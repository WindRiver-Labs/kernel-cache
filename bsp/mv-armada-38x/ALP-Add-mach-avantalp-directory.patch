From 7ba38f9f250411aff9c3709a301fe2203e2a642b Mon Sep 17 00:00:00 2001
From: Kosta Zertsekel <konszert@marvell.com>
Date: Thu, 17 Jan 2013 16:05:25 +0200
Subject: [PATCH 0446/1825] ALP: Add mach-avantalp directory

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 4a0795b441fc1a39f24e10fe0d8281c2179daaca

Not supposed to compile.

Signed-off-by: Kosta Zertsekel <konszert@marvell.com>
Change-Id: I782071defff3de0e9b94c0d09a6b5057684e55bf
Reviewed-on: http://vgitil04.il.marvell.com:8080/1222
Reviewed-by: Eran Ben-Avi <benavi@marvell.com>
Tested-by: Eran Ben-Avi <benavi@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/Kconfig                                  |   34 +-
 arch/arm/Makefile                                 |    1 +
 arch/arm/configs/avanta_lp_fpga_defconfig         |  191 +++
 arch/arm/mach-avantalp/Kconfig                    |   69 +
 arch/arm/mach-avantalp/Makefile                   |  205 +++
 arch/arm/mach-avantalp/Makefile.boot              |    9 +
 arch/arm/mach-avantalp/ca9x2.h                    |   94 ++
 arch/arm/mach-avantalp/clock.c                    |   50 +
 arch/arm/mach-avantalp/clock.h                    |    5 +
 arch/arm/mach-avantalp/config/mvRules.mk          |  185 +++
 arch/arm/mach-avantalp/config/mvSysCesaConfig.h   |   45 +
 arch/arm/mach-avantalp/config/mvSysCntmrConfig.h  |   36 +
 arch/arm/mach-avantalp/config/mvSysDdrConfig.h    |   45 +
 arch/arm/mach-avantalp/config/mvSysEthConfig.h    |  198 +++
 arch/arm/mach-avantalp/config/mvSysEthPhyConfig.h |   32 +
 arch/arm/mach-avantalp/config/mvSysGppConfig.h    |   37 +
 arch/arm/mach-avantalp/config/mvSysHwConfig.h     |  309 +++++
 arch/arm/mach-avantalp/config/mvSysNfcConfig.h    |   36 +
 arch/arm/mach-avantalp/config/mvSysPciConfig.h    |   26 +
 arch/arm/mach-avantalp/config/mvSysPexConfig.h    |   50 +
 arch/arm/mach-avantalp/config/mvSysPonConfig.h    |   38 +
 arch/arm/mach-avantalp/config/mvSysRtcConfig.h    |   36 +
 arch/arm/mach-avantalp/config/mvSysSataConfig.h   |   36 +
 arch/arm/mach-avantalp/config/mvSysSdmmcConfig.h  |   37 +
 arch/arm/mach-avantalp/config/mvSysSpiConfig.h    |   36 +
 arch/arm/mach-avantalp/config/mvSysTdmConfig.h    |   68 +
 arch/arm/mach-avantalp/config/mvSysTsConfig.h     |   39 +
 arch/arm/mach-avantalp/config/mvSysTwsiConfig.h   |   41 +
 arch/arm/mach-avantalp/config/mvSysUsbConfig.h    |   36 +
 arch/arm/mach-avantalp/config/mvSysXorConfig.h    |   36 +
 arch/arm/mach-avantalp/core.c                     |  747 +++++++++++
 arch/arm/mach-avantalp/core.h                     |   16 +
 arch/arm/mach-avantalp/dump_cp15_regs.c           |  219 ++++
 arch/arm/mach-avantalp/export.c                   |  217 ++++
 arch/arm/mach-avantalp/flashmap.c                 |  255 ++++
 arch/arm/mach-avantalp/headsmp.S                  |   40 +
 arch/arm/mach-avantalp/hotplug.c                  |  123 ++
 arch/arm/mach-avantalp/hwmon.c                    |  399 ++++++
 arch/arm/mach-avantalp/include/mach/avantalp.h    |  351 ++++++
 arch/arm/mach-avantalp/include/mach/clkdev.h      |    7 +
 arch/arm/mach-avantalp/include/mach/debug-macro.S |   24 +
 arch/arm/mach-avantalp/include/mach/dma.h         |   16 +
 arch/arm/mach-avantalp/include/mach/dove_bl.h     |   35 +
 arch/arm/mach-avantalp/include/mach/entry-macro.S |   17 +
 arch/arm/mach-avantalp/include/mach/gpio.h        |   55 +
 arch/arm/mach-avantalp/include/mach/hardware.h    |   14 +
 arch/arm/mach-avantalp/include/mach/ide.h         |   15 +
 arch/arm/mach-avantalp/include/mach/io.h          |   32 +
 arch/arm/mach-avantalp/include/mach/irqs.h        |  159 +++
 arch/arm/mach-avantalp/include/mach/kw_macro.h    |   39 +
 arch/arm/mach-avantalp/include/mach/memory.h      |   44 +
 arch/arm/mach-avantalp/include/mach/param.h       |   15 +
 arch/arm/mach-avantalp/include/mach/serial.h      |   41 +
 arch/arm/mach-avantalp/include/mach/smp.h         |   23 +
 arch/arm/mach-avantalp/include/mach/system.h      |   37 +
 arch/arm/mach-avantalp/include/mach/timex.h       |    9 +
 arch/arm/mach-avantalp/include/mach/uncompress.h  |  138 ++
 arch/arm/mach-avantalp/include/mach/vmalloc.h     |   11 +
 arch/arm/mach-avantalp/leds.c                     |   49 +
 arch/arm/mach-avantalp/localtimer.c               |   27 +
 arch/arm/mach-avantalp/mpp.h                      |   34 +
 arch/arm/mach-avantalp/mv_hal_if/mvSysCesa.c      |  122 ++
 arch/arm/mach-avantalp/mv_hal_if/mvSysCesaApi.h   |   71 ++
 arch/arm/mach-avantalp/mv_hal_if/mvSysDdr.c       |  134 ++
 arch/arm/mach-avantalp/mv_hal_if/mvSysEth.c       |  132 ++
 arch/arm/mach-avantalp/mv_hal_if/mvSysEthApi.h    |   71 ++
 arch/arm/mach-avantalp/mv_hal_if/mvSysEthPhy.c    |  104 ++
 arch/arm/mach-avantalp/mv_hal_if/mvSysEthPhyApi.h |   71 ++
 arch/arm/mach-avantalp/mv_hal_if/mvSysNeta.c      |  150 +++
 arch/arm/mach-avantalp/mv_hal_if/mvSysNetaApi.h   |   71 ++
 arch/arm/mach-avantalp/mv_hal_if/mvSysPci.c       | 1382 +++++++++++++++++++++
 arch/arm/mach-avantalp/mv_hal_if/mvSysPci.h       |  256 ++++
 arch/arm/mach-avantalp/mv_hal_if/mvSysPex.c       |  106 ++
 arch/arm/mach-avantalp/mv_hal_if/mvSysPexApi.h    |   71 ++
 arch/arm/mach-avantalp/mv_hal_if/mvSysSFlash.c    |  226 ++++
 arch/arm/mach-avantalp/mv_hal_if/mvSysSata.c      |   82 ++
 arch/arm/mach-avantalp/mv_hal_if/mvSysSataApi.h   |   71 ++
 arch/arm/mach-avantalp/mv_hal_if/mvSysSpi.c       |  126 ++
 arch/arm/mach-avantalp/mv_hal_if/mvSysSpiApi.h    |   70 +
 arch/arm/mach-avantalp/mv_hal_if/mvSysTdm.c       |  236 ++++
 arch/arm/mach-avantalp/mv_hal_if/mvSysTdmApi.h    |   78 ++
 arch/arm/mach-avantalp/mv_hal_if/mvSysTs.c        |   87 ++
 arch/arm/mach-avantalp/mv_hal_if/mvSysTsApi.h     |   73 ++
 arch/arm/mach-avantalp/mv_hal_if/mvSysUsb.c       |  103 ++
 arch/arm/mach-avantalp/mv_hal_if/mvSysUsbApi.h    |   70 +
 arch/arm/mach-avantalp/mv_hal_if/mvSysXor.c       |   87 ++
 arch/arm/mach-avantalp/mv_hal_if/mvSysXorApi.h    |   70 +
 arch/arm/mach-avantalp/pci.c                      |  243 ++++
 arch/arm/mach-avantalp/pex.c                      |  540 ++++++++
 arch/arm/mach-avantalp/platsmp.c                  |  174 +++
 arch/arm/mach-avantalp/pm.c                       |  159 +++
 arch/arm/mach-avantalp/proc_aurora_dbg.c          |   88 ++
 arch/arm/mach-avantalp/sysmap.c                   |  211 ++++
 arch/arm/mach-avantalp/time.c                     |  165 +++
 arch/arm/mach-avantalp/usb.c                      |  190 +++
 arch/arm/mm/Kconfig                               |    4 +-
 arch/arm/mm/Makefile                              |    5 +-
 arch/arm/plat-armada/linux_oss/mvOs.h             |    7 +-
 98 files changed, 11163 insertions(+), 11 deletions(-)
 create mode 100644 arch/arm/configs/avanta_lp_fpga_defconfig
 create mode 100644 arch/arm/mach-avantalp/Kconfig
 create mode 100644 arch/arm/mach-avantalp/Makefile
 create mode 100644 arch/arm/mach-avantalp/Makefile.boot
 create mode 100644 arch/arm/mach-avantalp/ca9x2.h
 create mode 100644 arch/arm/mach-avantalp/clock.c
 create mode 100644 arch/arm/mach-avantalp/clock.h
 create mode 100644 arch/arm/mach-avantalp/config/mvRules.mk
 create mode 100644 arch/arm/mach-avantalp/config/mvSysCesaConfig.h
 create mode 100644 arch/arm/mach-avantalp/config/mvSysCntmrConfig.h
 create mode 100644 arch/arm/mach-avantalp/config/mvSysDdrConfig.h
 create mode 100644 arch/arm/mach-avantalp/config/mvSysEthConfig.h
 create mode 100644 arch/arm/mach-avantalp/config/mvSysEthPhyConfig.h
 create mode 100644 arch/arm/mach-avantalp/config/mvSysGppConfig.h
 create mode 100755 arch/arm/mach-avantalp/config/mvSysHwConfig.h
 create mode 100644 arch/arm/mach-avantalp/config/mvSysNfcConfig.h
 create mode 100644 arch/arm/mach-avantalp/config/mvSysPciConfig.h
 create mode 100644 arch/arm/mach-avantalp/config/mvSysPexConfig.h
 create mode 100644 arch/arm/mach-avantalp/config/mvSysPonConfig.h
 create mode 100644 arch/arm/mach-avantalp/config/mvSysRtcConfig.h
 create mode 100644 arch/arm/mach-avantalp/config/mvSysSataConfig.h
 create mode 100644 arch/arm/mach-avantalp/config/mvSysSdmmcConfig.h
 create mode 100644 arch/arm/mach-avantalp/config/mvSysSpiConfig.h
 create mode 100644 arch/arm/mach-avantalp/config/mvSysTdmConfig.h
 create mode 100644 arch/arm/mach-avantalp/config/mvSysTsConfig.h
 create mode 100644 arch/arm/mach-avantalp/config/mvSysTwsiConfig.h
 create mode 100644 arch/arm/mach-avantalp/config/mvSysUsbConfig.h
 create mode 100644 arch/arm/mach-avantalp/config/mvSysXorConfig.h
 create mode 100755 arch/arm/mach-avantalp/core.c
 create mode 100644 arch/arm/mach-avantalp/core.h
 create mode 100644 arch/arm/mach-avantalp/dump_cp15_regs.c
 create mode 100644 arch/arm/mach-avantalp/export.c
 create mode 100644 arch/arm/mach-avantalp/flashmap.c
 create mode 100644 arch/arm/mach-avantalp/headsmp.S
 create mode 100644 arch/arm/mach-avantalp/hotplug.c
 create mode 100644 arch/arm/mach-avantalp/hwmon.c
 create mode 100644 arch/arm/mach-avantalp/include/mach/avantalp.h
 create mode 100644 arch/arm/mach-avantalp/include/mach/clkdev.h
 create mode 100644 arch/arm/mach-avantalp/include/mach/debug-macro.S
 create mode 100644 arch/arm/mach-avantalp/include/mach/dma.h
 create mode 100644 arch/arm/mach-avantalp/include/mach/dove_bl.h
 create mode 100755 arch/arm/mach-avantalp/include/mach/entry-macro.S
 create mode 100644 arch/arm/mach-avantalp/include/mach/gpio.h
 create mode 100644 arch/arm/mach-avantalp/include/mach/hardware.h
 create mode 100644 arch/arm/mach-avantalp/include/mach/ide.h
 create mode 100644 arch/arm/mach-avantalp/include/mach/io.h
 create mode 100644 arch/arm/mach-avantalp/include/mach/irqs.h
 create mode 100644 arch/arm/mach-avantalp/include/mach/kw_macro.h
 create mode 100644 arch/arm/mach-avantalp/include/mach/memory.h
 create mode 100644 arch/arm/mach-avantalp/include/mach/param.h
 create mode 100644 arch/arm/mach-avantalp/include/mach/serial.h
 create mode 100644 arch/arm/mach-avantalp/include/mach/smp.h
 create mode 100644 arch/arm/mach-avantalp/include/mach/system.h
 create mode 100644 arch/arm/mach-avantalp/include/mach/timex.h
 create mode 100644 arch/arm/mach-avantalp/include/mach/uncompress.h
 create mode 100644 arch/arm/mach-avantalp/include/mach/vmalloc.h
 create mode 100644 arch/arm/mach-avantalp/leds.c
 create mode 100644 arch/arm/mach-avantalp/localtimer.c
 create mode 100644 arch/arm/mach-avantalp/mpp.h
 create mode 100644 arch/arm/mach-avantalp/mv_hal_if/mvSysCesa.c
 create mode 100644 arch/arm/mach-avantalp/mv_hal_if/mvSysCesaApi.h
 create mode 100644 arch/arm/mach-avantalp/mv_hal_if/mvSysDdr.c
 create mode 100644 arch/arm/mach-avantalp/mv_hal_if/mvSysEth.c
 create mode 100644 arch/arm/mach-avantalp/mv_hal_if/mvSysEthApi.h
 create mode 100644 arch/arm/mach-avantalp/mv_hal_if/mvSysEthPhy.c
 create mode 100644 arch/arm/mach-avantalp/mv_hal_if/mvSysEthPhyApi.h
 create mode 100644 arch/arm/mach-avantalp/mv_hal_if/mvSysNeta.c
 create mode 100644 arch/arm/mach-avantalp/mv_hal_if/mvSysNetaApi.h
 create mode 100644 arch/arm/mach-avantalp/mv_hal_if/mvSysPci.c
 create mode 100644 arch/arm/mach-avantalp/mv_hal_if/mvSysPci.h
 create mode 100644 arch/arm/mach-avantalp/mv_hal_if/mvSysPex.c
 create mode 100644 arch/arm/mach-avantalp/mv_hal_if/mvSysPexApi.h
 create mode 100644 arch/arm/mach-avantalp/mv_hal_if/mvSysSFlash.c
 create mode 100644 arch/arm/mach-avantalp/mv_hal_if/mvSysSata.c
 create mode 100644 arch/arm/mach-avantalp/mv_hal_if/mvSysSataApi.h
 create mode 100644 arch/arm/mach-avantalp/mv_hal_if/mvSysSpi.c
 create mode 100644 arch/arm/mach-avantalp/mv_hal_if/mvSysSpiApi.h
 create mode 100644 arch/arm/mach-avantalp/mv_hal_if/mvSysTdm.c
 create mode 100644 arch/arm/mach-avantalp/mv_hal_if/mvSysTdmApi.h
 create mode 100644 arch/arm/mach-avantalp/mv_hal_if/mvSysTs.c
 create mode 100644 arch/arm/mach-avantalp/mv_hal_if/mvSysTsApi.h
 create mode 100644 arch/arm/mach-avantalp/mv_hal_if/mvSysUsb.c
 create mode 100644 arch/arm/mach-avantalp/mv_hal_if/mvSysUsbApi.h
 create mode 100644 arch/arm/mach-avantalp/mv_hal_if/mvSysXor.c
 create mode 100644 arch/arm/mach-avantalp/mv_hal_if/mvSysXorApi.h
 create mode 100644 arch/arm/mach-avantalp/pci.c
 create mode 100644 arch/arm/mach-avantalp/pex.c
 create mode 100644 arch/arm/mach-avantalp/platsmp.c
 create mode 100644 arch/arm/mach-avantalp/pm.c
 create mode 100644 arch/arm/mach-avantalp/proc_aurora_dbg.c
 create mode 100644 arch/arm/mach-avantalp/sysmap.c
 create mode 100644 arch/arm/mach-avantalp/time.c
 create mode 100644 arch/arm/mach-avantalp/usb.c

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index dcf90ad..fde2f2f 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -645,7 +645,6 @@ config ARCH_ARMADA_XP
 	select GENERIC_CLOCKEVENTS
 	select HAVE_SMP
 	select PLAT_ARMADA
-#	select PLAT_ORION
 	select HAVE_REGS_AND_STACK_ACCESS_API
 	select COMMON_CLKDEV
 	select CLKSRC_MMIO
@@ -655,7 +654,6 @@ config ARCH_ARMADA_XP
 	select DMABOUNCE
 	select ARCH_HAS_HOLES_MEMORYMODEL
 
-
 config ARCH_MV78XX0
 	bool "Marvell MV78xx0"
 	select CPU_FEROCEON
@@ -681,6 +679,37 @@ config ARCH_ORION5X
 	  Orion-1 (5181), Orion-VoIP (5181L), Orion-NAS (5182),
 	  Orion-2 (5281), Orion-1-90 (6183).
 
+config ARCH_AVANTA_LP
+bool "Marvell Avanta LP"
+#	select PCI
+#	select ARCH_HAS_CPUFREQ
+#	select ARCH_SUPPORTS_MSI
+	select ARCH_REQUIRE_GPIOLIB
+	select GENERIC_GPIO
+	select GENERIC_TIME
+	select GENERIC_CLOCKEVENTS
+	select PLAT_ARMADA
+	select HAVE_REGS_AND_STACK_ACCESS_API
+	select COMMON_CLKDEV
+	select CLKSRC_MMIO
+	select CLKDEV_LOOKUP
+	select NEED_MACH_MEMORY_H
+	select DMABOUNCE
+#	bool "ARM Ltd. Versatile Express family"
+#	select ARCH_WANT_OPTIONAL_GPIOLIB
+#	select ARM_AMBA
+#	select ARM_TIMER_SP804
+#	select CLKDEV_LOOKUP
+#	select HAVE_MACH_CLKDEV
+#	select GENERIC_CLOCKEVENTS
+#	select HAVE_CLK
+#	select HAVE_PATA_PLATFORM
+#	select ICST
+#	select PLAT_VERSATILE
+#	select PLAT_VERSATILE_CLCD
+	help
+	  Support for the Marvell Avanta-LP SoC Family
+ 
 config ARCH_MMP
 	bool "Marvell PXA168/910/MMP2"
 	depends on MMU
@@ -1149,6 +1178,7 @@ source "arch/arm/mach-sa1100/Kconfig"
 
 source "arch/arm/mach-armada370/Kconfig"
 source "arch/arm/mach-armadaxp/Kconfig"
+source "arch/arm/mach-avantalp/Kconfig"
 source "arch/arm/plat-armada/Kconfig"
 
 source "arch/arm/plat-samsung/Kconfig"
diff --git a/arch/arm/Makefile b/arch/arm/Makefile
index cf5ffd9..8abb999 100644
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -203,6 +203,7 @@ machine-$(CONFIG_MACH_SPEAR320)		:= spear3xx
 machine-$(CONFIG_MACH_SPEAR600)		:= spear6xx
 machine-$(CONFIG_ARCH_ZYNQ)		:= zynq
 machine-$(CONFIG_ARCH_ARMADA_XP)	:= armadaxp
+machine-$(CONFIG_ARCH_AVANTA_LP)	:= avantalp
 
 # Platform directory name.  This list is sorted alphanumerically
 # by CONFIG_* macro name.
diff --git a/arch/arm/configs/avanta_lp_fpga_defconfig b/arch/arm/configs/avanta_lp_fpga_defconfig
new file mode 100644
index 0000000..6756e7b
--- /dev/null
+++ b/arch/arm/configs/avanta_lp_fpga_defconfig
@@ -0,0 +1,191 @@
+# CONFIG_ARM_PATCH_PHYS_VIRT is not set
+CONFIG_EXPERIMENTAL=y
+CONFIG_SYSVIPC=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_EMBEDDED=y
+CONFIG_SLAB=y
+CONFIG_PROFILING=y
+CONFIG_OPROFILE=y
+CONFIG_KPROBES=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_BLK_DEV_BSG is not set
+CONFIG_ARCH_AVANTA_LP=y
+CONFIG_AVANTA_LP_REV_XX=y
+CONFIG_MV_INCLUDE_PCI=y
+# CONFIG_MV_INCLUDE_XOR is not set
+# CONFIG_MV_INCLUDE_NFC is not set
+# CONFIG_MV_INCLUDE_LEGACY_NAND is not set
+# CONFIG_MV_INCLUDE_SWITCH is not set
+# CONFIG_MV_INCLUDE_SFLASH_MTD is not set
+CONFIG_MV_ETH_NETA=y
+CONFIG_MV_ETH_PORTS_NUM=4
+CONFIG_MV_ETH_RXQ=8
+CONFIG_MV_ETH_TXQ=8
+CONFIG_NET_SKB_HEADROOM=96
+CONFIG_MV_ETH_NFP=y
+CONFIG_MV_ETH_BM_PORT_0_SHORT_BUF_NUM=4096
+CONFIG_MV_ETH_BM_PORT_1_SHORT_BUF_NUM=4096
+CONFIG_MV_ETH_BM_PORT_2_SHORT_BUF_NUM=4096
+# CONFIG_MV_ETH_PNC is not set
+CONFIG_MV_ETH_GRO_DEF=y
+CONFIG_MV_ETH_TSO_DEF=y
+# CONFIG_MV_ETH_STAT_INF is not set
+CONFIG_MV_ETH_RX_COAL_PKTS=64
+CONFIG_MV_ETH_RX_COAL_USEC=200
+CONFIG_MV_ETH_RX_DESC_PREFETCH=y
+CONFIG_MV_ETH_RX_PKT_PREFETCH=y
+CONFIG_MV_ETH_RX_POLL_WEIGHT=128
+# CONFIG_MV_ETH_REDUCE_BURST_SIZE_WA is not set
+# CONFIG_SWP_EMULATE is not set
+# CONFIG_SHEEVA_ERRATA_ARM_CPU_5980 is not set
+# CONFIG_SHEEVA_ERRATA_ARM_CPU_6043 is not set
+# CONFIG_SHEEVA_ERRATA_ARM_CPU_6075 is not set
+# CONFIG_SHEEVA_ERRATA_ARM_CPU_6076 is not set
+# CONFIG_SHEEVA_ERRATA_ARM_CPU_6136 is not set
+CONFIG_PCI_DEBUG=y
+CONFIG_SMP=y
+CONFIG_AEABI=y
+CONFIG_UACCESS_WITH_MEMCPY=y
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_VFP=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+# CONFIG_SUSPEND is not set
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IPV6 is not set
+CONFIG_BRIDGE=y
+CONFIG_NET_PKTGEN=m
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_MTD=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_CFI=y
+CONFIG_MTD_JEDECPROBE=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_GEOMETRY=y
+# CONFIG_MTD_MAP_BANK_WIDTH_4 is not set
+CONFIG_MTD_CFI_INTELEXT=y
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_M25P80=y
+CONFIG_MTD_NAND=y
+CONFIG_MTD_NAND_VERIFY_WRITE=y
+CONFIG_MTD_UBI=y
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_SCSI_PROC_FS is not set
+CONFIG_BLK_DEV_SD=y
+CONFIG_BLK_DEV_SR=m
+CONFIG_CHR_DEV_SG=m
+CONFIG_ATA=y
+CONFIG_SATA_MV=y
+CONFIG_MD=y
+CONFIG_BLK_DEV_MD=y
+CONFIG_MD_LINEAR=y
+CONFIG_MD_RAID0=y
+CONFIG_MD_RAID1=y
+CONFIG_MD_RAID10=y
+CONFIG_MD_RAID456=y
+CONFIG_NETDEVICES=y
+# CONFIG_NET_VENDOR_3COM is not set
+CONFIG_E100=y
+CONFIG_E1000E=y
+CONFIG_SKY2=y
+CONFIG_PHYLIB=y
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_SERIO is not set
+# CONFIG_VT is not set
+CONFIG_LEGACY_PTY_COUNT=16
+# CONFIG_DEVKMEM is not set
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+# CONFIG_SERIAL_8250_PCI is not set
+CONFIG_SERIAL_8250_RUNTIME_UARTS=2
+# CONFIG_HW_RANDOM is not set
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_SPI=y
+CONFIG_GPIO_SYSFS=y
+# CONFIG_HWMON is not set
+CONFIG_HID_A4TECH=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_EZKEY=y
+CONFIG_HID_GYRATION=y
+CONFIG_HID_LOGITECH=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_PANTHERLORD=y
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+CONFIG_USB=y
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_PRINTER=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+CONFIG_NEW_LEDS=y
+CONFIG_RTC_CLASS=y
+CONFIG_DMADEVICES=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+# CONFIG_EXT3_FS_XATTR is not set
+CONFIG_XFS_FS=y
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+CONFIG_UDF_FS=m
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_JFFS2_FS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_ROOT_NFS=y
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_850=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_ISO8859_2=y
+CONFIG_NLS_UTF8=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_DEBUG_FS=y
+CONFIG_DETECT_HUNG_TASK=y
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_DEBUG_BUGVERBOSE is not set
+CONFIG_DEBUG_INFO=y
+# CONFIG_FTRACE is not set
+# CONFIG_ARM_UNWIND is not set
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_LL=y
+CONFIG_EARLY_PRINTK=y
+CONFIG_CRYPTO_CBC=m
+CONFIG_CRYPTO_ECB=m
+CONFIG_CRYPTO_PCBC=m
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_LZO=y
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+CONFIG_LIBCRC32C=y
diff --git a/arch/arm/mach-avantalp/Kconfig b/arch/arm/mach-avantalp/Kconfig
new file mode 100644
index 0000000..44d89f4
--- /dev/null
+++ b/arch/arm/mach-avantalp/Kconfig
@@ -0,0 +1,69 @@
+if ARCH_AVANTA_LP
+
+config  MV_HAL_RULES_PATH
+        string "path of the mvRules.mk file for HAL drivers"
+        default "arch/arm/mach-avantalp/mv_hal_support/mvRules.mk"
+        ---help---
+	
+#source "arch/arm/plat-orion/mv_hal_drivers/Kconfig"
+
+menu "Marvell Avanta Options"
+
+config AVANTA_LP
+	bool "Avanta LP SoC Family"
+	default y
+
+choice
+	prompt "Avanta LP Chip revision"
+	depends on AVANTA_LP
+	default AVANTA_LP_REV_XX
+
+config  AVANTA_LP_REV_XX
+	bool "Avanta LP SoC devices"
+	select ARM_GIC
+	select ARM_ERRATA_720789
+	select ARM_ERRATA_751472
+	select ARM_ERRATA_753970
+	---help---
+	Choosing this option will generate a linux kernel for the
+	  Avanta LP devices
+
+endchoice
+
+config MACH_AVANTA_LP_FPGA
+	bool "Marvell Armada XP Development Board"	
+	default y
+	help
+
+config CFU_DRAM_BYPASS
+        bool "Bypass CFU to DRAM via Punit"
+	default n
+	help
+
+config AVANTA_LP_SPARSEMEM
+	bool "Use sparse memory model"
+	select ARCH_SPARSEMEM_ENABLE
+	default n
+
+config AVANTA_LP_USE_IRQ_INDIRECT_MODE
+	bool "Use indirect mode for handling interrupt controller"
+	default n
+	help
+		This mode enables using indirect mode for handling interrupts, in this
+		mode, the Interrupt Set Enable/Clear Enable registers are used for
+		unmasking/masking shared interrupts, and Interrupt Set Mask/Clear Mask
+		used for masking/unmasking per-cpu interrupts. Without this mode, the
+		Interrupt Source register is used directly. and this requires the
+		following:
+		- Locking mechanism to protect the access to the Interrupt Source Register
+		- Reads operation of those registers.
+		- Using the affinity variable for restoring the mask values
+
+config AVANTA_LP_USE_IRQ_INTERRUPT_ACK
+       bool "Use Interrupt Ack register to detect pending interrupts"
+       default n
+       help
+
+endmenu
+
+endif
diff --git a/arch/arm/mach-avantalp/Makefile b/arch/arm/mach-avantalp/Makefile
new file mode 100644
index 0000000..58824e2
--- /dev/null
+++ b/arch/arm/mach-avantalp/Makefile
@@ -0,0 +1,205 @@
+#*******************************************************************************
+# Marvell GPL License Option
+#
+# If you received this File from Marvell, you may opt to use, redistribute and/or
+# modify this File in accordance with the terms and conditions of the General
+# Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+# available along with the File in the license.txt file or by writing to the Free
+# Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+# on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+#
+# THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+# WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+# DISCLAIMED.  The GPL License provides additional details about this warranty
+# disclaimer.
+#*******************************************************************************/
+include 	  $(srctree)/arch/arm/mach-avantalp/config/mvRules.mk
+
+
+# Objects list
+COMMON_OBJS	= $(COMMON_DIR)/mvDebug.o $(COMMON_DIR)/mvCommon.o $(COMMON_DIR)/mvStack.o $(COMMON_DIR)/mvList.o $(COMMON_DIR)/mvIpc.o
+
+OSSERVICES_OBJS	= $(OSSERV_DIR)/mvOs.o
+
+HAL_OBJS	= $(HAL_RTC_DIR)/mvRtc.o					\
+                  $(HAL_CNTMR_DIR)/mvCntmr.o					\
+		  $(HAL_TWSI_DIR)/mvTwsi.o					\
+                  $(HAL_UART_DIR)/mvUart.o $(HAL_GPP_DIR)/mvGpp.o               \
+                  $(HAL_DRAM_DIR)/mvDramIf.o					\
+		  $(HAL_IF_DIR)/mvSysDdr.o
+#		  $(HAL_DRAM_SPD_DIR)/mvSpd.o
+
+KW_FAM_OBJS	= $(BOARD_ENV_DIR)/mvBoardEnvSpec.o $(SOC_ENV_DIR)/mvCtrlEnvLib.o	\
+		  $(BOARD_ENV_DIR)/mvBoardEnvLib.o $(SOC_ENV_DIR)/mvCtrlEnvAddrDec.o 	\
+		  $(SOC_SYS_DIR)/mvAhbToMbus.o $(SOC_SYS_DIR)/mvCpuIf.o 		\
+		  $(SOC_CPU_DIR)/mvCpu.o $(SOC_DEVICE_DIR)/mvDevice.o
+
+QD_OBJS		= $(HAL_QD_DIR)/src/driver/gtDrvConfig.o $(HAL_QD_DIR)/src/driver/gtDrvEvents.o \
+                  $(HAL_QD_DIR)/src/driver/gtHwCntl.o $(HAL_QD_DIR)/src/platform/gtMiiSmiIf.o	\
+                  $(HAL_QD_DIR)/src/platform/platformDeps.o $(HAL_QD_DIR)/src/platform/gtSem.o	\
+                  $(HAL_QD_DIR)/src/platform/gtDebug.o $(HAL_QD_DIR)/src/msapi/gtBrgFdb.o 	\
+                  $(HAL_QD_DIR)/src/msapi/gtBrgStp.o $(HAL_QD_DIR)/src/msapi/gtBrgVlan.o 	\
+                  $(HAL_QD_DIR)/src/msapi/gtEvents.o $(HAL_QD_DIR)/src/msapi/gtPortCtrl.o 	\
+                  $(HAL_QD_DIR)/src/msapi/gtPortStat.o $(HAL_QD_DIR)/src/msapi/gtPortStatus.o 	\
+                  $(HAL_QD_DIR)/src/msapi/gtQosMap.o $(HAL_QD_DIR)/src/msapi/gtPIRL.o  		\
+                  $(HAL_QD_DIR)/src/msapi/gtPhyCtrl.o $(HAL_QD_DIR)/src/msapi/gtPhyInt.o 	\
+                  $(HAL_QD_DIR)/src/msapi/gtSysConfig.o $(HAL_QD_DIR)/src/msapi/gtSysCtrl.o	\
+                  $(HAL_QD_DIR)/src/msapi/gtVersion.o $(HAL_QD_DIR)/src/msapi/gtUtils.o 	\
+                  $(HAL_QD_DIR)/src/msapi/gtBrgVtu.o $(HAL_QD_DIR)/src/msapi/gtPortRmon.o 	\
+                  $(HAL_QD_DIR)/src/msapi/gtSysStatus.o $(HAL_QD_DIR)/src/msapi/gtPortRateCtrl.o\
+                  $(HAL_QD_DIR)/src/msapi/gtPortPav.o $(HAL_QD_DIR)/src/msapi/gtVct.o		\
+		  $(HAL_QD_DIR)/src/msapi/gtPIRL2.o $(HAL_QD_DIR)/src/msapi/gtCCPVT.o		\
+		  $(HAL_QD_DIR)/src/msapi/gtPCSCtrl.o $(HAL_QD_DIR)/src/msapi/gtBrgStu.o
+
+LSP_OBJS        = core.o time.o leds.o sysmap.o export.o clock.o
+
+obj-y   				:=  avantalp.o
+avantalp-objs  				:=$(LSP_OBJS) $(COMMON_OBJS) $(OSSERVICES_OBJS) $(HAL_OBJS) 	\
+					  $(KW_FAM_OBJS)
+
+avantalp-$(CONFIG_MV_INCLUDE_SDIO) 	+= $(HAL_SDMMC_DIR)/mvSdmmcAddrDec.o
+avantalp-$(CONFIG_MV_INCLUDE_XOR) 	+= $(HAL_XOR_DIR)/mvXor.o $(HAL_XOR_DIR)/mvXorAddrDec.o		\
+					   $(HAL_IF_DIR)/mvSysXor.o
+avantalp-$(CONFIG_MV_INCLUDE_PEX) 	+= $(HAL_PEX_DIR)/mvPex.o					\
+					   $(HAL_IF_DIR)/mvSysPex.o $(HAL_PEX_DIR)/mvPexAddrDec.o
+avantalp-$(CONFIG_MV_INCLUDE_PCI) 	+= $(HAL_PCI_DIR)/mvPci.o $(HAL_IF_DIR)/mvSysPci.o
+avantalp-$(CONFIG_MV_INCLUDE_USB) 	+= $(HAL_USB_DIR)/mvUsb.o $(HAL_USB_DIR)/mvUsbAddrDec.o		\
+					   $(HAL_IF_DIR)/mvSysUsb.o
+avantalp-y				+= $(HAL_ETHPHY_DIR)/mvEthPhy.o $(HAL_IF_DIR)/mvSysEthPhy.o
+
+# Legacy Giga driver
+ifeq ($(CONFIG_MV_ETH_LEGACY),y)
+avantalp-$(CONFIG_MV_ETH_LEGACY)	+= $(HAL_ETH_GBE_DIR)/mvEth.o $(HAL_ETH_GBE_DIR)/mvEthDebug.o \
+					   $(HAL_ETH_GBE_DIR)/mvEthAddrDec.o $(HAL_IF_DIR)/mvSysEth.o
+endif
+
+# NETA Giga driver
+ifeq ($(CONFIG_MV_ETH_NETA),y)
+avantalp-$(CONFIG_MV_ETH_NETA)	        += $(HAL_ETH_GBE_DIR)/mvNeta.o $(HAL_ETH_GBE_DIR)/mvNetaDebug.o \
+					   $(HAL_ETH_GBE_DIR)/mvNetaAddrDec.o $(HAL_IF_DIR)/mvSysNeta.o
+avantalp-$(CONFIG_MV_ETH_PNC)    	+= $(HAL_ETH_PNC_DIR)/mvTcam.o  $(HAL_ETH_PNC_DIR)/mvPncAging.o \
+					   $(HAL_ETH_PNC_DIR)/mvPnc.o $(HAL_ETH_PNC_DIR)/mvPncLb.o
+avantalp-$(CONFIG_MV_ETH_PNC_L3_FLOW)   += $(HAL_ETH_PNC_DIR)/mvPncRxq.o
+avantalp-$(CONFIG_MV_ETH_PNC_WOL)       += $(HAL_ETH_PNC_DIR)/mvPncWol.o
+avantalp-$(CONFIG_MV_ETH_BM) 	        += $(HAL_ETH_BM_DIR)/mvBm.o
+avantalp-$(CONFIG_MV_ETH_PMT)	        += $(HAL_ETH_PMT_DIR)/mvPmt.o
+avantalp-$(CONFIG_MV_ETH_HWF)           += $(HAL_ETH_GBE_DIR)/mvHwf.o
+endif
+
+avantalp-$(CONFIG_MV_INCLUDE_CESA) 	+= $(HAL_CESA_DIR)/mvCesa.o $(HAL_CESA_DIR)/mvCesaIf.o		\
+					   $(HAL_CESA_DIR)/mvCesaDebug.o 				\
+					   $(HAL_CESA_DIR)/mvCesaAddrDec.o				\
+                        		   $(HAL_CESA_DIR)/mvMD5.o $(HAL_CESA_DIR)/mvSHA1.o 		\
+					   $(HAL_CESA_DIR)/mvSHA256.o					\
+					   $(HAL_CESA_AES_DIR)/mvAesAlg.o $(HAL_CESA_AES_DIR)/mvAesApi.o\
+					   $(HAL_IF_DIR)/mvSysCesa.o
+avantalp-$(CONFIG_MV_CESA_TEST)         += $(HAL_CESA_DIR)/mvCesaTest.o
+
+avantalp-$(CONFIG_MV_INCLUDE_INTEG_SATA)+= $(HAL_IF_DIR)/mvSysSata.o $(HAL_SATA_DIR)/mvSataSoc.o	\
+					   $(HAL_SATA_DIR)/mvSataAddrDec.o
+avantalp-$(CONFIG_MV_INCLUDE_SPI) 	+= $(HAL_SPI_DIR)/mvSpi.o $(HAL_SPI_DIR)/mvSpiCmnd.o 		\
+                         		   $(HAL_SFLASH_DIR)/mvSFlash.o $(HAL_IF_DIR)/mvSysSFlash.o	\
+					   $(HAL_IF_DIR)/mvSysSpi.o
+avantalp-$(CONFIG_MV_INCLUDE_NFC)	+= $(HAL_NFC_DIR)/mvNfc.o
+avantalp-$(CONFIG_MV_INCLUDE_AUDIO) 	+= $(HAL_AUDIO_DIR)/mvAudio.o $(HAL_IF_DIR)/mvSysAudio.o	\
+					   $(HAL_AUDIO_DIR)/mvAudioAddrDec.o
+avantalp-$(CONFIG_MV_INCLUDE_TS) 	+= $(HAL_TS_DIR)/mvTsu.o $(HAL_IF_DIR)/mvSysTs.o		\
+					   $(HAL_TS_DIR)/mvTsuAddrDec.o
+avantalp-$(CONFIG_MV_CPU_PERF_CNTRS)    += $(HAL_CPU_DIR)/mvCpuCntrs.o $(HAL_CPU_DIR)/pj4/mvPJ4Cntrs.o
+avantalp-$(CONFIG_PCIE_VIRTUAL_BRIDGE_SUPPORT) += $(HAL_PEX_DIR)/mvVrtBrgPex.o
+avantalp-$(CONFIG_MV_CPU_L2_PERF_CNTRS) += $(HAL_CPU_DIR)/mvCpuL2Cntrs.o
+
+obj-$(CONFIG_MV_INCLUDE_SWITCH) 	+= $(QD_OBJS)
+
+# drivers part
+
+ifeq ($(CONFIG_MV_ETH_NETA),y)
+obj-$(CONFIG_MV_ETH_PNC)                += $(LSP_PNC_DIR)/pnc_sysfs.o
+obj-$(CONFIG_MV_ETH_PNC_L3_FLOW)        += $(LSP_PNC_DIR)/rxq_map_sysfs.o
+obj-$(CONFIG_MV_ETH_BM)                 += $(LSP_BM_DIR)/bm_sysfs.o  $(LSP_BM_DIR)/mv_eth_bm.o
+obj-$(CONFIG_MV_ETH_PNC_WOL)            += $(LSP_PNC_DIR)/wol_sysfs.o
+obj-$(CONFIG_MV_ETH_PMT)		+= $(LSP_PMT_DIR)/pmt_sysfs.o
+obj-$(CONFIG_MV_ETH_HWF)        	+= $(LSP_HWF_DIR)/hwf_sysfs.o
+ifndef CONFIG_MV_ETH_BM_CPU
+obj-$(CONFIG_MV_ETH_HWF)		+=  $(LSP_HWF_DIR)/hwf_bm.o
+endif
+obj-$(CONFIG_MV_ETH_L2FW)               += $(LSP_L2FW_DIR)/l2fw_sysfs.o $(LSP_L2FW_DIR)/mv_eth_l2fw.o
+obj-$(CONFIG_MV_ETH_L2SEC)              += $(LSP_L2FW_DIR)/mv_eth_l2sec.o
+endif
+
+obj-$(CONFIG_MV_INCLUDE_GIG_ETH)        += $(LSP_PHY_DIR)/phy_sysfs.o
+
+obj-$(CONFIG_MV_USE_XOR_ENGINE) 	+= $(PLAT_DRIVERS)/mv_xor/
+obj-$(CONFIG_MV_CESA) 			+= $(PLAT_DRIVERS)/mv_cesa/
+obj-$(CONFIG_MV_IPC_DRIVER)		+= $(PLAT_DRIVERS)/mv_ipc/
+obj-$(CONFIG_MV_IPC_NET)		+= $(PLAT_DRIVERS)/mv_ipc_net/
+#obj-y					+= $(PLAT_DRIVERS)/mv_btns/
+obj-y					+= $(PLAT_DRIVERS)/mv_gpio/
+obj-$(CONFIG_MV_DBG_TRACE)              += $(PLAT_DRIVERS)/mv_trace/
+obj-$(CONFIG_MV_INCLUDE_SWITCH)         += $(LSP_SWITCH_DIR)/
+obj-$(CONFIG_SENSORS_ARMADA_XP)		+= hwmon.o
+# The rest of the drivers are compiled through the driver dir directly.
+
+
+# LSP part
+avantalp-$(CONFIG_MV_INCLUDE_USB)    	+= usb.o
+avantalp-$(CONFIG_MV_INCLUDE_PCI)	+= pci.o
+avantalp-$(CONFIG_MV_INCLUDE_PEX)	+= pex.o
+avantalp-$(CONFIG_FEROCEON_PROC) 	+= $(PLAT_DRIVERS)/mv_proc/proc.o
+avantalp-$(CONFIG_SMP)			+= platsmp.o headsmp.o
+avantalp-$(CONFIG_MV_AMP_ENABLE)	+= $(SOC_ENV_DIR)/mvUnitMap.o
+avantalp-$(CONFIG_MV_AMP_ENABLE)	+= $(SOC_ENV_DIR)/mvSemaphore.o
+avantalp-$(CONFIG_PROC_FS)		+= dump_cp15_regs.o
+obj-$(CONFIG_FB_DOVE_CLCD)		+= clcd.o
+obj-$(CONFIG_PM)			+= pm.o
+obj-$(CONFIG_LOCAL_TIMERS) += localtimer.o
+
+
+ifdef CONFIG_MV_ETH_NFP
+NFP_OBJS += $(LSP_NFP_MGR_DIR)/mv_nfp_mgr.o $(LSP_NFP_MGR_DIR)/nfp_sysfs.o
+NFP_OBJS += $(LSP_NET_DEV_DIR)/mv_eth_nfp.o $(HAL_ETH_NFP_DIR)/mvNfp.o
+endif
+
+ifdef CONFIG_MV_ETH_NFP_FIB
+NFP_OBJS += $(LSP_NFP_MGR_DIR)/nfp_fib_arp_sysfs.o
+NFP_OBJS += $(HAL_ETH_NFP_DIR)/mvNfpFib.o
+ifdef CONFIG_IPV6
+NFP_OBJS += $(LSP_NFP_MGR_DIR)/ipv6_parsing.o $(LSP_NFP_MGR_DIR)/nfp_fib6_arp_sysfs.o
+endif
+endif
+
+ifdef CONFIG_MV_ETH_NFP_CT
+NFP_OBJS += $(LSP_NFP_MGR_DIR)/nfp_ct_sysfs.o
+NFP_OBJS += $(HAL_ETH_NFP_DIR)/mvNfpCt.o
+ifdef CONFIG_IPV6
+NFP_OBJS += $(LSP_NFP_MGR_DIR)/nfp_ct6_sysfs.o
+endif
+endif
+
+ifdef CONFIG_MV_ETH_NFP_CLASSIFY
+NFP_OBJS += $(LSP_NFP_MGR_DIR)/nfp_classification_sysfs.o $(LSP_NFP_MGR_DIR)/nfp_exact_classification_sysfs.o \
+	   $(LSP_NFP_MGR_DIR)/nfp_prio_classification_sysfs.o
+endif
+
+ifdef CONFIG_MV_ETH_NFP_BRIDGE
+NFP_OBJS += $(LSP_NFP_MGR_DIR)/nfp_bridge_sysfs.o
+ifdef CONFIG_MV_ETH_NFP_FDB_MODE
+NFP_OBJS += $(HAL_ETH_NFP_DIR)/mvNfpFdb.o
+else
+NFP_OBJS += $(HAL_ETH_NFP_DIR)/mvNfpBridge.o
+endif
+endif
+
+ifdef CONFIG_MV_ETH_NFP_VLAN
+NFP_OBJS += $(LSP_NFP_MGR_DIR)/nfp_vlan_sysfs.o
+endif
+
+ifdef CONFIG_MV_ETH_NFP_PPP
+NFP_OBJS += $(LSP_NFP_MGR_DIR)/nfp_ppp_sysfs.o
+endif
+
+nfp-objs = $(NFP_OBJS)
+obj-$(CONFIG_MV_ETH_NFP) += nfp.o
+
+nfp_learn-objs = $(LSP_NFP_MGR_DIR)/mv_nfp_hooks.o
+obj-$(CONFIG_MV_ETH_NFP_LEARN) += nfp_learn.o
diff --git a/arch/arm/mach-avantalp/Makefile.boot b/arch/arm/mach-avantalp/Makefile.boot
new file mode 100644
index 0000000..0ef7d93
--- /dev/null
+++ b/arch/arm/mach-avantalp/Makefile.boot
@@ -0,0 +1,9 @@
+ifdef CONFIG_MV_AMP_ENABLE
+   zreladdr-y   := $(CONFIG_MV_ZREL_ADDR)
+params_phys-y   := $(CONFIG_MV_PARAM_PHYS)
+initrd_phys-y   := $(CONFIG_MV_INITRD_PHYS)
+else
+    zreladdr-y	:= 0x00008000
+ params_phys-y	:= 0x00000100
+ initrd_phys-y	:= 0x00800000
+endif
diff --git a/arch/arm/mach-avantalp/ca9x2.h b/arch/arm/mach-avantalp/ca9x2.h
new file mode 100644
index 0000000..68ddc38
--- /dev/null
+++ b/arch/arm/mach-avantalp/ca9x2.h
@@ -0,0 +1,94 @@
+#ifndef __MACH_MV_CA9X2_H
+#define __MACH_MV_CA9X2_H
+
+/*
+ * Physical base addresses
+ */
+#if 0
+#define MV_CA9X2_CLCDC		(0x10020000)
+#define MV_CA9X2_AXIRAM		(0x10060000)
+#define MV_CA9X2_DMC		(0x100e0000)
+#define MV_CA9X2_SMC		(0x100e1000)
+#define MV_CA9X2_SCC		(0x100e2000)
+
+#define MV_CA9X2_SP805_WDT	(0x100e5000)
+#define MV_CA9X2_TZPC		(0x100e6000)
+#define MV_CA9X2_GPIO		(0x100e8000)
+#define MV_CA9X2_FASTAXI	(0x100e9000)
+#define MV_CA9X2_SLOWAXI	(0x100ea000)
+#define MV_CA9X2_TZASC		(0x100ec000)
+#define MV_CA9X2_CORESIGHT	(0x10200000)
+
+#define MV_CA9X2_SYSTIMER	(0x1e004000)
+#define MV_CA9X2_SYSWDT		(0x1e007000)
+
+#define MV_CA9X2_SP804_TIMER	(0x100e4000)
+#define MV_CA9X2_TIMER0		(MV_CA9X2_SP804_TIMER + 0x000)
+#define MV_CA9X2_TIMER1		(MV_CA9X2_SP804_TIMER + 0x020)
+#endif
+
+#define MV_CA9X2_L2CC_OFFSET	(0x8000)
+
+#define MV_CA9X2_MPIC		(0xC000)
+#define A9_MPCORE_SCU		(MV_CA9X2_MPIC + 0x0000)
+#define A9_MPCORE_GIC_CPU	(MV_CA9X2_MPIC + 0x0100)
+#define A9_MPCORE_GIT		(MV_CA9X2_MPIC + 0x0200)
+#define A9_MPCORE_TWD		(MV_CA9X2_MPIC + 0x0600)
+#define A9_MPCORE_GIC_DIST	(MV_CA9X2_MPIC + 0x1000)
+
+/*
+ * Interrupts.  Those in {} are for AMBA devices
+ */
+#define IRQ_MV_CA9X2_CLCDC	{ 76 }
+#define IRQ_MV_CA9X2_DMC	{ -1 }
+#define IRQ_MV_CA9X2_SMC	{ 77, 78 }
+#define IRQ_MV_CA9X2_TIMER0	80
+#define IRQ_MV_CA9X2_TIMER1	81
+#define IRQ_MV_CA9X2_GPIO	{ 82 }
+#define IRQ_MV_CA9X2_PMU_CPU0	92
+#define IRQ_MV_CA9X2_PMU_CPU1	93
+#define IRQ_MV_CA9X2_PMU_CPU2	94
+#define IRQ_MV_CA9X2_PMU_CPU3	95
+
+/*
+ * Core tile IDs
+ */
+#define V2M_CT_ID_CA9		0x0c000191
+#define V2M_CT_ID_UNSUPPORTED	0xff000191
+#define V2M_CT_ID_MASK		0xff000fff
+
+struct ct_desc {
+	u32			id;
+	const char		*name;
+	void			(*map_io)(void);
+	void			(*init_early)(void);
+	void			(*init_irq)(void);
+	void			(*init_tile)(void);
+#ifdef CONFIG_SMP
+	void			(*init_cpu_map)(void);
+	void			(*smp_enable)(unsigned int);
+#endif
+};
+
+extern struct ct_desc *ct_desc;
+
+extern struct ct_desc ct_ca9x4_desc;
+
+#define AMBA_DEVICE(name,busid,base,plat)	\
+struct amba_device name##_device = {		\
+	.dev		= {			\
+		.coherent_dma_mask = ~0UL,	\
+		.init_name = busid,		\
+		.platform_data = plat,		\
+	},					\
+	.res		= {			\
+		.start	= base,			\
+		.end	= base + SZ_4K - 1,	\
+		.flags	= IORESOURCE_MEM,	\
+	},					\
+	.dma_mask	= ~0UL,			\
+	.irq		= IRQ_##base,		\
+	/* .dma		= DMA_##base,*/		\
+}
+
+#endif
diff --git a/arch/arm/mach-avantalp/clock.c b/arch/arm/mach-avantalp/clock.c
new file mode 100644
index 0000000..15b04ae
--- /dev/null
+++ b/arch/arm/mach-avantalp/clock.c
@@ -0,0 +1,50 @@
+/*
+ *  linux/arch/arm/mach-dove/clock.c
+ */
+
+/* TODO: Implement the functions below...	*/
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/string.h>
+#include <linux/clk.h>
+#include <linux/spinlock.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+
+#include <mach/hardware.h>
+
+#include "clock.h"
+
+int clk_enable(struct clk *clk)
+{
+	return 0;
+}
+EXPORT_SYMBOL(clk_enable);
+
+void clk_disable(struct clk *clk)
+{
+}
+EXPORT_SYMBOL(clk_disable);
+
+unsigned long clk_get_rate(struct clk *clk)
+{
+	return 0;
+}
+EXPORT_SYMBOL(clk_get_rate);
+
+
+void clks_register(struct clk *clks, size_t num)
+{
+}
+
+static int __init clk_init(void)
+{
+	/* TODO: Call clks_register with appropriate params. */
+	clks_register(NULL, 0);
+	return 0;
+}
+arch_initcall(clk_init);
diff --git a/arch/arm/mach-avantalp/clock.h b/arch/arm/mach-avantalp/clock.h
new file mode 100644
index 0000000..3fd3a3b
--- /dev/null
+++ b/arch/arm/mach-avantalp/clock.h
@@ -0,0 +1,5 @@
+struct clk {
+	unsigned int dummy;
+};
+
+void clks_register(struct clk *clks, size_t num);
diff --git a/arch/arm/mach-avantalp/config/mvRules.mk b/arch/arm/mach-avantalp/config/mvRules.mk
new file mode 100644
index 0000000..173e106
--- /dev/null
+++ b/arch/arm/mach-avantalp/config/mvRules.mk
@@ -0,0 +1,185 @@
+# This flags will be used only by the Marvell arch files compilation.
+
+###################################################################################################
+# General definitions
+###################################################################################################
+CPU_ARCH    = ARM
+CHIP        = 88F78xx0
+VENDOR      = Marvell
+ifeq ($(CONFIG_CPU_BIG_ENDIAN),y)
+ENDIAN      = BE
+else
+ENDIAN      = LE
+endif
+
+###################################################################################################
+# directory structure
+###################################################################################################
+# Main directory structure
+PLAT_PATH	  = ../plat-armada
+PLAT_DRIVERS	  = $(PLAT_PATH)/mv_drivers_lsp
+HAL_DIR           = $(PLAT_PATH)/mv_hal
+COMMON_DIR        = $(PLAT_PATH)/common
+OSSERV_DIR        = $(PLAT_PATH)/linux_oss
+CONFIG_DIR        = config
+HAL_IF		  = mv_hal_if
+
+# HALs
+HAL_ETHPHY_DIR    = $(HAL_DIR)/eth-phy
+HAL_FLASH_DIR     = $(HAL_DIR)/flash
+HAL_RTC_DIR       = $(HAL_DIR)/rtc/integ_rtc
+HAL_VOICEBAND     = $(HAL_DIR)/voiceband
+HAL_SLIC_DIR      = $(HAL_VOICEBAND)/slic
+HAL_DAA_DIR       = $(HAL_VOICEBAND)/daa
+HAL_SATA_DIR      = $(HAL_DIR)/sata/CoreDriver/
+HAL_QD_DIR        = $(HAL_DIR)/qd-dsdt
+HAL_SFLASH_DIR    = $(HAL_DIR)/sflash
+HAL_CNTMR_DIR     = $(HAL_DIR)/cntmr
+HAL_DRAM_DIR      = $(HAL_DIR)/ddr2_3/
+#HAL_DRAM_SPD_DIR  = $(HAL_DIR)/ddr2_3/spd
+HAL_GPP_DIR       = $(HAL_DIR)/gpp
+HAL_TWSI_DIR      = $(HAL_DIR)/twsi
+HAL_TWSI_ARCH_DIR = $(SOC_TWSI_DIR)/Arch$(CPU_ARCH)
+HAL_UART_DIR      = $(HAL_DIR)/uart
+
+ifeq ($(CONFIG_MV_ETH_NETA),y)
+HAL_ETH_DIR       = $(HAL_DIR)/neta 
+HAL_ETH_GBE_DIR   = $(HAL_DIR)/neta/gbe
+HAL_ETH_NFP_DIR   = $(HAL_DIR)/neta/nfp
+HAL_ETH_PNC_DIR   = $(HAL_DIR)/neta/pnc
+HAL_ETH_BM_DIR    = $(HAL_DIR)/neta/bm
+HAL_ETH_PMT_DIR   = $(HAL_DIR)/neta/pmt
+LSP_NETWORK_DIR   = $(PLAT_DRIVERS)/mv_neta
+LSP_NET_DEV_DIR   = $(LSP_NETWORK_DIR)/net_dev
+LSP_NFP_MGR_DIR   = $(LSP_NETWORK_DIR)/nfp_mgr
+LSP_PNC_DIR       = $(LSP_NETWORK_DIR)/pnc
+LSP_BM_DIR        = $(LSP_NETWORK_DIR)/bm
+LSP_PMT_DIR       = $(LSP_NETWORK_DIR)/pmt
+LSP_HWF_DIR       = $(LSP_NETWORK_DIR)/hwf
+LSP_L2FW_DIR      = $(LSP_NETWORK_DIR)/l2fw
+endif
+
+ifeq ($(CONFIG_MV_ETH_LEGACY),y)
+HAL_ETH_DIR       = $(HAL_DIR)/eth
+HAL_ETH_GBE_DIR   = $(HAL_DIR)/eth/gbe
+HAL_ETH_NFP_DIR	  = $(HAL_DIR)/eth/nfp
+LSP_NETWORK_DIR   = $(PLAT_DRIVERS)/mv_network
+LSP_NET_DEV_DIR   = $(LSP_NETWORK_DIR)/mv_etherent
+LSP_NFP_MGR_DIR   = $(LSP_NETWORK_DIR)/nfp_mgr
+endif
+
+HAL_CPU_DIR       = $(HAL_DIR)/cpu
+HAL_SDMMC_DIR	  = $(HAL_DIR)/sdmmc
+ifeq ($(CONFIG_MV_INCLUDE_PCI),y)
+HAL_PCI_DIR	  = $(HAL_DIR)/pci
+ifeq ($(CONFIG_MV_INCLUDE_PEX),y)
+HAL_PEX_DIR       = $(HAL_DIR)/pex
+endif
+endif
+ifeq ($(CONFIG_MV_INCLUDE_TDM),y)
+HAL_TDM_DIR       = $(HAL_DIR)/voiceband/tdm
+endif
+ifeq ($(CONFIG_MV_INCLUDE_USB),y)
+HAL_USB_DIR       = $(HAL_DIR)/usb
+endif
+ifeq ($(CONFIG_MV_INCLUDE_CESA),y)
+HAL_CESA_DIR	  = $(HAL_DIR)/cesa
+HAL_CESA_AES_DIR  = $(HAL_DIR)/cesa/AES
+endif
+ifeq ($(CONFIG_MV_INCLUDE_XOR),y)
+HAL_XOR_DIR       = $(HAL_DIR)/xor
+endif
+ifeq ($(CONFIG_MV_INCLUDE_SPI),y)
+HAL_SPI_DIR       = $(HAL_DIR)/spi
+endif
+ifeq ($(CONFIG_MV_INCLUDE_AUDIO),y)
+HAL_AUDIO_DIR     = $(HAL_DIR)/audio
+endif
+ifeq ($(CONFIG_MV_INCLUDE_NFC),y)
+HAL_NFC_DIR       = $(HAL_DIR)/nfc
+endif
+
+LSP_TRACE_DIR     = $(PLAT_DRIVERS)/mv_trace
+LSP_SWITCH_DIR    = $(PLAT_DRIVERS)/mv_switch
+LSP_PHY_DIR       = $(PLAT_DRIVERS)/mv_phy
+
+# Environment components
+ALP_FAM_DIR	= avanta_lp_family
+SOC_DEVICE_DIR	= $(ALP_FAM_DIR)/device
+SOC_CPU_DIR	= $(ALP_FAM_DIR)/cpu
+BOARD_ENV_DIR	= $(ALP_FAM_DIR)/boardEnv
+SOC_ENV_DIR	= $(ALP_FAM_DIR)/ctrlEnv
+SOC_SYS_DIR	= $(ALP_FAM_DIR)/ctrlEnv/sys
+HAL_IF_DIR	= mv_hal_if
+
+#####################################################################################################
+# Include path
+###################################################################################################
+
+LSP_PATH_I      = $(srctree)/arch/arm/mach-avantalp
+PLAT_PATH_I	= $(srctree)/arch/arm/plat-armada
+
+HAL_PATH        = -I$(PLAT_PATH_I)/$(HAL_DIR) -I$(PLAT_PATH_I)/$(HAL_SATA_DIR) -I$(PLAT_PATH_I)/$(HAL_ETH_DIR)
+ALP_FAM_PATH	= -I$(LSP_PATH_I)/$(ALP_FAM_DIR)
+QD_PATH         = -I$(PLAT_PATH_I)/$(HAL_QD_DIR)/Include  -I$(PLAT_PATH_I)/$(HAL_QD_DIR)/Include/h/msApi 	\
+                  -I$(PLAT_PATH_I)/$(HAL_QD_DIR)/Include/h/driver -I$(PLAT_PATH_I)/$(HAL_QD_DIR)/Include/h/platform
+                     
+COMMON_PATH   	= -I$(PLAT_PATH_I)/$(COMMON_DIR) -I$(srctree)
+ 
+OSSERV_PATH     = -I$(PLAT_PATH_I)/$(OSSERV_DIR)
+LSP_PATH        = -I$(LSP_PATH_I)
+CONFIG_PATH     = -I$(LSP_PATH_I)/$(CONFIG_DIR)
+HAL_IF_PATH	= -I$(LSP_PATH_I)/$(HAL_IF)
+DRIVERS_LSP_PATH = -I$(PLAT_PATH_I)/$(PLAT_DRIVERS) -I$(PLAT_PATH_I)/$(LSP_NETWORK_DIR) -I$(PLAT_PATH_I)/$(LSP_SWITCH_DIR) \
+		 -I$(PLAT_PATH_I)/$(LSP_TRACE_DIR)
+
+EXTRA_INCLUDE  	= $(OSSERV_PATH) $(COMMON_PATH) $(HAL_PATH)  $(ALP_FAM_PATH) \
+                  $(LSP_PATH) $(CONFIG_PATH) $(DRIVERS_LSP_PATH) $(HAL_IF_PATH)
+
+###################################################################################################
+# defines
+###################################################################################################
+MV_DEFINE = -DMV_LINUX -DMV_CPU_$(ENDIAN) -DMV_$(CPU_ARCH) 
+
+
+ifeq ($(CONFIG_MV_GATEWAY),y)
+EXTRA_INCLUDE	+= $(QD_PATH)
+EXTRA_CFLAGS    += -DLINUX  
+endif
+
+ifeq ($(CONFIG_MV_INCLUDE_SWITCH),y)
+EXTRA_INCLUDE   += $(QD_PATH)
+EXTRA_CFLAGS    += -DLINUX
+endif
+
+ifeq ($(CONFIG_MV_CESA_TEST),y)
+EXTRA_CFLAGS 	+= -DCONFIG_MV_CESA_TEST
+endif
+
+ifeq ($(CONFIG_SATA_DEBUG_ON_ERROR),y)
+EXTRA_CFLAGS    += -DMV_LOG_ERROR
+endif
+
+ifeq ($(CONFIG_SATA_FULL_DEBUG),y)
+EXTRA_CFLAGS    += -DMV_LOG_DEBUG
+endif
+
+ifeq ($(CONFIG_MV_SATA_SUPPORT_ATAPI),y)
+EXTRA_CFLAGS    += -DMV_SUPPORT_ATAPI
+endif
+
+ifeq ($(CONFIG_MV_SATA_ENABLE_1MB_IOS),y)
+EXTRA_CFLAGS    += -DMV_SUPPORT_1MBYTE_IOS
+endif
+
+ifeq ($(CONFIG_PCIE_VIRTUAL_BRIDGE_SUPPORT),y)
+EXTRA_CFLAGS    +=-DPCIE_VIRTUAL_BRIDGE_SUPPORT
+endif
+
+ifeq ($(CONFIG_MV_CESA_CHAIN_MODE_SUPPORT),y)
+EXTRA_CFLAGS    += -DMV_CESA_CHAIN_MODE_SUPPORT
+endif
+
+EXTRA_CFLAGS 	+= $(EXTRA_INCLUDE) $(MV_DEFINE)
+
+EXTRA_AFLAGS 	+= $(EXTRA_CFLAGS)
diff --git a/arch/arm/mach-avantalp/config/mvSysCesaConfig.h b/arch/arm/mach-avantalp/config/mvSysCesaConfig.h
new file mode 100644
index 0000000..141e9a4
--- /dev/null
+++ b/arch/arm/mach-avantalp/config/mvSysCesaConfig.h
@@ -0,0 +1,45 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysCesaConfig.h - Marvell Cesa unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+//#include "mvSysHwConfig.h"
+#include  "ctrlEnv/mvCtrlEnvSpec.h"
+
+/*
+** Base address for cesa registers.
+*/
+#define MV_CESA_REGS_BASE(chan) 	(MV_CESA_REGS_OFFSET(chan))
+
+#define MV_CESA_TDMA_REGS_BASE(chan)	(MV_CESA_TDMA_REGS_OFFSET(chan))
+
+#define MV_CESA_CHANNELS		(CONFIG_MV_CESA_CHANNELS)
+
+#ifdef CONFIG_MV_CESA_CHAIN_MODE
+	#define MV_CESA_CHAIN_MODE
+#endif
diff --git a/arch/arm/mach-avantalp/config/mvSysCntmrConfig.h b/arch/arm/mach-avantalp/config/mvSysCntmrConfig.h
new file mode 100644
index 0000000..de55150
--- /dev/null
+++ b/arch/arm/mach-avantalp/config/mvSysCntmrConfig.h
@@ -0,0 +1,36 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysCntmrConfig.h - Marvell Counter Manager unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for counter manager registers.
+*/
+#define MV_CNTMR_REGS_BASE		(MV_CNTMR_REGS_OFFSET)
diff --git a/arch/arm/mach-avantalp/config/mvSysDdrConfig.h b/arch/arm/mach-avantalp/config/mvSysDdrConfig.h
new file mode 100644
index 0000000..8332ebd
--- /dev/null
+++ b/arch/arm/mach-avantalp/config/mvSysDdrConfig.h
@@ -0,0 +1,45 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysDdrConfig.h - Marvell DRAM controller unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for DDR registers.
+*/
+#define MV_DDR_WIN_REGS_BASE		(MV_MBUS_REGS_OFFSET)
+#define MV_DDR_CTRL_REGS_BASE		(MV_DRAM_REGS_OFFSET)
+
+/* used for ddr2 "bak" files */
+#define MV_DDR_REGS_BASE		(MV_DRAM_REGS_OFFSET)
+
+#ifndef MV_BOOTROM
+#define MV_STATIC_DRAM_ON_BOARD
+#endif
+
diff --git a/arch/arm/mach-avantalp/config/mvSysEthConfig.h b/arch/arm/mach-avantalp/config/mvSysEthConfig.h
new file mode 100644
index 0000000..62f898e
--- /dev/null
+++ b/arch/arm/mach-avantalp/config/mvSysEthConfig.h
@@ -0,0 +1,198 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/*******************************************************************************
+* mvSysEthConfig.h - Marvell Ethernet unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#ifndef __mvSysEthConfig_h__
+#define __mvSysEthConfig_h__
+
+#include "mvSysHwConfig.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+
+/*
+** Base address for ethernet registers.
+*/
+#ifdef CONFIG_MV_PON
+#define MV_PON_PORT_ID_GET()	MV_PON_PORT_ID
+#define MV_PON_PORT(p)		((p) == MV_PON_PORT_ID)
+#define MV_PON_REG_BASE         MV_PON_REGS_OFFSET
+#define MV_ETH_REGS_BASE(p)	(MV_PON_PORT(p) ? MV_PON_REGS_OFFSET : MV_ETH_REGS_OFFSET(p))
+#else
+#define MV_PON_PORT(p)		MV_FALSE
+#define MV_ETH_REGS_BASE(p)	MV_ETH_REGS_OFFSET(p)
+#endif /* CONFIG_MV_PON */ 
+
+#define MV_BM_REG_BASE		MV_BM_REGS_OFFSET
+#define MV_PNC_REG_BASE         MV_PNC_REGS_OFFSET
+#define MV_ETH_COMPLEX_BASE		(MV_ETH_COMPLEX_OFFSET)
+#define MV_ETH_ONLY_REGS_BASE		(MV_ETH_ONLY_REGS_OFFSET)
+
+#if defined(CONFIG_MV_INCLUDE_GIG_ETH)
+
+/* put descriptors in uncached memory */
+/* #define ETH_DESCR_UNCACHED */
+
+/* port's default queueus */
+#define ETH_DEF_RXQ         0  
+
+#ifdef CONFIG_MV_ETH_LEGACY 
+
+#ifdef CONFIG_MV_NFP_STATS
+#define MV_FP_STATISTICS
+#else
+#undef MV_FP_STATISTICS
+#endif
+
+/* Default configuration for TX_EN workaround: 0 - Disabled, 1 - Enabled */
+#define MV_ETH_TX_EN_DEFAULT        0
+
+/* un-comment if you want to perform tx_done from within the poll function */
+/* #define ETH_TX_DONE_ISR */
+
+/* Descriptors location: DRAM/internal-SRAM */
+#define ETH_DESCR_IN_SDRAM
+#undef  ETH_DESCR_IN_SRAM    /* No integrated SRAM in 88Fxx81 devices */
+
+#if defined(ETH_DESCR_IN_SRAM)
+#if defined(ETH_DESCR_UNCACHED)
+ #define ETH_DESCR_CONFIG_STR    "Uncached descriptors in integrated SRAM"
+#else
+ #define ETH_DESCR_CONFIG_STR    "Cached descriptors in integrated SRAM"
+#endif
+#elif defined(ETH_DESCR_IN_SDRAM)
+#if defined(ETH_DESCR_UNCACHED)
+ #define ETH_DESCR_CONFIG_STR    "Uncached descriptors in DRAM"
+#else
+ #define ETH_DESCR_CONFIG_STR    "Cached descriptors in DRAM"
+#endif
+#else 
+ #error "Ethernet descriptors location undefined"
+#endif /* ETH_DESCR_IN_SRAM or ETH_DESCR_IN_SDRAM*/
+
+/* SW Sync-Barrier: not relevant for 88fxx81*/
+/* Reasnable to define this macro when descriptors in SRAM and buffers in DRAM */
+/* In RX the CPU theoretically might see himself as the descriptor owner,      */
+/* although the buffer hadn't been written to DRAM yet. Performance cost.      */
+/* #define INCLUDE_SYNC_BARR */
+
+/* Buffers cache coherency method (buffers in DRAM) */
+#ifndef MV_CACHE_COHER_SW
+/* Taken from mvCommon.h */
+/* Memory uncached, HW or SW cache coherency is not needed */
+#define MV_UNCACHED             0   
+/* Memory cached, HW cache coherency supported in WriteThrough mode */
+#define MV_CACHE_COHER_HW_WT    1
+/* Memory cached, HW cache coherency supported in WriteBack mode */
+#define MV_CACHE_COHER_HW_WB    2
+/* Memory cached, No HW cache coherency, Cache coherency must be in SW */
+#define MV_CACHE_COHER_SW       3
+
+#endif
+
+#define ETHER_DRAM_COHER    MV_CACHE_COHER_SW   /* No HW coherency in 88Fxx81 devices */
+
+#if (ETHER_DRAM_COHER == MV_CACHE_COHER_HW_WB)
+ #define ETH_SDRAM_CONFIG_STR    "DRAM HW cache coherency (write-back)"
+#elif (ETHER_DRAM_COHER == MV_CACHE_COHER_HW_WT)
+ #define ETH_SDRAM_CONFIG_STR    "DRAM HW cache coherency (write-through)"
+#elif (ETHER_DRAM_COHER == MV_CACHE_COHER_SW)
+ #define ETH_SDRAM_CONFIG_STR    "DRAM SW cache-coherency"
+#elif (ETHER_DRAM_COHER == MV_UNCACHED)
+#   define ETH_SDRAM_CONFIG_STR  "DRAM uncached"
+#else
+ #error "Ethernet-DRAM undefined"
+#endif /* ETHER_DRAM_COHER */
+
+
+/****************************************************************/
+/************* Ethernet driver configuration ********************/
+/****************************************************************/
+
+/* port's default queueus */
+#define ETH_DEF_TXQ         0
+
+#define MV_ETH_RX_Q_NUM     CONFIG_MV_ETH_RXQ
+#define MV_ETH_TX_Q_NUM     CONFIG_MV_ETH_TXQ
+
+/* interrupt coalescing setting */
+#define ETH_TX_COAL    		    200
+#define ETH_RX_COAL    		    200
+
+/* Checksum offloading */
+#define TX_CSUM_OFFLOAD
+#define RX_CSUM_OFFLOAD
+#endif /* CONFIG_MV_ETH_LEGACY */
+
+#endif /* CONFIG_MV_INCLUDE_GIG_ETH */
+
+#endif /* __mvSysEthConfig_h__ */
diff --git a/arch/arm/mach-avantalp/config/mvSysEthPhyConfig.h b/arch/arm/mach-avantalp/config/mvSysEthPhyConfig.h
new file mode 100644
index 0000000..74cc239
--- /dev/null
+++ b/arch/arm/mach-avantalp/config/mvSysEthPhyConfig.h
@@ -0,0 +1,32 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysEthPhyConfig.h - Marvell Ethernet-PHY specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
diff --git a/arch/arm/mach-avantalp/config/mvSysGppConfig.h b/arch/arm/mach-avantalp/config/mvSysGppConfig.h
new file mode 100644
index 0000000..630d523
--- /dev/null
+++ b/arch/arm/mach-avantalp/config/mvSysGppConfig.h
@@ -0,0 +1,37 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysGppConfig.h - Marvell GPP unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for GPP registers.
+*/
+#define MV_GPP_REGS_BASE(unit)		(MV_GPP_REGS_OFFSET(unit))
+#define MV_GPP_REGS_BASE_0		(MV_GPP_REGS_OFFSET(0))
diff --git a/arch/arm/mach-avantalp/config/mvSysHwConfig.h b/arch/arm/mach-avantalp/config/mvSysHwConfig.h
new file mode 100755
index 0000000..25e0f13
--- /dev/null
+++ b/arch/arm/mach-avantalp/config/mvSysHwConfig.h
@@ -0,0 +1,309 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysHwCfg.h - Marvell system HW configuration file
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#ifndef __INCmvSysHwConfigh
+#define __INCmvSysHwConfigh
+
+#define CONFIG_MARVELL	1
+
+/* includes */
+#define _1K         0x00000400
+#define _4K         0x00001000
+#define _8K         0x00002000
+#define _16K        0x00004000
+#define _32K        0x00008000
+#define _64K        0x00010000
+#define _128K       0x00020000
+#define _256K       0x00040000
+#define _512K       0x00080000
+
+#define _1M         0x00100000
+#define _2M         0x00200000
+#define _4M         0x00400000
+#define _8M         0x00800000
+#define _16M        0x01000000
+#define _32M        0x02000000
+#define _64M        0x04000000
+#define _128M       0x08000000
+#define _256M       0x10000000
+#define _512M       0x20000000
+
+#define _1G         0x40000000
+#define _2G         0x80000000
+
+#ifdef CONFIG_DRAM_IO_RESERVE_BASE
+#define MV_DRAM_IO_RESERVE_BASE	CONFIG_DRAM_IO_RESERVE_BASE
+#endif
+
+/****************************************/
+/* Soc supporeted Units definitions	*/
+/****************************************/
+
+#ifdef CONFIG_MV_INCLUDE_PEX
+#define MV_INCLUDE_PEX
+
+#ifdef CONFIG_MV_PEX_0_4X1
+#define MV_PEX_0_4X1		1
+#define MV_PEX_0_1X4		0
+#endif
+#ifdef CONFIG_MV_PEX_0_1X4
+#define MV_PEX_0_4X1		0
+#define MV_PEX_0_1X4		1
+#endif
+
+#ifdef CONFIG_MV_PEX_1_4X1
+#define MV_PEX_1_4X1		1
+#define MV_PEX_1_1X4		0
+#endif
+#ifdef CONFIG_MV_PEX_1_1X4
+#define MV_PEX_1_4X1		0
+#define MV_PEX_1_1X4		1
+#endif
+
+#ifdef CONFIG_MV_PEX_2_4X1
+#define MV_PEX_2_4X1		1
+#endif
+
+#ifdef CONFIG_MV_PEX_3_4X1
+#define MV_PEX_3_4X1		1
+#endif
+
+#endif /* CONFIG_MV_INCLUDE_PEX */
+
+#ifdef CONFIG_MV_INCLUDE_PCI
+#define MV_INCLUDE_PCI
+
+#define PCI_HOST_BUS_NUM(pciIf)		(pciIf)
+#define PCI_HOST_DEV_NUM(pciIf)		0
+
+#define PEX_HOST_BUS_NUM(pciIf)		(pciIf)
+#define PEX_HOST_DEV_NUM(pciIf)		0
+
+#endif
+
+#ifdef CONFIG_MV_INCLUDE_TWSI
+#define MV_INCLUDE_TWSI
+#endif
+#ifdef CONFIG_MV_INCLUDE_CESA
+#define MV_INCLUDE_CESA
+#endif
+#ifdef CONFIG_MV_INCLUDE_GIG_ETH
+#define MV_INCLUDE_GIG_ETH
+#endif
+#ifdef CONFIG_MV_INCLUDE_INTEG_SATA
+#define MV_INCLUDE_INTEG_SATA
+#define MV_INCLUDE_SATA
+#endif
+#ifdef CONFIG_MV_INCLUDE_USB
+#define MV_INCLUDE_USB
+//#define MV_USB_VOLTAGE_FIX
+#endif
+#ifdef CONFIG_MV_INCLUDE_LEGACY_NAND
+#define MV_INCLUDE_LEGACY_NAND
+#endif
+#ifdef CONFIG_MV_INCLUDE_TDM
+#define MV_INCLUDE_TDM
+#endif
+#ifdef CONFIG_MV_INCLUDE_XOR
+#define MV_INCLUDE_XOR
+#endif
+#ifdef CONFIG_MV_INCLUDE_TWSI
+#define MV_INCLUDE_TWSI
+#endif
+#ifdef CONFIG_MV_INCLUDE_UART
+#define MV_INCLUDE_UART
+#endif
+#ifdef CONFIG_MV_INCLUDE_SPI
+#define MV_INCLUDE_SPI
+#endif
+#ifdef CONFIG_MV_INCLUDE_NOR
+#define MV_INCLUDE_NOR
+#endif
+#ifdef CONFIG_MV_INCLUDE_SFLASH_MTD
+#define MV_INCLUDE_SFLASH_MTD
+#endif
+#ifdef CONFIG_MV_INCLUDE_AUDIO
+#define MV_INCLUDE_AUDIO
+#endif
+#ifdef CONFIG_MV_INCLUDE_TS
+#define MV_INCLUDE_TS
+#endif
+#ifdef CONFIG_MV_INCLUDE_SDIO
+#define MV_INCLUDE_SDIO
+#endif
+#ifdef CONFIG_MTD_NAND_LNC_BOOT
+#define MTD_NAND_LNC_BOOT
+#endif
+#ifdef CONFIG_MTD_NAND_LNC
+#define MTD_NAND_LNC
+#endif
+#ifdef CONFIG_MTD_NAND_NFC
+#define MTD_NAND_NFC
+#endif
+#ifdef CONFIG_MTD_NAND_NFC_INIT_RESET
+#define MTD_NAND_NFC_INIT_RESET
+#endif
+#ifdef CONFIG_MTD_NAND_NFC_GANG_SUPPORT
+#define MTD_NAND_NFC_GANG_SUPPORT
+#endif
+#ifdef CONFIG_MTD_NAND_NFC_MLC_SUPPORT
+#define MTD_NAND_NFC_MLC_SUPPORT
+#endif
+#ifdef CONFIG_MTD_NAND_NFC_INIT_RESET
+#define MTD_NAND_NFC_INIT_RESET
+#endif
+#ifdef CONFIG_MTD_NAND_NFC_NEGLECT_RNB
+#define MTD_NAND_NFC_NEGLECT_RNB
+#endif
+#ifdef CONFIG_MV_INCLUDE_PDMA
+#define MV_INCLUDE_PDMA
+#endif
+#ifdef CONFIG_MV_SPI_BOOT
+#define MV_SPI_BOOT
+#endif
+#ifdef CONFIG_AURORA_IO_CACHE_COHERENCY
+#define AURORA_IO_CACHE_COHERENCY
+#endif
+
+/* convert Definitions for Errata used in the HAL */
+#ifdef CONFIG_SHEEVA_ERRATA_ARM_CPU_4413
+#define SHEEVA_ERRATA_ARM_CPU_4413
+#endif
+#ifdef CONFIG_SHEEVA_ERRATA_ARM_CPU_BTS61
+#define SHEEVA_ERRATA_ARM_CPU_BTS61
+#endif
+#ifdef CONFIG_SHEEVA_ERRATA_ARM_CPU_4611
+#define SHEEVA_ERRATA_ARM_CPU_4611
+#endif
+
+/* convert chip revision definitions */
+#ifdef CONFIG_ARMADA_XP_REV_Z1
+#define MV88F78X60_Z1
+#endif
+#if defined(CONFIG_ARMADA_XP_REV_A0) || defined(CONFIG_ARMADA_XP_A0_WITH_B0)
+#define MV88F78X60_A0
+#endif
+#if defined(CONFIG_ARMADA_XP_REV_B0) && !defined(CONFIG_ARMADA_XP_A0_WITH_B0)
+#define MV88F78X60_B0
+#endif
+/****************************************************************/
+/************* General    configuration ********************/
+/****************************************************************/
+
+/* Enable Clock Power Control */
+#define MV_INCLUDE_CLK_PWR_CNTRL
+
+/* Disable the DEVICE BAR in the PEX */
+#define MV_DISABLE_PEX_DEVICE_BAR
+
+/* Allow the usage of early printings during initialization */
+#define MV_INCLUDE_EARLY_PRINTK
+
+/****************************************************************/
+/************* NFP configuration ********************************/
+/****************************************************************/
+#define MV_NFP_SEC_Q_SIZE		64
+#define MV_NFP_SEC_REQ_Q_SIZE		1000
+
+
+
+/****************************************************************/
+/************* CESA configuration ********************/
+/****************************************************************/
+
+#ifdef MV_INCLUDE_CESA
+
+#define MV_CESA_MAX_CHAN               4
+
+/* Use 2K of SRAM */
+#define MV_CESA_MAX_BUF_SIZE           1600
+
+#endif /* MV_INCLUDE_CESA */
+
+/* DRAM cache coherency configuration */
+#define MV_CACHE_COHERENCY  MV_CACHE_COHER_SW
+
+
+
+/****************************************************************/
+/*************** Telephony configuration ************************/
+/****************************************************************/
+#if defined(CONFIG_MV_TDM_LINEAR_MODE)
+ #define MV_TDM_LINEAR_MODE
+#elif defined(CONFIG_MV_TDM_ULAW_MODE)
+ #define MV_TDM_ULAW_MODE
+#endif
+
+#if defined(CONFIG_MV_TDM_5CHANNELS)
+ #define MV_TDM_5CHANNELS 
+#endif
+
+#if defined(CONFIG_MV_TDM_USE_EXTERNAL_PCLK_SOURCE)
+ #define MV_TDM_USE_EXTERNAL_PCLK_SOURCE
+#endif
+
+/****************************************************************/
+/******************* LPAE configuration *************************/
+/****************************************************************/
+#ifdef CONFIG_ARM_LPAE
+#define ARM_LPAE_SUPPORT
+#endif
+/* We use the following registers to store DRAM interface pre configuration   */
+/* auto-detection results													  */
+/* IMPORTANT: We are using mask register for that purpose. Before writing     */
+/* to units mask register, make sure main maks register is set to disable     */
+/* all interrupts.                                                            */
+#define DRAM_BUF_REG0   0x30810 /* sdram bank 0 size            */  
+#define DRAM_BUF_REG1   0x30820 /* sdram config                 */
+#define DRAM_BUF_REG2   0x30830 /* sdram mode                   */
+#define DRAM_BUF_REG3   0x308c4 /* dunit control low            */          
+#define DRAM_BUF_REG4   0x60a90 /* sdram address control        */
+#define DRAM_BUF_REG5   0x60a94 /* sdram timing control low     */
+#define DRAM_BUF_REG6   0x60a98 /* sdram timing control high    */
+#define DRAM_BUF_REG7   0x60a9c /* sdram ODT control low        */
+#define DRAM_BUF_REG8   0x60b90 /* sdram ODT control high       */
+#define DRAM_BUF_REG9   0x60b94 /* sdram Dunit ODT control      */
+#define DRAM_BUF_REG10  0x60b98 /* sdram Extended Mode          */
+#define DRAM_BUF_REG11  0x60b9c /* sdram Ddr2 Time Low Reg      */
+#define DRAM_BUF_REG12  0x60a00 /* sdram Ddr2 Time High Reg     */
+#define DRAM_BUF_REG13  0x60a04 /* dunit Ctrl High              */
+#define DRAM_BUF_REG14  0x60b00 /* sdram second DIMM exist      */
+
+/* Following the pre-configuration registers default values restored after    */
+/* auto-detection is done                                                     */
+#define DRAM_BUF_REG_DV 0
+
+/* DRAM detection stuff */
+#define MV_DRAM_AUTO_SIZE
+
+/* Default FPGA Clock */
+#define MV_FPGA_CLK	25000000
+#endif /* __INCmvSysHwConfigh */
+
diff --git a/arch/arm/mach-avantalp/config/mvSysNfcConfig.h b/arch/arm/mach-avantalp/config/mvSysNfcConfig.h
new file mode 100644
index 0000000..858497a
--- /dev/null
+++ b/arch/arm/mach-avantalp/config/mvSysNfcConfig.h
@@ -0,0 +1,36 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysSpiConfig.h - Marvell SPI unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for SPI registers.
+*/
+#define MV_NFC_REGS_BASE		(MV_NFC_REGS_OFFSET)
diff --git a/arch/arm/mach-avantalp/config/mvSysPciConfig.h b/arch/arm/mach-avantalp/config/mvSysPciConfig.h
new file mode 100644
index 0000000..2783d1a
--- /dev/null
+++ b/arch/arm/mach-avantalp/config/mvSysPciConfig.h
@@ -0,0 +1,26 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for Pex registers.
+*/
+#define MV_PCI_IF_REGS_BASE(pciIf) 		(MV_PEX_IF_REGS_OFFSET(pciIf))
+
diff --git a/arch/arm/mach-avantalp/config/mvSysPexConfig.h b/arch/arm/mach-avantalp/config/mvSysPexConfig.h
new file mode 100644
index 0000000..14a5292
--- /dev/null
+++ b/arch/arm/mach-avantalp/config/mvSysPexConfig.h
@@ -0,0 +1,50 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysPciIfConfig.h - Marvell PCI / Pex units specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for Pex registers.
+*/
+#define MV_PEX_IF_REGS_BASE(unit) 		(MV_PEX_IF_REGS_OFFSET(unit))
+
+/* PEX Work arround */
+/* the target we will use for the workarround */
+#define PEX_CONFIG_RW_WA_TARGET PEX0_MEM
+/*a flag that indicates if we are going to use the 
+size and base of the target we using for the workarround
+window */
+#define PEX_CONFIG_RW_WA_USE_ORIGINAL_WIN_VALUES 1
+/* if the above flag is 0 then the following values
+will be used for the workarround window base and size,
+otherwise the following defines will be ignored */
+#define PEX_CONFIG_RW_WA_BASE 0xF3000000
+#define PEX_CONFIG_RW_WA_SIZE _16M
+
diff --git a/arch/arm/mach-avantalp/config/mvSysPonConfig.h b/arch/arm/mach-avantalp/config/mvSysPonConfig.h
new file mode 100644
index 0000000..7701866
--- /dev/null
+++ b/arch/arm/mach-avantalp/config/mvSysPonConfig.h
@@ -0,0 +1,38 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysDdrConfig.h - Marvell DRAM controller unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for PON registers.
+*/
+#define MV_EPON_MAC_REGS_BASE		(MV_GPON_MAC_REGS_OFFSET)
+#define MV_GPON_MAC_REGS_BASE		(MV_GPON_MAC_REGS_OFFSET)
+
diff --git a/arch/arm/mach-avantalp/config/mvSysRtcConfig.h b/arch/arm/mach-avantalp/config/mvSysRtcConfig.h
new file mode 100644
index 0000000..38a3b54
--- /dev/null
+++ b/arch/arm/mach-avantalp/config/mvSysRtcConfig.h
@@ -0,0 +1,36 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysRtcConfig.h - Marvell Real-Time clock unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for RTC registers.
+*/
+#define MV_RTC_REGS_BASE		(MV_RTC_REGS_OFFSET)
diff --git a/arch/arm/mach-avantalp/config/mvSysSataConfig.h b/arch/arm/mach-avantalp/config/mvSysSataConfig.h
new file mode 100644
index 0000000..057b5a7
--- /dev/null
+++ b/arch/arm/mach-avantalp/config/mvSysSataConfig.h
@@ -0,0 +1,36 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysSataConfig.h - Marvell Sata unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for SPI registers.
+*/
+#define MV_SATA_REGS_BASE		(MV_SATA_REGS_OFFSET)
diff --git a/arch/arm/mach-avantalp/config/mvSysSdmmcConfig.h b/arch/arm/mach-avantalp/config/mvSysSdmmcConfig.h
new file mode 100644
index 0000000..e5a4d3b
--- /dev/null
+++ b/arch/arm/mach-avantalp/config/mvSysSdmmcConfig.h
@@ -0,0 +1,37 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysSdmmcConfig.h - Marvell SDMMC unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for audio registers.
+*/
+#define MV_SDMMC_REGS_BASE		(MV_SDMMC_REGS_OFFSET)
+
diff --git a/arch/arm/mach-avantalp/config/mvSysSpiConfig.h b/arch/arm/mach-avantalp/config/mvSysSpiConfig.h
new file mode 100644
index 0000000..a13c1a4
--- /dev/null
+++ b/arch/arm/mach-avantalp/config/mvSysSpiConfig.h
@@ -0,0 +1,36 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysSpiConfig.h - Marvell SPI unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for SPI registers.
+*/
+#define MV_SPI_REGS_BASE(unit)		(MV_SPI_REGS_OFFSET(unit))
diff --git a/arch/arm/mach-avantalp/config/mvSysTdmConfig.h b/arch/arm/mach-avantalp/config/mvSysTdmConfig.h
new file mode 100644
index 0000000..7946fdf
--- /dev/null
+++ b/arch/arm/mach-avantalp/config/mvSysTdmConfig.h
@@ -0,0 +1,68 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysTdmConfig.h - Marvell TDM unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "mvOs.h"
+
+/****************************************************************/
+/*************** Telephony configuration ************************/
+/****************************************************************/
+#if defined(CONFIG_MV_TDM_SUPPORT)
+	#define MV_TDM_SUPPORT
+	#define MV_TDM_REGS_BASE	MV_TDM_REGS_OFFSET
+#elif defined(CONFIG_MV_COMM_UNIT_SUPPORT)
+	#define MV_COMM_UNIT_SUPPORT
+	#define MV_COMM_UNIT_REGS_BASE	MV_COMM_UNIT_REGS_OFFSET
+#endif
+
+/* SLIC vendor */
+#if defined(CONFIG_SILABS_SLIC_SUPPORT)
+	#define SILABS_SLIC_SUPPORT
+	#if defined(CONFIG_SILABS_SLIC_3215)
+		#define SILABS_SLIC_3215
+	#elif defined(CONFIG_SILABS_SLIC_3217)
+		#define SILABS_SLIC_3217
+	#endif
+#elif defined(CONFIG_ZARLINK_SLIC_SUPPORT)
+	#define ZARLINK_SLIC_SUPPORT
+	#if defined(CONFIG_ZARLINK_SLIC_VE880)
+		#define ZARLINK_SLIC_VE880
+		#define SLIC_TIMER_EVENT_SUPPORT
+	#elif defined(CONFIG_ZARLINK_SLIC_VE792)
+		#define ZARLINK_SLIC_VE792
+	#endif
+#else
+	#define SILABS_SLIC_3215_OLD_SUPPORT
+#endif
+
+#if defined(CONFIG_MV_TDM_USE_EXTERNAL_PCLK_SOURCE)
+ #define MV_TDM_USE_EXTERNAL_PCLK_SOURCE
+#endif
diff --git a/arch/arm/mach-avantalp/config/mvSysTsConfig.h b/arch/arm/mach-avantalp/config/mvSysTsConfig.h
new file mode 100644
index 0000000..be94e0a
--- /dev/null
+++ b/arch/arm/mach-avantalp/config/mvSysTsConfig.h
@@ -0,0 +1,39 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysTsConfig.h - Marvell TS unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for TS registers.
+*/
+#define MV_TSU_GLOBAL_REGS_BASE		(MV_TSU_GLOBAL_REGS_OFFSET)
+#define MV_TSU_REGS_BASE(port)		(MV_TSU_REGS_OFFSET(port))
+
+
diff --git a/arch/arm/mach-avantalp/config/mvSysTwsiConfig.h b/arch/arm/mach-avantalp/config/mvSysTwsiConfig.h
new file mode 100644
index 0000000..6c9772d
--- /dev/null
+++ b/arch/arm/mach-avantalp/config/mvSysTwsiConfig.h
@@ -0,0 +1,41 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysTwsiConfig.h - Marvell TWSI unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+/*
+** Base address for TWSI registers.
+*/
+#define MV_TWSI_SLAVE_REGS_BASE(unit) 	(MV_TWSI_SLAVE_REGS_OFFSET(unit))
+
+/*
+** Specific definition for Main CPU interrupt cause register.
+** Needed for TWSI operation completion monitoring.
+*/
+#define MV_TWSI_CPU_MAIN_INT_CAUSE(chNum, cpu)	TWSI_CPU_MAIN_INT_CAUSE_REG(cpu)
diff --git a/arch/arm/mach-avantalp/config/mvSysUsbConfig.h b/arch/arm/mach-avantalp/config/mvSysUsbConfig.h
new file mode 100644
index 0000000..7c82f5c
--- /dev/null
+++ b/arch/arm/mach-avantalp/config/mvSysUsbConfig.h
@@ -0,0 +1,36 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysUsbConfig.h - Marvell USB unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for USB registers.
+*/
+#define MV_USB_REGS_BASE(unit) 		(MV_USB_REGS_OFFSET(unit))
diff --git a/arch/arm/mach-avantalp/config/mvSysXorConfig.h b/arch/arm/mach-avantalp/config/mvSysXorConfig.h
new file mode 100644
index 0000000..4681653
--- /dev/null
+++ b/arch/arm/mach-avantalp/config/mvSysXorConfig.h
@@ -0,0 +1,36 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysXorConfig.h - Marvell XOR unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for XOR registers.
+*/
+#define MV_XOR_REGS_BASE(unit)		(MV_XOR_REGS_OFFSET(unit))
diff --git a/arch/arm/mach-avantalp/core.c b/arch/arm/mach-avantalp/core.c
new file mode 100755
index 0000000..03645e9
--- /dev/null
+++ b/arch/arm/mach-avantalp/core.c
@@ -0,0 +1,747 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/ctype.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/sysdev.h>
+#include <linux/mbus.h>
+#include <asm/mach/time.h>
+#include <linux/clocksource.h>
+#include <mach/hardware.h>
+#include <asm/hardware/gic.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/flash.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/map.h>
+#include <mach/system.h>
+
+#include <linux/tty.h>
+#include <linux/platform_device.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+#include <linux/serial_8250.h>
+#include <linux/serial_reg.h>
+#include <linux/ata_platform.h>
+#include <linux/mv_neta.h>
+#include <asm/serial.h>
+#include <plat/cache-aurora-l2.h>
+
+#include <mach/serial.h>
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "ctrlEnv/mvUnitMap.h"
+#include "ctrlEnv/mvSemaphore.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "mvDebug.h"
+#include "mvSysHwConfig.h"
+#include "pex/mvPexRegs.h"
+#include "cntmr/mvCntmr.h"
+#include "gpp/mvGpp.h"
+#include "plat/gpio.h"
+#include "cpu/mvCpu.h"
+
+#if defined(CONFIG_MV_INCLUDE_CESA)
+#include "cesa/mvCesa.h"
+#endif
+
+#include <plat/mv_xor.h>
+
+/* I2C */
+#include <linux/i2c.h>
+#include <linux/mv643xx_i2c.h>
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ctrlEnv/mvCtrlEnvRegs.h"
+
+/* SPI */
+#include "mvSysSpiApi.h"
+
+/* Eth Phy */
+#include "mvSysEthPhyApi.h"
+
+#include <asm/hardware/cache-l2x0.h>
+#include <asm/hardware/gic.h>
+#include "ca9x2.h"
+
+#define MV_COHERENCY_FABRIC_CTRL_REG		(MV_COHERENCY_FABRIC_OFFSET + 0x0)
+#define MV_COHERENCY_FABRIC_CFG_REG		(MV_COHERENCY_FABRIC_OFFSET + 0x4)
+
+extern unsigned int irq_int_type[];
+extern void __init alp_map_io(void);
+extern void __init mv_init_irq(void);
+extern struct sys_timer alp_timer;
+extern void alp_timer_resume();
+extern MV_CPU_DEC_WIN* mv_sys_map(void);
+#if defined(CONFIG_MV_INCLUDE_CESA)
+extern u32 mv_crypto_virt_base_get(u8 chan);
+#endif
+//extern void alp_init_irq(void);
+extern void __init set_core_count(unsigned int cpu_count);
+extern unsigned int group_cpu_mask;
+
+/* for debug putstr */
+static char arr[256];
+MV_U32 mvTclk = 166666667;
+MV_U32 mvSysclk = 200000000;
+
+#ifdef CONFIG_MV_INCLUDE_GIG_ETH
+MV_U8 mvMacAddr[CONFIG_MV_ETH_PORTS_NUM][6];
+MV_U16 mvMtu[CONFIG_MV_ETH_PORTS_NUM] = {0};
+#endif
+
+/*
+ * Helpers to get DDR bank info
+ */
+#define DDR_BASE_CS_OFF(n)	(0x0180 + ((n) << 3))
+#define DDR_SIZE_CS_OFF(n)	(0x0184 + ((n) << 3))
+#define TARGET_DDR		0
+#define COHERENCY_STATUS_SHARED_NO_L2_ALLOC	0x1
+
+struct mbus_dram_target_info avantalp_mbus_dram_info;
+
+/* XOR0 is disabled in Z1 Silicone */
+#ifdef CONFIG_ARMADA_XP_REV_Z1
+ /* XOR0 is disabled in Z1 Silicone */
+#undef XOR0_ENABLE
+#else
+ /* XOR0 is disabled in A0 Silicone */
+#define XOR0_ENABLE
+#endif
+
+/*********************************************************************************/
+/**************                 Early Printk Support                **************/
+/*********************************************************************************/
+#ifdef MV_INCLUDE_EARLY_PRINTK
+#define MV_UART0_LSR 	(*(volatile unsigned char *)(INTER_REGS_BASE + 0x12000 + 0x14))
+#define MV_UART0_THR	(*(volatile unsigned char *)(INTER_REGS_BASE + 0x12000 + 0x0 ))
+#define MV_UART1_LSR    (*(volatile unsigned char *)(INTER_REGS_BASE + 0x12100 + 0x14))
+#define MV_UART1_THR    (*(volatile unsigned char *)(INTER_REGS_BASE + 0x12100 + 0x0 ))
+#define MV_SERIAL_BASE 	((unsigned char *)(INTER_REGS_BASE + 0x12000 + 0x0 ))
+#define DEV_REG		(*(volatile unsigned int *)(INTER_REGS_BASE + 0x40000))
+#define CLK_REG         (*(volatile unsigned int *)(INTER_REGS_BASE + 0x2011c))
+/*
+ * This does not append a newline
+ */
+static void putstr(const char *s)
+{
+	unsigned int model;
+
+	/* Get dev ID, make sure pex clk is on */
+	if((CLK_REG & 0x4) == 0)
+	{
+		CLK_REG = CLK_REG | 0x4;
+		model = (DEV_REG >> 16) & 0xffff;
+		CLK_REG = CLK_REG & ~0x4;
+	}
+	else
+		model = (DEV_REG >> 16) & 0xffff;
+
+        while (*s) {
+		while ((MV_UART0_LSR & UART_LSR_THRE) == 0);
+		MV_UART0_THR = *s;
+
+                if (*s == '\n') {
+                        while ((MV_UART0_LSR & UART_LSR_THRE) == 0); 
+                        MV_UART0_THR = '\r';
+                }
+                s++;
+        }
+}
+extern void putstr(const char *ptr);
+void mv_early_printk(char *fmt,...)
+{
+	va_list args;
+	va_start(args, fmt);
+	vsprintf(arr,fmt,args);
+	va_end(args);
+	putstr(arr);
+}
+#endif
+
+/*********************************************************************************/
+/**************               UBoot Tagging Parameters              **************/
+/*********************************************************************************/
+#ifdef CONFIG_BE8_ON_LE
+#define read_tag(a)    le32_to_cpu(a)
+#define read_mtu(a)    le16_to_cpu(a)
+#else
+#define read_tag(a)    a
+#define read_mtu(a)    a
+#endif
+
+extern MV_U32 gBoardId; 
+extern unsigned int elf_hwcap;
+extern u32 mvIsUsbHost;
+
+static int __init parse_tag_mv_uboot(const struct tag *tag)
+{
+    	unsigned int mvUbootVer = 0;
+	int i = 0;
+
+	printk("Using UBoot passing parameters structure\n");
+	mvUbootVer = read_tag(tag->u.mv_uboot.uboot_version);
+#ifdef CONFIG_MV_INCLUDE_USB
+	mvIsUsbHost = read_tag(tag->u.mv_uboot.isUsbHost);
+#endif
+	gBoardId =  (mvUbootVer & 0xff);
+
+#ifdef CONFIG_MV_INCLUDE_GIG_ETH
+	for (i = 0; i < CONFIG_MV_ETH_PORTS_NUM; i++) {
+#if defined (CONFIG_OVERRIDE_ETH_CMDLINE)
+		memset(mvMacAddr[i], 0, 6);
+		mvMtu[i] = 0;
+#else
+		memcpy(mvMacAddr[i], tag->u.mv_uboot.macAddr[i], 6);
+		mvMtu[i] = read_mtu(tag->u.mv_uboot.mtu[i]);
+#endif
+	}
+#endif
+
+#ifdef CONFIG_MV_NAND
+               /* get NAND ECC type(1-bit or 4-bit) */
+	if ((mvUbootVer >> 8) >= 0x3040c)
+		mv_nand_ecc = read_tag(tag->u.mv_uboot.nand_ecc);
+	else
+		mv_nand_ecc = 1; /* fallback to 1-bit ECC */
+#endif
+	return 0;
+}
+
+__tagtable(ATAG_MV_UBOOT, parse_tag_mv_uboot);
+
+/*********************************************************************************/
+/**************                Command Line Parameters              **************/
+/*********************************************************************************/
+
+#ifdef CONFIG_CACHE_AURORA_L2
+static int noL2 = 0;
+static int __init noL2_setup(char *__unused)
+{
+     noL2 = 1;
+     return 1;
+}
+
+__setup("noL2", noL2_setup);
+#endif
+
+#ifdef CONFIG_JTAG_DEBUG
+	MV_U32 support_wait_for_interrupt = 0x0;
+#else
+	MV_U32 support_wait_for_interrupt = 0x1;
+#endif
+
+static int __init noWFI_setup(char *__unused)
+{
+     support_wait_for_interrupt = 0;
+     return 1;
+}
+
+__setup("noWFI", noWFI_setup);
+
+
+#ifdef CONFIG_SMP
+#if 0
+unsigned long mv_cpu_count = NR_CPUS;
+static int __init mv_cpu_count_setup(char *s)
+{
+	int fail;
+	unsigned int cpu_count;
+
+	/* Translate string to integer. If fails return to default*/
+	while (isspace(*s))
+		s++;
+
+	fail = strict_strtoul(s, 10, &cpu_count);
+	if(fail == 0)
+	{
+		set_core_count(cpu_count);
+	}
+
+	return 1;
+}
+__setup("mv_cpu_count=", mv_cpu_count_setup);
+#endif
+static int __init mv_rsrc_setup(char *s)
+{
+	char* rsrc = strchr(s, ' ');
+
+	/*Verify NULL termination */
+	if (rsrc) (*rsrc) = '\0';
+	/* Parse string to table */
+	if (MV_FALSE == mvUnitMapSetup(s, strstr))
+		printk(KERN_ERR "Invalid resource string %s\n", s);
+
+	// Change to rsrc limited mode
+	mvUnitMapSetRsrcLimited(MV_TRUE);
+
+	return 1;
+}
+__setup("mv_rsrc=", mv_rsrc_setup);
+#endif /* CONFIG_SMP */
+
+
+void __init avantalp_setup_cpu_mbus(void)
+{
+	void __iomem *addr;
+	int i;
+	int cs;
+	u8	coherency_status = 0;
+#if defined(CONFIG_AURORA_IO_CACHE_COHERENCY)
+	coherency_status = COHERENCY_STATUS_SHARED_NO_L2_ALLOC;
+#endif
+
+	/*
+	 * Setup MBUS dram target info.
+	 */
+	avantalp_mbus_dram_info.mbus_dram_target_id = TARGET_DDR;
+	addr = (void __iomem *)AXP_BRIDGE_VIRT_BASE;
+
+	for (i = 0, cs = 0; i < 4; i++) {
+		u32 base = readl(addr + DDR_BASE_CS_OFF(i));
+		u32 size = readl(addr + DDR_SIZE_CS_OFF(i));
+
+		/*
+		 * Chip select enabled?
+		 */
+		if (size & 1) {
+			struct mbus_dram_window *w;
+			if (base & 0xf)
+				/* BaseExtension is used (> 4GB).*/
+				continue;
+			w = &avantalp_mbus_dram_info.cs[cs++];
+			w->cs_index = i;
+			w->mbus_attr = 0xf & ~(1 << i);
+			w->mbus_attr |= coherency_status << 4;
+			w->base = base & 0xff000000;
+			w->size = (size | 0x00ffffff) + 1;
+		}
+	}
+	avantalp_mbus_dram_info.num_cs = cs;
+}
+
+/*********************************************************************************/
+/**************               I/O Devices Platform Info             **************/
+/*********************************************************************************/
+/**********
+ * UART-0 *
+ **********/
+static struct plat_serial8250_port aurora_uart0_data[] = {
+	{
+		.iotype		= UPIO_MEM32,
+		.regshift	= 2,
+		.uartclk	= 0,
+	},
+};
+
+static struct resource aurora_uart0_resources[] = {
+	{
+		.start		= (INTER_REGS_PHYS_BASE | MV_UART_REGS_OFFSET(0)),
+		.end		= (INTER_REGS_PHYS_BASE | MV_UART_REGS_OFFSET(0)) + SZ_256 - 1,
+		.flags		= IORESOURCE_MEM,
+	}, {
+		.start		= IRQ_AURORA_UART0,
+		.end		= IRQ_AURORA_UART0,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device aurora_uart0 = {
+	.name			= "dw-apb-uart",
+	.id			= 0,
+	.dev			= {
+		.platform_data	= aurora_uart0_data,
+	},
+	.resource		= aurora_uart0_resources,
+	.num_resources		= ARRAY_SIZE(aurora_uart0_resources),
+};
+
+/**********
+ * UART-1 *
+ **********/
+ static struct plat_serial8250_port aurora_uart1_data[] = {
+	{
+		.iotype		= UPIO_MEM32,
+		.regshift	= 2,
+		.uartclk	= 0,
+	},
+};
+
+static struct resource aurora_uart1_resources[] = {
+	{
+		.start		= (INTER_REGS_PHYS_BASE | MV_UART_REGS_OFFSET(1)),
+		.end		= (INTER_REGS_PHYS_BASE | MV_UART_REGS_OFFSET(1)) + SZ_256 - 1,
+		.flags		= IORESOURCE_MEM,
+	}, {
+		.start		= IRQ_AURORA_UART1,
+		.end		= IRQ_AURORA_UART1,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device aurora_uart1 = {
+	.name			= "dw-apb-uart",
+	.id			= 0,
+	.dev			= {
+		.platform_data	= aurora_uart1_data,
+	},
+	.resource		= aurora_uart1_resources,
+	.num_resources		= ARRAY_SIZE(aurora_uart1_resources),
+};
+
+void __init serial_initialize(int port)
+{
+	if(port == 0)
+	{
+		if(mvUnitMapIsMine(UART0) == MV_FALSE){
+			printk(KERN_WARNING "uart%d resource not allocated but CONFIG_MV_UART_PORT = %d\n", port, port);
+			mvUnitMapSetMine(UART0);
+		}
+
+		aurora_uart0_data[0].uartclk = mvBoardTclkGet();
+		platform_device_register(&aurora_uart0);
+	}
+	else
+	{
+		if(mvUnitMapIsMine(UART1) == MV_FALSE){
+			printk(KERN_WARNING "uart%d resource not allocated but CONFIG_MV_UART_PORT = %d\n", port, port);
+			mvUnitMapSetMine(UART1);
+		}
+
+		aurora_uart1_data[0].uartclk = mvBoardTclkGet();
+		platform_device_register(&aurora_uart1);
+	}
+}
+
+/*******
+ * GBE *
+ *******/
+#ifdef CONFIG_MV_ETHERNET
+#if defined(CONFIG_MV_ETH_LEGACY)
+static struct platform_device mv88fx_eth = {
+	.name		= "mv88fx_eth",
+	.id		= 0,
+	.num_resources	= 0,
+};
+#elif defined(CONFIG_MV_ETH_NETA)
+static struct platform_device mv88fx_neta = {
+	.name		= "mv88fx_neta",
+	.id		= 0,
+	.num_resources	= 0,
+};
+#else
+#error "Ethernet Mode is not defined (should be Legacy or NETA)"
+#endif /* Ethernet mode: legacy or NETA */
+
+static void __init eth_init(void)
+{
+ struct netaSmpGroupStruct *netaSmpGroupStruct;
+        int cpu, found = 0, portMask;
+
+        netaSmpGroupStruct = kzalloc(sizeof(struct netaSmpGroupStruct), GFP_KERNEL);
+
+        if (!netaSmpGroupStruct) {
+                        printk(KERN_ERR "no memory for private data\n");
+                        return;
+        }
+        else {
+
+#ifdef  CONFIG_SMP
+                netaSmpGroupStruct->cpuMask  = group_cpu_mask;
+#else
+                netaSmpGroupStruct->cpuMask  = 1;
+#endif
+
+                portMask  = (mvUnitMapIsMine(ETH0) == MV_TRUE);
+                portMask |= (mvUnitMapIsMine(ETH1) == MV_TRUE) << 1;
+                portMask |= (mvUnitMapIsMine(ETH2) == MV_TRUE) << 2;
+                portMask |= (mvUnitMapIsMine(ETH3) == MV_TRUE) << 3;
+
+                netaSmpGroupStruct->portMask = portMask;
+        }
+
+        for (cpu = 0; cpu < CONFIG_NR_CPUS; cpu++) {
+                if (MV_BIT_CHECK(netaSmpGroupStruct->cpuMask, cpu))
+                        found = 1;
+        }
+        if (!found) {
+                printk(KERN_ERR "%s: cpuMask does not contain any of the CPUs \n", __func__);
+                printk(KERN_ERR "%s: not initializing network driver\n", __func__);
+                return;
+        }
+        mv88fx_neta.dev.platform_data = netaSmpGroupStruct;
+
+#if defined(CONFIG_MV_ETH_LEGACY)
+        platform_device_register(&mv88fx_eth);
+#elif defined(CONFIG_MV_ETH_NETA)
+        platform_device_register(&mv88fx_neta);
+#endif /* Ethernet mode: legacy or NETA */
+}
+
+#endif /* CONFIG_MV_ETHERNET */
+
+
+/************
+ * GPIO
+ ***********/
+static struct platform_device mv_gpio = {
+	.name	= "mv_gpio",
+	.id		= 0,
+	.num_resources	= 0,
+};
+
+static void __init mv_gpio_init()
+{
+	platform_device_register(&mv_gpio);
+}
+
+/*******
+ * RTC *
+ *******/
+static struct resource alp_rtc_resource[] = {
+	{
+		.start	= INTER_REGS_PHYS_BASE + MV_RTC_REGS_OFFSET,
+		.end	= INTER_REGS_PHYS_BASE + MV_RTC_REGS_OFFSET + 32 - 1,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= IRQ_AURORA_RTC,
+		.flags	= IORESOURCE_IRQ,
+	}
+};
+
+static void __init rtc_init(void)
+{
+	platform_device_register_simple("rtc-mv", -1, alp_rtc_resource, 2);
+}
+
+/*************
+ * 7-Segment *
+ *************/
+static struct timer_list alp_db_timer;
+static void alp_db_7seg_event(unsigned long data)
+{
+	static int count = 0;
+
+	/* Update the 7 segment */
+	mvBoardDebugLed(count);
+
+	/* Incremnt count and arm the timer*/
+	count = (count + 1) & 7;
+	mod_timer(&alp_db_timer, jiffies + 1 * HZ);
+}
+
+static int __init alp_db_7seg_init(void)
+{
+	/* Create the 7segment timer */
+	setup_timer(&alp_db_timer, alp_db_7seg_event, 0);
+
+	/* Arm it expire in 1 second */
+	mod_timer(&alp_db_timer, jiffies + 1 * HZ);
+
+	return 0;
+}
+__initcall(alp_db_7seg_init);
+
+
+/*********************************************************************************/
+/**************                      Helper Routines                **************/
+/*********************************************************************************/
+
+void print_board_info(void)
+{
+	char name_buff[50];
+	printk("\n");
+	printk("  Marvell Avanta-LP");
+
+	mvBoardNameGet(name_buff);
+	printk(" %s Board - ",name_buff);
+
+	mvCtrlModelRevNameGet(name_buff);
+	printk(" Soc: %s",  name_buff);
+#if defined(MV_CPU_LE)
+	printk(" LE\n");
+#else
+	printk(" BE\n");
+#endif
+	printk("  Detected Tclk %d, SysClk %d, FabricClk %d, PClk %d\n",mvTclk, mvSysclk, mvCpuL2ClkGet(), mvCpuPclkGet());
+	printk("  LSP version: %s\n", LSP_VERSION);
+#ifdef CONFIG_MV_AMP_ENABLE
+	mvUnitMapPrint();
+#endif
+	printk("\n");
+}
+
+#ifdef	CONFIG_AURORA_IO_CACHE_COHERENCY
+static void io_coherency_init(void)
+{
+	MV_U32 reg;
+
+	/* set CIB read snoop command to ReadUnique */
+	reg = MV_REG_READ(MV_CIB_CTRL_CFG_REG);
+	reg &= ~(7 << 16);
+	reg |= (7 << 16);
+	MV_REG_WRITE(MV_CIB_CTRL_CFG_REG, reg);
+
+#ifndef CONFIG_SMP
+        /* enable CPUs in SMP group on Fabric coherency */
+	reg = MV_REG_READ(MV_COHERENCY_FABRIC_CTRL_REG);
+	reg &= ~(0x3<<24);
+	reg |= 1<<24;
+	MV_REG_WRITE(MV_COHERENCY_FABRIC_CTRL_REG, reg);
+
+	reg = MV_REG_READ(MV_COHERENCY_FABRIC_CFG_REG);
+	reg &= ~(0x3<<24);
+	reg |= 1<<24;
+	MV_REG_WRITE(MV_COHERENCY_FABRIC_CFG_REG, reg);
+#endif
+}
+#endif
+
+#ifdef CONFIG_DEBUG_LL
+extern void printascii(const char *);
+#endif
+
+/*****************************************************************************
+ * CPU and Fabric
+ ****************************************************************************/
+
+struct ct_desc *ct_desc;
+
+static struct ct_desc *ct_descs[] __initdata = {
+#ifdef CONFIG_ARCH_VEXPRESS_CA9X4
+	&ct_ca9x4_desc,
+#endif
+};
+
+
+static void __init alp_init_irq(void)
+{
+	gic_init(0, 29, (void __iomem *) (INTER_REGS_BASE + A9_MPCORE_GIC_DIST),
+		 (void __iomem *) (INTER_REGS_BASE + A9_MPCORE_GIC_CPU));
+}
+
+static void cpu_fabric_common_init(void)
+{
+	int i;
+
+#if 0
+	for (i = 0; i < ARRAY_SIZE(v2m_amba_devs); i++)
+		amba_device_register(v2m_amba_devs[i], &iomem_resource);
+#endif
+
+#ifdef CONFIG_CACHE_L2X0
+	void __iomem *l2x0_base = (INTER_REGS_BASE + MV_CA9X2_L2CC_OFFSET));
+
+	/* set RAM latencies to 1 cycle for this core tile. */
+	writel(0, l2x0_base + L2X0_TAG_LATENCY_CTRL);
+	writel(0, l2x0_base + L2X0_DATA_LATENCY_CTRL);
+
+	l2x0_init(l2x0_base, 0x00400000, 0xfe0fffff);
+#endif
+#if 0
+	for (i = 0; i < ARRAY_SIZE(mv_ca9x2_amba_devs); i++)
+		amba_device_register(mv_ca9x2_amba_devs[i], &iomem_resource);
+
+	platform_device_register(&pmu_device);
+
+#if 0
+#ifdef	CONFIG_AURORA_IO_CACHE_COHERENCY
+	printk("Support IO coherency.\n");
+	io_coherency_init();
+#endif
+#endif
+#endif
+}
+
+
+/*****************************************************************************
+ * FPGA BOARD: Main Initialization
+ ****************************************************************************/
+extern MV_TARGET_ATTRIB mvTargetDefaultsArray[];
+static void __init alp_fpga_init(void)
+{
+	/* Call Aurora/cpu special configurations */
+	cpu_fabric_common_init();
+
+	/* Select appropriate Board ID for Machine */
+	gBoardId = FPGA_88F78XX0_ID;
+	/* Bypass serdes reconfiguration since already done at bootloader */
+	mvBoardSerdesConfigurationEnableSet(MV_FALSE);
+
+	/* init the Board environment */
+	mvBoardEnvInit();
+
+	/* init the controller environment */
+	if( mvCtrlEnvInit() ) {
+		printk( "Controller env initialization failed.\n" );
+		return;
+	}
+
+	/* Replace PCI-0 Attribute for FPGA 0xE => 0xD */
+	mvTargetDefaultsArray[PEX0_MEM].attrib = 0xD8;
+
+	/* Init the CPU windows setting and the access protection windows. */
+	/*if( mvCpuIfInit(mv_sys_map())) {
+		printk( "Cpu Interface initialization failed.\n" );
+		return;
+	}*/
+
+	avantalp_setup_cpu_mbus();
+
+	/* Init the CPU windows setting and the access protection windows. */
+	if( mvCpuIfInit(mv_sys_map())) {
+		printk( "Cpu Interface initialization failed.\n" );
+		return;
+	}
+
+	/* Init Tclk & SysClk */
+	mvTclk = mvBoardTclkGet();
+	mvSysclk = mvBoardSysClkGet();
+
+	elf_hwcap &= ~HWCAP_JAVA;
+
+	serial_initialize(0);
+
+	/* At this point, the CPU windows are configured according to default definitions in mvSysHwConfig.h */
+	/* and cpuAddrWinMap table in mvCpuIf.c. Now it's time to change defaults for each platform.         */
+	/*mvCpuIfAddDecShow();*/
+
+	print_board_info();
+
+	mv_gpio_init();
+
+	/* RTC */
+	rtc_init();
+
+	return;
+}
+
+MACHINE_START(AVANTA_LP_FPGA, "Marvell Avanta LP FPGA Board")
+	.atag_offset	= 0x00000100,
+	.map_io			= alp_map_io,
+	.init_irq		= alp_init_irq,
+	.timer			= &alp_timer,
+	.init_machine	= alp_fpga_init,
+MACHINE_END
diff --git a/arch/arm/mach-avantalp/core.h b/arch/arm/mach-avantalp/core.h
new file mode 100644
index 0000000..110ced6
--- /dev/null
+++ b/arch/arm/mach-avantalp/core.h
@@ -0,0 +1,16 @@
+#define AMBA_DEVICE(name,busid,base,plat)	\
+struct amba_device name##_device = {		\
+	.dev		= {			\
+		.coherent_dma_mask = ~0UL,	\
+		.init_name = busid,		\
+		.platform_data = plat,		\
+	},					\
+	.res		= {			\
+		.start	= base,			\
+		.end	= base + SZ_4K - 1,	\
+		.flags	= IORESOURCE_MEM,	\
+	},					\
+	.dma_mask	= ~0UL,			\
+	.irq		= IRQ_##base,		\
+	/* .dma		= DMA_##base,*/		\
+}
diff --git a/arch/arm/mach-avantalp/dump_cp15_regs.c b/arch/arm/mach-avantalp/dump_cp15_regs.c
new file mode 100644
index 0000000..bc4901e
--- /dev/null
+++ b/arch/arm/mach-avantalp/dump_cp15_regs.c
@@ -0,0 +1,219 @@
+/*
+ * arch/arm/mach-dove/dump_cp15_regs.c
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+
+static int
+proc_dump_cp15_read(char *page, char **start, off_t off, int count, int *eof,
+			void *data)
+{
+	char *p = page;
+	int len;
+	unsigned int value;
+	
+	asm volatile("mrc p15, 0, %0, c0, c0, 0": "=r"(value));
+	p += sprintf(p, "Main ID: 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c0, c0, 1": "=r"(value));
+	p += sprintf(p, "Cache Type: 0x%08x\n", value);
+	
+#ifdef CONFIG_CPU_V7
+	asm volatile("mrc p15, 0, %0, c0, c0, 2": "=r"(value));
+	p += sprintf(p, "TCM Type: 0x%08x\n", value);
+#endif	
+
+	asm volatile("mrc p15, 0, %0, c0, c0, 3": "=r"(value));
+	p += sprintf(p, "TLB Type: 0x%08x\n", value);
+
+#ifdef CONFIG_CPU_V7
+	asm volatile("mrc p15, 0, %0, c0, c0, 5": "=r"(value));
+	p += sprintf(p, "Microprocessor ID: 0x%08x\n", value);
+#endif	
+
+	asm volatile("mrc p15, 0, %0, c0, c1, 0": "=r"(value));
+	p += sprintf(p, "Processor Feature 0: 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c0, c1, 1": "=r"(value));
+	p += sprintf(p, "Processor Feature 1: 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c0, c1, 2": "=r"(value));
+	p += sprintf(p, "Debug Feature 0: 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c0, c1, 3": "=r"(value));
+	p += sprintf(p, "Auxiliary Feature 0: 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c0, c1, 4": "=r"(value));
+	p += sprintf(p, "Memory Model Feature 0: 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c0, c1, 5": "=r"(value));
+	p += sprintf(p, "Memory Model Feature 1: 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c0, c1, 6": "=r"(value));
+	p += sprintf(p, "Memory Model Feature 2: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c1, 7": "=r"(value));
+	p += sprintf(p, "Memory Model Feature 3: 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c0, c2, 0": "=r"(value));
+	p += sprintf(p, "Set Attribute 0: 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c0, c2, 1": "=r"(value));
+	p += sprintf(p, "Set Attribute 1: 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c0, c2, 2": "=r"(value));
+	p += sprintf(p, "Set Attribute 2: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c0, c2, 3": "=r"(value));
+	p += sprintf(p, "Set Attribute 3: 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c0, c2, 4": "=r"(value));
+	p += sprintf(p, "Set Attribute 4: 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c0, c2, 5": "=r"(value));
+	p += sprintf(p, "Set Attribute 5: 0x%08x\n", value);
+#ifdef CONFIG_CPU_V7
+	asm volatile("mrc p15, 1, %0, c0, c0, 0": "=r"(value));
+	p += sprintf(p, "Current Cache Size ID: 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 1, %0, c0, c0, 1": "=r"(value));
+	p += sprintf(p, "Current Cache Level ID: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 1, %0, c0, c0, 7": "=r"(value));
+	p += sprintf(p, "Silicon ID: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 2, %0, c0, c0, 0": "=r"(value));
+	p += sprintf(p, "Cache Size Selection: 0x%08x\n", value);
+
+#endif
+	asm volatile("mrc p15, 0, %0, c1, c0, 0": "=r"(value));
+	p += sprintf(p, "Control : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c1, c0, 1": "=r"(value));
+	p += sprintf(p, "Auxiliary Control : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c1, c0, 2": "=r"(value));
+	p += sprintf(p, "Coprocessor Access Control : 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c1, c1, 0": "=r"(value));
+	p += sprintf(p, "Secure Configuration : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c2, c0, 0": "=r"(value));
+	p += sprintf(p, "Translation Table Base 0 : 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c2, c0, 1": "=r"(value));
+	p += sprintf(p, "Translation Table Base 1 : 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c2, c0, 2": "=r"(value));
+	p += sprintf(p, "Translation Table Control : 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c3, c0, 0": "=r"(value));
+	p += sprintf(p, "Domain Access Control : 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c5, c0, 0": "=r"(value));
+	p += sprintf(p, "Data Fault Status : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c5, c0, 1": "=r"(value));
+	p += sprintf(p, "Instruction Fault Status : 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c6, c0, 0": "=r"(value));
+	p += sprintf(p, "Data Fault Address : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c6, c0, 1": "=r"(value));
+	p += sprintf(p, "Watchpoint Fault Address : 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c6, c0, 2": "=r"(value));
+	p += sprintf(p, "Instruction Fault Address : 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c7, c10, 6": "=r"(value));
+	p += sprintf(p, "Cache Dirty Status: 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 1, %0, c15, c1, 0": "=r"(value));
+	p += sprintf(p, "Auxiliary Debug Modes Control 0: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 1, %0, c15, c1, 1": "=r"(value));
+	p += sprintf(p, "Auxiliary Debug Modes Control 1: 0x%08x\n", value);
+
+#if 1
+	asm volatile("mrc p15, 1, %0, c15, c1, 0": "=r"(value));
+	p += sprintf(p, "Control Configuration: 0x%08x\n", value);
+	p += sprintf(p, "    Write Buffer Coalescing\t: %s\n", (value & (1 << 8)) ?
+		     "Enabled" : "Disabled");
+	if (value & (1 << 8))
+		p += sprintf(p, "    WB WAIT CYC\t: 0x%x\n", (value >> 9) & 0x7);
+
+	p += sprintf(p, "    Coprocessor dual issue \t: %s\n", (value & (1 << 15)) ?
+		     "Disabled" : "Enabled");
+
+	p += sprintf(p, "    L2 write allocate\t: %s\n", (value & (1 << 28)) ?
+		     "Enabled" : "Disabled");
+
+	p += sprintf(p, "    Streaming\t: %s\n", (value & (1 << 29)) ?
+		     "Enabled" : "Disabled");
+#endif	
+	asm volatile("mrc p15, 1, %0, c15, c12, 0": "=r"(value));
+	p += sprintf(p, "CPU ID Code Extension: 0x%08x\n", value);
+	
+	asm volatile("mrc p15, 0, %0, c9, c14, 0": "=r"(value));
+	p += sprintf(p, "User mode access for PMC registers: %s\n", (value & 1) ?
+		     "Enabled" : "Disabled");
+	asm volatile("mrc p15, 0, %0, c10, c2, 0": "=r"(value));
+	p += sprintf(p, "Memory Attribute PRRR: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 0, %0, c10, c2, 1": "=r"(value));
+	p += sprintf(p, "Memory Attribute NMRR: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 1, %0, c15, c1, 2": "=r"(value));
+	p += sprintf(p, "Auxiliary Debug Modes Control 2: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 1, %0, c15, c2, 0": "=r"(value));
+	p += sprintf(p, "Auxiliary Functional Modes Control 0: 0x%08x\n", value);
+
+	asm volatile("mrc p15, 1, %0, c15, c2, 1": "=r"(value));
+	p += sprintf(p, "Auxiliary Functional Modes Control 1: 0x%08x\n", value);
+
+	len = (p - page) - off;
+	if (len < 0)
+		len = 0;
+	
+	*eof = (len <= count) ? 1 : 0;
+	*start = page + off;
+
+	return len;
+}
+int dump_init_module(void)
+{
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry *res;
+	res = create_proc_entry("mv_dump_cp15", S_IRUSR, NULL);
+	if (!res)
+		return -ENOMEM;
+
+	res->read_proc = proc_dump_cp15_read;
+#endif
+
+	return 0;
+}
+
+void dump_cleanup_module(void)
+{
+	remove_proc_entry("mv_dump_cp15", NULL);
+}
+
+module_init(dump_init_module);
+module_exit(dump_cleanup_module);
+
+MODULE_AUTHOR("Saeed Bishara");
+MODULE_LICENSE("GPL");
+
diff --git a/arch/arm/mach-avantalp/export.c b/arch/arm/mach-avantalp/export.c
new file mode 100644
index 0000000..1d01e61
--- /dev/null
+++ b/arch/arm/mach-avantalp/export.c
@@ -0,0 +1,217 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/export.h>
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "mvDebug.h"
+#include "mvSysHwConfig.h"
+#include "pex/mvPexRegs.h"
+#include "cntmr/mvCntmr.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "mvOs.h"
+
+
+/*************************************************************************************************************
+ * Environment 
+ *************************************************************************************************************/
+extern u32 mvTclk;
+extern u32 mvSysclk;
+
+EXPORT_SYMBOL(mv_early_printk);
+EXPORT_SYMBOL(mvCtrlPwrClckGet);
+EXPORT_SYMBOL(mvCtrlModelRevGet);
+EXPORT_SYMBOL(mvTclk);
+EXPORT_SYMBOL(mvSysclk);
+EXPORT_SYMBOL(mvCtrlModelGet);
+EXPORT_SYMBOL(mvOsIoUncachedMalloc);
+EXPORT_SYMBOL(mvOsIoUncachedFree);
+EXPORT_SYMBOL(mvOsIoCachedMalloc);
+EXPORT_SYMBOL(mvOsIoCachedFree);
+EXPORT_SYMBOL(mvDebugMemDump);
+EXPORT_SYMBOL(mvHexToBin);
+EXPORT_SYMBOL(mvBinToHex);
+EXPORT_SYMBOL(mvSizePrint);
+EXPORT_SYMBOL(mvDebugPrintMacAddr);
+EXPORT_SYMBOL(mvCtrlEthMaxPortGet);
+EXPORT_SYMBOL(mvCtrlTargetNameGet);
+EXPORT_SYMBOL(mvBoardIdGet);
+EXPORT_SYMBOL(mvBoardPhyAddrGet);
+EXPORT_SYMBOL(mvCpuIfTargetWinGet);
+EXPORT_SYMBOL(mvMacStrToHex);
+EXPORT_SYMBOL(mvBoardTclkGet);
+EXPORT_SYMBOL(mvBoardMacSpeedGet);
+EXPORT_SYMBOL(mvWinOverlapTest);
+EXPORT_SYMBOL(mvCtrlAddrWinMapBuild);
+EXPORT_SYMBOL(mvBoardTdmSpiModeGet);
+EXPORT_SYMBOL(mvBoardTdmSpiCsGet);
+EXPORT_SYMBOL(mvBoardTdmDevicesCountGet);
+
+#ifdef CONFIG_MV_INCLUDE_SPI
+#include "spi/mvSpiCmnd.h"
+EXPORT_SYMBOL(mvSpiWriteThenWrite);
+EXPORT_SYMBOL(mvSpiWriteThenRead);
+#include "spi/mvSpi.h"
+EXPORT_SYMBOL(mvSpiParamsSet);
+#endif
+#include "gpp/mvGpp.h"
+EXPORT_SYMBOL(mvGppValueSet);
+
+/*************************************************************************************************************
+ * TDM
+ *************************************************************************************************************/
+#if defined(MV_INCLUDE_TDM)
+EXPORT_SYMBOL(mvCtrlTdmUnitIrqGet);
+EXPORT_SYMBOL(mvCtrlTdmUnitTypeGet);
+#endif
+
+/*************************************************************************************************************
+ * Audio
+ *************************************************************************************************************/
+#ifdef CONFIG_MV_INCLUDE_AUDIO
+#include "audio/mvAudio.h"
+#include "mvSysAudioApi.h"
+EXPORT_SYMBOL(mvSPDIFRecordTclockSet);
+EXPORT_SYMBOL(mvSPDIFPlaybackCtrlSet);
+EXPORT_SYMBOL(mvI2SPlaybackCtrlSet);
+EXPORT_SYMBOL(mvAudioPlaybackControlSet);
+EXPORT_SYMBOL(mvAudioDCOCtrlSet);
+EXPORT_SYMBOL(mvI2SRecordCntrlSet);
+EXPORT_SYMBOL(mvAudioRecordControlSet);
+EXPORT_SYMBOL(mvSysAudioInit);
+EXPORT_SYMBOL(mvBoardA2DTwsiAddrGet);
+EXPORT_SYMBOL(mvBoardA2DTwsiAddrTypeGet);
+#endif
+
+/*************************************************************************************************************
+ * USB
+ *************************************************************************************************************/
+#ifdef CONFIG_MV_INCLUDE_USB
+extern u32 mvIsUsbHost;
+
+#include "usb/mvUsb.h"
+EXPORT_SYMBOL(mvIsUsbHost);
+EXPORT_SYMBOL(mvCtrlUsbMaxGet);
+EXPORT_SYMBOL(mvUsbGetCapRegAddr);
+#ifdef MV_USB_VOLTAGE_FIX
+EXPORT_SYMBOL(mvUsbGppInit);
+EXPORT_SYMBOL(mvUsbBackVoltageUpdate);
+#endif
+#endif /* CONFIG_MV_INCLUDE_USB */
+
+/*************************************************************************************************************
+ * CESA
+ *************************************************************************************************************/
+#ifdef CONFIG_MV_INCLUDE_CESA
+#include "mvSysCesaApi.h"
+#include "cesa/mvCesa.h"
+#include "cesa/mvMD5.h"
+#include "cesa/mvSHA1.h"
+extern unsigned char*  mv_sram_usage_get(int* sram_size_ptr);
+
+EXPORT_SYMBOL(mvSysCesaInit);
+EXPORT_SYMBOL(mvCesaSessionOpen);
+EXPORT_SYMBOL(mvCesaSessionClose);
+EXPORT_SYMBOL(mvCesaAction);
+EXPORT_SYMBOL(mvCesaReadyGet);
+EXPORT_SYMBOL(mvCesaCopyFromMbuf);
+EXPORT_SYMBOL(mvCesaCopyToMbuf);
+EXPORT_SYMBOL(mvCesaMbufCopy);
+EXPORT_SYMBOL(mvCesaCryptoIvSet);
+EXPORT_SYMBOL(mvMD5);
+EXPORT_SYMBOL(mvSHA1);
+
+EXPORT_SYMBOL(mvCesaDebugQueue);
+EXPORT_SYMBOL(mvCesaDebugSram);
+EXPORT_SYMBOL(mvCesaDebugSAD);
+EXPORT_SYMBOL(mvCesaDebugStatus);
+EXPORT_SYMBOL(mvCesaDebugMbuf);
+EXPORT_SYMBOL(mvCesaDebugSA);
+EXPORT_SYMBOL(mv_sram_usage_get);
+
+extern u32 mv_crypto_virt_base_get(void);
+extern u32 mv_crypto_phys_base_get(void);
+EXPORT_SYMBOL(mv_crypto_virt_base_get);
+EXPORT_SYMBOL(mv_crypto_phys_base_get);
+EXPORT_SYMBOL(cesaReqResources);
+EXPORT_SYMBOL(mvCesaFinish);
+
+#endif
+
+/*************************************************************************************************************
+ * Flashes
+ *************************************************************************************************************/
+#if defined (CONFIG_MV_INCLUDE_SPI)
+#include <sflash/mvSFlash.h>
+#include <sflash/mvSFlashSpec.h>
+EXPORT_SYMBOL(mvSFlashInit);
+EXPORT_SYMBOL(mvSFlashSectorErase);
+EXPORT_SYMBOL(mvSFlashChipErase);
+EXPORT_SYMBOL(mvSFlashBlockRd);
+EXPORT_SYMBOL(mvSFlashBlockWr);
+EXPORT_SYMBOL(mvSFlashIdGet);
+EXPORT_SYMBOL(mvSFlashWpRegionSet);
+EXPORT_SYMBOL(mvSFlashWpRegionGet);
+EXPORT_SYMBOL(mvSFlashStatRegLock);
+EXPORT_SYMBOL(mvSFlashSizeGet);
+EXPORT_SYMBOL(mvSFlashPowerSaveEnter);
+EXPORT_SYMBOL(mvSFlashPowerSaveExit);
+EXPORT_SYMBOL(mvSFlashModelGet);
+#endif
+
+
+/*************************************************************************************************************
+ * SATA
+ *************************************************************************************************************/
+#ifdef CONFIG_MV_INCLUDE_INTEG_SATA
+#include <sata/CoreDriver/mvSata.h>
+EXPORT_SYMBOL(mvSataWinInit);
+#endif
+
+/*************************************************************************************************************
+ * DMA/XOR
+ *************************************************************************************************************/
+#if defined (CONFIG_MV_XOR_MEMCOPY) || defined (CONFIG_MV_IDMA_MEMCOPY)
+EXPORT_SYMBOL(asm_memcpy);
+#endif
+
+#ifdef CONFIG_MV_SP_I_FTCH_DB_INV 
+EXPORT_SYMBOL(mv_l2_inv_range);
+#endif
+
+/*************************************************************************************************************
+ * Marvell TRACE
+ *************************************************************************************************************/
+#ifdef CONFIG_MV_DBG_TRACE
+#include "dbg-trace.h"
+EXPORT_SYMBOL(TRC_INIT);
+EXPORT_SYMBOL(TRC_REC);
+EXPORT_SYMBOL(TRC_OUTPUT);
+EXPORT_SYMBOL(TRC_START);
+EXPORT_SYMBOL(TRC_RELEASE);
+#endif
+
+#ifdef CONFIG_MV_ETH_NFP_MODULE
+#ifdef CONFIG_MV_ETH_BM
+#include "bm/mvBm.h"
+EXPORT_SYMBOL(mvBmVirtBase);
+#endif
+#include "mvList.h"
+EXPORT_SYMBOL(mvListCreate);
+EXPORT_SYMBOL(mvListDestroy);
+#endif
diff --git a/arch/arm/mach-avantalp/flashmap.c b/arch/arm/mach-avantalp/flashmap.c
new file mode 100644
index 0000000..d3569ef
--- /dev/null
+++ b/arch/arm/mach-avantalp/flashmap.c
@@ -0,0 +1,255 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell 
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+********************************************************************************/
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <drivers/mtd/mtdcore.h>
+#include <linux/mtd/partitions.h>
+#include <linux/version.h>
+#include "mvSysHwConfig.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "ctrlEnv/mvUnitMap.h"
+
+#define MTD_FLASH_MAP_DEBUG
+
+#ifdef MTD_FLASH_MAP_DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+#define MTD_MAX_FLASH_NUMBER	4
+#define MTD_DUMMY_BANK_WIDTH	2
+
+struct maps_init_info
+{
+	struct map_info mapInfo;
+	char ** mtdDrv;
+	struct mtd_info * mtdInfo;
+	char name[32];
+};
+
+static struct maps_init_info maps[MTD_MAX_FLASH_NUMBER];
+static unsigned int mapsNum = 0;
+
+#if defined (CONFIG_MTD_CFI) || defined (CONFIG_MTD_JEDECPROBE)
+static char * cfiDev = "cfi_flash";
+static char * cfiMtdList[] = { "cfi_probe", NULL };
+#endif
+
+#ifdef CONFIG_MV_INCLUDE_SFLASH_MTD
+static char * sflashDev = "spi_flash";
+static char * sflashMtdList[] = {"sflash", NULL};
+#endif
+
+#ifdef CONFIG_MTD_CMDLINE_PARTS
+static struct mtd_partition *mtd_parts;
+static int                   mtd_parts_nb;
+static const char *part_probes[] __initdata = {"cmdlinepart", NULL};
+#endif /* CONFIG_MTD_CMDLINE_PARTS */
+
+static int flashInfoFill(void)
+{
+	int expectedDevs = 0;
+	int devs, i;
+
+	/* clear the whole array */
+	memset((void*)maps, 0x0, sizeof(maps));
+
+#if defined (CONFIG_MTD_CFI) || defined (CONFIG_MTD_JEDECPROBE)
+	/* gather the CFI and JEDEC NOR flash devices information */
+	devs = mvBoardGetDevicesNumber(BOARD_DEV_NOR_FLASH);
+
+	for(i=0; i<devs; i++) {
+		if (expectedDevs >= MTD_MAX_FLASH_NUMBER) {
+			printk(KERN_NOTICE "\nERROR: %s - Exceeded MAX MTD flash devices number", __FUNCTION__);
+			break;
+		}
+		maps[expectedDevs].mtdDrv = cfiMtdList;	
+		sprintf(maps[expectedDevs].name, "%s_%d", cfiDev, i);
+		maps[expectedDevs].mapInfo.name = maps[expectedDevs].name;
+		maps[expectedDevs].mapInfo.phys = mvBoardGetDeviceBaseAddr(i, BOARD_DEV_NOR_FLASH);
+		maps[expectedDevs].mapInfo.size = mvBoardGetDeviceWinSize(i, BOARD_DEV_NOR_FLASH);
+		maps[expectedDevs].mapInfo.bankwidth = (mvBoardGetDeviceBusWidth(i, BOARD_DEV_NOR_FLASH) / 8);
+		
+		if ((maps[expectedDevs].mapInfo.phys != 0xFFFFFFFF) && 
+		    (maps[expectedDevs].mapInfo.size != 0xFFFFFFFF)) {
+			DB(printk("\nINFO: Found %s %d - base 0x%08x, size 0x%x, bus %d", maps[expectedDevs].mapInfo.name, i,
+			   (unsigned int)maps[expectedDevs].mapInfo.phys, (unsigned int)maps[expectedDevs].mapInfo.size, maps[expectedDevs].mapInfo.bankwidth));
+			++expectedDevs;
+		} else {
+			printk(KERN_NOTICE "\nERROR: %s - Failed to get Device Base address and Size (%s %d)", __FUNCTION__, maps[expectedDevs].mapInfo.name, i);
+		}
+	}
+#endif
+	
+#ifdef CONFIG_MV_INCLUDE_SFLASH_MTD
+	/* gather the SPI flash devices information */
+	devs = mvBoardGetDevicesNumber(BOARD_DEV_SPI_FLASH);
+
+	for(i=0; i<devs; i++) {
+		if (expectedDevs >= MTD_MAX_FLASH_NUMBER) {
+			printk(KERN_NOTICE "\nERROR: %s - Exceeded MAX MTD flash devices number", __FUNCTION__);
+			break;
+		}
+		maps[expectedDevs].mtdDrv = sflashMtdList;
+		maps[expectedDevs].mapInfo.name = sflashDev;
+		maps[expectedDevs].mapInfo.phys = mvBoardGetDeviceBaseAddr(i, BOARD_DEV_SPI_FLASH);
+		maps[expectedDevs].mapInfo.size = mvBoardGetDeviceWinSize(i, BOARD_DEV_SPI_FLASH);
+		maps[expectedDevs].mapInfo.bankwidth = MTD_DUMMY_BANK_WIDTH;
+
+		if ((maps[expectedDevs].mapInfo.phys != 0xFFFFFFFF) && 
+		    (maps[expectedDevs].mapInfo.size != 0xFFFFFFFF)) {
+			DB(printk("\nINFO: Found %s %d - base 0x%08x, size 0x%x", maps[expectedDevs].mapInfo.name, i,
+						(unsigned int)maps[expectedDevs].mapInfo.phys,
+						(unsigned int)maps[expectedDevs].mapInfo.size));
+			++expectedDevs;
+		} else {
+			printk(KERN_NOTICE "\nERROR: %s - Failed to get Device Base address and Size (%s %d)",
+					__FUNCTION__, maps[expectedDevs].mapInfo.name, i);
+		}
+	}
+#endif
+
+	DB(printk("\nINFO: %s - Found %d Flash Devices", __FUNCTION__, expectedDevs));
+	return expectedDevs;
+}
+
+static int __init flashProbe(char ** mtdDrv, struct map_info * map, struct mtd_info ** mtd)
+{
+	if ((mtdDrv == NULL) || (map == NULL) || (mtd == NULL)) {
+		printk(KERN_NOTICE "\nERROR: NULL pointer parameter at %s entry", __FUNCTION__);
+		return -EINVAL;
+	}
+
+	/* remap the physical address to a virtual address */
+	map->virt = ioremap(map->phys, map->size);
+	if (!map->virt) {
+		printk(KERN_NOTICE "\nERROR: Failed to ioremap Flash device at physical base 0x%x.", (unsigned int)map->phys);
+		return -EIO;
+	}
+	
+	DB(printk("\nINFO: Io remapped successfully - phy addr = 0x%08x, virt addr = 0x%08x",
+				(unsigned int)map->phys, (unsigned int)map->virt));
+
+	simple_map_init(map);
+
+	*mtd = NULL;
+	for(; (!(*mtd) && *mtdDrv); mtdDrv++) {
+		DB(printk("\nINFO: Using %s to probe %s at address 0x%08x, size 0x%x, width %dm",
+					*mtdDrv, map->name, (unsigned int)map->phys,
+					(unsigned int)map->size, map->bankwidth));
+		if ((*mtd = do_map_probe(*mtdDrv, map))) {
+			DB(printk(" - detected OK"));
+			/*map->size = (*mtd)->size;*/
+			(*mtd)->owner = THIS_MODULE;
+
+#ifdef CONFIG_MTD_CMDLINE_PARTS
+			mtd_parts_nb = parse_mtd_partitions(*mtd, part_probes, &mtd_parts, 0);
+
+			if (mtd_parts_nb > 0) {
+				add_mtd_partitions (*mtd, mtd_parts, mtd_parts_nb);
+				return 0;
+			}
+#endif
+
+			if (/*add_mtd_device(*mtd) != 0*/mtd_device_register(*mtd, NULL,0)){
+				printk(KERN_NOTICE "\nERROR: %s - Failed to add the mtd device", __FUNCTION__);
+				iounmap((void *)map->virt);
+				map->virt = 0;
+				return -ENXIO;
+			}
+
+			return 0;
+		} else {
+			DB(printk(" - Not detected"));
+		}
+	}
+ 
+	iounmap((void *)map->virt);
+	map->virt = 0;
+	return -ENXIO;
+}
+	
+static int __init flash_map_init(void)
+{	
+	int i;
+
+	if(mvUnitMapIsMine(SPI) == MV_FALSE)
+		return 0;
+
+	mapsNum = flashInfoFill();
+	DB(printk("\nINFO: flash_map_init - detected %d devices\n",  mapsNum));
+
+	for (i=0; i<mapsNum; i++) {
+		DB(printk("MTD: Initialize the %s device at address 0x%08x\n", maps[i].mapInfo.name, (unsigned int)maps[i].mapInfo.phys));
+		if (flashProbe(maps[i].mtdDrv, &maps[i].mapInfo, &maps[i].mtdInfo) == 0) {
+			DB(printk(" - OK.\n"));
+		} else {
+			maps[i].mtdInfo = NULL;
+			DB(printk(" - FAILED!\n"));
+		}
+	}
+
+	return 0;
+}
+
+static void __exit flash_map_exit(void)
+{
+	int i;
+
+	for (i=0; i<mapsNum; i++) {
+		if (maps[i].mtdInfo) {
+			//del_mtd_device(maps[i].mtdInfo);
+			  mtd_device_unregister(maps[i].mtdInfo);
+			map_destroy(maps[i].mtdInfo);
+		}
+
+		if (maps[i].mapInfo.virt) {
+			iounmap((void *)maps[i].mapInfo.virt);
+			maps[i].mapInfo.virt = 0;
+		}
+	}
+}
+
+module_init(flash_map_init);
+module_exit(flash_map_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("MTD map driver for Marvell platforms");
diff --git a/arch/arm/mach-avantalp/headsmp.S b/arch/arm/mach-avantalp/headsmp.S
new file mode 100644
index 0000000..87fef0e
--- /dev/null
+++ b/arch/arm/mach-avantalp/headsmp.S
@@ -0,0 +1,40 @@
+/*
+ *  linux/arch/arm/plat-versatile/headsmp.S
+ *
+ *  Copyright (c) 2003 ARM Limited
+ *  All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/linkage.h>
+#include <linux/init.h>
+
+	__INIT
+
+/*
+ * Realview/Versatile Express specific entry point for secondary CPUs.
+ * This provides a "holding pen" into which all secondary cores are held
+ * until we're ready for them to initialise.
+ */
+ENTRY(avantalp_secondary_startup)
+	mrc	p15, 0, r0, c0, c0, 5
+	and	r0, r0, #15
+	adr	r4, 1f
+	ldmia	r4, {r5, r6}
+	sub	r4, r4, r5
+	add	r6, r6, r4
+pen:	ldr	r7, [r6]
+	cmp	r7, r0
+	bne	pen
+
+	/*
+	 * we've been released from the holding pen: secondary_stack
+	 * should now contain the SVC stack for this core
+	 */
+	b	secondary_startup
+
+	.align
+1:	.long	.
+	.long	pen_release
diff --git a/arch/arm/mach-avantalp/hotplug.c b/arch/arm/mach-avantalp/hotplug.c
new file mode 100644
index 0000000..813ee08
--- /dev/null
+++ b/arch/arm/mach-avantalp/hotplug.c
@@ -0,0 +1,123 @@
+/*
+ *  linux/arch/arm/mach-realview/hotplug.c
+ *
+ *  Copyright (C) 2002 ARM Ltd.
+ *  All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/smp.h>
+
+#include <asm/cacheflush.h>
+#include <asm/system.h>
+
+extern volatile int pen_release;
+
+static inline void cpu_enter_lowpower(void)
+{
+	unsigned int v;
+
+	flush_cache_all();
+	asm volatile(
+		"mcr	p15, 0, %1, c7, c5, 0\n"
+	"	mcr	p15, 0, %1, c7, c10, 4\n"
+	/*
+	 * Turn off coherency
+	 */
+	"	mrc	p15, 0, %0, c1, c0, 1\n"
+	"	bic	%0, %0, %3\n"
+	"	mcr	p15, 0, %0, c1, c0, 1\n"
+	"	mrc	p15, 0, %0, c1, c0, 0\n"
+	"	bic	%0, %0, %2\n"
+	"	mcr	p15, 0, %0, c1, c0, 0\n"
+	  : "=&r" (v)
+	  : "r" (0), "Ir" (CR_C), "Ir" (0x40)
+	  : "cc");
+}
+
+static inline void cpu_leave_lowpower(void)
+{
+	unsigned int v;
+
+	asm volatile(
+		"mrc	p15, 0, %0, c1, c0, 0\n"
+	"	orr	%0, %0, %1\n"
+	"	mcr	p15, 0, %0, c1, c0, 0\n"
+	"	mrc	p15, 0, %0, c1, c0, 1\n"
+	"	orr	%0, %0, %2\n"
+	"	mcr	p15, 0, %0, c1, c0, 1\n"
+	  : "=&r" (v)
+	  : "Ir" (CR_C), "Ir" (0x40)
+	  : "cc");
+}
+
+static inline void platform_do_lowpower(unsigned int cpu, int *spurious)
+{
+	/*
+	 * there is no power-control hardware on this platform, so all
+	 * we can do is put the core into WFI; this is safe as the calling
+	 * code will have already disabled interrupts
+	 */
+	for (;;) {
+		wfi();
+
+		if (pen_release == cpu_logical_map(cpu)) {
+			/*
+			 * OK, proper wakeup, we're done
+			 */
+			break;
+		}
+
+		/*
+		 * Getting here, means that we have come out of WFI without
+		 * having been woken up - this shouldn't happen
+		 *
+		 * Just note it happening - when we're woken, we can report
+		 * its occurrence.
+		 */
+		(*spurious)++;
+	}
+}
+
+int platform_cpu_kill(unsigned int cpu)
+{
+	return 1;
+}
+
+/*
+ * platform-specific code to shutdown a CPU
+ *
+ * Called with IRQs disabled
+ */
+void platform_cpu_die(unsigned int cpu)
+{
+	int spurious = 0;
+
+	/*
+	 * we're ready for shutdown now, so do it
+	 */
+	cpu_enter_lowpower();
+	platform_do_lowpower(cpu, &spurious);
+
+	/*
+	 * bring this CPU back into the world of cache
+	 * coherency, and then restore interrupts
+	 */
+	cpu_leave_lowpower();
+
+	if (spurious)
+		pr_warn("CPU%u: %u spurious wakeup calls\n", cpu, spurious);
+}
+
+int platform_cpu_disable(unsigned int cpu)
+{
+	/*
+	 * we don't allow CPU 0 to be shutdown (it is still too special
+	 * e.g. clock tick interrupts)
+	 */
+	return cpu == 0 ? -EPERM : 0;
+}
diff --git a/arch/arm/mach-avantalp/hwmon.c b/arch/arm/mach-avantalp/hwmon.c
new file mode 100644
index 0000000..eb87175
--- /dev/null
+++ b/arch/arm/mach-avantalp/hwmon.c
@@ -0,0 +1,399 @@
+/*
+ * hwmon-axp.c - temperature monitoring driver for Dove SoC
+ *
+ * Inspired from other hwmon drivers
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301 USA.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/jiffies.h>
+#include <linux/hwmon.h>
+#include <linux/sysfs.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/err.h>
+#include <linux/list.h>
+#include <linux/platform_device.h>
+#include <linux/cpu.h>
+#include <asm/io.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+
+/* Termal Sensor Registers */
+#define TSEN_STATUS_REG				0x184C4
+#define	TSEN_STATUS_TEMP_OUT_OFFSET		1
+#define	TSEN_STATUS_TEMP_OUT_MASK		(0x1FF << TSEN_STATUS_TEMP_OUT_OFFSET)
+
+#define TSEN_CONF_REG				0x184D0
+#define	TSEN_CONF_OTF_CALIB_MASK		(0x1 << 30)
+#define	TSEN_CONF_START_CALIB_MASK		(0x1 << 25)
+#define	TSEN_CONF_REF_CAL_MASK			(0x1FF << 11)
+#define	TSEN_CONF_SOFT_RESET_MASK		(0x1 << 1)
+
+#define ARMADAXP_OVERHEAT_TEMP	105		/* milidegree Celsius */
+#define ARMADAXP_OVERHEAT_DELAY	0x700
+#define ARMADAXP_OVERCOOL_TEMP	10		/* milidegree Celsius */
+#define	ARMADAXP_OVERCOOL_DELAY	0x700
+#define ARMADAXP_OVERHEAT_MIN	0
+#define ARMADAXP_OVERHEAT_MAX	110000
+#define ARMADAXP_OVERCOOL_MIN	0
+#define ARMADAXP_OVERCOOL_MAX	110000
+#define PMU_THERMAL_MNGR_REG	0x184c4
+#define	PMU_INT_MASK_REG        0x1C124
+#define	PMU_INT_CAUSE_REG	0x1c120
+#define PMU_INT_OVRHEAT_MASK	0x1
+#define PMU_INT_COOLING_MASK	0x2
+
+#define PMU_TM_COOL_THRSH_OFFS          10
+#define PMU_TM_COOL_THRSH_MASK          (0x1FF << PMU_TM_COOL_THRSH_OFFS)
+#define PMU_TM_OVRHEAT_THRSH_OFFS       19
+#define PMU_TM_OVRHEAT_THRSH_MASK       (0x1FF << PMU_TM_OVRHEAT_THRSH_OFFS)
+
+#define PMU_TM_DISABLE_OFFS             0
+#define PMU_TM_DISABLE_MASK             (0x1 << PMU_TM_DISABLE_OFFS)
+
+
+#define	PMU_TM_OVRHEAT_DLY_REG  0x184cc
+#define	PMU_TM_COOLING_DLY_REG	0x184c8
+
+/* Junction Temperature */
+#define ARMADAXP_TSEN_TEMP2RAW(x) ((3153000 - (13825 * x)) / 10000)
+#define ARMADAXP_TSEN_RAW2TEMP(x) ((3153000 - (10000 * x)) / 13825)
+
+#define LABEL "T-junction"
+static struct device *hwmon_dev;
+unsigned int temp_min = ARMADAXP_OVERCOOL_TEMP;
+unsigned int temp_max = ARMADAXP_OVERHEAT_TEMP;
+
+typedef enum {
+	SHOW_TEMP,
+	TEMP_MAX,
+	TEMP_MIN,
+	SHOW_NAME,
+	SHOW_TYPE,
+	SHOW_LABEL } SHOW;
+
+static void axptemp_set_thresholds(unsigned int max, unsigned int min)
+{
+	u32 temp, reg;
+
+	reg = readl(INTER_REGS_BASE | PMU_THERMAL_MNGR_REG);
+        reg &= ~PMU_TM_DISABLE_MASK;
+        writel(reg, (INTER_REGS_BASE | PMU_THERMAL_MNGR_REG));
+
+	/* Set the overheat threashold & delay */
+	temp = ARMADAXP_TSEN_TEMP2RAW(max);
+	reg = readl(INTER_REGS_BASE | PMU_THERMAL_MNGR_REG);
+	reg &= ~PMU_TM_OVRHEAT_THRSH_MASK;
+	reg |= (temp << PMU_TM_OVRHEAT_THRSH_OFFS);
+	writel(reg, (INTER_REGS_BASE | PMU_THERMAL_MNGR_REG));
+
+	/* Set the cool threshole & delay */
+	temp = ARMADAXP_TSEN_TEMP2RAW(min);
+	reg = readl(INTER_REGS_BASE | PMU_THERMAL_MNGR_REG);
+	reg &= ~PMU_TM_COOL_THRSH_MASK;
+	reg |= (temp << PMU_TM_COOL_THRSH_OFFS);
+	writel(reg, (INTER_REGS_BASE | PMU_THERMAL_MNGR_REG));
+}
+
+static int axptemp_init_sensor(void)
+{
+	u32 reg;
+
+	/* init the TSEN sensor once */
+	/* Enable On-The-Fly Calibration mode */
+	reg = readl(INTER_REGS_BASE | TSEN_CONF_REG);
+	reg |= TSEN_CONF_OTF_CALIB_MASK;
+	writel(reg, (INTER_REGS_BASE | TSEN_CONF_REG));
+
+	/* Set the Reference Count value */
+	reg = readl(INTER_REGS_BASE | TSEN_CONF_REG);
+	reg &= ~(TSEN_CONF_REF_CAL_MASK);
+	reg |= (0xf1 << 11);
+	writel(reg, (INTER_REGS_BASE | TSEN_CONF_REG));
+
+	/* Do not start calibration sequence */
+	reg = readl(INTER_REGS_BASE | TSEN_CONF_REG);
+	reg &= ~(TSEN_CONF_START_CALIB_MASK);
+	writel(reg, (INTER_REGS_BASE | TSEN_CONF_REG));
+
+	/* Initiate Soft Reset
+	reg = readl(INTER_REGS_BASE | TSEN_CONF_REG);
+	reg |= TSEN_CONF_SOFT_RESET_MASK;
+	writel(reg, (INTER_REGS_BASE | TSEN_CONF_REG));
+	*/
+	//udelay(1000);
+
+	/* Exit from Soft Reset
+	reg = readl(INTER_REGS_BASE | TSEN_CONF_REG);
+	reg &= ~(TSEN_CONF_SOFT_RESET_MASK);
+	writel(reg, (INTER_REGS_BASE | TSEN_CONF_REG));
+	*/
+	//udelay(10000);
+
+
+	/* Set thresholds */
+	axptemp_set_thresholds(temp_max, temp_min);
+
+	/* Set delays */
+	writel(ARMADAXP_OVERHEAT_DELAY, (INTER_REGS_BASE | PMU_TM_OVRHEAT_DLY_REG));
+	writel(ARMADAXP_OVERCOOL_DELAY, (INTER_REGS_BASE | PMU_TM_COOLING_DLY_REG));
+
+	/* Clear & unmask cooling/overheat interrupts */
+	writel(0, (INTER_REGS_BASE | PMU_INT_CAUSE_REG));
+	writel((PMU_INT_OVRHEAT_MASK | PMU_INT_COOLING_MASK), (INTER_REGS_BASE | PMU_INT_MASK_REG));
+
+	return 0;
+}
+
+static int axptemp_read_temp(void)
+{
+	int reg;
+
+	reg = readl(INTER_REGS_BASE | TSEN_STATUS_REG);
+	reg = (reg & TSEN_STATUS_TEMP_OUT_MASK) >> TSEN_STATUS_TEMP_OUT_OFFSET;
+	return ARMADAXP_TSEN_RAW2TEMP(reg);
+}
+
+
+/*
+ * Sysfs stuff
+ */
+
+static ssize_t show_name(struct device *dev, struct device_attribute
+			  *devattr, char *buf) {
+	return sprintf(buf, "%s\n", "axp-hwmon");
+}
+
+static ssize_t show_alarm(struct device *dev, struct device_attribute
+			  *devattr, char *buf)
+{
+
+	int alarm = 0;
+	u32 reg;
+
+	reg = readl(INTER_REGS_BASE | PMU_INT_CAUSE_REG);
+	if (reg & PMU_INT_OVRHEAT_MASK)
+	{
+		alarm = 1;
+		writel ((reg & ~PMU_INT_OVRHEAT_MASK), (INTER_REGS_BASE | PMU_INT_CAUSE_REG));
+	}
+	else if (reg & PMU_INT_COOLING_MASK)
+	{
+		alarm = 2;
+		writel ((reg & ~PMU_INT_COOLING_MASK), (INTER_REGS_BASE | PMU_INT_CAUSE_REG));
+	}
+
+	return sprintf(buf, "%d\n", alarm);
+}
+
+static ssize_t show_info(struct device *dev,
+			 struct device_attribute *devattr, char *buf) {
+	int ret;
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+
+	if (attr->index == SHOW_TYPE)
+		ret = sprintf(buf, "%d\n", 3);
+	else if (attr->index == SHOW_LABEL)
+		ret = sprintf(buf, "%s\n", LABEL);
+	else
+		ret = sprintf(buf, "%d\n", -1);
+	return ret;
+}
+
+static ssize_t show_temp(struct device *dev,
+			 struct device_attribute *devattr, char *buf) {
+	int ret;
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+
+	if (attr->index == SHOW_TEMP)
+		ret = sprintf(buf, "%d \n", axptemp_read_temp());
+	else if (attr->index == TEMP_MAX)
+		ret = sprintf(buf, "%d\n", temp_max);
+	else if (attr->index == TEMP_MIN)
+		ret = sprintf(buf, "%d\n", temp_min);
+	else
+		ret = sprintf(buf, "%d\n", -1);
+
+	return ret;
+}
+
+static ssize_t set_temp(struct device *dev, struct device_attribute *devattr,
+			 const char *buf, size_t count) {
+
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+	unsigned int temp;
+
+	if (sscanf(buf, "%d", &temp) != 1)
+		printk(KERN_WARNING "Invalid input string for temperature!");
+
+	if (attr->index == TEMP_MAX) {
+		if((temp < ARMADAXP_OVERHEAT_MIN) || (temp > ARMADAXP_OVERHEAT_MAX))
+			printk(KERN_WARNING "Invalid max temperature input (out of range: %d-%d)!",
+				ARMADAXP_OVERHEAT_MIN, ARMADAXP_OVERHEAT_MAX);
+		else {
+			temp_max = temp;
+			axptemp_set_thresholds(temp_max, temp_min);
+		}
+	}
+	else if (attr->index == TEMP_MIN) {
+		if((temp < ARMADAXP_OVERCOOL_MIN) || (temp > ARMADAXP_OVERCOOL_MAX))
+			printk(KERN_WARNING "Invalid min temperature input (out of range: %d-%d)!",
+				ARMADAXP_OVERCOOL_MIN, ARMADAXP_OVERCOOL_MAX);
+		else {
+			temp_min = temp;
+			axptemp_set_thresholds(temp_max, temp_min);
+		}
+	}
+	else
+		printk(KERN_ERR "axp-temp: Invalid sensor attribute!");
+
+	/* Clear & unmask cooling/overheat interrupts */
+	writel (0, (INTER_REGS_BASE | PMU_INT_CAUSE_REG));
+	writel((PMU_INT_OVRHEAT_MASK | PMU_INT_COOLING_MASK), (INTER_REGS_BASE | PMU_INT_MASK_REG));
+
+	printk(KERN_INFO "set_temp got string: %d\n", temp);
+	return count;
+}
+
+static irqreturn_t axptemp_irq_handler(int irq, void *data)
+{
+	u32 val, mask;
+	mask = readl(INTER_REGS_BASE | PMU_INT_MASK_REG);
+	val = (readl(INTER_REGS_BASE | PMU_INT_CAUSE_REG) & mask);
+	/* Mask cooling/overheat interrupt */
+	writel((mask & ~val), (INTER_REGS_BASE | PMU_INT_MASK_REG));
+
+	printk(KERN_WARNING "WARNING: %s threshold was triggered\n",
+			((val & PMU_INT_OVRHEAT_MASK) ? "overheat" : "cooling"));
+
+	if (val & PMU_INT_OVRHEAT_MASK)
+		val &= ~PMU_INT_OVRHEAT_MASK;
+	else if (val & PMU_INT_COOLING_MASK)
+		val &= ~PMU_INT_COOLING_MASK;
+
+	/* Clear cooling/overheat interrupt */
+	writel(val, (INTER_REGS_BASE | PMU_INT_CAUSE_REG));
+
+	return IRQ_HANDLED;
+}
+
+
+
+/* TODO - Add read/write support in order to support setting max/min */
+static SENSOR_DEVICE_ATTR(temp1_type, S_IRUGO, show_info, NULL,
+			  SHOW_TYPE);
+static SENSOR_DEVICE_ATTR(temp1_label, S_IRUGO, show_info, NULL,
+			  SHOW_LABEL);
+static SENSOR_DEVICE_ATTR(temp1_input, S_IRUGO, show_temp, NULL,
+			  SHOW_TEMP);
+static SENSOR_DEVICE_ATTR(temp1_max, S_IRWXUGO, show_temp, set_temp,
+			  TEMP_MAX);
+static SENSOR_DEVICE_ATTR(temp1_min, S_IRWXUGO, show_temp, set_temp,
+			  TEMP_MIN);
+static DEVICE_ATTR(temp1_crit_alarm, S_IRUGO, show_alarm, NULL);
+static SENSOR_DEVICE_ATTR(name, S_IRUGO, show_name, NULL, SHOW_NAME);
+
+static struct attribute *axptemp_attributes[] = {
+	&sensor_dev_attr_name.dev_attr.attr,
+	&dev_attr_temp1_crit_alarm.attr,
+	&sensor_dev_attr_temp1_input.dev_attr.attr,
+	&sensor_dev_attr_temp1_max.dev_attr.attr,
+	&sensor_dev_attr_temp1_min.dev_attr.attr,
+	&sensor_dev_attr_temp1_type.dev_attr.attr,
+	&sensor_dev_attr_temp1_label.dev_attr.attr,
+	NULL
+};
+
+static const struct attribute_group axptemp_group = {
+	.attrs = axptemp_attributes,
+};
+
+static int __devinit axptemp_probe(struct platform_device *pdev)
+{
+	int err, irq;
+
+	err = axptemp_init_sensor();
+	if (err)
+		goto exit;
+
+	err = sysfs_create_group(&pdev->dev.kobj, &axptemp_group);
+	if (err)
+		goto exit;
+
+	hwmon_dev = hwmon_device_register(&pdev->dev);
+	if (IS_ERR(hwmon_dev)) {
+		dev_err(&pdev->dev, "Class registration failed (%d)\n",
+			err);
+		goto exit;
+	}
+
+	/* Register cooling/overheat interrupt */
+	irq = IRQ_AURORA_PMU;
+	err = request_irq(irq, axptemp_irq_handler, IRQF_DISABLED ,
+				"axp-temp", NULL);
+	if (err)
+		printk(KERN_INFO "unable to request IRQ%d for axp-temp\n", irq);
+	printk(KERN_INFO "Armada XP hwmon thermal sensor initialized.\n");
+
+	return 0;
+exit:
+	sysfs_remove_group(&pdev->dev.kobj, &axptemp_group);
+	return err;
+}
+
+static int __devexit axptemp_remove(struct platform_device *pdev)
+{
+	struct axptemp_data *data = platform_get_drvdata(pdev);
+
+	hwmon_device_unregister(hwmon_dev);
+	sysfs_remove_group(&pdev->dev.kobj, &axptemp_group);
+	platform_set_drvdata(pdev, NULL);
+	kfree(data);
+	return 0;
+}
+
+static int axptemp_resume(struct platform_device *dev)
+{
+	return axptemp_init_sensor();
+}
+
+static struct platform_driver axptemp_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "axp-temp",
+	},
+	.probe = axptemp_probe,
+	.remove = __devexit_p(axptemp_remove),
+	.resume = axptemp_resume,
+};
+
+static int __init axptemp_init(void)
+{
+	return platform_driver_register(&axptemp_driver);
+}
+
+static void __exit axptemp_exit(void)
+{
+	platform_driver_unregister(&axptemp_driver);
+}
+
+MODULE_AUTHOR("Marvell Semiconductors");
+MODULE_DESCRIPTION("Marvell Armada XP SoC hwmon driver");
+MODULE_LICENSE("GPL");
+
+module_init(axptemp_init)
+module_exit(axptemp_exit)
diff --git a/arch/arm/mach-avantalp/include/mach/avantalp.h b/arch/arm/mach-avantalp/include/mach/avantalp.h
new file mode 100644
index 0000000..fed55a9
--- /dev/null
+++ b/arch/arm/mach-avantalp/include/mach/avantalp.h
@@ -0,0 +1,351 @@
+/*
+ * include/asm-arm/arch-aurora/dove.h
+ *
+ * Generic definitions for Marvell Dove MV88F6781 SoC
+ *
+ * Author: Tzachi Perelstein <tzachi@marvell.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_AURORA_H
+#define __ASM_ARCH_AURORA_H
+
+#include <mach/vmalloc.h>
+
+/****************************************************************/
+/******************* System Address Mapping *********************/
+/****************************************************************/
+
+/* The base address of memory that should be reserved for IO windows.
+** The reserved end address is 0xFFFFFFFF.
+*/
+#define CONFIG_DRAM_IO_RESERVE_BASE	0xC0000000ll
+
+/*
+ * Armada-XP address maps.
+ *
+ * phys		virt		size
+ * e0000000	@runtime	128M	PCIe-0 Memory space
+ * e8000000	@runtime	128M	PCIe-1 Memory space
+ * f0000000	fab00000	16M	SPI-CS0 (Flash)
+ * f1000000	fbb00000	1M	Internal Registers
+ * f1100000	fbc00000	1M	PCIe-0 I/O space
+ * f1200000	fbd00000	1M	PCIe-1 I/O space
+ * f1300000	fbe00000	1M	PCIe-2 I/O space
+ * f1400000	fbf00000	1M	PCIe-3 I/O space
+ * f1500000	fc000000	1M	PCIe-4 I/O space
+ * f1600000	fc100000	1M	PCIe-5 I/O space
+ * f1700000	fc200000	1M	PCIe-6 I/O space
+ * f1800000	fc300000	1M	PCIe-7 I/O space
+ * f1900000	fc400000	1M	PCIe-8 I/O space
+ * f1a00000	fc500000	1M	PCIe-9 I/O space
+ * f1b00000	fc600000	1M	DMA based UART
+ * f4000000	fe700000	1M	Device-CS0
+ * f2000000	fc700000	32M	Boot-Device CS (NOR Flash)
+ * f4100000	fe800000	1M	Device-CS1 (NOR Flash)
+ * f4200000	fe900000	1M	Device-CS2 (NOR Flash)
+ * f4300000	fea00000	1M	Device-CS3 (NOR Flash)
+ * f4400000	feb00000	1M	CESA SRAM (2 units)
+ * f4500000	fec00000	1M	NETA-BM (PNC)
+ * fff00000	fed00000	1M	BootROM
+ * f4700000	fee00800	1M	PMU Scratch pad
+ * f4800000	fef00000	1M	Legacy Nand Flash
+ */
+
+/*
+ * SDRAM Address decoding
+ * These values are dummy. Uboot configures these values.
+ */
+#define SDRAM_CS0_BASE  		0x00000000
+#define SDRAM_CS0_SIZE  		_256M
+#define SDRAM_CS1_BASE  		0x10000000
+#define SDRAM_CS1_SIZE  		_256M
+#define SDRAM_CS2_BASE  		0x20000000
+#define SDRAM_CS2_SIZE  		_256M
+#define SDRAM_CS3_BASE  		0x30000000
+#define SDRAM_CS3_SIZE  		_256M
+
+/*
+ * PEX Address Decoding
+ * Virtual address not specified - remapped @runtime
+ */
+#define PEX0_MEM_PHYS_BASE		0xE0000000
+#define PEX0_MEM_SIZE			_32M
+#define PEX1_MEM_PHYS_BASE		0xE2000000
+#define PEX1_MEM_SIZE			_32M
+#define PEX2_MEM_PHYS_BASE		0xE4000000
+#define PEX2_MEM_SIZE			_32M
+#define PEX3_MEM_PHYS_BASE		0xE6000000
+#define PEX3_MEM_SIZE			_32M
+#define PEX4_MEM_PHYS_BASE		0xE8000000
+#define PEX4_MEM_SIZE			_32M
+#define PEX5_MEM_PHYS_BASE		0x0	/*TBD*/
+#define PEX5_MEM_SIZE			_32M
+#define PEX6_MEM_PHYS_BASE		0xEA000000		
+#define PEX6_MEM_SIZE			_32M
+#define PEX7_MEM_PHYS_BASE		0x0	/*TBD*/
+#define PEX7_MEM_SIZE			_32M
+#define PEX8_MEM_PHYS_BASE		0xEC000000		
+#define PEX8_MEM_SIZE			_32M
+#define PEX9_MEM_PHYS_BASE		0xEE000000
+#define PEX9_MEM_SIZE			_32M
+
+#ifdef CONFIG_ARM_LPAE
+
+
+#define SPI_CS0_PHYS_BASE		0xF0000000
+#define SPI_CS0_VIRT_BASE		0xFAA00000
+#define SPI_CS0_SIZE			_16M
+
+#ifdef CONFIG_MACH_ARMADA_XP_FPGA
+ #define INTER_REGS_PHYS_BASE		0xF1000000
+ /* Make sure that no other machines are compiled in */
+ #if defined (CONFIG_MACH_ARMADA_XP_DB) || defined (CONFIG_MACH_ARMADA_XP_RDSRV)
+ #error	"Conflicting Board Configuration!!"
+ #endif
+#else
+ #define INTER_REGS_PHYS_BASE		0xD0000000
+#endif
+
+/*
+ * Change INTER_REGS_BASE from 0xFBB00000 to 0xFBC00000 is mainly
+ * for CONFIG_DEBUG_LL. Before paging_init, the UART port is mapped
+ * by a section entry (2MB). In such case, the '1' in bit 20 is treated
+ * as 'offset' and make it fail to access the UART port.
+ */
+#define INTER_REGS_BASE			0xFBC00000
+
+#define PEX0_IO_PHYS_BASE		0xF1100000
+#define PEX0_IO_VIRT_BASE		0xFBE00000
+#define PEX0_IO_SIZE			_1M
+#define PEX1_IO_PHYS_BASE		0xF1200000
+#define PEX1_IO_VIRT_BASE		0xFBF00000
+#define PEX1_IO_SIZE			_1M
+#define PEX2_IO_PHYS_BASE		0xF1300000
+#define PEX2_IO_VIRT_BASE		0xFC000000
+#define PEX2_IO_SIZE			_1M
+#define PEX3_IO_PHYS_BASE		0xF1400000
+#define PEX3_IO_VIRT_BASE		0xFC100000
+#define PEX3_IO_SIZE			_1M
+#define PEX4_IO_PHYS_BASE		0xF1500000
+#define PEX4_IO_VIRT_BASE		0xFC200000
+#define PEX4_IO_SIZE			_1M
+#define PEX5_IO_PHYS_BASE		0xF1600000
+#define PEX5_IO_VIRT_BASE		0xFC300000
+#define PEX5_IO_SIZE			_1M
+#define PEX6_IO_PHYS_BASE		0xF1700000
+#define PEX6_IO_VIRT_BASE		0xFC400000
+#define PEX6_IO_SIZE			_1M
+#define PEX7_IO_PHYS_BASE		0xF1800000
+#define PEX7_IO_VIRT_BASE		0xFC500000
+#define PEX7_IO_SIZE			_1M
+#define PEX8_IO_PHYS_BASE		0xF1900000
+#define PEX8_IO_VIRT_BASE		0xFC600000
+#define PEX8_IO_SIZE			_1M
+#define PEX9_IO_PHYS_BASE		0xF1A00000
+#define PEX9_IO_VIRT_BASE		0xFC700000
+#define PEX9_IO_SIZE			_1M
+
+#define UART_REGS_BASE			0xF1B00000
+#define UART_VIRT_BASE			0xFC800000
+#define UART_SIZE			_1M
+
+#define DEVICE_BOOTCS_PHYS_BASE		0xF2000000
+#define DEVICE_BOOTCS_VIRT_BASE		0xFCA00000
+#define DEVICE_BOOTCS_SIZE		_32M
+#define DEVICE_CS0_PHYS_BASE		0xF4000000
+#define DEVICE_CS0_VIRT_BASE		0xFEA00000
+#define DEVICE_CS0_SIZE			_1M
+#define DEVICE_CS1_PHYS_BASE		0xF4100000
+#define DEVICE_CS1_VIRT_BASE		0xFEB00000
+#define DEVICE_CS1_SIZE			_1M
+#define DEVICE_CS2_PHYS_BASE		0xF4200000
+#define DEVICE_CS2_VIRT_BASE		0xFEC00000
+#define DEVICE_CS2_SIZE			_1M
+#define DEVICE_CS3_PHYS_BASE		0xF4300000
+#define DEVICE_CS3_VIRT_BASE		0xFED00000
+#define DEVICE_CS3_SIZE			_1M
+
+#define CRYPT_ENG_PHYS_BASE(chan)	((chan == 0) ? 0xC8010000 : 0xF4480000)
+#define CRYPT_ENG_VIRT_BASE(chan)	((chan == 0) ? 0xFEE00000 : 0xFEE10000)
+#define CRYPT_ENG_SIZE			_64K
+
+
+#ifdef CONFIG_ARMADA_XP_REV_Z1
+#define XOR0_PHYS_BASE                 (INTER_REGS_PHYS_BASE | 0x60800)
+#define XOR1_PHYS_BASE                 (INTER_REGS_PHYS_BASE | 0x60900)
+#else
+#define XOR0_PHYS_BASE			(INTER_REGS_PHYS_BASE | 0x60900)
+#define XOR1_PHYS_BASE			(INTER_REGS_PHYS_BASE | 0xF0900)
+#endif
+#define XOR0_HIGH_PHYS_BASE		(INTER_REGS_PHYS_BASE | 0x60B00)
+#define XOR1_HIGH_PHYS_BASE		(INTER_REGS_PHYS_BASE | 0xF0B00)
+
+#define PNC_BM_PHYS_BASE		0xF4500000
+#define PNC_BM_VIRT_BASE		0xFEF00000
+#define PNC_BM_SIZE			_1M
+
+#define BOOTROM_PHYS_BASE		0xFFF00000
+#define BOOTROM_VIRT_BASE		0xFF000000
+#define BOOTROM_SIZE			_1M
+
+#define PMU_SCRATCH_PHYS_BASE		0xF4700000
+#define PMU_SCRATCH_VIRT_BASE		0xFF100000
+#define PMU_SCRATCH_SIZE		_1M
+
+#define LEGACY_NAND_PHYS_BASE		0xF4800000
+#define LEGACY_NAND_VIRT_BASE		0xFF200000
+#define LEGACY_NAND_SIZE		_1M
+
+#define	LCD_PHYS_BASE			(INTER_REGS_PHYS_BASE | 0xE0000)
+
+#define AXP_NFC_PHYS_BASE	(INTER_REGS_PHYS_BASE | 0xD0000)
+
+#else /* !CONFIG_ARM_LPAE */
+
+#define SPI_CS0_PHYS_BASE		0xF0000000
+#define SPI_CS0_VIRT_BASE		0xFAB00000
+#define SPI_CS0_SIZE			_16M
+
+#ifdef CONFIG_MACH_ARMADA_XP_FPGA
+ #define INTER_REGS_PHYS_BASE		0xF1000000
+ /* Make sure that no other machines are compiled in */
+ #if defined (CONFIG_MACH_ARMADA_XP_DB) || defined (CONFIG_MACH_ARMADA_XP_RDSRV)
+ #error	"Conflicting Board Configuration!!"
+ #endif
+#else
+ #define INTER_REGS_PHYS_BASE		0xD0000000
+#endif
+#define INTER_REGS_BASE			0xFBB00000
+
+#define PEX0_IO_PHYS_BASE		0xF1100000
+#define PEX0_IO_VIRT_BASE		0xFBC00000
+#define PEX0_IO_SIZE			_1M
+#define PEX1_IO_PHYS_BASE		0xF1200000
+#define PEX1_IO_VIRT_BASE		0xFBD00000
+#define PEX1_IO_SIZE			_1M
+#define PEX2_IO_PHYS_BASE		0xF1300000
+#define PEX2_IO_VIRT_BASE		0xFBE00000
+#define PEX2_IO_SIZE			_1M
+#define PEX3_IO_PHYS_BASE		0xF1400000
+#define PEX3_IO_VIRT_BASE		0xFBF00000
+#define PEX3_IO_SIZE			_1M
+#define PEX4_IO_PHYS_BASE		0xF1500000
+#define PEX4_IO_VIRT_BASE		0xFC000000
+#define PEX4_IO_SIZE			_1M
+#define PEX5_IO_PHYS_BASE		0xF1600000
+#define PEX5_IO_VIRT_BASE		0xFC100000
+#define PEX5_IO_SIZE			_1M
+#define PEX6_IO_PHYS_BASE		0xF1700000
+#define PEX6_IO_VIRT_BASE		0xFC200000
+#define PEX6_IO_SIZE			_1M
+#define PEX7_IO_PHYS_BASE		0xF1800000
+#define PEX7_IO_VIRT_BASE		0xFC300000
+#define PEX7_IO_SIZE			_1M
+#define PEX8_IO_PHYS_BASE		0xF1900000
+#define PEX8_IO_VIRT_BASE		0xFC400000
+#define PEX8_IO_SIZE			_1M
+#define PEX9_IO_PHYS_BASE		0xF1A00000
+#define PEX9_IO_VIRT_BASE		0xFC500000
+#define PEX9_IO_SIZE			_1M
+
+#define UART_REGS_BASE			0xF1B00000
+#define UART_VIRT_BASE			0xFC600000
+#define UART_SIZE			_1M
+
+#define DEVICE_BOOTCS_PHYS_BASE		0xF2000000
+#define DEVICE_BOOTCS_VIRT_BASE		0xFC700000
+#define DEVICE_BOOTCS_SIZE		_32M
+#define DEVICE_CS0_PHYS_BASE		0xF4000000
+#define DEVICE_CS0_VIRT_BASE		0xFE700000
+#define DEVICE_CS0_SIZE			_1M
+#define DEVICE_CS1_PHYS_BASE		0xF4100000
+#define DEVICE_CS1_VIRT_BASE		0xFE800000
+#define DEVICE_CS1_SIZE			_1M
+#define DEVICE_CS2_PHYS_BASE		0xF4200000
+#define DEVICE_CS2_VIRT_BASE		0xFE900000
+#define DEVICE_CS2_SIZE			_1M
+#define DEVICE_CS3_PHYS_BASE		0xF4300000
+#define DEVICE_CS3_VIRT_BASE		0xFEA00000
+#define DEVICE_CS3_SIZE			_1M
+
+#define CRYPT_ENG_PHYS_BASE(chan)	((chan == 0) ? 0xC8010000 : 0xF4480000)
+#define CRYPT_ENG_VIRT_BASE(chan)	((chan == 0) ? 0xFEB00000 : 0xFEB10000)
+#define CRYPT_ENG_SIZE			_64K
+
+
+#ifdef CONFIG_ARMADA_XP_REV_Z1
+#define XOR0_PHYS_BASE                 (INTER_REGS_PHYS_BASE | 0x60800)
+#define XOR1_PHYS_BASE                 (INTER_REGS_PHYS_BASE | 0x60900)
+#else
+#define XOR0_PHYS_BASE			(INTER_REGS_PHYS_BASE | 0x60900)
+#define XOR1_PHYS_BASE			(INTER_REGS_PHYS_BASE | 0xF0900)
+#endif
+#define XOR0_HIGH_PHYS_BASE		(INTER_REGS_PHYS_BASE | 0x60B00)
+#define XOR1_HIGH_PHYS_BASE		(INTER_REGS_PHYS_BASE | 0xF0B00)
+
+#define PNC_BM_PHYS_BASE		0xF4500000
+#define PNC_BM_VIRT_BASE		0xFEC00000
+#define PNC_BM_SIZE			_1M
+
+#define BOOTROM_PHYS_BASE		0xFFF00000
+#define BOOTROM_VIRT_BASE		0xFED00000
+#define BOOTROM_SIZE			_1M
+
+
+#define PMU_SCRATCH_PHYS_BASE		0xF4700000
+#define PMU_SCRATCH_VIRT_BASE		0xFEE00000
+#define PMU_SCRATCH_SIZE		_1M
+
+#define LEGACY_NAND_PHYS_BASE		0xF4800000
+#define LEGACY_NAND_VIRT_BASE		0xFEF00000
+#define LEGACY_NAND_SIZE		_1M
+
+#define	LCD_PHYS_BASE			(INTER_REGS_PHYS_BASE | 0xE0000)
+
+#define AXP_NFC_PHYS_BASE	(INTER_REGS_PHYS_BASE | 0xD0000)
+
+#endif /* CONFIG_ARM_LPAE */
+
+/*
+ * Linux native definitiotns
+ */
+#define SDRAM_OPERATION_REG		(INTER_REGS_BASE | 0x1418)
+#define SDRAM_CONFIG_REG		(INTER_REGS_BASE | 0x1400)
+#define SDRAM_DLB_EVICT_REG		(INTER_REGS_BASE | 0x170C)
+
+#define AXP_UART_PHYS_BASE(port)	(INTER_REGS_PHYS_BASE | 0x12000 + (port * 0x100))
+#define DDR_VIRT_BASE			(INTER_REGS_BASE | 0x00000)
+#define AXP_BRIDGE_VIRT_BASE		(INTER_REGS_BASE | 0x20000)
+#define AXP_BRIDGE_PHYS_BASE		(INTER_REGS_PHYS_BASE | 0x20000)
+#define DDR_WINDOW_CPU_BASE		(DDR_VIRT_BASE | 0x1500)
+#define AXP_SW_TRIG_IRQ			(AXP_BRIDGE_VIRT_BASE | 0x0A04)
+#define AXP_SW_TRIG_IRQ_PHYS		(AXP_BRIDGE_PHYS_BASE | 0x0A04)
+#define AXP_SW_TRIG_IRQ_CPU_TARGET_OFFS	8
+#define AXP_SW_TRIG_IRQ_INITID_MASK	0x1F
+#define AXP_PER_CPU_BASE		(AXP_BRIDGE_VIRT_BASE | 0x1000)
+#define AXP_IRQ_VIRT_BASE		(AXP_PER_CPU_BASE)
+#define AXP_CPU_INTACK			0xB4
+#define AXP_IRQ_SEL_CAUSE_OFF		0xA0
+#define AXP_IN_DOORBELL_CAUSE		0x78
+#define AXP_IN_DRBEL_CAUSE			(AXP_PER_CPU_BASE | 0x78)
+#define AXP_IN_DRBEL_MSK			(AXP_PER_CPU_BASE | 0x7c)
+
+#ifdef CONFIG_MACH_ARMADA_XP_FPGA
+#define AXP_CPU_RESUME_ADDR_REG(cpu)	(AXP_BRIDGE_VIRT_BASE | 0x984)
+#else
+#define AXP_CPU_RESUME_ADDR_REG(cpu)	(AXP_BRIDGE_VIRT_BASE | (0x2124+(cpu)*0x100))
+#endif
+#define AXP_CPU_RESUME_CTRL_REG		(AXP_BRIDGE_VIRT_BASE | 0x988)
+#define AXP_CPU_RESET_REG(cpu)		(AXP_BRIDGE_VIRT_BASE | (0x800+(cpu)*8))
+#define AXP_CPU_RESET_OFFS		0
+
+#define AXP_L2_CLEAN_WAY_REG		(INTER_REGS_BASE | 0x87BC) 
+#define AXP_L2_MNTNC_STAT_REG		(INTER_REGS_BASE | 0x8704)
+#define AXP_SNOOP_FILTER_PHYS_REG	(INTER_REGS_PHYS_BASE | 0x21020)
+#define AXP_REVISION_ID_PHYS_REG	(INTER_REGS_PHYS_BASE | 0x40008)
+#define AXP_REVISION_ID_VIRT_REG	(INTER_REGS_BASE | 0x40008)
+#endif
diff --git a/arch/arm/mach-avantalp/include/mach/clkdev.h b/arch/arm/mach-avantalp/include/mach/clkdev.h
new file mode 100644
index 0000000..04b37a8
--- /dev/null
+++ b/arch/arm/mach-avantalp/include/mach/clkdev.h
@@ -0,0 +1,7 @@
+#ifndef __ASM_MACH_CLKDEV_H
+#define __ASM_MACH_CLKDEV_H
+
+#define __clk_get(clk) ({ 1; })
+#define __clk_put(clk) do { } while (0)
+
+#endif
diff --git a/arch/arm/mach-avantalp/include/mach/debug-macro.S b/arch/arm/mach-avantalp/include/mach/debug-macro.S
new file mode 100644
index 0000000..579133c
--- /dev/null
+++ b/arch/arm/mach-avantalp/include/mach/debug-macro.S
@@ -0,0 +1,24 @@
+/*
+ * debug-macro.S
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+#include <mach/avantalp.h>
+
+	
+	.macro  addruart, rp, rv, tmp
+	ldr     \rp, =INTER_REGS_PHYS_BASE
+	ldr	\rv, =INTER_REGS_BASE
+	orr     \rp, \rp, #0x00012000
+        orr     \rv, \rv, #0x00012000
+#ifdef CONFIG_MV_UART_PORT
+	orr     \rp, \rp, #0x100 * CONFIG_MV_UART_PORT
+        orr     \rv, \rv, #0x100 * CONFIG_MV_UART_PORT
+#endif
+	.endm
+
+#define UART_SHIFT	2
+#include <asm/hardware/debug-8250.S>
diff --git a/arch/arm/mach-avantalp/include/mach/dma.h b/arch/arm/mach-avantalp/include/mach/dma.h
new file mode 100644
index 0000000..8e2f2d0
--- /dev/null
+++ b/arch/arm/mach-avantalp/include/mach/dma.h
@@ -0,0 +1,16 @@
+/*
+ * DaVinci DMA definitions
+ *
+ * Author: Kevin Hilman, MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H
+
+#define MAX_DMA_ADDRESS			0xffffffff
+
+#endif /* __ASM_ARCH_DMA_H */
diff --git a/arch/arm/mach-avantalp/include/mach/dove_bl.h b/arch/arm/mach-avantalp/include/mach/dove_bl.h
new file mode 100644
index 0000000..8a447f2
--- /dev/null
+++ b/arch/arm/mach-avantalp/include/mach/dove_bl.h
@@ -0,0 +1,35 @@
+#ifndef __ASM_ARCH_DOVE_BL_H
+#define __ASM_ARCH_DOVE_BL_H
+#include <linux/ioport.h>
+
+struct dovebl_platform_data {
+	int	default_intensity;
+	int	gpio_pm_control; /* enable LCD/panel power management via gpio*/
+
+	resource_size_t lcd_start;	/* lcd power control reg base. */
+	resource_size_t lcd_end;	/* end of reg map. */
+	unsigned long lcd_offset;	/* register offset */
+	unsigned long lcd_mapped;	/* pa = 0, va = 1 */
+	unsigned long lcd_mask;		/* mask */
+	unsigned long lcd_on;		/* value to enable lcd power */
+	unsigned long lcd_off;		/* value to disable lcd power */
+
+	resource_size_t blpwr_start;	/* backlight pwr ctrl reg base. */
+	resource_size_t blpwr_end;	/* end of reg map. */
+	unsigned long blpwr_offset;	/* register offset */
+	unsigned long blpwr_mapped;	/* pa = 0, va = 1 */
+	unsigned long blpwr_mask;	/* mask */
+	unsigned long blpwr_on;		/* value to enable bl power */
+	unsigned long blpwr_off;	/* value to disable bl power */
+
+	resource_size_t btn_start;	/* brightness control reg base. */
+	resource_size_t btn_end;	/* end of reg map. */
+	unsigned long btn_offset;	/* register offset */
+	unsigned long btn_mapped;	/* pa = 0, va = 1 */
+	unsigned long btn_mask;	/* mask */
+	unsigned long btn_level;	/* how many level can be configured. */
+	unsigned long btn_min;	/* min value */
+	unsigned long btn_max;	/* max value */
+	unsigned long btn_inc;	/* increment */
+};
+#endif /* __ASM_ARCH_DOVE_BL_H */
diff --git a/arch/arm/mach-avantalp/include/mach/entry-macro.S b/arch/arm/mach-avantalp/include/mach/entry-macro.S
new file mode 100755
index 0000000..ecd3952
--- /dev/null
+++ b/arch/arm/mach-avantalp/include/mach/entry-macro.S
@@ -0,0 +1,17 @@
+/*
+ * include/asm-arm/arch-mv78xx0/entry-macro.S
+ *
+ * Low-level IRQ helper macros for Marvell MV78xx0 platforms
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <asm/hardware/entry-macro-gic.S>
+
+	.macro	disable_fiq
+	.endm
+
+	.macro	arch_ret_to_user, tmp1, tmp2
+	.endm
diff --git a/arch/arm/mach-avantalp/include/mach/gpio.h b/arch/arm/mach-avantalp/include/mach/gpio.h
new file mode 100644
index 0000000..7ca789d
--- /dev/null
+++ b/arch/arm/mach-avantalp/include/mach/gpio.h
@@ -0,0 +1,55 @@
+/*
+ * include/asm-arm/arch-dove/gpio.h
+ *
+ * Author: Tzachi Perelstein <tzachi@marvell.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_GPIO_H
+#define __ASM_ARCH_GPIO_H
+
+#include <asm/errno.h>
+#include <mach/irqs.h>
+#include <plat/gpio.h>
+#include <asm-generic/gpio.h>		/* cansleep wrappers */
+
+#define gpio_get_value	__gpio_get_value
+#define gpio_set_value	__gpio_set_value
+#define gpio_cansleep	__gpio_cansleep
+
+#define GPIO_MAX	64
+
+#define GPIO_BASE_LO		(AURORA_GPIO_VIRT_BASE + 0x00)
+#define GPIO_BASE_HI		(AURORA_GPIO_VIRT_BASE + 0x20)
+
+#define GPIO_BASE(pin)		((pin < 32) ? GPIO_BASE_LO : GPIO_BASE_HI)
+
+#define GPIO_OUT(pin)		(GPIO_BASE(pin) + 0x00)
+#define GPIO_IO_CONF(pin)	(GPIO_BASE(pin) + 0x04)
+#define GPIO_BLINK_EN(pin)	(GPIO_BASE(pin) + 0x08)
+#define GPIO_IN_POL(pin)	(GPIO_BASE(pin) + 0x0c)
+#define GPIO_DATA_IN(pin)	(GPIO_BASE(pin) + 0x10)
+#define GPIO_EDGE_CAUSE(pin)	(GPIO_BASE(pin) + 0x14)
+#define GPIO_EDGE_MASK(pin)	(GPIO_BASE(pin) + 0x18)
+#define GPIO_LEVEL_MASK(pin)	(GPIO_BASE(pin) + 0x1c)
+
+static inline int gpio_to_irq(int pin)
+{
+	if (pin < NR_GPIO_IRQS)
+		return pin + IRQ_AURORA_GPIO_START;
+
+	return -EINVAL;
+}
+
+static inline int irq_to_gpio(int irq)
+{
+	if (IRQ_AURORA_GPIO_START < irq && irq < NR_IRQS)
+		return irq - IRQ_AURORA_GPIO_START;
+
+	return -EINVAL;
+}
+
+#endif
diff --git a/arch/arm/mach-avantalp/include/mach/hardware.h b/arch/arm/mach-avantalp/include/mach/hardware.h
new file mode 100644
index 0000000..cf20a97
--- /dev/null
+++ b/arch/arm/mach-avantalp/include/mach/hardware.h
@@ -0,0 +1,14 @@
+/*
+ * include/mach/hardware.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#include "avantalp.h"
+
+#endif
diff --git a/arch/arm/mach-avantalp/include/mach/ide.h b/arch/arm/mach-avantalp/include/mach/ide.h
new file mode 100644
index 0000000..04e0bca
--- /dev/null
+++ b/arch/arm/mach-avantalp/include/mach/ide.h
@@ -0,0 +1,15 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
diff --git a/arch/arm/mach-avantalp/include/mach/io.h b/arch/arm/mach-avantalp/include/mach/io.h
new file mode 100644
index 0000000..64bf574
--- /dev/null
+++ b/arch/arm/mach-avantalp/include/mach/io.h
@@ -0,0 +1,32 @@
+/*
+ * include/asm-arm/arch-dove/io.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_IO_H
+#define __ASM_ARCH_IO_H
+
+#include "avantalp.h"
+
+#define IO_SPACE_LIMIT		0xffffffff
+#define IO_SPACE_REMAP 		PEX0_IO_PHYS_BASE
+
+#define __io(a)			((a) + PEX0_IO_VIRT_BASE)
+#define __mem_pci(a)		((unsigned long)(a))
+#define __mem_isa(a)		(a)
+
+/*#define aurora_setbits(r, mask)	writel(readl(r) | (mask), (r))
+#define aurora_clrbits(r, mask)	writel(readl(r) & ~(mask), (r))*/
+
+#ifdef CONFIG_AURORA_IO_CACHE_COHERENCY
+#define dma_io_sync()	do {				\
+	writel(0x1, INTER_REGS_BASE + 0x21810);		\
+	while (readl(INTER_REGS_BASE + 0x21810) & 0x1);	\
+} while (0)
+#else
+#define dma_io_sync()	do { } while (0)
+#endif
+#endif
diff --git a/arch/arm/mach-avantalp/include/mach/irqs.h b/arch/arm/mach-avantalp/include/mach/irqs.h
new file mode 100644
index 0000000..d8f0cb9
--- /dev/null
+++ b/arch/arm/mach-avantalp/include/mach/irqs.h
@@ -0,0 +1,159 @@
+/*
+ * include/asm-arm/arch-aurora/irqs.h
+ *
+ * IRQ definitions for Marvell Dove MV88F6781 SoC
+ *
+ * Author: Tzachi Perelstein <tzachi@marvell.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_IRQS_H
+#define __ASM_ARCH_IRQS_H
+
+/*
+ * Aurora Low Interrupt Controller
+ */
+
+
+#define IRQ_LOCALTIMER		29
+#define IRQ_LOCALWDOG		30
+#define NR_IRQS	191
+
+#if 0
+#define IRQ_AURORA_IN_DRBL_LOW	0
+#define IRQ_AURORA_IN_DRBL_HIGH	1
+#define IRQ_AURORA_OUT_DRBL 	2
+#define IRQ_AURORA_MP		3
+#define IRQ_AURORA_SOC_ERROR	4
+#define IRQ_AURORA_TIMER0	5
+#define IRQ_LOCALTIMER 		IRQ_AURORA_TIMER0
+#define IRQ_AURORA_TIMER1	6
+#define IRQ_AURORA_WD		7
+#define IRQ_AURORA_GBE0_FIC	8
+#define IRQ_AURORA_GBE0_SIC	9
+#define IRQ_AURORA_GBE1_FIC	10
+#define IRQ_AURORA_GBE1_SIC	11
+#define IRQ_AURORA_GBE2_FIC     12
+#define IRQ_AURORA_GBE2_SIC	13
+#define IRQ_AURORA_GBE3_FIC	14
+#define IRQ_AURORA_GBE3_SIC	15
+
+#define IRQ_AURORA_LCD		29
+#endif
+#define IRQ_AURORA_SPI		33
+#define IRQ_AURORA_I2C0		34
+#define IRQ_AURORA_I2C1		35
+#if 0
+#define IRQ_AURORA_DMA0		33
+#define IRQ_AURORA_DMA1		34
+#define IRQ_AURORA_DMA2		35
+#define IRQ_AURORA_DMA3		36
+#endif
+#define IRQ_AURORA_GLOB_TIMER0	40
+#define IRQ_AURORA_GLOB_TIMER1	41
+#define IRQ_AURORA_GLOB_TIMER2	42
+#define IRQ_AURORA_GLOB_TIMER3	43
+
+#define IRQ_AURORA_UART0	44
+#define IRQ_AURORA_UART1	45
+
+#define IRQ_AURORA_USB0		48
+#define IRQ_AURORA_USB1		49
+
+#define IRQ_AURORA_RTC		53
+
+#define IRQ_AURORA_XOR00	54
+#define IRQ_AURORA_XOR01	55
+
+#define IRQ_AURORA_BM		56
+#define IRQ_AURORA_SDIO		57
+#define IRQ_AURORA_SATA0	58
+#define IRQ_AURORA_TDM		59
+#define IRQ_AURORA_SATA1	60
+	
+#define IRQ_AURORA_PCIE0	61
+#define IRQ_AURORA_PCIE1	65	
+#define IRQ_AURORA_PCI0		61	/* FPGA only */
+
+#define IRQ_AURORA_GBE0		69
+#define IRQ_AURORA_GBE0_RX	70
+#define IRQ_AURORA_GBE0_TX	71
+#define IRQ_AURORA_GBE0_MISC	72
+#define IRQ_AURORA_GBE1		73
+#define IRQ_AURORA_GBE1_RX	74
+#define IRQ_AURORA_GBE1_TX	75
+#define IRQ_AURORA_GBE1_MISC	76
+#define IRQ_AURORA_GBE2		77
+#define IRQ_AURORA_GBE2_RX	78
+#define IRQ_AURORA_GBE2_TX	79
+#define IRQ_AURORA_GBE2_MISC	80
+
+#define IRQ_AURORA_GPIO_0_7		85
+#define IRQ_AURORA_GPIO_8_15	86
+#define IRQ_AURORA_GPIO_16_23	87
+#define IRQ_AURORA_GPIO_24_31	88
+#define IRQ_AURORA_GPIO_32_39	90
+#define IRQ_AURORA_GPIO_40_47	91
+#define IRQ_AURORA_GPIO_48_55	92
+#define IRQ_AURORA_GPIO_56_63	93
+#define IRQ_AURORA_GPIO_64_66	94
+
+#define IRQ_AURORA_XOR10	97
+#define IRQ_AURORA_XOR11	98
+
+#define IRQ_AURORA_SHARE_INB_DB0	99
+#define IRQ_AURORA_SHARE_INB_DB1	100
+#define IRQ_AURORA_SHARE_INB_DB2	101
+
+#define IRQ_AURORA_PCIE2	102
+#define IRQ_AURORA_PCIE3	103
+
+#define IRQ_AURORA_PMU		110
+
+#define IRQ_AURORA_DRAM		111
+
+#define IRQ_AURORA_NET_WKUP0	112
+
+#define IRQ_AURORA_NFC		116
+
+#define IRQ_AURORA_OVRCL	115
+
+#define IRQ_MAIN_INTS_NUM	116
+
+#define MAX_PER_CPU_IRQ_NUMBER 	15
+/*
+ * AURORA General Purpose Pins
+ */
+#define IRQ_AURORA_GPIO_START		128
+#define NR_GPIO_IRQS			67
+#define IRQ_AURORA_SHARED_START 32
+
+/*
+ * AURORA MSI interrupts
+ */
+#define NR_PRIVATE_MSI_GROUP		16
+#define NR_PRIVATE_MSI_IRQS		NR_PRIVATE_MSI_GROUP
+#define NR_MSI_IRQS			NR_PRIVATE_MSI_IRQS
+#define IRQ_AURORA_MSI_START		(IRQ_AURORA_GPIO_START + NR_GPIO_IRQS)
+//#define NR_IRQS				(IRQ_AURORA_GPIO_START + NR_GPIO_IRQS + NR_MSI_IRQS)
+#define GPP_IRQ_TYPE_LEVEL		0
+#define GPP_IRQ_TYPE_CHANGE_LEVEL	1
+
+/*
+ * Aurora Error interrupts
+ */
+
+#define INT_ERR_CESA0         		0
+#define INT_ERR_DEVBUS         		1
+
+/*
+ * IRQ HAL remapping
+ */
+#define NET_TH_RXTX_IRQ_NUM(x)		(IRQ_AURORA_GBE0_FIC + ((x) * 2))
+#define SATA_IRQ_NUM			(IRQ_AURORA_SATA0)
+#define CESA_IRQ(chan)			IRQ_AURORA_CRYPTO(chan)
+#endif
+
diff --git a/arch/arm/mach-avantalp/include/mach/kw_macro.h b/arch/arm/mach-avantalp/include/mach/kw_macro.h
new file mode 100644
index 0000000..9e0525a
--- /dev/null
+++ b/arch/arm/mach-avantalp/include/mach/kw_macro.h
@@ -0,0 +1,39 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Assembler-only file 
+ */
+
+
+support_wait_for_interrupt_address:
+        .word   support_wait_for_interrupt
+
+/* rd, rs, rt, re - are temp registers that will b used (non are input/output) */
+.macro mv_flush_all, rd, rs, rt, re
+	mov     \re, #0
+
+        mov     \rd, #(4 - 1) << 30      @ 4 way cache
+        mov     \rs, #(256 * CACHE_DLINESIZE)
+
+1:      orr     \rt, \re, \rd
+2:      mcr     p15, 0, \rt, c7, c14, 2          @ clean & invalidate D index
+        subs    \rt, \rt, #1 << 30
+        bcs     2b                              @ entries 3 to 0
+        add     \re, \re, #32
+        cmp     \re, \rs
+        bne     1b
+
+/* exit */	
+	.endm
diff --git a/arch/arm/mach-avantalp/include/mach/memory.h b/arch/arm/mach-avantalp/include/mach/memory.h
new file mode 100644
index 0000000..6740ff2
--- /dev/null
+++ b/arch/arm/mach-avantalp/include/mach/memory.h
@@ -0,0 +1,44 @@
+/*
+ * include/asm-arm/arch-mv78xx0/memory.h
+ */
+
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+#ifdef CONFIG_MV_DRAM_BASE
+#define PLAT_PHYS_OFFSET		UL(CONFIG_MV_DRAM_BASE)
+#else
+#define PLAT_PHYS_OFFSET		UL(0x00000000)
+#endif
+
+#define BOOT_PARAMS_OFFSET      PLAT_PHYS_OFFSET + 0x100
+/* #define __virt_to_bus(x)	__virt_to_phys(x) */
+/* #define __bus_to_virt(x)	__phys_to_virt(x) */
+
+
+/* Override the ARM default */
+#ifdef CONFIG_SPARSEMEM
+#define MAX_PHYSMEM_BITS       35
+#define SECTION_SIZE_BITS      29
+#endif
+
+#if 0
+#ifdef CONFIG_FB_DOVE_CONSISTENT_DMA_SIZE
+
+#if (CONFIG_FB_DOVE_CONSISTENT_DMA_SIZE == 0)
+#undef CONFIG_FB_DOVE_CONSISTENT_DMA_SIZE
+#define CONFIG_FB_DOVE_CONSISTENT_DMA_SIZE 2
+#endif
+
+#define CONSISTENT_DMA_SIZE \
+	(((CONFIG_FB_DOVE_CONSISTENT_DMA_SIZE + 1) & ~1) * 1024 * 1024)
+
+#endif
+#endif
+
+#ifdef CONFIG_AURORA_IO_CACHE_COHERENCY
+#define arch_is_coherent()  1  
+#endif
+
+
+#endif
diff --git a/arch/arm/mach-avantalp/include/mach/param.h b/arch/arm/mach-avantalp/include/mach/param.h
new file mode 100644
index 0000000..04e0bca
--- /dev/null
+++ b/arch/arm/mach-avantalp/include/mach/param.h
@@ -0,0 +1,15 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
diff --git a/arch/arm/mach-avantalp/include/mach/serial.h b/arch/arm/mach-avantalp/include/mach/serial.h
new file mode 100644
index 0000000..6960e91
--- /dev/null
+++ b/arch/arm/mach-avantalp/include/mach/serial.h
@@ -0,0 +1,41 @@
+/*
+ *  linux/include/asm-arm/arch-integrator/serial.h
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_SERIAL_H
+#define __ASM_ARCH_SERIAL_H
+
+#include <asm/irq.h>
+//#include <linux/autoconf.h>
+
+#include "../arch/arm/mach-avantalp/config/mvSysHwConfig.h"
+
+extern unsigned int mvTclk;
+
+#undef  BASE_BAUD
+#define BASE_BAUD (mvTclk / 16)
+
+#define PORT0_BASE	(INTER_REGS_BASE + 0x12000) /* port 0 base */
+#define PORT1_BASE 	(INTER_REGS_BASE + 0x12100) /* port 1 base */
+
+#define STD_COM_FLAGS (ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST /* | ASYNC_SPD_VHI  115200 */ )
+
+#define STD_SERIAL_PORT_DEFNS
+#define EXTRA_SERIAL_PORT_DEFNS
+
+#endif
diff --git a/arch/arm/mach-avantalp/include/mach/smp.h b/arch/arm/mach-avantalp/include/mach/smp.h
new file mode 100644
index 0000000..f12d59e
--- /dev/null
+++ b/arch/arm/mach-avantalp/include/mach/smp.h
@@ -0,0 +1,23 @@
+#ifndef ASMARM_ARCH_SMP_H
+#define ASMARM_ARCH_SMP_H
+
+#include <asm/io.h>
+#include <mach/armadaxp.h>
+
+extern unsigned int master_cpu_id;
+extern unsigned int group_cpu_mask;
+extern unsigned long mv_cpu_count;
+
+#define hard_smp_processor_id()			\
+	({						\
+		unsigned int cpunum;			\
+		__asm__("mrc p15, 0, %0, c0, c0, 5"	\
+			: "=r" (cpunum));		\
+		cpunum &= 0x0F;				\
+	})
+
+#define get_hw_cpu_mask(cpu_mask)	((cpu_mask << master_cpu_id) & group_cpu_mask)
+#define get_hw_cpu_id(cpu)		(cpu + master_cpu_id)
+#define is_primary_amp()		(master_cpu_id == 0 ? 1 : 0)
+
+#endif //ASMARM_ARCH_SMP_H
diff --git a/arch/arm/mach-avantalp/include/mach/system.h b/arch/arm/mach-avantalp/include/mach/system.h
new file mode 100644
index 0000000..28bae52
--- /dev/null
+++ b/arch/arm/mach-avantalp/include/mach/system.h
@@ -0,0 +1,37 @@
+/*
+ * include/mach/system.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __MACH_SYSTEM_H
+#define __MACH_SYSTEM_H
+
+#include <asm/proc-fns.h>
+#include <mach/hardware.h>
+
+#include "boardEnv/mvBoardEnvLib.h"
+
+#ifdef CONFIG_MV_SUPPORT_64KB_PAGE_SIZE
+#define LSP_PG_SZ_VER  " (Large Page)"
+#else
+#define LSP_PG_SZ_VER  ""
+#endif
+
+#define LSP_VERSION    "linux-3.2.27-axp_a370-2012_Q4.3" LSP_PG_SZ_VER
+
+static inline void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+static inline void arch_reset(char mode, const char *cmd)
+{
+	printk("Reseting...\n");
+	mvBoardReset();
+	while (1);/* This should never be reached */
+}
+
+#endif
diff --git a/arch/arm/mach-avantalp/include/mach/timex.h b/arch/arm/mach-avantalp/include/mach/timex.h
new file mode 100644
index 0000000..c8cf294
--- /dev/null
+++ b/arch/arm/mach-avantalp/include/mach/timex.h
@@ -0,0 +1,9 @@
+/*
+ * include/asm-arm/arch-dove/timex.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#define CLOCK_TICK_RATE		(100 * HZ)
diff --git a/arch/arm/mach-avantalp/include/mach/uncompress.h b/arch/arm/mach-avantalp/include/mach/uncompress.h
new file mode 100644
index 0000000..8dea42f
--- /dev/null
+++ b/arch/arm/mach-avantalp/include/mach/uncompress.h
@@ -0,0 +1,138 @@
+/*
+ * include/asm-arm/arch-aurora/uncompress.h
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <mach/avantalp.h>
+
+#ifndef CONFIG_MV_UART_PORT
+#define UART_THR ((volatile unsigned char *)(AXP_UART_PHYS_BASE(0) + 0x0))
+#define UART_LSR ((volatile unsigned char *)(AXP_UART_PHYS_BASE(0) + 0x14))
+#else
+#define UART_THR ((volatile unsigned char *)(AXP_UART_PHYS_BASE(CONFIG_MV_UART_PORT) + 0x0))
+#define UART_LSR ((volatile unsigned char *)(AXP_UART_PHYS_BASE(CONFIG_MV_UART_PORT) + 0x14))
+#endif
+
+#define LSR_THRE	0x20
+
+static void putc(const char c)
+{
+	int i;
+
+	for (i = 0; i < 0x1000; i++) {
+		/* Transmit fifo not full? */
+		if (*UART_LSR & LSR_THRE)
+			break;
+	}
+
+	*UART_THR = c;
+}
+
+static void flush(void)
+{
+}
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
+
+#if 0
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+//#include <linux/autoconf.h>
+#include "../arch/arm/mach-armadaxp/config/mvSysHwConfig.h"
+#include <linux/serial_reg.h>
+#define MV_UART0_LSR 	(*(volatile unsigned char *)(INTER_REGS_BASE + 0x12000 + 0x14))
+#define MV_UART0_THR	(*(volatile unsigned char *)(INTER_REGS_BASE + 0x12000 + 0x0 ))	 
+
+#define MV_UART1_LSR    (*(volatile unsigned char *)(INTER_REGS_BASE + 0x12100 + 0x14))
+#define MV_UART1_THR    (*(volatile unsigned char *)(INTER_REGS_BASE + 0x12100 + 0x0 ))
+#define MV_SERIAL_BASE ((unsigned char *)(INTER_REGS_BASE + 0x12000 + 0x0 ))
+
+#define DEV_REG		(*(volatile unsigned int *)(INTER_REGS_BASE + 0x40000))
+#define CLK_REG         (*(volatile unsigned int *)(INTER_REGS_BASE + 0x2011c))
+/*
+ * This does not append a newline
+ */
+static void putstr(const char *s)
+{
+	unsigned int model;
+	
+	/* Get dev ID, make sure pex clk is on */
+	if((CLK_REG & 0x4) == 0)
+	{
+		CLK_REG = CLK_REG | 0x4;
+		model = (DEV_REG >> 16) & 0xffff;
+		CLK_REG = CLK_REG & ~0x4;
+	}
+	else
+		model = (DEV_REG >> 16) & 0xffff;
+
+        while (*s) {
+		while ((MV_UART0_LSR & UART_LSR_THRE) == 0);
+		MV_UART0_THR = *s;
+		
+                if (*s == '\n') {
+                        while ((MV_UART0_LSR & UART_LSR_THRE) == 0); 
+                        MV_UART0_THR = '\r';
+                }
+                s++;
+        }
+}
+
+#if 0
+static void putc(const char c)
+{
+	unsigned char *base = MV_SERIAL_BASE;
+	int i;
+
+	for (i = 0; i < 0x1000; i++) {
+		if (base[UART_LSR << 2] & UART_LSR_THRE)
+			break;
+		barrier();
+	}
+
+	base[UART_TX << 2] = c;
+}
+#endif
+#if 0
+static void flush(void)
+{
+	unsigned char *base = MV_SERIAL_BASE;
+	unsigned char mask;
+	int i;
+
+	mask = UART_LSR_TEMT | UART_LSR_THRE;
+
+	for (i = 0; i < 0x1000; i++) {
+		if ((base[UART_LSR << 2] & mask) == mask)
+			break;
+		barrier();
+	}
+}
+#endif
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
+#endif
diff --git a/arch/arm/mach-avantalp/include/mach/vmalloc.h b/arch/arm/mach-avantalp/include/mach/vmalloc.h
new file mode 100644
index 0000000..1630fe6
--- /dev/null
+++ b/arch/arm/mach-avantalp/include/mach/vmalloc.h
@@ -0,0 +1,11 @@
+/*
+ * include/asm-arm/arch-aurora/vmalloc.h
+ */
+
+/* Dove LCD driver performs big allocations for FrameBuffer memory, we need to
+ * move CONSISTENT_BASE by 32MB
+ */
+/* Was 0x2000000 */
+
+#define VMALLOC_END	(0xfa800000)
+
diff --git a/arch/arm/mach-avantalp/leds.c b/arch/arm/mach-avantalp/leds.c
new file mode 100644
index 0000000..66639b2
--- /dev/null
+++ b/arch/arm/mach-avantalp/leds.c
@@ -0,0 +1,49 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/init.h>
+
+#include <mach/hardware.h>
+#include <asm/leds.h>
+#include <asm/system.h>
+#include <asm/mach-types.h>
+#include "boardEnv/mvBoardEnvLib.h"
+
+static	u32		last_jiffies = 0;
+static	u32		led_val = 0;
+
+
+void mv_leds_hearbeat(void)
+{
+	u32 sec = jiffies_to_msecs(jiffies - last_jiffies) / 1000;
+	
+	if (!sec)
+		return;
+
+	led_val = (led_val % (1 << mvBoardDebugLedNumGet(mvBoardIdGet())));
+	mvBoardDebugLed(led_val);
+	led_val++;
+	last_jiffies = jiffies;
+}
+
+static int __init leds_init(void)
+{
+	return 0;
+}
+
+__initcall(leds_init);
diff --git a/arch/arm/mach-avantalp/localtimer.c b/arch/arm/mach-avantalp/localtimer.c
new file mode 100644
index 0000000..0fb3961
--- /dev/null
+++ b/arch/arm/mach-avantalp/localtimer.c
@@ -0,0 +1,27 @@
+/*
+ *  linux/arch/arm/plat-versatile/localtimer.c
+ *
+ *  Copyright (C) 2002 ARM Ltd.
+ *  All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/init.h>
+#include <linux/smp.h>
+#include <linux/clockchips.h>
+
+#include <asm/smp_twd.h>
+#include <asm/localtimer.h>
+#include <mach/irqs.h>
+
+/*
+ * Setup the local clock events for a CPU.
+ */
+int __cpuinit local_timer_setup(struct clock_event_device *evt)
+{
+	evt->irq = IRQ_LOCALTIMER;
+	twd_timer_setup(evt);
+	return 0;
+}
diff --git a/arch/arm/mach-avantalp/mpp.h b/arch/arm/mach-avantalp/mpp.h
new file mode 100644
index 0000000..1065468
--- /dev/null
+++ b/arch/arm/mach-avantalp/mpp.h
@@ -0,0 +1,34 @@
+#ifndef __ARCH_DOVE_MPP_H
+#define __ARCH_DOVE_MPP_H
+
+enum aurora_mpp_type {
+	/*
+	 * This MPP is unused.
+	 */
+	MPP_UNUSED,
+
+	/*
+	 * This MPP pin is used as a generic GPIO pin.
+	 */
+	MPP_GPIO,
+
+        /*
+         * This MPP is used as a SATA activity LED.
+         */
+        MPP_SATA_LED,
+        /*
+         * This MPP is used as a functional pad.
+         */
+        MPP_FUNCTIONAL,
+
+};
+
+struct aurora_mpp_mode {
+	int			mpp;
+	enum aurora_mpp_type	type;
+};
+
+void aurora_mpp_conf(struct aurora_mpp_mode *mode);
+
+
+#endif
diff --git a/arch/arm/mach-avantalp/mv_hal_if/mvSysCesa.c b/arch/arm/mach-avantalp/mv_hal_if/mvSysCesa.c
new file mode 100644
index 0000000..3d41db4
--- /dev/null
+++ b/arch/arm/mach-avantalp/mv_hal_if/mvSysCesa.c
@@ -0,0 +1,122 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "cesa/mvCesaIf.h"
+
+extern u32 mv_crypto_phys_base_get(u8 chan);
+extern u32 mv_crypto_virt_base_get(u8 chan);
+
+/*******************************************************************************
+* mvSysCesaInit - Initialize the Cesa subsystem
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_STATUS mvSysCesaInit(int numOfSession, int queueDepth, void *osHandle)
+{
+	MV_CESA_HAL_DATA halData;
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_STATUS status;
+	MV_U8 chan;
+
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+
+	if(status == MV_OK) {
+		for(chan = 0; chan < MV_CESA_CHANNELS; chan++) {
+			status = mvCesaIfTdmaWinInit(chan, addrWinMap);
+
+			if(status != MV_OK) {
+				mvOsPrintf("Error, unable to initialize CESA windows for channel(%d)\n", chan);
+				break;
+			}
+			halData.sramPhysBase[chan] = (MV_ULONG)mv_crypto_phys_base_get(chan);
+			halData.sramVirtBase[chan] = (MV_U8*)mv_crypto_virt_base_get(chan);
+#ifdef CONFIG_ARMADA_SUPPORT_DEEP_IDLE_FAST_EXIT
+			halData.sramOffset[chan] = 32;
+#else
+			halData.sramOffset[chan] = 0;
+#endif
+		}
+
+		if(status == MV_OK) {
+		halData.ctrlModel = mvCtrlModelGet();
+		halData.ctrlRev = mvCtrlRevGet();
+			status = mvCesaIfHalInit (numOfSession, queueDepth,
+					osHandle, &halData);
+	}
+	}
+
+	return status;
+}
diff --git a/arch/arm/mach-avantalp/mv_hal_if/mvSysCesaApi.h b/arch/arm/mach-avantalp/mv_hal_if/mvSysCesaApi.h
new file mode 100644
index 0000000..ce8aa9b
--- /dev/null
+++ b/arch/arm/mach-avantalp/mv_hal_if/mvSysCesaApi.h
@@ -0,0 +1,71 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_CESA_API_H__
+#define __MV_SYS_CESA_API_H__
+
+
+MV_STATUS mvSysCesaInit (int numOfSession, int queueDepth, void *osHandle);
+
+#endif
diff --git a/arch/arm/mach-avantalp/mv_hal_if/mvSysDdr.c b/arch/arm/mach-avantalp/mv_hal_if/mvSysDdr.c
new file mode 100644
index 0000000..38dc444
--- /dev/null
+++ b/arch/arm/mach-avantalp/mv_hal_if/mvSysDdr.c
@@ -0,0 +1,134 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "boardEnv/mvBoardEnvSpec.h"
+#include "twsi/mvTwsi.h"
+
+
+/*******************************************************************************
+* mvSysDdrSpdRead
+*
+* DESCRIPTION:
+*	System interface for reading DDR SPD contents.
+*
+* INPUT:
+*       data:	Buffer to read data into.
+*       size:	Number of bytes to read.
+*
+* OUTPUT:
+*       data:	SPD data.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysDdrSpdRead(MV_U8 *data, MV_U32 size)
+{
+	MV_TWSI_SLAVE slave;
+
+	slave.slaveAddr.address = MV_BOARD_DIMM0_I2C_ADDR;
+	slave.slaveAddr.type = ADDR7_BIT;
+	slave.validOffset = MV_TRUE;
+	slave.offset = 0;
+	slave.moreThen256 = MV_FALSE;
+
+	return mvTwsiRead(MV_BOARD_DIMM_I2C_CHANNEL, &slave, data, size);
+}
+
+
+/*******************************************************************************
+* mvSysDdrSpdWrite
+*
+* DESCRIPTION:
+*	System interface for writing DDR SPD contents.
+*
+* INPUT:
+*       data:	Buffer holding the data to be written.
+*       size:	Number of bytes to write.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysDdrSpdWrite(MV_U8 *data, MV_U32 size)
+{
+	MV_TWSI_SLAVE slave;
+
+	slave.slaveAddr.address = MV_BOARD_DIMM0_I2C_ADDR;
+	slave.slaveAddr.type = ADDR7_BIT;
+	slave.validOffset = MV_TRUE;
+	slave.offset = 0;
+	slave.moreThen256 = MV_FALSE;
+
+	return	mvTwsiWrite(MV_BOARD_DIMM_I2C_CHANNEL, &slave, data, size);
+}
+
diff --git a/arch/arm/mach-avantalp/mv_hal_if/mvSysEth.c b/arch/arm/mach-avantalp/mv_hal_if/mvSysEth.c
new file mode 100644
index 0000000..f8b64b6
--- /dev/null
+++ b/arch/arm/mach-avantalp/mv_hal_if/mvSysEth.c
@@ -0,0 +1,132 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "cpu/mvCpu.h"
+#include "eth/mvEth.h"
+
+
+/*******************************************************************************
+* mvSysEthInit - Initialize the Eth subsystem
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvSysEthInit(MV_VOID)
+{
+	MV_ETH_HAL_DATA halData;
+	MV_U32 port;
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_STATUS status;
+
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+	if(status != MV_OK)
+		return;
+
+	{
+		int i;
+		for(i = 0; i < MAX_TARGETS; i++) {
+			if(addrWinMap[i].enable == MV_FALSE)
+				continue;
+			printk("%d - Base 0x%08x , Size = 0x%08x.\n", i,
+					addrWinMap[i].addrWin.baseLow,
+					addrWinMap[i].addrWin.size);
+		}
+	}
+	halData.maxPortNum = mvCtrlEthMaxPortGet();
+	halData.cpuPclk = mvCpuPclkGet();
+	halData.tclk = mvBoardTclkGet();
+#ifdef ETH_DESCR_IN_SRAM
+	halData.sramSize = mvCtrlSramSizeGet();
+#endif
+
+	for (port=0;port < halData.maxPortNum;port++) {
+		if(mvCtrlPwrClckGet(ETH_GIG_UNIT_ID, port) == MV_FALSE) {
+			halData.portData[port].powerOn = MV_FALSE;
+			continue;
+		}
+		status = mvEthWinInit(port, addrWinMap);
+		if(status == MV_OK) {
+			halData.portData[port].powerOn = MV_TRUE;
+			halData.portData[port].phyAddr = mvBoardPhyAddrGet(port);
+			halData.portData[port].isSgmii = mvBoardIsPortInSgmii(port);
+			halData.portData[port].macSpeed = mvBoardMacSpeedGet(port);
+		}
+	}
+
+	mvEthHalInit(&halData);
+
+	return;
+}
+
diff --git a/arch/arm/mach-avantalp/mv_hal_if/mvSysEthApi.h b/arch/arm/mach-avantalp/mv_hal_if/mvSysEthApi.h
new file mode 100644
index 0000000..e1016e4
--- /dev/null
+++ b/arch/arm/mach-avantalp/mv_hal_if/mvSysEthApi.h
@@ -0,0 +1,71 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_ETH_API_H__
+#define __MV_SYS_ETH_API_H__
+
+
+MV_VOID mvSysEthInit(void);
+
+#endif
diff --git a/arch/arm/mach-avantalp/mv_hal_if/mvSysEthPhy.c b/arch/arm/mach-avantalp/mv_hal_if/mvSysEthPhy.c
new file mode 100644
index 0000000..0c9cdf5
--- /dev/null
+++ b/arch/arm/mach-avantalp/mv_hal_if/mvSysEthPhy.c
@@ -0,0 +1,104 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "eth-phy/mvEthPhy.h"
+#if defined(MV_ETH_LEGACY)
+#include "eth/gbe/mvEthRegs.h"
+#else
+#include "neta/gbe/mvEthRegs.h"
+#endif
+
+
+/*******************************************************************************
+* mvSysEthPhyInit - Initialize the EthPhy subsystem
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_STATUS mvSysEthPhyInit(void)
+{
+	MV_ETHPHY_HAL_DATA halData;
+	MV_U32 port;
+
+	for (port=0; port < mvCtrlEthMaxPortGet(); port++) {
+		halData.phyAddr[port] = mvBoardPhyAddrGet(port);
+		halData.boardSpecInit = MV_FALSE;
+	}
+
+	halData.ethPhySmiReg = ETH_SMI_REG(MV_ETH_SMI_PORT); 
+
+	return mvEthPhyHalInit(&halData);
+}
diff --git a/arch/arm/mach-avantalp/mv_hal_if/mvSysEthPhyApi.h b/arch/arm/mach-avantalp/mv_hal_if/mvSysEthPhyApi.h
new file mode 100644
index 0000000..eab268a
--- /dev/null
+++ b/arch/arm/mach-avantalp/mv_hal_if/mvSysEthPhyApi.h
@@ -0,0 +1,71 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_ETHPHY_API_H__
+#define __MV_SYS_ETHPHY_API_H__
+
+
+MV_STATUS mvSysEthPhyInit(void);
+
+#endif
diff --git a/arch/arm/mach-avantalp/mv_hal_if/mvSysNeta.c b/arch/arm/mach-avantalp/mv_hal_if/mvSysNeta.c
new file mode 100644
index 0000000..d5f1c39
--- /dev/null
+++ b/arch/arm/mach-avantalp/mv_hal_if/mvSysNeta.c
@@ -0,0 +1,150 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "cpu/mvCpu.h"
+#include "neta/gbe/mvNeta.h"
+
+
+/*******************************************************************************
+* mvSysNetaInit - Initialize the Eth subsystem
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+void 	mvSysNetaInit(MV_U32 portMask, MV_U32 cpuMask)
+{
+	MV_NETA_HAL_DATA halData;
+	MV_U32 port;
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_STATUS status;
+	int i;
+
+	memset(&halData, 0, sizeof(halData));
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+	if (status != MV_OK)
+		return;
+
+	for (i = 0; i < MAX_TARGETS; i++) {
+		if (addrWinMap[i].enable == MV_FALSE)
+			continue;
+
+#ifdef CONFIG_MV_SUPPORT_L2_DEPOSIT
+		/* Setting DRAM windows attribute to :
+		   0x3 - Shared transaction + L2 write allocate (L2 Deposit) */
+		if (MV_TARGET_IS_DRAM(i)) {
+			addrWinMap[i].attrib &= ~(0x30);
+			addrWinMap[i].attrib |= 0x30;
+		}
+#endif
+		mvOsPrintf("%d - Base 0x%08x , Size = 0x%08llx.\n", i,
+						addrWinMap[i].addrWin.baseLow, addrWinMap[i].addrWin.size);
+	}
+
+	halData.portMask = portMask;
+	halData.cpuMask  = cpuMask;
+	halData.maxPort = mvCtrlEthMaxPortGet();
+	halData.pClk = mvCpuPclkGet();
+	halData.tClk = mvBoardTclkGet();
+	halData.maxCPUs = mvCtrlEthMaxCPUsGet();
+	halData.iocc = arch_is_coherent();
+	halData.ctrlModel = mvCtrlModelGet();
+	halData.ctrlRev = mvCtrlRevGet();
+#ifdef CONFIG_MV_ETH_BM
+	halData.bmPhysBase = PNC_BM_PHYS_BASE;
+	halData.bmVirtBase = (MV_U8 *)ioremap(PNC_BM_PHYS_BASE, PNC_BM_SIZE);
+#endif /* CONFIG_MV_ETH_BM */
+
+#ifdef CONFIG_MV_ETH_PNC
+	halData.pncPhysBase = PNC_BM_PHYS_BASE;
+	halData.pncVirtBase = (MV_U8 *)ioremap(PNC_BM_PHYS_BASE, PNC_BM_SIZE);
+#endif /* CONFIG_MV_ETH_PNC */
+
+	for (port = 0; port < halData.maxPort; port++) {
+		if (!(MV_BIT_CHECK(portMask, port)))
+			continue;
+
+		if (mvCtrlPwrClckGet(ETH_GIG_UNIT_ID, port) == MV_FALSE)
+			continue;
+
+		mvNetaPortPowerUp(port, mvBoardIsPortInSgmii(port), !mvBoardIsPortInGmii(port));
+		status = mvNetaWinInit(port, addrWinMap);
+		if (status != MV_OK)
+			continue;
+	}
+	mvNetaHalInit(&halData);
+
+	return;
+}
+
diff --git a/arch/arm/mach-avantalp/mv_hal_if/mvSysNetaApi.h b/arch/arm/mach-avantalp/mv_hal_if/mvSysNetaApi.h
new file mode 100644
index 0000000..be0aaa0
--- /dev/null
+++ b/arch/arm/mach-avantalp/mv_hal_if/mvSysNetaApi.h
@@ -0,0 +1,71 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_NETA_API_H__
+#define __MV_SYS_NETA_API_H__
+
+
+void mvSysNetaInit(MV_U32 portMask, MV_U32 cpuMask);
+
+#endif /* __MV_SYS_NETA_API_H__ */
diff --git a/arch/arm/mach-avantalp/mv_hal_if/mvSysPci.c b/arch/arm/mach-avantalp/mv_hal_if/mvSysPci.c
new file mode 100644
index 0000000..ce4e013
--- /dev/null
+++ b/arch/arm/mach-avantalp/mv_hal_if/mvSysPci.c
@@ -0,0 +1,1382 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell 
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File under the following licensing terms. 
+Redistribution and use in source and binary forms, with or without modification, 
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer. 
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution. 
+
+    *   Neither the name of Marvell nor the names of its contributors may be 
+        used to endorse or promote products derived from this software without 
+        specific prior written permission. 
+    
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvSysPci.h"
+#include "ddr2_3/mvDramIf.h"
+
+/* PCI BARs registers offsets are inconsecutive. This struct describes BAR	*/
+/* register offsets	and its function where its is located.			*/
+/* Also, PCI address remap registers offsets are inconsecutive. This struct	*/
+/* describes address remap register offsets					*/
+typedef struct _pciBarRegInfo
+{
+	MV_U32 funcNum;
+	MV_U32 baseLowRegOffs;
+	MV_U32 baseHighRegOffs;
+	MV_U32 sizeRegOffs;
+	MV_U32 remapLowRegOffs;
+	MV_U32 remapHighRegOffs;
+}PCI_BAR_REG_INFO;
+
+typedef struct _pciBarStatus
+{
+	MV_PCI_BAR	bar;
+	int		enable;
+}PCI_BAR_STATUS;
+
+PCI_BAR_STATUS pciBarStatusMap[] = 
+{
+#if defined(MV_INCLUDE_SDRAM_CS0)
+	{CS0_BAR, EN},      
+#endif
+#if defined(MV_INCLUDE_SDRAM_CS1)
+        {CS1_BAR, EN}, 	
+#endif	      		
+#if defined(MV_INCLUDE_SDRAM_CS2)
+        {CS2_BAR, EN}, 	
+#endif
+#if defined(MV_INCLUDE_SDRAM_CS3)
+        {CS3_BAR, EN},   		
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS0)          		
+	{DEVCS0_BAR, EN},    	
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS1)          		
+	{DEVCS1_BAR, EN},    	
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS2)          		
+	{DEVCS2_BAR, EN},    	
+#endif
+	{BOOTCS_BAR, EN},     	
+	{MEM_INTER_REGS_BAR, EN},
+	{IO_INTER_REGS_BAR, EN}, 
+	{P2P_MEM0, DIS},     		
+	{P2P_IO, DIS},
+	{TBL_TERM, TBL_TERM}       	
+};
+
+/* PCI BAR table. Note that table entry number must match its target 		*/
+/* enumerator. For example, table entry '4' must describe Deivce CS0 		*/
+/* target which is represent by DEVICE_CS0 enumerator (4).                  */
+#if 0
+MV_PCI_BAR_WIN pciBarMap[] = 
+{
+/*     base low      base high      size        enable/disable				*/
+	{{SDRAM_CS0_BASE , 0, SDRAM_CS0_SIZE      	 },   EN},          
+	{{SDRAM_CS1_BASE , 0, SDRAM_CS1_SIZE      	 },   EN},          
+	{{SDRAM_CS2_BASE , 0, SDRAM_CS2_SIZE      	 },   EN},          
+	{{SDRAM_CS3_BASE , 0, SDRAM_CS3_SIZE      	 },   EN},          
+	{{DEVICE_CS0_BASE, 0, DEVICE_CS0_SIZE     	 },   EN},          
+	{{DEVICE_CS1_BASE, 0, DEVICE_CS1_SIZE     	 },   EN},          
+	{{DEVICE_CS2_BASE, 0, DEVICE_CS2_SIZE     	 },   EN},          
+	{{BOOTDEV_CS_BASE, 0, BOOTDEV_CS_SIZE     	 },   EN},          
+	{{INTER_REGS_BASE, 0, INTER_REGS_SIZE 	 	 },   EN},
+	{{INTER_REGS_BASE, 0, INTER_REGS_SIZE 	 	 },   EN},
+	{{  0xFFFFFFFF   , 0,    0xFFFFFFFF          },  DIS}, 	/* Ignore P2P 	*/ 
+	{{  0xFFFFFFFF   , 0,    0xFFFFFFFF          },  DIS},	/* Ignore P2P 	*/ 
+    /* Table terminator */
+    {{TBL_TERM, TBL_TERM, TBL_TERM}, TBL_TERM} 
+};
+#endif
+
+/* Locals */
+static MV_U32 pciBurstBytes2Reg(MV_U32 size);
+static MV_U32 pciBurstReg2Bytes(MV_U32 size);
+
+static MV_STATUS pciWinOverlapDetect(MV_U32 pciIf, MV_PCI_BAR bar,
+									 MV_ADDR_WIN *pAddrWin);
+
+static MV_STATUS pciBarRegInfoGet(MV_U32 pciIf, MV_PCI_BAR bar, 
+								  PCI_BAR_REG_INFO *pBarRegInfo);
+
+static MV_STATUS pciWinIsValid(MV_U32 baseLow, MV_U32 size);
+
+/* Forward declarations */
+const MV_8* pciBarNameGet(MV_PCI_BAR bar);
+
+/*******************************************************************************
+* mvPciInit - Initialize PCI interfaces
+*
+* DESCRIPTION:
+*       This function initiate the PCI interface:
+*       1) Set local bus number. In case of convential PCI it gets the bus
+*          number using mvPciLocalBusNumGet(). In case of PCI-X this 
+*          information is read only.
+*       2) Interface device number. In case of conventional PCI it gets the
+*          device number using mvPciLocalDevNumGet(). In case of PCI-X this 
+*          information is read only.
+*       3) PCI Arbiter if needed.
+*       4) Enable Master and Slave on PCI interfaces.
+*	5) Open PCI BARs according to default setting. 
+*	   Note that PCI bridge (P2P) is NOT initialized.
+*	6) Enable CPU to PCI ordering.
+*
+* INPUT:
+*
+*       pciIf   - PCI interface number.
+*		localBus - Local Bus of the PCI interface to be set
+*		localDev - Local Dev of the PCI interface to be set
+*		bFirstCall - Indicates wether this is the first call of this
+*					 function .
+*
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_OK if function success otherwise MV_ERROR or MV_BAD_PARAM
+*
+*******************************************************************************/
+MV_STATUS mvPciInit(MV_U32 pciIf, MV_PCI_MOD pciIfmod)
+{
+	MV_PCI_BAR     bar, barix=0;
+	MV_PCI_MODE    pciMode;
+	MV_PCI_PROT_WIN pciProtWin;
+   	MV_PCI_BAR_WIN pciBarMap[PCI_MAX_BARS];  
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_TARGET target;
+	MV_UNIT_WIN_INFO *addrDecWin;
+
+	/* Parameter checking  */
+	if (pciIf >= mvCtrlPciMaxIfGet()) {
+		mvOsPrintf("mvPciInit: ERR. Invalid PCI interface %d\n", pciIf);
+		return MV_BAD_PARAM;
+	}
+
+	/* device and bus numbers */
+	if (MV_OK != mvPciModeGet(pciIf, &pciMode)) {
+		mvOsPrintf("mvPciInit: ERR. mvPciModeGet failed\n");
+		return MV_ERROR;
+	}
+
+	/* First disable all PCI target windows  */
+	for (bar = 0; bar < PCI_MAX_BARS; bar++)
+		mvPciTargetWinEnable(pciIf, bar, MV_FALSE);
+
+	/* WA CQ 4382*/
+	MV_REG_BIT_SET(PCI_BASE_ADDR_ENABLE_REG(pciIf) ,BIT15);
+
+	/* Loop over all BARs and copy enabled SDRAM windows only */
+	if (MV_OK != mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1)){
+		mvOsPrintf("mvPciInit: ERR. mvCtrlAddrWinMapBuild failed\n");
+		return MV_ERROR;
+	}
+
+	for (target = SDRAM_CS0; target <= SDRAM_CS3; target++) {
+		addrDecWin = &addrWinMap[target];
+		if (addrDecWin->enable == MV_TRUE) {
+			pciBarMap[barix].addrWin.baseLow = addrDecWin->addrWin.baseLow;
+			pciBarMap[barix].addrWin.baseHigh = addrDecWin->addrWin.baseHigh;
+			pciBarMap[barix].addrWin.size = addrDecWin->addrWin.size;
+			pciBarMap[barix].enable = EN;
+			barix++;
+		}
+	}
+
+	/* Initialize all non used BARs */
+	for (bar = barix; bar < PCI_MAX_BARS; bar++) {
+		pciBarMap[bar].addrWin.baseLow = 0xFFFFFFFF;
+		pciBarMap[bar].addrWin.baseHigh = 0;
+		pciBarMap[bar].addrWin.size = 0xFFFFFFFF;
+		pciBarMap[bar].enable = DIS;
+	}
+
+	/* finally fill table with TBL_TERM entry */
+	bar = PCI_MAX_BARS - 1;
+	pciBarMap[bar].addrWin.baseLow = TBL_TERM;
+	pciBarMap[bar].addrWin.baseHigh = TBL_TERM;
+	pciBarMap[bar].addrWin.size = TBL_TERM;
+	pciBarMap[bar].enable =  TBL_TERM;
+
+
+    	/* Memory Mapped Internal Registers BAR can not be disabled.            */
+    	/* Relocate its BAR first to avoid colisions with other BARs (e.g DRAM) */
+    	if (MV_OK != mvPciTargetWinSet(pciIf, MEM_INTER_REGS_BAR, &pciBarMap[MEM_INTER_REGS_BAR])) {
+        	mvOsPrintf("mvPciInit: ERR. mvPciTargetWinSet failed\n");
+        	return MV_ERROR;
+    	}        
+
+	/* Now, go through all targets in default table until table terminator	*/
+	for (bar = 0; pciBarMap[bar].enable != TBL_TERM; bar++)
+    	{
+		/* Skip the P2P BARs. They should be configured seperately			*/
+		if (0xFFFFFFFF == pciBarMap[bar].addrWin.baseLow)
+            		continue;
+
+		/* check if the size passed is zero ! */
+		if (0 == pciBarMap[bar].addrWin.size) {
+			/* disable the bar */
+			mvPciTargetWinEnable(pciIf,bar,MV_FALSE);
+			continue;
+		}
+
+		if (MV_OK != mvPciTargetWinSet(pciIf, bar, &pciBarMap[bar])) {
+			mvOsPrintf("mvPciInit: ERR. mvPciTargetWinSet %d failed\n", bar);
+			return MV_ERROR;
+		}        
+    	}
+	
+	MV_REG_BIT_SET(PCI_ADDR_DECODE_CONTROL_REG(pciIf), PADCR_REMAP_REG_WR_DIS);
+
+	/* configure access control unit 0 to DDR to enhance performance */
+	pciProtWin.addrWin.baseLow = 0;
+	pciProtWin.addrWin.baseHigh = 0;
+	pciProtWin.addrWin.size = mvDramIfSizeGet();
+#ifdef AURORA_IO_CACHE_COHERENCY
+	pciProtWin.attributes.snoop = WT_CACHE_COHER;
+#else
+	pciProtWin.attributes.snoop = NO_CACHE_COHER;
+#endif
+	pciProtWin.attributes.access = ALLOWED;
+	pciProtWin.attributes.write = ALLOWED;
+	pciProtWin.attributes.swapType = MV_BYTE_SWAP;
+	pciProtWin.attributes.readMaxBurst = 128; 
+	pciProtWin.attributes.readBurst = 256;
+	pciProtWin.attributes.writeMaxBurst = 128;
+	pciProtWin.attributes.pciOrder = MV_FALSE;
+	pciProtWin.enable = MV_TRUE;
+	if( mvPciProtWinSet(pciIf, 0, &pciProtWin) != MV_OK ) {
+		mvOsPrintf("mvPciInit: ERR. mvPciProtWinSet failed\n");
+		return MV_ERROR;
+	}
+
+	mvPciHalInit(pciIf, pciIfmod);
+
+	return MV_OK;
+}
+
+
+
+/*******************************************************************************
+* mvPciTargetWinSet - Set PCI to peripheral target address window BAR
+*
+* DESCRIPTION:
+*       This function sets an address window from PCI to a peripheral 
+*       target (e.g. SDRAM bank0, PCI_MEM0), also known as BARs. 
+*       A new PCI BAR window is set for specified target address window.
+*       If address decode window parameter structure enables the window, 
+*       the routine will also enable the target window, allowing PCI to access
+*       the target window.
+*
+* INPUT:
+*       pciIf       - PCI interface number.
+*       bar         - BAR to be accessed by slave.
+*       pAddrBarWin - PCI target window information data structure.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_OK if PCI BAR target window was set correctly, MV_BAD_PARAM on bad params 
+*       MV_ERROR otherwise 
+*       (e.g. address window overlapps with other active PCI target window).
+*
+*******************************************************************************/
+MV_STATUS mvPciTargetWinSet(MV_U32 pciIf,
+							MV_PCI_BAR bar, 
+                            MV_PCI_BAR_WIN *pAddrBarWin)
+{
+	MV_U32 pciData;
+	MV_U32 sizeToReg;
+	MV_U32 size;
+	MV_U32 baseLow;
+	MV_U32 baseHigh;
+	MV_U32 localBus;
+	MV_U32 localDev;
+	PCI_BAR_REG_INFO barRegInfo;
+
+	size     = pAddrBarWin->addrWin.size;
+	baseLow  = pAddrBarWin->addrWin.baseLow;
+	baseHigh = pAddrBarWin->addrWin.baseHigh;
+
+	/* Parameter checking   */
+	if(pciIf >= mvCtrlPciMaxIfGet())
+	{
+		mvOsPrintf("mvPciTargetWinSet: ERR. Invalid PCI interface %d\n", pciIf);
+		return MV_BAD_PARAM;
+	}
+
+	if(bar >= PCI_MAX_BARS )
+	{
+		mvOsPrintf("mvPciTargetWinSet: ERR. Illigal PCI BAR %d\n", bar);
+		return MV_BAD_PARAM;
+	}
+
+
+	/* if the address windows is disabled , we only disable the appropriare
+	pci bar and ignore other settings */
+
+	if (MV_FALSE == pAddrBarWin->enable)
+	{
+        MV_REG_BIT_SET(PCI_BASE_ADDR_ENABLE_REG(pciIf), BARER_ENABLE(bar));
+		return MV_OK;
+	}
+
+	if (0 == pAddrBarWin->addrWin.size)
+	{
+        mvOsPrintf("mvPciTargetWinSet: ERR. Target %d can't be zero!\n",bar);
+        return MV_BAD_PARAM;
+	}
+
+	/* Check if the window complies with PCI spec							*/
+	if (MV_TRUE != pciWinIsValid(baseLow, size))
+	{
+        mvOsPrintf("mvPciTargetWinSet: ERR. Target %d window invalid\n", bar);
+		return MV_BAD_PARAM;
+	}
+
+    /* 2) Check if the requested window overlaps with current windows		*/
+	if(MV_TRUE == pciWinOverlapDetect(pciIf, bar, &pAddrBarWin->addrWin))
+	{
+		mvOsPrintf("mvPciTargetWinSet: ERR. Overlap detected for target %d\n",
+																		bar);
+		return MV_BAD_PARAM;
+	}
+
+	/* Get size register value according to window size						*/
+	sizeToReg = ctrlSizeToReg(size, PBBLR_BASE_ALIGNMET);
+
+	/* Size parameter validity check.                                   */
+	if (-1 == sizeToReg)
+	{
+		mvOsPrintf("mvPciTargetWinSet: ERR. Target BAR %d size invalid.\n",bar);
+		return MV_BAD_PARAM;
+	}
+
+	localBus = mvPciLocalBusNumGet(pciIf);
+	localDev = mvPciLocalDevNumGet(pciIf);
+	
+	/* Get BAR register information */
+	pciBarRegInfoGet(pciIf, bar, &barRegInfo);
+	
+	/* Internal register space size have no size register. Do not perform	*/
+	/* size register assigment for this slave target					 	*/
+	if (0 != barRegInfo.sizeRegOffs)
+	{    
+		/* Update size register */
+		MV_REG_WRITE(barRegInfo.sizeRegOffs, (sizeToReg << BAR_SIZE_OFFS));
+	}
+	
+	/* Read current address */
+	pciData = mvPciConfigRead(pciIf, localBus, localDev, barRegInfo.funcNum, 
+													barRegInfo.baseLowRegOffs);
+
+	/* Clear current address */
+	pciData &= ~PBBLR_BASE_MASK;
+	pciData |= (baseLow & PBBLR_BASE_MASK);
+		
+	/* Write new address */
+	mvPciConfigWrite(pciIf, localBus, localDev, barRegInfo.funcNum,
+											barRegInfo.baseLowRegOffs, pciData);
+
+	/* Skip base high settings if the BAR has only base low (32-bit)		*/
+	if (0 != barRegInfo.baseHighRegOffs)
+	{
+		mvPciConfigWrite(pciIf, localBus, localDev, barRegInfo.funcNum, 
+										barRegInfo.baseHighRegOffs, baseHigh);	
+	}
+
+	/* Enable/disable the BAR */
+    if (MV_TRUE == pAddrBarWin->enable)
+    {
+        MV_REG_BIT_RESET(PCI_BASE_ADDR_ENABLE_REG(pciIf), BARER_ENABLE(bar));
+    }
+	else
+	{
+        MV_REG_BIT_SET(PCI_BASE_ADDR_ENABLE_REG(pciIf), BARER_ENABLE(bar));
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvPciTargetWinGet - Get PCI to peripheral target address window
+*
+* DESCRIPTION:
+*		Get the PCI to peripheral target address window BAR.
+*
+* INPUT:
+*       pciIf - PCI interface number.
+*       bar   - BAR to be accessed by slave.
+*
+* OUTPUT:
+*       pAddrBarWin - PCI target window information data structure.
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvPciTargetWinGet(MV_U32 pciIf, MV_PCI_BAR bar, 
+                            MV_PCI_BAR_WIN *pAddrBarWin)
+{
+	MV_U32 size;
+	MV_U32 baseLow;
+	MV_U32 baseHigh;
+	MV_U32 localBus;
+	MV_U32 localDev;
+	MV_U32 barEnable;
+	PCI_BAR_REG_INFO barRegInfo;
+
+	/* Parameter checking   */
+	if (pciIf >= mvCtrlPciMaxIfGet())
+	{
+		mvOsPrintf("mvPciTargetWinGet: ERR. Invalid PCI interface %d\n", pciIf);
+		return MV_BAD_PARAM;
+	}
+
+	if (bar >= PCI_MAX_BARS )
+	{
+		mvOsPrintf("mvPciTargetWinGet: ERR. Illigal PCI BAR %d.\n", bar);
+		return MV_BAD_PARAM;
+	}
+
+	localBus = mvPciLocalBusNumGet(pciIf);
+	localDev = mvPciLocalDevNumGet(pciIf);
+
+	/* Get BAR register information */
+	pciBarRegInfoGet(pciIf, bar, &barRegInfo);
+
+	/* Reading Base Low bar */
+	baseLow = mvPciConfigRead(pciIf, localBus, localDev, barRegInfo.funcNum, 
+												barRegInfo.baseLowRegOffs);
+
+	baseLow &= PBBLR_BASE_MASK;
+
+	/* Skip base high if the BAR has only base low (32-bit)		*/
+	if (0 != barRegInfo.baseHighRegOffs)
+	{
+		/* Reading Base High */
+		baseHigh = mvPciConfigRead(pciIf, localBus, localDev, barRegInfo.funcNum, 
+												barRegInfo.baseHighRegOffs);
+	}
+	else
+	{
+		baseHigh = 0;
+	}
+
+    /* Internal register space size have no size register. Do not perform	*/
+	/* size register assigment for this slave target					 	*/
+	if (0 != barRegInfo.sizeRegOffs)
+	{    
+		/* Reading bar size*/
+		size = ctrlRegToSize(
+					(MV_REG_READ(barRegInfo.sizeRegOffs) >> PBSR_SIZE_OFFS), 
+														PBBLR_BASE_ALIGNMET);
+	}
+	else
+	{
+		size = INTER_REGS_SIZE;
+	}
+
+	/* Assign value to user struct */
+	pAddrBarWin->addrWin.baseLow  = baseLow;
+	pAddrBarWin->addrWin.baseHigh = baseHigh;
+	pAddrBarWin->addrWin.size     = size;
+
+	/* Check if window is enabled   */
+	barEnable = MV_REG_READ(PCI_BASE_ADDR_ENABLE_REG(pciIf));
+	
+	if (~barEnable & (BARER_ENABLE(bar)))
+    {
+        pAddrBarWin->enable = MV_TRUE;
+    }
+    else
+    {
+        pAddrBarWin->enable = MV_FALSE;
+    }
+
+	return MV_OK;
+}
+
+
+/*******************************************************************************
+* mvPciTargetWinEnable - Enable/disable a PCI BAR window
+*
+* DESCRIPTION:
+*       This function enable/disable a PCI BAR window.
+*       if parameter 'enable' == MV_TRUE the routine will enable the 
+*       window, thus enabling PCI accesses for that BAR (before enabling the 
+*       window it is tested for overlapping). Otherwise, the window will 
+*       be disabled.
+*
+* INPUT:
+*       pciIf  - PCI interface number.
+*       bar    - BAR to be accessed by slave.
+*       enable - Enable/disable parameter.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvPciTargetWinEnable(MV_U32 pciIf, MV_PCI_BAR bar, MV_BOOL enable)
+{
+	MV_PCI_BAR_WIN barWin;
+
+	/* Parameter checking   */
+	if (pciIf >= mvCtrlPciMaxIfGet())
+	{
+		mvOsPrintf("mvPciTargetWinEnable: ERR. Invalid PCI interface %d\n",
+                                                                        pciIf);
+		return MV_BAD_PARAM;
+	}
+
+	if (bar >= PCI_MAX_BARS )
+	{
+		mvOsPrintf("mvPciTargetWinEnable: ERR. Illigal PCI BAR %d\n", bar);
+		return MV_BAD_PARAM;
+	}
+	
+	if (MV_TRUE == enable)
+	{   /* First check for overlap with other enabled windows				*/
+        /* Get current window */
+		if (MV_OK != mvPciTargetWinGet(pciIf, bar, &barWin))
+		{
+			mvOsPrintf("mvPciTargetWinEnable: ERR. targetWinGet fail\n");
+			return MV_ERROR;
+		}
+
+		/* Check for overlapping */
+		if (MV_TRUE == pciWinOverlapDetect(pciIf, bar, &barWin.addrWin))
+		
+		{   /* Overlap detected	*/
+			mvOsPrintf("mvPciTargetWinEnable: ERR. Overlap detected\n");
+			return MV_ERROR;
+		}
+		else
+		{
+			/* No Overlap. Enable address decode target window              */
+			MV_REG_BIT_RESET(PCI_BASE_ADDR_ENABLE_REG(pciIf),BARER_ENABLE(bar));
+		}
+	}
+	else
+	{
+		/* Disable address decode target window                             */
+		MV_REG_BIT_SET(PCI_BASE_ADDR_ENABLE_REG(pciIf), BARER_ENABLE(bar));
+	}
+
+	return MV_OK;
+}
+
+
+/*******************************************************************************
+* mvPciProtWinSet - Set PCI protection access window
+*
+* DESCRIPTION:
+*       This function sets a specified address window with access protection 
+*       attributes. If protection structure enables the window the routine will
+*       also enable the protection window.
+*
+* INPUT:
+*       pciIf    - PCI interface number.
+*       winNum   - Protecion window number.
+*       pProtWin - Protection window structure.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvPciProtWinSet(MV_U32 pciIf, 
+						  MV_U32 winNum, 
+                          MV_PCI_PROT_WIN *pProtWin)
+{
+	MV_U32 protBaseLow;
+	MV_U32 protBaseHigh;
+	MV_U32 protSize;
+
+	/* Parameter checking   */
+	if (pciIf >= mvCtrlPciMaxIfGet())
+	{
+		mvOsPrintf("mvPciProtWinSet: ERR. Invalid PCI interface %d\n", pciIf);
+		return MV_BAD_PARAM;
+	}
+	if (winNum >= PCI_MAX_PROT_WIN)
+	{
+		mvOsPrintf("mvPciProtWinSet: ERR. Invalid window num %d\n", winNum);
+		return MV_BAD_PARAM;
+	}
+
+	/* Check if the window complies with PCI spec							*/
+	if (MV_TRUE != pciWinIsValid(pProtWin->addrWin.baseLow, 
+                                 pProtWin->addrWin.size))
+	{
+        mvOsPrintf("mvPciProtWinSet: ERR. Win base 0x%x unaligned to size 0x%llx\n",
+                   pProtWin->addrWin.baseLow, pProtWin->addrWin.size);
+
+		return MV_BAD_PARAM;
+	}
+
+	if (pProtWin->attributes.swapType >= SWAP_TYPE_MAX)
+	{
+		mvOsPrintf("mvPciProtWinSet: ERR. Swap parameter invalid %d\n",
+					                            pProtWin->attributes.swapType);
+		return MV_BAD_PARAM;
+
+	}
+
+	/* 1) Calculate protection window base low register value	*/
+	protBaseLow  =  pProtWin->addrWin.baseLow;
+
+	/* Setting the appropriate bits according to the passed values */
+	if (MV_TRUE == pProtWin->enable) 
+	{
+		protBaseLow |= PACBLR_EN;
+	}
+	else
+	{
+		protBaseLow &= ~PACBLR_EN;
+	}
+
+	/* I/O Cache Coherency */
+	protBaseLow |= ((MV_U32)pProtWin->attributes.snoop << PACBLR_SNOOP_OFFS);
+
+	/* Access protect */
+	if (ALLOWED == pProtWin->attributes.access)
+	{
+		protBaseLow &= ~PACBLR_ACCPROT;
+	}
+	else
+	{
+		protBaseLow |= PACBLR_ACCPROT;
+	}
+
+	/* Write Protect */
+	if (ALLOWED == pProtWin->attributes.write)
+	{
+		protBaseLow &= ~PACBLR_WRPROT;
+	}
+	else
+	{
+		protBaseLow |= PACBLR_WRPROT;
+	}
+	
+	/* PCI slave Data Swap Control */
+	protBaseLow |= (pProtWin->attributes.swapType << PACBLR_PCISWAP_OFFS);
+
+
+	/* Read Max Burst */
+	if (( pciBurstBytes2Reg(pProtWin->attributes.readMaxBurst) << PACBLR_RDMBURST_OFFS) > PACBLR_RDMBURST_128BYTE)
+	{
+		mvOsPrintf("mvPciProtWinSet: ERR illigal read max burst\n");
+		return MV_ERROR;
+	}
+	protBaseLow |= (pciBurstBytes2Reg(pProtWin->attributes.readMaxBurst) << PACBLR_RDMBURST_OFFS);
+
+
+	/* Typical PCI read transaction Size. Only valid for PCI conventional */
+	if ((pciBurstBytes2Reg(pProtWin->attributes.readBurst) << PACBLR_RDSIZE_OFFS) > PACBLR_RDSIZE_256BYTE )
+	{
+		mvOsPrintf("mvPciProtWinSet: ERR. illigal read size\n");
+		return MV_ERROR;
+	}
+	protBaseLow |= (pciBurstBytes2Reg(pProtWin->attributes.readBurst) << PACBLR_RDSIZE_OFFS);
+
+
+	/* 2) Calculate protection window base high register value	*/
+	protBaseHigh =  pProtWin->addrWin.baseHigh;
+
+	/* 3) Calculate protection window size register value	*/
+	protSize     =  ctrlSizeToReg(pProtWin->addrWin.size, PACSR_SIZE_ALIGNMENT) << PACSR_SIZE_OFFS;
+    
+
+	/* Write Max Burst */
+	if ((pciBurstBytes2Reg(pProtWin->attributes.writeMaxBurst) << PACSR_WRMBURST_OFFS) > PACSR_WRMBURST_128BYTE )
+	{
+		mvOsPrintf("mvPciProtWinSet: ERR illigal write max burst\n");
+		return MV_ERROR;
+	}
+	protSize |= (pciBurstBytes2Reg(pProtWin->attributes.writeMaxBurst) << PACSR_WRMBURST_OFFS);
+
+	/* Pci Order */
+    if (MV_TRUE == pProtWin->attributes.pciOrder)
+	{
+		protSize |= PACSR_PCI_ORDERING;
+	}
+	else
+	{
+		protSize &= ~PACSR_PCI_ORDERING;
+	}
+		    
+	/* Writing protection window walues into registers */
+	MV_REG_WRITE(PCI_ACCESS_CTRL_BASEL_REG(pciIf,winNum), protBaseLow);
+	MV_REG_WRITE(PCI_ACCESS_CTRL_BASEH_REG(pciIf,winNum), protBaseHigh);
+	MV_REG_WRITE(PCI_ACCESS_CTRL_SIZE_REG(pciIf,winNum),  protSize);
+
+	return MV_OK;
+}
+/*******************************************************************************
+* mvPciProtWinGet - Get PCI protection access window
+*
+* DESCRIPTION:
+*       This function gets a specified address window and access protection 
+*       attributes for a specific protection window .
+*
+* INPUT:
+*       pciIf    - PCI interface number.
+*       winNum   - Protecion window number.
+*       pProtWin - pointer to a Protection window structure.
+*
+* OUTPUT:
+*       pProtWin - Protection window structure.
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvPciProtWinGet(MV_U32 pciIf, 
+						  MV_U32 winNum, 
+                          MV_PCI_PROT_WIN *pProtWin)
+{
+	MV_U32 protBaseLow;
+	MV_U32 protBaseHigh;
+	MV_U32 protSize;
+
+	/* Parameter checking   */
+	if (pciIf >= mvCtrlPciMaxIfGet())
+	{
+		mvOsPrintf("mvPciProtWinGet: ERR. Invalid PCI interface %d\n", pciIf);
+		return MV_BAD_PARAM;
+	}
+	if (winNum >= PCI_MAX_PROT_WIN)
+	{
+		mvOsPrintf("mvPciProtWinGet: ERR. Invalid window num %d\n", winNum);
+		return MV_BAD_PARAM;
+	}
+
+	/* Writing protection window walues into registers */
+	protBaseLow = MV_REG_READ(PCI_ACCESS_CTRL_BASEL_REG(pciIf,winNum));
+	protBaseHigh = MV_REG_READ(PCI_ACCESS_CTRL_BASEH_REG(pciIf,winNum));
+	protSize = MV_REG_READ(PCI_ACCESS_CTRL_SIZE_REG(pciIf,winNum));
+
+
+	/* 1) Get Protection Windows base low 	*/
+	pProtWin->addrWin.baseLow = protBaseLow & PACBLR_BASE_L_MASK;
+
+	/* Get the appropriate protection attributes according to register bits*/
+
+	/* Is Windows enabled ? */
+	if (protBaseLow & PACBLR_EN)
+	{
+		pProtWin->enable = MV_TRUE;
+	}
+	else
+	{
+		pProtWin->enable = MV_FALSE;
+	}
+
+
+	/* What is access protect ? */
+	if (protBaseLow & PACBLR_ACCPROT)
+	{
+		pProtWin->attributes.access = FORBIDDEN;
+	}
+	else
+	{
+		pProtWin->attributes.access = ALLOWED;
+	}
+
+	/* Is write protect ? */
+	if (protBaseLow & PACBLR_WRPROT)
+	{
+		pProtWin->attributes.write = FORBIDDEN;
+	}
+	else
+	{
+		pProtWin->attributes.write = ALLOWED;
+	}
+
+
+    	/* PCI slave Data Swap Control */
+	pProtWin->attributes.swapType = (protBaseLow & PACBLR_PCISWAP_MASK) >> PACBLR_PCISWAP_OFFS;
+
+
+	/* Read Max Burst */
+	pProtWin->attributes.readMaxBurst = pciBurstReg2Bytes((protBaseLow & PACBLR_RDMBURST_MASK) >> PACBLR_RDMBURST_OFFS);
+
+	/* Typical PCI read transaction Size. */
+	pProtWin->attributes.readBurst = pciBurstReg2Bytes((protBaseLow & PACBLR_RDSIZE_MASK) >> PACBLR_RDSIZE_OFFS);
+
+
+	/* window base high register value	*/
+	pProtWin->addrWin.baseHigh = protBaseHigh;
+
+	/*Calculate protection window size register value	*/
+	pProtWin->addrWin.size = ctrlRegToSize(((protSize & PACSR_SIZE_MASK) >> PACSR_SIZE_OFFS),PACSR_SIZE_ALIGNMENT);
+
+
+	/* Write Max Burst */
+	pProtWin->attributes.writeMaxBurst = pciBurstReg2Bytes((protSize & PACSR_WRMBURST_MASK) >> PACSR_WRMBURST_OFFS);
+
+	/* Pci Order */
+	if (protSize & PACSR_PCI_ORDERING)
+	{
+		pProtWin->attributes.pciOrder = MV_TRUE;
+	}
+	else
+	{
+		pProtWin->attributes.pciOrder = MV_FALSE;
+	}
+
+
+	return MV_OK;
+}
+
+
+/*******************************************************************************
+* mvPciProtWinEnable - Enable/disable a PCI protection access window
+*
+* DESCRIPTION:
+*       This function enable/disable a PCI protection access window.
+*       if parameter 'enable' == MV_TRUE the routine will enable the 
+*       protection window, otherwise, the protection window will be disabled.
+*
+* INPUT:
+*       pciIf  - PCI interface number.
+*       winNum - Protecion window number.
+*       enable - Enable/disable parameter.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvPciProtWinEnable(MV_U32 pciIf, MV_U32 winNum, MV_BOOL enable)
+{
+	/* Parameter checking   */
+	if (pciIf >= mvCtrlPciMaxIfGet())
+	{
+		mvOsPrintf("mvPciProtWinEnable: ERR. Invalid PCI interface %d\n", 
+																		pciIf);
+		return MV_BAD_PARAM;
+	}
+
+	if (winNum >= PCI_MAX_PROT_WIN)
+	{
+		mvOsPrintf("mvPciProtWinEnable: ERR. Invalid window num %d\n", winNum);
+		return MV_BAD_PARAM;
+	}
+
+    if (MV_TRUE == enable)
+    {
+        MV_REG_BIT_SET(PCI_ACCESS_CTRL_BASEL_REG(pciIf,winNum), PACBLR_EN);
+    }
+	else
+	{
+        MV_REG_BIT_RESET(PCI_ACCESS_CTRL_BASEL_REG(pciIf,winNum), PACBLR_EN);
+	}
+
+	return MV_OK;
+}
+
+
+/*******************************************************************************
+* mvPciTargetRemap - Set PCI to target address window remap.
+*
+* DESCRIPTION:
+*       The PCI interface supports remap of the BAR original address window.
+*       For each BAR it is possible to define a remap address. For example
+*       an address 0x12345678 that hits BAR 0x10 (SDRAM CS[0]) will be modified
+*       according to remap register but will also be targeted to the 
+*       SDRAM CS[0].
+*
+* INPUT:
+*       pciIf    - PCI interface number.
+*       bar      - Peripheral target enumerator accessed by slave.
+*       pAddrWin - Address window to be checked.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvPciTargetRemap(MV_U32 pciIf,
+						   MV_PCI_BAR bar,
+                           MV_ADDR_WIN *pAddrWin)
+{
+	PCI_BAR_REG_INFO barRegInfo;
+	
+	/* Parameter checking   */
+	if (pciIf >= mvCtrlPciMaxIfGet())
+	{
+		mvOsPrintf("mvPciTargetRemap: ERR. Invalid PCI interface num %d\n", 
+																		pciIf);
+		return MV_BAD_PARAM;
+	}
+
+	if (MV_IS_NOT_ALIGN(pAddrWin->baseLow, PBARR_REMAP_ALIGNMENT))
+	{
+		mvOsPrintf("mvPciTargetRemap: Error remapping PCI interface %d bar %s."\
+				   "\nAddress 0x%08x is unaligned to size 0x%llx.\n",
+				   pciIf,
+				   pciBarNameGet(bar),
+                   pAddrWin->baseLow,
+				   pAddrWin->size);
+		return MV_ERROR;
+	}
+
+	pciBarRegInfoGet(pciIf, bar, &barRegInfo);
+
+	/* Set remap low register value */
+	MV_REG_WRITE(barRegInfo.remapLowRegOffs, pAddrWin->baseLow);
+	
+	/* Skip base high settings if the BAR has only base low (32-bit)		*/
+	if (0 != barRegInfo.remapHighRegOffs)
+	{
+		MV_REG_WRITE(barRegInfo.remapHighRegOffs, pAddrWin->baseHigh);
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* pciWinOverlapDetect - Detect address windows overlapping
+*
+* DESCRIPTION:
+*       This function detects address window overlapping of a given address 
+*       window in PCI BARs.
+*
+* INPUT:
+*       pAddrWin - Address window to be checked.
+*       bar      - BAR to be accessed by slave.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if the given address window overlap current address
+*       decode map, MV_FALSE otherwise.
+*
+*******************************************************************************/
+static MV_BOOL pciWinOverlapDetect(MV_U32 pciIf, MV_PCI_BAR bar, MV_ADDR_WIN *pAddrWin)
+{
+	MV_U32		barEnableReg;
+	MV_U32		targetBar;
+	MV_PCI_BAR_WIN	barAddrWin;
+
+	/* Read base address enable register. Do not check disabled windows		*/
+	barEnableReg = MV_REG_READ(PCI_BASE_ADDR_ENABLE_REG(pciIf));
+	
+	for(targetBar = 0; targetBar < PCI_MAX_BARS; targetBar++) {
+	        /* don't check our target or illegal targets */
+        	if (targetBar == bar)
+            		continue;
+        
+		/* Do not check disabled windows	*/
+		if (barEnableReg & (BARER_ENABLE(targetBar)))
+			continue;
+
+		/* Get window parameters 	*/
+		if (MV_OK != mvPciTargetWinGet(pciIf, targetBar, &barAddrWin)) {
+			mvOsPrintf("pciWinOverlapDetect: ERR. TargetWinGet failed\n");
+			return MV_ERROR;
+		}
+        
+		/* skip overlapp detect between MEM_INTER_REGS_BAR and IO_INTER_REGS_BAR*/
+		if (((bar == MEM_INTER_REGS_BAR)&&(targetBar == IO_INTER_REGS_BAR)) ||
+			((bar == IO_INTER_REGS_BAR)&&(targetBar == MEM_INTER_REGS_BAR))) {
+			return MV_FALSE;
+		} else if(MV_TRUE == mvWinOverlapTest(pAddrWin, &barAddrWin.addrWin)) {                    
+			mvOsPrintf("pciWinOverlapDetect: BAR %d overlap current %d\n", bar, targetBar);
+			return MV_TRUE;           
+		}
+	}
+
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* cpuWinIsValid - Check if the given address window is valid
+*
+* DESCRIPTION:
+*		PCI spec restrict BAR base to be aligned to BAR size.
+*		This function checks if the given address window is valid.
+*
+* INPUT:
+*       baseLow - 32bit low base address.
+*       size    - Window size.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if the address window is valid, MV_FALSE otherwise.
+*
+*******************************************************************************/
+static MV_STATUS pciWinIsValid(MV_U32 baseLow, MV_U32 size)
+{
+
+	/* PCI spec restrict BAR base to be aligned to BAR size					*/
+	if(MV_IS_NOT_ALIGN(baseLow, size))
+	{
+		return MV_ERROR;
+	}
+	else
+	{
+		return MV_TRUE;
+	}
+}
+
+/*******************************************************************************
+* pciBarRegInfoGet - Get BAR register information
+*
+* DESCRIPTION:
+* 		PCI BARs registers offsets are inconsecutive. 
+*		This function gets a PCI BAR register information like register offsets
+*		and function location of the BAR.
+*
+* INPUT:
+*       pciIf - PCI interface number.
+*		bar	  - The PCI BAR in question.	
+*
+* OUTPUT:
+*       pBarRegInfo - BAR register info struct.
+*
+* RETURN:
+*		MV_BAD_PARAM when bad parameters ,MV_ERROR on error ,othewise MV_OK
+*
+*******************************************************************************/
+static MV_STATUS pciBarRegInfoGet(MV_U32 pciIf, 
+								  MV_PCI_BAR bar,
+								  PCI_BAR_REG_INFO *pBarRegInfo)
+{
+	switch (bar)
+	{
+		/* Function 0 Bars */
+		#if defined(MV_INCLUDE_SDRAM_CS0)
+		case CS0_BAR:      		/* SDRAM chip select 0 bar*/
+			pBarRegInfo->funcNum          = 0;
+			pBarRegInfo->baseLowRegOffs   = PCI_SCS0_BASE_ADDR_LOW;
+			pBarRegInfo->baseHighRegOffs  = PCI_SCS0_BASE_ADDR_HIGH;
+			pBarRegInfo->sizeRegOffs      = PCI_CS0_BAR_SIZE_REG(pciIf);
+			pBarRegInfo->remapLowRegOffs  = PCI_CS0_ADDR_REMAP_REG(pciIf);
+			pBarRegInfo->remapHighRegOffs = 0;
+			break;
+		#endif
+		#if defined(MV_INCLUDE_SDRAM_CS1)
+		case CS1_BAR:      		/* SDRAM chip select 1 bar*/
+			pBarRegInfo->funcNum          = 0;
+			pBarRegInfo->baseLowRegOffs   = PCI_SCS1_BASE_ADDR_LOW;
+			pBarRegInfo->baseHighRegOffs  = PCI_SCS1_BASE_ADDR_HIGH;
+			pBarRegInfo->sizeRegOffs      = PCI_CS1_BAR_SIZE_REG(pciIf);
+			pBarRegInfo->remapLowRegOffs  = PCI_CS1_ADDR_REMAP_REG(pciIf);
+			pBarRegInfo->remapHighRegOffs = 0;
+			break;
+		#endif
+		case MEM_INTER_REGS_BAR: /* Memory Mapped Internal bar */
+			pBarRegInfo->funcNum          = 0;
+			pBarRegInfo->baseLowRegOffs   = PCI_INTER_REG_MEM_MAPPED_BASE_ADDR_L;
+			pBarRegInfo->baseHighRegOffs  = PCI_INTER_REG_MEM_MAPPED_BASE_ADDR_H;
+			pBarRegInfo->sizeRegOffs      = 0;
+			pBarRegInfo->remapLowRegOffs  = 0;
+			pBarRegInfo->remapHighRegOffs = 0;
+			break;
+	
+		/* Function 1 Bars */
+		#if defined(MV_INCLUDE_SDRAM_CS2)
+		case CS2_BAR:      		/* SDRAM chip select 2 bar*/
+			pBarRegInfo->funcNum          = 1;
+			pBarRegInfo->baseLowRegOffs   = PCI_SCS2_BASE_ADDR_LOW;
+			pBarRegInfo->baseHighRegOffs  = PCI_SCS2_BASE_ADDR_HIGH;
+			pBarRegInfo->sizeRegOffs      = PCI_CS2_BAR_SIZE_REG(pciIf);
+			pBarRegInfo->remapLowRegOffs  = PCI_CS2_ADDR_REMAP_REG(pciIf);
+			pBarRegInfo->remapHighRegOffs = 0;
+			break;
+		#endif
+		#if defined(MV_INCLUDE_SDRAM_CS3)
+		case CS3_BAR:      		/* SDRAM chip select 3 bar*/
+			pBarRegInfo->funcNum		  = 1;
+			pBarRegInfo->baseLowRegOffs	  = PCI_SCS3_BASE_ADDR_LOW;
+			pBarRegInfo->baseHighRegOffs  = PCI_SCS3_BASE_ADDR_HIGH;
+			pBarRegInfo->sizeRegOffs	  = PCI_CS3_BAR_SIZE_REG(pciIf);
+			pBarRegInfo->remapLowRegOffs  = PCI_CS3_ADDR_REMAP_REG(pciIf);
+			pBarRegInfo->remapHighRegOffs = 0;
+			break;
+		#endif
+		#if defined(MV_INCLUDE_DEVICE_CS0) 
+		/* Function 2 Bars */
+		case DEVCS0_BAR:     	/* Device chip select 0 bar*/
+			pBarRegInfo->funcNum		  = 2;
+			pBarRegInfo->baseLowRegOffs	  = PCI_DEVCS0_BASE_ADDR_LOW;
+			pBarRegInfo->baseHighRegOffs  = PCI_DEVCS0_BASE_ADDR_HIGH;
+			pBarRegInfo->sizeRegOffs	  = PCI_DEVCS0_BAR_SIZE_REG(pciIf);
+			pBarRegInfo->remapLowRegOffs  = PCI_DEVCS0_ADDR_REMAP_REG(pciIf);
+			pBarRegInfo->remapHighRegOffs = 0;
+			break;
+		#endif
+		#if defined(MV_INCLUDE_DEVICE_CS1) 
+		case DEVCS1_BAR:     	/* Device chip select 0 bar*/
+			pBarRegInfo->funcNum		  = 2;
+			pBarRegInfo->baseLowRegOffs	  = PCI_DEVCS1_BASE_ADDR_LOW;
+			pBarRegInfo->baseHighRegOffs  = PCI_DEVCS1_BASE_ADDR_HIGH;
+			pBarRegInfo->sizeRegOffs	  = PCI_DEVCS1_BAR_SIZE_REG(pciIf);
+			pBarRegInfo->remapLowRegOffs  = PCI_DEVCS1_ADDR_REMAP_REG(pciIf);
+			pBarRegInfo->remapHighRegOffs = 0;
+			break;
+		#endif
+		#if defined(MV_INCLUDE_DEVICE_CS2) 
+		case DEVCS2_BAR:     	/* Device chip select 0 bar*/
+			pBarRegInfo->funcNum		  = 2;
+			pBarRegInfo->baseLowRegOffs	  = PCI_DEVCS2_BASE_ADDR_LOW;
+			pBarRegInfo->baseHighRegOffs  = PCI_DEVCS2_BASE_ADDR_HIGH;
+			pBarRegInfo->sizeRegOffs	  = PCI_DEVCS2_BAR_SIZE_REG(pciIf);
+			pBarRegInfo->remapLowRegOffs  = PCI_DEVCS2_ADDR_REMAP_REG(pciIf);
+			pBarRegInfo->remapHighRegOffs = 0;
+			break;
+		#endif
+		case BOOTCS_BAR:      	/* Boot device chip select bar*/
+			pBarRegInfo->funcNum		  = 3;
+			pBarRegInfo->baseLowRegOffs	  = PCI_BOOTCS_BASE_ADDR_LOW;
+			pBarRegInfo->baseHighRegOffs  = PCI_BOOTCS_BASE_ADDR_HIGH;
+			pBarRegInfo->sizeRegOffs	  = PCI_BOOTCS_BAR_SIZE_REG(pciIf);
+			pBarRegInfo->remapLowRegOffs  = PCI_BOOTCS_ADDR_REMAP_REG(pciIf);
+			pBarRegInfo->remapHighRegOffs = 0;
+			break;
+	
+		/* Function 4 Bars */
+		case P2P_MEM0:      		/* P2P memory 0 */
+			pBarRegInfo->funcNum		  = 4;
+			pBarRegInfo->baseLowRegOffs	  = PCI_P2P_MEM0_BASE_ADDR_LOW;
+			pBarRegInfo->baseHighRegOffs  = PCI_P2P_MEM0_BASE_ADDR_HIGH;
+			pBarRegInfo->sizeRegOffs	  = PCI_P2P_MEM0_BAR_SIZE_REG(pciIf);
+			pBarRegInfo->remapLowRegOffs  = PCI_P2P_MEM0_ADDR_REMAP_LOW_REG(pciIf);
+			pBarRegInfo->remapHighRegOffs = PCI_P2P_MEM0_ADDR_REMAP_HIGH_REG(pciIf);
+			break;
+		case P2P_IO:        		/* P2P IO */
+			pBarRegInfo->funcNum		  = 4;
+			pBarRegInfo->baseLowRegOffs   = PCI_P2P_IO_BASE_ADDR;
+			pBarRegInfo->baseHighRegOffs  = 0;
+			pBarRegInfo->sizeRegOffs	  = PCI_P2P_IO_BAR_SIZE_REG(pciIf);
+			pBarRegInfo->remapLowRegOffs  = PCI_P2P_IO_ADDR_REMAP_REG(pciIf);
+			pBarRegInfo->remapHighRegOffs = 0;
+			break;
+		case IO_INTER_REGS_BAR: /* IO Mapped Internal bar */
+			pBarRegInfo->funcNum		  = 4;
+			pBarRegInfo->baseLowRegOffs	  = PCI_INTER_REGS_IO_MAPPED_BASE_ADDR;
+			pBarRegInfo->baseHighRegOffs  = 0;
+			pBarRegInfo->sizeRegOffs	  = 0;
+			pBarRegInfo->remapLowRegOffs  = 0;
+			pBarRegInfo->remapHighRegOffs = 0;
+			break;
+	
+	
+		default: 
+			mvOsPrintf("mvPciTargetWinGet: ERR.non existing target\n");
+			return MV_ERROR;
+
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* pciBarNameGet - Get the string name of PCI BAR.
+*
+* DESCRIPTION:
+*		This function get the string name of PCI BAR.
+*
+* INPUT:
+*       bar - PCI bar number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       pointer to the string name of PCI BAR.
+*
+*******************************************************************************/
+const MV_8* pciBarNameGet( MV_PCI_BAR bar )
+{
+	switch( bar ) 
+	{
+	#if defined(MV_INCLUDE_SDRAM_CS0)
+		case CS0_BAR: 
+			return "CS0_BAR..............";
+	#endif
+	#if defined(MV_INCLUDE_SDRAM_CS1)
+		case CS1_BAR: 
+			return "CS1_BAR..............";
+	#endif
+	#if defined(MV_INCLUDE_SDRAM_CS2)
+		case CS2_BAR: 
+			return "CS2_BAR..............";
+	#endif
+	#if defined(MV_INCLUDE_SDRAM_CS3)
+		case CS3_BAR: 
+			return "CS3_BAR..............";
+	#endif
+	#if defined(MV_INCLUDE_DEVICE_CS0)
+		case DEVCS0_BAR: 
+			return "DEVCS0_BAR...........";
+	#endif
+	#if defined(MV_INCLUDE_DEVICE_CS1)
+		case DEVCS1_BAR: 
+			return "DEVCS1_BAR...........";
+	#endif
+	#if defined(MV_INCLUDE_DEVICE_CS2)
+		case DEVCS2_BAR: 
+			return "DEVCS2_BAR...........";
+	#endif
+		case BOOTCS_BAR: 
+			return "BOOTCS_BAR...........";
+		case MEM_INTER_REGS_BAR: 
+			return "MEM_INTER_REGS_BAR...";
+		case IO_INTER_REGS_BAR: 
+			return "IO_INTER_REGS_BAR....";
+		case P2P_MEM0: 
+			return "P2P_MEM0.............";
+		case P2P_IO: 
+			return "P2P_IO...............";
+		default:
+			 return "target unknown";
+	}
+}
+
+/*******************************************************************************
+* mvPciAddrDecShow - Print the PCI address decode map (BARs).
+*
+* DESCRIPTION:
+*		This function print the PCI address decode map (BARs).
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvPciAddrDecShow(MV_VOID)
+{
+	MV_PCI_BAR_WIN win;
+	MV_PCI_BAR bar;
+	MV_U32 pciIf;
+
+	for( pciIf = 0; pciIf < mvCtrlPciMaxIfGet(); pciIf++ )
+	{ 
+		mvOsOutput( "\n" );
+		mvOsOutput( "PCI%d:\n", pciIf );
+		mvOsOutput( "-----\n" );
+
+		for( bar = 0; bar < PCI_MAX_BARS; bar++ ) 
+		{
+			memset( &win, 0, sizeof(MV_PCI_BAR_WIN) );
+
+			mvOsOutput( "%s ", pciBarNameGet(bar) );
+
+			if( mvPciTargetWinGet( pciIf, bar, &win ) == MV_OK )
+			{
+				if( win.enable )
+				{
+                    mvOsOutput( "base %08x, ", win.addrWin.baseLow );
+                    mvSizePrint( win.addrWin.size );
+                    mvOsOutput( "\n" );
+				}
+				else
+					mvOsOutput( "disable\n" );
+			}
+		}
+	}	
+}
+
+/* convert burst bytes to register value*/
+static MV_U32 pciBurstBytes2Reg(MV_U32 size)
+{
+        MV_U32 ret;
+        switch(size)
+        {
+                case 32: ret = 0; break;
+                case 64: ret = 1; break;
+                case 128: ret = 2; break;
+                case 256: ret = 3; break;
+                default: ret = 0xF; /* error */
+        }
+        return ret;
+}
+
+/* convert register value to burst bytes*/
+static MV_U32 pciBurstReg2Bytes(MV_U32 size)
+{
+        MV_U32 ret;
+        switch(size)
+        {
+                case 0: ret = 32; break;
+                case 1: ret = 64; break;
+                case 2: ret = 128; break;
+                case 3: ret = 256; break;
+                default: ret = 0x0; /* error */
+        }
+        return ret;
+}
+
diff --git a/arch/arm/mach-avantalp/mv_hal_if/mvSysPci.h b/arch/arm/mach-avantalp/mv_hal_if/mvSysPci.h
new file mode 100644
index 0000000..9f58f04
--- /dev/null
+++ b/arch/arm/mach-avantalp/mv_hal_if/mvSysPci.h
@@ -0,0 +1,256 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell 
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File in accordance with the terms and conditions of the General 
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
+available along with the File in the license.txt file or by writing to the Free 
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
+DISCLAIMED.  The GPL License provides additional details about this warranty 
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or 
+modify this File under the following licensing terms. 
+Redistribution and use in source and binary forms, with or without modification, 
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer. 
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution. 
+
+    *   Neither the name of Marvell nor the names of its contributors may be 
+        used to endorse or promote products derived from this software without 
+        specific prior written permission. 
+    
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCSysPCIH
+#define __INCSysPCIH
+
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "pci/mvPci.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+#include "mvSysPciConfig.h"
+
+#define PCI_MAX_PROT_WIN			6
+
+/* 4KB granularity */
+#define MINIMUM_WINDOW_SIZE     		0x1000
+#define MINIMUM_BAR_SIZE        		0x1000
+#define MINIMUM_BAR_SIZE_MASK			0xFFFFF000
+#define BAR_SIZE_OFFS				12
+#define BAR_SIZE_MASK				(0xFFFFF << BAR_SIZE_OFFS)
+
+#define PCI_IO_WIN_NUM          		1   /* Number of PCI_IO windows  */
+#define PCI_MEM_WIN_NUM         		4   /* Number of PCI_MEM windows */
+
+#ifndef MV_ASMLANGUAGE
+#include "ctrlEnv/mvCtrlEnvLib.h"
+typedef enum _mvPCIBars
+{
+	PCI_BAR_TBL_TERM = -1, /* none valid bar, used as bars list terminator */
+#if defined(MV_INCLUDE_SDRAM_CS0)
+	CS0_BAR,
+#endif	
+#if defined(MV_INCLUDE_SDRAM_CS1)
+	CS1_BAR,
+#endif	      		
+#if defined(MV_INCLUDE_SDRAM_CS2)
+	CS2_BAR,
+#endif
+#if defined(MV_INCLUDE_SDRAM_CS3)
+	CS3_BAR,
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS0)          		
+	DEVCS0_BAR,
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS1)          		
+	DEVCS1_BAR,
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS2)          		
+	DEVCS2_BAR,
+#endif
+	BOOTCS_BAR,      	/* Boot device chip select bar*/
+	MEM_INTER_REGS_BAR, 	/* Memory Mapped Internal bar */
+	IO_INTER_REGS_BAR,	/* IO Mapped Internal bar */
+	P2P_MEM0,      		/* P2P memory 0 */
+	P2P_IO,        		/* P2P IO */
+	PCI_MAX_BARS
+}MV_PCI_BAR;
+#endif /* MV_ASMLANGUAGE */
+
+#if defined(MV_INCLUDE_SDRAM_CS3)
+#define MV_PCI_BAR_IS_DRAM_BAR(bar) 		((bar >= CS0_BAR) && (bar <= CS3_BAR))
+#elif defined(MV_INCLUDE_SDRAM_CS2)
+#define MV_PCI_BAR_IS_DRAM_BAR(bar)		((bar >= CS0_BAR) && (bar <= CS2_BAR))
+#elif defined(MV_INCLUDE_SDRAM_CS1)
+#define MV_PCI_BAR_IS_DRAM_BAR(bar)		((bar >= CS0_BAR) && (bar <= CS1_BAR))
+#elif defined(MV_INCLUDE_SDRAM_CS0)
+#define MV_PCI_BAR_IS_DRAM_BAR(bar)		((bar == CS0_BAR))
+#endif
+
+
+/****************************************/
+/* PCI Slave Address Decoding registers */
+/****************************************/
+#define PCI_CS0_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c08 + ((pciIf) * 0x80))
+#define PCI_CS1_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d08 + ((pciIf) * 0x80))
+#define PCI_CS2_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c0c + ((pciIf) * 0x80))
+#define PCI_CS3_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d0c + ((pciIf) * 0x80))
+#define PCI_DEVCS0_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c10 + ((pciIf) * 0x80))
+#define PCI_DEVCS1_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d10 + ((pciIf) * 0x80))
+#define PCI_DEVCS2_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d18 + ((pciIf) * 0x80))
+#define PCI_BOOTCS_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d14 + ((pciIf) * 0x80))
+#define PCI_P2P_MEM0_BAR_SIZE_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d1c + ((pciIf) * 0x80))
+#define PCI_P2P_IO_BAR_SIZE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d24 + ((pciIf) * 0x80))
+#define PCI_EXPAN_ROM_BAR_SIZE_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d2c + ((pciIf) * 0x80)) 
+#define PCI_BASE_ADDR_ENABLE_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c3c + ((pciIf) * 0x80)) 
+#define PCI_CS0_ADDR_REMAP_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c48 + ((pciIf) * 0x80)) 
+#define PCI_CS1_ADDR_REMAP_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d48 + ((pciIf) * 0x80)) 
+#define PCI_CS2_ADDR_REMAP_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c4c + ((pciIf) * 0x80)) 
+#define PCI_CS3_ADDR_REMAP_REG(pciIf)		(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d4c + ((pciIf) * 0x80)) 
+#define PCI_DEVCS0_ADDR_REMAP_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c50 + ((pciIf) * 0x80)) 
+#define PCI_DEVCS1_ADDR_REMAP_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d50 + ((pciIf) * 0x80)) 
+#define PCI_DEVCS2_ADDR_REMAP_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d58 + ((pciIf) * 0x80)) 
+#define PCI_BOOTCS_ADDR_REMAP_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d54 + ((pciIf) * 0x80)) 
+#define PCI_P2P_MEM0_ADDR_REMAP_LOW_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d5c + ((pciIf) * 0x80)) 
+#define PCI_P2P_MEM0_ADDR_REMAP_HIGH_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d60 + ((pciIf) * 0x80)) 
+#define PCI_P2P_IO_ADDR_REMAP_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d6c + ((pciIf) * 0x80)) 
+#define PCI_EXPAN_ROM_ADDR_REMAP_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0f38 + ((pciIf) * 0x80))
+#define PCI_DRAM_BAR_BANK_SELECT_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0c1c + ((pciIf) * 0x80))
+#define PCI_ADDR_DECODE_CONTROL_REG(pciIf)	(MV_PCI_IF_REGS_BASE(pciIf) + 0x0d3c + ((pciIf) * 0x80))
+
+/* PCI Bars Size Registers (PBSR) */
+#define PBSR_SIZE_OFFS				12
+#define PBSR_SIZE_MASK				(0xfffff << PBSR_SIZE_OFFS)
+
+/* Base Address Registers Enable Register (BARER) */
+#define BARER_ENABLE(target)			(1 << (target))
+
+/* PCI Base Address Remap Registers (PBARR) */
+#define PBARR_REMAP_OFFS			12
+#define PBARR_REMAP_MASK			(0xfffff << PBARR_REMAP_OFFS)
+#define PBARR_REMAP_ALIGNMENT			(1 << PBARR_REMAP_OFFS)
+
+/* PCI DRAM Bar Bank Select Register (PDBBSR) */
+#define PDBBSR_DRAM_BANK_OFFS(bank)		((bank) * 2)
+#define PDBBSR_DRAM_BANK_MASK(bank)		(0x3 << PDBBSR_DRAM_BANK_OFFS(bank))
+
+/* PCI Address Decode Control Register (PADCR)*/
+#define PADCR_REMAP_REG_WR_DIS			BIT0
+#define PADCR_MSG_REG_ACC			BIT3
+
+#define PADCR_VPD_HIGH_ADDR_OFFS		8 /* Bits [31:15] of the VPD address */
+#define PADCR_VPD_HIGH_ADDR_MASK		(0x1ffff << PADCR_VPD_HIGH_ADDR_OFFS)
+
+/* PCI Headers Retarget Control Register (PHRCR) */
+#define PHRCR_ENABLE				BIT0
+#define PHRCR_BUFF_SIZE_OFFS			1 
+#define PHRCR_BUFF_SIZE_MASK			(0x7 << PHRCR_BUFF_SIZE_OFFS)
+#define PHRCR_BUFF_SIZE_258BYTE			(0x0 << PHRCR_BUFF_SIZE_OFFS)
+#define PHRCR_BUFF_SIZE_512BYTE			(0x1 << PHRCR_BUFF_SIZE_OFFS)
+#define PHRCR_BUFF_SIZE_1KB			(0x2 << PHRCR_BUFF_SIZE_OFFS)
+#define PHRCR_BUFF_SIZE_2KB			(0x3 << PHRCR_BUFF_SIZE_OFFS)
+#define PHRCR_BUFF_SIZE_4KB			(0x4 << PHRCR_BUFF_SIZE_OFFS)
+#define PHRCR_BUFF_SIZE_8KB			(0x5 << PHRCR_BUFF_SIZE_OFFS)
+#define PHRCR_MASK1_OFFS			16
+#define PHRCR_MASK1_MASK			(0xffff << PHRCR_MASK1_OFFS)
+
+/* PCI Headers Retarget Base Register (PHRBR) */
+#define PHRBR_BASE_OFFS				16
+#define PHRBR_BASE_MASK				(0xffff << PHRBR_BASE_OFFS)
+
+/* PCI Headers Retarget Base High Register (PHRBHR) */
+#define PHRBHR_BASE_OFFS			0
+#define PHRBHR_BASE_MASK			(0xffffffff << PHRBHR_BASE_OFFS)
+
+/* This structure describes a PCI BAR. It is also refered as PCI target     */
+/* window to keep consistency with other address decode units in the system */
+typedef struct _mvPciBarWin 
+{
+    MV_ADDR_WIN		addrWin;	/* Address window       */
+    MV_BOOL     	enable;		/* BAR enable/disable   */
+}MV_PCI_BAR_WIN;
+
+typedef enum
+{
+    NO_CACHE_COHER = 0,
+    WT_CACHE_COHER,
+    WB_CACHE_COHER
+}MV_PCI_SNOOP;
+
+/* This structure describes PCI region attributes                           */
+typedef struct _mvPciRegionAttr
+{
+    MV_PCI_SNOOP	snoop;		/* Cache Coherenc			*/
+    MV_PROT_RIGHT	access;         /* Access protection                    */
+    MV_PROT_RIGHT	write;          /* Write protection                     */
+    MV_SWAP_TYPE	swapType;       /* Data swap mode for that region       */
+    MV_U32		readMaxBurst;   /* Read max burst                       */
+    MV_U32		readBurst;      /* Read burst. Conventional PCI only    */
+    MV_U32		writeMaxBurst;  /* Write max burst                      */
+    MV_BOOL		pciOrder;       /* Hardware support for PCI ordering    */
+}MV_PCI_REGION_ATTR;
+
+/* The PCI slave interface supports configurable access control.            */
+/* It is possible to define up to six address ranges to different           */
+/* configurations. This structure describes the PCI access region           */
+typedef struct _mvPciProtWin
+{
+    MV_ADDR_WIN         addrWin;	/* An address window                    */
+    MV_PCI_REGION_ATTR  attributes;	/* Window attributes                    */
+    MV_BOOL             enable;		/* Window enabled/disabled              */
+}MV_PCI_PROT_WIN;
+
+/* Global Functions prototypes */
+MV_STATUS mvPciInit(MV_U32 pciIf, MV_PCI_MOD pciIfmod);
+MV_STATUS mvPciTargetWinSet(MV_U32 pciIf, MV_PCI_BAR slaveTarget, MV_PCI_BAR_WIN *pAddrBarWin);
+MV_STATUS mvPciTargetWinGet(MV_U32 pciIf, MV_PCI_BAR slaveTarget, MV_PCI_BAR_WIN *pAddrBarWin);
+MV_STATUS mvPciTargetWinEnable(MV_U32 pciIf,MV_PCI_BAR slaveTarget, MV_BOOL enable);
+MV_STATUS mvPciProtWinSet(MV_U32 pciIf, MV_U32 winNum, MV_PCI_PROT_WIN *pProtWin);
+MV_STATUS mvPciProtWinGet(MV_U32 pciIf, MV_U32 winNum, MV_PCI_PROT_WIN *pProtWin);
+MV_STATUS mvPciProtWinEnable(MV_U32 pciIf, MV_U32 winNum, MV_BOOL enable);
+MV_STATUS mvPciTargetRemap(MV_U32 pciIf, MV_PCI_BAR slaveTarget, MV_ADDR_WIN *pAddrWin);
+MV_VOID   mvPciAddrDecShow(MV_VOID);
+
+#endif
diff --git a/arch/arm/mach-avantalp/mv_hal_if/mvSysPex.c b/arch/arm/mach-avantalp/mv_hal_if/mvSysPex.c
new file mode 100644
index 0000000..e04ed71
--- /dev/null
+++ b/arch/arm/mach-avantalp/mv_hal_if/mvSysPex.c
@@ -0,0 +1,106 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "pex/mvPex.h"
+#include "pex/mvPexRegs.h"
+
+MV_STATUS mvPexTargetWinGet(MV_U32 pexIf, MV_U32 winNum, MV_PEX_DEC_WIN *pAddrDecWin);
+
+
+/*******************************************************************************
+* mvSysPexInit - Initialize the Pex subsystem
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_STATUS mvSysPexInit(MV_U32 pexIf, MV_PEX_TYPE pexType)
+{
+	MV_PEX_HAL_DATA halData;
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_STATUS status;
+
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+	if(status == MV_OK)
+		status = mvPexWinInit(pexIf, pexType, addrWinMap);
+
+	if(status == MV_OK) {
+		halData.ctrlModel = mvCtrlModelGet();
+		halData.maxPexIf = mvCtrlPexMaxIfGet();
+		status = mvPexInit(pexIf, pexType, &halData);
+	}
+
+	return status;
+}
+
diff --git a/arch/arm/mach-avantalp/mv_hal_if/mvSysPexApi.h b/arch/arm/mach-avantalp/mv_hal_if/mvSysPexApi.h
new file mode 100644
index 0000000..1b6a6bf
--- /dev/null
+++ b/arch/arm/mach-avantalp/mv_hal_if/mvSysPexApi.h
@@ -0,0 +1,71 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_PEX_API_H__
+#define __MV_SYS_PEX_API_H__
+
+
+MV_STATUS mvSysPexInit(MV_U32 pexIf, MV_PEX_TYPE pexType);
+
+#endif
diff --git a/arch/arm/mach-avantalp/mv_hal_if/mvSysSFlash.c b/arch/arm/mach-avantalp/mv_hal_if/mvSysSFlash.c
new file mode 100644
index 0000000..2b84d9c
--- /dev/null
+++ b/arch/arm/mach-avantalp/mv_hal_if/mvSysSFlash.c
@@ -0,0 +1,226 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "spi/mvSpi.h"
+#include "spi/mvSpiCmnd.h"
+#include "sflash/mvSysSFlash.h"
+
+#define MV_SYS_SFLASH_MAX_CMD_LEN 4
+
+static struct {
+	MV_U8 buf[MV_SYS_SFLASH_MAX_CMD_LEN];
+	MV_U32 bufLen;
+	MV_U8  transType;
+} mvSysSflashCmd;
+
+/*******************************************************************************
+* mvSysSflashCommandSet
+*
+* DESCRIPTION:
+*	System interface for sending a command to the SPI flash.
+*
+* INPUT:
+*       flashHandle: Handle passed by OS glue by which an SPI flash is
+*		     identified.
+*      	cmdBuff:     Command data to be written.
+*	cmdLen:	     Command length in bytes.
+*	transType:   Bitmask describing the transaction type, see 
+*		     SYS_SFLASH_TRANS_XX for details.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysSflashCommandSet(MV_VOID *flashHandle, MV_U8* cmdBuff, MV_U32 cmdLen,
+		MV_U8 transType)
+{
+	if (cmdLen > MV_SYS_SFLASH_MAX_CMD_LEN)
+		return MV_ERROR;
+
+	if (!(transType & SYS_SFLASH_TRANS_START) || (mvSysSflashCmd.transType != 0))
+		return MV_ERROR;	
+
+	mvSpiParamsSet(0, 0, SPI_TYPE_FLASH);
+
+	memcpy(mvSysSflashCmd.buf,cmdBuff,cmdLen);	
+	mvSysSflashCmd.bufLen = cmdLen;
+	mvSysSflashCmd.transType = transType;
+
+	if (transType & SYS_SFLASH_TRANS_END)
+		return mvSysSflashDataWrite(flashHandle, NULL, 0, transType);
+
+	return MV_OK;
+}
+
+
+/*******************************************************************************
+* mvSysSflashDataRead
+*
+* DESCRIPTION:
+*	System interface for reading SPI flash data.
+*
+* INPUT:
+*       flashHandle: Handle passed by OS glue by which an SPI flash is
+*		     identified.
+*	dataBuff:    Buffer to read the data into.
+*	dataLen:     Number of bytes to read.
+*	dummyBytes:  Number of dummy bytes to read before reading the real
+*		     data.
+*	transType:   Bitmask describing the transaction type, see 
+*		     SYS_SFLASH_TRANS_XX for details.
+*
+* OUTPUT:
+*	dataBuff: The data as read from flash.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysSflashDataRead(MV_VOID *flashHandle, MV_U8* dataBuff, MV_U32 dataLen,
+		MV_U32 dummyBytes, MV_U8 transType)
+{
+	MV_STATUS  ret;	
+
+	if (!(mvSysSflashCmd.transType & SYS_SFLASH_TRANS_START))
+		return MV_ERROR;
+
+
+	ret = mvSpiWriteThenRead (0, mvSysSflashCmd.buf, mvSysSflashCmd.bufLen,
+			dataBuff, dataLen, dummyBytes);
+	if (transType & SYS_SFLASH_TRANS_END)
+		memset(&mvSysSflashCmd,0,sizeof(mvSysSflashCmd));
+	return ret;
+}
+
+
+/*******************************************************************************
+* mvSysSflashDataWrite
+*
+* DESCRIPTION:
+*	System interface for writing SPI flash data.
+*
+* INPUT:
+*       flashHandle: Handle passed by OS glue by which an SPI flash is
+*		     identified.
+*	dataBuff:    Buffer holding the data to be written.
+*	dataLen:     Number of bytes to write.
+*	transType:   Bitmask describing the transaction type, see 
+*		     SYS_SFLASH_TRANS_XX for details.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysSflashDataWrite(MV_VOID *flashHandle, MV_U8* dataBuff, MV_U32 dataLen,
+		MV_U8 transType)
+{
+	MV_STATUS ret;
+
+	if (!(mvSysSflashCmd.transType & SYS_SFLASH_TRANS_START))
+		return MV_ERROR;
+
+	ret = mvSpiWriteThenWrite (0, mvSysSflashCmd.buf, mvSysSflashCmd.bufLen, dataBuff, dataLen);
+	if (transType & SYS_SFLASH_TRANS_END)
+		memset(&mvSysSflashCmd,0,sizeof(mvSysSflashCmd));
+	return ret;
+}
+
+
+/*******************************************************************************
+* mvSysSflashFreqSet
+*
+* DESCRIPTION:
+*	System interface for controlling the SPI interface frequency.
+*
+* INPUT:
+*       flashHandle: Handle passed by OS glue by which an SPI flash is
+*		     identified.
+*	freq:	     The new frequency to be configured for the SPI IF.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysSflashFreqSet(MV_VOID *flashHandle, MV_U32 freq)
+{
+
+	return mvSpiBaudRateSet(0, freq);
+}
+
diff --git a/arch/arm/mach-avantalp/mv_hal_if/mvSysSata.c b/arch/arm/mach-avantalp/mv_hal_if/mvSysSata.c
new file mode 100644
index 0000000..a0317c9
--- /dev/null
+++ b/arch/arm/mach-avantalp/mv_hal_if/mvSysSata.c
@@ -0,0 +1,82 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "sata/CoreDriver/mvSata.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+
+MV_STATUS mvSysSataWinInit(MV_VOID)
+{
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_STATUS status;
+
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+	if(status == MV_OK)
+		status = mvSataWinInit(addrWinMap);
+
+	return status;
+}
+
diff --git a/arch/arm/mach-avantalp/mv_hal_if/mvSysSataApi.h b/arch/arm/mach-avantalp/mv_hal_if/mvSysSataApi.h
new file mode 100644
index 0000000..575a8d6
--- /dev/null
+++ b/arch/arm/mach-avantalp/mv_hal_if/mvSysSataApi.h
@@ -0,0 +1,71 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_SATA_API_H__
+#define __MV_SYS_SATA_API_H__
+
+MV_STATUS mvSysSataWinInit(MV_VOID);
+
+#endif 
+
diff --git a/arch/arm/mach-avantalp/mv_hal_if/mvSysSpi.c b/arch/arm/mach-avantalp/mv_hal_if/mvSysSpi.c
new file mode 100644
index 0000000..b407634
--- /dev/null
+++ b/arch/arm/mach-avantalp/mv_hal_if/mvSysSpi.c
@@ -0,0 +1,126 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "spi/mvSpi.h"
+#include "spi/mvSysSpi.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+
+
+/*******************************************************************************
+* mvSysSpiInit - Initialize the SPI subsystem
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_STATUS   mvSysSpiInit(MV_U8 spiId, MV_U32 serialBaudRate)
+{
+	MV_SPI_HAL_DATA halData;
+
+	halData.ctrlModel = mvCtrlModelGet();
+	halData.tclk = mvBoardTclkGet();
+
+	return mvSpiInit(spiId, serialBaudRate, &halData);
+}
+
+
+/*******************************************************************************
+* mvSysSpiMppConfig
+*
+* DESCRIPTION:
+*	System interface for configuring the MPP's configuration to enable /
+*	disable SPI mode.
+*
+* INPUT:
+*      	mode:	The mode to be set into MPP unit.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysSpiMppConfig(MV_U8 mode)
+{
+#if 0
+	if(mode == SYS_SPI_MPP_ENABLE)
+		mvMPPConfigToSPI();
+	else
+		mvMPPConfigToDefault();
+#endif
+	return MV_OK;
+}
+
diff --git a/arch/arm/mach-avantalp/mv_hal_if/mvSysSpiApi.h b/arch/arm/mach-avantalp/mv_hal_if/mvSysSpiApi.h
new file mode 100644
index 0000000..80888c0
--- /dev/null
+++ b/arch/arm/mach-avantalp/mv_hal_if/mvSysSpiApi.h
@@ -0,0 +1,70 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_SPI_API_H__
+#define __MV_SYS_SPI_API_H__
+
+MV_STATUS   mvSysSpiInit(MV_U8 spi_id, MV_U32 serialBaudRate);
+
+#endif
diff --git a/arch/arm/mach-avantalp/mv_hal_if/mvSysTdm.c b/arch/arm/mach-avantalp/mv_hal_if/mvSysTdm.c
new file mode 100644
index 0000000..83c9d59
--- /dev/null
+++ b/arch/arm/mach-avantalp/mv_hal_if/mvSysTdm.c
@@ -0,0 +1,236 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#ifdef CONFIG_MV_TDM_SUPPORT
+#include "voiceband/tdm/mvTdm.h"
+#else
+ #include "voiceband/commUnit/mvCommUnit.h"
+ #include "gpp/mvGpp.h"
+#endif
+#include "voiceband/mvSysTdmSpi.h"
+#include "spi/mvSpiCmnd.h"
+#include "spi/mvSpi.h"
+
+#define MAX_DATA_LENGTH		255
+
+/*******************************************************************************
+* mvSysTdmInit - Initialize the TDM subsystem
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_STATUS mvSysTdmInit(MV_TDM_PARAMS* tdmParams)
+{
+	MV_TDM_HAL_DATA halData;
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_STATUS status;
+
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+	if(status == MV_OK)
+#ifdef MV_TDM_SUPPORT
+		status = mvTdmWinInit(addrWinMap);
+#else
+		status = mvCommUnitWinInit(addrWinMap);
+#endif
+
+	if(status == MV_OK) {
+		halData.spiMode = mvBoardTdmSpiModeGet();
+		halData.model = mvCtrlModelGet();
+#ifdef MV_TDM_SUPPORT
+		status = mvTdmHalInit (tdmParams, &halData);
+#else
+		halData.maxCs = mvBoardTdmDevicesCountGet();
+		status = mvCommUnitHalInit (tdmParams, &halData);
+		
+		/* Issue SLIC reset */
+		mvGppValueSet(0, BIT24, 0);
+		mvOsDelay(1);
+		mvGppValueSet(0, BIT24, BIT24);
+#endif
+	}
+
+	return status;
+}
+
+MV_VOID mvSysTdmSpiRead(MV_U16 lineId, MV_U8* cmdBuff, MV_U8 cmdSize, MV_U8* dataBuff, MV_U8 dataSize)
+{
+#if defined(MV_TDM_SUPPORT) && !defined(ZARLINK_SLIC_SUPPORT)
+
+	if((cmdSize > 4) || (dataSize > MAX_DATA_LENGTH))
+	{
+		mvOsPrintf("Error, exceeded max size of command(%d) or data(%d)\n", cmdSize, dataSize);
+		return;
+	}
+
+	mvTdmSpiRead(cmdBuff, cmdSize, dataBuff, dataSize, lineId);
+
+#else /* MV_COMM_UNIT_SUPPORT || ZARLINK_SLIC_SUPPORT */
+
+	/* Set SPI parameters(lineId = devId) */
+	mvSpiParamsSet(0, mvBoardTdmSpiCsGet(lineId), SPI_TYPE_SLIC);
+	
+	if(MV_OK != mvSpiWriteThenRead (0, cmdBuff, cmdSize, dataBuff, dataSize, 0))
+		printk("SPI read failed !!!\n");
+
+#endif /* MV_TDM_SUPPORT */
+}
+
+/*******************************************************************************
+* mvSysTdmSpiWrite - telephony register write via SPI interface
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvSysTdmSpiWrite(MV_U16 lineId, MV_U8* cmdBuff, MV_U8 cmdSize, MV_U8* dataBuff, MV_U8 dataSize)
+{
+#if defined(MV_TDM_SUPPORT) && !defined(ZARLINK_SLIC_SUPPORT)
+
+	if((cmdSize > 3) || (dataSize > MAX_DATA_LENGTH))
+	{
+		mvOsPrintf("Error, exceeded max size of command(%d) or data(%d)\n", cmdSize, dataSize);
+		return;
+	}
+
+	mvTdmSpiWrite(cmdBuff, cmdSize, dataBuff, dataSize, lineId);
+
+#else /* MV_COMM_UNIT_SUPPORT || ZARLINK_SLIC_SUPPORT */
+	
+	/* Set SPI parameters(lineId = devId) */
+	mvSpiParamsSet(0, mvBoardTdmSpiCsGet(lineId), SPI_TYPE_SLIC);
+
+	if(MV_OK != mvSpiWriteThenWrite (0, cmdBuff, cmdSize, dataBuff, dataSize))
+		printk("SPI write failed !!!\n");
+
+#endif /* MV_TDM_SUPPORT */
+}
+
+/*******************************************************************************
+* mvSysTdmIntEnable - Enable CSLAC device interrupts. 
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       Device ID
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvSysTdmIntEnable(MV_U8 deviceId)
+{
+#if defined(MV_TDM_SUPPORT)
+
+	mvTdmIntEnable();
+
+#else /* MV_COMM_UNIT_SUPPORT */
+
+	mvCommUnitIntEnable(deviceId);
+
+#endif
+}
+
+/*******************************************************************************
+* mvSysTdmIntDisable - Disable CSLAC device interrupts. 
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       Device ID
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvSysTdmIntDisable(MV_U8 deviceId)
+{
+#if defined(MV_TDM_SUPPORT)
+
+	mvTdmIntDisable();
+
+#else /* MV_COMM_UNIT_SUPPORT */
+
+	mvCommUnitIntDisable(deviceId);
+
+#endif
+}
diff --git a/arch/arm/mach-avantalp/mv_hal_if/mvSysTdmApi.h b/arch/arm/mach-avantalp/mv_hal_if/mvSysTdmApi.h
new file mode 100644
index 0000000..74ca023
--- /dev/null
+++ b/arch/arm/mach-avantalp/mv_hal_if/mvSysTdmApi.h
@@ -0,0 +1,78 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_TDM_API_H__
+#define __MV_SYS_TDM_API_H__
+
+#include "mvSysTdmConfig.h"
+
+#ifdef MV_TDM_SUPPORT
+#include "voiceband/tdm/mvTdm.h"
+#else
+  #include "voiceband/commUnit/mvCommUnit.h"
+#endif
+
+MV_STATUS mvSysTdmInit (MV_TDM_PARAMS* tdmParams);
+
+#endif
diff --git a/arch/arm/mach-avantalp/mv_hal_if/mvSysTs.c b/arch/arm/mach-avantalp/mv_hal_if/mvSysTs.c
new file mode 100644
index 0000000..79ea4e8
--- /dev/null
+++ b/arch/arm/mach-avantalp/mv_hal_if/mvSysTs.c
@@ -0,0 +1,87 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ts/mvTsu.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ts/mvTsuRegs.h"
+
+MV_STATUS mvSysTsuInit(MV_TSU_CORE_CLOCK coreClock, MV_TSU_PORTS_MODE mode,
+		void *osHandle)
+{
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_STATUS status;
+
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+	if(status == MV_OK)
+		status = mvTsuWinInit(addrWinMap);
+
+	if(status == MV_OK)
+		status = mvTsuHalInit(coreClock, mode, osHandle);
+	return status;
+}
+
diff --git a/arch/arm/mach-avantalp/mv_hal_if/mvSysTsApi.h b/arch/arm/mach-avantalp/mv_hal_if/mvSysTsApi.h
new file mode 100644
index 0000000..837782d
--- /dev/null
+++ b/arch/arm/mach-avantalp/mv_hal_if/mvSysTsApi.h
@@ -0,0 +1,73 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_TS_API_H__
+#define __MV_SYS_TS_API_H__
+
+#include "ts/mvTsu.h"
+
+MV_STATUS mvSysTsuInit(MV_TSU_CORE_CLOCK coreClock, MV_TSU_PORTS_MODE mode,
+		void *osHandle);
+
+#endif
diff --git a/arch/arm/mach-avantalp/mv_hal_if/mvSysUsb.c b/arch/arm/mach-avantalp/mv_hal_if/mvSysUsb.c
new file mode 100644
index 0000000..f84e065
--- /dev/null
+++ b/arch/arm/mach-avantalp/mv_hal_if/mvSysUsb.c
@@ -0,0 +1,103 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "usb/mvUsb.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+#include "usb/mvUsbRegs.h"
+
+/*******************************************************************************
+* mvSysUsbHalInit - Initialize the USB subsystem
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_STATUS   mvSysUsbInit(MV_U32 dev, MV_BOOL isHost)
+{
+	MV_USB_HAL_DATA halData;
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_STATUS status;
+
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+	if(status == MV_OK)
+		status = mvUsbWinInit(dev, addrWinMap);
+
+	if(status == MV_OK) {
+		halData.ctrlModel = mvCtrlModelGet();
+		halData.ctrlRev = mvCtrlRevGet();
+		status = mvUsbHalInit(dev, isHost, &halData);
+	}
+
+	return status;
+}
+
diff --git a/arch/arm/mach-avantalp/mv_hal_if/mvSysUsbApi.h b/arch/arm/mach-avantalp/mv_hal_if/mvSysUsbApi.h
new file mode 100644
index 0000000..675b608
--- /dev/null
+++ b/arch/arm/mach-avantalp/mv_hal_if/mvSysUsbApi.h
@@ -0,0 +1,70 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_USB_API_H__
+#define __MV_SYS_USB_API_H__
+
+MV_STATUS   mvSysUsbInit(MV_U32 dev, MV_BOOL isHost);
+
+#endif
diff --git a/arch/arm/mach-avantalp/mv_hal_if/mvSysXor.c b/arch/arm/mach-avantalp/mv_hal_if/mvSysXor.c
new file mode 100644
index 0000000..20acd3e
--- /dev/null
+++ b/arch/arm/mach-avantalp/mv_hal_if/mvSysXor.c
@@ -0,0 +1,87 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "xor/mvXor.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "xor/mvXorRegs.h"
+
+MV_VOID mvSysXorInit (void)
+{
+	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
+	MV_STATUS status;
+
+	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
+	if(status == MV_OK)
+		status = mvXorWinInit(addrWinMap);
+
+	if(status == MV_OK)
+		mvXorHalInit(MV_XOR_MAX_CHAN);
+	return;
+}
+
+
diff --git a/arch/arm/mach-avantalp/mv_hal_if/mvSysXorApi.h b/arch/arm/mach-avantalp/mv_hal_if/mvSysXorApi.h
new file mode 100644
index 0000000..fb2b06d
--- /dev/null
+++ b/arch/arm/mach-avantalp/mv_hal_if/mvSysXorApi.h
@@ -0,0 +1,70 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_XOR_API_H__
+#define __MV_SYS_XOR_API_H__
+
+MV_VOID mvSysXorInit (void);
+
+#endif
diff --git a/arch/arm/mach-avantalp/pci.c b/arch/arm/mach-avantalp/pci.c
new file mode 100644
index 0000000..6951093
--- /dev/null
+++ b/arch/arm/mach-avantalp/pci.c
@@ -0,0 +1,243 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/init.h>
+                                                                                                                             
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/mach/pci.h>
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "mvSysPci.h"
+#include "pci/mvPci.h"
+
+#undef DEBUG
+#ifdef DEBUG
+#	define DB(x) x
+#else
+#	define DB(x) 
+#endif
+
+static int __init mv_map_irq(struct pci_dev *dev, u8 slot, u8 pin);
+
+extern u32 mv_pci_mem_size_get(int ifNum);
+extern u32 mv_pci_io_base_get(int ifNum);
+extern u32 mv_pci_io_size_get(int ifNum);
+extern u32 mv_pci_mem_base_get(int ifNum);
+
+void __init mv_pci_preinit(void)
+{
+	MV_ADDR_WIN win;
+	
+	if (mvCtrlPciMaxIfGet() > 1)
+		panic("Single PCI is supported ONLY!");
+
+       	mvPciInit(0, MV_PCI_MOD_HOST);
+
+	/* I/O remmap */
+	win.baseLow = 0x0;
+	win.baseHigh = 0x0;
+	mvCpuIfPciRemap(PCI_IF0_IO, &win);
+}
+
+
+/* Currentlly the PCI config read/write are implemented as read modify write
+   to 32 bit.
+   TBD: adjust it to realy use 1/2/4 byte(partial) read/write, after the pex
+	read config WA will be removed.
+*/
+static int mv_pci0_read_config(struct pci_bus *bus, unsigned int devfn, int where,
+                          int size, u32 *val)
+{
+
+        MV_U32 bus_num,func,regOff,dev_no,temp;
+	MV_U32 localBus;
+ 
+	*val = 0xffffffff;
+
+        bus_num = bus->number;
+        dev_no = PCI_SLOT(devfn);
+ 
+	/* don't return for our device */
+	localBus = mvPciLocalBusNumGet(0);
+	if((dev_no == 0) && ( bus_num == localBus)) {
+		DB(printk("PCI 0 read from our own dev return 0xffffffff \n"));
+		return 0xffffffff;
+	}
+
+        func = PCI_FUNC(devfn); 
+        regOff = (MV_U32)where & PCAR_REG_NUM_MASK;
+
+	if ((func == 0)&&(dev_no < 2))
+		DB(printk("PCI 0 read: bus = %x dev = %x func = %x regOff = %x ",bus_num,dev_no,func,regOff));
+	
+
+        temp = (u32) mvPciConfigRead(0, bus_num, dev_no, func, regOff);
+
+        switch (size) {
+        case 1:
+                temp = (temp >>  (8*(where & 0x3))) & 0xff;
+                break;
+ 
+        case 2:
+                temp = (temp >>  (8*(where & 0x2))) & 0xffff;
+                break;
+ 
+        default:
+                break;
+        }
+	
+	*val = temp;
+
+	if ((func == 0)&&(dev_no < 2)) {
+		DB(printk(" got %x \n",temp));
+	}
+	
+        return 0;
+}
+
+static int mv_pci0_write_config(struct pci_bus *bus, unsigned int devfn, int where,
+                           int size, u32 val)
+{
+        MV_U32 bus_num,func,regOff,dev_no,temp, mask , shift;
+ 
+	bus_num = bus->number;
+	dev_no = PCI_SLOT(devfn); 
+	func = PCI_FUNC(devfn); 
+	regOff = (MV_U32)where & PCAR_REG_NUM_MASK;
+
+	DB(printk("PCI 0: writing data %x size %x to bus %x dev %x func %x offs %x \n",val,size,bus_num,dev_no,func,regOff));
+	if( size != 4)
+        	temp = (u32) mvPciConfigRead(0, bus_num, dev_no, func, regOff);
+	else
+		temp = val;
+
+        switch (size) {
+        case 1:
+		shift = (8*(where & 0x3));
+		mask = 0xff;
+                break;
+ 
+        case 2:
+		shift = (8*(where & 0x2));
+                mask = 0xffff; 
+                break;
+ 
+        default:
+		shift = 0;
+		mask = 0xffffffff;
+                break;
+        }
+	
+	temp = (temp & (~(mask<<shift))) | ((val & mask) << shift);
+	mvPciConfigWrite(0, bus_num, dev_no, func, regOff, temp);
+
+        return 0;
+}
+
+static struct pci_ops mv_pci_ops = {
+        .read   = mv_pci0_read_config,
+        .write  = mv_pci0_write_config,
+};
+
+int __init mv_pci_setup(int nr, struct pci_sys_data *sys)
+{
+        struct resource *res;
+
+	if (nr)
+		panic("Single PCI is supported ONLY!");
+
+        sys->map_irq = mv_map_irq;
+
+	res = kmalloc(sizeof(struct resource) * 2, GFP_KERNEL);
+        if (!res)
+                panic("PCI: unable to alloc resources");
+                                                                                                                             
+        memset(res, 0, sizeof(struct resource) * 2);
+                                                                                                                             
+	res[0].start = mv_pci_io_base_get(0) - IO_SPACE_REMAP;
+	res[0].end   =  mv_pci_io_base_get(0) - IO_SPACE_REMAP +  mv_pci_io_size_get(0) - 1;
+	res[0].name  = "PCI0 IO Primary";
+	res[0].flags = IORESOURCE_IO;
+                                                                                                                             
+	res[1].start =  mv_pci_mem_base_get(0);
+	res[1].end   =  mv_pci_mem_base_get(0) +  mv_pci_mem_size_get(0) - 1;
+	res[1].name  = "PCI0 Memory Primary";
+	res[1].flags = IORESOURCE_MEM;
+ 
+        if (request_resource(&ioport_resource, &res[0]))
+		printk ("IO Request resource failed - Pci If %x\n",nr);
+
+	if (request_resource(&iomem_resource, &res[1]))
+		printk ("Memory Request resource failed - Pci If %x\n",nr);
+ 
+        sys->resource[0] = &res[0];
+        sys->resource[1] = &res[1];
+        sys->resource[2] = NULL;
+        sys->io_offset   = 0x0;
+ 
+        return 1;
+
+}
+
+struct pci_bus *mv_pci_scan_bus(int nr, struct pci_sys_data *sys)
+{
+	struct pci_ops *ops;
+	struct pci_bus *bus;
+
+        if (nr)
+		panic("Single PCI is supported ONLY!");
+
+	ops = &mv_pci_ops;
+	bus = pci_scan_bus(sys->busnr, ops, sys);
+	return bus;
+}
+
+static int __init mv_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_AURORA_PCI0;
+}
+
+static struct hw_pci mv_pci __initdata = {
+	.swizzle        	= pci_std_swizzle,
+        .map_irq                = mv_map_irq,
+        .setup                  = mv_pci_setup,
+        .scan                   = mv_pci_scan_bus,
+        .preinit                = mv_pci_preinit,
+};
+ 
+static int __init mv_pci_init(void)
+{
+	MV_U32 ifnum = mvCtrlPciMaxIfGet();
+	if (ifnum) {
+		mv_pci.nr_controllers = ifnum; 
+		pci_common_init(&mv_pci);
+	}
+
+    return 0;
+}
+
+subsys_initcall(mv_pci_init);
+
diff --git a/arch/arm/mach-avantalp/pex.c b/arch/arm/mach-avantalp/pex.c
new file mode 100644
index 0000000..70ebe9e
--- /dev/null
+++ b/arch/arm/mach-avantalp/pex.c
@@ -0,0 +1,540 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include <mach/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/mach/pci.h>
+#include <mach/irqs.h>
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ctrlEnv/mvUnitMap.h"
+#include "pex/mvPexRegs.h"
+#include "mvSysPexApi.h"
+
+#ifdef MV_DEBUG
+#	define DB(x) x
+#else
+#	define DB(x) 
+#endif
+
+#define MV_PEX_MASK_ABCD              (BIT24 | BIT25 | BIT26 | BIT27)
+
+static int __init mv_map_irq_0(struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_1(struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_2(struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_3(struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_4(struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_5(struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_6(struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_7(struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_8(struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_9(struct pci_dev *dev, u8 slot, u8 pin);
+
+extern u32 mv_pci_mem_size_get(int ifNum);
+extern u32 mv_pci_io_base_get(int ifNum);
+extern u32 mv_pci_io_size_get(int ifNum);
+extern u32 mv_pci_mem_base_get(int ifNum);
+extern int mv_is_pci_io_mapped(int ifNum);
+extern MV_TARGET mv_pci_io_target_get(int ifNum);
+
+static struct platform_device mv_pex = {
+	.name		= "mv_pex",
+	.id		= 0,
+	.num_resources	= 0,
+};
+
+static void* mv_get_irqmap_func[] __initdata =
+{
+	mv_map_irq_0,
+	mv_map_irq_1,
+	mv_map_irq_2,
+	mv_map_irq_3,
+	mv_map_irq_4,
+	mv_map_irq_5,
+	mv_map_irq_6,
+	mv_map_irq_7,
+	mv_map_irq_8,
+	mv_map_irq_9
+};
+
+void __init mv_pex_preinit(void)
+{
+	static MV_U32 pex0flg = 0;
+	unsigned int pciIf, temp;
+	MV_ADDR_WIN pciIoRemap;
+	MV_BOARD_PEX_INFO* boardPexInfo = mvBoardPexInfoGet();
+	MV_U32 pexHWInf = 0;
+
+	for (pciIf = 0; pciIf < boardPexInfo->boardPexIfNum; pciIf++) 
+	{
+		/* Translate logical interface number to physical */
+		pexHWInf = boardPexInfo->pexMapping[pciIf];
+
+		if (MV_FALSE == mvUnitMapIsPexMine(pexHWInf))
+			continue;
+
+		printk("PCI-E: Cheking physical bus #%d (controller #%d): ", pciIf, pexHWInf);
+		if (MV_FALSE == mvCtrlPwrClckGet(PEX_UNIT_ID, pexHWInf))
+		{
+			printk("Disabled\n");
+			continue;
+		}
+
+		/* init the PCI interface */
+		temp = mvSysPexInit(pexHWInf, MV_PEX_ROOT_COMPLEX);
+
+		if (MV_NO_SUCH == temp)
+		{
+			printk("Enabled - No Link\n");
+			/* No Link - shutdown interface */
+			mvCtrlPwrClckSet(PEX_UNIT_ID, pexHWInf, MV_FALSE);;
+			continue;
+		}
+		else if ((MV_OK != temp) && (MV_NO_SUCH != temp)){
+			printk("Init FAILED!!!\n");
+			printk("PCI-E %d: Init Failed.\n", pexHWInf);
+		}
+
+		printk("Enabled - Link UP\n");
+		/* Assign bus number 0 to first active/available bus */
+		if (pex0flg == 0) {
+	       		mvPexLocalBusNumSet(pexHWInf, 0x0);
+	       		pex0flg = 1;
+		}
+
+		MV_REG_BIT_SET(PEX_MASK_REG(pexHWInf), MV_PEX_MASK_ABCD);
+		if (mv_is_pci_io_mapped(pexHWInf))
+		{
+			pciIoRemap.baseLow = mv_pci_io_base_get(pexHWInf) - IO_SPACE_REMAP;
+			pciIoRemap.baseHigh = 0; 		
+			pciIoRemap.size = mv_pci_io_size_get(pexHWInf);
+			mvCpuIfPexRemap(mv_pci_io_target_get(pexHWInf), &pciIoRemap);
+		}
+	}
+}
+
+void mv_pex_reinit(void)
+{
+	static MV_U32 pex0flg = 0;
+	unsigned int pciIf, temp;
+	MV_ADDR_WIN pciIoRemap;
+	MV_BOARD_PEX_INFO* boardPexInfo = mvBoardPexInfoGet();
+	MV_U32 pexHWInf = 0;
+
+	for (pciIf = 0; pciIf < boardPexInfo->boardPexIfNum; pciIf++)
+	{
+		/* Translate logical interface number to physical */
+		pexHWInf = boardPexInfo->pexMapping[pciIf];
+
+		if (MV_FALSE == mvUnitMapIsPexMine(pexHWInf))
+			continue;
+
+		if (MV_FALSE == mvCtrlPwrClckGet(PEX_UNIT_ID, pexHWInf))
+			continue;
+
+		/* init the PCI interface */
+		temp = mvSysPexInit(pexHWInf, MV_PEX_ROOT_COMPLEX);
+
+		if (MV_NO_SUCH == temp)
+		{
+			/* No Link - shutdown interface */
+			mvCtrlPwrClckSet(PEX_UNIT_ID, pexHWInf, MV_FALSE);;
+			continue;
+		}
+
+		/* Assign bus number 0 to first active/available bus */
+		if (pex0flg == 0) {
+			mvPexLocalBusNumSet(pexHWInf, 0x0);
+			pex0flg = 1;
+		}
+
+		MV_REG_BIT_SET(PEX_MASK_REG(pexHWInf), MV_PEX_MASK_ABCD);
+		if (mv_is_pci_io_mapped(pexHWInf))
+		{
+			pciIoRemap.baseLow = mv_pci_io_base_get(pexHWInf) - IO_SPACE_REMAP;
+			pciIoRemap.baseHigh = 0;
+			pciIoRemap.size = mv_pci_io_size_get(pexHWInf);
+			mvCpuIfPexRemap(mv_pci_io_target_get(pexHWInf), &pciIoRemap);
+		}
+	}
+}
+
+
+/* Currentlly the PCI config read/write are implemented as read modify write
+   to 32 bit.
+   TBD: adjust it to realy use 1/2/4 byte(partial) read/write, after the pex
+	read config WA will be removed.
+*/
+static int mv_pci_read_config(struct pci_bus *bus, 
+				  unsigned int devfn, int where,
+				  int size, u32 *val)
+{
+	u32 bus_num,func,regOff,dev_no,temp, localBus;		
+	struct pci_sys_data *sysdata = (struct pci_sys_data *)bus->sysdata;	
+	u32 pciIf = sysdata->mv_controller_num;
+
+	*val = 0xffffffff;
+
+	if (MV_FALSE == mvCtrlPwrClckGet(PEX_UNIT_ID, pciIf))
+		return 0;
+	bus_num = bus->number;
+	dev_no = PCI_SLOT(devfn);
+
+	/* don't return for our device */
+	localBus = mvPexLocalBusNumGet(pciIf);
+	if ((dev_no == 0) && ( bus_num == localBus))
+	{
+		DB(printk("PCI %d read from our own dev return 0xffffffff \n", pciIf));
+		return 0xffffffff;
+	}
+
+	func = PCI_FUNC(devfn); 
+	regOff = (MV_U32)where & (PXCAR_REG_NUM_MASK | PXCAR_REAL_EXT_REG_NUM_MASK); /* total of 12 bits: 8 legacy + 4 extended */
+
+	DB(printk("PCI %d read: bus = %x dev = %x func = %x regOff = %x ",pciIf, bus_num,dev_no,func,regOff));
+	
+	temp = (u32) mvPexConfigRead(pciIf, bus_num, dev_no, func, regOff);
+	switch (size) {
+		case 1:
+			temp = (temp >>  (8*(where & 0x3))) & 0xff;
+			break;
+
+		case 2:
+			temp = (temp >>  (8*(where & 0x2))) & 0xffff;
+			break;
+
+		default:
+			break;
+	}
+		
+	*val = temp;
+
+	DB(printk(" got %x \n",temp));
+	
+    return 0;
+}
+
+static int mv_pci_write_config(struct pci_bus *bus, unsigned int devfn, int where,
+                           int size, u32 val)
+{
+	u32 bus_num,func,regOff,dev_no,temp, mask , shift;
+	struct pci_sys_data *sysdata = (struct pci_sys_data *)bus->sysdata;	
+	u32 pciIf = sysdata->mv_controller_num;		
+
+	if (MV_FALSE == mvCtrlPwrClckGet(PEX_UNIT_ID, pciIf))
+		return 0xFFFFFFFF;
+	bus_num = bus->number;
+	dev_no = PCI_SLOT(devfn);
+	func = PCI_FUNC(devfn);
+	regOff = (MV_U32)where & (PXCAR_REG_NUM_MASK | PXCAR_REAL_EXT_REG_NUM_MASK); /* total of 12 bits: 8 legacy + 4 extended */
+
+	DB(printk("PCI %d: writing data %x size %x to bus %x dev %x func %x offs %x \n",
+			  pciIf, val,size,bus_num,dev_no,func,regOff));
+	if (size != 4)
+	{
+		temp = (u32) mvPexConfigRead(pciIf, bus_num, dev_no, func, regOff);
+	}
+	else
+	{
+		temp = val;
+	}
+
+	switch (size) {
+		case 1:
+			shift = (8*(where & 0x3));
+			mask = 0xff;
+			break;
+		case 2:
+			shift = (8*(where & 0x2));
+			mask = 0xffff;
+			break;
+
+		default:
+			shift = 0;
+			mask = 0xffffffff;
+			break;
+	}
+
+	temp = (temp & (~(mask<<shift))) | ((val & mask) << shift);
+	mvPexConfigWrite(pciIf, bus_num, dev_no, func, regOff, temp);
+	return 0;
+}
+
+
+static struct pci_ops mv_pci_ops = {
+        .read   = mv_pci_read_config,
+        .write  = mv_pci_write_config,
+};
+
+
+int __init mv_pex_setup(int nr, struct pci_sys_data *sys)
+{
+	struct resource *res;
+	u32 membase, iobase, index = 0;	
+	MV_BOARD_PEX_INFO* boardPexInfo = mvBoardPexInfoGet();
+	MV_U32 pexHWInf = 0;
+
+	/* Translate logical interface number to physical */
+	pexHWInf = boardPexInfo->pexMapping[nr];
+
+	if (MV_FALSE == mvUnitMapIsPexMine(pexHWInf))
+		return 0;
+
+	/* Check if this interface is used or not */
+	if (MV_FALSE == mvCtrlPwrClckGet(PEX_UNIT_ID, pexHWInf))
+		return 0;
+
+	/* Allocate resources memory */	
+	res = kmalloc(sizeof(struct resource) * 2, GFP_KERNEL);
+	if (!res)
+	{
+		panic("PCI: unable to alloc resources");
+		return 0;
+	}
+                                                                                                                             
+	memset(res, 0, sizeof(struct resource) * 2);
+
+	/* Save the H/W if number for this PEX bus */
+	sys->mv_controller_num = pexHWInf;
+	sys->map_irq = mv_get_irqmap_func[sys->mv_controller_num];
+	
+	membase = mv_pci_mem_base_get(sys->mv_controller_num);
+	if (mv_is_pci_io_mapped(sys->mv_controller_num))
+	{
+	
+		iobase = mv_pci_io_base_get(sys->mv_controller_num);
+		res[index].start = iobase - IO_SPACE_REMAP;
+		res[index].end   = iobase - IO_SPACE_REMAP + mv_pci_io_size_get(sys->mv_controller_num)-1;
+		res[index].name  = "PCIx IO Primary";
+		res[index].flags = IORESOURCE_IO;		
+		if (request_resource(&ioport_resource, &res[index]))
+		{	
+			printk ("IO Request resource failed - Pci If %x\n",nr);
+		}
+		else
+			index++;
+	}
+	res[index].start = membase;
+	res[index].end   = membase + mv_pci_mem_size_get(sys->mv_controller_num)-1;
+	res[index].name  = "PCIx Memory Primary";
+	res[index].flags = IORESOURCE_MEM;
+
+	if (request_resource(&iomem_resource, &res[index]))
+	{	
+		printk ("Memory Request resource failed - Pci If %x\n",nr);
+	}
+ 
+	sys->resource[0] = &res[0];
+	if (index > 0) 
+	{
+		sys->resource[1] = &res[1];
+		sys->resource[2] = NULL;
+	}
+	else
+		sys->resource[1] = NULL;
+	sys->io_offset   = 0x0;
+
+	return 1;
+}
+
+
+struct pci_bus *mv_pex_scan_bus(int nr, struct pci_sys_data *sys)
+{
+	struct pci_ops *ops = &mv_pci_ops;	
+	struct pci_bus *bus;
+	MV_BOARD_PEX_INFO* boardPexInfo = mvBoardPexInfoGet();
+	MV_U32 pexNextHWInf, ifnum;
+
+	bus = pci_scan_bus(sys->busnr, ops, sys);
+
+	/* Set the bus number in the following controller */
+	for (ifnum = (nr+1); ifnum < boardPexInfo->boardPexIfNum; ifnum++) {
+
+		pexNextHWInf = boardPexInfo->pexMapping[ifnum];
+
+		if (MV_FALSE == mvUnitMapIsPexMine(pexNextHWInf))
+			continue;
+
+		if (MV_TRUE == mvCtrlPwrClckGet(PEX_UNIT_ID, pexNextHWInf)) {
+			mvPexLocalBusNumSet(pexNextHWInf, (bus->subordinate + 1));
+			break;
+		}
+	}
+
+	return bus;
+}
+
+
+static int __init mv_map_irq_0(struct pci_dev *dev, u8 slot, u8 pin)
+{	
+	return IRQ_AURORA_PCIE0;
+}
+
+static int __init mv_map_irq_1(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_AURORA_PCIE1;
+}
+
+static int __init mv_map_irq_2(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_AURORA_PCIE2;
+}
+
+static int __init mv_map_irq_3(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_AURORA_PCIE3;
+}
+
+static int __init mv_map_irq_4(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_AURORA_PCIE4;
+}
+
+static int __init mv_map_irq_5(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_AURORA_PCIE5;
+}
+
+static int __init mv_map_irq_6(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_AURORA_PCIE6;
+}
+
+static int __init mv_map_irq_7(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_AURORA_PCIE7;
+}
+
+static int __init mv_map_irq_8(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_AURORA_PCIE8;
+}
+
+static int __init mv_map_irq_9(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_AURORA_PCIE9;
+}
+
+static struct hw_pci mv_pci __initdata = {
+	.swizzle        	= pci_std_swizzle,
+        .setup                  = mv_pex_setup,
+        .scan                   = mv_pex_scan_bus,
+        .preinit                = mv_pex_preinit,
+};
+
+static int mv_pex_probe(struct platform_device *dev)
+{
+	return 0;
+}
+
+static int pex_status[MV_PEX_MAX_IF];
+static int pex_ifnum;
+
+static int mv_pex_suspend(struct platform_device *dev, pm_message_t state)
+{
+	unsigned int pciIf;
+	MV_U32 pexHWInf = 0;
+	MV_BOARD_PEX_INFO* boardPexInfo = mvBoardPexInfoGet();
+
+	/* Save PCI Express status Register */
+	for (pciIf = 0; pciIf < pex_ifnum; pciIf++) {
+		pexHWInf = boardPexInfo->pexMapping[pciIf];
+
+		if (MV_FALSE == mvUnitMapIsPexMine(pexHWInf))
+			continue;
+		if (MV_FALSE == mvCtrlPwrClckGet(PEX_UNIT_ID, pexHWInf))
+			continue;
+
+		pex_status[pexHWInf] = MV_REG_READ(PEX_STATUS_REG(pexHWInf));
+	}
+
+	return 0;
+}
+
+static int mv_pex_resume(struct platform_device *dev)
+{
+	unsigned int pciIf;
+	MV_U32 pexHWInf = 0;
+	MV_BOARD_PEX_INFO* boardPexInfo = mvBoardPexInfoGet();
+
+	mv_pex_reinit();
+
+	/* Restore PCI Express status Register */
+	for (pciIf = 0; pciIf < pex_ifnum; pciIf++) {
+		pexHWInf = boardPexInfo->pexMapping[pciIf];
+
+		if (MV_FALSE == mvUnitMapIsPexMine(pexHWInf))
+			continue;
+		if (MV_FALSE == mvCtrlPwrClckGet(PEX_UNIT_ID, pexHWInf))
+			continue;
+
+		MV_REG_WRITE(PEX_STATUS_REG(pexHWInf), pex_status[pexHWInf]);
+	}
+
+	return 0;
+}
+
+static struct platform_driver mv_pex_driver = {
+	.probe    = mv_pex_probe,
+#ifdef CONFIG_PM
+	.suspend = mv_pex_suspend,
+	.resume  = mv_pex_resume,
+#endif /* CONFIG_PM */
+	.driver = {
+		.name = "mv_pex",
+	},
+};
+
+static int __init mv_pex_init_module(void)
+{
+	MV_BOARD_PEX_INFO* boardPexInfo = mvBoardPexInfoGet();
+
+	/* WA - Disable PEX on RD-SERVER board */
+	if (mvBoardIdGet() == RD_78460_SERVER_ID)
+		return 0;
+
+	mv_pci.nr_controllers = (mvBoardPexInfoGet())->boardPexIfNum;
+	mv_pci.swizzle        = pci_std_swizzle;
+	mv_pci.map_irq         = mv_map_irq_0;
+	mv_pci.setup           = mv_pex_setup;
+	mv_pci.scan            = mv_pex_scan_bus;
+	mv_pci.preinit         = mv_pex_preinit;
+	pci_common_init(&mv_pci);
+	platform_device_register(&mv_pex);
+
+	pex_ifnum = boardPexInfo->boardPexIfNum;
+
+	return platform_driver_register(&mv_pex_driver);
+}
+
+module_init(mv_pex_init_module);
+MODULE_DESCRIPTION("Marvell PEX Driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-avantalp/platsmp.c b/arch/arm/mach-avantalp/platsmp.c
new file mode 100644
index 0000000..5f1aca9
--- /dev/null
+++ b/arch/arm/mach-avantalp/platsmp.c
@@ -0,0 +1,174 @@
+/*
+ *  linux/arch/arm/mach-vexpress/platsmp.c
+ *
+ *  Copyright (C) 2002 ARM Ltd.
+ *  All Rights Reserved
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/smp.h>
+#include <linux/io.h>
+
+#include <asm/unified.h>
+#include <asm/smp_scu.h>
+
+#include <linux/delay.h>
+#include <linux/jiffies.h>
+#include <asm/cacheflush.h>
+#include <asm/hardware/gic.h>
+#include "ca9x2.h"
+//#include <mach/motherboard.h>
+//#define V2M_PA_CS7 0x10000000
+
+#include "core.h"
+
+extern void avantalp_secondary_startup(void);
+
+/*
+ * Initialise the CPU possible map early - this describes the CPUs
+ * which may be present or become present in the system.
+ */
+void __init smp_init_cpus(void)
+{
+	int i, ncores = scu_get_core_count(INTER_REGS_BASE + MV_CA9X2_L2CC_OFFSET);
+
+	if (ncores > nr_cpu_ids) {
+		pr_warn("SMP: %u cores greater than maximum (%u), clipping\n",
+			ncores, nr_cpu_ids);
+		ncores = nr_cpu_ids;
+	}
+
+	for (i = 0; i < ncores; ++i)
+		set_cpu_possible(i, true);
+
+	set_smp_cross_call(gic_raise_softirq);
+}
+
+void __init platform_smp_prepare_cpus(unsigned int max_cpus)
+{
+	unsigned int ncores = scu_get_core_count(INTER_REGS_BASE + MV_CA9X2_L2CC_OFFSET);
+
+	/*
+	 * Initialise the present map, which describes the set of CPUs
+	 * actually populated at the present time.
+	 */
+	scu_enable(INTER_REGS_BASE + MV_CA9X2_L2CC_OFFSET);
+	
+	/*
+	 * Write the address of secondary startup into the
+	 * system-wide flags register. The boot monitor waits
+	 * until it receives a soft interrupt, and then the
+	 * secondary CPU branches to this address.
+	 */
+	/* Set resume control and address */
+#if 0
+	MV_REG_WRITE(AXP_CPU_RESUME_CTRL_REG, 0x0);
+	MV_REG_WRITE(AXP_CPU_RESUME_ADDR_REG(cpu),
+			virt_to_phys(axp_secondary_startup));
+#endif
+#if 0
+	writel(~0, MMIO_P2V(V2M_SYS_FLAGSCLR));
+	writel(BSYM(virt_to_phys(avantalp_secondary_startup)),
+		MMIO_P2V(V2M_SYS_FLAGSSET));
+#endif
+}
+
+/*
+ * control for which core is the next to come out of the secondary
+ * boot "holding pen"
+ */
+volatile int __cpuinitdata pen_release = -1;
+
+/*
+ * Write pen_release in a way that is guaranteed to be visible to all
+ * observers, irrespective of whether they're taking part in coherency
+ * or not.  This is necessary for the hotplug code to work reliably.
+ */
+static void __cpuinit write_pen_release(int val)
+{
+	pen_release = val;
+	smp_wmb();
+	__cpuc_flush_dcache_area((void *)&pen_release, sizeof(pen_release));
+	outer_clean_range(__pa(&pen_release), __pa(&pen_release + 1));
+}
+
+static DEFINE_SPINLOCK(boot_lock);
+
+void __cpuinit platform_secondary_init(unsigned int cpu)
+{
+	/*
+	 * if any interrupts are already enabled for the primary
+	 * core (e.g. timer irq), then they will not have been enabled
+	 * for us: do so
+	 */
+	gic_secondary_init(0);
+
+	/*
+	 * let the primary processor know we're out of the
+	 * pen, then head off into the C entry point
+	 */
+	write_pen_release(-1);
+
+	/*
+	 * Synchronise with the boot thread.
+	 */
+	spin_lock(&boot_lock);
+	spin_unlock(&boot_lock);
+}
+
+int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
+{
+	unsigned long timeout;
+
+	/*
+	 * Set synchronisation state between this boot processor
+	 * and the secondary one
+	 */
+	spin_lock(&boot_lock);
+
+	/*
+	 * This is really belt and braces; we hold unintended secondary
+	 * CPUs in the holding pen until we're ready for them.  However,
+	 * since we haven't sent them a soft interrupt, they shouldn't
+	 * be there.
+	 */
+	write_pen_release(cpu_logical_map(cpu));
+
+	/*
+	 * Send the secondary CPU a soft interrupt, thereby causing
+	 * the boot monitor to read the system wide flags register,
+	 * and branch to the address found there.
+	 */
+	gic_raise_softirq(cpumask_of(cpu), 1);
+
+	timeout = jiffies + (1 * HZ);
+	while (time_before(jiffies, timeout)) {
+		smp_rmb();
+		if (pen_release == -1)
+			break;
+
+		udelay(10);
+	}
+
+	/*
+	 * now the secondary core is starting up let it run its
+	 * calibrations, then wait for it to finish
+	 */
+	spin_unlock(&boot_lock);
+
+	return pen_release != -1 ? -ENOSYS : 0;
+}
+#if 0
+void __init set_core_count(unsigned int cpu_count)
+{
+	/* Update cpu count */
+	mv_cpu_count = cpu_count;
+
+	/* Update group mask as well */
+	group_cpu_mask = ((1 << cpu_count) - 1) << (hard_smp_processor_id());
+}
+#endif
\ No newline at end of file
diff --git a/arch/arm/mach-avantalp/pm.c b/arch/arm/mach-avantalp/pm.c
new file mode 100644
index 0000000..7c16339
--- /dev/null
+++ b/arch/arm/mach-avantalp/pm.c
@@ -0,0 +1,159 @@
+/*
+ * pm.c
+ *
+ * Power Management functions for Marvell ArmadaXP System On Chip
+ *
+ * Maintainer: Nadav Haklai <nadavh@marvell.com>
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <linux/module.h>
+#include <linux/sysfs.h>
+#include <linux/proc_fs.h>
+#include <linux/interrupt.h>
+#include <linux/suspend.h>
+#include <linux/interrupt.h>
+
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+
+#ifdef CONFIG_SHEEVA_DEEP_IDLE
+extern void armadaxp_deepidle(int power_state);
+extern void armadaxp_suspend(void);
+extern void axp_db_restore(void);
+
+typedef enum  {
+	DISABLED,
+	WFI,
+	DEEP_IDLE,
+	SNOOZE,
+} MV_PM_STATES;
+
+/*
+ * Logical check for Armada XP valid PM states
+ */
+static int armadaxp_pm_valid(suspend_state_t state)
+{
+	return ((state == PM_SUSPEND_STANDBY) ||
+		(state == PM_SUSPEND_MEM));
+}
+
+/*
+ * Enter the requested PM state
+ */
+static int armadaxp_pm_enter(suspend_state_t state)
+{
+
+	MV_U32 reg;
+
+	switch (state)	{
+	case PM_SUSPEND_STANDBY:
+
+		/* Reenable the Uart IRQ in order to wake from it */
+		/* Enable Uart IRQ */
+		reg = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_UART0));
+		reg |= 0x1;
+		MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_UART0), reg);
+
+		/* Disable IPI IRQs */
+		reg = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_IN_DRBL_LOW));
+		reg &= ~0x1;
+		MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_IN_DRBL_LOW), reg);
+
+#ifdef CONFIG_MV_ETH_PNC_WOL
+
+		printk(KERN_INFO "Entering Wol Mode (Neta IRQs 8,10,12,14 are enabled now)...\n");
+
+		/* Reenable the NETA IRQ in order to wake from it */
+		reg = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_GBE0_FIC));
+		reg |= 0x1;
+		MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_GBE0_FIC), reg);
+
+		reg = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_GBE1_FIC));
+		reg |= 0x1;
+		MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_GBE1_FIC), reg);
+
+		reg = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_GBE2_FIC));
+		reg |= 0x1;
+		MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_GBE2_FIC), reg);
+
+		reg = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_GBE3_FIC));
+		reg |= 0x1;
+		MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_GBE3_FIC), reg);
+#endif /* CONFIG_MV_ETH_PNC_WOL */
+
+		armadaxp_deepidle(SNOOZE);
+
+		/* Enable IPI IRQs - return to original state */
+		reg = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_IN_DRBL_LOW));
+		reg |= 0x1;
+		MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_IN_DRBL_LOW), reg);
+
+		/* Disable it since it will be re-enabled by the stack */
+		reg = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_UART0));
+		reg &= ~0x1;
+		MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_UART0), reg);
+#ifdef CONFIG_MV_ETH_PNC_WOL
+		reg = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_GBE0_FIC));
+		reg &= ~0x1;
+		MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_GBE0_FIC), reg);
+
+		reg = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_GBE1_FIC));
+		reg &= ~0x1;
+		MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_GBE1_FIC), reg);
+
+		reg = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_GBE2_FIC));
+		reg &= ~0x1;
+		MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_GBE2_FIC), reg);
+
+		reg = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_GBE3_FIC));
+		reg &= ~0x1;
+		MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_GBE3_FIC), reg);
+
+		printk(KERN_INFO "Exiting Wol Mode (Neta IRQs 8,10,12,14 are disabled now)...\n");
+#endif /* CONFIG_MV_ETH_PNC_WOL */
+		break;
+
+	case PM_SUSPEND_MEM:
+
+		pr_info("Suspending Armada XP\n");
+		armadaxp_suspend();
+
+		pr_info("Restoring Armada XP\n");
+		axp_db_restore();
+
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static struct platform_suspend_ops armadaxp_pm_ops = {
+	.valid		= armadaxp_pm_valid,
+	.enter		= armadaxp_pm_enter,
+};
+
+static int __init armadaxp_pm_init(void)
+{
+	printk(KERN_INFO "ArmadaXP Power Managament Suspend Operations Initialized\n");
+	suspend_set_ops(&armadaxp_pm_ops);
+	return 0;
+}
+
+__initcall(armadaxp_pm_init);
+
+#else
+
+static int __init armadaxp_pm_init(void)
+{
+	printk(KERN_INFO "ArmadaXP Power Managament NOT Initialized (Missing Deep-Idle Support)\n");
+	return 0;
+}
+
+__initcall(armadaxp_pm_init);
+
+#endif /* CONFIG_SHEEVA_DEEP_IDLE */
diff --git a/arch/arm/mach-avantalp/proc_aurora_dbg.c b/arch/arm/mach-avantalp/proc_aurora_dbg.c
new file mode 100644
index 0000000..ed59c0a
--- /dev/null
+++ b/arch/arm/mach-avantalp/proc_aurora_dbg.c
@@ -0,0 +1,88 @@
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/sysdev.h>
+#include <linux/proc_fs.h>
+#include <linux/version.h> 
+ 
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+
+static struct proc_dir_entry *aurora_dbg;
+
+unsigned int aurora_core_index(void)
+{
+        unsigned int value;
+
+        __asm__ __volatile__("mrc p15, 0, %0, c0, c0, 5   @ read CPU ID reg\n"
+                : "=r" (value) :: "memory");
+        return (value & 0xF);
+}
+
+/********************************************************************/
+int aurora_dbg_read (char *buffer, char **buffer_location, off_t offset,
+                            int buffer_length, int *zero, void *ptr) {
+
+	char *p = buffer;
+  	unsigned int val, len;
+
+#ifdef CONFIG_SMP
+	p += sprintf(p,"CPU %d:\n", aurora_core_index());
+#endif
+	__asm volatile ("mrc  p15, 1, %0, c15, c1, 1" : "=r" (val));
+	p += sprintf(p, "c1, 1 %x \n", val);
+	__asm volatile ("mrc  p15, 1, %0, c15, c1, 2" : "=r" (val));
+	p += sprintf(p, "c1, 2 %x \n", val);
+	__asm volatile ("mrc  p15, 1, %0, c15, c2, 0" : "=r" (val));
+	p += sprintf(p, "c2, 0 %x \n", val);
+	__asm volatile ("mrc  p15, 1, %0, c15, c2, 1" : "=r" (val));
+	p += sprintf(p, "c2, 1 %x \n", val);
+	__asm volatile ("mrc  p15, 1, %0, c15, c1, 0" : "=r" (val));
+	p += sprintf(p, "c1, 0 %x \n", val);
+
+#ifdef CONFIG_PERF_EVENTS
+	__asm volatile ("mrc  p15, 0, %0, c9, c12, 0" : "=r" (val));
+	p += sprintf(p, "pmon ctrl %x \n", val);
+	__asm volatile ("mrc  p15, 0, %0, c9, c12, 1" : "=r" (val));
+	p += sprintf(p, "pmon cntrs en %x \n", val);
+	__asm volatile ("mrc  p15, 0, %0, c9, c12, 3" : "=r" (val));
+	p += sprintf(p, "pmon cntrs oflow %x \n", val);
+	__asm volatile ("mrc  p15, 0, %0, c9, c12, 5" : "=r" (val));
+	p += sprintf(p, "pmon cntr sel %x \n", val);
+	__asm volatile ("mrc  p15, 0, %0, c9, c13, 0" : "=r" (val));
+	p += sprintf(p, "pmon cycle cnt %x \n", val);
+	__asm volatile ("mrc  p15, 0, %0, c9, c13, 1" : "=r" (val));
+	p += sprintf(p, "pmon evt sel %x \n", val);
+	__asm volatile ("mrc  p15, 0, %0, c9, c13, 2" : "=r" (val));
+	p += sprintf(p, "pmon cntr val %x \n", val);
+	__asm volatile ("mrc  p15, 0, %0, c9, c14, 1" : "=r" (val));
+	p += sprintf(p, "pmon int en %x \n", val);
+#endif
+
+	len = (p - buffer);
+  	return len;
+}
+
+/********************************************************************/
+int __init start_aurora_dbg(void)
+{
+        aurora_dbg = create_proc_entry ("aurora_dbg" , 0666 , NULL);
+  	aurora_dbg->read_proc = aurora_dbg_read;
+  	aurora_dbg->write_proc = NULL;
+  	aurora_dbg->nlink = 1;
+	return 0;
+}
+void __exit stop_aurora_dbg(void)
+{
+        remove_proc_entry("aurora_dbg",  NULL);
+        return;
+}
+module_init(start_aurora_dbg);
+module_exit(stop_aurora_dbg);
+
diff --git a/arch/arm/mach-avantalp/sysmap.c b/arch/arm/mach-avantalp/sysmap.c
new file mode 100644
index 0000000..e7579ab
--- /dev/null
+++ b/arch/arm/mach-avantalp/sysmap.c
@@ -0,0 +1,211 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+
+#include "mvSysHwConfig.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include <asm/mach/map.h>
+#include <asm/smp_twd.h>
+#include "ca9x2.h"
+/* for putstr */
+/* #include <asm/arch/uncompress.h> */
+
+MV_CPU_DEC_WIN* mv_sys_map(void);
+
+struct map_desc  MEM_TABLE[] =	{
+	/* no use for pex mem remap */	
+	{ INTER_REGS_BASE,		__phys_to_pfn(INTER_REGS_PHYS_BASE),	SZ_1M,  	     	MT_DEVICE},
+};
+
+MV_CPU_DEC_WIN SYSMAP_ARMADA_XP[] = {
+	/* base low       	     base high        size       		WinNum     	enable */
+	{{SDRAM_CS0_BASE,		0,	SDRAM_CS0_SIZE		},	0xFFFFFFFF,	DIS},	/* SDRAM_CS0 */
+	{{SDRAM_CS1_BASE,		0,	SDRAM_CS1_SIZE		},	0xFFFFFFFF,	DIS},	/* SDRAM_CS1 */
+	{{SDRAM_CS2_BASE,		0,	SDRAM_CS2_SIZE		},	0xFFFFFFFF,	DIS},	/* SDRAM_CS2 */
+	{{SDRAM_CS3_BASE,		0,	SDRAM_CS3_SIZE		},	0xFFFFFFFF,	DIS},	/* SDRAM_CS3 */
+	{{DEVICE_CS0_PHYS_BASE,		0,	DEVICE_CS0_SIZE,	},	0x8,		EN},	/* DEVICE_CS0 */
+	{{DEVICE_CS1_PHYS_BASE,		0,	DEVICE_CS1_SIZE,	},	TBL_UNUSED,	DIS},	/* DEVICE_CS1 */
+	{{DEVICE_CS2_PHYS_BASE,		0,	DEVICE_CS2_SIZE,	},	TBL_UNUSED,	DIS},	/* DEVICE_CS2 */
+	{{DEVICE_CS3_PHYS_BASE,		0,	DEVICE_CS3_SIZE,	},	TBL_UNUSED,	DIS},	/* DEVICE_CS3 */
+	{{PEX0_MEM_PHYS_BASE,		0,	PEX0_MEM_SIZE		},	0x0,		EN},	/* PEX0_MEM */
+	{{PEX0_IO_PHYS_BASE,		0,	PEX0_IO_SIZE		},	TBL_UNUSED,	DIS},	/* PEX0_IO */
+	{{PEX1_MEM_PHYS_BASE,		0,	PEX1_MEM_SIZE		},	0x1,		EN},	/* PEX1_MEM */
+	{{PEX1_IO_PHYS_BASE,		0,	PEX1_IO_SIZE		},	TBL_UNUSED,	DIS},	/* PEX1_IO */
+	{{PEX2_MEM_PHYS_BASE,		0,	PEX2_MEM_SIZE		},	0x2,		EN},	/* PEX2_MEM */
+	{{PEX2_IO_PHYS_BASE,		0,	PEX2_IO_SIZE		},	TBL_UNUSED,	DIS},	/* PEX2_IO */
+	{{PEX3_MEM_PHYS_BASE,		0,	PEX3_MEM_SIZE		},	0x3,		EN},	/* PEX3_MEM */
+	{{PEX3_IO_PHYS_BASE,		0,	PEX3_IO_SIZE		},	TBL_UNUSED,	DIS},	/* PEX3_IO */
+	{{PEX4_MEM_PHYS_BASE,		0,	PEX4_MEM_SIZE		},	0x4,		EN},	/* PEX4_MEM */
+	{{PEX4_IO_PHYS_BASE,		0,	PEX4_IO_SIZE		},	TBL_UNUSED,	DIS},	/* PEX4_IO */
+	{{PEX5_MEM_PHYS_BASE,		0,	PEX5_MEM_SIZE		},	TBL_UNUSED,	DIS},	/* PEX5_MEM */
+	{{PEX5_IO_PHYS_BASE,		0,	PEX5_IO_SIZE		},	TBL_UNUSED,	DIS},	/* PEX5_IO */
+	{{PEX6_MEM_PHYS_BASE,		0,	PEX6_MEM_SIZE		},	0x5,		EN},	/* PEX6_MEM */
+	{{PEX6_IO_PHYS_BASE,		0,	PEX6_IO_SIZE		},	TBL_UNUSED,	DIS},	/* PEX6_IO */
+	{{PEX7_MEM_PHYS_BASE,		0,	PEX7_MEM_SIZE		},	TBL_UNUSED,	DIS},	/* PEX7_MEM */
+	{{PEX7_IO_PHYS_BASE,		0,	PEX7_IO_SIZE		},	TBL_UNUSED,	DIS},	/* PEX7_IO */
+	{{PEX8_MEM_PHYS_BASE,		0,	PEX8_MEM_SIZE		},	0x6,		EN},	/* PEX8_MEM */
+	{{PEX8_IO_PHYS_BASE,		0,	PEX8_IO_SIZE		},	TBL_UNUSED,	DIS},	/* PEX8_IO */
+	{{PEX9_MEM_PHYS_BASE,		0,	PEX9_MEM_SIZE		},	0x7,		EN},	/* PEX9_MEM */
+	{{PEX9_IO_PHYS_BASE,		0,	PEX9_IO_SIZE		},	TBL_UNUSED,	DIS},	/* PEX9_IO */
+	{{INTER_REGS_PHYS_BASE,		0,	INTER_REGS_SIZE		},	0x14,		EN},	/* INTER_REGS */
+	{{UART_REGS_BASE,		0,	UART_SIZE		},	TBL_UNUSED,	DIS},	/* DMA_UART */
+	{{SPI_CS0_PHYS_BASE,		0,	SPI_CS0_SIZE		},	0xe,		EN},	/* SPI_CS0 */
+	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS1 */
+	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS2 */
+	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS3 */
+	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS4 */
+	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS5 */
+	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS6 */
+	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS7 */
+	{{BOOTROM_PHYS_BASE,		0,	BOOTROM_SIZE		},	0x9,		EN},	/* BOOTROM */
+	{{DEVICE_BOOTCS_PHYS_BASE,	0,	DEVICE_BOOTCS_SIZE	},	0xa,		EN},	/* DEV_BOOCS */
+	{{PMU_SCRATCH_PHYS_BASE,	0,	PMU_SCRATCH_SIZE	},	TBL_UNUSED,	DIS},	/* PMU SCRATCHPAD */
+	{{CRYPT_ENG_PHYS_BASE(0),	0,	CRYPT_ENG_SIZE		},	0xb,		EN},	/* CRYPT0_ENG */
+	{{CRYPT_ENG_PHYS_BASE(1),	0,	CRYPT_ENG_SIZE		},	0xc,		EN},	/* CRYPT1_ENG */
+	{{PNC_BM_PHYS_BASE,		0,	PNC_BM_SIZE		},	0xd,		EN},	/* PNC_BM */
+	{{TBL_TERM,				TBL_TERM, TBL_TERM	},	TBL_TERM,	TBL_TERM}
+};
+
+
+MV_CPU_DEC_WIN* mv_sys_map(void)
+{
+	return SYSMAP_ARMADA_XP;
+}
+
+
+#if defined(CONFIG_MV_INCLUDE_CESA)
+u32 mv_crypto_phys_base_get(u8 chan)
+{
+	return CRYPT_ENG_PHYS_BASE(chan);
+}
+u32 mv_crypto_virt_base_get(u8 chan)
+{
+	return CRYPT_ENG_VIRT_BASE(chan);
+}
+#endif
+
+void __init alp_map_io(void)
+{
+        iotable_init(MEM_TABLE, ARRAY_SIZE(MEM_TABLE));
+		twd_base = INTER_REGS_BASE + A9_MPCORE_TWD;
+}
+
+static u32 mv_pci_mem_base[] = 
+{
+	PEX0_MEM_PHYS_BASE,
+	PEX1_MEM_PHYS_BASE,
+	PEX2_MEM_PHYS_BASE,
+	PEX3_MEM_PHYS_BASE,
+	PEX4_MEM_PHYS_BASE,
+	PEX5_MEM_PHYS_BASE,
+	PEX6_MEM_PHYS_BASE,
+	PEX7_MEM_PHYS_BASE,
+	PEX8_MEM_PHYS_BASE,
+	PEX9_MEM_PHYS_BASE,
+};
+
+static u32 mv_pci_mem_size[] = 
+{
+	PEX0_MEM_SIZE,
+	PEX1_MEM_SIZE,
+	PEX2_MEM_SIZE,
+	PEX3_MEM_SIZE,
+	PEX4_MEM_SIZE,
+	PEX5_MEM_SIZE,
+	PEX6_MEM_SIZE,
+	PEX7_MEM_SIZE,
+	PEX8_MEM_SIZE,
+	PEX9_MEM_SIZE,
+};
+
+static u32 mv_pci_io_base[] = 
+{
+	PEX0_IO_PHYS_BASE,
+	PEX1_IO_PHYS_BASE,
+	PEX2_IO_PHYS_BASE,
+	PEX3_IO_PHYS_BASE,
+	PEX4_IO_PHYS_BASE,
+	PEX5_IO_PHYS_BASE,
+	PEX6_IO_PHYS_BASE,
+	PEX7_IO_PHYS_BASE,
+	PEX8_IO_PHYS_BASE,
+	PEX9_IO_PHYS_BASE
+};
+
+static u32 mv_pci_io_size[] = 
+{
+	PEX0_IO_SIZE,
+	PEX1_IO_SIZE,
+	PEX2_IO_SIZE,
+	PEX3_IO_SIZE,
+	PEX4_IO_SIZE,
+	PEX5_IO_SIZE,
+	PEX6_IO_SIZE,
+	PEX7_IO_SIZE,
+	PEX8_IO_SIZE,
+	PEX9_IO_SIZE,
+};
+
+static MV_TARGET mv_pci_io_target[] = 
+{
+	PEX0_IO,
+	PEX1_IO,
+	PEX2_IO,
+	PEX3_IO,
+	PEX4_IO,
+	PEX5_IO,
+	PEX6_IO,
+	PEX7_IO,
+	PEX8_IO,
+	PEX9_IO,
+};
+
+u32 mv_pci_mem_base_get(int ifNum)
+{
+	return mv_pci_mem_base[ifNum];
+}
+
+u32 mv_pci_mem_size_get(int ifNum)
+{
+	return mv_pci_mem_size[ifNum];
+}
+
+u32 mv_pci_io_base_get(int ifNum)
+{
+	return mv_pci_io_base[ifNum];
+}
+
+u32 mv_pci_io_size_get(int ifNum)
+{
+	return mv_pci_io_size[ifNum];
+}
+
+MV_TARGET mv_pci_io_target_get(int ifNum)
+{
+	return mv_pci_io_target[ifNum];
+}
+
+int mv_is_pci_io_mapped(int ifNum)
+{
+	/* FIXME: First 8 address decode windows are statically assigned
+	   for 8 PCIE mem BARs.
+	   This is disabled as long that no more windows are available for
+	   I/O BARs
+	*/
+	    
+	return 0;
+}
diff --git a/arch/arm/mach-avantalp/time.c b/arch/arm/mach-avantalp/time.c
new file mode 100644
index 0000000..31c5a6b
--- /dev/null
+++ b/arch/arm/mach-avantalp/time.c
@@ -0,0 +1,165 @@
+/*
+ * arch/arm/mach-avantalp/time.c
+ *
+ * Marvell Aurora SoC timer handling.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ *
+ * Timer 0 is used as free-running clocksource, while timer 1 is
+ * used as clock_event_device.
+ */
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/timer.h>
+#include <linux/init.h>
+#include <linux/clockchips.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <asm/mach/time.h>
+#include <mach/hardware.h>
+#include <asm/localtimer.h>
+#include <asm/sched_clock.h>
+
+#include <linux/clk.h>
+#include <linux/clockchips.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+
+
+#include "boardEnv/mvBoardEnvLib.h"
+#include "cpu/mvCpu.h"
+
+#define  TIMER_CTRL		(MV_CNTMR_REGS_OFFSET + 0x0000)
+#define  TIMER_WD_RELOAD	(MV_CNTMR_REGS_OFFSET + 0x0020)
+#define  TIMER_WD_VAL		(MV_CNTMR_REGS_OFFSET + 0x0024)
+#define  TIMER_CAUSE		(MV_CNTMR_REGS_OFFSET + 0x0028)
+
+#define  TIMER_EN(x)		(0x0001 << (2 * x))
+#define  TIMER_RELOAD_EN(x)	(0x0002 << (2 * x))
+#define  TIMER_RELOAD(x)	(MV_CNTMR_REGS_OFFSET + 0x0010 + (8 * x))
+#define  TIMER_VAL(x)		(MV_CNTMR_REGS_OFFSET + 0x0014 + (8 * x))
+#define  INT_TIMER_CLR(x)	(~(1 << (8*x)))
+
+#define TIMER_TURN_25MHZ(x)	(1 << (11 + x))
+#define BRIDGE_CAUSE		(MV_MBUS_REGS_OFFSET | 0x0260)
+#define BRIDGE_MASK		(MV_MBUS_REGS_OFFSET | 0x10c4)
+#define BRIDGE_INT_TIMER(x)	(1 << (24 + x))
+
+/*
+ * Number of timer ticks per jiffy.
+ */
+static u32 ticks_per_jiffy;
+static unsigned int soc_timer_id;
+
+static DEFINE_CLOCK_DATA(cd);
+
+unsigned long long notrace sched_clock(void)
+{
+	u32 cyc = ~MV_REG_READ(TIMER_VAL(soc_timer_id));
+	return cyc_to_sched_clock(&cd, cyc, (u32)~0);
+}
+
+static void notrace alp_update_sched_clock(void)
+{
+	u32 cyc = ~MV_REG_READ(TIMER_VAL(soc_timer_id));
+	update_sched_clock(&cd, cyc, (u32)~0);
+}
+
+static void __init setup_sched_clock(unsigned long tclk)
+{
+	init_sched_clock(&cd, alp_update_sched_clock, 32, tclk);
+}
+
+/*
+ * Clocksource handling.
+ */
+static cycle_t alp_clksrc_read(struct clocksource *cs)
+{
+	return (0xffffffff - MV_REG_READ(TIMER_VAL(soc_timer_id)));
+}
+
+static struct clocksource alp_clksrc = {
+	.name		= "alp_clocksource",
+	.shift		= 20,
+	.rating		= 300,
+	.read		= alp_clksrc_read,
+	.mask		= CLOCKSOURCE_MASK(32),
+	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+/*
+ * Resume timer from suspend to RAM
+ * TODO - need to implement kernel hooks for suspend/resume
+ */
+void alp_timer_resume(void)
+{
+	u32 u;
+
+	pr_info("Resuming Avantalp SOC Timer %d\n", soc_timer_id);
+
+	MV_REG_WRITE(TIMER_VAL(soc_timer_id), 0xffffffff);
+	MV_REG_WRITE(TIMER_RELOAD(soc_timer_id), 0xffffffff);
+
+	u = MV_REG_READ(BRIDGE_MASK);
+	u &= ~BRIDGE_INT_TIMER(soc_timer_id);
+	MV_REG_WRITE(BRIDGE_MASK, u);
+
+	u = MV_REG_READ(TIMER_CTRL);
+	u |= (TIMER_EN(soc_timer_id) | TIMER_RELOAD_EN(soc_timer_id) |
+			TIMER_TURN_25MHZ(soc_timer_id));
+	MV_REG_WRITE(TIMER_CTRL, u);
+}
+
+void __init alp_time_init(unsigned int fabric_clk)
+{
+	u32 u;
+
+	soc_timer_id = 0;
+
+	printk("Initializing Avantalp SOC Timer %d\n", soc_timer_id);
+
+	ticks_per_jiffy = (fabric_clk + HZ/2) / HZ;
+	
+	setup_sched_clock(fabric_clk);
+
+	/* Setup free-running clocksource timer (interrupts disabled) */
+	MV_REG_WRITE(TIMER_VAL(soc_timer_id), 0xffffffff);
+	MV_REG_WRITE(TIMER_RELOAD(soc_timer_id), 0xffffffff);
+	u = MV_REG_READ(BRIDGE_MASK);
+	u &= ~BRIDGE_INT_TIMER(soc_timer_id);
+	MV_REG_WRITE(BRIDGE_MASK, u);
+	u = MV_REG_READ(TIMER_CTRL);
+#if !defined (CONFIG_MACH_AVANTA_LP_FPGA)
+	u |= (TIMER_EN(soc_timer_id) | TIMER_RELOAD_EN(soc_timer_id) | TIMER_TURN_25MHZ(soc_timer_id));
+#else
+	u |= (TIMER_EN(soc_timer_id) | TIMER_RELOAD_EN(soc_timer_id));
+#endif
+	MV_REG_WRITE(TIMER_CTRL, u);
+	alp_clksrc.mult = clocksource_hz2mult(fabric_clk, alp_clksrc.shift);
+	clocksource_register(&alp_clksrc);
+#if 0
+#ifdef CONFIG_SMP
+	{
+		percpu_timer_setup();
+	        return;
+	}
+#endif
+#endif
+}
+
+static void alp_timer_init(void)
+{
+#if defined (CONFIG_MACH_AVANTA_LP_FPGA)
+	/* FPGA is hardcoded to 25Mhx and DSMP-A0 ref clock for the timers is 25MHz */
+	alp_time_init(25000000);
+#else
+	alp_time_init(mvCpuL2ClkGet());  /* DSMP-Z1 clock is taken from Fabric */
+#endif
+}
+
+struct sys_timer alp_timer = {
+	.init = alp_timer_init,
+};
diff --git a/arch/arm/mach-avantalp/usb.c b/arch/arm/mach-avantalp/usb.c
new file mode 100644
index 0000000..8e74eaf
--- /dev/null
+++ b/arch/arm/mach-avantalp/usb.c
@@ -0,0 +1,190 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+//#include <linux/autoconf.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+                                                                                                                             
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include "mvCommon.h"
+#include "mvDebug.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvUnitMap.h"
+#include "mvSysUsbApi.h"
+#include "usb/mvUsbRegs.h"
+#include "usb/mvUsb.h"
+
+u32 mvIsUsbHost = 0x03;
+
+#define MV_USB_DMA_MASK		0xffffffff
+#define MAX_USB_PORTS		3
+
+static char usb_dev_name[]  = "mv_udc";
+static char usb_host_name[] = "ehci_marvell";
+static char usb_bus_name[]  = "platform";
+
+
+static void mv_usb_release(struct device *dev)
+{
+    struct platform_device  *pdev = to_platform_device(dev); 
+
+    /* normally not freed */
+    printk("mv_usb_release\n");
+
+    kfree(pdev->resource);
+    kfree(pdev->dev.dma_mask);
+    kfree(pdev);
+} 
+
+int mv_usb_resume(int dev)
+{
+	int status, isHost;
+	char *name_ptr;
+
+	if (MV_FALSE == mvCtrlPwrClckGet(USB_UNIT_ID, dev)) {
+		printk(KERN_DEBUG "\nWarning Integrated USB %d is Powered Off\n", dev);
+		return -EINVAL;
+	}
+
+	/* Check if this USB is mapped to this AMP group - YY */
+	if(MV_FALSE == mvUnitMapIsMine(USB0 + dev))
+		return -EINVAL;
+
+	isHost = mvIsUsbHost & (1 << dev);
+	name_ptr = isHost ? usb_host_name : usb_dev_name;
+
+	printk(KERN_DEBUG "registered dev#%d as a %s\n", dev, name_ptr);
+	status = mvSysUsbInit(dev, isHost);
+
+	return status;
+}
+
+static int __init   mv_usb_init(void)
+{
+	int                     status, dev, num, isHost;
+	char*                   name_ptr;
+	struct platform_device* mv_usb_dev_ptr;
+	int 			irq_num[3] = {	IRQ_AURORA_USB0,
+						IRQ_AURORA_USB1,
+						IRQ_AURORA_USB2};
+
+	num = mvCtrlUsbMaxGet(); 
+	if (num > MAX_USB_PORTS) {
+		printk("WARNING: Limited USB ports number to %d\n", MAX_USB_PORTS);
+		num = MAX_USB_PORTS;
+	}
+
+	for(dev=0; dev<num; dev++)
+	{
+		if (MV_FALSE == mvCtrlPwrClckGet(USB_UNIT_ID, dev))
+		{
+			printk("\nWarning Integrated USB %d is Powered Off\n",dev);
+			continue;
+		}
+
+		/* Check if this USB is mapped to this AMP group - YY */
+		if(MV_FALSE == mvUnitMapIsMine(USB0 + dev))
+		{
+			continue;
+		}
+
+		isHost = mvIsUsbHost & (1 << dev);
+
+		if(isHost)
+			name_ptr = usb_host_name;
+		else
+			name_ptr = usb_dev_name;
+
+		printk("registered dev#%d asa %s\n",dev,name_ptr);
+		status = mvSysUsbInit(dev, isHost);
+
+		mv_usb_dev_ptr = kmalloc(sizeof(struct platform_device), GFP_KERNEL);
+		if(mv_usb_dev_ptr == NULL)
+		{
+			printk("Can't allocate platform_device structure - %d bytes\n",
+					sizeof(struct platform_device) );
+			return 1;
+		}
+		memset(mv_usb_dev_ptr, 0, sizeof(struct platform_device) );
+
+		mv_usb_dev_ptr->name               = name_ptr;
+		mv_usb_dev_ptr->id                 = dev;
+
+		mv_usb_dev_ptr->num_resources  = 2;
+
+		mv_usb_dev_ptr->resource = (struct resource*)kmalloc(2*sizeof(struct resource), GFP_KERNEL);
+		if(mv_usb_dev_ptr->resource == NULL)
+		{
+			printk("Can't allocate 2 resource structure - %d bytes\n",
+					2*sizeof(struct resource) );
+			kfree(mv_usb_dev_ptr);
+			return 1;
+		}
+		memset(mv_usb_dev_ptr->resource, 0, 2*sizeof(struct resource));
+
+		mv_usb_dev_ptr->resource[0].start =
+			( INTER_REGS_BASE | MV_USB_CORE_CAP_LENGTH_REG(dev));
+		mv_usb_dev_ptr->resource[0].end   =
+			((INTER_REGS_BASE | MV_USB_CORE_CAP_LENGTH_REG(dev)) + 4096);
+		mv_usb_dev_ptr->resource[0].flags = IORESOURCE_DMA;
+
+		mv_usb_dev_ptr->resource[1].start = irq_num[dev];
+		mv_usb_dev_ptr->resource[1].flags = IORESOURCE_IRQ;
+
+		mv_usb_dev_ptr->dev.dma_mask           = kmalloc(sizeof(u64), GFP_KERNEL);
+		*mv_usb_dev_ptr->dev.dma_mask          = MV_USB_DMA_MASK;
+
+		mv_usb_dev_ptr->dev.coherent_dma_mask  = ~0;
+		mv_usb_dev_ptr->dev.release            = mv_usb_release;
+		dev_set_name(&mv_usb_dev_ptr->dev, "%s", usb_bus_name);
+
+		printk("Marvell USB %s controller #%d: %p\n",
+				isHost ? "EHCI Host" : "Gadget", dev, mv_usb_dev_ptr);
+
+		status = platform_device_register(mv_usb_dev_ptr);
+		if (status)
+		{
+			printk("Can't register Marvell USB EHCI controller #%d, status=%d\n", 
+					dev, status);
+			return status;
+		}
+	}
+	return 0;
+}
+
+subsys_initcall(mv_usb_init);
+
diff --git a/arch/arm/mm/Kconfig b/arch/arm/mm/Kconfig
index 3f33572..5fc801b 100644
--- a/arch/arm/mm/Kconfig
+++ b/arch/arm/mm/Kconfig
@@ -383,7 +383,7 @@ config CPU_FEROCEON_OLD_ID
 	  Relevant for Feroceon-1850 and early Feroceon-2850.
 
 choice
-	prompt "Marvell Sheeva CPU Architecture"
+	prompt "CPU Architecture"
 	default CPU_SHEEVA_PJ4B_V7
 
 config CPU_SHEEVA_PJ4B_V6
@@ -434,7 +434,7 @@ config CPU_V6K
 
 # ARMv7
 config CPU_V7
-	bool "Support ARM V7 processor" if ARCH_INTEGRATOR || MACH_REALVIEW_EB || MACH_REALVIEW_PBX
+	bool "Support ARM V7 processor" if ARCH_INTEGRATOR || MACH_REALVIEW_EB || MACH_REALVIEW_PBX || ARCH_AVANTA_LP
 	select CPU_32v6K
 	select CPU_32v7
 	select CPU_ABRT_EV7
diff --git a/arch/arm/mm/Makefile b/arch/arm/mm/Makefile
index 438d093..54dd90a 100644
--- a/arch/arm/mm/Makefile
+++ b/arch/arm/mm/Makefile
@@ -96,13 +96,16 @@ obj-$(CONFIG_CPU_MOHAWK)	+= proc-mohawk.o
 obj-$(CONFIG_CPU_FEROCEON)	+= proc-feroceon.o
 #obj-$(CONFIG_CPU_V6)		+= proc-v6.o
 #obj-$(CONFIG_CPU_V6K)		+= proc-v6.o
-#obj-$(CONFIG_CPU_V7)		+= proc-v7.o
 obj-$(CONFIG_CPU_SHEEVA_PJ4B_V6)	+= proc-sheeva_pj4bv6.o
+ifeq ($(CONFIG_CPU_SHEEVA_PJ4B_V7),y)
 ifeq ($(CONFIG_ARM_LPAE),y)
 obj-$(CONFIG_CPU_SHEEVA_PJ4B_V7)	+= proc-sheeva_pj4bv7lpae.o
 else
 obj-$(CONFIG_CPU_SHEEVA_PJ4B_V7)	+= proc-sheeva_pj4bv7.o
 endif
+else
+obj-$(CONFIG_CPU_V7)		+= proc-v7.o
+endif
 
 AFLAGS_proc-v6.o	:=-Wa,-march=armv6
 AFLAGS_proc-v7.o	:=-Wa,-march=armv7-a
diff --git a/arch/arm/plat-armada/linux_oss/mvOs.h b/arch/arm/plat-armada/linux_oss/mvOs.h
index c9375bd..d86dd68 100644
--- a/arch/arm/plat-armada/linux_oss/mvOs.h
+++ b/arch/arm/plat-armada/linux_oss/mvOs.h
@@ -373,14 +373,9 @@ static inline void mvOsBridgeReorderWA(void)
  #else
  #define mvOsCacheLineFlush(handle, addr)                     \
  {                                                               \
-   DSBWA_4611(addr);						 \
-#if defined(CONFIG_SHEEVA_ERRATA_ARM_CPU_6043) || defined(CONFIG_SHEEVA_ERRATA_ARM_CPU_6124)
-	__asm__ __volatile__ ("mcr p15, 0, %0, c7, c14, 1" : : "r" (addr));\
-#else
 	__asm__ __volatile__ ("mcr p15, 0, %0, c7, c10, 1" : : "r" (addr));\
-#endif
 	__asm__ __volatile__ ("mcr p15, 0, %0, c7, c10, 4" : : "r" (addr)); \
-}
+ }
 #endif
 
 #define MV_OS_CACHE_MULTI_THRESH	256
-- 
1.7.5.4

