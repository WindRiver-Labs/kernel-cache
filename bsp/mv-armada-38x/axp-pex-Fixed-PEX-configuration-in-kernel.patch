From ed3112c766e484cbef637c9065b53922415c2ea1 Mon Sep 17 00:00:00 2001
From: Igor Patrik <igorp@marvell.com>
Date: Mon, 22 Jul 2013 10:19:54 +0200
Subject: [PATCH 0870/1825] axp:pex: Fixed PEX configuration in kernel

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 9137e1749f04851e47f3c649bcde18d38763a054

	This patch fixing PEX bus init and proper scan.
	Updates for pex.c ported for kernel 3.2, this fix pex bus init for AXP.
	Also taked update from kernel 3.5+ that replaces pcan_bus to pci_scan_root_bus

Change-Id: I286cccadc72798d87bb8e9ad86e6d219490b3847
Signed-off-by: Igor Patrik <igorp@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/2750
Tested-by: Star_Automation <star@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-armadaxp/pex.c |  189 +++++++++++++++++++++++++++++-------------
 1 files changed, 132 insertions(+), 57 deletions(-)

diff --git a/arch/arm/mach-armadaxp/pex.c b/arch/arm/mach-armadaxp/pex.c
index a3e7675..d433eb9 100644
--- a/arch/arm/mach-armadaxp/pex.c
+++ b/arch/arm/mach-armadaxp/pex.c
@@ -47,16 +47,16 @@
 
 #define MV_PEX_MASK_ABCD              (BIT24 | BIT25 | BIT26 | BIT27)
 
-static int __init mv_map_irq_0(struct pci_dev *dev, u8 slot, u8 pin);
-static int __init mv_map_irq_1(struct pci_dev *dev, u8 slot, u8 pin);
-static int __init mv_map_irq_2(struct pci_dev *dev, u8 slot, u8 pin);
-static int __init mv_map_irq_3(struct pci_dev *dev, u8 slot, u8 pin);
-static int __init mv_map_irq_4(struct pci_dev *dev, u8 slot, u8 pin);
-static int __init mv_map_irq_5(struct pci_dev *dev, u8 slot, u8 pin);
-static int __init mv_map_irq_6(struct pci_dev *dev, u8 slot, u8 pin);
-static int __init mv_map_irq_7(struct pci_dev *dev, u8 slot, u8 pin);
-static int __init mv_map_irq_8(struct pci_dev *dev, u8 slot, u8 pin);
-static int __init mv_map_irq_9(struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_0(const struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_1(const struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_2(const struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_3(const struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_4(const struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_5(const struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_6(const struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_7(const struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_8(const struct pci_dev *dev, u8 slot, u8 pin);
+static int __init mv_map_irq_9(const struct pci_dev *dev, u8 slot, u8 pin);
 
 extern u32 mv_pci_mem_size_get(int ifNum);
 extern u32 mv_pci_io_base_get(int ifNum);
@@ -126,10 +126,14 @@ void __init mv_pex_preinit(void)
 		printk("Enabled - Link UP\n");
 		/* Assign bus number 0 to first active/available bus */
 		if (pex0flg == 0) {
-			mvPexLocalBusNumSet(pexHWInf, 0xFF);
-	       		pex0flg = 1;
+			mvPexLocalBusNumSet(pexHWInf, 0x0);
+			mvPexLocalDevNumSet(pexHWInf, 0x1);
+			pex0flg = 1;
 		}
 
+		/* Clear the secondary bus number */
+		MV_REG_WRITE(PEX_SECONDARY_BUS_REG(pexHWInf), 0);
+
 		MV_REG_BIT_SET(PEX_MASK_REG(pexHWInf), MV_PEX_MASK_ABCD);
 		if (mv_is_pci_io_mapped(pexHWInf))
 		{
@@ -173,9 +177,13 @@ void mv_pex_reinit(void)
 		/* Assign bus number 0 to first active/available bus */
 		if (pex0flg == 0) {
 			mvPexLocalBusNumSet(pexHWInf, 0x0);
+			mvPexLocalDevNumSet(pexHWInf, 0x1);
 			pex0flg = 1;
 		}
 
+		/* Clear the secondary bus number */
+		MV_REG_WRITE(PEX_SECONDARY_BUS_REG(pexHWInf), 0);
+
 		MV_REG_BIT_SET(PEX_MASK_REG(pexHWInf), MV_PEX_MASK_ABCD);
 		if (mv_is_pci_io_mapped(pexHWInf))
 		{
@@ -187,18 +195,55 @@ void mv_pex_reinit(void)
 	}
 }
 
+static int  pci_read_cfg(u32 pciIf, u32 bus_num, u32 dev_no,
+		u32 func, u32 where)
+{
+	u32 cfgCmd;
+	u32 regOff = (MV_U32)where & (PXCAR_REG_NUM_MASK
+			| PXCAR_REAL_EXT_REG_NUM_MASK);
+
+	/* Creating PEX address to be passed */
+	cfgCmd  = (bus_num << PXCAR_BUS_NUM_OFFS);
+	cfgCmd |= (dev_no << PXCAR_DEVICE_NUM_OFFS);
+	cfgCmd |= (func << PXCAR_FUNC_NUM_OFFS);
+	/* lgacy register space */
+	cfgCmd |= (regOff & PXCAR_REG_NUM_MASK);
+	/* extended register space */
+	cfgCmd |= (((regOff & PXCAR_REAL_EXT_REG_NUM_MASK) >>
+		     PXCAR_REAL_EXT_REG_NUM_OFFS) << PXCAR_EXT_REG_NUM_OFFS);
+	cfgCmd |= PXCAR_CONFIG_EN;
+
+	/* Write the address to the PEX configuration address register */
+	MV_REG_WRITE(PEX_CFG_ADDR_REG(pciIf), cfgCmd);
+
+	/*
+	 * In order to let the PEX controller absorbed the address of the
+	 * read transaction we perform a validity check that the address
+	 * was written
+	 * */
+	if (cfgCmd != MV_REG_READ(PEX_CFG_ADDR_REG(pciIf)))
+		return 0xFFFFFFFF;
+
+	/* cleaning Master Abort */
+	MV_REG_BIT_SET(PEX_CFG_DIRECT_ACCESS(pciIf, PEX_STATUS_AND_COMMAND),
+			PXSAC_MABORT);
+
+	/* Read the Data returned in the PEX Data register */
+	return  MV_REG_READ(PEX_CFG_DATA_REG(pciIf));
+
+}
 
 /* Currentlly the PCI config read/write are implemented as read modify write
    to 32 bit.
    TBD: adjust it to realy use 1/2/4 byte(partial) read/write, after the pex
 	read config WA will be removed.
 */
-static int mv_pci_read_config(struct pci_bus *bus, 
+static int mv_pci_read_config(struct pci_bus *bus,
 				  unsigned int devfn, int where,
 				  int size, u32 *val)
 {
-	u32 bus_num,func,regOff,dev_no,temp, localBus;		
-	struct pci_sys_data *sysdata = (struct pci_sys_data *)bus->sysdata;	
+	u32 bus_num, func, dev_no, temp, localBus;
+	struct pci_sys_data *sysdata = (struct pci_sys_data *)bus->sysdata;
 	u32 pciIf = sysdata->mv_controller_num;
 
 	*val = 0xffffffff;
@@ -208,16 +253,18 @@ static int mv_pci_read_config(struct pci_bus *bus,
 	bus_num = bus->number;
 	dev_no = PCI_SLOT(devfn);
 
-	/* Only one device (0) is possible per interface (secondary bus enabled) */
-	if (dev_no != 0)
+	/* Our local bus is PEX so enable reading only device 0 */
+	localBus = mvPexLocalBusNumGet(pciIf);
+	if ((dev_no !=  0) && (bus_num == localBus)) {
+		DB(pr_info("PCI %d device %d illegal on local bus\n", pciIf,
+					dev_no));
 		return 0xffffffff;
+	}
 
-	func = PCI_FUNC(devfn); 
-	regOff = (MV_U32)where & (PXCAR_REG_NUM_MASK | PXCAR_REAL_EXT_REG_NUM_MASK); /* total of 12 bits: 8 legacy + 4 extended */
+	func = PCI_FUNC(devfn);
+
+	temp = pci_read_cfg(pciIf, bus_num, dev_no, func, where);
 
-	DB(printk("PCI %d read: bus = %x dev = %x func = %x regOff = %x ",pciIf, bus_num,dev_no,func,regOff));
-	
-	temp = (u32) mvPexConfigRead(pciIf, bus_num, dev_no, func, regOff);
 	switch (size) {
 		case 1:
 			temp = (temp >>  (8*(where & 0x3))) & 0xff;
@@ -230,46 +277,45 @@ static int mv_pci_read_config(struct pci_bus *bus,
 		default:
 			break;
 	}
-		
+
 	*val = temp;
 
-	DB(printk(" got %x \n",temp));
-	
-    return 0;
+	DB(pr_info("PCI %d read: bus = %x dev = %x", pciIf, bus_num, dev_no));
+	DB(pr_info(" func = %x regOff = %x val = 0x%08x\n", func, where, temp));
+
+	return 0;
 }
 
-static int mv_pci_write_config(struct pci_bus *bus, unsigned int devfn, int where,
-                           int size, u32 val)
+static int mv_pci_write_config(struct pci_bus *bus, unsigned int devfn,
+		int where, int size, u32 val)
 {
 	u32 bus_num,func,regOff,dev_no,temp, mask , shift;
 	struct pci_sys_data *sysdata = (struct pci_sys_data *)bus->sysdata;	
 	u32 pciIf = sysdata->mv_controller_num;		
+	u32 cfgCmd;
 
 	if (MV_FALSE == mvCtrlPwrClckGet(PEX_UNIT_ID, pciIf))
 		return 0xFFFFFFFF;
+
 	bus_num = bus->number;
 	dev_no = PCI_SLOT(devfn);
 	func = PCI_FUNC(devfn);
-	regOff = (MV_U32)where & (PXCAR_REG_NUM_MASK | PXCAR_REAL_EXT_REG_NUM_MASK); /* total of 12 bits: 8 legacy + 4 extended */
+	/* total of 12 bits: 8 legacy + 4 extended */
+	regOff = (MV_U32)where & (PXCAR_REG_NUM_MASK |
+			PXCAR_REAL_EXT_REG_NUM_MASK);
 
-	DB(printk("PCI %d: writing data %x size %x to bus %x dev %x func %x offs %x \n",
-			  pciIf, val,size,bus_num,dev_no,func,regOff));
 	if (size != 4)
-	{
-		temp = (u32) mvPexConfigRead(pciIf, bus_num, dev_no, func, regOff);
-	}
+		temp = pci_read_cfg(pciIf, bus_num, dev_no, func, where);
 	else
-	{
 		temp = val;
-	}
 
 	switch (size) {
 		case 1:
-			shift = (8*(where & 0x3));
+			shift = (8 * (where & 0x3));
 			mask = 0xff;
 			break;
 		case 2:
-			shift = (8*(where & 0x2));
+			shift = (8 * (where & 0x2));
 			mask = 0xffff;
 			break;
 
@@ -279,15 +325,44 @@ static int mv_pci_write_config(struct pci_bus *bus, unsigned int devfn, int wher
 			break;
 	}
 
-	temp = (temp & (~(mask<<shift))) | ((val & mask) << shift);
-	mvPexConfigWrite(pciIf, bus_num, dev_no, func, regOff, temp);
+	temp = (temp & (~(mask << shift))) | ((val & mask) << shift);
+
+	/* Creating PEX address to be passed */
+	cfgCmd  = (bus_num << PXCAR_BUS_NUM_OFFS);
+	cfgCmd |= (dev_no << PXCAR_DEVICE_NUM_OFFS);
+	cfgCmd |= (func << PXCAR_FUNC_NUM_OFFS);
+	/* lgacy register space */
+	cfgCmd |= (regOff & PXCAR_REG_NUM_MASK);
+	/* extended register space */
+	cfgCmd |= (((regOff & PXCAR_REAL_EXT_REG_NUM_MASK) >>
+		     PXCAR_REAL_EXT_REG_NUM_OFFS) << PXCAR_EXT_REG_NUM_OFFS);
+	cfgCmd |= PXCAR_CONFIG_EN;
+
+	DB(pr_info("PCI %d: write data 0x%08x size %x to bus", pciIf, temp, size));
+	DB(pr_info(" %x dev %x func %x offs %x\n", bus_num, dev_no, func, regOff));
+
+	/* Write the address to the PEX configuration address register */
+	MV_REG_WRITE(PEX_CFG_ADDR_REG(pciIf), cfgCmd);
+
+	/*
+	 * In order to let the PEX controller absorbed the address of the read
+	 * transaction we perform a validity check that the address was written
+	 */
+	if (cfgCmd != MV_REG_READ(PEX_CFG_ADDR_REG(pciIf))) {
+		pr_info("Error: mv_pci_write_config failed to write\n");
+		return 1;
+	}
+
+	/* Write the Data passed to the PEX Data register */
+	MV_REG_WRITE(PEX_CFG_DATA_REG(pciIf), temp);
+
 	return 0;
 }
 
 
 static struct pci_ops mv_pci_ops = {
-        .read   = mv_pci_read_config,
-        .write  = mv_pci_write_config,
+	.read   = mv_pci_read_config,
+	.write  = mv_pci_write_config,
 };
 
 
@@ -315,7 +390,7 @@ int __init mv_pex_setup(int nr, struct pci_sys_data *sys)
 		panic("PCI: unable to alloc resources");
 		return 0;
 	}
-                                                                                                                             
+
 	memset(res, 0, sizeof(struct resource) * 2);
 
 	/* Save the H/W if number for this PEX bus */
@@ -329,13 +404,11 @@ int __init mv_pex_setup(int nr, struct pci_sys_data *sys)
 		res[index].end   = iobase - IO_SPACE_REMAP + mv_pci_io_size_get(sys->mv_controller_num)-1;
 		res[index].name  = "PCIx IO Primary";
 		res[index].flags = IORESOURCE_IO;		
-
 		if (request_resource(&ioport_resource, &res[index]))
 			printk ("IO Request resource failed - Pci If %x\n",nr);
 		else
 			index++;
 	}
-
 	res[index].start = membase;
 	res[index].end   = membase + mv_pci_mem_size_get(sys->mv_controller_num)-1;
 	res[index].name  = "PCIx Memory Primary";
@@ -352,6 +425,7 @@ int __init mv_pex_setup(int nr, struct pci_sys_data *sys)
 	return 1;
 }
 
+
 struct pci_bus *mv_pex_scan_bus(int nr, struct pci_sys_data *sys)
 {
 	struct pci_ops *ops = &mv_pci_ops;	
@@ -359,7 +433,7 @@ struct pci_bus *mv_pex_scan_bus(int nr, struct pci_sys_data *sys)
 	MV_BOARD_PEX_INFO* boardPexInfo = mvBoardPexInfoGet();
 	MV_U32 pexNextHWInf, ifnum;
 
-	bus = pci_scan_bus(sys->busnr, ops, sys);
+	bus =  pci_scan_root_bus(NULL, sys->busnr, &mv_pci_ops, sys, &sys->resources);
 
 	/* Set the bus number in the following controller */
 	for (ifnum = (nr+1); ifnum < boardPexInfo->boardPexIfNum; ifnum++) {
@@ -370,7 +444,8 @@ struct pci_bus *mv_pex_scan_bus(int nr, struct pci_sys_data *sys)
 			continue;
 
 		if (MV_TRUE == mvCtrlPwrClckGet(PEX_UNIT_ID, pexNextHWInf)) {
-			mvPexLocalBusNumSet(pexNextHWInf, 0xFF);
+			mvPexLocalBusNumSet(pexNextHWInf, (bus->subordinate + 1));
+			mvPexLocalDevNumSet(pexNextHWInf, 0x1);
 			break;
 		}
 	}
@@ -379,52 +454,52 @@ struct pci_bus *mv_pex_scan_bus(int nr, struct pci_sys_data *sys)
 }
 
 
-static int __init mv_map_irq_0(struct pci_dev *dev, u8 slot, u8 pin)
+static int __init mv_map_irq_0(const struct pci_dev *dev, u8 slot, u8 pin)
 {	
 	return IRQ_AURORA_PCIE0;
 }
 
-static int __init mv_map_irq_1(struct pci_dev *dev, u8 slot, u8 pin)
+static int __init mv_map_irq_1(const struct pci_dev *dev, u8 slot, u8 pin)
 {
 	return IRQ_AURORA_PCIE1;
 }
 
-static int __init mv_map_irq_2(struct pci_dev *dev, u8 slot, u8 pin)
+static int __init mv_map_irq_2(const struct pci_dev *dev, u8 slot, u8 pin)
 {
 	return IRQ_AURORA_PCIE2;
 }
 
-static int __init mv_map_irq_3(struct pci_dev *dev, u8 slot, u8 pin)
+static int __init mv_map_irq_3(const struct pci_dev *dev, u8 slot, u8 pin)
 {
 	return IRQ_AURORA_PCIE3;
 }
 
-static int __init mv_map_irq_4(struct pci_dev *dev, u8 slot, u8 pin)
+static int __init mv_map_irq_4(const struct pci_dev *dev, u8 slot, u8 pin)
 {
 	return IRQ_AURORA_PCIE4;
 }
 
-static int __init mv_map_irq_5(struct pci_dev *dev, u8 slot, u8 pin)
+static int __init mv_map_irq_5(const struct pci_dev *dev, u8 slot, u8 pin)
 {
 	return IRQ_AURORA_PCIE5;
 }
 
-static int __init mv_map_irq_6(struct pci_dev *dev, u8 slot, u8 pin)
+static int __init mv_map_irq_6(const struct pci_dev *dev, u8 slot, u8 pin)
 {
 	return IRQ_AURORA_PCIE6;
 }
 
-static int __init mv_map_irq_7(struct pci_dev *dev, u8 slot, u8 pin)
+static int __init mv_map_irq_7(const struct pci_dev *dev, u8 slot, u8 pin)
 {
 	return IRQ_AURORA_PCIE7;
 }
 
-static int __init mv_map_irq_8(struct pci_dev *dev, u8 slot, u8 pin)
+static int __init mv_map_irq_8(const struct pci_dev *dev, u8 slot, u8 pin)
 {
 	return IRQ_AURORA_PCIE8;
 }
 
-static int __init mv_map_irq_9(struct pci_dev *dev, u8 slot, u8 pin)
+static int __init mv_map_irq_9(const struct pci_dev *dev, u8 slot, u8 pin)
 {
 	return IRQ_AURORA_PCIE9;
 }
-- 
1.7.5.4

