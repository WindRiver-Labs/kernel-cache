From 2a40d58338a538324b904780a2a1e3e8db09cf35 Mon Sep 17 00:00:00 2001
From: Kosta Zertsekel <konszert@marvell.com>
Date: Wed, 10 Apr 2013 17:13:06 +0300
Subject: [PATCH 0548/1825] ALP: Add interrupt support and clean some code

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 82a6f8515ff74c4a44403ac60bba859f354f57b3

Change-Id: I8664e68813a3ef366aace870cdc5c7b2869bdf1b
Signed-off-by: Kosta Zertsekel <konszert@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/1496
Reviewed-by: Eran Ben-Avi <benavi@marvell.com>
Tested-by: Eran Ben-Avi <benavi@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-avantalp/config/mvSysHwConfig.h      |    1 +
 arch/arm/mach-avantalp/core.c                      |   30 +-
 arch/arm/mach-avantalp/hwmon.c                     |   64 ++--
 arch/arm/mach-avantalp/include/mach/avantalp.h     |  307 ++++++-------------
 arch/arm/mach-avantalp/include/mach/debug-macro.S  |    2 +-
 arch/arm/mach-avantalp/include/mach/gpio.h         |   11 +-
 arch/arm/mach-avantalp/include/mach/io.h           |    4 +-
 arch/arm/mach-avantalp/include/mach/irqs.h         |  247 ++++++++++------
 arch/arm/mach-avantalp/include/mach/serial.h       |    4 +-
 arch/arm/mach-avantalp/include/mach/uncompress.h   |   28 +-
 arch/arm/mach-avantalp/irq.c                       |  316 ++++++++++----------
 arch/arm/mach-avantalp/mv_hal_if/mvSysPci.c        |    4 +-
 arch/arm/mach-avantalp/platsmp.c                   |    6 +-
 arch/arm/mach-avantalp/sysmap.c                    |    2 +-
 arch/arm/mach-avantalp/time.c                      |    6 +-
 arch/arm/mach-avantalp/usb.c                       |    4 +-
 arch/arm/plat-armada/armada_suspend.S              |   22 +-
 arch/arm/plat-armada/linux_oss/mvOs.h              |   70 +++---
 .../plat-armada/mv_drivers_lsp/mv_error/mv_error.c |   40 ++--
 .../plat-armada/mv_drivers_lsp/mv_mtd/nand_nfc.c   |    2 +-
 .../mv_drivers_lsp/mv_sata/mvLinuxIalHt.c          |    2 +-
 21 files changed, 563 insertions(+), 609 deletions(-)

diff --git a/arch/arm/mach-avantalp/config/mvSysHwConfig.h b/arch/arm/mach-avantalp/config/mvSysHwConfig.h
index 036ffb6..d01969e 100755
--- a/arch/arm/mach-avantalp/config/mvSysHwConfig.h
+++ b/arch/arm/mach-avantalp/config/mvSysHwConfig.h
@@ -39,6 +39,7 @@ disclaimer.
 #define MV_FPGA_CORE_CLK		12500000
 #endif
 
+#define INTER_REGS_BASE			INTER_REGS_VIRT_BASE
 #define CONFIG_MARVELL	1
 
 /* includes */
diff --git a/arch/arm/mach-avantalp/core.c b/arch/arm/mach-avantalp/core.c
index e621ae7..8bb876a 100755
--- a/arch/arm/mach-avantalp/core.c
+++ b/arch/arm/mach-avantalp/core.c
@@ -146,13 +146,13 @@ struct mbus_dram_target_info avantalp_mbus_dram_info;
 /**************                 Early Printk Support                **************/
 /*********************************************************************************/
 #ifdef MV_INCLUDE_EARLY_PRINTK
-#define MV_UART0_LSR 	(*(volatile unsigned char *)(INTER_REGS_BASE + 0x12000 + 0x14))
-#define MV_UART0_THR	(*(volatile unsigned char *)(INTER_REGS_BASE + 0x12000 + 0x0 ))
-#define MV_UART1_LSR    (*(volatile unsigned char *)(INTER_REGS_BASE + 0x12100 + 0x14))
-#define MV_UART1_THR    (*(volatile unsigned char *)(INTER_REGS_BASE + 0x12100 + 0x0 ))
-#define MV_SERIAL_BASE 	((unsigned char *)(INTER_REGS_BASE + 0x12000 + 0x0 ))
-//#define DEV_REG		(*(volatile unsigned int *)(INTER_REGS_BASE + 0x40000))
-//#define CLK_REG         (*(volatile unsigned int *)(INTER_REGS_BASE + 0x2011c))
+#define MV_UART0_LSR 	(*(volatile unsigned char *)(INTER_REGS_VIRT_BASE + 0x12000 + 0x14))
+#define MV_UART0_THR	(*(volatile unsigned char *)(INTER_REGS_VIRT_BASE + 0x12000 + 0x0 ))
+#define MV_UART1_LSR    (*(volatile unsigned char *)(INTER_REGS_VIRT_BASE + 0x12100 + 0x14))
+#define MV_UART1_THR    (*(volatile unsigned char *)(INTER_REGS_VIRT_BASE + 0x12100 + 0x0 ))
+#define MV_SERIAL_BASE 	((unsigned char *)(INTER_REGS_VIRT_BASE + 0x12000 + 0x0 ))
+//#define DEV_REG		(*(volatile unsigned int *)(INTER_REGS_VIRT_BASE + 0x40000))
+//#define CLK_REG         (*(volatile unsigned int *)(INTER_REGS_VIRT_BASE + 0x2011c))
 /*
  * This does not append a newline
  */
@@ -314,7 +314,7 @@ void __init avantalp_setup_cpu_mbus(void)
 	 * Setup MBUS dram target info.
 	 */
 	avantalp_mbus_dram_info.mbus_dram_target_id = TARGET_DDR;
-	addr = (void __iomem *)AXP_BRIDGE_VIRT_BASE;
+	addr = (void __iomem *)BRIDGE_VIRT_BASE;
 
 	for (i = 0, cs = 0; i < 4; i++) {
 		u32 base = readl(addr + DDR_BASE_CS_OFF(i));
@@ -491,8 +491,8 @@ static void mv_pp2_giga_pdev_register(struct platform_device *pdev)
 
 static struct resource mv_pp2_ge0_resources[] = {
 	{
-		.start          = IRQ_GBE0_FIC,
-		.end            = IRQ_GBE0_FIC,
+		.start          = IRQ_PP_PORT0_RXTX,
+		.end            = IRQ_PP_PORT0_RXTX,
 		.flags          = IORESOURCE_IRQ,
 	},
 };
@@ -514,8 +514,8 @@ static struct platform_device mv_pp2_ge0_plat = {
 
 static struct resource mv_pp2_ge2_resources[] = {
 	{
-		.start          = IRQ_GBE2_FIC,
-		.end            = IRQ_GBE2_FIC,
+		.start          = IRQ_PP_PORT1_RXTX,
+		.end            = IRQ_PP_PORT1_RXTX,
 		.flags          = IORESOURCE_IRQ,
 	},
 };
@@ -542,8 +542,8 @@ static struct mv_pp2_pdata mv_pp2_ge3_pdata = {
 
 static struct resource mv_pp2_ge3_resources[] = {
 	{
-		.start          = IRQ_GBE3_FIC,
-		.end            = IRQ_GBE3_FIC,
+		.start          = IRQ_PP_PORT2_RXTX,
+		.end            = IRQ_PP_PORT2_RXTX,
 		.flags          = IORESOURCE_IRQ,
 	},
 };
@@ -748,7 +748,7 @@ static void cpu_fabric_common_init(void)
 #endif
 
 #ifdef CONFIG_CACHE_L2X0
-	void __iomem *l2x0_base = INTER_REGS_BASE + MV_CA9X2_L2CC_OFFSET;
+	void __iomem *l2x0_base = INTER_REGS_VIRT_BASE + MV_CA9X2_L2CC_OFFSET;
 
 	/* set RAM latencies to 1 cycle for this core tile. */
 #if 0
diff --git a/arch/arm/mach-avantalp/hwmon.c b/arch/arm/mach-avantalp/hwmon.c
index eb87175..38ca7083 100644
--- a/arch/arm/mach-avantalp/hwmon.c
+++ b/arch/arm/mach-avantalp/hwmon.c
@@ -1,8 +1,4 @@
 /*
- * hwmon-axp.c - temperature monitoring driver for Dove SoC
- *
- * Inspired from other hwmon drivers
- *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; version 2 of the License.
@@ -90,23 +86,23 @@ static void axptemp_set_thresholds(unsigned int max, unsigned int min)
 {
 	u32 temp, reg;
 
-	reg = readl(INTER_REGS_BASE | PMU_THERMAL_MNGR_REG);
+	reg = readl(INTER_REGS_VIRT_BASE | PMU_THERMAL_MNGR_REG);
         reg &= ~PMU_TM_DISABLE_MASK;
-        writel(reg, (INTER_REGS_BASE | PMU_THERMAL_MNGR_REG));
+        writel(reg, (INTER_REGS_VIRT_BASE | PMU_THERMAL_MNGR_REG));
 
 	/* Set the overheat threashold & delay */
 	temp = ARMADAXP_TSEN_TEMP2RAW(max);
-	reg = readl(INTER_REGS_BASE | PMU_THERMAL_MNGR_REG);
+	reg = readl(INTER_REGS_VIRT_BASE | PMU_THERMAL_MNGR_REG);
 	reg &= ~PMU_TM_OVRHEAT_THRSH_MASK;
 	reg |= (temp << PMU_TM_OVRHEAT_THRSH_OFFS);
-	writel(reg, (INTER_REGS_BASE | PMU_THERMAL_MNGR_REG));
+	writel(reg, (INTER_REGS_VIRT_BASE | PMU_THERMAL_MNGR_REG));
 
 	/* Set the cool threshole & delay */
 	temp = ARMADAXP_TSEN_TEMP2RAW(min);
-	reg = readl(INTER_REGS_BASE | PMU_THERMAL_MNGR_REG);
+	reg = readl(INTER_REGS_VIRT_BASE | PMU_THERMAL_MNGR_REG);
 	reg &= ~PMU_TM_COOL_THRSH_MASK;
 	reg |= (temp << PMU_TM_COOL_THRSH_OFFS);
-	writel(reg, (INTER_REGS_BASE | PMU_THERMAL_MNGR_REG));
+	writel(reg, (INTER_REGS_VIRT_BASE | PMU_THERMAL_MNGR_REG));
 }
 
 static int axptemp_init_sensor(void)
@@ -115,32 +111,32 @@ static int axptemp_init_sensor(void)
 
 	/* init the TSEN sensor once */
 	/* Enable On-The-Fly Calibration mode */
-	reg = readl(INTER_REGS_BASE | TSEN_CONF_REG);
+	reg = readl(INTER_REGS_VIRT_BASE | TSEN_CONF_REG);
 	reg |= TSEN_CONF_OTF_CALIB_MASK;
-	writel(reg, (INTER_REGS_BASE | TSEN_CONF_REG));
+	writel(reg, (INTER_REGS_VIRT_BASE | TSEN_CONF_REG));
 
 	/* Set the Reference Count value */
-	reg = readl(INTER_REGS_BASE | TSEN_CONF_REG);
+	reg = readl(INTER_REGS_VIRT_BASE | TSEN_CONF_REG);
 	reg &= ~(TSEN_CONF_REF_CAL_MASK);
 	reg |= (0xf1 << 11);
-	writel(reg, (INTER_REGS_BASE | TSEN_CONF_REG));
+	writel(reg, (INTER_REGS_VIRT_BASE | TSEN_CONF_REG));
 
 	/* Do not start calibration sequence */
-	reg = readl(INTER_REGS_BASE | TSEN_CONF_REG);
+	reg = readl(INTER_REGS_VIRT_BASE | TSEN_CONF_REG);
 	reg &= ~(TSEN_CONF_START_CALIB_MASK);
-	writel(reg, (INTER_REGS_BASE | TSEN_CONF_REG));
+	writel(reg, (INTER_REGS_VIRT_BASE | TSEN_CONF_REG));
 
 	/* Initiate Soft Reset
-	reg = readl(INTER_REGS_BASE | TSEN_CONF_REG);
+	reg = readl(INTER_REGS_VIRT_BASE | TSEN_CONF_REG);
 	reg |= TSEN_CONF_SOFT_RESET_MASK;
-	writel(reg, (INTER_REGS_BASE | TSEN_CONF_REG));
+	writel(reg, (INTER_REGS_VIRT_BASE | TSEN_CONF_REG));
 	*/
 	//udelay(1000);
 
 	/* Exit from Soft Reset
-	reg = readl(INTER_REGS_BASE | TSEN_CONF_REG);
+	reg = readl(INTER_REGS_VIRT_BASE | TSEN_CONF_REG);
 	reg &= ~(TSEN_CONF_SOFT_RESET_MASK);
-	writel(reg, (INTER_REGS_BASE | TSEN_CONF_REG));
+	writel(reg, (INTER_REGS_VIRT_BASE | TSEN_CONF_REG));
 	*/
 	//udelay(10000);
 
@@ -149,12 +145,12 @@ static int axptemp_init_sensor(void)
 	axptemp_set_thresholds(temp_max, temp_min);
 
 	/* Set delays */
-	writel(ARMADAXP_OVERHEAT_DELAY, (INTER_REGS_BASE | PMU_TM_OVRHEAT_DLY_REG));
-	writel(ARMADAXP_OVERCOOL_DELAY, (INTER_REGS_BASE | PMU_TM_COOLING_DLY_REG));
+	writel(ARMADAXP_OVERHEAT_DELAY, (INTER_REGS_VIRT_BASE | PMU_TM_OVRHEAT_DLY_REG));
+	writel(ARMADAXP_OVERCOOL_DELAY, (INTER_REGS_VIRT_BASE | PMU_TM_COOLING_DLY_REG));
 
 	/* Clear & unmask cooling/overheat interrupts */
-	writel(0, (INTER_REGS_BASE | PMU_INT_CAUSE_REG));
-	writel((PMU_INT_OVRHEAT_MASK | PMU_INT_COOLING_MASK), (INTER_REGS_BASE | PMU_INT_MASK_REG));
+	writel(0, (INTER_REGS_VIRT_BASE | PMU_INT_CAUSE_REG));
+	writel((PMU_INT_OVRHEAT_MASK | PMU_INT_COOLING_MASK), (INTER_REGS_VIRT_BASE | PMU_INT_MASK_REG));
 
 	return 0;
 }
@@ -163,7 +159,7 @@ static int axptemp_read_temp(void)
 {
 	int reg;
 
-	reg = readl(INTER_REGS_BASE | TSEN_STATUS_REG);
+	reg = readl(INTER_REGS_VIRT_BASE | TSEN_STATUS_REG);
 	reg = (reg & TSEN_STATUS_TEMP_OUT_MASK) >> TSEN_STATUS_TEMP_OUT_OFFSET;
 	return ARMADAXP_TSEN_RAW2TEMP(reg);
 }
@@ -185,16 +181,16 @@ static ssize_t show_alarm(struct device *dev, struct device_attribute
 	int alarm = 0;
 	u32 reg;
 
-	reg = readl(INTER_REGS_BASE | PMU_INT_CAUSE_REG);
+	reg = readl(INTER_REGS_VIRT_BASE | PMU_INT_CAUSE_REG);
 	if (reg & PMU_INT_OVRHEAT_MASK)
 	{
 		alarm = 1;
-		writel ((reg & ~PMU_INT_OVRHEAT_MASK), (INTER_REGS_BASE | PMU_INT_CAUSE_REG));
+		writel ((reg & ~PMU_INT_OVRHEAT_MASK), (INTER_REGS_VIRT_BASE | PMU_INT_CAUSE_REG));
 	}
 	else if (reg & PMU_INT_COOLING_MASK)
 	{
 		alarm = 2;
-		writel ((reg & ~PMU_INT_COOLING_MASK), (INTER_REGS_BASE | PMU_INT_CAUSE_REG));
+		writel ((reg & ~PMU_INT_COOLING_MASK), (INTER_REGS_VIRT_BASE | PMU_INT_CAUSE_REG));
 	}
 
 	return sprintf(buf, "%d\n", alarm);
@@ -262,8 +258,8 @@ static ssize_t set_temp(struct device *dev, struct device_attribute *devattr,
 		printk(KERN_ERR "axp-temp: Invalid sensor attribute!");
 
 	/* Clear & unmask cooling/overheat interrupts */
-	writel (0, (INTER_REGS_BASE | PMU_INT_CAUSE_REG));
-	writel((PMU_INT_OVRHEAT_MASK | PMU_INT_COOLING_MASK), (INTER_REGS_BASE | PMU_INT_MASK_REG));
+	writel (0, (INTER_REGS_VIRT_BASE | PMU_INT_CAUSE_REG));
+	writel((PMU_INT_OVRHEAT_MASK | PMU_INT_COOLING_MASK), (INTER_REGS_VIRT_BASE | PMU_INT_MASK_REG));
 
 	printk(KERN_INFO "set_temp got string: %d\n", temp);
 	return count;
@@ -272,10 +268,10 @@ static ssize_t set_temp(struct device *dev, struct device_attribute *devattr,
 static irqreturn_t axptemp_irq_handler(int irq, void *data)
 {
 	u32 val, mask;
-	mask = readl(INTER_REGS_BASE | PMU_INT_MASK_REG);
-	val = (readl(INTER_REGS_BASE | PMU_INT_CAUSE_REG) & mask);
+	mask = readl(INTER_REGS_VIRT_BASE | PMU_INT_MASK_REG);
+	val = (readl(INTER_REGS_VIRT_BASE | PMU_INT_CAUSE_REG) & mask);
 	/* Mask cooling/overheat interrupt */
-	writel((mask & ~val), (INTER_REGS_BASE | PMU_INT_MASK_REG));
+	writel((mask & ~val), (INTER_REGS_VIRT_BASE | PMU_INT_MASK_REG));
 
 	printk(KERN_WARNING "WARNING: %s threshold was triggered\n",
 			((val & PMU_INT_OVRHEAT_MASK) ? "overheat" : "cooling"));
@@ -286,7 +282,7 @@ static irqreturn_t axptemp_irq_handler(int irq, void *data)
 		val &= ~PMU_INT_COOLING_MASK;
 
 	/* Clear cooling/overheat interrupt */
-	writel(val, (INTER_REGS_BASE | PMU_INT_CAUSE_REG));
+	writel(val, (INTER_REGS_VIRT_BASE | PMU_INT_CAUSE_REG));
 
 	return IRQ_HANDLED;
 }
diff --git a/arch/arm/mach-avantalp/include/mach/avantalp.h b/arch/arm/mach-avantalp/include/mach/avantalp.h
index aaa8c05..b1a5883 100644
--- a/arch/arm/mach-avantalp/include/mach/avantalp.h
+++ b/arch/arm/mach-avantalp/include/mach/avantalp.h
@@ -1,10 +1,4 @@
 /*
- * include/asm-arm/arch-aurora/dove.h
- *
- * Generic definitions for Marvell Dove MV88F6781 SoC
- *
- * Author: Tzachi Perelstein <tzachi@marvell.com>
- *
  * This file is licensed under the terms of the GNU General Public
  * License version 2.  This program is licensed "as is" without any
  * warranty of any kind, whether express or implied.
@@ -13,63 +7,36 @@
 #ifndef __ASM_ARCH_AURORA_H
 #define __ASM_ARCH_AURORA_H
 
-/****************************************************************/
-/******************* System Address Mapping *********************/
-/****************************************************************/
-
-/* The base address of memory that should be reserved for IO windows.
-** The reserved end address is 0xFFFFFFFF.
-*/
-#define CONFIG_DRAM_IO_RESERVE_BASE	0xC0000000ll
-
 /*
- * Armada-XP address maps.
- *
- * phys		virt		size
- * e0000000	@runtime	128M	PCIe-0 Memory space
- * e8000000	@runtime	128M	PCIe-1 Memory space
- * f0000000	fab00000	16M	SPI-CS0 (Flash)
- * f1000000	fbb00000	1M	Internal Registers
- * f1100000	fbc00000	1M	PCIe-0 I/O space
- * f1200000	fbd00000	1M	PCIe-1 I/O space
- * f1300000	fbe00000	1M	PCIe-2 I/O space
- * f1400000	fbf00000	1M	PCIe-3 I/O space
- * f1500000	fc000000	1M	PCIe-4 I/O space
- * f1600000	fc100000	1M	PCIe-5 I/O space
- * f1700000	fc200000	1M	PCIe-6 I/O space
- * f1800000	fc300000	1M	PCIe-7 I/O space
- * f1900000	fc400000	1M	PCIe-8 I/O space
- * f1a00000	fc500000	1M	PCIe-9 I/O space
- * f1b00000	fc600000	1M	DMA based UART
- * f4000000	fe700000	1M	Device-CS0
- * f2000000	fc700000	32M	Boot-Device CS (NOR Flash)
- * f4100000	fe800000	1M	Device-CS1 (NOR Flash)
- * f4200000	fe900000	1M	Device-CS2 (NOR Flash)
- * f4300000	fea00000	1M	Device-CS3 (NOR Flash)
- * f4400000	feb00000	1M	CESA SRAM (2 units)
- * f4500000	fec00000	1M	NETA-BM (PNC)
- * fff00000	fed00000	1M	BootROM
- * f4700000	fee00800	1M	PMU Scratch pad
- * f4800000	fef00000	1M	Legacy Nand Flash
+ * The base address of memory that should be reserved for IO windows.
+ * The reserved end address is 0xFFFFFFFF.
  */
+#define CONFIG_DRAM_IO_RESERVE_BASE	0xC0000000ll
 
 /*
  * SDRAM Address decoding
  * These values are dummy. Uboot configures these values.
  */
-#define SDRAM_CS0_BASE  		0x00000000
-#define SDRAM_CS0_SIZE  		_256M
-#define SDRAM_CS1_BASE  		0x10000000
-#define SDRAM_CS1_SIZE  		_256M
-#define SDRAM_CS2_BASE  		0x20000000
-#define SDRAM_CS2_SIZE  		_256M
-#define SDRAM_CS3_BASE  		0x30000000
-#define SDRAM_CS3_SIZE  		_256M
+#define SDRAM_CS0_BASE			0x00000000
+#define SDRAM_CS0_SIZE			_256M
+#define SDRAM_CS1_BASE			0x10000000
+#define SDRAM_CS1_SIZE			_256M
+#define SDRAM_CS2_BASE			0x20000000
+#define SDRAM_CS2_SIZE			_256M
+#define SDRAM_CS3_BASE			0x30000000
+#define SDRAM_CS3_SIZE			_256M
 
-/*
- * PEX Address Decoding
- * Virtual address not specified - remapped @runtime
+#ifdef CONFIG_MACH_AVANTA_LP_FPGA
+#define INTER_REGS_PHYS_BASE		0xF1000000
+#else
+#define INTER_REGS_PHYS_BASE		0xD0000000
+#endif
+
+/*******************************************************************************
+ * PHYS_BASE address mappings.
  */
+
+/* Virtual address not specified - remapped @runtime. */
 #define PEX0_MEM_PHYS_BASE		0xE0000000
 #define PEX0_MEM_SIZE			_32M
 #define PEX1_MEM_PHYS_BASE		0xE2000000
@@ -80,262 +47,174 @@
 #define PEX3_MEM_SIZE			_32M
 #define PEX4_MEM_PHYS_BASE		0xE8000000
 #define PEX4_MEM_SIZE			_32M
-#define PEX5_MEM_PHYS_BASE		0x0	/*TBD*/
+#define PEX5_MEM_PHYS_BASE		0x0
 #define PEX5_MEM_SIZE			_32M
-#define PEX6_MEM_PHYS_BASE		0xEA000000		
+#define PEX6_MEM_PHYS_BASE		0xEA000000
 #define PEX6_MEM_SIZE			_32M
-#define PEX7_MEM_PHYS_BASE		0x0	/*TBD*/
+#define PEX7_MEM_PHYS_BASE		0x0
 #define PEX7_MEM_SIZE			_32M
-#define PEX8_MEM_PHYS_BASE		0xEC000000		
+#define PEX8_MEM_PHYS_BASE		0xEC000000
 #define PEX8_MEM_SIZE			_32M
 #define PEX9_MEM_PHYS_BASE		0xEE000000
 #define PEX9_MEM_SIZE			_32M
 
-#ifdef CONFIG_ARM_LPAE
-
-
-#define SPI_CS0_PHYS_BASE		0xF0000000
-#define SPI_CS0_VIRT_BASE		0xFAA00000
-#define SPI_CS0_SIZE			_16M
-
-#if defined(CONFIG_MACH_ARMADA_XP_FPGA) || defined(CONFIG_MACH_AVANTA_LP_FPGA)
- #define INTER_REGS_PHYS_BASE		0xF1000000
-#else
- #define INTER_REGS_PHYS_BASE		0xD0000000
-#endif
-
-/*
- * Change INTER_REGS_BASE from 0xFBB00000 to 0xFBC00000 is mainly
- * for CONFIG_DEBUG_LL. Before paging_init, the UART port is mapped
- * by a section entry (2MB). In such case, the '1' in bit 20 is treated
- * as 'offset' and make it fail to access the UART port.
- */
-#define INTER_REGS_BASE			0xFBC00000
-
 #define PEX0_IO_PHYS_BASE		0xF1100000
-#define PEX0_IO_VIRT_BASE		0xFBE00000
 #define PEX0_IO_SIZE			_1M
 #define PEX1_IO_PHYS_BASE		0xF1200000
-#define PEX1_IO_VIRT_BASE		0xFBF00000
 #define PEX1_IO_SIZE			_1M
 #define PEX2_IO_PHYS_BASE		0xF1300000
-#define PEX2_IO_VIRT_BASE		0xFC000000
 #define PEX2_IO_SIZE			_1M
 #define PEX3_IO_PHYS_BASE		0xF1400000
-#define PEX3_IO_VIRT_BASE		0xFC100000
 #define PEX3_IO_SIZE			_1M
 #define PEX4_IO_PHYS_BASE		0xF1500000
-#define PEX4_IO_VIRT_BASE		0xFC200000
 #define PEX4_IO_SIZE			_1M
 #define PEX5_IO_PHYS_BASE		0xF1600000
-#define PEX5_IO_VIRT_BASE		0xFC300000
 #define PEX5_IO_SIZE			_1M
 #define PEX6_IO_PHYS_BASE		0xF1700000
-#define PEX6_IO_VIRT_BASE		0xFC400000
 #define PEX6_IO_SIZE			_1M
 #define PEX7_IO_PHYS_BASE		0xF1800000
-#define PEX7_IO_VIRT_BASE		0xFC500000
 #define PEX7_IO_SIZE			_1M
 #define PEX8_IO_PHYS_BASE		0xF1900000
-#define PEX8_IO_VIRT_BASE		0xFC600000
 #define PEX8_IO_SIZE			_1M
 #define PEX9_IO_PHYS_BASE		0xF1A00000
-#define PEX9_IO_VIRT_BASE		0xFC700000
 #define PEX9_IO_SIZE			_1M
 
+#define SPI_CS0_PHYS_BASE		0xF0000000
+#define SPI_CS0_SIZE			_16M
+
 #define UART_REGS_BASE			0xF1B00000
-#define UART_VIRT_BASE			0xFC800000
 #define UART_SIZE			_1M
 
 #define DEVICE_BOOTCS_PHYS_BASE		0xF2000000
-#define DEVICE_BOOTCS_VIRT_BASE		0xFCA00000
 #define DEVICE_BOOTCS_SIZE		_32M
+
 #define DEVICE_CS0_PHYS_BASE		0xF4000000
-#define DEVICE_CS0_VIRT_BASE		0xFEA00000
 #define DEVICE_CS0_SIZE			_1M
 #define DEVICE_CS1_PHYS_BASE		0xF4100000
-#define DEVICE_CS1_VIRT_BASE		0xFEB00000
 #define DEVICE_CS1_SIZE			_1M
 #define DEVICE_CS2_PHYS_BASE		0xF4200000
-#define DEVICE_CS2_VIRT_BASE		0xFEC00000
 #define DEVICE_CS2_SIZE			_1M
 #define DEVICE_CS3_PHYS_BASE		0xF4300000
-#define DEVICE_CS3_VIRT_BASE		0xFED00000
 #define DEVICE_CS3_SIZE			_1M
 
 #define CRYPT_ENG_PHYS_BASE(chan)	((chan == 0) ? 0xC8010000 : 0xF4480000)
-#define CRYPT_ENG_VIRT_BASE(chan)	((chan == 0) ? 0xFEE00000 : 0xFEE10000)
 #define CRYPT_ENG_SIZE			_64K
 
-
-#ifdef CONFIG_ARMADA_XP_REV_Z1
-#define XOR0_PHYS_BASE                 (INTER_REGS_PHYS_BASE | 0x60800)
-#define XOR1_PHYS_BASE                 (INTER_REGS_PHYS_BASE | 0x60900)
-#else
 #define XOR0_PHYS_BASE			(INTER_REGS_PHYS_BASE | 0x60900)
 #define XOR1_PHYS_BASE			(INTER_REGS_PHYS_BASE | 0xF0900)
-#endif
 #define XOR0_HIGH_PHYS_BASE		(INTER_REGS_PHYS_BASE | 0x60B00)
 #define XOR1_HIGH_PHYS_BASE		(INTER_REGS_PHYS_BASE | 0xF0B00)
 
 #define PNC_BM_PHYS_BASE		0xF4500000
-#define PNC_BM_VIRT_BASE		0xFEF00000
 #define PNC_BM_SIZE			_1M
 
 #define BOOTROM_PHYS_BASE		0xFFF00000
-#define BOOTROM_VIRT_BASE		0xFF000000
 #define BOOTROM_SIZE			_1M
 
 #define PMU_SCRATCH_PHYS_BASE		0xF4700000
-#define PMU_SCRATCH_VIRT_BASE		0xFF100000
 #define PMU_SCRATCH_SIZE		_1M
 
 #define LEGACY_NAND_PHYS_BASE		0xF4800000
-#define LEGACY_NAND_VIRT_BASE		0xFF200000
 #define LEGACY_NAND_SIZE		_1M
 
-#define	LCD_PHYS_BASE			(INTER_REGS_PHYS_BASE | 0xE0000)
+#define NFC_PHYS_BASE			(INTER_REGS_PHYS_BASE | 0xD0000)
+
+/*******************************************************************************
+ * VIRT_BASE address mappings.
+ *
+ * Change INTER_REGS_VIRT_BASE from 0xFBB00000 to 0xFBC00000 is mainly
+ * for CONFIG_DEBUG_LL. Before paging_init, the UART port is mapped
+ * by a section entry (2MB). In such case, the '1' in bit 20 is treated
+ * as 'offset' and make it fail to access the UART port.
+ */
+
+/* CONFIG_ARM_LPAE - two sets of VIRT/PHYS base defines to respect LPAE */
+#ifdef CONFIG_ARM_LPAE
+
+#define SPI_CS0_VIRT_BASE		0xFAA00000
+#define INTER_REGS_VIRT_BASE		0xFBC00000
+
+#define PEX0_IO_VIRT_BASE		0xFBE00000
+#define PEX1_IO_VIRT_BASE		0xFBF00000
+#define PEX2_IO_VIRT_BASE		0xFC000000
+#define PEX3_IO_VIRT_BASE		0xFC100000
+#define PEX4_IO_VIRT_BASE		0xFC200000
+#define PEX5_IO_VIRT_BASE		0xFC300000
+#define PEX6_IO_VIRT_BASE		0xFC400000
+#define PEX7_IO_VIRT_BASE		0xFC500000
+#define PEX8_IO_VIRT_BASE		0xFC600000
+#define PEX9_IO_VIRT_BASE		0xFC700000
+
+#define UART_VIRT_BASE			0xFC800000
+
+#define DEVICE_BOOTCS_VIRT_BASE		0xFCA00000
+#define DEVICE_CS0_VIRT_BASE		0xFEA00000
+#define DEVICE_CS1_VIRT_BASE		0xFEB00000
+#define DEVICE_CS2_VIRT_BASE		0xFEC00000
+#define DEVICE_CS3_VIRT_BASE		0xFED00000
 
-#define AXP_NFC_PHYS_BASE	(INTER_REGS_PHYS_BASE | 0xD0000)
+#define CRYPT_ENG_VIRT_BASE(chan)	((chan == 0) ? 0xFEE00000 : 0xFEE10000)
+#define PNC_BM_VIRT_BASE		0xFEF00000
+#define BOOTROM_VIRT_BASE		0xFF000000
+#define PMU_SCRATCH_VIRT_BASE		0xFF100000
+#define LEGACY_NAND_VIRT_BASE		0xFF200000
 
 #else /* !CONFIG_ARM_LPAE */
 
-#define SPI_CS0_PHYS_BASE		0xF0000000
 #define SPI_CS0_VIRT_BASE		0xFAB00000
-#define SPI_CS0_SIZE			_16M
-
-#ifdef CONFIG_MACH_AVANTA_LP_FPGA
- #define INTER_REGS_PHYS_BASE		0xF1000000
-#else
- #define INTER_REGS_PHYS_BASE		0xD0000000
-#endif
-#define INTER_REGS_BASE			0xFBB00000
+#define INTER_REGS_VIRT_BASE		0xFBB00000
 
-#define PEX0_IO_PHYS_BASE		0xF1100000
 #define PEX0_IO_VIRT_BASE		0xFBC00000
-#define PEX0_IO_SIZE			_1M
-#define PEX1_IO_PHYS_BASE		0xF1200000
 #define PEX1_IO_VIRT_BASE		0xFBD00000
-#define PEX1_IO_SIZE			_1M
-#define PEX2_IO_PHYS_BASE		0xF1300000
 #define PEX2_IO_VIRT_BASE		0xFBE00000
-#define PEX2_IO_SIZE			_1M
-#define PEX3_IO_PHYS_BASE		0xF1400000
 #define PEX3_IO_VIRT_BASE		0xFBF00000
-#define PEX3_IO_SIZE			_1M
-#define PEX4_IO_PHYS_BASE		0xF1500000
 #define PEX4_IO_VIRT_BASE		0xFC000000
-#define PEX4_IO_SIZE			_1M
-#define PEX5_IO_PHYS_BASE		0xF1600000
 #define PEX5_IO_VIRT_BASE		0xFC100000
-#define PEX5_IO_SIZE			_1M
-#define PEX6_IO_PHYS_BASE		0xF1700000
 #define PEX6_IO_VIRT_BASE		0xFC200000
-#define PEX6_IO_SIZE			_1M
-#define PEX7_IO_PHYS_BASE		0xF1800000
 #define PEX7_IO_VIRT_BASE		0xFC300000
-#define PEX7_IO_SIZE			_1M
-#define PEX8_IO_PHYS_BASE		0xF1900000
 #define PEX8_IO_VIRT_BASE		0xFC400000
-#define PEX8_IO_SIZE			_1M
-#define PEX9_IO_PHYS_BASE		0xF1A00000
 #define PEX9_IO_VIRT_BASE		0xFC500000
-#define PEX9_IO_SIZE			_1M
 
-#define UART_REGS_BASE			0xF1B00000
 #define UART_VIRT_BASE			0xFC600000
-#define UART_SIZE			_1M
 
-#define DEVICE_BOOTCS_PHYS_BASE		0xF2000000
 #define DEVICE_BOOTCS_VIRT_BASE		0xFC700000
-#define DEVICE_BOOTCS_SIZE		_32M
-#define DEVICE_CS0_PHYS_BASE		0xF4000000
 #define DEVICE_CS0_VIRT_BASE		0xFE700000
-#define DEVICE_CS0_SIZE			_1M
-#define DEVICE_CS1_PHYS_BASE		0xF4100000
 #define DEVICE_CS1_VIRT_BASE		0xFE800000
-#define DEVICE_CS1_SIZE			_1M
-#define DEVICE_CS2_PHYS_BASE		0xF4200000
 #define DEVICE_CS2_VIRT_BASE		0xFE900000
-#define DEVICE_CS2_SIZE			_1M
-#define DEVICE_CS3_PHYS_BASE		0xF4300000
 #define DEVICE_CS3_VIRT_BASE		0xFEA00000
-#define DEVICE_CS3_SIZE			_1M
 
-#define CRYPT_ENG_PHYS_BASE(chan)	((chan == 0) ? 0xC8010000 : 0xF4480000)
 #define CRYPT_ENG_VIRT_BASE(chan)	((chan == 0) ? 0xFEB00000 : 0xFEB10000)
-#define CRYPT_ENG_SIZE			_64K
-
-
-#ifdef CONFIG_ARMADA_XP_REV_Z1
-#define XOR0_PHYS_BASE                 (INTER_REGS_PHYS_BASE | 0x60800)
-#define XOR1_PHYS_BASE                 (INTER_REGS_PHYS_BASE | 0x60900)
-#else
-#define XOR0_PHYS_BASE			(INTER_REGS_PHYS_BASE | 0x60900)
-#define XOR1_PHYS_BASE			(INTER_REGS_PHYS_BASE | 0xF0900)
-#endif
-#define XOR0_HIGH_PHYS_BASE		(INTER_REGS_PHYS_BASE | 0x60B00)
-#define XOR1_HIGH_PHYS_BASE		(INTER_REGS_PHYS_BASE | 0xF0B00)
-
-#define PNC_BM_PHYS_BASE		0xF4500000
 #define PNC_BM_VIRT_BASE		0xFEC00000
-#define PNC_BM_SIZE			_1M
-
-#define BOOTROM_PHYS_BASE		0xFFF00000
 #define BOOTROM_VIRT_BASE		0xFED00000
-#define BOOTROM_SIZE			_1M
-
-
-#define PMU_SCRATCH_PHYS_BASE		0xF4700000
 #define PMU_SCRATCH_VIRT_BASE		0xFEE00000
-#define PMU_SCRATCH_SIZE		_1M
-
-#define LEGACY_NAND_PHYS_BASE		0xF4800000
 #define LEGACY_NAND_VIRT_BASE		0xFEF00000
-#define LEGACY_NAND_SIZE		_1M
-
-#define	LCD_PHYS_BASE			(INTER_REGS_PHYS_BASE | 0xE0000)
-
-#define AXP_NFC_PHYS_BASE	(INTER_REGS_PHYS_BASE | 0xD0000)
 
 #endif /* CONFIG_ARM_LPAE */
 
 /*
  * Linux native definitiotns
  */
-#define SDRAM_OPERATION_REG		(INTER_REGS_BASE | 0x1418)
-#define SDRAM_CONFIG_REG		(INTER_REGS_BASE | 0x1400)
-#define SDRAM_DLB_EVICT_REG		(INTER_REGS_BASE | 0x170C)
-
-#define AXP_UART_PHYS_BASE(port)	(INTER_REGS_PHYS_BASE | 0x12000 + (port * 0x100))
-#define DDR_VIRT_BASE			(INTER_REGS_BASE | 0x00000)
-#define AXP_BRIDGE_VIRT_BASE		(INTER_REGS_BASE | 0x20000)
-#define AXP_BRIDGE_PHYS_BASE		(INTER_REGS_PHYS_BASE | 0x20000)
+#define SDRAM_OPERATION_REG		(INTER_REGS_VIRT_BASE | 0x1418)
+#define SDRAM_CONFIG_REG		(INTER_REGS_VIRT_BASE | 0x1400)
+#define SDRAM_DLB_EVICT_REG		(INTER_REGS_VIRT_BASE | 0x170C)
+
+#define UART_PHYS_BASE(port)		(INTER_REGS_PHYS_BASE | 0x12000 \
+						+ (port * 0x100))
+#define DDR_VIRT_BASE			(INTER_REGS_VIRT_BASE | 0x00000)
 #define DDR_WINDOW_CPU_BASE		(DDR_VIRT_BASE | 0x1500)
-#define AXP_SW_TRIG_IRQ			(AXP_BRIDGE_VIRT_BASE | 0x0A04)
-#define AXP_SW_TRIG_IRQ_PHYS		(AXP_BRIDGE_PHYS_BASE | 0x0A04)
-#define AXP_SW_TRIG_IRQ_CPU_TARGET_OFFS	8
-#define AXP_SW_TRIG_IRQ_INITID_MASK	0x1F
-#define AXP_PER_CPU_BASE		(AXP_BRIDGE_VIRT_BASE | 0x1000)
-#define AXP_IRQ_VIRT_BASE		(AXP_PER_CPU_BASE)
-#define AXP_CPU_INTACK			0xB4
-#define AXP_IRQ_SEL_CAUSE_OFF		0xA0
-#define AXP_IN_DOORBELL_CAUSE		0x78
-#define AXP_IN_DRBEL_CAUSE			(AXP_PER_CPU_BASE | 0x78)
-#define AXP_IN_DRBEL_MSK			(AXP_PER_CPU_BASE | 0x7c)
-
-#ifdef CONFIG_MACH_ARMADA_XP_FPGA
-#define AXP_CPU_RESUME_ADDR_REG(cpu)	(AXP_BRIDGE_VIRT_BASE | 0x984)
-#else
-#define AXP_CPU_RESUME_ADDR_REG(cpu)	(AXP_BRIDGE_VIRT_BASE | (0x2124+(cpu)*0x100))
-#endif
-#define AXP_CPU_RESUME_CTRL_REG		(AXP_BRIDGE_VIRT_BASE | 0x988)
-#define AXP_CPU_RESET_REG(cpu)		(AXP_BRIDGE_VIRT_BASE | (0x800+(cpu)*8))
-#define AXP_CPU_RESET_OFFS		0
-
-#define AXP_L2_CLEAN_WAY_REG		(INTER_REGS_BASE | 0x87BC) 
-#define AXP_L2_MNTNC_STAT_REG		(INTER_REGS_BASE | 0x8704)
-#define AXP_SNOOP_FILTER_PHYS_REG	(INTER_REGS_PHYS_BASE | 0x21020)
-#define AXP_REVISION_ID_PHYS_REG	(INTER_REGS_PHYS_BASE | 0x40008)
-#define AXP_REVISION_ID_VIRT_REG	(INTER_REGS_BASE | 0x40008)
-#endif
+
+#define BRIDGE_VIRT_BASE		(INTER_REGS_VIRT_BASE | 0x20000)
+#define BRIDGE_PHYS_BASE		(INTER_REGS_PHYS_BASE | 0x20000)
+#define SW_TRIG_IRQ			(BRIDGE_VIRT_BASE | 0x0A04)
+#define SW_TRIG_IRQ_PHYS		(BRIDGE_PHYS_BASE | 0x0A04)
+#define SW_TRIG_IRQ_CPU_TARGET_OFFS	8
+#define SW_TRIG_IRQ_INITID_MASK	0x1F
+#define PER_CPU_BASE			(BRIDGE_VIRT_BASE | 0x1000)
+#define IRQ_VIRT_BASE			(PER_CPU_BASE)
+#define CPU_INTACK			0xB4
+#define IRQ_SEL_CAUSE_OFF		0xA0
+#define IN_DOORBELL_CAUSE		0x78
+#define IN_DRBEL_CAUSE			(PER_CPU_BASE | 0x78)
+#define IN_DRBEL_MSK			(PER_CPU_BASE | 0x7c)
+
+#endif /* __ASM_ARCH_AURORA_H */
diff --git a/arch/arm/mach-avantalp/include/mach/debug-macro.S b/arch/arm/mach-avantalp/include/mach/debug-macro.S
index 579133c..0c4439d 100644
--- a/arch/arm/mach-avantalp/include/mach/debug-macro.S
+++ b/arch/arm/mach-avantalp/include/mach/debug-macro.S
@@ -11,7 +11,7 @@
 	
 	.macro  addruart, rp, rv, tmp
 	ldr     \rp, =INTER_REGS_PHYS_BASE
-	ldr	\rv, =INTER_REGS_BASE
+	ldr	\rv, =INTER_REGS_VIRT_BASE
 	orr     \rp, \rp, #0x00012000
         orr     \rv, \rv, #0x00012000
 #ifdef CONFIG_MV_UART_PORT
diff --git a/arch/arm/mach-avantalp/include/mach/gpio.h b/arch/arm/mach-avantalp/include/mach/gpio.h
index 9c23bc8..1628eeb 100644
--- a/arch/arm/mach-avantalp/include/mach/gpio.h
+++ b/arch/arm/mach-avantalp/include/mach/gpio.h
@@ -34,17 +34,20 @@
 
 static inline int gpio_to_irq(int pin)
 {
-	if (pin < NR_GPIO_IRQS)
-		return pin + IRQ_GPIO_START;
+	if (pin < NR_IRQS_GLOB_GPIO)
+		return pin + IRQ_START_GLOB_GPIO;
 
+	WARN(1, "%s: Error: wrong gpio pin number (%d)\n", __func__, pin);
 	return -EINVAL;
 }
 
 static inline int irq_to_gpio(int irq)
 {
-	if (IRQ_GPIO_START < irq && irq < NR_IRQS)
-		return irq - IRQ_GPIO_START;
+	if (irq >= IRQ_START_GLOB_GPIO &&
+	    irq <  IRQ_START_GLOB_GPIO + NR_IRQS_GLOB_GPIO)
+		return irq - IRQ_START_GLOB_GPIO;
 
+	WARN(1, "%s: Error: wrong irq number (%d)\n", __func__, irq);
 	return -EINVAL;
 }
 
diff --git a/arch/arm/mach-avantalp/include/mach/io.h b/arch/arm/mach-avantalp/include/mach/io.h
index f5f9e1b..9d44c14 100644
--- a/arch/arm/mach-avantalp/include/mach/io.h
+++ b/arch/arm/mach-avantalp/include/mach/io.h
@@ -18,8 +18,8 @@
 
 #ifdef CONFIG_AURORA_IO_CACHE_COHERENCY
 #define dma_io_sync()	do {				\
-	writel(0x1, INTER_REGS_BASE + 0x21810);		\
-	while (readl(INTER_REGS_BASE + 0x21810) & 0x1);	\
+	writel(0x1, INTER_REGS_VIRT_BASE + 0x21810);		\
+	while (readl(INTER_REGS_VIRT_BASE + 0x21810) & 0x1);	\
 } while (0)
 #else
 #define dma_io_sync()	do { } while (0)
diff --git a/arch/arm/mach-avantalp/include/mach/irqs.h b/arch/arm/mach-avantalp/include/mach/irqs.h
index a387ab2..ea49b39 100644
--- a/arch/arm/mach-avantalp/include/mach/irqs.h
+++ b/arch/arm/mach-avantalp/include/mach/irqs.h
@@ -7,30 +7,25 @@
 #ifndef __ASM_ARCH_IRQS_H
 #define __ASM_ARCH_IRQS_H
 
-#define IRQ_LOCALTIMER			29
-#define IRQ_LOCALWDOG			30
-#define NR_IRQS				192
-
-#define IRQ_IN_DRBL_LOW			0
-#define IRQ_IN_DRBL_HIGH		1
-#define IRQ_OUT_DRBL			2
-#define IRQ_MP				3
-#define IRQ_SOC_ERROR			4
-#define IRQ_TIMER0			5
-#define IRQ_TIMER1			6
-#define IRQ_WD				7
-
-#define IRQ_GBE0_FIC			8
-#define IRQ_GBE0_SIC			9
-#define IRQ_GBE1_FIC			10
-#define IRQ_GBE1_SIC			11
-#define IRQ_GBE2_FIC			12
-#define IRQ_GBE2_SIC			13
-#define IRQ_GBE3_FIC			14
-#define IRQ_GBE3_SIC			15
-
-#define IRQ_LCD				29
-#define IRQ_SPI				33
+/*
+ * Software Generated Interrupts (SGI)
+ */
+#define IRQ_SGI_0			0
+#define IRQ_SGI_15			15
+
+/*
+ * Private Peripheral Interrupts (PPI)
+ */
+#define IRQ_CPU_GLOB_TIMER0		27
+#define IRQ_MPIC_PPI_FIQ		28
+#define IRQ_CPU_LOCAL_TIMER		29
+#define IRQ_CPU_LOCAL_WD		30
+#define IRQ_MPIC_PPI_IRQ		31
+
+/*
+ * Shared Peripheral Interrupts (SPI)
+ */
+#define IRQ_SPI0			33
 #define IRQ_I2C0			34
 #define IRQ_I2C1			35
 
@@ -45,95 +40,173 @@
 #define IRQ_USB0			48
 #define IRQ_USB1			49
 
+#define IRQ_CESA0			51
+#define IRQ_CESA1			52
+
 #define IRQ_RTC				53
 
-#define IRQ_XOR00			54
-#define IRQ_XOR01			55
+#define IRQ_XOR0_CHAN0			54
+#define IRQ_XOR0_CHAN1			55
 
-#define IRQ_BM				56
 #define IRQ_SDIO			57
 #define IRQ_SATA0			58
 #define IRQ_TDM				59
-#define IRQ_SATA1			60
 
 #define IRQ_PCIE0			61
 #define IRQ_PCIE1			65
-#define IRQ_PCI0			61
-
-#define IRQ_GBE0			69
-#define IRQ_GBE0_RX			70
-#define IRQ_GBE0_TX			71
-#define IRQ_GBE0_MISC			72
-#define IRQ_GBE1			73
-#define IRQ_GBE1_RX			74
-#define IRQ_GBE1_TX			75
-#define IRQ_GBE1_MISC			76
-#define IRQ_GBE2			77
-#define IRQ_GBE2_RX			78
-#define IRQ_GBE2_TX			79
-#define IRQ_GBE2_MISC			80
-
-#define IRQ_GPIO_0_7			85
-#define IRQ_GPIO_8_15			86
-#define IRQ_GPIO_16_23			87
-#define IRQ_GPIO_24_31			88
-#define IRQ_GPIO_32_39			90
-#define IRQ_GPIO_40_47			91
-#define IRQ_GPIO_48_55			92
-#define IRQ_GPIO_56_63			93
-#define IRQ_GPIO_64_66			94
-
-#define IRQ_XOR10			97
-#define IRQ_XOR11			98
-
-#define IRQ_SHARE_INB_DB0		99
-#define IRQ_SHARE_INB_DB1		100
-#define IRQ_SHARE_INB_DB2		101
-
-#define IRQ_PCIE2			102
-#define IRQ_PCIE3			103
-
-#define IRQ_PMU				110
+
+#define IRQ_PP_PORT0_RXTX		69
+#define IRQ_PP_MISC			72
+#define IRQ_PP_PORT1_RXTX		73
+#define IRQ_PP_PORT2_RXTX		77
+#define IRQ_PP_PORT7_RXTX		81
+
+#define IRQ_GOP				82 /* Group of Ports (GOP) */
+#define IRQ_PON				83
+
+#define IRQ_ETH_COMPLEX			84
+
+#define IRQ_GLOB_GPIO_0_7		85
+#define IRQ_GLOB_GPIO_8_15		86
+#define IRQ_GLOB_GPIO_16_23		87
+#define IRQ_GLOB_GPIO_24_31		88
+
+#define IRQ_DYING_GASP			89
+
+#define IRQ_GLOB_GPIO_32_39		90
+#define IRQ_GLOB_GPIO_40_47		91
+#define IRQ_GLOB_GPIO_48_55		92
+#define IRQ_GLOB_GPIO_56_63		93
+#define IRQ_GLOB_GPIO_64_66		94
+
+#define IRQ_SPI1			95
+
+#define IRQ_WD				96
+
+#define IRQ_XOR1_CHAN0			97
+#define IRQ_XOR1_CHAN1			98
+
+#define IRQ_GLOB_INB_DOOR_BELL_SUMMARY0	99
+#define IRQ_GLOB_INB_DOOR_BELL_SUMMARY1	100
+#define IRQ_GLOB_INB_DOOR_BELL_SUMMARY2	101
+
+#define IRQ_AUDIO			107
+#define IRQ_CODEC_SUMMARY		109
+
+#define IRQ_THERMAL			110
 
 #define IRQ_DRAM			111
 
-#define IRQ_NET_WKUP0			112
+#define IRQ_NET_WAKE_UP			112
 
 #define IRQ_NFC				116
 
-#define IRQ_OVRCL			115
+#define IRQ_SOC_MISC_SUMMARY		117
 
-#define IRQ_MAIN_INTS_NUM		116
+#define IRQ_DRAGONITE			118
 
-#define MAX_PER_CPU_IRQ_NUMBER		15
+/*
+ * Global GPIO interrupts
+ */
+#define IRQ_START_GLOB_GPIO		192
+#define NR_IRQS_GLOB_GPIO		67
+#define IRQ_GLOB_GPIO(gpio_irq)		(gpio_irq >= NR_IRQS_GLOB_GPIO ? \
+			NR_IRQS_GLOB_GPIO : IRQ_START_GLOB_GPIO + gpio_irq)
 
 /*
- * General Purpose Pins
+ * Global PCIe MSI interrupts
  */
-#define IRQ_GPIO_START			128
-#define NR_GPIO_IRQS			63
-#define IRQ_SHARED_START		32
+#define IRQ_START_GLOB_MSI		(IRQ_START_GLOB_GPIO + NR_IRQS_GLOB_GPIO)
+#define NR_IRQS_GLOB_MSI		96
+#define IRQ_GLOB_MSI(msi_irq)		(msi_irq >= NR_IRQS_GLOB_MSI ? \
+			NR_IRQS_GLOB_MSI : NR_IRQS_GLOB_MSI + msi_irq)
 
 /*
- * MSI interrupts
+ * SoC private interrupts
  */
-#define NR_PRIVATE_MSI_GROUP		16
-#define NR_PRIVATE_MSI_IRQS		NR_PRIVATE_MSI_GROUP
-#define NR_MSI_IRQS			NR_PRIVATE_MSI_IRQS
-#define IRQ_MSI_START			(IRQ_GPIO_START + NR_GPIO_IRQS)
-#define GPP_IRQ_TYPE_LEVEL		0
-#define GPP_IRQ_TYPE_CHANGE_LEVEL	1
+#define IRQ_START_PRIV_SOC_PPI		(IRQ_START_GLOB_MSI + NR_IRQS_GLOB_MSI)
+#define NR_IRQS_PRIV_SOC_PPI		24
+
+#define IRQ_PRIV_INB_DOOR_BELL_SUMMARY0		(IRQ_START_PRIV_SOC_PPI + 0)
+#define IRQ_PRIV_INB_DOOR_BELL_SUMMARY1		(IRQ_START_PRIV_SOC_PPI + 1)
+#define IRQ_PRIV_OUT_DOOR_BELL_SUMMARY		(IRQ_START_PRIV_SOC_PPI + 2)
+#define IRQ_PRIV_MP_LOCAL_SUMMARY		(IRQ_START_PRIV_SOC_PPI + 3)
+#define IRQ_PRIV_SOC_ERROR_SUMMARY		(IRQ_START_PRIV_SOC_PPI + 4)
+#define IRQ_PRIV_SOC_PRIV_TIMER0		(IRQ_START_PRIV_SOC_PPI + 5)
+#define IRQ_PRIV_SOC_PRIV_TIMER1		(IRQ_START_PRIV_SOC_PPI + 6)
+#define IRQ_PRIV_PP_PORT0_RXTX			(IRQ_START_PRIV_SOC_PPI + 9)
+#define IRQ_PRIV_PP_PORT1_RXTX			(IRQ_START_PRIV_SOC_PPI + 11)
+#define IRQ_PRIV_PP_PORT2_RXTX			(IRQ_START_PRIV_SOC_PPI + 13)
+#define IRQ_PRIV_PP_PORT7_RXTX			(IRQ_START_PRIV_SOC_PPI + 15)
+#define IRQ_PRIV_GPIO_0_7			(IRQ_START_PRIV_SOC_PPI + 16)
+#define IRQ_PRIV_GPIO_8_15			(IRQ_START_PRIV_SOC_PPI + 17)
+#define IRQ_PRIV_GPIO_16_23			(IRQ_START_PRIV_SOC_PPI + 18)
+#define IRQ_PRIV_GPIO_24_31			(IRQ_START_PRIV_SOC_PPI + 19)
+#define IRQ_PRIV_GPIO_32_39			(IRQ_START_PRIV_SOC_PPI + 20)
+#define IRQ_PRIV_GPIO_40_47			(IRQ_START_PRIV_SOC_PPI + 21)
+#define IRQ_PRIV_GPIO_48_55			(IRQ_START_PRIV_SOC_PPI + 22)
+#define IRQ_PRIV_GPIO_56_63			(IRQ_START_PRIV_SOC_PPI + 23)
+#define IRQ_PRIV_GPIO_64_66			(IRQ_START_PRIV_SOC_PPI + 24)
 
 /*
- * Error interrupts
+ * Private GPIO interrupts
  */
-#define INT_ERR_CESA0			0
-#define INT_ERR_DEVBUS			1
+#define IRQ_START_PRIV_GPIO	(IRQ_START_PRIV_SOC_PPI + NR_IRQS_PRIV_SOC_PPI)
+#define NR_IRQS_PRIV_GPIO	67
+#define IRQ_PRIV_GPIO(gpio_irq)		(gpio_irq >= NR_IRQS_PRIV_GPIO ? \
+			NR_IRQS_PRIV_GPIO : IRQ_START_PRIV_GPIO + gpio_irq)
 
 /*
- * IRQ HAL remapping
+ * Private PCIe MSI interrupts
  */
-#define NET_TH_RXTX_IRQ_NUM(x)		(IRQ_GBE0_FIC + ((x) * 2))
-#define SATA_IRQ_NUM			(IRQ_SATA0)
-#define CESA_IRQ(chan)			IRQ_CRYPTO(chan)
-#endif
+#define IRQ_START_PRIV_MSI		(IRQ_START_PRIV_GPIO + NR_IRQS_PRIV_GPIO)
+#define NR_IRQS_PRIV_MSI		32
+#define IRQ_PRIV_MSI(msi_irq)		(msi_irq >= NR_IRQS_PRIV_MSI ? \
+			NR_IRQS_PRIV_MSI : IRQ_START_PRIV_MSI + msi_irq)
+
+/*
+ * SoC error interrupts
+ */
+#define IRQ_START_PRIV_ERROR		(IRQ_START_PRIV_MSI + NR_IRQS_PRIV_MSI)
+#define NR_IRQS_PRIV_ERROR		50
+
+#define IRQ_PRIV_ERROR_CESA0		(IRQ_START_PRIV_ERROR + 0)
+#define IRQ_PRIV_ERROR_DEV_BUS		(IRQ_START_PRIV_ERROR + 1)
+#define IRQ_PRIV_ERROR_XOR1		(IRQ_START_PRIV_ERROR + 3)
+#define IRQ_PRIV_ERROR_PCIE0		(IRQ_START_PRIV_ERROR + 4)
+#define IRQ_PRIV_ERROR_PCIE1		(IRQ_START_PRIV_ERROR + 5)
+#define IRQ_PRIV_ERROR_CESA1		(IRQ_START_PRIV_ERROR + 7)
+#define IRQ_PRIV_ERROR_USB		(IRQ_START_PRIV_ERROR + 8)
+#define IRQ_PRIV_ERROR_DRAM		(IRQ_START_PRIV_ERROR + 9)
+#define IRQ_PRIV_ERROR_XOR0		(IRQ_START_PRIV_ERROR + 10)
+#define IRQ_PRIV_ERROR_SATA0		(IRQ_START_PRIV_ERROR + 17)
+#define IRQ_PRIV_ERROR_TDM		(IRQ_START_PRIV_ERROR + 20)
+#define IRQ_PRIV_ERROR_NAND		(IRQ_START_PRIV_ERROR + 21)
+#define IRQ_PRIV_ERROR_L2_DECODE	(IRQ_START_PRIV_ERROR + 23)
+#define IRQ_PRIV_ERROR_L2_EVENT_CNT	(IRQ_START_PRIV_ERROR + 24)
+#define IRQ_PRIV_ERROR_L2_RAM_RD_DATA	(IRQ_START_PRIV_ERROR + 25)
+#define IRQ_PRIV_ERROR_L2_RAM_RD_TAG	(IRQ_START_PRIV_ERROR + 26)
+#define IRQ_PRIV_ERROR_L2_RAM_WR_DATA	(IRQ_START_PRIV_ERROR + 27)
+#define IRQ_PRIV_ERROR_L2_RAM_WR_TAG	(IRQ_START_PRIV_ERROR + 28)
+#define IRQ_PRIV_ERROR_L2_COMBINED	(IRQ_START_PRIV_ERROR + 29)
+#define IRQ_PRIV_ERROR_L2_PARITY_RAM_RD_DATA	(IRQ_START_PRIV_ERROR + 30)
+#define IRQ_PRIV_ERROR_L2_PARITY_RAM_RD_TAG	(IRQ_START_PRIV_ERROR + 31)
+#define IRQ_PRIV_ERROR_L2_SLAVE_ERR	(IRQ_START_PRIV_ERROR + 32)
+#define IRQ_PRIV_ERROR_PARITY_FAIL0(parity0_irq) \
+			(parity0_irq >= 8 ? \
+			IRQ_START_PRIV_ERROR + 33 : \
+			IRQ_START_PRIV_ERROR + 33 + parity0_irq)
+#define IRQ_PRIV_ERROR_PARITY_FAIL1(parity1_irq) \
+			(parity1_irq >= 8 ? \
+			IRQ_START_PRIV_ERROR + 41 : \
+			IRQ_START_PRIV_ERROR + 41 + parity1_irq)
+#define IRQ_PRIV_ERROR_POLARITY_SCU0	(IRQ_START_PRIV_ERROR + 49)
+#define IRQ_PRIV_ERROR_POLARITY_SCU1	(IRQ_START_PRIV_ERROR + 50)
+
+/*
+ * Total number of interrupts
+ */
+#define NR_IRQS			(IRQ_START_PRIV_ERROR + NR_IRQS_PRIV_ERROR)
+#define NR_GPIO_IRQS		NR_IRQS_GLOB_GPIO
+
+#endif /* __ASM_ARCH_IRQS_H */
diff --git a/arch/arm/mach-avantalp/include/mach/serial.h b/arch/arm/mach-avantalp/include/mach/serial.h
index 6960e91..eff57c2 100644
--- a/arch/arm/mach-avantalp/include/mach/serial.h
+++ b/arch/arm/mach-avantalp/include/mach/serial.h
@@ -30,8 +30,8 @@ extern unsigned int mvTclk;
 #undef  BASE_BAUD
 #define BASE_BAUD (mvTclk / 16)
 
-#define PORT0_BASE	(INTER_REGS_BASE + 0x12000) /* port 0 base */
-#define PORT1_BASE 	(INTER_REGS_BASE + 0x12100) /* port 1 base */
+#define PORT0_BASE	(INTER_REGS_VIRT_BASE + 0x12000) /* port 0 base */
+#define PORT1_BASE 	(INTER_REGS_VIRT_BASE + 0x12100) /* port 1 base */
 
 #define STD_COM_FLAGS (ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST /* | ASYNC_SPD_VHI  115200 */ )
 
diff --git a/arch/arm/mach-avantalp/include/mach/uncompress.h b/arch/arm/mach-avantalp/include/mach/uncompress.h
index 8dea42f..790d28f 100644
--- a/arch/arm/mach-avantalp/include/mach/uncompress.h
+++ b/arch/arm/mach-avantalp/include/mach/uncompress.h
@@ -9,11 +9,11 @@
 #include <mach/avantalp.h>
 
 #ifndef CONFIG_MV_UART_PORT
-#define UART_THR ((volatile unsigned char *)(AXP_UART_PHYS_BASE(0) + 0x0))
-#define UART_LSR ((volatile unsigned char *)(AXP_UART_PHYS_BASE(0) + 0x14))
+#define UART_THR ((volatile unsigned char *)(UART_PHYS_BASE(0) + 0x0))
+#define UART_LSR ((volatile unsigned char *)(UART_PHYS_BASE(0) + 0x14))
 #else
-#define UART_THR ((volatile unsigned char *)(AXP_UART_PHYS_BASE(CONFIG_MV_UART_PORT) + 0x0))
-#define UART_LSR ((volatile unsigned char *)(AXP_UART_PHYS_BASE(CONFIG_MV_UART_PORT) + 0x14))
+#define UART_THR ((volatile unsigned char *)(UART_PHYS_BASE(CONFIG_MV_UART_PORT) + 0x0))
+#define UART_LSR ((volatile unsigned char *)(UART_PHYS_BASE(CONFIG_MV_UART_PORT) + 0x14))
 #endif
 
 #define LSR_THRE	0x20
@@ -61,22 +61,22 @@ static void flush(void)
 //#include <linux/autoconf.h>
 #include "../arch/arm/mach-armadaxp/config/mvSysHwConfig.h"
 #include <linux/serial_reg.h>
-#define MV_UART0_LSR 	(*(volatile unsigned char *)(INTER_REGS_BASE + 0x12000 + 0x14))
-#define MV_UART0_THR	(*(volatile unsigned char *)(INTER_REGS_BASE + 0x12000 + 0x0 ))	 
+#define MV_UART0_LSR 	(*(volatile unsigned char *)(INTER_REGS_VIRT_BASE + 0x12000 + 0x14))
+#define MV_UART0_THR	(*(volatile unsigned char *)(INTER_REGS_VIRT_BASE + 0x12000 + 0x0 ))
 
-#define MV_UART1_LSR    (*(volatile unsigned char *)(INTER_REGS_BASE + 0x12100 + 0x14))
-#define MV_UART1_THR    (*(volatile unsigned char *)(INTER_REGS_BASE + 0x12100 + 0x0 ))
-#define MV_SERIAL_BASE ((unsigned char *)(INTER_REGS_BASE + 0x12000 + 0x0 ))
+#define MV_UART1_LSR    (*(volatile unsigned char *)(INTER_REGS_VIRT_BASE + 0x12100 + 0x14))
+#define MV_UART1_THR    (*(volatile unsigned char *)(INTER_REGS_VIRT_BASE + 0x12100 + 0x0 ))
+#define MV_SERIAL_BASE ((unsigned char *)(INTER_REGS_VIRT_BASE + 0x12000 + 0x0 ))
 
-#define DEV_REG		(*(volatile unsigned int *)(INTER_REGS_BASE + 0x40000))
-#define CLK_REG         (*(volatile unsigned int *)(INTER_REGS_BASE + 0x2011c))
+#define DEV_REG		(*(volatile unsigned int *)(INTER_REGS_VIRT_BASE + 0x40000))
+#define CLK_REG         (*(volatile unsigned int *)(INTER_REGS_VIRT_BASE + 0x2011c))
 /*
  * This does not append a newline
  */
 static void putstr(const char *s)
 {
 	unsigned int model;
-	
+
 	/* Get dev ID, make sure pex clk is on */
 	if((CLK_REG & 0x4) == 0)
 	{
@@ -90,9 +90,9 @@ static void putstr(const char *s)
         while (*s) {
 		while ((MV_UART0_LSR & UART_LSR_THRE) == 0);
 		MV_UART0_THR = *s;
-		
+
                 if (*s == '\n') {
-                        while ((MV_UART0_LSR & UART_LSR_THRE) == 0); 
+                        while ((MV_UART0_LSR & UART_LSR_THRE) == 0);
                         MV_UART0_THR = '\r';
                 }
                 s++;
diff --git a/arch/arm/mach-avantalp/irq.c b/arch/arm/mach-avantalp/irq.c
index bcfeab6..fd676b7 100644
--- a/arch/arm/mach-avantalp/irq.c
+++ b/arch/arm/mach-avantalp/irq.c
@@ -1,211 +1,209 @@
 /*
- * arch/arm/mach/irq.c
- *
  * This file is licensed under the terms of the GNU General Public
  * License version 2. This program is licensed "as is" without any
  * warranty of any kind, whether express or implied.
  */
 
+#include <linux/module.h>
 #include <linux/kernel.h>
+#include <linux/err.h>
 #include <linux/init.h>
+#include <linux/interrupt.h>
 #include <linux/irq.h>
-#include <asm/mach/arch.h>
 #include <asm/gpio.h>
 #include <asm/io.h>
 #include <asm/hardware/gic.h>
-#include <linux/irq.h>
-#include <linux/interrupt.h>
-#include <plat/msi.h>
-#include "ctrlEnv/mvCtrlEnvLib.h"
-#include "ctrlEnv/mvSemaphore.h"
-#include "boardEnv/mvBoardEnvLib.h"
-#include "gpp/mvGpp.h"
-#include "gpp/mvGppRegs.h"
-#include "mvOs.h"
-#include "include/mach/smp.h"
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
 #include "ca9x2.h"
 
-unsigned int  irq_int_type[NR_IRQS];
+#define SOC_PPI_CAUSE			0x21880
+#define SOC_PPI_MASK_SET		0x218b8
+#define SOC_PPI_MASK_CLEAR		0x218bc
+
 static DEFINE_SPINLOCK(irq_controller_lock);
-#define ENABLED_DOORBELS 	(0xF0FF)
 
-static void axp_unmask_fabric_interrupt(int cpu)
-{
-	u32 val;
-	val = MV_REG_READ(CPU_CF_LOCAL_MASK_REG(cpu));
-	val |=  (1 << cpu);
-	MV_REG_WRITE(CPU_CF_LOCAL_MASK_REG(cpu), val);
-
-#ifdef CONFIG_SMP
-	if (cpu > 0) { /*enabled for both cpu */
-		val = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_MP));
-		/* FIXME: assuming all 4 cpus */
-		val |= 0xf;
-		MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_MP), val);
+/*
+ * Handle SOC PPI (Private Peripheral Interrupts).
+ */
+struct mpic_chip_regs {
+	unsigned long cause;
+	unsigned long mask;
+	unsigned long unmask;
+};
+
+static struct mpic_data {
+	int irq_base;
+	struct irq_domain *domain;
+	struct mpic_chip_regs regs;
+};
+
+static struct mpic_data mpic_data = {
+	.regs = {
+		.cause	= INTER_REGS_VIRT_BASE + SOC_PPI_CAUSE,
+		.mask	= INTER_REGS_VIRT_BASE + SOC_PPI_MASK_SET,
+		.unmask	= INTER_REGS_VIRT_BASE + SOC_PPI_MASK_CLEAR,
 	}
-#endif
-}
+};
 
-static void axp_mask_fabric_interrupt(int cpu)
+static void mpic_irq_mask(struct irq_data *d)
 {
-	u32 val;
-	val = MV_REG_READ(CPU_CF_LOCAL_MASK_REG(cpu));
-	val &=  ~(1 << cpu);
-	MV_REG_WRITE(CPU_CF_LOCAL_MASK_REG(cpu), val);
-
-#ifdef CONFIG_SMP
-	if (cpu > 0) { /*disabled for both cpu */
-		val = MV_REG_READ(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_MP));
-		/* FIXME: assuming all 4 cpus */
-		val &= ~0xf;
-		MV_REG_WRITE(CPU_INT_SOURCE_CONTROL_REG(IRQ_AURORA_MP), val);
-	}
-#endif
+	struct mpic_data *mpic = irq_get_chip_data(d->irq);
+
+	raw_spin_lock(&irq_controller_lock);
+	writel_relaxed(d->hwirq, mpic->regs.mask);
+	raw_spin_unlock(&irq_controller_lock);
 }
 
-void axp_irq_mask(struct irq_data *d)
+static void mpic_irq_unmask(struct irq_data *d)
 {
-	MV_REG_WRITE(CPU_INT_SET_MASK_LOCAL_REG, d->irq);
-#if (defined(CONFIG_PERF_EVENTS) && defined(CONFIG_HW_PERF_EVENTS)) || defined(CONFIG_ERROR_HANDLING)
-	int cpu;
-	if(d->irq == IRQ_AURORA_MP){
-		for_each_online_cpu(cpu) {
-			axp_mask_fabric_interrupt(cpu);
-		}
-	}
-#endif
+	struct mpic_data *mpic = irq_get_chip_data(d->irq);
+
+	raw_spin_lock(&irq_controller_lock);
+	writel_relaxed(d->hwirq, mpic->regs.unmask);
+	raw_spin_unlock(&irq_controller_lock);
 }
 
-void axp_irq_unmask(struct irq_data *d)
+static struct irq_chip mpic_chip = {
+	.irq_mask	= mpic_irq_mask,
+	.irq_unmask	= mpic_irq_unmask,
+};
+
+static void mpic_handle_cascade_irq(unsigned int irq, struct irq_desc *desc)
 {
-	MV_REG_WRITE(CPU_INT_CLEAR_MASK_LOCAL_REG, d->irq);
-	MV_REG_WRITE(CPU_INT_SET_ENABLE_REG, d->irq);
-#if (defined(CONFIG_PERF_EVENTS) && defined(CONFIG_HW_PERF_EVENTS)) || defined(CONFIG_ERROR_HANDLING)
-	int cpu;
-	if(d->irq == IRQ_AURORA_MP){
-		for_each_online_cpu(cpu) {
-			axp_unmask_fabric_interrupt(cpu);
-		}
-	}
-#endif
+	struct mpic_data *mpic = irq_get_handler_data(irq);
+	struct irq_chip *chip = irq_get_chip(irq);
+	unsigned long cause;
+
+	chained_irq_enter(chip, desc);
+
+	raw_spin_lock(&irq_controller_lock);
+	cause = readl_relaxed(mpic->regs.cause);
+	raw_spin_unlock(&irq_controller_lock);
+
+	/* leave only relevant cause bits */
+	cause &= 0x3ff;
+	if (cause == 0)
+		goto out; /* spurious irq ? */
+
+	irq = ffs(cause) - 1;
+	generic_handle_irq(mpic->irq_base + irq);
+
+ out:
+	chained_irq_exit(chip, desc);
 }
 
-#ifdef CONFIG_SMP
-int axp_set_affinity(struct irq_data *d, const struct cpumask *mask_val,bool force)
+static int mpic_irq_domain_map(struct irq_domain *d, unsigned int irq,
+			       irq_hw_number_t hwirq)
 {
-	MV_U32 addr, temp;
-	u32 irq=d->irq;
-	addr = (CPU_INT_SOURCE_CONTROL_REG(irq));
-
-	spin_lock(&irq_controller_lock);
-	cpumask_copy(d->affinity, mask_val);
-	d->node = cpumask_first(mask_val);
-	temp = MV_REG_READ(addr);
-	temp &= ~0xf;
-	temp |= *cpus_addr(*mask_val);
-	MV_REG_WRITE(addr, temp);
-	spin_unlock(&irq_controller_lock);
+	irq_set_chip_and_handler(irq, &mpic_chip, handle_percpu_devid_irq);
+	irq_set_chip_data(irq, d->host_data);
+	set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
 
 	return 0;
 }
-#endif
 
-static struct irq_chip axp_irq_chip = {
-	.name		= "axp_irq",
-	.irq_mask	= axp_irq_mask,
-	.irq_mask_ack	= axp_irq_mask,
-	.irq_unmask	= axp_irq_unmask,
-#ifdef CONFIG_SMP
-	.irq_set_affinity   = axp_set_affinity,
-#endif
+static struct irq_domain_ops mpic_irq_domain_ops = {
+	.map	= mpic_irq_domain_map,
 };
 
+static void __init cascade_irq_config_mpic(int irq, int nr_irqs)
+{
+	struct mpic_data *mpic = &mpic_data;
 
-void __init alp_init_irq(void)
+	mpic->irq_base = irq_alloc_descs(-1, irq, nr_irqs, NULL);
+	if (IS_ERR_VALUE(mpic->irq_base))
+		BUG();
+
+	mpic->domain = irq_domain_add_legacy(NULL, nr_irqs, mpic->irq_base,
+					     0, &mpic_irq_domain_ops, mpic);
+	WARN_ON(!mpic->domain);
+}
+
+/*
+ * Handle Global GPIO interrupts.
+ */
+#define GPIO_VIRT_BASE_0_31	(BRIDGE_PHYS_BASE | 0x18100)
+#define GPIO_VIRT_BASE_32_63	(BRIDGE_PHYS_BASE | 0x18140)
+#define GPIO_VIRT_BASE_64_66	(BRIDGE_PHYS_BASE | 0x18180)
+
+static void __init cascade_irq_config_gpio_global(void)
 {
 #if 0
-	u32 irq;
-	/* MASK all interrupts */
-	/* Enable IRQ in control register */
-	for (irq = 0; irq < IRQ_MAIN_INTS_NUM; irq++) {
-		axp_irq_mask(irq_get_irq_data(irq));
-#ifndef CONFIG_SMP
-		MV_REG_WRITE(CPU_INT_CLEAR_MASK_LOCAL_REG, irq);
-#endif
-	}
-	/*
-	 * Register IRQ sources
-	 */
-	for (irq = 0; irq < IRQ_AURORA_MSI_START ; irq++) {
-		irq_set_chip(irq, &axp_irq_chip);
-		irq_set_chip_data(irq, 0);
-		irq_set_handler(irq, handle_level_irq);
-		irq_set_status_flags(irq,IRQ_LEVEL);
-#ifdef CONFIG_SMP
-		/*Warninig  - Seif Mazreeb, in Linux 3.2 you must declare that an
-		  interrupt is a percpu .....without doing this timer interrupt won't happen.
-		  If we declare network interrupt in the same way ( which I think we should),
-		  we crash duing boot, keep this for timers for now.
-		  This is a  TODO at a second stage, evalute perfrmance and fix as needed
-		  */
-		if( irq < MAX_PER_CPU_IRQ_NUMBER && irq != IRQ_AURORA_MP) {
-			irq_set_chip_and_handler(irq, &axp_irq_chip,
-					handle_percpu_devid_irq);
-			irq_set_percpu_devid(irq);
-		}
+	/* Initialize gpiolib for GPIOs 0-31 */
+	gpio_irq_init(0, 32, GPIO_VIRT_BASE_0_31, 0, IRQ_START_GLOB_GPIO);
+	irq_set_chained_handler(IRQ_GLOB_GPIO_0_7,   gpio_irq_handler);
+	irq_set_chained_handler(IRQ_GLOB_GPIO_8_15,  gpio_irq_handler);
+	irq_set_chained_handler(IRQ_GLOB_GPIO_16_23, gpio_irq_handler);
+	irq_set_chained_handler(IRQ_GLOB_GPIO_24_31, gpio_irq_handler);
+
+	/* Initialize gpiolib for GPIOs 32-63 */
+	gpio_irq_init(32, 32, GPIO_VIRT_BASE_32_63, 0, IRQ_START_GLOB_GPIO + 32);
+	irq_set_chained_handler(IRQ_GLOB_GPIO_32_39, gpio_irq_handler);
+	irq_set_chained_handler(IRQ_GLOB_GPIO_40_47, gpio_irq_handler);
+	irq_set_chained_handler(IRQ_GLOB_GPIO_48_55, gpio_irq_handler);
+	irq_set_chained_handler(IRQ_GLOB_GPIO_56_63, gpio_irq_handler);
+
+	/* Initialize gpiolib for GPIOs 64-66 */
+	gpio_irq_init(64, 2, GPIO_VIRT_BASE_64_66, 0, IRQ_START_GLOB_GPIO + 64);
+	irq_set_chained_handler(IRQ_GLOB_GPIO_64_66, gpio_irq_handler);
 #endif
-		set_irq_flags(irq, IRQF_VALID);
-	}
+}
 
-#ifdef CONFIG_SMP
-	{
-		u32/*void __iomem **/addr;
-		/* Set the default affinity to the boot cpu. */
-		cpumask_clear(irq_default_affinity);
-		cpumask_set_cpu(smp_processor_id(), irq_default_affinity);
-
-		/* open IPI mask */
-		/* this  register write does the job of axp_irq_unmask(IRQ_AURORA_IN_DRBL_LOW)
-		   i.e. enable / unmask the DRBL_LOW interrupt.
-		   */
-		MV_REG_WRITE(CPU_INT_CLEAR_MASK_LOCAL_REG, 0);
-		addr = /*(void __iomem *)*/(AXP_IN_DRBEL_MSK);
-		MV_REG_WRITE(addr, ENABLED_DOORBELS);
-	}
+static void __init cascade_irq_config_gpio_private(void)
+{
+#if 0
+	/* Initialize gpiolib for GPIOs 0-31 */
+	gpio_irq_init(0, 32, GPIO_VIRT_BASE_0_31, 0, IRQ_START_PRIV_GPIO);
+	irq_set_chained_handler(IRQ_PRIV_GPIO_0_7,   gpio_irq_handler);
+	irq_set_chained_handler(IRQ_PRIV_GPIO_8_15,  gpio_irq_handler);
+	irq_set_chained_handler(IRQ_PRIV_GPIO_16_23, gpio_irq_handler);
+	irq_set_chained_handler(IRQ_PRIV_GPIO_24_31, gpio_irq_handler);
+
+	/* Initialize gpiolib for GPIOs 32-63 */
+	gpio_irq_init(32, 32, GPIO_VIRT_BASE_32_63, 0, IRQ_START_PRIV_GPIO + 32);
+	irq_set_chained_handler(IRQ_PRIV_GPIO_32_39, gpio_irq_handler);
+	irq_set_chained_handler(IRQ_PRIV_GPIO_40_47, gpio_irq_handler);
+	irq_set_chained_handler(IRQ_PRIV_GPIO_48_55, gpio_irq_handler);
+	irq_set_chained_handler(IRQ_PRIV_GPIO_56_63, gpio_irq_handler);
+
+	/* Initialize gpiolib for GPIOs 64-66 */
+	gpio_irq_init(64, 2, GPIO_VIRT_BASE_64_66, 0, IRQ_START_PRIV_GPIO + 64);
+	irq_set_chained_handler(IRQ_PRIV_GPIO_64_66, gpio_irq_handler);
 #endif
+}
 
-	/* armada_msi_init(); */
-
-#else
-	gic_init(0, 29, (void __iomem *) (INTER_REGS_BASE + A9_MPCORE_GIC_DIST),
-		 (void __iomem *) (INTER_REGS_BASE + A9_MPCORE_GIC_CPU));
-#endif
+static void __init cascade_irq_config_msi_global(void)
+{
+	/* TBD */
 }
-#if 0 /***************************************** ca9 gic style ****************************/
-void alp_irq_mask(struct irq_data *d)
+
+static void __init cascade_irq_config_msi_private(void)
 {
-	if (d->irq < FIRST_LEGACY_IRQ)
-		return;
-	MV_REG_WRITE(CPU_INT_SET_MASK_LOCAL_REG, d->irq);
+	/* TBD */
 }
 
-void alp_irq_unmask(struct irq_data *d)
+static void __init cascade_irq_config_errors(void)
 {
-	if (d->irq < FIRST_LEGACY_IRQ)
-		return;
-	MV_REG_WRITE(CPU_INT_CLEAR_MASK_LOCAL_REG, d->irq);
-	MV_REG_WRITE(CPU_INT_SET_ENABLE_REG, d->irq);
+	/* TBD */
 }
 
+/*
+ * Init GIC and MPIC and setup cascade irq
+ * handling for GPIO, MSI and Error interrupts.
+ */
 void __init alp_init_irq(void)
 {
-#if 0
-	gic_arch_extn.irq_ack = alp_irq_mask;
-	gic_arch_extn.irq_mask = alp_irq_mask;
-	gic_arch_extn.irq_unmask = alp_irq_unmask;
-#endif
+	gic_init(0, 29, (void __iomem*)(INTER_REGS_VIRT_BASE + A9_MPCORE_GIC_DIST),
+			(void __iomem*)(INTER_REGS_VIRT_BASE + A9_MPCORE_GIC_CPU));
+
+	cascade_irq_config_mpic(IRQ_START_PRIV_SOC_PPI, NR_IRQS_PRIV_SOC_PPI);
 
-	gic_init(0, 29, (void __iomem *) (INTER_REGS_BASE + A9_MPCORE_GIC_DIST),
-		 (void __iomem *) (INTER_REGS_BASE + A9_MPCORE_GIC_CPU));
+	cascade_irq_config_gpio_global();
+	cascade_irq_config_gpio_private();
+
+	cascade_irq_config_msi_global();
+	cascade_irq_config_msi_private();
+
+	cascade_irq_config_errors();
 }
-#endif
diff --git a/arch/arm/mach-avantalp/mv_hal_if/mvSysPci.c b/arch/arm/mach-avantalp/mv_hal_if/mvSysPci.c
index ce4e013..9cbb0eb 100644
--- a/arch/arm/mach-avantalp/mv_hal_if/mvSysPci.c
+++ b/arch/arm/mach-avantalp/mv_hal_if/mvSysPci.c
@@ -131,8 +131,8 @@ MV_PCI_BAR_WIN pciBarMap[] =
 	{{DEVICE_CS1_BASE, 0, DEVICE_CS1_SIZE     	 },   EN},          
 	{{DEVICE_CS2_BASE, 0, DEVICE_CS2_SIZE     	 },   EN},          
 	{{BOOTDEV_CS_BASE, 0, BOOTDEV_CS_SIZE     	 },   EN},          
-	{{INTER_REGS_BASE, 0, INTER_REGS_SIZE 	 	 },   EN},
-	{{INTER_REGS_BASE, 0, INTER_REGS_SIZE 	 	 },   EN},
+	{{INTER_REGS_VIRT_BASE, 0, INTER_REGS_SIZE 	 	 },   EN},
+	{{INTER_REGS_VIRT_BASE, 0, INTER_REGS_SIZE 	 	 },   EN},
 	{{  0xFFFFFFFF   , 0,    0xFFFFFFFF          },  DIS}, 	/* Ignore P2P 	*/ 
 	{{  0xFFFFFFFF   , 0,    0xFFFFFFFF          },  DIS},	/* Ignore P2P 	*/ 
     /* Table terminator */
diff --git a/arch/arm/mach-avantalp/platsmp.c b/arch/arm/mach-avantalp/platsmp.c
index 8b5fbaa..b57ad51 100644
--- a/arch/arm/mach-avantalp/platsmp.c
+++ b/arch/arm/mach-avantalp/platsmp.c
@@ -29,7 +29,7 @@ extern void avantalp_secondary_startup(void);
  */
 void __init smp_init_cpus(void)
 {
-	int i, ncores = scu_get_core_count(INTER_REGS_BASE + A9_MPCORE_SCU);
+	int i, ncores = scu_get_core_count(INTER_REGS_VIRT_BASE + A9_MPCORE_SCU);
 
 	if (ncores > nr_cpu_ids) {
 		pr_warn("SMP: %u cores greater than maximum (%u), clipping\n",
@@ -45,13 +45,13 @@ void __init smp_init_cpus(void)
 
 void __init platform_smp_prepare_cpus(unsigned int max_cpus)
 {
-	unsigned int ncores = scu_get_core_count(INTER_REGS_BASE + A9_MPCORE_SCU);
+	unsigned int ncores = scu_get_core_count(INTER_REGS_VIRT_BASE + A9_MPCORE_SCU);
 
 	/*
 	 * Initialise the present map, which describes the set of CPUs
 	 * actually populated at the present time.
 	 */
-	scu_enable(INTER_REGS_BASE + A9_MPCORE_SCU);
+	scu_enable(INTER_REGS_VIRT_BASE + A9_MPCORE_SCU);
 	
 	/*
 	 * Write the address of secondary startup into the
diff --git a/arch/arm/mach-avantalp/sysmap.c b/arch/arm/mach-avantalp/sysmap.c
index ce18bba..f0ea567 100644
--- a/arch/arm/mach-avantalp/sysmap.c
+++ b/arch/arm/mach-avantalp/sysmap.c
@@ -25,7 +25,7 @@ MV_CPU_DEC_WIN* mv_sys_map(void);
 
 struct map_desc  MEM_TABLE[] =	{
 	/* no use for pex mem remap */
-	{ INTER_REGS_BASE,		__phys_to_pfn(INTER_REGS_PHYS_BASE),	SZ_1M,  	     	MT_DEVICE},
+	{ INTER_REGS_VIRT_BASE,		__phys_to_pfn(INTER_REGS_PHYS_BASE),	SZ_1M,  	     	MT_DEVICE},
 };
 
 MV_CPU_DEC_WIN SYSMAP_ARMADA_XP[] = {
diff --git a/arch/arm/mach-avantalp/time.c b/arch/arm/mach-avantalp/time.c
index 20c9647..99e8e21 100644
--- a/arch/arm/mach-avantalp/time.c
+++ b/arch/arm/mach-avantalp/time.c
@@ -202,7 +202,7 @@ static void __init alp_twd_init(void)
 static void alp_setup_clocksource(int timer, long rate)
 {
 	u32 i = timer, u;
-	void __iomem *base = (void __iomem *)(INTER_REGS_BASE + TIMER_VAL(i));
+	void __iomem *base = (void __iomem *)(INTER_REGS_VIRT_BASE + TIMER_VAL(i));
 
 	MV_REG_WRITE(TIMER_VAL(i), 0xffffffff);
 	MV_REG_WRITE(TIMER_RELOAD(i), 0xffffffff);
@@ -263,8 +263,12 @@ static void __init alp_timer_init(void)
 	printk("Initializing AvantaLP SoC Timers\n");
 	ticks_per_jiffy = (rate + HZ/2) / HZ;
 
+	/* Global timer 0 - for clock source */
 	alp_setup_clocksource(0, rate);
+
+	/* Global timer 1 - for clock event */
 	alp_setup_clockevent(IRQ_GLOB_TIMER1, rate);
+
 	alp_twd_init();
 }
 
diff --git a/arch/arm/mach-avantalp/usb.c b/arch/arm/mach-avantalp/usb.c
index 6fbba75..8e48c60 100644
--- a/arch/arm/mach-avantalp/usb.c
+++ b/arch/arm/mach-avantalp/usb.c
@@ -149,9 +149,9 @@ static int __init   mv_usb_init(void)
 		memset(mv_usb_dev_ptr->resource, 0, 2 * sizeof(struct resource));
 
 		mv_usb_dev_ptr->resource[0].start =
-			( INTER_REGS_BASE | MV_USB_CORE_CAP_LENGTH_REG(dev));
+			( INTER_REGS_VIRT_BASE | MV_USB_CORE_CAP_LENGTH_REG(dev));
 		mv_usb_dev_ptr->resource[0].end   =
-			((INTER_REGS_BASE | MV_USB_CORE_CAP_LENGTH_REG(dev)) + 4096);
+			((INTER_REGS_VIRT_BASE | MV_USB_CORE_CAP_LENGTH_REG(dev)) + 4096);
 		mv_usb_dev_ptr->resource[0].flags = IORESOURCE_DMA;
 
 		mv_usb_dev_ptr->resource[1].start = irq_num[dev];
diff --git a/arch/arm/plat-armada/armada_suspend.S b/arch/arm/plat-armada/armada_suspend.S
index 0562693..c89fe37 100644
--- a/arch/arm/plat-armada/armada_suspend.S
+++ b/arch/arm/plat-armada/armada_suspend.S
@@ -13,9 +13,9 @@
 #include <mach/hardware.h>
 
 #if 1  /* B0-GP board GPIO pins*/
-#define MPP_CTRL_PM_REG				(INTER_REGS_BASE + 0x18008)
-#define GPIO_OUT_VALUE_REG			(INTER_REGS_BASE + 0x18100)
-#define GPIO_OUT_CTRL_REG			(INTER_REGS_BASE + 0x18104)
+#define MPP_CTRL_PM_REG				(INTER_REGS_VIRT_BASE + 0x18008)
+#define GPIO_OUT_VALUE_REG			(INTER_REGS_VIRT_BASE + 0x18100)
+#define GPIO_OUT_CTRL_REG			(INTER_REGS_VIRT_BASE + 0x18104)
 #define MPP_SET_GPIO_MASK			(0xFFFFF000)
 #define GPIO_PIN_MASK				(0xFFF8FFFF)
 #define GPIO_CMD_VALUE				(0x10000)
@@ -25,9 +25,9 @@
 #define GPIO_PIN_MASK				(0xFFFFFFF8)
 #define GPIO_CMD_VALUE				(0x1)
 #define GPIO_ACK_VALUE				(0x7)
-#define MPP_CTRL_PM_REG				(INTER_REGS_BASE + 0x18020)
-#define GPIO_OUT_VALUE_REG			(INTER_REGS_BASE + 0x18180)
-#define GPIO_OUT_CTRL_REG			(INTER_REGS_BASE + 0x18184)
+#define MPP_CTRL_PM_REG				(INTER_REGS_VIRT_BASE + 0x18020)
+#define GPIO_OUT_VALUE_REG			(INTER_REGS_VIRT_BASE + 0x18180)
+#define GPIO_OUT_CTRL_REG			(INTER_REGS_VIRT_BASE + 0x18184)
 #endif
 
 #define MV_COHERENCY_FABRIC_CTRL_REG	(0x20200)
@@ -45,7 +45,7 @@ ENTRY(armadaxp_snoop_dis_virt)
 	and	r1, r1, #15
 	mov	r4, #1
 	add	r5, r1, #24
-	ldr	r2, =(MV_COHERENCY_FABRIC_CTRL_REG + INTER_REGS_BASE)
+	ldr	r2, =(MV_COHERENCY_FABRIC_CTRL_REG + INTER_REGS_VIRT_BASE)
 1:
 	ldrex r3, [r2]
 #ifdef CONFIG_BE8_ON_LE
@@ -98,7 +98,7 @@ ENTRY(armadaxp_cpu_suspend)
 	bl armadaxp_snoop_dis_virt
 
 #ifdef CONFIG_ARMADA_DEEP_IDLE_SUPPORT_DRAM_SR
-	ldr	r3, =(INTER_REGS_BASE + 0x1418)
+	ldr	r3, =(INTER_REGS_VIRT_BASE + 0x1418)
 	ldr	r4, [r3]
 #ifdef CONFIG_BE8_ON_LE
 	rev r4, r4
@@ -131,7 +131,7 @@ ENTRY(armadaxp_cpu_suspend)
 	and	r1, r1, #15
 	mov	r4, #1
 	add	r5, r1, #24
-	ldr	r2, =(MV_COHERENCY_FABRIC_CTRL_REG + INTER_REGS_BASE)
+	ldr	r2, =(MV_COHERENCY_FABRIC_CTRL_REG + INTER_REGS_VIRT_BASE)
 1:
 	ldrex r3, [r2]
 #ifdef CONFIG_BE8_ON_LE
@@ -235,8 +235,8 @@ ENTRY(armadaxp_powerdown)
 	str     r0, [r2]
 
 	/* Prepare register for DDR Self refresh */
-	ldr	r2, =(SDRAM_OPERATION_REG - INTER_REGS_BASE)
-	ldr	r0, =INTER_REGS_BASE
+	ldr	r2, =(SDRAM_OPERATION_REG - INTER_REGS_VIRT_BASE)
+	ldr	r0, =INTER_REGS_VIRT_BASE
 	orr	r2, r2, r0
 	ldr	r0, [r2]
 #ifdef CONFIG_CPU_BIG_ENDIAN
diff --git a/arch/arm/plat-armada/linux_oss/mvOs.h b/arch/arm/plat-armada/linux_oss/mvOs.h
index 491454e..5ce30ac 100644
--- a/arch/arm/plat-armada/linux_oss/mvOs.h
+++ b/arch/arm/plat-armada/linux_oss/mvOs.h
@@ -297,8 +297,8 @@ static inline void mvOsBridgeReorderWA(void)
 {                                                               \
 	DSBWA_4611(addr);						 \
 	__asm__ __volatile__ ("mcr p15, 0, %0, c7, c14, 1" : : "r" (addr));  /* Clean and Inv D$ by MVA to PoC */ \
-	writel(__virt_to_phys((int)(((int)addr) & ~0x1f)), (INTER_REGS_BASE + MV_AURORA_L2_REGS_OFFSET + 0x7F0/*L2_FLUSH_PA*/)); \
-	writel(0x0, (INTER_REGS_BASE + MV_AURORA_L2_REGS_OFFSET + 0x700/*L2_SYNC*/)); \
+	writel(__virt_to_phys((int)(((int)addr) & ~0x1f)), (INTER_REGS_VIRT_BASE + MV_AURORA_L2_REGS_OFFSET + 0x7F0/*L2_FLUSH_PA*/)); \
+	writel(0x0, (INTER_REGS_VIRT_BASE + MV_AURORA_L2_REGS_OFFSET + 0x700/*L2_SYNC*/)); \
 	__asm__ __volatile__ ("mcr p15, 0, %0, c7, c10, 4" : : "r" (addr));  /* DSB */ \
 }
 #else
@@ -324,8 +324,8 @@ static inline void mvOsBridgeReorderWA(void)
 {                                                               \
 	DSBWA_4413(addr);								\
 	__asm__ __volatile__ ("mcr p15, 0, %0, c7, c6, 1" : : "r" (addr));   /* Invalidate D$ by MVA to PoC */ \
-	writel(__virt_to_phys(((int)addr) & ~0x1f), (INTER_REGS_BASE + MV_AURORA_L2_REGS_OFFSET + 0x770/*L2_INVALIDATE_PA*/)); \
-	writel(0x0, (INTER_REGS_BASE + MV_AURORA_L2_REGS_OFFSET + 0x700/*L2_SYNC*/)); \
+	writel(__virt_to_phys(((int)addr) & ~0x1f), (INTER_REGS_VIRT_BASE + MV_AURORA_L2_REGS_OFFSET + 0x770/*L2_INVALIDATE_PA*/)); \
+	writel(0x0, (INTER_REGS_VIRT_BASE + MV_AURORA_L2_REGS_OFFSET + 0x700/*L2_SYNC*/)); \
 	__asm__ __volatile__ ("mcr p15, 0, %0, c7, c10, 4" : : "r" (addr));  /* DSB */ \
 }
 #else
@@ -357,8 +357,8 @@ static inline void mvOsBridgeReorderWA(void)
  {                                                               \
    DSBWA_4611(addr);                                             \
         __asm__ __volatile__ ("mcr p15, 0, %0, c7, c10, 1" : : "r" (addr)); /* Clean D$ line by MVA to PoC */ \
-   writel(__virt_to_phys(((int)addr) & ~0x1f), (INTER_REGS_BASE + MV_AURORA_L2_REGS_OFFSET + 0x7B0/*L2_CLEAN_PA*/)); \
-   writel(0x0, (INTER_REGS_BASE + MV_AURORA_L2_REGS_OFFSET + 0x700/*L2_SYNC*/)); \
+   writel(__virt_to_phys(((int)addr) & ~0x1f), (INTER_REGS_VIRT_BASE + MV_AURORA_L2_REGS_OFFSET + 0x7B0/*L2_CLEAN_PA*/)); \
+   writel(0x0, (INTER_REGS_VIRT_BASE + MV_AURORA_L2_REGS_OFFSET + 0x700/*L2_SYNC*/)); \
    __asm__ __volatile__ ("mcr p15, 0, %0, c7, c10, 4" : : "r" (addr)); /* DSB */ \
  }
 
@@ -367,8 +367,8 @@ static inline void mvOsBridgeReorderWA(void)
  {                                                               \
    DSBWA_4611(addr);						 \
         __asm__ __volatile__ ("mcr p15, 0, %0, c7, c14, 1" : : "r" (addr));\
-   writel(__virt_to_phys(((int)addr) & ~0x1f), (INTER_REGS_BASE + MV_AURORA_L2_REGS_OFFSET + 0x7B0/*L2_CLEAN_PA*/)); \
-   writel(0x0, (INTER_REGS_BASE + MV_AURORA_L2_REGS_OFFSET + 0x700/*L2_SYNC*/)); \
+   writel(__virt_to_phys(((int)addr) & ~0x1f), (INTER_REGS_VIRT_BASE + MV_AURORA_L2_REGS_OFFSET + 0x7B0/*L2_CLEAN_PA*/)); \
+   writel(0x0, (INTER_REGS_VIRT_BASE + MV_AURORA_L2_REGS_OFFSET + 0x700/*L2_SYNC*/)); \
    __asm__ __volatile__ ("mcr p15, 0, %0, c7, c10, 4" : : "r" (addr)); /* DSB */ \
  }
  #else
@@ -400,11 +400,11 @@ static inline void mvOsCacheMultiLineFlush(void *handle, void *addr, int size)
 #else
 			__asm__ __volatile__ ("mcr p15, 0, %0, c7, c10, 1" : : "r" (addr)); /* Clean D$ line by MVA to PoC */
 #endif
-			writel(__virt_to_phys(((int)addr) & ~0x1f), (INTER_REGS_BASE + MV_AURORA_L2_REGS_OFFSET + 0x7B0/*L2_CLEAN_PA*/));
+			writel(__virt_to_phys(((int)addr) & ~0x1f), (INTER_REGS_VIRT_BASE + MV_AURORA_L2_REGS_OFFSET + 0x7B0/*L2_CLEAN_PA*/));
 			size -= CPU_D_CACHE_LINE_SIZE;
 			addr += CPU_D_CACHE_LINE_SIZE;
 		}
-		writel(0x0, (INTER_REGS_BASE + MV_AURORA_L2_REGS_OFFSET + 0x700/*L2_SYNC*/));
+		writel(0x0, (INTER_REGS_VIRT_BASE + MV_AURORA_L2_REGS_OFFSET + 0x700/*L2_SYNC*/));
 		__asm__ __volatile__ ("mcr p15, 0, %0, c7, c10, 4" : : "r" (addr)); /* DSB */
 #else
 		while (size > 0) {
@@ -435,11 +435,11 @@ static inline void mvOsCacheMultiLineInv(void *handle, void *addr, int size)
 		DSBWA_4413(addr);
 		while (size > 0) {
 			__asm__ __volatile__ ("mcr p15, 0, %0, c7, c6, 1" : : "r" (addr));   /* Invalidate D$ by MVA to PoC */
-			writel(__virt_to_phys(((int)addr) & ~0x1f), (INTER_REGS_BASE + MV_AURORA_L2_REGS_OFFSET + 0x770/*L2_INVALIDATE_PA*/));
+			writel(__virt_to_phys(((int)addr) & ~0x1f), (INTER_REGS_VIRT_BASE + MV_AURORA_L2_REGS_OFFSET + 0x770/*L2_INVALIDATE_PA*/));
 			size -= CPU_D_CACHE_LINE_SIZE;
 			addr += CPU_D_CACHE_LINE_SIZE;
 		}
-		writel(0x0, (INTER_REGS_BASE + MV_AURORA_L2_REGS_OFFSET + 0x700/*L2_SYNC*/));
+		writel(0x0, (INTER_REGS_VIRT_BASE + MV_AURORA_L2_REGS_OFFSET + 0x700/*L2_SYNC*/));
 		__asm__ __volatile__ ("mcr p15, 0, %0, c7, c10, 4" : : "r" (addr));  /* DSB */
 #else
 		while (size > 0) {
@@ -467,11 +467,11 @@ static inline void mvOsCacheMultiLineFlushInv(void *handle, void *addr, int size
 		DSBWA_4611(addr);
 		while (size > 0) {
 			__asm__ __volatile__ ("mcr p15, 0, %0, c7, c14, 1" : : "r" (addr));  /* Clean and Inv D$ by MVA to PoC */
-			writel(__virt_to_phys((int)(((int)addr) & ~0x1f)), (INTER_REGS_BASE + MV_AURORA_L2_REGS_OFFSET + 0x7F0/*L2_FLUSH_PA*/));
+			writel(__virt_to_phys((int)(((int)addr) & ~0x1f)), (INTER_REGS_VIRT_BASE + MV_AURORA_L2_REGS_OFFSET + 0x7F0/*L2_FLUSH_PA*/));
 			size -= CPU_D_CACHE_LINE_SIZE;
 			addr += CPU_D_CACHE_LINE_SIZE;
 		}
-		writel(0x0, (INTER_REGS_BASE + MV_AURORA_L2_REGS_OFFSET + 0x700/*L2_SYNC*/));
+		writel(0x0, (INTER_REGS_VIRT_BASE + MV_AURORA_L2_REGS_OFFSET + 0x700/*L2_SYNC*/));
 		__asm__ __volatile__ ("mcr p15, 0, %0, c7, c10, 4" : : "r" (addr));  /* DSB */
 #else
 		while (size > 0) {
@@ -518,71 +518,71 @@ extern int reg_arry_index;
 
 /* Marvell controller register read/write macros */
 #define MV_REG_VALUE(offset)          \
-	(MV_MEMIO32_READ((INTER_REGS_BASE | (offset))))
+	(MV_MEMIO32_READ((INTER_REGS_VIRT_BASE | (offset))))
 
 #define MV_REG_READ(offset)             \
-	(MV_MEMIO_LE32_READ(INTER_REGS_BASE | (offset)))
+	(MV_MEMIO_LE32_READ(INTER_REGS_VIRT_BASE | (offset)))
 
 #if defined(REG_DEBUG)
 #define MV_REG_WRITE(offset, val)    \
-	MV_MEMIO_LE32_WRITE((INTER_REGS_BASE | (offset)), (val)); \
+	MV_MEMIO_LE32_WRITE((INTER_REGS_VIRT_BASE | (offset)), (val)); \
 	{ \
-		reg_arry[reg_arry_index][0] = (INTER_REGS_BASE | (offset));\
+		reg_arry[reg_arry_index][0] = (INTER_REGS_VIRT_BASE | (offset));\
 		reg_arry[reg_arry_index][1] = (val);\
 		reg_arry_index++;\
 	}
 #else
 #define MV_REG_WRITE(offset, val)    \
-	MV_MEMIO_LE32_WRITE((INTER_REGS_BASE | (offset)), (val))
+	MV_MEMIO_LE32_WRITE((INTER_REGS_VIRT_BASE | (offset)), (val))
 #endif
 
 #define MV_REG_BYTE_READ(offset)        \
-	(MV_MEMIO8_READ((INTER_REGS_BASE | (offset))))
+	(MV_MEMIO8_READ((INTER_REGS_VIRT_BASE | (offset))))
 
 #if defined(REG_DEBUG)
 #define MV_REG_BYTE_WRITE(offset, val)  \
-	MV_MEMIO8_WRITE((INTER_REGS_BASE | (offset)), (val)); \
+	MV_MEMIO8_WRITE((INTER_REGS_VIRT_BASE | (offset)), (val)); \
 	{ \
-		reg_arry[reg_arry_index][0] = (INTER_REGS_BASE | (offset));\
+		reg_arry[reg_arry_index][0] = (INTER_REGS_VIRT_BASE | (offset));\
 		reg_arry[reg_arry_index][1] = (val);\
 		reg_arry_index++;\
 	}
 #else
 #define MV_REG_BYTE_WRITE(offset, val)  \
-	MV_MEMIO8_WRITE((INTER_REGS_BASE | (offset)), (val))
+	MV_MEMIO8_WRITE((INTER_REGS_VIRT_BASE | (offset)), (val))
 #endif
 
 #if defined(REG_DEBUG)
 #define MV_REG_BIT_SET(offset, bitMask)                 \
-	(MV_MEMIO32_WRITE((INTER_REGS_BASE | (offset)), \
-	(MV_MEMIO32_READ(INTER_REGS_BASE | (offset)) | \
+	(MV_MEMIO32_WRITE((INTER_REGS_VIRT_BASE | (offset)), \
+	(MV_MEMIO32_READ(INTER_REGS_VIRT_BASE | (offset)) | \
 	MV_32BIT_LE_FAST(bitMask)))); \
 	{ \
-		reg_arry[reg_arry_index][0] = (INTER_REGS_BASE | (offset));\
-		reg_arry[reg_arry_index][1] = (MV_MEMIO32_READ(INTER_REGS_BASE | (offset)));\
+		reg_arry[reg_arry_index][0] = (INTER_REGS_VIRT_BASE | (offset));\
+		reg_arry[reg_arry_index][1] = (MV_MEMIO32_READ(INTER_REGS_VIRT_BASE | (offset)));\
 		reg_arry_index++;\
 	}
 #else
 #define MV_REG_BIT_SET(offset, bitMask)                 \
-	(MV_MEMIO32_WRITE((INTER_REGS_BASE | (offset)), \
-	(MV_MEMIO32_READ(INTER_REGS_BASE | (offset)) | \
+	(MV_MEMIO32_WRITE((INTER_REGS_VIRT_BASE | (offset)), \
+	(MV_MEMIO32_READ(INTER_REGS_VIRT_BASE | (offset)) | \
 	MV_32BIT_LE_FAST(bitMask))))
 #endif
 
 #if defined(REG_DEBUG)
 #define MV_REG_BIT_RESET(offset, bitMask)                \
-	(MV_MEMIO32_WRITE((INTER_REGS_BASE | (offset)), \
-	(MV_MEMIO32_READ(INTER_REGS_BASE | (offset)) & \
+	(MV_MEMIO32_WRITE((INTER_REGS_VIRT_BASE | (offset)), \
+	(MV_MEMIO32_READ(INTER_REGS_VIRT_BASE | (offset)) & \
 	MV_32BIT_LE_FAST(~bitMask)))); \
 	{ \
-		reg_arry[reg_arry_index][0] = (INTER_REGS_BASE | (offset));\
-		reg_arry[reg_arry_index][1] = (MV_MEMIO32_READ(INTER_REGS_BASE | (offset)));\
+		reg_arry[reg_arry_index][0] = (INTER_REGS_VIRT_BASE | (offset));\
+		reg_arry[reg_arry_index][1] = (MV_MEMIO32_READ(INTER_REGS_VIRT_BASE | (offset)));\
 		reg_arry_index++;\
 	}
 #else
 #define MV_REG_BIT_RESET(offset, bitMask)                \
-	(MV_MEMIO32_WRITE((INTER_REGS_BASE | (offset)), \
-	(MV_MEMIO32_READ(INTER_REGS_BASE | (offset)) & \
+	(MV_MEMIO32_WRITE((INTER_REGS_VIRT_BASE | (offset)), \
+	(MV_MEMIO32_READ(INTER_REGS_VIRT_BASE | (offset)) & \
 	MV_32BIT_LE_FAST(~bitMask))))
 #endif
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_error/mv_error.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_error/mv_error.c
index 2ab1b1e..4f7af2a 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_error/mv_error.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_error/mv_error.c
@@ -155,12 +155,12 @@ int IO_error_register(u32 mask, u32 unit_cause_reg, u32 unit_mask_reg,
 	/*unamsk for each possbile CPU, this can overriden by setting affinity */
 	for_each_possible_cpu(cpu) {
 		writel((0x1 << error_val),
-		       INTER_REGS_BASE | AXP_SOC_MAIN_INT_ERR_MASK(cpu));
+		       INTER_REGS_VIRT_BASE | AXP_SOC_MAIN_INT_ERR_MASK(cpu));
 	}
 
 	/*write the mask to the reg passed by the unit
 	   assuming that this will unmaks the desired errors per unit */
-	writel(mask, INTER_REGS_BASE | unit_mask_reg);
+	writel(mask, INTER_REGS_VIRT_BASE | unit_mask_reg);
 	return 0;
 }
 
@@ -174,7 +174,7 @@ static irqreturn_t armadaxp_mbusunit_error_isr(int irq, void *arg)
 	unsigned long flags;
 	struct unit_error *entry;
 
-	error_cause = readl(INTER_REGS_BASE | SOC_MAIN_INTR_ERROR_CAUSE);
+	error_cause = readl(INTER_REGS_VIRT_BASE | SOC_MAIN_INTR_ERROR_CAUSE);
 
 	list_for_each_entry(entry, &mbusunit_error_list.list, list) {
 		/*will have to pass the type of error to
@@ -196,7 +196,7 @@ static irqreturn_t armadaxp_mbusunit_error_isr(int irq, void *arg)
 			/*the actual ack */
 			axp_error_info.axp_error_info_array[axp_error_info.
 							    head].unit_cause =
-			    readl(INTER_REGS_BASE | entry->unit_cause_reg);
+			    readl(INTER_REGS_VIRT_BASE | entry->unit_cause_reg);
 
 			/*very important to notice that we mask the error after first time it happens,
 			   this will resolve the case that no one acks the error, which will compromise the
@@ -206,7 +206,7 @@ static irqreturn_t armadaxp_mbusunit_error_isr(int irq, void *arg)
 			writel(((~axp_error_info.
 				 axp_error_info_array[axp_error_info.head].
 				 unit_cause) & entry->mask),
-			       (INTER_REGS_BASE | entry->unit_mask_reg));
+			       (INTER_REGS_VIRT_BASE | entry->unit_mask_reg));
 
 #ifdef CONFIG_ERROR_HANDLING_DRAM_ECC
 			/*Read Specific Unit(DRAM) Data */
@@ -214,11 +214,11 @@ static irqreturn_t armadaxp_mbusunit_error_isr(int irq, void *arg)
 				axp_error_info.
 				    axp_error_info_array[axp_error_info.head].
 				    more_data =
-				    readl(INTER_REGS_BASE |
+				    readl(INTER_REGS_VIRT_BASE |
 					  DDR_INTR_ERROR_ADDR);
 				/*Clear unit cause register */
 				writel(0,
-				       INTER_REGS_BASE | entry->unit_cause_reg);
+				       INTER_REGS_VIRT_BASE | entry->unit_cause_reg);
 			}
 #endif
 			/*Report the error event */
@@ -239,9 +239,9 @@ static irqreturn_t armadaxp_error_event_isr(int irq, void *arg)
 	u32 error_cause, fabric_error_cause;
 	unsigned long flags;
 
-	error_cause = readl(INTER_REGS_BASE | COHERENCY_FBRIC_LOCAL_CAUSE);
+	error_cause = readl(INTER_REGS_VIRT_BASE | COHERENCY_FBRIC_LOCAL_CAUSE);
 	fabric_error_cause =
-	    readl(INTER_REGS_BASE | COHERENCY_FBRIC_ERROR_CAUSE);
+	    readl(INTER_REGS_VIRT_BASE | COHERENCY_FBRIC_ERROR_CAUSE);
 
 	if (error_cause & 0x8000000) {
 		spin_lock_irqsave(&axp_error_info.lock, flags);
@@ -251,7 +251,7 @@ static irqreturn_t armadaxp_error_event_isr(int irq, void *arg)
 			panic
 			    (" ARMADA XP error handler: ERROR RATE is too high");
 		fabric_error_cause =
-		    readl(INTER_REGS_BASE | COHERENCY_FBRIC_ERROR_CAUSE);
+		    readl(INTER_REGS_VIRT_BASE | COHERENCY_FBRIC_ERROR_CAUSE);
 		axp_error_info.axp_error_info_array[axp_error_info.head].
 		    cause_register = fabric_error_cause;
 		axp_error_info.axp_error_info_array[axp_error_info.head].
@@ -263,11 +263,11 @@ static irqreturn_t armadaxp_error_event_isr(int irq, void *arg)
 		   the "customized" function, registered with the notification call chain can
 		   unmask the error, which will cause it to happen again. */
 		writel(((~fabric_error_cause) &
-			readl(INTER_REGS_BASE | COHERENCY_FBRIC_ERROR_MASK)),
-		       (INTER_REGS_BASE | COHERENCY_FBRIC_ERROR_MASK));
+			readl(INTER_REGS_VIRT_BASE | COHERENCY_FBRIC_ERROR_MASK)),
+		       (INTER_REGS_VIRT_BASE | COHERENCY_FBRIC_ERROR_MASK));
 
 		writel(~(fabric_error_cause),
-		       INTER_REGS_BASE | COHERENCY_FBRIC_ERROR_CAUSE);
+		       INTER_REGS_VIRT_BASE | COHERENCY_FBRIC_ERROR_CAUSE);
 
 		queue_work(error_workqueue,
 			   (struct work_struct *)&axp_error_info.
@@ -353,28 +353,28 @@ static int __init errorhandling_notification_setup(void)
 	}
 	/*clear the error casue register, and unmask interrupt
 	   to trigger the coherency fabric error interrupt */
-	writel(0x0, INTER_REGS_BASE | COHERENCY_FBRIC_ERROR_CAUSE);
+	writel(0x0, INTER_REGS_VIRT_BASE | COHERENCY_FBRIC_ERROR_CAUSE);
 
 	/*ERRATA 6349 need to be taken into consideration */
 #ifdef CONFIG_ARMADA_XP_REV_A0
-	writel(0xFFF0FFFF, INTER_REGS_BASE | COHERENCY_FBRIC_ERROR_MASK);
+	writel(0xFFF0FFFF, INTER_REGS_VIRT_BASE | COHERENCY_FBRIC_ERROR_MASK);
 #else
-	writel(0xFFFFFFFF, INTER_REGS_BASE | COHERENCY_FBRIC_ERROR_MASK);
+	writel(0xFFFFFFFF, INTER_REGS_VIRT_BASE | COHERENCY_FBRIC_ERROR_MASK);
 #endif
 	/*bit 27 in COHERENCY_FBRIC_LOCAL_CAUSE is responsible for the errors from COHERENCY_FBRIC_ERROR_CAUSE
 	   thus must unmaks it in the per cpu Coherency Fabric Local Interrupt Mask Register */
 
 	for_each_possible_cpu(cpu) {
 		temp_reg =
-		    readl(INTER_REGS_BASE |
+		    readl(INTER_REGS_VIRT_BASE |
 			  AXP_COHERENCY_FBRIC_LCL_INT_MASK(cpu));
 		writel(temp_reg | COHERENCY_FBRIC_ERROR_SUM_MASK,
-		       INTER_REGS_BASE | AXP_COHERENCY_FBRIC_LCL_INT_MASK(cpu));
+		       INTER_REGS_VIRT_BASE | AXP_COHERENCY_FBRIC_LCL_INT_MASK(cpu));
 	}
 
 #ifdef CONFIG_ERROR_HANDLING_DRAM_ECC
 	/*Config Proper DRAM ECC reporting path */
-	writel(0x00010000, INTER_REGS_BASE | 0x1454);	/*Set Threshold 1 for 1-bit ECC errors*/
+	writel(0x00010000, INTER_REGS_VIRT_BASE | 0x1454);	/*Set Threshold 1 for 1-bit ECC errors*/
 #endif
 
 	/* the MBUS units part of the error handling setup */
@@ -392,7 +392,7 @@ static int __init errorhandling_notification_setup(void)
 #ifdef CONFIG_ARMADAXP_USE_IRQ_INDIRECT_MODE
 #ifdef CONFIG_ERROR_HANDLING_DRAM_ECC
 /*Enable the main mask of the interrupt*/
-	writel(0x1100000F, INTER_REGS_BASE | 0x20b10);
+	writel(0x1100000F, INTER_REGS_VIRT_BASE | 0x20b10);
 #endif
 #endif
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_mtd/nand_nfc.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_mtd/nand_nfc.c
index f810600..a2d8814 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_mtd/nand_nfc.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_mtd/nand_nfc.c
@@ -1560,7 +1560,7 @@ static int orion_nfc_probe(struct platform_device *pdev)
 	nfcInfo.tclk = info->tclk;
 	nfcInfo.readyBypass = MV_FALSE;
 	nfcInfo.osHandle = NULL;
-	nfcInfo.regsPhysAddr = INTER_REGS_BASE;
+	nfcInfo.regsPhysAddr = INTER_REGS_VIRT_BASE;
 #ifdef CONFIG_MV_INCLUDE_PDMA
 	nfcInfo.dataPdmaIntMask = MV_PDMA_END_OF_RX_INTR_EN | MV_PDMA_END_INTR_EN;
 	nfcInfo.cmdPdmaIntMask = 0x0;
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_sata/mvLinuxIalHt.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_sata/mvLinuxIalHt.c
index 086e81c..a0eb9cf 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_sata/mvLinuxIalHt.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_sata/mvLinuxIalHt.c
@@ -765,7 +765,7 @@ static int __devinit mv_ial_init_soc_sata(void)
         if (pAdapter->host[i] != NULL)
             pAdapter->host[i]->scsihost->base = pAdapter->host[0]->scsihost->base;
     }
-    pMvSataAdapter->adapterIoBaseAddress = (MV_BUS_ADDR_T)(INTER_REGS_BASE + MV_SATA_REGS_OFFSET - 
+    pMvSataAdapter->adapterIoBaseAddress = (MV_BUS_ADDR_T)(INTER_REGS_VIRT_BASE + MV_SATA_REGS_OFFSET -
                                             0x20000);
     
     mvLogMsg(MV_IAL_LOG_ID, MV_DEBUG, "io base address 0x%08lx\n",
-- 
1.7.5.4

