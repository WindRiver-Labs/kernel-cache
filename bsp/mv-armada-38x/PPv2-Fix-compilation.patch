From e2463c551a05ef25cc0f79ca9f7ed6d221db3a15 Mon Sep 17 00:00:00 2001
From: Kosta Zertsekel <konszert@marvell.com>
Date: Wed, 13 Mar 2013 00:07:56 +0200
Subject: [PATCH 0490/1825] PPv2: Fix compilation

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 41d59d8dca8f316d49dbceef9f9ba6647fe36b41

Signed-off-by: Kosta Zertsekel <konszert@marvell.com>
Change-Id: I8bdc34cb535f7371e24885ba5f38339d0d58c338
Reviewed-on: http://vgitil04.il.marvell.com:8080/1263
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-avantalp/core.c                      |    4 +-
 arch/arm/plat-armada/Kconfig                       |  157 ++++++------
 .../mv_drivers_lsp/mv_neta/net_dev/mv_eth_tool.c   |  186 +--------------
 .../mv_drivers_lsp/mv_neta/net_dev/mv_netdev.h     |    2 +-
 .../mv_network/mv_ethernet/mv_eth_tool.c           |  252 +++++---------------
 .../mv_network/mv_ethernet/mv_eth_tool.h           |   12 -
 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig |    9 +-
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c   |    2 +
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tool.c    |  179 +--------------
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c      |   11 +-
 10 files changed, 161 insertions(+), 653 deletions(-)

diff --git a/arch/arm/mach-avantalp/core.c b/arch/arm/mach-avantalp/core.c
index 0a47466..3f35264 100755
--- a/arch/arm/mach-avantalp/core.c
+++ b/arch/arm/mach-avantalp/core.c
@@ -44,6 +44,7 @@
 #include <linux/serial_8250.h>
 #include <linux/serial_reg.h>
 #include <linux/ata_platform.h>
+#include <linux/ethtool.h>
 #include <asm/serial.h>
 #include <plat/cache-aurora-l2.h>
 
@@ -411,12 +412,11 @@ void __init serial_initialize(int port)
 {
 	if(port == 0)
 	{
-		if(mvUnitMapIsMine(UART0) == MV_FALSE){
+		if (mvUnitMapIsMine(UART0) == MV_FALSE){
 			printk(KERN_WARNING "uart%d resource not allocated but CONFIG_MV_UART_PORT = %d\n", port, port);
 			mvUnitMapSetMine(UART0);
 		}
 
-early_printk("oooooooo: callling platform_device_register(&aurora_uart0)\n\n\n");
 		aurora_uart0_data[0].uartclk = mvBoardTclkGet();
 		platform_device_register(&aurora_uart0);
 	}
diff --git a/arch/arm/plat-armada/Kconfig b/arch/arm/plat-armada/Kconfig
index fed12dd..499de94 100644
--- a/arch/arm/plat-armada/Kconfig
+++ b/arch/arm/plat-armada/Kconfig
@@ -7,7 +7,7 @@ config JTAG_DEBUG
 	bool "Enable JTAG by disable \"wait for interrupt\"."
 	depends on MV88F6500 || MV88F6281 || MV78XX0
 	default n
-	---help---
+	help
 	   Enable the JTAG debugger taking over the CPU by disabling "wait for interrupt" idle loop."
 
 
@@ -20,8 +20,8 @@ config MV_INCLUDE_PEX
 	default y
 	select MV_PEX_2_1X4
 	select MV_PEX_3_1X4
-        ---help---
-        Please don't change this configs unless you know what you are doing.
+	help
+	  Please don't change this configs unless you know what you are doing.
 
 choice
 	prompt "PEX-0 Mode"
@@ -59,31 +59,31 @@ endif
 if ARMADA_370
 config MV_INCLUDE_PEX
 	bool "PCI Express Support"
-    depends on PCI && (MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_370)
-    default y
-        ---help---
-        Please don't change this configs unless you know what you are doing.
+	depends on PCI && (MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_370)
+	default y
+	help
+	  Please don't change this configs unless you know what you are doing.
 endif
 
 config MV_INCLUDE_PCI
 	bool "PCI Support"
 	depends on PCI && (MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP || ARMADA_370 || AVANTA_LP)
 	default n
-        ---help---
+        help
         Please don't change this configs unless you know what you are doing.
 
 config MV_INCLUDE_USB
 	bool "USB Support"
 	depends on MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP || ARMADA_370 || AVANTA_LP
 	default y
-        ---help---
+        help
         Please don't change this configs unless you know what you are doing.
 
 config MV_INCLUDE_XOR
 	bool "XOR Support"
 	depends on MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP || ARMADA_370 || AVANTA_LP
 	default y
-        ---help---
+        help
         Please don't change this configs unless you know what you are doing.
 
 config MV_INCLUDE_CESA
@@ -91,14 +91,14 @@ config MV_INCLUDE_CESA
 	depends on MV88F6500 || MV88F6082 || MV88F6183 || MV88F6281 || MV78XX0 \
 		|| ARMADA_XP || ARMADA_370 || AVANTA_LP
 	default y
-        ---help---
+        help
         Please don't change this configs unless you know what you are doing.
 
 config MV_INCLUDE_NFC
 	bool "Nand Flash Controller Support"
 	depends on MV88F6500 || ARMADA_XP || ARMADA_370 || AVANTA_LP
 	default y
-        ---help---
+        help
         Please don't change this configs unless you know what you are doing.
 
 config MV_INCLUDE_LEGACY_NAND
@@ -106,7 +106,7 @@ config MV_INCLUDE_LEGACY_NAND
 	depends on MV88F6500 || MV88F6281 || MV78XX0 \
 		|| ARMADA_XP || ARMADA_370 || AVANTA_LP
 	default y
-        ---help---
+        help
         Please don't change this configs unless you know what you are doing.
 
 config MV_INCLUDE_INTEG_SATA
@@ -114,7 +114,7 @@ config MV_INCLUDE_INTEG_SATA
 	depends on MV88F6500 || MV88F6281 || MV78XX0 || \
 		   ARMADA_XP || ARMADA_370 || AVANTA_LP
 	default y
-        ---help---
+        help
         Please don't change this configs unless you know what you are doing.
 
 config MV_INCLUDE_TDM
@@ -122,13 +122,13 @@ config MV_INCLUDE_TDM
 	depends on MV88F6500 || MV88F6281 || MV78XX0 || \
 		   ARMADA_XP || ARMADA_370 || AVANTA_LP
 	default y
-        ---help---
+        help
         Please don't change this configs unless you know what you are doing.
 
 config MV_INCLUDE_GIG_ETH
 	bool "Giga Ethernet Support"
 	depends on MV88F6500 || MV88F6281 || MV78XX0 || \
-		   ARMADA_XP || ARMADA_370
+		   ARMADA_XP || ARMADA_370 || AVANTA_LP
 	default y
 
 config MV_INCLUDE_SPI
@@ -136,44 +136,45 @@ config MV_INCLUDE_SPI
 	depends on MV88F6500 || MV88F6281 || (MV78XX0 && !MV78XX0_Z0) || \
 		   ARMADA_XP || ARMADA_370 || AVANTA_LP
 	default y
-        ---help---
-        Please don't change this configs unless you know what you are doing.
+	help
+	  Please don't change this configs unless you know what you are doing.
 
 config MV_INCLUDE_NOR
 	bool "NOR Support"
 	depends on MV88F6500 || MV88F6281 || (MV78XX0 && !MV78XX0_Z0) || \
 		   ARMADA_XP || AVANTA_LP
 	default y
-        ---help---
-        Please don't change this configs unless you know what you are doing.
-
+	help
+	  Please don't change this configs unless you know what you are doing.
 
 config MV_INCLUDE_SDIO
 	bool "SDIO Support"
 	depends on MV88F6500 || MV88F6281 || ARMADA_XP || ARMADA_370 || AVANTA_LP
 	default y
-        ---help---
+        help
         Please don't change this configs unless you know what you are doing.
 
 config MV_INCLUDE_TS
 	bool "TSU Support"
 	depends on MV88F6500 || MV88F6281
 	default n
-        ---help---
-        Please don't change this configs unless you know what you are doing.
+	help
+	  Please don't change this configs unless you know what you are doing.
 
 config MV_INCLUDE_PON
 	bool "PON Support"
 	depends on MV88F6500 || MV_ETH_PP2
 	default y
-        ---help---
-        Please don't change this configs unless you know what you are doing.
+	help
+	  Please don't change this configs unless you know what you are doing.
 
 config MV_INCLUDE_SWITCH
-        bool "Ethernet Switch Support"
-        depends on MV88F6500 || MV88F6281 || MV78XX0 || \
+	bool "Ethernet Switch Support"
+	depends on MV88F6500 || MV88F6281 || MV78XX0 || \
 		   ARMADA_XP || ARMADA_370 || AVANTA_LP
-        default y
+	default y
+	help
+	  TBD
 
 endmenu
 
@@ -268,25 +269,25 @@ config MV_FLASH_CTRL
 	default n
 
 config MV_INCLUDE_SFLASH_MTD
-    bool "Marvell support for MTD SPI flash device"
-    select MV_FLASH_CTRL
-    depends on MTD && MV_INCLUDE_SPI
-   	default y
+	bool "Marvell support for MTD SPI flash device"
+	select MV_FLASH_CTRL
+	depends on MTD && MV_INCLUDE_SPI
+	default y
 
 config MV_SPI_BOOT
 	bool "Marvell boot support from MTD SPI device"
 	depends on MV_INCLUDE_SFLASH_MTD
 	default n
-	---help---
+	help
 	Choose this option if SPI MTD is the system boot device.
 	This option controls the various flash types support in the board
 	device chip-select information structure under mvBoardEnvSpec.c
 
 config MV_INCLUDE_MFLASH_MTD
-    bool "Marvell support for MTD Marvell flash device"
-    select MV_FLASH_CTRL
-    depends on MTD && MV_INCLUDE_INTEG_MFLASH && !ARMADA_XP
-   	default y
+	bool "Marvell support for MTD Marvell flash device"
+	select MV_FLASH_CTRL
+	depends on MTD && MV_INCLUDE_INTEG_MFLASH && !ARMADA_XP
+	default y
 
 config MTD_NAND_LNC
 	bool "MTD driver for the Legacy NAND controller"
@@ -297,33 +298,33 @@ config MTD_NAND_LNC_BOOT
 	bool "Marvell boot support from MTD NAND device"
 	depends on MTD_NAND_LNC
 	default n
-	---help---
-	Choose this option if NAND MTD is the system boot device.
-	This option controls the various flash types support in the board
-	device chip-select information structure under mvBoardEnvSpec.c
+	help
+	  Choose this option if NAND MTD is the system boot device.
+	  This option controls the various flash types support in the board
+	  device chip-select information structure under mvBoardEnvSpec.c
 
 config MTD_NAND_LNC_RS_ECC
 	bool "Support Reed-Solomon 4-bit ECC algorithm for Legacy Nand Controller"
 	depends on MTD_NAND_LNC
 	default y
-	---help---
-	Choose this option to support Reed-Solomon 4-bit ECC algorithm.
-	Note this option also requires support by low-level boot loader.
+	help
+	  Choose this option to support Reed-Solomon 4-bit ECC algorithm.
+	  Note this option also requires support by low-level boot loader.
 
 config MTD_NAND_LNC_8BYTE_READ
 	bool "Support 8B burst Read for Legacy Nand Controller"
 	depends on MTD_NAND_LNC
 	default n
-	---help---
-	Choose this option to support NAND 8 Byte Read burst algorithm.
+	help
+	  Choose this option to support NAND 8 Byte Read burst algorithm.
 
 config MTD_NAND_NFC
-        tristate "MTD driver for the Armada Nand Flash Controller"
-        depends on MTD_NAND && MV_INCLUDE_NFC
+	tristate "MTD driver for the Armada Nand Flash Controller"
+	depends on MTD_NAND && MV_INCLUDE_NFC
 	default y
-        help
-          This enables the driver for the NAND flash controller found in
-          the Marvell Armada SoC devices.
+	help
+	  This enables the driver for the NAND flash controller found in
+	  the Marvell Armada SoC devices.
 
 config MTD_NAND_NFC_GANG_SUPPORT
         bool "NAND Ganged mode support for the NFC"
@@ -367,12 +368,12 @@ choice
 
 config MV_USB_HOST
 	bool "Support for USB Host"
-	---help---
+	help
 	Choosing this option will configure on chip USB Controller to work in Host mode
 
 config MV_USB_DEVICE
 	bool "Support for USB Device"
-	---help---
+	help
 	Choosing this option will configure on chip USB Controller to work in Device mode
 endchoice
 
@@ -389,7 +390,7 @@ config USE_DSP
 config  FEROCEON_PROC
 	bool "Support for MV-shell proc file system"
 	depends on PROC_FS
-	---help---
+	help
 	  Choosing this option will enable you to use the MV-shell through the Proc
 	  File system.
 	  The MV-shell is a debug utility which can be run from the shell.
@@ -397,40 +398,40 @@ config  FEROCEON_PROC
 config  MV_PMU_PROC
         bool "Support procfs control on Power-Management features"
         depends on PROC_FS
-        ---help---
+        help
           Choose this option to enable control over the power-management features through
           the proc file-system.
 
 config  MV_DBG_TRACE
 	bool "Enable tracing utility"
 	default n
-	---help---
+	help
 	  Choosing this debug option will cause some kernel modules to log operations into
 	  a cyclic buffer and dump them on failures. Enabling this feature decreases performance.
 
 config  MV_CPU_PERF_CNTRS
         bool "CPU Performance counters support"
         default n
-        ---help---
+        help
         Choosing this option will enable you to use CPU Performance counters
 
 config  MV_CPU_L2_PERF_CNTRS
         bool "CPU L2 Performance counters support"
         default n
-        ---help---
+        help
         Choosing this option will enable you to use CPU L2 Performance counters
 
 config	ERROR_HANDLING
 	bool "Error handling notification support"
         default n
-        ---help---
+        help
         Choosing this option will enable error notification
 
 config	ERROR_HANDLING_DRAM_ECC
 	bool "DRAM ECC Error handling notification support"
 	depends on ERROR_HANDLING
         default n
-        ---help---
+        help
         Choosing this option will enable DRAM ECC error notification by netlink
 
 
@@ -444,43 +445,45 @@ menu "SoC Networking support"
 depends on MV_INCLUDE_GIG_ETH
 
 config MV_ETHERNET
-        bool "Networking support"
-	depends on MV_INCLUDE_GIG_ETH
+	bool "Networking support"
 	default y
-        ---help---
-        Choose this option to support Marvell Gigabit Ethernet Controller
+	help
+	  Choose this option to support Marvell Gigabit Ethernet Controller
 
 choice
 
 	prompt "GbE Mode"
-	depends on MV_INCLUDE_GIG_ETH
 	default MV_ETH_LEGACY
 
 config MV_ETH_LEGACY
 	bool "Legacy mode "
-	---help---
+	help
+	  TBD
 
 config MV_ETH_NETA
 	bool "Acceleration mode "
-	depends on ARCH_FEROCEON_KW2 || ARCH_ARMADA_XP || ARCH_ARMADA370
-	---help---
+	depends on ARCH_FEROCEON_KW2 || ARCH_ARMADA_XP \
+		|| ARCH_ARMADA370 || AVANTA_LP
+	help
+	  TBD
 
 config MV_ETH_PP2
 	bool "PPv2 mode "
-	depends on ARCH_FEROCEON_KW2 || ARCH_ARMADA_XP || ARCH_ARMADA370
+	depends on ARCH_FEROCEON_KW2 || ARCH_ARMADA_XP || ARCH_ARMADA370 || AVANTA_LP
 	select MV_ETH_PP2_CLS2
 	select MV_ETH_PP2_CLS3
 	select MV_ETH_PP2_CLS4
 	select MV_ETH_PP2_CLS_MC
-	---help---
+	help
+	  TBD
 
 endchoice
 
 config MV_INCLUDE_ETH_PHY
-	bool "Choose to compile Ethernet PHY support
+	bool "Choose to compile Ethernet PHY support"
 	depends on MV_ETH_LEGACY || MV_ETH_NETA || MV_ETH_PP2
 	help
-	  No help currently.
+	  TBD
 
 if MV_ETH_LEGACY
 source arch/arm/plat-armada/mv_drivers_lsp/mv_network/Kconfig
@@ -500,18 +503,16 @@ source arch/arm/plat-armada/mv_drivers_lsp/mv_cesa/Kconfig
 
 source arch/arm/plat-armada/mv_drivers_lsp/mv_phone/Kconfig
 
-
 #source arch/arm/plat-armada/mv_drivers_lsp/mv_sdio/Kconfig
 
 source arch/arm/plat-armada/mv_drivers_lsp/mv_tsu/Kconfig
 
 source arch/arm/plat-armada/mv_drivers_lsp/mv_pon/Kconfig
 
-
 config  SCSI_MVSATA
 	tristate "Support for Marvell Sata Adapters"
 	depends on ( MV_INCLUDE_INTEG_SATA && SCSI ) || ( PCI && SCSI )
-	---help---
+	help
 	  Choosing this option will enable you to use the Marvell Sata
 	  adapters support with emulation as SCSI adapters.
 	  Note that the kernel scsi subsystem must be chosen too.
@@ -521,14 +522,14 @@ source arch/arm/plat-armada/mv_drivers_lsp/mv_sata/Kconfig
 config PCIE_VIRTUAL_BRIDGE_SUPPORT
         bool "Enable virtual bridge on PCIe"
         depends on PCI
-        ---help---
+        help
         Enable virtual bridge module to support PCIe switches
 
 config MV_UART_POLLING_MODE
         bool "Enable Polling mode for UART driver"
         depends on ARCH_FEROCEON_KW2
 	default y
-        ---help---
+        help
         Configure UART driver to work in polling mode.
 
 endmenu
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_tool.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_tool.c
index 230a3a7..31194e3 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_tool.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_tool.c
@@ -630,116 +630,6 @@ int mv_eth_tool_set_pauseparam(struct net_device *netdev,
 	return 0;
 }
 
-#if 0
-/******************************************************************************
-* mv_eth_tool_get_rx_csum
-* Description:
-*	ethtool get RX checksum offloading status
-* INPUT:
-*	netdev		Network device structure pointer
-* OUTPUT
-*	None
-* RETURN:
-*	RX checksum
-*
-*******************************************************************************/
-u32 mv_eth_tool_get_rx_csum(struct net_device *netdev)
-{
-#ifdef CONFIG_MV_ETH_RX_CSUM_OFFLOAD
-	struct eth_port *priv = MV_ETH_PRIV(netdev);
-
-	return (priv->rx_csum_offload != 0);
-#else
-	return 0;
-#endif
-}
-
-/******************************************************************************
-* mv_eth_tool_set_rx_csum
-* Description:
-*	ethtool enable/disable RX checksum offloading
-* INPUT:
-*	netdev		Network device structure pointer
-*	data		Command data
-* OUTPUT
-*	None
-* RETURN:
-*	0 on success
-*
-*******************************************************************************/
-int mv_eth_tool_set_rx_csum(struct net_device *netdev, uint32_t data)
-{
-#ifdef CONFIG_MV_ETH_RX_CSUM_OFFLOAD
-	struct eth_port *priv = MV_ETH_PRIV(netdev);
-
-	priv->rx_csum_offload = data;
-	return 0;
-#else
-	return -EOPNOTSUPP;
-#endif
-}
-
-/******************************************************************************
-* mv_eth_tool_set_tx_csum
-* Description:
-*	ethtool enable/disable TX checksum offloading
-* INPUT:
-*	netdev		Network device structure pointer
-*	data		Command data
-* OUTPUT
-*	None
-* RETURN:
-*	0 on success
-*
-*******************************************************************************/
-int mv_eth_tool_set_tx_csum(struct net_device *netdev, uint32_t data)
-{
-#ifdef CONFIG_MV_ETH_TX_CSUM_OFFLOAD
-	if (data) {
-		if (netdev->mtu > MV_ETH_TX_CSUM_MAX_SIZE) {
-			printk(KERN_ERR "Cannot set TX checksum when MTU > %d\n", MV_ETH_TX_CSUM_MAX_SIZE);
-			return -EOPNOTSUPP;
-		}
-		netdev->features |= NETIF_F_IP_CSUM;
-	} else {
-		netdev->features &= ~NETIF_F_IP_CSUM;
-	}
-
-	return 0;
-#else
-	return -EOPNOTSUPP;
-#endif /* TX_CSUM_OFFLOAD */
-}
-
-
-/******************************************************************************
-* mv_eth_tool_set_tso
-* Description:
-*	ethtool enable/disable TCP segmentation offloading
-* INPUT:
-*	netdev		Network device structure pointer
-*	data		Command data
-* OUTPUT
-*	None
-* RETURN:
-*	0 on success
-*
-*******************************************************************************/
-int mv_eth_tool_set_tso(struct net_device *netdev, uint32_t data)
-{
-#if defined(CONFIG_MV_ETH_TSO)
-	if (data)
-		netdev->features |= NETIF_F_TSO;
-	else
-		netdev->features &= ~NETIF_F_TSO;
-
-	return 0;
-#else
-	return -EOPNOTSUPP;
-#endif
-}
-#endif
-
 /******************************************************************************
 * mv_eth_tool_get_strings
 * Description:
@@ -823,62 +713,6 @@ static int mv_eth_tool_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *i
 }
 
 /******************************************************************************
-* mv_eth_tool_set_rx_ntuple
-* Description:
-*	ethtool set mapping from 2t/5t rule to rxq/drop
-*	ignore mask parameters (assume mask=0xFF for each byte provided)
-*	support only tcp4 / udp4 protocols
-*	support only full 2t/5t rules:
-*		** 2t - must provide src-ip, dst-ip
-*		** 5t - must provide src-ip, dst-ip, src-port, dst-port
-* INPUT:
-*	netdev		Network device structure pointer
-*	ntuple
-* OUTPUT
-*	None
-* RETURN:
-*
-*******************************************************************************/
-static int mv_eth_tool_set_rx_ntuple(struct net_device *dev, struct ethtool_rx_ntuple *ntuple)
-{
-#ifdef CONFIG_MV_ETH_PNC_L3_FLOW
-	unsigned int sip, dip, ports, sport, dport, proto;
-	struct eth_port *pp;
-
-	if ((ntuple->fs.flow_type != TCP_V4_FLOW) && (ntuple->fs.flow_type != UDP_V4_FLOW))
-		return -EOPNOTSUPP;
-
-	if ((ntuple->fs.action >= CONFIG_MV_ETH_RXQ) || (ntuple->fs.action < ETHTOOL_RXNTUPLE_ACTION_CLEAR))
-		return -EINVAL;
-
-	if (ntuple->fs.flow_type == TCP_V4_FLOW)
-		proto = 6; /* tcp */
-	else
-		proto = 17; /* udp */
-
-	sip = ntuple->fs.h_u.tcp_ip4_spec.ip4src;
-	dip = ntuple->fs.h_u.tcp_ip4_spec.ip4dst;
-	sport = ntuple->fs.h_u.tcp_ip4_spec.psrc;
-	dport = ntuple->fs.h_u.tcp_ip4_spec.pdst;
-	if (!sip || !dip)
-		return -EINVAL;
-
-	pp = MV_ETH_PRIV(dev);
-	if (!sport || !dport) { /* 2-tuple */
-		pnc_ip4_2tuple_rxq(pp->port, sip, dip, ntuple->fs.action);
-	} else {
-		ports = (dport << 16) | ((sport << 16) >> 16);
-		pnc_ip4_5tuple_rxq(pp->port, sip, dip, ports, proto, ntuple->fs.action);
-	}
-
-	return 0;
-#else
-	return 1;
-#endif /* CONFIG_MV_ETH_PNC_L3_FLOW */
-}
-
-
-/******************************************************************************
 * mv_eth_tool_get_ethtool_stats
 * Description:
 *	ethtool get statistics
@@ -902,32 +736,18 @@ const struct ethtool_ops mv_eth_tool_ops = {
 	.set_settings				= mv_eth_tool_set_settings,
 	.get_drvinfo				= mv_eth_tool_get_drvinfo,
 	.get_regs_len				= mv_eth_tool_get_regs_len,
-	.get_regs					= mv_eth_tool_get_regs,
-	.nway_reset					= mv_eth_tool_nway_reset,
-	.get_link					= mv_eth_tool_get_link,
+	.get_regs				= mv_eth_tool_get_regs,
+	.nway_reset				= mv_eth_tool_nway_reset,
+	.get_link				= mv_eth_tool_get_link,
 	.get_coalesce				= mv_eth_tool_get_coalesce,
 	.set_coalesce				= mv_eth_tool_set_coalesce,
 	.get_ringparam  			= mv_eth_tool_get_ringparam,
 	.get_pauseparam				= mv_eth_tool_get_pauseparam,
 	.set_pauseparam				= mv_eth_tool_set_pauseparam,
-#if 0
-	.get_rx_csum				= mv_eth_tool_get_rx_csum,
-	.set_rx_csum				= mv_eth_tool_set_rx_csum,
-	.get_tx_csum				= ethtool_op_get_tx_csum,
-	.set_tx_csum				= mv_eth_tool_set_tx_csum,
-	.get_sg						= ethtool_op_get_sg,
-	.set_sg						= ethtool_op_set_sg,
-	.get_tso					= ethtool_op_get_tso,
-	.set_tso					= mv_eth_tool_set_tso,
-#endif
 	.get_strings				= mv_eth_tool_get_strings,
 #if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 32)
 	.get_stats_count			= mv_eth_tool_get_stats_count,
 #endif
 	.get_ethtool_stats			= mv_eth_tool_get_ethtool_stats,
-//	.get_rxfh_indir				= mv_eth_tool_get_rxfh_indir,
-//	.set_rxfh_indir				= mv_eth_tool_set_rxfh_indir,
-//	.get_rxnfc                  = mv_eth_tool_get_rxnfc,
-//	.set_rx_ntuple				= mv_eth_tool_set_rx_ntuple,
 };
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.h
index 955e9d1..daa1db0 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.h
@@ -25,6 +25,7 @@ WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
 DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 *******************************************************************************/
+
 #ifndef __mv_netdev_h__
 #define __mv_netdev_h__
 
@@ -42,7 +43,6 @@ disclaimer.
 #include "bm/mvBmRegs.h"
 #include "bm/mvBm.h"
 
-
 /******************************************************
  * driver statistics control --                       *
  ******************************************************/
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_network/mv_ethernet/mv_eth_tool.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_network/mv_ethernet/mv_eth_tool.c
index 11b072c..41f236b 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_network/mv_ethernet/mv_eth_tool.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_network/mv_ethernet/mv_eth_tool.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -13,16 +13,16 @@ Marvell copyright notice above.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 *******************************************************************************/
 
@@ -71,16 +71,6 @@ const struct ethtool_ops mv_eth_tool_ops = {
 	.get_ringparam          = mv_eth_tool_get_ringparam,
 	.get_pauseparam		= mv_eth_tool_get_pauseparam,
 	.set_pauseparam		= mv_eth_tool_set_pauseparam,
-	.get_rx_csum		= mv_eth_tool_get_rx_csum,
-	.set_rx_csum		= mv_eth_tool_set_rx_csum,
-	.get_tx_csum		= ethtool_op_get_tx_csum,
-	.set_tx_csum		= mv_eth_tool_set_tx_csum,
-	.get_sg			= ethtool_op_get_sg,
-	.set_sg			= ethtool_op_set_sg,
-	.get_tso		= ethtool_op_get_tso,
-	.set_tso		= mv_eth_tool_set_tso,
-	.get_ufo		= ethtool_op_get_ufo,
-	.set_ufo		= mv_eth_tool_set_ufo,
 	.get_strings		= mv_eth_tool_get_strings,
 	.phys_id		= mv_eth_tool_phys_id,
 	.get_stats_count	= mv_eth_tool_get_stats_count,
@@ -166,17 +156,17 @@ static const struct mv_eth_tool_stats mv_eth_tool_tx_queue_strings_stats[] = {
 
 #define MV_ETH_TOOL_RX_QUEUE_STATS_LEN  \
 	sizeof(mv_eth_tool_rx_queue_strings_stats) / sizeof(struct mv_eth_tool_stats)
-	
+
 #define MV_ETH_TOOL_TX_QUEUE_STATS_LEN  \
 	sizeof(mv_eth_tool_tx_queue_strings_stats) / sizeof(struct mv_eth_tool_stats)
-	
+
 #define MV_ETH_TOOL_QUEUE_STATS_LEN 	\
 	((MV_ETH_TOOL_RX_QUEUE_STATS_LEN * MV_ETH_RX_Q_NUM) + \
 	(MV_ETH_TOOL_TX_QUEUE_STATS_LEN * MV_ETH_TX_Q_NUM))
 
 #define MV_ETH_TOOL_GLOBAL_STATS_LEN	\
 	sizeof(mv_eth_tool_global_strings_stats) / sizeof(struct mv_eth_tool_stats)
-	
+
 #define MV_ETH_TOOL_STATS_LEN 		\
 	(MV_ETH_TOOL_GLOBAL_STATS_LEN + MV_ETH_TOOL_QUEUE_STATS_LEN)
 
@@ -197,7 +187,7 @@ int mv_eth_tool_read_mdio(struct net_device *netdev, int addr, int reg)
 	unsigned long 	flags;
 	unsigned short 	value;
 	MV_STATUS 	status;
-	
+
 	spin_lock_irqsave(&mii_lock, flags);
 	status = mvEthPhyRegRead(addr, reg, &value);
 	spin_unlock_irqrestore(&mii_lock, flags);
@@ -251,7 +241,7 @@ int mv_eth_tool_read_phy_reg(int phy_addr, u16 page, u16 reg, u16 *val)
 {
 	unsigned long 	flags;
 	MV_STATUS 	status = 0;
-	
+
 	spin_lock_irqsave(&mii_lock, flags);
 	/* setup register address page first */
 	if (!mvEthPhyRegWrite(phy_addr, MV_ETH_TOOL_PHY_PAGE_ADDR_REG, page)) {
@@ -281,7 +271,7 @@ int mv_eth_tool_write_phy_reg(int phy_addr, u16 page, u16 reg, u16 data)
 {
 	unsigned long   flags;
 	MV_STATUS 	status = 0;
-	
+
 	spin_lock_irqsave(&mii_lock, flags);
 	/* setup register address page first */
 	if (!mvEthPhyRegWrite(phy_addr, MV_ETH_TOOL_PHY_PAGE_ADDR_REG,
@@ -311,8 +301,8 @@ int mv_eth_tool_get_settings(struct net_device *netdev, struct ethtool_cmd *cmd)
 	struct mii_if_info 	mii;
 	int			retval;
 	MV_ETH_PORT_STATUS 	status;
-	
-#ifdef CONFIG_MII	
+
+#ifdef CONFIG_MII
 	mii.dev			= netdev;
 	mii.phy_id_mask 	= 0x1F;
 	mii.reg_num_mask 	= 0x1F;
@@ -329,11 +319,11 @@ int mv_eth_tool_get_settings(struct net_device *netdev, struct ethtool_cmd *cmd)
 
 	/* Get some values from MAC */
 	mvEthStatusGet(priv->hal_priv, &status);
-	
+
 	switch (status.speed) {
 	case MV_ETH_SPEED_1000:
 		cmd->speed = SPEED_1000;
-		break;	
+		break;
 	case MV_ETH_SPEED_100:
 		cmd->speed = SPEED_100;
 		break;
@@ -344,7 +334,7 @@ int mv_eth_tool_get_settings(struct net_device *netdev, struct ethtool_cmd *cmd)
 		return -EINVAL;
 	}
 
-	if (status.duplex == MV_ETH_DUPLEX_FULL) 
+	if (status.duplex == MV_ETH_DUPLEX_FULL)
 		cmd->duplex = 1;
 	else
 		cmd->duplex = 0;
@@ -405,14 +395,13 @@ int mv_eth_tool_restore_settings(struct net_device *netdev)
 		default:
 			return -EINVAL;
 	}
-	
+
 	if (priv->autoneg_cfg == AUTONEG_ENABLE) {
 		err = mvEthSpeedDuplexSet(priv->hal_priv,
 					  MV_ETH_SPEED_AN, MV_ETH_DUPLEX_AN);
 
 		/* Restart AN on PHY enables it */
 		if (!err) {
-
 			err = mvEthPhyRestartAN(mv_phy_addr, MV_ETH_TOOL_AN_TIMEOUT);
 			if (err == MV_TIMEOUT) {
 				MV_ETH_PORT_STATUS ps;
@@ -540,7 +529,7 @@ void mv_eth_tool_get_regs(struct net_device *netdev,
 
 	memset(p, 0, MV_ETH_TOOL_REGS_LEN * sizeof(uint32_t));
 
-	regs->version = mvCtrlModelRevGet(); 
+	regs->version = mvCtrlModelRevGet();
 
 	/* ETH port registers */
 	regs_buff[0]  = MV_REG_READ(ETH_PORT_STATUS_REG(priv->port));
@@ -565,7 +554,7 @@ void mv_eth_tool_get_regs(struct net_device *netdev,
 	regs_buff[18] = MV_REG_READ(ETH_UNIT_INTR_MASK_REG(priv->port));
 	regs_buff[19] = MV_REG_READ(ETH_UNIT_ERROR_ADDR_REG(priv->port));
 	regs_buff[20] = MV_REG_READ(ETH_UNIT_INT_ADDR_ERROR_REG(priv->port));
-	
+
 }
 
 /******************************************************************************
@@ -611,7 +600,7 @@ u32 mv_eth_tool_get_link(struct net_device *netdev)
 	mvEthStatusGet(priv->hal_priv, &status);
 	if (status.isLinkUp == MV_TRUE)
 		return 1;
-	
+
 	return 0;
 }
 
@@ -636,7 +625,7 @@ int mv_eth_tool_get_coalesce(struct net_device *netdev,
 	if (mvEthCoalGet(priv->hal_priv, &cmd->rx_coalesce_usecs,
 	    &cmd->tx_coalesce_usecs) != MV_OK)
 		return -EINVAL;
-	
+
 	return 0;
 }
 
@@ -668,11 +657,11 @@ int mv_eth_tool_set_coalesce(struct net_device *netdev,
 	if ((cmd->rx_coalesce_usecs * 166 / 64 > 0x3FFF) ||
 		(cmd->tx_coalesce_usecs * 166 / 64 > 0x3FFF))
 		return -EINVAL;
-	
+
 	/* Save values for mv_eth_start_internals() */
 	priv->rx_coal_usec = cmd->rx_coalesce_usecs;
 	priv->tx_coal_usec = cmd->tx_coalesce_usecs;
-	
+
 	mvEthRxCoalSet (priv->hal_priv, cmd->rx_coalesce_usecs);
 	mvEthTxCoalSet (priv->hal_priv, cmd->tx_coalesce_usecs);
 
@@ -725,7 +714,7 @@ void mv_eth_tool_get_pauseparam(struct net_device *netdev,
 	MV_U32			reg;
 
 	reg = MV_REG_READ(ETH_PORT_SERIAL_CTRL_REG(pPortCtrl->portNo));
-	
+
 	pause->rx_pause = 0;
 	pause->tx_pause = 0;
 
@@ -764,7 +753,7 @@ int mv_eth_tool_set_pauseparam( struct net_device *netdev,
 {
 	mv_eth_priv 		*priv = MV_ETH_PRIV(netdev);
 	ETH_PORT_CTRL		*pPortCtrl = (ETH_PORT_CTRL*)(priv->hal_priv);
-	
+
 	if (pause->rx_pause && pause->tx_pause) { /* Enable FC */
 		if (pause->autoneg) { /* autoneg enable */
 			return mvEthFlowCtrlSet(priv->hal_priv, MV_ETH_FC_AN_ADV_SYM);
@@ -784,133 +773,6 @@ int mv_eth_tool_set_pauseparam( struct net_device *netdev,
 }
 
 /******************************************************************************
-* mv_eth_tool_get_rx_csum
-* Description:
-*	ethtool get RX checksum offloading status
-* INPUT:
-*	netdev		Network device structure pointer
-* OUTPUT
-*	None
-* RETURN:
-*	RX checksum
-*
-*******************************************************************************/
-u32 mv_eth_tool_get_rx_csum(struct net_device *netdev)
-{
-	mv_eth_priv 	*priv = MV_ETH_PRIV(netdev);
-#ifdef RX_CSUM_OFFLOAD
-	return (priv->rx_csum_offload != 0);
-#else
-	return 0;
-#endif
-}
-
-/******************************************************************************
-* mv_eth_tool_set_rx_csum
-* Description:
-*	ethtool enable/disable RX checksum offloading
-* INPUT:
-*	netdev		Network device structure pointer
-*	data		Command data
-* OUTPUT
-*	None
-* RETURN:
-*	0 on success
-*
-*******************************************************************************/
-int mv_eth_tool_set_rx_csum(struct net_device *netdev, uint32_t data)
-{
-	mv_eth_priv 	*priv = MV_ETH_PRIV(netdev);
-#ifdef RX_CSUM_OFFLOAD
-	priv->rx_csum_offload = data;
-	return 0;
-#else
-	return data ? -EINVAL : 0;
-#endif
-}
-
-/******************************************************************************
-* mv_eth_tool_set_tx_csum
-* Description:
-*	ethtool enable/disable TX checksum offloading
-* INPUT:
-*	netdev		Network device structure pointer
-*	data		Command data
-* OUTPUT
-*	None
-* RETURN:
-*	0 on success
-*
-*******************************************************************************/
-int mv_eth_tool_set_tx_csum(struct net_device *netdev, uint32_t data)
-{
-#ifdef TX_CSUM_OFFLOAD
-	if (data) {
-		netdev->features |= NETIF_F_IP_CSUM;
-	} else {
-		netdev->features &= ~NETIF_F_IP_CSUM;
-	}
-	return 0;
-#else
-	return data ? -EINVAL : 0;
-#endif /* TX_CSUM_OFFLOAD */
-}
-
-/******************************************************************************
-* mv_eth_tool_set_tso
-* Description:
-*	ethtool enable/disable TCP segmentation offloading
-* INPUT:
-*	netdev		Network device structure pointer
-*	data		Command data
-* OUTPUT
-*	None
-* RETURN:
-*	0 on success
-*
-*******************************************************************************/
-int mv_eth_tool_set_tso(struct net_device *netdev, uint32_t data)
-{
-#ifdef ETH_INCLUDE_TSO
-	if (data) {
-		netdev->features |= NETIF_F_TSO;
-	} else {
-		netdev->features &= ~NETIF_F_TSO;
-	}
-	return 0;
-#else
-	return data ? -EINVAL : 0;
-#endif /* ETH_INCLUDE_TSO */
-}
-
-/******************************************************************************
-* mv_eth_tool_set_ufo
-* Description:
-*	ethtool enable/disable UDP segmentation offloading
-* INPUT:
-*	netdev		Network device structure pointer
-*	data		Command data
-* OUTPUT
-*	None
-* RETURN:
-*	0 on success
-*
-*******************************************************************************/
-int mv_eth_tool_set_ufo(struct net_device *netdev, uint32_t data)
-{
-#ifdef ETH_INCLUDE_UFO
-	if (data) {
-		netdev->features |= NETIF_F_UFO;
-	} else {
-		netdev->features &= ~NETIF_F_UFO;
-	}
-	return 0;
-#else
-	return data ? -EINVAL : 0;
-#endif /* ETH_INCLUDE_UFO */
-}
-
-/******************************************************************************
 * mv_eth_tool_get_strings
 * Description:
 *	ethtool get strings (used for statistics and self-test descriptions)
@@ -931,34 +793,34 @@ void mv_eth_tool_get_strings(struct net_device *netdev,
 	char qnum[8][4] = {" Q0"," Q1"," Q2"," Q3"," Q4"," Q5"," Q6"," Q7"};
 
 	switch (stringset) {
-		case ETH_SS_TEST:
-			/*
-			memcpy(data, *mv_eth_tool_gstrings_test,
-			       MV_ETH_TOOL_TEST_LEN*ETH_GSTRING_LEN); */
-			break;
-		case ETH_SS_STATS:
-			for (i = 0; i < MV_ETH_TOOL_GLOBAL_STATS_LEN; i++) {
-				memcpy(p, mv_eth_tool_global_strings_stats[i].stat_string,
-				       ETH_GSTRING_LEN);
+	case ETH_SS_TEST:
+		/*
+		memcpy(data, *mv_eth_tool_gstrings_test,
+		       MV_ETH_TOOL_TEST_LEN*ETH_GSTRING_LEN); */
+		break;
+	case ETH_SS_STATS:
+		for (i = 0; i < MV_ETH_TOOL_GLOBAL_STATS_LEN; i++) {
+			memcpy(p, mv_eth_tool_global_strings_stats[i].stat_string,
+			       ETH_GSTRING_LEN);
+			p += ETH_GSTRING_LEN;
+		}
+		for (q = 0; q < MV_ETH_RX_Q_NUM; q++) {
+			for (i = 0; i < MV_ETH_TOOL_RX_QUEUE_STATS_LEN; i++) {
+				const char *str = mv_eth_tool_rx_queue_strings_stats[i].stat_string;
+				memcpy(p, str, ETH_GSTRING_LEN);
+				strcat(p, qnum[q]);
 				p += ETH_GSTRING_LEN;
 			}
-			for (q = 0; q < MV_ETH_RX_Q_NUM; q++) {
-				for (i = 0; i < MV_ETH_TOOL_RX_QUEUE_STATS_LEN; i++) {
-					const char *str = mv_eth_tool_rx_queue_strings_stats[i].stat_string;
-					memcpy(p, str, ETH_GSTRING_LEN);
-					strcat(p, qnum[q]);
-					p += ETH_GSTRING_LEN;
-				}
-			}
-			for (q = 0; q < MV_ETH_TX_Q_NUM; q++) {
-				for (i = 0; i < MV_ETH_TOOL_TX_QUEUE_STATS_LEN; i++) {
-					const char *str = mv_eth_tool_tx_queue_strings_stats[i].stat_string;
-					memcpy(p, str, ETH_GSTRING_LEN);
-					strcat(p, qnum[q]);
-					p += ETH_GSTRING_LEN;
-				}
+		}
+		for (q = 0; q < MV_ETH_TX_Q_NUM; q++) {
+			for (i = 0; i < MV_ETH_TOOL_TX_QUEUE_STATS_LEN; i++) {
+				const char *str = mv_eth_tool_tx_queue_strings_stats[i].stat_string;
+				memcpy(p, str, ETH_GSTRING_LEN);
+				strcat(p, qnum[q]);
+				p += ETH_GSTRING_LEN;
 			}
-			break;
+		}
+		break;
 	}
 }
 
@@ -985,7 +847,7 @@ int mv_eth_tool_phys_id(struct net_device *netdev, u32 data)
 
 	if(!data || data > (u32)(MAX_SCHEDULE_TIMEOUT / HZ))
 		data = (u32)(MAX_SCHEDULE_TIMEOUT / HZ);
-	
+
 	mv_eth_tool_read_phy_reg(priv->phy_id, ETH_TOOL_PHY_LED_CTRL_PAGE,
 				ETH_TOOL_PHY_LED_CTRL_REG, &old_led_state);
 	/* Forse LED blinking (all LED pins) */
@@ -1040,7 +902,7 @@ void mv_eth_tool_get_ethtool_stats(struct net_device *netdev,
 		pdest[i] =  *(uint32_t *)p;
 	}
 	pdest += MV_ETH_TOOL_GLOBAL_STATS_LEN;
-	
+
 	for (q = 0; q < MV_ETH_RX_Q_NUM; q++) {
 		for (i = 0; i < MV_ETH_TOOL_RX_QUEUE_STATS_LEN; i++) {
 			char *p = (char *)priv +
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_network/mv_ethernet/mv_eth_tool.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_network/mv_ethernet/mv_eth_tool.h
index e4c9860..8f06795 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_network/mv_ethernet/mv_eth_tool.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_network/mv_ethernet/mv_eth_tool.h
@@ -63,18 +63,6 @@ int mv_eth_tool_set_pauseparam
 		(struct net_device *netdev, struct ethtool_pauseparam *pause);
 void mv_eth_tool_get_drvinfo
 		(struct net_device *netdev, struct ethtool_drvinfo *info);
-#if 0
-u32 mv_eth_tool_get_rx_csum
-		(struct net_device *netdev);
-int mv_eth_tool_set_rx_csum
-		(struct net_device *netdev, uint32_t data);
-int mv_eth_tool_set_tx_csum
-		(struct net_device *netdev, uint32_t data);
-int mv_eth_tool_set_tso
-		(struct net_device *netdev, uint32_t data);
-int mv_eth_tool_set_ufo
-		(struct net_device *netdev, uint32_t data);
-#endif
 void mv_eth_tool_get_strings
 		(struct net_device *netdev, uint32_t stringset, uint8_t *data);
 int mv_eth_tool_phys_id
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig
index a81043a..a4c119f 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig
@@ -692,10 +692,11 @@ endmenu
 menu "PON support for Network driver"
 
 config MV_PON
-        bool "PON support"
-        depends on MV_ETH_PP2 && MV_INCLUDE_PON
-        ---help---
-        Choose this option to support PON port in Marvell network driver
+	bool "PON support"
+	default y
+	depends on MV_ETH_PP2 && MV_INCLUDE_PON
+	help
+	  Choose this option to support PON port in Marvell network driver
 
 config MV_PON_TXP_DEF
         int "Default T-CONT to send local generated packets"
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c
index 44e50fb..3fbedf2 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c
@@ -148,6 +148,7 @@ static ssize_t mv_eth_2_hex_store(struct device *dev,
 
 	local_irq_save(flags);
 
+#ifdef CONFIG_MV_ETH_STAT_DBG
 	if (!strcmp(name, "debug")) {
 		err = mv_eth_ctrl_dbg_flag(p, MV_ETH_F_DBG_RX,   v & 0x1);
 		err = mv_eth_ctrl_dbg_flag(p, MV_ETH_F_DBG_TX,   v & 0x2);
@@ -155,6 +156,7 @@ static ssize_t mv_eth_2_hex_store(struct device *dev,
 		err = mv_eth_ctrl_dbg_flag(p, MV_ETH_F_DBG_POLL, v & 0x8);
 		err = mv_eth_ctrl_dbg_flag(p, MV_ETH_F_DBG_DUMP, v & 0x10);
 	}
+#endif
 
 	return err ? -EINVAL : len;
 }
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tool.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tool.c
index 0a0cac6..c0dc4b7 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tool.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_tool.c
@@ -58,13 +58,11 @@ disclaimer.
 
 #define MV_ETH_TOOL_AN_TIMEOUT	5000
 
-
 static int isSwitch(struct eth_port *priv)
 {
 	return (priv->flags & (MV_ETH_F_SWITCH | MV_ETH_F_EXT_SWITCH));
 }
 
-
 /******************************************************************************
 * mv_eth_tool_get_settings
 * Description:
@@ -650,112 +648,6 @@ int mv_eth_tool_set_pauseparam(struct net_device *netdev,
 }
 
 /******************************************************************************
-* mv_eth_tool_get_rx_csum
-* Description:
-*	ethtool get RX checksum offloading status
-* INPUT:
-*	netdev		Network device structure pointer
-* OUTPUT
-*	None
-* RETURN:
-*	RX checksum
-*
-*******************************************************************************/
-u32 mv_eth_tool_get_rx_csum(struct net_device *netdev)
-{
-#ifdef CONFIG_MV_ETH_RX_CSUM_OFFLOAD
-	struct eth_port *priv = MV_ETH_PRIV(netdev);
-
-	return (priv->rx_csum_offload != 0);
-#else
-	return 0;
-#endif
-}
-
-/******************************************************************************
-* mv_eth_tool_set_rx_csum
-* Description:
-*	ethtool enable/disable RX checksum offloading
-* INPUT:
-*	netdev		Network device structure pointer
-*	data		Command data
-* OUTPUT
-*	None
-* RETURN:
-*	0 on success
-*
-*******************************************************************************/
-int mv_eth_tool_set_rx_csum(struct net_device *netdev, uint32_t data)
-{
-#ifdef CONFIG_MV_ETH_RX_CSUM_OFFLOAD
-	struct eth_port *priv = MV_ETH_PRIV(netdev);
-
-	priv->rx_csum_offload = data;
-	return 0;
-#else
-	return -EOPNOTSUPP;
-#endif
-}
-
-/******************************************************************************
-* mv_eth_tool_set_tx_csum
-* Description:
-*	ethtool enable/disable TX checksum offloading
-* INPUT:
-*	netdev		Network device structure pointer
-*	data		Command data
-* OUTPUT
-*	None
-* RETURN:
-*	0 on success
-*
-*******************************************************************************/
-int mv_eth_tool_set_tx_csum(struct net_device *netdev, uint32_t data)
-{
-#ifdef CONFIG_MV_ETH_TX_CSUM_OFFLOAD
-	if (data) {
-		if (netdev->mtu > MV_ETH_TX_CSUM_MAX_SIZE) {
-			printk(KERN_ERR "Cannot set TX checksum when MTU > %d\n", MV_ETH_TX_CSUM_MAX_SIZE);
-			return -EOPNOTSUPP;
-		}
-		netdev->features |= NETIF_F_IP_CSUM;
-	} else {
-		netdev->features &= ~NETIF_F_IP_CSUM;
-	}
-
-	return 0;
-#else
-	return -EOPNOTSUPP;
-#endif /* TX_CSUM_OFFLOAD */
-}
-
-/******************************************************************************
-* mv_eth_tool_set_tso
-* Description:
-*	ethtool enable/disable TCP segmentation offloading
-* INPUT:
-*	netdev		Network device structure pointer
-*	data		Command data
-* OUTPUT
-*	None
-* RETURN:
-*	0 on success
-*
-*******************************************************************************/
-int mv_eth_tool_set_tso(struct net_device *netdev, uint32_t data)
-{
-#if defined(CONFIG_MV_ETH_TSO)
-	if (data)
-		netdev->features |= NETIF_F_TSO;
-	else
-		netdev->features &= ~NETIF_F_TSO;
-
-	return 0;
-#else
-	return -EOPNOTSUPP;
-#endif
-}
-/******************************************************************************
 * mv_eth_tool_get_strings
 * Description:
 *	ethtool get strings (used for statistics and self-test descriptions)
@@ -793,8 +685,7 @@ int mv_eth_tool_get_stats_count(struct net_device *netdev)
 	return 0;
 }
 
-static int mv_eth_tool_get_rxfh_indir(struct net_device *netdev,
-							struct ethtool_rxfh_indir *indir)
+static int mv_eth_tool_get_rxfh_indir(struct net_device *netdev, u32 *p)
 {
 /*HW support in PPv2 step 2 */
 #if defined(MV_ETH_PNC_LB)
@@ -812,8 +703,7 @@ static int mv_eth_tool_get_rxfh_indir(struct net_device *netdev,
 #endif
 }
 
-static int mv_eth_tool_set_rxfh_indir(struct net_device *netdev,
-							   const struct ethtool_rxfh_indir *indir)
+static int mv_eth_tool_set_rxfh_indir(struct net_device *netdev, u32 *p)
 {
 /*HW support in PPv2 step 2 */
 #if defined(MV_ETH_PNC_LB)
@@ -842,60 +732,6 @@ static int mv_eth_tool_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *i
 }
 
 /******************************************************************************
-* mv_eth_tool_set_rx_ntuple
-* Description:
-*	ethtool set mapping from 2t/5t rule to rxq/drop
-*	ignore mask parameters (assume mask=0xFF for each byte provided)
-*	support only tcp4 / udp4 protocols
-*	support only full 2t/5t rules:
-*		** 2t - must provide src-ip, dst-ip
-*		** 5t - must provide src-ip, dst-ip, src-port, dst-port
-* INPUT:
-*	netdev		Network device structure pointer
-*	ntuple
-* OUTPUT
-*	None
-* RETURN:
-*
-*******************************************************************************/
-static int mv_eth_tool_set_rx_ntuple(struct net_device *dev, struct ethtool_rx_ntuple *ntuple)
-{
-/*TODO*/
-	unsigned int sip, dip, ports, sport, dport, proto;
-	struct eth_port *pp;
-
-	return -EOPNOTSUPP;
-
-	if ((ntuple->fs.flow_type != TCP_V4_FLOW) && (ntuple->fs.flow_type != UDP_V4_FLOW))
-		return -EOPNOTSUPP;
-
-	if ((ntuple->fs.action >= CONFIG_MV_ETH_RXQ) || (ntuple->fs.action < ETHTOOL_RXNTUPLE_ACTION_CLEAR))
-		return -EINVAL;
-
-	if (ntuple->fs.flow_type == TCP_V4_FLOW)
-		proto = 6;/*tcp*/
-	else
-		proto = 17;/*udp*/
-
-	sip = ntuple->fs.h_u.tcp_ip4_spec.ip4src;
-	dip = ntuple->fs.h_u.tcp_ip4_spec.ip4dst;
-	sport = ntuple->fs.h_u.tcp_ip4_spec.psrc;
-	dport = ntuple->fs.h_u.tcp_ip4_spec.pdst;
-	if (!sip || !dip)
-		return -EINVAL;
-
-	pp = MV_ETH_PRIV(dev);
-	if (!sport || !dport) {/*2-tuple*/
-		/*pnc_ip4_2tuple_rxq(pp->port, sip, dip, ntuple->fs.action);*/
-	} else {
-		ports = (dport << 16) | ((sport << 16) >> 16);
-		/*pnc_ip4_5tuple_rxq(pp->port, sip, dip, ports, proto, ntuple->fs.action);*/
-	}
-
-	return 0;
-}
-
-/******************************************************************************
 * mv_eth_tool_get_ethtool_stats
 * Description:
 *	ethtool get statistics
@@ -928,14 +764,6 @@ const struct ethtool_ops mv_eth_tool_ops = {
 	.set_ringparam 				= mv_eth_tool_set_ringparam,
 	.get_pauseparam				= mv_eth_tool_get_pauseparam,
 	.set_pauseparam				= mv_eth_tool_set_pauseparam,
-	.get_rx_csum				= mv_eth_tool_get_rx_csum,
-	.set_rx_csum				= mv_eth_tool_set_rx_csum,
-	.get_tx_csum				= ethtool_op_get_tx_csum,
-	.set_tx_csum				= mv_eth_tool_set_tx_csum,
-	.get_sg					= ethtool_op_get_sg,
-	.set_sg					= ethtool_op_set_sg,
-	.get_tso				= ethtool_op_get_tso,
-	.set_tso				= mv_eth_tool_set_tso,
 	.get_strings				= mv_eth_tool_get_strings,/*TODO: complete implementation */
 #if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 32)
 	.get_stats_count			= mv_eth_tool_get_stats_count,/*TODO: complete implementation */
@@ -943,6 +771,5 @@ const struct ethtool_ops mv_eth_tool_ops = {
 	.get_ethtool_stats			= mv_eth_tool_get_ethtool_stats,/*TODO: complete implementation */
 	.get_rxfh_indir				= mv_eth_tool_get_rxfh_indir,
 	.set_rxfh_indir				= mv_eth_tool_set_rxfh_indir,
-	.get_rxnfc                  		= mv_eth_tool_get_rxnfc,/*TODO new implementation*/
-	.set_rx_ntuple				= mv_eth_tool_set_rx_ntuple,/*TODO new implementation*/
+	.get_rxnfc				= mv_eth_tool_get_rxnfc,/*TODO new implementation*/
 };
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
index 24980a6..dcef960 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
@@ -61,6 +61,7 @@ disclaimer.
 
 #define MV_ETH_TX_PENDING_TIMEOUT_MSEC     1000
 
+void handle_group_affinity(int port);
 static inline int mv_eth_tx_policy(struct eth_port *pp, struct sk_buff *skb);
 
 #ifdef CONFIG_NET_SKB_RECYCLE
@@ -1470,7 +1471,7 @@ inline struct pp2_rx_desc *mv_eth_rx_prefetch(struct eth_port *pp, MV_PP2_PHYS_R
 static inline void mv_eth_buff_hdr_rx(struct eth_port *pp, struct pp2_rx_desc *rx_desc)
 {
 	u32 rx_status = rx_desc->status;
-	int mc_id, count = 0, pool_id, is_hwf;
+	int mc_id, pool_id;
 	PP2_BUFF_HDR *buff_hdr;
 	MV_U32 buff_phys_addr, buff_virt_addr;
 
@@ -1483,6 +1484,7 @@ static inline void mv_eth_buff_hdr_rx(struct eth_port *pp, struct pp2_rx_desc *r
 		buff_hdr = (PP2_BUFF_HDR *)buff_virt_addr;
 		mc_id = PP2_BUFF_HDR_INFO_MC_ID(buff_hdr->info);
 
+#ifdef CONFIG_MV_ETH_DEBUG_CODE
 		if (pp->dbg_flags & MV_ETH_F_DBG_RX) {
 			printk(KERN_ERR "buff header #%d:\n", ++count);
 			mvDebugMemDump(buff_hdr, 32, 1);
@@ -1491,6 +1493,7 @@ static inline void mv_eth_buff_hdr_rx(struct eth_port *pp, struct pp2_rx_desc *r
 				buff_hdr->byteCount, mc_id,
 				PP2_BUFF_HDR_INFO_IS_LAST(buff_hdr->info));
 		}
+#endif
 
 		/* release buffer */
 		mvBmPoolMcPut(pool_id, buff_phys_addr, buff_virt_addr, mc_id, 0);
@@ -1499,7 +1502,9 @@ static inline void mv_eth_buff_hdr_rx(struct eth_port *pp, struct pp2_rx_desc *r
 		buff_virt_addr = GET_BUFF_FROM_PKT(buff_hdr->nextBuffVirtAddr);
 	} while (!PP2_BUFF_HDR_INFO_IS_LAST(buff_hdr->info));
 
+#ifdef CONFIG_MV_ETH_STAT_DBG
 	pp->stats.rx_drop_sw++;
+#endif
 }
 
 static inline int mv_eth_rx(struct eth_port *pp, int rx_todo, int rxq)
@@ -1550,7 +1555,7 @@ static inline int mv_eth_rx(struct eth_port *pp, int rx_todo, int rxq)
 			printk(KERN_ERR "\n%s: port=%d, cpu=%d\n", __func__, pp->port, smp_processor_id());
 			mv_eth_rx_desc_print(rx_desc);
 		}
-#endif /* CONFIG_MV_ETH_DEBUG_CODE */
+#endif
 
 		rx_status = rx_desc->status;
 		/* check if buffer header is used */
@@ -3971,8 +3976,10 @@ int mv_eth_change_mtu_internals(struct net_device *dev, int mtu)
 
 	if (test_bit(MV_ETH_F_STARTED_BIT, &(pp->flags))) {
 		STAT_ERR(pp->stats.state_err++);
+#ifdef CONFIG_MV_ETH_DEBUG_CODE
 		if (pp->dbg_flags & MV_ETH_F_DBG_RX)
 			printk(KERN_ERR "%s: port %d, STARTED_BIT = 0, Invalid value.\n", __func__, pp->port);
+#endif
 		return -1;
 	}
 
-- 
1.7.5.4

