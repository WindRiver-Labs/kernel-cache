From 4aa0f3c7c041d7bddeedcfb5348760b477182994 Mon Sep 17 00:00:00 2001
From: Dovrat <dovrat@marvell.com>
Date: Thu, 10 Apr 2014 22:39:09 +0300
Subject: [PATCH 1553/1825] pp3: bm: r/w register, macros, verification

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 5a42fe7eef672c596646aed891a282f8477929ee

Change-Id: I9fa45a32012968a057ff7a29746176cf58ff1925
Signed-off-by: Dovrat <dovrat@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/7101
Reviewed-by: Eliezer Ben Zeev <eliezerb@marvell.com>
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Tested-by: Dmitri Epshtein <dima@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/net/ethernet/marvell/pp3/bm/mv_bm.c |  125 ++++++++-------------------
 drivers/net/ethernet/marvell/pp3/bm/mv_bm.h |   24 +++---
 2 files changed, 47 insertions(+), 102 deletions(-)

diff --git a/drivers/net/ethernet/marvell/pp3/bm/mv_bm.c b/drivers/net/ethernet/marvell/pp3/bm/mv_bm.c
index da1d869..a03957b 100644
--- a/drivers/net/ethernet/marvell/pp3/bm/mv_bm.c
+++ b/drivers/net/ethernet/marvell/pp3/bm/mv_bm.c
@@ -303,6 +303,11 @@ int bm_qm_gpm_pools_def_quick_init(u32 num_of_buffers, struct mv_a40 *qece_base_
 	int rc = -BM_INPUT_NOT_IN_RANGE;
 	u32 ae_thr, af_thr, cache_vmid, cache_attr, cache_so_thr, cache_si_thr, cache_num_of_buffers;
 
+	if (num_of_buffers != BM_NUM_OF_BUFFERS_QM_GPM_MAX)	{
+		pr_err("Default number of Buffer should be %d, Make sure you allocate the correct pool size\n",
+			BM_NUM_OF_BUFFERS_QM_GPM_MAX);
+		return rc;
+	}
 	ae_thr               = BM_AE_THR_DEF(num_of_buffers);
 	af_thr               = BM_AF_THR_DEF(num_of_buffers);
 	cache_vmid           = BM_CACHE_VMID_DEF;
@@ -322,6 +327,11 @@ int bm_qm_dram_pools_def_quick_init(u32 num_of_buffers, struct mv_a40 *qece_base
 	int rc = -BM_INPUT_NOT_IN_RANGE;
 	u32 ae_thr, af_thr, cache_vmid, cache_attr, cache_so_thr, cache_si_thr, cache_num_of_buffers;
 
+	if (num_of_buffers != BM_NUM_OF_BUFFERS_QM_GPM_MAX)	{
+		pr_err("Default number of Buffer should be %d, Make sure you allocate the correct pool size\n",
+			BM_NUM_OF_BUFFERS_QM_GPM_MAX);
+		return rc;
+	}
 	ae_thr               = BM_AE_THR_DEF(num_of_buffers);
 	af_thr               = BM_AF_THR_DEF(num_of_buffers);
 	cache_vmid           = BM_CACHE_VMID_DEF;
@@ -359,6 +369,10 @@ int bm_qm_gpm_pools_quick_init(u32 num_of_buffers, struct mv_a40 *qece_base_addr
 	granularity_of_pe_in_dram  = GRANULARITY_OF_64_BYTES / QM_PE_SIZE_IN_BYTES_IN_DRAM;		/* 64/4 */
 	granularity_of_pe_in_cache = GRANULARITY_OF_64_BYTES / QM_PE_SIZE_IN_BYTES_IN_CACHE;	/* 64/8 */
 
+	if (num_of_buffers < cache_num_of_buffers) {
+		pr_err("Number of buffers in DRAM should be equal or larger than cache number of buffers\n");
+		return rc;
+	}
 	if       ((num_of_buffers % granularity_of_pe_in_dram)  != 0) {
 		pr_err("number of buffer should be multiplication of %d\n", granularity_of_pe_in_dram);
 		return rc;  /*qm PE are always 22bits which is 4Bytes */
@@ -488,6 +502,7 @@ int bm_qm_gpm_pools_quick_init(u32 num_of_buffers, struct mv_a40 *qece_base_addr
 	if (rc != OK)
 		return rc;
 
+	pr_info("Pool 0 is enabled\n");
 	pool = 1;
 	base_address.dma_msb = qece_base_address->dma_msb;
 	base_address.dma_lsb = qece_base_address->dma_lsb;
@@ -508,6 +523,7 @@ int bm_qm_gpm_pools_quick_init(u32 num_of_buffers, struct mv_a40 *qece_base_addr
 	if (rc != OK)
 		return rc;
 	rc = bm_pool_enable(pool, quick_init);
+	pr_info("Pool 1 is enabled\n");
 	return rc;
 }
 
@@ -525,6 +541,10 @@ int bm_qm_dram_pools_quick_init(u32 num_of_buffers, struct mv_a40 *qece_base_add
 	granularity_of_pe_in_dram  = GRANULARITY_OF_64_BYTES / QM_PE_SIZE_IN_BYTES_IN_DRAM;		/* 64/4 */
 	granularity_of_pe_in_cache = GRANULARITY_OF_64_BYTES / QM_PE_SIZE_IN_BYTES_IN_CACHE;	/* 64/4 */
 
+	if (num_of_buffers < cache_num_of_buffers) {
+		pr_err("Number of Buffer in DRAM should be equal or larger than cache number of buffers\n");
+		return rc;
+	}
 	if       ((num_of_buffers % granularity_of_pe_in_dram)  != 0)
 		return rc;  /*qm PE are always 22bits which is 4Bytes */
 	if               ((ae_thr % granularity_of_pe_in_dram)  != 0)
@@ -675,12 +695,18 @@ int bm_pool_quick_init_status_get(u32 pool, u32 *completed)
 	u32 pid, bid, pid_local;
 	struct bm_pool_st   reg_pool_st;
 
-	if ((pool           <     BM_POOL_MIN) || (pool           >     BM_POOL_MAX))
+	if ((pool           <     BM_POOL_MIN) || (pool           >     BM_POOL_MAX)) {
+		pr_err("Wrong pool number %d\n", pool);
 		return rc;
-	if ((pool           >  BM_POOL_QM_MAX) && (pool           <  BM_POOL_GP_MIN))
+	}
+	if ((pool           >  BM_POOL_QM_MAX) && (pool           <  BM_POOL_GP_MIN)) {
+		pr_err("Wrong pool number %d\n", pool);
 		return rc; /* pools 4, 5, 6, 7 don't exist */
-	if (((u32)completed < BM_DATA_PTR_MIN) || ((u32)completed > BM_DATA_PTR_MAX))
+	}
+	if (((u32)completed < BM_DATA_PTR_MIN) || ((u32)completed > BM_DATA_PTR_MAX)) {
+		pr_err("Something is wrong\n");
 		return rc;
+	}
 
 	pid       = (int)pool;
 	bid       = BM_PID_TO_BANK(pid);
@@ -2985,57 +3011,36 @@ int bm_pool_disable(u32 pool)
 	return rc;
 }
 
-#define	COMPLETE_HW_WRITE
-
-#define	my_RW_DEBUG_UNITEST	/* for unitest */
-#ifdef my_RW_DEBUG_UNITEST
 int bm_register_read(u32 base_address, u32 offset, u32 wordsNumber, u32 *dataPtr)
 {
 	int rc = -BM_INPUT_NOT_IN_RANGE;
-/*	char reg_name[50];
-*/
+	char reg_name[255];
 	u32 *temp;
 	u32 i;
 
 	if (((u32)dataPtr <  BM_DATA_PTR_MIN) || ((u32)dataPtr >  BM_DATA_PTR_MAX))
 		return rc;
 
-/*	In the future we can also add printing of the fields of the register */
-/*	pr_info(" DUMMY_PRINT  read by function <%s>,  result = 0x%08X\n", __func__, *(u32 *)dataPtr);
-
 	bm_register_name_get(base_address, offset, reg_name);
-	pr_info("[QM-BM]  READ_REG add = 0x%08X : name = %s : value =", base_address, reg_name);
-*/
+	mv_pp3_hw_read(base_address+offset, wordsNumber, dataPtr);
+	pr_info("[QM-BM] READ_REG add = 0x%08X : name = %s : value =", base_address, reg_name);
 	temp = dataPtr;
 	for (i = 0; i < wordsNumber; i++) {
-		/*
-		pr_info(" 0x%08X", *(u32 *)temp);*/
-		*(u32 *)temp = 0;
+		pr_info(" 0x%08X", *(u32 *)temp);
 		temp++;
 	}
 	pr_info("\n");
-/*	return OK;	 */
-/*
-	rc = mv_pp3_hw_read(base_address+offset, wordsNumber, dataPtr);
-	if (rc != OK) {
-		pr_info(" Not Available\n");
-		return rc;
-	}
-*/
-/*	if (rc != OK)
-		return rc;*/
 
-	COMPLETE_HW_WRITE
 	rc = OK;
 	return rc;
 }
 
 int bm_register_write(u32 base_address, u32 offset, u32 wordsNumber, u32 *dataPtr)
 {
-	char reg_name[50];
 	int rc = -BM_INPUT_NOT_IN_RANGE;
+	char reg_name[255];
+	int i;
 	u32 *temp;
-	u32 i;
 
 	if (((u32)dataPtr <  BM_DATA_PTR_MIN) || ((u32)dataPtr >  BM_DATA_PTR_MAX))
 		return rc;
@@ -3048,73 +3053,13 @@ int bm_register_write(u32 base_address, u32 offset, u32 wordsNumber, u32 *dataPt
 		temp++;
 	}
 	pr_info("\n");
-
-/*	pr_info(" DUMMY_PRINT, result=%d\n", *(u32 *)dataPtr);*/
-/*	pr_info(" DUMMY_PRINT, result = 0x%08X\n", *(u32 *)dataPtr);*/
-/*	pr_info(" DUMMY_PRINT write by function <%s>, result = 0x%08X\n", __func__, *(u32 *)dataPtr);*/
-
-/*	return OK;	 */
-/*
-	rc = mv_pp3_hw_write(base_address+offset, wordsNumber, dataPtr);
-	if (rc != OK)
-		return rc;
-*/
-
-	COMPLETE_HW_WRITE
-	rc = OK;
-	return rc;
-}
-#else
-int bm_register_read(u32 base_address, u32 offset, u32 wordsNumber, u32 *dataPtr)
-{
-	int rc = -BM_INPUT_NOT_IN_RANGE;
-
-	if ((base_address <   BM_ADDRESS_MIN) || (base_address >   BM_ADDRESS_MAX))
-		return rc;
-	if ((offset       <    BM_OFFSET_MIN) || (offset       >    BM_OFFSET_MAX))
-		return rc;
-	if ((wordsNumber  < BM_DATA_SIZE_MIN) || (wordsNumber  > BM_DATA_SIZE_MAX))
-		return rc;
-	if (((u32)dataPtr <  BM_DATA_PTR_MIN) || ((u32)dataPtr >  BM_DATA_PTR_MAX))
-		return rc;
-
-	/*rc = */
-	mv_pp3_hw_read(base_address+offset, wordsNumber, dataPtr);
-	if (rc != OK)
-		return rc;
-
-	COMPLETE_HW_WRITE
-	rc = OK;
-	return rc;
-}
-
-int bm_register_write(u32 base_address, u32 offset, u32 wordsNumber, u32 *dataPtr)
-{
-	int rc = -BM_INPUT_NOT_IN_RANGE;
-
-	if ((base_address <   BM_ADDRESS_MIN) || (base_address >   BM_ADDRESS_MAX))
-		return rc;
-	if ((offset       <    BM_OFFSET_MIN) || (offset       >    BM_OFFSET_MAX))
-		return rc;
-	if ((wordsNumber  < BM_DATA_SIZE_MIN) || (wordsNumber  > BM_DATA_SIZE_MAX))
-		return rc;
-	if (((u32)dataPtr <  BM_DATA_PTR_MIN) || ((u32)dataPtr >  BM_DATA_PTR_MAX))
-		return rc;
-
-	/*rc = */
 	mv_pp3_hw_write(base_address+offset, wordsNumber, dataPtr);
-	if (rc != OK)
-		return rc;
 
-	COMPLETE_HW_WRITE
 	rc = OK;
 	return rc;
 }
-#endif
 
 void bm_register_register_fields_print(u32 base_address, u32 value)
 {
 
 }
-#ifdef MY_HIDE_DEBUG
-#endif /* MY_HIDE_DEBUG */
diff --git a/drivers/net/ethernet/marvell/pp3/bm/mv_bm.h b/drivers/net/ethernet/marvell/pp3/bm/mv_bm.h
index f0d46c6..746d92b 100644
--- a/drivers/net/ethernet/marvell/pp3/bm/mv_bm.h
+++ b/drivers/net/ethernet/marvell/pp3/bm/mv_bm.h
@@ -110,15 +110,15 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define BM_PE_SIZE_DEF					BM_PE_SIZE_IS_32_BITS	/* 0 - 40 bits, 1 - 32 bits */
 #define BM_POOL_PAIR_GP_DEF				         0	/* 0 -   false, 1 -    true */
 
-/* Almost empty default threshold is ¼ of num_of_buffers truncated to multiplication of 16,
+/* Almost empty default threshold is a quater of num_of_buffers truncated to multiplication of 16,
 		otherwise the range is 0 or 16 to num_of_buffers-32 */
 #define BM_AE_THR_DEF(_num_of_buffers) \
-	(((_num_of_buffers * 1/4) > GRANULARITY_OF_16) ? \
-	TRUNCATE((_num_of_buffers * 1/4),  GRANULARITY_OF_16) : GRANULARITY_OF_16)
+	((((_num_of_buffers) * 1/4) > GRANULARITY_OF_16) ? \
+	TRUNCATE(((_num_of_buffers) * 1/4),  GRANULARITY_OF_16) : GRANULARITY_OF_16)
 
-/*	Almost full  default threshold is ¾ of num_of_buffers rounded   to multiplication of 16,
+/*	Almost full  default threshold 3 quaters of num_of_buffers rounded   to multiplication of 16,
 		otherwise the range is 0 or 32 to num_of_buffers-16 */
-#define BM_AF_THR_DEF(_num_of_buffers)			TRUNCATE((_num_of_buffers * 3/4), GRANULARITY_OF_16)
+#define BM_AF_THR_DEF(_num_of_buffers)			TRUNCATE(((_num_of_buffers) * 3/4), GRANULARITY_OF_16)
 
 #define BM_CACHE_VMID_DEF                        0
 #define BM_CACHE_ATTR_DEF                        1
@@ -197,7 +197,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define BM_CACHE_NUM_OF_BUFFERS_GP_MAX		(0x00000400 - 8)	/* 1024-8 */
 
 #define BM_FILL_LEVEL_MIN			         0
-#define BM_FILL_LEVEL_MAX(_num_of_buffers)	_num_of_buffers
+#define BM_FILL_LEVEL_MAX(_num_of_buffers)	(_num_of_buffers)
 #define BM_QUICK_INIT_MIN			         0
 #define BM_QUICK_INIT_MAX			0x00000001
 #define BM_POOL_PAIR_MIN			         0
@@ -210,19 +210,19 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define BM_CACHE_VMID_MAX			0x0000003F	/*  63 */
 #define BM_CACHE_ATTR_MIN			         0
 #define BM_CACHE_ATTR_MAX			0x000000FF	/* 255 */
-#define BM_AE_THR_MIN(_num_of_buffers)		MV_MIN(0x00000010, _num_of_buffers) /*
+#define BM_AE_THR_MIN(_num_of_buffers)		MV_MIN(0x00000010, (_num_of_buffers)) /*
 	16                unless number of buffers is 0 and then it is also 0 */
-#define BM_AE_THR_MAX(_num_of_buffers)			MV_MAX((_num_of_buffers - 0x00000020), 0) /*
+#define BM_AE_THR_MAX(_num_of_buffers)			MV_MAX(((_num_of_buffers) - 0x00000020), 0) /*
 	num_of_buffers-32 unless number of buffers is 0 and then it is also 0 */
-#define BM_AF_THR_MIN(_num_of_buffers)		MV_MIN(0x00000020, _num_of_buffers) /*
+#define BM_AF_THR_MIN(_num_of_buffers)		MV_MIN(0x00000020, (_num_of_buffers)) /*
 	32                unless number of buffers is 0 and then it is also 0 */
-#define BM_AF_THR_MAX(_num_of_buffers)		MV_MAX((_num_of_buffers - 0x00000010), 0) /*
+#define BM_AF_THR_MAX(_num_of_buffers)		MV_MAX(((_num_of_buffers) - 0x00000010), 0) /*
 	num_of_buffers-16 unless number of buffers is 0 and then it is also 0 */
 #define BM_CACHE_SI_THR_MIN			0x00000010	/*  16 */
-#define BM_CACHE_SI_THR_MAX(_cache_num_of_buffers)		(_cache_num_of_buffers - 0x00000010)	/*
+#define BM_CACHE_SI_THR_MAX(_cache_num_of_buffers)		((_cache_num_of_buffers) - 0x00000010)	/*
 	cache_num_of_buffers - 16 */
 #define BM_CACHE_SO_THR_MIN			0x00000018	/*  24 */
-#define BM_CACHE_SO_THR_MAX(_cache_num_of_buffers)		(_cache_num_of_buffers - 0x00000008)	/*
+#define BM_CACHE_SO_THR_MAX(_cache_num_of_buffers)		((_cache_num_of_buffers) - 0x00000008)	/*
 	cache_num_of_buffers -  8 */
 #define BM_CACHE_START_MIN			         0
 #define BM_CACHE_START_MAX			0xFFFFFFFF
-- 
1.7.5.4

