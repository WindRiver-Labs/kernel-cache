From b96aacc3d94e1eeefc3b5bea24771634177d8989 Mon Sep 17 00:00:00 2001
From: Dmitri Epshtein <dima@marvell.com>
Date: Wed, 3 Jul 2013 10:49:00 -0400
Subject: [PATCH 0757/1825] NETA: Prepare for new gateway driver (MUX)

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 3ab2cc2378a7806c26576731741cad9048fe3065

	Improve mvNetaMaxCheck() function - API changed
	Move few defines to mv802_3.h file

Change-Id: Ib93d55f28c34c1c61f0d1d615a0c4c8975dda5b9
Reviewed-on: http://vgitil04.il.marvell.com:8080/2396
Reviewed-by: Star_Automation <star@marvell.com>
Reviewed-by: Nadav Haklai <nadavh@marvell.com>
Tested-by: Nadav Haklai <nadavh@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/plat-armada/mv_hal/neta/gbe/mvEthRegs.h   |    2 -
 arch/arm/plat-armada/mv_hal/neta/gbe/mvNeta.c      |   96 ++++++++++++--------
 arch/arm/plat-armada/mv_hal/neta/gbe/mvNeta.h      |   35 ++++----
 arch/arm/plat-armada/mv_hal/neta/gbe/mvNetaDebug.c |   10 +-
 arch/arm/plat-armada/mv_hal/neta/gbe/mvNetaRegs.h  |   21 +++--
 arch/arm/plat-armada/mv_hal/neta/pnc/mvPncWol.c    |    4 +-
 6 files changed, 97 insertions(+), 71 deletions(-)

diff --git a/arch/arm/plat-armada/mv_hal/neta/gbe/mvEthRegs.h b/arch/arm/plat-armada/mv_hal/neta/gbe/mvEthRegs.h
index 855edcf..acba134 100644
--- a/arch/arm/plat-armada/mv_hal/neta/gbe/mvEthRegs.h
+++ b/arch/arm/plat-armada/mv_hal/neta/gbe/mvEthRegs.h
@@ -72,8 +72,6 @@ extern "C" {
 
 #include "mvNetaRegs.h"
 
-#define MV_ETH_MH_SIZE					2
-#define MV_ETH_CRC_SIZE                 4
 
 #define ETH_MAX_DECODE_WIN              6
 #define ETH_MAX_HIGH_ADDR_REMAP_WIN     4
diff --git a/arch/arm/plat-armada/mv_hal/neta/gbe/mvNeta.c b/arch/arm/plat-armada/mv_hal/neta/gbe/mvNeta.c
index 9513748..515519f 100644
--- a/arch/arm/plat-armada/mv_hal/neta/gbe/mvNeta.c
+++ b/arch/arm/plat-armada/mv_hal/neta/gbe/mvNeta.c
@@ -94,49 +94,38 @@ static void mvNetaDescRingReset(MV_NETA_QUEUE_CTRL *pQueueHndl);
 #define TX_FIFO_EMPTY_TIMEOUT_MSEC  10000
 #define PORT_DISABLE_WAIT_TCLOCKS   5000
 
-int mvNetaPortCheck(int port)
+
+int mvNetaMaxCheck(int value, int limit, char *name)
 {
-	if ((port < 0) || (port >= mvNetaHalData.maxPort)) {
-		mvOsPrintf("port %d is out of range\n", port);
-		return 1;
-	}
-	if (!(MV_BIT_CHECK(mvNetaHalData.portMask, port))) {
-		mvOsPrintf("port %d is not in portMask (%x)\n", port,  	mvNetaHalData.portMask);
+	if ((value < 0) || (value >= limit)) {
+		mvOsPrintf("%s %d is out of range [0..%d]\n",
+			name ? name : "value", value, (limit - 1));
 		return 1;
 	}
-
 	return 0;
 }
 
+int mvNetaPortCheck(int port)
+{
+	return mvNetaMaxCheck(port, mvNetaHalData.maxPort, "port");
+}
+
 int mvNetaTxpCheck(int port, int txp)
 {
-	int txpNum;
+	int txpMax = 1;
 
 	if (mvNetaPortCheck(port))
 		return 1;
 
-	txpNum = 1;
-
-#ifdef CONFIG_MV_PON
 	if (MV_PON_PORT(port))
-		txpNum = MV_ETH_MAX_TCONT();
-#endif /* CONFIG_MV_PON */
+		txpMax = MV_ETH_MAX_TCONT();
 
-	if ((txp < 0) || (txp >= txpNum)) {
-		mvOsPrintf("txp %d is out of range\n", txp);
-		return 1;
-	}
-	return 0;
+	return mvNetaMaxCheck(txp, txpMax, "txp");
 }
 
-int mvNetaMaxCheck(int num, int limit)
+int mvNetaCpuCheck(int cpu)
 {
-	if ((num < 0) || (num >= limit)) {
-		mvOsPrintf("%d is out of range %d\n", num, limit);
-		return 1;
-	}
-
-	return 0;
+	return mvNetaMaxCheck(cpu, NETA_MAX_CPU_REGS, "cpu");
 }
 
 /******************************************************************************/
@@ -323,7 +312,7 @@ MV_STATUS mvNetaDefaultsSet(int port)
 
 	/* Set CPU queue access map - all CPUs have access to all RX queues and to all TX queues */
 
-	for (cpu = 0; cpu < mvNetaHalData.maxCPUs; cpu++)
+	for (cpu = 0; cpu < NETA_MAX_CPU_REGS; cpu++)
 		if (MV_BIT_CHECK(mvNetaHalData.cpuMask, cpu))
 			MV_REG_WRITE(NETA_CPU_MAP_REG(port, cpu), (NETA_CPU_RXQ_ACCESS_ALL_MASK | NETA_CPU_TXQ_ACCESS_ALL_MASK));
 
@@ -486,7 +475,10 @@ MV_STATUS	mvNetaRxqCpuMaskSet(int port, int rxq_mask, int cpu)
 {
 	MV_U32	regVal;
 
-	if (!(MV_BIT_CHECK(mvNetaHalData.cpuMask, cpu)))
+	if (mvNetaPortCheck(port))
+		return MV_ERROR;
+
+	if (mvNetaCpuCheck(cpu))
 		return MV_ERROR;
 
 	regVal = MV_REG_READ(NETA_CPU_MAP_REG(port, cpu));
@@ -502,7 +494,10 @@ MV_STATUS	mvNetaTxqCpuMaskSet(int port, int txq_mask, int cpu)
 {
 	MV_U32	regVal;
 
-	if (!(MV_BIT_CHECK(mvNetaHalData.cpuMask, cpu)))
+	if (mvNetaPortCheck(port))
+		return MV_ERROR;
+
+	if (mvNetaCpuCheck(cpu))
 		return MV_ERROR;
 
 	regVal = MV_REG_READ(NETA_CPU_MAP_REG(port, cpu));
@@ -2316,7 +2311,6 @@ void mvNetaTxqAddrSet(int port, int txp, int queue, int descrNum)
 	pTxqCtrl = mvNetaTxqHndlGet(port, txp, queue);
 	pQueueCtrl = &pTxqCtrl->queueCtrl;
 
-
 	/* Set Tx descriptors queue starting address */
 	MV_REG_WRITE(NETA_TXQ_BASE_ADDR_REG(port, txp, queue), netaDescVirtToPhys(pQueueCtrl, (MV_U8 *)pQueueCtrl->pFirst));
 
@@ -2488,6 +2482,36 @@ MV_STATUS mvNetaMhSet(int port, MV_NETA_MH_MODE mh)
 	return MV_OK;
 }
 
+MV_STATUS mvNetaTagSet(int port, MV_TAG_TYPE mh)
+{
+	MV_U32 regVal;
+
+	regVal = MV_REG_READ(ETH_PORT_MARVELL_HEADER_REG(port));
+	/* Clear relevant fields */
+	regVal &= ~(ETH_DSA_EN_MASK | ETH_MH_EN_MASK);
+	switch (mh) {
+	case MV_TAG_TYPE_NONE:
+		break;
+
+	case MV_TAG_TYPE_MH:
+		regVal |= ETH_MH_EN_MASK;
+		break;
+
+	case MV_TAG_TYPE_DSA:
+		regVal |= ETH_DSA_MASK;
+		break;
+
+	case MV_TAG_TYPE_EDSA:
+		regVal |= ETH_DSA_EXT_MASK;
+
+	default:
+		mvOsPrintf("port=%d: Unexpected MH = %d value\n", port, mh);
+		return MV_BAD_PARAM;
+	}
+	MV_REG_WRITE(ETH_PORT_MARVELL_HEADER_REG(port), regVal);
+	return MV_OK;
+}
+
 /* Set one of NETA_TX_MAX_MH_REGS registers */
 MV_STATUS mvNetaTxMhRegSet(int port, int txp, int reg, MV_U16 mh)
 {
@@ -2917,7 +2941,7 @@ MV_STATUS mvNetaTxqFixPrioSet(int port, int txp, int txq)
 	if (mvNetaTxpCheck(port, txp))
 		return MV_BAD_PARAM;
 
-	if (mvNetaMaxCheck(txq, MV_ETH_MAX_TXQ))
+	if (mvNetaMaxCheck(txq, MV_ETH_MAX_TXQ, "txq"))
 		return MV_BAD_PARAM;
 
 	regVal = MV_REG_READ(NETA_TX_FIXED_PRIO_CFG_REG(port, txp));
@@ -2936,7 +2960,7 @@ MV_STATUS mvNetaTxqWrrPrioSet(int port, int txp, int txq, int weight)
 	if (mvNetaTxpCheck(port, txp))
 		return MV_BAD_PARAM;
 
-	if (mvNetaMaxCheck(txq, MV_ETH_MAX_TXQ))
+	if (mvNetaMaxCheck(txq, MV_ETH_MAX_TXQ, "txq"))
 		return MV_BAD_PARAM;
 
 	/* Weight * 256 bytes * 8 bits must be larger then MTU [bits] */
@@ -3090,7 +3114,7 @@ MV_STATUS   mvNetaTxqRateSet(int port, int txp, int txq, int rate)
 	if (mvNetaTxpCheck(port, txp))
 		return MV_BAD_PARAM;
 
-	if (mvNetaMaxCheck(txq, MV_ETH_MAX_TXQ))
+	if (mvNetaMaxCheck(txq, MV_ETH_MAX_TXQ, "txq"))
 		return MV_BAD_PARAM;
 
 	status = mvNetaRateCalc(rate, accuracy, &period, &tokens);
@@ -3130,7 +3154,7 @@ MV_STATUS mvNetaTxqBurstSet(int port, int txp, int txq, int burst)
 	if (mvNetaTxpCheck(port, txp))
 		return MV_BAD_PARAM;
 
-	if (mvNetaMaxCheck(txq, MV_ETH_MAX_TXQ))
+	if (mvNetaMaxCheck(txq, MV_ETH_MAX_TXQ, "txq"))
 		return MV_BAD_PARAM;
 
 	/* Calulate Tocket Bucket Size */
@@ -3325,7 +3349,7 @@ MV_STATUS   mvNetaPonRxMibDefault(int mib)
 		/* Don't count default packets that not match Gem portID */
 		regVal &= ~NETA_PON_MIB_RX_VALID_MASK;
 	} else {
-		if (mvNetaMaxCheck(mib, MV_ETH_MAX_TCONT()))
+		if (mvNetaMaxCheck(mib, MV_ETH_MAX_TCONT(), "tcont"))
 			return MV_BAD_PARAM;
 
 		regVal &= ~NETA_PON_MIB_RX_MIB_NO_MASK;
@@ -3342,7 +3366,7 @@ MV_STATUS   mvNetaPonRxMibGemPid(int mib, MV_U16 gemPid)
 	MV_U32	regVal;
 	int	i, free = -1;
 
-	if ((mib != -1) && mvNetaMaxCheck(mib, MV_ETH_MAX_TCONT()))
+	if ((mib != -1) && mvNetaMaxCheck(mib, MV_ETH_MAX_TCONT(), "tcont"))
 		return MV_BAD_PARAM;
 
 	/* look for gemPid if exist of first free entry */
diff --git a/arch/arm/plat-armada/mv_hal/neta/gbe/mvNeta.h b/arch/arm/plat-armada/mv_hal/neta/gbe/mvNeta.h
index 379460b..58643a7 100644
--- a/arch/arm/plat-armada/mv_hal/neta/gbe/mvNeta.h
+++ b/arch/arm/plat-armada/mv_hal/neta/gbe/mvNeta.h
@@ -71,8 +71,6 @@ extern "C" {
 #include "mvTypes.h"
 #include "mvCommon.h"
 #include "mvOs.h"
-#include "ctrlEnv/mvCtrlEnvSpec.h"
-#include "mvSysEthConfig.h"
 #include "mvNetaRegs.h"
 #include "mvEthRegs.h"
 
@@ -97,12 +95,6 @@ extern "C" {
 
 #define NFP_MAX_PORTS   (MV_ETH_MAX_PORTS + NFP_EXT_NUM)
 
-#ifdef CONFIG_MV_ETH_SWITCH
-# define NFP_MAX_SWITCH_GROUPS  CONFIG_MV_ETH_SWITCH_NETDEV_NUM
-#else
-# define NFP_MAX_SWITCH_GROUPS  1
-#endif /* CONFIG_MV_ETH_SWITCH */
-
 typedef struct {
 	void   *dev;
 	MV_U32 tx_cmd;
@@ -196,9 +188,10 @@ typedef struct {
 #define NETA_RX_L3_IS_IP4_ERR(status)  (((status) & ETH_RX_IP_FRAME_TYPE_MASK) &&	\
 					!((status) & ETH_RX_IP_HEADER_OK_MASK))
 
-#define NETA_RX_L3_SET_IP4_ERR(rxd)													\
-					((rxd)->status |= ETH_RX_IP_FRAME_TYPE_MASK);					\
-					((rxd)->status &= ~ETH_RX_IP_HEADER_OK_MASK);
+#define NETA_RX_L3_SET_IP4_ERR(rxd) do {                \
+	((rxd)->status |= ETH_RX_IP_FRAME_TYPE_MASK);	\
+	((rxd)->status &= ~ETH_RX_IP_HEADER_OK_MASK);   \
+} while (0)
 
 #define NETA_RX_L3_IS_IP6(status)      (MV_FALSE)
 #define NETA_RX_L3_SET_IP6(rxd)        NETA_RX_L3_SET_UN(rxd)
@@ -294,9 +287,8 @@ typedef enum {
 
 typedef struct {
 	MV_U32 maxPort;
-	MV_U32 pClk;
 	MV_U32 tClk;
-	int	maxCPUs;
+	MV_U32 cpuMask;
 	MV_BOOL	iocc;
 	MV_U16 ctrlModel;       /* Controller Model     */
 	MV_U8  ctrlRev;         /* Controller Revision  */
@@ -311,8 +303,10 @@ typedef struct {
 	MV_U8 *pncVirtBase;
 #endif /* CONFIG_MV_ETH_PNC */
 
+	/* Obsolete fields - unused */
+	MV_U32 pClk;
 	MV_U32 portMask;
-	MV_U32 cpuMask;
+	int    maxCPUs;
 } MV_NETA_HAL_DATA;
 
 typedef struct eth_pbuf {
@@ -370,6 +364,8 @@ extern MV_NETA_HAL_DATA mvNetaHalData;
 
 #ifdef CONFIG_MV_PON
 #define MV_ETH_MAX_TCONT() 	CONFIG_MV_PON_TCONTS
+#else
+#define MV_ETH_MAX_TCONT()      1
 #endif /* CONFIG_MV_PON */
 
 /* Get Giga port handler */
@@ -412,10 +408,10 @@ static INLINE void mvNetaRxqDescSwap(NETA_RX_DESC *pRxDesc)
 static INLINE void mvNetaTxqDescSwap(NETA_TX_DESC *pTxDesc)
 {
 	pTxDesc->command = MV_BYTE_SWAP_32BIT(pTxDesc->command);
-    pTxDesc->csumL4 = MV_BYTE_SWAP_16BIT(pTxDesc->csumL4);
-    pTxDesc->dataSize = MV_BYTE_SWAP_16BIT(pTxDesc->dataSize);
-    pTxDesc->bufPhysAddr = MV_BYTE_SWAP_32BIT(pTxDesc->bufPhysAddr);
-    pTxDesc->hw_cmd = MV_BYTE_SWAP_32BIT(pTxDesc->hw_cmd);
+	pTxDesc->csumL4 = MV_BYTE_SWAP_16BIT(pTxDesc->csumL4);
+	pTxDesc->dataSize = MV_BYTE_SWAP_16BIT(pTxDesc->dataSize);
+	pTxDesc->bufPhysAddr = MV_BYTE_SWAP_32BIT(pTxDesc->bufPhysAddr);
+	pTxDesc->hw_cmd = MV_BYTE_SWAP_32BIT(pTxDesc->hw_cmd);
 }
 #else
 static INLINE void mvNetaRxqDescSwap(NETA_RX_DESC *pRxDesc)
@@ -737,6 +733,7 @@ MV_U32 mvNetaTxDonePktsCoalGet(int port, int txp, int txq);
 
 MV_STATUS mvNetaRxqBufSizeSet(int port, int rxq, int bufSize);
 MV_STATUS mvNetaMhSet(int port, MV_NETA_MH_MODE mh);
+MV_STATUS mvNetaTagSet(int port, MV_TAG_TYPE mh);
 MV_STATUS mvNetaTxMhRegSet(int port, int txp, int reg, MV_U16 mh);
 MV_STATUS mvNetaMaxRxSizeSet(int port, int maxRxSize);
 MV_STATUS mvNetaMacAddrSet(int port, unsigned char *pAddr, int queue);
@@ -760,7 +757,7 @@ MV_STATUS mvNetaTxpEjpTxSpeedSet(int port, int txp, int type, int speed);
 
 int mvNetaPortCheck(int port);
 int mvNetaTxpCheck(int port, int txp);
-int mvNetaMaxCheck(int num, int limit);
+int mvNetaMaxCheck(int num, int limit, char *name);
 
 void mvNetaMibCountersClear(int port, int txp);
 MV_U32 mvNetaMibCounterRead(int port, int txp, unsigned int mibOffset, MV_U32 *pHigh32);
diff --git a/arch/arm/plat-armada/mv_hal/neta/gbe/mvNetaDebug.c b/arch/arm/plat-armada/mv_hal/neta/gbe/mvNetaDebug.c
index 9873299..325830a 100644
--- a/arch/arm/plat-armada/mv_hal/neta/gbe/mvNetaDebug.c
+++ b/arch/arm/plat-armada/mv_hal/neta/gbe/mvNetaDebug.c
@@ -228,7 +228,7 @@ void mvNetaRxqRegs(int port, int rxq)
 	if (mvNetaPortCheck(port))
 		return;
 
-	if (mvNetaMaxCheck(rxq, MV_ETH_MAX_RXQ))
+	if (mvNetaMaxCheck(rxq, MV_ETH_MAX_RXQ, "rxq"))
 		return;
 
 	mvOsPrintf("\n[NetA Rx: port=%d, rxq=%d]\n", port, rxq);
@@ -247,7 +247,7 @@ void mvNetaTxqRegs(int port, int txp, int txq)
 	if (mvNetaTxpCheck(port, txp))
 		return;
 
-	if (mvNetaMaxCheck(txq, MV_ETH_MAX_TXQ))
+	if (mvNetaMaxCheck(txq, MV_ETH_MAX_TXQ, "txq"))
 		return;
 
 	mvOsPrintf("\n[NetA Tx: port=%d, txp=%d, txq=%d]\n", port, txp, txq);
@@ -362,7 +362,7 @@ void mvNetaPortRegs(int port)
 		return;
 
 	/* Per CPU register */
-	for (i = 0; i < mvNetaHalData.maxCPUs; i++)
+	for (i = 0; i < NETA_MAX_CPU_REGS; i++)
 		mvEthRegPrint2(NETA_CPU_MAP_REG(port, i), "NETA_CPU_MAP_REG", i);
 
 	/* Per BM pool registers */
@@ -443,7 +443,7 @@ void mvNetaRxqShow(int port, int rxq, int mode)
 	if (mvNetaPortCheck(port))
 		return;
 
-	if (mvNetaMaxCheck(rxq, MV_ETH_MAX_RXQ))
+	if (mvNetaMaxCheck(rxq, MV_ETH_MAX_RXQ, "rxq"))
 		return;
 
 	pPortCtrl = mvNetaPortHndlGet(port);
@@ -499,7 +499,7 @@ void mvNetaTxqShow(int port, int txp, int txq, int mode)
 	if (!pPortCtrl)
 		return;
 
-	if (mvNetaMaxCheck(txq, MV_ETH_MAX_TXQ))
+	if (mvNetaMaxCheck(txq, MV_ETH_MAX_TXQ, "txq"))
 		return;
 
 	mvOsPrintf("\n[NetA TxQ: port=%d, txp=%d, txq=%d]\n", port, txp, txq);
diff --git a/arch/arm/plat-armada/mv_hal/neta/gbe/mvNetaRegs.h b/arch/arm/plat-armada/mv_hal/neta/gbe/mvNetaRegs.h
index 2cdeaac..801dda8 100644
--- a/arch/arm/plat-armada/mv_hal/neta/gbe/mvNetaRegs.h
+++ b/arch/arm/plat-armada/mv_hal/neta/gbe/mvNetaRegs.h
@@ -70,7 +70,9 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 extern "C" {
 #endif /* __cplusplus */
 
+#if !defined(CONFIG_OF)
 #include "mvSysEthConfig.h"
+#endif
 
 #define NETA_REG_BASE(port) 				MV_ETH_REGS_BASE(port)
 
@@ -385,7 +387,10 @@ extern "C" {
 /*-------------------------------------------------------------------------------*/
 
 #define NETA_BM_ADDR_REG(p)                 (NETA_REG_BASE(p) + 0x2504)
+/*-------------------------------------------------------------------------------*/
 
+/* RXQs and TXQs to CPU mapping */
+#define NETA_MAX_CPU_REGS                   4
 #define NETA_CPU_MAP_REG(p, cpu)            (NETA_REG_BASE(p) + 0x2540 + ((cpu) << 2))
 
 #define NETA_CPU_RXQ_ACCESS_OFFS            0
@@ -395,6 +400,7 @@ extern "C" {
 #define NETA_CPU_TXQ_ACCESS_OFFS            8
 #define NETA_CPU_TXQ_ACCESS_ALL_MASK        (0xFF << NETA_CPU_TXQ_ACCESS_OFFS)
 #define NETA_CPU_TXQ_ACCESS_MASK(q)         (1 << (NETA_CPU_TXQ_ACCESS_OFFS + (q)))
+/*-------------------------------------------------------------------------------*/
 
 /* Interrupt coalescing mechanism */
 #define NETA_RXQ_INTR_TIME_COAL_REG(p, q)   (NETA_REG_BASE(p) + 0x2580 + ((q) << 2))
@@ -826,6 +832,7 @@ extern "C" {
 #endif /* MV_ETH_PMT_NEW */
 
 /*********************** New TX WRR EJP Registers ********************************/
+
 #define NETA_TX_CMD_1_REG(p, txp)           (NETA_TX_REG_BASE((p), (txp)) + 0x1a00)
 
 #define NETA_TX_EJP_RESET_BIT               0
@@ -1013,8 +1020,8 @@ typedef struct neta_rx_desc {
 #define NETA_RX_L3_MASK                     (3 << NETA_RX_L3_OFFS)
 #define NETA_RX_L3_UN                       (0 << NETA_RX_L3_OFFS)
 #define NETA_RX_L3_IP6                      (1 << NETA_RX_L3_OFFS)
-#define NETA_RX_L3_IP4           	        (2 << NETA_RX_L3_OFFS)
-#define NETA_RX_L3_IP4_ERR            		(3 << NETA_RX_L3_OFFS)
+#define NETA_RX_L3_IP4                      (2 << NETA_RX_L3_OFFS)
+#define NETA_RX_L3_IP4_ERR                  (3 << NETA_RX_L3_OFFS)
 
 #define NETA_RX_L4_OFFS                     28
 #define NETA_RX_L4_MASK                     (3 << NETA_RX_L4_OFFS)
@@ -1059,8 +1066,8 @@ typedef struct neta_rx_desc {
 #define NETA_RX_L3_MASK                     (3 << NETA_RX_L3_OFFS)
 #define NETA_RX_L3_UN                       (0 << NETA_RX_L3_OFFS)
 #define NETA_RX_L3_IP6                      (2 << NETA_RX_L3_OFFS)
-#define NETA_RX_L3_IP4           	        (3 << NETA_RX_L3_OFFS)
-#define NETA_RX_L3_IP4_ERR            		(1 << NETA_RX_L3_OFFS)
+#define NETA_RX_L3_IP4                      (3 << NETA_RX_L3_OFFS)
+#define NETA_RX_L3_IP4_ERR                  (1 << NETA_RX_L3_OFFS)
 
 #else
 
@@ -1081,12 +1088,12 @@ typedef struct neta_rx_desc {
 
 /* Bit map of "hw_cmd" field */
 #define NETA_RX_COLOR_BIT                   3
-#define NETA_RX_COLOR_MASK				    (1 << NETA_RX_COLOR_BIT)
+#define NETA_RX_COLOR_MASK                  (1 << NETA_RX_COLOR_BIT)
 #define NETA_RX_COLOR_GREEN                 (0 << NETA_RX_COLOR_BIT)
 #define NETA_RX_COLOR_YELLOW                (1 << NETA_RX_COLOR_BIT)
 
-#define NETA_RX_DSA_OFFS           		    4
-#define NETA_RX_DSA_MASK           		    (3 << NETA_RX_DSA_OFFS)
+#define NETA_RX_DSA_OFFS                    4
+#define NETA_RX_DSA_MASK                    (3 << NETA_RX_DSA_OFFS)
 #define NETA_RX_DSA_NONE                    (0 << NETA_RX_DSA_OFFS)
 #define NETA_RX_DSA                         (1 << NETA_RX_DSA_OFFS)
 #define NETA_RX_DSA_E                       (2 << NETA_RX_DSA_OFFS)
diff --git a/arch/arm/plat-armada/mv_hal/neta/pnc/mvPncWol.c b/arch/arm/plat-armada/mv_hal/neta/pnc/mvPncWol.c
index 815533e..ac70679 100644
--- a/arch/arm/plat-armada/mv_hal/neta/pnc/mvPncWol.c
+++ b/arch/arm/plat-armada/mv_hal/neta/pnc/mvPncWol.c
@@ -195,7 +195,7 @@ int mv_pnc_wol_rule_set(int port, char *data, char *mask, int size)
 	if (mvNetaPortCheck(port))
 		return -1;
 
-	if (mvNetaMaxCheck(size, (MV_PNC_TOTAL_DATA_SIZE + 1)))
+	if (mvNetaMaxCheck(size, (MV_PNC_TOTAL_DATA_SIZE + 1), "data_size"))
 		return -1;
 
 	/* Save WoL rule in mv_pnc_wol_tbl */
@@ -418,7 +418,7 @@ int mv_pnc_wol_rule_dump(int idx)
 	int	i;
 	MV_PNC_WOL_RULE *pWolRule;
 
-	if (mvNetaMaxCheck(idx, MV_PNC_MAX_RULES))
+	if (mvNetaMaxCheck(idx, MV_PNC_MAX_RULES, "pnc_rules"))
 		return -1;
 
 	pWolRule = mv_pnc_wol_tbl[idx];
-- 
1.7.5.4

