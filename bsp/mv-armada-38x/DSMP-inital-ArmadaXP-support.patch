From 317067616acb85f11e91cade37596328ddde884e Mon Sep 17 00:00:00 2001
From: Kosta Zertsekel <konszert@marvell.com>
Date: Sun, 6 Jan 2013 08:35:34 +0200
Subject: [PATCH 0003/1825] DSMP inital ArmadaXP support

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 74178542aa860ff1b4a2a7a336796acaadbb13a4

Alligned to official AXP LSP release 1.3.0

Change-Id: I63c82b9f90e758c9f2868e1326b0c703d4c4be26

Signed-off-by: Kosta Zertsekel <konszert@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/Kconfig                  |   24 ++++
 arch/arm/Makefile                 |    2 +
 arch/arm/boot/compressed/head.S   |   20 ++++-
 arch/arm/include/asm/cacheflush.h |    7 ++
 arch/arm/include/asm/glue-proc.h  |   19 ++++
 arch/arm/include/asm/hardirq.h    |    1 +
 arch/arm/include/asm/mach/pci.h   |    1 +
 arch/arm/include/asm/setup.h      |   34 +++++-
 arch/arm/include/asm/smp.h        |    3 +
 arch/arm/include/asm/tlbflush.h   |    9 ++-
 arch/arm/include/asm/vfp.h        |    5 +
 arch/arm/kernel/head-common.S     |    7 ++
 arch/arm/kernel/irq.c             |    3 +
 arch/arm/kernel/module.c          |   57 +++++++----
 arch/arm/kernel/perf_event.c      |   39 +++++++-
 arch/arm/kernel/setup.c           |   24 ++--
 arch/arm/kernel/smp.c             |   32 ++++++
 arch/arm/lib/copy_template.S      |   91 +++++++++++++++-
 arch/arm/mm/Kconfig               |   35 ++++++-
 arch/arm/mm/Makefile              |   10 ++-
 arch/arm/mm/abort-ev6.S           |    1 +
 arch/arm/mm/alignment.c           |    2 +
 arch/arm/mm/cache-v6.S            |   79 ++++++++++++++
 arch/arm/mm/cache-v7.S            |    6 +
 arch/arm/mm/copypage-v6.c         |    9 ++
 arch/arm/mm/mmu.c                 |    7 +-
 arch/arm/mm/proc-macros.S         |   22 ++++
 arch/arm/oprofile/common.c        |    2 +
 arch/arm/vfp/vfpmodule.c          |    4 +
 drivers/ata/libata-pmp.c          |   12 ++
 drivers/ata/sata_mv.c             |    1 +
 drivers/dma/Kconfig               |    2 +-
 drivers/dma/mv_xor.c              |  214 +++++++++++++++++--------------------
 drivers/dma/mv_xor.h              |    6 +-
 drivers/hwmon/Kconfig             |    7 ++
 drivers/i2c/busses/Kconfig        |    2 +-
 drivers/i2c/busses/i2c-mv64xxx.c  |    2 +-
 drivers/mmc/host/Kconfig          |    2 +-
 drivers/mtd/nand/Makefile         |    2 +
 drivers/mtd/nand/nand_base.c      |   40 +++++++-
 drivers/mtd/nand/nand_bbt.c       |   36 ++++++
 drivers/mtd/nand/nand_ids.c       |   11 ++
 drivers/net/Makefile              |    2 +
 drivers/rtc/Kconfig               |    2 +-
 drivers/usb/host/ehci-hcd.c       |   10 ++
 drivers/video/Makefile            |    1 +
 drivers/video/backlight/Kconfig   |    8 ++
 drivers/video/backlight/Makefile  |    1 +
 drivers/video/fb_ddc.c            |    9 ++
 fs/read_write.c                   |  172 +++++++++++++++++++++++++++++-
 fs/read_write.h                   |   40 +++++++
 fs/splice.c                       |   80 +++++++++++---
 include/linux/miscdevice.h        |    6 +-
 include/linux/mtd/bbm.h           |    4 +
 include/linux/skbuff.h            |    6 +-
 include/mtd/mtd-abi.h             |    4 +
 kernel/stop_machine.c             |    6 +
 kernel/time/tick-sched.c          |    1 +
 net/core/skbuff.c                 |   27 ++++-
 59 files changed, 1069 insertions(+), 202 deletions(-)

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 83af975..d3358156 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -615,6 +615,21 @@ config ARCH_LPC32XX
 	select GENERIC_CLOCKEVENTS
 	help
 	  Support for the NXP LPC32XX family of processors
+	  
+config ARCH_ARMADA_XP
+	bool "Marvell Armada XP"
+	select PCI
+	select ARCH_SUPPORTS_MSI
+	select ARCH_REQUIRE_GPIOLIB
+	select GENERIC_GPIO
+	select GENERIC_TIME
+	select GENERIC_CLOCKEVENTS
+	select PLAT_ARMADA
+#	select PLAT_ORION
+	select HAVE_REGS_AND_STACK_ACCESS_API
+	select COMMON_CLKDEV
+	select CLKSRC_MMIO
+	select CLKDEV_LOOKUP
 
 config ARCH_MV78XX0
 	bool "Marvell MV78xx0"
@@ -1106,6 +1121,9 @@ source "arch/arm/mach-realview/Kconfig"
 
 source "arch/arm/mach-sa1100/Kconfig"
 
+source "arch/arm/mach-armadaxp/Kconfig"
+source "arch/arm/plat-armada/Kconfig"
+
 source "arch/arm/plat-samsung/Kconfig"
 source "arch/arm/plat-s3c24xx/Kconfig"
 source "arch/arm/plat-s5p/Kconfig"
@@ -1149,6 +1167,12 @@ source "arch/arm/mach-vt8500/Kconfig"
 source "arch/arm/mach-w90x900/Kconfig"
 
 # Definitions to make life easier
+config PLAT_ARMADA
+	bool
+	select CLKSRC_MMIO
+        select GENERIC_IRQ_CHIP
+        select HAVE_SCHED_CLOCK
+
 config ARCH_ACORN
 	bool
 
diff --git a/arch/arm/Makefile b/arch/arm/Makefile
index 3ca2f60..d36be1e 100644
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -200,9 +200,11 @@ machine-$(CONFIG_MACH_SPEAR310)		:= spear3xx
 machine-$(CONFIG_MACH_SPEAR320)		:= spear3xx
 machine-$(CONFIG_MACH_SPEAR600)		:= spear6xx
 machine-$(CONFIG_ARCH_ZYNQ)		:= zynq
+machine-$(CONFIG_ARCH_ARMADA_XP)	:= armadaxp
 
 # Platform directory name.  This list is sorted alphanumerically
 # by CONFIG_* macro name.
+plat-$(CONFIG_PLAT_ARMADA)	:= armada
 plat-$(CONFIG_ARCH_MXC)		:= mxc
 plat-$(CONFIG_ARCH_OMAP)	:= omap
 plat-$(CONFIG_ARCH_S3C64XX)	:= samsung
diff --git a/arch/arm/boot/compressed/head.S b/arch/arm/boot/compressed/head.S
index 75a0406..4411104 100644
--- a/arch/arm/boot/compressed/head.S
+++ b/arch/arm/boot/compressed/head.S
@@ -123,6 +123,9 @@ start:
 		.type	start,#function
 		.rept	7
 		mov	r0, r0
+#ifdef CONFIG_BE8_ON_LE
+		setend	be
+#endif
 		.endr
    ARM(		mov	r0, r0		)
    ARM(		b	1f		)
@@ -707,6 +710,11 @@ __arm6_mmu_cache_on:
 
 __common_mmu_cache_on:
 #ifndef CONFIG_THUMB2_KERNEL
+#ifdef CONFIG_SHEEVA_ERRATA_ARM_CPU_4948
+		mrc 	p15, 1, r1, c15, c1, 0
+		orr     r1, r1, #1			@ Disable L0 cache.
+		mcr 	p15, 1, r1, c15, c1, 0
+#endif
 #ifndef DEBUG
 		orr	r0, r0, #0x000d		@ Write buffer, mmu
 #endif
@@ -895,9 +903,19 @@ proc_types:
 		W(b)	__armv4_mmu_cache_on
 		W(b)	__armv4_mmu_cache_off
 		W(b)	__armv5tej_mmu_cache_flush
-
+#ifdef CONFIG_CPU_SHEEVA_PJ4B_V6
+		.word	0x000f0000		@ Marvell PJ4B ARMv6
+		.word	0x000f0000
+#else
 		.word	0x0007b000		@ ARMv6
 		.word	0x000ff000
+#endif
+		W(b)	__armv4_mmu_cache_on
+		W(b)	__armv4_mmu_cache_off
+		W(b)	__armv6_mmu_cache_flush
+
+		.word	0x560f5810		@ Marvell PJ4 ARMv6
+		.word	0xff0ffff0
 		W(b)	__armv4_mmu_cache_on
 		W(b)	__armv4_mmu_cache_off
 		W(b)	__armv6_mmu_cache_flush
diff --git a/arch/arm/include/asm/cacheflush.h b/arch/arm/include/asm/cacheflush.h
index 420b7d2..0a35154 100644
--- a/arch/arm/include/asm/cacheflush.h
+++ b/arch/arm/include/asm/cacheflush.h
@@ -267,7 +267,14 @@ extern void flush_cache_page(struct vm_area_struct *vma, unsigned long user_addr
  * Perform necessary cache operations to ensure that the TLB will
  * see data written in the specified area.
  */
+#if defined (CONFIG_CACHE_AURORA_L2) && defined (CONFIG_AURORA_L2_OUTER) && !defined (CONFIG_AURORA_L2_PT_WALK)
+/*#warning "clean_dcache_area: Using D$ FLUSH instead of CLEAN. To be Checked\n"*/
+extern void aurora_l2_flush_range(unsigned long start, unsigned long end);
+#define clean_dcache_area(start,size)	do {cpu_dcache_clean_area(start, size);	\
+	aurora_l2_flush_range(__pa(start), __pa(start) + size);} while (0)			
+#else
 #define clean_dcache_area(start,size)	cpu_dcache_clean_area(start, size)
+#endif
 
 /*
  * flush_dcache_page is used when the kernel has written to the page
diff --git a/arch/arm/include/asm/glue-proc.h b/arch/arm/include/asm/glue-proc.h
index e2be7f1..124535a 100644
--- a/arch/arm/include/asm/glue-proc.h
+++ b/arch/arm/include/asm/glue-proc.h
@@ -248,6 +248,25 @@
 # endif
 #endif
 
+#ifdef CONFIG_CPU_SHEEVA_PJ4B_V6
+# ifdef CPU_NAME
+#  undef  MULTI_CPU
+#  define MULTI_CPU
+# else
+#  define CPU_NAME cpu_sheeva_pj4b_v6
+# endif
+#endif
+
+#ifdef CONFIG_CPU_SHEEVA_PJ4B_V7
+# ifdef CPU_NAME
+#  undef  MULTI_CPU
+#  define MULTI_CPU
+# else
+#  define CPU_NAME cpu_sheeva_pj4b_v7
+# endif
+#endif
+
+
 #ifndef MULTI_CPU
 #define cpu_proc_init			__glue(CPU_NAME,_proc_init)
 #define cpu_proc_fin			__glue(CPU_NAME,_proc_fin)
diff --git a/arch/arm/include/asm/hardirq.h b/arch/arm/include/asm/hardirq.h
index 436e60b..fd6d49f 100644
--- a/arch/arm/include/asm/hardirq.h
+++ b/arch/arm/include/asm/hardirq.h
@@ -9,6 +9,7 @@
 
 typedef struct {
 	unsigned int __softirq_pending;
+	unsigned int local_pmu_irqs;
 #ifdef CONFIG_SMP
 	unsigned int ipi_irqs[NR_IPI];
 #endif
diff --git a/arch/arm/include/asm/mach/pci.h b/arch/arm/include/asm/mach/pci.h
index d943b7d..7a4e27b 100644
--- a/arch/arm/include/asm/mach/pci.h
+++ b/arch/arm/include/asm/mach/pci.h
@@ -46,6 +46,7 @@ struct pci_sys_data {
 					/* IRQ mapping				*/
 	int		(*map_irq)(const struct pci_dev *, u8, u8);
 	struct hw_pci	*hw;
+	int		mv_controller_num;
 	void		*private_data;	/* platform controller private data	*/
 };
 
diff --git a/arch/arm/include/asm/setup.h b/arch/arm/include/asm/setup.h
index 23ebc0c..d2273bf 100644
--- a/arch/arm/include/asm/setup.h
+++ b/arch/arm/include/asm/setup.h
@@ -143,6 +143,21 @@ struct tag_memclk {
 	__u32 fmemclk;
 };
 
+/* Marvell uboot parameters */
+#define ATAG_MV_UBOOT   0x41000403
+#define MV_ARRAY_SIZE	4
+struct tag_mv_uboot {
+        __u32 uboot_version;
+        __u32 tclk;
+        __u32 sysclk;
+        __u32 isUsbHost;
+        __u8  macAddr[MV_ARRAY_SIZE][6];
+	__u16 mtu[MV_ARRAY_SIZE];
+	__u32 nand_ecc;
+	__u32 rgmii0Src;
+	__u32 feGeSrc;
+};                     
+
 struct tag {
 	struct tag_header hdr;
 	union {
@@ -165,6 +180,11 @@ struct tag {
 		 * DC21285 specific
 		 */
 		struct tag_memclk	memclk;
+
+		/*
+		 * Marvell specific
+		 */
+		struct tag_mv_uboot     mv_uboot;
 	} u;
 };
 
@@ -173,16 +193,20 @@ struct tagtable {
 	int (*parse)(const struct tag *);
 };
 
+#ifdef CONFIG_BE8_ON_LE
+#define read_tag(a)	le32_to_cpu(a)
+#else
+#define read_tag(a)	a
+#endif
+
 #define tag_member_present(tag,member)				\
 	((unsigned long)(&((struct tag *)0L)->member + 1)	\
-		<= (tag)->hdr.size * 4)
-
-#define tag_next(t)	((struct tag *)((__u32 *)(t) + (t)->hdr.size))
+		<= read_tag((tag)->hdr.size) * 4)
+#define tag_next(t)     ((struct tag *)((__u32 *)(t) + read_tag((t)->hdr.size)))
 #define tag_size(type)	((sizeof(struct tag_header) + sizeof(struct type)) >> 2)
 
 #define for_each_tag(t,base)		\
-	for (t = base; t->hdr.size; t = tag_next(t))
-
+	for (t = base; read_tag((t)->hdr.size); t = tag_next(t))
 #ifdef __KERNEL__
 
 #define __tag __used __attribute__((__section__(".taglist.init")))
diff --git a/arch/arm/include/asm/smp.h b/arch/arm/include/asm/smp.h
index f79a9f5..2ab291c 100644
--- a/arch/arm/include/asm/smp.h
+++ b/arch/arm/include/asm/smp.h
@@ -125,5 +125,8 @@ struct smp_operations {
  * set platform specific SMP operations
  */
 extern void smp_set_ops(struct smp_operations *);
+#if defined(CONFIG_ARCH_ARMADA_XP) && defined(CONFIG_PERF_EVENTS)
+extern void show_local_pmu_irqs(struct seq_file *, int);
+#endif
 
 #endif /* ifndef __ASM_ARM_SMP_H */
diff --git a/arch/arm/include/asm/tlbflush.h b/arch/arm/include/asm/tlbflush.h
index 85fe61e..f2a2906 100644
--- a/arch/arm/include/asm/tlbflush.h
+++ b/arch/arm/include/asm/tlbflush.h
@@ -168,8 +168,13 @@
 			 TLB_V6_I_ASID | TLB_V6_D_ASID)
 
 #ifdef CONFIG_CPU_TLB_V6
+#if defined (CONFIG_ARCH_ARMADA_XP) && !defined (CONFIG_AURORA_L2_PT_WALK)
+# define v6wbi_possible_flags	(v6wbi_tlb_flags | TLB_L2CLEAN_FR)
+# define v6wbi_always_flags	(v6wbi_tlb_flags | TLB_L2CLEAN_FR)
+#else
 # define v6wbi_possible_flags	v6wbi_tlb_flags
 # define v6wbi_always_flags	v6wbi_tlb_flags
+#endif
 # ifdef _TLB
 #  define MULTI_TLB 1
 # else
@@ -214,7 +219,9 @@
 #ifndef __ASSEMBLY__
 
 #include <linux/sched.h>
-
+#ifdef CONFIG_CACHE_AURORA_L2
+extern void l2_clean_pa(unsigned int pa); 
+#endif
 struct cpu_tlb_fns {
 	void (*flush_user_range)(unsigned long, unsigned long, struct vm_area_struct *);
 	void (*flush_kern_range)(unsigned long, unsigned long);
diff --git a/arch/arm/include/asm/vfp.h b/arch/arm/include/asm/vfp.h
index f4ab34f..2a85fd3 100644
--- a/arch/arm/include/asm/vfp.h
+++ b/arch/arm/include/asm/vfp.h
@@ -82,3 +82,8 @@
 #define VFPOPDESC_UNUSED_BIT	(24)
 #define VFPOPDESC_UNUSED_MASK	(0xFF << VFPOPDESC_UNUSED_BIT)
 #define VFPOPDESC_OPDESC_MASK	(~(VFPOPDESC_LENGTH_MASK | VFPOPDESC_UNUSED_MASK))
+
+#ifndef __ASSEMBLY__
+extern void vfp_save(void);
+extern void vfp_restore(void);
+#endif /* __ASSEMBLY__ */
\ No newline at end of file
diff --git a/arch/arm/kernel/head-common.S b/arch/arm/kernel/head-common.S
index 854bd22..5c6c7bd 100644
--- a/arch/arm/kernel/head-common.S
+++ b/arch/arm/kernel/head-common.S
@@ -48,6 +48,10 @@ __vet_atags:
 	bne	1f
 
 	ldr	r5, [r2, #0]
+
+#ifdef CONFIG_BE8_ON_LE
+	rev	r5, r5
+#endif
 #ifdef CONFIG_OF_FLATTREE
 	ldr	r6, =OF_DT_MAGIC		@ is it a DTB?
 	cmp	r5, r6
@@ -57,6 +61,9 @@ __vet_atags:
 	cmpne	r5, #ATAG_CORE_SIZE_EMPTY
 	bne	1f
 	ldr	r5, [r2, #4]
+#ifdef CONFIG_BE8_ON_LE
+	rev	r5, r5
+#endif
 	ldr	r6, =ATAG_CORE
 	cmp	r5, r6
 	bne	1f
diff --git a/arch/arm/kernel/irq.c b/arch/arm/kernel/irq.c
index 4c78998..40ff42b 100644
--- a/arch/arm/kernel/irq.c
+++ b/arch/arm/kernel/irq.c
@@ -50,6 +50,9 @@ int arch_show_interrupts(struct seq_file *p, int prec)
 #ifdef CONFIG_SMP
 	show_ipi_list(p, prec);
 #endif
+#if defined(CONFIG_ARCH_ARMADA_XP) && defined(CONFIG_PERF_EVENTS)
+        show_local_pmu_irqs(p, prec);
+#endif
 	seq_printf(p, "%*s: %10lu\n", prec, "Err", irq_err_count);
 	return 0;
 }
diff --git a/arch/arm/kernel/module.c b/arch/arm/kernel/module.c
index 452662a..3f37f3a 100644
--- a/arch/arm/kernel/module.c
+++ b/arch/arm/kernel/module.c
@@ -45,6 +45,18 @@ void *module_alloc(unsigned long size)
 }
 #endif
 
+#ifdef CONFIG_CPU_ENDIAN_BE8
+#define read_instr32(c)                        __swab32(*(u32 *)c)
+#define read_instr16(c)                        __swab16(*(u16 *)c)
+#define write_instr32(v,a)             (*(u32 *)(a) = __swab32((__force __u32)(v)))
+#define write_instr16(v,a)             (*(u16 *)(a) = __swab16((__force __u16)(v)))
+#else
+#define read_instr32(c)                        (*(u32 *)c)
+#define read_instr16(c)                        (*(u16 *)c)
+#define write_instr32(v,a)             (*(u32 *)(a) = (v))
+#define write_instr16(v,a)             (*(u16 *)(a) = (v))
+#endif
+
 int
 apply_relocate(Elf32_Shdr *sechdrs, const char *strtab, unsigned int symindex,
 	       unsigned int relindex, struct module *module)
@@ -95,7 +107,7 @@ apply_relocate(Elf32_Shdr *sechdrs, const char *strtab, unsigned int symindex,
 		case R_ARM_PC24:
 		case R_ARM_CALL:
 		case R_ARM_JUMP24:
-			offset = (*(u32 *)loc & 0x00ffffff) << 2;
+			offset = (read_instr32(loc) & 0x00ffffff) << 2;
 			if (offset & 0x02000000)
 				offset -= 0x04000000;
 
@@ -112,8 +124,8 @@ apply_relocate(Elf32_Shdr *sechdrs, const char *strtab, unsigned int symindex,
 
 			offset >>= 2;
 
-			*(u32 *)loc &= 0xff000000;
-			*(u32 *)loc |= offset & 0x00ffffff;
+			write_instr32((read_instr32(loc) & 0xff000000) |
+				(offset & 0x00ffffff), loc);
 			break;
 
 	       case R_ARM_V4BX:
@@ -121,6 +133,9 @@ apply_relocate(Elf32_Shdr *sechdrs, const char *strtab, unsigned int symindex,
 			* other bits to re-code instruction as
 			* MOV PC,Rm.
 			*/
+			
+			write_instr32((read_instr32(loc) & 0xf000000f) |
+						0x01a0f000, loc);
 		       *(u32 *)loc &= 0xf000000f;
 		       *(u32 *)loc |= 0x01a0f000;
 		       break;
@@ -132,7 +147,8 @@ apply_relocate(Elf32_Shdr *sechdrs, const char *strtab, unsigned int symindex,
 
 		case R_ARM_MOVW_ABS_NC:
 		case R_ARM_MOVT_ABS:
-			offset = *(u32 *)loc;
+			offset = read_instr32(loc);
+			
 			offset = ((offset & 0xf0000) >> 4) | (offset & 0xfff);
 			offset = (offset ^ 0x8000) - 0x8000;
 
@@ -140,16 +156,16 @@ apply_relocate(Elf32_Shdr *sechdrs, const char *strtab, unsigned int symindex,
 			if (ELF32_R_TYPE(rel->r_info) == R_ARM_MOVT_ABS)
 				offset >>= 16;
 
-			*(u32 *)loc &= 0xfff0f000;
-			*(u32 *)loc |= ((offset & 0xf000) << 4) |
-					(offset & 0x0fff);
+			write_instr32((read_instr32(loc) & 0xfff0f000) |
+				((offset & 0xf000) << 4) |
+					(offset & 0x0fff), loc);
 			break;
 
 #ifdef CONFIG_THUMB2_KERNEL
 		case R_ARM_THM_CALL:
 		case R_ARM_THM_JUMP24:
 			upper = *(u16 *)loc;
-			lower = *(u16 *)(loc + 2);
+			lower = read_instr16(loc + 2);
 
 			/*
 			 * 25 bit signed address range (Thumb-2 BL and B.W
@@ -198,17 +214,18 @@ apply_relocate(Elf32_Shdr *sechdrs, const char *strtab, unsigned int symindex,
 			sign = (offset >> 24) & 1;
 			j1 = sign ^ (~(offset >> 23) & 1);
 			j2 = sign ^ (~(offset >> 22) & 1);
-			*(u16 *)loc = (u16)((upper & 0xf800) | (sign << 10) |
-					    ((offset >> 12) & 0x03ff));
-			*(u16 *)(loc + 2) = (u16)((lower & 0xd000) |
-						  (j1 << 13) | (j2 << 11) |
-						  ((offset >> 1) & 0x07ff));
+			write_instr16((u16)((upper & 0xf800) | (sign << 10) |
+						((offset >> 12) & 0x03ff)),loc);
+			write_instr16((u16)((lower & 0xd000) |
+						(j1 << 13) | (j2 << 11) |
+						((offset >> 1) & 0x07ff)),loc + 2);
 			break;
 
 		case R_ARM_THM_MOVW_ABS_NC:
 		case R_ARM_THM_MOVT_ABS:
-			upper = *(u16 *)loc;
-			lower = *(u16 *)(loc + 2);
+			upper = read_instr16(loc);
+
+			lower = read_instr16(loc + 2);
 
 			/*
 			 * MOVT/MOVW instructions encoding in Thumb-2:
@@ -229,12 +246,14 @@ apply_relocate(Elf32_Shdr *sechdrs, const char *strtab, unsigned int symindex,
 			if (ELF32_R_TYPE(rel->r_info) == R_ARM_THM_MOVT_ABS)
 				offset >>= 16;
 
-			*(u16 *)loc = (u16)((upper & 0xfbf0) |
+				write_instr16((u16)((upper & 0xfbf0) |
 					    ((offset & 0xf000) >> 12) |
-					    ((offset & 0x0800) >> 1));
-			*(u16 *)(loc + 2) = (u16)((lower & 0x8f00) |
+					    ((offset & 0x0800) >> 1)),
+					doc);
+			write_instr16((u16)((lower & 0x8f00) |
 						  ((offset & 0x0700) << 4) |
-						  (offset & 0x00ff));
+						  (offset & 0x00ff)),
+					doc + 2);
 			break;
 #endif
 
diff --git a/arch/arm/kernel/perf_event.c b/arch/arm/kernel/perf_event.c
index ac73066..65b5e6b 100644
--- a/arch/arm/kernel/perf_event.c
+++ b/arch/arm/kernel/perf_event.c
@@ -27,6 +27,11 @@
 #include <asm/pmu.h>
 #include <asm/stacktrace.h>
 
+#ifdef CONFIG_ARCH_ARMADA_XP
+int pmu_request_irq(int irq, irq_handler_t handler);
+void pmu_free_irq(int irq);
+#endif
+
 /*
  * ARMv6 supports a maximum of 3 events, starting from index 0. If we add
  * another platform that supports more, we need to increase this to be the
@@ -443,9 +448,13 @@ armpmu_reserve_hardware(struct arm_pmu *armpmu)
 			continue;
 		}
 
+#ifdef CONFIG_ARCH_ARMADA_XP
+               err = pmu_request_irq(irq, armpmu->handle_irq);
+#else
 		err = request_irq(irq, handle_irq,
 				  IRQF_DISABLED | IRQF_NOBALANCING,
 				  "arm-pmu", armpmu);
+#endif
 		if (err) {
 			pr_err("unable to request IRQ%d for ARM PMU counters\n",
 				irq);
@@ -622,7 +631,7 @@ int __init armpmu_register(struct arm_pmu *armpmu, char *name, int type)
 #include "perf_event_xscale.c"
 #include "perf_event_v6.c"
 #include "perf_event_v7.c"
-
+#include "perf_event_pj4b.c"
 /*
  * Ensure the PMU has sane values out of reset.
  * This requires SMP to be available, so exists as a separate initcall.
@@ -735,7 +744,17 @@ init_hw_perf_events(void)
 			cpu_pmu = armv6pmu_init();
 			break;
 		case 0xB020:	/* ARM11mpcore */
+#ifdef CONFIG_ARCH_ARMADA_XP
+                       /*armpmu = &mrvl_pj4b_pmu;
+                       memcpy(armpmu_perf_cache_map, mrvl_pj4b_perf_cache_map,
+                                       sizeof(mrvl_pj4b_perf_cache_map));
+                       mrvl_pj4b_read_reset_pmnc();
+                       perf_max_events = mrvl_pj4b_pmu.num_events;*/
+                       printk(KERN_INFO "Armada-XP Performance Monitor Unit detected (ARM MPcore ID)!!!\n");
+                       armpmu=mrvl_pj4b_pmu_init();
+#else
 			cpu_pmu = armv6mpcore_pmu_init();
+#endif
 			break;
 		case 0xC080:	/* Cortex-A8 */
 			cpu_pmu = armv7_a8_pmu_init();
@@ -764,7 +783,25 @@ init_hw_perf_events(void)
 			cpu_pmu = xscale2pmu_init();
 			break;
 		}
+#ifdef CONFIG_ARCH_ARMADA_XP
+	/* Marvell Armada XP CPUs */
+	} else if (0x56 == implementor) {
+		part_number = (cpuid >> 4) & 0xFFF;
+		switch (part_number) {
+		case 0x581:
+		case 0x584:
+			printk(KERN_INFO "Armada-XP Performance Monitor Unit detected (Marvell ID)!!!\n");
+			armpmu=mrvl_pj4b_pmu_init();
+			/*armpmu = &mrvl_pj4b_pmu;
+			memcpy(armpmu_perf_cache_map, mrvl_pj4b_perf_cache_map,
+					sizeof(mrvl_pj4b_perf_cache_map));
+			perf_max_events	= mrvl_pj4b_pmu.num_events;*/
+			break;
+		}
+	}
+#else
 	}
+#endif
 
 	if (cpu_pmu) {
 		pr_info("enabled with %s PMU driver, %d counters available\n",
diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index c6fc3e9..97f7845 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -655,10 +655,10 @@ static void __init request_standard_resources(struct machine_desc *mdesc)
  */
 static int __init parse_tag_core(const struct tag *tag)
 {
-	if (tag->hdr.size > 2) {
-		if ((tag->u.core.flags & 1) == 0)
-			root_mountflags &= ~MS_RDONLY;
-		ROOT_DEV = old_decode_dev(tag->u.core.rootdev);
+	if (read_tag(tag->hdr.size) > 2) {
+	if ((read_tag(tag->u.core.flags) & 1) == 0)		
+		root_mountflags &= ~MS_RDONLY;
+		ROOT_DEV = old_decode_dev(read_tag(tag->u.core.rootdev));
 	}
 	return 0;
 }
@@ -667,7 +667,7 @@ __tagtable(ATAG_CORE, parse_tag_core);
 
 static int __init parse_tag_mem32(const struct tag *tag)
 {
-	return arm_add_memory(tag->u.mem.start, tag->u.mem.size);
+	return arm_add_memory(read_tag(tag->u.mem.start), read_tag(tag->u.mem.size));
 }
 
 __tagtable(ATAG_MEM, parse_tag_mem32);
@@ -720,7 +720,7 @@ __tagtable(ATAG_SERIAL, parse_tag_serialnr);
 
 static int __init parse_tag_revision(const struct tag *tag)
 {
-	system_rev = tag->u.revision.rev;
+	system_rev = read_tag(tag->u.revision.rev);
 	return 0;
 }
 
@@ -754,7 +754,7 @@ static int __init parse_tag(const struct tag *tag)
 	struct tagtable *t;
 
 	for (t = &__tagtable_begin; t < &__tagtable_end; t++)
-		if (tag->hdr.tag == t->tag) {
+		if ((read_tag(tag->hdr.tag) == t->tag)) {
 			t->parse(tag);
 			break;
 		}
@@ -768,9 +768,9 @@ static int __init parse_tag(const struct tag *tag)
  */
 static void __init parse_tags(const struct tag *t)
 {
-	for (; t->hdr.size; t = tag_next(t))
+	for (; read_tag(t->hdr.size); t = tag_next(t))
 		if (!parse_tag(t))
-			printk(KERN_WARNING
+			early_printk(KERN_WARNING
 				"Ignoring unrecognised tag 0x%08x\n",
 				t->hdr.tag);
 }
@@ -899,11 +899,11 @@ static struct machine_desc * __init setup_machine_tags(unsigned int nr)
 	 * If we have the old style parameters, convert them to
 	 * a tag list.
 	 */
-	if (tags->hdr.tag != ATAG_CORE)
+if (read_tag(tags->hdr.tag) != ATAG_CORE)
 		convert_to_tag_list(tags);
 #endif
 
-	if (tags->hdr.tag != ATAG_CORE) {
+	if (read_tag(tags->hdr.tag) != ATAG_CORE) {
 #if defined(CONFIG_OF)
 		/*
 		 * If CONFIG_OF is set, then assume this is a reasonably
@@ -917,7 +917,7 @@ static struct machine_desc * __init setup_machine_tags(unsigned int nr)
 	if (mdesc->fixup)
 		mdesc->fixup(tags, &from, &meminfo);
 
-	if (tags->hdr.tag == ATAG_CORE) {
+	if (read_tag(tags->hdr.tag) == ATAG_CORE) {
 		if (meminfo.nr_banks != 0)
 			squash_mem_tags(tags);
 		save_atags(tags);
diff --git a/arch/arm/kernel/smp.c b/arch/arm/kernel/smp.c
index 73a4f66..66e638f 100644
--- a/arch/arm/kernel/smp.c
+++ b/arch/arm/kernel/smp.c
@@ -489,6 +489,20 @@ u64 smp_irq_stat_cpu(unsigned int cpu)
  */
 static DEFINE_PER_CPU(struct clock_event_device, percpu_clockevent);
 
+#if defined(CONFIG_ARCH_ARMADA_XP) && defined(CONFIG_PERF_EVENTS)
+void show_local_pmu_irqs(struct seq_file *p)
+{
+	 unsigned int cpu;
+
+	 seq_printf(p, "PMU: ");
+	 
+	 for_each_present_cpu(cpu)
+		seq_printf(p, "%10u ", irq_stat[cpu].local_pmu_irqs);
+	 
+	 seq_putc(p, '\n');
+}
+#endif
+
 static void ipi_timer(void)
 {
 	struct clock_event_device *evt = &__get_cpu_var(percpu_clockevent);
@@ -690,6 +704,24 @@ void smp_send_stop(void)
 /*
  * not supported here
  */
+static inline void ipi_flush_cache_user_range(void *arg)
+{
+	struct tlb_args *ta = (struct tlb_args *)arg;
+
+	local_flush_cache_user_range(ta->ta_vma, ta->ta_start, ta->ta_end);
+}
+void flush_cache_user_range(struct vm_area_struct *vma,
+			    unsigned long start, unsigned long end)
+{
+	if (tlb_ops_need_broadcast()) {
+		struct tlb_args ta;
+		ta.ta_vma = vma;
+		ta.ta_start = start;
+		ta.ta_end = end;
+		on_each_cpu_mask(ipi_flush_cache_user_range, &ta, 1, mm_cpumask(vma->vm_mm));
+	} else
+		local_flush_cache_user_range(vma, start, end);
+}
 int setup_profiling_timer(unsigned int multiplier)
 {
 	return -EINVAL;
diff --git a/arch/arm/lib/copy_template.S b/arch/arm/lib/copy_template.S
index 805e3f8..b576ac3 100644
--- a/arch/arm/lib/copy_template.S
+++ b/arch/arm/lib/copy_template.S
@@ -65,6 +65,23 @@
  *	the ldr1w or str1w instructions (some of these macros may expand to
  *	than one 32bit instruction in Thumb-2)
  */
+        .macro  preload, reg, lines
+	        mov     r3, \reg
+	        mov     r4, #\lines
+222:
+	        pld     [r3, #28]
+	        subs    r4, r4, #1
+	        add     r3, r3, #32
+	        bne 222b
+	        .endm
+
+        .macro  loadstore, lines
+	        mov     r9, #\lines
+444:		ldr8w	r1, r3, r4, r5, r6, r7, r8, ip, lr, abort=20f
+		subs	r9, r9, #1
+		str8w	r0, r3, r4, r5, r6, r7, r8, ip, lr, abort=20f
+		bgt	444b
+	        .endm
 
 
 		enter	r4, lr
@@ -78,7 +95,7 @@
 		bne	10f
 
 1:		subs	r2, r2, #(28)
-		stmfd	sp!, {r5 - r8}
+		stmfd	sp!, {r5 - r9}
 		blt	5f
 
 	CALGN(	ands	ip, r0, #31		)
@@ -88,7 +105,73 @@
 	CALGN(	adr	r4, 6f			)
 	CALGN(	subs	r2, r2, r3		)  @ C gets set
 	CALGN(	add	pc, r4, ip		)
-
+#ifdef CONFIG_AURORA_IO_CACHE_COHERENCY 
+/* DSMP - Z1 optimized for Write Allocate + L2 Write Through */
+copy8:
+		movs	r9, r2, lsr #8
+		beq	copy4
+		preload	r1, 8
+		preload r0, 8
+		loadstore 8 
+		sub	r2, #32*8
+		b	copy8
+copy4:	
+		movs	r9, r2, lsr #7
+		beq	copy2
+		preload	r1, 4
+		preload r0, 4
+		loadstore 4
+		sub	r2, #32*4
+		b	copy4
+#else
+copy128:
+                movs    r9, r2, lsr #12
+                beq     copy64
+                preload r1, 128
+                loadstore 128
+                sub     r2, #32*128
+                b       copy128
+copy64:
+                movs    r9, r2, lsr #11
+                beq     copy32
+                preload r1, 64
+                loadstore 64
+                sub     r2, #32*64
+                b       copy64
+
+copy32:
+		movs	r9, r2, lsr #10
+		beq	copy16
+		preload	r1, 32
+		loadstore 32
+		sub	r2, #32*32
+		b 	copy32
+copy16:	
+		movs	r9, r2, lsr #9
+		beq	copy8
+		preload	r1, 16
+		loadstore 16
+		sub	r2, #32*16
+		b	copy16
+
+copy8:
+		movs	r9, r2, lsr #8
+		beq	copy4
+		preload	r1, 8
+		loadstore 8 
+		sub	r2, #32*8
+		b	copy8
+copy4:	
+		movs	r9, r2, lsr #7
+		beq	copy2
+		preload	r1, 4
+		loadstore 4
+		sub	r2, #32*4
+		b	copy4
+#endif
+copy2:
+	
+	
 	PLD(	pld	[r1, #0]		)
 2:	PLD(	subs	r2, r2, #96		)
 	PLD(	pld	[r1, #28]		)
@@ -143,7 +226,7 @@
 
 	CALGN(	bcs	2b			)
 
-7:		ldmfd	sp!, {r5 - r8}
+7:		ldmfd	sp!, {r5 - r9}
 
 8:		movs	r2, r2, lsl #31
 		ldr1b	r1, r3, ne, abort=21f
@@ -257,7 +340,7 @@
 	.macro	copy_abort_preamble
 19:	ldmfd	sp!, {r5 - r9}
 	b	21f
-20:	ldmfd	sp!, {r5 - r8}
+20:	ldmfd	sp!, {r5 - r9}
 21:
 	.endm
 
diff --git a/arch/arm/mm/Kconfig b/arch/arm/mm/Kconfig
index 7c8a7d8..afede57 100644
--- a/arch/arm/mm/Kconfig
+++ b/arch/arm/mm/Kconfig
@@ -382,6 +382,22 @@ config CPU_FEROCEON_OLD_ID
 	  for which the CPU ID is equal to the ARM926 ID.
 	  Relevant for Feroceon-1850 and early Feroceon-2850.
 
+choice
+	prompt "Marvell Sheeva CPU Architecture"
+	default CPU_SHEEVA_PJ4B_V6
+
+config CPU_SHEEVA_PJ4B_V6
+	bool "Support Sheeva processor in V6 mode" if ARCH_ARMADA_XP
+	select CPU_V6
+	select CPU_32v6K
+	select DMA_CACHE_RWFO if SMP
+
+config CPU_SHEEVA_PJ4B_V7
+	bool "Support Sheeva processor in V7 mode" if ARCH_ARMADA_XP
+	select CPU_V7
+
+endchoice
+	  
 # Marvell PJ4
 config CPU_PJ4
 	bool
@@ -705,19 +721,26 @@ config CPU_BIG_ENDIAN
 	  of your chipset/board/processor.
 
 config CPU_ENDIAN_BE8
-	bool
+	bool "Support BE8 Mode"
 	depends on CPU_BIG_ENDIAN
 	default CPU_V6 || CPU_V6K || CPU_V7
 	help
 	  Support for the BE-8 (big-endian) mode on ARMv6 and ARMv7 processors.
 
 config CPU_ENDIAN_BE32
-	bool
+	bool "Support BE32 Mode"
 	depends on CPU_BIG_ENDIAN
 	default !CPU_ENDIAN_BE8
 	help
 	  Support for the BE-32 (big-endian) mode on pre-ARMv6 processors.
 
+config BE8_ON_LE
+	bool "Run BE8 kernel on a little endian machine"
+	depends on CPU_V6 || CPU_V7
+	select CPU_BIG_ENDIAN
+	help
+	  Run BE8 kernel on a little endian machine.
+	  
 config CPU_HIGH_VECTOR
 	depends on !MMU && CPU_CP15 && !CPU_ARM740T
 	bool "Select the High exception vector"
@@ -810,6 +833,14 @@ config DMA_CACHE_RWFO
 	  in hardware, other workarounds are needed (e.g. cache
 	  maintenance broadcasting in software via FIQ).
 
+config SMP_ENABLE_LAZY_FLUSH
+	bool "Enable lazy flush for v6 smp"
+	depends on CPU_V6 && SMP
+	default y
+	help
+	  Enable the lazy flush when calling flush_dcache_page() for smp
+	  v6 mode where cache maintenance breadcasting done in sotfware.
+
 config OUTER_CACHE
 	bool
 
diff --git a/arch/arm/mm/Makefile b/arch/arm/mm/Makefile
index d223854..668555c 100644
--- a/arch/arm/mm/Makefile
+++ b/arch/arm/mm/Makefile
@@ -2,6 +2,8 @@
 # Makefile for the linux arm-specific parts of the memory manager.
 #
 
+include 	  $(srctree)/arch/arm/mach-armadaxp/config/mvRules.mk
+
 obj-y				:= dma-mapping.o extable.o fault.o init.o \
 				   iomap.o
 
@@ -90,9 +92,10 @@ obj-$(CONFIG_CPU_XSCALE)	+= proc-xscale.o
 obj-$(CONFIG_CPU_XSC3)		+= proc-xsc3.o
 obj-$(CONFIG_CPU_MOHAWK)	+= proc-mohawk.o
 obj-$(CONFIG_CPU_FEROCEON)	+= proc-feroceon.o
-obj-$(CONFIG_CPU_V6)		+= proc-v6.o
-obj-$(CONFIG_CPU_V6K)		+= proc-v6.o
-obj-$(CONFIG_CPU_V7)		+= proc-v7.o
+#obj-$(CONFIG_CPU_V6)		+= proc-v6.o
+#obj-$(CONFIG_CPU_V7)		+= proc-v7.o
+obj-$(CONFIG_CPU_SHEEVA_PJ4B_V6)	+= proc-sheeva_pj4bv6.o
+obj-$(CONFIG_CPU_SHEEVA_PJ4B_V7)	+= proc-sheeva_pj4bv7.o
 
 AFLAGS_proc-v6.o	:=-Wa,-march=armv6
 AFLAGS_proc-v7.o	:=-Wa,-march=armv7-a
@@ -101,3 +104,4 @@ obj-$(CONFIG_CACHE_FEROCEON_L2)	+= cache-feroceon-l2.o
 obj-$(CONFIG_CACHE_L2X0)	+= cache-l2x0.o
 obj-$(CONFIG_CACHE_XSC3L2)	+= cache-xsc3l2.o
 obj-$(CONFIG_CACHE_TAUROS2)	+= cache-tauros2.o
+obj-$(CONFIG_CACHE_AURORA_L2)	+= cache-aurora-l2.o
diff --git a/arch/arm/mm/abort-ev6.S b/arch/arm/mm/abort-ev6.S
index 8074199..75ff8fb 100644
--- a/arch/arm/mm/abort-ev6.S
+++ b/arch/arm/mm/abort-ev6.S
@@ -25,6 +25,7 @@ ENTRY(v6_early_abort)
 #endif
 	mrc	p15, 0, r1, c5, c0, 0		@ get FSR
 	mrc	p15, 0, r0, c6, c0, 0		@ get FAR
+#ifndef CONFIG_SMP
 /*
  * Faulty SWP instruction on 1136 doesn't set bit 11 in DFSR.
  */
diff --git a/arch/arm/mm/alignment.c b/arch/arm/mm/alignment.c
index fe06618..eed5587 100644
--- a/arch/arm/mm/alignment.c
+++ b/arch/arm/mm/alignment.c
@@ -960,8 +960,10 @@ static int __init alignment_init(void)
 #endif
 
 	if (cpu_is_v6_unaligned()) {
+#ifndef CONFIG_ENABLE_UNALINGED_ACCESS_FAULT
 		cr_alignment &= ~CR_A;
 		cr_no_alignment &= ~CR_A;
+#endif
 		set_cr(cr_alignment);
 		ai_usermode = safe_usermode(ai_usermode, false);
 	}
diff --git a/arch/arm/mm/cache-v6.S b/arch/arm/mm/cache-v6.S
index 74c2e5a..4434a19 100644
--- a/arch/arm/mm/cache-v6.S
+++ b/arch/arm/mm/cache-v6.S
@@ -63,14 +63,32 @@ ENDPROC(v6_flush_icache_all)
 ENTRY(v6_flush_kern_cache_all)
 	mov	r0, #0
 #ifdef HARVARD_CACHE
+#ifdef CONFIG_SHEEVA_ERRATA_ARM_CPU_4611
+        mrs     r2, cpsr
+        orr     r3, r2, #PSR_F_BIT | PSR_I_BIT
+        msr     cpsr_c, r3                      @ Disable interrupts
+        mcr     p15, 0, r0, c7, c10, 5          @ DMB
+#endif
 	mcr	p15, 0, r0, c7, c14, 0		@ D cache clean+invalidate
+#ifdef CONFIG_SHEEVA_ERRATA_ARM_CPU_4611
+	msr     cpsr_c, r2                      @ Restore interrupts
+#endif
 #ifndef CONFIG_ARM_ERRATA_411920
 	mcr	p15, 0, r0, c7, c5, 0		@ I+BTB cache invalidate
 #else
 	b	v6_flush_icache_all
 #endif
 #else
+#ifdef CONFIG_SHEEVA_ERRATA_ARM_CPU_4611
+        mrs     r2, cpsr
+        orr     r3, r2, #PSR_F_BIT | PSR_I_BIT
+        msr     cpsr_c, r3                      @ Disable interrupts
+        mcr     p15, 0, r0, c7, c10, 5          @ DMB
+#endif
 	mcr	p15, 0, r0, c7, c15, 0		@ Cache clean+invalidate
+#ifdef CONFIG_SHEEVA_ERRATA_ARM_CPU_4611
+	msr     cpsr_c, r2                      @ Restore interrupts
+#endif
 #endif
 	mov	pc, lr
 
@@ -132,12 +150,21 @@ ENTRY(v6_coherent_user_range)
  UNWIND(.fnstart		)
 #ifdef HARVARD_CACHE
 	bic	r0, r0, #CACHE_LINE_SIZE - 1
+#endif
+#if defined (CONFIG_SHEEVA_ERRATA_ARM_CPU_4611) || !defined(CONFIG_HAVE_GENERIC_DMA_COHERENT)
+        mrs     r2, cpsr
+        orr     r3, r2, #PSR_F_BIT | PSR_I_BIT
+        msr     cpsr_c, r3                      @ Disable interrupts
+        mcr     p15, 0, r0, c7, c10, 5          @ DMB
+#endif
 1:
  USER(	mcr	p15, 0, r0, c7, c10, 1	)	@ clean D line
 	add	r0, r0, #CACHE_LINE_SIZE
 2:
 	cmp	r0, r1
 	blo	1b
+#if defined (CONFIG_SHEEVA_ERRATA_ARM_CPU_4611) || !defined(CONFIG_HAVE_GENERIC_DMA_COHERENT)
+        msr     cpsr_c, r2                      @ Restore interrupts
 #endif
 	mov	r0, #0
 #ifdef HARVARD_CACHE
@@ -176,8 +203,18 @@ ENDPROC(v6_coherent_kern_range)
  */
 ENTRY(v6_flush_kern_dcache_area)
 	add	r1, r0, r1
+#if defined (CONFIG_SHEEVA_ERRATA_ARM_CPU_4611) || !defined(CONFIG_HAVE_GENERIC_DMA_COHERENT)
+        mrs     r2, cpsr
+        orr     r3, r2, #PSR_F_BIT | PSR_I_BIT
+        msr     cpsr_c, r3                      @ Disable interrupts
+        mcr     p15, 0, r0, c7, c10, 5          @ DMB
+#endif
 	bic	r0, r0, #D_CACHE_LINE_SIZE - 1
 1:
+#ifdef CONFIG_SMP_ENABLE_LAZY_FLUSH
+	/* no cache maintenance broadcasting */
+	ldr	r3, [r0]			@ read for ownership
+#endif
 #ifdef HARVARD_CACHE
 	mcr	p15, 0, r0, c7, c14, 1		@ clean & invalidate D line
 #else
@@ -186,6 +223,9 @@ ENTRY(v6_flush_kern_dcache_area)
 	add	r0, r0, #D_CACHE_LINE_SIZE
 	cmp	r0, r1
 	blo	1b
+#if defined (CONFIG_SHEEVA_ERRATA_ARM_CPU_4611) || !defined(CONFIG_HAVE_GENERIC_DMA_COHERENT)
+	msr     cpsr_c, r2                      @ Restore interrupts
+#endif
 #ifdef HARVARD_CACHE
 	mov	r0, #0
 	mcr	p15, 0, r0, c7, c10, 4
@@ -210,6 +250,15 @@ v6_dma_inv_range:
 #endif
 	tst	r0, #D_CACHE_LINE_SIZE - 1
 	bic	r0, r0, #D_CACHE_LINE_SIZE - 1
+#if defined (CONFIG_SHEEVA_ERRATA_ARM_CPU_4611) || !defined(CONFIG_HAVE_GENERIC_DMA_COHERENT) 
+	save_and_disable_irqs r3
+        mcr     p15, 0, r0, c7, c10, 5          @ DMB
+#endif
+#if defined (CONFIG_SHEEVA_ERRATA_ARM_CPU_4413) || !defined(CONFIG_HAVE_GENERIC_DMA_COHERENT) 
+	@ This WA is to cover the case tha ERRATA-4611 is not compiled in
+	@ if it is compiled in then the second successive DMB should be very fast
+	mcr 	p15, 0, r0, c7, c10, 5		@ DMB
+#endif
 #ifdef HARVARD_CACHE
 	mcrne	p15, 0, r0, c7, c10, 1		@ clean D line
 #else
@@ -219,6 +268,9 @@ v6_dma_inv_range:
 #ifdef CONFIG_DMA_CACHE_RWFO
 	ldrneb	r2, [r1, #-1]			@ read for ownership
 	strneb	r2, [r1, #-1]			@ write for ownership
+#if defined (CONFIG_SHEEVA_ERRATA_ARM_CPU_4413) || !defined(CONFIG_HAVE_GENERIC_DMA_COHERENT) 
+	mcrne 	p15, 0, r0, c7, c10, 5		@ Data Memory Barrier
+#endif
 #endif
 	bic	r1, r1, #D_CACHE_LINE_SIZE - 1
 #ifdef HARVARD_CACHE
@@ -237,8 +289,14 @@ v6_dma_inv_range:
 #ifdef CONFIG_DMA_CACHE_RWFO
 	ldrlo	r2, [r0]			@ read for ownership
 	strlo	r2, [r0]			@ write for ownership
+#if defined (CONFIG_SHEEVA_ERRATA_ARM_CPU_4413) || !defined(CONFIG_HAVE_GENERIC_DMA_COHERENT) 
+	mcrlo 	p15, 0, r0, c7, c10, 5		@ Data Memory Barrier
+#endif
 #endif
 	blo	1b
+#if defined (CONFIG_SHEEVA_ERRATA_ARM_CPU_4611) || !defined(CONFIG_HAVE_GENERIC_DMA_COHERENT) 
+	restore_irqs r3
+#endif
 	mov	r0, #0
 	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer
 	mov	pc, lr
@@ -250,10 +308,16 @@ v6_dma_inv_range:
  */
 v6_dma_clean_range:
 	bic	r0, r0, #D_CACHE_LINE_SIZE - 1
+#if defined (CONFIG_SHEEVA_ERRATA_ARM_CPU_4611) || !defined(CONFIG_HAVE_GENERIC_DMA_COHERENT) 
+	save_and_disable_irqs r3                @ Disable interrupts
+#endif
 1:
 #ifdef CONFIG_DMA_CACHE_RWFO
 	ldr	r2, [r0]			@ read for ownership
 #endif
+#if defined (CONFIG_SHEEVA_ERRATA_ARM_CPU_4611) || !defined(CONFIG_HAVE_GENERIC_DMA_COHERENT) 
+        mcr     p15, 0, r0, c7, c10, 5          @ DMB
+#endif
 #ifdef HARVARD_CACHE
 	mcr	p15, 0, r0, c7, c10, 1		@ clean D line
 #else
@@ -262,6 +326,9 @@ v6_dma_clean_range:
 	add	r0, r0, #D_CACHE_LINE_SIZE
 	cmp	r0, r1
 	blo	1b
+#if defined (CONFIG_SHEEVA_ERRATA_ARM_CPU_4611) || !defined(CONFIG_HAVE_GENERIC_DMA_COHERENT) 
+	restore_irqs r3               @ Restore interrupts
+#endif
 	mov	r0, #0
 	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer
 	mov	pc, lr
@@ -272,10 +339,16 @@ v6_dma_clean_range:
  *	- end     - virtual end address of region
  */
 ENTRY(v6_dma_flush_range)
+#if defined (CONFIG_SHEEVA_ERRATA_ARM_CPU_4611) || !defined(CONFIG_HAVE_GENERIC_DMA_COHERENT) 
+	save_and_disable_irqs r3                @ Disable interrupts
+#endif
 #ifdef CONFIG_DMA_CACHE_RWFO
 	ldrb	r2, [r0]		@ read for ownership
 	strb	r2, [r0]		@ write for ownership
 #endif
+#if defined (CONFIG_SHEEVA_ERRATA_ARM_CPU_4611) || !defined(CONFIG_HAVE_GENERIC_DMA_COHERENT) 
+        mcr     p15, 0, r0, c7, c10, 5          @ DMB
+#endif
 	bic	r0, r0, #D_CACHE_LINE_SIZE - 1
 1:
 #ifdef HARVARD_CACHE
@@ -288,8 +361,14 @@ ENTRY(v6_dma_flush_range)
 #ifdef CONFIG_DMA_CACHE_RWFO
 	ldrlob	r2, [r0]			@ read for ownership
 	strlob	r2, [r0]			@ write for ownership
+#if defined (CONFIG_SHEEVA_ERRATA_ARM_CPU_4611) || !defined(CONFIG_HAVE_GENERIC_DMA_COHERENT) 
+        mcrlo     p15, 0, r0, c7, c10, 5          @ DMB
+#endif
 #endif
 	blo	1b
+#if defined (CONFIG_SHEEVA_ERRATA_ARM_CPU_4611) || !defined(CONFIG_HAVE_GENERIC_DMA_COHERENT) 
+	restore_irqs r3                      @ Restore interrupts
+#endif
 	mov	r0, #0
 	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer
 	mov	pc, lr
diff --git a/arch/arm/mm/cache-v7.S b/arch/arm/mm/cache-v7.S
index 82ab2c5..ff5393a 100644
--- a/arch/arm/mm/cache-v7.S
+++ b/arch/arm/mm/cache-v7.S
@@ -195,6 +195,9 @@ ENTRY(v7_coherent_user_range)
 	bic	r12, r0, r3
 2:
  USER(	mcr	p15, 0, r12, c7, c5, 1	)	@ invalidate I line
+#ifdef CONFIG_SHEEVA_ERRATA_ARM_CPU_4659
+	isb
+#endif
 	add	r12, r12, r2
 	cmp	r12, r1
 	blo	2b
@@ -274,6 +277,9 @@ v7_dma_inv_range:
 	bic	r1, r1, r3
 	mcrne	p15, 0, r1, c7, c14, 1		@ clean & invalidate D / U line
 1:
+#if defined (CONFIG_SHEEVA_ERRATA_ARM_CPU_4413)
+	dmb
+#endif
 	mcr	p15, 0, r0, c7, c6, 1		@ invalidate D / U line
 	add	r0, r0, r2
 	cmp	r0, r1
diff --git a/arch/arm/mm/copypage-v6.c b/arch/arm/mm/copypage-v6.c
index b9bcc9d..c70d685 100644
--- a/arch/arm/mm/copypage-v6.c
+++ b/arch/arm/mm/copypage-v6.c
@@ -59,11 +59,20 @@ static void v6_clear_user_highpage_nonaliasing(struct page *page, unsigned long
  */
 static void discard_old_kernel_data(void *kto)
 {
+#ifdef CONFIG_SHEEVA_ERRATA_ARM_CPU_4611
+	unsigned long flags;
+
+	raw_local_irq_save(flags);
+	dmb();	
+#endif
 	__asm__("mcrr	p15, 0, %1, %0, c6	@ 0xec401f06"
 	   :
 	   : "r" (kto),
 	     "r" ((unsigned long)kto + PAGE_SIZE - L1_CACHE_BYTES)
 	   : "cc");
+#ifdef CONFIG_SHEEVA_ERRATA_ARM_CPU_4611
+	raw_local_irq_restore(flags);
+#endif
 }
 
 /*
diff --git a/arch/arm/mm/mmu.c b/arch/arm/mm/mmu.c
index ecb962b..983ad96 100644
--- a/arch/arm/mm/mmu.c
+++ b/arch/arm/mm/mmu.c
@@ -118,6 +118,7 @@ static int __init early_cachepolicy(char *p)
 	}
 	if (i == ARRAY_SIZE(cache_policies))
 		printk(KERN_ERR "ERROR: unknown or unsupported cache policy\n");
+#if !defined (CONFIG_CPU_SHEEVA_PJ4B_V6) && !defined(CONFIG_CPU_SHEEVA_PJ4B_V7)
 	/*
 	 * This restriction is partly to do with the way we boot; it is
 	 * unpredictable to have memory mapped using two different sets of
@@ -129,6 +130,7 @@ static int __init early_cachepolicy(char *p)
 		printk(KERN_WARNING "Only cachepolicy=writeback supported on ARMv6 and later\n");
 		cachepolicy = CPOLICY_WRITEBACK;
 	}
+#endif
 	flush_cache_all();
 	set_cr(cr_alignment);
 	return 0;
@@ -326,8 +328,10 @@ static void __init build_mem_type_table(void)
 			cachepolicy = CPOLICY_WRITEBACK;
 		ecc_mask = 0;
 	}
-	if (is_smp())
+	/*if (is_smp())*/
+#if defined(CONFIG_SMP) || defined (CONFIG_AURORA_IO_CACHE_COHERENCY)
 		cachepolicy = CPOLICY_WRITEALLOC;
+#endif
 
 	/*
 	 * Strip out features not present on earlier architectures.
@@ -968,6 +972,7 @@ void __init sanity_check_meminfo(void)
 
 		j++;
 	}
+#ifndef CONFIG_ARCH_ARMADA_XP
 #ifdef CONFIG_HIGHMEM
 	if (highmem) {
 		const char *reason = NULL;
diff --git a/arch/arm/mm/proc-macros.S b/arch/arm/mm/proc-macros.S
index 2d8ff3a..844dabb 100644
--- a/arch/arm/mm/proc-macros.S
+++ b/arch/arm/mm/proc-macros.S
@@ -169,7 +169,29 @@
 	moveq	r3, #0
 
 	str	r3, [r0]
+	
+#ifdef CONFIG_SHEEVA_ERRATA_ARM_CPU_4611
+        mrs     r2, cpsr
+        orr     r3, r2, #PSR_F_BIT | PSR_I_BIT
+        msr     cpsr_c, r3                      @ Disable interrupts
+
+#if __LINUX_ARM_ARCH__ >= 7
+	dmb					@ DMB for V7
+#elif __LINUX_ARM_ARCH__ == 6
+        mcr     p15, 0, r0, c7, c10, 5          @ DMB for V6
+#endif
+#endif
 	mcr	p15, 0, r0, c7, c10, 1		@ flush_pte
+#if defined (CONFIG_CACHE_AURORA_L2) && defined (CONFIG_AURORA_L2_OUTER) && !defined (CONFIG_AURORA_L2_PT_WALK)
+#error "armv6_set_pte_ext: calling l2_clean_va corrupts r2. SHOULD BE FIXED"
+	bl	l2_clean_va
+#endif
+#ifdef CONFIG_SHEEVA_ERRATA_ARM_CPU_4611
+	msr     cpsr_c, r2                      @ Restore interrupts
+	mcr     p15, 0, r0, c7, c10, 4          @ drain write buffer
+#endif
+
+	
 	.endm
 
 
diff --git a/arch/arm/oprofile/common.c b/arch/arm/oprofile/common.c
index 91387f7..d87d0cd 100644
--- a/arch/arm/oprofile/common.c
+++ b/arch/arm/oprofile/common.c
@@ -44,6 +44,8 @@ char *op_name_from_perf_id(void)
 		return "arm/armv7-ca9";
 	case ARM_PERF_PMU_ID_CA15:
 		return "arm/armv7-ca15";
+	case MRVL_PERF_PMU_ID_PJ4B:
+		return "arm/mrvl_pj4b";
 	default:
 		return NULL;
 	}
diff --git a/arch/arm/vfp/vfpmodule.c b/arch/arm/vfp/vfpmodule.c
index eede545..e322855 100644
--- a/arch/arm/vfp/vfpmodule.c
+++ b/arch/arm/vfp/vfpmodule.c
@@ -336,6 +336,10 @@ void VFP_bounce(u32 trigger, u32 fpexc, struct pt_regs *regs)
 {
 	u32 fpscr, orig_fpscr, fpsid, exceptions;
 
+	/* Adjust saved PC for thumb-2 user program */
+	if (regs->ARM_cpsr & PSR_T_BIT)
+		regs->ARM_pc += 2;
+
 	pr_debug("VFP: bounce: trigger %08x fpexc %08x\n", trigger, fpexc);
 
 	/*
diff --git a/drivers/ata/libata-pmp.c b/drivers/ata/libata-pmp.c
index 0ba32fe..c7a1420 100644
--- a/drivers/ata/libata-pmp.c
+++ b/drivers/ata/libata-pmp.c
@@ -460,7 +460,19 @@ static void sata_pmp_quirks(struct ata_port *ap)
 				       ATA_LFLAG_NO_SRST |
 				       ATA_LFLAG_ASSUME_ATA;
 		}
+	}else if (vendor == 0x11ab && devid == 0x4140) {
+		/* Marvell 4140 quirks */
+
+		ata_for_each_link(link, ap, EDGE) {
+			/* port 4 is for SEMB device and it doesn't like SRST */
+			if (link->pmp == 4)
+
+
+
+				link->flags |= ATA_LFLAG_DISABLED;
+		}	
 	}
+	
 }
 
 /**
diff --git a/drivers/ata/sata_mv.c b/drivers/ata/sata_mv.c
index 7336d4a..c7b8603 100644
--- a/drivers/ata/sata_mv.c
+++ b/drivers/ata/sata_mv.c
@@ -2780,6 +2780,7 @@ static void mv_process_crpb_entries(struct ata_port *ap, struct mv_port_priv *pp
 	in_index = (readl(port_mmio + EDMA_RSP_Q_IN_PTR)
 			>> EDMA_RSP_Q_PTR_SHIFT) & MV_MAX_Q_DEPTH_MASK;
 
+		dma_io_sync();
 	/* Process new responses from since the last time we looked */
 	while (in_index != pp->resp_idx) {
 		unsigned int tag;
diff --git a/drivers/dma/Kconfig b/drivers/dma/Kconfig
index 7de7a65..4b13705 100644
--- a/drivers/dma/Kconfig
+++ b/drivers/dma/Kconfig
@@ -115,7 +115,7 @@ config MPC512X_DMA
 
 config MV_XOR
 	bool "Marvell XOR engine support"
-	depends on PLAT_ORION
+	depends on PLAT_ORION || PLAT_ARMADA
 	select DMA_ENGINE
 	select ASYNC_TX_ENABLE_CHANNEL_SWITCH
 	---help---
diff --git a/drivers/dma/mv_xor.c b/drivers/dma/mv_xor.c
index fa5d55f..200d8c3 100644
--- a/drivers/dma/mv_xor.c
+++ b/drivers/dma/mv_xor.c
@@ -32,6 +32,10 @@
 
 static void mv_xor_issue_pending(struct dma_chan *chan);
 
+unsigned int dummy1[MV_XOR_MIN_BYTE_COUNT];
+unsigned int dummy2[MV_XOR_MIN_BYTE_COUNT];
+dma_addr_t dummy1_addr, dummy2_addr;
+
 #define to_mv_xor_chan(chan)		\
 	container_of(chan, struct mv_xor_chan, common)
 
@@ -41,13 +45,21 @@ static void mv_xor_issue_pending(struct dma_chan *chan);
 #define to_mv_xor_slot(tx)		\
 	container_of(tx, struct mv_xor_desc_slot, async_tx)
 
-static void mv_desc_init(struct mv_xor_desc_slot *desc, unsigned long flags)
+static void mv_desc_init(struct mv_xor_desc_slot *desc, unsigned int srcs, unsigned long flags)
 {
 	struct mv_xor_desc *hw_desc = desc->hw_desc;
+	u32 command = 0;
 
 	hw_desc->status = (1 << 31);
 	hw_desc->phy_next_desc = 0;
-	hw_desc->desc_command = (1 << 31);
+
+	if (flags & DMA_PREP_INTERRUPT)
+		command = (1 << 31);
+
+	if (desc->type == DMA_XOR)
+		command |= (1 << srcs) - 1;
+
+	hw_desc->desc_command = command;
 }
 
 static u32 mv_desc_get_dest_addr(struct mv_xor_desc_slot *desc)
@@ -79,12 +91,6 @@ static void mv_desc_set_next_desc(struct mv_xor_desc_slot *desc,
 	hw_desc->phy_next_desc = next_desc_addr;
 }
 
-static void mv_desc_clear_next_desc(struct mv_xor_desc_slot *desc)
-{
-	struct mv_xor_desc *hw_desc = desc->hw_desc;
-	hw_desc->phy_next_desc = 0;
-}
-
 static void mv_desc_set_block_fill_val(struct mv_xor_desc_slot *desc, u32 val)
 {
 	desc->value = val;
@@ -97,20 +103,11 @@ static void mv_desc_set_dest_addr(struct mv_xor_desc_slot *desc,
 	hw_desc->phy_dest_addr = addr;
 }
 
-static int mv_chan_memset_slot_count(size_t len)
-{
-	return 1;
-}
-
-#define mv_chan_memcpy_slot_count(c) mv_chan_memset_slot_count(c)
-
 static void mv_desc_set_src_addr(struct mv_xor_desc_slot *desc,
 				 int index, dma_addr_t addr)
 {
 	struct mv_xor_desc *hw_desc = desc->hw_desc;
 	hw_desc->phy_src_addr[index] = addr;
-	if (desc->type == DMA_XOR)
-		hw_desc->desc_command |= (1 << index);
 }
 
 static u32 mv_chan_get_current_desc(struct mv_xor_chan *chan)
@@ -164,7 +161,7 @@ static int mv_is_err_intr(u32 intr_cause)
 
 static void mv_xor_device_clear_eoc_cause(struct mv_xor_chan *chan)
 {
-	u32 val = ~(1 << (chan->idx * 16));
+	u32 val = ~(3 << (chan->idx * 16));
 	dev_dbg(chan->device->common.dev, "%s, val 0x%08x\n", __func__, val);
 	__raw_writel(val, XOR_INTR_CAUSE(chan));
 }
@@ -220,12 +217,9 @@ static void mv_set_mode(struct mv_xor_chan *chan,
 
 static void mv_chan_activate(struct mv_xor_chan *chan)
 {
-	u32 activation;
-
 	dev_dbg(chan->device->common.dev, " activate chan.\n");
-	activation = __raw_readl(XOR_ACTIVATION(chan));
-	activation |= 0x1;
-	__raw_writel(activation, XOR_ACTIVATION(chan));
+
+	__raw_writel(1, XOR_ACTIVATION(chan));
 }
 
 static char mv_chan_is_busy(struct mv_xor_chan *chan)
@@ -237,11 +231,6 @@ static char mv_chan_is_busy(struct mv_xor_chan *chan)
 	return (state == 1) ? 1 : 0;
 }
 
-static int mv_chan_xor_slot_count(size_t len, int src_cnt)
-{
-	return 1;
-}
-
 /**
  * mv_xor_free_slots - flags descriptor slots for reuse
  * @slot: Slot to free
@@ -282,8 +271,7 @@ static void mv_xor_start_new_chain(struct mv_xor_chan *mv_chan,
 		/* set the hardware chain */
 		mv_chan_set_next_descriptor(mv_chan, sw_desc->async_tx.phys);
 	}
-	mv_chan->pending += sw_desc->slot_cnt;
-	mv_xor_issue_pending(&mv_chan->common);
+	mv_chan_activate(mv_chan);
 }
 
 static dma_cookie_t
@@ -291,7 +279,8 @@ mv_xor_run_tx_complete_actions(struct mv_xor_desc_slot *desc,
 	struct mv_xor_chan *mv_chan, dma_cookie_t cookie)
 {
 	BUG_ON(desc->async_tx.cookie < 0);
-
+	dev_dbg(mv_chan->device->common.dev, "%s %d: desc %p\n",
+		__func__, __LINE__, desc);
 	if (desc->async_tx.cookie > 0) {
 		cookie = desc->async_tx.cookie;
 
@@ -305,8 +294,8 @@ mv_xor_run_tx_complete_actions(struct mv_xor_desc_slot *desc,
 		/* unmap dma addresses
 		 * (unmap_single vs unmap_page?)
 		 */
-		if (desc->group_head && desc->unmap_len) {
-			struct mv_xor_desc_slot *unmap = desc->group_head;
+		if (desc->unmap_len) {
+			struct mv_xor_desc_slot *unmap = desc;
 			struct device *dev =
 				&mv_chan->device->pdev->dev;
 			u32 len = unmap->unmap_len;
@@ -337,7 +326,6 @@ mv_xor_run_tx_complete_actions(struct mv_xor_desc_slot *desc,
 						       DMA_TO_DEVICE);
 				}
 			}
-			desc->group_head = NULL;
 		}
 	}
 
@@ -392,7 +380,6 @@ static void __mv_xor_slot_cleanup(struct mv_xor_chan *mv_chan)
 	u32 current_desc = mv_chan_get_current_desc(mv_chan);
 	int seen_current = 0;
 
-	dev_dbg(mv_chan->device->common.dev, "%s %d\n", __func__, __LINE__);
 	dev_dbg(mv_chan->device->common.dev, "current_desc %x\n", current_desc);
 	mv_xor_clean_completed_slots(mv_chan);
 
@@ -455,19 +442,16 @@ static void mv_xor_tasklet(unsigned long data)
 }
 
 static struct mv_xor_desc_slot *
-mv_xor_alloc_slots(struct mv_xor_chan *mv_chan, int num_slots,
-		    int slots_per_op)
+mv_xor_alloc_slots(struct mv_xor_chan *mv_chan)
 {
-	struct mv_xor_desc_slot *iter, *_iter, *alloc_start = NULL;
-	LIST_HEAD(chain);
-	int slots_found, retry = 0;
+	struct mv_xor_desc_slot *iter, *_iter;
+	int retry = 0;
 
 	/* start search from the last allocated descrtiptor
 	 * if a contiguous allocation can not be found start searching
 	 * from the beginning of the list
 	 */
 retry:
-	slots_found = 0;
 	if (retry == 0)
 		iter = mv_chan->last_used;
 	else
@@ -485,47 +469,17 @@ retry:
 			 */
 			if (retry)
 				break;
-
-			slots_found = 0;
 			continue;
 		}
 
-		/* start the allocation if the slot is correctly aligned */
-		if (!slots_found++)
-			alloc_start = iter;
-
-		if (slots_found == num_slots) {
-			struct mv_xor_desc_slot *alloc_tail = NULL;
-			struct mv_xor_desc_slot *last_used = NULL;
-			iter = alloc_start;
-			while (num_slots) {
-				int i;
-
-				/* pre-ack all but the last descriptor */
-				async_tx_ack(&iter->async_tx);
-
-				list_add_tail(&iter->chain_node, &chain);
-				alloc_tail = iter;
-				iter->async_tx.cookie = 0;
-				iter->slot_cnt = num_slots;
-				iter->xor_check_result = NULL;
-				for (i = 0; i < slots_per_op; i++) {
-					iter->slots_per_op = slots_per_op - i;
-					last_used = iter;
-					iter = list_entry(iter->slot_node.next,
-						struct mv_xor_desc_slot,
-						slot_node);
-				}
-				num_slots -= slots_per_op;
-			}
-			alloc_tail->group_head = alloc_start;
-			alloc_tail->async_tx.cookie = -EBUSY;
-			list_splice(&chain, &alloc_tail->tx_list);
-			mv_chan->last_used = last_used;
-			mv_desc_clear_next_desc(alloc_start);
-			mv_desc_clear_next_desc(alloc_tail);
-			return alloc_tail;
-		}
+		/* pre-ack descriptor */
+		async_tx_ack(&iter->async_tx);
+		
+		iter->async_tx.cookie = -EBUSY;
+		iter->slots_per_op = 1;
+		INIT_LIST_HEAD(&iter->chain_node);		
+		mv_chan->last_used = iter;
+		return iter;
 	}
 	if (!retry++)
 		goto retry;
@@ -588,7 +542,7 @@ mv_xor_tx_submit(struct dma_async_tx_descriptor *tx)
 	}
 
 	if (new_hw_chain)
-		mv_xor_start_new_chain(mv_chan, grp_start);
+		mv_xor_start_new_chain(mv_chan, sw_desc);
 
 submit_done:
 	spin_unlock_bh(&mv_chan->lock);
@@ -623,7 +577,6 @@ static int mv_xor_alloc_chan_resources(struct dma_chan *chan)
 		slot->async_tx.tx_submit = mv_xor_tx_submit;
 		INIT_LIST_HEAD(&slot->chain_node);
 		INIT_LIST_HEAD(&slot->slot_node);
-		INIT_LIST_HEAD(&slot->tx_list);
 		hw_desc = (char *) mv_chan->device->dma_desc_pool;
 		slot->async_tx.phys =
 			(dma_addr_t) &hw_desc[idx * MV_XOR_SLOT_SIZE];
@@ -652,11 +605,10 @@ mv_xor_prep_dma_memcpy(struct dma_chan *chan, dma_addr_t dest, dma_addr_t src,
 		size_t len, unsigned long flags)
 {
 	struct mv_xor_chan *mv_chan = to_mv_xor_chan(chan);
-	struct mv_xor_desc_slot *sw_desc, *grp_start;
-	int slot_cnt;
+	struct mv_xor_desc_slot *sw_desc;
 
 	dev_dbg(mv_chan->device->common.dev,
-		"%s dest: %x src %x len: %u flags: %ld\n",
+		"%s dest: %x src %x len: %u flags: %lx\n",
 		__func__, dest, src, len, flags);
 	if (unlikely(len < MV_XOR_MIN_BYTE_COUNT))
 		return NULL;
@@ -664,16 +616,15 @@ mv_xor_prep_dma_memcpy(struct dma_chan *chan, dma_addr_t dest, dma_addr_t src,
 	BUG_ON(len > MV_XOR_MAX_BYTE_COUNT);
 
 	spin_lock_bh(&mv_chan->lock);
-	slot_cnt = mv_chan_memcpy_slot_count(len);
-	sw_desc = mv_xor_alloc_slots(mv_chan, slot_cnt, 1);
+
+	sw_desc = mv_xor_alloc_slots(mv_chan);
 	if (sw_desc) {
-		sw_desc->type = DMA_MEMCPY;
+		sw_desc->type = DMA_XOR;
 		sw_desc->async_tx.flags = flags;
-		grp_start = sw_desc->group_head;
-		mv_desc_init(grp_start, flags);
-		mv_desc_set_byte_count(grp_start, len);
-		mv_desc_set_dest_addr(sw_desc->group_head, dest);
-		mv_desc_set_src_addr(grp_start, 0, src);
+		mv_desc_init(sw_desc, 1, flags);
+		mv_desc_set_byte_count(sw_desc, len);
+		mv_desc_set_dest_addr(sw_desc, dest);
+		mv_desc_set_src_addr(sw_desc, 0, src);
 		sw_desc->unmap_src_cnt = 1;
 		sw_desc->unmap_len = len;
 	}
@@ -686,16 +637,42 @@ mv_xor_prep_dma_memcpy(struct dma_chan *chan, dma_addr_t dest, dma_addr_t src,
 	return sw_desc ? &sw_desc->async_tx : NULL;
 }
 
+struct dma_async_tx_descriptor *
+mv_xor_prep_dma_interrupt(struct dma_chan *chan, unsigned long flags)
+{
+	struct mv_xor_chan *mv_chan = to_mv_xor_chan(chan);
+	struct mv_xor_desc_slot *sw_desc;
+
+	dev_dbg(mv_chan->device->common.dev,
+		"%s flags: %lx\n", __func__, flags);
+
+	spin_lock_bh(&mv_chan->lock);
+
+	sw_desc = mv_xor_alloc_slots(mv_chan);
+	if (sw_desc) {
+		sw_desc->type = DMA_XOR;
+		sw_desc->async_tx.flags = flags;
+		mv_desc_init(sw_desc, 1, DMA_PREP_INTERRUPT);
+		mv_desc_set_byte_count(sw_desc, MV_XOR_MIN_BYTE_COUNT);
+		mv_desc_set_dest_addr(sw_desc, dummy1_addr);
+		mv_desc_set_src_addr(sw_desc, 0, dummy2_addr);
+		sw_desc->unmap_len = 0;
+	}
+	spin_unlock_bh(&mv_chan->lock);
+	dev_dbg(mv_chan->device->common.dev, "%s sw_desc %p async_tx %p\n",
+		__func__, sw_desc, &sw_desc->async_tx);
+	return sw_desc ? &sw_desc->async_tx : NULL;
+}
+
 static struct dma_async_tx_descriptor *
 mv_xor_prep_dma_memset(struct dma_chan *chan, dma_addr_t dest, int value,
 		       size_t len, unsigned long flags)
 {
 	struct mv_xor_chan *mv_chan = to_mv_xor_chan(chan);
-	struct mv_xor_desc_slot *sw_desc, *grp_start;
-	int slot_cnt;
+	struct mv_xor_desc_slot *sw_desc;
 
 	dev_dbg(mv_chan->device->common.dev,
-		"%s dest: %x len: %u flags: %ld\n",
+		"%s dest: %x len: %u flags: %lx\n",
 		__func__, dest, len, flags);
 	if (unlikely(len < MV_XOR_MIN_BYTE_COUNT))
 		return NULL;
@@ -703,16 +680,15 @@ mv_xor_prep_dma_memset(struct dma_chan *chan, dma_addr_t dest, int value,
 	BUG_ON(len > MV_XOR_MAX_BYTE_COUNT);
 
 	spin_lock_bh(&mv_chan->lock);
-	slot_cnt = mv_chan_memset_slot_count(len);
-	sw_desc = mv_xor_alloc_slots(mv_chan, slot_cnt, 1);
+
+	sw_desc = mv_xor_alloc_slots(mv_chan);
 	if (sw_desc) {
 		sw_desc->type = DMA_MEMSET;
 		sw_desc->async_tx.flags = flags;
-		grp_start = sw_desc->group_head;
-		mv_desc_init(grp_start, flags);
-		mv_desc_set_byte_count(grp_start, len);
-		mv_desc_set_dest_addr(sw_desc->group_head, dest);
-		mv_desc_set_block_fill_val(grp_start, value);
+		mv_desc_init(sw_desc, 0, flags);
+		mv_desc_set_byte_count(sw_desc, len);
+		mv_desc_set_dest_addr(sw_desc, dest);
+		mv_desc_set_block_fill_val(sw_desc, value);
 		sw_desc->unmap_src_cnt = 1;
 		sw_desc->unmap_len = len;
 	}
@@ -728,33 +704,32 @@ mv_xor_prep_dma_xor(struct dma_chan *chan, dma_addr_t dest, dma_addr_t *src,
 		    unsigned int src_cnt, size_t len, unsigned long flags)
 {
 	struct mv_xor_chan *mv_chan = to_mv_xor_chan(chan);
-	struct mv_xor_desc_slot *sw_desc, *grp_start;
-	int slot_cnt;
+	struct mv_xor_desc_slot *sw_desc;
 
 	if (unlikely(len < MV_XOR_MIN_BYTE_COUNT))
 		return NULL;
 
-	BUG_ON(len > MV_XOR_MAX_BYTE_COUNT);
+	BUG_ON(unlikely(len > MV_XOR_MAX_BYTE_COUNT));
 
 	dev_dbg(mv_chan->device->common.dev,
-		"%s src_cnt: %d len: dest %x %u flags: %ld\n",
+		"%s src_cnt: %d len: dest %x %u flags: %lx\n",
 		__func__, src_cnt, len, dest, flags);
 
 	spin_lock_bh(&mv_chan->lock);
-	slot_cnt = mv_chan_xor_slot_count(len, src_cnt);
-	sw_desc = mv_xor_alloc_slots(mv_chan, slot_cnt, 1);
+
+	sw_desc = mv_xor_alloc_slots(mv_chan);
 	if (sw_desc) {
 		sw_desc->type = DMA_XOR;
 		sw_desc->async_tx.flags = flags;
-		grp_start = sw_desc->group_head;
-		mv_desc_init(grp_start, flags);
+
+		mv_desc_init(sw_desc, src_cnt, flags);
 		/* the byte count field is the same as in memcpy desc*/
-		mv_desc_set_byte_count(grp_start, len);
-		mv_desc_set_dest_addr(sw_desc->group_head, dest);
+		mv_desc_set_byte_count(sw_desc, len);
+		mv_desc_set_dest_addr(sw_desc, dest);
 		sw_desc->unmap_src_cnt = src_cnt;
 		sw_desc->unmap_len = len;
 		while (src_cnt--)
-			mv_desc_set_src_addr(grp_start, src_cnt, src[src_cnt]);
+			mv_desc_set_src_addr(sw_desc, src_cnt, src[src_cnt]);
 	}
 	spin_unlock_bh(&mv_chan->lock);
 	dev_dbg(mv_chan->device->common.dev,
@@ -888,11 +863,8 @@ static irqreturn_t mv_xor_interrupt_handler(int irq, void *data)
 static void mv_xor_issue_pending(struct dma_chan *chan)
 {
 	struct mv_xor_chan *mv_chan = to_mv_xor_chan(chan);
-
-	if (mv_chan->pending >= MV_XOR_THRESHOLD) {
-		mv_chan->pending = 0;
-		mv_chan_activate(mv_chan);
-	}
+	
+	mv_xor_slot_cleanup(mv_chan);
 }
 
 /*
@@ -1108,6 +1080,10 @@ static int __devinit mv_xor_probe(struct platform_device *pdev)
 	struct dma_device *dma_dev;
 	struct mv_xor_platform_data *plat_data = pdev->dev.platform_data;
 
+	dummy1_addr = dma_map_single(NULL, (void *)dummy1,
+				     MV_XOR_MIN_BYTE_COUNT, DMA_FROM_DEVICE);
+	dummy2_addr = dma_map_single(NULL, (void *)dummy1,
+				     MV_XOR_MIN_BYTE_COUNT, DMA_TO_DEVICE);
 
 	adev = devm_kzalloc(&pdev->dev, sizeof(*adev), GFP_KERNEL);
 	if (!adev)
@@ -1147,6 +1123,8 @@ static int __devinit mv_xor_probe(struct platform_device *pdev)
 	/* set prep routines based on capability */
 	if (dma_has_cap(DMA_MEMCPY, dma_dev->cap_mask))
 		dma_dev->device_prep_dma_memcpy = mv_xor_prep_dma_memcpy;
+	if (dma_has_cap(DMA_INTERRUPT, dma_dev->cap_mask))
+		dma_dev->device_prep_dma_interrupt = mv_xor_prep_dma_interrupt;
 	if (dma_has_cap(DMA_MEMSET, dma_dev->cap_mask))
 		dma_dev->device_prep_dma_memset = mv_xor_prep_dma_memset;
 	if (dma_has_cap(DMA_XOR, dma_dev->cap_mask)) {
diff --git a/drivers/dma/mv_xor.h b/drivers/dma/mv_xor.h
index 654876b..a1b101f 100644
--- a/drivers/dma/mv_xor.h
+++ b/drivers/dma/mv_xor.h
@@ -45,7 +45,7 @@
 #define XOR_INTR_MASK(chan)	(chan->mmr_base + 0x40)
 #define XOR_ERROR_CAUSE(chan)	(chan->mmr_base + 0x50)
 #define XOR_ERROR_ADDR(chan)	(chan->mmr_base + 0x60)
-#define XOR_INTR_MASK_VALUE	0x3F5
+#define XOR_INTR_MASK_VALUE	0x3F7
 
 #define WINDOW_BASE(w)		(0x250 + ((w) << 2))
 #define WINDOW_SIZE(w)		(0x270 + ((w) << 2))
@@ -117,7 +117,6 @@ struct mv_xor_chan {
  * @completed_node: node on the mv_xor_chan.completed_slots list
  * @hw_desc: virtual address of the hardware descriptor chain
  * @phys: hardware address of the hardware descriptor chain
- * @group_head: first operation in a transaction
  * @slot_cnt: total slots used in an transaction (group of operations)
  * @slots_per_op: number of slots per operation
  * @idx: pool index
@@ -134,14 +133,11 @@ struct mv_xor_desc_slot {
 	struct list_head	completed_node;
 	enum dma_transaction_type	type;
 	void			*hw_desc;
-	struct mv_xor_desc_slot	*group_head;
-	u16			slot_cnt;
 	u16			slots_per_op;
 	u16			idx;
 	u16			unmap_src_cnt;
 	u32			value;
 	size_t			unmap_len;
-	struct list_head	tx_list;
 	struct dma_async_tx_descriptor	async_tx;
 	union {
 		u32		*xor_check_result;
diff --git a/drivers/hwmon/Kconfig b/drivers/hwmon/Kconfig
index 8deedc1..0fe1dba 100644
--- a/drivers/hwmon/Kconfig
+++ b/drivers/hwmon/Kconfig
@@ -220,6 +220,13 @@ config SENSORS_ADT7475
 
 	  This driver can also be build as a module.  If so, the module
 	  will be called adt7475.
+config SENSORS_ARMADA_XP
+	tristate "Armada XP SoC Thermal Sensor"
+	depends on ARCH_ARMADA_XP
+	default y
+	help
+	  This driver provides support for the Marvell's Armada XP SoC thermal
+	  Controller, which provides onchip temperature sensors.
 
 config SENSORS_ASC7621
 	tristate "Andigilog aSC7621"
diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index 65e04ba..6d228e5 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -492,7 +492,7 @@ config I2C_MPC
 
 config I2C_MV64XXX
 	tristate "Marvell mv64xxx I2C Controller"
-	depends on (MV64X60 || PLAT_ORION) && EXPERIMENTAL
+	depends on (MV64X60 || PLAT_ORION || PLAT_ARMADA) && EXPERIMENTAL
 	help
 	  If you say yes to this option, support will be included for the
 	  built-in I2C interface on the Marvell 64xxx line of host bridges.
diff --git a/drivers/i2c/busses/i2c-mv64xxx.c b/drivers/i2c/busses/i2c-mv64xxx.c
index 4f44a33..7b27f79 100644
--- a/drivers/i2c/busses/i2c-mv64xxx.c
+++ b/drivers/i2c/busses/i2c-mv64xxx.c
@@ -528,7 +528,7 @@ mv64xxx_i2c_probe(struct platform_device *pd)
 	struct mv64xxx_i2c_pdata	*pdata = pd->dev.platform_data;
 	int	rc;
 
-	if ((pd->id != 0) || !pdata)
+	if ( (pd->id > 1) || (pd->id < 0) || !pdata)
 		return -ENODEV;
 
 	drv_data = kzalloc(sizeof(struct mv64xxx_i2c_data), GFP_KERNEL);
diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index 9f99a58..13d4ee2 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -352,7 +352,7 @@ config MMC_TIFM_SD
 
 config MMC_MVSDIO
 	tristate "Marvell MMC/SD/SDIO host driver"
-	depends on PLAT_ORION
+	depends on PLAT_ORION || PLAT_ARMADA
 	---help---
 	  This selects the Marvell SDIO host driver.
 	  SDIO may currently be found on the Kirkwood 88F6281 and 88F6192
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index d4b4d87..0bcd071 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -52,4 +52,6 @@ obj-$(CONFIG_MTD_NAND_RICOH)		+= r852.o
 obj-$(CONFIG_MTD_NAND_JZ4740)		+= jz4740_nand.o
 obj-$(CONFIG_MTD_NAND_GPMI_NAND)	+= gpmi-nand/
 
+obj-$(CONFIG_MTD_NAND_NFC)			+= ../../../arch/arm/plat-armada/mv_drivers_lsp/mv_mtd/
+
 nand-objs := nand_base.o nand_bbt.o
diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c
index 4afc6d5..78d40ea 100644
--- a/drivers/mtd/nand/nand_base.c
+++ b/drivers/mtd/nand/nand_base.c
@@ -49,6 +49,11 @@
 #include <linux/io.h>
 #include <linux/mtd/partitions.h>
 
+
+
+#ifdef CONFIG_MTD_NAND_NFC_GANG_SUPPORT
+static char nand_name[128];
+#endif
 /* Define default oob placement schemes for large and small page devices */
 static struct nand_ecclayout nand_oob_8 = {
 	.eccbytes = 3,
@@ -2998,10 +3003,24 @@ static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
 	if (!type->name)
 		return ERR_PTR(-ENODEV);
 
-	if (!mtd->name)
+	if (!mtd->name){
+
+#ifdef CONFIG_MTD_NAND_NFC_GANG_SUPPORT
+		sprintf(nand_name, "%s%s", type->name,
+				(chip->num_devs == 2) ? " - Ganged" : "");
+		type->name = nand_name;
+#endif
 		mtd->name = type->name;
+}
 
 	chip->chipsize = (uint64_t)type->chipsize << 20;
+#ifdef CONFIG_MTD_NAND_NFC_GANG_SUPPORT
+	chip->chipsize *= chip->num_devs;
+	if(chip->num_devs > 1)
+		type->options |= NAND_BUSWIDTH_16;
+#endif
+
+
 
 	if (!type->pagesize && chip->init_size) {
 		/* Set the pagesize, oobsize, erasesize by the driver */
@@ -3051,6 +3070,9 @@ static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
 		} else {
 			/* Calc pagesize */
 			mtd->writesize = 1024 << (extid & 0x03);
+#ifdef CONFIG_MTD_NAND_NFC_GANG_SUPPORT
+			mtd->writesize *= chip->num_devs;
+#endif
 			extid >>= 2;
 			/* Calc oobsize */
 			mtd->oobsize = (8 << (extid & 0x01)) *
@@ -3058,9 +3080,16 @@ static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
 			extid >>= 2;
 			/* Calc blocksize. Blocksize is multiples of 64KiB */
 			mtd->erasesize = (64 * 1024) << (extid & 0x03);
+#ifdef CONFIG_MTD_NAND_NFC_GANG_SUPPORT
+			mtd->erasesize *= chip->num_devs;
+#endif
 			extid >>= 2;
 			/* Get buswidth information */
 			busw = (extid & 0x01) ? NAND_BUSWIDTH_16 : 0;
+#ifdef CONFIG_MTD_NAND_NFC_GANG_SUPPORT
+			if(chip->num_devs > 1)
+				busw = NAND_BUSWIDTH_16;
+#endif
 		}
 	} else {
 		/*
@@ -3069,7 +3098,16 @@ static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
 		mtd->erasesize = type->erasesize;
 		mtd->writesize = type->pagesize;
 		mtd->oobsize = mtd->writesize / 32;
+#ifdef CONFIG_MTD_NAND_NFC_MLC_SUPPORT
+		/* New devices have non standard OOB size */
+		if (chip->oobsize_ovrd)
+			mtd->oobsize = chip->oobsize_ovrd;
+#endif
 		busw = type->options & NAND_BUSWIDTH_16;
+#ifdef CONFIG_MTD_NAND_NFC_GANG_SUPPORT
+		mtd->erasesize *= chip->num_devs;
+		mtd->writesize *= chip->num_devs;
+#endif
 
 		/*
 		 * Check for Spansion/AMD ID + repeating 5th, 6th byte since
diff --git a/drivers/mtd/nand/nand_bbt.c b/drivers/mtd/nand/nand_bbt.c
index c126469..2b4724c 100644
--- a/drivers/mtd/nand/nand_bbt.c
+++ b/drivers/mtd/nand/nand_bbt.c
@@ -447,6 +447,35 @@ static int scan_block_fast(struct mtd_info *mtd, struct nand_bbt_descr *bd,
 	}
 	return 0;
 }
+#ifdef CONFIG_MTD_NAND_NFC_MLC_SUPPORT
+/*
+ * Scan a given block in the custom location based on Naked symantics
+ */
+static int scan_block_custom(struct mtd_info *mtd, struct nand_bbt_descr *bd,
+			loff_t offs, uint8_t *buf, int page, int pos)
+{	
+	int ret;
+	struct mtd_oob_ops ops;
+
+	ops.mode = MTD_OOB_RAW;
+	ops.ooboffs = 0;
+	ops.ooblen = mtd->oobsize;
+	ops.oobbuf = (buf + mtd->writesize);
+	ops.datbuf = buf;
+	ops.len = mtd->writesize;
+
+	ret = mtd->read_oob(mtd, (offs + (mtd->writesize * page)), &ops);
+	if (ret)
+		return ret;
+
+	/* Check 2 bytes to cover the ganaged case */
+	if ((buf[pos] != 0xFF) || (buf[pos+1] != 0xFF))
+		return 1;
+
+	return 0;
+}
+#endif
+
 
 /**
  * create_bbt - [GENERIC] Create a bad block table by scanning the device
@@ -514,6 +543,13 @@ static int create_bbt(struct mtd_info *mtd, uint8_t *buf,
 		int ret;
 
 		BUG_ON(bd->options & NAND_BBT_NO_OOB);
+#ifdef CONFIG_MTD_NAND_NFC_MLC_SUPPORT
+
+		if (bd->options & NAND_BBT_SCANMVCUSTOM)
+			ret = scan_block_custom(mtd, bd, from, buf,
+						this->bb_page, this->bb_location);
+		else
+#endif
 
 		if (bd->options & NAND_BBT_SCANALLPAGES)
 			ret = scan_block_full(mtd, bd, from, buf, readlen,
diff --git a/drivers/mtd/nand/nand_ids.c b/drivers/mtd/nand/nand_ids.c
index af4fe8c..abdfdd6 100644
--- a/drivers/mtd/nand/nand_ids.c
+++ b/drivers/mtd/nand/nand_ids.c
@@ -107,6 +107,7 @@ struct nand_flash_dev nand_flash_ids[] = {
 	/* 8 Gigabit */
 	{"NAND 1GiB 1,8V 8-bit",	0xA3, 0, 1024, 0, LP_OPTIONS},
 	{"NAND 1GiB 3,3V 8-bit",	0xD3, 0, 1024, 0, LP_OPTIONS},
+	{"NAND 1GiB 3,3V 8-bit",	0x38, 4096, 1024, 524288, LP_OPTIONS},
 	{"NAND 1GiB 1,8V 16-bit",	0xB3, 0, 1024, 0, LP_OPTIONS16},
 	{"NAND 1GiB 3,3V 16-bit",	0xC3, 0, 1024, 0, LP_OPTIONS16},
 
@@ -115,6 +116,16 @@ struct nand_flash_dev nand_flash_ids[] = {
 	{"NAND 2GiB 3,3V 8-bit",	0xD5, 0, 2048, 0, LP_OPTIONS},
 	{"NAND 2GiB 1,8V 16-bit",	0xB5, 0, 2048, 0, LP_OPTIONS16},
 	{"NAND 2GiB 3,3V 16-bit",	0xC5, 0, 2048, 0, LP_OPTIONS16},
+#ifdef CONFIG_MTD_NAND_NFC_MLC_SUPPORT
+	/* 32 Gigabit - wrongly detected due to changes in READ_ID decoding */
+	{"NAND 4GiB 3,3V 8-bit",	0xD7, 4096, 4096, 524288, LP_OPTIONS},
+	/* 32 Gigabit - wrongly detected due to changes in READ_ID decoding */
+	{"NAND 8GiB 3,3V 8-bit",	0x88, 8192, 8192, 2097152, LP_OPTIONS},
+#else
+	/* 32 Gigabit */
+
+	{"NAND 4GiB 3,3V 8-bit",	0xD7, 0, 4096, 0, LP_OPTIONS},
+#endif
 
 	/* 32 Gigabit */
 	{"NAND 4GiB 1,8V 8-bit",	0xA7, 0, 4096, 0, LP_OPTIONS},
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index a6b8ce1..7ad029b 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -1,6 +1,8 @@
 #
 # Makefile for the Linux network device drivers.
 #
+obj-$(CONFIG_MV_ETH_LEGACY) += ../../arch/arm/plat-armada/mv_drivers_lsp/mv_network/mv_ethernet/
+obj-$(CONFIG_MV_ETH_NETA) += ../../arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/
 
 #
 # Networking Core Drivers
diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index fe282fb..6385fb2 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -979,7 +979,7 @@ config RTC_DRV_TX4939
 
 config RTC_DRV_MV
 	tristate "Marvell SoC RTC"
-	depends on ARCH_KIRKWOOD || ARCH_DOVE
+	depends on ARCH_KIRKWOOD || ARCH_DOVE || ARCH_ARMADA_XP
 	help
 	  If you say yes here you will get support for the in-chip RTC
 	  that can be found in some of Marvell's SoC devices, such as
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 987db27..e02458a 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -304,6 +304,11 @@ static void tdi_reset (struct ehci_hcd *ehci)
 	reg_ptr = (u32 __iomem *)(((u8 __iomem *)ehci->regs) + USBMODE);
 	tmp = ehci_readl(ehci, reg_ptr);
 	tmp |= USBMODE_CM_HC;
+	/*
+	 * MRVL: Disable USB Streaming
+	 */
+	tmp |= (1 << 4);
+
 	/* The default byte access to MMR space is LE after
 	 * controller reset. Set the required endian mode
 	 * for transfer buffers to match the host microprocessor
@@ -1310,6 +1315,11 @@ MODULE_LICENSE ("GPL");
 #define	PLATFORM_DRIVER		ehci_orion_driver
 #endif
 
+#ifdef CONFIG_PLAT_ARMADA
+#include "ehci_marvell.c"
+#define	PLATFORM_DRIVER		ehci_marvell_driver
+#endif
+
 #ifdef CONFIG_ARCH_IXP4XX
 #include "ehci-ixp4xx.c"
 #define	PLATFORM_DRIVER		ixp4xx_ehci_driver
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index e3b14b0..9326e26 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -31,6 +31,7 @@ obj-$(CONFIG_FB_DEFERRED_IO)   += fb_defio.o
 obj-$(CONFIG_FB_WMT_GE_ROPS)   += wmt_ge_rops.o
 
 # Hardware specific drivers go first
+obj-$(CONFIG_FB_DOVE)          += marvell/
 obj-$(CONFIG_FB_AMIGA)            += amifb.o c2p_planar.o
 obj-$(CONFIG_FB_ARC)              += arcfb.o
 obj-$(CONFIG_FB_CLPS711X)         += clps711xfb.o
diff --git a/drivers/video/backlight/Kconfig b/drivers/video/backlight/Kconfig
index 18d066b..fff1ccb 100644
--- a/drivers/video/backlight/Kconfig
+++ b/drivers/video/backlight/Kconfig
@@ -183,6 +183,14 @@ config BACKLIGHT_GENERIC
 	  Say y to enable the generic platform backlight driver previously
 	  known as the Corgi backlight driver. If you have a Sharp Zaurus
 	  SL-C7xx, SL-Cxx00 or SL-6000x say y.
+	  
+config BACKLIGHT_DOVE
+        tristate "Marvell Dove LCD/Backlight Driver"
+        depends on BACKLIGHT_CLASS_DEVICE && FB_DOVE_CLCD
+        select LCD_CLASS_DEVICE
+        default n
+        help
+          Say y to enable the Marvell Dove LCD/Backlight driver.
 
 config BACKLIGHT_LOCOMO
 	tristate "Sharp LOCOMO LCD/Backlight Driver"
diff --git a/drivers/video/backlight/Makefile b/drivers/video/backlight/Makefile
index 36855ae..c7f1477 100644
--- a/drivers/video/backlight/Makefile
+++ b/drivers/video/backlight/Makefile
@@ -17,6 +17,7 @@ obj-$(CONFIG_LCD_AMS369FG06)	+= ams369fg06.o
 
 obj-$(CONFIG_BACKLIGHT_CLASS_DEVICE) += backlight.o
 obj-$(CONFIG_BACKLIGHT_ATMEL_PWM)    += atmel-pwm-bl.o
+obj-$(CONFIG_BACKLIGHT_DOVE)    += dove_bl.o
 obj-$(CONFIG_BACKLIGHT_EP93XX)	+= ep93xx_bl.o
 obj-$(CONFIG_BACKLIGHT_GENERIC)	+= generic_bl.o
 obj-$(CONFIG_BACKLIGHT_HP700)	+= jornada720_bl.o
diff --git a/drivers/video/fb_ddc.c b/drivers/video/fb_ddc.c
index 2b106f0..e9e86c5 100644
--- a/drivers/video/fb_ddc.c
+++ b/drivers/video/fb_ddc.c
@@ -57,6 +57,15 @@ unsigned char *fb_ddc_read(struct i2c_adapter *adapter)
 	unsigned char *edid = NULL;
 	int i, j;
 
+	if (!algo_data) {
+		/* No direct control on I2C bus */
+		for (i = 0; i < 3; i++) {
+			edid = fb_do_probe_ddc_edid(adapter);
+			if (edid)
+				break;
+		}
+		return edid;
+	}
 	algo_data->setscl(algo_data->data, 1);
 
 	for (i = 0; i < 3; i++) {
diff --git a/fs/read_write.c b/fs/read_write.c
index f0a1865..5c97453 100644
--- a/fs/read_write.c
+++ b/fs/read_write.c
@@ -17,10 +17,15 @@
 #include <linux/splice.h>
 #include <trace/fs.h>
 #include "read_write.h"
-
+#include <linux/writeback.h> 
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
 
+#define WRITE_ARRAY_SIZE (WRITE_RECEIVE_SIZE/PAGE_SIZE +1)
+
+#ifdef COLLECT_WRITE_SOCK_TO_FILE_STAT
+struct write_sock_to_file_stat write_from_sock = {0};
+#endif /* COLLECT_WRITE_SOCK_TO_FILE_STAT */
 const struct file_operations generic_ro_fops = {
 	.llseek		= generic_file_llseek,
 	.read		= do_sync_read,
@@ -957,6 +962,9 @@ static ssize_t do_sendfile(int out_fd, int in_fd, loff_t *ppos,
 		max = min(in_inode->i_sb->s_maxbytes, out_inode->i_sb->s_maxbytes);
 
 	pos = *ppos;
+	retval = -EINVAL;
+	if (unlikely(pos < 0))
+		goto fput_out;
 	if (unlikely(pos + count > max)) {
 		retval = -EOVERFLOW;
 		if (pos >= max)
@@ -1030,3 +1038,165 @@ SYSCALL_DEFINE4(sendfile64, int, out_fd, int, in_fd, loff_t __user *, offset, si
 
 	return do_sendfile(out_fd, in_fd, NULL, count, 0);
 }
+
+static int start_write_procces(struct file *file, loff_t position, size_t buf_size)
+{
+	/*code from /fs/btrfs/file.c line 938 - 949 */
+	int ret_val = 0;
+	struct inode *inode=file->f_mapping->host;
+
+	/* lock mutex for inode */
+    	mutex_lock(&inode->i_mutex);
+
+	/* will not let the freeze-related IO syncing through inode->i_sb */
+	vfs_check_frozen(inode->i_sb, SB_FREEZE_WRITE);
+
+	/* set backing_dev_info of inode to current process */
+	current->backing_dev_info = file->f_mapping->backing_dev_info;
+
+	/* performs necessary checks before doing a write */
+	ret_val = generic_write_checks(file, &position, &buf_size, S_ISBLK(inode->i_mode));
+	if (ret_val) {
+		dprintk("Failed in call to generic_write_checks(), ret_val=%d\n", ret_val);
+		return -EFAULT;
+	}
+	if (buf_size == 0) {
+		dprintk("Zero buffer returned by generic_write_checks()\n");
+		return -EFAULT;
+	}
+
+	/* sets the TTR_FORCE flag and we are therefore able to
+	   remove the suid bits and continue */
+	ret_val = file_remove_suid(file);
+	if (ret_val) {
+		dprintk("Failed in call to file_remove_suid(), ret_val=%d\n", ret_val);
+		return -EFAULT;
+	}
+	/* update mtime and ctime time*/
+	file_update_time(file);
+
+ 	return 0;
+}
+
+static inline int release_resources(struct file *file, ssize_t err)
+{
+	mutex_unlock(&file->f_mapping->host->i_mutex);
+	current->backing_dev_info = NULL;
+	return err;
+}
+
+ssize_t write_from_socket_to_file(struct socket *sock,struct file *file, loff_t __user *ppos, size_t len)
+{
+	loff_t position;
+	long j, pages, err = 0;
+	struct msghdr message;
+	size_t ret, buf_size = len;
+	unsigned long shift;
+
+	struct curr_pages {
+		struct page *pagep;
+		loff_t pos;
+		size_t  size;
+		void *fsdata;
+	} curr_page[WRITE_ARRAY_SIZE];
+	struct kvec io_vector[WRITE_ARRAY_SIZE];
+
+	/* copy ppos to kernel space */
+	ret = copy_from_user(&position, ppos, sizeof(loff_t));
+    	if(ret) {
+			dprintk("Failed to copy position from user space, ret=%d\n", ret);
+			INC_WRITE_FROM_SOCK_ERR_CNT;
+        	return -EFAULT;
+	}
+
+	/* init write process */
+	ret = start_write_procces(file, position, len);
+	if(ret < 0) {
+		dprintk("Failed in call to start_write_procces(), ret=%d\n", ret);
+		INC_WRITE_FROM_SOCK_ERR_CNT;
+		return release_resources(file, ret);
+	}
+
+	/* Initialization all pages and IOV (input/output vector) */
+	for(pages = 0, j = buf_size; j > 0; pages++, j -= buf_size) {
+		shift = position & (PAGE_CACHE_SIZE - 1);
+		buf_size = PAGE_CACHE_SIZE - shift;
+		buf_size = ((long)buf_size > j) ? j : buf_size;
+
+		curr_page[pages].pos = position;
+		curr_page[pages].size = buf_size;
+		io_vector[pages].iov_len = buf_size;
+		/* code write_begin/write_end from /fs/ext4/move_extent.c line 858, 910 */
+		/* uses write_begin/write_end  to write data into the address_space structure (file->f_mapping) */
+        ret =  file->f_mapping->a_ops->write_begin(file, file->f_mapping,
+				 position, buf_size, AOP_FLAG_UNINTERRUPTIBLE,
+				 &curr_page[pages].pagep, &curr_page[pages].fsdata);
+        if (unlikely(ret)) {
+			dprintk("Failed in call to write_begin() on page %d, ret=%d\n", pages, ret);
+			err = ret;
+			goto unmup_pages;
+		}
+
+		/* set kernel virtual addresses + offset for the page */
+		io_vector[pages].iov_base = kmap(curr_page[pages].pagep) + shift;
+		position = position + curr_page[pages].size;
+    }
+
+ 	/* code from drivers/staging/dst/state.c line 89 - 98 */
+   	message.msg_iov = (struct iovec *)&io_vector;
+	message.msg_iovlen = pages;
+	message.msg_name = NULL;
+	message.msg_namelen = 0;
+	message.msg_control = NULL;
+	message.msg_controllen = 0;
+  
+	/* recive packet from soket to IOV */
+	ret = kernel_recvmsg(sock, &message, &io_vector[0], pages, len, MSG_WAITALL);
+	if(ret != len){
+		dprintk("Failed receive packet from socket to IOV, ret=%d\n", ret);
+		err = ret;
+	}
+
+#ifdef COLLECT_WRITE_SOCK_TO_FILE_STAT
+	if (len <= (1 << 12))
+		INC_WRITE_FROM_SOCK_4K_BUF_CNT;
+	else if (len <= (1 << 13))
+		INC_WRITE_FROM_SOCK_8K_BUF_CNT;
+	else if (len <= (1 << 14))
+		INC_WRITE_FROM_SOCK_16K_BUF_CNT;
+	else if (len <= (1 << 15))
+		INC_WRITE_FROM_SOCK_32K_BUF_CNT;
+	else if (len <= (1 << 16))
+		INC_WRITE_FROM_SOCK_64K_BUF_CNT;
+	else
+		INC_WRITE_FROM_SOCK_128K_BUF_CNT;
+#endif /* COLLECT_WRITE_SOCK_TO_FILE_STAT */
+
+unmup_pages:
+	/* free mappings created  with kmap previously and finish writing */
+	for(j = 0, buf_size = 0; j < pages;buf_size += curr_page[j].size, j++) {
+		kunmap(curr_page[j].pagep);
+		/* code write_begin/write_end from /fs/ext4/move_extent.c line 858, 910 */
+		ret = file->f_mapping->a_ops->write_end(file, file->f_mapping,
+					 curr_page[j].pos, curr_page[j].size, curr_page[j].size,
+					 curr_page[j].pagep, curr_page[j].fsdata);
+
+		if (unlikely(ret < 0)) {
+			dprintk("Failed in call to write_end() on page %d, ret=%d\n", j, ret);
+			INC_WRITE_FROM_SOCK_ERR_CNT;
+			err = ret;
+		}
+	}
+
+	if(!err) {
+		/* example balance_dirty_pages_ratelimited_nr from /fs/btrfs/relocation.c  line 2624 from mainline */
+		/* check the system's dirty state and will initiate writeback if needed */
+		balance_dirty_pages_ratelimited_nr(file->f_mapping, pages);
+
+		/* copy ppos to user space */
+		copy_to_user(ppos, &position, sizeof(loff_t));
+		err = buf_size;
+	}
+
+	return release_resources(file, err);
+}
diff --git a/fs/read_write.h b/fs/read_write.h
index d07b954..3cd1b1e 100644
--- a/fs/read_write.h
+++ b/fs/read_write.h
@@ -3,6 +3,41 @@
  * Don't use anywhere else.
  */
 
+#ifndef _READ_WRITE_H_
+#define _READ_WRITE_H_
+
+#include <net/sock.h>
+
+#define WRITE_RECEIVE_SIZE 131072
+
+#ifdef COLLECT_WRITE_SOCK_TO_FILE_STAT
+struct write_sock_to_file_stat {
+	unsigned long errors;
+	unsigned long buf_4k;
+	unsigned long buf_8k;
+	unsigned long buf_16k;
+	unsigned long buf_32k;
+	unsigned long buf_64k;
+	unsigned long buf_128k;
+};
+#define INC_WRITE_FROM_SOCK_ERR_CNT	(write_from_sock.errors++)
+#define INC_WRITE_FROM_SOCK_4K_BUF_CNT	(write_from_sock.buf_4k++)
+#define INC_WRITE_FROM_SOCK_8K_BUF_CNT	(write_from_sock.buf_8k++)
+#define INC_WRITE_FROM_SOCK_16K_BUF_CNT	(write_from_sock.buf_16k++)
+#define INC_WRITE_FROM_SOCK_32K_BUF_CNT	(write_from_sock.buf_32k++)
+#define INC_WRITE_FROM_SOCK_64K_BUF_CNT	(write_from_sock.buf_64k++)
+#define INC_WRITE_FROM_SOCK_128K_BUF_CNT	(write_from_sock.buf_128k++)
+#else /* COLLECT_WRITE_SOCK_TO_FILE_STAT */
+#define INC_WRITE_FROM_SOCK_ERR_CNT
+#endif /* COLLECT_WRITE_SOCK_TO_FILE_STAT */
+
+
+#ifdef DEBUG
+#define dprintk(fmt, args...) printk(KERN_ERR "%s: " fmt, __func__, ##args)
+#else
+#define dprintk(fmt, args...)
+#endif
+
 
 typedef ssize_t (*io_fn_t)(struct file *, char __user *, size_t, loff_t *);
 typedef ssize_t (*iov_fn_t)(struct kiocb *, const struct iovec *,
@@ -12,3 +47,8 @@ ssize_t do_sync_readv_writev(struct file *filp, const struct iovec *iov,
 		unsigned long nr_segs, size_t len, loff_t *ppos, iov_fn_t fn);
 ssize_t do_loop_readv_writev(struct file *filp, struct iovec *iov,
 		unsigned long nr_segs, loff_t *ppos, io_fn_t fn);
+ssize_t write_from_socket_to_file(struct socket *sock, struct file *file,
+		loff_t __user *ppos, size_t len);
+
+#endif /* _READ_WRITE_H_ */
+
diff --git a/fs/splice.c b/fs/splice.c
index 43e0486..190e322 100644
--- a/fs/splice.c
+++ b/fs/splice.c
@@ -31,6 +31,15 @@
 #include <linux/security.h>
 #include <linux/gfp.h>
 #include <linux/socket.h>
+#include <net/sock.h>
+#include "read_write.h"
+
+#define WRITE_SKT_TO_FILE
+#define WRITE_FROM_SOCK_TIMEOUT  8000
+
+#ifdef COLLECT_WRITE_SOCK_TO_FILE_STAT
+extern struct write_sock_to_file_stat write_from_sock;
+#endif /* COLLECT_WRITE_SOCK_TO_FILE_STAT */
 
 /*
  * Attempt to steal a page from a pipe buffer. This should perhaps go into
@@ -1693,32 +1702,69 @@ SYSCALL_DEFINE6(splice, int, fd_in, loff_t __user *, off_in,
 		int, fd_out, loff_t __user *, off_out,
 		size_t, len, unsigned int, flags)
 {
-	long error;
-	struct file *in, *out;
+	
+	long error, timeout;
+	struct file *in, *out = NULL;
+	struct socket *socket_struct = NULL;
 	int fput_in, fput_out;
-
 	if (unlikely(!len))
 		return 0;
 
 	error = -EBADF;
-	in = fget_light(fd_in, &fput_in);
-	if (in) {
-		if (in->f_mode & FMODE_READ) {
-			out = fget_light(fd_out, &fput_out);
-			if (out) {
-				if (out->f_mode & FMODE_WRITE)
-					error = do_splice(in, off_in,
-							  out, off_out,
-							  len, flags);
-				fput_light(out, fput_out);
-			}
-		}
 
-		fput_light(in, fput_in);
+	/* get file structure of "out" and check return result */
+	out = fget_light(fd_out, &fput_out);
+	if (out) {
+		if (!(out->f_mode & FMODE_WRITE)) {
+			fput_light(out, fput_out);
+			dprintk("FMODE_WRITE flag is not set in out->f_mode\n");
+			INC_WRITE_FROM_SOCK_ERR_CNT;
+			return error;
+		}
+	} else {
+		dprintk("Failed to get \"out\" file structire\n");
+		INC_WRITE_FROM_SOCK_ERR_CNT;
+		return error;
 	}
 
+#ifdef WRITE_SKT_TO_FILE
+    /* check fd_in is socket fd */
+
+	socket_struct = sockfd_lookup(fd_in, (int*)&error);
+	/* if fd_in is socket do do_splice_from_socket_to_file else do_splice */
+	if (socket_struct) {
+		/* check size of len argument and socket */
+		if(len > WRITE_RECEIVE_SIZE || !socket_struct->sk) {
+			if (socket_struct->sk != 0)
+				dprintk("Bad length (%d)\n", len);
+			else
+				dprintk("Bad socket (socket_struct->sk == 0)\n");
+			INC_WRITE_FROM_SOCK_ERR_CNT;
+        	error = -EINVAL;
+		} else {
+			timeout = socket_struct->sk->sk_rcvtimeo;
+			/* code from /net/tipc/socket.c line 61, 241 */
+			socket_struct->sk->sk_rcvtimeo = msecs_to_jiffies(WRITE_FROM_SOCK_TIMEOUT);
+			error = write_from_socket_to_file(socket_struct, out, off_out, len);
+			socket_struct->sk->sk_rcvtimeo = timeout;
+		} 
+		fput(socket_struct->file);
+	} else {
+#endif
+		in = fget_light(fd_in, &fput_in);
+		if (in) {
+			if (in->f_mode & FMODE_READ) {
+				error = do_splice(in, off_in, out, off_out, len, flags);
+			}
+			fput_light(in, fput_in);
+		}
+#ifdef WRITE_SKT_TO_FILE
+	}
+#endif
+	fput_light(out, fput_out);
 	return error;
-}
+	
+	}
 
 /*
  * Make sure there's data to read. Wait for input if we can, otherwise
diff --git a/include/linux/miscdevice.h b/include/linux/miscdevice.h
index dd2eb69..cb3d810 100644
--- a/include/linux/miscdevice.h
+++ b/include/linux/miscdevice.h
@@ -19,7 +19,11 @@
 #define APOLLO_MOUSE_MINOR	7
 #define PC110PAD_MINOR		9
 /*#define ADB_MOUSE_MINOR	10	FIXME OBSOLETE */
-#define CRYPTODEV_MINOR		70	/* /dev/crypto */
+#define CRYPTODEV_MINOR         70      /* OCF async crypto */
+#define CESADEV_MINOR		71	/* marvell CESA     */
+#define BTNSDEV_MINOR  		72	/* Marvell btns */
+#define SLICDEV_MINOR		73	/* Marvell SLIC control device */
+#define TDMDEV_MINOR		74	/* Marvell TDM test device */
 #define WATCHDOG_MINOR		130	/* Watchdog timer     */
 #define TEMP_MINOR		131	/* Temperature Sensor */
 #define RTC_MINOR		135
diff --git a/include/linux/mtd/bbm.h b/include/linux/mtd/bbm.h
index 650ef35..2e9e958 100644
--- a/include/linux/mtd/bbm.h
+++ b/include/linux/mtd/bbm.h
@@ -125,6 +125,10 @@ struct nand_bbt_descr {
  */
 #define NAND_BBT_DYNAMICSTRUCT	0x80000000
 
+#ifdef CONFIG_MTD_NAND_NFC_MLC_SUPPORT
+/* Search the bad block indicators according to Marvell's Naked symantics */
+#define NAND_BBT_SCANMVCUSTOM	0x10000000
+#endif
 /* The maximum number of blocks to scan for a bbt */
 #define NAND_BBT_SCAN_MAXBLOCKS	4
 
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index 3a7b87e..bea039c 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -434,6 +434,10 @@ struct sk_buff {
 	__be16			protocol;
 
 	void			(*destructor)(struct sk_buff *skb);
+#ifdef CONFIG_NET_SKB_RECYCLE
+	int				(*skb_recycle) (struct sk_buff *skb);
+	void			*hw_cookie;
+#endif /* CONFIG_NET_SKB_RECYCLE */
 #if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)
 	struct nf_conntrack	*nfct;
 #endif
@@ -2577,7 +2581,7 @@ static inline bool skb_is_recycleable(const struct sk_buff *skb, int skb_size)
 	if (skb_end_pointer(skb) - skb->head < skb_size)
 		return false;
 
-	if (skb_shared(skb) || skb_cloned(skb))
+	if (skb_shared(skb) || skb_cloned(skb)|| skb_has_frag_list(skb))
 		return false;
 
 	return true;
diff --git a/include/mtd/mtd-abi.h b/include/mtd/mtd-abi.h
index 36eace0..8946335 100644
--- a/include/mtd/mtd-abi.h
+++ b/include/mtd/mtd-abi.h
@@ -231,7 +231,11 @@ struct nand_oobfree {
  */
 struct nand_ecclayout_user {
 	__u32 eccbytes;
+#ifdef CONFIG_MTD_NAND_NFC
+	__u32 eccpos[128];
+#else
 	__u32 eccpos[MTD_MAX_ECCPOS_ENTRIES];
+#endif
 	__u32 oobavail;
 	struct nand_oobfree oobfree[MTD_MAX_OOBFREE_ENTRIES];
 };
diff --git a/kernel/stop_machine.c b/kernel/stop_machine.c
index 2f194e9..ea067d0 100644
--- a/kernel/stop_machine.c
+++ b/kernel/stop_machine.c
@@ -18,6 +18,9 @@
 #include <linux/stop_machine.h>
 #include <linux/interrupt.h>
 #include <linux/kallsyms.h>
+#ifdef CONFIG_SHEEVA_ERRATA_ARM_CPU_ADD_DELAY_FOR_STOP_MACHINE
+#include <linux/delay.h>
+#endif
 
 #include <linux/atomic.h>
 
@@ -458,6 +461,9 @@ static int stop_machine_cpu_stop(void *data)
 
 	/* Simple state machine */
 	do {
+#ifdef CONFIG_SHEEVA_ERRATA_ARM_CPU_ADD_DELAY_FOR_STOP_MACHINE
+		udelay(cpu);
+#endif
 		/* Chill out and ensure we re-read stopmachine_state. */
 		cpu_relax();
 		if (smdata->state != curstate) {
diff --git a/kernel/time/tick-sched.c b/kernel/time/tick-sched.c
index 2ee1525..56637da 100644
--- a/kernel/time/tick-sched.c
+++ b/kernel/time/tick-sched.c
@@ -294,6 +294,7 @@ static void tick_nohz_stop_sched_tick(struct tick_sched *ts)
 	if (unlikely(!cpu_online(cpu))) {
 		if (cpu == tick_do_timer_cpu)
 			tick_do_timer_cpu = TICK_DO_TIMER_NONE;
+			goto end;
 	}
 
 	if (unlikely(ts->nohz_mode == NOHZ_MODE_INACTIVE))
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index f0f383b..902ddc7 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -379,7 +379,7 @@ static void skb_clone_fraglist(struct sk_buff *skb)
 		skb_get(list);
 }
 
-static void skb_release_data(struct sk_buff *skb)
+static inline void skb_release_data(struct sk_buff *skb)
 {
 	if (!skb->cloned ||
 	    !atomic_sub_return(skb->nohdr ? (1 << SKB_DATAREF_SHIFT) + 1 : 1,
@@ -407,12 +407,20 @@ static void skb_release_data(struct sk_buff *skb)
 
 		kfree(skb->head);
 	}
+#ifdef CONFIG_NET_SKB_RECYCLE
+	/* Workaround for the cases when recycle callback was not called */
+	if (skb->hw_cookie) {
+		kfree(skb->hw_cookie);
+		skb->hw_cookie = NULL;
+	}
+	skb->skb_recycle = NULL;
+#endif /* CONFIG_NET_SKB_RECYCLE */	
 }
 
 /*
  *	Free an skbuff by memory without cleaning the state.
  */
-static void kfree_skbmem(struct sk_buff *skb)
+static inline void kfree_skbmem(struct sk_buff *skb)
 {
 	struct sk_buff *other;
 	atomic_t *fclone_ref;
@@ -443,7 +451,7 @@ static void kfree_skbmem(struct sk_buff *skb)
 	}
 }
 
-static void skb_release_head_state(struct sk_buff *skb)
+static inline void skb_release_head_state(struct sk_buff *skb)
 {
 	skb_dst_drop(skb);
 #ifdef CONFIG_XFRM
@@ -472,7 +480,7 @@ static void skb_release_head_state(struct sk_buff *skb)
 }
 
 /* Free everything but the sk_buff shell. */
-static void skb_release_all(struct sk_buff *skb)
+static inline void skb_release_all(struct sk_buff *skb)
 {
 	skb_release_head_state(skb);
 	skb_release_data(skb);
@@ -489,6 +497,11 @@ static void skb_release_all(struct sk_buff *skb)
 
 void __kfree_skb(struct sk_buff *skb)
 {
+#ifdef CONFIG_NET_SKB_RECYCLE
+	if (skb->skb_recycle && !skb->skb_recycle(skb))
+		return;
+#endif /* CONFIG_NET_SKB_RECYCLE */
+ 
 	skb_release_all(skb);
 	kfree_skbmem(skb);
 }
@@ -644,6 +657,12 @@ static struct sk_buff *__skb_clone(struct sk_buff *n, struct sk_buff *skb)
 	n->cloned = 1;
 	n->nohdr = 0;
 	n->destructor = NULL;
+
+#ifdef CONFIG_NET_SKB_RECYCLE
+	n->skb_recycle = NULL;
+	n->hw_cookie = NULL;
+#endif /* CONFIG_NET_SKB_RECYCLE */
+
 	C(tail);
 	C(end);
 	C(head);
-- 
1.7.5.4

