From f9a6f65bec3d1f4abeaf8548efc98a7aecad9eb4 Mon Sep 17 00:00:00 2001
From: Dmitri Epshtein <dima@marvell.com>
Date: Thu, 8 May 2014 17:58:10 -0400
Subject: [PATCH 1649/1825] fix: mux: Add support for MCAST MACs filtering

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 044bcf5a6886dec2dde4d6bbff11c2a9cc744db9

	- Fix bug in rx_bytes counter calculation
	- Add support for Multicast MACs filtering
		- Add pointer to all_mcast_del function to struct mv_mux_switch_ops
		- Implement mv_mux_set_rx_mode
		- Remove function mv_mux_change_rx_flags

Change-Id: I275937a663dda7c77523e46bd8b5fcb17775cb42
Signed-off-by: Dmitri Epshtein <dima@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/7897
Reviewed-by: Uri Eliyahu <uriel@marvell.com>
Tested-by: Yehuda Yitschak <yehuday@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../mv_drivers_lsp/mv_mux/mv_mux_netdev.c          |   74 +++++++++++++-------
 .../mv_drivers_lsp/mv_mux/mv_mux_netdev.h          |    3 +-
 2 files changed, 50 insertions(+), 27 deletions(-)

diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.c
index eb4e66b..251f441 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.c
@@ -294,7 +294,6 @@ static inline int mv_mux_get_tag_size(MV_TAG_TYPE type)
 /*-----------------------------------------------------------------------------------------*/
 
 int mv_mux_rx(struct sk_buff *skb, int port, struct napi_struct *napi)
-
 {
 	struct net_device *mux_dev;
 	int    len;
@@ -311,14 +310,13 @@ int mv_mux_rx(struct sk_buff *skb, int port, struct napi_struct *napi)
 	/* remove tag*/
 	len = mv_mux_rx_tag_remove(mux_dev, skb);
 	mux_dev->stats.rx_packets++;
-	mux_dev->stats.rx_bytes += skb->len - len;
-
+	mux_dev->stats.rx_bytes += skb->len;
 
 #ifdef CONFIG_MV_ETH_DEBUG_CODE
 	if (mux_eth_shadow[port].flags & MV_MUX_F_DBG_RX) {
 		struct mux_netdev *pmux_priv = MV_MUX_PRIV(mux_dev);
-		pr_err("\n%s - %s: port=%d, cpu=%d\n",
-			mux_dev->name, __func__, pmux_priv->port, smp_processor_id());
+		pr_err("\n%s - %s: port=%d, cpu=%d, pkt_size=%d, shift=%d\n",
+			mux_dev->name, __func__, pmux_priv->port, smp_processor_id(), skb->len, len);
 		/* mv_eth_skb_print(skb); */
 		mvDebugMemDump(skb->data, 64, 1);
 	}
@@ -410,32 +408,62 @@ char *mv_mux_get_mac(struct net_device *mux_dev)
 }
 /*-----------------------------------------------------------------------------------------*/
 
-static void mv_mux_set_rx_mode(struct net_device *dev)
+static void mv_mux_set_rx_mode(struct net_device *mux_dev)
 {
-/*
-	printk(KERN_ERR "Invalid operation %s is virtual interface.\n", dev->name);
-*/
-}
+	struct mux_netdev *pmux_priv = MV_MUX_PRIV(mux_dev);
 
-/*-----------------------------------------------------------------------------------------*/
+	if (!mv_mux_internal_switch(pmux_priv->port) || (switch_ops == NULL))
+		return;
 
-void mv_mux_change_rx_flags(struct net_device *mux_dev, int flags)
-{
-	struct mux_netdev *pmux_priv = MV_MUX_PRIV(mux_dev);
+	if (switch_ops->promisc_set)
+		if (switch_ops->promisc_set(pmux_priv->idx, (mux_dev->flags & IFF_PROMISC) ? 1 : 0))
+			pr_err("%s: Set promiscuous mode failed\n", mux_dev->name);
 
-	if (mv_mux_internal_switch(pmux_priv->port))
-		if (switch_ops && switch_ops->promisc_set)
-			switch_ops->promisc_set(pmux_priv->idx, (mux_dev->flags & IFF_PROMISC) ? 1 : 0);
-}
+	/* IFF_ALLMULTI is not supported by switch */
 
+	/* remove all mcast enries */
+	 if (switch_ops->all_mcast_del)
+		if (switch_ops->all_mcast_del(pmux_priv->idx))
+			pr_err("%s: Delete all Mcast failed\n", mux_dev->name);
+
+	if (mux_dev->flags & IFF_MULTICAST) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34)
+		if (!netdev_mc_empty(mux_dev)) {
+			struct netdev_hw_addr *ha;
+
+			netdev_for_each_mc_addr(ha, mux_dev) {
+				if (switch_ops->mac_addr_set) {
+					if (switch_ops->mac_addr_set(pmux_priv->idx, ha->addr, 1)) {
+						pr_err("%s: Mcast init failed\n", mux_dev->name);
+						break;
+					}
+				}
+			}
+		}
+#else
+		struct dev_mc_list *curr_addr = mux_dev->mc_list;
+		int                i;
+		for (i = 0; i < mux_dev->mc_count; i++, curr_addr = curr_addr->next) {
+			if (!curr_addr)
+				break;
+			if (switch_ops->mac_addr_set) {
+				if (switch_ops->mac_addr_set(pmux_priv->idx, curr_addr->dmi_addr, 1)) {
+					pr_err("%s: Mcast init failed\n", mux_dev->name);
+					break;
+				}
+			}
+		}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34) */
+	}
+}
 /*-----------------------------------------------------------------------------------------*/
+
 static int mv_mux_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 {
 	/*TODO compleate implementation*/
 	printk(KERN_ERR "Not supported yet.\n");
 	return 0;
 }
-
 /*-----------------------------------------------------------------------------------------*/
 
 static void mv_mux_switch_mtu_update(int mtu)
@@ -472,8 +500,8 @@ int mv_mux_close(struct net_device *dev)
 
 	return MV_OK;
 }
-
 /*-----------------------------------------------------------------------------------------*/
+
 int mv_mux_open(struct net_device *dev)
 {
 	struct mux_netdev *pmux_priv = MV_MUX_PRIV(dev);
@@ -505,7 +533,6 @@ int mv_mux_open(struct net_device *dev)
 	return MV_OK;
 
 }
-
 /*-----------------------------------------------------------------------------------------*/
 
 static int mv_mux_set_mac(struct net_device *mux_dev, void *addr)
@@ -536,7 +563,6 @@ static int mv_mux_set_mac(struct net_device *mux_dev, void *addr)
 
 	return 0;
 }
-
 /*-----------------------------------------------------------------------------------------*/
 
 int mv_mux_mtu_change(struct net_device *mux_dev, int mtu)
@@ -1150,7 +1176,6 @@ static inline struct net_device *mv_mux_rx_netdev_get(int port, struct sk_buff *
 	MV_U8 *data = skb->data;
 	int tag_type = mux_eth_shadow[port].tag_type;
 
-
 	/* skb->data point to MH */
 	switch (tag_type) {
 
@@ -1401,11 +1426,9 @@ static inline int mv_mux_tx_skb_tag_add(struct net_device *dev, struct sk_buff *
 
 void mv_mux_netdev_print(struct net_device *mux_dev)
 {
-
 	struct mux_netdev *pdev;
 	int tag_type;
 
-
 	if (!mux_dev) {
 		printk(KERN_ERR "%s:device in NULL.\n", __func__);
 		return;
@@ -1504,7 +1527,6 @@ static const struct net_device_ops mv_mux_netdev_ops = {
 	.ndo_set_mac_address	= mv_mux_set_mac,
 	.ndo_do_ioctl		= mv_mux_ioctl,
 	.ndo_set_rx_mode	= mv_mux_set_rx_mode,
-	.ndo_change_rx_flags	= mv_mux_change_rx_flags,
 	.ndo_change_mtu		= mv_mux_mtu_change,
 };
 /*-----------------------------------------------------------------------------------------*/
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.h
index 41a98b3..17dbd07 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.h
@@ -99,6 +99,7 @@ struct mv_mux_switch_ops {
 	int	(*group_disable)(int db);
 	int	(*group_enable)(int db);
 	int	(*link_status_get)(int db);
+	int     (*all_mcast_del)(int db);
 	int	(*mac_addr_set)(int db, unsigned char *mac_addr, unsigned char op);
 	int	(*group_cookie_set)(int db, void *cookie);
 	bool	(*tag_get)(int db, MV_TAG_TYPE tag_mode, MV_SWITCH_PRESET_TYPE preset, int vid, MV_MUX_TAG *tag);
@@ -128,7 +129,7 @@ void mv_mux_eth_attach(int port, struct net_device *root, struct mv_mux_eth_ops
 void mv_mux_switch_attach(int gbe_port, int preset, int vid, int tag, int switch_port);
 void mv_mux_eth_detach(int port);
 int mv_mux_switch_ops_set(const struct mv_mux_switch_ops *switch_ops_ptr);
-
+int mv_mux_netdev_find(unsigned int dev_idx);
 
 
 #endif /* __mv_tag_netdev_h__ */
-- 
1.7.5.4

