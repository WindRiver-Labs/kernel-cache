From 212f78bd94a84c3d39ff593d6a5d532135d65a07 Mon Sep 17 00:00:00 2001
From: Yoni Farhadian <yonif@marvell.com>
Date: Wed, 17 Jul 2013 15:31:31 +0300
Subject: [PATCH 0844/1825] PPv2: driver cleanup sequence

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 1ed4622a59e2bdb0e61ad41fb5b5a0816b6147d5

	add cleanup functions for txq/rxq/ports/pools

Change-Id: Ie01bbc75b05d4a328c2ae8373d766265e1cadc5b
Signed-off-by: Yoni Farhadian <yonif@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/2708
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Reviewed-by: Nadav Haklai <nadavh@marvell.com>
Tested-by: Nadav Haklai <nadavh@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../mv_drivers_lsp/mv_mux/mv_mux_netdev.c          |   29 ++-
 .../mv_drivers_lsp/mv_mux/mv_mux_netdev.h          |    1 +
 .../arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile |    2 +-
 .../mv_pp2/net_dev/mv_eth_dbg_sysfs.c              |  106 +++++++
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c   |   18 +-
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.h   |    4 +
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c      |  317 ++++++++++++++------
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h      |    4 +
 arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.c     |   94 +++++-
 arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.h     |    8 +-
 10 files changed, 464 insertions(+), 119 deletions(-)
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_dbg_sysfs.c

diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.c
index 673c9d9..414450b 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.c
@@ -142,6 +142,11 @@ static int mv_mux_mgr_probe(int gbe_port)
 
 void mv_mux_switch_attach(int gbe_port, int preset, int vid, int tag, int switch_port)
 {
+
+	/* allready attach */
+	if (mux_switch_shadow.attach)
+		return;
+
 	mux_switch_shadow.tag_type = tag;
 	mux_switch_shadow.preset = preset;
 	mux_switch_shadow.vid = vid;
@@ -163,6 +168,10 @@ void mv_mux_switch_attach(int gbe_port, int preset, int vid, int tag, int switch
 
 void mv_mux_eth_attach(int port, struct net_device *root, struct mv_mux_eth_ops *ops)
 {
+	/* allready attach */
+	if (mux_eth_shadow[port].root)
+		return;
+
 	/* update root device in shadow */
 	mux_eth_shadow[port].root = root;
 
@@ -174,6 +183,24 @@ void mv_mux_eth_attach(int port, struct net_device *root, struct mv_mux_eth_ops
 		mv_mux_mgr_probe(port);
 }
 
+void mv_mux_eth_detach(int port)
+{
+	struct net_device *mux_dev;
+
+	/* allready deattach */
+	if (mux_eth_shadow[port].root == NULL)
+		return;
+
+	/* delete all attached mux devices */
+	mux_dev = mux_eth_shadow[port].switch_dev;
+	while (mux_dev) {
+		mv_mux_netdev_delete(mux_dev);
+		mux_dev = mux_eth_shadow[port].switch_dev;
+	}
+
+	/* clear port data */
+	memset(&mux_eth_shadow[port], 0, sizeof(struct mv_mux_eth_port));
+}
 /*-----------------------------------------------------------------------------------------*/
 
 int mv_mux_netdev_find(unsigned int dev_idx)
@@ -1258,7 +1285,7 @@ void mv_mux_netdev_print(struct net_device *mux_dev)
 		break;
 
 	case MV_TAG_TYPE_MH:
-		printk(KERN_ERR "%s: port=%d, pdev=%p: tx_mh=0x%04x, rx_mh=0x%04x, rx_mh=0x%04x\n",
+		printk(KERN_ERR "%s: port=%d, pdev=%p: tx_mh=0x%04x, rx_mh=0x%04x, rx_mask=0x%04x\n",
 			mux_dev->name, pdev->port, pdev, pdev->tx_tag.mh, pdev->rx_tag_ptrn.mh, pdev->rx_tag_mask.mh);
 		break;
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.h
index 5295839..71ca312 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.h
@@ -95,6 +95,7 @@ struct net_device *mv_mux_switch_ptr_get(int port);
 int mv_mux_ctrl_dbg_flag(int port, u32 flag, u32 val);
 void mv_mux_eth_attach(int port, struct net_device *root, struct mv_mux_eth_ops *ops);
 void mv_mux_switch_attach(int gbe_port, int preset, int vid, int tag, int switch_port);
+void mv_mux_eth_detach(int port);
 
 
 #endif /* __mv_tag_netdev_h__ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile
index d9f49ae..2017c4a 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile
@@ -32,7 +32,7 @@ mv_pp2-objs +=  $(PP2_COMMON_DIR)/mvPp2Common.o
 mv_pp2-objs += net_dev/mv_netdev.o net_dev/mv_ethernet.o net_dev/mv_eth_sysfs.o net_dev/mv_eth_tool.o
 mv_pp2-objs += net_dev/mv_eth_rx_sysfs.o net_dev/mv_eth_tx_sysfs.o net_dev/mv_eth_tx_sched_sysfs.o
 mv_pp2-objs += net_dev/mv_eth_napi_sysfs.o net_dev/mv_eth_pme_sysfs.o net_dev/mv_eth_pon_sysfs.o
-mv_pp2-objs += net_dev/mv_eth_bm_sysfs.o net_dev/mv_eth_qos_sysfs.o
+mv_pp2-objs += net_dev/mv_eth_bm_sysfs.o net_dev/mv_eth_qos_sysfs.o net_dev/mv_eth_dbg_sysfs.o
 
 mv_pp2-objs += prs/prs_low_sysfs.o prs/prs_high_sysfs.o
 mv_pp2-objs += cls/cls_sysfs.o cls/cls2_sysfs.o cls/cls3_sysfs.o cls/cls4_sysfs.o cls/cls_mc_sysfs.o
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_dbg_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_dbg_sysfs.c
new file mode 100644
index 0000000..981053d
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_dbg_sysfs.c
@@ -0,0 +1,106 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/capability.h>
+#include <linux/platform_device.h>
+#include <linux/netdevice.h>
+
+#include "mv_netdev.h"
+#include "mv_eth_sysfs.h"
+
+
+static ssize_t mv_eth_dbg_help(char *buf)
+{
+	int off = 0;
+
+	off += sprintf(buf+off, "cat                clean         - Clean all ports\n");
+	off += sprintf(buf+off, "cat                init          - Clean and init all ports\n");
+
+	return off;
+}
+
+static ssize_t mv_eth_dbg_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	const char      *name = attr->attr.name;
+	int             off = 0;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	if (!strcmp(name, "clean"))
+		mv_eth_all_ports_cleanup();
+	else if (!strcmp(name, "init")) {
+		if (mv_eth_all_ports_cleanup() == 0)
+			/* probe only if all ports are clean */
+			mv_eth_all_ports_probe();
+	} else
+		off = mv_eth_dbg_help(buf);
+
+	return off;
+}
+
+
+
+static DEVICE_ATTR(help,	S_IRUSR, mv_eth_dbg_show, NULL);
+static DEVICE_ATTR(clean,	S_IRUSR, mv_eth_dbg_show, NULL);
+static DEVICE_ATTR(init,	S_IRUSR, mv_eth_dbg_show, NULL);
+
+
+static struct attribute *mv_eth_dbg_attrs[] = {
+	&dev_attr_clean.attr,
+	&dev_attr_init.attr,
+	&dev_attr_help.attr,
+	NULL
+};
+
+
+static struct attribute_group mv_eth_dbg_group = {
+	.name = "dbg",
+	.attrs = mv_eth_dbg_attrs,
+};
+
+int mv_pp2_dbg_sysfs_init(struct kobject *gbe_kobj)
+{
+	int err;
+
+	err = sysfs_create_group(gbe_kobj, &mv_eth_dbg_group);
+	if (err)
+		pr_err("sysfs group i%s failed %d\n", mv_eth_dbg_group.name, err);
+
+	return err;
+}
+
+int mv_pp2_dbg_sysfs_exit(struct kobject *gbe_kobj)
+{
+	sysfs_remove_group(gbe_kobj, &mv_eth_dbg_group);
+
+	return 0;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c
index 1480d96..71cb76c 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c
@@ -235,6 +235,8 @@ static ssize_t mv_eth_reg_store(struct device *dev,
 
 static DEVICE_ATTR(addrDec,	S_IRUSR, mv_eth_show, NULL);
 static DEVICE_ATTR(help,	S_IRUSR, mv_eth_show, NULL);
+
+
 #ifdef CONFIG_MV_ETH_DEBUG_CODE
 static DEVICE_ATTR(debug,	S_IWUSR, NULL, mv_eth_2_hex_store);
 #endif
@@ -243,6 +245,7 @@ static DEVICE_ATTR(dropCntrs,	S_IWUSR, NULL, mv_eth_port_store);
 static DEVICE_ATTR(stats,       S_IWUSR, NULL, mv_eth_port_store);
 static DEVICE_ATTR(pnc,		S_IWUSR, NULL, mv_eth_port_store);
 static DEVICE_ATTR(tag,		S_IWUSR, NULL, mv_eth_port_store);
+
 static DEVICE_ATTR(etypeDsaMod,	S_IWUSR, NULL, mv_eth_port_store);
 static DEVICE_ATTR(etypeDsa,	S_IWUSR, NULL, mv_eth_reg_store);
 
@@ -312,15 +315,12 @@ int mv_pp2_gbe_sysfs_exit(struct kobject *pp2_kobj)
 {
 	mv_pp2_gbe_pme_sysfs_exit(gbe_kobj);
 	mv_pp2_pon_sysfs_exit(gbe_kobj);
-	mv_pp2_qos_sysfs_init(gbe_kobj);
-	mv_pp2_tx_sched_sysfs_init(gbe_kobj);
-	mv_pp2_tx_sysfs_init(gbe_kobj);
-	mv_pp2_rx_sysfs_init(gbe_kobj);
-	mv_pp2_napi_sysfs_init(gbe_kobj);
-	mv_pp2_bm_sysfs_exit(pp2_kobj);
-
+	mv_pp2_qos_sysfs_exit(gbe_kobj);
+	mv_pp2_tx_sched_sysfs_exit(gbe_kobj);
+	mv_pp2_tx_sysfs_exit(gbe_kobj);
+	mv_pp2_rx_sysfs_exit(gbe_kobj);
+	mv_pp2_napi_sysfs_exit(gbe_kobj);
+	mv_pp2_bm_sysfs_exit(gbe_kobj);
 	sysfs_remove_group(pp2_kobj, &mv_eth_group);
-/*      remove_group_kobj_put(&pd->kobj, &mv_eth_group); */
-
 	return 0;
 }
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.h
index 870bf82..1a79560 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.h
@@ -86,4 +86,8 @@ int mv_pp2_pon_sysfs_exit(struct kobject *pp2_kobj);
 int mv_pp2_gbe_pme_sysfs_init(struct kobject *gbe_kobj);
 int mv_pp2_gbe_pme_sysfs_exit(struct kobject *gbe_kobj);
 
+
+int mv_pp2_dbg_sysfs_init(struct kobject *pp2_kobj);
+int mv_pp2_dbg_sysfs_exit(struct kobject *pp2_kobj);
+
 #endif /* __mv_eth_sysfs_h__ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
index 8dfda8e..d5efdd6 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
@@ -61,6 +61,14 @@ disclaimer.
 
 #define MV_ETH_TX_PENDING_TIMEOUT_MSEC     1000
 
+
+static struct  platform_device *pp2_sysfs;
+
+/*
+platform_device used in mv_eth_all_ports_probe only for debug
+*/
+struct platform_device *plats[MV_ETH_MAX_PORTS];
+
 static struct mv_mux_eth_ops mux_eth_ops;
 
 static inline int mv_eth_tx_policy(struct eth_port *pp, struct sk_buff *skb);
@@ -2490,12 +2498,11 @@ static int mv_eth_pool_destroy(int pool)
 
 	status = mvStackDelete(ppool->stack);
 
-/*	mvBmPoolDisable(pool);*/
 	mvBmPoolControl(pool, MV_STOP);
 
 	/* Note: we don't free the bm_pool here ! */
 	if (ppool->bm_pool)
-		mvOsFree(ppool->bm_pool);
+		mvOsIoUncachedFree(NULL, sizeof(MV_U32) * ppool->capacity, ppool->physAddr, ppool->bm_pool, 0);
 
 	memset(ppool, 0, sizeof(struct bm_pool));
 
@@ -2579,6 +2586,7 @@ void	*mv_eth_bm_pool_create(int pool, int capacity, MV_ULONG *pPhysAddr)
 	MV_STATUS status;
 
 	pVirt = mvOsIoUncachedMalloc(NULL, sizeof(MV_U32) * capacity, &physAddr, NULL);
+
 	if (pVirt == NULL) {
 		mvOsPrintf("%s: Can't allocate %d bytes for Long pool #%d\n",
 				__func__, MV_BM_POOL_CAP_MAX * sizeof(MV_U32), pool);
@@ -2610,6 +2618,7 @@ void	*mv_eth_bm_pool_create(int pool, int capacity, MV_ULONG *pPhysAddr)
 static MV_STATUS mv_eth_pool_create(int pool, int capacity)
 {
 	struct bm_pool *bm_pool;
+	MV_ULONG    physAddr;
 
 	if ((pool < 0) || (pool >= MV_ETH_BM_POOLS)) {
 		printk(KERN_ERR "%s: pool=%d is out of range\n", __func__, pool);
@@ -2619,7 +2628,7 @@ static MV_STATUS mv_eth_pool_create(int pool, int capacity)
 	bm_pool = &mv_eth_pool[pool];
 	memset(bm_pool, 0, sizeof(struct bm_pool));
 
-	bm_pool->bm_pool = mv_eth_bm_pool_create(pool, capacity, NULL);
+	bm_pool->bm_pool = mv_eth_bm_pool_create(pool, capacity, &physAddr /*NULL*/);
 	if (bm_pool->bm_pool == NULL)
 		return MV_FAIL;
 
@@ -2636,6 +2645,7 @@ static MV_STATUS mv_eth_pool_create(int pool, int capacity)
 	bm_pool->capacity = capacity;
 	bm_pool->pkt_size = 0;
 	bm_pool->buf_num = 0;
+	bm_pool->physAddr = physAddr;
 	spin_lock_init(&bm_pool->lock);
 
 	return MV_OK;
@@ -3105,6 +3115,7 @@ static int mv_eth_port_link_speed_fc(int port, MV_ETH_PORT_SPEED port_speed, int
 			printk(KERN_ERR "mvEthFlowCtrlSet failed\n");
 			return -EIO;
 		}
+
 	}
 
 	return 0;
@@ -3138,8 +3149,10 @@ static int mv_eth_load_network_interfaces(struct platform_device *pdev)
 	mv_eth_ports[port] = pp;
 
 	err = mv_eth_priv_init(pp, port);
-	if (err)
+	if (err) {
+		mv_eth_priv_cleanup(pp);
 		return err;
+	}
 
 	pp->cpuMask = plat_data->cpu_mask;
 
@@ -3169,8 +3182,10 @@ static int mv_eth_load_network_interfaces(struct platform_device *pdev)
 	if (!MV_PON_PORT(pp->port)) {
 		/* force link, speed and duplex if necessary based on board information */
 		err = mv_eth_port_link_speed_fc(pp->port, speed, force_link);
-		if (err)
+		if (err) {
+			mv_eth_priv_cleanup(pp);
 			return err;
+		}
 	}
 
 	pr_info("\t%s p=%d: phy=%d,  mtu=%d, mac="MV_MACQUAD_FMT", speed=%s %s\n",
@@ -3212,7 +3227,7 @@ static int mv_eth_load_network_interfaces(struct platform_device *pdev)
 
 	/* Call mv_eth_open specifically for ports not connected to Linux netdevice */
 	if (!(pp->flags & MV_ETH_F_CONNECT_LINUX))
-			mv_eth_open(pp->dev);
+		mv_eth_open(pp->dev);
 
 	mux_eth_ops.set_tag_type = mv_eth_tag_type_set;
 	mux_eth_ops.promisc_set = mv_eth_port_promisc_set;
@@ -3262,6 +3277,7 @@ void    mv_eth_hal_shared_init(struct mv_pp2_pdata *plat_data)
 	return;
 }
 
+
 /***********************************************************
  * mv_eth_win_init --                                      *
  *   Win initilization                                     *
@@ -3339,6 +3355,10 @@ static void mv_eth_sysfs_exit(void)
 	mv_pp2_prs_low_sysfs_exit(&pd->kobj);
 	mv_pp2_prs_high_sysfs_exit(&pd->kobj);
 	mv_pp2_gbe_sysfs_exit(&pd->kobj);
+	/* can't delete, we call to init/clean function from this sysfs */
+	/* TODO: open this line when we delete clean/init sysfs commands*/
+	/*mv_pp2_dbg_sysfs_exit(&pd->kobj);*/
+	platform_device_unregister(pp2_sysfs);
 }
 
 static int mv_eth_sysfs_init(void)
@@ -3347,7 +3367,7 @@ static int mv_eth_sysfs_init(void)
 
 	pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
 	if (!pd) {
-		platform_device_register_simple("pp2", -1, NULL, 0);
+		pp2_sysfs = platform_device_register_simple("pp2", -1, NULL, 0);
 		pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
 	}
 
@@ -3366,6 +3386,7 @@ static int mv_eth_sysfs_init(void)
 	mv_pp2_mc_sysfs_init(&pd->kobj);
 	mv_pp2_plcr_sysfs_init(&pd->kobj);
 	mv_pp2_pme_sysfs_init(&pd->kobj);
+	mv_pp2_dbg_sysfs_init(&pd->kobj);
 
 	return 0;
 }
@@ -3445,6 +3466,40 @@ oom:
 	return -ENOMEM;
 }
 
+static void mv_eth_shared_cleanup(void)
+{
+	int pool, cpu;
+
+	/*
+	There is no memory allocation in prser & classifier
+	cleanup functions are not necessary
+	*/
+
+	for (pool = 0; pool < MV_ETH_BM_POOLS; pool++)
+		mv_eth_pool_destroy(pool);
+
+#ifdef CONFIG_MV_ETH_HWF
+	/* Delete temporary TXQ (switching between HWF and SWF)*/
+	mvPp2TxqTempDelete();
+#endif
+	/* cleanup aggregated tx queues */
+	for_each_possible_cpu(cpu)
+		mvPp2AggrTxqDelete(cpu);
+
+	mvOsFree(aggr_txqs);
+
+	mvOsFree(mv_eth_ports);
+
+	/* Hal init by mv_eth_hal_shared_init*/
+	mvPp2HalDestroy();
+
+	/*mv_eth_win_cleanup();*/
+
+	mv_eth_sysfs_exit();
+
+	mv_eth_initialized = 0;
+}
+
 /***********************************************************
  * mv_eth_probe --                                         *
  *   main driver initialization. loading the interfaces.   *
@@ -3479,6 +3534,9 @@ static int mv_eth_probe(struct platform_device *pdev)
 	if (mv_eth_load_network_interfaces(pdev))
 		return -ENODEV;
 
+	/* used in mv_eth_all_ports_probe */
+	plats[pdev->id] = pdev;
+
 	printk(KERN_ERR "\n");
 
 	return 0;
@@ -3783,11 +3841,6 @@ static netdev_features_t mv_eth_netdev_fix_features(struct net_device *dev, netd
 }
 #endif
 
-void mv_eth_priv_cleanup(struct eth_port *pp)
-{
-	/* TODO */
-}
-
 static int mv_eth_rxq_fill(struct eth_port *pp, int rxq, int num)
 {
 	mvPp2RxqNonOccupDescAdd(pp->port, rxq, num);
@@ -4403,6 +4456,7 @@ int mv_eth_rxq_vlan_prio_set(int port, int rxq, unsigned char prio)
 static int mv_eth_priv_init(struct eth_port *pp, int port)
 {
 	static int first_rxq = 0;
+	static int first_rx_q[MV_ETH_MAX_PORTS];
 	int cpu, i;
 	struct cpu_ctrl	*cpuCtrl;
 	u8	*ext_buf;
@@ -4412,14 +4466,24 @@ static int mv_eth_priv_init(struct eth_port *pp, int port)
 		pp->cpu_config[i] = kmalloc(sizeof(struct cpu_ctrl), GFP_KERNEL);
 		memset(pp->cpu_config[i], 0, sizeof(struct cpu_ctrl));
 	}
+	/* init only once */
+	if (first_rxq == 0)
+		for (i = 0; i < MV_ETH_MAX_PORTS; i++)
+			first_rx_q[i] = -1;
 
 	pp->port = port;
-	pp->first_rxq = first_rxq;
 	pp->rxq_num = CONFIG_MV_ETH_RXQ;
-	first_rxq += pp->rxq_num;
 	pp->txp_num = 1;
 	pp->tx_spec.flags = 0;
 	pp->tx_spec.txp = 0;
+
+	if (first_rx_q[port] == -1) {
+		first_rx_q[port] = first_rxq;
+		first_rxq += pp->rxq_num;
+	}
+
+	pp->first_rxq = first_rx_q[port];
+
 	for_each_possible_cpu(cpu) {
 		cpuCtrl = pp->cpu_config[cpu];
 		cpuCtrl->txq = CONFIG_MV_ETH_TXQ_DEF;
@@ -4499,6 +4563,52 @@ static int mv_eth_priv_init(struct eth_port *pp, int port)
 	return 0;
 }
 
+/*
+free the memory that allocate by
+mv_eth_netdev_init
+mv_eth_priv_init
+mv_eth_hal_init
+*/
+static void mv_eth_priv_cleanup(struct eth_port *pp)
+{
+	int i, port;
+
+	if (!pp)
+		return;
+	port = pp->port;
+
+	mvOsFree(pp->rxq_ctrl);
+	pp->rxq_ctrl = NULL;
+
+
+	mvOsFree(pp->txq_ctrl);
+	pp->txq_ctrl = NULL;
+
+	mvPp2PortDestroy(pp->port);
+
+	for (i = 0; i < CONFIG_NR_CPUS; i++)
+		kfree(pp->cpu_config[i]);
+
+	/* delete pool of external buffers for TSO, fragmentation, etc */
+	if (mvStackDelete(pp->extArrStack))
+		printk(KERN_ERR "Error: failed delete extArrStack for port #%d\n", port);
+
+#ifdef CONFIG_MV_ETH_STAT_DIST
+	mvOsFree(pp->dist_stats.rx_dist);
+	mvOsFree(pp->dist_stats.tx_done_dist);
+	mvOsFree(pp->dist_stats.tx_tso_dist);
+#endif /* CONFIG_MV_ETH_STAT_DIST */
+
+	/* allocate by mv_eth_netdev_init */
+	/* free dev and pp*/
+	synchronize_net();
+	unregister_netdev(pp->dev);
+	free_netdev(pp->dev);
+	mv_eth_ports[port] = NULL;
+}
+
+
+
 /***********************************************************************************
  ***  print RX bm_pool status
  ***********************************************************************************/
@@ -4941,94 +5051,120 @@ void mv_eth_port_stats_print(unsigned int port)
 	}
 #endif /* CONFIG_MV_ETH_STAT_DIST */
 }
-
-
-static int mv_eth_port_cleanup(int port)
+/* mv_eth_tx_cleanup - reset and delete all tx queues */
+static void mv_eth_tx_cleanup(struct eth_port *pp)
 {
-	unsigned long flags = 0;
-	int txp, txq, rxq, i;
-	struct eth_port *pp;
+	int txp, txq;
 	struct tx_queue *txq_ctrl;
-	struct rx_queue *rxq_ctrl;
-
-	pp = mv_eth_port_by_id(port);
-
-	if (pp == NULL)
-		return -1;
 
-	if (pp->flags & MV_ETH_F_STARTED) {
-		printk(KERN_ERR "%s: port %d is started, cannot cleanup\n", __func__, port);
-		return -1;
-	}
+	if (!pp)
+		return;
 
 	/* Reset Tx ports */
 	for (txp = 0; txp < pp->txp_num; txp++) {
-		if (mv_eth_txp_clean(port, txp))
-			printk(KERN_ERR "Warning: Port %d Tx port %d reset failed\n", port, txp);
+		if (mv_eth_txp_clean(pp->port, txp))
+			printk(KERN_ERR "Warning: Port %d Tx port %d reset failed\n", pp->port, txp);
 	}
 
 	/* Delete Tx queues */
 	for (txp = 0; txp < pp->txp_num; txp++) {
 		for (txq = 0; txq < CONFIG_MV_ETH_TXQ; txq++) {
 			txq_ctrl = &pp->txq_ctrl[txp * CONFIG_MV_ETH_TXQ + txq];
-			mv_eth_txq_delete(pp, txq_ctrl);
+			if (txq_ctrl->q)
+				mv_eth_txq_delete(pp, txq_ctrl);
 		}
 	}
+}
 
-	mvOsFree(pp->txq_ctrl);
-	pp->txq_ctrl = NULL;
+/* mv_eth_rx_cleanup - reset and delete all rx queues */
+static void mv_eth_rx_cleanup(struct eth_port *pp)
+{
+	int rxq, prxq;
+	struct rx_queue *rxq_ctrl;
 
-#ifdef CONFIG_MV_ETH_STAT_DIST
-	/* Free Tx Done distribution statistics */
-	mvOsFree(pp->dist_stats.tx_done_dist);
-#endif
+	if (!pp)
+		return;
 
 	/* Reset RX ports */
-	if (mv_eth_rx_reset(port))
-		printk(KERN_ERR "Warning: Rx port %d reset failed\n", port);
+	if (mv_eth_rx_reset(pp->port))
+		printk(KERN_ERR "%s Warning: Rx port %d reset failed\n", __func__, pp->port);
 
 	/* Delete Rx queues */
+	/* TODO - delete rxq only if port was in up at least once */
 	for (rxq = 0; rxq < pp->rxq_num; rxq++) {
 		rxq_ctrl = &pp->rxq_ctrl[rxq];
-		mvPp2RxqDelete(pp->port, rxq);
+
+		/* port start called before*/
+		if (rxq_ctrl->q)
+			mvPp2RxqDelete(pp->port, rxq);
+
+		prxq = mvPp2LogicRxqToPhysRxq(pp->port, rxq);
+		mvPp2PhysRxqMapDel(prxq);
 		rxq_ctrl->q = NULL;
 	}
 
-	mvOsFree(pp->rxq_ctrl);
-	pp->rxq_ctrl = NULL;
+}
 
-#ifdef CONFIG_MV_ETH_STAT_DIST
-	/* Free Rx distribution statistics */
-	mvOsFree(pp->dist_stats.rx_dist);
-#endif
 
-	/* Free buffer pools */
-	if (pp->pool_long) {
-		pp->pool_long->port_map &= ~(1 << pp->port);
-		if (!pp->pool_long->port_map) {
-			MV_ETH_LOCK(&pp->pool_long->lock, flags);
-			mv_eth_pool_free(pp->pool_long->pool, pp->pool_long->buf_num);
-			pp->pool_long->type = MV_ETH_BM_FREE;
-			pp->pool_long->pkt_size = 0;
-
-			mvPp2BmPoolBufSizeSet(pp->pool_long->pool, 0);
-			MV_ETH_UNLOCK(&pp->pool_long->lock, flags);
-		}
-		pp->pool_long = NULL;
-	}
-	if (pp->pool_short) {
-		pp->pool_short->port_map &= ~(1 << pp->port);
-		if (!pp->pool_short->port_map) {
-			MV_ETH_LOCK(&pp->pool_short->lock, flags);
-			mv_eth_pool_free(pp->pool_short->pool, pp->pool_short->buf_num);
-			pp->pool_short->type = MV_ETH_BM_FREE;
-			pp->pool_short->pkt_size = 0;
-
-			mvPp2BmPoolBufSizeSet(pp->pool_short->pool, 0);
-			MV_ETH_UNLOCK(&pp->pool_short->lock, flags);
+/* mv_eth_pool_cleanup - delete all ports buffers from pool */
+static void mv_eth_pool_cleanup(int port, struct bm_pool *ppool)
+{
+	if (!ppool)
+		return;
+
+	ppool->port_map &= ~(1 << port);
+
+	if (ppool->port_map == 0) {
+		mv_eth_pool_free(ppool->pool, ppool->buf_num);
+		ppool->type = MV_ETH_BM_FREE;
+	}
+}
+
+static void mv_eth_napi_cleanup(struct eth_port *pp)
+{
+	int i;
+	struct napi_group_ctrl *napi_group;
+
+	if (!pp)
+		return;
+
+	if (!(pp->flags & MV_ETH_F_CONNECT_LINUX))
+		return;
+
+	for (i = 0; i < MV_ETH_MAX_NAPI_GROUPS; i++) {
+		napi_group = pp->napi_group[i];
+		if (napi_group) {
+			netif_napi_del(napi_group->napi);
+			mvOsFree(napi_group->napi);
+			mvOsFree(napi_group);
+			pp->napi_group[i] = NULL;
 		}
-		pp->pool_short = NULL;
 	}
+}
+
+static int mv_eth_port_cleanup(int port)
+{
+	struct eth_port *pp;
+	pp = mv_eth_port_by_id(port);
+
+	if (pp == NULL) {
+		printk(KERN_ERR "port %d already clean\n", port);
+		return 0;
+	}
+
+	if (pp->flags & MV_ETH_F_STARTED) {
+		printk(KERN_ERR "%s: port %d is started, cannot cleanup\n", __func__, port);
+		return -1;
+	}
+
+	mv_eth_tx_cleanup(pp);
+	mv_eth_rx_cleanup(pp);
+
+	/*pools cleanup*/
+	mv_eth_pool_cleanup(port, pp->pool_long);
+	mv_eth_pool_cleanup(port, pp->pool_short);
+	mv_eth_pool_cleanup(port, pp->hwf_pool_long);
+	mv_eth_pool_cleanup(port, pp->hwf_pool_short);
 
 	/* Clear Marvell Header related modes - will be set again if needed on re-init */
 	mvPp2MhSet(port, MV_PP2_MH_NONE);
@@ -5036,39 +5172,44 @@ static int mv_eth_port_cleanup(int port)
 	/* Clear any forced link, speed and duplex */
 	mv_eth_port_link_speed_fc(port, MV_ETH_SPEED_AN, 0);
 
-	mvPp2PortDestroy(port);
+	mv_eth_napi_cleanup(pp);
 
-	if (pp->flags & MV_ETH_F_CONNECT_LINUX)
-		for (i = 0; i < MV_ETH_MAX_NAPI_GROUPS; i++)
-			mv_eth_port_napi_group_delete(pp->port, i);
+	if (pp->tagged)
+		mv_mux_eth_detach(pp->port);
+
+	mv_eth_priv_cleanup(pp);
+
+	printk(KERN_ERR "port %d cleanup done\n", port);
 
 	return 0;
 }
 
-
 int mv_eth_all_ports_cleanup(void)
 {
-	int port, pool, status = 0;
+	int port, status;
 
 	for (port = 0; port < mv_eth_ports_num; port++) {
 		status = mv_eth_port_cleanup(port);
 		if (status != 0) {
-			printk(KERN_ERR "Error: mv_eth_port_cleanup failed on port %d, stopping all ports cleanup\n", port);
+			printk(KERN_ERR "%s :port %d, cleanup failed, stopping all ports cleanup\n", __func__, port);
 			return status;
 		}
 	}
 
-	for (pool = 0; pool < MV_ETH_BM_POOLS; pool++)
-		mv_eth_pool_destroy(pool);
+	if (mv_eth_initialized)
+		mv_eth_shared_cleanup();
 
-	for (port = 0; port < mv_eth_ports_num; port++) {
-		if (mv_eth_ports[port])
-			mvOsFree(mv_eth_ports[port]);
-	}
+	return MV_OK;
 
-	memset(mv_eth_ports, 0, (mv_eth_ports_num * sizeof(struct eth_port *)));
-	/* Note: not freeing mv_eth_ports - we will reuse them */
+}
+
+int mv_eth_all_ports_probe(void)
+{
+	int port = 0;
 
+	for (port = 0; port < mv_eth_ports_num; port++)
+		if (mv_eth_probe(plats[port]))
+			return 1;
 	return 0;
 }
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
index 2b1a590..5a1ca0e 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
@@ -230,6 +230,7 @@ struct port_stats {
 #define MV_ETH_F_SUSPEND           (1 << MV_ETH_F_SUSPEND_BIT)
 #define MV_ETH_F_STARTED_OLD       (1 << MV_ETH_F_STARTED_OLD_BIT)
 
+
 #ifdef CONFIG_MV_ETH_DEBUG_CODE
 /* Masks used for pp->dbg_flags */
 #define MV_ETH_F_DBG_RX_BIT         0
@@ -490,6 +491,7 @@ struct bm_pool {
 	spinlock_t		lock;
 	u32			port_map;
 	int			missed;		/* FIXME: move to stats */
+	MV_ULONG		physAddr;
 	struct			pool_stats stats;
 };
 
@@ -773,6 +775,8 @@ int         mv_eth_change_mtu_internals(struct net_device *netdev, int mtu);
 
 int         mv_eth_rx_reset(int port);
 int         mv_eth_txp_clean(int port, int txp);
+int         mv_eth_all_ports_cleanup(void);
+int         mv_eth_all_ports_probe(void);
 
 MV_STATUS   mv_eth_rx_ptks_coal_set(int port, int rxq, MV_U32 value);
 MV_STATUS   mv_eth_rx_time_coal_set(int port, int rxq, MV_U32 value);
diff --git a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.c b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.c
index ebdb423..90bbf8d 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.c
+++ b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.c
@@ -193,6 +193,15 @@ MV_STATUS mvPp2HalInit(MV_PP2_HAL_DATA *halData)
 	return MV_OK;
 }
 
+/*-------------------------------------------------------------------------------*/
+MV_VOID mvPp2HalDestroy(MV_VOID)
+{
+	mvPp2PhysTxqsDestroy();
+	mvPp2AggrTxqsDestroy();
+	mvPp2PhysRxqsDestroy();
+	mvOsFree(mvPp2PortCtrl);
+	memset(&mvPp2HalData, 0, sizeof(mvPp2HalData));
+}
 
 /*******************************************************************************
 * mvNetaDefaultsSet - Set defaults to the NETA port
@@ -479,14 +488,19 @@ void mvPp2RxqDelete(int port, int rxq)
    This function must be called before any use of RXQ */
 MV_STATUS mvPp2PhysRxqsAlloc(MV_VOID)
 {
-	int i;
+	int i, bytes;
+
+	bytes = MV_ETH_RXQ_TOTAL_NUM * sizeof(MV_PP2_PHYS_RXQ_CTRL);
+	mvPp2PhysRxqs = mvOsMalloc(bytes);
 
-	mvPp2PhysRxqs = mvOsMalloc(MV_ETH_RXQ_TOTAL_NUM * sizeof(MV_PP2_PHYS_RXQ_CTRL));
 	if (!mvPp2PhysRxqs) {
 		mvOsPrintf("mvPp2 Can't allocate %d Bytes for %d RXQs controls\n",
-			   MV_ETH_RXQ_TOTAL_NUM * sizeof(MV_PP2_PHYS_RXQ_CTRL), MV_ETH_RXQ_TOTAL_NUM);
+			   bytes, MV_ETH_RXQ_TOTAL_NUM);
 		return MV_OUT_OF_CPU_MEM;
 	}
+
+	memset(mvPp2PhysRxqs, 0, bytes);
+
 	for (i = 0; i < MV_ETH_RXQ_TOTAL_NUM; i++) {
 		mvPp2PhysRxqs[i].port = MV_PP2_RXQ_FREE;
 		mvPp2PhysRxqs[i].logicRxq = MV_PP2_RXQ_FREE;
@@ -498,7 +512,7 @@ MV_STATUS mvPp2PhysRxqsAlloc(MV_VOID)
 /* Destroy all physical RXQs */
 MV_STATUS mvPp2PhysRxqsDestroy(MV_VOID)
 {
-/*TODO*/
+	mvOsFree(mvPp2PhysRxqs);
 	return MV_OK;
 }
 
@@ -657,15 +671,21 @@ MV_STATUS mvPp2TxqDelete(int port, int txp, int txq)
    This function must be called before any use of TXQ */
 MV_STATUS mvPp2PhysTxqsAlloc(void)
 {
-	int i;
+	int i, bytes;
 
 	/* Alloc one extra element for temporary TXQ */
-	mvPp2PhysTxqs = mvOsMalloc((MV_PP2_TXQ_TOTAL_NUM + 1) * sizeof(MV_PP2_PHYS_TXQ_CTRL));
+	bytes = (MV_PP2_TXQ_TOTAL_NUM + 1) * sizeof(MV_PP2_PHYS_TXQ_CTRL);
+
+	mvPp2PhysTxqs = mvOsMalloc(bytes);
+
 	if (!mvPp2PhysTxqs) {
 		mvOsPrintf("mvPp2 Can't allocate %d Bytes for %d TXQs control\n",
-			   (MV_PP2_TXQ_TOTAL_NUM + 1) * sizeof(MV_PP2_PHYS_TXQ_CTRL), MV_PP2_TXQ_TOTAL_NUM);
+			   bytes, MV_PP2_TXQ_TOTAL_NUM);
 		return MV_OUT_OF_CPU_MEM;
 	}
+
+	memset(mvPp2PhysTxqs, 0, bytes);
+
 	for (i = 0; i < (MV_PP2_TXQ_TOTAL_NUM + 1); i++)
 		mvPp2PhysTxqs[i].txq = i;
 
@@ -673,10 +693,9 @@ MV_STATUS mvPp2PhysTxqsAlloc(void)
 }
 
 /* Destroy all physical TXQs */
-MV_STATUS mvPp2PhysTxqsDestroy(MV_VOID)
+MV_VOID mvPp2PhysTxqsDestroy(MV_VOID)
 {
-/*TODO*/
-	return MV_OK;
+	mvOsFree(mvPp2PhysTxqs);
 }
 
 /* Associate TXQs for this port
@@ -731,21 +750,38 @@ MV_STATUS mvPp2AggrTxqDescInit(MV_PP2_AGGR_TXQ_CTRL *txqCtrl, int descNum, int c
 MV_STATUS mvPp2AggrTxqsAlloc(int cpuNum)
 {
 	/* Alloc one extra element for temporary TXQ */
-	mvPp2AggrTxqs = mvOsMalloc(cpuNum * sizeof(MV_PP2_PHYS_TXQ_CTRL));
+	int bytes = cpuNum * sizeof(MV_PP2_PHYS_TXQ_CTRL);
+
+	mvPp2AggrTxqs = mvOsMalloc(bytes);
+
 	if (!mvPp2AggrTxqs) {
-		mvOsPrintf("mvPp2 Can't allocate %d Bytes for %d aggr TXQs control\n",
-			   cpuNum * sizeof(MV_PP2_PHYS_TXQ_CTRL), cpuNum);
+		mvOsPrintf("mvPp2 Can't allocate %d Bytes for %d aggr TXQs control\n", bytes, cpuNum);
 		return MV_OUT_OF_CPU_MEM;
 	}
 
+	memset(mvPp2AggrTxqs, 0, bytes);
+
 	return MV_OK;
 }
 
+/* release all aggregated TXQs */
+MV_VOID mvPp2AggrTxqsDestroy(MV_VOID)
+{
+	mvOsFree(mvPp2AggrTxqs);
+}
+
+
 /* Destroy all aggregated TXQs */
-MV_STATUS mvPp2AggrTxqsDestroy(MV_VOID)
+MV_VOID mvPp2AggrTxqDelete(int cpu)
 {
-/*TODO*/
-	return MV_OK;
+	MV_PP2_AGGR_TXQ_CTRL *pTxqCtrl = &mvPp2AggrTxqs[cpu];
+	MV_PP2_QUEUE_CTRL *pQueuCtrl = &pTxqCtrl->queueCtrl;
+	MV_BUF_INFO *pDescBuf = &pQueuCtrl->descBuf;
+
+	mvPp2DescrMemoryFree(pDescBuf->bufSize, (MV_ULONG *)pDescBuf->bufPhysAddr,
+				pDescBuf->bufVirtPtr, (MV_U32 *)pDescBuf->memHandle);
+
+	mvOsMemset(pQueuCtrl, 0, sizeof(*pQueuCtrl));
 }
 
 /* Initialize aggregated TXQ */
@@ -838,6 +874,19 @@ MV_STATUS mvPp2TxqTempInit(int descNum, int hwfNum)
 
 	return MV_OK;
 }
+
+void mvPp2TxqTempDelete(void)
+{
+	int ptxq = MV_PP2_TXQ_TOTAL_NUM;
+
+	MV_PP2_PHYS_TXQ_CTRL *pTxq = &mvPp2PhysTxqs[ptxq];
+	MV_PP2_QUEUE_CTRL *qCtrl = &pTxq->queueCtrl;
+	MV_BUF_INFO *pDescBuf = &qCtrl->descBuf;
+	mvPp2DescrMemoryFree(pDescBuf->bufSize, (MV_ULONG *)pDescBuf->bufPhysAddr,
+				pDescBuf->bufVirtPtr, (MV_U32 *)pDescBuf->memHandle);
+
+	mvOsMemset(qCtrl, 0, sizeof(*qCtrl));
+}
 /*-------------------------------------------------------------------------------*/
 /* Port */
 /* Allocate and initialize port structure
@@ -902,7 +951,18 @@ void *mvPp2PortInit(int port, int firstRxq, int numRxqs, void *osHandle)
 
 void mvPp2PortDestroy(int portNo)
 {
-/*TODO*/
+	MV_PP2_PORT_CTRL *pPortCtrl = mvPp2PortHndlGet(portNo);
+
+	if (pPortCtrl->pTxQueue)
+		mvOsFree(pPortCtrl->pTxQueue);
+
+	if (pPortCtrl->pRxQueue)
+		mvOsFree(pPortCtrl->pRxQueue);
+
+	if (pPortCtrl)
+		mvOsFree(pPortCtrl);
+
+	mvPp2PortCtrl[portNo] = NULL;
 }
 
 /*******************************************************************************
diff --git a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.h b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.h
index f610e5f..bd0185d 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.h
+++ b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.h
@@ -508,6 +508,7 @@ static INLINE MV_ULONG pp2DescVirtToPhys(MV_PP2_QUEUE_CTRL *pQueueCtrl, MV_U8 *p
 }
 
 MV_STATUS mvPp2HalInit(MV_PP2_HAL_DATA *halData);
+MV_VOID mvPp2HalDestroy(MV_VOID);
 
 /* Add a mapping prxq <-> (port, lrxq) */
 MV_STATUS mvPp2PhysRxqMapAdd(int prxq, int port, int lrxq);
@@ -543,15 +544,15 @@ MV_STATUS mvPp2TxqDelete(int port, int txp, int txq);
 MV_STATUS mvPp2PhysTxqsAlloc(MV_VOID);
 
 /* Destroy all physical TXQs */
-MV_STATUS mvPp2PhysTxqsDestroy(MV_VOID);
+MV_VOID mvPp2PhysTxqsDestroy(MV_VOID);
 
 /* Allocate and initialize all aggregated TXQs.
    This function must be called before any use of aggregated TXQ */
 MV_STATUS mvPp2AggrTxqsAlloc(int cpuNum);
 
 /* Destroy all aggregated TXQs */
-MV_STATUS mvPp2AggrTxqsDestroy(MV_VOID);
-
+MV_VOID mvPp2AggrTxqsDestroy(MV_VOID);
+MV_VOID mvPp2AggrTxqDelete(int cpu);
 /* Initialize aggregated TXQ */
 MV_PP2_AGGR_TXQ_CTRL *mvPp2AggrTxqInit(int cpu, int descNum);
 
@@ -561,6 +562,7 @@ int mvPp2TxDonePktsCoalGet(int port, int txp, int txq);
 void mvPp2TxpReset(int port, int txp);
 
 MV_STATUS mvPp2TxqTempInit(int descNum, int hwfNum);
+MV_VOID mvPp2TxqTempDelete(MV_VOID);
 
 /* Allocate and initialize port structure
    Associate relevant TXQs for this port (predefined)
-- 
1.7.5.4

