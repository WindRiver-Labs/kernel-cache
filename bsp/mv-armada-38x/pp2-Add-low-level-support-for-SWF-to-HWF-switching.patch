From 45841bb9c020b5b6cb5d31a2f8c70e2b6b6c8250 Mon Sep 17 00:00:00 2001
From: Dmitri Epshtein <dima@marvell.com>
Date: Tue, 13 Aug 2013 09:27:58 -0400
Subject: [PATCH 0949/1825] pp2: Add low level support for SWF to HWF
 switching

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 62f31e098c23f341c321883fa69fe5f20b09e042

	Add APIs (HAL level) for control and status
	Add new sysfs directory pp2/gbe/hwf
	Add new sysfs commands for SWF to HWF switching

Change-Id: Ia005edd4ab4779544e46aa081ab3b556d5a968f6
Signed-off-by: Dmitri Epshtein <dima@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/3016
Reviewed-by: Igor Patrik <igorp@marvell.com>
Reviewed-by: Jonatan Farhadian <yonif@marvell.com>
Tested-by: Star_Automation <star@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile |    4 +
 .../mv_pp2/net_dev/mv_eth_hwf_sysfs.c              |  182 ++++++++++++++++++++
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c   |   11 +-
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.h   |    4 +
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h      |    4 -
 5 files changed, 200 insertions(+), 5 deletions(-)
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_hwf_sysfs.c

diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile
index 76e1791..a0cad83 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile
@@ -34,6 +34,10 @@ mv_pp2-objs += net_dev/mv_eth_rx_sysfs.o net_dev/mv_eth_tx_sysfs.o net_dev/mv_et
 mv_pp2-objs += net_dev/mv_eth_napi_sysfs.o net_dev/mv_eth_pme_sysfs.o net_dev/mv_eth_pon_sysfs.o
 mv_pp2-objs += net_dev/mv_eth_bm_sysfs.o net_dev/mv_eth_qos_sysfs.o net_dev/mv_eth_dbg_sysfs.o
 
+ifeq ($(CONFIG_MV_ETH_HWF),y)
+mv_pp2-objs += net_dev/mv_eth_hwf_sysfs.o
+endif
+
 mv_pp2-objs += prs/prs_low_sysfs.o prs/prs_high_sysfs.o
 mv_pp2-objs += cls/cls_sysfs.o cls/cls2_sysfs.o cls/cls3_sysfs.o cls/cls4_sysfs.o cls/cls_mc_sysfs.o
 mv_pp2-objs += pme/pme_sysfs.o
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_hwf_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_hwf_sysfs.c
new file mode 100644
index 0000000..040bdf3
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_hwf_sysfs.c
@@ -0,0 +1,182 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/capability.h>
+#include <linux/platform_device.h>
+#include <linux/netdevice.h>
+
+#include "mv_eth_sysfs.h"
+#include "gbe/mvPp2Gbe.h"
+#include "mv_netdev.h"
+
+static ssize_t mv_pp2_hwf_help(char *buf)
+{
+	int o = 0;
+
+	o += scnprintf(buf+o, PAGE_SIZE-o, "id     - is hex number\n");
+	o += scnprintf(buf+o, PAGE_SIZE-o, "others - are dec numbers\n\n");
+
+	o += scnprintf(buf+o, PAGE_SIZE-o, "cat                    regs    - show SWF to HWF switching registers\n");
+	o += scnprintf(buf+o, PAGE_SIZE-o, "cat                    status  - show SWF to HWF switching status\n");
+	o += scnprintf(buf+o, PAGE_SIZE-o, "echo msec            > timeout - set SWF to HWF switching timeout\n");
+	o += scnprintf(buf+o, PAGE_SIZE-o, "echo id txq rxq msec > switch  - start SWF to HWF switching process\n");
+
+	return o;
+}
+
+static ssize_t mv_pp2_hwf_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	int             off = 0;
+	const char      *name = attr->attr.name;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	if (!strcmp(name, "regs"))
+		mvPp2FwdSwitchRegs();
+	else if (!strcmp(name, "status")) {
+		int state, status, msec;
+
+		status = mvPp2FwdSwitchStatus(&state, &msec);
+		pr_info("\n[FWD Switch status]\n");
+		pr_info("\t status=%d, hwState=%d, msec=%d\n", status, state, msec);
+	} else
+		off = mv_pp2_hwf_help(buf);
+
+	return off;
+}
+
+static unsigned int fwd_switch_msec = 3;
+
+static ssize_t mv_pp2_hwf_store(struct device *dev,
+				   struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char      *name = attr->attr.name;
+	int             num, err;
+	unsigned int    id, rxq, txq, msec;
+	unsigned long   flags;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	/* Read port and value */
+	err = id = txq = rxq = msec = 0;
+	num = sscanf(buf, "%x %d %d %d", &id, &txq, &rxq, &msec);
+	if (num < 4)
+		msec = fwd_switch_msec;
+
+	local_irq_save(flags);
+
+	if (!strcmp(name, "switch")) {
+		err = mvPp2FwdSwitchCtrl(id, txq, rxq, msec);
+	} else {
+		err = 1;
+		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
+	}
+
+	local_irq_restore(flags);
+
+	if (err)
+		printk(KERN_ERR "%s: error %d\n", __func__, err);
+
+	return err ? -EINVAL : len;
+}
+
+static ssize_t mv_pp2_hwf_dec_store(struct device *dev,
+				   struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char      *name = attr->attr.name;
+	int             err;
+	unsigned int    val;
+	unsigned long   flags;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	/* Read port and value */
+	err = val = 0;
+	sscanf(buf, "%d ", &val);
+
+	local_irq_save(flags);
+
+	if (!strcmp(name, "timeout")) {
+		fwd_switch_msec = val;
+	} else {
+		err = 1;
+		printk(KERN_ERR "%s: illegal operation <%s>\n", __func__, attr->attr.name);
+	}
+
+	local_irq_restore(flags);
+
+	if (err)
+		printk(KERN_ERR "%s: error %d\n", __func__, err);
+
+	return err ? -EINVAL : len;
+}
+
+static DEVICE_ATTR(help,		S_IRUSR, mv_pp2_hwf_show, NULL);
+static DEVICE_ATTR(regs,		S_IRUSR, mv_pp2_hwf_show, NULL);
+static DEVICE_ATTR(status,		S_IRUSR, mv_pp2_hwf_show, NULL);
+static DEVICE_ATTR(switch,		S_IWUSR, NULL, mv_pp2_hwf_store);
+static DEVICE_ATTR(timeout,		S_IWUSR, NULL, mv_pp2_hwf_dec_store);
+
+static struct attribute *mv_pp2_hwf_attrs[] = {
+	&dev_attr_help.attr,
+	&dev_attr_regs.attr,
+	&dev_attr_status.attr,
+	&dev_attr_switch.attr,
+	&dev_attr_timeout.attr,
+	NULL
+};
+
+static struct attribute_group mv_pp2_hwf_group = {
+	.name = "hwf",
+	.attrs = mv_pp2_hwf_attrs,
+};
+
+
+int mv_pp2_gbe_hwf_sysfs_init(struct kobject *gbe_kobj)
+{
+	int err;
+
+	err = sysfs_create_group(gbe_kobj, &mv_pp2_hwf_group);
+	if (err)
+		printk(KERN_INFO "sysfs group failed %d\n", err);
+
+	return err;
+}
+
+int mv_pp2_gbe_hwf_sysfs_exit(struct kobject *gbe_kobj)
+{
+	sysfs_remove_group(gbe_kobj, &mv_pp2_hwf_group);
+
+	return 0;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c
index 98ffe39..579850d 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.c
@@ -51,6 +51,9 @@ static ssize_t mv_eth_help(char *buf)
 	off += sprintf(buf+off, "cd                 pme         - move to PME sysfs directory\n");
 	off += sprintf(buf+off, "cd                 qos         - move to QoS sysfs directory\n\n");
 
+#ifdef CONFIG_MV_ETH_HWF
+	off += sprintf(buf+off, "cd                 qos         - move to QoS sysfs directory\n\n");
+#endif
 	off += sprintf(buf+off, "cat                addrDec     - show address decode registers\n");
 	off += sprintf(buf+off, "echo [p]         > port        - show port [p] status\n");
 	off += sprintf(buf+off, "echo [if_name]   > netdev      - show [if_name] net_device status\n");
@@ -259,7 +262,9 @@ int mv_pp2_gbe_sysfs_init(struct kobject *pp2_kobj)
 	mv_pp2_qos_sysfs_init(gbe_kobj);
 	mv_pp2_pon_sysfs_init(gbe_kobj);
 	mv_pp2_gbe_pme_sysfs_init(gbe_kobj);
-
+#ifdef CONFIG_MV_ETH_HWF
+	mv_pp2_gbe_hwf_sysfs_init(gbe_kobj);
+#endif
 	return err;
 }
 
@@ -273,6 +278,10 @@ int mv_pp2_gbe_sysfs_exit(struct kobject *pp2_kobj)
 	mv_pp2_rx_sysfs_exit(gbe_kobj);
 	mv_pp2_napi_sysfs_exit(gbe_kobj);
 	mv_pp2_bm_sysfs_exit(gbe_kobj);
+#ifdef CONFIG_MV_ETH_HWF
+	mv_pp2_gbe_hwf_sysfs_exit(gbe_kobj);
+#endif
 	sysfs_remove_group(pp2_kobj, &mv_eth_group);
+
 	return 0;
 }
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.h
index 1920c2b..ee18514 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_sysfs.h
@@ -86,6 +86,10 @@ int mv_pp2_pon_sysfs_exit(struct kobject *pp2_kobj);
 int mv_pp2_gbe_pme_sysfs_init(struct kobject *gbe_kobj);
 int mv_pp2_gbe_pme_sysfs_exit(struct kobject *gbe_kobj);
 
+#ifdef CONFIG_MV_ETH_HWF
+int mv_pp2_gbe_hwf_sysfs_init(struct kobject *gbe_kobj);
+int mv_pp2_gbe_hwf_sysfs_exit(struct kobject *gbe_kobj);
+#endif /* CONFIG_MV_ETH_HWF */
 
 int mv_pp2_dbg_sysfs_init(struct kobject *pp2_kobj);
 int mv_pp2_dbg_sysfs_exit(struct kobject *pp2_kobj);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
index 93a58e0..5dd034d 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
@@ -343,15 +343,11 @@ struct eth_port {
 	rwlock_t            rwlock;
 	struct bm_pool      *pool_long;
 	struct bm_pool      *pool_short;
-#ifdef CONFIG_MV_ETH_HWF
 	struct bm_pool      *hwf_pool_long;
 	struct bm_pool      *hwf_pool_short;
-#endif /* CONFIG_MV_ETH_HWF */
 	struct napi_group_ctrl *napi_group[MV_ETH_MAX_RXQ];
 	unsigned long       flags;	/* MH, TIMER, etc. */
-#ifdef CONFIG_MV_ETH_DEBUG_CODE
 	u8		    dbg_flags;
-#endif /* CONFIG_MV_ETH_DEBUG_CODE */
 	struct mv_eth_tx_spec tx_spec;
 	struct port_stats   stats;
 	struct dist_stats   dist_stats;
-- 
1.7.5.4

