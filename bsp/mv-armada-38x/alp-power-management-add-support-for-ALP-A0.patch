From e55bffb98e7bb0f0a7dffd4c4f93f73d5a7abf66 Mon Sep 17 00:00:00 2001
From: Joe Zhou <shjzhou@marvell.com>
Date: Tue, 18 Feb 2014 13:38:33 +0800
Subject: [PATCH 1408/1825] alp: power management: add support for ALP-A0

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 5e40226969f1f92d36edcefd79966d7d97aad212

	Added PMC register defintions for CESA, Coprocessor, USB3, PTP and TDMMC
	Corrected register offset for XOR
	Add multiple port support for USB and SATA

Signed-off-by: Joe Zhou <shjzhou@marvell.com>

Change-Id: I37b3299a7eadac02400a61afdcacf00feb75e869
Reviewed-on: http://vgitil04.il.marvell.com:8080/5754
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c        |  111 ++++++++++++++++++-
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvRegs.h       |   53 +++++++---
 2 files changed, 144 insertions(+), 20 deletions(-)

diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
index d6d83a0..748d95c 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
@@ -1075,6 +1075,33 @@ MV_U32 mvCtrlXorMaxUnitGet(MV_VOID)
 
 #endif
 
+#if defined(MV_INCLUDE_CESA)
+/*******************************************************************************
+* mvCtrlCesaMaxChanGet - Get Marvell engine number of CESA channels.
+*
+* DESCRIPTION:
+*       This function returns Marvell engine number of CESA channels.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell engine number of CESA channels.
+*
+*******************************************************************************/
+MV_U32 mvCtrlCesaMaxChanGet(MV_VOID)
+{
+	if (mvCtrlRevGet() <= MV_88F66X0_Z3_ID)
+		return 0;
+
+	return mvCtrlSocUnitInfoNumGet(CESA_UNIT_ID);
+}
+#endif
+
+
 #if defined(MV_INCLUDE_USB)
 /*******************************************************************************
 * mvCtrlUsbMaxGet - Get number of Marvell USB controllers
@@ -1991,6 +2018,11 @@ MV_VOID mvCtrlPwrClckSet(MV_UNIT_ID unitId, MV_U32 index, MV_BOOL enable)
 	switch (unitId) {
 #if defined(MV_INCLUDE_PEX)
 	case PEX_UNIT_ID:
+		if ((index + 1) > mvCtrlPexMaxIfGet()) {
+			mvOsPrintf("%s: Error: Rev %d doesn't support more than %d PEX interfaces\n",
+						__func__, mvCtrlRevGet(), mvCtrlPexMaxIfGet());
+			break;
+		}
 		if (enable == MV_FALSE)
 			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_PEX_STOP_CLK_MASK(index));
 		else
@@ -2000,19 +2032,36 @@ MV_VOID mvCtrlPwrClckSet(MV_UNIT_ID unitId, MV_U32 index, MV_BOOL enable)
 #endif
 #if defined(MV_INCLUDE_INTEG_SATA)
 	case SATA_UNIT_ID:
+		if ((index + 1) > mvCtrlSataMaxPortGet()) {
+			mvOsPrintf("%s: Error: Rev %d doesn't support more than %d SATA interfaces\n",
+						__func__, mvCtrlRevGet(), mvCtrlSataMaxPortGet());
+			break;
+		}
 		if (enable == MV_FALSE)
-			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_SATA_STOP_CLK_MASK);
+			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_SATA_STOP_CLK_MASK(index));
 		else
-			MV_REG_BIT_SET(POWER_MNG_CTRL_REG, PMC_SATA_STOP_CLK_MASK);
+			MV_REG_BIT_SET(POWER_MNG_CTRL_REG, PMC_SATA_STOP_CLK_MASK(index));
 
 		break;
 #endif
 #if defined(MV_INCLUDE_USB)
 	case USB_UNIT_ID:
+		if ((index + 1) > mvCtrlUsbMaxGet()) {
+			mvOsPrintf("%s: Error: Rev %d doesn't support more than %d USB interfaces\n",
+						__func__, mvCtrlRevGet(), mvCtrlUsbMaxGet());
+			break;
+		}
 		if (enable == MV_FALSE)
-			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_USB_STOP_CLK_MASK);
+			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_USB_STOP_CLK_MASK(index));
 		else
-			MV_REG_BIT_SET(POWER_MNG_CTRL_REG, PMC_USB_STOP_CLK_MASK);
+			MV_REG_BIT_SET(POWER_MNG_CTRL_REG, PMC_USB_STOP_CLK_MASK(index));
+
+		break;
+	case USB3_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_USB3_STOP_CLK_MASK);
+		else
+			MV_REG_BIT_SET(POWER_MNG_CTRL_REG, PMC_USB3_STOP_CLK_MASK);
 
 		break;
 #endif
@@ -2025,12 +2074,28 @@ MV_VOID mvCtrlPwrClckSet(MV_UNIT_ID unitId, MV_U32 index, MV_BOOL enable)
 
 		break;
 #endif
+#if defined(MV_INCLUDE_TDM)
 	case TDM_UNIT_ID:
 		if (enable == MV_FALSE)
 			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_TDM_STOP_CLK_MASK);
 		else
 			MV_REG_BIT_SET(POWER_MNG_CTRL_REG, PMC_TDM_STOP_CLK_MASK);
 		break;
+#endif
+#if defined(MV_INCLUDE_CESA)
+	case CESA_UNIT_ID:
+		if ((index + 1) > mvCtrlCesaMaxChanGet()) {
+			mvOsPrintf("%s: Error: Rev %d doesn't support more than %d CESA engines\n",
+						__func__, mvCtrlRevGet(), mvCtrlCesaMaxChanGet());
+			break;
+		}
+		if (enable == MV_FALSE)
+			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_CESA_STOP_CLK_MASK(index));
+		else
+			MV_REG_BIT_SET(POWER_MNG_CTRL_REG, PMC_CESA_STOP_CLK_MASK(index));
+		break;
+#endif
+
 	default:
 		break;
 	}
@@ -2059,6 +2124,11 @@ MV_BOOL mvCtrlPwrClckGet(MV_UNIT_ID unitId, MV_U32 index)
 	switch (unitId) {
 #if defined(MV_INCLUDE_PEX)
 	case PEX_UNIT_ID:
+		if ((index + 1) > mvCtrlPexMaxIfGet()) {
+			mvOsPrintf("%s: Error: Rev %d doesn't support more than %d PEX interfaces\n",
+						__func__, mvCtrlRevGet(), mvCtrlPexMaxIfGet());
+			break;
+		}
 		if ((reg & PMC_PEX_STOP_CLK_MASK(index)) == PMC_PEX_STOP_CLK_STOP(index))
 			state = MV_FALSE;
 		else
@@ -2067,7 +2137,12 @@ MV_BOOL mvCtrlPwrClckGet(MV_UNIT_ID unitId, MV_U32 index)
 #endif
 #if defined(MV_INCLUDE_SATA)
 	case SATA_UNIT_ID:
-		if ((reg & PMC_SATA_STOP_CLK_MASK) == PMC_SATA_STOP_CLK_STOP)
+		if ((index + 1) > mvCtrlSataMaxPortGet()) {
+			mvOsPrintf("%s: Error: Rev %d doesn't support more than %d SATA interfaces\n",
+						__func__, mvCtrlRevGet(), mvCtrlSataMaxPortGet());
+			break;
+		}
+		if ((reg & PMC_SATA_STOP_CLK_MASK(index)) == PMC_SATA_STOP_CLK_STOP(index))
 			state = MV_FALSE;
 		else
 			state = MV_TRUE;
@@ -2075,7 +2150,18 @@ MV_BOOL mvCtrlPwrClckGet(MV_UNIT_ID unitId, MV_U32 index)
 #endif
 #if defined(MV_INCLUDE_USB)
 	case USB_UNIT_ID:
-		if ((reg & PMC_USB_STOP_CLK_MASK) == PMC_USB_STOP_CLK_STOP)
+		if ((index + 1) > mvCtrlUsbMaxGet()) {
+			mvOsPrintf("%s: Error: Rev %d doesn't support more than %d USB interfaces\n",
+						__func__, mvCtrlRevGet(), mvCtrlUsbMaxGet());
+			break;
+		}
+		if ((reg & PMC_USB_STOP_CLK_MASK(index)) == PMC_USB_STOP_CLK_STOP(index))
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+	case USB3_UNIT_ID:
+		if ((reg & PMC_USB3_STOP_CLK_MASK) == PMC_USB3_STOP_CLK_STOP)
 			state = MV_FALSE;
 		else
 			state = MV_TRUE;
@@ -2097,6 +2183,19 @@ MV_BOOL mvCtrlPwrClckGet(MV_UNIT_ID unitId, MV_U32 index)
 			state = MV_TRUE;
 		break;
 #endif
+#if defined(MV_INCLUDE_CESA)
+	case CESA_UNIT_ID:
+		if ((index + 1) > mvCtrlCesaMaxChanGet()) {
+			mvOsPrintf("%s: Error: Rev %d doesn't support more than %d CESA engines\n",
+						__func__, mvCtrlRevGet(), mvCtrlCesaMaxChanGet());
+			break;
+		}
+		if ((reg & PMC_CESA_STOP_CLK_STOP(index)) == PMC_CESA_STOP_CLK_STOP(index))
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
 	default:
 		state = MV_TRUE;
 		break;
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvRegs.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvRegs.h
index 2cf15e1..f38cef3 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvRegs.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvRegs.h
@@ -126,35 +126,60 @@ extern "C" {
  */
 #define POWER_MNG_CTRL_REG			0x18220
 
-#define PMC_TDM_STOP_CLK_OFFS			25
+#define PMC_CESA_STOP_CLK_OFFS(id)		((id) + 28)
+#define PMC_CESA_STOP_CLK_MASK(id)	(5 << PMC_CESA_STOP_CLK_OFFS(id))
+#define PMC_CESA_STOP_CLK_EN(id)		(5 << PMC_CESA_STOP_CLK_OFFS(id))
+#define PMC_CESA_STOP_CLK_STOP(id)		(0 << PMC_CESA_STOP_CLK_OFFS(id))
+
+#define PMC_TDM_STOP_CLK_OFFS				25
 #define PMC_TDM_STOP_CLK_MASK			(1 << PMC_TDM_STOP_CLK_OFFS)
-#define PMC_TDM_STOP_CLK_EN			(1 << PMC_TDM_STOP_CLK_OFFS)
-#define PMC_TDM_STOP_CLK_STOP			(0 << PMC_TDM_STOP_CLK_OFFS)
+#define PMC_TDM_STOP_CLK_EN				(1 << PMC_TDM_STOP_CLK_OFFS)
+#define PMC_TDM_STOP_CLK_STOP				(0 << PMC_TDM_STOP_CLK_OFFS)
+
+#define PMC_COPROCESSOR_STOP_CLK_OFFS	24
+#define PMC_COPROCESSOR_STOP_CLK_MASK	(1 << PMC_COPROCESSOR_STOP_CLK_OFFS)
+#define PMC_COPROCESSOR_STOP_CLK_EN		(1 << PMC_COPROCESSOR_STOP_CLK_OFFS)
+#define PMC_COPROCESSOR_STOP_CLK_STOP	(0 << PMC_COPROCESSOR_STOP_CLK_OFFS)
 
 #define PMC_PEX_STOP_CLK_OFFS(port)		((port) + 5)
 #define PMC_PEX_STOP_CLK_MASK(port)		(1 << PMC_PEX_STOP_CLK_OFFS(port))
-#define PMC_PEX_STOP_CLK_EN(port)		(1 << PMC_PEX_STOP_CLK_OFFS(port))
+#define PMC_PEX_STOP_CLK_EN(port)			(1 << PMC_PEX_STOP_CLK_OFFS(port))
 #define PMC_PEX_STOP_CLK_STOP(port)		(0 << PMC_PEX_STOP_CLK_OFFS(port))
 
-#define PMC_USB_STOP_CLK_OFFS			18
-#define PMC_USB_STOP_CLK_MASK			(1 << PMC_USB_STOP_CLK_OFFS)
-#define PMC_USB_STOP_CLK_EN			(1 << PMC_USB_STOP_CLK_OFFS)
-#define PMC_USB_STOP_CLK_STOP			(0 << PMC_USB_STOP_CLK_OFFS)
+#define PMC_USB_STOP_CLK_OFFS(usb_id)		((usb_id == 0) ? 18 : 26)
+#define PMC_USB_STOP_CLK_MASK(usb_id)		(1 << PMC_USB_STOP_CLK_OFFS(usb_id))
+#define PMC_USB_STOP_CLK_EN(usb_id)		(1 << PMC_USB_STOP_CLK_OFFS(usb_id))
+#define PMC_USB_STOP_CLK_STOP(usb_id)		(0 << PMC_USB_STOP_CLK_OFFS(usb_id))
 
 #define PMC_SDIO_STOP_CLK_OFFS			17
 #define PMC_SDIO_STOP_CLK_MASK			(1 << PMC_SDIO_STOP_CLK_OFFS)
-#define PMC_SDIO_STOP_CLK_EN			(1 << PMC_SDIO_STOP_CLK_OFFS)
+#define PMC_SDIO_STOP_CLK_EN				(1 << PMC_SDIO_STOP_CLK_OFFS)
 #define PMC_SDIO_STOP_CLK_STOP			(0 << PMC_SDIO_STOP_CLK_OFFS)
 
-#define PMC_XOR_STOP_CLK_OFFS(xor_id)		(xor_id == 0 ? 22 : 28)
+#define PMC_XOR_STOP_CLK_OFFS(xor_id)		((xor_id) + 22)
 #define PMC_XOR_STOP_CLK_MASK(xor_id)		(1 << PMC_XOR_STOP_CLK_OFFS(xor_id))
 #define PMC_XOR_STOP_CLK_EN(xor_id)		(1 << PMC_XOR_STOP_CLK_OFFS(xor_id))
 #define PMC_XOR_STOP_CLK_STOP(xor_id)		(0 << PMC_XOR_STOP_CLK_OFFS(xor_id))
 
-#define PMC_SATA_STOP_CLK_OFFS			14
-#define PMC_SATA_STOP_CLK_MASK			(3 << PMC_SATA_STOP_CLK_OFFS)
-#define PMC_SATA_STOP_CLK_EN			(3 << PMC_SATA_STOP_CLK_OFFS)
-#define PMC_SATA_STOP_CLK_STOP			(0 << PMC_SATA_STOP_CLK_OFFS)
+#define PMC_USB3_STOP_CLK_OFFS			16
+#define PMC_USB3_STOP_CLK_MASK			(1 << PMC_USB3_STOP_CLK_OFFS)
+#define PMC_USB3_STOP_CLK_EN				(1 << PMC_USB3_STOP_CLK_OFFS)
+#define PMC_USB3_STOP_CLK_STOP			(0 << PMC_USB3_STOP_CLK_OFFS)
+
+#define PMC_SATA_STOP_CLK_OFFS(sata_id)	((sata_id == 0) ? 14 : 20)
+#define PMC_SATA_STOP_CLK_MASK(sata_id)	(3 << PMC_SATA_STOP_CLK_OFFS(sata_id))
+#define PMC_SATA_STOP_CLK_EN(sata_id)		(3 << PMC_SATA_STOP_CLK_OFFS(sata_id))
+#define PMC_SATA_STOP_CLK_STOP(sata_id)	(0 << PMC_SATA_STOP_CLK_OFFS(sata_id))
+
+#define PMC_PTP_STOP_CLK_OFFS				4
+#define PMC_PTP_STOP_CLK_MASK				(1 << PMC_PTP_STOP_CLK_OFFS)
+#define PMC_PTP_STOP_CLK_EN				(1 << PMC_PTP_STOP_CLK_OFFS)
+#define PMC_PTP_STOP_CLK_STOP				(0 << PMC_PTP_STOP_CLK_OFFS)
+
+#define PMC_TDMMC_STOP_CLK_OFFS			0
+#define PMC_TDMMC_STOP_CLK_MASK			(1 << PMC_TDMMC_STOP_CLK_OFFS)
+#define PMC_TDMMC_STOP_CLK_EN			(1 << PMC_TDMMC_STOP_CLK_OFFS)
+#define PMC_TDMMC_STOP_CLK_STOP			(0 << PMC_TDMMC_STOP_CLK_OFFS)
 
 /*
  * System Soft Reset
-- 
1.7.5.4

