From 3592acbdb990fb3b61047377eaa9b14ddf02736e Mon Sep 17 00:00:00 2001
From: Joe Zhou <shjzhou@marvell.com>
Date: Wed, 30 Apr 2014 16:27:32 +0800
Subject: [PATCH 1601/1825] fix: alp,a38x: ioremap overriding is not working

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 1e916d062bc79cd0bfc8051eaf2531284fb5c9db

	In order to fix PCI deadlock issue, we need to override ioremap.
	For ALP:
	alp_early_init was not called before. Now call it in alp_board_init.
	For a38x:
	it was using compile time overriding, but compile time overriding
	mechanism was removed from kernel 3.4. Now use same way sa ALP.

Change-Id: I2deb39f63af2792b97ae6f34705492b07a783bdd
Signed-off-by: Joe Zhou <shjzhou@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/7778
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Yehuda Yitschak <yehuday@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-armada38x/core.c            |   52 +++++++++++++----------------
 arch/arm/mach-armada38x/include/mach/io.h |    6 ---
 arch/arm/mach-avantalp/core.c             |    2 +
 3 files changed, 25 insertions(+), 35 deletions(-)

diff --git a/arch/arm/mach-armada38x/core.c b/arch/arm/mach-armada38x/core.c
index 52b9bf3..29bb3fd 100644
--- a/arch/arm/mach-armada38x/core.c
+++ b/arch/arm/mach-armada38x/core.c
@@ -1256,7 +1256,7 @@ static void __init a38x_init_l2x0_cache(void)
 #endif
 }
 
-static inline int is_a38x_pcie_phys_memory(u32 addr)
+static inline int is_a38x_pcie_memory(u32 addr)
 {
 	switch (mvCtrlSocUnitInfoNumGet(PEX_UNIT_ID)) {
 	case 0:
@@ -1266,49 +1266,41 @@ static inline int is_a38x_pcie_phys_memory(u32 addr)
 	case 2:
 		return (((addr >= PEX0_MEM_PHYS_BASE) && (addr < (PEX0_MEM_PHYS_BASE + PEX0_MEM_SIZE))) || \
 			((addr >= PEX1_MEM_PHYS_BASE) && (addr < (PEX1_MEM_PHYS_BASE + PEX1_MEM_SIZE))));
+	case 3:
+		return (((addr >= PEX0_MEM_PHYS_BASE) && (addr < (PEX0_MEM_PHYS_BASE + PEX0_MEM_SIZE))) || \
+			((addr >= PEX1_MEM_PHYS_BASE) && (addr < (PEX1_MEM_PHYS_BASE + PEX1_MEM_SIZE))) || \
+			((addr >= PEX2_MEM_PHYS_BASE) && (addr < (PEX2_MEM_PHYS_BASE + PEX2_MEM_SIZE))));
+	case 4:
+		return (((addr >= PEX0_MEM_PHYS_BASE) && (addr < (PEX0_MEM_PHYS_BASE + PEX0_MEM_SIZE))) || \
+			((addr >= PEX1_MEM_PHYS_BASE) && (addr < (PEX1_MEM_PHYS_BASE + PEX1_MEM_SIZE))) || \
+			((addr >= PEX2_MEM_PHYS_BASE) && (addr < (PEX2_MEM_PHYS_BASE + PEX2_MEM_SIZE))) || \
+			((addr >= PEX3_MEM_PHYS_BASE) && (addr < (PEX3_MEM_PHYS_BASE + PEX3_MEM_SIZE))));
 	default:
 		pr_err("%s: Error: invalid number of PCIe ports\n", __func__);
 		return 0;
 	}
 }
 
-static inline int is_a38x_pcie_virt_memory(u32 addr)
-{
-	switch (mvCtrlSocUnitInfoNumGet(PEX_UNIT_ID)) {
-	case 0:
-		return 0;
-	case 1:
-		return ((addr >= PEX0_MEM_VIRT_BASE) && (addr < (PEX0_MEM_VIRT_BASE + PEX0_MEM_SIZE)));
-	case 2:
-		return (((addr >= PEX0_MEM_VIRT_BASE) && (addr < (PEX0_MEM_VIRT_BASE + PEX0_MEM_SIZE))) || \
-			((addr >= PEX1_MEM_VIRT_BASE) && (addr < (PEX1_MEM_VIRT_BASE + PEX1_MEM_SIZE))));
-	default:
-		pr_err("%s: Error: invalid number of PCIe ports\n", __func__);
-		return 0;
-	}
-}
-
-void __iomem *__a38x_ioremap(unsigned long addr, unsigned long size, unsigned int mtype)
+static void __iomem *a38x_ioremap_caller(unsigned long addr, size_t size,
+					   unsigned int mtype, void *caller)
 {
-	if (!is_a38x_pcie_phys_memory(addr))
-		return __arm_ioremap(addr, size, mtype);
+	if (!is_a38x_pcie_memory(addr))
+		return __arm_ioremap_caller(addr, size, mtype, caller);
 
 	if ((addr >= PEX0_MEM_PHYS_BASE) && (addr < (PEX0_MEM_PHYS_BASE + PEX0_MEM_SIZE)))
 		return (void __iomem *)(PEX0_MEM_VIRT_BASE + (addr - PEX0_MEM_PHYS_BASE));
-	else
+	else if ((addr >= PEX1_MEM_PHYS_BASE) && (addr < (PEX1_MEM_PHYS_BASE + PEX1_MEM_SIZE)))
 		return (void __iomem *)(PEX1_MEM_VIRT_BASE + (addr - PEX1_MEM_PHYS_BASE));
-
+	else if ((addr >= PEX2_MEM_PHYS_BASE) && (addr < (PEX2_MEM_PHYS_BASE + PEX2_MEM_SIZE)))
+		return (void __iomem *)(PEX2_MEM_VIRT_BASE + (addr - PEX2_MEM_PHYS_BASE));
+	else
+		return (void __iomem *)(PEX3_MEM_VIRT_BASE + (addr - PEX3_MEM_PHYS_BASE));
 }
-EXPORT_SYMBOL(__a38x_ioremap);
 
-void __a38x_iounmap(void __iomem *addr)
+void __init a38x_init_early(void)
 {
-	if (is_a38x_pcie_virt_memory(addr))
-		return;
-	else
-		return __iounmap(addr);
+	arch_ioremap_caller = a38x_ioremap_caller;
 }
-EXPORT_SYMBOL(__a38x_iounmap);
 
 static void __init a38x_board_init(void)
 {
@@ -1316,6 +1308,8 @@ static void __init a38x_board_init(void)
 	if (mvCtrlEnvInit())
 		pr_err("%s: Error: ctrlEnv init failed.\n", __func__);
 
+	a38x_init_early();
+
 	a38x_init_cib_mbus_optimizations();
 	a38x_init_cpu_mbus();
 	a38x_init_l2x0_cache();
diff --git a/arch/arm/mach-armada38x/include/mach/io.h b/arch/arm/mach-armada38x/include/mach/io.h
index 7d05359..d93e83c 100644
--- a/arch/arm/mach-armada38x/include/mach/io.h
+++ b/arch/arm/mach-armada38x/include/mach/io.h
@@ -18,12 +18,6 @@
 
 void dma_io_sync(void);
 
-extern void __iomem *__a38x_ioremap(unsigned long addr, unsigned long size, unsigned int mtype);
-extern void __a38x_iounmap(void __iomem *addr);
-
-#define __arch_ioremap	__a38x_ioremap
-#define __arch_iounmap	__a38x_iounmap
-
 #ifdef CONFIG_AURORA_IO_CACHE_COHERENCY
 #define dma_io_sync()	do {				\
 	writel(0x1, CPU_IO_SYNC_BARRIER_CTRL_REG);		\
diff --git a/arch/arm/mach-avantalp/core.c b/arch/arm/mach-avantalp/core.c
index b14656e..55944af 100644
--- a/arch/arm/mach-avantalp/core.c
+++ b/arch/arm/mach-avantalp/core.c
@@ -1790,6 +1790,8 @@ static void __init alp_board_init(void)
 	mvTargetDefaultsArray[PEX0_MEM].attrib = 0xD8;
 #endif
 
+	alp_init_early();
+
 	alp_cpu_mbus_init();
 
 	if (mvUnitMapIsMine(MSTR) == MV_TRUE)
-- 
1.7.5.4

