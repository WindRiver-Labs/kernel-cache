From 512408c531503c05f314e5dc80f89810b34dbffd Mon Sep 17 00:00:00 2001
From: Dmitri Epshtein <dima@marvell.com>
Date: Mon, 26 Aug 2013 17:12:13 -0400
Subject: [PATCH 0972/1825] nfp: Cleanup old NFP code from the source tree,
 align to latest NFP version

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 2f9920318d341e68780cd578768fef47235a907a

Change-Id: If13917b4b7a392f750b0a5a7da993dcab0b09de1
Signed-off-by: Dmitri Epshtein <dima@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/3085
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Kosta Zertsekel <konszert@marvell.com>
Reviewed-by: Igor Patrik <igorp@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/Makefile                                  |   10 --
 arch/arm/mach-armada370/Makefile                   |  101 +-------------------
 arch/arm/mach-armada370/config/mvRules.mk          |   43 +++++----
 arch/arm/mach-armada370/mv_hal_if/mvSysNeta.c      |    5 +-
 arch/arm/mach-armadaxp/export.c                    |    3 +-
 arch/arm/mach-avantalp/export.c                    |    6 -
 include/linux/mv_nfp.h                             |   23 +++--
 include/linux/netfilter/ipt_NFP.h                  |    4 +-
 include/net/ip6_fib.h                              |    4 +-
 include/net/neighbour.h                            |    4 +-
 include/net/netfilter/nf_conntrack_tuple.h         |    4 +-
 include/net/route.h                                |    4 +-
 net/8021q/vlan.c                                   |   20 +++--
 net/bridge/br_fdb.c                                |   26 +++---
 net/bridge/br_if.c                                 |   16 ++--
 net/bridge/br_private.h                            |    4 +-
 net/core/Makefile                                  |    3 -
 net/core/dev.c                                     |   26 +++---
 net/core/mv_nfp.c                                  |    6 +-
 net/core/neighbour.c                               |   32 ++++---
 net/ipv4/netfilter/Kconfig                         |    5 +-
 .../netfilter/nf_conntrack_l3proto_ipv4_compat.c   |    4 +-
 net/ipv4/route.c                                   |   60 +++++++-----
 net/ipv6/ip6_fib.c                                 |   32 ++++---
 net/ipv6/netfilter/Kconfig                         |    2 +-
 net/ipv6/route.c                                   |    8 +-
 net/netfilter/nf_conntrack_core.c                  |   37 +++----
 net/netfilter/nf_conntrack_proto_tcp.c             |   20 ++--
 net/netfilter/nf_conntrack_standalone.c            |    4 +-
 29 files changed, 225 insertions(+), 291 deletions(-)

diff --git a/arch/arm/Makefile b/arch/arm/Makefile
index 5e271e7..47d2404 100644
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -16,8 +16,6 @@ LDFLAGS_vmlinux	+= --be8
 LDFLAGS_MODULE += --be8
 endif
 
-NFPLIBCMD=$(AR) rcs arch/arm/plat-feroceon/mv_drivers_lsp/mv_neta/nfplib.a arch/arm/plat-feroceon/mv_hal/neta/nfp/*.o arch/arm/plat-feroceon/mv_drivers_lsp/mv_neta/nfp_mgr/*.o
-
 OBJCOPYFLAGS	:=-O binary -R .comment -S
 GZFLAGS		:=-9
 last_kallsyms	:= 3
@@ -319,14 +317,6 @@ archclean:
 bp:;	$(Q)$(MAKE) $(build)=$(boot) MACHINE=$(MACHINE) $(boot)/bootpImage
 i zi:;	$(Q)$(MAKE) $(build)=$(boot) MACHINE=$(MACHINE) $@
 
-nfplib:
-ifeq ($(CONFIG_MV_ETH_NFP_LIB),y)
-	make -f scripts/Makefile.build NFPLIB=y obj=$(PWD)/arch/arm/mach-feroceon-kw2/
-	$(NFPLIBCMD)
-else
-	@echo "CONFIG_MV_ETH_NFP_LIB must be set for creating nfplib.a; exiting"
-endif
-
 define archhelp
   echo  '* zImage        - Compressed kernel image (arch/$(ARCH)/boot/zImage)'
   echo  '  Image         - Uncompressed kernel image (arch/$(ARCH)/boot/Image)'
diff --git a/arch/arm/mach-armada370/Makefile b/arch/arm/mach-armada370/Makefile
index 6c859a9..7349ead 100644
--- a/arch/arm/mach-armada370/Makefile
+++ b/arch/arm/mach-armada370/Makefile
@@ -17,66 +17,6 @@ ifneq ($(MACHINE),)
 include $(srctree)/$(MACHINE)/config/mvRules.mk
 endif
 
-ifdef CONFIG_MV_ETH_NFP
-	NFPOBJS += $(LSP_NFP_MGR_DIR)/mv_nfp_mgr.o $(LSP_NFP_MGR_DIR)/nfp_sysfs.o  $(LSP_NFP_MGR_DIR)/mv_nfp_hooks.o \
-		$(LSP_NET_DEV_DIR)/mv_eth_nfp.o
-endif
-
-ifdef CONFIG_MV_ETH_NFP_FIB
-	NFPOBJS += $(LSP_NFP_MGR_DIR)/nfp_fib_arp_sysfs.o
-ifdef CONFIG_IPV6
-	NFPOBJS += $(LSP_NFP_MGR_DIR)/ipv6_parsing.o $(LSP_NFP_MGR_DIR)/nfp_fib6_arp_sysfs.o
-endif
-endif
-
-ifdef CONFIG_MV_ETH_NFP_CT
-	NFPOBJS += $(LSP_NFP_MGR_DIR)/nfp_ct_sysfs.o
-ifdef CONFIG_IPV6
-	NFPOBJS += $(LSP_NFP_MGR_DIR)/nfp_ct6_sysfs.o
-endif
-endif
-
-ifdef CONFIG_MV_ETH_NFP_CLASSIFY
-	NFPOBJS += $(LSP_NFP_MGR_DIR)/nfp_classification_sysfs.o $(LSP_NFP_MGR_DIR)/nfp_exact_classification_sysfs.o \
-		   $(LSP_NFP_MGR_DIR)/nfp_prio_classification_sysfs.o
-endif
-
-ifdef CONFIG_MV_ETH_NFP_BRIDGE
-	NFPOBJS += $(LSP_NFP_MGR_DIR)/nfp_bridge_sysfs.o
-endif
-
-ifdef CONFIG_MV_ETH_NFP_VLAN
-	NFPOBJS += $(LSP_NFP_MGR_DIR)/nfp_vlan_sysfs.o
-endif
-
-ifdef CONFIG_MV_ETH_NFP_PPP
-	NFPOBJS += $(LSP_NFP_MGR_DIR)/nfp_ppp_sysfs.o
-endif
-
-ifdef CONFIG_MV_ETH_NFP
-	NFPOBJS += $(HAL_ETH_NFP_DIR)/mvNfp.o
-endif
-
-ifdef CONFIG_MV_ETH_NFP_CT
-	NFPOBJS += $(HAL_ETH_NFP_DIR)/mvNfpCt.o
-endif
-
-ifdef CONFIG_MV_ETH_NFP_BRIDGE
-ifdef CONFIG_MV_ETH_NFP_FDB_MODE
-	NFPOBJS += $(HAL_ETH_NFP_DIR)/mvNfpFdb.o
-else
-	NFPOBJS    += $(HAL_ETH_NFP_DIR)/mvNfpBridge.o
-endif
-endif
-
-ifdef CONFIG_MV_ETH_NFP_FIB
-	NFPOBJS += $(HAL_ETH_NFP_DIR)/mvNfpFib.o
-endif
-
-ifeq ($(CONFIG_MV_ETH_NFP),m)
-nfp-objs = $(NFPOBJS)
-obj-m := nfp.o
-endif
 
 # Objects list
 COMMON_OBJS	= $(COMMON_DIR)/mvDebug.o $(COMMON_DIR)/mvCommon.o $(COMMON_DIR)/mvStack.o $(COMMON_DIR)/mvList.o
@@ -129,31 +69,10 @@ armada370-$(CONFIG_MV_INCLUDE_USB) 	+= $(HAL_USB_DIR)/mvUsb.o $(HAL_USB_DIR)/mvU
 					   $(HAL_IF_DIR)/mvSysUsb.o
 armada370-y				+= $(HAL_ETHPHY_DIR)/mvEthPhy.o $(HAL_IF_DIR)/mvSysEthPhy.o
 
-ifneq ($(CONFIG_MV_ETH_NFP),m)
-	armada370-y += $(NFPOBJS)
-endif
-
-# Legacy Giga driver
-ifeq ($(CONFIG_MV_ETH_LEGACY),y)
-armada370-$(CONFIG_MV_ETH_LEGACY)	+= $(HAL_ETH_GBE_DIR)/mvEth.o $(HAL_ETH_GBE_DIR)/mvEthDebug.o \
-					   $(HAL_ETH_GBE_DIR)/mvEthAddrDec.o $(HAL_IF_DIR)/mvSysEth.o
-armada370-$(CONFIG_MV_ETH_NFP)           += $(HAL_ETH_NFP_DIR)/mvNfp.o
-armada370-$(CONFIG_MV_ETH_NFP_NAT) 	+= $(HAL_ETH_NFP_DIR)/mvNfpNat.o
-armada370-$(CONFIG_MV_ETH_NFP_FDB) 	+= $(HAL_ETH_NFP_DIR)/mvNfpFdb.o
-armada370-$(CONFIG_MV_ETH_NFP_PPP) 	+= $(HAL_ETH_NFP_DIR)/mvNfpPpp.o
-armada370-$(CONFIG_MV_ETH_NFP_SEC)	+= $(HAL_ETH_NFP_DIR)/mvNfpSec.o
-
-endif
 
 # NETA Giga driver
-ifeq ($(CONFIG_MV_ETH_NETA),y)
-armada370-$(CONFIG_MV_ETH_NETA)	        += $(HAL_ETH_GBE_DIR)/mvNeta.o $(HAL_ETH_GBE_DIR)/mvNetaDebug.o \
-					   $(HAL_ETH_GBE_DIR)/mvNetaAddrDec.o $(HAL_IF_DIR)/mvSysNeta.o
-armada370-$(CONFIG_MV_ETH_PNC)    	+= $(HAL_ETH_PNC_DIR)/mvTcam.o $(HAL_ETH_PNC_DIR)/mvPnc.o
-armada370-$(CONFIG_MV_ETH_BM) 	        += $(HAL_ETH_BM_DIR)/mvBm.o
-armada370-$(CONFIG_MV_ETH_PMT)	        += $(HAL_ETH_PMT_DIR)/mvPmt.o
-armada370-$(CONFIG_MV_ETH_HWF)           += $(HAL_ETH_GBE_DIR)/mvHwf.o
-endif
+armada370-$(CONFIG_MV_ETH_NETA)         += $(HAL_IF_DIR)/mvSysNeta.o
+obj-$(CONFIG_MV_ETH_NETA)		+= $(LSP_NETA_DIR)/
 
 armada370-$(CONFIG_MV_INCLUDE_CESA)     += $(HAL_CESA_DIR)/mvCesa.o $(HAL_CESA_DIR)/mvCesaDebug.o       \
 					   $(HAL_CESA_DIR)/mvCesaAddrDec.o				\
@@ -178,24 +97,15 @@ armada370-$(CONFIG_MV_CPU_L2_PERF_CNTRS) += $(HAL_CPU_DIR)/mvCpuL2Cntrs.o
 obj-$(CONFIG_MV_INCLUDE_SWITCH) 	+= $(QD_OBJS)
 
 # drivers part
-# Legacy Giga driver
-ifeq ($(CONFIG_MV_ETH_LEGACY),y)
-obj-$(CONFIG_MV_ETH_NFP) 	        += $(LSP_NFP_MGR_DIR)/mv_nfp_mgr.o
-obj-$(CONFIG_MV_ETH_NFP_SEC)            += $(LSP_NFP_MGR_DIR)/mv_nfp_sec.o
-endif
 
-ifeq ($(CONFIG_MV_ETH_NETA),y)
-obj-$(CONFIG_MV_ETH_PNC)                += $(LSP_PNC_DIR)/pnc_sysfs.o
-obj-$(CONFIG_MV_ETH_BM)                 += $(LSP_BM_DIR)/bm_sysfs.o  $(LSP_BM_DIR)/mv_eth_bm.o
-obj-$(CONFIG_MV_ETH_PMT)		+= $(LSP_PMT_DIR)/pmt_sysfs.o
-obj-$(CONFIG_MV_ETH_HWF)        	+= $(LSP_HWF_DIR)/hwf_sysfs.o
-obj-$(CONFIG_MV_ETH_L2FW)               += $(LSP_L2FW_DIR)/l2fw_sysfs.o $(LSP_L2FW_DIR)/mv_eth_l2fw.o
-endif
+
+obj-$(CONFIG_MV_INCLUDE_GIG_ETH)        += $(LSP_PHY_DIR)/phy_sysfs.o
 
 obj-$(CONFIG_MV_USE_XOR_ENGINE) 	+= $(PLAT_DRIVERS)/mv_xor/
 obj-$(CONFIG_MV_CESA) 			+= $(PLAT_DRIVERS)/mv_cesa/
 #obj-y					+= $(PLAT_DRIVERS)/mv_btns/
 obj-y					+= $(PLAT_DRIVERS)/mv_gpio/
+obj-$(CONFIG_MV_DBG_TRACE)              += $(PLAT_DRIVERS)/mv_trace/
 obj-$(CONFIG_MV_INCLUDE_SWITCH)         += $(LSP_SWITCH_DIR)/
 obj-$(CONFIG_SENSORS_ARMADA)		+= hwmon.o
 # The rest of the drivers are compiled through the driver dir directly.
@@ -206,6 +116,5 @@ armada370-$(CONFIG_MV_INCLUDE_USB)    	+= usb.o
 armada370-$(CONFIG_MV_INCLUDE_PCI)	+= pci.o
 armada370-$(CONFIG_MV_INCLUDE_PEX)	+= pex.o
 armada370-$(CONFIG_FEROCEON_PROC) 	+= $(PLAT_DRIVERS)/mv_proc/proc.o
-armada370-$(CONFIG_MV_DBG_TRACE) 	+= dbg-trace.o
 armada370-$(CONFIG_PROC_FS)           += dump_cp15_regs.o
 
diff --git a/arch/arm/mach-armada370/config/mvRules.mk b/arch/arm/mach-armada370/config/mvRules.mk
index e9d618c..19e8f36 100644
--- a/arch/arm/mach-armada370/config/mvRules.mk
+++ b/arch/arm/mach-armada370/config/mvRules.mk
@@ -42,31 +42,29 @@ HAL_TWSI_DIR      = $(HAL_DIR)/twsi
 HAL_TWSI_ARCH_DIR = $(SOC_TWSI_DIR)/Arch$(CPU_ARCH)
 HAL_UART_DIR      = $(HAL_DIR)/uart
 
-ifeq ($(CONFIG_MV_ETH_NETA),y)
-HAL_ETH_DIR       = $(HAL_DIR)/neta
-HAL_ETH_GBE_DIR   = $(HAL_DIR)/neta/gbe
-HAL_ETH_NFP_DIR   = $(HAL_DIR)/neta/nfp
-HAL_ETH_PNC_DIR   = $(HAL_DIR)/neta/pnc
-HAL_ETH_BM_DIR    = $(HAL_DIR)/neta/bm
-HAL_ETH_PMT_DIR   = $(HAL_DIR)/neta/pmt
-LSP_NETWORK_DIR   = $(PLAT_DRIVERS)/mv_neta
-LSP_NET_DEV_DIR   = $(LSP_NETWORK_DIR)/net_dev
-LSP_NFP_MGR_DIR   = $(LSP_NETWORK_DIR)/nfp_mgr
-LSP_PNC_DIR       = $(LSP_NETWORK_DIR)/pnc
-LSP_PMT_DIR       = $(LSP_NETWORK_DIR)/pmt
-LSP_HWF_DIR       = $(LSP_NETWORK_DIR)/hwf
-LSP_L2FW_DIR      = $(LSP_NETWORK_DIR)/l2fw
-LSP_SWITCH_DIR    = $(PLAT_DRIVERS)/mv_switch
-endif
-
-ifeq ($(CONFIG_MV_ETH_LEGACY),y)
+# NETA driver directories
+HAL_NETA_DIR      = $(HAL_DIR)/neta
+HAL_NETA_GBE_DIR  = $(HAL_DIR)/neta/gbe
+HAL_NETA_NFP_DIR  = $(HAL_DIR)/neta/nfp
+HAL_NETA_PNC_DIR  = $(HAL_DIR)/neta/pnc
+HAL_NETA_BM_DIR   = $(HAL_DIR)/neta/bm
+HAL_NETA_PMT_DIR  = $(HAL_DIR)/neta/pmt
+LSP_NETA_DIR      = $(PLAT_DRIVERS)/mv_neta
+LSP_NETA_DEV_DIR  = $(LSP_NETA_DIR)/net_dev
+LSP_NETA_NFP_DIR  = $(LSP_NETA_DIR)/nfp_mgr
+LSP_NETA_PNC_DIR  = $(LSP_NETA_DIR)/pnc
+LSP_NETA_BM_DIR   = $(LSP_NETA_DIR)/bm
+LSP_NETA_PMT_DIR  = $(LSP_NETA_DIR)/pmt
+LSP_NETA_HWF_DIR  = $(LSP_NETA_DIR)/hwf
+LSP_NETA_L2FW_DIR = $(LSP_NETA_DIR)/l2fw
+
+# Legacy network driver directoires
 HAL_ETH_DIR       = $(HAL_DIR)/eth
 HAL_ETH_GBE_DIR   = $(HAL_DIR)/eth/gbe
 HAL_ETH_NFP_DIR	  = $(HAL_DIR)/eth/nfp
 LSP_NETWORK_DIR   = $(PLAT_DRIVERS)/mv_network
 LSP_NET_DEV_DIR   = $(LSP_NETWORK_DIR)/mv_etherent
 LSP_NFP_MGR_DIR   = $(LSP_NETWORK_DIR)/nfp_mgr
-endif
 
 HAL_CPU_DIR       = $(HAL_DIR)/cpu
 HAL_SDMMC_DIR	  = $(HAL_DIR)/sdmmc
@@ -97,6 +95,11 @@ ifeq ($(CONFIG_MV_INCLUDE_NFC),y)
 HAL_NFC_DIR     = $(HAL_DIR)/nfc
 endif
 
+LSP_TRACE_DIR     = $(PLAT_DRIVERS)/mv_trace
+LSP_SWITCH_DIR    = $(PLAT_DRIVERS)/mv_switch
+LSP_PHY_DIR       = $(PLAT_DRIVERS)/mv_phy
+LSP_ERR_DIR       = $(PLAT_DRIVERS)/mv_error
+
 # Environment components
 ARMADA370_FAM_DIR	= armada_370_family
 SOC_DEVICE_DIR		= $(ARMADA370_FAM_DIR)/device
@@ -113,7 +116,7 @@ HAL_IF_DIR		= mv_hal_if
 LSP_PATH_I      	= $(srctree)/arch/arm/mach-armada370
 PLAT_PATH_I		= $(srctree)/arch/arm/plat-armada
 
-HAL_PATH        	= -I$(PLAT_PATH_I)/$(HAL_DIR) -I$(PLAT_PATH_I)/$(HAL_SATA_DIR) -I$(PLAT_PATH_I)/$(HAL_ETH_DIR)
+HAL_PATH        	= -I$(PLAT_PATH_I)/$(HAL_DIR) -I$(PLAT_PATH_I)/$(HAL_SATA_DIR) -I$(PLAT_PATH_I)/$(HAL_NETA_DIR)
 ARMADA370_FAM_PATH	= -I$(LSP_PATH_I)/$(ARMADA370_FAM_DIR)
 QD_PATH         	= -I$(PLAT_PATH_I)/$(HAL_QD_DIR)/Include  -I$(PLAT_PATH_I)/$(HAL_QD_DIR)/Include/h/msApi 	\
 			-I$(PLAT_PATH_I)/$(HAL_QD_DIR)/Include/h/driver -I$(PLAT_PATH_I)/$(HAL_QD_DIR)/Include/h/platform
@@ -125,7 +128,7 @@ LSP_PATH        	= -I$(LSP_PATH_I)
 CONFIG_PATH     	= -I$(LSP_PATH_I)/$(CONFIG_DIR)
 HAL_IF_PATH		= -I$(LSP_PATH_I)/$(HAL_IF)
 DRIVERS_LSP_PATH 	= -I$(PLAT_PATH_I)/$(PLAT_DRIVERS) -I$(PLAT_PATH_I)/$(LSP_NETWORK_DIR)	\
-			  -I$(PLAT_PATH_I)/$(LSP_SWITCH_DIR)
+			  -I$(PLAT_PATH_I)/$(LSP_SWITCH_DIR) -I$(PLAT_PATH_I)/$(LSP_NETA_DIR)
 
 EXTRA_INCLUDE  		= $(OSSERV_PATH) $(COMMON_PATH) $(HAL_PATH)  $(ARMADA370_FAM_PATH) \
 			$(LSP_PATH) $(CONFIG_PATH) $(DRIVERS_LSP_PATH) $(HAL_IF_PATH)
diff --git a/arch/arm/mach-armada370/mv_hal_if/mvSysNeta.c b/arch/arm/mach-armada370/mv_hal_if/mvSysNeta.c
index 4030f25..7697da9 100644
--- a/arch/arm/mach-armada370/mv_hal_if/mvSysNeta.c
+++ b/arch/arm/mach-armada370/mv_hal_if/mvSysNeta.c
@@ -107,10 +107,7 @@ void 	mvSysNetaInit(MV_U32 portMask, MV_U32 cpuMask)
 			addrWinMap[i].attrib &= ~(0x30);
 			addrWinMap[i].attrib |= 0x30;
 		}
-#endif
-		mvOsPrintf("%d - Base 0x%08x , Size = 0x%08x.\n", i,
-                                addrWinMap[i].addrWin.baseLow,
-                                addrWinMap[i].addrWin.size);
+#endif /* CONFIG_MV_SUPPORT_L2_DEPOSIT */
 	}
 	halData.portMask = portMask;
 	halData.cpuMask  = cpuMask;
diff --git a/arch/arm/mach-armadaxp/export.c b/arch/arm/mach-armadaxp/export.c
index 1d01e61..9f74008 100644
--- a/arch/arm/mach-armadaxp/export.c
+++ b/arch/arm/mach-armadaxp/export.c
@@ -206,12 +206,11 @@ EXPORT_SYMBOL(TRC_START);
 EXPORT_SYMBOL(TRC_RELEASE);
 #endif
 
-#ifdef CONFIG_MV_ETH_NFP_MODULE
 #ifdef CONFIG_MV_ETH_BM
 #include "bm/mvBm.h"
 EXPORT_SYMBOL(mvBmVirtBase);
 #endif
+
 #include "mvList.h"
 EXPORT_SYMBOL(mvListCreate);
 EXPORT_SYMBOL(mvListDestroy);
-#endif
diff --git a/arch/arm/mach-avantalp/export.c b/arch/arm/mach-avantalp/export.c
index 50ac81a..324080b 100644
--- a/arch/arm/mach-avantalp/export.c
+++ b/arch/arm/mach-avantalp/export.c
@@ -201,12 +201,6 @@ EXPORT_SYMBOL(TRC_START);
 EXPORT_SYMBOL(TRC_RELEASE);
 #endif
 
-#ifdef CONFIG_MV_ETH_NFP_MODULE
-#ifdef CONFIG_MV_ETH_BM
-#include "bm/mvBm.h"
-EXPORT_SYMBOL(mvBmVirtBase);
-#endif
 #include "mvList.h"
 EXPORT_SYMBOL(mvListCreate);
 EXPORT_SYMBOL(mvListDestroy);
-#endif
diff --git a/include/linux/mv_nfp.h b/include/linux/mv_nfp.h
index eec1405..d792373 100644
--- a/include/linux/mv_nfp.h
+++ b/include/linux/mv_nfp.h
@@ -66,15 +66,16 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #ifndef LINUX_MV_NFP_H
 #define LINUX_MV_NFP_H
 
-#ifdef CONFIG_NETFILTER
-#include <net/netfilter/nf_conntrack.h>
-#include <net/netfilter/nf_nat.h>
-#endif
 #include <linux/types.h>
 #include <linux/netdevice.h>
+#include <linux/skbuff.h>
 
+#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)
+#include <net/netfilter/nf_conntrack.h>
+#include <net/netfilter/nf_nat.h>
+#endif
 
-#if defined(CONFIG_MV_ETH_NFP) || defined(CONFIG_MV_ETH_NFP_MODULE)
+#if defined(CONFIG_MV_ETH_NFP)
 
 /* Supported flags */
 #define MV_EXT_L3_VALID_MASK	0x0001
@@ -92,12 +93,15 @@ typedef struct {
 } MV_EXT_PKT_INFO;
 
 struct nfp_core_ops {
-	int (*nfp_rx_ext)(struct net_device *dev, struct sk_buff *skb, MV_EXT_PKT_INFO *pktInfo);
+	int (*nfp_rx)(unsigned int port, void *rx_desc, void *pkt, void *res);
 };
 
 extern struct nfp_core_ops *nfp_core_p;
 int nfp_core_ops_init(void);
 
+#endif /* CONFIG_MV_ETH_NFP */
+
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 struct nfp_hook_ops {
 	int (*nfp_is_learning_enabled)(void);
 
@@ -137,6 +141,11 @@ struct nfp_hook_ops {
 extern struct nfp_hook_ops *nfp_mgr_p;
 int nfp_hook_ops_init(void);
 
-#endif /* CONFIG_MV_ETH_NFP || CONFIG_MV_ETH_NFP_MODULE */
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
+
+#ifdef CONFIG_MV_ETH_NFP_EXT
+int mv_eth_nfp_ext(struct net_device *dev, struct sk_buff *skb, MV_EXT_PKT_INFO *pktInfo);
+#endif /* CONFIG_MV_ETH_NFP_EXT */
+
 
 #endif /* LINUX_MV_NFP_H */
diff --git a/include/linux/netfilter/ipt_NFP.h b/include/linux/netfilter/ipt_NFP.h
index 6e0e11d..b1831e1 100644
--- a/include/linux/netfilter/ipt_NFP.h
+++ b/include/linux/netfilter/ipt_NFP.h
@@ -121,8 +121,8 @@ static inline void nfp_update_tuple_info(struct ipt_nfp_info *dst, struct ipt_nf
 	}
 
 	if (src->flags & IPT_NFP_F_SET_TXQ) {
-		dst->txq_map[src->dscp].txq = src->txq;
-		dst->txq_map[src->dscp].valid = 1;
+		dst->txq_map[src->dscp_txq].txq = src->txq;
+		dst->txq_map[src->dscp_txq].valid = 1;
 	}
 
 	if (src->flags & IPT_NFP_F_SET_TXQ_DEF) {
diff --git a/include/net/ip6_fib.h b/include/net/ip6_fib.h
index c06cf6e..ca71faf 100644
--- a/include/net/ip6_fib.h
+++ b/include/net/ip6_fib.h
@@ -117,10 +117,10 @@ struct rt6_info {
 
 	u8				rt6i_protocol;
 
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 	int				rt6i_iifindex;
 	bool 			nfp;
-#endif /* CONFIG_MV_ETH_NFP_LEARN */
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
 };
 
 static inline struct inet6_dev *ip6_dst_idev(struct dst_entry *dst)
diff --git a/include/net/neighbour.h b/include/net/neighbour.h
index 5a452f0..7601251 100644
--- a/include/net/neighbour.h
+++ b/include/net/neighbour.h
@@ -114,9 +114,9 @@ struct neighbour {
 	const struct neigh_ops	*ops;
 	struct rcu_head		rcu;
 	struct net_device	*dev;
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 	bool 			nfp;
-#endif /* CONFIG_MV_ETH_NFP_LEARN */
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
 	u8			primary_key[0];
 };
 
diff --git a/include/net/netfilter/nf_conntrack_tuple.h b/include/net/netfilter/nf_conntrack_tuple.h
index 5952b32..70f0cb0 100644
--- a/include/net/netfilter/nf_conntrack_tuple.h
+++ b/include/net/netfilter/nf_conntrack_tuple.h
@@ -70,14 +70,14 @@ struct nf_conntrack_tuple {
 		u_int8_t dir;
 	} dst;
 
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 	/* If true, this connection is handled by NFP */
 	bool nfp;
 	int ifindex;
 	bool nfpCapable;
 	bool udpCsum;
 	struct ipt_nfp_info *info;
-#endif /* CONFIG_MV_ETH_NFP_LEARN */
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
 };
 
 struct nf_conntrack_tuple_mask {
diff --git a/include/net/route.h b/include/net/route.h
index fc0ff7a..33e4958 100644
--- a/include/net/route.h
+++ b/include/net/route.h
@@ -70,9 +70,9 @@ struct rtable {
 	struct inet_peer	*peer; /* long-living peer info */
 	struct fib_info		*fi; /* for client ref to shared metrics */
 
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 	bool 			nfp;
-#endif /* CONFIG_MV_ETH_NFP_FIB_LEARN */
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
 };
 
 static inline bool rt_is_input_route(const struct rtable *rt)
diff --git a/net/8021q/vlan.c b/net/8021q/vlan.c
index 6a40086..82bb943 100644
--- a/net/8021q/vlan.c
+++ b/net/8021q/vlan.c
@@ -31,9 +31,11 @@
 #include <net/arp.h>
 #include <linux/rtnetlink.h>
 #include <linux/notifier.h>
-#if defined(CONFIG_MV_ETH_NFP) || defined(CONFIG_MV_ETH_NFP_MODULE)
+
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 #include <linux/mv_nfp.h>
 #endif
+
 #include <net/rtnetlink.h>
 #include <net/net_namespace.h>
 #include <net/netns/generic.h>
@@ -94,10 +96,12 @@ void unregister_vlan_dev(struct net_device *dev, struct list_head *head)
 
 	if (vlan->flags & VLAN_FLAG_GVRP)
 		vlan_gvrp_request_leave(dev);
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 	if (nfp_mgr_p->nfp_hook_vlan_del)
 		nfp_mgr_p->nfp_hook_vlan_del(dev->ifindex);
-#endif /* CONFIG_MV_ETH_NFP_LEARN */
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
+
 	vlan_group_set_device(grp, vlan_id, NULL);
 	/* Because unregister_netdevice_queue() makes sure at least one rcu
 	 * grace period is respected before device freeing,
@@ -259,10 +263,12 @@ static int register_vlan_device(struct net_device *real_dev, u16 vlan_id)
 	err = register_vlan_dev(new_dev);
 	if (err < 0)
 		goto out_free_newdev;
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 	if (nfp_mgr_p->nfp_hook_vlan_add)
 		nfp_mgr_p->nfp_hook_vlan_add(new_dev->ifindex, new_dev, real_dev->ifindex, vlan_id);
-#endif /* CONFIG_MV_ETH_NFP_LEARN */
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
+
 	return 0;
 
 out_free_newdev:
@@ -691,7 +697,7 @@ static void __exit vlan_cleanup_module(void)
 	vlan_gvrp_uninit();
 }
 
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 void vlan_sync(void)
 {
 	struct net_device *dev;
@@ -710,7 +716,7 @@ void vlan_sync(void)
 	rtnl_unlock();
 }
 EXPORT_SYMBOL(vlan_sync);
-#endif /* CONFIG_MV_ETH_NFP_LEARN */
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
 
 
 module_init(vlan_proto_init);
diff --git a/net/bridge/br_fdb.c b/net/bridge/br_fdb.c
index ae0bf51..19def1d 100644
--- a/net/bridge/br_fdb.c
+++ b/net/bridge/br_fdb.c
@@ -24,9 +24,11 @@
 #include <linux/slab.h>
 #include <linux/atomic.h>
 #include <asm/unaligned.h>
-#if defined(CONFIG_MV_ETH_NFP) || defined(CONFIG_MV_ETH_NFP_MODULE)
+
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 #include <linux/mv_nfp.h>
 #endif
+
 #include "br_private.h"
 
 static struct kmem_cache *br_fdb_cache __read_mostly;
@@ -70,14 +72,14 @@ static inline int has_expired(const struct net_bridge *br,
 	if (fdb->is_static)
 		return 0;
 
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 	if (fdb->nfp) {
 		if (nfp_mgr_p->nfp_hook_fdb_rule_age)
 			if (nfp_mgr_p->nfp_hook_fdb_rule_age(fdb->dst->br->dev->ifindex,
 					fdb->dst->dev->ifindex, fdb->addr.addr) > 0)
-			fdb->updated = jiffies + fdb->dst->br->forward_delay;
+				fdb->updated = jiffies + fdb->dst->br->forward_delay;
 	}
-#endif
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
 
 	return time_before_eq(fdb->updated + hold_time(br), jiffies);
 }
@@ -98,13 +100,13 @@ static void fdb_rcu_free(struct rcu_head *head)
 
 static void fdb_delete(struct net_bridge *br, struct net_bridge_fdb_entry *f)
 {
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 	if (f->nfp) {
 		if (nfp_mgr_p->nfp_hook_fdb_rule_del)
 			nfp_mgr_p->nfp_hook_fdb_rule_del(f->dst->br->dev->ifindex,
 					f->dst->dev->ifindex, f->addr.addr);
 	}
-#endif
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
 
 	hlist_del_rcu(&f->hlist);
 	fdb_notify(br, f, RTM_DELNEIGH);
@@ -179,14 +181,14 @@ void br_fdb_cleanup(unsigned long _data)
 			if (f->is_static)
 				continue;
 
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 			if (f->nfp) {
 				if (nfp_mgr_p->nfp_hook_fdb_rule_age)
 					if (nfp_mgr_p->nfp_hook_fdb_rule_age(f->dst->br->dev->ifindex,
 							f->dst->dev->ifindex, f->addr.addr) > 0)
 					f->updated = jiffies + f->dst->br->forward_delay;
 			}
-#endif
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
 
 			this_timer = f->updated + delay;
 			if (time_before_eq(this_timer, jiffies))
@@ -398,12 +400,12 @@ static struct net_bridge_fdb_entry *fdb_create(struct hlist_head *head,
 		fdb->updated = fdb->used = jiffies;
 		hlist_add_head_rcu(&fdb->hlist, head);
 
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 		fdb->nfp = false;
 		if (nfp_mgr_p->nfp_hook_fdb_rule_add)
 			if (!nfp_mgr_p->nfp_hook_fdb_rule_add(fdb->dst->br->dev->ifindex, fdb->dst->dev->ifindex, (u8 *)addr, is_local))
 				fdb->nfp = true;
-#endif
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
 	}
 	return fdb;
 }
@@ -780,7 +782,7 @@ int br_fdb_delete(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg)
 	return err;
 }
 
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 void fdb_sync(void)
 {
 	struct net_device *dev;
@@ -815,4 +817,4 @@ void fdb_sync(void)
 }
 EXPORT_SYMBOL(fdb_sync);
 
-#endif /* CONFIG_MV_ETH_NFP_LEARN */
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
diff --git a/net/bridge/br_if.c b/net/bridge/br_if.c
index 89c2ac2..bcfd05c 100644
--- a/net/bridge/br_if.c
+++ b/net/bridge/br_if.c
@@ -22,9 +22,11 @@
 #include <linux/rtnetlink.h>
 #include <linux/if_ether.h>
 #include <linux/slab.h>
-#if defined(CONFIG_MV_ETH_NFP) || defined(CONFIG_MV_ETH_NFP_MODULE)
+
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 #include <linux/mv_nfp.h>
 #endif
+
 #include <net/sock.h>
 
 #include "br_private.h"
@@ -171,10 +173,10 @@ void br_dev_delete(struct net_device *dev, struct list_head *head)
 
 	list_for_each_entry_safe(p, n, &br->port_list, list) {
 
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 	if (nfp_mgr_p->nfp_hook_br_port_del)
 		nfp_mgr_p->nfp_hook_br_port_del(br->dev->ifindex, p->dev->ifindex);
-#endif /* CONFIG_MV_ETH_NFP_LEARN */
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
 
 		del_nbp(p);
 	}
@@ -183,10 +185,10 @@ void br_dev_delete(struct net_device *dev, struct list_head *head)
 
 	del_timer_sync(&br->gc_timer);
 
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 	if (nfp_mgr_p->nfp_hook_br_del)
 		nfp_mgr_p->nfp_hook_br_del(br->dev->ifindex);
-#endif /* CONFIG_MV_ETH_NFP_LEARN */
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
 
 	br_sysfs_delbr(br->dev);
 	unregister_netdevice_queue(br->dev, head);
@@ -443,10 +445,10 @@ int br_del_if(struct net_bridge *br, struct net_device *dev)
 	if (!p || p->br != br)
 		return -EINVAL;
 
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 	if (nfp_mgr_p->nfp_hook_br_port_del)
 		nfp_mgr_p->nfp_hook_br_port_del(br->dev->ifindex, p->dev->ifindex);
-#endif /* CONFIG_MV_ETH_NFP_LEARN */
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
 
 	del_nbp(p);
 
diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index e3a22cd..5cb1ef1 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -75,9 +75,9 @@ struct net_bridge_fdb_entry
 	unsigned char			is_local;
 	unsigned char			is_static;
 
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 	bool 			nfp;
-#endif /* CONFIG_MV_ETH_NFP_FDB_LEARN */
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
 };
 
 struct net_bridge_port_group {
diff --git a/net/core/Makefile b/net/core/Makefile
index f4b9bad..43b139b 100644
--- a/net/core/Makefile
+++ b/net/core/Makefile
@@ -25,6 +25,3 @@ obj-$(CONFIG_NETPRIO_CGROUP) += netprio_cgroup.o
 ifeq ($(CONFIG_MV_ETH_NFP),y)
 obj-y += mv_nfp.o
 endif
-ifeq ($(CONFIG_MV_ETH_NFP),m)
-obj-y += mv_nfp.o
-endif
diff --git a/net/core/dev.c b/net/core/dev.c
index 5500d1e..3b1c7c8 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -139,9 +139,9 @@
 
 #include "net-sysfs.h"
 
-#if defined(CONFIG_MV_ETH_NFP) || defined(CONFIG_MV_ETH_NFP_MODULE)
+#if defined(CONFIG_MV_ETH_NFP)
 #include <linux/mv_nfp.h>
-#endif
+#endif /* CONFIG_MV_ETH_NFP */
 
 /* Instead of increasing this, you should create a hash table. */
 #define MAX_GRO_SKBS 8
@@ -3179,16 +3179,15 @@ EXPORT_SYMBOL_GPL(netdev_rx_handler_unregister);
 #ifdef CONFIG_MV_ETH_NFP_EXT
 static struct sk_buff *handle_nfp_extrcv(struct sk_buff *skb, struct net_device *dev)
 {
-	if (nfp_core_p->nfp_rx_ext) {
-
-		MV_EXT_PKT_INFO *pktInfo;
+	MV_EXT_PKT_INFO *pktInfo;
 
-		pktInfo = (MV_EXT_PKT_INFO *)&skb->cb;
-		if (pktInfo->flags == 0)
-			pktInfo = NULL;
+	pktInfo = (MV_EXT_PKT_INFO *)&skb->cb;
+	if (pktInfo->flags == 0)
+		pktInfo = NULL;
 
-		if (!nfp_core_p->nfp_rx_ext(skb->dev, skb, pktInfo))
-			return NULL;
+	if (!mv_eth_nfp_ext(skb->dev, skb, pktInfo)) {
+		/* packet processed by NFP */
+		return NULL;
 	}
 	return skb;
 }
@@ -6627,10 +6626,13 @@ static int __init net_dev_init(void)
 	dev_mcast_init();
 	rc = 0;
 
-#if defined(CONFIG_MV_ETH_NFP) || defined(CONFIG_MV_ETH_NFP_MODULE)
+#if defined(CONFIG_MV_ETH_NFP)
 	nfp_core_ops_init();
+#endif /* CONFIG_MV_ETH_NFP */
+
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 	nfp_hook_ops_init();
-#endif /* CONFIG_MV_ETH_NFP || CONFIG_MV_ETH_NFP_MODULE */
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
 
 out:
 	return rc;
diff --git a/net/core/mv_nfp.c b/net/core/mv_nfp.c
index 3b44107..65b1a40 100644
--- a/net/core/mv_nfp.c
+++ b/net/core/mv_nfp.c
@@ -66,8 +66,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include <linux/module.h>
 #include <linux/mv_nfp.h>
 
-struct nfp_core_ops *nfp_core_p = NULL;
-struct nfp_hook_ops *nfp_mgr_p = NULL;
+struct nfp_core_ops *nfp_core_p;
 
 int nfp_core_ops_init(void)
 {
@@ -81,6 +80,8 @@ int nfp_core_ops_init(void)
 }
 EXPORT_SYMBOL(nfp_core_p);
 
+#ifdef CONFIG_MV_ETH_NFP_HOOKS
+struct nfp_hook_ops *nfp_mgr_p;
 int nfp_hook_ops_init(void)
 {
 	nfp_mgr_p = kzalloc(sizeof(struct nfp_hook_ops), GFP_KERNEL);
@@ -93,3 +94,4 @@ int nfp_hook_ops_init(void)
 	return 0;
 }
 EXPORT_SYMBOL(nfp_mgr_p);
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
diff --git a/net/core/neighbour.c b/net/core/neighbour.c
index fba420c..08a8a6f 100644
--- a/net/core/neighbour.c
+++ b/net/core/neighbour.c
@@ -36,9 +36,10 @@
 #include <linux/random.h>
 #include <linux/string.h>
 #include <linux/log2.h>
-#if defined(CONFIG_MV_ETH_NFP) || defined(CONFIG_MV_ETH_NFP_MODULE)
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 #include <linux/mv_nfp.h>
 #endif
+
 #define NEIGH_DEBUG 1
 
 #define NEIGH_PRINTK(x...) printk(x)
@@ -723,14 +724,14 @@ void neigh_destroy(struct neighbour *neigh)
 	if (neigh_del_timer(neigh))
 		printk(KERN_WARNING "Impossible event.\n");
 
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 	if (neigh->nfp) {
 		if (nfp_mgr_p->nfp_hook_arp_delete)
 			nfp_mgr_p->nfp_hook_arp_delete(neigh->tbl->family, neigh->primary_key);
 		NEIGH_PRINTK2("0x%8lx: neigh %p, ref=%d, state=%d, nfp=%d is connected in %s.\n",
-				jiffies, neigh, atomic_read(&neigh->refcnt), neigh->nud_state, neigh->nfp, __func__);
+			jiffies, neigh, atomic_read(&neigh->refcnt), neigh->nud_state, neigh->nfp, __func__);
 	}
-#endif
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
 
 	write_lock_bh(&neigh->lock);
 	__skb_queue_purge(&neigh->arp_queue);
@@ -769,15 +770,18 @@ static void neigh_suspect(struct neighbour *neigh)
  */
 static void neigh_connect(struct neighbour *neigh)
 {
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 	neigh->nfp = false;
 	if (nfp_mgr_p->nfp_hook_arp_add)
 		if (!nfp_mgr_p->nfp_hook_arp_add(neigh->tbl->family, neigh->primary_key, neigh->ha, neigh->dev->ifindex)) {
 			neigh->nfp = true;
-               NEIGH_PRINTK2("0x%8lx: neigh %p, ref=%d, state=%d, nfp=%d is connected in %s.\n",
-                       jiffies, neigh, atomic_read(&neigh->refcnt), neigh->nud_state, neigh->nfp, __func__);
-       }
-#endif /* CONFIG_MV_ETH_NFP_LEARN  */
+
+		NEIGH_PRINTK2("0x%8lx: neigh %p, ref=%d, state=%d, nfp=%d is connected in %s.\n",
+			jiffies, neigh, atomic_read(&neigh->refcnt), neigh->nud_state, neigh->nfp, __func__);
+	}
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
+
 	neigh->output = neigh->ops->connected_output;
 }
 
@@ -824,7 +828,8 @@ static void neigh_periodic_work(struct work_struct *work)
 
 			if (time_before(n->used, n->confirmed))
 				n->used = n->confirmed;
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 			if ((atomic_read(&n->refcnt) == 1) && (state != NUD_FAILED) &&
 				time_after(jiffies, n->used + n->parms->gc_staletime)) {
 				if (n->nfp) {
@@ -836,7 +841,8 @@ static void neigh_periodic_work(struct work_struct *work)
 						jiffies, n, atomic_read(&n->refcnt), n->nud_state, __func__);
 				}
 			}
-#endif /* CONFIG_MV_ETH_NFP_LEARN */
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
+
 			if (atomic_read(&n->refcnt) == 1 &&
 			    (state == NUD_FAILED ||
 			     time_after(jiffies, n->used + n->parms->gc_staletime))) {
@@ -3053,7 +3059,7 @@ EXPORT_SYMBOL(neigh_sysctl_unregister);
 
 #endif	/* CONFIG_SYSCTL */
 
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 void neigh_sync(int family)
 {
 	struct neigh_table *tbl;
@@ -3089,7 +3095,7 @@ void neigh_sync(int family)
 	read_unlock(&neigh_tbl_lock);
 }
 EXPORT_SYMBOL(neigh_sync);
-#endif /* CONFIG_MV_ETH_NFP_LEARN */
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
 
 static int __init neigh_init(void)
 {
diff --git a/net/ipv4/netfilter/Kconfig b/net/ipv4/netfilter/Kconfig
index de567b7..33f7147 100644
--- a/net/ipv4/netfilter/Kconfig
+++ b/net/ipv4/netfilter/Kconfig
@@ -186,9 +186,12 @@ config IP_NF_TARGET_NETMAP
 config IP_NF_TARGET_NFP
 	tristate "NFP target support"
 	default y
-	depends on NF_CONNTRACK_IPV4 && MV_ETH_NFP_CT && MV_ETH_NFP_LEARN
+	depends on NF_CONNTRACK_IPV4 && MV_ETH_NFP_HOOKS
 	help
 	  This target allows to process selected connections in NFP.
+	  NFP modules should be build and loaded before.
+	  External NFP package is required to build NFP modules.
+
 	  To compile it as a module, choose M here.  If unsure, say N.
 
 config IP_NF_TARGET_REDIRECT
diff --git a/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4_compat.c b/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4_compat.c
index 94ae40b..6f2a4dd 100644
--- a/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4_compat.c
+++ b/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4_compat.c
@@ -179,7 +179,7 @@ static int ct_seq_show(struct seq_file *s, void *v)
 	if (ct_show_secctx(s, ct))
 		goto release;
 
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 	if ((ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.nfp) && (ct->tuplehash[IP_CT_DIR_REPLY].tuple.nfp)) {
 		if (seq_printf(s, "[NFP (both)] "))
 			goto release;
@@ -190,7 +190,7 @@ static int ct_seq_show(struct seq_file *s, void *v)
 		if (seq_printf(s, "[NFP (reply)] "))
 			goto release;
 	}
-#endif /* CONFIG_MV_ETH_NFP_LEARN */
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
 
 	if (seq_printf(s, "use=%u\n", atomic_read(&ct->ct_general.use)))
 		goto release;
diff --git a/net/ipv4/route.c b/net/ipv4/route.c
index d33aa0b..a55232e 100644
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@ -92,7 +92,8 @@
 #include <linux/rcupdate.h>
 #include <linux/times.h>
 #include <linux/slab.h>
-#if defined(CONFIG_MV_ETH_NFP) || defined(CONFIG_MV_ETH_NFP_MODULE)
+
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 #include <linux/mv_nfp.h>
 #endif
 #include <linux/prefetch.h>
@@ -663,12 +664,13 @@ static inline int ip_rt_proc_init(void)
 
 static inline void rt_free(struct rtable *rt)
 {
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
-		if (rt->nfp)
-			if (nfp_mgr_p->nfp_hook_fib_rule_del)
-				nfp_mgr_p->nfp_hook_fib_rule_del(AF_INET, (u8 *)(&rt->rt_src), (u8*)(&rt->rt_dst),
-							rt->rt_iif, rt->dst.dev->ifindex);
-#endif /* CONFIG_MV_ETH_NFP_LEARN */
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
+	if (rt->nfp)
+		if (nfp_mgr_p->nfp_hook_fib_rule_del)
+			nfp_mgr_p->nfp_hook_fib_rule_del(AF_INET, (u8 *)(&rt->rt_src),
+				(u8 *)(&rt->rt_dst), rt->rt_iif, rt->dst.dev->ifindex);
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
+
 	call_rcu_bh(&rt->dst.rcu_head, dst_rcu_free);
 }
 
@@ -696,16 +698,19 @@ static int rt_may_expire(struct rtable *rth, unsigned long tmo1, unsigned long t
 {
 	unsigned long age;
 	int ret = 0;
+
 	if (atomic_read(&rth->dst.__refcnt))
 		goto out;
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 	if (rth->nfp) {
 		if (nfp_mgr_p->nfp_hook_fib_rule_age)
 			if (nfp_mgr_p->nfp_hook_fib_rule_age(AF_INET, (u8 *)(&rth->rt_src), (u8 *)(&rth->rt_dst),
 						rth->rt_iif, rth->dst.dev->ifindex))
-			rth->dst.lastuse = jiffies;
+				rth->dst.lastuse = jiffies;
 	}
-#endif /* CONFIG_MV_ETH_NFP_LEARN */
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
+
 	age = jiffies - rth->dst.lastuse;
 	if ((age <= tmo1 && !rt_fast_clean(rth)) ||
 	    (age <= tmo2 && rt_valuable(rth)))
@@ -820,7 +825,7 @@ static void rt_do_flush(struct net *net, int process_context)
 	}
 }
 
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 void nfp_fib_sync(void)
 {
 	struct rtable *rt;
@@ -848,7 +853,7 @@ void nfp_fib_sync(void)
 	}
 }
 EXPORT_SYMBOL(nfp_fib_sync);
-#endif /* CONFIG_MV_ETH_NFP_LEARN */
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
 
 /*
  * While freeing expired entries, we compute average chain length
@@ -2091,9 +2096,11 @@ static int ip_route_input_mc(struct sk_buff *skb, __be32 daddr, __be32 saddr,
 			   IN_DEV_CONF_GET(in_dev, NOPOLICY), false);
 	if (!rth)
 		goto e_nobufs;
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 	rth->nfp = false;
-#endif /* CONFIG_MV_ETH_NFP_LEARN */
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
+
 #ifdef CONFIG_IP_ROUTE_CLASSID
 	rth->dst.tclassid = itag;
 #endif
@@ -2250,15 +2257,16 @@ static int __mkroute_input(struct sk_buff *skb,
 	rth->dst.output = ip_output;
 
 	rt_set_nexthop(rth, NULL, res, res->fi, res->type, itag);
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 	rth->nfp = false;
 	if (!(rth->rt_flags & (RTCF_MULTICAST | RTCF_BROADCAST | RTCF_LOCAL | RTCF_REJECT))) {
 		if (nfp_mgr_p->nfp_hook_fib_rule_add)
 			if (!nfp_mgr_p->nfp_hook_fib_rule_add(AF_INET, (u8 *)(&rth->rt_src), (u8 *)(&rth->rt_dst),
 					(u8 *)(&rth->rt_gateway), rth->rt_iif, rth->dst.dev->ifindex))
-			rth->nfp = true;
+				rth->nfp = true;
 	}
-#endif /* CONFIG_MV_ETH_NFP_LEARN */
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
 
 	*result = rth;
 	err = 0;
@@ -2410,9 +2418,11 @@ local_input:
 			   IN_DEV_CONF_GET(in_dev, NOPOLICY), false);
 	if (!rth)
 		goto e_nobufs;
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 	rth->nfp = false;
-#endif /* CONFIG_MV_ETH_NFP_LEARN */
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
+
 	rth->dst.input= ip_local_deliver;
 	rth->dst.output= ip_rt_bug;
 #ifdef CONFIG_IP_ROUTE_CLASSID
@@ -2623,9 +2633,11 @@ static struct rtable *__mkroute_output(const struct fib_result *res,
 			   IN_DEV_CONF_GET(in_dev, NOXFRM));
 	if (!rth)
 		return ERR_PTR(-ENOBUFS);
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 	rth->nfp = false;
-#endif /* CONFIG_MV_ETH_NFP_LEARN */
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
+
 	rth->dst.output = ip_output;
 
 	rth->rt_key_dst	= orig_daddr;
@@ -2964,9 +2976,11 @@ struct dst_entry *ipv4_blackhole_route(struct net *net, struct dst_entry *dst_or
 		new->dev = ort->dst.dev;
 		if (new->dev)
 			dev_hold(new->dev);
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 		rt->nfp = false;
-#endif /* CONFIG_MV_ETH_NFP_LEARN */
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
+
 		rt->rt_key_dst = ort->rt_key_dst;
 		rt->rt_key_src = ort->rt_key_src;
 		rt->rt_key_tos = ort->rt_key_tos;
diff --git a/net/ipv6/ip6_fib.c b/net/ipv6/ip6_fib.c
index f0228fd..dfc0676 100644
--- a/net/ipv6/ip6_fib.c
+++ b/net/ipv6/ip6_fib.c
@@ -28,9 +28,11 @@
 #include <linux/init.h>
 #include <linux/list.h>
 #include <linux/slab.h>
-#if defined(CONFIG_MV_ETH_NFP) || defined(CONFIG_MV_ETH_NFP_MODULE)
+
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 #include <linux/mv_nfp.h>
 #endif
+
 #include <net/ipv6.h>
 #include <net/ndisc.h>
 #include <net/addrconf.h>
@@ -419,7 +421,7 @@ out:
 }
 
 
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 static int fib6_add_node(struct fib6_walker_t *w)
 {
 	struct rt6_info *rt;
@@ -465,8 +467,7 @@ void nfp_fib6_sync(void)
 
 }
 EXPORT_SYMBOL(nfp_fib6_sync);
-
-#endif /* CONFIG_MV_ETH_NFP_LEARN */
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
 
 /*
  *	Routing Table
@@ -764,7 +765,7 @@ add:
 			fn->fn_flags |= RTN_RTINFO;
 		}
 
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 		rt->nfp = false;
 		if (rt->rt6i_flags & RTF_CACHE)	{
 			if (nfp_mgr_p->nfp_hook_fib_rule_add)
@@ -773,7 +774,7 @@ add:
 						rt->rt6i_iifindex, rt->rt6i_dev->ifindex))
 					rt->nfp = true;
 		}
-#endif
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
 	} else {
 		if (!found) {
 			if (add)
@@ -1312,13 +1313,15 @@ static void fib6_del_route(struct fib6_node *fn, struct rt6_info **rtp,
 	}
 
 	inet6_rt_notify(RTM_DELROUTE, rt, info);
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 	if (rt->rt6i_flags & RTF_CACHE)
 		if (rt->nfp)
 			if (nfp_mgr_p->nfp_hook_fib_rule_del)
 				nfp_mgr_p->nfp_hook_fib_rule_del(AF_INET6, (u8 *)&rt->rt6i_src.addr, (u8 *)&rt->rt6i_dst.addr,
 							rt->rt6i_iifindex, rt->rt6i_dev->ifindex);
-#endif /* CONFIG_MV_ETH_NFP_LEARN */
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
+
 	rt6_release(rt);
 }
 
@@ -1648,14 +1651,15 @@ static int fib6_age(struct rt6_info *rt, void *arg)
 				return -1;
 			}
 		}
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 		if (rt->nfp) {
-+			if (nfp_mgr_p->nfp_hook_fib_rule_age)
-+				if (nfp_mgr_p->nfp_hook_fib_rule_age(AF_INET6, (u8 *)(&rt->rt6i_src.addr), (u8 *)(&rt->rt6i_dst.addr),
-					rt->rt6i_iifindex, rt->rt6i_dev->ifindex))
-				rt->dst.lastuse = now;
+			if (nfp_mgr_p->nfp_hook_fib_rule_age)
+				if (nfp_mgr_p->nfp_hook_fib_rule_age(AF_INET6, (u8 *)(&rt->rt6i_src.addr),
+					(u8 *)(&rt->rt6i_dst.addr), rt->rt6i_iifindex, rt->rt6i_dev->ifindex))
+					rt->dst.lastuse = now;
 		}
-#endif
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
+
 		gc_args.more++;
 	}
 
diff --git a/net/ipv6/netfilter/Kconfig b/net/ipv6/netfilter/Kconfig
index 1f2e00a..0669537 100644
--- a/net/ipv6/netfilter/Kconfig
+++ b/net/ipv6/netfilter/Kconfig
@@ -198,7 +198,7 @@ config IP6_NF_RAW
 config IP6_NF_TARGET_NFP
 	tristate "NFP target support for IPv6"
 	default y
-	depends on NF_CONNTRACK_IPV6 && MV_ETH_NFP_CT && MV_ETH_NFP_LEARN
+	depends on NF_CONNTRACK_IPV6 && MV_ETH_NFP_HOOKS
 	help
 	  This target allows to process selected connections in NFP.
 
diff --git a/net/ipv6/route.c b/net/ipv6/route.c
index 3cfdd55..3d2967d 100644
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -269,9 +269,9 @@ static inline struct rt6_info *ip6_dst_alloc(struct dst_ops *ops,
 		memset(&rt->rt6i_table, 0,
 		       sizeof(*rt) - sizeof(struct dst_entry));
 
-#if defined(CONFIG_MV_ETH_NFP_FIB_LEARN)
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 	rt->nfp = false;
-#endif
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
 
 	return rt;
 }
@@ -869,13 +869,13 @@ restart:
 
 	dst_hold(&rt->dst);
 	if (nrt) {
-#if defined(CONFIG_MV_ETH_NFP_FIB_LEARN)
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 			if ((rt->rt6i_flags & RTF_CACHE)) {
 				ipv6_addr_copy(&rt->rt6i_src.addr, &fl6->saddr);
 				rt->rt6i_src.plen = 128;
 				rt->rt6i_iifindex = fl6->flowi6_iif;
 			}
-#endif /* CONFIG_MV_ETH_NFP_FIB_LEARN */
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
 
 		err = ip6_ins_rt(nrt);
 		if (!err)
diff --git a/net/netfilter/nf_conntrack_core.c b/net/netfilter/nf_conntrack_core.c
index 41b52b3..a18de8d 100644
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@ -32,9 +32,11 @@
 #include <linux/mm.h>
 #include <linux/nsproxy.h>
 #include <linux/rculist_nulls.h>
-#if defined(CONFIG_MV_ETH_NFP) || defined(CONFIG_MV_ETH_NFP_MODULE)
+
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 #include <linux/mv_nfp.h>
 #endif
+
 #include <net/netfilter/nf_conntrack.h>
 #include <net/netfilter/nf_conntrack_l3proto.h>
 #include <net/netfilter/nf_conntrack_l4proto.h>
@@ -304,7 +306,7 @@ static void death_by_timeout(unsigned long ul_conntrack)
 	struct nf_conn *ct = (void *)ul_conntrack;
 	struct nf_conn_tstamp *tstamp;
 
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 	struct nf_conntrack_tuple *t0 = &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple;
 	struct nf_conntrack_tuple *t1 = &ct->tuplehash[IP_CT_DIR_REPLY].tuple;
 	int confirmed_org = 0, confirmed_reply = 0;
@@ -385,7 +387,7 @@ static void death_by_timeout(unsigned long ul_conntrack)
 					ntohs(t1->dst.u.all),
 					t1->dst.protonum);
 	}
-#endif /* CONFIG_MV_ETH_NFP_LEARN */
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
 
 	tstamp = nf_conn_tstamp_find(ct);
 	if (tstamp && tstamp->stop == 0)
@@ -827,7 +829,7 @@ __nf_conntrack_alloc(struct net *net, u16 zone,
 	}
 #endif
 
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 	ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.nfp = false;
 	ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.ifindex = -1;
 	ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.nfpCapable = false;
@@ -837,7 +839,7 @@ __nf_conntrack_alloc(struct net *net, u16 zone,
 	ct->tuplehash[IP_CT_DIR_REPLY].tuple.ifindex = -1;
 	ct->tuplehash[IP_CT_DIR_REPLY].tuple.nfpCapable = false;
 	ct->tuplehash[IP_CT_DIR_REPLY].tuple.info = NULL;
-#endif /* CONFIG_MV_ETH_NFP_LEARN */
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
 
 	/*
 	 * changes to lookup keys must be done before setting refcnt to 1
@@ -867,13 +869,13 @@ void nf_conntrack_free(struct nf_conn *ct)
 {
 	struct net *net = nf_ct_net(ct);
 
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 	if (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.info)
 		kfree(ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.info);
 
 	if (ct->tuplehash[IP_CT_DIR_REPLY].tuple.info)
 		kfree(ct->tuplehash[IP_CT_DIR_REPLY].tuple.info);
-#endif /* CONFIG_MV_ETH_NFP_LEARN */
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
 
 	nf_ct_ext_destroy(ct);
 	atomic_dec(&net->ct.count);
@@ -1592,7 +1594,7 @@ void nf_ct_untracked_status_or(unsigned long bits)
 }
 EXPORT_SYMBOL_GPL(nf_ct_untracked_status_or);
 
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 void nfp_ct_sync(int family)
 {
 	struct nf_conntrack_tuple_hash *h;
@@ -1633,8 +1635,7 @@ void nfp_ct_sync(int family)
 
 			status = ct->status;
 
-#ifdef CONFIG_MV_ETH_NFP_NAT
-			if (status & IPS_NAT_MASK) {
+			if ((status & IPS_NAT_MASK) && nfp_mgr_p->nfp_hook_ct_nat_add) {
 				/* NFP NAT is supported only in IPv4 */
 				if (tuple->src.l3num == AF_INET) {
 					/* status says if the original direction requires SNAT or DNAT (or both) */
@@ -1646,17 +1647,13 @@ void nfp_ct_sync(int family)
 					nf_ct_invert_tuplepr(&target_tuple, &ct->tuplehash[!dir].tuple);
 
 					if ((status & IPS_NAT_MASK) == IPS_DST_NAT) {
-						if (nfp_mgr_p->nfp_hook_ct_nat_add)
-							nfp_mgr_p->nfp_hook_ct_nat_add(tuple, &target_tuple, IP_NAT_MANIP_DST);
+						nfp_mgr_p->nfp_hook_ct_nat_add(tuple, &target_tuple, IP_NAT_MANIP_DST);
 					} else if ((status & IPS_NAT_MASK) == IPS_SRC_NAT) {
-						if (nfp_mgr_p->nfp_hook_ct_nat_add)
-							nfp_mgr_p->nfp_hook_ct_nat_add(tuple, &target_tuple, IP_NAT_MANIP_SRC);
+						nfp_mgr_p->nfp_hook_ct_nat_add(tuple, &target_tuple, IP_NAT_MANIP_SRC);
 					} else {
-						if (nfp_mgr_p->nfp_hook_ct_nat_add)
-							nfp_mgr_p->nfp_hook_ct_nat_add(tuple, &target_tuple, IP_NAT_MANIP_DST);
-							nfp_mgr_p->nfp_hook_ct_nat_add(tuple, &target_tuple, IP_NAT_MANIP_SRC);
+						nfp_mgr_p->nfp_hook_ct_nat_add(tuple, &target_tuple, IP_NAT_MANIP_DST);
+						nfp_mgr_p->nfp_hook_ct_nat_add(tuple, &target_tuple, IP_NAT_MANIP_SRC);
 					}
-
 					continue;
 				} else {
 					/* NFP does not support NAT for IPv6, so nothing to do with this tuple */
@@ -1664,17 +1661,15 @@ void nfp_ct_sync(int family)
 					continue;
 				}
 			}
-#endif /* CONFIG_MV_ETH_NFP_NAT */
 			/* If we got till here, it must be IPT_NFP_FWD */
 			if (nfp_mgr_p->nfp_hook_ct_fwd_add)
 				nfp_mgr_p->nfp_hook_ct_fwd_add(tuple, 1);
 		}
 	}
-
 	spin_unlock_bh(&nf_conntrack_lock);
 }
 EXPORT_SYMBOL(nfp_ct_sync);
-#endif /* CONFIG_MV_ETH_NFP_LEARN */
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
 
 static int nf_conntrack_init_init_net(void)
 {
diff --git a/net/netfilter/nf_conntrack_proto_tcp.c b/net/netfilter/nf_conntrack_proto_tcp.c
index b27586a..7e48835 100644
--- a/net/netfilter/nf_conntrack_proto_tcp.c
+++ b/net/netfilter/nf_conntrack_proto_tcp.c
@@ -820,9 +820,6 @@ static int tcp_packet(struct nf_conn *ct,
 {
 	struct net *net = nf_ct_net(ct);
 	struct nf_conntrack_tuple *tuple;
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
-	struct nf_conntrack_tuple *tupleInverseDir;
-#endif
 	enum tcp_conntrack new_state, old_state;
 	enum ip_conntrack_dir dir;
 	const struct tcphdr *th;
@@ -839,9 +836,7 @@ static int tcp_packet(struct nf_conn *ct,
 	index = get_conntrack_index(th);
 	new_state = tcp_conntracks[dir][index][old_state];
 	tuple = &ct->tuplehash[dir].tuple;
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
-	tupleInverseDir	= &ct->tuplehash[!dir].tuple;
-#endif
+
 	switch (new_state) {
 	case TCP_CONNTRACK_SYN_SENT:
 		if (old_state < TCP_CONNTRACK_TIME_WAIT)
@@ -993,14 +988,19 @@ static int tcp_packet(struct nf_conn *ct,
 		break;
 	}
 
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 	/*
 	 * When connection is handled by NFP, we have to relax TCP tracking
 	 * rules as not all packets goes through Linux conntrack.
 	 */
-	if ((tuple->nfp) || (tupleInverseDir->nfp))
-		goto in_window;
-#endif /* CONFIG_MV_ETH_NFP_LEARN */
+	{
+		struct nf_conntrack_tuple *tupleInverseDir;
+
+		tupleInverseDir	= &ct->tuplehash[!dir].tuple;
+		if ((tuple->nfp) || (tupleInverseDir->nfp))
+			goto in_window;
+	}
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
 
 	if (!tcp_in_window(ct, &ct->proto.tcp, dir, index,
 			   skb, dataoff, th, pf)) {
diff --git a/net/netfilter/nf_conntrack_standalone.c b/net/netfilter/nf_conntrack_standalone.c
index cc08803..df350a5 100644
--- a/net/netfilter/nf_conntrack_standalone.c
+++ b/net/netfilter/nf_conntrack_standalone.c
@@ -245,7 +245,7 @@ static int ct_seq_show(struct seq_file *s, void *v)
 		goto release;
 #endif
 
-#if defined(CONFIG_MV_ETH_NFP_LEARN) || defined(CONFIG_MV_ETH_NFP_LEARN_MODULE)
+#if defined(CONFIG_MV_ETH_NFP_HOOKS)
 	if ((ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.nfp) && (ct->tuplehash[IP_CT_DIR_REPLY].tuple.nfp)) {
 		if (seq_printf(s, "[NFP (both)] "))
 			goto release;
@@ -256,7 +256,7 @@ static int ct_seq_show(struct seq_file *s, void *v)
 		if (seq_printf(s, "[NFP (reply)] "))
 			goto release;
 	}
-#endif /* CONFIG_MV_ETH_NFP_LEARN */
+#endif /* CONFIG_MV_ETH_NFP_HOOKS */
 
 	if (seq_printf(s, "use=%u\n", atomic_read(&ct->ct_general.use)))
 		goto release;
-- 
1.7.5.4

