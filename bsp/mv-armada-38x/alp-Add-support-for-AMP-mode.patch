From 8db89c6e1881177a124961e915710adfe842660e Mon Sep 17 00:00:00 2001
From: Eran Ben-Avi <benavi@marvell.com>
Date: Wed, 2 Oct 2013 18:39:43 +0300
Subject: [PATCH 1009/1825] alp: Add support for AMP mode

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit bb740a8b32aa98298222c10bdef538d5509340c1

Change-Id: I882645920b5ff6c0d7e8ac224002faf04f4dfe98
Signed-off-by: Grzegorz Jaszczyk <jaz@semihalf.com>
Signed-off-by: Eran Ben-Avi <benavi@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/3590
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/common/Makefile                           |    4 +
 arch/arm/common/gic.c                              |   39 +++++
 .../avanta_lp_family/ctrlEnv/mvSemaphore.h         |    3 +
 .../avanta_lp_family/ctrlEnv/mvUnitMap.c           |    5 +
 arch/arm/mach-avantalp/core.c                      |  170 ++++++++++++++++++--
 arch/arm/mach-avantalp/core.h                      |    2 +
 arch/arm/mach-avantalp/mv_hal_if/mvSysXor.c        |   14 ++-
 arch/arm/mach-avantalp/platsmp.c                   |   15 ++
 arch/arm/mach-avantalp/time.c                      |   41 +++++-
 9 files changed, 276 insertions(+), 17 deletions(-)

diff --git a/arch/arm/common/Makefile b/arch/arm/common/Makefile
index 215816f..b1b6628 100644
--- a/arch/arm/common/Makefile
+++ b/arch/arm/common/Makefile
@@ -2,6 +2,10 @@
 # Makefile for the linux kernel.
 #
 
+ifeq ($(CONFIG_ARCH_AVANTA_LP),y)
+include $(srctree)/$(MACHINE)/config/mvRules.mk
+endif
+
 obj-$(CONFIG_ARM_GIC)		+= gic.o
 obj-$(CONFIG_ARM_VIC)		+= vic.o
 obj-$(CONFIG_ICST)		+= icst.o
diff --git a/arch/arm/common/gic.c b/arch/arm/common/gic.c
index 3564c44..88111d8 100644
--- a/arch/arm/common/gic.c
+++ b/arch/arm/common/gic.c
@@ -45,6 +45,17 @@
 #include <asm/mach/irq.h>
 #include <asm/hardware/gic.h>
 
+#ifdef CONFIG_MV_AMP_ENABLE
+#include "common/mvTypes.h"
+#include "ctrlEnv/mvUnitMap.h"
+#include "ctrlEnv/mvSemaphore.h"
+
+#undef raw_spin_lock
+#undef raw_spin_unlock
+#define raw_spin_lock(lock) mvSemaLock(MV_SEMA_IRQ)
+#define raw_spin_unlock(lock) mvSemaUnlock(MV_SEMA_IRQ)
+#endif
+
 union gic_base {
 	void __iomem *common_base;
 	void __percpu __iomem **percpu_base;
@@ -67,7 +78,9 @@ struct gic_chip_data {
 #endif
 };
 
+#ifndef CONFIG_MV_AMP_ENABLE
 static DEFINE_RAW_SPINLOCK(irq_controller_lock);
+#endif
 
 /*
  * Supported arch specific GIC irq extension.
@@ -924,7 +937,33 @@ void __init gic_init_bases(unsigned int gic_nr, int irq_start,
 		gic_init_if_maps(gic);
 
 	gic_chip.flags |= gic_arch_extn.flags;
+
+#ifdef CONFIG_MV_AMP_ENABLE
+	if (mvUnitMapIsMine(MSTR) == MV_TRUE) {
+		/*
+		 * All Dist registers for interrupts > 32 are common for each
+		 * cpu, so only one configuration is needed
+		 */
+		BUG_ON(mvReadAmpReg(MV_SEMA_GIC) != 0);
+		gic_dist_init(gic);
+		mvWriteAmpReg(MV_SEMA_GIC, MV_LOCK_SEMA);
+	} else {
+		/*
+		 *  Wait until master initializes GIC Distributor
+		 */
+		while (mvReadAmpReg(MV_SEMA_GIC) != MV_LOCK_SEMA)
+			;
+	}
+#else
 	gic_dist_init(gic);
+#endif
+
+	/*
+	 * The GIC implements the CPU interface registers independently for
+	 * each CPU interface, and each connected processor accesses these
+	 * registers for the interface it connects to. So gic_cpu_init is
+	 * needed for each CPU
+	 */
 	gic_cpu_init(gic);
 	gic_pm_init(gic);
 }
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvSemaphore.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvSemaphore.h
index 2cd75a8..2cbc793 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvSemaphore.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvSemaphore.h
@@ -85,9 +85,12 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define MV_SEMA_L2		6
 #define MV_SEMA_TWSI		7
 #define MV_SEMA_ADR_WIN		8
+#define MV_SEMA_GIC		9
+#define MV_SEMA_CLOCK_INIT	10
 
 #define MV_SEMA_BARRIER(cpu)	(50 + cpu)
 
+#define MV_LOCK_SEMA		0x10C
 
 MV_BOOL mvSemaLock(MV_32 num);
 MV_BOOL mvSemaTryLock(MV_32 num);
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvUnitMap.c b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvUnitMap.c
index c194503..5ea98b1 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvUnitMap.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvUnitMap.c
@@ -173,6 +173,10 @@ MV_BOOL mvUnitMapSetup(char* cmdLine, STRSTR_FUNCPTR strstr_func)
 	return MV_TRUE;
 }
 
+#if 0
+/*
+ * Exclude unused function from build
+ */
 MV_U32 mvSocUnitMapFillFlagFormTable(void)
 {
 	int i;
@@ -210,6 +214,7 @@ MV_U32 mvSocUnitMapFillFlagFormTable(void)
 
 	return flag;
 }*/
+#endif
 MV_VOID mvUnitMapSetAllMine()
 {
 	int unitIdx;
diff --git a/arch/arm/mach-avantalp/core.c b/arch/arm/mach-avantalp/core.c
index 2c1ec13..d111b7c 100644
--- a/arch/arm/mach-avantalp/core.c
+++ b/arch/arm/mach-avantalp/core.c
@@ -16,6 +16,7 @@
 
 #include <linux/types.h>
 #include <linux/kernel.h>
+#include <linux/ctype.h>
 #include <linux/ioport.h>
 #include <linux/ata_platform.h>
 #include <linux/ethtool.h>
@@ -47,6 +48,7 @@
 #include "cpu/mvCpu.h"
 #include "boardEnv/mvBoardEnvLib.h"
 #include "mvSysHwConfig.h"
+#include "ctrlEnv/mvSemaphore.h"
 
 #ifdef CONFIG_MTD_NAND_NFC
 #include "mv_mtd/nand_nfc.h"
@@ -209,6 +211,58 @@ static int __init mv_rsrc_setup(char *s)
 __setup("mv_rsrc=", mv_rsrc_setup);
 #endif
 
+#ifdef CONFIG_MV_AMP_ENABLE
+unsigned long sh_mem_base = 0, sh_mem_size = 0;
+static int __init mv_shared_mem_setup(char *s)
+{
+	char *delim = strchr(s, ':');
+	char *base_str  = s;
+	char *size_str  = delim + 1;
+	int fail;
+
+	if (delim == NULL) {
+		printk(KERN_WARNING \
+			"AMP: No delimiter in shared memory string %s. use format mv_sh_mem=base:size\n", s);
+		return 1;
+	}
+
+	/*Split the string to base and size strings*/
+	*delim = '\0';
+
+	fail  = kstrtoul(base_str, 16, &sh_mem_base);
+	fail |= kstrtoul(size_str, 16, &sh_mem_size);
+
+	if (fail)
+		printk(KERN_WARNING \
+			"AMP: Bad shared memory string %s:%s. Can't extract valid values\n", base_str,
+				size_str);
+
+	return 1;
+}
+__setup("mv_sh_mem=", mv_shared_mem_setup);
+#endif /* CONFIG_MV_AMP_ENABLE */
+
+#ifdef CONFIG_MV_IPC_DRIVER
+unsigned long ipc_target_cpu;
+static int __init mv_ipc_setup(char *s)
+{
+	int fail;
+
+	while (isspace(*s))
+		s++;
+
+	/* Translate string to integer. If fails return to default*/
+	fail = kstrtoul(s, 10, &ipc_target_cpu);
+	if (fail) {
+		printk(KERN_WARNING "IPC: Received bad target cpu id %s\n", s);
+		ipc_target_cpu = -1;
+	}
+
+	return 1;
+}
+__setup("mv_ipc=", mv_ipc_setup);
+#endif
+
 char *nfcConfig = NULL;
 static int __init nfcConfig_setup(char *s)
 {
@@ -217,6 +271,26 @@ static int __init nfcConfig_setup(char *s)
 }
 __setup("nfcConfig=", nfcConfig_setup);
 
+#ifdef CONFIG_SMP
+unsigned long mv_cpu_count = 2; /* default max xpus */
+static int __init mv_cpu_count_setup(char *s)
+{
+	int fail;
+	unsigned long cpu_count;
+
+	/* Translate string to integer. If fails return to default*/
+	while (isspace(*s))
+		s++;
+
+	fail = kstrtoul(s, 10, &cpu_count);
+	if (fail == 0)
+		set_core_count(cpu_count);
+
+	return 1;
+}
+__setup("mv_cpu_count=", mv_cpu_count_setup);
+#endif /* CONFIG_SMP */
+
 static void __init alp_cpu_mbus_init(void)
 {
 	void __iomem *addr;
@@ -667,14 +741,21 @@ static struct platform_device mv_pp2_ge3_plat = {
 
 static void __init eth_init(void)
 {
-	if ((mvBoardIsEthConnected(0) == MV_TRUE) && (mvCtrlPwrClckGet(ETH_GIG_UNIT_ID, 0)))
-		mv_pp2_giga_pdev_register(&mv_pp2_ge0_plat);
-	if ((mvBoardIsEthConnected(1) == MV_TRUE) && (mvCtrlPwrClckGet(ETH_GIG_UNIT_ID, 1)))
-		mv_pp2_giga_pdev_register(&mv_pp2_ge1_plat);
-	if ((mvBoardIsEthConnected(2) == MV_TRUE) && (mvCtrlPwrClckGet(ETH_GIG_UNIT_ID, 2)))
-		mv_pp2_giga_pdev_register(&mv_pp2_ge2_plat);
+	if (mvUnitMapIsMine(ETH0) == MV_TRUE) {
+		if ((mvBoardIsEthConnected(0) == MV_TRUE) && (mvCtrlPwrClckGet(ETH_GIG_UNIT_ID, 0)))
+			mv_pp2_giga_pdev_register(&mv_pp2_ge0_plat);
+	}
+	if (mvUnitMapIsMine(ETH1) == MV_TRUE) {
+		if ((mvBoardIsEthConnected(1) == MV_TRUE) && (mvCtrlPwrClckGet(ETH_GIG_UNIT_ID, 1)))
+			mv_pp2_giga_pdev_register(&mv_pp2_ge1_plat);
+	}
+	if (mvUnitMapIsMine(ETH2) == MV_TRUE) {
+		if ((mvBoardIsEthConnected(2) == MV_TRUE) && (mvCtrlPwrClckGet(ETH_GIG_UNIT_ID, 2)))
+			mv_pp2_giga_pdev_register(&mv_pp2_ge2_plat);
+	}
 #ifdef CONFIG_MV_INCLUDE_PON
-	mv_pp2_giga_pdev_register(&mv_pp2_ge3_plat);
+	if (mvUnitMapIsMine(ETH3) == MV_TRUE)
+		mv_pp2_giga_pdev_register(&mv_pp2_ge3_plat);
 #endif
 }
 #endif /* CONFIG_MV_ETH_PP2 */
@@ -783,7 +864,8 @@ static struct platform_device mv_switch0_plat_dev = {
 
 static void __init switch_init(void)
 {
-	mv_switch_pdev_register(&mv_switch0_plat_dev);
+	if (mvUnitMapIsMine(MSTR) == MV_TRUE)
+		mv_switch_pdev_register(&mv_switch0_plat_dev);
 }
 #endif /* CONFIG_MV_INCLUDE_SWITCH */
 
@@ -816,6 +898,21 @@ static void __init alp_gpio_init(void)
 	platform_device_register(&mv_gpio);
 }
 
+/***********
+ * IPC NET *
+ ***********/
+
+#ifdef CONFIG_MV_IPC_NET
+static struct platform_device mv_ipc_net = {
+	.name	= "mv_ipc_net",
+	.id		= 0,
+	.num_resources	= 0,
+	.dev    = {
+		.platform_data = (void *)&ipc_target_cpu
+	}
+};
+#endif
+
 /*******************************************************************************
  * RTC
  */
@@ -833,7 +930,8 @@ static struct resource rtc_resource[] = {
 static void __init alp_rtc_init(void)
 {
 #ifdef CONFIG_RTC_DRV_MV
-	platform_device_register_simple("rtc-mv", -1, rtc_resource, 2);
+	if (mvUnitMapIsMine(RTC) == MV_TRUE)
+		platform_device_register_simple("rtc-mv", -1, rtc_resource, 2);
 #endif
 }
 
@@ -1191,6 +1289,36 @@ static void __init alp_xor_init(void)
 #endif
 }
 
+#ifdef CONFIG_MV_AMP_ENABLE
+static int mvAmpInitCpuIf()
+{
+	if (mvUnitMapIsMine(MSTR) == MV_TRUE) {
+
+		BUG_ON(mvReadAmpReg(ADR_WIN_EN_REG) != 0);
+
+		if (mvCpuIfInit(mv_sys_map()) != MV_OK)
+			return 1;
+
+		mvWriteAmpReg(ADR_WIN_EN_REG, 1);
+		printk(KERN_INFO "Initialized Address decode windows\n");
+	} else {
+		/*
+		 *  Wait until master initializes address decode windows
+		 */
+		while (mvReadAmpReg(ADR_WIN_EN_REG) == 0)
+			;
+
+		if (mvCpuIfVerify(mv_sys_map()) != MV_OK)
+			return 1;
+
+		/*verify window decode */
+		printk(KERN_INFO "Verified Address decode windows\n");
+	}
+
+	return 0;
+}
+#endif
+
 /*******************************************************************************
  * SPI
  */
@@ -1307,6 +1435,8 @@ static void *dma_io_sync_buff_virt[CONFIG_NR_CPUS];
 
 void dma_io_sync(void)
 {
+	/* XXX: temporary disabled for AMP */
+#ifndef CONFIG_MV_AMP_ENABLE
 	u32 data;
 	volatile u32 *virt;
 	int cpu = smp_processor_id();
@@ -1329,6 +1459,7 @@ void dma_io_sync(void)
 	do {
 		data = *virt;
 	} while (data);
+#endif
 }
 EXPORT_SYMBOL(dma_io_sync);
 
@@ -1448,6 +1579,11 @@ void __init alp_init_early(void)
 
 static void __init alp_board_init(void)
 {
+#ifdef CONFIG_MV_AMP_ENABLE
+	/* Init Resource sharing */
+	if (mvUnitMapIsRsrcLimited() == MV_FALSE)
+		mvUnitMapSetAllMine();
+#endif
 	mvBoardEnvInit();
 
 	if (mvCtrlEnvInit()) {
@@ -1461,10 +1597,16 @@ static void __init alp_board_init(void)
 #endif
 
 	alp_cpu_mbus_init();
-	alp_l2x0_cache_init();
+
+	if (mvUnitMapIsMine(MSTR) == MV_TRUE)
+		alp_l2x0_cache_init();
 
 	/* Init the CPU windows setting and the access protection windows. */
+#ifdef CONFIG_MV_AMP_ENABLE
+	if (mvAmpInitCpuIf()) {
+#else
 	if (mvCpuIfInit(mv_sys_map())) {
+#endif
 		pr_err("%s: Error: cpu memory windows init failed.\n", __func__);
 	}
 
@@ -1475,13 +1617,19 @@ static void __init alp_board_init(void)
 	alp_iocc_init();
 
 	elf_hwcap &= ~HWCAP_JAVA;
-
+#ifndef CONFIG_MV_UART_PORT
 	alp_init_serial(0);
+#else
+	alp_init_serial(CONFIG_MV_UART_PORT);
+#endif
 
 	mvCpuIfAddDecShow();
 	print_board_info();
 
 	alp_eth_init();
+#ifdef CONFIG_MV_IPC_NET
+	platform_device_register(&mv_ipc_net);
+#endif
 	alp_spi_init();
 	alp_usb_init();
 	alp_xor_init();
diff --git a/arch/arm/mach-avantalp/core.h b/arch/arm/mach-avantalp/core.h
index 0b49b9f..bc9180a 100644
--- a/arch/arm/mach-avantalp/core.h
+++ b/arch/arm/mach-avantalp/core.h
@@ -6,3 +6,5 @@
 
 void alp_irq_init(void);
 void __init mv_usb_init(struct mbus_dram_target_info *dram);
+
+void set_core_count(unsigned int cpu_count);
diff --git a/arch/arm/mach-avantalp/mv_hal_if/mvSysXor.c b/arch/arm/mach-avantalp/mv_hal_if/mvSysXor.c
index 20acd3e..a952af3 100644
--- a/arch/arm/mach-avantalp/mv_hal_if/mvSysXor.c
+++ b/arch/arm/mach-avantalp/mv_hal_if/mvSysXor.c
@@ -68,19 +68,25 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "xor/mvXor.h"
 #include "ctrlEnv/mvCtrlEnvAddrDec.h"
 #include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvUnitMap.h"
 #include "xor/mvXorRegs.h"
 
 MV_VOID mvSysXorInit (void)
 {
 	MV_UNIT_WIN_INFO addrWinMap[MAX_TARGETS + 1];
-	MV_STATUS status;
+	MV_STATUS status, unit;
 
 	status = mvCtrlAddrWinMapBuild(addrWinMap, MAX_TARGETS + 1);
-	if(status == MV_OK)
+	if (status == MV_OK)
 		status = mvXorWinInit(addrWinMap);
 
-	if(status == MV_OK)
-		mvXorHalInit(MV_XOR_MAX_CHAN);
+	if (status == MV_OK) {
+		for (unit = 0; unit < MV_XOR_MAX_UNIT; unit++) {
+			if (mvUnitMapIsMine(XOR0 + unit))
+				mvXorHalInit(unit);
+
+		}
+	}
 	return;
 }
 
diff --git a/arch/arm/mach-avantalp/platsmp.c b/arch/arm/mach-avantalp/platsmp.c
index 1fd3f95..7d88674 100644
--- a/arch/arm/mach-avantalp/platsmp.c
+++ b/arch/arm/mach-avantalp/platsmp.c
@@ -19,12 +19,24 @@
 #include <asm/hardware/gic.h>
 #include "ca9x2.h"
 #include "ctrlEnv/sys/mvCpuIfRegs.h"
+#include "ctrlEnv/mvSemaphore.h"
+#include "include/mach/smp.h"
 
 #include "core.h"
 
+unsigned int master_cpu_id;
 unsigned int group_cpu_mask = ((1 << NR_CPUS) - 1);
 static void __iomem *scu_base = (void __iomem *)(INTER_REGS_VIRT_BASE + A9_MPCORE_SCU);
 
+void __init set_core_count(unsigned int cpu_count)
+{
+	/* Update cpu count */
+	mv_cpu_count = cpu_count;
+
+	/* Update group mask as well */
+	group_cpu_mask = ((1 << cpu_count) - 1) << (hard_smp_processor_id());
+}
+
 /*
  * Initialise the CPU possible map early - this describes the CPUs
  * which may be present or become present in the system.
@@ -33,6 +45,9 @@ void __init smp_init_cpus(void)
 {
 	int i, ncores = scu_get_core_count(scu_base);
 
+	/* Set the HW CPU id of the master core */
+	master_cpu_id  = hard_smp_processor_id();
+
 	if (ncores > nr_cpu_ids) {
 		pr_warn("SMP: %u cores greater than maximum (%u), clipping\n",
 			ncores, nr_cpu_ids);
diff --git a/arch/arm/mach-avantalp/time.c b/arch/arm/mach-avantalp/time.c
index a952a6e..961c487 100644
--- a/arch/arm/mach-avantalp/time.c
+++ b/arch/arm/mach-avantalp/time.c
@@ -29,6 +29,10 @@
 
 #include "boardEnv/mvBoardEnvLib.h"
 #include "cpu/mvCpu.h"
+#include "ctrlEnv/mvUnitMap.h"
+#include "include/mach/smp.h"
+#include "common/mvTypes.h"
+#include "ctrlEnv/mvSemaphore.h"
 
 /* SoC global timer */
 #define TIMER_CTRL		(MV_CNTMR_REGS_OFFSET + 0x0000)
@@ -40,6 +44,11 @@
 #define TIMER_VAL(x)		(MV_CNTMR_REGS_OFFSET + 0x0014 + (8 * x))
 #define TIMER_TURN_25MHZ(x)	(1 << (11 + x))
 
+
+#ifndef CONFIG_MV_AMP_ENABLE
+#define mvSemaLock(MV_SEMA_CLOCK)
+#define mvSemaUnlock(MV_SEMA_CLOCK)
+#endif
 /*
  * Define SoC global timers to be used for event and source timers
  */
@@ -84,6 +93,7 @@ int alp_clkevt_next_event(unsigned long delta, struct clock_event_device *evt)
 
 	local_irq_save(flags);
 
+	mvSemaLock(MV_SEMA_CLOCK);
 	/* Clear and enable clockevent timer interrupt */
 	MV_REG_WRITE(TIMER_CAUSE, TIMER_INT_CLR(t));
 
@@ -94,6 +104,7 @@ int alp_clkevt_next_event(unsigned long delta, struct clock_event_device *evt)
 	u = MV_REG_READ(TIMER_CTRL);
 	u = (u & ~TIMER_RELOAD_EN(t)) | TIMER_EN(t);
 	MV_REG_WRITE(TIMER_CTRL, u);
+	mvSemaUnlock(MV_SEMA_CLOCK);
 
 	local_irq_restore(flags);
 	return 0;
@@ -105,6 +116,7 @@ static void alp_clkevt_mode(enum clock_event_mode mode, struct clock_event_devic
 	u32 u, t = event_timer_id;
 	local_irq_save(flags);
 
+	mvSemaLock(MV_SEMA_CLOCK);
 	if (mode == CLOCK_EVT_MODE_PERIODIC || mode == CLOCK_EVT_MODE_ONESHOT) {
 		/* Setup timer to fire at 1/HZ intervals */
 		MV_REG_WRITE(TIMER_RELOAD(t), ticks_per_jiffy - 1);
@@ -123,6 +135,7 @@ static void alp_clkevt_mode(enum clock_event_mode mode, struct clock_event_devic
 		/* Ack pending timer interrupt */
 		MV_REG_WRITE(TIMER_CAUSE, TIMER_INT_CLR(t));
 	}
+	mvSemaUnlock(MV_SEMA_CLOCK);
 
 	local_irq_restore(flags);
 }
@@ -305,13 +318,37 @@ static void __init alp_timer_init(void)
 	printk("Initializing AvantaLP SoC Timers\n");
 	ticks_per_jiffy = (mv_twd_rate + HZ/2) / HZ;
 
+#ifdef CONFIG_MV_AMP_ENABLE
+	if (mvUnitMapIsMine(MSTR) == MV_TRUE) {
+		if (mvReadAmpReg(MV_SEMA_CLOCK_INIT) != 0)
+			printk(KERN_WARNING "MV_SEMA_CLOCK_INIT != 0\n");
+		alp_clear_timer_config();
+		mvWriteAmpReg(MV_SEMA_CLOCK_INIT, MV_LOCK_SEMA);
+	} else {
+		/* Wait until master clear timers configuration */
+		while (mvReadAmpReg(MV_SEMA_CLOCK_INIT) != MV_LOCK_SEMA)
+			;
+		/*
+		 * MV_SEMA_CLOCK_INIT is used for locking access to common timer
+		 * registers so it have to be clear (unlock)
+		 */
+		mvWriteAmpReg(MV_SEMA_CLOCK_INIT, 0x0);
+	}
+#else
 	alp_clear_timer_config();
+#endif
 
 	/* Define timers used for event and source */
-	event_timer_id = 1;
+#ifdef CONFIG_MV_AMP_ENABLE
+	source_timer_id = (master_cpu_id == 0 ? 0 : 2);
+	event_timer_id = source_timer_id + 1;
+#else
 	source_timer_id = 0;
-
+	event_timer_id = 1;
+#endif
+	mvSemaLock(MV_SEMA_CLOCK);
 	alp_setup_clocksource(source_timer_id, mv_twd_rate);
+	mvSemaUnlock(MV_SEMA_CLOCK);
 	alp_setup_clockevent(IRQ_GLOBAL_TIMER(event_timer_id), mv_twd_rate);
 
 	alp_twd_init();
-- 
1.7.5.4

