From f47ca6a6db4845cb1498edf25efcb09013fab6a9 Mon Sep 17 00:00:00 2001
From: Yehuda Yitschak <yehuday@marvell.com>
Date: Wed, 15 Jan 2014 13:57:19 +0200
Subject: [PATCH 1284/1825] alp: dfev: Introduce ipc_dfev module.

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 4ac2915de425af9727fec730c43c9d25edb38dc7

	The ipc_dfev handles all IPC communications between DFEV telephony driver and
	SDD firmware running on DFEV CPU in AMP mode.

Change-Id: I5ab74e8a6189e936cd8d99bdba6be01aa608ae4b
Signed-off-by: Piotr Ziecik <kosmo@semihalf.com>
Signed-off-by: Yehuda Yitschak <yehuday@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/5160
Tested-by: Star_Automation <star@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/plat-armada/include/plat/ipc_dfev.h       |   82 ++++
 .../plat-armada/mv_drivers_lsp/mv_phone/Makefile   |    4 +-
 .../mv_drivers_lsp/mv_phone/dfev/ipc_dfev.c        |  486 ++++++++++++++++++++
 3 files changed, 571 insertions(+), 1 deletions(-)
 create mode 100644 arch/arm/plat-armada/include/plat/ipc_dfev.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_phone/dfev/ipc_dfev.c

diff --git a/arch/arm/plat-armada/include/plat/ipc_dfev.h b/arch/arm/plat-armada/include/plat/ipc_dfev.h
new file mode 100644
index 0000000..5a20eaf
--- /dev/null
+++ b/arch/arm/plat-armada/include/plat/ipc_dfev.h
@@ -0,0 +1,82 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _IPC_DFEV_H
+#define _IPC_DFEV_H
+
+#define IPC_DFEV_CTRL_BUFFERS		16	/* must be power of 2 */
+#define IPC_DFEV_CTRL_BUFFER_SIZE	64
+
+#define IPC_DFEV_DATA_BUFFERS		8	/* must be power of 2 */
+#define IPC_DFEV_DATA_BUFFER_SAMPLES	80	/* 10 ms */
+
+/* Maximum buffer size for wideband, 2-channel audio */
+#define IPC_DFEV_DATA_BUFFER_SIZE	(2 * 2 * IPC_DFEV_DATA_BUFFER_SAMPLES)
+
+struct ipc_dfev_ctrl_msg {
+	unsigned int	size;
+	unsigned char	payload[IPC_DFEV_CTRL_BUFFER_SIZE];
+};
+
+struct ipc_dfev_ctrl_ops {
+	void (*ipc_dfev_command_callback)(struct ipc_dfev_ctrl_msg *msg);
+	void (*ipc_dfev_event_callback)(struct ipc_dfev_ctrl_msg *msg);
+};
+
+struct ipc_dfev_data_msg {
+	unsigned int	wideband;
+	unsigned short	samples[IPC_DFEV_DATA_BUFFER_SIZE];
+};
+
+struct ipc_dfev_data_ops {
+	void (*ipc_dfev_rx_callback)(struct ipc_dfev_data_msg *msg);
+	void (*ipc_dfev_tx_callback)(struct ipc_dfev_data_msg *msg);
+};
+
+enum ipc_dfev_mode {
+	IPC_DFEV_MODE_INTERRUPT,
+	IPC_DFEV_MODE_POLLING,
+};
+
+/* Control Path Interface */
+extern int ipc_dfev_ctrl_init(enum ipc_dfev_mode mode,
+				struct ipc_dfev_ctrl_ops *ipc_dfev_ctrl_ops);
+extern void ipc_dfev_ctrl_exit(void);
+extern int ipc_dfev_ctrl_poll(void);
+
+extern struct ipc_dfev_ctrl_msg *ipc_dfev_ctrl_msg_get(void);
+extern void ipc_dfev_ctrl_msg_put(struct ipc_dfev_ctrl_msg *msg);
+
+extern int ipc_dfev_send_command(struct ipc_dfev_ctrl_msg *msg);
+extern int ipc_dfev_send_event(struct ipc_dfev_ctrl_msg *msg);
+
+/* Data Path Interface */
+extern int ipc_dfev_data_init(enum ipc_dfev_mode mode,
+				struct ipc_dfev_data_ops *ipc_dfev_data_ops);
+extern void ipc_dfev_data_exit(void);
+extern int ipc_dfev_data_poll_rx(void);
+extern int ipc_dfev_data_poll_tx(void);
+extern int ipc_dfev_data_poll_return(void);
+
+extern struct ipc_dfev_data_msg *ipc_dfev_data_msg_get(void);
+extern void ipc_dfev_data_msg_put(struct ipc_dfev_data_msg *msg);
+
+extern int ipc_dfev_send_rx(struct ipc_dfev_data_msg *msg);
+extern int ipc_dfev_send_rx_return(struct ipc_dfev_data_msg *msg);
+extern int ipc_dfev_send_tx(struct ipc_dfev_data_msg *msg);
+extern int ipc_dfev_send_tx_return(struct ipc_dfev_data_msg *msg);
+
+#endif /* _IPC_DFEV_H */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/Makefile b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/Makefile
index 5c9aa12..e29affe 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/Makefile
@@ -13,6 +13,7 @@ VB_SRC_PATH = ../../mv_hal/voiceband
 LSP_TDM_PATH = tdm
 LSP_SPI_PATH = spi
 LSP_SLIC_PATH = slic
+LSP_DFEV_PATH = dfev
 LSP_TDM_TEST_PATH = tdm/test
 
 obj-$(CONFIG_MV_INCLUDE_TDM) += mv_phone.o
@@ -31,10 +32,11 @@ EXTRA_CFLAGS += -DMV_KERNEL_SLIC_SUPPORT
 # DFEV support
 ifeq ($(CONFIG_LANTIQ_DFEV_SLIC_SUPPORT),y)
 	PHONE_OBJS += $(LSP_SLIC_PATH)/sdd_if.o
+	PHONE_OBJS += $(LSP_DFEV_PATH)/ipc_dfev.o
 endif
 
 # Lantiq support
-ifeq ($(CONFIG_LANTIQ_SLIC_SUPPORT), y)
+ifeq ($(CONFIG_LANTIQ_SLIC_SUPPORT),y)
 	PHONE_OBJS += $(LSP_SLIC_PATH)/drv_dxt_if.o
 endif
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/dfev/ipc_dfev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/dfev/ipc_dfev.c
new file mode 100644
index 0000000..842e09b
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/dfev/ipc_dfev.c
@@ -0,0 +1,486 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <plat/ipc_dfev.h>
+
+#include "mvTypes.h"
+#include "mvOs.h"
+#include "mvDebug.h"
+#include "mvCommon.h"
+#include "mvStack.h"
+#include "mvIpc.h"
+#include "mv_ipc/linux_amp/mv_ipc_os.h"
+#include "mv_ipc/linux_amp/mv_ipc_common.h"
+#include "cpu/mvCpu.h"
+
+#define ipc_attach_chn(linkId, chnId, cpu, ret)	mvIpcAttachChannel(linkId, chnId, cpu, ret)
+#define ipc_dettach_chn(linkId, chnId)		mvIpcDettachChannel(linkId, chnId)
+#define ipc_close_chn(linkId, chnId)		mvIpcCloseChannel(linkId, chnId)
+#define ipc_tx_msg(linkId, chnId, msg)		mvIpcTxMsg(linkId, chnId, msg)
+#define ipc_rx_msg(linkId, chnId)		mvIpcRxMsg(linkId, chnId)
+#define ipc_tx_ready(linkId, chnId)		mvIpcIsTxReady(linkId, chnId)
+#define ipc_release_msg(linkId, chnId, msg)	mvIpcReleaseMsg(linkId, chnId, msg)
+#define ipc_sh_malloc(linkId, size)		mvIpcShmemMalloc(linkId, size)
+#define ipc_open_chn(linkId, chnId, rx_clbk)	mvIpcOpenChannel(linkId, chnId, rx_clbk)
+#define ipc_enable_chn_rx(linkId, chnId)	mvIpcEnableChnRx(linkId, chnId)
+#define ipc_disable_chn_rx(linkId, chnId)	mvIpcDisableChnRx(linkId, chnId)
+#define ipc_virt_to_phys(linkId, virt_addr)	mvIpcOsVirt2Phys(linkId, virt_addr)
+#define ipc_phys_to_virt(linkId, phys_addr)	mvIpcOsPhys2Virt(linkId, phys_addr)
+
+#define IPC_DFEV_SLAVE_TO_MASTER_WAIT_TIME	1
+#define IPC_DFEV_SLAVE_TO_MASTER_WAIT_LOOPS	100
+
+/* IPC Identifiers */
+#define IPC_DFEV_LINK_ID		0
+#define IPC_DFEV_CTRL_CHAN_ID		0
+#define IPC_DFEV_DATA_TX_CHAN_ID	1
+#define IPC_DFEV_DATA_RX_CHAN_ID	2
+#define IPC_DFEV_DATA_RETURN_CHAN_ID	3
+
+/* Message type identifiers */
+#define IPC_DFEV_MSG_TYPE_COMMAND	0
+#define IPC_DFEV_MSG_TYPE_EVENT		1
+#define IPC_DFEV_MSG_TYPE_RX		2
+#define IPC_DFEV_MSG_TYPE_TX		3
+
+struct ipc_dfev_ctrl_buffer {
+	atomic_t			in_use;
+	struct ipc_dfev_ctrl_msg	msg;
+};
+
+struct ipc_dfev_ctrl_pool {
+	spinlock_t			lock;
+	unsigned int			idx;
+	struct ipc_dfev_ctrl_buffer	*fifo[IPC_DFEV_CTRL_BUFFERS];
+};
+
+struct ipc_dfev_data_buffer {
+	atomic_t			in_use;
+	struct ipc_dfev_data_msg	msg;
+};
+
+struct ipc_dfev_data_pool {
+	spinlock_t			lock;
+	unsigned int			idx;
+	struct ipc_dfev_data_buffer	*fifo[IPC_DFEV_DATA_BUFFERS];
+};
+
+static struct ipc_dfev_ctrl_ops *ipc_dfev_ctrl_ops;
+static struct ipc_dfev_data_ops *ipc_dfev_data_ops;
+
+static struct ipc_dfev_ctrl_pool ipc_dfev_ctrl_pool;
+static struct ipc_dfev_data_pool ipc_dfev_data_pool;
+
+#define ipc_dfev_init_pool(ch, perror)					\
+	do {								\
+		unsigned int i;						\
+									\
+		*(perror) = 0;						\
+		spin_lock_init(&(ch)->lock);				\
+									\
+		for (i = 0; i < ARRAY_SIZE((ch)->fifo); i++) {		\
+			(ch)->fifo[i] = ipc_sh_malloc(IPC_DFEV_LINK_ID,	\
+					     sizeof(*((ch)->fifo[i])));	\
+			if ((ch)->fifo[i] == NULL) {			\
+				*(perror) = -ENOMEM;			\
+				break;					\
+			}						\
+									\
+			atomic_set(&(ch)->fifo[i]->in_use, 0);		\
+		}							\
+	} while (0)
+
+#define ipc_dfev_get_buffer(ch, pbuffer)				\
+	do {								\
+		unsigned long flags;					\
+		unsigned int idx;					\
+									\
+		spin_lock_irqsave(&(ch)->lock, flags);			\
+									\
+		idx = (ch)->idx & (ARRAY_SIZE((ch)->fifo) - 1);		\
+		if (atomic_read(&(ch)->fifo[idx]->in_use) == 0) {	\
+			*(pbuffer) = (ch)->fifo[idx];			\
+			atomic_set(&(*(pbuffer))->in_use, 1);		\
+			(ch)->idx += 1;					\
+		}							\
+									\
+		spin_unlock_irqrestore(&(ch)->lock, flags);		\
+	} while (0)
+
+static int ipc_dfev_send(int type, int channel, void *message)
+{
+	MV_IPC_MSG msg;
+
+	msg.type = type;
+	msg.size = 0;
+	msg.ptr = ipc_virt_to_phys(IPC_DFEV_LINK_ID, message);
+
+	if (ipc_tx_msg(IPC_DFEV_LINK_ID, channel, &msg) != MV_OK)
+		return -EAGAIN;
+
+	return 0;
+}
+
+static int ipc_dfev_open_channel(MV_U32 linkId, MV_U32 chId,
+							MV_IPC_RX_CLBK rx_clbk)
+{
+	int attached, counter, status;
+
+	counter = 0;
+	do {
+		status = ipc_open_chn(linkId, chId, rx_clbk);
+		if (status == MV_NOT_STARTED) {
+			if (counter++ >= IPC_DFEV_SLAVE_TO_MASTER_WAIT_LOOPS)
+				return -ENODEV;
+			udelay(IPC_DFEV_SLAVE_TO_MASTER_WAIT_TIME);
+			continue;
+		}
+
+		if (status != MV_OK) {
+			pr_err("IPC DFEV: Failed to open IPC channel %d-%d\n",
+								linkId, chId);
+			return -ENODEV;
+		}
+	} while (status != MV_OK);
+
+	status = ipc_attach_chn(linkId, chId,
+				mvIpcGetlinkRemoteNodeId(linkId), &attached);
+	if (status != MV_OK) {
+		pr_err("IPC DFEV: Failed to attach IPC channel %d-%d\n",
+								linkId, chId);
+		ipc_close_chn(linkId, chId);
+		return -ENODEV;
+	}
+
+	ipc_enable_chn_rx(linkId, chId);
+
+	return 0;
+}
+
+/*
+ * Control Path API
+ */
+int ipc_dfev_ctrl_init(enum ipc_dfev_mode mode,
+					struct ipc_dfev_ctrl_ops *ctrl_ops)
+{
+	if (ctrl_ops == NULL)
+		return -EINVAL;
+
+	/* Wait for IPC link */
+	while (!ipc_tx_ready(IPC_DFEV_LINK_ID, IPC_DFEV_CTRL_CHAN_ID))
+		msleep(25);
+
+	switch (mode) {
+	case IPC_DFEV_MODE_INTERRUPT:
+		ipc_enable_chn_rx(IPC_DFEV_LINK_ID, IPC_DFEV_CTRL_CHAN_ID);
+		break;
+	case IPC_DFEV_MODE_POLLING:
+		ipc_disable_chn_rx(IPC_DFEV_LINK_ID, IPC_DFEV_CTRL_CHAN_ID);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ipc_dfev_ctrl_ops = ctrl_ops;
+	return 0;
+}
+EXPORT_SYMBOL(ipc_dfev_ctrl_init);
+
+void ipc_dfev_ctrl_exit(void)
+{
+	ipc_dfev_ctrl_ops = NULL;
+}
+EXPORT_SYMBOL(ipc_dfev_ctrl_exit);
+
+int ipc_dfev_ctrl_poll(void)
+{
+	return ipc_rx_msg(IPC_DFEV_LINK_ID, IPC_DFEV_CTRL_CHAN_ID);
+}
+EXPORT_SYMBOL(ipc_dfev_ctrl_poll);
+
+struct ipc_dfev_ctrl_msg *ipc_dfev_ctrl_msg_get(void)
+{
+	struct ipc_dfev_ctrl_buffer *buffer = NULL;
+
+	ipc_dfev_get_buffer(&ipc_dfev_ctrl_pool, &buffer);
+
+	if (!buffer)
+		return NULL;
+
+	return &buffer->msg;
+}
+EXPORT_SYMBOL(ipc_dfev_ctrl_msg_get);
+
+void ipc_dfev_ctrl_msg_put(struct ipc_dfev_ctrl_msg *msg)
+{
+	struct ipc_dfev_ctrl_buffer *buffer;
+
+	buffer = container_of(msg, struct ipc_dfev_ctrl_buffer, msg);
+	atomic_set(&buffer->in_use, 0);
+}
+EXPORT_SYMBOL(ipc_dfev_ctrl_msg_put);
+
+int ipc_dfev_send_command(struct ipc_dfev_ctrl_msg *msg)
+{
+	return ipc_dfev_send(IPC_DFEV_MSG_TYPE_COMMAND, IPC_DFEV_CTRL_CHAN_ID, msg);
+}
+EXPORT_SYMBOL(ipc_dfev_send_command);
+
+int ipc_dfev_send_event(struct ipc_dfev_ctrl_msg *msg)
+{
+	return ipc_dfev_send(IPC_DFEV_MSG_TYPE_EVENT, IPC_DFEV_CTRL_CHAN_ID, msg);
+}
+EXPORT_SYMBOL(ipc_dfev_send_event);
+
+static int ipc_dfev_ctrl_msg_handler(MV_IPC_MSG *msg)
+{
+	struct ipc_dfev_ctrl_msg *message;
+
+	message = ipc_phys_to_virt(IPC_DFEV_LINK_ID, msg->ptr);
+
+	switch (msg->type) {
+	case IPC_DFEV_MSG_TYPE_COMMAND:
+		if (ipc_dfev_ctrl_ops && ipc_dfev_ctrl_ops->ipc_dfev_command_callback)
+			ipc_dfev_ctrl_ops->ipc_dfev_command_callback(message);
+		else
+			ipc_dfev_ctrl_msg_put(message);
+		break;
+	case IPC_DFEV_MSG_TYPE_EVENT:
+		if (ipc_dfev_ctrl_ops && ipc_dfev_ctrl_ops->ipc_dfev_event_callback)
+			ipc_dfev_ctrl_ops->ipc_dfev_event_callback(message);
+		else
+			ipc_dfev_ctrl_msg_put(message);
+		break;
+	default:
+		pr_err("IPC DFEV: Unknown ctrl message type %u!\n", msg->type);
+	}
+
+	ipc_release_msg(IPC_DFEV_LINK_ID, IPC_DFEV_CTRL_CHAN_ID, msg);
+	return 0;
+}
+
+/*
+ * Data Path API
+ */
+int ipc_dfev_data_init(enum ipc_dfev_mode mode,
+					struct ipc_dfev_data_ops *data_ops)
+{
+	if (data_ops == NULL)
+		return -EINVAL;
+
+	/* Wait for IPC link */
+	while (!ipc_tx_ready(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_RX_CHAN_ID) ||
+	       !ipc_tx_ready(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_TX_CHAN_ID) ||
+	       !ipc_tx_ready(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_RETURN_CHAN_ID)) {
+		msleep(25);
+	}
+
+	switch (mode) {
+	case IPC_DFEV_MODE_INTERRUPT:
+		ipc_enable_chn_rx(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_RX_CHAN_ID);
+		ipc_enable_chn_rx(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_TX_CHAN_ID);
+		ipc_enable_chn_rx(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_RETURN_CHAN_ID);
+		break;
+	case IPC_DFEV_MODE_POLLING:
+		ipc_disable_chn_rx(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_RX_CHAN_ID);
+		ipc_disable_chn_rx(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_TX_CHAN_ID);
+		ipc_disable_chn_rx(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_RETURN_CHAN_ID);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	ipc_dfev_data_ops = data_ops;
+	return 0;
+}
+EXPORT_SYMBOL(ipc_dfev_data_init);
+
+void ipc_dfev_data_exit(void)
+{
+	ipc_dfev_data_ops = NULL;
+}
+EXPORT_SYMBOL(ipc_dfev_data_exit);
+
+struct ipc_dfev_data_msg *ipc_dfev_data_msg_get(void)
+{
+	struct ipc_dfev_data_buffer *buffer = NULL;
+
+	ipc_dfev_get_buffer(&ipc_dfev_data_pool, &buffer);
+
+	if (!buffer)
+		return NULL;
+
+	return &buffer->msg;
+}
+EXPORT_SYMBOL(ipc_dfev_data_msg_get);
+
+void ipc_dfev_data_msg_put(struct ipc_dfev_data_msg *msg)
+{
+	struct ipc_dfev_data_buffer *buffer;
+
+	buffer = container_of(msg, struct ipc_dfev_data_buffer, msg);
+	atomic_set(&buffer->in_use, 0);
+}
+EXPORT_SYMBOL(ipc_dfev_data_msg_put);
+
+int ipc_dfev_send_tx(struct ipc_dfev_data_msg *msg)
+{
+	return ipc_dfev_send(IPC_DFEV_MSG_TYPE_TX, IPC_DFEV_DATA_TX_CHAN_ID, msg);
+}
+EXPORT_SYMBOL(ipc_dfev_send_tx);
+
+int ipc_dfev_send_rx(struct ipc_dfev_data_msg *msg)
+{
+	return ipc_dfev_send(IPC_DFEV_MSG_TYPE_RX, IPC_DFEV_DATA_RX_CHAN_ID, msg);
+}
+EXPORT_SYMBOL(ipc_dfev_send_rx);
+
+int ipc_dfev_send_tx_return(struct ipc_dfev_data_msg *msg)
+{
+	return ipc_dfev_send(IPC_DFEV_MSG_TYPE_TX, IPC_DFEV_DATA_RETURN_CHAN_ID, msg);
+}
+EXPORT_SYMBOL(ipc_dfev_send_tx_return);
+
+int ipc_dfev_send_rx_return(struct ipc_dfev_data_msg *msg)
+{
+	return ipc_dfev_send(IPC_DFEV_MSG_TYPE_RX, IPC_DFEV_DATA_RETURN_CHAN_ID, msg);
+}
+EXPORT_SYMBOL(ipc_dfev_send_rx_return);
+
+int ipc_dfev_data_poll_rx(void)
+{
+	return ipc_rx_msg(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_RX_CHAN_ID);
+}
+EXPORT_SYMBOL(ipc_dfev_data_poll_rx);
+
+int ipc_dfev_data_poll_tx(void)
+{
+	return ipc_rx_msg(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_TX_CHAN_ID);
+}
+EXPORT_SYMBOL(ipc_dfev_data_poll_tx);
+
+int ipc_dfev_data_poll_return(void)
+{
+	return ipc_rx_msg(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_RETURN_CHAN_ID);
+}
+EXPORT_SYMBOL(ipc_dfev_data_poll_return);
+
+static void ipc_dfev_data_handler(MV_IPC_MSG *msg)
+{
+	struct ipc_dfev_data_msg *message;
+
+	message = ipc_phys_to_virt(IPC_DFEV_LINK_ID, msg->ptr);
+
+	switch (msg->type) {
+	case IPC_DFEV_MSG_TYPE_RX:
+		if (ipc_dfev_data_ops && ipc_dfev_data_ops->ipc_dfev_rx_callback)
+			ipc_dfev_data_ops->ipc_dfev_rx_callback(message);
+		else
+			ipc_dfev_data_msg_put(message);
+		break;
+	case IPC_DFEV_MSG_TYPE_TX:
+		if (ipc_dfev_data_ops && ipc_dfev_data_ops->ipc_dfev_tx_callback)
+			ipc_dfev_data_ops->ipc_dfev_tx_callback(message);
+		else
+			ipc_dfev_data_msg_put(message);
+		break;
+	default:
+		pr_err("IPC DFEV: Unknown data message type %u!\n", msg->type);
+	}
+}
+
+static int ipc_dfev_data_rx(MV_IPC_MSG *msg)
+{
+	ipc_dfev_data_handler(msg);
+	ipc_release_msg(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_RX_CHAN_ID, msg);
+	return 0;
+}
+
+static int ipc_dfev_data_tx(MV_IPC_MSG *msg)
+{
+	ipc_dfev_data_handler(msg);
+	ipc_release_msg(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_TX_CHAN_ID, msg);
+	return 0;
+}
+
+static int ipc_dfev_data_return(MV_IPC_MSG *msg)
+{
+	ipc_dfev_data_handler(msg);
+	ipc_release_msg(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_RETURN_CHAN_ID, msg);
+	return 0;
+}
+
+static int __init ipc_dfev_init_module(void)
+{
+	int error;
+
+	/* Open Command Channel */
+	error = ipc_dfev_open_channel(IPC_DFEV_LINK_ID, IPC_DFEV_CTRL_CHAN_ID, ipc_dfev_ctrl_msg_handler);
+	if (error)
+		goto error0;
+
+	/* Open Data Channels */
+	error = ipc_dfev_open_channel(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_RX_CHAN_ID, ipc_dfev_data_rx);
+	if (error)
+		goto error1;
+
+	error = ipc_dfev_open_channel(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_TX_CHAN_ID, ipc_dfev_data_tx);
+	if (error)
+		goto error2;
+
+	error = ipc_dfev_open_channel(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_RETURN_CHAN_ID, ipc_dfev_data_return);
+	if (error)
+		goto error3;
+
+	/* Allocate shared memory for command channel */
+	ipc_dfev_init_pool(&ipc_dfev_ctrl_pool, &error);
+	if (error) {
+		pr_err("IPC DFEV: Failed to allocate shared memory for IPC link %u\n", IPC_DFEV_LINK_ID);
+		goto error4;
+	}
+
+	/* Allocate shared memory for data channel */
+	ipc_dfev_init_pool(&ipc_dfev_data_pool, &error);
+	if (error) {
+		pr_err("IPC DFEV: Failed to allocate shared memory for IPC link %u!\n", IPC_DFEV_LINK_ID);
+		goto error4;
+	}
+
+	return 0;
+
+error4:
+	ipc_close_chn(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_RETURN_CHAN_ID);
+error3:
+	ipc_close_chn(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_TX_CHAN_ID);
+error2:
+	ipc_close_chn(IPC_DFEV_LINK_ID, IPC_DFEV_DATA_RX_CHAN_ID);
+error1:
+	ipc_close_chn(IPC_DFEV_LINK_ID, IPC_DFEV_CTRL_CHAN_ID);
+error0:
+	return error;
+}
+
+static void __exit ipc_dfev_cleanup_module(void)
+{
+}
+
+module_init(ipc_dfev_init_module);
+module_exit(ipc_dfev_cleanup_module);
+MODULE_DESCRIPTION("Marvell Inter-Processor DFEV Communication Driver");
+MODULE_AUTHOR("Piotr Ziecik <kosmo@semihalf.com>");
+MODULE_LICENSE("GPL");
-- 
1.7.5.4

