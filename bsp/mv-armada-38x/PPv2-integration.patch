From 16cbbd09b78fee22b9d6f0a823b8327d0ff27a87 Mon Sep 17 00:00:00 2001
From: Yoni Farhadian <yonif@marvell.com>
Date: Tue, 19 Feb 2013 18:02:35 +0200
Subject: [PATCH 0474/1825] PPv2 integration

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 55f37509057400b75627ad4094e90679d14cb056

Change-Id: I6b00e40a634b9d5f16611ffd19b96e5f5745ce2c
Reviewed-on: http://vgitil04.il.marvell.com:8080/1174
Reviewed-by: Eran Ben-Avi <benavi@marvell.com>
Tested-by: Eran Ben-Avi <benavi@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../avanta_lp_family/boardEnv/mvBoardEnvLib.c      |   45 +
 .../avanta_lp_family/boardEnv/mvBoardEnvLib.h      |    1 +
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c        |   12 +-
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h       |   31 +-
 arch/arm/plat-armada/mv_hal/pp2/bm/mvBm.c          |  336 ++++
 arch/arm/plat-armada/mv_hal/pp2/bm/mvBm.h          |  148 ++
 arch/arm/plat-armada/mv_hal/pp2/bm/mvBmRegs.h      |  197 ++
 .../plat-armada/mv_hal/pp2/cls/mvPp2Classifier.c   |   96 +
 .../plat-armada/mv_hal/pp2/cls/mvPp2Classifier.h   |  103 +
 arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls2Hw.c  | 1130 +++++++++++
 arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls2Hw.h  |  273 +++
 arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls3Hw.c  | 1340 +++++++++++++
 arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls3Hw.h  |  401 ++++
 arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls4Hw.c  |  601 ++++++
 arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls4Hw.h  |  251 +++
 .../arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsActHw.h |  233 +++
 arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsHw.c   |  909 +++++++++
 arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsHw.h   |  365 ++++
 arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsMcHw.c |  339 ++++
 arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsMcHw.h |  150 ++
 .../plat-armada/mv_hal/pp2/common/mvPp2Common.c    |  112 ++
 .../plat-armada/mv_hal/pp2/common/mvPp2Common.h    |  133 ++
 .../plat-armada/mv_hal/pp2/common/mvPp2ErrCode.h   |  119 ++
 arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2AddrDec.c |  360 ++++
 arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.c     | 1467 ++++++++++++++
 arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.h     |  616 ++++++
 .../arm/plat-armada/mv_hal/pp2/gbe/mvPp2GbeDebug.c |  587 ++++++
 arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2GbeRegs.h |  713 +++++++
 .../arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.c |  644 ++++++
 .../arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.h |  136 ++
 .../plat-armada/mv_hal/pp2/gmac/mvEthGmacRegs.h    |  229 +++
 arch/arm/plat-armada/mv_hal/pp2/plcr/mvPp2PlcrHw.c |  352 ++++
 arch/arm/plat-armada/mv_hal/pp2/plcr/mvPp2PlcrHw.h |  188 ++
 arch/arm/plat-armada/mv_hal/pp2/pme/mvPp2PmeHw.c   |  673 +++++++
 arch/arm/plat-armada/mv_hal/pp2/pme/mvPp2PmeHw.h   |  303 +++
 arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.c     | 2039 ++++++++++++++++++++
 arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.h     |  163 ++
 arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.c   | 1074 +++++++++++
 arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.h   |  842 ++++++++
 39 files changed, 17705 insertions(+), 6 deletions(-)
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/bm/mvBm.c
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/bm/mvBm.h
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/bm/mvBmRegs.h
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Classifier.c
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Classifier.h
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls2Hw.c
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls2Hw.h
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls3Hw.c
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls3Hw.h
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls4Hw.c
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls4Hw.h
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsActHw.h
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsHw.c
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsHw.h
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsMcHw.c
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsMcHw.h
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/common/mvPp2Common.c
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/common/mvPp2Common.h
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/common/mvPp2ErrCode.h
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2AddrDec.c
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.c
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.h
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2GbeDebug.c
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2GbeRegs.h
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.c
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.h
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacRegs.h
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/plcr/mvPp2PlcrHw.c
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/plcr/mvPp2PlcrHw.h
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/pme/mvPp2PmeHw.c
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/pme/mvPp2PmeHw.h
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.c
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.h
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.c
 create mode 100644 arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.h

diff --git a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
index 756821c..b4ae87b 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
@@ -73,7 +73,13 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "pex/mvPex.h"
 #include "pci/mvPci.h"
 #include "device/mvDevice.h"
+
+#if defined(CONFIG_MV_ETH_NETA)
 #include "neta/gbe/mvEthRegs.h"
+#elif defined(CONFIG_MV_ETH_PP2)
+#include "pp2/gbe/mvPp2GbeRegs.h"
+#endif
+
 #include "gpp/mvGppRegs.h"
 
 /* defines  */
@@ -245,6 +251,10 @@ MV_STATUS mvBoardNameGet(char *pNameBuff)
 *******************************************************************************/
 MV_BOOL mvBoardIsPortInSgmii(MV_U32 ethPortNum)
 {
+#if defined(CONFIG_MACH_AVANTA_LP_FPGA)
+	return (ethPortNum == 2);
+#endif
+
 	return MV_FALSE;
 }
 
@@ -292,6 +302,10 @@ MV_32 mvBoardPhyAddrGet(MV_U32 ethPortNum)
 	if (ethPortNum >= board->numBoardMacInfo)
 		return MV_ERROR;
 
+#if defined(CONFIG_MACH_AVANTA_LP_FPGA)
+	return 8;
+#endif
+
 	return board->pBoardMacInfo[ethPortNum].boardEthSmiAddr;
 }
 
@@ -372,10 +386,41 @@ MV_BOARD_MAC_SPEED mvBoardMacSpeedGet(MV_U32 ethPortNum)
 	if (ethPortNum >= board->numBoardMacInfo)
 		return MV_ERROR;
 
+#if defined(CONFIG_MACH_AVANTA_LP_FPGA)
+	return (ethPortNum == 2) ? BOARD_MAC_SPEED_1000M : BOARD_MAC_SPEED_100M;
+#endif
+
 	return board->pBoardMacInfo[ethPortNum].boardMacSpeed;
 }
 
 /*******************************************************************************
+* mvBoardIsPortLb -
+*
+* DESCRIPTION:
+*       This routine returns MV_TRUE for loopback port number or MV_FALSE
+*	For all other options.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE - port is loopback.
+*       MV_FALSE - other.
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsPortLb(MV_U32 ethPortNum)
+{
+#if defined(CONFIG_MACH_AVANTA_LP_FPGA)
+	return (ethPortNum == 2);
+#endif
+
+	return MV_FALSE;
+}
+
+/*******************************************************************************
 * mvBoardTclkGet
 *
 * DESCRIPTION:
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h
index 5de51cc..8646e57 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h
@@ -350,6 +350,7 @@ MV_U16 mvBoardRevGet(MV_VOID);
 MV_STATUS mvBoardNameGet(char *pNameBuff);
 MV_BOOL mvBoardIsPortInSgmii(MV_U32 ethPortNum);
 MV_BOOL mvBoardIsPortInGmii(MV_U32 ethPortNum);
+MV_BOOL mvBoardIsPortLb(MV_U32 ethPortNum);
 MV_32 mvBoardPhyAddrGet(MV_U32 ethPortNum);
 MV_32 mvBoardPhyLinkCryptPortAddrGet(MV_U32 ethPortNum);
 
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
index dc4959b..e50c7a8 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
@@ -78,9 +78,11 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #if defined(MV_INCLUDE_GIG_ETH)
 #if defined(MV_ETH_LEGACY)
 #include "eth/mvEth.h"
-#else
+#elif defined(CONFIG_MV_ETH_NETA)
 #include "neta/gbe/mvNeta.h"
-#endif /* MV_ETH_LEGACY or MV_ETH_NETA */
+#elif defined(CONFIG_MV_ETH_PP2)
+#include "pp2/gbe/mvPp2Gbe.h"
+#endif /* MV_ETH_LEGACY or MV_ETH_NETA  or PP2*/
 #endif
 
 #if defined(MV_INCLUDE_XOR)
@@ -884,9 +886,11 @@ MV_VOID mvCtrlAddrDecShow(MV_VOID)
 #if defined(MV_INCLUDE_GIG_ETH)
 #if defined(MV_ETH_LEGACY)
 	mvUnitAddrDecShow(mvCtrlEthMaxPortGet(), ETH_GIG_UNIT_ID, "ETH", mvEthWinRead);
+#elif defined(CONFIG_MV_ETH_NETA)
+ 	mvUnitAddrDecShow(mvCtrlEthMaxPortGet(), ETH_GIG_UNIT_ID, "ETH", mvNetaWinRead);
 #else
-	mvUnitAddrDecShow(mvCtrlEthMaxPortGet(), ETH_GIG_UNIT_ID, "ETH", mvNetaWinRead);
-#endif /* MV_ETH_LEGACY */
+	mvUnitAddrDecShow(mvCtrlEthMaxPortGet(), ETH_GIG_UNIT_ID, "ETH", mvPp2WinRead);
+#endif /* MV_ETH_LEGACY  or NETA pr PP2 */
 #endif /* MV_INCLUDE_GIG_ETH */
 
 #if defined(MV_INCLUDE_XOR)
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h
index f5e9da0..7732082 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h
@@ -112,7 +112,22 @@ extern "C" {
 #define MV_CPU_PMU_UNIT_SERV_OFFSET(cpu)	(0x22100 + (cpu) * 0x100)
 #define MV_CPU_HW_SEM_OFFSET			(0x20500)
 
-#if defined(MV_ETH_LEGACY)
+#if defined(MV_ETH_PP2)
+
+#define MV_PP2_REG_BASE				(0x80000)
+#define MV_ETH_BASE_ADDR			(0x50000)
+#define LMS_REG_BASE				(MV_ETH_BASE_ADDR)
+#define MIB_COUNTERS_REG_BASE			(MV_ETH_BASE_ADDR + 0x1000)
+#define GOP_MNG_REG_BASE			(MV_ETH_BASE_ADDR + 0x3000)
+#define GOP_REG_BASE(port)			(MV_ETH_BASE_ADDR + 0x4000 + ((port) / 2) * 0x3000 + ((port) % 2) * 0x1000)
+#define MV_PON_REGS_OFFSET			(MV_ETH_BASE_ADDR + 0x8000)
+
+#define MV_ETH_MAX_TCONT			16
+#define MV_PON_PORT_ID				7
+#define MV_ETH_RXQ_TOTAL_NUM			32
+#define MV_VLAN_1_TYPE				0x88A8
+
+#elif defined(MV_ETH_LEGACY)
 	#define MV_ETH_BASE_ADDR		(0x72000)
 #else
 	#define MV_ETH_BASE_ADDR		(0x70000)
@@ -237,6 +252,16 @@ extern "C" {
 
 /* This define describes the maximum number of supported Ethernet ports */
 /* TODO - verify all these numbers */
+
+#if defined(CONFIG_MV_ETH_PP2)
+#define MV_PON_PORT_ID                  	7
+#define MV_ETH_MAX_PORTS                        4
+#define MV_ETH_MAX_RXQ                          16 /* Maximum number of RXQs can be mapped to each port */
+#define MV_ETH_MAX_TXQ                          8
+#define MV_ETH_RXQ_TOTAL_NUM           		32 /* Total number of RXQs for usage by all ports */
+#define MV_ETH_MAX_TCONT 			16 /* Maximum number of TCONTs supported by PON port */
+#define MV_ETH_TX_CSUM_MAX_SIZE                 9800
+#else
 #define MV_ETH_VERSION 				4 /* for Legacy mode */
 #define MV_NETA_VERSION				1 /* for NETA mode */
 #define MV_ETH_MAX_PORTS			4
@@ -245,6 +270,8 @@ extern "C" {
 #define MV_ETH_TX_CSUM_MAX_SIZE 		9800
 #define MV_PNC_TCAM_LINES			1024	/* TCAM num of entries */
 
+#endif /* CONFIG_MV_ETH_PP2 */
+
 #if defined(MV88F78X60) && !defined(MV88F78X60_Z1)
 /* New GMAC module is used */
 #define MV_ETH_GMAC_NEW
@@ -260,7 +287,7 @@ extern "C" {
 
 #define MV_78130_ETH_MAX_PORT			3
 #define MV_78460_ETH_MAX_PORT			4
-#define MV_FPGA_ETH_MAX_PORT			1
+#define MV_FPGA_ETH_MAX_PORT			4
 
 /* This define describes the the support of USB */
 #define MV_USB_VERSION  			1
diff --git a/arch/arm/plat-armada/mv_hal/pp2/bm/mvBm.c b/arch/arm/plat-armada/mv_hal/pp2/bm/mvBm.c
new file mode 100644
index 0000000..003dfae
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/bm/mvBm.c
@@ -0,0 +1,336 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"		/* Should be included before mvSysHwConfig */
+#include "mvTypes.h"
+#include "mv802_3.h"
+#include "mvDebug.h"
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "mvSysEthConfig.h"
+
+#include "mvBm.h"
+
+static MV_BM_POOL	mvBmPools[MV_BM_POOLS];
+
+/* Initialize Hardware Buffer management unit */
+MV_STATUS mvBmInit()
+{
+	int i;
+
+	for (i = 0; i < MV_BM_POOLS; i++) {
+		/* Mask BM all interrupts */
+		mvPp2WrReg(MV_BM_INTR_MASK_REG(i), 0);
+		/* Clear BM cause register */
+		mvPp2WrReg(MV_BM_INTR_CAUSE_REG(i), 0);
+	}
+
+	memset(mvBmPools, 0, sizeof(mvBmPools));
+
+	return MV_OK;
+}
+
+MV_STATUS mvBmPoolControl(int pool, MV_COMMAND cmd)
+{
+	MV_U32 regVal = 0;
+	regVal = mvPp2RdReg(MV_BM_POOL_CTRL_REG(pool));
+
+	switch (cmd) {
+	case MV_START:
+		regVal |= MV_BM_START_MASK;
+		break;
+
+	case MV_STOP:
+		regVal |= MV_BM_STOP_MASK;
+		break;
+
+	default:
+		mvOsPrintf("bmControl: Unknown command %d\n", cmd);
+		return MV_FAIL;
+	}
+	mvPp2WrReg(MV_BM_POOL_CTRL_REG(pool), regVal);
+	return MV_OK;
+}
+
+MV_STATE mvBmPoolStateGet(int pool)
+{
+	MV_U32 regVal;
+	MV_STATE state;
+
+	regVal = mvPp2RdReg(MV_BM_POOL_CTRL_REG(pool));
+
+	if (regVal & MV_BM_STATE_MASK)
+		state = MV_ACTIVE;
+	else
+		state = MV_IDLE;
+
+	return state;
+}
+
+void mvBmPoolEnable(int pool)
+{
+	/* validate poolId */
+	if ((pool < 0) || (pool >= MV_BM_POOLS)) {
+		mvOsPrintf("bmPoolId = %d is invalid \n", pool);
+		return;
+	}
+	/* TODO */
+}
+
+void mvBmPoolDisable(int pool)
+{
+	/* validate poolId */
+	if ((pool < 0) || (pool >= MV_BM_POOLS)) {
+		mvOsPrintf("bmPoolId = %d is invalid \n", pool);
+		return;
+	}
+	/* TODO */
+}
+
+MV_BOOL mvBmPoolIsEnabled(int pool)
+{
+	/* validate poolId */
+	if ((pool < 0) || (pool >= MV_BM_POOLS)) {
+		mvOsPrintf("bmPoolId = %d is invalid \n", pool);
+		return MV_FALSE;
+	}
+	/* TODO */
+
+	return MV_TRUE;
+}
+
+/* Configure BM specific pool of "capacity" size. */
+MV_STATUS mvBmPoolInit(int pool, MV_ULONG physPoolBase, int capacity)
+{
+	MV_BM_POOL	*pBmPool;
+
+	/* validate poolId */
+	if ((pool < 0) || (pool >= MV_BM_POOLS)) {
+		mvOsPrintf("bmPoolId = %d is invalid \n", pool);
+		return MV_BAD_PARAM;
+	}
+	/* poolBase must be 4 byte aligned */
+	if (MV_IS_NOT_ALIGN(physPoolBase, MV_BM_POOL_PTR_ALIGN)) {
+		mvOsPrintf("bmPoolBase = 0x%lx is not aligned 4 bytes\n", physPoolBase);
+		return MV_NOT_ALIGNED;
+	}
+	if (MV_IS_NOT_ALIGN(capacity, 16)) {
+		mvOsPrintf("%s: Illegal pool capacity %d, ", __func__, capacity);
+		capacity = MV_ALIGN_UP(capacity, 16);
+		mvOsPrintf("round to: %d\n", capacity);
+	}
+	/* Minimum pool capacity is 128 entries */
+	if (capacity < MV_BM_POOL_CAP_MIN) {
+		mvOsPrintf("bmPool capacity = %d is smaller than minimum (%d)\n", capacity, MV_BM_POOL_CAP_MIN);
+		return MV_BAD_SIZE;
+	}
+	/* Maximum pool capacity is 16K entries (2^14) */
+	if (capacity > MV_BM_POOL_CAP_MAX) {
+		mvOsPrintf("bmPool capacity = %d is larger than maximum (%d)\n", capacity, MV_BM_POOL_CAP_MAX);
+		return MV_BAD_SIZE;
+	}
+	/* Update data structure */
+	pBmPool = &mvBmPools[pool];
+	if (pBmPool->physAddr) {
+		mvOsPrintf("bmPool = %d is already busy\n", pool);
+		return MV_BUSY;
+	}
+
+	pBmPool->pool = pool;
+	pBmPool->capacity = capacity;
+	pBmPool->physAddr = physPoolBase;
+
+	mvBmPoolControl(pool, MV_STOP);
+
+	/* Set poolBase address */
+	mvPp2WrReg(MV_BM_POOL_BASE_REG(pool), physPoolBase);
+
+	/* Set Pool size */
+	mvPp2WrReg(MV_BM_POOL_SIZE_REG(pool), capacity);
+
+	return MV_OK;
+}
+
+MV_STATUS mvBmPoolBufSizeSet(int pool, int buf_size)
+{
+	MV_BM_POOL *pBmPool;
+
+	/* validate poolId */
+	if ((pool < 0) || (pool >= MV_BM_POOLS)) {
+		mvOsPrintf("bmPoolId = %d is invalid \n", pool);
+		return MV_BAD_PARAM;
+	}
+	pBmPool = &mvBmPools[pool];
+
+	pBmPool->bufSize = buf_size;
+
+	return MV_OK;
+}
+
+MV_STATUS mvBmPoolBufNumUpdate(int pool, int buf_num)
+{
+	MV_BM_POOL *pBmPool;
+
+	/* validate poolId */
+	if ((pool < 0) || (pool >= MV_BM_POOLS)) {
+		mvOsPrintf("bmPoolId = %d is invalid \n", pool);
+		return MV_BAD_PARAM;
+	}
+
+	pBmPool = &mvBmPools[pool];
+	if (pBmPool->bufSize == 0) {
+		mvOsPrintf("bmPoolId = %d has unknown buf_size  \n", pool);
+		return MV_BAD_PARAM;
+	}
+	pBmPool->bufNum += buf_num;
+	return MV_OK;
+}
+
+void mvBmPoolPrint(int pool)
+{
+	MV_BM_POOL *pBmPool;
+
+	/* validate poolId */
+	if ((pool < 0) || (pool >= MV_BM_POOLS)) {
+		mvOsPrintf("bmPoolId = %d is invalid \n", pool);
+		return;
+	}
+
+	pBmPool = &mvBmPools[pool];
+	if (pBmPool->pVirt == NULL) {
+		mvOsPrintf("bmPool = %d is not created yet\n", pool);
+		return;
+	}
+
+	mvOsPrintf("  %2d:     %4d       %4d       %4d      0x%08x\n",
+						pBmPool->pool, pBmPool->capacity, pBmPool->bufSize, pBmPool->bufNum,
+						(unsigned)pBmPool->physAddr);
+}
+
+void mvBmStatus(void)
+{
+	int i;
+
+	mvOsPrintf("BM Pools status\n");
+	mvOsPrintf("pool:    capacity    bufSize    bufNum       physAddr\n");
+	for (i = 0; i < MV_BM_POOLS; i++)
+		mvBmPoolPrint(i);
+}
+
+void mvBmPoolDump(int pool, int mode)
+{
+/*	MV_U32     regVal;
+	MV_ULONG   *pBufAddr;
+	MV_BM_POOL *pBmPool;
+	int setReadIdx, getReadIdx, setWriteIdx, getWriteIdx, freeBuffs, i;
+*/
+	/* validate poolId */
+	if ((pool < 0) || (pool >= MV_BM_POOLS)) {
+		mvOsPrintf("bmPoolId = %d is invalid \n", pool);
+		return;
+	}
+/*
+	pBmPool = &mvBmPools[pool];
+	if (pBmPool->pVirt == NULL) {
+		mvOsPrintf("bmPool = %d is not created yet\n", pool);
+		return;
+	}
+
+	mvOsPrintf("\n[NETA BM: pool=%d, mode=%d]\n", pool, mode);
+
+	mvOsPrintf("poolBase=%p (0x%x), capacity=%d, buf_num=%d, buf_size=%d\n",
+		   pBmPool->pVirt, (unsigned)pBmPool->physAddr, pBmPool->capacity, pBmPool->bufNum, pBmPool->bufSize);
+
+	regVal = MV_REG_READ(MV_BM_POOL_READ_PTR_REG(pool));
+	setReadIdx = ((regVal & MV_BM_POOL_SET_READ_PTR_MASK) >> MV_BM_POOL_SET_READ_PTR_OFFS) / 4;
+	getReadIdx = ((regVal & MV_BM_POOL_GET_READ_PTR_MASK) >> MV_BM_POOL_GET_READ_PTR_OFFS) / 4;
+
+	regVal = MV_REG_READ(MV_BM_POOL_WRITE_PTR_REG(pool));
+	setWriteIdx = ((regVal & MV_BM_POOL_SET_WRITE_PTR_MASK) >> MV_BM_POOL_SET_WRITE_PTR_OFFS) / 4;
+	getWriteIdx = ((regVal & MV_BM_POOL_GET_WRITE_PTR_MASK) >> MV_BM_POOL_GET_WRITE_PTR_OFFS) / 4;
+	if (getWriteIdx >= getReadIdx)
+		freeBuffs = getWriteIdx - getReadIdx;
+	else
+		freeBuffs = (pBmPool->capacity - getReadIdx) + getWriteIdx;
+
+	mvOsPrintf("nextToRead: set=%d, get=%d, nextToWrite: set=%d, get=%d, freeBuffs=%d\n",
+		setReadIdx, getReadIdx, setWriteIdx, getWriteIdx, freeBuffs);
+
+	if (mode > 0) {
+*/
+		/* Print the content of BM pool */
+/*		i = getReadIdx;
+		while (i != getWriteIdx) {
+			pBufAddr = (MV_ULONG *)pBmPool->pVirt + i;
+			mvOsPrintf("%3d. pBufAddr=%p, bufAddr=%08x\n",
+				   i, pBufAddr, (MV_U32)(*pBufAddr));
+			i++;
+			if (i == pBmPool->capacity)
+				i = 0;
+		}
+	}
+*/
+}
+
+
diff --git a/arch/arm/plat-armada/mv_hal/pp2/bm/mvBm.h b/arch/arm/plat-armada/mv_hal/pp2/bm/mvBm.h
new file mode 100644
index 0000000..817d16b
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/bm/mvBm.h
@@ -0,0 +1,148 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __mvBm_h__
+#define __mvBm_h__
+
+/* includes */
+#include "mvTypes.h"
+#include "mvCommon.h"
+#include "mvStack.h"
+#include "mv802_3.h"
+#include "pp2/common/mvPp2Common.h"
+#include "mvBmRegs.h"
+
+typedef struct {
+	int valid;
+	int longPool;
+	int shortPool;
+	int longBufNum;
+	int shortBufNum;
+	int hwfLongPool;
+	int hwfShortPool;
+	int hwfLongBufNum;
+	int hwfShortBufNum;
+
+} MV_BM_CONFIG;
+
+typedef struct {
+	int         pool;
+	int         capacity;
+	int         bufNum;
+	int         bufSize;
+	MV_U32      *pVirt;
+	MV_ULONG    physAddr;
+} MV_BM_POOL;
+
+/* defines */
+
+/* bits[8-9] of address define pool 0-3 */
+#define BM_POOL_ACCESS_OFFS     8
+
+/* INLINE functions */
+static INLINE void mvBmPoolPut(int pool, MV_U32 bufPhysAddr, MV_U32 bufVirtAddr)
+{
+	mvPp2WrReg(MV_BM_VIRT_RLS_REG, bufVirtAddr);
+	mvPp2WrReg(MV_BM_PHY_RLS_REG(pool), bufPhysAddr);
+}
+
+static INLINE void mvBmPoolMcPut(int pool, MV_U32 bufPhysAddr, MV_U32 bufVirtAddr, int mcId, int isForce)
+{
+	MV_U32 regVal = 0;
+
+	regVal |= ((mcId << MV_BM_MC_ID_OFFS) & MV_BM_MC_ID_MASK);
+	if (isForce)
+		regVal |= MV_BM_FORCE_RELEASE_MASK;
+
+	mvPp2WrReg(MV_BM_MC_RLS_REG, regVal);
+	mvBmPoolPut(pool, bufPhysAddr | MV_BM_PHY_RLS_MC_BUFF_MASK, bufVirtAddr);
+}
+
+static INLINE MV_U32 mvBmPoolGet(int pool)
+{
+	MV_U32 bufPhysAddr, bufVirtAddr;
+
+	bufPhysAddr = mvPp2RdReg(MV_BM_PHY_ALLOC_REG(pool));
+	bufVirtAddr = mvPp2RdReg(MV_BM_VIRT_ALLOC_REG);
+
+	return bufVirtAddr;
+}
+
+/* prototypes */
+MV_STATUS mvBmInit(void);
+MV_STATUS mvBmPoolControl(int pool, MV_COMMAND cmd);
+MV_STATE  mvBmPoolStateGet(int pool);
+void      mvBmPoolEnable(int pool);
+void      mvBmPoolDisable(int pool);
+MV_BOOL   mvBmPoolIsEnabled(int pool);
+MV_STATUS mvBmPoolInit(int pool, MV_ULONG physPoolBase, int capacity);
+MV_STATUS mvBmPoolBufNumUpdate(int pool, int buf_num);
+MV_STATUS mvBmPoolBufSizeSet(int pool, int buf_size);
+void      mvBmRegs(void);
+void      mvBmStatus(void);
+void      mvBmPoolDump(int pool, int mode);
+void      mvBmPoolPrint(int pool);
+
+#endif /* __mvBm_h__ */
+
diff --git a/arch/arm/plat-armada/mv_hal/pp2/bm/mvBmRegs.h b/arch/arm/plat-armada/mv_hal/pp2/bm/mvBmRegs.h
new file mode 100644
index 0000000..2b8f219
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/bm/mvBmRegs.h
@@ -0,0 +1,197 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __mvBmRegs_h__
+#define __mvBmRegs_h__
+
+#include "pp2/gbe/mvPp2GbeRegs.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#define MV_BM_POOLS                 8
+#define MV_BM_POOL_CAP_MAX          (16*1024 - MV_BM_POOL_PTR_ALIGN/4)
+#define MV_BM_POOL_CAP_MIN          128
+#define MV_BM_POOL_PTR_ALIGN        128
+
+/* Address of External Buffer Pointers Pool Register */
+#define MV_BM_POOL_BASE_REG(pool)       (MV_PP2_REG_BASE + 0x6000 + ((pool) * 4))
+
+#define MV_BM_POOL_BASE_ADDR_OFFS       7
+#define MV_BM_POOL_BASE_ADDR_MASK       (0x1FFFFF << MV_BM_POOL_BASE_ADDR_OFFS)
+/*-------------------------------------------------------------------------------*/
+
+/* External Buffer Pointers Pool Size Register */
+#define MV_BM_POOL_SIZE_REG(pool)       (MV_PP2_REG_BASE + 0x6040 + ((pool) * 4))
+
+#define MV_BM_POOL_SIZE_OFFS            4
+#define MV_BM_POOL_SIZE_MASK            (0xFFF << MV_BM_POOL_SIZE_OFFS)
+/*-------------------------------------------------------------------------------*/
+
+/* External Buffer Pointers Pool Read pointer Register */
+#define MV_BM_POOL_READ_PTR_REG(pool)   (MV_PP2_REG_BASE + 0x6080 + ((pool) * 4))
+
+#define MV_BM_POOL_GET_READ_PTR_OFFS    4
+#define MV_BM_POOL_GET_READ_PTR_MASK    (0xFFF << MV_BM_POOL_GET_READ_PTR_OFFS)
+/*-------------------------------------------------------------------------------*/
+
+/* External Buffer Pointers Pool Number of Pointers Register */
+#define MV_BM_POOL_PTRS_NUM_REG(pool)	(MV_PP2_REG_BASE + 0x60c0 + ((pool) * 4))
+
+#define MV_BM_POOL_PTRS_NUM_OFFS		4
+#define MV_BM_POOL_PTRS_NUM_MASK		(0xFFF << MV_BM_POOL_PTRS_NUM_OFFS)
+/*-------------------------------------------------------------------------------*/
+
+/* Internal Buffer Pointers Pool RD pointer Register */
+#define MV_BM_BPPI_READ_PTR_REG(pool)   (MV_PP2_REG_BASE + 0x6100 + ((pool) * 4))
+/*-------------------------------------------------------------------------------*/
+
+/* Internal Buffer Pointers Pool Num of pointers Register */
+#define MV_BM_BPPI_PTRS_NUM_REG(pool)   (MV_PP2_REG_BASE + 0x6140 + ((pool) * 4))
+
+#define MV_BM_BPPI_PTR_NUM_OFFS    	0
+#define MV_BM_BPPI_PTR_NUM_MASK	    	(0x7FF << MV_BM_BPPI_PTR_NUM_OFFS)
+
+#define MV_BM_BPPI_PREFETCH_FULL_BIT    16
+#define MV_BM_BPPI_PREFETCH_FULL_MASK	(0x1 << MV_BM_BPPI_PREFETCH_FULL_BIT)
+/*-------------------------------------------------------------------------------*/
+
+/* BM Activation Register */
+#define MV_BM_POOL_CTRL_REG(pool)       (MV_PP2_REG_BASE + 0x6200 + 4 * pool)
+
+#define MV_BM_START_BIT                 0
+#define MV_BM_START_MASK                (1 << MV_BM_START_BIT)
+
+#define MV_BM_STOP_BIT                  1
+#define MV_BM_STOP_MASK                 (1 << MV_BM_STOP_BIT)
+
+#define MV_BM_STATE_BIT                 4
+#define MV_BM_STATE_MASK                (1 << MV_BM_STATE_BIT)
+
+#define MV_BM_LOW_THRESH_OFFS           8
+#define MV_BM_LOW_THRESH_MASK           (0x7F << MV_BM_LOW_THRESH_OFFS)
+#define MV_BM_LOW_THRESH_VALUE(val)     ((val) << MV_BM_LOW_THRESH_OFFS)
+
+#define MV_BM_HIGH_THRESH_OFFS          16
+#define MV_BM_HIGH_THRESH_MASK          (0x7F << MV_BM_HIGH_THRESH_OFFS)
+#define MV_BM_HIGH_THRESH_VALUE(val)    ((val) << MV_BM_HIGH_THRESH_OFFS)
+/*-------------------------------------------------------------------------------*/
+
+/* BM Interrupt Cause Register */
+#define MV_BM_INTR_CAUSE_REG(pool)      (MV_PP2_REG_BASE + 0x6240 + 4 * pool)
+
+#define MV_BM_RELEASED_DELAY_BIT        0
+#define MV_BM_RELEASED_DELAY_MASK       (1 << MV_BM_RELEASED_DELAY_BIT)
+
+#define MV_BM_ALLOC_FAILED_BIT          1
+#define MV_BM_ALLOC_FAILED_MASK         (1 << MV_BM_ALLOC_FAILED_BIT)
+
+#define MV_BM_BPPE_EMPTY_BIT            2
+#define MV_BM_BPPE_EMPTY_MASK           (1 << MV_BM_BPPE_EMPTY_BIT)
+
+#define MV_BM_BPPE_FULL_BIT             3
+#define MV_BM_BPPE_FULL_MASK            (1 << MV_BM_BPPE_FULL_BIT)
+
+#define MV_BM_AVAILABLE_BP_LOW_BIT      4
+#define MV_BM_AVAILABLE_BP_LOW_MASK     (1 << MV_BM_AVAILABLE_BP_LOW_BIT)
+/*-------------------------------------------------------------------------------*/
+
+/* BM interrupt Mask Register */
+#define MV_BM_INTR_MASK_REG(pool)       (MV_PP2_REG_BASE + 0x6280 + 4 * pool)
+/*-------------------------------------------------------------------------------*/
+
+/* BM physical address allocate */
+#define MV_BM_PHY_ALLOC_REG(pool)	(MV_PP2_REG_BASE + 0x6400 + 4 * pool)
+
+/* BM virtual address allocate */
+#define MV_BM_VIRT_ALLOC_REG		(MV_PP2_REG_BASE + 0x6440)
+
+/* BM physical address release */
+#define MV_BM_PHY_RLS_REG(pool)		(MV_PP2_REG_BASE + 0x6480 + 4 * pool)
+
+#define MV_BM_PHY_RLS_MC_BUFF_MASK	(0x1)
+
+/* BM virtual address release */
+#define MV_BM_VIRT_RLS_REG		(MV_PP2_REG_BASE + 0x64c0)
+
+/*-------------------------------------------------------------------------------*/
+
+/* BM MC release */
+#define MV_BM_MC_RLS_REG		(MV_PP2_REG_BASE + 0x64c4)
+
+#define MV_BM_MC_ID_OFFS		0
+#define MV_BM_MC_ID_MASK		(0xfff << MV_BM_MC_ID_OFFS)
+
+#define MV_BM_FORCE_RELEASE_OFFS	12
+#define MV_BM_FORCE_RELEASE_MASK	(0x1 << MV_BM_FORCE_RELEASE_OFFS)
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __mvBmRegs_h__ */
+
diff --git a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Classifier.c b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Classifier.c
new file mode 100644
index 0000000..3e1507c
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Classifier.c
@@ -0,0 +1,96 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#include "mvPp2Classifier.h"
+
+int mvPp2ClassifierDefInit()
+{
+
+	if (mvPp2ClsInit())
+		return MV_ERROR;
+
+	/* WorkAround HW bug */
+	//mvPp2ClsHwLastBitWorkAround();
+#ifdef CONFIG_MV_ETH_PP2_CLS2
+	if (mvPp2ClsC2Init())
+		return MV_ERROR;
+#endif /* CONFIG_MV_ETH_PP2_CLS2 */
+
+#ifdef CONFIG_MV_ETH_PP2_CLS3
+	if (mvPp2ClsC3Init())
+		return MV_ERROR;
+#endif /* CONFIG_MV_ETH_PP2_CLS3 */
+
+#ifdef CONFIG_MV_ETH_PP2_CLS4
+	mvPp2ClsC4HwClearAll();
+#endif /* CONFIG_MV_ETH_PP2_CLS2 */
+
+#ifdef CONFIG_MV_ETH_PP2_CLS_MC
+	mvPp2McHwClearAll();
+#endif /* CONFIG_MV_ETH_PP2_CLS_MC */
+
+	return MV_OK;
+}
+
+
+
diff --git a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Classifier.h b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Classifier.h
new file mode 100644
index 0000000..16884bf
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Classifier.h
@@ -0,0 +1,103 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_PNC_HW_H__
+#define __MV_PNC_HW_H__
+
+#include "mvPp2ClsHw.h"
+#include "mvPp2ClsActHw.h"
+#include "../common/mvPp2ErrCode.h"
+#include "../common/mvPp2Common.h"
+
+#ifdef CONFIG_MV_ETH_PP2_CLS2
+#include "mvPp2Cls2Hw.h"
+#endif
+#ifdef CONFIG_MV_ETH_PP2_CLS3
+#include "mvPp2Cls3Hw.h"
+#endif
+#ifdef CONFIG_MV_ETH_PP2_CLS4
+#include "mvPp2Cls4Hw.h"
+#endif
+#ifdef CONFIG_MV_ETH_PP2_CLS_MC
+#include "mvPp2ClsMcHw.h"
+#endif
+
+/* call to defult init of cls, C2, C3, C4, MC, Clear all HW structure , clean all shadow arrays */
+int mvPp2ClassifierDefInit(void);
+
+/*
+Assign Rx queue to a protocol
+int mvPp2ClassifierProtoRxq(unsigned int proto, unsigned int rxq); rxq to arp
+Assign Rx queue to a vlan priority
+int mvPp2ClassifierVlanPrioRxq(int port, int prio, int rxq);
+int mvPp2Classifier2tupleIp4Rxq(unsigned int eth_port, unsigned int sip, unsigned int dip, int rxq);
+int mvPp2Classifier5tupleIp4Rxq(unsigned int eth_port, unsigned int sip, unsigned int dip, unsigned int ports,
+				unsigned int proto, int rxq);
+int  mvPp2ClassifierIp4DscpRxq(int port, unsigned char dscp, unsigned char mask, int rxq);
+change def rxq per port
+int  mvPp2ClassifierPortRxq(int port, int rxq);
+*/
+
+#endif /*__MV_PNC_HW_H__ */
+
diff --git a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls2Hw.c b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls2Hw.c
new file mode 100644
index 0000000..fcf8a08
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls2Hw.c
@@ -0,0 +1,1130 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#include "mvPp2Cls2Hw.h"
+
+/*-------------------------------------------------------------------------------*/
+/*		Classifier C2 engine QoS table Public APIs			 */
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC2QosHwRead(int tbl_id, int tbl_sel, int tbl_line, MV_PP2_CLS_C2_QOS_ENTRY *qos)
+{
+	unsigned int regVal = 0;
+
+	PTR_VALIDATE(qos);
+
+	POS_RANGE_VALIDATE(tbl_sel, 1); /* one bit */
+	if (tbl_sel == 1) {
+		/*dscp*/
+		/* TODO define 8=DSCP_TBL_NUM  64=DSCP_TBL_LINES */
+		POS_RANGE_VALIDATE(tbl_id, QOS_TBL_NUM_DSCP);
+		POS_RANGE_VALIDATE(tbl_line, QOS_TBL_LINE_NUM_DSCP);
+	} else {
+		/*pri*/
+		/* TODO define 64=PRI_TBL_NUM  8=PRI_TBL_LINES */
+		POS_RANGE_VALIDATE(tbl_id, QOS_TBL_NUM_PRI);
+		POS_RANGE_VALIDATE(tbl_line, QOS_TBL_LINE_NUM_PRI);
+	}
+
+	qos->tbl_id = tbl_id;
+	qos->tbl_sel = tbl_sel;
+	qos->tbl_line = tbl_line;
+
+	/* write index reg */
+	regVal |= (tbl_line << MV_PP2_CLS2_DSCP_PRI_INDEX_LINE_OFF);
+	regVal |= (tbl_sel << MV_PP2_CLS2_DSCP_PRI_INDEX_SEL_OFF);
+	regVal |= (tbl_id << MV_PP2_CLS2_DSCP_PRI_INDEX_TBL_ID_OFF);
+
+	mvPp2WrReg(MV_PP2_CLS2_DSCP_PRI_INDEX_REG, regVal);
+
+	/* read data reg*/
+	qos->data = mvPp2RdReg(MV_PP2_CLS2_QOS_TBL_REG);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC2QosHwWrite(int tbl_id, int tbl_sel, int tbl_line, MV_PP2_CLS_C2_QOS_ENTRY *qos)
+{
+	unsigned int regVal = 0;
+
+	PTR_VALIDATE(qos);
+
+	POS_RANGE_VALIDATE(tbl_sel, 1); /* one bit */
+	if (tbl_sel == 1) {
+		/*dscp*/
+		/* TODO define 8=DSCP_TBL_NUM  64=DSCP_TBL_LINES */
+		POS_RANGE_VALIDATE(tbl_id, QOS_TBL_NUM_DSCP);
+		POS_RANGE_VALIDATE(tbl_line, QOS_TBL_LINE_NUM_DSCP);
+	} else {
+		/*pri*/
+		/* TODO define 64=PRI_TBL_NUM  8=PRI_TBL_LINES */
+		POS_RANGE_VALIDATE(tbl_id, QOS_TBL_NUM_PRI);
+		POS_RANGE_VALIDATE(tbl_line, QOS_TBL_LINE_NUM_PRI);
+	}
+	/* write index reg */
+	regVal |= (tbl_line << MV_PP2_CLS2_DSCP_PRI_INDEX_LINE_OFF);
+	regVal |= (tbl_sel << MV_PP2_CLS2_DSCP_PRI_INDEX_SEL_OFF);
+	regVal |= (tbl_id << MV_PP2_CLS2_DSCP_PRI_INDEX_TBL_ID_OFF);
+
+	mvPp2WrReg(MV_PP2_CLS2_DSCP_PRI_INDEX_REG, regVal);
+
+	/* write data reg*/
+	mvPp2WrReg(MV_PP2_CLS2_QOS_TBL_REG, qos->data);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC2QosSwDump(MV_PP2_CLS_C2_QOS_ENTRY *qos)
+{
+	int int32bit;
+	int status = 0;
+
+	PTR_VALIDATE(qos);
+
+	mvOsPrintf("TABLE	SEL	LINE	PRI	DSCP	COLOR	GEM_ID	QUEUE\n");
+
+	/* table id */
+	mvOsPrintf("0x%2.2x\t", qos->tbl_id);
+
+	/* table sel */
+	mvOsPrintf("0x%1.1x\t", qos->tbl_sel);
+
+	/* table line */
+	mvOsPrintf("0x%2.2x\t", qos->tbl_line);
+
+	/* priority */
+	status |= mvPp2ClsC2QosPrioGet(qos, &int32bit);
+	mvOsPrintf("0x%1.1x\t", int32bit);
+
+	/* dscp */
+	status |= mvPp2ClsC2QosDscpGet(qos, &int32bit);
+	mvOsPrintf("0x%2.2x\t", int32bit);
+
+	/* color */
+	status |= mvPp2ClsC2QosColorGet(qos, &int32bit);
+	mvOsPrintf("0x%1.1x\t", int32bit);
+
+	/* gem port id */
+	status |= mvPp2ClsC2QosGpidGet(qos, &int32bit);
+	mvOsPrintf("0x%3.3x\t", int32bit);
+
+	/* queue */
+	status |= mvPp2ClsC2QosQueueGet(qos, &int32bit);
+	mvOsPrintf("0x%2.2x", int32bit);
+
+	mvOsPrintf("\n");
+
+	return status;
+}
+/*-------------------------------------------------------------------------------*/
+void 	mvPp2ClsC2QosSwClear(MV_PP2_CLS_C2_QOS_ENTRY *qos)
+{
+
+	memset(qos, 0, sizeof(MV_PP2_CLS_C2_QOS_ENTRY));
+}
+/*-------------------------------------------------------------------------------*/
+void 	mvPp2ClsC2QosHwClearAll()
+{
+	int tbl_id, tbl_line;
+
+	MV_PP2_CLS_C2_QOS_ENTRY c2;
+
+	mvPp2ClsC2QosSwClear(&c2);
+
+	/* clear DSCP tables */
+	for (tbl_id = 0; tbl_id < MV_PP2_CLS_C2_QOS_DSCP_TBL_NUM; tbl_id++)
+		for (tbl_line = 0; tbl_line < MV_PP2_CLS_C2_QOS_DSCP_TBL_SIZE; tbl_line++)
+			mvPp2ClsC2QosHwWrite(tbl_id, 1/*DSCP*/, tbl_line, &c2);
+
+	/* clear PRIO tables */
+	for (tbl_id = 0; tbl_id < MV_PP2_CLS_C2_QOS_PRIO_TBL_NUM; tbl_id++)
+		for (tbl_line = 0; tbl_line < MV_PP2_CLS_C2_QOS_PRIO_TBL_SIZE; tbl_line++)
+			mvPp2ClsC2QosHwWrite(tbl_id, 0/*PRIO*/, tbl_line, &c2);
+
+
+
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC2QosDscpHwDump(void)
+{
+	int tbl_id, tbl_line, int32bit;
+	MV_PP2_CLS_C2_QOS_ENTRY qos;
+
+	for (tbl_id = 0; tbl_id < MV_PP2_CLS_C2_QOS_DSCP_TBL_NUM; tbl_id++) {
+
+		mvOsPrintf("\n------------ DSCP TABLE %d ------------\n", tbl_id);
+		mvOsPrintf("LINE	DSCP	COLOR	GEM_ID	QUEUE\n");
+		for (tbl_line = 0; tbl_line < MV_PP2_CLS_C2_QOS_DSCP_TBL_SIZE; tbl_line++) {
+			mvPp2ClsC2QosHwRead(tbl_id, 1/*DSCP*/, tbl_line, &qos);
+			mvOsPrintf("0x%2.2x\t", qos.tbl_line);
+			mvPp2ClsC2QosDscpGet(&qos, &int32bit);
+			mvOsPrintf("0x%2.2x\t", int32bit);
+			mvPp2ClsC2QosColorGet(&qos, &int32bit);
+			mvOsPrintf("0x%1.1x\t", int32bit);
+			mvPp2ClsC2QosGpidGet(&qos, &int32bit);
+			mvOsPrintf("0x%3.3x\t", int32bit);
+			mvPp2ClsC2QosQueueGet(&qos, &int32bit);
+			mvOsPrintf("0x%2.2x", int32bit);
+			mvOsPrintf("\n");
+		}
+	}
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC2QosPrioHwDump(void)
+{
+	int tbl_id, tbl_line, int32bit;
+
+	MV_PP2_CLS_C2_QOS_ENTRY qos;
+
+	for (tbl_id = 0; tbl_id < MV_PP2_CLS_C2_QOS_PRIO_TBL_NUM; tbl_id++) {
+
+		mvOsPrintf("\n-------- PRIORITY TABLE %d -----------\n", tbl_id);
+		mvOsPrintf("LINE	PRIO	COLOR	GEM_ID	QUEUE\n");
+
+		for (tbl_line = 0; tbl_line < MV_PP2_CLS_C2_QOS_PRIO_TBL_SIZE; tbl_line++) {
+			mvPp2ClsC2QosHwRead(tbl_id, 0/*PRIO*/, tbl_line, &qos);
+			mvOsPrintf("0x%2.2x\t", qos.tbl_line);
+			mvPp2ClsC2QosPrioGet(&qos, &int32bit);
+			mvOsPrintf("0x%1.1x\t", int32bit);
+			mvPp2ClsC2QosColorGet(&qos, &int32bit);
+			mvOsPrintf("0x%1.1x\t", int32bit);
+			mvPp2ClsC2QosGpidGet(&qos, &int32bit);
+			mvOsPrintf("0x%3.3x\t", int32bit);
+			mvPp2ClsC2QosQueueGet(&qos, &int32bit);
+			mvOsPrintf("0x%2.2x", int32bit);
+			mvOsPrintf("\n");
+		}
+	}
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC2QosPrioSet(MV_PP2_CLS_C2_QOS_ENTRY *qos, int prio)
+
+{
+	PTR_VALIDATE(qos);
+	POS_RANGE_VALIDATE(prio, (QOS_TBL_LINE_NUM_PRI-1));
+
+	qos->data &= ~QOS_TBL_PRI_MASK;
+	qos->data |= (prio << QOS_TBL_PRI);
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC2QosDscpSet(MV_PP2_CLS_C2_QOS_ENTRY *qos, int dscp)
+{
+	PTR_VALIDATE(qos);
+	POS_RANGE_VALIDATE(dscp, (QOS_TBL_LINE_NUM_DSCP-1));
+
+	qos->data &= ~QOS_TBL_DSCP_MASK;
+	qos->data |= (dscp << QOS_TBL_DSCP);
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC2QosColorSet(MV_PP2_CLS_C2_QOS_ENTRY *qos, int color)
+{
+	PTR_VALIDATE(qos);
+	POS_RANGE_VALIDATE(color, COLOR_RED_AND_LOCK);
+
+	qos->data &= ~QOS_TBL_COLOR_MASK;
+	qos->data |= (color << QOS_TBL_COLOR);
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC2QosGpidSet(MV_PP2_CLS_C2_QOS_ENTRY *qos, int gpid)
+{
+	PTR_VALIDATE(qos);
+	POS_RANGE_VALIDATE(gpid, ACT_QOS_ATTR_GEM_ID_MAX);
+
+	qos->data &= ~QOS_TBL_GEM_ID_MASK;
+	qos->data |= (gpid << QOS_TBL_GEM_ID);
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC2QosQueueSet(MV_PP2_CLS_C2_QOS_ENTRY *qos, int queue)
+{
+	PTR_VALIDATE(qos);
+	POS_RANGE_VALIDATE(queue, QOS_TBL_Q_NUM_MAX);
+
+	qos->data &= ~QOS_TBL_Q_NUM_MASK;
+	qos->data |= (queue << QOS_TBL_Q_NUM);
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC2QosPrioGet(MV_PP2_CLS_C2_QOS_ENTRY *qos, int *prio)
+{
+	PTR_VALIDATE(qos);
+	PTR_VALIDATE(prio);
+
+	*prio = (qos->data & QOS_TBL_PRI_MASK) >> QOS_TBL_PRI ;
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC2QosDscpGet(MV_PP2_CLS_C2_QOS_ENTRY *qos, int *dscp)
+{
+	PTR_VALIDATE(qos);
+	PTR_VALIDATE(dscp);
+
+	*dscp = (qos->data & QOS_TBL_DSCP_MASK) >> QOS_TBL_DSCP;
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC2QosColorGet(MV_PP2_CLS_C2_QOS_ENTRY *qos, int *color)
+{
+	PTR_VALIDATE(qos);
+	PTR_VALIDATE(color);
+
+	*color = (qos->data & QOS_TBL_COLOR_MASK) >> QOS_TBL_COLOR;
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC2QosGpidGet(MV_PP2_CLS_C2_QOS_ENTRY *qos, int *gpid)
+{
+	PTR_VALIDATE(qos);
+	PTR_VALIDATE(gpid);
+
+	*gpid = (qos->data & QOS_TBL_GEM_ID_MASK) >> QOS_TBL_GEM_ID;
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC2QosQueueGet(MV_PP2_CLS_C2_QOS_ENTRY *qos, int *queue)
+{
+	PTR_VALIDATE(qos);
+	PTR_VALIDATE(queue);
+
+	*queue = (qos->data & QOS_TBL_Q_NUM_MASK) >> QOS_TBL_Q_NUM;
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+/*		Classifier C2 engine TCAM table Public APIs	    		 */
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC2HwWrite(int index, MV_PP2_CLS_C2_ENTRY *c2)
+{
+	int TcmIdx;
+
+	PTR_VALIDATE(c2);
+
+	POS_RANGE_VALIDATE(index, (MV_PP2_CLS_C2_TCAM_SIZE-1));
+
+	c2->index = index;
+
+	/* write index reg */
+	mvPp2WrReg(MV_PP2_CLS2_TCAM_IDX_REG, index);
+
+	/* write valid bit*/
+	c2->inv = 0;
+	mvPp2WrReg(MV_PP2_CLS2_TCAM_INV_REG, ((c2->inv) << MV_PP2_CLS2_TCAM_INV_INVALID));
+
+	for (TcmIdx = 0; TcmIdx < MV_PP2_CLS_C2_TCAM_WORDS; TcmIdx++)
+		mvPp2WrReg(MV_PP2_CLS2_TCAM_DATA_REG(TcmIdx), c2->tcam.words[TcmIdx]);
+
+	/* write action_tbl 0x1B30 */
+	mvPp2WrReg(MV_PP2_CLS2_ACT_DATA_REG, c2->sram.regs.action_tbl);
+
+	/* write actions 0x1B60 */
+	mvPp2WrReg(MV_PP2_CLS2_ACT_REG, c2->sram.regs.actions);
+
+	/* write qos_attr 0x1B64 */
+	mvPp2WrReg(MV_PP2_CLS2_ACT_QOS_ATTR_REG, c2->sram.regs.qos_attr);
+
+	/* write hwf_attr 0x1B68 */
+	mvPp2WrReg(MV_PP2_CLS2_ACT_HWF_ATTR_REG, c2->sram.regs.hwf_attr);
+
+	/* write dup_attr 0x1B6C */
+	mvPp2WrReg(MV_PP2_CLS2_ACT_DUP_ATTR_REG, c2->sram.regs.dup_attr);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+/*
+ note: error is not returned if entry is invalid
+ user should check c2->valid afer returned from this func
+*/
+int mvPp2ClsC2HwRead(int index, MV_PP2_CLS_C2_ENTRY *c2)
+{
+	unsigned int regVal;
+	int	TcmIdx;
+
+	PTR_VALIDATE(c2);
+
+	c2->index = index;
+
+	/* write index reg */
+	mvPp2WrReg(MV_PP2_CLS2_TCAM_IDX_REG, index);
+
+	/* read inValid bit*/
+	regVal = mvPp2RdReg(MV_PP2_CLS2_TCAM_INV_REG);
+	c2->inv = (regVal & MV_PP2_CLS2_TCAM_INV_INVALID_MASK) >> MV_PP2_CLS2_TCAM_INV_INVALID;
+
+	if (c2->inv)
+		return MV_OK;
+
+	for (TcmIdx = 0; TcmIdx < MV_PP2_CLS_C2_TCAM_WORDS; TcmIdx++)
+		c2->tcam.words[TcmIdx] = mvPp2RdReg(MV_PP2_CLS2_TCAM_DATA_REG(TcmIdx));
+
+	/* read action_tbl 0x1B30 */
+	c2->sram.regs.action_tbl = mvPp2RdReg(MV_PP2_CLS2_ACT_DATA_REG);
+
+	/* read actions 0x1B60 */
+	c2->sram.regs.actions = mvPp2RdReg(MV_PP2_CLS2_ACT_REG);
+
+	/* read qos_attr 0x1B64 */
+	c2->sram.regs.qos_attr = mvPp2RdReg(MV_PP2_CLS2_ACT_QOS_ATTR_REG);
+
+	/* read hwf_attr 0x1B68 */
+	c2->sram.regs.hwf_attr = mvPp2RdReg(MV_PP2_CLS2_ACT_HWF_ATTR_REG);
+
+	/* read dup_attr 0x1B6C */
+	c2->sram.regs.dup_attr = mvPp2RdReg(MV_PP2_CLS2_ACT_DUP_ATTR_REG);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC2SwWordsDump(MV_PP2_CLS_C2_ENTRY *c2)
+{
+	int i;
+
+	PTR_VALIDATE(c2);
+
+	/* TODO check size */
+	/* hw entry id */
+	mvOsPrintf("[0x%3.3x] ", c2->index);
+
+	i = MV_PP2_CLS_C2_TCAM_WORDS - 1 ;
+
+	while (i >= 0)
+		mvOsPrintf("%4.4x ", (MV_32BIT_LE_FAST(c2->tcam.words[i--])) & 0xFFFF);
+
+	mvOsPrintf("| ");
+
+	mvOsPrintf(C2_SRAM_FMT, C2_SRAM_VAL(c2->sram.words));
+
+	/*tcam inValid bit*/
+	mvOsPrintf(" %s", (c2->inv == 1) ? "[inv]" : "[valid]");
+
+	mvOsPrintf("\n        ");
+
+	i = MV_PP2_CLS_C2_TCAM_WORDS - 1;
+
+	while (i >= 0)
+		mvOsPrintf("%4.4x ", ((MV_32BIT_LE_FAST(c2->tcam.words[i--]) >> 16)  & 0xFFFF));
+
+	mvOsPrintf("\n");
+
+	return MV_OK;
+}
+
+
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC2SwDump(MV_PP2_CLS_C2_ENTRY *c2)
+{
+	int id, sel, type, gemid, low_q, high_q, color, int32bit;
+
+	PTR_VALIDATE(c2);
+
+	mvPp2ClsC2SwWordsDump(c2);
+	mvOsPrintf("\n");
+
+	/*------------------------------*/
+	/*	action_tbl 0x1B30	*/
+	/*------------------------------*/
+
+	id =  ((c2->sram.regs.action_tbl & (ACT_TBL_ID_MASK)) >> ACT_TBL_ID);
+	sel =  ((c2->sram.regs.action_tbl & (ACT_TBL_SEL_MASK)) >> ACT_TBL_SEL);
+	type =	((c2->sram.regs.action_tbl & (ACT_TBL_PRI_DSCP_MASK)) >> ACT_TBL_PRI_DSCP);
+	gemid = ((c2->sram.regs.action_tbl & (ACT_TBL_GEM_ID_MASK)) >> ACT_TBL_GEM_ID);
+	low_q = ((c2->sram.regs.action_tbl & (ACT_TBL_LOW_Q_MASK)) >> ACT_TBL_LOW_Q);
+	high_q = ((c2->sram.regs.action_tbl & (ACT_TBL_HIGH_Q_MASK)) >> ACT_TBL_HIGH_Q);
+	color =  ((c2->sram.regs.action_tbl & (ACT_TBL_COLOR_MASK)) >> ACT_TBL_COLOR);
+
+	mvOsPrintf("FROM_QOS_%s_TBL[%2.2d]:  ", sel ? "DSCP" : "PRI", id);
+	type ? mvOsPrintf("%s	", sel ? "DSCP" : "PRIO") : 0;
+	color ? mvOsPrintf("COLOR	") : 0;
+	gemid ? mvOsPrintf("GEMID	") : 0;
+	low_q ? mvOsPrintf("LOW_Q	") : 0;
+	high_q ? mvOsPrintf("HIGH_Q	") : 0;
+	mvOsPrintf("\n");
+
+	mvOsPrintf("FROM_ACT_TBL:		");
+	(type == 0) ? mvOsPrintf("%s 	", sel ? "DSCP" : "PRI") : 0;
+	(gemid == 0) ? mvOsPrintf("GEMID	") : 0;
+	(low_q == 0) ? mvOsPrintf("LOW_Q	") : 0;
+	(high_q == 0) ? mvOsPrintf("HIGH_Q	") : 0;
+	(color == 0) ? mvOsPrintf("COLOR	") : 0;
+	mvOsPrintf("\n\n");
+
+	/*------------------------------*/
+	/*	actions 0x1B60		*/
+	/*------------------------------*/
+
+	mvOsPrintf("ACT_CMD:		COLOR	PRIO	DSCP	GEMID	LOW_Q	HIGH_Q	FWD	POLICER	FID\n");
+	mvOsPrintf("			");
+	/* color command*/
+	int32bit =  ((c2->sram.regs.actions & ACT_COLOR_MASK) >> ACT_COLOR);
+	mvOsPrintf("%1.1d\t", int32bit);
+
+	/* pri command*/
+	int32bit =  ((c2->sram.regs.actions & ACT_PRI_MASK) >> ACT_PRI);
+	mvOsPrintf("%1.1d\t", int32bit);
+
+	/* dscp command*/
+	int32bit =  ((c2->sram.regs.actions & ACT_DSCP_MASK) >> ACT_DSCP);
+	mvOsPrintf("%1.1d\t", int32bit);
+
+	/* gemport id command*/
+	int32bit =  ((c2->sram.regs.actions & ACT_GEM_ID_MASK) >> ACT_GEM_ID);
+	mvOsPrintf("%1.1d\t", int32bit);
+
+	/* queue low command*/
+	int32bit =  ((c2->sram.regs.actions & ACT_LOW_Q_MASK) >> ACT_LOW_Q);
+	mvOsPrintf("%1.1d\t", int32bit);
+
+	/* queue high command*/
+	int32bit =  ((c2->sram.regs.actions & ACT_HIGH_Q_MASK) >> ACT_HIGH_Q);
+	mvOsPrintf("%1.1d\t", int32bit);
+
+	/* forwarding command*/
+	int32bit =  ((c2->sram.regs.actions & ACT_FWD_MASK) >> ACT_FWD);
+	mvOsPrintf("%1.1d\t", int32bit);
+
+	/* policer select command*/
+	int32bit =  ((c2->sram.regs.actions & ACT_POLICER_SELECT_MASK) >> ACT_POLICER_SELECT);
+	mvOsPrintf("%1.1d\t", int32bit);
+
+	/* flow id en */
+	int32bit =  ((c2->sram.regs.actions & ACT_FLOW_ID_EN_MASK) >> ACT_FLOW_ID_EN);
+	mvOsPrintf("%1.1d\t", int32bit);
+	mvOsPrintf("\n\n");
+
+
+	/*------------------------------*/
+	/*	qos_attr 0x1B64		*/
+	/*------------------------------*/
+	mvOsPrintf("ACT_ATTR:		PRIO	DSCP	GEMID	LOW_Q	HIGH_Q	QUEUE\n");
+	mvOsPrintf("		");
+	/* modify priority */
+	int32bit =  ((c2->sram.regs.qos_attr & ACT_QOS_ATTR_MDF_PRI_MASK) >> ACT_QOS_ATTR_MDF_PRI);
+	mvOsPrintf("	%1.1d\t", int32bit);
+
+	/* modify dscp */
+	int32bit =  ((c2->sram.regs.qos_attr & ACT_QOS_ATTR_MDF_DSCP_MASK) >> ACT_QOS_ATTR_MDF_DSCP);
+	mvOsPrintf("0x%2.2d\t", int32bit);
+
+	/* modify gemportid */
+	int32bit =  ((c2->sram.regs.qos_attr & ACT_QOS_ATTR_MDF_GEM_ID_MASK) >> ACT_QOS_ATTR_MDF_GEM_ID);
+	mvOsPrintf("0x%4.4x\t", int32bit);
+
+	/* modify low Q */
+	int32bit =  ((c2->sram.regs.qos_attr & ACT_QOS_ATTR_MDF_LOW_Q_MASK) >> ACT_QOS_ATTR_MDF_LOW_Q);
+	mvOsPrintf("0x%1.1d\t", int32bit);
+
+	/* modify high Q */
+	int32bit =  ((c2->sram.regs.qos_attr & ACT_QOS_ATTR_MDF_HIGH_Q_MASK) >> ACT_QOS_ATTR_MDF_HIGH_Q);
+	mvOsPrintf("0x%2.2x\t", int32bit);
+
+	/*modify queue*/
+	int32bit = ((c2->sram.regs.qos_attr & (ACT_QOS_ATTR_MDF_LOW_Q_MASK | ACT_QOS_ATTR_MDF_HIGH_Q_MASK)));
+	int32bit >>= ACT_QOS_ATTR_MDF_LOW_Q;
+
+	mvOsPrintf("0x%2.2x\t", int32bit);
+	mvOsPrintf("\n\n");
+
+
+
+	/*------------------------------*/
+	/*	hwf_attr 0x1B68		*/
+	/*------------------------------*/
+
+	mvOsPrintf("HWF_ATTR:		IPTR	DPTR	CHKSM\n");
+	mvOsPrintf("			");
+
+	/* HWF modification instraction pointer */
+	int32bit =  ((c2->sram.regs.hwf_attr & ACT_HWF_ATTR_IPTR_MASK) >> ACT_HWF_ATTR_IPTR);
+	mvOsPrintf("0x%1.1x\t", int32bit);
+
+	/* HWF modification data pointer */
+	int32bit =  ((c2->sram.regs.hwf_attr & ACT_HWF_ATTR_DPTR_MASK) >> ACT_HWF_ATTR_DPTR);
+	mvOsPrintf("0x%4.4x\t", int32bit);
+
+	/* HWF modification instraction pointer */
+	int32bit =  ((c2->sram.regs.hwf_attr & ACT_HWF_ATTR_CHKSM_EN_MASK) >> ACT_HWF_ATTR_CHKSM_EN);
+	mvOsPrintf("%s\t", int32bit ? "ENABLE" : "DISABLE");
+	mvOsPrintf("\n\n");
+
+	/*------------------------------*/
+	/*	dup_attr 0x1B6C		*/
+	/*------------------------------*/
+
+	mvOsPrintf("DUP_ATTR:		FID	COUNT	POLICER\n");
+	mvOsPrintf("		");
+
+	/* HW duplication fid */
+	int32bit =  ((c2->sram.regs.dup_attr & ACT_DUP_FID_MASK) >> ACT_DUP_FID);
+	mvOsPrintf("	0x%2.2x\t", int32bit);
+
+	/* HW duplication count */
+	int32bit =  ((c2->sram.regs.dup_attr & ACT_DUP_COUNT_MASK) >> ACT_DUP_COUNT);
+	mvOsPrintf("0x%1.1x\t", int32bit);
+
+	/* policer id */
+	int32bit =  ((c2->sram.regs.dup_attr & ACT_DUP_POLICER_MASK) >> ACT_DUP_POLICER_ID);
+	mvOsPrintf("0x%1.1x\t", int32bit);
+
+	mvOsPrintf("\n\n");
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+void 	mvPp2ClsC2SwClear(MV_PP2_CLS_C2_ENTRY *c2)
+{
+
+	memset(c2, 0, sizeof(MV_PP2_CLS_C2_ENTRY));
+}
+/*-------------------------------------------------------------------------------*/
+void 	mvPp2ClsC2HwClearAll()
+{
+	int index;
+
+	MV_PP2_CLS_C2_ENTRY c2;
+
+	mvPp2ClsC2SwClear(&c2);
+
+	for (index = 0; index < MV_PP2_CLS_C2_TCAM_SIZE; index++) {
+		mvPp2ClsC2HwWrite(index, &c2);
+		mvPp2ClsC2HwInv(index);
+	}
+}
+/*-------------------------------------------------------------------------------*/
+int 	mvPp2ClsC2HwDump()
+{
+	int index;
+
+	MV_PP2_CLS_C2_ENTRY c2;
+
+	mvPp2ClsC2SwClear(&c2);
+
+	for (index = 0; index < MV_PP2_CLS_C2_TCAM_SIZE; index++) {
+		mvPp2ClsC2HwRead(index, &c2);
+		if (c2.inv == 0) {
+			mvPp2ClsC2SwDump(&c2);
+			mvOsPrintf("-----------------------------------------------------------------\n");
+		}
+	}
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC2TcamByteSet(MV_PP2_CLS_C2_ENTRY *c2, unsigned int offs, unsigned char byte, unsigned char enable)
+{
+	PTR_VALIDATE(c2);
+
+	POS_RANGE_VALIDATE(offs, MV_PP2_CLS_C2_TCAM_DATA_BYTES);
+
+	c2->tcam.bytes[TCAM_DATA_BYTE_OFFS(offs)] = byte;
+	c2->tcam.bytes[TCAM_DATA_MASK_OFFS(offs)] = enable;
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC2TcamByteGet(MV_PP2_CLS_C2_ENTRY *c2, unsigned int offs, unsigned char *byte, unsigned char *enable)
+{
+	PTR_VALIDATE(c2);
+	PTR_VALIDATE(byte);
+	PTR_VALIDATE(enable);
+
+	POS_RANGE_VALIDATE(offs, 8);
+
+	*byte = c2->tcam.bytes[TCAM_DATA_BYTE_OFFS(offs)];
+	*enable = c2->tcam.bytes[TCAM_DATA_MASK_OFFS(offs)];
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+/*
+return EQUALS if tcam_data[off]&tcam_mask[off] = byte
+*/
+int mvPp2ClsC2TcamByteCmp(MV_PP2_CLS_C2_ENTRY *c2, unsigned int offs, unsigned char byte)
+	{
+	unsigned char tcamByte, tcamMask;
+
+	PTR_VALIDATE(c2);
+
+	if (mvPp2ClsC2TcamByteGet(c2, offs, &tcamByte, &tcamMask) != MV_OK)
+		return MV_CLS2_ERR;
+
+	if ((tcamByte & tcamMask) == (byte & tcamMask))
+		return EQUALS;
+
+	return NOT_EQUALS;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC2TcamBytesCmp(MV_PP2_CLS_C2_ENTRY *c2, unsigned int offset, unsigned int size, unsigned char *bytes)
+{
+	int status, index;
+
+	PTR_VALIDATE(c2);
+
+	if ((sizeof(bytes) < size) || ((offset + size) > (MV_PP2_CLS_C2_TCAM_WORDS * 4))) {
+		mvOsPrintf("mvCls2Hw %s: value is out of range.\n", __func__);
+		return MV_CLS2_ERR;
+	}
+
+	for (index = 0; index < size; index++) {
+		status = mvPp2ClsC2TcamByteCmp(c2, offset, bytes[index]);
+		if (status != EQUALS)
+			return status;
+	}
+	return EQUALS;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC2QosTblSet(MV_PP2_CLS_C2_ENTRY *c2, int tbl_id, int tbl_sel)
+{
+
+	PTR_VALIDATE(c2);
+	POS_RANGE_VALIDATE(tbl_sel, 1);
+
+	if (tbl_sel == 1) {
+		/*dscp*/
+		POS_RANGE_VALIDATE(tbl_id, QOS_TBL_NUM_DSCP);
+	} else {
+		/*pri*/
+		POS_RANGE_VALIDATE(tbl_id, QOS_TBL_NUM_PRI);
+	}
+	c2->sram.regs.action_tbl = (tbl_id << ACT_TBL_ID) | (tbl_sel << ACT_TBL_SEL);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC2ColorSet(MV_PP2_CLS_C2_ENTRY *c2, int cmd, int from)
+{
+	PTR_VALIDATE(c2);
+	POS_RANGE_VALIDATE(cmd, COLOR_RED_AND_LOCK);
+
+	c2->sram.regs.actions &= ~ACT_COLOR_MASK;
+	c2->sram.regs.actions |= (cmd << ACT_COLOR);
+
+	if (from == 1)
+		c2->sram.regs.action_tbl |= (1 << ACT_TBL_COLOR);
+	else
+		c2->sram.regs.action_tbl &= ~(1 << ACT_TBL_COLOR);
+
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC2PrioSet(MV_PP2_CLS_C2_ENTRY *c2, int cmd, int prio, int from)
+{
+	PTR_VALIDATE(c2);
+	POS_RANGE_VALIDATE(cmd, UPDATE_AND_LOCK);
+	POS_RANGE_VALIDATE(prio, (QOS_TBL_LINE_NUM_PRI-1));
+
+	/*set command*/
+	c2->sram.regs.actions &= ~ACT_PRI_MASK;
+	c2->sram.regs.actions |= (cmd << ACT_PRI);
+
+	/*set modify priority value*/
+	c2->sram.regs.qos_attr &= ~ACT_QOS_ATTR_MDF_PRI_MASK;
+	c2->sram.regs.qos_attr |= (prio << ACT_QOS_ATTR_MDF_PRI);
+
+	if (from == 1)
+		c2->sram.regs.action_tbl |= (1 << ACT_TBL_PRI_DSCP);
+	else
+		c2->sram.regs.action_tbl &= ~(1 << ACT_TBL_PRI_DSCP);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC2DscpSet(MV_PP2_CLS_C2_ENTRY *c2, int cmd, int dscp, int from)
+{
+	PTR_VALIDATE(c2);
+	POS_RANGE_VALIDATE(cmd, UPDATE_AND_LOCK);
+	POS_RANGE_VALIDATE(dscp, (QOS_TBL_LINE_NUM_DSCP-1));
+
+	/*set command*/
+	c2->sram.regs.actions &= ~ACT_DSCP_MASK;
+	c2->sram.regs.actions |= (cmd << ACT_DSCP);
+
+	/*set modify DSCP value*/
+	c2->sram.regs.qos_attr &= ~ACT_QOS_ATTR_MDF_DSCP_MASK;
+	c2->sram.regs.qos_attr |= (dscp << ACT_QOS_ATTR_MDF_DSCP);
+
+	if (from == 1)
+		c2->sram.regs.action_tbl |= (1 << ACT_TBL_PRI_DSCP);
+	else
+		c2->sram.regs.action_tbl &= ~(1 << ACT_TBL_PRI_DSCP);
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC2GpidSet(MV_PP2_CLS_C2_ENTRY *c2, int cmd, int gpid, int from)
+{
+	PTR_VALIDATE(c2);
+	POS_RANGE_VALIDATE(cmd, UPDATE_AND_LOCK);
+	POS_RANGE_VALIDATE(gpid, ACT_QOS_ATTR_GEM_ID_MAX);
+
+	/*set command*/
+	c2->sram.regs.actions &= ~ACT_GEM_ID_MASK;
+	c2->sram.regs.actions |= (cmd << ACT_GEM_ID);
+
+	/*set modify DSCP value*/
+	c2->sram.regs.qos_attr &= ~ACT_QOS_ATTR_MDF_GEM_ID_MASK;
+	c2->sram.regs.qos_attr |= (gpid << ACT_QOS_ATTR_MDF_GEM_ID);
+
+	if (from == 1)
+		c2->sram.regs.action_tbl |= (1 << ACT_TBL_GEM_ID);
+	else
+		c2->sram.regs.action_tbl &= ~(1 << ACT_TBL_GEM_ID);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC2QueueHighSet(MV_PP2_CLS_C2_ENTRY *c2, int cmd, int queue, int from)
+{
+	PTR_VALIDATE(c2);
+
+
+	POS_RANGE_VALIDATE(cmd, UPDATE_AND_LOCK);
+	POS_RANGE_VALIDATE(queue, ACT_QOS_ATTR_MDF_HIGH_Q_MAX);
+
+	/*set command*/
+	c2->sram.regs.actions &= ~ACT_HIGH_Q_MASK;
+	c2->sram.regs.actions |= (cmd << ACT_HIGH_Q);
+
+	/*set modify High queue value*/
+	c2->sram.regs.qos_attr &= ~ACT_QOS_ATTR_MDF_HIGH_Q_MASK;
+	c2->sram.regs.qos_attr |= (queue << ACT_QOS_ATTR_MDF_HIGH_Q);
+
+	if (from == 1)
+		c2->sram.regs.action_tbl |= (1 << ACT_TBL_HIGH_Q);
+	else
+		c2->sram.regs.action_tbl &= ~(1 << ACT_TBL_HIGH_Q);
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC2QueueLowSet(MV_PP2_CLS_C2_ENTRY *c2, int cmd, int queue, int from)
+{
+	PTR_VALIDATE(c2);
+
+	POS_RANGE_VALIDATE(cmd, UPDATE_AND_LOCK);
+	POS_RANGE_VALIDATE(queue, ACT_QOS_ATTR_MDF_LOW_Q_MAX);
+
+	/*set command*/
+	c2->sram.regs.actions &= ~ACT_LOW_Q_MASK;
+	c2->sram.regs.actions |= (cmd << ACT_LOW_Q);
+
+	/*set modify High queue value*/
+	c2->sram.regs.qos_attr &= ~ACT_QOS_ATTR_MDF_LOW_Q_MASK;
+	c2->sram.regs.qos_attr |= (queue << ACT_QOS_ATTR_MDF_LOW_Q);
+
+	if (from == 1)
+		c2->sram.regs.action_tbl |= (1 << ACT_TBL_LOW_Q);
+	else
+		c2->sram.regs.action_tbl &= ~(1 << ACT_TBL_LOW_Q);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC2QueueSet(MV_PP2_CLS_C2_ENTRY *c2, int cmd, int queue, int from)
+{
+	int status = MV_OK;
+	int qHigh, qLow;
+
+	PTR_VALIDATE(c2);
+	POS_RANGE_VALIDATE(queue, ACT_QOS_ATTR_Q_MAX);
+
+	/* cmd validation in set functions */
+
+	qHigh = (queue & ACT_QOS_ATTR_MDF_HIGH_Q_MASK) >> ACT_QOS_ATTR_MDF_HIGH_Q;
+	qLow = (queue & ACT_QOS_ATTR_MDF_LOW_Q_MASK) >> ACT_QOS_ATTR_MDF_LOW_Q;
+
+	status |= mvPp2ClsC2QueueLowSet(c2, cmd, qLow, from);
+	status |= mvPp2ClsC2QueueHighSet(c2, cmd, qHigh, from);
+
+	return status;
+
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC2ForwardSet(MV_PP2_CLS_C2_ENTRY *c2, int cmd)
+{
+	PTR_VALIDATE(c2);
+	POS_RANGE_VALIDATE(cmd, HWF_AND_LOW_LATENCY_AND_LOCK);
+
+	c2->sram.regs.actions &= ~ACT_FWD_MASK;
+	c2->sram.regs.actions |= (cmd << ACT_FWD);
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC2PolicerSet(MV_PP2_CLS_C2_ENTRY *c2, int cmd, int policerId)
+{
+	PTR_VALIDATE(c2);
+	POS_RANGE_VALIDATE(cmd, UPDATE_AND_LOCK);
+	POS_RANGE_VALIDATE(policerId, ACT_DUP_POLICER_MAX);
+
+	c2->sram.regs.actions &= ~ACT_POLICER_SELECT_MASK;
+	c2->sram.regs.actions |= (cmd << ACT_POLICER_SELECT);
+
+	c2->sram.regs.dup_attr &= ~ACT_DUP_POLICER_MASK;
+	c2->sram.regs.dup_attr |= (policerId << ACT_DUP_POLICER_ID);
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC2ModSet(MV_PP2_CLS_C2_ENTRY *c2, int data_ptr, int instr_offs, int l4_csum)
+{
+	PTR_VALIDATE(c2);
+	POS_RANGE_VALIDATE(data_ptr, ACT_HWF_ATTR_DPTR_MAX);
+	POS_RANGE_VALIDATE(instr_offs, ACT_HWF_ATTR_IPTR_MAX);
+	POS_RANGE_VALIDATE(l4_csum, 1);
+
+	c2->sram.regs.hwf_attr &= ~ACT_HWF_ATTR_DPTR_MASK;
+	c2->sram.regs.hwf_attr &= ~ACT_HWF_ATTR_IPTR_MASK;
+	c2->sram.regs.hwf_attr &= ~ACT_HWF_ATTR_CHKSM_EN_MASK;
+
+	c2->sram.regs.hwf_attr |= (data_ptr << ACT_HWF_ATTR_DPTR);
+	c2->sram.regs.hwf_attr |= (instr_offs << ACT_HWF_ATTR_IPTR);
+	c2->sram.regs.hwf_attr |= (l4_csum << ACT_HWF_ATTR_CHKSM_EN);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC2DupSet(MV_PP2_CLS_C2_ENTRY *c2, int dupid, int count)
+{
+	PTR_VALIDATE(c2);
+	POS_RANGE_VALIDATE(count, ACT_DUP_COUNT_MAX);
+	POS_RANGE_VALIDATE(dupid, ACT_DUP_FID_MAX);
+
+	/*set Flow ID enable*/
+	c2->sram.regs.actions |= (1 << ACT_FLOW_ID_EN);
+
+	/*set flowid and count*/
+	c2->sram.regs.dup_attr &= ~(ACT_DUP_FID_MASK | ACT_DUP_COUNT_MASK);
+	c2->sram.regs.dup_attr |= (dupid << ACT_DUP_FID);
+	c2->sram.regs.dup_attr |= (count << ACT_DUP_COUNT);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+/*		Classifier C2 engine Hit counters Public APIs		    	 */
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC2HitCntrsClearAll(void)
+{
+	int iter = 0;
+
+	/* wrirte clear bit*/
+	mvPp2WrReg(MV_PP2_CLS2_HIT_CTR_CLR_REG, (1 << MV_PP2_CLS2_HIT_CTR_CLR_CLR));
+
+	while (mvPp2ClsC2HitCntrsIsBusy())
+		if (iter++ >= RETRIES_EXCEEDED) {
+			mvOsPrintf("%s:Error - retries exceeded.\n", __func__);
+			return MV_CLS2_RETRIES_EXCEEDED;
+		}
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC2HitCntrsIsBusy(void)
+{
+	unsigned int regVal;
+
+	regVal = mvPp2RdReg(MV_PP2_CLS2_HIT_CTR_REG);
+	regVal &= MV_PP2_CLS2_HIT_CTR_CLR_DONE_MASK;
+	regVal >>= MV_PP2_CLS2_HIT_CTR_CLR_DONE;
+
+	return (1 - (int)regVal);
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC2HitCntrRead(int index, MV_U32 *cntr)
+{
+	unsigned int value = 0;
+/*
+	if (cntr == NULL) {
+		mvOsPrintf("mvCls2Hw %s: null pointer.\n", __func__);
+		return MV_CLS2_ERR;
+	}
+*/
+	/* write index reg */
+	mvPp2WrReg(MV_PP2_CLS2_TCAM_IDX_REG, index);
+
+	value = mvPp2RdReg(MV_PP2_CLS2_HIT_CTR_REG);
+	value &= MV_PP2_CLS2_HIT_CTR_MASK;
+
+	if (cntr)
+		*cntr = value;
+	else
+		mvOsPrintf("INDEX: 0x%8.8X	VAL: 0x%8.8X\n", index, value);
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC2HitCntrsDump()
+{
+	int i;
+	unsigned int cnt;
+
+	for (i = 0; i < MV_PP2_CLS_C2_TCAM_SIZE; i++) {
+		mvPp2ClsC2HitCntrRead(i, &cnt);
+		if (cnt != 0)
+			mvOsPrintf("INDEX: 0x%8.8X	VAL: 0x%8.8X\n", i, cnt);
+	}
+
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC2RegsDump()
+{
+	int i;
+	char reg_name[100];
+
+	mvPp2PrintReg(MV_PP2_CLS2_TCAM_IDX_REG, "MV_PP2_CLS2_TCAM_IDX_REG");
+
+	for (i = 0; i < MV_PP2_CLS_C2_TCAM_WORDS; i++) {
+		mvOsSPrintf(reg_name, "MV_PP2_CLS2_TCAM_DATA_%d_REG", i);
+		mvPp2PrintReg(MV_PP2_CLS2_TCAM_DATA_REG(i), reg_name);
+	}
+
+	mvPp2PrintReg(MV_PP2_CLS2_TCAM_INV_REG, "MV_PP2_CLS2_TCAM_INV_REG");
+	mvPp2PrintReg(MV_PP2_CLS2_ACT_DATA_REG, "MV_PP2_CLS2_ACT_DATA_REG");
+	mvPp2PrintReg(MV_PP2_CLS2_DSCP_PRI_INDEX_REG, "MV_PP2_CLS2_DSCP_PRI_INDEX_REG");
+	mvPp2PrintReg(MV_PP2_CLS2_QOS_TBL_REG, "MV_PP2_CLS2_QOS_TBL_REG");
+	mvPp2PrintReg(MV_PP2_CLS2_ACT_REG, "MV_PP2_CLS2_ACT_REG");
+	mvPp2PrintReg(MV_PP2_CLS2_ACT_QOS_ATTR_REG, "MV_PP2_CLS2_ACT_QOS_ATTR_REG");
+	mvPp2PrintReg(MV_PP2_CLS2_ACT_HWF_ATTR_REG, "MV_PP2_CLS2_ACT_HWF_ATTR_REG");
+	mvPp2PrintReg(MV_PP2_CLS2_ACT_DUP_ATTR_REG, "MV_PP2_CLS2_ACT_DUP_ATTR_REG");
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+int	mvPp2ClsC2HwInv(int index)
+{	/* write index reg */
+	mvPp2WrReg(MV_PP2_CLS2_TCAM_IDX_REG, index);
+
+	/* set invalid bit*/
+	mvPp2WrReg(MV_PP2_CLS2_TCAM_INV_REG, (1 << MV_PP2_CLS2_TCAM_INV_INVALID));
+
+	/* trigger */
+	mvPp2WrReg(MV_PP2_CLS2_TCAM_DATA_REG(4), 0);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+int	mvPp2ClsC2HwInvAll(void)
+{
+	int index;
+
+	for (index = 0; index < MV_PP2_CLS_C2_TCAM_SIZE; index++) {
+		/* write index reg */
+		mvPp2WrReg(MV_PP2_CLS2_TCAM_IDX_REG, index);
+
+		/* set invalid bit*/
+		mvPp2WrReg(MV_PP2_CLS2_TCAM_INV_REG, (1 << MV_PP2_CLS2_TCAM_INV_INVALID));
+
+		/* trigger */
+		mvPp2WrReg(MV_PP2_CLS2_TCAM_DATA_REG(4), 0);
+	}
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+int	mvPp2ClsC2Init(void)
+{
+	mvPp2ClsC2QosHwClearAll();
+	mvPp2ClsC2HwClearAll();
+	return MV_OK;
+}
diff --git a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls2Hw.h b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls2Hw.h
new file mode 100644
index 0000000..6cba557
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls2Hw.h
@@ -0,0 +1,273 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_CLS2_HW_H__
+#define __MV_CLS2_HW_H__
+
+#include "mvPp2ClsActHw.h"
+#include "../common/mvPp2ErrCode.h"
+#include "../common/mvPp2Common.h"
+#include "../gbe/mvPp2GbeRegs.h"
+
+/*-------------------------------------------------------------------------------*/
+/*			Classifier C2 Top Registers	    			 */
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS2_TCAM_IDX_REG			(MV_PP2_REG_BASE + 0x1B00)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS2_TCAM_DATA_REG(idx)			(MV_PP2_REG_BASE + 0x1B10 + (idx) * 4)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS2_TCAM_INV_REG			(MV_PP2_REG_BASE + 0x1B24)
+#define MV_PP2_CLS2_TCAM_INV_INVALID			31
+#define MV_PP2_CLS2_TCAM_INV_INVALID_MASK		(1 << MV_PP2_CLS2_TCAM_INV_INVALID)
+
+#define TCAM_DATA_BYTE_OFFS(_offs_)			(((_offs_) - ((_offs_) % 2)) * 2 + ((_offs_) % 2))
+#define TCAM_DATA_MASK_OFFS(_offs_)			(((_offs_) * 2) - ((_offs_) % 2)  + 2)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS2_ACT_DATA_REG			(MV_PP2_REG_BASE + 0x1B30)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS2_DSCP_PRI_INDEX_REG			(MV_PP2_REG_BASE + 0x1B40)
+
+#define MV_PP2_CLS2_DSCP_PRI_INDEX_LINE_OFF		0
+#define MV_PP2_CLS2_DSCP_PRI_INDEX_LINE_BITS		6
+#define MV_PP2_CLS2_DSCP_PRI_INDEX_LINE_MASK		((1 << MV_PP2_CLS2_DSCP_PRI_INDEX_LINE_BITS) - 1)
+
+#define MV_PP2_CLS2_DSCP_PRI_INDEX_SEL_OFF		6
+#define MV_PP2_CLS2_DSCP_PRI_INDEX_SEL_MASK		(1 << MV_PP2_CLS2_DSCP_PRI_INDEX_SEL_OFF)
+
+#define MV_PP2_CLS2_DSCP_PRI_INDEX_TBL_ID_OFF		8
+#define MV_PP2_CLS2_DSCP_PRI_INDEX_TBL_ID_BITS		6
+#define MV_PP2_CLS2_DSCP_PRI_INDEX_TBL_ID_MASK		((1 << MV_PP2_CLS2_DSCP_PRI_INDEX_TBL_ID_BITS) - 1)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS2_QOS_TBL_REG				(MV_PP2_REG_BASE + 0x1B44)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS2_HIT_CTR_REG				(MV_PP2_REG_BASE + 0x1B50)
+#define MV_PP2_CLS2_HIT_CTR_OFF				0
+#define MV_PP2_CLS2_HIT_CTR_BITS			24
+#define MV_PP2_CLS2_HIT_CTR_MASK			((1  << MV_PP2_CLS2_HIT_CTR_BITS) - 1)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS2_HIT_CTR_CLR_REG			(MV_PP2_REG_BASE + 0x1B54)
+
+#define MV_PP2_CLS2_HIT_CTR_CLR_CLR			0
+#define MV_PP2_CLS2_HIT_CTR_CLR_CLR_MASK		(1 << MV_PP2_CLS2_HIT_CTR_CLR_CLR)
+
+#define MV_PP2_CLS2_HIT_CTR_CLR_DONE			1
+#define MV_PP2_CLS2_HIT_CTR_CLR_DONE_MASK		(1 << MV_PP2_CLS2_HIT_CTR_CLR_DONE)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS2_ACT_REG				(MV_PP2_REG_BASE + 0x1B60)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS2_ACT_QOS_ATTR_REG			(MV_PP2_REG_BASE + 0x1B64)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS2_ACT_HWF_ATTR_REG			(MV_PP2_REG_BASE + 0x1B68)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS2_ACT_DUP_ATTR_REG			(MV_PP2_REG_BASE + 0x1B6C)
+
+/*-------------------------------------------------------------------------------*/
+/*		Classifier C2 QOS Table	(DSCP/PRI Table)			 */
+/*-------------------------------------------------------------------------------*/
+#define QOS_TBL_LINE_NUM_PRI				(8)
+#define QOS_TBL_NUM_PRI					(64)
+
+#define QOS_TBL_LINE_NUM_DSCP				(64)
+#define QOS_TBL_NUM_DSCP				(8)
+
+#define QOS_TBL_PRI					0
+#define QOS_TBL_PRI_MASK				(((1 << ACT_QOS_ATTR_PRI_BITS) - 1) << QOS_TBL_PRI)
+
+
+#define QOS_TBL_DSCP					3
+#define QOS_TBL_DSCP_MASK				(((1 << ACT_QOS_ATTR_DSCP_BITS) - 1) << QOS_TBL_DSCP)
+
+#define QOS_TBL_COLOR					9
+#define QOS_TBL_COLOR_BITS				3
+#define QOS_TBL_COLOR_MASK				(((1 << QOS_TBL_COLOR_BITS) - 1) << QOS_TBL_COLOR)
+
+#define QOS_TBL_GEM_ID					12
+#define QOS_TBL_GEM_ID_MASK				(((1 << ACT_QOS_ATTR_GEM_ID_BITS) - 1) << QOS_TBL_GEM_ID)
+
+#define QOS_TBL_Q_NUM					24
+#define QOS_TBL_Q_NUM_BITS				8
+#define QOS_TBL_Q_NUM_MAX				((1 << QOS_TBL_Q_NUM_BITS) - 1)
+#define QOS_TBL_Q_NUM_MASK				(((1 << QOS_TBL_Q_NUM_BITS) - 1) << QOS_TBL_Q_NUM)
+/*-------------------------------------------------------------------------------*/
+/*			Classifier C2 engine Public APIs			 */
+/*-------------------------------------------------------------------------------*/
+int	mvPp2ClsC2Init(void);
+
+/*-------------------------------------------------------------------------------*/
+/*		Classifier C2 engine QoS table Public APIs			 */
+/*-------------------------------------------------------------------------------*/
+#define MV_PP2_CLS_C2_QOS_DSCP_TBL_SIZE				(64)
+#define MV_PP2_CLS_C2_QOS_PRIO_TBL_SIZE				(8)
+#define MV_PP2_CLS_C2_QOS_DSCP_TBL_NUM				(8)
+#define MV_PP2_CLS_C2_QOS_PRIO_TBL_NUM				(64)
+
+typedef struct mvPp2ClsC2Qosentry {
+	unsigned int tbl_id;
+	unsigned int tbl_sel;
+	unsigned int tbl_line;
+	unsigned int data;
+} MV_PP2_CLS_C2_QOS_ENTRY;
+
+int	mvPp2ClsC2QosPrioHwDump(void);
+int	mvPp2ClsC2QosDscpHwDump(void);
+int	mvPp2ClsC2QosHwRead(int tbl_id, int tbl_sel, int tbl_line, MV_PP2_CLS_C2_QOS_ENTRY *qos);
+int	mvPp2ClsC2QosHwWrite(int id, int sel, int line, MV_PP2_CLS_C2_QOS_ENTRY *qos);
+int	mvPp2ClsC2QosSwDump(MV_PP2_CLS_C2_QOS_ENTRY *qos);
+void 	mvPp2ClsC2QosSwClear(MV_PP2_CLS_C2_QOS_ENTRY *qos);
+void	mvPp2ClsC2QosHwClearAll(void);
+
+int	mvPp2ClsC2QosPrioSet(MV_PP2_CLS_C2_QOS_ENTRY *qos, int prio);
+int	mvPp2ClsC2QosDscpSet(MV_PP2_CLS_C2_QOS_ENTRY *qos, int dscp);
+int	mvPp2ClsC2QosColorSet(MV_PP2_CLS_C2_QOS_ENTRY *qos, int color);
+int	mvPp2ClsC2QosGpidSet(MV_PP2_CLS_C2_QOS_ENTRY *qos, int gpid);
+int	mvPp2ClsC2QosQueueSet(MV_PP2_CLS_C2_QOS_ENTRY *qos, int queue);
+int	mvPp2ClsC2QosPrioGet(MV_PP2_CLS_C2_QOS_ENTRY *qos, int *prio);
+int	mvPp2ClsC2QosDscpGet(MV_PP2_CLS_C2_QOS_ENTRY *qos, int *dscp);
+int	mvPp2ClsC2QosColorGet(MV_PP2_CLS_C2_QOS_ENTRY *qos, int *color);
+int	mvPp2ClsC2QosGpidGet(MV_PP2_CLS_C2_QOS_ENTRY *qos, int *gpid);
+int	mvPp2ClsC2QosQueueGet(MV_PP2_CLS_C2_QOS_ENTRY *qos, int *queue);
+
+/*-------------------------------------------------------------------------------*/
+/*		Classifier C2 engine action table Public APIs	 		 */
+/*-------------------------------------------------------------------------------*/
+#define MV_PP2_CLS_C2_TCAM_SIZE				(256)
+#define MV_PP2_CLS_C2_TCAM_WORDS			(5)
+#define MV_PP2_CLS_C2_TCAM_DATA_BYTES			(10)
+#define MV_PP2_CLS_C2_SRAM_WORDS			(5)
+
+#define C2_SRAM_FMT					"%8.8x %8.8x %8.8x %8.8x %8.8x"
+#define C2_SRAM_VAL(p)					p[4], p[3], p[2], p[1], p[0]
+
+typedef struct mvPp2ClsC2Entry {
+	unsigned int index;
+	bool         inv;
+	union {
+		MV_U32	words[MV_PP2_CLS_C2_TCAM_WORDS];
+		MV_U8	bytes[MV_PP2_CLS_C2_TCAM_WORDS * 4];
+	} tcam;
+	union {
+		MV_U32 words[MV_PP2_CLS_C2_SRAM_WORDS];
+		struct {
+			MV_U32 action_tbl; /* 0x1B30 */
+			MV_U32 actions;    /* 0x1B60 */
+			MV_U32 qos_attr;   /* 0x1B64*/
+			MV_U32 hwf_attr;   /* 0x1B68 */
+			MV_U32 dup_attr;   /* 0x1B6C */
+		} regs;
+	} sram;
+} MV_PP2_CLS_C2_ENTRY;
+
+int 	mvPp2ClsC2HwWrite(int index, MV_PP2_CLS_C2_ENTRY *c2);
+int 	mvPp2ClsC2HwRead(int index, MV_PP2_CLS_C2_ENTRY *c2);
+int 	mvPp2ClsC2SwDump(MV_PP2_CLS_C2_ENTRY *c2);
+int 	mvPp2ClsC2HwDump(void);
+void 	mvPp2ClsC2SwClear(MV_PP2_CLS_C2_ENTRY *c2);
+void	mvPp2ClsC2HwClearAll(void);
+int	mvPp2ClsC2HwInv(int index);
+int	mvPp2ClsC2HwInvAll(void);
+
+int	mvPp2ClsC2TcamByteSet(MV_PP2_CLS_C2_ENTRY *c2, unsigned int offs, unsigned char byte, unsigned char enable);
+int	mvPp2ClsC2TcamByteGet(MV_PP2_CLS_C2_ENTRY *c2, unsigned int offs, unsigned char *byte, unsigned char *enable);
+int	mvPp2ClsC2TcamByteCmp(MV_PP2_CLS_C2_ENTRY *c2, unsigned int offs, unsigned char byte);
+int 	mvPp2ClsC2TcamBytesCmp(MV_PP2_CLS_C2_ENTRY *c2, unsigned int offset, unsigned int size, unsigned char *bytes);
+
+int	mvPp2ClsC2QosTblSet(MV_PP2_CLS_C2_ENTRY *c2, int id, int sel);
+int	mvPp2ClsC2ColorSet(MV_PP2_CLS_C2_ENTRY *c2, int cmd, int from);
+int	mvPp2ClsC2PrioSet(MV_PP2_CLS_C2_ENTRY *c2, int cmd, int prio, int form);
+int	mvPp2ClsC2DscpSet(MV_PP2_CLS_C2_ENTRY *c2, int cmd, int dscp, int from);
+int	mvPp2ClsC2GpidSet(MV_PP2_CLS_C2_ENTRY *c2, int cmd, int gpid, int from);
+int	mvPp2ClsC2QueueHighSet(MV_PP2_CLS_C2_ENTRY *c2, int cmd, int queue, int from);
+int	mvPp2ClsC2QueueLowSet(MV_PP2_CLS_C2_ENTRY *c2, int cmd, int queue, int from);
+int	mvPp2ClsC2QueueSet(MV_PP2_CLS_C2_ENTRY *c2, int cmd, int queue, int from);
+int	mvPp2ClsC2ForwardSet(MV_PP2_CLS_C2_ENTRY *c2, int cmd);
+int	mvPp2ClsC2PolicerSet(MV_PP2_CLS_C2_ENTRY *c2, int cmd, int policerId);
+int	mvPp2ClsC2ModSet(MV_PP2_CLS_C2_ENTRY *c2, int data_ptr, int instr_offs, int l4_csum);
+int	mvPp2ClsC2DupSet(MV_PP2_CLS_C2_ENTRY *c2, int dupid, int count);
+
+/*-------------------------------------------------------------------------------*/
+/*		Classifier C2 engine Hit counters Public APIs		    	 */
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC2HitCntrsIsBusy(void);
+int mvPp2ClsC2HitCntrsClearAll(void);
+int mvPp2ClsC2HitCntrRead(int index, MV_U32 *cntr);
+int mvPp2ClsC2HitCntrsDump(void);
+
+/*-------------------------------------------------------------------------------*/
+/*		Classifier C2 engine debug Public APIs			    	 */
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC2RegsDump(void);
+
+#endif /* MV_CLS2_HW */
diff --git a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls3Hw.c b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls3Hw.c
new file mode 100644
index 0000000..2cd107b
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls3Hw.c
@@ -0,0 +1,1340 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#include "mvPp2Cls3Hw.h"
+
+CLS3_SHADOW_HASH_ENTRY mvCls3ShadowTbl[MV_PP2_CLS_C3_HASH_TBL_SIZE];
+int mvCls3ShadowExtTbl[MV_PP2_CLS_C3_EXT_TBL_SIZE];
+
+static int mvPp2ClsC3SwActDump(MV_PP2_CLS_C3_ENTRY *c3);
+
+static int initHitCounter = 0;
+
+/******************************************************************************
+ * 			Common utilities
+
+******************************************************************************/
+static void mvPp2ClsC3ShadowSet(int hekSize, int index, int ext_index)
+{
+	mvCls3ShadowTbl[index].size = hekSize;
+
+	if (hekSize > MV_PP2_CLS_C3_HEK_BYTES) {
+		mvCls3ShadowTbl[index].ext_ptr = ext_index;
+		mvCls3ShadowExtTbl[ext_index] = IN_USE;
+	} else
+		mvCls3ShadowTbl[index].ext_ptr = NOT_IN_USE;
+}
+
+/*-----------------------------------------------------------------------------*/
+void mvPp2ClsC3ShadowInit(void)
+{
+	/* clear hash shadow and extension shadow */
+	int index;
+
+	for (index = 0; index < MV_PP2_CLS_C3_HASH_TBL_SIZE; index++) {
+		mvCls3ShadowTbl[index].size = 0;
+		mvCls3ShadowTbl[index].ext_ptr = NOT_IN_USE;
+	}
+
+	for (index = 0; index < MV_PP2_CLS_C3_EXT_TBL_SIZE; index++)
+		mvCls3ShadowExtTbl[index] = NOT_IN_USE;
+}
+
+/*-----------------------------------------------------------------------------*/
+int mvPp2ClsC3ShadowFreeGet(void)
+{
+	int index;
+
+	/* Go through the all entires from first to last */
+	for (index = 0; index < MV_PP2_CLS_C3_HASH_TBL_SIZE; index++) {
+		if (!mvCls3ShadowTbl[index].size)
+			break;
+	}
+	return index;
+}
+/*-----------------------------------------------------------------------------*/
+int mvPp2ClsC3ShadowExtFreeGet(void)
+{
+	int index;
+
+	/* Go through the all entires from first to last */
+	for (index = 0; index < MV_PP2_CLS_C3_EXT_TBL_SIZE; index++) {
+		if (mvCls3ShadowExtTbl[index] == NOT_IN_USE)
+			break;
+	}
+	return index;
+}
+/*-----------------------------------------------------------------------------*/
+void mvPp2C3ShadowClear(int index)
+{
+	int ext_ptr;
+
+	mvCls3ShadowTbl[index].size = 0;
+	ext_ptr = mvCls3ShadowTbl[index].ext_ptr;
+
+	if (ext_ptr != NOT_IN_USE)
+		mvCls3ShadowExtTbl[ext_ptr] = NOT_IN_USE;
+
+	mvCls3ShadowTbl[index].ext_ptr = NOT_IN_USE;
+}
+/*-------------------------------------------------------------------------------
+retun 1 scan procedure completed
+TODO - ASK RUVEN , i use scane state , is it good enough ?
+-------------------------------------------------------------------------------*/
+/*
+static int mvPp2ClsC3ScanIsCompleate(void)
+{
+	unsigned int regVal;
+
+	regVal = mvPp2RdReg(MV_PP2_CLS3_STATE_REG);
+	regVal &= MV_PP2_CLS3_STATE_SC_DONE_MASK;
+	regVal >>= MV_PP2_CLS3_STATE_SC_DONE;
+
+	return regVal;
+}
+*/
+/*-------------------------------------------------------------------------------
+return 1 if that the last CPU access (Query,Add or Delete) was completed
+-------------------------------------------------------------------------------*/
+static int mvPp2ClsC3CpuIsDone(void)
+{
+	unsigned int regVal;
+
+	regVal = mvPp2RdReg(MV_PP2_CLS3_STATE_REG);
+	regVal &= MV_PP2_CLS3_STATE_CPU_DONE_MASK;
+	regVal >>= MV_PP2_CLS3_STATE_CPU_DONE;
+	return regVal;
+}
+
+/*-------------------------------------------------------------------------------
+0x0  "ScanCompleted"  scan completed and the scan results are ready in hardware
+0x1  "HitCountersClear"  The engine is clearing the Hit Counters
+0x2  "ScanWait"  The engine waits for the scan delay timer
+0x3  "ScanInProgress"  The scan process is in progress
+-------------------------------------------------------------------------------*/
+static int mvPp2ClsC3ScanStateGet(int *state)
+{
+	unsigned int regVal;
+
+	PTR_VALIDATE(state);
+
+	regVal = mvPp2RdReg(MV_PP2_CLS3_STATE_REG);
+	regVal &= MV_PP2_CLS3_STATE_SC_STATE_MASK;
+	regVal >>= MV_PP2_CLS3_STATE_SC_STATE;
+	*state = regVal;
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------
+return 1 if counters clearing is completed
+--------------------------------------------------------------------------------*/
+static int mvPp2ClsC3HitCntrClearDone(void)
+{
+	unsigned int regVal;
+
+	regVal = mvPp2RdReg(MV_PP2_CLS3_STATE_REG);
+	regVal &= MV_PP2_CLS3_STATE_CLEAR_CTR_DONE_MASK;
+	regVal >>= MV_PP2_CLS3_STATE_CLEAR_CTR_DONE;
+	return regVal;
+}
+/*-------------------------------------------------------------------------------*/
+
+void mvPp2ClsC3SwClear(MV_PP2_CLS_C3_ENTRY *c3)
+{
+	memset(c3, 0, sizeof(MV_PP2_CLS_C3_ENTRY));
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC3Init()
+{
+	int rc;
+
+	mvPp2ClsC3ShadowInit();
+	rc = mvPp2ClsC3HitCntrsClearAll();
+	return rc;
+}
+
+/*-------------------------------------------------------------------------------
+  bank first 2 entries are reserved for miss actions
+--------------------------------------------------------------------------------*/
+static int mvPp2ClsC3IsReservedIndex(int index)
+{
+	if ((index % 512/*MV_PP2_CLS_C3_BANK_SIZE*/) > 1)
+		/* not reserved */
+		return MV_FALSE;
+
+	return MV_TRUE;
+}
+
+/*-------------------------------------------------------------------------------
+Add entry to hash table
+ext_index used only if hek size < 12
+-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC3HwAdd(MV_PP2_CLS_C3_ENTRY *c3, int index, int ext_index)
+{
+	int regStartInd, hekSize, iter = 0;
+	unsigned int regVal = 0;
+
+
+	PTR_VALIDATE(c3);
+	POS_RANGE_VALIDATE(index, MV_PP2_CLS3_HASH_OP_TBL_ADDR_MAX);
+
+	c3->index = index;
+
+	/* write key control */
+	mvPp2WrReg(MV_PP2_CLS3_KEY_CTRL_REG, c3->key.key_ctrl);
+
+	hekSize = ((c3->key.key_ctrl & KEY_CTRL_HEK_SIZE_MASK) >> KEY_CTRL_HEK_SIZE);
+
+	if (hekSize > MV_PP2_CLS_C3_HEK_BYTES) {
+		/* Extension */
+		POS_RANGE_VALIDATE(ext_index, MV_PP2_CLS3_HASH_OP_EXT_TBL_ADDR_MAX)
+		c3->ext_index = ext_index;
+		regVal |= (ext_index << MV_PP2_CLS3_HASH_OP_EXT_TBL_ADDR);
+
+		/* write 9 hek refisters */
+		regStartInd = 0;
+	} else
+		/* write 3 hek refisters */
+		regStartInd = 6;
+
+	for (; regStartInd < MV_PP2_CLS_C3_EXT_HEK_WORDS; regStartInd++)
+		mvPp2WrReg(MV_PP2_CLS3_KEY_HEK_REG(regStartInd), c3->key.hek.words[regStartInd]);
+
+
+	regVal |= (index << MV_PP2_CLS3_HASH_OP_TBL_ADDR);
+	regVal |= (1 << MV_PP2_CLS3_HASH_OP_ADD);
+	regVal |= (initHitCounter << MV_PP2_CLS3_HASH_OP_INIT_CTR_VAL);
+
+	/*trigger ADD operation*/
+	mvPp2WrReg(MV_PP2_CLS3_HASH_OP_REG, regVal);
+
+	/* wait to cpu access done bit */
+	while (!mvPp2ClsC3CpuIsDone())
+		if (++iter >= RETRIES_EXCEEDED) {
+			mvOsPrintf("%s:Error - retries exceeded.\n", __func__);
+			return MV_CLS3_RETRIES_EXCEEDED;
+		}
+
+	/* write action table registers */
+	mvPp2WrReg(MV_PP2_CLS3_ACT_REG, c3->sram.regs.actions);
+	mvPp2WrReg(MV_PP2_CLS3_ACT_QOS_ATTR_REG, c3->sram.regs.qos_attr);
+	mvPp2WrReg(MV_PP2_CLS3_ACT_HWF_ATTR_REG, c3->sram.regs.hwf_attr);
+	mvPp2WrReg(MV_PP2_CLS3_ACT_DUP_ATTR_REG, c3->sram.regs.dup_attr);
+
+	/* set entry as valid, extesion pointer in use only if size > 12*/
+	mvPp2ClsC3ShadowSet(hekSize, index, ext_index);
+
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC3HwDel(int index)
+{
+
+	unsigned int regVal = 0;
+	int iter = 0;
+
+	POS_RANGE_VALIDATE(index, MV_PP2_CLS3_HASH_OP_TBL_ADDR_MAX);
+
+	regVal |= (index << MV_PP2_CLS3_HASH_OP_TBL_ADDR);
+	regVal |= (1 << MV_PP2_CLS3_HASH_OP_DEL);
+
+	/*trigger del operation*/
+	mvPp2WrReg(MV_PP2_CLS3_HASH_OP_REG, regVal);
+
+	/* wait to cpu access done bit */
+	while (!mvPp2ClsC3CpuIsDone())
+		if (++iter >= RETRIES_EXCEEDED) {
+			mvOsPrintf("%s:Error - retries exceeded.\n", __func__);
+			return MV_CLS3_RETRIES_EXCEEDED;
+		}
+
+	/* delete form shadow and extension shadow if exist */
+	mvPp2C3ShadowClear(index);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC3HwDelAll()
+{
+	int index, status;
+
+	for (index = 0; index < MV_PP2_CLS_C3_HASH_TBL_SIZE; index++) {
+		status = mvPp2ClsC3HwDel(index);
+		if (status != MV_OK)
+			return status;
+	}
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+void mvPp2ClsC3HwInitCtrSet(int cntVal)
+{
+	initHitCounter = cntVal;
+}
+
+/*-------------------------------------------------------------------------------*/
+
+static int mvPp2ClsC3HwQueryAddRelocate(int new_idx, int max_depth, int cur_depth)
+{
+	int status, index_free, idx = 0;
+	unsigned char occupied_bmp;
+	MV_PP2_CLS_C3_ENTRY local_c3;
+	int usedIndex[MV_PP2_CLS3_HASH_BANKS_NUM] = {0};
+
+	if (cur_depth >= max_depth)
+		return MV_CLS3_RETRIES_EXCEEDED;
+
+
+	mvPp2ClsC3SwClear(&local_c3);
+
+	if (mvPp2ClsC3HwRead(&local_c3, new_idx)) {
+		mvOsPrintf("%s could not get key for index [0x%x]\n", __func__, new_idx);
+		return MV_CLS3_RETRIES_EXCEEDED;
+	}
+
+	if (mvPp2ClsC3HwQuery(&local_c3, &occupied_bmp, usedIndex)) {
+		mvOsPrintf("%s: mvPp2ClsC3HwQuery failed, depth = %d\n", __func__, cur_depth);
+		return MV_CLS3_ERR;
+	}
+
+	/* fill in indices for this key */
+	for (idx = 0; idx < MV_PP2_CLS3_HASH_BANKS_NUM; idx++) {
+		/* if new index is in the bank index, skip it */
+		if (new_idx == usedIndex[idx] || mvPp2ClsC3IsReservedIndex(usedIndex[idx])) {
+			usedIndex[idx] = 0;
+			continue;
+		}
+
+		/* found a vacant index */
+		if (!(occupied_bmp & (1 << idx))) {
+			index_free = usedIndex[idx];
+			break;
+		}
+	}
+
+	/* no free index, recurse and relocate another key */
+	if (idx == MV_PP2_CLS3_HASH_BANKS_NUM) {
+#ifdef MV_DEBUG
+		mvOsPrintf("new[0x%.3x]:%.1d ", new_idx, cur_depth);
+		for (idx = 0; idx < MV_PP2_CLS3_HASH_BANKS_NUM; idx++)
+			mvOsPrintf("0x%.3x ", usedIndex[idx]);
+		mvOsPrintf("\n");
+#endif
+
+		/* recurse over all valid indices */
+		for (idx = 0; idx < MV_PP2_CLS3_HASH_BANKS_NUM; idx++) {
+			if (usedIndex[idx] == 0)
+				continue;
+
+			if (mvPp2ClsC3HwQueryAddRelocate(usedIndex[idx], max_depth, cur_depth+1) == MV_OK)
+				break;
+		}
+
+		/* tried relocate, no valid entries found */
+		if (idx == MV_PP2_CLS3_HASH_BANKS_NUM)
+			return MV_CLS3_RETRIES_EXCEEDED;
+
+	}
+
+	/* if we reached here, we found a valid free index */
+	index_free = usedIndex[idx];
+
+	/* del is not necessary */
+/*
+	status = mvPp2ClsC3HwDel(new_idx);
+
+	if (status != MV_OK) {
+		mvOsPrintf("%s:Error - mvPp2ClsC3HwDel failed, depth = %d\n", __func__, cur_depth);
+		return status;
+	}
+*/
+	/*We do not chage extension tabe*/
+	status = mvPp2ClsC3HwAdd(&local_c3, index_free, local_c3.ext_index);
+
+	if (status != MV_OK) {
+		mvOsPrintf("%s:Error - mvPp2ClsC3HwAdd failed, depth = %d\\n", __func__, cur_depth);
+		return status;
+	}
+
+	mvOsPrintf("key relocated  0x%.3x->0x%.3x\n", new_idx, index_free);
+
+	return MV_OK;
+}
+
+
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC3HwQueryAdd(MV_PP2_CLS_C3_ENTRY *c3, int max_search_depth)
+{
+	int usedIndex[MV_PP2_CLS3_HASH_BANKS_NUM] = {0};
+	unsigned char occupied_bmp;
+	int idx, index_free, hekSize, status, ext_index = 0;
+
+	status = mvPp2ClsC3HwQuery(c3, &occupied_bmp, usedIndex);
+
+	if (status != MV_OK) {
+		mvOsPrintf("%s:Error - mvPp2ClsC3HwQuery failed\n", __func__);
+		return status;
+	}
+
+	/* Select avaliable entry index */
+	for (idx = 0; idx < MV_PP2_CLS3_HASH_BANKS_NUM; idx++) {
+		if (!(occupied_bmp & (1 << idx)))
+			if (!mvPp2ClsC3IsReservedIndex(usedIndex[idx]))
+				break;
+	}
+
+	/* Avaliable index did not found, try to relocate another key */
+
+	if (idx == MV_PP2_CLS3_HASH_BANKS_NUM) {
+
+		/* save all valid bank indices */
+		for (idx = 0; idx < MV_PP2_CLS3_HASH_BANKS_NUM; idx++) {
+			if (mvPp2ClsC3IsReservedIndex(usedIndex[idx]))
+				usedIndex[idx] = 0;
+		}
+
+		for (idx = 0; idx < MV_PP2_CLS3_HASH_BANKS_NUM; idx++) {
+			if (mvPp2ClsC3IsReservedIndex(usedIndex[idx]))
+				continue;
+
+			if (mvPp2ClsC3HwQueryAddRelocate(usedIndex[idx], max_search_depth, 0 /*curren depth*/) == MV_OK)
+				break;
+		}
+
+		if (idx == MV_PP2_CLS3_HASH_BANKS_NUM) {
+			/* Avaliable index did not found*/
+			mvOsPrintf("%s:Error - HASH table is full.\n", __func__);
+			return MV_CLS3_ERR;
+		}
+	}
+
+	index_free = usedIndex[idx];
+
+	hekSize = ((c3->key.key_ctrl & KEY_CTRL_HEK_SIZE_MASK) >> KEY_CTRL_HEK_SIZE);
+
+	if (hekSize > MV_PP2_CLS_C3_HEK_BYTES) {
+		/* Get Free Extension Index */
+		ext_index = mvPp2ClsC3ShadowExtFreeGet();
+
+		if (ext_index == MV_PP2_CLS_C3_HASH_TBL_SIZE) {
+			mvOsPrintf("%s:Error - Extension table is full.\n", __func__);
+			return MV_CLS3_ERR;
+		}
+	}
+
+	status = mvPp2ClsC3HwAdd(c3, index_free, ext_index);
+
+	if (status != MV_OK) {
+		mvOsPrintf("%s:Error - mvPp2ClsC3HwAdd failed\n", __func__);
+		return status;
+	}
+
+	if (hekSize > MV_PP2_CLS_C3_HEK_BYTES)
+		mvOsPrintf("Added C3 entry @ index=0x%.3x ext=0x%.3x\n", index_free, ext_index);
+	else
+		mvOsPrintf("Added C3 entry @ index=0x%.3x\n", index_free);
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+/*if index or occupied_bmp is NULL dump the data 				 */
+/* index[] size must be 8							 */
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC3HwQuery(MV_PP2_CLS_C3_ENTRY *c3, unsigned char *occupied_bmp, int index[])
+{
+	int idx = 0;
+	unsigned int regVal = 0;
+
+	PTR_VALIDATE(c3);
+
+	/* write key control */
+	mvPp2WrReg(MV_PP2_CLS3_KEY_CTRL_REG, c3->key.key_ctrl);
+
+	/* write hek */
+	for (idx = 0; idx < MV_PP2_CLS_C3_EXT_HEK_WORDS; idx++)
+		mvPp2WrReg(MV_PP2_CLS3_KEY_HEK_REG(idx), c3->key.hek.words[idx]);
+
+	/*trigger query operation*/
+	mvPp2WrReg(MV_PP2_CLS3_QRY_ACT_REG, (1 << MV_PP2_CLS3_QRY_ACT));
+
+	idx = 0;
+	while (!mvPp2ClsC3CpuIsDone())
+		if (++idx >= RETRIES_EXCEEDED) {
+			mvOsPrintf("%s:Error - retries exceeded.\n", __func__);
+			return MV_CLS3_RETRIES_EXCEEDED;
+		}
+
+	regVal = mvPp2RdReg(MV_PP2_CLS3_STATE_REG) & MV_PP2_CLS3_STATE_OCCIPIED_MASK;
+	regVal = regVal >> MV_PP2_CLS3_STATE_OCCIPIED;
+
+	if ((!occupied_bmp) || (!index)) {
+		/* print to screen - call from sysfs*/
+		for (idx = 0; idx < MV_PP2_CLS3_HASH_BANKS_NUM; idx++)
+			mvOsPrintf("0x%8.8x	%s\n",
+				mvPp2RdReg(MV_PP2_CLS3_QRY_RES_HASH_REG(idx)),
+				(regVal & (1 << idx)) ? "OCCUPIED" : "FREE");
+		return MV_OK;
+	}
+
+	*occupied_bmp = regVal;
+	for (idx = 0; idx < MV_PP2_CLS3_HASH_BANKS_NUM; idx++)
+		index[idx] = mvPp2RdReg(MV_PP2_CLS3_QRY_RES_HASH_REG(idx));
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC3HwRead(MV_PP2_CLS_C3_ENTRY *c3, int index)
+{
+	int i, isExt;
+	MV_U32 regVal = 0;
+
+	unsigned int hashData[MV_PP2_CLS3_HASH_DATA_REG_NUM];
+	unsigned int hashExtData[MV_PP2_CLS3_HASH_EXT_DATA_REG_NUM];
+
+	PTR_VALIDATE(c3);
+	POS_RANGE_VALIDATE(index, MV_PP2_CLS3_HASH_OP_TBL_ADDR_MAX);
+
+	mvPp2ClsC3SwClear(c3);
+
+	c3->index = index;
+	c3->ext_index = NOT_IN_USE;
+
+	/* write index */
+	mvPp2WrReg(MV_PP2_CLS3_DB_INDEX_REG, index);
+
+	regVal |= (index << MV_PP2_CLS3_HASH_OP_TBL_ADDR);
+	mvPp2WrReg(MV_PP2_CLS3_HASH_OP_REG, regVal);
+
+	/* read action table */
+	c3->sram.regs.actions = mvPp2RdReg(MV_PP2_CLS3_ACT_REG);
+	c3->sram.regs.qos_attr = mvPp2RdReg(MV_PP2_CLS3_ACT_QOS_ATTR_REG);
+	c3->sram.regs.hwf_attr = mvPp2RdReg(MV_PP2_CLS3_ACT_HWF_ATTR_REG);
+	c3->sram.regs.dup_attr = mvPp2RdReg(MV_PP2_CLS3_ACT_DUP_ATTR_REG);
+
+	/* read hash data*/
+	for (i = 0; i < MV_PP2_CLS3_HASH_DATA_REG_NUM; i++)
+		hashData[i] = mvPp2RdReg(MV_PP2_CLS3_HASH_DATA_REG(i));
+
+	if (mvCls3ShadowTbl[index].size == 0) {
+		/* entry not in use */
+		return MV_OK;
+	}
+
+	c3->key.key_ctrl = 0;
+
+	if (mvCls3ShadowTbl[index].ext_ptr == NOT_IN_USE) {
+		isExt = 0;
+		/* TODO REMOVE NEXT LINES- ONLY FOR INTERNAL VALIDATION */
+		if ((mvCls3ShadowTbl[index].size == 0) ||
+			 (mvCls3ShadowTbl[index].ext_ptr != NOT_IN_USE)) {
+				mvOsPrintf("%s: SW internal error.\n", __func__);
+				return MV_CLS3_SW_INTERNAL;
+		}
+
+		/*read Multihash entry data*/
+		c3->key.hek.words[6] = hashData[0]; /* hek 0*/
+		c3->key.hek.words[7] = hashData[1]; /* hek 1*/
+		c3->key.hek.words[8] = hashData[2]; /* hek 2*/
+
+		/* write key control data to SW */
+		c3->key.key_ctrl |= (((hashData[3] & KEY_PRT_ID_MASK(isExt)) >>
+					(KEY_PRT_ID(isExt) % DWORD_BITS_LEN)) << KEY_CTRL_PRT_ID);
+
+		c3->key.key_ctrl |= (((hashData[3] & KEY_PRT_ID_TYPE_MASK(isExt)) >>
+					(KEY_PRT_ID_TYPE(isExt) % DWORD_BITS_LEN)) << KEY_CTRL_PRT_ID_TYPE);
+
+		c3->key.key_ctrl |= (((hashData[3] & KEY_LKP_TYPE_MASK(isExt)) >>
+					(KEY_LKP_TYPE(isExt) % DWORD_BITS_LEN)) << KEY_CTRL_LKP_TYPE);
+
+		c3->key.key_ctrl |= (((hashData[3] & KEY_L4_INFO_MASK(isExt)) >>
+					(KEY_L4_INFO(isExt) % DWORD_BITS_LEN)) << KEY_CTRL_L4);
+
+	} else {
+		isExt = 1;
+		/* TODO REMOVE NEXT LINES- ONLY FOR INTERNAL VALIDATION */
+		if ((mvCls3ShadowTbl[index].size == 0) ||
+			 (mvCls3ShadowTbl[index].ext_ptr == NOT_IN_USE)) {
+				mvOsPrintf("%s: SW internal error.\n", __func__);
+				return MV_CLS3_SW_INTERNAL;
+		}
+		c3->ext_index = mvCls3ShadowTbl[index].ext_ptr;
+
+		/* write extension index */
+		mvPp2WrReg(MV_PP2_CLS3_DB_INDEX_REG, mvCls3ShadowTbl[index].ext_ptr);
+
+		/* read hash extesion data*/
+		for (i = 0; i < MV_PP2_CLS3_HASH_EXT_DATA_REG_NUM; i++)
+			hashExtData[i] = mvPp2RdReg(MV_PP2_CLS3_HASH_EXT_DATA_REG(i));
+
+
+		/* heks bytes 35 - 32 */
+		c3->key.hek.words[8] = ((hashData[2] & 0x00FFFFFF) << 8) | ((hashData[1] & 0xFF000000) >> 24);
+
+		/* heks bytes 31 - 28 */
+		c3->key.hek.words[7] = ((hashData[1] & 0x00FFFFFF) << 8) | ((hashData[0] & 0xFF000000) >> 24);
+
+		/* heks bytes 27 - 24 */
+		c3->key.hek.words[6] = ((hashData[0] & 0x00FFFFFF) << 8) | (hashExtData[6] & 0x000000FF);
+
+		c3->key.hek.words[5] = hashExtData[5]; /* heks bytes 23 - 20 */
+		c3->key.hek.words[4] = hashExtData[4]; /* heks bytes 19 - 16 */
+		c3->key.hek.words[3] = hashExtData[3]; /* heks bytes 15 - 12 */
+		c3->key.hek.words[2] = hashExtData[2]; /* heks bytes 11 - 8  */
+		c3->key.hek.words[1] = hashExtData[1]; /* heks bytes 7 - 4   */
+		c3->key.hek.words[0] = hashExtData[0]; /* heks bytes 3 - 0   */
+
+		/* write key control data to SW*/
+
+		c3->key.key_ctrl |= (((hashData[3] & KEY_PRT_ID_MASK(isExt)) >>
+					(KEY_PRT_ID(isExt) % DWORD_BITS_LEN)) << KEY_CTRL_PRT_ID);
+		/* port ID type */
+		c3->key.key_ctrl |= ((((hashData[2] & 0x80000000) >> 31) |
+					((hashData[3] & 0x1) << 1)) << KEY_CTRL_PRT_ID_TYPE);
+
+		c3->key.key_ctrl |= (((hashData[2] & KEY_LKP_TYPE_MASK(isExt)) >>
+					(KEY_LKP_TYPE(isExt) % DWORD_BITS_LEN)) << KEY_CTRL_LKP_TYPE);
+
+		c3->key.key_ctrl |= (((hashData[2] & KEY_L4_INFO_MASK(isExt)) >>
+					(KEY_L4_INFO(isExt) % DWORD_BITS_LEN)) << KEY_CTRL_L4);
+	}
+
+	/* update hek size */
+	c3->key.key_ctrl |= ((mvCls3ShadowTbl[index].size << KEY_CTRL_HEK_SIZE) & KEY_CTRL_HEK_SIZE_MASK);
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC3SwDump(MV_PP2_CLS_C3_ENTRY *c3)
+{
+	int hekSize;
+
+	PTR_VALIDATE(c3);
+
+	mvOsPrintf("\n");
+	mvOsPrintf("INDEX[0x%3.3x] ", c3->index);
+
+	hekSize = ((c3->key.key_ctrl & KEY_CTRL_HEK_SIZE_MASK) >> KEY_CTRL_HEK_SIZE);
+
+	/* print extension index if exist*/
+	if (hekSize > MV_PP2_CLS_C3_HEK_BYTES)
+		/* extension */
+		mvOsPrintf("EXT_INDEX[0x%2.2x] ", c3->ext_index);
+	else
+		/* without extension */
+		mvOsPrintf("EXT_INDEX[ NA ] ");
+
+	mvOsPrintf("SIZE[0x%2.2x] ", hekSize);
+	mvOsPrintf("PRT[ID = 0x%2.2x,TYPE = 0x%1.1x] ",
+			((c3->key.key_ctrl & KEY_CTRL_PRT_ID_MASK) >> KEY_CTRL_PRT_ID),
+			((c3->key.key_ctrl & KEY_CTRL_PRT_ID_TYPE_MASK) >> KEY_CTRL_PRT_ID_TYPE));
+
+	mvOsPrintf("LKP_TYPE[0x%1.1x] ",
+			((c3->key.key_ctrl & KEY_CTRL_LKP_TYPE_MASK) >> KEY_CTRL_LKP_TYPE));
+
+	mvOsPrintf("L4INFO[0x%1.1x] ",
+			((c3->key.key_ctrl & KEY_CTRL_L4_MASK) >> KEY_CTRL_L4));
+
+	mvOsPrintf("\n\n");
+	mvOsPrintf("HEK	");
+	if (hekSize > MV_PP2_CLS_C3_HEK_BYTES)
+		/* extension */
+		mvOsPrintf(HEK_EXT_FMT, HEK_EXT_VAL(c3->key.hek.words));
+	else
+		/* without extension */
+		mvOsPrintf(HEK_FMT, HEK_VAL(c3->key.hek.words));
+	mvOsPrintf("\n");
+	return mvPp2ClsC3SwActDump(c3);
+}
+
+/*-------------------------------------------------------------------------------*/
+
+static int mvPp2ClsC3SwActDump(MV_PP2_CLS_C3_ENTRY *c3)
+{
+	PTR_VALIDATE(c3);
+	mvOsPrintf("\n");
+
+	/*------------------------------*/
+	/*	actions 0x1B60		*/
+	/*------------------------------*/
+
+	mvOsPrintf("ACT_TBL: COLOR   LOW_Q   HIGH_Q    FWD    POLICER   FID\n");
+	mvOsPrintf("CMD:     [%1d]      [%1d]    [%1d]        [%1d]   [%1d]       [%1d]\n",
+			((c3->sram.regs.actions & (ACT_COLOR_MASK)) >> ACT_COLOR),
+			((c3->sram.regs.actions & (ACT_LOW_Q_MASK)) >> ACT_LOW_Q),
+			((c3->sram.regs.actions & (ACT_HIGH_Q_MASK)) >> ACT_HIGH_Q),
+			((c3->sram.regs.actions & ACT_FWD_MASK) >> ACT_FWD),
+			((c3->sram.regs.actions & (ACT_POLICER_SELECT_MASK)) >> ACT_POLICER_SELECT),
+			((c3->sram.regs.actions & ACT_FLOW_ID_EN_MASK) >> ACT_FLOW_ID_EN));
+
+	/*mvOsPrintf("ACT_TBL:		LOW_Q	HIGH_Q		POLICER\n");*/
+
+	mvOsPrintf("VAL:              [%1d]    [0x%x]            [%1d]\n",
+			((c3->sram.regs.qos_attr & (ACT_QOS_ATTR_MDF_LOW_Q_MASK)) >> ACT_QOS_ATTR_MDF_LOW_Q),
+			((c3->sram.regs.qos_attr & (ACT_QOS_ATTR_MDF_HIGH_Q_MASK)) >> ACT_QOS_ATTR_MDF_HIGH_Q),
+			((c3->sram.regs.dup_attr & (ACT_DUP_POLICER_MASK)) >> ACT_DUP_POLICER_ID));
+
+	mvOsPrintf("\n");
+	/*------------------------------*/
+	/*	hwf_attr 0x1B68		*/
+	/*------------------------------*/
+
+	mvOsPrintf("HWF_ATTR: IPTR    DPTR   CHKSM\n");
+	mvOsPrintf("          0x%1.1x     0x%4.4x %s\t",
+			((c3->sram.regs.hwf_attr & ACT_HWF_ATTR_IPTR_MASK) >> ACT_HWF_ATTR_IPTR),
+			((c3->sram.regs.hwf_attr & ACT_HWF_ATTR_DPTR_MASK) >> ACT_HWF_ATTR_DPTR),
+			(((c3->sram.regs.hwf_attr & ACT_HWF_ATTR_CHKSM_EN_MASK) >> ACT_HWF_ATTR_CHKSM_EN) ? "ENABLE" : "DISABLE"));
+
+	mvOsPrintf("\n");
+
+	/*------------------------------*/
+	/*	dup_attr 0x1B6C		*/
+	/*------------------------------*/
+
+	mvOsPrintf("DUP_ATTR: FID     COUNT\n");
+	mvOsPrintf("          0x%2.2x      0x%1.1x\t",
+			((c3->sram.regs.dup_attr & ACT_DUP_FID_MASK) >> ACT_DUP_FID),
+			((c3->sram.regs.dup_attr & ACT_DUP_COUNT_MASK) >> ACT_DUP_COUNT));
+
+	mvOsPrintf("\n\n");
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC3HwDump()
+{
+	int index;
+	MV_PP2_CLS_C3_ENTRY c3;
+
+	mvPp2ClsC3SwClear(&c3);
+
+	for (index = 0; index < MV_PP2_CLS_C3_HASH_TBL_SIZE; index++) {
+		if (mvCls3ShadowTbl[index].size > 0) {
+			mvPp2ClsC3HwRead(&c3, index);
+			mvPp2ClsC3SwDump(&c3);
+			mvOsPrintf("----------------------------------------------------------------------\n");
+		}
+	}
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC3HwExtDump()
+{
+	int index, i;
+	unsigned int hashExtData[MV_PP2_CLS3_HASH_EXT_DATA_REG_NUM];
+
+	mvOsPrintf("INDEX    DATA\n");
+
+	for (index = 0; index <  MV_PP2_CLS_C3_EXT_TBL_SIZE; index++)
+		if (mvCls3ShadowExtTbl[index] == IN_USE) {
+			/* write extension index */
+			mvPp2WrReg(MV_PP2_CLS3_DB_INDEX_REG, index);
+
+			/* read hash extesion data*/
+			for (i = 0; i < MV_PP2_CLS3_HASH_EXT_DATA_REG_NUM; i++)
+				hashExtData[i] = mvPp2RdReg(MV_PP2_CLS3_HASH_EXT_DATA_REG(i));
+
+			mvOsPrintf("[0x%2.2x] %8.8x %8.8x %8.8x %8.8x %8.8x %8.8x %8.8x\n",
+					index, hashExtData[6], hashExtData[5], hashExtData[4],
+					hashExtData[3], hashExtData[2], hashExtData[1], hashExtData[0]);
+		} /* if */
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+/*		APIs for Classification C3 key fields			   	 */
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC3SwL4infoSet(MV_PP2_CLS_C3_ENTRY *c3, int l4info)
+{
+	PTR_VALIDATE(c3);
+	POS_RANGE_VALIDATE(l4info, KEY_CTRL_L4_MAX);
+
+	c3->key.key_ctrl &= ~KEY_CTRL_L4_MASK;
+	c3->key.key_ctrl |= (l4info << KEY_CTRL_L4);
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC3SwLkpTypeSet(MV_PP2_CLS_C3_ENTRY *c3, int lkp_type)
+{
+	PTR_VALIDATE(c3);
+	POS_RANGE_VALIDATE(lkp_type, KEY_CTRL_LKP_TYPE_MAX);
+
+	c3->key.key_ctrl &= ~KEY_CTRL_LKP_TYPE_MASK;
+	c3->key.key_ctrl |= (lkp_type << KEY_CTRL_LKP_TYPE);
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC3SwPortIDSet(MV_PP2_CLS_C3_ENTRY *c3, int type, int portid)
+{
+	PTR_VALIDATE(c3);
+	POS_RANGE_VALIDATE(portid, KEY_CTRL_PRT_ID_MAX);
+	POS_RANGE_VALIDATE(type, KEY_CTRL_PRT_ID_TYPE_MAX);
+
+	c3->key.key_ctrl &= ~(KEY_CTRL_PRT_ID_MASK | KEY_CTRL_PRT_ID_TYPE_MASK);
+	c3->key.key_ctrl |= ((portid << KEY_CTRL_PRT_ID) | (type << KEY_CTRL_PRT_ID_TYPE));
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC3SwHekSizeSet(MV_PP2_CLS_C3_ENTRY *c3, int hekSize)
+{
+	PTR_VALIDATE(c3);
+	POS_RANGE_VALIDATE(hekSize, KEY_CTRL_HEK_SIZE_MAX);
+
+	c3->key.key_ctrl &= ~KEY_CTRL_HEK_SIZE_MASK;
+	c3->key.key_ctrl |= (hekSize << KEY_CTRL_HEK_SIZE);
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC3SwHekByteSet(MV_PP2_CLS_C3_ENTRY *c3, unsigned int offs, unsigned char byte)
+{
+	PTR_VALIDATE(c3);
+	POS_RANGE_VALIDATE(offs, ((MV_PP2_CLS_C3_EXT_HEK_WORDS*4) - 1));
+
+	c3->key.hek.bytes[offs] = byte;
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC3SwHekWordSet(MV_PP2_CLS_C3_ENTRY *c3, unsigned int offs, unsigned int word)
+{
+	PTR_VALIDATE(c3);
+	POS_RANGE_VALIDATE(offs, ((MV_PP2_CLS_C3_EXT_HEK_WORDS) - 1));
+
+	c3->key.hek.words[offs] = word;
+
+	return MV_OK;
+}
+
+
+/*-------------------------------------------------------------------------------*/
+/*		APIs for Classification C3 action table fields		   	 */
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC3ColorSet(MV_PP2_CLS_C3_ENTRY *c3, int cmd)
+{
+	PTR_VALIDATE(c3);
+	POS_RANGE_VALIDATE(cmd, COLOR_RED_AND_LOCK);
+
+	c3->sram.regs.actions &= ~ACT_COLOR_MASK;
+	c3->sram.regs.actions |= (cmd << ACT_COLOR);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC3QueueHighSet(MV_PP2_CLS_C3_ENTRY *c3, int cmd, int queue)
+{
+	PTR_VALIDATE(c3);
+
+
+	POS_RANGE_VALIDATE(cmd, UPDATE_AND_LOCK);
+	POS_RANGE_VALIDATE(queue, ACT_QOS_ATTR_MDF_HIGH_Q_MAX);
+
+	/*set command*/
+	c3->sram.regs.actions &= ~ACT_HIGH_Q_MASK;
+	c3->sram.regs.actions |= (cmd << ACT_HIGH_Q);
+
+	/*set modify High queue value*/
+	c3->sram.regs.qos_attr &= ~ACT_QOS_ATTR_MDF_HIGH_Q_MASK;
+	c3->sram.regs.qos_attr |= (queue << ACT_QOS_ATTR_MDF_HIGH_Q);
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC3QueueLowSet(MV_PP2_CLS_C3_ENTRY *c3, int cmd, int queue)
+{
+	PTR_VALIDATE(c3);
+
+	POS_RANGE_VALIDATE(cmd, UPDATE_AND_LOCK);
+	POS_RANGE_VALIDATE(queue, ACT_QOS_ATTR_MDF_LOW_Q_MAX);
+
+	/*set command*/
+	c3->sram.regs.actions &= ~ACT_LOW_Q_MASK;
+	c3->sram.regs.actions |= (cmd << ACT_LOW_Q);
+
+	/*set modify High queue value*/
+	c3->sram.regs.qos_attr &= ~ACT_QOS_ATTR_MDF_LOW_Q_MASK;
+	c3->sram.regs.qos_attr |= (queue << ACT_QOS_ATTR_MDF_LOW_Q);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC3QueueSet(MV_PP2_CLS_C3_ENTRY *c3, int cmd, int queue)
+{
+	int status = MV_OK;
+	int qHigh, qLow;
+
+	PTR_VALIDATE(c3);
+	POS_RANGE_VALIDATE(queue, ACT_QOS_ATTR_Q_MAX);
+
+	/* cmd validation in set functions */
+
+	qHigh = (queue & ACT_QOS_ATTR_MDF_HIGH_Q_MASK) >> ACT_QOS_ATTR_MDF_HIGH_Q;
+	qLow = (queue & ACT_QOS_ATTR_MDF_LOW_Q_MASK) >> ACT_QOS_ATTR_MDF_LOW_Q;
+
+	status |= mvPp2ClsC3QueueLowSet(c3, cmd, qLow);
+	status |= mvPp2ClsC3QueueHighSet(c3, cmd, qHigh);
+
+	return status;
+}
+
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC3ForwardSet(MV_PP2_CLS_C3_ENTRY *c3, int cmd)
+{
+	PTR_VALIDATE(c3);
+	POS_RANGE_VALIDATE(cmd, HWF_AND_LOW_LATENCY_AND_LOCK);
+
+	c3->sram.regs.actions &= ~ACT_FWD_MASK;
+	c3->sram.regs.actions |= (cmd << ACT_FWD);
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC3PolicerSet(MV_PP2_CLS_C3_ENTRY *c3, int cmd, int policerId)
+{
+	PTR_VALIDATE(c3);
+	POS_RANGE_VALIDATE(cmd, UPDATE_AND_LOCK);
+	POS_RANGE_VALIDATE(policerId, ACT_DUP_POLICER_MAX);
+
+	c3->sram.regs.actions &= ~ACT_POLICER_SELECT_MASK;
+	c3->sram.regs.actions |= (cmd << ACT_POLICER_SELECT);
+
+	c3->sram.regs.dup_attr &= ~ACT_DUP_POLICER_MASK;
+	c3->sram.regs.dup_attr |= (policerId << ACT_DUP_POLICER_ID);
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC3ModSet(MV_PP2_CLS_C3_ENTRY *c3, int data_ptr, int instr_offs, int l4_csum)
+{
+	PTR_VALIDATE(c3);
+	POS_RANGE_VALIDATE(data_ptr, ACT_HWF_ATTR_DPTR_MAX);
+	POS_RANGE_VALIDATE(instr_offs, ACT_HWF_ATTR_IPTR_MAX);
+	POS_RANGE_VALIDATE(l4_csum, 1);
+
+	c3->sram.regs.hwf_attr &= ~ACT_HWF_ATTR_DPTR_MASK;
+	c3->sram.regs.hwf_attr &= ~ACT_HWF_ATTR_IPTR_MASK;
+	c3->sram.regs.hwf_attr &= ~ACT_HWF_ATTR_CHKSM_EN_MASK;
+
+	c3->sram.regs.hwf_attr |= (data_ptr << ACT_HWF_ATTR_DPTR);
+	c3->sram.regs.hwf_attr |= (instr_offs << ACT_HWF_ATTR_IPTR);
+	c3->sram.regs.hwf_attr |= (l4_csum << ACT_HWF_ATTR_CHKSM_EN);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC3DupSet(MV_PP2_CLS_C3_ENTRY *c3, int dupid, int count)
+{
+	PTR_VALIDATE(c3);
+	POS_RANGE_VALIDATE(count, ACT_DUP_COUNT_MAX);
+	POS_RANGE_VALIDATE(dupid, ACT_DUP_FID_MAX);
+
+	/*set Flow ID enable*/
+	c3->sram.regs.actions |= (1 << ACT_FLOW_ID_EN);
+
+	/*set flowid and count*/
+	c3->sram.regs.dup_attr &= ~(ACT_DUP_FID_MASK | ACT_DUP_COUNT_MASK);
+	c3->sram.regs.dup_attr |= (dupid << ACT_DUP_FID);
+	c3->sram.regs.dup_attr |= (count << ACT_DUP_COUNT);
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+/*		APIs for Classification C3 Hit counters management	   	 */
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC3HitCntrsClear(int lkpType)
+{
+	/* clear all counters that entry lookup type corresponding to lkpType */
+	int iter = 0;
+
+	POS_RANGE_VALIDATE(lkpType, KEY_CTRL_LKP_TYPE_MAX);
+
+	mvPp2WrReg(MV_PP2_CLS3_CLEAR_COUNTERS_REG, lkpType);
+
+	/* wait to clear het counters done bit */
+	while (!mvPp2ClsC3HitCntrClearDone())
+		if (++iter >= RETRIES_EXCEEDED) {
+			mvOsPrintf("%s:Error - retries exceeded.\n", __func__);
+			return MV_CLS3_RETRIES_EXCEEDED;
+		}
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC3HitCntrsClearAll(void)
+{
+	int iter = 0;
+
+	mvPp2WrReg(MV_PP2_CLS3_CLEAR_COUNTERS_REG, 0x1F /*clear all*/);
+
+	/* wait to clear het counters done bit */
+	while (!mvPp2ClsC3HitCntrClearDone())
+		if (++iter >= RETRIES_EXCEEDED) {
+			mvOsPrintf("%s:Error - retries exceeded.\n", __func__);
+			return MV_CLS3_RETRIES_EXCEEDED;
+		}
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC3HitCntrsRead(int index, MV_U32 *cntr)
+{
+	unsigned int counter;
+
+	POS_RANGE_VALIDATE(index, MV_PP2_CLS3_HASH_OP_TBL_ADDR_MAX);
+
+	/*write entry index*/
+	mvPp2WrReg(MV_PP2_CLS3_DB_INDEX_REG, index);
+
+	/*counter read*/
+	counter = mvPp2RdReg(MV_PP2_CLS3_HIT_COUNTER_REG) & MV_PP2_CLS3_HIT_COUNTER_MASK;
+
+	if (!cntr)
+		mvOsPrintf("ADDR:0x%3.3x	COUNTER VAL:0x%4.4x\n", index, counter);
+	else
+		*cntr = counter;
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC3HitCntrsReadAll(void)
+{
+	unsigned int counter, index;
+
+	for (index = 0; index < MV_PP2_CLS_C3_HASH_TBL_SIZE; index++) {
+		mvPp2ClsC3HitCntrsRead(index, &counter);
+
+		/* skip initial counter value */
+		if (counter == 0)
+			continue;
+
+		mvOsPrintf("ADDR:0x%3.3x	COUNTER VAL:0x%4.4x\n", index, counter);
+	}
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+/*	 APIs for Classification C3 hit counters scan fields operation 		 */
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC3ScanStart()
+{
+	int scState, iter = 0;
+
+	/* trigger scan operation */
+	mvPp2WrReg(MV_PP2_CLS3_SC_ACT_REG, (1 << MV_PP2_CLS3_SC_ACT));
+
+	do {
+		mvPp2ClsC3ScanStateGet(&scState);
+	} while (scState != 0 && ((iter++) < RETRIES_EXCEEDED));/*scan compleated*/
+
+	if (iter >= RETRIES_EXCEEDED) {
+		mvOsPrintf("%s:Error - retries exceeded.\n", __func__);
+		return MV_CLS3_RETRIES_EXCEEDED;
+	}
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC3ScanRegs()
+{
+	unsigned int prop, propVal;
+
+	prop = mvPp2RdReg(MV_PP2_CLS3_SC_PROP_REG);
+	propVal = mvPp2RdReg(MV_PP2_CLS3_SC_PROP_VAL_REG);
+
+	mvOsPrintf("%-32s: 0x%x = 0x%08x\n", "MV_PP2_CLS3_SC_PROP_REG", MV_PP2_CLS3_SC_PROP_REG, prop);
+	mvOsPrintf("%-32s: 0x%x = 0x%08x\n", "MV_PP2_CLS3_SC_PROP_VAL_REG", MV_PP2_CLS3_SC_PROP_VAL_REG, propVal);
+	mvOsPrintf("\n");
+
+	mvOsPrintf("MODE      = %s\n", ((MV_PP2_CLS3_SC_PROP_TH_MODE_MASK & prop) == 0) ? "Below" : "Above");
+	mvOsPrintf("CLEAR     = %s\n", ((MV_PP2_CLS3_SC_PROP_CLEAR_MASK & prop) == 0) ? "NoClear" : "Clear  ");
+
+	/* lookup type */
+	((MV_PP2_CLS3_SC_PROP_LKP_TYPE_EN_MASK & prop) == 0) ?
+		mvOsPrintf("LKP_TYPE  = NA\n") :
+		mvOsPrintf("LKP_TYPE  = 0x%x\n", ((MV_PP2_CLS3_SC_PROP_LKP_TYPE_MASK & prop) >> MV_PP2_CLS3_SC_PROP_LKP_TYPE));
+
+	/* start index */
+	mvOsPrintf("START     = 0x%x\n", (MV_PP2_CLS3_SC_PROP_START_ENTRY_MASK & prop) >> MV_PP2_CLS3_SC_PROP_START_ENTRY);
+
+	/* threshold */
+	mvOsPrintf("THRESHOLD = 0x%x\n", (MV_PP2_CLS3_SC_PROP_VAL_TH_MASK & propVal) >> MV_PP2_CLS3_SC_PROP_VAL_TH);
+
+	/* delay value */
+	mvOsPrintf("DELAY     = 0x%x\n\n", (MV_PP2_CLS3_SC_PROP_VAL_DELAY_MASK & propVal) >> MV_PP2_CLS3_SC_PROP_VAL_DELAY);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+/*mod = 0 below th . mode = 1 above threshold*/
+int mvPp2ClsC3ScanThreshSet(int mode, int thresh)
+{
+	unsigned int prop, propVal;
+
+	POS_RANGE_VALIDATE(mode, 1); /* one bit */
+	POS_RANGE_VALIDATE(thresh, MV_PP2_CLS3_SC_PROP_VAL_TH_MAX);
+
+	prop = mvPp2RdReg(MV_PP2_CLS3_SC_PROP_REG);
+	propVal = mvPp2RdReg(MV_PP2_CLS3_SC_PROP_VAL_REG);
+
+
+	prop &= ~MV_PP2_CLS3_SC_PROP_TH_MODE_MASK;
+	prop |= (mode << MV_PP2_CLS3_SC_PROP_TH_MODE);
+
+	propVal &= ~MV_PP2_CLS3_SC_PROP_VAL_TH_MASK;
+	propVal |= (thresh << MV_PP2_CLS3_SC_PROP_VAL_TH);
+
+	mvPp2WrReg(MV_PP2_CLS3_SC_PROP_REG, prop);
+	mvPp2WrReg(MV_PP2_CLS3_SC_PROP_VAL_REG, propVal);
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC3ScanLkpTypeSet(int type)
+{
+	unsigned int prop;
+
+	RANGE_VALIDATE(type, -1, MV_PP2_CLS3_SC_PROP_LKP_TYPE_MAX);
+	prop = mvPp2RdReg(MV_PP2_CLS3_SC_PROP_REG);
+
+	if (type == -1)
+		/* scan all entries */
+		prop &= ~(1 << MV_PP2_CLS3_SC_PROP_LKP_TYPE_EN);
+	else {
+		/* scan according to lookup type */
+		prop |= (1 << MV_PP2_CLS3_SC_PROP_LKP_TYPE_EN);
+		prop &= ~MV_PP2_CLS3_SC_PROP_LKP_TYPE_MASK;
+		prop |= (type << MV_PP2_CLS3_SC_PROP_LKP_TYPE);
+	}
+
+	mvPp2WrReg(MV_PP2_CLS3_SC_PROP_REG, prop);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC3ScanClearBeforeEnSet(int en)
+{
+	unsigned int prop;
+
+	POS_RANGE_VALIDATE(en, 1); /* one bit */
+
+	prop = mvPp2RdReg(MV_PP2_CLS3_SC_PROP_REG);
+
+	prop &= ~MV_PP2_CLS3_SC_PROP_CLEAR_MASK;
+	prop |= (en << MV_PP2_CLS3_SC_PROP_CLEAR);
+
+	mvPp2WrReg(MV_PP2_CLS3_SC_PROP_REG, prop);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC3ScanStartIndexSet(int idx)
+{
+	unsigned int prop;
+
+	POS_RANGE_VALIDATE(idx, MV_PP2_CLS3_HASH_OP_TBL_ADDR_MAX); /* one bit */
+
+	prop = mvPp2RdReg(MV_PP2_CLS3_SC_PROP_REG);
+
+	prop &= ~MV_PP2_CLS3_SC_PROP_START_ENTRY_MASK;
+	prop |= (idx << MV_PP2_CLS3_SC_PROP_START_ENTRY);
+
+	mvPp2WrReg(MV_PP2_CLS3_SC_PROP_REG, prop);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC3ScanDelaySet(int time)
+{
+	unsigned int propVal;
+
+	POS_RANGE_VALIDATE(time, MV_PP2_CLS3_SC_PROP_VAL_DELAY_MAX);
+
+	propVal = mvPp2RdReg(MV_PP2_CLS3_SC_PROP_VAL_REG);
+	propVal &= ~MV_PP2_CLS3_SC_PROP_VAL_DELAY_MASK;
+	propVal |= (time << MV_PP2_CLS3_SC_PROP_VAL_DELAY);
+
+	mvPp2WrReg(MV_PP2_CLS3_SC_PROP_VAL_REG, propVal);
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC3ScanResRead(int index, int *addr, int *cnt)
+{
+	unsigned int regVal, scState, addres, counter;
+	int iter = 0;
+
+	POS_RANGE_VALIDATE(index, MV_PP2_CLS_C3_SC_RES_TBL_SIZE-1);
+
+	do {
+		mvPp2ClsC3ScanStateGet(&scState);
+	} while (scState != 0 && ((iter++) < RETRIES_EXCEEDED));/*scan compleated*/
+
+	if (iter >= RETRIES_EXCEEDED) {
+		mvOsPrintf("%s:Error - retries exceeded.\n", __func__);
+		return MV_CLS3_RETRIES_EXCEEDED;
+	}
+
+	/*write index*/
+	mvPp2WrReg(MV_PP2_CLS3_SC_INDEX_REG, index);
+
+	/*read date*/
+	regVal = mvPp2RdReg(MV_PP2_CLS3_SC_RES_REG);
+	addres = (regVal & MV_PP2_CLS3_SC_RES_ENTRY_MASK) >> MV_PP2_CLS3_SC_RES_ENTRY;
+	counter = (regVal & MV_PP2_CLS3_SC_RES_CTR_MASK) >> MV_PP2_CLS3_SC_RES_CTR;
+
+	/* if one of parameters is null - func call from sysfs*/
+	if ((!addr) | (!cnt))
+		mvOsPrintf("INDEX:0x%2.2x	ADDR:0x%3.3x	COUNTER VAL:0x%4.4x\n", index, addres, counter);
+	else {
+		*addr = addres;
+		*cnt = counter;
+	}
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC3ScanResDump()
+{
+	int addr, cnt, resNum, index;
+
+	mvPp2ClsC3ScanNumOfResGet(&resNum);
+
+	mvOsPrintf("INDEX	ADDRESS		COUNTER\n");
+	for (index = 0; index < resNum; index++) {
+		mvPp2ClsC3ScanResRead(index, &addr, &cnt);
+		mvOsPrintf("[0x%2.2x]\t[0x%3.3x]\t[0x%4.4x]\n", index, addr, cnt);
+	}
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC3ScanNumOfResGet(int *resNum)
+{
+	unsigned int regVal, scState;
+	int iter = 0;
+
+	do {
+		mvPp2ClsC3ScanStateGet(&scState);
+	} while (scState != 0 && ((iter++) < RETRIES_EXCEEDED));/*scan compleated*/
+
+	if (iter >= RETRIES_EXCEEDED) {
+		mvOsPrintf("%s:Error - retries exceeded.\n", __func__);
+		return MV_CLS3_RETRIES_EXCEEDED;
+	}
+
+	regVal = mvPp2RdReg(MV_PP2_CLS3_SC_TIMER_REG);
+	regVal &= MV_PP2_CLS3_STATE_NO_OF_SC_RES_MASK;
+	regVal >>= MV_PP2_CLS3_STATE_NO_OF_SC_RES;
+	*resNum = regVal;
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------
+
+int mvPp2ClsC3ScanTimerGet(int *timer)
+{
+	unsigned int regVal;
+
+	if (timer == NULL) {
+		mvOsPrintf("mvCls3Hw %s: null pointer.\n", __func__);
+		return MV_CLS3_ERR;
+	}
+
+	regVal = mvPp2RdReg(MV_PP2_CLS3_SC_TIMER_REG);
+	regVal &= MV_PP2_CLS3_SC_TIMER_MASK;
+	regVal >>= MV_PP2_CLS3_SC_TIMER;
+	*timer = regVal;
+	return MV_OK;
+}
+-------------------------------------------------------------------------------------*/
diff --git a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls3Hw.h b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls3Hw.h
new file mode 100644
index 0000000..8d68da3
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls3Hw.h
@@ -0,0 +1,401 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_CLS3_HW_H__
+#define __MV_CLS3_HW_H__
+
+#include "mvPp2ClsActHw.h"
+#include "../common/mvPp2ErrCode.h"
+#include "../common/mvPp2Common.h"
+#include "../gbe/mvPp2GbeRegs.h"
+
+/*-------------------------------------------------------------------------------*/
+/*			Classifier C3 Top Registers	    			 */
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS3_KEY_CTRL_REG			(MV_PP2_REG_BASE + 0x1C10)
+#define KEY_CTRL_L4					0
+#define KEY_CTRL_L4_BITS				3
+#define KEY_CTRL_L4_MAX					((1 << KEY_CTRL_L4_BITS) - 1)
+#define KEY_CTRL_L4_MASK				(((1 << KEY_CTRL_L4_BITS) - 1) << KEY_CTRL_L4)
+
+
+#define KEY_CTRL_LKP_TYPE				8
+#define KEY_CTRL_LKP_TYPE_BITS				4
+#define KEY_CTRL_LKP_TYPE_MAX				((1 << KEY_CTRL_LKP_TYPE_BITS) - 1)
+#define KEY_CTRL_LKP_TYPE_MASK				(((1 << KEY_CTRL_LKP_TYPE_BITS) - 1) << KEY_CTRL_LKP_TYPE)
+
+
+#define KEY_CTRL_PRT_ID_TYPE				12
+#define KEY_CTRL_PRT_ID_TYPE_BITS			2
+#define KEY_CTRL_PRT_ID_TYPE_MAX			((1<<KEY_CTRL_PRT_ID_TYPE_BITS) - 1)
+#define KEY_CTRL_PRT_ID_TYPE_MASK			(((1<<KEY_CTRL_PRT_ID_TYPE_BITS) - 1) << KEY_CTRL_PRT_ID_TYPE)
+
+#define KEY_CTRL_PRT_ID					16
+#define KEY_CTRL_PRT_ID_BITS				8
+#define KEY_CTRL_PRT_ID_MAX				((1<<KEY_CTRL_PRT_ID_BITS) - 1)
+#define KEY_CTRL_PRT_ID_MASK				(((1<<KEY_CTRL_PRT_ID_BITS) - 1) << KEY_CTRL_PRT_ID)
+
+#define KEY_CTRL_HEK_SIZE				24
+#define KEY_CTRL_HEK_SIZE_BITS				6
+#define KEY_CTRL_HEK_SIZE_MAX				36
+#define KEY_CTRL_HEK_SIZE_MASK				(((1<<KEY_CTRL_HEK_SIZE_BITS) - 1) << KEY_CTRL_HEK_SIZE)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS3_KEY_HEK_REG(reg_num)		(MV_PP2_REG_BASE + 0x1C34 - 4*(reg_num))
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS3_QRY_ACT_REG				(MV_PP2_REG_BASE + 0x1C40)
+#define MV_PP2_CLS3_QRY_ACT				0
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS3_QRY_RES_HASH_REG(hash)		(MV_PP2_REG_BASE + 0x1C50 + 4*(hash))
+#define MV_PP2_CLS3_HASH_BANKS_NUM			8
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS3_HASH_OP_REG				(MV_PP2_REG_BASE + 0x1C84)
+
+#define MV_PP2_CLS3_HASH_OP_TBL_ADDR			0
+#define MV_PP2_CLS3_HASH_OP_TBL_ADDR_BITS		12
+#define MV_PP2_CLS3_HASH_OP_TBL_ADDR_MASK		(((1 << MV_PP2_CLS3_HASH_OP_TBL_ADDR_BITS) - 1) << MV_PP2_CLS3_HASH_OP_TBL_ADDR)
+#define MV_PP2_CLS3_HASH_OP_TBL_ADDR_MAX		((1 << MV_PP2_CLS3_HASH_OP_TBL_ADDR_BITS) - 1)
+
+#define MV_PP2_CLS3_HASH_OP_DEL				14
+#define MV_PP2_CLS3_HASH_OP_ADD				15
+
+#define MV_PP2_CLS3_HASH_OP_EXT_TBL_ADDR		16
+#define MV_PP2_CLS3_HASH_OP_EXT_TBL_ADDR_BITS		8
+#define MV_PP2_CLS3_HASH_OP_EXT_TBL_ADDR_MASK		(((1 << MV_PP2_CLS3_HASH_OP_EXT_TBL_ADDR_BITS) - 1) << MV_PP2_CLS3_HASH_OP_EXT_TBL_ADDR)
+#define MV_PP2_CLS3_HASH_OP_EXT_TBL_ADDR_MAX		((1 << MV_PP2_CLS3_HASH_OP_EXT_TBL_ADDR_BITS) - 1)
+
+#define MV_PP2_CLS3_HASH_OP_INIT_CTR_VAL		24
+/*-------------------------------------------------------------------------------*/
+#define MV_PP2_CLS3_STATE_REG				(MV_PP2_REG_BASE + 0x1C8C)
+#define MV_PP2_CLS3_STATE_CPU_DONE			0
+#define MV_PP2_CLS3_STATE_CPU_DONE_MASK			(1 << MV_PP2_CLS3_STATE_CPU_DONE)
+
+#define MV_PP2_CLS3_STATE_CLEAR_CTR_DONE		1
+#define MV_PP2_CLS3_STATE_CLEAR_CTR_DONE_MASK		(1 << MV_PP2_CLS3_STATE_CLEAR_CTR_DONE)
+
+#define MV_PP2_CLS3_STATE_SC_DONE			2
+#define MV_PP2_CLS3_STATE_SC_DONE_MASK			(1 << MV_PP2_CLS3_STATE_SC_DONE)
+
+#define MV_PP2_CLS3_STATE_OCCIPIED			8
+#define MV_PP2_CLS3_STATE_OCCIPIED_BITS			8
+#define MV_PP2_CLS3_STATE_OCCIPIED_MASK			(((1 << MV_PP2_CLS3_STATE_OCCIPIED_BITS) - 1) << MV_PP2_CLS3_STATE_OCCIPIED)
+
+#define MV_PP2_CLS3_STATE_SC_STATE			16
+#define MV_PP2_CLS3_STATE_SC_STATE_BITS			2
+#define MV_PP2_CLS3_STATE_SC_STATE_MASK			(((1 << MV_PP2_CLS3_STATE_SC_STATE_BITS) - 1) << MV_PP2_CLS3_STATE_SC_STATE)
+/*
+SCAN STATUS
+0 - scan compleat
+1 -	hit counter clear
+3 - scan wait
+4 - scan in progress
+*/
+
+#define MV_PP2_CLS3_STATE_NO_OF_SC_RES			20
+#define MV_PP2_CLS3_STATE_NO_OF_SC_RES_BITS		9
+#define MV_PP2_CLS3_STATE_NO_OF_SC_RES_MASK		(((1 << MV_PP2_CLS3_STATE_NO_OF_SC_RES_BITS) - 1) << MV_PP2_CLS3_STATE_NO_OF_SC_RES)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS3_DB_INDEX_REG			(MV_PP2_REG_BASE + 0x1C90)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS3_HASH_DATA_REG(num)			(MV_PP2_REG_BASE + 0x1CA0 + 4*(num)) /* 0-3 valid val*/
+#define MV_PP2_CLS3_HASH_DATA_REG_NUM			4
+#define MV_PP2_CLS3_HASH_EXT_DATA_REG(num)		(MV_PP2_REG_BASE + 0x1CC0 + 4*(num))
+#define MV_PP2_CLS3_HASH_EXT_DATA_REG_NUM		7
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS3_CLEAR_COUNTERS_REG			(MV_PP2_REG_BASE + 0x1D00)
+#define MV_PP2_CLS3_CLEAR_COUNTERS			5
+#define MV_PP2_CLS3_CLEAR_COUNTERS_BITS			5
+#define MV_PP2_CLS3_CLEAR_COUNTERS_MASK			(((1 << MV_PP2_CLS3_CLEAR_COUNTERS_BITS) - 1)  << MV_PP2_CLS3_CLEAR_COUNTERS)
+#define MV_PP2_CLS3_CLEAR_COUNTERS_MAX			0x1F
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS3_HIT_COUNTER_REG			(MV_PP2_REG_BASE + 0x1D08)
+#define MV_PP2_CLS3_HIT_COUNTER				0
+#define MV_PP2_CLS3_HIT_COUNTER_BITS			14
+#define MV_PP2_CLS3_HIT_COUNTER_MASK			(((1 << MV_PP2_CLS3_HIT_COUNTER_BITS) - 1) << MV_PP2_CLS3_HIT_COUNTER)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS3_SC_PROP_REG				(MV_PP2_REG_BASE + 0x1D10)
+
+#define MV_PP2_CLS3_SC_PROP_TH_MODE			0
+#define MV_PP2_CLS3_SC_PROP_TH_MODE_MASK		(1 << MV_PP2_CLS3_SC_PROP_TH_MODE)
+
+#define MV_PP2_CLS3_SC_PROP_CLEAR			1
+#define MV_PP2_CLS3_SC_PROP_CLEAR_MASK			(1 << MV_PP2_CLS3_SC_PROP_CLEAR)
+
+#define MV_PP2_CLS3_SC_PROP_LKP_TYPE_EN			3
+#define MV_PP2_CLS3_SC_PROP_LKP_TYPE_EN_MASK		(1 << MV_PP2_CLS3_SC_PROP_LKP_TYPE_EN)
+
+#define MV_PP2_CLS3_SC_PROP_LKP_TYPE			4
+#define MV_PP2_CLS3_SC_PROP_LKP_TYPE_BITS		4
+#define MV_PP2_CLS3_SC_PROP_LKP_TYPE_MAX		((1 << MV_PP2_CLS3_SC_PROP_LKP_TYPE_BITS) - 1)
+#define MV_PP2_CLS3_SC_PROP_LKP_TYPE_MASK		(((1 << MV_PP2_CLS3_SC_PROP_LKP_TYPE_BITS) - 1) << MV_PP2_CLS3_SC_PROP_LKP_TYPE)
+
+#define MV_PP2_CLS3_SC_PROP_START_ENTRY			16
+#define MV_PP2_CLS3_SC_PROP_START_ENTRY_MASK		(((1 << MV_PP2_CLS3_HASH_OP_TBL_ADDR_BITS) - 1) << MV_PP2_CLS3_SC_PROP_START_ENTRY)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS3_SC_PROP_VAL_REG			(MV_PP2_REG_BASE + 0x1D14)
+
+#define MV_PP2_CLS3_SC_PROP_VAL_TH			0
+#define MV_PP2_CLS3_SC_PROP_VAL_TH_BITS			13
+#define MV_PP2_CLS3_SC_PROP_VAL_TH_MASK			(((1 << MV_PP2_CLS3_SC_PROP_VAL_TH_BITS) - 1) << MV_PP2_CLS3_SC_PROP_VAL_TH)
+#define MV_PP2_CLS3_SC_PROP_VAL_TH_MAX			((1 << MV_PP2_CLS3_SC_PROP_VAL_TH_BITS) - 1)
+
+#define MV_PP2_CLS3_SC_PROP_VAL_DELAY			16
+#define MV_PP2_CLS3_SC_PROP_VAL_DELAY_BITS		16
+#define MV_PP2_CLS3_SC_PROP_VAL_DELAY_MASK		(((1 << MV_PP2_CLS3_SC_PROP_VAL_DELAY_BITS) - 1) << MV_PP2_CLS3_SC_PROP_VAL_DELAY)
+#define MV_PP2_CLS3_SC_PROP_VAL_DELAY_MAX		((1 << MV_PP2_CLS3_SC_PROP_VAL_DELAY_BITS) - 1)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS3_SC_TIMER_REG			(MV_PP2_REG_BASE + 0x1D18)
+#define MV_PP2_CLS3_SC_TIMER				0
+#define MV_PP2_CLS3_SC_TIMER_BITS			16
+#define MV_PP2_CLS3_SC_TIMER_MASK			(((1 << MV_PP2_CLS3_SC_TIMER_BITS) - 1) << MV_PP2_CLS3_SC_TIMER)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS3_SC_ACT_REG				(MV_PP2_REG_BASE + 0x1D20)
+#define MV_PP2_CLS3_SC_ACT				0
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS3_SC_INDEX_REG			(MV_PP2_REG_BASE + 0x1D28)
+#define MV_PP2_CLS3_SC_INDEX				0
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS3_SC_RES_REG				(MV_PP2_REG_BASE + 0x1D2C)
+#define MV_PP2_CLS3_SC_RES_ENTRY			0
+#define MV_PP2_CLS3_SC_RES_ENTRY_MASK			(((1 << MV_PP2_CLS3_HASH_OP_TBL_ADDR_BITS) - 1) << MV_PP2_CLS3_SC_RES_ENTRY)
+
+#define MV_PP2_CLS3_SC_RES_CTR				16
+#define MV_PP2_CLS3_SC_RES_CTR_MASK			(((1 << MV_PP2_CLS3_HIT_COUNTER_BITS) - 1) << MV_PP2_CLS3_SC_RES_CTR)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS3_ACT_REG				(MV_PP2_REG_BASE + 0x1D40)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS3_ACT_QOS_ATTR_REG			(MV_PP2_REG_BASE + 0x1D44)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS3_ACT_HWF_ATTR_REG			(MV_PP2_REG_BASE + 0x1D48)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS3_ACT_DUP_ATTR_REG			(MV_PP2_REG_BASE + 0x1D4C)
+/*-------------------------------------------------------------------------------*/
+
+
+/*-------------------------------------------------------------------------------*/
+/*		Classifier C3 offsets in hash table		    		 */
+/*-------------------------------------------------------------------------------*/
+
+#define KEY_OCCUPIED					114
+#define KEY_FORMAT					113
+#define KEY_PTR_EXT					105
+
+#define KEY_PRT_ID(ext_mode)				((ext_mode == 1) ? (97) : (105))
+#define KEY_PRT_ID_MASK(ext_mode)			(((1 << KEY_CTRL_PRT_ID_BITS) - 1) << (KEY_PRT_ID(ext_mode) % 32))
+
+#define KEY_PRT_ID_TYPE(ext_mode)			((ext_mode == 1) ? (95) : (103))
+#define KEY_PRT_ID_TYPE_MASK(ext_mode)			(((1 << KEY_CTRL_PRT_ID_TYPE_BITS) - 1) << (KEY_PRT_ID_TYPE(ext_mode) % 32))
+
+#define KEY_LKP_TYPE(ext_mode)				((ext_mode == 1) ? (91) : (99))
+#define KEY_LKP_TYPE_MASK(ext_mode)			(((1 << KEY_CTRL_LKP_TYPE_BITS) - 1) << (KEY_LKP_TYPE(ext_mode) % 32))
+
+#define KEY_L4_INFO(ext_mode)				((ext_mode == 1) ? (88) : (96))
+#define KEY_L4_INFO_MASK(ext_mode)			(((1 << KEY_CTRL_L4_BITS) - 1) << (KEY_L4_INFO(ext_mode) % 32))
+
+
+/*-------------------------------------------------------------------------------*/
+/*		Classifier C3 engine Key public APIs		    		 */
+/*-------------------------------------------------------------------------------*/
+
+typedef struct {
+	/* valid if size > 0 */
+	/* size include the extension*/
+	int	ext_ptr;
+	int	size;
+} CLS3_SHADOW_HASH_ENTRY;
+
+#define HEK_EXT_FMT				"%8.8x %8.8x %8.8x | %8.8x %8.8x %8.8x %8.8x %8.8x %8.8x"
+#define HEK_EXT_VAL(p)				p[8], p[7], p[6], p[5], p[4], p[3], p[2], p[1], p[0]
+
+#define HEK_FMT					"%8.8x %8.8x %8.8x"
+#define HEK_VAL(p)				p[8], p[7], p[6]
+
+/*-------------------------------------------------------------------------------*/
+/*			Classifier C3 engine Public APIs	 		 */
+/*-------------------------------------------------------------------------------*/
+#define MV_PP2_CLS_C3_HASH_TBL_SIZE			(4096)
+#define MV_PP2_CLS_C3_EXT_HEK_WORDS			(9)
+#define MV_PP2_CLS_C3_SRAM_WORDS			(5)
+#define MV_PP2_CLS_C3_EXT_TBL_SIZE			(256)
+#define MV_PP2_CLS_C3_HEK_WORDS				(3)
+#define MV_PP2_CLS_C3_HEK_BYTES				12 /* size in bytes */
+#define MV_PP2_CLS_C3_BANK_SIZE				(512)
+
+
+typedef struct mvPp2ClsC3Entry {
+	unsigned int 	index;
+	unsigned int 	ext_index;
+
+	/* unsigned int ext_index; internal DB */
+	struct {
+		union {
+			MV_U32	words[MV_PP2_CLS_C3_EXT_HEK_WORDS];
+			MV_U8	bytes[MV_PP2_CLS_C3_EXT_HEK_WORDS * 4];
+		} hek;
+		MV_U32		key_ctrl;/*0x1C10*/
+	} key;
+	union {
+		MV_U32 words[MV_PP2_CLS_C3_SRAM_WORDS];
+		struct {
+			MV_U32 actions;/*0x1D40*/
+			MV_U32 qos_attr;/*0x1D44*/
+			MV_U32 hwf_attr;/*0x1D48*/
+			MV_U32 dup_attr;/*0x1D4C*/
+		} regs;
+	} sram;
+} MV_PP2_CLS_C3_ENTRY;
+
+
+/*-------------------------------------------------------------------------------*/
+/*			Common utilities				   	 */
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC3Init(void);
+void mvPp2ClsC3ShadowInit(void);
+int mvPp2ClsC3ShadowFreeGet(void);
+int mvPp2ClsC3ShadowExtFreeGet(void);
+void mvPp2C3ShadowClear(int index);
+
+/*-------------------------------------------------------------------------------*/
+/*			APIs for Classification C3 engine		   	 */
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC3HwRead(MV_PP2_CLS_C3_ENTRY *c3, int index);
+int mvPp2ClsC3HwAdd(MV_PP2_CLS_C3_ENTRY *c3, int index, int ext_index);
+int mvPp2ClsC3HwDump(void);
+int mvPp2ClsC3HwExtDump(void);
+int mvPp2ClsC3HwDel(int index);
+int mvPp2ClsC3HwDelAll(void);
+int mvPp2ClsC3SwDump(MV_PP2_CLS_C3_ENTRY *c3);
+void mvPp2ClsC3SwClear(MV_PP2_CLS_C3_ENTRY *c3);
+void mvPp2ClsC3HwInitCtrSet(int cntVal);
+int mvPp2ClsC3HwQuery(MV_PP2_CLS_C3_ENTRY *c3, unsigned char *occupied_bmp, int index[]);
+int mvPp2ClsC3HwQueryAdd(MV_PP2_CLS_C3_ENTRY *c3, int max_search_depth);
+/*-------------------------------------------------------------------------------*/
+/*		APIs for Classification C3 key fields			   	 */
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC3SwL4infoSet(MV_PP2_CLS_C3_ENTRY *c3, int l4info);
+int mvPp2ClsC3SwLkpTypeSet(MV_PP2_CLS_C3_ENTRY *c3, int lkp_type);
+int mvPp2ClsC3SwPortIDSet(MV_PP2_CLS_C3_ENTRY *c3, int type, int portid);
+int mvPp2ClsC3SwHekSizeSet(MV_PP2_CLS_C3_ENTRY *c3, int hek_size);
+int mvPp2ClsC3SwHekByteSet(MV_PP2_CLS_C3_ENTRY *c3, unsigned int offs, unsigned char byte);
+int mvPp2ClsC3SwHekWordSet(MV_PP2_CLS_C3_ENTRY *c3, unsigned int offs, unsigned int word);
+
+/*-------------------------------------------------------------------------------*/
+/*		APIs for Classification C3 action table fields		   	 */
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC3ColorSet(MV_PP2_CLS_C3_ENTRY *c3, int cmd);
+int mvPp2ClsC3QueueHighSet(MV_PP2_CLS_C3_ENTRY *c3, int cmd, int q);
+int mvPp2ClsC3QueueLowSet(MV_PP2_CLS_C3_ENTRY *c3, int cmd, int q);
+int mvPp2ClsC3QueueSet(MV_PP2_CLS_C3_ENTRY *c3, int cmd, int queue);
+int mvPp2ClsC3ForwardSet(MV_PP2_CLS_C3_ENTRY *c3, int cmd);
+int mvPp2ClsC3PolicerSet(MV_PP2_CLS_C3_ENTRY *c3, int cmd, int policerId);
+int mvPp2ClsC3ModSet(MV_PP2_CLS_C3_ENTRY *c3, int data_ptr, int instr_offs, int l4_csum);
+int mvPp2ClsC3DupSet(MV_PP2_CLS_C3_ENTRY *c3, int dupid, int count);
+
+/*-------------------------------------------------------------------------------*/
+/*		APIs for Classification C3 Hit counters management	   	 */
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC3HitCntrsRead(int index, MV_U32 *cntr);
+int mvPp2ClsC3HitCntrsClearAll(void);
+int mvPp2ClsC3HitCntrsReadAll(void);
+int mvPp2ClsC3HitCntrsClear(int lkpType);
+
+
+/*-------------------------------------------------------------------------------*/
+/*	 APIs for Classification C3 hit counters scan fields operation 		 */
+/*-------------------------------------------------------------------------------*/
+#define MV_PP2_CLS_C3_SC_RES_TBL_SIZE			(256)
+
+int mvPp2ClsC3ScanStart(void);
+int mvPp2ClsC3ScanRegs(void);
+int mvPp2ClsC3ScanThreshSet(int mode, int thresh);
+int mvPp2ClsC3ScanClearBeforeEnSet(int en);
+int mvPp2ClsC3ScanLkpTypeSet(int type);
+int mvPp2ClsC3ScanStartIndexSet(int idx);
+int mvPp2ClsC3ScanDelaySet(int time);
+int mvPp2ClsC3ScanResRead(int index, int *addr, int *cnt);
+int mvPp2ClsC3ScanNumOfResGet(int *resNum);
+int mvPp2ClsC3ScanResDump(void);
+
+
+
+#endif /* __MV_CLS3_HW_H__ */
diff --git a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls4Hw.c b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls4Hw.c
new file mode 100644
index 0000000..ecbb772
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls4Hw.c
@@ -0,0 +1,601 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#include "mvPp2Cls4Hw.h"
+
+/*-------------------------------------------------------------------------------*/
+/*			Classifier C4 engine Public APIs			 */
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC4HwPortToRulesSet(int port, int set, int rules)
+{
+	unsigned int regVal;
+
+	POS_RANGE_VALIDATE(port, MV_PP2_MAX_PORTS-1);
+	POS_RANGE_VALIDATE(set, MV_PP2_CLS_C4_GRPS_NUM-1);
+	RANGE_VALIDATE(rules, 1, MV_PP2_CLS_C4_GRP_SIZE);
+
+	regVal = (set << MV_PP2_CLS4_PHY_TO_RL_GRP) | (rules << MV_PP2_CLS4_PHY_TO_RL_RULE_NUM);
+	mvPp2WrReg(MV_PP2_CLS4_PHY_TO_RL_REG(port), regVal);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC4HwUniToRulesSet(int uni, int set, int rules)
+{
+	unsigned int regVal;
+
+	POS_RANGE_VALIDATE(uni, UNI_MAX);
+	POS_RANGE_VALIDATE(set, MV_PP2_CLS_C4_GRPS_NUM-1);
+	RANGE_VALIDATE(rules, 1, MV_PP2_CLS_C4_GRP_SIZE);
+
+	regVal = (set << MV_PP2_CLS4_PHY_TO_RL_GRP) | (rules << MV_PP2_CLS4_PHY_TO_RL_RULE_NUM);
+	mvPp2WrReg(MV_PP2_CLS4_UNI_TO_RL_REG(uni), regVal);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC4HwPortToRulesGet(int port, int *set, int *rules)
+{
+	unsigned int regVal;
+
+	PTR_VALIDATE(set);
+	PTR_VALIDATE(rules);
+
+	regVal = mvPp2RdReg(MV_PP2_CLS4_PHY_TO_RL_REG(port));
+
+	*rules = (regVal & MV_PP2_CLS4_PHY_TO_RL_RULE_NUM_MASK) >> MV_PP2_CLS4_PHY_TO_RL_RULE_NUM;
+	*set = (regVal & MV_PP2_CLS4_PHY_TO_RL_GRP_MASK) >> MV_PP2_CLS4_PHY_TO_RL_GRP;
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC4HwUniToRulesGet(int uni, int *set, int *rules)
+{
+	unsigned int regVal;
+
+	PTR_VALIDATE(set);
+	PTR_VALIDATE(rules);
+
+
+	regVal = mvPp2RdReg(MV_PP2_CLS4_UNI_TO_RL_REG(uni));
+
+	*rules = (regVal & MV_PP2_CLS4_PHY_TO_RL_RULE_NUM_MASK) >> MV_PP2_CLS4_PHY_TO_RL_RULE_NUM;
+	*set = (regVal & MV_PP2_CLS4_PHY_TO_RL_GRP_MASK) >> MV_PP2_CLS4_PHY_TO_RL_GRP;
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC4HwRead(MV_PP2_CLS_C4_ENTRY *C4, int rule, int set)
+{
+	unsigned int regVal = 0;
+	int regInd;
+
+	PTR_VALIDATE(C4);
+
+	POS_RANGE_VALIDATE(rule, (MV_PP2_CLS_C4_GRP_SIZE-1));
+	POS_RANGE_VALIDATE(set, (MV_PP2_CLS_C4_GRPS_NUM-1));
+
+	/* write index reg */
+	regVal = (set << MV_PP2_CLS4_RL_INDEX_GRP) | (rule << MV_PP2_CLS4_RL_INDEX_RULE);
+	mvPp2WrReg(MV_PP2_CLS4_RL_INDEX_REG, regVal);
+
+	C4->ruleIndex = rule;
+	C4->setIndex = set;
+	/* read entry rule fields*/
+	C4->rules.regs.attr[0] = mvPp2RdReg(MV_PP2_CLS4_FATTR1_REG);
+	C4->rules.regs.attr[1] = mvPp2RdReg(MV_PP2_CLS4_FATTR2_REG);
+
+	for (regInd = 0; regInd < MV_PP2_CLS_C4_TBL_DATA_WORDS; regInd++)
+		C4->rules.regs.fdataArr[regInd] = mvPp2RdReg(MV_PP2_CLS4_FDATA_REG(regInd));
+
+	/* read entry from action table */
+	C4->sram.regs.actions = mvPp2RdReg(MV_PP2_CLS4_ACT_REG);
+	C4->sram.regs.qos_attr = mvPp2RdReg(MV_PP2_CLS4_ACT_QOS_ATTR_REG);
+	C4->sram.regs.dup_attr = mvPp2RdReg(MV_PP2_CLS4_ACT_DUP_ATTR_REG);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC4HwWrite(MV_PP2_CLS_C4_ENTRY *C4, int rule, int set)
+{
+	unsigned int regVal = 0;
+	int regInd;
+
+	PTR_VALIDATE(C4);
+
+
+	POS_RANGE_VALIDATE(rule, (MV_PP2_CLS_C4_GRP_SIZE-1));
+	POS_RANGE_VALIDATE(set, (MV_PP2_CLS_C4_GRPS_NUM-1));
+
+	/* write index reg */
+	regVal = (set << MV_PP2_CLS4_RL_INDEX_GRP) | (rule << MV_PP2_CLS4_RL_INDEX_RULE);
+	mvPp2WrReg(MV_PP2_CLS4_RL_INDEX_REG, regVal);
+
+	mvPp2WrReg(MV_PP2_CLS4_FATTR1_REG, C4->rules.regs.attr[0]);
+	mvPp2WrReg(MV_PP2_CLS4_FATTR2_REG, C4->rules.regs.attr[1]);
+
+	for (regInd = 0; regInd < MV_PP2_CLS_C4_TBL_DATA_WORDS; regInd++)
+		mvPp2WrReg(MV_PP2_CLS4_FDATA_REG(regInd), C4->rules.regs.fdataArr[regInd]);
+
+	/* read entry from action table */
+	mvPp2WrReg(MV_PP2_CLS4_ACT_REG, C4->sram.regs.actions);
+	mvPp2WrReg(MV_PP2_CLS4_ACT_QOS_ATTR_REG, C4->sram.regs.qos_attr);
+	mvPp2WrReg(MV_PP2_CLS4_ACT_DUP_ATTR_REG, C4->sram.regs.dup_attr);
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC4SwDump(MV_PP2_CLS_C4_ENTRY *C4)
+{
+	int index;
+
+	PTR_VALIDATE(C4);
+
+	mvOsPrintf("SET: %d	RULE: %d\n", C4->setIndex, C4->ruleIndex);
+	mvOsPrintf("FIELD  ID  OP	DATA\n");
+
+	/*------------------------------*/
+	/*	   fields 0-2		*/
+	/*------------------------------*/
+
+	for (index = 0; index <  4; index++) {
+		mvOsPrintf("%d       %d  %d	",
+				index,
+				MV_PP2_CLS4_FATTR_ID_VAL(index, C4->rules.regs.attr[GET_FIELD_ATRR(index)]),
+				MV_PP2_CLS4_FATTR_OPCODE_VAL(index, C4->rules.regs.attr[GET_FIELD_ATRR(index)]));
+
+		mvOsPrintf(FLD_FMT, FLD_VAL(index, C4->rules.regs.fdataArr));
+		mvOsPrintf("\n");
+	}
+
+	/*------------------------------*/
+	/*	   field 4		*/
+	/*------------------------------*/
+
+	/* index = 4 after loop */
+	mvOsPrintf("%d       %d  %d	",
+			index,
+			MV_PP2_CLS4_FATTR_ID_VAL(index, C4->rules.regs.attr[GET_FIELD_ATRR(index)]),
+			MV_PP2_CLS4_FATTR_OPCODE_VAL(index, C4->rules.regs.attr[GET_FIELD_ATRR(index)]));
+	mvOsPrintf(FLD4_FMT, FLD4_VAL(C4->rules.regs.fdataArr));
+	mvOsPrintf("\n");
+
+	/*------------------------------*/
+	/*	   field 5		*/
+	/*------------------------------*/
+	index++;
+
+	mvOsPrintf("%d       %d  %d	",
+			index,
+			MV_PP2_CLS4_FATTR_ID_VAL(index, C4->rules.regs.attr[GET_FIELD_ATRR(index)]),
+			MV_PP2_CLS4_FATTR_OPCODE_VAL(index, C4->rules.regs.attr[GET_FIELD_ATRR(index)]));
+	mvOsPrintf(FLD5_FMT, FLD5_VAL(C4->rules.regs.fdataArr));
+	mvOsPrintf("\n");
+	mvOsPrintf("\n");
+	mvOsPrintf("VLAN: %d  PPPOE: %d  MACME: %d  L4INFO: %d  L3INFO: %d\n",
+			MV_PP2_CLS4_VLAN_VAL(C4->rules.regs.fdataArr[6]),
+			MV_PP2_CLS4_PPPOE_VAL(C4->rules.regs.fdataArr[6]),
+			MV_PP2_CLS4_MACME_VAL(C4->rules.regs.fdataArr[6]),
+			MV_PP2_CLS4_L4INFO_VAL(C4->rules.regs.fdataArr[6]),
+			MV_PP2_CLS4_L3INFO_VAL(C4->rules.regs.fdataArr[6]));
+	mvOsPrintf("\n");
+	/*------------------------------*/
+	/*	actions	0x1E80		*/
+	/*------------------------------*/
+
+	mvOsPrintf("ACT_TBL:	COLOR	PRIO	DSCP	GPID	LOW_Q	HIGH_Q  POLICER\n");
+	mvOsPrintf("CMD:		[%1d]	[%1d]	[%1d]	[%1d]	[%1d]	[%1d]	[%1d]\n",
+			((C4->sram.regs.actions & (ACT_COLOR_MASK)) >> ACT_COLOR),
+			((C4->sram.regs.actions & (ACT_PRI_MASK)) >> ACT_PRI),
+			((C4->sram.regs.actions & (ACT_DSCP_MASK)) >> ACT_DSCP),
+			((C4->sram.regs.actions & (ACT_GEM_ID_MASK)) >> ACT_GEM_ID),
+			((C4->sram.regs.actions & (ACT_LOW_Q_MASK)) >> ACT_LOW_Q),
+			((C4->sram.regs.actions & (ACT_HIGH_Q_MASK)) >> ACT_HIGH_Q),
+			((C4->sram.regs.actions & (ACT_POLICER_SELECT_MASK)) >> ACT_POLICER_SELECT));
+
+
+	/*------------------------------*/
+	/*	qos_attr 0x1E84		*/
+	/*------------------------------*/
+	/*mvOsPrintf("VAL:		PRIO	DSCP	GPID	LOW_Q	HIGH_Q	 POLICER\n");*/
+
+	mvOsPrintf("VAL:                    [%1d]	[%1d]	[%1d]	[%1d]	[0x%x]	[%1d]\n",
+			((C4->sram.regs.qos_attr & (ACT_QOS_ATTR_MDF_PRI_MASK)) >> ACT_QOS_ATTR_MDF_PRI),
+			((C4->sram.regs.qos_attr & (ACT_QOS_ATTR_MDF_DSCP_MASK)) >> ACT_QOS_ATTR_MDF_DSCP),
+			((C4->sram.regs.qos_attr & (ACT_QOS_ATTR_MDF_GEM_ID_MASK)) >> ACT_QOS_ATTR_MDF_GEM_ID),
+			((C4->sram.regs.qos_attr & (ACT_QOS_ATTR_MDF_LOW_Q_MASK)) >> ACT_QOS_ATTR_MDF_LOW_Q),
+			((C4->sram.regs.qos_attr & (ACT_QOS_ATTR_MDF_HIGH_Q_MASK)) >> ACT_QOS_ATTR_MDF_HIGH_Q),
+			((C4->sram.regs.dup_attr & (ACT_DUP_POLICER_MASK)) >> ACT_DUP_POLICER_ID));
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC4HwDumpAll()
+{
+	int set, rule;
+	MV_PP2_CLS_C4_ENTRY C4;
+
+	for (set = 0; set < MV_PP2_CLS_C4_GRPS_NUM; set++)
+		for (rule = 0; rule <  MV_PP2_CLS_C4_GRP_SIZE; rule++) {
+			mvPp2ClsC4HwRead(&C4, rule, set);
+			mvPp2ClsC4SwDump(&C4);
+			mvOsPrintf("--------------------------------------------------------------------\n");
+		}
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC4RegsDump()
+{
+	int i = 0;
+	char reg_name[100];
+
+
+	for (i = 0; i < MV_PP2_MAX_PORTS; i++) {
+		mvOsSPrintf(reg_name, "MV_PP2_CLS4_PHY_TO_RL_%d_REG", i);
+		mvPp2PrintReg(MV_PP2_CLS4_PHY_TO_RL_REG(i), reg_name);
+	}
+
+	for (i = 0; i < MV_PP2_MAX_PORTS; i++) {
+		mvOsSPrintf(reg_name, "MV_PP2_CLS4_UNI_TO_RL_%d_REG", i);
+		mvPp2PrintReg(MV_PP2_CLS4_UNI_TO_RL_REG(i), reg_name);
+	}
+
+	mvPp2PrintReg(MV_PP2_CLS4_FATTR1_REG, "MV_PP2_CLS4_FATTR1_REG");
+	mvPp2PrintReg(MV_PP2_CLS4_FATTR2_REG, "MV_PP2_CLS4_FATTR2_REG");
+
+	for (i = 0; i < MV_PP2_CLS4_FDATA_REGS_NUM; i++) {
+		mvOsSPrintf(reg_name, "MV_PP2_CLS4_FDATA_%d_REG", i);
+		mvPp2PrintReg(MV_PP2_CLS4_FDATA_REG(i), reg_name);
+	}
+
+	mvPp2PrintReg(MV_PP2_CLS4_RL_INDEX_REG, "MV_PP2_CLS4_RL_INDEX_REG");
+	mvPp2PrintReg(MV_PP2_CLS4_ACT_REG, "MV_PP2_CLS4_ACT_REG");
+	mvPp2PrintReg(MV_PP2_CLS4_ACT_QOS_ATTR_REG, "MV_PP2_CLS4_ACT_QOS_ATTR_REG");
+	mvPp2PrintReg(MV_PP2_CLS4_ACT_DUP_ATTR_REG, "MV_PP2_CLS4_ACT_DUP_ATTR_REG");
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+void mvPp2ClsC4SwClear(MV_PP2_CLS_C4_ENTRY *C4)
+{
+	memset(C4, 0, sizeof(MV_PP2_CLS_C4_ENTRY));
+}
+
+/*-------------------------------------------------------------------------------*/
+void mvPp2ClsC4HwClearAll()
+{
+	int set, rule;
+	MV_PP2_CLS_C4_ENTRY C4;
+
+	mvPp2ClsC4SwClear(&C4);
+
+	for (set = 0; set < MV_PP2_CLS_C4_GRPS_NUM; set++)
+		for (rule = 0; rule <  MV_PP2_CLS_C4_GRP_SIZE; rule++)
+			mvPp2ClsC4HwWrite(&C4, rule, set);
+}
+/*-------------------------------------------------------------------------------*/
+/*			Classifier C4 engine rules APIs	 			 */
+/*-------------------------------------------------------------------------------*/
+
+/*
+set two bytes of data in fields
+offs - offset in byte resolution
+*/
+int mvPp2ClsC4FieldsShortSet(MV_PP2_CLS_C4_ENTRY *C4, int field, unsigned int offs, unsigned short data)
+{
+	PTR_VALIDATE(C4);
+
+	POS_RANGE_VALIDATE(field, MV_PP2_CLS_C4_FIELDS_NUM-1);
+
+	if ((offs % 2) != 0) {
+		mvOsPrintf("mvCls4Hw %s: offset should be even , current func write two bytes of data.\n", __func__);
+		return MV_CLS4_ERR;
+	}
+
+	if (field < 4) {
+		/* fields 0,1,2,3 lenght is 2 bytes */
+		POS_RANGE_VALIDATE(offs, 0);
+		C4->rules.regs.fdataArr[field/2] &= ~(0xFFFF << (16 * (field % 2)));
+		C4->rules.regs.fdataArr[field/2] |= (data << (16 * (field % 2)));
+	}
+
+	else if (field == 4) {
+		/* field 4 lenght is 16 bytes */
+		POS_RANGE_VALIDATE(offs, 14);
+		C4->rules.regs.fdataArr[5 - offs/4] &= ~(0xFFFF << (16 * ((offs / 2) % 2)));
+		C4->rules.regs.fdataArr[5 - offs/4] |= (data << (16 * ((offs / 2) % 2)));
+	} else {
+		/* field 5 lenght is 6 bytes */
+		POS_RANGE_VALIDATE(offs, 4);
+		C4->rules.regs.fdataArr[7 - offs/4] &= ~(0xFFFF << (16 * ((offs / 2) % 2)));
+		C4->rules.regs.fdataArr[7 - offs/4] |= (data << (16 * ((offs / 2) % 2)));
+	}
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC4FieldsParamsSet(MV_PP2_CLS_C4_ENTRY *C4, int field, unsigned int id, unsigned int op)
+{
+	PTR_VALIDATE(C4);
+	POS_RANGE_VALIDATE(field, MV_PP2_CLS_C4_FIELDS_NUM-1);
+	POS_RANGE_VALIDATE(id, MV_PP2_CLS4_FATTR_ID_MAX);
+	POS_RANGE_VALIDATE(op, MV_PP2_CLS4_FATTR_OPCODE_MAX);
+
+	/* clear old ID and opcode*/
+	C4->rules.regs.attr[GET_FIELD_ATRR(field)] &= ~MV_PP2_CLS4_FATTR_ID_MASK(field);
+	C4->rules.regs.attr[GET_FIELD_ATRR(field)] &= ~MV_PP2_CLS4_FATTR_OPCODE_MASK(field);
+
+	/* write new values */
+	C4->rules.regs.attr[GET_FIELD_ATRR(field)] |=  (op << MV_PP2_CLS4_FATTR_OPCODE(field));
+	C4->rules.regs.attr[GET_FIELD_ATRR(field)] |= 	(id << MV_PP2_CLS4_FATTR_ID(field));
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC4SwVlanSet(MV_PP2_CLS_C4_ENTRY *C4, int vlan)
+{
+	PTR_VALIDATE(C4);
+	POS_RANGE_VALIDATE(vlan, MV_PP2_CLS4_VLAN_MAX);
+
+	C4->rules.regs.fdataArr[6] &= ~MV_PP2_CLS4_VLAN_MASK;
+	C4->rules.regs.fdataArr[6] |= (vlan << MV_PP2_CLS4_FDATA7_VLAN);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC4SwPppoeSet(MV_PP2_CLS_C4_ENTRY *C4, int pppoe)
+{
+	PTR_VALIDATE(C4);
+	POS_RANGE_VALIDATE(pppoe, MV_PP2_CLS4_PPPOE_MAX);
+
+	C4->rules.regs.fdataArr[6] &= ~MV_PP2_CLS4_PPPOE_MASK;
+	C4->rules.regs.fdataArr[6] |= (pppoe << MV_PP2_CLS4_FDATA7_PPPOE);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC4SwMacMeSet(MV_PP2_CLS_C4_ENTRY *C4, int mac)
+{
+	PTR_VALIDATE(C4);
+	POS_RANGE_VALIDATE(mac, MV_PP2_CLS4_MACME_MAX);
+
+	C4->rules.regs.fdataArr[6] &= ~MV_PP2_CLS4_MACME_MASK;
+	C4->rules.regs.fdataArr[6] |= (mac << MV_PP2_CLS4_FDATA7_MACME);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC4SwL4InfoSet(MV_PP2_CLS_C4_ENTRY *C4, int info)
+{
+	PTR_VALIDATE(C4);
+	POS_RANGE_VALIDATE(info, MV_PP2_CLS4_L4INFO_MAX);
+
+	C4->rules.regs.fdataArr[6] &= ~MV_PP2_CLS4_L4INFO_MASK;
+	C4->rules.regs.fdataArr[6] |= (info << MV_PP2_CLS4_FDATA7_L4INFO);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC4SwL3InfoSet(MV_PP2_CLS_C4_ENTRY *C4, int info)
+{
+	PTR_VALIDATE(C4);
+	POS_RANGE_VALIDATE(info, MV_PP2_CLS4_L3INFO_MAX);
+
+	C4->rules.regs.fdataArr[6] &= ~MV_PP2_CLS4_L3INFO_MASK;
+	C4->rules.regs.fdataArr[6] |= (info << MV_PP2_CLS4_FDATA7_L3INFO);
+
+	return MV_OK;
+}
+
+
+/*-------------------------------------------------------------------------------*/
+/*			Classifier C4 engine Public action table APIs 		 */
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC4ColorSet(MV_PP2_CLS_C4_ENTRY *C4, int cmd)
+{
+	PTR_VALIDATE(C4);
+	POS_RANGE_VALIDATE(cmd, COLOR_RED_AND_LOCK);
+
+	C4->sram.regs.actions &= ~ACT_COLOR_MASK;
+	C4->sram.regs.actions |= (cmd << ACT_COLOR);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC4PrioSet(MV_PP2_CLS_C4_ENTRY *C4, int cmd, int prio)
+{
+	PTR_VALIDATE(C4);
+	POS_RANGE_VALIDATE(cmd, UPDATE_AND_LOCK);
+	POS_RANGE_VALIDATE(prio, ACT_QOS_ATTR_PRI_MAX);
+
+	/*set command*/
+	C4->sram.regs.actions &= ~ACT_PRI_MASK;
+	C4->sram.regs.actions |= (cmd << ACT_PRI);
+
+	/*set modify priority value*/
+	C4->sram.regs.qos_attr &= ~ACT_QOS_ATTR_MDF_PRI_MASK;
+	C4->sram.regs.qos_attr |= (prio << ACT_QOS_ATTR_MDF_PRI);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC4DscpSet(MV_PP2_CLS_C4_ENTRY *C4, int cmd, int dscp)
+{
+	PTR_VALIDATE(C4);
+	POS_RANGE_VALIDATE(cmd, UPDATE_AND_LOCK);
+	POS_RANGE_VALIDATE(dscp, ACT_QOS_ATTR_DSCP_MAX);
+
+	/*set command*/
+	C4->sram.regs.actions &= ~ACT_DSCP_MASK;
+	C4->sram.regs.actions |= (cmd << ACT_DSCP);
+
+	/*set modify DSCP value*/
+	C4->sram.regs.qos_attr &= ~ACT_QOS_ATTR_MDF_DSCP_MASK;
+	C4->sram.regs.qos_attr |= (dscp << ACT_QOS_ATTR_MDF_DSCP);
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC4GpidSet(MV_PP2_CLS_C4_ENTRY *C4, int cmd, int gid)
+{
+	PTR_VALIDATE(C4);
+	POS_RANGE_VALIDATE(cmd, UPDATE_AND_LOCK);
+	POS_RANGE_VALIDATE(gid, ACT_QOS_ATTR_GEM_ID_MAX);
+
+	/*set command*/
+	C4->sram.regs.actions &= ~ACT_GEM_ID_MASK;
+	C4->sram.regs.actions |= (cmd << ACT_GEM_ID);
+
+	/*set modify DSCP value*/
+	C4->sram.regs.qos_attr &= ~ACT_QOS_ATTR_MDF_GEM_ID_MASK;
+	C4->sram.regs.qos_attr |= (gid << ACT_QOS_ATTR_MDF_GEM_ID);
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC4PolicerSet(MV_PP2_CLS_C4_ENTRY *C4, int cmd, int policerId)
+{
+	PTR_VALIDATE(C4);
+	POS_RANGE_VALIDATE(cmd, UPDATE_AND_LOCK);
+	POS_RANGE_VALIDATE(policerId, ACT_DUP_POLICER_MAX);
+
+	C4->sram.regs.actions &= ~ACT_POLICER_SELECT_MASK;
+	C4->sram.regs.actions |= (cmd << ACT_POLICER_SELECT);
+
+	C4->sram.regs.dup_attr &= ~ACT_DUP_POLICER_MASK;
+	C4->sram.regs.dup_attr |= (policerId << ACT_DUP_POLICER_ID);
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC4QueueHighSet(MV_PP2_CLS_C4_ENTRY *C4, int cmd, int queue)
+{
+	PTR_VALIDATE(C4);
+
+
+	POS_RANGE_VALIDATE(cmd, UPDATE_AND_LOCK);
+	POS_RANGE_VALIDATE(queue, ACT_QOS_ATTR_MDF_HIGH_Q_MAX);
+
+	/*set command*/
+	C4->sram.regs.actions &= ~ACT_HIGH_Q_MASK;
+	C4->sram.regs.actions |= (cmd << ACT_HIGH_Q);
+
+	/*set modify High queue value*/
+	C4->sram.regs.qos_attr &= ~ACT_QOS_ATTR_MDF_HIGH_Q_MASK;
+	C4->sram.regs.qos_attr |= (queue << ACT_QOS_ATTR_MDF_HIGH_Q);
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsC4QueueLowSet(MV_PP2_CLS_C4_ENTRY *C4, int cmd, int queue)
+{
+	PTR_VALIDATE(C4);
+
+	POS_RANGE_VALIDATE(cmd, UPDATE_AND_LOCK);
+	POS_RANGE_VALIDATE(queue, ACT_QOS_ATTR_MDF_LOW_Q_MAX);
+
+	/*set command*/
+	C4->sram.regs.actions &= ~ACT_LOW_Q_MASK;
+	C4->sram.regs.actions |= (cmd << ACT_LOW_Q);
+
+	/*set modify High queue value*/
+	C4->sram.regs.qos_attr &= ~ACT_QOS_ATTR_MDF_LOW_Q_MASK;
+	C4->sram.regs.qos_attr |= (queue << ACT_QOS_ATTR_MDF_LOW_Q);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC4QueueSet(MV_PP2_CLS_C4_ENTRY *C4, int cmd, int queue)
+{
+	int status = MV_OK;
+	int qHigh, qLow;
+
+	PTR_VALIDATE(C4);
+	POS_RANGE_VALIDATE(queue, ACT_QOS_ATTR_Q_MAX);
+
+	/* cmd validation in set functions */
+
+	qHigh = (queue & ACT_QOS_ATTR_MDF_HIGH_Q_MASK) >> ACT_QOS_ATTR_MDF_HIGH_Q;
+	qLow = (queue & ACT_QOS_ATTR_MDF_LOW_Q_MASK) >> ACT_QOS_ATTR_MDF_LOW_Q;
+
+	status |= mvPp2ClsC4QueueLowSet(C4, cmd, qLow);
+	status |= mvPp2ClsC4QueueHighSet(C4, cmd, qHigh);
+
+	return status;
+
+}
+
+
+
+
+
diff --git a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls4Hw.h b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls4Hw.h
new file mode 100644
index 0000000..ede89a4
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2Cls4Hw.h
@@ -0,0 +1,251 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_CLS4_HW_H__
+#define __MV_CLS4_HW_H__
+
+#include "mvPp2ClsActHw.h"
+#include "../common/mvPp2ErrCode.h"
+#include "../common/mvPp2Common.h"
+#include "../gbe/mvPp2GbeRegs.h"
+
+
+/*-------------------------------------------------------------------------------*/
+/*			Classifier C4 Top Registers	    			 */
+/*-------------------------------------------------------------------------------*/
+#define MV_PP2_CLS4_PHY_TO_RL_REG(port)				(MV_PP2_REG_BASE + 0x1E00 + ((port)*4))
+
+#define MV_PP2_CLS4_PHY_TO_RL_GRP				0
+#define MV_PP2_CLS4_PHY_TO_RL_GRP_BITS				3
+#define MV_PP2_CLS4_PHY_TO_RL_GRP_MASK				(((1 << MV_PP2_CLS4_PHY_TO_RL_GRP_BITS) - 1) << MV_PP2_CLS4_PHY_TO_RL_GRP)
+
+#define MV_PP2_CLS4_PHY_TO_RL_RULE_NUM				4
+#define MV_PP2_CLS4_PHY_TO_RL_RULE_NUM_BITS			4
+#define MV_PP2_CLS4_PHY_TO_RL_RULE_NUM_MASK			(((1 << MV_PP2_CLS4_PHY_TO_RL_RULE_NUM_BITS) - 1) << MV_PP2_CLS4_PHY_TO_RL_RULE_NUM)
+
+/*-------------------------------------------------------------------------------*/
+#define MV_PP2_CLS4_UNI_TO_RL_REG(uni)				(MV_PP2_REG_BASE + 0x1E20 + ((uni)*4))
+
+#define MV_PP2_CLS4_UNI_TO_RL_GRP				0
+#define MV_PP2_CLS4_UNI_TO_RL_RULE_NUM				4
+/*-------------------------------------------------------------------------------*/
+#define MV_PP2_CLS4_RL_INDEX_REG				(MV_PP2_REG_BASE + 0x1E40)
+#define MV_PP2_CLS4_RL_INDEX_RULE				0
+#define MV_PP2_CLS4_RL_INDEX_GRP				3
+/*-------------------------------------------------------------------------------*/
+#define MV_PP2_CLS4_FATTR1_REG					(MV_PP2_REG_BASE + 0x1E50)
+#define MV_PP2_CLS4_FATTR2_REG					(MV_PP2_REG_BASE + 0x1E54)
+#define MV_PP2_CLS4_FATTR_REG_NUM				2
+
+#define MV_PP2_CLS4_FATTR_ID(field)				(((field) * 9) % 27)
+#define MV_PP2_CLS4_FATTR_ID_BITS				6
+#define MV_PP2_CLS4_FATTR_ID_MAX				((1 << MV_PP2_CLS4_FATTR_ID_BITS) - 1)
+#define MV_PP2_CLS4_FATTR_ID_MASK(field)			(MV_PP2_CLS4_FATTR_ID_MAX << MV_PP2_CLS4_FATTR_ID(field))
+#define MV_PP2_CLS4_FATTR_ID_VAL(field, reg_val)		((reg_val & MV_PP2_CLS4_FATTR_ID_MASK(field)) >> MV_PP2_CLS4_FATTR_ID(field))
+
+#define MV_PP2_CLS4_FATTR_OPCODE_BITS				3
+#define MV_PP2_CLS4_FATTR_OPCODE(field)				((((field) * 9) % 27) + MV_PP2_CLS4_FATTR_ID_BITS)
+#define MV_PP2_CLS4_FATTR_OPCODE_MAX				((1 << MV_PP2_CLS4_FATTR_OPCODE_BITS) - 1)
+#define MV_PP2_CLS4_FATTR_OPCODE_MASK(field)			(MV_PP2_CLS4_FATTR_OPCODE_MAX << MV_PP2_CLS4_FATTR_OPCODE(field))
+#define MV_PP2_CLS4_FATTR_OPCODE_VAL(field, reg_val)		((reg_val & MV_PP2_CLS4_FATTR_OPCODE_MASK(field)) >> MV_PP2_CLS4_FATTR_OPCODE(field))
+/*-------------------------------------------------------------------------------*/
+#define MV_PP2_CLS4_FDATA1_REG					(MV_PP2_REG_BASE + 0x1E58)
+#define MV_PP2_CLS4_FDATA2_REG					(MV_PP2_REG_BASE + 0x1E5C)
+#define MV_PP2_CLS4_FDATA3_REG					(MV_PP2_REG_BASE + 0x1E60)
+#define MV_PP2_CLS4_FDATA4_REG					(MV_PP2_REG_BASE + 0x1E64)
+#define MV_PP2_CLS4_FDATA5_REG					(MV_PP2_REG_BASE + 0x1E68)
+#define MV_PP2_CLS4_FDATA6_REG					(MV_PP2_REG_BASE + 0x1E6C)
+#define MV_PP2_CLS4_FDATA7_REG					(MV_PP2_REG_BASE + 0x1E70)
+#define MV_PP2_CLS4_FDATA8_REG					(MV_PP2_REG_BASE + 0x1E74)
+#define MV_PP2_CLS4_FDATA_REG(reg_num)				(MV_PP2_REG_BASE + 0x1E58 + (4*(reg_num)))
+#define MV_PP2_CLS4_FDATA_REGS_NUM				8
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS4_FDATA7_L3INFO				16
+#define MV_PP2_CLS4_FDATA7_L3INFO_BITS				4
+#define MV_PP2_CLS4_L3INFO_MAX					((1 << MV_PP2_CLS4_FDATA7_L3INFO_BITS) - 1)
+#define MV_PP2_CLS4_L3INFO_MASK					(MV_PP2_CLS4_L3INFO_MAX << MV_PP2_CLS4_FDATA7_L3INFO)
+#define MV_PP2_CLS4_L3INFO_VAL(reg_val)				(((reg_val) & MV_PP2_CLS4_L3INFO_MASK) >> MV_PP2_CLS4_FDATA7_L3INFO)
+
+#define MV_PP2_CLS4_FDATA7_L4INFO				20
+#define MV_PP2_CLS4_FDATA7_L4INFO_BITS				4
+#define MV_PP2_CLS4_L4INFO_MAX					((1 << MV_PP2_CLS4_FDATA7_L4INFO_BITS) - 1)
+#define MV_PP2_CLS4_L4INFO_MASK					(MV_PP2_CLS4_L4INFO_MAX << MV_PP2_CLS4_FDATA7_L4INFO)
+#define MV_PP2_CLS4_L4INFO_VAL(reg_val)				(((reg_val) & MV_PP2_CLS4_L4INFO_MASK) >> MV_PP2_CLS4_FDATA7_L4INFO)
+
+
+#define MV_PP2_CLS4_FDATA7_MACME				24
+#define MV_PP2_CLS4_FDATA7_MACME_BITS				2
+#define MV_PP2_CLS4_MACME_MAX					((1 << MV_PP2_CLS4_FDATA7_MACME_BITS) - 1)
+#define MV_PP2_CLS4_MACME_MASK					(MV_PP2_CLS4_MACME_MAX << MV_PP2_CLS4_FDATA7_MACME)
+#define MV_PP2_CLS4_MACME_VAL(reg_val)				(((reg_val) & MV_PP2_CLS4_MACME_MASK) >> MV_PP2_CLS4_FDATA7_MACME)
+
+#define MV_PP2_CLS4_FDATA7_PPPOE				26
+#define MV_PP2_CLS4_FDATA7_PPPOE_BITS				2
+#define MV_PP2_CLS4_PPPOE_MAX					((1 << MV_PP2_CLS4_FDATA7_PPPOE_BITS) - 1)
+#define MV_PP2_CLS4_PPPOE_MASK					(MV_PP2_CLS4_PPPOE_MAX << MV_PP2_CLS4_FDATA7_PPPOE)
+#define MV_PP2_CLS4_PPPOE_VAL(reg_val)				(((reg_val) & MV_PP2_CLS4_PPPOE_MASK) >> MV_PP2_CLS4_FDATA7_PPPOE)
+
+#define MV_PP2_CLS4_FDATA7_VLAN					28
+#define MV_PP2_CLS4_FDATA7_VLAN_BITS				3
+#define MV_PP2_CLS4_VLAN_MAX					((1 << MV_PP2_CLS4_FDATA7_VLAN_BITS) - 1)
+#define MV_PP2_CLS4_VLAN_MASK					(MV_PP2_CLS4_VLAN_MAX << MV_PP2_CLS4_FDATA7_VLAN)
+#define MV_PP2_CLS4_VLAN_VAL(reg_val)				(((reg_val) & MV_PP2_CLS4_VLAN_MASK) >> MV_PP2_CLS4_FDATA7_VLAN)
+
+/*-------------------------------------------------------------------------------*/
+#define MV_PP2_CLS4_ACT_REG					(MV_PP2_REG_BASE + 0x1E80)
+/*-------------------------------------------------------------------------------*/
+#define MV_PP2_CLS4_ACT_QOS_ATTR_REG				(MV_PP2_REG_BASE + 0x1E84)
+/*-------------------------------------------------------------------------------*/
+#define MV_PP2_CLS4_ACT_DUP_ATTR_REG				(MV_PP2_REG_BASE + 0x1E88)
+/*-------------------------------------------------------------------------------*/
+
+
+/*-------------------------------------------------------------------------------*/
+/*			Classifier C4 engine Public APIs			 */
+/*-------------------------------------------------------------------------------*/
+#define MV_PP2_CLS_C4_GRP_SIZE					(8)
+#define MV_PP2_CLS_C4_GRPS_NUM					(8)
+#define MV_PP2_CLS_C4_TBL_WORDS					(10)
+#define MV_PP2_CLS_C4_TBL_DATA_WORDS				(8)
+#define MV_PP2_CLS_C4_SRAM_WORDS				(3)
+
+/* Field 0- 3 */
+#define FLD_FMT							"%4.4x"
+#define FLD_VAL(field, p)					((p[field/2] >> (16 * (field % 2))) & 0xFFFF)
+
+/* field 4 */
+#define FLD4_FMT						"%8.8x %8.8x %8.8x %8.8x"
+#define FLD4_VAL(p)						p[2], p[3], p[4], p[5]
+/* field 5 */
+#define FLD5_FMT						"%4.4x %8.8x"
+#define FLD5_VAL(p)						p[6] & 0xFFFF, p[7]
+
+#define MV_PP2_CLS_C4_FIELDS_NUM				6
+#define GET_FIELD_ATRR(field)					((field) / 3)
+
+typedef struct mvPp2ClsC4RuleEntry {
+	unsigned int ruleIndex;
+	unsigned int setIndex;
+	union {
+		MV_U32	words[MV_PP2_CLS_C4_TBL_WORDS];
+		MV_U8	bytes[MV_PP2_CLS_C4_TBL_WORDS * 4];
+		struct {
+			MV_U32 attr[MV_PP2_CLS4_FATTR_REG_NUM];
+			MV_U32 fdataArr[MV_PP2_CLS_C4_TBL_DATA_WORDS];
+		} regs;
+	} rules;
+	union {
+		MV_U32 words[MV_PP2_CLS_C4_SRAM_WORDS];
+		struct {
+			MV_U32 actions;/* 0x1E80 */
+			MV_U32 qos_attr;/* 0x1E84*/
+			MV_U32 dup_attr;/* 0x1E88 */
+		} regs;
+	} sram;
+} MV_PP2_CLS_C4_ENTRY;
+
+
+int mvPp2ClsC4HwPortToRulesSet(int port, int set, int rules);
+int mvPp2ClsC4HwUniToRulesSet(int uniPort, int set, int rules);
+int mvPp2ClsC4HwPortToRulesGet(int port, int *set, int *rules);
+int mvPp2ClsC4HwUniToRulesGet(int uni, int *set, int *rules);
+int mvPp2ClsC4HwRead(MV_PP2_CLS_C4_ENTRY *C4, int rule, int set);
+int mvPp2ClsC4HwWrite(MV_PP2_CLS_C4_ENTRY *C4, int rule, int set);
+int mvPp2ClsC4SwDump(MV_PP2_CLS_C4_ENTRY *C4);
+void mvPp2ClsC4SwClear(MV_PP2_CLS_C4_ENTRY *C4);
+void mvPp2ClsC4HwClearAll(void);
+int mvPp2ClsC4RegsDump(void);
+int mvPp2ClsC4HwDumpAll(void);
+
+
+/*-------------------------------------------------------------------------------*/
+/*			Classifier C4 engine rules APIs	 			 */
+/*-------------------------------------------------------------------------------*/
+
+
+int mvPp2ClsC4FieldsShortSet(MV_PP2_CLS_C4_ENTRY *C4, int field, unsigned int offs, unsigned short data);
+int mvPp2ClsC4FieldsParamsSet(MV_PP2_CLS_C4_ENTRY *C4, int field, unsigned int id, unsigned int op);
+int mvPp2ClsC4SwVlanSet(MV_PP2_CLS_C4_ENTRY *C4, int vlan);
+int mvPp2ClsC4SwPppoeSet(MV_PP2_CLS_C4_ENTRY *C4, int pppoe);
+int mvPp2ClsC4SwMacMeSet(MV_PP2_CLS_C4_ENTRY *C4, int mac);
+int mvPp2ClsC4SwL4InfoSet(MV_PP2_CLS_C4_ENTRY *C4, int info);
+int mvPp2ClsC4SwL3InfoSet(MV_PP2_CLS_C4_ENTRY *C4, int info);
+
+
+/*-------------------------------------------------------------------------------*/
+/*			Classifier C4 engine action table APIs 			 */
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsC4ColorSet(MV_PP2_CLS_C4_ENTRY *C4, int cmd);
+int mvPp2ClsC4PrioSet(MV_PP2_CLS_C4_ENTRY *C4, int cmd, int prio);
+int mvPp2ClsC4DscpSet(MV_PP2_CLS_C4_ENTRY *C4, int cmd, int dscp);
+int mvPp2ClsC4GpidSet(MV_PP2_CLS_C4_ENTRY *C4, int cmd, int gpid);
+int mvPp2ClsC4ForwardSet(MV_PP2_CLS_C4_ENTRY *c4, int cmd);
+int mvPp2ClsC4PolicerSet(MV_PP2_CLS_C4_ENTRY *C4, int cmd, int policerId);
+int mvPp2ClsC4QueueHighSet(MV_PP2_CLS_C4_ENTRY *C4, int cmd, int queue);
+int mvPp2ClsC4QueueLowSet(MV_PP2_CLS_C4_ENTRY *C4, int cmd, int queue);
+int mvPp2ClsC4QueueSet(MV_PP2_CLS_C4_ENTRY *C4, int cmd, int queue);
+
+#endif /* MV_CLS4_HW */
diff --git a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsActHw.h b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsActHw.h
new file mode 100644
index 0000000..94a8658
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsActHw.h
@@ -0,0 +1,233 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_CLS_ACT_HW_H__
+#define __MV_CLS_ACT_HW_H__
+
+
+/*-------------------------------------------------------------------------------*/
+/*		Classifier engines Actions Table offsets	    		 */
+/*-------------------------------------------------------------------------------*/
+
+/*action_tbl*/
+#define ACT_TBL_ID						0
+#define ACT_TBL_ID_BITS						6
+#define ACT_TBL_ID_MASK						((1 << ACT_TBL_ID_BITS) - 1)
+
+#define ACT_TBL_SEL						6
+#define ACT_TBL_SEL_MASK					(1 << ACT_TBL_SEL)
+
+#define ACT_TBL_PRI_DSCP					7
+#define ACT_TBL_PRI_DSCP_MASK					(1 << ACT_TBL_PRI_DSCP)
+
+#define ACT_TBL_GEM_ID						8
+#define ACT_TBL_GEM_ID_MASK					(1 << ACT_TBL_GEM_ID)
+
+#define ACT_TBL_LOW_Q						9
+#define ACT_TBL_LOW_Q_MASK					(1 << ACT_TBL_LOW_Q)
+
+#define ACT_TBL_HIGH_Q						10
+#define ACT_TBL_HIGH_Q_MASK					(1 << ACT_TBL_HIGH_Q)
+
+#define ACT_TBL_COLOR						11
+#define ACT_TBL_COLOR_MASK					(1 << ACT_TBL_COLOR)
+
+/*actions*/
+#define ACT_COLOR						0
+#define ACT_COLOR_BITS						3
+#define ACT_COLOR_MASK						(((1 << ACT_COLOR_BITS) - 1) << ACT_COLOR)
+
+#define ACT_PRI							3
+#define ACT_PRI_BITS						2
+#define ACT_PRI_MASK						(((1 << ACT_PRI_BITS) - 1) << ACT_PRI)
+#define ACT_PRI_MAX						((1 << ACT_PRI_BITS) - 1)
+
+
+#define ACT_DSCP						5
+#define ACT_DSCP_BITS						2
+#define ACT_DSCP_MASK						(((1 << ACT_DSCP_BITS) - 1) << ACT_DSCP)
+
+#define ACT_GEM_ID						7
+#define ACT_GEM_ID_BITS						2
+#define ACT_GEM_ID_MASK						(((1 << ACT_GEM_ID_BITS) - 1) << ACT_GEM_ID)
+
+#define ACT_LOW_Q						9
+#define ACT_LOW_Q_BITS						2
+#define ACT_LOW_Q_MASK						(((1 << ACT_LOW_Q_BITS) - 1) << ACT_LOW_Q)
+
+
+#define ACT_HIGH_Q						11
+#define ACT_HIGH_Q_BITS						2
+#define ACT_HIGH_Q_MASK						(((1 << ACT_HIGH_Q_BITS) - 1) << ACT_HIGH_Q)
+
+#define ACT_FWD							13
+#define ACT_FWD_BITS						3
+#define ACT_FWD_MASK						(((1 << ACT_FWD_BITS) - 1) << ACT_FWD)
+
+#define ACT_POLICER_SELECT					16
+#define ACT_POLICER_SELECT_BITS					2
+#define ACT_POLICER_SELECT_MASK					(((1 << ACT_POLICER_SELECT_BITS) - 1) << ACT_POLICER_SELECT)
+
+#define ACT_FLOW_ID_EN						18
+#define ACT_FLOW_ID_EN_MASK					(1 << ACT_FLOW_ID_EN)
+
+/*qos_attr*/
+#define ACT_QOS_ATTR_MDF_PRI					0
+#define ACT_QOS_ATTR_PRI_BITS					3
+#define ACT_QOS_ATTR_MDF_PRI_MASK				(((1 << ACT_QOS_ATTR_PRI_BITS) - 1) << ACT_QOS_ATTR_MDF_PRI)
+#define ACT_QOS_ATTR_PRI_MAX					((1 << ACT_QOS_ATTR_PRI_BITS) - 1)
+
+#define ACT_QOS_ATTR_MDF_DSCP					3
+#define ACT_QOS_ATTR_DSCP_BITS					6
+#define ACT_QOS_ATTR_MDF_DSCP_MASK				(((1 << ACT_QOS_ATTR_DSCP_BITS) - 1) << ACT_QOS_ATTR_MDF_DSCP)
+#define ACT_QOS_ATTR_DSCP_MAX					((1 << ACT_QOS_ATTR_DSCP_BITS) - 1)
+
+#define ACT_QOS_ATTR_MDF_GEM_ID					9
+#define ACT_QOS_ATTR_GEM_ID_BITS				12
+#define ACT_QOS_ATTR_MDF_GEM_ID_MASK				(((1 << ACT_QOS_ATTR_GEM_ID_BITS) - 1) << ACT_QOS_ATTR_MDF_GEM_ID)
+#define ACT_QOS_ATTR_GEM_ID_MAX					((1 << ACT_QOS_ATTR_GEM_ID_BITS) - 1)
+
+
+#define ACT_QOS_ATTR_MDF_LOW_Q					21
+#define ACT_QOS_ATTR_MDF_LOW_Q_BITS				3
+#define ACT_QOS_ATTR_MDF_LOW_Q_MAX				((1 << ACT_QOS_ATTR_MDF_LOW_Q_BITS) - 1)
+#define ACT_QOS_ATTR_MDF_LOW_Q_MASK				(ACT_QOS_ATTR_MDF_LOW_Q_MAX << ACT_QOS_ATTR_MDF_LOW_Q)
+
+#define ACT_QOS_ATTR_MDF_HIGH_Q					24
+#define ACT_QOS_ATTR_MDF_HIGH_Q_BITS				5
+#define ACT_QOS_ATTR_MDF_HIGH_Q_MAX				((1 << ACT_QOS_ATTR_MDF_HIGH_Q_BITS) - 1)
+#define ACT_QOS_ATTR_MDF_HIGH_Q_MASK				(ACT_QOS_ATTR_MDF_HIGH_Q_MAX << ACT_QOS_ATTR_MDF_HIGH_Q)
+
+#define ACT_QOS_ATTR_Q_MAX					((1 << (ACT_QOS_ATTR_MDF_HIGH_Q_BITS + ACT_QOS_ATTR_MDF_LOW_Q_BITS)) - 1)
+/*hwf_attr*/
+
+#define	ACT_HWF_ATTR_DPTR					1
+#define	ACT_HWF_ATTR_DPTR_BITS					14
+#define	ACT_HWF_ATTR_DPTR_MASK					(((1 << ACT_HWF_ATTR_DPTR_BITS) - 1) << ACT_HWF_ATTR_DPTR)
+#define	ACT_HWF_ATTR_DPTR_MAX					((1 << ACT_HWF_ATTR_DPTR_BITS) - 1)
+
+#define	ACT_HWF_ATTR_IPTR					16
+#define	ACT_HWF_ATTR_IPTR_BITS					8
+#define	ACT_HWF_ATTR_IPTR_MASK					(((1 << ACT_HWF_ATTR_IPTR_BITS) - 1) << ACT_HWF_ATTR_IPTR)
+#define	ACT_HWF_ATTR_IPTR_MAX					((1 << ACT_HWF_ATTR_IPTR_BITS) - 1)
+
+#define	ACT_HWF_ATTR_CHKSM_EN					24
+#define	ACT_HWF_ATTR_CHKSM_EN_MASK				(1 << ACT_HWF_ATTR_CHKSM_EN)
+
+/*MV_U32 dup_attr*/
+#define ACT_DUP_FID						0
+#define ACT_DUP_FID_BITS					8
+#define ACT_DUP_FID_MASK					(((1 << ACT_DUP_FID_BITS) - 1) << ACT_DUP_FID)
+#define ACT_DUP_FID_MAX						((1 << ACT_DUP_FID_BITS) - 1)
+
+
+#define ACT_DUP_COUNT						8
+#define ACT_DUP_COUNT_BITS					4
+#define ACT_DUP_COUNT_MASK					(((1 << ACT_DUP_COUNT_BITS) - 1) << ACT_DUP_COUNT)
+#define ACT_DUP_COUNT_MAX					14
+
+#define ACT_DUP_POLICER_ID					28
+#define ACT_DUP_POLICER_ID_BITS					4
+#define ACT_DUP_POLICER_MASK					(((1 << ACT_DUP_POLICER_ID_BITS) - 1) << ACT_DUP_POLICER_ID)
+#define ACT_DUP_POLICER_MAX					((1 << ACT_DUP_POLICER_ID_BITS) - 1)
+
+
+/*-------------------------------------------------------------------------------*/
+/*		Classifier engines Actions Table offsets	    		 */
+/*-------------------------------------------------------------------------------*/
+
+typedef enum {
+	COLOR_NO_UPDATE = 0,
+	COLOR_NO_UPDATE_AND_LOCK = 1,
+	COLOR_GREEN = 2,
+	COLOR_YELLOW = 4,
+	COLOR_RED = 6,
+	COLOR_RED_AND_LOCK = 7
+} MV_PP2_CLS_COLOR_CMD;
+
+typedef enum MV_PP2_CLS_HWF_CMD {
+	HWF_NO_UPDATE = 0,
+	HWF_NO_UPDATE_AND_LOCK,
+	SWF,
+	SWF_AND_LOCK,
+	HWF,
+	HWF_AND_LOCK,
+	HWF_AND_LOW_LATENCY,
+	HWF_AND_LOW_LATENCY_AND_LOCK
+} MV_PP2_CLS_HWF_CMD;
+
+typedef enum {
+	NO_UPDATE = 0,
+	NO_UPDATE_AND_LOCK,
+	UPDATE,
+	UPDATE_AND_LOCK
+} MV_PP2_CLS_CMD;
+
+typedef enum {
+	GREEN = 0,
+	YELLOW,
+	RED
+} MV_PP2_CLS_COLOR;
+
+#endif /*__MV_CLS_ACT_HW_H__*/
diff --git a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsHw.c b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsHw.c
new file mode 100644
index 0000000..0f2e7a0
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsHw.c
@@ -0,0 +1,909 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#include "mvPp2ClsHw.h"
+
+/* TODO: chage to char arrays */
+int mvClsLkpShadowTbl[2 * MV_PP2_CLS_LKP_TBL_SIZE];
+int mvClsFlowShadowTbl[MV_PP2_CLS_FLOWS_TBL_SIZE];
+
+
+/******************************************************************************/
+/**************** Classifier Top Public initialization APIs *******************/
+/******************************************************************************/
+int mvPp2ClsInit()
+{
+	int rc;
+	/*TODO - SET MTU */
+	/* Enabled Classifier */
+	rc = mvPp2ClsHwEnable(1);
+	if (rc)
+		return rc;
+	/* clear cls flow table and shadow */
+	mvPp2ClsHwFlowClearAll();
+
+	/* clear cls lookup table and shadow */
+	mvPp2ClsHwLkpClearAll();
+
+	return MV_OK;
+}
+void mvPp2ClsShadowInit()
+{
+	memset(mvClsLkpShadowTbl, NOT_IN_USE, 2 * MV_PP2_CLS_LKP_TBL_SIZE * sizeof(int));
+	memset(mvClsFlowShadowTbl, NOT_IN_USE, MV_PP2_CLS_FLOWS_TBL_SIZE * sizeof(int));
+}
+void mvPp2ClsHwLastBitWorkAround()
+{
+	/* workaround to hw bug - set last bit in flow entry */
+	mvPp2WrReg(MV_PP2_CLS_FLOW_INDEX_REG, 0);
+	mvPp2WrReg(MV_PP2_CLS_FLOW_TBL0_REG, 1);
+}
+
+int mvPp2ClsHwPortDefConfig(int port, int way, int lkpid, int rxq)
+{
+	MV_PP2_CLS_LKP_ENTRY  le;
+
+	mvPp2ClsHwPortWaySet(port, way);
+	/*
+	the entry to be accessed in lookupid decoding table
+	is acording to way and lkpid
+	*/
+	le.way = way;
+	le.lkpid = lkpid;
+	le.data = 0;
+
+	mvPp2ClsSwLkpRxqSet(&le, rxq);
+
+	/* do not use classification engines */
+	mvPp2ClsSwLkpEnSet(&le, 0);
+
+	/* write entry */
+	mvPp2ClsHwLkpWrite(lkpid, way, &le);
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsHwEnable(int enable)
+{
+	mvPp2WrReg(MV_PP2_CLS_MODE_REG, (unsigned int)(enable << MV_PP2_CLS_MODE_ACTIVE_BIT));
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsHwPortWaySet(int port, int way)
+{
+	POS_RANGE_VALIDATE(port, MV_PP2_MAX_PORTS-1);
+	POS_RANGE_VALIDATE(way, ONE_BIT_MAX);
+
+	if (way == 1)
+		MV_REG_BIT_SET(MV_PP2_CLS_PORT_WAY_REG, MV_PP2_CLS_PORT_WAY_MASK(port));
+	else
+		MV_REG_BIT_RESET(MV_PP2_CLS_PORT_WAY_REG, MV_PP2_CLS_PORT_WAY_MASK(port));
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsHwPortSpidSet(int port, int spid)
+{
+	unsigned int regVal;
+
+	POS_RANGE_VALIDATE(port, ETH_PORTS_NUM-1);
+	POS_RANGE_VALIDATE(spid, MV_PP2_CLS_PORT_SPID_MAX);
+
+	regVal = mvPp2RdReg(MV_PP2_CLS_PORT_SPID_REG);
+	regVal &= ~MV_PP2_CLS_PORT_SPID_MASK(port);
+	regVal |=  MV_PP2_CLS_PORT_SPID_VAL(port, spid);
+	mvPp2WrReg(MV_PP2_CLS_PORT_SPID_REG, regVal);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsHwUniPortSet(int uni_port, int spid)
+{
+	unsigned int regVal;
+
+	POS_RANGE_VALIDATE(uni_port, UNI_MAX);
+	POS_RANGE_VALIDATE(spid, MV_PP2_CLS_SPID_MAX);
+
+	regVal = mvPp2RdReg(MV_PP2_CLS_SPID_UNI_REG(spid));
+	regVal &= ~MV_PP2_CLS_SPID_UNI_MASK(spid);
+	regVal |=  MV_PP2_CLS_SPID_UNI_VAL(spid, uni_port);
+	mvPp2WrReg(MV_PP2_CLS_SPID_UNI_REG(spid), regVal);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsHwVirtPortSet(int virt_port, int gem_portid)
+{
+	unsigned int regVal;
+
+	POS_RANGE_VALIDATE(virt_port, MV_PP2_CLS_GEM_VIRT_REGS_NUM - 1);
+	POS_RANGE_VALIDATE(gem_portid, MV_PP2_CLS_GEM_VIRT_MAX);
+
+	regVal = mvPp2RdReg(MV_PP2_CLS_GEM_VIRT_REG(virt_port));
+	regVal &= ~MV_PP2_CLS_GEM_VIRT_MASK;
+	regVal |= gem_portid;
+	mvPp2WrReg(MV_PP2_CLS_GEM_VIRT_REG(virt_port), regVal);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsHwUdfSet(int udf_no, int offs_id, int offs_bits, int size_bits)
+{
+	unsigned int regVal;
+
+	POS_RANGE_VALIDATE(offs_id, MV_PP2_CLS_UDF_OFFSET_ID_MAX);
+	POS_RANGE_VALIDATE(offs_bits, MV_PP2_CLS_UDF_REL_OFFSET_MAX);
+	POS_RANGE_VALIDATE(size_bits, MV_PP2_CLS_UDF_SIZE_MASK);
+	POS_RANGE_VALIDATE(udf_no, MV_PP2_CLS_UDF_REGS_NUM - 1);
+
+	regVal = mvPp2RdReg(MV_PP2_CLS_UDF_REG(udf_no));
+	regVal &= ~MV_PP2_CLS_UDF_OFFSET_ID_MASK;
+	regVal &= ~MV_PP2_CLS_UDF_REL_OFFSET_MASK;
+	regVal &= ~MV_PP2_CLS_UDF_SIZE_MASK;
+
+	regVal |= (offs_id << MV_PP2_CLS_UDF_OFFSET_ID_OFFS);
+	regVal |= (offs_bits << MV_PP2_CLS_UDF_REL_OFFSET_OFFS);
+	regVal |= (size_bits << MV_PP2_CLS_UDF_SIZE_OFFS);
+
+	mvPp2WrReg(MV_PP2_CLS_UDF_REG(udf_no), regVal);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsHwOversizeRxqSet(int port, int rxq)
+{
+	unsigned int regVal;
+
+	POS_RANGE_VALIDATE(rxq, MV_PP2_CLS_OVERSIZE_RXQ_MAX);
+
+	/* set oversize rxq */
+	regVal = mvPp2RdReg(MV_PP2_CLS_OVERSIZE_RXQ_REG(port));
+	regVal &= ~MV_PP2_CLS_OVERSIZE_RX_MASK;
+	regVal |= (rxq << MV_PP2_CLS_OVERSIZE_RXQ_OFFS);
+	mvPp2WrReg(MV_PP2_CLS_OVERSIZE_RXQ_REG(port), regVal);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsHwMtuSet(int port, int txp, int mtu)
+{
+	int eport;
+	unsigned int regVal;
+
+	POS_RANGE_VALIDATE(mtu, MV_PP2_CLS_MTU_MAX);
+
+	if (port == MV_PON_PORT_ID)  {/*pon*/
+		POS_RANGE_VALIDATE(txp, MV_ETH_MAX_TCONT - 1); /*txq num in pon*/
+		eport = txp; /* regs 0 - 15 for pon txq */
+	} else {
+		POS_RANGE_VALIDATE(port, ETH_PORTS_NUM - 1);
+		eport = 16 + port;/* regs 16 - 23 ethernet port */
+	}
+
+	/* set mtu */
+	regVal = mvPp2RdReg(MV_PP2_CLS_MTU_REG(eport));
+	regVal &= ~MV_PP2_CLS_MTU_MASK;
+	regVal |= (mtu << MV_PP2_CLS_MTU_OFFS);
+	mvPp2WrReg(MV_PP2_CLS_MTU_REG(eport), regVal);
+
+	return MV_OK;
+
+}
+
+/******************************************************************************/
+/***************** Classifier Top Public lkpid table APIs ********************/
+/******************************************************************************/
+
+int mvPp2ClsHwLkpWrite(int lkpid, int way, MV_PP2_CLS_LKP_ENTRY *fe)
+{
+	unsigned int regVal = 0;
+
+	PTR_VALIDATE(fe);
+
+	BIT_RANGE_VALIDATE(way);
+	POS_RANGE_VALIDATE(lkpid, MV_PP2_CLS_LKP_TBL_SIZE);
+
+	/* write index reg */
+	regVal = (way << MV_PP2_CLS_LKP_INDEX_WAY_OFFS) | (lkpid << MV_PP2_CLS_LKP_INDEX_LKP_OFFS);
+	mvPp2WrReg(MV_PP2_CLS_LKP_INDEX_REG, regVal);
+
+	/* write flowId reg */
+	mvPp2WrReg(MV_PP2_CLS_LKP_TBL_REG, fe->data);
+
+	/* update shadow */
+	mvClsLkpShadowTbl[regVal] = IN_USE;
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsHwLkpRead(int lkpid, int way, MV_PP2_CLS_LKP_ENTRY *fe)
+{
+	unsigned int regVal = 0;
+
+	PTR_VALIDATE(fe);
+
+	POS_RANGE_VALIDATE(way, WAY_MAX);
+	POS_RANGE_VALIDATE(lkpid, MV_PP2_CLS_FLOWS_TBL_SIZE);
+
+	/* write index reg */
+	regVal = (way << MV_PP2_CLS_LKP_INDEX_WAY_OFFS) | (lkpid << MV_PP2_CLS_LKP_INDEX_LKP_OFFS);
+	mvPp2WrReg(MV_PP2_CLS_LKP_INDEX_REG, regVal);
+
+	fe->way = way;
+	fe->lkpid = lkpid;
+
+	fe->data = mvPp2RdReg(MV_PP2_CLS_LKP_TBL_REG);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsSwLkpDump(MV_PP2_CLS_LKP_ENTRY *fe)
+{
+	int int32bit;
+	int status = 0;
+
+	PTR_VALIDATE(fe);
+
+	mvOsPrintf("< ID  WAY >:	RXQ  	EN	FLOW	MODE_BASE\n");
+
+	/* id */
+	mvOsPrintf(" 0x%2.2x  %1.1d\t", fe->lkpid, fe->way);
+
+	/*rxq*/
+	status |= mvPp2ClsSwLkpRxqGet(fe, &int32bit);
+	mvOsPrintf("0x%2.2x\t", int32bit);
+
+	/*enabe bit*/
+	status |= mvPp2ClsSwLkpEnGet(fe, &int32bit);
+	mvOsPrintf("%1.1d\t", int32bit);
+
+	/*flow*/
+	status |= mvPp2ClsSwLkpFlowGet(fe, &int32bit);
+	mvOsPrintf("0x%3.3x\t", int32bit);
+
+	/*mode*/
+	status |= mvPp2ClsSwLkpModGet(fe, &int32bit);
+	mvOsPrintf(" 0x%2.2x\t", int32bit);
+
+	mvOsPrintf("\n");
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsSwLkpRxqSet(MV_PP2_CLS_LKP_ENTRY *fe, int rxq)
+{
+	PTR_VALIDATE(fe);
+
+	POS_RANGE_VALIDATE(rxq, MV_PP2_MAX_RXQS_TOTAL-1);
+
+	fe->data &= ~FLOWID_RXQ_MASK;
+	fe->data |= (rxq << FLOWID_RXQ);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsSwLkpEnSet(MV_PP2_CLS_LKP_ENTRY *fe, int en)
+{
+	PTR_VALIDATE(fe);
+
+	BIT_RANGE_VALIDATE(en);
+
+	fe->data &= ~FLOWID_EN_MASK;
+	fe->data |= (en << FLOWID_EN);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsSwLkpFlowSet(MV_PP2_CLS_LKP_ENTRY *fe, int flow_idx)
+{
+	PTR_VALIDATE(fe);
+
+	POS_RANGE_VALIDATE(flow_idx, MV_PP2_CLS_FLOWS_TBL_SIZE);
+
+	fe->data &= ~FLOWID_FLOW_MASK;
+	fe->data |= (flow_idx << FLOWID_FLOW);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsSwLkpModSet(MV_PP2_CLS_LKP_ENTRY *fe, int mod_base)
+{
+	PTR_VALIDATE(fe);
+	/* TODO: what is the max value of mode base */
+	POS_RANGE_VALIDATE(mod_base, FLOWID_MODE_MAX);
+
+	fe->data &= ~FLOWID_MODE_MASK;
+	fe->data |= (mod_base << FLOWID_MODE);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsSwLkpRxqGet(MV_PP2_CLS_LKP_ENTRY *fe, int *rxq)
+{
+
+	PTR_VALIDATE(fe);
+	PTR_VALIDATE(rxq);
+
+	*rxq =  (fe->data & FLOWID_RXQ_MASK) >> FLOWID_RXQ;
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsSwLkpEnGet(MV_PP2_CLS_LKP_ENTRY *fe, int *en)
+{
+	PTR_VALIDATE(fe);
+	PTR_VALIDATE(en);
+
+	*en = (fe->data & FLOWID_EN_MASK) >> FLOWID_EN;
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsSwLkpFlowGet(MV_PP2_CLS_LKP_ENTRY *fe, int *flow_idx)
+{
+	PTR_VALIDATE(fe);
+	PTR_VALIDATE(flow_idx);
+
+	*flow_idx = (fe->data & FLOWID_FLOW_MASK) >> FLOWID_FLOW;
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsSwLkpModGet(MV_PP2_CLS_LKP_ENTRY *fe, int *mod_base)
+{
+	PTR_VALIDATE(fe);
+	PTR_VALIDATE(mod_base);
+
+	*mod_base = (fe->data & FLOWID_MODE_MASK) >> FLOWID_MODE;
+	return MV_OK;
+}
+
+/******************************************************************************/
+/***************** Classifier Top Public flows table APIs  ********************/
+/******************************************************************************/
+
+
+int mvPp2ClsHwFlowWrite(int index, MV_PP2_CLS_FLOW_ENTRY *fe)
+{
+	PTR_VALIDATE(fe);
+
+	POS_RANGE_VALIDATE(index, MV_PP2_CLS_FLOWS_TBL_SIZE);
+
+	fe->index = index;
+
+	/*write index*/
+	mvPp2WrReg(MV_PP2_CLS_FLOW_INDEX_REG, index);
+
+	mvPp2WrReg(MV_PP2_CLS_FLOW_TBL0_REG, fe->data[0]);
+	mvPp2WrReg(MV_PP2_CLS_FLOW_TBL1_REG, fe->data[1]);
+	mvPp2WrReg(MV_PP2_CLS_FLOW_TBL2_REG, fe->data[2]);
+
+	/* update shadow */
+	mvClsFlowShadowTbl[index] = IN_USE;
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+
+int mvPp2ClsHwFlowRead(int index, MV_PP2_CLS_FLOW_ENTRY *fe)
+{
+	PTR_VALIDATE(fe);
+
+	POS_RANGE_VALIDATE(index, MV_PP2_CLS_FLOWS_TBL_SIZE);
+
+	fe->index = index;
+
+	/*write index*/
+	mvPp2WrReg(MV_PP2_CLS_FLOW_INDEX_REG, index);
+
+	fe->data[0] = mvPp2RdReg(MV_PP2_CLS_FLOW_TBL0_REG);
+	fe->data[1] = mvPp2RdReg(MV_PP2_CLS_FLOW_TBL1_REG);
+	fe->data[2] = mvPp2RdReg(MV_PP2_CLS_FLOW_TBL2_REG);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsSwFlowDump(MV_PP2_CLS_FLOW_ENTRY *fe)
+{
+	int	int32bit_1, int32bit_2, i;
+	int	fieldsArr[MV_PP2_CLS_FLOWS_TBL_FIELDS_MAX];
+	int	status = MV_OK;
+
+	PTR_VALIDATE(fe);
+	mvOsPrintf("INDEX: F[0] F[1] F[2] F[3] PRT[T  ID] ENG LAST LKP_TYP  PRIO\n");
+
+	/*index*/
+	mvOsPrintf("0x%3.3x  ", fe->index);
+
+	/*filed[0] filed[1] filed[2] filed[3]*/
+	status |= mvPp2ClsSwFlowHekGet(fe, &int32bit_1, fieldsArr);
+
+	for (i = 0 ; i < MV_PP2_CLS_FLOWS_TBL_FIELDS_MAX; i++)
+		if (i < int32bit_1)
+			mvOsPrintf("0x%2.2x ", fieldsArr[i]);
+		else
+			mvOsPrintf(" NA  ");
+
+	/*port_type port_id*/
+	status |= mvPp2ClsSwFlowPortGet(fe, &int32bit_1, &int32bit_2);
+	mvOsPrintf("[%1d  0x%3.3x]  ", int32bit_1, int32bit_2);
+
+	/* engine_num last_bit*/
+	status |= mvPp2ClsSwFlowEngineGet(fe, &int32bit_1, &int32bit_2);
+	mvOsPrintf("%1d   %1d    ", int32bit_1, int32bit_2);
+
+	/* lookup_type priority*/
+	status |= mvPp2ClsSwFlowExtraGet(fe, &int32bit_1, &int32bit_2);
+	mvOsPrintf("0x%2.2x    0x%2.2x", int32bit_1, int32bit_2);
+
+	mvOsPrintf("\n");
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsSwFlowHekSet(MV_PP2_CLS_FLOW_ENTRY *fe, int field_index, int field_id)
+{
+	int num_of_fields;
+
+	PTR_VALIDATE(fe);
+	POS_RANGE_VALIDATE(field_index, MV_PP2_CLS_FLOWS_TBL_FIELDS_MAX);
+	POS_RANGE_VALIDATE(field_id, FLOW_FIELED_MAX);
+
+	/* get current num_of_fields */
+	num_of_fields = ((fe->data[1] & FLOW_FIELDS_NUM_MASK) >> FLOW_FIELDS_NUM) ;
+
+	if (num_of_fields < (field_index+1)) {
+		mvOsPrintf("%s: number of heks = %d , index (%d) is out of range.\n", __func__, num_of_fields, field_index);
+		return MV_CLS_OUT_OF_RAGE;
+	}
+
+	fe->data[2] &= ~FLOW_FIELED_MASK(field_index);
+	fe->data[2] |= (field_id <<  FLOW_FIELED_ID(field_index));
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsSwFlowHekNumSet(MV_PP2_CLS_FLOW_ENTRY *fe, int num_of_fields)
+{
+	PTR_VALIDATE(fe);
+	POS_RANGE_VALIDATE(num_of_fields, MV_PP2_CLS_FLOWS_TBL_FIELDS_MAX);
+
+	fe->data[1] &= ~FLOW_FIELDS_NUM_MASK;
+	fe->data[1] |= (num_of_fields << FLOW_FIELDS_NUM);
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------
+
+int mvPp2ClsSwFlowHekSet(MV_PP2_CLS_FLOW_ENTRY *fe, int num_of_fields, int field_ids[])
+{
+	int index;
+
+	PTR_VALIDATE(fe);
+	PTR_VALIDATE(field_ids);
+
+	POS_RANGE_VALIDATE(num_of_fields, MV_PP2_CLS_FLOWS_TBL_FIELDS_MAX);
+
+	fe->data[1] &= ~FLOW_FIELDS_NUM_MASK;
+	fe->data[1] |= (num_of_fields << FLOW_FIELDS_NUM);
+
+	for (index = 0; index < num_of_fields; index++) {
+		POS_RANGE_VALIDATE(field_ids[index], FLOW_FIELED_MAX);
+		fe->data[2] &= ~FLOW_FIELED_MASK(index);
+		fe->data[2] |= (field_ids[index] <<  FLOW_FIELED_ID(index));
+	}
+
+	return MV_OK;
+}
+-------------------------------------------------------------------------------*/
+
+int mvPp2ClsSwFlowPortSet(MV_PP2_CLS_FLOW_ENTRY *fe, int type, int portid)
+{
+	PTR_VALIDATE(fe);
+
+	POS_RANGE_VALIDATE(type, FLOW_PORT_TYPE_MAX);
+	POS_RANGE_VALIDATE(portid, FLOW_PORT_ID_MAX);
+
+	fe->data[0] &= ~FLOW_PORT_ID_MASK;
+	fe->data[0] &= ~FLOW_PORT_TYPE_MASK;
+
+	fe->data[0] |= (portid << FLOW_PORT_ID);
+	fe->data[0] |= (type << FLOW_PORT_TYPE);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsSwFlowEngineSet(MV_PP2_CLS_FLOW_ENTRY *fe, int engine, int is_last)
+{
+	PTR_VALIDATE(fe);
+
+	POS_RANGE_VALIDATE(is_last, 1);
+	POS_RANGE_VALIDATE(engine, FLOW_ENGINE_MAX);
+
+	fe->data[0] &= ~FLOW_LAST_MASK;
+	fe->data[0] &= ~FLOW_ENGINE_MASK;
+
+	fe->data[0] |= is_last;
+	fe->data[0] |= (engine << FLOW_ENGINE);
+
+	return MV_OK;
+
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsSwFlowExtraSet(MV_PP2_CLS_FLOW_ENTRY *fe, int type, int prio)
+{
+	PTR_VALIDATE(fe);
+	POS_RANGE_VALIDATE(type, FLOW_PORT_ID_MAX);
+	POS_RANGE_VALIDATE(prio, FLOW_FIELED_MAX);
+
+	fe->data[1] &= ~FLOW_LKP_TYPE_MASK;
+	fe->data[1] |= (type << FLOW_LKP_TYPE);
+
+	fe->data[1] &= ~FLOW_FIELED_PRIO_MASK;
+	fe->data[1] |= (prio << FLOW_FIELED_PRIO);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsSwFlowHekGet(MV_PP2_CLS_FLOW_ENTRY *fe, int *num_of_fields, int field_ids[])
+{
+	int index;
+
+	PTR_VALIDATE(fe);
+	PTR_VALIDATE(num_of_fields);
+	PTR_VALIDATE(field_ids);
+
+	*num_of_fields = (fe->data[1] & FLOW_FIELDS_NUM_MASK) >> FLOW_FIELDS_NUM;
+
+
+	for (index = 0; index < (*num_of_fields); index++)
+		field_ids[index] = ((fe->data[2] & FLOW_FIELED_MASK(index)) >>  FLOW_FIELED_ID(index));
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsSwFlowPortGet(MV_PP2_CLS_FLOW_ENTRY *fe, int *type, int *portid)
+{
+	PTR_VALIDATE(fe);
+	PTR_VALIDATE(type);
+	PTR_VALIDATE(portid);
+
+	*type = (fe->data[0] & FLOW_PORT_TYPE_MASK) >> FLOW_PORT_TYPE;
+	*portid = (fe->data[0] & FLOW_PORT_ID_MASK) >> FLOW_PORT_ID;
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsSwFlowEngineGet(MV_PP2_CLS_FLOW_ENTRY *fe, int *engine, int *is_last)
+{
+	PTR_VALIDATE(fe);
+	PTR_VALIDATE(engine);
+	PTR_VALIDATE(is_last);
+
+	*engine = (fe->data[0] & FLOW_ENGINE_MASK) >> FLOW_ENGINE;
+	*is_last = fe->data[0] & FLOW_LAST_MASK;
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsSwFlowExtraGet(MV_PP2_CLS_FLOW_ENTRY *fe, int *type, int *prio)
+{
+	PTR_VALIDATE(fe);
+	PTR_VALIDATE(type);
+	PTR_VALIDATE(prio);
+
+	*type = (fe->data[1] & FLOW_LKP_TYPE_MASK) >> FLOW_LKP_TYPE;
+	*prio = (fe->data[1] & FLOW_FIELED_PRIO_MASK) >> FLOW_FIELED_PRIO;
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+/*	Classifier Top Public length change table APIs   			 */
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsPktLenChangeWrite(int index, unsigned int data)
+{
+
+	POS_RANGE_VALIDATE(index, MV_PP2_CLS_LEN_CHANGE_TBL_SIZE);
+
+	/*write index*/
+	mvPp2WrReg(MV_PP2_CLS_LEN_CHANGE_INDEX_REG, index);
+
+	mvPp2WrReg(MV_PP2_CLS_LEN_CHANGE_TBL_REG, data);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsPktLenChangeRead(int index, unsigned int *data)
+{
+	PTR_VALIDATE(data);
+
+	POS_RANGE_VALIDATE(index, MV_PP2_CLS_LEN_CHANGE_TBL_SIZE);
+
+	/*write index*/
+	mvPp2WrReg(MV_PP2_CLS_LEN_CHANGE_INDEX_REG, index);
+
+	*data = mvPp2RdReg(MV_PP2_CLS_LEN_CHANGE_TBL_REG);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsPktLenChangeDump()
+{
+	/* print all non-zero length change entries */
+	int index, int32bit_1;
+
+	mvOsPrintf("INDEX:\tLENGHT\n");
+
+	for (index = 0 ; index <= LEN_CHANGE_LENGTH_MAX; index++) {
+		/* read entry */
+		mvPp2ClsPktLenChangeGet(index, &int32bit_1);
+
+		if (int32bit_1 != 0)
+			mvOsPrintf("0x%3.3x\t%d\n", index, int32bit_1);
+	}
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsPktLenChangeSet(int index, int length)
+{
+	unsigned int dec = 0, data = 0;
+
+	DECIMAL_RANGE_VALIDATE(length, (0 - LEN_CHANGE_LENGTH_MAX), LEN_CHANGE_LENGTH_MAX);
+
+	if (length < 0) {
+		dec =  1;
+		length = 0 - length;
+	}
+
+	data &= ~(LEN_CHANGE_DEC_MASK | LEN_CHANGE_LENGTH_MASK);
+	data |= ((dec << LEN_CHANGE_DEC) |  (length << LEN_CHANGE_LENGTH));
+
+	mvPp2ClsPktLenChangeWrite(index, data);
+
+	return MV_OK;
+}
+
+int mvPp2ClsPktLenChangeGet(int index, int *length)
+{
+	unsigned int data, dec;
+
+	PTR_VALIDATE(length);
+
+	/* read HW entry */
+	mvPp2ClsPktLenChangeRead(index, &data);
+
+	dec = ((data & LEN_CHANGE_DEC_MASK) >> LEN_CHANGE_DEC);
+	*length = ((data & LEN_CHANGE_LENGTH_MASK) >> LEN_CHANGE_LENGTH);
+
+	if (dec == 1)
+		*length = (*length) * (-1);
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+/*			additional cls debug APIs				 */
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2ClsHwRegsDump()
+{
+	int i = 0;
+	char reg_name[100];
+
+	mvPp2PrintReg(MV_PP2_CLS_MODE_REG, "MV_PP2_CLS_MODE_REG");
+	mvPp2PrintReg(MV_PP2_CLS_PORT_WAY_REG, "MV_PP2_CLS_PORT_WAY_REG");
+	mvPp2PrintReg(MV_PP2_CLS_LKP_INDEX_REG, "MV_PP2_CLS_LKP_INDEX_REG");
+	mvPp2PrintReg(MV_PP2_CLS_LKP_TBL_REG, "MV_PP2_CLS_LKP_TBL_REG");
+	mvPp2PrintReg(MV_PP2_CLS_FLOW_INDEX_REG, "MV_PP2_CLS_FLOW_INDEX_REG");
+
+	mvPp2PrintReg(MV_PP2_CLS_FLOW_TBL0_REG, "MV_PP2_CLS_FLOW_TBL0_REG");
+	mvPp2PrintReg(MV_PP2_CLS_FLOW_TBL1_REG, "MV_PP2_CLS_FLOW_TBL1_REG");
+	mvPp2PrintReg(MV_PP2_CLS_FLOW_TBL2_REG, "MV_PP2_CLS_FLOW_TBL2_REG");
+
+
+	mvPp2PrintReg(MV_PP2_CLS_PORT_SPID_REG, "MV_PP2_CLS_PORT_SPID_REG");
+
+	for (i = 0; i < MV_PP2_CLS_SPID_UNI_REGS; i++) {
+		mvOsSPrintf(reg_name, "MV_PP2_CLS_SPID_UNI_%d_REG", i);
+		mvPp2PrintReg((MV_PP2_CLS_SPID_UNI_BASE_REG + (4 * i)), reg_name);
+	}
+
+	for (i = 0; i < MV_PP2_CLS_GEM_VIRT_REGS_NUM; i++) {
+		mvOsSPrintf(reg_name, "MV_PP2_CLS_GEM_VIRT_%d_REG", i);
+		mvPp2PrintReg(MV_PP2_CLS_GEM_VIRT_REG(i), reg_name);
+	}
+
+	for (i = 0; i < MV_PP2_CLS_UDF_BASE_REGS; i++)	{
+		mvOsSPrintf(reg_name, "MV_PP2_CLS_UDF_REG_%d_REG", i);
+		mvPp2PrintReg((MV_PP2_CLS_UDF_BASE_REG + (4 * i)), reg_name);
+	}
+
+	for (i = 0; i < (MV_ETH_MAX_TCONT + MV_PP2_MAX_PORTS - 1); i++) {
+		mvOsSPrintf(reg_name, "MV_PP2_CLS_MTU_%d_REG", i);
+		mvPp2PrintReg(MV_PP2_CLS_MTU_REG(i), reg_name);
+	}
+
+	for (i = 0; i < MV_PP2_MAX_PORTS; i++) {
+		mvOsSPrintf(reg_name, "MV_PP2_CLS_OVERSIZE_RXQ_%d_REG", i);
+		mvPp2PrintReg(MV_PP2_CLS_OVERSIZE_RXQ_REG(i), reg_name);
+	}
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+void mvPp2ClsSwLkpClear(MV_PP2_CLS_LKP_ENTRY *fe)
+{
+	memset(fe, 0, sizeof(MV_PP2_CLS_LKP_ENTRY));
+}
+
+/*-------------------------------------------------------------------------------*/
+void mvPp2ClsSwFlowClear(MV_PP2_CLS_FLOW_ENTRY *fe)
+{
+	memset(fe, 0, sizeof(MV_PP2_CLS_FLOW_ENTRY));
+}
+/*-------------------------------------------------------------------------------*/
+void mvPp2ClsHwFlowClearAll()
+{
+	int index;
+
+	MV_PP2_CLS_FLOW_ENTRY fe;
+
+	mvPp2ClsSwFlowClear(&fe);
+
+	for (index = 0; index < MV_PP2_CLS_FLOWS_TBL_SIZE ; index++)
+		mvPp2ClsHwFlowWrite(index, &fe);
+
+	/* clear shadow */
+	memset(mvClsFlowShadowTbl, NOT_IN_USE, MV_PP2_CLS_FLOWS_TBL_SIZE * sizeof(int));
+
+}
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsHwFlowDump()
+{
+	int index;
+
+	MV_PP2_CLS_FLOW_ENTRY fe;
+
+	for (index = 0; index < MV_PP2_CLS_FLOWS_TBL_SIZE ; index++) {
+		if (mvClsFlowShadowTbl[index] == IN_USE) {
+			mvPp2ClsHwFlowRead(index, &fe);
+			mvPp2ClsSwFlowDump(&fe);
+			mvOsPrintf("------------------------------------------------------------------\n");
+		}
+	}
+	return MV_OK;
+
+}
+/*-------------------------------------------------------------------------------*/
+void mvPp2ClsHwLkpClearAll()
+{
+	int index;
+
+	MV_PP2_CLS_LKP_ENTRY fe;
+
+	mvPp2ClsSwLkpClear(&fe);
+
+	for (index = 0; index < MV_PP2_CLS_LKP_TBL_SIZE ; index++) {
+		mvPp2ClsHwLkpWrite(index, 0, &fe);
+		mvPp2ClsHwLkpWrite(index, 1, &fe);
+	}
+	/* clear shadow */
+	memset(mvClsLkpShadowTbl, NOT_IN_USE, 2 * MV_PP2_CLS_LKP_TBL_SIZE * sizeof(int));
+
+}
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsHwLkpDump()
+{
+	int index, way, int32bit, ind;
+
+	MV_PP2_CLS_LKP_ENTRY fe;
+
+	mvOsPrintf("< ID  WAY >:	RXQ  	EN	FLOW	MODE_BASE\n");
+	for (index = 0; index < MV_PP2_CLS_LKP_TBL_SIZE ; index++)
+		for (way = 0; way < 2 ; way++)	{
+			ind = (way << MV_PP2_CLS_LKP_INDEX_WAY_OFFS) | index;
+			if (mvClsLkpShadowTbl[ind] == IN_USE) {
+				mvPp2ClsHwLkpRead(index, way, &fe);
+				mvOsPrintf(" 0x%2.2x  %1.1d\t", fe.lkpid, fe.way);
+				mvPp2ClsSwLkpRxqGet(&fe, &int32bit);
+				mvOsPrintf("0x%2.2x\t", int32bit);
+				mvPp2ClsSwLkpEnGet(&fe, &int32bit);
+				mvOsPrintf("%1.1d\t", int32bit);
+				mvPp2ClsSwLkpFlowGet(&fe, &int32bit);
+				mvOsPrintf("0x%3.3x\t", int32bit);
+				mvPp2ClsSwLkpModGet(&fe, &int32bit);
+				mvOsPrintf(" 0x%2.2x\n", int32bit);
+			}
+		}
+
+	return MV_OK;
+}
diff --git a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsHw.h b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsHw.h
new file mode 100644
index 0000000..8ae0b2b
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsHw.h
@@ -0,0 +1,365 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_CLS_HW_H__
+#define __MV_CLS_HW_H__
+
+#include "../common/mvPp2ErrCode.h"
+#include "../common/mvPp2Common.h"
+#include "../gbe/mvPp2GbeRegs.h"
+/*-------------------------------------------------------------------------------*/
+/*			Classifier Top Registers	    			 */
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS_MODE_REG                    		(MV_PP2_REG_BASE + 0x1800)
+
+#define MV_PP2_CLS_MODE_ACTIVE_BIT            	 	0
+#define MV_PP2_CLS_MODE_ACTIVE_MASK          	  	(1 << MV_PP2_CLS_MODE_ACTIVE_BIT)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS_PORT_WAY_REG               	 	(MV_PP2_REG_BASE + 0x1810)
+
+#define MV_PP2_CLS_PORT_WAY_OFFS              		 0
+#define MV_PP2_CLS_PORT_WAY_MASK(port)        	 	(1 << ((port) + MV_PP2_CLS_PORT_WAY_OFFS))
+#define WAY_MAX						 1
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS_LKP_INDEX_REG            	 	(MV_PP2_REG_BASE + 0x1814)
+
+#define MV_PP2_CLS_LKP_INDEX_LKP_OFFS        		0
+#define MV_PP2_CLS_LKP_INDEX_WAY_OFFS	 		6
+#define MV_PP2_CLS_LKP_INDEX_BITS		 	7
+#define MV_PP2_CLS_LKP_INDEX_MASK			((1 << MV_PP2_CLS_LKP_INDEX_BITS) - 1)
+#define MV_PP2_CLS_LKP_WAY_MASK				(1 << MV_PP2_CLS_LKP_INDEX_WAY_OFFS)
+
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS_LKP_TBL_REG				(MV_PP2_REG_BASE + 0x1818)
+
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS_FLOW_INDEX_REG              		 (MV_PP2_REG_BASE + 0x1820)
+
+#define MV_PP2_CLS_FLOW_INDEX_BITS			 9
+#define MV_PP2_CLS_FLOW_INDEX_MASK			 ((1 << MV_PP2_CLS_FLOW_INDEX_BITS) - 1)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS_FLOW_TBL0_REG			(MV_PP2_REG_BASE + 0x1824)
+#define MV_PP2_CLS_FLOW_TBL1_REG			(MV_PP2_REG_BASE + 0x1828)
+#define MV_PP2_CLS_FLOW_TBL2_REG			(MV_PP2_REG_BASE + 0x182c)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS_PORT_SPID_REG                	(MV_PP2_REG_BASE + 0x1830)
+
+#define MV_PP2_CLS_PORT_SPID_BITS               	2
+#define MV_PP2_CLS_PORT_SPID_MAX                	((1 << MV_PP2_CLS_PORT_SPID_BITS) - 1)
+#define MV_PP2_CLS_PORT_SPID_MASK(port)         	(((1 << MV_PP2_CLS_PORT_SPID_BITS) - 1) << ((port) * MV_PP2_CLS_PORT_SPID_BITS))
+#define MV_PP2_CLS_PORT_SPID_VAL(port, val)     	((val) << ((port) * MV_PP2_CLS_PORT_SPID_BITS));
+
+/* PORT - SPID types */
+#define PORT_SPID_MH					0
+#define PORT_SPID_EXT_SWITCH				1
+#define PORT_SPID_CAS_SWITCH				2
+#define PORT_SPID_PORT_TRUNK				3
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS_SPID_UNI_BASE_REG   	       		(MV_PP2_REG_BASE + 0x1840)
+#define MV_PP2_CLS_SPID_UNI_REG(spid)         		(MV_PP2_CLS_SPID_UNI_BASE_REG + (((spid) >> 3) * 4))
+
+#define MV_PP2_CLS_SPID_MAX				31
+#define MV_PP2_CLS_SPID_UNI_REGS   	        	4
+#define MV_PP2_CLS_SPID_UNI_BITS               		3
+#define MV_PP2_CLS_SPID_UNI_FIXED_BITS         		4
+#define MV_PP2_CLS_SPID_UNI_MAX                		((1 << MV_PP2_CLS_SPID_UNI_BITS) - 1)
+#define MV_PP2_CLS_SPID_UNI_MASK(spid)			(((1 << MV_PP2_CLS_SPID_UNI_BITS) - 1) << (((spid) % 8) * MV_PP2_CLS_SPID_UNI_FIXED_BITS))
+#define MV_PP2_CLS_SPID_UNI_VAL(spid, val)		((val) << (((spid) % 8) * MV_PP2_CLS_SPID_UNI_FIXED_BITS))
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS_GEM_VIRT_BASE_REG			(MV_PP2_REG_BASE + 0x1A00)
+#define MV_PP2_CLS_GEM_VIRT_REG(gem_id)			(MV_PP2_CLS_GEM_VIRT_BASE_REG + (4 * (gem_id)))
+#define MV_PP2_CLS_GEM_VIRT_REGS_NUM			64
+#define MV_PP2_CLS_GEM_VIRT_BITS			12
+#define MV_PP2_CLS_GEM_VIRT_MAX				((1 << MV_PP2_CLS_GEM_VIRT_BITS) - 1)
+#define MV_PP2_CLS_GEM_VIRT_MASK			(((1 << MV_PP2_CLS_GEM_VIRT_BITS) - 1) << 0)
+/*-------------------------------------------------------------------------------*/
+#define MV_PP2_CLS_UDF_BASE_REG				(MV_PP2_REG_BASE + 0x1860)
+#define MV_PP2_CLS_UDF_REG(index)			(MV_PP2_CLS_UDF_BASE_REG + ((index) * 4)) /*index <=63*/
+#define MV_PP2_CLS_UDF_REGS_NUM				64
+
+#define MV_PP2_CLS_UDF_BASE_REGS			8
+#define MV_PP2_CLS_UDF_OFFSET_ID_OFFS			0
+#define MV_PP2_CLS_UDF_OFFSET_ID_BITS			4
+#define MV_PP2_CLS_UDF_OFFSET_ID_MAX			((1 << MV_PP2_CLS_UDF_OFFSET_ID_BITS) - 1)
+#define MV_PP2_CLS_UDF_OFFSET_ID_MASK			(((1 << MV_PP2_CLS_UDF_OFFSET_ID_BITS) - 1) << MV_PP2_CLS_UDF_OFFSET_ID_OFFS)
+
+#define MV_PP2_CLS_UDF_REL_OFFSET_OFFS			4
+#define MV_PP2_CLS_UDF_REL_OFFSET_BITS			11
+#define MV_PP2_CLS_UDF_REL_OFFSET_MAX			((1 << MV_PP2_CLS_UDF_REL_OFFSET_BITS) - 1)
+#define MV_PP2_CLS_UDF_REL_OFFSET_MASK			(((1 << MV_PP2_CLS_UDF_REL_OFFSET_BITS) - 1) << MV_PP2_CLS_UDF_REL_OFFSET_OFFS)
+
+#define MV_PP2_CLS_UDF_SIZE_OFFS			16
+#define MV_PP2_CLS_UDF_SIZE_BITS			8
+#define MV_PP2_CLS_UDF_SIZE_MAX				((1 << MV_PP2_CLS_UDF_SIZE_BITS) - 1)
+#define MV_PP2_CLS_UDF_SIZE_MASK			(((1 << MV_PP2_CLS_UDF_SIZE_BITS) - 1) << MV_PP2_CLS_UDF_SIZE_OFFS)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS_MTU_BASE_REG				(MV_PP2_REG_BASE + 0x1900)
+#define MV_PP2_CLS_MTU_REG(eport)			(MV_PP2_CLS_MTU_BASE_REG + ((eport) * 4)) /*eport <=31*/
+/* 0-15 pon txq,  16-23 ethernet */
+#define MV_PP2_CLS_MTU_OFFS				0
+#define MV_PP2_CLS_MTU_BITS				16
+#define MV_PP2_CLS_MTU_MAX				((1 << MV_PP2_CLS_MTU_BITS) - 1)
+#define MV_PP2_CLS_MTU_MASK				(((1 << MV_PP2_CLS_MTU_BITS) - 1) << MV_PP2_CLS_MTU_OFFS)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS_OVERSIZE_RXQ_BASE_REG		(MV_PP2_REG_BASE + 0x1980)
+#define MV_PP2_CLS_OVERSIZE_RXQ_REG(eport)		(MV_PP2_CLS_OVERSIZE_RXQ_BASE_REG + (4 * (eport))) /*eport <=23*/
+#define MV_PP2_CLS_OVERSIZE_RXQ_BITS			9
+#define MV_PP2_CLS_OVERSIZE_RXQ_MAX			((1 << MV_PP2_CLS_OVERSIZE_RXQ_BITS) - 1)
+#define MV_PP2_CLS_OVERSIZE_RXQ_OFFS			0
+#define MV_PP2_CLS_OVERSIZE_RX_MASK			(((1 << MV_PP2_CLS_OVERSIZE_RXQ_BITS) - 1) << MV_PP2_CLS_OVERSIZE_RXQ_OFFS)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS_LEN_CHANGE_INDEX_REG			(MV_PP2_REG_BASE + 0x19A0)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_CLS_LEN_CHANGE_TBL_REG			(MV_PP2_REG_BASE + 0x19A4)
+
+/*-------------------------------------------------------------------------------*/
+/*			 lkpid table structure					 */
+/*-------------------------------------------------------------------------------*/
+#define FLOWID_RXQ					0
+#define FLOWID_RXQ_BITS					8
+#define FLOWID_RXQ_MASK					(((1 << FLOWID_RXQ_BITS) - 1) << FLOWID_RXQ)
+
+#define FLOWID_MODE					8
+#define FLOWID_MODE_BITS				8
+#define FLOWID_MODE_MASK				(((1 << FLOWID_MODE_BITS) - 1) << FLOWID_MODE)
+#define FLOWID_MODE_MAX					((1 << FLOWID_MODE_BITS) - 1)
+
+#define FLOWID_FLOW					16
+#define FLOWID_FLOW_BITS				9
+#define FLOWID_FLOW_MASK				(((1 << FLOWID_FLOW_BITS) - 1) << FLOWID_FLOW)
+
+#define FLOWID_EN					25 /*one bit */
+#define FLOWID_EN_MASK					(1 << FLOWID_EN)
+
+
+/*-------------------------------------------------------------------------------*/
+/*			 flow table structure					 */
+/*-------------------------------------------------------------------------------*/
+
+/*-------------------------------  DWORD 0  ------------------------------------ */
+
+#define FLOW_LAST					0
+#define FLOW_LAST_MASK					1 /*one bit*/
+
+#define FLOW_ENGINE					1
+#define FLOW_ENGINE_BITS				3
+#define FLOW_ENGINE_MASK				(((1 << FLOW_ENGINE_BITS) - 1) << FLOW_ENGINE)
+#define FLOW_ENGINE_MAX					5 /* valid value 1 - 5 */
+
+#define FLOW_PORT_ID					4
+#define FLOW_PORT_ID_BITS				8
+#define FLOW_PORT_ID_MASK				(((1 << FLOW_PORT_ID_BITS) - 1) << FLOW_PORT_ID)
+#define FLOW_PORT_ID_MAX				((1 << FLOW_PORT_ID_BITS) - 1)
+
+#define FLOW_PORT_TYPE					12
+#define FLOW_PORT_TYPE_BITS				2
+#define FLOW_PORT_TYPE_MASK				(((1 << FLOW_PORT_TYPE_BITS) - 1) << FLOW_PORT_TYPE)
+#define FLOW_PORT_TYPE_MAX				2 /* valid value 0 - 2 */
+
+/*-------------------------------  DWORD 1  ------------------------------------ */
+
+#define FLOW_FIELDS_NUM					0
+#define FLOW_FIELDS_NUM_BITS				3
+#define FLOW_FIELDS_NUM_MASK				(((1 << FLOW_FIELDS_NUM_BITS) - 1) << FLOW_FIELDS_NUM)
+#define FLOW_FIELDS_NUM_MAX				4 /*valid vaue 0 - 4 */
+
+#define FLOW_LKP_TYPE					3
+#define FLOW_LKP_TYPE_BITS				6
+#define FLOW_LKP_TYPE_MASK				(((1 << FLOW_LKP_TYPE_BITS) - 1) << FLOW_LKP_TYPE)
+#define FLOW_LKP_TYPE_MAX				((1 << FLOW_LKP_TYPE_BITS) - 1)
+
+#define FLOW_FIELED_PRIO				9
+#define FLOW_FIELED_PRIO_BITS				6
+#define FLOW_FIELED_PRIO_MASK				(((1 << FLOW_FIELED_PRIO_BITS) - 1) << FLOW_FIELED_PRIO)
+#define FLOW_FIELED_PRIO_MAX				((1 << FLOW_FIELED_PRIO_BITS) - 1)
+
+/*----------------------------------  DWORD 2  ---------------------------------- */
+#define FLOW_FIELD0_ID					0
+#define FLOW_FIELD1_ID					6
+#define FLOW_FIELD2_ID					12
+#define FLOW_FIELD3_ID					18
+
+#define FLOW_FIELD_ID_BITS				6
+#define FLOW_FIELED_ID(num)				(FLOW_FIELD0_ID + (FLOW_FIELD_ID_BITS * (num)))
+#define FLOW_FIELED_MASK(num)				(((1 << FLOW_FIELD_ID_BITS) - 1) << (FLOW_FIELD_ID_BITS * (num)))
+#define FLOW_FIELED_MAX					((1 << FLOW_FIELD_ID_BITS) - 1)
+
+/*-------------------------------------------------------------------------------*/
+/*		  change length table structure					 */
+/*-------------------------------------------------------------------------------*/
+#define LEN_CHANGE_LENGTH				0
+#define LEN_CHANGE_LENGTH_BITS				7
+#define LEN_CHANGE_LENGTH_MAX				((1 << LEN_CHANGE_LENGTH_BITS) - 1)
+#define LEN_CHANGE_LENGTH_MASK				(((1 << LEN_CHANGE_LENGTH_BITS) - 1) << LEN_CHANGE_LENGTH)
+
+#define LEN_CHANGE_DEC					7 /*1 dec , 0 inc*/
+#define LEN_CHANGE_DEC_MASK				(1 << LEN_CHANGE_DEC)
+/*-------------------------------------------------------------------------------*/
+/*		Classifier Top Public initialization APIs    			 */
+/*-------------------------------------------------------------------------------*/
+/* workaround for HW bug - set las bit in flow entry 0*/
+void mvPp2ClsHwLastBitWorkAround(void);
+
+int mvPp2ClsInit(void);
+int mvPp2ClsHwPortDefConfig(int port, int way, int lkpid, int rxq);
+int mvPp2ClsHwEnable(int enable);
+int mvPp2ClsHwPortWaySet(int port, int way);
+int mvPp2ClsHwPortSpidSet(int port, int spid);
+int mvPp2ClsHwUniPortSet(int uni_port, int spid);
+int mvPp2ClsHwVirtPortSet(int virt_port, int gem_portid);
+int mvPp2ClsHwUdfSet(int udf_no, int offs_id, int offs_bits, int size_bits);
+int mvPp2ClsHwMtuSet(int port, int txp, int mtu);
+int mvPp2ClsHwOversizeRxqSet(int port, int rxq);
+void mvPp2ClsShadowInit(void);
+
+
+/*-------------------------------------------------------------------------------*/
+/*		Classifier Top Public lkpid table APIs     			 */
+/*-------------------------------------------------------------------------------*/
+#define MV_PP2_CLS_LKP_TBL_SIZE				(64)
+
+typedef struct mvPp2ClsLkpEntry {
+	unsigned int lkpid;
+	unsigned int way;
+	unsigned int data;
+} MV_PP2_CLS_LKP_ENTRY;
+
+int mvPp2ClsHwLkpWrite(int lkpid, int way, MV_PP2_CLS_LKP_ENTRY *fe);
+int mvPp2ClsHwLkpRead(int lkpid, int way, MV_PP2_CLS_LKP_ENTRY *fe);
+int mvPp2ClsSwLkpDump(MV_PP2_CLS_LKP_ENTRY *fe);
+int mvPp2ClsHwLkpDump(void);
+void mvPp2ClsSwLkpClear(MV_PP2_CLS_LKP_ENTRY *fe);
+void mvPp2ClsHwLkpClearAll(void);
+
+int mvPp2ClsSwLkpRxqSet(MV_PP2_CLS_LKP_ENTRY *fe, int rxq);
+int mvPp2ClsSwLkpEnSet(MV_PP2_CLS_LKP_ENTRY *fe, int en);
+int mvPp2ClsSwLkpFlowSet(MV_PP2_CLS_LKP_ENTRY *fe, int flow_idx);
+int mvPp2ClsSwLkpModSet(MV_PP2_CLS_LKP_ENTRY *fe, int mod_base);
+int mvPp2ClsSwLkpRxqGet(MV_PP2_CLS_LKP_ENTRY *fe, int *rxq);
+int mvPp2ClsSwLkpEnGet(MV_PP2_CLS_LKP_ENTRY *fe, int *en);
+int mvPp2ClsSwLkpFlowGet(MV_PP2_CLS_LKP_ENTRY *fe, int *flow_idx);
+int mvPp2ClsSwLkpModGet(MV_PP2_CLS_LKP_ENTRY *fe, int *mod_base);
+
+/*-------------------------------------------------------------------------------*/
+/*		Classifier Top Public flows table APIs   			 */
+/*-------------------------------------------------------------------------------*/
+#define MV_PP2_CLS_FLOWS_TBL_SIZE			(512)
+#define MV_PP2_CLS_FLOWS_TBL_DATA_WORDS			(3)
+#define MV_PP2_CLS_FLOWS_TBL_FIELDS_MAX			(4)
+
+typedef struct mvPp2ClsFlowEntry {
+	unsigned int index;
+	unsigned int data[MV_PP2_CLS_FLOWS_TBL_DATA_WORDS];
+} MV_PP2_CLS_FLOW_ENTRY;
+
+int mvPp2ClsHwFlowWrite(int index, MV_PP2_CLS_FLOW_ENTRY *fe);
+int mvPp2ClsHwFlowRead(int index, MV_PP2_CLS_FLOW_ENTRY *fe);
+int mvPp2ClsSwFlowDump(MV_PP2_CLS_FLOW_ENTRY *fe);
+int mvPp2ClsHwFlowDump(void);
+void mvPp2ClsSwFlowClear(MV_PP2_CLS_FLOW_ENTRY *fe);
+void mvPp2ClsHwFlowClearAll(void);
+
+/*
+int mvPp2ClsSwFlowHekSet(MV_PP2_CLS_FLOW_ENTRY *fe, int num_of_fields, int field_ids[]);
+*/
+int mvPp2ClsSwFlowHekSet(MV_PP2_CLS_FLOW_ENTRY *fe, int field_index, int field_id);
+int mvPp2ClsSwFlowHekNumSet(MV_PP2_CLS_FLOW_ENTRY *fe, int num_of_fields);
+int mvPp2ClsSwFlowPortSet(MV_PP2_CLS_FLOW_ENTRY *fe, int type, int portid);
+int mvPp2ClsSwFlowEngineSet(MV_PP2_CLS_FLOW_ENTRY *fe, int engine, int is_last);
+int mvPp2ClsSwFlowExtraSet(MV_PP2_CLS_FLOW_ENTRY *fe, int type, int prio);
+int mvPp2ClsSwFlowHekGet(MV_PP2_CLS_FLOW_ENTRY *fe, int *num_of_fields, int field_ids[]);
+int mvPp2ClsSwFlowPortGet(MV_PP2_CLS_FLOW_ENTRY *fe, int *type, int *portid);
+int mvPp2ClsSwFlowEngineGet(MV_PP2_CLS_FLOW_ENTRY *fe, int *engine, int *is_last);
+int mvPp2ClsSwFlowExtraGet(MV_PP2_CLS_FLOW_ENTRY *fe, int *type, int *prio);
+
+
+/*-------------------------------------------------------------------------------*/
+/*		Classifier Top Public length change table APIs  		 */
+/*-------------------------------------------------------------------------------*/
+#define MV_PP2_CLS_LEN_CHANGE_TBL_SIZE				(256)
+
+int mvPp2ClsPktLenChangeDump(void);
+int mvPp2ClsPktLenChangeSet(int index, int length);
+int mvPp2ClsPktLenChangeGet(int index, int *length);
+
+
+/*-------------------------------------------------------------------------------*/
+/*			additional cls debug APIs				 */
+/*-------------------------------------------------------------------------------*/
+int mvPp2ClsHwRegsDump(void);
+
+#endif /* MV_CLS_HW */
diff --git a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsMcHw.c b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsMcHw.c
new file mode 100644
index 0000000..9f0cdbb
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsMcHw.c
@@ -0,0 +1,339 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvPp2ClsMcHw.h"
+
+MC_SHADOW_ENTRY  mvMcShadowTbl[MV_PP2_MC_TBL_SIZE];
+
+/******************************************************************************
+ * Common utilities
+ ******************************************************************************/
+/*
+static void mvPp2McShadowSet(int index, int next)
+{
+	mvMcShadowTbl[index].valid = 1;
+	mvMcShadowTbl[index].next = next;
+}
+*/
+/*-------------------------------------------------------------------------------*/
+/*
+static void mvPp2McShadowClear(int index)
+{
+	mvMcShadowTbl[index].valid = 0;
+}
+*/
+/*-------------------------------------------------------------------------------*/
+/*
+static void mvPp2McShadowClearAll(void)
+{
+	int index;
+
+	for (index = 0; index < MV_PP2_MC_TBL_SIZE; index++)
+		mvMcShadowTbl[index].valid = 0;
+}
+*/
+/*-------------------------------------------------------------------------------*/
+/*
+int mvPp2McFirstFreeGet(void)
+{
+	int index;
+
+	Go through the all entires from first to last
+	for (index = 0; index < MV_PP2_MC_TBL_SIZE; index++) {
+		if (!mvMcShadowTbl[index].valid)
+			break;
+	}
+	return index;
+}
+*/
+/*-------------------------------------------------------------------------------*/
+int	mvPp2McHwWrite(MV_PP2_MC_ENTRY *mc, int index)
+{
+	PTR_VALIDATE(mc);
+
+	POS_RANGE_VALIDATE(index, MV_PP2_MC_TBL_SIZE - 1);
+
+	mc->index = index;
+
+	/* write index */
+	mvPp2WrReg(MV_PP2_MC_INDEX_REG, mc->index);
+
+	/* write data */
+	mvPp2WrReg(MV_PP2_MC_DATA1_REG, mc->sram.regs.data1);
+	mvPp2WrReg(MV_PP2_MC_DATA2_REG, mc->sram.regs.data2);
+	mvPp2WrReg(MV_PP2_MC_DATA3_REG, mc->sram.regs.data3);
+
+	/*
+	update shadow
+	next = ((mc->sram.regs.data3 & MV_PP2_MC_DATA3_NEXT_MASK) >> MV_PP2_MC_DATA3_NEXT);
+	mvPp2McShadowSet(mc->index, next);
+	*/
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+int	mvPp2McHwRead(MV_PP2_MC_ENTRY *mc, int index)
+{
+	PTR_VALIDATE(mc);
+
+	POS_RANGE_VALIDATE(index, MV_PP2_MC_TBL_SIZE - 1);
+
+	mc->index = index;
+
+	/* write index */
+	mvPp2WrReg(MV_PP2_MC_INDEX_REG, mc->index);
+
+	/* read data */
+	mc->sram.regs.data1 = mvPp2RdReg(MV_PP2_MC_DATA1_REG);
+	mc->sram.regs.data2 = mvPp2RdReg(MV_PP2_MC_DATA2_REG);
+	mc->sram.regs.data3 = mvPp2RdReg(MV_PP2_MC_DATA3_REG);
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+int	mvPp2McSwDump(MV_PP2_MC_ENTRY *mc)
+{
+	mvOsPrintf("INDEX:0x%2x\t", mc->index);
+
+	mvOsPrintf("IPTR:0x%1x\t",
+			(mc->sram.regs.data1 >> MV_PP2_MC_DATA1_IPTR) & ACT_HWF_ATTR_IPTR_MAX);
+
+	mvOsPrintf("DPTR:0x%1x\t",
+			(mc->sram.regs.data1 >> MV_PP2_MC_DATA1_DPTR) & ACT_HWF_ATTR_DPTR_MAX);
+
+	if (mc->sram.regs.data2 &  MV_PP2_MC_DATA2_GEM_ID_EN)
+		mvOsPrintf("GPID:0x%3x\t", (mc->sram.regs.data2 >> MV_PP2_MC_DATA2_GEM_ID) & ACT_QOS_ATTR_GEM_ID_MAX);
+	else
+		mvOsPrintf("GPID:INV\t");
+
+	if (mc->sram.regs.data2 &  MV_PP2_MC_DATA2_DSCP_EN)
+		mvOsPrintf("DSCP:0x%1x\t", (mc->sram.regs.data2 >> MV_PP2_MC_DATA2_DSCP) & ACT_QOS_ATTR_DSCP_MAX);
+	else
+		mvOsPrintf("DSCP:INV\t");
+
+	if (mc->sram.regs.data2 &  MV_PP2_MC_DATA2_PRI_EN)
+		mvOsPrintf("PRI:0x%1x \t", (mc->sram.regs.data2 >> MV_PP2_MC_DATA2_PRI) & ACT_QOS_ATTR_PRI_MAX);
+	else
+		mvOsPrintf("DSCP:INV\t");
+
+	mvOsPrintf("QUEUE:0x%2x\t", (mc->sram.regs.data3 >> MV_PP2_MC_DATA3_QUEUE) & 0xFF);/*TODO use gbe define*/
+
+	if (mc->sram.regs.data3 & MV_PP2_MC_DATA3_HWF_EN)
+		mvOsPrintf("HW_FWD:ENABLE\t");
+
+	else
+		mvOsPrintf("HW_FWD:DISABLE\t");
+
+	mvOsPrintf("NEXT:0x%2x\t", (mc->sram.regs.data3 >> MV_PP2_MC_DATA3_NEXT) & MV_PP2_MC_INDEX_MAX);
+
+	mvOsPrintf("\n");
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+int	mvPp2McHwDump(void)
+{
+	int index;
+	MV_PP2_MC_ENTRY mc;
+
+	for (index = 0; index < MV_PP2_MC_TBL_SIZE; index++) {
+		mc.index = index;
+		mvPp2McHwRead(&mc, index);
+		mvPp2McSwDump(&mc);
+		mvOsPrintf("-------------------------------------------------------------------------");
+		mvOsPrintf("-------------------------------------------------------------------------\n");
+
+	}
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+void	mvPp2McSwClear(MV_PP2_MC_ENTRY *mc)
+{
+	memset(mc, 0, sizeof(MV_PP2_MC_ENTRY));
+}
+
+/*-------------------------------------------------------------------------------*/
+void	mvPp2McHwClearAll(void)
+{
+	int index;
+	MV_PP2_MC_ENTRY mc;
+
+	mvPp2McSwClear(&mc);
+
+	for (index = 0; index < MV_PP2_MC_TBL_SIZE; index++)
+		mvPp2McHwWrite(&mc, index);
+
+}
+/*-------------------------------------------------------------------------------*/
+
+int	mvPp2McSwModSet(MV_PP2_MC_ENTRY *mc, int data_ptr, int instr_offs)
+{
+	PTR_VALIDATE(mc);
+	POS_RANGE_VALIDATE(data_ptr, ACT_HWF_ATTR_DPTR_MAX);
+	POS_RANGE_VALIDATE(instr_offs, ACT_HWF_ATTR_IPTR_MAX);
+
+	mc->sram.regs.data1 &= ~(ACT_HWF_ATTR_DPTR_MAX << MV_PP2_MC_DATA1_DPTR);
+	mc->sram.regs.data1 |= (data_ptr << MV_PP2_MC_DATA1_DPTR);
+
+	mc->sram.regs.data1 &= ~(ACT_HWF_ATTR_IPTR_MAX << MV_PP2_MC_DATA1_IPTR);
+	mc->sram.regs.data1 |= (instr_offs << MV_PP2_MC_DATA1_IPTR);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+int	mvPp2McSwGpidSet(MV_PP2_MC_ENTRY *mc, int gpid, int enable)
+{
+	PTR_VALIDATE(mc);
+	POS_RANGE_VALIDATE(gpid, ACT_QOS_ATTR_GEM_ID_MAX);
+	POS_RANGE_VALIDATE(enable, 1);
+	if (enable) {
+		mc->sram.regs.data2 &= ~(ACT_QOS_ATTR_GEM_ID_MAX << MV_PP2_MC_DATA2_GEM_ID);
+		mc->sram.regs.data2 |= (gpid << MV_PP2_MC_DATA2_GEM_ID);
+		mc->sram.regs.data2 |= MV_PP2_MC_DATA2_GEM_ID_EN;
+
+	} else
+		mc->sram.regs.data2 &= ~MV_PP2_MC_DATA2_GEM_ID_EN;
+
+	return MV_OK;
+
+}
+/*-------------------------------------------------------------------------------*/
+int	mvPp2McSwDscpSet(MV_PP2_MC_ENTRY *mc, int dscp, int enable)
+{
+	PTR_VALIDATE(mc);
+	POS_RANGE_VALIDATE(dscp, ACT_QOS_ATTR_DSCP_MAX);
+	POS_RANGE_VALIDATE(enable, 1);
+	if (enable) {
+		mc->sram.regs.data2 &= ~(ACT_QOS_ATTR_DSCP_MAX << MV_PP2_MC_DATA2_DSCP);
+		mc->sram.regs.data2 |= (dscp << MV_PP2_MC_DATA2_DSCP);
+		mc->sram.regs.data2 |= MV_PP2_MC_DATA2_DSCP_EN;
+
+	} else
+		mc->sram.regs.data2 &= MV_PP2_MC_DATA2_DSCP_EN;
+
+	return MV_OK;
+
+}
+/*-------------------------------------------------------------------------------*/
+int	mvPp2McSwPrioSet(MV_PP2_MC_ENTRY *mc, int prio, int enable)
+{
+	PTR_VALIDATE(mc);
+	POS_RANGE_VALIDATE(prio, ACT_QOS_ATTR_PRI_MAX);
+	POS_RANGE_VALIDATE(enable, 1);
+	if (enable) {
+		mc->sram.regs.data2 &= ~(ACT_QOS_ATTR_PRI_MAX << MV_PP2_MC_DATA2_PRI);
+		mc->sram.regs.data2 |= (prio << MV_PP2_MC_DATA2_PRI);
+		mc->sram.regs.data2 |= MV_PP2_MC_DATA2_PRI_EN;
+
+	} else
+		mc->sram.regs.data2 &= ~MV_PP2_MC_DATA2_PRI_EN;
+
+	return MV_OK;
+
+}
+/*-------------------------------------------------------------------------------*/
+int	mvPp2McSwQueueSet(MV_PP2_MC_ENTRY *mc, int q)
+{
+	PTR_VALIDATE(mc);
+	POS_RANGE_VALIDATE(q, 0xFF);/*TODO use gbe define*/
+
+	mc->sram.regs.data3 &= ~(0xFF << MV_PP2_MC_DATA3_QUEUE);/*TODO use gbe define*/
+	mc->sram.regs.data3 |= (q << MV_PP2_MC_DATA3_QUEUE);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+int	mvPp2McSwForwardEn(MV_PP2_MC_ENTRY *mc, int enable)
+{
+	PTR_VALIDATE(mc);
+	POS_RANGE_VALIDATE(enable, 1);
+
+	if (enable)
+		mc->sram.regs.data3 |= MV_PP2_MC_DATA3_HWF_EN;
+	else
+		mc->sram.regs.data3 &= ~MV_PP2_MC_DATA3_HWF_EN;
+
+	return MV_OK;
+
+}
+/*-------------------------------------------------------------------------------*/
+
+int	mvPp2McSwNext(MV_PP2_MC_ENTRY *mc, int next)
+{
+	PTR_VALIDATE(mc);
+	/* if next = -1 last link */
+	DECIMAL_RANGE_VALIDATE(next, -1, MV_PP2_MC_INDEX_MAX);
+
+	mc->sram.regs.data3 &= ~(MV_PP2_MC_INDEX_MAX << MV_PP2_MC_DATA3_NEXT);
+	mc->sram.regs.data3 |= (next << MV_PP2_MC_DATA3_NEXT);
+
+	return MV_OK;
+
+}
+/*-------------------------------------------------------------------------------*/
diff --git a/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsMcHw.h b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsMcHw.h
new file mode 100644
index 0000000..c8a22fa
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/cls/mvPp2ClsMcHw.h
@@ -0,0 +1,150 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_CLS_MC_HW_H__
+#define __MV_CLS_MC_HW_H__
+
+#include "mvPp2ClsActHw.h"
+#include "../common/mvPp2ErrCode.h"
+#include "../common/mvPp2Common.h"
+#include "../gbe/mvPp2GbeRegs.h"
+
+/*-------------------------------------------------------------------------------*/
+/*			Multicast table Top Registers	    			 */
+/*-------------------------------------------------------------------------------*/
+#define MV_PP2_MC_INDEX_REG			(MV_PP2_REG_BASE + 0x160)
+#define MV_PP2_MC_INDEX_MAX			ACT_DUP_FID_MAX
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_MC_DATA1_REG			(MV_PP2_REG_BASE + 0x164)
+#define	MV_PP2_MC_DATA1_DPTR			1
+#define	MV_PP2_MC_DATA1_IPTR			16
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_MC_DATA2_REG			(MV_PP2_REG_BASE + 0x168)
+#define MV_PP2_MC_DATA2_GEM_ID			0
+#define MV_PP2_MC_DATA2_PRI			12
+#define MV_PP2_MC_DATA2_DSCP			15
+#define MV_PP2_MC_DATA2_GEM_ID_EN		(1 << 21)
+#define MV_PP2_MC_DATA2_PRI_EN			(1 << 22)
+#define MV_PP2_MC_DATA2_DSCP_EN			(1 << 23)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_MC_DATA3_REG			(MV_PP2_REG_BASE + 0x16C)
+
+#define MV_PP2_MC_DATA3_QUEUE			0
+
+#define MV_PP2_MC_DATA3_HWF_EN			(1 << 8)
+
+#define MV_PP2_MC_DATA3_NEXT			16
+#define MV_PP2_MC_DATA3_NEXT_MASK		(MV_PP2_MC_INDEX_MAX << MV_PP2_MC_DATA3_NEXT)
+
+
+typedef struct {
+	int             valid;
+	int		next;
+} MC_SHADOW_ENTRY;
+
+#define LAST 	(-1)
+/*-------------------------------------------------------------------------------*/
+/*			Multicast table Public APIs				 */
+/*-------------------------------------------------------------------------------*/
+#define MV_PP2_MC_TBL_SIZE		256
+#define MV_PP2_MC_WORDS			3
+
+
+typedef struct mvPp2McEntry {
+	unsigned int index;
+	union {
+		MV_U32 words[MV_PP2_MC_WORDS];
+		struct {
+			MV_U32 data1;/* 0x164 */
+			MV_U32 data2;/* 0x168 */
+			MV_U32 data3;/* 0x16c */
+		} regs;
+	} sram;
+} MV_PP2_MC_ENTRY;
+/*
+int	mvPp2McFirstFreeGet(void)
+*/
+
+int	mvPp2McHwWrite(MV_PP2_MC_ENTRY *mc, int index);
+int	mvPp2McHwRead(MV_PP2_MC_ENTRY *mc, int index);
+int	mvPp2McSwDump(MV_PP2_MC_ENTRY *mc);
+int	mvPp2McHwDump(void);
+void	mvPp2McSwClear(MV_PP2_MC_ENTRY *mc);
+void	mvPp2McHwClearAll(void);
+
+
+int	mvPp2McSwModSet(MV_PP2_MC_ENTRY *mc, int data_ptr, int instr_offs);
+int	mvPp2McSwGpidSet(MV_PP2_MC_ENTRY *mc, int gpid, int enable);
+int	mvPp2McSwDscpSet(MV_PP2_MC_ENTRY *mc, int dscp, int enable);
+int	mvPp2McSwPrioSet(MV_PP2_MC_ENTRY *mc, int prio, int enable);
+int	mvPp2McSwQueueSet(MV_PP2_MC_ENTRY *mc, int q);
+int	mvPp2McSwForwardEn(MV_PP2_MC_ENTRY *mc, int enable);
+int	mvPp2McSwNext(MV_PP2_MC_ENTRY *mc, int next);
+
+
+#endif /*__MV_CLS_MC_HW_H__ */
+
diff --git a/arch/arm/plat-armada/mv_hal/pp2/common/mvPp2Common.c b/arch/arm/plat-armada/mv_hal/pp2/common/mvPp2Common.c
new file mode 100644
index 0000000..e6c3e17
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/common/mvPp2Common.c
@@ -0,0 +1,112 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#include "mvPp2Common.h"
+
+/*#define PP2_REG_WRITE_TRACE*/
+/*#define PP2_REG_READ_TRACE*/
+
+int mvPp2WrReg(unsigned int offset, unsigned int  val)
+{
+	MV_REG_WRITE(offset, val);
+#if defined(PP2_REG_WRITE_TRACE)
+	mvOsPrintf("REG:0x%08X	W:0x%08X\n", offset, val);
+#endif
+	return val;
+}
+
+int mvPp2RdReg(unsigned int offset)
+{
+	unsigned int val = MV_REG_READ(offset);
+
+#if defined(PP2_REG_READ_TRACE)
+	mvOsPrintf("REG:0x%08X	R:0x%08X\n", offset, val);
+#endif
+	return val;
+}
+
+int mvPp2SPrintReg(char *buf, unsigned int  reg_addr, char *reg_name)
+
+{
+	return mvOsSPrintf(buf, "  %-32s: 0x%x = 0x%08x\n", reg_name, reg_addr, MV_REG_READ(reg_addr));
+}
+
+int mvPp2PrintReg(unsigned int reg_addr, char *reg_name)
+
+{
+	return mvOsPrintf("  %-32s: 0x%x = 0x%08x\n", reg_name, reg_addr, MV_REG_READ(reg_addr));
+}
+
+void mvEthRegPrint(MV_U32 reg_addr, char *reg_name)
+{
+	mvOsPrintf("  %-32s: 0x%x = 0x%08x\n", reg_name, reg_addr, MV_REG_READ(reg_addr));
+}
+
+void mvEthRegPrint2(MV_U32 reg_addr, char *reg_name, MV_U32 index)
+{
+	char buf[64];
+
+	mvOsSPrintf(buf, "%s[%d]", reg_name, index);
+	mvOsPrintf("  %-32s: 0x%x = 0x%08x\n", buf, reg_addr, MV_REG_READ(reg_addr));
+}
+
diff --git a/arch/arm/plat-armada/mv_hal/pp2/common/mvPp2Common.h b/arch/arm/plat-armada/mv_hal/pp2/common/mvPp2Common.h
new file mode 100644
index 0000000..41a71ef
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/common/mvPp2Common.h
@@ -0,0 +1,133 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#ifndef __MV_PP2_COMMON_H__
+#define __MV_PP2_COMMON_H__
+
+#include "mvTypes.h"
+#include "mvCommon.h"
+#include "mvOs.h"
+
+/*--------------------------------------------------------------------*/
+/*			PP2 COMMON MACROS			      */
+/*--------------------------------------------------------------------*/
+
+#define DECIMAL_RANGE_VALIDATE(_VALUE_ , _MIN_, _MAX_) {\
+	if (((_VALUE_) > (_MAX_)) || ((_VALUE_) < (_MIN_))) {\
+		mvOsPrintf("%s: value %d (0x%x) is out of range [%d , %d].\n",\
+				__func__, (_VALUE_), (_VALUE_), (_MIN_), (_MAX_));\
+		return MV_ERROR;\
+	} \
+}
+
+#define RANGE_VALIDATE(_VALUE_ , _MIN_, _MAX_) {\
+	if (((_VALUE_) > (_MAX_)) || ((_VALUE_) < (_MIN_))) {\
+		mvOsPrintf("%s: value 0x%X (%d) is out of range [0x%X , 0x%X].\n",\
+				__func__, (_VALUE_), (_VALUE_), (_MIN_), (_MAX_));\
+		return MV_ERROR;\
+	} \
+}
+
+#define BIT_RANGE_VALIDATE(_VALUE_)			RANGE_VALIDATE(_VALUE_ , 0, 1)
+
+#define POS_RANGE_VALIDATE(_VALUE_, _MAX_)		RANGE_VALIDATE(_VALUE_ , 0, _MAX_)
+
+#define PTR_VALIDATE(_ptr_) {\
+	if (_ptr_ == NULL) {\
+		mvOsPrintf("%s: null pointer.\n", __func__);\
+		return MV_ERROR;\
+	} \
+}
+
+#define WARN_OOM(cond) if (cond) { mvOsPrintf("%s: out of memory\n", __func__); return NULL; }
+
+
+/*--------------------------------------------------------------------*/
+/*			PP2 COMMON FUNCTIONS			      */
+/*--------------------------------------------------------------------*/
+
+
+int mvPp2RdReg(unsigned int offset);
+
+int mvPp2WrReg(unsigned int offset, unsigned int  val);
+
+int mvPp2PrintReg(unsigned int  reg_addr, char *reg_name);
+
+int mvPp2SPrintReg(char *buf, unsigned int  reg_addr, char *reg_name);
+
+void mvEthRegPrint(MV_U32 reg_addr, char *reg_name);
+void mvEthRegPrint2(MV_U32 reg_addr, char *reg_name, MV_U32 index);
+
+/*--------------------------------------------------------------------*/
+/*			PP2 COMMON DEFINETIONS			      */
+/*--------------------------------------------------------------------*/
+#define NOT_IN_USE					(-1)
+#define IN_USE						(1)
+#define DWORD_BITS_LEN					32
+#define DWORD_BYTES_LEN                                 4
+#define RETRIES_EXCEEDED				5000
+#define ONE_BIT_MAX					1
+#define UNI_MAX						7
+#define ETH_PORTS_NUM					7
+
+#endif /* __MV_PP2_ERR_CODE_H__ */
diff --git a/arch/arm/plat-armada/mv_hal/pp2/common/mvPp2ErrCode.h b/arch/arm/plat-armada/mv_hal/pp2/common/mvPp2ErrCode.h
new file mode 100644
index 0000000..6d7a421
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/common/mvPp2ErrCode.h
@@ -0,0 +1,119 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_PP2_ERR_CODE_H__
+#define __MV_PP2_ERR_CODE_H__
+
+#define  MV_ERR_CODE_BASE					0x80000000
+#define  MV_PP2_ERR_CODE_BASE					(MV_ERR_CODE_BASE | 0x00001000)
+
+
+#define  MV_PP2_PRS						(MV_PP2_ERR_CODE_BASE | 0x00000100)
+#define  MV_PP2_CLS						(MV_PP2_ERR_CODE_BASE | 0x00000200)
+#define  MV_PP2_CLS2						(MV_PP2_ERR_CODE_BASE | 0x00000400)
+#define  MV_PP2_CLS3						(MV_PP2_ERR_CODE_BASE | 0x00000800)
+#define  MV_PP2_CLS4						(MV_PP2_ERR_CODE_BASE | 0x00000800)
+
+
+/*****************************************************************************
+
+
+
+			    E R R O R   C O D E S
+
+
+*****************************************************************************/
+/* #define MV_OK 0  define in mvTypes*/
+#define EQUALS 0
+#define NOT_EQUALS 1
+
+/* PRS error codes */
+#define  MV_PRS_ERR						(MV_PP2_PRS | 0x00)
+#define  MV_PRS_OUT_OF_RAGE					(MV_PP2_PRS | 0x01)
+#define  MV_PRS_NULL_POINTER					(MV_PP2_PRS | 0x02)
+
+/* CLS error codes */
+#define  MV_CLS_ERR						(MV_PP2_CLS | 0x00)
+#define  MV_CLS_OUT_OF_RAGE					(MV_PP2_CLS | 0x01)
+
+/* CLS2 error codes */
+#define  MV_CLS2_ERR						(MV_PP2_CLS2 | 0x00)
+#define  MV_CLS2_OUT_OF_RAGE					(MV_PP2_CLS2 | 0x01)
+#define  MV_CLS2_NULL_POINTER					(MV_PP2_CLS2 | 0x02)
+#define  MV_CLS2_RETRIES_EXCEEDED				(MV_PP2_CLS2 | 0x03)
+
+/* CLS3 error codes */
+#define  MV_CLS3_ERR						(MV_PP2_CLS3 | 0x00)
+#define  MV_CLS3_OUT_OF_RAGE					(MV_PP2_CLS3 | 0x01)
+#define  MV_CLS3_NULL_POINTER					(MV_PP2_CLS3 | 0x02)
+#define  MV_CLS3_RETRIES_EXCEEDED				(MV_PP2_CLS3 | 0x03)
+#define  MV_CLS3_SW_INTERNAL					(MV_PP2_CLS3 | 0x04)
+
+/* CLS4 error codes */
+#define  MV_CLS4_ERR						(MV_PP2_CLS4 | 0x00)
+#define  MV_CLS4_OUT_OF_RAGE					(MV_PP2_CLS4 | 0x01)
+#define  MV_CLS4_NULL_POINTER					(MV_PP2_CLS4 | 0x02)
+#define  MV_CLS4_RETRIES_EXCEEDED				(MV_PP2_CLS4 | 0x03)
+
+#endif /* __MV_PP2_ERR_CODE_H__ */
diff --git a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2AddrDec.c b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2AddrDec.c
new file mode 100644
index 0000000..e709276
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2AddrDec.c
@@ -0,0 +1,360 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "mvSysEthConfig.h"
+
+#include "mvPp2Gbe.h"
+
+MV_TARGET ethAddrDecPrioTab[] = {
+#if defined(MV_INCLUDE_SDRAM_CS0)
+	SDRAM_CS0,
+#endif
+#if defined(MV_INCLUDE_SDRAM_CS1)
+	SDRAM_CS1,
+#endif
+#if defined(MV_INCLUDE_SDRAM_CS2)
+	SDRAM_CS2,
+#endif
+#if defined(MV_INCLUDE_SDRAM_CS3)
+	SDRAM_CS3,
+#endif
+	TBL_TERM
+};
+
+static MV_STATUS ethWinOverlapDetect(MV_U32 winNum, MV_ADDR_WIN *pAddrWin);
+
+/*******************************************************************************
+* mvPp2WinInit
+*
+* DESCRIPTION:
+*	This function initialize ETH window decode unit. It set the default
+*	address decode windows of the unit.
+*
+* INPUT:
+*	addWinMap: An array holding the address decoding information for the
+*		    system.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_ERROR if setting fail.
+*******************************************************************************/
+MV_STATUS mvPp2WinInit(MV_U32 dummy/*backward compability*/, MV_UNIT_WIN_INFO *addrWinMap)
+{
+	MV_U32 winNum, winPrioIndex = 0, regVal = 0;
+	MV_UNIT_WIN_INFO *addrDecWin;
+
+	/* Initiate Ethernet address decode */
+	/* First disable all address decode windows */
+	for (winNum = 0; winNum < ETH_MAX_DECODE_WIN; winNum++)
+		regVal |= MV_BIT_MASK(winNum);
+
+	mvPp2WrReg(ETH_BASE_ADDR_ENABLE_REG, regVal);
+
+	/* Go through all windows in user table until table terminator      */
+	for (winNum = 0; ((ethAddrDecPrioTab[winPrioIndex] != TBL_TERM) && (winNum < ETH_MAX_DECODE_WIN));) {
+		addrDecWin = &addrWinMap[ethAddrDecPrioTab[winPrioIndex]];
+
+		if (addrDecWin->enable == MV_TRUE) {
+			if (MV_OK != mvPp2WinWrite(0, winNum, addrDecWin)) {
+				mvOsPrintf("mvPp2WinInit failed: winNum=%d (%d, %d)\n",
+					   winNum, winPrioIndex, ethAddrDecPrioTab[winPrioIndex]);
+				return MV_ERROR;
+			}
+			winNum++;
+		}
+		winPrioIndex++;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvPp2WinWrite
+*
+* DESCRIPTION:
+*	This function writes the address decoding registers according to the
+*	given window configuration.
+*
+* INPUT:
+*	unit	    - The Ethernet unit number to configure.
+*       winNum	    - ETH target address decode window number.
+*       pAddrDecWin - ETH target window data structure.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_OK on success,
+*	MV_BAD_PARAM if winNum is invalid.
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvPp2WinWrite(MV_U32 dummy/*backward compability*/, MV_U32 winNum, MV_UNIT_WIN_INFO *pAddrDecWin)
+{
+	MV_U32 size, alignment;
+	MV_U32 baseReg, sizeReg;
+
+	/* Parameter checking   */
+	if (winNum >= ETH_MAX_DECODE_WIN) {
+		mvOsPrintf("mvPp2WinSet: ERR. Invalid win num %d\n", winNum);
+		return MV_BAD_PARAM;
+	}
+
+	/* Check if the requested window overlapps with current windows     */
+	if (MV_TRUE == ethWinOverlapDetect(winNum, &pAddrDecWin->addrWin)) {
+		mvOsPrintf("mvPp2WinWrite: ERR. Window %d overlap\n", winNum);
+		return MV_ERROR;
+	}
+
+	/* check if address is aligned to the size */
+	if (MV_IS_NOT_ALIGN(pAddrDecWin->addrWin.baseLow, pAddrDecWin->addrWin.size)) {
+		mvOsPrintf("mvPp2WinSet: Error setting Ethernet window %d.\n"
+			   "Address 0x%08x is unaligned to size 0x%x.\n",
+			   winNum, pAddrDecWin->addrWin.baseLow, (MV_U32)pAddrDecWin->addrWin.size);
+		return MV_ERROR;
+	}
+
+	size = pAddrDecWin->addrWin.size;
+	if (!MV_IS_POWER_OF_2(size)) {
+		mvOsPrintf("mvPp2WinWrite: Error setting AUDIO window %d. "
+			   "Window size is not a power to 2.", winNum);
+		return MV_BAD_PARAM;
+	}
+
+	baseReg = (pAddrDecWin->addrWin.baseLow & ETH_WIN_BASE_MASK);
+	sizeReg = MV_REG_READ(ETH_WIN_SIZE_REG(winNum));
+
+	/* set size */
+	alignment = 1 << ETH_WIN_SIZE_OFFS;
+	sizeReg &= ~ETH_WIN_SIZE_MASK;
+	sizeReg |= (((size / alignment) - 1) << ETH_WIN_SIZE_OFFS);
+
+	/* set attributes */
+	baseReg &= ~ETH_WIN_ATTR_MASK;
+	baseReg |= pAddrDecWin->attrib << ETH_WIN_ATTR_OFFS;
+
+	/* set target ID */
+	baseReg &= ~ETH_WIN_TARGET_MASK;
+	baseReg |= pAddrDecWin->targetId << ETH_WIN_TARGET_OFFS;
+
+	/* for the safe side we disable the window before writing the new
+	   values */
+	mvPp2WinEnable(0, winNum, MV_FALSE);
+	mvPp2WrReg(ETH_WIN_BASE_REG(winNum), baseReg);
+
+	/* Write to address decode Size Register                            */
+	mvPp2WrReg(ETH_WIN_SIZE_REG(winNum), sizeReg);
+
+	/* Enable address decode target window                              */
+	if (pAddrDecWin->enable == MV_TRUE)
+		mvPp2WinEnable(0, winNum, MV_TRUE);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* ethWinOverlapDetect - Detect ETH address windows overlapping
+*
+* DESCRIPTION:
+*       An unpredicted behaviur is expected in case ETH address decode
+*       windows overlapps.
+*       This function detects ETH address decode windows overlapping of a
+*       specified window. The function does not check the window itself for
+*       overlapping. The function also skipps disabled address decode windows.
+*
+* INPUT:
+*       winNum      - address decode window number.
+*       pAddrDecWin - An address decode window struct.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if the given address window overlap current address
+*       decode map, MV_FALSE otherwise, MV_ERROR if reading invalid data
+*       from registers.
+*
+*******************************************************************************/
+static MV_STATUS ethWinOverlapDetect(MV_U32 winNum, MV_ADDR_WIN *pAddrWin)
+{
+	MV_U32 baseAddrEnableReg;
+	MV_U32 winNumIndex;
+	MV_UNIT_WIN_INFO addrDecWin;
+
+	/* Read base address enable register. Do not check disabled windows     */
+	baseAddrEnableReg = MV_REG_READ(ETH_BASE_ADDR_ENABLE_REG);
+
+	for (winNumIndex = 0; winNumIndex < ETH_MAX_DECODE_WIN; winNumIndex++) {
+		/* Do not check window itself           */
+		if (winNumIndex == winNum)
+			continue;
+
+		/* Do not check disabled windows        */
+		if (baseAddrEnableReg & (1 << winNumIndex))
+			continue;
+
+		/* Get window parameters        */
+		if (MV_OK != mvPp2WinRead(0, winNumIndex, &addrDecWin)) {
+			mvOsPrintf("ethWinOverlapDetect: ERR. TargetWinGet failed\n");
+			return MV_ERROR;
+		}
+
+		if (MV_TRUE == mvWinOverlapTest(pAddrWin, &(addrDecWin.addrWin)))
+			return MV_TRUE;
+	}
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvPp2WinRead
+*
+* DESCRIPTION:
+*       Read Ethernet peripheral target address window.
+*
+* INPUT:
+*       winNum - ETH to target address decode window number.
+*
+* OUTPUT:
+*       pAddrDecWin - ETH target window data structure.
+*
+* RETURN:
+*	MV_BAD_PARAM if winNum is invalid.
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvPp2WinRead(MV_U32 dummy/*backward compability*/, MV_U32 winNum, MV_UNIT_WIN_INFO *pAddrDecWin)
+{
+	MV_U32 baseReg, sizeReg;
+	MV_U32 alignment, size;
+
+	/* Parameter checking   */
+	if (winNum >= ETH_MAX_DECODE_WIN) {
+		mvOsPrintf("mvPp2WinGet: ERR. Invalid winNum %d\n", winNum);
+		return MV_NOT_SUPPORTED;
+	}
+
+	baseReg = MV_REG_READ(ETH_WIN_BASE_REG(winNum));
+	sizeReg = MV_REG_READ(ETH_WIN_SIZE_REG(winNum));
+
+	alignment = 1 << ETH_WIN_SIZE_OFFS;
+	size = (sizeReg & ETH_WIN_SIZE_MASK) >> ETH_WIN_SIZE_OFFS;
+	pAddrDecWin->addrWin.size = (size + 1) * alignment;
+
+	/* Extract base address                                     */
+	pAddrDecWin->addrWin.baseLow = baseReg & ETH_WIN_BASE_MASK;
+	pAddrDecWin->addrWin.baseHigh = 0;
+
+	/* attrib and targetId */
+	pAddrDecWin->attrib = (baseReg & ETH_WIN_ATTR_MASK) >> ETH_WIN_ATTR_OFFS;
+	pAddrDecWin->targetId = (baseReg & ETH_WIN_TARGET_MASK) >> ETH_WIN_TARGET_OFFS;
+
+	/* Check if window is enabled   */
+	if (~(MV_REG_READ(ETH_BASE_ADDR_ENABLE_REG)) & (1 << winNum))
+		pAddrDecWin->enable = MV_TRUE;
+	else
+		pAddrDecWin->enable = MV_FALSE;
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvPp2WinEnable - Enable/disable a ETH to target address window
+*
+* DESCRIPTION:
+*       This function enable/disable a ETH to target address window.
+*       According to parameter 'enable' the routine will enable the
+*       window, thus enabling ETH accesses (before enabling the window it is
+*       tested for overlapping). Otherwise, the window will be disabled.
+*
+* INPUT:
+*       winNum - ETH to target address decode window number.
+*       enable - Enable/disable parameter.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_ERROR if decode window number was wrong or enabled window overlapps.
+*
+*******************************************************************************/
+MV_STATUS mvPp2WinEnable(MV_U32 dummy/*backward compability*/, MV_U32 winNum, MV_BOOL enable)
+{
+	/* Parameter checking   */
+	if (winNum >= ETH_MAX_DECODE_WIN) {
+		mvOsPrintf("mvPp2TargetWinEnable:ERR. Invalid winNum%d\n", winNum);
+		return MV_ERROR;
+	}
+
+	if (enable)
+		MV_REG_BIT_SET(ETH_BASE_ADDR_ENABLE_REG, (1 << winNum));
+	else
+		/* Disable address decode target window                             */
+		MV_REG_BIT_RESET(ETH_BASE_ADDR_ENABLE_REG, (1 << winNum));
+
+	return MV_OK;
+}
+
diff --git a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.c b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.c
new file mode 100644
index 0000000..2dd4945
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.c
@@ -0,0 +1,1467 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"		/* Should be included before mvSysHwConfig */
+#include "mvTypes.h"
+#include "mv802_3.h"
+#include "mvDebug.h"
+#include "mvOs.h"
+
+#include "mvPp2Gbe.h"
+#include "pp2/prs/mvPp2Prs.h"
+#include "pp2/bm/mvBm.h"
+
+#define MV_PP2_RXQ_FREE 	-1
+
+#define TX_DISABLE_TIMEOUT_MSEC     1000
+#define RX_DISABLE_TIMEOUT_MSEC     1000
+#define TX_FIFO_EMPTY_TIMEOUT_MSEC  10000
+#define PORT_DISABLE_WAIT_TCLOCKS   5000
+
+/* physical TXQs */
+MV_PP2_PHYS_TXQ_CTRL *mvPp2PhysTxqs;
+
+/* aggregated TXQs */
+MV_PP2_AGGR_TXQ_CTRL *mvPp2AggrTxqs;
+
+/* physical RXQs */
+MV_PP2_PHYS_RXQ_CTRL *mvPp2PhysRxqs;
+
+/* ports control */
+MV_PP2_PORT_CTRL **mvPp2PortCtrl;
+
+/* HW data */
+MV_PP2_HAL_DATA mvPp2HalData;
+
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2MaxCheck(int value, int limit, char *name)
+{
+	if ((value < 0) || (value >= limit)) {
+		mvOsPrintf("%s %d is out of range [0..%d]\n",
+			name ? name : "value", value, (limit - 1));
+		return 1;
+	}
+	return 0;
+}
+
+int mvPp2PortCheck(int port)
+{
+	return mvPp2MaxCheck(port, mvPp2HalData.maxPort, "port");
+}
+
+int mvPp2TxpCheck(int port, int txp)
+{
+	int txpMax = 1;
+
+	if (mvPp2PortCheck(port))
+		return 1;
+
+	if (MV_PON_PORT(port))
+		txpMax = mvPp2HalData.maxTcont;
+
+	return mvPp2MaxCheck(txp, txpMax, "txp");
+}
+
+int mvPp2CpuCheck(int cpu)
+{
+	return mvPp2MaxCheck(cpu, mvPp2HalData.maxCPUs, "cpu");
+}
+
+int mvPp2EgressPort(int port, int txp)
+{
+	if (!MV_PON_PORT(port))
+		return (MV_ETH_MAX_TCONT + port + txp);
+	return txp;
+}
+/*-------------------------------------------------------------------------------*/
+MV_STATUS mvPp2HalInit(MV_PP2_HAL_DATA *halData)
+{
+	int bytes, i;
+	MV_STATUS status;
+
+	mvPp2HalData = *halData;
+	bytes = mvPp2HalData.maxPort * sizeof(MV_PP2_PORT_CTRL *);
+
+	/* Allocate port data structures */
+	mvPp2PortCtrl = mvOsMalloc(bytes);
+	if (mvPp2PortCtrl == NULL) {
+		mvOsPrintf("%s: Can't allocate %d bytes for %d ports\n", __func__,
+			   mvPp2HalData.maxPort * sizeof(MV_PP2_PORT_CTRL), mvPp2HalData.maxPort);
+		return MV_OUT_OF_CPU_MEM;
+	}
+
+	mvOsMemset(mvPp2PortCtrl, 0, bytes);
+
+	/* Allocate physical TXQs */
+	status = mvPp2PhysTxqsAlloc();
+
+	/* Allocate aggregated TXQs */
+	status = mvPp2AggrTxqsAlloc(mvPp2HalData.maxCPUs);
+
+	/* Allocate physical RXQs */
+	status = mvPp2PhysRxqsAlloc();
+
+	mvBmInit();
+
+	/* Rx Fifo Init */
+	mvPp2RxFifoInit(mvPp2HalData.maxPort);
+
+	/* Init all interrupt rxqs groups - each port has 0 rxqs */
+	for (i = 0; i <= MV_PON_PORT_ID; i++)
+		mvPp2GbeIsrRxqGroup(i, 0);
+
+	mvPp2WrReg(ETH_MNG_EXTENDED_GLOBAL_CTRL_REG, 0x27);
+
+	/* Allow cache snoop when transmiting packets */
+	mvPp2WrReg(MV_PP2_TX_SNOOP_REG, 0x1);
+
+	return MV_OK;
+}
+
+
+/*******************************************************************************
+* mvNetaDefaultsSet - Set defaults to the NETA port
+*
+* DESCRIPTION:
+*       This
+function sets default values to the NETA port.
+*       1) Clears interrupt Cause and Mask registers.
+*       2) Clears all MAC tables.
+*       3) Sets defaults to all registers.
+*       4) Resets RX and TX descriptor rings.
+*       5) Resets PHY.
+*
+* INPUT:
+*   int     portNo		- Port number.
+*
+* RETURN:   MV_STATUS
+*               MV_OK - Success, Others - Failure
+* NOTE:
+*   This function updates all the port configurations except those set
+*   initialy by the OsGlue by MV_NETA_PORT_INIT.
+*   This function can be called after portDown to return the port settings
+*   to defaults.
+*******************************************************************************/
+MV_STATUS mvPp2DefaultsSet(int port)
+{
+	int txp, queue, txPortNum, i;
+	MV_PP2_PORT_CTRL *pPortCtrl = mvPp2PortHndlGet(port);
+
+	for (txp = 0; txp < pPortCtrl->txpNum; txp++) {
+		/* Disable Legacy WRR, Disable EJP, Release from reset */
+		txPortNum = mvPp2EgressPort(port, txp);
+
+		mvPp2WrReg(MV_PP2_TXP_SCHED_PORT_INDEX_REG, txPortNum);
+
+		mvPp2WrReg(MV_PP2_TXP_SCHED_CMD_1_REG, 0);
+		/* Close bandwidth for all queues */
+		for (queue = 0; queue < MV_ETH_MAX_TXQ; queue++)
+			mvPp2WrReg(MV_PP2_TXQ_SCHED_TOKEN_CNTR_REG(MV_PPV2_TXQ_PHYS(port, txp, queue)),  0);
+
+		/* Set basic period to  1 usec */
+		mvPp2WrReg(MV_PP2_TXP_SCHED_REFILL_REG,  mvPp2HalData.tClk / 1000000);
+	}
+
+	/* Enable Rx cache snoop */
+	for (i = 0; i < pPortCtrl->rxqNum; i++) {
+		queue = mvPp2LogicRxqToPhysRxq(port, i);
+		mvPp2WrReg(MV_PP2_RXQ_SNOOP_REG(queue), MV_PP2_SNOOP_PKT_SIZE_MASK | MV_PP2_SNOOP_BUF_HDR_MASK);
+	}
+
+	/* At default, mask all interrupts to all cpus */
+	for (i = 0; i < mvPp2HalData.maxCPUs; i++)
+		mvPp2GbeCpuInterruptsDisable(port, i);
+
+	return MV_OK;
+
+}
+
+/*-------------------------------------------------------------------------------*/
+/* Mapping */
+/* Add a mapping prxq <-> (port, lrxq) */
+MV_STATUS mvPp2PhysRxqMapAdd(int prxq, int port, int lrxq)
+{
+	MV_PP2_PORT_CTRL *pCtrl;
+
+	if (mvPp2PortCheck(port)) {
+		mvOsPrintf("Bad port number: %d\n", port);
+		return MV_BAD_PARAM;
+	}
+	if (lrxq < 0 || lrxq > MV_ETH_MAX_RXQ) {
+		mvOsPrintf("Bad logical RXQ number: %d\n", lrxq);
+		return MV_BAD_PARAM;
+	}
+	if (mvPp2PhysRxqs == NULL)
+		return MV_ERROR;
+	if (prxq < 0 || prxq >= MV_ETH_RXQ_TOTAL_NUM)
+		return MV_BAD_PARAM;
+	if (mvPp2PhysRxqs[prxq].port != MV_PP2_RXQ_FREE || mvPp2PhysRxqs[prxq].logicRxq != MV_PP2_RXQ_FREE)
+		return MV_BAD_PARAM;
+
+	pCtrl = mvPp2PortCtrl[port];
+	/* map prxq <- (port, lrxq) */
+	if (pCtrl == NULL || pCtrl->pRxQueue == NULL)
+		return MV_BAD_PARAM;
+	if (lrxq < 0 || lrxq >= MV_ETH_MAX_RXQ)
+		return MV_BAD_PARAM;
+	if (pCtrl->rxqNum >= MV_ETH_MAX_RXQ)
+		return MV_FAIL;
+
+	pCtrl->pRxQueue[lrxq] = &mvPp2PhysRxqs[prxq];
+	pCtrl->rxqNum++;
+
+	/* map prxq -> (port, lrxq) */
+	mvPp2PhysRxqs[prxq].port = port;
+	mvPp2PhysRxqs[prxq].logicRxq = lrxq;
+
+	return MV_OK;
+}
+
+/* Free the relevant physical rxq */
+MV_STATUS mvPp2PhysRxqMapDel(int prxq)
+{
+	int port, lrxq;
+
+	if (mvPp2PhysRxqs == NULL)
+		return MV_ERROR;
+	if (prxq < 0 || prxq >= MV_ETH_RXQ_TOTAL_NUM)
+		return MV_BAD_PARAM;
+
+	port = mvPp2PhysRxqs[prxq].port;
+	lrxq = mvPp2PhysRxqs[prxq].logicRxq;
+	mvPp2PhysRxqs[prxq].port = MV_PP2_RXQ_FREE;
+	mvPp2PhysRxqs[prxq].logicRxq = MV_PP2_RXQ_FREE;
+
+	if (port != MV_PP2_RXQ_FREE && lrxq != MV_PP2_RXQ_FREE &&
+		mvPp2PortCtrl[port] && mvPp2PortCtrl[port]->pRxQueue[lrxq]) {
+		mvPp2PortCtrl[port]->pRxQueue[lrxq] = NULL;
+		mvPp2PortCtrl[port]->rxqNum--;
+	}
+
+	return MV_OK;
+}
+
+MV_STATUS mvPp2PortLogicRxqMapDel(int port, int lrxq)
+{
+	MV_PP2_PHYS_RXQ_CTRL *prxqCtrl;
+
+	if (mvPp2PortCheck(port)) {
+		mvOsPrintf("Bad port number: %d\n", port);
+		return MV_BAD_PARAM;
+	}
+	if (lrxq < 0 || lrxq > MV_ETH_MAX_RXQ) {
+		mvOsPrintf("Bad logical RXQ number: %d\n", lrxq);
+		return MV_BAD_PARAM;
+	}
+	if (mvPp2PhysRxqs == NULL)
+		return MV_ERROR;
+	if (mvPp2PortCtrl[port] == NULL || mvPp2PortCtrl[port]->pRxQueue == NULL)
+		return MV_BAD_PARAM;
+
+	prxqCtrl = mvPp2PortCtrl[port]->pRxQueue[lrxq];
+	mvPp2PortCtrl[port]->pRxQueue[lrxq] = NULL;
+	if (prxqCtrl) {
+		prxqCtrl->logicRxq = MV_PP2_RXQ_FREE;
+		prxqCtrl->port = MV_PP2_RXQ_FREE;
+		mvPp2PortCtrl[port]->rxqNum--;
+	}
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+/* General descriptor management */
+static void mvPp2DescRingReset(MV_PP2_QUEUE_CTRL *pQueueCtrl)
+{
+	int descrNum = (pQueueCtrl->lastDesc + 1);
+	char *pDesc  = pQueueCtrl->pFirst;
+
+	if (pDesc == NULL)
+		return;
+
+	/* reset ring of descriptors */
+	mvOsMemset(pDesc, 0, (descrNum * MV_PP2_DESC_ALIGNED_SIZE));
+	mvOsCacheFlush(NULL, pDesc, (descrNum * MV_PP2_DESC_ALIGNED_SIZE));
+	pQueueCtrl->nextToProc = 0;
+}
+
+/* allocate descriptors */
+static MV_U8 *mvPp2DescrMemoryAlloc(int descSize, MV_ULONG *pPhysAddr, MV_U32 *memHandle)
+{
+	MV_U8 *pVirt;
+#ifdef ETH_DESCR_UNCACHED
+	pVirt = (MV_U8 *)mvOsIoUncachedMalloc(NULL, descSize, pPhysAddr, memHandle);
+#else
+	pVirt = (MV_U8 *)mvOsIoCachedMalloc(NULL, descSize, pPhysAddr, memHandle);
+#endif /* ETH_DESCR_UNCACHED */
+	if (pVirt)
+		mvOsMemset(pVirt, 0, descSize);
+
+	return pVirt;
+}
+
+static void mvPp2DescrMemoryFree(int descSize, MV_ULONG *pPhysAddr, MV_U8 *pVirt, MV_U32 *memHandle)
+{
+#ifdef ETH_DESCR_UNCACHED
+	mvOsIoUncachedFree(NULL, descSize, (MV_ULONG)pPhysAddr, pVirt, (MV_U32)memHandle);
+#else
+	mvOsIoCachedFree(NULL, descSize, (MV_ULONG)pPhysAddr, pVirt, (MV_U32)memHandle);
+#endif /* ETH_DESCR_UNCACHED */
+}
+
+MV_STATUS mvPp2DescrCreate(MV_PP2_QUEUE_CTRL *qCtrl, int descNum)
+{
+	int descSize;
+
+	/* Allocate memory for descriptors */
+	descSize = ((descNum * MV_PP2_DESC_ALIGNED_SIZE) + MV_PP2_DESC_Q_ALIGN);
+	qCtrl->descBuf.bufVirtPtr =
+	    mvPp2DescrMemoryAlloc(descSize, &qCtrl->descBuf.bufPhysAddr, &qCtrl->descBuf.memHandle);
+
+	qCtrl->descBuf.bufSize = descSize;
+
+	if (qCtrl->descBuf.bufVirtPtr == NULL) {
+		mvOsPrintf("%s: Can't allocate %d bytes for %d descr\n", __func__, descSize, descNum);
+		return MV_OUT_OF_CPU_MEM;
+	}
+
+	/* Make sure descriptor address is aligned */
+	qCtrl->pFirst = (char *)MV_ALIGN_UP((MV_ULONG) qCtrl->descBuf.bufVirtPtr, MV_PP2_DESC_Q_ALIGN);
+
+	qCtrl->lastDesc = (descNum - 1);
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+/* RXQ */
+/* Allocate and initialize descriptors for RXQ */
+MV_PP2_PHYS_RXQ_CTRL *mvPp2RxqInit(int port, int rxq, int descNum)
+{
+	MV_STATUS status;
+	int prxq;
+	MV_PP2_PHYS_RXQ_CTRL *pRxq;
+	MV_PP2_QUEUE_CTRL *qCtrl;
+
+	prxq = mvPp2LogicRxqToPhysRxq(port, rxq);
+	if (prxq < 0) {
+		mvOsPrintf("bad (port,rxq): (%d, %d), no mapping to physical rxq\n", port, rxq);
+		return NULL;
+	}
+	pRxq = &mvPp2PhysRxqs[prxq];
+	qCtrl = &pRxq->queueCtrl;
+
+	/* Number of descriptors must be multiple of 16 */
+	if (descNum % 16 != 0) {
+		mvOsPrintf("Descriptor number %d, must be a multiple of 16\n", descNum);
+		return NULL;
+	}
+
+	status = mvPp2DescrCreate(qCtrl, descNum);
+	if (status != MV_OK)
+		return NULL;
+
+	mvPp2DescRingReset(qCtrl);
+
+	/* Set Rx descriptors queue starting address */
+	/* indirect access */
+	mvPp2WrReg(MV_PP2_RXQ_NUM_REG, prxq);
+	mvPp2WrReg(MV_PP2_RXQ_DESC_ADDR_REG, pp2DescVirtToPhys(qCtrl, (MV_U8 *)qCtrl->pFirst));
+	mvPp2WrReg(MV_PP2_RXQ_DESC_SIZE_REG, descNum);
+	mvPp2WrReg(MV_PP2_RXQ_INDEX_REG, 0);
+
+	return pRxq;
+}
+
+void mvPp2RxqDelete(int port, int rxq)
+{
+	int prxq;
+	MV_PP2_PHYS_RXQ_CTRL *pRxq;
+	MV_PP2_QUEUE_CTRL *pQueueCtrl;
+	MV_BUF_INFO *pDescBuf;
+
+	prxq = mvPp2LogicRxqToPhysRxq(port, rxq);
+
+	if (prxq < 0) {
+		mvOsPrintf("bad (port,rxq): (%d, %d), no mapping to physical rxq\n", port, rxq);
+		return;
+	}
+	pRxq = &mvPp2PhysRxqs[prxq];
+	pQueueCtrl = &pRxq->queueCtrl;
+	pDescBuf = &pQueueCtrl->descBuf;
+
+	mvPp2DescrMemoryFree(pDescBuf->bufSize, (MV_ULONG *)pDescBuf->bufPhysAddr,
+				pDescBuf->bufVirtPtr, (MV_U32 *)pDescBuf->memHandle);
+	mvOsMemset(pQueueCtrl, 0, sizeof(*pQueueCtrl));
+
+	/* Clear Rx descriptors queue starting address, size and free descr number */
+	mvPp2WrReg(MV_PP2_RXQ_STATUS_REG(prxq), 0);
+	mvPp2WrReg(MV_PP2_RXQ_NUM_REG, prxq);
+	mvPp2WrReg(MV_PP2_RXQ_DESC_ADDR_REG, 0);
+	mvPp2WrReg(MV_PP2_RXQ_DESC_SIZE_REG, 0);
+}
+
+/* Allocate and initialize all physical RXQs.
+   This function must be called before any use of RXQ */
+MV_STATUS mvPp2PhysRxqsAlloc(MV_VOID)
+{
+	int i;
+
+	mvPp2PhysRxqs = mvOsMalloc(MV_ETH_RXQ_TOTAL_NUM * sizeof(MV_PP2_PHYS_RXQ_CTRL));
+	if (!mvPp2PhysRxqs) {
+		mvOsPrintf("mvPp2 Can't allocate %d Bytes for %d RXQs controls\n",
+			   MV_ETH_RXQ_TOTAL_NUM * sizeof(MV_PP2_PHYS_RXQ_CTRL), MV_ETH_RXQ_TOTAL_NUM);
+		return MV_OUT_OF_CPU_MEM;
+	}
+	for (i = 0; i < MV_ETH_RXQ_TOTAL_NUM; i++) {
+		mvPp2PhysRxqs[i].port = MV_PP2_RXQ_FREE;
+		mvPp2PhysRxqs[i].logicRxq = MV_PP2_RXQ_FREE;
+		mvPp2PhysRxqs[i].rxq = i;
+	}
+	return MV_OK;
+}
+
+/* Destroy all physical RXQs */
+MV_STATUS mvPp2PhysRxqsDestroy(MV_VOID)
+{
+/*TODO*/
+	return MV_OK;
+}
+
+/* Associate <num_rxqs> RXQs for Port number <port>, starting from RXQ number <firstRxq>
+   Port and physical RXQs must be initialized.
+   Opperation succeeds only if ALL RXQs can be added to this port - otherwise do nothing */
+MV_STATUS mvPp2PortRxqsInit(int port, int firstRxq, int numRxqs)
+{
+	int i;
+	MV_PP2_PORT_CTRL *pCtrl = mvPp2PortCtrl[port];
+
+	if (firstRxq < 0 || firstRxq + numRxqs > MV_ETH_RXQ_TOTAL_NUM) {
+		mvOsPrintf("%s: Bad RXQ parameters. first RXQ = %d,  num of RXQS = %d\n", __func__, firstRxq, numRxqs);
+		return MV_BAD_PARAM;
+	}
+	/* Check resources */
+	for (i = firstRxq; i < firstRxq + numRxqs; i++) {
+		if (mvPp2PhysRxqs[i].port != MV_PP2_RXQ_FREE || mvPp2PhysRxqs[i].logicRxq != MV_PP2_RXQ_FREE) {
+			mvOsPrintf("%s: Failed to init port#%d RXQ#%d: RXQ is already occupied\n", __func__, port, i);
+			return MV_FAIL;
+		}
+	}
+
+	/* Allocate logical RXQs */
+	if (!pCtrl->pRxQueue)
+		pCtrl->pRxQueue = mvOsMalloc(MV_ETH_MAX_RXQ * sizeof(MV_PP2_PHYS_RXQ_CTRL *));
+	if (!pCtrl->pRxQueue)
+		return MV_OUT_OF_CPU_MEM;
+
+	/* Associate requested RXQs with port */
+	for (i = firstRxq; i < firstRxq + numRxqs; i++)
+		mvPp2PhysRxqMapAdd(i, port, i - firstRxq);
+
+	return MV_OK;
+}
+
+MV_STATUS mvPp2RxqOffsetSet(int port, int rxq, int offset)
+{
+	MV_U32 regVal;
+	int prxq = mvPp2LogicRxqToPhysRxq(port, rxq);
+
+	if (offset % 32 != 0) {
+		mvOsPrintf("%s: offset must be in units of 32\n", __func__);
+		return MV_BAD_PARAM;
+	}
+
+	regVal = mvPp2RdReg(MV_PP2_RXQ_CONFIG_REG(prxq));
+	regVal &= ~MV_PP2_RXQ_PACKET_OFFSET_MASK;
+
+	/* Offset is in */
+	regVal |= ((offset << MV_PP2_RXQ_PACKET_OFFSET_OFFS) & MV_PP2_RXQ_PACKET_OFFSET_MASK);
+
+	mvPp2WrReg(MV_PP2_RXQ_CONFIG_REG(prxq), regVal);
+
+	return MV_OK;
+}
+
+MV_STATUS mvPp2RxqPktsCoalSet(int port, int rxq, MV_U32 pkts)
+{
+	MV_U32 regVal;
+	int prxq = mvPp2LogicRxqToPhysRxq(port, rxq);
+
+	regVal = (pkts << MV_PP2_OCCUPIED_THRESH_OFFSET) & MV_PP2_OCCUPIED_THRESH_MASK;
+	mvPp2WrReg(MV_PP2_RXQ_NUM_REG, prxq);
+	mvPp2WrReg(MV_PP2_RXQ_THRESH_REG, regVal);
+
+	return MV_OK;
+}
+
+int mvPp2RxqPktsCoalGet(int port, int rxq)
+{
+	MV_U32 regVal;
+	int prxq = mvPp2LogicRxqToPhysRxq(port, rxq);
+
+	mvPp2WrReg(MV_PP2_RXQ_NUM_REG, prxq);
+	regVal = mvPp2RdReg(MV_PP2_RXQ_THRESH_REG);
+
+	return (regVal & MV_PP2_OCCUPIED_THRESH_MASK) >> MV_PP2_OCCUPIED_THRESH_OFFSET;
+}
+
+/* Reset all RXQs */
+void mvPp2RxReset(int port)
+{
+	int rxq, prxq;
+	MV_PP2_PORT_CTRL *pPortCtrl = mvPp2PortCtrl[port];
+	MV_PP2_PHYS_RXQ_CTRL *pRxq;
+
+	for (rxq = 0; rxq < pPortCtrl->rxqNum ; rxq++) {
+		prxq = mvPp2LogicRxqToPhysRxq(port, rxq);
+		pRxq = &mvPp2PhysRxqs[prxq];
+
+		mvPp2DescRingReset(&pRxq->queueCtrl);
+		mvPp2WrReg(MV_PP2_RXQ_NUM_REG, prxq);
+		mvPp2WrReg(MV_PP2_RXQ_INDEX_REG, 0);
+	}
+}
+/*-------------------------------------------------------------------------------*/
+/* TXQ */
+/* Allocate and initialize descriptors for TXQ */
+MV_PP2_PHYS_TXQ_CTRL *mvPp2TxqInit(int port, int txp, int txq, int descNum, int hwfNum)
+{
+	MV_STATUS status;
+	int ptxq = MV_PPV2_TXQ_PHYS(port, txp, txq);
+	MV_PP2_PHYS_TXQ_CTRL *pTxq = &mvPp2PhysTxqs[ptxq];
+	MV_PP2_QUEUE_CTRL *qCtrl = &pTxq->queueCtrl;
+
+	status = mvPp2DescrCreate(qCtrl, descNum);
+	if (status != MV_OK)
+		return NULL;
+
+	mvPp2DescRingReset(qCtrl);
+
+	/* Set Tx descriptors queue starting address */
+	/* indirect access */
+	mvPp2WrReg(MV_PP2_TXQ_NUM_REG, ptxq);
+	mvPp2WrReg(MV_PP2_TXQ_DESC_ADDR_REG, pp2DescVirtToPhys(qCtrl, (MV_U8 *)qCtrl->pFirst));
+	mvPp2WrReg(MV_PP2_TXQ_DESC_SIZE_REG, descNum & MV_PP2_TXQ_DESC_SIZE_MASK);
+	mvPp2WrReg(MV_PP2_TXQ_DESC_HWF_SIZE_REG, hwfNum & MV_PP2_TXQ_DESC_HWF_SIZE_MASK);
+	mvPp2WrReg(MV_PP2_TXQ_INDEX_REG, 0);
+
+	mvPp2WrReg(MV_PP2_TXQ_PREF_BUF_REG, MV_PP2_PREF_BUF_PTR(ptxq*4) | MV_PP2_PREF_BUF_SIZE_4 |
+				MV_PP2_PREF_BUF_THRESH(4/2));
+
+	return pTxq;
+}
+
+MV_STATUS mvPp2TxqDelete(int port, int txp, int txq)
+{
+	int ptxq = MV_PPV2_TXQ_PHYS(port, txp, txq);
+	MV_PP2_QUEUE_CTRL *pQueueCtrl = &mvPp2PhysTxqs[ptxq].queueCtrl;
+	MV_BUF_INFO *pDescBuf = &pQueueCtrl->descBuf;
+
+	mvPp2DescrMemoryFree(pDescBuf->bufSize, (MV_ULONG *)pDescBuf->bufPhysAddr,
+				pDescBuf->bufVirtPtr, (MV_U32 *)pDescBuf->memHandle);
+
+	mvOsMemset(pQueueCtrl, 0, sizeof(*pQueueCtrl));
+
+	/* Set minimum bandwidth for disabled TXQs */
+	mvPp2WrReg(MV_PP2_TXQ_SCHED_TOKEN_CNTR_REG(ptxq), 0);
+
+	/* Set Tx descriptors queue starting address and size */
+	mvPp2WrReg(MV_PP2_TXQ_NUM_REG, ptxq);
+
+	mvPp2WrReg(MV_PP2_TXQ_DESC_ADDR_REG, 0);
+	mvPp2WrReg(MV_PP2_TXQ_DESC_SIZE_REG, 0);
+	mvPp2WrReg(MV_PP2_TXQ_DESC_HWF_SIZE_REG, 0);
+
+	return MV_OK;
+}
+
+/* Allocate and initialize all physical TXQs.
+   This function must be called before any use of TXQ */
+MV_STATUS mvPp2PhysTxqsAlloc()
+{
+	int i;
+
+	mvPp2PhysTxqs = mvOsMalloc(MV_PP2_TXQ_TOTAL_NUM * sizeof(MV_PP2_PHYS_TXQ_CTRL));
+	if (!mvPp2PhysTxqs) {
+		mvOsPrintf("mvPp2 Can't allocate %d Bytes for %d TXQs control\n",
+			   MV_PP2_TXQ_TOTAL_NUM * sizeof(MV_PP2_PHYS_TXQ_CTRL), MV_PP2_TXQ_TOTAL_NUM);
+		return MV_OUT_OF_CPU_MEM;
+	}
+	for (i = 0; i < MV_PP2_TXQ_TOTAL_NUM; i++)
+		mvPp2PhysTxqs[i].txq = i;
+
+	return MV_OK;
+}
+
+/* Destroy all physical TXQs */
+MV_STATUS mvPp2PhysTxqsDestroy(MV_VOID)
+{
+/*TODO*/
+	return MV_OK;
+}
+
+/* Associate TXQs for this port
+   Physical TXQS must be initialized (by using mvPp2PhysTxqsAlloc)
+   Notice that TXQ mapping is predefined */
+MV_STATUS mvPp2PortTxqsInit(int port)
+{
+	int txp, txq, ptxq;
+	MV_PP2_PORT_CTRL *pCtrl = mvPp2PortCtrl[port];
+
+	if (!pCtrl->pTxQueue)
+		pCtrl->pTxQueue = mvOsMalloc(pCtrl->txqNum * pCtrl->txpNum * sizeof(MV_PP2_PHYS_TXQ_CTRL *));
+	if (!pCtrl->pTxQueue)
+		return MV_OUT_OF_CPU_MEM;
+
+	for (txp = 0; txp < pCtrl->txpNum; txp++) {
+		for (txq = 0; txq < pCtrl->txqNum; txq++) {
+			ptxq = MV_PPV2_TXQ_PHYS(port, txp, txq);
+			pCtrl->pTxQueue[txp * CONFIG_MV_ETH_TXQ + txq] = &mvPp2PhysTxqs[ptxq];
+		}
+	}
+
+	return MV_OK;
+}
+
+/* Allocate and initialize descriptors for Aggr TXQ */
+MV_STATUS mvPp2AggrTxqDescInit(MV_PP2_AGGR_TXQ_CTRL *txqCtrl, int descNum, int cpu)
+{
+	MV_STATUS status;
+	MV_PP2_QUEUE_CTRL *qCtrl = &txqCtrl->queueCtrl;
+
+	status = mvPp2DescrCreate(qCtrl, descNum);
+	if (status != MV_OK)
+		return status;
+
+	mvPp2DescRingReset(qCtrl);
+
+	/* Aggr TXQ no reset WA */
+	qCtrl->nextToProc = mvPp2RdReg(MV_PP2_AGGR_TXQ_INDEX_REG(cpu));
+
+	/* Set Tx descriptors queue starting address */
+	/* indirect access */
+	mvPp2WrReg(MV_PP2_AGGR_TXQ_DESC_ADDR_REG(cpu), pp2DescVirtToPhys(qCtrl, (MV_U8 *)qCtrl->pFirst));
+	mvPp2WrReg(MV_PP2_AGGR_TXQ_DESC_SIZE_REG(cpu), descNum & MV_PP2_AGGR_TXQ_DESC_SIZE_MASK);
+	/* RO - mvPp2WrReg(MV_PP2_AGGR_TXQ_INDEX_REG(cpu), 0); */
+
+	return MV_OK;
+}
+
+/* Allocate all aggregated TXQs.
+   This function must be called before any use of aggregated TXQ */
+MV_STATUS mvPp2AggrTxqsAlloc(int cpuNum)
+{
+	mvPp2AggrTxqs = mvOsMalloc(cpuNum * sizeof(MV_PP2_PHYS_TXQ_CTRL));
+	if (!mvPp2AggrTxqs) {
+		mvOsPrintf("mvPp2 Can't allocate %d Bytes for %d aggr TXQs control\n",
+			   cpuNum * sizeof(MV_PP2_PHYS_TXQ_CTRL), cpuNum);
+		return MV_OUT_OF_CPU_MEM;
+	}
+
+	return MV_OK;
+}
+
+/* Destroy all aggregated TXQs */
+MV_STATUS mvPp2AggrTxqsDestroy(MV_VOID)
+{
+/*TODO*/
+	return MV_OK;
+}
+
+/* Initialize aggregated TXQ */
+MV_PP2_AGGR_TXQ_CTRL *mvPp2AggrTxqInit(int cpu, int descNum)
+{
+	MV_STATUS status;
+
+	if (!mvPp2AggrTxqs)
+		return NULL;
+
+	/* Number of descriptors must be multiple of 16 */
+	if (descNum % 16 != 0) {
+		mvOsPrintf("Descriptor number %d, must be a multiple of 16\n", descNum);
+		return NULL;
+	}
+
+	mvPp2AggrTxqs[cpu].cpu = cpu;
+	status = mvPp2AggrTxqDescInit(&mvPp2AggrTxqs[cpu], descNum, cpu);
+	if (status != MV_OK) {
+		mvOsPrintf("mvPp2 failed to initialize descriptor ring for aggr TXQ %d\n", cpu);
+		return NULL;
+	}
+
+	return &mvPp2AggrTxqs[cpu];
+}
+
+MV_STATUS mvPp2TxDonePktsCoalSet(int port, int txp, int txq, MV_U32 pkts)
+{
+	MV_U32 regVal;
+	int ptxq = MV_PPV2_TXQ_PHYS(port, txp, txq);
+
+	regVal = (pkts << MV_PP2_TRANSMITTED_THRESH_OFFSET) & MV_PP2_TRANSMITTED_THRESH_MASK;
+	mvPp2WrReg(MV_PP2_TXQ_NUM_REG, ptxq);
+	mvPp2WrReg(MV_PP2_TXQ_THRESH_REG, regVal);
+
+	return MV_OK;
+}
+
+int mvPp2TxDonePktsCoalGet(int port, int txp, int txq)
+{
+	MV_U32 regVal;
+	int ptxq = MV_PPV2_TXQ_PHYS(port, txp, txq);
+
+	mvPp2WrReg(MV_PP2_TXQ_NUM_REG, ptxq);
+	regVal = mvPp2RdReg(MV_PP2_TXQ_THRESH_REG);
+
+	return (regVal & MV_PP2_TRANSMITTED_THRESH_MASK) >> MV_PP2_TRANSMITTED_THRESH_OFFSET;
+}
+
+/* Reset all TXQs */
+void mvPp2TxpReset(int port, int txp)
+{
+	int txq, ptxq;
+	MV_PP2_PHYS_TXQ_CTRL *pTxq;
+	MV_PP2_PORT_CTRL *pPortCtrl = mvPp2PortCtrl[port];
+
+	for (txq = 0; txq < pPortCtrl->txqNum; txq++) {
+		ptxq = MV_PPV2_TXQ_PHYS(port, txp, txq);
+		pTxq = &mvPp2PhysTxqs[ptxq];
+
+		mvPp2DescRingReset(&pTxq->queueCtrl);
+		mvPp2WrReg(MV_PP2_TXQ_NUM_REG, ptxq);
+		mvPp2WrReg(MV_PP2_TXQ_INDEX_REG, 0);
+	}
+}
+/*-------------------------------------------------------------------------------*/
+/* Port */
+/* Allocate and initialize port structure
+   Alocate an initialize TXQs for this port
+   Associate <numRxqs> RXQs for Port number <port>, starting from RXQ number <firstRxq>
+   Note: mvPp2PortCtrl must be initialized, i.e. must call mvPp2HalInit before this function */
+void *mvPp2PortInit(int port, int firstRxq, int numRxqs, void *osHandle)
+{
+	MV_STATUS status;
+	MV_PP2_PORT_CTRL *pCtrl;
+
+	if (mvPp2PortCheck(port)) {
+		mvOsPrintf("%s: Bad port number: %d\n", __func__, port);
+		return NULL;
+	}
+	if (!mvPp2PortCtrl) {
+		mvOsPrintf("%s: Port control is uninitialized\n", __func__);
+		return NULL;
+	}
+
+	if (!mvPp2PortCtrl[port])
+		mvPp2PortCtrl[port] = (MV_PP2_PORT_CTRL *)mvOsMalloc(sizeof(MV_PP2_PORT_CTRL));
+	if (!mvPp2PortCtrl[port]) {
+		mvOsPrintf("%s: Could not allocate %d bytes for port structure\n", __func__, sizeof(MV_PP2_PORT_CTRL));
+		return NULL;
+	}
+
+	mvOsMemset(mvPp2PortCtrl[port], 0, sizeof(MV_PP2_PORT_CTRL));
+
+	pCtrl = mvPp2PortCtrl[port];
+	pCtrl->portNo = port;
+	pCtrl->osHandle = osHandle;
+
+	/* associate TXQs to this port */
+	pCtrl->txpNum = MV_PON_PORT(port) ? CONFIG_MV_PON_TCONTS : 1;
+	pCtrl->txqNum = CONFIG_MV_ETH_TXQ;
+	status = mvPp2PortTxqsInit(port);
+	if (status != MV_OK)
+		return NULL;
+
+	/* associate RXQs to this port */
+	pCtrl->rxqNum = 0;
+	status = mvPp2PortRxqsInit(port, firstRxq, numRxqs);
+	if (status != MV_OK)
+		return NULL;
+
+	/* associate interrupt from relevant rxqs group to this port */
+	status = mvPp2GbeIsrRxqGroup(port, numRxqs);
+	if (status != MV_OK)
+		return NULL;
+
+	/* Disable port */
+	mvPp2PortDisable(port);
+	mvPp2DefaultsSet(port);
+
+	return pCtrl;
+}
+
+void mvPp2PortDestroy(int portNo)
+{
+/*TODO*/
+}
+
+/*******************************************************************************
+* mvPp2PortUp - Start the Ethernet port RX and TX activity.
+*
+* DESCRIPTION:
+*       This routine start Rx and Tx activity:
+*
+*       Note: Each Rx and Tx queue descriptor's list must be initialized prior
+*       to calling this function.
+*
+* INPUT:
+*		int     portNo		- Port number.
+*
+* RETURN:   MV_STATUS
+*           MV_OK - Success, Others - Failure.
+*
+*******************************************************************************/
+MV_STATUS mvPp2PortUp(int port)
+{
+	int queue, txp, txPortNum;
+	MV_U32 qMap;
+	MV_PP2_PORT_CTRL *pPortCtrl = mvPp2PortHndlGet(port);
+	MV_PP2_QUEUE_CTRL *pQueueCtrl;
+
+	mvEthMibCountersClear(port);
+
+	/* Enable all initialized TXs. */
+	for (txp = 0; txp < pPortCtrl->txpNum; txp++) {
+		txPortNum = mvPp2EgressPort(port, txp);
+
+		qMap = 0;
+		for (queue = 0; queue < pPortCtrl->txqNum; queue++) {
+			pQueueCtrl = &pPortCtrl->pTxQueue[txp * CONFIG_MV_ETH_TXQ + queue]->queueCtrl;
+
+			if (pQueueCtrl->pFirst != NULL)
+				qMap |= (1 << queue);
+		}
+
+		mvPp2WrReg(MV_PP2_TXP_SCHED_PORT_INDEX_REG, txPortNum);
+		mvPp2WrReg(MV_PP2_TXP_SCHED_Q_CMD_REG, qMap);
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvPp2PortDown - Stop the Ethernet port activity.
+*
+* DESCRIPTION:
+*
+* INPUT:
+*		int     portNo		- Port number.
+*
+* RETURN:   MV_STATUS
+*               MV_OK - Success, Others - Failure.
+*
+* NOTE : used for port link down.
+*******************************************************************************/
+MV_STATUS mvPp2PortDown(int port)
+{
+	int	          txp, txPortNum;
+	MV_PP2_PORT_CTRL *pPortCtrl = mvPp2PortHndlGet(port);
+	MV_U32 		  regData;
+	int 		  mDelay;
+
+	/* Stop Rx port activity. Check port Rx activity. */
+	/*TBD*/
+
+	if (!MV_PON_PORT(port)) {
+		/* Stop Tx port activity. Check port Tx activity. */
+		for (txp = 0; txp < pPortCtrl->txpNum; txp++) {
+			txPortNum = mvPp2EgressPort(port, txp);
+
+			/* Issue stop command for active channels only */
+			mvPp2WrReg(MV_PP2_TXP_SCHED_PORT_INDEX_REG, txPortNum);
+			regData = (mvPp2RdReg(MV_PP2_TXP_SCHED_Q_CMD_REG)) & MV_PP2_TXP_SCHED_ENQ_MASK;
+			if (regData != 0)
+				mvPp2WrReg(MV_PP2_TXP_SCHED_Q_CMD_REG, (regData << MV_PP2_TXP_SCHED_DISQ_OFFSET));
+
+			/* Wait for all Tx activity to terminate. */
+			mDelay = 0;
+			do {
+				if (mDelay >= TX_DISABLE_TIMEOUT_MSEC) {
+					mvOsPrintf("port=%d, txp=%d: TIMEOUT for TX stopped !!! txQueueCmd - 0x%08x\n",
+						   port, txp, regData);
+					break;
+				}
+				mvOsDelay(1);
+				mDelay++;
+
+				/* Check port TX Command register that all Tx queues are stopped */
+				regData = mvPp2RdReg(MV_PP2_TXP_SCHED_Q_CMD_REG);
+			} while (regData & 0xFF);
+		}
+
+		/* Double check to Verify that TX FIFO is Empty */
+		/*TBD*/
+	}
+	/* Wait about 200 usec */
+	mvOsUDelay(200);
+
+	return MV_OK;
+}
+
+MV_STATUS mvPp2PortEnable(int port)
+{
+	if (!MV_PON_PORT(port)) {
+		/* Enable port */
+		mvEthPortEnable(MV_PPV2_PORT_PHYS(port));
+
+		/* If Link is UP, Start RX and TX traffic */
+		if (mvEthPortIsLinkUp(MV_PPV2_PORT_PHYS(port)))
+			return mvPp2PortUp(port);
+	}
+	return MV_NOT_READY;
+}
+
+MV_STATUS mvPp2PortDisable(int port)
+{
+	mvPp2PortDown(port);
+
+	if (!MV_PON_PORT(port)) {
+		/* Reset the Enable bit in the Serial Control Register */
+		mvEthPortDisable(MV_PPV2_PORT_PHYS(port));
+	}
+	/* Wait about 200 usec */
+	mvOsUDelay(200);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+/* BM */
+MV_STATUS mvPp2BmPoolBufSizeSet(int pool, int bufsize)
+{
+	MV_U32 regVal;
+
+	mvBmPoolBufSizeSet(pool, bufsize);
+	regVal = MV_ALIGN_UP(bufsize, 1 << MV_PP2_POOL_BUF_SIZE_OFFSET);
+	mvPp2WrReg(MV_PP2_POOL_BUF_SIZE_REG(pool), regVal);
+
+	return MV_OK;
+}
+
+MV_STATUS mvPp2RxqBmPoolSet(int port, int rxq, int shortPool, int longPool)
+{
+	MV_U32 regVal = 0;
+	int prxq = mvPp2LogicRxqToPhysRxq(port, rxq);
+
+	regVal = mvPp2RdReg(MV_PP2_RXQ_CONFIG_REG(prxq));
+	regVal &= ~MV_PP2_RXQ_POOL_MASK;
+
+	regVal |= ((shortPool << MV_PP2_RXQ_POOL_SHORT_ID_OFFS) & MV_PP2_RXQ_POOL_SHORT_ID_MASK);
+	regVal |= ((longPool << MV_PP2_RXQ_POOL_LONG_ID_OFFS) & MV_PP2_RXQ_POOL_LONG_ID_MASK);
+
+	mvPp2WrReg(MV_PP2_RXQ_CONFIG_REG(prxq), regVal);
+
+	return MV_OK;
+}
+
+MV_STATUS mvPp2PortHwfBmPoolSet(int port, int shortPool, int longPool)
+{
+	MV_U32 regVal = 0;
+
+	regVal |= ((shortPool << MV_PP2_PORT_HWF_POOL_SHORT_ID_OFFS) & MV_PP2_PORT_HWF_POOL_SHORT_ID_MASK);
+	regVal |= ((longPool << MV_PP2_PORT_HWF_POOL_LONG_ID_OFFS) & MV_PP2_PORT_HWF_POOL_LONG_ID_MASK);
+
+	mvPp2WrReg(MV_PP2_PORT_HWF_CONFIG_REG(MV_PPV2_PORT_PHYS(port)), regVal);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+
+MV_STATUS mvPp2MhSet(int port, MV_PP2_MH_MODE mh)
+{
+	MV_U32 regVal;
+
+	regVal = mvPp2RdReg(MV_PP2_MH_REG(MV_PPV2_PORT_PHYS(port)));
+	/* Clear relevant fields */
+	regVal &= ~(MV_PP2_DSA_EN_MASK | MV_PP2_MH_EN_MASK);
+	switch (mh) {
+	case MV_PP2_MH_NONE:
+		break;
+
+	case MV_PP2_MH:
+		regVal |= MV_PP2_MH_EN_MASK;
+		break;
+
+	case MV_PP2_DSA:
+		regVal |= MV_PP2_DSA_EN_MASK;
+		break;
+
+	case MV_PP2_DSA_EXT:
+		regVal |= MV_PP2_DSA_EXTENDED;
+
+	default:
+		mvOsPrintf("port=%d: Unexpected MH = %d value\n", port, mh);
+		return MV_BAD_PARAM;
+	}
+	mvPp2WrReg(MV_PP2_MH_REG(MV_PPV2_PORT_PHYS(port)), regVal);
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+MV_STATUS mvPp2RxFifoInit(int portNum)
+{
+	int i, port;
+
+	for (i = 0; i < portNum; i++) {
+		port = MV_PPV2_PORT_PHYS(i);
+		mvPp2WrReg(MV_PP2_RX_DATA_FIFO_SIZE_REG(port), MV_PP2_RX_FIFO_PORT_DATA_SIZE);
+		mvPp2WrReg(MV_PP2_RX_ATTR_FIFO_SIZE_REG(port), MV_PP2_RX_FIFO_PORT_ATTR_SIZE);
+	}
+
+	mvPp2WrReg(MV_PP2_RX_MIN_PKT_SIZE_REG, MV_PP2_RX_FIFO_PORT_MIN_PKT);
+	mvPp2WrReg(MV_PP2_RX_FIFO_INIT_REG, 0x1);
+
+	return MV_OK;
+}
+
+/*-------------------------------------------------------------------------------*/
+/*******************************/
+/*       Interrupts API        */
+/*******************************/
+MV_VOID mvPp2GbeCpuInterruptsDisable(int port, int cpu)
+{
+	if ((cpu < 0) || mvPp2PortCheck(port))
+		return;
+
+	mvPp2WrReg(MV_PP2_ISR_ENABLE_REG(port), MV_PP2_ISR_DISABLE_INTERRUPT(cpu));
+}
+
+MV_VOID mvPp2GbeCpuInterruptsEnable(int port, int cpu)
+{
+	if ((cpu < 0) || mvPp2PortCheck(port))
+		return;
+	mvPp2WrReg(MV_PP2_ISR_ENABLE_REG(port), MV_PP2_ISR_ENABLE_INTERRUPT(cpu));
+}
+
+MV_STATUS mvPp2RxqTimeCoalSet(int port, int rxq, MV_U32 uSec)
+{
+	MV_U32 regVal;
+	int prxq = mvPp2LogicRxqToPhysRxq(port, rxq);
+
+	regVal = (mvPp2HalData.tClk / 1000000) * uSec;
+
+	mvPp2WrReg(MV_PP2_ISR_RX_THRESHOLD_REG(prxq), regVal);
+
+	return MV_OK;
+}
+
+int mvPp2RxqTimeCoalGet(int port, int rxq)
+{
+	MV_U32 regVal;
+	int prxq = mvPp2LogicRxqToPhysRxq(port, rxq);
+
+	regVal = mvPp2RdReg(MV_PP2_ISR_RX_THRESHOLD_REG(prxq));
+
+	regVal = (regVal * 1000000) / mvPp2HalData.tClk;
+
+
+	return regVal;
+}
+
+/* unmask the current CPU's rx/tx interrupts                   *
+ *  - rxq_mask: support rxq to cpu granularity                 *
+ *  - isTxDoneIsr: if 0 then Tx Done interruptare not unmasked */
+MV_STATUS mvPp2GbeIsrRxTxUnmask(int port, MV_U16 rxq_mask, int isTxDoneIsr)
+{
+	if (MV_PON_PORT(port)) {
+		mvPp2WrReg(MV_PP2_ISR_PON_RX_TX_MASK_REG,
+			(MV_PP2_PON_CAUSE_MISC_SUM_MASK |
+			((isTxDoneIsr) ? MV_PP2_PON_CAUSE_TXP_OCCUP_DESC_ALL_MASK : 0) |
+			(MV_PP2_PON_CAUSE_RXQ_OCCUP_DESC_ALL_MASK & rxq_mask)));
+	} else {
+		mvPp2WrReg(MV_PP2_ISR_RX_TX_MASK_REG(MV_PPV2_PORT_PHYS(port)),
+			(MV_PP2_CAUSE_MISC_SUM_MASK |
+			((isTxDoneIsr) ? MV_PP2_CAUSE_TXQ_OCCUP_DESC_ALL_MASK : 0) |
+			(MV_PP2_CAUSE_RXQ_OCCUP_DESC_ALL_MASK & rxq_mask)));
+	}
+
+	return MV_OK;
+}
+
+/* mask the current CPU's rx/tx interrupts */
+MV_STATUS mvPp2GbeIsrRxTxMask(int port)
+{
+	if (MV_PON_PORT(port))
+		mvPp2WrReg(MV_PP2_ISR_PON_RX_TX_MASK_REG, 0);
+	else
+		mvPp2WrReg(MV_PP2_ISR_RX_TX_MASK_REG(MV_PPV2_PORT_PHYS(port)), 0);
+
+	return MV_OK;
+}
+
+MV_STATUS mvPp2GbeIsrRxqGroup(int port, int rxqNum)
+{
+	if ((rxqNum % 4 != 0) || (rxqNum > MV_ETH_MAX_RXQ)) {
+		mvOsPrintf("%s: bad number of rxqs - %d.  Must be multiple of 4 and less than %d\n",
+			__func__, rxqNum, MV_ETH_MAX_RXQ);
+		return MV_BAD_PARAM;
+	}
+
+	mvPp2WrReg(MV_PP2_ISR_RXQ_GROUP_REG(port), rxqNum);
+
+	return MV_OK;
+}
+/*-------------------------------------------------------------------------------*/
+/* WRR / EJP configuration routines */
+/* Calculate period and tokens accordingly with required rate and accuracy */
+MV_STATUS mvPp2RateCalc(int rate, unsigned int accuracy, unsigned int *pPeriod, unsigned int *pTokens)
+{
+	/* Calculate refill tokens and period - rate [Kbps] = tokens [bits] * 1000 / period [usec] */
+	/* Assume:  Tclock [MHz] / BasicRefillNoOfClocks = 1 */
+	unsigned int period, tokens, calc;
+
+	if (rate == 0) {
+		/* Disable traffic from the port: tokens = 0 */
+		if (pPeriod != NULL)
+			*pPeriod = 1000;
+
+		if (pTokens != NULL)
+			*pTokens = 0;
+
+		return MV_OK;
+	}
+
+	/* Find values of "period" and "tokens" match "rate" and "accuracy" when period is minimal */
+	for (period = 1; period <= 1000; period++) {
+		tokens = 1;
+		while (MV_TRUE)	{
+			calc = (tokens * 1000) / period;
+			if (((MV_ABS(calc - rate) * 100) / rate) <= accuracy) {
+				if (pPeriod != NULL)
+					*pPeriod = period;
+
+				if (pTokens != NULL)
+					*pTokens = tokens;
+
+				return MV_OK;
+			}
+			if (calc > rate)
+				break;
+
+			tokens++;
+		}
+	}
+	return MV_FAIL;
+}
+
+/* Set bandwidth limitation for TX port
+ *   rate [Kbps]    - steady state TX bandwidth limitation
+ */
+MV_STATUS   mvPp2TxpRateSet(int port, int txp, int rate)
+{
+	MV_U32		regVal;
+	unsigned int	tokens, period, txPortNum, accuracy = 0;
+	MV_STATUS	status;
+
+	if (mvPp2TxpCheck(port, txp))
+		return MV_BAD_PARAM;
+
+	txPortNum = mvPp2EgressPort(port, txp);
+	mvPp2WrReg(MV_PP2_TXP_SCHED_PORT_INDEX_REG, txPortNum);
+
+	regVal = mvPp2RdReg(MV_PP2_TXP_SCHED_PERIOD_REG);
+
+	status = mvPp2RateCalc(rate, accuracy, &period, &tokens);
+	if (status != MV_OK) {
+		mvOsPrintf("%s: Can't provide rate of %d [Kbps] with accuracy of %d [%%]\n",
+				__func__, rate, accuracy);
+		return status;
+	}
+	if (tokens > MV_PP2_TXP_REFILL_TOKENS_MAX)
+		tokens = MV_PP2_TXP_REFILL_TOKENS_MAX;
+
+	if (period > MV_PP2_TXP_REFILL_PERIOD_MAX)
+		period = MV_PP2_TXP_REFILL_PERIOD_MAX;
+
+	regVal = mvPp2RdReg(MV_PP2_TXP_SCHED_REFILL_REG);
+
+	regVal &= ~MV_PP2_TXP_REFILL_TOKENS_ALL_MASK ;
+	regVal |= MV_PP2_TXP_REFILL_TOKENS_MASK(tokens);
+
+	regVal &= ~MV_PP2_TXP_REFILL_PERIOD_ALL_MASK;
+	regVal |= MV_PP2_TXP_REFILL_PERIOD_MASK(period);
+
+	mvPp2WrReg(MV_PP2_TXP_SCHED_REFILL_REG, regVal);
+
+	return MV_OK;
+}
+
+/* Set maximum burst size for TX port
+ *   burst [bytes] - number of bytes to be sent with maximum possible TX rate,
+ *                    before TX rate limitation will take place.
+ */
+MV_STATUS mvPp2TxpBurstSet(int port, int txp, int burst)
+{
+	MV_U32  size, mtu;
+	int txPortNum;
+
+	if (mvPp2TxpCheck(port, txp))
+		return MV_BAD_PARAM;
+
+	txPortNum = mvPp2EgressPort(port, txp);
+	mvPp2WrReg(MV_PP2_TXP_SCHED_PORT_INDEX_REG, txPortNum);
+
+	/* Calulate Token Bucket Size */
+	size = 8 * burst;
+
+	if (size > MV_PP2_TXP_TOKEN_SIZE_MAX)
+		size = MV_PP2_TXP_TOKEN_SIZE_MAX;
+
+	/* Token bucket size must be larger then MTU */
+	mtu = mvPp2RdReg(MV_PP2_TXP_SCHED_TOKEN_SIZE_REG);
+	if (mtu > size) {
+		mvOsPrintf("%s Error: Bucket size (%d bytes) < MTU (%d bytes)\n",
+					__func__, (size / 8), (mtu / 8));
+		return MV_BAD_PARAM;
+	}
+	mvPp2WrReg(MV_PP2_TXP_SCHED_TOKEN_SIZE_REG, size);
+
+	return MV_OK;
+}
+
+/* Set bandwidth limitation for TXQ
+ *   rate  [Kbps]  - steady state TX rate limitation
+ */
+MV_STATUS   mvPp2TxqRateSet(int port, int txp, int txq, int rate)
+{
+	MV_U32		regVal;
+	unsigned int	txPortNum, period, tokens, accuracy = 0;
+	MV_STATUS	status;
+
+	if (mvPp2TxpCheck(port, txp))
+		return MV_BAD_PARAM;
+
+	if (txq >= MV_ETH_MAX_TXQ)
+		return MV_BAD_PARAM;
+
+	status = mvPp2RateCalc(rate, accuracy, &period, &tokens);
+	if (status != MV_OK) {
+		mvOsPrintf("%s: Can't provide rate of %d [Kbps] with accuracy of %d [%%]\n",
+				__func__, rate, accuracy);
+		return status;
+	}
+
+	txPortNum = mvPp2EgressPort(port, txp);
+	mvPp2WrReg(MV_PP2_TXP_SCHED_PORT_INDEX_REG, txPortNum);
+
+	if (tokens > MV_PP2_TXQ_REFILL_TOKENS_MAX)
+		tokens = MV_PP2_TXQ_REFILL_TOKENS_MAX;
+
+	if (period > MV_PP2_TXQ_REFILL_PERIOD_MAX)
+		period = MV_PP2_TXQ_REFILL_PERIOD_MAX;
+
+	regVal = mvPp2RdReg(MV_PP2_TXQ_SCHED_REFILL_REG(txq));
+
+	regVal &= ~MV_PP2_TXQ_REFILL_TOKENS_ALL_MASK;
+	regVal |= MV_PP2_TXQ_REFILL_TOKENS_MASK(tokens);
+
+	regVal &= ~MV_PP2_TXQ_REFILL_PERIOD_ALL_MASK;
+	regVal |= MV_PP2_TXQ_REFILL_PERIOD_MASK(period);
+
+	mvPp2WrReg(MV_PP2_TXQ_SCHED_REFILL_REG(txq), regVal);
+
+	return MV_OK;
+}
+
+/* Set maximum burst size for TX port
+ *   burst [bytes] - number of bytes to be sent with maximum possible TX rate,
+ *                    before TX bandwidth limitation will take place.
+ */
+MV_STATUS mvPp2TxqBurstSet(int port, int txp, int txq, int burst)
+{
+	MV_U32  size, mtu;
+	int txPortNum;
+
+	if (mvPp2TxpCheck(port, txp))
+		return MV_BAD_PARAM;
+
+	if (txq >= MV_ETH_MAX_TXQ)
+		return MV_BAD_PARAM;
+
+	txPortNum = mvPp2EgressPort(port, txp);
+	mvPp2WrReg(MV_PP2_TXP_SCHED_PORT_INDEX_REG, txPortNum);
+
+	/* Calulate Tocket Bucket Size */
+	size = 8 * burst;
+
+	if (size > MV_PP2_TXQ_TOKEN_SIZE_MAX)
+		size = MV_PP2_TXQ_TOKEN_SIZE_MAX;
+
+	/* Tocken bucket size must be larger then MTU */
+	mtu = mvPp2RdReg(MV_PP2_TXP_SCHED_MTU_REG);
+	if (mtu > size) {
+		mvOsPrintf("%s Error: Bucket size (%d bytes) < MTU (%d bytes)\n",
+					__func__, (size / 8), (mtu / 8));
+		return MV_BAD_PARAM;
+	}
+
+	mvPp2WrReg(MV_PP2_TXQ_SCHED_TOKEN_SIZE_REG(txq), size);
+
+	return MV_OK;
+}
+
+/* Set TXQ to work in FIX priority mode */
+MV_STATUS mvPp2TxqFixPrioSet(int port, int txp, int txq)
+{
+	MV_U32 regVal;
+	int txPortNum;
+
+	if (mvPp2TxpCheck(port, txp))
+		return MV_BAD_PARAM;
+
+	if (txq >= MV_ETH_MAX_TXQ)
+		return MV_BAD_PARAM;
+
+	txPortNum = mvPp2EgressPort(port, txp);
+	mvPp2WrReg(MV_PP2_TXP_SCHED_PORT_INDEX_REG, txPortNum);
+
+	regVal = mvPp2RdReg(MV_PP2_TXP_SCHED_FIXED_PRIO_REG);
+	regVal |= (1 << txq);
+	mvPp2WrReg(MV_PP2_TXP_SCHED_FIXED_PRIO_REG, regVal);
+
+	return MV_OK;
+}
+
+/* Set TXQ to work in WRR mode and set relative weight. */
+/*   Weight range [1..N] */
+MV_STATUS mvPp2TxqWrrPrioSet(int port, int txp, int txq, int weight)
+{
+	MV_U32 regVal, mtu;
+	int txPortNum;
+
+	if (mvPp2TxpCheck(port, txp))
+		return MV_BAD_PARAM;
+
+	if (txq >= MV_ETH_MAX_TXQ)
+		return MV_BAD_PARAM;
+
+	txPortNum = mvPp2EgressPort(port, txp);
+	mvPp2WrReg(MV_PP2_TXP_SCHED_PORT_INDEX_REG, txPortNum);
+
+	/* Weight * 256 bytes * 8 bits must be larger then MTU [bits] */
+	mtu = mvPp2RdReg(MV_PP2_TXP_SCHED_MTU_REG);
+	/* MTU [bits] -> MTU [256 bytes] */
+	mtu = ((mtu / 8) / 256) + 1;
+
+	if ((weight < mtu) || (weight > MV_PP2_TXQ_WRR_WEIGHT_MAX)) {
+		mvOsPrintf("%s Error: weight=%d is out of range %d...%d\n",
+				__func__, weight, mtu, MV_PP2_TXQ_WRR_WEIGHT_MAX);
+		return MV_FAIL;
+	}
+
+	regVal = mvPp2RdReg(MV_PP2_TXQ_SCHED_WRR_REG(txq));
+
+	regVal &= ~MV_PP2_TXQ_WRR_WEIGHT_ALL_MASK;
+	regVal |= MV_PP2_TXQ_WRR_WEIGHT_MASK(weight);
+	mvPp2WrReg(MV_PP2_TXQ_SCHED_WRR_REG(txq), regVal);
+
+	regVal = mvPp2RdReg(MV_PP2_TXP_SCHED_FIXED_PRIO_REG);
+	regVal &= ~(1 << txq);
+	mvPp2WrReg(MV_PP2_TXP_SCHED_FIXED_PRIO_REG, regVal);
+
+	return MV_OK;
+}
+
+/* Set minimum number of tockens to start transmit for TX port
+ *   maxTxSize [bytes]    - maximum packet size can be sent via this TX port
+ */
+MV_STATUS   mvPp2TxpMaxTxSizeSet(int port, int txp, int maxTxSize)
+{
+	MV_U32	regVal, size, mtu;
+	int	txq, txPortNum;
+
+	if (mvPp2TxpCheck(port, txp))
+		return MV_BAD_PARAM;
+
+	mtu = maxTxSize * 8;
+	if (mtu > MV_PP2_TXP_MTU_MAX)
+		mtu = MV_PP2_TXP_MTU_MAX;
+
+	txPortNum = mvPp2EgressPort(port, txp);
+
+	mvPp2WrReg(MV_PP2_TXP_SCHED_PORT_INDEX_REG, txPortNum);
+	/* set MTU */
+	regVal = mvPp2RdReg(MV_PP2_TXP_SCHED_MTU_REG);
+	regVal &= ~MV_PP2_TXP_MTU_ALL_MASK;
+	regVal |= MV_PP2_TXP_MTU_MASK(mtu);
+
+	mvPp2WrReg(MV_PP2_TXP_SCHED_MTU_REG, regVal);
+
+	/* TXP token size and all TXQs token size must be larger that MTU */
+	regVal = mvPp2RdReg(MV_PP2_TXP_SCHED_TOKEN_SIZE_REG);
+	size = regVal & MV_PP2_TXP_TOKEN_SIZE_MAX;
+	if (size < mtu) {
+		size = mtu;
+		regVal &= ~MV_PP2_TXP_TOKEN_SIZE_MAX;
+		regVal |= size;
+		mvPp2WrReg(MV_PP2_TXP_SCHED_TOKEN_SIZE_REG, regVal);
+	}
+	for (txq = 0; txq < CONFIG_MV_ETH_TXQ; txq++) {
+		regVal = mvPp2RdReg(MV_PP2_TXQ_SCHED_REFILL_REG(txq));
+		size = regVal & MV_PP2_TXQ_TOKEN_SIZE_MAX;
+		if (size < mtu) {
+			size = mtu;
+			regVal &= ~MV_PP2_TXQ_TOKEN_SIZE_MAX;
+			regVal |= size;
+			mvPp2WrReg(MV_PP2_TXQ_SCHED_REFILL_REG(txq), regVal);
+		}
+	}
+	return MV_OK;
+}
diff --git a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.h b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.h
new file mode 100644
index 0000000..ea04a98
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.h
@@ -0,0 +1,616 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_PP2_GBE_H__
+#define __MV_PP2_GBE_H__
+
+#include "mvTypes.h"
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "mvSysEthConfig.h"
+#include "mvPp2GbeRegs.h"
+#include "pp2/gmac/mvEthGmacApi.h"
+#include "pp2/common/mvPp2Common.h"
+
+
+/************************** PPv2 HW Configuration ***********************/
+typedef struct eth_pbuf {
+	void *osInfo;
+	MV_ULONG physAddr;
+	MV_U8 *pBuf;
+	MV_U16 bytes;
+	MV_U16 offset;
+	MV_U8  pool;
+	MV_U8  reserved;
+	MV_U16 vlanId;
+} MV_ETH_PKT;
+
+typedef enum {
+	MV_PP2_MH_NONE = 0,
+	MV_PP2_MH = 1,
+	MV_PP2_DSA = 2,
+	MV_PP2_DSA_EXT = 3
+} MV_PP2_MH_MODE;
+
+/************************** Port + Queue Control Structures ******************************/
+typedef struct {
+	char *pFirst;
+	int lastDesc;
+	int nextToProc;
+	int descSize;
+	MV_BUF_INFO descBuf;
+} MV_PP2_QUEUE_CTRL;
+
+#define MV_PP2_QUEUE_DESC_PTR(pQueueCtrl, descIdx)                 \
+    ((pQueueCtrl)->pFirst + ((descIdx) * MV_PP2_DESC_ALIGNED_SIZE))
+
+#define MV_PP2_QUEUE_NEXT_DESC(pQueueCtrl, descIdx)  \
+    (((descIdx) < (pQueueCtrl)->lastDesc) ? ((descIdx) + 1) : 0)
+
+#define MV_PP2_QUEUE_PREV_DESC(pQueueCtrl, descIdx)  \
+    (((descIdx) > 0) ? ((descIdx) - 1) : (pQueueCtrl)->lastDesc)
+
+/*-------------------------------------------------------------------------------*/
+/* TXQ */
+typedef struct {
+	MV_PP2_QUEUE_CTRL queueCtrl;
+	int txq;
+} MV_PP2_PHYS_TXQ_CTRL;
+
+typedef struct {
+	MV_PP2_QUEUE_CTRL queueCtrl;
+	int cpu;
+} MV_PP2_AGGR_TXQ_CTRL;
+
+/* physical TXQs */
+extern MV_PP2_PHYS_TXQ_CTRL *mvPp2PhysTxqs;
+
+/* aggregated TXQs */
+extern MV_PP2_AGGR_TXQ_CTRL *mvPp2AggrTxqs;
+
+/*-------------------------------------------------------------------------------*/
+/* RXQ */
+
+typedef struct {
+	MV_PP2_QUEUE_CTRL queueCtrl;
+	int rxq;
+	int port;
+	int logicRxq;
+} MV_PP2_PHYS_RXQ_CTRL;
+
+/* physical RXQs */
+extern MV_PP2_PHYS_RXQ_CTRL *mvPp2PhysRxqs;
+
+/*-------------------------------------------------------------------------------*/
+/* Port */
+typedef struct {
+	int portNo;
+	MV_PP2_PHYS_RXQ_CTRL **pRxQueue;
+	MV_PP2_PHYS_TXQ_CTRL **pTxQueue;
+	int rxqNum;
+	int txpNum;
+	int txqNum;
+	void *osHandle;
+} MV_PP2_PORT_CTRL;
+
+/* ports control */
+extern MV_PP2_PORT_CTRL **mvPp2PortCtrl;
+
+/*-------------------------------------------------------------------------------*/
+/* HW data */
+typedef struct {
+	MV_U32 maxPort;
+	MV_U32 maxTcont;
+	MV_U32 aggrTxqSize;
+	MV_U32 physTxqHwfSize;
+	MV_U32 maxCPUs;
+	MV_U32 portMask;
+	MV_U32 cpuMask;
+	MV_U32 pClk;
+	MV_U32 tClk;
+	MV_BOOL	iocc;
+	MV_U16 ctrlModel;       /* Controller Model     */
+	MV_U8  ctrlRev;         /* Controller Revision  */
+} MV_PP2_HAL_DATA;
+
+extern MV_PP2_HAL_DATA mvPp2HalData;
+
+/************************** RXQ: Physical - Logical Mapping ******************************/
+static INLINE int mvPp2PhysRxqToPort(int prxq)
+{
+	return mvPp2PhysRxqs[prxq].port;
+}
+
+static INLINE int mvPp2PhysRxqToLogicRxq(int prxq)
+{
+	return mvPp2PhysRxqs[prxq].logicRxq;
+}
+
+static INLINE int mvPp2LogicRxqToPhysRxq(int port, int rxq)
+{
+	if (mvPp2PortCtrl[port]->pRxQueue[rxq])
+		return mvPp2PortCtrl[port]->pRxQueue[rxq]->rxq;
+	return -1;
+}
+
+
+/************************** TXQ: Physical - Logical Mapping ******************************/
+#ifdef CONFIG_MV_PON
+
+#define MV_PON_LOGIC_PORT_GET()			(mvPp2HalData.maxPort - 1)
+#define MV_PON_PORT(p)				((p) == MV_PON_LOGIC_PORT_GET())
+#define MV_PON_PHYS_PORT_GET()			MV_PON_PORT_ID
+#define MV_PON_PHYS_PORT(p)			((p) == MV_PON_PORT_ID)
+#define MV_PP2_TOTAL_TXP_NUM			(MV_ETH_MAX_TCONT + MV_ETH_MAX_PORTS - 1)
+#define MV_PP2_TOTAL_PON_TXQ_NUM		(MV_ETH_MAX_TCONT * MV_ETH_MAX_TXQ)
+
+#define MV_PPV2_PORT_PHYS(port)			((MV_PON_PORT(port)) ? MV_PON_PHYS_PORT_GET() : (port))
+#define MV_PPV2_TXP_PHYS(port, txp)		((MV_PON_PORT(port)) ? txp : (MV_ETH_MAX_TCONT + port))
+#define MV_PPV2_TXQ_PHYS(port, txp, txq)	((MV_PON_PORT(port)) ? txp * MV_ETH_MAX_TXQ + txq :\
+											MV_PP2_TOTAL_PON_TXQ_NUM + port * MV_ETH_MAX_TXQ + txq)
+
+#define MV_PPV2_TXQ_LOGICAL_PORT(physTxq)	((physTxq < MV_PP2_TOTAL_PON_TXQ_NUM) ? MV_PON_LOGIC_PORT_ID_GET() :\
+							(physTxq - MV_PP2_TOTAL_PON_TXQ_NUM) / MV_ETH_MAX_TXQ)
+
+#define MV_PPV2_TXQ_LOGICAL_TXP(physTxq)	((physTxq < MV_PP2_TOTAL_PON_TXQ_NUM) ? (physTxq / MV_ETH_MAX_TXQ) : 0)
+
+#else /* Without PON */
+
+#define MV_PON_PORT(p)				MV_FALSE
+#define MV_PON_PHYS_PORT(p)			MV_FALSE
+#define MV_PP2_TOTAL_TXP_NUM			(MV_ETH_MAX_PORTS)
+
+#define MV_PPV2_PORT_PHYS(port)                 (port)
+#define MV_PPV2_TXP_PHYS(port, txp)		(port)
+#define MV_PPV2_TXQ_PHYS(port, txp, txq)	(port * MV_ETH_MAX_TXQ + txq)
+#define MV_PPV2_TXQ_LOGICAL_PORT(physTxq)	(physTxq / MV_ETH_MAX_TXQ)
+#define MV_PPV2_TXQ_LOGICAL_TXP(physTxq)	0
+
+#endif /* CONFIG_MV_PON */
+
+#define MV_PPV2_TXQ_LOGICAL_TXQ(physTxq)	(physTxq % MV_ETH_MAX_TXQ)
+#define MV_PP2_TXQ_TOTAL_NUM			(MV_PP2_TOTAL_TXP_NUM * MV_ETH_MAX_TXQ)
+
+/************************** Data Path functions ******************************/
+/* Set TXQ descriptors fields relevant for CSUM calculation */
+static INLINE MV_U32 mvPp2TxqDescCsum(int l3_offs, int l3_proto, int ip_hdr_len, int l4_proto)
+{
+	MV_U32 command;
+
+	/* fields: L3_offset, IP_hdrlen, L3_type, G_IPv4_chk, G_L4_chk, L4_type */
+	/* required only for checksum calculation */
+	command = (l3_offs << PP2_TX_L3_OFFSET_OFFS);
+	command |= (ip_hdr_len << PP2_TX_IP_HLEN_OFFS);
+	command |= PP2_TX_IP_CSUM_DISABLE_MASK;
+
+	if (l3_proto == MV_16BIT_BE(MV_IP_TYPE)) {
+		command &= ~PP2_TX_IP_CSUM_DISABLE_MASK; /* enable IP CSUM */
+		command |= PP2_TX_L3_IP4;
+	} else
+		command |= PP2_TX_L3_IP6;
+
+	if (l4_proto == MV_IP_PROTO_TCP)
+		command |= (PP2_TX_L4_TCP | PP2_TX_L4_CSUM);
+	else if (l4_proto == MV_IP_PROTO_UDP)
+		command |= (PP2_TX_L4_UDP | PP2_TX_L4_CSUM);
+	else
+		command |= PP2_TX_L4_CSUM_NOT;
+
+	return command;
+}
+
+/* Get Giga port handler */
+static INLINE MV_PP2_PORT_CTRL *mvPp2PortHndlGet(int port)
+{
+	return mvPp2PortCtrl[port];
+}
+
+/* Get physical RX queue handler */
+static INLINE MV_PP2_PHYS_RXQ_CTRL *mvPp2RxqHndlGet(int port, int rxq)
+{
+	return mvPp2PortCtrl[port]->pRxQueue[rxq];
+}
+
+/* Get physical TX queue handler */
+static INLINE MV_PP2_PHYS_TXQ_CTRL *mvPp2TxqHndlGet(int port, int txp, int txq)
+{
+	MV_PP2_PORT_CTRL *pPortCtrl = mvPp2PortCtrl[port];
+
+	return pPortCtrl->pTxQueue[txp * pPortCtrl->txqNum + txq];
+}
+
+/* Get Aggregated TX queue handler */
+static INLINE MV_PP2_AGGR_TXQ_CTRL *mvPp2AggrTxqHndlGet(int cpu)
+{
+	return &mvPp2AggrTxqs[cpu];
+}
+
+
+/* Get pointer to next RX descriptor to be processed by SW */
+static INLINE PP2_RX_DESC *mvPp2RxqNextDescGet(MV_PP2_PHYS_RXQ_CTRL *pRxq)
+{
+	PP2_RX_DESC	*pRxDesc;
+	int		rxDesc = pRxq->queueCtrl.nextToProc;
+
+	pRxq->queueCtrl.nextToProc = MV_PP2_QUEUE_NEXT_DESC(&(pRxq->queueCtrl), rxDesc);
+
+	pRxDesc = ((PP2_RX_DESC *)pRxq->queueCtrl.pFirst) + rxDesc;
+
+	return pRxDesc;
+}
+
+static INLINE PP2_RX_DESC *mvPp2RxqDescGet(MV_PP2_PHYS_RXQ_CTRL *pRxq)
+{
+	PP2_RX_DESC	*pRxDesc;
+
+	pRxDesc = ((PP2_RX_DESC *)pRxq->queueCtrl.pFirst) + pRxq->queueCtrl.nextToProc;
+
+	return pRxDesc;
+}
+
+/*-------------------------------------------------------------------------------*/
+/* Get number of RX descriptors occupied by received packets */
+static INLINE int mvPp2RxqBusyDescNumGet(int port, int rxq)
+{
+	MV_U32 regVal;
+	int prxq = mvPp2LogicRxqToPhysRxq(port, rxq);
+	if (prxq < 0)
+		return prxq;
+
+	regVal = mvPp2RdReg(MV_PP2_RXQ_STATUS_REG(prxq));
+
+	return (regVal & MV_PP2_RXQ_OCCUPIED_MASK) >> MV_PP2_RXQ_OCCUPIED_OFFSET;
+}
+
+/* Get number of free RX descriptors ready to received new packets */
+static INLINE int mvPp2RxqFreeDescNumGet(int port, int rxq)
+{
+	MV_U32 regVal;
+	int prxq = mvPp2LogicRxqToPhysRxq(port, rxq);
+	if (prxq < 0)
+		return prxq;
+
+	regVal = mvPp2RdReg(MV_PP2_RXQ_STATUS_REG(prxq));
+
+	return (regVal & MV_PP2_RXQ_NON_OCCUPIED_MASK) >> MV_PP2_RXQ_NON_OCCUPIED_OFFSET;
+}
+
+/* Update HW with number of RX descriptors processed by SW:
+ *    - decrement number of occupied descriptors
+ *    - increment number of Non-occupied descriptors
+ */
+static INLINE void mvPp2RxqDescNumUpdate(int port, int rxq, int rx_done, int rx_filled)
+{
+	MV_U32 regVal;
+	int prxq = mvPp2LogicRxqToPhysRxq(port, rxq);
+
+	regVal = (rx_done << MV_PP2_RXQ_NUM_PROCESSED_OFFSET) | (rx_filled << MV_PP2_RXQ_NUM_NEW_OFFSET);
+	mvPp2WrReg(MV_PP2_RXQ_STATUS_UPDATE_REG(prxq), regVal);
+}
+
+/* Add number of descriptors are ready to receive new packets */
+static INLINE void mvPp2RxqNonOccupDescAdd(int port, int rxq, int rx_desc)
+{
+	MV_U32	regVal;
+	int prxq = mvPp2LogicRxqToPhysRxq(port, rxq);
+
+	regVal = (rx_desc << MV_PP2_RXQ_NUM_NEW_OFFSET);
+	mvPp2WrReg(MV_PP2_RXQ_STATUS_UPDATE_REG(prxq), regVal);
+}
+
+/*-------------------------------------------------------------------------------*/
+/* Get number of TXQ descriptors waiting to be transmitted by HW */
+static INLINE int mvPp2TxqPendDescNumGet(int port, int txp, int txq)
+{
+	MV_U32 regVal, ptxq;
+
+	ptxq = MV_PPV2_TXQ_PHYS(port, txp, txq);
+	mvPp2WrReg(MV_PP2_TXQ_NUM_REG, ptxq);
+
+	regVal = mvPp2RdReg(MV_PP2_TXQ_PENDING_REG);
+
+	return (regVal & MV_PP2_TXQ_PENDING_MASK) >> MV_PP2_TXQ_PENDING_OFFSET;
+}
+
+/* Get number of TXQ HWF descriptors waiting to be transmitted by HW */
+static INLINE int mvPp2TxqPendHwfDescNumGet(int port, int txp, int txq)
+{
+	MV_U32 regVal, ptxq;
+
+	ptxq = MV_PPV2_TXQ_PHYS(port, txp, txq);
+	mvPp2WrReg(MV_PP2_TXQ_NUM_REG, ptxq);
+
+	regVal = mvPp2RdReg(MV_PP2_TXQ_PENDING_REG);
+
+	return (regVal & MV_PP2_TXQ_HWF_PENDING_MASK) >> MV_PP2_TXQ_HWF_PENDING_OFFSET;
+}
+
+/* Get next aggregated TXQ descriptor */
+static INLINE PP2_TX_DESC *mvPp2AggrTxqNextDescGet(MV_PP2_AGGR_TXQ_CTRL *pTxq)
+{
+	PP2_TX_DESC	*pTxDesc;
+	int		txDesc = pTxq->queueCtrl.nextToProc;
+
+	pTxq->queueCtrl.nextToProc = MV_PP2_QUEUE_NEXT_DESC(&(pTxq->queueCtrl), txDesc);
+
+	pTxDesc = ((PP2_TX_DESC *)pTxq->queueCtrl.pFirst) + txDesc;
+
+	return pTxDesc;
+}
+
+/* Get pointer to previous aggregated TX descriptor for rollback when needed */
+static INLINE PP2_TX_DESC *mvPp2AggrTxqPrevDescGet(MV_PP2_AGGR_TXQ_CTRL *pTxq)
+{
+	int txDesc = pTxq->queueCtrl.nextToProc;
+
+	pTxq->queueCtrl.nextToProc = MV_PP2_QUEUE_PREV_DESC(&(pTxq->queueCtrl), txDesc);
+
+	return ((PP2_TX_DESC *) pTxq->queueCtrl.pFirst) + txDesc;
+}
+
+/* Get number of aggregated TXQ descriptors didn't send by HW to relevant physical TXQ */
+static INLINE int mvPp2AggrTxqPendDescNumGet(int cpu)
+{
+	MV_U32 regVal;
+
+	regVal = mvPp2RdReg(MV_PP2_AGGR_TXQ_STATUS_REG(cpu));
+
+	return (regVal & MV_PP2_AGGR_TXQ_PENDING_MASK) >> MV_PP2_AGGR_TXQ_PENDING_OFFSET;
+}
+
+/* Update HW with number of Aggr-TX descriptors to be sent - user responsible for writing TXQ in TX descriptor */
+static INLINE void mvPp2AggrTxqPendDescAdd(int pending)
+{
+	/* aggregated access - relevant TXQ number is written in TX descriptor */
+	mvPp2WrReg(MV_PP2_AGGR_TXQ_UPDATE_REG, pending);
+}
+
+/* Get number of sent descriptors and descrement counter.
+   Clear sent descriptor counter.
+   Number of sent descriptors is returned. */
+static INLINE int mvPp2TxqSentDescProc(int port, int txp, int txq)
+{
+	MV_U32  regVal, ptxq;
+
+	ptxq = MV_PPV2_TXQ_PHYS(port, txp, txq);
+	/* reading status reg also cause to reset transmitted counter */
+	regVal = mvPp2RdReg(MV_PP2_TXQ_SENT_REG(ptxq));
+
+	return (regVal & MV_PP2_TRANSMITTED_COUNT_MASK) >> MV_PP2_TRANSMITTED_COUNT_OFFSET;
+}
+
+/*-------------------------------------------------------------------------------*/
+
+static INLINE MV_U32 mvPp2GbeIsrCauseRxTxGet(int port)
+{
+	MV_U32 val;
+
+	if (MV_PON_PORT(port)) {
+		val = mvPp2RdReg(MV_PP2_ISR_PON_RX_TX_CAUSE_REG);
+		val &= (MV_PP2_PON_CAUSE_RXQ_OCCUP_DESC_ALL_MASK |
+			MV_PP2_PON_CAUSE_TXP_OCCUP_DESC_ALL_MASK | MV_PP2_PON_CAUSE_MISC_ERR_SUM_MASK);
+	} else {
+		val = mvPp2RdReg(MV_PP2_ISR_RX_TX_CAUSE_REG(MV_PPV2_PORT_PHYS(port)));
+		val &= (MV_PP2_CAUSE_RXQ_OCCUP_DESC_ALL_MASK |
+			MV_PP2_CAUSE_TXQ_OCCUP_DESC_ALL_MASK | MV_PP2_CAUSE_MISC_ERR_SUM_MASK);
+	}
+
+	return val;
+}
+
+static INLINE MV_BOOL mvPp2GbeIsrCauseTxDoneIsSet(int port, MV_U32 causeRxTx)
+{
+	if (MV_PON_PORT(port))
+		return (causeRxTx & MV_PP2_PON_CAUSE_TXP_OCCUP_DESC_ALL_MASK);
+
+	return (causeRxTx & MV_PP2_CAUSE_TXQ_OCCUP_DESC_ALL_MASK);
+}
+
+static INLINE MV_U32 mvPp2GbeIsrCauseTxDoneOffset(int port, MV_U32 causeRxTx)
+{
+	if (MV_PON_PORT(port))
+		return (causeRxTx & MV_PP2_PON_CAUSE_TXP_OCCUP_DESC_ALL_MASK);
+
+	return (causeRxTx & MV_PP2_CAUSE_TXQ_OCCUP_DESC_ALL_MASK);
+}
+/************************** function declaration ******************************/
+MV_STATUS 	mvPp2WinInit(MV_U32 dummy/*backward compability*/,   MV_UNIT_WIN_INFO *addrWinMap);
+MV_STATUS 	mvPp2WinWrite(MV_U32 dummy/*backward compability*/,  MV_U32 winNum, MV_UNIT_WIN_INFO *pAddrDecWin);
+MV_STATUS 	mvPp2WinRead(MV_U32 dummy/*backward compability*/,   MV_U32 winNum, MV_UNIT_WIN_INFO *pAddrDecWin);
+MV_STATUS 	mvPp2WinEnable(MV_U32 dummy/*backward compability*/, MV_U32 winNum, MV_BOOL enable);
+
+int mvPp2MaxCheck(int value, int limit, char *name);
+int mvPp2PortCheck(int port);
+int mvPp2TxpCheck(int port, int txp);
+int mvPp2CpuCheck(int cpu);
+
+static INLINE MV_ULONG pp2DescVirtToPhys(MV_PP2_QUEUE_CTRL *pQueueCtrl, MV_U8 *pDesc)
+{
+	return (pQueueCtrl->descBuf.bufPhysAddr + (pDesc - pQueueCtrl->descBuf.bufVirtPtr));
+}
+
+MV_STATUS mvPp2HalInit(MV_PP2_HAL_DATA *halData);
+
+/* Add a mapping prxq <-> (port, lrxq) */
+MV_STATUS mvPp2PhysRxqMapAdd(int prxq, int port, int lrxq);
+/* Free the relevant physical rxq */
+MV_STATUS mvPp2PhysRxqMapDel(int prxq);
+MV_STATUS mvPp2PortLogicRxqMapDel(int port, int lrxq);
+
+/* Allocate and initialize descriptors for RXQ */
+MV_PP2_PHYS_RXQ_CTRL *mvPp2RxqInit(int port, int rxq, int descNum);
+void mvPp2RxqDelete(int port, int queue);
+
+/* Allocate and initialize all physical RXQs.
+   This function must be called before any use of RXQ */
+MV_STATUS mvPp2PhysRxqsAlloc(MV_VOID);
+
+/* Destroy all physical RXQs */
+MV_STATUS mvPp2PhysRxqsDestroy(MV_VOID);
+
+MV_STATUS mvPp2RxqOffsetSet(int port, int rxq, int offset);
+
+MV_STATUS mvPp2RxqPktsCoalSet(int port, int rxq, MV_U32 pkts);
+int mvPp2RxqPktsCoalGet(int port, int rxq);
+
+void mvPp2RxReset(int port);
+
+/* Allocate and initialize descriptors for TXQ */
+MV_PP2_PHYS_TXQ_CTRL *mvPp2TxqInit(int port, int txp, int txq, int descNum, int hwfNum);
+
+MV_STATUS mvPp2TxqDelete(int port, int txp, int txq);
+
+/* Allocate and initialize all physical TXQs.
+   This function must be called before any use of TXQ */
+MV_STATUS mvPp2PhysTxqsAlloc(MV_VOID);
+
+/* Destroy all physical TXQs */
+MV_STATUS mvPp2PhysTxqsDestroy(MV_VOID);
+
+/* Allocate and initialize all aggregated TXQs.
+   This function must be called before any use of aggregated TXQ */
+MV_STATUS mvPp2AggrTxqsAlloc(int cpuNum);
+
+/* Destroy all aggregated TXQs */
+MV_STATUS mvPp2AggrTxqsDestroy(MV_VOID);
+
+/* Initialize aggregated TXQ */
+MV_PP2_AGGR_TXQ_CTRL *mvPp2AggrTxqInit(int cpu, int descNum);
+
+MV_STATUS mvPp2TxDonePktsCoalSet(int port, int txp, int txq, MV_U32 pkts);
+int mvPp2TxDonePktsCoalGet(int port, int txp, int txq);
+
+void mvPp2TxpReset(int port, int txp);
+
+/* Allocate and initialize port structure
+   Associate relevant TXQs for this port (predefined)
+   Associate <numRxqs> RXQs for Port number <port>, starting from RXQ number <firstRxq>
+   Note: mvPp2PortCtrl must be initialized, i.e. must call mvPp2HalInit before this function */
+void *mvPp2PortInit(int port, int firstRxq, int numRxqs, void *osHandle);
+void mvPp2PortDestroy(int port);
+
+MV_STATUS mvPp2PortUp(int port);
+MV_STATUS mvPp2PortDown(int port);
+
+MV_STATUS mvPp2PortEnable(int port);
+MV_STATUS mvPp2PortDisable(int port);
+
+MV_STATUS mvPp2BmPoolBufSizeSet(int pool, int bufsize);
+MV_STATUS mvPp2RxqBmPoolSet(int port, int rxq, int shortPool, int longPool);
+MV_STATUS mvPp2PortHwfBmPoolSet(int port, int shortPool, int longPool);
+
+MV_STATUS mvPp2MhSet(int port, MV_PP2_MH_MODE mh);
+
+MV_STATUS mvPp2RxFifoInit(int portNum);
+
+MV_STATUS mvPp2TxpMaxTxSizeSet(int port, int txp, int maxTxSize);
+MV_STATUS mvPp2TxpRateSet(int port, int txp, int rate);
+MV_STATUS mvPp2TxpBurstSet(int port, int txp, int burst);
+MV_STATUS mvPp2TxqRateSet(int port, int txp, int txq, int rate);
+MV_STATUS mvPp2TxqBurstSet(int port, int txp, int txq, int burst);
+MV_STATUS mvPp2TxqFixPrioSet(int port, int txp, int txq);
+MV_STATUS mvPp2TxqWrrPrioSet(int port, int txp, int txq, int weight);
+
+/*****************************/
+/*      Interrupts API       */
+/*****************************/
+MV_VOID   mvPp2GbeCpuInterruptsDisable(int port, int cpu);
+MV_VOID   mvPp2GbeCpuInterruptsEnable(int port, int cpu);
+MV_STATUS mvPp2RxqTimeCoalSet(int port, int rxq, MV_U32 uSec);
+int	  mvPp2RxqTimeCoalGet(int port, int rxq);
+MV_STATUS mvPp2GbeIsrRxqGroup(int port, int rxqNum);
+
+/* unmask the current CPU's rx/tx interrupts                   *
+ *  - rxq_mask: support rxq to cpu granularity                 *
+ *  - isTxDoneIsr: if 0 then Tx Done interruptare not unmasked */
+MV_STATUS mvPp2GbeIsrRxTxUnmask(int port, MV_U16 rxq_mask, int isTxDoneIsr);
+
+/* mask the current CPU's rx/tx interrupts */
+MV_STATUS mvPp2GbeIsrRxTxMask(int port);
+/*****************************/
+
+/*****************************/
+/*      Debug functions      */
+/*****************************/
+MV_VOID mvPp2RxDmaRegsPrint(MV_VOID);
+MV_VOID mvPp2DescMgrRegsRxPrint(MV_VOID);
+MV_VOID mvPp2DescMgrRegsTxPrint(MV_VOID);
+MV_VOID mvPp2AddressDecodeRegsPrint(MV_VOID);
+void mvPp2IsrRegs(int port);
+void mvPp2PhysRxqRegs(int rxq);
+MV_VOID mvPp2RxqShow(int port, int rxq, int mode);
+MV_VOID mvPp2TxqShow(int port, int txp, int txq, int mode);
+MV_VOID mvPp2AggrTxqShow(int cpu, int mode);
+void mvPp2PhysTxqRegs(int txq);
+void mvPp2PortTxqRegs(int port, int txp, int txq);
+void mvPp2AggrTxqRegs(int cpu);
+void mvPp2AddrDecodeRegs(void);
+void mvPp2TxSchedRegs(int port, int txp);
+void mvPp2BmPoolRegs(int pool);
+void mvPp2DropCntrs(int port);
+void mvPp2RxFifoRegs(int port);
+void mvPp2PortStatus(int port);
+#endif /* MV_PP2_GBE_H */
diff --git a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2GbeDebug.c b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2GbeDebug.c
new file mode 100644
index 0000000..581fa62
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2GbeDebug.c
@@ -0,0 +1,587 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"		/* Should be included before mvSysHwConfig */
+#include "mvTypes.h"
+#include "mv802_3.h"
+#include "mvDebug.h"
+#include "mvOs.h"
+
+#include "mvPp2Gbe.h"
+#include "pp2/bm/mvBm.h"
+
+#include "mvPp2GbeRegs.h"
+
+MV_VOID mvPp2RxDmaRegsPrint(void)
+{
+	int i;
+
+	mvOsPrintf("\n[RX DMA regs]\n");
+
+	for (i = 0; i < MV_BM_POOLS; i++)
+		mvEthRegPrint2(MV_PP2_POOL_BUF_SIZE_REG(i), "MV_PP2_POOL_BUF_SIZE_REG", i);
+
+	mvOsPrintf("\n");
+
+	for (i = 0; i < MV_ETH_RXQ_TOTAL_NUM; i++)
+		mvEthRegPrint2(MV_PP2_RXQ_CONFIG_REG(i), "MV_PP2_RXQ_CONFIG_REG", i);
+
+	mvOsPrintf("\n");
+
+	for (i = 0; i < MV_PP2_MAX_PORTS; i++) {
+		mvEthRegPrint2(MV_PP2_PORT_HWF_CONFIG_REG(i), "MV_PP2_PORT_HWF_CONFIG_REG", i);
+		mvEthRegPrint2(MV_PP2_RX_CTRL_REG(i), "MV_PP2_RX_CTRL_REG", i);
+	}
+	mvOsPrintf("\n");
+}
+
+
+
+MV_VOID mvPp2DescMgrRegsRxPrint(void)
+{
+	MV_U32 val, val1;
+	int i;
+
+	mvOsPrintf("--- %s ---\n\n", __func__);
+
+	for (i = 0; i < MV_ETH_RXQ_TOTAL_NUM; i++) {
+		mvOsPrintf("RXQ %d:\n", i);
+		MV_REG_WRITE(MV_PP2_RXQ_NUM_REG, i);
+		val1 = MV_REG_READ(MV_PP2_RXQ_DESC_ADDR_REG);
+		val = MV_REG_READ(MV_PP2_RXQ_DESC_SIZE_REG);
+		mvOsPrintf("   addr reg: 0x%x,   size reg: 0x%x\n", val1, val);
+		mvOsPrintf("   * address: %d,  size: %d,  L2 deposit: %d\n", val1,
+				val & MV_PP2_RXQ_DESC_SIZE_MASK,
+				(val & MV_PP2_RXQ_L2_DEPOSIT_MASK) >> MV_PP2_RXQ_L2_DEPOSIT_OFFSET);
+
+		val = MV_REG_READ(MV_PP2_RXQ_STATUS_REG(i));
+		mvOsPrintf("   status reg: 0x%x\n", val);
+		mvOsPrintf("   * occupied: %d,  non-occupied: %d\n",
+				(val & MV_PP2_RXQ_OCCUPIED_MASK) >> MV_PP2_RXQ_OCCUPIED_OFFSET,
+				(val & MV_PP2_RXQ_NON_OCCUPIED_MASK) >> MV_PP2_RXQ_NON_OCCUPIED_OFFSET);
+
+		val = MV_REG_READ(MV_PP2_RXQ_THRESH_REG);
+		mvOsPrintf("   rx thresh reg: 0x%x\n", val);
+		mvOsPrintf("   * occupied thrsh: %d,  non-occupied thrsh: %d\n",
+				(val & MV_PP2_OCCUPIED_THRESH_MASK) >> MV_PP2_OCCUPIED_THRESH_OFFSET,
+				(val & MV_PP2_NON_OCCUPIED_THRESH_MASK) >> MV_PP2_NON_OCCUPIED_THRESH_OFFSET);
+	}
+	mvOsPrintf("\n");
+}
+
+MV_VOID mvPp2DescMgrRegsTxPrint(void)
+{
+	MV_U32 val, val1, val2;
+	int i;
+
+	mvOsPrintf("--- %s ---\n\n", __func__);
+
+	for (i = 0; i < MV_PP2_TXQ_TOTAL_NUM; i++) {
+		mvOsPrintf("TXQ %d:\n", i);
+		MV_REG_WRITE(MV_PP2_TXQ_NUM_REG, i);
+		val1 = MV_REG_READ(MV_PP2_TXQ_DESC_ADDR_REG);
+		val = MV_REG_READ(MV_PP2_TXQ_DESC_SIZE_REG);
+		val2 = MV_REG_READ(MV_PP2_TXQ_DESC_HWF_SIZE_REG);
+		mvOsPrintf("   addr reg: 0x%x,   size reg: 0x%x,  hwf size reg: 0x%x\n", val1, val, val2);
+		mvOsPrintf("   * address: %d,  size: %d,   hwf size: %d\n", val1, val, val2);
+
+		val = MV_REG_READ(MV_PP2_TXQ_SENT_REG(i));
+		mvOsPrintf("   status reg: 0x%x\n", val);
+		mvOsPrintf("   * transmitted count: %d\n",
+				(val & MV_PP2_TRANSMITTED_COUNT_MASK) >> MV_PP2_TRANSMITTED_COUNT_OFFSET);
+
+		val = MV_REG_READ(MV_PP2_TXQ_THRESH_REG);
+		mvOsPrintf("   tx thresh reg: 0x%x\n", val);
+		mvOsPrintf("   * transmitted thrsh: %d\n",
+				(val & MV_PP2_TRANSMITTED_THRESH_MASK) >> MV_PP2_TRANSMITTED_THRESH_OFFSET);
+
+		val = MV_REG_READ(MV_PP2_TXQ_PENDING_REG);
+		mvOsPrintf("   desc status reg: 0x%x\n", val);
+		mvOsPrintf("   * pending: %d,  hwf pending: %d\n",
+				(val & MV_PP2_TXQ_PENDING_MASK) >> MV_PP2_TXQ_PENDING_OFFSET,
+				(val & MV_PP2_TXQ_HWF_PENDING_MASK) >> MV_PP2_TXQ_HWF_PENDING_OFFSET);
+	}
+	mvOsPrintf("\n");
+}
+
+MV_VOID mvPp2DescMgrRegsAggrTxPrint(void)
+{
+	MV_U32 val, val1, val2;
+	int i;
+
+	mvOsPrintf("--- %s ---\n\n", __func__);
+
+	for (i = 0; i < CONFIG_NR_CPUS; i++) {
+		mvOsPrintf("CPU %d:\n", i);
+		MV_REG_WRITE(MV_PP2_TXQ_NUM_REG, i);
+		val1 = MV_REG_READ(MV_PP2_AGGR_TXQ_DESC_ADDR_REG(i));
+		val = MV_REG_READ(MV_PP2_AGGR_TXQ_DESC_SIZE_REG(i));
+		val2 = MV_REG_READ(MV_PP2_AGGR_TXQ_STATUS_REG(i));
+		mvOsPrintf("   addr reg: 0x%x,   size reg: 0x%x,  status reg: 0x%x\n", val1, val, val2);
+		mvOsPrintf("   * address: %d,  size: %d,   pending: %d\n", val1, val, val2);
+	}
+	mvOsPrintf("\n");
+}
+
+MV_VOID mvPp2AddressDecodeRegsPrint(void)
+{
+	MV_U32 val;
+	int i;
+
+	mvOsPrintf("--- %s ---\n\n", __func__);
+
+	for (i = 0; i < ETH_MAX_DECODE_WIN; i++) {
+		mvOsPrintf("window %d:\n", i);
+		val = MV_REG_READ(ETH_WIN_BASE_REG(i));
+		mvOsPrintf("   win base reg: 0x%x\n", val);
+		mvOsPrintf("   * target :%d,  attr: %d,  base addr: %d\n", val & ETH_WIN_TARGET_MASK,
+			(val & ETH_WIN_ATTR_MASK) >> ETH_WIN_ATTR_OFFS, (val & ETH_WIN_BASE_MASK) >> ETH_WIN_BASE_OFFS);
+
+		val = MV_REG_READ(ETH_WIN_SIZE_REG(i));
+		mvOsPrintf("   win size reg: 0x%x\n", val);
+		mvOsPrintf("   * size: %d\n", (val & ETH_WIN_SIZE_MASK) >> ETH_WIN_SIZE_OFFS);
+		val = MV_REG_READ(ETH_WIN_REMAP_REG(i));
+	}
+
+	val = MV_REG_READ(ETH_BASE_ADDR_ENABLE_REG);
+	mvOsPrintf("base addr enable reg: 0x%x\n", val);
+	mvOsPrintf("\n");
+}
+
+static void mvPp2QueueShow(MV_PP2_QUEUE_CTRL *pQueueCtrl, int mode, int isTxq)
+{
+	mvOsPrintf("pFirst=%p (0x%x), numOfDescr=%d\n",
+		   pQueueCtrl->pFirst,
+		   (MV_U32) pp2DescVirtToPhys(pQueueCtrl, (MV_U8 *) pQueueCtrl->pFirst), pQueueCtrl->lastDesc + 1);
+
+	if (mode > 0) {
+		int i;
+
+		for (i = 0; i <= pQueueCtrl->lastDesc; i++) {
+			if (isTxq) {
+				PP2_TX_DESC *pTxDesc = (PP2_TX_DESC *) MV_PP2_QUEUE_DESC_PTR(pQueueCtrl, i);
+				mvOsPrintf("%3d. pTxDesc=%p, cmd=%08x, offs=%08x, txq=%4d, data=%4d, bufAddr=%08x, cookie=%x\n",
+					   i, pTxDesc, pTxDesc->command, pTxDesc->pktOffset, pTxDesc->physTxq, pTxDesc->dataSize,
+					   (MV_U32) pTxDesc->bufPhysAddr, (MV_U32) pTxDesc->bufCookie);
+
+				mvOsCacheLineInv(NULL, pTxDesc);
+			} else { /* RXQ */
+				PP2_RX_DESC *pRxDesc;
+
+				pRxDesc = (PP2_RX_DESC *) MV_PP2_QUEUE_DESC_PTR(pQueueCtrl, i);
+				mvOsPrintf("%3d. desc=%p, status=%08x, data=%4d, bufAddr=%08x, bufCookie=%08x, parserInfo=%03x\n",
+					   i, pRxDesc, pRxDesc->status,
+					   pRxDesc->dataSize, (MV_U32) pRxDesc->bufPhysAddr,
+					   (MV_U32) pRxDesc->bufCookie, (MV_U16) pRxDesc->parserInfo);
+				mvOsCacheLineInv(NULL, pRxDesc);
+			}
+		}
+	}
+}
+
+/* Show Port/Rxq descriptors ring */
+MV_VOID mvPp2RxqShow(int port, int rxq, int mode)
+{
+	int pRxq;
+	MV_PP2_PHYS_RXQ_CTRL *pRxqCtrl;
+	MV_PP2_QUEUE_CTRL *pQueueCtrl;
+
+	mvOsPrintf("\n[PPv2 RxQ show: port=%d, rxq=%d]\n", port, rxq);
+
+	if (mvPp2PortCheck(port))
+		return;
+
+	if (mvPp2MaxCheck(rxq, MV_ETH_MAX_RXQ, "logical rxq"))
+		return;
+
+	pRxq = mvPp2LogicRxqToPhysRxq(port, rxq);
+	if (pRxq < 0) {
+		mvOsPrintf("Port/RXQ is not mapped to physical RXQ\n");
+		return;
+	}
+
+	pRxqCtrl = &mvPp2PhysRxqs[pRxq];
+	pQueueCtrl = &pRxqCtrl->queueCtrl;
+	if (!pQueueCtrl->pFirst) {
+		mvOsPrintf("rxq %d wasn't created\n", rxq);
+		return;
+	}
+
+	mvOsPrintf("nextToProc=%d (%p), rxqOccupied=%d, rxqNonOccupied=%d\n",
+		   pQueueCtrl->nextToProc,
+		   MV_PP2_QUEUE_DESC_PTR(pQueueCtrl, pQueueCtrl->nextToProc),
+		   mvPp2RxqBusyDescNumGet(port, rxq), mvPp2RxqFreeDescNumGet(port, rxq));
+
+	mvPp2QueueShow(pQueueCtrl, mode, 0);
+}
+
+/* Show Port/TXQ descriptors ring */
+MV_VOID mvPp2TxqShow(int port, int txp, int txq, int mode)
+{
+	int pTxq;
+	MV_PP2_PHYS_TXQ_CTRL *pTxqCtrl;
+	MV_PP2_QUEUE_CTRL *pQueueCtrl;
+
+	mvOsPrintf("\n[PPv2 TxQ show: port=%d, txp=%d, txq=%d]\n", port, txp, txq);
+
+	if (mvPp2TxpCheck(port, txp))
+		return;
+
+	if (mvPp2MaxCheck(txq, MV_ETH_MAX_TXQ, "logical txq"))
+		return;
+
+	pTxq = MV_PPV2_TXQ_PHYS(port, txp, txq);
+
+	pTxqCtrl = &mvPp2PhysTxqs[pTxq];
+	pQueueCtrl = &pTxqCtrl->queueCtrl;
+	if (!pQueueCtrl->pFirst) {
+		mvOsPrintf("txq %d wasn't created\n", txq);
+		return;
+	}
+
+	mvOsPrintf("nextToProc=%d (%p), txqPending=%d\n",
+		   pQueueCtrl->nextToProc,
+		   MV_PP2_QUEUE_DESC_PTR(pQueueCtrl, pQueueCtrl->nextToProc),
+		   mvPp2TxqPendDescNumGet(port, txp, txq));
+
+	mvPp2QueueShow(pQueueCtrl, mode, 1);
+}
+
+/* Show CPU aggregation TXQ descriptors ring */
+MV_VOID mvPp2AggrTxqShow(int cpu, int mode)
+{
+	MV_PP2_AGGR_TXQ_CTRL *pTxqCtrl;
+	MV_PP2_QUEUE_CTRL *pQueueCtrl;
+
+	mvOsPrintf("\n[PPv2 AggrTxQ: cpu=%d]\n", cpu);
+
+	if (mvPp2CpuCheck(cpu))
+		return;
+
+	pTxqCtrl = &mvPp2AggrTxqs[cpu];
+	pQueueCtrl = &pTxqCtrl->queueCtrl;
+	if (!pQueueCtrl->pFirst) {
+		mvOsPrintf("aggr tx queue for cpu %d wasn't created\n", cpu);
+		return;
+	}
+	mvOsPrintf("nextToProc=%d (%p), txqPending=%d\n",
+		   pQueueCtrl->nextToProc,
+		   MV_PP2_QUEUE_DESC_PTR(pQueueCtrl, pQueueCtrl->nextToProc),
+		   mvPp2AggrTxqPendDescNumGet(cpu));
+
+	mvPp2QueueShow(pQueueCtrl, mode, 1);
+}
+
+void mvPp2IsrRegs(int port)
+{
+	int physPort;
+
+	if (mvPp2PortCheck(port))
+		return;
+
+	physPort = MV_PPV2_PORT_PHYS(port);
+
+	mvOsPrintf("\n[PPv2 ISR registers: port=%d - %s]\n", port, MV_PON_PORT(port) ? "PON" : "GMAC");
+	mvEthRegPrint(MV_PP2_ISR_RXQ_GROUP_REG(port), "MV_PP2_ISR_RXQ_GROUP_REG");
+	mvEthRegPrint(MV_PP2_ISR_ENABLE_REG(port), "MV_PP2_ISR_ENABLE_REG");
+	mvEthRegPrint(MV_PP2_ISR_RX_TX_CAUSE_REG(physPort), "MV_PP2_ISR_RX_TX_CAUSE_REG");
+	mvEthRegPrint(MV_PP2_ISR_RX_TX_MASK_REG(physPort), "MV_PP2_ISR_RX_TX_MASK_REG");
+
+	mvEthRegPrint(MV_PP2_ISR_RX_ERR_CAUSE_REG(physPort), "MV_PP2_ISR_RX_ERR_CAUSE_REG");
+	mvEthRegPrint(MV_PP2_ISR_RX_ERR_MASK_REG(physPort), "MV_PP2_ISR_RX_ERR_MASK_REG");
+
+	if (MV_PON_PORT(port)) {
+		mvEthRegPrint(MV_PP2_ISR_PON_TX_UNDR_CAUSE_REG, "MV_PP2_ISR_PON_TX_UNDR_CAUSE_REG");
+		mvEthRegPrint(MV_PP2_ISR_PON_TX_UNDR_MASK_REG, "MV_PP2_ISR_PON_TX_UNDR_MASK_REG");
+	} else {
+		mvEthRegPrint(MV_PP2_ISR_TX_ERR_CAUSE_REG(physPort), "MV_PP2_ISR_TX_ERR_CAUSE_REG");
+		mvEthRegPrint(MV_PP2_ISR_TX_ERR_MASK_REG(physPort), "MV_PP2_ISR_TX_ERR_MASK_REG");
+	}
+	mvEthRegPrint(MV_PP2_ISR_MISC_CAUSE_REG, "MV_PP2_ISR_MISC_CAUSE_REG");
+	mvEthRegPrint(MV_PP2_ISR_MISC_MASK_REG, "MV_PP2_ISR_MISC_MASK_REG");
+}
+
+void mvPp2PhysRxqRegs(int rxq)
+{
+	mvOsPrintf("\n[PPv2 Phys RxQ registers: rxq=%d]\n", rxq);
+
+	if (mvPp2MaxCheck(rxq, MV_ETH_RXQ_TOTAL_NUM, "physical rxq"))
+		return;
+
+	MV_REG_WRITE(MV_PP2_RXQ_NUM_REG, rxq);
+	mvEthRegPrint(MV_PP2_RXQ_NUM_REG, "MV_PP2_RXQ_NUM_REG");
+	mvEthRegPrint(MV_PP2_RXQ_DESC_ADDR_REG, "MV_PP2_RXQ_DESC_ADDR_REG");
+	mvEthRegPrint(MV_PP2_RXQ_DESC_SIZE_REG, "MV_PP2_RXQ_DESC_SIZE_REG");
+	mvEthRegPrint(MV_PP2_RXQ_STATUS_REG(rxq), "MV_PP2_RXQ_STATUS_REG");
+	mvEthRegPrint(MV_PP2_RXQ_THRESH_REG, "MV_PP2_RXQ_THRESH_REG");
+	mvEthRegPrint(MV_PP2_RXQ_INDEX_REG, "MV_PP2_RXQ_INDEX_REG");
+	mvEthRegPrint(MV_PP2_RXQ_CONFIG_REG(rxq), "MV_PP2_RXQ_CONFIG_REG");
+	mvEthRegPrint(MV_PP2_RXQ_SNOOP_REG(rxq), "MV_PP2_RXQ_SNOOP_REG");
+	mvEthRegPrint(MV_PP2_RX_EARLY_DROP_REG(rxq), "MV_PP2_RX_EARLY_DROP_REG");
+	mvEthRegPrint(MV_PP2_RX_DESC_DROP_REG(rxq), "MV_PP2_RX_DESC_DROP_REG");
+}
+
+void mvPp2PhysTxqRegs(int txq)
+{
+	mvOsPrintf("\n[PPv2 Phys TxQ registers: txq=%d]\n", txq);
+
+	if (mvPp2MaxCheck(txq, MV_PP2_TXQ_TOTAL_NUM, "physical txq"))
+		return;
+
+	MV_REG_WRITE(MV_PP2_TXQ_NUM_REG, txq);
+	mvEthRegPrint(MV_PP2_TXQ_NUM_REG, "MV_PP2_TXQ_NUM_REG");
+	mvEthRegPrint(MV_PP2_TXQ_DESC_ADDR_REG, "MV_PP2_TXQ_DESC_ADDR_REG");
+	mvEthRegPrint(MV_PP2_TXQ_DESC_SIZE_REG, "MV_PP2_TXQ_DESC_SIZE_REG");
+	mvEthRegPrint(MV_PP2_TXQ_DESC_HWF_SIZE_REG, "MV_PP2_TXQ_DESC_HWF_SIZE_REG");
+	mvEthRegPrint(MV_PP2_TXQ_INDEX_REG, "MV_PP2_TXQ_INDEX_REG");
+	mvEthRegPrint(MV_PP2_TXQ_PREF_BUF_REG, "MV_PP2_TXQ_PREF_BUF_REG");
+	mvEthRegPrint(MV_PP2_TXQ_PENDING_REG, "MV_PP2_TXQ_PENDING_REG");
+	mvEthRegPrint(MV_PP2_TXQ_SENT_REG(txq), "MV_PP2_TXQ_SENT_REG");
+	mvEthRegPrint(MV_PP2_TXQ_INT_STATUS_REG, "MV_PP2_TXQ_INT_STATUS_REG");
+}
+
+void mvPp2PortTxqRegs(int port, int txp, int txq)
+{
+	mvOsPrintf("\n[PPv2 Phys TxQ registers: txq=%d]\n", txq);
+
+	if (mvPp2TxpCheck(port, txp))
+		return;
+
+	if (mvPp2MaxCheck(txq, MV_ETH_MAX_TXQ, "logical txq"))
+		return;
+
+	mvPp2PhysTxqRegs(MV_PPV2_TXQ_PHYS(port, txp, txq));
+}
+
+void mvPp2AggrTxqRegs(int cpu)
+{
+	mvOsPrintf("\n[PP2 Aggr TXQ registers: cpu=%d]\n", cpu);
+
+	if (mvPp2CpuCheck(cpu))
+		return;
+
+	mvEthRegPrint(MV_PP2_AGGR_TXQ_DESC_ADDR_REG(cpu), "MV_PP2_AGGR_TXQ_DESC_ADDR_REG");
+	mvEthRegPrint(MV_PP2_AGGR_TXQ_DESC_SIZE_REG(cpu), "MV_PP2_AGGR_TXQ_DESC_SIZE_REG");
+	mvEthRegPrint(MV_PP2_AGGR_TXQ_STATUS_REG(cpu), "MV_PP2_AGGR_TXQ_STATUS_REG");
+	mvEthRegPrint(MV_PP2_AGGR_TXQ_INDEX_REG(cpu), "MV_PP2_AGGR_TXQ_INDEX_REG");
+}
+
+void mvPp2AddrDecodeRegs(void)
+{
+	MV_U32 regValue;
+	int win;
+
+	/* ToDo - print Misc interrupt Cause and Mask registers */
+
+	mvEthRegPrint(ETH_BASE_ADDR_ENABLE_REG, "ETH_BASE_ADDR_ENABLE_REG");
+	mvEthRegPrint(ETH_TARGET_DEF_ADDR_REG, "ETH_TARGET_DEF_ADDR_REG");
+	mvEthRegPrint(ETH_TARGET_DEF_ID_REG, "ETH_TARGET_DEF_ID_REG");
+
+	regValue = MV_REG_READ(ETH_BASE_ADDR_ENABLE_REG);
+	for (win = 0; win < ETH_MAX_DECODE_WIN; win++) {
+		if (regValue & (1 << win))
+			continue; /* window is disable */
+		mvOsPrintf("\t win[%d]\n", win);
+		mvEthRegPrint(ETH_WIN_BASE_REG(win), "\t ETH_WIN_BASE_REG");
+		mvEthRegPrint(ETH_WIN_SIZE_REG(win), "\t ETH_WIN_SIZE_REG");
+		if (win < ETH_MAX_HIGH_ADDR_REMAP_WIN)
+			mvEthRegPrint(ETH_WIN_REMAP_REG(win), "\t ETH_WIN_REMAP_REG");
+	}
+}
+
+
+void mvPp2TxSchedRegs(int port, int txp)
+{
+	int physTxp, txq;
+
+	physTxp = MV_PPV2_TXP_PHYS(port, txp);
+
+	mvOsPrintf("\n[TXP Scheduler registers: port=%d, txp=%d, physPort=%d]\n", port, txp, physTxp);
+
+	MV_REG_WRITE(MV_PP2_TXP_SCHED_PORT_INDEX_REG, physTxp);
+	mvEthRegPrint(MV_PP2_TXP_SCHED_PORT_INDEX_REG, "MV_PP2_TXP_SCHED_PORT_INDEX_REG");
+	mvEthRegPrint(MV_PP2_TXP_SCHED_Q_CMD_REG, "MV_PP2_TXP_SCHED_Q_CMD_REG");
+	mvEthRegPrint(MV_PP2_TXP_SCHED_CMD_1_REG, "MV_PP2_TXP_SCHED_CMD_1_REG");
+	mvEthRegPrint(MV_PP2_TXP_SCHED_FIXED_PRIO_REG, "MV_PP2_TXP_SCHED_FIXED_PRIO_REG");
+	mvEthRegPrint(MV_PP2_TXP_SCHED_PERIOD_REG, "MV_PP2_TXP_SCHED_PERIOD_REG");
+	mvEthRegPrint(MV_PP2_TXP_SCHED_MTU_REG, "MV_PP2_TXP_SCHED_MTU_REG");
+	mvEthRegPrint(MV_PP2_TXP_SCHED_REFILL_REG, "MV_PP2_TXP_SCHED_REFILL_REG");
+	mvEthRegPrint(MV_PP2_TXP_SCHED_TOKEN_SIZE_REG, "MV_PP2_TXP_SCHED_TOKEN_SIZE_REG");
+	mvEthRegPrint(MV_PP2_TXP_SCHED_TOKEN_CNTR_REG, "MV_PP2_TXP_SCHED_TOKEN_CNTR_REG");
+
+	for (txq = 0; txq < MV_ETH_MAX_TXQ; txq++) {
+		mvOsPrintf("\n[TxQ Scheduler registers: port=%d, txp=%d, txq=%d]\n", port, txp, txq);
+		mvEthRegPrint(MV_PP2_TXQ_SCHED_REFILL_REG(txq), "MV_PP2_TXQ_SCHED_REFILL_REG");
+		mvEthRegPrint(MV_PP2_TXQ_SCHED_TOKEN_SIZE_REG(txq), "MV_PP2_TXQ_SCHED_TOKEN_SIZE_REG");
+		mvEthRegPrint(MV_PP2_TXQ_SCHED_TOKEN_CNTR_REG(txq), "MV_PP2_TXQ_SCHED_TOKEN_CNTR_REG");
+	}
+}
+
+void mvPp2BmPoolRegs(int pool)
+{
+	mvOsPrintf("\n[BM pool registers: pool=%d]\n", pool);
+	mvEthRegPrint(MV_BM_POOL_BASE_REG(pool), "MV_BM_POOL_BASE_REG");
+	mvEthRegPrint(MV_BM_POOL_SIZE_REG(pool), "MV_BM_POOL_SIZE_REG");
+	mvEthRegPrint(MV_BM_POOL_READ_PTR_REG(pool), "MV_BM_POOL_READ_PTR_REG");
+	mvEthRegPrint(MV_BM_POOL_PTRS_NUM_REG(pool), "MV_BM_POOL_PTRS_NUM_REG");
+	mvEthRegPrint(MV_BM_BPPI_READ_PTR_REG(pool), "MV_BM_BPPI_READ_PTR_REG");
+	mvEthRegPrint(MV_BM_BPPI_PTRS_NUM_REG(pool), "MV_BM_BPPI_PTRS_NUM_REG");
+	mvEthRegPrint(MV_BM_POOL_CTRL_REG(pool), "MV_BM_POOL_CTRL_REG");
+	mvEthRegPrint(MV_BM_INTR_CAUSE_REG(pool), "MV_BM_INTR_CAUSE_REG");
+	mvEthRegPrint(MV_BM_INTR_MASK_REG(pool), "MV_BM_INTR_MASK_REG");
+}
+
+void mvPp2DropCntrs(int port)
+{
+	int i;
+
+	mvOsPrintf("\n[Port #%d Drop counters]\n", port);
+	mvEthRegPrint(MV_PP2_OVERRUN_DROP_REG(MV_PPV2_PORT_PHYS(port)), "MV_PP2_OVERRUN_DROP_REG");
+	mvEthRegPrint(MV_PP2_CLS_DROP_REG(MV_PPV2_PORT_PHYS(port)), "MV_PP2_CLS_DROP_REG");
+
+	if (MV_PON_PORT(port)) {
+		for (i = 0; i < CONFIG_MV_PON_TCONTS; i++) {
+			mvEthRegPrint2(MV_PP2_TX_EARLY_DROP_REG(i), "MV_PP2_TX_EARLY_DROP_REG", i);
+			mvEthRegPrint2(MV_PP2_TX_DESC_DROP_REG(i), "MV_PP2_TX_DESC_DROP_REG", i);
+		}
+	} else {
+		i = MV_ETH_MAX_TCONT + port;
+		mvEthRegPrint2(MV_PP2_TX_EARLY_DROP_REG(i), "MV_PP2_TX_EARLY_DROP_REG", i);
+		mvEthRegPrint2(MV_PP2_TX_DESC_DROP_REG(i), "MV_PP2_TX_DESC_DROP_REG", i);
+	}
+	for (i = port * CONFIG_MV_ETH_RXQ; i < (port * CONFIG_MV_ETH_RXQ + CONFIG_MV_ETH_RXQ); i++) {
+		mvEthRegPrint2(MV_PP2_RX_EARLY_DROP_REG(i), "MV_PP2_RX_EARLY_DROP_REG", i);
+		mvEthRegPrint2(MV_PP2_RX_DESC_DROP_REG(i), "MV_PP2_RX_DESC_DROP_REG", i);
+	}
+}
+
+void mvPp2RxFifoRegs(int port)
+{
+	int p = MV_PPV2_PORT_PHYS(port);
+
+	mvOsPrintf("\n[Port #%d RX Fifo]\n", p);
+	mvEthRegPrint(MV_PP2_RX_DATA_FIFO_SIZE_REG(p), "MV_PP2_RX_DATA_FIFO_SIZE_REG");
+	mvEthRegPrint(MV_PP2_RX_ATTR_FIFO_SIZE_REG(p), "MV_PP2_RX_ATTR_FIFO_SIZE_REG");
+	mvOsPrintf("\n[Global RX Fifo regs]\n");
+	mvEthRegPrint(MV_PP2_RX_MIN_PKT_SIZE_REG, "MV_PP2_RX_MIN_PKT_SIZE_REG");
+}
+
+
+/* Print status of Ethernet port */
+void mvPp2PortStatus(int port)
+{
+	int i;
+	MV_ETH_PORT_STATUS	link;
+	MV_PP2_PORT_CTRL 	*pPortCtrl;
+
+	if (mvPp2PortCheck(port))
+		return;
+
+	pPortCtrl = mvPp2PortHndlGet(port);
+	if (!pPortCtrl)
+		return;
+
+	mvOsPrintf("\n[RXQ mapping: port=%d, ctrl=%p]\n", port, pPortCtrl);
+	if (pPortCtrl->pRxQueue) {
+		mvOsPrintf("         RXQ: ");
+		for (i = 0; i < pPortCtrl->rxqNum; i++) {
+			mvOsPrintf(" %4d", i);
+		}
+		mvOsPrintf("\nphysical RXQ: ");
+		for (i = 0; i < pPortCtrl->rxqNum; i++) {
+			if (pPortCtrl->pRxQueue[i])
+				mvOsPrintf(" %4d", pPortCtrl->pRxQueue[i]->rxq);
+			else
+				mvOsPrintf(" NULL");
+		}
+		mvOsPrintf("\n");
+	}
+
+	mvOsPrintf("\n[Link: port=%d, ctrl=%p]\n", port, pPortCtrl);
+
+	if (MV_PON_PORT(port)) {
+		mvOsPrintf("GPON port %d link is up\n", port);
+	} else {
+
+		mvEthLinkStatus(port, &link);
+
+		if (link.linkup) {
+			mvOsPrintf("link up");
+			mvOsPrintf(", %s duplex", (link.duplex == MV_ETH_DUPLEX_FULL) ? "full" : "half");
+			mvOsPrintf(", speed ");
+
+			if (link.speed == MV_ETH_SPEED_1000)
+				mvOsPrintf("1 Gbps\n");
+			else if (link.speed == MV_ETH_SPEED_100)
+				mvOsPrintf("100 Mbps\n");
+			else
+				mvOsPrintf("10 Mbps\n");
+
+			mvOsPrintf("rxFC - %s, txFC - %s\n",
+				(link.rxFc == MV_ETH_FC_DISABLE) ? "disabled" : "enabled",
+				(link.txFc == MV_ETH_FC_DISABLE) ? "disabled" : "enabled");
+		} else
+			mvOsPrintf("link down\n");
+	}
+}
diff --git a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2GbeRegs.h b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2GbeRegs.h
new file mode 100644
index 0000000..c7acc08
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2GbeRegs.h
@@ -0,0 +1,713 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_PP2_GBE_REGS_H__
+#define __MV_PP2_GBE_REGS_H__
+
+#include "mvSysEthConfig.h"
+#include "pp2/gmac/mvEthGmacApi.h"
+
+/************************** PPv2 HW Configuration ***********************/
+
+/************************** TX General Registers ******************************/
+#define MV_PP2_TX_SNOOP_REG			(MV_PP2_REG_BASE + 0x8800)
+
+/************************** RX Fifo Registers ******************************/
+#define MV_PP2_RX_DATA_FIFO_SIZE_REG(port)	(MV_PP2_REG_BASE + 4 * (port))
+#define MV_PP2_RX_ATTR_FIFO_SIZE_REG(port)	(MV_PP2_REG_BASE + 0x20 + 4 * (port))
+#define MV_PP2_RX_MIN_PKT_SIZE_REG		(MV_PP2_REG_BASE + 0x60)
+#define MV_PP2_RX_FIFO_INIT_REG			(MV_PP2_REG_BASE + 0x64)
+
+/************************** Top Reg file ******************************/
+#define MV_PP2_MH_REG(port)			(MV_PP2_REG_BASE + 0x5040 + 4 * (port))
+
+#define MV_PP2_MH_EN_OFFS			0
+#define MV_PP2_MH_EN_MASK			(1 << MV_PP2_MH_EN_OFFS)
+
+#define MV_PP2_DSA_EN_OFFS			0
+#define MV_PP2_DSA_EN_MASK			(0x3 << MV_PP2_DSA_EN_OFFS)
+#define MV_PP2_DSA_DISABLE			0
+#define MV_PP2_DSA_NON_EXTENDED			(0x1 << MV_PP2_DSA_EN_OFFS)
+#define MV_PP2_DSA_EXTENDED			(0x2 << MV_PP2_DSA_EN_OFFS)
+
+/************************** RX DMA Top Registers ******************************/
+#define MV_PP2_POOL_BUF_SIZE_REG(pool)		(MV_PP2_REG_BASE + 0x180 + 4 * (pool))
+
+#define MV_PP2_POOL_BUF_SIZE_OFFSET		5
+#define MV_PP2_POOL_BUF_SIZE_MASK		(0xFFFE)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_RXQ_SNOOP_REG(rxq)		(MV_PP2_REG_BASE + 0x800 + 4 * (rxq))
+
+#define MV_PP2_SNOOP_PKT_SIZE_OFFS		5
+#define MV_PP2_SNOOP_PKT_SIZE_MASK		(0x1FF << MV_PP2_SNOOP_PKT_SIZE_OFFS)
+
+#define MV_PP2_SNOOP_BUF_HDR_OFFS		6
+#define MV_PP2_SNOOP_BUF_HDR_MASK		(0x1 << MV_PP2_SNOOP_BUF_HDR_OFFS)
+
+#define MV_PP2_L2_DEPOSIT_PKT_SIZE_OFFS		21
+#define MV_PP2_L2_DEPOSIT_PKT_SIZE_MASK		(0xF << MV_PP2_L2_DEPOSIT_PKT_SIZE_OFFS)
+
+#define MV_PP2_L2_DEPOSIT_BUF_HDR_OFFS		25
+#define MV_PP2_L2_DEPOSIT_BUF_HDR_MASK		(0x1 << MV_PP2_L2_DEPOSIT_BUF_HDR_OFFS)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_RXQ_CONFIG_REG(rxq)		(MV_PP2_REG_BASE + 0xc00 + 4 * (rxq))
+
+#define MV_PP2_RXQ_PACKET_OFFSET_ALL_MASK	(0xE0707)
+#define MV_PP2_RXQ_POOL_MASK			(0x707)
+
+#define MV_PP2_RXQ_POOL_SHORT_ID_OFFS		0
+#define MV_PP2_RXQ_POOL_SHORT_ID_MASK		(0x7 << MV_PP2_RXQ_POOL_SHORT_ID_OFFS)
+#define MV_PP2_RXQ_POOL_LONG_ID_OFFS		8
+#define MV_PP2_RXQ_POOL_LONG_ID_MASK		(0x7 << MV_PP2_RXQ_POOL_LONG_ID_OFFS)
+#define MV_PP2_RXQ_PACKET_OFFSET_OFFS		12
+#define MV_PP2_RXQ_PACKET_OFFSET_MASK		(0xFF << MV_PP2_RXQ_PACKET_OFFSET_OFFS)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_PORT_HWF_CONFIG_REG(port)	(MV_PP2_REG_BASE + 0x120 + 4 * (port))
+
+#define MV_PP2_PORT_HWF_PKT_OFFSET_ALL_MASK	(0x707)
+
+#define MV_PP2_PORT_HWF_POOL_SHORT_ID_OFFS	0
+#define MV_PP2_PORT_HWF_POOL_SHORT_ID_MASK	(0x7 << MV_PP2_PORT_HWF_POOL_SHORT_ID_OFFS)
+#define MV_PP2_PORT_HWF_POOL_LONG_ID_OFFS	8
+#define MV_PP2_PORT_HWF_POOL_LONG_ID_MASK	(0x7 << MV_PP2_PORT_HWF_POOL_LONG_ID_OFFS)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_RX_CTRL_REG(port)		(MV_PP2_REG_BASE + 0x140 + 4 * (port))
+/************************** Dsecriptor Manager Top Registers ******************************/
+
+#define MV_PP2_RXQ_NUM_REG			(MV_PP2_REG_BASE + 0x2040)
+
+#define MV_PP2_RXQ_NUM_OFFSET			0
+#define MV_PP2_RXQ_NUM_MASK			(0xFF << MV_PP2_RXQ_NUM_OFFSET)
+/*-------------------------------------------------------------------------------*/
+#define MV_PP2_RXQ_DESC_ADDR_REG		(MV_PP2_REG_BASE + 0x2044)
+
+#define MV_PP2_RXQ_DESC_SIZE_REG		(MV_PP2_REG_BASE + 0x2048)
+
+#define MV_PP2_RXQ_DESC_SIZE_OFFSET		4
+#define MV_PP2_RXQ_DESC_SIZE_MASK		(0x3FF << MV_PP2_RXQ_DESC_SIZE_OFFSET)
+
+#define MV_PP2_RXQ_L2_DEPOSIT_OFFSET		16
+#define MV_PP2_RXQ_L2_DEPOSIT_MASK		(0x1 << MV_PP2_RXQ_L2_DEPOSIT_OFFSET)
+/*-------------------------------------------------------------------------------*/
+#define MV_PP2_RXQ_STATUS_UPDATE_REG(rxq)	(MV_PP2_REG_BASE + 0x3000 + 4 * (rxq))
+
+#define MV_PP2_RXQ_NUM_PROCESSED_OFFSET	0
+#define MV_PP2_RXQ_NUM_PROCESSED_MASK		(0x3FFF << MV_PP2_RXQ_NUM_PROCESSED_OFFSET)
+#define MV_PP2_RXQ_NUM_NEW_OFFSET		16
+#define MV_PP2_RXQ_NUM_NEW_MASK			(0x3FFF << MV_PP2_RXQ_NUM_NEW_OFFSET)
+/*-------------------------------------------------------------------------------*/
+#define MV_PP2_RXQ_STATUS_REG(rxq)		(MV_PP2_REG_BASE + 0x3400 + 4 * (rxq))
+
+#define MV_PP2_RXQ_OCCUPIED_OFFSET		0
+#define MV_PP2_RXQ_OCCUPIED_MASK		(0x3FFF << MV_PP2_RXQ_OCCUPIED_OFFSET)
+#define MV_PP2_RXQ_NON_OCCUPIED_OFFSET		16
+#define MV_PP2_RXQ_NON_OCCUPIED_MASK		(0x3FFF << MV_PP2_RXQ_NON_OCCUPIED_OFFSET)
+/*-------------------------------------------------------------------------------*/
+#define MV_PP2_RXQ_THRESH_REG			(MV_PP2_REG_BASE + 0x204c)
+
+#define MV_PP2_OCCUPIED_THRESH_OFFSET		0
+#define MV_PP2_OCCUPIED_THRESH_MASK		(0x3FFF << MV_PP2_OCCUPIED_THRESH_OFFSET)
+
+#define MV_PP2_NON_OCCUPIED_THRESH_OFFSET	16
+#define MV_PP2_NON_OCCUPIED_THRESH_MASK		(0x3FFF << MV_PP2_NON_OCCUPIED_THRESH_OFFSET)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_RXQ_INDEX_REG			(MV_PP2_REG_BASE + 0x2050)
+/*-------------------------------------------------------------------------------*/
+
+/*-------------------------------------------------------------------------------*/
+#define MV_PP2_TXQ_NUM_REG			(MV_PP2_REG_BASE + 0x2080)
+
+#define MV_PP2_TXQ_NUM_OFFSET			0
+#define MV_PP2_TXQ_NUM_MASK			(0xFF << MV_PP2_RXQ_NUM_OFFSET)
+/*-------------------------------------------------------------------------------*/
+#define MV_PP2_TXQ_DESC_ADDR_REG		(MV_PP2_REG_BASE + 0x2084)
+
+#define MV_PP2_TXQ_DESC_SIZE_REG		(MV_PP2_REG_BASE + 0x2088)
+
+#define MV_PP2_TXQ_DESC_SIZE_OFFSET		4
+#define MV_PP2_TXQ_DESC_SIZE_MASK		(0x3FF << MV_PP2_TXQ_DESC_SIZE_OFFSET)
+/*-------------------------------------------------------------------------------*/
+#define MV_PP2_TXQ_DESC_HWF_SIZE_REG		(MV_PP2_REG_BASE + 0x208c)
+
+#define MV_PP2_TXQ_DESC_HWF_SIZE_OFFSET		4
+#define MV_PP2_TXQ_DESC_HWF_SIZE_MASK		(0x3FF << MV_PP2_TXQ_DESC_HWF_SIZE_OFFSET)
+/*-------------------------------------------------------------------------------*/
+
+/* Aggregated (per CPU) TXQ - WO */
+#define MV_PP2_AGGR_TXQ_UPDATE_REG		(MV_PP2_REG_BASE + 0x2090)
+/*-------------------------------------------------------------------------------*/
+
+/* Each CPU has own copy */
+#define MV_PP2_TXQ_THRESH_REG			(MV_PP2_REG_BASE + 0x2094)
+
+#define MV_PP2_TRANSMITTED_THRESH_OFFSET	16
+#define MV_PP2_TRANSMITTED_THRESH_MASK		(0x3FFF << MV_PP2_TRANSMITTED_THRESH_OFFSET)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_TXQ_INDEX_REG			(MV_PP2_REG_BASE + 0x2098)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_TXQ_PREF_BUF_REG			(MV_PP2_REG_BASE + 0x209c)
+
+#define MV_PP2_PREF_BUF_PTR_OFFSET		0
+#define MV_PP2_PREF_BUF_PTR_MASK		(0xFFFF << MV_PP2_PREF_BUF_PTR_OFFSET)
+#define MV_PP2_PREF_BUF_PTR(desc)		((desc) << MV_PP2_PREF_BUF_PTR_OFFSET)
+
+#define MV_PP2_PREF_BUF_SIZE_OFFSET		12
+#define MV_PP2_PREF_BUF_SIZE_MASK		(0x7 << MV_PP2_PREF_BUF_SIZE_OFFSET)
+#define MV_PP2_PREF_BUF_SIZE_NONE		(0 << MV_PP2_PREF_BUF_SIZE_OFFSET)
+#define MV_PP2_PREF_BUF_SIZE_1			(1 << MV_PP2_PREF_BUF_SIZE_OFFSET)
+#define MV_PP2_PREF_BUF_SIZE_2			(2 << MV_PP2_PREF_BUF_SIZE_OFFSET)
+#define MV_PP2_PREF_BUF_SIZE_4			(3 << MV_PP2_PREF_BUF_SIZE_OFFSET)
+#define MV_PP2_PREF_BUF_SIZE_8			(4 << MV_PP2_PREF_BUF_SIZE_OFFSET)
+#define MV_PP2_PREF_BUF_SIZE_16			(5 << MV_PP2_PREF_BUF_SIZE_OFFSET)
+#define MV_PP2_PREF_BUF_SIZE_32			(6 << MV_PP2_PREF_BUF_SIZE_OFFSET)
+#define MV_PP2_PREF_BUF_SIZE_64			(7 << MV_PP2_PREF_BUF_SIZE_OFFSET)
+
+#define MV_PP2_PREF_BUF_THRESH_OFFSET		17
+#define MV_PP2_PREF_BUF_THRESH_MASK		(0xF << MV_PP2_PREF_BUF_THRESH_OFFSET)
+#define MV_PP2_PREF_BUF_THRESH(val)		((val) << MV_PP2_PREF_BUF_THRESH_OFFSET)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_TXQ_PENDING_REG			(MV_PP2_REG_BASE + 0x20a0)
+
+#define MV_PP2_TXQ_PENDING_OFFSET		0
+#define MV_PP2_TXQ_PENDING_MASK			(0x3FFF << MV_PP2_TXQ_PENDING_OFFSET)
+
+#define MV_PP2_TXQ_HWF_PENDING_OFFSET		16
+#define MV_PP2_TXQ_HWF_PENDING_MASK		(0x3FFF << MV_PP2_TXQ_HWF_PENDING_OFFSET)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_TXQ_INT_STATUS_REG		(MV_PP2_REG_BASE + 0x20a4)
+/*-------------------------------------------------------------------------------*/
+
+/* Direct access - per TXQ, per CPU */
+#define MV_PP2_TXQ_SENT_REG(txq)		(MV_PP2_REG_BASE + 0x3c00 + 4 * (txq))
+
+#define MV_PP2_TRANSMITTED_COUNT_OFFSET	16
+#define MV_PP2_TRANSMITTED_COUNT_MASK		(0x3FFF << MV_PP2_TRANSMITTED_COUNT_OFFSET)
+/*-------------------------------------------------------------------------------*/
+
+
+/*-------------------------------------------------------------------------------*/
+#define MV_PP2_AGGR_TXQ_DESC_ADDR_REG(cpu)	(MV_PP2_REG_BASE + 0x2100 + 4 * (cpu))
+
+#define MV_PP2_AGGR_TXQ_DESC_SIZE_REG(cpu)	(MV_PP2_REG_BASE + 0x2140 + 4 * (cpu))
+#define MV_PP2_AGGR_TXQ_DESC_SIZE_OFFSET	4
+#define MV_PP2_AGGR_TXQ_DESC_SIZE_MASK		(0x3FF << MV_PP2_AGGR_TXQ_DESC_SIZE_OFFSET)
+/*-------------------------------------------------------------------------------*/
+#define MV_PP2_AGGR_TXQ_STATUS_REG(cpu)		(MV_PP2_REG_BASE + 0x2180 + 4 * (cpu))
+
+#define MV_PP2_AGGR_TXQ_PENDING_OFFSET		0
+#define MV_PP2_AGGR_TXQ_PENDING_MASK		(0x3FFF << MV_PP2_AGGR_TXQ_PENDING_OFFSET)
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_AGGR_TXQ_INDEX_REG(cpu)		(MV_PP2_REG_BASE + 0x21c0 + 4 * (cpu))
+
+/************************** Interrupt Cause and Mask registers ******************/
+#define MV_PP2_ISR_RX_THRESHOLD_REG(port)	(MV_PP2_REG_BASE + 0x5200 + 4 * (port))
+
+#define MV_PP2_ISR_RXQ_GROUP_REG(port)		(MV_PP2_REG_BASE + 0x5400 + 4 * (port))
+
+#define MV_PP2_ISR_ENABLE_REG(port)		(MV_PP2_REG_BASE + 0x5420 + 4 * (port))
+
+#define MV_PP2_ISR_ENABLE_INTERRUPT_OFFS	0
+#define MV_PP2_ISR_ENABLE_INTERRUPT_MASK	0xFFFF
+#define MV_PP2_ISR_ENABLE_INTERRUPT(cpu)	((1 << cpu) & MV_PP2_ISR_ENABLE_INTERRUPT_MASK)
+
+#define MV_PP2_ISR_DISABLE_INTERRUPT_OFFS	16
+#define MV_PP2_ISR_DISABLE_INTERRUPT_MASK	(0xFFFF << MV_PP2_ISR_DISABLE_INTERRUPT_OFFS)
+#define MV_PP2_ISR_DISABLE_INTERRUPT(cpu)	(((1 << cpu) << MV_PP2_ISR_DISABLE_INTERRUPT_OFFS)\
+							& MV_PP2_ISR_DISABLE_INTERRUPT_MASK)
+
+
+#define MV_PP2_ISR_RX_TX_CAUSE_REG(port)	(MV_PP2_REG_BASE + 0x5480 + 4 * (port))
+#define MV_PP2_ISR_RX_TX_MASK_REG(port)		(MV_PP2_REG_BASE + 0x54a0 + 4 * (port))
+
+#define MV_PP2_CAUSE_RXQ_OCCUP_DESC_OFFS      	0
+#define MV_PP2_CAUSE_RXQ_OCCUP_DESC_BIT(q)    	(MV_PP2_CAUSE_RXQ_OCCUP_DESC_OFFS + (q))
+#define MV_PP2_CAUSE_RXQ_OCCUP_DESC_ALL_MASK  	(0xFFFF << MV_PP2_CAUSE_RXQ_OCCUP_DESC_OFFS)
+#define MV_PP2_CAUSE_RXQ_OCCUP_DESC_MASK(q)   	(1 << (MV_PP2_CAUSE_RXQ_OCCUP_DESC_BIT(q)))
+
+#define MV_PP2_CAUSE_TXQ_OCCUP_DESC_OFFS       	16
+#define MV_PP2_CAUSE_TXQ_OCCUP_DESC_BIT(q)     	(MV_PP2_CAUSE_TXQ_OCCUP_DESC_OFFS + (q))
+#define MV_PP2_CAUSE_TXQ_OCCUP_DESC_ALL_MASK   	(0xFF << MV_PP2_CAUSE_TXQ_OCCUP_DESC_OFFS)
+#define MV_PP2_CAUSE_TXQ_OCCUP_DESC_MASK(q)    	(1 << (MV_PP2_CAUSE_TXQ_SENT_DESC_BIT(q)))
+
+#define MV_PP2_CAUSE_RX_FIFO_OVERRUN_BIT        24
+#define MV_PP2_CAUSE_RX_FIFO_OVERRUN_MASK      	(1 << MV_PP2_CAUSE_RX_FIFO_OVERRUN_BIT)
+
+#define MV_PP2_CAUSE_FCS_ERR_BIT           	25
+#define MV_PP2_CAUSE_FCS_ERR_MASK          	(1 << MV_PP2_CAUSE_FCS_ERR_BIT)
+
+#define MV_PP2_CAUSE_TX_FIFO_UNDERRUN_BIT       26
+#define MV_PP2_CAUSE_TX_FIFO_UNDERRUN_MASK     	(1 << MV_PP2_CAUSE_TX_FIFO_UNDERRUN_BIT)
+
+#define MV_PP2_CAUSE_TX_EXCEPTION_SUM_BIT     	29
+#define MV_PP2_CAUSE_TX_EXCEPTION_SUM_MASK     	(1 << MV_PP2_CAUSE_TX_EXCEPTION_SUM_BIT)
+
+#define MV_PP2_CAUSE_RX_EXCEPTION_SUM_BIT     	30
+#define MV_PP2_CAUSE_RX_EXCEPTION_SUM_MASK     	(1 << MV_PP2_CAUSE_RX_EXCEPTION_SUM_BIT)
+
+#define MV_PP2_CAUSE_MISC_SUM_BIT     		31
+#define MV_PP2_CAUSE_MISC_SUM_MASK     		(1 << MV_PP2_CAUSE_MISC_SUM_BIT)
+
+#define MV_PP2_CAUSE_MISC_ERR_SUM_MASK		(0xE7000000)
+
+
+#define MV_PP2_ISR_PON_RX_TX_CAUSE_REG			(MV_PP2_REG_BASE + 0x549c)
+#define MV_PP2_ISR_PON_RX_TX_MASK_REG			(MV_PP2_REG_BASE + 0x54bc)
+
+#define MV_PP2_PON_CAUSE_RXQ_OCCUP_DESC_OFFS      	0
+#define MV_PP2_PON_CAUSE_RXQ_OCCUP_DESC_BIT(q)    	(MV_PP2_PON_CAUSE_RXQ_OCCUP_DESC_OFFS + (q))
+#define MV_PP2_PON_CAUSE_RXQ_OCCUP_DESC_ALL_MASK  	(0xFFFF << MV_PP2_PON_CAUSE_RXQ_OCCUP_DESC_OFFS)
+#define MV_PP2_PON_CAUSE_RXQ_OCCUP_DESC_MASK(q)   	(1 << (MV_PP2_PON_CAUSE_RXQ_OCCUP_DESC_BIT(q)))
+
+#define MV_PP2_PON_CAUSE_RX_FIFO_OVERRUN_BIT        	16
+#define MV_PP2_PON_CAUSE_RX_FIFO_OVERRUN_MASK      	(1 << MV_PP2_CAUSE_RX_FIFO_OVERRUN_BIT)
+
+#define MV_PP2_PON_CAUSE_FCS_ERR_BIT           		17
+#define MV_PP2_PON_CAUSE_FCS_ERR_MASK          		(1 << MV_PP2_PON_CAUSE_FCS_ERR_BIT)
+
+#define MV_PP2_PON_BYTE_COUNT_ERR_BIT          		18
+#define MV_PP2_PON_BYTE_COUNT_ERR_MASK         		(1 << MV_PP2_PON_BYTE_COUNT_ERR_BIT)
+
+#define MV_PP2_PON_CAUSE_TX_FIFO_UNDERRUN_BIT       	21
+#define MV_PP2_PON_CAUSE_TX_FIFO_UNDERRUN_MASK     	(1 << MV_PP2_PON_CAUSE_TX_FIFO_UNDERRUN_BIT)
+
+#define MV_PP2_PON_CAUSE_TXP_OCCUP_DESC_OFFS       	22
+#define MV_PP2_PON_CAUSE_TXP_OCCUP_DESC_ALL_MASK   	(0xFF << MV_PP2_PON_CAUSE_TXP_OCCUP_DESC_OFFS)
+
+#define MV_PP2_PON_CAUSE_TX_EXCEPTION_SUM_BIT     	29
+#define MV_PP2_PON_CAUSE_TX_EXCEPTION_SUM_MASK     	(1 << MV_PP2_PON_CAUSE_TX_EXCEPTION_SUM_BIT)
+
+#define MV_PP2_PON_CAUSE_RX_EXCEPTION_SUM_BIT     	30
+#define MV_PP2_PON_CAUSE_RX_EXCEPTION_SUM_MASK     	(1 << MV_PP2_PON_CAUSE_RX_EXCEPTION_SUM_BIT)
+
+#define MV_PP2_PON_CAUSE_MISC_SUM_BIT     		31
+#define MV_PP2_PON_CAUSE_MISC_SUM_MASK     		(1 << MV_PP2_PON_CAUSE_MISC_SUM_BIT)
+
+#define MV_PP2_PON_CAUSE_MISC_ERR_SUM_MASK		(0xC0270000)
+
+
+/* TCONT Cause registers 54c0 - 54cc */
+/* TCONT Mask registers 54d0 - 54dc */
+#define MV_PP2_ISR_RX_ERR_CAUSE_REG(port)	(MV_PP2_REG_BASE + 0x5500 + 4 * (port))
+#define MV_PP2_ISR_RX_ERR_MASK_REG(port)	(MV_PP2_REG_BASE + 0x5520 + 4 * (port))
+#define MV_PP2_ISR_TX_ERR_CAUSE_REG(port)	(MV_PP2_REG_BASE + 0x5500 + 4 * (port))
+#define MV_PP2_ISR_TX_ERR_MASK_REG(port)	(MV_PP2_REG_BASE + 0x5520 + 4 * (port))
+/* TCONT TX exception Cause registers 5580 - 558c */
+/* TCONT TX exception Mask registers 5590 - 559c */
+#define MV_PP2_ISR_PON_TX_UNDR_CAUSE_REG	(MV_PP2_REG_BASE + 0x55a0)
+#define MV_PP2_ISR_PON_TX_UNDR_MASK_REG		(MV_PP2_REG_BASE + 0x55a4)
+
+#define MV_PP2_ISR_MISC_CAUSE_REG			(MV_PP2_REG_BASE + 0x55b0)
+#define MV_PP2_ISR_MISC_MASK_REG			(MV_PP2_REG_BASE + 0x55b4)
+/*-------------------------------------------------------------------------------*/
+
+/******************************** Port Drop counters *****************************/
+#define MV_PP2_OVERRUN_DROP_REG(port)		(MV_PP2_REG_BASE + 0x7000 + 4 * (port))
+#define MV_PP2_CLS_DROP_REG(port)			(MV_PP2_REG_BASE + 0x7020 + 4 * (port))
+#define MV_PP2_POLICER_DROP_REG(plcr)		(MV_PP2_REG_BASE + 0x7040 + 4 * (plcr))
+#define MV_PP2_TX_EARLY_DROP_REG(eport)		(MV_PP2_REG_BASE + 0x7080 + 4 * (eport))
+#define MV_PP2_TX_DESC_DROP_REG(eport)		(MV_PP2_REG_BASE + 0x7100 + 4 * (eport))
+#define MV_PP2_RX_EARLY_DROP_REG(rxq)		(MV_PP2_REG_BASE + 0x7200 + 4 * (rxq))
+#define MV_PP2_RX_DESC_DROP_REG(rxq)		(MV_PP2_REG_BASE + 0x7400 + 4 * (rxq))
+/*-------------------------------------------------------------------------------*/
+
+
+/************************** TX Scheduler Registers ******************************/
+/* Indirect access */
+#define MV_PP2_TXP_SCHED_PORT_INDEX_REG		(MV_PP2_REG_BASE + 0x8000)
+
+#define MV_PP2_TXP_SCHED_Q_CMD_REG		(MV_PP2_REG_BASE + 0x8004)
+
+#define MV_PP2_TXP_SCHED_ENQ_OFFSET		0
+#define MV_PP2_TXP_SCHED_ENQ_MASK		(0xFF << MV_PP2_TXP_SCHED_ENQ_OFFSET)
+#define MV_PP2_TXP_SCHED_DISQ_OFFSET		8
+#define MV_PP2_TXP_SCHED_DISQ_MASK		(0xFF << MV_PP2_TXP_SCHED_DISQ_OFFSET)
+/*-----------------------------------------------------------------------------------------------*/
+
+#define MV_PP2_TXP_SCHED_CMD_1_REG		(MV_PP2_REG_BASE + 0x8010)
+
+#define MV_PP2_TXP_SCHED_RESET_BIT          	0
+#define MV_PP2_TXP_SCHED_RESET_MASK         	(1 << MV_PP2_TXP_SCHED_RESET_BIT)
+
+#define MV_PP2_TXP_SCHED_PTP_SYNC_BIT		1
+#define MV_PP2_TXP_SCHED_PTP_SYNC_MASK		(1 << MV_PP2_TXP_SCHED_PTP_SYNC_BIT)
+
+#define MV_PP2_TXP_SCHED_EJP_ENABLE_BIT     	2
+#define MV_PP2_TXP_SCHED_EJP_ENABLE_MASK	(1 << MV_PP2_TXP_SCHED_EJP_ENABLE_BIT)
+/*-----------------------------------------------------------------------------------------------*/
+
+/* Transmit Queue Fixed Priority Configuration (TQFPC) */
+#define MV_PP2_TXP_SCHED_FIXED_PRIO_REG		(MV_PP2_REG_BASE + 0x8014)
+
+#define MV_PP2_TXP_FIXED_PRIO_OFFS          	0
+#define MV_PP2_TXP_FIXED_PRIO_MASK          	(0xFF << MV_PP2_TX_FIXED_PRIO_OFFS)
+/*-----------------------------------------------------------------------------------------------*/
+
+/* Basic Refill No of Clocks (BRC) */
+#define MV_PP2_TXP_SCHED_PERIOD_REG		(MV_PP2_REG_BASE + 0x8018)
+
+#define MV_PP2_TXP_REFILL_CLOCKS_OFFS       	0
+#define MV_PP2_TXP_REFILL_CLOCKS_MIN        	16
+#define MV_PP2_TXP_REFILL_CLOCKS_MASK       	(0xFFFF << MV_PP2_TXP_REFILL_CLOCKS_OFFS)
+/*-----------------------------------------------------------------------------------------------*/
+
+/* Port Maximum Transmit Unit (PMTU) */
+#define MV_PP2_TXP_SCHED_MTU_REG		(MV_PP2_REG_BASE + 0x801c)
+
+#define MV_PP2_TXP_MTU_OFFS                 	0
+#define MV_PP2_TXP_MTU_MAX                  	0x3FFFF
+#define MV_PP2_TXP_MTU_ALL_MASK             	(MV_PP2_TXP_MTU_MAX << MV_PP2_TXP_MTU_OFFS)
+#define MV_PP2_TXP_MTU_MASK(mtu)            	((mtu) << MV_PP2_TXP_MTU_OFFS)
+/*-----------------------------------------------------------------------------------------------*/
+
+/* Port Bucket Refill (PRefill) */
+#define MV_PP2_TXP_SCHED_REFILL_REG		(MV_PP2_REG_BASE + 0x8020)
+
+#define MV_PP2_TXP_REFILL_TOKENS_OFFS       	0
+#define MV_PP2_TXP_REFILL_TOKENS_MAX        	0x7FFFF
+#define MV_PP2_TXP_REFILL_TOKENS_ALL_MASK   	(MV_PP2_TXP_REFILL_TOKENS_MAX << MV_PP2_TXP_REFILL_TOKENS_OFFS)
+#define MV_PP2_TXP_REFILL_TOKENS_MASK(val)  	((val) << MV_PP2_TXP_REFILL_TOKENS_OFFS)
+
+#define MV_PP2_TXP_REFILL_PERIOD_OFFS       	20
+#define MV_PP2_TXP_REFILL_PERIOD_MAX        	0x3FF
+#define MV_PP2_TXP_REFILL_PERIOD_ALL_MASK   	(MV_PP2_TXP_REFILL_PERIOD_MAX << MV_PP2_TXP_REFILL_PERIOD_OFFS)
+#define MV_PP2_TXP_REFILL_PERIOD_MASK(val)  	((val) << MV_PP2_TXP_REFILL_PERIOD_OFFS)
+/*-----------------------------------------------------------------------------------------------*/
+
+/* Port Maximum Token Bucket Size (PMTBS) */
+#define MV_PP2_TXP_SCHED_TOKEN_SIZE_REG		(MV_PP2_REG_BASE + 0x8024)
+#define MV_PP2_TXP_TOKEN_SIZE_MAX           	0xFFFFFFFF
+/*-----------------------------------------------------------------------------------------------*/
+
+/* Port Token Bucket Counter (PMTBS) */
+#define MV_PP2_TXP_SCHED_TOKEN_CNTR_REG		(MV_PP2_REG_BASE + 0x8028)
+#define MV_PP2_TXP_TOKEN_CNTR_MAX		0xFFFFFFFF
+/*-----------------------------------------------------------------------------------------------*/
+
+/* Queue Bucket Refill (QRefill) */
+#define MV_PP2_TXQ_SCHED_REFILL_REG(q)		(MV_PP2_REG_BASE + 0x8040 + ((q) << 2))
+
+#define MV_PP2_TXQ_REFILL_TOKENS_OFFS       	0
+#define MV_PP2_TXQ_REFILL_TOKENS_MAX        	0x7FFFF
+#define MV_PP2_TXQ_REFILL_TOKENS_ALL_MASK   	(MV_PP2_TXQ_REFILL_TOKENS_MAX << MV_PP2_TXQ_REFILL_TOKENS_OFFS)
+#define MV_PP2_TXQ_REFILL_TOKENS_MASK(val)  	((val) << MV_PP2_TXQ_REFILL_TOKENS_OFFS)
+
+#define MV_PP2_TXQ_REFILL_PERIOD_OFFS       	20
+#define MV_PP2_TXQ_REFILL_PERIOD_MAX        	0x3FF
+#define MV_PP2_TXQ_REFILL_PERIOD_ALL_MASK   	(MV_PP2_TXQ_REFILL_PERIOD_MAX << MV_PP2_TXQ_REFILL_PERIOD_OFFS)
+#define MV_PP2_TXQ_REFILL_PERIOD_MASK(val)  	((val) << MV_PP2_TXQ_REFILL_PERIOD_OFFS)
+/*-----------------------------------------------------------------------------------------------*/
+
+/* Queue Maximum Token Bucket Size (QMTBS) */
+#define MV_PP2_TXQ_SCHED_TOKEN_SIZE_REG(q)	(MV_PP2_REG_BASE + 0x8060 + ((q) << 2))
+#define MV_PP2_TXQ_TOKEN_SIZE_MAX           	0x7FFFFFFF
+/*-----------------------------------------------------------------------------------------------*/
+
+/* Queue Token Bucket Counter (PMTBS) */
+#define MV_PP2_TXQ_SCHED_TOKEN_CNTR_REG(q)	(MV_PP2_REG_BASE + 0x8080 + ((q) << 2))
+#define MV_PP2_TXQ_TOKEN_CNTR_MAX           	0xFFFFFFFF
+/*-----------------------------------------------------------------------------------------------*/
+
+/* Transmit Queue Arbiter Configuration (TQxAC) */
+#define MV_PP2_TXQ_SCHED_WRR_REG(q)		(MV_PP2_REG_BASE + 0x80A0 + ((q) << 2))
+
+#define MV_PP2_TXQ_WRR_WEIGHT_OFFS          	0
+#define MV_PP2_TXQ_WRR_WEIGHT_MAX           	0xFF
+#define MV_PP2_TXQ_WRR_WEIGHT_ALL_MASK      	(MV_PP2_TXQ_WRR_WEIGHT_MAX << MV_PP2_TXQ_WRR_WEIGHT_OFFS)
+#define MV_PP2_TXQ_WRR_WEIGHT_MASK(weigth)  	((weigth) << MV_PP2_TXQ_WRR_WEIGHT_OFFS)
+
+#define MV_PP2_TXQ_WRR_BYTE_COUNT_OFFS      	8
+#define MV_PP2_TXQ_WRR_BYTE_COUNT_MASK      	(0x3FFFF << MV_PP2_TXQ_WRR_BYTE_COUNT_OFFS)
+/*-----------------------------------------------------------------------------------------------*/
+
+#if 0 /* TBD - set EJP registers */
+/* Transmission Queue IPG (TQxIPG) */
+#define MV_PP2_TXQ_EJP_IPG_REG(q)		(MV_PP2_REG_BASE + 0x80C0 + ((q) >> 2))
+
+#define MV_PP2_TXQ_EJP_IPG_OFFS             	0
+#define MV_PP2_TXQ_EJP_IPG_MASK             	(0x3FFF << MV_PP2_TXQ_EJP_IPG_OFFS)
+/*-----------------------------------------------------------------------------------------------*/
+
+#define MV_PP2_TXP_EJP_HI_LO_REG		(MV_PP2_REG_BASE + 0x80D0)
+#define MV_PP2_TXP_EJP_HI_ASYNC_REG		(MV_PP2_REG_BASE + 0x80D4)
+#define MV_PP2_TXP_EJP_LO_ASYNC_REG		(MV_PP2_REG_BASE + 0x80D8)
+#define MV_PP2_TXP_EJP_SPEED_REG		(MV_PP2_REG_BASE + 0x80DC)
+#endif /* 0 */
+/*-----------------------------------------------------------------------------------------------*/
+
+/************************** PPv2 HW defines ******************************/
+#define MV_PP2_RX_FIFO_PORT_DATA_SIZE		0x2000
+#define MV_PP2_RX_FIFO_PORT_ATTR_SIZE		0x80
+#define MV_PP2_RX_FIFO_PORT_MIN_PKT		0x80
+
+#define MV_PP2_MAX_PORTS			8 	/* Maximum number of ports supported by PPv2 HW */
+#define MV_PP2_MAX_RXQS_TOTAL			256	/* Maximum number of RXQs supported by PPv2 HW for all ports */
+
+#define MV_PP2_DESC_ALIGNED_SIZE		32
+#define MV_PP2_DESC_Q_ALIGN			512
+/************************** RX/TX Descriptor defines and inlines ******************************/
+/* RXQ */
+typedef struct pp2_rx_desc {
+	MV_U32 status;
+	MV_U16 parserInfo;
+	MV_U16 dataSize;
+	MV_U32 bufPhysAddr;
+	MV_U32 bufCookie;
+	MV_U16 gemPortIdPktColor;
+	MV_U16 csumL4;
+	MV_U16 reserved;
+	MV_U16 classifyInfo;
+	MV_U32 flowId;
+	MV_U32 reserved2;
+} PP2_RX_DESC;
+
+/* Bits of "status" field */
+#define PP2_RX_L3_OFFSET_OFFS			0
+#define PP2_RX_L3_OFFSET_MASK			(0x7F << PP2_RX_L3_OFFSET_OFFS)
+
+#define PP2_RX_IP_HLEN_OFFS                	8
+#define PP2_RX_IP_HLEN_MASK                	(0x1F << PP2_RX_IP_HLEN_OFFS)
+
+#define PP2_RX_ERR_CODE_OFFS               	13
+#define PP2_RX_ERR_CODE_MASK               	(3 << PP2_RX_ERR_CODE_OFFS)
+#define PP2_RX_ERR_CRC                     	(0 << PP2_RX_ERR_CODE_OFFS)
+#define PP2_RX_ERR_OVERRUN                 	(1 << PP2_RX_ERR_CODE_OFFS)
+#define PP2_RX_RESERVED                    	(2 << PP2_RX_ERR_CODE_OFFS)
+#define PP2_RX_ERR_RESOURCE                	(3 << PP2_RX_ERR_CODE_OFFS)
+
+#define PP2_RX_ES_BIT                      	15
+#define PP2_RX_ES_MASK                     	(1 << PP2_RX_ES_BIT)
+
+#define PP2_RX_BM_POOL_ID_OFFS             	16
+#define PP2_RX_BM_POOL_ALL_MASK            	(0x3 << PP2_RX_BM_POOL_ID_OFFS)
+#define PP2_RX_BM_POOL_ID_MASK(pool)       	((pool) << PP2_RX_BM_POOL_ID_OFFS)
+
+#define PP2_RX_HWF_SYNC_BIT                	21
+#define PP2_RX_HWF_SYNC_MASK               	(1 << PP2_RX_HWF_SYNC_BIT)
+
+#define PP2_RX_L4_CHK_OK_BIT               	22
+#define PP2_RX_L4_CHK_OK_MASK              	(1 << PP2_RX_L4_CHK_OK_BIT)
+
+#define PP2_RX_IP_FRAG_BIT                 	23
+#define PP2_RX_IP_FRAG_MASK                	(1 << PP2_RX_IP_FRAG_BIT)
+
+#define PP2_RX_IP4_HEADER_ERR_BIT          	24
+#define PP2_RX_IP4_HEADER_ERR_MASK         	(1 << PP2_RX_IP4_HEADER_ERR_BIT)
+
+#define PP2_RX_L4_OFFS                     	25
+#define PP2_RX_L4_MASK                     	(7 << PP2_RX_L4_OFFS)
+/* Value 0 - N/A, 3-7 - User Defined */
+#define PP2_RX_L4_TCP                      	(1 << PP2_RX_L4_OFFS)
+#define PP2_RX_L4_UDP                      	(2 << PP2_RX_L4_OFFS)
+
+#define PP2_RX_L3_OFFS                     	28
+#define PP2_RX_L3_MASK                     	(7 << PP2_RX_L3_OFFS)
+/* Value 0 - N/A, 6-7 - User Defined */
+#define PP2_RX_L3_IP4                		(1 << PP2_RX_L3_OFFS)
+#define PP2_RX_L3_IP4_OPT          	   	(2 << PP2_RX_L3_OFFS)
+#define PP2_RX_L3_IP4_OTHER                	(3 << PP2_RX_L3_OFFS)
+#define PP2_RX_L3_IP6                  		(4 << PP2_RX_L3_OFFS)
+#define PP2_RX_L3_IP6_EXT              		(5 << PP2_RX_L3_OFFS)
+
+#define PP2_RX_BUF_HDR_BIT                 	31
+#define PP2_RX_BUF_HDR_MASK                	(1 << PP2_RX_BUF_HDR_BIT)
+
+/* status field MACROs */
+#define PP2_RX_L3_IS_IP4(status)		(((status) & PP2_RX_L3_MASK) == PP2_RX_L3_IP4) 
+#define PP2_RX_L3_IS_IP4_OPT(status)		(((status) & PP2_RX_L3_MASK) == PP2_RX_L3_IP4_OPT)
+#define PP2_RX_L3_IS_IP4_OTHER(status)		(((status) & PP2_RX_L3_MASK) == PP2_RX_L3_IP4_OTHER)
+#define PP2_RX_L3_IS_IP6(status)		(((status) & PP2_RX_L3_MASK) == PP2_RX_L3_IP6)
+#define PP2_RX_L3_IS_IP6_EXT(status)		(((status) & PP2_RX_L3_MASK) == PP2_RX_L3_IP6_EXT)
+#define PP2_RX_L4_IS_UDP(status)      		(((status) & PP2_RX_L4_MASK) == PP2_RX_L4_UDP)
+#define PP2_RX_L4_IS_TCP(status)		(((status) & PP2_RX_L4_MASK) == PP2_RX_L4_TCP)
+#define PP2_RX_IP4_HDR_ERR(status)		((status) & PP2_RX_IP4_HEADER_ERR_MASK)
+#define PP2_RX_IP4_FRG(status)			((status) & PP2_RX_IP_FRAG_MASK)
+#define PP2_RX_L4_CHK_OK(status)		((status) & PP2_RX_L4_CHK_OK_MASK)
+
+/* Bits of "parserInfo" field */
+#define PP2_RX_LKP_ID_OFFS              	0
+#define PP2_RX_LKP_ID_BITS			6				
+#define PP2_RX_LKP_ID_MASK              	(((1 << PP2_RX_LKP_ID_BITS) - 1) << PP2_RX_LKP_ID_OFFS)
+
+#define PP2_RX_CPU_CODE_OFFS			6
+#define PP2_RX_CPU_CODE_MASK			((0x7) << PP2_RX_CPU_CODE_OFFS)
+#define PP2_RX_SPECIAL				(1 << PP2_RX_CPU_CODE_OFFS)
+#define PP2_RX_IS_RX_SPECIAL(parserInfo)	(((parserInfo) & PP2_RX_CPU_CODE_MASK) == PP2_RX_SPECIAL)
+
+#define PP2_RX_PRS_INFO_OFFS            	6
+#define PP2_RX_PRS_INFO_BITS			10				
+#define PP2_RX_PRS_INFO_MASK            	(((1 << PP2_RX_PRS_INFO_BITS) - 1) << PP2_RX_PRS_INFO_OFFS)
+/*-------------------------------------------------------------------------------*/
+
+/* TXQ */
+typedef struct pp2_tx_desc {
+	MV_U32 command;
+	MV_U8  pktOffset;
+	MV_U8  physTxq;
+	MV_U16 dataSize;
+	MV_U32 bufPhysAddr;
+	MV_U32 bufCookie;
+	MV_U16 ponHwCmd;
+	MV_U16 initialCsumL4;
+	MV_U16 reserved;
+	MV_U16 modifyInfo[3];
+	MV_U32 reserved2;
+} PP2_TX_DESC;
+
+/* Bits of "command" field */
+#define PP2_TX_L3_OFFSET_OFFS			0
+#define PP2_TX_L3_OFFSET_MASK			(0x7F << PP2_TX_L3_OFFSET_OFFS)
+
+#define PP2_TX_BUF_RELEASE_MODE_BIT		7
+#define PP2_TX_BUF_RELEASE_MODE_MASK		(1 << PP2_TX_BUF_RELEASE_MODE_BIT)
+
+#define PP2_TX_IP_HLEN_OFFS			8
+#define PP2_TX_IP_HLEN_MASK			(0x1F << PP2_TX_IP_HLEN_OFFS)
+
+#define PP2_TX_L4_CSUM_OFFS			13
+#define PP2_TX_L4_CSUM_MASK			(3 << PP2_TX_L4_CSUM_OFFS)
+#define PP2_TX_L4_CSUM				(0 << PP2_TX_L4_CSUM_OFFS)
+#define PP2_TX_L4_CSUM_FRG			(1 << PP2_TX_L4_CSUM_OFFS)
+#define PP2_TX_L4_CSUM_NOT			(2 << PP2_TX_L4_CSUM_OFFS)
+
+#define PP2_TX_IP_CSUM_DISABLE_BIT		15
+#define PP2_TX_IP_CSUM_DISABLE_MASK		(1 << PP2_TX_IP_CSUM_DISABLE_BIT)
+
+#define PP2_TX_PADDING_DISABLE_BIT		23
+#define PP2_TX_PADDING_DISABLE_MASK		(1 << PP2_TX_PADDING_DISABLE_BIT)
+
+#define PP2_TX_L4_OFFS				24
+#define PP2_TX_L4_TCP				(0 << PP2_TX_L4_OFFS)
+#define PP2_TX_L4_UDP				(1 << PP2_TX_L4_OFFS)
+
+#define PP2_TX_L3_OFFS				26
+#define PP2_TX_L3_IP4				(0 << PP2_TX_L3_OFFS)
+#define PP2_TX_L3_IP6				(1 << PP2_TX_L3_OFFS)
+
+#define PP2_TX_L_DESC_BIT			28
+#define PP2_TX_L_DESC_MASK			(1 << PP2_TX_L_DESC_BIT)
+
+#define PP2_TX_F_DESC_BIT			29
+#define PP2_TX_F_DESC_MASK			(1 << PP2_TX_F_DESC_BIT)
+
+/************************** Buffer Header defines ******************************/
+typedef struct pp2_buff_hdr {
+	MV_U32 nextBuffPhysAddr;
+	MV_U32 nextBuffVirtAddr;
+	MV_U16 byteCount;
+	MV_U16 info;
+} PP2_BUFF_HDR;
+
+#define PP2_BUFF_HDR_INFO_MC_ID_OFFS		0
+#define PP2_BUFF_HDR_INFO_MC_ID_MASK		(0xfff << PP2_BUFF_HDR_INFO_MC_ID_OFFS)
+#define PP2_BUFF_HDR_INFO_MC_ID(info)		((info & PP2_BUFF_HDR_INFO_MC_ID_MASK) >> PP2_BUFF_HDR_INFO_MC_ID_OFFS)
+
+#define PP2_BUFF_HDR_INFO_LAST_OFFS		12
+#define PP2_BUFF_HDR_INFO_LAST_MASK		(0x1 << PP2_BUFF_HDR_INFO_LAST_OFFS)
+#define PP2_BUFF_HDR_INFO_IS_LAST(info)		((info & PP2_BUFF_HDR_INFO_LAST_MASK) >> PP2_BUFF_HDR_INFO_LAST_OFFS)
+
+/************************** Ethernet misc ******************************/
+
+#define ETH_MAX_DECODE_WIN              	6
+#define ETH_MAX_HIGH_ADDR_REMAP_WIN     	4
+
+/**** Address decode registers ****/
+
+#define ETH_WIN_BASE_REG(win)         		(MV_PP2_REG_BASE + 0x4000 + ((win) << 2))
+#define ETH_WIN_SIZE_REG(win)         		(MV_PP2_REG_BASE + 0x4020 + ((win) << 2))
+#define ETH_WIN_REMAP_REG(win)        		(MV_PP2_REG_BASE + 0x4040 + ((win) << 2))
+#define ETH_BASE_ADDR_ENABLE_REG      		(MV_PP2_REG_BASE + 0x4060)
+
+/* The target associated with this window*/
+#define ETH_WIN_TARGET_OFFS                 	0
+#define ETH_WIN_TARGET_MASK                 	(0xf << ETH_WIN_TARGET_OFFS)
+/* The target attributes associated with window */
+#define ETH_WIN_ATTR_OFFS                   	8
+#define ETH_WIN_ATTR_MASK                   	(0xff << ETH_WIN_ATTR_OFFS)
+
+/* The Base address associated with window */
+#define ETH_WIN_BASE_OFFS		        16
+#define ETH_WIN_BASE_MASK		        (0xFFFF << ETH_WIN_BASE_OFFS)
+
+#define ETH_WIN_SIZE_OFFS		        16
+#define ETH_WIN_SIZE_MASK		        (0xFFFF << ETH_WIN_SIZE_OFFS)
+/*-----------------------------------------------------------------------------------------------*/
+
+#define ETH_TARGET_DEF_ADDR_REG      		(MV_PP2_REG_BASE + 0x4064)
+#define ETH_TARGET_DEF_ID_REG      			(MV_PP2_REG_BASE + 0x4068)
+/*-----------------------------------------------------------------------------------------------*/
+
+#endif /* MV_PP2_GBE_REGS_H */
+
+
+
diff --git a/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.c b/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.c
new file mode 100644
index 0000000..04701c9
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.c
@@ -0,0 +1,644 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#include "pp2/gbe/mvPp2Gbe.h"
+#include "mvEthGmacApi.h"
+
+void mvEthPortEnable(int port)
+{
+	MV_U32 regVal;
+
+	regVal = MV_REG_READ(ETH_GMAC_CTRL_0_REG(port));
+	regVal |= ETH_GMAC_PORT_EN_MASK;
+
+	mvPp2WrReg(ETH_GMAC_CTRL_0_REG(port), regVal);
+}
+
+void mvEthPortDisable(int port)
+{
+	MV_U32 regVal;
+
+	regVal = MV_REG_READ(ETH_GMAC_CTRL_0_REG(port));
+	regVal &= ~(ETH_GMAC_PORT_EN_MASK);
+	mvPp2WrReg(ETH_GMAC_CTRL_0_REG(port), regVal);
+}
+
+static void mvEthPortRgmiiSet(int port, int enable)
+{
+	MV_U32  regVal;
+
+	regVal = MV_REG_READ(ETH_GMAC_CTRL_2_REG(port));
+	if (enable)
+		regVal |= ETH_GMAC_PORT_RGMII_MASK;
+	else
+		regVal &= ~ETH_GMAC_PORT_RGMII_MASK;
+
+	mvPp2WrReg(ETH_GMAC_CTRL_2_REG(port), regVal);
+}
+
+static void mvEthPortSgmiiSet(int port, int enable)
+{
+	MV_U32 regVal;
+
+	regVal = MV_REG_READ(ETH_GMAC_CTRL_2_REG(port));
+	if (enable)
+		regVal |= ETH_GMAC_PCS_ENABLE_MASK;
+	else
+		regVal &= ~ETH_GMAC_PCS_ENABLE_MASK;
+
+	mvPp2WrReg(ETH_GMAC_CTRL_2_REG(port), regVal);
+}
+
+void mvEthPortLbSet(int port, int isGmii, int isPcsEn)
+{
+	MV_U32 regVal;
+
+	regVal = MV_REG_READ(ETH_GMAC_CTRL_1_REG(port));
+
+	if (isGmii)
+		regVal |= ETH_GMAC_GMII_LB_EN_MASK;
+	else
+		regVal &= ~ETH_GMAC_GMII_LB_EN_MASK;
+
+	if (isPcsEn)
+		regVal |= ETH_GMAC_PCS_LB_EN_MASK;
+	else
+		regVal &= ~ETH_GMAC_PCS_LB_EN_MASK;
+
+	mvPp2WrReg(ETH_GMAC_CTRL_1_REG(port), regVal);
+}
+
+void mvEthPortPowerUp(int port, MV_BOOL isSgmii, MV_BOOL isRgmii)
+{
+	MV_U32 regVal;
+
+	mvEthPortSgmiiSet(port, isSgmii);
+	mvEthPortRgmiiSet(port, isRgmii);
+
+	/* Cancel Port Reset */
+	regVal = MV_REG_READ(ETH_GMAC_CTRL_2_REG(port));
+	regVal &= (~ETH_GMAC_PORT_RESET_MASK);
+	mvPp2WrReg(ETH_GMAC_CTRL_2_REG(port), regVal);
+	while ((MV_REG_READ(ETH_GMAC_CTRL_2_REG(port)) & ETH_GMAC_PORT_RESET_MASK) != 0)
+		continue;
+}
+
+void mvEthPortPowerDown(int port)
+{
+}
+
+MV_BOOL mvEthPortIsLinkUp(int port)
+{
+	return (MV_REG_READ(ETH_GMAC_STATUS_REG(port)) & ETH_GMAC_LINK_UP_MASK);
+}
+
+MV_STATUS mvEthLinkStatus(int port, MV_ETH_PORT_STATUS *pStatus)
+{
+	MV_U32 regVal;
+
+	if (MV_PON_PORT(port)) {
+		pStatus->linkup = MV_TRUE;
+		pStatus->speed = MV_ETH_SPEED_1000;
+		pStatus->duplex = MV_ETH_DUPLEX_FULL;
+		pStatus->rxFc = MV_ETH_FC_DISABLE;
+		pStatus->txFc = MV_ETH_FC_DISABLE;
+		return MV_OK;
+	}
+
+	regVal = MV_REG_READ(ETH_GMAC_STATUS_REG(port));
+
+	if (regVal & ETH_GMAC_SPEED_1000_MASK)
+		pStatus->speed = MV_ETH_SPEED_1000;
+	else if (regVal & ETH_GMAC_SPEED_100_MASK)
+		pStatus->speed = MV_ETH_SPEED_100;
+	else
+		pStatus->speed = MV_ETH_SPEED_10;
+
+	if (regVal & ETH_GMAC_LINK_UP_MASK)
+		pStatus->linkup = MV_TRUE;
+	else
+		pStatus->linkup = MV_FALSE;
+
+	if (regVal & ETH_GMAC_FULL_DUPLEX_MASK)
+		pStatus->duplex = MV_ETH_DUPLEX_FULL;
+	else
+		pStatus->duplex = MV_ETH_DUPLEX_HALF;
+
+	if (regVal & ETH_TX_FLOW_CTRL_ACTIVE_MASK)
+		pStatus->txFc = MV_ETH_FC_ACTIVE;
+	else if (regVal & ETH_TX_FLOW_CTRL_ENABLE_MASK)
+		pStatus->txFc = MV_ETH_FC_ENABLE;
+	else
+		pStatus->txFc = MV_ETH_FC_DISABLE;
+
+	if (regVal & ETH_RX_FLOW_CTRL_ACTIVE_MASK)
+		pStatus->rxFc = MV_ETH_FC_ACTIVE;
+	else if (regVal & ETH_RX_FLOW_CTRL_ENABLE_MASK)
+		pStatus->rxFc = MV_ETH_FC_ENABLE;
+	else
+		pStatus->rxFc = MV_ETH_FC_DISABLE;
+
+	return MV_OK;
+}
+/******************************************************************************/
+/*                          Port Configuration functions                      */
+/******************************************************************************/
+
+/*******************************************************************************
+* mvNetaMaxRxSizeSet -
+*
+* DESCRIPTION:
+*       Change maximum receive size of the port. This configuration will take place
+*       imidiately.
+*
+* INPUT:
+*
+* RETURN:
+*******************************************************************************/
+void mvEthMaxRxSizeSet(int port, int maxRxSize)
+{
+    MV_U32		regVal;
+
+	if (!MV_PON_PORT(port)) {
+
+		regVal =  MV_REG_READ(ETH_GMAC_CTRL_0_REG(port));
+		regVal &= ~ETH_GMAC_MAX_RX_SIZE_MASK;
+		regVal |= (((maxRxSize - MV_ETH_MH_SIZE) / 2) << ETH_GMAC_MAX_RX_SIZE_OFFS);
+		mvPp2WrReg(ETH_GMAC_CTRL_0_REG(port), regVal);
+/*
+		mvOsPrintf("%s: port=%d, maxRxSize=%d, regAddr=0x%x, regVal=0x%x\n",
+			__func__, port, maxRxSize, ETH_GMAC_CTRL_0_REG(port), regVal);
+*/
+	}
+}
+
+/*******************************************************************************
+* mvEthForceLinkModeSet -
+*
+* DESCRIPTION:
+*       Sets "Force Link Pass" and "Do Not Force Link Fail" bits.
+* 	Note: This function should only be called when the port is disabled.
+*
+* INPUT:
+* 	int		portNo			- port number
+* 	MV_BOOL force_link_pass	- Force Link Pass
+* 	MV_BOOL force_link_fail - Force Link Failure
+*		0, 0 - normal state: detect link via PHY and connector
+*		1, 1 - prohibited state.
+*
+* RETURN:
+*******************************************************************************/
+MV_STATUS mvEthForceLinkModeSet(int portNo, MV_BOOL force_link_up, MV_BOOL force_link_down)
+{
+	MV_U32	regVal;
+
+	/* Can't force link pass and link fail at the same time */
+	if ((force_link_up) && (force_link_down))
+		return MV_BAD_PARAM;
+
+	regVal = MV_REG_READ(ETH_GMAC_AN_CTRL_REG(portNo));
+
+	if (force_link_up)
+		regVal |= ETH_FORCE_LINK_PASS_MASK;
+	else
+		regVal &= ~ETH_FORCE_LINK_PASS_MASK;
+
+	if (force_link_down)
+		regVal |= ETH_FORCE_LINK_FAIL_MASK;
+	else
+		regVal &= ~ETH_FORCE_LINK_FAIL_MASK;
+
+	mvPp2WrReg(ETH_GMAC_AN_CTRL_REG(portNo), regVal);
+
+    return MV_OK;
+}
+
+/*******************************************************************************
+* mvEthSpeedDuplexSet -
+*
+* DESCRIPTION:
+*       Sets port speed to Auto Negotiation / 1000 / 100 / 10 Mbps.
+*	Sets port duplex to Auto Negotiation / Full / Half Duplex.
+*
+* INPUT:
+* 	int portNo - port number
+* 	MV_ETH_PORT_SPEED speed - port speed
+*	MV_ETH_PORT_DUPLEX duplex - port duplex mode
+*
+* RETURN:
+*******************************************************************************/
+MV_STATUS mvEthSpeedDuplexSet(int portNo, MV_ETH_PORT_SPEED speed, MV_ETH_PORT_DUPLEX duplex)
+{
+	MV_U32 regVal;
+
+	/* Check validity */
+	if ((speed == MV_ETH_SPEED_1000) && (duplex == MV_ETH_DUPLEX_HALF))
+		return MV_BAD_PARAM;
+
+	regVal = MV_REG_READ(ETH_GMAC_AN_CTRL_REG(portNo));
+
+	switch (speed) {
+	case MV_ETH_SPEED_AN:
+		regVal |= ETH_ENABLE_SPEED_AUTO_NEG_MASK;
+		/* the other bits don't matter in this case */
+		break;
+	case MV_ETH_SPEED_1000:
+		regVal &= ~ETH_ENABLE_SPEED_AUTO_NEG_MASK;
+		regVal |= ETH_SET_GMII_SPEED_1000_MASK;
+		regVal &= ~ETH_SET_MII_SPEED_100_MASK;
+		/* the 100/10 bit doesn't matter in this case */
+		break;
+	case MV_ETH_SPEED_100:
+		regVal &= ~ETH_ENABLE_SPEED_AUTO_NEG_MASK;
+		regVal &= ~ETH_SET_GMII_SPEED_1000_MASK;
+		regVal |= ETH_SET_MII_SPEED_100_MASK;
+		break;
+	case MV_ETH_SPEED_10:
+		regVal &= ~ETH_ENABLE_SPEED_AUTO_NEG_MASK;
+		regVal &= ~ETH_SET_GMII_SPEED_1000_MASK;
+		regVal &= ~ETH_SET_MII_SPEED_100_MASK;
+		break;
+	default:
+		mvOsPrintf("Unexpected Speed value %d\n", speed);
+		return MV_BAD_PARAM;
+	}
+
+	switch (duplex) {
+	case MV_ETH_DUPLEX_AN:
+		regVal  |= ETH_ENABLE_DUPLEX_AUTO_NEG_MASK;
+		/* the other bits don't matter in this case */
+		break;
+	case MV_ETH_DUPLEX_HALF:
+		regVal &= ~ETH_ENABLE_DUPLEX_AUTO_NEG_MASK;
+		regVal &= ~ETH_SET_FULL_DUPLEX_MASK;
+		break;
+	case MV_ETH_DUPLEX_FULL:
+		regVal &= ~ETH_ENABLE_DUPLEX_AUTO_NEG_MASK;
+		regVal |= ETH_SET_FULL_DUPLEX_MASK;
+		break;
+	default:
+		mvOsPrintf("Unexpected Duplex value %d\n", duplex);
+		return MV_BAD_PARAM;
+	}
+
+	mvPp2WrReg(ETH_GMAC_AN_CTRL_REG(portNo), regVal);
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvEthSpeedDuplexGet -
+*
+* DESCRIPTION:
+*       Gets port speed
+*	Gets port duplex
+*
+* INPUT:
+* 	int portNo - port number
+* OUTPUT:
+* 	MV_ETH_PORT_SPEED *speed - port speed
+*	MV_ETH_PORT_DUPLEX *duplex - port duplex mode
+*
+* RETURN:
+*******************************************************************************/
+MV_STATUS mvEthSpeedDuplexGet(int portNo, MV_ETH_PORT_SPEED *speed, MV_ETH_PORT_DUPLEX *duplex)
+{
+	MV_U32 regVal;
+
+	/* Check validity */
+	if (!speed || !duplex)
+		return MV_BAD_PARAM;
+
+	regVal = MV_REG_READ(ETH_GMAC_AN_CTRL_REG(portNo));
+	if (regVal & ETH_ENABLE_SPEED_AUTO_NEG_MASK)
+		*speed = MV_ETH_SPEED_AN;
+	else if (regVal & ETH_SET_GMII_SPEED_1000_MASK)
+		*speed = MV_ETH_SPEED_1000;
+	else if (regVal & ETH_SET_MII_SPEED_100_MASK)
+		*speed = MV_ETH_SPEED_100;
+	else
+		*speed = MV_ETH_SPEED_10;
+
+	if (regVal & ETH_ENABLE_DUPLEX_AUTO_NEG_MASK)
+		*duplex = MV_ETH_DUPLEX_AN;
+	else if (regVal & ETH_SET_FULL_DUPLEX_MASK)
+		*duplex = MV_ETH_DUPLEX_FULL;
+	else
+		*duplex = MV_ETH_DUPLEX_HALF;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvEthFlowCtrlSet - Set Flow Control of the port.
+*
+* DESCRIPTION:
+*       This function configures the port's Flow Control properties.
+*
+* INPUT:
+*       int				port		- Port number
+*       MV_ETH_PORT_FC  flowControl - Flow control of the port.
+*
+* RETURN:   MV_STATUS
+*       MV_OK           - Success
+*       MV_OUT_OF_RANGE - Failed. Port is out of valid range
+*       MV_BAD_VALUE    - Value flowControl parameters is not valid
+*
+*******************************************************************************/
+MV_STATUS mvEthFlowCtrlSet(int port, MV_ETH_PORT_FC flowControl)
+{
+	MV_U32 regVal;
+
+	regVal = MV_REG_READ(ETH_GMAC_AN_CTRL_REG(port));
+
+	switch (flowControl) {
+	case MV_ETH_FC_AN_NO:
+		regVal |= ETH_ENABLE_FLOW_CONTROL_AUTO_NEG_MASK;
+		regVal &= ~ETH_FLOW_CONTROL_ADVERTISE_MASK;
+		regVal &= ~ETH_FLOW_CONTROL_ASYMETRIC_MASK;
+		break;
+
+	case MV_ETH_FC_AN_SYM:
+		regVal |= ETH_ENABLE_FLOW_CONTROL_AUTO_NEG_MASK;
+		regVal |= ETH_FLOW_CONTROL_ADVERTISE_MASK;
+		regVal &= ~ETH_FLOW_CONTROL_ASYMETRIC_MASK;
+		break;
+
+	case MV_ETH_FC_AN_ASYM:
+		regVal |= ETH_ENABLE_FLOW_CONTROL_AUTO_NEG_MASK;
+		regVal |= ETH_FLOW_CONTROL_ADVERTISE_MASK;
+		regVal |= ETH_FLOW_CONTROL_ASYMETRIC_MASK;
+		break;
+
+	case MV_ETH_FC_DISABLE:
+		regVal &= ~ETH_ENABLE_FLOW_CONTROL_AUTO_NEG_MASK;
+		regVal &= ~ETH_SET_FLOW_CONTROL_MASK;
+		break;
+
+	case MV_ETH_FC_ENABLE:
+		regVal &= ~ETH_ENABLE_FLOW_CONTROL_AUTO_NEG_MASK;
+		regVal |= ETH_SET_FLOW_CONTROL_MASK;
+		break;
+
+	default:
+		mvOsPrintf("ethDrv: Unexpected FlowControl value %d\n", flowControl);
+		return MV_BAD_VALUE;
+	}
+
+	mvPp2WrReg(ETH_GMAC_AN_CTRL_REG(port), regVal);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvEthFlowCtrlGet - Get Flow Control configuration of the port.
+*
+* DESCRIPTION:
+*       This function returns the port's Flow Control properties.
+*
+* INPUT:
+*       int				port		- Port number
+*
+* OUTPUT:
+*       MV_ETH_PORT_FC  *flowCntrl	- Flow control of the port.
+*
+* RETURN:   MV_STATUS
+*       MV_OK           - Success
+*       MV_OUT_OF_RANGE - Failed. Port is out of valid range
+*
+*******************************************************************************/
+MV_STATUS mvEthFlowCtrlGet(int port, MV_ETH_PORT_FC *pFlowCntrl)
+{
+	MV_U32 regVal;
+
+	regVal = MV_REG_READ(ETH_GMAC_AN_CTRL_REG(port));
+
+	if (regVal & ETH_ENABLE_FLOW_CONTROL_AUTO_NEG_MASK) {
+		/* Auto negotiation is enabled */
+		if (regVal & ETH_FLOW_CONTROL_ADVERTISE_MASK) {
+			if (regVal & ETH_FLOW_CONTROL_ASYMETRIC_MASK)
+				*pFlowCntrl = MV_ETH_FC_AN_ASYM;
+			else
+				*pFlowCntrl = MV_ETH_FC_AN_SYM;
+		} else
+			*pFlowCntrl = MV_ETH_FC_AN_NO;
+	} else {
+		/* Auto negotiation is disabled */
+		if (regVal & ETH_SET_FLOW_CONTROL_MASK)
+			*pFlowCntrl = MV_ETH_FC_ENABLE;
+		else
+			*pFlowCntrl = MV_ETH_FC_DISABLE;
+	}
+	return MV_OK;
+}
+
+/******************************************************************************/
+/*                         PHY Control Functions                              */
+/******************************************************************************/
+void mvEthPhyAddrSet(int port, int phyAddr)
+{
+	unsigned int regData;
+
+	regData = MV_REG_READ(ETH_PHY_ADDR_REG);
+
+	regData &= ~ETH_PHY_ADDR_MASK(port);
+	regData |= (phyAddr << ETH_PHY_ADDR_OFFS(port));
+
+	mvPp2WrReg(ETH_PHY_ADDR_REG, regData);
+
+	return;
+}
+
+int mvEthPhyAddrGet(int port)
+{
+	unsigned int 	regData;
+
+	regData = MV_REG_READ(ETH_PHY_ADDR_REG);
+
+	return ((regData & ETH_PHY_ADDR_MASK(port)) >> ETH_PHY_ADDR_OFFS(port));
+}
+
+/******************************************************************************/
+/*                      MIB Counters functions                                */
+/******************************************************************************/
+
+/*******************************************************************************
+* mvEthMibCounterRead - Read a MIB counter
+*
+* DESCRIPTION:
+*       This function reads a MIB counter of a specific ethernet port.
+*       NOTE - Read from ETH_MIB_GOOD_OCTETS_RECEIVED_LOW or
+*              ETH_MIB_GOOD_OCTETS_SENT_LOW counters will return 64 bits value,
+*              so pHigh32 pointer should not be NULL in this case.
+*
+* INPUT:
+*       port        - Ethernet Port number.
+*       mibOffset   - MIB counter offset.
+*
+* OUTPUT:
+*       MV_U32*       pHigh32 - pointer to place where 32 most significant bits
+*                             of the counter will be stored.
+*
+* RETURN:
+*       32 low sgnificant bits of MIB counter value.
+*
+*******************************************************************************/
+MV_U32 mvEthMibCounterRead(int port, unsigned int mibOffset, MV_U32 *pHigh32)
+{
+	MV_U32 valLow32, valHigh32;
+
+	valLow32 = MV_REG_READ(ETH_MIB_COUNTERS_BASE(port) + mibOffset);
+
+	/* Implement FEr ETH. Erroneous Value when Reading the Upper 32-bits    */
+	/* of a 64-bit MIB Counter.                                             */
+	if ((mibOffset == ETH_MIB_GOOD_OCTETS_RECEIVED_LOW) || (mibOffset == ETH_MIB_GOOD_OCTETS_SENT_LOW)) {
+		valHigh32 = MV_REG_READ(ETH_MIB_COUNTERS_BASE(port) + mibOffset + 4);
+		if (pHigh32 != NULL)
+			*pHigh32 = valHigh32;
+	}
+	return valLow32;
+}
+
+/*******************************************************************************
+* mvEthMibCountersClear - Clear all MIB counters
+*
+* DESCRIPTION:
+*       This function clears all MIB counters
+*
+* INPUT:
+*       port      - Ethernet Port number.
+*
+* RETURN:   void
+*
+*******************************************************************************/
+void mvEthMibCountersClear(int port)
+{
+	int i;
+	MV_U32 dummy;
+
+#if defined(CONFIG_MV_PON) && !defined(MV_PON_MIB_SUPPORT)
+	if (MV_PON_PORT(port))
+		return;
+#endif /* CONFIG_MV_PON && !MV_PON_MIB_SUPPORT */
+
+	/* Perform dummy reads from MIB counters */
+	for (i = ETH_MIB_GOOD_OCTETS_RECEIVED_LOW; i < ETH_MIB_LATE_COLLISION; i += 4)
+		dummy = MV_REG_READ((ETH_MIB_COUNTERS_BASE(port) + i));
+}
+
+static void mvEthMibPrint(int port, MV_U32 offset, char *mib_name)
+{
+	MV_U32 regVaLo, regValHi = 0;
+
+	regVaLo = mvEthMibCounterRead(port, offset, &regValHi);
+
+	if (!regValHi)
+		mvOsPrintf("  %-32s: %u\n", mib_name, regVaLo);
+	else
+		mvOsPrintf("  t%-32s: 0x%08x%08x\n", mib_name, regValHi, regVaLo);
+}
+
+/* Print MIB counters of the Ethernet port */
+void mvEthMibCountersShow(int port)
+{
+	if (MV_PON_PORT(port)) {
+		mvOsPrintf("%s: not supported for PON port\n", __func__);
+		return;
+	}
+
+/*TODO: check port
+	if (mvNetaTxpCheck(port))
+		return;
+*/
+	mvOsPrintf("\nMIBs: port=%d\n", port);
+
+	mvOsPrintf("\n[Rx]\n");
+	mvEthMibPrint(port, ETH_MIB_GOOD_FRAMES_RECEIVED, "GOOD_FRAMES_RECEIVED");
+	mvEthMibPrint(port, ETH_MIB_BAD_FRAMES_RECEIVED, "BAD_FRAMES_RECEIVED");
+	mvEthMibPrint(port, ETH_MIB_BROADCAST_FRAMES_RECEIVED, "BROADCAST_FRAMES_RECEIVED");
+	mvEthMibPrint(port, ETH_MIB_MULTICAST_FRAMES_RECEIVED, "MULTICAST_FRAMES_RECEIVED");
+	mvEthMibPrint(port, ETH_MIB_GOOD_OCTETS_RECEIVED_LOW, "GOOD_OCTETS_RECEIVED");
+	mvOsPrintf("\n[Rx Errors]\n");
+	mvEthMibPrint(port, ETH_MIB_BAD_OCTETS_RECEIVED, "BAD_OCTETS_RECEIVED");
+	mvEthMibPrint(port, ETH_MIB_UNDERSIZE_RECEIVED, "UNDERSIZE_RECEIVED");
+	mvEthMibPrint(port, ETH_MIB_FRAGMENTS_RECEIVED, "FRAGMENTS_RECEIVED");
+	mvEthMibPrint(port, ETH_MIB_OVERSIZE_RECEIVED, "OVERSIZE_RECEIVED");
+	mvEthMibPrint(port, ETH_MIB_JABBER_RECEIVED, "JABBER_RECEIVED");
+	mvEthMibPrint(port, ETH_MIB_MAC_RECEIVE_ERROR, "MAC_RECEIVE_ERROR");
+	mvEthMibPrint(port, ETH_MIB_BAD_CRC_EVENT, "BAD_CRC_EVENT");
+	mvOsPrintf("\n[Tx]\n");
+	mvEthMibPrint(port, ETH_MIB_GOOD_FRAMES_SENT, "GOOD_FRAMES_SENT");
+	mvEthMibPrint(port, ETH_MIB_BROADCAST_FRAMES_SENT, "BROADCAST_FRAMES_SENT");
+	mvEthMibPrint(port, ETH_MIB_MULTICAST_FRAMES_SENT, "MULTICAST_FRAMES_SENT");
+	mvEthMibPrint(port, ETH_MIB_GOOD_OCTETS_SENT_LOW, "GOOD_OCTETS_SENT");
+	mvOsPrintf("\n[Tx Errors]\n");
+	mvEthMibPrint(port, ETH_MIB_INTERNAL_MAC_TRANSMIT_ERR, "INTERNAL_MAC_TRANSMIT_ERR");
+	mvEthMibPrint(port, ETH_MIB_EXCESSIVE_COLLISION, "EXCESSIVE_COLLISION");
+	mvEthMibPrint(port, ETH_MIB_COLLISION, "COLLISION");
+	mvEthMibPrint(port, ETH_MIB_LATE_COLLISION, "LATE_COLLISION");
+	mvOsPrintf("\n[FC control]\n");
+	mvEthMibPrint(port, ETH_MIB_UNREC_MAC_CONTROL_RECEIVED, "UNREC_MAC_CONTROL_RECEIVED");
+	mvEthMibPrint(port, ETH_MIB_GOOD_FC_RECEIVED, "GOOD_FC_RECEIVED");
+	mvEthMibPrint(port, ETH_MIB_BAD_FC_RECEIVED, "BAD_FC_RECEIVED");
+	mvEthMibPrint(port, ETH_MIB_FC_SENT, "FC_SENT");
+	mvOsPrintf("\n");
+}
diff --git a/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.h b/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.h
new file mode 100644
index 0000000..f4c7108
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacApi.h
@@ -0,0 +1,136 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#ifndef __mvEthGmac_h__
+#define __mvEthGmac_h__
+
+#include "mvEthGmacRegs.h"
+
+#include "mvTypes.h"
+#include "mvCommon.h"
+#include "mvOs.h"
+
+typedef enum {
+	MV_ETH_SPEED_AN,
+	MV_ETH_SPEED_10,
+	MV_ETH_SPEED_100,
+	MV_ETH_SPEED_1000
+} MV_ETH_PORT_SPEED;
+
+typedef enum {
+	MV_ETH_DUPLEX_AN,
+	MV_ETH_DUPLEX_HALF,
+	MV_ETH_DUPLEX_FULL
+} MV_ETH_PORT_DUPLEX;
+
+typedef enum {
+	MV_ETH_FC_AN_NO,
+	MV_ETH_FC_AN_SYM,
+	MV_ETH_FC_AN_ASYM,
+	MV_ETH_FC_DISABLE,
+	MV_ETH_FC_ENABLE,
+	MV_ETH_FC_ACTIVE
+
+} MV_ETH_PORT_FC;
+
+typedef struct eth_link_status {
+	MV_BOOL			linkup;
+	MV_ETH_PORT_SPEED	speed;
+	MV_ETH_PORT_DUPLEX	duplex;
+	MV_ETH_PORT_FC		rxFc;
+	MV_ETH_PORT_FC		txFc;
+
+} MV_ETH_PORT_STATUS;
+
+void mvEthPortEnable(int port);
+void mvEthPortDisable(int port);
+MV_BOOL mvEthPortIsLinkUp(int port);
+MV_STATUS mvEthLinkStatus(int port, MV_ETH_PORT_STATUS *pStatus);
+void mvEthPortLbSet(int port, int isGmii, int isPcsEn);
+void mvEthPortPowerUp(int port, MV_BOOL isSgmii, MV_BOOL isRgmii);
+void mvEthPortPowerDown(int port);
+
+/******************************************************************************/
+/*                          Port Configuration functions                      */
+/******************************************************************************/
+void mvEthMaxRxSizeSet(int port, int maxRxSize);
+MV_STATUS mvEthForceLinkModeSet(int portNo, MV_BOOL force_link_up, MV_BOOL force_link_down);
+MV_STATUS mvEthSpeedDuplexSet(int portNo, MV_ETH_PORT_SPEED speed, MV_ETH_PORT_DUPLEX duplex);
+MV_STATUS mvEthSpeedDuplexGet(int portNo, MV_ETH_PORT_SPEED *speed, MV_ETH_PORT_DUPLEX *duplex);
+MV_STATUS mvEthFlowCtrlSet(int port, MV_ETH_PORT_FC flowControl);
+MV_STATUS mvEthFlowCtrlGet(int port, MV_ETH_PORT_FC *pFlowCntrl);
+
+/******************************************************************************/
+/*                         PHY Control Functions                              */
+/******************************************************************************/
+void mvEthPhyAddrSet(int port, int phyAddr);
+int mvEthPhyAddrGet(int port);
+
+/****************************************/
+/*        MIB counters		       	*/
+/****************************************/
+MV_U32 mvEthMibCounterRead(int port, unsigned int mibOffset, MV_U32 *pHigh32);
+void mvEthMibCountersClear(int port);
+void mvEthMibCountersShow(int port);
+
+#endif /* __mvEthGmac_h__ */
diff --git a/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacRegs.h b/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacRegs.h
new file mode 100644
index 0000000..46a671d
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/gmac/mvEthGmacRegs.h
@@ -0,0 +1,229 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __mvEthGmacRegs_h__
+#define __mvEthGmacRegs_h__
+
+#include "mvSysEthConfig.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+
+#define ETH_MNG_EXTENDED_GLOBAL_CTRL_REG   (GOP_MNG_REG_BASE + 0x5c)
+
+#define ETH_REG_BASE(port)                 GOP_REG_BASE(port)
+
+#define ETH_GMAC_CTRL_0_REG(p)             (ETH_REG_BASE(p) + 0x0)
+
+#define ETH_GMAC_PORT_EN_BIT               0
+#define ETH_GMAC_PORT_EN_MASK              (1 << ETH_GMAC_PORT_EN_BIT)
+
+#define ETH_GMAC_PORT_TYPE_BIT             1
+#define ETH_GMAC_PORT_TYPE_MASK            (1 << ETH_GMAC_PORT_TYPE_BIT)
+#define ETH_GMAC_PORT_TYPE_SGMII           (0 << ETH_GMAC_PORT_TYPE_BIT)
+#define ETH_GMAC_PORT_TYPE_1000X           (1 << ETH_GMAC_PORT_TYPE_BIT)
+
+#define ETH_GMAC_MAX_RX_SIZE_OFFS          2
+#define ETH_GMAC_MAX_RX_SIZE_MASK          (0x1FFF << ETH_GMAC_MAX_RX_SIZE_OFFS)
+
+#define ETH_GMAC_MIB_CNTR_EN_BIT           15
+#define ETH_GMAC_MIB_CNTR_EN_MASK          (1 << ETH_GMAC_MIB_CNTR_EN_BIT)
+/*-------------------------------------------------------------------------------*/
+
+#define ETH_GMAC_CTRL_1_REG(p)             (ETH_REG_BASE(p) + 0x4)
+
+#define ETH_GMAC_GMII_LB_EN_BIT            5
+#define ETH_GMAC_GMII_LB_EN_MASK           (1 << ETH_GMAC_GMII_LB_EN_BIT)
+
+#define ETH_GMAC_PCS_LB_EN_BIT             6
+#define ETH_GMAC_PCS_LB_EN_MASK            (1 << ETH_GMAC_PCS_LB_EN_BIT)
+
+#define ETH_GMAC_SA_LOW_OFFS               7
+#define ETH_GMAC_SA_LOW_MASK               (0xFF << ETH_GMAC_SA_LOW_OFFS)
+/*-------------------------------------------------------------------------------*/
+
+#define ETH_GMAC_CTRL_2_REG(p)             (ETH_REG_BASE(p) + 0x8)
+
+#define ETH_GMAC_PCS_ENABLE_BIT            3
+#define ETH_GMAC_PCS_ENABLE_MASK           (1 << ETH_GMAC_PCS_ENABLE_BIT)
+
+#define ETH_GMAC_PORT_RGMII_BIT            4
+#define ETH_GMAC_PORT_RGMII_MASK           (1 << ETH_GMAC_PORT_RGMII_BIT)
+
+#define ETH_GMAC_PORT_RESET_BIT            6
+#define ETH_GMAC_PORT_RESET_MASK           (1 << ETH_GMAC_PORT_RESET_BIT)
+/*-------------------------------------------------------------------------------*/
+
+#define ETH_GMAC_AN_CTRL_REG(p)                (ETH_REG_BASE(p) + 0xC)
+
+#define ETH_FORCE_LINK_FAIL_BIT                0
+#define ETH_FORCE_LINK_FAIL_MASK               (1 << ETH_FORCE_LINK_FAIL_BIT)
+
+#define ETH_FORCE_LINK_PASS_BIT                1
+#define ETH_FORCE_LINK_PASS_MASK               (1 << ETH_FORCE_LINK_PASS_BIT)
+
+#define ETH_SET_MII_SPEED_100_BIT              5
+#define ETH_SET_MII_SPEED_100_MASK             (1 << ETH_SET_MII_SPEED_100_BIT)
+
+#define ETH_SET_GMII_SPEED_1000_BIT            6
+#define ETH_SET_GMII_SPEED_1000_MASK           (1 << ETH_SET_GMII_SPEED_1000_BIT)
+
+#define ETH_ENABLE_SPEED_AUTO_NEG_BIT          7
+#define ETH_ENABLE_SPEED_AUTO_NEG_MASK         (1 << ETH_ENABLE_SPEED_AUTO_NEG_BIT)
+
+/* TODO: I keep this bit even though it's not listed in Cider */
+#define ETH_SET_FLOW_CONTROL_BIT               8
+#define ETH_SET_FLOW_CONTROL_MASK              (1 << ETH_SET_FLOW_CONTROL_BIT)
+
+#define ETH_FLOW_CONTROL_ADVERTISE_BIT         9
+#define ETH_FLOW_CONTROL_ADVERTISE_MASK        (1 << ETH_FLOW_CONTROL_ADVERTISE_BIT)
+
+#define ETH_FLOW_CONTROL_ASYMETRIC_BIT         10
+#define ETH_FLOW_CONTROL_ASYMETRIC_MASK        (1 << ETH_FLOW_CONTROL_ASYMETRIC_BIT)
+
+#define ETH_ENABLE_FLOW_CONTROL_AUTO_NEG_BIT   11
+#define ETH_ENABLE_FLOW_CONTROL_AUTO_NEG_MASK  (1 << ETH_ENABLE_FLOW_CONTROL_AUTO_NEG_BIT)
+
+#define ETH_SET_FULL_DUPLEX_BIT                12
+#define ETH_SET_FULL_DUPLEX_MASK               (1 << ETH_SET_FULL_DUPLEX_BIT)
+
+#define ETH_ENABLE_DUPLEX_AUTO_NEG_BIT         13
+#define ETH_ENABLE_DUPLEX_AUTO_NEG_MASK        (1 << ETH_ENABLE_DUPLEX_AUTO_NEG_BIT)
+/*-------------------------------------------------------------------------------*/
+
+#define ETH_GMAC_STATUS_REG(p)             (ETH_REG_BASE(p) + 0x10)
+
+#define ETH_GMAC_LINK_UP_BIT               0
+#define ETH_GMAC_LINK_UP_MASK              (1 << ETH_GMAC_LINK_UP_BIT)
+
+#define ETH_GMAC_SPEED_1000_BIT            1
+#define ETH_GMAC_SPEED_1000_MASK           (1 << ETH_GMAC_SPEED_1000_BIT)
+
+#define ETH_GMAC_SPEED_100_BIT             2
+#define ETH_GMAC_SPEED_100_MASK            (1 << ETH_GMAC_SPEED_100_BIT)
+
+#define ETH_GMAC_FULL_DUPLEX_BIT           3
+#define ETH_GMAC_FULL_DUPLEX_MASK          (1 << ETH_GMAC_FULL_DUPLEX_BIT)
+
+#define ETH_RX_FLOW_CTRL_ENABLE_BIT        4
+#define ETH_RX_FLOW_CTRL_ENABLE_MASK       (1 << ETH_RX_FLOW_CTRL_ENABLE_BIT)
+
+#define ETH_TX_FLOW_CTRL_ENABLE_BIT        5
+#define ETH_TX_FLOW_CTRL_ENABLE_MASK       (1 << ETH_TX_FLOW_CTRL_ENABLE_BIT)
+
+#define ETH_RX_FLOW_CTRL_ACTIVE_BIT        6
+#define ETH_RX_FLOW_CTRL_ACTIVE_MASK       (1 << ETH_RX_FLOW_CTRL_ACTIVE_BIT)
+
+#define ETH_TX_FLOW_CTRL_ACTIVE_BIT        7
+#define ETH_TX_FLOW_CTRL_ACTIVE_MASK       (1 << ETH_TX_FLOW_CTRL_ACTIVE_BIT)
+/*-------------------------------------------------------------------------------*/
+
+/****************************************/
+/*        LMS Unit Registers       	*/
+/****************************************/
+#define ETH_PHY_ADDR_REG		(LMS_REG_BASE + 0x30)
+#define ETH_PHY_ADDR_OFFS(port)		(port * 5)
+#define ETH_PHY_ADDR_MASK(port)		(0x1F << ETH_PHY_ADDR_OFFS(port))
+
+#define ETH_SMI_REG(port)		(LMS_REG_BASE + 0x54)
+
+
+/****************************************/
+/*        MIB counters		       	*/
+/****************************************/
+#define ETH_MIB_PORT_OFFSET(port)	    ((port >> 1) * 0x400 + (port) * 0x400)
+#define ETH_MIB_COUNTERS_BASE(port)    (MIB_COUNTERS_REG_BASE + ETH_MIB_PORT_OFFSET(port))
+
+/* MIB Counters register definitions */
+#define ETH_MIB_GOOD_OCTETS_RECEIVED_LOW    0x0
+#define ETH_MIB_GOOD_OCTETS_RECEIVED_HIGH   0x4
+#define ETH_MIB_BAD_OCTETS_RECEIVED         0x8
+#define ETH_MIB_INTERNAL_MAC_TRANSMIT_ERR   0xc
+#define ETH_MIB_GOOD_FRAMES_RECEIVED        0x10
+#define ETH_MIB_BAD_FRAMES_RECEIVED         0x14
+#define ETH_MIB_BROADCAST_FRAMES_RECEIVED   0x18
+#define ETH_MIB_MULTICAST_FRAMES_RECEIVED   0x1c
+#define ETH_MIB_FRAMES_64_OCTETS            0x20
+#define ETH_MIB_FRAMES_65_TO_127_OCTETS     0x24
+#define ETH_MIB_FRAMES_128_TO_255_OCTETS    0x28
+#define ETH_MIB_FRAMES_256_TO_511_OCTETS    0x2c
+#define ETH_MIB_FRAMES_512_TO_1023_OCTETS   0x30
+#define ETH_MIB_FRAMES_1024_TO_MAX_OCTETS   0x34
+#define ETH_MIB_GOOD_OCTETS_SENT_LOW        0x38
+#define ETH_MIB_GOOD_OCTETS_SENT_HIGH       0x3c
+#define ETH_MIB_GOOD_FRAMES_SENT            0x40
+#define ETH_MIB_EXCESSIVE_COLLISION         0x44
+#define ETH_MIB_MULTICAST_FRAMES_SENT       0x48
+#define ETH_MIB_BROADCAST_FRAMES_SENT       0x4c
+#define ETH_MIB_UNREC_MAC_CONTROL_RECEIVED  0x50
+#define ETH_MIB_FC_SENT                     0x54
+#define ETH_MIB_GOOD_FC_RECEIVED            0x58
+#define ETH_MIB_BAD_FC_RECEIVED             0x5c
+#define ETH_MIB_UNDERSIZE_RECEIVED          0x60
+#define ETH_MIB_FRAGMENTS_RECEIVED          0x64
+#define ETH_MIB_OVERSIZE_RECEIVED           0x68
+#define ETH_MIB_JABBER_RECEIVED             0x6c
+#define ETH_MIB_MAC_RECEIVE_ERROR           0x70
+#define ETH_MIB_BAD_CRC_EVENT               0x74
+#define ETH_MIB_COLLISION                   0x78
+#define ETH_MIB_LATE_COLLISION              0x7c
+#endif /* mvEthGmacRegs */
diff --git a/arch/arm/plat-armada/mv_hal/pp2/plcr/mvPp2PlcrHw.c b/arch/arm/plat-armada/mv_hal/pp2/plcr/mvPp2PlcrHw.c
new file mode 100644
index 0000000..71f8583
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/plcr/mvPp2PlcrHw.c
@@ -0,0 +1,352 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"  /* Should be included before mvSysHwConfig */
+#include "mvTypes.h"
+#include "mvDebug.h"
+#include "mvOs.h"
+
+#include "pp2/common/mvPp2Common.h"
+#include "pp2/gbe/mvPp2Gbe.h"
+#include "mvPp2PlcrHw.h"
+
+
+void        mvPp2PlcrHwRegs(void)
+{
+	int    i;
+	MV_U32 regVal;
+
+	mvOsPrintf("\n[PLCR registers: %d policers]\n", MV_PP2_PLCR_NUM);
+
+	mvEthRegPrint(MV_PP2_PLCR_ENABLE_REG,      "MV_PP2_PLCR_ENABLE_REG");
+	mvEthRegPrint(MV_PP2_PLCR_BASE_PERIOD_REG, "MV_PP2_PLCR_BASE_PERIOD_REG");
+	mvEthRegPrint(MV_PP2_PLCR_MIN_PKT_LEN_REG,   "MV_PP2_PLCR_MIN_PKT_LEN_REG");
+	mvEthRegPrint(MV_PP2_PLCR_EDROP_EN_REG,      "MV_PP2_PLCR_EDROP_EN_REG");
+
+	for (i = 0; i < MV_PP2_PLCR_NUM; i++) {
+		mvOsPrintf("\n[Policer %d registers]\n", i);
+
+		mvPp2WrReg(MV_PP2_PLCR_TABLE_INDEX_REG, i);
+		mvEthRegPrint(MV_PP2_PLCR_COMMIT_TOKENS_REG, "MV_PP2_PLCR_COMMIT_TOKENS_REG");
+		mvEthRegPrint(MV_PP2_PLCR_EXCESS_TOKENS_REG, "MV_PP2_PLCR_EXCESS_TOKENS_REG");
+		mvEthRegPrint(MV_PP2_PLCR_BUCKET_SIZE_REG,   "MV_PP2_PLCR_BUCKET_SIZE_REG");
+		mvEthRegPrint(MV_PP2_PLCR_TOKEN_CFG_REG,     "MV_PP2_PLCR_TOKEN_CFG_REG");
+	}
+
+	mvOsPrintf("\nEarly Drop Thresholds for SW and HW forwarding\n");
+	for (i = 0; i < MV_PP2_PLCR_EDROP_THRESH_NUM; i += 2) {
+		mvEthRegPrint2(MV_PP2_PLCR_EDROP_CPU_TR_REG(i),   "MV_PP2_PLCR_EDROP_CPU_TR_REG", i);
+		mvEthRegPrint2(MV_PP2_PLCR_EDROP_HWF_TR_REG(i),   "MV_PP2_PLCR_EDROP_HWF_TR_REG", i);
+	}
+	mvOsPrintf("\nPer RXQ: Non zero early drop thresholds\n");
+	for (i = 0; i < MV_ETH_RXQ_TOTAL_NUM; i++) {
+		mvPp2WrReg(MV_PP2_PLCR_EDROP_RXQ_REG, i);
+		regVal = mvPp2RdReg(MV_PP2_PLCR_EDROP_RXQ_TR_REG);
+		if (regVal != 0)
+			mvOsPrintf("  %-32s: 0x%x = 0x%08x\n", "MV_PP2_PLCR_EDROP_RXQ_TR_REG", MV_PP2_PLCR_EDROP_RXQ_TR_REG, regVal);
+	}
+	mvOsPrintf("\nPer TXQ: Non zero Early Drop Thresholds\n");
+	for (i = 0; i < MV_PP2_TXQ_TOTAL_NUM; i++) {
+		mvPp2WrReg(MV_PP2_PLCR_EDROP_TXQ_REG, i);
+		regVal = mvPp2RdReg(MV_PP2_PLCR_EDROP_TXQ_TR_REG);
+		if (regVal != 0)
+			mvOsPrintf("  %-32s: 0x%x = 0x%08x\n", "MV_PP2_PLCR_EDROP_TXQ_TR_REG", MV_PP2_PLCR_EDROP_TXQ_TR_REG, regVal);
+	}
+}
+
+static void        mvPp2PlcrHwDumpTitle(void)
+{
+	MV_U32 regVal;
+
+	regVal = mvPp2RdReg(MV_PP2_PLCR_BASE_PERIOD_REG);
+	mvOsPrintf("PLCR status: %d policers, period=%d (%s), ",
+				MV_PP2_PLCR_NUM, regVal & MV_PP2_PLCR_BASE_PERIOD_ALL_MASK,
+				regVal & MV_PP2_PLCR_ADD_TOKENS_EN_MASK ? "En" : "Dis");
+
+	regVal = mvPp2RdReg(MV_PP2_PLCR_EDROP_EN_REG);
+	mvOsPrintf("edrop=%s, ", regVal & MV_PP2_PLCR_EDROP_EN_MASK ? "En" : "Dis");
+
+	regVal = mvPp2RdReg(MV_PP2_PLCR_MIN_PKT_LEN_REG);
+	mvOsPrintf("min_pkt=%d bytes\n", (regVal & MV_PP2_PLCR_MIN_PKT_LEN_ALL_MASK) >> MV_PP2_PLCR_MIN_PKT_LEN_OFFS);
+
+	mvOsPrintf("PLCR: enable period  unit   type  tokens  c_size  e_size  c_tokens  e_tokens\n");
+}
+
+static void        mvPp2PlcrHwDump(int plcr)
+{
+	int units, type, tokens;
+	MV_U32 regVal;
+
+	mvPp2WrReg(MV_PP2_PLCR_TABLE_INDEX_REG, plcr);
+	mvOsPrintf("%3d:  ", plcr);
+	regVal = mvPp2RdReg(MV_PP2_PLCR_ENABLE_REG);
+	mvOsPrintf("%4s", MV_BIT_CHECK(regVal, plcr) ? "Yes" : "No");
+
+	regVal = mvPp2RdReg(MV_PP2_PLCR_BASE_PERIOD_REG);
+	mvOsPrintf("  %6d", regVal & MV_PP2_PLCR_BASE_PERIOD_ALL_MASK);
+
+	regVal = mvPp2RdReg(MV_PP2_PLCR_TOKEN_CFG_REG);
+	units = regVal & MV_PP2_PLCR_TOKEN_UNIT_MASK;
+	type = (regVal & MV_PP2_PLCR_TOKEN_TYPE_ALL_MASK) >> MV_PP2_PLCR_TOKEN_TYPE_OFFS;
+	tokens =  (regVal & MV_PP2_PLCR_TOKEN_VALUE_ALL_MASK) >> MV_PP2_PLCR_TOKEN_VALUE_OFFS;
+	mvOsPrintf("   %5s  %2d   %5d", units ? "pkts" : "bytes", type, tokens);
+
+	regVal = mvPp2RdReg(MV_PP2_PLCR_BUCKET_SIZE_REG);
+	mvOsPrintf("    %04x    %04x",
+			(regVal & MV_PP2_PLCR_COMMIT_SIZE_ALL_MASK) >> MV_PP2_PLCR_COMMIT_SIZE_OFFS,
+			(regVal & MV_PP2_PLCR_EXCESS_SIZE_ALL_MASK) >> MV_PP2_PLCR_EXCESS_SIZE_OFFS);
+
+	regVal = mvPp2RdReg(MV_PP2_PLCR_COMMIT_TOKENS_REG);
+	mvOsPrintf("    %08x", regVal);
+
+	regVal = mvPp2RdReg(MV_PP2_PLCR_EXCESS_TOKENS_REG);
+	mvOsPrintf("  %08x", regVal);
+
+	mvOsPrintf("\n");
+}
+
+void        mvPp2PlcrHwDumpAll(void)
+{
+	int i;
+
+	mvPp2PlcrHwDumpTitle();
+	for (i = 0; i < MV_PP2_PLCR_NUM; i++)
+		mvPp2PlcrHwDump(i);
+}
+
+void        mvPp2PlcrHwDumpSingle(int plcr)
+{
+	mvPp2PlcrHwDumpTitle();
+	mvPp2PlcrHwDump(plcr);
+}
+
+MV_STATUS   mvPp2PlcrHwBaseRateGenEnable(int enable)
+{
+	MV_U32 regVal;
+
+	regVal = mvPp2RdReg(MV_PP2_PLCR_BASE_PERIOD_REG);
+	if (enable)
+		regVal |= MV_PP2_PLCR_ADD_TOKENS_EN_MASK;
+	else
+		regVal &= ~MV_PP2_PLCR_ADD_TOKENS_EN_MASK;
+
+	mvPp2WrReg(MV_PP2_PLCR_BASE_PERIOD_REG, regVal);
+
+	return MV_OK;
+}
+
+MV_STATUS   mvPp2PlcrHwBasePeriodSet(int period)
+{
+	MV_U32 regVal;
+
+	regVal = mvPp2RdReg(MV_PP2_PLCR_BASE_PERIOD_REG);
+	regVal &= ~MV_PP2_PLCR_BASE_PERIOD_ALL_MASK;
+	regVal |= MV_PP2_PLCR_BASE_PERIOD_MASK(period);
+	mvPp2WrReg(MV_PP2_PLCR_BASE_PERIOD_REG, regVal);
+
+	return MV_OK;
+}
+
+MV_STATUS   mvPp2PlcrHwEnable(int plcr, int enable)
+{
+	MV_U32 regVal;
+
+	regVal = mvPp2RdReg(MV_PP2_PLCR_ENABLE_REG);
+	if (enable)
+		regVal |= MV_PP2_PLCR_EN_MASK(plcr);
+	else
+		regVal &= ~MV_PP2_PLCR_EN_MASK(plcr);
+
+	mvPp2WrReg(MV_PP2_PLCR_ENABLE_REG, regVal);
+
+	return MV_OK;
+}
+
+MV_STATUS   mvPp2PlcrHwMinPktLen(int bytes)
+{
+	MV_U32 regVal;
+
+	regVal = mvPp2RdReg(MV_PP2_PLCR_MIN_PKT_LEN_REG);
+	regVal &= ~MV_PP2_PLCR_MIN_PKT_LEN_ALL_MASK;
+	regVal |= MV_PP2_PLCR_MIN_PKT_LEN_MASK(bytes);
+	mvPp2WrReg(MV_PP2_PLCR_MIN_PKT_LEN_REG, regVal);
+
+	return MV_OK;
+}
+
+MV_STATUS   mvPp2PlcrHwEarlyDropSet(int enable)
+{
+	MV_U32 regVal;
+
+	regVal = mvPp2RdReg(MV_PP2_PLCR_EDROP_EN_REG);
+	if (enable)
+		regVal |= MV_PP2_PLCR_EDROP_EN_MASK;
+	else
+		regVal &= ~MV_PP2_PLCR_EDROP_EN_MASK;
+
+	mvPp2WrReg(MV_PP2_PLCR_EDROP_EN_REG, regVal);
+
+	return MV_OK;
+}
+
+MV_STATUS   mvPp2PlcrHwTokenConfig(int plcr, int unit, int type)
+{
+	MV_U32 regVal;
+
+	mvPp2WrReg(MV_PP2_PLCR_TABLE_INDEX_REG, plcr);
+	regVal = mvPp2RdReg(MV_PP2_PLCR_TOKEN_CFG_REG);
+	if (unit)
+		regVal |= MV_PP2_PLCR_TOKEN_UNIT_MASK;
+	else
+		regVal &= ~MV_PP2_PLCR_TOKEN_UNIT_MASK;
+
+	regVal &= ~MV_PP2_PLCR_TOKEN_TYPE_ALL_MASK;
+	regVal |= MV_PP2_PLCR_TOKEN_TYPE_MASK(type);
+
+	mvPp2WrReg(MV_PP2_PLCR_TOKEN_CFG_REG, regVal);
+
+	return MV_OK;
+}
+
+MV_STATUS   mvPp2PlcrHwTokenValue(int plcr, int value)
+{
+	MV_U32 regVal;
+
+	mvPp2WrReg(MV_PP2_PLCR_TABLE_INDEX_REG, plcr);
+	regVal = mvPp2RdReg(MV_PP2_PLCR_TOKEN_CFG_REG);
+
+	regVal &= ~MV_PP2_PLCR_TOKEN_VALUE_ALL_MASK;
+	regVal |= MV_PP2_PLCR_TOKEN_VALUE_MASK(value);
+	mvPp2WrReg(MV_PP2_PLCR_TOKEN_CFG_REG, regVal);
+
+	return MV_OK;
+}
+
+MV_STATUS   mvPp2PlcrHwColorModeSet(int plcr, int enable)
+{
+	MV_U32 regVal;
+
+	mvPp2WrReg(MV_PP2_PLCR_TABLE_INDEX_REG, plcr);
+	regVal = mvPp2RdReg(MV_PP2_PLCR_TOKEN_CFG_REG);
+	if (enable)
+		regVal |= MV_PP2_PLCR_COLOR_MODE_MASK;
+	else
+		regVal &= ~MV_PP2_PLCR_COLOR_MODE_MASK;
+
+	mvPp2WrReg(MV_PP2_PLCR_TOKEN_CFG_REG, regVal);
+
+	return MV_OK;
+}
+
+
+MV_STATUS   mvPp2PlcrHwBucketSizeSet(int plcr, int commit, int excess)
+{
+	MV_U32 regVal;
+
+	mvPp2WrReg(MV_PP2_PLCR_TABLE_INDEX_REG, plcr);
+	regVal = MV_PP2_PLCR_EXCESS_SIZE_MASK(excess) | MV_PP2_PLCR_COMMIT_SIZE_MASK(commit);
+	mvPp2WrReg(MV_PP2_PLCR_BUCKET_SIZE_REG, regVal);
+
+	return MV_OK;
+}
+
+MV_STATUS   mvPp2PlcrHwCpuThreshSet(int idx, int threshold)
+{
+	MV_U32 regVal;
+
+	regVal = mvPp2RdReg(MV_PP2_PLCR_EDROP_CPU_TR_REG(idx));
+	regVal &= ~MV_PP2_PLCR_EDROP_TR_ALL_MASK(idx);
+	regVal |= MV_PP2_PLCR_EDROP_TR_MASK(idx, threshold);
+	mvPp2WrReg(MV_PP2_PLCR_EDROP_CPU_TR_REG(idx), regVal);
+
+	return MV_OK;
+}
+
+MV_STATUS   mvPp2PlcrHwHwfThreshSet(int idx, int threshold)
+{
+	MV_U32 regVal;
+
+	regVal = mvPp2RdReg(MV_PP2_PLCR_EDROP_HWF_TR_REG(idx));
+	regVal &= ~MV_PP2_PLCR_EDROP_TR_ALL_MASK(idx);
+	regVal |= MV_PP2_PLCR_EDROP_TR_MASK(idx, threshold);
+	mvPp2WrReg(MV_PP2_PLCR_EDROP_HWF_TR_REG(idx), regVal);
+
+	return MV_OK;
+}
+
+MV_STATUS   mvPp2PlcrHwRxqThreshSet(int rxq, int idx)
+{
+	mvPp2WrReg(MV_PP2_PLCR_EDROP_RXQ_REG, rxq);
+	mvPp2WrReg(MV_PP2_PLCR_EDROP_RXQ_TR_REG, idx);
+
+	return MV_OK;
+}
+
+MV_STATUS   mvPp2PlcrHwTxqThreshSet(int txq, int idx)
+{
+	mvPp2WrReg(MV_PP2_PLCR_EDROP_TXQ_REG, txq);
+	mvPp2WrReg(MV_PP2_PLCR_EDROP_TXQ_TR_REG, idx);
+
+	return MV_OK;
+}
diff --git a/arch/arm/plat-armada/mv_hal/pp2/plcr/mvPp2PlcrHw.h b/arch/arm/plat-armada/mv_hal/pp2/plcr/mvPp2PlcrHw.h
new file mode 100644
index 0000000..cbe854b
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/plcr/mvPp2PlcrHw.h
@@ -0,0 +1,188 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __mvPp2PlcrHw_h__
+#define __mvPp2PlcrHw_h__
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#define MV_PP2_PLCR_NUM		16
+
+/*********************************** RX Policer Registers *******************/
+#define MV_PP2_PLCR_ENABLE_REG				(MV_PP2_REG_BASE + 0x1300)
+
+#define MV_PP2_PLCR_EN_OFFS					0
+#define MV_PP2_PLCR_EN_ALL_MASK				(((1 << MV_PP2_PLCR_NUM) - 1) << MV_PP2_PLCR_EN_OFFS)
+#define MV_PP2_PLCR_EN_MASK(plcr)			((1 << (plcr)) << MV_PP2_PLCR_EN_OFFS)
+/*---------------------------------------------------------------------------------------------*/
+
+#define MV_PP2_PLCR_BASE_PERIOD_REG			(MV_PP2_REG_BASE + 0x1304)
+
+#define MV_PP2_PLCR_BASE_PERIOD_OFFS		0
+#define MV_PP2_PLCR_BASE_PERIOD_BITS		16
+#define MV_PP2_PLCR_BASE_PERIOD_ALL_MASK	(((1 << MV_PP2_PLCR_BASE_PERIOD_BITS) - 1) << MV_PP2_PLCR_BASE_PERIOD_OFFS)
+#define MV_PP2_PLCR_BASE_PERIOD_MASK(p)		(((p) << MV_PP2_PLCR_BASE_PERIOD_OFFS) & MV_PP2_PLCR_BASE_PERIOD_ALL_MASK)
+
+#define MV_PP2_PLCR_ADD_TOKENS_EN_BIT		16
+#define MV_PP2_PLCR_ADD_TOKENS_EN_MASK      (1 << MV_PP2_PLCR_ADD_TOKENS_EN_BIT)
+/*---------------------------------------------------------------------------------------------*/
+
+#define MV_PP2_PLCR_TABLE_INDEX_REG			(MV_PP2_REG_BASE + 0x130c)
+#define MV_PP2_PLCR_COMMIT_TOKENS_REG		(MV_PP2_REG_BASE + 0x1310)
+#define MV_PP2_PLCR_EXCESS_TOKENS_REG		(MV_PP2_REG_BASE + 0x1314)
+/*---------------------------------------------------------------------------------------------*/
+
+#define MV_PP2_PLCR_BUCKET_SIZE_REG			(MV_PP2_REG_BASE + 0x1318)
+
+#define MV_PP2_PLCR_COMMIT_SIZE_OFFS		0
+#define MV_PP2_PLCR_COMMIT_SIZE_BITS		16
+#define MV_PP2_PLCR_COMMIT_SIZE_ALL_MASK	(((1 << MV_PP2_PLCR_COMMIT_SIZE_BITS) - 1) << MV_PP2_PLCR_COMMIT_SIZE_OFFS)
+#define MV_PP2_PLCR_COMMIT_SIZE_MASK(size)  (((size)	<< MV_PP2_PLCR_COMMIT_SIZE_OFFS) & MV_PP2_PLCR_COMMIT_SIZE_ALL_MASK)
+
+#define MV_PP2_PLCR_EXCESS_SIZE_OFFS		16
+#define MV_PP2_PLCR_EXCESS_SIZE_BITS		16
+#define MV_PP2_PLCR_EXCESS_SIZE_ALL_MASK	(((1 << MV_PP2_PLCR_EXCESS_SIZE_BITS) - 1) << MV_PP2_PLCR_EXCESS_SIZE_OFFS)
+#define MV_PP2_PLCR_EXCESS_SIZE_MASK(size)  (((size) << MV_PP2_PLCR_EXCESS_SIZE_OFFS) & MV_PP2_PLCR_EXCESS_SIZE_ALL_MASK)
+/*---------------------------------------------------------------------------------------------*/
+
+#define MV_PP2_PLCR_TOKEN_CFG_REG			(MV_PP2_REG_BASE + 0x131c)
+
+#define MV_PP2_PLCR_TOKEN_VALUE_OFFS		0
+#define MV_PP2_PLCR_TOKEN_VALUE_BITS		10
+#define MV_PP2_PLCR_TOKEN_VALUE_ALL_MASK	(((1 << MV_PP2_PLCR_TOKEN_VALUE_BITS) - 1) << MV_PP2_PLCR_TOKEN_VALUE_OFFS)
+#define MV_PP2_PLCR_TOKEN_VALUE_MASK(val)	(((val) << MV_PP2_PLCR_TOKEN_VALUE_OFFS) & MV_PP2_PLCR_TOKEN_VALUE_ALL_MASK)
+
+#define MV_PP2_PLCR_TOKEN_TYPE_OFFS			12
+#define MV_PP2_PLCR_TOKEN_TYPE_BITS			3
+#define MV_PP2_PLCR_TOKEN_TYPE_ALL_MASK		(((1 << MV_PP2_PLCR_TOKEN_TYPE_BITS) - 1) << MV_PP2_PLCR_TOKEN_TYPE_OFFS)
+#define MV_PP2_PLCR_TOKEN_TYPE_MASK(type)	(((type) << MV_PP2_PLCR_TOKEN_TYPE_OFFS) & MV_PP2_PLCR_TOKEN_TYPE_ALL_MASK)
+
+#define MV_PP2_PLCR_TOKEN_UNIT_BIT			31
+#define MV_PP2_PLCR_TOKEN_UNIT_MASK			(1 << MV_PP2_PLCR_TOKEN_UNIT_BIT)
+#define MV_PP2_PLCR_TOKEN_UNIT_BYTES		(0 << MV_PP2_PLCR_TOKEN_UNIT_BIT)
+#define MV_PP2_PLCR_TOKEN_UNIT_PKTS			(1 << MV_PP2_PLCR_TOKEN_UNIT_BIT)
+
+#define MV_PP2_PLCR_COLOR_MODE_BIT			30
+#define MV_PP2_PLCR_COLOR_MODE_MASK			(1 << MV_PP2_PLCR_COLOR_MODE_BIT)
+/*---------------------------------------------------------------------------------------------*/
+
+#define MV_PP2_PLCR_MIN_PKT_LEN_REG			(MV_PP2_REG_BASE + 0x1320)
+
+#define MV_PP2_PLCR_MIN_PKT_LEN_OFFS		0
+#define MV_PP2_PLCR_MIN_PKT_LEN_BITS		8
+#define MV_PP2_PLCR_MIN_PKT_LEN_ALL_MASK	(((1 << MV_PP2_PLCR_MIN_PKT_LEN_BITS) - 1) << MV_PP2_PLCR_MIN_PKT_LEN_OFFS)
+#define MV_PP2_PLCR_MIN_PKT_LEN_MASK(len)	(((len) << MV_PP2_PLCR_MIN_PKT_LEN_OFFS) & MV_PP2_PLCR_MIN_PKT_LEN_ALL_MASK)
+/*---------------------------------------------------------------------------------------------*/
+
+#define MV_PP2_PLCR_EDROP_EN_REG			(MV_PP2_REG_BASE + 0x1330)
+
+#define MV_PP2_PLCR_EDROP_EN_BIT			0
+#define MV_PP2_PLCR_EDROP_EN_MASK			(1 << MV_PP2_PLCR_EDROP_EN_BIT)
+/*---------------------------------------------------------------------------------------------*/
+
+#define MV_PP2_PLCR_EDROP_THRESH_NUM		4
+
+#define MV_PP2_PLCR_EDROP_TR_OFFS(i)		((i % 2) ? 16 : 0)
+#define MV_PP2_PLCR_EDROP_TR_BITS			16
+#define MV_PP2_PLCR_EDROP_TR_ALL_MASK(i)	(((1 << MV_PP2_PLCR_EDROP_TR_BITS) - 1) << MV_PP2_PLCR_EDROP_TR_OFFS(i))
+#define MV_PP2_PLCR_EDROP_TR_MASK(i, tr)	(((tr) << MV_PP2_PLCR_EDROP_TR_OFFS(i)) & MV_PP2_PLCR_EDROP_TR_ALL_MASK(i))
+
+#define MV_PP2_PLCR_EDROP_CPU_TR_REG(i)		(MV_PP2_REG_BASE + 0x1340 + (((i) / 2) << 2))
+#define MV_PP2_PLCR_EDROP_HWF_TR_REG(i)		(MV_PP2_REG_BASE + 0x1350 + (((i) / 2) << 2))
+/*---------------------------------------------------------------------------------------------*/
+
+#define MV_PP2_PLCR_EDROP_RXQ_REG			(MV_PP2_REG_BASE + 0x1348)
+#define MV_PP2_PLCR_EDROP_RXQ_TR_REG		(MV_PP2_REG_BASE + 0x134c)
+/*---------------------------------------------------------------------------------------------*/
+
+#define MV_PP2_PLCR_EDROP_TXQ_REG			(MV_PP2_REG_BASE + 0x1358)
+#define MV_PP2_PLCR_EDROP_TXQ_TR_REG		(MV_PP2_REG_BASE + 0x135c)
+/*---------------------------------------------------------------------------------------------*/
+
+/* Policer APIs */
+void        mvPp2PlcrHwRegs(void);
+void        mvPp2PlcrHwDumpAll(void);
+void        mvPp2PlcrHwDumpSingle(int plcr);
+MV_STATUS   mvPp2PlcrHwBasePeriodSet(int period);
+MV_STATUS   mvPp2PlcrHwBaseRateGenEnable(int enable);
+MV_STATUS   mvPp2PlcrHwEnable(int plcr, int enable);
+MV_STATUS   mvPp2PlcrHwMinPktLen(int bytes);
+MV_STATUS   mvPp2PlcrHwEarlyDropSet(int enable);
+MV_STATUS   mvPp2PlcrHwTokenConfig(int plcr, int unit, int type);
+MV_STATUS   mvPp2PlcrHwTokenValue(int plcr, int value);
+MV_STATUS   mvPp2PlcrHwColorModeSet(int plcr, int enable);
+MV_STATUS   mvPp2PlcrHwBucketSizeSet(int plcr, int commit, int excess);
+MV_STATUS   mvPp2PlcrHwCpuThreshSet(int idx, int threshold);
+MV_STATUS   mvPp2PlcrHwHwfThreshSet(int idx, int threshold);
+MV_STATUS   mvPp2PlcrHwRxqThreshSet(int rxq, int idx);
+MV_STATUS   mvPp2PlcrHwTxqThreshSet(int txq, int idx);
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __mvPp2PlcrHw_h__ */
diff --git a/arch/arm/plat-armada/mv_hal/pp2/pme/mvPp2PmeHw.c b/arch/arm/plat-armada/mv_hal/pp2/pme/mvPp2PmeHw.c
new file mode 100644
index 0000000..75336f6
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/pme/mvPp2PmeHw.c
@@ -0,0 +1,673 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"  /* Should be included before mvSysHwConfig */
+#include "mvTypes.h"
+#include "mvDebug.h"
+#include "mvOs.h"
+
+#include "common/mvPp2Common.h"
+#include "gbe/mvPp2Gbe.h"
+#include "mvPp2PmeHw.h"
+
+
+/* #define PME_DBG mvOsPrintf */
+#define PME_DBG(X...)
+
+static char *mvPp2PmeCmdName(enum MV_PP2_PME_CMD_E cmd)
+{
+	switch (cmd) {
+	case MV_PP2_PME_CMD_NONE:		return "NO_MOD";
+	case MV_PP2_PME_CMD_ADD_2B:		return "ADD_2B";
+	case MV_PP2_PME_CMD_CFG_VLAN:	return "CFG_VLAN";
+	case MV_PP2_PME_CMD_ADD_VLAN:	return "ADD_VLAN";
+	case MV_PP2_PME_CMD_CFG_DSA_1:	return "CFG_DSA_1";
+	case MV_PP2_PME_CMD_CFG_DSA_2:	return "CFG_DSA_2";
+	case MV_PP2_PME_CMD_ADD_DSA:	return "ADD_DSA";
+	case MV_PP2_PME_CMD_DEL_BYTES:	return "DEL_BYTES";
+	case MV_PP2_PME_CMD_REPLACE_2B: return "REPLACE_2B";
+	case MV_PP2_PME_CMD_REPLACE_LSB: return "REPLACE_LSB";
+	case MV_PP2_PME_CMD_REPLACE_MSB: return "REPLACE_MSB";
+	case MV_PP2_PME_CMD_REPLACE_VLAN: return "REPLACE_VLAN";
+	case MV_PP2_PME_CMD_DEC_LSB:	return "DEC_LSB";
+	case MV_PP2_PME_CMD_DEC_MSB:	return "DEC_MSB";
+	case MV_PP2_PME_CMD_ADD_CALC_LEN: return "ADD_CALC_LEN";
+	case MV_PP2_PME_CMD_REPLACE_LEN: return "REPLACE_LEN";
+	case MV_PP2_PME_CMD_IPV4_CSUM:	return "IPV4_CSUM";
+	case MV_PP2_PME_CMD_L4_CSUM:	return "L4_CSUM";
+	case MV_PP2_PME_CMD_SKIP:		return "SKIP";
+	case MV_PP2_PME_CMD_JUMP:		return "JUMP";
+	case MV_PP2_PME_CMD_JUMP_SKIP:	return "JUMP_SKIP";
+	case MV_PP2_PME_CMD_JUMP_SUB:	return "JUMP_SUB";
+	case MV_PP2_PME_CMD_PPPOE:		return "PPPOE";
+	case MV_PP2_PME_CMD_STORE:		return "STORE";
+	case MV_PP2_PME_CMD_ADD_IP4_CSUM: return "ADD_L4";
+	case MV_PP2_PME_CMD_PPPOE_2:	return "PPPOE_2";
+	case MV_PP2_PME_CMD_REPLACE_MID: return "REPLACE_MID";
+	case MV_PP2_PME_CMD_ADD_MULT:	return "ADD_MULT";
+	case MV_PP2_PME_CMD_REPLACE_MULT: return "REPLACE_MULT";
+	case MV_PP2_PME_CMD_RESERVED_1:
+	case MV_PP2_PME_CMD_RESERVED_2:	return "RESERVED";
+	case MV_PP2_PME_CMD_DROP_PKT:	return "DROP";
+	default:
+		return "UNKNOWN";
+	}
+	return NULL;
+};
+
+static 	int mvPp2PmeDataTblSize(int tbl)
+{
+	int max;
+
+	switch (tbl) {
+	case 0:
+		max = MV_PP2_PME_DATA1_SIZE;
+		break;
+	case 1:
+		max = MV_PP2_PME_DATA2_SIZE;
+		break;
+	default:
+		max = 0;
+		mvOsPrintf("%s: tbl %d is out of range [0..1]\n", __func__, tbl);
+	}
+	return max;
+}
+
+static inline MV_U32	mvPp2PmeDataTblRegAddr(int tbl)
+{
+	MV_U32 regAddr;
+
+	switch (tbl) {
+	case 0:
+		regAddr = MV_PP2_PME_TBL_DATA1_REG;
+		break;
+	case 1:
+		regAddr = MV_PP2_PME_TBL_DATA2_REG;
+		break;
+	default:
+		regAddr = 0;
+		mvOsPrintf("%s: tbl %d is out of range [0..1]\n", __func__, tbl);
+	}
+	return regAddr;
+}
+
+/*******************************************************************************
+* mvPp2PmeHwRegs - Print PME hardware registers
+*
+*******************************************************************************/
+void        mvPp2PmeHwRegs(void)
+{
+	int    i;
+	MV_U32 regVal;
+
+	mvOsPrintf("\n[PME registers]\n");
+
+	mvEthRegPrint(MV_PP2_PME_TBL_IDX_REG, "MV_PP2_PME_TBL_IDX_REG");
+	mvEthRegPrint(MV_PP2_PME_TCONT_THRESH_REG, "MV_PP2_PME_TCONT_THRESH_REG");
+	mvEthRegPrint(MV_PP2_PME_MTU_REG, "MV_PP2_PME_MTU_REG");
+
+	for (i = 0; i < MV_PP2_PME_MAX_VLAN_ETH_TYPES; i++)
+		mvEthRegPrint2(MV_PP2_PME_VLAN_ETH_TYPE_REG(i), "MV_PP2_PME_VLAN_ETH_TYPE_REG", i);
+
+	mvEthRegPrint(MV_PP2_PME_DEF_VLAN_CFG_REG, "MV_PP2_PME_DEF_VLAN_CFG_REG");
+	for (i = 0; i < MV_PP2_PME_MAX_DSA_ETH_TYPES; i++)
+		mvEthRegPrint2(MV_PP2_PME_DEF_DSA_CFG_REG(i), "MV_PP2_PME_DEF_DSA_CFG_REG", i);
+
+	mvEthRegPrint(MV_PP2_PME_DEF_DSA_SRC_DEV_REG, "MV_PP2_PME_DEF_DSA_SRC_DEV_REG");
+	mvEthRegPrint(MV_PP2_PME_TTL_ZERO_FRWD_REG, "MV_PP2_PME_TTL_ZERO_FRWD_REG");
+	mvEthRegPrint(MV_PP2_PME_PPPOE_ETYPE_REG, "MV_PP2_PME_PPPOE_ETYPE_REG");
+	mvEthRegPrint(MV_PP2_PME_PPPOE_DATA_REG, "MV_PP2_PME_PPPOE_DATA_REG");
+	mvEthRegPrint(MV_PP2_PME_PPPOE_LEN_REG, "MV_PP2_PME_PPPOE_LEN_REG");
+	mvEthRegPrint(MV_PP2_PME_PPPOE_PROTO_REG, "MV_PP2_PME_PPPOE_PROTO_REG");
+	mvEthRegPrint(MV_PP2_PME_CONFIG_REG, "MV_PP2_PME_CONFIG_REG");
+	mvEthRegPrint(MV_PP2_PME_STATUS_1_REG, "MV_PP2_PME_STATUS_1_REG");
+
+	mvOsPrintf("\nMV_PP2_PME_STATUS_2_REG[txp] registers that are not zero\n");
+	for (i = 0; i < MV_PP2_TOTAL_TXP_NUM; i++) {
+		regVal = MV_REG_READ(MV_PP2_PME_STATUS_2_REG(i));
+		if (regVal != 0)
+			mvOsPrintf("%-32s[%2d]: 0x%x = 0x%08x\n",
+				"MV_PP2_PME_STATUS_2_REG", i, MV_PP2_PME_STATUS_2_REG(i), regVal);
+	}
+
+	mvOsPrintf("\nMV_PP2_PME_STATUS_3_REG[txp] registers that are not zero\n");
+	for (i = 0; i < MV_PP2_TOTAL_TXP_NUM; i++) {
+		regVal = MV_REG_READ(MV_PP2_PME_STATUS_3_REG(i));
+		if (regVal != 0)
+			mvOsPrintf("%-32s[%2d]: 0x%x = 0x%08x\n",
+				"MV_PP2_PME_STATUS_3_REG", i, MV_PP2_PME_STATUS_3_REG(i), regVal);
+	}
+}
+
+/*******************************************************************************
+* mvPp2PmeHwWrite - Write PME entry to the hardware
+*
+* INPUT:
+*       int			idx	- PME entry index to write to
+*       MV_PP2_PME_ENTRY	*pEntry - PME software entry to be written
+*
+* RETURN:   MV_STATUS
+*               MV_OK - Success, Others - Failure
+*******************************************************************************/
+MV_STATUS   mvPp2PmeHwWrite(int idx, MV_PP2_PME_ENTRY *pEntry)
+{
+	if ((idx < 0) || (idx >= MV_PP2_PME_INSTR_SIZE)) {
+		mvOsPrintf("%s: entry %d is out of range [0..%d]\n", __func__, idx, MV_PP2_PME_INSTR_SIZE);
+		return MV_OUT_OF_RANGE;
+	}
+	pEntry->index = idx;
+	mvPp2WrReg(MV_PP2_PME_TBL_IDX_REG, idx);
+	mvPp2WrReg(MV_PP2_PME_TBL_INSTR_REG, pEntry->word);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvPp2PmeHwRead - Read PME entry from the hardware
+*
+* INPUT:
+*       int	idx	- PME entry index to write to
+* OUTPUT:
+*       MV_PP2_PME_ENTRY	*pEntry - PME software entry to be read into
+*
+* RETURN:   MV_STATUS
+*               MV_OK - Success, Others - Failure
+*******************************************************************************/
+MV_STATUS mvPp2PmeHwRead(int idx, MV_PP2_PME_ENTRY *pEntry)
+{
+	if ((idx < 0) || (idx >= MV_PP2_PME_INSTR_SIZE)) {
+		mvOsPrintf("%s: entry %d is out of range [0..%d]\n", __func__, idx, MV_PP2_PME_INSTR_SIZE);
+		return MV_OUT_OF_RANGE;
+	}
+
+	pEntry->index = idx;
+	mvPp2WrReg(MV_PP2_PME_TBL_IDX_REG, idx);
+	pEntry->word = mvPp2RdReg(MV_PP2_PME_TBL_INSTR_REG);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvPp2PmeHwInv - Invalidate single PME entry in the hardware
+*
+* INPUT:
+*       int	idx	- PME entry index to be invaliadted
+*
+* RETURN:   MV_STATUS
+*               MV_OK - Success, Others - Failure
+*******************************************************************************/
+MV_STATUS   mvPp2PmeHwInv(int idx)
+{
+	MV_PP2_PME_ENTRY	entry;
+
+	if ((idx < 0) || (idx >= MV_PP2_PME_INSTR_SIZE)) {
+		mvOsPrintf("%s: entry %d is out of range [0..%d]\n", __func__, idx, MV_PP2_PME_INSTR_SIZE);
+		return MV_OUT_OF_RANGE;
+	}
+	mvPp2PmeSwClear(&entry);
+
+	return mvPp2PmeHwWrite(idx, &entry);
+}
+
+/*******************************************************************************
+* mvPp2PmeHwInvAll - Invalidate all PME entries in the hardware
+*
+* INPUT:
+*
+* RETURN:   MV_STATUS
+*               MV_OK - Success, Others - Failure
+*******************************************************************************/
+MV_STATUS   mvPp2PmeHwInvAll(void)
+{
+	int	idx;
+
+	for (idx = 0; idx < MV_PP2_PME_INSTR_SIZE; idx++)
+		mvPp2PmeHwInv(idx);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvPp2PmeHwInit - Init TX Packet Modification driver
+*
+* INPUT:
+*
+* RETURN:   MV_STATUS
+*               MV_OK - Success, Others - Failure
+*******************************************************************************/
+MV_STATUS   mvPp2PmeHwInit(void)
+{
+	mvPp2PmeHwInvAll();
+	mvPp2PmeHwDataTblClear(0);
+	mvPp2PmeHwDataTblClear(1);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvPp2PmeSwDump - Print PME software entry
+*
+* INPUT:
+*       MV_PP2_PME_ENTRY*    pEntry - PME software entry to be printed
+*
+* RETURN:   void
+*******************************************************************************/
+MV_STATUS	mvPp2PmeSwDump(MV_PP2_PME_ENTRY *pEntry)
+{
+	mvOsPrintf("%04x %04x: ",
+		MV_PP2_PME_CTRL_GET(pEntry), MV_PP2_PME_DATA_GET(pEntry));
+
+	mvOsPrintf("%s ", mvPp2PmeCmdName(MV_PP2_PME_CMD_GET(pEntry)));
+
+	if (pEntry->word & MV_PP2_PME_IP4_CSUM_MASK)
+		mvOsPrintf(", IPv4 csum");
+
+	if (pEntry->word & MV_PP2_PME_L4_CSUM_MASK)
+		mvOsPrintf(", L4 csum");
+
+	if (pEntry->word & MV_PP2_PME_LAST_MASK)
+		mvOsPrintf(", Last");
+
+	mvOsPrintf("\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvPp2PmeHwDump - Dump PME hardware entries
+*
+* INPUT:
+*       int	mode   -
+*
+* RETURN:   void
+*******************************************************************************/
+MV_STATUS	mvPp2PmeHwDump(int mode)
+{
+	int					idx, count = 0;
+	MV_PP2_PME_ENTRY 	entry;
+	MV_STATUS			status;
+
+	mvOsPrintf("PME instraction table: #%d entries\n", MV_PP2_PME_INSTR_SIZE);
+	for (idx = 0; idx < MV_PP2_PME_INSTR_SIZE; idx++) {
+		status = mvPp2PmeHwRead(idx, &entry);
+		if (status != MV_OK) {
+			mvOsPrintf("%s failed: idx=%d, status=%d\n",
+					__func__, idx, status);
+			return status;
+		}
+		if (mode == 0) {
+			if (!MV_PP2_PME_IS_VALID(&entry))
+				continue;
+		}
+
+		count++;
+		mvOsPrintf("[%4d]: ", idx);
+		mvPp2PmeSwDump(&entry);
+	}
+
+	if (!count)
+		mvOsPrintf("Table is Empty\n");
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvPp2PmeEntryPrint - Print PME entry
+*
+* INPUT:
+*       MV_PP2_PME_ENTRY	*pEntry - PME entry to be printed
+*
+* RETURN:   MV_STATUS
+*******************************************************************************/
+MV_STATUS   mvPp2PmeSwClear(MV_PP2_PME_ENTRY *pEntry)
+{
+	pEntry->word = 0;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvPp2PmeSwWordSet - Set 4 bytes data to software PME entry
+*
+* INPUT:
+*       MV_PP2_PME_ENTRY*    pEntry - PME entry to be set
+*		MV_U32               word   - 4 bytes of data to be set
+*
+* RETURN:   MV_STATUS
+*******************************************************************************/
+MV_STATUS   mvPp2PmeSwWordSet(MV_PP2_PME_ENTRY *pEntry, MV_U32 word)
+{
+	pEntry->word = word;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvPp2PmeSwCmdSet - Set modification command to software PME instruction entry
+*
+* INPUT:
+*       MV_PP2_PME_ENTRY*     pEntry - PME entry to be set
+*		enum MV_PP2_PME_CMD_E cmd    - modification command to be set
+*
+* RETURN:   MV_STATUS
+*******************************************************************************/
+MV_STATUS   mvPp2PmeSwCmdSet(MV_PP2_PME_ENTRY *pEntry, enum MV_PP2_PME_CMD_E cmd)
+{
+	pEntry->word &= ~MV_PP2_PME_CMD_ALL_MASK;
+	pEntry->word |= MV_PP2_PME_CMD_MASK(cmd);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvPp2PmeSwCmdTypeSet - Set modification command type to software PME instruction entry
+*
+* INPUT:
+*       MV_PP2_PME_ENTRY*     pEntry - PME entry to be set
+*		int                   type    - modification command type to be set
+*
+* RETURN:   MV_STATUS
+*******************************************************************************/
+MV_STATUS   mvPp2PmeSwCmdTypeSet(MV_PP2_PME_ENTRY *pEntry, int type)
+{
+	pEntry->word &= ~MV_PP2_PME_CMD_TYPE_ALL_MASK;
+	pEntry->word |= MV_PP2_PME_CMD_TYPE_MASK(type);
+
+	return MV_OK;
+}
+
+MV_STATUS   mvPp2PmeSwCmdLastSet(MV_PP2_PME_ENTRY *pEntry, int last)
+{
+	if (last)
+		pEntry->word |= MV_PP2_PME_LAST_MASK;
+	else
+		pEntry->word &= ~MV_PP2_PME_LAST_MASK;
+
+	return MV_OK;
+}
+
+MV_STATUS   mvPp2PmeSwCmdFlagsSet(MV_PP2_PME_ENTRY *pEntry, int last, int ipv4, int l4)
+{
+	if (last)
+		pEntry->word |= MV_PP2_PME_LAST_MASK;
+	else
+		pEntry->word &= ~MV_PP2_PME_LAST_MASK;
+
+	if (ipv4)
+		pEntry->word |= MV_PP2_PME_IP4_CSUM_MASK;
+	else
+		pEntry->word &= ~MV_PP2_PME_IP4_CSUM_MASK;
+
+	if (l4)
+		pEntry->word |= MV_PP2_PME_L4_CSUM_MASK;
+	else
+		pEntry->word &= ~MV_PP2_PME_L4_CSUM_MASK;
+
+	return MV_OK;
+}
+
+MV_STATUS   mvPp2PmeSwCmdDataSet(MV_PP2_PME_ENTRY *pEntry, MV_U16 data)
+{
+	MV_PP2_PME_DATA_SET(pEntry, data);
+	return MV_OK;
+}
+
+/* Functions to access PME data1 and data2 tables */
+MV_STATUS   mvPp2PmeHwDataTblWrite(int tbl, int idx, MV_U16 data)
+{
+	MV_U32  regVal;
+
+	if ((tbl < 0) || (tbl > 1)) {
+		mvOsPrintf("%s: data table %d is out of range [0..1]\n", __func__, tbl);
+		return MV_BAD_PARAM;
+	}
+	if ((idx < 0) || (idx >= mvPp2PmeDataTblSize(tbl))) {
+		mvOsPrintf("%s: entry index #%d is out of range [0..%d] for data table #%d\n",
+					__func__, idx, tbl, mvPp2PmeDataTblSize(tbl));
+		return MV_FALSE;
+	}
+
+	mvPp2WrReg(MV_PP2_PME_TBL_IDX_REG, idx / 2);
+
+	regVal = mvPp2RdReg(mvPp2PmeDataTblRegAddr(tbl));
+	regVal &= ~MV_PP2_PME_TBL_DATA_MASK(idx % 2);
+	regVal |= (data << MV_PP2_PME_TBL_DATA_OFFS(idx % 2));
+
+	mvPp2WrReg(MV_PP2_PME_TBL_IDX_REG, idx / 2);
+	mvPp2WrReg(mvPp2PmeDataTblRegAddr(tbl), regVal);
+
+	return MV_OK;
+}
+
+MV_STATUS   mvPp2PmeHwDataTblRead(int tbl, int idx, MV_U16 *data)
+{
+	MV_U32  regVal;
+
+	if ((tbl < 0) || (tbl > 1)) {
+		mvOsPrintf("%s: data table %d is out of range [0..1]\n", __func__, tbl);
+		return MV_BAD_PARAM;
+	}
+	if ((idx < 0) || (idx >= mvPp2PmeDataTblSize(tbl))) {
+		mvOsPrintf("%s: entry index #%d is out of range [0..%d] for data table #%d\n",
+					__func__, idx, tbl, mvPp2PmeDataTblSize(tbl));
+		return MV_FALSE;
+	}
+
+	mvPp2WrReg(MV_PP2_PME_TBL_IDX_REG, idx / 2);
+
+	regVal = mvPp2RdReg(mvPp2PmeDataTblRegAddr(tbl));
+
+	if (data)
+		*data = (regVal & MV_PP2_PME_TBL_DATA_MASK(idx % 2)) >> MV_PP2_PME_TBL_DATA_OFFS(idx % 2);
+
+	return MV_OK;
+}
+
+MV_STATUS   mvPp2PmeHwDataTblDump(int tbl)
+{
+	int idx, max, count = 0;
+	MV_U16 data;
+
+	if ((tbl < 0) || (tbl > 1)) {
+		mvOsPrintf("%s: data table %d is out of range [0..1]\n", __func__, tbl);
+		return MV_BAD_PARAM;
+	}
+	max = mvPp2PmeDataTblSize(tbl);
+
+	mvOsPrintf("PME Data%d table: #%d entries\n", tbl + 1, max);
+	for (idx = 0; idx < max; idx++) {
+		mvPp2PmeHwDataTblRead(tbl, idx, &data);
+		if (data != 0) {
+			mvOsPrintf("[%4d]: 0x%04x\n", idx, data);
+			count++;
+		}
+	}
+	if (count == 0)
+		mvOsPrintf("Table is Empty\n");
+
+	return MV_OK;
+}
+
+MV_STATUS   mvPp2PmeHwDataTblClear(int tbl)
+{
+	int max, idx;
+
+	if ((tbl < 0) || (tbl > 1)) {
+		mvOsPrintf("%s: data table %d is out of range [0..1]\n", __func__, tbl);
+		return MV_BAD_PARAM;
+	}
+
+	max = mvPp2PmeDataTblSize(tbl);
+	for (idx = 0; idx < max; idx++)
+		mvPp2PmeHwDataTblWrite(tbl, idx, 0);
+
+	return MV_OK;
+}
+
+/* Functions to set other PME register fields */
+MV_STATUS   mvPp2PmeVlanEtherTypeSet(int idx, MV_U16 ethertype)
+{
+	MV_U32 regVal = (MV_U32)ethertype;
+
+	if ((idx < 0) || (idx > MV_PP2_PME_MAX_VLAN_ETH_TYPES)) {
+		mvOsPrintf("%s: idx %d is out of range [0..%d]\n", __func__, idx, MV_PP2_PME_MAX_VLAN_ETH_TYPES);
+		return MV_BAD_PARAM;
+	}
+	mvPp2WrReg(MV_PP2_PME_VLAN_ETH_TYPE_REG(idx), regVal);
+
+	return MV_OK;
+}
+
+MV_STATUS   mvPp2PmeVlanDefaultSet(MV_U16 ethertype)
+{
+	mvPp2WrReg(MV_PP2_PME_DEF_VLAN_CFG_REG, (MV_U32)ethertype);
+	return MV_OK;
+}
+
+MV_STATUS   mvPp2PmeDsaDefaultSet(int idx, MV_U16 ethertype)
+{
+	MV_U32 regVal = (MV_U32)ethertype;
+
+	if ((idx < 0) || (idx > MV_PP2_PME_MAX_DSA_ETH_TYPES)) {
+		mvOsPrintf("%s: idx %d is out of range [0..%d]\n", __func__, idx, MV_PP2_PME_MAX_DSA_ETH_TYPES);
+		return MV_BAD_PARAM;
+	}
+	mvPp2WrReg(MV_PP2_PME_DEF_DSA_CFG_REG(idx), regVal);
+	return MV_OK;
+}
+
+MV_STATUS   mvPp2PmeDsaSrcDevSet(MV_U8 src)
+{
+	MV_U32 regVal = 0;
+
+	regVal &= ~MV_PP2_PME_DSA_SRC_DEV_ALL_MASK;
+	regVal |= MV_PP2_PME_DSA_SRC_DEV_MASK(src);
+	mvPp2WrReg(MV_PP2_PME_DEF_DSA_SRC_DEV_REG, regVal);
+	return MV_OK;
+}
+
+MV_STATUS   mvPp2PmeTtlZeroSet(int forward)
+{
+	MV_U32 regVal = 0;
+
+	regVal |= MV_PP2_PME_TTL_ZERO_FRWD_MASK;
+	mvPp2WrReg(MV_PP2_PME_TTL_ZERO_FRWD_REG, regVal);
+	return MV_OK;
+}
+
+MV_STATUS   mvPp2PmePppoeEtypeSet(MV_U16 ethertype)
+{
+	mvPp2WrReg(MV_PP2_PME_PPPOE_ETYPE_REG, (MV_U32)ethertype);
+	return MV_OK;
+}
+
+MV_STATUS   mvPp2PmePppoeLengthSet(MV_U16 length)
+{
+	mvPp2WrReg(MV_PP2_PME_PPPOE_LEN_REG, (MV_U32)length);
+	return MV_OK;
+}
+
+MV_STATUS   mvPp2PmePppoeConfig(MV_U8 version, MV_U8 type, MV_U8 code)
+{
+	MV_U32 regVal = 0;
+
+	regVal |= MV_PP2_PME_PPPOE_VER_MASK(version);
+	regVal |= MV_PP2_PME_PPPOE_TYPE_MASK(type);
+	regVal |= MV_PP2_PME_PPPOE_CODE_MASK(code);
+
+	mvPp2WrReg(MV_PP2_PME_PPPOE_DATA_REG, regVal);
+
+	return MV_OK;
+}
+
+MV_STATUS   mvPp2PmePppoeProtoSet(int idx, MV_U16 protocol)
+{
+	MV_U32 regVal = 0;
+
+	if ((idx < 0) || (idx > 1)) {
+		mvOsPrintf("%s: idx %d is out of range [0..1]\n", __func__, idx);
+		return MV_BAD_PARAM;
+	}
+	regVal = mvPp2RdReg(MV_PP2_PME_PPPOE_PROTO_REG);
+
+	regVal &= ~MV_PP2_PME_PPPOE_PROTO_ALL_MASK(idx);
+	regVal |= MV_PP2_PME_PPPOE_PROTO_MASK(idx, protocol);
+	mvPp2WrReg(MV_PP2_PME_PPPOE_PROTO_REG, regVal);
+
+	return MV_OK;
+}
+
+MV_STATUS   mvPp2PmeMaxConfig(int maxsize, int maxinstr, int errdrop)
+{
+	MV_U32 regVal = 0;
+
+	regVal |= MV_PP2_PME_MAX_INSTR_NUM_MASK(maxinstr);
+	regVal |= MV_PP2_PME_MAX_HDR_SIZE_MASK(maxsize);
+	if (errdrop)
+		regVal |= MV_PP2_PME_DROP_ON_ERR_MASK;
+
+	mvPp2WrReg(MV_PP2_PME_CONFIG_REG, regVal);
+
+	return MV_OK;
+}
diff --git a/arch/arm/plat-armada/mv_hal/pp2/pme/mvPp2PmeHw.h b/arch/arm/plat-armada/mv_hal/pp2/pme/mvPp2PmeHw.h
new file mode 100644
index 0000000..e1c2791
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/pme/mvPp2PmeHw.h
@@ -0,0 +1,303 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __mvPp2PmeHw_h__
+#define __mvPp2PmeHw_h__
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* FIXME: move to ctrlSpec.h */
+#define MV_PP2_PME_INSTR_SIZE	2600
+#define MV_PP2_PME_DATA1_SIZE   (46 * 1024 / 2) /* 46KBytes = 23K data of 2 bytes */
+#define MV_PP2_PME_DATA2_SIZE   (4 * 1024 / 2) /* 4KBytes = 2K data of 2 bytes */
+
+/*************** TX Packet Modification Registers *******************/
+#define MV_PP2_PME_TBL_IDX_REG				(MV_PP2_REG_BASE + 0x8400)
+#define MV_PP2_PME_TBL_INSTR_REG			(MV_PP2_REG_BASE + 0x8480)
+#define MV_PP2_PME_TBL_DATA1_REG			(MV_PP2_REG_BASE + 0x8500)
+#define MV_PP2_PME_TBL_DATA2_REG			(MV_PP2_REG_BASE + 0x8580)
+#define MV_PP2_PME_TBL_STATUS_REG			(MV_PP2_REG_BASE + 0x8600)
+#define MV_PP2_PME_TCONT_THRESH_REG			(MV_PP2_REG_BASE + 0x8604)
+#define MV_PP2_PME_MTU_REG					(MV_PP2_REG_BASE + 0x8608)
+
+#define MV_PP2_PME_MAX_VLAN_ETH_TYPES		4
+#define MV_PP2_PME_VLAN_ETH_TYPE_REG(i)		(MV_PP2_REG_BASE + 0x8610 + ((i) << 2))
+/*---------------------------------------------------------------------------*/
+
+#define MV_PP2_PME_DEF_VLAN_CFG_REG			(MV_PP2_REG_BASE + 0x8620)
+/*---------------------------------------------------------------------------*/
+
+#define MV_PP2_PME_MAX_DSA_ETH_TYPES		2
+#define MV_PP2_PME_DEF_DSA_CFG_REG(i)		(MV_PP2_REG_BASE + 0x8624 + ((i) << 2))
+/*---------------------------------------------------------------------------*/
+
+#define MV_PP2_PME_DEF_DSA_SRC_DEV_REG		(MV_PP2_REG_BASE + 0x8630)
+#define MV_PP2_PME_DSA_SRC_DEV_OFFS			1
+#define MV_PP2_PME_DSA_SRC_DEV_BITS			4
+#define MV_PP2_PME_DSA_SRC_DEV_ALL_MASK		(((1 << MV_PP2_PME_DSA_SRC_DEV_BITS) - 1) << MV_PP2_PME_DSA_SRC_DEV_OFFS)
+#define MV_PP2_PME_DSA_SRC_DEV_MASK(dev)	((dev) << MV_PP2_PME_DSA_SRC_DEV_OFFS)
+/*---------------------------------------------------------------------------*/
+
+#define MV_PP2_PME_TTL_ZERO_FRWD_REG		(MV_PP2_REG_BASE + 0x8640)
+#define MV_PP2_PME_TTL_ZERO_FRWD_BIT		0
+#define MV_PP2_PME_TTL_ZERO_FRWD_MASK		(1 << MV_PP2_PME_TTL_ZERO_FRWD_BIT);
+/*---------------------------------------------------------------------------*/
+
+#define MV_PP2_PME_PPPOE_ETYPE_REG			(MV_PP2_REG_BASE + 0x8650)
+
+#define MV_PP2_PME_PPPOE_DATA_REG			(MV_PP2_REG_BASE + 0x8654)
+
+#define MV_PP2_PME_PPPOE_CODE_OFFS			0
+#define MV_PP2_PME_PPPOE_CODE_BITS			8
+#define MV_PP2_PME_PPPOE_CODE_ALL_MASK		(((1 << MV_PP2_PME_PPPOE_CODE_BITS) - 1) << MV_PP2_PME_PPPOE_CODE_OFFS)
+#define MV_PP2_PME_PPPOE_CODE_MASK(code)	(((code) << MV_PP2_PME_PPPOE_CODE_OFFS) & MV_PP2_PME_PPPOE_CODE_ALL_MASK)
+
+#define MV_PP2_PME_PPPOE_TYPE_OFFS			8
+#define MV_PP2_PME_PPPOE_TYPE_BITS			4
+#define MV_PP2_PME_PPPOE_TYPE_ALL_MASK		(((1 << MV_PP2_PME_PPPOE_TYPE_BITS) - 1) << MV_PP2_PME_PPPOE_TYPE_OFFS)
+#define MV_PP2_PME_PPPOE_TYPE_MASK(type)	(((type) << MV_PP2_PME_PPPOE_TYPE_OFFS) & MV_PP2_PME_PPPOE_TYPE_ALL_MASK)
+
+#define MV_PP2_PME_PPPOE_VER_OFFS			12
+#define MV_PP2_PME_PPPOE_VER_BITS			4
+#define MV_PP2_PME_PPPOE_VER_ALL_MASK		(((1 << MV_PP2_PME_PPPOE_VER_BITS) - 1) << MV_PP2_PME_PPPOE_VER_OFFS)
+#define MV_PP2_PME_PPPOE_VER_MASK(ver)		(((ver) << MV_PP2_PME_PPPOE_VER_OFFS) & MV_PP2_PME_PPPOE_VER_ALL_MASK)
+/*---------------------------------------------------------------------------*/
+
+#define MV_PP2_PME_PPPOE_LEN_REG			(MV_PP2_REG_BASE + 0x8658)
+/*---------------------------------------------------------------------------*/
+
+#define MV_PP2_PME_PPPOE_PROTO_REG			(MV_PP2_REG_BASE + 0x865c)
+
+#define MV_PP2_PME_PPPOE_PROTO_OFFS(i)		((i == 0) ? 0 : 16)
+#define MV_PP2_PME_PPPOE_PROTO_BITS			16
+#define MV_PP2_PME_PPPOE_PROTO_ALL_MASK(i)	(((1 << MV_PP2_PME_PPPOE_PROTO_BITS) - 1) << MV_PP2_PME_PPPOE_PROTO_OFFS(i))
+#define MV_PP2_PME_PPPOE_PROTO_MASK(i, p)	(((p) << MV_PP2_PME_PPPOE_PROTO_OFFS(i)) & MV_PP2_PME_PPPOE_PROTO_ALL_MASK(i))
+/*---------------------------------------------------------------------------*/
+
+#define MV_PP2_PME_CONFIG_REG				(MV_PP2_REG_BASE + 0x8660)
+
+#define MV_PP2_PME_MAX_HDR_SIZE_OFFS		0
+#define MV_PP2_PME_MAX_HDR_SIZE_BITS		8
+#define MV_PP2_PME_MAX_HDR_SIZE_ALL_MASK	(((1 << MV_PP2_PME_MAX_HDR_SIZE_BITS) - 1) << MV_PP2_PME_MAX_HDR_SIZE_OFFS)
+#define MV_PP2_PME_MAX_HDR_SIZE_MASK(size)	(((size) << MV_PP2_PME_MAX_HDR_SIZE_OFFS) & MV_PP2_PME_MAX_HDR_SIZE_ALL_MASK)
+
+#define MV_PP2_PME_MAX_INSTR_NUM_OFFS		16
+#define MV_PP2_PME_MAX_INSTR_NUM_BITS		8
+#define MV_PP2_PME_MAX_INSTR_NUM_ALL_MASK	(((1 << MV_PP2_PME_MAX_INSTR_NUM_BITS) - 1) << MV_PP2_PME_MAX_INSTR_NUM_OFFS)
+#define MV_PP2_PME_MAX_INSTR_NUM_MASK(num)	(((num) << MV_PP2_PME_MAX_INSTR_NUM_OFFS) & MV_PP2_PME_MAX_INSTR_NUM_ALL_MASK)
+
+#define MV_PP2_PME_DROP_ON_ERR_BIT			24
+#define MV_PP2_PME_DROP_ON_ERR_MASK			(1 << MV_PP2_PME_DROP_ON_ERR_BIT)
+/*---------------------------------------------------------------------------*/
+
+#define MV_PP2_PME_STATUS_1_REG				(MV_PP2_REG_BASE + 0x8664)
+#define MV_PP2_PME_STATUS_2_REG(txp)		(MV_PP2_REG_BASE + 0x8700 + 4 * (txp))
+#define MV_PP2_PME_STATUS_3_REG(txp)		(MV_PP2_REG_BASE + 0x8780 + 4 * (txp))
+
+/* PME instructions table (MV_PP2_PME_TBL_INSTR_REG) fields definition */
+#define MV_PP2_PME_DATA_OFFS				0
+#define MV_PP2_PME_DATA_BITS				16
+#define MV_PP2_PME_DATA_MASK				(((1 << MV_PP2_PME_DATA_BITS) - 1) << MV_PP2_PME_DATA_OFFS)
+
+#define MV_PP2_PME_CTRL_OFFS				16
+#define MV_PP2_PME_CTRL_BITS				16
+#define MV_PP2_PME_CTRL_MASK				(((1 << MV_PP2_PME_CTRL_BITS) - 1) << MV_PP2_PME_CTRL_OFFS)
+
+#define MV_PP2_PME_CMD_OFFS					16
+#define MV_PP2_PME_CMD_BITS					5
+#define MV_PP2_PME_CMD_ALL_MASK				(((1 << MV_PP2_PME_CMD_BITS) - 1) << MV_PP2_PME_CMD_OFFS)
+#define MV_PP2_PME_CMD_MASK(cmd)			((cmd) << MV_PP2_PME_CMD_OFFS)
+
+#define MV_PP2_PME_IP4_CSUM_BIT				21
+#define MV_PP2_PME_IP4_CSUM_MASK			(1 << MV_PP2_PME_IP4_CSUM_BIT)
+
+#define MV_PP2_PME_L4_CSUM_BIT				22
+#define MV_PP2_PME_L4_CSUM_MASK				(1 << MV_PP2_PME_L4_CSUM_BIT)
+
+#define MV_PP2_PME_LAST_BIT					23
+#define MV_PP2_PME_LAST_MASK				(1 << MV_PP2_PME_LAST_BIT)
+
+#define MV_PP2_PME_CMD_TYPE_OFFS			24
+#define MV_PP2_PME_CMD_TYPE_BITS			3
+#define MV_PP2_PME_CMD_TYPE_ALL_MASK		(((1 << MV_PP2_PME_CMD_TYPE_BITS) - 1) << MV_PP2_PME_CMD_TYPE_OFFS)
+#define MV_PP2_PME_CMD_TYPE_MASK(type)		((type) << MV_PP2_PME_CMD_TYPE_OFFS)
+
+enum MV_PP2_PME_CMD_E {
+	MV_PP2_PME_CMD_NONE        = 0,
+	MV_PP2_PME_CMD_ADD_2B,
+	MV_PP2_PME_CMD_CFG_VLAN,
+	MV_PP2_PME_CMD_ADD_VLAN,
+	MV_PP2_PME_CMD_CFG_DSA_1,
+	MV_PP2_PME_CMD_CFG_DSA_2,
+	MV_PP2_PME_CMD_ADD_DSA,
+	MV_PP2_PME_CMD_DEL_BYTES,
+	MV_PP2_PME_CMD_REPLACE_2B,
+	MV_PP2_PME_CMD_REPLACE_LSB,
+	MV_PP2_PME_CMD_REPLACE_MSB,
+	MV_PP2_PME_CMD_REPLACE_VLAN,
+	MV_PP2_PME_CMD_DEC_LSB,
+	MV_PP2_PME_CMD_DEC_MSB,
+	MV_PP2_PME_CMD_ADD_CALC_LEN,
+	MV_PP2_PME_CMD_REPLACE_LEN,
+	MV_PP2_PME_CMD_IPV4_CSUM,
+	MV_PP2_PME_CMD_L4_CSUM,
+	MV_PP2_PME_CMD_SKIP,
+	MV_PP2_PME_CMD_JUMP,
+	MV_PP2_PME_CMD_JUMP_SKIP,
+	MV_PP2_PME_CMD_JUMP_SUB,
+	MV_PP2_PME_CMD_PPPOE,
+	MV_PP2_PME_CMD_STORE,
+	MV_PP2_PME_CMD_ADD_IP4_CSUM,
+	MV_PP2_PME_CMD_PPPOE_2,
+	MV_PP2_PME_CMD_REPLACE_MID,
+	MV_PP2_PME_CMD_ADD_MULT,
+	MV_PP2_PME_CMD_REPLACE_MULT,
+	MV_PP2_PME_CMD_RESERVED_1,
+	MV_PP2_PME_CMD_RESERVED_2,
+	MV_PP2_PME_CMD_DROP_PKT = 0x1f,
+	MV_PP2_TMP_CMD_LAST
+};
+
+/* PME data1 and data2 fields MV_PP2_PME_TBL_DATA1_REG and MV_PP2_PME_TBL_DATA2_REG */
+#define MV_PP2_PME_TBL_DATA_BITS		16
+#define MV_PP2_PME_TBL_DATA_OFFS(idx)	((idx == 0) ? MV_PP2_PME_TBL_DATA_BITS : 0)
+#define MV_PP2_PME_TBL_DATA_MASK(idx)	(((1 << MV_PP2_PME_TBL_DATA_BITS) - 1) << MV_PP2_PME_TBL_DATA_OFFS(idx))
+
+/* Macros for internal usage */
+#define MV_PP2_PME_IS_VALID(pme)        \
+		((((pme)->word & MV_PP2_PME_CMD_ALL_MASK) >> MV_PP2_PME_CMD_OFFS) != MV_PP2_PME_CMD_NONE)
+
+#define MV_PP2_PME_INVALID_SET(pme)        \
+		((pme)->word = MV_PP2_PME_CMD_MASK(MV_NETA_CMD_NONE) | MV_PP2_PME_LAST_MASK);
+
+#define MV_PP2_PME_CTRL_GET(pme)           \
+		(MV_U16)(((pme)->word & MV_PP2_PME_CTRL_MASK) >> MV_PP2_PME_CTRL_OFFS)
+
+#define MV_PP2_PME_CMD_GET(pme)           \
+		(((pme)->word & MV_PP2_PME_CMD_ALL_MASK) >> MV_PP2_PME_CMD_OFFS)
+
+#define MV_PP2_PME_DATA_GET(pme)           \
+		(MV_U16)(((pme)->word & MV_PP2_PME_DATA_MASK) >> MV_PP2_PME_DATA_OFFS)
+
+#define MV_PP2_PME_CMD_SET(pme, cmd)                       \
+		(pme)->word &= ~MV_PP2_PME_CMD_ALL_MASK;       \
+		(pme)->word |= MV_PP2_PME_CMD_MASK(cmd);
+
+#define MV_PP2_PME_DATA_SET(pme, data)                         \
+		(pme)->word &= ~MV_PP2_PME_DATA_MASK;              \
+		(pme)->word |= ((data) << MV_PP2_PME_DATA_OFFS);
+
+/* TX packet modification table entry */
+typedef struct mv_pp2_pme {
+	int     index;
+	MV_U32	word;
+
+} MV_PP2_PME_ENTRY;
+/*------------------------------------------------------------*/
+
+
+/* TX packet modification APIs */
+void        mvPp2PmeHwRegs(void);
+void        mvPp2PmeHwCntrs(void);
+MV_STATUS   mvPp2PmeHwDump(int mode);
+MV_STATUS   mvPp2PmeHwInvAll(void);
+
+MV_STATUS   mvPp2PmeHwInv(int idx);
+MV_STATUS   mvPp2PmeHwWrite(int idx, MV_PP2_PME_ENTRY *pEntry);
+MV_STATUS   mvPp2PmeHwRead(int idx, MV_PP2_PME_ENTRY *pEntry);
+
+MV_STATUS   mvPp2PmeSwDump(MV_PP2_PME_ENTRY *pEntry);
+MV_STATUS   mvPp2PmeSwClear(MV_PP2_PME_ENTRY *pEntry);
+MV_STATUS   mvPp2PmeSwWordSet(MV_PP2_PME_ENTRY *pEntry, MV_U32 word);
+MV_STATUS   mvPp2PmeSwCmdSet(MV_PP2_PME_ENTRY *pEntry, enum MV_PP2_PME_CMD_E cmd);
+MV_STATUS   mvPp2PmeSwCmdTypeSet(MV_PP2_PME_ENTRY *pEntry, int type);
+MV_STATUS   mvPp2PmeSwCmdFlagsSet(MV_PP2_PME_ENTRY *pEntry, int last, int ipv4, int l4);
+MV_STATUS   mvPp2PmeSwCmdLastSet(MV_PP2_PME_ENTRY *pEntry, int last);
+MV_STATUS   mvPp2PmeSwCmdDataSet(MV_PP2_PME_ENTRY *pEntry, MV_U16 data);
+
+MV_STATUS   mvPp2PmeHwDataTblDump(int tbl);
+MV_STATUS   mvPp2PmeHwDataTblClear(int tbl);
+MV_STATUS   mvPp2PmeHwDataTblWrite(int tbl, int idx, MV_U16 data);
+MV_STATUS   mvPp2PmeHwDataTblRead(int tbl, int idx, MV_U16 *data);
+
+MV_STATUS   mvPp2PmeVlanEtherTypeSet(int idx, MV_U16 ethertype);
+MV_STATUS   mvPp2PmeVlanDefaultSet(MV_U16 ethertype);
+MV_STATUS   mvPp2PmeDsaDefaultSet(int idx, MV_U16 ethertype);
+MV_STATUS   mvPp2PmeDsaSrcDevSet(MV_U8 src);
+MV_STATUS   mvPp2PmeTtlZeroSet(int forward);
+MV_STATUS   mvPp2PmePppoeConfig(MV_U8 version, MV_U8 type, MV_U8 code);
+MV_STATUS   mvPp2PmePppoeProtoSet(int idx, MV_U16 protocol);
+MV_STATUS   mvPp2PmePppoeEtypeSet(MV_U16 ethertype);
+MV_STATUS   mvPp2PmePppoeLengthSet(MV_U16 length);
+MV_STATUS   mvPp2PmeMaxConfig(int maxsize, int maxinstr, int errdrop);
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __mvPp2PmeHw_h__ */
diff --git a/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.c b/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.c
new file mode 100644
index 0000000..2f2ab3f
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.c
@@ -0,0 +1,2039 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#include "mvOs.h"
+#include "mvCommon.h"
+#include "mv802_3.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "mvPp2Prs.h"
+#include "pp2/gbe/mvPp2Gbe.h"
+#include "mvPp2PrsHw.h"
+
+#define PRS_DBG(X...)
+
+
+/*-------------------------------------------------------------------------------*/
+/*		Static varialbes for internal use				 */
+/*-------------------------------------------------------------------------------*/
+
+int etherTypeDsa;
+
+int mvPrsDblVlanAiShadow[DBL_VLAN_SHADOW_SIZE];
+
+static int mvPrsDblVlanAiShadowSet(int index)
+{
+	RANGE_VALIDATE(index, 1, DBL_VLAN_SHADOW_SIZE - 1);
+	mvPrsDblVlanAiShadow[index] = 1;
+	return MV_OK;
+}
+
+
+static int mvPrsDblVlanAiShadowClear(int index)
+{
+	RANGE_VALIDATE(index, 1, DBL_VLAN_SHADOW_SIZE - 1);
+	mvPrsDblVlanAiShadow[index] = 0;
+	return MV_OK;
+}
+
+static int mvPrsDblVlanAiShadowClearAll(void)
+{
+	int i;
+
+	for (i = 1; i < DBL_VLAN_SHADOW_SIZE; i++)
+		mvPrsDblVlanAiShadowClear(i);
+
+	return MV_OK;
+}
+static int mvPrsDblVlanAiFreeGet(void)
+{
+	int i;
+	/* start from 1, 0 not in used */
+	for (i = 1; i < DBL_VLAN_SHADOW_SIZE; i++)
+		if (mvPrsDblVlanAiShadow[i] == 0)
+			return i;
+
+	return MV_PRS_OUT_OF_RAGE;
+}
+
+
+/******************************************************************************
+ * Common utilities
+ ******************************************************************************/
+/*
+ * Helper: match ethertype
+ */
+static void mvPp2PrsMatchEtype(MV_PP2_PRS_ENTRY *pe, int offset, unsigned short ethertype)
+{
+	PRS_DBG("%s\n", __func__);
+
+	mvPp2PrsSwTcamByteSet(pe, offset + 0, ethertype >> 8, 0xff);
+	mvPp2PrsSwTcamByteSet(pe, offset + 1, ethertype & 0xFF, 0xff);
+}
+
+static void mvPp2PrsMatchMh(MV_PP2_PRS_ENTRY *pe, unsigned short mh)
+{
+	PRS_DBG("%s\n", __func__);
+
+	mvPp2PrsSwTcamByteSet(pe, 0, mh >> 8, 0xff);
+	mvPp2PrsSwTcamByteSet(pe, 1, mh & 0xFF, 0xff);
+}
+
+/******************************************************************************
+ *
+ * MAC Address Section
+ *
+ ******************************************************************************
+ */
+
+static MV_PP2_PRS_ENTRY *mvPrsMacDaFind(unsigned char *da)
+{
+	MV_PP2_PRS_ENTRY *pe;
+	int tid;
+
+	pe = mvPp2PrsSwAlloc(PRS_LU_MAC);
+
+	/* Go through the all entires with PRS_LU_MAC */
+	for (tid = PE_FIRST_FREE_TID ; tid <= PE_LAST_FREE_TID; tid++) {
+		if ((!mvPp2PrsShadowIsValid(tid)) || (mvPp2PrsShadowLu(tid) != PRS_LU_MAC))
+			continue;
+
+		pe->index = tid;
+		mvPp2PrsHwRead(pe);
+		if (mvPp2PrsSwTcamBytesIgnorMaskCmp(pe, MV_ETH_MH_SIZE, MV_MAC_ADDR_SIZE, da) == EQUALS)
+			return pe;
+	}
+	mvPp2PrsSwFree(pe);
+	return NULL;
+}
+
+/* Accept special MAC DA - 6 bytes */
+int mvPrsMacDaAccept(int port, unsigned char *da, int add)
+{
+	MV_PP2_PRS_ENTRY *pe = NULL;
+	unsigned int     len, ports;
+	int              tid;
+	char             *name;
+
+	/* Scan TCAM and see if entry with this MAC DA already exist */
+	pe = mvPrsMacDaFind(da);
+	if (pe == NULL) {
+		/* No such entry */
+		if (!add) {
+			/* Can't remove - No such entry */
+			return MV_ERROR;
+		}
+		/* Create new TCAM entry */
+
+		/* Go through the all entires from first to last */
+		tid = mvPp2PrsTcamFirstFree(0, MV_PP2_PRS_TCAM_SIZE - 1);
+
+		/* Can't add - No free TCAM entries */
+		if (tid == MV_PRS_OUT_OF_RAGE) {
+			mvOsPrintf("%s: No free TCAM entiry\n", __func__);
+			return MV_ERROR;
+		}
+
+		pe = mvPp2PrsSwAlloc(PRS_LU_MAC);
+		pe->index = tid;
+
+		mvPp2PrsSwTcamPortMapSet(pe, 0);
+
+	}
+	/* Update port mask */
+	mvPp2PrsSwTcamPortSet(pe, port, add);
+	mvPp2PrsSwTcamPortMapGet(pe, &ports);
+
+	if (ports == 0) {
+		if (add) {
+			/* Internal error, port should be set in ports bitmap */
+			return MV_ERROR;
+		}
+		/* No ports - invalidate the entry */
+		mvPp2PrsHwInv(pe->index);
+		mvPp2PrsShadowClear(pe->index);
+		return MV_OK;
+
+	}
+
+	/* Continue - set next lookup */
+	mvPp2PrsSwSramNextLuSet(pe, PRS_LU_DSA);
+
+	/* set match on DA */
+	len = MV_MAC_ADDR_SIZE;
+	while (len--)
+		mvPp2PrsSwTcamByteSet(pe, MV_ETH_MH_SIZE + len, da[len], 0xff);
+
+	/* Set result info bits */
+	if (MV_IS_BROADCAST_MAC(da)) {
+		mvPp2PrsSwSramRiUpdate(pe, RI_L2_BCAST, RI_L2_CAST_MASK);
+		name = "bcast";
+	/*TODO - remove mcast ,  handled in mvPrsMacAllMultiSet */
+	} else if (MV_IS_MULTICAST_MAC(da)) {
+		mvPp2PrsSwSramRiUpdate(pe, RI_L2_MCAST, RI_L2_CAST_MASK);
+		name = "mcast";
+	} else {
+		mvPp2PrsSwSramRiUpdate(pe, RI_L2_UCAST, RI_L2_CAST_MASK);
+		name = "ucast";
+	}
+
+	mvPp2PrsSwSramRiSetBit(pe, RI_MAC_ME_BIT);
+
+	/* shift to ethertype */
+	mvPp2PrsSwSramShiftSet(pe, MV_ETH_MH_SIZE + 2 * MV_MAC_ADDR_SIZE, SRAM_OP_SEL_SHIFT_ADD);
+
+	/* Write entry to TCAM */
+	mvPp2PrsHwWrite(pe);
+
+	/* Update mvPrsShadowTbl */
+	mvPp2PrsShadowSet(pe->index, PRS_LU_MAC, name);
+
+	mvPp2PrsSwFree(pe);
+	return MV_OK;
+}
+
+/* Drop special MAC DA - 6 bytes */
+int mvPrsMacDaDrop(int port, unsigned char *da, int add)
+{
+	return MV_OK;
+}
+
+int mvPrsMacDropAllSet(int port, int add)
+{
+	MV_PP2_PRS_ENTRY pe;
+
+	if (mvPp2PrsShadowIsValid(PE_DROP_ALL)) {
+		/* Entry exist - update port only */
+		pe.index = PE_DROP_ALL;
+		mvPp2PrsHwRead(&pe);
+	} else {
+		/* Entry doesn't exist - create new */
+		mvPp2PrsSwClear(&pe);
+		mvPp2PrsSwTcamLuSet(&pe, PRS_LU_MAC);
+		pe.index = PE_DROP_ALL;
+
+		/* Non-promiscous mode for all ports - DROP unknown packets */
+		mvPp2PrsSwSramRiSetBit(&pe, RI_DROP_BIT);
+	/*	mvPp2PrsSwSramLuDoneSet(&pe);*/
+
+		mvPp2PrsSwSramFlowidGenSet(&pe);
+		mvPp2PrsSwSramNextLuSet(&pe, PRS_LU_FLOWS);
+
+		/* Update mvPrsShadowTbl */
+		mvPp2PrsShadowSet(pe.index, PRS_LU_MAC, "drop-all");
+
+		mvPp2PrsSwTcamPortMapSet(&pe, 0);
+	}
+
+	mvPp2PrsSwTcamPortSet(&pe, port, add);
+
+	mvPp2PrsHwWrite(&pe);
+
+	return MV_OK;
+}
+
+/* Set port to promiscous mode */
+int mvPrsMacPromiscousSet(int port, int add)
+{
+	MV_PP2_PRS_ENTRY pe;
+
+	/* Promiscous mode - Accept unknown packets */
+
+	if (mvPp2PrsShadowIsValid(PE_MAC_PROMISCOUS)) {
+		/* Entry exist - update port only */
+		pe.index = PE_MAC_PROMISCOUS;
+		mvPp2PrsHwRead(&pe);
+	} else {
+		/* Entry doesn't exist - create new */
+		mvPp2PrsSwClear(&pe);
+		mvPp2PrsSwTcamLuSet(&pe, PRS_LU_MAC);
+		pe.index = PE_MAC_PROMISCOUS;
+
+		/* Continue - set next lookup */
+		mvPp2PrsSwSramNextLuSet(&pe, PRS_LU_DSA);
+
+		/* Set result info bits */
+		mvPp2PrsSwSramRiUpdate(&pe, RI_L2_UCAST, RI_L2_CAST_MASK);
+
+		/* shift to ethertype */
+		mvPp2PrsSwSramShiftSet(&pe, MV_ETH_MH_SIZE + 2 * MV_MAC_ADDR_SIZE, SRAM_OP_SEL_SHIFT_ADD);
+
+		/* mask all ports */
+		mvPp2PrsSwTcamPortMapSet(&pe, 0);
+
+		/* Update mvPrsShadowTbl */
+		mvPp2PrsShadowSet(pe.index, PRS_LU_MAC, "promisc");
+	}
+
+	mvPp2PrsSwTcamPortSet(&pe, port, add);
+
+	mvPp2PrsHwWrite(&pe);
+
+	return MV_OK;
+}
+/* 0 - reject, 1 - accept */
+int mvPrsMacAllMultiSet(int port, int add)
+{
+	MV_PP2_PRS_ENTRY pe;
+
+	/* Ethernet multicast address first byte is with 0x01 */
+	unsigned char da_mc = 0x01;
+	/* all multicast */
+
+	if (mvPp2PrsShadowIsValid(PE_MAC_MC_ALL)) {
+		/* Entry exist - update port only */
+		pe.index = PE_MAC_MC_ALL;
+		mvPp2PrsHwRead(&pe);
+	} else {
+		/* Entry doesn't exist - create new */
+		mvPp2PrsSwClear(&pe);
+
+		pe.index = PE_MAC_MC_ALL;
+
+		mvPp2PrsSwTcamLuSet(&pe, PRS_LU_MAC);
+
+		/* Continue - set next lookup */
+		mvPp2PrsSwSramNextLuSet(&pe, PRS_LU_DSA);
+
+		/* Set result info bits */
+		mvPp2PrsSwSramRiUpdate(&pe, RI_L2_MCAST, RI_L2_CAST_MASK);
+
+		mvPp2PrsSwTcamByteSet(&pe, MV_ETH_MH_SIZE, da_mc, 0xff);
+
+		/* shift to ethertype */
+		mvPp2PrsSwSramShiftSet(&pe, MV_ETH_MH_SIZE + 2 * MV_MAC_ADDR_SIZE, SRAM_OP_SEL_SHIFT_ADD);
+
+		/* no ports */
+		mvPp2PrsSwTcamPortMapSet(&pe, 0);
+
+		/* Update mvPrsShadowTbl */
+		mvPp2PrsShadowSet(pe.index, PRS_LU_MAC, "mcast-all");
+	}
+
+	mvPp2PrsSwTcamPortSet(&pe, port, add);
+
+	mvPp2PrsHwWrite(&pe);
+
+	return MV_OK;
+}
+
+int mvPrsMhRxSpecialSet(int port, int add, unsigned short mh)
+{
+	MV_PP2_PRS_ENTRY pe;
+
+	if (mvPp2PrsShadowIsValid(PE_RX_SPECIAL)) {
+		/* Entry exist - update port only */
+		pe.index = PE_RX_SPECIAL;
+		mvPp2PrsHwRead(&pe);
+	} else {
+		/* Entry doesn't exist - create new */
+		mvPp2PrsSwClear(&pe);
+		mvPp2PrsSwTcamLuSet(&pe, PRS_LU_MAC);
+		pe.index = PE_RX_SPECIAL;
+
+		mvPp2PrsSwSramRiUpdate(&pe, RI_CPU_CODE_RX_SPEC, RI_CPU_CODE_MASK);
+		mvPp2PrsSwSramFlowidGenSet(&pe);
+		mvPp2PrsSwSramNextLuSet(&pe, PRS_LU_FLOWS);
+
+		/* Update mvPrsShadowTbl */
+		mvPp2PrsShadowSet(pe.index, PRS_LU_MAC, "RX special");
+
+		mvPp2PrsSwTcamPortMapSet(&pe, 0);
+	}
+
+	mvPp2PrsMatchMh(&pe, mh);
+	mvPp2PrsSwTcamPortSet(&pe, port, add);
+
+	mvPp2PrsHwWrite(&pe);
+
+	return MV_OK;
+}
+
+/* Set default entires (place holder) for promiscous, non-promiscous and all-milticast MAC addresses */
+static int mvPp2PrsMacInit(void)
+{
+	MV_PP2_PRS_ENTRY pe;
+
+	mvPp2PrsSwClear(&pe);
+
+	/* Non-promiscous mode for all ports - DROP unknown packets */
+	pe.index = PE_MAC_NON_PROMISCOUS;
+	mvPp2PrsSwTcamLuSet(&pe, PRS_LU_MAC);
+	mvPp2PrsSwSramRiSetBit(&pe, RI_DROP_BIT);
+/*	mvPp2PrsSwSramLuDoneSet(&pe);*/
+
+	mvPp2PrsSwSramFlowidGenSet(&pe);
+	mvPp2PrsSwSramNextLuSet(&pe, PRS_LU_FLOWS);
+
+	/* Update mvPrsShadowTbl */
+	mvPp2PrsShadowSet(pe.index, PRS_LU_MAC, "non-promisc");
+
+	mvPp2PrsSwTcamPortMapSet(&pe, PORT_MASK);
+	mvPp2PrsHwWrite(&pe);
+
+	/* place holders only - no ports */
+	mvPrsMacDropAllSet(0, 0);
+	mvPrsMhRxSpecialSet(0, 0, 0);
+	mvPrsMacPromiscousSet(0, 0);
+	mvPrsMacAllMultiSet(0, 0);
+
+	return MV_OK;
+}
+/******************************************************************************
+ *
+ * DSA Section
+ *
+ ******************************************************************************
+ */
+
+static int mvPp2PrsDsaTagEtherTypeSet(int port, int add, int tagged, int extend)
+{
+	MV_PP2_PRS_ENTRY pe;
+	char name[PRS_TEXT_SIZE];
+	int tid, shift, portMask;
+
+	/* if packet is tagged continue check vlans */
+
+	if (extend) {
+		if (tagged) {
+			tid = PE_ETYPE_EDSA_TAGGED;
+			mvOsSPrintf(name, "Etype-EDSA-tagged");
+		} else {
+			tid = PE_ETYPE_EDSA_UNTAGGED;
+			mvOsSPrintf(name, "Etype-EDSA-untagged");
+		}
+		portMask = 0;
+		shift = 8;
+	} else {
+
+		if (tagged) {
+			tid = PE_ETYPE_DSA_TAGGED;
+			mvOsSPrintf(name, "Etype-DSA-tagged");
+		} else {
+			tid = PE_ETYPE_DSA_UNTAGGED;
+			mvOsSPrintf(name, "Etype-DSA-untagged");
+		}
+		portMask = PORT_MASK;
+		shift = 4;
+	}
+
+	if (mvPp2PrsShadowIsValid(tid)) {
+		/* Entry exist - update port only */
+		pe.index = tid;
+		mvPp2PrsHwRead(&pe);
+	} else {
+		/* Entry doesn't exist - create new */
+		mvPp2PrsSwClear(&pe);
+		mvPp2PrsSwTcamLuSet(&pe, PRS_LU_DSA);
+		pe.index = tid;
+
+		/* set etherType*/
+		mvPp2PrsMatchEtype(&pe, 0, etherTypeDsa);
+		mvPp2PrsMatchEtype(&pe, 2, 0);
+
+		mvPp2PrsSwSramRiSetBit(&pe, RI_DSA_BIT);
+
+		/* shift etherType + 2 byte reserved + tag*/
+		mvPp2PrsSwSramShiftSet(&pe, 2 + MV_ETH_TYPE_LEN + shift, SRAM_OP_SEL_SHIFT_ADD);
+
+		mvPp2PrsShadowSet(pe.index, PRS_LU_DSA, name);
+
+		/* set tagged bit in DSA tag */
+		/* TODO use define */
+		if (tagged) {
+			/* set bit 29 in dsa tag */
+			mvPp2PrsSwTcamByteSet(&pe, MV_ETH_TYPE_LEN + 2 + 3, 0x20, 0x20);
+
+			/* Clear all AI bits for next iteration */
+			mvPp2PrsSwSramAiUpdate(&pe, 0, SRAM_AI_MASK);
+
+			mvPp2PrsSwSramNextLuSet(&pe, PRS_LU_VLAN);
+		} else {
+			/* Set result info bits - No valns ! */
+			mvPp2PrsSwSramRiUpdate(&pe, RI_VLAN_NONE, RI_VLAN_MASK);
+			mvPp2PrsSwSramNextLuSet(&pe, PRS_LU_L2);
+		}
+		/* all ports enabled */
+		mvPp2PrsSwTcamPortMapSet(&pe, portMask);
+	}
+
+	mvPp2PrsSwTcamPortSet(&pe, port, add);
+
+	mvPp2PrsHwWrite(&pe);
+
+	return MV_OK;
+}
+
+
+static int mvPp2PrsDsaTagSet(int port, int add, int tagged, int extend)
+{
+	MV_PP2_PRS_ENTRY pe;
+	char name[PRS_TEXT_SIZE];
+	int tid, shift;
+
+	/* if packet is tagged continue check vlans */
+
+	if (extend) {
+		if (tagged) {
+			tid = PE_EDSA_TAGGED;
+			mvOsSPrintf(name, "EDSA-tagged");
+		} else {
+			tid = PE_EDSA_UNTAGGED;
+			mvOsSPrintf(name, "EDSA-untagged");
+		}
+
+		shift = 8;
+	} else {
+
+		if (tagged) {
+			tid = PE_DSA_TAGGED;
+			mvOsSPrintf(name, "DSA-tagged");
+		} else {
+			tid = PE_DSA_UNTAGGED;
+			mvOsSPrintf(name, "DSA-untagged");
+		}
+
+		shift = 4;
+	}
+
+	if (mvPp2PrsShadowIsValid(tid)) {
+		/* Entry exist - update port only */
+		pe.index = tid;
+		mvPp2PrsHwRead(&pe);
+	} else {
+		/* Entry doesn't exist - create new */
+		mvPp2PrsSwClear(&pe);
+		mvPp2PrsSwTcamLuSet(&pe, PRS_LU_DSA);
+		pe.index = tid;
+
+
+		/* shift 4 bytes if DSA tag , Skip 8 bytes if extand DSA tag*/
+		mvPp2PrsSwSramShiftSet(&pe, shift, SRAM_OP_SEL_SHIFT_ADD);
+
+		mvPp2PrsShadowSet(pe.index, PRS_LU_DSA, name);
+
+		/* set tagged bit in DSA tag */
+		/* TODO use define */
+		if (tagged) {
+			mvPp2PrsSwTcamByteSet(&pe, 3, 0x20, 0x20);
+
+			/* Clear all AI bits for next iteration */
+			mvPp2PrsSwSramAiUpdate(&pe, 0, SRAM_AI_MASK);
+
+			mvPp2PrsSwSramNextLuSet(&pe, PRS_LU_VLAN);
+		} else {
+			/* Set result info bits - No valns ! */
+			mvPp2PrsSwSramRiUpdate(&pe, RI_VLAN_NONE, RI_VLAN_MASK);
+			mvPp2PrsSwSramNextLuSet(&pe, PRS_LU_L2);
+		}
+
+		mvPp2PrsSwTcamPortMapSet(&pe, 0);
+	}
+
+	mvPp2PrsSwTcamPortSet(&pe, port, add);
+
+	mvPp2PrsHwWrite(&pe);
+
+	return MV_OK;
+}
+
+
+
+static int mvPp2PrsDsaInit(void)
+{
+	MV_PP2_PRS_ENTRY pe;
+
+	etherTypeDsa = DSA_ETHER_TYPE;
+
+	/* none tagged EDSA entry -place holder */
+	mvPp2PrsDsaTagSet(0, 0, UNTAGGED, EDSA);
+
+	/* tagged EDSA entry -place holder */
+	mvPp2PrsDsaTagSet(0, 0, TAGGED, EDSA);
+
+	/* none tagged DSA entry -place holder */
+	mvPp2PrsDsaTagSet(0, 0, UNTAGGED, DSA);
+
+	/* tagged DSA entry -place holder */
+	mvPp2PrsDsaTagSet(0, 0, TAGGED, DSA);
+
+	/* none tagged EDSA EtherType entry - place holder*/
+	mvPp2PrsDsaTagEtherTypeSet(0, 0, UNTAGGED, EDSA);
+
+	/* tagged EDSA EtherType entry - place holder*/
+	mvPp2PrsDsaTagEtherTypeSet(0, 0, TAGGED, EDSA);
+
+	/* none tagged DSA EtherType entry */
+	mvPp2PrsDsaTagEtherTypeSet(0, 1, UNTAGGED, DSA);
+
+	/* tagged DSA EtherType entry */
+	mvPp2PrsDsaTagEtherTypeSet(0, 1, TAGGED, DSA);
+
+	/* default entry , if DSA or EDSA tag not found */
+	mvPp2PrsSwClear(&pe);
+	mvPp2PrsSwTcamLuSet(&pe, PRS_LU_DSA);
+	pe.index = PE_DSA_DEFAULT;
+	mvPp2PrsSwSramNextLuSet(&pe, PRS_LU_VLAN);
+
+	/* shift 0 bytes */
+	mvPp2PrsSwSramShiftSet(&pe, 0, SRAM_OP_SEL_SHIFT_ADD);
+	mvPp2PrsShadowSet(pe.index, PRS_LU_MAC, "default-DSA-tag");
+
+	/* Clear all AI bits for next iteration */
+	mvPp2PrsSwSramAiUpdate(&pe, 0, SRAM_AI_MASK);
+
+	/* match for all ports*/
+	mvPp2PrsSwTcamPortMapSet(&pe, PORT_MASK);
+	mvPp2PrsHwWrite(&pe);
+
+	return MV_OK;
+}
+
+int mvPp2PrsEtypeDsaSet(unsigned int eType)
+{
+	int tid;
+
+	MV_PP2_PRS_ENTRY pe;
+
+	etherTypeDsa = eType;
+
+	for (tid = PE_ETYPE_EDSA_TAGGED; tid <= PE_ETYPE_DSA_UNTAGGED; tid++) {
+
+		pe.index = tid;
+
+		mvPp2PrsHwRead(&pe);
+
+		/* overrwite old etherType*/
+		mvPp2PrsMatchEtype(&pe, 0, etherTypeDsa);
+
+		mvPp2PrsHwWrite(&pe);
+	}
+
+	return MV_OK;
+}
+
+int mvPp2PrsEtypeDsaModeSet(int port, int extand)
+{
+	POS_RANGE_VALIDATE(port, MV_PP2_MAX_PORTS - 1);
+	POS_RANGE_VALIDATE(extand, 1);
+
+	if (extand) {
+		mvPp2PrsDsaTagEtherTypeSet(port, 1, UNTAGGED, EDSA);
+		mvPp2PrsDsaTagEtherTypeSet(port, 1, TAGGED, EDSA);
+		mvPp2PrsDsaTagEtherTypeSet(port, 0, UNTAGGED, DSA);
+		mvPp2PrsDsaTagEtherTypeSet(port, 0, TAGGED, DSA);
+	} else {
+		mvPp2PrsDsaTagEtherTypeSet(port, 0, UNTAGGED, EDSA);
+		mvPp2PrsDsaTagEtherTypeSet(port, 0, TAGGED, EDSA);
+		mvPp2PrsDsaTagEtherTypeSet(port, 1, UNTAGGED, DSA);
+		mvPp2PrsDsaTagEtherTypeSet(port, 1, TAGGED, DSA);
+	}
+	return MV_OK;
+}
+
+int mvPp2PrsTagModeSet(int port, int type)
+{
+
+	POS_RANGE_VALIDATE(port, MV_PP2_MAX_PORTS-1);
+
+	switch (type) {
+
+	case MV_PP2_DSA_EXT:
+		/* Add port to EDSA entries */
+		mvPp2PrsDsaTagSet(port, 1, TAGGED, EDSA);
+		mvPp2PrsDsaTagSet(port, 1, UNTAGGED, EDSA);
+		/* remove port from DSA entries */
+		mvPp2PrsDsaTagSet(port, 0, TAGGED, DSA);
+		mvPp2PrsDsaTagSet(port, 0, UNTAGGED, DSA);
+/*
+		 remove port from all EtherType DSA/EDSA entries
+		mvPp2PrsDsaTagEtherTypeSet(port, 0, UNTAGGED, EDSA);
+		mvPp2PrsDsaTagEtherTypeSet(port, 0, TAGGED, EDSA);
+		mvPp2PrsDsaTagEtherTypeSet(port, 0, UNTAGGED, DSA);
+		mvPp2PrsDsaTagEtherTypeSet(port, 0, TAGGED, DSA);
+*/
+		break;
+
+	case MV_PP2_DSA:
+		/* Add port to DSA entries */
+		mvPp2PrsDsaTagSet(port, 1, TAGGED, DSA);
+		mvPp2PrsDsaTagSet(port, 1, UNTAGGED, DSA);
+
+		/* remove port from EDSA entries */
+		mvPp2PrsDsaTagSet(port, 0, TAGGED, EDSA);
+		mvPp2PrsDsaTagSet(port, 0, UNTAGGED, EDSA);
+/*
+		remove port from all EtherType DSA/EDSA entries
+		mvPp2PrsDsaTagEtherTypeSet(port, 0, UNTAGGED, EDSA);
+		mvPp2PrsDsaTagEtherTypeSet(port, 0, TAGGED, EDSA);
+		mvPp2PrsDsaTagEtherTypeSet(port, 0, UNTAGGED, DSA);
+		mvPp2PrsDsaTagEtherTypeSet(port, 0, TAGGED, DSA);
+*/
+		break;
+
+	case MV_PP2_MH:
+	case MV_PP2_MH_NONE:
+
+		/* remove port form EDSA and DSA entries */
+		mvPp2PrsDsaTagSet(port, 0, TAGGED, DSA);
+		mvPp2PrsDsaTagSet(port, 0, UNTAGGED, DSA);
+		mvPp2PrsDsaTagSet(port, 0, TAGGED, EDSA);
+		mvPp2PrsDsaTagSet(port, 0, UNTAGGED, EDSA);
+/*
+		Add port from all EtherType DSA/EDSA entries
+		mvPp2PrsDsaTagEtherTypeSet(port, 1, UNTAGGED, EDSA);
+		mvPp2PrsDsaTagEtherTypeSet(port, 1, TAGGED, EDSA);
+		mvPp2PrsDsaTagEtherTypeSet(port, 1, UNTAGGED, DSA);
+		mvPp2PrsDsaTagEtherTypeSet(port, 1, TAGGED, DSA);
+*/
+		break;
+
+	default:
+		POS_RANGE_VALIDATE(type, MV_PP2_DSA_EXT);
+	}
+
+	return MV_OK;
+
+}
+
+
+/******************************************************************************
+ *
+ * VLAN Section
+ *
+ ******************************************************************************
+ */
+
+static MV_PP2_PRS_ENTRY *mvPrsVlanFind(unsigned short tpid, int ai)
+{
+	MV_PP2_PRS_ENTRY *pe;
+	int tid;
+	unsigned int riBits, aiBits, enable;
+	unsigned char tpidArr[2];
+
+	pe = mvPp2PrsSwAlloc(PRS_LU_VLAN);
+
+#ifndef CONFIG_CPU_BIG_ENDIAN
+	tpidArr[0] = ((unsigned char *)&tpid)[1];
+	tpidArr[1] = ((unsigned char *)&tpid)[0];
+#endif /* CONFIG_CPU_BIG_ENDIAN */
+
+	/* Go through the all entires with PRS_LU_MAC */
+	for (tid = PE_FIRST_FREE_TID ; tid <= PE_LAST_FREE_TID; tid++) {
+		if ((!mvPp2PrsShadowIsValid(tid)) || (mvPp2PrsShadowLu(tid) != PRS_LU_VLAN))
+			continue;
+
+		pe->index = tid;
+
+		mvPp2PrsHwRead(pe);
+		if (mvPp2PrsSwTcamBytesIgnorMaskCmp(pe, 0, 2, tpidArr) == EQUALS) {
+			mvPp2PrsSwSramRiGet(pe, &riBits, &enable);
+
+			/* get Vlan type */
+			riBits = (riBits & RI_VLAN_MASK);
+
+			/* get current AI value Tcam */
+			mvPp2PrsSwTcamAiGet(pe, &aiBits, &enable);
+
+			/* clear double Vlan Bit */
+			aiBits &= ~(1 << DBL_VLAN_AI_BIT);
+
+			if (ai != aiBits)
+				continue;
+
+			if ((riBits == RI_VLAN_SINGLE) || (riBits == RI_VLAN_TRIPLE))
+				return pe;
+		}
+	}
+	mvPp2PrsSwFree(pe);
+	return NULL;
+}
+
+static MV_PP2_PRS_ENTRY *mvPrsDoubleVlanFind(unsigned short tpid1, unsigned short tpid2)
+{
+	MV_PP2_PRS_ENTRY *pe;
+	int tid;
+	unsigned int bits, enable;
+	unsigned char tpidArr1[2];
+	unsigned char tpidArr2[2];
+
+#ifndef CONFIG_CPU_BIG_ENDIAN
+	tpidArr1[0] = ((unsigned char *)&tpid1)[1];
+	tpidArr1[1] = ((unsigned char *)&tpid1)[0];
+	tpidArr2[0] = ((unsigned char *)&tpid2)[1];
+	tpidArr2[1] = ((unsigned char *)&tpid2)[0];
+#endif /* CONFIG_CPU_BIG_ENDIAN */
+
+	pe = mvPp2PrsSwAlloc(PRS_LU_VLAN);
+
+	/* Go through the all entires with PRS_LU_MAC */
+	for (tid = PE_FIRST_FREE_TID ; tid <= PE_LAST_FREE_TID; tid++) {
+		if ((!mvPp2PrsShadowIsValid(tid)) || (mvPp2PrsShadowLu(tid) != PRS_LU_VLAN))
+			continue;
+
+		pe->index = tid;
+		mvPp2PrsHwRead(pe);
+		if ((mvPp2PrsSwTcamBytesIgnorMaskCmp(pe, 0, 2, tpidArr1) == EQUALS) &&
+			(mvPp2PrsSwTcamBytesIgnorMaskCmp(pe, 4, 2, tpidArr2) == EQUALS)) {
+
+			mvPp2PrsSwSramRiGet(pe, &bits, &enable);
+
+			if ((bits & RI_VLAN_MASK) == RI_VLAN_DOUBLE)
+				return pe;
+		}
+	}
+	mvPp2PrsSwFree(pe);
+	return NULL;
+}
+
+/* return last double vlan entry */
+static int mvPpPrsDoubleVlanLast(void)
+{
+	MV_PP2_PRS_ENTRY pe;
+	unsigned int bits, enable;
+	int tid;
+
+	for (tid = PE_LAST_FREE_TID; tid >= PE_FIRST_FREE_TID; tid--) {
+		if ((!mvPp2PrsShadowIsValid(tid)) || (mvPp2PrsShadowLu(tid) != PRS_LU_VLAN))
+			continue;
+
+		pe.index = tid;
+		mvPp2PrsHwRead(&pe);
+		mvPp2PrsSwSramRiGet(&pe, &bits, &enable);
+
+		if ((bits & RI_VLAN_MASK) == RI_VLAN_DOUBLE)
+			return tid;
+	}
+	return tid;
+}
+
+/* return first Single or Triple vlan entry */
+static int mvPpPrsVlanFirst(void)
+{
+	MV_PP2_PRS_ENTRY pe;
+	unsigned int bits, enable;
+	int tid;
+
+	for (tid = PE_FIRST_FREE_TID; tid <= PE_LAST_FREE_TID; tid++) {
+		if ((!mvPp2PrsShadowIsValid(tid)) || (mvPp2PrsShadowLu(tid) != PRS_LU_VLAN))
+			continue;
+
+		pe.index = tid;
+		mvPp2PrsHwRead(&pe);
+		mvPp2PrsSwSramRiGet(&pe, &bits, &enable);
+
+		bits &= RI_VLAN_MASK;
+
+		if ((bits == RI_VLAN_SINGLE) || (bits == RI_VLAN_TRIPLE))
+			return tid;
+	}
+	return tid;
+}
+
+static int mvPp2PrsVlanAdd(unsigned short tpid, int ai, unsigned int portBmp)
+{
+	int lastDouble, tid, status = 0;
+	MV_PP2_PRS_ENTRY *pe = NULL;
+	char name[PRS_TEXT_SIZE];
+
+	pe = mvPrsVlanFind(tpid, ai);
+
+	if (pe == NULL) {
+
+		/* Create new TCAM entry */
+		tid = mvPp2PrsTcamFirstFree(PE_LAST_FREE_TID, PE_FIRST_FREE_TID);
+
+		if (tid == MV_PRS_OUT_OF_RAGE) {
+			mvOsPrintf("%s: No free TCAM entiry\n", __func__);
+			return MV_ERROR;
+		}
+
+		/* get last double vlan tid */
+		lastDouble = mvPpPrsDoubleVlanLast();
+
+		if (tid <= lastDouble) {
+			/* double vlan entries overlapping*/
+			mvOsPrintf("%s:Can't add entry, please remove unnecessary triple or single vlans entries.\n", __func__);
+			return MV_ERROR;
+		}
+
+		pe = mvPp2PrsSwAlloc(PRS_LU_VLAN);
+		pe->index = tid;
+
+		mvPp2PrsMatchEtype(pe, 0, tpid);
+
+		/* Clear all AI bits for next iteration */
+		status |= mvPp2PrsSwSramAiUpdate(pe, 0, SRAM_AI_MASK);
+
+		/* Continue - set next lookup */
+		status |= mvPp2PrsSwSramNextLuSet(pe, PRS_LU_L2);
+
+		/* shift 4 bytes - skip 1 VLAN tags */
+		status |= mvPp2PrsSwSramShiftSet(pe, MV_VLAN_HLEN, SRAM_OP_SEL_SHIFT_ADD);
+
+		if (ai == SINGLE_VLAN_AI) {
+			/* single vlan*/
+			mvOsSPrintf(name, "single-VLAN");
+			mvPp2PrsSwSramRiUpdate(pe, RI_VLAN_SINGLE, RI_VLAN_MASK);
+		} else {
+			/* triple vlan*/
+			mvOsSPrintf(name, "triple-VLAN-%d", ai);
+			ai |= (1 << DBL_VLAN_AI_BIT);
+			mvPp2PrsSwSramRiUpdate(pe, RI_VLAN_TRIPLE, RI_VLAN_MASK);
+		}
+
+		status |= mvPp2PrsSwTcamAiUpdate(pe, ai, SRAM_AI_MASK);
+
+		mvPp2PrsShadowSet(pe->index, PRS_LU_VLAN, name);
+	}
+
+	status |= mvPp2PrsSwTcamPortMapSet(pe, portBmp);
+
+	if (status == 0)
+		mvPp2PrsHwWrite(pe);
+
+	mvPp2PrsSwFree(pe);
+
+	return MV_OK;
+}
+
+static int mvPp2PrsVlanDel(unsigned short tpid, int ai)
+{
+	MV_PP2_PRS_ENTRY *pe = NULL;
+
+	pe = mvPrsVlanFind(tpid, ai);
+
+	if (pe == NULL) {
+		/* No such entry */
+		mvOsPrintf("Can't remove - No such entry\n");
+		return MV_ERROR;
+	}
+
+	/* remove entry */
+	mvPp2PrsHwInv(pe->index);
+	mvPp2PrsShadowClear(pe->index);
+	mvPp2PrsSwFree(pe);
+	return MV_OK;
+}
+
+int mvPp2PrsDoubleVlanAdd(unsigned short tpid1, unsigned short tpid2, unsigned int portBmp)
+{
+	int tid, ai, status = 0;
+	int firstVlan;
+	MV_PP2_PRS_ENTRY *pe = NULL;
+	char name[PRS_TEXT_SIZE];
+
+	pe = mvPrsDoubleVlanFind(tpid1, tpid2);
+
+	if (pe == NULL) {
+
+		/* Create new TCAM entry */
+
+		tid = mvPp2PrsTcamFirstFree(PE_FIRST_FREE_TID, PE_LAST_FREE_TID);
+
+		if (tid == MV_PRS_OUT_OF_RAGE) {
+			mvOsPrintf("%s: No free TCAM entiry\n", __func__);
+			return MV_ERROR;
+		}
+
+		pe = mvPp2PrsSwAlloc(PRS_LU_VLAN);
+		pe->index = tid;
+
+		/* set AI value for new double vlan entry */
+		ai = mvPrsDblVlanAiFreeGet();
+
+		if (ai == MV_PRS_OUT_OF_RAGE) {
+			mvOsPrintf("%s: Can't add - number of Double vlan rules reached to maximum.\n", __func__);
+			return MV_ERROR;
+		}
+
+		/* get first single/triple vlan tid */
+		firstVlan = mvPpPrsVlanFirst();
+
+		if (tid >= firstVlan) {
+			/* double vlan entries overlapping*/
+			mvOsPrintf("%s:Can't add entry, please remove unnecessary double vlans entries.\n", __func__);
+			return MV_ERROR;
+		}
+
+		mvPrsDblVlanAiShadowSet(ai);
+
+		mvPp2PrsMatchEtype(pe, 0, tpid1);
+		mvPp2PrsMatchEtype(pe, 4, tpid2);
+
+		/* Set AI value in SRAM for double vlan */
+		status |= mvPp2PrsSwSramAiUpdate(pe, (ai | (1 << DBL_VLAN_AI_BIT)), SRAM_AI_MASK);
+
+		/* Continue - set next lookup, */
+		status |= mvPp2PrsSwSramNextLuSet(pe, PRS_LU_VLAN);
+
+		/* Set result info bits */
+		status |= mvPp2PrsSwSramRiUpdate(pe, RI_VLAN_DOUBLE, RI_VLAN_MASK);
+
+		/* shift 8 bytes - skip 2 VLAN tags */
+		status |= mvPp2PrsSwSramShiftSet(pe, 2 * MV_VLAN_HLEN, SRAM_OP_SEL_SHIFT_ADD);
+
+		/* Update mvPrsShadowTbl */
+		mvOsSPrintf(name, "double-VLAN-%d", ai);
+		mvPp2PrsShadowSet(pe->index, PRS_LU_VLAN, name);
+
+	}
+	/* set ports bitmap*/
+	status |= mvPp2PrsSwTcamPortMapSet(pe, portBmp);
+
+	if (status == 0)
+		mvPp2PrsHwWrite(pe);
+
+	mvPp2PrsSwFree(pe);
+
+	return status;
+}
+
+int mvPp2PrsDoubleVlanDel(unsigned short tpid1, unsigned short tpid2)
+{
+	MV_PP2_PRS_ENTRY *pe = NULL;
+	int ai, enable;
+
+
+	pe = mvPrsDoubleVlanFind(tpid1, tpid2);
+
+	if (pe == NULL) {
+		/* No such entry */
+		mvOsPrintf("Can't remove - No such entry\n");
+		return MV_ERROR;
+	}
+
+	/* TODO - remove all corresponding vlan triples  */
+
+	mvPp2PrsSwSramAiGet(pe, &ai, &enable);
+	/* remove double vlan AI sign*/
+	ai &= ~(1 << DBL_VLAN_AI_BIT);
+	mvPrsDblVlanAiShadowClear(ai);
+
+	/* remove entry */
+	mvPp2PrsHwInv(pe->index);
+	mvPp2PrsShadowClear(pe->index);
+	mvPp2PrsSwFree(pe);
+	return MV_OK;
+
+}
+
+
+int mvPp2PrsSingleVlan(unsigned short tpid, unsigned int portBmp, int add)
+{
+	if (add)
+		return mvPp2PrsVlanAdd(tpid, SINGLE_VLAN_AI, portBmp);
+	else
+		return mvPp2PrsVlanDel(tpid, SINGLE_VLAN_AI);
+}
+
+
+int mvPp2PrsDoubleVlan(unsigned short tpid1, unsigned short tpid2, unsigned int portBmp, int add)
+{
+	if (add)
+		return mvPp2PrsDoubleVlanAdd(tpid1, tpid2, portBmp);
+	else
+		return mvPp2PrsDoubleVlanDel(tpid1, tpid2);
+}
+
+int mvPp2PrsTripleVlan(unsigned short tpid1, unsigned short tpid2, unsigned short tpid3, unsigned int portBmp, int add)
+{
+	MV_PP2_PRS_ENTRY *pe;
+	int ai, aiEnable;
+	int status;
+
+	pe = mvPrsDoubleVlanFind(tpid1, tpid2);
+
+	if (!pe) {
+		if (add)
+			mvOsPrintf("User must enter first double vlan <0x%x,0x%x> before triple\n", tpid1, tpid2);
+		else
+			mvOsPrintf("Can't remove - No such entry\n");
+
+		return MV_ERROR;
+	}
+
+	/* get AI value form double VLAN entry */
+	mvPp2PrsSwSramAiGet(pe, &ai, &aiEnable);
+
+	ai &= ~(1 << DBL_VLAN_AI_BIT);
+
+	if (add)
+		status = mvPp2PrsVlanAdd(tpid3, ai, portBmp);
+	else
+		status = mvPp2PrsVlanDel(tpid3, ai);
+
+	mvPp2PrsSwFree(pe);
+
+	return status;
+}
+
+/* Detect up to 2 successive VLAN tags:
+ * Possible options:
+ * 0x8100, 0x88A8
+ * 0x8100, 0x8100
+ * 0x8100
+ * 0x88A8
+ */
+static int mvPp2PrsVlanInit(void)
+{
+	MV_PP2_PRS_ENTRY pe;
+
+	mvPrsDblVlanAiShadowClearAll();
+
+	/* double VLAN: 0x8100, 0x88A8 */
+	if (mvPp2PrsDoubleVlan(MV_VLAN_TYPE, MV_VLAN_1_TYPE, PORT_MASK, 1))
+		return MV_ERROR;
+
+	/* double VLAN: 0x8100, 0x8100 */
+	if (mvPp2PrsDoubleVlan(MV_VLAN_TYPE, MV_VLAN_TYPE, PORT_MASK, 1))
+		return MV_ERROR;
+
+	/* single VLAN: 0x88a8 */
+	if (mvPp2PrsSingleVlan(MV_VLAN_1_TYPE, PORT_MASK, 1))
+		return MV_ERROR;
+
+	/* single VLAN: 0x8100 */
+	if (mvPp2PrsSingleVlan(MV_VLAN_TYPE, PORT_MASK, 1))
+		return MV_ERROR;
+
+	/*---------------------------------*/
+	/*  Set default double vlan entry  */
+	/*---------------------------------*/
+	mvPp2PrsSwClear(&pe);
+	mvPp2PrsSwTcamLuSet(&pe, PRS_LU_VLAN);
+	pe.index = PE_VLAN_DBL;
+	/* Continue - set next lookup */
+	mvPp2PrsSwSramNextLuSet(&pe, PRS_LU_L2);
+
+	/* double vlan AI bit */
+	mvPp2PrsSwTcamAiUpdate(&pe, (1 << DBL_VLAN_AI_BIT), (1 << DBL_VLAN_AI_BIT));
+
+	/* clear AI for next iterations */
+	mvPp2PrsSwSramAiUpdate(&pe, 0, SRAM_AI_MASK);
+
+	/* Set result info bits */
+	mvPp2PrsSwSramRiUpdate(&pe, RI_VLAN_DOUBLE, RI_VLAN_MASK);
+
+	mvPp2PrsSwTcamPortMapSet(&pe, PORT_MASK);
+	mvPp2PrsHwWrite(&pe);
+
+	/* Update mvPrsShadowTbl */
+	mvPp2PrsShadowSet(pe.index, PRS_LU_VLAN, "double-VLAN-accept");
+
+	/*---------------------------------*/
+	/*   Set default vlan none entry   */
+	/*---------------------------------*/
+
+	mvPp2PrsSwClear(&pe);
+	mvPp2PrsSwTcamLuSet(&pe, PRS_LU_VLAN);
+	pe.index = PE_VLAN_NONE;
+	/* Continue - set next lookup */
+	mvPp2PrsSwSramNextLuSet(&pe, PRS_LU_L2);
+
+	/* Set result info bits */
+	mvPp2PrsSwSramRiUpdate(&pe, RI_VLAN_NONE, RI_VLAN_MASK);
+
+	mvPp2PrsSwTcamPortMapSet(&pe, PORT_MASK);
+	mvPp2PrsHwWrite(&pe);
+
+	/* Update mvPrsShadowTbl */
+	mvPp2PrsShadowSet(pe.index, PRS_LU_VLAN, "no-VLAN");
+
+	return MV_OK;
+}
+
+
+/******************************************************************************
+ *
+ * Ethertype Section
+ *
+ ******************************************************************************
+ */
+
+
+static int mvPp2PrsEtypePppoe(void)
+{
+	int tid;
+	MV_PP2_PRS_ENTRY *pe;
+
+	PRS_DBG("%s\n", __func__);
+
+	/* Go through the all entires from first to last */
+	tid = mvPp2PrsTcamFirstFree(0, MV_PP2_PRS_TCAM_SIZE - 1);
+
+	/* Can't add - No free TCAM entries */
+	if (tid == MV_PRS_OUT_OF_RAGE) {
+		mvOsPrintf("%s: No free TCAM entiry\n", __func__);
+		return MV_ERROR;
+	}
+
+	pe = mvPp2PrsSwAlloc(PRS_LU_L2);
+
+	pe->index = tid;
+
+	mvPp2PrsMatchEtype(pe, 0, MV_PPPOE_TYPE);
+	mvPp2PrsSwSramShiftSet(pe, MV_PPPOE_HDR_SIZE, SRAM_OP_SEL_SHIFT_ADD);
+
+	mvPp2PrsSwSramNextLuSet(pe, PRS_LU_PPPOE);
+	mvPp2PrsSwSramRiSetBit(pe, RI_PPPOE_BIT);
+	mvPp2PrsHwWrite(pe);
+
+	/* Update mvPrsShadowTbl */
+	mvPp2PrsShadowSet(pe->index, PRS_LU_L2, "etype-PPPoE");
+	mvPp2PrsSwFree(pe);
+
+	return MV_OK;
+}
+
+
+/* match ip4 and ihl == 5 */
+static int mvPp2PrsEtypeIp4(void)
+{
+	int tid;
+	MV_PP2_PRS_ENTRY *pe;
+
+	PRS_DBG("%s\n", __func__);
+
+	/* IPv4 without options */
+	/* Go through the all entires from first to last */
+	tid = mvPp2PrsTcamFirstFree(0, MV_PP2_PRS_TCAM_SIZE - 1);
+
+	/* Can't add - No free TCAM entries */
+	if (tid == MV_PRS_OUT_OF_RAGE) {
+		mvOsPrintf("%s: No free TCAM entiry\n", __func__);
+		return MV_ERROR;
+	}
+
+	pe = mvPp2PrsSwAlloc(PRS_LU_L2);
+	pe->index = tid;
+
+	mvPp2PrsMatchEtype(pe, 0, MV_IP_TYPE);
+	mvPp2PrsSwTcamByteSet(pe, MV_ETH_TYPE_LEN + 0, 0x45, 0xff);
+
+	mvPp2PrsSwSramNextLuSet(pe, PRS_LU_IP4);
+	mvPp2PrsSwSramRiUpdate(pe, RI_L3_IP4, RI_L3_PROTO_MASK);
+
+	/* Skip eth_type + 4 bytes of IP header */
+	mvPp2PrsSwSramShiftSet(pe, MV_ETH_TYPE_LEN + 4, SRAM_OP_SEL_SHIFT_ADD);
+
+	/* set L3 offset */
+	mvPp2PrsSwSramOffsetSet(pe, SRAM_OFFSET_TYPE_L3, MV_ETH_TYPE_LEN, SRAM_OP_SEL_OFFSET_ADD);
+
+	mvPp2PrsHwWrite(pe);
+
+	/* Update mvPrsShadowTbl */
+	mvPp2PrsShadowSet(pe->index, PRS_LU_L2, "etype-ipv4");
+	mvPp2PrsSwFree(pe);
+
+	/* IPv4 with options */
+	/* Go through the all entires from first to last */
+	tid = mvPp2PrsTcamFirstFree(0, MV_PP2_PRS_TCAM_SIZE - 1);
+
+	/* Can't add - No free TCAM entries */
+	if (tid == MV_PRS_OUT_OF_RAGE) {
+		mvOsPrintf("%s: No free TCAM entiry\n", __func__);
+		return MV_ERROR;
+	}
+
+	pe = mvPp2PrsSwAlloc(PRS_LU_L2);
+
+	pe->index = tid;
+	mvPp2PrsMatchEtype(pe, 0, MV_IP_TYPE);
+	mvPp2PrsSwTcamByteSet(pe, MV_ETH_TYPE_LEN + 0, 0x40, 0xf0);
+
+	/* Skip eth_type + 4 bytes of IP header */
+	mvPp2PrsSwSramShiftSet(pe, MV_ETH_TYPE_LEN + 4, SRAM_OP_SEL_SHIFT_ADD);
+	mvPp2PrsSwSramNextLuSet(pe, PRS_LU_IP4);
+	mvPp2PrsSwSramRiUpdate(pe, RI_L3_IP4_OPT, RI_L3_PROTO_MASK);
+
+	/* set L3 offset */
+	mvPp2PrsSwSramOffsetSet(pe, SRAM_OFFSET_TYPE_L3, MV_ETH_TYPE_LEN, SRAM_OP_SEL_OFFSET_ADD);
+
+	mvPp2PrsHwWrite(pe);
+
+	/* Update mvPrsShadowTbl */
+	mvPp2PrsShadowSet(pe->index, PRS_LU_L2, "etype-ipv4-opt");
+
+	mvPp2PrsSwFree(pe);
+
+	return MV_OK;
+}
+
+static int mvPp2PrsEtypeArp(void)
+{
+	int tid;
+	MV_PP2_PRS_ENTRY *pe;
+
+	/* Go through the all entires from first to last */
+	tid = mvPp2PrsTcamFirstFree(0, MV_PP2_PRS_TCAM_SIZE - 1);
+
+	/* Can't add - No free TCAM entries */
+	if (tid == MV_PRS_OUT_OF_RAGE) {
+		mvOsPrintf("%s: No free TCAM entiry\n", __func__);
+		return MV_ERROR;
+	}
+
+
+	pe = mvPp2PrsSwAlloc(PRS_LU_L2);
+
+	pe->index = tid;
+
+	mvPp2PrsMatchEtype(pe, 0, MV_IP_ARP_TYPE);
+
+	/* generate flow in the next iteration*/
+	/*mvPp2PrsSwSramAiSetBit(pe, AI_DONE_BIT);*/
+	mvPp2PrsSwSramNextLuSet(pe, PRS_LU_FLOWS);
+	mvPp2PrsSwSramFlowidGenSet(pe);
+	mvPp2PrsSwSramRiUpdate(pe, RI_L3_ARP, RI_L3_PROTO_MASK);
+
+	/* set L3 offset */
+	mvPp2PrsSwSramOffsetSet(pe, SRAM_OFFSET_TYPE_L3, MV_ETH_TYPE_LEN, SRAM_OP_SEL_OFFSET_ADD);
+
+	mvPp2PrsHwWrite(pe);
+
+	mvPp2PrsShadowSet(pe->index, PRS_LU_L2, "etype-arp");
+
+	mvPp2PrsSwFree(pe);
+
+	return MV_OK;
+}
+
+
+/* match ip6 */
+static int mvPp2PrsEtypeIp6(void)
+{
+	int tid;
+	MV_PP2_PRS_ENTRY *pe;
+
+	/* Go through the all entires from first to last */
+	tid = mvPp2PrsTcamFirstFree(0, MV_PP2_PRS_TCAM_SIZE - 1);
+
+		/* Can't add - No free TCAM entries */
+	if (tid == MV_PRS_OUT_OF_RAGE) {
+		mvOsPrintf("%s: No free TCAM entiry\n", __func__);
+		return MV_ERROR;
+	}
+
+	pe = mvPp2PrsSwAlloc(PRS_LU_L2);
+
+	pe->index = tid;
+
+	mvPp2PrsMatchEtype(pe, 0, MV_IP6_TYPE);
+
+	/* Skip eth_type + 4 bytes of IPV6 header */
+	mvPp2PrsSwSramShiftSet(pe, MV_ETH_TYPE_LEN + 4, SRAM_OP_SEL_SHIFT_ADD);
+
+	mvPp2PrsSwSramNextLuSet(pe, PRS_LU_IP6);
+/*
+	there is no support in extension yet
+*/
+	mvPp2PrsSwSramRiUpdate(pe, RI_L3_IP6, RI_L3_PROTO_MASK);
+
+	/* set L3 offset */
+	mvPp2PrsSwSramOffsetSet(pe, SRAM_OFFSET_TYPE_L3, MV_ETH_TYPE_LEN, SRAM_OP_SEL_OFFSET_ADD);
+
+	mvPp2PrsHwWrite(pe);
+
+	mvPp2PrsShadowSet(pe->index, PRS_LU_L2, "etype-ipv6");
+
+	mvPp2PrsSwFree(pe);
+
+	return MV_OK;
+}
+
+
+/* unknown ethertype */
+static int mvPp2PrsEtypeUn(void)
+{
+	MV_PP2_PRS_ENTRY *pe;
+
+	/* Default entry for PRS_LU_L2 - Unknown ethtype */
+	pe = mvPp2PrsSwAlloc(PRS_LU_L2);
+	pe->index = PE_ETH_TYPE_UN;
+
+	/* generate flow in the next iteration*/
+	mvPp2PrsSwSramFlowidGenSet(pe);
+	mvPp2PrsSwSramNextLuSet(pe, PRS_LU_FLOWS);
+
+	/* Set result info bits */
+	mvPp2PrsSwSramRiUpdate(pe, RI_L3_UN, RI_L3_PROTO_MASK);
+
+	mvPp2PrsSwTcamPortMapSet(pe, PORT_MASK);
+	mvPp2PrsHwWrite(pe);
+
+	/* Update mvPrsShadowTbl */
+	mvPp2PrsShadowSet(pe->index, PRS_LU_L2, "etype-unknown");
+
+	mvPp2PrsSwFree(pe);
+
+	return MV_OK;
+}
+
+/*
+ * pnc_etype_init - match basic ethertypes
+ */
+static int mvPp2PrsEtypeInit(void)
+{
+	int    rc;
+
+	PRS_DBG("%s\n", __func__);
+
+	rc = mvPp2PrsEtypePppoe();
+	if (rc)
+		return rc;
+
+	rc = mvPp2PrsEtypeArp();
+	if (rc)
+		return rc;
+
+	rc = mvPp2PrsEtypeIp4();
+	if (rc)
+		return rc;
+
+	rc = mvPp2PrsEtypeIp6();
+	if (rc)
+		return rc;
+
+	rc = mvPp2PrsEtypeUn();
+	if (rc)
+		return rc;
+
+	return MV_OK;
+}
+
+/******************************************************************************
+ *
+ * PPPoE Section
+ *
+ ******************************************************************************
+ */
+
+static int mvPp2PrsIpv6Pppoe(void)
+{
+	int tid;
+	MV_PP2_PRS_ENTRY *pe;
+
+	PRS_DBG("%s\n", __func__);
+
+	/* Go through the all entires from first to last */
+	tid = mvPp2PrsTcamFirstFree(0, MV_PP2_PRS_TCAM_SIZE - 1);
+
+	/* Can't add - No free TCAM entries */
+	if (tid == MV_PRS_OUT_OF_RAGE) {
+		mvOsPrintf("%s: No free TCAM entiry\n", __func__);
+		return MV_ERROR;
+	}
+
+	pe = mvPp2PrsSwAlloc(PRS_LU_PPPOE);
+
+	pe->index = tid;
+
+	mvPp2PrsMatchEtype(pe, 0, MV_IP6_PPP);
+
+	/* there is no support in extension yet */
+	mvPp2PrsSwSramRiUpdate(pe, RI_L3_IP6, RI_L3_PROTO_MASK);
+
+	/* Skip eth_type + 4 bytes of IPV6 header */
+	mvPp2PrsSwSramShiftSet(pe, MV_ETH_TYPE_LEN + 4, SRAM_OP_SEL_SHIFT_ADD);
+
+	/* set L3 offset */
+	mvPp2PrsSwSramOffsetSet(pe, SRAM_OFFSET_TYPE_L3, MV_ETH_TYPE_LEN, SRAM_OP_SEL_OFFSET_ADD);
+
+	mvPp2PrsSwSramNextLuSet(pe, PRS_LU_IP6);
+	mvPp2PrsHwWrite(pe);
+
+	/* Update mvPrsShadowTbl */
+	mvPp2PrsShadowSet(pe->index, PRS_LU_PPPOE, "Ipv6-over-PPPoE");
+
+	mvPp2PrsSwFree(pe);
+
+	return MV_OK;
+}
+
+static int mvPp2PrsIpv4Pppoe(void)
+{
+	int tid;
+	MV_PP2_PRS_ENTRY *pe;
+
+	PRS_DBG("%s\n", __func__);
+
+	/** ipV4 over PPPoE without options **/
+
+	/* Go through the all entires from first to last */
+	tid = mvPp2PrsTcamFirstFree(0, MV_PP2_PRS_TCAM_SIZE - 1);
+
+	/* Can't add - No free TCAM entries */
+	if (tid == MV_PRS_OUT_OF_RAGE) {
+		mvOsPrintf("%s: No free TCAM entiry\n", __func__);
+		return MV_ERROR;
+	}
+
+	pe = mvPp2PrsSwAlloc(PRS_LU_PPPOE);
+
+	pe->index = tid;
+
+	mvPp2PrsMatchEtype(pe, 0, MV_IP_PPP);
+	mvPp2PrsSwTcamByteSet(pe, MV_ETH_TYPE_LEN + 0, 0x45, 0xff);
+
+	mvPp2PrsSwSramRiUpdate(pe, RI_L3_IP4, RI_L3_PROTO_MASK);
+
+	/* Skip eth_type + 4 bytes of IP header */
+	mvPp2PrsSwSramShiftSet(pe, MV_ETH_TYPE_LEN + 4, SRAM_OP_SEL_SHIFT_ADD);
+
+	/* set L3 offset */
+	mvPp2PrsSwSramOffsetSet(pe, SRAM_OFFSET_TYPE_L3, MV_ETH_TYPE_LEN, SRAM_OP_SEL_OFFSET_ADD);
+
+	mvPp2PrsSwSramNextLuSet(pe, PRS_LU_IP4);
+	mvPp2PrsHwWrite(pe);
+
+	/* Update mvPrsShadowTbl */
+	mvPp2PrsShadowSet(pe->index, PRS_LU_PPPOE, "Ipv4-over-PPPoE");
+
+	mvPp2PrsSwFree(pe);
+
+
+	/** ipV4 over PPPoE with options **/
+
+	/* Go through the all entires from first to last */
+	tid = mvPp2PrsTcamFirstFree(0, MV_PP2_PRS_TCAM_SIZE - 1);
+
+	/* Can't add - No free TCAM entries */
+	if (tid == MV_PRS_OUT_OF_RAGE) {
+		mvOsPrintf("%s: No free TCAM entiry\n", __func__);
+		return MV_ERROR;
+	}
+
+	pe = mvPp2PrsSwAlloc(PRS_LU_PPPOE);
+
+	pe->index = tid;
+
+	mvPp2PrsMatchEtype(pe, 0, MV_IP_PPP);
+
+	mvPp2PrsSwSramRiUpdate(pe, RI_L3_IP4_OPT, RI_L3_PROTO_MASK);
+
+	/* Skip eth_type + 4 bytes of IP header */
+	mvPp2PrsSwSramShiftSet(pe, MV_ETH_TYPE_LEN + 4, SRAM_OP_SEL_SHIFT_ADD);
+
+	/* set L3 offset */
+	mvPp2PrsSwSramOffsetSet(pe, SRAM_OFFSET_TYPE_L3, MV_ETH_TYPE_LEN, SRAM_OP_SEL_OFFSET_ADD);
+
+	mvPp2PrsSwSramNextLuSet(pe, PRS_LU_IP4);
+	mvPp2PrsHwWrite(pe);
+
+	/* Update mvPrsShadowTbl */
+	mvPp2PrsShadowSet(pe->index, PRS_LU_PPPOE, "Ipv4-over-PPPoE-opt");
+	mvPp2PrsSwFree(pe);
+
+	return MV_OK;
+}
+
+
+/* match etype = PPPOE */
+static int mvPp2PrsPpppeInit(void)
+{
+	int rc;
+
+	rc = mvPp2PrsIpv4Pppoe();
+	if (rc)
+		return rc;
+
+	rc = mvPp2PrsIpv6Pppoe();
+	if (rc)
+		return rc;
+
+	return MV_OK;
+}
+
+
+
+/******************************************************************************
+ *
+ * IPv4 Section
+ *
+ ******************************************************************************
+ */
+
+/* IPv4/TCP header parsing for fragmentation and L4 offset.  */
+static int mvPp2PrsIp4Proto(unsigned short proto)
+{
+	int tid;
+	MV_PP2_PRS_ENTRY *pe;
+
+	PRS_DBG("%s\n", __func__);
+
+	/* TCP, Not Fragmented */
+	tid = mvPp2PrsTcamFirstFree(0, MV_PP2_PRS_TCAM_SIZE - 1);
+	if (tid == MV_PRS_OUT_OF_RAGE) {
+		mvOsPrintf("%s: No free TCAM entiry\n", __func__);
+		return MV_ERROR;
+	}
+	pe = mvPp2PrsSwAlloc(PRS_LU_IP4);
+	pe->index = tid;
+
+	mvPp2PrsSwTcamByteSet(pe, 2, 0x00, 0x3f);
+	mvPp2PrsSwTcamByteSet(pe, 3, 0x00, 0xff);
+
+	mvPp2PrsSwTcamPortMapSet(pe, PORT_MASK);
+	mvPp2PrsSwTcamByteSet(pe, 5, proto, 0xff);
+
+	if (proto == MV_IP_PROTO_TCP) {
+		mvPp2PrsSwSramRiUpdate(pe, RI_L4_TCP, RI_L4_PROTO_MASK);
+		mvPp2PrsShadowSet(pe->index, PRS_LU_IP4, "ipv4-tcp");
+	} else if (proto == MV_IP_PROTO_UDP) {
+		mvPp2PrsSwSramRiUpdate(pe, RI_L4_UDP, RI_L4_PROTO_MASK);
+		mvPp2PrsShadowSet(pe->index, PRS_LU_IP4, "ipv4-udp");
+	} else {
+		mvOsPrintf("%s: IPv4 unsupported protocol %d\n", __func__, proto);
+		mvPp2PrsSwFree(pe);
+		return MV_ERROR;
+	}
+
+	/* set L4 offset */
+	mvPp2PrsSwSramOffsetSet(pe, SRAM_OFFSET_TYPE_L4, sizeof(MV_IP_HEADER) - 4, SRAM_OP_SEL_OFFSET_ADD);
+
+	/* Finished: go to flowid generation */
+	mvPp2PrsSwSramFlowidGenSet(pe);
+	mvPp2PrsSwSramNextLuSet(pe, PRS_LU_FLOWS);
+
+	mvPp2PrsSwTcamPortMapSet(pe, PORT_MASK);
+	mvPp2PrsHwWrite(pe);
+
+	mvPp2PrsSwFree(pe);
+
+	/* TCP, Fragmented */
+	tid = mvPp2PrsTcamFirstFree(0, MV_PP2_PRS_TCAM_SIZE - 1);
+	if (tid == MV_PRS_OUT_OF_RAGE) {
+		mvOsPrintf("%s: No free TCAM entiry\n", __func__);
+		return MV_ERROR;
+	}
+	pe = mvPp2PrsSwAlloc(PRS_LU_IP4);
+	pe->index = tid;
+
+	mvPp2PrsSwTcamByteSet(pe, 5, proto, 0xff);
+	mvPp2PrsSwSramRiSetBit(pe, RI_IP_FRAG_BIT);
+
+	if (proto == MV_IP_PROTO_TCP) {
+		mvPp2PrsSwSramRiUpdate(pe, RI_L4_TCP, RI_L4_PROTO_MASK);
+		mvPp2PrsShadowSet(pe->index, PRS_LU_IP4, "ipv4-tcp-frag");
+	} else if (proto == MV_IP_PROTO_UDP) {
+		mvPp2PrsSwSramRiUpdate(pe, RI_L4_UDP, RI_L4_PROTO_MASK);
+		mvPp2PrsShadowSet(pe->index, PRS_LU_IP4, "ipv4-udp-frag");
+	} else {
+		mvOsPrintf("%s: IPv4 unsupported protocol %d\n", __func__, proto);
+		mvPp2PrsSwFree(pe);
+		return MV_ERROR;
+	}
+
+	/* set L4 offset */
+	mvPp2PrsSwSramOffsetSet(pe, SRAM_OFFSET_TYPE_L4, sizeof(MV_IP_HEADER) - 4, SRAM_OP_SEL_OFFSET_ADD);
+
+	/* Finished: go to flowid generation */
+	mvPp2PrsSwSramFlowidGenSet(pe);
+	mvPp2PrsSwSramNextLuSet(pe, PRS_LU_FLOWS);
+
+	mvPp2PrsSwTcamPortMapSet(pe, PORT_MASK);
+	mvPp2PrsHwWrite(pe);
+
+	mvPp2PrsSwFree(pe);
+
+	return MV_OK;
+}
+
+
+static int mvPp2PrsIp4Init(void)
+{
+	int rc;
+	MV_PP2_PRS_ENTRY *pe;
+
+	PRS_DBG("%s\n", __func__);
+
+	/* Set entries for TCP and UDP over IPv4 */
+	rc = mvPp2PrsIp4Proto(MV_IP_PROTO_TCP);
+	if (rc)
+		return rc;
+
+	rc = mvPp2PrsIp4Proto(MV_IP_PROTO_UDP);
+	if (rc)
+		return rc;
+
+	/* Default IPv4 entry for unknown protocols */
+	pe = mvPp2PrsSwAlloc(PRS_LU_IP4);
+	pe->index = PE_IP4_PROTO_UN;
+
+	/* generate flow in the next iteration*/
+	mvPp2PrsSwSramFlowidGenSet(pe);
+	mvPp2PrsSwSramNextLuSet(pe, PRS_LU_FLOWS);
+
+	/* Set result info bits */
+	mvPp2PrsSwSramRiUpdate(pe, RI_L4_OTHER, RI_L4_PROTO_MASK);
+
+	mvPp2PrsSwSramOffsetSet(pe, SRAM_OFFSET_TYPE_L4, sizeof(MV_IP_HEADER) - 4, SRAM_OP_SEL_OFFSET_ADD);
+
+	mvPp2PrsSwTcamPortMapSet(pe, PORT_MASK);
+	mvPp2PrsHwWrite(pe);
+
+	/* Update mvPrsShadowTbl */
+	mvPp2PrsShadowSet(pe->index, PRS_LU_IP4, "ipv4-l4-unknown");
+
+	mvPp2PrsSwFree(pe);
+
+	return MV_OK;
+}
+
+/******************************************************************************
+ *
+ * IPv6 Section
+ *
+ *******************************************************************************/
+/* TODO continue from here */
+/* IPv6 - detect TCP */
+
+static int mvPp2PrsIp6Proto(unsigned short proto)
+{
+	int tid;
+	MV_PP2_PRS_ENTRY *pe;
+
+	PRS_DBG("%s\n", __func__);
+
+	/* TCP, Not Fragmented */
+	tid = mvPp2PrsTcamFirstFree(0, MV_PP2_PRS_TCAM_SIZE - 1);
+	if (tid == MV_PRS_OUT_OF_RAGE) {
+		mvOsPrintf("%s: No free TCAM entiry\n", __func__);
+		return MV_ERROR;
+	}
+	pe = mvPp2PrsSwAlloc(PRS_LU_IP6);
+	pe->index = tid;
+
+	/* match TCP protocol */
+	mvPp2PrsSwTcamByteSet(pe, 2, proto, 0xff);
+
+
+	if (proto == MV_IP_PROTO_TCP) {
+		mvPp2PrsSwSramRiUpdate(pe, RI_L4_TCP, RI_L4_PROTO_MASK);
+		mvPp2PrsShadowSet(pe->index, PRS_LU_IP4, "ipv6-tcp");
+	} else if (proto == MV_IP_PROTO_UDP) {
+		mvPp2PrsSwSramRiUpdate(pe, RI_L4_UDP, RI_L4_PROTO_MASK);
+		mvPp2PrsShadowSet(pe->index, PRS_LU_IP4, "ipv4-udp");
+	} else {
+		mvOsPrintf("%s: IPv4 unsupported protocol %d\n", __func__, proto);
+		mvPp2PrsSwFree(pe);
+		return MV_ERROR;
+	}
+	/* Finished: go to flowid generation */
+	mvPp2PrsSwSramNextLuSet(pe, PRS_LU_FLOWS);
+	mvPp2PrsSwSramFlowidGenSet(pe);
+
+	/* All ports */
+	mvPp2PrsSwTcamPortMapSet(pe, PORT_MASK);
+
+	/* set L4 offset relatively to our current place */
+	mvPp2PrsSwSramOffsetSet(pe, SRAM_OFFSET_TYPE_L4, sizeof(MV_IP6_HEADER) - 4, SRAM_OP_SEL_OFFSET_ADD);
+
+	mvPp2PrsHwWrite(pe);
+	mvPp2PrsSwFree(pe);
+
+	return MV_OK;
+}
+
+static int mvPp2PrsIp6Init(void)
+{
+	int tid, rc;
+	MV_PP2_PRS_ENTRY *pe;
+
+	PRS_DBG("%s\n", __func__);
+
+	pe = mvPp2PrsSwAlloc(PRS_LU_IP6);
+
+	/* Check hop limit */
+	tid = mvPp2PrsTcamFirstFree(0, MV_PP2_PRS_TCAM_SIZE - 1);
+	if (tid == MV_PRS_OUT_OF_RAGE) {
+		mvOsPrintf("%s: No free TCAM entiry\n", __func__);
+		mvPp2PrsSwFree(pe);
+		return MV_ERROR;
+	}
+	pe->index = tid;
+
+	mvPp2PrsSwTcamByteSet(pe, 3, 0x00, 0xff);
+	mvPp2PrsSwSramRiUpdate(pe, (RI_L3_UN | RI_DROP_BIT), (RI_L3_PROTO_MASK | RI_DROP_MASK));
+
+	mvPp2PrsSwSramFlowidGenSet(pe);
+	mvPp2PrsSwSramNextLuSet(pe, PRS_LU_FLOWS);
+
+	mvPp2PrsHwWrite(pe);
+
+	/* Update mvPrsShadowTbl */
+	mvPp2PrsShadowSet(pe->index, PRS_LU_IP4, "ipv6-hop-zero");
+
+	mvPp2PrsSwFree(pe);
+
+	/* Set entries for TCP and UDP over IPv6 */
+	rc = mvPp2PrsIp6Proto(MV_IP_PROTO_TCP);
+	if (rc)
+		return rc;
+
+	rc = mvPp2PrsIp6Proto(MV_IP_PROTO_UDP);
+	if (rc)
+		return rc;
+
+
+	/* Default IPv6 entry for unknown protocols */
+	pe = mvPp2PrsSwAlloc(PRS_LU_IP6);
+	pe->index = PE_IP6_PROTO_UN;
+
+	/* generate flow in the next iteration*/
+	mvPp2PrsSwSramFlowidGenSet(pe);
+	mvPp2PrsSwSramNextLuSet(pe, PRS_LU_FLOWS);
+
+	/* Set result info bits */
+	mvPp2PrsSwSramRiUpdate(pe, RI_L4_OTHER, RI_L4_PROTO_MASK);
+
+	/* set L4 offset relatively to our current place */
+	mvPp2PrsSwSramOffsetSet(pe, SRAM_OFFSET_TYPE_L4, sizeof(MV_IP6_HEADER) - 4, SRAM_OP_SEL_OFFSET_ADD);
+
+	mvPp2PrsSwTcamPortMapSet(pe, PORT_MASK);
+	mvPp2PrsHwWrite(pe);
+
+	/* Update mvPrsShadowTbl */
+	mvPp2PrsShadowSet(pe->index, PRS_LU_IP4, "ipv6-l4-unknown");
+
+	mvPp2PrsSwFree(pe);
+	return MV_OK;
+}
+
+
+/*
+ ******************************************************************************
+ *
+ * flows
+ *
+ ******************************************************************************
+*/
+
+static MV_PP2_PRS_ENTRY *mvPrsFlowFind(int flow)
+{
+	MV_PP2_PRS_ENTRY *pe;
+	int tid, bits, enable;
+
+	pe = mvPp2PrsSwAlloc(PRS_LU_FLOWS);
+
+	/* Go through the all entires with PRS_LU_MAC */
+	for (tid = MV_PP2_PRS_TCAM_SIZE-1; tid >= 0; tid--) {
+		if ((!mvPp2PrsShadowIsValid(tid)) || (mvPp2PrsShadowLu(tid) != PRS_LU_FLOWS))
+			continue;
+
+		pe->index = tid;
+		mvPp2PrsHwRead(pe);
+		mvPp2PrsSwSramAiGet(pe, &bits, &enable);
+
+		/* sram store classification lookup id in AI bits [5:0] */
+		if ((bits & FLOWID_MASK) == flow)
+			return pe;
+	}
+	mvPp2PrsSwFree(pe);
+	return NULL;
+}
+
+int mvPrsFlowIdGen(int tid, int flowId, unsigned int res, unsigned int resMask, int portBmp)
+{
+	MV_PP2_PRS_ENTRY *pe;
+	char name[PRS_TEXT_SIZE];
+
+	PRS_DBG("%s\n", __func__);
+
+	POS_RANGE_VALIDATE(flowId, FLOWID_MASK);
+	POS_RANGE_VALIDATE(tid, MV_PP2_PRS_TCAM_SIZE-1);
+
+	/* Default configuration entry - overrwite is forbidden */
+	if (mvPp2PrsShadowIsValid(tid) && (mvPp2PrsShadowLu(tid) != PRS_LU_FLOWS)) {
+		mvOsPrintf("%s: Error, Tcam entry is in use\n", __func__);
+		return MV_ERROR;
+	}
+
+	pe = mvPp2PrsSwAlloc(PRS_LU_FLOWS);
+	pe->index = tid;
+
+	mvPp2PrsSwSramAiUpdate(pe, flowId, FLOWID_MASK);
+	mvPp2PrsSwSramLuDoneSet(pe);
+
+	mvOsSPrintf(name, "flowId-%d", flowId);
+
+	/* Update mvPrsShadowTbl */
+	mvPp2PrsShadowSet(pe->index, PRS_LU_FLOWS, name);
+
+	mvPp2PrsSwTcamPortMapSet(pe, portBmp);
+
+	/*update result data and mask*/
+	mvPp2PrsSwTcamWordSet(pe, TCAM_DATA_BYTE, res, resMask);
+
+	mvPp2PrsHwWrite(pe);
+
+	mvPp2PrsSwFree(pe);
+
+	return MV_OK;
+
+}
+
+
+int mvPrsDefFlow(int port)
+{
+
+	MV_PP2_PRS_ENTRY *pe;
+	int tid, mallocFlag = 0;
+	char name[PRS_TEXT_SIZE];
+
+	PRS_DBG("%s\n", __func__);
+
+	POS_RANGE_VALIDATE(port, MV_PP2_MAX_PORTS - 1);
+
+	pe = mvPrsFlowFind(FLOWID_DEF(port));
+
+	/* Such entry not exist */
+	if (!pe) {
+		/* Go through the all entires from last to fires */
+		tid = mvPp2PrsTcamFirstFree(MV_PP2_PRS_TCAM_SIZE - 1, 0);
+
+		if (tid == MV_PRS_OUT_OF_RAGE) {
+			mvOsPrintf("%s: No free TCAM entiry\n", __func__);
+			return MV_ERROR;
+		}
+
+		mallocFlag = 1;
+		pe = mvPp2PrsSwAlloc(PRS_LU_FLOWS);
+		pe->index = tid;
+
+		/* set flowID*/
+		mvPp2PrsSwSramAiUpdate(pe, FLOWID_DEF(port), FLOWID_MASK);
+		mvPp2PrsSwSramLuDoneSet(pe);
+
+		mvOsSPrintf(name, "def-flowId-port-%d", port);
+
+		/* Update mvPrsShadowTbl */
+		mvPp2PrsShadowSet(pe->index, PRS_LU_FLOWS, name);
+
+	}
+
+	mvPp2PrsSwTcamPortMapSet(pe, (1 << port));
+
+	mvPp2PrsHwWrite(pe);
+
+	if (mallocFlag)
+		mvPp2PrsSwFree(pe);
+
+	return MV_OK;
+}
+
+/******************************************************************************
+ *
+ * Paeser Init
+ *
+ ******************************************************************************
+ */
+int mvPrsDefaultInit(void)
+{
+	int    port, rc;
+
+	/*write zero to all the lines*/
+	mvPp2PrsHwClearAll();
+
+	mvPp2PrsHwInvAll();
+	mvPp2PrsShadowClearAll();
+
+	/* TODO: Mask & clear all interrupts */
+
+	/* Always start from lookup = 0 */
+	for (port = 0; port < MV_PP2_MAX_PORTS; port++)
+		mvPp2PrsHwPortInit(port,
+					PRS_LU_MAC/*first lu id*/,
+					MV_PP2_PRS_PORT_LU_MAX, 0);
+
+	rc = mvPp2PrsMacInit();
+	if (rc)
+		return rc;
+
+	rc = mvPp2PrsDsaInit();
+	if (rc)
+		return rc;
+
+	rc = mvPp2PrsVlanInit();
+	if (rc)
+		return rc;
+
+	rc = mvPp2PrsEtypeInit();
+	if (rc)
+		return rc;
+
+	rc = mvPp2PrsPpppeInit();
+	if (rc)
+		return rc;
+
+	rc = mvPp2PrsIp4Init();
+	if (rc)
+		return rc;
+
+	rc = mvPp2PrsIp6Init();
+	if (rc)
+		return rc;
+
+	return MV_OK;
+
+}
diff --git a/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.h b/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.h
new file mode 100644
index 0000000..c77bf32
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2Prs.h
@@ -0,0 +1,163 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_PRS_H__
+#define __MV_PRS_H__
+
+/*
+#define PP2_PRS_DEBUG
+*/
+/*
+ * TCAM topology definition.
+ * The TCAM is divided into sections per protocol encapsulation.
+ * Usually each section is designed to be to a lookup.
+ * Change sizes of sections according to the target product.
+ */
+
+/* VLAN */
+#define SINGLE_VLAN_AI		0
+#define DBL_VLAN_AI_BIT		7
+#define DBL_VLAN_SHADOW_SIZE	0x64	/* max number of double vlan*/
+
+/* DSA/EDSA type */
+#define TAGGED			1
+#define UNTAGGED		0
+#define EDSA			1
+#define DSA			0
+
+#define	DSA_ETHER_TYPE		0xDADA/*TODO set to default DSA ether type*/
+
+
+
+/* LOOKUP ID */
+enum prs_lookup {
+	PRS_LU_MAC,
+	PRS_LU_DSA,
+	PRS_LU_VLAN,
+	PRS_LU_L2,
+	PRS_LU_PPPOE,
+	PRS_LU_IP4,
+	PRS_LU_IP6,
+	PRS_LU_FLOWS,
+	PRS_LU_LAST,
+};
+/* Tcam entries ID */
+
+#define	PE_DROP_ALL					0
+#define	PE_RX_SPECIAL					1
+#define PE_FIRST_FREE_TID				2
+
+
+#define PE_LAST_FREE_TID	(MV_PP2_PRS_TCAM_SIZE - 19)
+#define PE_ETYPE_DSA		(MV_PP2_PRS_TCAM_SIZE - 18)
+#define PE_EDSA_TAGGED		(MV_PP2_PRS_TCAM_SIZE - 17)
+#define PE_EDSA_UNTAGGED	(MV_PP2_PRS_TCAM_SIZE - 16)
+#define PE_DSA_TAGGED		(MV_PP2_PRS_TCAM_SIZE - 15)
+#define PE_DSA_UNTAGGED		(MV_PP2_PRS_TCAM_SIZE - 14)
+
+#define PE_ETYPE_EDSA_TAGGED	(MV_PP2_PRS_TCAM_SIZE - 13)
+#define PE_ETYPE_EDSA_UNTAGGED	(MV_PP2_PRS_TCAM_SIZE - 12)
+#define PE_ETYPE_DSA_TAGGED	(MV_PP2_PRS_TCAM_SIZE - 11)
+#define PE_ETYPE_DSA_UNTAGGED	(MV_PP2_PRS_TCAM_SIZE - 10)
+
+
+#define PE_DSA_DEFAULT		(MV_PP2_PRS_TCAM_SIZE - 9)
+#define PE_IP6_PROTO_UN		(MV_PP2_PRS_TCAM_SIZE - 8)
+#define PE_IP4_PROTO_UN		(MV_PP2_PRS_TCAM_SIZE - 7)
+#define PE_ETH_TYPE_UN		(MV_PP2_PRS_TCAM_SIZE - 6)
+#define	PE_VLAN_DBL             (MV_PP2_PRS_TCAM_SIZE - 5) /* accept double vlan*/
+#define	PE_VLAN_NONE            (MV_PP2_PRS_TCAM_SIZE - 4) /* vlan default*/
+#define PE_MAC_MC_ALL   	(MV_PP2_PRS_TCAM_SIZE - 3) /* all multicast mode */
+#define PE_MAC_PROMISCOUS   	(MV_PP2_PRS_TCAM_SIZE - 2) /* promiscous mode */
+#define PE_MAC_NON_PROMISCOUS   (MV_PP2_PRS_TCAM_SIZE - 1) /* non-promiscous mode */
+
+
+/*
+ * Pre-defined FlowId assigment
+*/
+
+#define FLOWID_DEF(_port_)	(_port_)
+#define FLOWID_MASK	 	0x3F
+/*
+ * Export API
+ */
+int mvPrsDefFlow(int port);
+int mvPrsDefaultInit(void);
+int mvPrsMacDaAccept(int port, unsigned char *da, int add);
+int mvPrsMacDropAllSet(int port, int add);
+int mvPrsMhRxSpecialSet(int port, int add, unsigned short mh);
+int mvPrsMacPromiscousSet(int port, int add);
+int mvPrsMacAllMultiSet(int port, int add);
+int mvPrsDebugBasicInit(void);
+int mvPrsFlowIdGen(int tid, int flowId, unsigned int res, unsigned int resMask, int portBmp);
+int mvPp2PrsTagModeSet(int port, int type);
+int mvPp2PrsEtypeDsaModeSet(int port, int extand);
+int mvPp2PrsEtypeDsaSet(unsigned int eType);
+int mvPp2PrsTripleVlan(unsigned short tpid1, unsigned short tpid2, unsigned short tpid3, unsigned int portBmp, int add);
+int mvPp2PrsDoubleVlan(unsigned short tpid1, unsigned short tpid2, unsigned int portBmp, int add);
+int mvPp2PrsSingleVlan(unsigned short tpid, unsigned int portBmp, int add);
+/*
+int mvPrsMacDaDrop(int port, unsigned char *da, int add);
+*/
+#endif /*__MV_PRS_H__ */
diff --git a/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.c b/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.c
new file mode 100644
index 0000000..1098f31
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.c
@@ -0,0 +1,1074 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvPp2PrsHw.h"
+
+
+/*-------------------------------------------------------------------------------*/
+/*	Static functions declaretion for internal use 				*/
+/*-------------------------------------------------------------------------------*/
+
+static int mvPp2PrsSwSramRiDump(MV_PP2_PRS_ENTRY *pe);
+static int mvPp2PrsSwSramAiDump(MV_PP2_PRS_ENTRY *pe);
+/*-------------------------------------------------------------------------------*/
+
+PRS_SHADOW_ENTRY  mvPrsShadowTbl[MV_PP2_PRS_TCAM_SIZE];
+/******************************************************************************
+ * Common utilities
+ ******************************************************************************/
+int mvPp2PrsShadowIsValid(int index)
+{
+	return mvPrsShadowTbl[index].valid;
+}
+
+int mvPp2PrsShadowLu(int index)
+{
+	return mvPrsShadowTbl[index].lu;
+}
+
+void mvPp2PrsShadowSet(int index, int lu, char *text)
+{
+	strncpy(mvPrsShadowTbl[index].text, text, PRS_TEXT_SIZE);
+	mvPrsShadowTbl[index].text[PRS_TEXT_SIZE - 1] = 0;
+	mvPrsShadowTbl[index].valid = MV_TRUE;
+	mvPrsShadowTbl[index].lu = lu;
+}
+
+void mvPp2PrsShadowClear(int index)
+{
+	mvPrsShadowTbl[index].valid = MV_FALSE;
+	mvPrsShadowTbl[index].text[0] = 0;
+}
+
+void mvPp2PrsShadowClearAll(void)
+{
+	int index;
+
+	for (index = 0; index < MV_PP2_PRS_TCAM_SIZE; index++) {
+		mvPrsShadowTbl[index].valid = MV_FALSE;
+		mvPrsShadowTbl[index].text[0] = 0;
+	}
+
+}
+
+static int mvPp2PrsFirstFreeGet(int from, int to)
+{
+	int tid;
+
+	for (tid = from; tid <= to; tid++) {
+		if (!mvPrsShadowTbl[tid].valid)
+			break;
+	}
+	return tid;
+}
+
+static int mvPp2PrsLastFreeGet(int from, int to)
+{
+	int tid;
+
+	/* Go through the all entires from last to fires */
+
+	for (tid = from; tid >= to; tid--) {
+		if (!mvPrsShadowTbl[tid].valid)
+			break;
+	}
+	return tid;
+}
+/*
+* mvPp2PrsTcamFirstFree - seek for free tcam entry
+* Return first free TCAM index, seeking from start to end
+* If start < end - seek up-->bottom
+* If start > end - seek bottom-->up
+*/
+int mvPp2PrsTcamFirstFree(int start, int end)
+{
+	int tid;
+
+	if (start < end)
+		tid = mvPp2PrsFirstFreeGet(start, end);
+	else
+		tid =  mvPp2PrsLastFreeGet(start, end);
+
+	if ((tid < MV_PP2_PRS_TCAM_SIZE) && (tid > -1))
+		return tid;
+	else
+		return MV_PRS_OUT_OF_RAGE;
+}
+/*
+ * mvPrsSwAlloc - allocate new prs entry
+ * @id: tcam lookup id
+ */
+MV_PP2_PRS_ENTRY  *mvPp2PrsSwAlloc(unsigned int lu)
+{
+	MV_PP2_PRS_ENTRY *pe = mvOsMalloc(sizeof(MV_PP2_PRS_ENTRY));
+
+	WARN_OOM(pe == NULL);
+	mvPp2PrsSwClear(pe);
+	mvPp2PrsSwTcamLuSet(pe, lu);
+
+	return pe;
+}
+
+/*-------------------------------------------------------------------------------*/
+/*
+ * mvPp2PrsSwFree mvPrsSwAlloc - free prs entry
+ * @id: tcam lookup id
+ */
+
+void mvPp2PrsSwFree(MV_PP2_PRS_ENTRY *pe)
+{
+	mvOsFree(pe);
+}
+/*-------------------------------------------------------------------------------*/
+
+int mvPp2PrsHwPortInit(int port, int lu_first, int lu_max, int offs)
+{
+	int status = MV_OK;
+
+	status = mvPrsHwLkpFirstSet(port, lu_first);
+	if (status < 0)
+		return status;
+
+	status = mvPrsHwLkpMaxSet(port, lu_max);
+	if (status < 0)
+		return status;
+
+	status = mvPrsHwLkpFirstOffsSet(port, offs);
+	if (status < 0)
+		return status;
+
+	return MV_OK;
+}
+
+
+int mvPp2PrsHwRegsDump()
+{
+	int i;
+	char reg_name[100];
+
+	mvPp2PrintReg(MV_PP2_PRS_INIT_LOOKUP_REG, "MV_PP2_PRS_INIT_LOOKUP_REG");
+	mvPp2PrintReg(MV_PP2_PRS_INIT_OFFS_0_REG, "MV_PP2_PRS_INIT_OFFS_0_REG");
+	mvPp2PrintReg(MV_PP2_PRS_INIT_OFFS_1_REG, "MV_PP2_PRS_INIT_OFFS_1_REG");
+	mvPp2PrintReg(MV_PP2_PRS_MAX_LOOP_0_REG, "MV_PP2_PRS_MAX_LOOP_0_REG");
+	mvPp2PrintReg(MV_PP2_PRS_MAX_LOOP_1_REG, "MV_PP2_PRS_MAX_LOOP_1_REG");
+
+	mvPp2PrintReg(MV_PP2_PRS_INTR_CAUSE_REG, "MV_PP2_PRS_INTR_CAUSE_REG");
+	mvPp2PrintReg(MV_PP2_PRS_INTR_MASK_REG, "MV_PP2_PRS_INTR_MASK_REG");
+	mvPp2PrintReg(MV_PP2_PRS_TCAM_IDX_REG, "MV_PP2_PRS_TCAM_IDX_REG");
+
+	for (i = 0; i < MV_PP2_PRC_TCAM_WORDS; i++) {
+		mvOsSPrintf(reg_name, "MV_PP2_PRS_TCAM_DATA_%d_REG", i);
+		mvPp2PrintReg(MV_PP2_PRS_TCAM_DATA_REG(i), reg_name);
+	}
+	mvPp2PrintReg(MV_PP2_PRS_SRAM_IDX_REG, "MV_PP2_PRS_SRAM_IDX_REG");
+
+	for (i = 0; i < MV_PP2_PRC_SRAM_WORDS; i++) {
+		mvOsSPrintf(reg_name, "MV_PP2_PRS_SRAM_DATA_%d_REG", i);
+		mvPp2PrintReg(MV_PP2_PRS_SRAM_DATA_REG(i), reg_name);
+	}
+
+	return MV_OK;
+}
+
+
+int mvPrsHwLkpFirstSet(int port, int lu_first)
+{
+	unsigned int regVal;
+
+	POS_RANGE_VALIDATE(lu_first, MV_PP2_PRS_PORT_LU_MAX);
+	regVal = MV_REG_READ(MV_PP2_PRS_INIT_LOOKUP_REG);
+	regVal &= ~MV_PP2_PRS_PORT_LU_MASK(port);
+	regVal |=  MV_PP2_PRS_PORT_LU_VAL(port, lu_first);
+	mvPp2WrReg(MV_PP2_PRS_INIT_LOOKUP_REG, regVal);
+
+	return MV_OK;
+}
+
+int mvPrsHwLkpMaxSet(int port, int lu_max)
+{
+	unsigned int regVal;
+
+	RANGE_VALIDATE(lu_max, MV_PP2_PRS_MAX_LOOP_MIN, MV_PP2_PRS_PORT_LU_MAX);
+
+	regVal = MV_REG_READ(MV_PP2_PRS_MAX_LOOP_REG(port));
+	regVal &= ~MV_PP2_PRS_MAX_LOOP_MASK(port);
+	regVal |= MV_PP2_PRS_MAX_LOOP_VAL(port, lu_max);
+	mvPp2WrReg(MV_PP2_PRS_MAX_LOOP_REG(port), regVal);
+
+	return MV_OK;
+}
+
+int mvPrsHwLkpFirstOffsSet(int port, int off)
+{
+	unsigned int regVal;
+	/* todo if port > 7 return error */
+
+	POS_RANGE_VALIDATE(off, MV_PP2_PRS_INIT_OFF_MAX);
+
+	regVal = MV_REG_READ(MV_PP2_PRS_INIT_OFFS_REG(port));
+	regVal &= ~MV_PP2_PRS_INIT_OFF_MASK(port);
+	regVal |= MV_PP2_PRS_INIT_OFF_VAL(port, off);
+	mvPp2WrReg(MV_PP2_PRS_INIT_OFFS_REG(port), regVal);
+
+	return MV_OK;
+}
+
+/*
+	user responsibility to check valid bit after the call to this function
+	this function will return OK even if the entry is invalid
+*/
+int mvPp2PrsHwRead(MV_PP2_PRS_ENTRY *pe)
+{
+	int index, tid;
+
+	PTR_VALIDATE(pe);
+	POS_RANGE_VALIDATE(pe->index, MV_PP2_PRS_TCAM_SIZE - 1);
+
+	tid = pe->index;
+/*
+	mvOsPrintf("start read parser entry %d \n",tid);
+*/
+	/* write index */
+	mvPp2WrReg(MV_PP2_PRS_TCAM_IDX_REG, tid);
+	pe->tcam.word[TCAM_INV_WORD] = mvPp2RdReg(MV_PP2_PRS_TCAM_DATA5_REG);
+
+	if ((pe->tcam.word[TCAM_INV_WORD] & TCAM_INV_MASK) != TCAM_VALID)
+		/* Invalid entry */
+		return MV_OK;
+
+	for (index = 0; index < MV_PP2_PRC_TCAM_WORDS; index++)
+		pe->tcam.word[index] = mvPp2RdReg(MV_PP2_PRS_TCAM_DATA_REG(index));
+
+	/* write index */
+	mvPp2WrReg(MV_PP2_PRS_SRAM_IDX_REG, tid);
+
+	for (index = 0; index < MV_PP2_PRC_SRAM_WORDS; index++)
+		pe->sram.word[index] = mvPp2RdReg(MV_PP2_PRS_SRAM_DATA_REG(index));
+/*
+	mvOsPrintf("end read parser entry %d \n",tid);
+*/
+	return MV_OK;
+}
+
+/*
+write entry SRAM + TCAM,
+*/
+int mvPp2PrsHwWrite(MV_PP2_PRS_ENTRY *pe)
+{
+	int index, tid;
+
+	PTR_VALIDATE(pe);
+/*
+	mvOsPrintf("Write parser entry %d - start\n",pe->index);
+*/
+	POS_RANGE_VALIDATE(pe->index, MV_PP2_PRS_TCAM_SIZE - 1);
+	tid = pe->index;
+
+	/*clear invalid bit*/
+	pe->tcam.word[TCAM_INV_WORD] &= ~TCAM_INV_MASK;
+
+	/* write index */
+	mvPp2WrReg(MV_PP2_PRS_TCAM_IDX_REG, tid);
+
+	for (index = 0; index < MV_PP2_PRC_TCAM_WORDS; index++)
+		mvPp2WrReg(MV_PP2_PRS_TCAM_DATA_REG(index), pe->tcam.word[index]);
+
+	/* write index */
+	mvPp2WrReg(MV_PP2_PRS_SRAM_IDX_REG, tid);
+
+	for (index = 0; index < MV_PP2_PRC_SRAM_WORDS; index++)
+		mvPp2WrReg(MV_PP2_PRS_SRAM_DATA_REG(index), pe->sram.word[index]);
+/*
+	mvOsPrintf("Write parser entry %d - end\n",pe->index);
+*/
+	return MV_OK;
+}
+
+/* delete hw entry (set as invalid) */
+int mvPp2PrsHwInv(int tid)
+{
+	POS_RANGE_VALIDATE(tid, MV_PP2_PRS_TCAM_SIZE - 1);
+
+	/* write index */
+	mvPp2WrReg(MV_PP2_PRS_TCAM_IDX_REG, tid);
+	/* write invalid */
+	mvPp2WrReg(MV_PP2_PRS_TCAM_DATA_REG(TCAM_INV_WORD), TCAM_INV_MASK);
+
+	return MV_OK;
+}
+
+/* delete all hw entry (set all as invalid) */
+int mvPp2PrsHwInvAll()
+{
+	int index;
+
+	for (index = 0; index < MV_PP2_PRS_TCAM_SIZE; index++)
+		mvPp2PrsHwInv(index);
+
+	return MV_OK;
+}
+
+int mvPp2PrsHwClearAll()
+{
+	int index, i;
+
+	for (index = 0; index < MV_PP2_PRS_TCAM_SIZE; index++) {
+		mvPp2WrReg(MV_PP2_PRS_TCAM_IDX_REG, index);
+
+		for (i = 0; i < MV_PP2_PRC_TCAM_WORDS; i++)
+			mvPp2WrReg(MV_PP2_PRS_TCAM_DATA_REG(i), 0);
+
+		for (i = 0; i < MV_PP2_PRC_SRAM_WORDS; i++)
+			mvPp2WrReg(MV_PP2_PRS_SRAM_DATA_REG(i), 0);
+	}
+
+	return MV_OK;
+}
+
+int mvPp2PrsHwDump()
+{
+	int index;
+	MV_PP2_PRS_ENTRY pe;
+
+	for (index = 0; index < MV_PP2_PRS_TCAM_SIZE; index++) {
+		pe.index = index;
+		mvPp2PrsHwRead(&pe);
+		if ((pe.tcam.word[TCAM_INV_WORD] & TCAM_INV_MASK) == TCAM_VALID) {
+			mvOsPrintf("%s\n", mvPrsShadowTbl[index].text);
+			mvPp2PrsSwDump(&pe);
+			mvOsPrintf("-------------------------------------------------------------------------\n");
+		}
+	}
+
+	return MV_OK;
+}
+
+
+int mvPp2PrsSwDump(MV_PP2_PRS_ENTRY *pe)
+{
+	MV_U32	op, type, lu, done, flowid;
+	int	shift, offset, i;
+
+	PTR_VALIDATE(pe);
+
+	/* hw entry id */
+	mvOsPrintf("[%4d] ", pe->index);
+
+	i = MV_PP2_PRC_TCAM_WORDS - 1;
+	mvOsPrintf("%1.1x ", pe->tcam.word[i--] & 0xF);
+
+	while (i >= 0)
+		mvOsPrintf("%4.4x ", (MV_32BIT_LE_FAST(pe->tcam.word[i--])) & 0xFFFF);
+
+	mvOsPrintf("| ");
+
+	mvOsPrintf(PRS_SRAM_FMT, PRS_SRAM_VAL(pe->sram.word));
+
+	mvOsPrintf("\n       ");
+
+	i = MV_PP2_PRC_TCAM_WORDS - 1;
+	mvOsPrintf("%1.1x ", (pe->tcam.word[i--] >> 16) & 0xF);
+
+	while (i >= 0)
+		mvOsPrintf("%4.4x ", ((MV_32BIT_LE_FAST(pe->tcam.word[i--]) >> 16)  & 0xFFFF));
+
+	mvOsPrintf("| ");
+
+	mvPp2PrsSwSramShiftGet(pe, &shift);
+	mvOsPrintf("SH=%d ", shift);
+
+	mvPp2PrsSwSramOffsetGet(pe, &type, &offset, &op);
+	if (offset != 0)
+		mvOsPrintf("UDFT=%u UDFO=%d ", type, offset);
+
+	mvOsPrintf("op=%u ", op);
+
+	mvPp2PrsSwSramNextLuGet(pe, &lu);
+	mvOsPrintf("LU=%u ", lu);
+
+	mvPp2PrsSwSramLuDoneGet(pe, &done);
+	mvOsPrintf("%s ", done ? "DONE" : "N_DONE");
+
+	/*flow id generation bit*/
+	mvPp2PrsSwSramFlowidGenGet(pe, &flowid);
+	mvOsPrintf("%s ", flowid ? "FIDG" : "N_FIDG");
+
+	(pe->tcam.word[TCAM_INV_WORD] & TCAM_INV_MASK) ? mvOsPrintf(" [inv]") : 0;
+
+	if (mvPp2PrsSwSramRiDump(pe))
+		return MV_ERROR;
+
+	if (mvPp2PrsSwSramAiDump(pe))
+		return MV_ERROR;
+
+	mvOsPrintf("\n");
+
+	return MV_OK;
+
+}
+
+void mvPp2PrsSwClear(MV_PP2_PRS_ENTRY *pe)
+{
+	memset(pe, 0, sizeof(MV_PP2_PRS_ENTRY));
+}
+
+/*
+	byte - data to tcam entry
+	enable - data to tcam enable endtry
+*/
+int mvPp2PrsSwTcamByteSet(MV_PP2_PRS_ENTRY *pe, unsigned int offs, unsigned char byte, unsigned char enable)
+{
+	PTR_VALIDATE(pe);
+
+	POS_RANGE_VALIDATE(offs, TCAM_DATA_MAX);
+	pe->tcam.byte[TCAM_DATA_BYTE_OFFS(offs)] = byte;
+	pe->tcam.byte[TCAM_DATA_MASK_OFFS(offs)] = enable;
+	return MV_OK;
+}
+
+/*  get byte from entry structure MV_PP2_PRS_ENTRY (sw)
+	byte - data of tcam entry
+	enable - data of tcam enable entry
+*/
+int mvPp2PrsSwTcamByteGet(MV_PP2_PRS_ENTRY *pe, unsigned int offs, unsigned char *byte, unsigned char *enable)
+{
+
+	PTR_VALIDATE(pe);
+	PTR_VALIDATE(byte);
+	PTR_VALIDATE(enable);
+
+	POS_RANGE_VALIDATE(offs, TCAM_DATA_MAX);
+
+	*byte = pe->tcam.byte[TCAM_DATA_BYTE_OFFS(offs)];
+	*enable = pe->tcam.byte[TCAM_DATA_MASK_OFFS(offs)];
+	return MV_OK;
+}
+
+int mvPp2PrsSwTcamWordSet(MV_PP2_PRS_ENTRY *pe, unsigned int offs, unsigned int word, unsigned int mask)
+{
+	int index, offset;
+	unsigned char byte, byteMask;
+
+	PTR_VALIDATE(pe);
+	POS_RANGE_VALIDATE(offs, TCAM_DATA_WORD_MAX);
+	for (index = 0; index < DWORD_BYTES_LEN; index++) {
+		offset = (offs * DWORD_BYTES_LEN) + index;
+		byte = ((unsigned char *) &word)[index];
+		byteMask = ((unsigned char *) &mask)[index];
+		mvPp2PrsSwTcamByteSet(pe, offset, byte, byteMask);
+	}
+
+	return MV_OK;
+}
+
+int mvPp2PrsSwTcamWordGet(MV_PP2_PRS_ENTRY *pe, unsigned int offs, unsigned int *word, unsigned int *enable)
+{
+	int index, offset;
+	unsigned char byte, mask;
+
+	PTR_VALIDATE(pe);
+	PTR_VALIDATE(word);
+	PTR_VALIDATE(enable);
+
+	POS_RANGE_VALIDATE(offs, TCAM_DATA_WORD_MAX);
+
+	for (index = 0; index < DWORD_BYTES_LEN; index++) {
+		offset = (offs * DWORD_BYTES_LEN) + index;
+		mvPp2PrsSwTcamByteGet(pe, offset,  &byte, &mask);
+		((unsigned char *) word)[index] = byte;
+		((unsigned char *) enable)[index] = mask;
+	}
+
+	return MV_OK;
+}
+
+/* compare in sw.
+	return EQUALS if tcam_data[off]&tcam_mask[off] = byte
+
+	user should call hw_read before.!!!!!
+*/
+int mvPp2PrsSwTcamByteCmp(MV_PP2_PRS_ENTRY *pe, unsigned int offs, unsigned char byte)
+{
+	unsigned char tcamByte, tcamMask;
+
+	PTR_VALIDATE(pe);
+
+	if (mvPp2PrsSwTcamByteGet(pe, offs, &tcamByte, &tcamMask) != MV_OK)
+		return MV_PRS_ERR;
+
+	if ((tcamByte & tcamMask) == (byte & tcamMask))
+		return EQUALS;
+
+	return NOT_EQUALS;
+}
+
+/* compare in sw.
+	enable data according to corresponding enable bits in  MV_PP2_PRS_ENTRY
+	user should call hw_read before.!!!!!
+	byte - data of tcam entry
+	enable - data of tcam enable endtry
+	return 0 if equals ..else return 1
+	return MV_PRS_ERR if falied !
+*/
+int mvPp2PrsSwTcamBytesCmp(MV_PP2_PRS_ENTRY *pe, unsigned int offs, unsigned int size, unsigned char *bytes)
+{
+	int status, index;
+
+	PTR_VALIDATE(pe);
+
+	POS_RANGE_VALIDATE(offs + size, TCAM_DATA_SIZE);
+
+	for (index = 0; index < size; index++) {
+		status = mvPp2PrsSwTcamByteCmp(pe, offs + index, bytes[index]);
+		if (status != EQUALS)
+			return status;
+	}
+	return EQUALS;
+}
+
+int mvPp2PrsSwTcamBytesIgnorMaskCmp(MV_PP2_PRS_ENTRY *pe, unsigned int offs, unsigned int size, unsigned char *bytes)
+{
+	int		index;
+	unsigned char 	tcamByte, tcamMask;
+
+	PTR_VALIDATE(pe);
+	POS_RANGE_VALIDATE(offs + size, TCAM_DATA_SIZE);
+
+	for (index = 0; index < size; index++) {
+		mvPp2PrsSwTcamByteGet(pe, offs + index, &tcamByte, &tcamMask);
+		if (tcamByte != bytes[index])
+			return NOT_EQUALS;
+	}
+	return EQUALS;
+}
+
+
+
+int mvPp2PrsSwTcamAiUpdate(MV_PP2_PRS_ENTRY *pe, unsigned int bits, unsigned int enable)
+{
+	int i;
+
+	PTR_VALIDATE(pe);
+	POS_RANGE_VALIDATE(bits, AI_MASK);
+	POS_RANGE_VALIDATE(enable, AI_MASK);
+
+	for (i = 0; i < AI_BITS; i++)
+		if (enable & (1 << i)) {
+			if (bits & (1 << i))
+				pe->tcam.byte[TCAM_AI_BYTE] |= (1 << i);
+			else
+				pe->tcam.byte[TCAM_AI_BYTE] &= ~(1 << i);
+		}
+
+	pe->tcam.byte[TCAM_MASK_OFFS(TCAM_AI_BYTE)] |= enable;
+	return MV_OK;
+}
+
+int mvPp2PrsSwTcamAiGet(MV_PP2_PRS_ENTRY *pe, unsigned int *bits, unsigned int *enable)
+{
+	PTR_VALIDATE(pe);
+	PTR_VALIDATE(bits);
+	PTR_VALIDATE(enable);
+
+	*bits = pe->tcam.byte[TCAM_AI_BYTE];
+	*enable = pe->tcam.byte[TCAM_MASK_OFFS(TCAM_AI_BYTE)];
+
+	return MV_OK;
+}
+
+int mvPp2PrsSwTcamPortSet(MV_PP2_PRS_ENTRY *pe, unsigned int port, int add)
+{
+	PTR_VALIDATE(pe);
+	POS_RANGE_VALIDATE(port, 7);/*TODO define max port val*/
+	POS_RANGE_VALIDATE(add, 1);
+
+	if (add == 1)
+		pe->tcam.byte[TCAM_MASK_OFFS(TCAM_PORT_BYTE)] &= ~(1 << port);
+	else
+		pe->tcam.byte[TCAM_MASK_OFFS(TCAM_PORT_BYTE)] |= (1 << port);
+
+	return MV_OK;
+}
+
+int mvPp2PrsSwTcamPortMapSet(MV_PP2_PRS_ENTRY *pe, unsigned int ports)
+{
+	PTR_VALIDATE(pe);
+	POS_RANGE_VALIDATE(ports, PORT_MASK);
+
+	pe->tcam.byte[TCAM_PORT_BYTE] = 0;
+	pe->tcam.byte[TCAM_MASK_OFFS(TCAM_PORT_BYTE)] &= (unsigned char)(~PORT_MASK);
+	pe->tcam.byte[TCAM_MASK_OFFS(TCAM_PORT_BYTE)] |= ((~ports) & PORT_MASK);
+
+	return MV_OK;
+}
+int mvPp2PrsSwTcamPortMapGet(MV_PP2_PRS_ENTRY *pe, unsigned int *ports)
+{
+	PTR_VALIDATE(pe);
+	PTR_VALIDATE(ports);
+
+	*ports = (~pe->tcam.byte[TCAM_MASK_OFFS(TCAM_PORT_BYTE)]) & PORT_MASK;
+
+	return MV_OK;
+}
+
+
+int mvPp2PrsSwTcamLuSet(MV_PP2_PRS_ENTRY *pe, unsigned int lu)
+{
+
+	PTR_VALIDATE(pe);
+	POS_RANGE_VALIDATE(lu, LU_MASK);
+
+	pe->tcam.byte[TCAM_LU_BYTE] = lu;
+	pe->tcam.byte[TCAM_MASK_OFFS(TCAM_LU_BYTE)] = LU_MASK;
+
+	return MV_OK;
+}
+
+int mvPp2PrsSwTcamLuGet(MV_PP2_PRS_ENTRY *pe, unsigned int *lu, unsigned int *enable)
+{
+	PTR_VALIDATE(pe);
+	PTR_VALIDATE(lu);
+	PTR_VALIDATE(enable);
+
+	*lu = (pe->tcam.byte[TCAM_LU_BYTE]) & LU_MASK;
+	*enable = (pe->tcam.byte[TCAM_MASK_OFFS(TCAM_LU_BYTE)]) & LU_MASK;
+
+	return MV_OK;
+}
+
+int mvPp2PrsSwSramRiSetBit(MV_PP2_PRS_ENTRY *pe, unsigned int bit)
+{
+	PTR_VALIDATE(pe);
+
+	POS_RANGE_VALIDATE(bit, (SRAM_RI_BITS - 1));
+
+	pe->sram.word[SRAM_RI_WORD] |= (1 << bit);
+	pe->sram.word[SRAM_RI_CTRL_WORD] |= (1 << bit);
+
+
+	return MV_OK;
+}
+
+int mvPp2PrsSwSramRiClearBit(MV_PP2_PRS_ENTRY *pe, unsigned int bit)
+{
+	PTR_VALIDATE(pe);
+
+	POS_RANGE_VALIDATE(bit, (SRAM_RI_BITS-1));
+
+	pe->sram.word[SRAM_RI_OFFS] &= ~(1 << bit);
+	pe->sram.word[SRAM_RI_CTRL_WORD] |= (1 << bit);
+
+	return MV_OK;
+}
+
+
+/* set RI and RI_UPDATE */
+int mvPp2PrsSwSramRiUpdate(MV_PP2_PRS_ENTRY *pe, unsigned int bits, unsigned int enable)
+{
+	unsigned int i;
+
+	PTR_VALIDATE(pe);
+
+
+	for (i = 0; i < SRAM_RI_BITS; i++) {
+		if (enable & (1 << i)) {
+			if (bits & (1 << i))
+				mvPp2PrsSwSramRiSetBit(pe, i);
+			else
+				mvPp2PrsSwSramRiClearBit(pe, i);
+		}
+	}
+	return MV_OK;
+}
+
+/* return RI and RI_UPDATE */
+int mvPp2PrsSwSramRiGet(MV_PP2_PRS_ENTRY *pe, unsigned int *bits, unsigned int *enable)
+{
+	PTR_VALIDATE(pe);
+	PTR_VALIDATE(bits);
+	PTR_VALIDATE(enable);
+
+	*bits = pe->sram.word[SRAM_RI_OFFS/32];
+	*enable = pe->sram.word[SRAM_RI_CTRL_OFFS/32];
+	return MV_OK;
+}
+
+static int mvPp2PrsSwSramRiDump(MV_PP2_PRS_ENTRY *pe)
+{
+	int i, data, mask;
+	int off = 0, bitsOffs = 0;
+	char bits[100];
+
+	PTR_VALIDATE(pe);
+
+	mvPp2PrsSwSramRiGet(pe, &data, &mask);
+	if (mask == 0)
+		return off;
+
+	mvOsPrintf("\n       ");
+
+	mvOsPrintf("S_RI=");
+	for (i = (SRAM_RI_BITS-1); i > -1 ; i--)
+		if (mask & (1 << i)) {
+			mvOsPrintf("%d", ((data & (1 << i)) != 0));
+			bitsOffs += mvOsSPrintf(bits + bitsOffs, "%d:", i);
+		} else
+			mvOsPrintf("x");
+
+	bits[bitsOffs] = '\0';
+	mvOsPrintf(" %s", bits);
+
+	return MV_OK;
+}
+
+int mvPp2PrsSwSramAiSetBit(MV_PP2_PRS_ENTRY *pe, unsigned char bit)
+{
+	PTR_VALIDATE(pe);
+	POS_RANGE_VALIDATE(bit, (SRAM_AI_CTRL_BITS - 1));
+
+	pe->sram.byte[(SRAM_AI_OFFS + bit) / 8] |= (1  << ((SRAM_AI_OFFS + bit) % 8));
+	pe->sram.byte[(SRAM_AI_CTRL_OFFS + bit) / 8] |= (1  << ((SRAM_AI_CTRL_OFFS + bit) % 8));
+
+	return MV_OK;
+}
+
+int mvPp2PrsSwSramAiClearBit(MV_PP2_PRS_ENTRY *pe, unsigned char bit)
+{
+	PTR_VALIDATE(pe);
+	POS_RANGE_VALIDATE(bit, (SRAM_AI_CTRL_BITS - 1));
+
+	pe->sram.byte[(SRAM_AI_OFFS + bit) / 8] &= ~(1  << ((SRAM_AI_OFFS + bit) % 8));
+	pe->sram.byte[(SRAM_AI_CTRL_OFFS + bit) / 8] |= (1  << ((SRAM_AI_CTRL_OFFS + bit) % 8));
+
+	return MV_OK;
+}
+
+
+int mvPp2PrsSwSramAiUpdate(MV_PP2_PRS_ENTRY *pe, unsigned int bits, unsigned int mask)
+{
+	unsigned int i;
+
+	PTR_VALIDATE(pe);
+
+	POS_RANGE_VALIDATE(bits, AI_MASK);
+	POS_RANGE_VALIDATE(mask, AI_MASK);
+
+	for (i = 0; i < SRAM_AI_CTRL_BITS; i++)
+		if (mask & (1 << i)) {
+			if (bits & (1 << i))
+				mvPp2PrsSwSramAiSetBit(pe, i);
+			else
+				mvPp2PrsSwSramAiClearBit(pe, i);
+		}
+	return MV_OK;
+}
+
+
+/* return AI and AI_UPDATE */
+int mvPp2PrsSwSramAiGet(MV_PP2_PRS_ENTRY *pe, unsigned int *bits, unsigned int *enable)
+{
+
+	PTR_VALIDATE(pe);
+	PTR_VALIDATE(bits);
+	PTR_VALIDATE(enable);
+
+	*bits = (pe->sram.byte[SRAM_AI_OFFS/8] >> (SRAM_AI_OFFS % 8)) |
+			(pe->sram.byte[(SRAM_AI_OFFS+SRAM_AI_CTRL_BITS)/8] << (8 - (SRAM_AI_OFFS % 8)));
+
+	*enable = (pe->sram.byte[SRAM_AI_CTRL_OFFS/8] >> (SRAM_AI_CTRL_OFFS % 8)) |
+			(pe->sram.byte[(SRAM_AI_CTRL_OFFS+SRAM_AI_CTRL_BITS)/8] << (8 - (SRAM_AI_CTRL_OFFS % 8)));
+
+	*bits &= SRAM_AI_MASK;
+	*enable &= SRAM_AI_MASK;
+
+	return MV_OK;
+}
+
+static int mvPp2PrsSwSramAiDump(MV_PP2_PRS_ENTRY *pe)
+{
+	int i, data, mask, bitsOffs = 0;
+	char bits[30];
+
+	PTR_VALIDATE(pe);
+
+	mvPp2PrsSwSramAiGet(pe, &data, &mask);
+
+	if (mask == 0)
+		return MV_OK;
+
+	mvOsPrintf("\n       ");
+
+	mvOsPrintf("S_AI=");
+	for (i = (SRAM_AI_CTRL_BITS-1); i > -1 ; i--)
+		if (mask & (1 << i)) {
+			mvOsPrintf("%d", ((data & (1 << i)) != 0));
+			bitsOffs += mvOsSPrintf(bits + bitsOffs, "%d:", i);
+		} else
+			mvOsPrintf("x");
+	bits[bitsOffs] = '\0';
+	mvOsPrintf(" %s", bits);
+
+	return MV_OK;
+}
+
+int mvPp2PrsSwSramNextLuSet(MV_PP2_PRS_ENTRY *pe, unsigned int lu)
+{
+	PTR_VALIDATE(pe);
+
+	POS_RANGE_VALIDATE(lu, SRAM_NEXT_LU_MASK);
+
+	pe->sram.byte[SRAM_NEXT_LU_OFFS/8] &= ~(SRAM_NEXT_LU_MASK << (SRAM_NEXT_LU_OFFS % 8));
+	pe->sram.byte[SRAM_NEXT_LU_OFFS/8] |= (lu << (SRAM_NEXT_LU_OFFS % 8));
+	return MV_OK;
+}
+
+int mvPp2PrsSwSramNextLuGet(MV_PP2_PRS_ENTRY *pe, unsigned int *lu)
+{
+	PTR_VALIDATE(pe);
+	PTR_VALIDATE(lu);
+
+	*lu = pe->sram.byte[SRAM_NEXT_LU_OFFS / 8];
+	*lu = ((*lu) >> SRAM_NEXT_LU_OFFS % 8);
+	*lu &= SRAM_NEXT_LU_MASK;
+	return MV_OK;
+}
+
+/* shift to (current offset + shift) */
+int mvPp2PrsSwSramShiftSet(MV_PP2_PRS_ENTRY *pe, int shift, unsigned int op)
+{
+	PTR_VALIDATE(pe);
+	RANGE_VALIDATE(shift, 0 - SRAM_SHIFT_MASK, SRAM_SHIFT_MASK);
+	POS_RANGE_VALIDATE(op, SRAM_OP_SEL_SHIFT_MASK);
+
+	/* Set sign */
+	if (shift < 0) {
+		pe->sram.byte[SRAM_SHIFT_SIGN_BIT / 8] |= (1 << (SRAM_SHIFT_SIGN_BIT % 8));
+		shift = 0 - shift;
+	} else
+		pe->sram.byte[SRAM_SHIFT_SIGN_BIT / 8] &= ~(1 << (SRAM_SHIFT_SIGN_BIT % 8));
+
+	/* Set offset */
+	pe->sram.byte[SRAM_SHIFT_OFFS / 8] = (unsigned char)shift;
+
+	/* Reset and Set operation */
+	pe->sram.byte[SRAM_OP_SEL_SHIFT_OFFS / 8] &= ~(SRAM_OP_SEL_SHIFT_MASK << (SRAM_OP_SEL_SHIFT_OFFS % 8));
+	pe->sram.byte[SRAM_OP_SEL_SHIFT_OFFS / 8] |= (op << (SRAM_OP_SEL_SHIFT_OFFS % 8));
+
+	/* Set base offset as current */
+	pe->sram.byte[SRAM_OP_SEL_BASE_OFFS / 8] &= ~(1 << (SRAM_OP_SEL_BASE_OFFS % 8));
+
+	return MV_OK;
+}
+
+int mvPp2PrsSwSramShiftGet(MV_PP2_PRS_ENTRY *pe, int *shift)
+{
+	int sign;
+
+	PTR_VALIDATE(pe);
+	PTR_VALIDATE(shift);
+
+	sign = pe->sram.byte[SRAM_SHIFT_SIGN_BIT / 8] & (1 << (SRAM_SHIFT_SIGN_BIT % 8));
+	*shift = ((int)(pe->sram.byte[SRAM_SHIFT_OFFS / 8])) & SRAM_SHIFT_MASK;
+
+	if (sign == 1)
+		*shift *= -1;
+
+	return MV_OK;
+}
+/* shift to (InitOffs + shift) */
+int mvPp2PrsSwSramShiftAbsUpdate(MV_PP2_PRS_ENTRY *pe, int shift, unsigned int op)
+{
+	mvPp2PrsSwSramShiftSet(pe, shift, op);
+
+	/* Set base offset as initial */
+	pe->sram.byte[SRAM_OP_SEL_BASE_OFFS / 8] |= (1 << (SRAM_OP_SEL_BASE_OFFS % 8));
+
+	return MV_OK;
+}
+
+
+int mvPp2PrsSwSramOffsetSet(MV_PP2_PRS_ENTRY *pe, unsigned int type, int offset, unsigned int op)
+{
+	PTR_VALIDATE(pe);
+
+	RANGE_VALIDATE(offset, 0 - SRAM_OFFSET_MASK, SRAM_OFFSET_MASK);
+	POS_RANGE_VALIDATE(type, SRAM_OFFSET_TYPE_MASK);
+	POS_RANGE_VALIDATE(op, SRAM_OP_SEL_OFFSET_MASK);
+
+	/* Set offset sign */
+	if (offset < 0) {
+		offset = 0 - offset;
+		/* set sram offset sign bit */
+		pe->sram.byte[SRAM_OFFSET_SIGN_BIT / 8] |= (1 << (SRAM_OFFSET_SIGN_BIT % 8));
+	} else
+		pe->sram.byte[SRAM_OFFSET_SIGN_BIT / 8] &= ~(1 << (SRAM_OFFSET_SIGN_BIT % 8));
+
+	/* set offset value */
+	pe->sram.byte[SRAM_OFFSET_OFFS / 8] &= ~(SRAM_OFFSET_MASK << (SRAM_OFFSET_OFFS % 8));
+	pe->sram.byte[SRAM_OFFSET_OFFS / 8] |= (offset << (SRAM_OFFSET_OFFS % 8));
+	pe->sram.byte[(SRAM_OFFSET_OFFS + SRAM_OFFSET_BITS) / 8] &= ~(SRAM_OFFSET_MASK >> (8 - (SRAM_OFFSET_OFFS % 8)));
+	pe->sram.byte[(SRAM_OFFSET_OFFS + SRAM_OFFSET_BITS) / 8] |= (offset >> (8 - (SRAM_OFFSET_OFFS % 8)));
+
+	/* set offset type */
+	pe->sram.byte[SRAM_OFFSET_TYPE_OFFS / 8] &= ~(SRAM_OFFSET_TYPE_MASK << (SRAM_OFFSET_TYPE_OFFS % 8));
+	pe->sram.byte[SRAM_OFFSET_TYPE_OFFS / 8] |= (type << (SRAM_OFFSET_TYPE_OFFS % 8));
+
+	/* Set offset operation */
+	pe->sram.byte[SRAM_OP_SEL_OFFSET_OFFS / 8] &= ~(SRAM_OP_SEL_OFFSET_MASK << (SRAM_OP_SEL_OFFSET_OFFS % 8));
+	pe->sram.byte[SRAM_OP_SEL_OFFSET_OFFS / 8] |= (op << (SRAM_OP_SEL_OFFSET_OFFS % 8));
+
+	pe->sram.byte[(SRAM_OP_SEL_OFFSET_OFFS + SRAM_OP_SEL_OFFSET_BITS) / 8] &=
+			 ~(SRAM_OP_SEL_OFFSET_MASK >> (8 - (SRAM_OP_SEL_OFFSET_OFFS % 8)));
+	pe->sram.byte[(SRAM_OP_SEL_OFFSET_OFFS + SRAM_OP_SEL_OFFSET_BITS) / 8] |=
+			  (op >> (8 - (SRAM_OP_SEL_OFFSET_OFFS % 8)));
+
+	/* Set base offset as current */
+	pe->sram.byte[SRAM_OP_SEL_BASE_OFFS / 8] &= ~(1 << (SRAM_OP_SEL_BASE_OFFS % 8));
+
+	return MV_OK;
+}
+
+int mvPp2PrsSwSramOffsetGet(MV_PP2_PRS_ENTRY *pe, unsigned int *type, int *offset, unsigned int *op)
+{
+	int sign;
+
+	PTR_VALIDATE(pe);
+	PTR_VALIDATE(offset);
+	PTR_VALIDATE(type);
+
+	*type = pe->sram.byte[SRAM_OFFSET_TYPE_OFFS/8] >> (SRAM_OFFSET_TYPE_OFFS % 8);
+	*type &= SRAM_OFFSET_TYPE_MASK;
+
+
+	*offset = (pe->sram.byte[(SRAM_OFFSET_OFFS)/8] >> (SRAM_OFFSET_OFFS % 8)) & 0x7f;
+	*offset |= (pe->sram.byte[(SRAM_OFFSET_OFFS + SRAM_OFFSET_BITS)/8] << (8 - (SRAM_OFFSET_OFFS % 8))) & 0x80;
+
+	*op = (pe->sram.byte[SRAM_OP_SEL_OFFS/8] >> (SRAM_OP_SEL_OFFS % 8)) & 0x7;
+	*op |= (pe->sram.byte[(SRAM_OP_SEL_OFFS + SRAM_OP_SEL_BITS)/8] << (8 - (SRAM_OP_SEL_OFFS % 8))) & 0x18;
+
+	/* if signed bit is tes */
+	sign = pe->sram.byte[SRAM_OFFSET_SIGN_BIT/8] & (1 << (SRAM_OFFSET_SIGN_BIT % 8));
+	if (sign != 0)
+		*offset = 1-(*offset);
+
+	return MV_OK;
+}
+
+int mvPp2PrsSramBitSet(MV_PP2_PRS_ENTRY *pe, int bitNum)
+{
+
+	PTR_VALIDATE(pe);
+
+	pe->sram.byte[bitNum/8] |= (1 << (bitNum % 8));
+	return MV_OK;
+}
+
+int mvPp2PrsSramBitClear(MV_PP2_PRS_ENTRY *pe, int bitNum)
+{
+	PTR_VALIDATE(pe);
+
+	pe->sram.byte[bitNum/8] &= ~(1 << (bitNum % 8));
+	return MV_OK;
+}
+
+int mvPp2PrsSramBitGet(MV_PP2_PRS_ENTRY *pe, int bitNum, unsigned int *bit)
+{
+	PTR_VALIDATE(pe);
+
+	*bit = pe->sram.byte[bitNum/8]  & (1 << (bitNum % 8));
+	*bit = (*bit) >> (bitNum % 8);
+	return MV_OK;
+}
+
+int mvPp2PrsSwSramLuDoneSet(MV_PP2_PRS_ENTRY *pe)
+{
+	return mvPp2PrsSramBitSet(pe, SRAM_LU_DONE_BIT);
+}
+
+int mvPp2PrsSwSramLuDoneClear(MV_PP2_PRS_ENTRY *pe)
+{
+	return mvPp2PrsSramBitClear(pe, SRAM_LU_DONE_BIT);
+}
+
+int mvPp2PrsSwSramLuDoneGet(MV_PP2_PRS_ENTRY *pe, unsigned int *bit)
+{
+	return mvPp2PrsSramBitGet(pe, SRAM_LU_DONE_BIT, bit);
+}
+
+int mvPp2PrsSwSramFlowidGenSet(MV_PP2_PRS_ENTRY *pe)
+{
+	return mvPp2PrsSramBitSet(pe, SRAM_LU_GEN_BIT);
+}
+
+int mvPp2PrsSwSramFlowidGenClear(MV_PP2_PRS_ENTRY *pe)
+{
+	return mvPp2PrsSramBitClear(pe, SRAM_LU_GEN_BIT);
+}
+
+int mvPp2PrsSwSramFlowidGenGet(MV_PP2_PRS_ENTRY *pe, unsigned int *bit)
+{
+	return mvPp2PrsSramBitGet(pe, SRAM_LU_GEN_BIT, bit);
+
+}
+
diff --git a/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.h b/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.h
new file mode 100644
index 0000000..c55015c
--- /dev/null
+++ b/arch/arm/plat-armada/mv_hal/pp2/prs/mvPp2PrsHw.h
@@ -0,0 +1,842 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_PRS_HW_H__
+#define __MV_PRS_HW_H__
+
+#include "mvTypes.h"
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "../common/mvPp2ErrCode.h"
+#include "../common/mvPp2Common.h"
+#include "../gbe/mvPp2GbeRegs.h"
+/************************** Parser HW Configuration ***********************/
+
+/************************** Parser Registers ******************************/
+
+#define MV_PP2_PRS_INIT_LOOKUP_REG              (MV_PP2_REG_BASE + 0x1000)
+
+#define MV_PP2_PRS_PORT_LU_BITS                 4
+#define MV_PP2_PRS_PORT_LU_MAX			((1 << MV_PP2_PRS_PORT_LU_BITS) - 1)
+#define MV_PP2_PRS_PORT_LU_MASK(port)           (MV_PP2_PRS_PORT_LU_MAX << ((port) * MV_PP2_PRS_PORT_LU_BITS))
+#define MV_PP2_PRS_PORT_LU_VAL(port, val)       ((val) << ((port) * MV_PP2_PRS_PORT_LU_BITS))
+
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_PRS_INIT_OFFS_0_REG              (MV_PP2_REG_BASE + 0x1004)
+#define MV_PP2_PRS_INIT_OFFS_1_REG              (MV_PP2_REG_BASE + 0x1008)
+
+#define MV_PP2_PRS_INIT_OFFS_REG(port)         	(MV_PP2_PRS_INIT_OFFS_0_REG + ((port) & 4))
+#define MV_PP2_PRS_INIT_OFF_BITS					6
+#define MV_PP2_PRS_INIT_OFF_FIXED_BITS		8 /*only for offsets calculations*/
+#define MV_PP2_PRS_INIT_OFF_MAX			((1 << MV_PP2_PRS_INIT_OFF_BITS) - 1)
+#define MV_PP2_PRS_INIT_OFF_MASK(port)		(MV_PP2_PRS_INIT_OFF_MAX << (((port) % 4) * MV_PP2_PRS_INIT_OFF_FIXED_BITS))
+#define MV_PP2_PRS_INIT_OFF_VAL(port, val)	((val) << (((port) % 4) * MV_PP2_PRS_INIT_OFF_FIXED_BITS))
+
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_PRS_MAX_LOOP_0_REG		(MV_PP2_REG_BASE + 0x100c)
+#define MV_PP2_PRS_MAX_LOOP_1_REG		(MV_PP2_REG_BASE + 0x1010)
+
+#define MV_PP2_PRS_MAX_LOOP_REG(port)		(MV_PP2_PRS_MAX_LOOP_0_REG + ((port) & 4))
+#define MV_PP2_PRS_MAX_LOOP_BITS                8
+#define MV_PP2_PRS_MAX_LOOP_MAX			((1 << MV_PP2_PRS_MAX_LOOP_BITS) - 1) /*MAX VALID VALUE*/
+#define MV_PP2_PRS_MAX_LOOP_MIN			1 /*MIN VALID VALUE*/
+#define MV_PP2_PRS_MAX_LOOP_MASK(port)		(MV_PP2_PRS_MAX_LOOP_MAX << (((port) % 4) * MV_PP2_PRS_MAX_LOOP_BITS))
+#define MV_PP2_PRS_MAX_LOOP_VAL(port, val)      ((val) << (((port) % 4) * MV_PP2_PRS_MAX_LOOP_BITS))
+
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_PRS_INTR_CAUSE_REG		(MV_PP2_REG_BASE + 0x1020)
+#define MV_PP2_PRS_INTR_MASK_REG		(MV_PP2_REG_BASE + 0x1024)
+
+#define PRS_INTR_MISS				0
+#define PRS_INTR_MAX_LOOPS			1
+#define PRS_INTR_INV_OFF			2
+#define PRS_INTR_PARITY				4
+#define PRS_INTR_SRAM_PARITY			5
+
+#define PRS_INTR_MISS_MASK			(1 << PRS_INTR_MISS)
+#define PRS_INTR_MAX_LOOP_MASK			(1 << PRS_INTR_MAX_LOOPS)
+#define PRS_INTR_INV_OFF_MASK			(1 << PRS_INTR_INV_OFF)
+#define PRS_INTR_PARITY_MASK			(1 << PRS_INTR_PARITY)
+#define PRS_INTR_SRAM_PARITY_MASK		(1 << PRS_INTR_SRAM_PARITY)
+
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_PRS_TCAM_IDX_REG			(MV_PP2_REG_BASE + 0x1100)
+#define MV_PP2_PRS_TCAM_DATA_REG(idx)		(MV_PP2_REG_BASE + 0x1104 + (idx) * 4)
+#define MV_PP2_PRS_TCAM_DATA0_REG		(MV_PP2_REG_BASE + 0x1104)
+#define MV_PP2_PRS_TCAM_DATA1_REG		(MV_PP2_REG_BASE + 0x1108)
+#define MV_PP2_PRS_TCAM_DATA2_REG		(MV_PP2_REG_BASE + 0x110c)
+#define MV_PP2_PRS_TCAM_DATA3_REG		(MV_PP2_REG_BASE + 0x1110)
+#define MV_PP2_PRS_TCAM_DATA4_REG		(MV_PP2_REG_BASE + 0x1114)
+#define MV_PP2_PRS_TCAM_DATA5_REG		(MV_PP2_REG_BASE + 0x1118)
+
+#define MV_PP2_PRS_TCAM_DATA_OFFS		0
+#define MV_PP2_PRS_TCAM_MASK_OFFS		16
+/*-------------------------------------------------------------------------------*/
+
+#define MV_PP2_PRS_SRAM_IDX_REG			(MV_PP2_REG_BASE + 0x1200)
+#define MV_PP2_PRS_SRAM_DATA_REG(idx)		(MV_PP2_REG_BASE + 0x1204 + (idx) * 4)
+#define MV_PP2_PRS_SRAM_DATA0_REG		(MV_PP2_REG_BASE + 0x1204)
+#define MV_PP2_PRS_SRAM_DATA1_REG		(MV_PP2_REG_BASE + 0x1208)
+#define MV_PP2_PRS_SRAM_DATA2_REG		(MV_PP2_REG_BASE + 0x120c)
+#define MV_PP2_PRS_SRAM_DATA3_REG		(MV_PP2_REG_BASE + 0x1210)
+/*-------------------------------------------------------------------------------*/
+
+
+#define AI_BITS  				8
+#define AI_MASK					((1 << AI_BITS) - 1)
+#define AI_DONE_BIT				7
+#define AI_DONE					(1 << 7)
+
+#define PORT_BITS  				8
+#define PORT_MASK				((1 << PORT_BITS) - 1)
+
+#define LU_BITS  				4
+#define LU_MASK					((1 << LU_BITS) - 1)
+
+/************************* TCAM structure **********************/
+/*
+______________________________________________
+|  LKP ID  | PORT ID |    AI  | HEADER DATA  |
+| 4 bits   | 1 byte  | 1 byte |   8 byte     |
+----------------------------------------------
+reg 5 --> reg 0
+*/
+
+#define TCAM_DATA_BYTE				0
+#define TCAM_DATA_SIZE				8 /*bytes*/
+#define TCAM_DATA_MAX				(TCAM_DATA_SIZE - 1) /*bytes*/
+#define TCAM_DATA_WORD_MAX			((TCAM_DATA_SIZE / 4) - 1) /*words*/
+#define TCAM_AI_BYTE				16
+#define TCAM_AI_OFFS				0
+
+#define TCAM_PORT_BYTE				17
+#define TCAM_PORT_OFFS				0
+
+#define TCAM_LU_BYTE				20
+#define TCAM_LU_OFFS				0
+
+/* Special bit in the TCAM register */
+#define TCAM_INV_BIT				31
+#define TCAM_INV_MASK				(1 << TCAM_INV_BIT)
+#define TCAM_VALID				0
+#define TCAM_INVALID				1
+#define TCAM_INV_WORD				5
+
+#define TCAM_DATA_BYTE_OFFS(_offs_)		(((_offs_) - ((_offs_) % 2)) * 2 + ((_offs_) % 2))
+#define TCAM_DATA_MASK_OFFS(_offs_)		(((_offs_) * 2) - ((_offs_) % 2)  + 2)
+#define TCAM_MASK_OFFS(_offs_)			((_offs_) + 2)
+
+
+
+/************************* SRAM structure **********************/
+#define SRAM_RI_OFFS  					0
+#define SRAM_RI_BITS  					32
+#define SRAM_RI_MASK  					((1 << SRAM_RI_BITS) - 1)
+#define SRAM_RI_WORD  					(SRAM_RI_OFFS / DWORD_BITS_LEN)
+
+#define SRAM_RI_CTRL_OFFS  				32
+#define SRAM_RI_CTRL_BITS  				32
+#define SRAM_RI_CTRL_WORD  				(SRAM_RI_CTRL_OFFS / DWORD_BITS_LEN)
+
+#define SRAM_SHIFT_OFFS  				64 /*NEXT_LKP*/
+#define SRAM_SHIFT_BITS					8
+#define SRAM_SHIFT_MASK					((1 << SRAM_SHIFT_BITS) - 1)
+
+#define SRAM_SHIFT_SIGN_BIT  				72 /*NEXT_LKP_SIGN*/
+
+#define SRAM_OFFSET_OFFS				73 /*UDF_OFF*/
+#define SRAM_OFFSET_BITS				8
+#define SRAM_OFFSET_MASK				((1 << SRAM_OFFSET_BITS) - 1)
+
+#define SRAM_OFFSET_SIGN_BIT  				81 /*UDF_SIGN*/
+
+#define SRAM_OFFSET_TYPE_OFFS  				82 /*UDF_TYPE*/
+#define SRAM_OFFSET_TYPE_BITS  				3
+#define SRAM_OFFSET_TYPE_MASK  				((1 << SRAM_OFFSET_TYPE_BITS) - 1)
+#define SRAM_OFFSET_TYPE_PKT				0
+#define SRAM_OFFSET_TYPE_L3				1
+#define SRAM_OFFSET_TYPE_L4				4
+
+#define SRAM_OP_SEL_OFFS  				85
+#define SRAM_OP_SEL_BITS  				5
+#define SRAM_OP_SEL_MASK  				((1 << SRAM_OP_SEL_BITS) - 1)
+
+#define SRAM_OP_SEL_SHIFT_OFFS				85
+#define SRAM_OP_SEL_SHIFT_BITS				2
+#define SRAM_OP_SEL_SHIFT_MASK  			((1 << SRAM_OP_SEL_SHIFT_BITS) - 1)
+#define SRAM_OP_SEL_SHIFT_ADD				1
+#define SRAM_OP_SEL_SHIFT_IP4_ADD			2
+#define SRAM_OP_SEL_SHIFT_IP6_ADD			3
+
+#define SRAM_OP_SEL_OFFSET_OFFS				87
+#define SRAM_OP_SEL_OFFSET_BITS				2
+#define SRAM_OP_SEL_OFFSET_MASK  			((1 << SRAM_OP_SEL_OFFSET_BITS) - 1)
+#define SRAM_OP_SEL_OFFSET_ADD				0
+#define SRAM_OP_SEL_OFFSET_LKP_ADD			1
+#define SRAM_OP_SEL_OFFSET_IP4_ADD			2
+#define SRAM_OP_SEL_OFFSET_IP6_ADD			3
+
+#define SRAM_OP_SEL_BASE_OFFS				89
+#define SRAM_OP_SEL_BASE_BITS				1
+#define SRAM_OP_SEL_BASE_MASK				((1 << SRAM_OP_SEL_BASE_BITS) - 1)
+#define SRAM_OP_SEL_BASE_CURRENT			0
+#define SRAM_OP_SEL_BASE_INIT				1
+
+#define SRAM_AI_OFFS					90
+#define SRAM_AI_BITS					8
+#define SRAM_AI_MASK					((1 << SRAM_AI_BITS) - 1)
+#define SRAM_AI_WORD					(SRAM_AI_OFFS / DWORD_BITS_LEN)
+
+#define SRAM_AI_CTRL_OFFS				98
+#define SRAM_AI_CTRL_BITS				8
+#define SRAM_AI_CTRL_MASK				((1 << SRAM_AI_CTRL_BITS) - 1)
+#define SRAM_AI_CTRL_WORD				(SRAM_AI_CTRL_OFFS / DWORD_BITS_LEN)
+
+#define SRAM_NEXT_LU_OFFS				106 /*LOOKUP ID*/
+#define SRAM_NEXT_LU_BITS				4
+#define SRAM_NEXT_LU_MASK				((1 << SRAM_NEXT_LU_BITS) - 1)
+
+#define SRAM_LU_DONE_BIT				110
+#define SRAM_LU_GEN_BIT					111
+/*-------------------------------------------------------------------------------*/
+
+/* Result info bits assigment */
+#define RI_MAC_ME_BIT					0
+#define RI_MAC_ME_MASK					(1 << RI_MAC_ME_BIT)
+
+#define RI_DSA_BIT                 			1
+#define RI_DSA_MASK        				(1 << RI_DSA_BIT)
+
+/* bits 2 - 3 */
+#define RI_VLAN_OFFS					2
+#define RI_VLAN_BITS					2
+#define RI_VLAN_MASK					(((1 << RI_VLAN_BITS) - 1) << RI_VLAN_OFFS)
+#define RI_VLAN_NONE          				(0 << RI_VLAN_OFFS)
+#define RI_VLAN_SINGLE          			(1 << RI_VLAN_OFFS)
+#define RI_VLAN_DOUBLE          			(2 << RI_VLAN_OFFS)
+#define RI_VLAN_TRIPLE          			(3 << RI_VLAN_OFFS)
+
+/* bits 4 - 6 */
+#define RI_CPU_CODE_OFFS           			4 /* bits 4 - 6 */
+#define RI_CPU_CODE_BITS				3
+#define RI_CPU_CODE_MASK				(((1 << RI_CPU_CODE_BITS) - 1) << RI_CPU_CODE_OFFS)
+#define RI_CPU_CODE_RX_SPEC				(1 << RI_CPU_CODE_OFFS)
+
+/* bits 7 - 8 */
+#define RI_L2_VER_OFFS					7
+#define RI_L2_VER_BITS					2
+#define RI_L2_VER_MASK					(((1 << RI_L2_VER_BITS) - 1) << RI_L2_VER_OFFS)
+#define RI_L2_LLC               			(0 << RI_L2_VER_OFFS)
+#define RI_L2_LLC_SNAP          			(1 << RI_L2_VER_OFFS)
+#define RI_L2_ETH2             				(2 << RI_L2_VER_OFFS)
+#define RI_L2_OTHER             			(3 << RI_L2_VER_OFFS)
+
+/* bits 9 - 10 */
+#define RI_L2_CAST_OFFS					9
+#define RI_L2_CAST_BITS					2
+#define RI_L2_CAST_MASK					(((1 << RI_L2_CAST_BITS) - 1) << RI_L2_CAST_OFFS)
+#define RI_L2_UCAST					(0 << RI_L2_CAST_OFFS)
+#define RI_L2_MCAST					(1 << RI_L2_CAST_OFFS)
+#define RI_L2_BCAST					(2 << RI_L2_CAST_OFFS)
+#define RI_L2_RESERVED					(3 << RI_L2_CAST_OFFS)
+
+/* bit 11 */
+#define RI_PPPOE_BIT					11
+#define RI_PPPOE_MASK					(1 << RI_PPPOE_BIT)
+
+/* bits 12 - 14 */
+#define RI_L3_PROTO_OFFS				12
+#define RI_L3_PROTO_BITS				3
+#define RI_L3_PROTO_MASK				(((1 << RI_L3_PROTO_BITS) - 1) << RI_L3_PROTO_OFFS)
+#define RI_L3_UN              				(0 << RI_L3_PROTO_OFFS)
+#define RI_L3_IP4            				(1 << RI_L3_PROTO_OFFS)
+#define RI_L3_IP4_OPT          				(2 << RI_L3_PROTO_OFFS)
+#define RI_L3_IP4_OTHER       				(3 << RI_L3_PROTO_OFFS)
+#define RI_L3_IP6         				(4 << RI_L3_PROTO_OFFS)
+#define RI_L3_IP6_EXT          				(5 << RI_L3_PROTO_OFFS)
+#define RI_L3_ARP					(6 << RI_L3_PROTO_OFFS)
+#define RI_L3_RESERVED					(7 << RI_L3_PROTO_OFFS)
+
+
+/* bits 15 - 16 */
+#define RI_L3_ADDR_OFFS       				15
+#define RI_L3_ADDR_BITS       				2
+#define RI_L3_ADDR_MASK					(((1 << RI_L3_ADDR_BITS) - 1) << RI_L3_ADDR_OFFS)
+#define RI_L3_UCAST            				(0 << RI_L3_ADDR_OFFS)
+#define RI_L3_MCAST            				(1 << RI_L3_ADDR_OFFS)
+#define RI_L3_BCAST            				(2 << RI_L3_ADDR_OFFS)
+#define RI_L3_ANYCAST           			(3 << RI_L3_ADDR_OFFS)
+
+/* bit 17 */
+#define RI_IP_FRAG_BIT					17
+#define RI_IP_FRAG_MASK					(1 << RI_IP_FRAG_BIT)
+
+/* Bits 18 - 19 */
+#define RI_UDF2_OFFS					18
+#define RI_UDF2_BITS					2
+#define RI_UDF2_MASK					(((1 << RI_UDF2_BITS) - 1) << RI_UDF2_OFFS)
+
+/* Bits 20 - 21 */
+#define RI_UDF3_OFFS					20
+#define RI_UDF3_BITS					2
+#define RI_UDF3_MASK					(((1 << RI_UDF3_BITS) - 1) << RI_UDF3_OFFS)
+
+/* Bits 22 - 24 */
+#define RI_L4_PROTO_OFFS				22
+#define RI_L4_PROTO_BITS				3
+#define RI_L4_PROTO_MASK				(((1 << RI_L4_PROTO_BITS) - 1) << RI_L4_PROTO_OFFS)
+#define RI_L4_UN					(0 << RI_L4_PROTO_OFFS)
+#define RI_L4_TCP					(1 << RI_L4_PROTO_OFFS)
+#define RI_L4_UDP					(2 << RI_L4_PROTO_OFFS)
+#define RI_L4_OTHER					(3 << RI_L4_PROTO_OFFS)
+									/* 3-7 user defined */
+/* Bits 25 - 26 */
+#define RI_UDF5_OFFS					25
+#define RI_UDF5_BITS					2
+#define RI_UDF5_MASK					(((1 << RI_UDF5_BITS) - 1) << RI_UDF5_OFFS)
+
+/* Bits 27 - 28 */
+#define RI_UDF6_OFFS					27
+#define RI_UDF6_BITS					2
+#define RI_UDF6_MASK					(((1 << RI_UDF6_BITS) - 1) << RI_UDF6_OFFS)
+
+/* Bits 29 - 30 */
+#define RI_UDF7_OFFS					29
+#define RI_UDF7_BITS					2
+#define RI_UDF7_MASK					(((1 << RI_UDF7_BITS) - 1) << RI_UDF7_OFFS)
+
+/* bit 31 - drop */
+#define RI_DROP_BIT					31
+#define RI_DROP_MASK					(1 << RI_DROP_BIT)
+/*---------------------------------------------------------------------------*/
+
+/************* Offfset types *****************/
+#define MV_PP2_PKT_OFFSET				0
+#define MV_PP2_L3_OFFSET				1
+#define MV_PP2_IP6_OFFSET				2
+#define MV_PP2_UDF3_OFFSET				3
+#define MV_PP2_L4_OFFSET				4
+#define MV_PP2_UDF5_OFFSET				5
+#define MV_PP2_UDF6_OFFSET				6
+#define MV_PP2_UDF7_OFFSET				7
+
+
+/*-------------------------------------------------------------------------------*/
+/* 				Parser Shadow					 */
+/*-------------------------------------------------------------------------------*/
+
+#define PRS_TEXT_SIZE					20
+
+typedef struct {
+	int             valid;
+	int		lu;
+	unsigned char   text[PRS_TEXT_SIZE];
+} PRS_SHADOW_ENTRY;
+
+void mvPp2PrsShadowSet(int index, int lu, char *text);
+void mvPp2PrsShadowClear(int index);
+void mvPp2PrsShadowClearAll(void);
+int mvPp2PrsShadowLu(int index);
+int mvPp2PrsShadowIsValid(int index);
+int mvPp2PrsTcamFirstFree(int start, int end);
+
+
+/*-------------------------------------------------------------------------------*/
+/* 				Parser SW entry 				 */
+/*-------------------------------------------------------------------------------*/
+
+/* Parser Public TCAM APIs */
+#define MV_PP2_PRS_TCAM_SIZE 				(256)
+
+#define MV_PP2_PRC_TCAM_WORDS				6
+#define MV_PP2_PRC_SRAM_WORDS				4
+
+#define PRS_SRAM_FMT					"%4.4x %8.8x %8.8x %8.8x"
+#define PRS_SRAM_VAL(p)					p[3] & 0xFFFF, p[2], p[1], p[0]
+
+typedef union mvPp2TcamEntry {
+	MV_U32 word[MV_PP2_PRC_TCAM_WORDS];
+	MV_U8  byte[MV_PP2_PRC_TCAM_WORDS * 4];
+} MV_PP2_TCAM_ENTRY;
+
+typedef union mvPp2SramEntry {
+	MV_U32 word[MV_PP2_PRC_SRAM_WORDS];
+	MV_U8  byte[MV_PP2_PRC_SRAM_WORDS * 4];
+} MV_PP2_SRAM_ENTRY;
+
+
+typedef struct mvPp2PrsEntry {
+	unsigned int index;
+	MV_PP2_TCAM_ENTRY tcam;
+	MV_PP2_SRAM_ENTRY sram;
+} MV_PP2_PRS_ENTRY;
+
+
+/*-------------------------------------------------------------------------------*/
+/* 			Parser Public initialization APIs			 */
+/*-------------------------------------------------------------------------------*/
+
+/*
+ *mvPp2PrsHwInvAll - sign all tcam entries as invalid
+*/
+int mvPp2PrsHwInvAll(void);
+
+/*
+ *mvPp2PrsHwClearAll - clear all tcam and sram entries
+*/
+int mvPp2PrsHwClearAll(void);
+
+/*
+ * mvPp2PrsHwPortInit - set first lookup fileds per port
+ * @port: port number
+ * @lu_first: first lookup id
+ * @lu_max: max number of lookups
+ * @offs: initial offset in packet
+*/
+int mvPp2PrsHwPortInit(int port, int lu_first, int lu_max, int offs);
+
+/*
+ * mvPrsSwAlloc - allocate new prs entry
+ * @id: tcam lookup id
+ */
+MV_PP2_PRS_ENTRY *mvPp2PrsSwAlloc(unsigned int luId);
+
+/*
+ * mvPp2PrsSwFree
+ * @pe: entry to free
+*/
+void mvPp2PrsSwFree(MV_PP2_PRS_ENTRY *pe);
+
+/*-------------------------------------------------------------------------------*/
+/* 			Parser internal initialization functions		 */
+/*-------------------------------------------------------------------------------*/
+
+/*
+ * mvPrsHwLkpFirstSet - set first lookup id per port
+ * @port: port number
+ * @lu_first: first lookup id
+*/
+int mvPrsHwLkpFirstSet(int port, int lu_first);
+
+/*
+ * mvPrsHwLkpMaxSet - set max number of lookups per port
+ * @port: port number
+ * @lu_max: max number of lookups
+*/
+int mvPrsHwLkpMaxSet(int port, int lu_max);
+
+/*
+ * mvPrsHwLkpMaxSet - set first lookup initial packet offset
+ * @port: port number
+ * @offs: initial offset in packet
+*/
+int mvPrsHwLkpFirstOffsSet(int port, int off);
+
+/*-------------------------------------------------------------------------------*/
+/* 			Parser Public TCAM APIs 				*/
+/*-------------------------------------------------------------------------------*/
+
+/*
+ * mvPp2PrsHwRead - read prs entry
+*/
+int mvPp2PrsHwRead(MV_PP2_PRS_ENTRY *pe);
+
+/*
+ * mvPp2PrsHwWrite - write prs entry
+*/
+int mvPp2PrsHwWrite(MV_PP2_PRS_ENTRY *pe);
+
+/*
+ * mvPp2PrsHwInv - invalidate prs entry
+ * @tid: entry id
+*/
+int mvPp2PrsHwInv(int tid);
+
+/*
+ * mvPp2PrsHwRegsDump - dump all prs registers into buffer
+*/
+int mvPp2PrsHwRegsDump(void);
+
+/*
+ * mvPp2PrsSwDump - dump sw prs entry
+ * @pe: sw prs entry
+*/
+int mvPp2PrsSwDump(MV_PP2_PRS_ENTRY *pe);
+
+/*
+ * mvPp2PrsSwClear - clear prs sw entry
+ * @pe: sw prs entry
+*/
+int mvPp2PrsHwDump(void);
+
+/*
+ * mvPp2PrsHwDump - dump all valid hw entries
+*/
+void mvPp2PrsSwClear(MV_PP2_PRS_ENTRY *pe);
+
+/*
+ * mvPp2PrsSwTcamWordGet - get byte form tcam data and tcam mask
+ * @pe: sw prs entry
+ * @offs: offset in tcam data, valid value 0 - 7
+ * @woed: data from tcam
+ * @enablek: data from tcam mask
+*/
+int mvPp2PrsSwTcamWordGet(MV_PP2_PRS_ENTRY *pe, unsigned int offs, unsigned int *word, unsigned int *enable);
+/*
+ * mvPp2PrsSwTcamWordSet - set byte in tcam data and tcam mask
+ * @pe: sw prs entry
+ * @offs: offset in tcam data, valid value 0, 1
+ * @word: data to tcam
+ * enable: data to tcam mask
+*/
+int mvPp2PrsSwTcamWordSet(MV_PP2_PRS_ENTRY *pe, unsigned int offs, unsigned int word, unsigned int mask);
+
+/*
+ * mvPp2PrsSwTcamByteGet - get byte form tcam data and tcam mask
+ * @pe: sw prs entry
+ * @offs: offset in tcam data, valid value 0, 1
+ * @byte: data from tcam
+ * @mask: data from tcam mask
+*/
+int mvPp2PrsSwTcamByteGet(MV_PP2_PRS_ENTRY *pe, unsigned int offs, unsigned char *byte, unsigned char *enable);
+/*
+ * mvPp2PrsSwTcamByteSet - set byte in tcam data and tcam mask
+ * @pe: sw prs entry
+ * @offs: offset in tcam data, valid value 0 - 7
+ * @byte: data to tcam
+ * enable: data to tcam mask
+*/
+int mvPp2PrsSwTcamByteSet(MV_PP2_PRS_ENTRY *pe, unsigned int offs, unsigned char byte, unsigned char mask);
+
+/*
+ * mvPp2PrsSwTcamByteCmp - compare one byte in tcam data of prs sw entery
+ * @pe: sw prs entry
+ * @offs: offset in tcam data, valid value 0 - 7
+ * @byte: data to compare
+ * return value: tcam[off] & tcam_mask[off] == byte & tcam_mask[off]
+*/
+int mvPp2PrsSwTcamByteCmp(MV_PP2_PRS_ENTRY *pe, unsigned int offs, unsigned char byte);
+
+/*
+ * mvPp2PrsSwTcamBytesCmp - compare bytes sequence in tcam data of prs sw entery
+ * call to  mvPp2PrsSwTcamByteCmp fpr each byte in the sequence.
+ * @pe: sw prs entry
+ * @offs: bytes sequence start offset in tcam dat
+ * @size: number of bytes to compare
+ * return value: tcam[off] & tcam_mask[off] == byte & tcam_mask[off] for all bytes
+*/
+int mvPp2PrsSwTcamBytesCmp(MV_PP2_PRS_ENTRY *pe, unsigned int offset, unsigned int size, unsigned char *bytes);
+
+/*
+ * mvPp2PrsSwTcamBytesCmpIgnorMask - compare bytes sequence in tcam data of prs sw entery
+ * call to  mvPp2PrsSwTcamByteCmp fpr each byte in the sequence.
+ * @pe: sw prs entry
+ * @offs: bytes sequence start offset in tcam dat
+ * @size: number of bytes to compare
+ * return value: tcam[off] == byte for all bytes
+*/
+int mvPp2PrsSwTcamBytesIgnorMaskCmp(MV_PP2_PRS_ENTRY *pe, unsigned int offs, unsigned int size, unsigned char *bytes);
+/*
+ * mvPp2PrsSwTcamAiUpdate - update tcam ai bits in prs sw entry.
+ * @pe: sw prs entry
+ * @bits: bits to set
+ * @enable: bits mask
+ * tcam AI[i] <-- bits[i] only if  enable[i] is set.
+ * tcam_mask AI[i] <--1 only if enable[i] is set.
+*/
+int mvPp2PrsSwTcamAiUpdate(MV_PP2_PRS_ENTRY *pe, unsigned int bits, unsigned int enable);
+
+/*
+ * mvPp2PrsSwTcamAiGet - get tcam AI and tcam_mask AI from prs sw entry.
+ * @pe: sw prs entry
+ * @bits: get tcam AI val
+ * @enable: get tcam mask AI val
+*/
+int mvPp2PrsSwTcamAiGet(MV_PP2_PRS_ENTRY *pe, unsigned int *bits, unsigned int *enable);
+
+/*
+ * mvPp2PrsSwTcamAiSetBit - set tcam AI bit in prs sw entry.
+ * @pe: sw prs entry
+ * @bit: bit offset
+ * tcam AI[bit] = 1 , tcam mask AI[bit] = 1
+*/
+int mvPp2PrsSwTcamAiSetBit(MV_PP2_PRS_ENTRY *pe, unsigned char bit);
+
+/*
+ * mvPp2PrsSwTcamAiClearBit - clear tcam AI bit in prs sw entry.
+ * @pe: sw prs entry
+ * @bit: bit offset
+ * tcam AI[bit] = 0 , tcam mask AI[bit] = 1
+*/
+int mvPp2PrsSwTcamAiClearBit(MV_PP2_PRS_ENTRY *pe, unsigned char bit);
+
+/*
+ * mvPp2PrsSwTcamPortSet - set tcam port map in prs sw entry.
+ * @pe: sw prs entry
+ * @port: single port to be add or delete
+ * @add: 1 - add port, 0 - delete port
+*/
+int mvPp2PrsSwTcamPortSet(MV_PP2_PRS_ENTRY *pe, unsigned int port, int add);
+
+/*
+ * mvPp2PrsSwTcamPortMapSet - set tcam port map in prs sw entry.
+ * @pe: sw prs entry
+ * @ports: ports bitmap to be set
+*/
+int mvPp2PrsSwTcamPortMapSet(MV_PP2_PRS_ENTRY *pe, unsigned int ports);
+
+/*
+ * mvPp2PrsSwTcamPortMapGet - get tcam PORT bitmap from prs sw entry.
+ * @pe: sw prs entry
+ * @port: get tcam PORTS val
+*/
+int mvPp2PrsSwTcamPortMapGet(MV_PP2_PRS_ENTRY *pe, unsigned int *ports);
+
+/*
+ * mvPp2PrsSwTcamLuSet - set tcam lookup id in prs sw entry.
+ * @pe: sw prs entry
+ * @lu: lookup id
+ * set tcam mask LU to 0xff
+*/
+int mvPp2PrsSwTcamLuSet(MV_PP2_PRS_ENTRY *pe, unsigned int lu);
+
+/*
+ * mvPp2PrsSwTcamLuGet - get tcam lookup id from prs sw entry.
+ * @pe: sw prs entry
+ * @lu: get tcam lookup id
+ * @enable: get tcam mask lookup id
+*/
+int mvPp2PrsSwTcamLuGet(MV_PP2_PRS_ENTRY *pe, unsigned int *lu, unsigned int *enable);
+
+
+/*
+ * mvPp2PrsSwSramRiSetBit - set sram result info bit in prs sw entry.
+ * @pe: sw prs entry
+ * @bit: bit offset in result info
+ * set sram RI_EN[bit]
+ */
+int mvPp2PrsSwSramRiSetBit(MV_PP2_PRS_ENTRY *pe, unsigned int bit);
+
+/*
+ * mvPp2PrsSwSramRiClearBit - clear sram result info bit in prs sw entry.
+ * @pe: sw prs entry
+ * @bit: bit offset in result info
+ * set sram RI_EN[bit]
+ */
+int mvPp2PrsSwSramRiClearBit(MV_PP2_PRS_ENTRY *pe, unsigned int bit);
+
+/*
+ * mvPp2PrsSwSramRiUpdate - update sram result info bits in prs sw entry.
+ * @pe: sw prs entry
+ * @bits: bits to set
+ * @enable: bits mask
+ * sram RI[i] <-- bits[i] only if  sram RI_EN[i] is set.
+ * sram RI_EN[i] <--1 only if enable[i] is set.
+ */
+int mvPp2PrsSwSramRiUpdate(MV_PP2_PRS_ENTRY *pe, unsigned int bits, unsigned int enable);
+
+/*
+ * mvPp2PrsSwSramRiGet - get sram result info from prs sw entry.
+ * @pe: sw prs entry
+ * @bits: get result info bits
+ * @enable: get result info update bits
+*/
+int mvPp2PrsSwSramRiGet(MV_PP2_PRS_ENTRY *pe, unsigned int *bits, unsigned int *enable);
+
+
+/*
+ * mvPp2PrsSwSramAiSetBit - set sram AI bit in prs sw entry.
+ * @pe: sw prs entry
+ * @bit: bit offset
+ * sram AI[bit] = 1 , sram AI_EN[bit] = 1
+*/
+int mvPp2PrsSwSramAiSetBit(MV_PP2_PRS_ENTRY *pe, unsigned char bit);
+
+/*
+ * mvPp2PrsSwSramAiClearBit - clear sram AI bit in prs sw entry.
+ * @pe: sw prs entry
+ * @bit: bit offset
+ * sram AI[bit] = 0 , sram AI_EN[bit] = 1
+*/
+int mvPp2PrsSwSramAiClearBit(MV_PP2_PRS_ENTRY *pe, unsigned char bit);
+
+/*
+ * mvPp2PrsSwSramAiUpdate - update sram ai bits in prs sw entry.
+ * @pe: sw prs entry
+ * @bits: bits to set
+ * @enable: bits mask
+ * sram AI[i] <-- bits[i] only if  enable[i] is set.
+ * sram AI_EN[i] <--1 only if enable[i] is set.
+*/
+int mvPp2PrsSwSramAiUpdate(MV_PP2_PRS_ENTRY *pe, unsigned int bits, unsigned int enable);
+
+/*
+ * mvPp2PrsSwSramAiGet - get sram AI and AI_EN from prs sw entry.
+ * @pe: sw prs entry
+ * @bits: get sram AI val
+ * @enable: get sram AI_EN val
+*/
+int mvPp2PrsSwSramAiGet(MV_PP2_PRS_ENTRY *pe, unsigned int *bits, unsigned int *enable);
+
+
+/*
+ * mvPp2PrsSwSramNextLuSet - set prs sram next lookup id.
+ * @pe: sw prs entry
+ * @lu: next lookup id
+*/
+int mvPp2PrsSwSramNextLuSet(MV_PP2_PRS_ENTRY *pe, unsigned int lu);
+
+/*
+ * mvPp2PrsSwSramNextLuGet - got prs sram next lookup id.
+ * @pe: sw prs entry
+ * @lu: get next lookup id
+*/
+int mvPp2PrsSwSramNextLuGet(MV_PP2_PRS_ENTRY *pe, unsigned int *lu);
+
+
+/*
+ * mvPp2PrsSwSramShiftSet - set prs sram shift.
+ * @pe: sw prs entry
+ * @shift
+ * @op
+*/
+int mvPp2PrsSwSramShiftSet(MV_PP2_PRS_ENTRY *pe, int shift, unsigned int op);
+
+/*
+ * mvPp2PrsSwSramShiftGet - get prs sram shift.
+ * @pe: sw prs entry
+ * @shift: get shift val
+ * @op: get shift op
+*/
+int mvPp2PrsSwSramShiftGet(MV_PP2_PRS_ENTRY *pe, int *shift);
+
+/*
+ * mvPp2PrsSwSramShiftAbsUpdate - set sram shift value according to initial offset
+ * @pe: sw prs entry
+ * @shift: get shift val
+ * shift value = @shift + inital value (store in reg 0x1004, 0x1008)
+*/
+int mvPp2PrsSwSramShiftAbsUpdate(MV_PP2_PRS_ENTRY *pe, int shift, unsigned int op);
+
+/*
+ * mvPp2PrsSwSramOffsetSet - set prs sram offset.
+ * @pe: sw prs entry
+ * @type: offset type
+ * @offset: signed offset value
+ * @op: offset operation
+*/
+int mvPp2PrsSwSramOffsetSet(MV_PP2_PRS_ENTRY *pe, unsigned int type, int offset, unsigned int op);
+
+/*
+ * mvPp2PrsSwSramOffsetGet - get prs sram offset.
+ * @pe: sw prs entry
+ * @type: get offset type
+ * @offset: get offset
+ * @op: get offset operation
+*/
+int mvPp2PrsSwSramOffsetGet(MV_PP2_PRS_ENTRY *pe, unsigned int *type, int *offset, unsigned int *op);
+
+/*
+ * mvPp2PrsSwSramLuDoneSet - set prs sram lookup done bit.
+ * @pe: sw prs entry
+*/
+int mvPp2PrsSwSramLuDoneSet(MV_PP2_PRS_ENTRY *pe);
+
+/*
+ * mvPp2PrsSwSramLuDoneClear - clear prs sram lookup done bit.
+ * @pe: sw prs entry
+*/
+int mvPp2PrsSwSramLuDoneClear(MV_PP2_PRS_ENTRY *pe);
+
+/*
+ * mvPp2PrsSwSramLuDoneGet - get prs sram lookup done bit.
+ * @pe: sw prs entry
+ * bit: get lookup done bit
+*/
+int mvPp2PrsSwSramLuDoneGet(MV_PP2_PRS_ENTRY *pe, unsigned int *bit);
+
+/*
+ * mvPp2PrsSwSramFlowidGenSet - set prs sram flowid gen bit.
+ * @pe: sw prs entry
+*/
+int mvPp2PrsSwSramFlowidGenSet(MV_PP2_PRS_ENTRY *pe);
+
+/*
+ * mvPp2PrsSwSramFlowidGenClear - clear prs sram flowid gen bit.
+ * @pe: sw prs entry
+*/
+int mvPp2PrsSwSramFlowidGenClear(MV_PP2_PRS_ENTRY *pe);
+
+/*
+ * mvPp2PrsSwSramFlowidGenGet - get prs sram flowid gen bit.
+ * @pe: sw prs entry
+ * bit: get lowid gen bit.
+*/
+int mvPp2PrsSwSramFlowidGenGet(MV_PP2_PRS_ENTRY *pe, unsigned int *bit);
+
+#endif /* __MV_PRS_HW_H__ */
-- 
1.7.5.4

