From 0be47a281e6e5c083a20d2633fb3fb968531c15e Mon Sep 17 00:00:00 2001
From: Kosta Zertsekel <konszert@marvell.com>
Date: Sun, 11 Aug 2013 17:32:35 +0300
Subject: [PATCH 0965/1825] pmu: alp: add Performance Monitor support for UP
 mode

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit da1c0da772f334393b210a170238980f38b0cf1e

Change-Id: I0826dc6d91beff93f6172a86b70d9c511000ff5d
Signed-off-by: Kosta Zertsekel <konszert@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/3073
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Eran Ben-Avi <benavi@marvell.com>
Tested-by: Eran Ben-Avi <benavi@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/Kconfig                            |    2 +-
 arch/arm/kernel/perf_event.c                |    2 +-
 arch/arm/mach-armada370/include/mach/irqs.h |    3 +
 arch/arm/mach-armadaxp/include/mach/irqs.h  |    4 +
 arch/arm/mach-avantalp/include/mach/irqs.h  |   33 +++--
 arch/arm/mach-avantalp/irq.c                |  240 +++++++++++++++++++++------
 arch/arm/plat-armada/pmu.c                  |    4 +-
 7 files changed, 219 insertions(+), 69 deletions(-)

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 540f341..4f0b8df 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -1299,7 +1299,7 @@ config XSCALE_PMU
 
 config CPU_HAS_PMU
 	depends on (CPU_V6 || CPU_V6K || CPU_V7 || XSCALE_PMU) && \
-		   (!ARCH_OMAP3 || OMAP3_EMU) && !ARCH_AVANTA_LP
+		   (!ARCH_OMAP3 || OMAP3_EMU)
 	default y
 	bool
 
diff --git a/arch/arm/kernel/perf_event.c b/arch/arm/kernel/perf_event.c
index bf32b5f..0bf4467 100644
--- a/arch/arm/kernel/perf_event.c
+++ b/arch/arm/kernel/perf_event.c
@@ -445,7 +445,7 @@ armpmu_reserve_hardware(struct arm_pmu *armpmu)
 
 		err = request_irq(irq, handle_irq,
 				IRQF_NOBALANCING | IRQF_SHARED,
-				"armpmu", handle_irq);
+				"armpmu", armpmu);
 		if (err) {
 			pr_err("unable to request IRQ%d for ARM PMU counters\n",
 				irq);
diff --git a/arch/arm/mach-armada370/include/mach/irqs.h b/arch/arm/mach-armada370/include/mach/irqs.h
index 8caadb9..e2c0037 100644
--- a/arch/arm/mach-armada370/include/mach/irqs.h
+++ b/arch/arm/mach-armada370/include/mach/irqs.h
@@ -150,4 +150,7 @@
 /* Interrupt Macros for backward compatibility */
 #define IRQ_USB_CTRL(x)			((x == 0) ? IRQ_AURORA_USB0 : IRQ_AURORA_USB1)
 
+/* Performance Monitor IRQ */
+#define IRQ_PERF_MONITOR		IRQ_AURORA_MP
+
 #endif
diff --git a/arch/arm/mach-armadaxp/include/mach/irqs.h b/arch/arm/mach-armadaxp/include/mach/irqs.h
index e77e8ac..c823f5d 100644
--- a/arch/arm/mach-armadaxp/include/mach/irqs.h
+++ b/arch/arm/mach-armadaxp/include/mach/irqs.h
@@ -168,4 +168,8 @@
 #define NET_TH_RXTX_IRQ_NUM(x)		(IRQ_AURORA_GBE0_FIC + ((x) * 2))
 #define SATA_IRQ_NUM			(IRQ_AURORA_SATA0)
 #define CESA_IRQ(chan)			IRQ_AURORA_CRYPTO(chan)
+
+/* Performance Monitor IRQ */
+#define IRQ_PERF_MONITOR		IRQ_AURORA_MP
+
 #endif
diff --git a/arch/arm/mach-avantalp/include/mach/irqs.h b/arch/arm/mach-avantalp/include/mach/irqs.h
index e0e698e..1f0d949 100644
--- a/arch/arm/mach-avantalp/include/mach/irqs.h
+++ b/arch/arm/mach-avantalp/include/mach/irqs.h
@@ -7,13 +7,13 @@
 #ifndef __ASM_ARCH_IRQS_H
 #define __ASM_ARCH_IRQS_H
 
-/*
+/*******************************************************************************
  * Software Generated Interrupts (SGI)
  */
 #define IRQ_SGI_0			0
 #define IRQ_SGI_15			15
 
-/*
+/*******************************************************************************
  * Private Peripheral Interrupts (PPI)
  */
 #define IRQ_PRIV_CPU_TIMER0		27
@@ -22,7 +22,7 @@
 #define IRQ_PRIV_CPU_LOCAL_WD		30
 #define IRQ_PRIV_MPIC_PPI_IRQ		31
 
-/*
+/*******************************************************************************
  * Shared Peripheral Interrupts (SPI)
  */
 #define IRQ_GLOBAL_SPI0			33
@@ -111,7 +111,7 @@
 
 #define IRQ_GLOBAL_DRAGONITE		118
 
-/*
+/*******************************************************************************
  * Global GPIO interrupts
  */
 #define IRQ_START_GLOBAL_GPIO		192
@@ -119,7 +119,7 @@
 #define IRQ_GLOBAL_GPIO(gpio_irq)	(gpio_irq >= NR_IRQS_GLOBAL_GPIO ? \
 			NR_IRQS_GLOBAL_GPIO : IRQ_START_GLOBAL_GPIO + gpio_irq)
 
-/*
+/*******************************************************************************
  * Global PCIe MSI interrupts
  */
 #define IRQ_START_GLOBAL_MSI		(IRQ_START_GLOBAL_GPIO + NR_IRQS_GLOBAL_GPIO)
@@ -127,7 +127,7 @@
 #define IRQ_GLOBAL_MSI(msi_irq)		(msi_irq >= NR_IRQS_GLOBAL_MSI ? \
 			NR_IRQS_GLOBAL_MSI : NR_IRQS_GLOBAL_MSI + msi_irq)
 
-/*
+/*******************************************************************************
  * SoC private interrupts
  */
 #define IRQ_START_PRIV_SOC_PPI		(IRQ_START_GLOBAL_MSI + NR_IRQS_GLOBAL_MSI)
@@ -154,7 +154,7 @@
 #define IRQ_PRIV_GPIO_56_63			(IRQ_START_PRIV_SOC_PPI + 23)
 #define IRQ_PRIV_GPIO_64_66			(IRQ_START_PRIV_SOC_PPI + 24)
 
-/*
+/*******************************************************************************
  * Private GPIO interrupts
  */
 #define IRQ_START_PRIV_GPIO	(IRQ_START_PRIV_SOC_PPI + NR_IRQS_PRIV_SOC_PPI)
@@ -162,7 +162,7 @@
 #define IRQ_PRIV_GPIO(gpio_irq)		(gpio_irq >= NR_IRQS_PRIV_GPIO ? \
 			NR_IRQS_PRIV_GPIO : IRQ_START_PRIV_GPIO + gpio_irq)
 
-/*
+/*******************************************************************************
  * Private PCIe MSI interrupts
  */
 #define IRQ_START_PRIV_MSI		(IRQ_START_PRIV_GPIO + NR_IRQS_PRIV_GPIO)
@@ -170,7 +170,7 @@
 #define IRQ_PRIV_MSI(msi_irq)		(msi_irq >= NR_IRQS_PRIV_MSI ? \
 			NR_IRQS_PRIV_MSI : IRQ_START_PRIV_MSI + msi_irq)
 
-/*
+/*******************************************************************************
  * Private SoC error interrupts
  */
 #define IRQ_START_PRIV_ERROR		(IRQ_START_PRIV_MSI + NR_IRQS_PRIV_MSI)
@@ -209,10 +209,21 @@
 #define IRQ_PRIV_ERROR_POLARITY_SCU0	(IRQ_START_PRIV_ERROR + 49)
 #define IRQ_PRIV_ERROR_POLARITY_SCU1	(IRQ_START_PRIV_ERROR + 50)
 
-/*
+/*******************************************************************************
+ * Private CPU local summary interrupts
+ */
+#define IRQ_START_PRIV_LOCAL_SUM	(IRQ_START_PRIV_ERROR + NR_IRQS_PRIV_ERROR)
+#define NR_IRQS_PRIV_LOCAL_SUM		1
+
+#define IRQ_PRIV_LOCAL_SUM_PERF_MONITOR (IRQ_START_PRIV_LOCAL_SUM + 0)
+
+/* Performance Monitor IRQ */
+#define IRQ_PERF_MONITOR		IRQ_PRIV_LOCAL_SUM_PERF_MONITOR
+
+/*******************************************************************************
  * Total number of interrupts
  */
-#define NR_IRQS			(IRQ_START_PRIV_ERROR + NR_IRQS_PRIV_ERROR)
+#define NR_IRQS			(IRQ_START_PRIV_LOCAL_SUM + NR_IRQS_PRIV_LOCAL_SUM)
 #define NR_GPIO_IRQS		NR_IRQS_GLOBAL_GPIO
 
 #endif /* __ASM_ARCH_IRQS_H */
diff --git a/arch/arm/mach-avantalp/irq.c b/arch/arm/mach-avantalp/irq.c
index bfd3a32..5341ae5 100644
--- a/arch/arm/mach-avantalp/irq.c
+++ b/arch/arm/mach-avantalp/irq.c
@@ -19,13 +19,23 @@
 #include "mvOs.h"
 #include "gpp/mvGppRegs.h"
 
+/* CPU-shared registers  */
+#define SOC_LOCAL_SUM_CAUSE		0x20260
+#define SOC_LOCAL_SUM_CAUSE_BITS	0xffc71111
+
+/*
+ * CPU-private registers
+ */
 #define SOC_PPI_CAUSE			0x21880
 #define SOC_PPI_MASK_SET		0x218b8
 #define SOC_PPI_MASK_CLEAR		0x218bc
+#define SOC_PPI_CAUSE_BITS		0x1fffffff
+
+#define SOC_LOCAL_SUM_MASK		0x218c4
 
 static DEFINE_RAW_SPINLOCK(irq_controller_lock);
 
-/*
+/*******************************************************************************
  * Global GPIO interrupt handling
  */
 static void alp_gpio_irq_mask(struct irq_data *d)
@@ -70,12 +80,11 @@ static struct irq_chip alp_irq_chip = {
 /*
  * gpio_cascade_irq is in [85:88] or [90:94]
  */
-static void alp_gpio_cascade_irq_handler(unsigned int gpio_cascade_irq,
+static void alp_gpio_cascade_irq_handler(u32 gpio_cascade_irq,
 					 struct irq_desc *desc)
 {
 	struct irq_chip *chip = irq_desc_get_chip(desc);
-	u32 bit, n, gpio_group, irq;
-	unsigned long cause, mask;
+	u32 bit, n, gpio_group, irq, cause, mask;
 
 	chained_irq_enter(chip, desc);
 
@@ -128,135 +137,258 @@ static void __init alp_cascade_irq_gpio_global(void)
 	irq_set_chained_handler(IRQ_GLOBAL_GPIO_64_66, alp_gpio_cascade_irq_handler);
 }
 
-/*
- * Handle SOC PPI (Private Peripheral Interrupts).
+/* Mask and Unmaks registers are the same in case of some interrupts.
+ * For example, Local Summary interrupts.
  */
-struct mpic_chip_regs {
-	unsigned long cause;
-	unsigned long mask;
-	unsigned long unmask;
+struct alp_irq_chip_regs {
+	u32 cause;
+	u32 mask;
+	u32 unmask;
 };
 
-struct mpic_data {
+struct alp_irq_chip_data {
 	int irq_base;
 	struct irq_domain *domain;
-	struct mpic_chip_regs regs;
+	struct alp_irq_chip_regs regs;
+	u32 mask;
 };
 
-static struct mpic_data mpic_data = {
+/*******************************************************************************
+ * CPU-private Local Summary interrupts
+ */
+static struct alp_irq_chip_data alp_local_summary_chip_data = {
+	.regs = {
+		.cause	= INTER_REGS_VIRT_BASE + SOC_LOCAL_SUM_CAUSE,
+		.mask	= INTER_REGS_VIRT_BASE + SOC_LOCAL_SUM_MASK,
+		.unmask	= INTER_REGS_VIRT_BASE + SOC_LOCAL_SUM_MASK,
+	},
+	.mask = SOC_LOCAL_SUM_CAUSE_BITS,
+};
+
+static void alp_local_summary_irq_mask(struct irq_data *d)
+{
+	u32 mask;
+	struct alp_irq_chip_data *chd = irq_get_chip_data(d->irq);
+
+	/* To mask IRQ, set its bit to zero. */
+	raw_spin_lock(&irq_controller_lock);
+	mask = readl_relaxed(chd->regs.mask);
+	mask &= ~(1 << d->hwirq);
+	writel_relaxed(mask, chd->regs.mask);
+	raw_spin_unlock(&irq_controller_lock);
+}
+
+static void alp_local_summary_irq_unmask(struct irq_data *d)
+{
+	u32 mask;
+	struct alp_irq_chip_data *chd = irq_get_chip_data(d->irq);
+
+	/* To unmask IRQ, set its bit to one. */
+	raw_spin_lock(&irq_controller_lock);
+	mask = readl_relaxed(chd->regs.unmask);
+	mask |= (1 << d->hwirq);
+	writel_relaxed(mask, chd->regs.unmask);
+	raw_spin_unlock(&irq_controller_lock);
+}
+
+
+static struct irq_chip alp_local_summary_irq_chip = {
+	.irq_mask	= alp_local_summary_irq_mask,
+	.irq_unmask	= alp_local_summary_irq_unmask,
+};
+
+static void
+alp_handle_cascade_irq_local_summary(u32 irq, struct irq_desc *desc)
+{
+	struct alp_irq_chip_data *chd = &alp_local_summary_chip_data;
+	u32 cause, virt_irq;
+
+	chained_irq_enter(irq_get_chip(irq), desc);
+
+	raw_spin_lock(&irq_controller_lock);
+	cause = readl_relaxed(chd->regs.cause);
+	raw_spin_unlock(&irq_controller_lock);
+
+	/* leave only relevant cause bits */
+	cause &= chd->mask;
+	if (cause == 0) {
+		pr_warn("%s: Zero interrupt cause reg 0x%08x\n",
+			__func__, chd->regs.cause);
+		goto out; /* spurious irq ? */
+	}
+
+	virt_irq = ffs(cause) - 1 + chd->irq_base;
+	generic_handle_irq(virt_irq);
+
+ out:
+	chained_irq_exit(irq_get_chip(irq), desc);
+}
+
+static int
+alp_local_sumary_irq_domain_map(struct irq_domain *d, u32 irq,
+				irq_hw_number_t hwirq)
+{
+	irq_set_chip_and_handler(irq,
+		&alp_local_summary_irq_chip, handle_percpu_devid_irq);
+	irq_set_chip_data(irq, d->host_data);
+	set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
+	return 0;
+}
+
+static struct irq_domain_ops alp_local_summary_irq_domain_ops = {
+	.map	= alp_local_sumary_irq_domain_map,
+};
+
+static void __init
+alp_cascade_irq_local_summary(int chained_irq, int irq, int nr_irqs)
+{
+	struct alp_irq_chip_data *chd = &alp_local_summary_chip_data;
+
+	chd->irq_base = irq_alloc_descs(-1, irq, nr_irqs, 0);
+	if (IS_ERR_VALUE(chd->irq_base))
+		BUG();
+
+	chd->domain = irq_domain_add_legacy(NULL, nr_irqs, chd->irq_base,
+				    0, &alp_local_summary_irq_domain_ops, chd);
+	WARN_ON(!chd->domain);
+	irq_set_chained_handler(chained_irq, alp_handle_cascade_irq_local_summary);
+}
+
+/*******************************************************************************
+ * CPU-private Peripherals interrupts (PPI)
+ */
+static struct alp_irq_chip_data alp_ppi_chip_data = {
 	.regs = {
 		.cause	= INTER_REGS_VIRT_BASE + SOC_PPI_CAUSE,
 		.mask	= INTER_REGS_VIRT_BASE + SOC_PPI_MASK_SET,
 		.unmask	= INTER_REGS_VIRT_BASE + SOC_PPI_MASK_CLEAR,
-	}
+	},
+	.mask = SOC_PPI_CAUSE_BITS,
 };
 
-static void mpic_irq_mask(struct irq_data *d)
+static void alp_ppi_irq_mask(struct irq_data *d)
 {
-	struct mpic_data *mpic = irq_get_chip_data(d->irq);
+	struct alp_irq_chip_data *chd = irq_get_chip_data(d->irq);
 
 	raw_spin_lock(&irq_controller_lock);
-	writel_relaxed(d->hwirq, mpic->regs.mask);
+	writel_relaxed(d->hwirq, chd->regs.mask);
 	raw_spin_unlock(&irq_controller_lock);
 }
 
-static void mpic_irq_unmask(struct irq_data *d)
+static void alp_ppi_irq_unmask(struct irq_data *d)
 {
-	struct mpic_data *mpic = irq_get_chip_data(d->irq);
+	struct alp_irq_chip_data *chd = irq_get_chip_data(d->irq);
 
 	raw_spin_lock(&irq_controller_lock);
-	writel_relaxed(d->hwirq, mpic->regs.unmask);
+	writel_relaxed(d->hwirq, chd->regs.unmask);
 	raw_spin_unlock(&irq_controller_lock);
 }
 
-static struct irq_chip mpic_chip = {
-	.irq_mask	= mpic_irq_mask,
-	.irq_unmask	= mpic_irq_unmask,
+static struct irq_chip alp_ppi_irq_chip = {
+	.irq_mask	= alp_ppi_irq_mask,
+	.irq_unmask	= alp_ppi_irq_unmask,
 };
 
-static void mpic_handle_cascade_irq(unsigned int irq, struct irq_desc *desc)
+static void alp_ppi_handle_cascade_irq(u32 irq, struct irq_desc *desc)
 {
-	struct mpic_data *mpic = irq_get_handler_data(irq);
-	struct irq_chip *chip = irq_get_chip(irq);
-	unsigned long cause;
+	struct alp_irq_chip_data *chd = &alp_ppi_chip_data;
+	u32 cause, virt_irq;
 
-	chained_irq_enter(chip, desc);
+	chained_irq_enter(irq_get_chip(irq), desc);
 
 	raw_spin_lock(&irq_controller_lock);
-	cause = readl_relaxed(mpic->regs.cause);
+	cause = readl_relaxed(chd->regs.cause);
 	raw_spin_unlock(&irq_controller_lock);
 
 	/* leave only relevant cause bits */
-	cause &= 0x3ff;
-	if (cause == 0)
+	cause &= chd->mask;
+	if (cause == 0) {
+		pr_warn("%s: Zero interrupt cause reg 0x%08x\n",
+			__func__, chd->regs.cause);
 		goto out; /* spurious irq ? */
+	}
 
-	irq = ffs(cause) - 1;
-	generic_handle_irq(mpic->irq_base + irq);
+	virt_irq = ffs(cause) - 1 + chd->irq_base;
+	generic_handle_irq(virt_irq);
 
  out:
-	chained_irq_exit(chip, desc);
+	chained_irq_exit(irq_get_chip(irq), desc);
 }
 
-static int mpic_irq_domain_map(struct irq_domain *d, unsigned int irq,
-			       irq_hw_number_t hwirq)
+static int
+alp_ppi_irq_domain_map(struct irq_domain *d, u32 irq, irq_hw_number_t hwirq)
 {
-	irq_set_percpu_devid(irq);
-	irq_set_chip_and_handler(irq, &mpic_chip, handle_percpu_devid_irq);
+	irq_set_chip_and_handler(irq, &alp_ppi_irq_chip, handle_percpu_devid_irq);
 	irq_set_chip_data(irq, d->host_data);
 	set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
-
 	return 0;
 }
 
-static struct irq_domain_ops mpic_irq_domain_ops = {
-	.map	= mpic_irq_domain_map,
+static struct irq_domain_ops alp_ppi_irq_domain_ops = {
+	.map	= alp_ppi_irq_domain_map,
 };
 
-static void __init alp_cascade_irq_mpic(int irq, int nr_irqs)
+static void __init
+alp_cascade_irq_ppi(int chained_irq, int irq, int nr_irqs)
 {
-	struct mpic_data *mpic = &mpic_data;
+	struct alp_irq_chip_data *chd = &alp_ppi_chip_data;
 
-	mpic->irq_base = irq_alloc_descs(-1, irq, nr_irqs, 0);
-	if (IS_ERR_VALUE(mpic->irq_base))
+	chd->irq_base = irq_alloc_descs(-1, irq, nr_irqs, 0);
+	if (IS_ERR_VALUE(chd->irq_base))
 		BUG();
 
-	mpic->domain = irq_domain_add_legacy(NULL, nr_irqs, mpic->irq_base,
-					     0, &mpic_irq_domain_ops, mpic);
-	WARN_ON(!mpic->domain);
-	irq_set_chained_handler(irq, mpic_handle_cascade_irq);
+	chd->domain = irq_domain_add_legacy(NULL, nr_irqs, chd->irq_base,
+					    0, &alp_ppi_irq_domain_ops, chd);
+	WARN_ON(!chd->domain);
+	irq_set_chained_handler(chained_irq, alp_ppi_handle_cascade_irq);
+
+	alp_cascade_irq_local_summary(IRQ_PRIV_MP_LOCAL_SUMMARY,
+			      IRQ_START_PRIV_LOCAL_SUM, NR_IRQS_PRIV_LOCAL_SUM);
 }
 
+/*******************************************************************************
+ * CPU-private GPIO interrupts
+ */
 static void __init alp_cascade_irq_gpio_private(void)
 {
 	/* TBD */
 }
 
+/*******************************************************************************
+ * Global MSI interrupts
+ */
 static void __init alp_cascade_irq_msi_global(void)
 {
 	/* TBD */
 }
 
+/*******************************************************************************
+ * CPU-private MSI interrupts
+ */
 static void __init alp_cascade_irq_msi_private(void)
 {
 	/* TBD */
 }
 
+/*******************************************************************************
+ * CPU-private error interrupts
+ */
 static void __init alp_cascade_irq_errors(void)
 {
 	/* TBD */
 }
 
-/*
+/*******************************************************************************
  * Init GIC and MPIC and setup cascade irq
- * handling for GPIO, MSI and Error interrupts.
+ * handling for Local Summary, GPIO, MSI and Error interrupts.
  */
 void __init alp_irq_init(void)
 {
-	gic_init(0, 29, (void __iomem*)(INTER_REGS_VIRT_BASE + A9_MPCORE_GIC_DIST),
-			(void __iomem*)(INTER_REGS_VIRT_BASE + A9_MPCORE_GIC_CPU));
+	gic_init(0, 29, (void __iomem *)(INTER_REGS_VIRT_BASE + A9_MPCORE_GIC_DIST),
+			(void __iomem *)(INTER_REGS_VIRT_BASE + A9_MPCORE_GIC_CPU));
 
-	alp_cascade_irq_mpic(IRQ_START_PRIV_SOC_PPI, NR_IRQS_PRIV_SOC_PPI);
+	alp_cascade_irq_ppi(IRQ_PRIV_MPIC_PPI_IRQ,
+			    IRQ_START_PRIV_SOC_PPI, NR_IRQS_PRIV_SOC_PPI);
 
 	alp_cascade_irq_gpio_global();
 	alp_cascade_irq_gpio_private();
diff --git a/arch/arm/plat-armada/pmu.c b/arch/arm/plat-armada/pmu.c
index a9fabb7..f4812b1 100644
--- a/arch/arm/plat-armada/pmu.c
+++ b/arch/arm/plat-armada/pmu.c
@@ -12,8 +12,8 @@
 #include <mach/irqs.h>
 
 static struct resource pmu_resource = {
-	.start	= IRQ_AURORA_MP,
-	.end	= IRQ_AURORA_MP,
+	.start	= IRQ_PERF_MONITOR,
+	.end	= IRQ_PERF_MONITOR,
 	.flags	= IORESOURCE_IRQ,
 };
 
-- 
1.7.5.4

