From c8b8955689ea555cc5a26faa0c608b036dc5905f Mon Sep 17 00:00:00 2001
From: Omri Itach <omrii@marvell.com>
Date: Tue, 9 Apr 2013 16:04:33 +0300
Subject: [PATCH 0559/1825] ALP: Debug & error prints added +code cleanup

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 2da8d3265747aca28024f4c7232e5c66598126df

Change-Id: I839191d05d0ea19c8a72149713303b7cf92b2868
Reviewed-on: http://vgitil04.il.marvell.com:8080/1515
Reviewed-by: Eran Ben-Avi <benavi@marvell.com>
Tested-by: Eran Ben-Avi <benavi@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../avanta_lp_family/boardEnv/mvBoardEnvLib.c      |  115 ++++++++------
 .../avanta_lp_family/boardEnv/mvBoardEnvLib.h      |   18 +-
 .../avanta_lp_family/boardEnv/mvBoardEnvSpec.c     |    4 +-
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c        |  165 +++++++++++---------
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h        |    2 +-
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvRegs.h       |    6 +-
 .../avanta_lp_family/ctrlEnv/sys/mvCpuIfRegs.h     |    4 +-
 7 files changed, 177 insertions(+), 137 deletions(-)

diff --git a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
index 9903325..06939ec 100755
--- a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
@@ -91,7 +91,7 @@
 #endif
 
 extern MV_BOARD_INFO *boardInfoTbl[];
-extern MV_BOARD_SAR_INFO boardSarInfo[];
+extern MV_BOARD_SATR_INFO boardSatrInfo[];
 extern MV_BOARD_CONFIG_TYPE_INFO boardConfigTypesInfo[];
 
 /* Locals */
@@ -307,8 +307,10 @@ MV_32 mvBoardPhyAddrGet(MV_U32 ethPortNum)
 	return 8;
 #endif
 
-	if (ethPortNum >= board->numBoardMacInfo)
+	if (ethPortNum >= board->numBoardMacInfo) {
+		DB(mvOsPrintf("%s: Error: invalid ethPortNum (%d)\n", __func__, ethPortNum));
 		return MV_ERROR;
+	}
 
 	return board->pBoardMacInfo[ethPortNum].boardEthSmiAddr;
 }
@@ -542,7 +544,18 @@ MV_32 mvBoarGpioPinNumGet(MV_BOARD_GPP_CLASS gppClass, MV_U32 index)
 *******************************************************************************/
 MV_VOID mvBoardReset(MV_VOID)
 {
-	/* empty */
+	MV_32 resetPin;
+
+	/* Get gpp reset pin if define */
+	resetPin = mvBoardResetGpioPinGet();
+	if (resetPin != MV_ERROR)
+		MV_REG_BIT_RESET(GPP_DATA_OUT_REG((int)(resetPin/32)), (1 << (resetPin % 32)));
+	else
+	{
+		/* No gpp reset pin was found, try to reset using system reset out */
+		MV_REG_BIT_SET( CPU_RSTOUTN_MASK_REG , BIT0);
+		MV_REG_BIT_SET( CPU_SYS_SOFT_RST_REG , BIT0);
+	}
 }
 
 /*******************************************************************************
@@ -807,7 +820,7 @@ MV_VOID mvBoardConfigInit(void)
 *	   Or   groups 3-4 for SPI1 Boot
 *	- return Selected boot device
 *
-* INPUT:  sarBootDevice - BOOT_DEVICE value from S@R.
+* INPUT:
 *
 * OUTPUT:  None.
 *
@@ -863,7 +876,7 @@ MV_BOARD_BOOT_SRC mvBoardBootDeviceGroupSet()
 * DESCRIPTION:
 *   read board BOOT configuration from S@R and return Boot device accordingly
 *
-* INPUT:  sarBootDevice - BOOT_DEVICE value from S@R.
+* INPUT:
 *
 * OUTPUT:  None.
 *
@@ -873,15 +886,15 @@ MV_BOARD_BOOT_SRC mvBoardBootDeviceGroupSet()
 *******************************************************************************/
 MV_BOARD_BOOT_SRC mvBoardBootDeviceGet()
 {
-	MV_U32 sarBootDeviceValue = mvCtrlSatRRead(MV_SATR_BOOT_DEVICE);
-	MV_SAR_BOOT_TABLE sarTable[] = MV_SAR_TABLE_VAL;
-	MV_SAR_BOOT_TABLE sarBootEntry = sarTable[sarBootDeviceValue];
+	MV_U32 satrBootDeviceValue = mvCtrlSatRRead(MV_SATR_BOOT_DEVICE);
+	MV_SATR_BOOT_TABLE satrTable[] = MV_SATR_TABLE_VAL;
+	MV_SATR_BOOT_TABLE satrBootEntry = satrTable[satrBootDeviceValue];
 
-	if (sarBootEntry.bootSrc != MSAR_0_BOOT_SPI_FLASH)
-		return sarBootEntry.bootSrc;
+	if (satrBootEntry.bootSrc != MSAR_0_BOOT_SPI_FLASH)
+		return satrBootEntry.bootSrc;
 
 	/* if boot source is SPI ,verify which CS (0/1) */
-	if (mvBoardBootAttrGet(sarBootDeviceValue, 1) == MSAR_0_SPI0)
+	if (mvBoardBootAttrGet(satrBootDeviceValue, 1) == MSAR_0_SPI0)
 		return MSAR_0_BOOT_SPI_FLASH;
 	else
 		return MSAR_0_BOOT_SPI1_FLASH;
@@ -893,7 +906,7 @@ MV_BOARD_BOOT_SRC mvBoardBootDeviceGet()
 * DESCRIPTION:
 *   read board BOOT configuration and return attributes accordingly
 *
-* INPUT:  sarBootDevice - BOOT_DEVICE value from S@R.*
+* INPUT:  satrBootDevice - BOOT_DEVICE value from S@R.*
 *         attrNum - attribute number [1/2/3]
 * OUTPUT:  None.
 *
@@ -901,20 +914,20 @@ MV_BOARD_BOOT_SRC mvBoardBootDeviceGet()
 *       the selected attribute value
 *
 *******************************************************************************/
-MV_U32 mvBoardBootAttrGet(MV_U32 sarBootDeviceValue, MV_U8 attrNum)
+MV_U32 mvBoardBootAttrGet(MV_U32 satrBootDeviceValue, MV_U8 attrNum)
 {
-	MV_SAR_BOOT_TABLE sarTable[] = MV_SAR_TABLE_VAL;
-	MV_SAR_BOOT_TABLE sarBootEntry = sarTable[sarBootDeviceValue];
+	MV_SATR_BOOT_TABLE satrTable[] = MV_SATR_TABLE_VAL;
+	MV_SATR_BOOT_TABLE satrBootEntry = satrTable[satrBootDeviceValue];
 
 	switch (attrNum) {
 	case 1:
-		return sarBootEntry.attr1;
+		return satrBootEntry.attr1;
 		break;
 	case 2:
-		return sarBootEntry.attr2;
+		return satrBootEntry.attr2;
 		break;
 	case 3:
-		return sarBootEntry.attr3;
+		return satrBootEntry.attr3;
 		break;
 	default:
 		return MV_ERROR;
@@ -1620,17 +1633,17 @@ MV_U32 boardGetDevCSNum(MV_32 devNum, MV_BOARD_DEV_CLASS devClass)
 *       MV_U8  :return requested value , if TWSI read was succesfull, else 0xFF.
 *
 *******************************************************************************/
-MV_U8 mvBoardIoExpValGet(MV_BOARD_IO_EXPANDER_TYPE_INFO ioInfo)
+MV_U8 mvBoardIoExpValGet(MV_BOARD_IO_EXPANDER_TYPE_INFO *ioInfo)
 {
-	MV_U8 tempVal, mask;
+	MV_U8 val, mask;
 
-	tempVal = mvBoardTwsiGet(BOARD_DEV_TWSI_IO_EXPANDER, ioInfo.expanderNum, ioInfo.regNum);
-	if ((MV_8)MV_ERROR != (MV_8)tempVal) {
-		mask = (1 << ioInfo.offset);
-		return ( (tempVal & mask) >> ioInfo.offset);
+	val = mvBoardTwsiGet(BOARD_DEV_TWSI_IO_EXPANDER, ioInfo->expanderNum, ioInfo->regNum);
+	if ((MV_U8)MV_ERROR != val) {
+		mask = (1 << ioInfo->offset);
+		return ( (val & mask) >> ioInfo->offset);
 	}
-	else
-		return 0xFF;
+	DB(mvOsPrintf("%s: Error: Read from IO Expander failed\n", __func__));
+	return 0xFF;
 }
 
 /*******************************************************************************
@@ -1664,7 +1677,7 @@ MV_U8 mvBoardTwsiAddrTypeGet(MV_BOARD_TWSI_CLASS twsiClass, MV_U32 index)
 				indexFound++;
 		}
 	}
-
+	DB(mvOsPrintf("%s: Error: read TWSI address type failed\n", __func__));
 	return MV_ERROR;
 }
 
@@ -1747,37 +1760,37 @@ MV_VOID mvBoardEthComplexConfigSet(MV_U32 ethConfig)
 }
 
 /*******************************************************************************
-* mvBoardSarInfoGet
+* mvBoardSatrInfoGet
 *
 * DESCRIPTION:
 *	Return the SAR fields information for a given SAR class.
 *
 * INPUT:
-*	sarClass - The SAR field to return the information for.
+*	satrClass - The SATR field to return the information for.
 *
 * OUTPUT:
 *       None.
 *
 * RETURN:
-*	MV_BOARD_SAR_INFO struct with mask, offset and register number.
+*	MV_BOARD_SATR_INFO struct with mask, offset and register number.
 *
 *******************************************************************************/
-MV_STATUS mvBoardSarInfoGet(MV_SATR_TYPE_ID sarClass, MV_BOARD_SAR_INFO *sarInfo)
+MV_STATUS mvBoardSatrInfoGet(MV_SATR_TYPE_ID satrClass, MV_BOARD_SATR_INFO *satrInfo)
 {
 	int i;
 	MV_U32 boardId = mvBoardIdGet();
 
-	if (sarInfo == NULL )
-		return MV_ERROR;
-
 	/* verify existence of requested SATR type, pull its data,
 	 * and check if field is relevant to current running board */
 	for (i = 0; i < MV_SATR_READ_MAX_OPTION ; i++)
-		if (boardSarInfo[i].sarid == sarClass) {
-			*sarInfo = boardSarInfo[i];
-			if (boardSarInfo[i].isActiveForBoard[boardId])
+		if (boardSatrInfo[i].satrId == satrClass) {
+			satrInfo = &boardSatrInfo[i];
+			if (boardSatrInfo[i].isActiveForBoard[boardId])
 				return MV_OK;
+			else
+				return MV_ERROR;
 		}
+	DB(mvOsPrintf("%s: Error: requested MV_SATR_TYPE_ID was not found (%d)\n", __func__,satrClass));
 	return MV_ERROR;
 }
 
@@ -1805,11 +1818,14 @@ MV_STATUS mvBoardConfigTypeGet(MV_CONFIG_TYPE_ID configClass, MV_BOARD_CONFIG_TY
 	/* verify existence of requested config type, pull its data,
 	 * and check if field is relevant to current running board */
 	for (i = 0; i < MV_CONFIG_TYPE_MAX_OPTION ; i++)
-		if (boardConfigTypesInfo[i].configid == configClass) {
-			*configInfo = boardConfigTypesInfo[i];
+		if (boardConfigTypesInfo[i].configId == configClass) {
+			configInfo = &boardConfigTypesInfo[i];
 			if (boardConfigTypesInfo[i].isActiveForBoard[boardId])
 				return MV_OK;
+			else
+				return MV_ERROR;
 		}
+	DB(mvOsPrintf("%s: Error: requested MV_CONFIG_TYPE_ID was not found (%d) \n", __func__, configClass));
 	return MV_ERROR;
 }
 
@@ -1836,9 +1852,10 @@ MV_STATUS mvBoardIoExpanderTypeGet(MV_IO_EXPANDER_TYPE_ID ioClass, MV_BOARD_IO_E
 	/* verify existance of requested config type, pull its data */
 	for (i = 0; i < board->numBoardIoExpanderInfo ; i++)
 		if (board->pBoardIoExpanderInfo[i].ioFieldid == ioClass) {
-			*ioInfo = board->pBoardIoExpanderInfo[i];
+			ioInfo = &board->pBoardIoExpanderInfo[i];
 			return MV_OK;
 		}
+	DB(mvOsPrintf("%s: Error: requested MV_IO_EXPANDER_TYPE_ID was not found\n", __func__));
 	return MV_ERROR;
 }
 
@@ -1867,7 +1884,7 @@ MV_32 mvBoardNandWidthGet(void)
 			return devWidth / 8;
 	}
 
-	/* NAND wasn't found */
+	DB(mvOsPrintf("%s: Error: NAND device was not found\n", __func__));
 	return MV_ERROR;
 }
 
@@ -1917,13 +1934,13 @@ MV_VOID mvBoardIdSet(MV_U32 boardId)
 *******************************************************************************/
 MV_U32 mvBoardIdGet(MV_VOID)
 {
-	MV_U32 boardId, tempVal;
+	MV_U32 boardId, value;
 
 #ifdef CONFIG_MACH_AVANTA_LP_FPGA
 	boardId = MV_BOARD_ID_AVANTA_LP_FPGA;
 #else
-	tempVal = MV_REG_READ(MPP_SAMPLE_AT_RESET(1));
-	boardId = ((tempVal & (0xF0)) >> 4);
+	value = MV_REG_READ(MPP_SAMPLE_AT_RESET(1));
+	boardId = ((value & (0xF0)) >> 4);
 #endif
 	if (boardId >= MV_MAX_BOARD_ID) {
 		mvOsPrintf("%s: Error: read wrong board (%d)\n", __func__, boardId);
@@ -2016,10 +2033,10 @@ MV_STATUS mvBoardTwsiSet(MV_BOARD_TWSI_CLASS twsiClass, MV_U8 devNum, MV_U8 regN
 	twsiSlave.offset = regNum;
 	twsiSlave.moreThen256 = MV_FALSE;
 	if (MV_OK != mvTwsiWrite(0, &twsiSlave, &regVal, 1)) {
-		DB(mvOsPrintf("Board: Write S@R fail\n"));
+		DB(mvOsPrintf("%s: Write S@R fail\n" __func__));
 		return MV_ERROR;
 	}
-	DB(mvOsPrintf("Board: Write S@R succeded\n"));
+	DB(mvOsPrintf("%s: Write S@R succeded\n" __func__));
 
 	return MV_OK;
 }
@@ -2511,7 +2528,7 @@ MV_BOARD_PEX_INFO *mvBoardPexInfoGet(void)
 }
 
 /*******************************************************************************
-* mvBoardModuleAutoDetectEnabled
+* mvBoardConfigAutoDetectEnabled
 *
 * DESCRIPTION:
 *	Indicate if the board supports auto configuration and detection of
@@ -2528,7 +2545,7 @@ MV_BOARD_PEX_INFO *mvBoardPexInfoGet(void)
 *	MV_FALSE otherwise.
 *
 *******************************************************************************/
-MV_BOOL mvBoardModuleAutoDetectEnabled()
+MV_BOOL mvBoardConfigAutoDetectEnabled()
 {
-	return board->moduleAutoDetect;
+	return board->configAutoDetect;
 }
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h
index e0945bd..d5f1101 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h
@@ -209,16 +209,16 @@ typedef struct _boardTwsiInfo {
 	MV_U8 twsiDevAddrType;
 } MV_BOARD_TWSI_INFO;
 
-typedef struct _boardSarInfo {
-	MV_SATR_TYPE_ID sarid;
+typedef struct _boardSatrInfo {
+	MV_SATR_TYPE_ID satrId;
 	MV_U32 mask;
 	MV_U32 offset;
 	MV_U32 regNum;
 	MV_U32 isActiveForBoard[MV_MAX_BOARD_ID];
-} MV_BOARD_SAR_INFO;
+} MV_BOARD_SATR_INFO;
 
 typedef struct _boardConfigTypesInfo {
-	MV_CONFIG_TYPE_ID configid;
+	MV_CONFIG_TYPE_ID configId;
 	MV_U32 mask;
 	MV_U32 offset;
 	MV_U32 expanderNum;
@@ -368,7 +368,7 @@ typedef struct _boardInfo {
 
 	/* Indicates if auto-detection of modules is enabled on this board. */
 	/* Set to MV_FALSE for any board that is not a DB. */
-	MV_BOOL moduleAutoDetect;
+	MV_BOOL configAutoDetect;
 } MV_BOARD_INFO;
 
 /* Boot device bus width */
@@ -408,8 +408,8 @@ MV_BOOL mvBoardIsPortInGmii(MV_U32 ethPortNum);
 MV_32 mvBoardSwitchPortMap(MV_U32 switchIdx, MV_U32 switchPortNum);
 MV_BOOL mvBoardIsPortLoopback(MV_U32 ethPortNum);
 MV_32 mvBoardPhyAddrGet(MV_U32 ethPortNum);
-MV_U8 mvBoardIoExpValGet(MV_BOARD_IO_EXPANDER_TYPE_INFO ioInfo);
-MV_STATUS mvBoardSarInfoGet(MV_SATR_TYPE_ID sarClass, MV_BOARD_SAR_INFO *sarInfo);
+MV_U8 mvBoardIoExpValGet(MV_BOARD_IO_EXPANDER_TYPE_INFO *ioInfo);
+MV_STATUS mvBoardSatrInfoGet(MV_SATR_TYPE_ID satrClass, MV_BOARD_SATR_INFO *satrInfo);
 MV_STATUS mvBoardConfigTypeGet(MV_CONFIG_TYPE_ID configClass, MV_BOARD_CONFIG_TYPE_INFO *configInfo);
 MV_STATUS mvBoardIoExpanderTypeGet(MV_IO_EXPANDER_TYPE_ID ioClass, MV_BOARD_IO_EXPANDER_TYPE_INFO *ioInfo);
 MV_U32 mvBoardTclkGet(MV_VOID);
@@ -456,7 +456,7 @@ MV_ETH_COMPLEX_TOPOLOGY mvBoardMac1ConfigGet(MV_VOID);
 MV_ETH_COMPLEX_TOPOLOGY mvBoardLaneSGMIIGet(MV_VOID);
 MV_BOARD_BOOT_SRC mvBoardBootDeviceGroupSet(MV_VOID);
 MV_BOARD_BOOT_SRC mvBoardBootDeviceGet(MV_VOID);
-MV_U32 mvBoardBootAttrGet(MV_U32 sarBootDeviceValue, MV_U8 attrNum);
+MV_U32 mvBoardBootAttrGet(MV_U32 satrBootDeviceValue, MV_U8 attrNum);
 MV_U8 mvBoardTwsiGet(MV_BOARD_TWSI_CLASS twsiClass, MV_U8 devNum, MV_U8 regNum);
 MV_STATUS mvBoardTwsiSet(MV_BOARD_TWSI_CLASS twsiClass, MV_U8 devNum, MV_U8 regNum, MV_U8 regVal);
 MV_U8 mvBoardCpuFreqGet(MV_VOID);
@@ -485,7 +485,7 @@ MV_32 mvBoardSwitchCpuPortGet(MV_U32 switchIdx);
 MV_32 mvBoardSwitchIrqGet(MV_VOID);
 MV_32 mvBoardSwitchConnectedPortGet(MV_U32 ethPort);
 MV_8 mvBoardSwitchPortsMaskGet(MV_U32 switchIdx);
-MV_BOOL mvBoardModuleAutoDetectEnabled(void);
+MV_BOOL mvBoardConfigAutoDetectEnabled(void);
 MV_32 mvBoardSmiScanModeGet(MV_U32 switchIdx);
 MV_BOARD_PEX_INFO *mvBoardPexInfoGet(void);
 MV_STATUS mvBoardConfIdSet(MV_U16 conf);
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.c b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.c
index 9a49875..5dbfd39 100755
--- a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.c
@@ -69,7 +69,7 @@
 
 #define ARRSZ(x)                (sizeof(x) / sizeof(x[0]))
 
-MV_BOARD_SAR_INFO boardSarInfo[] = {
+MV_BOARD_SATR_INFO boardSatrInfo[] = {
 /* {	{MV_SATR_TYPE_ID SarID,		MV_U32 Mask,   	      Offset, regNum , 	       isActiveForBoard[]}} */
 	{ MV_SATR_CPU_DDR_L2_FREQ,		 0x003E0000,	  17,	       1, {1,0,0,0} },
 	{ MV_SATR_CORE_CLK_SELECT,	 0x00400000,	  22,	       1, {1,0,0,0} },
@@ -324,7 +324,7 @@ MV_BOARD_INFO db88f6660_board_info = {
 	.norFlashReadParams		= 0,
 	.norFlashWriteParams		= 0,
 	/* Enable modules auto-detection. */
-	.moduleAutoDetect		= MV_TRUE
+	.configAutoDetect		= MV_TRUE
 };
 
 /*******************************************************************************
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
index 6dd4e77..143f81d 100755
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
@@ -174,9 +174,16 @@ MV_STATUS mvCtrlEnvInit(MV_VOID)
 {
 	MV_U32 i, gppMask;
 
-	/* If set to Auto Detect modules, read S@R and board config info, to build Eth-Complex config & MPP group types */
-	if (mvBoardModuleAutoDetectEnabled())
+	/* If set to Auto detect board config, read S@R and board config info, to build Eth-Complex config & MPP group types */
+	if (mvBoardConfigAutoDetectEnabled())
+	{
 		mvBoardConfigInit();
+		/* split mvBoardConfigInit to
+			 * mvBoardMppIdUpdate
+			 * mvBoardSwitchInfoUpdate
+		 * rest_of_board_info_update */
+	}
+
 
 	/* write MPP's config and Board general config */
 	mvBoardConfigWrite();
@@ -220,38 +227,40 @@ MV_STATUS mvCtrlEnvInit(MV_VOID)
 *******************************************************************************/
 MV_STATUS mvCtrlSatRWrite(MV_SATR_TYPE_ID satrWriteField, MV_SATR_TYPE_ID satrReadField, MV_U8 val)
 {
-	MV_BOARD_SAR_INFO sarInfo;
-	MV_U32 readVal, tmpVal;
-
-	if ((satrReadField < MV_SATR_READ_MAX_OPTION) && (satrWriteField < MV_SATR_WRITE_MAX_OPTION)) {
-		if ( mvBoardSarInfoGet(satrWriteField, &sarInfo)) {
-
-			/* read */
-			readVal = mvBoardTwsiGet(BOARD_DEV_TWSI_SATR, sarInfo.regNum, 0);
-			if ((MV_U8)readVal == (MV_U8)MV_ERROR)
-				return MV_ERROR;
-
-			/* modify */
-			readVal &= !(sarInfo.mask);             /* clean old value */
-			readVal &= (val <<  sarInfo.offset);    /* save new value */
-
-			/* write */
-			tmpVal = mvBoardTwsiSet(BOARD_DEV_TWSI_SATR, sarInfo.regNum, 0, readVal);
-			if ((MV_U8)tmpVal == (MV_U8)MV_ERROR)
-				return MV_ERROR;
-
-			/* verify */
-			tmpVal = mvBoardTwsiGet(BOARD_DEV_TWSI_SATR, sarInfo.regNum, 0);
-			if (tmpVal != readVal)
-				return MV_ERROR;
-
-			/*else save written value in global array */
-			satrOptionsConfig[satrReadField] = readVal;
-			return MV_OK;
-		}else
-			printf("%s: Error: Requested S@R config is not relevant for the current board\n", __func__);
+	MV_BOARD_SATR_INFO *satrInfo = NULL;
+	MV_U8 readVal;
+
+	if (satrReadField >= MV_SATR_READ_MAX_OPTION ||
+		satrWriteField >= MV_SATR_WRITE_MAX_OPTION) {
+		mvOsPrintf("%s: Error: wrong MV_SATR_TYPE_ID field value (%d).\n", __func__ ,satrWriteField);
+		return MV_ERROR;
 	}
-	return MV_ERROR;
+
+	if (mvBoardSatrInfoGet(satrWriteField, satrInfo) != MV_OK) {
+		mvOsPrintf("%s: mvBoardSarInfoGet failed: S@R config is not relevant for this board(%d)\n", __func__, satrWriteField);
+		return MV_ERROR;
+	}
+
+	/* read */
+	readVal = mvBoardTwsiGet(BOARD_DEV_TWSI_SATR, satrInfo->regNum, 0);
+	if (readVal == (MV_U8)MV_ERROR)
+		return MV_ERROR;
+
+	/* modify */
+	readVal &= !(satrInfo->mask);             /* clean old value */
+	readVal &= (val <<  satrInfo->offset);    /* save new value */
+
+	/* write */
+	if (mvBoardTwsiSet(BOARD_DEV_TWSI_SATR, satrInfo->regNum, 0, readVal) == MV_ERROR)
+		return MV_ERROR;
+
+	/* verify */
+	if (readVal != mvBoardTwsiGet(BOARD_DEV_TWSI_SATR, satrInfo->regNum, 0))
+		return MV_ERROR;
+
+	/*else save written value in global array */
+	satrOptionsConfig[satrReadField] = readVal;
+	return MV_OK;
 }
 
 /*******************************************************************************
@@ -270,7 +279,8 @@ MV_STATUS mvCtrlSatRWrite(MV_SATR_TYPE_ID satrWriteField, MV_SATR_TYPE_ID satrRe
 *******************************************************************************/
 MV_U32 mvCtrlSatRRead(MV_SATR_TYPE_ID satrField)
 {
-	if (satrField < MV_SATR_READ_MAX_OPTION)
+	MV_BOARD_SATR_INFO *satrInfo = NULL;;
+	if (satrField < MV_SATR_READ_MAX_OPTION && mvBoardSatrInfoGet(satrField, satrInfo))
 		return satrOptionsConfig[satrField];
 	else
 		return MV_ERROR;
@@ -362,10 +372,12 @@ MV_STATUS mvCtrlCpuDdrL2FreqGet(MV_FREQ_MODE *freqMode)
 *******************************************************************************/
 MV_U32 mvCtrlConfigGet(MV_CONFIG_TYPE_ID configField)
 {
-	if (configField < MV_CONFIG_TYPE_MAX_OPTION)
+	MV_BOARD_CONFIG_TYPE_INFO *configInfo = NULL;
+	if (configField < MV_CONFIG_TYPE_MAX_OPTION && mvBoardConfigTypeGet(configField, configInfo) == MV_OK)
 		return boardOptionsConfig[configField];
-	else
-		return MV_ERROR;
+
+	DB(mvOsPrintf("%s: Error: Requested board config is not valid for this board(%d)\n", __func__, configField));
+	return MV_ERROR;
 }
 
 /*******************************************************************************
@@ -386,39 +398,39 @@ MV_U32 mvCtrlConfigGet(MV_CONFIG_TYPE_ID configField)
 *******************************************************************************/
 MV_VOID mvCtrlSatrInit(void)
 {
-	MV_U8 tempVal[MV_IO_EXP_MAX_REGS];
-	MV_U32 tempRegNum;
-	MV_BOARD_SAR_INFO sarInfo;
-	MV_BOARD_CONFIG_TYPE_INFO confInfo;
+	MV_U8 regNum, satrVal, configVal[MV_IO_EXP_MAX_REGS];
+	MV_BOARD_SATR_INFO *satrInfo = NULL;
+	MV_BOARD_CONFIG_TYPE_INFO *configInfo = NULL;
 	int i = 0;
 
 	/* Verify that board support Auto detection from S@R & board configuration */
-	if (!mvBoardModuleAutoDetectEnabled())
+	if (!mvBoardConfigAutoDetectEnabled())
 		return;
 
 	/* initialize all S@R & Board configuration fields to -1 (MV_ERROR) */
-	memset(&satrOptionsConfig, 0xff, sizeof(MV_U32) * MV_SATR_READ_MAX_OPTION );
-	memset(&boardOptionsConfig, 0xff, sizeof(MV_U32) * MV_CONFIG_TYPE_MAX_OPTION );
+	memset(&satrOptionsConfig, 0x0, sizeof(MV_U32) * MV_SATR_READ_MAX_OPTION );
+	memset(&boardOptionsConfig, 0x0, sizeof(MV_U32) * MV_CONFIG_TYPE_MAX_OPTION );
 
 	/* Read Sample @ Reset configuration, memory access read : */
 	for (i = 0; i < MV_SATR_READ_MAX_OPTION; i++) {
-		if ( mvBoardSarInfoGet(i, &sarInfo) ) {
-			tempVal[0] = MV_REG_READ(MPP_SAMPLE_AT_RESET(sarInfo.regNum));
-			satrOptionsConfig[sarInfo.sarid] = ((tempVal[0]  & (sarInfo.mask)) >> sarInfo.offset);
+		if ( mvBoardSatrInfoGet(i, satrInfo) == MV_OK ) {
+			satrVal = MV_REG_READ(MPP_SAMPLE_AT_RESET(satrInfo->regNum));
+			satrOptionsConfig[satrInfo->satrId] = ((satrVal  & (satrInfo->mask)) >> (satrInfo->offset));
 		}
 	}
 
 	/*Read rest of Board Configuration, EEPROM / Dip Switch access read : */
-	if (mvCtrlBoardConfigGet((MV_U8**)&tempVal)) {
-		/* Save values Locally in tempVal[3] */
+	if (mvCtrlBoardConfigGet(configVal) == MV_OK) {
+		/* Save values Locally in configVal[] */
 		for (i = 0; i < MV_CONFIG_TYPE_MAX_OPTION; i++) {
-			if ( mvBoardConfigTypeGet(i, &confInfo) ) {
+			if ( mvBoardConfigTypeGet(i, configInfo) == MV_OK) {
 				/* each Expander conatins 2 registers */
-				tempRegNum= confInfo.expanderNum * 2 + confInfo.regNum;
-				boardOptionsConfig[confInfo.configid] = ((tempVal[tempRegNum] & (confInfo.mask)) >> confInfo.offset);
+				regNum = configInfo->expanderNum * 2 + configInfo->regNum;
+				boardOptionsConfig[configInfo->configId] = ((configVal[regNum] & (configInfo->mask)) >> configInfo->offset);
 			}
 		}
 	}
+	printf("%s: Error: Read board configuration from EEPROM/Dip Switch failed\n", __func__);
 }
 
 /*******************************************************************************
@@ -440,28 +452,35 @@ MV_VOID mvCtrlSatrInit(void)
 *       MV_BOOL :  MV_TRUE if EEPROM enabled, else return MV_FALSE.
 *
 *******************************************************************************/
-MV_STATUS mvCtrlBoardConfigGet(MV_U8 **tempVal)
+MV_STATUS mvCtrlBoardConfigGet(MV_U8 *config)
 {
 	MV_U32 boardId = mvBoardIdGet();
 	MV_BOOL isEepromEnabled = mvCtrlIsEepromEnabled();
-	MV_BOARD_TWSI_CLASS twsiClass= (isEepromEnabled ? BOARD_DEV_TWSI_EEPROM : BOARD_DEV_TWSI_IO_EXPANDER);
+	MV_BOARD_TWSI_CLASS twsiClass = (isEepromEnabled ? BOARD_DEV_TWSI_EEPROM : BOARD_DEV_TWSI_IO_EXPANDER);
 
-	(*tempVal)[0] = mvBoardTwsiGet(twsiClass, 0, 0);		/* EEPROM/Dip Switch Reg#0 */
-	(*tempVal)[1] = mvBoardTwsiGet(twsiClass, 0, 1);		/* EEPROM/Dip Switch Reg#1 */
-
-	if (boardId == DB_6660_ID) { /* DB-6660 has another register for board configuration */
-		if (isEepromEnabled)
-			(*tempVal)[2] = mvBoardTwsiGet(BOARD_DEV_TWSI_EEPROM, 0, 2);		/* EEPROM Reg#2 */
-		else
-			(*tempVal)[2] = mvBoardTwsiGet(BOARD_DEV_TWSI_IO_EXPANDER, 1, 0);	/* Dip Switch Reg#1 */
+	config[0] = mvBoardTwsiGet(twsiClass, 0, 0);		/* EEPROM/Dip Switch Reg#0 */
+	if ((MV_U8)MV_ERROR == config[0]) {
+		DB(mvOsPrintf("%s: Error: Read from EEPROM/Dip Switch Reg#0 failed\n", __func__));
+		return MV_ERROR;
 	}
 
-	/* verify that all TWSI reads were successfull */
-	if (((MV_8)MV_ERROR == (*tempVal)[0]) || ((MV_8)MV_ERROR == (*tempVal)[1]))
+	config[1] = mvBoardTwsiGet(twsiClass, 0, 1);		/* EEPROM/Dip Switch Reg#1 */
+	if ((MV_U8)MV_ERROR == config[1]) {
+		DB(mvOsPrintf("%s: Error: Read from EEPROM/Dip Switch Reg#1 failed\n", __func__));
 		return MV_ERROR;
+	}
 
-	if ((boardId == DB_6660_ID) && ((MV_8)MV_ERROR == (*tempVal)[2]))
-		return MV_ERROR;
+	if (boardId == DB_6660_ID) { /* DB-6660 has another register for board configuration */
+		if (isEepromEnabled == MV_OK)
+			config[2] = mvBoardTwsiGet(BOARD_DEV_TWSI_EEPROM, 0, 2);		/* EEPROM Reg#2 */
+		else
+			config[2] = mvBoardTwsiGet(BOARD_DEV_TWSI_IO_EXPANDER, 1, 0);	/* Dip Switch Reg#1 */
+
+		if ((MV_U8)MV_ERROR == config[2]) {
+			DB(mvOsPrintf("%s: Error: Read from EEPROM/Dip Switch Reg#2 failed\n", __func__));
+			return MV_ERROR;
+		}
+	}
 
 	return MV_OK;
 }
@@ -484,13 +503,17 @@ MV_STATUS mvCtrlBoardConfigGet(MV_U8 **tempVal)
 *******************************************************************************/
 MV_BOOL mvCtrlIsEepromEnabled()
 {
-	MV_BOARD_IO_EXPANDER_TYPE_INFO ioInfo;
+	MV_BOARD_IO_EXPANDER_TYPE_INFO *ioInfo = NULL;
+	MV_U8 value;
 
-	if(mvBoardIoExpanderTypeGet(MV_IO_EXPANDER_JUMPER1_EEPROM_ENABLED ,&ioInfo))
+	if(mvBoardIoExpanderTypeGet(MV_IO_EXPANDER_JUMPER1_EEPROM_ENABLED ,ioInfo))
 	{
-		return (mvBoardIoExpValGet(ioInfo) == 0x1);
+		value = mvBoardIoExpValGet(ioInfo);
+		if (value != 0xFF)
+			return (value == 0x1);
 	}
-	else return MV_FALSE;
+	printf("%s: Error: Read from IO expander failed (EEPROM enabled jumper)\n", __func__);
+	return MV_FALSE;
 }
 
 /*******************************************************************************
@@ -838,7 +861,7 @@ MV_U32 mvCtrlTdmMaxGet(MV_VOID)
 MV_SLIC_UNIT_TYPE mvCtrlSlicUnitTypeGet(MV_VOID)
 {
 
-	if (mvBoardModuleAutoDetectEnabled())
+	if (mvBoardConfigAutoDetectEnabled())
 		return boardOptionsConfig[MV_CONFIG_SLIC_TDM_DEVICE];
 	else
 		return mvBoardSlicMppModeGet();
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h
index ddecdd8..049e556 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h
@@ -270,7 +270,7 @@ MV_U32 mvCtrlGetQuadNum(MV_VOID);
 MV_STATUS mvCtrlUpdatePexId(MV_VOID);
 MV_BOOL mvCtrlIsValidSatR(MV_VOID);
 MV_BOOL mvCtrlIsEepromEnabled(MV_VOID);
-MV_STATUS mvCtrlBoardConfigGet(MV_U8 **tempVal);
+MV_STATUS mvCtrlBoardConfigGet(MV_U8 *tempVal);
 MV_STATUS mvCtrlEnvInit(MV_VOID);
 MV_U32    mvCtrlMppRegGet(MV_U32 mppGroup);
 
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvRegs.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvRegs.h
index 9a52dca..c061648 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvRegs.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvRegs.h
@@ -408,14 +408,14 @@ typedef enum {
 	MSAR_0_BOOT_SPI1_FLASH
 } MV_BOARD_BOOT_SRC;
 
-typedef struct _mvSARBootTable {
+typedef struct _mvSATRBootTable {
 	MV_BOARD_BOOT_SRC bootSrc;
 	MV_U32 attr1;                           /* Device width/Port */
 	MV_U32 attr2;                           /* ALE TIming Parameters/Page Size/Serdes Lane/Address cycles */
 	MV_U32 attr3;                           /* Dev_Wen Dev_Oen Muxed/Address cycle/SPI interface */
-} MV_SAR_BOOT_TABLE;
+} MV_SATR_BOOT_TABLE;
 
-#define MV_SAR_TABLE_VAL { \
+#define MV_SATR_TABLE_VAL { \
 /*00*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, 0, 0 }, \
 /*01*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT,             0, 1 }, \
 /*02*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, 0, 0 }, \
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvCpuIfRegs.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvCpuIfRegs.h
index a39a9a6..cc1a3a6 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvCpuIfRegs.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvCpuIfRegs.h
@@ -81,8 +81,8 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #define CPU_CONFIG_REG(cpu)			(MV_CPUIF_REGS_BASE(cpu))
 #define CPU_CTRL_STAT_REG(cpu)			(MV_CPUIF_REGS_BASE(cpu) + 0x8)
-#define CPU_RSTOUTN_MASK_REG			(MV_MISC_REGS_BASE + 0x60)
-#define CPU_SYS_SOFT_RST_REG			(MV_MISC_REGS_BASE + 0x64)
+#define CPU_RSTOUTN_MASK_REG			(MV_MISC_REGS_BASE + 0x54)
+#define CPU_SYS_SOFT_RST_REG			(MV_MISC_REGS_BASE + 0x58)
 #define CPU_L2_CTRL_REG				(MV_L2C_REGS_BASE + 0x100)
 #define CPU_L2_AUX_CTRL_REG			(MV_L2C_REGS_BASE + 0x104)
 #define SOC_CTRL_REG				(MV_MISC_REGS_BASE + 0x4)
-- 
1.7.5.4

