From 1eac9b5e4d2457bf3441667930ebfdae2eb7f9ce Mon Sep 17 00:00:00 2001
From: Yelena <yelena@marvell.com>
Date: Sun, 29 Dec 2013 14:52:16 +0200
Subject: [PATCH 1254/1825] pp3: hmac interface improved

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit ab2c18cda75536e5a2009912fab3f66d367b24cd

     Improved register names generated from CIDER.
     Move register access to separate functions to improve performance.
     Add functionality for TX queue with constant CFH size.

Change-Id: Ib95185e252363d4f2f462819ead6f24d00979b9b
Signed-off-by: Yelena <yelena@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/4921
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Uri Eliyahu <uriel@marvell.com>
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Tested-by: Dmitri Epshtein <dima@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/net/ethernet/marvell/pp3/hmac/mv_hmac.c    |  175 +++++++++++++----
 drivers/net/ethernet/marvell/pp3/hmac/mv_hmac.h    |  206 +++++++++++++++++--
 drivers/net/ethernet/marvell/pp3/hmac/mv_hmac_bm.h |    4 +-
 .../net/ethernet/marvell/pp3/hmac/mv_hmac_regs.h   |  126 ++++++------
 4 files changed, 392 insertions(+), 119 deletions(-)

diff --git a/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac.c b/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac.c
index 77ed194..1ee36f5 100644
--- a/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac.c
+++ b/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac.c
@@ -70,15 +70,16 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "hmac/mv_hmac.h"
 #include "hmac/mv_hmac_regs.h"
 
-/* local functions declaration */
-static int mv_pp3_hmac_queue_create(struct mv_pp3_queue_ctrl *q_ctrl, int desc_num);
-
-/* per frame bitmap to store queues state (allocated/free) */
+/* bitmap to store queues state (allocated/free) per frame */
 static unsigned int mv_pp3_hmac_queue_act[MV_PP3_HMAC_MAX_FRAME] = {0};
 /* */
 struct pp3_unit_info pp3_hmac_gl;
 struct pp3_unit_info pp3_hmac_fr;
 
+/* local functions declaration */
+static int mv_pp3_hmac_queue_create(struct mv_pp3_queue_ctrl *q_ctrl, int desc_num);
+
+/* general functions */
 /* store unit base address = silicon base address + unit offset */
 void mv_pp3_hmac_gl_unit_base(unsigned int unit_offset)
 {
@@ -94,56 +95,135 @@ void mv_pp3_hmac_frame_unit_base(unsigned int unit_offset, unsigned int ins_offs
 	pp3_hmac_fr.ins_offs = ins_offset;
 }
 
+/* configure queue to be used like BM queue */
+void mv_pp3_hmac_queue_bm_mode_cfg(int frame, int queue)
+{
+	u32 reg_data;
+
+	reg_data = mv_pp3_hmac_frame_reg_read(frame, MV_HMAC_SEND_Q_CTRL_REG(queue));
+	U32_SET_FIELD(reg_data, MV_HMAC_SEND_Q_CTRL_Q_MODE_OFFS, MV_HMAC_SEND_Q_CTRL_Q_MODE_MASK, 1);
+
+	mv_pp3_hmac_frame_reg_write(frame, MV_HMAC_SEND_Q_CTRL_REG(queue), reg_data);
+}
+
+/* configure queue parameters used by QM queue
+ * qm_num - is a number of QM queue                   */
+void mv_pp3_hmac_queue_qm_mode_cfg(int frame, int queue, int qm_num)
+{
+	u32 reg_data;
+
+	/* configure queue to be QM queue */
+	reg_data = mv_pp3_hmac_frame_reg_read(frame, MV_HMAC_SEND_Q_CTRL_REG(queue));
+	U32_SET_FIELD(reg_data, MV_HMAC_SEND_Q_CTRL_Q_MODE_OFFS, MV_HMAC_SEND_Q_CTRL_Q_MODE_MASK, 0);
+	mv_pp3_hmac_frame_reg_write(frame, MV_HMAC_SEND_Q_CTRL_REG(queue), reg_data);
+	/* map QM queue number */
+	mv_pp3_hmac_frame_reg_write(frame, MV_HMAC_SEND_Q_NUM_BPID_REG(queue), qm_num);
+}
+
+
+/* RX queue functions */
 /* Allocate memory and init RX queue HW facility
  * size is a queue size in datagrams (16 bytes each) */
 u32 mv_pp3_hmac_rxq_init(int frame, int queue, int size, struct mv_pp3_queue_ctrl *qctrl)
 {
+	u32 reg_data;
+
 	/* check if already created */
 	if ((mv_pp3_hmac_queue_act[frame] >> queue) & 1)
 		return 1;
 
 	qctrl->size = size;
+	qctrl->occ_dg = 0;
 	mv_pp3_hmac_queue_create(qctrl, size * MV_PP3_HMAC_DG_SIZE);
-/*	Write pointer to allocated memory to
-a.	rq_address_high table address bits [39:32]
-b.	rq_address_low table address bits [31:8], aligned to 256B
-3.	Store queue size in rq_size table, number of 16B units.
-4.	Configure Receive Threshold TBD.
-5.	Disable queue, hmac_%m_rec_q_%n_control set to 0.
-*/
+	/* Write pointer to allocated memory */
+	mv_pp3_hmac_frame_reg_write(frame, MV_PP3_HMAC_RQ_ADDR_LOW(queue), (u32)qctrl->first);
+	/* Store queue size in rq_size table, number of 16B units */
+	mv_pp3_hmac_frame_reg_write(frame, MV_PP3_HMAC_RQ_SIZE(queue), (u32)qctrl->size);
+	/* Configure Receive Threshold TBD */
+	/* Disable queue, hmac_%m_rec_q_%n_control set to 0 */
+	reg_data = mv_pp3_hmac_frame_reg_read(frame, MV_HMAC_REC_Q_CTRL_REG(queue));
+	U32_SET_FIELD(reg_data, MV_HMAC_REC_Q_CTRL_RCV_Q_EN_OFFS, MV_HMAC_REC_Q_CTRL_RCV_Q_EN_MASK, 0);
+	mv_pp3_hmac_frame_reg_write(frame, MV_HMAC_REC_Q_CTRL_REG(queue), reg_data);
+
+	/* mark queue as created */
+	mv_pp3_hmac_queue_act[frame] |= (1 << queue);
 	return 0;
 }
 
-/* Return pointer to first free CFH:
- * size is CFH size in datagrams (16 bytes each)     */
-void mv_pp3_hmac_txq_next_cfh(int frame, int queue, struct mv_pp3_queue_ctrl *qctrl, int size, u8 **cfh_ptr)
+void mv_pp3_hmac_rxq_flush(int frame, int queue)
 {
-	if ((qctrl->next_proc + size * MV_PP3_HMAC_DG_SIZE) > qctrl->last)
-		/* do FIFO wraparound */;
+	u32 data;
 
-	*cfh_ptr = qctrl->next_proc;
-	qctrl->next_proc += size;
+	/* flush queue */
+	data = mv_pp3_hmac_frame_reg_read(frame, MV_HMAC_REC_Q_CTRL_REG(queue));
+	data &= ~(MV_HMAC_REC_Q_CTRL_RCV_Q_FLUSH_MASK);
+	mv_pp3_hmac_frame_reg_write(frame, MV_HMAC_REC_Q_CTRL_REG(queue), data);
 }
 
-void mv_pp3_hmac_rxq_reset(int frame, int queue)
+void mv_pp3_hmac_rxq_enable(int frame, int queue)
 {
-	unsigned int data;
+	u32 reg_data;
 
-	/* reset queue */
-	data = mv_pp3_hmac_frame_reg_read(frame, MV_HMAC_REC_Q_CTRL_REG(queue));
-	data &= ~(MV_HMAC_REC_Q_CTRL_RCV_Q_FLUSH_MASK);
-	mv_pp3_hmac_frame_reg_write(frame, MV_HMAC_REC_Q_CTRL_REG(queue), data);
+	/* Enable queue */
+	reg_data = mv_pp3_hmac_frame_reg_read(frame, MV_HMAC_REC_Q_CTRL_REG(queue));
+	U32_SET_FIELD(reg_data, MV_HMAC_REC_Q_CTRL_RCV_Q_EN_OFFS, MV_HMAC_REC_Q_CTRL_RCV_Q_EN_MASK, 1);
+	mv_pp3_hmac_frame_reg_write(frame, MV_HMAC_REC_Q_CTRL_REG(queue), reg_data);
 }
 
-void mv_pp3_hmac_txq_qm_mode_cfg(int frame, int queue, int qm_num)
+void mv_pp3_hmac_rxq_disable(int frame, int queue)
 {
-	unsigned int data;
+	u32 reg_data;
 
-	data = mv_pp3_hmac_frame_reg_read(frame, MV_HMAC_SEND_Q_CTRL_REG(queue));
-	data &= ~(MV_HMAC_SEND_Q_CTRL_Q_MODE_MASK); /* set mode to QM */
-	mv_pp3_hmac_frame_reg_write(frame, MV_HMAC_SEND_Q_CTRL_REG(queue), data);
+	/* Disable queue */
+	reg_data = mv_pp3_hmac_frame_reg_read(frame, MV_HMAC_REC_Q_CTRL_REG(queue));
+	U32_SET_FIELD(reg_data, MV_HMAC_REC_Q_CTRL_RCV_Q_EN_OFFS, MV_HMAC_REC_Q_CTRL_RCV_Q_EN_MASK, 0);
+	mv_pp3_hmac_frame_reg_write(frame, MV_HMAC_REC_Q_CTRL_REG(queue), reg_data);
 }
 
+/* TX queue functions */
+u32 mv_pp3_hmac_txq_init(int frame, int queue, int size, int cfh_size, struct mv_pp3_queue_ctrl *qctrl)
+{
+	u32 reg_data;
+
+	qctrl->size = size;
+	qctrl->occ_dg = 0;
+	qctrl->cfh_size = cfh_size;
+
+	mv_pp3_hmac_queue_create(qctrl, size * MV_PP3_HMAC_DG_SIZE);
+	/* Write pointer to allocated memory */
+	mv_pp3_hmac_frame_reg_write(frame, MV_PP3_HMAC_SQ_ADDR_LOW(queue), (u32)qctrl->first);
+	/* Store queue size in rq_size table, number of 16B units */
+	mv_pp3_hmac_frame_reg_write(frame, MV_PP3_HMAC_SQ_SIZE(queue), (u32)qctrl->size);
+	/* Configure Transmit Threshold TBD */
+	/* Disable queue */
+	reg_data = mv_pp3_hmac_frame_reg_read(frame, MV_HMAC_SEND_Q_CTRL_REG(queue));
+	U32_SET_FIELD(reg_data, MV_HMAC_SEND_Q_CTRL_SEND_Q_EN_OFFS, MV_HMAC_SEND_Q_CTRL_SEND_Q_EN_MASK, 0);
+	mv_pp3_hmac_frame_reg_write(frame, MV_HMAC_SEND_Q_CTRL_REG(queue), reg_data);
+
+	return 0;
+}
+
+void mv_pp3_hmac_txq_enable(int frame, int queue)
+{
+	u32 reg_data;
+
+	/* Enable queue */
+	reg_data = mv_pp3_hmac_frame_reg_read(frame, MV_HMAC_SEND_Q_CTRL_REG(queue));
+	U32_SET_FIELD(reg_data, MV_HMAC_SEND_Q_CTRL_SEND_Q_EN_OFFS, MV_HMAC_SEND_Q_CTRL_SEND_Q_EN_MASK, 1);
+	mv_pp3_hmac_frame_reg_write(frame, MV_HMAC_SEND_Q_CTRL_REG(queue), reg_data);
+}
+
+void mv_pp3_hmac_txq_disable(int frame, int queue)
+{
+	u32 reg_data;
+
+	/* Disable queue */
+	reg_data = mv_pp3_hmac_frame_reg_read(frame, MV_HMAC_SEND_Q_CTRL_REG(queue));
+	U32_SET_FIELD(reg_data, MV_HMAC_SEND_Q_CTRL_SEND_Q_EN_OFFS, MV_HMAC_SEND_Q_CTRL_SEND_Q_EN_MASK, 0);
+	mv_pp3_hmac_frame_reg_write(frame, MV_HMAC_SEND_Q_CTRL_REG(queue), reg_data);
+}
+
+/* Local functions */
 /* allocate descriptors */
 static u8 *mv_pp3_queue_mem_alloc(int size)
 {
@@ -171,16 +251,43 @@ static int mv_pp3_hmac_queue_create(struct mv_pp3_queue_ctrl *q_ctrl, int desc_n
 
 	/* Make sure descriptor address is aligned */
 	/*q_ctrl->first = (char *)MV_ALIGN_UP((MV_ULONG) qCtrl->descBuf.bufVirtPtr, MV_PP2_DESC_Q_ALIGN);*/
-
-	q_ctrl->last = q_ctrl->first + size;
+	q_ctrl->size = size / MV_PP3_HMAC_DG_SIZE;
+	q_ctrl->end = q_ctrl->first + size;
 	return 0;
 }
 
-u32 mv_pp3_hmac_txq_init(int frame, int queue, int size, struct mv_pp3_queue_ctrl *qctrl)
+/* Print HMAC Frame unit register */
+static void mv_pp3_hmac_fr_reg_print(int frame, char *reg_name, u32 reg)
 {
-	return 0;
+	pr_info("  %-32s: 0x%x = 0x%08x\n", reg_name, reg, mv_pp3_hmac_frame_reg_read(frame, reg));
+}
+
+/* dump hmac queue registers */
+void mv_pp3_hmac_rxq_regs(int frame, int queue)
+{
+	pr_info("-------------- HMAC RX (frame = %d, queue = %d) regs -----------\n", frame, queue);
+	mv_pp3_hmac_fr_reg_print(frame, "QUEUE_CTRL", MV_HMAC_REC_Q_CTRL_REG(queue));
+	mv_pp3_hmac_fr_reg_print(frame, "QUEUE_STATUS", MV_HMAC_REC_Q_STATUS_REG(queue));
+	mv_pp3_hmac_fr_reg_print(frame, "TIMEOUT", MV_HMAC_REC_Q_TIMEOUT_REG(queue));
+	mv_pp3_hmac_fr_reg_print(frame, "ADDR_LOW", MV_PP3_HMAC_RQ_ADDR_LOW(queue));
+	mv_pp3_hmac_fr_reg_print(frame, "QUEUE_SIZE", MV_PP3_HMAC_RQ_SIZE(queue));
+	mv_pp3_hmac_fr_reg_print(frame, "OCC_STATUS", MV_PP3_HMAC_RQ_OCC_STATUS(queue));
+	mv_pp3_hmac_fr_reg_print(frame, "AXI_ATTR", MV_PP3_HMAC_RQ_AXI_ATTR(queue));
+	mv_pp3_hmac_fr_reg_print(frame, "EVENT_GROUP", MV_PP3_HMAC_RQ_EVENT_GROUP(queue));
+	mv_pp3_hmac_fr_reg_print(frame, "INT_THRESH", MV_PP3_HMAC_RQ_INT_THRESH(queue));
 }
 
-void mv_pp3_hmac_txq_send(int frame, int queue, int size)
+/* dump hmac queue registers */
+void mv_pp3_hmac_txq_regs(int frame, int queue)
 {
+	pr_info("-------------- HMAC TX (frame = %d, queue = %d) regs -----------\n", frame, queue);
+	mv_pp3_hmac_fr_reg_print(frame, "QUEUE_CTRL", MV_HMAC_SEND_Q_CTRL_REG(queue));
+	mv_pp3_hmac_fr_reg_print(frame, "QM_NUM", MV_HMAC_SEND_Q_NUM_BPID_REG(queue));
+	mv_pp3_hmac_fr_reg_print(frame, "QUEUE_STATUS", MV_HMAC_SEND_Q_STATUS_REG(queue));
+	mv_pp3_hmac_fr_reg_print(frame, "TIMEOUT", MV_HMAC_SEND_Q_TIMEOUT_REG(queue));
+	mv_pp3_hmac_fr_reg_print(frame, "ADDR_LOW", MV_PP3_HMAC_SQ_ADDR_LOW(queue));
+	mv_pp3_hmac_fr_reg_print(frame, "QUEUE_SIZE", MV_PP3_HMAC_SQ_SIZE(queue));
+	mv_pp3_hmac_fr_reg_print(frame, "OCC_STATUS", MV_PP3_HMAC_SQ_OCC_STATUS(queue));
+	mv_pp3_hmac_fr_reg_print(frame, "AXI_ATTR", MV_PP3_HMAC_SQ_AXI_ATTR(queue));
+	mv_pp3_hmac_fr_reg_print(frame, "EVENT_GROUP", MV_PP3_HMAC_SQ_EVENT_GROUP(queue));
 }
diff --git a/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac.h b/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac.h
index 5ab5dbc..73fc897 100644
--- a/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac.h
+++ b/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac.h
@@ -65,23 +65,53 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #ifndef __mvHmac_h__
 #define __mvHmac_h__
 
+#include "hmac/mv_hmac_regs.h"
 
 #define MV_PP3_HMAC_MAX_FRAME			(16)
 #define MV_PP3_HMAC_DG_SIZE				(16)
 #define MV_PP3_CFH_MIN_SIZE				(32)
-#define MV_PP3_CFH_DG_NUM				(MV_PP3_CFH_MIN_SIZE \ MV_PP3_HMAC_DG_SIZE)
+#define MV_PP3_CFH_MAX_SIZE				(128)
+#define MV_PP3_CFH_DG_NUM				(MV_PP3_CFH_MIN_SIZE / MV_PP3_HMAC_DG_SIZE)
 #define MV_PP3_HMAC_Q_ALIGN				(256)
 
+#define MV_PP3_HMAC_CFH_DUMMY			(0x8000)
+
 extern struct pp3_unit_info pp3_hmac_gl;
 extern struct pp3_unit_info pp3_hmac_fr;
 
 struct mv_pp3_queue_ctrl {
-	u8 *first;
-	u8 *next_proc;
-	u8 *last;
-	int   size;  /* number of 16 bytes units (datagram) in queue */
+	u8 *first;		/* pointer to first byte in queue */
+	u8 *next_proc;	/* pointer to next CFH to procces in queue */
+	u8 *end;		/* pointer to first byte not belong to queue */
+	int occ_dg;		/* number of occupated datagram in queue */
+	int dummy_dg;	/* number of dummy datagrams added by last wraparound */
+	int size;		/* number of 16 bytes units (datagram) in queue */
+	int cfh_size;	/* for queue with constant CFH size is number of datargarms in CFH, (or -1) */
+};
+
+/* CFH structure */
+struct cfh_common_format {
+
+	unsigned short pkt_length;
+	unsigned short seq_id_qe_cntrl;
+	unsigned short qm_cntrl;
+	unsigned char  cfh_length;
+	unsigned char  cfh_format;
+	unsigned int   tag1;
+	unsigned int   tag2;
+	unsigned int   addr_low;
+	unsigned short addr_high;
+	unsigned char  vm_id;
+	unsigned char  bp_id;
+	unsigned int   marker_low;
+	unsigned char  marker_high;
+	unsigned char  reserved0;
+	unsigned short qc_cntrl;
 };
 
+/*****************************************
+ *     Reigister acccess functions       *
+ *****************************************/
 static inline u32 mv_pp3_hmac_gl_reg_read(u32 reg)
 {
 	u32 reg_data;
@@ -94,28 +124,29 @@ static inline u32 mv_pp3_hmac_gl_reg_read(u32 reg)
 
 static inline u32 mv_pp3_hmac_frame_reg_read(int frameId, u32 reg)
 {
-	u32 reg_data;
 	u32 reg_addr;
 
 	reg_addr = pp3_hmac_fr.base_addr + pp3_hmac_fr.ins_offs * frameId + reg;
 	/* add debug print */
-	mv_pp3_hw_read(reg_addr, 1, &reg_data);
 
-	return reg_data;
+	return mv_pp3_hw_reg_read(reg_addr);
 }
 
 static inline void mv_pp3_hmac_gl_reg_write(u32 reg, u32 data)
 {
-	mv_pp3_hw_write(reg + pp3_hmac_gl.base_addr, 1, &data);
+	mv_pp3_hw_reg_write(reg + pp3_hmac_gl.base_addr, data);
 }
 
 static inline void mv_pp3_hmac_frame_reg_write(int frame_id, u32 reg, u32 data)
 {
 	u32 reg_addr = pp3_hmac_fr.base_addr + pp3_hmac_fr.ins_offs * frame_id + reg;
 
-	mv_pp3_hw_write(reg_addr, 1, &data);
+	mv_pp3_hw_reg_write(reg_addr, data);
 }
 
+/*****************************************
+ *        HMAC unit init functions       *
+ *****************************************/
 /* Init HMAC global unit base address
  * unit_offset = silicon base address + unit offset  */
 void mv_pp3_hmac_gl_unit_base(u32 unit_offset);
@@ -124,34 +155,165 @@ void mv_pp3_hmac_gl_unit_base(u32 unit_offset);
  * frame_offset - is an next frame unit offset       */
 void mv_pp3_hmac_frame_unit_base(u32 unit_offset, u32 frame_offset);
 
+/*****************************************
+ *           RX queue functions          *
+ *****************************************/
 /* Allocate memory and init RX queue HW facility
  * size is a queue size in datagrams (16 bytes each) */
 u32 mv_pp3_hmac_rxq_init(int frame, int queue, int size, struct mv_pp3_queue_ctrl *qctrl);
 void mv_pp3_hmac_rxq_flush(int frame, int queue);
 void mv_pp3_hmac_rxq_enable(int frame, int queue);
 void mv_pp3_hmac_rxq_disable(int frame, int queue);
-void mv_pp3_hmac_rxq_occ_get(int frame, int queue, int *size);
-void mv_pp3_hmac_rxq_next_cfh(int frame, int queue, int *size, u8 *cfh_ptr);
 
+/* Return number of received datagrams */
+static inline int mv_pp3_hmac_rxq_occ_get(int frame, int queue)
+{
+	return mv_pp3_hmac_frame_reg_read(frame, MV_PP3_HMAC_RQ_OCC_STATUS(queue)) & MV_PP3_HMAC_OCC_COUNTER_MASK;
+}
+
+/* Write a number of processed datagram (16 bytes each) */
+static inline void mv_pp3_hmac_rxq_occ_set(int frame, int queue, int size)
+{
+	mv_pp3_hmac_frame_reg_write(frame, MV_HMAC_REC_Q_OCC_STATUS_UPDATE_REG(queue), size);
+}
+
+/* size - number of datagram in proccesed CFH */
+static inline u8 *mv_pp3_hmac_rxq_next_cfh(struct mv_pp3_queue_ctrl *qctrl, int *size)
+{
+	struct cfh_common_format *cfh;
+	int dg;
+	u8	*cfh_ptr;
+
+	/* Read 16 bytes of CFH pointed by "next_proc" field and calculate size of CFH in bytes */
+	cfh = (struct cfh_common_format *)qctrl->next_proc;
+	dg = cfh->cfh_length / MV_PP3_HMAC_DG_SIZE;
+
+	/* Store "next_proc" field value to return */
+	cfh_ptr = qctrl->next_proc;
+	/* Move "next_proc" pointer to next CFH ("next_proc" + size) */
+	qctrl->next_proc += cfh->cfh_length;
+
+	/* if get NULL CFH with "W" bit set, do wraparound */
+	if (cfh->qm_cntrl & MV_PP3_HMAC_CFH_DUMMY) {
+		qctrl->next_proc = qctrl->first;
+		/* return first CFH in queue */
+		cfh = (struct cfh_common_format *)qctrl->next_proc;
+		dg += cfh->cfh_length / MV_PP3_HMAC_DG_SIZE;
+	}
+	*size = dg;
+	return cfh_ptr;
+}
+
+/*****************************************
+ *           TX queue functions          *
+ *****************************************/
 /* Allocate memory and init TX queue HW facility:
  * size is a queue size in datagrams (16 bytes each) */
-u32 mv_pp3_hmac_txq_init(int frame, int queue, int size, struct mv_pp3_queue_ctrl *qctrl);
+u32 mv_pp3_hmac_txq_init(int frame, int queue, int size, int cfh_size, struct mv_pp3_queue_ctrl *qctrl);
 void mv_pp3_hmac_txq_flush(int frame, int queue);
 void mv_pp3_hmac_txq_enable(int frame, int queue);
 void mv_pp3_hmac_txq_disable(int frame, int queue);
-/* Return pointer to first free CFH:
+
+/* Check for space in the queue.
+ * Return 0 for positive answer, or 1 for negative.
+ * dg_num - number of datagrams we are looking for */
+static inline int mv_pp3_hmac_txq_check_for_space(int frame, int queue, struct mv_pp3_queue_ctrl *qctrl, int dg_num)
+{
+	if ((qctrl->size - qctrl->occ_dg) >= dg_num)
+		return 0;
+
+	qctrl->occ_dg = mv_pp3_hmac_frame_reg_read(frame, MV_PP3_HMAC_SQ_OCC_STATUS(queue)) &
+					MV_PP3_HMAC_OCC_COUNTER_MASK;
+	return ((qctrl->size - qctrl->occ_dg) >= dg_num) ? 0 : 1;
+}
+
+/* Return number of free space in the end of queue (in datagrams) */
+static inline int mv_pp3_hmac_txq_free_room(struct mv_pp3_queue_ctrl *qctrl)
+{
+	return (qctrl->end - qctrl->next_proc) / MV_PP3_HMAC_DG_SIZE;
+}
+
+/* Return number of currently occupated datagrams in queue */
+static inline int mv_pp3_hmac_txq_occ_get(int frame, int queue, struct mv_pp3_queue_ctrl *qctrl)
+{
+	qctrl->occ_dg = mv_pp3_hmac_frame_reg_read(frame, MV_PP3_HMAC_SQ_OCC_STATUS(queue)) &
+					MV_PP3_HMAC_OCC_COUNTER_MASK;
+	return qctrl->occ_dg;
+}
+
+/* Return pointer to first free one CFH from queue with constant CFH size
+ * (do queue wraparound, if needed) */
+static inline u8 *mv_pp3_hmac_const_txq_next_cfh(struct mv_pp3_queue_ctrl *qctrl)
+{
+	u8 *cfh_ptr;
+
+	if ((qctrl->cfh_size + qctrl->occ_dg) > qctrl->size)
+		return NULL;
+
+	cfh_ptr = qctrl->next_proc;
+	qctrl->next_proc += (qctrl->cfh_size * MV_PP3_HMAC_DG_SIZE);
+	qctrl->occ_dg += qctrl->cfh_size;
+
+	if (qctrl->next_proc == qctrl->end)
+		qctrl->next_proc = qctrl->first;
+
+	return cfh_ptr;
+}
+
+/* Return pointer to first free one CFH (run queue wraparound, if needed) :
  * size is CFH size in datagrams (16 bytes each)     */
-void mv_pp3_hmac_txq_next_cfh(int frame, int queue, struct mv_pp3_queue_ctrl *qctrl, int size, u8 **cfh_ptr);
+static inline u8 *mv_pp3_hmac_txq_next_cfh(struct mv_pp3_queue_ctrl *qctrl, int size)
+{
+	u8 *cfh_ptr;
+	int end_free_dg;	/* number of free datagram in the queue end */
+	int start_free_dg;	/* number of free datagram in the queue start */
+
+	/* calculate number of unused datagram n the queue end */
+	end_free_dg = (qctrl->end - qctrl->next_proc) / MV_PP3_HMAC_DG_SIZE;
+	if (end_free_dg >= size) {
+		cfh_ptr = qctrl->next_proc;
+		qctrl->next_proc += (size * MV_PP3_HMAC_DG_SIZE);
+		qctrl->occ_dg += size;
+
+		return cfh_ptr;
+	}
+
+	/* There is not enough space in the queue end. */
+	/* Check and if possible to queue wraparound */
+	/* calculate number of unused datagrams in the queue start */
+	start_free_dg = (qctrl->size - qctrl->occ_dg) - end_free_dg;
+	if (start_free_dg < size)
+		/* not enough space in queue (cannot run wraparound) */
+		return NULL;
+
+	/* do FIFO wraparound */
+	/* return pointer to fisrt CFH and move next pointer to second CFH in queue */
+	if (qctrl->end != qctrl->next_proc) {
+		/* do wraparound with dummy CFH sent */
+		struct cfh_common_format *cfh = (struct cfh_common_format *)qctrl->next_proc;
+
+		cfh->pkt_length = end_free_dg * MV_PP3_HMAC_DG_SIZE;
+		cfh->qm_cntrl = MV_PP3_HMAC_CFH_DUMMY; /* set bit 'W' */
+		qctrl->dummy_dg = end_free_dg;
+	}
+	qctrl->next_proc = qctrl->first + (size * MV_PP3_HMAC_DG_SIZE);
+	qctrl->occ_dg += size;
+
+	return qctrl->first;
+}
+
 /* size - is number of datagrams to transmit         */
-void mv_pp3_hmac_txq_send(int frame, int queue, int size);
+static inline void mv_pp3_hmac_txq_send(int frame, int queue, int size, struct mv_pp3_queue_ctrl *qctrl)
+{
+	size += qctrl->dummy_dg;
+	mv_pp3_hmac_frame_reg_write(frame, MV_HMAC_SEND_Q_OCC_STATUS_UPDATE_REG(queue), size);
+	qctrl->dummy_dg = 0;
+}
 
-/* configure queue parameters used by BM queue
- * bpid - is a buffer pool ID for allocation request
- * bm_alloc_count - is a size of the allocation
- * request in units of 16B                           */
-void mv_pp3_hmac_txq_bm_mode_cfg(int frame, int queue, int bpid, int bm_alloc_count);
+/* configure queue parameters used by BM queue       */
+void mv_pp3_hmac_queue_bm_mode_cfg(int frame, int queue);
 /* configure queue parameters used by QM queue
  * q_num - is a number of QM queue                   */
-void mv_pp3_hmac_txq_qm_mode_cfg(int frame, int queue, int q_num);
+void mv_pp3_hmac_queue_qm_mode_cfg(int frame, int queue, int q_num);
 
 #endif /* __mvHmac_h__ */
diff --git a/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac_bm.h b/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac_bm.h
index 6c0ae1c..9b03710 100644
--- a/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac_bm.h
+++ b/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac_bm.h
@@ -91,7 +91,7 @@ u32 mv_pp3_hmac_bm_queue_init(int frame, int queue, int q_size,
 
 	size = MV_PP3_BM_PE_DG; /* number of descriptors * 1 datagrams (per PE) */
 	ret = mv_pp3_hmac_rxq_init(frame, queue, size, rxq_ctrl);
-	ret = mv_pp3_hmac_txq_init(frame, queue, size, txq_ctrl);
+	ret = mv_pp3_hmac_txq_init(frame, queue, size, MV_PP3_BM_PE_DG, txq_ctrl);
 
 	mv_pp3_hmac_queue_bm_mode_cfg(frame, queue);
 
@@ -128,7 +128,7 @@ int mv_pp3_hmac_bm_buff_free(int bp_id, u32 buff_addr, struct mv_pp3_queue_ctrl
 	struct mv_pp3_hmac_bm_cfh *bm_cfh;
 
 	/* get pointer to PE and write parameters */
-	bm_cfh = (struct mv_pp3_hmac_bm_cfh *)mv_pp3_hmac_txq_next_cfh(qctrl, MV_PP3_BM_PE_SIZE);
+	bm_cfh = (struct mv_pp3_hmac_bm_cfh *)mv_pp3_hmac_const_txq_next_cfh(qctrl);
 	if (bm_cfh == NULL)
 		return 1;
 
diff --git a/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac_regs.h b/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac_regs.h
index 276c944..13a03c3 100644
--- a/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac_regs.h
+++ b/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac_regs.h
@@ -66,6 +66,8 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define __mvHmacRegs_h__
 
 /* includes */
+/* Sets the field located at the specified offset & length in data.     */
+#define U32_SET_FIELD(data, offset, mask, val)		((data) = (((data) & ~(mask)) | ((val) << (offset))))
 
 /* unit offset */
 #define MV_PP3_HMAC_GL_UNIT_OFFSET	0x30000
@@ -104,57 +106,57 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 
 /* Hmac_vmid_frame_%m */
-#define MV_HMAC_VMID_FRAME_M_REG(m)							(0x0010 + 4*m)
-#define MV_HMAC_VMID_FRAME_M_CONTEXT_ID_OFFS		0
-#define MV_HMAC_VMID_FRAME_M_CONTEXT_ID_MASK    \
-		(0x0000003f << MV_HMAC_VMID_FRAME_M_CONTEXT_ID_OFFS)
+#define MV_HMAC_VMID_FRAME_REG(m)							(0x0010 + 4*m)
+#define MV_HMAC_VMID_FRAME_CONTEXT_ID_OFFS		0
+#define MV_HMAC_VMID_FRAME_CONTEXT_ID_MASK    \
+		(0x0000003f << MV_HMAC_VMID_FRAME_CONTEXT_ID_OFFS)
 
-#define MV_HMAC_VMID_FRAME_M_AXI_PROT_PRIVILEGE_OFFS		16
-#define MV_HMAC_VMID_FRAME_M_AXI_PROT_PRIVILEGE_MASK    \
-		(0x00000001 << MV_HMAC_VMID_FRAME_M_AXI_PROT_PRIVILEGE_OFFS)
+#define MV_HMAC_VMID_FRAME_AXI_PROT_PRIVILEGE_OFFS		16
+#define MV_HMAC_VMID_FRAME_AXI_PROT_PRIVILEGE_MASK    \
+		(0x00000001 << MV_HMAC_VMID_FRAME_AXI_PROT_PRIVILEGE_OFFS)
 
-#define MV_HMAC_VMID_FRAME_M_AW_QOS_OFFS		20
-#define MV_HMAC_VMID_FRAME_M_AW_QOS_MASK    \
-		(0x00000003 << MV_HMAC_VMID_FRAME_M_AW_QOS_OFFS)
+#define MV_HMAC_VMID_FRAME_AW_QOS_OFFS		20
+#define MV_HMAC_VMID_FRAME_AW_QOS_MASK    \
+		(0x00000003 << MV_HMAC_VMID_FRAME_AW_QOS_OFFS)
 
-#define MV_HMAC_VMID_FRAME_M_AR_QOS_OFFS		24
-#define MV_HMAC_VMID_FRAME_M_AR_QOS_MASK    \
-		(0x00000003 << MV_HMAC_VMID_FRAME_M_AR_QOS_OFFS)
+#define MV_HMAC_VMID_FRAME_AR_QOS_OFFS		24
+#define MV_HMAC_VMID_FRAME_AR_QOS_MASK    \
+		(0x00000003 << MV_HMAC_VMID_FRAME_AR_QOS_OFFS)
 
 
 /* Hmac_event_addr_low_%m */
-#define MV_HMAC_EVENT_ADDR_LOW_M_REG(m)							(0x0050 + 8*m)
-#define MV_HMAC_EVENT_ADDR_LOW_M_EVENT_ADDRESS_LOW_OFFS		8
-#define MV_HMAC_EVENT_ADDR_LOW_M_EVENT_ADDRESS_LOW_MASK    \
-		(0x00ffffff << MV_HMAC_EVENT_ADDR_LOW_M_EVENT_ADDRESS_LOW_OFFS)
+#define MV_HMAC_EVENT_ADDR_LOW_REG(m)							(0x0050 + 8*m)
+#define MV_HMAC_EVENT_ADDR_LOW_EVENT_ADDRESS_LOW_OFFS		8
+#define MV_HMAC_EVENT_ADDR_LOW_EVENT_ADDRESS_LOW_MASK    \
+		(0x00ffffff << MV_HMAC_EVENT_ADDR_LOW_EVENT_ADDRESS_LOW_OFFS)
 
 
 /* Hmac_event_addr_high_%m */
-#define MV_HMAC_EVENT_ADDR_HIGH_M_REG(m)							(0x0054 + 8*m)
-#define MV_HMAC_EVENT_ADDR_HIGH_M_EVENT_ADDRESS_HIGH_OFFS		0
-#define MV_HMAC_EVENT_ADDR_HIGH_M_EVENT_ADDRESS_HIGH_MASK    \
-		(0x000000ff << MV_HMAC_EVENT_ADDR_HIGH_M_EVENT_ADDRESS_HIGH_OFFS)
+#define MV_HMAC_EVENT_ADDR_HIGH_REG(m)							(0x0054 + 8*m)
+#define MV_HMAC_EVENT_ADDR_HIGH_EVENT_ADDRESS_HIGH_OFFS		0
+#define MV_HMAC_EVENT_ADDR_HIGH_EVENT_ADDRESS_HIGH_MASK    \
+		(0x000000ff << MV_HMAC_EVENT_ADDR_HIGH_EVENT_ADDRESS_HIGH_OFFS)
 
 
 /* Hmac_dram_update_time_out_%m */
-#define MV_HMAC_DRAM_UPDATE_TIME_OUT_M_REG(m)							(0x00d0 + 4*m)
-#define MV_HMAC_DRAM_UPDATE_TIME_OUT_M_DRAM_UPDAT_TIME_OUT_OFFS		0
-#define MV_HMAC_DRAM_UPDATE_TIME_OUT_M_DRAM_UPDAT_TIME_OUT_MASK    \
-		(0x0000ffff << MV_HMAC_DRAM_UPDATE_TIME_OUT_M_DRAM_UPDAT_TIME_OUT_OFFS)
+#define MV_HMAC_DRAM_UPDATE_TIME_OUT_REG(m)							(0x00d0 + 4*m)
+#define MV_HMAC_DRAM_UPDATE_TIME_OUT_DRAM_UPDAT_TIME_OUT_OFFS		0
+#define MV_HMAC_DRAM_UPDATE_TIME_OUT_DRAM_UPDAT_TIME_OUT_MASK    \
+		(0x0000ffff << MV_HMAC_DRAM_UPDATE_TIME_OUT_DRAM_UPDAT_TIME_OUT_OFFS)
 
 
 /* Hmac_dram_update_threshold_%m */
-#define MV_HMAC_DRAM_UPDATE_THRESHOLD_M_REG(m)							(0x0110 + 4*m)
-#define MV_HMAC_DRAM_UPDATE_THRESHOLD_M_DRAM_UPDAT_THRESHOLD_OFFS		0
-#define MV_HMAC_DRAM_UPDATE_THRESHOLD_M_DRAM_UPDAT_THRESHOLD_MASK    \
-		(0x0000ffff << MV_HMAC_DRAM_UPDATE_THRESHOLD_M_DRAM_UPDAT_THRESHOLD_OFFS)
+#define MV_HMAC_DRAM_UPDATE_THRESHOLD_REG(m)							(0x0110 + 4*m)
+#define MV_HMAC_DRAM_UPDATE_THRESHOLD_DRAM_UPDAT_THRESHOLD_OFFS		0
+#define MV_HMAC_DRAM_UPDATE_THRESHOLD_DRAM_UPDAT_THRESHOLD_MASK    \
+		(0x0000ffff << MV_HMAC_DRAM_UPDATE_THRESHOLD_DRAM_UPDAT_THRESHOLD_OFFS)
 
 
 /* Hmac_axi_prot_secure_%m */
-#define MV_HMAC_AXI_PROT_SECURE_M_REG(m)							(0x0300 + 4*m)
-#define MV_HMAC_AXI_PROT_SECURE_M_AXI_PROT_SECURE_OFFS		0
-#define MV_HMAC_AXI_PROT_SECURE_M_AXI_PROT_SECURE_MASK    \
-		(0x00000001 << MV_HMAC_AXI_PROT_SECURE_M_AXI_PROT_SECURE_OFFS)
+#define MV_HMAC_AXI_PROT_SECURE_REG(m)							(0x0300 + 4*m)
+#define MV_HMAC_AXI_PROT_SECURE_AXI_PROT_SECURE_OFFS		0
+#define MV_HMAC_AXI_PROT_SECURE_AXI_PROT_SECURE_MASK    \
+		(0x00000001 << MV_HMAC_AXI_PROT_SECURE_AXI_PROT_SECURE_OFFS)
 
 /************************** HMAC FRAME regs *********************************************************/
 
@@ -245,18 +247,18 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 
 /* Hmac_%m_send_q_%n_q_num_bpid */
-#define MV_HMAC_SEND_Q_Q_NUM_BPID_REG(n)							(0x8048 + 0x100*n)
-#define MV_HMAC_SEND_Q_Q_NUM_BPID_QNUM_OFFS		0
-#define MV_HMAC_SEND_Q_Q_NUM_BPID_QNUM_MASK    \
-		(0x00000fff << MV_HMAC_SEND_Q_Q_NUM_BPID_QNUM_OFFS)
+#define MV_HMAC_SEND_Q_NUM_BPID_REG(n)							(0x8048 + 0x100*n)
+#define MV_HMAC_SEND_Q_NUM_BPID_QNUM_OFFS		0
+#define MV_HMAC_SEND_Q_NUM_BPID_QNUM_MASK    \
+		(0x00000fff << MV_HMAC_SEND_Q_NUM_BPID_QNUM_OFFS)
 
-#define MV_HMAC_SEND_Q_Q_NUM_BPID_BPID_OFFS		0
-#define MV_HMAC_SEND_Q_Q_NUM_BPID_BPID_MASK    \
-		(0x000000ff << MV_HMAC_SEND_Q_Q_NUM_BPID_BPID_OFFS)
+#define MV_HMAC_SEND_Q_NUM_BPID_BPID_OFFS		0
+#define MV_HMAC_SEND_Q_NUM_BPID_BPID_MASK    \
+		(0x000000ff << MV_HMAC_SEND_Q_NUM_BPID_BPID_OFFS)
 
-#define MV_HMAC_SEND_Q_Q_NUM_BPID_BM_ALLOC_COUNT_OFFS		8
-#define MV_HMAC_SEND_Q_Q_NUM_BPID_BM_ALLOC_COUNT_MASK    \
-		(0x00000007 << MV_HMAC_SEND_Q_Q_NUM_BPID_BM_ALLOC_COUNT_OFFS)
+#define MV_HMAC_SEND_Q_NUM_BPID_BM_ALLOC_COUNT_OFFS		8
+#define MV_HMAC_SEND_Q_NUM_BPID_BM_ALLOC_COUNT_MASK    \
+		(0x00000007 << MV_HMAC_SEND_Q_NUM_BPID_BM_ALLOC_COUNT_OFFS)
 
 
 /* Hmac_%m_send_q_%n_status */
@@ -283,29 +285,31 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 
 /* Hmac_%m_send_q_%n_timeout */
-#define MV_HMAC_SEND_Q_TIMEOUT_REG(n)							(0x8050 + n)
+#define MV_HMAC_SEND_Q_TIMEOUT_REG(n)							(0x8050 + 0x100*n)
 #define MV_HMAC_SEND_Q_TIMEOUT_SQ_TIME_OUT_0_OFFS		5
 #define MV_HMAC_SEND_Q_TIMEOUT_SQ_TIME_OUT_0_MASK    \
 		(0x000007ff << MV_HMAC_SEND_Q_TIMEOUT_SQ_TIME_OUT_0_OFFS)
 
 /* HMAC Frame unit tables offsets */
-#define MV_PP3_HMAC_RQ_ADDR_LOW			0x0000
-#define MV_PP3_HMAC_RQ_ADDR_HIGH		0x0004
-#define MV_PP3_HMAC_RQ_SIZE				0x0008
-#define MV_PP3_HMAC_RQ_OCC_STATUS		0x000C
-#define MV_PP3_HMAC_RQ_AXI_ATTR			0x0010
-#define MV_PP3_HMAC_RQ_EVENT_GROUP		0x0014
-#define MV_PP3_HMAC_RQ_INT_THRESH		0x0018
-#define MV_PP3_HMAC_RQ_BACK_PRES0		0x001c
-#define MV_PP3_HMAC_RQ_BACK_PRES1		0x0020
-
-#define MV_PP3_HMAC_SQ_ADDR_LOW			0x0040
-#define MV_PP3_HMAC_SQ_ADDR_HIGH		0x0044
-#define MV_PP3_HMAC_SQ_SIZE				0x0048
-#define MV_PP3_HMAC_SQ_OCC_STATUS		0x004C
-#define MV_PP3_HMAC_SQ_AXI_ATTR			0x0050
-#define MV_PP3_HMAC_SQ_EVENT_GROUP		0x0054
-#define MV_PP3_HMAC_SQ_SW_QNUM_TDEST	0x0058
+#define MV_PP3_HMAC_RQ_ADDR_LOW(n)		(0x0000 + 0x100*n)
+#define MV_PP3_HMAC_RQ_ADDR_HIGH(n)		(0x0004 + 0x100*n)
+#define MV_PP3_HMAC_RQ_SIZE(n)			(0x0008 + 0x100*n)
+#define MV_PP3_HMAC_RQ_OCC_STATUS(n)	(0x000C + 0x100*n)
+#define MV_PP3_HMAC_RQ_AXI_ATTR(n)		(0x0010 + 0x100*n)
+#define MV_PP3_HMAC_RQ_EVENT_GROUP(n)	(0x0014 + 0x100*n)
+#define MV_PP3_HMAC_RQ_INT_THRESH(n)	(0x0018 + 0x100*n)
+#define MV_PP3_HMAC_RQ_BACK_PRES0(n)	(0x001c + 0x100*n)
+#define MV_PP3_HMAC_RQ_BACK_PRES1(n)	(0x0020 + 0x100*n)
+
+#define MV_PP3_HMAC_SQ_ADDR_LOW(n)		(0x0040 + 0x100*n)
+#define MV_PP3_HMAC_SQ_ADDR_HIGH(n)		(0x0044 + 0x100*n)
+#define MV_PP3_HMAC_SQ_SIZE(n)			(0x0048 + 0x100*n)
+#define MV_PP3_HMAC_SQ_OCC_STATUS(n)	(0x004C + 0x100*n)
+#define MV_PP3_HMAC_SQ_AXI_ATTR(n)		(0x0050 + 0x100*n)
+#define MV_PP3_HMAC_SQ_EVENT_GROUP(n)	(0x0054 + 0x100*n)
+#define MV_PP3_HMAC_SQ_SW_QNUM_TDEST(n)	(0x0058 + 0x100*n)
+
+#define MV_PP3_HMAC_OCC_COUNTER_MASK	0xFFFF
 /**/
 
 #endif /* __mvHmacRegs_h__ */
-- 
1.7.5.4

