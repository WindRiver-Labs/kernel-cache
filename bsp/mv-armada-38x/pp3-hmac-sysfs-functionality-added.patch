From 7e883a3f19521d40231a96008ec6c2937bf310ec Mon Sep 17 00:00:00 2001
From: Yelena <yelena@marvell.com>
Date: Mon, 3 Mar 2014 10:39:05 +0200
Subject: [PATCH 1415/1825] pp3: hmac sysfs functionality added

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit b7108efe36044a24c059ad80dba979b64c09814d

	Makefile changed with file compilation groups
	Fixed silicon base address init process

Change-Id: I7902a6afb80ca1bbc39027c3d6c3394c36147d2f
Signed-off-by: Yelena <yelena@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/6055
Reviewed-by: Ernest Villion <ernestv@marvell.com>
Reviewed-by: Uri Eliyahu <uriel@marvell.com>
Tested-by: Star_Automation <star@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/net/ethernet/marvell/pp3/Makefile          |    5 +-
 drivers/net/ethernet/marvell/pp3/common/mv_hw_if.h |    5 +-
 drivers/net/ethernet/marvell/pp3/hmac/mv_hmac.c    |   51 +++++-
 drivers/net/ethernet/marvell/pp3/hmac/mv_hmac.h    |   13 ++-
 .../net/ethernet/marvell/pp3/hmac/mv_hmac_regs.h   |   10 +
 .../net/ethernet/marvell/pp3/hmac/mv_hmac_sysfs.c  |  191 ++++++++++++++++++++
 6 files changed, 263 insertions(+), 12 deletions(-)
 create mode 100644 drivers/net/ethernet/marvell/pp3/hmac/mv_hmac_sysfs.c

diff --git a/drivers/net/ethernet/marvell/pp3/Makefile b/drivers/net/ethernet/marvell/pp3/Makefile
index 011f7d1..2922254 100644
--- a/drivers/net/ethernet/marvell/pp3/Makefile
+++ b/drivers/net/ethernet/marvell/pp3/Makefile
@@ -6,5 +6,6 @@ obj-$(CONFIG_MV_PP3) += mv_pp3.o
 
 ccflags-y       += -Idrivers/net/ethernet/marvell/pp3
 
-mv_pp3-objs := net_dev/mv_netdev.o hmac/mv_hmac.o emac/mv_emac.o emac/mv_emac_sysfs.o gop/mv_gop.o fw/mv_channel_if.o \
-		common/mv_stack.o
+mv_pp3-objs := net_dev/mv_netdev.o hmac/mv_hmac.o emac/mv_emac.o
+mv_pp3-objs += emac/mv_emac_sysfs.o hmac/mv_hmac_sysfs.o
+mv_pp3-objs += gop/mv_gop.o fw/mv_channel_if.o common/mv_stack.o
diff --git a/drivers/net/ethernet/marvell/pp3/common/mv_hw_if.h b/drivers/net/ethernet/marvell/pp3/common/mv_hw_if.h
index 7395b5f..6bbd392 100644
--- a/drivers/net/ethernet/marvell/pp3/common/mv_hw_if.h
+++ b/drivers/net/ethernet/marvell/pp3/common/mv_hw_if.h
@@ -125,9 +125,6 @@ static INLINE void mv_pp3_hw_reg_write(u32 access_addr, u32 data)
 	writel(data, access_addr);
 }
 
-static INLINE u32 mv_hw_silicon_base_addr_get(void)
-{
-	return 0xe0000000;
-}
+u32 mv_hw_silicon_base_addr_get(void);
 
 #endif /* __mvHwIf_h__ */
diff --git a/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac.c b/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac.c
index 4655334..289218d 100644
--- a/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac.c
+++ b/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac.c
@@ -68,7 +68,6 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include <linux/slab.h>
 #include "common/mv_hw_if.h"
 #include "hmac/mv_hmac.h"
-#include "hmac/mv_hmac_regs.h"
 
 /* bitmap to store queues state (allocated/free) per frame */
 static u32 mv_pp3_hmac_queue_act[MV_PP3_HMAC_MAX_FRAME] = {0};
@@ -85,6 +84,15 @@ struct mv_pp3_hmac_queue_ctrl *mv_hmac_txq_handle[MV_PP3_HMAC_MAX_FRAME][MV_PP3_
 static int mv_pp3_hmac_queue_create(struct mv_pp3_hmac_queue_ctrl *q_ctrl, int bytes);
 
 /* general functions */
+/* HMAC unit init */
+void mv_pp3_hmac_init(void)
+{
+	int base = mv_hw_silicon_base_addr_get();
+
+	mv_pp3_hmac_gl_unit_base(base + MV_PP3_HMAC_GL_UNIT_OFFSET);
+	mv_pp3_hmac_frame_unit_base(base + MV_PP3_HMAC_FR_UNIT_OFFSET, MV_PP3_HMAC_FR_INST_OFFSET);
+}
+
 /* store unit base address = silicon base address + unit offset */
 void mv_pp3_hmac_gl_unit_base(unsigned int unit_offset)
 {
@@ -336,10 +344,16 @@ static void mv_pp3_hmac_fr_reg_print(int frame, char *reg_name, u32 reg)
 	pr_info("  %-32s: 0x%x = 0x%08x\n", reg_name, reg, mv_pp3_hmac_frame_reg_read(frame, reg));
 }
 
+static void mv_pp3_hmac_global_reg_print(char *reg_name, u32 reg)
+{
+	pr_info("  %-32s: 0x%x = 0x%08x\n", reg_name, reg, mv_pp3_hmac_gl_reg_read(reg));
+}
+
 /* dump hmac queue registers */
-void mv_pp3_hmac_rxq_regs(int frame, int queue)
+void mv_pp3_hmac_rxq_regs_dump(int frame, int queue)
 {
-	pr_info("-------------- HMAC RX (frame = %d, queue = %d) regs -----------\n", frame, queue);
+	pr_info("\n-------------- HMAC RX (frame = %d, queue = %d) regs (0x%x)-----------\n",
+		frame, queue, pp3_hmac_fr.base_addr + pp3_hmac_fr.ins_offs * frame);
 	mv_pp3_hmac_fr_reg_print(frame, "QUEUE_CTRL", MV_HMAC_REC_Q_CTRL_REG(queue));
 	mv_pp3_hmac_fr_reg_print(frame, "QUEUE_STATUS", MV_HMAC_REC_Q_STATUS_REG(queue));
 	mv_pp3_hmac_fr_reg_print(frame, "TIMEOUT", MV_HMAC_REC_Q_TIMEOUT_REG(queue));
@@ -352,9 +366,10 @@ void mv_pp3_hmac_rxq_regs(int frame, int queue)
 }
 
 /* dump hmac queue registers */
-void mv_pp3_hmac_txq_regs(int frame, int queue)
+void mv_pp3_hmac_txq_regs_dump(int frame, int queue)
 {
-	pr_info("-------------- HMAC TX (frame = %d, queue = %d) regs -----------\n", frame, queue);
+	pr_info("\n-------------- HMAC TX (frame = %d, queue = %d) regs (0x%x)-----------\n",
+		frame, queue, pp3_hmac_fr.base_addr + pp3_hmac_fr.ins_offs * frame);
 	mv_pp3_hmac_fr_reg_print(frame, "QUEUE_CTRL", MV_HMAC_SEND_Q_CTRL_REG(queue));
 	mv_pp3_hmac_fr_reg_print(frame, "QM_NUM", MV_HMAC_SEND_Q_NUM_BPID_REG(queue));
 	mv_pp3_hmac_fr_reg_print(frame, "QUEUE_STATUS", MV_HMAC_SEND_Q_STATUS_REG(queue));
@@ -365,3 +380,29 @@ void mv_pp3_hmac_txq_regs(int frame, int queue)
 	mv_pp3_hmac_fr_reg_print(frame, "AXI_ATTR", MV_PP3_HMAC_SQ_AXI_ATTR(queue));
 	mv_pp3_hmac_fr_reg_print(frame, "EVENT_GROUP", MV_PP3_HMAC_SQ_EVENT_GROUP(queue));
 }
+
+void mv_pp3_hmac_frame_regs_dump(int frame)
+{
+	pr_info("\n-------------- HMAC Frame %d regs -----------\n", frame);
+	mv_pp3_hmac_global_reg_print("VMID", MV_HMAC_VMID_FRAME_REG(frame));
+	mv_pp3_hmac_global_reg_print("Event Address Low", MV_HMAC_EVENT_ADDR_LOW_REG(frame));
+	mv_pp3_hmac_global_reg_print("Event Address High", MV_HMAC_EVENT_ADDR_HIGH_REG(frame));
+	mv_pp3_hmac_global_reg_print("DRAM Upd Timeout", MV_HMAC_DRAM_UPDATE_TIME_OUT_REG(frame));
+	mv_pp3_hmac_global_reg_print("DRAM Upd Threshold", MV_HMAC_DRAM_UPDATE_THRESHOLD_REG(frame));
+	mv_pp3_hmac_global_reg_print("AXI Protection Secure", MV_HMAC_AXI_PROT_SECURE_REG(frame));
+}
+
+void mv_pp3_hmac_global_regs_dump(void)
+{
+	pr_info("\n-------------- HMAC Golbal regs (0x%x) -----------\n", pp3_hmac_gl.base_addr);
+	mv_pp3_hmac_global_reg_print("ECO", MV_HMAC_ECO_REG);
+	mv_pp3_hmac_global_reg_print("BW Control", MV_HMAC_BW_CTRL_REG);
+	mv_pp3_hmac_global_reg_print("Receive QM Port", MV_HMAC_REC_QM_PORT_NUMBER_REG);
+	mv_pp3_hmac_global_reg_print("AXI Interrupt Cause", MV_HMAC_AXI_INT_CAUSE);
+	mv_pp3_hmac_global_reg_print("AXI Interrupt Mask", MV_HMAC_AXI_INT_MASK);
+	mv_pp3_hmac_global_reg_print("AXI Interrupt Syndrome", MV_HMAC_AXI_INT_SYNDROME);
+	mv_pp3_hmac_global_reg_print("MISC Interrupt Cause", MV_HMAC_MISC_INT_CAUSE);
+	mv_pp3_hmac_global_reg_print("MISC Interrupt Mask", MV_HMAC_MISC_INT_MASK);
+	mv_pp3_hmac_global_reg_print("MISC Interrupt Syndrome", MV_HMAC_MISC_INT_SYNDROME);
+	mv_pp3_hmac_global_reg_print("HMAC Busy", MV_HMAC_BUSY);
+}
diff --git a/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac.h b/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac.h
index 1a10b47..27de250 100644
--- a/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac.h
+++ b/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac.h
@@ -65,6 +65,9 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #ifndef __mvHmac_h__
 #define __mvHmac_h__
 
+#include <linux/netdevice.h>
+
+#include "common/mv_hw_if.h"
 #include "hmac/mv_hmac_regs.h"
 
 #define MV_PP3_HMAC_MAX_FRAME			(16)
@@ -151,6 +154,7 @@ static inline void mv_pp3_hmac_frame_reg_write(int frame_id, u32 reg, u32 data)
 /*****************************************
  *        HMAC unit init functions       *
  *****************************************/
+void mv_pp3_hmac_init(void);
 /* Init HMAC global unit base address
  * unit_offset = silicon base address + unit offset  */
 void mv_pp3_hmac_gl_unit_base(u32 unit_offset);
@@ -304,7 +308,7 @@ static inline u8 *mv_pp3_hmac_txq_next_cfh(int frame, int queue, int size)
 
 		cfh->pkt_length = end_free_dg * MV_PP3_HMAC_DG_SIZE;
 		cfh->qm_cntrl = MV_PP3_HMAC_CFH_DUMMY; /* set bit 'W' */
-		qctrl->dummy_dg = end_free_dg;
+;		qctrl->dummy_dg = end_free_dg;
 	}
 	qctrl->next_proc = qctrl->first + (size * MV_PP3_HMAC_DG_SIZE);
 	qctrl->occ_dg += size;
@@ -328,5 +332,12 @@ void mv_pp3_hmac_queue_bm_mode_cfg(int frame, int queue);
  * q_num - is a number of QM queue                   */
 void mv_pp3_hmac_queue_qm_mode_cfg(int frame, int queue, int q_num);
 
+/* dump hmac queue registers */
+void mv_pp3_hmac_rxq_regs_dump(int frame, int queue);
+void mv_pp3_hmac_txq_regs_dump(int frame, int queue);
+void mv_pp3_hmac_frame_regs_dump(int frame);
+void mv_pp3_hmac_global_regs_dump(void);
+
+int mv_pp3_hmac_sysfs_init(struct kobject *pp3_kobj);
 
 #endif /* __mvHmac_h__ */
diff --git a/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac_regs.h b/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac_regs.h
index 3c034b4..f42490c 100644
--- a/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac_regs.h
+++ b/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac_regs.h
@@ -149,6 +149,16 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define MV_HMAC_DRAM_UPDATE_THRESHOLD_DRAM_UPDAT_THRESHOLD_MASK    \
 		(0x0000ffff << MV_HMAC_DRAM_UPDATE_THRESHOLD_DRAM_UPDAT_THRESHOLD_OFFS)
 
+/* HMAC AXI Interrupt Cause */
+#define MV_HMAC_AXI_INT_CAUSE								(0x0200)
+#define MV_HMAC_AXI_INT_MASK								(0x0204)
+#define MV_HMAC_AXI_INT_SYNDROME							(0x0208)
+#define MV_HMAC_MISC_INT_CAUSE								(0x0210)
+#define MV_HMAC_MISC_INT_MASK								(0x0214)
+#define MV_HMAC_MISC_INT_SYNDROME							(0x0218)
+
+/* HMAC Busy */
+#define MV_HMAC_BUSY									(0x0234)
 
 /* Hmac_axi_prot_secure_%m */
 #define MV_HMAC_AXI_PROT_SECURE_REG(m)							(0x0300 + 4*m)
diff --git a/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac_sysfs.c b/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac_sysfs.c
new file mode 100644
index 0000000..66813fa
--- /dev/null
+++ b/drivers/net/ethernet/marvell/pp3/hmac/mv_hmac_sysfs.c
@@ -0,0 +1,191 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include "hmac/mv_hmac.h"
+
+static ssize_t mv_hmac_help(char *b)
+{
+	int o = 0;
+
+	o += scnprintf(b+o, PAGE_SIZE-o, "\n");
+	o += scnprintf(b+o, PAGE_SIZE-o, "echo [f]         > f_regs      - Dump Global unit frame registers\n");
+	o += scnprintf(b+o, PAGE_SIZE-o, "echo [f] [q]     > rxq_regs    - Dump Frame RX queue registers\n");
+	o += scnprintf(b+o, PAGE_SIZE-o, "echo [f] [q]     > txq_regs    - Dump Frame TX queue registers\n");
+	o += scnprintf(b+o, PAGE_SIZE-o, "echo [u]         > reg_read    - Read Global unit register\n");
+	o += scnprintf(b+o, PAGE_SIZE-o, "echo [u] [v]     > reg_write   - Write Global unit register\n");
+	o += scnprintf(b+o, PAGE_SIZE-o, "echo [f] [u]     > f_reg_read  - Read Frame unit register\n");
+	o += scnprintf(b+o, PAGE_SIZE-o, "echo [f] [u] [v] > f_reg_write - Write Frame unit register\n");
+	o += scnprintf(b+o, PAGE_SIZE-o, "\n");
+	o += scnprintf(b+o, PAGE_SIZE-o, "parameters: [f] frame number\n");
+	o += scnprintf(b+o, PAGE_SIZE-o, "            [q] queue number\n");
+	o += scnprintf(b+o, PAGE_SIZE-o, "            [u] hex register address\n");
+	o += scnprintf(b+o, PAGE_SIZE-o, "            [v] hex value\n");
+
+	return o;
+}
+
+static ssize_t mv_hmac_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	/* const char      *name = attr->attr.name; */
+	int             off = 0;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	off = mv_hmac_help(buf);
+
+	return off;
+}
+
+static ssize_t mv_hmac_3_hex_store(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t len)
+{
+	const char      *name = attr->attr.name;
+	int             err;
+	unsigned int    p, u, v;
+	unsigned long   flags;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	/* Read first 3 parameters */
+	err = p = u = v = 0;
+	sscanf(buf, "%x %x %x", &p, &u, &v);
+
+	local_irq_save(flags);
+
+	if (!strcmp(name, "f_regs")) {
+		mv_pp3_hmac_global_regs_dump();
+		mv_pp3_hmac_frame_regs_dump(p);
+	} else if (!strcmp(name, "rxq_regs"))
+		mv_pp3_hmac_rxq_regs_dump(p, u);
+	else if (!strcmp(name, "txq_regs"))
+		mv_pp3_hmac_txq_regs_dump(p, u);
+	else if (!strcmp(name, "reg_write"))
+		mv_pp3_hmac_gl_reg_write(p, u);
+	else if (!strcmp(name, "reg_read")) {
+		v = mv_pp3_hmac_gl_reg_read(p);
+		pr_info("0x%x = 0x%x\n", p, v);
+	} else if (!strcmp(name, "f_reg_write"))
+		mv_pp3_hmac_frame_reg_write(p, u, v);
+	else if (!strcmp(name, "f_reg_read")) {
+		v = mv_pp3_hmac_frame_reg_read(p, u);
+		pr_info("0x%x = 0x%x\n", u, v);
+	} else {
+		err = 1;
+		pr_err("%s: illegal operation <%s>\n", __func__, attr->attr.name);
+	}
+
+	local_irq_restore(flags);
+
+	return err ? -EINVAL : len;
+}
+
+static DEVICE_ATTR(help, S_IRUSR, mv_hmac_show, NULL);
+static DEVICE_ATTR(f_regs, S_IWUSR, NULL, mv_hmac_3_hex_store);
+static DEVICE_ATTR(rxq_regs, S_IWUSR, NULL, mv_hmac_3_hex_store);
+static DEVICE_ATTR(txq_regs, S_IWUSR, NULL, mv_hmac_3_hex_store);
+static DEVICE_ATTR(reg_write, S_IWUSR, NULL, mv_hmac_3_hex_store);
+static DEVICE_ATTR(reg_read, S_IWUSR, NULL, mv_hmac_3_hex_store);
+static DEVICE_ATTR(f_reg_write, S_IWUSR, NULL, mv_hmac_3_hex_store);
+static DEVICE_ATTR(f_reg_read, S_IWUSR, NULL, mv_hmac_3_hex_store);
+
+
+static struct attribute *mv_hmac_attrs[] = {
+	&dev_attr_help.attr,
+	&dev_attr_f_regs.attr,
+	&dev_attr_rxq_regs.attr,
+	&dev_attr_txq_regs.attr,
+	&dev_attr_reg_write.attr,
+	&dev_attr_reg_read.attr,
+	&dev_attr_f_reg_write.attr,
+	&dev_attr_f_reg_read.attr,
+	NULL
+};
+
+static struct attribute_group mv_hmac_group = {
+	.name = "hmac",
+	.attrs = mv_hmac_attrs,
+};
+
+int mv_pp3_hmac_sysfs_init(struct kobject *pp3_kobj)
+{
+	int err;
+
+	err = sysfs_create_group(pp3_kobj, &mv_hmac_group);
+	if (err) {
+		pr_err("sysfs group failed %d\n", err);
+		return err;
+	}
+
+	return err;
+}
+
+int mv_pp3_hmac_sysfs_exit(struct kobject *hmac_kobj)
+{
+	sysfs_remove_group(hmac_kobj, &mv_hmac_group);
+	return 0;
+}
-- 
1.7.5.4

