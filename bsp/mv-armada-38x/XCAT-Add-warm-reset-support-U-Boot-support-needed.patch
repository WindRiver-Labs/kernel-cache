From 6d7b9f4b9e364a86e03b3eb41b582e200a089259 Mon Sep 17 00:00:00 2001
From: Igor Petrik <igorp@marvell.com>
Date: Wed, 26 Dec 2012 13:47:02 +0200
Subject: [PATCH 0428/1825] XCAT: Add warm reset support (U-Boot support
 needed)

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 6ce64603ad2f32a84d5a61475e44b18ab102129c

Change-Id: I3df7d0838e2a49d1434b8b5cc0e66d0aa2f12673
Signed-off-by: Igor Petrik <igorp@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 LspReleaseNotes_KW.txt                             |  276 --------------------
 arch/arm/mach-kirkwood/Kconfig                     |   13 +
 arch/arm/mach-kirkwood/common.c                    |    2 +-
 arch/arm/mach-kirkwood/config/mvSysHwConfig.h      |   49 ++--
 arch/arm/mach-kirkwood/include/mach/bridge-regs.h  |    2 +-
 arch/arm/mach-kirkwood/include/mach/kirkwood.h     |   50 ++++-
 .../mv_ethernet/mv_xcat_pp/xcat98dx-core.c         |  125 ++++++---
 .../mv_ethernet/mv_xcat_pp/xcat98dx-core.h         |   19 +-
 .../mv_ethernet/mv_xcat_pp/xcat98dx-switch.c       |    7 +-
 .../mv_ethernet/mv_xcat_pp/xcat98dx-switch.h       |    9 +
 .../mv_drivers_lsp/mv_switch/mv_switch.h           |   17 +-
 arch/arm/plat-orion/time.c                         |   41 ++--
 12 files changed, 233 insertions(+), 377 deletions(-)
 delete mode 100644 LspReleaseNotes_KW.txt

diff --git a/LspReleaseNotes_KW.txt b/LspReleaseNotes_KW.txt
deleted file mode 100644
index 230ca95..0000000
--- a/LspReleaseNotes_KW.txt
+++ /dev/null
@@ -1,276 +0,0 @@
-01/Jan/2012
-
-Release notes for KW and XCAT LSP linux-3.2.34_A300_XCAT_2012_Q4.0_PQ.
-======================================================================
-
-
-Notes:
-	* See XCAT section at the end.
-	* This LSP is compatible with U-Boot release 3.5.9 and above
-	* This LSP release has a new architecture using "mach-kirkwood"
-	  and "plat-orion" in order to minimize the LSP footprint
-
-Table of Contents
------------------
-
-1.  Contents of this Release
-2.  HowTo build
-3.  Changes from previous releases
-4.  Known Issues
-5.  Notes
-6.  XCAT notes
-7.  Disclaimer
-
-
-1. Contents of This Release
-===========================
-
-	Included in current release:
-	* Support for ttyS0.
-	* Interrupts handling.
-	* L2 support + optimized cache opertaions.
-	* USB host support.
-	* CESA support.
-	* PCI and PEX support.
-	* Standard network interface support for the KW giga port.
-	* Gateway network interface support for the RD on board switch.
-	    - L2 IGMP Snooping.
-	* Marvell SATA support using Linux Kernel mainline LIBATA driver
-	* SD/SDIO/MMC driver.
-	* Nand flash driver.
-	* SPI flash driver.
-	* Memory transfer accelerations by using the XOR-DMA engine.
-	* RTC support.
-	* Support for passing Marvell Tag list from uboot.
-	* Kconfig scripts for KW platforms configuration.
-	* Heart Beat led.
-	* Reset support.
-	* MV shell Proc FS.
-	* Transport Stream unit. (See known issues below).
-	* XCAT98DX SoC support (based on KW 88F6281 SoC).
-	* Openswan support (version 2.6.37)
-	* Audio Alsa driver.
-	* This release is a patch to Linux 3.2.34 which can be download from
-          (www.kernel.org or https://github.com/mirrors/linux-2.6)
-
-	Unsupported features:
-	---------------------
-	* Voice/phone/telephony driver.
-	* USB device support.
-	* Advanced Gateway (Switch) network interface features:
-	  - All-Multicast mode is not supported in network interfaces
-	    connected to the Switch.
-	* Big Endian support
-
-	Configuration:
-	--------------
-	* mv_kw_defconfig		-> no GW/NAT support
-	* mv_kw_gtw_defconfig		-> default configuration
-	* mv_kw_be_gtw_defconfig	-> default configuration
-	* mv_kw_xcat_defconfig		-> xcat support
-
-	Supported boards:
-	-----------------
-	* DB-88F6281-BP-A
-	* DB-88F6192-BP-A (6190)
-	* DB-88F6180-BP-A
-	* RD-88F6281-A
-	* RD-88F6192-A (6190)
-	* DB-88F6282-A-BP
-	* RD-88F6282-A
-	* DB-XCAT-24GE
-
-
-2. HowTo build
-===============
-	This release was built using SDK_EBU_2012_Q4.2 (gcc version 4.6.3)
-	get linux-3.2.34 from www.kernel.org
-	change its name to the release name (linux_feroceon_...).
-	unzip the release.zip in the directory where you put the kernel, say A to replace all.
-	define ARCH & CROSS_COMPILE env variables
-	'export ARCH=arm'
-	'export CROSS_COMPILE=<compiler name>'
-	(example: 'export CROSS_COMPILE=.../SDK-6.0.1/\
-		armv5-marvell-linux-gnueabi-softfp_i686/\
-		bin/arm-marvell-linux-gnueabi-')
-	cd to the kernel directory.
-	'make mrproper'
-	config the kernel:
-	'make <platform>_defconfig'
-	'make uImage'
-	the kernel uImage will be found under arch/arm/boot/.
-
-
-3. Changes from previous releases
-=================================
-Note:
-This release has new LSP architecture in order to minimize LSP footprint.
-It was ported from LSP release 6.0.1.
-
-
-4. Known Issues
-===============
-
-NAS:
-- From this version in order to get more optimized results, EXT4 should be used
-  instead of XFS.
-
-Counter/Timer:
-- Due to built-in +/-30 PPM deviation of on-board 25MHz main Xtal, KW
-  internal core clock may drift ~2.5 seconds per day.
-  The +/-30 PPM deviation is according to manufacturer specification.
-
-USB:
-- Linux doesn't handle well a case of 2 ISO devices(full speed) working
-  simultaneously through the high speed hub.
-
-NAND:
-- When working with 4bit ECC configuration, it is not recommended to perform
-  read from an erased page, since no ECC was calculated for this page.
-  In this case we compared the page data against 512 bytes of 0xFF and if we
-  get a match, then return gracefully, otherwise, there is an uncorrectable
-  error.
-  To enable 4bit ECC support in LSP (dynamically), add "nandEcc=4bit" string
-  to U-Boot bootargs.
-
-UBIFS:
-- When UBIFS support is enabled, the kernel configuration option
-  CONFIG_MTD_NAND_VERIFY_WRITE must be disabled, and the CONFIG_NFTL,
-  CONFIG_NFTL_RW options need to be enabled.
-
-TWSI:
-- 2 TWSI drivers are supported within the LSP: based HAL driver and standard Linux
-  driver.
-  The HAL based driver is used by the board environment initialization
-  code (at kernel startup), and upon phone drivers initialization.
-  The Linux driver is being used by the I2S audio codec.
-  In order to use the I2S audio codec the i2c-mv64xxx.ko module should
-  be loaded (after system startup).
-  In a case where both phone and I2S codec drivers should exist in the system,
-  then the Linux I2C module should be loaded (insmod) only after the phone
-  driver is initialized (MMP package is loaded into the system).
-  Additionally, the HAL based driver is not reentrant and can not be used
-  simultaneously by more than one source.
-
-Networking:
-
-- Networking when CPU frequency is low (800MHz) may generate overrun error:
-  " bad rx status 2fc3a86b, (overrun error)".
-
-- NFP doesn't support packets with MTU bigger than 1500 Bytes.
-
-Transport Stream:
-- The transport stream unit driver supports only non-aggregation mode
-  for read and write operations.
-
-Storage:
-- USB VBUS and SDIO WP is not operational on the following boards since
-  it conflicts MPP settings for add-on modules:
-  o DB-88F6281-BP-A: SDIO and USB device
-  o DB-88F6180-BP-A: USB device
-
-- When disconnecting a SATA device while it used by the kernel (e.g. contains
-  unmounted file system), the user must delete the block devices on that
-  channel (using the sysfs), otherwise, farther hotswap events on that channel
-  may cause to kernel crash.
-
-  In order to overcome this issue,
-  We recommend that the user will cleanly remove the scsi dev through the sysfs by using the
-  following command:
-  #echo 1 > /sys/class/scsi_host/hostH/device/targetH:B:T/H:B:T:L/delete
-  Where H, B, T and L stands for Host, Bus, Target and Lun.
-
-  In case that the disk was removed brutally, the udev should detect this event and should remove
-  the device from the sysfs by using the same command as above.
-
-- Thor 6145 has issues with hot-swap, NCQ, port-multiplier and
-  ATAPI support.
-
-- Thor 6121 has issues with hot-swap and ATAPI support.
-
-- This release support up to 512MB of DRAM with current memory layout definition.
-
-Configs:
-- CONFIG_ARM_UNWIND can't be used together with CONFIG_REORDER
-
-
-5. Notes
-=========
-	* No notes currently.
-
-
-6.  XCAT notes
-==============
-	* This LSP is compatible with U-Boot release 5.3.4_005 and above
-	* LSP supports the below interfaces:
-	  - USB host.
-	  - Prestera Switch (internal RGMII mode).
-	  - Interrupts handling.
-	  - L2 support + optimized cache opertaions.
-	  - USB host support.
-	  - CESA support.
-	  - PEX support.
-	  - Standard network interface support for the KW giga port.
-	  - Nand flash driver.
-	  - SPI flash driver.
-	  - Kconfig scripts for KW platforms configuration.
-	  - MV shell Proc FS.
-
-	Unsupported features:
-	---------------------
-	- USB device support.
-	- Big Endian support
-
-
-7. Disclaimer
-=============
-This document provides preliminary information about the products described, and such
-information should not be used for purpose of final design. Visit the Marvell(r) web
-site at www.marvell.com for the latest information on Marvell products.
-
-No part of this document may be reproduced or transmitted in any form or by any means,
-electronic or mechanical, including photocopying and recording, for any purpose,
-without the express written permission of Marvell. Marvell retains the right to make
-changes to this document at any time, without notice. Marvell makes no warranty of
-any kind, expressed or implied, with regard to any information contained in this
-document, including, but not limited to, the implied warranties of merchantability
-or fitness for any particular purpose. Further, Marvell does not warrant the accuracy
-or completeness of the information, text, graphics, or other items contained within
-this document. Marvell makes no commitment either to update or to keep current the
-information contained in this document. Marvell products are not designed for use in
-life-support equipment or applications that would cause a life-threatening situation
-if any such products failed. Do not use Marvell products in these types of equipment
-or applications. The user should contact Marvell to obtain the latest specifications
-before finalizing a product design. Marvell assumes no responsibility, either for use
-of these products or for any infringements of patents and trademarks, or other rights
-of third parties resulting from its use. No license is granted under any patents,
-patent rights, or trademarks of Marvell.These products may include one or more
-optional functions. The user has the choice of implementing any particular optional
-function. Should the user choose to implement any of these optional functions, it is
-possible that the use could be subject to third party intellectual property rights.
-Marvell recommends that the user investigate whether third party intellectual property
-rights are relevant to the intended use of these products and obtain licenses as
-appropriate under relevant intellectual property rights.
-Marvell comprises Marvell Technology Group Ltd. (MTGL) and its subsidiaries, Marvell
-International Ltd. (MIL), Marvell Semiconductor, Inc. (MSI), Marvell Asia Pte Ltd. (MAPL),
-Marvell Japan K.K. (MJKK), Marvell Semiconductor Israel Ltd. (MSIL), SysKonnect GmbH,
-and Radlan Computer Communications, Ltd.
-Export Controls.  With respect to any of Marvell's Information, the user or recipient,
-in the absence of appropriate U.S. government authorization, agrees: 1) not to re-export
-or release any such information consisting of technology, software or source code
-controlled for national security reasons by the U.S. Export Control Regulations ("EAR"),
-to a national of EAR Country Groups D:1 or E:2; 2) not to export the direct product of
-such technology or such software, to EAR Country Groups D:1 or E:2, if such technology or
-software and direct products thereof are controlled for national security reasons by the
-EAR; and, 3) in the case of technology controlled for national security reasons under the
-EAR where the direct product of the technology is a complete plant or component of a plant,
-not to export to EAR Country Groups D:1 or E:2 the direct product of the plant or major
-component thereof, if such direct product is controlled for national security reasons by
-the EAR, or is subject to controls under the U.S. Munitions List  ("USML").  At all times
-hereunder, the recipient of any such information agrees that they shall be deemed to have
-manually signed this document in connection with their receipt of any such information.
-Copyright (c) 2004.  Marvell.  All rights reserved.  Marvell, the Marvell logo, Moving
-Forward Faster, Alaska, and GalNet are registered trademarks of Marvell.  Discovery,
-Fastwriter, GalTis, Horizon, Libertas, Link Street, NetGX, PHY Advantage, Prestera,
-Raising The Technology Bar, UniMAC, Virtual Cable Tester, and Yukon are trademarks of
-Marvell.  All other trademarks are the property of their respective owners.
diff --git a/arch/arm/mach-kirkwood/Kconfig b/arch/arm/mach-kirkwood/Kconfig
index 1cf6606..d52de41 100644
--- a/arch/arm/mach-kirkwood/Kconfig
+++ b/arch/arm/mach-kirkwood/Kconfig
@@ -18,6 +18,19 @@ config MACH_XCAT98DX
 config MV_XCAT98DX
 	bool
 
+config MV_XCAT98DX_WARM_RESET
+	depends on MACH_XCAT98DX && NO_HZ
+	bool "Marvell XCAT-98DX Development Board Warm reset support"
+	default n
+	help
+	  Say 'Y' here if you want your kernel to support the Warm reset on
+	  Marvell xCat-98DX Development Board
+	  U-Boot support required - U-Boot should enable external reset
+	  and restore high Address Map windows to default.
+
+config MV_XCAT98DX_WARM_RESET
+	bool
+
 config MACH_RD88F6192_NAS
 	bool "Marvell RD-88F6192-NAS Reference Board"
 	help
diff --git a/arch/arm/mach-kirkwood/common.c b/arch/arm/mach-kirkwood/common.c
index 621e986..1d38a15 100644
--- a/arch/arm/mach-kirkwood/common.c
+++ b/arch/arm/mach-kirkwood/common.c
@@ -366,7 +366,7 @@ static void __init kirkwood_timer_init(void)
 {
 	kirkwood_tclk = kirkwood_find_tclk();
 
-	orion_time_init(BRIDGE_VIRT_BASE, BRIDGE_INT_TIMER1_CLR,
+	orion_time_init(BRIDGE_VIRT_BASE, BRIDGE_INT_TIMER0_CLR,
 			IRQ_KIRKWOOD_BRIDGE, kirkwood_tclk);
 }
 
diff --git a/arch/arm/mach-kirkwood/config/mvSysHwConfig.h b/arch/arm/mach-kirkwood/config/mvSysHwConfig.h
index 1ecb1c4..138a752 100644
--- a/arch/arm/mach-kirkwood/config/mvSysHwConfig.h
+++ b/arch/arm/mach-kirkwood/config/mvSysHwConfig.h
@@ -1,7 +1,7 @@
-/*******************************************************************************
+/******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-********************************************************************************
+*******************************************************************************
 Marvell GPL License Option
 
 If you received this File from Marvell, you may opt to use, redistribute and/or
@@ -16,8 +16,8 @@ WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
 DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 
-*******************************************************************************/
-/*******************************************************************************
+******************************************************************************/
+/******************************************************************************
 * mvSysHwCfg.h - Marvell system HW configuration file
 *
 * DESCRIPTION:
@@ -26,7 +26,7 @@ disclaimer.
 * DEPENDENCIES:
 *       None.
 *
-*******************************************************************************/
+******************************************************************************/
 
 #ifndef __INCmvSysHwConfigh
 #define __INCmvSysHwConfigh
@@ -183,7 +183,8 @@ disclaimer.
 #endif /* ETH_DESCR_IN_SRAM or ETH_DESCR_IN_SDRAM*/
 
 /* SW Sync-Barrier: not relevant for 88fxx81*/
-/* Reasnable to define this macro when descriptors in SRAM and buffers in DRAM */
+/* Reasnable to define this macro
+	when descriptors in SRAM and buffers in DRAM */
 /* In RX the CPU theoretically might see himself as the descriptor owner,      */
 /* although the buffer hadn't been written to DRAM yet. Performance cost.      */
 /* #define INCLUDE_SYNC_BARR */
@@ -205,8 +206,8 @@ disclaimer.
 /* DRAM cache coherency configuration */
 #define MV_CACHE_COHERENCY  MV_CACHE_COHER_SW
 
-
-#define ETHER_DRAM_COHER    MV_CACHE_COHER_SW   /* No HW coherency in 88Fxx81 devices */
+/*No HW coherency in 88Fxx81 devices*/
+#define ETHER_DRAM_COHER    MV_CACHE_COHER_SW
 
 #if (ETHER_DRAM_COHER == MV_CACHE_COHER_HW_WB)
  #define ETH_SDRAM_CONFIG_STR    "DRAM HW cache coherency (write-back)"
@@ -243,8 +244,8 @@ disclaimer.
 #define MV_ETH_TX_Q_NUM     CONFIG_MV_ETH_TXQ
 
 /* interrupt coalescing setting */
-#define ETH_TX_COAL    		    200
-#define ETH_RX_COAL    		    200
+#define ETH_TX_COAL		    200
+#define ETH_RX_COAL		    200
 
 /* Checksum offloading */
 #define TX_CSUM_OFFLOAD
@@ -299,11 +300,11 @@ disclaimer.
 	#define MV_TDM_PCM_CLK_2MHZ
 #endif
 
-/* We use the following registers to store DRAM interface pre configuration   */
-/* auto-detection results													  */
-/* IMPORTANT: We are using mask register for that purpose. Before writing     */
-/* to units mask register, make sure main maks register is set to disable     */
-/* all interrupts.                                                            */
+/* We use the following registers to store DRAM interface pre config */
+/* auto-detection results */
+/* IMPORTANT: We are using mask register for that purpose. Before writing */
+/* to units mask register, make sure main maks register is set to disable */
+/* all interrupts */
 #define DRAM_BUF_REG0   0x30810 /* sdram bank 0 size            */
 #define DRAM_BUF_REG1   0x30820 /* sdram config                 */
 #define DRAM_BUF_REG2   0x30830 /* sdram mode                   */
@@ -320,8 +321,8 @@ disclaimer.
 #define DRAM_BUF_REG13  0x60a04 /* dunit Ctrl High              */
 #define DRAM_BUF_REG14  0x60b00 /* sdram second DIMM exist      */
 
-/* Following the pre-configuration registers default values restored after    */
-/* auto-detection is done                                                     */
+/* Following the pre-configuration registers default values restored after   */
+/* auto-detection is done                                                    */
 #define DRAM_BUF_REG_DV 0
 
 /* System Mapping */
@@ -355,7 +356,14 @@ disclaimer.
 #define DEVICE_CS2_SIZE _1M
 
 /* Internal registers: size is defined in Controllerenvironment */
+#ifdef CONFIG_MV_XCAT98DX_WARM_RESET
+/* Warm reset requires default base for internal registers mapping
+	(U-Boot have to use same base) */
+#define INTER_REGS_BASE	0xD0000000
+#else
 #define INTER_REGS_BASE	0xF1000000
+#endif
+
 
 /* #define DDR_OPERATION_BASE	(INTER_REGS_BASE | 0x1418) */
 
@@ -363,10 +371,9 @@ disclaimer.
 #define MV_DRAM_AUTO_SIZE
 
 /* Board clock detection */
-#define TCLK_AUTO_DETECT    	/* Use Tclk auto detection   */
+#define TCLK_AUTO_DETECT	/* Use Tclk auto detection   */
 #define SYSCLK_AUTO_DETECT	/* Use SysClk auto detection */
-#define PCLCK_AUTO_DETECT  	/* Use PClk auto detection   */
-#define L2CLK_AUTO_DETECT 	/* Use L2Clk auto detection   */
+#define PCLCK_AUTO_DETECT	/* Use PClk auto detection   */
+#define L2CLK_AUTO_DETECT	/* Use L2Clk auto detection   */
 
 #endif /* __INCmvSysHwConfigh */
-
diff --git a/arch/arm/mach-kirkwood/include/mach/bridge-regs.h b/arch/arm/mach-kirkwood/include/mach/bridge-regs.h
index 086f25e..9659e8dad 100644
--- a/arch/arm/mach-kirkwood/include/mach/bridge-regs.h
+++ b/arch/arm/mach-kirkwood/include/mach/bridge-regs.h
@@ -29,7 +29,7 @@
 #define BRIDGE_CAUSE		(BRIDGE_VIRT_BASE | 0x0110)
 #define WDT_INT_REQ		0x0008
 
-#define BRIDGE_INT_TIMER1_CLR	(~0x0004)
+#define BRIDGE_INT_TIMER0_CLR	(~0x0002)
 
 #define IRQ_VIRT_BASE		(BRIDGE_VIRT_BASE | 0x0200)
 #define IRQ_CAUSE_LOW_OFF	0x0000
diff --git a/arch/arm/mach-kirkwood/include/mach/kirkwood.h b/arch/arm/mach-kirkwood/include/mach/kirkwood.h
index 8d2e3fe..f44cc60 100644
--- a/arch/arm/mach-kirkwood/include/mach/kirkwood.h
+++ b/arch/arm/mach-kirkwood/include/mach/kirkwood.h
@@ -28,13 +28,61 @@
  * fed00000	f1000000	1M	on-chip peripheral registers
  * fee00000	f2000000	1M	PCIe #0 I/O space
  * fef00000	f3000000	1M	PCIe #1 I/O space
+ * NOTE: For Warm reset support addresses will differ.
  */
 
+#ifdef CONFIG_MV_XCAT98DX_WARM_RESET
+/*For Warm reset some offsets changed
+    to avoid overlap with default values in high windows*/
+#define KIRKWOOD_SRAM_PHYS_BASE		0xC8010000
+#define KIRKWOOD_SRAM_SIZE		SZ_2K
+
+#define KIRKWOOD_BOOT_PHYS_BASE		0xF8000000
+#define KIRKWOOD_BOOT_SIZE		SZ_128M
+
+#define KIRKWOOD_NAND_MEM_PHYS_BASE	0xf3100000
+#define KIRKWOOD_NAND_MEM_SIZE		SZ_1K
+#define KIRKWOOD_SPI_MEM_PHYS_BASE	0xE8000000
+#define KIRKWOOD_SPI_MEM_SIZE		SZ_128M
+
+#define KIRKWOOD_PCIE1_IO_PHYS_BASE	0xf3000000
+#define KIRKWOOD_PCIE1_IO_VIRT_BASE	0xfef00000
+#define KIRKWOOD_PCIE1_IO_BUS_BASE	0x00100000
+#define KIRKWOOD_PCIE1_IO_SIZE		SZ_1M
+
+#define KIRKWOOD_PCIE_IO_PHYS_BASE	0xf2000000
+#define KIRKWOOD_PCIE_IO_VIRT_BASE	0xfee00000
+#define KIRKWOOD_PCIE_IO_BUS_BASE	0x00000000
+#define KIRKWOOD_PCIE_IO_SIZE		SZ_1M
+
+#define KIRKWOOD_REGS_PHYS_BASE		0xD0000000
+#define KIRKWOOD_REGS_VIRT_BASE		0xfed00000
+#define KIRKWOOD_REGS_SIZE		SZ_1M
+
+#define KIRKWOOD_PCIE_MEM_PHYS_BASE	0xE0000000
+#define KIRKWOOD_PCIE_MEM_BUS_BASE	0xE0000000
+#define KIRKWOOD_PCIE_MEM_SIZE		SZ_128M
+
+#define KIRKWOOD_PCIE1_MEM_PHYS_BASE	0x90000000
+#define KIRKWOOD_PCIE1_MEM_BUS_BASE	0xe8000000
+#define KIRKWOOD_PCIE1_MEM_SIZE		SZ_128M
+
+#define KIRKWOOD_PP_PHYS_BASE		0xF4000000
+#define KIRKWOOD_PP_VIRT_BASE		0xF4000000
+#define KIRKWOOD_PP_SIZE		SZ_64M
+
+#else
+
 #define KIRKWOOD_SRAM_PHYS_BASE		0xf3200000
 #define KIRKWOOD_SRAM_SIZE		SZ_2K
 
+#define KIRKWOOD_BOOT_PHYS_BASE		0xD8000000
+#define KIRKWOOD_BOOT_SIZE		SZ_128M
+
 #define KIRKWOOD_NAND_MEM_PHYS_BASE	0xf3100000
 #define KIRKWOOD_NAND_MEM_SIZE		SZ_1K
+#define KIRKWOOD_SPI_MEM_PHYS_BASE	0xD0000000
+#define KIRKWOOD_SPI_MEM_SIZE		SZ_128M
 
 #define KIRKWOOD_PCIE1_IO_PHYS_BASE	0xf3000000
 #define KIRKWOOD_PCIE1_IO_VIRT_BASE	0xfef00000
@@ -61,7 +109,7 @@
 #define KIRKWOOD_PP_PHYS_BASE		0xf4000000
 #define KIRKWOOD_PP_VIRT_BASE		0xf4000000
 #define KIRKWOOD_PP_SIZE		SZ_64M
-
+#endif
 /*
  * Register Map
  */
diff --git a/arch/arm/plat-orion/mv_drivers_lsp/mv_network/mv_ethernet/mv_xcat_pp/xcat98dx-core.c b/arch/arm/plat-orion/mv_drivers_lsp/mv_network/mv_ethernet/mv_xcat_pp/xcat98dx-core.c
index 67b4443..f17262b 100644
--- a/arch/arm/plat-orion/mv_drivers_lsp/mv_network/mv_ethernet/mv_xcat_pp/xcat98dx-core.c
+++ b/arch/arm/plat-orion/mv_drivers_lsp/mv_network/mv_ethernet/mv_xcat_pp/xcat98dx-core.c
@@ -1,4 +1,4 @@
-/*******************************************************************************
+/******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
 This software file (the "File") is owned and distributed by Marvell
@@ -9,7 +9,7 @@ introductory statement regarding license alternatives, (ii) delete the two
 license alternatives that you have not elected to use and (iii) preserve the
 Marvell copyright notice above.
 
-********************************************************************************
+*******************************************************************************
 Marvell GPL License Option
 
 If you received this File from Marvell, you may opt to use, redistribute and/or
@@ -23,7 +23,7 @@ THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
 WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
 DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
-*******************************************************************************/
+******************************************************************************/
 
 #include <linux/kernel.h>
 #include <linux/init.h>
@@ -41,7 +41,8 @@ void mvPpAddrComp(MV_U32 baseAddr, MV_U32 reg, MV_U32 *addr)
 	MV_U32 region, regionValue, regionMask;
 
 	/* read the contents of the addr completion register */
-	addressCompletion = (MV_U32)MV_32BIT_LE_FAST(*((volatile MV_U32 *)baseAddr));
+	addressCompletion =
+		(MV_U32)MV_32BIT_LE_FAST(*((volatile MV_U32 *)baseAddr));
 
 	/* check if the region need to be changed */
 	/* calculate the region (bits 24,25) */
@@ -70,7 +71,8 @@ void mvPpAddrComp(MV_U32 baseAddr, MV_U32 reg, MV_U32 *addr)
 		addressCompletion |= regionValue << (region * 8);
 
 		/* write back the updated addr completion register */
-		*((volatile MV_U32 *)baseAddr) = (MV_U32)MV_32BIT_LE_FAST(addressCompletion);
+		*((volatile MV_U32 *)baseAddr) =
+			(MV_U32)MV_32BIT_LE_FAST(addressCompletion);
 	}
 
 	/* Calculate the PCI addr to return */
@@ -162,7 +164,7 @@ MV_BOOL mvPpChipIsXCat2Simple(void)
 	MV_U32 devId, chipType;
 	MV_BOOL isXCat2;
 
-	devId = *(MV_U32 *)0xf400004c;
+	devId = *(MV_U32 *)(KIRKWOOD_PP_PHYS_BASE+0x4c);
 	devId = MV_32BIT_LE_FAST(devId);
 	chipType = (devId & MV_PP_CHIP_TYPE_MASK) >> MV_PP_CHIP_TYPE_OFFSET;
 
@@ -206,7 +208,10 @@ static void mvSwitchVidxCfg(void)
 	}
 }
 
-MV_STATUS mvPpReadVlanEntry(int dev, int entryNum, STRUCT_VLAN_ENTRY *vlanTableEntry)
+MV_STATUS mvPpReadVlanEntry(
+	int dev,
+	int entryNum,
+	STRUCT_VLAN_ENTRY *vlanTableEntry)
 {
 	MV_U32 val, i;
 
@@ -226,7 +231,10 @@ MV_STATUS mvPpReadVlanEntry(int dev, int entryNum, STRUCT_VLAN_ENTRY *vlanTableE
 	return MV_OK;
 }
 
-MV_STATUS mvPpSetVlanEntry(int dev, int entryNum,STRUCT_VLAN_ENTRY* vlanTableEntry)
+MV_STATUS mvPpSetVlanEntry(
+	int dev,
+	int entryNum,
+	STRUCT_VLAN_ENTRY *vlanTableEntry)
 {
 	MV_U32 i=0;
 
@@ -405,7 +413,8 @@ MV_U32 mvPresteraMibCounterRead(int dev, int portNum, unsigned int mibOffset,
 	/* of a 64-bit MIB Counter.                                             */
 	if (mibOffset == PRESTERA_MIB_GOOD_OCTETS_RECEIVED_LOW ||
 	    mibOffset == PRESTERA_MIB_GOOD_OCTETS_SENT_LOW) {
-		valHigh32 = mvPpReadReg(dev, PRESTERA_MIB_REG_BASE(portNum) + mibOffset);
+		valHigh32 =	mvPpReadReg(dev,
+				PRESTERA_MIB_REG_BASE(portNum) + mibOffset);
 		if (pHigh32 != NULL)
 			*pHigh32 = valHigh32;
 	}
@@ -570,86 +579,111 @@ void mvPresteraReadPortMibCounters(int port)
 		return;
 	}
 
-	printk("\n\t Prestera Port #%d MIB Counters (Port %d Device %d)\n\n",port, portNum, dev);
+	pr_info("\n\t Prestera Port #%d MIB Counters (Port %d Device %d)\n\n",
+		port, portNum, dev);
 	printk("Port MIB base address: 0x%08x\n",PRESTERA_MIB_REG_BASE(portNum));
 
 	printk("GoodFramesReceived          = %u\n",
-			mvPresteraMibCounterRead(dev, portNum, PRESTERA_MIB_GOOD_FRAMES_RECEIVED, NULL));
+			mvPresteraMibCounterRead(dev, portNum,
+			PRESTERA_MIB_GOOD_FRAMES_RECEIVED, NULL));
 	printk("BroadcastFramesReceived     = %u\n",
-			mvPresteraMibCounterRead(dev, portNum, PRESTERA_MIB_BROADCAST_FRAMES_RECEIVED, NULL));
+			mvPresteraMibCounterRead(dev, portNum,
+			PRESTERA_MIB_BROADCAST_FRAMES_RECEIVED, NULL));
 	printk("MulticastFramesReceived     = %u\n",
-			mvPresteraMibCounterRead(dev, portNum, PRESTERA_MIB_MULTICAST_FRAMES_RECEIVED, NULL));
+			mvPresteraMibCounterRead(dev, portNum,
+			PRESTERA_MIB_MULTICAST_FRAMES_RECEIVED, NULL));
 
-	regValue = mvPresteraMibCounterRead(dev, portNum, PRESTERA_MIB_GOOD_OCTETS_RECEIVED_LOW,
+	regValue = mvPresteraMibCounterRead(dev, portNum,
+				PRESTERA_MIB_GOOD_OCTETS_RECEIVED_LOW,
 			&regValHigh);
 	printk("GoodOctetsReceived          = 0x%08x%08x\n",
 			regValHigh, regValue);
 
 	printk("\n");
 	printk("GoodFramesSent              = %u\n",
-			mvPresteraMibCounterRead(dev, portNum, PRESTERA_MIB_GOOD_FRAMES_SENT, NULL));
+			mvPresteraMibCounterRead(dev, portNum,
+			PRESTERA_MIB_GOOD_FRAMES_SENT, NULL));
 	printk("BroadcastFramesSent         = %u\n",
-			mvPresteraMibCounterRead(dev, portNum, PRESTERA_MIB_BROADCAST_FRAMES_SENT, NULL));
+			mvPresteraMibCounterRead(dev, portNum,
+			PRESTERA_MIB_BROADCAST_FRAMES_SENT, NULL));
 	printk("MulticastFramesSent         = %u\n",
-			mvPresteraMibCounterRead(dev, portNum, PRESTERA_MIB_MULTICAST_FRAMES_SENT, NULL));
+			mvPresteraMibCounterRead(dev, portNum,
+			PRESTERA_MIB_MULTICAST_FRAMES_SENT, NULL));
 
-	regValue = mvPresteraMibCounterRead(dev, portNum, PRESTERA_MIB_GOOD_OCTETS_SENT_LOW,
+	regValue = mvPresteraMibCounterRead(dev, portNum,
+			PRESTERA_MIB_GOOD_OCTETS_SENT_LOW,
 			&regValHigh);
 	printk("GoodOctetsSent              = 0x%08x%08x\n", regValHigh, regValue);
 
-	regValue = mvPresteraMibCounterRead(dev, portNum, PRESTERA_MIB_SENT_MULTIPLE, NULL);
+	regValue = mvPresteraMibCounterRead(dev, portNum,
+			PRESTERA_MIB_SENT_MULTIPLE, NULL);
 	printk("SentMultiple                = %u\n", regValue);
 
 	printk("SentDeferred                = %u\n",
-			mvPresteraMibCounterRead(dev, portNum, PRESTERA_MIB_SENT_DEFERRED, NULL));
+			mvPresteraMibCounterRead(dev, portNum,
+			PRESTERA_MIB_SENT_DEFERRED, NULL));
 
 	printk("\n\t FC Control Counters\n");
 
-	regValue = mvPresteraMibCounterRead(dev, portNum, PRESTERA_MIB_GOOD_FC_RECEIVED, NULL);
+	regValue = mvPresteraMibCounterRead(dev, portNum,
+			PRESTERA_MIB_GOOD_FC_RECEIVED, NULL);
 	printk("GoodFCFramesReceived        = %u\n", regValue);
 
-	regValue = mvPresteraMibCounterRead(dev, portNum, PRESTERA_MIB_RECEIVED_FIFO_OVERRUN, NULL);
+	regValue = mvPresteraMibCounterRead(dev, portNum,
+			PRESTERA_MIB_RECEIVED_FIFO_OVERRUN, NULL);
 	printk("ReceivedFifoOverrun         = %u\n", regValue);
 
-	regValue = mvPresteraMibCounterRead(dev, portNum, PRESTERA_MIB_FC_SENT, NULL);
+	regValue = mvPresteraMibCounterRead(dev, portNum,
+			PRESTERA_MIB_FC_SENT, NULL);
 	printk("FCFramesSent                = %u\n", regValue);
 
 
 	printk("\n\t RX Errors\n");
 
-	regValue = mvPresteraMibCounterRead(dev, portNum, PRESTERA_MIB_BAD_OCTETS_RECEIVED, NULL);
+	regValue = mvPresteraMibCounterRead(dev, portNum,
+			PRESTERA_MIB_BAD_OCTETS_RECEIVED, NULL);
 	printk("BadOctetsReceived           = %u\n", regValue);
 
-	regValue = mvPresteraMibCounterRead(dev, portNum, PRESTERA_MIB_UNDERSIZE_RECEIVED, NULL);
+	regValue = mvPresteraMibCounterRead(dev, portNum,
+			PRESTERA_MIB_UNDERSIZE_RECEIVED, NULL);
 	printk("UndersizeFramesReceived     = %u\n", regValue);
 
-	regValue = mvPresteraMibCounterRead(dev, portNum, PRESTERA_MIB_FRAGMENTS_RECEIVED, NULL);
+	regValue = mvPresteraMibCounterRead(dev, portNum,
+			PRESTERA_MIB_FRAGMENTS_RECEIVED, NULL);
 	printk("FragmentsReceived           = %u\n", regValue);
 
-	regValue = mvPresteraMibCounterRead(dev, portNum, PRESTERA_MIB_OVERSIZE_RECEIVED, NULL);
+	regValue = mvPresteraMibCounterRead(dev, portNum,
+			PRESTERA_MIB_OVERSIZE_RECEIVED, NULL);
 	printk("OversizeFramesReceived      = %u\n", regValue);
 
-	regValue = mvPresteraMibCounterRead(dev, portNum, PRESTERA_MIB_JABBER_RECEIVED, NULL);
+	regValue = mvPresteraMibCounterRead(dev, portNum,
+			PRESTERA_MIB_JABBER_RECEIVED, NULL);
 	printk("JabbersReceived             = %u\n", regValue);
 
-	regValue = mvPresteraMibCounterRead(dev, portNum, PRESTERA_MIB_RX_ERROR_FRAME_RECEIVED, NULL);
+	regValue = mvPresteraMibCounterRead(dev, portNum,
+			PRESTERA_MIB_RX_ERROR_FRAME_RECEIVED, NULL);
 	printk("RxErrorFrameReceived        = %u\n", regValue);
 
-	/*regValue = mvPresteraMibCounterRead(dev, portNum, PRESTERA_MIB_BAD_CRC_EVENT, NULL);
+	/*regValue = mvPresteraMibCounterRead(dev, portNum,
+			PRESTERA_MIB_BAD_CRC_EVENT, NULL);
 	  printk("BadCrcReceived              = %u\n", regValue);*/
 
 	printk("\n\t TX Errors\n");
 
-	regValue = mvPresteraMibCounterRead(dev, portNum, PRESTERA_MIB_TX_FIFO_UNDERRUN_AND_CRC, NULL);
+	regValue = mvPresteraMibCounterRead(dev, portNum,
+			PRESTERA_MIB_TX_FIFO_UNDERRUN_AND_CRC, NULL);
 	printk("TxFifoUnderrunAndCRC        = %u\n", regValue);
 
-	regValue = mvPresteraMibCounterRead(dev, portNum, PRESTERA_MIB_EXCESSIVE_COLLISION, NULL);
+	regValue = mvPresteraMibCounterRead(dev, portNum,
+			PRESTERA_MIB_EXCESSIVE_COLLISION, NULL);
 	printk("TxExcessiveCollisions       = %u\n", regValue);
 
-	/*regValue = mvPresteraMibCounterRead(dev, portNum, PRESTERA_MIB_COLLISION, NULL);
+	/*regValue = mvPresteraMibCounterRead(dev, portNum,
+			PRESTERA_MIB_COLLISION, NULL);
 	  printk("TxCollisions                = %u\n", regValue);
 
-	  regValue = mvPresteraMibCounterRead(dev, portNum, PRESTERA_MIB_LATE_COLLISION, NULL);
+	  regValue = mvPresteraMibCounterRead(dev, portNum,
+			PRESTERA_MIB_LATE_COLLISION, NULL);
 	  printk("TxLateCollisions            = %u\n", regValue);*/
 
 	printk("\n");
@@ -728,12 +762,22 @@ MV_BOOL mvPpIsChipGE(void)
 
 void mvPpConfigNetworkPorts(void)
 {
-	if (mvPpIsChipFE() == MV_TRUE) {
-		simulate_PP_EEPROM_2122_24FE();
-	} else {
-		simulate_PP_EEPROM_4122_24GE_PHY_A0();
-	}
-
+#ifdef CONFIG_MV_XCAT98DX_WARM_RESET
+	unsigned int data;
+	/*
+	 * Check if called after Warm reset, if not - up WarmReset Flag.
+	 */
+	data = mvPpReadReg(0, MV_WARM_RESET_REG);
+	if (data != MV_WARM_RESET_MAGIC) {
+#endif
+		if (mvPpIsChipFE() == MV_TRUE)
+			simulate_PP_EEPROM_2122_24FE();
+		else
+			simulate_PP_EEPROM_4122_24GE_PHY_A0();
+#ifdef CONFIG_MV_XCAT98DX_WARM_RESET
+	} else
+		mvPpWriteReg(0, MV_WARM_RESET_REG, MV_WARM_RESET_MAGIC);
+#endif
 	mvSwitchVidxCfg();
 
 	/*
@@ -747,3 +791,4 @@ void mvPpConfigNetworkPorts(void)
 	 */
 	mvPpBitSet(MV_PP_DEV0, 0x02040000, BIT(8));
 }
+
diff --git a/arch/arm/plat-orion/mv_drivers_lsp/mv_network/mv_ethernet/mv_xcat_pp/xcat98dx-core.h b/arch/arm/plat-orion/mv_drivers_lsp/mv_network/mv_ethernet/mv_xcat_pp/xcat98dx-core.h
index 3b765f6..b9b7cd1 100644
--- a/arch/arm/plat-orion/mv_drivers_lsp/mv_network/mv_ethernet/mv_xcat_pp/xcat98dx-core.h
+++ b/arch/arm/plat-orion/mv_drivers_lsp/mv_network/mv_ethernet/mv_xcat_pp/xcat98dx-core.h
@@ -1,4 +1,4 @@
-/*******************************************************************************
+/******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
 This software file (the "File") is owned and distributed by Marvell
@@ -9,7 +9,7 @@ introductory statement regarding license alternatives, (ii) delete the two
 license alternatives that you have not elected to use and (iii) preserve the
 Marvell copyright notice above.
 
-********************************************************************************
+*******************************************************************************
 Marvell GPL License Option
 
 If you received this File from Marvell, you may opt to use, redistribute and/or
@@ -23,13 +23,16 @@ THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
 WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
 DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
-*******************************************************************************/
+******************************************************************************/
 
 #ifndef __INC_xcat98dx_core_h
 #define __INC_xcat98dx_core_h
 
 #include <mach/kirkwood.h>
 #include "mvTypes.h"
+#ifdef CONFIG_MV_XCAT98DX_WARM_RESET
+#include "mv_switch/mv_switch.h"
+#endif
 
 #define MV_PP_DEV0	(0)
 #define MV_PP_DEV1	(1)
@@ -53,6 +56,10 @@ MV_STATUS mvPpMruSetAllPorts(MV_U32 mruBytes);
 void mvPpReadPortMibCntCpuPort(MV_U32 dev);
 void mvPresteraReadPortMibCounters(int port);
 
+#ifdef CONFIG_MV_XCAT98DX_WARM_RESET
+void mvPpWarmRestart();
+#endif
+
 /*
  * VLAN Table handeling functions.
  */
@@ -104,8 +111,10 @@ typedef struct _mvPpVlanEntry
     #define MV_NET_NUM_OF_TX_DESC_PER_Q       (8)
 #endif
 
-#define MV_NET_NUM_OF_RX_DESC_TOTAL (MV_NET_NUM_OF_RX_Q*MV_NET_NUM_OF_RX_DESC_PER_Q)
-#define MV_NET_NUM_OF_TX_DESC_TOTAL (MV_NET_NUM_OF_TX_Q*MV_NET_NUM_OF_TX_DESC_PER_Q)
+#define MV_NET_NUM_OF_RX_DESC_TOTAL \
+	(MV_NET_NUM_OF_RX_Q*MV_NET_NUM_OF_RX_DESC_PER_Q)
+#define MV_NET_NUM_OF_TX_DESC_TOTAL \
+	(MV_NET_NUM_OF_TX_Q*MV_NET_NUM_OF_TX_DESC_PER_Q)
 
 #define NUM_OF_RX_QUEUES                  MV_NET_NUM_OF_RX_Q
 #define NUM_OF_TX_QUEUES                  MV_NET_NUM_OF_TX_Q
diff --git a/arch/arm/plat-orion/mv_drivers_lsp/mv_network/mv_ethernet/mv_xcat_pp/xcat98dx-switch.c b/arch/arm/plat-orion/mv_drivers_lsp/mv_network/mv_ethernet/mv_xcat_pp/xcat98dx-switch.c
index 7c691a8..d513dc9 100644
--- a/arch/arm/plat-orion/mv_drivers_lsp/mv_network/mv_ethernet/mv_xcat_pp/xcat98dx-switch.c
+++ b/arch/arm/plat-orion/mv_drivers_lsp/mv_network/mv_ethernet/mv_xcat_pp/xcat98dx-switch.c
@@ -1,4 +1,4 @@
-/*******************************************************************************
+/******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
 This software file (the "File") is owned and distributed by Marvell
@@ -9,7 +9,7 @@ introductory statement regarding license alternatives, (ii) delete the two
 license alternatives that you have not elected to use and (iii) preserve the
 Marvell copyright notice above.
 
-********************************************************************************
+*******************************************************************************
 Marvell GPL License Option
 
 If you received this File from Marvell, you may opt to use, redistribute and/or
@@ -23,7 +23,7 @@ THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
 WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
 DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
-*******************************************************************************/
+******************************************************************************/
 
 #include <linux/kernel.h>
 #include <linux/init.h>
@@ -188,3 +188,4 @@ int xcat_config_internal_mii(mv_eth_priv *priv)
 
 	return ret_val;
 }
+
diff --git a/arch/arm/plat-orion/mv_drivers_lsp/mv_network/mv_ethernet/mv_xcat_pp/xcat98dx-switch.h b/arch/arm/plat-orion/mv_drivers_lsp/mv_network/mv_ethernet/mv_xcat_pp/xcat98dx-switch.h
index e251326..213cdb0 100644
--- a/arch/arm/plat-orion/mv_drivers_lsp/mv_network/mv_ethernet/mv_xcat_pp/xcat98dx-switch.h
+++ b/arch/arm/plat-orion/mv_drivers_lsp/mv_network/mv_ethernet/mv_xcat_pp/xcat98dx-switch.h
@@ -24,9 +24,18 @@ WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
 DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 *******************************************************************************/
+#ifndef __xcat98dx_switch_h
+#define __xcat98dx_switch_h
 
 #include "mvTypes.h"
 #include "../mv_netdev.h"
 
+#define MV_WARM_RESET_COMMAND_REG       0x88
+#define MV_WARM_RESET_COMMAND_MASK      0x100000
+#define MV_WARM_RESET_REG               0x84
+#define MV_WARM_RESET_MAGIC             0x12345678
+
 int xcat_config_internal_mii(mv_eth_priv *priv);
 void mvPpBridgeTeachNewAddr(MV_U8 *mac);
+
+#endif
diff --git a/arch/arm/plat-orion/mv_drivers_lsp/mv_switch/mv_switch.h b/arch/arm/plat-orion/mv_drivers_lsp/mv_switch/mv_switch.h
index 7ea80d2..0bede7a 100644
--- a/arch/arm/plat-orion/mv_drivers_lsp/mv_switch/mv_switch.h
+++ b/arch/arm/plat-orion/mv_drivers_lsp/mv_switch/mv_switch.h
@@ -1,4 +1,4 @@
-/*******************************************************************************
+/******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
 This software file (the "File") is owned and distributed by Marvell
@@ -10,7 +10,7 @@ license alternatives that you have not elected to use and (iii) preserve the
 Marvell copyright notice above.
 
 
-********************************************************************************
+*******************************************************************************
 Marvell GPL License Option
 
 If you received this File from Marvell, you may opt to use, redistribute and/or
@@ -24,11 +24,12 @@ THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
 WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
 DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
-*******************************************************************************/
+******************************************************************************/
 #ifndef MV_SWITCH_MV_SWITCH_H
 #define MV_SWITCH_MV_SWITCH_H
 
 #include "boardEnv/mvBoardEnvLib.h"
+#include "msApi.h"
 
 #define MV_SWITCH_PHY_ACCESS			1
 #define MV_SWITCH_PORT_ACCESS			2
@@ -39,12 +40,12 @@ disclaimer.
 extern GT_QD_DEV qd_dev[BOARD_MAX_CASCADED_SWITCHES];
 
 int mv_switch_load_drv(unsigned int switch_ports_mask);
-int mv_switch_reg_read(int switch_num, int port, int reg, int type, MV_U16 *value);
-int mv_switch_reg_write(int switch_num, int port, int reg, int type, MV_U16 value);
+int mv_switch_reg_read(int switch_num, int port,
+			int reg, int type, MV_U16 *value);
+int mv_switch_reg_write(int switch_num, int port,
+			int reg, int type, MV_U16 value);
 
 void mv_switch_stats_print (int switch_num);
 void mv_switch_status_print(int switch_num);
 
-#endif
-
-
+#endif /* MV_SWITCH_MV_SWITCH_H */
diff --git a/arch/arm/plat-orion/time.c b/arch/arm/plat-orion/time.c
index 1ed8d13..f08a3b0 100644
--- a/arch/arm/plat-orion/time.c
+++ b/arch/arm/plat-orion/time.c
@@ -26,7 +26,6 @@
 #define  BRIDGE_INT_TIMER0	 0x0002
 #define  BRIDGE_INT_TIMER1	 0x0004
 
-
 /*
  * Timer block registers.
  */
@@ -45,7 +44,7 @@
  * SoC-specific data.
  */
 static void __iomem *bridge_base;
-static u32 bridge_timer1_clr_mask;
+static u32 bridge_timer0_clr_mask;
 static void __iomem *timer_base;
 
 
@@ -82,22 +81,22 @@ orion_clkevt_next_event(unsigned long delta, struct clock_event_device *dev)
 	/*
 	 * Clear and enable clockevent timer interrupt.
 	 */
-	writel(bridge_timer1_clr_mask, bridge_base + BRIDGE_CAUSE_OFF);
+	writel(bridge_timer0_clr_mask, bridge_base + BRIDGE_CAUSE_OFF);
 
 	u = readl(bridge_base + BRIDGE_MASK_OFF);
-	u |= BRIDGE_INT_TIMER1;
+	u |= BRIDGE_INT_TIMER0;
 	writel(u, bridge_base + BRIDGE_MASK_OFF);
 
 	/*
 	 * Setup new clockevent timer value.
 	 */
-	writel(delta, timer_base + TIMER1_VAL_OFF);
+	writel(delta, timer_base + TIMER0_VAL_OFF);
 
 	/*
 	 * Enable the timer.
 	 */
 	u = readl(timer_base + TIMER_CTRL_OFF);
-	u = (u & ~TIMER1_RELOAD_EN) | TIMER1_EN;
+	u = (u & ~TIMER0_RELOAD_EN) | TIMER0_EN;
 	writel(u, timer_base + TIMER_CTRL_OFF);
 
 	local_irq_restore(flags);
@@ -116,38 +115,38 @@ orion_clkevt_mode(enum clock_event_mode mode, struct clock_event_device *dev)
 		/*
 		 * Setup timer to fire at 1/HZ intervals.
 		 */
-		writel(ticks_per_jiffy - 1, timer_base + TIMER1_RELOAD_OFF);
-		writel(ticks_per_jiffy - 1, timer_base + TIMER1_VAL_OFF);
+		writel(ticks_per_jiffy - 1, timer_base + TIMER0_RELOAD_OFF);
+		writel(ticks_per_jiffy - 1, timer_base + TIMER0_VAL_OFF);
 
 		/*
 		 * Enable timer interrupt.
 		 */
 		u = readl(bridge_base + BRIDGE_MASK_OFF);
-		writel(u | BRIDGE_INT_TIMER1, bridge_base + BRIDGE_MASK_OFF);
+		writel(u | BRIDGE_INT_TIMER0, bridge_base + BRIDGE_MASK_OFF);
 
 		/*
 		 * Enable timer.
 		 */
 		u = readl(timer_base + TIMER_CTRL_OFF);
-		writel(u | TIMER1_EN | TIMER1_RELOAD_EN,
+		writel(u | TIMER0_EN | TIMER0_RELOAD_EN,
 		       timer_base + TIMER_CTRL_OFF);
 	} else {
 		/*
 		 * Disable timer.
 		 */
 		u = readl(timer_base + TIMER_CTRL_OFF);
-		writel(u & ~TIMER1_EN, timer_base + TIMER_CTRL_OFF);
+		writel(u & ~TIMER0_EN, timer_base + TIMER_CTRL_OFF);
 
 		/*
 		 * Disable timer interrupt.
 		 */
 		u = readl(bridge_base + BRIDGE_MASK_OFF);
-		writel(u & ~BRIDGE_INT_TIMER1, bridge_base + BRIDGE_MASK_OFF);
+		writel(u & ~BRIDGE_INT_TIMER0, bridge_base + BRIDGE_MASK_OFF);
 
 		/*
 		 * ACK pending timer interrupt.
 		 */
-		writel(bridge_timer1_clr_mask, bridge_base + BRIDGE_CAUSE_OFF);
+		writel(bridge_timer0_clr_mask, bridge_base + BRIDGE_CAUSE_OFF);
 
 	}
 	local_irq_restore(flags);
@@ -167,7 +166,7 @@ static irqreturn_t orion_timer_interrupt(int irq, void *dev_id)
 	/*
 	 * ACK timer interrupt and call event handler.
 	 */
-	writel(bridge_timer1_clr_mask, bridge_base + BRIDGE_CAUSE_OFF);
+	writel(bridge_timer0_clr_mask, bridge_base + BRIDGE_CAUSE_OFF);
 	orion_clkevt.event_handler(&orion_clkevt);
 
 	return IRQ_HANDLED;
@@ -186,7 +185,7 @@ orion_time_set_base(u32 _timer_base)
 }
 
 void __init
-orion_time_init(u32 _bridge_base, u32 _bridge_timer1_clr_mask,
+orion_time_init(u32 _bridge_base, u32 _bridge_timer0_clr_mask,
 		unsigned int irq, unsigned int tclk)
 {
 	u32 u;
@@ -195,7 +194,7 @@ orion_time_init(u32 _bridge_base, u32 _bridge_timer1_clr_mask,
 	 * Set SoC-specific data.
 	 */
 	bridge_base = (void __iomem *)_bridge_base;
-	bridge_timer1_clr_mask = _bridge_timer1_clr_mask;
+	bridge_timer0_clr_mask = _bridge_timer0_clr_mask;
 
 	ticks_per_jiffy = (tclk + HZ/2) / HZ;
 
@@ -208,13 +207,13 @@ orion_time_init(u32 _bridge_base, u32 _bridge_timer1_clr_mask,
 	 * Setup free-running clocksource timer (interrupts
 	 * disabled).
 	 */
-	writel(0xffffffff, timer_base + TIMER0_VAL_OFF);
-	writel(0xffffffff, timer_base + TIMER0_RELOAD_OFF);
+	writel(0xffffffff, timer_base + TIMER1_VAL_OFF);
+	writel(0xffffffff, timer_base + TIMER1_RELOAD_OFF);
 	u = readl(bridge_base + BRIDGE_MASK_OFF);
-	writel(u & ~BRIDGE_INT_TIMER0, bridge_base + BRIDGE_MASK_OFF);
+	writel(u & ~BRIDGE_INT_TIMER1, bridge_base + BRIDGE_MASK_OFF);
 	u = readl(timer_base + TIMER_CTRL_OFF);
-	writel(u | TIMER0_EN | TIMER0_RELOAD_EN, timer_base + TIMER_CTRL_OFF);
-	clocksource_mmio_init(timer_base + TIMER0_VAL_OFF, "orion_clocksource",
+	writel(u | TIMER1_EN | TIMER1_RELOAD_EN, timer_base + TIMER_CTRL_OFF);
+	clocksource_mmio_init(timer_base + TIMER1_VAL_OFF, "orion_clocksource",
 		tclk, 300, 32, clocksource_mmio_readl_down);
 
 	/*
-- 
1.7.5.4

