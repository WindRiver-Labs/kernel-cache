From 44d19bfdfe6a1a2f102e5ca686858adf971a9a71 Mon Sep 17 00:00:00 2001
From: Joe Zhou <shjzhou@marvell.com>
Date: Mon, 5 May 2014 15:47:27 +0800
Subject: [PATCH 1612/1825] Change linux-2.6.32.59-14t2 to use shared
 components code

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 19a5e3e0aeb2eb285fe33dc4503bee0c3eb0be98

	There are some kernel version dependent code, version check is added
	to support different kernel versions, including 2.6

	In addtion, netmap header file is added to support netmap for 2.6.

Change-Id: I60244dae423d3ff401695bbd52fca415cd4b3e48
Signed-off-by: Joe Zhou <shjzhou@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/7831
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../mv_drivers_lsp/mv_mux/mv_mux_netdev.c          |   32 ++
 .../mv_drivers_lsp/mv_mux/mv_mux_netdev.h          |    6 +
 .../mv_drivers_lsp/mv_mux/mv_mux_tool.c            |   20 +
 .../mv_drivers_lsp/mv_neta/net_dev/mv_eth_tool.c   |   10 +-
 .../mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c     |   43 ++-
 .../arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile |    4 +
 .../mv_drivers_lsp/mv_pp2/l2fw/mv_eth_l2fw.c       |    4 +
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_ethernet.c    |   14 +
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c      |   38 ++-
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h      |    9 +-
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_pp2_netmap.h  |  473 ++++++++++++++++++++
 11 files changed, 645 insertions(+), 8 deletions(-)
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_pp2_netmap.h

diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.c
index eed6130..abf3cec 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.c
@@ -63,6 +63,24 @@ static inline int mv_mux_rx_tag_remove(struct net_device *dev, struct sk_buff *s
 static inline int mv_mux_tx_skb_tag_add(struct net_device *dev, struct sk_buff *skb);
 static int mv_mux_netdev_delete_all(int port);
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 33)
+void netif_stacked_transfer_operstate(const struct net_device *rootdev,
+										struct net_device *dev)
+{
+	if (rootdev->operstate == IF_OPER_DORMANT)
+		netif_dormant_on(dev);
+	else
+		netif_dormant_off(dev);
+
+	if (netif_carrier_ok(rootdev)) {
+		if (!netif_carrier_ok(dev))
+			netif_carrier_on(dev);
+	} else {
+		if (netif_carrier_ok(dev))
+			netif_carrier_off(dev);
+	}
+}
+#endif
 /*-----------------------------------------------------------------------------------------*/
 /*----------------------------     MANAGER      -------------------------------------------*/
 /*-----------------------------------------------------------------------------------------*/
@@ -600,8 +618,10 @@ static inline void mv_mux_init_features(struct net_device *mux_dev)
 	struct net_device *root = mux_eth_shadow[pmux_priv->port].root;
 
 	mux_dev->features = root->features;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
 	mux_dev->hw_features = root->hw_features & ~NETIF_F_RXCSUM;
 	mux_dev->wanted_features = root->wanted_features;
+#endif
 	mux_dev->vlan_features = root->vlan_features;
 }
 /*-----------------------------------------------------------------------------------------*/
@@ -610,26 +630,34 @@ static inline void mv_mux_init_features(struct net_device *mux_dev)
 /*-----------------------------------------------------------------------------------------*/
 static void mv_mux_transfer_features(struct net_device *root, struct net_device *mux_dev)
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
 	mux_dev->features &= ~NETIF_F_RXCSUM;
 	mux_dev->features |=  (root->features & NETIF_F_RXCSUM);
+#endif
 
 	mux_dev->features &= ~NETIF_F_IP_CSUM;
 	mux_dev->features |=  (root->features & NETIF_F_IP_CSUM);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
 	mux_dev->hw_features &= ~NETIF_F_IP_CSUM;
 	mux_dev->hw_features |=  (root->features & NETIF_F_IP_CSUM);
+#endif
 
 	mux_dev->features &= ~NETIF_F_TSO;
 	mux_dev->features |=  (root->features & NETIF_F_TSO);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
 	mux_dev->hw_features &= ~NETIF_F_TSO;
 	mux_dev->hw_features |=  (root->features & NETIF_F_TSO);
+#endif
 
 	mux_dev->features &= ~NETIF_F_SG;
 	mux_dev->features |=  (root->features & NETIF_F_SG);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
 	mux_dev->hw_features &= ~NETIF_F_SG;
 	mux_dev->hw_features |=  (root->features & NETIF_F_SG);
+#endif
 }
 /*----------------------------------------------------------------------------------------*/
 /* Function attache mux device to root device,						  */
@@ -713,7 +741,11 @@ struct net_device *mv_mux_netdev_add(int port, struct net_device *mux_dev)
 		}
 		/*check whether mux_dev is already in the physical port*/
 		if (mux_dev == dev_temp)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 34)
+			printk(KERN_INFO "%s: this mux interface is already in port %d\n", mux_dev->name, port);
+#else
 			netdev_info(mux_dev, "this mux interface is already in port %d\n", port);
+#endif
 		else
 			pdev->next = mux_dev;
 	}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.h
index 660084a..41a98b3 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.h
@@ -28,6 +28,7 @@ disclaimer.
 #ifndef __mv_tag_netdev_h__
 #define __mv_tag_netdev_h__
 
+#include <linux/version.h>
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
 #include <linux/skbuff.h>
@@ -39,8 +40,13 @@ disclaimer.
 #include "mv802_3.h"
 
 #define MV_MUX_SKB_TAG_VAL		(0xabcd)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 33)
+#define MV_MUX_SKB_TAG_SET(skb)		(skb->iif = (MV_MUX_SKB_TAG_VAL))
+#define MV_MUX_SKB_IS_TAGGED(skb)	(skb->iif == (MV_MUX_SKB_TAG_VAL))
+#else
 #define MV_MUX_SKB_TAG_SET(skb)		(skb->skb_iif = (MV_MUX_SKB_TAG_VAL))
 #define MV_MUX_SKB_IS_TAGGED(skb)	(skb->skb_iif == (MV_MUX_SKB_TAG_VAL))
+#endif
 
 extern const struct ethtool_ops mv_mux_tool_ops;
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_tool.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_tool.c
index 44816d6..7e4551b 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_tool.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_tool.c
@@ -63,6 +63,26 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *******************************************************************************/
 
 #include "mv_mux_tool.h"
+#include <linux/ethtool.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0)
+static int __ethtool_get_settings(struct net_device *dev, void __user *useraddr)
+{
+	struct ethtool_cmd cmd = { ETHTOOL_GSET };
+	int err;
+
+	if (!dev->ethtool_ops->get_settings)
+		return -EOPNOTSUPP;
+
+	err = dev->ethtool_ops->get_settings(dev, &cmd);
+	if (err < 0)
+		return err;
+
+	if (copy_to_user(useraddr, &cmd, sizeof(cmd)))
+		return -EFAULT;
+	return 0;
+}
+#endif
 
 /******************************************************************************
 *mv_mux_tool_get_settings
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_tool.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_tool.c
index 9e5b6ad..3d01ffb 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_tool.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_tool.c
@@ -688,7 +688,7 @@ int mv_eth_tool_get_stats_count(struct net_device *netdev)
 	return 0;
 }
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 25)
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35)
 static int mv_eth_tool_get_rxfh_indir(struct net_device *netdev,
 					struct ethtool_rxfh_indir *indir)
 {
@@ -722,6 +722,7 @@ static int mv_eth_tool_set_rxfh_indir(struct net_device *netdev,
 	return -EOPNOTSUPP;
 #endif
 }
+#endif
 
 static int mv_eth_tool_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *info,
 									u32 *rules)
@@ -734,6 +735,7 @@ static int mv_eth_tool_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *i
 	return 0;
 }
 
+#if ((LINUX_VERSION_CODE < KERNEL_VERSION(3, 3, 0)) && (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 33)))
 /******************************************************************************
 * mv_eth_tool_set_rx_ntuple
 * Description:
@@ -788,7 +790,7 @@ static int mv_eth_tool_set_rx_ntuple(struct net_device *dev, struct ethtool_rx_n
 	return 1;
 #endif /* CONFIG_MV_ETH_PNC_L3_FLOW */
 }
-#endif /* #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 25) */
+#endif
 
 /******************************************************************************
 * mv_eth_tool_get_ethtool_stats
@@ -829,10 +831,12 @@ const struct ethtool_ops mv_eth_tool_ops = {
 	.get_stats_count			= mv_eth_tool_get_stats_count,
 #endif
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 25)
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35)
 	.get_rxfh_indir				= mv_eth_tool_get_rxfh_indir,
 	.set_rxfh_indir				= mv_eth_tool_set_rxfh_indir,
+#endif
 	.get_rxnfc				= mv_eth_tool_get_rxnfc,
+#if ((LINUX_VERSION_CODE < KERNEL_VERSION(3, 3, 0)) && (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 33)))
 	.set_rx_ntuple				= mv_eth_tool_set_rx_ntuple,
 #endif
 };
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c
index d9575c7..55b1b61 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c
@@ -1109,8 +1109,10 @@ static const struct net_device_ops mv_eth_netdev_ops = {
 	.ndo_change_mtu = mv_eth_change_mtu,
 	.ndo_tx_timeout = mv_eth_tx_timeout,
 	.ndo_select_queue = mv_eth_select_txq,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
 	.ndo_fix_features = mv_eth_netdev_fix_features,
 	.ndo_set_features = mv_eth_netdev_set_features,
+#endif
 };
 
 
@@ -1281,6 +1283,7 @@ EXPORT_SYMBOL(mv_eth_pkt_print);
 static inline void mv_eth_rx_csum(struct eth_port *pp, struct neta_rx_desc *rx_desc, struct sk_buff *skb)
 {
 #if defined(CONFIG_MV_ETH_RX_CSUM_OFFLOAD)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
 	if (pp->dev->features & NETIF_F_RXCSUM) {
 
 		if ((NETA_RX_L3_IS_IP4(rx_desc->status) ||
@@ -1291,6 +1294,7 @@ static inline void mv_eth_rx_csum(struct eth_port *pp, struct neta_rx_desc *rx_d
 			return;
 		}
 	}
+#endif
 #endif /* CONFIG_MV_ETH_RX_CSUM_OFFLOAD */
 
 	skb->ip_summed = CHECKSUM_NONE;
@@ -2300,7 +2304,11 @@ int mv_eth_tx_tso(struct sk_buff *skb, struct net_device *dev,
 
 		/* Move to next segment */
 		frag_size = skb_frag_ptr->size;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 1, 10)
 		frag_ptr = page_address(skb_frag_ptr->page.p) + skb_frag_ptr->page_offset;
+#else
+		frag_ptr = page_address(skb_frag_ptr->page) + skb_frag_ptr->page_offset;
+#endif
 		frag++;
 	}
 	totalDescNum = 0;
@@ -2357,7 +2365,11 @@ int mv_eth_tx_tso(struct sk_buff *skb, struct net_device *dev,
 
 				/* Move to next segment */
 				frag_size = skb_frag_ptr->size;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 1, 10)
 				frag_ptr = page_address(skb_frag_ptr->page.p) + skb_frag_ptr->page_offset;
+#else
+				frag_ptr = page_address(skb_frag_ptr->page) + skb_frag_ptr->page_offset;
+#endif
 				frag++;
 			}
 		}		/* of while data_left > 0 */
@@ -2527,9 +2539,13 @@ static void mv_eth_tx_frag_process(struct eth_port *pp, struct sk_buff *skb, str
 		/* NETA_TX_PKT_OFFSET_MASK = 0 */
 		tx_desc->dataSize = frag->size;
 		tx_desc->bufPhysAddr =
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 1, 10)
 			mvOsCacheFlush(pp->dev->dev.parent, page_address(frag->page.p) + frag->page_offset,
 			tx_desc->dataSize);
-
+#else
+			mvOsCacheFlush(pp->dev->dev.parent, page_address(frag->page) + frag->page_offset,
+			tx_desc->dataSize);
+#endif
 		if (i == (skb_shinfo(skb)->nr_frags - 1)) {
 			/* Last descriptor */
 			if (flags & MV_ETH_F_NO_PAD)
@@ -4248,7 +4264,9 @@ struct net_device *mv_eth_netdev_init(int mtu, u8 *mac,
 
 	SET_NETDEV_DEV(dev, &pdev->dev);
 
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 1, 10)
 	dev->priv_flags |= IFF_UNICAST_FLT;
+#endif
 
 	if (pp->flags & MV_ETH_F_CONNECT_LINUX) {
 		mv_eth_netdev_init_features(dev);
@@ -4488,33 +4506,47 @@ void mv_eth_config_show(void)
 static void mv_eth_netdev_init_features(struct net_device *dev)
 {
 	dev->features |= NETIF_F_SG | NETIF_F_LLTX;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
 	dev->hw_features |= NETIF_F_SG;
+#endif
 
 #ifdef CONFIG_MV_ETH_PNC_L3_FLOW
 	dev->features |= NETIF_F_NTUPLE;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
 	dev->hw_features |= NETIF_F_NTUPLE;
+#endif
 #endif /* CONFIG_MV_ETH_PNC_L3_FLOW */
 
 #if defined(MV_ETH_PNC_LB) && defined(CONFIG_MV_ETH_PNC)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
 	dev->hw_features |= NETIF_F_RXHASH;
 #endif
+#endif
 
 #ifdef CONFIG_MV_ETH_TX_CSUM_OFFLOAD
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
 	dev->hw_features |= NETIF_F_IP_CSUM;
+#endif
 #ifdef CONFIG_MV_ETH_TX_CSUM_OFFLOAD_DEF
 	dev->features |= NETIF_F_IP_CSUM;
 #endif /* CONFIG_MV_ETH_TX_CSUM_OFFLOAD_DEF */
 #endif /* CONFIG_MV_ETH_TX_CSUM_OFFLOAD */
 
 #ifdef CONFIG_MV_ETH_RX_CSUM_OFFLOAD
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
 	dev->hw_features |= NETIF_F_RXCSUM;
+#endif
 #ifdef CONFIG_MV_ETH_RX_CSUM_OFFLOAD_DEF
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
 	dev->features |= NETIF_F_RXCSUM;
+#endif
 #endif /* CONFIG_MV_ETH_RX_CSUM_OFFLOAD_DEF */
 #endif /* CONFIG_MV_ETH_RX_CSUM_OFFLOAD */
 
 #ifdef CONFIG_MV_ETH_TSO
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
 	dev->hw_features |= NETIF_F_TSO;
+#endif
 #ifdef CONFIG_MV_ETH_TSO_DEF
 	dev->features |= NETIF_F_TSO;
 #endif /* CONFIG_MV_ETH_TSO_DEF */
@@ -5368,7 +5400,11 @@ int mv_eth_change_mtu_internals(struct net_device *dev, int mtu)
 	}
 	dev->mtu = mtu;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0)
 	netdev_update_features(dev);
+#else
+	netdev_features_change(dev);
+#endif
 
 	return 0;
 }
@@ -5834,9 +5870,14 @@ void mv_eth_netdev_print(struct net_device *dev)
 	       dev->ifindex, dev->mtu, RX_PKT_SIZE(dev->mtu),
 		RX_BUF_SIZE(RX_PKT_SIZE(dev->mtu)), MV_MACQUAD(dev->dev_addr));
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
 	printk(KERN_ERR "features=0x%x, hw_features=0x%x, wanted_features=0x%x, vlan_features=0x%x\n",
 			(unsigned int)(dev->features), (unsigned int)(dev->hw_features),
 			(unsigned int)(dev->wanted_features), (unsigned int)(dev->vlan_features));
+#else
+	printk(KERN_ERR "features=0x%x, vlan_features=0x%x\n",
+		 (unsigned int)(dev->features), (unsigned int)(dev->vlan_features));
+#endif
 
 	printk(KERN_ERR "flags=0x%x, gflags=0x%x: running=%d, oper_up=%d\n",
 			(unsigned int)(dev->flags), (unsigned int)(dev->gflags),
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile
index 2ed700d..df3a570 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile
@@ -91,4 +91,8 @@ ifeq ($(NETMAP),y)
 ccflags-y       += -DCONFIG_NETMAP -I$(NETMAP_DIR) -I$(NETMAP_DIR)/../sys
 endif
 
+ifeq ($(CONFIG_NETMAP),y)
+ccflags-y       += -Inet/netmap
+endif
+
 obj-$(CONFIG_MV_ETH_PP2) += mv_pp2.o
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/l2fw/mv_eth_l2fw.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/l2fw/mv_eth_l2fw.c
index 0ac0faba..2d810de 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/l2fw/mv_eth_l2fw.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/l2fw/mv_eth_l2fw.c
@@ -26,6 +26,8 @@ DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 *******************************************************************************/
 
+#include <linux/version.h>
+
 #ifdef CONFIG_MV_INCLUDE_XOR
 #include "xor/mvXor.h"
 #include "xor/mvXorRegs.h"
@@ -1204,7 +1206,9 @@ static const struct net_device_ops mv_l2fw_netdev_ops = {
 	.ndo_open = mv_eth_open,
 	.ndo_stop = mv_l2fw_stop,
 	.ndo_start_xmit = mv_l2fw_xmit,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34)
 	.ndo_change_rx_flags = mv_eth_change_rx_flags,
+#endif
 	.ndo_set_mac_address = mv_eth_set_mac_addr,
 	.ndo_change_mtu = mv_eth_change_mtu,
 };
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_ethernet.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_ethernet.c
index 8865a39..6fec0c3 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_ethernet.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_ethernet.c
@@ -280,6 +280,7 @@ void mv_eth_rx_set_rx_mode(struct net_device *dev)
 	mvPrsMcastDelAll(phyPort);
 
 	if (dev->flags & IFF_MULTICAST) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34)
 		if (!netdev_mc_empty(dev)) {
 			struct netdev_hw_addr *ha;
 
@@ -290,6 +291,19 @@ void mv_eth_rx_set_rx_mode(struct net_device *dev)
 				}
 			}
 		}
+#else
+		struct dev_mc_list *curr_addr = dev->mc_list;
+		int                i;
+		for (i = 0; i < dev->mc_count; i++, curr_addr = curr_addr->next) {
+			if (!curr_addr)
+				break;
+			if (mvPrsMacDaAccept(priv->port, curr_addr->dmi_addr, 1)) {
+				printk(KERN_ERR "%s: Mcast init failed - %d of %d\n",
+						dev->name, i, dev->mc_count);
+				break;
+			}
+		}
+#endif
 	}
 }
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
index fb0e692..d919f58 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
@@ -68,7 +68,11 @@ void mv_pp2_cache_inv_wa_ctrl(int en)
 void mv_eth_iocc_l1_l2_cache_inv(unsigned char *v_start, int size)
 {
 	if (mv_pp2_swf_hwf_wa_en)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34)
 		___dma_single_dev_to_cpu(v_start, size, DMA_FROM_DEVICE);
+#else
+		dma_cache_maint(v_start, size, DMA_FROM_DEVICE);
+#endif
 }
 #endif /* CONFIG_MV_ETH_SWF_HWF_CORRUPTION_WA */
 
@@ -1285,7 +1289,9 @@ static const struct net_device_ops mv_eth_netdev_ops = {
 	.ndo_change_mtu = mv_eth_change_mtu,
 	.ndo_tx_timeout = mv_eth_tx_timeout,
 	.ndo_select_queue = mv_eth_select_txq,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
 	.ndo_fix_features = mv_eth_netdev_fix_features,
+#endif
 };
 
 
@@ -2385,7 +2391,11 @@ int mv_eth_tx_tso(struct sk_buff *skb, struct net_device *dev, struct mv_eth_tx_
 
 		/* Move to next segment */
 		frag_size = skb_frag_ptr->size;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 1, 10)
 		frag_ptr = page_address(skb_frag_ptr->page.p) + skb_frag_ptr->page_offset;
+#else
+		frag_ptr = page_address(skb_frag_ptr->page) + skb_frag_ptr->page_offset;
+#endif
 		frag++;
 	}
 	total_desc_num = 0;
@@ -2493,7 +2503,11 @@ int mv_eth_tx_tso(struct sk_buff *skb, struct net_device *dev, struct mv_eth_tx_
 
 				/* Move to next segment */
 				frag_size = skb_frag_ptr->size;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 1, 10)
 				frag_ptr = page_address(skb_frag_ptr->page.p) + skb_frag_ptr->page_offset;
+#else
+				frag_ptr = page_address(skb_frag_ptr->page) + skb_frag_ptr->page_offset;
+#endif
 				frag++;
 			}
 		}
@@ -2659,8 +2673,13 @@ static void mv_eth_tx_frag_process(struct eth_port *pp, struct sk_buff *skb, str
 		/* NETA_TX_PKT_OFFSET_MASK = 0 */
 		tx_desc->dataSize = frag->size;
 
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 1, 10)
 		bufPhysAddr = mvOsCacheFlush(NULL, page_address(frag->page.p) + frag->page_offset,
 						      tx_desc->dataSize);
+#else
+		bufPhysAddr = mvOsCacheFlush(NULL, page_address(frag->page) + frag->page_offset,
+						      tx_desc->dataSize);
+#endif
 
 		tx_desc->pktOffset = bufPhysAddr & MV_ETH_TX_DESC_ALIGN;
 		tx_desc->bufPhysAddr = bufPhysAddr & (~MV_ETH_TX_DESC_ALIGN);
@@ -4155,13 +4174,21 @@ void mv_eth_config_show(void)
 /* Set network device features on initialization. Take into account default compile time configuration. */
 void mv_eth_netdev_init_features(struct net_device *dev)
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
 	dev->features = NETIF_F_RXCSUM | NETIF_F_IP_CSUM | NETIF_F_SG | NETIF_F_LLTX;
+#else
+	dev->features = NETIF_F_IP_CSUM | NETIF_F_SG | NETIF_F_LLTX;
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
 	dev->hw_features = NETIF_F_GRO | NETIF_F_RXCSUM | NETIF_F_IP_CSUM | NETIF_F_SG;
+#endif
 
 #ifdef CONFIG_MV_ETH_TSO
 	dev->features |= NETIF_F_TSO;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
 	dev->hw_features |= NETIF_F_TSO;
 #endif
+#endif
 }
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 25)
@@ -4670,9 +4697,11 @@ int mv_eth_change_mtu_internals(struct net_device *dev, int mtu)
 
 mtu_out:
 	dev->mtu = mtu;
-
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0)
 	netdev_update_features(dev);
-
+#else
+	netdev_features_change(dev);
+#endif
 	return 0;
 }
 
@@ -5097,9 +5126,14 @@ void mv_eth_netdev_print(struct net_device *dev)
 		dev->ifindex, dev->mtu, RX_PKT_SIZE(dev->mtu),
 		(int)RX_BUF_SIZE(RX_PKT_SIZE(dev->mtu)), MV_MACQUAD(dev->dev_addr));
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
 	printk(KERN_ERR "features=0x%x, hw_features=0x%x, wanted_features=0x%x, vlan_features=0x%x\n",
 			(unsigned int)(dev->features), (unsigned int)(dev->hw_features),
 			(unsigned int)(dev->wanted_features), (unsigned int)(dev->vlan_features));
+#else
+	printk(KERN_ERR "features=0x%x, vlan_features=0x%x\n",
+		 (unsigned int)(dev->features), (unsigned int)(dev->vlan_features));
+#endif
 
 	printk(KERN_ERR "flags=0x%x, gflags=0x%x: running=%d, oper_up=%d\n",
 			(unsigned int)(dev->flags), (unsigned int)(dev->flags), netif_running(dev), netif_oper_up(dev));
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
index 20f0896..da16938 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
@@ -27,7 +27,7 @@ disclaimer.
 *******************************************************************************/
 #ifndef __mv_netdev_h__
 #define __mv_netdev_h__
-
+#include <linux/version.h>
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
 #include <linux/skbuff.h>
@@ -569,6 +569,7 @@ extern struct eth_port **mv_eth_ports;
 
 static inline void mv_eth_rx_csum(struct eth_port *pp, struct pp2_rx_desc *rx_desc, struct sk_buff *skb)
 {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
 	if (pp->dev->features & NETIF_F_RXCSUM) {
 		if ((PP2_RX_L3_IS_IP4(rx_desc->status) && !PP2_RX_IP4_HDR_ERR(rx_desc->status)) ||
 			(PP2_RX_L3_IS_IP6(rx_desc->status))) {
@@ -581,7 +582,7 @@ static inline void mv_eth_rx_csum(struct eth_port *pp, struct pp2_rx_desc *rx_de
 			}
 		}
 	}
-
+#endif
 	skb->ip_summed = CHECKSUM_NONE;
 	STAT_DBG(pp->stats.rx_csum_sw++);
 }
@@ -1028,7 +1029,11 @@ void      mv_hwf_bm_dump(void);
 #endif /* CONFIG_MV_ETH_HWF && !CONFIG_MV_ETH_BM_CPU */
 
 #ifdef CONFIG_MV_ETH_SWF_HWF_CORRUPTION_WA
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34)
 extern void ___dma_single_dev_to_cpu(const void *, size_t, enum dma_data_direction);
+#else
+extern void dma_cache_maint(const void *, size_t, int);
+#endif
 void mv_pp2_cache_inv_wa_ctrl(int en);
 #endif
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_pp2_netmap.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_pp2_netmap.h
new file mode 100644
index 0000000..37b68af
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_pp2_netmap.h
@@ -0,0 +1,473 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+/* mv_pp2_netmap.h */
+
+#ifndef __MV_PP2_NETMAP_H__
+#define __MV_PP2_NETMAP_H__
+
+#include <bsd_glue.h>
+#include <netmap.h>
+#include <netmap_kern.h>
+
+#define SOFTC_T	eth_port
+
+static int pool_buf_num[MV_BM_POOLS];
+static struct bm_pool *pool_short[MV_ETH_MAX_PORTS];
+/*
+ * Register/unregister
+ *	adapter is pointer to eth_port
+ */
+static int mv_pp2_netmap_reg(struct ifnet *ifp, int onoff)
+{
+	struct eth_port *adapter = MV_ETH_PRIV(ifp);
+	struct netmap_adapter *na = NA(ifp);
+	int error = 0, txq, rxq;
+
+	if (na == NULL)
+		return -EINVAL;
+
+	if (!(ifp->flags & IFF_UP)) {
+		/* mv_eth_open has not been called yet, so resources
+		 * are not allocated */
+		printk(KERN_ERR "Interface is down!");
+		return -EINVAL;
+	}
+
+	/* stop current interface */
+	if (mv_eth_stop(ifp)) {
+		printk(KERN_ERR "%s: stop interface failed\n", ifp->name);
+		return -EINVAL;
+	}
+
+	if (onoff) { /* enable netmap mode */
+		u32 port_map;
+
+		mv_eth_rx_reset(adapter->port);
+		ifp->if_capenable |= IFCAP_NETMAP;
+		na->if_transmit = (void *)ifp->netdev_ops;
+		ifp->netdev_ops = &na->nm_ndo;
+
+		/* check that long pool is not shared with other ports */
+		port_map =  mv_eth_ctrl_pool_port_map_get(adapter->pool_long->pool);
+		if (port_map != (1 << adapter->port)) {
+			printk(KERN_ERR "%s: BM pool %d not initialized or shared with other ports.\n",
+			__func__, adapter->pool_long->pool);
+			return -EINVAL;
+		}
+
+		/* Keep old number of long pool buffers */
+		pool_buf_num[adapter->pool_long->pool] = adapter->pool_long->buf_num;
+		mv_eth_pool_free(adapter->pool_long->pool, adapter->pool_long->buf_num);
+
+		/* set same pool number for short and long packets */
+		for (rxq = 0; rxq < CONFIG_MV_ETH_RXQ; rxq++)
+			mvPp2RxqBmShortPoolSet(adapter->port, rxq, adapter->pool_long->pool);
+
+		/* update short pool in software */
+		pool_short[adapter->port] = adapter->pool_short;
+		adapter->pool_short = adapter->pool_long;
+
+		set_bit(MV_ETH_F_IFCAP_NETMAP_BIT, &(adapter->flags));
+
+	} else {
+		unsigned long flags = 0;
+		u_int pa, i;
+
+		ifp->if_capenable &= ~IFCAP_NETMAP;
+		ifp->netdev_ops = (void *)na->if_transmit;
+		mv_eth_rx_reset(adapter->port);
+
+		/* TODO: handle SMP - each CPU must call this loop */
+		/*
+		for (txq = 0; txq < CONFIG_MV_ETH_TXQ; txq++)
+			mvPp2TxqSentDescProc(adapter->port, 0, txq);
+		*/
+
+		i = 0;
+		MV_ETH_LOCK(&adapter->pool_long->lock, flags);
+		do {
+			mvBmPoolGet(adapter->pool_long->pool, &pa);
+			i++;
+		} while (pa != 0);
+
+		MV_ETH_UNLOCK(&adapter->pool_long->lock, flags);
+		printk(KERN_ERR "NETMAP: free %d buffers from pool %d\n", i, adapter->pool_long->pool);
+		mv_eth_pool_add(adapter->pool_long->pool, pool_buf_num[adapter->pool_long->pool]);
+
+		/* set port's short pool for Linux driver */
+		for (rxq = 0; rxq < CONFIG_MV_ETH_RXQ; rxq++)
+			mvPp2RxqBmShortPoolSet(adapter->port, rxq, adapter->pool_short->pool);
+
+		/* update short pool in software */
+		adapter->pool_short = pool_short[adapter->port];
+
+		clear_bit(MV_ETH_F_IFCAP_NETMAP_BIT, &(adapter->flags));
+	}
+
+	if (mv_eth_start(ifp)) {
+		printk(KERN_ERR "%s: start interface failed\n", ifp->name);
+		return -EINVAL;
+	}
+	return error;
+}
+
+/*
+ * Reconcile kernel and user view of the transmit ring.
+ */
+static int
+mv_pp2_netmap_txsync(struct ifnet *ifp, u_int ring_nr, int do_lock)
+{
+	struct SOFTC_T *adapter = MV_ETH_PRIV(ifp);
+	struct netmap_adapter *na = NA(ifp);
+	struct netmap_kring *kring = &na->tx_rings[ring_nr];
+	struct netmap_ring *ring = kring->ring;
+	u_int j, k, n = 0, lim = kring->nkr_num_slots - 1;
+	u_int sent_n, cpu = 0;
+
+	struct pp2_tx_desc *tx_desc;
+	struct aggr_tx_queue *aggr_txq_ctrl = NULL;
+
+	/* generate an interrupt approximately every half ring */
+	/*int report_frequency = kring->nkr_num_slots >> 1;*/
+	/* take a copy of ring->cur now, and never read it again */
+	k = ring->cur;
+	if (k > lim)
+		return netmap_ring_reinit(kring);
+
+	aggr_txq_ctrl = &aggr_txqs[cpu];
+
+	if (do_lock)
+		mtx_lock(&kring->q_lock);
+
+	rmb();
+	/*
+	 * Process new packets to send. j is the current index in the
+	 * netmap ring, l is the corresponding index in the NIC ring.
+	 */
+	j = kring->nr_hwcur;
+	if (j != k) {	/* we have new packets to send */
+		for (n = 0; j != k; n++) {
+			/* slot is the current slot in the netmap ring */
+			struct netmap_slot *slot = &ring->slot[j];
+
+			uint64_t paddr;
+			void *addr = PNMB(slot, &paddr);
+			u_int len = slot->len;
+
+			if (addr == netmap_buffer_base || len > NETMAP_BUF_SIZE) {
+				if (do_lock)
+					mtx_unlock(&kring->q_lock);
+				return netmap_ring_reinit(kring);
+			}
+
+			slot->flags &= ~NS_REPORT;
+
+			/* check aggregated TXQ resource */
+			if (mv_eth_aggr_desc_num_check(aggr_txq_ctrl, 1)) {
+				if (do_lock)
+					mtx_unlock(&kring->q_lock);
+				return netmap_ring_reinit(kring);
+			}
+
+			tx_desc = mvPp2AggrTxqNextDescGet(aggr_txq_ctrl->q);
+			tx_desc->physTxq = MV_PPV2_TXQ_PHYS(adapter->port, 0, ring_nr);
+			tx_desc->bufPhysAddr = (uint32_t)(paddr);
+			tx_desc->dataSize = len;
+			tx_desc->pktOffset = slot->data_offs;
+			tx_desc->command = PP2_TX_L4_CSUM_NOT | PP2_TX_F_DESC_MASK | PP2_TX_L_DESC_MASK;
+			mv_eth_tx_desc_flush(tx_desc);
+			aggr_txq_ctrl->txq_count++;
+
+			if (slot->flags & NS_BUF_CHANGED)
+				slot->flags &= ~NS_BUF_CHANGED;
+
+			j = (j == lim) ? 0 : j + 1;
+		}
+		kring->nr_hwcur = k; /* the saved ring->cur */
+		kring->nr_hwavail -= n;
+
+		wmb(); /* synchronize writes to the NIC ring */
+
+		/* Enable transmit */
+		sent_n = n;
+		while (sent_n > 0xFF) {
+			mvPp2AggrTxqPendDescAdd(0xFF);
+			sent_n -= 0xFF;
+		}
+		mvPp2AggrTxqPendDescAdd(sent_n);
+	}
+
+	if (n == 0 || kring->nr_hwavail < 1) {
+		int delta;
+
+		delta = mvPp2TxqSentDescProc(adapter->port, 0, ring_nr);
+		if (delta)
+			kring->nr_hwavail += delta;
+	}
+	/* update avail to what the kernel knows */
+	ring->avail = kring->nr_hwavail;
+
+	if (do_lock)
+		mtx_unlock(&kring->q_lock);
+
+	return 0;
+}
+
+
+/*
+ * Reconcile kernel and user view of the receive ring.
+ */
+static int
+mv_pp2_netmap_rxsync(struct ifnet *ifp, u_int ring_nr, int do_lock)
+{
+	struct SOFTC_T *adapter = MV_ETH_PRIV(ifp);
+	struct netmap_adapter *na = NA(ifp);
+
+	MV_PP2_PHYS_RXQ_CTRL *rxr = adapter->rxq_ctrl[ring_nr].q;
+
+	struct netmap_kring *kring = &na->rx_rings[ring_nr];
+	struct netmap_ring *ring = kring->ring;
+	u_int j, l, n;
+
+	int force_update = do_lock || kring->nr_kflags & NKR_PENDINTR;
+
+	uint16_t strip_crc = (1) ? 4 : 0; /* TBD :: remove CRC or not */
+
+	u_int lim   = kring->nkr_num_slots - 1;
+	u_int k     = ring->cur;
+	u_int resvd = ring->reserved;
+	u_int rx_done;
+
+	if (k > lim)
+		return netmap_ring_reinit(kring);
+
+	if (do_lock)
+		mtx_lock(&kring->q_lock);
+
+	/* hardware memory barrier that prevents any memory read access from being moved */
+	/* and executed on the other side of the barrier */
+	rmb();
+
+	/*
+	 * Import newly received packets into the netmap ring.
+	 * j is an index in the netmap ring, l in the NIC ring.
+	*/
+	l = rxr->queueCtrl.nextToProc;
+	j = netmap_idx_n2k(kring, l); /* map NIC ring index to netmap ring index */
+
+	if (netmap_no_pendintr || force_update) { /* netmap_no_pendintr = 1, see netmap.c */
+		/* Get number of received packets */
+		rx_done = mvPp2RxqBusyDescNumGet(adapter->port, ring_nr);
+		mvOsCacheIoSync();
+		rx_done = (rx_done >= lim) ? lim - 1 : rx_done;
+		for (n = 0; n < rx_done; n++) {
+			PP2_RX_DESC *curr = (PP2_RX_DESC *)MV_PP2_QUEUE_DESC_PTR(&rxr->queueCtrl, l);
+
+#if defined(MV_CPU_BE)
+			mvPPv2RxqDescSwap(curr);
+#endif /* MV_CPU_BE */
+
+			/* TBD : check for ERRORs */
+			ring->slot[j].len = (curr->dataSize) - strip_crc - MV_ETH_MH_SIZE;
+			ring->slot[j].data_offs = NET_SKB_PAD + MV_ETH_MH_SIZE;
+			ring->slot[j].buf_idx = curr->bufCookie;
+			ring->slot[j].flags |= NS_BUF_CHANGED;
+
+			j = (j == lim) ? 0 : j + 1;
+			l = (l == lim) ? 0 : l + 1;
+		}
+		if (n) { /* update the state variables */
+			struct napi_group_ctrl *napi_group;
+
+			rxr->queueCtrl.nextToProc = l;
+			kring->nr_hwavail += n;
+			mvPp2RxqOccupDescDec(adapter->port, ring_nr, n);
+
+			/* enable interrupts */
+			wmb();
+			napi_group = adapter->cpu_config[smp_processor_id()]->napi_group;
+			mvPp2GbeCpuInterruptsEnable(adapter->port, napi_group->cpu_mask);
+		}
+		kring->nr_kflags &= ~NKR_PENDINTR;
+	}
+
+	/* skip past packets that userspace has released */
+	j = kring->nr_hwcur; /* netmap ring index */
+	if (resvd > 0) {
+		if (resvd + ring->avail >= lim + 1) {
+			printk(KERN_ERR "XXX invalid reserve/avail %d %d", resvd, ring->avail);
+			ring->reserved = resvd = 0;
+		}
+		k = (k >= resvd) ? k - resvd : k + lim + 1 - resvd;
+	}
+
+	if (j != k) { /* userspace has released some packets. */
+		l = netmap_idx_k2n(kring, j); /* NIC ring index */
+		for (n = 0; j != k; n++) {
+			struct netmap_slot *slot = &ring->slot[j];
+			PP2_RX_DESC *curr = (PP2_RX_DESC *)MV_PP2_QUEUE_DESC_PTR(&rxr->queueCtrl, l);
+			uint64_t paddr;
+			uint32_t *addr = PNMB(slot, &paddr);
+
+			/*
+			In big endian mode:
+			we do not need to swap descriptor here, allready swapped before
+			*/
+
+			slot->data_offs = NET_SKB_PAD + MV_ETH_MH_SIZE;
+			if (addr == (uint32_t *)netmap_buffer_base) { /* bad buf */
+				if (do_lock)
+					mtx_unlock(&kring->q_lock);
+
+				return netmap_ring_reinit(kring);
+			}
+			if (slot->flags & NS_BUF_CHANGED) {
+				slot->flags &= ~NS_BUF_CHANGED;
+
+				mvBmPoolPut(adapter->pool_long->pool, (uint32_t)paddr, curr->bufCookie);
+			}
+			curr->status = 0;
+			j = (j == lim) ? 0 : j + 1;
+			l = (l == lim) ? 0 : l + 1;
+		}
+		kring->nr_hwavail -= n;
+		kring->nr_hwcur = k;
+		/* hardware memory barrier that prevents any memory write access from being moved and */
+		/* executed on the other side of the barrier.*/
+		wmb();
+		/*
+		 * IMPORTANT: we must leave one free slot in the ring,
+		 * so move l back by one unit
+		 */
+		l = (l == 0) ? lim : l - 1;
+		mvPp2RxqNonOccupDescAdd(adapter->port, ring_nr, n);
+	}
+	/* tell userspace that there are new packets */
+	ring->avail = kring->nr_hwavail - resvd;
+
+	if (do_lock)
+		mtx_unlock(&kring->q_lock);
+
+	return 0;
+}
+
+
+/* diagnostic routine to catch errors */
+static void mv_pp2_no_rx_alloc(struct SOFTC_T *a, int n)
+{
+	printk("mv_pp2_skb_alloc should not be called");
+}
+
+/*
+ * Make the rx ring point to the netmap buffers.
+ */
+static int pp2_netmap_rxq_init_buffers(struct SOFTC_T *adapter, int rxq)
+{
+	struct ifnet *ifp = adapter->dev; /* struct net_devive */
+	struct netmap_adapter *na = NA(ifp);
+	struct netmap_slot *slot;
+	struct rx_queue   *rxr;
+
+	int i, si;
+	uint64_t paddr;
+	uint32_t *vaddr;
+
+	if (!(adapter->flags & MV_ETH_F_IFCAP_NETMAP))
+		return 0;
+
+	/* initialize the rx ring */
+	slot = netmap_reset(na, NR_RX, rxq, 0);
+	if (!slot) {
+		printk(KERN_ERR "%s: RX slot is null\n", __func__);
+		return 1;
+	}
+	rxr = &(adapter->rxq_ctrl[rxq]);
+
+	for (i = 0; i < rxr->rxq_size; i++) {
+		si = netmap_idx_n2k(&na->rx_rings[rxq], i);
+		vaddr = PNMB(slot + si, &paddr);
+		/* printk(KERN_ERR "paddr = 0x%x, virt = 0x%x\n",
+				(uint32_t)paddr,  (uint32_t)((slot+si)->buf_idx));*/
+
+		/* TODO: use mvBmPoolQsetPut in ppv2.1 */
+		mvBmPoolPut(adapter->pool_long->pool, (uint32_t)paddr, (uint32_t)((slot+si)->buf_idx));
+
+	}
+	rxr->q->queueCtrl.nextToProc = 0;
+	/* Force memory writes to complete */
+	wmb();
+	return 0;
+}
+
+
+/*
+ * Make the tx ring point to the netmap buffers.
+*/
+static int pp2_netmap_txq_init_buffers(struct SOFTC_T *adapter, int txp, int txq)
+{
+	struct ifnet *ifp = adapter->dev;
+	struct netmap_adapter *na = NA(ifp);
+	struct netmap_slot *slot;
+	int q;
+
+	if (!(adapter->flags & MV_ETH_F_IFCAP_NETMAP))
+		return 0;
+
+	q = txp * CONFIG_MV_ETH_TXQ + txq;
+
+	/* initialize the tx ring */
+	slot = netmap_reset(na, NR_TX, q, 0);
+
+	if (!slot) {
+		printk(KERN_ERR "%s: TX slot is null\n", __func__);
+		return 1;
+	}
+
+	return 0;
+}
+
+
+static void
+mv_pp2_netmap_attach(struct SOFTC_T *adapter)
+{
+	struct netmap_adapter na;
+
+	bzero(&na, sizeof(na));
+
+	na.ifp = adapter->dev; /* struct net_device */
+	na.separate_locks = 0;
+	na.num_tx_desc = 256;
+	na.num_rx_desc = adapter->rxq_ctrl->rxq_size;
+	na.nm_register = mv_pp2_netmap_reg;
+	na.nm_txsync = mv_pp2_netmap_txsync;
+	na.nm_rxsync = mv_pp2_netmap_rxsync;
+	na.num_tx_rings = CONFIG_MV_ETH_TXQ;
+	netmap_attach(&na, CONFIG_MV_ETH_RXQ);
+}
+/* end of file */
+
+#endif  /* __MV_PP2_NETMAP_H__ */
-- 
1.7.5.4

