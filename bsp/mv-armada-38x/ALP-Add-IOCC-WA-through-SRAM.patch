From 5983bc695511bc0a89b7b686fed91f1b80a61e47 Mon Sep 17 00:00:00 2001
From: Kosta Zertsekel <konszert@marvell.com>
Date: Wed, 22 May 2013 16:55:16 +0300
Subject: [PATCH 0683/1825] ALP: Add IOCC WA through SRAM

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 32bd2ce05851df37ad6c226f14db157d4cfc87f9

Signed-off-by: Kosta Zertsekel <konszert@marvell.com>
Change-Id: I09b4306b9e61b5159e43371f316a7068578034b4
Reviewed-on: http://vgitil04.il.marvell.com:8080/1919
Reviewed-by: Eran Ben-Avi <benavi@marvell.com>
Tested-by: Eran Ben-Avi <benavi@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../avanta_lp_family/ctrlEnv/sys/mvCpuIfRegs.h     |    3 +
 arch/arm/mach-avantalp/config/mvSysHwConfig.h      |    7 -
 arch/arm/mach-avantalp/core.c                      |  149 +++++++++++++++++---
 arch/arm/mach-avantalp/include/mach/avantalp.h     |   48 ++-----
 arch/arm/mach-avantalp/include/mach/io.h           |    6 +-
 arch/arm/mach-avantalp/sysmap.c                    |    4 +-
 arch/arm/mm/Kconfig                                |   10 ++
 arch/arm/plat-armada/linux_oss/mvOs.h              |    5 +-
 8 files changed, 155 insertions(+), 77 deletions(-)

diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvCpuIfRegs.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvCpuIfRegs.h
index 449a7ed..40e40e2 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvCpuIfRegs.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/sys/mvCpuIfRegs.h
@@ -296,6 +296,9 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define LVDS_PADS_CONF_PD_MASK(idx)		(1 << (16 + idx))
 #define LVDS_PADS_CONF_PD_EN(idx, en)		((en ? 0 : 1) << LVDS_PADS_CONF_PD_OFFS(idx))
 
+#define CPU_IO_SYNC_BARRIER_PER_CPU_REG(cpu)	(MV_CPUIF_REGS_BASE(cpu) + 0x10)
+#define CPU_IO_SYNC_BARRIER_REG			(MV_CPUIF_LOCAL_REGS_OFFSET + 0x10)
+
 /*******************************************/
 /* Main Interrupt Controller Registers Map */
 /*******************************************/
diff --git a/arch/arm/mach-avantalp/config/mvSysHwConfig.h b/arch/arm/mach-avantalp/config/mvSysHwConfig.h
index 4c9fc85..a552763 100755
--- a/arch/arm/mach-avantalp/config/mvSysHwConfig.h
+++ b/arch/arm/mach-avantalp/config/mvSysHwConfig.h
@@ -224,13 +224,6 @@ disclaimer.
  #define MV_TDM_USE_EXTERNAL_PCLK_SOURCE
 #endif
 
-/****************************************************************/
-/******************* LPAE configuration *************************/
-/****************************************************************/
-#ifdef CONFIG_ARM_LPAE
-#define ARM_LPAE_SUPPORT
-#endif
-
 /* We use the following registers to store DRAM interface pre configuration	*/
 /* auto-detection results							*/
 /* IMPORTANT: We are using mask register for that purpose. Before writing	*/
diff --git a/arch/arm/mach-avantalp/core.c b/arch/arm/mach-avantalp/core.c
index 18adfd5..76c316e 100644
--- a/arch/arm/mach-avantalp/core.c
+++ b/arch/arm/mach-avantalp/core.c
@@ -166,7 +166,7 @@ static int __init parse_tag_mv_uboot(const struct tag *tag)
 	unsigned int mvUbootVer = 0;
 	int i = 0;
 
-	printk("Using UBoot passing parameters structure\n");
+	pr_info("Using UBoot passing parameters structure\n");
 	mvUbootVer = read_tag(tag->u.mv_uboot.uboot_version);
 #ifdef CONFIG_MV_INCLUDE_USB
 	mvIsUsbHost = read_tag(tag->u.mv_uboot.isUsbHost);
@@ -198,7 +198,7 @@ static int __init mv_rsrc_setup(char *s)
 
 	/* Parse string to table */
 	if (mvUnitMapSetup(s, strstr) == MV_FALSE)
-		printk(KERN_ERR "Invalid resource string %s\n", s);
+		pr_err("Invalid resource string %s\n", s);
 
 	/* Change to rsrc limited mode */
 	mvUnitMapSetRsrcLimited(MV_TRUE);
@@ -421,8 +421,8 @@ static void __init alp_init_serial(int port)
 {
 	if (port == 0) {
 		if (mvUnitMapIsMine(UART0) == MV_FALSE) {
-			printk(KERN_WARNING "uart%d resource not allocated "
-			       "but CONFIG_MV_UART_PORT = %d\n", port, port);
+			pr_warn("uart%d resource not allocated "
+			        "but CONFIG_MV_UART_PORT = %d\n", port, port);
 			mvUnitMapSetMine(UART0);
 		}
 
@@ -430,8 +430,8 @@ static void __init alp_init_serial(int port)
 		platform_device_register(&uart0);
 	} else {
 		if (mvUnitMapIsMine(UART1) == MV_FALSE) {
-			printk(KERN_WARNING "uart%d resource not allocated "
-			       "but CONFIG_MV_UART_PORT = %d\n", port, port);
+			pr_warn("uart%d resource not allocated "
+			        "but CONFIG_MV_UART_PORT = %d\n", port, port);
 			mvUnitMapSetMine(UART1);
 		}
 
@@ -537,7 +537,7 @@ static void mv_pp2_giga_pdev_register(struct platform_device *pdev)
 		plat_data->mtu = mvMtu[port];
 		if (plat_data->mtu == 0) {
 			plat_data->mtu = 1500;
-			printk(KERN_ERR "%s: warning - failed to use MTU from uboot env, changing to default MTU (1500).\n", __func__);
+			pr_err("%s: warning - failed to use MTU from uboot env, changing to default MTU (1500).\n", __func__);
 		}
 
 		memcpy(plat_data->mac_addr, mvMacAddr[port], 6);
@@ -1145,27 +1145,29 @@ static void print_board_info(void)
 {
 	char name_buff[50];
 
-	printk("\n");
-	printk("  Marvell Avanta-LP");
+	pr_info("\n  Marvell Avanta-LP");
 
 	mvBoardNameGet(name_buff, 50);
-	printk(" %s Board - ", name_buff);
+	pr_info(" %s Board - ", name_buff);
 
 	mvCtrlModelRevNameGet(name_buff);
-	printk(" Soc: %s",  name_buff);
+	pr_info(" Soc: %s",  name_buff);
 #if defined(MV_CPU_LE)
-	printk(" LE\n");
+	pr_info(" LE\n");
 #else
-	printk(" BE\n");
+	pr_info(" BE\n");
 #endif
-	printk("  LSP version: %s\n", LSP_VERSION);
+	pr_info("  LSP version: %s\n", LSP_VERSION);
 #ifdef CONFIG_AURORA_IO_CACHE_COHERENCY
-	printk("  IOCC: Support IO coherency.\n");
+	pr_info("  IOCC: Support IO coherency.\n");
+#ifdef CONFIG_ALP_IOCC_SYNC_BARRIER_WA
+	pr_info("     -> Sync Barrier WA enabled\n");
+#endif
 #endif
 #ifdef CONFIG_MV_AMP_ENABLE
 	mvUnitMapPrint();
 #endif
-	printk("\n");
+	pr_info("\n");
 }
 
 #ifdef CONFIG_DEBUG_LL
@@ -1175,6 +1177,104 @@ extern void printascii(const char *);
 extern MV_TARGET_ATTRIB mvTargetDefaultsArray[];
 
 /*
+ * IOCC sync implementation
+ */
+#ifdef CONFIG_AURORA_IO_CACHE_COHERENCY
+
+#ifdef CONFIG_ALP_IOCC_SYNC_BARRIER_WA
+
+void *io_sync_virt_addr_for_write;
+
+void dma_io_sync(void)
+{
+	u32 val = 0;
+	u32 *virt_uncached = (u32 *)(SZ_1K + CRYPT_ENG_VIRT_BASE(0));
+	u32 *virt_cached   = (u32 *)(SZ_1K + io_sync_virt_addr_for_write);
+
+	/*
+	 * Write 0 through straight-forward path
+	 */
+	writel(0, virt_uncached);
+	dmb();
+
+	/*
+	 * Write 1 through CIB-SCU path
+	 */
+	*virt_cached = 1;
+	dmb();
+
+	/*
+	 * Wait till write through CIB-SCU path reaches SRAM
+	 */
+	do {
+		val = readl(virt_uncached);
+	} while (val != 1);
+}
+
+static void alp_iocc_wa_setup_punit_win(ulong phys0, ulong phys1, MV_TARGET target)
+{
+	MV_AHB_TO_MBUS_DEC_WIN mbus_win;
+	MV_ADDR_WIN remap_win;
+	u32 win_num;
+
+	win_num = mvAhbToMbusWinAvailGet();
+	if (win_num > 7 || win_num == 0xffffffff) {
+		pr_err("%s: Error: No free PUnit window (win_num = 0x%x)\n",
+		       __func__, win_num);
+		return;
+	}
+
+	mbus_win.target			= target;
+	mbus_win.addrWin.baseLow	= phys0;
+	mbus_win.addrWin.baseHigh	= 0;
+	mbus_win.addrWin.size		= SZ_64K;
+	mbus_win.enable			= MV_TRUE;
+
+	if (mvAhbToMbusWinSet(win_num, &mbus_win) != MV_OK) {
+		pr_err("%s: Error: mvAhbToMbusWinSet failed\n", __func__);
+		return;
+	}
+
+	remap_win.baseLow  = phys1;	/* remap low base  */
+	remap_win.baseHigh = 0;		/* remap high base */
+
+	if (mvAhbToMbusWinRemap(win_num, &remap_win) == 0xffffffff) {
+		pr_err("%s: Error:mvAhbToMbusWinRemap failed\n", __func__);
+		return;
+	}
+}
+
+static void alp_iocc_wa_init(void)
+{
+	/*
+	 * Config PUnit windows
+	 */
+	alp_iocc_wa_setup_punit_win(IOCC_WA_WIN0_PHYS_BASE,
+				    CRYPT_ENG_PHYS_BASE(0), SDRAM_CS0);
+
+	/*
+	 * Save address for IOCC work-around write
+	 */
+	io_sync_virt_addr_for_write = (void *)IOCC_WA_WIN0_VIRT_BASE;
+}
+#else
+void dma_io_sync(void)
+{
+	/* Nothing */
+}
+
+static void alp_iocc_wa_init(void) { /* empty */ }
+
+#endif /* CONFIG_ALP_IOCC_SYNC_BARRIER_WA */
+
+#else
+void dma_io_sync(void)
+{
+	/* No IOCC is needed in SWCC mode */
+}
+#endif /* CONFIG_AURORA_IO_CACHE_COHERENCY */
+
+/*
  * All combinations of IOCC/SMP/UP should be supported:
  *     UP  + HWCC (Hardware Cache Coherency)
  *     UP  + SWCC (Software Cache Coherency)
@@ -1188,6 +1288,8 @@ static void __init alp_init_iocc(void)
 		(void __iomem *)(INTER_REGS_VIRT_BASE + A9_MPCORE_SCU);
 	scu_enable(scu_base);
 #endif
+
+	alp_iocc_wa_init();
 }
 
 static void __init alp_init_l2x0_cache(void)
@@ -1203,8 +1305,7 @@ static void __init alp_board_init(void)
 {
 	mvBoardEnvInit();
 	if (mvCtrlEnvInit()) {
-		printk(KERN_ERR "%s: Error: ctrlEnv initi failed.\n", __func__);
-		/* return; */
+		pr_err("%s: Error: ctrlEnv init failed.\n", __func__);
 	}
 
 #ifdef CONFIG_MACH_AVANTA_LP_FPGA
@@ -1213,15 +1314,19 @@ static void __init alp_board_init(void)
 #endif
 
 	alp_init_cpu_mbus();
-	alp_init_iocc();
 	alp_init_l2x0_cache();
 
 	/* Init the CPU windows setting and the access protection windows. */
 	if (mvCpuIfInit(mv_sys_map())) {
-		printk(KERN_ERR "%s: Error: cpu memory windows init failed.\n", __func__);
-		/* return; */
+		pr_err("%s: Error: cpu memory windows init failed.\n", __func__);
 	}
 
+	/*
+	 * Changes PUnit windows for IOCC WA, hence, should be
+	 * placed after PUnit windows config.
+	 */
+	alp_init_iocc();
+
 	elf_hwcap &= ~HWCAP_JAVA;
 
 	alp_init_serial(0);
@@ -1246,7 +1351,7 @@ static void __init alp_board_init(void)
 
 static void board_restart(char mode, const char *cmd)
 {
-	printk("Reseting...\n");
+	printk(KERN_NOTICE "Reseting...\n");
 	mvBoardReset();
 
 	/* This should never be reached */
diff --git a/arch/arm/mach-avantalp/include/mach/avantalp.h b/arch/arm/mach-avantalp/include/mach/avantalp.h
index d12154f..b3eb617 100644
--- a/arch/arm/mach-avantalp/include/mach/avantalp.h
+++ b/arch/arm/mach-avantalp/include/mach/avantalp.h
@@ -26,13 +26,11 @@
 #define SDRAM_CS3_BASE			0x30000000
 #define SDRAM_CS3_SIZE			_256M
 
-#define INTER_REGS_PHYS_BASE		0xF1000000
-
-/*******************************************************************************
- * PHYS_BASE address mappings.
+/*
+ * Physical address map
  */
+#define INTER_REGS_PHYS_BASE		0xF1000000
 
-/* Virtual address not specified - remapped @runtime. */
 #define PEX0_MEM_PHYS_BASE		0xE0000000
 #define PEX0_MEM_SIZE			_32M
 #define PEX1_MEM_PHYS_BASE		0xE2000000
@@ -80,45 +78,19 @@
 
 #define NFC_PHYS_BASE			(INTER_REGS_PHYS_BASE | 0xD0000)
 
-/*******************************************************************************
- * VIRT_BASE address mappings.
- *
- * Change INTER_REGS_VIRT_BASE from 0xFBB00000 to 0xFBC00000 is mainly
- * for CONFIG_DEBUG_LL. Before paging_init, the UART port is mapped
- * by a section entry (2MB). In such case, the '1' in bit 20 is treated
- * as 'offset' and make it fail to access the UART port.
- */
-
-/* CONFIG_ARM_LPAE - two sets of VIRT/PHYS base defines to respect LPAE */
-#ifdef CONFIG_ARM_LPAE
-
-#define SPI_CS0_VIRT_BASE		0xFAA00000
-#define INTER_REGS_VIRT_BASE		0xFBC00000
-
-#define PEX0_IO_VIRT_BASE		0xFBE00000
-#define PEX1_IO_VIRT_BASE		0xFBF00000
-
-#define UART_VIRT_BASE			0xFC800000
-
-#define DEVICE_BOOTCS_VIRT_BASE		0xFCA00000
-#define DEVICE_CS0_VIRT_BASE		0xFEA00000
-#define DEVICE_CS1_VIRT_BASE		0xFEB00000
-#define DEVICE_CS2_VIRT_BASE		0xFEC00000
-#define DEVICE_CS3_VIRT_BASE		0xFED00000
-
-#define CRYPT_ENG_VIRT_BASE(chan)	((chan == 0) ? 0xFEE00000 : 0xFEE10000)
-#define PP2_VIRT_BASE			0xFEF00000
-#define BOOTROM_VIRT_BASE		0xFF000000
-#define LEGACY_NAND_VIRT_BASE		0xFF200000
-
-#else /* !CONFIG_ARM_LPAE */
+#define IOCC_WA_WIN0_PHYS_BASE		0xFF000000
 
+/*
+ * Virtual address map
+ */
 #define SPI_CS0_VIRT_BASE		0xFAB00000
 #define INTER_REGS_VIRT_BASE		0xFBB00000
 
 #define PEX0_IO_VIRT_BASE		0xFBC00000
 #define PEX1_IO_VIRT_BASE		0xFBD00000
 
+#define IOCC_WA_WIN0_VIRT_BASE		0xFBE00000
+
 #define UART_VIRT_BASE			0xFC600000
 
 #define DEVICE_BOOTCS_VIRT_BASE		0xFC700000
@@ -132,8 +104,6 @@
 #define BOOTROM_VIRT_BASE		0xFED00000
 #define LEGACY_NAND_VIRT_BASE		0xFEF00000
 
-#endif /* CONFIG_ARM_LPAE */
-
 /*
  * Linux native definitiotns
  */
diff --git a/arch/arm/mach-avantalp/include/mach/io.h b/arch/arm/mach-avantalp/include/mach/io.h
index 26c6af6..b61cca6 100644
--- a/arch/arm/mach-avantalp/include/mach/io.h
+++ b/arch/arm/mach-avantalp/include/mach/io.h
@@ -17,11 +17,7 @@
 #define __mem_isa(a)		(a)
 
 #ifdef CONFIG_AURORA_IO_CACHE_COHERENCY
-#define dma_io_sync() do { \
-	writel(0x1, INTER_REGS_VIRT_BASE + 0x21810); \
-} while (0)
-#else
-#define dma_io_sync() do { } while (0)
+void dma_io_sync(void);
 #endif
 
 #endif /* __ASM_ARCH_IO_H */
diff --git a/arch/arm/mach-avantalp/sysmap.c b/arch/arm/mach-avantalp/sysmap.c
index 9a26ba0..edcdb40 100644
--- a/arch/arm/mach-avantalp/sysmap.c
+++ b/arch/arm/mach-avantalp/sysmap.c
@@ -25,6 +25,8 @@ struct map_desc MEM_TABLE[] = {
 	/* no use for pex mem remap */
 	{ INTER_REGS_VIRT_BASE,		__phys_to_pfn(INTER_REGS_PHYS_BASE),	SZ_1M,		MT_DEVICE },
 	{ PP2_VIRT_BASE,		__phys_to_pfn(PP2_PHYS_BASE),		SZ_1M, 	     	MT_DEVICE },
+	{ CRYPT_ENG_VIRT_BASE(0),	__phys_to_pfn(CRYPT_ENG_PHYS_BASE(0)),	CRYPT_ENG_SIZE,	MT_DEVICE },
+	{ IOCC_WA_WIN0_VIRT_BASE,	__phys_to_pfn(IOCC_WA_WIN0_PHYS_BASE),	SZ_64K,		MT_DEVICE },
 };
 
 MV_CPU_DEC_WIN SYSMAP_ALP[] = {
@@ -53,7 +55,7 @@ MV_CPU_DEC_WIN SYSMAP_ALP[] = {
 	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,		DIS},	/* SPI_CS7 */
 	{{BOOTROM_PHYS_BASE,		0,	BOOTROM_SIZE		},	0x9,			DIS},	/* BOOTROM */
 	{{DEVICE_BOOTCS_PHYS_BASE,	0,	DEVICE_BOOTCS_SIZE	},	0xa,			DIS},	/* DEV_BOOCS */
-	{{CRYPT_ENG_PHYS_BASE(0),	0,	CRYPT_ENG_SIZE		},	0xc,			DIS},	/* CRYPT_ENG */
+	{{CRYPT_ENG_PHYS_BASE(0),	0,	CRYPT_ENG_SIZE		},	0xc,			EN},	/* CRYPT_ENG */
 	{{PP2_PHYS_BASE,		0,	PP2_SIZE		},	0xd,			EN},	/* PP2 */
 	{{TBL_TERM,			TBL_TERM,	TBL_TERM	},	TBL_TERM,		TBL_TERM}
 };
diff --git a/arch/arm/mm/Kconfig b/arch/arm/mm/Kconfig
index ba566c7..eae9c6c 100644
--- a/arch/arm/mm/Kconfig
+++ b/arch/arm/mm/Kconfig
@@ -1187,6 +1187,16 @@ config AURORA_IO_CACHE_COHERENCY
 	help
 	  This option enables the hardware mechanism for I/O cache coherency.
 
+config ALP_IOCC_SYNC_BARRIER_WA
+	depends on ARCH_AVANTA_LP && AURORA_IO_CACHE_COHERENCY
+	bool "Enable IO Sync Barrier WA"
+	default y
+	help
+	  Enables IO Sync Barrier work-around using reads from/write to
+	  SoC memory.
+	  This WA enables driver to keep in sync with memory
+	  updated by IO engine.
+
 config CPU_SHEEVA_PJ4B_PMC_ACCESS_IN_USERMODE
 	bool "Enabled User mode access for PMC"
 	depends on CPU_SHEEVA_PJ4B_V6 || CPU_SHEEVA_PJ4B_V7
diff --git a/arch/arm/plat-armada/linux_oss/mvOs.h b/arch/arm/plat-armada/linux_oss/mvOs.h
index fe75b20..554b15d 100644
--- a/arch/arm/plat-armada/linux_oss/mvOs.h
+++ b/arch/arm/plat-armada/linux_oss/mvOs.h
@@ -279,10 +279,9 @@ static inline void mvOsBridgeReorderWA(void)
 #define mvOsCacheMultiLineFlush(handle, addr, size)
 #define mvOsCacheMultiLineInv(handle, addr, size)
 #define mvOsCacheMultiLineFlushInv(handle, addr, size)
-#define mvOsCacheIoSync()		/*TBD - Doesn't work in ALP z1*/
-					/*{ MV_REG_WRITE(0x21810, 0x1); while (MV_REG_READ(0x21810) & 0x1); }*/
+#define mvOsCacheIoSync()	dma_io_sync()
 #else
-#define mvOsCacheIoSync()		/* Dummy - not needed in s/w cache coherency */
+#define mvOsCacheIoSync()	/* Not needed in s/w cache coherency (SWCC) */
 /*************************************/
 /* FLUSH & INVALIDATE single D$ line */
 /*************************************/
-- 
1.7.5.4

