From 7aa9eba52cd1ab7bfeb308950fada304afbb26f7 Mon Sep 17 00:00:00 2001
From: Biyao Zhai <biyao.zhai@windriver.com>
Date: Mon, 16 Feb 2015 13:45:15 +0800
Subject: [PATCH] Arm/armada38x :add support of new board DB-88F6820-GP

Add followings to support DB-88F6820-GP:
1 Add boardinfo table of DB-88F6820-GP.
2 Use new serders config table serdesRev2Map so as
  its phy can work normally.
3 I2C device Twsi(EEPROM) address is shifted to 0x57, old board use
  address 0x50.

Signed-off-by: Biyao Zhai <biyao.zhai@windriver.com>
---
 .../armada_38x_family/boardEnv/mvBoardEnvLib.c     |    9 +-
 .../armada_38x_family/boardEnv/mvBoardEnvSpec.c    |   80 ++++++++++++++++-
 .../armada_38x_family/boardEnv/mvBoardEnvSpec.h    |    3 +-
 .../armada_38x_family/ctrlEnv/mvCtrlEnvLib.c       |   98 +++++++++++++++++++-
 .../armada_38x_family/ctrlEnv/mvCtrlEnvRegs.h      |    3 +
 arch/arm/mach-armada38x/core.c                     |    8 ++-
 6 files changed, 193 insertions(+), 8 deletions(-)

diff --git a/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.c b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.c
index 2673233..050493f 100644
--- a/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.c
+++ b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.c
@@ -1994,9 +1994,12 @@ MV_U32 mvBoardIdGet(MV_VOID)
 	   use S@R TWSI address, and read board ID */
 	board = marvellBoardInfoTbl[mvBoardIdIndexGet(DB_68XX_ID)];
 	if (mvBoardTwsiGet(BOARD_DEV_TWSI_SATR, 0, 0, &readValue) != MV_OK) {
-		mvOsPrintf("%s: Error: Read from TWSI failed\n", __func__);
-		mvOsPrintf("%s: Set default board ID to DB-88F6820-BP\n", __func__);
-		readValue = DB_68XX_ID;
+		board = marvellBoardInfoTbl[mvBoardIdIndexGet(DB_68XX_GP_ID)];
+		if (mvBoardTwsiGet(BOARD_DEV_TWSI_SATR, 0, 0, &readValue) != MV_OK) {
+			mvOsPrintf("%s: Error: Read from TWSI failed\n", __func__);
+			mvOsPrintf("%s: Set default board ID to DB-88F6820-GP\n", __func__);
+			readValue = DB_68XX_GP_ID;
+		}
 	}
 	readValue = readValue & 0x07;
 
diff --git a/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvSpec.c b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvSpec.c
index ce1d234..e5c3b50 100644
--- a/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvSpec.c
+++ b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvSpec.c
@@ -231,12 +231,31 @@ MV_BOARD_TWSI_INFO db88f68xxInfoBoardTwsiDev[] = {
 	{ BOARD_TWSI_MODULE_DETECT,	4,	0x26,	   ADDR7_BIT, MV_FALSE},
 	{ BOARD_TWSI_MODULE_DETECT,	5,	0x27,	   ADDR7_BIT, MV_FALSE},
 };
+MV_BOARD_TWSI_INFO db88f68xxgpInfoBoardTwsiDev[] = {
+	{ BOARD_DEV_TWSI_SATR,          0,      0x57,      ADDR7_BIT, MV_TRUE},
+	{ BOARD_DEV_TWSI_SATR,          1,      0x4c,      ADDR7_BIT, MV_FALSE},
+	{ BOARD_DEV_TWSI_SATR,          2,      0x4d,      ADDR7_BIT, MV_FALSE},
+	{ BOARD_DEV_TWSI_SATR,          3,      0x4e,      ADDR7_BIT, MV_FALSE},
+	{ BOARD_DEV_TWSI_SATR,          4,      0x21,      ADDR7_BIT, MV_FALSE},
+	{ BOARD_TWSI_MODULE_DETECT,     0,      0x20,      ADDR7_BIT, MV_FALSE},
+	{ BOARD_TWSI_MODULE_DETECT,     1,      0x23,      ADDR7_BIT, MV_FALSE},
+	{ BOARD_TWSI_MODULE_DETECT,     2,      0x24,      ADDR7_BIT, MV_FALSE},
+	{ BOARD_TWSI_MODULE_DETECT,     3,      0x25,      ADDR7_BIT, MV_FALSE},
+	{ BOARD_TWSI_MODULE_DETECT,     4,      0x26,      ADDR7_BIT, MV_FALSE},
+	{ BOARD_TWSI_MODULE_DETECT,     5,      0x27,      ADDR7_BIT, MV_FALSE},
+};
+
 MV_BOARD_MAC_INFO db88f68xxInfoBoardMacInfo[] = {
 	/* {{MV_BOARD_MAC_SPEED boardMacSpeed, MV_8 boardEthSmiAddr}} */
 	{ BOARD_MAC_SPEED_AUTO, 0},
 	{ BOARD_MAC_SPEED_AUTO, 0x1},
 	{ BOARD_MAC_SPEED_AUTO, 0x0},
 };
+MV_BOARD_MAC_INFO db88f68xxgpInfoBoardMacInfo[] = {
+	/* {{MV_BOARD_MAC_SPEED boardMacSpeed, MV_8 boardEthSmiAddr}} */
+	{ BOARD_MAC_SPEED_AUTO, 0x1},
+	{ BOARD_MAC_SPEED_AUTO, 0x0},
+};
 
 MV_DEV_CS_INFO db88f68xxInfoBoardDeCsInfo[] = {
 	/*{deviceCS, params, devType, devWidth, busWidth }*/
@@ -314,6 +333,64 @@ MV_BOARD_INFO db88f68xx_board_info = {
 	.boardOptionsConfig		= MV_CONFIG_NO_MODULE
 };
 
+MV_BOARD_INFO db88f68xxgp_board_info = {
+	.boardName              = "DB-88F6820-GP",
+	.numBoardMppTypeValue   = 0,
+	.pBoardModTypeValue     = NULL,
+	.pBoardMppConfigValue   = db88f68xxInfoBoardMppConfigValue,
+	.intsGppMaskLow         = 0,
+	.intsGppMaskMid         = 0,
+	.intsGppMaskHigh        = 0,
+	.numBoardDeviceIf       = ARRSZ(db88f68xxInfoBoardDeCsInfo),
+	.pDevCsInfo             = db88f68xxInfoBoardDeCsInfo,
+	.numBoardTwsiDev        = ARRSZ(db88f68xxgpInfoBoardTwsiDev),
+	.pBoardTwsiDev          = db88f68xxgpInfoBoardTwsiDev,
+	.numBoardMacInfo        = ARRSZ(db88f68xxgpInfoBoardMacInfo),
+	.pBoardMacInfo          = db88f68xxgpInfoBoardMacInfo,
+	.numBoardGppInfo        = 0,
+	.pBoardGppInfo          = 0,
+	.activeLedsNumber       = 0,
+	.pLedGppPin             = NULL,
+	.ledsPolarity           = 0,
+
+	/* PMU Power */
+	.pmuPwrUpPolarity       = 0,
+	.pmuPwrUpDelay          = 80000,
+
+	/* GPP values */
+	.gppOutEnValLow         = DB_88F68XX_GPP_OUT_ENA_LOW,
+	.gppOutEnValMid         = DB_88F68XX_GPP_OUT_ENA_MID,
+	.gppOutEnValHigh        = DB_88F68XX_GPP_OUT_ENA_HIGH,
+	.gppOutValLow           = DB_88F68XX_GPP_OUT_VAL_LOW,
+	.gppOutValMid           = DB_88F68XX_GPP_OUT_VAL_MID,
+	.gppOutValHigh          = DB_88F68XX_GPP_OUT_VAL_HIGH,
+	.gppPolarityValLow      = DB_88F68XX_GPP_POL_LOW,
+	.gppPolarityValMid      = DB_88F68XX_GPP_POL_MID,
+	.gppPolarityValHigh     = DB_88F68XX_GPP_POL_HIGH,
+
+	/* TDM */
+	.numBoardTdmInfo                = {1},
+	.pBoardTdmInt2CsInfo            = {db88f68xxTdm880},
+	.boardTdmInfoIndex              = 0,
+	.pBoardSpecInit                 = NULL,
+
+	/* NAND init params */
+	.nandFlashReadParams            = DB_88F68XX_BOARD_NAND_READ_PARAMS,
+	.nandFlashWriteParams           = DB_88F68XX_BOARD_NAND_WRITE_PARAMS,
+	.nandFlashControl               = DB_88F68XX_BOARD_NAND_CONTROL,
+	.pBoardTdmSpiInfo               = db88f68xxTdmSpiInfo,
+
+	/* NOR init params */
+	.norFlashReadParams             = DB_88F68XX_BOARD_NOR_READ_PARAMS,
+	.norFlashWriteParams            = DB_88F68XX_BOARD_NOR_WRITE_PARAMS,
+
+	/* Enable modules auto-detection. */
+	.configAutoDetect               = MV_TRUE,
+	.numIoExp                       = 0,
+	.pIoExp                         = NULL,
+	.boardOptionsConfig             = MV_CONFIG_NO_MODULE
+};
+
 /*******************************************************************************
  * A380 RD-NAS-88F68XX board */
 /*******************************************************************************/
@@ -600,5 +677,6 @@ MV_BOARD_INFO *marvellBoardInfoTbl[] = {
 	&rdNas88f68XX_board_info,
 	&db88f68xx_board_info,
 	&rdWAP88f68XX_board_info,
-	&dbAP88f68xx_board_info
+	&dbAP88f68xx_board_info,
+	&db88f68xxgp_board_info
 };
diff --git a/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvSpec.h b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvSpec.h
index 0c54c67..c21e637 100644
--- a/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvSpec.h
+++ b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvSpec.h
@@ -85,7 +85,8 @@
 #define DB_68XX_ID			(MARVELL_BOARD_ID_BASE + 1)
 #define RD_AP_68XX_ID			(MARVELL_BOARD_ID_BASE + 2)
 #define DB_AP_68XX_ID			(MARVELL_BOARD_ID_BASE + 3)
-#define MV_MAX_MARVELL_BOARD_ID		(MARVELL_BOARD_ID_BASE + 4)
+#define DB_68XX_GP_ID			(MARVELL_BOARD_ID_BASE + 4)
+#define MV_MAX_MARVELL_BOARD_ID		(MARVELL_BOARD_ID_BASE + 5)
 #define MV_MARVELL_BOARD_NUM		(MV_MAX_MARVELL_BOARD_ID - MARVELL_BOARD_ID_BASE)
 
 #define MV_INVALID_BOARD_ID		0xFFFFFFFF
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.c b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.c
index 2c3e3ea..fdcbce5 100644
--- a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.c
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.c
@@ -143,6 +143,34 @@ MV_UNIT_ID mvCtrlSocUnitNums[MAX_UNITS_ID][MV_68xx_INDEX_MAX] = {
 #define ON_BOARD_RGMII(x)	(1 << x)
 #define SERDES_SGMII(x)		(4 << x)
 
+#define LAST_SERDES_TYPE         19
+#define MAX_SERDES_LANES         7
+#define NA                       0
+MV_U8 serdesRev2Map[LAST_SERDES_TYPE][MAX_SERDES_LANES] = {
+	/* 0      1      2       3       4       5       6 */
+	{ 0x1,   0x1,    NA,     NA,     NA,     NA,     NA }, /* PEX0 */
+	{ NA,    NA,     0x1,    NA,     0x1,    NA,     0x1 }, /* PEX1 */
+	{ NA,    NA,     NA,     NA,     0x7,    0x1,    NA }, /* PEX2 */
+	{ NA,    NA,     NA,     0x1,    NA,     NA,     NA }, /* PEX3 */
+	{ 0x2,   0x3,    NA,     NA,     NA,     NA,     NA }, /* SATA0 */
+	{ NA,    NA,     0x3,    NA,     NA,     NA,     NA }, /* SATA1 */
+	{ NA,    NA,     NA,     NA,     0x6,    0x2,    NA }, /* SATA2 */
+	{ NA,    NA,     NA,     0x3,    NA,     NA,     NA }, /* SATA3 */
+	{ 0x3,   0x4,    NA,     NA,     NA,     NA,     NA }, /* SGMII0 */
+	{ NA,    0x5,    0x4,    NA,     0x3,    NA,     NA }, /* SGMII1 */
+	{ NA,    NA,     NA,     0x4,    NA,     0x3,    NA }, /* SGMII2 */
+	{ NA,    0x7,    NA,     NA,     NA,     NA,     NA }, /* QSGMII */
+	{ NA,    0x6,    NA,     NA,     0x4,    NA,     NA }, /* USB3_HOST0 */
+	{ NA,    NA,     NA,     0x5,    NA,     0x4,    NA }, /* USB3_HOST1 */
+	{ NA,    NA,     NA,     0x6,    0x5,    0x5,    NA }, /* USB3_DEVICE */
+#ifdef MV88F69XX
+	{ NA,    NA,     0x5,    NA,     0x8,    NA,     0x2 }, /* SGMII3 */
+	{ NA,    NA,     NA,     0x8,    0x9,    0x8,    0x4 }, /* XAUI */
+	{ NA,    NA,     NA,     NA,     NA,     0x8,    0x4 }, /* RXAUI */
+#endif
+	{ 0x0,   0x0,    0x0,    0x0,    0x0,    0x0,    NA } /*DEF_SERDES*/
+};
+
 /* ethComPhy will be initialize by mvCtrlEnvInit and  updated by mvCtrlSerdesConfigDetect in case SGMII is set */
 static MV_U32	ethComPhy;
 /*******************************************************************************
@@ -284,11 +312,12 @@ MV_U32 mvCtrlSocUnitInfoNumSet(MV_UNIT_ID unit, MV_U32 maxValue)
 *******************************************************************************/
 MV_VOID mvCtrlSerdesConfigDetect(MV_VOID)
 {
-	MV_U32 ifNo, commPhyConfigReg, comPhyCfg, serdesNum, serdesCongigField, maxSerdesLane;
+	MV_U32 ifNo, commPhyConfigReg, comPhyCfg, serdesNum, serdesCongigField,
+	 maxSerdesLane, serdersType;
 	MV_U32 sataIfCount = 0;
 	MV_U32 usbIfCount = 0;
 	MV_U32 usbHIfCount = 0;
-
+	char boardname[50];
 	MV_BOARD_PEX_INFO *boardPexInfo = mvBoardPexInfoGet();
 
 	maxSerdesLane = MV_SERDES_MAX_LANES;
@@ -298,6 +327,71 @@ MV_VOID mvCtrlSerdesConfigDetect(MV_VOID)
 	memset(boardPexInfo, 0, sizeof(MV_BOARD_PEX_INFO));
 	commPhyConfigReg = MV_REG_READ(COMM_PHY_SELECTOR_REG);
 	DB(printf("mvCtrlSerdesConfig: commPhyConfigReg=0x%x\n", commPhyConfigReg));
+	mvBoardNameGet(boardname, sizeof(boardname));
+	if (strstr(boardname, "DB-88F6820-GP")) {
+		for (serdesNum = 0; serdesNum < maxSerdesLane; serdesNum++) {
+			serdesCongigField = (commPhyConfigReg & GP_COMPHY_SELECT_MASK(serdesNum)) >> GP_COMPHY_SELECT_OFFS(serdesNum);
+			for (serdersType = 0; serdersType < LAST_SERDES_TYPE; serdersType++) {
+				if ((serdesCongigField == serdesRev2Map[serdersType][serdesNum]) && (serdesCongigField != NA)) {
+					switch (serdersType) {
+					case 0:/*PEX*/
+					case 1:
+					case 2:
+					case 3:
+						ifNo = serdersType;
+						if ((ifNo == PEX0_IF) && (commPhyConfigReg & PCIE0_X4_EN_MASK))
+							boardPexInfo->pexUnitCfg[ifNo] = PEX_BUS_MODE_X4;
+						else {
+							boardPexInfo->pexUnitCfg[ifNo] = PEX_BUS_MODE_X1;
+							boardPexInfo->pexMapping[boardPexInfo->boardPexIfNum] = ifNo;
+							boardPexInfo->boardPexIfNum++;
+							DB(printf("PEX, if=%d\n", ifNo));
+						}
+						break;
+					case 4:/*SATA*/
+					case 5:
+					case 6:
+					case 7:
+						ifNo = serdersType-4;
+						DB(printf("SATA, if=%d\n", ifNo));
+						sataIfCount++;
+						break;
+					case 8:/*GBE*/
+					case 9:
+					case 10:
+					case 11:
+						ifNo = serdersType-8;
+						if (ON_BOARD_RGMII(ifNo)) {
+							ethComPhy &= ~(ON_BOARD_RGMII(ifNo));
+							ethComPhy |= SERDES_SGMII(ifNo);
+							DB(printf("SGMII,if=%d\n", ifNo));
+						}
+						break;
+					case 12:/*USBH*/
+					case 13:
+						ifNo = serdersType-12;
+						DB(printf("USB_H, if=%d\n", ifNo));
+						usbHIfCount++;
+						break;
+					case 14:/*USB*/
+						ifNo = serdersType-14;
+						DB(printf("USB, if=%d\n", ifNo));
+						usbIfCount++;
+						break;
+					}
+				}
+
+			}
+
+		}
+	mvCtrlSocUnitInfoNumSet(PEX_UNIT_ID, boardPexInfo->boardPexIfNum);
+	mvCtrlSocUnitInfoNumSet(SATA_UNIT_ID, sataIfCount);
+	mvCtrlSocUnitInfoNumSet(USB3_UNIT_ID, usbHIfCount);
+	/* only if found more serdes eth interfaces than on-board ports,
+	than update max eth count.(needed by phy + giga init sequence)*/
+	mvCtrlSocUnitInfoNumSet(ETH_GIG_UNIT_ID, mvCountMaskBits(ethComPhy));
+	return;
+	}
 	for (serdesNum = 0; serdesNum < maxSerdesLane; serdesNum++) {
 		serdesCongigField = (commPhyConfigReg & COMPHY_SELECT_MASK(serdesNum)) >> COMPHY_SELECT_OFFS(serdesNum);
 		comPhyCfg = serdesCfg[serdesNum][serdesCongigField];
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvRegs.h b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvRegs.h
index b834e8a..6e07122 100644
--- a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvRegs.h
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvRegs.h
@@ -183,6 +183,9 @@ extern "C" {
 #define COMM_PHY_SELECTOR_REG			0x183fc
 #define COMPHY_SELECT_OFFS(x)			(x * 3)
 #define COMPHY_SELECT_MASK(x)			(0x07 << COMPHY_SELECT_OFFS(x))
+/* new board GP */
+#define GP_COMPHY_SELECT_OFFS(x)               (x * 4)
+#define GP_COMPHY_SELECT_MASK(x)               (0x0f<<GP_COMPHY_SELECT_OFFS(x))
 #define	PCIE0_X4_EN_OFFS			18
 #define	PCIE0_X4_EN_MASK			(1 << PCIE0_X4_EN_OFFS)
 
diff --git a/arch/arm/mach-armada38x/core.c b/arch/arm/mach-armada38x/core.c
index 35a1788..57409b3 100644
--- a/arch/arm/mach-armada38x/core.c
+++ b/arch/arm/mach-armada38x/core.c
@@ -818,12 +818,18 @@ static struct platform_device a38x_sata_unit1 = {
 
 static void __init a38x_sata_init(void)
 {
+	char boardname[50];
+
+	mvBoardNameGet(boardname, sizeof(boardname));
+
 #ifdef CONFIG_SATA_AHCI_MV
 	if (mvUnitMapIsMine(SATA) != MV_TRUE)
 		return;
 
 	platform_device_register(&a38x_sata_unit0);
-	platform_device_register(&a38x_sata_unit1);
+	if ((strcmp(boardname, "DB-88F6820-GP")) ||
+	(mvCtrlSocUnitInfoNumGet(SATA_UNIT_ID) == 4))
+		platform_device_register(&a38x_sata_unit1);
 #endif /* CONFIG_SATA_AHCI_MV */
 }
 
-- 
1.7.5.4

