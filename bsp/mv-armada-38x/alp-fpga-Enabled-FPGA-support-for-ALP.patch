From e142363dee03fab709ba3b320ce38cafe003409c Mon Sep 17 00:00:00 2001
From: Yehuda Yitschak <yehuday@marvell.com>
Date: Wed, 27 Nov 2013 14:46:52 +0200
Subject: [PATCH 1164/1825] alp: fpga: Enabled FPGA support for ALP

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit c9cea0d77cc74a94d1dd24a3ba43df0cec0d42d3

	This is a initial version with some limitations
	PCI - Has problems working with e1000. link up with no ping
	IOCC WA - stuck on completion of XOR DMA transfer
	XOR - not supported
	SMP - supported but not tested.

Change-Id: Ia43edffa9778de07c15b111d4cb877e51272f8b4
Signed-off-by: Yehuda Yitschak <yehuday@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/4455
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Kosta Zertsekel <konszert@marvell.com>
Reviewed-by: Igor Patrik <igorp@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-avantalp/core.c              |   23 +++++-
 arch/arm/mach-avantalp/export.c            |    2 +
 arch/arm/mach-avantalp/include/mach/irqs.h |    1 +
 arch/arm/mach-avantalp/pci.c               |  114 ++++++++++++++--------------
 arch/arm/mach-avantalp/sysmap.c            |    3 +
 arch/arm/tools/mach-types                  |    1 +
 6 files changed, 84 insertions(+), 60 deletions(-)

diff --git a/arch/arm/mach-avantalp/core.c b/arch/arm/mach-avantalp/core.c
index de52e77..43ea78c 100644
--- a/arch/arm/mach-avantalp/core.c
+++ b/arch/arm/mach-avantalp/core.c
@@ -518,7 +518,6 @@ static void __init alp_init_serial(int port)
 			        "but CONFIG_MV_UART_PORT = %d\n", port, port);
 			mvUnitMapSetMine(UART0);
 		}
-
 		uart0_data[0].uartclk = mvBoardTclkGet();
 		platform_device_register(&uart0);
 	} else {
@@ -1378,8 +1377,10 @@ static void print_board_info(void)
 	mvBoardNameGet(name_buff, 50);
 	pr_info("Board:        [%s]\n", name_buff);
 
+#if !defined(CONFIG_MACH_AVANTA_LP_FPGA)
 	mvCtrlModelRevNameGet(name_buff);
 	pr_info("Soc:          [%s]\n",  name_buff);
+#endif
 
 	pr_info("Endianness:   [%s]\n",  endianness);
 	pr_info("LSP version:  [%s]\n", LSP_VERSION);
@@ -1614,14 +1615,15 @@ static void __init alp_board_init(void)
 	if (mvUnitMapIsRsrcLimited() == MV_FALSE)
 		mvUnitMapSetAllMine();
 #endif
+
+#if !defined(CONFIG_MACH_AVANTA_LP_FPGA)
 	mvBoardEnvInit();
 
 	if (mvCtrlEnvInit()) {
 		pr_err("%s: Error: ctrlEnv init failed.\n", __func__);
 		return;
 	}
-
-#ifdef CONFIG_MACH_AVANTA_LP_FPGA
+#else
 	/* Replace PCI-0 Attribute for FPGA 0xE => 0xD */
 	mvTargetDefaultsArray[PEX0_MEM].attrib = 0xD8;
 #endif
@@ -1656,6 +1658,7 @@ static void __init alp_board_init(void)
 	mvCpuIfAddDecShow();
 	print_board_info();
 
+#if !defined(CONFIG_MACH_AVANTA_LP_FPGA)
 	alp_eth_init();
 #ifdef CONFIG_MV_IPC_NET
 	platform_device_register(&mv_ipc_net);
@@ -1668,11 +1671,11 @@ static void __init alp_board_init(void)
 	alp_rtc_init();
 	alp_sdio_init();
 	alp_i2c_init();
-
 #if 0
 	alp_gpio_init();
 	alp_hwmon_init();
 #endif
+#endif
 }
 
 static void board_restart(char mode, const char *cmd)
@@ -1693,3 +1696,15 @@ MACHINE_START(AVANTA_LP, "Marvell AvantaLP 88f66xx Board")
 	.init_machine   = alp_board_init,
 	.restart        = board_restart,
 MACHINE_END
+
+#if defined(CONFIG_MACH_AVANTA_LP_FPGA)
+MACHINE_START(AVANTA_LP_FPGA, "Marvell AvantaLP 88f66xx FPGA Board")
+	.atag_offset    = BOOT_PARAMS_OFFSET,
+	.map_io         = alp_map_io,
+	.init_irq       = alp_irq_init,
+	.timer          = &alp_timer,
+	.handle_irq     = gic_handle_irq,
+	.init_machine   = alp_board_init,
+	.restart        = board_restart,
+MACHINE_END
+#endif
diff --git a/arch/arm/mach-avantalp/export.c b/arch/arm/mach-avantalp/export.c
index 8170401..0f7fce8 100644
--- a/arch/arm/mach-avantalp/export.c
+++ b/arch/arm/mach-avantalp/export.c
@@ -210,6 +210,7 @@ EXPORT_SYMBOL(mvStackCreate);
 EXPORT_SYMBOL(mvStackDelete);
 EXPORT_SYMBOL(mvStackStatus);
 
+#ifdef CONFIG_MV_INCLUDE_ETH_PHY
 #include "eth-phy/mvEthPhy.h"
 EXPORT_SYMBOL(mvEthPhyRestartAN);
 EXPORT_SYMBOL(mvEthPhyDisableAN);
@@ -217,6 +218,7 @@ EXPORT_SYMBOL(mvEthPhyRegRead);
 EXPORT_SYMBOL(mvEthPhyRegWrite);
 EXPORT_SYMBOL(mvEthPhyAdvertiseSet);
 EXPORT_SYMBOL(mvEthPhyAdvertiseGet);
+#endif
 
 #include "common/mvCommon.h"
 EXPORT_SYMBOL(mvCharToHex);
diff --git a/arch/arm/mach-avantalp/include/mach/irqs.h b/arch/arm/mach-avantalp/include/mach/irqs.h
index 1f0d949..c13afac 100644
--- a/arch/arm/mach-avantalp/include/mach/irqs.h
+++ b/arch/arm/mach-avantalp/include/mach/irqs.h
@@ -59,6 +59,7 @@
 #define IRQ_GLOBAL_TDM			59
 
 #define IRQ_GLOBAL_PCIE0		61
+#define IRQ_GLOBAL_PCI0			62 /* FPGA only */
 #define IRQ_GLOBAL_PCIE1		65
 
 #define IRQ_GLOBAL_PP_PORT0_RXTX	69
diff --git a/arch/arm/mach-avantalp/pci.c b/arch/arm/mach-avantalp/pci.c
index 6951093..193494c 100644
--- a/arch/arm/mach-avantalp/pci.c
+++ b/arch/arm/mach-avantalp/pci.c
@@ -40,26 +40,27 @@
 #	define DB(x) 
 #endif
 
-static int __init mv_map_irq(struct pci_dev *dev, u8 slot, u8 pin);
-
 extern u32 mv_pci_mem_size_get(int ifNum);
 extern u32 mv_pci_io_base_get(int ifNum);
 extern u32 mv_pci_io_size_get(int ifNum);
 extern u32 mv_pci_mem_base_get(int ifNum);
 
+static int __init mv_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return IRQ_GLOBAL_PCI0;
+}
+
+static void *mv_get_irqmap_func[] __initdata = {
+	mv_map_irq,
+};
+
 void __init mv_pci_preinit(void)
 {
-	MV_ADDR_WIN win;
-	
 	if (mvCtrlPciMaxIfGet() > 1)
 		panic("Single PCI is supported ONLY!");
 
        	mvPciInit(0, MV_PCI_MOD_HOST);
 
-	/* I/O remmap */
-	win.baseLow = 0x0;
-	win.baseHigh = 0x0;
-	mvCpuIfPciRemap(PCI_IF0_IO, &win);
 }
 
 
@@ -162,81 +163,82 @@ static struct pci_ops mv_pci_ops = {
         .write  = mv_pci0_write_config,
 };
 
-int __init mv_pci_setup(int nr, struct pci_sys_data *sys)
+static int __init mv_pci_setup(int nr, struct pci_sys_data *sys)
 {
-        struct resource *res;
+	struct resource *res;
+	u32 mem_base, mem_size;
+	u32 io_base, io_size;
+
+	res = kzalloc(2 * sizeof(struct resource), GFP_KERNEL);
+	if (!res) {
+		panic("%s: memory alloc failed\n", __func__);
+		return 0;
+	}
 
-	if (nr)
-		panic("Single PCI is supported ONLY!");
+	/* Save the HW iface number for this PCI bus */
+	sys->mv_controller_num = nr;
+	sys->map_irq = mv_get_irqmap_func[nr];
 
-        sys->map_irq = mv_map_irq;
+	/*
+	 * Init PCI memory space
+	 */
+	mem_base  = mv_pci_mem_base_get(nr);
+	mem_size  = mv_pci_mem_size_get(nr);
 
-	res = kmalloc(sizeof(struct resource) * 2, GFP_KERNEL);
-        if (!res)
-                panic("PCI: unable to alloc resources");
-                                                                                                                             
-        memset(res, 0, sizeof(struct resource) * 2);
-                                                                                                                             
-	res[0].start = mv_pci_io_base_get(0) - IO_SPACE_REMAP;
-	res[0].end   =  mv_pci_io_base_get(0) - IO_SPACE_REMAP +  mv_pci_io_size_get(0) - 1;
-	res[0].name  = "PCI0 IO Primary";
-	res[0].flags = IORESOURCE_IO;
-                                                                                                                             
-	res[1].start =  mv_pci_mem_base_get(0);
-	res[1].end   =  mv_pci_mem_base_get(0) +  mv_pci_mem_size_get(0) - 1;
-	res[1].name  = "PCI0 Memory Primary";
-	res[1].flags = IORESOURCE_MEM;
- 
-        if (request_resource(&ioport_resource, &res[0]))
-		printk ("IO Request resource failed - Pci If %x\n",nr);
+	res[0].start = mem_base;
+	res[0].end   = mem_base + mem_size - 1;
+	res[0].name  = "PCI Memory Primary";
+	res[0].flags = IORESOURCE_MEM;
 
-	if (request_resource(&iomem_resource, &res[1]))
-		printk ("Memory Request resource failed - Pci If %x\n",nr);
- 
-        sys->resource[0] = &res[0];
-        sys->resource[1] = &res[1];
-        sys->resource[2] = NULL;
-        sys->io_offset   = 0x0;
- 
-        return 1;
+	if (request_resource(&iomem_resource, &res[0]))
+		panic("Request PCI%d Memory resource failed\n", nr);
 
-}
+	pci_add_resource_offset(&sys->resources, &res[0], sys->mem_offset);
 
-struct pci_bus *mv_pci_scan_bus(int nr, struct pci_sys_data *sys)
-{
-	struct pci_ops *ops;
-	struct pci_bus *bus;
+	/*
+	 * Init PCI IO space
+	 */
+	io_base   = mv_pci_io_base_get(nr);
+	io_size   = mv_pci_io_size_get(nr);
 
-        if (nr)
-		panic("Single PCI is supported ONLY!");
+	res[1].start = io_base - IO_SPACE_REMAP;
+	res[1].end   = io_base - IO_SPACE_REMAP + io_size - 1;
+	res[1].name  = "PCI I/O Primary";
+	res[1].flags = IORESOURCE_IO;
+
+	if (request_resource(&ioport_resource, &res[1]))
+		panic("Request PCI%d IO resource failed\n", nr);
+
+	sys->io_offset = 0;
+	pci_add_resource_offset(&sys->resources, &res[1], sys->io_offset);
 
-	ops = &mv_pci_ops;
-	bus = pci_scan_bus(sys->busnr, ops, sys);
-	return bus;
+	return 1;
 }
 
-static int __init mv_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+struct pci_bus *mv_pci_scan_bus(int nr, struct pci_sys_data *sys)
 {
-	return IRQ_AURORA_PCI0;
+	if (nr)
+		panic("Single PCI is supported ONLY!");
+
+	return pci_scan_root_bus(NULL, sys->busnr, &mv_pci_ops, sys, &sys->resources);
 }
 
 static struct hw_pci mv_pci __initdata = {
 	.swizzle        	= pci_std_swizzle,
-        .map_irq                = mv_map_irq,
         .setup                  = mv_pci_setup,
         .scan                   = mv_pci_scan_bus,
         .preinit                = mv_pci_preinit,
 };
- 
+
 static int __init mv_pci_init(void)
 {
 	MV_U32 ifnum = mvCtrlPciMaxIfGet();
 	if (ifnum) {
-		mv_pci.nr_controllers = ifnum; 
+		mv_pci.nr_controllers = ifnum;
 		pci_common_init(&mv_pci);
 	}
 
-    return 0;
+	return 0;
 }
 
 subsys_initcall(mv_pci_init);
diff --git a/arch/arm/mach-avantalp/sysmap.c b/arch/arm/mach-avantalp/sysmap.c
index 8bee0cf..e2887a0 100644
--- a/arch/arm/mach-avantalp/sysmap.c
+++ b/arch/arm/mach-avantalp/sysmap.c
@@ -150,6 +150,9 @@ MV_CPU_DEC_WIN *mv_sys_map(void)
 	MV_U16 ctrlModel = mvCtrlModelGet();
 
 	switch (ctrlModel) {
+	case MV_88F66X0:
+		map = SYSMAP_ALP_6660;
+		break;
 	case MV_6660_DEV_ID:
 		map = SYSMAP_ALP_6660;
 		break;
diff --git a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
index bb1886f..e1c38a9 100644
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -122,6 +122,7 @@ xcat98dx		MACH_XCAT98DX		XCAT98DX		527
 armada_xp_fpga		MACH_ARMADA_XP_FPGA	ARMADA_XP_FPGA		528
 avanta_lp		MACH_AVANTA_LP		AVANTA_LP		529
 armada_38x		MACH_ARMADA_38X		ARMADA_38X		530
+avanta_lp_fpga		MACH_AVANTA_LP_FPGA	AVANTA_LP_FPGA		531
 feroceon_kw2		ARCH_FEROCEON_KW2	FEROCEON_KW2		529
 edb9302			MACH_EDB9302		EDB9302			538
 husky			MACH_HUSKY		HUSKY			543
-- 
1.7.5.4

