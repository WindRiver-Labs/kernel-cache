From 0a397b73b3241c27754075e94056629220992788 Mon Sep 17 00:00:00 2001
From: Ofer Heifetz <oferh@marvell.com>
Date: Sun, 2 Feb 2014 16:11:07 +0200
Subject: [PATCH 1327/1825] spi: msys: add SPI support

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit ba338248c0b21109f1834a9c5800536d0513842f

	This commit adds SPI support for MSYS, SPI support added to MSYS defconig

	The following was done to validate
	1) write 30MB of random data, verify after reset
	2) load rootfs from 30MB rootfs partition formatted as jffs2

	following config for jffs2:
	configure flash mapping:
		setenv mtdParts mtdparts=spi_flash:2m(uboot)ro,-(rootfs)  # 2MB-uboot, 30MB-rootfs
	modify bootcmd to boot from SPI:
		root=/dev/mtdblock1 rw
		init=/linuxrc
		rootfstype=jffs2
		rootwait
		${mtdParts}
	make a 30MB rootfs
		mkfs.jffs2 -l --pad=0x1E00000 -d ./rootfs -o jffs2-arm.img
	erase the 30MB flash
		flash_erase -j  /dev/mtd1 0x0 480
	write new image to SPI
		mtd_debug write /dev/mtd1 0 31457280 jffs2-arm.img

	This commit changed the plat-armada SPI routines by replacing the low level locking
	 from local_irq_save to spin_lock_irqsave. This was done since more than one core access
	 the global SPI command structure.

Change-Id: Id5d1ca339439054a3cf11155390d9c486aa7995d
Signed-off-by: Ofer Heifetz <oferh@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/5407
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Gal Zion <galz@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/configs/msys_defconfig                    |    2 -
 arch/arm/mach-msys/config/mvSysSpiConfig.h         |   36 +++
 arch/arm/mach-msys/core.c                          |    7 +
 arch/arm/mach-msys/flashmap.c                      |   46 ++--
 arch/arm/mach-msys/include/mach/msys.h             |    2 +-
 arch/arm/mach-msys/mv_hal_if/mvSysSFlash.c         |  245 ++++++++++++++++++++
 arch/arm/mach-msys/mv_hal_if/mvSysSpi.c            |  125 ++++++++++
 arch/arm/mach-msys/mv_hal_if/mvSysSpiApi.h         |   70 ++++++
 arch/arm/plat-armada/Kconfig                       |    2 +-
 .../arm/plat-armada/mv_drivers_lsp/mv_mtd/sflash.c |   67 +++---
 10 files changed, 535 insertions(+), 67 deletions(-)
 create mode 100644 arch/arm/mach-msys/config/mvSysSpiConfig.h
 create mode 100644 arch/arm/mach-msys/mv_hal_if/mvSysSFlash.c
 create mode 100644 arch/arm/mach-msys/mv_hal_if/mvSysSpi.c
 create mode 100644 arch/arm/mach-msys/mv_hal_if/mvSysSpiApi.h

diff --git a/arch/arm/configs/msys_defconfig b/arch/arm/configs/msys_defconfig
index 103dc7c..a621f70 100644
--- a/arch/arm/configs/msys_defconfig
+++ b/arch/arm/configs/msys_defconfig
@@ -19,11 +19,9 @@ CONFIG_PARTITION_ADVANCED=y
 CONFIG_EFI_PARTITION=y
 CONFIG_ARCH_MSYS=y
 # CONFIG_MV_INCLUDE_GIG_ETH is not set
-# CONFIG_MV_INCLUDE_SPI is not set
 CONFIG_MV_HAL_RULES_PATH="arch/arm/mach-armadaxp/mv_hal_support/mvRules.mk"
 # CONFIG_MV_INCLUDE_XOR is not set
 # CONFIG_MV_INCLUDE_NFC is not set
-# CONFIG_MV_INCLUDE_LEGACY_NAND is not set
 # CONFIG_MV_INCLUDE_SDIO is not set
 CONFIG_MV_PMU_PROC=y
 # CONFIG_SWP_EMULATE is not set
diff --git a/arch/arm/mach-msys/config/mvSysSpiConfig.h b/arch/arm/mach-msys/config/mvSysSpiConfig.h
new file mode 100644
index 0000000..9901193
--- /dev/null
+++ b/arch/arm/mach-msys/config/mvSysSpiConfig.h
@@ -0,0 +1,36 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysSpiConfig.h - Marvell SPI unit specific configurations
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include "mvSysHwConfig.h"
+
+/*
+** Base address for SPI registers.
+*/
+#define MV_SPI_REGS_BASE(unit)		(MV_SPI_REGS_OFFSET(unit))
diff --git a/arch/arm/mach-msys/core.c b/arch/arm/mach-msys/core.c
index 61146f5..fe36236 100644
--- a/arch/arm/mach-msys/core.c
+++ b/arch/arm/mach-msys/core.c
@@ -86,6 +86,9 @@ disclaimer.
 #include "ctrlEnv/mvCtrlEnvSpec.h"
 #include "ctrlEnv/mvCtrlEnvRegs.h"
 
+/* SPI */
+#include "mvSysSpiApi.h"
+
 /* for debug putstr */
 static char arr[256];
 
@@ -616,6 +619,10 @@ static void __init msys_bc2_rd_init(void)
 
 	mv_gpio_init();
 
+#ifdef CONFIG_MV_INCLUDE_SPI
+	mvSysSpiInit(0, _16M);
+#endif
+
 	return;
 }
 
diff --git a/arch/arm/mach-msys/flashmap.c b/arch/arm/mach-msys/flashmap.c
index 5d7ce00..5dff005 100644
--- a/arch/arm/mach-msys/flashmap.c
+++ b/arch/arm/mach-msys/flashmap.c
@@ -46,8 +46,7 @@ disclaimer.
 #include "ctrlEnv/sys/mvCpuIf.h"
 #include "ctrlEnv/mvUnitMap.h"
 
-#define MTD_FLASH_MAP_DEBUG
-
+/*#define MTD_FLASH_MAP_DEBUG*/
 #ifdef MTD_FLASH_MAP_DEBUG
 #define DB(x)	x
 #else
@@ -109,16 +108,15 @@ static int flashInfoFill(void)
 
 		if ((maps[expectedDevs].mapInfo.phys != 0xFFFFFFFF) &&
 		    (maps[expectedDevs].mapInfo.size != 0xFFFFFFFF)) {
-			DB(printk("\nINFO: Found %s %d - base 0x%08x, size 0x%x, bus %d",
+			DB(printk(KERN_INFO "\nINFO: Found %s %d - base 0x%08x, size 0x%x, bus %d",
 				maps[expectedDevs].mapInfo.name, i,
 				(unsigned int)maps[expectedDevs].mapInfo.phys,
 				(unsigned int)maps[expectedDevs].mapInfo.size,
 				maps[expectedDevs].mapInfo.bankwidth));
 			++expectedDevs;
-		} else {
+		} else
 			printk(KERN_NOTICE "\nERROR: %s - Failed to get Device Base address and Size (%s %d)",
 				__func__, maps[expectedDevs].mapInfo.name, i);
-		}
 	}
 #endif
 
@@ -139,18 +137,18 @@ static int flashInfoFill(void)
 
 		if ((maps[expectedDevs].mapInfo.phys != 0xFFFFFFFF) &&
 		    (maps[expectedDevs].mapInfo.size != 0xFFFFFFFF)) {
-			DB(printk("\nINFO: Found %s %d - base 0x%08x, size 0x%x", maps[expectedDevs].mapInfo.name, i,
+			DB(printk(KERN_INFO "\nINFO: Found %s %d - base 0x%08x, size 0x%x",
+						maps[expectedDevs].mapInfo.name, i,
 						(unsigned int)maps[expectedDevs].mapInfo.phys,
 						(unsigned int)maps[expectedDevs].mapInfo.size));
 			++expectedDevs;
-		} else {
+		} else
 			printk(KERN_NOTICE "\nERROR: %s - Failed to get Device Base address and Size (%s %d)",
 					__func__, maps[expectedDevs].mapInfo.name, i);
-		}
 	}
 #endif
 
-	DB(printk("\nINFO: %s - Found %d Flash Devices", __func__, expectedDevs));
+	DB(printk(KERN_INFO "\nINFO: %s - Found %d Flash Devices", __func__, expectedDevs));
 	return expectedDevs;
 }
 
@@ -169,21 +167,20 @@ static int __init flashProbe(char **mtdDrv, struct map_info *map, struct mtd_inf
 		return -EIO;
 	}
 
-	DB(printk("\nINFO: Io remapped successfully - phy addr = 0x%08x, virt addr = 0x%08x",
+	DB(printk(KERN_INFO "\nINFO: Io remapped successfully - phy addr = 0x%08x, virt addr = 0x%08x",
 		(unsigned int)map->phys, (unsigned int)map->virt));
 
 	simple_map_init(map);
 
 	*mtd = NULL;
 	for (; (!(*mtd) && *mtdDrv); mtdDrv++) {
-		DB(printk("\nINFO: Using %s to probe %s at address 0x%08x, size 0x%x, width %dm",
+		DB(printk(KERN_INFO "\nINFO: Using %s to probe %s at address 0x%08x, size 0x%x, width %dm",
 				*mtdDrv, map->name, (unsigned int)map->phys,
 				(unsigned int)map->size, map->bankwidth));
 
-		*mtd = do_map_probe(*mtdDrv, map)
+		*mtd = do_map_probe(*mtdDrv, map);
 		if (*mtd) {
-			DB(printk(" - detected OK"));
-			/*map->size = (*mtd)->size;*/
+			DB(printk(KERN_INFO " - detected OK"));
 			(*mtd)->owner = THIS_MODULE;
 
 #ifdef CONFIG_MTD_CMDLINE_PARTS
@@ -202,9 +199,8 @@ static int __init flashProbe(char **mtdDrv, struct map_info *map, struct mtd_inf
 				return -ENXIO;
 			}
 			return 0;
-		} else {
-			DB(printk(KERN_DEBUG" - Not detected"));
-		}
+		} else
+			DB(printk(KERN_INFO " - Not detected"));
 	}
 
 	iounmap((void *)map->virt);
@@ -220,16 +216,17 @@ static int __init flash_map_init(void)
 		return 0;
 
 	mapsNum = flashInfoFill();
-	DB(printk(KERN_DEBUG "\nINFO: flash_map_init - detected %d devices\n",  mapsNum));
+	DB(printk(KERN_INFO "\nINFO: flash_map_init - detected %d devices\n",  mapsNum));
 
 	for (i = 0; i < mapsNum; i++) {
-		DB(printk(KERN_DEBUG "MTD: Initialize the %s device at address 0x%08x\n",
+		DB(printk(KERN_INFO "MTD: Initialize the %s device at address 0x%08x\n",
 			maps[i].mapInfo.name, (unsigned int)maps[i].mapInfo.phys));
-		if (flashProbe(maps[i].mtdDrv, &maps[i].mapInfo, &maps[i].mtdInfo) == 0) {
-			DB(printk(KERN_DEBUG" - OK.\n"));
-		} else {
+
+		if (flashProbe(maps[i].mtdDrv, &maps[i].mapInfo, &maps[i].mtdInfo) == 0)
+			DB(printk(KERN_INFO " - OK.\n"));
+		else {
 			maps[i].mtdInfo = NULL;
-			DB(printk(KERN_DEBUG" - FAILED!\n"));
+			DB(printk(KERN_INFO " - FAILED!\n"));
 		}
 	}
 
@@ -240,9 +237,6 @@ static void __exit flash_map_exit(void)
 {
 	int i;
 
-	if (-1 == mapsNum)
-		return;
-
 	for (i = 0; i < mapsNum; i++) {
 		if (maps[i].mtdInfo) {
 			mtd_device_unregister(maps[i].mtdInfo);
diff --git a/arch/arm/mach-msys/include/mach/msys.h b/arch/arm/mach-msys/include/mach/msys.h
index a29e804..bcbc884 100644
--- a/arch/arm/mach-msys/include/mach/msys.h
+++ b/arch/arm/mach-msys/include/mach/msys.h
@@ -164,7 +164,7 @@ disclaimer.
  * window needs to be enlarged.
  */
 #define SPI_CS0_PHYS_BASE		0xF6000000
-#define SPI_CS0_SIZE			_16M
+#define SPI_CS0_SIZE			_32M
 
 /*
  * Free area from 0xF9000000 to 0xFFF00000 (111MB).
diff --git a/arch/arm/mach-msys/mv_hal_if/mvSysSFlash.c b/arch/arm/mach-msys/mv_hal_if/mvSysSFlash.c
new file mode 100644
index 0000000..a30d3c9
--- /dev/null
+++ b/arch/arm/mach-msys/mv_hal_if/mvSysSFlash.c
@@ -0,0 +1,245 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "spi/mvSpi.h"
+#include "spi/mvSpiCmnd.h"
+#include "sflash/mvSysSFlash.h"
+
+#define MV_SYS_SFLASH_MAX_CMD_LEN	5
+
+struct  sflash_cmd {
+	MV_U8	buf[MV_SYS_SFLASH_MAX_CMD_LEN];
+	MV_U32	bufLen;
+	MV_U8	transType;
+};
+
+static struct sflash_cmd mvSysSflashCmd;
+
+/*******************************************************************************
+* mvSysSflashCommandSet
+*
+* DESCRIPTION:
+*	System interface for sending a command to the SPI flash.
+*
+* INPUT:
+*       flashHandle: Handle passed by OS glue by which an SPI flash is
+*		     identified.
+*	cmdBuff:     Command data to be written.
+*	cmdLen:	     Command length in bytes.
+*	transType:   Bitmask describing the transaction type, see
+*		     SYS_SFLASH_TRANS_XX for details.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysSflashCommandSet(MV_VOID *flashHandle, MV_U8 *cmdBuff, MV_U32 cmdLen,
+				MV_U8 transType)
+{
+	MV_STATUS	ret = MV_OK;
+
+	if (cmdLen > MV_SYS_SFLASH_MAX_CMD_LEN) {
+		mvOsPrintf("%s %d!\n", __func__, cmdLen);
+		return MV_ERROR;
+	}
+
+	if (!(transType & SYS_SFLASH_TRANS_START) || (mvSysSflashCmd.transType != 0)) {
+		mvOsPrintf("%s %d %d\n", __func__, transType, mvSysSflashCmd.transType);
+		return MV_ERROR;
+	}
+
+	mvSpiParamsSet(0, 0, SPI_TYPE_FLASH);
+
+	memcpy(mvSysSflashCmd.buf, cmdBuff, cmdLen);
+	mvSysSflashCmd.bufLen = cmdLen;
+	mvSysSflashCmd.transType = transType;
+
+	if (transType & SYS_SFLASH_TRANS_END) {
+		ret = mvSysSflashDataWrite(flashHandle, NULL, 0, transType);
+
+		if (ret)
+			mvOsPrintf("%s mvSysSflashDataWrite returned error %d!\n", __func__, ret);
+	}
+
+	return ret;
+}
+
+
+/*******************************************************************************
+* mvSysSflashDataRead
+*
+* DESCRIPTION:
+*	System interface for reading SPI flash data.
+*
+* INPUT:
+*       flashHandle: Handle passed by OS glue by which an SPI flash is
+*		     identified.
+*	dataBuff:    Buffer to read the data into.
+*	dataLen:     Number of bytes to read.
+*	dummyBytes:  Number of dummy bytes to read before reading the real
+*		     data.
+*	transType:   Bitmask describing the transaction type, see
+*		     SYS_SFLASH_TRANS_XX for details.
+*
+* OUTPUT:
+*	dataBuff: The data as read from flash.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysSflashDataRead(MV_VOID *flashHandle, MV_U8 *dataBuff, MV_U32 dataLen,
+		MV_U32 dummyBytes, MV_U8 transType)
+{
+	MV_STATUS  ret;
+
+	if (!(mvSysSflashCmd.transType & SYS_SFLASH_TRANS_START))
+		return MV_ERROR;
+
+	ret = mvSpiWriteThenRead(0, mvSysSflashCmd.buf, mvSysSflashCmd.bufLen,
+			dataBuff, dataLen, dummyBytes);
+
+	if (ret)
+		mvOsPrintf("%s mvSpiWriteThenRead returned error %d!\n", __func__, ret);
+
+	if (transType & SYS_SFLASH_TRANS_END)
+		memset(&mvSysSflashCmd, 0, sizeof(mvSysSflashCmd));
+
+	return ret;
+}
+
+
+/*******************************************************************************
+* mvSysSflashDataWrite
+*
+* DESCRIPTION:
+*	System interface for writing SPI flash data.
+*
+* INPUT:
+*       flashHandle: Handle passed by OS glue by which an SPI flash is
+*		     identified.
+*	dataBuff:    Buffer holding the data to be written.
+*	dataLen:     Number of bytes to write.
+*	transType:   Bitmask describing the transaction type, see
+*		     SYS_SFLASH_TRANS_XX for details.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysSflashDataWrite(MV_VOID *flashHandle, MV_U8 *dataBuff, MV_U32 dataLen,
+		MV_U8 transType)
+{
+	MV_STATUS ret;
+
+	if (!(mvSysSflashCmd.transType & SYS_SFLASH_TRANS_START))
+		return MV_ERROR;
+
+	ret = mvSpiWriteThenWrite(0, mvSysSflashCmd.buf, mvSysSflashCmd.bufLen, dataBuff, dataLen);
+
+	if (ret)
+		mvOsPrintf("%s mvSpiWriteThenWrite returned error %d!\n", __func__, ret);
+
+	if (transType & SYS_SFLASH_TRANS_END)
+		memset(&mvSysSflashCmd, 0, sizeof(mvSysSflashCmd));
+
+	return ret;
+}
+
+
+/*******************************************************************************
+* mvSysSflashFreqSet
+*
+* DESCRIPTION:
+*	System interface for controlling the SPI interface frequency.
+*
+* INPUT:
+*       flashHandle: Handle passed by OS glue by which an SPI flash is
+*		     identified.
+*	freq:	     The new frequency to be configured for the SPI IF.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysSflashFreqSet(MV_VOID *flashHandle, MV_U32 freq)
+{
+	return mvSpiBaudRateSet(0, freq);
+}
diff --git a/arch/arm/mach-msys/mv_hal_if/mvSysSpi.c b/arch/arm/mach-msys/mv_hal_if/mvSysSpi.c
new file mode 100644
index 0000000..fa61ec9
--- /dev/null
+++ b/arch/arm/mach-msys/mv_hal_if/mvSysSpi.c
@@ -0,0 +1,125 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "spi/mvSpi.h"
+#include "spi/mvSysSpi.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+
+
+/*******************************************************************************
+* mvSysSpiInit - Initialize the SPI subsystem
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_STATUS mvSysSpiInit(MV_U8 spiId, MV_U32 serialBaudRate)
+{
+	MV_SPI_HAL_DATA halData;
+
+	halData.ctrlModel = mvCtrlModelGet();
+	halData.tclk = mvBoardTclkGet();
+
+	return mvSpiInit(spiId, serialBaudRate, &halData);
+}
+
+
+/*******************************************************************************
+* mvSysSpiMppConfig
+*
+* DESCRIPTION:
+*	System interface for configuring the MPP's configuration to enable /
+*	disable SPI mode.
+*
+* INPUT:
+*	mode:	The mode to be set into MPP unit.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_OK on success,
+*	MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvSysSpiMppConfig(MV_U8 mode)
+{
+#if 0
+	if (mode == SYS_SPI_MPP_ENABLE)
+		mvMPPConfigToSPI();
+	else
+		mvMPPConfigToDefault();
+#endif
+	return MV_OK;
+}
diff --git a/arch/arm/mach-msys/mv_hal_if/mvSysSpiApi.h b/arch/arm/mach-msys/mv_hal_if/mvSysSpiApi.h
new file mode 100644
index 0000000..6c73d48
--- /dev/null
+++ b/arch/arm/mach-msys/mv_hal_if/mvSysSpiApi.h
@@ -0,0 +1,70 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_SPI_API_H__
+#define __MV_SYS_SPI_API_H__
+
+MV_STATUS mvSysSpiInit(MV_U8 spi_id, MV_U32 serialBaudRate);
+
+#endif
diff --git a/arch/arm/plat-armada/Kconfig b/arch/arm/plat-armada/Kconfig
index f703109..815c962 100644
--- a/arch/arm/plat-armada/Kconfig
+++ b/arch/arm/plat-armada/Kconfig
@@ -140,7 +140,7 @@ config MV_INCLUDE_GIG_ETH
 config MV_INCLUDE_SPI
 	bool "SPI Support"
 	depends on MV88F6500 || MV88F6281 || (MV78XX0 && !MV78XX0_Z0) || \
-		   ARMADA_XP || ARMADA_370 || AVANTA_LP || (ARMADA_38X && MV_CM_SPI)
+		   ARMADA_XP || ARMADA_370 || AVANTA_LP || (ARMADA_38X && MV_CM_SPI) || ARCH_MSYS
 	default y
 	help
 	For Armada38x, the NFC,	Legacy NAND,
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_mtd/sflash.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_mtd/sflash.c
index 2437984..5b9a0a9 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_mtd/sflash.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_mtd/sflash.c
@@ -39,6 +39,7 @@
 #include <linux/errno.h>
 #include <linux/version.h>
 #include <linux/interrupt.h>
+#include <linux/spinlock.h>
 #include <linux/mtd/map.h>
 #include <linux/mtd/mtd.h>
 #include "mvCommon.h"
@@ -55,15 +56,7 @@
 #define DB(x)
 #endif
 
-/* macros for interrupts enable/disable */
-#define sflash_disable_irqs(flags, sflash_in_irq)	\
-	sflash_in_irq = in_interrupt();			\
-	if (!sflash_in_irq)				 \
-		local_irq_save(flags);
-
-#define sflash_enable_irqs(flags, sflash_in_irq)	\
-	if (!sflash_in_irq)				 \
-		local_irq_restore(flags);
+static DEFINE_SPINLOCK(sf_lock);
 
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26))
 typedef uint32_t sflash_size_t;
@@ -96,7 +89,7 @@ static struct mtd_info *sflash_probe(struct map_info *map)
 {
 	struct mtd_info *mtd = NULL;
 	MV_SFLASH_INFO *sflash = NULL;
-	MV_ULONG flags = 0, sflash_in_irq = 0;
+	MV_ULONG flags = 0;
 
 #if defined(CONFIG_MV78200) || defined(CONFIG_MV632X)
 	if (MV_FALSE == mvSocUnitIsMappedToThisCpu(SPI_FLASH)) {
@@ -137,15 +130,15 @@ static struct mtd_info *sflash_probe(struct map_info *map)
 	/* Try to detect the flash and initialize it over SPI */
 	sflash->baseAddr         = map->phys;
 	sflash->index            = MV_INVALID_DEVICE_NUMBER; /* will be detected in init */
-	sflash_disable_irqs(flags, sflash_in_irq);
+	spin_lock_irqsave(&sf_lock, flags);
 	if (mvSFlashInit(sflash) != MV_OK) {
-		sflash_enable_irqs(flags, sflash_in_irq);
+		spin_unlock_irqrestore(&sf_lock, flags);
 		pr_warn("%s: Failed to init SPI flash\n", __func__);
 		kfree(mtd);
 		kfree(sflash);
 		return NULL;
 	}
-	sflash_enable_irqs(flags, sflash_in_irq);
+	spin_unlock_irqrestore(&sf_lock, flags);
 
 	/* After success fill in the MTD structure with the appropriate info */
 	mtd->erasesize = sflash->sectorSize;
@@ -201,19 +194,19 @@ static int sflash_read(struct mtd_info *mtd, loff_t from, size_t len,
 	struct map_info *map = mtd->priv;
 	MV_SFLASH_INFO *sflash = map->fldrv_priv;
 	MV_U32 offset = ((MV_U32)from);
-	MV_ULONG flags = 0, sflash_in_irq = 0;
+	MV_ULONG flags = 0;
 
 	*retlen = 0;
 
 	DB(printk("\nINFO: %s  - offset %08x, len %d", __func__, offset, (int)len));
 
-	sflash_disable_irqs(flags, sflash_in_irq);
+	spin_lock_irqsave(&sf_lock, flags);
 	if (mvSFlashBlockRd(sflash, offset, buf, len) != MV_OK) {
-		sflash_enable_irqs(flags, sflash_in_irq);
+		spin_unlock_irqrestore(&sf_lock, flags);
 		printk(KERN_NOTICE "\nERROR: %s - Failed to read block.", __func__);
 		return -1;
 	}
-	sflash_enable_irqs(flags, sflash_in_irq);
+	spin_unlock_irqrestore(&sf_lock, flags);
 
 	*retlen = len;
 
@@ -228,19 +221,19 @@ static int sflash_write(struct mtd_info *mtd, loff_t to, size_t len,
 	MV_SFLASH_INFO *sflash = map->fldrv_priv;
 /*	MV_SFLASH_INFO *sflash = mtd->priv;*/
 	MV_U32 offset = ((MV_U32)to);
-	MV_ULONG flags = 0, sflash_in_irq = 0;
+	MV_ULONG flags = 0;
 
 	*retlen = 0;
 
 	DB(printk("\nINFO: %s - offset %08x, len %d", __func__, offset, len));
 
-	sflash_disable_irqs(flags, sflash_in_irq);
+	spin_lock_irqsave(&sf_lock, flags);
 	if (mvSFlashBlockWr(sflash, offset, (MV_U8 *)buf, len) != MV_OK) {
-		sflash_enable_irqs(flags, sflash_in_irq);
+		spin_unlock_irqrestore(&sf_lock, flags);
 		printk(KERN_NOTICE "\nERROR: %s - Failed to write block", __func__);
 		return -1;
 	}
-	sflash_enable_irqs(flags, sflash_in_irq);
+	spin_unlock_irqrestore(&sf_lock, flags);
 
 	*retlen = len;
 
@@ -256,7 +249,7 @@ static int sflash_erase(struct mtd_info *mtd, struct erase_info *instr)
 /*	MV_SFLASH_INFO *sflash = mtd->priv;*/
 	MV_U32 fsec, lsec;
 	int i;
-	MV_ULONG flags = 0, sflash_in_irq = 0;
+	MV_ULONG flags = 0;
 
 	DB(printk("\nINFO: %s - Addr %08x, len %d", __func__, instr->addr, instr->len));
 
@@ -287,15 +280,15 @@ static int sflash_erase(struct mtd_info *mtd, struct erase_info *instr)
 	DB(printk("\nINFO: %s - from sector %u to %u", __func__, fsec,
 		  lsec - 1));
 
-	sflash_disable_irqs(flags, sflash_in_irq);
+	spin_lock_irqsave(&sf_lock, flags);
 	for (i = fsec; i < lsec; i++) {
 		if (mvSFlashSectorErase(sflash, i) != MV_OK) {
-			sflash_enable_irqs(flags, sflash_in_irq);
+			spin_unlock_irqrestore(&sf_lock, flags);
 			printk(KERN_NOTICE "\nError: %s - mvSFlashSectorErase on sector %d", __func__, i);
 			return -1;
 		}
 	}
-	sflash_enable_irqs(flags, sflash_in_irq);
+	spin_unlock_irqrestore(&sf_lock, flags);
 
 	instr->state = MTD_ERASE_DONE;
 	mtd_erase_callback(instr);
@@ -307,19 +300,19 @@ static int sflash_lock(struct mtd_info *mtd, loff_t ofs, sflash_size_t len)
 {
 	struct map_info *map = mtd->priv;
 	MV_SFLASH_INFO *sflash = map->fldrv_priv;
-	MV_ULONG flags = 0, sflash_in_irq = 0;
+	MV_ULONG flags = 0;
 
 /*	MV_SFLASH_INFO *sflash = mtd->priv;*/
 
 	DB(printk("\nINFO: %s called", __func__));
 
-	sflash_disable_irqs(flags, sflash_in_irq);
+	spin_lock_irqsave(&sf_lock, flags);
 	if (mvSFlashWpRegionSet(sflash, MV_WP_ALL) != MV_OK) {
-		sflash_enable_irqs(flags, sflash_in_irq);
+		spin_unlock_irqrestore(&sf_lock, flags);
 		printk(KERN_NOTICE "\nError: %s - mvSFlashWpRegionSet failed", __func__);
 		return -1;
 	}
-	sflash_enable_irqs(flags, sflash_in_irq);
+	spin_unlock_irqrestore(&sf_lock, flags);
 
 	printk("\nNotice: Serial SPI flash (%s) lock per sector is not supported!\n        Locking the whole device.", mtd->name);
 
@@ -330,19 +323,19 @@ static int sflash_unlock(struct mtd_info *mtd, loff_t ofs, sflash_size_t len)
 {
 	struct map_info *map = mtd->priv;
 	MV_SFLASH_INFO *sflash = map->fldrv_priv;
-	MV_ULONG flags = 0, sflash_in_irq = 0;
+	MV_ULONG flags = 0;
 
 /*	MV_SFLASH_INFO *sflash = mtd->priv;*/
 
 	DB(printk("\nINFO: %s called", __func__));
 
-	sflash_disable_irqs(flags, sflash_in_irq);
+	spin_lock_irqsave(&sf_lock, flags);
 	if (mvSFlashWpRegionSet(sflash, MV_WP_NONE) != MV_OK) {
-		sflash_enable_irqs(flags, sflash_in_irq);
+		spin_unlock_irqrestore(&sf_lock, flags);
 		printk(KERN_NOTICE "\nError: %s - mvSFlashWpRegionSet failed", __func__);
 		return -1;
 	}
-	sflash_enable_irqs(flags, sflash_in_irq);
+	spin_unlock_irqrestore(&sf_lock, flags);
 
 	printk("\nNotice: Serial SPI flash (%s) unlock per sector is not supported!\n        Unlocking the whole device.", mtd->name);
 	return 0;
@@ -363,17 +356,17 @@ static void sflash_resume(struct mtd_info *mtd)
 {
 	struct map_info *map = mtd->priv;
 	MV_SFLASH_INFO *sflash = map->fldrv_priv;
-	MV_ULONG flags = 0, sflash_in_irq = 0;
+	MV_ULONG flags = 0;
 
-	sflash_disable_irqs(flags, sflash_in_irq);
+	spin_lock_irqsave(&sf_lock, flags);
 	if (mvSFlashInit(sflash) != MV_OK) {
-		sflash_enable_irqs(flags, sflash_in_irq);
+		spin_unlock_irqrestore(&sf_lock, flags);
 		printk(KERN_NOTICE "ERROR: %s - Failed to initialize the SFlash.", __func__);
 		kfree(mtd);
 		kfree(sflash);
 		return;
 	}
-	sflash_enable_irqs(flags, sflash_in_irq);
+	spin_unlock_irqrestore(&sf_lock, flags);
 
 	printk(KERN_NOTICE "Resuming serial Flash succeeded\n");
 }
-- 
1.7.5.4

