From 50db594a92c7c67a8228986b58f78a9f407a853d Mon Sep 17 00:00:00 2001
From: Nadav Haklai <nadavh@marvell.com>
Date: Mon, 11 Nov 2013 18:19:22 +0200
Subject: [PATCH 1139/1825] fix: iocc: a38x: Enable HW dma io sync barrier

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit f47b0ed5e6d058c6bcfcda2cc7a50b217ed751c3

	The dma io sync barrier Silicone bug was fixed in Armada 38x
	Therefore, Remove the dma_io_sync barrier WA using the XOR engine
	and enable the HW CPU IO Sync Barrier

Change-Id: I67421ac4f8bd1e66d517e8315c56c5e049ae4325
Signed-off-by: Nadav Haklai <nadavh@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/4294
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Tawfik Bayouk <tawfik@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-armada38x/core.c                   |   89 +---------------------
 arch/arm/mach-armada38x/include/mach/armada38x.h |    1 +
 arch/arm/mach-armada38x/include/mach/io.h        |   10 +++
 3 files changed, 14 insertions(+), 86 deletions(-)

diff --git a/arch/arm/mach-armada38x/core.c b/arch/arm/mach-armada38x/core.c
index 04d8cf7..45451b3 100644
--- a/arch/arm/mach-armada38x/core.c
+++ b/arch/arm/mach-armada38x/core.c
@@ -62,10 +62,6 @@
 #include <plat/mv_xor.h>
 #endif
 
-#ifdef CONFIG_IOCC_SYNC_BARRIER_WA
-#include "xor/mvXorRegs.h"
-#endif
-
 #if defined(CONFIG_MV_ETH_NETA)
 #include <linux/mv_neta.h>
 #endif
@@ -934,7 +930,6 @@ static void __init a38x_xor0_init(void)
 
 	platform_device_register(&a38x_xor0_shared);
 
-#ifndef CONFIG_IOCC_SYNC_BARRIER_WA
 	/*
 	 * two engines can't do memset simultaneously, this limitation
 	 * satisfied by removing memset support from one of the engines.
@@ -947,7 +942,6 @@ static void __init a38x_xor0_init(void)
 	dma_cap_set(DMA_MEMSET, a38x_xor01_data.cap_mask);
 	dma_cap_set(DMA_XOR, a38x_xor01_data.cap_mask);
 	platform_device_register(&a38x_xor01_channel);
-#endif
 }
 
 /*
@@ -1040,12 +1034,15 @@ static void __init a38x_xor1_init(void)
 	 * two engines can't do memset simultaneously, this limitation
 	 * satisfied by removing memset support from one of the engines.
 	 */
+	dma_cap_set(DMA_MEMCPY, a38x_xor10_data.cap_mask);
 	dma_cap_set(DMA_XOR, a38x_xor10_data.cap_mask);
 	platform_device_register(&a38x_xor10_channel);
 
 	dma_cap_set(DMA_MEMCPY, a38x_xor11_data.cap_mask);
 	dma_cap_set(DMA_MEMSET, a38x_xor11_data.cap_mask);
+	dma_cap_set(DMA_XOR, a38x_xor11_data.cap_mask);
 	platform_device_register(&a38x_xor11_channel);
+
 }
 #endif
 
@@ -1092,9 +1089,6 @@ static void print_board_info(void)
 	pr_info("  LSP version: %s\n", LSP_VERSION);
 #ifdef CONFIG_AURORA_IO_CACHE_COHERENCY
 	pr_info("  IOCC: Support IO coherency.\n");
-#ifdef CONFIG_IOCC_SYNC_BARRIER_WA
-	pr_info("     -> Sync Barrier WA enabled\n");
-#endif
 #endif
 #ifdef CONFIG_MV_AMP_ENABLE
 	mvUnitMapPrint();
@@ -1107,75 +1101,6 @@ static void print_board_info(void)
  */
 #ifdef CONFIG_AURORA_IO_CACHE_COHERENCY
 
-#ifdef CONFIG_IOCC_SYNC_BARRIER_WA
-
-/*	The A38X IOCC SYNC Barrirer WA overcomes the A38X Z1 revision sync barrier issue using the XOR engine.
-	When the dma_io_sync is called by each of the CPUs, the correct channel (CPU dependent) is activated
-	to preform a memset operation. The XOR's memset operation provides the required IO transaction that
-	guerentees that the latest data fetched from the IO is coherent.
-	The WA uses both channels of XOR engine 0.
-*/
-
-dma_addr_t dma_io_sync_buff_phys[CONFIG_NR_CPUS];
-volatile u32 *dma_io_sync_buff_virt[CONFIG_NR_CPUS];
-
-void dma_io_sync(void)
-{
-	int idx = smp_processor_id();
-	volatile u32 data;
-
-	/* Write '1' to the first word of the buffer */
-	*dma_io_sync_buff_virt[idx] = 0x1;
-
-	/* Wait untill the engine is idle */
-	while ((MV_REG_READ(XOR_ACTIVATION_REG(0, idx)) >> 4) & 0x3)
-		;
-
-	dmb();
-
-	/* Trigger channel */
-	MV_REG_WRITE((XOR_ACTIVATION_REG(0, idx)), 0x1);
-
-	/* Poll the data until it is cleard by the XOR transaction */
-	do {
-		data = *((volatile u32 *)dma_io_sync_buff_virt[idx]);
-
-	} while (data);
-
-	return;
-}
-
-static void dma_io_sync_wa_init(void)
-{
-	int i;
-
-	/* Allcate memory as XOR engine target, Use XOR unit 0 */
-	for (i = 0; i < CONFIG_NR_CPUS; i++) {
-		dma_io_sync_buff_virt[i] = kzalloc(PAGE_SIZE, GFP_KERNEL);
-		if (!dma_io_sync_buff_virt[i]) {
-			pr_err("%s: Error - Cannot allocate memory for iocc sync WA.\n", __func__);
-			return;
-		}
-
-		dma_io_sync_buff_phys[i] = dma_map_single(NULL, (void *)dma_io_sync_buff_virt[i],
-				PAGE_SIZE, DMA_FROM_DEVICE);
-
-		/* Initialize the XOR engines. */
-		MV_REG_WRITE(XOR_CONFIG_REG(0, i), 0x444);			/* Set to memset operation */
-		MV_REG_WRITE(XOR_BLOCK_SIZE_REG(0, i), 128);			/* Set memset size */
-		MV_REG_WRITE(XOR_DST_PTR_REG(0, i) , dma_io_sync_buff_phys[i]);	/* Set buffer address */
-	}
-
-	MV_REG_WRITE(XOR_INIT_VAL_LOW_REG(0), 0x0);				/* Set initVal Low to '0' */
-	MV_REG_WRITE(XOR_INIT_VAL_HIGH_REG(0), 0x0);				/* Set initVal High to '0' */
-}
-#else
-void dma_io_sync(void)
-{
-	/* Need to implement final dma io sync for A38X */
-}
-#endif /* CONFIG_IOCC_SYNC_BARRIER_WA */
-
 /*
  * All combinations of IOCC/SMP/UP should be supported:
  *     UP  + HWCC (Hardware Cache Coherency)
@@ -1191,16 +1116,8 @@ static void __init a38x_init_iocc(void)
 	scu_enable(scu_base);
 #endif
 
-	dma_io_sync_wa_init();
-
 	return;
 }
-
-#else
-void dma_io_sync(void)
-{
-	/* No IOCC is needed in SWCC mode */
-}
 #endif /* CONFIG_AURORA_IO_CACHE_COHERENCY */
 
 static void __init a38x_init_l2x0_cache(void)
diff --git a/arch/arm/mach-armada38x/include/mach/armada38x.h b/arch/arm/mach-armada38x/include/mach/armada38x.h
index 198f418..7fa3102 100644
--- a/arch/arm/mach-armada38x/include/mach/armada38x.h
+++ b/arch/arm/mach-armada38x/include/mach/armada38x.h
@@ -149,5 +149,6 @@
 #define IN_DOORBELL_CAUSE		0x78
 #define IN_DRBEL_CAUSE			(PER_CPU_BASE | 0x78)
 #define IN_DRBEL_MSK			(PER_CPU_BASE | 0x7c)
+#define CPU_IO_SYNC_BARRIER_CTRL_REG	(PER_CPU_BASE | 0x10)
 
 #endif /* __ASM_ARCH_AURORA_H */
diff --git a/arch/arm/mach-armada38x/include/mach/io.h b/arch/arm/mach-armada38x/include/mach/io.h
index 2f8da5d..7d05359 100644
--- a/arch/arm/mach-armada38x/include/mach/io.h
+++ b/arch/arm/mach-armada38x/include/mach/io.h
@@ -24,4 +24,14 @@ extern void __a38x_iounmap(void __iomem *addr);
 #define __arch_ioremap	__a38x_ioremap
 #define __arch_iounmap	__a38x_iounmap
 
+#ifdef CONFIG_AURORA_IO_CACHE_COHERENCY
+#define dma_io_sync()	do {				\
+	writel(0x1, CPU_IO_SYNC_BARRIER_CTRL_REG);		\
+	while (readl(CPU_IO_SYNC_BARRIER_CTRL_REG) & 0x1)	\
+		;					\
+} while (0)
+#else
+#define dma_io_sync()	do { } while (0)
+#endif
+
 #endif /* __ASM_ARCH_IO_H */
-- 
1.7.5.4

