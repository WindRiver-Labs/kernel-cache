From 8bdaf8524157a06808d4045f240ac54f45d4990a Mon Sep 17 00:00:00 2001
From: Dmitri Epshtein <dima@marvell.com>
Date: Mon, 22 Jul 2013 08:38:25 -0400
Subject: [PATCH 0862/1825] PPv2: fix: hot unplug bug with timer crushed
 (found on AXP)

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 9945875e37acfec80f71beddfb551ffb229fb2fe

	In tx_done_timer callback function check if CPU migration occurs
	Change some statistics to be per CPU (irq, poll, tx_done_timer, others)
	Delete unused cleanup timer and some statistics

Change-Id: I505fe53051ca016ba2b7ad50a58e2421c27d718a
Reviewed-on: http://vgitil04.il.marvell.com:8080/2742
Reviewed-by: Nadav Haklai <nadavh@marvell.com>
Tested-by: Nadav Haklai <nadavh@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_ethernet.c    |    2 -
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c      |  123 ++++++++-----------
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h      |   35 ++----
 3 files changed, 64 insertions(+), 96 deletions(-)

diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_ethernet.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_ethernet.c
index 1eac3fe..2d8537b 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_ethernet.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_ethernet.c
@@ -153,8 +153,6 @@ int mv_eth_stop(struct net_device *dev)
 		cpuCtrl = priv->cpu_config[cpu];
 		del_timer(&cpuCtrl->tx_done_timer);
 		clear_bit(MV_ETH_F_TX_DONE_TIMER_BIT, &(cpuCtrl->flags));
-		del_timer(&cpuCtrl->cleanup_timer);
-		clear_bit(MV_ETH_F_CLEANUP_TIMER_BIT, &(cpuCtrl->flags));
 	}
 	if (dev->irq != 0)
 		free_irq(dev->irq, priv);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
index 65d46a0..058fca9 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
@@ -1526,7 +1526,6 @@ inline int mv_eth_refill(struct eth_port *pp, int rxq,
 		if (!skb) {
 			mvOsFree(pkt);
 			pool->missed++;
-			mv_eth_add_cleanup_timer(pp->cpu_config[smp_processor_id()]);
 			return 1;
 		}
 	}
@@ -1775,7 +1774,6 @@ static inline int mv_eth_rx(struct eth_port *pp, int rx_todo, int rxq, struct na
 		if (err) {
 			printk(KERN_ERR "Linux processing - Can't refill\n");
 			pp->rxq_ctrl[rxq].missed++;
-			mv_eth_add_cleanup_timer(pp->cpu_config[smp_processor_id()]);
 			rx_filled--;
 		}
 	}
@@ -2742,19 +2740,20 @@ static struct bm_pool *mv_eth_pool_use(int pool, enum mv_eth_bm_type type, int p
 irqreturn_t mv_eth_isr(int irq, void *dev_id)
 {
 	struct eth_port *pp = (struct eth_port *)dev_id;
-	struct napi_group_ctrl *napi_group = pp->cpu_config[smp_processor_id()]->napi_group;
+	int cpu = smp_processor_id();
+	struct napi_group_ctrl *napi_group = pp->cpu_config[cpu]->napi_group;
 	struct napi_struct *napi = napi_group->napi;
 
 #ifdef CONFIG_MV_ETH_DEBUG_CODE
 	if (pp->dbg_flags & MV_ETH_F_DBG_ISR) {
 		pr_info("%s: port=%d, cpu=%d, mask=0x%x, cause=0x%x\n",
-			__func__, pp->port, smp_processor_id(),
+			__func__, pp->port, cpu,
 			mvPp2RdReg(MV_PP2_ISR_RX_TX_MASK_REG(MV_PPV2_PORT_PHYS(pp->port))),
 			mvPp2GbeIsrCauseRxTxGet(pp->port));
 	}
 #endif /* CONFIG_MV_ETH_DEBUG_CODE */
 
-	STAT_INFO(pp->stats.irq++);
+	STAT_INFO(pp->stats.irq[cpu]++);
 
 	/* Mask all interrupts for cpus in this group */
 	mvPp2GbeCpuInterruptsDisable(pp->port, napi_group->cpu_mask);
@@ -2764,11 +2763,11 @@ irqreturn_t mv_eth_isr(int irq, void *dev_id)
 		/* schedule the work (rx+txdone+link) out of interrupt contxet */
 		__napi_schedule(napi);
 	} else {
-		STAT_INFO(pp->stats.irq_err++);
+		STAT_INFO(pp->stats.irq_err[cpu]++);
 #ifdef CONFIG_MV_ETH_DEBUG_CODE
-		pr_err("mv_eth_isr ERROR: port=%d, cpu=%d, napi group id=%d, napi cpu_mask=0x%x\n",
-				pp->port, smp_processor_id(), napi_group->id, napi_group->cpu_mask);
-#endif
+		pr_debug("%s: IRQ=%d, port=%d, cpu=%d, cpu_mask=0x%x - NAPI already scheduled\n",
+			__func__, irq, pp->port, cpu, napi_group->cpu_mask);
+#endif /* CONFIG_MV_ETH_DEBUG_CODE */
 	}
 
 	return IRQ_HANDLED;
@@ -3631,8 +3630,6 @@ static int mv_eth_netdev_connect(struct eth_port *pp)
 	for_each_possible_cpu(cpu) {
 		cpuCtrl = pp->cpu_config[cpu];
 		cpuCtrl->napi_group = NULL;
-		cpuCtrl->tx_done_timer.data = (unsigned long)dev;
-		cpuCtrl->cleanup_timer.data = (unsigned long)dev;
 	}
 
 	if (pp->flags & MV_ETH_F_CONNECT_LINUX) {
@@ -4287,19 +4284,15 @@ mtu_out:
  ***********************************************************/
 static void mv_eth_tx_done_timer_callback(unsigned long data)
 {
-	struct cpu_ctrl *cpuCtrl;
-	struct net_device *dev = (struct net_device *)data;
-	struct eth_port *pp = MV_ETH_PRIV(dev);
+	struct cpu_ctrl *cpuCtrl = (struct cpu_ctrl *)data;
+	struct eth_port *pp = cpuCtrl->pp;
 	int tx_done = 0, tx_todo = 0;
 	unsigned int txq_mask;
 
-	STAT_INFO(pp->stats.tx_done_timer++);
-
-	cpuCtrl = pp->cpu_config[smp_processor_id()];
+	STAT_INFO(pp->stats.tx_done_timer_event[smp_processor_id()]++);
 
 	clear_bit(MV_ETH_F_TX_DONE_TIMER_BIT, &(cpuCtrl->flags));
 
-
 	if (!test_bit(MV_ETH_F_STARTED_BIT, &(pp->flags))) {
 		STAT_INFO(pp->stats.netdev_stop++);
 #ifdef CONFIG_MV_ETH_DEBUG_CODE
@@ -4318,32 +4311,14 @@ static void mv_eth_tx_done_timer_callback(unsigned long data)
 		tx_done = mv_eth_tx_done_gbe(pp, txq_mask, &tx_todo);
 	}
 
+	if (cpuCtrl->cpu != smp_processor_id()) {
+		pr_warning("%s: Called on other CPU - %d != %d\n", __func__, cpuCtrl->cpu, smp_processor_id());
+		cpuCtrl = pp->cpu_config[smp_processor_id()];
+	}
 	if (tx_todo > 0)
 		mv_eth_add_tx_done_timer(cpuCtrl);
 }
 
-/***********************************************************
- * mv_eth_cleanup_timer_callback --			   *
- *   N msec periodic callback for error cleanup            *
- ***********************************************************/
-static void mv_eth_cleanup_timer_callback(unsigned long data)
-{
-	struct cpu_ctrl *cpuCtrl;
-	struct net_device *dev = (struct net_device *)data;
-	struct eth_port *pp = MV_ETH_PRIV(dev);
-
-	STAT_INFO(pp->stats.cleanup_timer++);
-
-	cpuCtrl = pp->cpu_config[smp_processor_id()];
-	clear_bit(MV_ETH_F_CLEANUP_TIMER_BIT, &(cpuCtrl->flags));
-
-	if (!test_bit(MV_ETH_F_STARTED_BIT, &(pp->flags)))
-		return;
-
-	/* FIXME: check bm_pool->missed and pp->rxq_ctrl[rxq].missed counters and allocate */
-	/* re-add timer if necessary (check bm_pool->missed and pp->rxq_ctrl[rxq].missed   */
-}
-
 void mv_eth_mac_show(int port)
 {
 	struct eth_port *pp = mv_eth_port_by_id(port);
@@ -4489,6 +4464,8 @@ static int mv_eth_priv_init(struct eth_port *pp, int port)
 	for_each_possible_cpu(cpu) {
 		cpuCtrl = pp->cpu_config[cpu];
 		cpuCtrl->txq = CONFIG_MV_ETH_TXQ_DEF;
+		cpuCtrl->pp = pp;
+		cpuCtrl->cpu = cpu;
 	}
 
 	pp->flags = 0;
@@ -4515,12 +4492,9 @@ static int mv_eth_priv_init(struct eth_port *pp, int port)
 		cpuCtrl = pp->cpu_config[cpu];
 		memset(&cpuCtrl->tx_done_timer, 0, sizeof(struct timer_list));
 		cpuCtrl->tx_done_timer.function = mv_eth_tx_done_timer_callback;
+		cpuCtrl->tx_done_timer.data = (unsigned long)cpuCtrl;
 		init_timer(&cpuCtrl->tx_done_timer);
 		clear_bit(MV_ETH_F_TX_DONE_TIMER_BIT, &(cpuCtrl->flags));
-		memset(&cpuCtrl->cleanup_timer, 0, sizeof(struct timer_list));
-		cpuCtrl->cleanup_timer.function = mv_eth_cleanup_timer_callback;
-		init_timer(&cpuCtrl->cleanup_timer);
-		clear_bit(MV_ETH_F_CLEANUP_TIMER_BIT, &(cpuCtrl->flags));
 	}
 
 	pp->weight = CONFIG_MV_ETH_RX_POLL_WEIGHT;
@@ -4871,12 +4845,12 @@ void mv_eth_port_stats_print(unsigned int port)
 	struct port_stats *stat = NULL;
 	struct tx_queue *txq_ctrl;
 	struct txq_cpu_ctrl *txq_cpu_ptr;
-	int txp, queue, cpu;
+	int txp, queue, cpu = smp_processor_id();
 	u32 total_rx_ok, total_rx_fill_ok;
-#ifdef CONFIG_MV_ETH_STAT_INF
-	int i;
-#endif
 
+	pr_info("\n====================================================\n");
+	pr_info("ethPort_%d: Statistics (running on cpu#%d)", port, cpu);
+	pr_info("----------------------------------------------------\n\n");
 
 	if (pp == NULL) {
 		printk(KERN_ERR "eth_stats_print: wrong port number %d\n", port);
@@ -4885,36 +4859,43 @@ void mv_eth_port_stats_print(unsigned int port)
 	stat = &(pp->stats);
 
 #ifdef CONFIG_MV_ETH_STAT_ERR
-	printk(KERN_ERR "\n====================================================\n");
-	printk(KERN_ERR "ethPort_%d: Errors", port);
-	printk(KERN_CONT "\n-------------------------------\n");
+	printk(KERN_ERR "Errors:\n");
 	printk(KERN_ERR "rx_error......................%10u\n", stat->rx_error);
 	printk(KERN_ERR "tx_timeout....................%10u\n", stat->tx_timeout);
-	printk(KERN_ERR "tx_netif_stop.................%10u\n", stat->netif_stop);
-	printk(KERN_ERR "netif_wake....................%10u\n", stat->netif_wake);
 	printk(KERN_ERR "ext_stack_empty...............%10u\n", stat->ext_stack_empty);
 	printk(KERN_ERR "ext_stack_full ...............%10u\n", stat->ext_stack_full);
 	printk(KERN_ERR "state_err.....................%10u\n", stat->state_err);
 #endif /* CONFIG_MV_ETH_STAT_ERR */
 
 #ifdef CONFIG_MV_ETH_STAT_INF
-	printk(KERN_ERR "\n====================================================\n");
-	printk(KERN_ERR "ethPort_%d: interrupt statistics", port);
-	printk(KERN_CONT "\n-------------------------------\n");
-	printk(KERN_ERR "irq...........................%10u\n", stat->irq);
-	printk(KERN_ERR "irq_err.......................%10u\n", stat->irq_err);
-
-	printk(KERN_ERR "\n====================================================\n");
-	printk(KERN_ERR "ethPort_%d: Events", port);
-	printk(KERN_CONT "\n-------------------------------\n");
-	for (i = 0; i < CONFIG_NR_CPUS; i++) {
-		printk(KERN_ERR "poll[%d]......................%10u\n", i, stat->poll[i]);
-		printk(KERN_ERR "poll_exit[%d].................%10u\n", i, stat->poll_exit[i]);
-	}
-	printk(KERN_ERR "tx_fragmentation..............%10u\n", stat->tx_fragment);
+	pr_info("\nEvents:\n");
+
+	pr_info("irq[cpu]            = ");
+	for_each_possible_cpu(cpu)
+		printk(KERN_CONT "%8d ", stat->irq[cpu]);
+
+	pr_info("irq_none[cpu]       = ");
+	for_each_possible_cpu(cpu)
+		printk(KERN_CONT "%8d ", stat->irq_err[cpu]);
+
+	pr_info("poll[cpu]           = ");
+	for_each_possible_cpu(cpu)
+		printk(KERN_CONT "%8d ", stat->poll[cpu]);
+
+	pr_info("poll_exit[cpu]      = ");
+	for_each_possible_cpu(cpu)
+		printk(KERN_CONT "%8d ", stat->poll_exit[cpu]);
+
+	pr_info("tx_timer_event[cpu] = ");
+	for_each_possible_cpu(cpu)
+		printk(KERN_CONT "%8d ", stat->tx_done_timer_event[cpu]);
+
+	pr_info("tx_timer_add[cpu]   = ");
+	for_each_possible_cpu(cpu)
+		printk(KERN_CONT "%8d ", stat->tx_done_timer_add[cpu]);
+
+	pr_info("\n");
 	printk(KERN_ERR "tx_done_event.................%10u\n", stat->tx_done);
-	printk(KERN_ERR "tx_done_timer_event...........%10u\n", stat->tx_done_timer);
-	printk(KERN_ERR "cleanup_timer_event...........%10u\n", stat->cleanup_timer);
 	printk(KERN_ERR "link..........................%10u\n", stat->link);
 	printk(KERN_ERR "netdev_stop...................%10u\n", stat->netdev_stop);
 	if (pp->tagged)
@@ -4978,7 +4959,7 @@ void mv_eth_port_stats_print(unsigned int port)
 #endif /* CONFIG_MV_ETH_STAT_DBG */
 
 	printk(KERN_ERR "\n");
-	printk(KERN_ERR "TXP-TXQ:  count        send          done      no_resource\n\n");
+	printk(KERN_ERR "TXP-TXQ-CPU:  count        send          done      no_resource\n\n");
 
 	for (txp = 0; txp < pp->txp_num; txp++) {
 		for (queue = 0; queue < CONFIG_MV_ETH_TXQ; queue++)
@@ -4995,7 +4976,7 @@ void mv_eth_port_stats_print(unsigned int port)
 				txq_err = txq_ctrl->stats.txq_err;
 #endif /* CONFIG_MV_ETH_STAT_ERR */
 
-				printk(KERN_ERR "%d-%d-cpu#%d:      %3d    %10u    %10u    %10u\n",
+				printk(KERN_ERR " %d - %d - %d:   %3d   %10u    %10u    %10u\n",
 				       txp, queue, cpu, txq_cpu_ptr->txq_count, txq_tx,
 				       txq_txdone, txq_err);
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
index 5a1ca0e..7497ab5 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
@@ -160,22 +160,19 @@ struct port_stats {
 #ifdef CONFIG_MV_ETH_STAT_ERR
 	u32 rx_error;
 	u32 tx_timeout;
-	u32 netif_stop;
 	u32 ext_stack_empty;
 	u32 ext_stack_full;
-	u32 netif_wake;
 	u32 state_err;
 #endif /* CONFIG_MV_ETH_STAT_ERR */
 
 #ifdef CONFIG_MV_ETH_STAT_INF
-	u32 irq;
-	u32 irq_err;
+	u32 irq[CONFIG_NR_CPUS];
+	u32 irq_err[CONFIG_NR_CPUS];
 	u32 poll[CONFIG_NR_CPUS];
 	u32 poll_exit[CONFIG_NR_CPUS];
-	u32 tx_fragment;
+	u32 tx_done_timer_event[CONFIG_NR_CPUS];
+	u32 tx_done_timer_add[CONFIG_NR_CPUS];
 	u32 tx_done;
-	u32 tx_done_timer;
-	u32 cleanup_timer;
 	u32 link;
 	u32 netdev_stop;
 	u32 rx_tagged;
@@ -250,10 +247,8 @@ struct port_stats {
 
 /* Masks used for cpu_ctrl->flags */
 #define MV_ETH_F_TX_DONE_TIMER_BIT  0
-#define MV_ETH_F_CLEANUP_TIMER_BIT  1
 
 #define MV_ETH_F_TX_DONE_TIMER		(1 << MV_ETH_F_TX_DONE_TIMER_BIT)	/* 0x01 */
-#define MV_ETH_F_CLEANUP_TIMER		(1 << MV_ETH_F_CLEANUP_TIMER_BIT)	/* 0x02 */
 
 
 #define MV_ETH_TXQ_INVALID	0xFF
@@ -332,11 +327,12 @@ struct napi_group_ctrl {
 };
 
 struct cpu_ctrl {
-	struct napi_group_ctrl	*napi_group;
-	int			txq;
-	struct timer_list	tx_done_timer;
-	struct timer_list	cleanup_timer;
-	unsigned long		flags;
+	struct eth_port        *pp;
+	struct napi_group_ctrl *napi_group;
+	int	                   txq;
+	int                    cpu;
+	struct timer_list      tx_done_timer;
+	unsigned long          flags;
 };
 
 struct eth_port {
@@ -637,20 +633,13 @@ static inline int mv_eth_extra_pool_put(struct eth_port *pp, void *ext_buf)
 	return 0;
 }
 
-static inline void mv_eth_add_cleanup_timer(struct cpu_ctrl *cpuCtrl)
-{
-	if (test_and_set_bit(MV_ETH_F_CLEANUP_TIMER_BIT, &(cpuCtrl->flags)) == 0) {
-		cpuCtrl->cleanup_timer.expires = jiffies + ((HZ * CONFIG_MV_ETH_CLEANUP_TIMER_PERIOD) / 1000); /* ms */
-		add_timer(&cpuCtrl->cleanup_timer);
-	}
-}
-
 static inline void mv_eth_add_tx_done_timer(struct cpu_ctrl *cpuCtrl)
 {
 	if (test_and_set_bit(MV_ETH_F_TX_DONE_TIMER_BIT, &(cpuCtrl->flags)) == 0) {
 
 		cpuCtrl->tx_done_timer.expires = jiffies + ((HZ * CONFIG_MV_ETH_TX_DONE_TIMER_PERIOD) / 1000); /* ms */
-		add_timer(&cpuCtrl->tx_done_timer);
+		STAT_INFO(cpuCtrl->pp->stats.tx_done_timer_add[smp_processor_id()]++);
+		add_timer_on(&cpuCtrl->tx_done_timer, smp_processor_id());
 	}
 }
 
-- 
1.7.5.4

