From 30014719b2dba5c77962608e1d0f0149df6b5ba9 Mon Sep 17 00:00:00 2001
From: Eli Nidam <elini@marvell.com>
Date: Wed, 13 Nov 2013 16:48:28 +0200
Subject: [PATCH 1133/1825] fix: nand: Fixed bring up a38x on board nand.

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 36307dd4530c75ff304e102fa7f510b409004422

        1. Fix initial CS0 for nand. and define CS0 for nand in boardEnvSpec
        2. Update MPP's for on board nand
        3. Fix a38x  Core Divider Clock Control register offset

Change-Id: Iab69c4fa369d2c5509ccf5da3deac369aaf93ad9
Signed-off-by: Eli Nidam <elini@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/4316
Reviewed-by: Nadav Haklai <nadavh@marvell.com>
Tested-by: Nadav Haklai <nadavh@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../armada_38x_family/boardEnv/mvBoardEnvLib.c     |   64 ++++++++++++-------
 .../armada_38x_family/boardEnv/mvBoardEnvLib.h     |    4 +-
 .../armada_38x_family/boardEnv/mvBoardEnvSpec.c    |   19 +++++-
 .../armada_38x_family/ctrlEnv/mvCtrlEnvLib.h       |    4 +-
 .../armada_38x_family/ctrlEnv/mvCtrlEnvRegs.h      |    2 +-
 5 files changed, 61 insertions(+), 32 deletions(-)

diff --git a/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.c b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.c
index 9a709c8..d2550a8 100644
--- a/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.c
+++ b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.c
@@ -120,29 +120,35 @@ MV_U32 boardOptionsConfig[MV_CONFIG_TYPE_MAX_OPTION];
 *******************************************************************************/
 MV_VOID mvBoardEnvInit(MV_VOID)
 {
-	MV_U32 nandDev;
-	MV_U32 norDev;
-	MV_U32 syncCtrl = 0;
+	MV_U32 nandDev	= 0xFFFFFFFF;
+	MV_U32 norDev	= 0xFFFFFFFF;
+	MV_U32 syncCtrl	= 0;
+	MV_BOARD_BOOT_SRC bootSrc;
+
+	memset(&boardOptionsConfig, 0x0, sizeof(MV_U32) * MV_CONFIG_TYPE_MAX_OPTION);
 
 	board = boardInfoTbl[DB_68XX_ID];	/* init for first time get the correct twsi address */
 	mvBoardIdSet(mvBoardIdGet());
-	nandDev = boardGetDevCSNum(0, BOARD_DEV_NAND_FLASH);
-	if (nandDev != 0xFFFFFFFF) {
-		/* Set NAND interface access parameters */
-		MV_REG_WRITE(DEV_BANK_PARAM_REG(nandDev), board->nandFlashReadParams);
-		MV_REG_WRITE(DEV_BANK_PARAM_REG_WR(nandDev), board->nandFlashWriteParams);
-		MV_REG_WRITE(DEV_NAND_CTRL_REG, board->nandFlashControl);
-		/* Set Ready Polarity to Active High */
-		syncCtrl |= SYNC_CTRL_READY_POL(nandDev);
-	}
-
-	norDev = boardGetDevCSNum(0, BOARD_DEV_NOR_FLASH);
-	if (norDev != 0xFFFFFFFF) {
-		/* Set NOR interface access parameters */
-		MV_REG_WRITE(DEV_BANK_PARAM_REG(norDev), board->norFlashReadParams);
-		MV_REG_WRITE(DEV_BANK_PARAM_REG_WR(norDev), board->norFlashWriteParams);
-		/* Ignore Ready signal */
-		syncCtrl |= SYNC_CTRL_READY_IGNORE(norDev);
+	bootSrc = mvBoardBootDeviceGroupSet();
+	if (MSAR_0_BOOT_NAND_NEW == bootSrc) {
+		nandDev = boardGetDevCSNum(0, BOARD_DEV_NAND_FLASH);
+		if (nandDev != 0xFFFFFFFF) {
+			/* Set NAND interface access parameters */
+			MV_REG_WRITE(DEV_BANK_PARAM_REG(nandDev), board->nandFlashReadParams);
+			MV_REG_WRITE(DEV_BANK_PARAM_REG_WR(nandDev), board->nandFlashWriteParams);
+			MV_REG_WRITE(DEV_NAND_CTRL_REG, board->nandFlashControl);
+			/* Set Ready Polarity to Active High */
+			syncCtrl |= SYNC_CTRL_READY_POL(nandDev);
+		}
+	} else if (MSAR_0_BOOT_NOR_FLASH == bootSrc) {
+		norDev = boardGetDevCSNum(0, BOARD_DEV_NOR_FLASH);
+		if (norDev != 0xFFFFFFFF) {
+			/* Set NOR interface access parameters */
+			MV_REG_WRITE(DEV_BANK_PARAM_REG(norDev), board->norFlashReadParams);
+			MV_REG_WRITE(DEV_BANK_PARAM_REG_WR(norDev), board->norFlashWriteParams);
+			/* Ignore Ready signal */
+			syncCtrl |= SYNC_CTRL_READY_IGNORE(norDev);
+		}
 	}
 
 	if (nandDev != 0xFFFFFFFF || norDev != 0xFFFFFFFF) {
@@ -812,11 +818,12 @@ MV_VOID mvBoardInfoUpdate(MV_VOID)
 	MV_U8 readValue;
 	MV_BOARD_CONFIG_TYPE_INFO configInfo;
 	int i;
+	MV_BOARD_BOOT_SRC bootSrc;
+
 
-	memset(&boardOptionsConfig, 0x0, sizeof(MV_U32) * MV_CONFIG_TYPE_MAX_OPTION);
 	/*Read all TWSI board module if exsist : */
 	/* Save values Locally in configVal[] */
-	for (i = 0; i < MV_CONFIG_TYPE_MAX_OPTION; i++) {
+	for (i = 0; i < MV_CONFIG_TYPE_MAX_MODULE; i++) {
 		if (mvBoardConfigTypeGet(i, &configInfo) == MV_TRUE) {
 			if (mvBoardTwsiGet(BOARD_TWSI_MODULE_DETECT, configInfo.twsiAddr,
 					   configInfo.offset, &readValue) != MV_OK) {
@@ -829,6 +836,9 @@ MV_VOID mvBoardInfoUpdate(MV_VOID)
 				boardOptionsConfig[configInfo.configId] = 1;
 		}
 	}
+	bootSrc = mvBoardBootDeviceGroupSet();
+	if (MSAR_0_BOOT_NAND_NEW == bootSrc)
+		boardOptionsConfig[MV_CONFIG_NAND_ON_BOARD] = 1;
 
 	/* Update MPP group types and values according to board configuration */
 	mvBoardMppIdUpdate();
@@ -911,6 +921,7 @@ MV_VOID mvBoardMppIdUpdate(MV_VOID)
 	struct _mvBoardMppModule tdmModule[2] = MPP_TDM_MODULE;
 	struct _mvBoardMppModule i2sModule = MPP_I2S_MODULE;
 	struct _mvBoardMppModule spdifModule = MPP_SPDIF_MODULE;
+	struct _mvBoardMppModule nandOnBoard[4] = MPP_NAND_ON_BOARD;
 
 	if (mvBoardIsModuleConnected(MV_CONFIG_MII))
 		mvModuleMppUpdate(3, miiModule);
@@ -932,6 +943,10 @@ MV_VOID mvBoardMppIdUpdate(MV_VOID)
 
 	if (mvBoardIsModuleConnected(MV_CONFIG_SPDIF_DEVICE))
 		mvModuleMppUpdate(1, &spdifModule);
+
+	if (mvBoardIsModuleConnected(MV_CONFIG_NAND_ON_BOARD))
+		mvModuleMppUpdate(4, nandOnBoard);
+
 }
 
 /*******************************************************************************
@@ -982,6 +997,7 @@ MV_BOARD_BOOT_SRC mvBoardBootDeviceGroupSet()
 	case MSAR_0_BOOT_NOR_FLASH:
 		break;
 	case MSAR_0_BOOT_NAND_NEW:
+		boardOptionsConfig[MV_CONFIG_NAND_ON_BOARD] = 1;
 		break;
 	case MSAR_0_BOOT_SPI_FLASH:
 		break;
@@ -1184,7 +1200,7 @@ MV_VOID mvBoardConfigWrite(void)
 MV_VOID mvBoardMppModuleTypePrint(MV_VOID)
 {
 	int i;
-	char *moduleStr[MV_CONFIG_TYPE_MAX_OPTION] = { \
+	char *moduleStr[MV_CONFIG_TYPE_MAX_MODULE] = { \
 		"SGMII",                                \
 		"MII",                                  \
 		"TDM",                                  \
@@ -1199,7 +1215,7 @@ MV_VOID mvBoardMppModuleTypePrint(MV_VOID)
 	};
 	mvOsOutput("Board configuration detected:\n");
 
-	for (i = 0; i < MV_CONFIG_TYPE_MAX_OPTION; i++) {
+	for (i = 0; i < MV_CONFIG_TYPE_MAX_MODULE; i++) {
 		if (mvBoardIsModuleConnected(i))
 			mvOsOutput("       %s module.\n", moduleStr[i]);
 
diff --git a/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.h b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.h
index 97d6dc0..dd3e491 100644
--- a/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.h
+++ b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.h
@@ -390,8 +390,8 @@ struct _mvBoardMppModule {
 				  {3, 0x55555055}, {4, 0x55555555}, {5, 0x40045525 } }
 #define MPP_NAND_MODULE		{ {0, 0x55111111}, {1, 0x15555555}, {2, 0x55266011}, \
 				  {3, 0x25255051}, {4, 0x25555555}, {5, 0x40042555 } }
-#define MPP_SDIO_MODULE		{ {2, 0x11466011}, {3, 0x22242011}, {4, 0x44400002}, \
-				  {5, 0x40042024 } }
+#define MPP_SDIO_MODULE		{ {2, 0x11466011}, {3, 0x22242011}, {4, 0x44400002}, {5, 0x40042024 } }
+#define MPP_NAND_ON_BOARD	{ {2, 0x55266011}, {3, 0x25252051}, {4, 0x25255555}, {5, 0x40042565 } }
 
 /* Boot device bus width */
 #define MSAR_0_BOOT_DEV_BUS_WIDTH_OFFS          3
diff --git a/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvSpec.c b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvSpec.c
index 43e9ac6..eba2068 100644
--- a/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvSpec.c
+++ b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvSpec.c
@@ -70,6 +70,14 @@
 /*******************************************************************************
  * A380 DB-88F6660 board */
 /*******************************************************************************/
+#define DB_88F68XX_BOARD_NAND_READ_PARAMS	0x000C0282
+#define DB_88F68XX_BOARD_NAND_WRITE_PARAMS	0x00010305
+/*NAND care support for small page chips*/
+#define DB_88F68XX_BOARD_NAND_CONTROL		0x01c00543
+
+#define DB_88F68XX_BOARD_NOR_READ_PARAMS	0x403E07CF
+#define DB_88F68XX_BOARD_NOR_WRITE_PARAMS	0x000F0F0F
+
 MV_BOARD_MPP_INFO db88f68xxInfoBoardMppConfigValue[] = {
 	{ {
 		  DB_88F68XX_MPP0_7,
@@ -106,7 +114,10 @@ MV_BOARD_MAC_INFO db88f68xxInfoBoardMacInfo[] = {
 MV_DEV_CS_INFO db88f68xxInfoBoardDeCsInfo[] = {
 	/*{deviceCS, params, devType, devWidth, busWidth }*/
 #if defined(MV_INCLUDE_SPI)
-	{ SPI_CS0, N_A, BOARD_DEV_SPI_FLASH, 8, 8 } /* SPI DEV */
+	{ SPI_CS0,	N_A, BOARD_DEV_SPI_FLASH,	8,	8 } /* SPI DEV */
+#endif
+#ifdef MV_NAND
+	{ DEVICE_CS0,	N_A, BOARD_DEV_NAND_FLASH,	8,	8},  /* NAND DEV */
 #endif
 };
 /*
@@ -165,9 +176,9 @@ MV_BOARD_INFO db88f68xx_board_info = {
 	.pBoardSpecInit			= NULL,
 
 	/* NAND init params */
-	.nandFlashReadParams		= 0,
-	.nandFlashWriteParams		= 0,
-	.nandFlashControl		= 0,
+	.nandFlashReadParams		= DB_88F68XX_BOARD_NAND_READ_PARAMS,
+	.nandFlashWriteParams		= DB_88F68XX_BOARD_NAND_WRITE_PARAMS,
+	.nandFlashControl		= DB_88F68XX_BOARD_NAND_CONTROL,
 	.pBoardTdmSpiInfo		= db88f68xxTdmSpiInfo,
 
 	/* NOR init params */
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.h b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.h
index ff7c49d..f18618b 100644
--- a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.h
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.h
@@ -86,7 +86,9 @@ typedef enum _mvConfigTypeID {
 	MV_CONFIG_SGMII,		/* SERDES module SGMII	*/
 	MV_CONFIG_SERDES_PEX_LAN1,	/* SERDES module PEX	*/
 	MV_CONFIG_SERDES_PEX_LAN2,	/* SERDES module PEX	*/
-	MV_CONFIG_TYPE_MAX_OPTION
+	MV_CONFIG_TYPE_MAX_MODULE,
+	MV_CONFIG_NAND_ON_BOARD = MV_CONFIG_TYPE_MAX_MODULE,	/* ON board nand detect */
+	MV_CONFIG_TYPE_MAX_OPTION,
 } MV_CONFIG_TYPE_ID;
 
 
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvRegs.h b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvRegs.h
index e7e5ce4..7e81244 100644
--- a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvRegs.h
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvRegs.h
@@ -144,7 +144,7 @@ extern "C" {
 #define SATR_CPU1_ENABLE_MASK		(1 << SATR_CPU1_ENABLE_OFFS)
 
 /* Core Divider Clock Control */
-#define CORE_DIV_CLK_CTRL(num)		(0xE8250 + ((num) * 0x4))
+#define CORE_DIV_CLK_CTRL(num)		(0xE4250 + ((num) * 0x4))
 
 #define CORE_DIVCLK_RELOAD_FORCE_OFFS		0
 #define CORE_DIVCLK_RELOAD_FORCE_MASK		(0xFF << CORE_DIVCLK_RELOAD_FORCE_OFFS)
-- 
1.7.5.4

