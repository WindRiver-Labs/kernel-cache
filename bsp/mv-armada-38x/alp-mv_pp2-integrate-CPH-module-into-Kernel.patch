From 039d2ad4ab685f77810a08e7174c523d485d4b3a Mon Sep 17 00:00:00 2001
From: Evan <xswang@marvell.com>
Date: Tue, 25 Mar 2014 15:17:13 +0800
Subject: [PATCH 1518/1825] alp: mv_pp2: integrate CPH module into Kernel

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 5b2f0e1a114d5f00264a8090062ad01c1eb3c04a

Signed-off-by: Evan <xswang@marvell.com>

Change-Id: I245317a1774410a3d46bc2dd21ae15a0c26dd5ff
Reviewed-on: http://vgitil04.il.marvell.com:8080/6646
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Tested-by: Yehuda Yitschak <yehuday@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig |   66 +
 .../arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile |   13 +
 .../mv_drivers_lsp/mv_pp2/cph/mv_cph_api.c         |  541 ++++
 .../mv_drivers_lsp/mv_pp2/cph/mv_cph_api.h         |  411 +++
 .../mv_drivers_lsp/mv_pp2/cph/mv_cph_app.c         | 1433 ++++++++++
 .../mv_drivers_lsp/mv_pp2/cph/mv_cph_app.h         |  766 +++++
 .../mv_drivers_lsp/mv_pp2/cph/mv_cph_db.c          | 1299 +++++++++
 .../mv_drivers_lsp/mv_pp2/cph/mv_cph_db.h          |  529 ++++
 .../mv_drivers_lsp/mv_pp2/cph/mv_cph_dev.c         |  446 +++
 .../mv_drivers_lsp/mv_pp2/cph/mv_cph_dev.h         |  151 +
 .../mv_drivers_lsp/mv_pp2/cph/mv_cph_flow.c        | 2911 ++++++++++++++++++++
 .../mv_drivers_lsp/mv_pp2/cph/mv_cph_flow.h        |  687 +++++
 .../mv_drivers_lsp/mv_pp2/cph/mv_cph_header.h      |   97 +
 .../mv_drivers_lsp/mv_pp2/cph/mv_cph_infra.c       |  238 ++
 .../mv_drivers_lsp/mv_pp2/cph/mv_cph_infra.h       |  500 ++++
 .../mv_drivers_lsp/mv_pp2/cph/mv_cph_mng_if.h      |  162 ++
 .../mv_drivers_lsp/mv_pp2/cph/mv_cph_mod.c         |  142 +
 .../mv_drivers_lsp/mv_pp2/cph/mv_cph_netdev.c      |  861 ++++++
 .../mv_drivers_lsp/mv_pp2/cph/mv_cph_netdev.h      |  160 ++
 .../mv_drivers_lsp/mv_pp2/cph/mv_cph_sysfs.c       | 1114 ++++++++
 .../mv_drivers_lsp/mv_pp2/cph/mv_cph_sysfs.h       |  131 +
 21 files changed, 12658 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_api.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_api.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_app.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_app.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_db.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_db.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_dev.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_dev.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_flow.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_flow.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_header.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_infra.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_infra.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_mng_if.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_mod.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_netdev.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_netdev.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_sysfs.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_sysfs.h

diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig
index 6a491f2..4588382 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig
@@ -347,3 +347,69 @@ config MV_ETH_SWF_HWF_CORRUPTION_WA
 	when HWF and SWF traffic use buffers from the same BM pools.
 
 endmenu
+
+menu "SoC CPH support"
+
+config  MV_CPH
+        bool "Support for Marvell CPU Packet Handler Driver"
+        depends on MV_ETH_TX_SPECIAL
+        default n
+        ---help---
+        CPH is designed mainly for PON product (GPON/EPON),
+        which basically has two features:
+        1. Set special skb->protocol value based on user configure rules.
+        2. Forward SWF packets to special TCONT and GEM port (GPON), LLID (EPON).
+
+comment "CPH Driver Options"
+
+config  MV_CPH_IGMP_HANDLE
+        bool "Enable MV_CPH IGMP handling"
+	depends on MV_CPH
+        default n
+        ---help---
+        Enable CPH to handle IGMP as protocol packet,
+        and setspecial skb->protocol value based on
+        user configure rules. So it could be trapped
+        by RAW SOCKET.
+
+config  MV_CPH_MLD_HANDLE
+        bool "Enable MV_CPH MLD handling"
+	depends on MV_CPH
+        default n
+        ---help---
+        Enable CPH to handle MLD as protocol packet,
+        and set special skb->protocol value based
+        on user configure rules. So it could be
+        trapped by RAW SOCKET.
+
+config  MV_CPH_BC_HANDLE
+        bool "Enable MV_CPH broadcast handling"
+	depends on MV_CPH
+        default n
+        ---help---
+        Enable CPH to handle Broadcast as protocol
+        packet, and set special skb->protocol value
+        based on user configure rules.So it could be
+        trapped by RAW SOCKETl
+
+config  MV_CPH_UDP_SAMPLE_HANDLE
+        bool "Enable MV_CPH sample UDP handling"
+	depends on MV_CPH
+        default n
+        ---help---
+        Enable CPH to handle sample UDP as protocol
+        packet, and set special skb->protocol value
+        based on user configure rules. So it could be
+        trapped by RAW SOCKET.
+
+config  MV_CPH_FLOW_MAP_HANDLE
+        bool "Enable MV_CPH flow mapping handling"
+	depends on MV_CPH
+        default n
+        ---help---
+        Enable CPH to handle flow mapping, and forward
+        upstream SWF packets to special TCONT and
+        GEM port (GPON), LLID (EPON) based on user
+        configure rules.
+
+endmenu
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile
index c3d4907..2ed700d 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Makefile
@@ -18,6 +18,7 @@ PP2_PLCR_DIR  = $(PP2_HAL_DIR)/plcr
 PP2_WOL_DIR   = $(PP2_HAL_DIR)/wol
 PP2_DPI_DIR   = $(PP2_HAL_DIR)/dpi
 PP2_COMMON_DIR= $(PP2_HAL_DIR)/common
+PP2_CPH_DIR   = $(PP2_HAL_DIR)/cph
 
 mv_pp2-objs +=	$(PP2_GMAC_DIR)/mvEthGmacApi.o
 mv_pp2-objs +=	$(PP2_GBE_DIR)/mvPp2Gbe.o $(PP2_GBE_DIR)/mvPp2GbeDebug.o
@@ -54,6 +55,18 @@ ifeq ($(CONFIG_MV_ETH_L2FW),y)
 mv_pp2-objs += l2fw/l2fw_sysfs.o l2fw/mv_eth_l2fw.o
 endif
 
+ifeq ($(CONFIG_MV_CPH),y)
+mv_pp2-objs += cph/mv_cph_api.o
+mv_pp2-objs += cph/mv_cph_app.o
+mv_pp2-objs += cph/mv_cph_db.o
+mv_pp2-objs += cph/mv_cph_dev.o
+mv_pp2-objs += cph/mv_cph_flow.o
+mv_pp2-objs += cph/mv_cph_infra.o
+mv_pp2-objs += cph/mv_cph_mod.o
+mv_pp2-objs += cph/mv_cph_netdev.o
+mv_pp2-objs += cph/mv_cph_sysfs.o
+endif
+
 ifeq ($(CONFIG_ARCH_MVEBU),y)
 
 ccflags-y       += $(MVEBU_NET_FLAGS)
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_api.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_api.c
new file mode 100644
index 0000000..7082778
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_api.c
@@ -0,0 +1,541 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+	*   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+	*   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+	*   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+********************************************************************************
+* mv_cph_api.c
+*
+* DESCRIPTION: Marvell CPH(CPH Packet Handler) API definition
+*
+* DEPENDENCIES:
+*               None
+*
+* CREATED BY:   VictorGu
+*
+* DATE CREATED: 22Jan2013
+*
+* FILE REVISION NUMBER:
+*               Revision: 1.0
+*
+*
+*******************************************************************************/
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/mutex.h>
+#include <linux/spinlock.h>
+#include <linux/poll.h>
+#include <linux/clk.h>
+#include <linux/fs.h>
+#include <linux/vmalloc.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+
+#include "mv_cph_header.h"
+
+
+/******************************************************************************
+* Variable Definition
+******************************************************************************/
+
+
+/******************************************************************************
+* Function Definition
+******************************************************************************/
+/******************************************************************************
+* cph_set_complex_profile()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Set TPM complex profile ID
+*
+* INPUTS:
+*       profile_id   - TPM complex profile ID
+*       active_port  - Active WAN port
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_set_complex_profile(enum tpm_eth_complex_profile_t profile_id, enum MV_APP_GMAC_PORT_E active_port)
+{
+	MV_STATUS rc = MV_OK;
+
+	rc = cph_app_set_complex_profile(profile_id, active_port);
+	CHECK_API_RETURN_AND_LOG_ERROR(rc, "Fail to call cph_app_set_complex_profile");
+
+	return rc;
+}
+EXPORT_SYMBOL(cph_set_complex_profile);
+
+/******************************************************************************
+* cph_set_feature_flag()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Enable or disable feature support in CPH
+*
+* INPUTS:
+*       feature - CPH supported features
+*       state   - Enable or disable this feature in CPH
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_set_feature_flag(enum CPH_APP_FEATURE_E feature, bool state)
+{
+	MV_STATUS rc = MV_OK;
+
+	rc = cph_app_set_feature_flag(feature, state);
+	CHECK_API_RETURN_AND_LOG_ERROR(rc, "fail to call cph_app_set_feature_flag");
+
+	return rc;
+}
+EXPORT_SYMBOL(cph_set_feature_flag);
+
+/******************************************************************************
+* cph_add_app_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Add CPH rule
+*
+* INPUTS:
+*       parse_bm   - Parsing bitmap
+*       parse_key  - Parsing key
+*       mod_bm     - Modification bitmap
+*       mod_value  - Modification value
+*       frwd_bm    - Forwarding bitmap
+*       frwd_value - Forwarding value
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_add_app_rule(
+	enum CPH_APP_PARSE_FIELD_E parse_bm,
+	struct CPH_APP_PARSE_T      *parse_key,
+	enum CPH_APP_MOD_FIELD_E   mod_bm,
+	struct CPH_APP_MOD_T        *mod_value,
+	enum CPH_APP_FRWD_FIELD_E  frwd_bm,
+	struct CPH_APP_FRWD_T       *frwd_value)
+{
+	MV_STATUS rc = MV_OK;
+
+	rc = cph_app_add_rule(parse_bm, parse_key, mod_bm, mod_value, frwd_bm, frwd_value);
+	CHECK_API_RETURN_AND_LOG_ERROR(rc, "Fail to call cph_app_add_rule");
+
+	return rc;
+}
+EXPORT_SYMBOL(cph_add_app_rule);
+
+/******************************************************************************
+* cph_del_app_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Delete CPH rule
+*
+* INPUTS:
+*       parse_bm   - Parsing bitmap
+*       parse_key  - Parsing key
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_del_app_rule(
+	enum CPH_APP_PARSE_FIELD_E parse_bm,
+	struct CPH_APP_PARSE_T      *parse_key)
+{
+	MV_STATUS rc = MV_OK;
+
+	rc = cph_app_del_rule(parse_bm, parse_key);
+	CHECK_API_RETURN_AND_LOG_ERROR(rc, "Fail to call cph_app_del_rule");
+
+	return rc;
+}
+EXPORT_SYMBOL(cph_del_app_rule);
+
+/******************************************************************************
+* cph_update_app_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Update CPH rule
+*
+* INPUTS:
+*       parse_bm   - Parsing bitmap
+*       parse_key  - Parsing key
+*       mod_bm     - Modification bitmap
+*       mod_value  - Modification value
+*       frwd_bm    - Forwarding bitmap
+*       frwd_value - Forwarding value
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_update_app_rule(
+	enum CPH_APP_PARSE_FIELD_E parse_bm,
+	struct CPH_APP_PARSE_T      *parse_key,
+	enum CPH_APP_MOD_FIELD_E   mod_bm,
+	struct CPH_APP_MOD_T        *mod_value,
+	enum CPH_APP_FRWD_FIELD_E  frwd_bm,
+	struct CPH_APP_FRWD_T       *frwd_value)
+{
+	MV_STATUS rc = MV_OK;
+
+	rc = cph_app_update_rule(parse_bm, parse_key, mod_bm, mod_value, frwd_bm, frwd_value);
+	CHECK_API_RETURN_AND_LOG_ERROR(rc, "Fail to call cph_app_update_rule");
+
+	return rc;
+}
+EXPORT_SYMBOL(cph_update_app_rule);
+
+/******************************************************************************
+* cph_get_app_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Get CPH rule
+*
+* INPUTS:
+*       parse_bm   - Parsing bitmap
+*       parse_key  - Parsing key
+*
+* OUTPUTS:
+*       mod_bm     - Modification bitmap
+*       mod_value  - Modification value
+*       frwd_bm    - Forwarding bitmap
+*       frwd_value - Forwarding value
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_get_app_rule(
+	enum CPH_APP_PARSE_FIELD_E parse_bm,
+	struct CPH_APP_PARSE_T      *parse_key,
+	enum CPH_APP_MOD_FIELD_E  *mod_bm,
+	struct CPH_APP_MOD_T        *mod_value,
+	enum CPH_APP_FRWD_FIELD_E *frwd_bm,
+	struct CPH_APP_FRWD_T       *frwd_value)
+{
+	MV_STATUS rc = MV_OK;
+
+	rc = cph_app_get_rule(parse_bm, parse_key, mod_bm, mod_value, frwd_bm, frwd_value);
+	if (rc != MV_OK)
+		MV_CPH_PRINT(CPH_DEBUG_LEVEL, "fail to call cph_app_get_rule\n");
+
+	return rc;
+}
+EXPORT_SYMBOL(cph_get_app_rule);
+
+/******************************************************************************
+* cph_add_flow_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Sets flow mapping rule
+*
+* INPUTS:
+*       cph_flow - VLAN ID, 802.1p value, pkt_fwd information.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int cph_add_flow_rule(struct CPH_FLOW_ENTRY_T *cph_flow)
+{
+	MV_STATUS rc = MV_OK;
+
+	rc = cph_flow_add_rule(cph_flow);
+	CHECK_API_RETURN_AND_LOG_ERROR(rc, "Fail to call cph_flow_add_rule");
+
+	return rc;
+}
+EXPORT_SYMBOL(cph_add_flow_rule);
+
+/******************************************************************************
+* cph_del_flow_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Deletes flow mapping rule
+*
+* INPUTS:
+*       cph_flow - VLAN ID, 802.1p value, pkt_fwd information.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int cph_del_flow_rule(struct CPH_FLOW_ENTRY_T *cph_flow)
+{
+	MV_STATUS rc = MV_OK;
+
+	rc = cph_flow_del_rule(cph_flow);
+	CHECK_API_RETURN_AND_LOG_ERROR(rc, "Fail to call cph_flow_del_rule");
+
+	return rc;
+}
+EXPORT_SYMBOL(cph_del_flow_rule);
+
+/******************************************************************************
+* cph_get_flow_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Gets flow mapping rule for tagged frames.
+*
+* INPUTS:
+*       cph_flow - Input vid, pbits, dir
+*
+* OUTPUTS:
+*       cph_flow - output packet forwarding information, including GEM port,
+*                   T-CONT, queue and packet modification for VID, P-bits.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int cph_get_flow_rule(struct CPH_FLOW_ENTRY_T *cph_flow)
+{
+	MV_STATUS rc = MV_OK;
+
+	rc = cph_flow_get_rule(cph_flow);
+	if (rc != MV_OK)
+		MV_CPH_PRINT(CPH_DEBUG_LEVEL, "fail to call cph_flow_get_rule\n");
+
+	return rc;
+}
+EXPORT_SYMBOL(cph_get_flow_rule);
+
+/******************************************************************************
+* cph_clear_flow_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Clears all flow mapping rules
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int cph_clear_flow_rule(void)
+{
+	MV_STATUS rc = MV_OK;
+
+	rc = cph_flow_clear_rule();
+	CHECK_API_RETURN_AND_LOG_ERROR(rc, "Fail to call cph_flow_clear_rule");
+
+	return rc;
+}
+EXPORT_SYMBOL(cph_clear_flow_rule);
+
+/******************************************************************************
+* cph_clear_flow_rule_by_mh()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Clears flow mapping rules by MH
+*
+* INPUTS:
+*       mh   -  Marvell header.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int cph_clear_flow_rule_by_mh(unsigned short mh)
+{
+	MV_STATUS rc = MV_OK;
+
+	rc = cph_flow_clear_rule_by_mh(mh);
+	CHECK_API_RETURN_AND_LOG_ERROR(rc, "Fail to call cph_flow_clear_rule_by_mh");
+
+	return rc;
+}
+
+/******************************************************************************
+* cph_set_flow_dscp_map()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Sets DSCP to P-bits mapping rules
+*
+* INPUTS:
+*       dscp_map  - DSCP to P-bits mapping rules.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int cph_set_flow_dscp_map(struct CPH_DSCP_PBITS_T *dscp_map)
+{
+	MV_STATUS rc = MV_OK;
+
+	rc = cph_flow_set_dscp_map(dscp_map);
+	CHECK_API_RETURN_AND_LOG_ERROR(rc, "Fail to call cph_flow_set_dscp_map");
+
+	return rc;
+}
+EXPORT_SYMBOL(cph_set_flow_dscp_map);
+
+/******************************************************************************
+* cph_del_flow_dscp_map()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Deletes DSCP to P-bits mapping rules
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int cph_del_flow_dscp_map(void)
+{
+	MV_STATUS rc = MV_OK;
+
+	rc = cph_flow_del_dscp_map();
+	CHECK_API_RETURN_AND_LOG_ERROR(rc, "Fail to call cph_flow_del_dscp_map");
+
+	return rc;
+}
+EXPORT_SYMBOL(cph_del_flow_dscp_map);
+
+/*******************************************************************************
+**
+** cph_get_tcont_state
+** ___________________________________________________________________________
+**
+** DESCRIPTION: The function get T-CONT state
+**
+** INPUTS:
+**   tcont - T-CONT
+**
+** OUTPUTS:
+**   None.
+**
+** RETURNS:
+**   state - State of T-CONT, enabled or disabled.
+**
+*******************************************************************************/
+bool cph_get_tcont_state(unsigned int tcont)
+{
+	return cph_db_get_tcont_state(tcont);
+}
+EXPORT_SYMBOL(cph_get_tcont_state);
+
+/*******************************************************************************
+**
+** cph_set_tcont_state
+** ___________________________________________________________________________
+**
+** DESCRIPTION: The function sets T-CONT state in mv_cust
+**
+** INPUTS:
+**   tcont - T-CONT
+**   state - State of T-CONT, enabled or disabled.
+**
+** OUTPUTS:
+**   None.
+**
+** RETURNS:
+**  On success, the function returns (MV_OK). On error different types are
+**  returned according to the case.
+**
+*******************************************************************************/
+int cph_set_tcont_state(unsigned int tcont, bool state)
+{
+	return cph_db_set_tcont_state(tcont, state);
+}
+EXPORT_SYMBOL(cph_set_tcont_state);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_api.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_api.h
new file mode 100644
index 0000000..27041cf
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_api.h
@@ -0,0 +1,411 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+	*   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+	*   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+	*   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+********************************************************************************
+* mv_cph_api.h
+*
+* DESCRIPTION: Marvell CPH(CPH Packet Handler) API definition
+*
+* DEPENDENCIES:
+*               None
+*
+* CREATED BY:   VictorGu
+*
+* DATE CREATED: 22Jan2013
+*
+* FILE REVISION NUMBER:
+*               Revision: 1.0
+*
+*
+*******************************************************************************/
+#ifndef _MV_CPH_API_H_
+#define _MV_CPH_API_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/******************************************************************************
+* Type Definition
+******************************************************************************/
+
+
+
+/******************************************************************************
+* Function Declaration
+******************************************************************************/
+/******************************************************************************
+* cph_set_complex_profile()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Set TPM complex profile ID
+*
+* INPUTS:
+*       profile_id   - TPM complex profile ID
+*       active_port  - Active WAN port
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_set_complex_profile(enum tpm_eth_complex_profile_t profile_id, enum MV_APP_GMAC_PORT_E active_port);
+
+/******************************************************************************
+* cph_set_feature_flag()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Enable or disable feature support in CPH
+*
+* INPUTS:
+*       feature - CPH supported features
+*       state   - Enable or disable this feature in CPH
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_set_feature_flag(enum CPH_APP_FEATURE_E feature, bool state);
+
+/******************************************************************************
+* cph_add_app_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Add CPH rule
+*
+* INPUTS:
+*       parse_bm   - Parsing bitmap
+*       parse_key  - Parsing key
+*       mod_bm     - Modification bitmap
+*       mod_value  - Modification value
+*       frwd_bm    - Forwarding bitmap
+*       frwd_value - Forwarding value
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_add_app_rule(
+	enum CPH_APP_PARSE_FIELD_E parse_bm,
+	struct CPH_APP_PARSE_T      *parse_key,
+	enum CPH_APP_MOD_FIELD_E   mod_bm,
+	struct CPH_APP_MOD_T        *mod_value,
+	enum CPH_APP_FRWD_FIELD_E  frwd_bm,
+	struct CPH_APP_FRWD_T       *frwd_value);
+
+/******************************************************************************
+* cph_del_app_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Delete CPH rule
+*
+* INPUTS:
+*       parse_bm   - Parsing bitmap
+*       parse_key  - Parsing key
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_del_app_rule(
+	enum CPH_APP_PARSE_FIELD_E parse_bm,
+	struct CPH_APP_PARSE_T      *parse_key);
+
+/******************************************************************************
+* cph_update_app_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Update CPH rule
+*
+* INPUTS:
+*       parse_bm   - Parsing bitmap
+*       parse_key  - Parsing key
+*       mod_bm     - Modification bitmap
+*       mod_value  - Modification value
+*       frwd_bm    - Forwarding bitmap
+*       frwd_value - Forwarding value
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_update_app_rule(
+	enum CPH_APP_PARSE_FIELD_E parse_bm,
+	struct CPH_APP_PARSE_T      *parse_key,
+	enum CPH_APP_MOD_FIELD_E   mod_bm,
+	struct CPH_APP_MOD_T        *mod_value,
+	enum CPH_APP_FRWD_FIELD_E  frwd_bm,
+	struct CPH_APP_FRWD_T       *frwd_value);
+
+/******************************************************************************
+* cph_get_app_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Get CPH rule
+*
+* INPUTS:
+*       parse_bm   - Parsing bitmap
+*       parse_key  - Parsing key
+*
+* OUTPUTS:
+*       mod_bm     - Modification bitmap
+*       mod_value  - Modification value
+*       frwd_bm    - Forwarding bitmap
+*       frwd_value - Forwarding value
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_get_app_rule(
+	enum CPH_APP_PARSE_FIELD_E parse_bm,
+	struct CPH_APP_PARSE_T      *parse_key,
+	enum CPH_APP_MOD_FIELD_E  *mod_bm,
+	struct CPH_APP_MOD_T        *mod_value,
+	enum CPH_APP_FRWD_FIELD_E *frwd_bm,
+	struct CPH_APP_FRWD_T       *frwd_value);
+
+/******************************************************************************
+* cph_add_flow_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Sets flow mapping rule
+*
+* INPUTS:
+*       cph_flow - VLAN ID, 802.1p value, pkt_fwd information.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int cph_add_flow_rule(struct CPH_FLOW_ENTRY_T *cph_flow);
+
+/******************************************************************************
+* cph_del_flow_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Deletes flow mapping rule
+*
+* INPUTS:
+*       cph_flow - VLAN ID, 802.1p value, pkt_fwd information.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int cph_del_flow_rule(struct CPH_FLOW_ENTRY_T *cph_flow);
+
+/******************************************************************************
+* cph_get_flow_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Gets flow mapping rule for tagged frames.
+*
+* INPUTS:
+*       cph_flow - Input vid, pbits, dir
+*
+* OUTPUTS:
+*       cph_flow - output packet forwarding information, including GEM port,
+*                   T-CONT, queue and packet modification for VID, P-bits.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int cph_get_flow_rule(struct CPH_FLOW_ENTRY_T *cph_flow);
+
+/******************************************************************************
+* cph_clear_flow_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Clears all flow mapping rules
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int cph_clear_flow_rule(void);
+
+/******************************************************************************
+* cph_clear_flow_rule_by_mh()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Clears flow mapping rules by MH
+*
+* INPUTS:
+*       mh   -  Marvell header.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int cph_clear_flow_rule_by_mh(unsigned short mh);
+
+/******************************************************************************
+* cph_set_flow_dscp_map()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Sets DSCP to P-bits mapping rules
+*
+* INPUTS:
+*       dscp_map  - DSCP to P-bits mapping rules.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int cph_set_flow_dscp_map(struct CPH_DSCP_PBITS_T *dscp_map);
+
+/******************************************************************************
+* cph_del_flow_dscp_map()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Deletes DSCP to P-bits mapping rules
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int cph_del_flow_dscp_map(void);
+
+/*******************************************************************************
+**
+** cph_get_tcont_state
+** ___________________________________________________________________________
+**
+** DESCRIPTION: The function get T-CONT state
+**
+** INPUTS:
+**   tcont - T-CONT
+**
+** OUTPUTS:
+**   None.
+**
+** RETURNS:
+**   state - State of T-CONT, enabled or disabled.
+**
+*******************************************************************************/
+bool cph_get_tcont_state(unsigned int tcont);
+
+/*******************************************************************************
+**
+** cph_set_tcont_state
+** ___________________________________________________________________________
+**
+** DESCRIPTION: The function sets T-CONT state in mv_cust
+**
+** INPUTS:
+**   tcont - T-CONT
+**   state - State of T-CONT, enabled or disabled.
+**
+** OUTPUTS:
+**   None.
+**
+** RETURNS:
+**  On success, the function returns (MV_OK). On error different types are
+**  returned according to the case.
+**
+*******************************************************************************/
+int cph_set_tcont_state(unsigned int tcont, bool state);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _MV_CPH_API_H_ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_app.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_app.c
new file mode 100644
index 0000000..b8860a0
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_app.c
@@ -0,0 +1,1433 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+	*   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+	*   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+	*   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+********************************************************************************
+* mv_cph_app.c
+*
+* DESCRIPTION: Marvell CPH(CPH Packet Handler) application module to implement
+*              CPH main logic and handle application packets such as OMCI, eOAM,
+*              IGMP packets.
+*
+* DEPENDENCIES:
+*               None
+*
+* CREATED BY:   VictorGu
+*
+* DATE CREATED: 22Jan2013
+*
+* FILE REVISION NUMBER:
+*               Revision: 1.0
+*
+*
+*******************************************************************************/
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/mutex.h>
+#include <linux/spinlock.h>
+#include <linux/poll.h>
+#include <linux/clk.h>
+#include <linux/fs.h>
+#include <linux/vmalloc.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/if_vlan.h>
+#include <net/ip.h>
+#include <net/ipv6.h>
+
+#include "mv_cph_header.h"
+
+
+/******************************************************************************
+* Variable Definition
+******************************************************************************/
+/* CPH global trace flag */
+unsigned int g_cph_global_trace = CPH_ERR_LEVEL|CPH_WARN_LEVEL|CPH_INFO_LEVEL;
+
+struct MV_ENUM_ENTRY_T g_enum_map_profile_id[] = {
+	{ TPM_PON_WAN_DUAL_MAC_INT_SWITCH,  "TPM_PON_WAN_DUAL_MAC_INT_SWITCH"},
+	{ TPM_PON_WAN_G0_INT_SWITCH,        "TPM_PON_WAN_G0_INT_SWITCH"},
+	{ TPM_PON_WAN_G1_LAN_G0_INT_SWITCH, "TPM_PON_WAN_G1_LAN_G0_INT_SWITCH"},
+	{ TPM_G0_WAN_G1_INT_SWITCH,         "TPM_G0_WAN_G1_INT_SWITCH"},
+	{ TPM_G1_WAN_G0_INT_SWITCH,         "TPM_G1_WAN_G0_INT_SWITCH"},
+	{ TPM_PON_G1_WAN_G0_INT_SWITCH,     "TPM_PON_G1_WAN_G0_INT_SWITCH"},
+	{ TPM_PON_G0_WAN_G1_INT_SWITCH,     "TPM_PON_G0_WAN_G1_INT_SWITCH"},
+	{ TPM_PON_WAN_DUAL_MAC_EXT_SWITCH,  "TPM_PON_WAN_DUAL_MAC_EXT_SWITCH"},
+	{ TPM_PON_WAN_G1_MNG_EXT_SWITCH,    "TPM_PON_WAN_G1_MNG_EXT_SWITCH"},
+	{ TPM_PON_WAN_G0_SINGLE_PORT,       "TPM_PON_WAN_G0_SINGLE_PORT"},
+	{ TPM_PON_WAN_G1_SINGLE_PORT,       "TPM_PON_WAN_G1_SINGLE_PORT"},
+	{ TPM_PON_G1_WAN_G0_SINGLE_PORT,    "TPM_PON_G1_WAN_G0_SINGLE_PORT"},
+	{ TPM_PON_G0_WAN_G1_SINGLE_PORT,    "TPM_PON_G0_WAN_G1_SINGLE_PORTg"},
+	{ TPM_PON_WAN_G0_G1_LPBK,           "TPM_PON_WAN_G0_G1_LPBK"},
+	{ TPM_PON_WAN_G0_G1_DUAL_LAN,       "TPM_PON_WAN_G0_G1_DUAL_LAN"},
+};
+
+static struct MV_ENUM_ARRAY_T g_enum_array_profile_id = {
+	sizeof(g_enum_map_profile_id)/sizeof(g_enum_map_profile_id[0]),
+	g_enum_map_profile_id
+};
+
+static struct MV_ENUM_ENTRY_T g_enum_map_pon_type[] = {
+	{ CPH_PON_TYPE_EPON, "EPON"},
+	{ CPH_PON_TYPE_GPON, "GPON"},
+	{ CPH_PON_TYPE_GBE,  "GBE"},
+	{ CPH_PON_TYPE_P2P,  "P2P"},
+};
+
+static struct MV_ENUM_ARRAY_T g_enum_array_pon_type = {
+	sizeof(g_enum_map_pon_type)/sizeof(g_enum_map_pon_type[0]),
+	g_enum_map_pon_type
+};
+
+static struct MV_ENUM_ENTRY_T g_enum_map_dir[] = {
+	{ CPH_DIR_US,       "US"},
+	{ CPH_DIR_DS,       "DS"},
+	{ CPH_DIR_NOT_CARE, "Not Care"},
+};
+
+static struct MV_ENUM_ARRAY_T g_enum_array_dir = {
+	sizeof(g_enum_map_dir)/sizeof(g_enum_map_dir[0]),
+	g_enum_map_dir
+};
+
+static struct MV_ENUM_ENTRY_T g_enum_map_rx_tx[] = {
+	{ CPH_DIR_RX,         "RX"},
+	{ CPH_DIR_TX,         "TX"},
+	{ CPH_RX_TX_NOT_CARE, "Not Care"},
+};
+
+static struct MV_ENUM_ARRAY_T g_enum_array_rx_tx = {
+	sizeof(g_enum_map_rx_tx)/sizeof(g_enum_map_rx_tx[0]),
+	g_enum_map_rx_tx
+};
+
+static struct MV_ENUM_ENTRY_T g_enum_map_gmac[] = {
+	{ MV_APP_GMAC_PORT_0,  "GMAC0"},
+	{ MV_APP_GMAC_PORT_1,  "GMAC1"},
+	{ MV_APP_PON_MAC_PORT, "PON MAC"},
+};
+
+static struct MV_ENUM_ARRAY_T g_enum_array_gmac = {
+	sizeof(g_enum_map_gmac)/sizeof(g_enum_map_gmac[0]),
+	g_enum_map_gmac
+};
+
+
+/******************************************************************************
+* External Declaration
+******************************************************************************/
+
+/******************************************************************************
+* Function Definition
+******************************************************************************/
+/******************************************************************************
+* cph_app_set_complex_profile()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Set TPM complex profile ID
+*
+* INPUTS:
+*       profile_id   - TPM complex profile ID
+*       active_port  - Active WAN port
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_app_set_complex_profile(enum tpm_eth_complex_profile_t profile_id, enum MV_APP_GMAC_PORT_E active_port)
+{
+	MV_STATUS rc = MV_OK;
+
+	/* Check the range of profile_id */
+	if (profile_id > TPM_PON_WAN_G0_G1_DUAL_LAN) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "profile_id[%d] is out of range[1~%d]\n",
+			profile_id, TPM_PON_WAN_G0_G1_DUAL_LAN);
+		return MV_OUT_OF_RANGE;
+	}
+
+	/* Check the range of active_port */
+	if (active_port > MV_APP_PON_MAC_PORT) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "active_port[%d] is out of range[0~%d]\n",
+			active_port, MV_APP_PON_MAC_PORT);
+		return MV_OUT_OF_RANGE;
+	}
+
+	rc = cph_db_set_param(CPH_DB_PARAM_PROFILE_ID, &profile_id);
+	CHECK_API_RETURN_AND_LOG_ERROR(rc, "fail to call cph_db_set_param");
+
+	rc = cph_db_set_param(CPH_DB_PARAM_ACTIVE_PORT, &active_port);
+	CHECK_API_RETURN_AND_LOG_ERROR(rc, "fail to call cph_db_set_param");
+
+	return rc;
+}
+
+/******************************************************************************
+* cph_app_set_feature_flag()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Enable or disable feature support in CPH
+*
+* INPUTS:
+*       feature - CPH supported features
+*       state   - Enable or disable this feature in CPH
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_app_set_feature_flag(enum CPH_APP_FEATURE_E feature, bool state)
+{
+	MV_STATUS rc = MV_OK;
+
+	switch (feature) {
+	case CPH_APP_FEATURE_APP:
+		cph_db_set_param(CPH_DB_PARAM_APP_SUPPORT, &state);
+		break;
+	case CPH_APP_FEATURE_IGMP:
+		cph_db_set_param(CPH_DB_PARAM_IGMP_SUPPORT, &state);
+		break;
+	case CPH_APP_FEATURE_BC:
+		cph_db_set_param(CPH_DB_PARAM_BC_SUPPORT, &state);
+		break;
+	case CPH_APP_FEATURE_FLOW:
+		cph_db_set_param(CPH_DB_PARAM_FLOW_SUPPORT, &state);
+		break;
+	case CPH_APP_FEATURE_UDP:
+		cph_db_set_param(CPH_DB_PARAM_UDP_SUPPORT, &state);
+		break;
+	default:
+		break;
+	}
+	return rc;
+}
+
+/******************************************************************************
+* cph_app_validate_parse_field()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Validate the parsing filed of CPH rule
+*
+* INPUTS:
+*       parse_bm   - Parsing bitmap
+*       parse_key  - Parsing key
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_app_validate_parse_field(
+	enum CPH_APP_PARSE_FIELD_E parse_bm,
+	struct CPH_APP_PARSE_T      *parse_key)
+{
+	MV_STATUS rc = MV_OK;
+
+	/* Check the range of parse_bm */
+	if (parse_bm >= CPH_APP_PARSE_FIELD_END) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "parse_bm[0x%x] is out of range[0x01~0x%x]\n",
+			parse_bm, CPH_APP_PARSE_FIELD_END);
+		return MV_OUT_OF_RANGE;
+	}
+
+	/* Validate direction */
+	if (parse_bm & CPH_APP_PARSE_FIELD_DIR) {
+		if (parse_key->dir > CPH_DIR_NOT_CARE) {
+			MV_CPH_PRINT(CPH_ERR_LEVEL, "dir[%d] is out of range[0~%d]\n",
+				parse_key->dir, CPH_DIR_NOT_CARE);
+			return MV_OUT_OF_RANGE;
+		}
+	}
+
+	/* Validate RX/TX direction */
+	if (parse_bm & CPH_APP_PARSE_FIELD_RX_TX) {
+		if (parse_key->rx_tx > CPH_RX_TX_NOT_CARE) {
+			MV_CPH_PRINT(CPH_ERR_LEVEL, "rx_tx[%d] is out of range[0~%d]\n",
+				parse_key->rx_tx,
+				CPH_RX_TX_NOT_CARE);
+			return MV_OUT_OF_RANGE;
+		}
+	}
+
+	/* Could not parse None IPv4 Eth type and IPv4 protocol type at the same ime */
+	if ((parse_bm & CPH_APP_PARSE_FIELD_ETH_TYPE) &&
+		(parse_bm & CPH_APP_PARSE_FIELD_IPV4_TYPE) &&
+		(parse_key->eth_type != MV_CPH_ETH_TYPE_IPV4)) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "parse_bm[0x%x], eth_type[0x%x], does not support parsing None" \
+			"IPv4 Eth type and IPv4 protocol type at the same time\n",
+				parse_bm, parse_key->eth_type);
+		return MV_BAD_VALUE;
+	}
+
+	/* Could not parse None IPv6 Eth type and IPv4 protocol type at the same ime */
+	if ((parse_bm & CPH_APP_PARSE_FIELD_ETH_TYPE) &&
+		((parse_bm & CPH_APP_PARSE_FIELD_IPV6_NH1) ||
+		(parse_bm & CPH_APP_PARSE_FIELD_IPV6_NH2) ||
+		(parse_bm & CPH_APP_PARSE_FIELD_ICMPV6_TYPE)) &&
+		(parse_key->eth_type != MV_CPH_ETH_TYPE_IPV6)) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL,
+			"parse_bm[0x%x], eth_type[0x%x], does not support parsing None IPv6 Eth type and " \
+			"IPv6 NH or ICMP type at the same time\n",
+				parse_bm, parse_key->eth_type);
+		return MV_BAD_VALUE;
+	}
+
+	/* Could not parse Eth subtype and IPv4 the same time */
+	if ((parse_bm & CPH_APP_PARSE_FIELD_ETH_SUBTYPE) &&
+		(parse_bm & CPH_APP_PARSE_FIELD_IPV4_TYPE)) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL,
+			"parse_bm[0x%x], does not support parsing Eth subtype and IPv4 type at the same time\n",
+			parse_bm);
+		return MV_BAD_VALUE;
+	}
+
+	/* Could not parse Eth subtype and IPv6 the same time */
+	if ((parse_bm & CPH_APP_PARSE_FIELD_ETH_SUBTYPE) &&
+		((parse_bm & CPH_APP_PARSE_FIELD_IPV6_NH1) ||
+		(parse_bm & CPH_APP_PARSE_FIELD_IPV6_NH2) ||
+		(parse_bm & CPH_APP_PARSE_FIELD_ICMPV6_TYPE))) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL,
+			"parse_bm[0x%x], does not support parsing Eth subtype and IPv6 type at the same time\n",
+			parse_bm);
+		return MV_BAD_VALUE;
+	}
+
+	/* Could not parse IPv4 and IPv6 at the same time */
+	if ((parse_bm & CPH_APP_PARSE_FIELD_IPV4_TYPE) &&
+		((parse_bm & CPH_APP_PARSE_FIELD_IPV6_NH1) ||
+		 (parse_bm & CPH_APP_PARSE_FIELD_IPV6_NH2) ||
+		 (parse_bm & CPH_APP_PARSE_FIELD_ICMPV6_TYPE))) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL,
+			"parse_bm[0x%x], does not support parsing IPv4 and IPv6 type at the same time\n",
+			parse_bm);
+		return MV_BAD_VALUE;
+	}
+
+	/* Validate IGMPv6 type */
+	if ((parse_bm & CPH_APP_PARSE_FIELD_ICMPV6_TYPE) &&
+		(parse_key->icmpv6_type != MV_ICMPV6_TYPE_MLD)) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL,
+			"parse_bm[0x%x], icmpv6_type[%d], currently only support ICMPv6 MLD type[%d]\n",
+			parse_bm, parse_key->icmpv6_type, MV_ICMPV6_TYPE_MLD);
+		return MV_BAD_VALUE;
+	}
+	return rc;
+}
+
+/******************************************************************************
+* cph_app_validate_mod_field()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Validate the modification filed of CPH rule
+*
+* INPUTS:
+*       mod_bm     - Modification bitmap
+*       mod_value  - Modification value
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_app_validate_mod_field(
+	enum CPH_APP_MOD_FIELD_E   mod_bm,
+	struct CPH_APP_MOD_T        *mod_value)
+{
+	MV_STATUS rc = MV_OK;
+
+	/* Check the range of mod_bm */
+	if (mod_bm >= CPH_APP_MOD_FIELD_END) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "mod_bm[0x%x] is out of range[0x01~0x%x]\n", mod_bm, CPH_APP_MOD_FIELD_END);
+		return MV_OUT_OF_RANGE;
+	}
+
+	/* Does not support adding GMAC information and strip MH at the same time */
+	if ((mod_bm & CPH_APP_RX_MOD_ADD_GMAC) &&
+	    (mod_bm & CPH_APP_RX_MOD_STRIP_MH)) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL,
+			"mod_bm[0x%x], does not support adding GMAC information and stripping MH at the same time\n",
+			mod_bm);
+		return MV_BAD_VALUE;
+	}
+
+	return rc;
+}
+
+/******************************************************************************
+* cph_app_validate_frwd_field()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Validate the forwarding filed of CPH rule
+*
+* INPUTS:
+*       frwd_bm    - Forwarding bitmap
+*       frwd_value - Forwarding value
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_app_validate_frwd_field(
+	enum CPH_APP_FRWD_FIELD_E  frwd_bm,
+	struct CPH_APP_FRWD_T       *frwd_value)
+{
+	MV_STATUS rc = MV_OK;
+
+	/* Check the range of frwd_bm */
+	if (frwd_bm >= CPH_APP_FRWD_FIELD_END) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "frwd_bm[0x%x] is out of range[0x01~0x%x]\n",
+			frwd_bm, CPH_APP_FRWD_FIELD_END);
+		return MV_OUT_OF_RANGE;
+	}
+
+	return rc;
+}
+
+/******************************************************************************
+* cph_app_add_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Add CPH rule
+*
+* INPUTS:
+*       parse_bm   - Parsing bitmap
+*       parse_key  - Parsing key
+*       mod_bm     - Modification bitmap
+*       mod_value  - Modification value
+*       frwd_bm    - Forwarding bitmap
+*       frwd_value - Forwarding value
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_app_add_rule(
+	enum CPH_APP_PARSE_FIELD_E parse_bm,
+	struct CPH_APP_PARSE_T      *parse_key,
+	enum CPH_APP_MOD_FIELD_E   mod_bm,
+	struct CPH_APP_MOD_T        *mod_value,
+	enum CPH_APP_FRWD_FIELD_E  frwd_bm,
+	struct CPH_APP_FRWD_T       *frwd_value)
+{
+	MV_STATUS rc = MV_OK;
+
+	rc = cph_app_validate_parse_field(parse_bm, parse_key);
+	CHECK_API_RETURN_AND_LOG_ERROR(rc, "fail to valid parsing field");
+
+	rc = cph_app_validate_mod_field(mod_bm, mod_value);
+	CHECK_API_RETURN_AND_LOG_ERROR(rc, "fail to valid modification field");
+
+	rc = cph_app_validate_frwd_field(frwd_bm, frwd_value);
+	CHECK_API_RETURN_AND_LOG_ERROR(rc, "fail to valid forwarding field");
+
+	rc = cph_db_add_app_rule(parse_bm, parse_key, mod_bm, mod_value, frwd_bm, frwd_value);
+	CHECK_API_RETURN_AND_LOG_ERROR(rc, "fail to call cph_db_add_app_rule");
+
+	return rc;
+}
+
+/******************************************************************************
+* cph_app_del_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Delete CPH rule
+*
+* INPUTS:
+*       parse_bm   - Parsing bitmap
+*       parse_key  - Parsing key
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_app_del_rule(
+	enum CPH_APP_PARSE_FIELD_E parse_bm,
+	struct CPH_APP_PARSE_T      *parse_key)
+{
+	MV_STATUS rc = MV_OK;
+
+	rc = cph_app_validate_parse_field(parse_bm, parse_key);
+	CHECK_API_RETURN_AND_LOG_ERROR(rc, "fail to valid parsing field");
+
+	rc = cph_db_del_app_rule(parse_bm, parse_key);
+	CHECK_API_RETURN_AND_LOG_ERROR(rc, "fail to call cph_db_del_app_rule");
+
+	return rc;
+}
+
+/******************************************************************************
+* cph_app_update_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Update CPH rule
+*
+* INPUTS:
+*       parse_bm   - Parsing bitmap
+*       parse_key  - Parsing key
+*       mod_bm     - Modification bitmap
+*       mod_value  - Modification value
+*       frwd_bm    - Forwarding bitmap
+*       frwd_value - Forwarding value
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_app_update_rule(
+	enum CPH_APP_PARSE_FIELD_E parse_bm,
+	struct CPH_APP_PARSE_T      *parse_key,
+	enum CPH_APP_MOD_FIELD_E   mod_bm,
+	struct CPH_APP_MOD_T        *mod_value,
+	enum CPH_APP_FRWD_FIELD_E  frwd_bm,
+	struct CPH_APP_FRWD_T       *frwd_value)
+{
+	MV_STATUS rc = MV_OK;
+
+	rc = cph_app_validate_parse_field(parse_bm, parse_key);
+	CHECK_API_RETURN_AND_LOG_ERROR(rc, "fail to valid parsing field");
+
+	rc = cph_app_validate_mod_field(mod_bm, mod_value);
+	CHECK_API_RETURN_AND_LOG_ERROR(rc, "fail to valid modification field");
+
+	rc = cph_app_validate_frwd_field(frwd_bm, frwd_value);
+	CHECK_API_RETURN_AND_LOG_ERROR(rc, "fail to valid forwarding field");
+
+	rc = cph_db_update_app_rule(parse_bm, parse_key, mod_bm, mod_value, frwd_bm, frwd_value);
+	CHECK_API_RETURN_AND_LOG_ERROR(rc, "fail to call cph_db_update_app_rule");
+
+	return rc;
+}
+
+/******************************************************************************
+* cph_app_get_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Get CPH rule
+*
+* INPUTS:
+*       parse_bm   - Parsing bitmap
+*       parse_key  - Parsing key
+*
+* OUTPUTS:
+*       mod_bm     - Modification bitmap
+*       mod_value  - Modification value
+*       frwd_bm    - Forwarding bitmap
+*       frwd_value - Forwarding value
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_app_get_rule(
+	enum CPH_APP_PARSE_FIELD_E parse_bm,
+	struct CPH_APP_PARSE_T      *parse_key,
+	enum CPH_APP_MOD_FIELD_E  *mod_bm,
+	struct CPH_APP_MOD_T        *mod_value,
+	enum CPH_APP_FRWD_FIELD_E *frwd_bm,
+	struct CPH_APP_FRWD_T       *frwd_value)
+{
+	MV_STATUS rc = MV_OK;
+
+	rc = cph_app_validate_parse_field(parse_bm, parse_key);
+	CHECK_API_RETURN_AND_LOG_ERROR(rc, "fail to valid parsing field");
+
+	rc = cph_db_get_app_rule(parse_bm, parse_key, mod_bm, mod_value, frwd_bm, frwd_value);
+	if (rc != MV_OK)
+		MV_CPH_PRINT(CPH_DEBUG_LEVEL, "fail to call cph_app_get_rule\n");
+
+	return rc;
+}
+
+/******************************************************************************
+* cph_app_get_rule_by_dir_proto()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Get CPH rule according to protocol type
+*
+* INPUTS:
+*       dir        - Direction
+*       proto_type - SKB protocol type
+*
+* OUTPUTS:
+*       parse_bm   - Parsing bitmap
+*       parse_key  - Parsing key
+*       mod_bm     - Modification bitmap
+*       mod_value  - Modification value
+*       frwd_bm    - Forwarding bitmap
+*       frwd_value - Forwarding value
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_app_get_rule_by_dir_proto(
+	enum CPH_DIR_E              dir,
+	unsigned short                 proto_type,
+	enum CPH_APP_PARSE_FIELD_E *parse_bm,
+	struct CPH_APP_PARSE_T       *parse_key,
+	enum CPH_APP_MOD_FIELD_E   *mod_bm,
+	struct CPH_APP_MOD_T         *mod_value,
+	enum CPH_APP_FRWD_FIELD_E  *frwd_bm,
+	struct CPH_APP_FRWD_T        *frwd_value)
+{
+	MV_STATUS rc = MV_OK;
+
+	rc = cph_db_get_app_rule_by_dir_proto(dir, proto_type, parse_bm,
+		parse_key, mod_bm, mod_value, frwd_bm, frwd_value);
+	CHECK_API_RETURN_AND_LOG_ERROR(rc, "fail to call cph_db_get_app_rule_by_dir_proto");
+
+	return rc;
+}
+
+/******************************************************************************
+* cph_app_increase_counter()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Increase RX counter
+*
+* INPUTS:
+*       parse_bm   - Parsing bitmap
+*       parse_key  - Parsing key
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_app_increase_counter(
+	enum CPH_APP_PARSE_FIELD_E parse_bm,
+	struct CPH_APP_PARSE_T      *parse_key)
+{
+	MV_STATUS rc = MV_OK;
+
+	rc = cph_app_validate_parse_field(parse_bm, parse_key);
+	CHECK_API_RETURN_AND_LOG_ERROR(rc, "fail to valid parsing field");
+
+	rc = cph_db_increase_counter(parse_bm, parse_key);
+	CHECK_API_RETURN_AND_LOG_ERROR(rc, "fail to call cph_db_increase_counter");
+
+	return rc;
+}
+
+/******************************************************************************
+* cph_app_increase_counter_by_dir_proto()
+* _____________________________________________________________________________
+*
+* DESCRIPTION:  Increase RX counter according to protocol type
+*
+* INPUTS:
+*       dir        - Direction
+*       proto_type - SKB protocol type
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_app_increase_counter_by_dir_proto(
+	enum CPH_DIR_E dir,
+	unsigned short    proto_type)
+{
+	MV_STATUS rc = MV_OK;
+
+	rc = cph_db_increase_counter_by_dir_proto(dir, proto_type);
+	CHECK_API_RETURN_AND_LOG_ERROR(rc, "fail to call cph_db_increase_counter_by_dir_proto");
+
+	return rc;
+}
+
+/******************************************************************************
+* cph_app_parse_ge_port_type()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Get GEMAC port type by profile ID
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       port_type   - Modification bitmap
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_app_parse_ge_port_type(struct CPH_PORT_STATE_T *port_type)
+{
+	enum tpm_eth_complex_profile_t  profile_id  = 0;
+	enum MV_APP_GMAC_PORT_E         active_port = 0;
+	MV_STATUS                  rc          = MV_OK;
+
+	/* Get Profile ID and active WAN port */
+	cph_db_get_param(CPH_DB_PARAM_PROFILE_ID,  &profile_id);
+	cph_db_get_param(CPH_DB_PARAM_ACTIVE_PORT, &active_port);
+
+	switch (profile_id) {
+	case TPM_PON_WAN_DUAL_MAC_INT_SWITCH:
+	case TPM_PON_WAN_G1_LAN_G0_INT_SWITCH:
+	case TPM_PON_WAN_DUAL_MAC_EXT_SWITCH:
+	case TPM_PON_WAN_G0_G1_DUAL_LAN:
+		port_type[MV_APP_GMAC_PORT_0].port_type   = MV_APP_PORT_LAN;
+		port_type[MV_APP_GMAC_PORT_0].port_state  = MV_GE_PORT_ACTIVE;
+		port_type[MV_APP_GMAC_PORT_1].port_type   = MV_APP_PORT_LAN;
+		port_type[MV_APP_GMAC_PORT_1].port_state  = MV_GE_PORT_ACTIVE;
+		port_type[MV_APP_PON_MAC_PORT].port_type  = MV_APP_PORT_WAN;
+		port_type[MV_APP_PON_MAC_PORT].port_state = MV_GE_PORT_ACTIVE;
+		break;
+	case TPM_PON_WAN_G0_INT_SWITCH:
+	case TPM_PON_WAN_G0_SINGLE_PORT:
+	case TPM_PON_WAN_G0_G1_LPBK:
+		port_type[MV_APP_GMAC_PORT_0].port_type   = MV_APP_PORT_LAN;
+		port_type[MV_APP_GMAC_PORT_0].port_state  = MV_GE_PORT_ACTIVE;
+		port_type[MV_APP_GMAC_PORT_1].port_state  = MV_GE_PORT_INVALID;
+		port_type[MV_APP_PON_MAC_PORT].port_type  = MV_APP_PORT_WAN;
+		port_type[MV_APP_PON_MAC_PORT].port_state = MV_GE_PORT_ACTIVE;
+		break;
+	case TPM_G0_WAN_G1_INT_SWITCH:
+		port_type[MV_APP_GMAC_PORT_0].port_type   = MV_APP_PORT_WAN;
+		port_type[MV_APP_GMAC_PORT_0].port_state  = MV_GE_PORT_ACTIVE;
+		port_type[MV_APP_GMAC_PORT_1].port_type   = MV_APP_PORT_LAN;
+		port_type[MV_APP_GMAC_PORT_1].port_state  = MV_GE_PORT_ACTIVE;
+		port_type[MV_APP_PON_MAC_PORT].port_state = MV_GE_PORT_INVALID;
+		break;
+	case TPM_G1_WAN_G0_INT_SWITCH:
+		port_type[MV_APP_GMAC_PORT_0].port_type   = MV_APP_PORT_LAN;
+		port_type[MV_APP_GMAC_PORT_0].port_state  = MV_GE_PORT_ACTIVE;
+		port_type[MV_APP_GMAC_PORT_1].port_type   = MV_APP_PORT_WAN;
+		port_type[MV_APP_GMAC_PORT_1].port_state  = MV_GE_PORT_ACTIVE;
+		port_type[MV_APP_PON_MAC_PORT].port_state = MV_GE_PORT_INVALID;
+		break;
+	case TPM_PON_G1_WAN_G0_INT_SWITCH:
+	case TPM_PON_G1_WAN_G0_SINGLE_PORT:
+		port_type[MV_APP_GMAC_PORT_0].port_type   = MV_APP_PORT_LAN;
+		port_type[MV_APP_GMAC_PORT_0].port_state  = MV_GE_PORT_ACTIVE;
+		port_type[MV_APP_GMAC_PORT_1].port_type   = MV_APP_PORT_WAN;
+		port_type[MV_APP_PON_MAC_PORT].port_type  = MV_APP_PORT_WAN;
+
+		if (active_port == MV_APP_GMAC_PORT_1) {
+			port_type[MV_APP_GMAC_PORT_1].port_state  = MV_GE_PORT_ACTIVE;
+			port_type[MV_APP_PON_MAC_PORT].port_state = MV_GE_PORT_INACTIVE;
+		} else {
+			port_type[MV_APP_GMAC_PORT_1].port_state  = MV_GE_PORT_INACTIVE;
+			port_type[MV_APP_PON_MAC_PORT].port_state = MV_GE_PORT_ACTIVE;
+		}
+		break;
+	case TPM_PON_G0_WAN_G1_INT_SWITCH:
+	case TPM_PON_G0_WAN_G1_SINGLE_PORT:
+		port_type[MV_APP_GMAC_PORT_0].port_type   = MV_APP_PORT_WAN;
+		port_type[MV_APP_GMAC_PORT_1].port_type   = MV_APP_PORT_LAN;
+		port_type[MV_APP_GMAC_PORT_1].port_state  = MV_GE_PORT_ACTIVE;
+		port_type[MV_APP_PON_MAC_PORT].port_type  = MV_APP_PORT_WAN;
+		if (active_port == MV_APP_GMAC_PORT_0) {
+			port_type[MV_APP_GMAC_PORT_0].port_state  = MV_GE_PORT_ACTIVE;
+			port_type[MV_APP_PON_MAC_PORT].port_state = MV_GE_PORT_INACTIVE;
+		} else {
+			port_type[MV_APP_GMAC_PORT_0].port_state  = MV_GE_PORT_INACTIVE;
+			port_type[MV_APP_PON_MAC_PORT].port_state = MV_GE_PORT_ACTIVE;
+		}
+		break;
+	case TPM_PON_WAN_G1_MNG_EXT_SWITCH:
+	case TPM_PON_WAN_G1_SINGLE_PORT:
+		port_type[MV_APP_GMAC_PORT_0].port_state  = MV_GE_PORT_INVALID;
+		port_type[MV_APP_GMAC_PORT_1].port_type   = MV_APP_PORT_LAN;
+		port_type[MV_APP_GMAC_PORT_1].port_state  = MV_GE_PORT_ACTIVE;
+		port_type[MV_APP_PON_MAC_PORT].port_type  = MV_APP_PORT_WAN;
+		port_type[MV_APP_PON_MAC_PORT].port_state = MV_GE_PORT_ACTIVE;
+		break;
+	default:
+		port_type[MV_APP_GMAC_PORT_0].port_state  = MV_GE_PORT_INVALID;
+		port_type[MV_APP_GMAC_PORT_1].port_state  = MV_GE_PORT_INVALID;
+		port_type[MV_APP_PON_MAC_PORT].port_state = MV_GE_PORT_INVALID;
+		break;
+	}
+	/* loopback port will be LAN side port by default */
+	port_type[MV_APP_LPBK_PORT].port_type  = MV_APP_PORT_LAN;
+	port_type[MV_APP_LPBK_PORT].port_state = MV_GE_PORT_ACTIVE;
+
+	return rc;
+}
+
+/******************************************************************************
+* cph_app_parse_peer_port()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Get peer GEMAC port
+*
+* INPUTS:
+*       port        - Original port
+*
+* OUTPUTS:
+*       peer_port   - Peer port
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_app_parse_peer_port(
+	int    port,
+	int   *peer_port)
+{
+	unsigned int            idx = 0;
+	struct CPH_PORT_STATE_T  port_type[MV_APP_GMAC_PORT_NUM];
+	MV_STATUS         rc  = MV_FAIL;
+
+	/* Verify port */
+	if (port > MV_APP_PON_MAC_PORT) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "port[%d] is out of range[0~%d]\n", port, MV_APP_PON_MAC_PORT);
+		return MV_OUT_OF_RANGE;
+	}
+
+	/* Get port type */
+	rc = cph_app_parse_ge_port_type(&port_type[0]);
+
+	/* Search for peer port */
+	if (port_type[port].port_type == MV_APP_PORT_LAN) {
+		for (idx = 0; idx < MV_APP_GMAC_PORT_NUM; idx++) {
+			if (idx == port)
+				continue;
+			if ((port_type[idx].port_type  == MV_APP_PORT_WAN) &&
+			    (port_type[idx].port_state == MV_GE_PORT_ACTIVE)) {
+				*peer_port = idx;
+				rc  = MV_OK;
+				break;
+			}
+		}
+	} else if (port_type[port].port_type == MV_APP_PORT_WAN) {
+		for (idx = 0; idx < MV_APP_GMAC_PORT_NUM; idx++) {
+			if (idx == port)
+				continue;
+			if (port_type[idx].port_type  == MV_APP_PORT_LAN) {
+				*peer_port = idx;
+				rc  = MV_OK;
+				break;
+			}
+		}
+	}
+
+	return rc;
+}
+
+/******************************************************************************
+* cph_app_parse_dir()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Parse application packet to output parse bitmap and value
+*
+* INPUTS:
+*       port  - GE MAC port
+*       rx    - Whether RX path
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       Return direction.
+*******************************************************************************/
+enum CPH_DIR_E cph_app_parse_dir(
+	int    port,
+	bool     rx)
+{
+	struct CPH_PORT_STATE_T port_type[MV_APP_GMAC_PORT_NUM];
+	MV_STATUS        rc  = MV_OK;
+	enum CPH_DIR_E        dir = CPH_DIR_INVALID;
+
+	/* Parse port */
+	if (port > MV_APP_PON_MAC_PORT) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "port[%d] is out of range[0~%d]\n", port, MV_APP_PON_MAC_PORT);
+		return dir;
+	}
+
+	/* Get GMAC WAN/LAN type */
+	rc = cph_app_parse_ge_port_type(&port_type[0]);
+	if (rc != MV_OK) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "fail to call cph_app_parse_ge_port_type()\n");
+		return dir;
+	}
+
+	/* Rx dir */
+	if (rx == TRUE) {
+		if ((port_type[port].port_type  == MV_APP_PORT_WAN) &&
+		    (port_type[port].port_state == MV_GE_PORT_ACTIVE))
+			dir = CPH_DIR_DS;
+		else if ((port_type[port].port_type  == MV_APP_PORT_LAN) &&
+			(port_type[port].port_state == MV_GE_PORT_ACTIVE))
+			dir = CPH_DIR_US;
+		else {
+			dir = CPH_DIR_INVALID;
+			MV_CPH_PRINT(CPH_ERR_LEVEL, "RX dir[%d] is invalid\n", dir);
+		}
+	} else {/* Tx dir */
+		if ((port_type[port].port_type  == MV_APP_PORT_WAN) &&
+		    (port_type[port].port_state == MV_GE_PORT_ACTIVE))
+			dir = CPH_DIR_US;
+		else if ((port_type[port].port_type  == MV_APP_PORT_LAN) &&
+			(port_type[port].port_state == MV_GE_PORT_ACTIVE))
+			dir = CPH_DIR_DS;
+		else {
+			dir = CPH_DIR_INVALID;
+			MV_CPH_PRINT(CPH_ERR_LEVEL, "TX dir[%d] is invalid\n", dir);
+		}
+	}
+
+	return dir;
+}
+
+/******************************************************************************
+* cph_app_parse_packet()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Parse application packet to output parse bitmap and value
+*
+* INPUTS:
+*       port       - GE MAC port
+*       skb_data   - Pointer to SKB data holding application packet
+*
+* OUTPUTS:
+*       parse_bm   - Parsing bitmap
+*       parse_key  - Parsing key
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_app_parse_packet(
+	int                  port,
+	unsigned char                 *skb_data,
+	enum CPH_APP_PARSE_FIELD_E *parse_bm,
+	struct CPH_APP_PARSE_T       *parse_key)
+{
+	unsigned short                  eth_type     = 0;
+	struct ipv6hdr         *p_ipv6_hdr   = NULL;
+	struct ipv6_hopopt_hdr *p_hopopt_hdr = NULL;
+	struct icmp6hdr        *p_icmp_hdr   = NULL;
+	unsigned char                  *p_field      = NULL;
+	MV_STATUS               rc           = MV_OK;
+
+	*parse_bm = 0;
+	memset(parse_key, 0, sizeof(struct CPH_APP_PARSE_T));
+
+	/* Parse dir */
+	parse_key->dir = cph_app_parse_dir(port, TRUE);
+	if (parse_key->dir == CPH_DIR_INVALID) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "dir[%d] is invalid\n", parse_key->dir);
+		return MV_BAD_VALUE;
+	}
+	*parse_bm |= CPH_APP_PARSE_FIELD_DIR;
+
+	/* Parse RX/TX */
+	parse_key->rx_tx = CPH_DIR_RX;
+	*parse_bm |= CPH_APP_PARSE_FIELD_RX_TX;
+
+	/* Parse Marvell header */
+	if (parse_key->dir == CPH_DIR_US)
+		parse_key->mh = (ntohs(*(unsigned short *)skb_data) & MV_VALID_MH_MASK);
+	else
+		parse_key->mh = (ntohs(*(unsigned short *)skb_data) & MV_VALID_GH_MASK);
+
+	*parse_bm |= CPH_APP_PARSE_FIELD_MH;
+
+	/* Parse Eth type */
+	p_field  = skb_data + MV_ETH_MH_SIZE + ETH_ALEN + ETH_ALEN;
+	eth_type = ntohs(*(unsigned short *)p_field);
+	while (eth_type == MV_TPID_8100 || eth_type == MV_TPID_88A8 || eth_type == MV_TPID_9100) {
+		p_field += VLAN_HLEN;
+		eth_type = ntohs(*(unsigned short *)p_field);
+	}
+	parse_key->eth_type = eth_type;
+	*parse_bm |= CPH_APP_PARSE_FIELD_ETH_TYPE;
+
+	/* Parse IPv4 type */
+	if (eth_type == ETH_P_IP) {
+		p_field += MV_CPH_ETH_TYPE_LEN;
+		p_field += MV_IPV4_PROTO_OFFSET;
+		parse_key->ipv4_type = *(unsigned char *)p_field;
+		*parse_bm |= CPH_APP_PARSE_FIELD_IPV4_TYPE;
+	} else if (eth_type == ETH_P_IPV6) {/* Parse IPv6 type */
+		p_ipv6_hdr = (struct ipv6hdr *)(p_field + MV_CPH_ETH_TYPE_LEN);
+		parse_key->ipv6_nh1 = p_ipv6_hdr->nexthdr;
+		*parse_bm |= CPH_APP_PARSE_FIELD_IPV6_NH1;
+
+		if (p_ipv6_hdr->nexthdr != NEXTHDR_HOP)
+			return rc;
+
+		p_hopopt_hdr = (struct ipv6_hopopt_hdr *)((unsigned char *)p_ipv6_hdr + sizeof(struct ipv6hdr));
+
+		parse_key->ipv6_nh2 = p_hopopt_hdr->nexthdr;
+		*parse_bm |= CPH_APP_PARSE_FIELD_IPV6_NH2;
+
+		if (p_hopopt_hdr->nexthdr != IPPROTO_ICMPV6)
+			return rc;
+
+		p_icmp_hdr =  (struct icmp6hdr *)((unsigned char *)p_hopopt_hdr + ipv6_optlen(p_hopopt_hdr));
+
+		switch (p_icmp_hdr->icmp6_type) {
+		case ICMPV6_MGM_QUERY:
+		case ICMPV6_MGM_REPORT:
+		case ICMPV6_MGM_REDUCTION:
+		case ICMPV6_MLD2_REPORT:
+			parse_key->icmpv6_type = MV_ICMPV6_TYPE_MLD;
+			*parse_bm |= CPH_APP_PARSE_FIELD_ICMPV6_TYPE;
+			break;
+		default:
+			break;
+		}
+	} else {/* Parse Ethenet subtype */
+		parse_key->eth_subtype = (*(unsigned char *)(p_field + MV_CPH_ETH_TYPE_LEN));
+		*parse_bm |= CPH_APP_PARSE_FIELD_ETH_SUBTYPE;
+	}
+
+	return rc;
+}
+
+/******************************************************************************
+* cph_app_mod_rx_packet()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Modify RX application packet
+*
+* INPUTS:
+*       port      - Gmac port the packet from
+*       dev       - Net device
+*       skb       - SKB buffer to receive packet
+*       rx_desc   - RX descriptor
+*       mod_bm    - Modification bitmap
+*       mod_value - Modification value
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_app_mod_rx_packet(
+	int                port,
+	struct net_device   *dev,
+	struct sk_buff      *skb,
+	struct pp2_rx_desc  *rx_desc,
+	enum CPH_APP_MOD_FIELD_E  mod_bm,
+	struct CPH_APP_MOD_T       *mod_value)
+{
+	unsigned char     *p_data = NULL;
+	MV_STATUS  rc     = MV_OK;
+
+	/* Save GMAC Information */
+	if (mod_bm & CPH_APP_RX_MOD_ADD_GMAC) {
+		p_data     = (unsigned char *)skb->data;
+		p_data[0] &= 0x0F;
+		p_data[0] |= ((port & 0x0F) << 4);
+	}
+
+	if (mod_bm & CPH_APP_RX_MOD_STRIP_MH) {
+		skb->data += MV_ETH_MH_SIZE;
+		skb->tail -= MV_ETH_MH_SIZE;
+		skb->len  -= MV_ETH_MH_SIZE;
+	}
+
+	skb->protocol = eth_type_trans(skb, dev);
+	if (mod_bm & CPH_APP_RX_MOD_REPLACE_PROTO_TYPE)
+		skb->protocol = mod_value->proto_type;
+
+	return rc;
+}
+
+/******************************************************************************
+* cph_app_mod_tx_packet()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Modify TX application packet
+*
+* INPUTS:
+*       skb         - Pointer to SKB data hoding application packet
+*       tx_spec_out - TX descriptor
+*       mod_bm      - Modification bitmap
+*       mod_value   - Modification value
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_app_mod_tx_packet(
+	struct sk_buff        *skb,
+	struct mv_eth_tx_spec *tx_spec_out,
+	enum CPH_APP_MOD_FIELD_E    mod_bm,
+	struct CPH_APP_MOD_T         *mod_value)
+{
+	MV_STATUS rc = MV_OK;
+
+	if (mod_bm & CPH_APP_TX_MOD_ADD_MH_BY_DRIVER) {
+		tx_spec_out->flags |= MV_ETH_TX_F_MH;
+		tx_spec_out->tx_mh = MV_16BIT_BE(mod_value->mh);
+	}
+
+	if (mod_bm & CPH_APP_TX_MOD_NO_PAD)
+		tx_spec_out->flags |= MV_ETH_TX_F_NO_PAD;
+
+	return rc;
+}
+
+/******************************************************************************
+* cph_app_set_frwd()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Set packet forwarding information
+*
+* INPUTS:
+*       skb         - Pointer to SKB data hoding application packet
+*       tx_spec_out - TX descriptor
+*       frwd_bm     - Forwarding bitmap
+*       frwd_value  - Forwarding value
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_app_set_frwd(
+	struct sk_buff        *skb,
+	struct mv_eth_tx_spec *tx_spec_out,
+	enum CPH_APP_FRWD_FIELD_E   frwd_bm,
+	struct CPH_APP_FRWD_T        *frwd_value)
+{
+	MV_STATUS rc = MV_OK;
+
+	if (frwd_bm & CPH_APP_FRWD_SET_TRG_PORT)
+		tx_spec_out->txp = frwd_value->trg_port;
+
+	if (frwd_bm & CPH_APP_FRWD_SET_TRG_QUEUE)
+		tx_spec_out->txq = frwd_value->trg_queue;
+
+	if (frwd_bm & CPH_APP_FRWD_SET_GEM_PORT)
+		tx_spec_out->hw_cmd[0] = ((frwd_value->gem_port << 8)|0x0010);
+
+	tx_spec_out->tx_func = NULL;
+
+	return rc;
+}
+
+/******************************************************************************
+* cph_app_rx_bc()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: CPH function to handle the received broadcast packets
+*
+* INPUTS:
+*       port    - Gmac port the packet from
+*       dev     - Net device
+*       pkt     - Marvell packet information
+*       rx_desc - RX descriptor
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns 1.
+*       On error returns 0.
+*******************************************************************************/
+int cph_app_rx_bc(int port, struct net_device *dev, struct sk_buff *skb, struct pp2_rx_desc *rx_desc)
+{
+	struct CPH_FLOW_ENTRY_T      flow_rule;
+	int                 peer_port = 0;
+	int                 rx_size   = 0;
+	int                 offset    = 0;
+	bool                  state     = FALSE;
+	struct sk_buff       *skb_old   = NULL;
+	struct sk_buff       *skb_new   = NULL;
+	MV_STATUS             rc        = MV_OK;
+
+	/* Check whether need to handle broadcast packet */
+	cph_db_get_param(CPH_DB_PARAM_BC_SUPPORT, &state);
+	if (state == FALSE)
+		return 0;
+
+	/* Parse packets */
+	skb_old = skb;
+	skb_new = skb;
+	rc = cph_flow_parse_packet(port, skb_old->data, TRUE, TRUE, &flow_rule);
+	if (rc != MV_OK) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "fail to call cph_flow_parse_packet, rc<%d>\n", rc);
+		return 0;
+	}
+
+	/* U/S */
+	if (flow_rule.dir == CPH_DIR_US) {
+		/* Forward packet to peer port */
+		rc = cph_app_parse_peer_port(port, &peer_port);
+		if (rc != MV_OK) {
+			MV_CPH_PRINT(CPH_ERR_LEVEL, "fail to call cph_app_parse_peer_port, rc<%d>\n", rc);
+			return 0;
+		}
+
+		/* Forward packet */
+		if (netif_running(mv_eth_ports[peer_port]->dev)) {
+			/* Copy a new SKB */
+			skb_old->tail += rx_desc->dataSize;
+			skb_old->len   = rx_desc->dataSize;
+			skb_new = skb_copy(skb_old, GFP_ATOMIC);
+			if (skb_new == NULL) {
+				skb_new = skb_old;
+				goto out;
+			}
+			mv_eth_ports[peer_port]->dev->netdev_ops->ndo_start_xmit(skb_old, mv_eth_ports[peer_port]->dev);
+		}
+	}
+out:
+	/* Stripe VLAN tag, then send to Linux network stack */
+	offset         = cph_flow_strip_vlan(TRUE, skb_new->data);
+	skb_new->data += offset;
+	rx_size       -= offset;
+
+	/* Strip MH */
+	skb_new->data += MV_ETH_MH_SIZE;
+	offset        += MV_ETH_MH_SIZE;
+
+	skb_new->tail    -= offset;
+	skb_new->len     -= offset;
+	skb_new->protocol = eth_type_trans(skb_new, dev);
+
+	cph_rec_skb(port, skb_new);
+
+	return 1;
+}
+
+/******************************************************************************
+* cph_app_lookup_profile_id()
+* _____________________________________________________________________________
+*
+* DESCRIPTION:lookup profile ID string according to value
+*
+* INPUTS:
+*       enum_value - The enum value to be matched
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       Enum string
+*******************************************************************************/
+char *cph_app_lookup_profile_id(int enum_value)
+{
+	return mtype_lookup_enum_str(&g_enum_array_profile_id, enum_value);
+}
+
+/******************************************************************************
+* cph_app_lookup_pon_type()
+* _____________________________________________________________________________
+*
+* DESCRIPTION:lookup PON type string according to value
+*
+* INPUTS:
+*       enum_value - The enum value to be matched
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       Enum string
+*******************************************************************************/
+char *cph_app_lookup_pon_type(int enum_value)
+{
+	return mtype_lookup_enum_str(&g_enum_array_pon_type, enum_value);
+}
+
+/******************************************************************************
+* cph_app_lookup_dir()
+* _____________________________________________________________________________
+*
+* DESCRIPTION:lookup direction string according to value
+*
+* INPUTS:
+*       enum_value - The enum value to be matched
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       Enum string
+*******************************************************************************/
+char *cph_app_lookup_dir(int enum_value)
+{
+	return mtype_lookup_enum_str(&g_enum_array_dir, enum_value);
+}
+
+/******************************************************************************
+* cph_app_lookup_rx_tx()
+* _____________________________________________________________________________
+*
+* DESCRIPTION:lookup RX/TX direction string according to value
+*
+* INPUTS:
+*       enum_value - The enum value to be matched
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       Enum string
+*******************************************************************************/
+char *cph_app_lookup_rx_tx(int enum_value)
+{
+	return mtype_lookup_enum_str(&g_enum_array_rx_tx, enum_value);
+}
+
+/******************************************************************************
+* cph_app_lookup_gmac()
+* _____________________________________________________________________________
+*
+* DESCRIPTION:lookup GMAC string according to value
+*
+* INPUTS:
+*       enum_value - The enum value to be matched
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       Enum string
+*******************************************************************************/
+char *cph_app_lookup_gmac(int enum_value)
+{
+	return mtype_lookup_enum_str(&g_enum_array_gmac, enum_value);
+}
+
+
+/******************************************************************************
+* cph_app_init()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Initializes CPH application module.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int  cph_app_init(void)
+{
+
+	cph_db_init();
+
+	return MV_OK;
+}
+
+/******************************************************************************
+* cph_set_trace_flag()
+* _____________________________________________________________________________
+*
+* DESCRIPTION:sets cph trace flag.
+*
+* INPUTS:
+*       enum_value - The enum value to be matched
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_set_trace_flag(unsigned int flag)
+{
+	g_cph_global_trace = flag;
+
+	return MV_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_app.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_app.h
new file mode 100644
index 0000000..dbce709
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_app.h
@@ -0,0 +1,766 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+	*   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+	*   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+	*   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+********************************************************************************
+* mv_cph_app.h
+*
+* DESCRIPTION: Marvell CPH(CPH Packet Handler) application module to implement
+*              CPH main logic and handle application packets such as OMCI, eOAM,
+*              IGMP packets.
+*
+* DEPENDENCIES:
+*               None
+*
+* CREATED BY:   VictorGu
+*
+* DATE CREATED: 22Jan2013
+*
+* FILE REVISION NUMBER:
+*               Revision: 1.0
+*
+*
+*******************************************************************************/
+#ifndef _MV_CPH_APP_H_
+#define _MV_CPH_APP_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/******************************************************************************
+* Type Definition
+******************************************************************************/
+#define MV_VALID_MH_MASK  0x007F  /* Valid MH filed in CPH */
+#define MV_VALID_GH_MASK  0x0FFF  /* Valid MH filed in CPH */
+
+
+/* CPH application packets parsing field definition
+------------------------------------------------------------------------------*/
+enum CPH_APP_PARSE_FIELD_E {
+	CPH_APP_PARSE_FIELD_DIR          = 0x1,
+	CPH_APP_PARSE_FIELD_RX_TX        = 0x2,
+	CPH_APP_PARSE_FIELD_MH           = 0x4,
+	CPH_APP_PARSE_FIELD_ETH_TYPE     = 0x8,
+	CPH_APP_PARSE_FIELD_ETH_SUBTYPE  = 0x10,
+	CPH_APP_PARSE_FIELD_IPV4_TYPE    = 0x20,
+	CPH_APP_PARSE_FIELD_IPV6_NH1     = 0x40,
+	CPH_APP_PARSE_FIELD_IPV6_NH2     = 0x80,
+	CPH_APP_PARSE_FIELD_ICMPV6_TYPE  = 0x100,
+	CPH_APP_PARSE_FIELD_END          = 0x200
+};
+
+enum CPH_DIR_E {
+	CPH_DIR_US       = 0,
+	CPH_DIR_DS       = 1,
+	CPH_DIR_NOT_CARE = 2,
+	CPH_DIR_NUM      = 2,
+	CPH_DIR_INVALID  = 3
+};
+
+enum CPH_RX_TX_E {
+	CPH_DIR_RX         = 0,
+	CPH_DIR_TX         = 1,
+	CPH_RX_TX_NOT_CARE = 2,
+};
+
+struct CPH_APP_PARSE_T {
+	enum CPH_DIR_E   dir;
+	enum CPH_RX_TX_E rx_tx;
+	unsigned short      mh;
+	unsigned short      eth_type;
+	unsigned char       eth_subtype;
+	unsigned char       ipv4_type;
+	unsigned char       ipv6_nh1;
+	unsigned char       ipv6_nh2;
+	unsigned int      icmpv6_type;
+};
+
+/* CPH application packets modification field definition
+------------------------------------------------------------------------------*/
+enum CPH_APP_MOD_FIELD_E {
+	CPH_APP_RX_MOD_ADD_GMAC           = 0x1,
+	CPH_APP_RX_MOD_REPLACE_PROTO_TYPE = 0x2,
+	CPH_APP_RX_MOD_STRIP_MH           = 0x4,
+	CPH_APP_TX_MOD_ADD_MH_BY_DRIVER   = 0x8,
+	CPH_APP_TX_MOD_NO_PAD             = 0x10,
+	CPH_APP_MOD_CHANGE_STATE          = 0x20,
+	CPH_APP_MOD_FIELD_END             = 0x40
+};
+
+struct CPH_APP_MOD_T {
+	unsigned short   proto_type;
+	unsigned short   mh;
+	bool     state;
+};
+
+/* CPH application packets forwarding field definition
+------------------------------------------------------------------------------*/
+enum CPH_APP_FRWD_FIELD_E {
+	CPH_APP_FRWD_SET_TRG_PORT     = 0x1,
+	CPH_APP_FRWD_SET_TRG_QUEUE    = 0x2,
+	CPH_APP_FRWD_SET_GEM_PORT     = 0x4,
+	CPH_APP_FRWD_FIELD_END        = 0x8
+};
+
+struct CPH_APP_FRWD_T {
+	unsigned char   trg_port;
+	unsigned char   trg_queue;
+	unsigned short  gem_port;
+};
+
+/* TPM connection profile definition from "tpm_types.h"
+------------------------------------------------------------------------------*/
+enum tpm_eth_complex_profile_t {
+	TPM_PON_WAN_DUAL_MAC_INT_SWITCH = 1,
+	TPM_PON_WAN_G0_INT_SWITCH,
+	TPM_PON_WAN_G1_LAN_G0_INT_SWITCH,
+	TPM_G0_WAN_G1_INT_SWITCH,
+	TPM_G1_WAN_G0_INT_SWITCH,
+	TPM_PON_G1_WAN_G0_INT_SWITCH,
+	TPM_PON_G0_WAN_G1_INT_SWITCH,
+	TPM_PON_WAN_DUAL_MAC_EXT_SWITCH,
+	TPM_PON_WAN_G1_MNG_EXT_SWITCH,
+	TPM_PON_WAN_G0_SINGLE_PORT,
+	TPM_PON_WAN_G1_SINGLE_PORT,
+	TPM_PON_G1_WAN_G0_SINGLE_PORT,
+	TPM_PON_G0_WAN_G1_SINGLE_PORT,
+	TPM_PON_WAN_G0_G1_LPBK,
+	TPM_PON_WAN_G0_G1_DUAL_LAN
+};
+
+/* PON type definition
+------------------------------------------------------------------------------*/
+enum CPH_PON_TYPE_E {
+	CPH_PON_TYPE_EPON = 0,
+	CPH_PON_TYPE_GPON,
+	CPH_PON_TYPE_GBE,
+	CPH_PON_TYPE_P2P,
+	CPH_PON_TYPE_MAX
+};
+
+
+/* CPH feature flag
+------------------------------------------------------------------------------*/
+enum CPH_APP_FEATURE_E {
+	CPH_APP_FEATURE_APP = 0,
+	CPH_APP_FEATURE_IGMP,
+	CPH_APP_FEATURE_BC,
+	CPH_APP_FEATURE_FLOW,
+	CPH_APP_FEATURE_UDP,
+};
+
+
+/* CPH parse/modification field definition for bc/igmp
+------------------------------------------------------------------------------*/
+struct CPH_PACKET_PARSE_T {
+	enum CPH_DIR_E      dir;
+	unsigned int         src_port;
+	unsigned short         vid;
+	unsigned char          pbits;
+	unsigned char          dscp;
+};
+
+
+struct CPH_PACKET_MOD_T {
+	enum CPH_DIR_E      dir;
+	unsigned int         src_port;
+	unsigned short         vid;
+	unsigned char          pbits;
+	unsigned char          dscp;
+};
+
+/* GMAC port state definition
+------------------------------------------------------------------------------*/
+struct CPH_PORT_STATE_T {
+	enum MV_APP_PORT_TYPE_E   port_type;
+	enum MV_GE_PORT_STATE_E   port_state;
+};
+
+/* Debug related definition
+------------------------------------------------------------------------------*/
+extern unsigned int g_cph_global_trace;
+
+#define CPH_GLOBAL_TRACE g_cph_global_trace
+#define CPH_DEBUG_LEVEL  0x00000001
+#define CPH_INFO_LEVEL   0x00000002
+#define CPH_WARN_LEVEL   0x00000004
+#define CPH_ERR_LEVEL    0x00000008
+
+#define MV_CPH_PRINT(level, format, ...) \
+	{ \
+		if (level & CPH_GLOBAL_TRACE) \
+			pr_info("%s(line:%d) "format, __func__, __LINE__, ##__VA_ARGS__); \
+	}
+
+#define MV_CPH_CLEAN_PRINT(level, format, ...) \
+	{ \
+		if (level & CPH_GLOBAL_TRACE) \
+			pr_info(format, ##__VA_ARGS__); \
+	}
+
+/******************************************************************************
+ * Function Declaration
+ ******************************************************************************/
+/******************************************************************************
+* cph_app_set_complex_profile()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Set TPM complex profile ID
+*
+* INPUTS:
+*       profile_id   - TPM complex profile ID
+*       active_port  - Active WAN port
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_app_set_complex_profile(enum tpm_eth_complex_profile_t profile_id, enum MV_APP_GMAC_PORT_E active_port);
+
+/******************************************************************************
+* cph_app_set_feature_flag()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Enable or disable feature support in CPH
+*
+* INPUTS:
+*       feature - CPH supported features
+*       state   - Enable or disable this feature in CPH
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_app_set_feature_flag(enum CPH_APP_FEATURE_E feature, bool state);
+
+/******************************************************************************
+* cph_app_add_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Add CPH rule
+*
+* INPUTS:
+*       parse_bm   - Parsing bitmap
+*       parse_key  - Parsing key
+*       mod_bm     - Modification bitmap
+*       mod_value  - Modification value
+*       frwd_bm    - Forwarding bitmap
+*       frwd_value - Forwarding value
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_app_add_rule(
+	enum CPH_APP_PARSE_FIELD_E parse_bm,
+	struct CPH_APP_PARSE_T      *parse_key,
+	enum CPH_APP_MOD_FIELD_E   mod_bm,
+	struct CPH_APP_MOD_T        *mod_value,
+	enum CPH_APP_FRWD_FIELD_E  frwd_bm,
+	struct CPH_APP_FRWD_T       *frwd_value);
+
+/******************************************************************************
+* cph_app_del_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Del CPH rule
+*
+* INPUTS:
+*       parse_bm   - Parsing bitmap
+*       parse_key  - Parsing key
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_app_del_rule(
+	enum CPH_APP_PARSE_FIELD_E parse_bm,
+	struct CPH_APP_PARSE_T      *parse_key);
+
+/******************************************************************************
+* cph_app_update_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Update CPH rule
+*
+* INPUTS:
+*       parse_bm   - Parsing bitmap
+*       parse_key  - Parsing key
+*       mod_bm     - Modification bitmap
+*       mod_value  - Modification value
+*       frwd_bm    - Forwarding bitmap
+*       frwd_value - Forwarding value
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_app_update_rule(
+	enum CPH_APP_PARSE_FIELD_E parse_bm,
+	struct CPH_APP_PARSE_T      *parse_key,
+	enum CPH_APP_MOD_FIELD_E   mod_bm,
+	struct CPH_APP_MOD_T        *mod_value,
+	enum CPH_APP_FRWD_FIELD_E  frwd_bm,
+	struct CPH_APP_FRWD_T       *frwd_value);
+
+/******************************************************************************
+* cph_app_get_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Get CPH rule
+*
+* INPUTS:
+*       parse_bm   - Parsing bitmap
+*       parse_key  - Parsing key
+*
+* OUTPUTS:
+*       mod_bm     - Modification bitmap
+*       mod_value  - Modification value
+*       frwd_bm    - Forwarding bitmap
+*       frwd_value - Forwarding value
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_app_get_rule(
+	enum CPH_APP_PARSE_FIELD_E parse_bm,
+	struct CPH_APP_PARSE_T      *parse_key,
+	enum CPH_APP_MOD_FIELD_E  *mod_bm,
+	struct CPH_APP_MOD_T        *mod_value,
+	enum CPH_APP_FRWD_FIELD_E *frwd_bm,
+	struct CPH_APP_FRWD_T       *frwd_value);
+
+/******************************************************************************
+* cph_app_get_rule_by_dir_proto()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Get CPH rule according to protocol type
+*
+* INPUTS:
+*       dir        - Direction
+*       proto_type - SKB protocol type
+*
+* OUTPUTS:
+*       parse_bm   - Parsing bitmap
+*       parse_key  - Parsing key
+*       mod_bm     - Modification bitmap
+*       mod_value  - Modification value
+*       frwd_bm    - Forwarding bitmap
+*       frwd_value - Forwarding value
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_app_get_rule_by_dir_proto(
+	enum CPH_DIR_E              dir,
+	unsigned short                 proto_type,
+	enum CPH_APP_PARSE_FIELD_E *parse_bm,
+	struct CPH_APP_PARSE_T       *parse_key,
+	enum CPH_APP_MOD_FIELD_E   *mod_bm,
+	struct CPH_APP_MOD_T         *mod_value,
+	enum CPH_APP_FRWD_FIELD_E  *frwd_bm,
+	struct CPH_APP_FRWD_T        *frwd_value);
+
+/******************************************************************************
+* cph_app_increase_counter()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Increase RX counter
+*
+* INPUTS:
+*       parse_bm   - Parsing bitmap
+*       parse_key  - Parsing key
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_app_increase_counter(
+	enum CPH_APP_PARSE_FIELD_E parse_bm,
+	struct CPH_APP_PARSE_T      *parse_key);
+
+/******************************************************************************
+* cph_app_increase_counter_by_dir_proto()
+* _____________________________________________________________________________
+*
+* DESCRIPTION:  Increase RX counter according to protocol type
+*
+* INPUTS:
+*       dir        - Direction
+*       proto_type - SKB protocol type
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_app_increase_counter_by_dir_proto(
+	enum CPH_DIR_E dir,
+	unsigned short    proto_type);
+
+/******************************************************************************
+* cph_app_parse_ge_port_type()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Get GEMAC port type by profile ID
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       port_type   - Modification bitmap
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_app_parse_ge_port_type(struct CPH_PORT_STATE_T *port_type);
+
+/******************************************************************************
+* cph_app_parse_dir()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Parse application packet to output parse bitmap and value
+*
+* INPUTS:
+*       port  - GE MAC port
+*       rx    - Whether RX path
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       Return direction.
+*******************************************************************************/
+enum CPH_DIR_E cph_app_parse_dir(
+	int    port,
+	bool     rx);
+
+/******************************************************************************
+* cph_app_parse_packet()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Parse application packet to output parse bitmap and value
+*
+* INPUTS:
+*       port       - GE MAC port
+*       skb_data   - Pointer to SKB data holding application packet
+*
+* OUTPUTS:
+*       parse_bm   - Parsing bitmap
+*       parse_key  - Parsing key
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_app_parse_packet(
+	int                  port,
+	unsigned char                 *skb_data,
+	enum CPH_APP_PARSE_FIELD_E *parse_bm,
+	struct CPH_APP_PARSE_T       *parse_key);
+
+/******************************************************************************
+* cph_app_mod_rx_packet()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Modify RX application packet
+*
+* INPUTS:
+*       port      - Gmac port the packet from
+*       dev       - Net device
+*       skb       - SKB buffer to receive packet
+*       rx_desc   - RX descriptor
+*       mod_bm    - Modification bitmap
+*       mod_value - Modification value
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_app_mod_rx_packet(
+	int                port,
+	struct net_device   *dev,
+	struct sk_buff      *skb,
+	struct pp2_rx_desc  *rx_desc,
+	enum CPH_APP_MOD_FIELD_E  mod_bm,
+	struct CPH_APP_MOD_T       *mod_value);
+
+/******************************************************************************
+* cph_app_mod_tx_packet()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Modify TX application packet
+*
+* INPUTS:
+*       skb         - Pointer to SKB data hoding application packet
+*       tx_spec_out - TX descriptor
+*       mod_bm      - Modification bitmap
+*       mod_value   - Modification value
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_app_mod_tx_packet(
+	struct sk_buff        *skb,
+	struct mv_eth_tx_spec *tx_spec_out,
+	enum CPH_APP_MOD_FIELD_E    mod_bm,
+	struct CPH_APP_MOD_T         *mod_value);
+
+/******************************************************************************
+* cph_app_set_frwd()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Set packet forwarding information
+*
+* INPUTS:
+*       skb         - Pointer to SKB data hoding application packet
+*       tx_spec_out - TX descriptor
+*       frwd_bm     - Forwarding bitmap
+*       frwd_value  - Forwarding value
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_app_set_frwd(
+	struct sk_buff        *skb,
+	struct mv_eth_tx_spec *tx_spec_out,
+	enum CPH_APP_FRWD_FIELD_E   frwd_bm,
+	struct CPH_APP_FRWD_T        *frwd_value);
+
+/******************************************************************************
+* cph_app_rx_bc()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: CPH function to handle the received broadcast packets
+*
+* INPUTS:
+*       port    - Gmac port the packet from
+*       dev     - Net device
+*       skb     - Marvell packet information
+*       rx_desc - RX descriptor
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns 1.
+*       On error returns 0.
+*******************************************************************************/
+int cph_app_rx_bc(int port, struct net_device *dev, struct sk_buff *skb, struct pp2_rx_desc *rx_desc);
+
+/******************************************************************************
+* cph_app_lookup_profile_id()
+*
+* DESCRIPTION:lookup profile ID string according to value
+*
+* INPUTS:
+*       enum_value - The enum value to be matched
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       Enum string
+*******************************************************************************/
+char *cph_app_lookup_profile_id(int enum_value);
+
+/******************************************************************************
+* cph_app_lookup_pon_type()
+*
+* DESCRIPTION:lookup PON type string according to value
+*
+* INPUTS:
+*       enum_value - The enum value to be matched
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       Enum string
+*******************************************************************************/
+char *cph_app_lookup_pon_type(int enum_value);
+
+/******************************************************************************
+* cph_app_lookup_dir()
+*
+* DESCRIPTION:lookup direction string according to value
+*
+* INPUTS:
+*       enum_value - The enum value to be matched
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       Enum string
+*******************************************************************************/
+char *cph_app_lookup_dir(int enum_value);
+
+/******************************************************************************
+* cph_app_lookup_rx_tx()
+* _____________________________________________________________________________
+*
+* DESCRIPTION:lookup RX/TX direction string according to value
+*
+* INPUTS:
+*       enum_value - The enum value to be matched
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       Enum string
+*******************************************************************************/
+char *cph_app_lookup_rx_tx(int enum_value);
+
+/******************************************************************************
+* cph_app_lookup_gmac()
+* _____________________________________________________________________________
+*
+* DESCRIPTION:lookup GMAC string according to value
+*
+* INPUTS:
+*       enum_value - The enum value to be matched
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       Enum string
+*******************************************************************************/
+char *cph_app_lookup_gmac(int enum_value);
+
+/******************************************************************************
+* cph_app_init()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Initializes CPH application module.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int  cph_app_init(void);
+
+/******************************************************************************
+* cph_set_trace_flag()
+* _____________________________________________________________________________
+*
+* DESCRIPTION:sets cph trace flag.
+*
+* INPUTS:
+*       enum_value - The enum value to be matched
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_set_trace_flag(unsigned int flag);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _MV_CPH_APP_H_ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_db.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_db.c
new file mode 100644
index 0000000..9e15e07
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_db.c
@@ -0,0 +1,1299 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+	*   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+	*   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+	*   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+********************************************************************************
+* mv_cph_db.c
+*
+* DESCRIPTION: Marvell CPH(CPH Packet Handler) data base implementation
+*
+* DEPENDENCIES:
+*               None
+*
+* CREATED BY:   VictorGu
+*
+* DATE CREATED: 22Jan2013
+*
+* FILE REVISION NUMBER:
+*               Revision: 1.0
+*
+*
+*******************************************************************************/
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/mutex.h>
+#include <linux/spinlock.h>
+#include <linux/poll.h>
+#include <linux/clk.h>
+#include <linux/fs.h>
+#include <linux/vmalloc.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+
+#include "mv_cph_header.h"
+/*#include "ezxml.h"*/
+
+
+/******************************************************************************
+* Variable Definition
+******************************************************************************/
+static struct CPH_APP_DB_T g_cph_app_db;
+char *g_cph_xml_cfg_file         = US_CPH_XML_CFG_FILE;
+char *g_onu_profile_xml_cfg_file = US_ONU_PROFILE_XML_CFG_FILE;
+
+/******************************************************************************
+* Function Definition
+******************************************************************************/
+/******************************************************************************
+* cph_db_set_param()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Set CPH DB parameter
+*
+* INPUTS:
+*       param   - The parameter type
+*       value   - Parameter value
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_db_set_param(enum CPH_DB_PARAM_E param, void *value)
+{
+	MV_STATUS rc = MV_OK;
+
+	switch (param) {
+	case CPH_DB_PARAM_PROFILE_ID:
+		g_cph_app_db.profile_id   = *(enum tpm_eth_complex_profile_t *)value;
+		break;
+	case CPH_DB_PARAM_ACTIVE_PORT:
+		g_cph_app_db.active_port  = *(enum MV_APP_GMAC_PORT_E *)value;
+		break;
+	case CPH_DB_PARAM_APP_SUPPORT:
+		g_cph_app_db.app_support  = *(bool *)value;
+		break;
+	case CPH_DB_PARAM_IGMP_SUPPORT:
+		g_cph_app_db.igmp_support = *(bool *)value;
+		break;
+	case CPH_DB_PARAM_BC_SUPPORT:
+		g_cph_app_db.bc_support   = *(bool *)value;
+		break;
+	case CPH_DB_PARAM_FLOW_SUPPORT:
+		g_cph_app_db.flow_support = *(bool *)value;
+		break;
+	case CPH_DB_PARAM_UDP_SUPPORT:
+		g_cph_app_db.udp_support  = *(bool *)value;
+		break;
+	case CPH_DB_PARAM_BC_COUNTER:
+		g_cph_app_db.bc_count     = *(unsigned int *)value;
+		break;
+	default:
+		break;
+	}
+
+	return rc;
+}
+
+/******************************************************************************
+* cph_db_get_param()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Get CPH DB parameter
+*
+* INPUTS:
+*       param   - The parameter type
+*
+* OUTPUTS:
+*       value   - Parameter value
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_db_get_param(enum CPH_DB_PARAM_E param, void *value)
+{
+	MV_STATUS rc = MV_OK;
+
+	switch (param) {
+	case CPH_DB_PARAM_PROFILE_ID:
+		*(enum tpm_eth_complex_profile_t *)value = g_cph_app_db.profile_id;
+		break;
+	case CPH_DB_PARAM_ACTIVE_PORT:
+		*(enum MV_APP_GMAC_PORT_E *)value = g_cph_app_db.active_port;
+		break;
+	case CPH_DB_PARAM_APP_SUPPORT:
+		*(bool *)value = g_cph_app_db.app_support;
+		break;
+	case CPH_DB_PARAM_IGMP_SUPPORT:
+		*(bool *)value = g_cph_app_db.igmp_support;
+		break;
+	case CPH_DB_PARAM_BC_SUPPORT:
+		*(bool *)value = g_cph_app_db.bc_support;
+		break;
+	case CPH_DB_PARAM_FLOW_SUPPORT:
+		*(bool *)value = g_cph_app_db.flow_support;
+		break;
+	case CPH_DB_PARAM_UDP_SUPPORT:
+		*(bool *)value = g_cph_app_db.udp_support;
+		break;
+	case CPH_DB_PARAM_BC_COUNTER:
+		*(unsigned int *)value = g_cph_app_db.bc_count;
+		break;
+	default:
+		break;
+	}
+	return rc;
+}
+
+/******************************************************************************
+* cph_db_compare_rules()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Compare the parse_bm and parse_key of two rules
+*
+* INPUTS:
+*       parse_bm_1   - Parsing bitmap of first CPH rule
+*       parse_key_1  - Parsing key of first CPH rule
+*       parse_bm_2   - Parsing bitmap of second CPH rule
+*       parse_key_2  - Parsing key of second CPH rule
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       In case same, return TRUE,
+*       In case different, return FALSE.
+*******************************************************************************/
+bool cph_db_compare_rules(
+	enum CPH_APP_PARSE_FIELD_E parse_bm_1,
+	struct CPH_APP_PARSE_T      *parse_key_1,
+	enum CPH_APP_PARSE_FIELD_E parse_bm_2,
+	struct CPH_APP_PARSE_T      *parse_key_2)
+{
+	if (parse_bm_1 == parse_bm_2) {
+		/* Compare direction */
+		if (parse_bm_1 & CPH_APP_PARSE_FIELD_DIR) {
+			if (parse_key_1->dir != parse_key_2->dir) {
+				MV_CPH_PRINT(CPH_DEBUG_LEVEL, "Old dir[%d], new dir[%d]\n",
+						parse_key_1->dir, parse_key_2->dir);
+				return FALSE;
+			}
+		}
+
+		/* Compare RX direction */
+		if (parse_bm_1 & CPH_APP_PARSE_FIELD_RX_TX) {
+			if (parse_key_1->rx_tx != parse_key_2->rx_tx) {
+				MV_CPH_PRINT(CPH_DEBUG_LEVEL, "Old rx_tx[%d], new rx_tx[%d]\n",
+						parse_key_1->rx_tx, parse_key_2->rx_tx);
+				return FALSE;
+			}
+		}
+
+		/* Compare Marvell header */
+		if (parse_bm_1 & CPH_APP_PARSE_FIELD_MH) {
+			if (parse_key_1->mh != parse_key_2->mh) {
+				MV_CPH_PRINT(CPH_DEBUG_LEVEL, "Old mh[%d], new mh[%d]\n",
+						parse_key_1->mh, parse_key_2->mh);
+				return FALSE;
+			}
+		}
+
+		/* Compare Eth type */
+		if (parse_bm_1 & CPH_APP_PARSE_FIELD_ETH_TYPE) {
+			if (parse_key_1->eth_type != parse_key_2->eth_type) {
+				MV_CPH_PRINT(CPH_DEBUG_LEVEL, "Old eth_type[%d], new eth_type[%d]\n",
+						parse_key_1->eth_type, parse_key_2->eth_type);
+				return FALSE;
+			}
+		}
+
+		/* Compare Eth subtype */
+		if (parse_bm_1 & CPH_APP_PARSE_FIELD_ETH_SUBTYPE) {
+			if (parse_key_1->eth_subtype != parse_key_2->eth_subtype) {
+				MV_CPH_PRINT(CPH_DEBUG_LEVEL, "Old eth_subtype[%d], new eth_subtype[%d]\n",
+						parse_key_1->eth_subtype, parse_key_2->eth_subtype);
+				return FALSE;
+			}
+		}
+
+		/* Compare IPV4 type */
+		if (parse_bm_1 & CPH_APP_PARSE_FIELD_IPV4_TYPE) {
+			if (parse_key_1->ipv4_type != parse_key_2->ipv4_type) {
+				MV_CPH_PRINT(CPH_DEBUG_LEVEL, "Old ipv4_type[%d], new ipv4_type[%d]\n",
+						parse_key_1->ipv4_type, parse_key_2->ipv4_type);
+				return FALSE;
+			}
+		}
+
+		/* Compare IPV6 type */
+		if (parse_bm_1 & CPH_APP_PARSE_FIELD_IPV6_NH1) {
+			if (parse_key_1->ipv6_nh1 != parse_key_2->ipv6_nh1) {
+				MV_CPH_PRINT(CPH_DEBUG_LEVEL, "Old ipv6_nh1[%d], new ipv6_nh1[%d]\n",
+						parse_key_1->ipv6_nh1, parse_key_2->ipv6_nh1);
+				return FALSE;
+			}
+		}
+
+		/* Compare IPv6 NH */
+		if (parse_bm_1 & CPH_APP_PARSE_FIELD_IPV6_NH2) {
+			if (parse_key_1->ipv6_nh2 != parse_key_2->ipv6_nh2) {
+				MV_CPH_PRINT(CPH_DEBUG_LEVEL, "Old ipv6_nh2[%d], new ipv6_nh2[%d]\n",
+						parse_key_1->ipv6_nh2, parse_key_2->ipv6_nh2);
+				return FALSE;
+			}
+		}
+
+		/* Compare ICMPv6 type */
+		if (parse_bm_1 & CPH_APP_PARSE_FIELD_ICMPV6_TYPE) {
+			if (parse_key_1->icmpv6_type != parse_key_2->icmpv6_type) {
+				MV_CPH_PRINT(CPH_DEBUG_LEVEL, "Old icmpv6_type[%d], new icmpv6_type[%d]\n",
+						parse_key_1->icmpv6_type, parse_key_2->icmpv6_type);
+				return FALSE;
+			}
+		}
+		return TRUE;
+	} else {
+		return FALSE;
+	}
+}
+
+/******************************************************************************
+* cph_db_compare_rule_and_packet()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Compare the parse_bm and parse_key of CPH and the packet
+*
+* INPUTS:
+*       parse_bm_rule     - Parsing bitmap of CPH rule
+*       parse_key_rule    - Parsing key of CPH rule
+*       parse_bm_packet   - Parsing bitmap of packet
+*       parse_key_packet  - Parsing key of packet
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       In case same, return TRUE,
+*       In case different, return FALSE.
+*******************************************************************************/
+bool cph_db_compare_rule_and_packet(
+	enum CPH_APP_PARSE_FIELD_E parse_bm_rule,
+	struct CPH_APP_PARSE_T      *parse_key_rule,
+	enum CPH_APP_PARSE_FIELD_E parse_bm_packet,
+	struct CPH_APP_PARSE_T      *parse_key_packet)
+{
+	/* Check direction */
+	if (parse_bm_rule & CPH_APP_PARSE_FIELD_DIR) {
+		if (parse_key_rule->dir != CPH_DIR_NOT_CARE) {
+			if (!(parse_bm_packet & CPH_APP_PARSE_FIELD_DIR)) {
+				MV_CPH_PRINT(CPH_DEBUG_LEVEL, "Packet has no dir field\n");
+				return FALSE;
+			}
+
+			if (parse_key_rule->dir != parse_key_packet->dir) {
+				MV_CPH_PRINT(CPH_DEBUG_LEVEL,
+						"Packet dir[%d] is different with rule dir[%d], mis-mathced!\n",
+						parse_key_packet->dir, parse_key_rule->dir);
+				return FALSE;
+			}
+		}
+	}
+
+	/* Check RX/TX direction */
+	if (parse_bm_rule & CPH_APP_PARSE_FIELD_RX_TX) {
+		if (parse_key_rule->rx_tx != CPH_RX_TX_NOT_CARE) {
+			if (!(parse_bm_packet & CPH_APP_PARSE_FIELD_RX_TX)) {
+				MV_CPH_PRINT(CPH_DEBUG_LEVEL, "Packet has no dir RX/TX field\n");
+				return FALSE;
+			}
+
+			if (parse_key_rule->rx_tx != parse_key_packet->rx_tx) {
+				MV_CPH_PRINT(CPH_DEBUG_LEVEL,
+					"Packet rx_tx[%d] is different with rule rx_tx[%d], mis-mathced!\n",
+					parse_key_packet->rx_tx, parse_key_rule->rx_tx);
+				return FALSE;
+			}
+		}
+	}
+
+	/* Check Marvell header */
+	if (parse_bm_rule & CPH_APP_PARSE_FIELD_MH) {
+		if (!(parse_bm_packet & CPH_APP_PARSE_FIELD_MH)) {
+			MV_CPH_PRINT(CPH_DEBUG_LEVEL, "Packet has no MH field\n");
+			return FALSE;
+		}
+
+		if (parse_key_rule->mh != parse_key_packet->mh) {
+			MV_CPH_PRINT(CPH_DEBUG_LEVEL, "Packet mh[0x%x] is different with rule mh[0x%x], mis-mathced!\n",
+					parse_key_packet->mh, parse_key_rule->mh);
+			return FALSE;
+		}
+	}
+
+	/* Check Eth type */
+	if (parse_bm_rule & CPH_APP_PARSE_FIELD_ETH_TYPE) {
+		if (!(parse_bm_packet & CPH_APP_PARSE_FIELD_ETH_TYPE)) {
+			MV_CPH_PRINT(CPH_DEBUG_LEVEL, "Packet has no eth_type field\n");
+			return FALSE;
+		}
+
+		if (parse_key_rule->eth_type != parse_key_packet->eth_type) {
+			MV_CPH_PRINT(CPH_DEBUG_LEVEL,
+				"Packet eth_type[0x%x] is different with rule eth_type[0x%x], mis-mathced!\n",
+				parse_key_packet->eth_type, parse_key_rule->eth_type);
+			return FALSE;
+		}
+	}
+
+	/* Check Eth subtype */
+	if (parse_bm_rule & CPH_APP_PARSE_FIELD_ETH_SUBTYPE) {
+		if (!(parse_bm_packet & CPH_APP_PARSE_FIELD_ETH_SUBTYPE)) {
+			MV_CPH_PRINT(CPH_DEBUG_LEVEL, "Packet has no eth_subtype field\n");
+			return FALSE;
+		}
+
+		if (parse_key_rule->eth_subtype != parse_key_packet->eth_subtype) {
+			MV_CPH_PRINT(CPH_DEBUG_LEVEL,
+				"Packet eth_subtype[%d] is different with rule eth_subtype[%d], mis-mathced!\n",
+				parse_key_packet->eth_subtype, parse_key_rule->eth_subtype);
+			return FALSE;
+		}
+	}
+
+	/* Check IPV4 type */
+	if (parse_bm_rule & CPH_APP_PARSE_FIELD_IPV4_TYPE) {
+		if (!(parse_bm_packet & CPH_APP_PARSE_FIELD_IPV4_TYPE)) {
+			MV_CPH_PRINT(CPH_DEBUG_LEVEL, "Packet has no ipv4_type field\n");
+			return FALSE;
+		}
+
+		if (parse_key_rule->ipv4_type != parse_key_packet->ipv4_type) {
+			MV_CPH_PRINT(CPH_DEBUG_LEVEL,
+				"Packet ipv4_type[%d] is different with rule ipv4_type[%d], mis-mathced!\n",
+				parse_key_packet->ipv4_type, parse_key_rule->ipv4_type);
+			return FALSE;
+		}
+	}
+
+	/* Check IPV6 NH1 */
+	if (parse_bm_rule & CPH_APP_PARSE_FIELD_IPV6_NH1) {
+		if (!(parse_bm_packet & CPH_APP_PARSE_FIELD_IPV6_NH1)) {
+			MV_CPH_PRINT(CPH_DEBUG_LEVEL, "Packet has no ipv6_nh1 field\n");
+			return FALSE;
+		}
+
+		if (parse_key_rule->ipv6_nh1 != parse_key_packet->ipv6_nh1) {
+			MV_CPH_PRINT(CPH_DEBUG_LEVEL,
+				"Packet ipv6_nh1[%d] is different with rule ipv6_nh1[%d], mis-mathced!\n",
+				parse_key_packet->ipv6_nh1, parse_key_rule->ipv6_nh1);
+			return FALSE;
+		}
+	}
+
+	/* Check IPv6 NH2 */
+	if (parse_bm_rule & CPH_APP_PARSE_FIELD_IPV6_NH2) {
+		if (!(parse_bm_packet & CPH_APP_PARSE_FIELD_IPV6_NH2)) {
+			MV_CPH_PRINT(CPH_DEBUG_LEVEL, "Packet has no ipv6_nh2 field\n");
+			return FALSE;
+		}
+
+		if (parse_key_rule->ipv6_nh2 != parse_key_packet->ipv6_nh2) {
+			MV_CPH_PRINT(CPH_DEBUG_LEVEL,
+				"Packet ipv6_nh2[%d] is different with rule ipv6_nh2[%d], mis-mathced!\n",
+				parse_key_packet->ipv6_nh2, parse_key_rule->ipv6_nh2);
+			return FALSE;
+		}
+	}
+
+	/* Check ICMPv6 type */
+	if (parse_bm_rule & CPH_APP_PARSE_FIELD_ICMPV6_TYPE) {
+		if (!(parse_bm_packet & CPH_APP_PARSE_FIELD_ICMPV6_TYPE)) {
+			MV_CPH_PRINT(CPH_DEBUG_LEVEL, "Packet has no icmpv6_type field\n");
+			return FALSE;
+		}
+
+		if (parse_key_rule->icmpv6_type != parse_key_packet->icmpv6_type) {
+			MV_CPH_PRINT(CPH_DEBUG_LEVEL,
+				"Packet icmpv6_type[%d] is different with rule icmpv6_type[%d], mis-mathced!\n",
+				parse_key_packet->icmpv6_type, parse_key_rule->icmpv6_type);
+			return FALSE;
+		}
+	}
+
+	return TRUE;
+}
+
+/******************************************************************************
+* cph_db_check_duplicate_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Check whether there is duplicate CPH rule w/ same parse bitmap
+*              value
+*
+* INPUTS:
+*       parse_bm   - Parsing bitmap
+*       parse_key  - Parsing key
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       In case has duplicated rule, return TRUE,
+*       In case has not duplicated rule, return FALSE.
+*******************************************************************************/
+bool cph_db_check_duplicate_rule(
+	enum CPH_APP_PARSE_FIELD_E parse_bm,
+	struct CPH_APP_PARSE_T      *parse_key)
+{
+	unsigned int           idx         = 0;
+	unsigned int           rule_idx    = 0;
+	struct CPH_APP_RULE_T  *p_cph_rule  = NULL;
+	bool             rc          = FALSE;
+
+	for (idx = 0, rule_idx = 0; (idx < CPH_APP_MAX_RULE_NUM) && (rule_idx < g_cph_app_db.rule_num); idx++) {
+		p_cph_rule = &g_cph_app_db.cph_rule[idx];
+
+		/* Compare parse_bm and parse_key */
+		if (p_cph_rule->valid == TRUE) {
+			rule_idx++;
+
+			rc = cph_db_compare_rules(p_cph_rule->parse_bm, &p_cph_rule->parse_key, parse_bm, parse_key);
+			if (rc == TRUE)
+				return rc;
+		}
+	}
+
+	return rc;
+}
+
+/******************************************************************************
+* cph_db_add_app_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Add application type CPH rule to data base
+*
+* INPUTS:
+*       parse_bm   - Parsing bitmap
+*       parse_key  - Parsing key
+*       mod_bm     - Modification bitmap
+*       mod_value  - Modification value
+*       frwd_bm    - Forwarding bitmap
+*       frwd_value - Forwarding value
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_db_add_app_rule(
+	enum CPH_APP_PARSE_FIELD_E parse_bm,
+	struct CPH_APP_PARSE_T      *parse_key,
+	enum CPH_APP_MOD_FIELD_E   mod_bm,
+	struct CPH_APP_MOD_T        *mod_value,
+	enum CPH_APP_FRWD_FIELD_E  frwd_bm,
+	struct CPH_APP_FRWD_T       *frwd_value)
+{
+	unsigned int           idx        = 0;
+	struct CPH_APP_RULE_T  *p_cph_rule = NULL;
+	bool             rc         = TRUE;
+	unsigned long    flags;
+
+	spin_lock_irqsave(&g_cph_app_db.app_lock, flags);
+	/* Seach for an free entry */
+	for (idx = 0; idx < CPH_APP_MAX_RULE_NUM; idx++) {
+		if (g_cph_app_db.cph_rule[idx].valid == FALSE)
+			break;
+	}
+
+	/* No free entry */
+	if (idx == CPH_APP_MAX_RULE_NUM) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "No free CPH entry\n");
+		spin_unlock_irqrestore(&g_cph_app_db.app_lock, flags);
+		return MV_FULL;
+	}
+
+	/* Do not add new rule if there is already duplicated rule */
+	rc = cph_db_check_duplicate_rule(parse_bm, parse_key);
+	if (rc == TRUE) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "Already has duplicated rule, could not add new CPH rule\n");
+		spin_unlock_irqrestore(&g_cph_app_db.app_lock, flags);
+		return MV_ERROR;
+	}
+
+	/* Save CPH rule for application packet */
+	p_cph_rule = &g_cph_app_db.cph_rule[idx];
+	p_cph_rule->parse_bm = parse_bm;
+	memcpy(&p_cph_rule->parse_key,  parse_key, sizeof(struct CPH_APP_PARSE_T));
+	p_cph_rule->mod_bm   = mod_bm;
+	memcpy(&p_cph_rule->mod_value,  mod_value, sizeof(struct CPH_APP_MOD_T));
+	p_cph_rule->frwd_bm  = frwd_bm;
+	memcpy(&p_cph_rule->frwd_value, frwd_value, sizeof(struct CPH_APP_FRWD_T));
+	p_cph_rule->valid    = TRUE;
+	g_cph_app_db.rule_num++;
+
+	spin_unlock_irqrestore(&g_cph_app_db.app_lock, flags);
+	return MV_OK;
+}
+
+/******************************************************************************
+* cph_db_del_app_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Delete application type CPH rule from data base
+*
+* INPUTS:
+*       parse_bm   - Parsing bitmap
+*       parse_key  - Parsing key
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_db_del_app_rule(
+	enum CPH_APP_PARSE_FIELD_E parse_bm,
+	struct CPH_APP_PARSE_T      *parse_key)
+{
+	unsigned int           idx         = 0;
+	unsigned int           rule_idx    = 0;
+	struct CPH_APP_RULE_T  *p_cph_rule  = NULL;
+	bool             rc          = FALSE;
+	unsigned long    flags;
+
+	spin_lock_irqsave(&g_cph_app_db.app_lock, flags);
+	for (idx = 0, rule_idx = 0; (idx < CPH_APP_MAX_RULE_NUM) && (rule_idx < g_cph_app_db.rule_num); idx++) {
+		p_cph_rule = &g_cph_app_db.cph_rule[idx];
+
+		/* Compare parse_bm and parse_key */
+		if (p_cph_rule->valid == TRUE) {
+			rule_idx++;
+
+			rc = cph_db_compare_rules(p_cph_rule->parse_bm, &p_cph_rule->parse_key, parse_bm, parse_key);
+			if (rc == TRUE) {
+				memset(p_cph_rule, 0, sizeof(struct CPH_APP_RULE_T));
+				p_cph_rule->valid = FALSE;
+				g_cph_app_db.rule_num--;
+
+				spin_unlock_irqrestore(&g_cph_app_db.app_lock, flags);
+				return MV_OK;
+			}
+		}
+	}
+	spin_unlock_irqrestore(&g_cph_app_db.app_lock, flags);
+
+	return MV_OK;
+}
+
+/******************************************************************************
+* cph_db_update_app_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Update application type CPH rule from data base
+*
+* INPUTS:
+*       parse_bm   - Parsing bitmap
+*       parse_key  - Parsing key
+*       mod_bm     - Modification bitmap
+*       mod_value  - Modification value
+*       frwd_bm    - Forwarding bitmap
+*       frwd_value - Forwarding value
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_db_update_app_rule(
+	enum CPH_APP_PARSE_FIELD_E parse_bm,
+	struct CPH_APP_PARSE_T      *parse_key,
+	enum CPH_APP_MOD_FIELD_E   mod_bm,
+	struct CPH_APP_MOD_T        *mod_value,
+	enum CPH_APP_FRWD_FIELD_E  frwd_bm,
+	struct CPH_APP_FRWD_T       *frwd_value)
+{
+	unsigned int           idx         = 0;
+	unsigned int           rule_idx    = 0;
+	struct CPH_APP_RULE_T  *p_cph_rule  = NULL;
+	bool             rc          = FALSE;
+	unsigned long    flags;
+
+	spin_lock_irqsave(&g_cph_app_db.app_lock, flags);
+	for (idx = 0, rule_idx = 0; (idx < CPH_APP_MAX_RULE_NUM) && (rule_idx < g_cph_app_db.rule_num); idx++) {
+		p_cph_rule = &g_cph_app_db.cph_rule[idx];
+
+		/* Compare parse_bm and parse_key */
+		if (p_cph_rule->valid == TRUE) {
+			rule_idx++;
+
+			rc = cph_db_compare_rules(p_cph_rule->parse_bm, &p_cph_rule->parse_key, parse_bm, parse_key);
+			if (rc == TRUE) {
+				p_cph_rule->mod_bm   = mod_bm;
+				memcpy(&p_cph_rule->mod_value,  mod_value,  sizeof(struct CPH_APP_MOD_T));
+				p_cph_rule->frwd_bm  = frwd_bm;
+				memcpy(&p_cph_rule->frwd_value, frwd_value, sizeof(struct CPH_APP_FRWD_T));
+				spin_unlock_irqrestore(&g_cph_app_db.app_lock, flags);
+				return MV_OK;
+			}
+		}
+	}
+	spin_unlock_irqrestore(&g_cph_app_db.app_lock, flags);
+
+	return MV_OK;
+}
+
+/******************************************************************************
+* cph_db_get_app_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Get application type CPH rule from data base
+*
+* INPUTS:
+*       parse_bm   - Parsing bitmap
+*       parse_key  - Parsing key
+*
+* OUTPUTS:
+*       mod_bm     - Modification bitmap
+*       mod_value  - Modification value
+*       frwd_bm    - Forwarding bitmap
+*       frwd_value - Forwarding value
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_db_get_app_rule(
+	enum CPH_APP_PARSE_FIELD_E parse_bm,
+	struct CPH_APP_PARSE_T      *parse_key,
+	enum CPH_APP_MOD_FIELD_E  *mod_bm,
+	struct CPH_APP_MOD_T        *mod_value,
+	enum CPH_APP_FRWD_FIELD_E *frwd_bm,
+	struct CPH_APP_FRWD_T       *frwd_value)
+{
+	unsigned int           idx         = 0;
+	unsigned int           rule_idx    = 0;
+	struct CPH_APP_RULE_T  *p_cph_rule  = NULL;
+	bool             rc          = FALSE;
+	unsigned long    flags;
+
+	spin_lock_irqsave(&g_cph_app_db.app_lock, flags);
+	for (idx = 0, rule_idx = 0; (idx < CPH_APP_MAX_RULE_NUM) && (rule_idx < g_cph_app_db.rule_num); idx++) {
+		p_cph_rule = &g_cph_app_db.cph_rule[idx];
+
+		/* Compare parse_bm and parse_key */
+		if (p_cph_rule->valid == TRUE) {
+			rule_idx++;
+
+			rc = cph_db_compare_rule_and_packet(p_cph_rule->parse_bm,
+							    &p_cph_rule->parse_key,
+							    parse_bm,
+							    parse_key);
+			if (rc == TRUE) {
+				if (p_cph_rule->mod_value.state == TRUE) {
+					*mod_bm  = p_cph_rule->mod_bm;
+					memcpy(mod_value, &p_cph_rule->mod_value, sizeof(struct CPH_APP_MOD_T));
+					*frwd_bm = p_cph_rule->frwd_bm;
+					memcpy(frwd_value, &p_cph_rule->frwd_value, sizeof(struct CPH_APP_FRWD_T));
+
+					spin_unlock_irqrestore(&g_cph_app_db.app_lock, flags);
+					return MV_OK;
+				}
+			}
+		}
+	}
+	spin_unlock_irqrestore(&g_cph_app_db.app_lock, flags);
+
+	return MV_FAIL;
+}
+
+/******************************************************************************
+* cph_db_get_app_rule_by_dir_proto()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Get application type CPH rule from data base by protocol type
+*
+* INPUTS:
+*       dir        - Direction
+*       proto_type - SKB protocol type
+*
+* OUTPUTS:
+*       parse_bm   - Parsing bitmap
+*       parse_key  - Parsing key
+*       mod_bm     - Modification bitmap
+*       mod_value  - Modification value
+*       frwd_bm    - Forwarding bitmap
+*       frwd_value - Forwarding value
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_db_get_app_rule_by_dir_proto(
+enum CPH_DIR_E              dir,
+unsigned short                 proto_type,
+enum CPH_APP_PARSE_FIELD_E *parse_bm,
+struct CPH_APP_PARSE_T       *parse_key,
+enum CPH_APP_MOD_FIELD_E   *mod_bm,
+struct CPH_APP_MOD_T         *mod_value,
+enum CPH_APP_FRWD_FIELD_E  *frwd_bm,
+struct CPH_APP_FRWD_T        *frwd_value)
+{
+	unsigned int           idx         = 0;
+	unsigned int           rule_idx    = 0;
+	struct CPH_APP_RULE_T  *p_cph_rule  = NULL;
+	unsigned long    flags;
+
+	spin_lock_irqsave(&g_cph_app_db.app_lock, flags);
+	for (idx = 0, rule_idx = 0; (idx < CPH_APP_MAX_RULE_NUM) && (rule_idx < g_cph_app_db.rule_num); idx++) {
+		p_cph_rule = &g_cph_app_db.cph_rule[idx];
+
+		/* Compare parse_bm and parse_key */
+		if (p_cph_rule->valid == TRUE) {
+			rule_idx++;
+
+			if ((p_cph_rule->mod_bm & CPH_APP_RX_MOD_REPLACE_PROTO_TYPE) &&
+			   (p_cph_rule->mod_value.proto_type == proto_type) &&
+			   (p_cph_rule->mod_value.state      == TRUE)) {
+				if ((p_cph_rule->parse_bm & CPH_APP_PARSE_FIELD_DIR) &&
+				    ((p_cph_rule->parse_key.dir == CPH_DIR_NOT_CARE) ||
+				     (p_cph_rule->parse_key.dir == dir)) &&
+				     (p_cph_rule->parse_bm & CPH_APP_PARSE_FIELD_RX_TX) &&
+				     (p_cph_rule->parse_key.rx_tx == CPH_DIR_TX)) {
+					*parse_bm = p_cph_rule->parse_bm;
+					memcpy(parse_key, &p_cph_rule->parse_key, sizeof(struct CPH_APP_PARSE_T));
+					*mod_bm   = p_cph_rule->mod_bm;
+					memcpy(mod_value, &p_cph_rule->mod_value, sizeof(struct CPH_APP_MOD_T));
+					*frwd_bm  = p_cph_rule->frwd_bm;
+					memcpy(frwd_value, &p_cph_rule->frwd_value, sizeof(struct CPH_APP_FRWD_T));
+
+					spin_unlock_irqrestore(&g_cph_app_db.app_lock, flags);
+					return MV_OK;
+				}
+			}
+		}
+	}
+	spin_unlock_irqrestore(&g_cph_app_db.app_lock, flags);
+
+	return MV_FAIL;
+}
+
+/******************************************************************************
+* cph_db_increase_counter()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Increase RX counter
+*
+* INPUTS:
+*       parse_bm   - Parsing bitmap
+*       parse_key  - Parsing key
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_db_increase_counter(
+	enum CPH_APP_PARSE_FIELD_E parse_bm,
+	struct CPH_APP_PARSE_T      *parse_key)
+{
+	unsigned int           idx         = 0;
+	unsigned int           rule_idx    = 0;
+	struct CPH_APP_RULE_T  *p_cph_rule  = NULL;
+	bool             rc          = MV_FAIL;
+	unsigned long    flags;
+
+	spin_lock_irqsave(&g_cph_app_db.app_lock, flags);
+	for (idx = 0, rule_idx = 0; (idx < CPH_APP_MAX_RULE_NUM) && (rule_idx < g_cph_app_db.rule_num); idx++) {
+		p_cph_rule = &g_cph_app_db.cph_rule[idx];
+
+		/* Compare parse_bm and parse_key */
+		if (p_cph_rule->valid == TRUE) {
+			rule_idx++;
+
+			rc = cph_db_compare_rule_and_packet(p_cph_rule->parse_bm,
+							    &p_cph_rule->parse_key,
+							    parse_bm, parse_key);
+			if (rc == TRUE) {
+				if (p_cph_rule->mod_value.state == TRUE) {
+					p_cph_rule->count++;
+
+					spin_unlock_irqrestore(&g_cph_app_db.app_lock, flags);
+					return MV_OK;
+				}
+			}
+		}
+	}
+	spin_unlock_irqrestore(&g_cph_app_db.app_lock, flags);
+
+	return rc;
+}
+
+/******************************************************************************
+* cph_db_increase_counter_by_dir_proto()
+* _____________________________________________________________________________
+*
+* DESCRIPTION:  Increase RX counter according to protocol type
+*
+* INPUTS:
+*       dir        - Direction
+*       proto_type - SKB protocol type
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_db_increase_counter_by_dir_proto(enum CPH_DIR_E dir,
+	unsigned short    proto_type)
+{
+	unsigned int           idx         = 0;
+	unsigned int           rule_idx    = 0;
+	struct CPH_APP_RULE_T  *p_cph_rule  = NULL;
+	unsigned long    flags;
+
+	spin_lock_irqsave(&g_cph_app_db.app_lock, flags);
+	for (idx = 0, rule_idx = 0; (idx < CPH_APP_MAX_RULE_NUM) && (rule_idx < g_cph_app_db.rule_num); idx++) {
+		p_cph_rule = &g_cph_app_db.cph_rule[idx];
+
+	/* Compare dir and protocol type */
+	if (p_cph_rule->valid == TRUE) {
+		rule_idx++;
+
+		if ((p_cph_rule->mod_bm & CPH_APP_RX_MOD_REPLACE_PROTO_TYPE) &&
+		    (p_cph_rule->mod_value.proto_type == proto_type) &&
+		    (p_cph_rule->mod_value.state      == TRUE)) {
+			if ((p_cph_rule->parse_bm & CPH_APP_PARSE_FIELD_DIR) &&
+			    ((p_cph_rule->parse_key.dir == CPH_DIR_NOT_CARE) ||
+			     (p_cph_rule->parse_key.dir == dir)) &&
+			     (p_cph_rule->parse_bm & CPH_APP_PARSE_FIELD_RX_TX) &&
+			     (p_cph_rule->parse_key.rx_tx == CPH_DIR_TX)) {
+				p_cph_rule->count++;
+
+				spin_unlock_irqrestore(&g_cph_app_db.app_lock, flags);
+				return MV_OK;
+			}
+		}
+	}
+	}
+	spin_unlock_irqrestore(&g_cph_app_db.app_lock, flags);
+
+	return MV_OK;
+}
+
+/******************************************************************************
+* cph_db_get_xml_param()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Get the XML parameter
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+* COMMENTS: The routine need to finish in A0, it used to parse input file.
+*******************************************************************************/
+MV_STATUS cph_db_get_xml_param(void)
+{
+	int       rc         = MV_OK;
+
+	return rc;
+}
+
+/*******************************************************************************
+**
+** cph_db_get_tcont_state
+** ___________________________________________________________________________
+**
+** DESCRIPTION: The function get T-CONT state
+**
+** INPUTS:
+**   tcont - T-CONT
+**
+** OUTPUTS:
+**   None.
+**
+** RETURNS:
+**   state - State of T-CONT, enabled or disabled.
+**
+*******************************************************************************/
+bool cph_db_get_tcont_state(unsigned int tcont)
+{
+	/* Check tcont */
+	if (tcont >= MV_TCONT_LLID_NUM) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "tcont[%d] is illegal, should be less than [%d]\n",
+				tcont, MV_TCONT_LLID_NUM);
+		return FALSE;
+	}
+
+	return g_cph_app_db.tcont_state[tcont];
+}
+
+/*******************************************************************************
+**
+** cph_db_set_tcont_state
+** ___________________________________________________________________________
+**
+** DESCRIPTION: The function sets T-CONT state in mv_cph
+**
+** INPUTS:
+**   tcont - T-CONT
+**   state - State of T-CONT, enabled or disabled.
+**
+** OUTPUTS:
+**   None.
+**
+** RETURNS:
+**  On success, the function returns (MV_OK). On error different types are
+**  returned according to the case.
+**
+*******************************************************************************/
+MV_STATUS cph_db_set_tcont_state(unsigned int tcont, bool state)
+{
+	/* Check tcont */
+	if (tcont >= MV_TCONT_LLID_NUM) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "tcont[%d] is illegal, should be less than [%d]\n",
+				tcont, MV_TCONT_LLID_NUM);
+		return MV_FAIL;
+	}
+
+	/* Apply t-cont state to mv_cph */
+	g_cph_app_db.tcont_state[tcont] = state;
+
+	return MV_OK;
+}
+
+/******************************************************************************
+* cph_db_display_parse_field()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Display CPH rule parsing field
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_db_display_parse_field(
+	enum CPH_APP_PARSE_FIELD_E parse_bm,
+	struct CPH_APP_PARSE_T      *parse_key)
+{
+	pr_info("Parse field(0x%x): ", parse_bm);
+
+	/* Print direction */
+	if (parse_bm & CPH_APP_PARSE_FIELD_DIR)
+		pr_info("Dir(%s), ", cph_app_lookup_dir(parse_key->dir));
+
+	/* Print TX/RX direction */
+	if (parse_bm & CPH_APP_PARSE_FIELD_RX_TX)
+		pr_info("RX/TX(%s), ", cph_app_lookup_rx_tx(parse_key->rx_tx));
+
+	/* Print Marvell header */
+	if (parse_bm & CPH_APP_PARSE_FIELD_MH)
+		pr_info("MH(0x%x), ", parse_key->mh);
+
+	/* Print Eth type */
+	if (parse_bm & CPH_APP_PARSE_FIELD_ETH_TYPE)
+		pr_info("Eth type(0x%04x), ", parse_key->eth_type);
+
+	/* Print Eth subtype */
+	if (parse_bm & CPH_APP_PARSE_FIELD_ETH_SUBTYPE)
+		pr_info("Eth subtype(%d), ", parse_key->eth_subtype);
+
+	/* Print IPV4 type */
+	if (parse_bm & CPH_APP_PARSE_FIELD_IPV4_TYPE)
+		pr_info("IPv4 type(%d), ", parse_key->ipv4_type);
+
+	/* Print IPv6 NH1 */
+	if (parse_bm & CPH_APP_PARSE_FIELD_IPV6_NH1)
+		pr_info("IPv6 NH1(%d), ", parse_key->ipv6_nh1);
+
+	/* Print IPv6 NH2 */
+	if (parse_bm & CPH_APP_PARSE_FIELD_IPV6_NH2)
+		pr_info("IPv6 NH2(%d), ", parse_key->ipv6_nh2);
+
+	/* Print ICMPv6 type */
+	if (parse_bm & CPH_APP_PARSE_FIELD_ICMPV6_TYPE)
+		pr_info("ICMPv6 type(%d)", parse_key->icmpv6_type);
+
+	pr_info("\n");
+
+	return MV_OK;
+}
+
+/******************************************************************************
+* cph_db_display_mod_field()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Display CPH rule modification field
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_db_display_mod_field(
+	enum CPH_APP_MOD_FIELD_E   mod_bm,
+	struct CPH_APP_MOD_T        *mod_value)
+{
+	pr_info("Mod field(0x%x): ", mod_bm);
+
+	/* Print protocol type */
+	if (mod_bm & CPH_APP_RX_MOD_REPLACE_PROTO_TYPE)
+		pr_info("Proto type(0x%x), ", mod_value->proto_type);
+
+	pr_info("state(%s)", (mod_value->state == TRUE) ? "Enabled" : "Disabled");
+
+	pr_info("\n");
+
+	return MV_OK;
+}
+
+/******************************************************************************
+* cph_db_display_frwd_field()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Display CPH rule forwarding field
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_db_display_frwd_field(
+	enum CPH_APP_FRWD_FIELD_E  frwd_bm,
+	struct CPH_APP_FRWD_T       *frwd_value)
+{
+	pr_info("Forward field(0x%x): ", frwd_bm);
+
+	/* Print target port */
+	if (frwd_bm & CPH_APP_FRWD_SET_TRG_PORT)
+		pr_info("Target port(%d), ", frwd_value->trg_port);
+
+	/* Print target queue */
+	if (frwd_bm & CPH_APP_FRWD_SET_TRG_QUEUE)
+		pr_info("Target queue(%d), ", frwd_value->trg_queue);
+
+	/* Print GEM port */
+	if (frwd_bm & CPH_APP_FRWD_SET_GEM_PORT)
+		pr_info("Gem port(%d)", frwd_value->gem_port);
+
+	pr_info("\n");
+
+	return MV_OK;
+}
+
+
+/******************************************************************************
+* cph_db_display_all()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Display all CPH rules in data base
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_db_display_all(void)
+{
+	struct CPH_APP_RULE_T *p_cph_rule = NULL;
+	unsigned int          idx        = 0;
+	unsigned int          rule_idx   = 0;
+
+	pr_info("CPH Application Data Base, total rule number[%u]\n", g_cph_app_db.rule_num);
+	pr_info("-------------------------------------------------------\n");
+
+	pr_info("TPM complex profile: %s, active WAN: %s\n",
+		cph_app_lookup_profile_id(g_cph_app_db.profile_id),
+		cph_app_lookup_gmac(g_cph_app_db.active_port));
+
+	pr_info("Generic application handling suppport: %s\n",
+	   (g_cph_app_db.app_support == TRUE) ? "Enabled" : "Disabled");
+
+#ifdef CONFIG_MV_CPH_IGMP_HANDLE
+	pr_info("IGMP/MLD handling suppport: %s\n",
+		(g_cph_app_db.igmp_support == TRUE) ? "Enabled" : "Disabled");
+#endif
+
+#ifdef CONFIG_MV_CPH_BC_HANDLE
+	pr_info("Broadcast handling suppport: %s\n",
+		(g_cph_app_db.bc_support == TRUE) ? "Enabled" : "Disabled");
+#endif
+
+#ifdef CONFIG_MV_CPH_FLOW_MAP_HANDLE
+	pr_info("Data flow mapping/modification suppport: %s\n",
+		(g_cph_app_db.flow_support == TRUE) ? "Enabled" : "Disabled");
+#endif
+
+#ifdef CONFIG_MV_CPH_UDP_SAMPLE_HANDLE
+	pr_info("UDP port mapping suppport: %s\n",
+		(g_cph_app_db.udp_support == TRUE) ? "Enabled" : "Disabled");
+#endif
+
+	pr_info("-------------------------------------------------------\n");
+
+	pr_info("CPH total rule number: %d\n", g_cph_app_db.rule_num);
+
+	for (idx = 0, rule_idx = 0; (idx < CPH_APP_MAX_RULE_NUM) && (rule_idx < g_cph_app_db.rule_num); idx++) {
+		p_cph_rule = &g_cph_app_db.cph_rule[idx];
+		if (p_cph_rule->valid == TRUE) {
+			rule_idx++;
+
+			pr_info("CPH rule: #%d\n", rule_idx);
+			pr_info("-----------------------\n");
+			cph_db_display_parse_field(p_cph_rule->parse_bm, &p_cph_rule->parse_key);
+			cph_db_display_mod_field(p_cph_rule->mod_bm,     &p_cph_rule->mod_value);
+			cph_db_display_frwd_field(p_cph_rule->frwd_bm,   &p_cph_rule->frwd_value);
+			pr_info("Counter: %d\n\n", p_cph_rule->count);
+		}
+	}
+
+	pr_info("Mis-matched or broadcast counter: %d\n", g_cph_app_db.bc_count);
+
+	pr_info("T-CONT State\n");
+	for (idx = 0; idx < MV_TCONT_LLID_NUM; idx++)
+		pr_info("T-CONT[%d]: %s\n", idx, (g_cph_app_db.tcont_state[idx] == TRUE) ? "TRUE" : "FALSE");
+
+	return MV_OK;
+}
+
+/******************************************************************************
+* cph_db_init()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Initialize CPH data base
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_db_init(void)
+{
+	unsigned int    idx = 0;
+	MV_STATUS rc  = MV_OK;
+
+	memset(&g_cph_app_db, 0, sizeof(g_cph_app_db));
+	for (idx = 0; idx < CPH_APP_MAX_RULE_NUM; idx++)
+		g_cph_app_db.cph_rule[idx].valid = FALSE;
+
+	/* Set the default value */
+	g_cph_app_db.profile_id   = TPM_PON_WAN_DUAL_MAC_INT_SWITCH;
+	g_cph_app_db.active_port  = MV_APP_PON_MAC_PORT;
+	g_cph_app_db.app_support  = TRUE;
+	g_cph_app_db.igmp_support = FALSE;
+	g_cph_app_db.bc_support   = FALSE;
+	g_cph_app_db.flow_support = FALSE;
+	g_cph_app_db.udp_support  = FALSE;
+
+	for (idx = 0; idx < MV_TCONT_LLID_NUM; idx++)
+		g_cph_app_db.tcont_state[idx] = FALSE;
+
+	/* Init spin lock */
+	spin_lock_init(&g_cph_app_db.app_lock);
+
+	return rc;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_db.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_db.h
new file mode 100644
index 0000000..8068c33
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_db.h
@@ -0,0 +1,529 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+	*   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+	*   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+	*   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+********************************************************************************
+* mv_cph_db.h
+*
+* DESCRIPTION: Marvell CPH(CPH Packet Handler) data base implementation
+*
+* DEPENDENCIES:
+*               None
+*
+* CREATED BY:   VictorGu
+*
+* DATE CREATED: 22Jan2013
+*
+* FILE REVISION NUMBER:
+*               Revision: 1.0
+*
+*
+*******************************************************************************/
+#ifndef _MV_CPH_DB_H_
+#define _MV_CPH_DB_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/******************************************************************************
+ * Data type Definition
+ ******************************************************************************/
+#define US_CPH_XML_CFG_FILE          "/etc/xml_params/cph_xml_cfg_file.xml"
+#define US_ONU_PROFILE_XML_CFG_FILE  "/etc/xml_params/onu_profile_xml_cfg_file.xml"
+
+#define XML_PROFILE_ELM_CAPABILITY   "Capability"
+#define XML_PROFILE_ELM_ATTRIB       "attrib"
+#define XML_PROFILE_ATTR_NAME        "name"
+#define XML_PROFILE_ATTR_VALUE       "value"
+#define XML_PROFILE_NAME_PROFILE     "Complex profile"
+#define XML_PROFILE_NAME_ACTIVE_PORT "Active wan"
+
+#define XML_CPH_ELM_APP_SUPPORT      "app_support"
+#define XML_CPH_ELM_IGMP_SUPPORT     "igmp_support"
+#define XML_CPH_ELM_BC_SUPPORT       "bc_support"
+#define XML_CPH_ELM_FLOW_SUPPORT     "flow_support"
+#define XML_CPH_ELM_UDP_SUPPORT      "udp_support"
+
+
+/* CPH rule definition for application packet handling
+------------------------------------------------------------------------------*/
+struct CPH_APP_RULE_T {
+	bool                  valid;
+	enum CPH_APP_PARSE_FIELD_E parse_bm;
+	struct CPH_APP_PARSE_T       parse_key;
+	enum CPH_APP_MOD_FIELD_E   mod_bm;
+	struct CPH_APP_MOD_T         mod_value;
+	enum CPH_APP_FRWD_FIELD_E  frwd_bm;
+	struct CPH_APP_FRWD_T        frwd_value;
+	unsigned int                count;
+};
+
+/* CPH data base for application packet handling
+------------------------------------------------------------------------------*/
+#define CPH_APP_MAX_RULE_NUM  (64)
+struct CPH_APP_DB_T {
+	enum tpm_eth_complex_profile_t  profile_id;       /* Complex profile ID, see enum tpm_eth_complex_profile_t  */
+	enum MV_APP_GMAC_PORT_E         active_port;      /* Current active WAN GE port, see enum MV_APP_GMAC_PORT_E */
+	bool                       app_support;      /* Whether support generic application handling       */
+	bool                       igmp_support;     /* Whether support IGMP/MLD packet handling           */
+	bool                       bc_support;       /* Whether support U/S broadcast packet handling      */
+	bool                       flow_support;     /* Whether support flow mapping handling in CPH       */
+	bool                       udp_support;      /* Whether support UDP port mapping in CPH            */
+	unsigned int                     rule_num;         /* Current application rule number                    */
+	struct CPH_APP_RULE_T             cph_rule[CPH_APP_MAX_RULE_NUM]; /* CPH application rules                */
+	spinlock_t                 app_lock;         /* Spin lock for application rule operation           */
+	unsigned int                     bc_count;         /* Counter for mis-matched packets, usually is bc     */
+	bool                       tcont_state[MV_TCONT_LLID_NUM];/* T-CONT state used to control SWF      */
+};
+
+/* CPH database parameter enum
+------------------------------------------------------------------------------*/
+enum CPH_DB_PARAM_E {
+	CPH_DB_PARAM_PROFILE_ID = 0,
+	CPH_DB_PARAM_ACTIVE_PORT,
+	CPH_DB_PARAM_APP_SUPPORT,
+	CPH_DB_PARAM_IGMP_SUPPORT,
+	CPH_DB_PARAM_BC_SUPPORT,
+	CPH_DB_PARAM_FLOW_SUPPORT,
+	CPH_DB_PARAM_UDP_SUPPORT,
+	CPH_DB_PARAM_BC_COUNTER
+};
+
+/******************************************************************************
+* Function Declaration
+******************************************************************************/
+/******************************************************************************
+* cph_db_set_param()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Set CPH DB parameter
+*
+* INPUTS:
+*       param   - The parameter type
+*       value   - Parameter value
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_db_set_param(enum CPH_DB_PARAM_E param, void *value);
+
+/******************************************************************************
+* cph_db_get_param()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Get CPH DB parameter
+*
+* INPUTS:
+*       param   - The parameter type
+*
+* OUTPUTS:
+*       value   - Parameter value
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_db_get_param(enum CPH_DB_PARAM_E param, void *value);
+
+/******************************************************************************
+* cph_db_add_app_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Add CPH rule
+*
+* INPUTS:
+*       parse_bm   - Parsing bitmap
+*       parse_key  - Parsing key
+*       mod_bm     - Modification bitmap
+*       mod_value  - Modification value
+*       frwd_bm    - Forwarding bitmap
+*       frwd_value - Forwarding value
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_db_add_app_rule(
+	enum CPH_APP_PARSE_FIELD_E parse_bm,
+	struct CPH_APP_PARSE_T      *parse_key,
+	enum CPH_APP_MOD_FIELD_E   mod_bm,
+	struct CPH_APP_MOD_T        *mod_value,
+	enum CPH_APP_FRWD_FIELD_E  frwd_bm,
+	struct CPH_APP_FRWD_T       *frwd_value);
+
+/******************************************************************************
+* cph_db_del_app_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Deletes CPH rule
+*
+* INPUTS:
+*       parse_bm   - Parsing bitmap
+*       parse_key  - Parsing key
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_db_del_app_rule(
+	enum CPH_APP_PARSE_FIELD_E parse_bm,
+	struct CPH_APP_PARSE_T      *parse_key);
+
+/******************************************************************************
+* cph_db_update_app_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Update CPH rule
+*
+* INPUTS:
+*       parse_bm   - Parsing bitmap
+*       parse_key  - Parsing key
+*       mod_bm     - Modification bitmap
+*       mod_value  - Modification value
+*       frwd_bm    - Forwarding bitmap
+*       frwd_value - Forwarding value
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_db_update_app_rule(
+	enum CPH_APP_PARSE_FIELD_E parse_bm,
+	struct CPH_APP_PARSE_T      *parse_key,
+	enum CPH_APP_MOD_FIELD_E   mod_bm,
+	struct CPH_APP_MOD_T        *mod_value,
+	enum CPH_APP_FRWD_FIELD_E  frwd_bm,
+	struct CPH_APP_FRWD_T       *frwd_value);
+
+/******************************************************************************
+* cph_db_get_app_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Get CPH rule
+*
+* INPUTS:
+*       parse_bm   - Parsing bitmap
+*       parse_key  - Parsing key
+*
+* OUTPUTS:
+*       mod_bm     - Modification bitmap
+*       mod_value  - Modification value
+*       frwd_bm    - Forwarding bitmap
+*       frwd_value - Forwarding value
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_db_get_app_rule(
+	enum CPH_APP_PARSE_FIELD_E parse_bm,
+	struct CPH_APP_PARSE_T      *parse_key,
+	enum CPH_APP_MOD_FIELD_E  *mod_bm,
+	struct CPH_APP_MOD_T        *mod_value,
+	enum CPH_APP_FRWD_FIELD_E *frwd_bm,
+	struct CPH_APP_FRWD_T       *frwd_value);
+
+/******************************************************************************
+* cph_db_get_app_rule_by_dir_proto()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Get application type CPH rule from data base by protocol type
+*
+* INPUTS:
+*       dir        - Direction
+*       proto_type - SKB protocol type
+*
+* OUTPUTS:
+*       parse_bm   - Parsing bitmap
+*       parse_key  - Parsing key
+*       mod_bm     - Modification bitmap
+*       mod_value  - Modification value
+*       frwd_bm    - Forwarding bitmap
+*       frwd_value - Forwarding value
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_db_get_app_rule_by_dir_proto(
+	enum CPH_DIR_E              dir,
+	unsigned short                 proto_type,
+	enum CPH_APP_PARSE_FIELD_E *parse_bm,
+	struct CPH_APP_PARSE_T       *parse_key,
+	enum CPH_APP_MOD_FIELD_E   *mod_bm,
+	struct CPH_APP_MOD_T         *mod_value,
+	enum CPH_APP_FRWD_FIELD_E  *frwd_bm,
+	struct CPH_APP_FRWD_T        *frwd_value);
+
+/******************************************************************************
+* cph_db_increase_counter()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Increase RX counter
+*
+* INPUTS:
+*       parse_bm   - Parsing bitmap
+*       parse_key  - Parsing key
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_db_increase_counter(
+	enum CPH_APP_PARSE_FIELD_E parse_bm,
+	struct CPH_APP_PARSE_T      *parse_key);
+
+/******************************************************************************
+* cph_db_increase_counter_by_dir_proto()
+* _____________________________________________________________________________
+*
+* DESCRIPTION:  Increase RX counter according to protocol type
+*
+* INPUTS:
+*       dir        - Direction
+*       proto_type - SKB protocol type
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_db_increase_counter_by_dir_proto(enum CPH_DIR_E dir,
+	unsigned short    proto_type);
+
+/******************************************************************************
+* cph_db_get_xml_param()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Get the XML parameter
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_db_get_xml_param(void);
+
+/*******************************************************************************
+**
+** cph_db_get_tcont_state
+** ___________________________________________________________________________
+**
+** DESCRIPTION: The function get T-CONT state
+**
+** INPUTS:
+**   tcont - T-CONT
+**
+** OUTPUTS:
+**   None.
+**
+** RETURNS:
+**   state - State of T-CONT, enabled or disabled.
+**
+*******************************************************************************/
+bool cph_db_get_tcont_state(unsigned int tcont);
+
+/*******************************************************************************
+**
+** cph_db_set_tcont_state
+** ___________________________________________________________________________
+**
+** DESCRIPTION: The function sets T-CONT state in mv_cph
+**
+** INPUTS:
+**   tcont - T-CONT
+**   state - State of T-CONT, enabled or disabled.
+**
+** OUTPUTS:
+**   None.
+**
+** RETURNS:
+**  On success, the function returns (MV_OK). On error different types are
+**  returned according to the case.
+**
+*******************************************************************************/
+MV_STATUS cph_db_set_tcont_state(unsigned int tcont, bool state);
+
+/******************************************************************************
+* cph_db_display_parse_field()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Display CPH rule parsing field
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_db_display_parse_field(
+	enum CPH_APP_PARSE_FIELD_E parse_bm,
+	struct CPH_APP_PARSE_T      *parse_key);
+
+/******************************************************************************
+* cph_db_display_mod_field()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Display CPH rule modification field
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_db_display_mod_field(
+	enum CPH_APP_MOD_FIELD_E   mod_bm,
+	struct CPH_APP_MOD_T        *mod_value);
+
+/******************************************************************************
+* cph_db_display_frwd_field()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Display CPH rule forwarding field
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_db_display_frwd_field(
+	enum CPH_APP_FRWD_FIELD_E  frwd_bm,
+	struct CPH_APP_FRWD_T       *frwd_value);
+
+
+/******************************************************************************
+* cph_db_display_all()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Display CPH data base
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_db_display_all(void);
+
+/******************************************************************************
+* cph_db_init()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Initialize CPH data base
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_db_init(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _MV_CPH_DB_H_ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_dev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_dev.c
new file mode 100644
index 0000000..4aeedff
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_dev.c
@@ -0,0 +1,446 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+	*   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+	*   Redistributions in binary form must reproduce the above copyright
+		notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+	*   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+********************************************************************************
+* mv_cph_dev.c
+*
+* DESCRIPTION: Marvell CPH(CPH Packet Handler) char device definition
+*
+* DEPENDENCIES:
+*               None
+*
+* CREATED BY:   VictorGu
+*
+* DATE CREATED: 22Jan2013
+*
+* FILE REVISION NUMBER:
+*               Revision: 1.0
+*
+*
+*******************************************************************************/
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/mutex.h>
+#include <linux/spinlock.h>
+#include <linux/poll.h>
+#include <linux/clk.h>
+#include <linux/fs.h>
+#include <linux/vmalloc.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+
+#include "mv_cph_header.h"
+
+/* Used to prevent multiple access to device */
+static int               g_cph_device_open;
+static struct miscdevice g_cph_misc_dev;
+
+/******************************************************************************
+* cph_dev_open()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: The function executes device open actions
+*
+* INPUTS:
+*       inode - Device inode pointer.
+*       file  - File handler.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+static int cph_dev_open(struct inode *inode, struct file *file)
+{
+	MV_CPH_PRINT(CPH_DEBUG_LEVEL, "Enter\n");
+
+#if 0
+	if (g_cph_device_open > 0)
+		return -EBUSY;
+#endif
+
+	g_cph_device_open++;
+
+	return MV_OK;
+}
+
+/******************************************************************************
+* cph_dev_release()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: The function executes device release actions
+*
+* INPUTS:
+*       inode - Device inode pointer.
+*       file  - File handler.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+static int cph_dev_release(struct inode *inode, struct file *file)
+{
+	MV_CPH_PRINT(CPH_DEBUG_LEVEL, "Enter\n");
+
+#if 0
+	if (cph_device_open > 0)
+		cph_device_open--;
+#endif
+	return MV_OK;
+}
+
+/******************************************************************************
+* cph_dev_ioctl()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: The function executes ioctl commands
+*
+* INPUTS:
+*       inode - Device inode pointer.
+*       file  - File handler.
+*       cmd   - Command.
+*       arg   - Ponter to arg.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+long cph_dev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	struct CPH_IOCTL_APP_RULE_T    cph_app_rule;
+	struct CPH_IOCTL_FLOW_MAP_T    cph_flow_map;
+	struct CPH_IOCTL_DSCP_MAP_T    cph_dscp_map;
+	struct CPH_IOCTL_MISC_T        cph_misc;
+	struct CPH_IOCTL_TCONT_STATE_T cph_tcont;
+	int                   rc  = -EINVAL;
+
+	MV_CPH_PRINT(CPH_DEBUG_LEVEL, "Enter\n");
+
+	switch (cmd) {
+	/* CPH application packet handling IOCTL
+	-------------------------------------------*/
+	case MV_CPH_IOCTL_SET_COMPLEX_PROFILE:
+		if (copy_from_user(&cph_misc, (struct CPH_IOCTL_MISC_T *)arg, sizeof(struct CPH_IOCTL_MISC_T))) {
+			MV_CPH_PRINT(CPH_ERR_LEVEL, "copy_from_user failed\n");
+			goto ioctl_err;
+		}
+
+		rc = cph_set_complex_profile(cph_misc.profile_id, cph_misc.active_port);
+		break;
+
+	case MV_CPH_IOCTL_SET_FEATURE_FLAG:
+		if (copy_from_user(&cph_misc, (struct CPH_IOCTL_MISC_T *)arg, sizeof(struct CPH_IOCTL_MISC_T))) {
+			MV_CPH_PRINT(CPH_ERR_LEVEL, "copy_from_user failed\n");
+			goto ioctl_err;
+		}
+
+		rc = cph_set_feature_flag(cph_misc.feature_type, cph_misc.feature_flag);
+		break;
+
+	case MV_CPH_IOCTL_APP_ADD_RULE:
+		if (copy_from_user(&cph_app_rule, (struct CPH_IOCTL_APP_RULE_T *)arg,
+			sizeof(struct CPH_IOCTL_APP_RULE_T))) {
+			MV_CPH_PRINT(CPH_ERR_LEVEL, "copy_from_user failed\n");
+			goto ioctl_err;
+		}
+
+		rc = cph_add_app_rule(cph_app_rule.parse_bm, &cph_app_rule.parse_key, cph_app_rule.mod_bm,
+					&cph_app_rule.mod_value, cph_app_rule.frwd_bm, &cph_app_rule.frwd_value);
+		break;
+
+	case MV_CPH_IOCTL_APP_DEL_RULE:
+		if (copy_from_user(&cph_app_rule, (struct CPH_IOCTL_APP_RULE_T *)arg,
+			sizeof(struct CPH_IOCTL_APP_RULE_T))) {
+			MV_CPH_PRINT(CPH_ERR_LEVEL, "copy_from_user failed\n");
+			goto ioctl_err;
+		}
+
+		rc = cph_del_app_rule(cph_app_rule.parse_bm, &cph_app_rule.parse_key);
+		break;
+
+	case MV_CPH_IOCTL_APP_UPDATE_RULE:
+		if (copy_from_user(&cph_app_rule, (struct CPH_IOCTL_APP_RULE_T *)arg,
+			sizeof(struct CPH_IOCTL_APP_RULE_T))) {
+			MV_CPH_PRINT(CPH_ERR_LEVEL, "copy_from_user failed\n");
+			goto ioctl_err;
+		}
+
+		rc = cph_update_app_rule(cph_app_rule.parse_bm, &cph_app_rule.parse_key, cph_app_rule.mod_bm,
+					&cph_app_rule.mod_value, cph_app_rule.frwd_bm, &cph_app_rule.frwd_value);
+		break;
+
+	case MV_CPH_IOCTL_APP_GET_RULE:
+		if (copy_from_user(&cph_app_rule, (struct CPH_IOCTL_APP_RULE_T *)arg,
+			sizeof(struct CPH_IOCTL_APP_RULE_T))) {
+			MV_CPH_PRINT(CPH_ERR_LEVEL, "copy_from_user failed\n");
+			goto ioctl_err;
+		}
+
+		rc = cph_get_app_rule(cph_app_rule.parse_bm, &cph_app_rule.parse_key, &cph_app_rule.mod_bm,
+					&cph_app_rule.mod_value, &cph_app_rule.frwd_bm, &cph_app_rule.frwd_value);
+
+		if (rc != MV_OK)
+			goto ioctl_err;
+
+		if (copy_to_user((struct CPH_IOCTL_APP_RULE_T *)arg, &cph_app_rule,
+			sizeof(struct CPH_IOCTL_APP_RULE_T))) {
+			MV_CPH_PRINT(CPH_ERR_LEVEL, "copy_to_user failed\n");
+			goto ioctl_err;
+		}
+		break;
+
+	/* CPH flow mapping IOCTL
+	-------------------------------------------*/
+	case MV_CPH_IOCTL_FLOW_ADD_RULE:
+		if (copy_from_user(&cph_flow_map, (struct CPH_IOCTL_FLOW_MAP_T *)arg,
+			sizeof(struct CPH_IOCTL_FLOW_MAP_T))) {
+			MV_CPH_PRINT(CPH_ERR_LEVEL, "copy_from_user failed\n");
+			goto ioctl_err;
+		}
+
+		rc = cph_add_flow_rule(&cph_flow_map.flow_map);
+		break;
+
+	case MV_CPH_IOCTL_FLOW_DEL_RULE:
+		if (copy_from_user(&cph_flow_map, (struct CPH_IOCTL_FLOW_MAP_T *)arg,
+			sizeof(struct CPH_IOCTL_FLOW_MAP_T))) {
+			MV_CPH_PRINT(CPH_ERR_LEVEL, "copy_from_user failed\n");
+			goto ioctl_err;
+		}
+
+		rc = cph_del_flow_rule(&cph_flow_map.flow_map);
+		break;
+
+	case MV_CPH_IOCTL_FLOW_GET_RULE:
+		if (copy_from_user(&cph_flow_map, (struct CPH_IOCTL_FLOW_MAP_T *)arg,
+			sizeof(struct CPH_IOCTL_FLOW_MAP_T))) {
+			MV_CPH_PRINT(CPH_ERR_LEVEL, "copy_from_user failed\n");
+			goto ioctl_err;
+		}
+
+		rc = cph_get_flow_rule(&cph_flow_map.flow_map);
+
+		if (rc != MV_OK)
+			goto ioctl_err;
+
+		if (copy_to_user((struct CPH_IOCTL_FLOW_MAP_T *)arg, &cph_flow_map,
+			sizeof(struct CPH_IOCTL_FLOW_MAP_T))) {
+			MV_CPH_PRINT(CPH_ERR_LEVEL, "copy_to_user failed\n");
+			goto ioctl_err;
+		}
+		break;
+
+	case MV_CPH_IOCTL_FLOW_CLEAR_RULE:
+		rc = cph_clear_flow_rule();
+		break;
+
+	case MV_CPH_IOCTL_FLOW_CLEAR_RULE_BY_MH:
+		if (copy_from_user(&cph_flow_map, (struct CPH_IOCTL_FLOW_MAP_T *)arg,
+			sizeof(struct CPH_IOCTL_FLOW_MAP_T))) {
+			MV_CPH_PRINT(CPH_ERR_LEVEL, "copy_from_user failed\n");
+			goto ioctl_err;
+		}
+
+		rc = cph_clear_flow_rule_by_mh(cph_flow_map.flow_map.mh);
+		break;
+
+	case MV_CPH_IOCTL_FLOW_SET_DSCP_MAP:
+		if (copy_from_user(&cph_dscp_map, (struct CPH_IOCTL_DSCP_MAP_T *)arg,
+			sizeof(struct CPH_IOCTL_DSCP_MAP_T))) {
+			MV_CPH_PRINT(CPH_ERR_LEVEL, "copy_from_user failed\n");
+			goto ioctl_err;
+		}
+
+		rc = cph_set_flow_dscp_map(&cph_dscp_map.dscp_map);
+		break;
+
+	case MV_CPH_IOCTL_FLOW_DEL_DSCP_MAP:
+		rc = cph_del_flow_dscp_map();
+		break;
+
+	case MV_CPH_IOCTL_SET_TCONT_LLID_STATE:
+		if (copy_from_user(&cph_tcont, (unsigned int *)arg, sizeof(struct CPH_IOCTL_TCONT_STATE_T))) {
+			MV_CPH_PRINT(CPH_ERR_LEVEL, "copy_from_user failed\n");
+			goto ioctl_err;
+		}
+
+		rc = cph_set_tcont_state(cph_tcont.tcont, cph_tcont.state);
+		break;
+
+	case MV_CPH_IOCTL_SETUP:
+		rc = cph_dev_setup();
+		break;
+
+	default:
+		rc = -EINVAL;
+	}
+
+ioctl_err:
+	return rc;
+}
+
+
+static const struct file_operations g_cph_dev_fops = {
+	.open			= cph_dev_open,
+	.release		= cph_dev_release,
+	.unlocked_ioctl	= cph_dev_ioctl,
+};
+
+/******************************************************************************
+* cph_dev_setup()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Setup device
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int cph_dev_setup(void)
+{
+	MV_STATUS rc  = MV_OK;
+
+	/* Get parameter from XML file */
+	rc = cph_db_get_xml_param();
+	CHECK_API_RETURN_AND_LOG_ERROR(rc, "fail to call cph_db_get_xml_param");
+
+	return rc;
+}
+
+/******************************************************************************
+* cph_dev_init()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Initialize CPH device
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int cph_dev_init(void)
+{
+	MV_STATUS rc = MV_OK;
+	MV_CPH_PRINT(CPH_DEBUG_LEVEL, "Enter\n");
+
+	g_cph_misc_dev.minor = MISC_DYNAMIC_MINOR;
+	g_cph_misc_dev.name  = MV_CPH_DEVICE_NAME;
+	g_cph_misc_dev.fops  = &g_cph_dev_fops;
+
+	rc = misc_register(&g_cph_misc_dev);
+	CHECK_API_RETURN_AND_LOG_ERROR(rc, "fail to call misc_register");
+
+	rc = cph_netdev_init();
+	CHECK_API_RETURN_AND_LOG_ERROR(rc, "fail to call cph_netdev_init");
+
+	rc = cph_sysfs_init();
+	CHECK_API_RETURN_AND_LOG_ERROR(rc, "fail to call cph_sysfs_init");
+
+	pr_info("CPH: misc device %s registered with minor: %d\n", MV_CPH_DEVICE_NAME, g_cph_misc_dev.minor);
+	return rc;
+}
+
+/******************************************************************************
+* cph_dev_shutdown()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Shutdown CPH device
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       None.
+*******************************************************************************/
+void cph_dev_shutdown(void)
+{
+	MV_CPH_PRINT(CPH_DEBUG_LEVEL, "Enter\n");
+
+	cph_sysfs_exit();
+
+	misc_deregister(&g_cph_misc_dev);
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_dev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_dev.h
new file mode 100644
index 0000000..9b1371a
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_dev.h
@@ -0,0 +1,151 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+	*   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+	*   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+	*   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+********************************************************************************
+* mv_cph_dev.h
+*
+* DESCRIPTION: Marvell CPH(CPH Packet Handler) char device definition
+*
+* DEPENDENCIES:
+*               None
+*
+* CREATED BY:   VictorGu
+*
+* DATE CREATED: 22Jan2013
+*
+* FILE REVISION NUMBER:
+*               Revision: 1.0
+*
+*
+*******************************************************************************/
+#ifndef _MV_CPH_DEV_H_
+#define _MV_CPH_DEV_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#define MV_CPH_DEVICE_NAME  "cph"
+#define MV_CPH_IOCTL_MAGIC  ('C')
+
+/******************************************************************************
+* Function Declaration
+******************************************************************************/
+/******************************************************************************
+* cph_dev_setup()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Setup device
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int cph_dev_setup(void);
+
+/******************************************************************************
+* cph_dev_shutdown()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Initialize CPH device
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int  cph_dev_init(void);
+
+/******************************************************************************
+* cph_dev_shutdown()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Shutdown CPH device
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       None.
+*******************************************************************************/
+void cph_dev_shutdown(void);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _MV_CPH_DEV_H_ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_flow.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_flow.c
new file mode 100644
index 0000000..30f139a
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_flow.c
@@ -0,0 +1,2911 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+	*   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+	*   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+	*   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+********************************************************************************
+* mv_cph_flow.c
+*
+* DESCRIPTION: Marvell CPH(CPH Packet Handler) flow module to handle the
+*              flow mapping, VLAN modification of data traffic
+*
+* DEPENDENCIES:
+*               None
+*
+* CREATED BY:   VictorGu
+*
+* DATE CREATED: 12Dec2011
+*
+* FILE REVISION NUMBER:
+*               Revision: 1.1
+*
+*
+*******************************************************************************/
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/if_vlan.h>
+#include <net/ip.h>
+#include <net/ipv6.h>
+
+#include "mv_cph_header.h"
+
+/******************************************************************************
+*                           Global Data Definitions
+******************************************************************************/
+static struct CPH_FLOW_DB_T gs_cph_flow_db;
+static struct CPH_FLOW_TABLE_T gs_mc_flow_tbl;
+
+static struct MV_ENUM_ENTRY_T g_enum_map_op_type[] = {
+	{ CPH_VLAN_OP_ASIS,                              "ASIS"},
+	{ CPH_VLAN_OP_DISCARD,                           "DISCARD"},
+	{ CPH_VLAN_OP_ADD,                               "ADD"},
+	{ CPH_VLAN_OP_ADD_COPY_DSCP,                     "ADD_COPY_DSCP"},
+	{ CPH_VLAN_OP_ADD_COPY_OUTER_PBIT,               "ADD_COPY_OUTER_PBIT"},
+	{ CPH_VLAN_OP_ADD_COPY_INNER_PBIT,               "ADD_COPY_INNER_PBIT"},
+	{ CPH_VLAN_OP_ADD_2_TAGS,                        "ADD_2_TAGS"},
+	{ CPH_VLAN_OP_ADD_2_TAGS_COPY_DSCP,              "ADD_2_TAGS_COPY_DSCP"},
+	{ CPH_VLAN_OP_ADD_2_TAGS_COPY_PBIT,              "ADD_2_TAGS_COPY_PBIT"},
+	{ CPH_VLAN_OP_REM,                               "REM"},
+	{ CPH_VLAN_OP_REM_2_TAGS,                        "REM_2_TAGS"},
+	{ CPH_VLAN_OP_REPLACE,                           "REPLACE"},
+	{ CPH_VLAN_OP_REPLACE_VID,                       "REPLACE_VID"},
+	{ CPH_VLAN_OP_REPLACE_PBIT,                      "REPLACE_PBIT"},
+	{ CPH_VLAN_OP_REPLACE_INNER_ADD_OUTER,           "REPLACE_INNER_ADD_OUTER"},
+	{ CPH_VLAN_OP_REPLACE_INNER_ADD_OUTER_COPY_PBIT, "REPLACE_INNER_ADD_OUTER_COPY_PBIT"},
+	{ CPH_VLAN_OP_REPLACE_INNER_REM_OUTER,           "REPLACE_INNER_REM_OUTER"},
+	{ CPH_VLAN_OP_REPLACE_2TAGS,                     "REPLACE_2TAGS"},
+	{ CPH_VLAN_OP_REPLACE_2TAGS_VID,                 "REPLACE_2TAGS_VID"},
+	{ CPH_VLAN_OP_SWAP,                              "SWAP"}
+};
+
+static struct MV_ENUM_ARRAY_T g_enum_array_op_type = {
+	sizeof(g_enum_map_op_type)/sizeof(g_enum_map_op_type[0]),
+	g_enum_map_op_type
+};
+
+/******************************************************************************
+*                           External Declarations
+******************************************************************************/
+
+
+
+/******************************************************************************
+*                           Function Definitions
+******************************************************************************/
+/******************************************************************************
+* cph_flow_db_get_mc_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Get CPH flow mapping multicast rule.
+*
+* INPUTS:
+*       mc_flow    - MC flow parsing field values
+*       for_packet - Whether get rule for packet or for new CPH rule
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_flow_db_get_mc_rule(struct CPH_FLOW_ENTRY_T *mc_flow, bool for_packet)
+{
+	unsigned int            idx         = 0;
+	unsigned int            rule_idx    = 0;
+	struct CPH_FLOW_ENTRY_T *p_flow_rule = NULL;
+	struct CPH_FLOW_DB_T    *p_cph_db    = NULL;
+	struct CPH_FLOW_TABLE_T *p_mc_tbl    = NULL;
+	bool              rc          = FALSE;
+	unsigned long     flags;
+
+	CPH_IF_NULL(mc_flow);
+
+	p_cph_db = &gs_cph_flow_db;
+	p_mc_tbl = &gs_mc_flow_tbl;
+
+	spin_lock_irqsave(&p_cph_db->flow_lock, flags);
+	/* Traverse CPH flow rule table */
+	for (idx = 0, rule_idx = 0; (idx < CPH_FLOW_ENTRY_NUM) && (rule_idx < p_mc_tbl->rule_num); idx++) {
+		p_flow_rule = &p_mc_tbl->flow_rule[idx];
+
+		/* Compare packet or new rule rule data base rule */
+		if (p_flow_rule->valid == TRUE) {
+			rule_idx++;
+
+			if (for_packet == TRUE)
+				rc = cph_flow_compare_packet_and_rule(mc_flow, p_flow_rule);
+			else
+				rc = cph_flow_compare_rules(mc_flow, p_flow_rule);
+
+			if (rc == TRUE) {
+				mc_flow->op_type = p_flow_rule->op_type;
+				memcpy(&mc_flow->mod_outer_tci, &p_flow_rule->mod_outer_tci,
+					sizeof(struct CPH_FLOW_TCI_T));
+				memcpy(&mc_flow->mod_inner_tci, &p_flow_rule->mod_inner_tci,
+					sizeof(struct CPH_FLOW_TCI_T));
+				memcpy(&mc_flow->pkt_frwd,      &p_flow_rule->pkt_frwd,
+					sizeof(struct CPH_FLOW_FRWD_T));
+
+				/* Increase count */
+				if (for_packet == TRUE) {
+					if (p_flow_rule->count == 0xFFFFFFFF)
+						p_flow_rule->count = 0;
+					else
+						p_flow_rule->count++;
+				}
+
+				spin_unlock_irqrestore(&p_cph_db->flow_lock, flags);
+				return MV_OK;
+			}
+		}
+	}
+	spin_unlock_irqrestore(&p_cph_db->flow_lock, flags);
+
+	return MV_FAIL;
+}
+/******************************************************************************
+* cph_flow_db_add_mc_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Add flow rule to database
+*
+* INPUTS:
+*       mc_flow - VLAN ID, 802.1p value, pkt_fwd information.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int  cph_flow_db_add_mc_rule(struct CPH_FLOW_ENTRY_T *mc_flow)
+{
+	unsigned int            idx         = 0;
+	struct CPH_FLOW_ENTRY_T *p_flow_rule = NULL;
+	struct CPH_FLOW_DB_T    *p_cph_db    = NULL;
+	struct CPH_FLOW_TABLE_T *p_mc_tbl    = NULL;
+	bool              rc          = MV_OK;
+	unsigned long     flags;
+
+	CPH_IF_NULL(mc_flow);
+
+	p_cph_db = &gs_cph_flow_db;
+	p_mc_tbl = &gs_mc_flow_tbl;
+
+	/* If the flow table is full */
+	if (p_mc_tbl->rule_num >= CPH_FLOW_ENTRY_NUM) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "%s(), flow rule table is full<%d>\n", __func__, p_mc_tbl->rule_num);
+		return MV_FULL;
+	}
+
+	/* Check if there is already conflicted rules */
+	if (cph_flow_db_get_mc_rule(mc_flow, FALSE) == MV_OK) {
+		MV_CPH_PRINT(CPH_DEBUG_LEVEL, "%s(), already has conflict flow rule\n", __func__);
+		return MV_OK;
+	}
+
+	spin_lock_irqsave(&p_cph_db->flow_lock, flags);
+	/* Traverse CPH flow rule tale */
+	for (idx = 0; idx < CPH_FLOW_ENTRY_NUM; idx++) {
+		p_flow_rule = &p_mc_tbl->flow_rule[idx];
+
+		/* Compare parse_bm and parse_key */
+		if (p_flow_rule->valid == FALSE)
+			break;
+	}
+
+	if (idx == CPH_FLOW_ENTRY_NUM) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "%s(), flow rule table is full<%d>\n", __func__, p_mc_tbl->rule_num);
+		spin_unlock_irqrestore(&p_cph_db->flow_lock, flags);
+		return MV_FULL;
+	}
+
+	/* Save to db */
+	memcpy(p_flow_rule, mc_flow, sizeof(struct CPH_FLOW_ENTRY_T));
+	p_flow_rule->valid = TRUE;
+	p_flow_rule->count = 0;
+	p_mc_tbl->rule_num++;
+	spin_unlock_irqrestore(&p_cph_db->flow_lock, flags);
+
+	return rc;
+}
+
+/******************************************************************************
+* cph_flow_db_del_mc_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Delete CPH flow mapping rule.
+*
+* INPUTS:
+*       mc_flow - Flow parsing field values
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_flow_db_del_mc_rule(struct CPH_FLOW_ENTRY_T *mc_flow)
+{
+	unsigned int            idx         = 0;
+	unsigned int            rule_idx    = 0;
+	struct CPH_FLOW_ENTRY_T *p_flow_rule = NULL;
+	struct CPH_FLOW_DB_T    *p_cph_db    = NULL;
+	struct CPH_FLOW_TABLE_T *p_mc_tbl    = NULL;
+	bool              rc          = MV_OK;
+	unsigned long     flags;
+
+	CPH_IF_NULL(mc_flow);
+
+	p_cph_db = &gs_cph_flow_db;
+	p_mc_tbl = &gs_mc_flow_tbl;
+
+	spin_lock_irqsave(&p_cph_db->flow_lock, flags);
+	/* Traverse CPH flow rule tale */
+	for (idx = 0, rule_idx = 0; (idx < CPH_FLOW_ENTRY_NUM) && (rule_idx < p_mc_tbl->rule_num); idx++) {
+		p_flow_rule = &p_mc_tbl->flow_rule[idx];
+
+		/* Compare parse_bm and parse_key */
+		if (p_flow_rule->valid == TRUE) {
+			rule_idx++;
+
+			rc = cph_flow_compare_rules(mc_flow, p_flow_rule);
+			if (rc == TRUE) {
+				memset(p_flow_rule, 0, sizeof(struct CPH_FLOW_ENTRY_T));
+				p_flow_rule->valid = FALSE;
+				p_mc_tbl->rule_num--;
+
+				spin_unlock_irqrestore(&p_cph_db->flow_lock, flags);
+				return MV_OK;
+			}
+		}
+	}
+	spin_unlock_irqrestore(&p_cph_db->flow_lock, flags);
+
+	return rc;
+}
+
+/******************************************************************************
+* cph_flow_get_vid_pbit()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Get external VID and P-bits.
+*
+* INPUTS:
+*       flow       - Flow parsing field values
+*
+* OUTPUTS:
+*       vid  - external VLAN ID.
+*       pbit - external P-bits
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_flow_get_vid_pbit(struct CPH_FLOW_ENTRY_T *flow, unsigned short *vid, unsigned char *pbit)
+{
+	MV_STATUS rc = MV_OK;
+
+	CPH_IF_NULL(flow);
+	CPH_IF_NULL(vid);
+	CPH_IF_NULL(pbit);
+
+	*vid = flow->parse_outer_tci.vid;
+	*pbit = flow->parse_outer_tci.pbits;
+	if (flow->is_default == FALSE) {
+		if (!(flow->parse_bm & (CPH_FLOW_PARSE_EXT_VLAN|CPH_FLOW_PARSE_TWO_VLAN))) {
+			*vid   = MV_CPH_DEFAULT_UNTAG_RULE;
+			*pbit  = MV_CPH_PBITS_NOT_CARE_VALUE;
+		}
+	} else {
+		if (flow->parse_bm & CPH_FLOW_PARSE_EXT_VLAN) {
+			if ((flow->parse_outer_tci.vid == MV_CPH_ZERO_VALUE) ||
+			    (flow->parse_outer_tci.vid == MV_CPH_VID_NOT_CARE_VALUE))
+				*vid = MV_CPH_DEFAULT_SINGLE_TAG_RULE;
+
+			if ((flow->parse_outer_tci.pbits == MV_CPH_ZERO_VALUE) ||
+			    (flow->parse_outer_tci.pbits == MV_CPH_PBITS_NOT_CARE_VALUE))
+				*pbit = MV_CPH_PBITS_NOT_CARE_VALUE;
+		} else if (flow->parse_bm & CPH_FLOW_PARSE_TWO_VLAN) {
+			if ((flow->parse_outer_tci.vid == MV_CPH_ZERO_VALUE) ||
+			    (flow->parse_outer_tci.vid == MV_CPH_VID_NOT_CARE_VALUE)) {
+				*vid = MV_CPH_DEFAULT_DOUBLE_TAG_RULE;
+			}
+			if ((flow->parse_outer_tci.pbits == MV_CPH_ZERO_VALUE) ||
+			    (flow->parse_outer_tci.pbits == MV_CPH_PBITS_NOT_CARE_VALUE)) {
+				*pbit = MV_CPH_PBITS_NOT_CARE_VALUE;
+			}
+		} else {
+			*vid = MV_CPH_DEFAULT_UNTAG_RULE;
+			*pbit  = MV_CPH_PBITS_NOT_CARE_VALUE;
+		}
+	}
+
+	return rc;
+}
+
+/******************************************************************************
+* cph_flow_db_get_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Get CPH flow mapping rule.
+*
+* INPUTS:
+*       cph_flow   - Flow parsing field values
+*       for_packet - Whether get rule for packet or for new CPH rule
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_flow_db_get_rule(struct CPH_FLOW_ENTRY_T *cph_flow, bool for_packet)
+{
+	unsigned short             vid;
+	unsigned char              pbit;
+	unsigned int             idx           = 0;
+	unsigned char             *p_vid_entry   = NULL;
+	struct CPH_PBITS_TABLE_T *p_pbit_tbl    = NULL;
+	struct CPH_PBITS_ENTRY_T *p_pbit_entry  = NULL;
+	struct CPH_FLOW_ENTRY_T  *p_flow_rule   = NULL;
+	struct CPH_FLOW_DB_T     *p_cph_db      = NULL;
+	bool               rc            = MV_OK;
+	unsigned long      flags;
+
+	CPH_IF_NULL(cph_flow);
+	if (cph_flow->parse_bm & CPH_FLOW_PARSE_MC_PROTO) {
+		rc = cph_flow_db_get_mc_rule(cph_flow, for_packet);
+		if (rc != MV_OK) {
+			MV_CPH_PRINT(CPH_DEBUG_LEVEL, "%s(%d), failed to get MC rule\n", __func__, __LINE__);
+			return rc;
+		}
+		return rc;
+	}
+
+	CPH_POS_RANGE_VALIDATE(cph_flow->dir, CPH_DIR_DS, "DIR not allowed");
+
+	/* get VLAN ID and P-bits from cph rule */
+	rc = cph_flow_get_vid_pbit(cph_flow, &vid, &pbit);
+	CPH_IF_ERROR(rc, "fail to get VID and P-bits\n");
+
+	CPH_POS_RANGE_VALIDATE(vid, MV_CPH_VID_INDEX_TABLE_MAX_SIZE - 1, "illegal VID");
+	CPH_POS_RANGE_VALIDATE(pbit, MV_CPH_PBITS_MAP_MAX_ENTRY_NUM - 1, "illegal pbits");
+
+	p_cph_db = &gs_cph_flow_db;
+
+	spin_lock_irqsave(&p_cph_db->flow_lock, flags);
+	/* Find VID index entry by VID */
+	p_vid_entry = &p_cph_db->vid_idx_tbl[cph_flow->dir].pbit_tbl_idx[vid];
+
+	/* Get P-bits mapping table */
+	if ((*p_vid_entry == MV_CPH_PBITS_TABLE_INVALID_INDEX) ||
+	    (*p_vid_entry >= MV_CPH_MAX_PBITS_MAP_TABLE_SIZE)) {
+		MV_CPH_PRINT(CPH_DEBUG_LEVEL, "Pbit table index(%d) is invalid\n", *p_vid_entry);
+		spin_unlock_irqrestore(&p_cph_db->flow_lock, flags);
+		return MV_NO_SUCH;
+	}
+
+	p_pbit_tbl = &p_cph_db->pbits_tbl[cph_flow->dir][*p_vid_entry];
+
+	/* Save forwarding information */
+	if (cph_flow->is_default == TRUE)
+		p_pbit_entry = &p_pbit_tbl->def_flow_rule[pbit];
+	else
+		p_pbit_entry = &p_pbit_tbl->flow_rule[pbit];
+
+	if (p_pbit_entry->num > MV_CPH_RULE_NUM_PER_ENTRY) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "invalid P-bit entry number(%d)\n", p_pbit_entry->num);
+		spin_unlock_irqrestore(&p_cph_db->flow_lock, flags);
+		return MV_BAD_VALUE;
+	}
+
+	/* Traverse CPH flow rule table */
+	for (idx = 0; idx < p_pbit_entry->num; idx++) {
+		if ((p_pbit_entry->rule_idx[idx] >= CPH_FLOW_ENTRY_NUM) ||
+		    (p_pbit_entry->rule_idx[idx] < 1)) {
+			MV_CPH_PRINT(CPH_ERR_LEVEL, "invalid rule index(%d)\n", p_pbit_entry->rule_idx[idx]);
+			spin_unlock_irqrestore(&p_cph_db->flow_lock, flags);
+			return MV_BAD_VALUE;
+		}
+
+		p_flow_rule = &p_cph_db->flow_tbl.flow_rule[p_pbit_entry->rule_idx[idx]];
+		/* Compare parse_bm and parse_key */
+		if (p_flow_rule->valid == TRUE) {
+			if (for_packet == TRUE)
+				rc = cph_flow_compare_packet_and_rule(cph_flow, p_flow_rule);
+			else
+				rc = cph_flow_compare_rules(cph_flow, p_flow_rule);
+
+			if (rc == TRUE) {
+				cph_flow->op_type = p_flow_rule->op_type;
+				memcpy(&cph_flow->mod_outer_tci, &p_flow_rule->mod_outer_tci,
+					sizeof(struct CPH_FLOW_TCI_T));
+				memcpy(&cph_flow->mod_inner_tci, &p_flow_rule->mod_inner_tci,
+					sizeof(struct CPH_FLOW_TCI_T));
+				memcpy(&cph_flow->pkt_frwd,      &p_flow_rule->pkt_frwd,
+					sizeof(struct CPH_FLOW_FRWD_T));
+
+				/* Increase count */
+				if (for_packet == TRUE) {
+					if (p_flow_rule->count == 0xFFFFFFFF)
+						p_flow_rule->count = 0;
+					else
+						p_flow_rule->count++;
+				}
+
+				spin_unlock_irqrestore(&p_cph_db->flow_lock, flags);
+				return MV_OK;
+			}
+		}
+	}
+
+	/* traverse CPH flow rule rules which does not care about P-bits */
+	if (MV_CPH_PBITS_NOT_CARE_VALUE != pbit) {
+		MV_CPH_PRINT(CPH_DEBUG_LEVEL, "Search P-bits not care rules, vlan(%d), p-bits(%d), default(%d)\n",
+				vid, pbit, cph_flow->is_default);
+		if (cph_flow->is_default == TRUE)
+			p_pbit_entry = &p_pbit_tbl->def_flow_rule[MV_CPH_PBITS_NOT_CARE_VALUE];
+		else
+			p_pbit_entry = &p_pbit_tbl->flow_rule[MV_CPH_PBITS_NOT_CARE_VALUE];
+
+		if (p_pbit_entry->num > MV_CPH_RULE_NUM_PER_ENTRY) {
+			MV_CPH_PRINT(CPH_ERR_LEVEL, "invalid P-bit entry number(%d)\n", p_pbit_entry->num);
+			spin_unlock_irqrestore(&p_cph_db->flow_lock, flags);
+			return MV_BAD_VALUE;
+		}
+
+		/* Traverse CPH flow rule table */
+		for (idx = 0; idx < p_pbit_entry->num; idx++) {
+			if ((p_pbit_entry->rule_idx[idx] >= CPH_FLOW_ENTRY_NUM) ||
+			    (p_pbit_entry->rule_idx[idx] < 1)) {
+				MV_CPH_PRINT(CPH_ERR_LEVEL, "invalid rule index(%d)\n", p_pbit_entry->rule_idx[idx]);
+				spin_unlock_irqrestore(&p_cph_db->flow_lock, flags);
+				return MV_BAD_VALUE;
+			}
+
+			p_flow_rule = &p_cph_db->flow_tbl.flow_rule[p_pbit_entry->rule_idx[idx]];
+			/* Compare parse_bm and parse_key */
+			if (p_flow_rule->valid != TRUE)
+				continue;
+			MV_CPH_PRINT(CPH_DEBUG_LEVEL, "Search P-bits not care rules, for_packet(%d)\n", for_packet);
+
+			if (for_packet == TRUE)
+				rc = cph_flow_compare_packet_and_rule(cph_flow, p_flow_rule);
+			else
+				rc = cph_flow_compare_rules(cph_flow, p_flow_rule);
+			MV_CPH_PRINT(CPH_DEBUG_LEVEL, "Search P-bits not care rules, rc(%d)\n", rc);
+
+			if (rc == TRUE) {
+				cph_flow->op_type = p_flow_rule->op_type;
+				memcpy(&cph_flow->mod_outer_tci, &p_flow_rule->mod_outer_tci,
+					sizeof(struct CPH_FLOW_TCI_T));
+				memcpy(&cph_flow->mod_inner_tci, &p_flow_rule->mod_inner_tci,
+					sizeof(struct CPH_FLOW_TCI_T));
+				memcpy(&cph_flow->pkt_frwd,      &p_flow_rule->pkt_frwd,
+					sizeof(struct CPH_FLOW_FRWD_T));
+
+				/* Increase count */
+				if (for_packet == TRUE) {
+					if (p_flow_rule->count == 0xFFFFFFFF)
+						p_flow_rule->count = 0;
+					else
+						p_flow_rule->count++;
+				}
+
+				spin_unlock_irqrestore(&p_cph_db->flow_lock, flags);
+				return MV_OK;
+			}
+		}
+	}
+	spin_unlock_irqrestore(&p_cph_db->flow_lock, flags);
+
+	return MV_FAIL;
+}
+
+/******************************************************************************
+* cph_flow_db_get_rule_by_vid()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Get CPH flow mapping rule by VID, only used to compare packet and db rule.
+*
+* INPUTS:
+*       cph_flow   - Flow parsing field values
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_flow_db_get_rule_by_vid(struct CPH_FLOW_ENTRY_T *cph_flow)
+{
+	unsigned short             vid;
+	unsigned char              pbit;
+	unsigned int             idx           = 0;
+	unsigned char             *p_vid_entry   = NULL;
+	struct CPH_PBITS_TABLE_T *p_pbit_tbl    = NULL;
+	struct CPH_PBITS_ENTRY_T *p_pbit_entry  = NULL;
+	struct CPH_FLOW_ENTRY_T  *p_flow_rule   = NULL;
+	struct CPH_FLOW_DB_T     *p_cph_db      = NULL;
+	bool               rc            = MV_OK;
+	unsigned long      flags;
+
+	CPH_IF_NULL(cph_flow);
+	CPH_POS_RANGE_VALIDATE(cph_flow->dir, CPH_DIR_DS, "DIR not allowed");
+
+	/* get VLAN ID and P-bits from cph rule */
+	rc = cph_flow_get_vid_pbit(cph_flow, &vid, &pbit);
+	CPH_IF_ERROR(rc, "fail to get VID and P-bits\n");
+
+	CPH_POS_RANGE_VALIDATE(vid, MV_CPH_VID_INDEX_TABLE_MAX_SIZE - 1, "illegal VID");
+	CPH_POS_RANGE_VALIDATE(pbit, MV_CPH_PBITS_MAP_MAX_ENTRY_NUM - 1, "illegal pbits");
+
+	p_cph_db = &gs_cph_flow_db;
+
+	spin_lock_irqsave(&p_cph_db->flow_lock, flags);
+	/* Find VID index entry by VID */
+	p_vid_entry = &p_cph_db->vid_idx_tbl[cph_flow->dir].pbit_tbl_idx[vid];
+
+	/* Get P-bits mapping table */
+	if ((*p_vid_entry == MV_CPH_PBITS_TABLE_INVALID_INDEX) ||
+	    (*p_vid_entry >= MV_CPH_MAX_PBITS_MAP_TABLE_SIZE)) {
+		MV_CPH_PRINT(CPH_DEBUG_LEVEL, "Pbit table index(%d) is invalid\n", *p_vid_entry);
+		spin_unlock_irqrestore(&p_cph_db->flow_lock, flags);
+		return MV_NO_SUCH;
+	}
+
+	p_pbit_tbl = &p_cph_db->pbits_tbl[cph_flow->dir][*p_vid_entry];
+
+	/* Save forwarding information */
+	if (cph_flow->is_default == TRUE)
+		p_pbit_entry = &p_pbit_tbl->def_flow_rule[MV_CPH_PBITS_NOT_CARE_VALUE];
+	else
+		p_pbit_entry = &p_pbit_tbl->flow_rule[MV_CPH_PBITS_NOT_CARE_VALUE];
+
+	if (p_pbit_entry->num > MV_CPH_RULE_NUM_PER_ENTRY) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "invalid P-bit entry number(%d)\n", p_pbit_entry->num);
+		spin_unlock_irqrestore(&p_cph_db->flow_lock, flags);
+		return MV_BAD_VALUE;
+	}
+
+	/* Traverse CPH flow rule tale */
+	for (idx = 0; idx < p_pbit_entry->num; idx++) {
+		if ((p_pbit_entry->rule_idx[idx] >= CPH_FLOW_ENTRY_NUM) ||
+		    (p_pbit_entry->rule_idx[idx] < 1)) {
+			MV_CPH_PRINT(CPH_ERR_LEVEL, "invalid rule index(%d)\n", p_pbit_entry->rule_idx[idx]);
+			spin_unlock_irqrestore(&p_cph_db->flow_lock, flags);
+			return MV_BAD_VALUE;
+		}
+		p_flow_rule = &p_cph_db->flow_tbl.flow_rule[p_pbit_entry->rule_idx[idx]];
+		/* Compare parse_bm and parse_key */
+		if (p_flow_rule->valid == TRUE) {
+			rc = cph_flow_compare_packet_and_rule_vid(cph_flow, p_flow_rule);
+
+			if (rc == TRUE) {
+				cph_flow->op_type = p_flow_rule->op_type;
+				memcpy(&cph_flow->mod_outer_tci, &p_flow_rule->mod_outer_tci,
+					sizeof(struct CPH_FLOW_TCI_T));
+				memcpy(&cph_flow->mod_inner_tci, &p_flow_rule->mod_inner_tci,
+					sizeof(struct CPH_FLOW_TCI_T));
+				memcpy(&cph_flow->pkt_frwd,      &p_flow_rule->pkt_frwd,
+					sizeof(struct CPH_FLOW_FRWD_T));
+
+				/* Increase count */
+				if (p_flow_rule->count == 0xFFFFFFFF)
+					p_flow_rule->count = 0;
+				else
+					p_flow_rule->count++;
+
+				spin_unlock_irqrestore(&p_cph_db->flow_lock, flags);
+				return MV_OK;
+			}
+		}
+	}
+	spin_unlock_irqrestore(&p_cph_db->flow_lock, flags);
+
+	return MV_FAIL;
+}
+
+/******************************************************************************
+* cph_flow_db_add_flow_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Add flow rule to database
+*
+* INPUTS:
+*       cph_flow - VLAN ID, 802.1p value, pkt_fwd information.
+*
+* OUTPUTS:
+*       idx      - index of the rule in flow rule table.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int  cph_flow_db_add_flow_rule(struct CPH_FLOW_ENTRY_T *cph_flow, unsigned int *idx)
+{
+	unsigned int            l_idx       = 0;
+	struct CPH_FLOW_ENTRY_T *p_flow_rule = NULL;
+	bool              rc          = MV_OK;
+	unsigned long     flags;
+	struct CPH_FLOW_DB_T    *p_cph_db    = NULL;
+
+	CPH_IF_NULL(cph_flow);
+	CPH_IF_NULL(idx);
+
+	p_cph_db = &gs_cph_flow_db;
+	/* If the flow table is full */
+	if (p_cph_db->flow_tbl.rule_num >= CPH_FLOW_ENTRY_NUM) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL,
+			"%s(), flow rule table is full<%d>\n", __func__, p_cph_db->flow_tbl.rule_num);
+		return MV_FULL;
+	}
+
+	/* Check if there is already conflicted rules */
+	if (cph_flow_db_get_rule(cph_flow, FALSE) == MV_OK) {
+		MV_CPH_PRINT(CPH_DEBUG_LEVEL, "%s(), already has conflict flow rule\n", __func__);
+		return MV_ALREADY_EXIST;
+	}
+
+	spin_lock_irqsave(&p_cph_db->flow_lock, flags);
+	/* Traverse CPH flow rule tale, entry 0 will be reserved */
+	for (l_idx = 1; l_idx < CPH_FLOW_ENTRY_NUM; l_idx++) {
+		p_flow_rule = &p_cph_db->flow_tbl.flow_rule[l_idx];
+
+		/* Compare parse_bm and parse_key */
+		if (p_flow_rule->valid == FALSE)
+			break;
+	}
+
+	if (l_idx == CPH_FLOW_ENTRY_NUM) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL,
+			"%s(), flow rule table is full<%d>\n", __func__, p_cph_db->flow_tbl.rule_num);
+		spin_unlock_irqrestore(&p_cph_db->flow_lock, flags);
+		return MV_FULL;
+	}
+	*idx = l_idx;
+
+	/* Save to db */
+	memcpy(p_flow_rule, cph_flow, sizeof(struct CPH_FLOW_ENTRY_T));
+	p_flow_rule->valid = TRUE;
+	p_flow_rule->count = 0;
+	p_cph_db->flow_tbl.rule_num++;
+	spin_unlock_irqrestore(&p_cph_db->flow_lock, flags);
+
+	return rc;
+}
+
+/*******************************************************************************
+**
+**    cph_flow_db_get_free_pbit_tbl
+**    ___________________________________________________________________________
+**
+**    DESCRIPTION: The function gets available P-bits mapping table.
+**
+**    INPUTS:
+**      None.
+**
+**    OUTPUTS:
+**      None.
+**
+**    RETURNS:
+**      Available P-bits mapping table index.
+**
+*******************************************************************************/
+unsigned int cph_flow_db_get_free_pbit_tbl(enum CPH_DIR_E dir)
+{
+	unsigned int table_idx = 0;
+
+	/* Table index MV_CUST_MAX_PBITS_MAP_TABLE_SIZE is reserved for tagged default packets */
+	for (table_idx = 0;
+		table_idx < (MV_CPH_MAX_PBITS_MAP_TABLE_SIZE - 1 - MV_CPH_RESERVED_PBITS_TABLE_NUM);
+		table_idx++) {
+		if (gs_cph_flow_db.pbits_tbl[dir][table_idx].in_use == FALSE)
+			return table_idx;
+	}
+
+	return MV_CPH_PBITS_TABLE_INVALID_INDEX;
+}
+
+/******************************************************************************
+* cph_flow_db_add_idx()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Add flow rule to database
+*
+* INPUTS:
+*       cph_flow - VLAN ID, 802.1p value, pkt_fwd information.
+*       idx      - the index in flow rule table
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int  cph_flow_db_add_idx(struct CPH_FLOW_ENTRY_T *cph_flow, unsigned int idx)
+{
+	unsigned short             vid;
+	unsigned char              pbit;
+	unsigned long      flags;
+	struct CPH_FLOW_DB_T     *p_cph_db = NULL;
+	unsigned char             *p_vid_entry = NULL;
+	struct CPH_PBITS_TABLE_T *p_pbit_tbl = NULL;
+	struct CPH_PBITS_ENTRY_T *p_pbit_entry = NULL;
+	unsigned int             pbit_tbl_idx;
+	MV_STATUS          rc = MV_OK;
+
+	CPH_IF_NULL(cph_flow);
+	CPH_POS_RANGE_VALIDATE(cph_flow->dir, CPH_DIR_DS, "DIR not allowed");
+	CPH_POS_RANGE_VALIDATE(idx, CPH_FLOW_ENTRY_NUM, "exceed max flow index");
+
+	/* get VLAN ID and P-bits from cph rule */
+	rc = cph_flow_get_vid_pbit(cph_flow, &vid, &pbit);
+	CPH_IF_ERROR(rc, "failed to get VID and P-bits\n");
+
+	p_cph_db = &gs_cph_flow_db;
+	spin_lock_irqsave(&p_cph_db->flow_lock, flags);
+
+	/* Find VID index entry by VID */
+	p_vid_entry = &p_cph_db->vid_idx_tbl[cph_flow->dir].pbit_tbl_idx[vid];
+
+	/* Get P-bits mapping table */
+	/* If this VID index entry does not point to any P-bits mapping table,
+	   need to search for an available P-bits mapping table             */
+	if ((*p_vid_entry == MV_CPH_PBITS_TABLE_INVALID_INDEX) ||
+	    (*p_vid_entry >= MV_CPH_MAX_PBITS_MAP_TABLE_SIZE)) {
+		/* Reserved for default tagged rule */
+		if (vid >= MV_CPH_DEFAULT_UNTAG_RULE)
+			pbit_tbl_idx = MV_CPH_MAX_PBITS_MAP_TABLE_SIZE - 1 - (vid - MV_CPH_DEFAULT_UNTAG_RULE);
+		else
+			pbit_tbl_idx = cph_flow_db_get_free_pbit_tbl(cph_flow->dir);
+
+		if (pbit_tbl_idx >= MV_CPH_MAX_PBITS_MAP_TABLE_SIZE) {
+			MV_CPH_PRINT(CPH_DEBUG_LEVEL, " %d P-bits mapping table has used out\n\r",
+				MV_CPH_MAX_PBITS_MAP_TABLE_SIZE);
+			spin_unlock_irqrestore(&p_cph_db->flow_lock, flags);
+			return MV_FULL;
+		}
+	} else {
+		/* In case that the VID index already points to a P-bits mapping table,
+		   Need to replace the forwarding information of this P-bit mapping table */
+		pbit_tbl_idx = *p_vid_entry;
+	}
+	p_pbit_tbl = &p_cph_db->pbits_tbl[cph_flow->dir][pbit_tbl_idx];
+
+	/* If legal P-bits is configured */
+	if (pbit <= MV_CPH_PBITS_NOT_CARE_VALUE) {
+		/* Save forwarding information */
+		if (cph_flow->is_default == TRUE)
+			p_pbit_entry = &p_pbit_tbl->def_flow_rule[pbit];
+		else
+			p_pbit_entry = &p_pbit_tbl->flow_rule[pbit];
+
+		if (p_pbit_entry->num >= MV_CPH_RULE_NUM_PER_ENTRY) {
+			MV_CPH_PRINT(CPH_DEBUG_LEVEL, "%s(%d), p-bit table(%d) for vid(%d), p-bit(%d)is full\n",
+					__func__, __LINE__, pbit_tbl_idx, vid, pbit);
+			spin_unlock_irqrestore(&p_cph_db->flow_lock, flags);
+			return MV_FULL;
+		}
+		p_pbit_entry->rule_idx[p_pbit_entry->num] = idx;
+		p_pbit_entry->num++;
+		p_pbit_tbl->in_use  = TRUE;
+
+		/* Save P-bit mapping table index in VID index table */
+		*p_vid_entry = pbit_tbl_idx;
+	}
+
+	spin_unlock_irqrestore(&p_cph_db->flow_lock, flags);
+
+	return rc;
+}
+
+/******************************************************************************
+* cph_flow_db_add_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Add flow rule and index to database
+*
+* INPUTS:
+*       cph_flow - VLAN ID, 802.1p value, pkt_fwd information.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_flow_db_add_rule(struct CPH_FLOW_ENTRY_T *cph_flow)
+{
+	unsigned int    idx;
+	MV_STATUS rc = MV_OK;
+
+	CPH_IF_NULL(cph_flow);
+
+	if (cph_flow->parse_bm & CPH_FLOW_PARSE_MC_PROTO) {
+		rc = cph_flow_db_add_mc_rule(cph_flow);
+		CPH_IF_ERROR(rc, "failed to add CPH MC rule\n");
+	} else {
+		/* add flow to flow table */
+		rc = cph_flow_db_add_flow_rule(cph_flow, &idx);
+		if (rc == MV_ALREADY_EXIST) {
+			MV_CPH_PRINT(CPH_DEBUG_LEVEL, "already has conflicted rule\n");
+			return MV_OK;
+		} else if (rc != MV_OK) {
+			MV_CPH_PRINT(CPH_ERR_LEVEL, "fail to add flow rule to data base\n");
+			return MV_FAIL;
+		}
+
+		/* save flow index to vid and p-bit index table */
+		rc = cph_flow_db_add_idx(cph_flow, idx);
+		CPH_IF_ERROR(rc, "failed to set CPH index\n");
+	}
+
+	return MV_OK;
+}
+
+/******************************************************************************
+* cph_flow_db_update_pbit_tbl_state()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: update the state(in_use or not) of P-bit table.
+*
+* INPUTS:
+*       cph_flow - Flow parsing field values
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_flow_db_update_pbit_tbl_state(struct CPH_PBITS_TABLE_T *pbit_tbl)
+{
+	unsigned int idx;
+	bool in_use = FALSE;
+
+	for (idx = 0; idx < MV_CPH_PBITS_MAP_MAX_ENTRY_NUM; idx++) {
+		if ((pbit_tbl->flow_rule[idx].num != 0) ||
+		    (pbit_tbl->def_flow_rule[idx].num != 0)) {
+			in_use = TRUE;
+			break;
+		}
+	}
+
+	pbit_tbl->in_use = in_use;
+	return MV_OK;
+}
+
+/******************************************************************************
+* cph_flow_db_del_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Delete CPH flow mapping rule.
+*
+* INPUTS:
+*       cph_flow - Flow parsing field values
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_flow_db_del_rule(struct CPH_FLOW_ENTRY_T *cph_flow)
+{
+	unsigned short             vid;
+	unsigned char              pbit;
+	unsigned int             idx           = 0;
+	unsigned char             *p_vid_entry   = NULL;
+	struct CPH_PBITS_TABLE_T *p_pbit_tbl    = NULL;
+	struct CPH_PBITS_ENTRY_T *p_pbit_entry  = NULL;
+	struct CPH_FLOW_ENTRY_T  *p_flow_rule   = NULL;
+	struct CPH_FLOW_DB_T     *p_cph_db      = NULL;
+	MV_STATUS          rc            = MV_OK;
+	unsigned long      flags;
+
+	CPH_IF_NULL(cph_flow);
+	if (cph_flow->parse_bm & CPH_FLOW_PARSE_MC_PROTO) {
+		rc = cph_flow_db_del_mc_rule(cph_flow);
+		CPH_IF_ERROR(rc, "failed to delete CPH MC rule\n");
+	} else {
+		CPH_POS_RANGE_VALIDATE(cph_flow->dir, CPH_DIR_DS, "DIR not allowed");
+
+		/* get VLAN ID and P-bits from cph rule */
+		rc = cph_flow_get_vid_pbit(cph_flow, &vid, &pbit);
+		CPH_IF_ERROR(rc, "failed to get VID and P-bits\n");
+
+		CPH_POS_RANGE_VALIDATE(vid, MV_CPH_VID_INDEX_TABLE_MAX_SIZE - 1, "illegal VID");
+		CPH_POS_RANGE_VALIDATE(pbit, MV_CPH_PBITS_MAP_MAX_ENTRY_NUM - 1, "illegal pbits");
+
+		p_cph_db = &gs_cph_flow_db;
+
+		spin_lock_irqsave(&p_cph_db->flow_lock, flags);
+		/* Find VID index entry by VID */
+		p_vid_entry = &p_cph_db->vid_idx_tbl[cph_flow->dir].pbit_tbl_idx[vid];
+
+		/* Get P-bits mapping table */
+		if ((*p_vid_entry == MV_CPH_PBITS_TABLE_INVALID_INDEX) ||
+		    (*p_vid_entry >= MV_CPH_MAX_PBITS_MAP_TABLE_SIZE)) {
+			MV_CPH_PRINT(CPH_ERR_LEVEL, "Pbit tale index(%d) is invalid\n", *p_vid_entry);
+			spin_unlock_irqrestore(&p_cph_db->flow_lock, flags);
+			return MV_NO_SUCH;
+		}
+
+		p_pbit_tbl = &p_cph_db->pbits_tbl[cph_flow->dir][*p_vid_entry];
+
+		/* Save forwarding information */
+		if (cph_flow->is_default == TRUE)
+			p_pbit_entry = &p_pbit_tbl->def_flow_rule[pbit];
+		else
+			p_pbit_entry = &p_pbit_tbl->flow_rule[pbit];
+
+		if (p_pbit_entry->num > MV_CPH_RULE_NUM_PER_ENTRY) {
+			MV_CPH_PRINT(CPH_ERR_LEVEL, "invalid P-bit entry number(%d)\n", p_pbit_entry->num);
+			spin_unlock_irqrestore(&p_cph_db->flow_lock, flags);
+			return MV_BAD_VALUE;
+		}
+
+		/* Traverse CPH flow rule tale */
+		for (idx = 0; idx < p_pbit_entry->num; idx++) {
+			if ((p_pbit_entry->rule_idx[idx] >= CPH_FLOW_ENTRY_NUM) ||
+			    (p_pbit_entry->rule_idx[idx] < 1)) {
+				MV_CPH_PRINT(CPH_ERR_LEVEL, "invalid rule index(%d)\n", p_pbit_entry->rule_idx[idx]);
+				spin_unlock_irqrestore(&p_cph_db->flow_lock, flags);
+				return MV_BAD_VALUE;
+			}
+			p_flow_rule = &p_cph_db->flow_tbl.flow_rule[p_pbit_entry->rule_idx[idx]];
+			/* Compare parse_bm and parse_key */
+			if (p_flow_rule->valid == TRUE) {
+				rc = cph_flow_compare_rules(cph_flow, p_flow_rule);
+				if (rc == TRUE) {
+					/* clear flow rule in flow table */
+					memset(p_flow_rule, 0, sizeof(struct CPH_FLOW_ENTRY_T));
+					p_flow_rule->valid = FALSE;
+					p_cph_db->flow_tbl.rule_num--;
+
+					/* clear the rule index */
+					if (idx == (p_pbit_entry->num - 1)) {
+						p_pbit_entry->rule_idx[idx] = 0;
+					} else {
+						memmove(&p_pbit_entry->rule_idx[idx], &p_pbit_entry->rule_idx[idx+1],
+							sizeof(p_pbit_entry->rule_idx[idx])*
+							(p_pbit_entry->num - 1 - idx));
+						p_pbit_entry->rule_idx[p_pbit_entry->num - 1] = 0;
+					}
+					p_pbit_entry->num--;
+
+					rc = cph_flow_db_update_pbit_tbl_state(p_pbit_tbl);
+					CPH_IF_ERROR(rc, "failed to update P-bit table\n");
+
+					spin_unlock_irqrestore(&p_cph_db->flow_lock, flags);
+					return MV_OK;
+				}
+			}
+		}
+		spin_unlock_irqrestore(&p_cph_db->flow_lock, flags);
+	}
+	return rc;
+}
+
+/******************************************************************************
+* cph_flow_db_clear_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Clear CPH flow mapping rules.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_flow_db_clear_rule(void)
+{
+	unsigned int         idx         = 0;
+	unsigned long  flags;
+	struct CPH_FLOW_DB_T *p_cph_db    = NULL;
+	struct CPH_FLOW_TABLE_T *p_mc_tbl = NULL;
+
+	p_cph_db = &gs_cph_flow_db;
+	p_mc_tbl = &gs_mc_flow_tbl;
+	spin_lock_irqsave(&p_cph_db->flow_lock, flags);
+
+	/* reset VID index table */
+	for (idx = 0; idx < MV_CPH_VID_INDEX_TABLE_MAX_SIZE; idx++) {
+		p_cph_db->vid_idx_tbl[CPH_DIR_US].pbit_tbl_idx[idx] = MV_CPH_PBITS_TABLE_INVALID_INDEX;
+		p_cph_db->vid_idx_tbl[CPH_DIR_DS].pbit_tbl_idx[idx] = MV_CPH_PBITS_TABLE_INVALID_INDEX;
+	}
+
+	/* reset P-bit table */
+	memset(p_cph_db->pbits_tbl, 0, sizeof(p_cph_db->pbits_tbl));
+	for (idx = 0; idx < MV_CPH_MAX_PBITS_MAP_TABLE_SIZE; idx++) {
+		p_cph_db->pbits_tbl[CPH_DIR_US][idx].in_use = FALSE;
+		p_cph_db->pbits_tbl[CPH_DIR_DS][idx].in_use = FALSE;
+	}
+
+	/* reset flow rule table */
+	memset(&p_cph_db->flow_tbl, 0, sizeof(p_cph_db->flow_tbl));
+	for (idx = 0; idx < CPH_FLOW_ENTRY_NUM; idx++)
+		p_cph_db->flow_tbl.flow_rule[idx].valid = FALSE;
+	memset(p_mc_tbl, 0, sizeof(struct CPH_FLOW_TABLE_T));
+	for (idx = 0; idx < CPH_FLOW_ENTRY_NUM; idx++)
+		p_mc_tbl->flow_rule[idx].valid = FALSE;
+
+	spin_unlock_irqrestore(&p_cph_db->flow_lock, flags);
+
+	return MV_OK;
+}
+
+/******************************************************************************
+* cph_flow_db_clear_rule_by_mh()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Clear CPH flow mapping rules by MH.
+*
+* INPUTS:
+*       mh  -  Marvell header.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_flow_db_clear_rule_by_mh(unsigned short mh)
+{
+	struct CPH_FLOW_ENTRY_T   *p_flow_rule = NULL;
+	struct CPH_FLOW_DB_T      *p_cph_db    = NULL;
+	unsigned int              idx = 0;
+	MV_STATUS           rc          = MV_OK;
+
+	/* go through all flow rules */
+	p_cph_db = &gs_cph_flow_db;
+	for (idx = 0; idx < CPH_FLOW_ENTRY_NUM; idx++) {
+		p_flow_rule = &p_cph_db->flow_tbl.flow_rule[idx];
+
+		if ((p_flow_rule->valid == TRUE) &&
+		    (p_flow_rule->mh == mh) &&
+		    !(p_flow_rule->parse_bm & CPH_FLOW_PARSE_MC_PROTO)) {
+			rc = cph_flow_db_del_rule(p_flow_rule);
+			CPH_IF_ERROR(rc, "failed to delete flow rule\n");
+		}
+	}
+
+	return MV_OK;
+}
+
+/******************************************************************************
+* cph_flow_db_init()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Initialize CPH flow mapping database.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_flow_db_init(void)
+{
+	unsigned int            idx        = 0;
+	struct CPH_FLOW_DB_T    *p_cph_db   = NULL;
+	struct CPH_FLOW_TABLE_T *p_mc_table = NULL;
+
+	/* Init flow rule */
+	p_cph_db = &gs_cph_flow_db;
+	memset((unsigned char *)p_cph_db, 0, sizeof(struct CPH_FLOW_DB_T));
+	p_mc_table = &gs_mc_flow_tbl;
+	memset((unsigned char *)p_mc_table, 0, sizeof(struct CPH_FLOW_TABLE_T));
+
+	/* Init lock */
+	spin_lock_init(&p_cph_db->flow_lock);
+
+	/* Init VID index table */
+	for (idx = 0; idx < MV_CPH_VID_INDEX_TABLE_MAX_SIZE; idx++) {
+		p_cph_db->vid_idx_tbl[CPH_DIR_US].pbit_tbl_idx[idx] = MV_CPH_PBITS_TABLE_INVALID_INDEX;
+		p_cph_db->vid_idx_tbl[CPH_DIR_DS].pbit_tbl_idx[idx] = MV_CPH_PBITS_TABLE_INVALID_INDEX;
+	}
+
+	/* Init P-bit table */
+	for (idx = 0; idx < MV_CPH_MAX_PBITS_MAP_TABLE_SIZE; idx++) {
+		p_cph_db->pbits_tbl[CPH_DIR_US][idx].in_use = FALSE;
+		p_cph_db->pbits_tbl[CPH_DIR_DS][idx].in_use = FALSE;
+	}
+
+	/* Init flow rule table */
+	for (idx = 0; idx < CPH_FLOW_ENTRY_NUM; idx++)
+		p_cph_db->flow_tbl.flow_rule[idx].valid = FALSE;
+	for (idx = 0; idx < CPH_FLOW_ENTRY_NUM; idx++)
+		p_mc_table->flow_rule[idx].valid = FALSE;
+
+	/* Init DSCP to P-bits mapping table */
+	p_cph_db->dscp_tbl.in_use = FALSE;
+
+	return MV_OK;
+}
+
+/******************************************************************************
+* cph_flow_verify_tci()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Verify TCI field of flow mapping rule
+*
+* INPUTS:
+*       tci         - TPID, VLAN ID, P-bits information.
+*       parse_field - Whether the TCI is from parsing field.
+*       tci_field   - the TCI field need to be checked.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns TRUE.
+*       On error returns FALSE.
+*******************************************************************************/
+bool  cph_flow_verify_tci(struct CPH_FLOW_TCI_T *tci, bool parse_field, enum CPH_TCI_FIELD_E tci_field)
+{
+	unsigned short max_vid   = 0;
+	unsigned short max_pbits = 0;
+
+	if (TRUE == parse_field) {
+		max_vid   = MV_CPH_VID_NOT_CARE_VALUE;
+		max_pbits = MV_CPH_PBITS_NOT_CARE_VALUE;
+	} else {
+		max_vid   = MV_VLAN_ID_MAX;
+		max_pbits = MV_PBITS_MAX;
+	}
+
+	/* Check TPID */
+	if ((tci->tpid != MV_TPID_8100) &&
+	    (tci->tpid != MV_TPID_9100) &&
+	    (tci->tpid != MV_TPID_88A8) &&
+	    ((tci->tpid != MV_CPH_TPID_NOT_CARE_VALUE) && (parse_field == TRUE))) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "tpid[0x%x] is invalid\n", tci->tpid);
+		return FALSE;
+	}
+
+	/* Check VID */
+	if ((tci_field == CPH_TCI_FIELD_VID) ||
+	    (tci_field == CPH_TCI_FIELD_VID_PBIT) ||
+	    (tci_field == CPH_TCI_FIELD_ALL)) {
+		if (tci->vid > max_vid) {
+			MV_CPH_PRINT(CPH_ERR_LEVEL, "vid[%d] exceeds maximum value[%d]\n", tci->vid, max_vid);
+			return FALSE;
+		}
+	}
+
+	/* Check P-bits */
+	if ((tci_field == CPH_TCI_FIELD_PBIT) ||
+	    (tci_field == CPH_TCI_FIELD_VID_PBIT) ||
+	    (tci_field == CPH_TCI_FIELD_ALL)) {
+		if (tci->pbits > max_pbits) {
+			MV_CPH_PRINT(CPH_ERR_LEVEL, "pbits[%d] exceeds maximum value[%d]\n", tci->pbits, max_pbits);
+			return FALSE;
+		}
+	}
+
+	return TRUE;
+}
+
+/******************************************************************************
+* cph_flow_verify_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Verify flow mapping rule
+*
+* INPUTS:
+*       cph_flow - VLAN ID, 802.1p value, pkt_fwd information.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns TRUE.
+*       On error returns FALSE.
+*******************************************************************************/
+bool  cph_flow_verify_rule(struct CPH_FLOW_ENTRY_T *cph_flow, bool full)
+{
+	enum CPH_DIR_E          dir         = CPH_DIR_US;
+	enum CPH_FLOW_PARSE_E   parse_bm    = 0;
+	enum CPH_VLAN_OP_TYPE_E op_type     = 0;
+	struct CPH_FLOW_FRWD_T   *p_pkt_fwd   = NULL;
+	bool               rc          = TRUE;
+
+	/* Get input information: VID, P-bits... */
+	if (cph_flow == NULL) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "cph_flow is NULL\n");
+		return FALSE;
+	}
+
+	dir       =  cph_flow->dir;
+	parse_bm  =  cph_flow->parse_bm;
+	op_type   =  cph_flow->op_type;
+	p_pkt_fwd = &cph_flow->pkt_frwd;
+
+	/* Check dir */
+	if (dir >= CPH_DIR_NOT_CARE) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "dir[%d] exceeds maximum value[%d]\n", dir, CPH_DIR_NOT_CARE);
+		return FALSE;
+	}
+
+	/* Check parse_bm */
+	if ((parse_bm & CPH_FLOW_PARSE_EXT_VLAN) &&
+	    (parse_bm & CPH_FLOW_PARSE_TWO_VLAN)) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL,
+			"Cann't set parse_bm CPH_FLOW_PARSE_EXT_VLAN and CPH_FLOW_PARSE_EXT_VLAN at the same time\n");
+		return FALSE;
+	}
+
+	/* Check op_type */
+	if (op_type > CPH_VLAN_OP_SWAP) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "op_type[%d] exceeds maximum value[%d]\n", op_type, CPH_VLAN_OP_SWAP);
+		return FALSE;
+	}
+
+	/* Check TCI */
+	if ((parse_bm & CPH_FLOW_PARSE_EXT_VLAN) ||
+	    (parse_bm & CPH_FLOW_PARSE_TWO_VLAN)) {
+		rc = cph_flow_verify_tci(&cph_flow->parse_outer_tci, TRUE, CPH_TCI_FIELD_VID_PBIT);
+		if (rc == FALSE)
+			return FALSE;
+	}
+
+	if (parse_bm & CPH_FLOW_PARSE_TWO_VLAN) {
+		rc = cph_flow_verify_tci(&cph_flow->parse_inner_tci, TRUE, CPH_TCI_FIELD_VID_PBIT);
+		if (rc == FALSE)
+			return FALSE;
+	}
+
+	switch (cph_flow->op_type) {
+	case CPH_VLAN_OP_ASIS:
+	case CPH_VLAN_OP_DISCARD:
+	case CPH_VLAN_OP_REM:
+	case CPH_VLAN_OP_REM_2_TAGS:
+	case CPH_VLAN_OP_SWAP:
+		break;
+	case CPH_VLAN_OP_ADD:
+	case CPH_VLAN_OP_REPLACE:
+	case CPH_VLAN_OP_REPLACE_INNER_REM_OUTER:
+		rc = cph_flow_verify_tci(&cph_flow->mod_outer_tci, FALSE, CPH_TCI_FIELD_VID_PBIT);
+		if (rc == FALSE)
+			return FALSE;
+		break;
+	case CPH_VLAN_OP_ADD_COPY_DSCP:
+	case CPH_VLAN_OP_ADD_COPY_OUTER_PBIT:
+	case CPH_VLAN_OP_ADD_COPY_INNER_PBIT:
+	case CPH_VLAN_OP_REPLACE_VID:
+		rc = cph_flow_verify_tci(&cph_flow->mod_outer_tci, FALSE, CPH_TCI_FIELD_VID);
+		if (rc == FALSE)
+			return FALSE;
+		break;
+	case CPH_VLAN_OP_ADD_2_TAGS:
+	case CPH_VLAN_OP_REPLACE_2TAGS:
+	case CPH_VLAN_OP_REPLACE_INNER_ADD_OUTER:
+		rc = cph_flow_verify_tci(&cph_flow->mod_outer_tci, FALSE, CPH_TCI_FIELD_VID_PBIT);
+		if (rc == FALSE)
+			return FALSE;
+		rc = cph_flow_verify_tci(&cph_flow->mod_inner_tci, FALSE, CPH_TCI_FIELD_VID_PBIT);
+		if (rc == FALSE)
+			return FALSE;
+		break;
+	case CPH_VLAN_OP_ADD_2_TAGS_COPY_DSCP:
+	case CPH_VLAN_OP_ADD_2_TAGS_COPY_PBIT:
+	case CPH_VLAN_OP_REPLACE_2TAGS_VID:
+	case CPH_VLAN_OP_REPLACE_INNER_ADD_OUTER_COPY_PBIT:
+		rc = cph_flow_verify_tci(&cph_flow->mod_outer_tci, FALSE, CPH_TCI_FIELD_VID);
+		if (rc == FALSE)
+			return FALSE;
+		rc = cph_flow_verify_tci(&cph_flow->mod_inner_tci, FALSE, CPH_TCI_FIELD_VID);
+		if (rc == FALSE)
+			return FALSE;
+		break;
+	case CPH_VLAN_OP_REPLACE_PBIT:
+		rc = cph_flow_verify_tci(&cph_flow->mod_outer_tci, FALSE, CPH_TCI_FIELD_PBIT);
+		if (rc == FALSE)
+			return FALSE;
+		break;
+	default:
+		break;
+	}
+
+	/* Check target port/queue/GEM port */
+	if (p_pkt_fwd->trg_port > MV_TCONT_LLID_MAX) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "trg_port[%d] exceeds maximum value[%d]\n",
+			p_pkt_fwd->trg_port, MV_TCONT_LLID_MAX);
+		return FALSE;
+	}
+
+	if (p_pkt_fwd->trg_queue > MV_QUEUE_MAX) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "SWF trg_queue[%d] exceeds maximum value[%d]\n",
+			p_pkt_fwd->trg_queue, MV_QUEUE_MAX);
+		return FALSE;
+	}
+
+	if (p_pkt_fwd->trg_hwf_queue > MV_QUEUE_MAX) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "HWF trg_queue[%d] exceeds maximum value[%d]\n",
+			p_pkt_fwd->trg_hwf_queue, MV_QUEUE_MAX);
+		return FALSE;
+	}
+
+	if (p_pkt_fwd->gem_port > MV_GEM_PORT_MAX) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "gem_port[%d] exceeds maximum value[%d]\n",
+			p_pkt_fwd->gem_port, MV_GEM_PORT_MAX);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+/******************************************************************************
+* cph_flow_display_tci()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Display TCI value
+*
+* INPUTS:
+*       tci         - TCI field
+*       trace_level - Trace and debug level
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+void  cph_flow_display_tci(struct CPH_FLOW_TCI_T *tci, unsigned int trace_level)
+{
+	MV_CPH_PRINT(trace_level,
+			"TPID[0x%x], vid[%d], p-bits[%d]\n",
+			((tci != NULL) ? tci->tpid : 0),
+			((tci != NULL) ? tci->vid : 0),
+			((tci != NULL) ? tci->pbits : 0));
+	return;
+}
+
+/******************************************************************************
+* cph_flow_add_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Sets flow mapping rule
+*
+* INPUTS:
+*       cph_flow - VLAN ID, 802.1p value, pkt_fwd information.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int  cph_flow_add_rule(struct CPH_FLOW_ENTRY_T *cph_flow)
+{
+	bool rc = TRUE;
+
+	/* Display input CPH flow */
+	MV_CPH_PRINT(CPH_DEBUG_LEVEL,
+		"---->\n default rule[%s], dir[%d], parse bm[%x], mh[%d], eth type[0x%x], op type[%d], trg port[%d]," \
+		"SWF queue[%d], HWF queue[%d], GEM port[%d]\n",
+		(cph_flow->is_default == TRUE) ? "Yes" : "No",
+		cph_flow->dir, cph_flow->parse_bm, cph_flow->mh, cph_flow->eth_type, cph_flow->op_type,
+		cph_flow->pkt_frwd.trg_port, cph_flow->pkt_frwd.trg_queue, cph_flow->pkt_frwd.trg_hwf_queue,
+		cph_flow->pkt_frwd.gem_port);
+	cph_flow_display_tci(&cph_flow->parse_outer_tci, CPH_DEBUG_LEVEL);
+	cph_flow_display_tci(&cph_flow->parse_inner_tci, CPH_DEBUG_LEVEL);
+	cph_flow_display_tci(&cph_flow->mod_outer_tci, CPH_DEBUG_LEVEL);
+	cph_flow_display_tci(&cph_flow->mod_inner_tci, CPH_DEBUG_LEVEL);
+
+	/* Verify CPH flow rule */
+	rc = cph_flow_verify_rule(cph_flow, TRUE);
+	if (rc == FALSE) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "%s(), verify rule failed\n", __func__);
+		return MV_FAIL;
+	}
+
+	/* Add flow rule to data base */
+	if (cph_flow_db_add_rule(cph_flow) != MV_OK) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "%s(), fail to call cph_flow_db_add_rule\n", __func__);
+		return MV_FAIL;
+	}
+
+	MV_CPH_PRINT(CPH_DEBUG_LEVEL, "<----\n");
+
+	return MV_OK;
+}
+
+/******************************************************************************
+* cph_flow_del_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Deletes flow mapping rule
+*
+* INPUTS:
+*       cph_flow - VLAN ID, 802.1p value, pkt_fwd information.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int  cph_flow_del_rule(struct CPH_FLOW_ENTRY_T *cph_flow)
+{
+	/* Display input CPH flow */
+	MV_CPH_PRINT(CPH_DEBUG_LEVEL,
+		"---->\n default rule[%s], dir[%d], parse bm[%x], mh[%d], eth type[0x%x], op type[%d]\n",
+		(cph_flow->is_default == TRUE) ? "Yes" : "No",
+		cph_flow->dir, cph_flow->parse_bm, cph_flow->mh, cph_flow->eth_type, cph_flow->op_type);
+	cph_flow_display_tci(&cph_flow->parse_outer_tci, CPH_DEBUG_LEVEL);
+	cph_flow_display_tci(&cph_flow->parse_inner_tci, CPH_DEBUG_LEVEL);
+
+	/* Delete flow rule from data base */
+	if (cph_flow_db_del_rule(cph_flow) != MV_OK) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "%s(), fail to call cph_flow_db_del_rule\n", __func__);
+		return MV_FAIL;
+	}
+
+	MV_CPH_PRINT(CPH_DEBUG_LEVEL, "<----\n");
+
+	return MV_OK;
+}
+
+/******************************************************************************
+* cph_flow_get_tag_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Gets flow mapping rule for tagged frames.
+*
+* INPUTS:
+*       cph_flow - Input vid, pbits, dir
+*
+* OUTPUTS:
+*       cph_flow - output packet forwarding information, including GEM port,
+*                  T-CONT, queue and packet modification for VID, P-bits.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int  cph_flow_get_rule(struct CPH_FLOW_ENTRY_T *cph_flow)
+{
+	/* Display input CPH flow */
+	MV_CPH_PRINT(CPH_DEBUG_LEVEL,
+		"---->\nPacket flow rule: default rule[%s], dir[%d], parse bm[%x], mh[%d], eth type[0x%x]\n",
+		(cph_flow->is_default == TRUE) ? "Yes" : "No",
+		cph_flow->dir, cph_flow->parse_bm, cph_flow->mh, cph_flow->eth_type);
+	cph_flow_display_tci(&cph_flow->parse_outer_tci, CPH_DEBUG_LEVEL);
+	cph_flow_display_tci(&cph_flow->parse_inner_tci, CPH_DEBUG_LEVEL);
+
+	/* Get flow rule from data base */
+	if (cph_flow_db_get_rule(cph_flow, TRUE) != MV_OK) {
+		MV_CPH_PRINT(CPH_DEBUG_LEVEL, "%s(), fail to call cph_flow_db_get_rule\n", __func__);
+		return MV_FAIL;
+	}
+
+	MV_CPH_PRINT(CPH_DEBUG_LEVEL, "<----\n");
+
+	return MV_OK;
+}
+
+/******************************************************************************
+* cph_flow_clear_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Clears all flow mapping rules
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int cph_flow_clear_rule(void)
+{
+	/* Display input CPH flow */
+	MV_CPH_PRINT(CPH_DEBUG_LEVEL, "---->\n");
+
+	/* Clear flow rule from data base */
+	if (cph_flow_db_clear_rule() != MV_OK) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "%s(), fail to call cph_flow_db_clear_rule\n", __func__);
+		return MV_FAIL;
+	}
+
+	MV_CPH_PRINT(CPH_DEBUG_LEVEL, "<----\n");
+	return MV_OK;
+}
+
+/******************************************************************************
+* cph_flow_clear_rule_by_mh()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Clears flow mapping rules by MH
+*
+* INPUTS:
+*       mh   -  Marvell header.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int cph_flow_clear_rule_by_mh(unsigned short mh)
+{
+	/* Display input CPH flow */
+	MV_CPH_PRINT(CPH_DEBUG_LEVEL, "---->  mh(%d)\n", mh);
+
+	/* Clear flow rule from data base */
+	if (cph_flow_db_clear_rule_by_mh(mh) != MV_OK) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "%s(), fail to call cph_flow_db_clear_rule_by_mh\n", __func__);
+		return MV_FAIL;
+	}
+
+	MV_CPH_PRINT(CPH_DEBUG_LEVEL, "<----\n");
+	return MV_OK;
+}
+
+/******************************************************************************
+* cph_flow_set_dscp_map()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Sets DSCP to P-bits mapping rules
+*
+* INPUTS:
+*       dscp_map  - DSCP to P-bits mapping rules.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int  cph_flow_set_dscp_map(struct CPH_DSCP_PBITS_T *dscp_map)
+{
+	struct CPH_FLOW_DB_T *p_cph_db = NULL;
+
+	CPH_IF_NULL(dscp_map);
+
+	MV_CPH_PRINT(CPH_DEBUG_LEVEL,
+		"----> in_use[%d]\n",
+		((dscp_map != NULL) ? dscp_map->in_use : 0));
+
+	p_cph_db = &gs_cph_flow_db;
+	/* Case 1: to enable DSCP to P-bits mapping */
+	if (dscp_map->in_use == TRUE) {
+		memcpy(&p_cph_db->dscp_tbl.pbits[0], &dscp_map->pbits[0], sizeof(p_cph_db->dscp_tbl.pbits));
+		p_cph_db->dscp_tbl.in_use = TRUE;
+	} else {/* Case 2: to disable DSCP to P-bits mapping */
+		memset((unsigned char *)&p_cph_db->dscp_tbl, 0, sizeof(p_cph_db->dscp_tbl));
+		p_cph_db->dscp_tbl.in_use = FALSE;
+	}
+
+	MV_CPH_PRINT(CPH_DEBUG_LEVEL, "<----\n");
+
+	return MV_OK;
+}
+
+/******************************************************************************
+* cph_flow_del_dscp_map()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Deletes DSCP to P-bits mapping rules
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int  cph_flow_del_dscp_map(void)
+{
+	struct CPH_FLOW_DB_T *p_cph_db = NULL;
+	MV_CPH_PRINT(CPH_DEBUG_LEVEL, "---->\n");
+
+	/* Clear DSCP to P-bits mapping */
+	p_cph_db = &gs_cph_flow_db;
+	memset((unsigned char *)&p_cph_db->dscp_tbl, 0, sizeof(p_cph_db->dscp_tbl));
+	p_cph_db->dscp_tbl.in_use = FALSE;
+
+	MV_CPH_PRINT(CPH_DEBUG_LEVEL, "<----\n");
+
+	return MV_OK;
+}
+
+/******************************************************************************
+* cph_flow_add_vlan()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Add one VLAN tag behind of source MAC address.
+*
+* INPUTS:
+*       mh     - Whether has MH or not
+*       p_data - Pointer to packet
+*       tpid   - Type of VLAN ID
+*       vid    - VLAN to be added
+*       pbits  - P-bits value
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       The shift of SKB data.
+*******************************************************************************/
+INLINE int cph_flow_add_vlan(bool mh, unsigned char *p_data, unsigned short tpid,
+	unsigned short vid, unsigned char pbits)
+{
+	unsigned char  *p_new  = NULL;
+	unsigned short *p_vlan = NULL;
+	unsigned int  len    = 0;
+
+	p_new = p_data - MV_VLAN_HLEN;
+
+	if (TRUE == mh)
+		len = MV_ETH_MH_SIZE + MV_MAC_ADDR_SIZE + MV_MAC_ADDR_SIZE;
+	else
+		len = MV_MAC_ADDR_SIZE + MV_MAC_ADDR_SIZE;
+
+	memmove(p_new, p_data, len);
+
+	p_vlan = (unsigned short *)(p_new + len);
+
+	/* Set VLAN Type */
+	*p_vlan = htons(tpid);
+	p_vlan++;
+
+	/* Set VID + priority */
+	*p_vlan = htons((vid & MV_VLAN_ID_MASK) | ((pbits & MV_PBITS_MASK) << MV_PBITS_SHIFT));
+
+	return -MV_VLAN_HLEN;
+}
+
+/******************************************************************************
+* cph_flow_del_vlan()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Delete one VLAN tag behind of source MAC address.
+*
+* INPUTS:
+*       mh     - Whether has MH or not
+*       p_data - Pointer to packet.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       The shift of SKB data.
+*******************************************************************************/
+INLINE int cph_flow_del_vlan(bool mh, unsigned char *p_data)
+{
+	unsigned char  *p_new  = NULL;
+	unsigned int  len    = 0;
+
+	p_new = p_data + MV_VLAN_HLEN;
+
+	if (TRUE == mh)
+		len = MV_ETH_MH_SIZE + MV_MAC_ADDR_SIZE + MV_MAC_ADDR_SIZE;
+	else
+		len = MV_MAC_ADDR_SIZE + MV_MAC_ADDR_SIZE;
+
+	memmove(p_new, p_data, len);
+
+	return MV_VLAN_HLEN;
+}
+
+/******************************************************************************
+* cph_flow_strip_vlan()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Delete all VLAN tags behind of source MAC address.
+*
+* INPUTS:
+*       mh     - Whether has MH or not
+*       p_data - Pointer to packet.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       The shift of SKB data.
+*******************************************************************************/
+INLINE int cph_flow_strip_vlan(bool mh, unsigned char *p_data)
+{
+	int  offset       = 0;
+	int  total_offset = 0;
+	unsigned short eth_type     = 0;
+	unsigned char *p_field      = NULL;
+	unsigned int len          = 0;
+
+	if (TRUE == mh)
+		len = MV_ETH_MH_SIZE + MV_MAC_ADDR_SIZE + MV_MAC_ADDR_SIZE;
+	else
+		len = MV_MAC_ADDR_SIZE + MV_MAC_ADDR_SIZE;
+
+	p_field  = p_data + len;
+	eth_type = ntohs(*(unsigned short *)p_field);
+
+	while (eth_type == MV_TPID_8100 || eth_type == MV_TPID_88A8 || eth_type == MV_TPID_9100) {
+		offset   = cph_flow_del_vlan(mh, p_data+offset);
+
+		p_field += offset;
+		eth_type = ntohs(*(unsigned short *)p_field);
+		total_offset += offset;
+	}
+
+	return total_offset;
+}
+
+/******************************************************************************
+* cph_flow_replace_vlan()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Replace one VLAN tag behind of source MAC address.
+*
+* INPUTS:
+*       mh     - Whether has MH or not
+*       p_data - Pointer to packet
+*       tpid   - Type of VLAN ID
+*       vid    - VLAN to be added
+*       pbits  - P-bits value
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       The shift of SKB data.
+*******************************************************************************/
+INLINE int cph_flow_replace_vlan(bool mh, unsigned char *p_data, unsigned short tpid,
+	unsigned short vid, unsigned char pbits)
+{
+	unsigned short *p_vlan = NULL;
+	unsigned int  len    = 0;
+
+	if (TRUE == mh)
+		len = MV_ETH_MH_SIZE + MV_MAC_ADDR_SIZE + MV_MAC_ADDR_SIZE;
+	else
+		len = MV_MAC_ADDR_SIZE + MV_MAC_ADDR_SIZE;
+
+	p_vlan = (unsigned short *)(p_data + len);
+
+	/* Set VLAN Type */
+	*p_vlan = htons(tpid);
+	p_vlan++;
+
+	/* Set VID + priority */
+	*p_vlan = htons((vid & MV_VLAN_ID_MASK) | ((pbits & MV_PBITS_MASK) << MV_PBITS_SHIFT));
+
+	return 0;
+}
+
+/******************************************************************************
+* cph_flow_swap_vlan()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Swap between two VLAN tag.
+*
+* INPUTS:
+*       mh     - Whether has MH or not
+*       p_data - Pointer to packet
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       The shift of SKB data.
+*******************************************************************************/
+INLINE int cph_flow_swap_vlan(bool mh, unsigned char *p_data)
+{
+	unsigned int *p_tci = NULL;
+	unsigned int  tci1  = 0;
+	unsigned int  tci2  = 0;
+	unsigned int  len    = 0;
+
+	if (TRUE == mh)
+		len = MV_ETH_MH_SIZE + MV_MAC_ADDR_SIZE + MV_MAC_ADDR_SIZE;
+	else
+		len = MV_MAC_ADDR_SIZE + MV_MAC_ADDR_SIZE;
+
+	p_tci = (unsigned int *)(p_data + len);
+
+	/* Save first TCI */
+	tci1 = ntohl(*p_tci);
+	p_tci++;
+
+	/* Save second TCI and replace it w/ first TCI */
+	tci2   = ntohl(*p_tci);
+	*p_tci = htonl(tci1);
+
+	/* Go back to replce first TCI */
+	p_tci--;
+	*p_tci = htonl(tci2);
+
+	return 0;
+}
+
+/******************************************************************************
+* cph_flow_parse_packet()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Parse packet and output flow information.
+*
+* INPUTS:
+*       port - Source GMAC port
+*       data - Pointer to packet
+*       rx   - Whether in RX dir
+*       mh   - Whether has Marvell header
+*
+* OUTPUTS:
+*       flow - Flow parsing field values
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_flow_parse_packet(int port, unsigned char *data, bool rx, bool mh, struct CPH_FLOW_ENTRY_T *flow)
+{
+	unsigned short      eth_type = 0;
+	unsigned char      *p_field  = NULL;
+	unsigned char       proto    = 0;
+	MV_STATUS   rc       = MV_OK;
+	struct ipv6hdr         *p_ipv6_hdr   = NULL;
+	struct ipv6_hopopt_hdr *p_hopopt_hdr = NULL;
+	struct icmp6hdr        *p_icmp_hdr   = NULL;
+
+	memset(flow, 0, sizeof(struct CPH_FLOW_ENTRY_T));
+
+	/* Parse Direction */
+	flow->dir = cph_app_parse_dir(port, rx);
+	if (flow->dir == CPH_DIR_INVALID) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "dir[%d] is invalid\n", flow->dir);
+		return MV_BAD_VALUE;
+	}
+
+	if (TRUE == mh) {
+		/* Parse Marvell header */
+		if (flow->dir == CPH_DIR_US)
+			flow->mh = (ntohs(*(unsigned short *)data) & MV_VALID_MH_MASK);
+		else
+			flow->mh = (ntohs(*(unsigned short *)data) & MV_VALID_GH_MASK);
+
+		flow->parse_bm |= CPH_FLOW_PARSE_MH;
+		p_field  = data + MV_ETH_MH_SIZE + ETH_ALEN + ETH_ALEN;
+	} else {
+		p_field  = data + ETH_ALEN + ETH_ALEN;
+	}
+
+	/* Parse VLAN tag */
+	eth_type = ntohs(*(unsigned short *)p_field);
+	if (eth_type == MV_TPID_8100 || eth_type == MV_TPID_88A8 || eth_type == MV_TPID_9100) {
+		flow->parse_bm |= CPH_FLOW_PARSE_EXT_VLAN;
+
+		flow->parse_outer_tci.tpid = ntohs(*(unsigned short *)p_field);
+		p_field += MV_CPH_TPID_LEN;
+
+		flow->parse_outer_tci.vid   = (ntohs(*(unsigned short *)p_field) & MV_VLAN_ID_MASK);
+		flow->parse_outer_tci.pbits = ((ntohs(*(unsigned short *)p_field) >> MV_PBITS_SHIFT) & MV_PBITS_MASK);
+
+		p_field += MV_CPH_VLAN_TAG_LEN;
+
+		eth_type = ntohs(*(unsigned short *)p_field);
+		if (eth_type == MV_TPID_8100 || eth_type == MV_TPID_88A8 || eth_type == MV_TPID_9100) {
+			flow->parse_bm &= ~CPH_FLOW_PARSE_EXT_VLAN;
+			flow->parse_bm |= CPH_FLOW_PARSE_TWO_VLAN;
+
+			flow->parse_inner_tci.tpid = ntohs(*(unsigned short *)p_field);
+			p_field += MV_CPH_TPID_LEN;
+
+			flow->parse_inner_tci.vid   = (ntohs(*(unsigned short *)p_field) & MV_VLAN_ID_MASK);
+			flow->parse_inner_tci.pbits = ((ntohs(*(unsigned short *)p_field) >> MV_PBITS_SHIFT)
+							& MV_PBITS_MASK);
+
+			p_field += MV_CPH_VLAN_TAG_LEN;
+
+			eth_type = ntohs(*(unsigned short *)p_field);
+		}
+	}
+	while (eth_type == MV_TPID_8100 || eth_type == MV_TPID_88A8 || eth_type == MV_TPID_9100) {
+		p_field += VLAN_HLEN;
+		eth_type = ntohs(*(unsigned short *)p_field);
+	}
+	/* Parse Eth type */
+	flow->eth_type = eth_type;
+	flow->parse_bm |= CPH_FLOW_PARSE_ETH_TYPE;
+
+	/* Parse Multicast protocol */
+	if (MV_CPH_ETH_TYPE_IPV4 == flow->eth_type) {
+		p_field += MV_CPH_ETH_TYPE_LEN;
+		p_field += MV_IPV4_PROTO_OFFSET;
+		proto = *(unsigned char *)p_field;
+
+		if (IPPROTO_IGMP == proto)
+			flow->parse_bm |= CPH_FLOW_PARSE_MC_PROTO;
+	} else if (MV_CPH_ETH_TYPE_IPV6 == flow->eth_type) {
+		p_ipv6_hdr = (struct ipv6hdr *)(p_field + MV_CPH_ETH_TYPE_LEN);
+
+		if (NEXTHDR_HOP == p_ipv6_hdr->nexthdr) {
+			p_hopopt_hdr = (struct ipv6_hopopt_hdr *)((unsigned char *)p_ipv6_hdr + sizeof(struct ipv6hdr));
+
+			if (IPPROTO_ICMPV6 == p_hopopt_hdr->nexthdr) {
+				p_icmp_hdr = (struct icmp6hdr *)((unsigned char *)p_hopopt_hdr +
+					ipv6_optlen(p_hopopt_hdr));
+
+				switch (p_icmp_hdr->icmp6_type) {
+				case ICMPV6_MGM_QUERY:
+				case ICMPV6_MGM_REPORT:
+				case ICMPV6_MGM_REDUCTION:
+				case ICMPV6_MLD2_REPORT:
+					flow->parse_bm |= CPH_FLOW_PARSE_MC_PROTO;
+					break;
+				default:
+					break;
+				}
+			}
+		}
+	}
+
+	return rc;
+}
+
+/******************************************************************************
+* cph_flow_compare_rules()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Compare two flow rules.
+*
+* INPUTS:
+*       parse_rule  - The parsing field values come from the packets
+*       db_rule     - The flow rule stored in flow database
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       In case same, return TRUE,
+*       In case different, return FALSE.
+*******************************************************************************/
+bool cph_flow_compare_rules(struct CPH_FLOW_ENTRY_T *parse_rule, struct CPH_FLOW_ENTRY_T *db_rule)
+{
+	/* Check direction */
+	if (parse_rule->dir != db_rule->dir)
+		return FALSE;
+
+	/* Check parse_bm */
+	if (parse_rule->parse_bm != db_rule->parse_bm)
+		return FALSE;
+
+	/* Check MH if needed */
+	if (db_rule->parse_bm & CPH_FLOW_PARSE_MH) {
+		if (parse_rule->mh != db_rule->mh)
+			return FALSE;
+	}
+
+	/* Check if it is default rule */
+	if (parse_rule->is_default != db_rule->is_default)
+		return FALSE;
+
+	/* Check VLAN ID */
+	if (parse_rule->is_default == FALSE) {
+		if ((db_rule->parse_bm & CPH_FLOW_PARSE_EXT_VLAN) ||
+		    (db_rule->parse_bm & CPH_FLOW_PARSE_TWO_VLAN)) {
+			if (parse_rule->parse_outer_tci.tpid != db_rule->parse_outer_tci.tpid)
+				return FALSE;
+
+			if (parse_rule->parse_outer_tci.vid != db_rule->parse_outer_tci.vid)
+				return FALSE;
+
+			if (parse_rule->parse_outer_tci.pbits != db_rule->parse_outer_tci.pbits)
+				return FALSE;
+		}
+		if (db_rule->parse_bm & CPH_FLOW_PARSE_TWO_VLAN) {
+			if (parse_rule->parse_inner_tci.tpid != db_rule->parse_inner_tci.tpid)
+				return FALSE;
+
+			if (parse_rule->parse_inner_tci.vid != db_rule->parse_inner_tci.vid)
+				return FALSE;
+
+			if (parse_rule->parse_inner_tci.pbits != db_rule->parse_inner_tci.pbits)
+				return FALSE;
+		}
+	}
+	/* Check Ethernet type if needed */
+	if (db_rule->parse_bm & CPH_FLOW_PARSE_ETH_TYPE) {
+		if (parse_rule->eth_type != db_rule->eth_type)
+			return FALSE;
+	}
+
+	return TRUE;
+}
+
+/******************************************************************************
+* cph_flow_compare_packet_and_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Compare flow packet and rule.
+*
+* INPUTS:
+*       packet_rule - The parsing field values come from the packets
+*       db_rule     - The flow rule stored in flow database
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       In case same, return TRUE,
+*       In case different, return FALSE.
+*******************************************************************************/
+bool cph_flow_compare_packet_and_rule(struct CPH_FLOW_ENTRY_T *packet_rule, struct CPH_FLOW_ENTRY_T *db_rule)
+{
+	/* Check direction */
+	if ((packet_rule->dir != db_rule->dir) &&
+	    (db_rule->dir != CPH_DIR_NOT_CARE))
+		return FALSE;
+
+	/* Check Multicast protocol */
+	if ((db_rule->parse_bm & CPH_FLOW_PARSE_MC_PROTO) != (packet_rule->parse_bm & CPH_FLOW_PARSE_MC_PROTO))
+		return FALSE;
+
+	/* Check MH if needed */
+	if ((db_rule->parse_bm & CPH_FLOW_PARSE_MH) &&
+	    (packet_rule->parse_bm & CPH_FLOW_PARSE_MH)) {
+		if (packet_rule->mh != db_rule->mh)
+			return FALSE;
+	}
+
+	/* Check if it is default rule */
+	if (packet_rule->is_default != db_rule->is_default)
+		return FALSE;
+
+	/* Check VLAN ID */
+	if ((packet_rule->parse_bm & (CPH_FLOW_PARSE_EXT_VLAN | CPH_FLOW_PARSE_TWO_VLAN))
+	     != (db_rule->parse_bm & (CPH_FLOW_PARSE_EXT_VLAN | CPH_FLOW_PARSE_TWO_VLAN)))
+		return FALSE;
+	if (packet_rule->is_default == FALSE) {
+		if ((db_rule->parse_bm & CPH_FLOW_PARSE_EXT_VLAN) ||
+		    (db_rule->parse_bm & CPH_FLOW_PARSE_TWO_VLAN)) {
+			if ((packet_rule->parse_outer_tci.tpid != db_rule->parse_outer_tci.tpid) &&
+			    (db_rule->parse_outer_tci.tpid != MV_CPH_TPID_NOT_CARE_VALUE))
+				return FALSE;
+
+			if ((packet_rule->parse_outer_tci.vid != db_rule->parse_outer_tci.vid) &&
+			    (db_rule->parse_outer_tci.vid != MV_CPH_VID_NOT_CARE_VALUE))
+				return FALSE;
+
+			if ((packet_rule->parse_outer_tci.pbits != db_rule->parse_outer_tci.pbits) &&
+			    (db_rule->parse_outer_tci.pbits != MV_CPH_PBITS_NOT_CARE_VALUE))
+				return FALSE;
+		}
+		if (db_rule->parse_bm & CPH_FLOW_PARSE_TWO_VLAN) {
+			if ((packet_rule->parse_inner_tci.tpid != db_rule->parse_inner_tci.tpid) &&
+			    (db_rule->parse_inner_tci.tpid != MV_CPH_TPID_NOT_CARE_VALUE))
+				return FALSE;
+
+			if ((packet_rule->parse_inner_tci.vid != db_rule->parse_inner_tci.vid) &&
+			    (db_rule->parse_inner_tci.vid != MV_CPH_VID_NOT_CARE_VALUE))
+				return FALSE;
+
+			if ((packet_rule->parse_inner_tci.pbits != db_rule->parse_inner_tci.pbits) &&
+			    (db_rule->parse_inner_tci.pbits != MV_CPH_PBITS_NOT_CARE_VALUE))
+				return FALSE;
+		}
+	}
+	/* Check Ethernet type if needed */
+	if (db_rule->parse_bm & CPH_FLOW_PARSE_ETH_TYPE) {
+		if (packet_rule->eth_type != db_rule->eth_type)
+			return FALSE;
+	}
+
+	return TRUE;
+}
+
+/******************************************************************************
+* cph_flow_compare_packet_and_rule_vid()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Compare flow packet and rule w/ only VID.
+*
+* INPUTS:
+*       packet_rule - The parsing field values come from the packets
+*       db_rule     - The flow rule stored in flow database
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       In case same, return TRUE,
+*       In case different, return FALSE.
+*******************************************************************************/
+bool cph_flow_compare_packet_and_rule_vid(struct CPH_FLOW_ENTRY_T *packet_rule,
+					struct CPH_FLOW_ENTRY_T *db_rule)
+{
+	/* Check direction */
+	if ((packet_rule->dir != db_rule->dir) &&
+	    (db_rule->dir != CPH_DIR_NOT_CARE))
+		return FALSE;
+
+	/* Check Multicast protocol */
+	if ((db_rule->parse_bm & CPH_FLOW_PARSE_MC_PROTO) != (packet_rule->parse_bm & CPH_FLOW_PARSE_MC_PROTO))
+		return FALSE;
+
+	/* Check MH if needed */
+	if ((db_rule->parse_bm & CPH_FLOW_PARSE_MH) &&
+	    (packet_rule->parse_bm & CPH_FLOW_PARSE_MH)) {
+		if (packet_rule->mh != db_rule->mh)
+			return FALSE;
+	}
+
+	/* Check if it is default rule */
+	if (packet_rule->is_default != db_rule->is_default)
+		return FALSE;
+
+	/* Check VLAN ID */
+	if ((packet_rule->parse_bm & (CPH_FLOW_PARSE_EXT_VLAN | CPH_FLOW_PARSE_TWO_VLAN))
+	     != (db_rule->parse_bm & (CPH_FLOW_PARSE_EXT_VLAN | CPH_FLOW_PARSE_TWO_VLAN)))
+		return FALSE;
+	if (packet_rule->is_default == FALSE) {
+		if ((db_rule->parse_bm & CPH_FLOW_PARSE_EXT_VLAN) ||
+		    (db_rule->parse_bm & CPH_FLOW_PARSE_TWO_VLAN)) {
+			if (db_rule->parse_outer_tci.tpid != MV_CPH_TPID_NOT_CARE_VALUE)
+				return FALSE;
+
+			if (db_rule->parse_outer_tci.pbits != MV_CPH_PBITS_NOT_CARE_VALUE)
+				return FALSE;
+
+			if ((packet_rule->parse_outer_tci.vid != db_rule->parse_outer_tci.vid) &&
+			    (db_rule->parse_outer_tci.vid != MV_CPH_VID_NOT_CARE_VALUE))
+				return FALSE;
+		}
+		if (db_rule->parse_bm & CPH_FLOW_PARSE_TWO_VLAN) {
+			if (db_rule->parse_inner_tci.tpid != MV_CPH_TPID_NOT_CARE_VALUE)
+				return FALSE;
+
+			if (db_rule->parse_inner_tci.pbits != MV_CPH_PBITS_NOT_CARE_VALUE)
+				return FALSE;
+
+			if ((packet_rule->parse_inner_tci.vid != db_rule->parse_inner_tci.vid) &&
+			    (db_rule->parse_inner_tci.vid != MV_CPH_VID_NOT_CARE_VALUE))
+				return FALSE;
+		}
+	}
+	/* Check Ethernet type if needed */
+	if (db_rule->parse_bm & CPH_FLOW_PARSE_ETH_TYPE) {
+		if (packet_rule->eth_type != db_rule->eth_type)
+			return FALSE;
+	}
+
+	return TRUE;
+}
+
+/******************************************************************************
+* cph_flow_mod_packet()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Modify packet according to flow rule
+*
+* INPUTS:
+*       skb        - Pointer to packet
+*       mh         - Whether has MH or not
+*       flow       - Flow parsing field values
+*       out_offset - Offset of packet
+*       rx         - Whether RX or TX
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_flow_mod_packet(struct sk_buff *skb,  bool mh, struct CPH_FLOW_ENTRY_T *flow, int *out_offset)
+{
+	int  offset = 0;
+	unsigned short tpid   = 0;
+	unsigned short vid    = 0;
+	unsigned char  pbits  = 0;
+	bool   rc     = MV_OK;
+
+	switch (flow->op_type) {
+	case CPH_VLAN_OP_ASIS:
+		break;
+	case CPH_VLAN_OP_DISCARD:
+		break;
+	case CPH_VLAN_OP_ADD:
+		tpid   = flow->mod_outer_tci.tpid ? flow->mod_outer_tci.tpid : MV_TPID_8100;
+		offset = cph_flow_add_vlan(mh, skb->data, tpid,
+					flow->mod_outer_tci.vid, flow->mod_outer_tci.pbits);
+		break;
+	case CPH_VLAN_OP_ADD_COPY_DSCP:
+		tpid   = flow->mod_outer_tci.tpid ? flow->mod_outer_tci.tpid : MV_TPID_8100;
+		offset = cph_flow_add_vlan(mh, skb->data, tpid,
+					flow->mod_outer_tci.vid, flow->mod_outer_tci.pbits);
+		break;
+	case CPH_VLAN_OP_ADD_COPY_OUTER_PBIT:
+		tpid   = flow->mod_outer_tci.tpid ? flow->mod_outer_tci.tpid : MV_TPID_8100;
+		pbits  = (flow->parse_outer_tci.pbits == MV_CPH_PBITS_NOT_CARE_VALUE) ? 0 : flow->parse_outer_tci.pbits;
+		offset = cph_flow_add_vlan(mh, skb->data, tpid,
+					flow->mod_outer_tci.vid, pbits);
+		break;
+	case CPH_VLAN_OP_ADD_COPY_INNER_PBIT:
+		tpid   = flow->mod_outer_tci.tpid ? flow->mod_outer_tci.tpid : MV_TPID_8100;
+		pbits  = (flow->parse_inner_tci.pbits == MV_CPH_PBITS_NOT_CARE_VALUE) ? 0 : flow->parse_inner_tci.pbits;
+		offset = cph_flow_add_vlan(mh, skb->data, tpid,
+					flow->mod_outer_tci.vid, pbits);
+		break;
+	case CPH_VLAN_OP_ADD_2_TAGS:
+		tpid    = flow->mod_outer_tci.tpid ? flow->mod_outer_tci.tpid : MV_TPID_8100;
+		offset  = cph_flow_add_vlan(mh, skb->data, tpid,
+					flow->mod_outer_tci.vid, flow->mod_outer_tci.pbits);
+		tpid    = flow->mod_inner_tci.tpid ? flow->mod_inner_tci.tpid : MV_TPID_8100;
+		offset += cph_flow_add_vlan(mh, skb->data, tpid,
+					flow->mod_inner_tci.vid, flow->mod_inner_tci.pbits);
+		break;
+	case CPH_VLAN_OP_ADD_2_TAGS_COPY_DSCP:
+		tpid    = flow->mod_outer_tci.tpid ? flow->mod_outer_tci.tpid : MV_TPID_8100;
+		offset  = cph_flow_add_vlan(mh, skb->data, tpid,
+					flow->mod_outer_tci.vid, flow->mod_outer_tci.pbits);
+		tpid    = flow->mod_inner_tci.tpid ? flow->mod_inner_tci.tpid : MV_TPID_8100;
+		offset += cph_flow_add_vlan(mh, skb->data, tpid,
+					flow->mod_inner_tci.vid, flow->mod_inner_tci.pbits);
+		break;
+	case CPH_VLAN_OP_ADD_2_TAGS_COPY_PBIT:
+		tpid   = flow->mod_outer_tci.tpid ? flow->mod_outer_tci.tpid : MV_TPID_8100;
+		pbits  = (flow->parse_outer_tci.pbits == MV_CPH_PBITS_NOT_CARE_VALUE) ? 0 : flow->parse_outer_tci.pbits;
+		offset = cph_flow_add_vlan(mh, skb->data, tpid,
+					flow->mod_inner_tci.vid, pbits);
+		tpid   = flow->mod_inner_tci.tpid ? flow->mod_inner_tci.tpid : MV_TPID_8100;
+		pbits  = (flow->parse_inner_tci.pbits == MV_CPH_PBITS_NOT_CARE_VALUE) ? 0 : flow->parse_inner_tci.pbits;
+		offset += cph_flow_add_vlan(mh, skb->data, tpid,
+					flow->mod_inner_tci.vid, pbits);
+		break;
+	case CPH_VLAN_OP_REM:
+		offset = cph_flow_del_vlan(mh, skb->data);
+		break;
+	case CPH_VLAN_OP_REM_2_TAGS:
+		offset  = cph_flow_del_vlan(mh, skb->data);
+		offset += cph_flow_del_vlan(mh, skb->data);
+		break;
+	case CPH_VLAN_OP_REPLACE:
+		tpid   = flow->mod_outer_tci.tpid ? flow->mod_outer_tci.tpid : MV_TPID_8100;
+		offset = cph_flow_replace_vlan(mh, skb->data, tpid,
+					flow->mod_outer_tci.vid, flow->mod_outer_tci.pbits);
+		break;
+	case CPH_VLAN_OP_REPLACE_VID:
+		tpid = flow->mod_outer_tci.tpid ? flow->mod_outer_tci.tpid : MV_TPID_8100;
+
+		pbits  = (flow->parse_outer_tci.pbits == MV_CPH_PBITS_NOT_CARE_VALUE) ? 0 : flow->parse_outer_tci.pbits;
+		offset = cph_flow_replace_vlan(mh, skb->data, tpid,
+					flow->mod_outer_tci.vid, pbits);
+		break;
+	case CPH_VLAN_OP_REPLACE_PBIT:
+		tpid = flow->mod_outer_tci.tpid ? flow->mod_outer_tci.tpid : MV_TPID_8100;
+
+		vid    = (flow->parse_outer_tci.vid == MV_CPH_VID_NOT_CARE_VALUE) ? 0 : flow->parse_outer_tci.vid;
+		offset = cph_flow_replace_vlan(mh, skb->data, tpid,
+					vid, flow->mod_outer_tci.pbits);
+		break;
+	case CPH_VLAN_OP_REPLACE_INNER_ADD_OUTER:
+		tpid = flow->mod_inner_tci.tpid ? flow->mod_inner_tci.tpid : MV_TPID_8100;
+		offset = cph_flow_replace_vlan(mh, skb->data, tpid,
+					flow->mod_inner_tci.vid, flow->mod_inner_tci.pbits);
+		tpid = flow->mod_outer_tci.tpid ? flow->mod_outer_tci.tpid : MV_TPID_8100;
+		offset += cph_flow_add_vlan(mh, skb->data, tpid,
+					flow->mod_outer_tci.vid, flow->mod_outer_tci.pbits);
+		break;
+	case CPH_VLAN_OP_REPLACE_INNER_ADD_OUTER_COPY_PBIT:
+		tpid = flow->mod_inner_tci.tpid ? flow->mod_inner_tci.tpid : MV_TPID_8100;
+		pbits  = (flow->parse_inner_tci.pbits == MV_CPH_PBITS_NOT_CARE_VALUE) ? 0 : flow->parse_inner_tci.pbits;
+		offset = cph_flow_replace_vlan(mh, skb->data, tpid,
+					flow->mod_inner_tci.vid, pbits);
+		tpid = flow->mod_outer_tci.tpid ? flow->mod_outer_tci.tpid : MV_TPID_8100;
+		pbits  = (flow->parse_outer_tci.pbits == MV_CPH_PBITS_NOT_CARE_VALUE) ? 0 : flow->parse_outer_tci.pbits;
+		offset += cph_flow_add_vlan(mh, skb->data, tpid,
+					flow->mod_outer_tci.vid, pbits);
+		break;
+	case CPH_VLAN_OP_REPLACE_INNER_REM_OUTER:
+		offset  = cph_flow_del_vlan(mh, skb->data);
+		tpid    = flow->mod_outer_tci.tpid ? flow->mod_outer_tci.tpid : MV_TPID_8100;
+		offset += cph_flow_replace_vlan(mh, skb->data, tpid,
+					flow->mod_outer_tci.vid, flow->mod_outer_tci.pbits);
+		break;
+	case CPH_VLAN_OP_REPLACE_2TAGS:
+		tpid    = flow->mod_inner_tci.tpid ? flow->mod_inner_tci.tpid : MV_TPID_8100;
+		offset  = cph_flow_replace_vlan(mh, skb->data, tpid,
+					flow->mod_inner_tci.vid, flow->mod_inner_tci.pbits);
+		offset += cph_flow_swap_vlan(mh, skb->data);
+		tpid    = flow->mod_outer_tci.tpid ? flow->mod_outer_tci.tpid : MV_TPID_8100;
+		offset += cph_flow_replace_vlan(mh, skb->data, tpid,
+					flow->mod_outer_tci.vid, flow->mod_outer_tci.pbits);
+		break;
+	case CPH_VLAN_OP_REPLACE_2TAGS_VID:
+		tpid    = flow->mod_inner_tci.tpid ? flow->mod_inner_tci.tpid : MV_TPID_8100;
+		pbits  = (flow->parse_inner_tci.pbits == MV_CPH_PBITS_NOT_CARE_VALUE) ? 0 : flow->parse_inner_tci.pbits;
+		offset  = cph_flow_replace_vlan(mh, skb->data, tpid,
+					flow->mod_inner_tci.vid, pbits);
+		offset += cph_flow_swap_vlan(mh, skb->data);
+		tpid    = flow->mod_outer_tci.tpid ? flow->mod_outer_tci.tpid : MV_TPID_8100;
+		pbits  = (flow->parse_outer_tci.pbits == MV_CPH_PBITS_NOT_CARE_VALUE) ? 0 : flow->parse_outer_tci.pbits;
+		offset += cph_flow_replace_vlan(mh, skb->data, tpid,
+					flow->mod_outer_tci.vid, pbits);
+		break;
+	case CPH_VLAN_OP_SWAP:
+		offset  = cph_flow_swap_vlan(mh, skb->data);
+		break;
+	default:
+		break;
+	}
+
+	/* Save SKB data offset */
+	skb->data  += offset;
+	skb->len   -= offset;
+	*out_offset = offset;
+
+	return rc;
+}
+
+/******************************************************************************
+* cph_flow_mod_frwd()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Modify forwarding parameter of transmiting packet according to flow rule
+*
+* INPUTS:
+*       flow        - Flow parsing field values
+*       tx_spec_out - TX descriptor
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_flow_mod_frwd(struct CPH_FLOW_ENTRY_T *flow, struct mv_eth_tx_spec *tx_spec_out)
+{
+	MV_STATUS rc = MV_OK;
+
+	tx_spec_out->txp     = flow->pkt_frwd.trg_port;
+	tx_spec_out->txq     = flow->pkt_frwd.trg_queue;
+	if ((FALSE == cph_db_get_tcont_state(tx_spec_out->txp)) ||
+	    (flow->op_type == CPH_VLAN_OP_DISCARD))
+		tx_spec_out->txq = MV_INVALID_QUEUE_NUM;
+	tx_spec_out->hw_cmd[0]  = ((flow->pkt_frwd.gem_port << 8)|0x0010);
+	tx_spec_out->tx_func = NULL;
+	tx_spec_out->flags   = MV_ETH_TX_F_MH;
+	if (!flow->pkt_frwd.gem_port)
+		tx_spec_out->tx_mh = htons(flow->pkt_frwd.trg_port + 0x01);/* EPON LLID*/
+	else
+		tx_spec_out->tx_mh = htons(flow->pkt_frwd.gem_port);/* GPON GEM port */
+
+	return rc;
+}
+
+/******************************************************************************
+* cph_flow_send_packet()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: CPH function to handle the received application packets
+*
+* INPUTS:
+*       dev_out     - Net device
+*       pkt         - Marvell packet information
+*       tx_spec_out - TX descriptor
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns 1.
+*       On error returns 0.
+*******************************************************************************/
+MV_STATUS cph_flow_send_packet(struct net_device *dev_out, struct eth_pbuf *pkt,
+	struct mv_eth_tx_spec *tx_spec_out)
+{
+#if 0
+	struct eth_port *pp = MV_ETH_PRIV(dev_out);
+	int frags = 0;
+	bool tx_spec_ready = false;
+	struct mv_eth_tx_spec tx_spec;
+	u32 tx_cmd;
+	struct tx_queue *txq_ctrl = NULL;
+	struct pp2_tx_desc *tx_desc;
+	struct sk_buff  *skb;
+
+
+	skb = (struct sk_buff *)(pkt->osInfo);
+
+	read_lock(&pp->rwlock);
+
+	if (!(netif_running(dev_out))) {
+		pr_err("!netif_running() in %s\n", __func__);
+		goto out;
+	}
+
+	/* Get TXQ (without BM) to send packet generated by Linux */
+	if (tx_spec_ready == false) {
+		tx_spec.txp    = tx_spec_out->txp;
+		tx_spec.txq    = tx_spec_out->txq;
+		tx_spec.hw_cmd[0] = tx_spec_out->hw_cmd[0];
+		tx_spec.flags  = tx_spec_out->flags;
+	}
+
+	txq_ctrl = &pp->txq_ctrl[tx_spec.txp * CONFIG_MV_ETH_TXQ + tx_spec.txq];
+	if (txq_ctrl == NULL) {
+		pr_err("%s: invalidate txp/txq (%d/%d)\n", __func__, tx_spec.txp, tx_spec.txq);
+		goto out;
+	}
+	spin_lock_irqsave(&txq_ctrl->queue_lock);
+
+#if 0
+#ifdef CONFIG_MV_ETH_TSO
+	/* GSO/TSO */
+	if (skb_is_gso(skb)) {
+		frags = mv_eth_tx_tso(skb, dev_out, &tx_spec, txq_ctrl);
+		goto out;
+	}
+#endif /* CONFIG_MV_ETH_TSO */
+#endif
+
+	frags = 1;
+
+#if 0
+	if (tx_spec.flags & MV_ETH_TX_F_MH) {
+		if (tx_spec.flags & MV_ETH_F_SWITCH)
+			mh = dev_priv->tx_vlan_mh;
+		else
+			mh = pp->tx_mh;
+
+		if (mv_eth_skb_mh_add(skb, mh)) {
+			frags = 0;
+			goto out;
+		}
+	}
+#endif
+	tx_desc = mv_eth_tx_desc_get(txq_ctrl, frags);
+	if (tx_desc == NULL) {
+		frags = 0;
+		goto out;
+	}
+
+	tx_cmd = PP2_TX_L4_CSUM_NOT;
+
+#ifdef CONFIG_MV_PON
+	tx_desc->hw_cmd[0] = tx_spec.hw_cmd[0];
+#endif
+
+	/* FIXME: beware of nonlinear --BK */
+	tx_desc->dataSize = skb_headlen(skb);
+
+	tx_desc->bufPhysAddr = mvOsCacheFlush(NULL, skb->data, tx_desc->dataSize);
+
+	if (frags == 1) {
+		/*
+		 * First and Last descriptor
+		 */
+		if (tx_spec.flags & MV_ETH_TX_F_NO_PAD)
+			tx_cmd |= PP2_TX_F_DESC_MASK | PP2_TX_L_DESC_MASK;
+		else
+			tx_cmd |= PP2_TX_FLZ_DESC_MASK;
+
+		tx_desc->command = tx_cmd;
+		mv_eth_tx_desc_flush(tx_desc);
+
+		txq_ctrl->shadow_txq[txq_ctrl->shadow_txq_put_i] = ((MV_ULONG) skb | MV_ETH_SHADOW_SKB);
+		mv_eth_shadow_inc_put(txq_ctrl);
+	}
+
+	txq_ctrl->txq_count += frags;
+
+#ifdef CONFIG_MV_ETH_DEBUG_CODE
+	if (pp->flags & MV_ETH_F_DBG_TX) {
+		pr_err("\n");
+		pr_err("%s - eth_tx_%lu: port=%d, txp=%d, txq=%d, skb=%p, head=%p, data=%p, size=%d\n",
+			dev_out->name, dev_out->stats.tx_packets, pp->port, tx_spec.txp, tx_spec.txq, skb,
+			skb->head, skb->data, skb->len);
+		mv_eth_tx_desc_print(tx_desc);
+	}
+#endif /* CONFIG_MV_ETH_DEBUG_CODE */
+
+#ifdef CONFIG_MV_PON
+	if (MV_PON_PORT(pp->port))
+		mvNetaPonTxqBytesAdd(pp->port, tx_spec.txp, tx_spec.txq, skb->len);
+#endif /* CONFIG_MV_PON */
+
+	/* Enable transmit */
+	mvPp2AggrTxqPendDescAdd(pp->port, tx_spec.txp, tx_spec.txq, frags);
+
+	STAT_DBG(txq_ctrl->stats.txq_tx += frags);
+
+out:
+	if (frags > 0) {
+		dev_out->stats.tx_packets++;
+		dev_out->stats.tx_bytes += skb->len;
+	} else {
+		dev_out->stats.tx_dropped++;
+		dev_kfree_skb_any(skb);
+	}
+
+#ifndef CONFIG_MV_ETH_TXDONE_ISR
+	if (txq_ctrl) {
+		if (txq_ctrl->txq_count >= mv_ctrl_txdone) {
+			u32 tx_done = mv_eth_txq_done(pp, txq_ctrl);
+			STAT_DIST((tx_done < pp->dist_stats.tx_done_dist_size) ?
+				pp->dist_stats.tx_done_dist[tx_done]++ : 0);
+		}
+		/* If after calling mv_eth_txq_done, txq_ctrl->txq_count equals frags, we need to set the timer */
+		if ((txq_ctrl->txq_count == frags) && (frags > 0))
+			mv_eth_add_tx_done_timer(pp);
+	}
+#endif /* CONFIG_MV_ETH_TXDONE_ISR */
+
+	if (txq_ctrl)
+		spin_unlock_irqrestore(&txq_ctrl->queue_lock);
+
+	read_unlock(&pp->rwlock);
+
+#endif
+	return MV_OK;
+}
+
+/******************************************************************************
+* cph_flow_lookup_op_type()
+* _____________________________________________________________________________
+*
+* DESCRIPTION:lookup operation type string according to value
+*
+* INPUTS:
+*       enum_value - The enum value to be matched
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       Enum string
+*******************************************************************************/
+char *cph_flow_lookup_op_type(int enum_value)
+{
+	return mtype_lookup_enum_str(&g_enum_array_op_type, enum_value);
+}
+
+/******************************************************************************
+* cph_flow_display_all()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: The function displays valid flow mapping tables and DSCP
+*              to P-bits mapping tablefor untagged frames.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int  cph_flow_display_all(void)
+{
+	unsigned int             idx         = 0;
+	unsigned int             pbit_idx    = 0;
+	unsigned int             rule_idx    = 0;
+	struct CPH_FLOW_ENTRY_T  *p_flow_rule = NULL;
+	int              offset      = 0;
+	struct CPH_FLOW_DB_T     *p_cph_db    = NULL;
+	struct CPH_PBITS_TABLE_T *p_pbits_tbl = NULL;
+	struct CPH_FLOW_TABLE_T  *p_mc_tbl    = NULL;
+	unsigned char              pbit_tbl_idx;
+	unsigned char              buff[512];
+
+	p_cph_db = &gs_cph_flow_db;
+	p_mc_tbl = &gs_mc_flow_tbl;
+	/* Print flow rule entries */
+	pr_info("MV_CPH Flow Rule Table\n----------------------------------\n");
+	pr_info("Total rule number:%d, Max rule number:%d\n", p_cph_db->flow_tbl.rule_num, CPH_FLOW_ENTRY_NUM);
+
+	pr_info("----------------------------------------------------------------------------------------------------------------------------------------------------------------\n");
+	pr_info("                                         |Parse outer       |Parse inner       |Mod outer         |Mod Inner         |Forward\n");
+	pr_info("rule_idx dir default parse_bm mh   ety    tpid   vid  pbits  tpid   vid  pbits  tpid   vid  pbits  tpid   vid  pbits  port queue hwf_queue gem  count    op_type\n");
+	/* Traverse CPH flow rule table */
+	for (idx = 0, rule_idx = 0; (idx < CPH_FLOW_ENTRY_NUM) && (rule_idx < p_cph_db->flow_tbl.rule_num); idx++) {
+		p_flow_rule = &p_cph_db->flow_tbl.flow_rule[idx];
+
+		/* Compare parse_bm and parse_key */
+		if (p_flow_rule->valid == TRUE) {
+			rule_idx++;
+
+			pr_info(
+			       "%-8d %2.2s  %3.3s     0x%04x   %-4d 0x%04x 0x%04x %-4d %1d      0x%04x %-4d %1d      " \
+			       "0x%04x %-4d %1d      0x%04x %-4d %1d      %1d    %1d     %1d         %-4d %-8d %s\n",
+			       idx,
+			       cph_app_lookup_dir(p_flow_rule->dir), (p_flow_rule->is_default == TRUE) ? "Yes" : "No ",
+			       p_flow_rule->parse_bm,             p_flow_rule->mh,
+			       p_flow_rule->eth_type,
+			       p_flow_rule->parse_outer_tci.tpid, p_flow_rule->parse_outer_tci.vid,
+			       p_flow_rule->parse_outer_tci.pbits,
+			       p_flow_rule->parse_inner_tci.tpid, p_flow_rule->parse_inner_tci.vid,
+			       p_flow_rule->parse_inner_tci.pbits,
+			       p_flow_rule->mod_outer_tci.tpid,   p_flow_rule->mod_outer_tci.vid,
+			       p_flow_rule->mod_outer_tci.pbits,
+			       p_flow_rule->mod_inner_tci.tpid,   p_flow_rule->mod_inner_tci.vid,
+			       p_flow_rule->mod_inner_tci.pbits,
+			       p_flow_rule->pkt_frwd.trg_port,    p_flow_rule->pkt_frwd.trg_queue,
+			       p_flow_rule->pkt_frwd.trg_hwf_queue, p_flow_rule->pkt_frwd.gem_port,
+			       p_flow_rule->count,                cph_flow_lookup_op_type(p_flow_rule->op_type));
+		}
+	}
+
+	pr_info("\nVID Index Table U/S\n----------------------------------\n");
+	pr_info("Index   pbit_tbl_idx\n");
+	rule_idx = 0;
+	/* Traverse CPH U/S VID index table */
+	for (idx = 0; idx < MV_CPH_VID_INDEX_TABLE_MAX_SIZE; idx++) {
+		pbit_tbl_idx = p_cph_db->vid_idx_tbl[CPH_DIR_US].pbit_tbl_idx[idx];
+
+		if (pbit_tbl_idx < MV_CPH_MAX_PBITS_MAP_TABLE_SIZE) {
+			rule_idx++;
+			pr_info("%4.4d       %4.4d\n", idx, pbit_tbl_idx);
+		}
+	}
+	pr_info("Total valid P-bits table index:%d\n\n", rule_idx);
+
+	pr_info("VID Index Table D/S\n----------------------------------\n");
+	pr_info("Index   pbit_tbl_idx\n");
+	rule_idx = 0;
+	/* Traverse CPH D/S VID index table */
+	for (idx = 0; idx < MV_CPH_VID_INDEX_TABLE_MAX_SIZE; idx++) {
+		pbit_tbl_idx = p_cph_db->vid_idx_tbl[CPH_DIR_DS].pbit_tbl_idx[idx];
+
+		if (pbit_tbl_idx < MV_CPH_MAX_PBITS_MAP_TABLE_SIZE) {
+			rule_idx++;
+			pr_info("%4.4d       %4.4d\n", idx, pbit_tbl_idx);
+		}
+	}
+	pr_info("Total valid P-bits table index:%d\n\n", rule_idx);
+
+	pr_info("P-bits table U/S\n----------------------------------\n");
+	/* Traverse CPH U/S P-bits table */
+	for (idx = 0; idx < MV_CPH_MAX_PBITS_MAP_TABLE_SIZE; idx++) {
+		p_pbits_tbl = &p_cph_db->pbits_tbl[CPH_DIR_US][idx];
+
+		if (p_pbits_tbl->in_use == TRUE) {
+			pr_info("\nP-bits table:%d\nflow rule:\n", idx);
+			for (pbit_idx = 0; pbit_idx < MV_CPH_PBITS_MAP_MAX_ENTRY_NUM; pbit_idx++) {
+				if ((p_pbits_tbl->flow_rule[pbit_idx].num > 0) &&
+				    (p_pbits_tbl->flow_rule[pbit_idx].num < MV_CPH_RULE_NUM_PER_ENTRY)) {
+					memset(buff, 0, sizeof(buff));
+					offset = 0;
+					offset += sprintf(buff+offset, "P-bit:%d, number:%d rule_idx:",
+						pbit_idx, p_pbits_tbl->flow_rule[pbit_idx].num);
+					for (rule_idx = 0; rule_idx < p_pbits_tbl->flow_rule[pbit_idx].num; rule_idx++)
+						offset += sprintf(buff+offset, "[%d]%d ", rule_idx,
+							p_pbits_tbl->flow_rule[pbit_idx].rule_idx[rule_idx]);
+					pr_info("%s\n", buff);
+				}
+			}
+			pr_info("default flow rule:\n");
+			for (pbit_idx = 0; pbit_idx < MV_CPH_PBITS_MAP_MAX_ENTRY_NUM; pbit_idx++) {
+				if ((p_pbits_tbl->def_flow_rule[pbit_idx].num > 0) &&
+				    (p_pbits_tbl->def_flow_rule[pbit_idx].num < MV_CPH_RULE_NUM_PER_ENTRY)) {
+					memset(buff, 0, sizeof(buff));
+					offset = 0;
+					offset += sprintf(buff+offset, "P-bit:%d, number:%d rule_idx:",
+						pbit_idx, p_pbits_tbl->def_flow_rule[pbit_idx].num);
+					for (rule_idx = 0;
+						rule_idx < p_pbits_tbl->def_flow_rule[pbit_idx].num;
+						rule_idx++)
+						offset += sprintf(buff+offset, "[%d]%d ",
+						rule_idx, p_pbits_tbl->def_flow_rule[pbit_idx].rule_idx[rule_idx]);
+					pr_info("%s\n", buff);
+				}
+			}
+		}
+	}
+
+	pr_info("\nP-bits table D/S\n----------------------------------\n");
+	/* Traverse CPH D/S P-bits table */
+	for (idx = 0; idx < MV_CPH_MAX_PBITS_MAP_TABLE_SIZE; idx++) {
+		p_pbits_tbl = &p_cph_db->pbits_tbl[CPH_DIR_DS][idx];
+
+		if (p_pbits_tbl->in_use == TRUE) {
+			pr_info("\nP-bits table:%d\nflow rule:\n", idx);
+			for (pbit_idx = 0; pbit_idx < MV_CPH_PBITS_MAP_MAX_ENTRY_NUM; pbit_idx++) {
+				if ((p_pbits_tbl->flow_rule[pbit_idx].num > 0) &&
+				    (p_pbits_tbl->flow_rule[pbit_idx].num < MV_CPH_RULE_NUM_PER_ENTRY)) {
+					memset(buff, 0, sizeof(buff));
+					offset = 0;
+					offset += sprintf(buff+offset, "P-bit:%d, number:%d rule_idx:",
+						pbit_idx, p_pbits_tbl->flow_rule[pbit_idx].num);
+					for (rule_idx = 0; rule_idx < p_pbits_tbl->flow_rule[pbit_idx].num; rule_idx++)
+						offset += sprintf(buff+offset, "[%d]%d ",
+						rule_idx, p_pbits_tbl->flow_rule[pbit_idx].rule_idx[rule_idx]);
+					pr_info("%s\n\n", buff);
+				}
+			}
+			pr_info("default flow rule:\n");
+			for (pbit_idx = 0; pbit_idx < MV_CPH_PBITS_MAP_MAX_ENTRY_NUM; pbit_idx++) {
+				if ((p_pbits_tbl->def_flow_rule[pbit_idx].num > 0) &&
+				    (p_pbits_tbl->def_flow_rule[pbit_idx].num < MV_CPH_RULE_NUM_PER_ENTRY)) {
+					memset(buff, 0, sizeof(buff));
+					offset = 0;
+					offset += sprintf(buff+offset, "P-bit:%d, number:%d rule_idx:",
+						pbit_idx, p_pbits_tbl->def_flow_rule[pbit_idx].num);
+					for (rule_idx = 0;
+						rule_idx < p_pbits_tbl->def_flow_rule[pbit_idx].num;
+						rule_idx++)
+						offset += sprintf(buff+offset, "[%d]%d ", rule_idx,
+						p_pbits_tbl->def_flow_rule[pbit_idx].rule_idx[rule_idx]);
+					pr_info("%s\n\n", buff);
+				}
+			}
+		}
+	}
+
+	/* Print MC flow rule entries */
+	pr_info("MV_CPH MC Flow Rule Table\n----------------------------------\n");
+	pr_info("Total rule number:%d, Max rule number:%d\n", p_mc_tbl->rule_num, CPH_FLOW_ENTRY_NUM);
+
+	pr_info("----------------------------------------------------------------------------------------------------------------------------------------------------------------\n");
+	pr_info("                                         |Parse outer       |Parse inner       |Mod outer         |Mod Inner         |Forward\n");
+	pr_info("rule_idx dir default parse_bm mh   ety    tpid   vid  pbits  tpid   vid  pbits  tpid   vid  pbits  tpid   vid  pbits  port queue hwf_queue gem  count    op_type\n");
+	/* Traverse CPH flow rule table */
+	for (idx = 0, rule_idx = 0; (idx < CPH_FLOW_ENTRY_NUM) && (rule_idx < p_mc_tbl->rule_num); idx++) {
+		p_flow_rule = &p_mc_tbl->flow_rule[idx];
+		/* Compare parse_bm and parse_key */
+		if (p_flow_rule->valid == TRUE) {
+			rule_idx++;
+
+			pr_info(
+			       "%-8d %2.2s  %3.3s     0x%04x   %-4d 0x%04x 0x%04x %-4d %1d      0x%04x %-4d %1d      " \
+			       "0x%04x %-4d %1d      0x%04x %-4d %1d      %1d    %1d     %1d         %-4d %-8d %s\n",
+			       idx,
+			       cph_app_lookup_dir(p_flow_rule->dir), (p_flow_rule->is_default == TRUE) ? "Yes" : "No ",
+			       p_flow_rule->parse_bm, p_flow_rule->mh, p_flow_rule->eth_type,
+			       p_flow_rule->parse_outer_tci.tpid, p_flow_rule->parse_outer_tci.vid,
+			       p_flow_rule->parse_outer_tci.pbits,
+			       p_flow_rule->parse_inner_tci.tpid, p_flow_rule->parse_inner_tci.vid,
+			       p_flow_rule->parse_inner_tci.pbits,
+			       p_flow_rule->mod_outer_tci.tpid,   p_flow_rule->mod_outer_tci.vid,
+			       p_flow_rule->mod_outer_tci.pbits,
+			       p_flow_rule->mod_inner_tci.tpid,   p_flow_rule->mod_inner_tci.vid,
+			       p_flow_rule->mod_inner_tci.pbits,
+			       p_flow_rule->pkt_frwd.trg_port,    p_flow_rule->pkt_frwd.trg_queue,
+			       p_flow_rule->pkt_frwd.trg_hwf_queue, p_flow_rule->pkt_frwd.gem_port,
+			       p_flow_rule->count,                cph_flow_lookup_op_type(p_flow_rule->op_type));
+		}
+	}
+
+	/* Print  DSCP to P-bits mapping table */
+	offset = 0;
+	pr_info("\nMV_CPH DSCP to P-bits Mapping Table\n----------------------------------\n");
+	if (p_cph_db->dscp_tbl.in_use == FALSE)
+		pr_info("No DSCP to P-bits mapping\n");
+	else {
+		pr_info("DSCP[Pbits]\n");
+		memset(buff, 0, sizeof(buff));
+		for (idx = 0; idx < MV_CPH_DSCP_PBITS_TABLE_MAX_SIZE; idx++) {
+			offset += sprintf(buff+offset, "%2.2d[%2.2d] ", idx, p_cph_db->dscp_tbl.pbits[idx]);
+			if (((idx+1) % 16) == 0)
+				offset += sprintf(buff+offset, "\n");
+		}
+		pr_info("%s\n", buff);
+	}
+	pr_info("\n");
+
+	return MV_OK;
+}
+
+/******************************************************************************
+* cph_flow_init()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Initializes CPH flow mapping data structure.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int  cph_flow_init(void)
+{
+	MV_STATUS rc = MV_OK;
+
+	rc = cph_flow_db_init();
+	CHECK_API_RETURN_AND_LOG_ERROR(rc, "Fail to call cph_flow_db_init");
+
+	return rc;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_flow.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_flow.h
new file mode 100644
index 0000000..a7b8e6f
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_flow.h
@@ -0,0 +1,687 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+	*   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+	*   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+	*   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+********************************************************************************
+* mv_cph_flow.h
+*
+* DESCRIPTION: Marvell CPH(CPH Packet Handler) flow module to handle the
+*              flow mapping, VLAN modification of data traffic
+*
+* DEPENDENCIES:
+*               None
+*
+* CREATED BY:   VictorGu
+*
+* DATE CREATED: 12Dec2011
+*
+* FILE REVISION NUMBER:
+*               Revision: 1.1
+*
+*
+*******************************************************************************/
+#ifndef _MV_CPH_FLOW_H_
+#define _MV_CPH_FLOW_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/******************************************************************************
+*                        Data Enum and Structure
+******************************************************************************/
+#define MV_CPH_TPID_NOT_CARE_VALUE       (0)     /* Does not care for TPID     */
+#define MV_CPH_ZERO_VALUE                (0)     /* zero value                 */
+#define MV_CPH_VID_NOT_CARE_VALUE        (4096)  /* Does not care for VID      */
+#define MV_CPH_PBITS_NOT_CARE_VALUE      (8)     /* Does not care for P-bits   */
+#define MV_CPH_DSCP_NOT_CARE_VALUE       (64)    /* Does not care for DSCP     */
+
+#define MV_CPH_TPID_INVALID_VALUE        (0xFFFF)/* No valid TPID              */
+#define MV_CPH_VID_INVALID_VALUE         (0xFFFF)/* No valid VID               */
+#define MV_CPH_PBITS_INVALID_VALUE       (0xFF)  /* No valid P-bits            */
+#define MV_CPH_DSCP_INVALID_VALUE        (0xFF)  /* No valid DSCP              */
+
+#define MV_CPH_DEFAULT_UNTAG_RULE        (4096+1)/* Default untagged  rule     */
+#define MV_CPH_DEFAULT_SINGLE_TAG_RULE   (4096+2)/* Default sinlge tagged  rule*/
+#define MV_CPH_DEFAULT_DOUBLE_TAG_RULE   (4096+3)/* Default double tagged  rule*/
+
+#define MV_CPH_PBITS_TABLE_INVALID_INDEX (0xFF)     /* Invalid Pbits table index value in VID index table*/
+
+/* VLAN ID index table definition for flow mapping */
+#define MV_CPH_VID_INDEX_TABLE_MAX_SIZE  (4096+4)
+struct CPH_VID_IDX_TBL_T {
+	unsigned char pbit_tbl_idx[MV_CPH_VID_INDEX_TABLE_MAX_SIZE];
+};
+
+/* P-bits flow mapping table definition */
+#define MV_CPH_RULE_NUM_PER_ENTRY   (16)
+struct CPH_PBITS_ENTRY_T {
+	unsigned short    num;        /* total valid cph flow rule number */
+	unsigned short    rule_idx[MV_CPH_RULE_NUM_PER_ENTRY]; /* index to flow rule */
+};
+
+#define MV_CPH_PBITS_MAP_MAX_ENTRY_NUM   (8+1)
+#define MV_CPH_MAX_PBITS_MAP_TABLE_SIZE  (64)
+#define MV_CPH_RESERVED_PBITS_TABLE_NUM  (4)
+
+struct CPH_PBITS_TABLE_T {
+	bool               in_use;
+	struct CPH_PBITS_ENTRY_T  flow_rule[MV_CPH_PBITS_MAP_MAX_ENTRY_NUM];
+	struct CPH_PBITS_ENTRY_T  def_flow_rule[MV_CPH_PBITS_MAP_MAX_ENTRY_NUM];
+};
+
+/* CPH flow mapping rule definition
+------------------------------------------------------------------------------*/
+enum CPH_VLAN_OP_TYPE_E {
+	CPH_VLAN_OP_ASIS                               = 0,
+	CPH_VLAN_OP_DISCARD                            = 1,
+	CPH_VLAN_OP_ADD                                = 2,
+	CPH_VLAN_OP_ADD_COPY_DSCP                      = 3,
+	CPH_VLAN_OP_ADD_COPY_OUTER_PBIT                = 4,
+	CPH_VLAN_OP_ADD_COPY_INNER_PBIT                = 5,
+	CPH_VLAN_OP_ADD_2_TAGS                         = 6,
+	CPH_VLAN_OP_ADD_2_TAGS_COPY_DSCP               = 7,
+	CPH_VLAN_OP_ADD_2_TAGS_COPY_PBIT               = 8,
+	CPH_VLAN_OP_REM                                = 9,
+	CPH_VLAN_OP_REM_2_TAGS                         = 10,
+	CPH_VLAN_OP_REPLACE                            = 11,
+	CPH_VLAN_OP_REPLACE_VID                        = 12,
+	CPH_VLAN_OP_REPLACE_PBIT                       = 13,
+	CPH_VLAN_OP_REPLACE_INNER_ADD_OUTER            = 14,
+	CPH_VLAN_OP_REPLACE_INNER_ADD_OUTER_COPY_PBIT  = 15,
+	CPH_VLAN_OP_REPLACE_INNER_REM_OUTER            = 16,
+	CPH_VLAN_OP_REPLACE_2TAGS                      = 17,
+	CPH_VLAN_OP_REPLACE_2TAGS_VID                  = 18,
+	CPH_VLAN_OP_SWAP                               = 19
+};
+
+struct CPH_FLOW_FRWD_T {
+	unsigned char  trg_port;
+	unsigned char  trg_queue;
+	unsigned char  trg_hwf_queue;
+	unsigned short gem_port;
+};
+
+struct CPH_FLOW_TCI_T {
+	unsigned short  tpid;
+	unsigned short  vid;
+	unsigned char   pbits;
+};
+
+enum CPH_FLOW_PARSE_E {
+	CPH_FLOW_PARSE_MH        = 0x01,  /* parsing Marvell header                          */
+	CPH_FLOW_PARSE_EXT_VLAN  = 0x02,  /* parsing external VLAN tag                       */
+	CPH_FLOW_PARSE_TWO_VLAN  = 0x04,  /* parsing both of external and internal VLAN tags */
+	CPH_FLOW_PARSE_ETH_TYPE  = 0x08,  /* parsing Ethernet type                           */
+	CPH_FLOW_PARSE_MC_PROTO  = 0x10,  /* parsing multicast protocol                      */
+};
+
+enum CPH_TCI_FIELD_E {
+	CPH_TCI_FIELD_VID,
+	CPH_TCI_FIELD_CFI,
+	CPH_TCI_FIELD_PBIT,
+	CPH_TCI_FIELD_VID_PBIT,
+	CPH_TCI_FIELD_ALL,
+};
+
+struct CPH_FLOW_ENTRY_T {
+	bool               valid;
+	enum CPH_DIR_E          dir;
+	enum CPH_FLOW_PARSE_E   parse_bm;
+	bool               is_default;
+	unsigned short             mh;
+	struct CPH_FLOW_TCI_T     parse_outer_tci;
+	struct CPH_FLOW_TCI_T     parse_inner_tci;
+	unsigned short             eth_type;
+	enum CPH_VLAN_OP_TYPE_E op_type;
+	struct CPH_FLOW_TCI_T     mod_outer_tci;
+	struct CPH_FLOW_TCI_T     mod_inner_tci;
+	struct CPH_FLOW_FRWD_T    pkt_frwd;
+	unsigned int             count;
+};
+
+#define CPH_FLOW_ENTRY_NUM   (512)
+
+struct CPH_FLOW_TABLE_T {
+	unsigned int             rule_num;
+	struct CPH_FLOW_ENTRY_T   flow_rule[CPH_FLOW_ENTRY_NUM];
+};
+
+/* DSCP to P-bits mapping table definition
+------------------------------------------------------------------------------*/
+#define MV_CPH_DSCP_PBITS_TABLE_MAX_SIZE  (64)
+struct CPH_DSCP_PBITS_T {
+	unsigned int in_use;
+	unsigned char  pbits[MV_CPH_DSCP_PBITS_TABLE_MAX_SIZE];
+};
+
+/* CPH flow database
+------------------------------------------------------------------------------*/
+struct CPH_FLOW_DB_T {
+	spinlock_t         flow_lock;
+	struct CPH_VID_IDX_TBL_T  vid_idx_tbl[CPH_DIR_NUM];
+	struct CPH_PBITS_TABLE_T  pbits_tbl[CPH_DIR_NUM][MV_CPH_MAX_PBITS_MAP_TABLE_SIZE];
+	struct CPH_FLOW_TABLE_T   flow_tbl;
+	struct CPH_DSCP_PBITS_T   dscp_tbl;
+};
+
+/******************************************************************************
+ *                        Function Declaration
+ ******************************************************************************/
+/******************************************************************************
+* cph_flow_add_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Sets flow mapping rule
+*
+* INPUTS:
+*       cph_flow - VLAN ID, 802.1p value, pkt_fwd information.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int cph_flow_add_rule(struct CPH_FLOW_ENTRY_T *cph_flow);
+
+/******************************************************************************
+* cph_flow_del_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Deletes flow mapping rule
+*
+* INPUTS:
+*       cph_flow - VLAN ID, 802.1p value, pkt_fwd information.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int  cph_flow_del_rule(struct CPH_FLOW_ENTRY_T *cph_flow);
+
+/******************************************************************************
+* cph_flow_clear_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Clears all flow mapping rules
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int cph_flow_clear_rule(void);
+
+/******************************************************************************
+* cph_flow_clear_rule_by_mh()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Clears flow mapping rules by MH
+*
+* INPUTS:
+*       mh   -  Marvell header.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int cph_flow_clear_rule_by_mh(unsigned short mh);
+
+/******************************************************************************
+* cph_flow_get_tag_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Gets flow mapping rule for tagged frames.
+*
+* INPUTS:
+*       cph_flow - Input vid, pbits, dir
+*
+* OUTPUTS:
+*       cph_flow - output packet forwarding information, including GEM port,
+*                  T-CONT, queue and packet modification for VID, P-bits.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int  cph_flow_get_rule(struct CPH_FLOW_ENTRY_T *cph_flow);
+
+/******************************************************************************
+* cph_flow_db_get_rule_by_vid()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Get CPH flow mapping rule by VID, only used to compare packet and db rule.
+*
+* INPUTS:
+*       cph_flow   - Flow parsing field values
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_flow_db_get_rule_by_vid(struct CPH_FLOW_ENTRY_T *cph_flow);
+
+/******************************************************************************
+* cph_flow_set_dscp_map()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Sets DSCP to P-bits mapping rules
+*
+* INPUTS:
+*       dscp_map  - DSCP to P-bits mapping rules.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int cph_flow_set_dscp_map(struct CPH_DSCP_PBITS_T *dscp_map);
+
+/******************************************************************************
+* cph_flow_del_dscp_map()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Deletes DSCP to P-bits mapping rules
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int cph_flow_del_dscp_map(void);
+
+/******************************************************************************
+* cph_flow_add_vlan()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Add one VLAN tag behind of source MAC address.
+*
+* INPUTS:
+*       mh     - Whether has MH or not
+*       p_data - Pointer to packet
+*       tpid   - Type of VLAN ID
+*       vid    - VLAN to be added
+*       pbits  - P-bits value
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       The shift of SKB data.
+*******************************************************************************/
+INLINE int cph_flow_add_vlan(bool mh, unsigned char *p_data, unsigned short tpid,
+	unsigned short vid, unsigned char pbits);
+
+/******************************************************************************
+* cph_flow_del_vlan()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Delete one VLAN tag behind of source MAC address.
+*
+* INPUTS:
+*       mh     - Whether has MH or not
+*       p_data - Pointer to packet.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       The shift of SKB data.
+*******************************************************************************/
+INLINE int cph_flow_del_vlan(bool mh, unsigned char *p_data);
+
+/******************************************************************************
+* cph_flow_replace_vlan()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Replace one VLAN tag behind of source MAC address.
+*
+* INPUTS:
+*       mh     - Whether has MH or not
+*       p_data - Pointer to packet
+*       tpid   - Type of VLAN ID
+*       vid    - VLAN to be added
+*       pbits  - P-bits value
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       The shift of SKB data.
+*******************************************************************************/
+INLINE int cph_flow_replace_vlan(bool mh, unsigned char *p_data, unsigned short tpid,
+	unsigned short vid, unsigned char pbits);
+
+/******************************************************************************
+* cph_flow_swap_vlan()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Swap between two VLAN tag.
+*
+* INPUTS:
+*       mh     - Whether has MH or not
+*       p_data - Pointer to packet
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       The shift of SKB data.
+*******************************************************************************/
+INLINE int cph_flow_swap_vlan(bool mh, unsigned char *p_data);
+
+/******************************************************************************
+* cph_flow_strip_vlan()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Delete all VLAN tags behind of source MAC address.
+*
+* INPUTS:
+*       mh     - Whether has MH or not
+*       p_data - Pointer to packet.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       The shift of SKB data.
+*******************************************************************************/
+INLINE int cph_flow_strip_vlan(bool mh, unsigned char *p_data);
+
+/******************************************************************************
+* cph_flow_compare_rules()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Comparse two flow rules.
+*
+* INPUTS:
+*       parse_rule  - The parsing field values come from the packets
+*       db_rule     - The flow rule stored in flow database
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       In case same, return TRUE,
+*       In case different, return FALSE.
+*******************************************************************************/
+bool cph_flow_compare_rules(struct CPH_FLOW_ENTRY_T *parse_rule, struct CPH_FLOW_ENTRY_T *db_rule);
+
+/******************************************************************************
+* cph_flow_compare_packet_and_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Compare flow packet and rule.
+*
+* INPUTS:
+*       packet_rule - The parsing field values come from the packets
+*       db_rule     - The flow rule stored in flow database
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       In case same, return TRUE,
+*       In case different, return FALSE.
+*******************************************************************************/
+bool cph_flow_compare_packet_and_rule(struct CPH_FLOW_ENTRY_T *packet_rule, struct CPH_FLOW_ENTRY_T *db_rule);
+
+/******************************************************************************
+* cph_flow_compare_packet_and_rule_vid()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Compare flow packet and rule w/ only VID.
+*
+* INPUTS:
+*       packet_rule - The parsing field values come from the packets
+*       db_rule     - The flow rule stored in flow database
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       In case same, return TRUE,
+*       In case different, return FALSE.
+*******************************************************************************/
+bool cph_flow_compare_packet_and_rule_vid(struct CPH_FLOW_ENTRY_T *packet_rule, struct CPH_FLOW_ENTRY_T *db_rule);
+
+/******************************************************************************
+* cph_flow_parse_packet()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Parse packet and output flow information.
+*
+* INPUTS:
+*       port - Source GMAC port
+*       data - Pointer to packet
+*       rx   - Whether in RX dir
+*
+* OUTPUTS:
+*       flow - Flow parsing field values
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_flow_parse_packet(int port, unsigned char *data, bool rx, bool mh, struct CPH_FLOW_ENTRY_T *flow);
+
+/******************************************************************************
+* cph_flow_mod_packet()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Modify packet according to flow rule
+*
+* INPUTS:
+*       skb        - Pointer to packet
+*       mh         - Whether has MH or not
+*       flow       - Flow parsing field values
+*       out_offset - Offset of packet
+*       rx         - Whether RX or TX
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_flow_mod_packet(struct sk_buff *skb,  bool mh, struct CPH_FLOW_ENTRY_T *flow, int *out_offset);
+
+/******************************************************************************
+* cph_flow_mod_frwd()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Modify forwarding parameter of transmiting packet according to flow rule
+*
+* INPUTS:
+*       flow        - Flow parsing field values
+*       tx_spec_out - TX descriptor
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_flow_mod_frwd(struct CPH_FLOW_ENTRY_T *flow, struct mv_eth_tx_spec *tx_spec_out);
+
+/******************************************************************************
+* cph_flow_send_packet()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: CPH function to handle the received application packets
+*
+* INPUTS:
+*       dev_out     - Net device
+*       pkt         - Marvell packet information
+*       tx_spec_out - TX descriptor
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns 1.
+*       On error returns 0.
+*******************************************************************************/
+MV_STATUS cph_flow_send_packet(struct net_device *dev_out,  struct eth_pbuf *pkt,
+	struct mv_eth_tx_spec *tx_spec_out);
+
+/******************************************************************************
+* cph_flow_db_get_rule()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Get CPH flow mapping rule.
+*
+* INPUTS:
+*       flow       - Flow parsing field values
+*       for_packet - Whether get rule for packet or for new CPH rule
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+MV_STATUS cph_flow_db_get_rule(struct CPH_FLOW_ENTRY_T *cph_flow, bool for_packet);
+
+/******************************************************************************
+* cph_flow_lookup_op_type()
+* _____________________________________________________________________________
+*
+* DESCRIPTION:lookup operation type string according to value
+*
+* INPUTS:
+*       enum_value - The enum value to be matched
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       Enum string
+*******************************************************************************/
+char *cph_flow_lookup_op_type(int enum_value);
+
+/******************************************************************************
+* cph_flow_display_all()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: The function displays valid flow mapping tables and DSCP
+*              to P-bits mapping tablefor untagged frames.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int cph_flow_display_all(void);
+
+/******************************************************************************
+* cph_flow_init()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Initializes CPH flow mapping data structure.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int cph_flow_init(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _MV_CPH_FLOW_MAP_H_ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_header.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_header.h
new file mode 100644
index 0000000..7fee81f
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_header.h
@@ -0,0 +1,97 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+	*   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+	*   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+	*   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+********************************************************************************
+* mv_cph_header.h
+*
+* DESCRIPTION: Marvell CPH(CPH Packet Handler) header file
+*
+* DEPENDENCIES:
+*               None
+*
+* CREATED BY:   VictorGu
+*
+* DATE CREATED: 22Jan2013
+*
+* FILE REVISION NUMBER:
+*               Revision: 1.0
+*
+*
+*******************************************************************************/
+#ifndef _MV_CPH_HEADER_H_
+#define _MV_CPH_HEADER_H_
+
+/* Include Files
+------------------------------------------------------------------------------*/
+#include <mvCommon.h>
+#include <mv_pp2/net_dev/mv_netdev.h>
+
+#include "mv_cph_infra.h"
+#include "mv_cph_app.h"
+#include "mv_cph_flow.h"
+#include "mv_cph_db.h"
+#include "mv_cph_api.h"
+#include "mv_cph_mng_if.h"
+#include "mv_cph_dev.h"
+#include "mv_cph_netdev.h"
+#include "mv_cph_sysfs.h"
+
+#endif /* _MV_CPH_HEADER_H_ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_infra.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_infra.c
new file mode 100644
index 0000000..8761b4d
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_infra.c
@@ -0,0 +1,238 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+	*   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+	*   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+	*   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+********************************************************************************
+* mv_cph_infra.c
+*
+* DESCRIPTION: Include user space infrastructure modules definitions
+*
+* DEPENDENCIES:
+*               None
+*
+* CREATED BY:   VictorGu
+*
+* DATE CREATED: 22Jan2013
+*
+* FILE REVISION NUMBER:
+*               Revision: 1.0
+*
+*
+*******************************************************************************/
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/if_vlan.h>
+#include <net/ip.h>
+#include <net/ipv6.h>
+
+#include "mv_cph_header.h"
+
+/******************************************************************************
+* Variable Definition
+******************************************************************************/
+char g_cph_unknown_str[] = "<unknown>";
+
+/******************************************************************************
+* Function Definition
+******************************************************************************/
+/******************************************************************************
+* mindex_tpm_src_to_app_port()
+*
+* DESCRIPTION:Convert TPM source port to application UNI port
+*
+* INPUTS:
+*       src_port    - TPM source port
+*
+* OUTPUTS:
+*       Application UNI port index
+*
+* RETURNS:
+*       On success, the function returns application UNI port index.
+*       On error return invalid application UNI port index.
+*******************************************************************************/
+enum MV_APP_ETH_PORT_UNI_E mindex_tpm_src_to_app_port(enum tpm_src_port_type_t src_port)
+{
+	enum MV_APP_ETH_PORT_UNI_E app_port = MV_APP_ETH_PORT_INVALID;
+
+	/* Should modify below code in case support more than four UNI ports */
+	if (src_port <= TPM_SRC_PORT_UNI_3)
+		app_port = MV_APP_ETH_PORT_INDEX_MIN + (src_port - TPM_SRC_PORT_UNI_0);
+
+	return app_port;
+}
+
+/******************************************************************************
+* mindex_mh_to_app_llid()
+*
+* DESCRIPTION:Convert Marvell header to application LLID
+*
+* INPUTS:
+*       mh  - Marvell header
+*
+* OUTPUTS:
+*       Application LLID
+*
+* RETURNS:
+*       On success, the function returns application LLID.
+*       On error return invalid application LLID.
+*******************************************************************************/
+enum MV_TCONT_LLID_E mindex_mh_to_app_llid(unsigned short mh)
+{
+	enum MV_TCONT_LLID_E llid       = MV_TCONT_LLID_INVALID;
+	unsigned char           llid_index = 0;
+
+	llid_index = (mh >> 8) & 0x0f;
+
+	if (llid_index > 0) {
+		if (0x0f == llid_index) {
+			llid = MV_TCONT_LLID_BROADCAST;
+		} else {
+			llid = llid_index - 1;
+			if (llid > MV_TCONT_LLID_7)
+				llid = MV_TCONT_LLID_INVALID;
+		}
+	}
+
+	return llid;
+}
+
+/******************************************************************************
+* mtype_get_digit_num()
+*
+* DESCRIPTION:Convert character string to digital number
+*
+* INPUTS:
+*       str   - Character string
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       Digital numbe
+*******************************************************************************/
+unsigned int mtype_get_digit_num(const char  *str)
+{
+	unsigned int  val = 0;
+
+	if ((str[1] == 'x') || (str[1] == 'X'))
+		sscanf(&str[2], "%x", &val);
+	else
+		val = simple_strtoul(str, NULL, 10);
+
+	return val;
+}
+
+/******************************************************************************
+* mtype_lookup_enum_str()
+* _____________________________________________________________________________
+*
+* DESCRIPTION:lookup enum string according to enum value
+*
+* INPUTS:
+*       p_enum_array   - Pointer to enum array
+*       enum_value     - The enum value to be matched
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       Enum string
+*******************************************************************************/
+char *mtype_lookup_enum_str(struct MV_ENUM_ARRAY_T *p_enum_array, int enum_value)
+{
+	int idx;
+
+	for (idx = 0; idx < p_enum_array->enum_num; idx++) {
+		if (enum_value == p_enum_array->enum_array[idx].enum_value)
+			return p_enum_array->enum_array[idx].enum_str;
+	}
+	return g_cph_unknown_str;
+}
+
+/******************************************************************************
+* mutils_is_frwd_broadcast_packet()
+* _____________________________________________________________________________
+*
+* DESCRIPTION:Check whether packet is directly forwarded broadcast one
+*
+* INPUTS:
+*       data   - packet data
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       TRUE: broadcast packet, FALSE:none broadcast packet
+*******************************************************************************/
+bool mutils_is_frwd_broadcast_packet(char *data)
+{
+	char bc_mac[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
+	char *p_data;
+
+	p_data = data + MV_ETH_MH_SIZE;
+
+	if (!memcmp(p_data, &bc_mac[0], sizeof(bc_mac)))
+		return TRUE;
+	else
+		return FALSE;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_infra.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_infra.h
new file mode 100644
index 0000000..afe2cc0
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_infra.h
@@ -0,0 +1,500 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+	*   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+	*   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+	*   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+********************************************************************************
+* mv_cph_infra.h
+*
+* DESCRIPTION: Include user space infrastructure modules definitions
+*
+* DEPENDENCIES:
+*               None
+*
+* CREATED BY:   VictorGu
+*
+* DATE CREATED: 22Jan2013
+*
+* FILE REVISION NUMBER:
+*               Revision: 1.0
+*
+*
+*******************************************************************************/
+#ifndef _MV_CPH_INFRA_H_
+#define _MV_CPH_INFRA_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/******************************************************************************
+* Data Type Definition
+******************************************************************************/
+
+#define TRUE               true
+#define FALSE              false
+
+
+/******************************************************************************
+* Port Index Definition
+******************************************************************************/
+/* Ethernet port index */
+#define MV_APP_ETH_PORT_INDEX_MIN 1
+#define MV_APP_ETH_PORT_INDEX_MAX 4
+#define MV_APP_ETH_PORT_NUM       (MV_APP_ETH_PORT_INDEX_MAX-MV_APP_ETH_PORT_INDEX_MIN+1)
+#define MV_APP_ETH_PORTS_NUM      4
+enum MV_APP_ETH_PORT_UNI_E {
+	MV_APP_ETH_PORT_UNI_0   = 1,
+	MV_APP_ETH_PORT_UNI_1,
+	MV_APP_ETH_PORT_UNI_2,
+	MV_APP_ETH_PORT_UNI_3,
+	MV_APP_ETH_PORT_UNI_4,
+	MV_APP_ETH_PORT_UNI_5,
+	MV_APP_ETH_PORT_UNI_6,
+	MV_APP_ETH_PORT_UNI_7,
+	MV_APP_ETH_PORT_INVALID
+};
+
+/* VoIP port index */
+#define MV_APP_VOIP_PORT_INDEX_MIN 1
+#define MV_APP_VOIP_PORT_INDEX_MAX 2
+#define MV_APP_VOIP_PORT_NUM       (MV_APP_VOIP_PORT_INDEX_MAX-MV_APP_VOIP_PORT_INDEX_MIN+1)
+
+enum MV_APP_VOIP_PORT_E {
+	MV_APP_VOIP_PORT_0 = 1,
+	MV_APP_VOIP_PORT_1
+};
+
+/* WIFI SSID port index */
+#define MV_APP_SSID_INDEX_MIN 1
+#define MV_APP_SSID_INDEX_MAX 4
+enum MV_APP_SSID_E {
+	MV_APP_SSID_0 = 1,
+	MV_APP_SSID_1,
+	MV_APP_SSID_2,
+	MV_APP_SSID_3,
+	MV_APP_SSID_4,
+	MV_APP_SSID_5,
+	MV_APP_SSID_6,
+	MV_APP_SSID_7
+};
+
+/* USB port index */
+#define MV_APP_USB_PORT_INDEX_MIN 1
+#define MV_APP_USB_PORT_INDEX_MAX 2
+#define MV_APP_USB_PORT_NUM       (MV_APP_USB_PORT_INDEX_MAX-MV_APP_USB_PORT_INDEX_MIN+1)
+
+enum MV_APP_USB_PORT_E {
+	MV_APP_USB_PORT_0 = 1,
+	MV_APP_USB_PORT_1
+};
+
+/******************************************************************************
+ * GE MAC Port Index Definition
+ ******************************************************************************/
+enum MV_APP_GMAC_PORT_E {
+	MV_APP_GMAC_PORT_0       = 0,
+	MV_APP_GMAC_PORT_1,
+	MV_APP_LPBK_PORT,
+	MV_APP_PON_MAC_PORT,
+	MV_APP_GMAC_PORT_NUM,
+	MV_APP_GMAC_PORT_INVALID = 0xff,
+};
+
+/******************************************************************************
+ * T-CONT/LLID Index Definition
+ ******************************************************************************/
+#define MV_TCONT_LLID_MIN 0
+#define MV_TCONT_LLID_MAX 7
+#define MV_TCONT_LLID_NUM (MV_TCONT_LLID_MAX-MV_TCONT_LLID_MIN+1)
+
+enum MV_TCONT_LLID_E {
+	MV_TCONT_LLID_0 = 0,
+	MV_TCONT_LLID_1,
+	MV_TCONT_LLID_2,
+	MV_TCONT_LLID_3,
+	MV_TCONT_LLID_4,
+	MV_TCONT_LLID_5,
+	MV_TCONT_LLID_6,
+	MV_TCONT_LLID_7,
+	MV_TCONT_LLID_8,
+	MV_TCONT_LLID_9,
+	MV_TCONT_LLID_10,
+	MV_TCONT_LLID_11,
+	MV_TCONT_LLID_12,
+	MV_TCONT_LLID_13,
+	MV_TCONT_LLID_14,
+	MV_TCONT_LLID_15,
+	MV_TCONT_LLID_BROADCAST,
+	MV_TCONT_LLID_INVALID
+};
+
+/******************************************************************************
+* WAN and LAN Index Definition
+******************************************************************************/
+enum MV_APP_PORT_TYPE_E {
+	MV_APP_PORT_WAN = 0,
+	MV_APP_PORT_LAN,
+	MV_APP_PORT_INVALID,
+};
+
+/******************************************************************************
+* GEM Port Index Definition
+******************************************************************************/
+#define MV_GEM_PORT_MIN  0
+#define MV_GEM_PORT_MAX  4095
+#define MV_GEM_PORT_NUM  (MV_GEM_PORT_MAX-MV_GEM_PORT_MIN+1)
+#define MV_GEM_PORT_MASK 0x0FFF
+
+/******************************************************************************
+ * Queue Index Definition
+ ******************************************************************************/
+#define MV_QUEUE_MIN  0
+#define MV_QUEUE_MAX  7
+#define MV_QUEUE_NUM  (MV_QUEUE_MAX-MV_QUEUE_MIN+1)
+#define MV_INVALID_QUEUE_NUM  (0xFF) /* Invalid queue number  */
+
+enum MV_QUEUE_E {
+	MV_QUEUE_0 = 0,
+	MV_QUEUE_1,
+	MV_QUEUE_2,
+	MV_QUEUE_3,
+	MV_QUEUE_4,
+	MV_QUEUE_5,
+	MV_QUEUE_6,
+	MV_QUEUE_7
+};
+
+/******************************************************************************
+* VLAN ID/P-bits Index Definition
+******************************************************************************/
+#define MV_VLAN_ID_MIN  0
+#define MV_VLAN_ID_MAX 4095
+#define MV_VLAN_ID_NUM (MV_VLAN_ID_MAX-MV_VLAN_ID_MIN+1)
+#define MV_VLAN_ID_MASK 0x0FFF
+#define MV_VLAN_ID_INVALID_VALUE 0xFFFF
+
+#define MV_PBITS_MIN   0
+#define MV_PBITS_MAX   7
+#define MV_PBITS_NUM  (MV_PBITS_MAX-MV_PBITS_MIN+1)
+#define MV_PBITS_SHIFT 13
+#define MV_PBITS_MASK 0x07
+#define MV_PBITS_INVALID_VALUE 0xFF
+
+
+/******************************************************************************
+* WAN Port State Definition
+******************************************************************************/
+enum MV_GE_PORT_STATE_E {
+	MV_GE_PORT_INACTIVE = 0,
+	MV_GE_PORT_ACTIVE,
+	MV_GE_PORT_INVALID,
+};
+
+/* Enum for well known TPID
+------------------------------------------------------------------------------*/
+#define MV_TPID_8100 0x8100
+#define MV_TPID_88A8 0x88A8
+#define MV_TPID_9100 0x9100
+#define MV_CPH_TPID_LEN      (2)
+#define MV_CPH_VLAN_TAG_LEN  (2)
+#define MV_CPH_ETH_TYPE_LEN  (2)
+#define MV_IPV4_PROTO_OFFSET (9)
+#define MV_ICMPV6_TYPE_MLD   (1)
+#define MV_CPH_ETH_TYPE_IPV4 (0x0800)
+#define MV_CPH_ETH_TYPE_IPV6 (0x86DD)
+
+
+/******************************************************************************
+* TPM Source port - used to specify through which port the packet entered the processor
+******************************************************************************/
+enum tpm_src_port_type_t {
+	TPM_SRC_PORT_UNI_0,        /* upstream */
+	TPM_SRC_PORT_UNI_1,        /* upstream */
+	TPM_SRC_PORT_UNI_2,        /* upstream */
+	TPM_SRC_PORT_UNI_3,        /* upstream */
+	TPM_SRC_PORT_UNI_4,        /* upstream */
+	TPM_SRC_PORT_UNI_5,        /* upstream */
+	TPM_SRC_PORT_UNI_6,        /* upstream */
+	TPM_SRC_PORT_UNI_7,        /* upstream */
+	TPM_SRC_PORT_UNI_VIRT,     /* upstream */
+	TPM_SRC_PORT_WAN,          /* downstram */
+	TPM_SRC_PORT_UNI_ANY,      /* upstream - all UNI ports */
+	TPM_SRC_PORT_WAN_OR_LAN,   /* Any Port, currently not supported */
+	TPM_SRC_PORT_ILLEGAL = 0xFF
+};
+
+/******************************************************************************
+* Check API return value
+******************************************************************************/
+
+#define INT_TO_MV_BOOL(var)    ((var) ? TRUE : FALSE)
+#define MV_BOOL_TO_INT(var)    (((var) == TRUE) ? 1 : 0)
+
+#define CHECK_API_RETURN_AND_LOG_ERROR(ret, log)\
+{\
+	if (ret != 0) {\
+		pr_err("%s(%d) error:%s , ret(%d)\n", __func__, __LINE__, (log), ret);\
+		return ret;\
+	} \
+} \
+
+#define CPH_IF_NULL(ptr)\
+{\
+	if (ptr == NULL) {\
+		pr_err("%s(%d) NULL pointer\n", __func__, __LINE__);\
+		return MV_BAD_VALUE;\
+	} \
+}
+
+#define CPH_IF_ERROR(rc, format, ...)\
+{\
+	if (rc) {\
+		pr_err("(error) %s(%d)(rc=%d):  "format , __func__, __LINE__, rc, ##__VA_ARGS__);\
+	return rc;\
+	} \
+}
+
+#define CPH_IF_EQUAL(var, expect, format, ...)\
+{\
+	if (var == expect) {\
+		pr_err("%s(%d) (var=%d): "format , __func__, __LINE__, var, ##__VA_ARGS__);\
+		return MV_BAD_VALUE;\
+	} \
+}
+
+#define CPH_IF_NOT_EQUAL(var, expect, format, ...)\
+{\
+	if (var != expect) {\
+		pr_err("%s(%d) (var!=%d): "format , __func__, __LINE__, var, ##__VA_ARGS__);\
+		return MV_BAD_VALUE;\
+	} \
+}
+
+#define CPH_IF_NULL_NO_RET(ptr)\
+{\
+	if (ptr == NULL) {\
+		pr_err("%s(%d) NULL pointer\n", __func__, __LINE__);\
+		return;\
+	} \
+}
+
+#define CPH_DECIMAL_RANGE_VALIDATE(value, min, max) {\
+	if (((value) > (max)) || ((value) < (min))) {\
+		pr_err("(error) %s(%d) value (%d/0x%x) is out of range[%d, %d]\n",\
+		    __func__, __LINE__, (value), (value), (min), (max));\
+		return MV_BAD_VALUE;\
+	} \
+}
+
+#define CPH_HEX_RANGE_VALIDATE(value, min, max) {\
+	if (((value) > (max)) || ((value) < (min))) {\
+		pr_err("(error) %s(%d) value(%d/0x%x) is out of range[0x%X, 0x%X]\n",\
+		    __func__, __LINE__, (value), (value), (min), (max));\
+		return MV_BAD_VALUE;\
+	} \
+}
+
+#define CPH_DECIMAL_RANGE_VALIDATE_STR(value, min, max, str) {\
+	if (((value) > (max)) || ((value) < (min))) {\
+		pr_err("(error) %s(%d) %s(%d/0x%x), out of range[%d, %d]\n",\
+		    __func__, __LINE__, (str), (value), (value), (min), (max));\
+		return MV_BAD_VALUE;\
+	} \
+}
+
+#define CPH_HEX_RANGE_VALIDATE_STR(value, min, max, str) {\
+	if (((value) > (max)) || ((value) < (min))) {\
+		pr_err("(error) %s(%d) %s(%d/0x%x), out of range[0x%X, 0x%X]\n",\
+		    __func__ , __LINE__, (str), (value), (value), (min), (max));\
+		return MV_BAD_VALUE;\
+	} \
+}
+
+#define CPH_BIT_RANGE_VALIDATE(value, str) {\
+	if (((value) != (0)) || ((value) != (1))) {\
+		pr_err("(error) %s(%d) %s(%d/0x%x), out of range[%d, %d]\n",\
+		    __func__, __LINE__, (str), (value), (value), (0), (1));\
+		return MV_BAD_VALUE;\
+	} \
+}
+
+#define CPH_POS_RANGE_VALIDATE(value, max, str) {\
+	if ((value) > (max)) {\
+		pr_err("(error) %s(%d) %s(%d/0x%x), out of range[%d, %d]\n",\
+		    __func__, __LINE__, (str), (value), (value), (0), (max));\
+		return MV_BAD_VALUE;\
+	} \
+}
+
+#define CPH_POS_HEX_RANGE_VALIDATE(value, max, str) {\
+	if ((value) > (max)) {\
+		pr_err("(error) %s(%d) %s(%d/0x%x), out of range[0x%X, 0x%X]\n",\
+		    __func__, __LINE__, (str), (value), (value), (0), (max));\
+		return MV_BAD_VALUE;\
+	} \
+}
+#define CPH_TBL_ENTRY_NUM(a) (sizeof(a)/sizeof(a[0]))
+
+/******************************************************************************
+* Enum for display
+******************************************************************************/
+struct MV_ENUM_ENTRY_T {
+	int  enum_value;
+	char  *enum_str;
+};
+
+struct MV_ENUM_ARRAY_T {
+	int            enum_num;
+	struct MV_ENUM_ENTRY_T *enum_array;
+};
+
+/******************************************************************************
+* Function Declaration
+******************************************************************************/
+/******************************************************************************
+* mindex_tpm_src_to_app_port()
+*
+* DESCRIPTION:Convert TPM source port to application UNI port
+*
+* INPUTS:
+*       src_port    - TPM source port
+*
+* OUTPUTS:
+*       Application UNI port index
+*
+* RETURNS:
+*       On success, the function returns application UNI port index.
+*       On error return invalid application UNI port index.
+*******************************************************************************/
+enum MV_APP_ETH_PORT_UNI_E mindex_tpm_src_to_app_port(enum tpm_src_port_type_t src_port);
+
+/******************************************************************************
+* mindex_mh_to_app_llid()
+*
+* DESCRIPTION:Convert Marvell header to application LLID
+*
+* INPUTS:
+*       mh  - Marvell header
+*
+* OUTPUTS:
+*       Application LLID
+*
+* RETURNS:
+*       On success, the function returns application LLID.
+*       On error return invalid application LLID.
+*******************************************************************************/
+enum MV_TCONT_LLID_E mindex_mh_to_app_llid(unsigned short mh);
+
+/******************************************************************************
+* mtype_get_digit_num()
+*
+* DESCRIPTION:Convert character string to digital number
+*
+* INPUTS:
+*       str   - Character string
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       Digital numbe
+*******************************************************************************/
+unsigned int mtype_get_digit_num(const char  *str);
+
+/******************************************************************************
+* mtype_lookup_enum_str()
+* _____________________________________________________________________________
+*
+* DESCRIPTION:lookup enum string according to enum value
+*
+* INPUTS:
+*       p_enum_array   - Pointer to enum array
+*       enum_value     - The enum value to be matched
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       Enum string
+*******************************************************************************/
+char *mtype_lookup_enum_str(struct MV_ENUM_ARRAY_T *p_enum_array, int enum_value);
+
+/******************************************************************************
+* mutils_is_frwd_broadcast_packet()
+* _____________________________________________________________________________
+*
+* DESCRIPTION:Check whether packet is directly forwarded broadcast one
+*
+* INPUTS:
+*       data   - packet data
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       TRUE: broadcast packet, FALSE:none broadcast packet
+*******************************************************************************/
+bool mutils_is_frwd_broadcast_packet(char *data);
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _MV_CPH_INFRA_H_ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_mng_if.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_mng_if.h
new file mode 100644
index 0000000..157dcd5
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_mng_if.h
@@ -0,0 +1,162 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+	*   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+	*   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+	*   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+********************************************************************************
+* mv_cph_mng_if.h
+*
+* DESCRIPTION: Marvell CPH(CPH Packet Handler) management interface definition
+*              for ioctl
+*
+* DEPENDENCIES:
+*               None
+*
+* CREATED BY:   VictorGu
+*
+* DATE CREATED: 11Dec2011
+*
+* FILE REVISION NUMBER:
+*               Revision: 1.1
+*
+*
+*******************************************************************************/
+#ifndef _MV_CPH_MNG_IF_H_
+#define _MV_CPH_MNG_IF_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* Include Files
+------------------------------------------------------------------------------*/
+#include <linux/cdev.h>
+
+/* Definitions
+------------------------------------------------------------------------------*/
+#define MV_CPH_IOCTL_SET_COMPLEX_PROFILE      _IOW(MV_CPH_IOCTL_MAGIC,  1,  unsigned int)
+#define MV_CPH_IOCTL_SET_FEATURE_FLAG         _IOW(MV_CPH_IOCTL_MAGIC,  2,  unsigned int)
+#define MV_CPH_IOCTL_APP_ADD_RULE             _IOW(MV_CPH_IOCTL_MAGIC,  3,  unsigned int)
+#define MV_CPH_IOCTL_APP_DEL_RULE             _IOW(MV_CPH_IOCTL_MAGIC,  4,  unsigned int)
+#define MV_CPH_IOCTL_APP_UPDATE_RULE          _IOW(MV_CPH_IOCTL_MAGIC,  5,  unsigned int)
+#define MV_CPH_IOCTL_APP_GET_RULE             _IOR(MV_CPH_IOCTL_MAGIC,  6,  unsigned int)
+#define MV_CPH_IOCTL_FLOW_ADD_RULE            _IOW(MV_CPH_IOCTL_MAGIC,  7,  unsigned int)
+#define MV_CPH_IOCTL_FLOW_DEL_RULE            _IOW(MV_CPH_IOCTL_MAGIC,  8,  unsigned int)
+#define MV_CPH_IOCTL_FLOW_GET_RULE            _IOR(MV_CPH_IOCTL_MAGIC,  9,  unsigned int)
+#define MV_CPH_IOCTL_FLOW_CLEAR_RULE          _IOW(MV_CPH_IOCTL_MAGIC,  10, unsigned int)
+#define MV_CPH_IOCTL_FLOW_CLEAR_RULE_BY_MH    _IOW(MV_CPH_IOCTL_MAGIC,  11, unsigned int)
+#define MV_CPH_IOCTL_FLOW_SET_DSCP_MAP        _IOW(MV_CPH_IOCTL_MAGIC,  12, unsigned int)
+#define MV_CPH_IOCTL_FLOW_DEL_DSCP_MAP        _IOW(MV_CPH_IOCTL_MAGIC,  13, unsigned int)
+#define MV_CPH_IOCTL_SET_TCONT_LLID_STATE     _IOW(MV_CPH_IOCTL_MAGIC,  14, unsigned int)
+#define MV_CPH_IOCTL_SETUP                    _IOW(MV_CPH_IOCTL_MAGIC,  15, unsigned int)
+
+/* Typedefs
+------------------------------------------------------------------------------*/
+struct CPH_IOCTL_APP_RULE_T {
+	enum CPH_APP_PARSE_FIELD_E parse_bm;
+	struct CPH_APP_PARSE_T       parse_key;
+	enum CPH_APP_MOD_FIELD_E   mod_bm;
+	struct CPH_APP_MOD_T         mod_value;
+	enum CPH_APP_FRWD_FIELD_E  frwd_bm;
+	struct CPH_APP_FRWD_T        frwd_value;
+};
+
+struct CPH_IOCTL_FLOW_MAP_T {
+	struct CPH_FLOW_ENTRY_T flow_map;
+};
+
+struct CPH_IOCTL_DSCP_MAP_T {
+	struct CPH_DSCP_PBITS_T dscp_map;
+};
+
+struct CPH_IOCTL_MISC_T {
+	enum tpm_eth_complex_profile_t profile_id;
+	enum MV_APP_GMAC_PORT_E        active_port;
+	enum CPH_APP_FEATURE_E         feature_type;
+	bool                      feature_flag;
+};
+
+struct CPH_IOCTL_TCONT_STATE_T {
+	unsigned int  tcont;
+	bool    state;
+};
+
+/* MV CPH Char Device Structure */
+struct CPH_CDEV_T {
+	struct CPH_IOCTL_APP_RULE_T    cph_ioctl_app_rule;
+	struct CPH_IOCTL_FLOW_MAP_T    cph_ioctl_flow_map;
+	struct CPH_IOCTL_DSCP_MAP_T    cph_ioctl_dscp_map;
+	struct CPH_IOCTL_MISC_T        cph_ioctl_misc;
+	struct CPH_IOCTL_TCONT_STATE_T cph_ioctl_tcont;
+
+	struct cdev             cdev;
+};
+
+/* Global variables
+------------------------------------------------------------------------------*/
+
+/* Global functions
+------------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _MV_CPH_MNG_IF_H_ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_mod.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_mod.c
new file mode 100644
index 0000000..6150da7
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_mod.c
@@ -0,0 +1,142 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+	*   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+	*   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+	*   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+********************************************************************************
+* mv_cph_mod.c
+*
+* DESCRIPTION: Marvell CPH(CPH Packet Handler) module definition
+*
+* DEPENDENCIES:
+*               None
+*
+* CREATED BY:   VictorGu
+*
+* DATE CREATED: 22Jan2013
+*
+* FILE REVISION NUMBER:
+*               Revision: 1.0
+*
+*
+*******************************************************************************/
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+
+#include "mv_cph_header.h"
+
+#define CPH_MODULE_VERSION  "22-Jan-2013"
+#define CPH_MODULE_DESC     "Marvell CPU Packet Handler Module"
+
+/******************************************************************************
+* cph_mod_exit()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Exit from CPH module
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       None.
+*******************************************************************************/
+static void __exit cph_mod_exit(void)
+{
+	cph_dev_shutdown();
+}
+
+/******************************************************************************
+* cph_mod_init()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Initialize CPH module
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+static int __init cph_mod_init(void)
+{
+	if (cph_dev_init() != 0) {
+		pr_err("\nCPH module initialization failed\n\n");
+		return MV_ERROR;
+	}
+
+	/* pr_info("\nCPH module inserted - %s\n\n", CPH_MODULE_VERSION); */
+
+	return MV_OK;
+}
+
+device_initcall_sync(cph_mod_init);
+
+module_exit(cph_mod_exit);
+
+MODULE_AUTHOR("Victor Gu");
+MODULE_VERSION(CPH_MODULE_VERSION);
+MODULE_DESCRIPTION(CPH_MODULE_DESC);
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_netdev.c
new file mode 100644
index 0000000..e5c2c13
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_netdev.c
@@ -0,0 +1,861 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+	*   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+	*   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+	*   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+********************************************************************************
+* mv_cph_netdev.c
+*
+* DESCRIPTION: Marvell CPH(CPH Packet Handler) network device part definition
+*
+* DEPENDENCIES:
+*               None
+*
+* CREATED BY:   VictorGu
+*
+* DATE CREATED: 22Jan2013
+*
+* FILE REVISION NUMBER:
+*               Revision: 1.1
+*
+*
+*******************************************************************************/
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/if_vlan.h>
+#include <net/ip.h>
+#include <net/ipv6.h>
+#include <linux/icmpv6.h>
+
+#include <ctrlEnv/mvCtrlEnvLib.h>
+
+#include "mvDebug.h"
+#include "mv_cph_header.h"
+
+
+/******************************************************************************
+*                           Global Definition
+******************************************************************************/
+#define MV_MUX_SKB_TAG_VAL		(0xabcd)
+
+/* Total Eth port number */
+static int gs_mv_eth_port_num;
+
+
+#ifdef CONFIG_MV_CPH_UDP_SAMPLE_HANDLE
+static struct mv_port_tx_spec    udp_port_spec_cfg[MV_APP_ETH_PORTS_NUM];
+#define PORT_ENTRIES        CPH_TBL_ENTRY_NUM(udp_port_spec_cfg)
+#endif
+
+/******************************************************************************
+*                           External Declarations
+******************************************************************************/
+
+/******************************************************************************
+*                           Function Definitions
+******************************************************************************/
+/******************************************************************************
+* cph_rec_skb()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Send SKB packet to linux network and increse counter
+*
+* INPUTS:
+*       port    - Gmac port the packet from
+*       skb     - SKB buffer to receive packet
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       None.
+*******************************************************************************/
+void cph_rec_skb(int port, struct sk_buff *skb)
+{
+	unsigned int rx_status    = 0;
+	struct eth_port *pp = NULL;
+
+	rx_status = netif_receive_skb(skb);
+	pp        = mv_eth_port_by_id(port);
+	if (rx_status)
+		STAT_DBG(pp->stats.rx_drop_sw++);
+}
+
+#ifdef CONFIG_MV_CPH_UDP_SAMPLE_HANDLE
+static inline void cph_copy_tx_spec(struct mv_eth_tx_spec *tx_spec,
+					uint8_t txp, uint8_t txq,
+					uint16_t flags, uint32_t hw_cmd)
+{
+	tx_spec->txp = txp;
+	tx_spec->txq = txq;
+	tx_spec->hw_cmd[0] = hw_cmd;
+	tx_spec->flags = flags;
+}
+
+int cph_udp_spec_print(int port)
+{
+	int i;
+	struct eth_port *pp = mv_eth_port_by_id(port);
+	struct mv_udp_port_tx_spec *udp_spec;
+
+	if (!pp)
+		return -ENODEV;
+
+	udp_spec = &(udp_port_spec_cfg[port].udp_dst[0]);
+
+	pr_err("\n**** port #%d - TX UDP Dest Port configuration *****\n", port);
+	pr_err("----------------------------------------------------\n");
+	pr_err("ID udp_dst   txp    txq    flags    hw_cmd     func_add\n");
+	for (i = 0; i < sizeof(udp_port_spec_cfg[port].udp_dst)/sizeof(udp_port_spec_cfg[port].udp_dst[0]); i++) {
+		if (udp_spec[i].tx_spec.txq != MV_ETH_TXQ_INVALID)
+			pr_err("%2d   %04d      %d      %d     0x%04lx   0x%08x   0x%p\n",
+			       i, ntohs(udp_spec[i].udp_port),
+			       udp_spec[i].tx_spec.txp, udp_spec[i].tx_spec.txq,
+			       udp_spec[i].tx_spec.flags, udp_spec[i].tx_spec.hw_cmd[0],
+			       udp_spec[i].tx_spec.tx_func);
+	}
+	pr_err("-----------------------------------------------------\n");
+
+	udp_spec = &(udp_port_spec_cfg[port].udp_src[0]);
+
+	pr_err("**** port #%d - TX UDP Source Port configuration *****\n", port);
+	pr_err("-----------------------------------------------------\n");
+	pr_err("ID udp_src   txp    txq     flags    hw_cmd     func_add\n");
+	for (i = 0; i < sizeof(udp_port_spec_cfg[port].udp_src)/sizeof(udp_port_spec_cfg[port].udp_src[0]); i++) {
+		if (udp_spec[i].tx_spec.txq != MV_ETH_TXQ_INVALID)
+			pr_err("%2d   %04d      %d      %d     0x%04lx   0x%08x   0x%p\n",
+			       i, ntohs(udp_spec[i].udp_port),
+			       udp_spec[i].tx_spec.txp, udp_spec[i].tx_spec.txq,
+			       udp_spec[i].tx_spec.flags, udp_spec[i].tx_spec.hw_cmd[0],
+			       udp_spec[i].tx_spec.tx_func);
+	}
+	pr_err("**************************************************************\n");
+
+	return 0;
+}
+
+
+void cph_udp_spec_print_all(void)
+{
+	int port;
+
+	for (port = 0; port < MV_APP_ETH_PORTS_NUM; port++)
+		cph_udp_spec_print(port);
+}
+
+MV_STATUS  cph_udp_int_spec_set(struct mv_udp_port_tx_spec *udp_spec, uint16_t udp_port, int table_size,
+				uint8_t txp, uint8_t txq, uint16_t flags, uint32_t hw_cmd)
+{
+	int i;
+
+	/* Check if already exists */
+	for (i = 0; i < table_size; i++) {
+		if (udp_spec[i].udp_port == htons(udp_port) &&
+		    udp_spec[i].tx_spec.txq != MV_ETH_TXQ_INVALID) {
+			cph_copy_tx_spec(&(udp_spec[i].tx_spec), txp, txq, flags, hw_cmd);
+			return MV_OK;
+		}
+	}
+	/* Check empty */
+	for (i = 0; i < table_size; i++) {
+		if (udp_spec[i].tx_spec.txq == MV_ETH_TXQ_INVALID) {
+			udp_spec[i].udp_port = htons(udp_port);
+			cph_copy_tx_spec(&(udp_spec[i].tx_spec), txp, txq, flags, hw_cmd);
+			return MV_OK;
+		}
+	}
+
+	return MV_FULL;
+}
+
+
+MV_STATUS  cph_udp_src_spec_set(int tx_port, uint16_t udp_src_port, uint8_t txp,
+	uint8_t txq, uint16_t flags, uint32_t hw_cmd)
+{
+	struct eth_port *pp = mv_eth_port_by_id(tx_port);
+	struct mv_udp_port_tx_spec *udp_src_spec = udp_port_spec_cfg[tx_port].udp_src;
+	MV_STATUS mv_status;
+
+	if (!pp)
+		return -ENODEV;
+
+	mv_status = cph_udp_int_spec_set(udp_src_spec, udp_src_port,
+					MV_CPH_MAS_UDP_SRC_PORT,
+					txp, txq, flags, hw_cmd);
+
+	if (mv_status != MV_OK)
+		pr_err("%s: UDP Special Source Port Table is full\n", __func__);
+
+	return mv_status;
+}
+EXPORT_SYMBOL(cph_udp_src_spec_set);
+
+
+MV_STATUS  cph_udp_dest_spec_set(int tx_port, uint16_t udp_dest_port, uint8_t txp,
+	uint8_t txq, uint16_t flags, uint32_t hw_cmd)
+{
+	struct eth_port *pp = mv_eth_port_by_id(tx_port);
+	struct mv_udp_port_tx_spec *udp_dst_spec = udp_port_spec_cfg[tx_port].udp_dst;
+	MV_STATUS mv_status;
+
+	if (!pp)
+		return -ENODEV;
+
+	mv_status = cph_udp_int_spec_set(udp_dst_spec, udp_dest_port,
+					MV_CPH_MAS_UDP_DST_PORT,
+					txp, txq, flags, hw_cmd);
+
+	if (mv_status != MV_OK)
+		pr_err("%s: UDP Special Dest. Port Table is full\n", __func__);
+
+	return mv_status;
+}
+EXPORT_SYMBOL(cph_udp_dest_spec_set);
+
+
+void cph_udp_table_init(void)
+{
+	int num_ports = PORT_ENTRIES;
+	int tx_port, i;
+
+	if (num_ports > gs_mv_eth_port_num)
+		num_ports = gs_mv_eth_port_num;
+
+	for (tx_port = 0; tx_port < num_ports; tx_port++) {
+		/* Invalidate UDP Dest ports, set txq=invalid  */
+		for (i = 0; i < MV_CPH_MAS_UDP_DST_PORT; i++) {
+			memset(&(udp_port_spec_cfg[tx_port].udp_dst[i]), 0, sizeof(struct mv_udp_port_tx_spec));
+			udp_port_spec_cfg[tx_port].udp_dst[i].tx_spec.txq = MV_ETH_TXQ_INVALID;
+		}
+
+		/* Invalidate UDP Source ports, , set txq=invalid */
+		for (i = 0; i < MV_CPH_MAS_UDP_SRC_PORT; i++) {
+			memset(&(udp_port_spec_cfg[tx_port].udp_src[i]), 0, sizeof(struct mv_udp_port_tx_spec));
+			udp_port_spec_cfg[tx_port].udp_src[i].tx_spec.txq = MV_ETH_TXQ_INVALID;
+		}
+
+	}
+	return;
+}
+
+int cph_udp_port_tx(int port, struct net_device *dev, struct sk_buff *skb,
+		struct mv_eth_tx_spec *tx_spec_out)
+{
+	struct iphdr  *iphdrp   = NULL;
+	struct udphdr *udphdrp  = NULL;
+	int i;
+
+	if (port >= MV_APP_ETH_PORTS_NUM) {
+		pr_err("Port Error\n");
+		return 0;
+	}
+
+	if (skb->protocol == MV_CPH_ETH_TYPE_IPV4) {
+		/* Get UDP Port */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 22)
+		iphdrp = skb->nh.iph;
+#else
+		iphdrp = ip_hdr(skb);
+#endif
+
+	if ((iphdrp) && (iphdrp->protocol == IPPROTO_UDP)) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 22)
+		udphdrp = skb->h.uh;
+#else
+		udphdrp = udp_hdr(skb);
+#endif
+			if (udphdrp) {
+				if (udphdrp == (struct udphdr *)iphdrp)
+					udphdrp = (struct udphdr *)((char *)udphdrp + (4*(iphdrp->ihl)));
+				/* Find configured UDP Source Port*/
+				for (i = 0; i < MV_CPH_MAS_UDP_SRC_PORT; i++) {
+					if ((udphdrp->source == udp_port_spec_cfg[port].udp_src[i].udp_port) &&
+					(udp_port_spec_cfg[port].udp_src[i].tx_spec.txq != MV_ETH_TXQ_INVALID)) {
+						memcpy(tx_spec_out, &(udp_port_spec_cfg[port].udp_src[i].tx_spec),
+							sizeof(struct mv_eth_tx_spec));
+						MV_CPH_PRINT(CPH_DEBUG_LEVEL, "found udp_src 0x(%04x)\n",
+							ntohs(udphdrp->source));
+						return 1;
+					}
+				}
+				/* Find configured UDP Dest. Port*/
+				for (i = 0; i < MV_CPH_MAS_UDP_DST_PORT; i++) {
+					if ((udphdrp->dest == udp_port_spec_cfg[port].udp_dst[i].udp_port) &&
+					(udp_port_spec_cfg[port].udp_src[i].tx_spec.txq != MV_ETH_TXQ_INVALID)) {
+						memcpy(tx_spec_out, &(udp_port_spec_cfg[port].udp_dst[i].tx_spec),
+							sizeof(struct mv_eth_tx_spec));
+						MV_CPH_PRINT(CPH_DEBUG_LEVEL, "found udp_dst 0x(%04x)\n",
+							ntohs(udphdrp->dest));
+						return 1;
+					}
+				}
+
+				if (port == MV_CPH_PON_PORT_IDX) {
+					MV_CPH_PRINT(CPH_DEBUG_LEVEL, "Packet UDP, udp source or dest port not found");
+					MV_CPH_PRINT(CPH_DEBUG_LEVEL, " udp_src(%x)x udp_dst(%x)x\n",
+						ntohs(udphdrp->source), ntohs(udphdrp->dest));
+				}
+			}
+		} else if (port == MV_CPH_PON_PORT_IDX)
+			MV_CPH_PRINT(CPH_DEBUG_LEVEL, "NOT UDP, ip_proto(%d)\n", iphdrp->protocol);
+	} else if (port == MV_CPH_PON_PORT_IDX)
+		MV_CPH_PRINT(CPH_DEBUG_LEVEL, "NOT IP, proto(%d)\n", skb->protocol);
+
+	return 0;
+}
+#endif
+
+
+#ifdef CONFIG_MV_CPH_FLOW_MAP_HANDLE
+/******************************************************************************
+* cph_data_flow_rx()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: CPH function to handle the received application packets
+*
+* INPUTS:
+*       port    - Gmac port the packet from
+*       dev     - Net device
+*       skb     - SKB buffer to receive packet
+*       rx_desc - RX descriptor
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns 1.
+*       On error returns 0.
+*******************************************************************************/
+static int cph_data_flow_rx(int port, struct net_device *dev, struct sk_buff *skb, struct pp2_rx_desc *rx_desc)
+{
+	struct CPH_FLOW_ENTRY_T flow_rule;
+	int            offset = 0;
+	bool             state  = FALSE;
+	MV_STATUS        rc     = MV_OK;
+
+	if (MV_CPH_PON_PORT_IDX != port)
+		return 0;
+
+	cph_db_get_param(CPH_DB_PARAM_FLOW_SUPPORT, &state);
+
+	if (state == TRUE) {
+		/* Parse packets */
+		rc = cph_flow_parse_packet(port, skb->data, TRUE, TRUE, &flow_rule);
+		if (rc != MV_OK) {
+			MV_CPH_PRINT(CPH_ERR_LEVEL, "%s():fail to call cph_flow_parse_packet, rc(%d)\n", __func__, rc);
+			return 0;
+		}
+
+		/* Get None default CPH data flow rule at first */
+		flow_rule.is_default = FALSE;
+		rc = cph_flow_db_get_rule(&flow_rule, MV_TRUE);
+		if (rc != MV_OK) {
+			/* Get default CPH data flow rule secondly */
+			flow_rule.is_default = TRUE;
+			rc = cph_flow_db_get_rule(&flow_rule, MV_TRUE);
+			/* Do nothing */
+			if (rc != MV_OK)
+				return 0;
+		}
+
+		/* modify packet */
+		rc = cph_flow_mod_packet(skb, TRUE, &flow_rule, &offset);
+		if (rc != MV_OK) {
+			MV_CPH_PRINT(CPH_ERR_LEVEL, "%s():fail to call cph_flow_mod_rx_packet, rc(%d)\n", __func__, rc);
+			return 0;
+		}
+
+		return 1;
+	}
+
+	return 0;
+}
+
+/******************************************************************************
+* cph_data_flow_tx()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: CPH function to handle the trasmiting application packets
+*
+* INPUTS:
+*       port        - Gmac port the packet from
+*       dev         - Net device
+*       skb         - SKB buffer to receive packet
+*       tx_spec_out - TX descriptor
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns 1.
+*       On error returns 0.
+*******************************************************************************/
+int cph_data_flow_tx(int port, struct net_device *dev, struct sk_buff *skb,
+			bool mh, struct mv_eth_tx_spec *tx_spec_out)
+{
+	struct CPH_FLOW_ENTRY_T flow_rule;
+	int            offset = 0;
+	bool             l_mh;
+	bool             state  = FALSE;
+	MV_STATUS        rc     = MV_OK;
+
+	if (MV_CPH_PON_PORT_IDX != port)
+		return 0;
+
+	cph_db_get_param(CPH_DB_PARAM_FLOW_SUPPORT, &state);
+
+	if (state == TRUE)
+		return 0;
+
+	/* Decide whether need to handle Marvell header */
+	l_mh = mh;
+	if (TRUE == mutils_is_frwd_broadcast_packet(skb->data))
+		l_mh = TRUE;
+
+	/* Parse packets */
+	rc = cph_flow_parse_packet(port, skb->data, FALSE, l_mh, &flow_rule);
+	if (rc != MV_OK) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "%s():fail to call cph_flow_parse_packet, rc<%d>\n", __func__, rc);
+		return 0;
+	}
+
+	/* Get CPH data flow rule */
+	flow_rule.is_default = FALSE;
+	rc = cph_flow_db_get_rule(&flow_rule, MV_TRUE);
+	if (rc != MV_OK) {
+		/* Handle multicat packets as unicast one */
+		if (flow_rule.parse_bm & CPH_FLOW_PARSE_MC_PROTO) {
+			flow_rule.parse_bm &= ~CPH_FLOW_PARSE_MC_PROTO;
+			rc = cph_flow_db_get_rule_by_vid(&flow_rule);
+			if (rc != MV_OK) {
+				rc = cph_flow_db_get_rule(&flow_rule, MV_TRUE);
+
+				if (rc != MV_OK) {
+					flow_rule.is_default = TRUE;
+					flow_rule.parse_outer_tci.vid   = MV_CPH_VID_NOT_CARE_VALUE;
+					flow_rule.parse_outer_tci.pbits = MV_CPH_PBITS_NOT_CARE_VALUE;
+					rc = cph_flow_db_get_rule(&flow_rule, MV_TRUE);
+					if (rc != MV_OK) {
+						MV_CPH_PRINT(CPH_DEBUG_LEVEL,
+							"%s():fail to call cph_flow_get_rule, rc<%d>\n",
+							__func__, rc);
+						return 0;
+					}
+				}
+			}
+		} else {
+			flow_rule.is_default = TRUE;
+			flow_rule.parse_outer_tci.vid   = MV_CPH_VID_NOT_CARE_VALUE;
+			flow_rule.parse_outer_tci.pbits = MV_CPH_PBITS_NOT_CARE_VALUE;
+			rc = cph_flow_db_get_rule(&flow_rule, MV_TRUE);
+			if (rc != MV_OK) {
+				MV_CPH_PRINT(CPH_DEBUG_LEVEL, "%s():fail to call cph_flow_get_rule, rc<%d>\n",
+					__func__, rc);
+				return 0;
+			}
+		}
+	}
+
+	/* modify packet */
+	rc = cph_flow_mod_packet(skb, l_mh, &flow_rule, &offset);
+	if (rc != MV_OK) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "%s():fail to call cph_flow_mod_rx_packet, rc<%d>\n", __func__, rc);
+		return 0;
+	}
+
+	/* Strip TX MH */
+	if (TRUE == l_mh) {
+		skb->data  += MV_ETH_MH_SIZE;
+		skb->len   -= MV_ETH_MH_SIZE;
+	}
+
+	/* modify packet */
+	rc = cph_flow_mod_frwd(&flow_rule, tx_spec_out);
+	if (rc != MV_OK) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "%s():fail to call cph_flow_mod_frwd, rc<%d>\n", __func__, rc);
+		return 0;
+	}
+	return 1;
+}
+#endif
+
+/******************************************************************************
+* cph_app_packet_rx()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: CPH function to handle the received application packets
+*
+* INPUTS:
+*       port    - Gmac port the packet from
+*       dev     - Net device
+*       skb     - SKB buffer to receive packet
+*       rx_desc - RX descriptor
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns 1.
+*       On error returns 0.
+*******************************************************************************/
+static int cph_app_packet_rx(int port, struct net_device *dev, struct sk_buff *skb, struct pp2_rx_desc *rx_desc)
+{
+	enum CPH_APP_PARSE_FIELD_E parse_bm = 0;
+	struct CPH_APP_PARSE_T       parse_key;
+	int                 rc       = MV_OK;
+	enum CPH_APP_MOD_FIELD_E   mod_bm   = 0;
+	struct CPH_APP_MOD_T         mod_value;
+	enum CPH_APP_FRWD_FIELD_E  frwd_bm  = 0;
+	struct CPH_APP_FRWD_T        frwd_value;
+	bool                  state    = FALSE;
+
+	/* Check whether need to handle generic application packet */
+	cph_db_get_param(CPH_DB_PARAM_APP_SUPPORT, &state);
+	if (state == FALSE)
+		return 0;
+
+	memset(&parse_key,  0, sizeof(parse_key));
+	memset(&mod_value,  0, sizeof(mod_value));
+	memset(&frwd_value, 0, sizeof(frwd_value));
+
+	/* Parse application packet */
+	rc = cph_app_parse_packet(port, skb->data, &parse_bm, &parse_key);
+	if (rc != MV_OK) {
+		pr_err("Fail to call cph_app_parse_packet, rc(%d)\n", rc);
+		return 0;
+	}
+
+	/* Get CPH application rule */
+	rc = cph_app_get_rule(parse_bm, &parse_key, &mod_bm, &mod_value, &frwd_bm, &frwd_value);
+	if (rc != MV_OK) {
+		pr_err(KERN_DEBUG "Fail to call cph_app_get_rule, rc(%d)\n", rc);
+		return 0;
+	}
+
+	/* Increase counter */
+	rc = cph_app_increase_counter(parse_bm, &parse_key);
+	if (rc != MV_OK) {
+		pr_err("Fail to call cph_app_increase_counter, rc(%d)\n", rc);
+		return 0;
+	}
+
+	/* Apply modification */
+	rc = cph_app_mod_rx_packet(port, dev, skb, rx_desc, mod_bm, &mod_value);
+	if (rc != MV_OK) {
+		pr_err("Fail to call cph_app_mod_rx_packet, rc(%d)\n", rc);
+		return 0;
+	}
+
+	/* Send to Linux Network Stack */
+	cph_rec_skb(port, skb);
+
+	return 1;
+}
+
+/******************************************************************************
+* cph_app_packet_tx()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: CPH function to handle the trasmiting application packets
+*
+* INPUTS:
+*       port        - Gmac port the packet from
+*       dev         - Net device
+*       skb         - SKB buffer to receive packet
+*       tx_spec_out - TX descriptor
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns 1.
+*       On error returns 0.
+*******************************************************************************/
+int cph_app_packet_tx(int port, struct net_device *dev, struct sk_buff *skb,
+			struct mv_eth_tx_spec *tx_spec_out)
+{
+	enum CPH_DIR_E             dir;
+	unsigned short                proto_type = 0;
+	enum CPH_APP_PARSE_FIELD_E parse_bm   = 0;
+	struct CPH_APP_PARSE_T       parse_key;
+	enum CPH_APP_MOD_FIELD_E   mod_bm     = 0;
+	struct CPH_APP_MOD_T         mod_value;
+	enum CPH_APP_FRWD_FIELD_E  frwd_bm    = 0;
+	struct CPH_APP_FRWD_T        frwd_value;
+	int                 rc         = MV_OK;
+	bool                  state      = FALSE;
+
+	/* Check whether need to handle generic application packet */
+	cph_db_get_param(CPH_DB_PARAM_APP_SUPPORT, &state);
+	if (state == FALSE)
+		return 0;
+
+	memset(&parse_key,  0, sizeof(parse_key));
+	memset(&mod_value,  0, sizeof(mod_value));
+	memset(&frwd_value, 0, sizeof(frwd_value));
+	tx_spec_out->tx_func = NULL;
+	tx_spec_out->flags   = 0;
+
+	/* Get direction of packet */
+	dir = cph_app_parse_dir(port, FALSE);
+	if (dir == CPH_DIR_INVALID) {
+		MV_CPH_PRINT(CPH_ERR_LEVEL, "dir[%d] is invalid\n", dir);
+		return 0;
+	}
+
+	/* Get the protocol type application packet */
+	proto_type = skb->protocol;
+
+	/* Get CPH application rule by protocol type */
+	rc = cph_app_get_rule_by_dir_proto(dir, proto_type, &parse_bm,
+					&parse_key, &mod_bm, &mod_value, &frwd_bm, &frwd_value);
+	if (rc != MV_OK)
+		return 0;
+
+	/* Increase counter */
+	rc = cph_app_increase_counter_by_dir_proto(dir, proto_type);
+	if (rc != MV_OK) {
+		pr_err("Fail to call cph_app_increase_counter_by_dir_proto, rc(%d)\n", rc);
+		return 0;
+	}
+
+	/* Sepcial handling for IGMP and MLD */
+	if (((parse_bm & CPH_APP_PARSE_FIELD_IPV4_TYPE) &&
+		(parse_key.ipv4_type == MV_IP_PROTO_IGMP))  ||
+		((parse_bm & CPH_APP_PARSE_FIELD_ICMPV6_TYPE) &&
+		(parse_key.icmpv6_type == MV_ICMPV6_TYPE_MLD))) {
+		/* only handle U/S multicast protocol packet in U/S */
+		if (dir == CPH_DIR_US) {
+			if (cph_data_flow_tx(port, dev, skb, TRUE, tx_spec_out))
+				return 1;
+		}
+	}
+
+	/* Apply modification and set forwarding information */
+	rc = cph_app_mod_tx_packet(skb, tx_spec_out, mod_bm, &mod_value);
+	if (rc != MV_OK) {
+		pr_err("Fail to call cph_app_mod_tx_packet, rc(%d)\n", rc);
+		return 0;
+	}
+
+	/* Set forwarding information */
+	rc = cph_app_set_frwd(skb, tx_spec_out, frwd_bm, &frwd_value);
+	if (rc != MV_OK) {
+		pr_err("Fail to call cph_app_set_frwd, rc(%d)\n", rc);
+		return 0;
+	}
+
+	/* mark skb as tagged skb */
+	if (dir == CPH_DIR_DS)
+		skb->skb_iif = MV_MUX_SKB_TAG_VAL;
+	return 1;
+}
+
+/******************************************************************************
+* cph_rx_func()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: CPH function to handle the received special packets
+*              from network driver
+*
+* INPUTS:
+*       port    - Gmac port the packet from
+*       rxq     - CPU received queue
+*       dev     - Net device
+*       skb     - Marvell packet information
+*       rx_desc - RX descriptor
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       None.
+*******************************************************************************/
+void cph_rx_func(int port, int rxq, struct net_device *dev,
+		struct sk_buff *skb, struct pp2_rx_desc *rx_desc)
+{
+	MV_CPH_CLEAN_PRINT(CPH_DEBUG_LEVEL, "\n");
+	MV_CPH_PRINT(CPH_DEBUG_LEVEL, "Enter\n");
+
+	if (dev == NULL || skb == NULL || rx_desc == NULL) {
+		pr_err("%s: NULL Pointer dev(%p) skb(%p) rx_desc(%p)\n",
+			__func__, dev, skb, rx_desc);
+	}
+
+	if (mvPp2IsRxSpecial(rx_desc->parserInfo)) {
+		/* Receive application packets */
+		if (cph_app_packet_rx(port, dev, skb, rx_desc))
+			MV_CPH_PRINT(CPH_DEBUG_LEVEL, "Failed to receive application packet\n");
+
+		/* Handle the broadcast packet in case it is enabled */
+#ifdef CONFIG_MV_CPH_BC_HANDLE
+		if (cph_app_rx_bc(port, dev, skb, rx_desc))
+			MV_CPH_PRINT(CPH_DEBUG_LEVEL, "BC packet failure\n");
+#endif
+		/* deliver to upper layer */
+		MV_CPH_PRINT(CPH_DEBUG_LEVEL, "Deliver to upper layer\n");
+	} else {/* Handle received data flow packets */
+#ifdef CONFIG_MV_CPH_FLOW_MAP_HANDLE
+		if (cph_data_flow_rx(port, dev, skb, rx_desc))
+			MV_CPH_PRINT(CPH_DEBUG_LEVEL, "Flow mapping\n");
+
+#endif
+	}
+}
+
+/******************************************************************************
+* cph_tx_func()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: CPH function to handle tranmitting special packets
+*              to network driver
+*
+* INPUTS:
+*       port        - Gmac port the packet from
+*       dev         - Net device
+*       skb         - SKB buffer to receive packet
+*       tx_spec_out - TX descriptor
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       None.
+*******************************************************************************/
+int cph_tx_func(int port, struct net_device *dev, struct sk_buff *skb,
+		struct mv_eth_tx_spec *tx_spec_out)
+{
+	/* Transmit application packets */
+	if (cph_app_packet_tx(port, dev, skb, tx_spec_out))
+		return 1;
+
+	/* Transmit data flow packets */
+#ifdef CONFIG_MV_CPH_FLOW_MAP_HANDLE
+	if (cph_data_flow_tx(port, dev, skb, FALSE, tx_spec_out))
+		return 1;
+#endif
+
+	/* Transmit data flow packets by UDP Source Port or Dest Port */
+#ifdef CONFIG_MV_CPH_UDP_SAMPLE_HANDLE
+	if (cph_udp_port_tx(port, dev, skb, tx_spec_out))
+		return 1;
+#endif
+
+	return 0;
+}
+
+/******************************************************************************
+* cph_netdev_init()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Initialize CPH network device
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int cph_netdev_init(void)
+{
+	unsigned int idx;
+
+	/* Retrieve Eth port number, as in mv_eth_init_module */
+	gs_mv_eth_port_num = mvCtrlEthMaxPortGet();
+
+	if (gs_mv_eth_port_num > MV_ETH_MAX_PORTS)
+		gs_mv_eth_port_num = MV_ETH_MAX_PORTS;
+
+	/* Initialize application packet handling */
+	cph_app_init();
+
+	/* Initialize UDP port mapping feature */
+#ifdef CONFIG_MV_CPH_UDP_SAMPLE_HANDLE
+	cph_udp_table_init();
+#endif
+
+	/* Initialize data flow mapping feature */
+#ifdef CONFIG_MV_CPH_FLOW_MAP_HANDLE
+	cph_flow_init();
+#endif
+
+	/* Register special receive check function */
+#ifdef CONFIG_MV_ETH_RX_SPECIAL
+	for (idx = 0; idx < gs_mv_eth_port_num; idx++)
+		mv_eth_rx_special_proc_func(idx, cph_rx_func);
+#endif /* CONFIG_MV_ETH_RX_SPECIAL */
+
+	/* Register special transmit check function */
+#ifdef CONFIG_MV_ETH_TX_SPECIAL
+	for (idx = 0; idx < gs_mv_eth_port_num; idx++)
+		mv_eth_tx_special_check_func(idx, cph_tx_func);
+#endif /* CONFIG_MV_ETH_TX_SPECIAL */
+
+	/* enable all T-CONT by default, whill remove it once callback implmented*/
+	for (idx = 0; idx < MV_TCONT_LLID_NUM; idx++)
+		cph_set_tcont_state(idx, true);
+
+	return MV_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_netdev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_netdev.h
new file mode 100644
index 0000000..80b82a4
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_netdev.h
@@ -0,0 +1,160 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+	*   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+	*   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+	*   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+********************************************************************************
+* mv_cph_netdev.h
+*
+* DESCRIPTION: Marvell CPH(CPH Packet Handler) network device part definition
+*
+* DEPENDENCIES:
+*               None
+*
+* CREATED BY:   VictorGu
+*
+* DATE CREATED: 11Dec2011
+*
+* FILE REVISION NUMBER:
+*               Revision: 1.0
+*
+*
+*******************************************************************************/
+#ifndef _MV_CPH_NETDEV_H_
+#define _MV_CPH_NETDEV_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <net/ip.h>
+
+#include <mvCommon.h>
+#include <mvOs.h>
+#include <mv_pp2/net_dev/mv_netdev.h>
+
+
+#define MV_CPH_MAS_UDP_SRC_PORT          8
+#define MV_CPH_MAS_UDP_DST_PORT          8
+#define MV_CPH_NUM_LLID                  8
+#define MV_CPH_PON_PORT_IDX              3
+
+#ifdef CONFIG_MV_CPH_UDP_SAMPLE_HANDLE
+struct mv_udp_port_tx_spec {
+	__be16    udp_port;
+	struct mv_eth_tx_spec tx_spec;
+};
+
+struct mv_port_tx_spec {
+	struct mv_udp_port_tx_spec udp_src[MV_CPH_MAS_UDP_SRC_PORT];
+	struct mv_udp_port_tx_spec udp_dst[MV_CPH_MAS_UDP_DST_PORT];
+};
+
+void cph_udp_spec_print_all(void);
+MV_STATUS  cph_udp_src_spec_set(int tx_port, uint16_t udp_src_port,
+	uint8_t txp, uint8_t txq, uint16_t flags, uint32_t hw_cmd);
+MV_STATUS  cph_udp_dest_spec_set(int tx_port, uint16_t udp_dest_port,
+	uint8_t txp, uint8_t txq, uint16_t flags, uint32_t hw_cmd);
+#endif
+
+/******************************************************************************
+* cph_rec_skb()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Send SKB packet to linux network and increse counter
+*
+* INPUTS:
+*       port    - Gmac port the packet from
+*       skb     - SKB buffer to receive packet
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       None.
+*******************************************************************************/
+void cph_rec_skb(int port, struct sk_buff *skb);
+
+/******************************************************************************
+* cph_netdev_init()
+* _____________________________________________________________________________
+*
+* DESCRIPTION: Initialize CPH network device
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       On success, the function returns MV_OK.
+*       On error returns error code accordingly.
+*******************************************************************************/
+int cph_netdev_init(void);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _MV_CPH_NETDEV_H_ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_sysfs.c
new file mode 100644
index 0000000..408cf7c
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_sysfs.c
@@ -0,0 +1,1114 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+	*   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+	*   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+	*   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+********************************************************************************
+* mv_cph_sysfs.c
+*
+* DESCRIPTION: Marvell CPH(CPH Packet Handler) sysfs command definition
+*
+* DEPENDENCIES:
+*               None
+*
+* CREATED BY:   VictorGu
+*
+* DATE CREATED: 22Jan2013
+*
+* FILE REVISION NUMBER:
+*               Revision: 1.1
+*
+*
+*******************************************************************************/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/capability.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/netdevice.h>
+
+#include "mv_cph_header.h"
+
+static ssize_t cph_spec_proc_help(char *buf)
+{
+	int off = 0;
+	off += sprintf(buf+off, "cat  help                                 - show this help\n");
+	off += sprintf(buf+off, "cat  help_add                             - show additional help for parameters\n");
+	off += sprintf(buf+off, "cat  show_app_db                          - show all information in application rule data base\n");
+	off += sprintf(buf+off, "cat  show_parse_name                      - show sysfs parsing rule data base\n");
+	off += sprintf(buf+off, "cat  show_mod_name                        - show sysfs modification rule data base\n");
+	off += sprintf(buf+off, "cat  show_frwd_name                       - show sysfs modification rule data base\n");
+#ifdef CONFIG_MV_CPH_UDP_SAMPLE_HANDLE
+	off += sprintf(buf+off, "cat  udp_ports                            - show special udp source and destination port configuration\n");
+#endif
+#ifdef CONFIG_MV_CPH_FLOW_MAP_HANDLE
+	off += sprintf(buf+off, "cat  show_flow_rule                       - show flow mapping rules\n");
+	off += sprintf(buf+off, "cat  clear_flow_rule                      - clear all flow mapping rules\n");
+	off += sprintf(buf+off, "cat  del_dscp_map                         - delete DSCP to P-bits mapping rules\n");
+#endif
+	off += sprintf(buf+off, "echo profile_id active_port               > set_complex     - Set TPM complex profile ID and active GMAC port, 0:GMAC0, 1:GMAC1, 2:PON MAC\n");
+	off += sprintf(buf+off, "echo feature state                        > set_flag        - Set the support of CPH feature: refer to below additional info, state 0:disable, 1:enable\n");
+	off += sprintf(buf+off, "echo tcont state                          > set_tcont       - Set T-CONT state in CPH, T-CONT 0~7, state, 1:enable, 0:disable\n");
+	off += sprintf(buf+off, "echo hex                                  > trace_level     - Set cph trace level bitmap. 0x01:debug, 0x02:info, 0x04:warn, 0x08:error\n");
+	off += sprintf(buf+off, "echo name bm(hex) dir rx(hex) mh(hex) ety(hex) esty ipv4ty nh1 nh2 icmpty > add_parse   - add parsing field, dir 0:U/S, 1:D/S, 2:Not care\n");
+	off += sprintf(buf+off, "echo name                                 > del_parse       - delete parsing field\n");
+	off += sprintf(buf+off, "echo name bm(hex) proto_type(hex) state   > add_mod         - add modification field, state 0:diable, 1:enable\n");
+	off += sprintf(buf+off, "echo name                                 > del_mod         - delete modification field\n");
+	off += sprintf(buf+off, "echo name bm(hex) trg_port trg_queue gem  > add_frwd        - add forwarding field\n");
+	off += sprintf(buf+off, "echo name                                 > del_frwd        - delete forwarding field\n");
+	off += sprintf(buf+off, "echo parse_name mod_name frwd_name        > add_app_rule    - add application rule\n");
+	off += sprintf(buf+off, "echo parse_name                           > del_app_rule    - delete application rule\n");
+	off += sprintf(buf+off, "echo parse_name mod_name frwd_name        > update_app_rule - update application rule\n");
+	off += sprintf(buf+off, "echo parse_name                           > get_app_rule    - get application rule\n");
+#ifdef CONFIG_MV_CPH_UDP_SAMPLE_HANDLE
+	off += sprintf(buf+off, "echo p udp_src(dec) txp txq flags hw_cmd  > udp_src         - set udp source port special Tx behavior\n");
+	off += sprintf(buf+off, "echo p udp_dst(dec) txp txq flags hw_cmd  > udp_dst         - set udp destination port special Tx behavior\n");
+#endif
+#ifdef CONFIG_MV_CPH_FLOW_MAP_HANDLE
+	off += sprintf(buf+off, "---------------------------------------------------------------------------------------------------------------------------------------\n");
+	off += sprintf(buf+off, "                         |Parse outer    |Parse inner             |Mod outer      |Mod Inner      |Forward\n");
+	off += sprintf(buf+off, "echo dir default parse_bm mh ety  tpid vid pbits  tpid vid pbits  op_type  tpid vid pbits  tpid vid pbits  port queue hwf_queue gem > add_flow_rule - Add flow rule\n");
+	off += sprintf(buf+off, "echo dir default parse_bm mh ety  tpid vid pbits  tpid vid pbits  > del_flow_rule   - delete flow mapping rule\n");
+	off += sprintf(buf+off, "echo dir default parse_bm mh ety  tpid vid pbits  tpid vid pbits  > get_flow_rule   - get flow mapping rule\n");
+	off += sprintf(buf+off, "echo pbits0 pbits1 ... pbits62 pbits63                    > set_dscp_map    - set DSCP to P-bits mapping rules\n");
+#endif
+	return off;
+}
+
+static ssize_t cph_spec_proc_help_add(char *buf)
+{
+	int off = 0;
+	off += sprintf(buf+off, "CPH additional help for parameters\n");
+	off += sprintf(buf+off, "---------------------------------------------------------------------------------------------------------------------------------------\n");
+	off += sprintf(buf+off, "[Generic Parameters]\n");
+	off += sprintf(buf+off, "feature:\n");
+	off += sprintf(buf+off, "   0:Generic application, 1:IGMP/MLD support, 2:Broadcast support, 3:Data flow mapping support, 4: UDP port mapping support\n");
+	off += sprintf(buf+off, "[App Parameters]\n");
+	off += sprintf(buf+off, "parse bm:\n");
+	off += sprintf(buf+off, "   0x01:PARSE_FIELD_DIR              0x02:PARSE_FIELD_MH               0x04:PARSE_FIELD_ETH_TYPE         0x08:PARSE_FIELD_ETH_SUBTYPE\n");
+	off += sprintf(buf+off, "   0x10:PARSE_FIELD_IPV4_TYPE        0x20:PARSE_FIELD_IPV6_NH1         0x40:PARSE_FIELD_IPV6_NH2         0x80:PARSE_FIELD_ICMPV6_TYPE\n");
+	off += sprintf(buf+off, "dir: 0: U/S, 1:D/S, 2: Not care\n");
+	off += sprintf(buf+off, "rx: 0: RX, 1:TX\n");
+	off += sprintf(buf+off, "mod bm:\n");
+	off += sprintf(buf+off, "   0x01:RX_MOD_ADD_GMAC              0x02:RX_MOD_REPLACE_PROTO_TYPE    0x04:RX_MOD_STRIP_MH              0x08:TX_MOD_ADD_MH_BY_DRIVER\n");
+	off += sprintf(buf+off, "   0x10:CPH_APP_TX_MOD_NO_PAD        0x20:MOD_SET_STATE\n");
+	off += sprintf(buf+off, "frwd bm:\n");
+	off += sprintf(buf+off, "   0x01:FRWD_SET_TRG_PORT            0x02:FRWD_SET_TRG_QUEUE           0x04:FRWD_SET_GEM_PORT\n");
+	off += sprintf(buf+off, "[Flow Parameters]\n");
+	off += sprintf(buf+off, "dir: 0: U/S, 1:D/S, 2: Not care\n");
+	off += sprintf(buf+off, "default: 0: not default, 1:default\n");
+	off += sprintf(buf+off, "bm:\n");
+	off += sprintf(buf+off, "   0x01:PARSE_MH                     0x02:PARSE_EXT_VLAN               0x04:PARSE_TWO_VLAN               0x08:PARSE_ETH_TYPE\n");
+	off += sprintf(buf+off, "mh(hex), ety(hex), tpid(hex), vid(dec), pbits(dec)\n");
+	off += sprintf(buf+off, "op_type:\n");
+	off += sprintf(buf+off, "   00:ASIS                           01:DISCARD                        02:ADD                            03:ADD_COPY_DSCP\n");
+	off += sprintf(buf+off, "   04:ADD_COPY_OUTER_PBIT            05:ADD_COPY_INNER_PBIT            06:ADD_2_TAGS                     07:ADD_2_TAGS_COPY_DSCP\n");
+	off += sprintf(buf+off, "   08:ADD_2_TAGS_COPY_PBIT           09:REM                            10:REM_2_TAGS                     11:REPLACE\n");
+	off += sprintf(buf+off, "   12:REPLACE_VID                    13:REPLACE_PBIT                   14:REPLACE_INNER_ADD_OUTER        15:REPLACE_INNER_ADD_OUTER_COPY_PBIT\n");
+	off += sprintf(buf+off, "   16:REPLACE_INNER_REM_OUTER        17:REPLACE_2TAGS                  18:REPLACE_2TAGS_VID              19:SWAP\n");
+
+	return off;
+}
+
+
+/********************************************************************************/
+/*                          Parsing field table                                 */
+/********************************************************************************/
+static struct CPH_SYSFS_PARSE_T cph_sysfs_parse_table[CPH_SYSFS_FIELD_MAX_ENTRY];
+
+static struct CPH_SYSFS_RULE_T cph_parse_rule_db = {
+	.max_entry_num    = CPH_SYSFS_FIELD_MAX_ENTRY,
+	.entry_num        = 0,
+	.entry_size       = sizeof(struct CPH_SYSFS_PARSE_T),
+	.entry_ara        = cph_sysfs_parse_table
+};
+
+static void cph_sysfs_init_parse_db(void)
+{
+	struct CPH_SYSFS_PARSE_T  *p_entry = (struct CPH_SYSFS_PARSE_T *)cph_parse_rule_db.entry_ara;
+	int               idx     = 0;
+
+	for (idx = 0; idx < cph_parse_rule_db.max_entry_num; idx++, p_entry++)
+		p_entry->name[0] = 0;
+}
+
+struct CPH_SYSFS_PARSE_T *cph_sysfs_find_parse_entry_by_name(char *name)
+{
+	struct CPH_SYSFS_PARSE_T *p_entry = (struct CPH_SYSFS_PARSE_T *)cph_parse_rule_db.entry_ara;
+	int              idx     = 0;
+
+	for (idx = 0; idx < cph_parse_rule_db.max_entry_num; idx++, p_entry++) {
+		if (strcmp(p_entry->name, name) == 0)
+			return p_entry;
+	}
+	return 0;
+}
+
+struct CPH_SYSFS_PARSE_T *cph_sysfs_find_free_parse_entry(void)
+{
+	struct CPH_SYSFS_PARSE_T *p_entry = (struct CPH_SYSFS_PARSE_T *)cph_parse_rule_db.entry_ara;
+	int              idx     = 0;
+
+	for (idx = 0; idx < cph_parse_rule_db.max_entry_num; idx++, p_entry++) {
+		if (p_entry->name[0] == 0)
+			return p_entry;
+	}
+	return 0;
+}
+
+bool cph_sysfs_del_parse_entry_by_name(char *name)
+{
+	struct CPH_SYSFS_PARSE_T *p_entry = (struct CPH_SYSFS_PARSE_T *)cph_parse_rule_db.entry_ara;
+	int              idx     = 0;
+
+	for (idx = 0; idx < cph_parse_rule_db.max_entry_num; idx++, p_entry++) {
+		if (strcmp(p_entry->name, name) == 0) {
+			p_entry->name[0]  = 0;
+			p_entry->parse_bm = 0;
+			memset(&p_entry->parse_key, 0, sizeof(p_entry->parse_key));
+			return TRUE;
+		}
+	}
+	return FALSE;
+}
+
+void cph_sysfs_show_parse_db(void)
+{
+	struct CPH_SYSFS_PARSE_T *p_entry = (struct CPH_SYSFS_PARSE_T *)cph_parse_rule_db.entry_ara;
+	int              idx     = 0;
+
+	for (idx = 0; idx < cph_parse_rule_db.max_entry_num; idx++, p_entry++) {
+		if (p_entry->name[0] != 0) {
+			pr_info("Parse entry(%d) name(%s)\n", idx, p_entry->name);
+			cph_db_display_parse_field(p_entry->parse_bm, &p_entry->parse_key);
+		}
+	}
+}
+
+/********************************************************************************/
+/*                          Modification field table                            */
+/********************************************************************************/
+static struct CPH_SYSFS_MOD_T CPH_SYSFS_MOD_Table[CPH_SYSFS_FIELD_MAX_ENTRY];
+
+static struct CPH_SYSFS_RULE_T cph_mod_rule_db = {
+	.max_entry_num    = CPH_SYSFS_FIELD_MAX_ENTRY,
+	.entry_num        = 0,
+	.entry_size       = sizeof(struct CPH_SYSFS_MOD_T),
+	.entry_ara        = CPH_SYSFS_MOD_Table
+};
+
+static void cph_sysfs_init_mod_db(void)
+{
+	struct CPH_SYSFS_MOD_T  *p_entry = (struct CPH_SYSFS_MOD_T *)cph_mod_rule_db.entry_ara;
+	int             idx     = 0;
+
+	for (idx = 0; idx < cph_mod_rule_db.max_entry_num; idx++, p_entry++)
+		p_entry->name[0] = 0;
+}
+
+struct CPH_SYSFS_MOD_T *cph_sysfs_find_mod_entry_by_name(char *name)
+{
+	struct CPH_SYSFS_MOD_T  *p_entry = (struct CPH_SYSFS_MOD_T *)cph_mod_rule_db.entry_ara;
+	int             idx     = 0;
+
+	for (idx = 0; idx < cph_mod_rule_db.max_entry_num; idx++, p_entry++) {
+		if (strcmp(p_entry->name, name) == 0)
+			return p_entry;
+	}
+	return 0;
+}
+
+struct CPH_SYSFS_MOD_T *cph_sysfs_find_free_mod_entry(void)
+{
+	struct CPH_SYSFS_MOD_T  *p_entry = (struct CPH_SYSFS_MOD_T *)cph_mod_rule_db.entry_ara;
+	int             idx     = 0;
+
+	for (idx = 0; idx < cph_mod_rule_db.max_entry_num; idx++, p_entry++) {
+		if (p_entry->name[0] == 0)
+			return p_entry;
+	}
+	return 0;
+}
+
+bool cph_sysfs_del_mod_entry_by_name(char *name)
+{
+	struct CPH_SYSFS_MOD_T  *p_entry = (struct CPH_SYSFS_MOD_T *)cph_mod_rule_db.entry_ara;
+	int             idx     = 0;
+
+	for (idx = 0; idx < cph_mod_rule_db.max_entry_num; idx++, p_entry++) {
+		if (strcmp(p_entry->name, name) == 0) {
+			p_entry->name[0] = 0;
+			p_entry->mod_bm  = 0;
+			memset(&p_entry->mod_value, 0, sizeof(p_entry->mod_value));
+			return TRUE;
+		}
+	}
+	return FALSE;
+}
+
+void cph_sysfs_show_mod_db(void)
+{
+	struct CPH_SYSFS_MOD_T  *p_entry = (struct CPH_SYSFS_MOD_T *)cph_mod_rule_db.entry_ara;
+	int             idx     = 0;
+
+	for (idx = 0; idx < cph_mod_rule_db.max_entry_num; idx++, p_entry++) {
+		if (p_entry->name[0] != 0) {
+			pr_info("Mod entry(%d) name(%s)\n", idx, p_entry->name);
+			cph_db_display_mod_field(p_entry->mod_bm, &p_entry->mod_value);
+		}
+	}
+}
+
+/********************************************************************************/
+/*                          Forwarding field table                              */
+/********************************************************************************/
+static struct CPH_SYSFS_FRWD_T cph_sysfs_frwd_table[CPH_SYSFS_FIELD_MAX_ENTRY];
+
+static struct CPH_SYSFS_RULE_T cph_frwd_rule_db = {
+	.max_entry_num    = CPH_SYSFS_FIELD_MAX_ENTRY,
+	.entry_num        = 0,
+	.entry_size       = sizeof(struct CPH_SYSFS_FRWD_T),
+	.entry_ara        = cph_sysfs_frwd_table
+};
+
+static void cph_sysfs_init_frwd_db(void)
+{
+	struct CPH_SYSFS_FRWD_T *p_entry = (struct CPH_SYSFS_FRWD_T *)cph_frwd_rule_db.entry_ara;
+	int             idx     = 0;
+
+	for (idx = 0; idx < cph_frwd_rule_db.max_entry_num; idx++, p_entry++)
+		p_entry->name[0] = 0;
+}
+
+struct CPH_SYSFS_FRWD_T *cph_sysfs_find_frwd_entry_by_name(char *name)
+{
+	struct CPH_SYSFS_FRWD_T *p_entry = (struct CPH_SYSFS_FRWD_T *)cph_frwd_rule_db.entry_ara;
+	int             idx     = 0;
+
+	for (idx = 0; idx < cph_frwd_rule_db.max_entry_num; idx++, p_entry++) {
+		if (strcmp(p_entry->name, name) == 0)
+			return p_entry;
+	}
+	return 0;
+}
+
+struct CPH_SYSFS_FRWD_T *cph_sysfs_find_free_frwd_entry(void)
+{
+	struct CPH_SYSFS_FRWD_T *p_entry = (struct CPH_SYSFS_FRWD_T *)cph_frwd_rule_db.entry_ara;
+	int             idx     = 0;
+
+	for (idx = 0; idx < cph_frwd_rule_db.max_entry_num; idx++, p_entry++) {
+		if (p_entry->name[0] == 0)
+			return p_entry;
+	}
+	return 0;
+}
+
+bool cph_sysfs_del_frwd_entry_by_name(char *name)
+{
+	struct CPH_SYSFS_FRWD_T *p_entry = (struct CPH_SYSFS_FRWD_T *)cph_frwd_rule_db.entry_ara;
+	int             idx     = 0;
+
+	for (idx = 0; idx < cph_frwd_rule_db.max_entry_num; idx++, p_entry++) {
+		if (strcmp(p_entry->name, name) == 0) {
+			p_entry->name[0] = 0;
+			p_entry->frwd_bm = 0;
+			memset(&p_entry->frwd_value, 0, sizeof(p_entry->frwd_value));
+			return TRUE;
+		}
+	}
+	return FALSE;
+}
+
+void cph_sysfs_show_frwd_db(void)
+{
+	struct CPH_SYSFS_FRWD_T *p_entry = (struct CPH_SYSFS_FRWD_T *)cph_frwd_rule_db.entry_ara;
+	int             idx     = 0;
+
+	for (idx = 0; idx < cph_frwd_rule_db.max_entry_num; idx++, p_entry++) {
+		if (p_entry->name[0] != 0) {
+			pr_info("Frwd entry(%d) name(%s)\n", idx, p_entry->name);
+			cph_db_display_frwd_field(p_entry->frwd_bm, &p_entry->frwd_value);
+		}
+	}
+}
+
+/********************************************************************************/
+/*                          SYS FS Parsing Functions                            */
+/********************************************************************************/
+static ssize_t cph_spec_proc_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int       off  = 0;
+	const char *name = attr->attr.name;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	if (!strcmp(name, "help"))
+		off = cph_spec_proc_help(buf);
+
+	if (!strcmp(name, "help_add"))
+		off = cph_spec_proc_help_add(buf);
+	else if (!strcmp(name, "show_app_db"))
+		cph_db_display_all();
+
+	else if (!strcmp(name, "show_parse_name"))
+		cph_sysfs_show_parse_db();
+
+	else if (!strcmp(name, "show_mod_name"))
+		cph_sysfs_show_mod_db();
+
+	else if (!strcmp(name, "show_frwd_name"))
+		cph_sysfs_show_frwd_db();
+
+#ifdef CONFIG_MV_CPH_UDP_SAMPLE_HANDLE
+	else if (!strcmp(name, "udp_ports"))
+		cph_udp_spec_print_all();
+#endif
+#ifdef CONFIG_MV_CPH_FLOW_MAP_HANDLE
+	else if (!strcmp(name, "show_flow_rule"))
+		cph_flow_display_all();
+
+	else if (!strcmp(name, "clear_flow_rule"))
+		cph_flow_clear_rule();
+
+	else if (!strcmp(name, "del_dscp_map"))
+		cph_flow_del_dscp_map();
+#endif
+	else
+		off = cph_spec_proc_help(buf);
+
+	return off;
+}
+
+static ssize_t cph_spec_proc_1_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t len)
+{
+	const char *name  = attr->attr.name;
+	unsigned int      v1    = 0;
+	unsigned long       flags = 0;
+	MV_STATUS   rc    =  MV_OK;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	/* Read input */
+	sscanf(buf, "%x", &v1);
+
+	raw_local_irq_save(flags);
+
+	if (!strcmp(name, "trace_level")) {
+		rc = cph_set_trace_flag(v1);
+		if (rc == MV_OK)
+			pr_err("Succeed to set trace level<0x%x>\n", v1);
+		else
+			pr_err("Fail to set trace level<0x%x>\n", v1);
+	} else
+		pr_err("%s: illegal operation <%s>\n", __func__, attr->attr.name);
+
+	raw_local_irq_restore(flags);
+
+	return len;
+}
+
+static ssize_t cph_spec_proc_2_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t len)
+{
+	const char *name  = attr->attr.name;
+	unsigned int      v1    = 0;
+	unsigned int      v2    = 0;
+	unsigned long       flags = 0;
+	MV_STATUS   rc    =  MV_OK;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	/* Read input */
+	sscanf(buf, "%d %d", &v1, &v2);
+
+	raw_local_irq_save(flags);
+
+	if (!strcmp(name, "set_complex")) {
+		rc = cph_set_complex_profile(v1, v2);
+		if (rc == MV_OK)
+			pr_err("Succeed to set complex profile<%d> active port<%d>\n", v1, v2);
+		else
+			pr_err("Fail to set complex profile<%d> active port<%d>\n", v1, v2);
+	} else if (!strcmp(name, "set_flag")) {
+		rc = cph_set_feature_flag(v1, v2);
+		if (rc == MV_OK)
+			pr_err("Succeed to set feature<%d> to <%d>\n", v1, v2);
+		else
+			pr_err("Fail to set feature<%d> to<%d>\n", v1, v2);
+	} else if (!strcmp(name, "set_tcont")) {
+		rc = cph_set_tcont_state(v1, v2);
+		if (rc == MV_OK)
+			pr_err("Succeed to set tcont<%d> to <%d>\n", v1, v2);
+		else
+			pr_err("Fail to set tcont<%d> to<%d>\n", v1, v2);
+	} else
+		pr_err("%s: illegal operation <%s>\n", __func__, attr->attr.name);
+
+	raw_local_irq_restore(flags);
+
+	return len;
+}
+
+static ssize_t cph_spec_proc_name_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t len)
+{
+	const char *name  = attr->attr.name;
+	char        name1[CPH_SYSFS_FIELD_MAX_LEN+1];
+	unsigned int      v1    = 0;
+	unsigned int      v2    = 0;
+	unsigned int      v3    = 0;
+	unsigned int      v4    = 0;
+	unsigned int      v5    = 0;
+	unsigned int      v6    = 0;
+	unsigned int      v7    = 0;
+	unsigned int      v8    = 0;
+	unsigned int      v9    = 0;
+	unsigned int      v10   = 0;
+	unsigned long       flags = 0;
+	struct CPH_SYSFS_PARSE_T *p_parse_entry = NULL;
+	struct CPH_SYSFS_MOD_T   *p_mod_entry   = NULL;
+	struct CPH_SYSFS_FRWD_T  *p_frwd_entry  = NULL;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	if (!strcmp(name, "add_parse")) {
+		/* Read input */
+		sscanf(buf, "%s %x %d %d %d %x %d %d %d %d %d", name1, &v1, &v2, &v3, &v4, &v5, &v6, &v7, &v8, &v9, &v10);
+
+		raw_local_irq_save(flags);
+
+		p_parse_entry = cph_sysfs_find_parse_entry_by_name(name1);
+		if (p_parse_entry) {
+			pr_err("Already has the parse field by name <%s>\n", name1);
+			return -EPERM;
+		}
+
+		p_parse_entry = cph_sysfs_find_free_parse_entry();
+		if (!p_parse_entry) {
+			pr_err("No free parse entry\n");
+			return -EPERM;
+		}
+
+		strcpy(p_parse_entry->name, name1);
+		p_parse_entry->parse_bm              = v1;
+		p_parse_entry->parse_key.dir         = v2;
+		p_parse_entry->parse_key.rx_tx       = v3;
+		p_parse_entry->parse_key.mh          = v4;
+		p_parse_entry->parse_key.eth_type    = v5;
+		p_parse_entry->parse_key.eth_subtype = v6;
+		p_parse_entry->parse_key.ipv4_type   = v7;
+		p_parse_entry->parse_key.ipv6_nh1    = v8;
+		p_parse_entry->parse_key.ipv6_nh2    = v9;
+		p_parse_entry->parse_key.icmpv6_type = v10;
+
+		pr_err("Succeed to add parse field by name <%s>\n", name1);
+
+		raw_local_irq_restore(flags);
+	} else if (!strcmp(name, "add_mod")) {
+		/* Read input */
+		sscanf(buf, "%s %x %x %d", name1, &v1, &v2, &v3);
+
+		raw_local_irq_save(flags);
+
+		p_mod_entry = cph_sysfs_find_mod_entry_by_name(name1);
+		if (p_mod_entry) {
+			pr_err("Already has the mod field by name <%s>\n", name1);
+			return -EPERM;
+		}
+
+		p_mod_entry = cph_sysfs_find_free_mod_entry();
+		if (!p_mod_entry) {
+			pr_err("No free mod entry\n");
+			return -EPERM;
+		}
+
+		strcpy(p_mod_entry->name, name1);
+		p_mod_entry->mod_bm                = v1;
+		p_mod_entry->mod_value.proto_type  = v2;
+		if (v3)
+			p_mod_entry->mod_value.state   = TRUE;
+		else
+			p_mod_entry->mod_value.state   = FALSE;
+
+		pr_err("Succeed to add mod field by name <%s>\n", name1);
+
+		raw_local_irq_restore(flags);
+	} else if (!strcmp(name, "add_frwd")) {
+		/* Read input */
+		sscanf(buf, "%s %x %d %d %d", name1, &v1, &v2, &v3, &v4);
+
+		raw_local_irq_save(flags);
+
+		p_frwd_entry = cph_sysfs_find_frwd_entry_by_name(name1);
+		if (p_frwd_entry) {
+			pr_err("Already has the frwd field by name <%s>\n", name1);
+			return -EPERM;
+		}
+
+		p_frwd_entry = cph_sysfs_find_free_frwd_entry();
+		if (!p_frwd_entry) {
+			pr_err("No free frwd entry\n");
+			return -EPERM;
+		}
+
+		strcpy(p_frwd_entry->name, name1);
+		p_frwd_entry->frwd_bm              = v1;
+		p_frwd_entry->frwd_value.trg_port  = v2;
+		p_frwd_entry->frwd_value.trg_queue = v3;
+		p_frwd_entry->frwd_value.gem_port  = v4;
+
+		pr_err("Succeed to add frwd field by name <%s>\n", name1);
+
+		raw_local_irq_restore(flags);
+	} else
+		pr_err("%s: illegal operation <%s>\n", __func__, attr->attr.name);
+
+	return len;
+}
+
+static ssize_t cph_spec_proc_app_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t len)
+{
+	const char *name  = attr->attr.name;
+	char        name1[CPH_SYSFS_FIELD_MAX_LEN+1];
+	char        name2[CPH_SYSFS_FIELD_MAX_LEN+1];
+	char        name3[CPH_SYSFS_FIELD_MAX_LEN+1];
+	unsigned long       flags = 0;
+	MV_STATUS   rc    =  MV_OK;
+	struct CPH_SYSFS_PARSE_T *p_parse_entry = NULL;
+	struct CPH_SYSFS_MOD_T   *p_mod_entry   = NULL;
+	struct CPH_SYSFS_FRWD_T  *p_frwd_entry  = NULL;
+	struct CPH_SYSFS_MOD_T    mod_entry;
+	struct CPH_SYSFS_FRWD_T   frwd_entry;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	/* Read input */
+	sscanf(buf, "%s %s %s", name1, name2, name3);
+
+	raw_local_irq_save(flags);
+
+	if (!strcmp(name, "add_app_rule")) {
+		p_parse_entry = cph_sysfs_find_parse_entry_by_name(name1);
+		if (!p_parse_entry) {
+			pr_err("add_app_rule: invalid parse name <%s>\n", name1);
+			return -EPERM;
+		}
+		p_mod_entry = cph_sysfs_find_mod_entry_by_name(name2);
+		if (!p_mod_entry) {
+			pr_err("add_app_rule: invalid mod name <%s>\n", name2);
+			return -EPERM;
+		}
+		p_frwd_entry = cph_sysfs_find_frwd_entry_by_name(name3);
+		if (!p_frwd_entry) {
+			pr_err("add_app_rule: invalid frwd name <%s>\n", name3);
+			return -EPERM;
+		}
+
+		rc = cph_add_app_rule(p_parse_entry->parse_bm, &p_parse_entry->parse_key,
+					p_mod_entry->mod_bm, &p_mod_entry->mod_value,
+					p_frwd_entry->frwd_bm, &p_frwd_entry->frwd_value);
+		if (rc == MV_OK)
+			pr_err("Succeed to add app rule\n");
+		else
+			pr_err("Fail to add app rule\n");
+	} else if (!strcmp(name, "del_app_rule")) {
+		p_parse_entry = cph_sysfs_find_parse_entry_by_name(name1);
+		if (!p_parse_entry) {
+			pr_err("add_app_rule: invalid parse name <%s>\n", name1);
+			return -EPERM;
+		}
+
+		rc = cph_del_app_rule(p_parse_entry->parse_bm, &p_parse_entry->parse_key);
+		if (rc == MV_OK)
+			pr_err("Succeed to delete app rule\n");
+		else
+			pr_err("Fail to delete app rule\n");
+	} else if (!strcmp(name, "update_app_rule")) {
+		p_parse_entry = cph_sysfs_find_parse_entry_by_name(name1);
+		if (!p_parse_entry) {
+			pr_err("add_app_rule: invalid parse name <%s>\n", name1);
+			return -EPERM;
+		}
+		p_mod_entry = cph_sysfs_find_mod_entry_by_name(name2);
+		if (!p_mod_entry) {
+			pr_err("add_app_rule: invalid mod name <%s>\n", name2);
+			return -EPERM;
+		}
+		p_frwd_entry = cph_sysfs_find_frwd_entry_by_name(name3);
+		if (!p_frwd_entry) {
+			pr_err("add_app_rule: invalid frwd name <%s>\n", name3);
+			return -EPERM;
+		}
+
+		rc = cph_update_app_rule(p_parse_entry->parse_bm, &p_parse_entry->parse_key,
+					p_mod_entry->mod_bm, &p_mod_entry->mod_value,
+					p_frwd_entry->frwd_bm, &p_frwd_entry->frwd_value);
+		if (rc == MV_OK)
+			pr_err("Succeed to update app rule\n");
+		else
+			pr_err("Fail to update app rule\n");
+	} else if (!strcmp(name, "get_app_rule")) {
+		p_parse_entry = cph_sysfs_find_parse_entry_by_name(name1);
+		if (!p_parse_entry) {
+			pr_err("add_app_rule: invalid parse name <%s>\n", name1);
+			return -EPERM;
+		}
+
+		rc = cph_get_app_rule(p_parse_entry->parse_bm, &p_parse_entry->parse_key,
+					&mod_entry.mod_bm, &mod_entry.mod_value,
+					&frwd_entry.frwd_bm, &frwd_entry.frwd_value);
+		if (rc == MV_OK) {
+			cph_db_display_parse_field(p_parse_entry->parse_bm, &p_parse_entry->parse_key);
+			cph_db_display_mod_field(mod_entry.mod_bm, &mod_entry.mod_value);
+			cph_db_display_frwd_field(frwd_entry.frwd_bm, &frwd_entry.frwd_value);
+		} else {
+			pr_err("No valid CPH app rule\n");
+		}
+
+	} else if (!strcmp(name, "del_parse")) {
+		rc = cph_sysfs_del_parse_entry_by_name(name1);
+		if (rc == TRUE)
+			pr_err("Succeed to delete parse field by name <%s>\n", name1);
+		else
+			pr_err("Fail to delete parse field by name <%s>\n", name1);
+	} else if (!strcmp(name, "del_mod")) {
+		rc = cph_sysfs_del_mod_entry_by_name(name1);
+		if (rc == TRUE)
+			pr_err("Succeed to delete mod field by name <%s>\n", name1);
+		else
+			pr_err("Fail to delete mod field by name <%s>\n", name1);
+	} else if (!strcmp(name, "del_frwd")) {
+		rc = cph_sysfs_del_frwd_entry_by_name(name1);
+		if (rc == TRUE)
+			pr_err("Succeed to delete frwd field by name <%s>\n", name1);
+		else
+			pr_err("Fail to delete frwd field by name <%s>\n", name1);
+	} else
+		pr_err("%s: illegal operation <%s>\n", __func__, attr->attr.name);
+
+	raw_local_irq_restore(flags);
+
+	return len;
+}
+
+#ifdef CONFIG_MV_CPH_UDP_SAMPLE_HANDLE
+static ssize_t cph_spec_proc_udp_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t len)
+{
+	const char *name  = attr->attr.name;
+	unsigned int      v1    = 0;
+	unsigned int      v2    = 0;
+	unsigned int      v3    = 0;
+	unsigned int      v4    = 0;
+	unsigned int      v5    = 0;
+	unsigned int      v6    = 0;
+	unsigned long       flags = 0;
+	MV_STATUS   rc    =  MV_OK;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	/* Read input */
+	sscanf(buf, "%d %d %x %x %x %x", &v1, &v2, &v3, &v4, &v5, &v6);
+
+	raw_local_irq_save(flags);
+
+	if (!strcmp(name, "udp_src")) {
+		rc = cph_udp_src_spec_set(v1, v2, v3, v4, v5, v6);
+		if (rc == MV_OK)
+			pr_err("Succeed to add UDP src rule\n");
+		else
+			pr_err("Fail to add UDP src rule\n");
+	} else if (!strcmp(name, "udp_dst")) {
+		rc = cph_udp_dest_spec_set(v1, v2, v3, v4, v5, v6);
+		if (rc == MV_OK)
+			pr_err("Succeed to add UDP dest rule\n");
+		else
+			pr_err("Fail to add UDP dest rule\n");
+	} else
+		pr_err("%s: illegal operation <%s>\n", __func__, attr->attr.name);
+
+	raw_local_irq_restore(flags);
+
+	return len;
+}
+#endif
+
+#ifdef CONFIG_MV_CPH_FLOW_MAP_HANDLE
+static ssize_t cph_spec_proc_flow_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t len)
+{
+	const char    *name  = attr->attr.name;
+	unsigned int         v0    = 0;
+	unsigned int         v1    = 0;
+	unsigned int         v2    = 0;
+	unsigned int         v3    = 0;
+	unsigned int         v4    = 0;
+	unsigned int         v5    = 0;
+	unsigned int         v6    = 0;
+	unsigned int         v7    = 0;
+	unsigned int         v8    = 0;
+	unsigned int         v9    = 0;
+	unsigned int         v10   = 0;
+	unsigned int         v11   = 0;
+	unsigned int         v12   = 0;
+	unsigned int         v13   = 0;
+	unsigned int         v14   = 0;
+	unsigned int         v15   = 0;
+	unsigned int         v16   = 0;
+	unsigned int         v17   = 0;
+	unsigned int         v18   = 0;
+	unsigned int         v19   = 0;
+	unsigned int         v20   = 0;
+	unsigned int         v21   = 0;
+	unsigned long          flags = 0;
+	MV_STATUS      rc    =  MV_OK;
+	struct CPH_FLOW_ENTRY_T cph_flow;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	/* Read input */
+	sscanf(buf, "%d %d %x %x %x %x %d %d %x %d %d %d %x %d %d %x %d %d %d %d %d %d", &v0, &v1, &v2, &v3, &v4, &v5, &v6, &v7, &v8, &v9, &v10, &v11, &v12, &v13, &v14, &v15, &v16, &v17, &v18, &v19, &v20, &v21);
+
+	raw_local_irq_save(flags);
+
+#ifdef CONFIG_MV_CPH_FLOW_MAP_HANDLE
+	if (!strcmp(name, "add_flow_rule")) {
+		memset(&cph_flow, 0, sizeof(cph_flow));
+		cph_flow.dir        = (enum CPH_DIR_E)v0;
+		cph_flow.is_default = v1 ? TRUE : FALSE;
+		cph_flow.parse_bm   = (enum CPH_FLOW_PARSE_E)v2;
+		cph_flow.mh         = (unsigned short)v3;
+		cph_flow.eth_type   = (unsigned short)v4;
+		cph_flow.parse_outer_tci.tpid   = (unsigned short)v5;
+		cph_flow.parse_outer_tci.vid    = (unsigned short)v6;
+		cph_flow.parse_outer_tci.pbits  = (unsigned char)v7;
+		cph_flow.parse_inner_tci.tpid   = (unsigned short)v8;
+		cph_flow.parse_inner_tci.vid    = (unsigned short)v9;
+		cph_flow.parse_inner_tci.pbits  = (unsigned char)v10;
+		cph_flow.op_type                = (enum CPH_VLAN_OP_TYPE_E)v11;
+		cph_flow.mod_outer_tci.tpid     = (unsigned short)v12;
+		cph_flow.mod_outer_tci.vid      = (unsigned short)v13;
+		cph_flow.mod_outer_tci.pbits    = (unsigned char)v14;
+		cph_flow.mod_inner_tci.tpid     = (unsigned short)v15;
+		cph_flow.mod_inner_tci.vid      = (unsigned short)v16;
+		cph_flow.mod_inner_tci.pbits    = (unsigned char)v17;
+		cph_flow.pkt_frwd.trg_port      = (unsigned char)v18;
+		cph_flow.pkt_frwd.trg_queue     = (unsigned char)v19;
+		cph_flow.pkt_frwd.trg_hwf_queue = (unsigned char)v20;
+		cph_flow.pkt_frwd.gem_port      = (unsigned short)v21;
+
+		rc = cph_flow_add_rule(&cph_flow);
+		if (rc == MV_OK)
+			pr_err("Succeed to add flow mapping rule\n");
+		else
+			pr_err("Fail to add flow mapping rule\n");
+	} else if (!strcmp(name, "del_flow_rule")) {
+		memset(&cph_flow, 0, sizeof(cph_flow));
+		cph_flow.dir        = (enum CPH_DIR_E)v0;
+		cph_flow.is_default = v1 ? TRUE : FALSE;
+		cph_flow.parse_bm   = (enum CPH_FLOW_PARSE_E)v2;
+		cph_flow.mh         = (unsigned short)v3;
+		cph_flow.eth_type   = (unsigned short)v4;
+		cph_flow.parse_outer_tci.tpid   = (unsigned short)v5;
+		cph_flow.parse_outer_tci.vid    = (unsigned short)v6;
+		cph_flow.parse_outer_tci.pbits  = (unsigned char)v7;
+		cph_flow.parse_inner_tci.tpid   = (unsigned short)v8;
+		cph_flow.parse_inner_tci.vid    = (unsigned short)v9;
+		cph_flow.parse_inner_tci.pbits  = (unsigned char)v10;
+
+		rc = cph_flow_del_rule(&cph_flow);
+		if (rc == MV_OK)
+			pr_err("Succeed to delete flow mapping rule\n");
+		else
+			pr_err("Fail to delete flow mapping rule\n");
+	} else if (!strcmp(name, "get_flow_rule")) {
+		memset(&cph_flow, 0, sizeof(cph_flow));
+		cph_flow.dir        = (enum CPH_DIR_E)v0;
+		cph_flow.is_default = v1 ? TRUE : FALSE;
+		cph_flow.parse_bm   = (enum CPH_FLOW_PARSE_E)v2;
+		cph_flow.mh         = (unsigned short)v3;
+		cph_flow.eth_type   = (unsigned short)v4;
+		cph_flow.parse_outer_tci.tpid   = (unsigned short)v5;
+		cph_flow.parse_outer_tci.vid    = (unsigned short)v6;
+		cph_flow.parse_outer_tci.pbits  = (unsigned char)v7;
+		cph_flow.parse_inner_tci.tpid   = (unsigned short)v8;
+		cph_flow.parse_inner_tci.vid    = (unsigned short)v9;
+		cph_flow.parse_inner_tci.pbits  = (unsigned char)v10;
+
+		rc = cph_flow_get_rule(&cph_flow);
+		if (rc == MV_OK) {
+			pr_err("Succeed to get flow rule\n");
+			pr_info("                        |Parse outer       |Parse inner       |Mod outer         |Mod Inner         |Forward\n");
+			pr_info("dir default tparse_bm mh   ety    tpid   vid  pbits  tpid   vid  pbits  tpid   vid  pbits  tpid   vid  pbits  port queue hwf_queue gem  op_type\n");
+			pr_info(
+			"%2.2s  %4.4s    0x%04x   %-4d 0x%04x 0x%04x %4d %1d      0x%04x %4d %1d      0x%04x %4d %1d      0x%04x %4d %1d      %1d    %1d     %1d         %4d %s\n",
+			cph_app_lookup_dir(cph_flow.dir), (cph_flow.is_default == TRUE) ? "Yes" : "No",
+			cph_flow.parse_bm, cph_flow.mh, cph_flow.eth_type,
+			cph_flow.parse_outer_tci.tpid, cph_flow.parse_outer_tci.vid, cph_flow.parse_outer_tci.pbits,
+			cph_flow.parse_inner_tci.tpid, cph_flow.parse_inner_tci.vid, cph_flow.parse_inner_tci.pbits,
+			cph_flow.mod_outer_tci.tpid,   cph_flow.mod_outer_tci.vid,   cph_flow.mod_outer_tci.pbits,
+			cph_flow.mod_inner_tci.tpid,   cph_flow.mod_inner_tci.vid,   cph_flow.mod_inner_tci.pbits,
+			cph_flow.pkt_frwd.trg_port,    cph_flow.pkt_frwd.trg_queue,  cph_flow.pkt_frwd.trg_hwf_queue,
+			cph_flow.pkt_frwd.gem_port, cph_flow_lookup_op_type(cph_flow.op_type));
+		} else {
+			pr_err("Fail to get flow\n");
+		}
+	} else
+		pr_err("%s: illegal operation <%s>\n", __func__, attr->attr.name);
+#endif
+
+	raw_local_irq_restore(flags);
+
+	return len;
+}
+
+static ssize_t cph_spec_proc_dscp_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t len)
+{
+	const char      *name = attr->attr.name;
+	unsigned int           v[64];
+	unsigned int           index = 0;
+	unsigned long            flags = 0;
+	MV_STATUS        rc    =  MV_OK;
+	struct CPH_DSCP_PBITS_T dscp_map;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	/* Read input */
+	sscanf(buf, "%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d ",
+	       &v[0],  &v[1],  &v[2],  &v[3],  &v[4],  &v[5],  &v[6],  &v[7],
+	       &v[8],  &v[9],  &v[10], &v[11], &v[12], &v[13], &v[14], &v[15],
+	       &v[16], &v[17], &v[18], &v[19], &v[20], &v[21], &v[22], &v[23],
+	       &v[24], &v[25], &v[26], &v[27], &v[28], &v[29], &v[30], &v[31],
+	       &v[32], &v[33], &v[34], &v[35], &v[36], &v[37], &v[38], &v[39],
+	       &v[40], &v[41], &v[42], &v[43], &v[44], &v[45], &v[46], &v[47],
+	       &v[48], &v[49], &v[50], &v[51], &v[52], &v[53], &v[54], &v[55],
+	       &v[56], &v[57], &v[58], &v[59], &v[60], &v[61], &v[62], &v[63]);
+	for (index = 0; index < 64; index++)
+		dscp_map.pbits[index] = (unsigned char)v[index];
+
+	dscp_map.in_use = TRUE;
+
+	raw_local_irq_save(flags);
+
+	if (!strcmp(name, "set_dscp_map")) {
+		rc = cph_flow_set_dscp_map(&dscp_map);
+		if (rc == MV_OK)
+			pr_err("Succeed to set DSCP to P-bits mapping\n");
+		else
+			pr_err("Fail to set DSCP to P-bits mapping\n");
+	} else
+		pr_err("%s: illegal operation <%s>\n", __func__, attr->attr.name);
+
+	raw_local_irq_restore(flags);
+
+	return len;
+}
+#endif
+
+static DEVICE_ATTR(help,            S_IRUSR, cph_spec_proc_show, NULL);
+static DEVICE_ATTR(help_add,        S_IRUSR, cph_spec_proc_show, NULL);
+static DEVICE_ATTR(show_app_db,     S_IRUSR, cph_spec_proc_show, NULL);
+static DEVICE_ATTR(show_parse_name, S_IRUSR, cph_spec_proc_show, NULL);
+static DEVICE_ATTR(show_mod_name,   S_IRUSR, cph_spec_proc_show, NULL);
+static DEVICE_ATTR(show_frwd_name,  S_IRUSR, cph_spec_proc_show, NULL);
+#ifdef CONFIG_MV_CPH_UDP_SAMPLE_HANDLE
+static DEVICE_ATTR(udp_ports,       S_IRUSR, cph_spec_proc_show, NULL);
+#endif
+#ifdef CONFIG_MV_CPH_FLOW_MAP_HANDLE
+static DEVICE_ATTR(show_flow_rule,  S_IRUSR, cph_spec_proc_show, NULL);
+static DEVICE_ATTR(clear_flow_rule, S_IRUSR, cph_spec_proc_show, NULL);
+static DEVICE_ATTR(del_dscp_map,    S_IRUSR, cph_spec_proc_show, NULL);
+#endif
+static DEVICE_ATTR(set_complex,     S_IWUSR, cph_spec_proc_show, cph_spec_proc_2_store);
+static DEVICE_ATTR(set_flag,        S_IWUSR, cph_spec_proc_show, cph_spec_proc_2_store);
+static DEVICE_ATTR(add_parse,       S_IWUSR, cph_spec_proc_show, cph_spec_proc_name_store);
+static DEVICE_ATTR(del_parse,       S_IWUSR, cph_spec_proc_show, cph_spec_proc_app_store);
+static DEVICE_ATTR(add_mod,         S_IWUSR, cph_spec_proc_show, cph_spec_proc_name_store);
+static DEVICE_ATTR(del_mod,         S_IWUSR, cph_spec_proc_show, cph_spec_proc_app_store);
+static DEVICE_ATTR(add_frwd,        S_IWUSR, cph_spec_proc_show, cph_spec_proc_name_store);
+static DEVICE_ATTR(del_frwd,        S_IWUSR, cph_spec_proc_show, cph_spec_proc_app_store);
+static DEVICE_ATTR(add_app_rule,    S_IWUSR, cph_spec_proc_show, cph_spec_proc_app_store);
+static DEVICE_ATTR(del_app_rule,    S_IWUSR, cph_spec_proc_show, cph_spec_proc_app_store);
+static DEVICE_ATTR(update_app_rule, S_IWUSR, cph_spec_proc_show, cph_spec_proc_app_store);
+static DEVICE_ATTR(get_app_rule,    S_IWUSR, cph_spec_proc_show, cph_spec_proc_app_store);
+#ifdef CONFIG_MV_CPH_UDP_SAMPLE_HANDLE
+static DEVICE_ATTR(udp_src,         S_IWUSR, cph_spec_proc_show, cph_spec_proc_udp_store);
+static DEVICE_ATTR(udp_dst,         S_IWUSR, cph_spec_proc_show, cph_spec_proc_udp_store);
+#endif
+#ifdef CONFIG_MV_CPH_FLOW_MAP_HANDLE
+static DEVICE_ATTR(add_flow_rule,   S_IWUSR, cph_spec_proc_show, cph_spec_proc_flow_store);
+static DEVICE_ATTR(del_flow_rule,   S_IWUSR, cph_spec_proc_show, cph_spec_proc_flow_store);
+static DEVICE_ATTR(get_flow_rule,   S_IWUSR, cph_spec_proc_show, cph_spec_proc_flow_store);
+static DEVICE_ATTR(set_dscp_map,    S_IWUSR, cph_spec_proc_show, cph_spec_proc_dscp_store);
+#endif
+static DEVICE_ATTR(set_tcont,       S_IWUSR, cph_spec_proc_show, cph_spec_proc_2_store);
+static DEVICE_ATTR(trace_level,     S_IWUSR, cph_spec_proc_show, cph_spec_proc_1_store);
+
+
+static struct attribute *cph_spec_proc_attrs[] = {
+	&dev_attr_help.attr,
+	&dev_attr_help_add.attr,
+	&dev_attr_show_app_db.attr,
+	&dev_attr_show_parse_name.attr,
+	&dev_attr_show_mod_name.attr,
+	&dev_attr_show_frwd_name.attr,
+#ifdef CONFIG_MV_CPH_UDP_SAMPLE_HANDLE
+	&dev_attr_udp_ports.attr,
+#endif
+#ifdef CONFIG_MV_CPH_FLOW_MAP_HANDLE
+	&dev_attr_show_flow_rule.attr,
+	&dev_attr_clear_flow_rule.attr,
+	&dev_attr_del_dscp_map.attr,
+#endif
+	&dev_attr_set_complex.attr,
+	&dev_attr_set_flag.attr,
+	&dev_attr_add_parse.attr,
+	&dev_attr_del_parse.attr,
+	&dev_attr_add_mod.attr,
+	&dev_attr_del_mod.attr,
+	&dev_attr_add_frwd.attr,
+	&dev_attr_del_frwd.attr,
+	&dev_attr_add_app_rule.attr,
+	&dev_attr_del_app_rule.attr,
+	&dev_attr_update_app_rule.attr,
+	&dev_attr_get_app_rule.attr,
+#ifdef CONFIG_MV_CPH_UDP_SAMPLE_HANDLE
+	&dev_attr_udp_src.attr,
+	&dev_attr_udp_dst.attr,
+#endif
+#ifdef CONFIG_MV_CPH_FLOW_MAP_HANDLE
+	&dev_attr_add_flow_rule.attr,
+	&dev_attr_del_flow_rule.attr,
+	&dev_attr_get_flow_rule.attr,
+	&dev_attr_set_dscp_map.attr,
+#endif
+	&dev_attr_set_tcont.attr,
+	&dev_attr_trace_level.attr,
+
+	NULL
+};
+
+static struct attribute_group cph_spec_proc_group = {
+	.name = "proto",
+	.attrs = cph_spec_proc_attrs,
+};
+
+int cph_sysfs_init(void)
+{
+	int          err = 0;
+	struct device *pd  = NULL;
+
+	pd = bus_find_device_by_name(&platform_bus_type, NULL, "cph");
+	if (!pd) {
+		platform_device_register_simple("cph", -1, NULL, 0);
+		pd = bus_find_device_by_name(&platform_bus_type, NULL, "cph");
+	}
+
+	if (!pd) {
+		pr_err("%s: cannot find cph device\n", __func__);
+		pd = &platform_bus;
+	}
+
+	err = sysfs_create_group(&pd->kobj, &cph_spec_proc_group);
+	if (err) {
+		pr_info("sysfs group failed %d\n", err);
+		goto out;
+	}
+
+	/* Init CPH SYS FS data base to hold parse/mod/frwd values */
+	cph_sysfs_init_parse_db();
+	cph_sysfs_init_mod_db();
+	cph_sysfs_init_frwd_db();
+
+out:
+	return err;
+}
+
+void cph_sysfs_exit(void)
+{
+	struct device *pd = NULL;
+
+	pd = bus_find_device_by_name(&platform_bus_type, NULL, "cph");
+	if (!pd) {
+		pr_err("%s: cannot find CPH device\n", __func__);
+		return;
+	}
+
+	sysfs_remove_group(&pd->kobj, &cph_spec_proc_group);
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_sysfs.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_sysfs.h
new file mode 100644
index 0000000..1f753b6
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/cph/mv_cph_sysfs.h
@@ -0,0 +1,131 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+	*   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+	*   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+	*   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+********************************************************************************
+* mv_cph_sysfs.h
+*
+* DESCRIPTION: Marvell CPH(CPH Packet Handler) sysfs command definition
+*
+* DEPENDENCIES:
+*               None
+*
+* CREATED BY:   VictorGu
+*
+* DATE CREATED: 11Dec2011
+*
+* FILE REVISION NUMBER:
+*               Revision: 1.1
+*
+*
+*******************************************************************************/
+#ifndef _MV_CPH_SYSFS_H_
+#define _MV_CPH_SYSFS_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define CPH_SYSFS_FIELD_MAX_LEN   (32)
+#define CPH_SYSFS_FIELD_MAX_ENTRY (64)
+
+
+/* Common DB structure for entries
+------------------------------------------------------------------------------*/
+struct CPH_SYSFS_RULE_T {
+	int  max_entry_num;
+	int  entry_num;
+	int  entry_size;
+	void  *entry_ara;
+} ;
+
+/* Parsing filed entry
+------------------------------------------------------------------------------*/
+struct CPH_SYSFS_PARSE_T {
+	char                  name[CPH_SYSFS_FIELD_MAX_LEN+1];
+	enum CPH_APP_PARSE_FIELD_E parse_bm;
+	struct CPH_APP_PARSE_T       parse_key;
+};
+
+/* Modification filed entry
+------------------------------------------------------------------------------*/
+struct CPH_SYSFS_MOD_T {
+	char                  name[CPH_SYSFS_FIELD_MAX_LEN+1];
+	enum CPH_APP_MOD_FIELD_E   mod_bm;
+	struct CPH_APP_MOD_T         mod_value;
+};
+
+/* Forwarding filed entry
+------------------------------------------------------------------------------*/
+struct CPH_SYSFS_FRWD_T {
+	char                  name[CPH_SYSFS_FIELD_MAX_LEN+1];
+	enum CPH_APP_FRWD_FIELD_E  frwd_bm;
+	struct CPH_APP_FRWD_T        frwd_value;
+};
+
+
+int cph_sysfs_init(void);
+void cph_sysfs_exit(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _MV_CPH_SYSFS_H_ */
-- 
1.7.5.4

