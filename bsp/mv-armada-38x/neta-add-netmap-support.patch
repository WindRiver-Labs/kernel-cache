From 6775bf26b25e638268b3e8967348ec8c0a29c830 Mon Sep 17 00:00:00 2001
From: Yelena <yelena@yk-lxl0057.il.marvell.com>
Date: Wed, 23 Oct 2013 14:12:32 +0200
Subject: [PATCH 1059/1825] neta: add netmap support

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 79cb82050aba527d342c1f4dc5e24ad9e7735afd

	Netmap is a framework for packet generation and capture from
	user space.
	All netmap relevant code added under define CONFIG_NETMAP
	and activated only through netmap compilation.

Change-Id: Ifdb1e4596c3448d69ca70f26d348f94d98302647
Signed-off-by: Yelena <yelena@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../plat-armada/mv_drivers_lsp/mv_neta/Makefile    |    4 ++
 .../mv_drivers_lsp/mv_neta/net_dev/mv_ethernet.c   |    2 +-
 .../mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c     |   46 +++++++++++++++++---
 .../mv_drivers_lsp/mv_neta/net_dev/mv_netdev.h     |    4 +-
 4 files changed, 48 insertions(+), 8 deletions(-)

diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/Makefile b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/Makefile
index 3175bd1..2cbb19e 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/Makefile
@@ -63,4 +63,8 @@ ifeq ($(CONFIG_MV_PON),y)
 mv_neta-objs += mv_pon_sysfs.o
 endif
 
+ifeq ($(NETMAP),y)
+ccflags-y       += -DCONFIG_NETMAP -I$(NETMAP_DIR) -I$(NETMAP_DIR)/../sys
+endif
+
 obj-$(CONFIG_MV_ETH_NETA) += mv_neta.o
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_ethernet.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_ethernet.c
index d53a4c3..b222d29 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_ethernet.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_ethernet.c
@@ -52,7 +52,7 @@ static int mv_eth_set_mac_addr_internals(struct net_device *dev, void *addr);
  *   set hw defaults. fill rx buffers. restart phy link    *
  *   auto neg. set device link flags. report status.       *
  ***********************************************************/
-static int mv_eth_start(struct net_device *dev)
+int mv_eth_start(struct net_device *dev)
 {
 	struct eth_port *priv = MV_ETH_PRIV(dev);
 	int group;
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c
index e06e9dd..0d705fa 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c
@@ -56,6 +56,11 @@ disclaimer.
 #include "mv_eth_tool.h"
 #include "mv_eth_sysfs.h"
 #include "cpu/mvCpuCntrs.h"
+
+#if defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
+#include <mv_neta_netmap.h>
+#endif
+
 static struct mv_mux_eth_ops mux_eth_ops;
 
 #ifdef CONFIG_MV_CPU_PERF_CNTRS
@@ -1671,7 +1676,13 @@ static inline int mv_eth_rx(struct eth_port *pp, int rx_todo, int rxq, struct na
 	struct eth_pbuf *pkt;
 	struct sk_buff *skb;
 	struct bm_pool *pool;
-
+#ifdef CONFIG_NETMAP
+	if (pp->flags & MV_ETH_F_IFCAP_NETMAP) {
+		int netmap_done;
+		if (netmap_rx_irq(pp->dev, 0, &netmap_done))
+			return 1; /* seems to be ignored */
+	}
+#endif /* CONFIG_NETMAP */
 	/* Get number of received packets */
 	rx_done = mvNetaRxqBusyDescNumGet(pp->port, rxq);
 	mvOsCacheIoSync();
@@ -2990,11 +3001,13 @@ int mv_eth_poll(struct napi_struct *napi, int budget)
 		if (pp->rx_adaptive_coal_cfg)
 			mv_eth_adaptive_rx_update(pp);
 
-		local_irq_save(flags);
-		MV_REG_WRITE(NETA_INTR_NEW_MASK_REG(pp->port),
+		if (!(pp->flags & MV_ETH_F_IFCAP_NETMAP)) {
+			local_irq_save(flags);
+			MV_REG_WRITE(NETA_INTR_NEW_MASK_REG(pp->port),
 			     (MV_ETH_MISC_SUM_INTR_MASK | MV_ETH_TXDONE_INTR_MASK | MV_ETH_RX_INTR_MASK));
 
-		local_irq_restore(flags);
+			local_irq_restore(flags);
+		}
 	}
 	cpuCtrl->causeRxTx = causeRxTx;
 	return rx_done;
@@ -3242,6 +3255,10 @@ static int mv_eth_load_network_interfaces(struct platform_device *pdev)
 	mux_eth_ops.promisc_set = mv_eth_port_promisc_set;
 	mv_mux_eth_attach(pp->port, pp->dev, &mux_eth_ops);
 
+#ifdef CONFIG_NETMAP
+	mv_neta_netmap_attach(pp);
+#endif /* CONFIG_NETMAP */
+
 	/* Call mv_eth_open specifically for ports not connected to Linux netdevice */
 	if (!(pp->flags & MV_ETH_F_CONNECT_LINUX))
 		mv_eth_open(pp->dev);
@@ -4735,8 +4752,16 @@ int mv_eth_start_internals(struct eth_port *pp, int mtu)
 		mvNetaRxqBmDisable(pp->port, rxq);
 #endif /* CONFIG_MV_ETH_BM_CPU */
 
-		if (mvNetaRxqFreeDescNumGet(pp->port, rxq) == 0)
-			mv_eth_rxq_fill(pp, rxq, pp->rxq_ctrl[rxq].rxq_size);
+		if (!(pp->flags & MV_ETH_F_IFCAP_NETMAP)) {
+			if ((mvNetaRxqFreeDescNumGet(pp->port, rxq) == 0))
+				mv_eth_rxq_fill(pp, rxq, pp->rxq_ctrl[rxq].rxq_size);
+		} else {
+			mvNetaRxqNonOccupDescAdd(pp->port, rxq, pp->rxq_ctrl[rxq].rxq_size);
+#ifdef CONFIG_NETMAP
+			if (neta_netmap_rxq_init_buffers(pp, rxq))
+				return MV_ERROR;
+#endif
+		}
 	}
 
 	for (txp = 0; txp < pp->txp_num; txp++) {
@@ -4751,6 +4776,11 @@ int mv_eth_start_internals(struct eth_port *pp, int mtu)
 			}
 			mv_eth_tx_done_pkts_coal_set(pp->port, txp, txq,
 					pp->txq_ctrl[txp * CONFIG_MV_ETH_TXQ + txq].txq_done_pkts_coal);
+#ifdef CONFIG_NETMAP
+			if (neta_netmap_txq_init_buffers(pp, txp, txq))
+				return MV_ERROR;
+#endif /* CONFIG_NETMAP */
+
 		}
 		mvNetaTxpMaxTxSizeSet(pp->port, txp, RX_PKT_SIZE(mtu));
 	}
@@ -6242,6 +6272,10 @@ static int mv_eth_remove(struct platform_device *pdev)
 
 	mv_eth_priv_cleanup(pp);
 
+#ifdef CONFIG_NETMAP
+	netmap_detach(pp->dev);
+#endif /* CONFIG_NETMAP */
+
 	return 0;
 }
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.h
index 4e78ad8..17e6650 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.h
@@ -253,7 +253,7 @@ struct port_stats {
 #define MV_ETH_F_SUSPEND_BIT        12
 #define MV_ETH_F_STARTED_OLD_BIT    13 /*STARTED_BIT value before suspend */
 #define MV_ETH_F_FORCE_LINK_BIT     14
-
+#define MV_ETH_F_IFCAP_NETMAP_BIT   15
 
 #define MV_ETH_F_STARTED           (1 << MV_ETH_F_STARTED_BIT)
 #define MV_ETH_F_SWITCH            (1 << MV_ETH_F_SWITCH_BIT)
@@ -271,6 +271,7 @@ struct port_stats {
 #define MV_ETH_F_SUSPEND           (1 << MV_ETH_F_SUSPEND_BIT)
 #define MV_ETH_F_STARTED_OLD       (1 << MV_ETH_F_STARTED_OLD_BIT)
 #define MV_ETH_F_FORCE_LINK        (1 << MV_ETH_F_FORCE_LINK_BIT)
+#define MV_ETH_F_IFCAP_NETMAP      (1 << MV_ETH_F_IFCAP_NETMAP_BIT)
 
 /* Masks used for cpu_ctrl->flags */
 #define MV_ETH_F_TX_DONE_TIMER_BIT  0
@@ -709,6 +710,7 @@ static inline void mv_eth_rxq_refill(struct eth_port *pp, int rxq,
  * Function prototypes --                             *
  ******************************************************/
 int         mv_eth_stop(struct net_device *dev);
+int         mv_eth_start(struct net_device *dev);
 int         mv_eth_change_mtu(struct net_device *dev, int mtu);
 int         mv_eth_check_mtu_internals(struct net_device *dev, int mtu);
 int         mv_eth_check_mtu_valid(struct net_device *dev, int mtu);
-- 
1.7.5.4

