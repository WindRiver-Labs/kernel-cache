From b73ef2540f8175701a152f12a77be24c265738af Mon Sep 17 00:00:00 2001
From: Kosta Zertsekel <konszert@marvell.com>
Date: Wed, 13 Mar 2013 15:07:29 +0200
Subject: [PATCH 0491/1825] PPv2: remove non-existing callbacks

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit e358a1edac19d58ce76976b59b3f6dc5b297df54

As part of poring from Linux 3.2.x to 3.4.y, some network related callbacks
were completely removed. Thus these callbacks were removed from the driver code.

Signed-off-by: Kosta Zertsekel <konszert@marvell.com>
Change-Id: Ic6c30e228e3efe7ed50152b6b48103d7c427f2a0
Reviewed-on: http://vgitil04.il.marvell.com:8080/1278
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../mv_drivers_lsp/mv_neta/net_dev/mv_eth_switch.c |   65 --------------------
 .../mv_network/mv_ethernet/mv_ethernet.c           |   43 -------------
 .../mv_network/mv_ethernet/mv_netdev.c             |    2 -
 .../mv_network/mv_ethernet/mv_netdev.h             |    1 -
 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig |   16 ++++-
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_eth_switch.c  |   65 --------------------
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c      |   11 +---
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h      |    1 -
 8 files changed, 15 insertions(+), 189 deletions(-)

diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_switch.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_switch.c
index fe676e1..8af8738 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_switch.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_eth_switch.c
@@ -344,71 +344,6 @@ int    mv_eth_switch_set_mac_addr(struct net_device *dev, void *mac)
 	return 0;
 }
 
-void    mv_eth_switch_set_multicast_list(struct net_device *dev)
-{
-	struct eth_netdev *dev_priv = MV_DEV_PRIV(dev);
-
-	if (dev->flags & IFF_PROMISC) {
-		/* promiscuous mode - connect the CPU port to the VLAN (port based + 802.1q) */
-		/* printk(KERN_ERR "mv_eth_switch: setting promiscuous mode\n"); */
-		if (mv_switch_promisc_set(dev_priv->vlan_grp_id, dev_priv->port_map, dev_priv->cpu_port, 1))
-			printk(KERN_ERR "mv_switch_promisc_set to 1 failed\n");
-	} else {
-		/* not in promiscuous mode - disconnect the CPU port to the VLAN (port based + 802.1q) */
-		if (mv_switch_promisc_set(dev_priv->vlan_grp_id, dev_priv->port_map, dev_priv->cpu_port, 0))
-			printk(KERN_ERR "mv_switch_promisc_set to 0 failed\n");
-
-		if (dev->flags & IFF_ALLMULTI) {
-			/* allmulticast - not supported. There is no way to tell the Switch to accept only	*/
-			/* the multicast addresses but not Unicast addresses, so the alternatives are:	*/
-			/* 1) Don't support multicast and do nothing					*/
-			/* 2) Support multicast with same implementation as promiscuous			*/
-			/* 3) Don't rely on Switch for MAC filtering, but use PnC			*/
-			/* Currently option 1 is selected						*/
-			printk(KERN_ERR "mv_eth_switch: setting all-multicast mode is not supported\n");
-		}
-
-		/* Add or delete specific multicast addresses:						*/
-		/* Linux provides a list of the current multicast addresses for the device.		*/
-		/* First, we delete all the multicast addresses in the ATU.				*/
-		/* Then we add the specific multicast addresses Linux provides.				*/
-		if (mv_switch_all_multicasts_del(MV_SWITCH_VLAN_TO_GROUP(dev_priv->vlan_grp_id)))
-			printk(KERN_ERR "mv_eth_switch: mv_switch_all_multicasts_del failed\n");
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34)
-		if (!netdev_mc_empty(dev)) {
-			struct netdev_hw_addr *ha;
-
-			netdev_for_each_mc_addr(ha, dev) {
-				mv_switch_mac_addr_set(ha->addr,
-					MV_SWITCH_VLAN_TO_GROUP(dev_priv->vlan_grp_id),
-					(dev_priv->port_map | (1 << dev_priv->cpu_port)), 1);
-			}
-		}
-#else
-		{
-			int i;
-			struct dev_mc_list *curr_addr = dev->mc_list;
-
-			/* accept specific multicasts */
-			for (i = 0; i < dev->mc_count; i++, curr_addr = curr_addr->next) {
-				if (!curr_addr)
-					break;
-
-				/*
-				printk(KERN_ERR "Setting MC = %02X:%02X:%02X:%02X:%02X:%02X\n",
-				curr_addr->dmi_addr[0], curr_addr->dmi_addr[1], curr_addr->dmi_addr[2],
-				curr_addr->dmi_addr[3], curr_addr->dmi_addr[4], curr_addr->dmi_addr[5]);
-				*/
-				mv_switch_mac_addr_set(curr_addr->dmi_addr,
-					MV_SWITCH_VLAN_TO_GROUP(dev_priv->vlan_grp_id),
-					(dev_priv->port_map | (1 << dev_priv->cpu_port)), 1);
-			}
-		}
-#endif /* KERNEL_VERSION >= 2.6.34 */
-	}
-}
-
 int     mv_eth_switch_change_mtu(struct net_device *dev, int mtu)
 {
 	int i;
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_network/mv_ethernet/mv_ethernet.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_network/mv_ethernet/mv_ethernet.c
index 02f5931..15089d1 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_network/mv_ethernet/mv_ethernet.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_network/mv_ethernet/mv_ethernet.c
@@ -316,49 +316,6 @@ static int mv_eth_set_mac_addr_internals(struct net_device *dev, void *addr )
     return 0;
 }
 
-/***********************************************************
- * eth_set_multicast_list --                             *
- *   Add multicast addresses or set promiscuous mode.      *
- *   This function should have been but was not included   *
- *   by Marvell. -bbozarth                                 *
- ***********************************************************/
-void mv_eth_set_multicast_list(struct net_device *dev) {
-
-     mv_eth_priv        *priv = MV_ETH_PRIV(dev);
-     int                queue = ETH_DEF_RXQ;
-     struct dev_mc_list *curr_addr = dev->mc_list;
-     int                i;
-
-     if (dev->flags & IFF_PROMISC)
-     {
-        mvEthRxFilterModeSet(priv->hal_priv, 1);
-     }
-     else if (dev->flags & IFF_ALLMULTI)
-     {
-        mvEthRxFilterModeSet(priv->hal_priv, 0);
-        mvEthMacAddrSet(priv->hal_priv, dev->dev_addr, queue);
-        mvEthSetSpecialMcastTable(priv->port, queue);
-        mvEthSetOtherMcastTable(priv->port, queue);
-     }
-     else if (dev->mc_count)
-     {
-        mvEthRxFilterModeSet(priv->hal_priv, 0);
-        mvEthMacAddrSet(priv->hal_priv, dev->dev_addr, queue);
-        for (i=0; i<dev->mc_count; i++, curr_addr = curr_addr->next)
-        {
-            if (!curr_addr)
-                break;
-            mvEthMcastAddrSet(priv->hal_priv, curr_addr->dmi_addr, queue);
-        }
-     }
-     else /* No Mcast addrs, not promisc or all multi - clear tables */
-     {
-        mvEthRxFilterModeSet(priv->hal_priv, 0);
-        mvEthMacAddrSet(priv->hal_priv, dev->dev_addr, queue);
-     }
-}
-
-
 int     mv_eth_set_mac_addr( struct net_device *dev, void *addr )
 {
     if(!netif_running(dev)) {
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_network/mv_ethernet/mv_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_network/mv_ethernet/mv_netdev.c
index 1abec53..fabf96a 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_network/mv_ethernet/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_network/mv_ethernet/mv_netdev.c
@@ -2737,7 +2737,6 @@ static const struct net_device_ops mv_eth_netdev_ops = {
 	.ndo_open		= mv_eth_open,
 	.ndo_stop		= mv_eth_stop,
 	.ndo_start_xmit		= eth_tx,
-	.ndo_set_multicast_list	= mv_eth_set_multicast_list,
 	.ndo_set_mac_address	= mv_eth_set_mac_addr,
 	.ndo_change_mtu		= mv_eth_change_mtu,
 	.ndo_tx_timeout		= eth_tx_timeout,
@@ -2800,7 +2799,6 @@ struct net_device* __init mv_netdev_init(mv_eth_priv *priv, int mtu, u8* mac)
     dev->open = mv_eth_open;
     dev->stop = mv_eth_stop;
     dev->set_mac_address = mv_eth_set_mac_addr;
-    dev->set_multicast_list = mv_eth_set_multicast_list;
     dev->change_mtu = &mv_eth_change_mtu; 
 #else
     dev->netdev_ops = &mv_eth_netdev_ops;
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_network/mv_ethernet/mv_netdev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_network/mv_ethernet/mv_netdev.h
index 185ba0b..01240f9 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_network/mv_ethernet/mv_netdev.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_network/mv_ethernet/mv_netdev.h
@@ -494,7 +494,6 @@ extern int  mv_eth_start(struct net_device *dev);
 extern int  mv_eth_stop(struct net_device *dev);
 extern int  mv_eth_change_mtu(struct net_device *dev, int mtu);
 extern int  mv_eth_set_mac_addr( struct net_device *dev, void *mac );
-extern void mv_eth_set_multicast_list(struct net_device *dev);
 
 int __init                  mv_eth_hal_init(mv_eth_priv *priv, int mtu, u8* mac);
 int __init                  mv_eth_priv_init(mv_eth_priv *priv, int port);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig
index a4c119f..e13c5c1 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig
@@ -1,3 +1,11 @@
+if MV_ETH_PP2
+
+config MV_ETH_PORTS_NUM
+	int "Number of Marvell GbE ports"
+	default 4
+	help
+	  Number of Marvell GbE ports supported by NETA driver
+
 config MV_ETH_PP2_CLS2
 	bool
 	prompt "cls engine 2" if (0)
@@ -162,7 +170,7 @@ config  MV_ETH_BM_HWF_PORT_1_SHORT_BUF_NUM
         ---help---
 	Number of short buffers allocated for this port.
 
-menuconfig  MV_ETH_BM_HWF_PORT_2
+menuconfig MV_ETH_BM_HWF_PORT_2
         depends on (MV_ETH_PP2 && (MV_ETH_PORTS_NUM != 0) && (MV_ETH_PORTS_NUM != 1) &&  (MV_ETH_PORTS_NUM != 2))
         bool "BM HWF configuration for GbE #2"
         default y
@@ -358,7 +366,8 @@ config  MV_ETH_BM_PORT_2_SHORT_BUF_NUM
         Number of short buffers allocated for this port.
 
 menuconfig  MV_ETH_BM_PORT_3
-        depends on (MV_ETH_PP2 && (MV_ETH_PORTS_NUM != 0) && (MV_ETH_PORTS_NUM != 1) && (MV_ETH_PORTS_NUM != 2) && (MV_ETH_PORTS_NUM != 3))
+        depends on (MV_ETH_PP2 && (MV_ETH_PORTS_NUM != 0) && (MV_ETH_PORTS_NUM != 1) \
+		&& (MV_ETH_PORTS_NUM != 2) && (MV_ETH_PORTS_NUM != 3))
         bool "BM configuration for GbE #3"
         default y
         ---help---
@@ -721,6 +730,7 @@ config MV_ETH_HWF
 
 endmenu
 
+if MV_INCLUDE_SWITCH
 menu "Switch support"
 
 config MV_ETH_SWITCH
@@ -762,4 +772,6 @@ config  MV_ETH_SWITCH_LINK
 	---help---
 	  Support Phy link status change indications.
 endmenu
+endif
 
+endif
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_switch.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_switch.c
index 5a7b306..9a8d4b7 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_switch.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_eth_switch.c
@@ -344,71 +344,6 @@ int    mv_eth_switch_set_mac_addr(struct net_device *dev, void *mac)
 	return 0;
 }
 
-void    mv_eth_switch_set_multicast_list(struct net_device *dev)
-{
-	struct eth_netdev *dev_priv = MV_DEV_PRIV(dev);
-
-	if (dev->flags & IFF_PROMISC) {
-		/* promiscuous mode - connect the CPU port to the VLAN (port based + 802.1q) */
-		/* printk(KERN_ERR "mv_eth_switch: setting promiscuous mode\n"); */
-		if (mv_switch_promisc_set(dev_priv->vlan_grp_id, dev_priv->port_map, dev_priv->cpu_port, 1))
-			printk(KERN_ERR "mv_switch_promisc_set to 1 failed\n");
-	} else {
-		/* not in promiscuous mode - disconnect the CPU port to the VLAN (port based + 802.1q) */
-		if (mv_switch_promisc_set(dev_priv->vlan_grp_id, dev_priv->port_map, dev_priv->cpu_port, 0))
-			printk(KERN_ERR "mv_switch_promisc_set to 0 failed\n");
-
-		if (dev->flags & IFF_ALLMULTI) {
-			/* allmulticast - not supported. There is no way to tell the Switch to accept only	*/
-			/* the multicast addresses but not Unicast addresses, so the alternatives are:	*/
-			/* 1) Don't support multicast and do nothing					*/
-			/* 2) Support multicast with same implementation as promiscuous			*/
-			/* 3) Don't rely on Switch for MAC filtering, but use PnC			*/
-			/* Currently option 1 is selected						*/
-			printk(KERN_ERR "mv_eth_switch: setting all-multicast mode is not supported\n");
-		}
-
-		/* Add or delete specific multicast addresses:						*/
-		/* Linux provides a list of the current multicast addresses for the device.		*/
-		/* First, we delete all the multicast addresses in the ATU.				*/
-		/* Then we add the specific multicast addresses Linux provides.				*/
-		if (mv_switch_all_multicasts_del(MV_SWITCH_VLAN_TO_GROUP(dev_priv->vlan_grp_id)))
-			printk(KERN_ERR "mv_eth_switch: mv_switch_all_multicasts_del failed\n");
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 34)
-		if (!netdev_mc_empty(dev)) {
-			struct netdev_hw_addr *ha;
-
-			netdev_for_each_mc_addr(ha, dev) {
-				mv_switch_mac_addr_set(ha->addr,
-					MV_SWITCH_VLAN_TO_GROUP(dev_priv->vlan_grp_id),
-					(dev_priv->port_map | (1 << dev_priv->cpu_port)), 1);
-			}
-		}
-#else
-		{
-			int i;
-			struct dev_mc_list *curr_addr = dev->mc_list;
-
-			/* accept specific multicasts */
-			for (i = 0; i < dev->mc_count; i++, curr_addr = curr_addr->next) {
-				if (!curr_addr)
-					break;
-
-				/*
-				printk(KERN_ERR "Setting MC = %02X:%02X:%02X:%02X:%02X:%02X\n",
-				curr_addr->dmi_addr[0], curr_addr->dmi_addr[1], curr_addr->dmi_addr[2],
-				curr_addr->dmi_addr[3], curr_addr->dmi_addr[4], curr_addr->dmi_addr[5]);
-				*/
-				mv_switch_mac_addr_set(curr_addr->dmi_addr,
-					MV_SWITCH_VLAN_TO_GROUP(dev_priv->vlan_grp_id),
-					(dev_priv->port_map | (1 << dev_priv->cpu_port)), 1);
-			}
-		}
-#endif /* KERNEL_VERSION >= 2.6.34 */
-	}
-}
-
 int     mv_eth_switch_change_mtu(struct net_device *dev, int mtu)
 {
 	int i;
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
index dcef960..29ec351 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
@@ -890,18 +890,11 @@ static const struct net_device_ops mv_eth_netdev_ops = {
 	.ndo_open = mv_eth_open,
 	.ndo_stop = mv_eth_stop,
 	.ndo_start_xmit = mv_eth_tx,
-/*TODO - this is a hack by Seif M. need to fix this to properly move to linux 3.2!!!
-.ndo_set_multicast_list = mv_eth_set_multicast_list,
-*/
 	.ndo_change_rx_flags = mv_eth_set_multicast_list,
 	.ndo_set_mac_address = mv_eth_set_mac_addr,
 	.ndo_change_mtu = mv_eth_change_mtu,
 	.ndo_tx_timeout = mv_eth_tx_timeout,
 	.ndo_select_queue = mv_eth_select_txq,
-/*
-.ndo_change_rx_flags = mv_eth_change_rx_flags,
-.ndo_set_rx_mode = mv_eth_set_rx_mode,
-*/
 };
 
 #ifdef CONFIG_MV_ETH_SWITCH
@@ -909,7 +902,6 @@ static const struct net_device_ops mv_switch_netdev_ops = {
 	.ndo_open = mv_eth_switch_start,
 	.ndo_stop = mv_eth_switch_stop,
 	.ndo_start_xmit = mv_eth_tx,
-	.ndo_set_multicast_list = mv_eth_switch_set_multicast_list,
 	.ndo_set_mac_address = mv_eth_switch_set_mac_addr,
 	.ndo_change_mtu = mv_eth_switch_change_mtu,
 	.ndo_tx_timeout = mv_eth_tx_timeout,
@@ -936,7 +928,6 @@ static inline struct net_device *mv_eth_switch_netdev_get(struct eth_port *pp, s
 	return pp->dev;
 }
 
-
 void mv_eth_switch_priv_update(struct net_device *netdev, int i)
 {
 	struct eth_netdev *dev_priv;
@@ -4298,7 +4289,7 @@ static int mv_eth_priv_init(struct eth_port *pp, int port)
 #ifdef CONFIG_MV_PON
 	if (MV_PON_PORT(port)) {
 		set_bit(MV_ETH_F_MH_BIT, &(pp->flags));
-		pp->txp_num = CONFIG_MV_PON_TCONTS;
+		pp->txp_num = CONFIG_MV_GPON_TCONTS;
 		pp->txp = CONFIG_MV_PON_TXP_DEF;
 		for_each_possible_cpu(i)
 			pp->cpu_config[i]->txq = CONFIG_MV_PON_TXQ_DEF;
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
index 9675cf9..6fdcfda 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
@@ -708,7 +708,6 @@ extern struct net_device **mv_net_devs;
 
 int     mv_eth_switch_config_get(int use_existing_config, int port);
 int     mv_eth_switch_set_mac_addr(struct net_device *dev, void *mac);
-void    mv_eth_switch_set_multicast_list(struct net_device *dev);
 int     mv_eth_switch_change_mtu(struct net_device *dev, int mtu);
 int     mv_eth_switch_start(struct net_device *dev);
 int     mv_eth_switch_stop(struct net_device *dev);
-- 
1.7.5.4

