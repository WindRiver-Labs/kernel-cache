From 282529562a952b7a49cd7f3671d2d5d82f5dc2f1 Mon Sep 17 00:00:00 2001
From: Dmitri Epshtein <dima@marvell.com>
Date: Wed, 24 Jul 2013 09:36:43 -0400
Subject: [PATCH 0873/1825] Networking: Change SKB recycle mechanism to match
 differrent drivers NETA/PP2

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 51d9924d9238cbc8e8c89846d46451496d63fb71

        Minimize changes in Linux Network stack
        Manage skb->hw_cookie as __u32, bit0 means invalid

Change-Id: Ide3193b52684b4c786bd631cac1e1543af5f349f
Signed-off-by: Dmitri Epshtein <dima@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c     |   50 ++++++++++-------
 .../mv_drivers_lsp/mv_neta/net_dev/mv_netdev.h     |    3 +-
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c      |   56 +++++++++++++-------
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h      |    3 +-
 include/linux/skbuff.h                             |    2 +-
 net/core/skbuff.c                                  |   20 ++-----
 6 files changed, 75 insertions(+), 59 deletions(-)

diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c
index cd4ece6d..20c7a3b 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.c
@@ -1222,7 +1222,7 @@ void mv_eth_skb_print(struct sk_buff *skb)
 	       skb_shinfo(skb)->nr_frags, skb_shinfo(skb)->gso_size, skb_shinfo(skb)->gso_segs);
 	printk(KERN_ERR "\t proto=%d, ip_summed=%d, priority=%d\n", ntohs(skb->protocol), skb->ip_summed, skb->priority);
 #ifdef CONFIG_NET_SKB_RECYCLE
-	printk(KERN_ERR "\t skb_recycle=%p, hw_cookie=%p\n", skb->skb_recycle, skb->hw_cookie);
+	printk(KERN_ERR "\t skb_recycle=%p, hw_cookie=0x%x\n", skb->skb_recycle, skb->hw_cookie);
 #endif /* CONFIG_NET_SKB_RECYCLE */
 }
 
@@ -1361,35 +1361,43 @@ static inline int mv_eth_tx_policy(struct eth_port *pp, struct sk_buff *skb)
 #ifdef CONFIG_NET_SKB_RECYCLE
 int mv_eth_skb_recycle(struct sk_buff *skb)
 {
-	struct eth_pbuf *pkt = skb->hw_cookie;
+	struct eth_pbuf *pkt = (struct eth_pbuf *)(skb->hw_cookie & ~BIT(0));
 	struct bm_pool  *pool;
 	int             status = 0;
 
-#if defined(CONFIG_MV_ETH_DEBUG_CODE) && defined(CONFIG_MV_ETH_BM_CPU)
+	if (mvNetaMaxCheck(pkt->pool, MV_ETH_BM_POOLS, "bm_pool"))
+		goto err;
+
+	pool = &mv_eth_pool[pkt->pool];
+	if (skb->hw_cookie & BIT(0)) {
+		/* hw_cookie is not valid for recycle */
+		STAT_DBG(pool->stats.skb_hw_cookie_err++);
+		goto err;
+	}
+
+#if defined(CONFIG_MV_ETH_BM_CPU)
 	/* Check that first 4 bytes of the buffer contain hw_cookie */
 	if (*((MV_U32 *) skb->head) != (MV_U32)pkt) {
-		printk(KERN_ERR "%s: Wrong skb->head=%p (0x%x) != hw_cookie=%p\n",
+		/*
+		pr_err("%s: Wrong skb->head=%p (0x%x) != hw_cookie=%p\n",
 			__func__, skb->head, *((MV_U32 *) skb->head), pkt);
-		mv_eth_skb_print(skb);
-		mvDebugMemDump(skb->head, (skb->data - skb->head), 1);
-		printk(KERN_ERR "\n");
+		*/
+		STAT_DBG(pool->stats.skb_hw_cookie_err++);
 		goto err;
 	}
-#endif /* CONFIG_MV_ETH_DEBUG_CODE && CONFIG_MV_ETH_BM_CPU */
+#endif /* CONFIG_MV_ETH_BM_CPU */
 
 	/* Check validity of skb->head - some Linux functions (skb_expand_head) reallocate it */
 	if (skb->head != pkt->pBuf) {
-		printk(KERN_ERR "%s: skb=%p, pkt=%p, Wrong skb->head=%p != pkt->pBuf=%p\n",
+		/*
+		pr_err("%s: skb=%p, pkt=%p, Wrong skb->head=%p != pkt->pBuf=%p\n",
 			__func__, skb, pkt, skb->head, pkt->pBuf);
-		mv_eth_pkt_print(pkt);
-		mv_eth_skb_print(skb);
-		printk(KERN_ERR "\n");
+		*/
+		STAT_DBG(pool->stats.skb_hw_cookie_err++);
 		goto err;
 	}
 
-	pool = &mv_eth_pool[pkt->pool];
 	if (skb_recycle_check(skb, pool->pkt_size)) {
-
 #ifdef CONFIG_MV_ETH_DEBUG_CODE
 		/* Sanity check */
 		if (SKB_TRUESIZE(skb->end - skb->head) != skb->truesize) {
@@ -1409,14 +1417,14 @@ int mv_eth_skb_recycle(struct sk_buff *skb)
 			mv_eth_skb_save(skb, "recycle");
 #endif /* ETH_SKB_DEBUG */
 
-		return MV_OK;
+		return 0;
 	}
 	STAT_DBG(pool->stats.skb_recycled_err++);
-
 	/* printk(KERN_ERR "mv_eth_skb_recycle failed: pool=%d, pkt=%p, skb=%p\n", pkt->pool, pkt, skb); */
 err:
 	mvOsFree(pkt);
-	skb->hw_cookie = NULL;
+	skb->hw_cookie = 0;
+	skb->skb_recycle = NULL;
 
 	return 1;
 }
@@ -1788,7 +1796,7 @@ static inline int mv_eth_rx(struct eth_port *pp, int rx_todo, int rxq)
 #ifdef CONFIG_NET_SKB_RECYCLE
 		if (mv_eth_is_recycle()) {
 			skb->skb_recycle = mv_eth_skb_recycle;
-			skb->hw_cookie = pkt;
+			skb->hw_cookie = (__u32)pkt;
 			pkt = NULL;
 		}
 #endif /* CONFIG_NET_SKB_RECYCLE */
@@ -5471,11 +5479,11 @@ void mv_eth_pool_status_print(int pool)
 #endif /* #ifdef CONFIG_MV_ETH_STAT_ERR */
 
 #ifdef CONFIG_MV_ETH_STAT_DBG
-	printk(KERN_ERR "skb_alloc_ok=%u, bm_put=%u, stack_put=%u, stack_get=%u\n",
+	pr_info("     skb_alloc_ok=%u, bm_put=%u, stack_put=%u, stack_get=%u\n",
 	       bm_pool->stats.skb_alloc_ok, bm_pool->stats.bm_put, bm_pool->stats.stack_put, bm_pool->stats.stack_get);
 
-	printk(KERN_ERR "skb_recycled_ok=%u, skb_recycled_err=%u\n",
-	       bm_pool->stats.skb_recycled_ok, bm_pool->stats.skb_recycled_err);
+	pr_info("     skb_recycled_ok=%u, skb_recycled_err=%u, skb_hw_cookie_err=%u\n",
+	       bm_pool->stats.skb_recycled_ok, bm_pool->stats.skb_recycled_err, bm_pool->stats.skb_hw_cookie_err);
 #endif /* CONFIG_MV_ETH_STAT_DBG */
 
 	if (bm_pool->stack)
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.h
index 6369f66..7ca79c1 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_neta/net_dev/mv_netdev.h
@@ -452,6 +452,7 @@ struct pool_stats {
 	u32 skb_alloc_ok;
 	u32 skb_recycled_ok;
 	u32 skb_recycled_err;
+	u32 skb_hw_cookie_err;
 #endif /* CONFIG_MV_ETH_STAT_DBG */
 };
 
@@ -656,7 +657,7 @@ static inline void mv_eth_pkt_free(struct eth_pbuf *pkt)
 
 #ifdef CONFIG_NET_SKB_RECYCLE
 	skb->skb_recycle = NULL;
-	skb->hw_cookie = NULL;
+	skb->hw_cookie = 0;
 #endif /* CONFIG_NET_SKB_RECYCLE */
 
 	dev_kfree_skb_any(skb);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
index 058fca9..6ad95ab 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
@@ -1243,7 +1243,7 @@ void mv_eth_skb_print(struct sk_buff *skb)
 	       skb_shinfo(skb)->nr_frags, skb_shinfo(skb)->gso_size, skb_shinfo(skb)->gso_segs);
 	printk(KERN_ERR "\t proto=%d, ip_summed=%d, priority=%d\n", ntohs(skb->protocol), skb->ip_summed, skb->priority);
 #ifdef CONFIG_NET_SKB_RECYCLE
-	printk(KERN_ERR "\t skb_recycle=%p, hw_cookie=%p\n", skb->skb_recycle, skb->hw_cookie);
+	printk(KERN_ERR "\t skb_recycle=%p, hw_cookie=0x%x\n", skb->skb_recycle, skb->hw_cookie);
 #endif /* CONFIG_NET_SKB_RECYCLE */
 }
 
@@ -1361,16 +1361,38 @@ static inline int mv_eth_tx_policy(struct eth_port *pp, struct sk_buff *skb)
 #ifdef CONFIG_NET_SKB_RECYCLE
 int mv_eth_skb_recycle(struct sk_buff *skb)
 {
-	struct eth_pbuf *pkt = skb->hw_cookie;
-	struct bm_pool *pool = &mv_eth_pool[pkt->pool];
-	int status = 0;
+	struct eth_pbuf *pkt = (struct eth_pbuf *)(skb->hw_cookie & ~BIT(0));
+	struct bm_pool  *pool;
+	int             status = 0;
 
-	if (skb_recycle_check(skb, pool->pkt_size)) {
+	if (mvPp2MaxCheck(pkt->pool, MV_ETH_BM_POOLS, "bm_pool"))
+		goto err;
+
+	pool = &mv_eth_pool[pkt->pool];
+	if (skb->hw_cookie & BIT(0)) {
+		/* hw_cookie is not valid for recycle */
+		STAT_DBG(pool->stats.skb_hw_cookie_err++);
+		goto err;
+	}
 
+	/* Check validity of skb->head - some Linux functions (skb_expand_head) reallocate it */
+	if (skb->head != pkt->pBuf) {
+		/*
+		pr_err("%s: skb=%p, pkt=%p, Wrong skb->head=%p != pkt->pBuf=%p\n",
+			__func__, skb, pkt, skb->head, pkt->pBuf);
+		*/
+		STAT_DBG(pool->stats.skb_hw_cookie_err++);
+		goto err;
+	}
+
+	if (skb_recycle_check(skb, pool->pkt_size)) {
 #ifdef CONFIG_MV_ETH_DEBUG_CODE
 		/* Sanity check */
-		/*if (skb->truesize != ((skb->end - skb->head) + sizeof(struct sk_buff)))
-			mv_eth_skb_print(skb);*/
+		if (SKB_TRUESIZE(skb->end - skb->head) != skb->truesize) {
+			printk(KERN_ERR "%s: skb=%p, Wrong SKB_TRUESIZE(end - head)=%d\n",
+				__func__, skb, SKB_TRUESIZE(skb->end - skb->head));
+			mv_eth_skb_print(skb);
+		}
 #endif /* CONFIG_MV_ETH_DEBUG_CODE */
 
 		STAT_DBG(pool->stats.skb_recycled_ok++);
@@ -1380,13 +1402,12 @@ int mv_eth_skb_recycle(struct sk_buff *skb)
 
 		return 0;
 	}
-
+	STAT_DBG(pool->stats.skb_recycled_err++);
 	/* printk(KERN_ERR "mv_eth_skb_recycle failed: pool=%d, pkt=%p, skb=%p\n", pkt->pool, pkt, skb); */
-
+err:
 	mvOsFree(pkt);
-	skb->hw_cookie = NULL;
-
-	STAT_DBG(pool->stats.skb_recycled_err++);
+	skb->hw_cookie = 0;
+	skb->skb_recycle = NULL;
 
 	return 1;
 }
@@ -1747,7 +1768,7 @@ static inline int mv_eth_rx(struct eth_port *pp, int rx_todo, int rxq, struct na
 #ifdef CONFIG_NET_SKB_RECYCLE
 		if (mv_eth_is_recycle()) {
 			skb->skb_recycle = mv_eth_skb_recycle;
-			skb->hw_cookie = pkt;
+			skb->hw_cookie = (__u32)pkt;
 			pkt = NULL;
 		}
 #endif /* CONFIG_NET_SKB_RECYCLE */
@@ -4666,8 +4687,8 @@ void mv_eth_pool_status_print(int pool)
 	pr_info("     skb_alloc_ok=%u, bm_put=%u, stack_put=%u, stack_get=%u\n",
 	       bm_pool->stats.skb_alloc_ok, bm_pool->stats.bm_put, bm_pool->stats.stack_put, bm_pool->stats.stack_get);
 
-	pr_info("     skb_recycled_ok=%u, skb_recycled_err=%u\n",
-	       bm_pool->stats.skb_recycled_ok, bm_pool->stats.skb_recycled_err);
+	pr_info("     skb_recycled_ok=%u, skb_recycled_err=%u, skb_hw_cookie_err=%u\n",
+	       bm_pool->stats.skb_recycled_ok, bm_pool->stats.skb_recycled_err, bm_pool->stats.skb_hw_cookie_err);
 #endif /* CONFIG_MV_ETH_STAT_DBG */
 
 	if (bm_pool->stack) {
@@ -4676,11 +4697,6 @@ void mv_eth_pool_status_print(int pool)
 	}
 
 	memset(&bm_pool->stats, 0, sizeof(bm_pool->stats));
-
-#ifdef CONFIG_MV_ETH_STAT_ERR
-	pr_info("     Errors: skb_alloc_oom=%u, stack_empty=%u, stack_full=%u\n",
-	       bm_pool->stats.skb_alloc_oom, bm_pool->stats.stack_empty, bm_pool->stats.stack_full);
-#endif /* #ifdef CONFIG_MV_ETH_STAT_ERR */
 }
 
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
index 7497ab5..9dd7b31 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
@@ -422,6 +422,7 @@ struct pool_stats {
 	u32 skb_alloc_ok;
 	u32 skb_recycled_ok;
 	u32 skb_recycled_err;
+	u32 skb_hw_cookie_err;
 #endif /* CONFIG_MV_ETH_STAT_DBG */
 };
 
@@ -690,7 +691,7 @@ static inline void mv_eth_pkt_free(struct eth_pbuf *pkt)
 
 #ifdef CONFIG_NET_SKB_RECYCLE
 	skb->skb_recycle = NULL;
-	skb->hw_cookie = NULL;
+	skb->hw_cookie = 0;
 #endif /* CONFIG_NET_SKB_RECYCLE */
 
 	dev_kfree_skb_any(skb);
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index e82bb58..c54c943 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -440,7 +440,7 @@ struct sk_buff {
 	void			(*destructor)(struct sk_buff *skb);
 #ifdef CONFIG_NET_SKB_RECYCLE
 	int			(*skb_recycle) (struct sk_buff *skb);
-	void			*hw_cookie;
+	__u32			hw_cookie;
 #endif /* CONFIG_NET_SKB_RECYCLE */
 #if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)
 	struct nf_conntrack	*nfct;
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index 01461dd..b4a7d25 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -409,11 +409,11 @@ static inline void skb_release_data(struct sk_buff *skb)
 	}
 #ifdef CONFIG_NET_SKB_RECYCLE
 	/* Workaround for the cases when recycle callback was not called */
-	if (skb->hw_cookie) {
-		kfree(skb->hw_cookie);
-		skb->hw_cookie = NULL;
+	if (skb->skb_recycle) {
+		/* Sign that skb is not available for recycle */
+		skb->hw_cookie |= BIT(0);
+		skb->skb_recycle(skb);
 	}
-	skb->skb_recycle = NULL;
 #endif /* CONFIG_NET_SKB_RECYCLE */	
 }
 
@@ -662,7 +662,7 @@ static struct sk_buff *__skb_clone(struct sk_buff *n, struct sk_buff *skb)
 
 #ifdef CONFIG_NET_SKB_RECYCLE
 	n->skb_recycle = NULL;
-	n->hw_cookie = NULL;
+	n->hw_cookie = 0;
 #endif /* CONFIG_NET_SKB_RECYCLE */
 
 	C(tail);
@@ -991,16 +991,6 @@ int pskb_expand_head(struct sk_buff *skb, int nhead, int ntail,
 	       offsetof(struct skb_shared_info, frags[skb_shinfo(skb)->nr_frags]));
 
 	if (fastpath) {
-
-#ifdef CONFIG_NET_SKB_RECYCLE
-		/* Workaround for the cases when recycle callback was not called */
-		if (skb->hw_cookie) {
-			kfree(skb->hw_cookie);
-			skb->hw_cookie = NULL;
-		}
-		skb->skb_recycle = NULL;
-#endif /* CONFIG_NET_SKB_RECYCLE */
-
 		kfree(skb->head);
 	} else {
 		/* copy this zero copy skb frags */
-- 
1.7.5.4

