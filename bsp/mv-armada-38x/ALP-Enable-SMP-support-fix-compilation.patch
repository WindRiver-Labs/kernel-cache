From 25678be47b30ebde4305639fb2f6cf9d20e11b5e Mon Sep 17 00:00:00 2001
From: Kosta Zertsekel <konszert@marvell.com>
Date: Sun, 14 Apr 2013 10:21:49 +0300
Subject: [PATCH 0575/1825] ALP: Enable SMP support, fix compilation

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 34e9e13b0c0d5f3962dae5d2a3e8e648261c0612

Signed-off-by: Kosta Zertsekel <konszert@marvell.com>
Change-Id: I992410283385adfd82cc1032a0eb77b05503e2f7
Reviewed-on: http://vgitil04.il.marvell.com:8080/1522
Reviewed-by: Eran Ben-Avi <benavi@marvell.com>
Tested-by: Eran Ben-Avi <benavi@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-avantalp/headsmp.S |    2 +-
 arch/arm/mach-avantalp/platsmp.c |   17 ++++++-----------
 2 files changed, 7 insertions(+), 12 deletions(-)

diff --git a/arch/arm/mach-avantalp/headsmp.S b/arch/arm/mach-avantalp/headsmp.S
index 4c6042c..e7df510 100644
--- a/arch/arm/mach-avantalp/headsmp.S
+++ b/arch/arm/mach-avantalp/headsmp.S
@@ -7,7 +7,7 @@
  * This provides a "holding pen" into which all secondary cores are held
  * until we're ready for them to initialise.
  */
-ENTRY(avantalp_secondary_startup)
+ENTRY(alp_secondary_startup)
 	mrc	p15, 0, r0, c0, c0, 5
 	and	r0, r0, #15
 	adr	r4, 1f
diff --git a/arch/arm/mach-avantalp/platsmp.c b/arch/arm/mach-avantalp/platsmp.c
index b57ad51..075a1a7 100644
--- a/arch/arm/mach-avantalp/platsmp.c
+++ b/arch/arm/mach-avantalp/platsmp.c
@@ -21,7 +21,9 @@
 
 #include "core.h"
 
-extern void avantalp_secondary_startup(void);
+unsigned int group_cpu_mask = ((1 << NR_CPUS) - 1);
+
+extern void alp_secondary_startup(void);
 
 /*
  * Initialise the CPU possible map early - this describes the CPUs
@@ -59,12 +61,7 @@ void __init platform_smp_prepare_cpus(unsigned int max_cpus)
 	 * until it receives a soft interrupt, and then the
 	 * secondary CPU branches to this address.
 	 */
-	/* Set resume control and address */
-#if 0
-	MV_REG_WRITE(AXP_CPU_RESUME_CTRL_REG, 0x0);
-	MV_REG_WRITE(AXP_CPU_RESUME_ADDR_REG(cpu),
-			virt_to_phys(axp_secondary_startup));
-#endif
+	writel(CPU_RESUME_ADDR_REG, virt_to_phys(alp_secondary_startup));
 }
 
 /*
@@ -130,11 +127,9 @@ int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
 	write_pen_release(cpu_logical_map(cpu));
 
 	/*
-	 * Send the secondary CPU a soft interrupt, thereby causing
-	 * the boot monitor to read the system wide flags register,
-	 * and branch to the address found there.
+	 * Get CPU out of software reset state.
 	 */
-	gic_raise_softirq(cpumask_of(cpu), 1);
+	writel(CPU_RESUME_CTRL_REG, 0x0);
 
 	timeout = jiffies + (1 * HZ);
 	while (time_before(jiffies, timeout)) {
-- 
1.7.5.4

