From 4a013ed5f7d0a2915b41306c1dde529794ee9ebb Mon Sep 17 00:00:00 2001
From: Tawfik Bayouk <tawfik@marvell.com>
Date: Thu, 13 Dec 2012 19:43:35 +0200
Subject: [PATCH 0385/1825] Armada300: Align arch/arm/mach-kirkwood.

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit d4b9e9bbbf5fdb7e2f4ea1fddf7fe359d1f99f86

Change-Id: Icfd599fee64db2c87d8961d454fe112bdcaf1493
Signed-off-by: Tawfik Bayouk <tawfik@marvell.com>
Signed-off-by: Kosta Zertsekel <konszert@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-kirkwood/Kconfig                     |   16 +
 arch/arm/mach-kirkwood/Makefile                    |   67 +
 arch/arm/mach-kirkwood/addr-map.c                  |   12 +
 arch/arm/mach-kirkwood/btns_dev.h                  |   36 +
 arch/arm/mach-kirkwood/btns_device.c               |  134 ++
 arch/arm/mach-kirkwood/common.c                    |   45 +-
 arch/arm/mach-kirkwood/common.h                    |    3 +
 arch/arm/mach-kirkwood/config/mvRules.mk           |  142 ++
 arch/arm/mach-kirkwood/config/mvSysHwConfig.h      |  372 +++++
 arch/arm/mach-kirkwood/db88f6281-bp-setup.c        |   58 +-
 arch/arm/mach-kirkwood/dbg-trace.c                 |  110 ++
 arch/arm/mach-kirkwood/dbg-trace.h                 |   24 +
 arch/arm/mach-kirkwood/export.c                    |  123 ++
 arch/arm/mach-kirkwood/include/mach/io.h           |    2 +
 arch/arm/mach-kirkwood/include/mach/irqs.h         |    5 +
 arch/arm/mach-kirkwood/include/mach/kirkwood.h     |   14 +-
 .../kw_family/boardEnv/mvBoardEnvLib.c             | 1512 ++++++++++++++++++++
 .../kw_family/boardEnv/mvBoardEnvLib.h             |  357 +++++
 .../kw_family/boardEnv/mvBoardEnvSpec.c            | 1425 ++++++++++++++++++
 .../kw_family/boardEnv/mvBoardEnvSpec.h            |  342 +++++
 arch/arm/mach-kirkwood/kw_family/cpu/mvCpu.c       |  202 +++
 arch/arm/mach-kirkwood/kw_family/cpu/mvCpu.h       |   84 ++
 .../mach-kirkwood/kw_family/ctrlEnv/mvCtrlEnvLib.c |  635 ++++++++
 .../mach-kirkwood/kw_family/ctrlEnv/mvCtrlEnvLib.h |  102 ++
 .../kw_family/ctrlEnv/mvCtrlEnvRegs.h              |  346 +++++
 .../kw_family/ctrlEnv/mvCtrlEnvSpec.h              |  183 +++
 .../mach-kirkwood/kw_family/ctrlEnv/sys/mvSysTdm.c |  273 ++++
 .../mach-kirkwood/kw_family/ctrlEnv/sys/mvSysTdm.h |  106 ++
 arch/arm/mach-kirkwood/pcie.c                      |    2 +-
 arch/arm/mach-kirkwood/rd88f6192-nas-setup.c       |   23 +
 arch/arm/mach-kirkwood/rd88f6282-a-setup.c         |  103 ++
 arch/arm/mach-kirkwood/xcat98dx-setup.c            |   99 ++
 32 files changed, 6939 insertions(+), 18 deletions(-)
 create mode 100644 arch/arm/mach-kirkwood/btns_dev.h
 create mode 100644 arch/arm/mach-kirkwood/btns_device.c
 create mode 100644 arch/arm/mach-kirkwood/config/mvRules.mk
 create mode 100644 arch/arm/mach-kirkwood/config/mvSysHwConfig.h
 create mode 100644 arch/arm/mach-kirkwood/dbg-trace.c
 create mode 100644 arch/arm/mach-kirkwood/dbg-trace.h
 create mode 100644 arch/arm/mach-kirkwood/export.c
 create mode 100644 arch/arm/mach-kirkwood/kw_family/boardEnv/mvBoardEnvLib.c
 create mode 100644 arch/arm/mach-kirkwood/kw_family/boardEnv/mvBoardEnvLib.h
 create mode 100644 arch/arm/mach-kirkwood/kw_family/boardEnv/mvBoardEnvSpec.c
 create mode 100644 arch/arm/mach-kirkwood/kw_family/boardEnv/mvBoardEnvSpec.h
 create mode 100644 arch/arm/mach-kirkwood/kw_family/cpu/mvCpu.c
 create mode 100644 arch/arm/mach-kirkwood/kw_family/cpu/mvCpu.h
 create mode 100644 arch/arm/mach-kirkwood/kw_family/ctrlEnv/mvCtrlEnvLib.c
 create mode 100644 arch/arm/mach-kirkwood/kw_family/ctrlEnv/mvCtrlEnvLib.h
 create mode 100644 arch/arm/mach-kirkwood/kw_family/ctrlEnv/mvCtrlEnvRegs.h
 create mode 100644 arch/arm/mach-kirkwood/kw_family/ctrlEnv/mvCtrlEnvSpec.h
 create mode 100644 arch/arm/mach-kirkwood/kw_family/ctrlEnv/sys/mvSysTdm.c
 create mode 100644 arch/arm/mach-kirkwood/kw_family/ctrlEnv/sys/mvSysTdm.h
 create mode 100644 arch/arm/mach-kirkwood/rd88f6282-a-setup.c
 create mode 100644 arch/arm/mach-kirkwood/xcat98dx-setup.c

diff --git a/arch/arm/mach-kirkwood/Kconfig b/arch/arm/mach-kirkwood/Kconfig
index 90ceab7..1cf6606 100644
--- a/arch/arm/mach-kirkwood/Kconfig
+++ b/arch/arm/mach-kirkwood/Kconfig
@@ -8,6 +8,16 @@ config MACH_DB88F6281_BP
 	  Say 'Y' here if you want your kernel to support the
 	  Marvell DB-88F6281-BP Development Board.
 
+config MACH_XCAT98DX
+	bool "Marvell XCAT-98DX Development Board"
+	select MV_XCAT98DX
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  Marvell xCat-98DX Development Board.
+
+config MV_XCAT98DX
+	bool
+
 config MACH_RD88F6192_NAS
 	bool "Marvell RD-88F6192-NAS Reference Board"
 	help
@@ -20,6 +30,12 @@ config MACH_RD88F6281
 	  Say 'Y' here if you want your kernel to support the
 	  Marvell RD-88F6281 Reference Board.
 
+config MACH_RD88F6282_A
+	bool "Marvell RD-88F6282-A Reference Board"
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  Marvell RD-88F6282-A Reference Board.
+
 config MACH_MV88F6281GTW_GE
 	bool "Marvell 88F6281 GTW GE Board"
 	help
diff --git a/arch/arm/mach-kirkwood/Makefile b/arch/arm/mach-kirkwood/Makefile
index e299a95..5d627cc 100644
--- a/arch/arm/mach-kirkwood/Makefile
+++ b/arch/arm/mach-kirkwood/Makefile
@@ -1,8 +1,10 @@
 obj-y				+= common.o addr-map.o irq.o pcie.o mpp.o
 
 obj-$(CONFIG_MACH_DB88F6281_BP)		+= db88f6281-bp-setup.o
+obj-$(CONFIG_MACH_XCAT98DX)		+= xcat98dx-setup.o
 obj-$(CONFIG_MACH_RD88F6192_NAS)	+= rd88f6192-nas-setup.o
 obj-$(CONFIG_MACH_RD88F6281)		+= rd88f6281-setup.o
+obj-$(CONFIG_MACH_RD88F6282_A)		+= rd88f6282-a-setup.o
 obj-$(CONFIG_MACH_MV88F6281GTW_GE)	+= mv88f6281gtw_ge-setup.o
 obj-$(CONFIG_MACH_SHEEVAPLUG)		+= sheevaplug-setup.o
 obj-$(CONFIG_MACH_ESATA_SHEEVAPLUG)	+= sheevaplug-setup.o
@@ -22,3 +24,68 @@ obj-$(CONFIG_MACH_T5325)		+= t5325-setup.o
 obj-$(CONFIG_CPU_IDLE)			+= cpuidle.o
 obj-$(CONFIG_ARCH_KIRKWOOD_DT)		+= board-dt.o
 obj-$(CONFIG_MACH_DREAMPLUG_DT)		+= board-dreamplug.o
+
+obj-y					+= kirkwood.o
+
+# Marvell adds
+include $(srctree)/arch/arm/mach-kirkwood/config/mvRules.mk
+
+COMMON_OBJS	= $(COMMON_DIR)/mvDebug.o $(COMMON_DIR)/mvCommon.o $(COMMON_DIR)/mvStack.o
+
+OSSERVICES_OBJS	= $(OSSERV_DIR)/mvOs.o
+
+HAL_OBJS	= $(HAL_TWSI_DIR)/mvTwsi.o $(HAL_GPP_DIR)/mvGpp.o
+
+QD_OBJS		= $(HAL_QD_DIR)/src/driver/gtDrvConfig.o $(HAL_QD_DIR)/src/driver/gtDrvEvents.o \
+		  $(HAL_QD_DIR)/src/driver/gtHwCntl.o $(HAL_QD_DIR)/src/platform/gtMiiSmiIf.o \
+		  $(HAL_QD_DIR)/src/platform/platformDeps.o $(HAL_QD_DIR)/src/platform/gtSem.o \
+		  $(HAL_QD_DIR)/src/platform/gtDebug.o $(HAL_QD_DIR)/src/msapi/gtBrgFdb.o \
+		  $(HAL_QD_DIR)/src/msapi/gtBrgStp.o $(HAL_QD_DIR)/src/msapi/gtBrgVlan.o \
+		  $(HAL_QD_DIR)/src/msapi/gtEvents.o $(HAL_QD_DIR)/src/msapi/gtPortCtrl.o \
+		  $(HAL_QD_DIR)/src/msapi/gtPortStat.o $(HAL_QD_DIR)/src/msapi/gtPortStatus.o \
+		  $(HAL_QD_DIR)/src/msapi/gtQosMap.o $(HAL_QD_DIR)/src/msapi/gtPIRL.o \
+		  $(HAL_QD_DIR)/src/msapi/gtPhyCtrl.o $(HAL_QD_DIR)/src/msapi/gtPhyInt.o \
+		  $(HAL_QD_DIR)/src/msapi/gtSysConfig.o $(HAL_QD_DIR)/src/msapi/gtSysCtrl.o \
+		  $(HAL_QD_DIR)/src/msapi/gtVersion.o $(HAL_QD_DIR)/src/msapi/gtUtils.o \
+		  $(HAL_QD_DIR)/src/msapi/gtBrgVtu.o $(HAL_QD_DIR)/src/msapi/gtPortRmon.o \
+		  $(HAL_QD_DIR)/src/msapi/gtSysStatus.o $(HAL_QD_DIR)/src/msapi/gtPortRateCtrl.o \
+		  $(HAL_QD_DIR)/src/msapi/gtPortPav.o $(HAL_QD_DIR)/src/msapi/gtVct.o \
+		  $(HAL_QD_DIR)/src/msapi/gtPIRL2.o $(HAL_QD_DIR)/src/msapi/gtCCPVT.o \
+		  $(HAL_QD_DIR)/src/msapi/gtPCSCtrl.o $(HAL_QD_DIR)/src/msapi/gtCCPVT.o
+
+KW_FAM_OBJS	= $(BOARD_ENV_DIR)/mvBoardEnvSpec.o \
+		  $(SOC_ENV_DIR)/mvCtrlEnvLib.o \
+		  $(BOARD_ENV_DIR)/mvBoardEnvLib.o \
+		  $(SOC_CPU_DIR)/mvCpu.o
+
+LSP_OBJS	= $(LSP_DIR)/export.o $(LSP_DIR)/btns_device.o
+
+kirkwood-objs	:= $(LSP_OBJS) $(COMMON_OBJS) $(OSSERVICES_OBJS) \
+		  $(HAL_OBJS) $(KW_FAM_OBJS)
+
+kirkwood-$(CONFIG_MV_INCLUDE_GIG_ETH)		+= $(HAL_ETH_DIR)/mvEthDebug.o \
+						   $(HAL_ETHPHY_DIR)/mvEthPhy.o \
+						   $(HAL_ETH_DIR)/mvEth.o
+
+kirkwood-$(CONFIG_MV_ETH_NFP)			+= $(HAL_ETH_NFP_DIR)/mvNfp.o
+kirkwood-$(CONFIG_MV_ETH_NFP_NAT_SUPPORT)	+= $(HAL_ETH_NFP_DIR)/mvNfpNat.o
+kirkwood-$(CONFIG_MV_ETH_NFP_FDB_SUPPORT)	+= $(HAL_ETH_NFP_DIR)/mvNfpFdb.o
+kirkwood-$(CONFIG_MV_ETH_NFP_PPP)		+= $(HAL_ETH_NFP_DIR)/mvNfpPpp.o
+kirkwood-$(CONFIG_MV_ETH_NFP_SEC)		+= $(HAL_ETH_NFP_DIR)/mvNfpSec.o
+
+kirkwood-$(CONFIG_MV_INCLUDE_CESA)		+= $(HAL_CESA_DIR)/mvCesa.o \
+						   $(HAL_CESA_DIR)/mvCesaDebug.o \
+						   $(HAL_CESA_DIR)/mvMD5.o \
+						   $(HAL_CESA_DIR)/mvSHA1.o \
+						   $(HAL_CESA_AES_DIR)/mvAesAlg.o \
+						   $(HAL_CESA_AES_DIR)/mvAesApi.o
+
+kirkwood-$(CONFIG_MV_CESA_TEST)			+= $(HAL_CESA_DIR)/mvCesaTest.o
+kirkwood-$(CONFIG_MV_INCLUDE_SPI)		+= $(HAL_SPI_DIR)/mvSpi.o \
+						   $(HAL_SPI_DIR)/mvSpiCmnd.o
+kirkwood-$(CONFIG_MV_INCLUDE_TDM)		+= $(SOC_SYS_DIR)/mvSysTdm.o
+kirkwood-$(CONFIG_MV_INCLUDE_TS)		+= $(HAL_TS_DIR)/mvTsu.o
+kirkwood-$(CONFIG_MV_CPU_PERF_CNTRS)		+= $(HAL_CPU_DIR)/mvCpuCntrs.o
+kirkwood-$(CONFIG_MV_CPU_L2_PERF_CNTRS)		+= $(HAL_CPU_DIR)/mvCpuL2Cntrs.o
+
+kirkwood-$(CONFIG_MV_INCLUDE_SWITCH)		+= $(QD_OBJS)
diff --git a/arch/arm/mach-kirkwood/addr-map.c b/arch/arm/mach-kirkwood/addr-map.c
index e9a7180..70a28c7 100644
--- a/arch/arm/mach-kirkwood/addr-map.c
+++ b/arch/arm/mach-kirkwood/addr-map.c
@@ -15,6 +15,8 @@
 #include <mach/hardware.h>
 #include <plat/addr-map.h>
 #include "common.h"
+#include "boardEnv/mvBoardEnvSpec.h"
+#include "boardEnv/mvBoardEnvLib.h"
 
 /*
  * Generic Address Decode Windows bit settings
@@ -22,6 +24,7 @@
 #define TARGET_DEV_BUS		1
 #define TARGET_SRAM		3
 #define TARGET_PCIE		4
+#define TARGET_PP		0xc
 #define ATTR_DEV_SPI_ROM	0x1e
 #define ATTR_DEV_BOOT		0x1d
 #define ATTR_DEV_NAND		0x2f
@@ -34,6 +37,7 @@
 #define ATTR_PCIE1_IO		0xd0
 #define ATTR_PCIE1_MEM		0xd8
 #define ATTR_SRAM		0x01
+#define ATTR_PP			0x00
 
 /*
  * Description of the windows needed by the platform code
@@ -72,6 +76,14 @@ static const struct __initdata orion_addr_map_info addr_map_info[] = {
 	{ 5, KIRKWOOD_SRAM_PHYS_BASE, KIRKWOOD_SRAM_SIZE,
 	  TARGET_SRAM, ATTR_SRAM, -1
 	},
+#ifdef CONFIG_MV_XCAT98DX
+	/*
+	 * Window for PP (Prestera Switch).
+	 */
+	{ 6, KIRKWOOD_PP_PHYS_BASE, KIRKWOOD_PP_SIZE,
+	  TARGET_PP, ATTR_PP, -1
+	},
+#endif
 	/* End marker */
 	{ -1, 0, 0, 0, 0, 0 }
 };
diff --git a/arch/arm/mach-kirkwood/btns_dev.h b/arch/arm/mach-kirkwood/btns_dev.h
new file mode 100644
index 0000000..b65236f
--- /dev/null
+++ b/arch/arm/mach-kirkwood/btns_dev.h
@@ -0,0 +1,36 @@
+/*******************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+#ifndef _BTNS_DEV_H_
+#define _BTNS_DEV_H_
+
+/* rd6281 */
+#define WPS_GPP 46
+#define WPS_BTN (1 << WPS_GPP)
+
+/* rd6192 tact switch */
+#define UP_GPP		30
+#define DOWN_GPP	34
+#define LEFT_GPP	32
+#define RIGHT_GPP	31
+#define PRESSED_GPP	25
+
+struct btns_platform_data {
+        unsigned int    btns_num;
+        struct btn_data *btns_data_arr;
+};
+
+#endif /* _BTNS_DEV_H_ */
diff --git a/arch/arm/mach-kirkwood/btns_device.c b/arch/arm/mach-kirkwood/btns_device.c
new file mode 100644
index 0000000..cf36baa
--- /dev/null
+++ b/arch/arm/mach-kirkwood/btns_device.c
@@ -0,0 +1,134 @@
+/********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+#include <linux/platform_device.h>
+#include <linux/miscdevice.h>
+#include "btns_dev.h"
+#include "../plat-orion/mv_drivers_lsp/mv_btns/btns_driver.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+
+/*
+ * common debug for all
+ */
+#undef DEBUG
+
+#ifdef DEBUG
+#define dprintk   printk
+#else
+#define dprintk(a...)
+#endif
+
+static struct btns_platform_data btns_data;
+static struct btn_data btn_data_rd_6281[] = {
+	[0] = {
+		.gpp_id		= WPS_GPP,
+		.default_gpp_val= 0x0,
+		.btn_op		= BTN_CHANGE,
+		.btn_name	= "WPS",
+	}
+};
+
+static struct btn_data btn_data_rd_6192[] = {
+	[0] = {
+		.gpp_id		= UP_GPP,
+		.default_gpp_val= 0x0,
+		.btn_op		= BTN_PUSH,
+		.btn_name	= "UP",
+	},
+	[1] = {
+		.gpp_id		= DOWN_GPP,
+		.default_gpp_val= 0x0,
+		.btn_op		= BTN_PUSH,
+		.btn_name	= "DOWN",
+	},
+	[2] = {
+		.gpp_id		= LEFT_GPP,
+		.default_gpp_val= 0x0,
+		.btn_op		= BTN_PUSH,
+		.btn_name	= "LEFT",
+	},
+/*	[3] = {
+		.gpp_id		= PRESSED_GPP,
+		.default_gpp_val= 0x0,
+		.btn_op		= BTN_PUSH,
+		.btn_name	= "PRESSED",
+	},*/
+	[3] = {
+		.gpp_id		= RIGHT_GPP,
+		.default_gpp_val= 0x0,
+		.btn_op		= BTN_PUSH,
+		.btn_name	= "RIGHT",
+	},
+};
+
+static struct platform_device btns_device = {
+	.name		= MV_BTNS_NAME,
+	.id		= 0,
+	.num_resources	= 0,
+	.dev = {
+		.platform_data  = &btns_data,
+	},
+};
+
+static int btns_init_data(struct platform_device *pdev)
+{
+	switch (mvBoardIdGet()) {
+	case RD_88F6281A_ID:
+		dprintk("%s - RD 6281A\n", __FUNCTION__);
+		btns_data.btns_data_arr = btn_data_rd_6281;
+		btns_data.btns_num = (btns_data.btns_data_arr == NULL) ?
+			0 : ARRAY_SIZE(btn_data_rd_6281);
+		break;
+	case RD_88F6192A_ID:
+		dprintk("%s - RD 6192A\n", __FUNCTION__);
+		btns_data.btns_data_arr = btn_data_rd_6192;
+		btns_data.btns_num = (btns_data.btns_data_arr == NULL) ?
+			0 : ARRAY_SIZE(btn_data_rd_6192);
+		break;
+	default:
+		btns_data.btns_data_arr = NULL;
+	}
+
+	if (btns_data.btns_num)
+		dprintk("%s - Number of configured buttons: %d\n",
+			__func__, btns_data.btns_num);
+
+	return 0;
+}
+
+static int __init mv_btns_init(void)
+{
+	int status;
+
+	printk(KERN_NOTICE "MV Buttons Device Load\n");
+
+	/* Initialize btns related structures and data*/
+	status = btns_init_data(&btns_device);
+	if (status) {
+		printk("Can't initialize Marvell Buttons Data, status=%d\n", status);
+		return status;
+	}
+
+	/* register device */
+	status = platform_device_register(&btns_device);
+	if (status) {
+		printk("Can't register Marvell Buttons Device, status=%d\n", status);
+		return status;
+	}
+
+	return 0;
+}
+
+subsys_initcall(mv_btns_init);
diff --git a/arch/arm/mach-kirkwood/common.c b/arch/arm/mach-kirkwood/common.c
index d275802..621e986 100644
--- a/arch/arm/mach-kirkwood/common.c
+++ b/arch/arm/mach-kirkwood/common.c
@@ -32,6 +32,8 @@
 #include <plat/time.h>
 #include <plat/addr-map.h>
 #include "common.h"
+#include "boardEnv/mvBoardEnvSpec.h"
+#include "boardEnv/mvBoardEnvLib.h"
 
 /*****************************************************************************
  * I/O Address Mapping
@@ -53,6 +55,12 @@ static struct map_desc kirkwood_io_desc[] __initdata = {
 		.length		= KIRKWOOD_REGS_SIZE,
 		.type		= MT_DEVICE,
 	},
+	{
+		.virtual	= KIRKWOOD_PP_VIRT_BASE,
+		.pfn		= __phys_to_pfn(KIRKWOOD_PP_PHYS_BASE),
+		.length		= KIRKWOOD_PP_SIZE,
+		.type		= MT_DEVICE,
+	},
 };
 
 void __init kirkwood_map_io(void)
@@ -106,6 +114,15 @@ void __init kirkwood_ge01_init(struct mv643xx_eth_platform_data *eth_data)
 
 
 /*****************************************************************************
+ * TDM
+ ****************************************************************************/
+void __init kirkwood_tdm_init(void)
+{
+	kirkwood_clk_ctrl |= CGC_TDM;
+}
+
+
+/*****************************************************************************
  * Ethernet switch
  ****************************************************************************/
 void __init kirkwood_ge00_switch_init(struct dsa_platform_data *d, int irq)
@@ -114,6 +131,12 @@ void __init kirkwood_ge00_switch_init(struct dsa_platform_data *d, int irq)
 }
 
 
+void __init kirkwood_ge01_switch_init(struct dsa_platform_data *d, int irq)
+{
+       orion_ge01_switch_init(d, irq);
+}
+
+
 /*****************************************************************************
  * NAND flash
  ****************************************************************************/
@@ -312,8 +335,15 @@ void __init kirkwood_wdt_init(void)
 /*****************************************************************************
  * Time handling
  ****************************************************************************/
-void __init kirkwood_init_early(void)
+#ifdef CONFIG_JTAG_DEBUG
+int support_wait_for_interrupt = 1;
+#endif
+
+void kirkwood_init_early(void)
 {
+#ifdef CONFIG_JTAG_DEBUG
+	support_wait_for_interrupt = 0; /* Lauterbach JTAG support */
+#endif
 	orion_time_set_base(TIMER_VIRT_BASE);
 }
 
@@ -386,6 +416,16 @@ void __init kirkwood_audio_init(void)
 	platform_device_register(&kirkwood_pcm_device);
 }
 
+
+/*****************************************************************************
+ * xCat clock init
+ ****************************************************************************/
+void __init kirkwood_xcat_clock_init(void)
+{
+	kirkwood_clk_ctrl |= 0x00dfc3fd;
+}
+
+
 /*****************************************************************************
  * General
  ****************************************************************************/
@@ -466,7 +506,8 @@ void __init kirkwood_init(void)
 #endif
 
 	/* internal devices that every board has */
-	kirkwood_rtc_init();
+	if (mvBoardIdGet() != XCAT98DX_ID)
+		kirkwood_rtc_init();
 	kirkwood_wdt_init();
 	kirkwood_xor0_init();
 	kirkwood_xor1_init();
diff --git a/arch/arm/mach-kirkwood/common.h b/arch/arm/mach-kirkwood/common.h
index fa8e768..c49b035 100644
--- a/arch/arm/mach-kirkwood/common.h
+++ b/arch/arm/mach-kirkwood/common.h
@@ -38,7 +38,9 @@ void kirkwood_pcie_id(u32 *dev, u32 *rev);
 void kirkwood_ehci_init(void);
 void kirkwood_ge00_init(struct mv643xx_eth_platform_data *eth_data);
 void kirkwood_ge01_init(struct mv643xx_eth_platform_data *eth_data);
+void kirkwood_tdm_init(void);
 void kirkwood_ge00_switch_init(struct dsa_platform_data *d, int irq);
+void kirkwood_ge01_switch_init(struct dsa_platform_data *d, int irq);
 void kirkwood_pcie_init(unsigned int portmask);
 void kirkwood_sata_init(struct mv_sata_platform_data *sata_data);
 void kirkwood_sdio_init(struct mvsdio_platform_data *mvsdio_data);
@@ -49,6 +51,7 @@ void kirkwood_uart1_init(void);
 void kirkwood_nand_init(struct mtd_partition *parts, int nr_parts, int delay);
 void kirkwood_nand_init_rnb(struct mtd_partition *parts, int nr_parts, int (*dev_ready)(struct mtd_info *));
 void kirkwood_audio_init(void);
+void kirkwood_xcat_clock_init(void);
 void kirkwood_restart(char, const char *);
 
 /* board init functions for boards not fully converted to fdt */
diff --git a/arch/arm/mach-kirkwood/config/mvRules.mk b/arch/arm/mach-kirkwood/config/mvRules.mk
new file mode 100644
index 0000000..b293183
--- /dev/null
+++ b/arch/arm/mach-kirkwood/config/mvRules.mk
@@ -0,0 +1,142 @@
+# This flags will be used only by the Marvell arch files compilation.
+
+###################################################################################################
+# General definitions
+###################################################################################################
+CPU_ARCH    = ARM
+CHIP        = 88F6281
+VENDOR      = Marvell
+ifeq ($(CONFIG_CPU_BIG_ENDIAN),y)
+ENDIAN      = BE
+else
+ENDIAN      = LE
+endif
+
+###################################################################################################
+# directory structure
+###################################################################################################
+# Main directory structure
+SRC_PATH          = .
+PLAT_PATH	  = ../plat-orion
+PLAT_DRIVERS	  = $(PLAT_PATH)/mv_drivers_lsp
+HAL_DIR           = $(PLAT_PATH)/mv_hal
+COMMON_DIR        = $(PLAT_PATH)/common
+OSSERV_DIR        = $(PLAT_PATH)/linux_oss
+LSP_DIR           = $(SRC_PATH)
+CONFIG_DIR        = $(LSP_DIR)/config
+
+# HALs
+HAL_ETHPHY_DIR    = $(HAL_DIR)/eth-phy
+HAL_FLASH_DIR     = $(HAL_DIR)/flash
+HAL_RTC_DIR       = $(HAL_DIR)/rtc/integ_rtc
+HAL_VOICEBAND     = $(HAL_DIR)/voiceband
+HAL_SLIC_DIR      = $(HAL_VOICEBAND)/slic
+HAL_DAA_DIR       = $(HAL_VOICEBAND)/daa
+HAL_SATA_DIR      = $(HAL_DIR)/sata/CoreDriver/
+HAL_QD_DIR        = $(HAL_DIR)/qd-dsdt
+HAL_SFLASH_DIR    = $(HAL_DIR)/sflash
+HAL_CNTMR_DIR     = $(HAL_DIR)/cntmr
+HAL_GPP_DIR       = $(HAL_DIR)/gpp
+HAL_TWSI_DIR      = $(HAL_DIR)/twsi
+HAL_TWSI_ARCH_DIR = $(SOC_TWSI_DIR)/Arch$(CPU_ARCH)
+HAL_UART_DIR      = $(HAL_DIR)/uart
+HAL_ETH_DIR       = $(HAL_DIR)/eth/gbe
+HAL_ETH_NFP_DIR	  = $(HAL_DIR)/eth/nfp
+HAL_CPU_DIR       = $(HAL_DIR)/cpu
+ifeq ($(CONFIG_MV_INCLUDE_TDM),y)
+HAL_TDM_DIR       = $(HAL_DIR)/voiceband/tdm
+endif
+ifeq ($(CONFIG_MV_INCLUDE_USB),y)
+HAL_USB_DIR       = $(HAL_DIR)/usb
+endif
+ifeq ($(CONFIG_MV_INCLUDE_CESA),y)
+HAL_CESA_DIR	  = $(HAL_DIR)/cesa
+HAL_CESA_AES_DIR  = $(HAL_DIR)/cesa/AES
+endif
+ifeq ($(CONFIG_MV_INCLUDE_SPI),y)
+HAL_SPI_DIR       = $(HAL_DIR)/spi
+endif
+ifeq ($(CONFIG_MV_INCLUDE_TS),y)
+HAL_TS_DIR      = $(HAL_DIR)/ts
+endif
+ifeq ($(CONFIG_MV_INCLUDE_LCD),y)
+HAL_LCD_DIR      = $(HAL_DIR)/lcd
+endif
+
+# Environment components
+KW_FAM_DIR	    = $(LSP_DIR)/kw_family
+SOC_DEVICE_DIR      = $(KW_FAM_DIR)/device
+SOC_CPU_DIR         = $(KW_FAM_DIR)/cpu
+BOARD_ENV_DIR       = $(KW_FAM_DIR)/boardEnv
+SOC_ENV_DIR         = $(KW_FAM_DIR)/ctrlEnv
+SOC_SYS_DIR	    = $(KW_FAM_DIR)/ctrlEnv/sys
+
+#####################################################################################################
+# Include path
+###################################################################################################
+
+LSP_PATH_I       = $(srctree)/arch/arm/mach-kirkwood
+PLAT_PATH_I	 = $(srctree)/arch/arm/plat-orion
+
+HAL_PATH         = -I$(PLAT_PATH_I)/$(HAL_DIR) -I$(PLAT_PATH_I)/$(HAL_SATA_DIR)
+KW_FAM_PATH      = -I$(LSP_PATH_I)/$(KW_FAM_DIR)
+QD_PATH          = -I$(PLAT_PATH_I)/$(HAL_QD_DIR)/Include  -I$(PLAT_PATH_I)/$(HAL_QD_DIR)/Include/h/msApi 	\
+                   -I$(PLAT_PATH_I)/$(HAL_QD_DIR)/Include/h/driver -I$(PLAT_PATH_I)/$(HAL_QD_DIR)/Include/h/platform
+
+COMMON_PATH   	 = -I$(PLAT_PATH_I)/$(COMMON_DIR) -I$(srctree)
+
+OSSERV_PATH      = -I$(PLAT_PATH_I)/$(OSSERV_DIR)
+LSP_PATH         = -I$(LSP_PATH_I)/$(LSP_DIR)
+CONFIG_PATH      = -I$(LSP_PATH_I)/$(CONFIG_DIR)
+DRIVERS_LSP_PATH = -I$(PLAT_PATH_I)/$(PLAT_DRIVERS)
+
+EXTRA_INCLUDE  	 = $(OSSERV_PATH) $(COMMON_PATH) $(HAL_PATH)  $(KW_FAM_PATH) \
+                   $(LSP_PATH) $(CONFIG_PATH) $(DRIVERS_LSP_PATH)
+
+###################################################################################################
+# defines
+###################################################################################################
+MV_DEFINE = -DMV_LINUX -DMV_CPU_$(ENDIAN) -DMV_$(CPU_ARCH)
+
+
+ifeq ($(CONFIG_MV_GATEWAY),y)
+EXTRA_INCLUDE	+= $(QD_PATH)
+EXTRA_CFLAGS    += -DLINUX
+endif
+
+ifeq ($(CONFIG_MV_INCLUDE_SWITCH),y)
+EXTRA_INCLUDE   += $(QD_PATH)
+EXTRA_CFLAGS    += -DLINUX
+endif
+
+ifeq ($(CONFIG_MV_CESA_TEST),y)
+EXTRA_CFLAGS 	+= -DCONFIG_MV_CESA_TEST
+endif
+
+ifeq ($(CONFIG_SATA_DEBUG_ON_ERROR),y)
+EXTRA_CFLAGS    += -DMV_LOG_ERROR
+endif
+
+ifeq ($(CONFIG_SATA_FULL_DEBUG),y)
+EXTRA_CFLAGS    += -DMV_LOG_DEBUG
+endif
+
+ifeq ($(CONFIG_MV_SATA_SUPPORT_ATAPI),y)
+EXTRA_CFLAGS    += -DMV_SUPPORT_ATAPI
+endif
+
+ifeq ($(CONFIG_MV_SATA_ENABLE_1MB_IOS),y)
+EXTRA_CFLAGS    += -DMV_SUPPORT_1MBYTE_IOS
+endif
+
+ifeq ($(CONFIG_MV88F6281),y)
+EXTRA_CFLAGS    += -DMV88F6281
+endif
+
+ifeq ($(CONFIG_MV_CESA_CHAIN_MODE_SUPPORT),y)
+EXTRA_CFLAGS    += -DMV_CESA_CHAIN_MODE_SUPPORT
+endif
+
+EXTRA_CFLAGS 	+= $(EXTRA_INCLUDE) $(MV_DEFINE)
+
+EXTRA_AFLAGS 	+= $(EXTRA_CFLAGS)
diff --git a/arch/arm/mach-kirkwood/config/mvSysHwConfig.h b/arch/arm/mach-kirkwood/config/mvSysHwConfig.h
new file mode 100644
index 0000000..1ecb1c4
--- /dev/null
+++ b/arch/arm/mach-kirkwood/config/mvSysHwConfig.h
@@ -0,0 +1,372 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+
+*******************************************************************************/
+/*******************************************************************************
+* mvSysHwCfg.h - Marvell system HW configuration file
+*
+* DESCRIPTION:
+*       None.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#ifndef __INCmvSysHwConfigh
+#define __INCmvSysHwConfigh
+
+#include "../../../../include/generated/autoconf.h"
+
+#define CONFIG_MARVELL	1
+
+/* includes */
+#define _1K         0x00000400
+#define _4K         0x00001000
+#define _8K         0x00002000
+#define _16K        0x00004000
+#define _32K        0x00008000
+#define _64K        0x00010000
+#define _128K       0x00020000
+#define _256K       0x00040000
+#define _512K       0x00080000
+
+#define _1M         0x00100000
+#define _2M         0x00200000
+#define _4M         0x00400000
+#define _8M         0x00800000
+#define _16M        0x01000000
+#define _32M        0x02000000
+#define _64M        0x04000000
+#define _128M       0x08000000
+#define _256M       0x10000000
+#define _512M       0x20000000
+
+#define _1G         0x40000000
+#define _2G         0x80000000
+
+/****************************************/
+/* Soc supporeted Units definitions	*/
+/****************************************/
+
+#ifdef CONFIG_MV_INCLUDE_TWSI
+#define MV_INCLUDE_TWSI
+#endif
+#ifdef CONFIG_MV_INCLUDE_CESA
+#define MV_INCLUDE_CESA
+#endif
+#ifdef CONFIG_MV_INCLUDE_GIG_ETH
+#define MV_INCLUDE_GIG_ETH
+#endif
+#ifdef CONFIG_MV_INCLUDE_INTEG_SATA
+#define MV_INCLUDE_INTEG_SATA
+#define MV_INCLUDE_SATA
+#endif
+#ifdef CONFIG_MV_INCLUDE_USB
+#define MV_INCLUDE_USB
+#define MV_USB_VOLTAGE_FIX
+#endif
+#ifdef CONFIG_MV_INCLUDE_TDM
+#define MV_INCLUDE_TDM
+#endif
+#ifdef CONFIG_MV_INCLUDE_TWSI
+#define MV_INCLUDE_TWSI
+#endif
+#ifdef CONFIG_MV_INCLUDE_UART
+#define MV_INCLUDE_UART
+#endif
+#ifdef CONFIG_MV_INCLUDE_SPI
+#define MV_INCLUDE_SPI
+#endif
+#ifdef CONFIG_MV_INCLUDE_SFLASH_MTD
+#define MV_INCLUDE_SFLASH_MTD
+#endif
+#ifdef CONFIG_MV_INCLUDE_TS
+#define MV_INCLUDE_TS
+#endif
+
+/* NAND flash stuff */
+#ifdef CONFIG_MV_NAND_BOOT
+#define MV_NAND_BOOT
+#endif
+#ifdef CONFIG_MV_NAND
+#define MV_NAND
+#endif
+
+/* SPI flash stuff */
+#ifdef CONFIG_MV_SPI_BOOT
+#define MV_SPI_BOOT
+#endif
+
+
+/****************************************************************/
+/************* General    configuration ********************/
+/****************************************************************/
+
+/* Enable Clock Power Control */
+#define MV_INCLUDE_CLK_PWR_CNTRL
+
+/* Allow the usage of early printings during initialization */
+#define MV_INCLUDE_EARLY_PRINTK
+
+/****************************************************************/
+/************* NFP configuration ********************************/
+/****************************************************************/
+#define MV_NFP_SEC_Q_SIZE		64
+#define MV_NFP_SEC_REQ_Q_SIZE		1000
+
+
+
+/****************************************************************/
+/************* CESA configuration ********************/
+/****************************************************************/
+
+#ifdef MV_INCLUDE_CESA
+
+#define MV_CESA_MAX_CHAN               4
+
+/* Use 2K of SRAM */
+#define MV_CESA_MAX_BUF_SIZE           1600
+
+#endif /* MV_INCLUDE_CESA */
+
+#if defined(CONFIG_MV_INCLUDE_GIG_ETH)
+
+#ifdef CONFIG_MV_NFP_STATS
+#define MV_FP_STATISTICS
+#else
+#undef MV_FP_STATISTICS
+#endif
+
+/* Default configuration for TX_EN workaround: 0 - Disabled, 1 - Enabled */
+#define MV_ETH_TX_EN_DEFAULT        0
+
+/* un-comment if you want to perform tx_done from within the poll function */
+/* #define ETH_TX_DONE_ISR */
+
+/* put descriptors in uncached memory */
+/* #define ETH_DESCR_UNCACHED */
+
+/* Descriptors location: DRAM/internal-SRAM */
+#define ETH_DESCR_IN_SDRAM
+#undef  ETH_DESCR_IN_SRAM    /* No integrated SRAM in 88Fxx81 devices */
+
+#if defined(ETH_DESCR_IN_SRAM)
+#if defined(ETH_DESCR_UNCACHED)
+ #define ETH_DESCR_CONFIG_STR    "Uncached descriptors in integrated SRAM"
+#else
+ #define ETH_DESCR_CONFIG_STR    "Cached descriptors in integrated SRAM"
+#endif
+#elif defined(ETH_DESCR_IN_SDRAM)
+#if defined(ETH_DESCR_UNCACHED)
+ #define ETH_DESCR_CONFIG_STR    "Uncached descriptors in DRAM"
+#else
+ #define ETH_DESCR_CONFIG_STR    "Cached descriptors in DRAM"
+#endif
+#else
+ #error "Ethernet descriptors location undefined"
+#endif /* ETH_DESCR_IN_SRAM or ETH_DESCR_IN_SDRAM*/
+
+/* SW Sync-Barrier: not relevant for 88fxx81*/
+/* Reasnable to define this macro when descriptors in SRAM and buffers in DRAM */
+/* In RX the CPU theoretically might see himself as the descriptor owner,      */
+/* although the buffer hadn't been written to DRAM yet. Performance cost.      */
+/* #define INCLUDE_SYNC_BARR */
+
+/* Buffers cache coherency method (buffers in DRAM) */
+#ifndef MV_CACHE_COHER_SW
+/* Taken from mvCommon.h */
+/* Memory uncached, HW or SW cache coherency is not needed */
+#define MV_UNCACHED             0
+/* Memory cached, HW cache coherency supported in WriteThrough mode */
+#define MV_CACHE_COHER_HW_WT    1
+/* Memory cached, HW cache coherency supported in WriteBack mode */
+#define MV_CACHE_COHER_HW_WB    2
+/* Memory cached, No HW cache coherency, Cache coherency must be in SW */
+#define MV_CACHE_COHER_SW       3
+
+#endif
+
+/* DRAM cache coherency configuration */
+#define MV_CACHE_COHERENCY  MV_CACHE_COHER_SW
+
+
+#define ETHER_DRAM_COHER    MV_CACHE_COHER_SW   /* No HW coherency in 88Fxx81 devices */
+
+#if (ETHER_DRAM_COHER == MV_CACHE_COHER_HW_WB)
+ #define ETH_SDRAM_CONFIG_STR    "DRAM HW cache coherency (write-back)"
+#elif (ETHER_DRAM_COHER == MV_CACHE_COHER_HW_WT)
+ #define ETH_SDRAM_CONFIG_STR    "DRAM HW cache coherency (write-through)"
+#elif (ETHER_DRAM_COHER == MV_CACHE_COHER_SW)
+ #define ETH_SDRAM_CONFIG_STR    "DRAM SW cache-coherency"
+#elif (ETHER_DRAM_COHER == MV_UNCACHED)
+#   define ETH_SDRAM_CONFIG_STR  "DRAM uncached"
+#else
+ #error "Ethernet-DRAM undefined"
+#endif /* ETHER_DRAM_COHER */
+
+
+/****************************************************************/
+/************* Ethernet driver configuration ********************/
+/****************************************************************/
+
+/* port's default queueus */
+#define ETH_DEF_TXQ         0
+#define ETH_DEF_RXQ         0
+
+#define MV_DSA_TAG_SIZE		4
+#define MV_EDSA_TAG_SIZE	8
+
+#ifndef CONFIG_MV_ETH_RXQ
+#define CONFIG_MV_ETH_RXQ
+#endif
+#define MV_ETH_RX_Q_NUM     CONFIG_MV_ETH_RXQ
+
+#ifndef CONFIG_MV_ETH_TXQ
+#define CONFIG_MV_ETH_TXQ   1
+#endif
+#define MV_ETH_TX_Q_NUM     CONFIG_MV_ETH_TXQ
+
+/* interrupt coalescing setting */
+#define ETH_TX_COAL    		    200
+#define ETH_RX_COAL    		    200
+
+/* Checksum offloading */
+#define TX_CSUM_OFFLOAD
+#define RX_CSUM_OFFLOAD
+
+#endif /* CONFIG_MV_INCLUDE_GIG_ETH */
+
+/****************************************************************/
+/*************** Telephony configuration ************************/
+/****************************************************************/
+#if defined(CONFIG_MV_TDM_SUPPORT)
+	#define MV_TDM_SUPPORT
+	#define MV_TDM_REGS_BASE	0xD0000
+#elif defined(CONFIG_MV_COMM_UNIT_SUPPORT)
+	#define MV_COMM_UNIT_SUPPORT
+	#define MV_COMM_UNIT_REGS_BASE	MV_COMM_UNIT_REGS_OFFSET
+#endif
+
+#ifdef CONFIG_MV_TDM_USE_DCO
+	#define MV_TDM_USE_DCO
+#endif
+
+/* SLIC vendor */
+#if defined(CONFIG_SILABS_SLIC_SUPPORT)
+	#define SILABS_SLIC_SUPPORT
+	#if defined(CONFIG_SILABS_SLIC_3215)
+		#define SILABS_SLIC_3215
+	#elif defined(CONFIG_SILABS_SLIC_3217)
+		#define SILABS_SLIC_3217
+	#elif defined(CONFIG_SILAB_SLIC_SI3226)
+		#define SI3226X
+	#endif
+#else /* CONFIG_ZARLINK_SLIC_SUPPORT) */
+	#define ZARLINK_SLIC_SUPPORT
+	#define SLIC_TIMER_EVENT_SUPPORT
+	#if defined(CONFIG_ZARLINK_SLIC_VE880)
+		#define ZARLINK_SLIC_VE880
+	#elif defined(CONFIG_ZARLINK_SLIC_VE792)
+		#define ZARLINK_SLIC_VE792
+	#endif
+#endif
+
+#if defined(CONFIG_MV_TDM_USE_EXTERNAL_PCLK_SOURCE)
+	#define MV_TDM_USE_EXTERNAL_PCLK_SOURCE
+#endif
+
+#if defined(CONFIG_MV_TDM_PCM_CLK_8MHZ)
+	#define MV_TDM_PCM_CLK_8MHZ
+#elif defined(CONFIG_MV_TDM_PCM_CLK_4MHZ)
+	#define MV_TDM_PCM_CLK_4MHZ
+#elif defined(CONFIG_MV_TDM_PCM_CLK_2MHZ)
+	#define MV_TDM_PCM_CLK_2MHZ
+#endif
+
+/* We use the following registers to store DRAM interface pre configuration   */
+/* auto-detection results													  */
+/* IMPORTANT: We are using mask register for that purpose. Before writing     */
+/* to units mask register, make sure main maks register is set to disable     */
+/* all interrupts.                                                            */
+#define DRAM_BUF_REG0   0x30810 /* sdram bank 0 size            */
+#define DRAM_BUF_REG1   0x30820 /* sdram config                 */
+#define DRAM_BUF_REG2   0x30830 /* sdram mode                   */
+#define DRAM_BUF_REG3   0x308c4 /* dunit control low            */
+#define DRAM_BUF_REG4   0x60a90 /* sdram address control        */
+#define DRAM_BUF_REG5   0x60a94 /* sdram timing control low     */
+#define DRAM_BUF_REG6   0x60a98 /* sdram timing control high    */
+#define DRAM_BUF_REG7   0x60a9c /* sdram ODT control low        */
+#define DRAM_BUF_REG8   0x60b90 /* sdram ODT control high       */
+#define DRAM_BUF_REG9   0x60b94 /* sdram Dunit ODT control      */
+#define DRAM_BUF_REG10  0x60b98 /* sdram Extended Mode          */
+#define DRAM_BUF_REG11  0x60b9c /* sdram Ddr2 Time Low Reg      */
+#define DRAM_BUF_REG12  0x60a00 /* sdram Ddr2 Time High Reg     */
+#define DRAM_BUF_REG13  0x60a04 /* dunit Ctrl High              */
+#define DRAM_BUF_REG14  0x60b00 /* sdram second DIMM exist      */
+
+/* Following the pre-configuration registers default values restored after    */
+/* auto-detection is done                                                     */
+#define DRAM_BUF_REG_DV 0
+
+/* System Mapping */
+#define SDRAM_CS0_BASE  0x00000000
+#define SDRAM_CS0_SIZE  _256M
+
+#define SDRAM_CS1_BASE  0x10000000
+#define SDRAM_CS1_SIZE  _256M
+
+#define SDRAM_CS2_BASE  0x20000000
+#define SDRAM_CS2_SIZE  _256M
+
+#define SDRAM_CS3_BASE  0x30000000
+#define SDRAM_CS3_SIZE  _256M
+
+/* Device Chip Selects */
+#define NFLASH_CS_BASE 0xfa000000
+#define NFLASH_CS_SIZE _2M
+
+#define SPI_CS_BASE 0xf4000000
+#define SPI_CS_SIZE _16M
+
+#define CRYPT_ENG_BASE	0xf0000000
+#define CRYPT_ENG_SIZE	_2M
+
+#define BOOTDEV_CS_BASE	0xff800000
+#define BOOTDEV_CS_SIZE _8M
+
+/* CS2 - BOOTROM */
+#define DEVICE_CS2_BASE 0xff900000
+#define DEVICE_CS2_SIZE _1M
+
+/* Internal registers: size is defined in Controllerenvironment */
+#define INTER_REGS_BASE	0xF1000000
+
+/* #define DDR_OPERATION_BASE	(INTER_REGS_BASE | 0x1418) */
+
+/* DRAM detection stuff */
+#define MV_DRAM_AUTO_SIZE
+
+/* Board clock detection */
+#define TCLK_AUTO_DETECT    	/* Use Tclk auto detection   */
+#define SYSCLK_AUTO_DETECT	/* Use SysClk auto detection */
+#define PCLCK_AUTO_DETECT  	/* Use PClk auto detection   */
+#define L2CLK_AUTO_DETECT 	/* Use L2Clk auto detection   */
+
+#endif /* __INCmvSysHwConfigh */
+
diff --git a/arch/arm/mach-kirkwood/db88f6281-bp-setup.c b/arch/arm/mach-kirkwood/db88f6281-bp-setup.c
index d933593..ad40ab0 100644
--- a/arch/arm/mach-kirkwood/db88f6281-bp-setup.c
+++ b/arch/arm/mach-kirkwood/db88f6281-bp-setup.c
@@ -14,12 +14,17 @@
 #include <linux/mtd/partitions.h>
 #include <linux/ata_platform.h>
 #include <linux/mv643xx_eth.h>
+#include <linux/i2c.h>
+#include <linux/spi/flash.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/orion_spi.h>
 #include <asm/mach-types.h>
 #include <asm/mach/arch.h>
 #include <mach/kirkwood.h>
 #include <plat/mvsdio.h>
 #include "common.h"
 #include "mpp.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
 
 static struct mtd_partition db88f6281_nand_parts[] = {
 	{
@@ -37,10 +42,29 @@ static struct mtd_partition db88f6281_nand_parts[] = {
 	},
 };
 
+static const struct flash_platform_data db88f6281_spi_slave_data = {
+	.type		= "m25p128",
+};
+
+static struct spi_board_info __initdata db88f6281_spi_slave_info[] = {
+	{
+		.modalias	= "m25p80",
+		.platform_data	= &db88f6281_spi_slave_data,
+		.irq		= -1,
+		.max_speed_hz	= 20000000,
+		.bus_num	= 0,
+		.chip_select	= 0,
+	},
+};
+
 static struct mv643xx_eth_platform_data db88f6281_ge00_data = {
 	.phy_addr	= MV643XX_ETH_PHY_ADDR(8),
 };
 
+static struct mv643xx_eth_platform_data db88f6281_ge01_data= {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(0),
+};
+
 static struct mv_sata_platform_data db88f6281_sata_data = {
 	.n_ports	= 2,
 };
@@ -50,34 +74,42 @@ static struct mvsdio_platform_data db88f6281_mvsdio_data = {
 	.gpio_card_detect	= 38,
 };
 
-static unsigned int db88f6281_mpp_config[] __initdata = {
-	MPP0_NF_IO2,
-	MPP1_NF_IO3,
-	MPP2_NF_IO4,
-	MPP3_NF_IO5,
-	MPP4_NF_IO6,
-	MPP5_NF_IO7,
-	MPP18_NF_IO0,
-	MPP19_NF_IO1,
-	MPP37_GPIO,
-	MPP38_GPIO,
-	0
+static struct i2c_board_info i2c_board_info[] __initdata = {
+	{
+		I2C_BOARD_INFO("cs42l51", 0x4a),
+	},
 };
 
 static void __init db88f6281_init(void)
 {
 	/*
+	 * Init board id (Marvell-internal) and MPPs
+	 */
+	mvBoardIdSet(DB_88F6282A_BP_ID);
+	mvBoardEnvInit();
+	mvCtrlEnvInit();
+
+	/*
 	 * Basic setup. Needs to be called early.
 	 */
 	kirkwood_init();
-	kirkwood_mpp_conf(db88f6281_mpp_config);
 
 	kirkwood_nand_init(ARRAY_AND_SIZE(db88f6281_nand_parts), 25);
 	kirkwood_ehci_init();
 	kirkwood_ge00_init(&db88f6281_ge00_data);
+	kirkwood_ge01_init(&db88f6281_ge01_data);
 	kirkwood_sata_init(&db88f6281_sata_data);
+
+	spi_register_board_info(db88f6281_spi_slave_info,
+				ARRAY_SIZE(db88f6281_spi_slave_info));
+	kirkwood_spi_init();
+
 	kirkwood_uart0_init();
 	kirkwood_sdio_init(&db88f6281_mvsdio_data);
+
+	kirkwood_i2c_init();
+	i2c_register_board_info(0, i2c_board_info, ARRAY_SIZE(i2c_board_info));
+	kirkwood_audio_init();
 }
 
 static int __init db88f6281_pci_init(void)
diff --git a/arch/arm/mach-kirkwood/dbg-trace.c b/arch/arm/mach-kirkwood/dbg-trace.c
new file mode 100644
index 0000000..6576d35
--- /dev/null
+++ b/arch/arm/mach-kirkwood/dbg-trace.c
@@ -0,0 +1,110 @@
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/time.h>
+#include "dbg-trace.h"
+
+#define TRACE_ARR_LEN   800
+#define STR_LEN         128
+struct trace {
+    struct timeval tv;
+        char str[STR_LEN];
+    unsigned int callback_val1;
+    unsigned int callback_val2;
+        char valid;
+};
+static unsigned int (*trc_callback1) (unsigned char) = NULL;
+static unsigned int (*trc_callback2) (unsigned char) = NULL;
+static unsigned char trc_param1 = 0;
+static unsigned char trc_param2 = 0;
+struct trace *trc_arr;
+static int trc_index;
+static int trc_active = 0;
+
+void TRC_START()
+{
+    trc_active = 1;
+}
+
+void TRC_STOP()
+{
+    trc_active = 0;
+}
+
+void TRC_INIT(void *callback1, void *callback2, unsigned char callback1_param, unsigned char callback2_param)
+{
+    printk("Marvell debug tracing is on\n");
+        trc_arr = (struct trace *)kmalloc(TRACE_ARR_LEN*sizeof(struct trace),GFP_KERNEL);
+    if(trc_arr == NULL)
+    {
+        printk("Can't allocate Debug Trace buffer\n");
+        return;
+    }
+        memset(trc_arr,0,TRACE_ARR_LEN*sizeof(struct trace));
+        trc_index = 0;
+    trc_callback1 = callback1;
+    trc_callback2 = callback2;
+    trc_param1 = callback1_param;
+    trc_param2 = callback2_param;
+}
+void TRC_REC(char *fmt,...)
+{
+    va_list args;
+        struct trace *trc = &trc_arr[trc_index];
+
+    if(trc_active == 0)
+        return;
+
+    do_gettimeofday(&trc->tv);
+    if(trc_callback1)
+        trc->callback_val1 = trc_callback1(trc_param1);
+    if(trc_callback2)
+        trc->callback_val2 = trc_callback2(trc_param2);
+    va_start(args, fmt);
+    vsprintf(trc->str,fmt,args);
+    va_end(args);
+        trc->valid = 1;
+        if((++trc_index) == TRACE_ARR_LEN) {
+                trc_index = 0;
+    }
+}
+void TRC_OUTPUT(void)
+{
+        int i,j;
+        struct trace *p;
+        printk("\n\nTrace %d items\n",TRACE_ARR_LEN);
+        for(i=0,j=trc_index; i<TRACE_ARR_LEN; i++,j++) {
+                if(j == TRACE_ARR_LEN)
+                        j = 0;
+                p = &trc_arr[j];
+                if(p->valid) {
+            unsigned long uoffs;
+            struct trace *plast;
+            if(p == &trc_arr[0])
+                plast = &trc_arr[TRACE_ARR_LEN-1];
+            else
+                plast = p-1;
+            if(p->tv.tv_sec == ((plast)->tv.tv_sec))
+                uoffs = (p->tv.tv_usec - ((plast)->tv.tv_usec));
+            else
+                uoffs = (1000000 - ((plast)->tv.tv_usec)) +
+                    ((p->tv.tv_sec - ((plast)->tv.tv_sec) - 1) * 1000000) +
+                    p->tv.tv_usec;
+                        printk("%03d: [+%ld usec]", j, (unsigned long)uoffs);
+            if(trc_callback1)
+                printk("[%u]",p->callback_val1);
+            if(trc_callback2)
+                printk("[%u]",p->callback_val2);
+            printk(": %s",p->str);
+        }
+                p->valid = 0;
+        }
+        memset(trc_arr,0,TRACE_ARR_LEN*sizeof(struct trace));
+        trc_index = 0;
+}
+void TRC_RELEASE(void)
+{
+        kfree(trc_arr);
+        trc_index = 0;
+}
+
+
diff --git a/arch/arm/mach-kirkwood/dbg-trace.h b/arch/arm/mach-kirkwood/dbg-trace.h
new file mode 100644
index 0000000..e3dd480
--- /dev/null
+++ b/arch/arm/mach-kirkwood/dbg-trace.h
@@ -0,0 +1,24 @@
+
+#ifndef _MV_DBG_TRCE_H_
+#define _MV_DBG_TRCE_H_
+
+#ifdef CONFIG_MV_DBG_TRACE
+void TRC_INIT(void *callback1, void *callback2,
+    unsigned char callback1_param, unsigned char callback2_param);
+void TRC_REC(char *fmt,...);
+void TRC_OUTPUT(void);
+void TRC_RELEASE(void);
+void TRC_START(void);
+void TRC_STOP(void);
+
+#else
+#define TRC_INIT(x1,x2,x3,x4)
+#define TRC_REC(X...)
+#define TRC_OUTPUT()
+#define TRC_RELEASE()
+#define TRC_START()
+#define TRC_STOP()
+#endif
+
+
+#endif
diff --git a/arch/arm/mach-kirkwood/export.c b/arch/arm/mach-kirkwood/export.c
new file mode 100644
index 0000000..d45e17f
--- /dev/null
+++ b/arch/arm/mach-kirkwood/export.c
@@ -0,0 +1,123 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/export.h>
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "mvDebug.h"
+#include "mvSysHwConfig.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "mvOs.h"
+
+/*************************************************************************************************************
+ * Environment
+ *************************************************************************************************************/
+EXPORT_SYMBOL(mvCtrlPwrClckGet);
+EXPORT_SYMBOL(mvCtrlModelRevGet);
+EXPORT_SYMBOL(mvCtrlModelGet);
+EXPORT_SYMBOL(mvOsIoUncachedMalloc);
+EXPORT_SYMBOL(mvOsIoUncachedFree);
+EXPORT_SYMBOL(mvOsIoCachedMalloc);
+EXPORT_SYMBOL(mvOsIoCachedFree);
+EXPORT_SYMBOL(mvDebugMemDump);
+EXPORT_SYMBOL(mvHexToBin);
+EXPORT_SYMBOL(mvBinToHex);
+EXPORT_SYMBOL(mvSizePrint);
+EXPORT_SYMBOL(mvDebugPrintMacAddr);
+EXPORT_SYMBOL(mvCtrlTargetNameGet);
+EXPORT_SYMBOL(mvBoardIdGet);
+EXPORT_SYMBOL(mvBoardPhyAddrGet);
+EXPORT_SYMBOL(mvMacStrToHex);
+EXPORT_SYMBOL(mvBoardMacSpeedGet);
+
+/*************************************************************************************************************
+ * USB
+ *************************************************************************************************************/
+#ifdef CONFIG_MV_INCLUDE_USB
+extern u32 mvIsUsbHost;
+
+#include "usb/mvUsb.h"
+EXPORT_SYMBOL(mvIsUsbHost);
+EXPORT_SYMBOL(mvCtrlUsbMaxGet);
+EXPORT_SYMBOL(mvUsbGetCapRegAddr);
+EXPORT_SYMBOL(mvUsbGppInit);
+EXPORT_SYMBOL(mvUsbBackVoltageUpdate);
+#endif /* CONFIG_MV_INCLUDE_USB */
+
+/*************************************************************************************************************
+ * CESA
+ *************************************************************************************************************/
+#ifdef CONFIG_MV_INCLUDE_CESA
+#include "cesa/mvCesa.h"
+#include "cesa/mvMD5.h"
+#include "cesa/mvSHA1.h"
+
+#ifdef CONFIG_USB_MRVL
+extern unsigned char*  mv_sram_usage_get(int* sram_size_ptr);
+EXPORT_SYMBOL(mv_sram_usage_get);
+#endif
+
+EXPORT_SYMBOL(mvCesaHalInit);
+EXPORT_SYMBOL(mvCesaSessionOpen);
+EXPORT_SYMBOL(mvCesaSessionClose);
+EXPORT_SYMBOL(mvCesaAction);
+EXPORT_SYMBOL(mvCesaReadyGet);
+EXPORT_SYMBOL(mvCesaCopyFromMbuf);
+EXPORT_SYMBOL(mvCesaCopyToMbuf);
+EXPORT_SYMBOL(mvCesaMbufCopy);
+EXPORT_SYMBOL(mvCesaCryptoIvSet);
+EXPORT_SYMBOL(mvMD5);
+EXPORT_SYMBOL(mvSHA1);
+
+EXPORT_SYMBOL(mvCesaDebugQueue);
+EXPORT_SYMBOL(mvCesaDebugSram);
+EXPORT_SYMBOL(mvCesaDebugSAD);
+EXPORT_SYMBOL(mvCesaDebugStatus);
+EXPORT_SYMBOL(mvCesaDebugMbuf);
+EXPORT_SYMBOL(mvCesaDebugSA);
+
+EXPORT_SYMBOL(cesaReqResources);
+EXPORT_SYMBOL(mvCesaFinish);
+#endif /* CONFIG_MV_INCLUDE_CESA */
+
+#ifdef CONFIG_MV_CESA_OCF
+extern void cesa_ocf_debug(void);
+EXPORT_SYMBOL(cesa_ocf_debug);
+#endif
+
+/*************************************************************************************************************
+ * Networking
+ *************************************************************************************************************/
+#ifdef CONFIG_MV_INCLUDE_GIG_ETH
+#include "eth/mvEth.h"
+#include "eth-phy/mvEthPhy.h"
+EXPORT_SYMBOL(mvCtrlEthMaxPortGet);
+EXPORT_SYMBOL(mvEthPhyRegRead);
+EXPORT_SYMBOL(mvEthPhyRegWrite);
+#endif
+
+/*************************************************************************************************************
+ * Marvell TRACE
+ *************************************************************************************************************/
+#ifdef CONFIG_MV_DBG_TRACE
+#include "dbg-trace.h"
+EXPORT_SYMBOL(TRC_INIT);
+EXPORT_SYMBOL(TRC_REC);
+EXPORT_SYMBOL(TRC_OUTPUT);
+#endif
+
diff --git a/arch/arm/mach-kirkwood/include/mach/io.h b/arch/arm/mach-kirkwood/include/mach/io.h
index 5d0ab61..7518051 100644
--- a/arch/arm/mach-kirkwood/include/mach/io.h
+++ b/arch/arm/mach-kirkwood/include/mach/io.h
@@ -13,6 +13,8 @@
 
 #define IO_SPACE_LIMIT		0xffffffff
 
+#define dma_io_sync()	do { } while (0)
+
 static inline void __iomem *__io(unsigned long addr)
 {
 	return (void __iomem *)((addr - KIRKWOOD_PCIE_IO_BUS_BASE)
diff --git a/arch/arm/mach-kirkwood/include/mach/irqs.h b/arch/arm/mach-kirkwood/include/mach/irqs.h
index 2bf8161..7d4d9c2 100644
--- a/arch/arm/mach-kirkwood/include/mach/irqs.h
+++ b/arch/arm/mach-kirkwood/include/mach/irqs.h
@@ -26,12 +26,17 @@
 #define IRQ_KIRKWOOD_PCIE1	10
 #define IRQ_KIRKWOOD_GE00_SUM	11
 #define IRQ_KIRKWOOD_GE01_SUM	15
+#define IRQ_KIRKWOOD_GE(x)	((x == 0) ? \
+		IRQ_KIRKWOOD_GE00_SUM : IRQ_KIRKWOOD_GE01_SUM)
 #define IRQ_KIRKWOOD_USB	19
 #define IRQ_KIRKWOOD_SATA	21
 #define IRQ_KIRKWOOD_CRYPTO	22
 #define IRQ_KIRKWOOD_SPI	23
 #define IRQ_KIRKWOOD_I2S	24
 #define IRQ_KIRKWOOD_TS_0	26
+#define IRQ_KIRKWOOD_TS_1	27
+#define IRQ_KIRKWOOD_TS(x)	((x == 0) ? \
+		IRQ_KIRKWOOD_TS_0 : IRQ_KIRKWOOD_TS_1)
 #define IRQ_KIRKWOOD_SDIO	28
 #define IRQ_KIRKWOOD_TWSI	29
 #define IRQ_KIRKWOOD_AVB	30
diff --git a/arch/arm/mach-kirkwood/include/mach/kirkwood.h b/arch/arm/mach-kirkwood/include/mach/kirkwood.h
index c5b6851..8d2e3fe 100644
--- a/arch/arm/mach-kirkwood/include/mach/kirkwood.h
+++ b/arch/arm/mach-kirkwood/include/mach/kirkwood.h
@@ -30,10 +30,10 @@
  * fef00000	f3000000	1M	PCIe #1 I/O space
  */
 
-#define KIRKWOOD_SRAM_PHYS_BASE		0xf5000000
+#define KIRKWOOD_SRAM_PHYS_BASE		0xf3200000
 #define KIRKWOOD_SRAM_SIZE		SZ_2K
 
-#define KIRKWOOD_NAND_MEM_PHYS_BASE	0xf4000000
+#define KIRKWOOD_NAND_MEM_PHYS_BASE	0xf3100000
 #define KIRKWOOD_NAND_MEM_SIZE		SZ_1K
 
 #define KIRKWOOD_PCIE1_IO_PHYS_BASE	0xf3000000
@@ -58,6 +58,10 @@
 #define KIRKWOOD_PCIE1_MEM_BUS_BASE	0xe8000000
 #define KIRKWOOD_PCIE1_MEM_SIZE		SZ_128M
 
+#define KIRKWOOD_PP_PHYS_BASE		0xf4000000
+#define KIRKWOOD_PP_VIRT_BASE		0xf4000000
+#define KIRKWOOD_PP_SIZE		SZ_64M
+
 /*
  * Register Map
  */
@@ -117,6 +121,12 @@
 #define AUDIO_PHYS_BASE		(KIRKWOOD_REGS_PHYS_BASE | 0xA0000)
 #define AUDIO_VIRT_BASE		(KIRKWOOD_REGS_VIRT_BASE | 0xA0000)
 
+#define TSU_PHYS_BASE		(KIRKWOOD_REGS_PHYS_BASE | 0xB4000)
+#define TSU_VIRT_BASE		(KIRKWOOD_REGS_VIRT_BASE | 0xB4000)
+
+#define TDM_PHYS_BASE		(KIRKWOOD_REGS_PHYS_BASE | 0xD0000)
+#define TDM_VIRT_BASE		(KIRKWOOD_REGS_VIRT_BASE | 0xD0000)
+
 /*
  * Supported devices and revisions.
  */
diff --git a/arch/arm/mach-kirkwood/kw_family/boardEnv/mvBoardEnvLib.c b/arch/arm/mach-kirkwood/kw_family/boardEnv/mvBoardEnvLib.c
new file mode 100644
index 0000000..357cdd2
--- /dev/null
+++ b/arch/arm/mach-kirkwood/kw_family/boardEnv/mvBoardEnvLib.c
@@ -0,0 +1,1512 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include "common.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "cpu/mvCpu.h"
+#include "gpp/mvGpp.h"
+#include "twsi/mvTwsi.h"
+#include "eth/gbe/mvEthRegs.h"
+
+#ifdef MV_DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+extern	MV_BOARD_INFO*	boardInfoTbl[];
+#define BOARD_INFO(boardId)	boardInfoTbl[boardId - BOARD_ID_BASE]
+
+/*******************************************************************************
+* mvBoardEnvInit - Init board
+*
+* DESCRIPTION:
+*		In this function the board environment take care of device bank
+*		initialization.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+#define NAND_READ_PARAMS_REG		0x10418
+#define NAND_WRITE_PARAMS_REG		0x1041c
+#define NAND_CTRL_REG			0x10470
+#define NAND_ACTCEBOOT_BIT		BIT1
+
+MV_VOID mvBoardEnvInit(MV_VOID)
+{
+	MV_U32 boardId= mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE)&&(boardId < MV_MAX_BOARD_ID)))
+	{
+		mvOsPrintf("mvBoardEnvInit:Board unknown.\n");
+		return;
+
+	}
+
+	if (mvBoardIdGet() != XCAT98DX_ID) {
+		/* Set NAND interface access parameters */
+		MV_REG_WRITE(NAND_READ_PARAMS_REG, BOARD_INFO(boardId)->nandFlashReadParams);
+		MV_REG_WRITE(NAND_WRITE_PARAMS_REG, BOARD_INFO(boardId)->nandFlashWriteParams);
+		MV_REG_WRITE(NAND_CTRL_REG, BOARD_INFO(boardId)->nandFlashControl);
+	}
+
+	/* Set GPP Out value */
+	MV_REG_WRITE(GPP_DATA_OUT_REG(0), BOARD_INFO(boardId)->gppOutValLow);
+	MV_REG_WRITE(GPP_DATA_OUT_REG(1), BOARD_INFO(boardId)->gppOutValHigh);
+
+	/* set GPP polarity */
+	mvGppPolaritySet(0, 0xFFFFFFFF, BOARD_INFO(boardId)->gppPolarityValLow);
+	mvGppPolaritySet(1, 0xFFFFFFFF, BOARD_INFO(boardId)->gppPolarityValHigh);
+
+    /* Workaround for Erratum FE-MISC-70*/
+    if(mvCtrlRevGet()==MV_88F6XXX_A0_REV)
+    {
+        BOARD_INFO(boardId)->gppOutEnValLow &= 0xfffffffd;
+        BOARD_INFO(boardId)->gppOutEnValLow |= (BOARD_INFO(boardId)->gppOutEnValHigh) & 0x00000002;
+    } /*End of WA*/
+
+	/* Set GPP Out Enable*/
+	mvGppTypeSet(0, 0xFFFFFFFF, BOARD_INFO(boardId)->gppOutEnValLow);
+	mvGppTypeSet(1, 0xFFFFFFFF, BOARD_INFO(boardId)->gppOutEnValHigh);
+
+	/* Nand CE */
+	MV_REG_BIT_SET(NAND_CTRL_REG, NAND_ACTCEBOOT_BIT);
+}
+
+/*******************************************************************************
+* mvBoardNameGet - Get Board name
+*
+* DESCRIPTION:
+*       This function returns a string describing the board model and revision.
+*       String is extracted from board I2C EEPROM.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       pNameBuff - Buffer to contain board name string. Minimum size 32 chars.
+*
+* RETURN:
+*
+*       MV_ERROR if informantion can not be read.
+*******************************************************************************/
+MV_STATUS mvBoardNameGet(char *pNameBuff)
+{
+	MV_U32 boardId= mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE)&&(boardId < MV_MAX_BOARD_ID)))
+	{
+		mvOsSPrintf (pNameBuff, "Board unknown.\n");
+		return MV_ERROR;
+
+	}
+
+	mvOsSPrintf (pNameBuff, "%s",BOARD_INFO(boardId)->boardName);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvBoardIsPortInSgmii -
+*
+* DESCRIPTION:
+*       This routine returns MV_TRUE for port number works in SGMII or MV_FALSE
+*	For all other options.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE - port in SGMII.
+*       MV_FALSE - other.
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsPortInSgmii(MV_U32 ethPortNum)
+{
+    MV_BOOL ethPortSgmiiSupport[BOARD_ETH_PORT_NUM] = MV_ETH_PORT_SGMII;
+
+    if(ethPortNum >= BOARD_ETH_PORT_NUM)
+    {
+	    mvOsPrintf ("Invalid portNo=%d\n", ethPortNum);
+		return MV_FALSE;
+    }
+    return ethPortSgmiiSupport[ethPortNum];
+}
+
+/*******************************************************************************
+* mvBoardIsPortInGmii -
+*
+* DESCRIPTION:
+*       This routine returns MV_TRUE for port number works in GMII or MV_FALSE
+*	For all other options.
+*
+* INPUT:
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE - port in GMII.
+*       MV_FALSE - other.
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsPortInGmii(MV_VOID)
+{
+	MV_U32 devClassId, devClass = 0;
+	if (mvBoardMppGroupTypeGet(devClass) == MV_BOARD_AUTO)
+	{
+		/* Get MPP module ID */
+		devClassId = mvBoarModuleTypeGet(devClass);
+		if (MV_BOARD_MODULE_GMII_ID == devClassId)
+			return MV_TRUE;
+	}
+	else if (mvBoardMppGroupTypeGet(devClass) == MV_BOARD_GMII)
+		return MV_TRUE;
+
+    return MV_FALSE;
+}
+/*******************************************************************************
+* mvBoardPhyAddrGet - Get the phy address
+*
+* DESCRIPTION:
+*       This routine returns the Phy address of a given ethernet port.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit describing Phy address, -1 if the port number is wrong.
+*
+*******************************************************************************/
+MV_32 mvBoardPhyAddrGet(MV_U32 ethPortNum)
+{
+	MV_U32 boardId= mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE)&&(boardId < MV_MAX_BOARD_ID)))
+	{
+		mvOsPrintf("mvBoardPhyAddrGet: Board unknown.\n");
+		return MV_ERROR;
+	}
+
+	return BOARD_INFO(boardId)->pBoardMacInfo[ethPortNum].boardEthSmiAddr;
+}
+
+/*******************************************************************************
+* mvBoardMacSpeedGet - Get the Mac speed
+*
+* DESCRIPTION:
+*       This routine returns the Mac speed if pre define of a given ethernet port.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_BOARD_MAC_SPEED, -1 if the port number is wrong.
+*
+*******************************************************************************/
+MV_BOARD_MAC_SPEED      mvBoardMacSpeedGet(MV_U32 ethPortNum)
+{
+	MV_U32 boardId= mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE)&&(boardId < MV_MAX_BOARD_ID)))
+	{
+		mvOsPrintf("mvBoardMacSpeedGet: Board unknown.\n");
+		return MV_ERROR;
+	}
+
+	return BOARD_INFO(boardId)->pBoardMacInfo[ethPortNum].boardMacSpeed;
+}
+
+/*******************************************************************************
+* mvBoardLinkStatusIrqGet - Get the IRQ number for the link status indication
+*
+* DESCRIPTION:
+*       This routine returns the IRQ number for the link status indication.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*       switchIndex - Switch index.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_ERROR - if ethPortNum or switchIndex are illegal or board is unknown
+*       The number of the IRQ for the link status indication, -1 if the port
+*       number is wrong or if not relevant.
+*
+*******************************************************************************/
+MV_32	mvBoardLinkStatusIrqGet(MV_U32 ethPortNum, MV_U32 switchIndex)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE)&&(boardId < MV_MAX_BOARD_ID)))
+	{
+		mvOsPrintf("mvBoardLinkStatusIrqGet: Board unknown.\n");
+		return (-MV_BAD_VALUE);
+	}
+
+	if (ethPortNum >= BOARD_INFO(boardId)->numBoardMacInfo)
+	{
+		mvOsPrintf("mvBoardLinkStatusIrqGet: Illegal port number(%u)\n", ethPortNum);
+		return (-MV_BAD_VALUE);
+	}
+
+    if (switchIndex >= BOARD_MAX_CASCADED_SWITCHES)
+    {
+        mvOsPrintf("mvBoardLinkStatusIrqGet: Illegal Switch index(%u)\n", switchIndex);
+        return (-MV_BAD_VALUE);
+    }
+
+    if ((MV_32)(BOARD_INFO(boardId)->pSwitchInfo))
+	    return BOARD_INFO(boardId)->pSwitchInfo[ethPortNum].linkStatusIrq[switchIndex];
+
+    return (-MV_BAD_VALUE);
+}
+
+/*******************************************************************************
+* mvBoardSwitchPortGet - Get the mapping between the board connector (logical port number) and the
+*                        physical Switch port
+*
+* DESCRIPTION:
+*       This routine returns the matching Switch port.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*       logicalPortNum - logical number of the connector on the board
+*
+* OUTPUT:
+*       switchIndex - Switch index.
+*       portNum - Switch port number.
+*       portName - Switch port name (string)
+*
+* RETURN:
+*       MV_OK on success, MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_32	mvBoardSwitchPortGet(MV_U32 ethPortNum, MV_U8 logicalPortNum, MV_32 *switchIndex, MV_32 *portNum, char *portName)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE)&&(boardId < MV_MAX_BOARD_ID)))
+	{
+		mvOsPrintf("mvBoardSwitchPortGet: Board unknown.\n");
+		return MV_ERROR;
+	}
+
+	if (logicalPortNum >= BOARD_ETH_SWITCH_PORT_NUM)
+	{
+		mvOsPrintf("mvBoardSwitchPortGet: Illegal board port number.\n");
+		return MV_ERROR;
+	}
+
+    if ((switchIndex == NULL) || (portNum == NULL))
+    {
+        mvOsPrintf("mvBoardSwitchPortGet: got NULL arguments.\n");
+        return MV_ERROR;
+    }
+
+    if ((MV_32)(BOARD_INFO(boardId)->pSwitchInfo))
+    {
+        *switchIndex    = BOARD_INFO(boardId)->pSwitchInfo[ethPortNum].qdPort[logicalPortNum].qdSwitchNum;
+        *portNum        = BOARD_INFO(boardId)->pSwitchInfo[ethPortNum].qdPort[logicalPortNum].qdPortNum;
+        memcpy(portName, BOARD_INFO(boardId)->pSwitchInfo[ethPortNum].qdPort[logicalPortNum].portStr, BOARD_ETH_MAX_PORT_STRING);
+        return MV_OK;
+    }
+
+    return MV_ERROR;
+}
+
+/*******************************************************************************
+* mvBoardSwitchCpuPortGet - Get the the Ethernet Switch CPU port
+*
+* DESCRIPTION:
+*       This routine returns the Switch CPU port.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*       switchIndex - Switch index.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_ERROR - if ethPortNum or switchIndex are illegal or board is unknown
+*       The Switch CPU port, -1 if the port number is wrong or if not relevant.
+*
+*******************************************************************************/
+MV_32	mvBoardSwitchCpuPortGet(MV_U32 ethPortNum, MV_U32 switchIndex)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE)&&(boardId < MV_MAX_BOARD_ID)))
+	{
+		mvOsPrintf("mvBoardSwitchCpuPortGet: Board unknown.\n");
+		return MV_ERROR;
+	}
+
+	if (ethPortNum >= BOARD_INFO(boardId)->numBoardMacInfo)
+	{
+		mvOsPrintf("mvBoardSwitchCpuPortGet: Illegal port number(%u)\n", ethPortNum);
+		return MV_ERROR;
+	}
+
+    if (switchIndex >= BOARD_MAX_CASCADED_SWITCHES)
+    {
+        mvOsPrintf("mvBoardSwitchCpuPortGet: Illegal Switch index(%u)\n", switchIndex);
+        return MV_ERROR;
+    }
+
+    if ((MV_32)(BOARD_INFO(boardId)->pSwitchInfo))
+	    return BOARD_INFO(boardId)->pSwitchInfo[ethPortNum].qdCpuPort[switchIndex];
+
+    return MV_ERROR;
+}
+
+/*******************************************************************************
+* mvBoardSwitchInterconnectPortGet - Get the the Ethernet Switch Interconnect port
+*
+* DESCRIPTION:
+*       This routine returns the Switch Interconnect port - the port that is connected to another Switch (if relevant).
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*       switchIndex - Switch index.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_ERROR - if ethPortNum or switchIndex are illegal or board is unknown
+*       The Switch Interconnect port, -1 if the port number is wrong or if not relevant.
+*
+*******************************************************************************/
+MV_32	mvBoardSwitchInterconnectPortGet(MV_U32 ethPortNum, MV_U32 switchIndex)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE)&&(boardId < MV_MAX_BOARD_ID)))
+	{
+		mvOsPrintf("mvBoardSwitchInterconnectPortGet: Board unknown.\n");
+		return MV_ERROR;
+	}
+
+	if (ethPortNum >= BOARD_INFO(boardId)->numBoardMacInfo)
+	{
+		mvOsPrintf("mvBoardSwitchInterconnectPortGet: Illegal port number(%u)\n", ethPortNum);
+		return MV_ERROR;
+	}
+
+    if (switchIndex >= BOARD_MAX_CASCADED_SWITCHES)
+    {
+        mvOsPrintf("mvBoardSwitchInterconnectPortGet: Illegal Switch index(%u)\n", switchIndex);
+        return MV_ERROR;
+    }
+
+    if ((MV_32)(BOARD_INFO(boardId)->pSwitchInfo))
+    	return BOARD_INFO(boardId)->pSwitchInfo[ethPortNum].qdInterconnectPort[switchIndex];
+
+    return MV_ERROR;
+}
+
+/*******************************************************************************
+* mvBoardSwitchSmiAddrGet - Get the the Ethernet Switch SMI address
+*
+* DESCRIPTION:
+*       This routine returns the Switch SMI address.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*       switchIndex - Switch index.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_ERROR - if ethPortNum or switchIndex are illegal or board is unknown
+*       The Switch SMI address, -1 if the port number is wrong or if not relevant.
+*
+*******************************************************************************/
+MV_32	mvBoardSwitchSmiAddrGet(MV_U32 ethPortNum, MV_U32 switchIndex)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE)&&(boardId < MV_MAX_BOARD_ID)))
+	{
+		mvOsPrintf("mvBoardSwitchSmiAddrGet: Board unknown.\n");
+		return MV_ERROR;
+	}
+
+	if (ethPortNum >= BOARD_INFO(boardId)->numBoardMacInfo)
+	{
+		mvOsPrintf("mvBoardSwitchSmiAddrGet: Illegal port number(%u)\n", ethPortNum);
+		return MV_ERROR;
+	}
+
+    if (switchIndex >= BOARD_MAX_CASCADED_SWITCHES)
+    {
+        mvOsPrintf("mvBoardSwitchSmiAddrGet: Illegal Switch index(%u)\n", switchIndex);
+        return MV_ERROR;
+    }
+
+    if ((MV_32)(BOARD_INFO(boardId)->pSwitchInfo))
+    	return BOARD_INFO(boardId)->pSwitchInfo[ethPortNum].switchSmiAddr[switchIndex];
+
+    return MV_ERROR;
+}
+
+/*******************************************************************************
+ * mvBoardDsaTagLenGet
+ */
+MV_U32 mvBoardDsaTagLenGet(MV_U32 port)
+{
+	MV_BOARD_INFO *b = BOARD_INFO(mvBoardIdGet());
+
+	if (port >= b->numBoardMacInfo)
+	{
+		mvOsPrintf("%s: Wrong port number (%u)\n", __func__, port);
+		return MV_ERROR;
+	}
+
+	return b->portDsaInfo[port].dsaTagLen;
+}
+
+/*******************************************************************************
+ * mvBoardUseDsaTagOnPort
+ */
+MV_BOOL mvBoardUseDsaTagOnPort(MV_U32 port)
+{
+	MV_BOARD_INFO *b = BOARD_INFO(mvBoardIdGet());
+
+	if (port >= b->numBoardMacInfo)
+	{
+		mvOsPrintf("%s: Wrong port number (%u)\n", __func__, port);
+		return MV_ERROR;
+	}
+
+	return b->portDsaInfo[port].useDsaTag;
+}
+
+/*******************************************************************************
+* mvBoardNumSwitchesOnPortGet - Get number of cascaded Switches on this Ethernet port
+*
+* DESCRIPTION:
+*       This routine returns the number of cascaded Switches on this Ethernet port.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_ERROR - if ethPortNum is illegal or board is unknown
+*       0 if no Switch information available
+*       1 if only one Switch is connected to this Ethernet port, 2 if two Switches are cascaded together on this port.
+*
+*******************************************************************************/
+MV_32	mvBoardNumSwitchesOnPortGet(MV_U32 ethPortNum)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE)&&(boardId < MV_MAX_BOARD_ID)))
+	{
+		mvOsPrintf("mvBoardNumSwitchesOnPortGet: Board unknown.\n");
+		return MV_ERROR;
+	}
+
+	if (ethPortNum >= BOARD_INFO(boardId)->numBoardMacInfo)
+	{
+		mvOsPrintf("mvBoardNumSwitchesOnPortGet: Illegal port number(%u)\n", ethPortNum);
+		return MV_ERROR;
+	}
+
+    if ((MV_32)(BOARD_INFO(boardId)->pSwitchInfo))
+    	return BOARD_INFO(boardId)->pSwitchInfo[ethPortNum].numSwitchesOnPort;
+
+    return 0;
+}
+
+/*********************************************************************************
+* mvBoardIsSwitchConnected - Check if a Switch is connected on this Ethernet Port
+*
+* DESCRIPTION:
+*       This routine checks if a Switch is connected on this Ethernet port.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE - if a Switch (or more than one Switch) is connected on this Ethernet Port
+*       MV_FALSE - otherwise (or in case of error)
+*
+*******************************************************************************/
+MV_BOOL     mvBoardIsSwitchConnected(MV_U32 ethPortNum)
+{
+    if (mvBoardNumSwitchesOnPortGet(ethPortNum) > 0)
+        return MV_TRUE;
+
+    return MV_FALSE;
+}
+/*******************************************************************************
+* mvBoardSmiScanModeGet - Get Switch SMI scan mode
+*
+* DESCRIPTION:
+*       This routine returns Switch SMI scan mode.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_ERROR - if ethPortNum is illegal or board is unknown
+*       1 for SMI_MANUAL_MODE,
+*       2 for SMI_MULTI_ADDR_MODE,
+*       -1 if the port number is wrong or if not relevant.
+*
+*******************************************************************************/
+MV_32	mvBoardSmiScanModeGet(MV_U32 ethPortNum)
+{
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE)&&(boardId < MV_MAX_BOARD_ID)))
+	{
+		mvOsPrintf("mvBoardSmiScanModeGet: Board unknown.\n");
+		return MV_ERROR;
+	}
+
+	if (ethPortNum >= BOARD_INFO(boardId)->numBoardMacInfo)
+	{
+		mvOsPrintf("mvBoardSmiScanModeGet: Illegal port number(%u)\n", ethPortNum);
+		return MV_ERROR;
+	}
+
+    if ((MV_32)(BOARD_INFO(boardId)->pSwitchInfo))
+    	return BOARD_INFO(boardId)->pSwitchInfo[ethPortNum].smiScanMode;
+
+    return MV_ERROR;
+}
+
+/*******************************************************************************
+* mvBoarGpioPinGet - mvBoarGpioPinGet
+*
+* DESCRIPTION:
+*
+* INPUT:
+*		class - MV_BOARD_GPP_CLASS enum.
+*
+* OUTPUT:
+*		None.
+*
+* RETURN:
+*       GPIO pin number. The function return -1 for bad parameters.
+*
+*******************************************************************************/
+MV_32 mvBoarGpioPinNumGet(MV_BOARD_GPP_CLASS class, MV_U32 index)
+{
+	MV_U32 boardId, i;
+	MV_U32 indexFound = 0;
+
+	boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE)&&(boardId < MV_MAX_BOARD_ID)))
+	{
+		mvOsPrintf("Board unknown.\n");
+		return MV_ERROR;
+
+	}
+
+        for (i = 0; i < BOARD_INFO(boardId)->numBoardGppInfo; i++)
+		if (BOARD_INFO(boardId)->pBoardGppInfo[i].devClass == class) {
+			if (indexFound == index)
+        			return (MV_U32)BOARD_INFO(boardId)->pBoardGppInfo[i].gppPinNum;
+			else
+				indexFound++;
+
+		}
+
+	return MV_ERROR;
+}
+
+/*******************************************************************************
+* mvBoardMppGet - Get board dependent MPP register value
+*
+* DESCRIPTION:
+*		MPP settings are derived from board design.
+*		MPP group consist of 8 MPPs. An MPP group represent MPP
+*		control register.
+*       This function retrieves board dependend MPP register value.
+*
+* INPUT:
+*       mppGroupNum - MPP group number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit value describing MPP control register value.
+*
+*******************************************************************************/
+MV_32 mvBoardMppGet(MV_U32 mppGroupNum)
+{
+	MV_U32 boardId;
+
+	boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE)&&(boardId < MV_MAX_BOARD_ID)))
+	{
+		mvOsPrintf("mvBoardMppGet:Board unknown.\n");
+		return MV_ERROR;
+
+	}
+
+	return BOARD_INFO(boardId)->pBoardMppConfigValue[0].mppGroup[mppGroupNum];
+}
+
+
+/*******************************************************************************
+* mvBoardMppGroupId - If MPP group type is AUTO then identify it using twsi
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_VOID mvBoardMppGroupIdUpdate(MV_VOID)
+{
+	MV_BOARD_MPP_GROUP_CLASS devClass;
+	MV_BOARD_MODULE_ID_CLASS devClassId;
+	MV_BOARD_MPP_TYPE_CLASS mppGroupType;
+	MV_U32 devId;
+	MV_U32 maxMppGrp = 1;
+
+	devId = mvCtrlModelGet();
+
+	switch(devId){
+        case MV_6281_DEV_ID:
+            maxMppGrp = MV_6281_MPP_MAX_MODULE;
+            break;
+        case MV_6282_DEV_ID:
+            maxMppGrp = MV_6282_MPP_MAX_MODULE;
+            break;
+        case MV_6280_DEV_ID:
+            maxMppGrp = MV_6280_MPP_MAX_MODULE;
+            break;
+        case MV_6192_DEV_ID:
+        case MV_6701_DEV_ID:
+        case MV_6702_DEV_ID:
+            maxMppGrp = MV_6192_MPP_MAX_MODULE;
+            break;
+        case MV_6190_DEV_ID:
+            maxMppGrp = MV_6190_MPP_MAX_MODULE;
+            break;
+        case MV_6180_DEV_ID:
+            maxMppGrp = MV_6180_MPP_MAX_MODULE;
+            break;
+	}
+
+	for (devClass = 0; devClass < maxMppGrp; devClass++)
+	{
+		/* If MPP group can be defined by the module connected to it */
+		if (mvBoardMppGroupTypeGet(devClass) == MV_BOARD_AUTO)
+		{
+			/* Get MPP module ID */
+			devClassId = mvBoarModuleTypeGet(devClass);
+			if (MV_ERROR != devClassId)
+			{
+				switch(devClassId)
+				{
+				case MV_BOARD_MODULE_TDM_ID:
+				case MV_BOARD_MODULE_TDM_5CHAN_ID:
+					mppGroupType = MV_BOARD_TDM;
+					break;
+				case MV_BOARD_MODULE_AUDIO_ID:
+					mppGroupType = MV_BOARD_AUDIO;
+					break;
+				case MV_BOARD_MODULE_RGMII_ID:
+					mppGroupType = MV_BOARD_RGMII;
+					break;
+				case MV_BOARD_MODULE_GMII_ID:
+					mppGroupType = MV_BOARD_GMII;
+					break;
+				case MV_BOARD_MODULE_TS_ID:
+					mppGroupType = MV_BOARD_TS;
+					break;
+				case MV_BOARD_MODULE_MII_ID:
+					mppGroupType = MV_BOARD_MII;
+					break;
+				case MV_BOARD_MODULE_LCD_ID:
+					mppGroupType = MV_BOARD_LCD;
+					break;
+				default:
+					mppGroupType = MV_BOARD_OTHER;
+					break;
+				}
+			}
+			else
+				/* The module bay is empty */
+				mppGroupType = MV_BOARD_OTHER;
+
+			/* Update MPP group type */
+			mvBoardMppGroupTypeSet(devClass, mppGroupType);
+		}
+
+
+		/* Update MPP output voltage for RGMII 1.8V. Set port to GMII for GMII module */
+		if ((mvBoardMppGroupTypeGet(devClass) == MV_BOARD_RGMII))
+			MV_REG_BIT_SET(MPP_OUTPUT_DRIVE_REG,MPP_1_8_RGMII1_OUTPUT_DRIVE | MPP_1_8_RGMII0_OUTPUT_DRIVE);
+        	else
+		{
+			if ((mvBoardMppGroupTypeGet(devClass) == MV_BOARD_GMII))
+        		{
+				MV_REG_BIT_RESET(MPP_OUTPUT_DRIVE_REG, BIT7 | BIT15);
+            			MV_REG_BIT_RESET(ETH_PORT_SERIAL_CTRL_1_REG(0),BIT3);
+            			MV_REG_BIT_RESET(ETH_PORT_SERIAL_CTRL_1_REG(1),BIT3);
+        		}
+        		else if ((mvBoardMppGroupTypeGet(devClass) == MV_BOARD_MII))
+        		{
+				/* Assumption that the MDC & MDIO should be 3.3V */
+				MV_REG_BIT_RESET(MPP_OUTPUT_DRIVE_REG, BIT7 | BIT15);
+				/* Assumption that only ETH1 can be MII when using modules on DB */
+            			MV_REG_BIT_RESET(ETH_PORT_SERIAL_CTRL_1_REG(1),BIT3);
+        		}
+		}
+	}
+
+	/* Update MPP when module is LCD to override both group */
+	devId = mvCtrlModelGet();
+	mppGroupType = mvBoardMppGroupTypeGet(0);
+	if ((devId == MV_6282_DEV_ID) && (mppGroupType == MV_BOARD_LCD))
+	{
+	    /* LCD module include AUDIO intrface over NAND ctrl lines */
+	    MV_REG_BIT_SET(NAND_AUDIO_PIN_MUX, NAND_AUDIO_PIN_MUX_SELECT_AUDIO_MODE);
+
+	    /* Override MPP group 1 type to LCD to update all MPP for LCD */
+	    mvBoardMppGroupTypeSet(1, MV_BOARD_LCD);
+	}
+}
+
+/*******************************************************************************
+* mvBoardMppGroupTypeGet
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       mppGroupClass - MPP group number 0  for MPP[35:20] or 1 for MPP[49:36].
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_BOARD_MPP_TYPE_CLASS mvBoardMppGroupTypeGet(MV_BOARD_MPP_GROUP_CLASS mppGroupClass)
+{
+	MV_U32 boardId;
+
+	boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE)&&(boardId < MV_MAX_BOARD_ID)))
+	{
+		mvOsPrintf("mvBoardMppGet:Board unknown.\n");
+		return MV_ERROR;
+
+	}
+
+	if (mppGroupClass == MV_BOARD_MPP_GROUP_1)
+		return BOARD_INFO(boardId)->pBoardMppTypeValue[0].boardMppGroup1;
+	else
+		return BOARD_INFO(boardId)->pBoardMppTypeValue[0].boardMppGroup2;
+}
+
+/*******************************************************************************
+* mvBoardMppGroupTypeSet
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       mppGroupClass - MPP group number 0  for MPP[35:20] or 1 for MPP[49:36].
+*       mppGroupType - MPP group type for MPP[35:20] or for MPP[49:36].
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_VOID mvBoardMppGroupTypeSet(MV_BOARD_MPP_GROUP_CLASS mppGroupClass,
+						MV_BOARD_MPP_TYPE_CLASS mppGroupType)
+{
+	MV_U32 boardId;
+
+	boardId = mvBoardIdGet();
+
+	if (!((boardId >= BOARD_ID_BASE)&&(boardId < MV_MAX_BOARD_ID)))
+	{
+		mvOsPrintf("mvBoardMppGet:Board unknown.\n");
+	}
+
+	if (mppGroupClass == MV_BOARD_MPP_GROUP_1)
+		BOARD_INFO(boardId)->pBoardMppTypeValue[0].boardMppGroup1 = mppGroupType;
+	else
+		BOARD_INFO(boardId)->pBoardMppTypeValue[0].boardMppGroup2 = mppGroupType;
+
+}
+
+/*******************************************************************************
+* mvBoardMppMuxSet - Update MPP mux
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_VOID mvBoardMppMuxSet(MV_VOID)
+{
+	MV_BOARD_MPP_GROUP_CLASS devClass;
+	MV_BOARD_MPP_TYPE_CLASS mppGroupType;
+	MV_U32 devId;
+	MV_U8 muxVal = 0xf;
+	MV_U32 maxMppGrp = 1;
+    MV_TWSI_SLAVE twsiSlave;
+	MV_TWSI_ADDR slave;
+
+	devId = mvCtrlModelGet();
+
+	switch(devId){
+		case MV_6281_DEV_ID:
+			maxMppGrp = MV_6281_MPP_MAX_MODULE;
+			break;
+        case MV_6282_DEV_ID:
+            maxMppGrp = MV_6282_MPP_MAX_MODULE;
+            break;
+        case MV_6280_DEV_ID:
+            maxMppGrp = MV_6280_MPP_MAX_MODULE;
+			break;
+		case MV_6192_DEV_ID:
+        case MV_6701_DEV_ID:
+        case MV_6702_DEV_ID:
+			maxMppGrp = MV_6192_MPP_MAX_MODULE;
+			break;
+        case MV_6190_DEV_ID:
+            maxMppGrp = MV_6190_MPP_MAX_MODULE;
+            break;
+		case MV_6180_DEV_ID:
+			maxMppGrp = MV_6180_MPP_MAX_MODULE;
+			break;
+	}
+
+	for (devClass = 0; devClass < maxMppGrp; devClass++)
+	{
+		mppGroupType = mvBoardMppGroupTypeGet(devClass);
+
+		switch(mppGroupType)
+		{
+			case MV_BOARD_TDM:
+				muxVal &= ~(devClass ? (0x2 << (devClass * 2)):0x0);
+				break;
+			case MV_BOARD_AUDIO:
+				 muxVal &= ~(devClass ? 0x7 : 0x0); /*old Z0 value 0xd:0x0*/
+				break;
+			case MV_BOARD_TS:
+				 muxVal &= ~(devClass ? (0x2 << (devClass * 2)):0x0);
+				break;
+			case MV_BOARD_LCD:
+				 muxVal = 0x0;
+				break;
+			default:
+				muxVal |= (devClass ? 0xf : 0);
+				break;
+		}
+	}
+
+	/* TWSI init */
+	slave.type = ADDR7_BIT;
+	slave.address = 0;
+	mvTwsiInit(0, TWSI_SPEED, kirkwood_tclk, &slave, 0);
+
+	/* Read MPP module ID */
+    	DB(mvOsPrintf("Board: twsi exp set\n"));
+    	twsiSlave.slaveAddr.address = mvBoardTwsiExpAddrGet(MV_BOARD_MUX_I2C_ADDR_ENTRY);
+    	twsiSlave.slaveAddr.type = mvBoardTwsiExpAddrTypeGet(MV_BOARD_MUX_I2C_ADDR_ENTRY);
+    	twsiSlave.validOffset = MV_TRUE;
+	/* Offset is the first command after the address which indicate the register number to be read
+	   in next operation */
+    	twsiSlave.offset = 2;
+    	twsiSlave.moreThen256 = MV_FALSE;
+
+
+
+    	if( MV_OK != mvTwsiWrite (0, &twsiSlave, &muxVal, 1) )
+    	{
+    		DB(mvOsPrintf("Board: twsi exp out val fail\n"));
+        	return;
+    	}
+    	DB(mvOsPrintf("Board: twsi exp out val succeded\n"));
+
+	/* Change twsi exp to output */
+    	twsiSlave.offset = 6;
+	muxVal = 0;
+	if( MV_OK != mvTwsiWrite (0, &twsiSlave, &muxVal, 1) )
+    	{
+    		DB(mvOsPrintf("Board: twsi exp change to out fail\n"));
+        	return;
+    	}
+    	DB(mvOsPrintf("Board: twsi exp change to out succeded\n"));
+
+}
+
+/*******************************************************************************
+* mvBoardTdmMppSet - set MPPs in TDM module
+*
+* DESCRIPTION:
+*
+* INPUT: type of second telephony device
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_VOID mvBoardTdmMppSet(MV_32 chType)
+{
+	MV_BOARD_MPP_GROUP_CLASS devClass;
+	MV_BOARD_MPP_TYPE_CLASS mppGroupType;
+	MV_U32 devId;
+	MV_U8 muxVal = 1;
+	MV_U8 muxValMask = 1;
+	MV_U8 twsiVal;
+	MV_U32 maxMppGrp = 1;
+    	MV_TWSI_SLAVE twsiSlave;
+	MV_TWSI_ADDR slave;
+
+	devId = mvCtrlModelGet();
+
+	switch(devId)
+	{
+		case MV_6281_DEV_ID:
+			maxMppGrp = MV_6281_MPP_MAX_MODULE;
+			break;
+        case MV_6282_DEV_ID:
+            maxMppGrp = MV_6282_MPP_MAX_MODULE;
+            break;
+        case MV_6280_DEV_ID:
+            maxMppGrp = MV_6280_MPP_MAX_MODULE;
+			break;
+		case MV_6192_DEV_ID:
+		case MV_6701_DEV_ID:
+		case MV_6702_DEV_ID:
+			maxMppGrp = MV_6192_MPP_MAX_MODULE;
+			break;
+        case MV_6190_DEV_ID:
+            maxMppGrp = MV_6190_MPP_MAX_MODULE;
+            break;
+		case MV_6180_DEV_ID:
+			maxMppGrp = MV_6180_MPP_MAX_MODULE;
+			break;
+	}
+
+	for (devClass = 0; devClass < maxMppGrp; devClass++)
+	{
+		mppGroupType = mvBoardMppGroupTypeGet(devClass);
+		if(mppGroupType == MV_BOARD_TDM)
+			break;
+	}
+
+	if(devClass == maxMppGrp)
+		return;		/* TDM module not found */
+
+	/* TWSI init */
+	slave.type = ADDR7_BIT;
+	slave.address = 0;
+	mvTwsiInit(0, TWSI_SPEED, kirkwood_tclk, &slave, 0);
+
+	/* Read MPP module ID */
+    	DB(mvOsPrintf("Board: twsi exp set\n"));
+    	twsiSlave.slaveAddr.address = mvBoardTwsiExpAddrGet(devClass);
+    	twsiSlave.slaveAddr.type = ADDR7_BIT;
+    	twsiSlave.validOffset = MV_TRUE;
+	/* Offset is the first command after the address which indicate the register number to be read
+	   in next operation */
+    	twsiSlave.offset = 3;
+    	twsiSlave.moreThen256 = MV_FALSE;
+
+	if(mvBoardIdGet() == RD_88F6281A_ID)
+	{
+		muxVal = 0xc;
+		muxValMask = 0xf3;
+	}
+
+	mvTwsiRead(0, &twsiSlave, &twsiVal, 1);
+        muxVal = (twsiVal & muxValMask) | muxVal;
+
+    	if( MV_OK != mvTwsiWrite (0, &twsiSlave, &muxVal, 1) )
+    	{
+    		mvOsPrintf("Board(1): twsi exp out val fail\n");
+        	return;
+    	}
+    	DB(mvOsPrintf("Board: twsi exp out val succeded\n"));
+
+	/* Change twsi exp to output */
+    	twsiSlave.offset = 7;
+	muxVal = 0xfe;
+	if(mvBoardIdGet() == RD_88F6281A_ID)
+		muxVal = 0xf3;
+
+	mvTwsiRead(0, &twsiSlave, &twsiVal, 1);
+	muxVal = (twsiVal & muxVal);
+
+	if( MV_OK != mvTwsiWrite (0, &twsiSlave, &muxVal, 1) )
+    	{
+    		mvOsPrintf("Board: twsi exp change to out fail\n");
+        	return;
+    	}
+    	DB(mvOsPrintf("Board: twsi exp change to out succeded\n"));
+	/* reset the line to 0 */
+    	twsiSlave.offset = 3;
+	muxVal = 0;
+	muxValMask = 1;
+
+	if(mvBoardIdGet() == RD_88F6281A_ID)
+	{
+		muxVal = 0x0;
+		muxValMask = 0xf3;
+	}
+
+	mvTwsiRead(0, &twsiSlave, &twsiVal, 1);
+        muxVal = (twsiVal & muxValMask) | muxVal;
+
+    	if( MV_OK != mvTwsiWrite (0, &twsiSlave, &muxVal, 1) )
+    	{
+    		mvOsPrintf("Board(2): twsi exp out val fail\n");
+        	return;
+    	}
+    	DB(mvOsPrintf("Board: twsi exp out val succeded\n"));
+
+	mvOsDelay(20);
+
+	/* set the line to 1 */
+    	twsiSlave.offset = 3;
+	muxVal = 1;
+	muxValMask = 1;
+
+	if(mvBoardIdGet() == RD_88F6281A_ID)
+	{
+		muxVal = 0xc;
+		muxValMask = 0xf3;
+		if(chType) /* FXS - issue reset properly */
+		{
+			MV_REG_BIT_SET(GPP_DATA_OUT_REG(1), MV_GPP12);
+			mvOsDelay(50);
+			MV_REG_BIT_RESET(GPP_DATA_OUT_REG(1), MV_GPP12);
+		}
+		else /* FXO - issue reset via TDM_CODEC_RST*/
+		{
+		   /* change MPP44 type to TDM_CODEC_RST(0x2) */
+		   MV_REG_WRITE(MPP_CONTROL_REG5, ((MV_REG_READ(MPP_CONTROL_REG5) & 0xFFF0FFFF)  | BIT17));
+		}
+	}
+
+	mvTwsiRead(0, &twsiSlave, &twsiVal, 1);
+        muxVal = (twsiVal & muxValMask) | muxVal;
+
+    	if( MV_OK != mvTwsiWrite (0, &twsiSlave, &muxVal, 1) )
+    	{
+    		mvOsPrintf("Board: twsi exp out val fail\n");
+        	return;
+    	}
+
+    	DB(mvOsPrintf("Board: twsi exp out val succeded\n"));
+}
+
+/*******************************************************************************
+* mvBoardTdmSpiModeGet - return SLIC/DAA connection
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_32 mvBoardTdmSpiModeGet(MV_VOID)
+{
+	switch(mvBoardIdGet())
+	{
+		case RD_88F6281A_ID:
+			return DAISY_CHAIN_MODE;
+		case DB_88F6281A_BP_ID:
+		case RD_88F6192A_ID:
+		case DB_88F6192A_BP_ID:
+		case DB_88F6701A_BP_ID:
+		case DB_88F6702A_BP_ID:
+		case DB_88F6282A_BP_ID:
+		case RD_88F6282A_ID:
+			 return DUAL_CHIP_SELECT_MODE;
+		default:
+			mvOsPrintf("%s: unknown boardId(0x%x)\n",__FUNCTION__, mvBoardIdGet());
+			return DUAL_CHIP_SELECT_MODE;
+	}
+}
+
+/*******************************************************************************
+* mvBoardTwsiExpAddrTypeGet -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*
+*
+*******************************************************************************/
+MV_U8 mvBoardTwsiExpAddrTypeGet(MV_U32 index)
+{
+	int i;
+	MV_U32 indexFound = 0;
+	MV_U32 boardId= mvBoardIdGet();
+
+	for (i = 0; i < BOARD_INFO(boardId)->numBoardTwsiDev; i++)
+		if (BOARD_INFO(boardId)->pBoardTwsiDev[i].devClass == BOARD_DEV_TWSI_EXP)
+		{
+			if (indexFound == index)
+				return BOARD_INFO(boardId)->pBoardTwsiDev[i].twsiDevAddrType;
+			else
+				indexFound++;
+		}
+
+	return (MV_ERROR);
+}
+
+/*******************************************************************************
+* mvBoardTwsiExpAddrGet -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*
+*
+*******************************************************************************/
+MV_U8 mvBoardTwsiExpAddrGet(MV_U32 index)
+{
+	int i;
+	MV_U32 indexFound = 0;
+	MV_U32 boardId= mvBoardIdGet();
+
+	for (i = 0; i < BOARD_INFO(boardId)->numBoardTwsiDev; i++)
+		if (BOARD_INFO(boardId)->pBoardTwsiDev[i].devClass == BOARD_DEV_TWSI_EXP)
+		{
+			if (indexFound == index)
+				return BOARD_INFO(boardId)->pBoardTwsiDev[i].twsiDevAddr;
+			else
+				indexFound++;
+		}
+
+	return (0xFF);
+}
+
+
+/*******************************************************************************
+* mvBoardTwsiSatRAddrTypeGet -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*
+*
+*******************************************************************************/
+MV_U8 mvBoardTwsiSatRAddrTypeGet(MV_U32 index)
+{
+	int i;
+	MV_U32 indexFound = 0;
+	MV_U32 boardId= mvBoardIdGet();
+
+	for (i = 0; i < BOARD_INFO(boardId)->numBoardTwsiDev; i++)
+		if (BOARD_INFO(boardId)->pBoardTwsiDev[i].devClass == BOARD_DEV_TWSI_SATR)
+		{
+			if (indexFound == index)
+				return BOARD_INFO(boardId)->pBoardTwsiDev[i].twsiDevAddrType;
+			else
+				indexFound++;
+		}
+
+	return (MV_ERROR);
+}
+
+/*******************************************************************************
+* mvBoardTwsiSatRAddrGet -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*
+*
+*******************************************************************************/
+MV_U8 mvBoardTwsiSatRAddrGet(MV_U32 index)
+{
+	int i;
+	MV_U32 indexFound = 0;
+	MV_U32 boardId= mvBoardIdGet();
+
+	for (i = 0; i < BOARD_INFO(boardId)->numBoardTwsiDev; i++)
+		if (BOARD_INFO(boardId)->pBoardTwsiDev[i].devClass == BOARD_DEV_TWSI_SATR)
+		{
+			if (indexFound == index)
+				return BOARD_INFO(boardId)->pBoardTwsiDev[i].twsiDevAddr;
+			else
+				indexFound++;
+		}
+
+	return (0xFF);
+}
+
+MV_U32 gBoardId;
+
+/*******************************************************************************
+* mvBoardIdSet - Set Board model
+*
+* DESCRIPTION:
+*       Board ID is 32bit word constructed of board model (16bit) and
+*       board revision (16bit) in the following way: 0xMMMMRRRR.
+*
+* INPUT:
+*       Board ID.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvBoardIdSet(MV_U32 boardId)
+{
+	gBoardId = boardId;
+}
+
+/*******************************************************************************
+* mvBoardIdGet - Get Board model
+*
+* DESCRIPTION:
+*       This function returns board ID.
+*       Board ID is 32bit word constructed of board model (16bit) and
+*       board revision (16bit) in the following way: 0xMMMMRRRR.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit board ID number, '-1' if board is undefined.
+*
+*******************************************************************************/
+MV_U32 mvBoardIdGet(MV_VOID)
+{
+	MV_U32 tmpBoardId = -1;
+
+	if(gBoardId == -1)
+        {
+		#if defined(DB_88F6281A)
+		tmpBoardId = DB_88F6281A_BP_ID;
+		#elif defined(DB_88F6282A)
+		tmpBoardId = DB_88F6282A_BP_ID;
+		#elif defined(DB_88F6280A)
+		tmpBoardId = DB_88F6280A_BP_ID;
+		#elif defined(RD_88F6281A)
+		tmpBoardId = RD_88F6281A_ID;
+		#elif defined(RD_88F6282A)
+		tmpBoardId = RD_88F6282A_ID;
+		#elif defined(DB_88F6192A)
+		tmpBoardId = DB_88F6192A_BP_ID;
+		#elif defined(DB_88F6701A)
+		tmpBoardId = DB_88F6701A_BP_ID;
+		#elif defined(DB_88F6702A)
+		tmpBoardId = DB_88F6702A_BP_ID;
+		#elif defined(DB_88F6190A)
+		tmpBoardId = DB_88F6190A_BP_ID;
+		#elif defined(RD_88F6192A)
+		tmpBoardId = RD_88F6192A_ID;
+		#elif defined(RD_88F6190A)
+		tmpBoardId = RD_88F6190A_ID;
+		#elif defined(DB_88F6180A)
+		tmpBoardId = DB_88F6180A_BP_ID;
+		#elif defined(RD_88F6281A_PCAC)
+		tmpBoardId = RD_88F6281A_PCAC_ID;
+		#elif defined(RD_88F6281A_SHEEVA_PLUG)
+		tmpBoardId = SHEEVA_PLUG_ID;
+		#elif defined(DB_CUSTOMER)
+		tmpBoardId = DB_CUSTOMER_ID;
+		#endif
+		gBoardId = tmpBoardId;
+	}
+
+	return gBoardId;
+}
+
+
+/*******************************************************************************
+* mvBoarModuleTypeGet - mvBoarModuleTypeGet
+*
+* DESCRIPTION:
+*
+* INPUT:
+*		group num - MV_BOARD_MPP_GROUP_CLASS enum
+*
+* OUTPUT:
+*		None.
+*
+* RETURN:
+*		module num - MV_BOARD_MODULE_CLASS enum
+*
+*******************************************************************************/
+MV_BOARD_MODULE_ID_CLASS mvBoarModuleTypeGet(MV_BOARD_MPP_GROUP_CLASS devClass)
+{
+    	MV_TWSI_SLAVE twsiSlave;
+	MV_TWSI_ADDR slave;
+    	MV_U8 data;
+
+	/* TWSI init */
+	slave.type = ADDR7_BIT;
+	slave.address = 0;
+	mvTwsiInit(0, TWSI_SPEED, kirkwood_tclk, &slave, 0);
+
+    	/* Read MPP module ID */
+    	DB(mvOsPrintf("Board: Read MPP module ID\n"));
+    	twsiSlave.slaveAddr.address = mvBoardTwsiExpAddrGet(devClass);
+    	twsiSlave.slaveAddr.type = mvBoardTwsiExpAddrTypeGet(devClass);
+    	twsiSlave.validOffset = MV_TRUE;
+	/* Offset is the first command after the address which indicate the register number to be read
+	   in next operation */
+    	twsiSlave.offset = 0;
+    	twsiSlave.moreThen256 = MV_FALSE;
+
+
+
+    	if( MV_OK != mvTwsiRead (0, &twsiSlave, &data, 1) )
+    	{
+    		DB(mvOsPrintf("Board: Read MPP module ID fail\n"));
+        	return MV_ERROR;
+    	}
+    	DB(mvOsPrintf("Board: Read MPP module ID succeded\n"));
+
+	return data;
+}
diff --git a/arch/arm/mach-kirkwood/kw_family/boardEnv/mvBoardEnvLib.h b/arch/arm/mach-kirkwood/kw_family/boardEnv/mvBoardEnvLib.h
new file mode 100644
index 0000000..d6f715e
--- /dev/null
+++ b/arch/arm/mach-kirkwood/kw_family/boardEnv/mvBoardEnvLib.h
@@ -0,0 +1,357 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#ifndef __INCmvBoardEnvLibh
+#define __INCmvBoardEnvLibh
+
+/* defines */
+/* The below constant macros defines the board I2C EEPROM data offsets */
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "mvSysHwConfig.h"
+#include "boardEnv/mvBoardEnvSpec.h"
+
+/* DUART stuff for Tclk detection only */
+#define DUART_BAUD_RATE			115200
+#define MAX_CLOCK_MARGINE		5000000	/* Maximum detected clock margine */
+
+/* Voice devices assembly modes */
+#define DAISY_CHAIN_MODE        1
+#define DUAL_CHIP_SELECT_MODE   0
+#define INTERRUPT_TO_MPP        1
+#define INTERRUPT_TO_TDM        0
+
+#define BOARD_ETH_PORT_NUM  MV_ETH_MAX_PORTS
+#define BOARD_MAX_CASCADED_SWITCHES     2
+#define BOARD_ETH_SWITCH_PORT_NUM       11
+#define BOARD_ETH_MAX_PORT_STRING       32
+
+#define	MV_BOARD_MAX_USB_IF		1
+#define MV_BOARD_MAX_MPP		7
+#define MV_BOARD_NAME_LEN  		0x20
+
+typedef struct _boardData
+{
+   MV_U32 magic;
+   MV_U16 boardId;
+   MV_U8 boardVer;
+   MV_U8 boardRev;
+   MV_U32 reserved1;
+   MV_U32 reserved2;
+
+}BOARD_DATA;
+
+typedef enum _devBoardMppGroupClass
+{
+	MV_BOARD_MPP_GROUP_1,
+	MV_BOARD_MPP_GROUP_2,
+	MV_BOARD_MAX_MPP_GROUP
+}MV_BOARD_MPP_GROUP_CLASS;
+
+typedef enum _devBoardMppTypeClass
+{
+	MV_BOARD_AUTO,
+	MV_BOARD_TDM,
+	MV_BOARD_AUDIO,
+	MV_BOARD_RGMII,
+	MV_BOARD_GMII,
+	MV_BOARD_TS,
+	MV_BOARD_MII,
+	RSRVD0,
+	MV_BOARD_LCD,
+	MV_BOARD_OTHER
+}MV_BOARD_MPP_TYPE_CLASS;
+
+typedef enum _devBoardModuleIdClass
+{
+	MV_BOARD_MODULE_TDM_ID = 1,
+	MV_BOARD_MODULE_AUDIO_ID,
+	MV_BOARD_MODULE_RGMII_ID,
+	MV_BOARD_MODULE_GMII_ID,
+	MV_BOARD_MODULE_TS_ID,
+	MV_BOARD_MODULE_MII_ID,
+	MV_BOARD_MODULE_TDM_5CHAN_ID,
+	MV_BOARD_MODULE_LCD_ID = 9,
+	MV_BOARD_MODULE_OTHER_ID
+}MV_BOARD_MODULE_ID_CLASS;
+
+typedef struct _boardMppTypeInfo
+{
+	MV_BOARD_MPP_TYPE_CLASS	boardMppGroup1;
+	MV_BOARD_MPP_TYPE_CLASS	boardMppGroup2;
+
+}MV_BOARD_MPP_TYPE_INFO;
+
+
+typedef enum _devBoardClass
+{
+	BOARD_DEV_NOR_FLASH,
+	BOARD_DEV_NAND_FLASH,
+	BOARD_DEV_SEVEN_SEG,
+	BOARD_DEV_FPGA,
+	BOARD_DEV_SRAM,
+	BOARD_DEV_SPI_FLASH,
+	BOARD_DEV_OTHER,
+}MV_BOARD_DEV_CLASS;
+
+typedef enum _devTwsiBoardClass
+{
+	BOARD_TWSI_RTC,
+	BOARD_DEV_TWSI_EXP,
+	BOARD_DEV_TWSI_SATR,
+	BOARD_TWSI_AUDIO_DEC,
+	BOARD_TWSI_OTHER
+}MV_BOARD_TWSI_CLASS;
+
+typedef enum _devGppBoardClass
+{
+	BOARD_GPP_RTC,
+	BOARD_GPP_MV_SWITCH,
+	BOARD_GPP_USB_VBUS,
+	BOARD_GPP_USB_VBUS_EN,
+	BOARD_GPP_USB_OC,
+	BOARD_GPP_USB_HOST_DEVICE,
+	BOARD_GPP_REF_CLCK,
+	BOARD_GPP_VOIP_SLIC,
+	BOARD_GPP_LIFELINE,
+	BOARD_GPP_BUTTON,
+	BOARD_GPP_TS_BUTTON_C,
+	BOARD_GPP_TS_BUTTON_U,
+	BOARD_GPP_TS_BUTTON_D,
+	BOARD_GPP_TS_BUTTON_L,
+	BOARD_GPP_TS_BUTTON_R,
+	BOARD_GPP_POWER_BUTTON,
+	BOARD_GPP_RESTOR_BUTTON,
+	BOARD_GPP_WPS_BUTTON,
+	BOARD_GPP_HDD0_POWER,
+	BOARD_GPP_HDD1_POWER,
+	BOARD_GPP_FAN_POWER,
+	BOARD_GPP_RESET,
+	BOARD_GPP_POWER_ON_LED,
+	BOARD_GPP_HDD_POWER,
+    BOARD_GPP_SDIO_POWER,
+    BOARD_GPP_SDIO_DETECT,
+    BOARD_GPP_SDIO_WP,
+	BOARD_GPP_SWITCH_PHY_INT,
+	BOARD_GPP_TSU_DIRCTION,
+	BOARD_GPP_OTHER
+}MV_BOARD_GPP_CLASS;
+
+
+typedef struct _devCsInfo
+{
+    MV_U8		deviceCS;
+    MV_U32		params;
+    MV_U32		devClass;	/* MV_BOARD_DEV_CLASS */
+    MV_U8		devWidth;
+
+}MV_DEV_CS_INFO;
+
+typedef struct _boardSwitchPort
+{
+    MV_32   qdSwitchNum;                                /* Switch index, e.g., 0, 1 */
+    MV_32   qdPortNum;                                  /* Switch physical port number */
+    char    portStr[BOARD_ETH_MAX_PORT_STRING];         /* String to print for link change messages */
+}MV_BOARD_SWITCH_PORT;
+
+typedef struct _boardSwitchInfo
+{
+    MV_32   numSwitchesOnPort;    /* number of Switches on this port: 1 means only one Switch is connected, 2 means two cascaded Switches on this port */
+    MV_32	linkStatusIrq[BOARD_MAX_CASCADED_SWITCHES];         /* link indication IRQ (MPP) number, or -1 for polling */
+    MV_BOARD_SWITCH_PORT    qdPort[BOARD_ETH_SWITCH_PORT_NUM];  /* map logical port number to switch index and physical switch port number */
+    MV_32	qdCpuPort[BOARD_MAX_CASCADED_SWITCHES];             /* Switch port directed to the CPU (GbE) */
+    MV_32   qdInterconnectPort[BOARD_MAX_CASCADED_SWITCHES];    /* Switch port connected to another Switch. Assumes only 2 cascaded Switches */
+    MV_32	smiScanMode;                                        /* 1 for SMI_MANUAL_MODE, 2 for SMI_MULTI_ADDR_MODE, 0 otherwise */
+    MV_U8   switchSmiAddr[BOARD_MAX_CASCADED_SWITCHES];         /* Switch SMI address */
+}MV_BOARD_SWITCH_INFO;
+
+typedef struct _boardLedInfo
+{
+	MV_U8	activeLedsNumber;
+	MV_U8	ledsPolarity;	/* '0' or '1' to turn on led */
+	MV_U8*	gppPinNum; 	/* Pointer to GPP values */
+
+}MV_BOARD_LED_INFO;
+
+typedef struct _boardGppInfo
+{
+	MV_BOARD_GPP_CLASS	devClass;
+	MV_U8	gppPinNum;
+
+}MV_BOARD_GPP_INFO;
+
+
+typedef struct _boardTwsiInfo
+{
+	MV_BOARD_TWSI_CLASS	devClass;
+	MV_U8	twsiDevAddr;
+	MV_U8	twsiDevAddrType;
+
+}MV_BOARD_TWSI_INFO;
+
+
+typedef enum _boardMacSpeed
+{
+	BOARD_MAC_SPEED_10M,
+	BOARD_MAC_SPEED_100M,
+	BOARD_MAC_SPEED_1000M,
+	BOARD_MAC_SPEED_AUTO,
+
+}MV_BOARD_MAC_SPEED;
+
+typedef struct _boardMacInfo
+{
+	MV_BOARD_MAC_SPEED  boardMacSpeed;
+	MV_U8               boardEthSmiAddr;
+
+}MV_BOARD_MAC_INFO;
+
+typedef struct _boardMppInfo
+{
+	MV_U32		mppGroup[MV_BOARD_MAX_MPP];
+
+}MV_BOARD_MPP_INFO;
+
+typedef struct _mvPortDsaInfo
+{
+	MV_BOOL		useDsaTag;
+	MV_U32		dsaTagLen;
+} MV_PORT_DSA_INFO;
+
+typedef struct _boardInfo
+{
+	char 			   	boardName[MV_BOARD_NAME_LEN];
+	MV_U8				numBoardMppTypeValue;
+	MV_BOARD_MPP_TYPE_INFO*		pBoardMppTypeValue;
+	MV_U8				numBoardMppConfigValue;
+	MV_BOARD_MPP_INFO*	pBoardMppConfigValue;
+    MV_U32				intsGppMaskLow;
+	MV_U32				intsGppMaskHigh;
+	MV_U8				numBoardDeviceIf;
+    MV_DEV_CS_INFO*		pDevCsInfo;
+	MV_U8				numBoardTwsiDev;
+	MV_BOARD_TWSI_INFO*	pBoardTwsiDev;
+	MV_U8				numBoardMacInfo;
+	MV_BOARD_MAC_INFO*	pBoardMacInfo;
+	MV_U8				numBoardGppInfo;
+	MV_BOARD_GPP_INFO*	pBoardGppInfo;
+    MV_U8				activeLedsNumber;
+	MV_U8*				pLedGppPin;
+	MV_U8				ledsPolarity;	/* '0' or '1' to turn on led */
+	/* GPP values */
+	MV_U32				gppOutEnValLow;
+	MV_U32				gppOutEnValHigh;
+	MV_U32				gppOutValLow;
+	MV_U32				gppOutValHigh;
+	MV_U32				gppPolarityValLow;
+	MV_U32				gppPolarityValHigh;
+
+	/* Switch Configuration */
+	MV_BOARD_SWITCH_INFO*		pSwitchInfo;
+	MV_U32				nandFlashReadParams;
+	MV_U32				nandFlashWriteParams;
+	MV_U32				nandFlashControl;
+
+	/* General DSA tag support */
+	MV_PORT_DSA_INFO		*portDsaInfo;
+}MV_BOARD_INFO;
+
+MV_VOID 	mvBoardEnvInit(MV_VOID);
+MV_VOID     mvBoardIdSet(MV_U32 boardId);
+MV_U32      mvBoardIdGet(MV_VOID);
+MV_STATUS	mvBoardNameGet(char *pNameBuff);
+MV_32      	mvBoardPhyAddrGet(MV_U32 ethPortNum);
+MV_BOARD_MAC_SPEED      mvBoardMacSpeedGet(MV_U32 ethPortNum);
+
+MV_U32 mvBoardDsaTagLenGet(MV_U32 port);
+MV_BOOL mvBoardUseDsaTagOnPort(MV_U32 port);
+
+/* Switch related: */
+MV_32       mvBoardNumSwitchesOnPortGet(MV_U32 ethPortNum);
+MV_32		mvBoardLinkStatusIrqGet(MV_U32 ethPortNum, MV_U32 switchIndex);
+MV_32   	mvBoardSwitchPortGet(MV_U32 ethPortNum, MV_U8 logicalPortNum, MV_32 *switchIndex, MV_32 *portNum, char *portName);
+MV_32		mvBoardSwitchCpuPortGet(MV_U32 ethPortNum, MV_U32 switchIndex);
+MV_32       mvBoardSwitchInterconnectPortGet(MV_U32 ethPortNum, MV_U32 switchIndex);
+MV_32		mvBoardSmiScanModeGet(MV_U32 ethPortNum);
+MV_32       mvBoardSwitchSmiAddrGet(MV_U32 ethPortNum, MV_U32 switchIndex);
+MV_BOOL     mvBoardIsSwitchConnected(MV_U32 ethPortNum);
+
+MV_BOOL     mvBoardIsPortInSgmii(MV_U32 ethPortNum);
+MV_BOOL 	mvBoardIsPortInGmii(MV_VOID);
+MV_32      	mvBoardMppGet(MV_U32 mppGroupNum);
+
+MV_U8 		mvBoardTwsiExpAddrGet(MV_U32 index);
+MV_U8 		mvBoardTwsiSatRAddrTypeGet(MV_U32 index);
+MV_U8 		mvBoardTwsiSatRAddrGet(MV_U32 index);
+MV_U8 		mvBoardTwsiExpAddrTypeGet(MV_U32 index);
+MV_BOARD_MODULE_ID_CLASS 	mvBoarModuleTypeGet(MV_BOARD_MPP_GROUP_CLASS devClass);
+MV_BOARD_MPP_TYPE_CLASS 	mvBoardMppGroupTypeGet(MV_BOARD_MPP_GROUP_CLASS mppGroupClass);
+MV_VOID 	mvBoardMppGroupTypeSet(MV_BOARD_MPP_GROUP_CLASS mppGroupClass,
+						MV_BOARD_MPP_TYPE_CLASS mppGroupType);
+MV_VOID 	mvBoardMppGroupIdUpdate(MV_VOID);
+MV_VOID 	mvBoardMppMuxSet(MV_VOID);
+MV_VOID 	mvBoardTdmMppSet(MV_32 chType);
+MV_32 		mvBoardTdmSpiModeGet(MV_VOID);
+MV_32		mvBoarGpioPinNumGet(MV_BOARD_GPP_CLASS class, MV_U32 index);
+
+#endif /* __INCmvBoardEnvLibh */
diff --git a/arch/arm/mach-kirkwood/kw_family/boardEnv/mvBoardEnvSpec.c b/arch/arm/mach-kirkwood/kw_family/boardEnv/mvBoardEnvSpec.c
new file mode 100644
index 0000000..7a63d32
--- /dev/null
+++ b/arch/arm/mach-kirkwood/kw_family/boardEnv/mvBoardEnvSpec.c
@@ -0,0 +1,1425 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#include "mvCommon.h"
+#include "mvBoardEnvLib.h"
+#include "mvBoardEnvSpec.h"
+#include "twsi/mvTwsi.h"
+
+#define DB_88F6281A_BOARD_TWSI_DEF_NUM              0x7
+#define DB_88F6281A_BOARD_MAC_INFO_NUM              0x2
+#define DB_88F6281A_BOARD_GPP_INFO_NUM              0x1
+#define DB_88F6281A_BOARD_MPP_CONFIG_NUM            0x1
+#define DB_88F6281A_BOARD_MPP_GROUP_TYPE_NUM        0x1
+#if defined(MV_NAND) && defined(MV_NAND_BOOT)
+    #define DB_88F6281A_BOARD_DEVICE_CONFIG_NUM	    0x1
+#elif defined(MV_NAND) && defined(MV_SPI_BOOT)
+    #define DB_88F6281A_BOARD_DEVICE_CONFIG_NUM	    0x2
+#else
+    #define DB_88F6281A_BOARD_DEVICE_CONFIG_NUM	    0x1
+#endif
+#define DB_88F6281A_BOARD_DEBUG_LED_NUM             0x0
+#define DB_88F6281A_BOARD_NAND_READ_PARAMS          0x000C0282
+#define DB_88F6281A_BOARD_NAND_WRITE_PARAMS         0x00010305
+#define DB_88F6281A_BOARD_NAND_CONTROL              0x01c00541
+
+MV_PORT_DSA_INFO defaultBoardPortDsaInfo[CONFIG_MV_ETH_PORTS_NUM] =
+{
+	[0 ... CONFIG_MV_ETH_PORTS_NUM-1] = {
+		.useDsaTag = MV_FALSE,
+		.dsaTagLen = 0,
+	}
+};
+
+MV_BOARD_TWSI_INFO	db88f6281AInfoBoardTwsiDev[] =
+	/* {{MV_BOARD_DEV_CLASS	devClass, MV_U8	twsiDevAddr, MV_U8 twsiDevAddrType}} */
+	{
+	{BOARD_DEV_TWSI_EXP, 0x20, ADDR7_BIT},
+	{BOARD_DEV_TWSI_EXP, 0x21, ADDR7_BIT},
+	{BOARD_DEV_TWSI_EXP, 0x27, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4C, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4D, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4E, ADDR7_BIT},
+	{BOARD_TWSI_AUDIO_DEC, 0x4A, ADDR7_BIT}
+	};
+
+MV_BOARD_MAC_INFO db88f6281AInfoBoardMacInfo[] =
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+	{
+	{BOARD_MAC_SPEED_AUTO, 0x8},
+	{BOARD_MAC_SPEED_AUTO, 0x9}
+	};
+
+MV_BOARD_MPP_TYPE_INFO db88f6281AInfoBoardMppTypeInfo[] =
+	/* {{MV_BOARD_MPP_TYPE_CLASS	boardMppGroup1,
+ 		MV_BOARD_MPP_TYPE_CLASS	boardMppGroup2}} */
+	{{MV_BOARD_AUTO, MV_BOARD_AUTO}
+	};
+
+MV_BOARD_GPP_INFO db88f6281AInfoBoardGppInfo[] =
+	/* {{MV_BOARD_GPP_CLASS	devClass, MV_U8	gppPinNum}} */
+	{
+	{BOARD_GPP_TSU_DIRCTION, 33}
+	/*muxed with TDM/Audio module via IOexpender
+	{BOARD_GPP_SDIO_DETECT, 38},
+	{BOARD_GPP_USB_VBUS, 49}*/
+	};
+
+MV_DEV_CS_INFO db88f6281AInfoBoardDeCsInfo[] =
+		/*{deviceCS, params, devType, devWidth}*/
+#if defined(MV_NAND) && defined(MV_NAND_BOOT)
+		 {{0, N_A, BOARD_DEV_NAND_FLASH, 8}};	   /* NAND DEV */
+#elif defined(MV_NAND) && defined(MV_SPI_BOOT)
+		 {
+         {0, N_A, BOARD_DEV_NAND_FLASH, 8},	   /* NAND DEV */
+         {1, N_A, BOARD_DEV_SPI_FLASH, 8},	   /* SPI DEV */
+         };
+#else
+	 {{1, N_A, BOARD_DEV_SPI_FLASH, 8}};	   /* SPI DEV */
+#endif
+
+MV_BOARD_MPP_INFO	db88f6281AInfoBoardMppConfigValue[] =
+	{{{
+	DB_88F6281A_MPP0_7,
+	DB_88F6281A_MPP8_15,
+	DB_88F6281A_MPP16_23,
+	DB_88F6281A_MPP24_31,
+	DB_88F6281A_MPP32_39,
+	DB_88F6281A_MPP40_47,
+	DB_88F6281A_MPP48_55
+	}}};
+
+
+MV_BOARD_INFO db88f6281AInfo = {
+	"DB-88F6281A-BP",				/* boardName[MAX_BOARD_NAME_LEN] */
+	DB_88F6281A_BOARD_MPP_GROUP_TYPE_NUM,		/* numBoardMppGroupType */
+	db88f6281AInfoBoardMppTypeInfo,
+	DB_88F6281A_BOARD_MPP_CONFIG_NUM,		/* numBoardMppConfig */
+	db88f6281AInfoBoardMppConfigValue,
+	0,						/* intsGppMaskLow */
+	0,						/* intsGppMaskHigh */
+	DB_88F6281A_BOARD_DEVICE_CONFIG_NUM,		/* numBoardDevIf */
+	db88f6281AInfoBoardDeCsInfo,
+	DB_88F6281A_BOARD_TWSI_DEF_NUM,			/* numBoardTwsiDev */
+	db88f6281AInfoBoardTwsiDev,
+	DB_88F6281A_BOARD_MAC_INFO_NUM,			/* numBoardMacInfo */
+	db88f6281AInfoBoardMacInfo,
+	DB_88F6281A_BOARD_GPP_INFO_NUM,			/* numBoardGppInfo */
+	db88f6281AInfoBoardGppInfo,
+	DB_88F6281A_BOARD_DEBUG_LED_NUM,			/* activeLedsNumber */
+	NULL,
+	0,						/* ledsPolarity */
+	DB_88F6281A_OE_LOW,				/* gppOutEnLow */
+	DB_88F6281A_OE_HIGH,				/* gppOutEnHigh */
+	DB_88F6281A_OE_VAL_LOW,				/* gppOutValLow */
+	DB_88F6281A_OE_VAL_HIGH,				/* gppOutValHigh */
+	0,						/* gppPolarityValLow */
+	BIT6, 						/* gppPolarityValHigh */
+	NULL,						/* pSwitchInfo */
+    DB_88F6281A_BOARD_NAND_READ_PARAMS,
+    DB_88F6281A_BOARD_NAND_WRITE_PARAMS,
+    DB_88F6281A_BOARD_NAND_CONTROL,
+	.portDsaInfo = defaultBoardPortDsaInfo,
+};
+
+
+#define RD_88F6281A_BOARD_TWSI_DEF_NUM		0x2
+#define RD_88F6281A_BOARD_MAC_INFO_NUM		0x2
+#define RD_88F6281A_BOARD_GPP_INFO_NUM		0x5
+#define RD_88F6281A_BOARD_MPP_GROUP_TYPE_NUM	0x1
+#define RD_88F6281A_BOARD_MPP_CONFIG_NUM		0x1
+#if defined(MV_NAND) && defined(MV_NAND_BOOT)
+    #define RD_88F6281A_BOARD_DEVICE_CONFIG_NUM	    0x1
+#elif defined(MV_NAND) && defined(MV_SPI_BOOT)
+    #define RD_88F6281A_BOARD_DEVICE_CONFIG_NUM	    0x2
+#else
+    #define RD_88F6281A_BOARD_DEVICE_CONFIG_NUM	    0x1
+#endif
+#define RD_88F6281A_BOARD_DEBUG_LED_NUM		0x0
+#define RD_88F6281A_BOARD_NAND_READ_PARAMS		    0x000C0282
+#define RD_88F6281A_BOARD_NAND_WRITE_PARAMS		    0x00010305
+#define RD_88F6281A_BOARD_NAND_CONTROL		        0x01c00541
+
+MV_BOARD_MAC_INFO rd88f6281AInfoBoardMacInfo[] =
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+	{{BOARD_MAC_SPEED_1000M, 0xa},
+    {BOARD_MAC_SPEED_AUTO, 0xb}
+	};
+
+MV_BOARD_SWITCH_INFO rd88f6281AInfoBoardSwitchInfo[] =
+    {
+        /* GbE Port #0, one Switch is connected to this port */
+
+        {   .numSwitchesOnPort = 1,
+            .linkStatusIrq = {38, -1},
+            .qdPort = { {0,0,"Port 0"}, {0,1,"Port 1"}, {0,2,"Port 2"}, {0,3,"Port 3"},
+                        {-1,-1,""}, {-1,-1,""}, {-1,-1,""}, {-1,-1,""}, {-1,-1,""}, {-1,-1,""}, {-1,-1,""} },
+            .qdCpuPort = {5, -1},
+            .qdInterconnectPort = {-1, -1},
+            .smiScanMode = 2,
+            .switchSmiAddr = {0x0A, 0x0}
+        },
+
+        /* GbE Port #1, Switch is not connected to this port */
+        { .numSwitchesOnPort = 0 }
+    };
+
+MV_BOARD_TWSI_INFO	rd88f6281AInfoBoardTwsiDev[] =
+	/* {{MV_BOARD_DEV_CLASS	devClass, MV_U8	twsiDevAddr, MV_U8 twsiDevAddrType}} */
+	{
+	{BOARD_DEV_TWSI_EXP, 0xFF, ADDR7_BIT}, /* dummy entry to align with modules indexes */
+	{BOARD_DEV_TWSI_EXP, 0x27, ADDR7_BIT}
+	};
+
+MV_BOARD_MPP_TYPE_INFO rd88f6281AInfoBoardMppTypeInfo[] =
+	{{MV_BOARD_RGMII, MV_BOARD_TDM}
+	};
+
+MV_DEV_CS_INFO rd88f6281AInfoBoardDeCsInfo[] =
+		/*{deviceCS, params, devType, devWidth}*/
+#if defined(MV_NAND) && defined(MV_NAND_BOOT)
+		 {{0, N_A, BOARD_DEV_NAND_FLASH, 8}};	   /* NAND DEV */
+#elif defined(MV_NAND) && defined(MV_SPI_BOOT)
+		 {
+         {0, N_A, BOARD_DEV_NAND_FLASH, 8},	   /* NAND DEV */
+         {1, N_A, BOARD_DEV_SPI_FLASH, 8},	   /* SPI DEV */
+         };
+#else
+		 {{1, N_A, BOARD_DEV_SPI_FLASH, 8}};	   /* SPI DEV */
+#endif
+
+MV_BOARD_GPP_INFO rd88f6281AInfoBoardGppInfo[] =
+	/* {{MV_BOARD_GPP_CLASS	devClass, MV_U8	gppPinNum}} */
+	{{BOARD_GPP_SDIO_DETECT, 28},
+    {BOARD_GPP_USB_OC, 29},
+    {BOARD_GPP_WPS_BUTTON, 35},
+    {BOARD_GPP_MV_SWITCH, 38},
+    {BOARD_GPP_USB_VBUS, 49}
+	};
+
+MV_BOARD_MPP_INFO	rd88f6281AInfoBoardMppConfigValue[] =
+	{{{
+	RD_88F6281A_MPP0_7,
+	RD_88F6281A_MPP8_15,
+	RD_88F6281A_MPP16_23,
+	RD_88F6281A_MPP24_31,
+	RD_88F6281A_MPP32_39,
+	RD_88F6281A_MPP40_47,
+	RD_88F6281A_MPP48_55
+	}}};
+
+MV_BOARD_INFO rd88f6281AInfo = {
+	"RD-88F6281A",				/* boardName[MAX_BOARD_NAME_LEN] */
+	RD_88F6281A_BOARD_MPP_GROUP_TYPE_NUM,		/* numBoardMppGroupType */
+	rd88f6281AInfoBoardMppTypeInfo,
+	RD_88F6281A_BOARD_MPP_CONFIG_NUM,		/* numBoardMppConfig */
+	rd88f6281AInfoBoardMppConfigValue,
+	0,						/* intsGppMaskLow */
+	(1 << 3),					/* intsGppMaskHigh */
+	RD_88F6281A_BOARD_DEVICE_CONFIG_NUM,		/* numBoardDevIf */
+	rd88f6281AInfoBoardDeCsInfo,
+	RD_88F6281A_BOARD_TWSI_DEF_NUM,			/* numBoardTwsiDev */
+	rd88f6281AInfoBoardTwsiDev,
+	RD_88F6281A_BOARD_MAC_INFO_NUM,			/* numBoardMacInfo */
+	rd88f6281AInfoBoardMacInfo,
+	RD_88F6281A_BOARD_GPP_INFO_NUM,			/* numBoardGppInfo */
+	rd88f6281AInfoBoardGppInfo,
+	RD_88F6281A_BOARD_DEBUG_LED_NUM,			/* activeLedsNumber */
+	NULL,
+	0,										/* ledsPolarity */
+	RD_88F6281A_OE_LOW,				/* gppOutEnLow */
+	RD_88F6281A_OE_HIGH,				/* gppOutEnHigh */
+	RD_88F6281A_OE_VAL_LOW,				/* gppOutValLow */
+	RD_88F6281A_OE_VAL_HIGH,				/* gppOutValHigh */
+	0,						/* gppPolarityValLow */
+	BIT6, 						/* gppPolarityValHigh */
+	rd88f6281AInfoBoardSwitchInfo,			/* pSwitchInfo */
+    RD_88F6281A_BOARD_NAND_READ_PARAMS,
+    RD_88F6281A_BOARD_NAND_WRITE_PARAMS,
+    RD_88F6281A_BOARD_NAND_CONTROL,
+	.portDsaInfo = defaultBoardPortDsaInfo,
+};
+
+
+#define DB_88F6192A_BOARD_TWSI_DEF_NUM		    0x7
+#define DB_88F6192A_BOARD_MAC_INFO_NUM		    0x2
+#define DB_88F6192A_BOARD_GPP_INFO_NUM		    0x3
+#define DB_88F6192A_BOARD_MPP_GROUP_TYPE_NUM	0x1
+#define DB_88F6192A_BOARD_MPP_CONFIG_NUM		0x1
+#if defined(MV_NAND) && defined(MV_NAND_BOOT)
+    #define DB_88F6192A_BOARD_DEVICE_CONFIG_NUM	    0x1
+#elif defined(MV_NAND) && defined(MV_SPI_BOOT)
+    #define DB_88F6192A_BOARD_DEVICE_CONFIG_NUM	    0x2
+#else
+    #define DB_88F6192A_BOARD_DEVICE_CONFIG_NUM	    0x1
+#endif
+#define DB_88F6192A_BOARD_DEBUG_LED_NUM		    0x0
+#define DB_88F6192A_BOARD_NAND_READ_PARAMS		    0x000C0282
+#define DB_88F6192A_BOARD_NAND_WRITE_PARAMS		    0x00010305
+#define DB_88F6192A_BOARD_NAND_CONTROL		        0x01c00541
+
+MV_BOARD_TWSI_INFO	db88f6192AInfoBoardTwsiDev[] =
+	/* {{MV_BOARD_DEV_CLASS	devClass, MV_U8	twsiDevAddr, MV_U8 twsiDevAddrType}} */
+	{
+	{BOARD_DEV_TWSI_EXP, 0x20, ADDR7_BIT},
+	{BOARD_DEV_TWSI_EXP, 0x21, ADDR7_BIT},
+	{BOARD_DEV_TWSI_EXP, 0x27, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4C, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4D, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4E, ADDR7_BIT},
+	{BOARD_TWSI_AUDIO_DEC, 0x4A, ADDR7_BIT}
+	};
+
+MV_BOARD_MAC_INFO db88f6192AInfoBoardMacInfo[] =
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+	{
+	{BOARD_MAC_SPEED_AUTO, 0x8},
+	{BOARD_MAC_SPEED_AUTO, 0x9}
+	};
+
+MV_BOARD_MPP_TYPE_INFO db88f6192AInfoBoardMppTypeInfo[] =
+	/* {{MV_BOARD_MPP_TYPE_CLASS	boardMppGroup1,
+ 		MV_BOARD_MPP_TYPE_CLASS	boardMppGroup2}} */
+	{{MV_BOARD_AUTO, MV_BOARD_OTHER}
+	};
+
+MV_DEV_CS_INFO db88f6192AInfoBoardDeCsInfo[] =
+		/*{deviceCS, params, devType, devWidth}*/
+#if defined(MV_NAND) && defined(MV_NAND_BOOT)
+		 {{0, N_A, BOARD_DEV_NAND_FLASH, 8}};	   /* NAND DEV */
+#elif defined(MV_NAND) && defined(MV_SPI_BOOT)
+		 {
+         {0, N_A, BOARD_DEV_NAND_FLASH, 8},	   /* NAND DEV */
+         {1, N_A, BOARD_DEV_SPI_FLASH, 8},	   /* SPI DEV */
+         };
+#else
+		 {{1, N_A, BOARD_DEV_SPI_FLASH, 8}};	   /* SPI DEV */
+#endif
+
+MV_BOARD_GPP_INFO db88f6192AInfoBoardGppInfo[] =
+	/* {{MV_BOARD_GPP_CLASS	devClass, MV_U8	gppPinNum}} */
+	{
+    {BOARD_GPP_SDIO_WP, 20},
+	{BOARD_GPP_USB_VBUS, 22},
+	{BOARD_GPP_SDIO_DETECT, 23},
+	};
+
+MV_BOARD_MPP_INFO	db88f6192AInfoBoardMppConfigValue[] =
+	{{{
+	DB_88F6192A_MPP0_7,
+	DB_88F6192A_MPP8_15,
+	DB_88F6192A_MPP16_23,
+	DB_88F6192A_MPP24_31,
+	DB_88F6192A_MPP32_35
+	}}};
+
+MV_BOARD_INFO db88f6192AInfo = {
+	"DB-88F6192A-BP",				/* boardName[MAX_BOARD_NAME_LEN] */
+	DB_88F6192A_BOARD_MPP_GROUP_TYPE_NUM,		/* numBoardMppGroupType */
+	db88f6192AInfoBoardMppTypeInfo,
+	DB_88F6192A_BOARD_MPP_CONFIG_NUM,		/* numBoardMppConfig */
+	db88f6192AInfoBoardMppConfigValue,
+	0,						/* intsGppMaskLow */
+	(1 << 3),					/* intsGppMaskHigh */
+	DB_88F6192A_BOARD_DEVICE_CONFIG_NUM,		/* numBoardDevIf */
+	db88f6192AInfoBoardDeCsInfo,
+	DB_88F6192A_BOARD_TWSI_DEF_NUM,			/* numBoardTwsiDev */
+	db88f6192AInfoBoardTwsiDev,
+	DB_88F6192A_BOARD_MAC_INFO_NUM,			/* numBoardMacInfo */
+	db88f6192AInfoBoardMacInfo,
+	DB_88F6192A_BOARD_GPP_INFO_NUM,			/* numBoardGppInfo */
+	db88f6192AInfoBoardGppInfo,
+	DB_88F6192A_BOARD_DEBUG_LED_NUM,			/* activeLedsNumber */
+	NULL,
+	0,										/* ledsPolarity */
+	DB_88F6192A_OE_LOW,				/* gppOutEnLow */
+	DB_88F6192A_OE_HIGH,				/* gppOutEnHigh */
+	DB_88F6192A_OE_VAL_LOW,				/* gppOutValLow */
+	DB_88F6192A_OE_VAL_HIGH,				/* gppOutValHigh */
+	0,						/* gppPolarityValLow */
+	0, 						/* gppPolarityValHigh */
+	NULL,						/* pSwitchInfo */
+    DB_88F6192A_BOARD_NAND_READ_PARAMS,
+    DB_88F6192A_BOARD_NAND_WRITE_PARAMS,
+    DB_88F6192A_BOARD_NAND_CONTROL,
+	.portDsaInfo = defaultBoardPortDsaInfo,
+};
+
+MV_BOARD_INFO db88f6701AInfo = {
+	"DB-88F6701A-BP",				/* boardName[MAX_BOARD_NAME_LEN] */
+	DB_88F6192A_BOARD_MPP_GROUP_TYPE_NUM,		/* numBoardMppGroupType */
+	db88f6192AInfoBoardMppTypeInfo,
+	DB_88F6192A_BOARD_MPP_CONFIG_NUM,		/* numBoardMppConfig */
+	db88f6192AInfoBoardMppConfigValue,
+	0,						/* intsGppMaskLow */
+	(1 << 3),					/* intsGppMaskHigh */
+	DB_88F6192A_BOARD_DEVICE_CONFIG_NUM,		/* numBoardDevIf */
+	db88f6192AInfoBoardDeCsInfo,
+	DB_88F6192A_BOARD_TWSI_DEF_NUM,			/* numBoardTwsiDev */
+	db88f6192AInfoBoardTwsiDev,
+	DB_88F6192A_BOARD_MAC_INFO_NUM,			/* numBoardMacInfo */
+	db88f6192AInfoBoardMacInfo,
+	DB_88F6192A_BOARD_GPP_INFO_NUM,			/* numBoardGppInfo */
+	db88f6192AInfoBoardGppInfo,
+	DB_88F6192A_BOARD_DEBUG_LED_NUM,		/* activeLedsNumber */
+	NULL,
+	0,						/* ledsPolarity */
+	DB_88F6192A_OE_LOW,				/* gppOutEnLow */
+	DB_88F6192A_OE_HIGH,				/* gppOutEnHigh */
+	DB_88F6192A_OE_VAL_LOW,				/* gppOutValLow */
+	DB_88F6192A_OE_VAL_HIGH,			/* gppOutValHigh */
+	0,						/* gppPolarityValLow */
+	0, 						/* gppPolarityValHigh */
+	NULL,						/* pSwitchInfo */
+    DB_88F6192A_BOARD_NAND_READ_PARAMS,
+    DB_88F6192A_BOARD_NAND_WRITE_PARAMS,
+    DB_88F6192A_BOARD_NAND_CONTROL,
+	.portDsaInfo = defaultBoardPortDsaInfo,
+};
+
+MV_BOARD_INFO db88f6702AInfo = {
+	"DB-88F6702A-BP",				/* boardName[MAX_BOARD_NAME_LEN] */
+	DB_88F6192A_BOARD_MPP_GROUP_TYPE_NUM,		/* numBoardMppGroupType */
+	db88f6192AInfoBoardMppTypeInfo,
+	DB_88F6192A_BOARD_MPP_CONFIG_NUM,		/* numBoardMppConfig */
+	db88f6192AInfoBoardMppConfigValue,
+	0,						/* intsGppMaskLow */
+	(1 << 3),					/* intsGppMaskHigh */
+	DB_88F6192A_BOARD_DEVICE_CONFIG_NUM,		/* numBoardDevIf */
+	db88f6192AInfoBoardDeCsInfo,
+	DB_88F6192A_BOARD_TWSI_DEF_NUM,			/* numBoardTwsiDev */
+	db88f6192AInfoBoardTwsiDev,
+	DB_88F6192A_BOARD_MAC_INFO_NUM,			/* numBoardMacInfo */
+	db88f6192AInfoBoardMacInfo,
+	DB_88F6192A_BOARD_GPP_INFO_NUM,			/* numBoardGppInfo */
+	db88f6192AInfoBoardGppInfo,
+	DB_88F6192A_BOARD_DEBUG_LED_NUM,		/* activeLedsNumber */
+	NULL,
+	0,						/* ledsPolarity */
+	DB_88F6192A_OE_LOW,				/* gppOutEnLow */
+	DB_88F6192A_OE_HIGH,				/* gppOutEnHigh */
+	DB_88F6192A_OE_VAL_LOW,				/* gppOutValLow */
+	DB_88F6192A_OE_VAL_HIGH,			/* gppOutValHigh */
+	0,						/* gppPolarityValLow */
+	0, 						/* gppPolarityValHigh */
+	NULL,						/* pSwitchInfo */
+    DB_88F6192A_BOARD_NAND_READ_PARAMS,
+    DB_88F6192A_BOARD_NAND_WRITE_PARAMS,
+    DB_88F6192A_BOARD_NAND_CONTROL,
+	.portDsaInfo = defaultBoardPortDsaInfo,
+};
+
+#define DB_88F6190A_BOARD_MAC_INFO_NUM		0x1
+
+MV_BOARD_INFO db88f6190AInfo = {
+	"DB-88F6190A-BP",				/* boardName[MAX_BOARD_NAME_LEN] */
+	DB_88F6192A_BOARD_MPP_GROUP_TYPE_NUM,		/* numBoardMppGroupType */
+	db88f6192AInfoBoardMppTypeInfo,
+	DB_88F6192A_BOARD_MPP_CONFIG_NUM,		/* numBoardMppConfig */
+	db88f6192AInfoBoardMppConfigValue,
+	0,						/* intsGppMaskLow */
+	(1 << 3),					/* intsGppMaskHigh */
+	DB_88F6192A_BOARD_DEVICE_CONFIG_NUM,		/* numBoardDevIf */
+	db88f6192AInfoBoardDeCsInfo,
+	DB_88F6192A_BOARD_TWSI_DEF_NUM,			/* numBoardTwsiDev */
+	db88f6192AInfoBoardTwsiDev,
+	DB_88F6190A_BOARD_MAC_INFO_NUM,			/* numBoardMacInfo */
+	db88f6192AInfoBoardMacInfo,
+	DB_88F6192A_BOARD_GPP_INFO_NUM,			/* numBoardGppInfo */
+	db88f6192AInfoBoardGppInfo,
+	DB_88F6192A_BOARD_DEBUG_LED_NUM,		/* activeLedsNumber */
+	NULL,
+	0,						/* ledsPolarity */
+	DB_88F6192A_OE_LOW,				/* gppOutEnLow */
+	DB_88F6192A_OE_HIGH,				/* gppOutEnHigh */
+	DB_88F6192A_OE_VAL_LOW,				/* gppOutValLow */
+	DB_88F6192A_OE_VAL_HIGH,			/* gppOutValHigh */
+	0,						/* gppPolarityValLow */
+	0, 						/* gppPolarityValHigh */
+	NULL,						/* pSwitchInfo */
+    DB_88F6192A_BOARD_NAND_READ_PARAMS,
+    DB_88F6192A_BOARD_NAND_WRITE_PARAMS,
+    DB_88F6192A_BOARD_NAND_CONTROL,
+	.portDsaInfo = defaultBoardPortDsaInfo,
+};
+
+#define RD_88F6192A_BOARD_TWSI_DEF_NUM		0x0
+#define RD_88F6192A_BOARD_MAC_INFO_NUM		0x1
+#define RD_88F6192A_BOARD_GPP_INFO_NUM		0xE
+#define RD_88F6192A_BOARD_MPP_GROUP_TYPE_NUM	0x1
+#define RD_88F6192A_BOARD_MPP_CONFIG_NUM		0x1
+#define RD_88F6192A_BOARD_DEVICE_CONFIG_NUM	0x1
+#define RD_88F6192A_BOARD_DEBUG_LED_NUM		0x3
+#define RD_88F6192A_BOARD_NAND_READ_PARAMS		    0x000C0282
+#define RD_88F6192A_BOARD_NAND_WRITE_PARAMS		    0x00010305
+#define RD_88F6192A_BOARD_NAND_CONTROL		        0x01c00541
+
+MV_U8	rd88f6192AInfoBoardDebugLedIf[] =
+	{17, 28, 29};
+
+MV_BOARD_MAC_INFO rd88f6192AInfoBoardMacInfo[] =
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+	{{BOARD_MAC_SPEED_AUTO, 0x8}
+	};
+
+MV_BOARD_MPP_TYPE_INFO rd88f6192AInfoBoardMppTypeInfo[] =
+	/* {{MV_BOARD_MPP_TYPE_CLASS	boardMppGroup1,
+ 		MV_BOARD_MPP_TYPE_CLASS	boardMppGroup2}} */
+	{{MV_BOARD_OTHER, MV_BOARD_OTHER}
+	};
+
+MV_DEV_CS_INFO rd88f6192AInfoBoardDeCsInfo[] =
+		/*{deviceCS, params, devType, devWidth}*/
+		 {{1, N_A, BOARD_DEV_SPI_FLASH, 8}};	   /* SPI DEV */
+
+MV_BOARD_GPP_INFO rd88f6192AInfoBoardGppInfo[] =
+	/* {{MV_BOARD_GPP_CLASS	devClass, MV_U8	gppPinNum}} */
+	{
+	{BOARD_GPP_USB_VBUS_EN, 10},
+	{BOARD_GPP_USB_HOST_DEVICE, 11},
+	{BOARD_GPP_RESET, 14},
+	{BOARD_GPP_POWER_ON_LED, 15},
+	{BOARD_GPP_HDD_POWER, 16},
+	{BOARD_GPP_WPS_BUTTON, 24},
+	{BOARD_GPP_TS_BUTTON_C, 25},
+	{BOARD_GPP_USB_VBUS, 26},
+	{BOARD_GPP_USB_OC, 27},
+	{BOARD_GPP_TS_BUTTON_U, 30},
+	{BOARD_GPP_TS_BUTTON_R, 31},
+	{BOARD_GPP_TS_BUTTON_L, 32},
+	{BOARD_GPP_TS_BUTTON_D, 34},
+	{BOARD_GPP_FAN_POWER, 35}
+	};
+
+MV_BOARD_MPP_INFO	rd88f6192AInfoBoardMppConfigValue[] =
+	{{{
+	RD_88F6192A_MPP0_7,
+	RD_88F6192A_MPP8_15,
+	RD_88F6192A_MPP16_23,
+	RD_88F6192A_MPP24_31,
+	RD_88F6192A_MPP32_35
+	}}};
+
+MV_BOARD_INFO rd88f6192AInfo = {
+	"RD-88F6192A-NAS",				/* boardName[MAX_BOARD_NAME_LEN] */
+	RD_88F6192A_BOARD_MPP_GROUP_TYPE_NUM,		/* numBoardMppGroupType */
+	rd88f6192AInfoBoardMppTypeInfo,
+	RD_88F6192A_BOARD_MPP_CONFIG_NUM,		/* numBoardMppConfig */
+	rd88f6192AInfoBoardMppConfigValue,
+	0,						/* intsGppMaskLow */
+	(1 << 3),					/* intsGppMaskHigh */
+	RD_88F6192A_BOARD_DEVICE_CONFIG_NUM,		/* numBoardDevIf */
+	rd88f6192AInfoBoardDeCsInfo,
+	RD_88F6192A_BOARD_TWSI_DEF_NUM,			/* numBoardTwsiDev */
+	NULL,
+	RD_88F6192A_BOARD_MAC_INFO_NUM,			/* numBoardMacInfo */
+	rd88f6192AInfoBoardMacInfo,
+	RD_88F6192A_BOARD_GPP_INFO_NUM,			/* numBoardGppInfo */
+	rd88f6192AInfoBoardGppInfo,
+	RD_88F6192A_BOARD_DEBUG_LED_NUM,			/* activeLedsNumber */
+	rd88f6192AInfoBoardDebugLedIf,
+	0,										/* ledsPolarity */
+	RD_88F6192A_OE_LOW,				/* gppOutEnLow */
+	RD_88F6192A_OE_HIGH,				/* gppOutEnHigh */
+	RD_88F6192A_OE_VAL_LOW,				/* gppOutValLow */
+	RD_88F6192A_OE_VAL_HIGH,				/* gppOutValHigh */
+	0,						/* gppPolarityValLow */
+	0, 						/* gppPolarityValHigh */
+	NULL,						/* pSwitchInfo */
+    RD_88F6192A_BOARD_NAND_READ_PARAMS,
+    RD_88F6192A_BOARD_NAND_WRITE_PARAMS,
+    RD_88F6192A_BOARD_NAND_CONTROL,
+	.portDsaInfo = defaultBoardPortDsaInfo,
+};
+
+MV_BOARD_INFO rd88f6190AInfo = {
+	"RD-88F6190A-NAS",				/* boardName[MAX_BOARD_NAME_LEN] */
+	RD_88F6192A_BOARD_MPP_GROUP_TYPE_NUM,		/* numBoardMppGroupType */
+	rd88f6192AInfoBoardMppTypeInfo,
+	RD_88F6192A_BOARD_MPP_CONFIG_NUM,		/* numBoardMppConfig */
+	rd88f6192AInfoBoardMppConfigValue,
+	0,						/* intsGppMaskLow */
+	(1 << 3),					/* intsGppMaskHigh */
+	RD_88F6192A_BOARD_DEVICE_CONFIG_NUM,		/* numBoardDevIf */
+	rd88f6192AInfoBoardDeCsInfo,
+	RD_88F6192A_BOARD_TWSI_DEF_NUM,			/* numBoardTwsiDev */
+	NULL,
+	RD_88F6192A_BOARD_MAC_INFO_NUM,			/* numBoardMacInfo */
+	rd88f6192AInfoBoardMacInfo,
+	RD_88F6192A_BOARD_GPP_INFO_NUM,			/* numBoardGppInfo */
+	rd88f6192AInfoBoardGppInfo,
+	RD_88F6192A_BOARD_DEBUG_LED_NUM,			/* activeLedsNumber */
+	rd88f6192AInfoBoardDebugLedIf,
+	0,										/* ledsPolarity */
+	RD_88F6192A_OE_LOW,				/* gppOutEnLow */
+	RD_88F6192A_OE_HIGH,				/* gppOutEnHigh */
+	RD_88F6192A_OE_VAL_LOW,				/* gppOutValLow */
+	RD_88F6192A_OE_VAL_HIGH,				/* gppOutValHigh */
+	0,						/* gppPolarityValLow */
+	0, 						/* gppPolarityValHigh */
+	NULL,						/* pSwitchInfo */
+    RD_88F6192A_BOARD_NAND_READ_PARAMS,
+    RD_88F6192A_BOARD_NAND_WRITE_PARAMS,
+    RD_88F6192A_BOARD_NAND_CONTROL,
+	.portDsaInfo = defaultBoardPortDsaInfo,
+};
+
+#define DB_88F6180A_BOARD_TWSI_DEF_NUM		0x5
+#define DB_88F6180A_BOARD_MAC_INFO_NUM		0x1
+#define DB_88F6180A_BOARD_GPP_INFO_NUM		0x0
+#define DB_88F6180A_BOARD_MPP_GROUP_TYPE_NUM	0x2
+#define DB_88F6180A_BOARD_MPP_CONFIG_NUM		0x1
+#define DB_88F6180A_BOARD_DEVICE_CONFIG_NUM	    0x1
+#define DB_88F6180A_BOARD_DEBUG_LED_NUM		0x0
+#define DB_88F6180A_BOARD_NAND_READ_PARAMS		    0x000C0282
+#define DB_88F6180A_BOARD_NAND_WRITE_PARAMS		    0x00010305
+#define DB_88F6180A_BOARD_NAND_CONTROL		        0x01c00541
+
+MV_BOARD_TWSI_INFO	db88f6180AInfoBoardTwsiDev[] =
+	/* {{MV_BOARD_DEV_CLASS	devClass, MV_U8	twsiDevAddr, MV_U8 twsiDevAddrType}} */
+	{
+    {BOARD_DEV_TWSI_EXP, 0x20, ADDR7_BIT},
+    {BOARD_DEV_TWSI_EXP, 0x21, ADDR7_BIT},
+    {BOARD_DEV_TWSI_EXP, 0x27, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4C, ADDR7_BIT},
+	{BOARD_TWSI_AUDIO_DEC, 0x4A, ADDR7_BIT}
+	};
+
+MV_BOARD_MAC_INFO db88f6180AInfoBoardMacInfo[] =
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+	{{BOARD_MAC_SPEED_AUTO, 0x8}
+	};
+
+MV_BOARD_GPP_INFO db88f6180AInfoBoardGppInfo[] =
+	/* {{MV_BOARD_GPP_CLASS	devClass, MV_U8	gppPinNum}} */
+	{
+	/* Muxed with TDM/Audio module via IOexpender
+	{BOARD_GPP_USB_VBUS, 6} */
+	};
+
+MV_BOARD_MPP_TYPE_INFO db88f6180AInfoBoardMppTypeInfo[] =
+	/* {{MV_BOARD_MPP_TYPE_CLASS	boardMppGroup1,
+ 		MV_BOARD_MPP_TYPE_CLASS	boardMppGroup2}} */
+	{{MV_BOARD_OTHER, MV_BOARD_AUTO}
+	};
+
+MV_DEV_CS_INFO db88f6180AInfoBoardDeCsInfo[] =
+		/*{deviceCS, params, devType, devWidth}*/
+#if defined(MV_NAND_BOOT)
+		 {{0, N_A, BOARD_DEV_NAND_FLASH, 8}};	   /* NAND DEV */
+#else
+		 {{1, N_A, BOARD_DEV_SPI_FLASH, 8}};	   /* SPI DEV */
+#endif
+
+MV_BOARD_MPP_INFO	db88f6180AInfoBoardMppConfigValue[] =
+	{{{
+	DB_88F6180A_MPP0_7,
+	DB_88F6180A_MPP8_15,
+    DB_88F6180A_MPP16_23,
+    DB_88F6180A_MPP24_31,
+    DB_88F6180A_MPP32_39,
+    DB_88F6180A_MPP40_44
+	}}};
+
+MV_BOARD_INFO db88f6180AInfo = {
+	"DB-88F6180A-BP",				/* boardName[MAX_BOARD_NAME_LEN] */
+	DB_88F6180A_BOARD_MPP_GROUP_TYPE_NUM,		/* numBoardMppGroupType */
+	db88f6180AInfoBoardMppTypeInfo,
+	DB_88F6180A_BOARD_MPP_CONFIG_NUM,		/* numBoardMppConfig */
+	db88f6180AInfoBoardMppConfigValue,
+	0,						/* intsGppMaskLow */
+	0,					/* intsGppMaskHigh */
+	DB_88F6180A_BOARD_DEVICE_CONFIG_NUM,		/* numBoardDevIf */
+	db88f6180AInfoBoardDeCsInfo,
+	DB_88F6180A_BOARD_TWSI_DEF_NUM,			/* numBoardTwsiDev */
+	db88f6180AInfoBoardTwsiDev,
+	DB_88F6180A_BOARD_MAC_INFO_NUM,			/* numBoardMacInfo */
+	db88f6180AInfoBoardMacInfo,
+	DB_88F6180A_BOARD_GPP_INFO_NUM,			/* numBoardGppInfo */
+	NULL,
+	DB_88F6180A_BOARD_DEBUG_LED_NUM,			/* activeLedsNumber */
+	NULL,
+	0,										/* ledsPolarity */
+	DB_88F6180A_OE_LOW,				/* gppOutEnLow */
+	DB_88F6180A_OE_HIGH,				/* gppOutEnHigh */
+	DB_88F6180A_OE_VAL_LOW,				/* gppOutValLow */
+	DB_88F6180A_OE_VAL_HIGH,				/* gppOutValHigh */
+	0,						/* gppPolarityValLow */
+	0, 						/* gppPolarityValHigh */
+	NULL,						/* pSwitchInfo */
+    DB_88F6180A_BOARD_NAND_READ_PARAMS,
+    DB_88F6180A_BOARD_NAND_WRITE_PARAMS,
+    DB_88F6180A_BOARD_NAND_CONTROL,
+	.portDsaInfo = defaultBoardPortDsaInfo,
+};
+
+
+#define RD_88F6281A_PCAC_BOARD_TWSI_DEF_NUM		0x1
+#define RD_88F6281A_PCAC_BOARD_MAC_INFO_NUM		0x1
+#define RD_88F6281A_PCAC_BOARD_GPP_INFO_NUM		0x0
+#define RD_88F6281A_PCAC_BOARD_MPP_GROUP_TYPE_NUM	0x1
+#define RD_88F6281A_PCAC_BOARD_MPP_CONFIG_NUM		0x1
+#if defined(MV_NAND) && defined(MV_NAND_BOOT)
+    #define RD_88F6281A_PCAC_BOARD_DEVICE_CONFIG_NUM	    0x1
+#elif defined(MV_NAND) && defined(MV_SPI_BOOT)
+    #define RD_88F6281A_PCAC_BOARD_DEVICE_CONFIG_NUM	    0x2
+#else
+    #define RD_88F6281A_PCAC_BOARD_DEVICE_CONFIG_NUM	    0x1
+#endif
+#define RD_88F6281A_PCAC_BOARD_DEBUG_LED_NUM		0x4
+#define RD_88F6281A_PCAC_BOARD_NAND_READ_PARAMS		    0x000C0282
+#define RD_88F6281A_PCAC_BOARD_NAND_WRITE_PARAMS		    0x00010305
+#define RD_88F6281A_PCAC_BOARD_NAND_CONTROL		        0x01c00541
+
+MV_U8	rd88f6281APcacInfoBoardDebugLedIf[] =
+	{38, 39, 40, 41};
+
+MV_BOARD_MAC_INFO rd88f6281APcacInfoBoardMacInfo[] =
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+	{{BOARD_MAC_SPEED_AUTO, 0x8}
+	};
+
+MV_BOARD_TWSI_INFO	rd88f6281APcacInfoBoardTwsiDev[] =
+	/* {{MV_BOARD_DEV_CLASS	devClass, MV_U8	twsiDevAddr, MV_U8 twsiDevAddrType}} */
+	{
+	{BOARD_TWSI_OTHER, 0xa7, ADDR7_BIT}
+	};
+
+MV_BOARD_MPP_TYPE_INFO rd88f6281APcacInfoBoardMppTypeInfo[] =
+	{{MV_BOARD_OTHER, MV_BOARD_OTHER}
+	};
+
+MV_DEV_CS_INFO rd88f6281APcacInfoBoardDeCsInfo[] =
+		/*{deviceCS, params, devType, devWidth}*/
+#if defined(MV_NAND) && defined(MV_NAND_BOOT)
+		 {{0, N_A, BOARD_DEV_NAND_FLASH, 8}};	   /* NAND DEV */
+#elif defined(MV_NAND) && defined(MV_SPI_BOOT)
+		 {
+         {0, N_A, BOARD_DEV_NAND_FLASH, 8},	   /* NAND DEV */
+         {1, N_A, BOARD_DEV_SPI_FLASH, 8},	   /* SPI DEV */
+         };
+#else
+	 {{1, N_A, BOARD_DEV_SPI_FLASH, 8}};	   /* SPI DEV */
+#endif
+
+MV_BOARD_MPP_INFO	rd88f6281APcacInfoBoardMppConfigValue[] =
+	{{{
+	RD_88F6281A_PCAC_MPP0_7,
+	RD_88F6281A_PCAC_MPP8_15,
+	RD_88F6281A_PCAC_MPP16_23,
+	RD_88F6281A_PCAC_MPP24_31,
+	RD_88F6281A_PCAC_MPP32_39,
+	RD_88F6281A_PCAC_MPP40_47,
+	RD_88F6281A_PCAC_MPP48_55
+	}}};
+
+MV_BOARD_INFO rd88f6281APcacInfo = {
+	"RD-88F6281A-PCAC",				/* boardName[MAX_BOARD_NAME_LEN] */
+	RD_88F6281A_PCAC_BOARD_MPP_GROUP_TYPE_NUM,	/* numBoardMppGroupType */
+	rd88f6281APcacInfoBoardMppTypeInfo,
+	RD_88F6281A_PCAC_BOARD_MPP_CONFIG_NUM,		/* numBoardMppConfig */
+	rd88f6281APcacInfoBoardMppConfigValue,
+	0,						/* intsGppMaskLow */
+	(1 << 3),					/* intsGppMaskHigh */
+	RD_88F6281A_PCAC_BOARD_DEVICE_CONFIG_NUM,	/* numBoardDevIf */
+	rd88f6281APcacInfoBoardDeCsInfo,
+	RD_88F6281A_PCAC_BOARD_TWSI_DEF_NUM,		/* numBoardTwsiDev */
+	rd88f6281APcacInfoBoardTwsiDev,
+	RD_88F6281A_PCAC_BOARD_MAC_INFO_NUM,		/* numBoardMacInfo */
+	rd88f6281APcacInfoBoardMacInfo,
+	RD_88F6281A_PCAC_BOARD_GPP_INFO_NUM,		/* numBoardGppInfo */
+	0,
+	RD_88F6281A_PCAC_BOARD_DEBUG_LED_NUM,		/* activeLedsNumber */
+	NULL,
+	0,										/* ledsPolarity */
+	RD_88F6281A_PCAC_OE_LOW,			/* gppOutEnLow */
+	RD_88F6281A_PCAC_OE_HIGH,			/* gppOutEnHigh */
+	RD_88F6281A_PCAC_OE_VAL_LOW,			/* gppOutValLow */
+	RD_88F6281A_PCAC_OE_VAL_HIGH,			/* gppOutValHigh */
+	0,						/* gppPolarityValLow */
+	0, 	 					/* gppPolarityValHigh */
+	NULL,						/* pSwitchInfo */
+    RD_88F6281A_PCAC_BOARD_NAND_READ_PARAMS,
+    RD_88F6281A_PCAC_BOARD_NAND_WRITE_PARAMS,
+    RD_88F6281A_PCAC_BOARD_NAND_CONTROL,
+	.portDsaInfo = defaultBoardPortDsaInfo,
+};
+
+
+#define DB_88F6280A_BOARD_TWSI_DEF_NUM		    0x7
+#define DB_88F6280A_BOARD_MAC_INFO_NUM		    0x1
+#define DB_88F6280A_BOARD_GPP_INFO_NUM		    0x0
+#define DB_88F6280A_BOARD_MPP_CONFIG_NUM		0x1
+#define DB_88F6280A_BOARD_MPP_GROUP_TYPE_NUM	0x1
+#if defined(MV_NAND) && defined(MV_NAND_BOOT)
+    #define DB_88F6280A_BOARD_DEVICE_CONFIG_NUM	    0x1
+#elif defined(MV_NAND) && defined(MV_SPI_BOOT)
+    #define DB_88F6280A_BOARD_DEVICE_CONFIG_NUM	    0x2
+#else
+    #define DB_88F6280A_BOARD_DEVICE_CONFIG_NUM	    0x1
+#endif
+#define DB_88F6280A_BOARD_DEBUG_LED_NUM		    0x0
+#define DB_88F6280A_BOARD_NAND_READ_PARAMS		    0x000C0282
+#define DB_88F6280A_BOARD_NAND_WRITE_PARAMS		    0x00010305
+#define DB_88F6280A_BOARD_NAND_CONTROL		        0x01c00541
+
+
+MV_BOARD_TWSI_INFO	db88f6280AInfoBoardTwsiDev[] =
+	/* {{MV_BOARD_DEV_CLASS	devClass, MV_U8	twsiDevAddr, MV_U8 twsiDevAddrType}} */
+	{
+	{BOARD_DEV_TWSI_EXP, 0x20, ADDR7_BIT},
+	{BOARD_DEV_TWSI_EXP, 0x21, ADDR7_BIT},
+	{BOARD_DEV_TWSI_EXP, 0x27, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4C, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4D, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4E, ADDR7_BIT},
+	{BOARD_TWSI_AUDIO_DEC, 0x4A, ADDR7_BIT}
+	};
+
+MV_BOARD_MAC_INFO db88f6280AInfoBoardMacInfo[] =
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+	{
+	{BOARD_MAC_SPEED_AUTO, 0x8}
+	};
+
+MV_BOARD_MPP_TYPE_INFO db88f6280AInfoBoardMppTypeInfo[] =
+	/* {{MV_BOARD_MPP_TYPE_CLASS	boardMppGroup1,
+ 		MV_BOARD_MPP_TYPE_CLASS	boardMppGroup2}} */
+	{{MV_BOARD_AUTO, MV_BOARD_OTHER}
+	};
+
+MV_DEV_CS_INFO db88f6280AInfoBoardDeCsInfo[] =
+		/*{deviceCS, params, devType, devWidth}*/
+#if defined(MV_NAND) && defined(MV_NAND_BOOT)
+		 {{0, N_A, BOARD_DEV_NAND_FLASH, 8}};	   /* NAND DEV */
+#elif defined(MV_NAND) && defined(MV_SPI_BOOT)
+		 {
+         {0, N_A, BOARD_DEV_NAND_FLASH, 8},	   /* NAND DEV */
+         {1, N_A, BOARD_DEV_SPI_FLASH, 8},	   /* SPI DEV */
+         };
+#else
+	 {{0, N_A, BOARD_DEV_SPI_FLASH, 8}};	   /* SPI DEV */
+#endif
+
+MV_BOARD_MPP_INFO	db88f6280AInfoBoardMppConfigValue[] =
+	{{{
+	DB_88F6280A_MPP0_7,
+	DB_88F6280A_MPP8_15,
+	DB_88F6280A_MPP16_23,
+	DB_88F6280A_MPP24_31,
+	DB_88F6280A_MPP32_39,
+	DB_88F6280A_MPP40_47,
+	DB_88F6280A_MPP48_55
+	}}};
+
+
+MV_BOARD_INFO db88f6280AInfo = {
+	"DB-88F6280A-BP",				/* boardName[MAX_BOARD_NAME_LEN] */
+	DB_88F6280A_BOARD_MPP_GROUP_TYPE_NUM,		/* numBoardMppGroupType */
+	db88f6280AInfoBoardMppTypeInfo,
+	DB_88F6280A_BOARD_MPP_CONFIG_NUM,		/* numBoardMppConfig */
+	db88f6280AInfoBoardMppConfigValue,
+	0,						/* intsGppMaskLow */
+	0,						/* intsGppMaskHigh */
+	DB_88F6280A_BOARD_DEVICE_CONFIG_NUM,		/* numBoardDevIf */
+	db88f6280AInfoBoardDeCsInfo,
+	DB_88F6280A_BOARD_TWSI_DEF_NUM,			/* numBoardTwsiDev */
+	db88f6280AInfoBoardTwsiDev,
+	DB_88F6280A_BOARD_MAC_INFO_NUM,			/* numBoardMacInfo */
+	db88f6280AInfoBoardMacInfo,
+	DB_88F6280A_BOARD_GPP_INFO_NUM,			/* numBoardGppInfo */
+	NULL,
+	DB_88F6280A_BOARD_DEBUG_LED_NUM,			/* activeLedsNumber */
+	NULL,
+	0,						/* ledsPolarity */
+	DB_88F6280A_OE_LOW,				/* gppOutEnLow */
+	DB_88F6280A_OE_HIGH,				/* gppOutEnHigh */
+	DB_88F6280A_OE_VAL_LOW,				/* gppOutValLow */
+	DB_88F6280A_OE_VAL_HIGH,				/* gppOutValHigh */
+	0,						/* gppPolarityValLow */
+	BIT6, 						/* gppPolarityValHigh */
+	NULL,						/* pSwitchInfo */
+    DB_88F6280A_BOARD_NAND_READ_PARAMS,
+    DB_88F6280A_BOARD_NAND_WRITE_PARAMS,
+    DB_88F6280A_BOARD_NAND_CONTROL,
+	.portDsaInfo = defaultBoardPortDsaInfo,
+};
+
+#define RD_88F6282A_BOARD_TWSI_DEF_NUM		0x0
+#define RD_88F6282A_BOARD_MAC_INFO_NUM		0x2
+#define RD_88F6282A_BOARD_GPP_INFO_NUM		0x5
+#define RD_88F6282A_BOARD_MPP_CONFIG_NUM		0x1
+#define RD_88F6282A_BOARD_MPP_GROUP_TYPE_NUM	0x1
+#define RD_88F6282A_BOARD_DEVICE_CONFIG_NUM	0x1
+#define RD_88F6282A_BOARD_NAND_READ_PARAMS	0x000C0282
+#define RD_88F6282A_BOARD_NAND_WRITE_PARAMS	0x00010305
+#define RD_88F6282A_BOARD_NAND_CONTROL		0x01c00541
+
+
+MV_BOARD_TWSI_INFO	rd88f6282aInfoBoardTwsiDev[] =
+	/* {{MV_BOARD_DEV_CLASS	devClass, MV_U8	twsiDevAddr, MV_U8 twsiDevAddrType}} */
+	{
+	};
+
+MV_BOARD_MAC_INFO rd88f6282aInfoBoardMacInfo[] =
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+	{
+	{BOARD_MAC_SPEED_AUTO, 0x0},
+	{BOARD_MAC_SPEED_1000M, 0x10}
+	};
+
+MV_BOARD_MPP_TYPE_INFO rd88f6282aInfoBoardMppTypeInfo[] =
+	/* {{MV_BOARD_MPP_TYPE_CLASS	boardMppGroup1,
+ 		MV_BOARD_MPP_TYPE_CLASS	boardMppGroup2}} */
+	{{MV_BOARD_RGMII, MV_BOARD_TDM}
+	};
+
+MV_BOARD_GPP_INFO rd88f6282aInfoBoardGppInfo[] =
+	/* {{MV_BOARD_GPP_CLASS	devClass, MV_U8	gppPinNum}} */
+	{{BOARD_GPP_WPS_BUTTON, 29},
+	{BOARD_GPP_HDD_POWER, 35},
+    	{BOARD_GPP_FAN_POWER, 34},
+    	{BOARD_GPP_USB_VBUS, 37},
+    	{BOARD_GPP_USB_VBUS_EN, 37}
+	};
+
+MV_DEV_CS_INFO rd88f6282aInfoBoardDeCsInfo[] =
+		/*{deviceCS, params, devType, devWidth}*/
+		 {{0, N_A, BOARD_DEV_NAND_FLASH, 8}};	   /* NAND DEV */
+
+MV_BOARD_MPP_INFO	rd88f6282aInfoBoardMppConfigValue[] =
+	{{{
+	RD_88F6282A_MPP0_7,
+	RD_88F6282A_MPP8_15,
+	RD_88F6282A_MPP16_23,
+	RD_88F6282A_MPP24_31,
+	RD_88F6282A_MPP32_39,
+	RD_88F6282A_MPP40_47,
+	RD_88F6282A_MPP48_55
+	}}};
+
+MV_BOARD_SWITCH_INFO rd88f6282aInfoBoardSwitchInfo[] =
+    {
+        /* GbE Port #0, Switch is not connected to this port */
+        { .numSwitchesOnPort = 0 },
+
+        /* GbE Port #1, one Switch is connected to this port */
+        {   .numSwitchesOnPort = 1,
+            .linkStatusIrq = {38, -1},
+            .qdPort = { {0,0,"Port 0"}, {0,1,"Port 1"}, {0,2,"Port 2"}, {0,3,"Port 3"},
+                        {-1,-1,""}, {-1,-1,""}, {-1,-1,""}, {-1,-1,""}, {-1,-1,""}, {-1,-1,""}, {-1,-1,""} },
+            .qdCpuPort = {5, -1},
+            .qdInterconnectPort = {-1, -1},
+            .smiScanMode = 2,
+            .switchSmiAddr = {0x10, 0x0}
+        }
+    };
+
+MV_BOARD_INFO rd88f6282aInfo = {
+	"RD-88F6282A",                              /* boardName[MAX_BOARD_NAME_LEN] */
+	RD_88F6282A_BOARD_MPP_GROUP_TYPE_NUM,       /* numBoardMppGroupType */
+	rd88f6282aInfoBoardMppTypeInfo,
+	RD_88F6282A_BOARD_MPP_CONFIG_NUM,           /* numBoardMppConfig */
+	rd88f6282aInfoBoardMppConfigValue,
+	0,                                          /* intsGppMaskLow */
+	BIT6,                                       /* intsGppMaskHigh */
+	RD_88F6282A_BOARD_DEVICE_CONFIG_NUM,        /* numBoardDevIf */
+	rd88f6282aInfoBoardDeCsInfo,
+	RD_88F6282A_BOARD_TWSI_DEF_NUM,             /* numBoardTwsiDev */
+	rd88f6282aInfoBoardTwsiDev,
+	RD_88F6282A_BOARD_MAC_INFO_NUM,             /* numBoardMacInfo */
+	rd88f6282aInfoBoardMacInfo,
+	RD_88F6282A_BOARD_GPP_INFO_NUM,             /* numBoardGppInfo */
+	rd88f6282aInfoBoardGppInfo,
+	0,                                          /* activeLedsNumber */
+	NULL,
+	0,                                          /* ledsPolarity */
+	RD_88F6282A_OE_LOW,                         /* gppOutEnLow */
+	RD_88F6282A_OE_HIGH,                        /* gppOutEnHigh */
+	RD_88F6282A_OE_VAL_LOW,                     /* gppOutValLow */
+	RD_88F6282A_OE_VAL_HIGH,                    /* gppOutValHigh */
+	BIT29,                                      /* gppPolarityValLow */
+	BIT6,                                       /* gppPolarityValHigh */
+	rd88f6282aInfoBoardSwitchInfo,              /* pSwitchInfo */
+	RD_88F6282A_BOARD_NAND_READ_PARAMS,
+	RD_88F6282A_BOARD_NAND_WRITE_PARAMS,
+	RD_88F6282A_BOARD_NAND_CONTROL,
+	.portDsaInfo = defaultBoardPortDsaInfo,
+};
+
+#define DB_88F6282A_BOARD_TWSI_DEF_NUM          0x7
+#define DB_88F6282A_BOARD_MAC_INFO_NUM	        0x2
+#define DB_88F6282A_BOARD_GPP_INFO_NUM          0x1
+#define DB_88F6282A_BOARD_MPP_CONFIG_NUM        0x1
+#define DB_88F6282A_BOARD_MPP_GROUP_TYPE_NUM    0x1
+#if defined(MV_NAND) && defined(MV_NAND_BOOT)
+    #define DB_88F6282A_BOARD_DEVICE_CONFIG_NUM 0x1
+#elif defined(MV_NAND) && defined(MV_SPI_BOOT)
+    #define DB_88F6282A_BOARD_DEVICE_CONFIG_NUM 0x2
+#else
+    #define DB_88F6282A_BOARD_DEVICE_CONFIG_NUM 0x1
+#endif
+#define DB_88F6282A_BOARD_DEBUG_LED_NUM	        0x0
+#define DB_88F6282A_BOARD_NAND_READ_PARAMS      0x000C0282
+#define DB_88F6282A_BOARD_NAND_WRITE_PARAMS     0x00010305
+#define DB_88F6282A_BOARD_NAND_CONTROL          0x01c00541
+
+
+MV_BOARD_TWSI_INFO	db88f6282AInfoBoardTwsiDev[] =
+	/* {{MV_BOARD_DEV_CLASS	devClass, MV_U8	twsiDevAddr, MV_U8 twsiDevAddrType}} */
+	{
+	{BOARD_DEV_TWSI_EXP, 0x20, ADDR7_BIT},
+	{BOARD_DEV_TWSI_EXP, 0x21, ADDR7_BIT},
+	{BOARD_DEV_TWSI_EXP, 0x27, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4C, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4D, ADDR7_BIT},
+	{BOARD_DEV_TWSI_SATR, 0x4E, ADDR7_BIT},
+	{BOARD_TWSI_AUDIO_DEC, 0x4A, ADDR7_BIT}
+	};
+
+#ifdef CONFIG_MV_GTW_DSA_SUPPORT
+MV_BOARD_MAC_INFO db88f6282AInfoBoardMacInfo[] =
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+	{
+	{BOARD_MAC_SPEED_AUTO, 0x8},
+	{BOARD_MAC_SPEED_1000M, 0x10}
+	};
+#else
+MV_BOARD_MAC_INFO db88f6282AInfoBoardMacInfo[] =
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+	{
+	{BOARD_MAC_SPEED_AUTO, 0x8},
+	{BOARD_MAC_SPEED_AUTO, 0x9}
+	};
+#endif
+
+MV_BOARD_MPP_TYPE_INFO db88f6282AInfoBoardMppTypeInfo[] =
+	/* {{MV_BOARD_MPP_TYPE_CLASS	boardMppGroup1,
+ 		MV_BOARD_MPP_TYPE_CLASS	boardMppGroup2}} */
+	{{MV_BOARD_AUTO, MV_BOARD_AUTO}
+	};
+
+MV_BOARD_GPP_INFO db88f6282AInfoBoardGppInfo[] =
+	/* {{MV_BOARD_GPP_CLASS	devClass, MV_U8	gppPinNum}} */
+	{
+	{BOARD_GPP_TSU_DIRCTION, 33}
+	/*muxed with TDM/Audio module via IOexpender
+	{BOARD_GPP_SDIO_DETECT, 38},
+	{BOARD_GPP_USB_VBUS, 49}*/
+	};
+
+MV_DEV_CS_INFO db88f6282AInfoBoardDeCsInfo[] =
+		/*{deviceCS, params, devType, devWidth}*/
+#if defined(MV_NAND) && defined(MV_NAND_BOOT)
+		 {{0, N_A, BOARD_DEV_NAND_FLASH, 8}};	   /* NAND DEV */
+#elif defined(MV_NAND) && defined(MV_SPI_BOOT)
+		 {
+         {0, N_A, BOARD_DEV_NAND_FLASH, 8},	   /* NAND DEV */
+         {1, N_A, BOARD_DEV_SPI_FLASH, 8},	   /* SPI DEV */
+         };
+#else
+	 {{1, N_A, BOARD_DEV_SPI_FLASH, 8}};	   /* SPI DEV */
+#endif
+
+
+#ifdef CONFIG_MV_GTW_DSA_SUPPORT
+MV_BOARD_SWITCH_INFO db88f6282AInfoBoardSwitchInfo[] =
+    {
+        /* GbE Port #0, one Switch is connected to this port */
+        { .numSwitchesOnPort = 0 },
+
+        /* GbE Port #1, two Switches are connected to this port */
+        {   .numSwitchesOnPort = 2,
+            .linkStatusIrq = {-1, -1},
+            .qdPort = { {0,0,"Port 0"}, {0,1,"Port 1"}, {0,2,"Port 2"}, {0,3,"Port 3"}, {0,4,"Port 4"},
+                        {1,0,"Port 5"}, {1,1,"Port 6"}, {1,2,"Port 7"}, {1,3,"Port 8"}, {1,4,"Port 9"}, {1,6,"Port 10"} },
+            .qdCpuPort = {5, 5},
+            .qdInterconnectPort = {6, 5},
+            .smiScanMode = 2,
+            .switchSmiAddr = {0x10, 0x11}
+        }
+    };
+#endif /* CONFIG_MV_GTW_DSA_SUPPORT */
+
+MV_BOARD_MPP_INFO	db88f6282AInfoBoardMppConfigValue[] =
+	{{{
+	DB_88F6282A_MPP0_7,
+	DB_88F6282A_MPP8_15,
+	DB_88F6282A_MPP16_23,
+	DB_88F6282A_MPP24_31,
+	DB_88F6282A_MPP32_39,
+	DB_88F6282A_MPP40_47,
+	DB_88F6282A_MPP48_55
+	}}};
+
+MV_PORT_DSA_INFO db88f6282ABoardPortDsaInfo[CONFIG_MV_ETH_PORTS_NUM] =
+{
+	[0] = {
+		.useDsaTag = MV_FALSE,
+		.dsaTagLen = 0,
+	},
+	[1] = {
+		.useDsaTag = MV_TRUE,
+		.dsaTagLen = MV_EDSA_TAG_SIZE,
+	},
+};
+
+MV_BOARD_INFO db88f6282AInfo = {
+	"DB-88F6282A-BP",				/* boardName[MAX_BOARD_NAME_LEN] */
+	DB_88F6282A_BOARD_MPP_GROUP_TYPE_NUM,		/* numBoardMppGroupType */
+	db88f6282AInfoBoardMppTypeInfo,
+	DB_88F6282A_BOARD_MPP_CONFIG_NUM,		/* numBoardMppConfig */
+	db88f6282AInfoBoardMppConfigValue,
+	0,						/* intsGppMaskLow */
+	0,						/* intsGppMaskHigh */
+	DB_88F6282A_BOARD_DEVICE_CONFIG_NUM,		/* numBoardDevIf */
+	db88f6282AInfoBoardDeCsInfo,
+	DB_88F6282A_BOARD_TWSI_DEF_NUM,			/* numBoardTwsiDev */
+	db88f6282AInfoBoardTwsiDev,
+	DB_88F6282A_BOARD_MAC_INFO_NUM,			/* numBoardMacInfo */
+	db88f6282AInfoBoardMacInfo,
+	DB_88F6282A_BOARD_GPP_INFO_NUM,			/* numBoardGppInfo */
+	db88f6282AInfoBoardGppInfo,
+	DB_88F6282A_BOARD_DEBUG_LED_NUM,			/* activeLedsNumber */
+	NULL,
+	0,						/* ledsPolarity */
+	DB_88F6282A_OE_LOW,				/* gppOutEnLow */
+	DB_88F6282A_OE_HIGH,				/* gppOutEnHigh */
+	DB_88F6282A_OE_VAL_LOW,				/* gppOutValLow */
+	DB_88F6282A_OE_VAL_HIGH,				/* gppOutValHigh */
+	0,						/* gppPolarityValLow */
+	BIT6, 						/* gppPolarityValHigh */
+#ifdef CONFIG_MV_GTW_DSA_SUPPORT
+    db88f6282AInfoBoardSwitchInfo,  /* pSwitchInfo */
+#else
+	NULL,						/* pSwitchInfo */
+#endif
+    DB_88F6282A_BOARD_NAND_READ_PARAMS,
+    DB_88F6282A_BOARD_NAND_WRITE_PARAMS,
+    DB_88F6282A_BOARD_NAND_CONTROL,
+	.portDsaInfo = db88f6282ABoardPortDsaInfo,
+};
+
+/*
+ * XCAT board support
+ */
+#define DB_98DX4122_BOARD_PCI_IF_NUM        0x0
+#define DB_98DX4122_BOARD_TWSI_DEF_NUM      0x0
+#define DB_98DX4122_BOARD_MAC_INFO_NUM      0x2
+#define DB_98DX4122_BOARD_GPP_INFO_NUM      0x0
+#define DB_98DX4122_BOARD_MPP_GROUP_TYPE_NUM    0x1
+#define DB_98DX4122_BOARD_MPP_CONFIG_NUM    0x1
+#define DB_98DX4122_BOARD_DEVICE_CONFIG_NUM 0x2
+#define DB_98DX4122_BOARD_DEBUG_LED_NUM     0x0
+
+MV_BOARD_MAC_INFO db98dx4122InfoBoardMacInfo[] =
+/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+{{BOARD_MAC_SPEED_AUTO, 0x8},
+ {BOARD_MAC_SPEED_1000M, 0x8} /*smi addr was not updated. not in use for now*/
+};
+
+MV_BOARD_MPP_TYPE_INFO db98dx4122InfoBoardMppTypeInfo[] =
+    /* {{MV_BOARD_MPP_TYPE_CLASS	boardMppGroup1,
+        MV_BOARD_MPP_TYPE_CLASS	boardMppGroup2}} */
+{{MV_BOARD_OTHER, MV_BOARD_OTHER}};
+
+MV_BOARD_MPP_INFO db98dx4122InfoBoardMppConfigValue[] =
+{{{
+            DB_98DX4122_MPP0_7,
+            DB_98DX4122_MPP8_15,
+            DB_98DX4122_MPP16_23,
+            DB_98DX4122_MPP24_31,
+            DB_98DX4122_MPP32_39,
+            DB_98DX4122_MPP40_47,
+            DB_98DX4122_MPP48_55
+}}};
+
+MV_DEV_CS_INFO db98dx4122InfoBoardDeCsInfo[] =
+{
+    {0, N_A, BOARD_DEV_NAND_FLASH, 8},
+    {1, N_A, BOARD_DEV_SPI_FLASH,  8}
+};
+
+#define DB_98DX4122_OE_LOW                    (~((BIT7)  | (BIT12) | (BIT13) | \
+                                                 (BIT14) | (BIT15) | (BIT17)))
+#define DB_98DX4122_OE_HIGH                     0xFFFE0001
+#define DB_98DX4122_OE_VAL_LOW                  0x0
+#define DB_98DX4122_OE_VAL_HIGH                 0x0
+
+MV_BOARD_INFO xcat98dxInfo = {
+	"DB-98DX",				/* boardName[MAX_BOARD_NAME_LEN] */
+	DB_98DX4122_BOARD_MPP_GROUP_TYPE_NUM,	/* numBoardMppGroupType */
+	db98dx4122InfoBoardMppTypeInfo,
+	DB_98DX4122_BOARD_MPP_CONFIG_NUM,	/* numBoardMppConfig */
+	db98dx4122InfoBoardMppConfigValue,
+	0,					/* intsGppMaskLow */
+	0,					/* intsGppMaskHigh */
+	DB_98DX4122_BOARD_DEVICE_CONFIG_NUM,	/* numBoardDevIf */
+	db98dx4122InfoBoardDeCsInfo,
+	DB_98DX4122_BOARD_TWSI_DEF_NUM,		/* numBoardTwsiDev */
+	NULL,
+	DB_98DX4122_BOARD_MAC_INFO_NUM,		/* numBoardMacInfo */
+	db98dx4122InfoBoardMacInfo,
+	DB_98DX4122_BOARD_GPP_INFO_NUM,		/* numBoardGppInfo */
+	NULL,
+	DB_98DX4122_BOARD_DEBUG_LED_NUM,	/* activeLedsNumber */
+	NULL,
+	N_A,					/* ledsPolarity */
+	DB_98DX4122_OE_LOW,			/* gppOutEnLow */
+	DB_98DX4122_OE_HIGH,			/* gppOutEnHigh */
+	DB_98DX4122_OE_VAL_LOW,			/* gppOutValLow */
+	DB_98DX4122_OE_VAL_HIGH,		/* gppOutValHigh */
+	0,					/* gppPolarityValLow */
+	0x20000,				/* gppPolarityValHigh */
+	NULL,					/* pSwitchInfo */
+	0,					/* not used */
+	0,					/* not used */
+	0,					/* not used */
+	.portDsaInfo = db88f6282ABoardPortDsaInfo,
+};
+
+
+/* 6281 Sheeva Plug*/
+#define SHEEVA_PLUG_BOARD_TWSI_DEF_NUM		        0x0
+#define SHEEVA_PLUG_BOARD_MAC_INFO_NUM		        0x1
+#define SHEEVA_PLUG_BOARD_GPP_INFO_NUM		        0x0
+#define SHEEVA_PLUG_BOARD_MPP_GROUP_TYPE_NUN        0x1
+#define SHEEVA_PLUG_BOARD_MPP_CONFIG_NUM		    0x1
+#define SHEEVA_PLUG_BOARD_DEVICE_CONFIG_NUM	        0x1
+#define SHEEVA_PLUG_BOARD_DEBUG_LED_NUM		        0x1
+#define SHEEVA_PLUG_BOARD_NAND_READ_PARAMS		    0x000E02C2
+#define SHEEVA_PLUG_BOARD_NAND_WRITE_PARAMS		    0x00010305
+#define SHEEVA_PLUG_BOARD_NAND_CONTROL		        0x01c00541
+
+MV_U8	sheevaPlugInfoBoardDebugLedIf[] =
+	{49};
+
+MV_BOARD_MAC_INFO sheevaPlugInfoBoardMacInfo[] =
+    /* {{MV_BOARD_MAC_SPEED	boardMacSpeed,	MV_U8	boardEthSmiAddr}} */
+	{{BOARD_MAC_SPEED_AUTO, 0x0}};
+
+MV_BOARD_TWSI_INFO	sheevaPlugInfoBoardTwsiDev[] =
+	/* {{MV_BOARD_DEV_CLASS	devClass, MV_U8	twsiDevAddr, MV_U8 twsiDevAddrType}} */
+	{{BOARD_TWSI_OTHER, 0x0, ADDR7_BIT}};
+
+MV_BOARD_MPP_TYPE_INFO sheevaPlugInfoBoardMppTypeInfo[] =
+	{{MV_BOARD_OTHER, MV_BOARD_OTHER}
+	};
+
+MV_DEV_CS_INFO sheevaPlugInfoBoardDeCsInfo[] =
+		/*{deviceCS, params, devType, devWidth}*/
+		 {{0, N_A, BOARD_DEV_NAND_FLASH, 8}};	   /* NAND DEV */
+
+MV_BOARD_MPP_INFO	sheevaPlugInfoBoardMppConfigValue[] =
+	{{{
+	RD_SHEEVA_PLUG_MPP0_7,
+	RD_SHEEVA_PLUG_MPP8_15,
+	RD_SHEEVA_PLUG_MPP16_23,
+	RD_SHEEVA_PLUG_MPP24_31,
+	RD_SHEEVA_PLUG_MPP32_39,
+	RD_SHEEVA_PLUG_MPP40_47,
+	RD_SHEEVA_PLUG_MPP48_55
+	}}};
+
+MV_BOARD_INFO sheevaPlugInfo = {
+	"SHEEVA PLUG",				                /* boardName[MAX_BOARD_NAME_LEN] */
+	SHEEVA_PLUG_BOARD_MPP_GROUP_TYPE_NUN,		/* numBoardMppGroupType */
+	sheevaPlugInfoBoardMppTypeInfo,
+	SHEEVA_PLUG_BOARD_MPP_CONFIG_NUM,		    /* numBoardMppConfig */
+	sheevaPlugInfoBoardMppConfigValue,
+	0,						                    /* intsGppMaskLow */
+	0,					                        /* intsGppMaskHigh */
+	SHEEVA_PLUG_BOARD_DEVICE_CONFIG_NUM,		/* numBoardDevIf */
+	sheevaPlugInfoBoardDeCsInfo,
+	SHEEVA_PLUG_BOARD_TWSI_DEF_NUM,			    /* numBoardTwsiDev */
+	sheevaPlugInfoBoardTwsiDev,
+	SHEEVA_PLUG_BOARD_MAC_INFO_NUM,			    /* numBoardMacInfo */
+	sheevaPlugInfoBoardMacInfo,
+	SHEEVA_PLUG_BOARD_GPP_INFO_NUM,			    /* numBoardGppInfo */
+	0,
+	SHEEVA_PLUG_BOARD_DEBUG_LED_NUM,			/* activeLedsNumber */
+	sheevaPlugInfoBoardDebugLedIf,
+	0,										/* ledsPolarity */
+	RD_SHEEVA_PLUG_OE_LOW,				            /* gppOutEnLow */
+	RD_SHEEVA_PLUG_OE_HIGH,				        /* gppOutEnHigh */
+	RD_SHEEVA_PLUG_OE_VAL_LOW,				        /* gppOutValLow */
+	RD_SHEEVA_PLUG_OE_VAL_HIGH,				    /* gppOutValHigh */
+	0,						                    /* gppPolarityValLow */
+	0, 						                    /* gppPolarityValHigh */
+	NULL,						/* pSwitchInfo */
+    SHEEVA_PLUG_BOARD_NAND_READ_PARAMS,
+    SHEEVA_PLUG_BOARD_NAND_WRITE_PARAMS,
+    SHEEVA_PLUG_BOARD_NAND_CONTROL,
+	.portDsaInfo = defaultBoardPortDsaInfo,
+};
+
+/* Customer specific board place holder*/
+
+#define DB_CUSTOMER_BOARD_TWSI_DEF_NUM		        0x0
+#define DB_CUSTOMER_BOARD_MAC_INFO_NUM		        0x0
+#define DB_CUSTOMER_BOARD_GPP_INFO_NUM		        0x0
+#define DB_CUSTOMER_BOARD_MPP_GROUP_TYPE_NUN        0x0
+#define DB_CUSTOMER_BOARD_MPP_CONFIG_NUM		    0x0
+#if defined(MV_NAND) && defined(MV_NAND_BOOT)
+    #define DB_CUSTOMER_BOARD_DEVICE_CONFIG_NUM	    0x0
+#elif defined(MV_NAND) && defined(MV_SPI_BOOT)
+    #define DB_CUSTOMER_BOARD_DEVICE_CONFIG_NUM	    0x0
+#else
+    #define DB_CUSTOMER_BOARD_DEVICE_CONFIG_NUM	    0x0
+#endif
+#define DB_CUSTOMER_BOARD_DEBUG_LED_NUM		0x0
+#define DB_CUSTOMER_BOARD_NAND_READ_PARAMS		    0x000E02C2
+#define DB_CUSTOMER_BOARD_NAND_WRITE_PARAMS		    0x00010305
+#define DB_CUSTOMER_BOARD_NAND_CONTROL		        0x01c00541
+
+MV_U8	dbCustomerInfoBoardDebugLedIf[] =
+	{0};
+
+MV_BOARD_MAC_INFO dbCustomerInfoBoardMacInfo[] =
+    /* {{MV_BOARD_MAC_SPEED	boardMacSpeed,	MV_U8	boardEthSmiAddr}} */
+	{{BOARD_MAC_SPEED_AUTO, 0x0}};
+
+MV_BOARD_TWSI_INFO	dbCustomerInfoBoardTwsiDev[] =
+	/* {{MV_BOARD_DEV_CLASS	devClass, MV_U8	twsiDevAddr, MV_U8 twsiDevAddrType}} */
+	{{BOARD_TWSI_OTHER, 0x0, ADDR7_BIT}};
+
+MV_BOARD_MPP_TYPE_INFO dbCustomerInfoBoardMppTypeInfo[] =
+	{{MV_BOARD_OTHER, MV_BOARD_OTHER}
+	};
+
+MV_DEV_CS_INFO dbCustomerInfoBoardDeCsInfo[] =
+		/*{deviceCS, params, devType, devWidth}*/
+#if defined(MV_NAND) && defined(MV_NAND_BOOT)
+		 {{0, N_A, BOARD_DEV_NAND_FLASH, 8}};	   /* NAND DEV */
+#elif defined(MV_NAND) && defined(MV_SPI_BOOT)
+		 {
+         {0, N_A, BOARD_DEV_NAND_FLASH, 8},	   /* NAND DEV */
+         {2, N_A, BOARD_DEV_SPI_FLASH, 8},	   /* SPI DEV */
+         };
+#else
+		 {{2, N_A, BOARD_DEV_SPI_FLASH, 8}};	   /* SPI DEV */
+#endif
+
+MV_BOARD_MPP_INFO	dbCustomerInfoBoardMppConfigValue[] =
+	{{{
+	DB_CUSTOMER_MPP0_7,
+	DB_CUSTOMER_MPP8_15,
+	DB_CUSTOMER_MPP16_23,
+	DB_CUSTOMER_MPP24_31,
+	DB_CUSTOMER_MPP32_39,
+	DB_CUSTOMER_MPP40_47,
+	DB_CUSTOMER_MPP48_55
+	}}};
+
+MV_BOARD_INFO dbCustomerInfo = {
+	"DB-CUSTOMER",				                /* boardName[MAX_BOARD_NAME_LEN] */
+	DB_CUSTOMER_BOARD_MPP_GROUP_TYPE_NUN,		/* numBoardMppGroupType */
+	dbCustomerInfoBoardMppTypeInfo,
+	DB_CUSTOMER_BOARD_MPP_CONFIG_NUM,		    /* numBoardMppConfig */
+	dbCustomerInfoBoardMppConfigValue,
+	0,			                    /* intsGppMaskLow */
+	0,			                        /* intsGppMaskHigh */
+	DB_CUSTOMER_BOARD_DEVICE_CONFIG_NUM,		/* numBoardDevIf */
+	dbCustomerInfoBoardDeCsInfo,
+	DB_CUSTOMER_BOARD_TWSI_DEF_NUM,			    /* numBoardTwsiDev */
+	dbCustomerInfoBoardTwsiDev,
+	DB_CUSTOMER_BOARD_MAC_INFO_NUM,			    /* numBoardMacInfo */
+	dbCustomerInfoBoardMacInfo,
+	DB_CUSTOMER_BOARD_GPP_INFO_NUM,			    /* numBoardGppInfo */
+	0,
+	DB_CUSTOMER_BOARD_DEBUG_LED_NUM,			/* activeLedsNumber */
+	NULL,
+	0,						/* ledsPolarity */
+	DB_CUSTOMER_OE_LOW,				            /* gppOutEnLow */
+	DB_CUSTOMER_OE_HIGH,				        /* gppOutEnHigh */
+	DB_CUSTOMER_OE_VAL_LOW,				        /* gppOutValLow */
+	DB_CUSTOMER_OE_VAL_HIGH,			    /* gppOutValHigh */
+	0,				                    /* gppPolarityValLow */
+	0, 				                    /* gppPolarityValHigh */
+	NULL,						/* pSwitchInfo */
+    DB_CUSTOMER_BOARD_NAND_READ_PARAMS,
+    DB_CUSTOMER_BOARD_NAND_WRITE_PARAMS,
+    DB_CUSTOMER_BOARD_NAND_CONTROL,
+	.portDsaInfo = defaultBoardPortDsaInfo,
+};
+
+MV_BOARD_INFO*  boardInfoTbl[] =    {
+                    &db88f6281AInfo,
+                    &rd88f6281AInfo,
+                    &db88f6192AInfo,
+                    &rd88f6192AInfo,
+                    &db88f6180AInfo,
+                    &db88f6190AInfo,
+                    &rd88f6190AInfo,
+                    &rd88f6281APcacInfo,
+                    &dbCustomerInfo,
+                    &sheevaPlugInfo,
+                    &db88f6280AInfo,
+                    &db88f6282AInfo,
+                    &rd88f6282aInfo,
+                    &db88f6701AInfo,
+                    &db88f6702AInfo,
+		    &xcat98dxInfo,
+                    };
+
+
diff --git a/arch/arm/mach-kirkwood/kw_family/boardEnv/mvBoardEnvSpec.h b/arch/arm/mach-kirkwood/kw_family/boardEnv/mvBoardEnvSpec.h
new file mode 100644
index 0000000..49f4cf2
--- /dev/null
+++ b/arch/arm/mach-kirkwood/kw_family/boardEnv/mvBoardEnvSpec.h
@@ -0,0 +1,342 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvBoardEnvSpech
+#define __INCmvBoardEnvSpech
+
+#include "mvSysHwConfig.h"
+
+/* For future use */
+#define BD_ID_DATA_START_OFFS		0x0
+#define BD_DETECT_SEQ_OFFS		0x0
+#define BD_SYS_NUM_OFFS			0x4
+#define BD_NAME_OFFS			0x8
+
+/* I2C bus addresses */
+#define MV_BOARD_CTRL_I2C_ADDR			0x0     /* Controller slave addr */
+#define MV_BOARD_CTRL_I2C_ADDR_TYPE 		ADDR7_BIT
+#define MV_BOARD_DIMM0_I2C_ADDR			0x56
+#define MV_BOARD_DIMM0_I2C_ADDR_TYPE 		ADDR7_BIT
+#define MV_BOARD_DIMM1_I2C_ADDR			0x54
+#define MV_BOARD_DIMM1_I2C_ADDR_TYPE 		ADDR7_BIT
+#define MV_BOARD_EEPROM_I2C_ADDR	    	0x51
+#define MV_BOARD_EEPROM_I2C_ADDR_TYPE 		ADDR7_BIT
+#define MV_BOARD_MAIN_EEPROM_I2C_ADDR	   	0x50
+#define MV_BOARD_MAIN_EEPROM_I2C_ADDR_TYPE 	ADDR7_BIT
+#define MV_BOARD_MUX_I2C_ADDR_ENTRY		0x2
+#define MV_BOARD_DIMM_I2C_CHANNEL		0x0
+
+#define BOOT_FLASH_INDEX			0
+#define MAIN_FLASH_INDEX			1
+
+#define BOARD_ETH_START_PORT_NUM	0
+
+/* Supported clocks */
+#define MV_BOARD_TCLK_100MHZ	100000000
+#define MV_BOARD_TCLK_125MHZ	125000000
+#define MV_BOARD_TCLK_133MHZ	133333333
+#define MV_BOARD_TCLK_150MHZ	150000000
+#define MV_BOARD_TCLK_166MHZ	166666667
+#define MV_BOARD_TCLK_200MHZ	200000000
+
+#define MV_BOARD_SYSCLK_100MHZ	100000000
+#define MV_BOARD_SYSCLK_125MHZ	125000000
+#define MV_BOARD_SYSCLK_133MHZ	133333333
+#define MV_BOARD_SYSCLK_150MHZ	150000000
+#define MV_BOARD_SYSCLK_166MHZ	166666667
+#define MV_BOARD_SYSCLK_200MHZ	200000000
+#define MV_BOARD_SYSCLK_233MHZ	233333333
+#define MV_BOARD_SYSCLK_250MHZ	250000000
+#define MV_BOARD_SYSCLK_267MHZ	266666667
+#define MV_BOARD_SYSCLK_300MHZ	300000000
+#define MV_BOARD_SYSCLK_333MHZ	333333334
+#define MV_BOARD_SYSCLK_400MHZ	400000000
+
+#define MV_BOARD_REFCLK_25MHZ	 25000000
+
+/* Board specific */
+/* =============================== */
+
+/* boards ID numbers */
+
+#define BOARD_ID_BASE           		0x0
+
+/* New board ID numbers */
+#define DB_88F6281A_BP_ID			(BOARD_ID_BASE)
+#define DB_88F6281_BP_MLL_ID        1680
+#define RD_88F6281A_ID				(BOARD_ID_BASE+0x1)
+#define RD_88F6281_MLL_ID			1682
+#define DB_88F6192A_BP_ID			(BOARD_ID_BASE+0x2)
+#define RD_88F6192A_ID				(BOARD_ID_BASE+0x3)
+#define RD_88F6192_MLL_ID			1681
+#define DB_88F6180A_BP_ID			(BOARD_ID_BASE+0x4)
+#define DB_88F6190A_BP_ID			(BOARD_ID_BASE+0x5)
+#define RD_88F6190A_ID				(BOARD_ID_BASE+0x6)
+#define RD_88F6281A_PCAC_ID			(BOARD_ID_BASE+0x7)
+#define DB_CUSTOMER_ID			    (BOARD_ID_BASE+0x8)
+#define SHEEVA_PLUG_ID			    (BOARD_ID_BASE+0x9)
+#define DB_88F6280A_BP_ID		    (BOARD_ID_BASE+0xA)
+#define DB_88F6282A_BP_ID		    (BOARD_ID_BASE+0xB)
+#define RD_88F6282A_ID		    		(BOARD_ID_BASE+0xC)
+#define DB_88F6701A_BP_ID			(BOARD_ID_BASE+0xD)
+#define DB_88F6702A_BP_ID			(BOARD_ID_BASE+0xE)
+#define XCAT98DX_ID				(BOARD_ID_BASE+0xF)
+#define MV_MAX_BOARD_ID 			(XCAT98DX_ID + 1)
+
+/* DB-88F6281A-BP */
+#if defined(MV_NAND)
+    #define DB_88F6281A_MPP0_7                   	0x21111111
+#else
+    #define DB_88F6281A_MPP0_7                   	0x21112220
+#endif
+#define DB_88F6281A_MPP8_15                   	0x11113311
+#define DB_88F6281A_MPP16_23                   	0x00551111
+#define DB_88F6281A_MPP24_31                   	0x00000000
+#define DB_88F6281A_MPP32_39                   	0x00000000
+#define DB_88F6281A_MPP40_47                   	0x00000000
+#define DB_88F6281A_MPP48_55                   	0x00000000
+#define DB_88F6281A_OE_LOW                       0x0
+#if defined(MV_TDM_5CHANNELS)
+	#define DB_88F6281A_OE_HIGH		(BIT6)
+#else
+#define DB_88F6281A_OE_HIGH                      0x0
+#endif
+#define DB_88F6281A_OE_VAL_LOW                   0x0
+#define DB_88F6281A_OE_VAL_HIGH                  0x0
+
+
+/* DB-88F6282A-BP */
+#if defined(MV_NAND)
+    #define DB_88F6282A_MPP0_7                   	0x21111111
+#else
+    #define DB_88F6282A_MPP0_7                   	0x21112220
+#endif
+#define DB_88F6282A_MPP8_15                   	0x11113311
+#define DB_88F6282A_MPP16_23                   	0x00551111
+#define DB_88F6282A_MPP24_31                   	0x00000000
+#define DB_88F6282A_MPP32_39                   	0x00000000
+#define DB_88F6282A_MPP40_47                   	0x00000000
+#define DB_88F6282A_MPP48_55                   	0x00000000
+#define DB_88F6282A_OE_LOW                       0x0
+#if defined(MV_TDM_5CHANNELS)
+	#define DB_88F6282A_OE_HIGH		(BIT6)
+#else
+#define DB_88F6282A_OE_HIGH                      0x0
+#endif
+#define DB_88F6282A_OE_VAL_LOW                   0x0
+#define DB_88F6282A_OE_VAL_HIGH                  0x0
+
+/* RD-88F6282 */
+#define RD_88F6282A_MPP0_7                   	0x21111111
+#define RD_88F6282A_MPP8_15                   	0x433B2211
+#define RD_88F6282A_MPP16_23                   	0x33331104
+#define RD_88F6282A_MPP24_31                   	0x33023333
+#define RD_88F6282A_MPP32_39                   	0x40000033
+#define RD_88F6282A_MPP40_47                   	0x22224444
+#define RD_88F6282A_MPP48_55                   	0x00000002
+#define RD_88F6282A_OE_LOW                       ~(BIT17)
+#define RD_88F6282A_OE_HIGH                      ~(BIT2 | BIT3 | BIT4)
+#define RD_88F6282A_OE_VAL_LOW                   BIT17
+#define RD_88F6282A_OE_VAL_HIGH                  (BIT2|BIT3|BIT4)
+
+/* RD-88F6281A */
+#if defined(MV_NAND)
+    #define RD_88F6281A_MPP0_7                   	0x21111111
+#else
+    #define RD_88F6281A_MPP0_7                   	0x21112220
+#endif
+#define RD_88F6281A_MPP8_15                   	0x11113311
+#define RD_88F6281A_MPP16_23                   	0x33331111
+#define RD_88F6281A_MPP24_31                   	0x33003333
+#define RD_88F6281A_MPP32_39                   	0x20440533
+#define RD_88F6281A_MPP40_47                   	0x22202222
+#define RD_88F6281A_MPP48_55                   	0x00000002
+#define RD_88F6281A_OE_LOW                      (BIT28 | BIT29)
+#define RD_88F6281A_OE_HIGH                     (BIT3 | BIT6 | BIT17)
+#define RD_88F6281A_OE_VAL_LOW                   0x0
+#define RD_88F6281A_OE_VAL_HIGH                  0x0
+
+/* DB-88F6192A-BP */
+#if defined(MV_NAND)
+    #define DB_88F6192A_MPP0_7                   	0x21111111
+#else
+    #define DB_88F6192A_MPP0_7                   	0x21112220
+#endif
+#define DB_88F6192A_MPP8_15                   	0x11113311
+#define DB_88F6192A_MPP16_23                   	0x00501111
+#define DB_88F6192A_MPP24_31                   	0x00000000
+#define DB_88F6192A_MPP32_35                   	0x00000000
+#define DB_88F6192A_OE_LOW                       (BIT22 | BIT23)
+#define DB_88F6192A_OE_HIGH                      0x0
+#define DB_88F6192A_OE_VAL_LOW                   0x0
+#define DB_88F6192A_OE_VAL_HIGH                  0x0
+
+/* RD-88F6192A */
+#define RD_88F6192A_MPP0_7                   	0x01222222
+#define RD_88F6192A_MPP8_15                   	0x00000011
+#define RD_88F6192A_MPP16_23                   	0x05550000
+#define RD_88F6192A_MPP24_31                   	0x0
+#define RD_88F6192A_MPP32_35                   	0x0
+#define RD_88F6192A_OE_LOW                      (BIT11 | BIT14 | BIT24 | BIT25 | BIT26 | BIT27 | BIT30 | BIT31)
+#define RD_88F6192A_OE_HIGH                     (BIT0 | BIT2)
+#define RD_88F6192A_OE_VAL_LOW                  0x18400
+#define RD_88F6192A_OE_VAL_HIGH                 0x8
+
+/* DB-88F6180A-BP */
+#if defined(MV_NAND)
+    #define DB_88F6180A_MPP0_7                   	0x21111111
+#else
+    #define DB_88F6180A_MPP0_7                   	0x01112222
+#endif
+#define DB_88F6180A_MPP8_15                   	0x11113311
+#define DB_88F6180A_MPP16_23                   	0x00001111
+#define DB_88F6180A_MPP24_31                   	0x0
+#define DB_88F6180A_MPP32_39                   	0x4444c000
+#define DB_88F6180A_MPP40_44                   	0x00044444
+#define DB_88F6180A_OE_LOW                       0x0
+#define DB_88F6180A_OE_HIGH                      0x0
+#define DB_88F6180A_OE_VAL_LOW                   0x0
+#define DB_88F6180A_OE_VAL_HIGH                  0x0
+
+/* RD-88F6281A_PCAC */
+#define RD_88F6281A_PCAC_MPP0_7                	0x21111111
+#define RD_88F6281A_PCAC_MPP8_15               	0x00003311
+#define RD_88F6281A_PCAC_MPP16_23              	0x00001100
+#define RD_88F6281A_PCAC_MPP24_31              	0x00000000
+#define RD_88F6281A_PCAC_MPP32_39              	0x00000000
+#define RD_88F6281A_PCAC_MPP40_47              	0x00000000
+#define RD_88F6281A_PCAC_MPP48_55              	0x00000000
+#define RD_88F6281A_PCAC_OE_LOW                 0x0
+#define RD_88F6281A_PCAC_OE_HIGH                0x0
+#define RD_88F6281A_PCAC_OE_VAL_LOW             0x0
+#define RD_88F6281A_PCAC_OE_VAL_HIGH            0x0
+
+/* DB-88F6280A-BP */
+#if defined(MV_NAND)
+    #define DB_88F6280A_MPP0_7                 	0x01111111
+#else
+    #define DB_88F6280A_MPP0_7                 	0x01222222
+#endif
+#define DB_88F6280A_MPP8_15                   	0x00300011
+#define DB_88F6280A_MPP16_23                   	0x00001103
+#define DB_88F6280A_MPP24_31                   	0x00000000
+#define DB_88F6280A_MPP32_39                   	0x00000000
+#define DB_88F6280A_MPP40_47                   	0x00000000
+#define DB_88F6280A_MPP48_55                   	0x00000000
+#define DB_88F6280A_OE_LOW                      (0xffffffff)
+#define DB_88F6280A_OE_HIGH                     0x0
+#define DB_88F6280A_OE_VAL_LOW                  0x0
+#define DB_88F6280A_OE_VAL_HIGH                 0x0
+
+
+/* SHEEVA PLUG */
+#define RD_SHEEVA_PLUG_MPP0_7                   0x01111111
+#define RD_SHEEVA_PLUG_MPP8_15                  0x11113322
+#define RD_SHEEVA_PLUG_MPP16_23                 0x00001111
+#define RD_SHEEVA_PLUG_MPP24_31                 0x00100000
+#define RD_SHEEVA_PLUG_MPP32_39                 0x00000000
+#define RD_SHEEVA_PLUG_MPP40_47                 0x00000000
+#define RD_SHEEVA_PLUG_MPP48_55                 0x00000000
+#define RD_SHEEVA_PLUG_OE_LOW                   0x0
+#define RD_SHEEVA_PLUG_OE_HIGH                  0x0
+#define RD_SHEEVA_PLUG_OE_VAL_LOW               (BIT29)
+#define RD_SHEEVA_PLUG_OE_VAL_HIGH              ((~(BIT17 | BIT16 | BIT15)) | BIT14)
+
+/* DB-CUSTOMER */
+#define DB_CUSTOMER_MPP0_7                	    0x21111111
+#define DB_CUSTOMER_MPP8_15               	    0x00003311
+#define DB_CUSTOMER_MPP16_23              	    0x00001100
+#define DB_CUSTOMER_MPP24_31              	    0x00000000
+#define DB_CUSTOMER_MPP32_39              	    0x00000000
+#define DB_CUSTOMER_MPP40_47              	    0x00000000
+#define DB_CUSTOMER_MPP48_55              	    0x00000000
+#define DB_CUSTOMER_OE_LOW                      0x0
+#define DB_CUSTOMER_OE_HIGH                     (~((BIT6) | (BIT7) | (BIT8) | (BIT9)))
+#define DB_CUSTOMER_OE_VAL_LOW                  0x0
+#define DB_CUSTOMER_OE_VAL_HIGH                 0x0
+
+/* xCat98DX */
+#ifdef MV_SPI_BOOT
+#define DB_98DX4122_MPP0_7			0x21112221
+#else
+#define DB_98DX4122_MPP0_7			0x01111111
+#endif
+
+#define DB_98DX4122_MPP8_15			0x03303311
+
+#define DB_98DX4122_MPP16_23			0x00001110
+#define DB_98DX4122_MPP24_31			0x00110000
+#define DB_98DX4122_MPP32_39			0x00001100
+
+#define DB_98DX4122_MPP40_47			0x00000000
+#define DB_98DX4122_MPP48_55			0x00000000
+
+#define DB_98DX4122_OE_LOW			(~((BIT7)  | (BIT12) | (BIT13) | \
+						   (BIT14) | (BIT15) | (BIT17)))
+#define DB_98DX4122_OE_HIGH			0xFFFE0001
+#define DB_98DX4122_OE_VAL_LOW			0x0
+#define DB_98DX4122_OE_VAL_HIGH			0x0
+
+#endif /* __INCmvBoardEnvSpech */
diff --git a/arch/arm/mach-kirkwood/kw_family/cpu/mvCpu.c b/arch/arm/mach-kirkwood/kw_family/cpu/mvCpu.c
new file mode 100644
index 0000000..7556a36
--- /dev/null
+++ b/arch/arm/mach-kirkwood/kw_family/cpu/mvCpu.c
@@ -0,0 +1,202 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "cpu/mvCpu.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvCtrlEnvRegs.h"
+
+#ifdef MV_DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+static MV_U32 mvCpu6180PclkGet(MV_VOID)
+{
+	MV_U32 	tmpPClkRate=0;
+	MV_CPU_ARM_CLK cpu6180_ddr_l2_CLK[] = MV_CPU6180_DDR_L2_CLCK_TBL;
+
+	tmpPClkRate = MV_REG_READ(MPP_SAMPLE_AT_RESET);
+	tmpPClkRate = tmpPClkRate & MSAR_CPUCLCK_MASK_6180;
+	tmpPClkRate = tmpPClkRate >> MSAR_CPUCLCK_OFFS_6180;
+
+	tmpPClkRate = cpu6180_ddr_l2_CLK[tmpPClkRate].cpuClk;
+
+	return tmpPClkRate;
+}
+
+
+MV_U32 mvCpuPclkGet(MV_VOID)
+{
+#if defined(PCLCK_AUTO_DETECT)
+	MV_U32 	tmpPClkRate=0;
+	MV_U32 cpuCLK[] = MV_CPU_CLCK_TBL;
+
+	if(mvCtrlModelGet() == MV_6180_DEV_ID || mvCtrlModelGet() == MV_6280_DEV_ID)
+		return mvCpu6180PclkGet();
+
+	tmpPClkRate = MV_REG_READ(MPP_SAMPLE_AT_RESET);
+	tmpPClkRate = MSAR_CPUCLCK_EXTRACT(tmpPClkRate);
+	tmpPClkRate = cpuCLK[tmpPClkRate];
+
+	return tmpPClkRate;
+#else
+	return MV_DEFAULT_PCLK
+#endif
+}
+
+#define MV_PROC_STR_SIZE 50
+#define CPU_L2_CONFIG_REG			0x20128
+
+static void mvCpuIfGetL2EccMode(MV_8 *buf)
+{
+    MV_U32 regVal = MV_REG_READ(CPU_L2_CONFIG_REG);
+    if (regVal & BIT2)
+	mvOsSPrintf(buf, "L2 ECC Enabled");
+    else
+	mvOsSPrintf(buf, "L2 ECC Disabled");
+}
+
+static void mvCpuIfGetL2Mode(MV_8 *buf)
+{
+    MV_U32 regVal = 0;
+    __asm volatile ("mrc	p15, 1, %0, c15, c1, 0" : "=r" (regVal)); /* Read Marvell extra features register */
+    if (regVal & BIT22)
+	mvOsSPrintf(buf, "L2 Enabled");
+    else
+	mvOsSPrintf(buf, "L2 Disabled");
+}
+
+static void mvCpuIfGetL2PrefetchMode(MV_8 *buf)
+{
+    MV_U32 regVal = 0;
+    __asm volatile ("mrc	p15, 1, %0, c15, c1, 0" : "=r" (regVal)); /* Read Marvell extra features register */
+    if (regVal & BIT24)
+	mvOsSPrintf(buf, "L2 Prefetch Disabled");
+    else
+	mvOsSPrintf(buf, "L2 Prefetch Enabled");
+}
+
+static void mvCpuIfGetWriteAllocMode(MV_8 *buf)
+{
+    MV_U32 regVal = 0;
+    __asm volatile ("mrc	p15, 1, %0, c15, c1, 0" : "=r" (regVal)); /* Read Marvell extra features register */
+    if (regVal & BIT28)
+	mvOsSPrintf(buf, "Write Allocate Enabled");
+    else
+	mvOsSPrintf(buf, "Write Allocate Disabled");
+}
+
+static void mvCpuIfGetCpuStreamMode(MV_8 *buf)
+{
+    MV_U32 regVal = 0;
+    __asm volatile ("mrc	p15, 1, %0, c15, c1, 0" : "=r" (regVal)); /* Read Marvell extra features register */
+    if (regVal & BIT29)
+	mvOsSPrintf(buf, "CPU Streaming Enabled");
+    else
+	mvOsSPrintf(buf, "CPU Streaming Disabled");
+}
+
+static void mvCpuIfPrintCpuRegs(void)
+{
+    MV_U32 regVal = 0;
+
+    __asm volatile ("mrc p15, 1, %0, c15, c1, 0" : "=r" (regVal)); /* Read Marvell extra features register */
+    mvOsPrintf("Extra Feature Reg = 0x%x\n",regVal);
+
+   __asm volatile ("mrc	p15, 0, %0, c1, c0, 0" : "=r" (regVal)); /* Read Control register */
+   mvOsPrintf("Control Reg = 0x%x\n",regVal);
+
+   __asm volatile ("mrc	p15, 0, %0, c0, c0, 0" : "=r" (regVal)); /* Read ID Code register */
+    mvOsPrintf("ID Code Reg = 0x%x\n",regVal);
+
+   __asm volatile ("mrc	p15, 0, %0, c0, c0, 1" : "=r" (regVal)); /* Read Cache Type register */
+   mvOsPrintf("Cache Type Reg = 0x%x\n",regVal);
+
+}
+
+MV_U32 mvCpuIfPrintSystemConfig(MV_8 *buffer, MV_U32 index)
+{
+  MV_U32 count = 0;
+
+  MV_8 L2_ECC_str[MV_PROC_STR_SIZE];
+  MV_8 L2_En_str[MV_PROC_STR_SIZE];
+  MV_8 L2_Prefetch_str[MV_PROC_STR_SIZE];
+  MV_8 Write_Alloc_str[MV_PROC_STR_SIZE];
+  MV_8 Cpu_Stream_str[MV_PROC_STR_SIZE];
+
+  mvCpuIfGetL2Mode(L2_En_str);
+  mvCpuIfGetL2EccMode(L2_ECC_str);
+  mvCpuIfGetL2PrefetchMode(L2_Prefetch_str);
+  mvCpuIfGetWriteAllocMode(Write_Alloc_str);
+  mvCpuIfGetCpuStreamMode(Cpu_Stream_str);
+  mvCpuIfPrintCpuRegs();
+
+  count += mvOsSPrintf(buffer + count + index, "%s\n", L2_En_str);
+  count += mvOsSPrintf(buffer + count + index, "%s\n", L2_ECC_str);
+  count += mvOsSPrintf(buffer + count + index, "%s\n", L2_Prefetch_str);
+  count += mvOsSPrintf(buffer + count + index, "%s\n", Write_Alloc_str);
+  count += mvOsSPrintf(buffer + count + index, "%s\n", Cpu_Stream_str);
+  return count;
+}
diff --git a/arch/arm/mach-kirkwood/kw_family/cpu/mvCpu.h b/arch/arm/mach-kirkwood/kw_family/cpu/mvCpu.h
new file mode 100644
index 0000000..dd4199a
--- /dev/null
+++ b/arch/arm/mach-kirkwood/kw_family/cpu/mvCpu.h
@@ -0,0 +1,84 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvCpuh
+#define __INCmvCpuh
+
+#include "mvCommon.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+
+#ifndef MV_ASMLANGUAGE
+typedef struct _mvCpuArmClk
+{
+	MV_U32	      cpuClk;	  /* CPU clock in MHz */
+	MV_U32	      ddrClk;	  /* DDR clock in MHz */
+	MV_U32	      l2Clk;	  /* CPU DDR clock ratio */
+}MV_CPU_ARM_CLK;
+
+MV_U32 mvCpuPclkGet(MV_VOID);
+MV_U32 mvCpuL2ClkGet(MV_VOID);
+MV_U32 mvCpuIfPrintSystemConfig(MV_8 *buffer, MV_U32 index);
+#endif /* MV_ASMLANGUAGE */
+
+#endif /* __INCmvCpuh */
diff --git a/arch/arm/mach-kirkwood/kw_family/ctrlEnv/mvCtrlEnvLib.c b/arch/arm/mach-kirkwood/kw_family/ctrlEnv/mvCtrlEnvLib.c
new file mode 100644
index 0000000..152bff3
--- /dev/null
+++ b/arch/arm/mach-kirkwood/kw_family/ctrlEnv/mvCtrlEnvLib.c
@@ -0,0 +1,635 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvCtrlEnvLib.h"
+#include "mvDeviceId.h"
+
+#ifdef MV_DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+/*******************************************************************************
+* mvCtrlEnvInit - Initialize Marvell controller environment.
+*
+* DESCRIPTION:
+*       This function get environment information and initialize controller
+*       internal/external environment. For example
+*       1) MPP settings according to board MPP macros.
+*		NOTE: It is the user responsibility to shut down all DMA channels
+*		in device and disable controller sub units interrupts during
+*		boot process.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS mvCtrlEnvInit(MV_VOID)
+{
+    	MV_U32 mppGroup;
+	MV_U32 devId;
+	MV_U32 boardId;
+	MV_U32 i;
+	MV_U32 maxMppGrp = 1;
+	MV_U32 mppVal = 0;
+	MV_U32 bootVal = 0;
+	MV_U32 mppGroupType = 0;
+	MV_U32 mppGroup1[][3] = MPP_GROUP_1_TYPE;
+	MV_U32 mppGroup2[][3] = MPP_GROUP_2_TYPE;
+
+	devId = mvCtrlModelGet();
+	boardId= mvBoardIdGet();
+
+	switch(devId){
+        case MV_6281_DEV_ID:
+            maxMppGrp = MV_6281_MPP_MAX_GROUP;
+            break;
+        case MV_6282_DEV_ID:
+            maxMppGrp = MV_6282_MPP_MAX_GROUP;
+            break;
+        case MV_6280_DEV_ID:
+            maxMppGrp = MV_6280_MPP_MAX_GROUP;
+            break;
+        case MV_6192_DEV_ID:
+        case MV_6701_DEV_ID:
+        case MV_6702_DEV_ID:
+            maxMppGrp = MV_6192_MPP_MAX_GROUP;
+            break;
+        case MV_6190_DEV_ID:
+            maxMppGrp = MV_6190_MPP_MAX_GROUP;
+            break;
+        case MV_6180_DEV_ID:
+            maxMppGrp = MV_6180_MPP_MAX_GROUP;
+            break;
+	}
+
+	/* MPP Init */
+	/* We split mpp init to 3 phases:
+	 * 1. We init mpp[19:0] from the board info. mpp[23:20] will be over write
+	 * in phase 2.
+	 * 2. We detect the mpp group type and according the mpp values [35:20].
+	 * 3. We detect the mpp group type and according the mpp values [49:36].
+	 */
+	/* Mpp phase 1 mpp[19:0] */
+	/* Read MPP group from board level and assign to MPP register */
+	for (mppGroup = 0; mppGroup < 3; mppGroup++)
+	{
+		mppVal = mvBoardMppGet(mppGroup);
+		if (mppGroup == 0)
+		{
+		    bootVal = MV_REG_READ(mvCtrlMppRegGet(mppGroup));
+		    if (mvCtrlIsBootFromSPI())
+		    {
+			mppVal &= ~0xffff;
+			bootVal &= 0xffff;
+			mppVal |= bootVal;
+		    }
+		    else if (mvCtrlIsBootFromSPIUseNAND())
+		    {
+			mppVal &= ~0xf0000000;
+			bootVal &= 0xf0000000;
+			mppVal |= bootVal;
+		    }
+		    else if (mvCtrlIsBootFromNAND())
+		    {
+			mppVal &= ~0xffffff;
+			bootVal &= 0xffffff;
+			mppVal |= bootVal;
+		    }
+		}
+
+		if (mppGroup == 2)
+		{
+		    bootVal = MV_REG_READ(mvCtrlMppRegGet(mppGroup));
+		    if (mvCtrlIsBootFromNAND())
+		    {
+			mppVal &= ~0xff00;
+			bootVal &= 0xff00;
+			mppVal |= bootVal;
+		    }
+		}
+
+		MV_REG_WRITE(mvCtrlMppRegGet(mppGroup), mppVal);
+	}
+
+	/* Identify MPPs group */
+	mvBoardMppGroupIdUpdate();
+
+	/* Update MPPs mux relevent only on Marvell DB */
+	if ((boardId == DB_88F6281A_BP_ID) ||
+        (boardId == DB_88F6282A_BP_ID) ||
+		(boardId == DB_88F6180A_BP_ID))
+		mvBoardMppMuxSet();
+
+	mppGroupType = mvBoardMppGroupTypeGet(MV_BOARD_MPP_GROUP_1);
+
+	/* Mpp phase 2 */
+	/* Read MPP group from board level and assign to MPP register */
+    if (devId != MV_6180_DEV_ID && devId != MV_6280_DEV_ID)
+    {
+        i = 0;
+    	for (mppGroup = 2; mppGroup < 5; mppGroup++)
+    	{
+    		if ((mppGroupType == MV_BOARD_OTHER) ||
+    			(boardId == RD_88F6281A_ID) ||
+    			(boardId == RD_88F6282A_ID) ||
+    			(boardId == RD_88F6192A_ID) ||
+                (boardId == RD_88F6190A_ID) ||
+                (boardId == RD_88F6281A_PCAC_ID) ||
+                (boardId == SHEEVA_PLUG_ID))
+    			mppVal = mvBoardMppGet(mppGroup);
+    		else
+    		{
+    			mppVal = mppGroup1[mppGroupType][i];
+    			i++;
+    		}
+
+    		/* Group 2 is shared mpp[23:16] */
+    		if (mppGroup == 2)
+    		{
+                bootVal = MV_REG_READ(mvCtrlMppRegGet(mppGroup));
+    			mppVal &= ~0xffff;
+    			bootVal &= 0xffff;
+    			mppVal |= bootVal;
+    		}
+
+    		MV_REG_WRITE(mvCtrlMppRegGet(mppGroup), mppVal);
+    	}
+    }
+
+        if ((devId == MV_6192_DEV_ID) || (devId == MV_6190_DEV_ID) ||
+            (devId == MV_6701_DEV_ID) || (devId == MV_6702_DEV_ID))
+		return MV_OK;
+
+	/* Mpp phase 3 */
+	mppGroupType = mvBoardMppGroupTypeGet(MV_BOARD_MPP_GROUP_2);
+	/* Read MPP group from board level and assign to MPP register */
+	i = 0;
+	for (mppGroup = 4; mppGroup < 7; mppGroup++)
+	{
+		if ((mppGroupType == MV_BOARD_OTHER) ||
+			(boardId == RD_88F6281A_ID) ||
+			(boardId == RD_88F6282A_ID) ||
+            (boardId == RD_88F6281A_PCAC_ID) ||
+            (boardId == SHEEVA_PLUG_ID))
+			mppVal = mvBoardMppGet(mppGroup);
+		else
+		{
+			mppVal = mppGroup2[mppGroupType][i];
+			i++;
+		}
+
+		/* Group 4 is shared mpp[35:32] */
+		if (mppGroup == 4)
+		{
+            bootVal = MV_REG_READ(mvCtrlMppRegGet(mppGroup));
+			mppVal &= ~0xffff;
+			bootVal &= 0xffff;
+			mppVal |= bootVal;
+		}
+
+		MV_REG_WRITE(mvCtrlMppRegGet(mppGroup), mppVal);
+	}
+
+    /* Update SSCG configuration register*/
+    if (mvBoardIdGet() == DB_88F6281A_BP_ID ||
+        mvBoardIdGet() == DB_88F6282A_BP_ID ||
+        mvBoardIdGet() == DB_88F6192A_BP_ID ||
+        mvBoardIdGet() == DB_88F6701A_BP_ID ||
+        mvBoardIdGet() == DB_88F6702A_BP_ID ||
+        mvBoardIdGet() == DB_88F6190A_BP_ID ||
+        mvBoardIdGet() == DB_88F6180A_BP_ID ||
+        mvBoardIdGet() == DB_88F6280A_BP_ID)
+        MV_REG_WRITE(0x100d8, 0x53);
+
+    return MV_OK;
+}
+
+/*******************************************************************************
+* mvCtrlMppRegGet - return reg address of mpp group
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       mppGroup - MPP group.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_U32 - Register address.
+*
+*******************************************************************************/
+MV_U32 mvCtrlMppRegGet(MV_U32 mppGroup)
+{
+        MV_U32 ret;
+
+        switch(mppGroup){
+                case (0):       ret = MPP_CONTROL_REG0;
+                                break;
+                case (1):       ret = MPP_CONTROL_REG1;
+                                break;
+                case (2):       ret = MPP_CONTROL_REG2;
+                                break;
+                case (3):       ret = MPP_CONTROL_REG3;
+                                break;
+                case (4):       ret = MPP_CONTROL_REG4;
+                                break;
+                case (5):       ret = MPP_CONTROL_REG5;
+                                break;
+                case (6):       ret = MPP_CONTROL_REG6;
+                                break;
+                default:        ret = MPP_CONTROL_REG0;
+                                break;
+        }
+        return ret;
+}
+
+#if defined(MV_INCLUDE_GIG_ETH)
+/*******************************************************************************
+* mvCtrlEthMaxPortGet - Get Marvell controller number of etherent ports.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of etherent port.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of etherent port.
+*
+*******************************************************************************/
+MV_U32 mvCtrlEthMaxPortGet(MV_VOID)
+{
+	MV_U32 devId;
+
+	devId = mvCtrlModelGet();
+
+	switch(devId){
+        case MV_6281_DEV_ID:
+            return MV_6281_ETH_MAX_PORTS;
+            break;
+        case MV_6282_DEV_ID:
+            return MV_6282_ETH_MAX_PORTS;
+            break;
+        case MV_6280_DEV_ID:
+            return MV_6280_ETH_MAX_PORTS;
+            break;
+        case MV_6192_DEV_ID:
+	case MV_6701_DEV_ID:
+	case MV_6702_DEV_ID:
+            return MV_6192_ETH_MAX_PORTS;
+            break;
+        case MV_6190_DEV_ID:
+            return MV_6190_ETH_MAX_PORTS;
+            break;
+        case MV_6180_DEV_ID:
+            return MV_6180_ETH_MAX_PORTS;
+            break;
+	}
+	return 0;
+}
+#endif
+
+#if defined(MV_INCLUDE_TDM)
+/*******************************************************************************
+* mvCtrlTdmSupport - Return if this controller has integrated TDM flash support
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if TDM is supported and MV_FALSE otherwise
+*
+*******************************************************************************/
+MV_U32	  mvCtrlTdmSupport(MV_VOID)
+{
+	MV_U32 devId;
+
+	devId = mvCtrlModelGet();
+
+	switch(devId){
+		case MV_6281_DEV_ID:
+			return MV_6281_TDM;
+			break;
+        case MV_6282_DEV_ID:
+            return MV_6282_TDM;
+            break;
+        case MV_6280_DEV_ID:
+            return MV_6280_TDM;
+            break;
+		case MV_6192_DEV_ID:
+	case MV_6701_DEV_ID:
+	case MV_6702_DEV_ID:
+			return MV_6192_TDM;
+			break;
+        case MV_6190_DEV_ID:
+            return MV_6190_TDM;
+            break;
+		case MV_6180_DEV_ID:
+			return MV_6180_TDM;
+			break;
+	}
+	return 0;
+
+}
+#endif
+
+void kirkwood_pcie_id(u32 *dev, u32 *rev);
+
+MV_U16 mvCtrlModelGet(MV_VOID)
+{
+	u32 dev, rev;
+	kirkwood_pcie_id(&dev, &rev);
+	return dev;
+}
+
+MV_U8 mvCtrlRevGet(MV_VOID)
+{
+	u32 dev, rev;
+	kirkwood_pcie_id(&dev, &rev);
+	return rev;
+}
+
+MV_U32	mvCtrlModelRevGet(MV_VOID)
+{
+	return ((mvCtrlModelGet() << 16) | mvCtrlRevGet());
+}
+
+static const char* cntrlName[] = TARGETS_NAME_ARRAY;
+
+/*******************************************************************************
+* mvCtrlTargetNameGet - Get Marvell controller target name
+*
+* DESCRIPTION:
+*       This function convert the trget enumeration to string.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Target name (const MV_8 *)
+*******************************************************************************/
+const MV_8* mvCtrlTargetNameGet( MV_TARGET target )
+{
+
+	if (target >= MAX_TARGETS)
+	{
+		return "target unknown";
+	}
+
+	return cntrlName[target];
+}
+
+MV_BOOL	  mvCtrlIsBootFromSPI(MV_VOID)
+{
+    MV_U32 satr = 0;
+    satr = MV_REG_READ(MPP_SAMPLE_AT_RESET);
+    if(mvCtrlModelGet() == MV_6180_DEV_ID || mvCtrlModelGet() == MV_6280_DEV_ID)
+    {
+        if (MSAR_BOOT_MODE_6180(satr) == MSAR_BOOT_SPI_WITH_BOOTROM_6180)
+            return MV_TRUE;
+        else
+            return MV_FALSE;
+    }
+    satr = satr & MSAR_BOOT_MODE_MASK;
+    if (satr == MSAR_BOOT_SPI_WITH_BOOTROM)
+        return MV_TRUE;
+    else
+        return MV_FALSE;
+}
+
+MV_BOOL	  mvCtrlIsBootFromSPIUseNAND(MV_VOID)
+{
+    MV_U32 satr = 0;
+    if(mvCtrlModelGet() == MV_6180_DEV_ID || mvCtrlModelGet() == MV_6280_DEV_ID)
+        return MV_FALSE;
+    satr = MV_REG_READ(MPP_SAMPLE_AT_RESET);
+    satr = satr & MSAR_BOOT_MODE_MASK;
+
+    if (satr == MSAR_BOOT_SPI_USE_NAND_WITH_BOOTROM)
+        return MV_TRUE;
+    else
+        return MV_FALSE;
+}
+
+MV_BOOL	  mvCtrlIsBootFromNAND(MV_VOID)
+{
+    MV_U32 satr = 0;
+    satr = MV_REG_READ(MPP_SAMPLE_AT_RESET);
+    if(mvCtrlModelGet() == MV_6180_DEV_ID || mvCtrlModelGet() == MV_6280_DEV_ID)
+    {
+        if (MSAR_BOOT_MODE_6180(satr) == MSAR_BOOT_NAND_WITH_BOOTROM_6180)
+            return MV_TRUE;
+        else
+            return MV_FALSE;
+    }
+    satr = satr & MSAR_BOOT_MODE_MASK;
+    if ((satr == MSAR_BOOT_NAND_WITH_BOOTROM))
+        return MV_TRUE;
+    else
+        return MV_FALSE;
+}
+
+#if defined(MV_INCLUDE_CLK_PWR_CNTRL)
+/*******************************************************************************
+* mvCtrlPwrClckGet - Get Power State of specific Unit
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+******************************************************************************/
+MV_BOOL		mvCtrlPwrClckGet(MV_UNIT_ID unitId, MV_U32 index)
+{
+	MV_U32 reg = MV_REG_READ(POWER_MNG_CTRL_REG);
+	MV_BOOL state = MV_TRUE;
+
+	switch (unitId)
+    {
+#if defined(MV_INCLUDE_GIG_ETH)
+	case ETH_GIG_UNIT_ID:
+		if ((reg & PMC_GESTOPCLOCK_MASK(index)) == PMC_GESTOPCLOCK_STOP(index))
+		{
+			state = MV_FALSE;
+		}
+		else state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_CESA)
+	case CESA_UNIT_ID:
+		if ((reg & PMC_SESTOPCLOCK_MASK) == PMC_SESTOPCLOCK_STOP)
+		{
+			state = MV_FALSE;
+		}
+		else state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_TS)
+	case TS_UNIT_ID:
+		if ((reg & PMC_TSSTOPCLOCK_MASK) == PMC_TSSTOPCLOCK_STOP)
+		{
+			state = MV_FALSE;
+		}
+		else state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_TDM)
+	case TDM_UNIT_ID:
+		if ((reg & PMC_TDMSTOPCLOCK_MASK) == PMC_TDMSTOPCLOCK_STOP)
+		{
+			state = MV_FALSE;
+		}
+		else state = MV_TRUE;
+		break;
+#endif
+
+	default:
+		state = MV_TRUE;
+		break;
+	}
+
+	return state;
+}
+
+#else
+MV_BOOL	  mvCtrlPwrClckGet(MV_UNIT_ID unitId, MV_U32 index) {return MV_TRUE;}
+#endif /* #if defined(MV_INCLUDE_CLK_PWR_CNTRL) */
+
+
+/*******************************************************************************
+* mvMPPConfigToSPI - Change MPP[3:0] configuration to SPI mode
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+******************************************************************************/
+MV_VOID   mvMPPConfigToSPI(MV_VOID)
+{
+	MV_U32 mppVal = 0;
+	MV_U32 bootVal = 0;
+
+    if(!mvCtrlIsBootFromSPIUseNAND())
+        return;
+    mppVal = 0x00002220; /* Set MPP [3:1] to SPI mode */
+    bootVal = MV_REG_READ(mvCtrlMppRegGet(0));
+    bootVal &= 0xffff000f;
+        mppVal |= bootVal;
+
+    MV_REG_WRITE(mvCtrlMppRegGet(0), mppVal);
+}
+
+
+/*******************************************************************************
+* mvMPPConfigToDefault - Change MPP[7:0] configuration to default configuration
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+******************************************************************************/
+MV_VOID mvMPPConfigToDefault(MV_VOID)
+{
+	MV_U32 mppVal = 0;
+	MV_U32 bootVal = 0;
+
+    if(!mvCtrlIsBootFromSPIUseNAND())
+        return;
+    mppVal = mvBoardMppGet(0);
+    bootVal = MV_REG_READ(mvCtrlMppRegGet(0));
+    mppVal &= ~0xffff000f;
+    bootVal &= 0xffff000f;
+        mppVal |= bootVal;
+
+    MV_REG_WRITE(mvCtrlMppRegGet(0), mppVal);
+}
diff --git a/arch/arm/mach-kirkwood/kw_family/ctrlEnv/mvCtrlEnvLib.h b/arch/arm/mach-kirkwood/kw_family/ctrlEnv/mvCtrlEnvLib.h
new file mode 100644
index 0000000..9f91bdc
--- /dev/null
+++ b/arch/arm/mach-kirkwood/kw_family/ctrlEnv/mvCtrlEnvLib.h
@@ -0,0 +1,102 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvCtrlEnvLibh
+#define __INCmvCtrlEnvLibh
+
+#include "mvSysHwConfig.h"
+#include "mvCommon.h"
+#include "mvTypes.h"
+#include "mvOs.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ctrlEnv/mvCtrlEnvRegs.h"
+
+MV_STATUS mvCtrlEnvInit(MV_VOID);
+MV_U32    mvCtrlMppRegGet(MV_U32 mppGroup);
+
+#define   mvCtrlPciIfMaxIfGet()	(0)
+
+#if defined(MV_INCLUDE_GIG_ETH)
+MV_U32	  mvCtrlEthMaxPortGet(MV_VOID);
+#endif
+#if defined(MV_INCLUDE_USB)
+MV_U32 	  mvCtrlUsbMaxGet(MV_VOID);
+#endif
+#if defined(MV_INCLUDE_TDM)
+MV_U32	  mvCtrlTdmSupport(MV_VOID);
+#endif
+
+MV_U16    mvCtrlModelGet(MV_VOID);
+MV_U8     mvCtrlRevGet(MV_VOID);
+MV_U32    mvCtrlModelRevGet(MV_VOID);
+const MV_8* mvCtrlTargetNameGet(MV_TARGET target);
+MV_BOOL	  mvCtrlPwrClckGet(MV_UNIT_ID unitId, MV_U32 index);
+MV_BOOL	  mvCtrlIsBootFromSPI(MV_VOID);
+MV_BOOL	  mvCtrlIsBootFromSPIUseNAND(MV_VOID);
+MV_BOOL	  mvCtrlIsBootFromNAND(MV_VOID);
+MV_VOID   mvMPPConfigToSPI(MV_VOID);
+MV_VOID   mvMPPConfigToDefault(MV_VOID);
+
+#endif /* __INCmvCtrlEnvLibh */
diff --git a/arch/arm/mach-kirkwood/kw_family/ctrlEnv/mvCtrlEnvRegs.h b/arch/arm/mach-kirkwood/kw_family/ctrlEnv/mvCtrlEnvRegs.h
new file mode 100644
index 0000000..984fb88
--- /dev/null
+++ b/arch/arm/mach-kirkwood/kw_family/ctrlEnv/mvCtrlEnvRegs.h
@@ -0,0 +1,346 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+        this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvCtrlEnvRegsh
+#define __INCmvCtrlEnvRegsh
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* Controller revision info */
+#define PCCRIR_REVID_OFFS				    0		/* Revision ID */
+#define PCCRIR_REVID_MASK				    (0xff << PCCRIR_REVID_OFFS)
+
+/* Controler environment registers offsets */
+
+/* Power Managment Control */
+#define POWER_MNG_MEM_CTRL_REG			0x20118
+
+#define PMC_GESTOPMEM_OFFS(port)		((port)? 13 : 0)
+#define PMC_GESTOPMEM_MASK(port)		(1 << PMC_GESTOPMEM_OFFS(port))
+#define PMC_GESTOPMEM_EN(port)			(0 << PMC_GESTOPMEM_OFFS(port))
+#define PMC_GESTOPMEM_STOP(port)		(1 << PMC_GESTOPMEM_OFFS(port))
+
+#define PMC_USBSTOPMEM_OFFS			2
+#define PMC_USBSTOPMEM_MASK			(1 << PMC_USBSTOPMEM_OFFS)
+#define PMC_USBSTOPMEM_EN			(0 << PMC_USBSTOPMEM_OFFS)
+#define PMC_USBSTOPMEM_STOP			(1 << PMC_USBSTOPMEM_OFFS)
+
+#define PMC_DUNITSTOPMEM_OFFS			3
+#define PMC_DUNITSTOPMEM_MASK			(1 << PMC_DUNITSTOPMEM_OFFS)
+#define PMC_DUNITSTOPMEM_EN			(0 << PMC_DUNITSTOPMEM_OFFS)
+#define PMC_DUNITSTOPMEM_STOP			(1 << PMC_DUNITSTOPMEM_OFFS)
+
+#define PMC_RUNITSTOPMEM_OFFS			4
+#define PMC_RUNITSTOPMEM_MASK			(1 << PMC_RUNITSTOPMEM_OFFS)
+#define PMC_RUNITSTOPMEM_EN			(0 << PMC_RUNITSTOPMEM_OFFS)
+#define PMC_RUNITSTOPMEM_STOP			(1 << PMC_RUNITSTOPMEM_OFFS)
+
+#define PMC_XORSTOPMEM_OFFS(port)		(5+(port*2))
+#define PMC_XORSTOPMEM_MASK(port)		(1 << PMC_XORSTOPMEM_OFFS(port))
+#define PMC_XORSTOPMEM_EN(port)			(0 << PMC_XORSTOPMEM_OFFS(port))
+#define PMC_XORSTOPMEM_STOP(port)		(1 << PMC_XORSTOPMEM_OFFS(port))
+
+#define PMC_SATASTOPMEM_OFFS(port)		(6+(port*5))
+#define PMC_SATASTOPMEM_MASK(port)		(1 << PMC_SATASTOPMEM_OFFS(port))
+#define PMC_SATASTOPMEM_EN(port)		(0 << PMC_SATASTOPMEM_OFFS(port))
+#define PMC_SATASTOPMEM_STOP(port)		(1 << PMC_SATASTOPMEM_OFFS(port))
+
+#define PMC_SESTOPMEM_OFFS			8
+#define PMC_SESTOPMEM_MASK			(1 << PMC_SESTOPMEM_OFFS)
+#define PMC_SESTOPMEM_EN			(0 << PMC_SESTOPMEM_OFFS)
+#define PMC_SESTOPMEM_STOP			(1 << PMC_SESTOPMEM_OFFS)
+
+#define PMC_AUDIOSTOPMEM_OFFS			9
+#define PMC_AUDIOSTOPMEM_MASK			(1 << PMC_AUDIOSTOPMEM_OFFS)
+#define PMC_AUDIOSTOPMEM_EN			(0 << PMC_AUDIOSTOPMEM_OFFS)
+#define PMC_AUDIOSTOPMEM_STOP			(1 << PMC_AUDIOSTOPMEM_OFFS)
+
+#define POWER_MNG_CTRL_REG			0x2011C
+
+#define PMC_GESTOPCLOCK_OFFS(port)		((port)? 19 : 0)
+#define PMC_GESTOPCLOCK_MASK(port)		(1 << PMC_GESTOPCLOCK_OFFS(port))
+#define PMC_GESTOPCLOCK_EN(port)		(1 << PMC_GESTOPCLOCK_OFFS(port))
+#define PMC_GESTOPCLOCK_STOP(port)		(0 << PMC_GESTOPCLOCK_OFFS(port))
+
+#define PMC_USBSTOPCLOCK_OFFS			3
+#define PMC_USBSTOPCLOCK_MASK			(1 << PMC_USBSTOPCLOCK_OFFS)
+#define PMC_USBSTOPCLOCK_EN			(1 << PMC_USBSTOPCLOCK_OFFS)
+#define PMC_USBSTOPCLOCK_STOP			(0 << PMC_USBSTOPCLOCK_OFFS)
+
+#define PMC_SDIOSTOPCLOCK_OFFS			4
+#define PMC_SDIOSTOPCLOCK_MASK			(1 << PMC_SDIOSTOPCLOCK_OFFS)
+#define PMC_SDIOSTOPCLOCK_EN			(1 << PMC_SDIOSTOPCLOCK_OFFS)
+#define PMC_SDIOSTOPCLOCK_STOP			(0 << PMC_SDIOSTOPCLOCK_OFFS)
+
+#define PMC_TSSTOPCLOCK_OFFS			5
+#define PMC_TSSTOPCLOCK_MASK			(1 << PMC_TSSTOPCLOCK_OFFS)
+#define PMC_TSSTOPCLOCK_EN			(1 << PMC_TSSTOPCLOCK_OFFS)
+#define PMC_TSSTOPCLOCK_STOP			(0 << PMC_TSSTOPCLOCK_OFFS)
+
+#define PMC_AUDIOSTOPCLOCK_OFFS			9
+#define PMC_AUDIOSTOPCLOCK_MASK			(1 << PMC_AUDIOSTOPCLOCK_OFFS)
+#define PMC_AUDIOSTOPCLOCK_EN			(1 << PMC_AUDIOSTOPCLOCK_OFFS)
+#define PMC_AUDIOSTOPCLOCK_STOP			(0 << PMC_AUDIOSTOPCLOCK_OFFS)
+
+#define PMC_POWERSAVE_OFFS			11
+#define PMC_POWERSAVE_MASK			(1 << PMC_POWERSAVE_OFFS)
+#define PMC_POWERSAVE_EN			(1 << PMC_POWERSAVE_OFFS)
+#define PMC_POWERSAVE_STOP			(0 << PMC_POWERSAVE_OFFS)
+
+#define PMC_SATASTOPCLOCK_OFFS(port)		(14+(port))
+#define PMC_SATASTOPCLOCK_MASK(port)		(1 << PMC_SATASTOPCLOCK_OFFS(port))
+#define PMC_SATASTOPCLOCK_EN(port)		(1 << PMC_SATASTOPCLOCK_OFFS(port))
+#define PMC_SATASTOPCLOCK_STOP(port)		(0 << PMC_SATASTOPCLOCK_OFFS(port))
+
+#define PMC_SESTOPCLOCK_OFFS			17
+#define PMC_SESTOPCLOCK_MASK			(1 << PMC_SESTOPCLOCK_OFFS)
+#define PMC_SESTOPCLOCK_EN			(1 << PMC_SESTOPCLOCK_OFFS)
+#define PMC_SESTOPCLOCK_STOP			(0 << PMC_SESTOPCLOCK_OFFS)
+
+#define PMC_TDMSTOPCLOCK_OFFS			20
+#define PMC_TDMSTOPCLOCK_MASK			(1 << PMC_TDMSTOPCLOCK_OFFS)
+#define PMC_TDMSTOPCLOCK_EN			(1 << PMC_TDMSTOPCLOCK_OFFS)
+#define PMC_TDMSTOPCLOCK_STOP			(0 << PMC_TDMSTOPCLOCK_OFFS)
+
+
+/* Controler environment registers offsets */
+#define MPP_CONTROL_REG0			0x10000
+#define MPP_CONTROL_REG1			0x10004
+#define MPP_CONTROL_REG2			0x10008
+#define MPP_CONTROL_REG3			0x1000C
+#define MPP_CONTROL_REG4			0x10010
+#define MPP_CONTROL_REG5			0x10014
+#define MPP_CONTROL_REG6			0x10018
+#define NAND_AUDIO_PIN_MUX			0x1002C
+#define NAND_AUDIO_PIN_MUX_SELECT_AUDIO_MODE	0x1
+#define MPP_SAMPLE_AT_RESET			0x10030
+#define CHIP_BOND_REG				0x10034
+#define SYSRST_LENGTH_COUNTER_REG		0x10050
+#define SLCR_COUNT_OFFS				0
+#define SLCR_COUNT_MASK				(0x1FFFFFFF << SLCR_COUNT_OFFS)
+#define SLCR_CLR_OFFS				31
+#define SLCR_CLR_MASK				(1 << SLCR_CLR_OFFS)
+#define PCKG_OPT_MASK				0x3
+#define MPP_OUTPUT_DRIVE_REG			0x100E0
+#define MPP_RGMII0_OUTPUT_DRIVE_OFFS            7
+#define MPP_3_3_RGMII0_OUTPUT_DRIVE		(0x0 << MPP_RGMII0_OUTPUT_DRIVE_OFFS)
+#define MPP_1_8_RGMII0_OUTPUT_DRIVE		(0x1 << MPP_RGMII0_OUTPUT_DRIVE_OFFS)
+#define MPP_RGMII1_OUTPUT_DRIVE_OFFS            15
+#define MPP_3_3_RGMII1_OUTPUT_DRIVE		(0x0 << MPP_RGMII1_OUTPUT_DRIVE_OFFS)
+#define MPP_1_8_RGMII1_OUTPUT_DRIVE		(0x1 << MPP_RGMII1_OUTPUT_DRIVE_OFFS)
+
+#define MSAR_BOOT_MODE_OFFS                     12
+#define MSAR_BOOT_MODE_MASK                     (0x7 << MSAR_BOOT_MODE_OFFS)
+#define MSAR_BOOT_NAND_WITH_BOOTROM		        (0x5 << MSAR_BOOT_MODE_OFFS)
+#define MSAR_BOOT_SPI_WITH_BOOTROM              (0x4 << MSAR_BOOT_MODE_OFFS)
+#define MSAR_BOOT_SPI_USE_NAND_WITH_BOOTROM		(0x2 << MSAR_BOOT_MODE_OFFS)
+
+#define MSAR_BOOT_MODE_6180(X)                  (((X & 0x3000) >> 12) | \
+                                                ((X & 0x2) << 1))
+#define MSAR_BOOT_SPI_WITH_BOOTROM_6180         0x1
+#define MSAR_BOOT_NAND_WITH_BOOTROM_6180        0x5
+
+#define MSAR_TCLCK_OFFS				21
+#define MSAR_TCLCK_MASK				(0x1 << MSAR_TCLCK_OFFS)
+#define MSAR_TCLCK_166				(0x1 << MSAR_TCLCK_OFFS)
+#define MSAR_TCLCK_200				(0x0 << MSAR_TCLCK_OFFS)
+
+
+#define MSAR_CPUCLCK_EXTRACT(X)     (((X & 0x2) >> 1) | ((X & 0x400000) >> 21) | \
+                                    ((X & 0x18) >> 1))
+
+#define MSAR_CPUCLCK_OFFS_6180		2
+#define MSAR_CPUCLCK_MASK_6180		(0x7 << MSAR_CPUCLCK_OFFS_6180)
+
+#define MSAR_DDRCLCK_RTIO_OFFS		5
+#define MSAR_DDRCLCK_RTIO_MASK		(0xF << MSAR_DDRCLCK_RTIO_OFFS)
+
+#define MSAR_L2CLCK_EXTRACT(X)      (((X & 0x600) >> 9) | ((X & 0x80000) >> 17))
+
+#ifndef MV_ASMLANGUAGE
+/* CPU clock for 6281,6192,6282  0->Resereved */
+#define MV_CPU_CLCK_TBL { 	0,		400000000,	0, 		0,	\
+			     	600000000, 	0,		800000000,	1000000000,	\
+			     	0,	 	1200000000,	0,		0,		\
+			     	1500000000,	1600000000,		1800000000,		2000000000}
+
+/* DDR clock RATIO for 6281,6192,6282 {0,0}->Reserved */
+#define MV_DDR_CLCK_RTIO_TBL	{\
+	{1, 1}, {0, 0}, {2, 1}, {5, 2}, \
+	{3, 1}, {0, 0}, {4, 1}, {9, 2}, \
+	{5, 1}, {6, 1}, {0, 0}, {0, 0}, \
+	{0, 0}, {0, 0}, {0, 0}, {0, 0} \
+}
+
+/* L2 clock RATIO for 6281,6192,6282 {1,1}->Reserved */
+#define MV_L2_CLCK_RTIO_TBL	{\
+	{1, 1}, {2, 1}, {2, 1}, {3, 1}, \
+	{0, 0}, {4, 1}, {0, 0}, {0, 0} \
+}
+
+/* 6180 have different clk reset sampling 		*/
+/* ARM CPU, DDR, L2 clock for 6180 {0,0,0}->Reserved 	*/
+#define MV_CPU6180_DDR_L2_CLCK_TBL    { \
+	{0,   		0,   		0		},\
+	{0,   		0,   		0		},\
+	{0,   		0,   		0		},\
+	{0,   		0,   		0		},\
+	{0,   		0,   		0		},\
+	{600000000, 	200000000, 	300000000	},\
+	{800000000, 	200000000, 	400000000	},\
+	{1000000000,   	200000000,   500000000		}\
+}
+
+/* For old competability */
+#define DEVICE_CS0		NFLASH_CS
+#define DEVICE_CS1  		SPI_CS
+#define DEVICE_CS2  		BOOT_ROM_CS
+#define DEVICE_CS3  		DEV_BOOCS
+#define MV_BOOTDEVICE_INDEX   	0
+
+#define START_DEV_CS   		DEV_CS0
+#define DEV_TO_TARGET(dev)	((dev) + DEVICE_CS0)
+
+/* This enumerator defines the Marvell controller target ID      */
+typedef enum _mvTargetId
+{
+    DRAM_TARGET_ID  = 0 ,    /* Port 0 -> DRAM interface         */
+    DEV_TARGET_ID   = 1,     /* Port 1 -> Nand/SPI 		*/
+    PEX0_TARGET_ID  = 4 ,    /* Port 4 -> PCI Express0 		*/
+    PEX1_TARGET_ID  = 4 ,    /* Port 4 -> PCI Express1 */
+    CRYPT_TARGET_ID = 3 ,    /* Port 3 --> Crypto Engine 	*/
+    SAGE_TARGET_ID = 12 ,    /* Port 12 -> SAGE Unit 	*/
+    MAX_TARGETS_ID
+}MV_TARGET_ID;
+
+
+/* This enumerator described the possible Controller paripheral targets.    */
+/* Controller peripherals are designated memory/IO address spaces that the  */
+/* controller can access. They are also refered as "targets"                */
+typedef enum _mvTarget
+{
+    TBL_TERM = -1, 	/* none valid target, used as targets list terminator*/
+    SDRAM_CS0,      	/* SDRAM chip select 0                          */
+    SDRAM_CS1,      	/* SDRAM chip select 1                          */
+    SDRAM_CS2,      	/* SDRAM chip select 2                          */
+    SDRAM_CS3,      	/* SDRAM chip select 3                          */
+    PEX0_MEM,		/* PCI Express 0 Memory				*/
+    PEX0_IO,		/* PCI Express 0 IO				*/
+    PEX1_MEM,		/* PCI Express 1 Memory				*/
+    PEX1_IO,		/* PCI Express 1 IO				*/
+    INTER_REGS,     	/* Internal registers                           */
+    NFLASH_CS,     	/* NFLASH_CS					*/
+    SPI_CS,     	/* SPI_CS					*/
+    BOOT_ROM_CS,        /* BOOT_ROM_CS                                  */
+    DEV_BOOCS,     	/* DEV_BOOCS					*/
+    CRYPT_ENG,      	/* Crypto Engine				*/
+#ifdef MV_INCLUDE_SAGE
+    SAGE_UNIT,      	/* SAGE Unit					*/
+#endif
+    MAX_TARGETS
+
+}MV_TARGET;
+
+#define TARGETS_DEF_ARRAY	{			\
+    {0x0E, DRAM_TARGET_ID }, /* SDRAM_CS0 */		\
+    {0x0D, DRAM_TARGET_ID }, /* SDRAM_CS1 */		\
+    {0x0B, DRAM_TARGET_ID }, /* SDRAM_CS0 */		\
+    {0x07, DRAM_TARGET_ID }, /* SDRAM_CS1 */		\
+    {0xE8, PEX0_TARGET_ID }, /* PEX0_MEM */			\
+    {0xE0, PEX0_TARGET_ID }, /* PEX0_IO */			\
+    {0xD8, PEX1_TARGET_ID }, /* PEX1_MEM */			\
+    {0xD0, PEX1_TARGET_ID }, /* PEX1_IO */			\
+    {0xFF, 0xFF           }, /* INTER_REGS */		\
+    {0x2F, DEV_TARGET_ID  },  /* NFLASH_CS */		\
+    {0x1E, DEV_TARGET_ID  },  /* SPI_CS */		 	\
+    {0x1D, DEV_TARGET_ID  },  /* BOOT_ROM_CS */     \
+    {0x1E, DEV_TARGET_ID  },  /* DEV_BOOCS */		\
+    {0x01, CRYPT_TARGET_ID}, /* CRYPT_ENG */        \
+    {0x00, SAGE_TARGET_ID }  						\
+}
+
+
+#define TARGETS_NAME_ARRAY	{	\
+    "SDRAM_CS0",    /* SDRAM_CS0 */	\
+    "SDRAM_CS1",    /* SDRAM_CS1 */	\
+    "SDRAM_CS2",    /* SDRAM_CS2 */	\
+    "SDRAM_CS3",    /* SDRAM_CS3 */	\
+    "PEX0_MEM",	    /* PEX0_MEM */	\
+    "PEX0_IO",	    /* PEX0_IO */	\
+    "PEX1_MEM",	    /* PEX1_MEM */	\
+    "PEX1_IO",	    /* PEX1_IO */	\
+    "INTER_REGS",   /* INTER_REGS */	\
+    "NFLASH_CS",    /* NFLASH_CS */	\
+    "SPI_CS",	    /* SPI_CS */	\
+    "BOOT_ROM_CS",  /* BOOT_ROM_CS */ \
+    "DEV_BOOTCS",   /* DEV_BOOCS */	\
+    "CRYPT_ENG",    /* CRYPT_ENG */  \
+    "SAGE_UNIT"	   /* SAGE_UNIT */	\
+}
+#endif /* MV_ASMLANGUAGE */
+
+
+#endif
diff --git a/arch/arm/mach-kirkwood/kw_family/ctrlEnv/mvCtrlEnvSpec.h b/arch/arm/mach-kirkwood/kw_family/ctrlEnv/mvCtrlEnvSpec.h
new file mode 100644
index 0000000..8c4ebba
--- /dev/null
+++ b/arch/arm/mach-kirkwood/kw_family/ctrlEnv/mvCtrlEnvSpec.h
@@ -0,0 +1,183 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+        this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvCtrlEnvSpech
+#define __INCmvCtrlEnvSpech
+
+#include "mvDeviceId.h"
+#include "mvSysHwConfig.h"
+
+#define SOC_NAME_PREFIX			"MV88F"
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#define TDM_REG_BASE			0xD0000
+#define MV_CESA_REG_BASE                0x3D000
+#define MV_CESA_TDMA_REG_BASE		0x30000
+#define MV_ETH_REG_BASE(port)      	(((port) == 0) ? 0x72000 : 0x76000)
+#define TWSI_SLAVE_BASE(chanNum)	(0x11000 + (0x100 * (chanNum)))
+
+/* This define describes the TWSI interrupt bit and location */
+#define TWSI_CPU_MAIN_INT_CAUSE_REG(chanNum)	((chanNum)?0x20210:0x20200)
+#define TWSI_CPU_MAIN_INT_BIT(chanNum)		((chanNum)?(1<<0):(1<<29))
+#define TWSI_SPEED				100000
+
+#define MV_GPP_MAX_PINS			64
+#define MV_GPP_MAX_GROUP    		2
+
+#define MV_6281_MPP_MAX_MODULE    	2
+#define MV_6282_MPP_MAX_MODULE    	2
+#define MV_6280_MPP_MAX_MODULE    	1
+#define MV_6192_MPP_MAX_MODULE    	1
+#define MV_6190_MPP_MAX_MODULE    	1
+#define MV_6180_MPP_MAX_MODULE    	2
+#define MV_6281_MPP_MAX_GROUP    	7
+#define MV_6282_MPP_MAX_GROUP    	7
+#define MV_6280_MPP_MAX_GROUP    	3
+#define MV_6192_MPP_MAX_GROUP    	4
+#define MV_6190_MPP_MAX_GROUP    	4
+#define MV_6180_MPP_MAX_GROUP    	3
+
+#define MV_ETH_MAX_PORTS		2
+#define MV_6281_ETH_MAX_PORTS	   	2
+#define MV_6282_ETH_MAX_PORTS	   	2
+#define MV_6280_ETH_MAX_PORTS	   	1
+#define MV_6192_ETH_MAX_PORTS	   	2
+#define MV_6190_ETH_MAX_PORTS	   	1
+#define MV_6180_ETH_MAX_PORTS	   	1
+
+#define MV_6281_TDM			1
+#define MV_6282_TDM			1
+#define MV_6280_TDM			0
+#define MV_6192_TDM			1
+#define MV_6190_TDM			0
+#define MV_6180_TDM			0
+
+/* CESA version #2: One channel, 2KB SRAM, TDMA */
+#if defined(MV_CESA_CHAIN_MODE_SUPPORT)
+#define MV_CESA_VERSION		 	3
+#else
+#define MV_CESA_VERSION		 	2
+#endif
+#define MV_CESA_SRAM_SIZE               2*1024
+
+/* This define describes the maximum number of supported Ethernet ports 	*/
+#define MV_ETH_VERSION 			4
+#define MV_ETH_MAX_RXQ              	8
+#define MV_ETH_MAX_TXQ              	8
+#define MV_ETH_PORT_SGMII          	{ MV_FALSE, MV_FALSE }
+
+#define MPP_GROUP_1_TYPE {\
+	{0, 0, 0}, /* Reserved for AUTO */ \
+	{0x22220000, 0x22222222, 0x2222}, /* TDM */ \
+	{0x44440000, 0x00044444, 0x0000}, /* AUDIO */ \
+	{0x33330000, 0x33003333, 0x0033}, /* RGMII */ \
+	{0x33330000, 0x03333333, 0x0033}, /* GMII */ \
+	{0x11110000, 0x11111111, 0x0001}, /* TS */ \
+	{0x33330000, 0x33333333, 0x3333},  /* MII */\
+	{0, 0, 0}, /* N_A */\
+	{0xBBBBBBBB, 0xBBBBBBBB, 0xBBBB} /* LCD */\
+}
+
+#define MPP_GROUP_2_TYPE {\
+	{0, 0, 0}, /* Reserved for AUTO */ \
+	{0x22220000, 0x22222222, 0x22}, /* TDM */ \
+	{0x44440000, 0x00044444, 0x0}, /* AUDIO */ \
+	{0, 0, 0}, /* N_A */ \
+	{0, 0, 0}, /* N_A */ \
+	{0x11110000, 0x11111111, 0x01},  /* TS */ \
+	{0, 0, 0}, /* N_A */ \
+	{0, 0, 0}, /* N_A */ \
+	{0xBBBBBBBB, 0xBBBBBBBB, 0xBB} /* LCD */ \
+}
+
+#ifndef MV_ASMLANGUAGE
+
+/* This enumerator defines the Marvell Units ID      */
+typedef enum _mvUnitId
+{
+    DRAM_UNIT_ID,
+    PEX_UNIT_ID,
+    ETH_GIG_UNIT_ID,
+    USB_UNIT_ID,
+    IDMA_UNIT_ID,
+    XOR_UNIT_ID,
+    SATA_UNIT_ID,
+    TDM_UNIT_ID,
+    UART_UNIT_ID,
+    CESA_UNIT_ID,
+    SPI_UNIT_ID,
+    AUDIO_UNIT_ID,
+    SDIO_UNIT_ID,
+    TS_UNIT_ID,
+    LCD_UNIT_ID,
+    MAX_UNITS_ID
+
+}MV_UNIT_ID;
+
+#endif
+
+#endif /* __INCmvCtrlEnvSpech */
diff --git a/arch/arm/mach-kirkwood/kw_family/ctrlEnv/sys/mvSysTdm.c b/arch/arm/mach-kirkwood/kw_family/ctrlEnv/sys/mvSysTdm.c
new file mode 100644
index 0000000..ee1cc6d
--- /dev/null
+++ b/arch/arm/mach-kirkwood/kw_family/ctrlEnv/sys/mvSysTdm.c
@@ -0,0 +1,273 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/compiler.h>
+#include <linux/mbus.h>
+#include "common.h"
+
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+
+#ifdef MV_TDM_SUPPORT
+#include "voiceband/tdm/mvTdm.h"
+#else
+ #include "voiceband/commUnit/mvCommUnit.h"
+ #include "gpp/mvGpp.h"
+#endif
+
+#include "voiceband/mvSysTdmSpi.h"
+#include "spi/mvSpiCmnd.h"
+#include "spi/mvSpi.h"
+
+#define MAX_DATA_LENGTH			255
+#define MV_SPI_DEFAULT_BAUD_RATE	(10 << 20)
+
+#define WINDOW_CTRL(i)		(0x4030 + ((i) << 4))
+#define WINDOW_BASE(i)		(0x4034 + ((i) << 4))
+
+static void mv_conf_mbus_windows(void __iomem *base,
+				 const struct mbus_dram_target_info *dram)
+{
+	int i;
+
+	for (i = 0; i < 4; i++) {
+		writel(0, base + WINDOW_CTRL(i));
+		writel(0, base + WINDOW_BASE(i));
+	}
+
+	for (i = 0; i < dram->num_cs; i++) {
+		const struct mbus_dram_window *cs = dram->cs + i;
+
+		writel(((cs->size - 1) & 0xffff0000) |
+			(cs->mbus_attr << 8) |
+			(dram->mbus_dram_target_id << 4) | 1,
+			base + WINDOW_CTRL(i));
+		writel(cs->base, base + WINDOW_BASE(i));
+	}
+}
+
+MV_STATUS mvSysTdmInit(MV_TDM_PARAMS* tdmParams)
+{
+	MV_TDM_HAL_DATA halData;
+	MV_STATUS status;
+	const struct mbus_dram_target_info *dram;
+
+#ifdef MV_TDM_SUPPORT
+	dram = mv_mbus_dram_info();
+	mv_conf_mbus_windows((void __iomem *)TDM_PHYS_BASE, dram);
+#else
+	mvCommUnitWinInit();
+#endif
+
+	halData.spiMode = mvBoardTdmSpiModeGet();
+	halData.model = mvCtrlModelGet();
+	halData.ctrlRev = mvCtrlRevGet();
+#if defined(MV_TDM_PCM_CLK_8MHZ)
+	halData.frameTs = MV_FRAME_128TS;
+	halData.pcmFreq = PCM_8192KHZ;
+#elif defined(MV_TDM_PCM_CLK_4MHZ)
+	halData.frameTs = MV_FRAME_64TS;
+	halData.pcmFreq = PCM_4096KHZ;
+#else /* MV_TDM_PCM_CLK_2MHZ */
+	halData.frameTs = MV_FRAME_32TS;
+	halData.pcmFreq = PCM_2048KHZ;
+#endif
+
+#ifdef MV_TDM_SUPPORT
+	status = mvTdmHalInit (tdmParams, &halData);
+#else
+	halData.maxCs = mvBoardTdmDevicesCountGet();
+	status = mvCommUnitHalInit (tdmParams, &halData);
+
+	/* Issue SLIC reset */
+	mvGppValueSet(0, BIT25, 0);
+	mvOsUDelay(60);
+	mvGppValueSet(0, BIT25, BIT25);
+#endif
+
+	if (mvSpiInit(MV_SPI_DEFAULT_BAUD_RATE, kirkwood_tclk) != MV_OK)
+		mvOsPrintf("Error, unable to initialize SPI HAL driver\n");
+
+	return status;
+}
+
+MV_VOID mvSysTdmSpiRead(MV_U16 lineId, MV_U8* cmdBuff, MV_U8 cmdSize, MV_U8* dataBuff, MV_U8 dataSize)
+{
+#if defined(MV_TDM_SUPPORT) && !defined(ZARLINK_SLIC_SUPPORT) && !defined(SILABS_SLIC_SUPPORT)
+	if((cmdSize > 4) || (dataSize > MAX_DATA_LENGTH))
+	{
+		mvOsPrintf("Error, exceeded max size of command(%d) or data(%d)\n", cmdSize, dataSize);
+		return;
+	}
+
+	mvTdmSpiRead(cmdBuff, cmdSize, dataBuff, dataSize, lineId);
+
+#else
+
+	/* Set SPI parameters for SLIC */
+	mvSpiParamsSet(SPI_TYPE_SLIC);
+
+	if(MV_OK != mvSpiWriteThenRead (cmdBuff, cmdSize, dataBuff, dataSize, 0))
+		mvOsPrintf("SPI read failed !!!\n");
+
+	/* Restore SPI parameters to FLASH */
+	mvSpiParamsSet(SPI_TYPE_FLASH);
+
+#endif
+}
+
+/*******************************************************************************
+* mvSysTdmSpiWrite - telephony register write via SPI interface
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvSysTdmSpiWrite(MV_U16 lineId, MV_U8* cmdBuff, MV_U8 cmdSize, MV_U8* dataBuff, MV_U8 dataSize)
+{
+#if defined(MV_TDM_SUPPORT) && !defined(ZARLINK_SLIC_SUPPORT) && !defined(SILABS_SLIC_SUPPORT)
+
+	if((cmdSize > 3) || (dataSize > MAX_DATA_LENGTH))
+	{
+		mvOsPrintf("Error, exceeded max size of command(%d) or data(%d)\n", cmdSize, dataSize);
+		return;
+	}
+
+	mvTdmSpiWrite(cmdBuff, cmdSize, dataBuff, dataSize, lineId);
+
+#else /* MV_COMM_UNIT_SUPPORT || ZARLINK_SLIC_SUPPORT || SILABS_SLIC_SUPPORT*/
+
+	/* Set SPI parameters for SLIC */
+	mvSpiParamsSet(SPI_TYPE_SLIC);
+
+	if(MV_OK != mvSpiWriteThenWrite (cmdBuff, cmdSize, dataBuff, dataSize))
+		printk("SPI write failed !!!\n");
+
+	/* Restore SPI parameters to FLASH */
+	mvSpiParamsSet(SPI_TYPE_FLASH);
+
+#endif /* MV_TDM_SUPPORT */
+}
+
+/*******************************************************************************
+* mvSysTdmIntEnable - Enable CSLAC device interrupts.
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       Device ID
+* OUTPUT:
+*		None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvSysTdmIntEnable(MV_U8 deviceId)
+{
+#if defined(MV_TDM_SUPPORT)
+
+	mvTdmIntEnable();
+
+#else /* MV_COMM_UNIT_SUPPORT */
+
+	mvCommUnitIntEnable(deviceId);
+
+#endif
+}
+
+/*******************************************************************************
+* mvSysTdmIntDisable - Disable CSLAC device interrupts.
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       Device ID
+* OUTPUT:
+*	None
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvSysTdmIntDisable(MV_U8 deviceId)
+{
+#if defined(MV_TDM_SUPPORT)
+
+	mvTdmIntDisable();
+
+#else /* MV_COMM_UNIT_SUPPORT */
+
+	mvCommUnitIntDisable(deviceId);
+
+#endif
+}
diff --git a/arch/arm/mach-kirkwood/kw_family/ctrlEnv/sys/mvSysTdm.h b/arch/arm/mach-kirkwood/kw_family/ctrlEnv/sys/mvSysTdm.h
new file mode 100644
index 0000000..09e0165
--- /dev/null
+++ b/arch/arm/mach-kirkwood/kw_family/ctrlEnv/sys/mvSysTdm.h
@@ -0,0 +1,106 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __MV_SYS_TDM_API_H__
+#define __MV_SYS_TDM_API_H__
+
+#include "mvSysHwConfig.h"
+
+#ifdef MV_TDM_SUPPORT
+#include "voiceband/tdm/mvTdm.h"
+#else
+  #include "voiceband/commUnit/mvCommUnit.h"
+#endif
+
+MV_STATUS mvSysTdmInit (MV_TDM_PARAMS* tdmParams);
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+
+typedef struct _mvTdmDecWin
+{
+        MV_TARGET     target;
+        MV_ADDR_WIN   addrWin; /* An address window*/
+        MV_BOOL       enable;  /* Address decode window is enabled/disabled */ 
+} MV_TDM_DEC_WIN;
+
+#define TDM_MBUS_MAX_WIN	4
+#define TDM_WIN_CTRL_REG(win)	((TDM_REG_BASE + 0x4030) + (win<<4))
+#define TDM_WIN_BASE_REG(win)	((TDM_REG_BASE +0x4034) + (win<<4))
+
+/* TDM_WIN_CTRL_REG bits */
+#define TDM_WIN_ENABLE_OFFS	0
+#define TDM_WIN_ENABLE_MASK	(1<<TDM_WIN_ENABLE_OFFS)
+#define TDM_WIN_ENABLE		1
+#define TDM_WIN_TARGET_OFFS	4
+#define TDM_WIN_TARGET_MASK	(0xf<<TDM_WIN_TARGET_OFFS)
+#define TDM_WIN_ATTRIB_OFFS	8
+#define TDM_WIN_ATTRIB_MASK	(0xff<<TDM_WIN_ATTRIB_OFFS)
+#define TDM_WIN_SIZE_OFFS	16
+#define TDM_WIN_SIZE_MASK	(0xffff<<TDM_WIN_SIZE_OFFS)
+
+/* TDM_WIN_BASE_REG bits */
+#define TDM_BASE_OFFS		16
+#define TDM_BASE_MASK		(0xffff<<TDM_BASE_OFFS)
+
+#endif
diff --git a/arch/arm/mach-kirkwood/pcie.c b/arch/arm/mach-kirkwood/pcie.c
index c46d20e..b59e76a 100644
--- a/arch/arm/mach-kirkwood/pcie.c
+++ b/arch/arm/mach-kirkwood/pcie.c
@@ -26,7 +26,7 @@ void kirkwood_enable_pcie(void)
 		writel(curr | CGC_PEX0, CLOCK_GATING_CTRL);
 }
 
-void __init kirkwood_pcie_id(u32 *dev, u32 *rev)
+void kirkwood_pcie_id(u32 *dev, u32 *rev)
 {
 	kirkwood_enable_pcie();
 	*dev = orion_pcie_dev_id((void __iomem *)PCIE_VIRT_BASE);
diff --git a/arch/arm/mach-kirkwood/rd88f6192-nas-setup.c b/arch/arm/mach-kirkwood/rd88f6192-nas-setup.c
index fd2c9c8..bf14be2 100644
--- a/arch/arm/mach-kirkwood/rd88f6192-nas-setup.c
+++ b/arch/arm/mach-kirkwood/rd88f6192-nas-setup.c
@@ -20,7 +20,10 @@
 #include <asm/mach-types.h>
 #include <asm/mach/arch.h>
 #include <mach/kirkwood.h>
+#include <plat/gpio.h>
 #include "common.h"
+#include "mpp.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
 
 #define RD88F6192_GPIO_USB_VBUS		10
 
@@ -50,10 +53,30 @@ static struct spi_board_info __initdata rd88F6192_spi_slave_info[] = {
 static void __init rd88f6192_init(void)
 {
 	/*
+	 * Init board id (Marvell-internal) and MPPs
+	 */
+	mvBoardIdSet(RD_88F6192A_ID);
+	mvBoardEnvInit();
+	mvCtrlEnvInit();
+
+	/*
 	 * Basic setup. Needs to be called early.
 	 */
 	kirkwood_init();
 
+	/*
+	 * Enable joystick support for LCD panel
+	 */
+#define UP_GPP		30
+#define DOWN_GPP	34
+#define LEFT_GPP	32
+#define RIGHT_GPP	31
+
+	orion_gpio_set_valid(UP_GPP,	GPIO_INPUT_OK);
+	orion_gpio_set_valid(DOWN_GPP,	GPIO_INPUT_OK);
+	orion_gpio_set_valid(LEFT_GPP,	GPIO_INPUT_OK);
+	orion_gpio_set_valid(RIGHT_GPP,	GPIO_INPUT_OK);
+
 	orion_gpio_set_valid(RD88F6192_GPIO_USB_VBUS, 1);
 	if (gpio_request(RD88F6192_GPIO_USB_VBUS, "USB VBUS") != 0 ||
 	    gpio_direction_output(RD88F6192_GPIO_USB_VBUS, 1) != 0)
diff --git a/arch/arm/mach-kirkwood/rd88f6282-a-setup.c b/arch/arm/mach-kirkwood/rd88f6282-a-setup.c
new file mode 100644
index 0000000..ab00231
--- /dev/null
+++ b/arch/arm/mach-kirkwood/rd88f6282-a-setup.c
@@ -0,0 +1,103 @@
+/*
+ * arch/arm/mach-kirkwood/rd88f6282-a-setup.c
+ *
+ * Marvell RD-88F6282-A Reference Board Setup
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/partitions.h>
+#include <linux/ata_platform.h>
+#include <linux/mv643xx_eth.h>
+#include <net/dsa.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include "common.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+
+static struct mtd_partition rd88f6282_a_nand_parts[] = {
+	{
+		.name = "u-boot",
+		.offset = 0,
+		.size = SZ_1M
+	}, {
+		.name = "uImage",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_2M
+	}, {
+		.name = "root",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = MTDPART_SIZ_FULL
+	},
+};
+
+static struct dsa_chip_data rd88f6282_a_switch_chip_data = {
+	.sw_addr	= 16,
+	.port_names[0]	= "lan1",
+	.port_names[1]	= "lan2",
+	.port_names[2]	= "lan3",
+	.port_names[3]	= "lan4",
+	.port_names[5]	= "cpu",
+};
+
+static struct dsa_platform_data rd88f6282_a_switch_plat_data = {
+	.nr_chips	= 1,
+	.chip		= &rd88f6282_a_switch_chip_data,
+};
+
+static struct mv643xx_eth_platform_data rd88f6282_a_ge00_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(0),
+};
+
+static struct mv643xx_eth_platform_data rd88f6282_a_ge01_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(10),
+};
+
+static struct mv_sata_platform_data rd88f6282_a_sata_data = {
+	.n_ports	= 2,
+};
+
+static void __init rd88f6282_a_init(void)
+{
+	mvBoardIdSet(RD_88F6282A_ID);
+	mvBoardEnvInit();
+	mvCtrlEnvInit();
+
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+
+	kirkwood_nand_init(ARRAY_AND_SIZE(rd88f6282_a_nand_parts), 25);
+	kirkwood_ehci_init();
+
+	kirkwood_ge00_init(&rd88f6282_a_ge00_data);
+	kirkwood_ge01_init(&rd88f6282_a_ge01_data);
+	kirkwood_ge01_switch_init(&rd88f6282_a_switch_plat_data, NO_IRQ);
+
+	kirkwood_sata_init(&rd88f6282_a_sata_data);
+	kirkwood_i2c_init();
+	kirkwood_uart1_init();
+}
+
+static int __init rd88f6282_a_pci_init(void)
+{
+	kirkwood_pcie_init(KW_PCIE1 | KW_PCIE0);
+	return 0;
+}
+subsys_initcall(rd88f6282_a_pci_init);
+
+MACHINE_START(RD88F6282_A, "Marvell RD-88F6282-A Reference Board")
+	/* Maintainer: Kosta Zertsekel <konszert@marvell.com> */
+	.atag_offset	= 0x100,
+	.init_machine	= rd88f6282_a_init,
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.timer		= &kirkwood_timer,
+MACHINE_END
diff --git a/arch/arm/mach-kirkwood/xcat98dx-setup.c b/arch/arm/mach-kirkwood/xcat98dx-setup.c
new file mode 100644
index 0000000..6166633
--- /dev/null
+++ b/arch/arm/mach-kirkwood/xcat98dx-setup.c
@@ -0,0 +1,99 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+*******************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/partitions.h>
+#include <linux/ata_platform.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/spi/flash.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/orion_spi.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include <plat/mvsdio.h>
+#include "common.h"
+#include "mpp.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+
+static struct mtd_partition db88f6281_nand_parts[] = {
+	{
+		.name = "u-boot",
+		.offset = 0,
+		.size = SZ_1M
+	}, {
+		.name = "uImage",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_4M
+	}, {
+		.name = "root",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = MTDPART_SIZ_FULL
+	},
+};
+
+static void __init xcat98dx_init(void)
+{
+	/*
+	 * Init board id (Marvell-internal) and MPPs
+	 */
+	mvBoardIdSet(XCAT98DX_ID);
+#if 0
+	mvBoardEnvInit();
+	mvCtrlEnvInit();
+#endif
+
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+
+	kirkwood_xcat_clock_init();
+
+	kirkwood_nand_init(ARRAY_AND_SIZE(db88f6281_nand_parts), 25);
+	kirkwood_i2c_init();
+	kirkwood_uart0_init();
+}
+
+static int __init xcat98dx_pci_init(void)
+{
+	kirkwood_pcie_init(KW_PCIE0);
+	return 0;
+}
+subsys_initcall(xcat98dx_pci_init);
+
+MACHINE_START(XCAT98DX, "Marvell xCat98DX Development Board")
+	/* Maintainer: Kosta Zertsekel <konszert@marvell.com> */
+	.atag_offset	= 0x100,
+	.init_machine	= xcat98dx_init,
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.timer		= &kirkwood_timer,
+MACHINE_END
-- 
1.7.5.4

