From f2882dc82b0cbb391295c3ecfb11e6cadb81e499 Mon Sep 17 00:00:00 2001
From: Ofer Heifetz <oferh@marvell.com>
Date: Thu, 12 Nov 2015 10:09:53 +0200
Subject: [PATCH 015/150] thermal: armada: Add support for overheat interrupt
 indication

The Armada 38x thermal sensor unit supports detection of overheat scenario
when the junction temperature reaches configured threshold +/- calculated
hysteresis value.
When the temperature reaches both high or low thresholds, interrupt
is asserted. This patch add support for the thermal sensor interrupt.
Threshold and hysteresis value can be configured in DT, if none given
default low/high thresholds are 97..107 Celsius degrees.

Signed-off-by: Ofer Heifetz <oferh@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/24793
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Lior Amsalem <alior@marvell.com>

Conflicts:
	arch/arm/boot/dts/armada-38x.dtsi

Change-Id: Ibb0fb4a835646c1f4b637548ab712667c791e46d
Signed-off-by: Grzegorz Jaszczyk <jaz@semihalf.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/27813
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Ofer Heifetz <oferh@marvell.com>
[zou:Original patch taken from
https://github.com/MarvellEmbeddedProcessors/linux-marvell-prv.git linux-4.4.1-devel]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 arch/arm/boot/dts/armada-38x.dtsi |    6 ++-
 drivers/thermal/armada_thermal.c  |  139 ++++++++++++++++++++++++++++++++++++-
 2 files changed, 143 insertions(+), 2 deletions(-)

diff --git a/arch/arm/boot/dts/armada-38x.dtsi b/arch/arm/boot/dts/armada-38x.dtsi
index 1548b33..d5ccb31 100644
--- a/arch/arm/boot/dts/armada-38x.dtsi
+++ b/arch/arm/boot/dts/armada-38x.dtsi
@@ -580,7 +580,11 @@
 
 			thermal@e8078 {
 				compatible = "marvell,armada380-thermal";
-				reg = <0xe4078 0x4>, <0xe4070 0x8>;
+				reg = <0xe4078 0x4>, <0xe4070 0x8>,
+				      <0xe4100 0x20>;
+				interrupts = <GIC_SPI 78 IRQ_TYPE_LEVEL_HIGH>;
+				threshold = <100>;
+				hysteresis = <2>;
 				status = "okay";
 			};
 
diff --git a/drivers/thermal/armada_thermal.c b/drivers/thermal/armada_thermal.c
index 06f3180..eb25549 100644
--- a/drivers/thermal/armada_thermal.c
+++ b/drivers/thermal/armada_thermal.c
@@ -23,8 +23,11 @@
 #include <linux/platform_device.h>
 #include <linux/of_device.h>
 #include <linux/thermal.h>
+#include <linux/interrupt.h>
 
 #define THERMAL_VALID_MASK		0x1
+#define MCELSIUS(temp)			((temp) * 1000)
+#define CELSIUS(temp)			((temp) / 1000)
 
 /* Thermal Manager Control and Status Register */
 #define PMU_TDC0_SW_RST_MASK		(0x1 << 1)
@@ -43,13 +46,22 @@
 #define A380_CONTROL_MSB_OFFSET		4
 #define A380_TSEN_TC_TRIM_MASK		0x7
 
+/* Statically defined overheat threshold Celsius */
+#define A380_THRESH_DEFAULT_TEMP	100
+#define A380_THRESH_DEFAULT_HYST	2
+#define A380_THRESH_OFFSET		16
+#define A380_THRESH_HYST_MASK		0x3
+#define A380_THRESH_HYST_OFFSET		26
+
 struct armada_thermal_data;
 
 /* Marvell EBU Thermal Sensor Dev Structure */
 struct armada_thermal_priv {
 	void __iomem *sensor;
 	void __iomem *control;
+	void __iomem *dfx;
 	struct armada_thermal_data *data;
+	struct platform_device *pdev;
 };
 
 struct armada_thermal_data {
@@ -72,6 +84,69 @@ struct armada_thermal_data {
 	unsigned int is_valid_shift;
 };
 
+inline unsigned int armada380_thresh_val_calc(unsigned int celsius_temp,
+					      struct armada_thermal_data *data)
+{
+	int thresh_val;
+
+	thresh_val = ((MCELSIUS(celsius_temp) * data->coef_div) +
+		      data->coef_b) / data->coef_m;
+
+	return thresh_val & data->temp_mask;
+}
+
+inline unsigned int armada380_thresh_celsius_calc(int thresh_val,
+				     int hyst, struct armada_thermal_data *data)
+{
+	unsigned int mcelsius_temp;
+
+	mcelsius_temp = (((data->coef_m * (thresh_val + hyst)) -
+			  data->coef_b) / data->coef_div);
+
+	return CELSIUS(mcelsius_temp);
+}
+
+static void armada380_temp_set_threshold(struct platform_device *pdev,
+					 struct armada_thermal_priv *priv)
+{
+	int temp, reg, hyst;
+	unsigned int thresh;
+	struct armada_thermal_data *data = priv->data;
+	struct device_node *np = pdev->dev.of_node;
+
+	/* get threshold value from DT */
+	if (of_property_read_u32(np, "threshold", &thresh)) {
+		thresh = A380_THRESH_DEFAULT_TEMP;
+		dev_warn(&pdev->dev, "no threshold in DT, using default\n");
+	}
+
+	/* get hysteresis value from DT */
+	if (of_property_read_u32(np, "hysteresis", &hyst)) {
+		hyst = A380_THRESH_DEFAULT_HYST;
+		dev_warn(&pdev->dev, "no hysteresis in DT, using default\n");
+	}
+
+	temp = armada380_thresh_val_calc(thresh, data);
+	reg = readl_relaxed(priv->control + A380_CONTROL_MSB_OFFSET);
+
+	/* Set Threshold */
+	reg &= ~(data->temp_mask << A380_THRESH_OFFSET);
+	reg |= (temp << A380_THRESH_OFFSET);
+
+	/* Set Hysteresis */
+	reg &= ~(A380_THRESH_HYST_MASK << A380_THRESH_HYST_OFFSET);
+	reg |= (hyst << A380_THRESH_HYST_OFFSET);
+
+	writel(reg, priv->control + A380_CONTROL_MSB_OFFSET);
+
+	/* hysteresis calculation is 2^(2+n) */
+	hyst = 1 << (hyst + 2);
+
+	dev_info(&pdev->dev, "Overheat threshold between %d..%d\n",
+		armada380_thresh_celsius_calc(temp, -hyst, data),
+		armada380_thresh_celsius_calc(temp, hyst, data));
+}
+
 static void armadaxp_init_sensor(struct platform_device *pdev,
 				 struct armada_thermal_priv *priv)
 {
@@ -154,6 +229,22 @@ static void armada380_init_sensor(struct platform_device *pdev,
 	reg &= ~A380_TSEN_TC_TRIM_MASK;
 	reg |= 0x3;
 	writel(reg, priv->control);
+
+	/* Set thresholds */
+	armada380_temp_set_threshold(pdev, priv);
+
+	/* Clear on Read DFX temperature irqs cause */
+	reg = readl_relaxed(priv->dfx + 0x10);
+
+	/* Unmask DFX Temperature overheat and cooldown irqs */
+	reg = readl_relaxed(priv->dfx + 0x14);
+	reg |= (0x3 << 1);
+	writel(reg, priv->dfx + 0x14);
+
+	/* Unmask DFX Server irq */
+	reg = readl_relaxed(priv->dfx + 0x4);
+	reg |= (0x3 << 1);
+	writel(reg, priv->dfx + 0x4);
 }
 
 static bool armada_is_valid(struct armada_thermal_priv *priv)
@@ -195,6 +286,32 @@ static int armada_get_temp(struct thermal_zone_device *thermal,
 static struct thermal_zone_device_ops ops = {
 	.get_temp = armada_get_temp,
 };
+ 
+static irqreturn_t a38x_temp_irq_handler(int irq, void *data)
+{
+	struct armada_thermal_priv *priv = (struct armada_thermal_priv *)data;
+	struct device *dev = &priv->pdev->dev;
+	u32 reg;
+
+	/* Mask Temp irq */
+	reg = readl_relaxed(priv->dfx + 0x14);
+	reg &= ~(0x3 << 1);
+	writel(reg, priv->dfx + 0x14);
+
+	/* Clear Temp irq cause */
+	reg = readl_relaxed(priv->dfx + 0x10);
+
+	if (reg & (0x3 << 1))
+		dev_warn(dev, "Overheat critical %s threshold temperature reached\n",
+			 (reg & (1 << 1)) ? "high" : "low");
+
+	/* UnMask Temp irq */
+	reg = readl_relaxed(priv->dfx + 0x14);
+	reg |= (0x3 << 1);
+	writel(reg, priv->dfx + 0x14);
+
+	return IRQ_HANDLED;
+}
 
 static const struct armada_thermal_data armadaxp_data = {
 	.init_sensor = armadaxp_init_sensor,
@@ -268,6 +385,7 @@ static int armada_thermal_probe(struct platform_device *pdev)
 	const struct of_device_id *match;
 	struct armada_thermal_priv *priv;
 	struct resource *res;
+	int irq;
 
 	match = of_match_device(armada_thermal_id_table, &pdev->dev);
 	if (!match)
@@ -287,6 +405,11 @@ static int armada_thermal_probe(struct platform_device *pdev)
 	if (IS_ERR(priv->control))
 		return PTR_ERR(priv->control);
 
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 2);
+	priv->dfx = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(priv->dfx))
+		return PTR_ERR(priv->dfx);
+
 	priv->data = (struct armada_thermal_data *)match->data;
 	priv->data->init_sensor(pdev, priv);
 
@@ -298,6 +421,20 @@ static int armada_thermal_probe(struct platform_device *pdev)
 		return PTR_ERR(thermal);
 	}
 
+	priv->pdev = pdev;
+
+	/* Register overheat interrupt */
+	irq = platform_get_irq(pdev, 0);
+
+	if (irq < 0) {
+		dev_warn(&pdev->dev, "no irq\n");
+		return irq;
+	}
+	if (devm_request_irq(&pdev->dev, irq, a38x_temp_irq_handler,
+				0, pdev->name, priv) < 0) {
+		dev_warn(&pdev->dev, "Interrupt not available.\n");
+	}
+
 	platform_set_drvdata(pdev, thermal);
 
 	return 0;
@@ -325,5 +462,5 @@ static struct platform_driver armada_thermal_driver = {
 module_platform_driver(armada_thermal_driver);
 
 MODULE_AUTHOR("Ezequiel Garcia <ezequiel.garcia@free-electrons.com>");
-MODULE_DESCRIPTION("Armada 370/XP thermal driver");
+MODULE_DESCRIPTION("Armada 370/380/XP thermal driver");
 MODULE_LICENSE("GPL v2");
-- 
1.7.5.4

