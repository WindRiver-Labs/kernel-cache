From 06c330d810b0123e7eddb7686447d23d07636376 Mon Sep 17 00:00:00 2001
From: Dmitri Epshtein <dima@marvell.com>
Date: Mon, 16 Jun 2014 14:52:37 -0400
Subject: [PATCH 1714/1825] fix: pp2: Fix compilation when pp2 is kernel
 module

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit ae8b7a2f640b994a538b795d4791638434e30e95

Change-Id: Ief72d988b029af3c310af47db642f4d9ccb99329
Signed-off-by: Dmitri Epshtein <dima@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/8550
Reviewed-by: Evan Wang <xswang@marvell.com>
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Uri Eliyahu <uriel@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../mv_drivers_lsp/mv_mux/mv_mux_netdev.c          |    1 +
 arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig |   10 ++++
 .../mv_drivers_lsp/mv_pp2/l2fw/l2fw_sysfs.c        |   10 +++--
 .../mv_drivers_lsp/mv_pp2/l2fw/mv_eth_l2fw.c       |   48 ++++++++++---------
 4 files changed, 42 insertions(+), 27 deletions(-)

diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.c
index 251f441..a5222f1 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_mux/mv_mux_netdev.c
@@ -272,6 +272,7 @@ int mv_mux_netdev_find(unsigned int dev_idx)
 	}
 	return -1;
 }
+EXPORT_SYMBOL(mv_mux_netdev_find);
 /*-----------------------------------------------------------------------------------------*/
 int mv_mux_update_link(void *cookie, int link_up)
 {
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig
index 4588382..fff08f1 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/Kconfig
@@ -283,6 +283,16 @@ config MV_ETH_L2FW
 	Three modes are supported: Send packet without change, Swap MAC DA<->SA,
 	Copy the whole packet and swap MAC
 
+config MV_ETH_L2FW_XOR
+        bool "L2 Forwarding XOR support"
+        depends on MV_ETH_L2FW && MV_INCLUDE_XOR
+        default n
+        ---help---
+        Enable using XOR engine to copy ingress packets during L2FW processing.
+	If enabled XOR engine will be used to copy packet when packet size is
+	larger than XOR threshold (default value is 2000 bytes).
+	XOR threshold can be changes using sysfs command.
+
 config MV_ETH_L2SEC
 	bool "L2 Forwarding IPSec support"
 	depends on MV_ETH_L2FW
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/l2fw/l2fw_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/l2fw/l2fw_sysfs.c
index 7a5ec9b..faa049e 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/l2fw/l2fw_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/l2fw/l2fw_sysfs.c
@@ -50,10 +50,12 @@ static ssize_t mv_l2fw_help(char *buf)
 	off += sprintf(buf+off, "\n");
 	off += sprintf(buf+off, "echo p [1|0]      > l2fw     - Enable/Disable L2FW for port <p>\n");
 	off += sprintf(buf+off, "echo rxp txp mode > bind     - Set <rxp-->txp>, mode: 0-as_is, 1-swap, 2-copy\n");
-	off += sprintf(buf+off, "echo rxp thresh   > xor      - Set XOR threshold for port <rxp>\n");
 	off += sprintf(buf+off, "echo rxp [1|0]    > lookup   - Enable/Disable L3 lookup for port <rxp>\n");
 	off += sprintf(buf+off, "echo 1            > flush    - Flush L2FW rules DB\n");
 	off += sprintf(buf+off, "echo sip dip txp  > add_ip   - Set L3 lookup rule, sip, dip in a.b.c.d format\n");
+#ifdef CONFIG_MV_L2FW_XOR
+	off += sprintf(buf+off, "echo rxp thresh   > xor      - Set XOR threshold for port <rxp>\n");
+#endif
 #ifdef CONFIG_MV_ETH_L2SEC
 	off += sprintf(buf+off, "echo p chan       > cesa     - Set cesa channel <chan> for port <p>.\n");
 #endif
@@ -170,7 +172,7 @@ static ssize_t mv_l2fw_store(struct device *dev,
 	local_irq_save(flags);
 	if (!strcmp(name, "lookup"))
 		mv_l2fw_lookupEn(a, b);
-#ifdef CONFIG_MV_INCLUDE_XOR
+#ifdef CONFIG_MV_L2FW_XOR
 	else if (!strcmp(name, "xor"))
 		mv_l2fw_xor(a, b);
 #endif
@@ -207,7 +209,7 @@ static DEVICE_ATTR(flush,		S_IWUSR, NULL,	mv_l2fw_hex_store);
 #ifdef CONFIG_MV_ETH_L2SEC
 static DEVICE_ATTR(cesa_chan,		S_IWUSR, NULL,  mv_l2fw_store);
 #endif
-#ifdef CONFIG_MV_INCLUDE_XOR
+#ifdef CONFIG_MV_L2FW_XOR
 static DEVICE_ATTR(xor,		S_IWUSR, mv_l2fw_show, mv_l2fw_store);
 #endif
 
@@ -216,7 +218,7 @@ static DEVICE_ATTR(xor,		S_IWUSR, mv_l2fw_show, mv_l2fw_store);
 static struct attribute *mv_l2fw_attrs[] = {
 	&dev_attr_l2fw.attr,
 	&dev_attr_bind.attr,
-#ifdef CONFIG_MV_INCLUDE_XOR
+#ifdef CONFIG_MV_L2FW_XOR
 	&dev_attr_xor.attr,
 #endif
 	&dev_attr_lookup.attr,
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/l2fw/mv_eth_l2fw.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/l2fw/mv_eth_l2fw.c
index 01d2cf7..b95bd27 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/l2fw/mv_eth_l2fw.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/l2fw/mv_eth_l2fw.c
@@ -28,11 +28,11 @@ disclaimer.
 
 #include <linux/version.h>
 
-#ifdef CONFIG_MV_INCLUDE_XOR
+#ifdef CONFIG_MV_ETH_L2FW_XOR
 #include "xor/mvXor.h"
 #include "xor/mvXorRegs.h"
 #include "mv_hal_if/mvSysXorApi.h"
-#endif
+#endif /* CONFIG_MV_ETH_L2FW_XOR */
 
 #include "mv_eth_l2fw.h"
 #include "mv_pp2/net_dev/mv_netdev.h"
@@ -52,7 +52,7 @@ static int eth_ports_l2fw_num;
 
 static MV_U32 l2fw_jhash_iv;
 
-#ifdef CONFIG_MV_INCLUDE_XOR
+#ifdef CONFIG_MV_ETH_L2FW_XOR
 static MV_XOR_DESC *eth_xor_desc;
 static MV_LONG      eth_xor_desc_phys_addr;
 #endif
@@ -511,10 +511,10 @@ inline struct sk_buff *eth_l2fw_copy_packet_withOutXor(struct sk_buff *skb, stru
 	return skb_new;
 }
 
-#ifdef CONFIG_MV_INCLUDE_XOR
+#ifdef CONFIG_MV_ETH_L2FW_XOR
 inline struct sk_buff *eth_l2fw_copy_packet_withXor(struct sk_buff *skb, struct pp2_rx_desc *rx_desc)
 {
-	struct sk_buff *skb_new;
+	struct sk_buff *skb_new = NULL;
 	MV_U8 *pSrc;
 	MV_U8 *pDst;
 	int poolId;
@@ -606,7 +606,7 @@ void mv_l2fw_xor(int rx_port, int threshold)
 	mvOsPrintf("setting port %d threshold to %d in %s\n", rx_port, threshold, __func__);
 	mv_eth_ports_l2fw[rx_port]->xorThreshold = threshold;
 }
-#endif /*CONFIG_MV_INCLUDE_XOR*/
+#endif /* CONFIG_MV_ETH_L2FW_XOR */
 
 void mv_l2fw_lookupEn(int rx_port, int enable)
 {
@@ -779,7 +779,7 @@ inline int mv_l2fw_txq_done(struct eth_port *pp, struct tx_queue *txq_ctrl)
 
 static int mv_l2fw_txq_done_force(struct eth_port *pp, struct tx_queue *txq_ctrl)
 {
-	int cpu, tx_done;
+	int cpu, tx_done = 0;
 	struct txq_cpu_ctrl *txq_cpu_ptr;
 
 	for_each_possible_cpu(cpu) {
@@ -901,7 +901,7 @@ inline int mv_l2fw_rx(struct eth_port *pp, int rx_todo, int rxq)
 	struct eth_port_l2fw *ppl2fw = mv_eth_ports_l2fw[pp->port];
 	MV_IP_HEADER *pIph = NULL;
 	int ipOffset;
-	struct sk_buff *skb, *skb_new;
+	struct sk_buff *skb, *skb_new = NULL;
 	MV_U32 bufPhysAddr, bm;
 
 	rx_done = mvPp2RxqBusyDescNumGet(pp->port, rxq);
@@ -1013,26 +1013,28 @@ inline int mv_l2fw_rx(struct eth_port *pp, int rx_todo, int rxq)
 				status = MV_ERROR;
 				break;
 			}
+#ifdef CONFIG_MV_ETH_L2FW_XOR
 			if (bytes >= ppl2fw->xorThreshold) {
-				printk(KERN_INFO "%s: xor is not supported\n", __func__);
 				skb_new = eth_l2fw_copy_packet_withXor(skb, rx_desc);
-			} else {
-				skb_new = eth_l2fw_copy_packet_withOutXor(skb, rx_desc);
+				pr_error("%s: xor is not supported\n", __func__);
+			}
+#endif /* CONFIG_MV_ETH_L2FW_XOR */
 
-				if (skb_new) {
-					bufPhysAddr = rx_desc->bufPhysAddr;
+			if (skb_new == NULL)
+				skb_new = eth_l2fw_copy_packet_withOutXor(skb, rx_desc);
 
-					bm = mv_eth_bm_cookie_build(rx_desc);
-					status = mv_l2fw_tx(skb_new, new_pp, rx_desc);
+			if (skb_new) {
+				bufPhysAddr = rx_desc->bufPhysAddr;
 
-					mv_eth_pool_refill(pool, bm, bufPhysAddr, (MV_ULONG)skb);
+				bm = mv_eth_bm_cookie_build(rx_desc);
+				status = mv_l2fw_tx(skb_new, new_pp, rx_desc);
 
-					/* for refill function */
-					skb = skb_new;
-				} else
+				mv_eth_pool_refill(pool, bm, bufPhysAddr, (MV_ULONG)skb);
 
+				/* for refill function */
+				skb = skb_new;
+			} else
 				status = MV_ERROR;
-			}
 			break;
 #ifdef CONFIG_MV_ETH_L2SEC
 		case CMD_L2FW_CESA:
@@ -1102,7 +1104,7 @@ static int mv_l2fw_shared_init(void)
 	memset(mv_eth_ports_l2fw, 0, size);
 
 	bytes = sizeof(struct l2fw_rule *) * L2FW_HASH_SIZE;
-	l2fw_jhash_iv = mvOsRand();
+	get_random_bytes(&l2fw_jhash_iv, sizeof(l2fw_jhash_iv));
 	l2fw_hash = (struct l2fw_rule **)mvOsMalloc(bytes);
 
 	if (l2fw_hash == NULL) {
@@ -1118,8 +1120,8 @@ static int mv_l2fw_shared_init(void)
 	mv_l2sec_cesa_init();
 #endif
 
-#ifdef CONFIG_MV_INCLUDE_XOR
-	/*setXorDesc();*/
+#ifdef CONFIG_MV_ETH_L2FW_XOR
+	setXorDesc();
 #endif
 
 	return MV_OK;
-- 
1.7.5.4

