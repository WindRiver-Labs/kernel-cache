From 9708b7694e795a12e4575d10d3daac89a780e2c1 Mon Sep 17 00:00:00 2001
From: Eli Nidam <elini@marvell.com>
Date: Thu, 10 Oct 2013 16:17:48 +0200
Subject: [PATCH 1087/1825] A380: Added Armada 380 (KW28) family

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit b3cde95f7f97cebc337f4db449c40f57fc5f5107

Change-Id: Ic7d12bc4febae512d6d9094d8c5af6c6745655dc
Signed-off-by: Eli Nidam <elini@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/3673
Reviewed-by: Tawfik Bayouk <tawfik@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../armada_38x_family/boardEnv/mvBoardEnvLib.c     |  889 +++++++++-----------
 .../armada_38x_family/boardEnv/mvBoardEnvLib.h     |  209 +++--
 .../armada_38x_family/boardEnv/mvBoardEnvSpec.c    |  359 +++++----
 .../armada_38x_family/boardEnv/mvBoardEnvSpec.h    |  182 +++--
 .../armada_38x_family/ctrlEnv/mvCtrlEnvLib.c       |  355 ++------
 .../armada_38x_family/ctrlEnv/mvCtrlEnvLib.h       |  129 +---
 .../armada_38x_family/ctrlEnv/mvCtrlEnvRegs.h      |  141 ++--
 .../armada_38x_family/ctrlEnv/mvCtrlEnvSpec.h      |    9 +-
 .../armada_38x_family/ctrlEnv/sys/mvCpuIfRegs.h    |    4 +-
 9 files changed, 1039 insertions(+), 1238 deletions(-)

diff --git a/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.c b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.c
index 88b5cc2..7032cc4 100644
--- a/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.c
+++ b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.c
@@ -93,10 +93,12 @@
 extern MV_BOARD_INFO *boardInfoTbl[];
 extern MV_BOARD_SATR_INFO boardSatrInfo[];
 MV_BOARD_CONFIG_TYPE_INFO boardConfigTypesInfo[] = MV_BOARD_CONFIG_INFO;
+MV_BOARD_SATR_INFO boardSatrInfo[] = MV_SAR_INFO;
 
 /* Locals */
 static MV_DEV_CS_INFO *boardGetDevEntry(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
 static MV_BOARD_INFO *board = NULL;
+MV_U32 boardOptionsConfig[MV_CONFIG_TYPE_MAX_OPTION];
 
 
 /*******************************************************************************
@@ -120,10 +122,9 @@ MV_VOID mvBoardEnvInit(MV_VOID)
 {
 	MV_U32 nandDev;
 	MV_U32 norDev;
-
-	mvBoardIdSet(mvBoardIdGet());
 	MV_U32 syncCtrl = 0;
 
+	mvBoardIdSet(mvBoardIdGet());
 	nandDev = boardGetDevCSNum(0, BOARD_DEV_NAND_FLASH);
 	if (nandDev != 0xFFFFFFFF) {
 		/* Set NAND interface access parameters */
@@ -167,7 +168,7 @@ MV_VOID mvBoardEnvInit(MV_VOID)
 }
 
 /*******************************************************************************
-* mvBoardModelGet - Get Board model
+* mvBoardModelGet - Get Board model - (ECO version)
 *
 * DESCRIPTION:
 *       This function returns 16bit describing board model.
@@ -188,7 +189,6 @@ MV_U16 mvBoardModelGet(MV_VOID)
 {
 	return mvBoardIdGet() >> 16;
 }
-
 /*******************************************************************************
 * mbBoardRevlGet - Get Board revision
 *
@@ -206,12 +206,20 @@ MV_U16 mvBoardModelGet(MV_VOID)
 *       None.
 *
 * RETURN:
-*       String describing board model.
 *
 *******************************************************************************/
-MV_U16 mvBoardRevGet(MV_VOID)
+MV_U32 mvBoardRevGet(MV_VOID)
 {
-	return mvBoardIdGet() & 0xFFFF;
+
+	MV_U32 boardECO;
+	MV_U8 readValue;
+
+	if (mvBoardTwsiGet(BOARD_DEV_TWSI_EEPROM, 0, 1, &readValue) != MV_OK) {
+		mvOsPrintf("%s: Error: Read from TWSI failed\n", __func__);
+		return MV_ERROR;
+	}
+	boardECO = (readValue & 0x0F) | ((readValue & 0x0f0) << 12);
+	return boardECO;
 }
 
 /*******************************************************************************
@@ -257,6 +265,14 @@ MV_STATUS mvBoardNameGet(char *pNameBuff, MV_U32 size)
 *******************************************************************************/
 MV_BOOL mvBoardIsPortInSgmii(MV_U32 ethPortNum)
 {
+	MV_U8 readValue;
+
+	if (mvBoardTwsiGet(BOARD_TWSI_MODULE_DETECT, 2, 0, &readValue) != MV_OK) {
+		mvOsPrintf("%s: Error: Read from TWSI failed\n", __func__);
+		return MV_FALSE;
+	}
+	if (readValue == 0x0d)
+		return MV_TRUE;
 	return MV_FALSE;
 }
 
@@ -426,7 +442,7 @@ MV_U32 mvBoardTclkGet(MV_VOID)
 {
 	MV_U32 tclk;
 	tclk = (MV_REG_READ(MPP_SAMPLE_AT_RESET(1)));
-	tclk = ((tclk & 0x400000) >> 22);
+	tclk = ((tclk & (1 << 22)) >> 22);
 	switch (tclk) {
 	case 0:
 		return MV_BOARD_TCLK_166MHZ;
@@ -585,31 +601,6 @@ MV_32 mvBoardResetGpioPinGet(MV_VOID)
 }
 
 /*******************************************************************************
-* mvBoardSDIOGpioPinGet
-*
-* DESCRIPTION:
-*	used for hotswap detection
-* INPUT:
-*	type - Type of SDIO GPP to get.
-*
-* OUTPUT:
-*	None.
-*
-* RETURN:
-*       GPIO pin number. The function return -1 for bad parameters.
-*
-*******************************************************************************/
-MV_32 mvBoardSDIOGpioPinGet(MV_BOARD_GPP_CLASS type)
-{
-	if (type != BOARD_GPP_SDIO_POWER &&
-	    type != BOARD_GPP_SDIO_DETECT &&
-	    type != BOARD_GPP_SDIO_WP)
-		return MV_FAIL;
-
-	return mvBoarGpioPinNumGet(type, 0);
-}
-
-/*******************************************************************************
 * mvBoardUSBVbusGpioPinGet - return Vbus input GPP
 *
 * DESCRIPTION:
@@ -705,7 +696,7 @@ MV_U32 mvBoardGpioIntMaskGet(MV_U32 gppGrp)
 *******************************************************************************/
 MV_U32 mvBoardSlicUnitTypeGet(MV_VOID)
 {
-	return board->pBoardModTypeValue->boardMppSlic;
+	return MV_BOARD_SLIC_DISABLED;
 }
 
 /*******************************************************************************
@@ -727,7 +718,6 @@ MV_U32 mvBoardSlicUnitTypeGet(MV_VOID)
 *******************************************************************************/
 MV_VOID mvBoardSlicUnitTypeSet(MV_U32 slicType)
 {
-	board->pBoardModTypeValue->boardMppSlic = slicType;
 }
 /*******************************************************************************
 * mvBoardMppGet - Get board dependent MPP register value
@@ -822,27 +812,62 @@ MV_VOID mvBoardMppTypeSet(MV_U32 mppGroupNum, MV_U32 groupType)
 *******************************************************************************/
 MV_VOID mvBoardInfoUpdate(MV_VOID)
 {
-	MV_U32 ethComplex;
-
-	/* Update SMI phy address for MAC0/1 */
-	ethComplex = mvBoardEthComplexConfigGet();
-
-	if (ethComplex & MV_ETHCOMP_GE_MAC0_2_RGMII0)
-		mvBoardPhyAddrSet(0, 0x0);
-	else
-		mvBoardPhyAddrSet(0, -1); /* no SMI address if connected to switch */
+	MV_U8 readValue;
+	MV_BOARD_CONFIG_TYPE_INFO configInfo;
+	MV_U32 boardId = mvBoardIdGet();
+	int i;
 
+	memset(&boardOptionsConfig, 0x0, sizeof(MV_U32) * MV_CONFIG_TYPE_MAX_OPTION);
+
+	/*Read all TWSI board module if exsist : */
+	/* Save values Locally in configVal[] */
+	for (i = 0; i < MV_CONFIG_TYPE_MAX_OPTION; i++) {
+		if (mvBoardConfigTypeGet(i, &configInfo) == MV_TRUE) {
+			if (mvBoardTwsiGet(configInfo.twsiAddr, configInfo.offset, 0, &readValue) != MV_OK) {
+				mvOsPrintf("%s: Error: Read from TWSI failed\n", __func__);
+				return;
+			}
+			if ((configInfo.twsiId == readValue) &&
+				(configInfo.isActiveForBoard[boardId]))
+				boardOptionsConfig[configInfo.configId] = 1;
+		}
+	}
 	/* Update MPP group types and values according to board configuration */
 	mvBoardMppIdUpdate();
-
+	mvBoardEthComplexInfoUpdate();
+}
+/*******************************************************************************
+* mvBoardIsModuleConnected
+*
+* DESCRIPTION:
+*	Checks if a given Module connected to board.
+*
+* INPUT:
+*	Module ID
+*
+* OUTPUT:
+*       None
+*
+* RETURN:
+*	MV_TRUE if Module is connected, MV_FALSE otherwise.
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsModuleConnected(MV_U32 ModuleID)
+{
+	if (ModuleID >= MV_CONFIG_TYPE_MAX_OPTION)
+		return MV_FALSE;
+	if (boardOptionsConfig[ModuleID] == 1)
+		return MV_TRUE;
+	return MV_FALSE;
 }
 
 /*******************************************************************************
 * mvBoardMppIdUpdate - Update MPP ID's according to modules auto-detection.
 *
 * DESCRIPTION:
-*	Update MPP ID's according to boot source
+*	Update MPP ID's according to on-board modules as detected using TWSI bus.
 *	Update board information for changed mpp values
+	Must run AFTER mvBoardEthComplexInfoUpdate
 *
 * INPUT:
 *	None.
@@ -856,11 +881,46 @@ MV_VOID mvBoardInfoUpdate(MV_VOID)
 *******************************************************************************/
 MV_VOID mvBoardMppIdUpdate(MV_VOID)
 {
-	/* MPP Groups initialization : */
-	/* Set Group 0-1 - Boot device (else if booting from SPI1: Set Groups 3-4) */
-	mvBoardBootDeviceGroupSet();
+	/*
+	if (mvBoardIsModuleConnected(MV_CONFIG_MII)) {
+	}
+	if (mvBoardIsModuleConnected(MV_CONFIG_NOR)) {
+	}
+	if (mvBoardIsModuleConnected(MV_CONFIG_NAND)) {
+	}
+	if (mvBoardIsModuleConnected(MV_CONFIG_SDIO)) {
+	}
+	if (mvBoardIsModuleConnected(MV_CONFIG_SLIC_TDM_DEVICE)) {
+	}
+	if (mvBoardIsModuleConnected(MV_CONFIG_I2S_DEVICE)) {
+	}
+	if (mvBoardIsModuleConnected(MV_CONFIG_SPDIF_DEVICE)) {
+	}
+*/
 }
 
+/*******************************************************************************
+* mvBoardEthComplexInfoUpdate
+*
+* DESCRIPTION:
+*	Update etherntComplex configuration,
+*	according to modules detection (S@R & board configuration)
+*
+** INPUT:
+*	None.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_OK - on success,
+*	MV_ERROR - On failure.
+*
+*******************************************************************************/
+MV_STATUS mvBoardEthComplexInfoUpdate(MV_VOID)
+{
+	return MV_OK;
+}
 
 /*******************************************************************************
 * mvBoardBootDeviceGroupSet - test board Boot configuration and set MPP groups
@@ -884,13 +944,13 @@ MV_BOARD_BOOT_SRC mvBoardBootDeviceGroupSet()
 	MV_BOARD_BOOT_SRC bootSrc = mvBoardBootDeviceGet();
 
 	switch (bootSrc) {
+	case MSAR_0_BOOT_NOR_FLASH:
+		break;
 	case MSAR_0_BOOT_NAND_NEW:
-		mvBoardMppTypeSet(0, NAND_BOOT_V2);
-		mvBoardMppTypeSet(1, NAND_BOOT_V2);
 		break;
 	case MSAR_0_BOOT_SPI_FLASH:
-		mvBoardMppTypeSet(0, SPI0_BOOT);
-		mvBoardMppTypeSet(1, SPI0_BOOT);
+		break;
+	case MSAR_0_BOOT_SPI1_FLASH:
 		break;
 	default:
 		return MV_ERROR;
@@ -914,9 +974,18 @@ MV_BOARD_BOOT_SRC mvBoardBootDeviceGroupSet()
 *******************************************************************************/
 MV_BOARD_BOOT_SRC mvBoardBootDeviceGet()
 {
-	MV_U32 satrBootDeviceValue = mvCtrlSatRRead(MV_SATR_BOOT_DEVICE);
+	MV_U32 satrBootDeviceValue;
 	MV_SATR_BOOT_TABLE satrTable[] = MV_SATR_TABLE_VAL;
-	MV_SATR_BOOT_TABLE satrBootEntry = satrTable[satrBootDeviceValue];
+	MV_SATR_BOOT_TABLE satrBootEntry;
+
+	satrBootDeviceValue = mvBoardSatRRead(MV_SATR_BOOT_DEVICE);
+	if (satrBootDeviceValue == MV_ERROR) {
+		mvOsPrintf("%s: Error: failed to read boot source\n", __func__);
+		mvOsPrintf("Using NAND as the default boot source\n");
+		return MSAR_0_BOOT_SPI_FLASH; /* SPI is the Default Boot source */
+	}
+
+	satrBootEntry = satrTable[satrBootDeviceValue];
 
 	if (satrBootEntry.bootSrc != MSAR_0_BOOT_SPI_FLASH)
 		return satrBootEntry.bootSrc;
@@ -963,83 +1032,6 @@ MV_U32 mvBoardBootAttrGet(MV_U32 satrBootDeviceValue, MV_U8 attrNum)
 }
 
 /*******************************************************************************
-* mvBoardIsLaneSGMII - check if a board lane is configured to SGMII-0
-*
-* DESCRIPTION:
-*	test board configuration regarding lanes-1/2/3
-*	if one of them is configured to SGMII-0 , will return its MV_ETH_COMPLEX_TOPOLOGY define
-*	else return error
-*
-* INPUT:  None.
-*
-* OUTPUT:  None.
-*
-* RETURN:
-*       value =MV_ETH_COMPLEX_GE_MAC0_COMPHY_1/2/3 if lanes 1/2/3 are SGMII-0 (adaptively)
-*       or -1 if none of them is SGMII-0
-*
-*******************************************************************************/
-MV_ETH_COMPLEX_TOPOLOGY mvBoardLaneSGMIIGet()
-{
-	MV_U32 laneConfig;
-	/* Lane 1 */
-	laneConfig = mvCtrlSysConfigGet(MV_CONFIG_LANE1);
-	if (laneConfig == MV_ERROR)
-		return MV_ERROR;
-	else if (laneConfig == 0x1)
-		return MV_ETHCOMP_GE_MAC0_2_COMPHY_1;
-	/* Lane 2 */
-	laneConfig = mvCtrlSysConfigGet(MV_CONFIG_LANE2);
-	if (laneConfig == MV_ERROR)
-		return MV_ERROR;
-	else if (laneConfig == 0x0)
-		return MV_ETHCOMP_GE_MAC0_2_COMPHY_2;
-	/* Lane 3 */
-	laneConfig = mvCtrlSysConfigGet(MV_CONFIG_LANE3);
-	if (laneConfig == MV_ERROR)
-		return MV_ERROR;
-	else if (laneConfig == 0x1)
-		return MV_ETHCOMP_GE_MAC0_2_COMPHY_3;
-
-	mvOsPrintf("%s: Error: unexpected value for Serdes Lane board configuration\n", __func__);
-	return MV_ERROR;
-}
-
-/*******************************************************************************
-* mvBoardIsInternalSwitchConnectedToPort
-*
-* DESCRIPTION:
-*       This routine returns port's connection status
-*
-* INPUT:
-*       ethPortNum - Ethernet port number.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*       1 - if ethPortNum is connected to switch, 0 otherwise
-*
-*******************************************************************************/
-MV_STATUS mvBoardIsInternalSwitchConnectedToPort(MV_U32 ethPortNum)
-{
-	MV_U32 ethComplex = mvBoardEthComplexConfigGet();
-
-	if (ethPortNum >= board->numBoardMacInfo) {
-		mvOsPrintf("%s: Error: Illegal port number(%u)\n", __func__, ethPortNum);
-		return MV_FALSE;
-	}
-
-	/* Check if internal switch is connected */
-	if ((ethPortNum == 0) && (ethComplex & MV_ETHCOMP_GE_MAC0_2_SW_P6))
-		return MV_TRUE;
-	else if ((ethPortNum == 1) && (ethComplex & MV_ETHCOMP_GE_MAC1_2_SW_P4))
-		return MV_TRUE;
-	else
-		return MV_FALSE;
-}
-
-/*******************************************************************************
 * mvBoardIsInternalSwitchConnected
 *
 * DESCRIPTION:
@@ -1057,47 +1049,7 @@ MV_STATUS mvBoardIsInternalSwitchConnectedToPort(MV_U32 ethPortNum)
 *******************************************************************************/
 MV_STATUS mvBoardIsInternalSwitchConnected(void)
 {
-	MV_U32 ethComplex = mvBoardEthComplexConfigGet();
-
-	if ((ethComplex & MV_ETHCOMP_GE_MAC0_2_SW_P6) ||
-	    (ethComplex & MV_ETHCOMP_GE_MAC1_2_SW_P4))
-		return MV_TRUE;
-	else
-		return MV_FALSE;
-}
-
-/*******************************************************************************
-* mvBoardSwitchConnectedPortGet -
-*
-* DESCRIPTION:
-*       This routine returns the switch port connected to the ethPort
-*
-* INPUT:
-*       ethPortNum - Ethernet port number.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*	switch port connected to the ethPort
-*
-*******************************************************************************/
-MV_32 mvBoardSwitchConnectedPortGet(MV_U32 ethPort)
-{
-	MV_U32 ethComplex = mvBoardEthComplexConfigGet();
-
-	if (ethPort >= board->numBoardMacInfo) {
-		mvOsPrintf("%s: Error: Illegal port number(%u)\n", __func__, ethPort);
-		return MV_FALSE;
-	}
-
-	if ((ethPort == 0) && (ethComplex & MV_ETHCOMP_GE_MAC0_2_SW_P6))
-		return 6;
-	else if ((ethPort == 1) && (ethComplex & MV_ETHCOMP_GE_MAC1_2_SW_P4))
-		return 4;
-	else
-		return -1;
-
+	return MV_FALSE;
 }
 
 /*******************************************************************************
@@ -1117,22 +1069,7 @@ MV_32 mvBoardSwitchConnectedPortGet(MV_U32 ethPort)
 *******************************************************************************/
 MV_U32 mvBoardSwitchPortsMaskGet(MV_U32 switchIdx)
 {
-	MV_U32 mask = 0, c = mvBoardEthComplexConfigGet();
-
-	if (c & MV_ETHCOMP_SW_P0_2_GE_PHY_P0)
-		mask |= BIT0;
-	if (c & MV_ETHCOMP_SW_P1_2_GE_PHY_P1)
-		mask |= BIT1;
-	if (c & MV_ETHCOMP_SW_P2_2_GE_PHY_P2)
-		mask |= BIT2;
-	if (c & MV_ETHCOMP_SW_P3_2_GE_PHY_P3)
-		mask |= BIT3;
-	if ((c & MV_ETHCOMP_SW_P4_2_RGMII0) || (c & MV_ETHCOMP_GE_MAC1_2_SW_P4))
-		mask |= BIT4;
-	if (c & MV_ETHCOMP_GE_MAC0_2_SW_P6)
-		mask |= BIT6;
-
-	return mask;
+	return 0;
 }
 
 /*******************************************************************************
@@ -1153,14 +1090,13 @@ MV_U32 mvBoardSwitchPortsMaskGet(MV_U32 switchIdx)
 *******************************************************************************/
 MV_U32 mvBoardSwitchPortForceLinkGet(MV_U32 switchIdx)
 {
-	return board->switchforceLinkMask;
+	return 0;
 }
 
 /*******************************************************************************
 * mvBoardFreqModesNumGet
 *
-* DESCRIPTION:
-*      Return the number of supported frequency modes for this board
+* DESCRIPTION: Return the number of supported frequency modes for this SoC
 *
 *
 * INPUT:
@@ -1175,13 +1111,21 @@ MV_U32 mvBoardSwitchPortForceLinkGet(MV_U32 switchIdx)
 *******************************************************************************/
 MV_U32 mvBoardFreqModesNumGet()
 {
-	MV_U16 ctrlModel = mvCtrlModelGet();
+	MV_U32 freqNum;
 
-	if (ctrlModel == MV_6720_DEV_ID)
-		return FREQ_MODES_NUM_6720;
+	switch (mvCtrlModelGet()) {
+	case MV_6810_DEV_ID:
+		freqNum = FREQ_MODES_NUM_6810;
+		break;
+	case MV_6820_DEV_ID:
+		freqNum = FREQ_MODES_NUM_6820;
+		break;
+	default:
+		mvOsPrintf("%s: Error: failed to read ctrlModel (SoC ID)\n", __func__);
+		return MV_ERROR;
+	}
 
-	mvOsPrintf("%s: Error: Illegal ctrl Model (%x)\n", __func__, ctrlModel);
-	return MV_ERROR;
+	return freqNum;
 }
 
 
@@ -1224,112 +1168,6 @@ MV_VOID mvBoardConfigWrite(void)
 		}
 	}
 }
-
-/*******************************************************************************
-* mvBoardGppConfigGet
-*
-* DESCRIPTION:
-*	Get board configuration according to the input configuration GPP's.
-*
-* INPUT:
-*       None.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*	The value of the board configuration GPP's.
-*
-*******************************************************************************/
-MV_U32 mvBoardGppConfigGet(void)
-{
-	MV_U32 gpp, i, result = 0;
-
-	for (i = 0; i < board->numBoardGppInfo; i++) {
-		if (board->pBoardGppInfo[i].devClass == BOARD_GPP_CONF) {
-			gpp = board->pBoardGppInfo[i].gppPinNum;
-			result <<= 1;
-			result |= (mvGppValueGet(gpp >> 5, 1 << (gpp & 0x1F)) >> (gpp & 0x1F));
-		}
-	}
-
-	return result;
-}
-
-/*******************************************************************************
-* mvBoardTdmSpiModeGet - return SLIC/DAA connection
-*
-* DESCRIPTION:
-*
-* INPUT:
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*
-*******************************************************************************/
-MV_32 mvBoardTdmSpiModeGet(MV_VOID)
-{
-	return 0;
-}
-
-/*******************************************************************************
-* mvBoardTdmDevicesCountGet
-*
-* DESCRIPTION:
-*	Return the number of TDM devices on board.
-*
-* INPUT:
-*	None.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*	Number of devices.
-*
-*******************************************************************************/
-MV_U8 mvBoardTdmDevicesCountGet(void)
-{
-	MV_16 index = board->boardTdmInfoIndex;
-
-	if (index == -1)
-		return 0;
-
-	return board->numBoardTdmInfo[index];
-}
-
-/*******************************************************************************
-* mvBoardTdmSpiCsGet
-*
-* DESCRIPTION:
-*	Return the SPI Chip-select number for a given device.
-*
-* INPUT:
-*	devId	- The Slic device ID to get the SPI CS for.
-*
-* OUTPUT:
-*       None.
-*
-* RETURN:
-*	The SPI CS if found, -1 otherwise.
-*
-*******************************************************************************/
-MV_U8 mvBoardTdmSpiCsGet(MV_U8 devId)
-{
-	MV_16 index;
-
-	index = board->boardTdmInfoIndex;
-	if (index == -1)
-		return 0;
-
-	if (devId >= board->numBoardTdmInfo[index])
-		return -1;
-
-	return board->pBoardTdmInt2CsInfo[index][devId].spiCs;
-}
-
 /*******************************************************************************
 * mvBoardMppModuleTypePrint
 *
@@ -1348,74 +1186,31 @@ MV_U8 mvBoardTdmSpiCsGet(MV_U8 devId)
 *******************************************************************************/
 MV_VOID mvBoardMppModuleTypePrint(MV_VOID)
 {
-	MV_U32 ethConfig = mvBoardEthComplexConfigGet();
-
+	int i;
+	char *moduleStr[MV_CONFIG_TYPE_MAX_OPTION] = { \
+		"SGMII",                                \
+		"MII",                                  \
+		"TDM",                                  \
+		"I2S",                                  \
+		"SPDIF",                                \
+		"SERDES PEX LANE1",                     \
+		"SERDES PEX LANE2",                     \
+		"NOR",                                  \
+		"NAND",                                 \
+		"SDIO",                                 \
+		"GIGA"
+	};
 	mvOsOutput("Board configuration detected:\n");
 
-	/* TDM */
-	if (mvBoardTdmDevicesCountGet() > 0)
-		mvOsOutput("       TDM module.\n");
-
-	/* LCD DVI Module */
-	if (mvBoardIsLcdDviModuleConnected())
-		mvOsOutput("       LCD DVI module.\n");
-
-	/* Switch Module */
-	if ((ethConfig & MV_ETHCOMP_GE_MAC0_2_SW_P6) &&
-		!(ethConfig & MV_ETHCOMP_GE_MAC1_2_SW_P4))
-		mvOsOutput("       Ethernet Switch port 6 on MAC0 [Default]\n");
-	else if ((ethConfig & MV_ETHCOMP_GE_MAC1_2_SW_P4) &&
-		!(ethConfig & MV_ETHCOMP_GE_MAC0_2_SW_P6))
-		mvOsOutput("       Ethernet Switch port 4 on MAC1 [Default]\n");
-	else if ((ethConfig & MV_ETHCOMP_GE_MAC0_2_SW_P6) &&
-		(ethConfig & MV_ETHCOMP_GE_MAC1_2_SW_P4)) {
-		mvOsOutput("       Ethernet Switch port 6 on MAC0 [Default]\n");
-		mvOsOutput("       Ethernet Switch port 4 on MAC1\n");
-	}
+	for (i = 0; i < MV_CONFIG_TYPE_MAX_OPTION; i++) {
+		if (mvBoardIsModuleConnected(i))
+			mvOsOutput("       %s module.\n", moduleStr[i]);
 
-	/* RGMII */
-	if (ethConfig & MV_ETHCOMP_GE_MAC0_2_RGMII0)
-		mvOsOutput("       RGMII0 Module on MAC0\n");
-	if (ethConfig & MV_ETHCOMP_GE_MAC1_2_RGMII1)
-		mvOsOutput("       RGMII1 on MAC1\n");
-	if (ethConfig & MV_ETHCOMP_SW_P4_2_RGMII0)
-		mvOsOutput("       RGMII0 Module on Switch port #4\n");
-
-	/* Internal GE Quad Phy */
-	if (ethConfig & MV_ETHCOMP_GE_MAC0_2_GE_PHY_P0)
-			mvOsOutput("       GE-PHY-0 on MAC0\n");
-	if (ethConfig & MV_ETHCOMP_GE_MAC1_2_GE_PHY_P3)
-			mvOsOutput("       GE-PHY-3 on MAC1\n");
-	if ((ethConfig & MV_ETHCOMP_SW_P0_2_GE_PHY_P0) && (ethConfig & MV_ETHCOMP_SW_P1_2_GE_PHY_P1)
-		&& (ethConfig & MV_ETHCOMP_SW_P2_2_GE_PHY_P2) && (ethConfig & MV_ETHCOMP_SW_P3_2_GE_PHY_P3))
-			mvOsOutput("       4xGE-PHY Module on 4 Switch ports\n");
-	else {
-		if (ethConfig & MV_ETHCOMP_SW_P0_2_GE_PHY_P0)
-			mvOsOutput("       GE-PHY-0 Module on Switch port #0\n");
-		if (ethConfig & MV_ETHCOMP_SW_P1_2_GE_PHY_P1)
-			mvOsOutput("       GE-PHY-1 Module on Switch port #1\n");
-		if (ethConfig & MV_ETHCOMP_SW_P2_2_GE_PHY_P2)
-			mvOsOutput("       GE-PHY-2 Module on Switch port #2\n");
-		if (ethConfig & MV_ETHCOMP_SW_P3_2_GE_PHY_P3)
-			mvOsOutput("       GE-PHY-3 Module on Switch port #3\n");
 	}
-
-
-
-
 }
 
 MV_VOID mvBoardOtherModuleTypePrint(MV_VOID)
 {
-	/* Pex Module */
-	if (mvBoardIsPexModuleConnected())
-		mvOsOutput("       PEX module.\n");
-	/* SETM Module */
-	if (mvBoardIsSetmModuleConnected())
-		mvOsOutput("       SETM module.\n");
-	/* LVDS Module */
-	if (mvBoardIsLvdsModuleConnected())
-		mvOsOutput("       LVDS module.\n");
 }
 
 /*******************************************************************************
@@ -1728,7 +1523,7 @@ MV_U8 mvBoardTwsiAddrGet(MV_BOARD_TWSI_CLASS twsiClass, MV_U32 index)
 *******************************************************************************/
 MV_U32 mvBoardEthComplexConfigGet(MV_VOID)
 {
-	return board->pBoardModTypeValue->ethSataComplexOpt;
+	return 0;
 }
 
 /*******************************************************************************
@@ -1750,8 +1545,6 @@ MV_U32 mvBoardEthComplexConfigGet(MV_VOID)
 *******************************************************************************/
 MV_VOID mvBoardEthComplexConfigSet(MV_U32 ethConfig)
 {
-	/* Set ethernet complex configuration. */
-	board->pBoardModTypeValue->ethSataComplexOpt = ethConfig;
 	return;
 }
 
@@ -1771,22 +1564,14 @@ MV_VOID mvBoardEthComplexConfigSet(MV_U32 ethConfig)
 *	MV_BOARD_SATR_INFO struct with mask, offset and register number.
 *
 *******************************************************************************/
-MV_STATUS mvBoardSatrInfoConfig(MV_SATR_TYPE_ID satrClass, MV_BOARD_SATR_INFO *satrInfo, MV_BOOL read)
+MV_STATUS mvBoardSatrInfoConfig(MV_SATR_TYPE_ID satrClass, MV_BOARD_SATR_INFO *satrInfo)
 {
-	int i, start, end;
+	int i;
 	MV_U32 boardId = mvBoardIdGet();
 
-	if (read == MV_TRUE) {	/* if read request, check read SATR fields */
-		start = 0;
-		end = MV_SATR_READ_MAX_OPTION;
-	} else {		/* if write request, check write SATR fields */
-		start = MV_SATR_READ_MAX_OPTION;
-		end = MV_SATR_WRITE_MAX_OPTION;
-	}
-
 	/* verify existence of requested SATR type, pull its data,
 	 * and check if field is relevant to current running board */
-	for (i = start; i < end ; i++)
+	for (i = 0; i < MV_SATR_MAX_OPTION ; i++)
 		if (boardSatrInfo[i].satrId == satrClass) {
 			*satrInfo = boardSatrInfo[i];
 			if (boardSatrInfo[i].isActiveForBoard[boardId])
@@ -1929,12 +1714,14 @@ MV_VOID mvBoardIdSet(MV_U32 boardId)
 *******************************************************************************/
 MV_U32 mvBoardIdGet(MV_VOID)
 {
-	MV_U32 boardId, value;
-	/*Fake board ID, TODO fix*/
-	return 0x0;
+	MV_U32 boardId;
+	MV_U8 readValue;
 
-	value = MV_REG_READ(MPP_SAMPLE_AT_RESET(1));
-	boardId = ((value & (0xF0)) >> 4);
+	if (mvBoardTwsiGet(BOARD_DEV_TWSI_EEPROM, 0, 0, &readValue) != MV_OK) {
+		mvOsPrintf("%s: Error: Read from TWSI failed\n", __func__);
+		return MV_ERROR;
+	}
+	boardId = readValue & 0x07;
 
 	if (boardId >= MV_MAX_BOARD_ID) {
 		mvOsPrintf("%s: Error: read wrong board (%d)\n", __func__, boardId);
@@ -2049,48 +1836,6 @@ MV_U8 mvBoardCpuCoresNumGet(MV_VOID)
 *******************************************************************************/
 
 /*******************************************************************************
-* mvBoardMppModulesScan
-*
-* DESCRIPTION:
-*	Scan for modules connected through MPP lines.
-*
-* INPUT:
-*	None.
-*
-* OUTPUT:
-*	None
-*
-* RETURN:
-*       MV_STATUS - MV_OK, MV_ERROR.
-*
-*******************************************************************************/
-MV_STATUS mvBoardMppModulesScan(void)
-{
-	return MV_OK;
-}
-
-/*******************************************************************************
-* mvBoardIsPexModuleConnected
-*
-* DESCRIPTION:
-*	Check if PEX module is connected to the board.
-*
-* INPUT:
-*	None.
-*
-* OUTPUT:
-*	None
-*
-* RETURN:
-*       MV_TRUE / MV_FALSE
-*
-*******************************************************************************/
-MV_BOOL mvBoardIsPexModuleConnected(void)
-{
-	return MV_FALSE;
-}
-
-/*******************************************************************************
 * mvBoardIsSetmModuleConnected
 *
 * DESCRIPTION:
@@ -2108,28 +1853,7 @@ MV_BOOL mvBoardIsPexModuleConnected(void)
 *******************************************************************************/
 MV_BOOL mvBoardIsSetmModuleConnected(void)
 {
-	return MV_FALSE;
-}
-
-/*******************************************************************************
-* mvBoardIsLvdsModuleConnected
-*
-* DESCRIPTION:
-*	Check if LVDS module is connected to the board.
-*
-* INPUT:
-*	None.
-*
-* OUTPUT:
-*	None
-*
-* RETURN:
-*       MV_TRUE / MV_FALSE
-*
-*******************************************************************************/
-MV_BOOL mvBoardIsLvdsModuleConnected(void)
-{
-	return MV_FALSE;
+	return mvBoardIsModuleConnected(MV_CONFIG_SLIC_TDM_DEVICE);
 }
 
 /*******************************************************************************
@@ -2173,32 +1897,6 @@ MV_STATUS mvBoardTwsiMuxChannelSet(MV_U8 muxChNum)
 {
 	return MV_ERROR;
 }
-
-/*******************************************************************************
-* mvBoardTwsiReadByteThruMux
-*
-* DESCRIPTION:
-*	Read a single byte from a TWSI device through the TWSI Mux.
-*
-* INPUT:
-*	muxChNum	- The Twsi Mux channel number to read through.
-*	chNum		- The TWSI channel number.
-*	pTwsiSlave	- The TWSI slave address.
-*	data		- Buffer to read into (1 byte).
-*
-* OUTPUT:
-*	None.
-*
-* RETURN:
-*       MV_STATUS - MV_OK, MV_ERROR.
-*
-*******************************************************************************/
-MV_STATUS mvBoardTwsiReadByteThruMux(MV_U8 muxChNum, MV_U8 chNum,
-				     MV_TWSI_SLAVE *pTwsiSlave, MV_U8 *data)
-{
-	return MV_ERROR;
-}
-
 /*******************************************************************************
 * mvBoardSmiScanModeGet - Get Switch SMI scan mode
 *
@@ -2238,17 +1936,7 @@ MV_32 mvBoardSmiScanModeGet(MV_U32 switchIdx)
 *******************************************************************************/
 MV_U32 mvBoardSwitchCpuPortGet(MV_U32 switchIdx)
 {
-	MV_U32 c = board->pBoardModTypeValue->ethSataComplexOpt;
-	MV_U32 cpuPort = -1;
-
-	if (c & MV_ETHCOMP_GE_MAC0_2_SW_P6)
-		cpuPort = 6;
-	else if (c & MV_ETHCOMP_GE_MAC1_2_SW_P4)
-		cpuPort = 4;
-	else
-		mvOsPrintf("%s: Error: No CPU port.\n", __func__);
-
-	return cpuPort;
+	return -1;
 }
 
 /*******************************************************************************
@@ -2267,7 +1955,7 @@ MV_U32 mvBoardSwitchCpuPortGet(MV_U32 switchIdx)
 *	MV_TRUE if the requested ethernet port is connected.
 *
 *******************************************************************************/
-MV_U32 mvBoardIsEthConnected(MV_U32 ethNum)
+MV_BOOL mvBoardIsEthConnected(MV_U32 ethNum)
 {
 	if (ethNum == 0)
 		return MV_TRUE;
@@ -2364,24 +2052,6 @@ MV_32 mvBoardRgmiiASwitchPortGet(MV_VOID)
 *******************************************************************************/
 MV_32 mvBoardSwitchPortMap(MV_U32 switchIdx, MV_U32 switchPortNum)
 {
-	MV_U32 ethComplex = mvBoardEthComplexConfigGet();
-	if (switchPortNum >= BOARD_ETH_SWITCH_PORT_NUM) {
-		mvOsPrintf("%s: Error: wrong switch port number (%d)\n", __func__, switchPortNum);
-		return -1;
-	}
-
-	if ((switchPortNum == 0) && (ethComplex & MV_ETHCOMP_SW_P0_2_GE_PHY_P0))
-		return 0;
-	else if ((switchPortNum == 1) && (ethComplex & MV_ETHCOMP_SW_P1_2_GE_PHY_P1))
-		return 1;
-	else if ((switchPortNum == 2) && (ethComplex & MV_ETHCOMP_SW_P2_2_GE_PHY_P2))
-		return 2;
-	else if ((switchPortNum == 3) && (ethComplex & MV_ETHCOMP_SW_P3_2_GE_PHY_P3))
-		return 3;
-	else if ((switchPortNum == 4) && (ethComplex & MV_ETHCOMP_SW_P4_2_RGMII0))
-		return 4;
-
-	mvOsPrintf("%s: Error: switch port map not found\n", __func__);
 	return -1;
 }
 
@@ -2424,3 +2094,218 @@ MV_BOOL mvBoardConfigAutoDetectEnabled()
 {
 	return board->configAutoDetect;
 }
+/*******************************************************************************
+* mvBoardTwsiSatRGet -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*	device num - one of three devices
+*	reg num - 0 or 1
+*
+* OUTPUT:
+*		None.
+*
+* RETURN:
+*		reg value
+*
+*******************************************************************************/
+MV_STATUS mvBoardTwsiSatRGet(MV_U8 devNum, MV_U8 regNum, MV_U8 *pData)
+{
+	MV_TWSI_SLAVE twsiSlave;
+	MV_TWSI_ADDR slave;
+
+	/* Read MPP module ID */
+	DB(mvOsPrintf("Board: Read S@R device read\n"));
+	twsiSlave.slaveAddr.address = mvBoardTwsiAddrGet(BOARD_DEV_TWSI_SATR, devNum);
+	if (0xFF == twsiSlave.slaveAddr.address)
+		return MV_ERROR;
+	twsiSlave.slaveAddr.type = mvBoardTwsiAddrTypeGet(BOARD_DEV_TWSI_SATR, devNum);
+
+	/* Use offset as command */
+	twsiSlave.offset = regNum;
+	twsiSlave.moreThen256 = MV_FALSE;
+	twsiSlave.validOffset = MV_TRUE;
+
+	/* TWSI init */
+	slave.type = ADDR7_BIT;
+	slave.address = 0;
+	mvTwsiInit(0, TWSI_SPEED, mvBoardTclkGet(), &slave, 0);
+
+
+	if (MV_OK != mvTwsiRead(0, &twsiSlave, pData, 1)) {
+		DB(mvOsPrintf("Board: Read S@R fail\n"));
+		return MV_ERROR;
+	}
+	DB(mvOsPrintf("Board: Read S@R succeded\n"));
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvBoardTwsiSatRSet -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*	devNum - one of three devices
+*	regNum - 0 or 1
+*	regVal - value
+*
+*
+* OUTPUT:
+*		None.
+*
+* RETURN:
+*		reg value
+*
+*******************************************************************************/
+MV_STATUS mvBoardTwsiSatRSet(MV_U8 devNum, MV_U8 regNum, MV_U8 regVal)
+{
+	MV_TWSI_SLAVE twsiSlave;
+	MV_TWSI_ADDR slave;
+
+	/* Read MPP module ID */
+	twsiSlave.slaveAddr.address = mvBoardTwsiAddrGet(BOARD_DEV_TWSI_SATR, devNum);
+	if (0xFF == twsiSlave.slaveAddr.address)
+		return MV_ERROR;
+	twsiSlave.slaveAddr.type = mvBoardTwsiAddrTypeGet(BOARD_DEV_TWSI_SATR, devNum);
+	twsiSlave.validOffset = MV_TRUE;
+	DB(mvOsPrintf("Board: Write S@R device addr %x, type %x, data %x\n",
+		      twsiSlave.slaveAddr.address, twsiSlave.slaveAddr.type, regVal));
+	/* Use offset as command */
+	twsiSlave.offset = regNum;
+	twsiSlave.moreThen256 = MV_FALSE;
+	/* TWSI init */
+	slave.type = ADDR7_BIT;
+	slave.address = 0;
+	mvTwsiInit(0, TWSI_SPEED, mvBoardTclkGet(), &slave, 0);
+
+	if (MV_OK != mvTwsiWrite(0, &twsiSlave, &regVal, 1)) {
+		DB(mvOsPrintf("Board: Write S@R fail\n"));
+		return MV_ERROR;
+	}
+	DB(mvOsPrintf("Board: Write S@R succeded\n"));
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvBoardSatRRead
+*
+* DESCRIPTION: Read S@R configuration Field
+*
+* INPUT: satrField - Field description enum
+*
+* OUTPUT: None
+*
+* RETURN:
+*	if field is valid - returns requested S@R field value
+*       else if field is not relevant for running board, return 0xFFFFFFF.
+*
+*******************************************************************************/
+MV_U32 mvBoardSatRRead(MV_SATR_TYPE_ID satrField)
+{
+	MV_BOARD_SATR_INFO satrInfo;
+	MV_U8 data;
+
+	if (satrField >= MV_SATR_MAX_OPTION) {
+		mvOsPrintf("%s: Error: wrong MV_SATR_TYPE_ID field value (%d).\n", __func__ , satrField);
+		return MV_ERROR;
+	}
+
+	if (mvBoardSatrInfoConfig(satrField, &satrInfo) != MV_OK) {
+		mvOsPrintf("%s: Error: Requested S@R field is not relevant for this board\n", __func__);
+		return MV_ERROR;
+	}
+
+	/* read */
+	if (mvBoardTwsiSatRGet(satrInfo.devClassId , satrInfo.regOffset, &data) != MV_OK) {
+		mvOsPrintf("%s: Error: Read from S@R failed\n", __func__);
+		return MV_ERROR;
+	}
+	data &= satrInfo.mask;
+	data = (data >> satrInfo.bitOffset);
+	if (satrInfo.status & BOARD_SATR_SWAP_BIT) {
+		MV_U32 c = mvCountMaskBits(satrInfo.mask);
+		data = mvReverseBits(data) >> (8-c) ;
+	}
+
+	if (satrField == MV_SATR_BOOT_DEVICE) {
+		/*  read boot mode second part from rd */
+		MV_U32 tmp = mvBoardSatRRead(MV_SATR_BOOT2_DEVICE);
+		if (tmp == MV_ERROR) {
+			mvOsPrintf("%s: Error: Read from S@R failed\n", __func__);
+			return MV_ERROR;
+		}
+		data = data | ((tmp & 0x0f) << 2);
+	}
+	return data;
+}
+
+/*******************************************************************************
+* mvBoardSatRWrite
+*
+* DESCRIPTION: Write S@R configuration Field
+*
+* INPUT: satrField - Field description enum
+*        val       - value to write (if write action requested)
+*
+* OUTPUT: None
+*
+* RETURN:
+*       write action:
+*       if value is writen succesfully - returns the written value
+*       else if write failed - returns MV_ERROR
+*
+*******************************************************************************/
+MV_STATUS mvBoardSatRWrite(MV_SATR_TYPE_ID satrWriteField, MV_U8 val)
+{
+	MV_BOARD_SATR_INFO satrInfo;
+	MV_U8 data, val1;
+
+	if (satrWriteField >= MV_SATR_MAX_OPTION) {
+		mvOsPrintf("%s: Error: wrong MV_SATR_TYPE_ID field value (%d).\n", __func__ , satrWriteField);
+		return MV_ERROR;
+	}
+
+	if (mvBoardSatrInfoConfig(satrWriteField, &satrInfo) != MV_OK) {
+		mvOsPrintf("%s: Error: Requested S@R field is not relevant for this board\n", __func__);
+		return MV_ERROR;
+	}
+	if (satrInfo.status & BOARD_SATR_READ_ONLY) {
+		mvOsPrintf("%s: Error: Requested S@R field is read only\n", __func__);
+		return MV_ERROR;
+	}
+	if (satrWriteField == MV_SATR_BOOT_DEVICE) {
+		val1 = (val & 0x3c) >> 2;
+		if (mvBoardSatRWrite(MV_SATR_BOOT2_DEVICE, val1) != MV_OK) {
+			mvOsPrintf("%s: Error: write boot device second field\n", __func__);
+			return MV_ERROR;
+		}
+	}
+	val &= (satrInfo.mask >> satrInfo.bitOffset); /* verify correct value */
+
+	/* read */
+	if (mvBoardTwsiSatRGet(satrInfo.devClassId , satrInfo.regOffset, &data) != MV_OK) {
+		mvOsPrintf("%s: Error: Read from S@R failed\n", __func__);
+		return MV_ERROR;
+	}
+
+	if (satrInfo.status & BOARD_SATR_SWAP_BIT) {
+		MV_U32 c = mvCountMaskBits(satrInfo.mask);
+		val = mvReverseBits(val) >> (8 - c) ;
+	}
+
+
+	/* modify */
+	data &= ~(satrInfo.mask);             /* clean old value */
+	data |= (val <<  satrInfo.bitOffset);    /* save new value */
+
+	/* write */
+	if (mvBoardTwsiSatRSet(satrInfo.devClassId , satrInfo.regOffset, data) != MV_OK) {
+		mvOsPrintf("%s: Error: Write to S@R failed\n", __func__);
+		return MV_ERROR;
+	}
+	return MV_OK;
+}
diff --git a/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.h b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.h
index 2bcda7f..b99ae4b 100644
--- a/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.h
+++ b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.h
@@ -77,39 +77,28 @@ extern "C" {
 #include "boardEnv/mvBoardEnvSpec.h"
 #include "twsi/mvTwsi.h"
 
+#define ARRSZ(x)                (sizeof(x) / sizeof(x[0]))
 #define BOARD_ETH_SWITCH_PORT_NUM       7
 #define BOARD_ETH_SWITCH_SMI_SCAN_MODE	1	/* Use manual scanning mode */
-#define MV_BOARD_MAX_MPP                9       /* number of MPP conf registers */
+#define MV_BOARD_MAX_MPP                59       /* number of MPP conf registers */
 #define MV_BOARD_MAX_MPP_GROUPS         9
 #define MV_BOARD_MPP_GROUPS_MAX_TYPES   8
 #define MV_BOARD_NAME_LEN               0x20
 
-typedef enum _devBoardSlicType {
-	MV_BOARD_SLIC_DISABLED,
-	MV_BOARD_SLIC_SSI_ID, /* Lantiq Integrated SLIC */
-	MV_BOARD_SLIC_ISI_ID, /* Silicon Labs ISI Bus */
-	MV_BOARD_SLIC_ZSI_ID, /* Zarlink ZSI Bus */
-	MV_BOARD_SLIC_EXTERNAL_ID /* Cross vendor external SLIC */
-} MV_BOARD_SLIC_TYPE;
-
 typedef enum _devBoardOtherTypeClass {
-	MV_BOARD_NONE    = 0x00000000,
-	MV_BOARD_LVDS    = 0x00000001,
-	MV_BOARD_PEX     = 0x00000002,
-	MV_BOARD_SWITCH  = 0x00000004,
-	MV_BOARD_SETM    = 0x00000008,
-	MV_BOARD_UNKNOWN = 0x80000000
+	MV_BOARD_NONE		= 0x00000000,
+	MV_BOARD_SPDIF		= 0x00000001,
+	MV_BOARD_I2S		= 0x00000002,
+	MV_BOARD_TDM		= 0x00000004,
+	MV_BOARD_MII		= 0x00000008,
+	MV_BOARD_SGMII		= 0x00000010,
+	MV_BOARD_SERDES_MUX	= 0x00000020,
+	MV_BOARD_NOR		= 0x00000040,
+	MV_BOARD_NAND16BIT	= 0x00000080,
+	MV_BOARD_SDIO4BIT	= 0x00000100,
+	MV_BOARD_UNKNOWN	= 0x80000000
 } MV_BOARD_OTHER_TYPE_CLASS;
 
-/* omriii:  decide between MODULE_TYPE or MPP_TYPE */
-typedef struct _boardMppTypeInfo {
-	MV_BOARD_SLIC_TYPE boardMppSlic;
-
-	/* Ethernet / Sata complex                      */
-	/* A bitmask of MV_ETH_SATA_COMPLEX_OPTIONS     */
-	MV_U32 ethSataComplexOpt;
-	MV_U32 ethPortsMode;    /* bitmask of MV_ETH_PORT_MODE */
-} MV_BOARD_MPP_TYPE_INFO;
 
 typedef enum _devBoardClass {
 	BOARD_DEV_NOR_FLASH,
@@ -122,12 +111,9 @@ typedef enum _devBoardClass {
 } MV_BOARD_DEV_CLASS;
 
 typedef enum _devTwsiBoardClass {
-	BOARD_TWSI_RTC,
-	BOARD_DEV_TWSI_EXP,
 	BOARD_DEV_TWSI_SATR,
-	BOARD_TWSI_MUX,
+	BOARD_TWSI_MODULE_DETECT,
 	BOARD_DEV_TWSI_EEPROM,
-	BOARD_DEV_TWSI_IO_EXPANDER,
 	BOARD_TWSI_OTHER
 } MV_BOARD_TWSI_CLASS;
 
@@ -169,6 +155,29 @@ typedef enum _devGppBoardClass {
 	BOARD_GPP_OTHER
 } MV_BOARD_GPP_CLASS;
 
+typedef enum _mvSatRTypeID {
+/*  "Bios" Device  */
+	MV_SATR_CPU_DDR_L2_FREQ,
+	MV_SATR_CORE_CLK_SELECT,
+	MV_SATR_CPU1_ENABLE,
+	MV_SATR_SSCG_DISABLE,
+	/*  SW parameters: */
+	MV_SATR_DDR4_SELECT,
+	MV_SATR_DDR_BUS_WIDTH,
+	MV_SATR_DDR_ECC_ENABLE,
+	MV_SATR_NAND_DETECT,
+	MV_SATR_RD_LANE1_2_CFG,
+	MV_SATR_RD_LANE4_CFG,
+	MV_SATR_RD_LANE0_CFG,
+	MV_SATR_RD_APPS_CFG,
+	MV_SATR_BOOT_DEVICE,
+	MV_SATR_BOOT2_DEVICE,
+	MV_SATR_BOARD_ID,
+	MV_SATR_BOARD_ECO_VERSION,
+	MV_SATR_MAX_OPTION,
+} MV_SATR_TYPE_ID;
+
+
 typedef struct _devCsInfo {
 	MV_U8 deviceCS;
 	MV_U32 params;
@@ -177,6 +186,11 @@ typedef struct _devCsInfo {
 	MV_U8 busWidth;
 } MV_DEV_CS_INFO;
 
+typedef enum _SatRstatus {
+	BOARD_SATR_READ_ONLY = 0x01,
+	BOARD_SATR_SWAP_BIT  = 0x02,
+} MV_BOARD_SATR_STATUS;
+
 typedef struct _boardLedInfo {
 	MV_U8 activeLedsNumber;
 	MV_U8 ledsPolarity;     /* '0' or '1' to turn on led */
@@ -198,17 +212,18 @@ typedef struct _boardTwsiInfo {
 typedef struct _boardSatrInfo {
 	MV_SATR_TYPE_ID satrId;
 	MV_U32 mask;
-	MV_U32 offset;
-	MV_U32 regNum;
+	MV_U32 bitOffset;
+	MV_U32 devClassId;
+	MV_U32 regOffset;
 	MV_U32 isActiveForBoard[MV_MAX_BOARD_ID];
+	MV_BOARD_SATR_STATUS status;
 } MV_BOARD_SATR_INFO;
 
 typedef struct _boardConfigTypesInfo {
 	MV_CONFIG_TYPE_ID configId;
-	MV_U32 mask;
+	MV_U32 twsiAddr;
 	MV_U32 offset;
-	MV_U32 expanderNum;
-	MV_U32 regNum;
+	MV_U32 twsiId;
 	MV_U32 isActiveForBoard[MV_MAX_BOARD_ID];
 } MV_BOARD_CONFIG_TYPE_INFO;
 
@@ -216,6 +231,7 @@ typedef enum _boardMacSpeed {
 	BOARD_MAC_SPEED_10M,
 	BOARD_MAC_SPEED_100M,
 	BOARD_MAC_SPEED_1000M,
+	BOARD_MAC_SPEED_2000M,
 	BOARD_MAC_SPEED_AUTO
 } MV_BOARD_MAC_SPEED;
 
@@ -228,6 +244,11 @@ typedef struct _boardMppInfo {
 	MV_U32 mppGroup[MV_BOARD_MAX_MPP];
 } MV_BOARD_MPP_INFO;
 
+typedef struct _boardMppTypeInfo {
+	MV_BOARD_OTHER_TYPE_CLASS externalModule;
+	MV_BOARD_MPP_INFO		  ModuleMpp;
+} MV_BOARD_MPP_TYPE_INFO;
+
 typedef enum {
 	BOARD_EPON_CONFIG,
 	BOARD_GPON_CONFIG,
@@ -244,15 +265,24 @@ typedef struct _boardPexInfo {
 	MV_U32 boardPexIfNum;
 } MV_BOARD_PEX_INFO;
 
+typedef enum _devBoardSlicType {
+	MV_BOARD_SLIC_DISABLED,
+	MV_BOARD_SLIC_SSI_ID, /* Lantiq Integrated SLIC */
+	MV_BOARD_SLIC_ISI_ID, /* Silicon Labs ISI Bus */
+	MV_BOARD_SLIC_ZSI_ID, /* Zarlink ZSI Bus */
+	MV_BOARD_SLIC_EXTERNAL_ID /* Cross vendor external SLIC */
+} MV_BOARD_SLIC_TYPE;
+
 typedef struct {
 	MV_U8 spiId;
 } MV_BOARD_TDM_SPI_INFO;
 
 typedef enum {
-	BOARD_TDM_SLIC_880 = 0,
-	BOARD_TDM_SLIC_792,
-	BOARD_TDM_SLIC_3215,
-	BOARD_TDM_SLIC_OTHER,
+	BOARD_SLIC_880 = 0,
+	BOARD_SLIC_792,
+	BOARD_SLIC_SSI,
+	BOARD_SLIC_ISI,
+	BOARD_SLIC_ZSI,
 	BOARD_TDM_SLIC_COUNT
 } MV_BOARD_TDM_SLIC_TYPE;
 
@@ -297,9 +327,6 @@ typedef struct _boardInfo {
 	MV_U32 gppPolarityValMid;
 	MV_U32 gppPolarityValHigh;
 
-	/* External Switch Configuration */
-	MV_U32 switchforceLinkMask;
-
 	/* PON configuration. */
 	MV_BOARD_PON_CONFIG ponConfigValue;
 	/* TDM configuration:
@@ -333,22 +360,21 @@ typedef struct _boardInfo {
 	MV_BOOL configAutoDetect;
 } MV_BOARD_INFO;
 
-/* {{MV_CONFIG_TYPE_ID ConfigID, MV_U32 Mask,  Offset, expanderNum,  regNum,    isActiveForBoard[]}} */
+/* {{MV_CONFIG_TYPE_ID ConfigID, twsi-ID,  Offset, ID,  isActiveForBoard[]}} */
 #define MV_BOARD_CONFIG_INFO { \
-	{ MV_CONFIG_MAC0,			0x3,	0,	0,	0,	{0 } },\
-	{ MV_CONFIG_MAC1,			0xC,	2,	0,	0,	{0 } },\
-	{ MV_CONFIG_PON_SERDES,			0x10,	4,	0,	0,	{0 } },\
-	{ MV_CONFIG_PON_BEN_POLARITY,	0x20,	5,	0,	0,	{0 } },\
-	{ MV_CONFIG_SGMII0_CAPACITY,	0x40,	6,	0,	0,	{0 } },\
-	{ MV_CONFIG_SGMII1_CAPACITY,	0x80,	7,	0,	0,	{0 } },\
-	{ MV_CONFIG_SLIC_TDM_DEVICE,	0x3,	0,	0,	1,	{0 } },\
-	{ MV_CONFIG_LANE1,			0xC,	2,	0,	1,	{0 } },\
-	{ MV_CONFIG_LANE2,			0x10,	4,	0,	1,	{0 } },\
-	{ MV_CONFIG_LANE3,			0X60,	5,	0,	1,	{0 } },\
-	{ MV_CONFIG_DEVICE_BUS_MODULE, 0x3,	0,	1,	0,	{0 } },\
+{ MV_CONFIG_SGMII,				0x2,	0,	 0xD,	{ 0, 1, 0} }, \
+{ MV_CONFIG_MII,				0x1,	0,	 0x4,	{ 0, 1, 0} }, \
+{ MV_CONFIG_SLIC_TDM_DEVICE,	0x0,	0,	 0x1,	{ 0, 1, 0} }, \
+{ MV_CONFIG_I2S_DEVICE,			0x1,	0,	 0x3,	{ 0, 1, 0} }, \
+{ MV_CONFIG_SPDIF_DEVICE,		0x1,	0,	 0x2,	{ 0, 1, 0} }, \
+{ MV_CONFIG_SERDES_PEX_LAN1,	0x3,	0,	 0xC,	{ 0, 1, 0} }, \
+{ MV_CONFIG_SERDES_PEX_LAN2,	0x3,	0,	 0xD,	{ 0, 1, 0} }, \
+{ MV_CONFIG_NOR,				0x4,	0,	 0xF,	{ 0, 1, 0} }, \
+{ MV_CONFIG_NAND,				0x4,	0,	 0x1,	{ 0, 1, 0} }, \
+{ MV_CONFIG_SDIO,				0x4,	0,	 0x2,	{ 0, 1, 0} }, \
+{ MV_CONFIG_GIGA,				0x27,	0,	 0xE,	{ 0, 1, 0} }, \
 };
 
-
 /* Boot device bus width */
 #define MSAR_0_BOOT_DEV_BUS_WIDTH_OFFS          3
 /* Bus width field meaning for NOR/NAND */
@@ -356,7 +382,7 @@ typedef struct _boardInfo {
 #define MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT         (0x1 << MSAR_0_BOOT_DEV_BUS_WIDTH_OFFS)
 #define MSAR_0_BOOT_DEV_BUS_WIDTH_32BIT         (0x2 << MSAR_0_BOOT_DEV_BUS_WIDTH_OFFS)
 /* Bus width field meaning for SPI */
-#define MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24_16BIT  (0x1 << MSAR_0_BOOT_DEV_BUS_WIDTH_OFFS)
+#define MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24BIT		(0x1 << MSAR_0_BOOT_DEV_BUS_WIDTH_OFFS)
 #define MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT     (0x0 << MSAR_0_BOOT_DEV_BUS_WIDTH_OFFS)
 
 /* NAND page size */
@@ -378,26 +404,27 @@ typedef struct _boardInfo {
 
 MV_VOID mvBoardEnvInit(MV_VOID);
 MV_U16 mvBoardModelGet(MV_VOID);
-MV_U16 mvBoardRevGet(MV_VOID);
+MV_U32 mvBoardRevGet(MV_VOID);
 MV_STATUS mvBoardNameGet(char *pNameBuff, MV_U32 size);
 MV_BOARD_SPEC_INIT *mvBoardSpecInitGet(MV_VOID);
 MV_BOOL mvBoardIsPortInSgmii(MV_U32 ethPortNum);
 MV_BOOL mvBoardIsPortInGmii(MV_U32 ethPortNum);
-MV_32 mvBoardSwitchPortMap(MV_U32 switchIdx, MV_U32 switchPortNum);
 MV_BOOL mvBoardIsPortLoopback(MV_U32 ethPortNum);
 MV_32 mvBoardPhyAddrGet(MV_U32 ethPortNum);
 MV_VOID mvBoardPhyAddrSet(MV_U32 ethPortNum, MV_U32 smiAddr);
-MV_STATUS mvBoardSatrInfoConfig(MV_SATR_TYPE_ID satrClass, MV_BOARD_SATR_INFO *satrInfo, MV_BOOL read);
+MV_STATUS mvBoardSatrInfoConfig(MV_SATR_TYPE_ID satrClass, MV_BOARD_SATR_INFO *satrInfo);
 MV_STATUS mvBoardConfigTypeGet(MV_CONFIG_TYPE_ID configClass, MV_BOARD_CONFIG_TYPE_INFO *configInfo);
 MV_STATUS mvBoardExtPhyBufferSelect(MV_BOOL enable);
+MV_STATUS mvBoardSgmiiSfp0TxSet(MV_BOOL enable);
 MV_U32 mvBoardTclkGet(MV_VOID);
+MV_U32 mvBoardL2ClkGetRaw(MV_VOID);
 MV_U32 mvBoardSysClkGet(MV_VOID);
 MV_U32 mvBoardDebugLedNumGet(MV_U32 boardId);
 MV_VOID mvBoardDebugLed(MV_U32 hexNum);
 MV_32 mvBoarGpioPinNumGet(MV_BOARD_GPP_CLASS class, MV_U32 index);
 MV_VOID mvBoardReset(MV_VOID);
+MV_BOARD_PEX_INFO *mvBoardPexInfoGet(void);
 MV_32 mvBoardResetGpioPinGet(MV_VOID);
-MV_32 mvBoardSDIOGpioPinGet(MV_BOARD_GPP_CLASS type);
 MV_32 mvBoardUSBVbusGpioPinGet(MV_32 devId);
 MV_32 mvBoardUSBVbusEnGpioPinGet(MV_32 devId);
 MV_BOOL mvBoardIsOurPciSlot(MV_U32 busNum, MV_U32 slotNum);
@@ -407,34 +434,32 @@ MV_VOID mvBoardSlicUnitTypeSet(MV_U32 slicType);
 MV_32 mvBoardMppGet(MV_U32 mppGroupNum);
 MV_VOID mvBoardMppTypeSet(MV_U32 mppGroupNum, MV_U32 groupType);
 MV_VOID mvBoardMppSet(MV_U32 mppGroupNum, MV_U32 mppValue);
-MV_U32 mvBoardGppConfigGet(void);
 MV_32 mvBoardTdmSpiModeGet(MV_VOID);
 MV_U8 mvBoardTdmDevicesCountGet(void);
 MV_U8 mvBoardTdmSpiCsGet(MV_U8 devId);
-MV_VOID mvBoardMppModuleTypePrint(MV_VOID);
-MV_VOID mvBoardOtherModuleTypePrint(MV_VOID);
+MV_U8 mvBoardTdmSpiIdGet(MV_VOID);
+MV_VOID mvBoardConfigurationPrint(MV_VOID);
 MV_BOOL mvBoardIsGbEPortConnected(MV_U32 ethPortNum);
 MV_32 mvBoardGetDevicesNumber(MV_BOARD_DEV_CLASS devClass);
 MV_32 mvBoardGetDeviceBaseAddr(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
 MV_32 mvBoardGetDeviceBusWidth(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
-MV_32 mvBoardGetDeviceWidth(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
 MV_32 mvBoardGetDeviceWinSize(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
 MV_U32 boardGetDevCSNum(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
 MV_U8 mvBoardTwsiAddrTypeGet(MV_BOARD_TWSI_CLASS twsiClass, MV_U32 index);
 MV_U8 mvBoardTwsiAddrGet(MV_BOARD_TWSI_CLASS twsiClass, MV_U32 index);
-MV_32 mvBoardNandWidthGet(void);
 MV_U32 mvBoardEthComplexConfigGet(MV_VOID);
 MV_VOID mvBoardEthComplexConfigSet(MV_U32 ethConfig);
 MV_U32 mvBoardIdGet(MV_VOID);
 MV_VOID mvBoardIdSet(MV_U32 boardId);
 MV_U32 mvBoardSledCpuNumGet(MV_VOID);
 MV_VOID mvBoardInfoUpdate(MV_VOID);
+MV_VOID mvBoardVerifySerdesCofig(MV_VOID);
 MV_VOID mvBoardMppIdUpdate(MV_VOID);
 MV_STATUS mvBoardEthComplexInfoUpdate(MV_VOID);
 MV_VOID mvBoardConfigWrite(MV_VOID);
 MV_ETH_COMPLEX_TOPOLOGY mvBoardMac0ConfigGet(MV_VOID);
 MV_ETH_COMPLEX_TOPOLOGY mvBoardMac1ConfigGet(MV_VOID);
-MV_ETH_COMPLEX_TOPOLOGY mvBoardLaneSGMIIGet(MV_VOID);
+MV_BOOL mvBoardLaneSGMIIGet(MV_ETH_COMPLEX_TOPOLOGY *sgmiiConfig);
 MV_BOARD_BOOT_SRC mvBoardBootDeviceGroupSet(MV_VOID);
 MV_BOARD_BOOT_SRC mvBoardBootDeviceGet(MV_VOID);
 MV_U32 mvBoardBootAttrGet(MV_U32 satrBootDeviceValue, MV_U8 attrNum);
@@ -442,34 +467,58 @@ MV_STATUS mvBoardTwsiGet(MV_BOARD_TWSI_CLASS twsiClass, MV_U8 devNum, MV_U8 regN
 MV_STATUS mvBoardTwsiSet(MV_BOARD_TWSI_CLASS twsiClass, MV_U8 devNum, MV_U8 regNum, MV_U8 regVal);
 MV_U8 mvBoardCpuFreqGet(MV_VOID);
 MV_STATUS mvBoardCpuFreqSet(MV_U8 freqVal);
-MV_U8 mvBoardCpuCoresNumGet(MV_VOID);
-MV_STATUS mvBoardMppModulesScan(void);
-MV_BOOL mvBoardIsPexModuleConnected(void);
-MV_BOOL mvBoardIsSetmModuleConnected(void);
-MV_STATUS mvBoardIsInternalSwitchConnectedToPort(MV_U32 ethPortNum);
 MV_STATUS mvBoardIsInternalSwitchConnected(void);
 MV_U32 mvBoardSwitchPortForceLinkGet(MV_U32 switchIdx);
-MV_BOOL mvBoardIsLvdsModuleConnected(void);
-MV_BOOL mvBoardIsLcdDviModuleConnected(void);
-MV_STATUS mvBoardTwsiMuxChannelSet(MV_U8 muxChNum);
-MV_STATUS mvBoardTwsiReadByteThruMux(MV_U8 muxChNum, MV_U8 chNum, MV_TWSI_SLAVE *pTwsiSlave, MV_U8 *data);
+MV_U32 mvBoardFreqModesNumGet(void);
 MV_32 mvBoardSmiScanModeGet(MV_U32 switchIdx);
-MV_BOOL mvBoardIsQsgmiiModuleConnected(void);
-MV_32 mvBoardGePhySwitchPortGet(void);
-MV_32 mvBoardRgmiiASwitchPortGet(void);
 MV_BOARD_MAC_SPEED mvBoardMacSpeedGet(MV_U32 ethPortNum);
+MV_VOID mvBoardMacSpeedSet(MV_U32 ethPortNum, MV_BOARD_MAC_SPEED macSpeed);
 MV_U32 mvBoardSwitchCpuPortGet(MV_U32 switchIdx);
-MV_U32 mvBoardIsEthConnected(MV_U32 ethNum);
+MV_U32 mvBoardMacCpuPortGet(MV_VOID);
+MV_BOOL mvBoardIsEthConnected(MV_U32 ethNum);
 MV_32 mvBoardSwitchIrqGet(MV_VOID);
-MV_32 mvBoardSwitchConnectedPortGet(MV_U32 ethPort);
 MV_U32 mvBoardSwitchPortsMaskGet(MV_U32 switchIdx);
 MV_BOOL mvBoardConfigAutoDetectEnabled(void);
 MV_32 mvBoardSmiScanModeGet(MV_U32 switchIdx);
-MV_BOARD_PEX_INFO *mvBoardPexInfoGet(void);
 MV_STATUS mvBoardConfIdSet(MV_U16 conf);
 MV_U16 mvBoardPexModeGet(MV_VOID);
 MV_STATUS mvBoardPexModeSet(MV_U16 conf);
-MV_U32 mvBoardFreqModesNumGet(void);
+MV_BOOL mvBoardIsLcdDviModuleConnected(void);
+MV_BOOL mvBoardIsPexModuleConnected(void);
+MV_BOOL mvBoardIsLvdsModuleConnected(void);
+MV_BOOL mvBoardIsSetmModuleConnected(void);
+MV_U8 mvBoardCpuCoresNumGet(MV_VOID);
+MV_VOID mvBoardMppModuleTypePrint(MV_VOID);
+MV_VOID mvBoardOtherModuleTypePrint(MV_VOID);
+MV_BOOL mvBoardIsModuleConnected(MV_U32 ModuleID);
+
+MV_STATUS mvBoardTwsiSatRGet(MV_U8 devNum, MV_U8 regNum, MV_U8 *pData);
+MV_STATUS mvBoardTwsiSatRSet(MV_U8 devNum, MV_U8 regNum, MV_U8 regVal);
+MV_U32 mvBoardSatRRead(MV_SATR_TYPE_ID satrField);
+MV_STATUS mvBoardSatRWrite(MV_SATR_TYPE_ID satrWriteField, MV_U8 val);
+
+/*    SATR-ID                   Mask    bit    TWSI   Reg  board	*/
+/*    SATR-ID                   Mask  offset  devID  num  active	*/
+#define MV_SAR_INFO { \
+{ MV_SATR_CPU_DDR_L2_FREQ,	0x1F,	0,	1,	0,	{1, 1, 0}, BOARD_SATR_SWAP_BIT},\
+{ MV_SATR_CORE_CLK_SELECT,	0x08,	3,	3,	0,	{0, 1, 0}, 0},\
+{ MV_SATR_CPU1_ENABLE,		0x01,	0,	2,	0,	{0, 1, 0}, 0},\
+{ MV_SATR_SSCG_DISABLE,		0x10,	4,	2,	0,	{0, 1, 0}, 0},\
+{ MV_SATR_DDR4_SELECT,		0x20,	5,	4,	1,	{0, 1, 0}, BOARD_SATR_READ_ONLY},\
+{ MV_SATR_DDR_BUS_WIDTH,	0x02,	1,	4,	0,	{0, 1, 0}, BOARD_SATR_READ_ONLY},\
+{ MV_SATR_DDR_ECC_ENABLE,	0x04,	2,	4,	0,	{0, 1, 0}, 0},\
+{ MV_SATR_NAND_DETECT,		0x1,	0,	4,	1,	{0, 1, 0}, BOARD_SATR_READ_ONLY},\
+{ MV_SATR_RD_LANE1_2_CFG,	0x1,	0,	1,	1,	{1, 0, 0}, 0},\
+{ MV_SATR_RD_LANE4_CFG,		0x2,	1,	1,	1,	{1, 0, 0}, 0},\
+{ MV_SATR_RD_LANE0_CFG,		0x4,	2,	1,	1,	{1, 0, 0}, 0},\
+{ MV_SATR_RD_APPS_CFG,		0x8,	3,	1,	1,	{1, 0, 0}, 0},\
+{ MV_SATR_BOOT_DEVICE,		0x3,	0,	3,	0,	{0, 1, 0}, BOARD_SATR_SWAP_BIT},\
+{ MV_SATR_BOOT2_DEVICE,		0x1E,	1,	4,	0,	{0, 1, 0}, BOARD_SATR_SWAP_BIT},\
+{ MV_SATR_BOARD_ID,		0x7,	0,	0,	0,	{1, 1, 0}, BOARD_SATR_READ_ONLY},\
+{ MV_SATR_BOARD_ECO_VERSION,	0xff,	0,	0,	1,	{1, 1, 0}, BOARD_SATR_READ_ONLY},\
+{ MV_SATR_MAX_OPTION,		0x0,	0,	0,	0,	{0, 0, 0}, 0},\
+};
+
 
 #ifdef __cplusplus
 }
diff --git a/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvSpec.c b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvSpec.c
index f041852..61e1c78 100644
--- a/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvSpec.c
+++ b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvSpec.c
@@ -62,83 +62,171 @@
 
 *******************************************************************************/
 #include "mvCommon.h"
-#include "mvBoardEnvLib.h"
-#include "mvBoardEnvSpec.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "boardEnv/mvBoardEnvSpec.h"
 #include "twsi/mvTwsi.h"
 #include "pex/mvPexRegs.h"
 
-#define ARRSZ(x)                (sizeof(x) / sizeof(x[0]))
-
 /*******************************************************************************
- * Armada 375 DB-88F6720 board */
+ * A380 DB-88F6660 board */
 /*******************************************************************************/
-
-#define DB_88F6720_BOARD_NOR_READ_PARAMS	0x403E07CF
-#define DB_88F6720_BOARD_NOR_WRITE_PARAMS	0x000F0F0F
-
-#define DB_88F6720_BOARD_NAND_READ_PARAMS	0x003E07CF
-#define DB_88F6720_BOARD_NAND_WRITE_PARAMS	0x000F0F0F
-
-MV_BOARD_TWSI_INFO db88f6720InfoBoardTwsiDev[] = {
-	/* {{MV_BOARD_DEV_CLASS devClass, MV_U8 devClassId,  MV_U8 twsiDevAddr, MV_U8 twsiDevAddrType}} */
-	{ BOARD_DEV_TWSI_SATR,		0,	0x4C,	   ADDR7_BIT	},
-	{ BOARD_DEV_TWSI_SATR,		1,	0x4D,	   ADDR7_BIT	},
-	{ BOARD_DEV_TWSI_EEPROM,	0,	0x52,	   ADDR7_BIT	},
+MV_BOARD_MPP_INFO db88f68xxInfoBoardMppConfigValue[] = {
+	{ {
+		  DB_88F68XX_MPP0_7,
+		  DB_88F68XX_MPP8_15,
+		  DB_88F68XX_MPP16_23,
+		  DB_88F68XX_MPP24_31,
+		  DB_88F68XX_MPP32_39,
+		  DB_88F68XX_MPP40_47,
+		  DB_88F68XX_MPP48_55,
+		  DB_88F68XX_MPP56_63
+	 } }
 };
 
-MV_BOARD_MAC_INFO db88f6720InfoBoardMacInfo[] = {
+MV_BOARD_TWSI_INFO db88f68xxInfoBoardTwsiDev[] = {
+	/* {{devClass,		devClassId, twsiDevAddr, twsiDevAddrType}} */
+	{ BOARD_DEV_TWSI_SATR,		0,	0x54,	   ADDR7_BIT},  /* read only for HW configuration */
+	{ BOARD_DEV_TWSI_SATR,		1,	0x4c,	   ADDR7_BIT},
+	{ BOARD_DEV_TWSI_SATR,		2,	0x4d,	   ADDR7_BIT},
+	{ BOARD_DEV_TWSI_SATR,		3,	0x4e,	   ADDR7_BIT},
+	{ BOARD_DEV_TWSI_SATR,		4,	0x21,	   ADDR7_BIT},
+	{ BOARD_TWSI_MODULE_DETECT,	0,	0x20,	   ADDR7_BIT},   /* modules */
+	{ BOARD_TWSI_MODULE_DETECT,	1,	0x23,	   ADDR7_BIT},
+	{ BOARD_TWSI_MODULE_DETECT,	2,	0x24,	   ADDR7_BIT},
+	{ BOARD_TWSI_MODULE_DETECT,	3,	0x25,	   ADDR7_BIT},
+	{ BOARD_TWSI_MODULE_DETECT,	4,	0x26,	   ADDR7_BIT},
+	{ BOARD_TWSI_MODULE_DETECT,	5,	0x27,	   ADDR7_BIT},
+};
+MV_BOARD_MAC_INFO db88f68xxInfoBoardMacInfo[] = {
 	/* {{MV_BOARD_MAC_SPEED boardMacSpeed, MV_8 boardEthSmiAddr}} */
-	{ BOARD_MAC_SPEED_AUTO, 0x0									}
+	{ BOARD_MAC_SPEED_AUTO, 0},
+	{ BOARD_MAC_SPEED_AUTO, 0x1},
+};
+
+MV_DEV_CS_INFO db88f68xxInfoBoardDeCsInfo[] = {
+	/*{deviceCS, params, devType, devWidth, busWidth }*/
+#if defined(MV_INCLUDE_SPI)
+	{ SPI_CS0, N_A, BOARD_DEV_SPI_FLASH, 8, 8 } /* SPI DEV */
+#endif
 };
-MV_BOARD_MPP_TYPE_INFO db88f6720InfoBoardModTypeInfo[] = {
+/*
+MV_BOARD_MPP_TYPE_INFO db88f68XXInfoBoardModTypeInfo[] = {
 	{
-		.boardMppSlic = MV_BOARD_SLIC_DISABLED,
-		.ethSataComplexOpt = MV_ETHCOMP_GE_MAC0_2_RGMII0,
-		.ethPortsMode = 0x0
+		.externalModule = MV_BOARD_NONE,
+		.ModuleMpp = 0,
 	}
 };
+*/
+
+MV_BOARD_TDM_INFO db88f68xxTdm880[] = { {0} };
+
+MV_BOARD_TDM_SPI_INFO db88f68xxTdmSpiInfo[] = { {1} };
+
+MV_BOARD_INFO db88f68xx_board_info = {
+	.boardName		= "DB-88f68xx",
+	.numBoardMppTypeValue	= 0,		/* ARRSZ(db88f68XXInfoBoardModTypeInfo), */
+	.pBoardModTypeValue	= NULL,		/* db88f68XXInfoBoardModTypeInfo, */
+	.pBoardMppConfigValue	= db88f68xxInfoBoardMppConfigValue,
+	.intsGppMaskLow		= 0,
+	.intsGppMaskMid		= 0,
+	.intsGppMaskHigh	= 0,
+	.numBoardDeviceIf	= ARRSZ(db88f68xxInfoBoardDeCsInfo),
+	.pDevCsInfo		= db88f68xxInfoBoardDeCsInfo,
+	.numBoardTwsiDev	= ARRSZ(db88f68xxInfoBoardTwsiDev),
+	.pBoardTwsiDev		= db88f68xxInfoBoardTwsiDev,
+	.numBoardMacInfo	= ARRSZ(db88f68xxInfoBoardMacInfo),
+	.pBoardMacInfo		= db88f68xxInfoBoardMacInfo,
+	.numBoardGppInfo	= 0,
+	.pBoardGppInfo		= 0,
+	.activeLedsNumber	= 0,
+	.pLedGppPin		= NULL,
+	.ledsPolarity		= 0,
+
+	/* PMU Power */
+	.pmuPwrUpPolarity	= 0,
+	.pmuPwrUpDelay		= 80000,
+
+	/* GPP values */
+	.gppOutEnValLow		= DB_88F68XX_GPP_OUT_ENA_LOW,
+	.gppOutEnValMid		= DB_88F68XX_GPP_OUT_ENA_MID,
+	.gppOutEnValHigh	= DB_88F68XX_GPP_OUT_ENA_HIGH,
+	.gppOutValLow		= DB_88F68XX_GPP_OUT_VAL_LOW,
+	.gppOutValMid		= DB_88F68XX_GPP_OUT_VAL_MID,
+	.gppOutValHigh		= DB_88F68XX_GPP_OUT_VAL_HIGH,
+	.gppPolarityValLow	= DB_88F68XX_GPP_POL_LOW,
+	.gppPolarityValMid	= DB_88F68XX_GPP_POL_MID,
+	.gppPolarityValHigh	= DB_88F68XX_GPP_POL_HIGH,
+
+	/* TDM */
+	.numBoardTdmInfo		= {1},
+	.pBoardTdmInt2CsInfo		= {db88f68xxTdm880},
+	.boardTdmInfoIndex		= 0,
+
+	.pBoardSpecInit			= NULL,
+
+	/* NAND init params */
+	.nandFlashReadParams		= 0,
+	.nandFlashWriteParams		= 0,
+	.nandFlashControl		= 0,
+	.pBoardTdmSpiInfo		= db88f68xxTdmSpiInfo,
+
+	/* NOR init params */
+	.norFlashReadParams		= 0,
+	.norFlashWriteParams		= 0,
+	/* Enable modules auto-detection. */
+	.configAutoDetect		= MV_TRUE
+};
+
 
-MV_DEV_CS_INFO db88f6720InfoBoardDeCsInfo[] = {
+/*******************************************************************************
+ * A380 RD-88F68XX board */
+/*******************************************************************************/
+
+MV_BOARD_TWSI_INFO rd88F68XXInfoBoardTwsiDev[] = {
+	/* {{MV_BOARD_DEV_CLASS devClass, MV_U8 devClassId,  MV_U8 twsiDevAddr, MV_U8 twsiDevAddrType}} */
+	{ BOARD_DEV_TWSI_SATR,	0,	0x54, ADDR7_BIT	},  /* read only for HW configuration */
+	{ BOARD_DEV_TWSI_SATR,	1,	0x4C, ADDR7_BIT	},
+};
+MV_BOARD_MAC_INFO rd88F68XXInfoBoardMacInfo[] = {
+	/* {{MV_BOARD_MAC_SPEED boardMacSpeed, MV_8 boardEthSmiAddr}} */
+	{ BOARD_MAC_SPEED_AUTO, 0},
+	{ BOARD_MAC_SPEED_AUTO, 0x1}
+};
+
+MV_DEV_CS_INFO rd88F68XXInfoBoardDeCsInfo[] = {
 	/*{deviceCS, params, devType, devWidth, busWidth }*/
 #if defined(MV_INCLUDE_SPI)
-	{ SPI_CS0, N_A, BOARD_DEV_SPI_FLASH, 8, 8 }, /* SPI DEV */
-#endif
-#if defined(MV_INCLUDE_NOR)
-	{DEV_BOOCS, N_A, BOARD_DEV_NOR_FLASH, 16, 16}, /* NOR DEV */
-#endif
-#if defined(MV_INCLUDE_LEGACY_NAND)
-	{DEV_BOOCS, N_A, BOARD_DEV_NAND_FLASH, 16, 16}  /* NAND DEV */
+	{ SPI_CS0, N_A, BOARD_DEV_SPI_FLASH, 8, 8 } /* SPI DEV */
 #endif
 };
 
-MV_BOARD_MPP_INFO db88f6720InfoBoardMppConfigValue[] = {
+MV_BOARD_MPP_INFO rd88f68XXInfoBoardMppConfigValue[] = {
 	{ {
-		  DB_88F6720_MPP0_7,
-		  DB_88F6720_MPP8_15,
-		  DB_88F6720_MPP16_23,
-		  DB_88F6720_MPP24_31,
-		  DB_88F6720_MPP32_39,
-		  DB_88F6720_MPP40_47,
-		  DB_88F6720_MPP48_55,
-		  DB_88F6720_MPP56_63,
-		  DB_88F6720_MPP64_67,
-	 } }
+		RD_88F68XX_MPP0_7,
+		RD_88F68XX_MPP8_15,
+		RD_88F68XX_MPP16_23,
+		RD_88F68XX_MPP24_31,
+		RD_88F68XX_MPP32_39,
+		RD_88F68XX_MPP40_47,
+		RD_88F68XX_MPP48_55,
+		RD_88F68XX_MPP56_63,
+	} }
 };
 
-MV_BOARD_INFO db88f6720_board_info = {
-	.boardName			= "DB-88F6720",
-	.numBoardMppTypeValue		= ARRSZ(db88f6720InfoBoardModTypeInfo),
-	.pBoardModTypeValue		= db88f6720InfoBoardModTypeInfo,
-	.pBoardMppConfigValue		= db88f6720InfoBoardMppConfigValue,
+MV_BOARD_INFO rd88f68XX_board_info = {
+	.boardName			= "RD-88F68XX",
+	.numBoardMppTypeValue	= ARRSZ(rd88f68XXInfoBoardMppConfigValue),
+	.pBoardModTypeValue		= NULL,
+	.pBoardMppConfigValue	= rd88f68XXInfoBoardMppConfigValue,
 	.intsGppMaskLow			= 0,
 	.intsGppMaskMid			= 0,
 	.intsGppMaskHigh		= 0,
-	.numBoardDeviceIf		= ARRSZ(db88f6720InfoBoardDeCsInfo),
-	.pDevCsInfo			= db88f6720InfoBoardDeCsInfo,
-	.numBoardTwsiDev		= ARRSZ(db88f6720InfoBoardTwsiDev),
-	.pBoardTwsiDev			= db88f6720InfoBoardTwsiDev,
-	.numBoardMacInfo		= ARRSZ(db88f6720InfoBoardMacInfo),
-	.pBoardMacInfo			= db88f6720InfoBoardMacInfo,
+	.numBoardDeviceIf		= ARRSZ(rd88F68XXInfoBoardDeCsInfo),
+	.pDevCsInfo				= rd88F68XXInfoBoardDeCsInfo,
+	.numBoardTwsiDev		= ARRSZ(rd88F68XXInfoBoardTwsiDev),
+	.pBoardTwsiDev			= rd88F68XXInfoBoardTwsiDev,
+	.numBoardMacInfo		= ARRSZ(rd88F68XXInfoBoardMacInfo),
+	.pBoardMacInfo			= rd88F68XXInfoBoardMacInfo,
 	.numBoardGppInfo		= 0,
 	.pBoardGppInfo			= 0,
 	.activeLedsNumber		= 0,
@@ -150,18 +238,12 @@ MV_BOARD_INFO db88f6720_board_info = {
 	.pmuPwrUpDelay			= 80000,
 
 	/* GPP values */
-	.gppOutEnValLow			= DB_88F6720_GPP_OUT_ENA_LOW,
-	.gppOutEnValMid			= DB_88F6720_GPP_OUT_ENA_MID,
-	.gppOutEnValHigh		= DB_88F6720_GPP_OUT_ENA_HIGH,
-	.gppOutValLow			= DB_88F6720_GPP_OUT_VAL_LOW,
-	.gppOutValMid			= DB_88F6720_GPP_OUT_VAL_MID,
-	.gppOutValHigh			= DB_88F6720_GPP_OUT_VAL_HIGH,
-	.gppPolarityValLow		= DB_88F6720_GPP_POL_LOW,
-	.gppPolarityValMid		= DB_88F6720_GPP_POL_MID,
-	.gppPolarityValHigh		= DB_88F6720_GPP_POL_HIGH,
-
-	/* External Switch Configuration */
-	.switchforceLinkMask		= 0x0,
+	.gppOutEnValLow			= RD_88F68XX_GPP_OUT_ENA_LOW,
+	.gppOutEnValMid			= RD_88F68XX_GPP_OUT_ENA_MID,
+	.gppOutValLow			= RD_88F68XX_GPP_OUT_VAL_LOW,
+	.gppOutValMid			= RD_88F68XX_GPP_OUT_VAL_MID,
+	.gppPolarityValLow		= RD_88F68XX_GPP_POL_LOW,
+	.gppPolarityValMid		= RD_88F68XX_GPP_POL_MID,
 
 	/* TDM */
 	.numBoardTdmInfo		= {},
@@ -171,90 +253,82 @@ MV_BOARD_INFO db88f6720_board_info = {
 	.pBoardSpecInit			= NULL,
 
 	/* NAND init params */
-	.nandFlashReadParams		= DB_88F6720_BOARD_NAND_READ_PARAMS,
-	.nandFlashWriteParams		= DB_88F6720_BOARD_NAND_WRITE_PARAMS,
+	.nandFlashReadParams		= 0,
+	.nandFlashWriteParams		= 0,
 	.nandFlashControl		= 0,
 	/* NOR init params */
-	.norFlashReadParams		= DB_88F6720_BOARD_NOR_READ_PARAMS,
-	.norFlashWriteParams		= DB_88F6720_BOARD_NOR_WRITE_PARAMS,
+	.norFlashReadParams		= 0,
+	.norFlashWriteParams		= 0,
 	/* Enable modules auto-detection. */
-	.configAutoDetect		= MV_TRUE
+	.configAutoDetect		= MV_FALSE
 };
 
-/*******************************************************************************
- * Armada 375 Customer board */
-/*******************************************************************************/
 
-#define A375_CUSTOMER_BOARD_NOR_READ_PARAMS		0x403E07CF
-#define A375_CUSTOMER_BOARD_NOR_WRITE_PARAMS	0x000F0F0F
+#define A380_CUSTOMER_BOARD_NAND_READ_PARAMS       0x000C0282
+#define A380_CUSTOMER_BOARD_NAND_WRITE_PARAMS      0x00010305
+/*NAND care support for small page chips*/
+#define A380_CUSTOMER_BOARD_NAND_CONTROL           0x01c00543
 
-#define A375_CUSTOMER_BOARD_NAND_READ_PARAMS	0x003E07CF
-#define A375_CUSTOMER_BOARD_NAND_WRITE_PARAMS	0x000F0F0F
+#define A380_CUSTOMER_BOARD_NOR_READ_PARAMS        0x403E07CF
+#define A380_CUSTOMER_BOARD_NOR_WRITE_PARAMS       0x000F0F0F
 
-MV_BOARD_TWSI_INFO armada_375_customer_InfoBoardTwsiDev[] = {
+MV_BOARD_TWSI_INFO A380_customerInfoBoardTwsiDev[] = {
 	/* {{MV_BOARD_DEV_CLASS devClass, MV_U8 devClassId,  MV_U8 twsiDevAddr, MV_U8 twsiDevAddrType}} */
 	{ BOARD_DEV_TWSI_SATR,		0,	0x4C,	   ADDR7_BIT	},
 	{ BOARD_DEV_TWSI_SATR,		1,	0x4D,	   ADDR7_BIT	},
-	{ BOARD_DEV_TWSI_EEPROM,	0,	0x52,	   ADDR7_BIT	},
+	{ BOARD_DEV_TWSI_EEPROM,	0,	0x54,	   ADDR7_BIT	},
 };
 
-MV_BOARD_MAC_INFO armada_375_customer_InfoBoardMacInfo[] = {
-	/* {{MV_BOARD_MAC_SPEED boardMacSpeed, MV_8 boardEthSmiAddr}} */
-	{ BOARD_MAC_SPEED_AUTO, 0x0									}
-};
-MV_BOARD_MPP_TYPE_INFO armada_375_customer_InfoBoardModTypeInfo[] = {
-	{
-		.boardMppSlic = MV_BOARD_SLIC_DISABLED,
-		.ethSataComplexOpt = MV_ETHCOMP_GE_MAC0_2_RGMII0,
-		.ethPortsMode = 0x0
-	}
+MV_BOARD_MAC_INFO A380_customerInfoBoardMacInfo[] = {
+	/* {{MV_BOARD_MAC_SPEED	boardMacSpeed, MV_U8 boardEthSmiAddr}} */
+	{ BOARD_MAC_SPEED_AUTO, 0x10},
+	{ BOARD_MAC_SPEED_AUTO, 0x11},
+	{ BOARD_MAC_SPEED_AUTO, 0x12},
+	{ BOARD_MAC_SPEED_AUTO, 0x13},
 };
 
-MV_DEV_CS_INFO armada_375_customer_InfoBoardDeCsInfo[] = {
+MV_DEV_CS_INFO A380_customerInfoBoardDeCsInfo[] = {
 	/*{deviceCS, params, devType, devWidth, busWidth }*/
 #if defined(MV_INCLUDE_SPI)
-	{ SPI_CS0, N_A, BOARD_DEV_SPI_FLASH, 8, 8 }, /* SPI DEV */
-#endif
-#if defined(MV_INCLUDE_NOR)
-	{DEV_BOOCS, N_A, BOARD_DEV_NOR_FLASH, 16, 16}, /* NOR DEV */
-#endif
-#if defined(MV_INCLUDE_LEGACY_NAND)
-	{DEV_BOOCS, N_A, BOARD_DEV_NAND_FLASH, 16, 16}  /* NAND DEV */
+	{ SPI_CS0, N_A, BOARD_DEV_SPI_FLASH, 8, 8 } /* SPI DEV */
 #endif
 };
 
-MV_BOARD_MPP_INFO armada_375_customer_InfoBoardMppConfigValue[] = {
+MV_BOARD_TDM_INFO A380_customerTdm880[] = { {0} };
+
+MV_BOARD_TDM_SPI_INFO A380_customerTdmSpiInfo[] = { {1} };
+
+MV_BOARD_MPP_INFO A380_customerInfoBoardMppConfigValue[] = {
 	{ {
-		  A375_CUSTOMER_BOARD_MPP0_7,
-		  A375_CUSTOMER_BOARD_MPP8_15,
-		  A375_CUSTOMER_BOARD_MPP16_23,
-		  A375_CUSTOMER_BOARD_MPP24_31,
-		  A375_CUSTOMER_BOARD_MPP32_39,
-		  A375_CUSTOMER_BOARD_MPP40_47,
-		  A375_CUSTOMER_BOARD_MPP48_55,
-		  A375_CUSTOMER_BOARD_MPP56_63,
-		  A375_CUSTOMER_BOARD_MPP64_67,
+		  A380_CUSTOMER_MPP0_7,
+		  A380_CUSTOMER_MPP8_15,
+		  A380_CUSTOMER_MPP16_23,
+		  A380_CUSTOMER_MPP24_31,
+		  A380_CUSTOMER_MPP32_39,
+		  A380_CUSTOMER_MPP40_47,
+		  A380_CUSTOMER_MPP48_55,
+		  A380_CUSTOMER_MPP56_63
 	 } }
 };
 
-MV_BOARD_INFO armada_375_customer_board_info = {
-	.boardName			= "A375-CUSTOMER-BOARD",
-	.numBoardMppTypeValue		= ARRSZ(armada_375_customer_InfoBoardModTypeInfo),
-	.pBoardModTypeValue		= armada_375_customer_InfoBoardModTypeInfo,
-	.pBoardMppConfigValue		= armada_375_customer_InfoBoardMppConfigValue,
+MV_BOARD_INFO A380_customer_board_info = {
+	.boardName				= "A380-CUSTOMER",
+	.numBoardMppTypeValue	= 0,
+	.pBoardModTypeValue		= NULL,
+	.pBoardMppConfigValue	= A380_customerInfoBoardMppConfigValue,
 	.intsGppMaskLow			= 0,
 	.intsGppMaskMid			= 0,
 	.intsGppMaskHigh		= 0,
-	.numBoardDeviceIf		= ARRSZ(armada_375_customer_InfoBoardDeCsInfo),
-	.pDevCsInfo			= armada_375_customer_InfoBoardDeCsInfo,
-	.numBoardTwsiDev		= ARRSZ(armada_375_customer_InfoBoardTwsiDev),
-	.pBoardTwsiDev			= armada_375_customer_InfoBoardTwsiDev,
-	.numBoardMacInfo		= ARRSZ(armada_375_customer_InfoBoardMacInfo),
-	.pBoardMacInfo			= armada_375_customer_InfoBoardMacInfo,
+	.numBoardDeviceIf		= ARRSZ(A380_customerInfoBoardDeCsInfo),
+	.pDevCsInfo				= A380_customerInfoBoardDeCsInfo,
+	.numBoardTwsiDev		= ARRSZ(A380_customerInfoBoardTwsiDev),
+	.pBoardTwsiDev			= A380_customerInfoBoardTwsiDev,
+	.numBoardMacInfo		= ARRSZ(A380_customerInfoBoardMacInfo),
+	.pBoardMacInfo			= A380_customerInfoBoardMacInfo,
 	.numBoardGppInfo		= 0,
-	.pBoardGppInfo			= 0,
+	.pBoardGppInfo			= NULL,
 	.activeLedsNumber		= 0,
-	.pLedGppPin			= NULL,
+	.pLedGppPin				= NULL,
 	.ledsPolarity			= 0,
 
 	/* PMU Power */
@@ -262,41 +336,32 @@ MV_BOARD_INFO armada_375_customer_board_info = {
 	.pmuPwrUpDelay			= 80000,
 
 	/* GPP values */
-	.gppOutEnValLow			= A375_CUSTOMER_BOARD_GPP_OUT_ENA_LOW,
-	.gppOutEnValMid			= A375_CUSTOMER_BOARD_GPP_OUT_ENA_MID,
-	.gppOutEnValHigh		= A375_CUSTOMER_BOARD_GPP_OUT_ENA_HIGH,
-	.gppOutValLow			= A375_CUSTOMER_BOARD_GPP_OUT_VAL_LOW,
-	.gppOutValMid			= A375_CUSTOMER_BOARD_GPP_OUT_VAL_MID,
-	.gppOutValHigh			= A375_CUSTOMER_BOARD_GPP_OUT_VAL_HIGH,
-	.gppPolarityValLow		= A375_CUSTOMER_BOARD_GPP_POL_LOW,
-	.gppPolarityValMid		= A375_CUSTOMER_BOARD_GPP_POL_MID,
-	.gppPolarityValHigh		= A375_CUSTOMER_BOARD_GPP_POL_HIGH,
-
-	/* External Switch Configuration */
-	.switchforceLinkMask		= 0x0,
+	.gppOutEnValLow			= A380_CUSTOMER_GPP_OUT_ENA_LOW,
+	.gppOutEnValMid			= A380_CUSTOMER_GPP_OUT_ENA_MID,
+	.gppOutValLow			= A380_CUSTOMER_GPP_OUT_VAL_LOW,
+	.gppOutValMid			= A380_CUSTOMER_GPP_OUT_VAL_MID,
+	.gppPolarityValLow		= A380_CUSTOMER_GPP_POL_LOW,
+	.gppPolarityValMid		= A380_CUSTOMER_GPP_POL_MID,
 
 	/* TDM */
-	.numBoardTdmInfo		= {},
-	.pBoardTdmInt2CsInfo		= {},
-	.boardTdmInfoIndex		= -1,
-
-	.pBoardSpecInit			= NULL,
+	.numBoardTdmInfo		= {1},
+	.pBoardTdmInt2CsInfo		= {A380_customerTdm880},
+	.boardTdmInfoIndex		= 0,
 
 	/* NAND init params */
-	.nandFlashReadParams		= A375_CUSTOMER_BOARD_NAND_READ_PARAMS,
-	.nandFlashWriteParams		= A375_CUSTOMER_BOARD_NAND_WRITE_PARAMS,
-	.nandFlashControl		= 0,
+	.nandFlashReadParams		= A380_CUSTOMER_BOARD_NAND_READ_PARAMS,
+	.nandFlashWriteParams		= A380_CUSTOMER_BOARD_NAND_WRITE_PARAMS,
+	.nandFlashControl		= A380_CUSTOMER_BOARD_NAND_CONTROL,
 	/* NOR init params */
-	.norFlashReadParams		= A375_CUSTOMER_BOARD_NOR_READ_PARAMS,
-	.norFlashWriteParams		= A375_CUSTOMER_BOARD_NOR_WRITE_PARAMS,
-	/* Enable modules auto-detection. */
-	.configAutoDetect		= MV_TRUE
+	.norFlashReadParams		= A380_CUSTOMER_BOARD_NOR_READ_PARAMS,
+	.norFlashWriteParams		= A380_CUSTOMER_BOARD_NOR_WRITE_PARAMS
 };
 
 /*
- * All supported Armada 375 boards
+ * All supported A380 boards
  */
 MV_BOARD_INFO *boardInfoTbl[] = {
-	&db88f6720_board_info,
-	&armada_375_customer_board_info,
+	&rd88f68XX_board_info,
+	&db88f68xx_board_info,
+	&A380_customer_board_info
 };
diff --git a/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvSpec.h b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvSpec.h
index d8b9455..b641a01 100644
--- a/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvSpec.h
+++ b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvSpec.h
@@ -67,12 +67,6 @@
 
 #include "mvSysHwConfig.h"
 
-/* I2C bus addresses */
-#define MV_BOARD_DIMM0_I2C_ADDR                 0x56
-#define MV_BOARD_DIMM0_I2C_ADDR_TYPE            ADDR7_BIT
-#define MV_BOARD_DIMM1_I2C_ADDR                 0x57
-#define MV_BOARD_DIMM1_I2C_ADDR_TYPE            ADDR7_BIT
-#define MV_BOARD_DIMM_I2C_CHANNEL               0x0
 
 /* Board specific configuration */
 /* ============================ */
@@ -80,62 +74,138 @@
 /* New board ID numbers */
 
 /* boards ID numbers */
-#define BOARD_ID_BASE                   0x0
-#define DB_6720_ID                      (BOARD_ID_BASE)
-#define A375_CUSTOMER_ID                (DB_6720_ID + 1)
-#define MV_MAX_BOARD_ID                 (A375_CUSTOMER_ID + 1)
-#define MV_INVALID_BOARD_ID             0xFFFFFFFF
+#define BOARD_ID_BASE			0x0
+
+#define RD_68XX_ID			(BOARD_ID_BASE)
+#define DB_68XX_ID			(RD_68XX_ID + 1)
+#define A380_CUSTOMER_ID		(DB_68XX_ID + 1)
+#define MV_MAX_BOARD_ID			(A380_CUSTOMER_ID + 1)
+#define MV_INVALID_BOARD_ID		0xFFFFFFFF
 
 /*******************************************************************************
- * Armada 375 DB-88F6720 board */
-/******************************************************************************/
-/*SPI, NAND cases*/
+ * A380 DB-88F6810 board */
+/******************************************************************************
+   MPP#			DEFAULT UNIT		        MPP Values (respectively)
+   -----------------------------------------------------------------------------------
+   0-1			UART				1
+   2-3			I2C0				1
+   4-5			SMI ( MDC/MDIO )		1
+   6-17			GE0				1
+   18			SGMII , GIGA0			0
+   19-20		Uart1				6
+   21, 27-32
+   37-41	GE1					2
+   22-25	SPI					1
+   33-35	7 segment				0
+   26		USB Device detect			0  (USB3_0)
+   36,42	Spare Inputs				0
+   43		M_VTT_CTRL (out)			2
+   44		SATA3_PRESENT_ACTIVEn			4
+45,46,56	Inputs( PIC outputs )			0
+	47		SATA1_PRESENT_ACTIVEn		4
+   48-50
+   52-55
+   57-59	SDIO 8 Bit				5
+    51		USB Device detect0			0
+*/
 #define GROUP1_DEFAULT_MPP_SPI_I2C         0x22000022  /* SPI , I2C */
-#define DB_88F6720_MPP0_7               0x00020020  /* SPI */
-#define DB_88F6720_MPP8_15              0x22000022  /* SPI , I2C */
-#define DB_88F6720_MPP16_23             0x22222222	/* UART, TDM*/
-#define DB_88F6720_MPP24_31             0x33333333  /* SDIO*/
-#define DB_88F6720_MPP32_39             0x04403330  /* SPI, SMI */
-#define DB_88F6720_MPP40_47             0x22002044  /* UART1, GE0  */
-#define DB_88F6720_MPP48_55             0x22222222  /*GE0*/
-#define DB_88F6720_MPP56_63             0x44444422  /* GE0 , LED_MATRIX */
-#define DB_88F6720_MPP64_67				0x004		/* LED_MATRIX */
-
-#define DB_88F6720_GPP_OUT_ENA_LOW      0xFFFFFFFF
-#define DB_88F6720_GPP_OUT_ENA_MID      0xFFFFFFFF
-#define DB_88F6720_GPP_OUT_ENA_HIGH     0xFFFFFFFF
-#define DB_88F6720_GPP_OUT_VAL_LOW      0x0
-#define DB_88F6720_GPP_OUT_VAL_MID      0x0
-#define DB_88F6720_GPP_OUT_VAL_HIGH     0x0
-#define DB_88F6720_GPP_POL_LOW          0x0
-#define DB_88F6720_GPP_POL_MID          0x0
-#define DB_88F6720_GPP_POL_HIGH         0x0
+/*******************************************************************************
+* A380 DB-68xx board
+*******************************************************************************/
+#define DB_88F68XX_MPP0_7               0x11111111
+#define DB_88F68XX_MPP8_15              0x11111111
+#define DB_88F68XX_MPP16_23             0x11266011
+#define DB_88F68XX_MPP24_31             0x22222011
+#define DB_88F68XX_MPP32_39             0x22200002
+#define DB_88F68XX_MPP40_47             0x40042022
+#define DB_88F68XX_MPP48_55             0x55550555
+#define DB_88F68XX_MPP56_63             0x00005550
+
+#define DB_88F68XX_GPP_OUT_ENA_LOW      0xFFFFFFFF
+#define DB_88F68XX_GPP_OUT_ENA_MID      (~(0x0E))
+#define DB_88F68XX_GPP_OUT_ENA_HIGH     (~(BIT1))
+#define DB_88F68XX_GPP_OUT_VAL_LOW      0x0
+#define DB_88F68XX_GPP_OUT_VAL_MID      0x0
+#define DB_88F68XX_GPP_OUT_VAL_HIGH     0x0
+#define DB_88F68XX_GPP_POL_LOW          0x0
+#define DB_88F68XX_GPP_POL_MID          0x0
+#define DB_88F68XX_GPP_POL_HIGH         0x0
+
 
 /*******************************************************************************
- * Armada 375 Customer board */
-/******************************************************************************/
-/*SPI, NAND cases*/
-#define GROUP1_DEFAULT_MPP_SPI_I2C         0x22000022  /* SPI , I2C */
-#define A375_CUSTOMER_BOARD_MPP0_7               0x00020020  /* SPI */
-#define A375_CUSTOMER_BOARD_MPP8_15              0x22000022  /* SPI , I2C */
-#define A375_CUSTOMER_BOARD_MPP16_23             0x22222222	/* UART, TDM*/
-#define A375_CUSTOMER_BOARD_MPP24_31             0x33333333  /* SDIO*/
-#define A375_CUSTOMER_BOARD_MPP32_39             0x04403330  /* SPI, SMI */
-#define A375_CUSTOMER_BOARD_MPP40_47             0x22002044  /* UART1, GE0  */
-#define A375_CUSTOMER_BOARD_MPP48_55             0x22222222  /*GE0*/
-#define A375_CUSTOMER_BOARD_MPP56_63             0x44444422  /* GE0 , LED_MATRIX */
-#define A375_CUSTOMER_BOARD_MPP64_67				0x004		/* LED_MATRIX */
-
-#define A375_CUSTOMER_BOARD_GPP_OUT_ENA_LOW      0xFFFFFFFF
-#define A375_CUSTOMER_BOARD_GPP_OUT_ENA_MID      0xFFFFFFFF
-#define A375_CUSTOMER_BOARD_GPP_OUT_ENA_HIGH     0xFFFFFFFF
-#define A375_CUSTOMER_BOARD_GPP_OUT_VAL_LOW      0x0
-#define A375_CUSTOMER_BOARD_GPP_OUT_VAL_MID      0x0
-#define A375_CUSTOMER_BOARD_GPP_OUT_VAL_HIGH     0x0
-#define A375_CUSTOMER_BOARD_GPP_POL_LOW          0x0
-#define A375_CUSTOMER_BOARD_GPP_POL_MID          0x0
-#define A375_CUSTOMER_BOARD_GPP_POL_HIGH         0x0
+* A380 RD-68XX board
+*******************************************************************************/
+/******************************************************************************
+   MPP#			DEFAULT UNIT		        MPP Values (respectively)
+   -----------------------------------------------------------------------------------
+   0-1			UART					1
+   2-3			I2C0					1
+   4-5			SMI ( MDC/MDIO )			1
+   6-17			GE0					1
+   18			IO_INT					0
+   19			SATA1					4
+   20			SATA0					4
+   21, 27-32
+   37-41	GE1						2
+   22-26	SPI0						1
+   33		CPU Clock Frequency Options[0]			0
+   34      CPU Clock Frequency Options[3]			0
+   35      CPU Clock Frequency Options[4]			0
+   36      CPU1 Enable						0
+   42		FAN_CTRL					0
+   43		M_VTT_CTRL (out)				2
+   44		SATA3_PRESENT_ACTIVEn				4
+   45-46	REF_CLK_OUT[0,1] (out)				0
+   47		SATA2_PRESENT_ACTIVEn				3
+   48-50
+   52-55
+   57-59	SDIO 8 Bit					5
+    56		boot Device mode				0
+    51		USB Device detect0				0
+ */
+#define RD_88F68XX_MPP0_7               0x11111111
+#define RD_88F68XX_MPP8_15              0x11111111
+#define RD_88F68XX_MPP16_23             0x11244011
+#define RD_88F68XX_MPP24_31             0x22222111
+#define RD_88F68XX_MPP32_39             0x22200002
+#define RD_88F68XX_MPP40_47             0x30042022
+#define RD_88F68XX_MPP48_55             0x55550555
+#define RD_88F68XX_MPP56_63             0x00005550
+
+#define RD_88F68XX_GPP_OUT_ENA_LOW      (~(BIT1  | BIT4  | BIT6  | BIT7  | BIT8  | BIT9  | BIT10 | \
+					   BIT11 | BIT19 | BIT20 | BIT22 | BIT23 | BIT25 | BIT26 | \
+					   BIT27 | BIT29 | BIT30 | BIT31))
+#define RD_88F68XX_GPP_OUT_ENA_MID	(~(BIT0 | BIT1 | BIT2 | BIT3 | BIT4 | BIT15 | BIT16 | BIT17 | BIT18))
+#define RD_88F68XX_GPP_OUT_VAL_LOW	0x0
+#define RD_88F68XX_GPP_OUT_VAL_MID	0x0
+#define RD_88F68XX_GPP_POL_LOW		0x0
+#define RD_88F68XX_GPP_POL_MID		0x0
+
 
+/*******************************************************************************
+* A380_CUSTOMER_ID - customer board
+*******************************************************************************/
+#define A380_CUSTOMER_MPP0_7		0x11111111
+#define A380_CUSTOMER_MPP8_15		0x11111111
+#define A380_CUSTOMER_MPP16_23		0x11244011
+#define A380_CUSTOMER_MPP24_31		0x22222111
+#define A380_CUSTOMER_MPP32_39		0x22200002
+#define A380_CUSTOMER_MPP40_47		0x30042022
+#define A380_CUSTOMER_MPP48_55		0x55550555
+#define A380_CUSTOMER_MPP56_63		0x00005550
+
+/* GPPs
+MPP#	NAME			IN/OUT
+--------------------------------------
+19	TDM_reset		OUT
+25	Ethernet Reset		OUT			   29	PCIe0_RSTOUTn		OUT
+*/
+#define A380_CUSTOMER_GPP_OUT_ENA_LOW      (~(BIT19 | BIT25 | BIT29))
+#define A380_CUSTOMER_GPP_OUT_ENA_MID      0xFFFFFFFF
+#define A380_CUSTOMER_GPP_OUT_VAL_LOW      0x0
+#define A380_CUSTOMER_GPP_OUT_VAL_MID      0x0
+#define A380_CUSTOMER_GPP_POL_LOW          0x0
+#define A380_CUSTOMER_GPP_POL_MID          0x0
 
 #endif  /* MV_ASMLANGUAGE */
 
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.c b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.c
index 4e181e0..b717232 100644
--- a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.c
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.c
@@ -116,18 +116,6 @@
  */
 #define MV_INVALID_CTRL_REV     0xff
 
-typedef struct _ctrlEnvInfo {
-	MV_U16 ctrlModel;
-	MV_U8 ctrlRev;
-} CTRL_ENV_INFO;
-
-CTRL_ENV_INFO ctrlEnvInfo = {};
-
-MV_U32 satrOptionsConfig[MV_SATR_READ_MAX_OPTION];
-MV_U32 boardOptionsConfig[MV_CONFIG_TYPE_MAX_OPTION];
-
-MV_BOARD_SATR_INFO boardSatrInfo[] = MV_SAR_INFO;
-
 /*******************************************************************************
 * mvCtrlGetCpuNum
 *
@@ -145,12 +133,10 @@ MV_U32 mvCtrlGetCpuNum(MV_VOID)
 {
 	MV_U32 cpu1Enabled;
 
-	cpu1Enabled = mvCtrlSatRRead(MV_SATR_CPU1_ENABLE);
-	if (cpu1Enabled == MV_ERROR) {
-		DB(mvOsPrintf("%s: Error: MV_SATR_CPU1_ENABLE is not active for board (using default)\n", __func__));
-		return 0;
-	} else
-		return cpu1Enabled;
+	cpu1Enabled = MV_REG_READ(MPP_SAMPLE_AT_RESET(1));
+	if (cpu1Enabled & SATR_CPU1_ENABLE_MASK)
+		return 2;
+	return 1;
 }
 
 /*******************************************************************************
@@ -171,7 +157,7 @@ MV_BOOL mvCtrlIsValidSatR(MV_VOID)
 	MV_U32 i, cpuFreqMode, maxFreqModes = mvBoardFreqModesNumGet();
 	MV_FREQ_MODE pFreqModes[] = MV_USER_SAR_FREQ_MODES;
 
-	cpuFreqMode =  mvCtrlSatRRead(MV_SATR_CPU_DDR_L2_FREQ);
+	cpuFreqMode =  mvBoardSatRRead(MV_SATR_CPU_DDR_L2_FREQ);
 
 	for (i = 0; i < maxFreqModes; i++) {
 		if (cpuFreqMode == pFreqModes[i].id)
@@ -189,12 +175,17 @@ MV_STATUS mvCtrlUpdatePexId(MV_VOID)
 
 #endif
 
-#define MV_6720_INDEX		0
-#define MV_67xx_INDEX_MAX	1
+#define MV_6820_INDEX		0
+#define MV_6810_INDEX		1
+#define MV_68xx_INDEX_MAX	2
 
-static MV_U32 mvCtrlDevIdIndexGet(MV_U32 devId)
+static MV_U32 mvCtrlDevIdIndexGet(void)
 {
-	return MV_6720_INDEX;
+	switch (mvCtrlModelGet()) {
+	case MV_6820_DEV_ID: return MV_6820_INDEX;
+	case MV_6810_DEV_ID: return MV_6810_INDEX;
+	}
+	return MV_6820_INDEX;
 }
 
 static MV_VOID mvCtrlPexConfig(MV_VOID)
@@ -213,40 +204,39 @@ static MV_VOID mvCtrlPexConfig(MV_VOID)
 }
 
 
-MV_UNIT_ID mvCtrlSocUnitNums[MAX_UNITS_ID][MV_67xx_INDEX_MAX] = {
-/*                          6720 */
-/* DRAM_UNIT_ID         */ { 1, },
-/* PEX_UNIT_ID          */ { 2, },
-/* ETH_GIG_UNIT_ID      */ { 2, },
-/* USB_UNIT_ID          */ { 1, },
-/* USB3_UNIT_ID          */ { 1, },
-/* IDMA_UNIT_ID         */ { 0, },
-/* XOR_UNIT_ID          */ { 2, },
-/* SATA_UNIT_ID         */ { 2, },
-/* TDM_32CH_UNIT_ID     */ { 1, },
-/* UART_UNIT_ID         */ { 2, },
-/* CESA_UNIT_ID         */ { 1, },
-/* SPI_UNIT_ID          */ { 2, },
-/* AUDIO_UNIT_ID        */ { 1, },
-/* SDIO_UNIT_ID         */ { 1, },
-/* TS_UNIT_ID           */ { 0, },
-/* XPON_UNIT_ID         */ { 1, },
-/* BM_UNIT_ID           */ { 1, },
-/* PNC_UNIT_ID          */ { 1, },
-/* I2C_UNIT_ID          */ { 2, },
+MV_UNIT_ID mvCtrlSocUnitNums[MAX_UNITS_ID][MV_68xx_INDEX_MAX] = {
+/*                          6820 */
+/* DRAM_UNIT_ID         */ { 1, 1},
+/* PEX_UNIT_ID          */ { 2, 2},
+/* ETH_GIG_UNIT_ID      */ { 2, 2},
+/* USB_UNIT_ID          */ { 3, 3},
+/* USB3_UNIT_ID         */ { 1, 1},
+/* IDMA_UNIT_ID         */ { 1, 1},
+/* XOR_UNIT_ID          */ { 2, 2},
+/* SATA_UNIT_ID         */ { 2, 2},
+/* TDM_32CH_UNIT_ID     */ { 1, 1},
+/* UART_UNIT_ID         */ { 2, 2},
+/* CESA_UNIT_ID         */ { 1, 1},
+/* SPI_UNIT_ID          */ { 2, 2},
+/* AUDIO_UNIT_ID        */ { 1, 1},
+/* SDIO_UNIT_ID         */ { 1, 1},
+/* TS_UNIT_ID           */ { 0, 0},
+/* XPON_UNIT_ID         */ { 1, 1},
+/* BM_UNIT_ID           */ { 1, 1},
+/* PNC_UNIT_ID          */ { 1, 1},
+/* I2C_UNIT_ID          */ { 2, 2},
 };
 
 MV_U32 mvCtrlSocUnitInfoNumGet(MV_UNIT_ID unit)
 {
-	MV_U32 devId, devIdIndex;
+	MV_U32 devIdIndex;
 
 	if (unit >= MAX_UNITS_ID) {
 		mvOsPrintf("%s: Error: Wrong unit type (%u)\n", __func__, unit);
 		return 0;
 	}
 
-	devId = mvCtrlModelGet();
-	devIdIndex = mvCtrlDevIdIndexGet(devId);
+	devIdIndex = mvCtrlDevIdIndexGet();
 	return mvCtrlSocUnitNums[unit][devIdIndex];
 }
 
@@ -278,7 +268,6 @@ MV_STATUS mvCtrlEnvInit(MV_VOID)
 	/* Set I2C MPP's(MPP Group 1), before reading board configuration, using TWSI read */
 	MV_REG_WRITE(mvCtrlMppRegGet(1), GROUP1_DEFAULT_MPP_SPI_I2C);
 
-	mvCtrlSatrInit();
 
 	/* If set to Auto detect, read board config info, update MPP group types*/
 	if (mvBoardConfigAutoDetectEnabled()) {
@@ -328,152 +317,6 @@ MV_STATUS mvCtrlEnvInit(MV_VOID)
 }
 
 /*******************************************************************************
-* mvCtrlSatRWrite
-*
-* DESCRIPTION: Write S@R configuration Field
-*
-* INPUT: satrField - Field description enum
-*        val       - value to write (if write action requested)
-*
-* OUTPUT: None
-*
-* RETURN:
-*       write action:
-*       if value is writen succesfully - returns the written value
-*       else if write failed - returns MV_ERROR
-*
-*******************************************************************************/
-MV_STATUS mvCtrlSatRWrite(MV_SATR_TYPE_ID satrWriteField, MV_SATR_TYPE_ID satrReadField, MV_U8 val)
-{
-	MV_BOARD_SATR_INFO satrInfo;
-	MV_U8 readValue, verifyValue;
-
-	if (satrReadField >= MV_SATR_READ_MAX_OPTION ||
-		satrWriteField >= MV_SATR_WRITE_MAX_OPTION) {
-		mvOsPrintf("%s: Error: wrong MV_SATR_TYPE_ID field value (%d).\n", __func__ ,satrWriteField);
-		return MV_ERROR;
-	}
-
-	if (mvBoardSatrInfoConfig(satrWriteField, &satrInfo, MV_FALSE) != MV_OK) {
-		mvOsPrintf("%s: Error: Requested S@R field is not relevant for this board\n", __func__);
-		return MV_ERROR;
-	}
-
-	/* read */
-	if (mvBoardTwsiGet(BOARD_DEV_TWSI_SATR, satrInfo.regNum, 0, &readValue) != MV_OK) {
-		mvOsPrintf("%s: Error: Read from S@R failed\n", __func__);
-		return MV_ERROR;
-	}
-
-	/* #1 Workaround for mirrored bits bug (for freq. mode SatR value only!)
-	 * Bug: all freq. mode bits are reversed when sampled at reset from I2C
-	 *		(caused due to a bug in board design)
-	 * Solution: reverse them before write to I2C
-	 *		(reverse only 5 bits - size of SatR field) */
-	if (satrWriteField == MV_SATR_WRITE_CPU_FREQ)
-		val = mvReverseBits(val) >> 3 ;
-
-	/* modify */
-	readValue &= ~(satrInfo.mask);             /* clean old value */
-	readValue |= (val <<  satrInfo.offset);    /* save new value */
-
-	/* write */
-	if (mvBoardTwsiSet(BOARD_DEV_TWSI_SATR, satrInfo.regNum, 0, readValue) != MV_OK) {
-		mvOsPrintf("%s: Error: Write to S@R failed\n", __func__);
-		return MV_ERROR;
-	}
-
-	/* verify */
-	if (mvBoardTwsiGet(BOARD_DEV_TWSI_SATR, satrInfo.regNum, 0, &verifyValue) != MV_OK) {
-		mvOsPrintf("%s: Error: 2nd Read from S@R failed\n", __func__);
-		return MV_ERROR;
-	}
-
-	if (readValue != verifyValue) {
-		mvOsPrintf("%s: Error: Write to S@R failed : written value doesn't match\n", __func__);
-		return MV_ERROR;
-	}
-
-	/* #2 Workaround for mirrored bits bug (for freq. mode SatR value only!)
-	 * Reverse bits again to locally save them properly */
-	if (satrWriteField == MV_SATR_WRITE_CPU_FREQ)
-		val = mvReverseBits(val) >> 3 ;
-
-	/* Save written value in global array */
-	satrOptionsConfig[satrReadField] = val;
-	return MV_OK;
-}
-
-/*******************************************************************************
-* mvCtrlSatRRead
-*
-* DESCRIPTION: Read S@R configuration Field
-*
-* INPUT: satrField - Field description enum
-*
-* OUTPUT: None
-*
-* RETURN:
-*	if field is valid - returns requested S@R field value
-*       else if field is not relevant for running board, return 0xFFFFFFF.
-*
-*******************************************************************************/
-MV_U32 mvCtrlSatRRead(MV_SATR_TYPE_ID satrField)
-{
-	MV_BOARD_SATR_INFO satrInfo;
-	if (satrField < MV_SATR_READ_MAX_OPTION &&
-			mvBoardSatrInfoConfig(satrField, &satrInfo, MV_TRUE) == MV_OK)
-		return satrOptionsConfig[satrField];
-	else
-		return MV_ERROR;
-}
-
-/*******************************************************************************
-* mvCtrlSmiMasterSet - alter Group 4 MPP type, between CPU SMI control and SWITCH SMI control
-*
-* DESCRIPTION: Read board configuration which is relevant to MPP group 4 interfaces,
-* 		to derive the correct group type, and according to input SMI conrtol,
-* 		write the correct MPP value.
-*
-* INPUT: smiCtrl - enum to select between SWITCH/CPU SMI controll
-*
-* OUTPUT: None
-*
-* RETURN: None
-*
-*******************************************************************************/
-MV_VOID mvCtrlSmiMasterSet(MV_SMI_CTRL smiCtrl)
-{
-	MV_BOOL isSwSMICtrl   = (smiCtrl == SWITCH_SMI_CTRL ? MV_TRUE : MV_FALSE);
-	MV_BOOL isBootDevSPI1 = (MSAR_0_BOOT_SPI1_FLASH == mvBoardBootDeviceGet());
-	MV_BOOL isRefClkOut   = !( mvBoardSlicUnitTypeGet() == SLIC_LANTIQ_ID ); 	/* if not using Lantiq TDM, define REF_CLK_OUT */
-	MV_U8 groupTypeSelect = 0;
-
-	if (! ((smiCtrl == SWITCH_SMI_CTRL) || (smiCtrl == CPU_SMI_CTRL)) ) {
-		DB(mvOsPrintf("mvCtrlSMISet: SMI ctrl initialize failed\n"));
-		return;
-	}
-
-	/* MPP settings :
-	 * Test board configuration relevant to MPP group 4, and derive the correct group type */
-
-	if (isRefClkOut)	/* add first REF_CLK_OUT group type */
-		groupTypeSelect += GE1_CPU_SMI_CTRL_REF_CLK_OUT;
-
-	if (isSwSMICtrl)	/* add first SW_SMI group type */
-		groupTypeSelect += GE1_SW_SMI_CTRL_TDM_LQ_UNIT;
-
-	if (isBootDevSPI1)	/* add first SPI1 group type */
-		groupTypeSelect += SPI1_CPU_SMI_CTRL_TDM_LQ_UNIT;
-
-	mvBoardMppTypeSet(4, groupTypeSelect);	/* Set MPP value according to group type */
-	MV_REG_WRITE(mvCtrlMppRegGet(4), mvBoardMppGet(4));
-
-	/* Mux settings :
-	 * Add mux configuration setup here ! */
-}
-
-/*******************************************************************************
 * mvCtrlCpuDdrL2FreqGet - Get the selected S@R Frequency mode
 *
 * DESCRIPTION:
@@ -490,84 +333,18 @@ MV_VOID mvCtrlSmiMasterSet(MV_SMI_CTRL smiCtrl)
 MV_STATUS mvCtrlCpuDdrL2FreqGet(MV_FREQ_MODE *freqMode)
 {
 	MV_FREQ_MODE freqTable[] = MV_SAR_FREQ_MODES;
-	MV_U32 freqModeSatRValue = mvCtrlSatRRead(MV_SATR_CPU_DDR_L2_FREQ);
+	MV_U32 freqModeSatRValue, satrVal;
 
-	if (MV_ERROR != freqModeSatRValue) {
+	satrVal = MV_REG_READ(MPP_SAMPLE_AT_RESET(1));
+	freqModeSatRValue = (satrVal & SATR_CPU_FREQ_MASK) >> SATR_CPU_FREQ_OFFS;
+
+	if (freqModeSatRValue <= 29) {
 		*freqMode = freqTable[freqModeSatRValue];
 		return MV_OK;
 	}
-
 	DB(mvOsPrintf("%s: Error Read from S@R fail\n", __func__));
 	return MV_ERROR;
 }
-
-/*******************************************************************************
-* mvCtrlSysConfigGet
-*
-* DESCRIPTION: Read Board configuration Field
-*
-* INPUT: configField - Field description enum
-*
-* OUTPUT: None
-*
-* RETURN:
-*	if field is valid - returns requested Board configuration field value
-*
-*******************************************************************************/
-MV_U32 mvCtrlSysConfigGet(MV_CONFIG_TYPE_ID configField)
-{
-	MV_BOARD_CONFIG_TYPE_INFO configInfo;
-
-	if (!mvBoardConfigAutoDetectEnabled()) {
-		mvOsPrintf("%s: Error reading board configuration", __func__);
-		mvOsPrintf("- Auto detection is disabled\n");
-		return MV_ERROR;
-	}
-
-	if (configField < MV_CONFIG_TYPE_MAX_OPTION &&
-		mvBoardConfigTypeGet(configField, &configInfo) != MV_TRUE) {
-		mvOsPrintf("%s: Error: Requested board config", __func__);
-		mvOsPrintf("is not valid for this board(%d)\n", configField);
-		return -1;
-	}
-
-	return boardOptionsConfig[configField];
-
-}
-
-/*******************************************************************************
-* mvCtrlSatrInit
-* DESCRIPTION: Initialize S@R configuration
-*               1. initialize all S@R and fields
-*               2. read relevant S@R fields (direct memory access)
-*               **from this point, all reads from S@R will use mvCtrlSatRRead/Write functions**
-*
-* INPUT:  None
-*
-* OUTPUT: None
-*
-* RETURN: NONE
-*
-*******************************************************************************/
-MV_VOID mvCtrlSatrInit(void)
-{
-	MV_U32 satrVal[2];
-	MV_BOARD_SATR_INFO satrInfo;
-	MV_U32 i;
-
-	/* initialize all S@R & Board configuration fields to -1 (MV_ERROR) */
-	memset(&satrOptionsConfig, 0x0, sizeof(MV_U32) * MV_SATR_READ_MAX_OPTION );
-
-	/* Read Sample @ Reset configuration, memory access read : */
-	satrVal[0] = MV_REG_READ(MPP_SAMPLE_AT_RESET(0));
-	satrVal[1] = MV_REG_READ(MPP_SAMPLE_AT_RESET(1));
-
-	for (i = 0; i < MV_SATR_READ_MAX_OPTION; i++)
-		if (mvBoardSatrInfoConfig(i, &satrInfo, MV_TRUE) == MV_OK)
-			satrOptionsConfig[satrInfo.satrId] = ((satrVal[satrInfo.regNum]  & (satrInfo.mask)) >> (satrInfo.offset));
-
-}
-
 /*******************************************************************************
 * mvCtrlDevFamilyIdGet - Get Device ID
 *
@@ -586,7 +363,9 @@ MV_VOID mvCtrlSatrInit(void)
 *******************************************************************************/
 MV_U32 mvCtrlDevFamilyIdGet(MV_U16 ctrlModel)
 {
-	return MV_88F67X0;
+	MV_U32 devFamilyId = ctrlModel & 0xFF00;
+
+	return devFamilyId;
 }
 
 /*******************************************************************************
@@ -971,7 +750,14 @@ MV_U32 mvCtrlTdmUnitIrqGet(MV_VOID)
 *******************************************************************************/
 MV_U16 mvCtrlModelGet(MV_VOID)
 {
-	return MV_6720_DEV_ID;
+	MV_U32	ctrlId = MV_REG_READ(DEV_ID_REG);
+	ctrlId = (ctrlId & (DEVICE_ID_MASK)) >> DEVICE_ID_OFFS;
+	if (ctrlId == 0x6820)
+		return MV_6820_DEV_ID;
+	if (ctrlId == 0x6810)
+		return MV_6810_DEV_ID;
+
+	return MV_INVALID_DEV_ID;
 }
 
 /*******************************************************************************
@@ -1733,3 +1519,38 @@ MV_U32 mvCtrlGetJuncTemp(MV_VOID)
 
 	return (3171900 - (10000 * reg)) / 13553;
 }
+/*******************************************************************************
+* mvCtrlNandClkSet
+*
+* DESCRIPTION:
+*       Set the division ratio of ECC Clock
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None
+*******************************************************************************/
+void mvCtrlNandClkSet(int nClock)
+{
+	/* Set the division ratio of ECC Clock 0x00018748[13:8] (by default it's double of core clock) */
+	MV_U32 nVal = MV_REG_READ(CORE_DIV_CLK_CTRL(1));
+	nVal &= ~(NAND_ECC_DIVCKL_RATIO_MASK);
+	nVal |= (nClock << NAND_ECC_DIVCKL_RATIO_OFFS);
+	MV_REG_WRITE(CORE_DIV_CLK_CTRL(1), nVal);
+
+	/* Set reload force of ECC clock 0x00018740[7:0] to 0x2 (meaning you will force only the ECC clock) */
+	nVal = MV_REG_READ(CORE_DIV_CLK_CTRL(0));
+	nVal &= ~(CORE_DIVCLK_RELOAD_FORCE_MASK);
+	nVal |= CORE_DIVCLK_RELOAD_FORCE_VAL;
+	MV_REG_WRITE(CORE_DIV_CLK_CTRL(0), nVal);
+
+	/* Set reload ratio bit 0x00018740[8] to 1'b1 */
+	MV_REG_BIT_SET(CORE_DIV_CLK_CTRL(0), CORE_DIVCLK_RELOAD_RATIO_MASK);
+	mvOsDelay(1); /*  msec */
+	/* Set reload ratio bit 0x00018740[8] to 0'b1 */
+	MV_REG_BIT_RESET(CORE_DIV_CLK_CTRL(0), CORE_DIVCLK_RELOAD_RATIO_MASK);
+}
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.h b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.h
index fbce500..c17fe84 100644
--- a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.h
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.h
@@ -73,79 +73,22 @@
 #include "ctrlEnv/mvCtrlEnvRegs.h"
 #include "ctrlEnv/mvCtrlEnvAddrDec.h"
 
-typedef enum _mvSatRTypeID {
-	// "Bios" Device
-	MV_SATR_CPU_DDR_L2_FREQ,
-	MV_SATR_CORE_CLK_SELECT,
-	MV_SATR_CPU1_ENABLE,
-	MV_SATR_SSCG_DISABLE,
-	// Jumpers  - change by removing Jumper. S@R will be changed by this option
-	MV_SATR_I2C0_SERIAL_ROM,
-	MV_SATR_EXTERNAL_CPU_RESET,
-	MV_SATR_EXTERNAL_CORE_RESET,
-	// DIP Switch - change by removing Switch. S@R will be changed by this option:
-	MV_SATR_BOOT_DEVICE,
-	// DPR's -modified by moving resistor with solderer. S@R will be changed by this
-	MV_SATR_CPU_PLL_XTAL_BYPASS,
-	MV_SATR_CPU0_ENDIANESS,
-	MV_SATR_CPU0_NMFI,
-	MV_SATR_CPU0_THUMB,
-	MV_SATR_PEX0_CLOCK,
-	MV_SATR_PEX1_CLOCK,
-	MV_SATR_REF_CLOCK_ENABLE,
-	MV_SATR_EFUSE_BYPASS,
-	MV_SATR_POR_BYPASS,
-	MV_SATR_TESTER_OPTIONS,
-	MV_SATR_BOARD_ID,
-	MV_SATR_READ_MAX_OPTION,
-	MV_SATR_WRITE_CPU_FREQ,
-	MV_SATR_WRITE_CORE_CLK_SELECT,
-	MV_SATR_WRITE_CPU1_ENABLE,
-	MV_SATR_WRITE_SSCG_DISABLE,
-	MV_SATR_WRITE_MAX_OPTION
-} MV_SATR_TYPE_ID;
 
 typedef enum _mvConfigTypeID {
-	MV_CONFIG_MAC0,
-	MV_CONFIG_MAC1,
-	MV_CONFIG_PON_SERDES,
-	MV_CONFIG_PON_BEN_POLARITY,
-	MV_CONFIG_SGMII0_CAPACITY,
-	MV_CONFIG_SGMII1_CAPACITY,
-	MV_CONFIG_LANE1,
-	MV_CONFIG_LANE2,
-	MV_CONFIG_LANE3,
-	MV_CONFIG_DEVICE_BUS_MODULE,
+	MV_CONFIG_SGMII,		/* module SGMII       */
+	MV_CONFIG_MII,			/* only one MII board */
 	MV_CONFIG_SLIC_TDM_DEVICE,
+	MV_CONFIG_I2S_DEVICE,
+	MV_CONFIG_SPDIF_DEVICE,
+	MV_CONFIG_SERDES_PEX_LAN1,
+	MV_CONFIG_SERDES_PEX_LAN2,
+	MV_CONFIG_NOR,
+	MV_CONFIG_NAND,
+	MV_CONFIG_SDIO,
+	MV_CONFIG_GIGA,
 	MV_CONFIG_TYPE_MAX_OPTION
 } MV_CONFIG_TYPE_ID;
 
-typedef enum _mvIoExpanderTypeID {
-	MV_IO_EXPANDER_SFP0_TX_DIS,
-	MV_IO_EXPANDER_SFP0_PRSNT,
-	MV_IO_EXPANDER_SFP0_TX_FAULT,
-	MV_IO_EXPANDER_SFP0_LOS,
-	MV_IO_EXPANDER_SFP1_PRSNT,
-	MV_IO_EXPANDER_SFP1_TX_FAULT,
-	MV_IO_EXPANDER_SFP1_LOS,
-	MV_IO_EXPANDER_SFP1_TX_DIS,
-	MV_IO_EXPANDER_USB_VBUS,
-	MV_IO_EXPANDER_MAC0_RJ45_PORT_LED,
-	MV_IO_EXPANDER_MAC0_SFP_PORT_LED,
-	MV_IO_EXPANDER_MAC1_RJ45_PORT_LED,
-	MV_IO_EXPANDER_MAC1_SFP_PORT_LED,
-	MV_IO_EXPANDER_PON_PORT_LED,
-	MV_IO_EXPANDER_SD_STATUS,
-	MV_IO_EXPANDER_SD_WRITE_PROTECT,
-	MV_IO_EXPANDER_JUMPER1,
-	MV_IO_EXPANDER_JUMPER2_EEPROM_ENABLED,
-	MV_IO_EXPANDER_JUMPER3,
-	MV_IO_EXPANDER_EXT_PHY_SMI_EN,
-	MV_IO_EXPANDER_SPI1_CS_MSB0,
-	MV_IO_EXPANDER_SPI1_CS_MSB1,
-	MV_IO_EXPANDER_INTEG_PHY_PORTS_LED,
-	MV_IO_EXPANDER_USB_SUPER_SPEED,
-} MV_IO_EXPANDER_TYPE_ID;
 
 /* This enumerator describes the possible SMI control options */
 typedef enum _mvSMIctrl {
@@ -182,23 +125,9 @@ typedef enum _mvSwapType {
  * the FE/GE phy interfaces.
  */
 typedef enum {
-	MV_ETHCOMP_SW_P0_2_GE_PHY_P0		=	BIT0,
-	MV_ETHCOMP_SW_P1_2_GE_PHY_P1		=	BIT1,
-	MV_ETHCOMP_SW_P2_2_GE_PHY_P2		=	BIT2,
-	MV_ETHCOMP_SW_P3_2_GE_PHY_P3		=	BIT3,
-	MV_ETHCOMP_SW_P4_2_RGMII0		=	BIT4,
-	/* Switch port 5 does not exist, ==> BIT5 is omitted */
-	MV_ETHCOMP_GE_MAC0_2_SW_P6		=	BIT6,
-	MV_ETHCOMP_GE_MAC0_2_GE_PHY_P0		=	BIT7,
-	MV_ETHCOMP_GE_MAC0_2_RGMII0		=	BIT8,
-	MV_ETHCOMP_GE_MAC0_2_COMPHY_1		=	BIT9,
-	MV_ETHCOMP_GE_MAC0_2_COMPHY_2		=	BIT10,
-	MV_ETHCOMP_GE_MAC0_2_COMPHY_3		=	BIT11,
-	MV_ETHCOMP_GE_MAC1_2_SW_P4		=	BIT12,
-	MV_ETHCOMP_GE_MAC1_2_GE_PHY_P3		=	BIT13,
-	MV_ETHCOMP_GE_MAC1_2_RGMII1		=	BIT14,
-	MV_ETHCOMP_GE_MAC1_2_PON_ETH_SERDES	=	BIT15,
-	MV_ETHCOMP_P2P_MAC_2_PON_ETH_SERDES	=	BIT16,
+	MV_ETHCOMP_SW_GE_0_1_DEFAULT		=	BIT0,
+	MV_ETHCOMP_SW_GE_0_1_SGMII_MODULE	=	BIT1,
+	MV_ETHCOMP_SW_GE_0_MII_MODULE		=	BIT2,
 } MV_ETH_COMPLEX_TOPOLOGY;
 
 typedef enum {
@@ -262,11 +191,7 @@ typedef struct _boardSerdesConf {
 #define SAR_CPU_FAB_GET(cpu, fab)       (((cpu & 0x7) << 21) | ((fab & 0xF) << 24))
 
 /* mcspLib.h API list */
-MV_STATUS mvCtrlSatRWrite(MV_SATR_TYPE_ID satrWriteField, MV_SATR_TYPE_ID satrReadField, MV_U8 val);
-MV_U32 mvCtrlSatRRead(MV_SATR_TYPE_ID satrField);
 MV_STATUS mvCtrlCpuDdrL2FreqGet(MV_FREQ_MODE *freqMode);
-MV_VOID mvCtrlSatrInit(MV_VOID);
-MV_VOID mvCtrlSysConfigInit(MV_VOID);
 MV_U32 mvCtrlSysConfigGet(MV_CONFIG_TYPE_ID configField);
 MV_U32 mvCtrlGetCpuNum(MV_VOID);
 MV_U32 mvCtrlGetQuadNum(MV_VOID);
@@ -279,7 +204,7 @@ MV_U32 mvCtrlSocUnitInfoNumGet(MV_UNIT_ID unit);
 MV_STATUS mvCtrlEnvInit(MV_VOID);
 MV_U32    mvCtrlMppRegGet(MV_U32 mppGroup);
 MV_U32 mvCtrlGetJuncTemp(MV_VOID);
-MV_STATUS mvEthComplexInit(MV_U32 ethCompConfig);
+void mvCtrlNandClkSet(int nClock);
 
 #if defined(MV_INCLUDE_PEX)
 MV_U32 mvCtrlPexMaxIfGet(MV_VOID);
@@ -336,30 +261,4 @@ MV_U32 mvCtrlDDRBudWidth(MV_VOID);
 MV_BOOL mvCtrlDDRThruXbar(MV_VOID);
 MV_BOOL mvCtrlDDRECC(MV_VOID);
 
-#define MV_SAR_INFO { \
-{ MV_SATR_CPU_DDR_L2_FREQ,	 0x003E0000,	17,	1, {1} },\
-{ MV_SATR_CORE_CLK_SELECT,	 0x00400000,	22,	1, {1} },\
-{ MV_SATR_CPU1_ENABLE,		 0x00008000,	15,	0, {1} },\
-{ MV_SATR_SSCG_DISABLE,		 0x00000002,	1,	0, {1} },\
-{ MV_SATR_I2C0_SERIAL_ROM,	 0X00000001,	0,	0, {1} },\
-{ MV_SATR_EXTERNAL_CPU_RESET,	 0X00000000,	0,	0, {1} },\
-{ MV_SATR_EXTERNAL_CORE_RESET,	 0X00000000,	0,	0, {1} },\
-{ MV_SATR_BOOT_DEVICE,		 0X000001F8,	3,	0, {1} },\
-{ MV_SATR_CPU_PLL_XTAL_BYPASS,	 0x00000200,	9,	0, {1} },\
-{ MV_SATR_PEX0_CLOCK,		 0x00000400,	10,	0, {1} },\
-{ MV_SATR_PEX1_CLOCK,		 0x00000800,	11,	0, {1} },\
-{ MV_SATR_REF_CLOCK_ENABLE,	 0x00000004,	2,	0, {1} },\
-{ MV_SATR_TESTER_OPTIONS,	 0x00080000,	19,	0, {1} },\
-{ MV_SATR_CPU0_ENDIANESS,	 0x00001000,	12,	0, {1} },\
-{ MV_SATR_CPU0_NMFI,		 0x00002000,	13,	0, {1} },\
-{ MV_SATR_CPU0_THUMB,		 0x00004000,	14,	0, {1} },\
-{ MV_SATR_EFUSE_BYPASS,		 0x00020000,	17,	0, {1} },\
-{ MV_SATR_POR_BYPASS,		 0x00100000,	20,	0, {1} },\
-{ MV_SATR_BOARD_ID,		 0x000000F0,	4,	1, {1} },\
-{ MV_SATR_WRITE_CPU_FREQ,	 0X0000001F,	0,	0, {1} },\
-{ MV_SATR_WRITE_CORE_CLK_SELECT, 0x00000001,	0,	1, {1} },\
-{ MV_SATR_WRITE_CPU1_ENABLE,	 0x00000002,	1,	1, {1} },\
-{ MV_SATR_WRITE_SSCG_DISABLE,	 0x00000004,	2,	1, {1} },\
-};
-
 #endif /* __INCmvCtrlEnvLibh */
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvRegs.h b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvRegs.h
index fa7861f..82deae9 100644
--- a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvRegs.h
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvRegs.h
@@ -132,10 +132,25 @@ extern "C" {
 #define MPP_SAMPLE_AT_RESET(id)		(0xE8200 + ( id * 0x4 ))
 #define SATR_DEVICE_ID_2_0_OFFS		21
 #define SATR_DEVICE_ID_2_0_MASK		(3 << SATR_DEVICE_ID_2_0_OFFS)
+#define SATR_CPU_FREQ_OFFS			17
+#define SATR_CPU_FREQ_MASK			(0x1F << SATR_CPU_FREQ_OFFS)
+#define SATR_CPU1_ENABLE_OFFS		15
+#define SATR_CPU1_ENABLE_MASK		(1 << SATR_CPU1_ENABLE_OFFS)
 
 /* Core Divider Clock Control */
 #define CORE_DIV_CLK_CTRL(num)		(0xE8250 + ((num) * 0x4))
 
+#define CORE_DIVCLK_RELOAD_FORCE_OFFS		0
+#define CORE_DIVCLK_RELOAD_FORCE_MASK		(0xFF << CORE_DIVCLK_RELOAD_FORCE_OFFS)
+#define CORE_DIVCLK_RELOAD_FORCE_VAL		(0x2 << CORE_DIVCLK_RELOAD_FORCE_OFFS)
+
+#define NAND_ECC_DIVCKL_RATIO_OFFS		8
+#define NAND_ECC_DIVCKL_RATIO_MASK		(0x3F << NAND_ECC_DIVCKL_RATIO_OFFS)
+
+#define CORE_DIVCLK_RELOAD_RATIO_OFFS		8
+#define CORE_DIVCLK_RELOAD_RATIO_MASK		(1 << CORE_DIVCLK_RELOAD_RATIO_OFFS)
+
+
 #define DEV_ID_REG			0x18238
 #define VENDOR_ID_OFFS			0
 #define VENDOR_ID_MASK			0xFFFF
@@ -175,7 +190,9 @@ typedef enum {
 	MSAR_0_BOOT_PEX,
 	MSAR_0_BOOT_SATA,
 	MSAR_0_BOOT_PROMPT,
-	MSAR_0_BOOT_SPI1_FLASH
+	MSAR_0_BOOT_SPI1_FLASH,
+	MSAR_0_BOOT_I2C,
+	MSAR_0_BOOT_SDIO
 } MV_BOARD_BOOT_SRC;
 
 typedef struct _mvSATRBootTable {
@@ -186,70 +203,64 @@ typedef struct _mvSATRBootTable {
 } MV_SATR_BOOT_TABLE;
 
 #define MV_SATR_TABLE_VAL { \
-/*00*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, 0, 0 }, \
-/*01*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT,             0, 1 }, \
-/*02*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, 0, 0 }, \
-/*03*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT,             0, 1 }, \
-/*04*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, 0, 0 }, \
-/*05*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT,             0, 1 }, \
-/*06*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, 0, 0 }, \
-/*07*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT,             0, 1 }, \
-/*08*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 0, 0 }, \
-/*09*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 6, 1 }, \
-/*10*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 0, 0 }, \
-/*11*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 6, 1 }, \
-/*12*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 4, 0 }, \
-/*13*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 6, 1 }, \
-/*14*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 5, 0 }, \
-/*15*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 5, 1 }, \
-/*16*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_512B, MSAR_0_NAND_ECC_4BIT }, \
-/*17*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_512B, MSAR_0_NAND_ECC_4BIT }, \
-/*18*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_4BIT },	\
-/*19*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_8BIT },	\
-/*20*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_12BIT }, \
-/*21*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_16BIT }, \
-/*22*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_4BIT },	\
-/*23*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_8BIT },	\
-/*24*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_12BIT }, \
-/*25*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_16BIT }, \
-/*26*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_4BIT },	\
-/*27*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_8BIT },	\
-/*28*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_12BIT }, \
-/*29*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_16BIT }, \
-/*30*/ { 0,           5,            60,          60           }, \
-/*31*/ { 0,           2,            40,          40           }, \
-/*32*/ {-1, -1, -1, -1 },\
-/*33*/ {-1, -1, -1, -1 },\
-/*34*/ {-1, -1, -1, -1 },\
-/*35*/ {-1, -1, -1, -1 },\
-/*36*/ {-1, -1, -1, -1 },\
-/*37*/ {-1, -1, -1, -1 },\
-/*38*/ { 0,           1,            2,            2              }, \
-/*39*/ { 0,           3,            6,            6              }, \
-/*40*/ { 0,           3,            5,            5              }, \
-/*41*/ { 0,           2,            6,            3              }, \
-/*42*/ { 0,           4,            10,          5              }, \
-/*43*/ { 0,           3,            6,            6              }, \
-/*44*/ { 0,           2,            4,            4              }, \
-/*45*/ { 0,           3,            6,            3              }, \
-/*46*/ { 0,           2,            5,            5              }, \
-/*47*/ { MSAR_0_BOOT_PROMPT,         2,            5,            5              }, \
-/*48*/ { MSAR_0_BOOT_UART,               1,            3,            3              }, \
-/*49*/ { MSAR_0_BOOT_SATA,                5,            10,          10           }, \
-/*50*/ { MSAR_0_BOOT_PEX,   3,            8,            4              }, \
-/*51*/ { MSAR_0_BOOT_PEX,   1,            2,            1              }, \
-/*52*/ { 0,           3,            6,            3              }, \
-/*53*/ { 0,           2,            8,            4              }, \
-/*54*/ { 0,           5,            10,          5              }, \
-/*55*/ { 0,           1,            20,          20           }, \
-/*56*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24_16BIT, 60        }, \
-/*57*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT, 60               }, \
-/*58*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI1, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24_16BIT, 60        }, \
-/*59*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI1, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT, 60               }, \
-/*60*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24_16BIT, 60        }, \
-/*61*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT, 60               }, \
-/*62*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI1, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24_16BIT, 60        }, \
-/*63*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI1, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT, 40               } \
+/*00*/ { MSAR_0_BOOT_NOR_FLASH, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, 0, 0 }, \
+/*01*/ { MSAR_0_BOOT_NOR_FLASH, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, 0, 1 }, \
+/*02*/ { MSAR_0_BOOT_NOR_FLASH, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, 0, 0 }, \
+/*03*/ { MSAR_0_BOOT_NOR_FLASH, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, 0, 1 }, \
+/*04*/ { MSAR_0_BOOT_NOR_FLASH, MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 0, 0 }, \
+/*05*/ { MSAR_0_BOOT_NOR_FLASH, MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 0, 1 }, \
+/*06*/ { MSAR_0_BOOT_NOR_FLASH, MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 0, 0 }, \
+/*07*/ { MSAR_0_BOOT_NOR_FLASH, MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 0, 1 }, \
+/*08*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_512B, 3 }, \
+/*09*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_512B, 4 }, \
+/*0A*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_4BIT }, \
+/*0B*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_8BIT }, \
+/*0C*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_12BIT}, \
+/*0D*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_16BIT}, \
+/*0E*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_4BIT }, \
+/*0F*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_8BIT }, \
+/*10*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_12BIT}, \
+/*11*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_16BIT}, \
+/*12*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_4BIT }, \
+/*13*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_8BIT }, \
+/*14*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_12BIT}, \
+/*15*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_16BIT}, \
+/*16*/ { -1, -1, -1, -1},	\
+/*17*/ { -1, -1, -1, -1}, \
+/*18*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_512B, 3}, \
+/*19*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_512B, 4}, \
+/*1A*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_4BIT }, \
+/*1B*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_8BIT }, \
+/*1C*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_12BIT}, \
+/*1D*/ { MSAR_0_BOOT_NAND_NEW,	MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_16BIT}, \
+/*1E*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_4BIT }, \
+/*1F*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_8BIT }, \
+/*20*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_12BIT},\
+/*21*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_16BIT},\
+/*22*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_4BIT },\
+/*23*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_8BIT },\
+/*24*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_12BIT},\
+/*25*/ { MSAR_0_BOOT_NAND_NEW,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_16BIT},\
+/*26*/ { -1, -1, -1, -1}, \
+/*27*/ { -1, -1, -1, -1}, \
+/*28*/ { MSAR_0_BOOT_UART,		0,		 0,		1 }, /* port, mpp, mpp */ \
+/*29*/ { MSAR_0_BOOT_UART,		1,		56,		55}, /* port, mpp, mpp */  \
+/*2A*/ { MSAR_0_BOOT_SATA,		0,		 0,		-1}, /* port, lane */  \
+/*2B*/ { MSAR_0_BOOT_SATA,		0,		 1,		-1}, /* port, lane */ \
+/*2C*/ { MSAR_0_BOOT_PEX,		0,		 0,		-1}, /* port, lane */ \
+/*2D*/ { MSAR_0_BOOT_PEX,		0,		 1,		-1}, /* port, lane */ \
+/*2E*/ { MSAR_0_BOOT_I2C,		0,		 3,		 2}, /* port, mpp, mpp */ \
+/*2F*/ { -1, -1, -1, -1}, \
+/*30*/ { MSAR_0_BOOT_SDIO,		0,		59,		54}, /* port, mpp, mpp */ \
+/*31*/ { MSAR_0_BOOT_SDIO,		0,		40,		37}, /* port, mpp, mpp */ \
+/*32*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24BIT, 25}, \
+/*33*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT, 25}, \
+/*34*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI1, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24BIT, 59}, \
+/*35*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI1, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT, 59}, \
+/*36*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24BIT, 25}, \
+/*37*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT, 25}, \
+/*38*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24BIT, 25}, \
+/*39*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT, 25} \
 }
 
 typedef struct {
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvSpec.h b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvSpec.h
index af055283..8aeb048 100644
--- a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvSpec.h
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvSpec.h
@@ -78,7 +78,7 @@ extern "C" {
 #define SOC_NAME_PREFIX                         "MV88F"
 
 /*
- * Armada-375 Units Address decoding
+ * Armada-38x Units Address decoding
  */
 #define MV_DRAM_REGS_OFFSET                     (0x0)
 #define MV_AURORA_L2_REGS_OFFSET                (0x8000)
@@ -220,7 +220,7 @@ extern "C" {
 #define MV_SPI_VERSION                          2
 
 #define MV_INCLUDE_SDRAM_CS0
-#define  MV_INCLUDE_SDRAM_CS1
+#define MV_INCLUDE_SDRAM_CS1
 #undef  MV_INCLUDE_SDRAM_CS2
 #undef  MV_INCLUDE_SDRAM_CS3
 
@@ -232,8 +232,9 @@ extern "C" {
 #ifndef MV_ASMLANGUAGE
 
 #define TBL_UNUSED      0       /* Used to mark unused entry */
-#define FREQ_MODES_NUM          29
-#define FREQ_MODES_NUM_6720	3
+#define FREQ_MODES_NUM		29
+#define FREQ_MODES_NUM_6810	3
+#define FREQ_MODES_NUM_6820	3
 
 #define MPP_GROUP_0_TYPE { \
 	0x55555555,     /* NAND_V2_BOOT_DEVICE  */ \
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/sys/mvCpuIfRegs.h b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/sys/mvCpuIfRegs.h
index 725d769..b80b8e2 100644
--- a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/sys/mvCpuIfRegs.h
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/sys/mvCpuIfRegs.h
@@ -87,8 +87,8 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #define CPU_SOFT_RESET_REG(cpu)			(MV_MBUS_REGS_OFFSET + 0x800 + (cpu) * 0x8)
 
-#define CPU_RSTOUTN_MASK_REG			(MV_MISC_REGS_BASE + 0x54)
-#define CPU_SYS_SOFT_RST_REG			(MV_MISC_REGS_BASE + 0x58)
+#define CPU_RSTOUTN_MASK_REG			(MV_MISC_REGS_BASE + 0x60)
+#define CPU_SYS_SOFT_RST_REG			(MV_MISC_REGS_BASE + 0x64)
 #define CPU_L2_CTRL_REG				(MV_L2C_REGS_BASE + 0x100)
 #define CPU_L2_AUX_CTRL_REG			(MV_L2C_REGS_BASE + 0x104)
 #define SOC_CTRL_REG				(MV_MISC_REGS_BASE + 0x4)
-- 
1.7.5.4

