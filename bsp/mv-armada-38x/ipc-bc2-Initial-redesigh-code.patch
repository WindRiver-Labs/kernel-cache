From fa22911b814f384a6e48a1e220c35c7901327828 Mon Sep 17 00:00:00 2001
From: Igor Patrik <igorp@marvell.com>
Date: Thu, 3 Oct 2013 16:17:45 +0200
Subject: [PATCH 1006/1825] ipc: bc2: Initial redesigh code

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 54373f2a77640637627992ad9e45561e4ecba3e6

	Code changes by new design requerements, initial code.
	Main changes:
		Added OS/HW/common layers.
		OS layer implements OS dependent function, like memory mapping, and driver init entry point.
		HW layer is interrupt or polling functions implementation.
		Common layer is configuration layer implements function defining the link/node configuration.
		RX/TX queue size is per channel.
		HAL layer changes:
			Init sequence in master slave mode.
			Link based, every link is separated shared memory region.
			mvIpcShmemMalloc now is HAL function.

        Note: IPC tested on AXP board with BC2 defconfig, testing on AvantaLP should be done.

Change-Id: I5e5993b16bb8d14f86583ba1fa83c6b71e6941a9
Signed-off-by: Igor Patrik <igorp@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/3616
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/boot/.gitignore                           |    2 +-
 arch/arm/include/asm/entry-macro-multi.S           |    2 +-
 arch/arm/mach-armadaxp/Makefile                    |    4 +-
 arch/arm/mach-armadaxp/config/mvRules.mk           |    4 +-
 arch/arm/mach-armadaxp/core.c                      |    2 +-
 arch/arm/mach-avantalp/Makefile                    |    2 +-
 arch/arm/plat-armada/Kconfig                       |    6 +-
 arch/arm/plat-armada/common/mvIpc.c                | 1553 +++++++++++++-------
 arch/arm/plat-armada/common/mvIpc.h                |  224 ++--
 .../arm/plat-armada/mv_drivers_lsp/mv_ipc/Makefile |    5 +-
 .../mv_ipc/linux_amp/mv_ipc_common.c               |  185 +++
 .../mv_ipc/linux_amp/mv_ipc_common.h               |  111 ++
 .../mv_ipc/linux_amp/mv_ipc_doorbell.c             |  190 +++
 .../mv_ipc/linux_amp/mv_ipc_doorbell.h             |   74 +
 .../mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_node.h  |   81 +
 .../mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_os.c    |  178 +++
 .../mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_os.h    |   40 +
 .../mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_poll.c  |  186 +++
 .../mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_poll.h  |   74 +
 .../arm/plat-armada/mv_drivers_lsp/mv_ipc/mv_ipc.c |  238 ---
 .../arm/plat-armada/mv_drivers_lsp/mv_ipc/mv_ipc.h |   53 -
 .../plat-armada/mv_drivers_lsp/mv_ipc_net/Makefile |    2 +-
 .../mv_drivers_lsp/mv_ipc_net/ipc_net.c            |   74 +-
 tools/amp/amp_make.pl                              |    1 +
 24 files changed, 2293 insertions(+), 998 deletions(-)
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_common.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_common.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_doorbell.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_doorbell.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_node.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_os.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_os.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_poll.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_poll.h
 delete mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/mv_ipc.c
 delete mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/mv_ipc.h

diff --git a/arch/arm/boot/.gitignore b/arch/arm/boot/.gitignore
index 3c79f85..b7c556c 100644
--- a/arch/arm/boot/.gitignore
+++ b/arch/arm/boot/.gitignore
@@ -2,5 +2,5 @@ Image
 zImage
 xipImage
 bootpImage
-uImage
+uImage*
 *.dtb
diff --git a/arch/arm/include/asm/entry-macro-multi.S b/arch/arm/include/asm/entry-macro-multi.S
index 50a7f3f..9719368 100644
--- a/arch/arm/include/asm/entry-macro-multi.S
+++ b/arch/arm/include/asm/entry-macro-multi.S
@@ -20,7 +20,7 @@
 	 * this macro assumes that irqstat (r2) and base (r6) are
 	 * preserved from get_irqnr_and_base above
 	 */
-#ifdef CONFIG_MV_IPC_DRIVER
+#ifdef CONFIG_MV_IPC_LINUX_AMP_DRIVER
 	test_for_ipc r0, r2, r6, lr
 	movne   r1, sp
 	adrne   lr, BSYM(1b)
diff --git a/arch/arm/mach-armadaxp/Makefile b/arch/arm/mach-armadaxp/Makefile
index bd51812..3280c4c 100755
--- a/arch/arm/mach-armadaxp/Makefile
+++ b/arch/arm/mach-armadaxp/Makefile
@@ -17,7 +17,7 @@ include 	  $(srctree)/arch/arm/mach-armadaxp/config/mvRules.mk
 
 
 # Objects list
-COMMON_OBJS	= $(COMMON_DIR)/mvDebug.o $(COMMON_DIR)/mvCommon.o $(COMMON_DIR)/mvStack.o $(COMMON_DIR)/mvList.o $(COMMON_DIR)/mvIpc.o
+COMMON_OBJS	= $(COMMON_DIR)/mvDebug.o $(COMMON_DIR)/mvCommon.o $(COMMON_DIR)/mvStack.o $(COMMON_DIR)/mvList.o
 
 OSSERVICES_OBJS	= $(OSSERV_DIR)/mvOs.o
 
@@ -103,7 +103,7 @@ obj-$(CONFIG_ERROR_HANDLING)		   += $(LSP_ERR_DIR)/mv_error.o
 
 obj-$(CONFIG_MV_USE_XOR_ENGINE) 	+= $(PLAT_DRIVERS)/mv_xor/
 obj-$(CONFIG_MV_CESA) 			+= $(PLAT_DRIVERS)/mv_cesa/
-obj-$(CONFIG_MV_IPC_DRIVER)		+= $(PLAT_DRIVERS)/mv_ipc/
+obj-$(CONFIG_MV_IPC_LINUX_AMP_DRIVER)		+= $(COMMON_DIR)/mvIpc.o $(PLAT_DRIVERS)/mv_ipc/
 obj-$(CONFIG_MV_IPC_NET)		+= $(PLAT_DRIVERS)/mv_ipc_net/
 #obj-y					+= $(PLAT_DRIVERS)/mv_btns/
 obj-y					+= $(PLAT_DRIVERS)/mv_gpio/
diff --git a/arch/arm/mach-armadaxp/config/mvRules.mk b/arch/arm/mach-armadaxp/config/mvRules.mk
index c11ac65..c409d0c 100644
--- a/arch/arm/mach-armadaxp/config/mvRules.mk
+++ b/arch/arm/mach-armadaxp/config/mvRules.mk
@@ -99,6 +99,8 @@ LSP_TRACE_DIR     = $(PLAT_DRIVERS)/mv_trace
 LSP_SWITCH_DIR    = $(PLAT_DRIVERS)/mv_switch
 LSP_PHY_DIR       = $(PLAT_DRIVERS)/mv_phy
 LSP_ERR_DIR       = $(PLAT_DRIVERS)/mv_error
+LSP_IPC_DIR       = $(PLAT_DRIVERS)/mv_ipc/linux_amp
+
 
 # Environment components
 AXP_FAM_DIR	= armada_xp_family
@@ -128,7 +130,7 @@ LSP_PATH        = -I$(LSP_PATH_I)
 CONFIG_PATH     = -I$(LSP_PATH_I)/$(CONFIG_DIR)
 HAL_IF_PATH	= -I$(LSP_PATH_I)/$(HAL_IF)
 DRIVERS_LSP_PATH = -I$(PLAT_PATH_I)/$(PLAT_DRIVERS) -I$(PLAT_PATH_I)/$(LSP_NETWORK_DIR) -I$(PLAT_PATH_I)/$(LSP_SWITCH_DIR) \
-		 -I$(PLAT_PATH_I)/$(LSP_TRACE_DIR) -I$(PLAT_PATH_I)/$(LSP_NETA_DIR)
+		-I$(PLAT_PATH_I)/$(LSP_TRACE_DIR) -I$(PLAT_PATH_I)/$(LSP_NETA_DIR) -I$(PLAT_PATH_I)/$(LSP_IPC_DIR)
 
 EXTRA_INCLUDE  	= $(OSSERV_PATH) $(COMMON_PATH) $(HAL_PATH)  $(AXP_FAM_PATH) \
                   $(LSP_PATH) $(CONFIG_PATH) $(DRIVERS_LSP_PATH) $(HAL_IF_PATH)
diff --git a/arch/arm/mach-armadaxp/core.c b/arch/arm/mach-armadaxp/core.c
index 995c406..92014bd 100644
--- a/arch/arm/mach-armadaxp/core.c
+++ b/arch/arm/mach-armadaxp/core.c
@@ -410,7 +410,7 @@ static int __init mv_shared_mem_setup(char *s)
 __setup("mv_sh_mem=", mv_shared_mem_setup);
 #endif /* CONFIG_MV_AMP_ENABLE */
 
-#ifdef CONFIG_MV_IPC_DRIVER
+#ifdef CONFIG_MV_IPC_LINUX_AMP_DRIVER
 int ipc_target_cpu;
 static int __init mv_ipc_setup(char *s)
 {
diff --git a/arch/arm/mach-avantalp/Makefile b/arch/arm/mach-avantalp/Makefile
index d8b026c..fd2fb49 100644
--- a/arch/arm/mach-avantalp/Makefile
+++ b/arch/arm/mach-avantalp/Makefile
@@ -17,7 +17,7 @@ include 	  $(srctree)/arch/arm/mach-avantalp/config/mvRules.mk
 
 
 # Objects list
-COMMON_OBJS	= $(COMMON_DIR)/mvDebug.o $(COMMON_DIR)/mvCommon.o $(COMMON_DIR)/mvStack.o $(COMMON_DIR)/mvList.o $(COMMON_DIR)/mvIpc.o
+COMMON_OBJS	= $(COMMON_DIR)/mvDebug.o $(COMMON_DIR)/mvCommon.o $(COMMON_DIR)/mvStack.o $(COMMON_DIR)/mvList.o
 
 OSSERVICES_OBJS	= $(OSSERV_DIR)/mvOs.o
 
diff --git a/arch/arm/plat-armada/Kconfig b/arch/arm/plat-armada/Kconfig
index d212e2f..272b433 100644
--- a/arch/arm/plat-armada/Kconfig
+++ b/arch/arm/plat-armada/Kconfig
@@ -209,14 +209,14 @@ config MV_UART_PORT_G1
         depends on MV_AMP_ENABLE
         default 1
 
-config MV_IPC_DRIVER
-        bool "Enable IPC basic driver"
+config MV_IPC_LINUX_AMP_DRIVER
+        bool "Enable IPC basic driver based on AMP kernel-kernel"
         depends on   MV_AMP_ENABLE
         default y
 
 config MV_IPC_NET
         bool "Enable IPC pseudo network driver"
-        depends on MV_IPC_DRIVER
+        depends on MV_IPC_LINUX_AMP_DRIVER
         default y
 
 config MV_DRAM_BASE
diff --git a/arch/arm/plat-armada/common/mvIpc.c b/arch/arm/plat-armada/common/mvIpc.c
index 3deb0e1..bd633d0 100644
--- a/arch/arm/plat-armada/common/mvIpc.c
+++ b/arch/arm/plat-armada/common/mvIpc.c
@@ -1,64 +1,64 @@
 /*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
+   Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
 
 ********************************************************************************
-Marvell Commercial License Option
+   Marvell Commercial License Option
 
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
+   If you received this File from Marvell and you have entered into a commercial
+   license agreement (a "Commercial License") with Marvell, the File is licensed
+   to you under the terms of the applicable Commercial License.
 
 ********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
 ********************************************************************************
-Marvell BSD License Option
+   Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File under the following licensing terms.
+   Redistribution and use in source and binary forms, with or without modification,
+   are permitted provided that the following conditions are met:
 
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
+*   Redistributions of source code must retain the above copyright notice,
+		this list of conditions and the following disclaimer.
 
-    *   Redistributions in binary form must reproduce the above copyright
+*   Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
         documentation and/or other materials provided with the distribution.
 
-    *   Neither the name of Marvell nor the names of its contributors may be
+*   Neither the name of Marvell nor the names of its contributors may be
         used to endorse or promote products derived from this software without
         specific prior written permission.
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+   ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+   ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
 
@@ -69,177 +69,402 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "mvIpc.h"
 #include "mvOs.h"
 
+#include "mv_ipc_common.h"
+
 //#define MV_IPC_DEBUG
 #ifdef MV_IPC_DEBUG
 #define mvIpcDbgPrintf mvOsPrintf
 #else
-#define mvIpcDbgPrintf(x...)
+#define mvIpcDbgPrintf(x ...)
 #endif
 
-//#define mvIpcDbgWrite(x, y)  (x = y);
-#define mvIpcDbgWrite(x, y)
+#define mvIpcDbgWrite(x, y)  (x = y);
+/*#define mvIpcDbgWrite(x, y)*/
 
 #define mvIpcErrPrintf mvOsPrintf
 
+/*main data structure - links array*/
+MV_IPC_LINK mv_ipc_links[MV_IPC_LINKS_NUM];
 
-//int axp_read_soc_clock(int timer_id);
+/***********************************************************************************
+ * mvIpcChannelsOffsetsFix
+ *
+ * DESCRIPTION:
+ *		This add base address to all addresses in link and channel structures
+ *
+ * INPUT:
+ *		link  - Link structure to be fixed
+ *		base  - Base address
+ * OUTPUT:
+ *       None
+ * RETURN:
+ *		status
+ *
+ ************************************************************************************/
+static MV_VOID mvIpcChannelsOffsetsFix(MV_IPC_LINK *link, MV_U32 base)
+{
+	int chnIdx;
 
-#define  IPC_BASE_DOORBELL  12
+	/*Fixup all offsets to shmem to local addresses*/
+	for (chnIdx = 0; chnIdx < link->numOfChannels; chnIdx++) {
+		link->channels[chnIdx].rxMsgQueVa =
+			(MV_IPC_MSG *)(base + (MV_U32)link->channels[chnIdx].rxMsgQueVa);
+		link->channels[chnIdx].txMsgQueVa =
+			(MV_IPC_MSG *)(base + (MV_U32)link->channels[chnIdx].txMsgQueVa);
 
-unsigned int    myCpuId;
-void   		    *queueBaseAddr;
-MV_IPC_CHANNEL  ipcChannels[MAX_IPC_CHANNELS];
+		link->channels[chnIdx].rxCtrlMsg    = &link->channels[chnIdx].rxMsgQueVa[0];
+		link->channels[chnIdx].txCtrlMsg    = &link->channels[chnIdx].txMsgQueVa[0];
 
+		link->channels[chnIdx].txMessageFlag += base;
+		link->channels[chnIdx].rxMessageFlag += base;
+	}
+
+	link->txSharedHeapAddr += base;
+	link->rxSharedHeapAddr += base;
+}
 
 /***********************************************************************************
-* mvIpcGetQueue
-*
-* DESCRIPTION:
-*		This routine allocates an IPC queue from the shared memory space
-*		Since the queue location must be at the same address for both parties
-*		the exact location is determined by this function
-*
-* INPUT:
-*		qId   - the id of the queue to allocate
-*		isRx  - is it used to receive messages
-*		qSize - size of individual queue
-* OUTPUT:
-*       None
-* RETURN:
-*		void * - return pointer to queue
-*
-************************************************************************************/
-static void* mvIpcGetQueue(int qId, bool isRx, int qSize)
+ * mvIpcSlaveConfig
+ *
+ * DESCRIPTION:
+ *		This routine read configuration from shared memory and fill local
+ *		structires with data configured by Master.
+ *		Can be called from mvIpcInit or postponed by and called from mvIpcOpenChannel
+ *
+ * INPUT:
+ *		linkId  - Link id to be configred
+ * OUTPUT:
+ *       None
+ * RETURN:
+ *		status
+ *
+ ************************************************************************************/
+static MV_STATUS mvIpcSlaveConfig(MV_U32 linkId)
 {
-	void *ptr;
+	MV_U32 chnIdx;
+	MV_IPC_LINK *link;
+	MV_U32 tempAddr;
+	MV_IPC_MSG *tempQueVa;
 
-	ptr = (void *)((MV_U8*)queueBaseAddr + (qId * 2 * qSize) + (qSize * isRx));
+	/* Verify parameters */
+	if (linkId > MV_IPC_LINKS_NUM) {
+		mvIpcErrPrintf("IPC ERROR: IPC Init: Bad link id %d\n", linkId);
+		return MV_FALSE;
+	}
 
-	return ptr;
+	link = &mv_ipc_links[linkId];
+	/*Read link structure from shared mem*/
+	mvOsMemcpy(link, mvIpcGetShmemAddr(linkId), sizeof(MV_IPC_LINK));
+
+	/*Override local paramters for link*/
+	link->nodeId            = mvIpcWhoAmI();
+	link->shmemBaseAddr = (MV_U32)mvIpcGetShmemAddr(linkId);
+	link->remoteNodeId      = mvIpcGetlinkRemoteNodeId(linkId);
+	link->channels = mvOsMalloc(sizeof(MV_IPC_CHANNEL) * link->numOfChannels);
+
+	/*Swap rx and tx fields for Heap region partition*/
+	tempAddr = link->txSharedHeapAddr;
+	link->txSharedHeapAddr = link->rxSharedHeapAddr;
+	link->rxSharedHeapAddr = tempAddr;
+	tempAddr = link->txSharedHeapSize;
+	link->txSharedHeapSize = link->rxSharedHeapSize;
+	link->rxSharedHeapSize = tempAddr;
+
+	/* Initialize all channels */
+	for (chnIdx = 0; chnIdx < link->numOfChannels; chnIdx++) {
+		/*Read channel structure from shared mem*/
+		mvOsMemcpy(&link->channels[chnIdx],
+			   (MV_VOID *)(link->shmemBaseAddr + sizeof(MV_IPC_LINK) + (chnIdx * sizeof(MV_IPC_CHANNEL))),
+			   sizeof(MV_IPC_CHANNEL));
+
+		link->channels[chnIdx].state        = MV_CHN_CLOSED;
+		link->channels[chnIdx].txEnable     = MV_FALSE;
+		link->channels[chnIdx].rxEnable     = MV_FALSE;
+		link->channels[chnIdx].nextRxMsgIdx = 1;
+		link->channels[chnIdx].nextTxMsgIdx = 1;
+
+		/*Swap RX and TX queue start */
+		tempQueVa = link->channels[chnIdx].rxMsgQueVa;
+		link->channels[chnIdx].rxMsgQueVa = link->channels[chnIdx].txMsgQueVa;
+		link->channels[chnIdx].txMsgQueVa   = tempQueVa;
+
+		mvIpcDbgPrintf("IPC HAL: Init channel %d with RxQ = 0x%08x; TxQ = 0x%08x\n",
+			       chnIdx, (unsigned int)link->channels[chnIdx].rxMsgQueVa,
+			       (unsigned int)link->channels[chnIdx].txMsgQueVa);
+
+		/*Set rx and tx functions*/
+		link->channels[chnIdx].sendTrigger = mvIpcGetChnTxHwPtr(linkId);
+		link->channels[chnIdx].registerChnInISR = mvIpcGetChnRxHwPtr(linkId);
+
+		tempAddr = link->channels[chnIdx].txMessageFlag;
+		link->channels[chnIdx].txMessageFlag = link->channels[chnIdx].rxMessageFlag;
+		link->channels[chnIdx].rxMessageFlag = tempAddr;
+	}
+
+	/*Fixup all offsets to shmem to local addresses*/
+	mvIpcChannelsOffsetsFix(link, link->shmemBaseAddr);
+
+	return MV_OK;
 }
 
 /***********************************************************************************
-* mvIpcInit
-*
-* DESCRIPTION:
-*		Initializes the IPC mechanism. reset all queues and sets global variables
-*
-* INPUT:
-*		qBasePtr - base pointer to queue space
-*		primary  - is this the primary initializer. help locating queue addresses
-* OUTPUT:
-*       None
-* RETURN:
-*		MV_OK or MV_ERROR
-*
-************************************************************************************/
-MV_STATUS mvIpcInit(MV_VOID *qbasePtr, MV_BOOL primary)
+ * mvIpcLinkStart
+ *
+ * DESCRIPTION:
+ *		Initializes the IPC mechanism. reset all queues and sets global variables
+ *
+ * INPUT:
+ *		linkId  - Link id to be configred
+ * OUTPUT:
+ *       None
+ * RETURN:
+ *		MV_OK or MV_ERROR
+ *
+ ************************************************************************************/
+MV_STATUS mvIpcLinkStart(MV_U32 linkId)
 {
 	MV_U32 chnIdx;
+	MV_IPC_LINK             *link;
+	/*runningOffset is offset in shared memory,
+	used to compute addreses of queues and heap*/
+	MV_U32 runningOffset = 0, flagsOffset;
+	MV_U32 heapSize;
 
-	myCpuId        = whoAmI();
-	queueBaseAddr  = qbasePtr;
+	/* Verify parameters */
+	if (linkId > MV_IPC_LINKS_NUM) {
+		mvIpcErrPrintf("IPC ERROR: IPC Init: Bad link id %d\n", linkId);
+		return MV_FALSE;
+	}
 
-	/* Initialize all channels */
-	for(chnIdx = 0; chnIdx < MAX_IPC_CHANNELS; chnIdx++) {
-		ipcChannels[chnIdx].state        = MV_CHN_CLOSED;
-		ipcChannels[chnIdx].txEnable     = MV_FALSE;
-		ipcChannels[chnIdx].rxEnable     = MV_FALSE;
-		ipcChannels[chnIdx].queSizeInMsg = MV_IPC_QUEUE_SIZE;
-		ipcChannels[chnIdx].nextRxMsgIdx = 1;
-		ipcChannels[chnIdx].nextTxMsgIdx = 1;
-		ipcChannels[chnIdx].rxMsgQueVa   = mvIpcGetQueue(chnIdx, (primary == MV_TRUE),  MV_IPC_QUEUE_SIZE * sizeof(MV_IPC_MSG));
-		ipcChannels[chnIdx].txMsgQueVa   = mvIpcGetQueue(chnIdx, (primary == MV_FALSE), MV_IPC_QUEUE_SIZE * sizeof(MV_IPC_MSG));
-		ipcChannels[chnIdx].rxCtrlMsg    = &ipcChannels[chnIdx].rxMsgQueVa[0];
-		ipcChannels[chnIdx].txCtrlMsg    = &ipcChannels[chnIdx].txMsgQueVa[0];
-
-		if(primary){
-			mvOsMemset(ipcChannels[chnIdx].rxMsgQueVa, 0, MV_IPC_QUEUE_SIZE * sizeof(MV_IPC_MSG));
-			mvOsMemset(ipcChannels[chnIdx].txMsgQueVa, 0, MV_IPC_QUEUE_SIZE * sizeof(MV_IPC_MSG));
+	link = &mv_ipc_links[linkId];
+
+	if (MV_TRUE == mvIpcGetlinkMaster(linkId)) {
+		/*master configuration*/
+
+		link->nodeId            = mvIpcWhoAmI();
+		link->shmemBaseAddr =   (MV_U32)mvIpcGetShmemAddr(linkId);
+		link->shmemSize =               (MV_U32)mvIpcGetShmemSize(linkId);
+		link->numOfChannels     = mvIpcChnNum(linkId);
+		link->remoteNodeId      = mvIpcGetlinkRemoteNodeId(linkId);
+		link->channels = mvOsMalloc(sizeof(MV_IPC_CHANNEL) * link->numOfChannels);
+
+		/*Skip the control structures in Shared mem*/
+		/*Note: all pointers to shmem will be offsets,
+		after controle structures will be copied ti shmem, them will be fixed to addresses*/
+		runningOffset += sizeof(MV_IPC_LINK);
+		runningOffset += sizeof(MV_IPC_CHANNEL) * link->numOfChannels;
+		/*Skip the RX/TX flags in Shared mem*/
+		flagsOffset = runningOffset;
+		runningOffset += 2 * sizeof(MV_U32) * link->numOfChannels;
+
+		/* Initialize all channels */
+		for (chnIdx = 0; chnIdx < link->numOfChannels; chnIdx++) {
+			link->channels[chnIdx].state        = MV_CHN_CLOSED;
+			link->channels[chnIdx].txEnable     = MV_FALSE;
+			link->channels[chnIdx].rxEnable     = MV_FALSE;
+			link->channels[chnIdx].queSizeInMsg = mvIpcGetChnQueueSize(linkId, chnIdx);
+			link->channels[chnIdx].nextRxMsgIdx = 1;
+			link->channels[chnIdx].nextTxMsgIdx = 1;
+
+			/*set RX queue start move offset to queue size * message size*/
+			link->channels[chnIdx].rxMsgQueVa   = (MV_IPC_MSG *)runningOffset;
+			runningOffset += link->channels[chnIdx].queSizeInMsg * sizeof(MV_IPC_MSG);
+
+			/*set TX queue start move offset to queue size * message size*/
+			link->channels[chnIdx].txMsgQueVa   = (MV_IPC_MSG *)runningOffset;
+			runningOffset += link->channels[chnIdx].queSizeInMsg * sizeof(MV_IPC_MSG);
+
+			mvOsMemset((MV_VOID *)(link->shmemBaseAddr + (MV_U32)link->channels[chnIdx].rxMsgQueVa), 0,
+				   link->channels[chnIdx].queSizeInMsg * sizeof(MV_IPC_MSG));
+			mvOsMemset((MV_VOID *)(link->shmemBaseAddr + (MV_U32)link->channels[chnIdx].txMsgQueVa), 0,
+				   link->channels[chnIdx].queSizeInMsg * sizeof(MV_IPC_MSG));
+
+			mvIpcDbgPrintf("IPC HAL: Init channel %d with RxQ = 0x%08x; TxQ = 0x%08x\n",
+				       chnIdx, (unsigned int)link->channels[chnIdx].rxMsgQueVa,
+				       (unsigned int)link->channels[chnIdx].txMsgQueVa);
+
+			/*Set rx and tx functions*/
+			link->channels[chnIdx].sendTrigger = mvIpcGetChnTxHwPtr(linkId);
+			link->channels[chnIdx].registerChnInISR = mvIpcGetChnRxHwPtr(linkId);
+
+			link->channels[chnIdx].txMessageFlag = flagsOffset + 2 * chnIdx * sizeof(MV_U32);
+			link->channels[chnIdx].rxMessageFlag = flagsOffset + (2 * chnIdx + 1) * sizeof(MV_U32);
 		}
 
-		mvIpcDbgPrintf("IPC HAL: Init channel %d with RxQ = 0x%08x; TxQ = 0x%08x\n",
-			       chnIdx, (unsigned int)ipcChannels[chnIdx].rxMsgQueVa, (unsigned int)ipcChannels[chnIdx].txMsgQueVa);
-	}
+		/*Check if we have enouth shared memory for all channels*/
+		if (runningOffset > mvIpcGetShmemSize(linkId)) {
+			mvIpcDbgPrintf("IPC HAL: Init channels allocated 0x%X bytes, shmem is 0x%X bytes\n",
+				       runningOffset, mvIpcGetShmemSize(linkId));
+
+			return MV_FAIL;
+		}
 
-	mvIpcDbgPrintf("IPC HAL: Initialized interface as %s\n", (primary == MV_TRUE) ? "primary" : "secondary");
+		/*Heap region partition*/
+		heapSize = mvIpcGetShmemSize(linkId) - runningOffset;
+		link->txSharedHeapAddr = runningOffset;
+		link->txSharedHeapSize = (heapSize * mvIpcGetFreeMemMasterPercent(linkId))/100;
+		runningOffset += link->txSharedHeapSize;
+		link->rxSharedHeapAddr = runningOffset;
+		link->rxSharedHeapSize = mvIpcGetShmemSize(linkId) - runningOffset;
+
+		/*Link and channel structures ready, copy channels first to shared mem*/
+		runningOffset = sizeof(MV_IPC_LINK);
+		for (chnIdx = 0; chnIdx < link->numOfChannels; chnIdx++) {
+			mvOsMemcpy((MV_VOID *)(link->shmemBaseAddr + runningOffset),
+				   &link->channels[chnIdx], sizeof(MV_IPC_CHANNEL));
+			runningOffset += sizeof(MV_IPC_CHANNEL);
+		}
+
+		/*Set magic value in link structures and copy to shared memory,
+		this is ready state for client */
+		link->masterConfigDone = MV_IPC_MASTER_CONFIG_MAGIC;
+		mvOsMemcpy((MV_VOID *)link->shmemBaseAddr, link, sizeof(MV_IPC_LINK));
+
+		/*Fixup all offsets to shmem to local addresses*/
+		mvIpcChannelsOffsetsFix(link, link->shmemBaseAddr);
+
+		mvIpcDbgPrintf("IPC HAL: Initialized interface as Master\n");
+	} else {
+		/*Slave configuration*/
+
+		/*Read link structure from shared mem*/
+		mvOsMemcpy((MV_VOID *)link, mvIpcGetShmemAddr(linkId), sizeof(MV_IPC_LINK));
+		if (link->masterConfigDone == MV_IPC_MASTER_CONFIG_MAGIC) {
+			/*Master finished the init, Slave get the configuration*/
+			mvIpcSlaveConfig(linkId);
+
+			/*Clear magic*/
+			link->masterConfigDone = 0;
+			mvOsMemcpy((MV_VOID *)link->shmemBaseAddr, link, sizeof(MV_IPC_LINK));
+			link->slaveLinkInitialized = 0;
+
+			mvIpcDbgPrintf("IPC HAL: Initialized interface as Slave\n");
+		} else {
+			/*postpone the Slave init, will be done in mvIpcOpenChannel*/
+			link->slaveLinkInitialized = MV_IPC_MASTER_CONFIG_MAGIC;
+			mvIpcDbgPrintf("IPC HAL: Initialized interface as Slave, config postponed\n");
+		}
+	}
 
 	return MV_OK;
 }
 
 /***********************************************************************************
-* mvIpcClose
-*
-* DESCRIPTION:
-*		Closes all IPC channels
-*
-* INPUT:
-*		None
-* OUTPUT:
-*       None
-* RETURN:
-*		MV_OK or MV_ERROR
-*
-************************************************************************************/
-MV_STATUS mvIpcClose(MV_VOID)
+ * mvIpcClose
+ *
+ * DESCRIPTION:
+ *		Closes all IPC channels
+ *
+ * INPUT:
+ *		linkId  - Link id to be configred
+ * OUTPUT:
+ *       None
+ * RETURN:
+ *		MV_OK or MV_ERROR
+ *
+ ************************************************************************************/
+MV_STATUS mvIpcClose(MV_U32 linkId)
 {
+	MV_IPC_LINK             *link;
 	MV_U32 chnIdx;
 
-	/* De-activate all channels */
-	for(chnIdx = 0; chnIdx < MAX_IPC_CHANNELS; chnIdx++) {
+	/* Verify parameters */
+	if (linkId > MV_IPC_LINKS_NUM) {
+		mvIpcErrPrintf("IPC ERROR: IPC close: Bad link id %d\n", linkId);
+		return MV_FALSE;
+	}
 
-		if(ipcChannels[chnIdx].state == MV_CHN_ATTACHED)
-			mvIpcDettachChannel(chnIdx);
+	link = &mv_ipc_links[linkId];
 
-		if(ipcChannels[chnIdx].state == MV_CHN_OPEN)
-			mvIpcCloseChannel(chnIdx);
+	/* De-activate all channels */
+	for (chnIdx = 0; chnIdx < link->numOfChannels; chnIdx++) {
+		if (link->channels[chnIdx].state == MV_CHN_ATTACHED)
+			mvIpcDettachChannel(linkId, chnIdx);
+
+		if (link->channels[chnIdx].state == MV_CHN_OPEN)
+			mvIpcCloseChannel(linkId, chnIdx);
 	}
 
 	mvIpcDbgPrintf("IPC HAL: CLosed IPC interface\n");
 
 	return MV_OK;
 }
+
 /***********************************************************************************
-* mvIpcOpenChannel
-*
-* DESCRIPTION:
-*		Opens a ipc channel and prepares it for receiving messages
-*
-* INPUT:
-*		chnId - the channel ID to open
-* OUTPUT:
-*       None
-* RETURN:
-*		MV_OK or MV_ERROR
-*
-************************************************************************************/
-MV_STATUS mvIpcOpenChannel(MV_U32 chnId)
+ * mvIpcOpenChannel
+ *
+ * DESCRIPTION:
+ *		Opens a ipc channel and prepares it for receiving messages
+ *
+ * INPUT:
+ *		linkId  - Link id to open
+ *		chnId - the channel ID to open
+ * OUTPUT:
+ *       None
+ * RETURN:
+ *		MV_OK or MV_ERROR
+ *		MV_NOT_STARTED if slave and master still not wake.
+ *
+ ************************************************************************************/
+MV_STATUS mvIpcOpenChannel(MV_U32 linkId, MV_U32 chnId, MV_IPC_RX_CLBK rx_clbk)
 {
-	MV_IPC_CHANNEL *chn;
+	MV_IPC_LINK             *link;
+	MV_IPC_CHANNEL  *chn;
 	MV_U32 msgId;
+	MV_STATUS status;
 
 	/* Verify parameters */
-	if(chnId > MAX_IPC_CHANNELS){
-		mvIpcErrPrintf("IPC ERROR: Open channel: Invalid channel id %d\n", chnId);
-		return MV_ERROR;
+	if (linkId > MV_IPC_LINKS_NUM) {
+		mvIpcErrPrintf("IPC ERROR: Open Chn: Bad link id %d\n", chnId);
+		return MV_FALSE;
 	}
 
-	chn = &ipcChannels[chnId];
+	link = &mv_ipc_links[linkId];
+
+	/*Check if posponed Slave init needed*/
+	if (link->slaveLinkInitialized == MV_IPC_MASTER_CONFIG_MAGIC) {
+		/*Read link structure from shared mem*/
+		mvOsMemcpy((MV_VOID *)link, mvIpcGetShmemAddr(linkId), sizeof(MV_IPC_LINK));
+		if (link->masterConfigDone == MV_IPC_MASTER_CONFIG_MAGIC) {
+			/*Master finished the init, Slave get the configuration*/
+			status = mvIpcSlaveConfig(linkId);
+			mvIpcErrPrintf("IPC MESSG: Open Chn:Postponed init done with status %d\n", status);
+
+			/*Clear magic*/
+			link->masterConfigDone = 0;
+			mvOsMemcpy((MV_VOID *)link->shmemBaseAddr, link, sizeof(MV_IPC_LINK));
+			link->slaveLinkInitialized = 0;
+		} else {
+			/*Master still not wake, cannot open the channel*/
+			mvIpcErrPrintf("IPC WARNG: Open Chn: Master not ready\n");
+			link->slaveLinkInitialized = MV_IPC_MASTER_CONFIG_MAGIC;
+			return MV_NOT_STARTED;
+		}
+	}
 
-	if(chn->state != MV_CHN_CLOSED){
-		mvIpcErrPrintf("IPC ERROR: Can't open channel %d. It is already open\n", chnId);
+	if (chnId > link->numOfChannels) {
+		mvIpcErrPrintf("IPC ERROR: Open Chn: Bad channel id %d\n", chnId);
+		return MV_FALSE;
+	}
+
+	chn = &link->channels[chnId];
+
+	if (chn->state != MV_CHN_CLOSED) {
+		mvIpcErrPrintf("IPC ERROR: Can't open channel %d. It is already open %d\n",
+			       chnId, chn->state);
 		return MV_ERROR;
 	}
 
 	/* Initialize the transmit queue */
-	for(msgId = 0; msgId < chn->queSizeInMsg; msgId++)
+	for (msgId = 0; msgId < chn->queSizeInMsg; msgId++)
 		chn->txMsgQueVa[msgId].isUsed = MV_FALSE;
 
 	/* Initialize channel members */
-	chn->state	  	  = MV_CHN_OPEN;
+	chn->state                = MV_CHN_OPEN;
 	chn->nextRxMsgIdx = 1;
 	chn->nextTxMsgIdx = 1;
 	chn->rxEnable     = MV_TRUE;
+	chn->rxCallback   = rx_clbk;
 
 	mvIpcDbgPrintf("IPC HAL: Opened channel %d successfully\n", chnId);
 
@@ -247,52 +472,69 @@ MV_STATUS mvIpcOpenChannel(MV_U32 chnId)
 }
 
 /***********************************************************************************
-* mvIpcAckAttach
-*
-* DESCRIPTION:
-*		Acknowledges and Attach request from receiver.
-*
-* INPUT:
-*		chnId - the channel ID
-*		cpuId - the CPU ID to attach to
-*		acknowledge - do i need to acknowledge the message
-* OUTPUT:
-*       None
-* RETURN:
-*		MV_OK or MV_ERROR
-*
-************************************************************************************/
-static MV_STATUS mvIpcAckAttach(MV_U32 chnId, MV_U32 cpuId, MV_BOOL acknowledge)
+ * mvIpcAckAttach
+ *
+ * DESCRIPTION:
+ *		Acknowledges and Attach request from receiver.
+ *
+ * INPUT:
+ *		linkId  - the link ID
+ *		chnId - the channel ID
+ *		cpuId - the CPU ID to attach to
+ *		acknowledge - do i need to acknowledge the message
+ * OUTPUT:
+ *       None
+ * RETURN:
+ *		MV_OK or MV_ERROR
+ *
+ ************************************************************************************/
+static MV_STATUS mvIpcAckAttach(MV_U32 linkId, MV_U32 chnId, MV_BOOL acknowledge)
 {
-	MV_IPC_CHANNEL *chn = &ipcChannels[chnId];
+	MV_IPC_LINK             *link;
+	MV_IPC_CHANNEL  *chn;
 	MV_IPC_MSG attachMsg;
 	MV_STATUS status;
 
+	/* Verify parameters */
+	if (linkId > MV_IPC_LINKS_NUM) {
+		mvIpcErrPrintf("IPC ERROR: Ack attach: Bad link id %d\n", chnId);
+		return MV_FALSE;
+	}
+
+	link = &mv_ipc_links[linkId];
+
+	if (chnId > link->numOfChannels) {
+		mvIpcErrPrintf("IPC ERROR:Ack attach: Bad channel id %d\n", chnId);
+		return MV_FALSE;
+	}
+
+	chn = &link->channels[chnId];
+
 	/* Cannot acknowledge remote attach until local attach was requested*/
-	if((chn->state != MV_CHN_ATTACHED) && (chn->state != MV_CHN_LINKING)) {
+	if ((chn->state != MV_CHN_ATTACHED) && (chn->state != MV_CHN_LINKING)) {
 		mvIpcDbgPrintf("IPC HAL: Can't acknowledge attach. channel in state %d\n", chn->state);
 		return MV_ERROR;
 	}
 
-	if(acknowledge == MV_TRUE) {
-
+	if (acknowledge == MV_TRUE) {
 		/* Check that channel is not already coupled to another CPU*/
-		if(chn->remoteCpuId != cpuId) {
-			mvIpcDbgPrintf("IPC HAL: Can't acknowledge attach. CPU %d != %d\n", chn->remoteCpuId, cpuId);
+		if (chn->remoteNodeId != link->remoteNodeId) {
+			mvIpcDbgPrintf("IPC HAL: Can't acknowledge attach. CPU %d != %d\n",
+				       chn->remoteNodeId, link->remoteNodeId);
 			return MV_ERROR;
 		}
 
-		mvIpcDbgPrintf("IPC HAL: Acknowledging attach from CPU %d\n", cpuId);
+		mvIpcDbgPrintf("IPC HAL: Acknowledging attach from CPU %d\n", link->remoteNodeId);
 
 		/* Send the attach acknowledge message */
 		attachMsg.type  = IPC_MSG_ATTACH_ACK;
-		attachMsg.value = myCpuId;
+		attachMsg.value = link->remoteNodeId;
 		attachMsg.size  = 0;
 		attachMsg.ptr   = 0;
-		status = mvIpcTxCtrlMsg(chnId, &attachMsg);
-		if(status != MV_OK) {
-				mvIpcErrPrintf("IPC ERROR: Cannot Send attach acknowledge message\n");
-				return MV_ERROR;
+		status = mvIpcTxCtrlMsg(linkId, chnId, &attachMsg);
+		if (status != MV_OK) {
+			mvIpcErrPrintf("IPC ERROR: Cannot Send attach acknowledge message\n");
+			return MV_ERROR;
 		}
 	}
 
@@ -303,56 +545,73 @@ static MV_STATUS mvIpcAckAttach(MV_U32 chnId, MV_U32 cpuId, MV_BOOL acknowledge)
 }
 
 /***********************************************************************************
-* mvIpcAckDetach
-*
-* DESCRIPTION:
-*		Acknowledges detach request from receiver. this closes the channel for
-*		transmission and resets the queues
-*
-* INPUT:
-*		chnId - the channel ID
-*		acknowledge - do i need to acknowledge the message
-* OUTPUT:
-*       None
-* RETURN:
-*		MV_OK or MV_ERROR
-*
-************************************************************************************/
-static MV_STATUS mvIpcAckDetach(MV_U32 chnId, MV_BOOL acknowledge)
+ * mvIpcAckDetach
+ *
+ * DESCRIPTION:
+ *		Acknowledges detach request from receiver. this closes the channel for
+ *		transmission and resets the queues
+ *
+ * INPUT:
+ *		linkId  - the link ID
+ *		chnId - the channel ID
+ *		acknowledge - do i need to acknowledge the message
+ * OUTPUT:
+ *       None
+ * RETURN:
+ *		MV_OK or MV_ERROR
+ *
+ ************************************************************************************/
+static MV_STATUS mvIpcAckDetach(MV_U32 linkId, MV_U32 chnId, MV_BOOL acknowledge)
 {
-	MV_IPC_CHANNEL *chn = &ipcChannels[chnId];
+	MV_IPC_LINK             *link;
+	MV_IPC_CHANNEL *chn;
 	MV_IPC_MSG dettachMsg;
 	MV_STATUS status;
 	MV_U32 msgId;
 
+	/* Verify parameters */
+	if (linkId > MV_IPC_LINKS_NUM) {
+		mvIpcErrPrintf("IPC ERROR: Ack detach: Bad link id %d\n", chnId);
+		return MV_FALSE;
+	}
+
+	link = &mv_ipc_links[linkId];
+
+	if (chnId > link->numOfChannels) {
+		mvIpcErrPrintf("IPC ERROR:Ack detach: Bad channel id %d\n", chnId);
+		return MV_FALSE;
+	}
+
+	chn = &link->channels[chnId];
+
 	/* Cannot acknowledge remote detach until local attach was requested*/
-	if((chn->state != MV_CHN_ATTACHED) && (chn->state != MV_CHN_UNLINKING)) {
+	if ((chn->state != MV_CHN_ATTACHED) && (chn->state != MV_CHN_UNLINKING)) {
 		mvIpcDbgPrintf("IPC HAL: Can't acknowledge detach. channel in state %d\n", chn->state);
 		return MV_ERROR;
 	}
 
-	if(acknowledge == MV_TRUE) {
+	if (acknowledge == MV_TRUE) {
 		/* Send the attach acknowledge message */
 		dettachMsg.type  = IPC_MSG_DETACH_ACK;
 		dettachMsg.size  = 0;
 		dettachMsg.ptr   = 0;
 		dettachMsg.value = 0;
 
-		status = mvIpcTxCtrlMsg(chnId, &dettachMsg);
-		if(status != MV_OK) {
-				mvIpcErrPrintf("IPC ERROR: Cannot Send dettach acknowledge message\n");
-				return MV_ERROR;
+		status = mvIpcTxCtrlMsg(linkId, chnId, &dettachMsg);
+		if (status != MV_OK) {
+			mvIpcErrPrintf("IPC ERROR: Cannot Send dettach acknowledge message\n");
+			return MV_ERROR;
 		}
 	}
 
 	/* Now change my own state to attached */
-	chn->state 		  = MV_CHN_OPEN;
+	chn->state                = MV_CHN_OPEN;
 	chn->txEnable     = MV_FALSE;
 	chn->nextRxMsgIdx = 1;
 	chn->nextTxMsgIdx = 1;
 
 	/* Initialize the transmit queue */
-	for(msgId = 1; msgId < chn->queSizeInMsg; msgId++)
+	for (msgId = 1; msgId < chn->queSizeInMsg; msgId++)
 		chn->txMsgQueVa[msgId].isUsed = MV_FALSE;
 
 	return MV_OK;
@@ -361,36 +620,36 @@ static MV_STATUS mvIpcAckDetach(MV_U32 chnId, MV_BOOL acknowledge)
 }
 
 /***********************************************************************************
-* mvIpcReqAttach
-*
-* DESCRIPTION:
-*		Ask receiver to acknowledge attach request. To verify reception, message
-*		transmission is possible only after receiver acknowledges the attach
-*
-* INPUT:
-*		chn   - pointer to channel structure
-*		chnId - the channel ID
-* OUTPUT:
-*       None
-* RETURN:
-*		MV_OK or MV_ERROR
-*
-************************************************************************************/
-static MV_STATUS mvIpcReqAttach(MV_IPC_CHANNEL *chn, MV_U32 chnId)
+ * mvIpcReqAttach
+ *
+ * DESCRIPTION:
+ *		Ask receiver to acknowledge attach request. To verify reception, message
+ *		transmission is possible only after receiver acknowledges the attach
+ *
+ * INPUT:
+ *		chn   - pointer to channel structure
+ *		chnId - the channel ID
+ * OUTPUT:
+ *       None
+ * RETURN:
+ *		MV_OK or MV_ERROR
+ *
+ ************************************************************************************/
+static MV_STATUS mvIpcReqAttach(MV_U32 linkId, MV_IPC_CHANNEL *chn, MV_U32 chnId)
 {
 	MV_IPC_MSG attachMsg;
 	MV_STATUS status;
 	int backoff = 10, timeout = 10;
 
-	mvIpcDbgPrintf("IPC HAL: Requesting attach from cpu %d\n", chn->remoteCpuId);
+	mvIpcDbgPrintf("IPC HAL: Requesting attach from cpu %d\n", chn->remoteNodeId);
 
 	/* Send the attach message */
 	attachMsg.type  = IPC_MSG_ATTACH_REQ;
-	attachMsg.value = myCpuId;
-	status = mvIpcTxCtrlMsg(chnId, &attachMsg);
-	if(status != MV_OK) {
-			mvIpcErrPrintf("IPC ERROR: Cannot Send attach req message\n");
-			return MV_ERROR;
+	attachMsg.value = mvIpcWhoAmI();
+	status = mvIpcTxCtrlMsg(linkId, chnId, &attachMsg);
+	if (status != MV_OK) {
+		mvIpcErrPrintf("IPC ERROR: Cannot Send attach req message\n");
+		return MV_ERROR;
 	}
 
 	/* Give the receiver 10 seconds to reply */
@@ -399,9 +658,9 @@ static MV_STATUS mvIpcReqAttach(MV_IPC_CHANNEL *chn, MV_U32 chnId)
 		timeout--;
 	}
 
-	if(chn->state != MV_CHN_ATTACHED) {
+	if (chn->state != MV_CHN_ATTACHED) {
 		mvIpcDbgPrintf("IPC HAL: Cannot complete attach sequence. no reply from receiver after %d usec\n",
-				  timeout * backoff);
+			       timeout * backoff);
 		return MV_ERROR;
 	}
 
@@ -409,101 +668,117 @@ static MV_STATUS mvIpcReqAttach(MV_IPC_CHANNEL *chn, MV_U32 chnId)
 
 	return MV_OK;
 }
+
 /***********************************************************************************
-* mvIpcAttachChannel
-*
-* DESCRIPTION:
-*		Attempts to attach the TX queue to a remote CPU by sending a ATTACH ACK
-*		messages to receiver. if the message is acknowledged the the channel state
-*		becomes attached and message transmission is enabled.
-*
-* INPUT:
-*		chnId 		- The channel ID
-*		remoteCpuId - CPU ID of receiver
-* OUTPUT:
-*		attached   - indicates if channel is attached
-* RETURN:
-*		MV_OK or MV_ERROR
-*
-************************************************************************************/
-MV_STATUS mvIpcAttachChannel(MV_U32 chnId, MV_U32 remoteCpuId, MV_BOOL *attached)
+ * mvIpcAttachChannel
+ *
+ * DESCRIPTION:
+ *		Attempts to attach the TX queue to a remote CPU by sending a ATTACH ACK
+ *		messages to receiver. if the message is acknowledged the the channel state
+ *		becomes attached and message transmission is enabled.
+ *
+ * INPUT:
+ *		linkId  - the link ID
+ *		chnId           - The channel ID
+ *		remoteNodeId - CPU ID of receiver
+ * OUTPUT:
+ *		attached   - indicates if channel is attached
+ * RETURN:
+ *		MV_OK or MV_ERROR
+ *
+ ************************************************************************************/
+MV_STATUS mvIpcAttachChannel(MV_U32 linkId, MV_U32 chnId, MV_U32 remoteNodeId, MV_BOOL *attached)
 {
+	MV_IPC_LINK             *link;
 	MV_IPC_CHANNEL *chn;
 	MV_U32 msgId;
 	MV_STATUS status;
 
 	(*attached) = 0;
 
-	if(chnId > MAX_IPC_CHANNELS){
-		mvIpcErrPrintf("IPC ERROR: Attach channel: Invalid channel id %d\n", chnId);
-		return MV_ERROR;
+	/* Verify parameters */
+	if (linkId > MV_IPC_LINKS_NUM) {
+		mvIpcErrPrintf("IPC ERROR: Chn attach: Bad link id %d\n", chnId);
+		return MV_FALSE;
 	}
 
-	if(remoteCpuId > (NR_CPUS- 1)){
-			mvIpcErrPrintf("IPC ERROR: Attach channel: Invalid target cpu id %d\n", remoteCpuId);
-			return MV_ERROR;
+	link = &mv_ipc_links[linkId];
+
+	if (chnId > link->numOfChannels) {
+		mvIpcErrPrintf("IPC ERROR: Chn attach: Bad channel id %d\n", chnId);
+		return MV_FALSE;
 	}
 
-	chn = &ipcChannels[chnId];
+	chn = &link->channels[chnId];
 
-	if(chn->state == MV_CHN_CLOSED){
+	if (chn->state == MV_CHN_CLOSED) {
 		mvIpcErrPrintf("IPC ERROR: Can't attach channel %d. It is closed\n", chnId);
 		return MV_ERROR;
 	}
 
-	if(chn->state == MV_CHN_ATTACHED){
+	if (chn->state == MV_CHN_ATTACHED) {
 		(*attached) = 1;
 		return MV_OK;
 	}
 
-	chn->state 		  = MV_CHN_LINKING;
-	chn->remoteCpuId  = remoteCpuId;
-	chn->txEnable	  = MV_TRUE;
+	chn->state                = MV_CHN_LINKING;
+	chn->remoteNodeId  = remoteNodeId;
+	chn->txEnable     = MV_TRUE;
 
 	/* Initialize the transmit queue */
-	for(msgId = 1; msgId < chn->queSizeInMsg; msgId++)
+	for (msgId = 1; msgId < chn->queSizeInMsg; msgId++)
 		chn->txMsgQueVa[msgId].isUsed = MV_FALSE;
 
 	/* Send req for attach to other side */
-	status = mvIpcReqAttach(chn, chnId);
-	if(status == MV_OK) {
+	status = mvIpcReqAttach(linkId, chn, chnId);
+	if (status == MV_OK) {
 		(*attached) = 1;
-		mvIpcDbgPrintf("IPC HAL: Attached channel %d to CPU %d\n", chnId, remoteCpuId);
+		mvIpcDbgPrintf("IPC HAL: Attached channel %d to link %d\n", chnId, linkId);
 	}
 
 	return MV_OK;
 }
 
 /***********************************************************************************
-* mvIpcDettachChannel
-*
-* DESCRIPTION:
-*		Detaches the channel from remote cpu. it notifies the remote cpu by sending
-*		control message and waits for acknowledge. after calling this function
-*		data messages cannot be sent anymore
-*
-* INPUT:
-*		chnId 		- The channel ID
-* OUTPUT:
-*       None
-* RETURN:
-*		MV_OK or MV_ERROR
-*
-************************************************************************************/
-MV_STATUS mvIpcDettachChannel(MV_U32 chnId)
+ * mvIpcDettachChannel
+ *
+ * DESCRIPTION:
+ *		Detaches the channel from remote cpu. it notifies the remote cpu by sending
+ *		control message and waits for acknowledge. after calling this function
+ *		data messages cannot be sent anymore
+ *
+ * INPUT:
+ *		linkId  - the link ID
+ *		chnId           - The channel ID
+ * OUTPUT:
+ *       None
+ * RETURN:
+ *		MV_OK or MV_ERROR
+ *
+ ************************************************************************************/
+MV_STATUS mvIpcDettachChannel(MV_U32 linkId, MV_U32 chnId)
 {
+	MV_IPC_LINK             *link;
 	MV_IPC_CHANNEL *chn;
 	MV_IPC_MSG msg;
 	MV_STATUS status;
 
-	if(chnId > MAX_IPC_CHANNELS){
-		mvIpcErrPrintf("IPC ERROR: Detach channel: Invalid channel id %d\n", chnId);
-		return MV_ERROR;
+	/* Verify parameters */
+	if (linkId > MV_IPC_LINKS_NUM) {
+		mvIpcErrPrintf("IPC ERROR: Chn detach: Bad link id %d\n", chnId);
+		return MV_FALSE;
+	}
+
+	link = &mv_ipc_links[linkId];
+
+	if (chnId > link->numOfChannels) {
+		mvIpcErrPrintf("IPC ERROR: Chn detach: Bad channel id %d\n", chnId);
+		return MV_FALSE;
 	}
 
-	chn = &ipcChannels[chnId];
+	chn = &link->channels[chnId];
 
-	if(chn->state != MV_CHN_ATTACHED){
+	if (chn->state != MV_CHN_ATTACHED) {
 		mvIpcErrPrintf("IPC ERROR: Detach: channel %d is not attached\n", chnId);
 		return MV_ERROR;
 	}
@@ -513,47 +788,62 @@ MV_STATUS mvIpcDettachChannel(MV_U32 chnId)
 	msg.ptr   = 0;
 	msg.value = 0;
 
-	status = mvIpcTxCtrlMsg(chnId, &msg);
-	if(status != MV_OK) {
-			mvIpcErrPrintf("IPC ERROR: Cannot Send detach request message\n");
-			return MV_ERROR;
+	status = mvIpcTxCtrlMsg(linkId, chnId, &msg);
+	if (status != MV_OK) {
+		mvIpcErrPrintf("IPC ERROR: Cannot Send detach request message\n");
+		return MV_ERROR;
 	}
 
-	chn->remoteCpuId  = 0;
+	chn->remoteNodeId  = 0;
 	chn->state        = MV_CHN_UNLINKING;
 
 	return MV_OK;
 }
 
 /***********************************************************************************
-* mvIpcCloseChannel - CLose and IPC channel
-*
-* DESCRIPTION:
-*		Closes the 	IPC channels. this disables the channels ability to receive messages
-*
-* INPUT:
-*		chnId 		- The channel ID
-* OUTPUT:
-*       None
-* RETURN:
-*		MV_OK or MV_ERROR
-*
-************************************************************************************/
-MV_STATUS mvIpcCloseChannel(MV_U32 chnId)
+ * mvIpcCloseChannel - CLose and IPC channel
+ *
+ * DESCRIPTION:
+ *		Closes the      IPC channels. this disables the channels ability to receive messages
+ *
+ * INPUT:
+ *		linkId          - the link ID
+ *		chnId           - The channel ID
+ * OUTPUT:
+ *       None
+ * RETURN:
+ *		MV_OK or MV_ERROR
+ *
+ ************************************************************************************/
+MV_STATUS mvIpcCloseChannel(MV_U32 linkId, MV_U32 chnId)
 {
-	if(chnId > MAX_IPC_CHANNELS){
-		mvIpcErrPrintf("IPC ERROR: Close channel: Invalid channel id %d\n", chnId);
-		return MV_ERROR;
+	MV_IPC_LINK             *link;
+	MV_IPC_CHANNEL *chn;
+
+	/* Verify parameters */
+	if (linkId > MV_IPC_LINKS_NUM) {
+		mvIpcErrPrintf("IPC ERROR: Chn close: Bad link id %d\n", chnId);
+		return MV_FALSE;
 	}
-	if(ipcChannels[chnId].state == MV_CHN_CLOSED){
+
+	link = &mv_ipc_links[linkId];
+
+	if (chnId > link->numOfChannels) {
+		mvIpcErrPrintf("IPC ERROR: Chn close: Bad channel id %d\n", chnId);
+		return MV_FALSE;
+	}
+
+	chn = &link->channels[chnId];
+
+	if (chn->state == MV_CHN_CLOSED) {
 		mvIpcErrPrintf("IPC ERROR: Close channel: Channel %d is already closed\n", chnId);
 		return MV_ERROR;
 	}
 
-	ipcChannels[chnId].state       = MV_CHN_CLOSED;
-	ipcChannels[chnId].txEnable    = MV_FALSE;
-	ipcChannels[chnId].rxEnable    = MV_FALSE;
-	ipcChannels[chnId].remoteCpuId = 0;
+	chn->state       = MV_CHN_CLOSED;
+	chn->txEnable    = MV_FALSE;
+	chn->rxEnable    = MV_FALSE;
+	chn->remoteNodeId = 0;
 
 	mvIpcDbgPrintf("IPC HAL: Closed channel %d successfully\n", chnId);
 
@@ -561,96 +851,91 @@ MV_STATUS mvIpcCloseChannel(MV_U32 chnId)
 }
 
 /***********************************************************************************
-* mvIpcIsTxReady
-*
-* DESCRIPTION:
-*		Checks if the channel is ready to transmit
-*
-* INPUT:
-*		chnId 		- The channel ID
-* OUTPUT:
-*       None
-* RETURN:
-*		MV_OK or MV_ERROR
-*
-************************************************************************************/
-MV_BOOL mvIpcIsTxReady(MV_U32 chnId)
+ * mvIpcIsTxReady
+ *
+ * DESCRIPTION:
+ *		Checks if the channel is ready to transmit
+ *
+ * INPUT:
+ *		chnId           - The channel ID
+ * OUTPUT:
+ *       None
+ * RETURN:
+ *		MV_OK or MV_ERROR
+ *
+ ************************************************************************************/
+MV_BOOL mvIpcIsTxReady(MV_U32 linkId, MV_U32 chnId)
 {
+	MV_IPC_LINK             *link;
 	MV_IPC_CHANNEL *chn;
 
-	/* Some parameters verification */
-	if(chnId > MAX_IPC_CHANNELS){
-		mvIpcErrPrintf("IPC ERROR: Tx Test: Invalid channel id %d\n", chnId);
+	/* Verify parameters */
+	if (linkId > MV_IPC_LINKS_NUM) {
+		mvIpcErrPrintf("IPC ERROR: Chn is ready: Bad link id %d\n", chnId);
 		return MV_FALSE;
 	}
-	if(ipcChannels[chnId].state != MV_CHN_ATTACHED){
-		mvIpcErrPrintf("IPC ERROR: Tx Test: channel not attached, state is %d\n", ipcChannels[chnId].state);
+
+	link = &mv_ipc_links[linkId];
+
+	if (chnId > link->numOfChannels) {
+		mvIpcErrPrintf("IPC ERROR: Chn is ready: Bad channel id %d\n", chnId);
 		return MV_FALSE;
 	}
 
-	chn = &ipcChannels[chnId];
+	chn = &link->channels[chnId];
+
+	if (chn->state != MV_CHN_ATTACHED) {
+		mvIpcErrPrintf("IPC ERROR: Tx Test: channel not attached, state is %d\n", chn->state);
+		return MV_FALSE;
+	}
 
 	/* Is next message still used by receiver, yes means full queue or bug */
-	if(chn->txMsgQueVa[chn->nextTxMsgIdx].isUsed != MV_FALSE) {
-		mvIpcDbgPrintf("IPC HAL: Tx Test: Can't send, Msg %d used flag = %d\n", chn->nextTxMsgIdx, chn->txMsgQueVa[chn->nextTxMsgIdx].isUsed);
+	if (chn->txMsgQueVa[chn->nextTxMsgIdx].isUsed != MV_FALSE) {
+		mvIpcDbgPrintf("IPC HAL: Tx Test: Can't send, Msg %d used flag = %d\n",
+			       chn->nextTxMsgIdx, chn->txMsgQueVa[chn->nextTxMsgIdx].isUsed);
 		return MV_FALSE;
 	}
 
 	return MV_TRUE;
 }
+
 /***********************************************************************************
-* mvIpcSendDoorbell
-*
-* DESCRIPTION:
-* 		Send an IPC doorbell to target CPU
-*
-* INPUT:
-*		cpuId - the id of the target CPU
-*		chnId - The channel ID
-* OUTPUT:
-*       None
-* RETURN:
-*		MV_OK or MV_ERROR
-*
-************************************************************************************/
-static INLINE MV_VOID mvIpcSendDoorbell(MV_U32 cpuId, MV_U32 chnId)
+ * mvIpcTxCtrlMsg
+ *
+ * DESCRIPTION:
+ *		Sends a control message to other side. these messages are not forwarded
+ *		to user
+ *
+ * INPUT:
+ *		linkId  - the link ID
+ *		chnId - The channel ID
+ *		inMsg - Pointer to message to send
+ * OUTPUT:
+ *       None
+ * RETURN:
+ *		MV_OK or MV_ERROR
+ *
+ ************************************************************************************/
+MV_STATUS mvIpcTxCtrlMsg(MV_U32 linkId, MV_U32 chnId, MV_IPC_MSG *inMsg)
 {
-	MV_U32 cpuBitMask;
-	MV_U32 doorbellNum;
-
-	cpuBitMask   = (1 << cpuId);
-	doorbellNum  = IPC_BASE_DOORBELL + chnId;
+	MV_IPC_LINK             *link;
+	MV_IPC_CHANNEL *chn;
 
-	/* Use private doorbell 15 for IPC */
-	MV_REG_WRITE(CPU_SW_TRIG_IRQ, ((cpuBitMask << 8) | doorbellNum));
+	if (linkId > MV_IPC_LINKS_NUM) {
+		mvIpcErrPrintf("IPC ERROR: Tx Ctrl Msg: Bad link id %d\n", chnId);
+		return MV_FALSE;
+	}
 
-	return;
-}
+	link = &mv_ipc_links[linkId];
 
-/***********************************************************************************
-* mvIpcTxCtrlMsg
-*
-* DESCRIPTION:
-*		Sends a control message to other side. these messages are not forwarded
-*		to user
-*
-* INPUT:
-*		chnId - The channel ID
-*		inMsg - Pointer to message to send
-* OUTPUT:
-*       None
-* RETURN:
-*		MV_OK or MV_ERROR
-*
-************************************************************************************/
-MV_STATUS mvIpcTxCtrlMsg(MV_U32 chnId, MV_IPC_MSG *inMsg)
-{
-	MV_IPC_CHANNEL *chn;
+	if (chnId > link->numOfChannels) {
+		mvIpcErrPrintf("IPC ERROR: Tx Ctr Msg: Bad channel id %d\n", chnId);
+		return MV_FALSE;
+	}
 
-	chn = &ipcChannels[chnId];
+	chn = &link->channels[chnId];
 
-	if(chn->txEnable == MV_FALSE)
-	{
+	if (chn->txEnable == MV_FALSE) {
 		mvIpcErrPrintf("IPC ERROR: Tx Ctrl msg: Tx not enabled\n");
 		return MV_ERROR;
 	}
@@ -665,47 +950,72 @@ MV_STATUS mvIpcTxCtrlMsg(MV_U32 chnId, MV_IPC_MSG *inMsg)
 	 * to ensure the polling receiver will get valid message once
 	 * it detects isUsed == MV_TRUE.
 	 */
-	dmb();
+	mvOsSync();
 
 	chn->txCtrlMsg->isUsed   = MV_TRUE;
 
-	mvIpcDbgWrite(chn->txCtrlMsg->align[0], axp_read_soc_clock(0));
+	mvIpcDbgWrite(chn->txCtrlMsg->align[0], MV_IPC_HAND_SHAKE_MAGIC);
 	mvIpcDbgWrite(chn->txCtrlMsg->align[1], 0);
 	mvIpcDbgWrite(chn->txCtrlMsg->align[2], 0);
 
-	mvIpcDbgPrintf("IPC HAL: Sent control message 0x%8x on channel %d to cpu %d\n", chn->txCtrlMsg, chnId, chn->remoteCpuId);
+	mvIpcDbgPrintf("IPC HAL: Sent control message 0x%8x on channel %d to link %d\n",
+			(int)chn->txCtrlMsg, chnId, linkId);
 
-	mvIpcSendDoorbell(chn->remoteCpuId, chnId);
+	/*Raise the TX ready flag and send the trigger*/
+	*((MV_U32 *)chn->txMessageFlag) = 0x1;
+	chn->sendTrigger(chn->remoteNodeId, chnId);
 
 	return MV_OK;
 }
 
 /***********************************************************************************
-* mvIpcTxMsg
-*
-* DESCRIPTION:
-*		Main transmit function
-*
-* INPUT:
-*		chnId - The channel ID
-*		inMsg - Pointer to message to send
-* OUTPUT:
-*       None
-* RETURN:
-*		MV_OK or MV_ERROR
-*
-************************************************************************************/
-MV_STATUS mvIpcTxMsg(MV_U32 chnId, MV_IPC_MSG *inMsg)
+ * mvIpcTxMsg
+ *
+ * DESCRIPTION:
+ *		Main transmit function
+ *
+ * INPUT:
+ *		linkId  - the link ID
+ *		chnId - The channel ID
+ *		inMsg - Pointer to message to send
+ * OUTPUT:
+ *       None
+ * RETURN:
+ *		MV_OK or MV_ERROR
+ *
+ ************************************************************************************/
+MV_STATUS mvIpcTxMsg(MV_U32 linkId, MV_U32 chnId, MV_IPC_MSG *inMsg)
 {
+	MV_IPC_LINK             *link;
 	MV_IPC_CHANNEL *chn;
 	MV_IPC_MSG     *currMsg;
 
-	if(mvIpcIsTxReady(chnId) == MV_FALSE){
-		mvIpcDbgPrintf("IPC ERROR: Tx msg: Tx Queue not ready. Can't transmit at this time \n");
-		return MV_ERROR;
+	if (linkId > MV_IPC_LINKS_NUM) {
+		mvIpcErrPrintf("IPC ERROR: Tx Msg: Bad link id %d\n", chnId);
+		return MV_FALSE;
 	}
 
-	chn = &ipcChannels[chnId];
+	link = &mv_ipc_links[linkId];
+
+	if (chnId > link->numOfChannels) {
+		mvIpcErrPrintf("IPC ERROR: Tx Msg: Bad channel id %d\n", chnId);
+		return MV_FALSE;
+	}
+
+	chn = &link->channels[chnId];
+
+	/*Test if TX ready to send*/
+	if (chn->state != MV_CHN_ATTACHED) {
+		mvIpcErrPrintf("IPC ERROR: Tx Msg: channel not attached, state is %d\n", chn->state);
+		return MV_FALSE;
+	}
+
+	/* Is next message still used by receiver, yes means full queue or bug */
+	if (chn->txMsgQueVa[chn->nextTxMsgIdx].isUsed != MV_FALSE) {
+		mvIpcDbgPrintf("IPC HAL: Tx Msg: Can't send, Msg %d used flag = %d\n",
+			chn->nextTxMsgIdx, chn->txMsgQueVa[chn->nextTxMsgIdx].isUsed);
+		return MV_FALSE;
+	}
 
 	/* Write the message */
 	currMsg  = &chn->txMsgQueVa[chn->nextTxMsgIdx];
@@ -719,260 +1029,367 @@ MV_STATUS mvIpcTxMsg(MV_U32 chnId, MV_IPC_MSG *inMsg)
 	 * to ensure the polling receiver will get valid message once
 	 * it detects isUsed == MV_TRUE.
 	 */
-	dmb();
+	mvOsSync();
 
 	/* Pass ownership to remote cpu */
 	currMsg->isUsed   = MV_TRUE;
 
-	mvIpcDbgWrite(currMsg->align[0], axp_read_soc_clock(0));
+	mvIpcDbgWrite(currMsg->align[0], MV_IPC_HAND_SHAKE_MAGIC);
 	mvIpcDbgWrite(currMsg->align[1], 0);
 	mvIpcDbgWrite(currMsg->align[2], 0);
 
 	chn->nextTxMsgIdx++;
-	if(chn->nextTxMsgIdx == chn->queSizeInMsg)
+	if (chn->nextTxMsgIdx == chn->queSizeInMsg)
 		chn->nextTxMsgIdx = 1;
 
-	mvIpcDbgPrintf("IPC HAL: Sent message %d on channel %d to cpu %d\n", chn->nextTxMsgIdx - 1, chnId, chn->remoteCpuId);
+	mvIpcDbgPrintf("IPC HAL: Sent message %d on channel %d to link %d\n",
+			chn->nextTxMsgIdx - 1, chnId, linkId);
 
-	mvIpcSendDoorbell(chn->remoteCpuId, chnId);
+	/*Raise the TX ready flag and send the trigger*/
+	*((MV_U32 *)chn->txMessageFlag) = 0x1;
+	chn->sendTrigger(chn->remoteNodeId, chnId);
 
 	return MV_OK;
 }
 
 /***********************************************************************************
-* mvIpcRecieveDoorbell
-*
-* DESCRIPTION:
-*		Translates a received doorbell to the matching channel
-*
-* INPUT:
-*		chnId   - The channel ID
-*		drblNum - Number of doorbell received
-* OUTPUT:
-*       None
-* RETURN:
-*		MV_OK or MV_ERROR
-*
-************************************************************************************/
-static MV_STATUS mvIpcRecieveDoorbell(int *chnId, MV_U32 drblNum)
+ * mvIpcRxCtrlMsg
+ *
+ * DESCRIPTION:
+ *		This routine initializes IPC channel: setup receive queue and enable data receiving
+ *		This routine receives IPC control structure (ipcCtrl) as input parameter.
+ *		The following ipcCtrl members must be initialized prior calling this function:
+ *
+ * INPUT:
+ *		linkId  - the link ID
+ *		chnId - The channel ID
+ *		msg   - Pointer to received control message
+ * OUTPUT:
+ *       None
+ * RETURN:
+ *		void
+ *
+ ************************************************************************************/
+static void mvIpcRxCtrlMsg(MV_U32 linkId, MV_U32 chnId, MV_IPC_MSG *msg)
 {
-	(*chnId) = (drblNum) - IPC_BASE_DOORBELL;
-	return MV_OK;
-}
-
-/***********************************************************************************
-* mvIpcRxCtrlMsg
-*
-* DESCRIPTION:
-*		This routine initializes IPC channel: setup receive queue and enable data receiving
-*		This routine receives IPC control structure (ipcCtrl) as input parameter.
-*		The following ipcCtrl members must be initialized prior calling this function:
-*
-* INPUT:
-*		chnId - The channel ID
-*		msg   - Pointer to received control message
-* OUTPUT:
-*       None
-* RETURN:
-*		void
-*
-************************************************************************************/
-static void mvIpcRxCtrlMsg(MV_U32 chnId, MV_IPC_MSG *msg)
-{
-	mvIpcDbgPrintf("IPC HAL: Processing control message %d \n", msg->type);
-
-	switch(msg->type) {
+	mvIpcDbgPrintf("IPC HAL: Processing control message %d\n", msg->type);
 
+	switch (msg->type) {
 	case IPC_MSG_ATTACH_REQ:
-		mvIpcAckAttach(chnId, msg->value, MV_TRUE);
+		mvIpcAckAttach(linkId, chnId, MV_TRUE);
 		break;
 
 	case IPC_MSG_ATTACH_ACK:
-		mvIpcAckAttach(chnId, msg->value, MV_FALSE);
+		mvIpcAckAttach(linkId, chnId, MV_FALSE);
 		break;
 
 	case IPC_MSG_DETACH_REQ:
-		mvIpcAckDetach(chnId, MV_TRUE);
+		mvIpcAckDetach(linkId, chnId, MV_TRUE);
 		break;
 
 	case IPC_MSG_DETACH_ACK:
-		mvIpcAckDetach(chnId, MV_FALSE);
+		mvIpcAckDetach(linkId, chnId, MV_FALSE);
 		break;
 
 	default:
-		mvIpcDbgPrintf("IPC HAL: Unknown internal message type %d \n", msg->type);
+		mvIpcDbgPrintf("IPC HAL: Unknown internal message type %d\n", msg->type);
 	}
 
-	mvIpcDbgWrite(msg->align[2], axp_read_soc_clock(0));
+	mvIpcDbgWrite(msg->align[2], MV_IPC_HAND_SHAKE_MAGIC);
 
-	mvIpcReleaseMsg(chnId, msg);
-}
-/***********************************************************************************
-* isCtrlMsg
-*
-* DESCRIPTION:
-*		Checks for control message
-*
-* INPUT:
-*		chn - pointer to control channel
-* OUTPUT:
-*       None
-* RETURN:
-*		MV_TRUE or MV_FALSE
-*
-************************************************************************************/
-static MV_BOOL isCtrlMsg(MV_IPC_CHANNEL *chn)
-{
-	if(chn->rxCtrlMsg->isUsed == MV_TRUE)
-		return MV_TRUE;
-	else
-		return MV_FALSE;
+	mvIpcReleaseMsg(linkId, chnId, msg);
 }
 
 /***********************************************************************************
-* mvIpcDisableChnRx
-*
-* DESCRIPTION:
-*		Masks the doorbell for the given channel
-*
-* INPUT:
-*		irq - number of irq/doorbell to mask
-* OUTPUT:
-*       None
-* RETURN:
-*		MV_OK or MV_ERROR
-*
-************************************************************************************/
-MV_VOID mvIpcDisableChnRx(MV_U32 irq)
+ * mvIpcDisableChnRx
+ *
+ * DESCRIPTION:
+ *		Masks the given channel in ISR
+ *
+ * INPUT:
+ *		linkId  - the link ID
+ *		chnId - The channel ID
+ * OUTPUT:
+ *       None
+ * RETURN:
+ *		MV_OK or MV_ERROR
+ *
+ ************************************************************************************/
+MV_VOID mvIpcDisableChnRx(MV_U32 linkId, MV_U32 chnId)
 {
-	/* Reset the doorbell corresponding to channel */
-	MV_REG_BIT_RESET(CPU_DOORBELL_IN_MASK_REG, (1 << irq));
+	MV_IPC_LINK             *link;
+	MV_IPC_CHANNEL *chn;
+
+	if (linkId > MV_IPC_LINKS_NUM) {
+		mvIpcErrPrintf("IPC ERROR:  Dis Chn RX: Bad link id %d\n", chnId);
+		return;
+	}
+
+	link = &mv_ipc_links[linkId];
+
+	if (chnId > link->numOfChannels) {
+		mvIpcErrPrintf("IPC ERROR: Dis Chn RX: Bad channel id %d\n", chnId);
+		return;
+	}
+
+	chn = &link->channels[chnId];
+
+	chn->registerChnInISR(linkId, chnId, MV_FALSE);
+
+	mvIpcDbgPrintf("IPC HAL: Disabled ISR for link %d, channel %d\n", linkId, chnId);
+	return;
 }
 
 /***********************************************************************************
-* mvIpcEnableChnRx
-*
-* DESCRIPTION:
-*		Unmasks the doorbell for the given channel
-*
-* INPUT:
-*		irq - number of irq/doorbell to unmask
-* OUTPUT:
-*       None
-* RETURN:
-*		MV_OK or MV_ERROR
-*
-************************************************************************************/
-MV_VOID mvIpcEnableChnRx(MV_U32 irq)
+ * mvIpcEnableChnRx
+ *
+ * DESCRIPTION:
+ *		Unmasks the given channel in ISR
+ *
+ * INPUT:
+ *		linkId  - the link ID
+ *		chnId - The channel ID
+ * OUTPUT:
+ *       None
+ * RETURN:
+ *		MV_OK or MV_ERROR
+ *
+ ************************************************************************************/
+MV_VOID mvIpcEnableChnRx(MV_U32 linkId, MV_U32 chnId)
 {
-	/* Set the doorbell corresponding to channel */
-	MV_REG_BIT_SET(CPU_DOORBELL_IN_MASK_REG, (1 << irq));
+	MV_IPC_LINK             *link;
+	MV_IPC_CHANNEL *chn;
+
+	if (linkId > MV_IPC_LINKS_NUM) {
+		mvIpcErrPrintf("IPC ERROR:  Ena Chn RX: Bad link id %d\n", chnId);
+		return;
+	}
+
+	link = &mv_ipc_links[linkId];
+
+	if (chnId > link->numOfChannels) {
+		mvIpcErrPrintf("IPC ERROR: Ena Chn RX: Bad channel id %d\n", chnId);
+		return;
+	}
+
+	chn = &link->channels[chnId];
+
+	chn->registerChnInISR(linkId, chnId, MV_TRUE);
+
+	mvIpcDbgPrintf("IPC HAL: Enabled ISR for link %d, channel %d\n", linkId, chnId);
+	return;
 }
 
 /***********************************************************************************
-* mvIpcRxMsg
-*
-* DESCRIPTION:
-*		Main Rx routine - should be called from interrupt routine
-*
-* INPUT:
-*		drblNum  - number of doorbel received
-* OUTPUT:
-*       outChnId - the channel id that received a message
-*       outMsg   - pointer to the message received
-* RETURN:
-*		MV_TRUE  - if a message was received
-*		MV_FALSE - if no message exists
-*
-************************************************************************************/
-MV_BOOL mvIpcRxMsg(MV_U32 *outChnId, MV_IPC_MSG **outMsg, MV_U32 drblNum)
+ * mvIpcRxMsg
+ *
+ * DESCRIPTION:
+ *		Main Rx routine - should be called from interrupt routine
+ *
+ * INPUT:
+ *		drblNum  - number of doorbel received
+ * OUTPUT:
+ *		linkId  - the link ID
+ *       chnId - the channel id that received a message
+ *       outMsg   - pointer to the message received
+ * RETURN:
+ *		MV_TRUE  - if a message was received
+ *		MV_FALSE - if no message exists
+ *
+ ************************************************************************************/
+MV_STATUS mvIpcRxMsg(MV_U32 linkId, MV_U32 chnId)
 {
-	MV_IPC_CHANNEL *chn;
+	MV_IPC_LINK             *link;
+	MV_IPC_CHANNEL  *chn;
 	MV_IPC_MSG     *currMsg;
-	MV_U32 	  chnId;
-	MV_STATUS status;
+	MV_U32 msgIndx;
 
-	status = mvIpcRecieveDoorbell(&chnId, drblNum);
+	if (linkId > MV_IPC_LINKS_NUM) {
+		mvIpcErrPrintf("IPC ERROR: Rx msg: Bad link id %d\n", chnId);
+		return MV_FAIL;
+	}
+
+	link = &mv_ipc_links[linkId];
 
-	if(chnId > MAX_IPC_CHANNELS) {
+	if (chnId > link->numOfChannels) {
 		mvIpcErrPrintf("IPC ERROR: Rx msg: Bad channel id %d\n", chnId);
-		return MV_FALSE;
+		return MV_FAIL;
 	}
 
-	chn = &ipcChannels[chnId];
+	chn = &link->channels[chnId];
 
 	if (chn->state == MV_CHN_CLOSED)
 		return MV_FALSE;
 
 	/* First process control messages like attach, detach, close */
-	if(isCtrlMsg(chn) == MV_TRUE){
-		mvIpcRxCtrlMsg(chnId, chn->rxCtrlMsg);
-	}
+	if (chn->rxCtrlMsg->isUsed == MV_TRUE)
+		mvIpcRxCtrlMsg(linkId, chnId, chn->rxCtrlMsg);
 
-	currMsg = &chn->rxMsgQueVa[chn->nextRxMsgIdx];
+	msgIndx = chn->nextRxMsgIdx;
+	currMsg = &chn->rxMsgQueVa[msgIndx];
 
 	// Check for unread data messages in queue */
-	if(currMsg->isUsed != MV_TRUE){
-		return MV_FALSE;
+	if (currMsg->isUsed != MV_TRUE) {
+		/*No more messages, disable RX ready flag*/
+		*((MV_U32 *)chn->rxMessageFlag) = 0x0;
+		return MV_NO_MORE;
 	}
 
 	/* Increment msg idx to keep in sync with sender */
 	chn->nextRxMsgIdx++;
-	if(chn->nextRxMsgIdx == chn->queSizeInMsg)
+	if (chn->nextRxMsgIdx == chn->queSizeInMsg)
 		chn->nextRxMsgIdx = 1;
 
 	// Check if channel is ready to receive messages */
-	if(chn->state < MV_CHN_OPEN){
+	if (chn->state < MV_CHN_OPEN) {
 		mvIpcErrPrintf("IPC ERROR: Rx msg: Channel not ready, state = %d\n", chn->state);
-		return MV_FALSE;
+		return MV_FAIL;
 	}
 
-	mvIpcDbgWrite(currMsg->align[2], axp_read_soc_clock(0));
+	mvIpcDbgWrite(currMsg->align[2], MV_IPC_HAND_SHAKE_MAGIC);
 
 	/* Now process user messages */
-	mvIpcDbgPrintf("IPC HAL: Received message %d on channel %d\n", chn->nextRxMsgIdx - 1, chnId);
+	mvIpcDbgPrintf("IPC HAL: Received message %d on channel %d\n",
+			chn->nextRxMsgIdx - 1, chnId);
 
-	(*outMsg)   = currMsg;
-	(*outChnId) = chnId;
+	/*Call user function to care the message*/
+	chn->rxCallback(currMsg);
 
-	return MV_TRUE;
+	return MV_OK;
+}
+
+/***********************************************************************************
+ * mvIpcRxMsgFlagCheck
+ *
+ * DESCRIPTION:
+ *		Check if RX flag raided
+ *
+ * INPUT:
+ *		linkId  - the link ID
+ *       chnId - the channel id that received a message
+ * OUTPUT:
+ * RETURN:
+ *		MV_TRUE  - if a RX flag raised
+ *		MV_FALSE - if no RX waiting
+ *
+ ************************************************************************************/
+MV_BOOL mvIpcRxMsgFlagCheck(MV_U32 linkId, MV_U32 chnId)
+{
+	MV_IPC_LINK             *link;
+	MV_IPC_CHANNEL  *chn;
+
+	if (linkId > MV_IPC_LINKS_NUM) {
+		mvIpcErrPrintf("IPC ERROR: Rx msg: Bad link id %d\n", chnId);
+		return MV_FALSE;
+	}
+
+	link = &mv_ipc_links[linkId];
+
+	if (chnId > link->numOfChannels) {
+		mvIpcErrPrintf("IPC ERROR: Rx msg: Bad channel id %d\n", chnId);
+		return MV_FALSE;
+	}
+
+	chn = &link->channels[chnId];
+
+	if (chn->state == MV_CHN_CLOSED)
+		return MV_FALSE;
+
+	if (*((MV_U32 *)chn->rxMessageFlag) == 0x1)
+		return MV_TRUE;
+	else
+		return MV_FALSE;
 }
 
 /***********************************************************************************
-* mvIpcReleaseMsg
-*
-* DESCRIPTION:
-*		Return ownership on message to transmitter
-*
-* INPUT:
-*		chnId - The channel ID
-*		msg   - Pointer to message to release
-* OUTPUT:
-*       None
-* RETURN:
-*		MV_OK or MV_ERROR
-*
-************************************************************************************/
-MV_STATUS mvIpcReleaseMsg(MV_U32 chnId, MV_IPC_MSG *msg)
+ * mvIpcReleaseMsg
+ *
+ * DESCRIPTION:
+ *		Return ownership on message to transmitter
+ *
+ * INPUT:
+ *		linkId  - the link ID
+ *		chnId - The channel ID
+ *		msg   - Pointer to message to release
+ * OUTPUT:
+ *       None
+ * RETURN:
+ *		MV_OK or MV_ERROR
+ *
+ ************************************************************************************/
+MV_STATUS mvIpcReleaseMsg(MV_U32 linkId, MV_U32 chnId, MV_IPC_MSG *msg)
 {
+	MV_IPC_LINK             *link;
 	MV_IPC_CHANNEL *chn;
 
-	if((chnId > MAX_IPC_CHANNELS) || (ipcChannels[chnId].state == MV_CHN_CLOSED)) {
-		mvIpcErrPrintf("IPC ERROR: Msg release: Bad or inactive channel id %d\n", chnId);
-		return MV_ERROR;
+	if (linkId > MV_IPC_LINKS_NUM) {
+		mvIpcErrPrintf("IPC ERROR: Tx Msg: Bad link id %d\n", chnId);
+		return MV_FALSE;
 	}
 
-	chn = &ipcChannels[chnId];
+	link = &mv_ipc_links[linkId];
+
+	if (chnId > link->numOfChannels) {
+		mvIpcErrPrintf("IPC ERROR: Tx Msg: Bad channel id %d\n", chnId);
+		return MV_FALSE;
+	}
+
+	chn = &link->channels[chnId];
+
+	if (chn->state == MV_CHN_CLOSED) {
+		mvIpcErrPrintf("IPC ERROR: Msg release: Inactive channel id %d\n", chnId);
+		return MV_ERROR;
+	}
 
-	if(msg->isUsed == MV_FALSE) {
-		mvIpcErrPrintf("IPC ERROR: Msg release: Msg %d owned by %d\n", chn->nextRxMsgIdx, msg->isUsed);
+	if (msg->isUsed == MV_FALSE) {
+		mvIpcErrPrintf("IPC ERROR: Msg release: Msg %d owned by %d\n",
+			chn->nextRxMsgIdx, msg->isUsed);
 		return MV_ERROR;
 	}
 
 	msg->isUsed   = MV_FALSE;
-	mvIpcDbgWrite(msg->align[1], axp_read_soc_clock(0));
+	mvIpcDbgWrite(msg->align[1], MV_IPC_HAND_SHAKE_MAGIC);
 
-	mvIpcDbgPrintf("IPC HAL: Released message 0x%8x on channel %d\n", msg, chnId);
+	mvIpcDbgPrintf("IPC HAL: Released message 0x%8x on channel %d\n", (int)msg, chnId);
 
 	return MV_OK;
 }
+
+/***********************************************************************************
+ * mvIpcShmemMalloc
+ *
+ * DESCRIPTION:
+ *		Malloc buffer in shared memory heap for TX buffers
+ *		(Sequentual malloc, no free allowed)
+ *
+ * INPUT:
+ *		linkId  - the link ID
+ *		size - requested buffer size
+ * OUTPUT:
+ *       offset of the buffer
+ * RETURN:
+ *		MV_OK or MV_ERROR
+ *
+ ************************************************************************************/
+MV_VOID *mvIpcShmemMalloc(MV_U32 linkId, MV_U32 size)
+{
+	MV_IPC_LINK             *link;
+	MV_VOID *ptr;
+
+	if (linkId > MV_IPC_LINKS_NUM) {
+		mvIpcErrPrintf("IPC ERROR: Tx Msg: Bad link id %d\n", linkId);
+		return MV_FALSE;
+	}
+
+	link = &mv_ipc_links[linkId];
+
+	if (size > link->txSharedHeapSize)
+		return NULL;
+
+	ptr = (MV_VOID *)link->txSharedHeapAddr;
+
+	link->txSharedHeapAddr  += size;
+	link->txSharedHeapSize -= size;
+
+	return ptr;
+}
diff --git a/arch/arm/plat-armada/common/mvIpc.h b/arch/arm/plat-armada/common/mvIpc.h
index 7cf3d44..fe91bad 100644
--- a/arch/arm/plat-armada/common/mvIpc.h
+++ b/arch/arm/plat-armada/common/mvIpc.h
@@ -1,75 +1,71 @@
 /*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
+   Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
 
 ********************************************************************************
-Marvell Commercial License Option
+   Marvell Commercial License Option
 
-If you received this File from Marvell and you have entered into a commercial
-license agreement (a "Commercial License") with Marvell, the File is licensed
-to you under the terms of the applicable Commercial License.
+   If you received this File from Marvell and you have entered into a commercial
+   license agreement (a "Commercial License") with Marvell, the File is licensed
+   to you under the terms of the applicable Commercial License.
 
 ********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
 ********************************************************************************
-Marvell BSD License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File under the following licensing terms.
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
-
-    *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution.
-
-    *   Neither the name of Marvell nor the names of its contributors may be
-        used to endorse or promote products derived from this software without
-        specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+   Marvell BSD License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File under the following licensing terms.
+   Redistribution and use in source and binary forms, with or without modification,
+   are permitted provided that the following conditions are met:
+
+*   Redistributions of source code must retain the above copyright notice,
+		this list of conditions and the following disclaimer.
+
+*   Redistributions in binary form must reproduce the above copyright
+		notice, this list of conditions and the following disclaimer in the
+		documentation and/or other materials provided with the distribution.
+
+*   Neither the name of Marvell nor the names of its contributors may be
+		used to endorse or promote products derived from this software without
+		specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+   ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+   ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
-
 #ifndef __mvIpc_h
 #define __mvIpc_h
 
-#define IPC_TRANSMITTER		0
-#define IPC_RECIEVER		1
-
-typedef enum
-{
+/*Channel statuses*/
+typedef enum {
 	MV_CHN_CLOSED =  0,
 	MV_CHN_OPEN,
 	MV_CHN_LINKING,
@@ -78,59 +74,85 @@ typedef enum
 
 }MV_IPC_CHN_STATE;
 
-typedef struct __ipc_message_struct
-{
-	MV_U32	 type;
-	MV_U32 	 size; 			/*buffer size*/
-	MV_VOID* ptr;   		/*buffer virtual address for Rx side*/
-	MV_U32	 value;			/*User data*/
-	MV_U32   isUsed;		/*CPU Id and optional oob message*/
-	MV_U32	 align[3];		/* Align message size to cache line */
+/*Message struct(channel queue entry)*/
+typedef struct __ipc_message_struct {
+	MV_U32 type;
+	MV_U32 size;                    /*buffer size*/
+	MV_VOID *ptr;                   /*buffer virtual address for Rx side*/
+	MV_U32 value;                   /*User data*/
+	MV_U32 isUsed;                  /*CPU Id and optional oob message*/
+	MV_U32 align[3];                /* Align message size to cache line */
 } MV_IPC_MSG;
 
-typedef struct __ipc_channel_struct
-{
-	MV_IPC_MSG* rxMsgQueVa;   /*buffer virtual address for Rx side*/
-	MV_IPC_MSG* txMsgQueVa;   /*buffer virtual address for Tx side*/
-	MV_IPC_MSG* rxCtrlMsg;    /*buffer virtual address for Rx side*/
-	MV_IPC_MSG* txCtrlMsg;    /*buffer virtual address for Tx side*/
-	MV_U32	 nextRxMsgIdx;
-	MV_U32	 nextTxMsgIdx;
-	MV_U32	 queSizeInMsg;
-	MV_U32   remoteCpuId;
-	MV_BOOL	 txEnable;
-	MV_BOOL	 rxEnable;
+/*Function types*/
+typedef int (*MV_IPC_RX_CLBK)(MV_IPC_MSG *msg);
+typedef MV_VOID (*MV_IPC_SEND_TRIGGER)(MV_U32 linkId, MV_U32 chnId);
+typedef MV_VOID (*MV_IPC_RX_CHANNEL_REGISTER)(MV_U32 linkId, MV_U32 chnId, MV_BOOL enable);
+
+/*Channel struct*/
+typedef struct __ipc_channel_struct {
+	MV_IPC_MSG *rxMsgQueVa;         /*buffer virtual address for Rx side*/
+	MV_IPC_MSG *txMsgQueVa;         /*buffer virtual address for Tx side*/
+	MV_IPC_MSG *rxCtrlMsg;          /*buffer virtual address for Rx side*/
+	MV_IPC_MSG *txCtrlMsg;          /*buffer virtual address for Tx side*/
+	MV_U32 nextRxMsgIdx;
+	MV_U32 nextTxMsgIdx;
+	MV_U32 queSizeInMsg;
+	MV_U32 remoteNodeId;
+	MV_BOOL txEnable;
+	MV_BOOL rxEnable;
 	MV_IPC_CHN_STATE state;
 
-} MV_IPC_CHANNEL;
+	MV_U32 txMessageFlag;                           /*Shared memory flag raised for message in queue*/
+	MV_U32 rxMessageFlag;                           /*Shared memory flag raised for message in queue*/
 
-#define MAX_IPC_CHANNELS     4
-#define MV_IPC_QUEUE_SIZE    256
-#define MV_IPC_QUEUE_MEM     (MV_IPC_QUEUE_SIZE * 2 * sizeof(MV_IPC_MSG) * MAX_IPC_CHANNELS)
-#define MAX_USER_MSG_TYPE	 (1 << 16)
+	MV_IPC_RX_CLBK rxCallback;                      /*Called for for each RX*/
+	MV_IPC_SEND_TRIGGER sendTrigger;                /*Trigger to remote node to start RX*/
+	MV_IPC_RX_CHANNEL_REGISTER registerChnInISR;    /*Register the channel in RX ISR/Timer*/
+} MV_IPC_CHANNEL;
 
-typedef enum
-{
+/*Magic for masterConfigDone, wrote by master and clean by slave*/
+#define MV_IPC_MASTER_CONFIG_MAGIC      0x12345678
+#define MV_IPC_HAND_SHAKE_MAGIC         0x87654321
+/*Link struct(hold array of channels)*/
+typedef struct __ipc_link_struct {
+	MV_IPC_CHANNEL *channels;       /*Array of channels*/
+	MV_U32 numOfChannels;           /*Number of channels*/
+	MV_U32 shmemBaseAddr;           /*Shared mem physycal addr*/
+	MV_U32 shmemSize;               /*Shared mem physycal addr*/
+	MV_U32 nodeId;                  /*I node ID*/
+	MV_U32 remoteNodeId;            /*remote node ID*/
+	MV_U32 txSharedHeapAddr;        /*offset of heap node memory*/
+	MV_U32 txSharedHeapSize;        /*size of heap node memory*/
+	MV_U32 rxSharedHeapAddr;        /*offset of heap for remote node memory*/
+	MV_U32 rxSharedHeapSize;        /*size of heap node memory*/
+	MV_U32 masterConfigDone;        /*if master finished the configuration*/
+	MV_U32 slaveLinkInitialized;   /*if master not finished the configuration
+									and configuration was postponed by slave*/
+} MV_IPC_LINK;
+
+/*Control messages types*/
+typedef enum {
 	IPC_MSG_ATTACH_REQ = 0,
 	IPC_MSG_ATTACH_ACK,
 	IPC_MSG_DETACH_REQ,
 	IPC_MSG_DETACH_ACK
 }MV_IPC_CTRL_MSG_TYPE;
 
-
-MV_STATUS mvIpcInit(MV_VOID *qbasePtr, MV_BOOL primary);
-MV_STATUS mvIpcClose(MV_VOID);
-MV_STATUS mvIpcOpenChannel(MV_U32 chnId);
-MV_STATUS mvIpcCloseChannel(MV_U32 chnId);
-MV_STATUS mvIpcAttachChannel(MV_U32 chnId, MV_U32 remoteCpuId, MV_BOOL *attached);
-MV_STATUS mvIpcDettachChannel(MV_U32 chnId);
-MV_BOOL   mvIpcIsTxReady(MV_U32 chnId);
-MV_STATUS mvIpcTxMsg(MV_U32 chnId, MV_IPC_MSG *inMsg);
-MV_STATUS mvIpcTxCtrlMsg(MV_U32 chnId, MV_IPC_MSG *inMsg);
-MV_STATUS mvIpcRxMsg(MV_U32 *outChnId, MV_IPC_MSG **outMsg, MV_U32 drblNum);
-MV_STATUS mvIpcReleaseMsg(MV_U32 chnId, MV_IPC_MSG *msg);
-MV_VOID   mvIpcDisableChnRx(MV_U32 irq);
-MV_VOID   mvIpcEnableChnRx(MV_U32 irq);
-
+MV_STATUS mvIpcLinkStart(MV_U32 linkId);
+MV_STATUS mvIpcClose(MV_U32 linkId);
+MV_STATUS mvIpcOpenChannel(MV_U32 linkId, MV_U32 chnId, MV_IPC_RX_CLBK rx_clbk);
+MV_STATUS mvIpcCloseChannel(MV_U32 linkId, MV_U32 chnId);
+MV_STATUS mvIpcAttachChannel(MV_U32 linkId, MV_U32 chnId, MV_U32 remoteCpuId, MV_BOOL *attached);
+MV_STATUS mvIpcDettachChannel(MV_U32 linkId, MV_U32 chnId);
+MV_BOOL   mvIpcIsTxReady(MV_U32 linkId, MV_U32 chnId);
+MV_STATUS mvIpcTxMsg(MV_U32 linkId, MV_U32 chnId, MV_IPC_MSG *inMsg);
+MV_STATUS mvIpcTxCtrlMsg(MV_U32 linkId, MV_U32 chnId, MV_IPC_MSG *inMsg);
+MV_STATUS mvIpcRxMsg(MV_U32 linkId, MV_U32 chnId);
+MV_BOOL mvIpcRxMsgFlagCheck(MV_U32 linkId, MV_U32 chnId);
+MV_STATUS mvIpcReleaseMsg(MV_U32 linkId, MV_U32 chnId, MV_IPC_MSG *msg);
+MV_VOID   mvIpcDisableChnRx(MV_U32 linkId, MV_U32 chnId);
+MV_VOID   mvIpcEnableChnRx(MV_U32 linkId, MV_U32 chnId);
+MV_VOID *mvIpcShmemMalloc(MV_U32 linkId, MV_U32 size);
 
 #endif /*__mvIpc_h */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/Makefile b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/Makefile
index 89f41c9..94d6267 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/Makefile
@@ -1,8 +1,9 @@
 #
-# Makefile for the Marvell IPC Pseudo Network driver
+# Makefile for the Marvell IPC driver
 #
 ifneq ($(MACHINE),)
 include $(srctree)/$(MACHINE)/config/mvRules.mk
 endif
 
-obj-$(CONFIG_MV_IPC_NET) += mv_ipc.o
+obj-$(CONFIG_MV_IPC_LINUX_AMP_DRIVER) += linux_amp/mv_ipc_os.o linux_amp/mv_ipc_doorbell.o \
+								linux_amp/mv_ipc_poll.o linux_amp/mv_ipc_common.o
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_common.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_common.c
new file mode 100644
index 0000000..fb2be9e
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_common.c
@@ -0,0 +1,185 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+*******************************************************************************/
+
+#include "mvTypes.h"
+#include "mvOs.h"
+
+#include "mv_ipc_common.h"
+#include "mv_ipc_node.h"
+#include "mv_ipc_os.h"
+#include "mvIpc.h"
+
+MV_IPC_LINK_INFO mv_ipc_link_info_array[MV_IPC_LINKS_NUM] = MV_IPC_LINK_INFO_TABLE;
+MV_IPC_CHN_INFO mv_ipc_chn_info_array[MV_IPC_LINKS_NUM][MV_IPC_CHN_NUM_MAX] =
+	MV_IPC_CHN_INFO_TABLE;
+MV_VOID *hwLayerAPI[MV_IPC_HW_LAYERS_NUM][2] = MV_IPC_HW_LAYER_API_TABLE;
+
+MV_U32 mv_ipc_master_free_reg_percent[MV_IPC_LINKS_NUM] =
+	MV_IPC_MASTER_FREE_REGION_PERCENT_TBL;
+
+/*#define IPC_DRV_DEBUG*/
+
+/*Return local node ID*/
+MV_U32 mvIpcWhoAmI(void)
+{
+	if (CONFIG_MV_DRAM_BASE == 0x0)
+		return 0;
+	else
+		return 1;
+}
+
+/*Return number of link in local node*/
+MV_U32 mvIpcGetNumOfLinks(void)
+{
+	return MV_IPC_LINKS_NUM;
+}
+
+/*Return number of channels for the link*/
+MV_U32 mvIpcChnNum(MV_U32 link)
+{
+	MV_IPC_LINK_INFO *str = &mv_ipc_link_info_array[link];
+
+	return str->numOfChannels;
+}
+
+/*Return max number of channels for all links*/
+MV_U32 mvIpcChnNumMax(void)
+{
+	return MV_IPC_CHN_NUM_MAX;
+}
+
+/*Return true if local node is a master for the link*/
+MV_BOOL mvIpcGetlinkMaster(MV_U32 link)
+{
+/*	MV_IPC_LINK_INFO* str = &mv_ipc_link_info_array[link];
+	return str->isMaster;*/
+
+	if (CONFIG_MV_DRAM_BASE == 0x0)
+		return MV_TRUE;
+	else
+		return MV_FALSE;
+}
+
+/*Return remote node ID for the link*/
+MV_U32 mvIpcGetlinkRemoteNodeId(MV_U32 link)
+{
+/*	MV_IPC_LINK_INFO* str = &mv_ipc_link_info_array[link];
+	return str->isMaster;*/
+
+	if (CONFIG_MV_DRAM_BASE == 0x0)
+		return 1;
+	else
+		return 0;
+}
+
+/*Return Shared memory base address*/
+MV_VOID *mvIpcGetShmemAddr(MV_U32 link)
+{
+	return mvIpcOsGetVirtBase(link);
+}
+
+/*Return Shared memory Phys base size*/
+MV_U32 mvIpcGetShmemBaseAddr(MV_U32 link)
+{
+	MV_IPC_LINK_INFO *str = &mv_ipc_link_info_array[link];
+
+	return str->shmemAddr;
+}
+
+/*Return Shared memory Virtual base size*/
+MV_U32 mvIpcGetShmemSize(MV_U32 link)
+{
+	MV_IPC_LINK_INFO *str = &mv_ipc_link_info_array[link];
+
+	return str->shmemSize;
+}
+
+/*Return queue size*/
+MV_U32 mvIpcGetChnQueueSize(MV_U32 link, MV_U32 chn)
+{
+	MV_IPC_CHN_INFO *str = &mv_ipc_chn_info_array[link][chn];
+
+	return str->queueSize;
+}
+
+/*Return HW Layer ID */
+MV_U32 mvIpcGetHwLayerId(MV_U32 link)
+{
+	return MV_IPC_HW_LAYER_ACTUAL;
+}
+
+/*Return pointer to Send Trigger function*/
+MV_IPC_SEND_TRIGGER mvIpcGetChnTxHwPtr(MV_U32 link)
+{
+	return hwLayerAPI[mvIpcGetHwLayerId(link)][0];
+}
+
+/*Return pointer to Register channel function*/
+MV_IPC_RX_CHANNEL_REGISTER mvIpcGetChnRxHwPtr(MV_U32 link)
+{
+	return hwLayerAPI[mvIpcGetHwLayerId(link)][1];
+}
+
+/*Return percent of free memory division between master and slave*/
+MV_U32 mvIpcGetFreeMemMasterPercent(MV_U32 link)
+{
+	return mv_ipc_master_free_reg_percent[link];
+}
+
+/*Do init sequence*/
+MV_STATUS mvIpcCommonInit(void)
+{
+	MV_U32 link;
+	MV_STATUS status;
+
+#ifdef IPC_DRV_DEBUG
+	if (CONFIG_MV_DRAM_BASE == 0x0) {
+		printk(KERN_INFO "---------------------Delay to async boot sequence----------\n");
+		mvOsDelay(1000);
+	}
+#endif
+
+	/* Initialize shared memory*/
+	for (link = 0; link < mvIpcGetNumOfLinks(); link++)
+		mvIpcOsSharedStack(link, mvIpcGetShmemBaseAddr(link), mvIpcGetShmemSize(link));
+
+	for (link = 0; link < mvIpcGetNumOfLinks(); link++) {
+		mvIpcDoorbellInit(link);
+		mvIpcPollInit(link);
+	}
+
+	for (link = 0; link < mvIpcGetNumOfLinks(); link++) {
+		status = mvIpcLinkStart(link);
+		if (status != MV_OK) {
+			printk(KERN_ERR "IPC: IPC HAL %d initialization failed\n", 0);
+			return status;
+		}
+	}
+
+	return MV_OK;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_common.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_common.h
new file mode 100644
index 0000000..d8ff4d3
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_common.h
@@ -0,0 +1,111 @@
+/*******************************************************************************
+   Copyright (C) Marvell MV_U32ernational Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   MV_U32ernational Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   MV_U32roductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+********************************************************************************
+   Marvell Commercial License Option
+
+   If you received this File from Marvell and you have entered MV_U32o a commercial
+   license agreement (a "Commercial License") with Marvell, the File is licensed
+   to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+********************************************************************************
+   Marvell BSD License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File under the following licensing terms.
+   Redistribution and use in source and binary forms, with or without modification,
+   are permitted provided that the following conditions are met:
+
+*   Redistributions of source code must retain the above copyright notice,
+            this list of conditions and the following disclaimer.
+
+*   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+*   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+   ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS MV_U32ERRUPTION) HOWEVER CAUSED AND ON
+   ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#ifndef __mv_ipc_common_h
+#define __mv_ipc_common_h
+
+#include "mv_ipc_node.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "cpu/mvCpu.h"
+#include "mvIpc.h"
+#include "mvOs.h"
+#include "mv_ipc_doorbell.h"
+#include "mv_ipc_os.h"
+
+typedef struct __ipc_link_info_struct {
+	MV_U32 numOfChannels;
+	MV_BOOL isMaster;
+	MV_VOID *shmemVirtAddr;
+	MV_U32 shmemAddr;
+	MV_U32 shmemSize;
+} MV_IPC_LINK_INFO;
+
+typedef struct __ipc_chn_info_struct {
+	MV_U32 queueSize;
+} MV_IPC_CHN_INFO;
+
+/*Interrupt/Polling modes*/
+enum {
+	MV_IPC_HW_LAYER_POLLING_ACTIVE  = 0,
+	MV_IPC_HW_LAYER_INTERRUPT_ISR,
+	MV_IPC_HW_LAYER_POLLING_PASSIVE,
+};
+
+MV_U32 mvIpcWhoAmI(void);
+MV_U32 mvIpcGetNumOfLinks(void);
+MV_U32 mvIpcChnNum(MV_U32 link);
+MV_U32 mvIpcChnNumMax(void);
+MV_BOOL mvIpcGetlinkMaster(MV_U32 link);
+MV_U32 mvIpcGetlinkRemoteNodeId(MV_U32 link);
+MV_VOID *mvIpcGetShmemAddr(MV_U32 link);
+MV_U32 mvIpcGetShmemBaseAddr(MV_U32 link);
+MV_U32 mvIpcGetShmemSize(MV_U32 link);
+MV_U32 mvIpcGetChnQueueSize(MV_U32 link, MV_U32 chn);
+MV_U32 mvIpcGetHwLayerId(MV_U32 link);
+MV_IPC_SEND_TRIGGER mvIpcGetChnTxHwPtr(MV_U32 link);
+MV_IPC_RX_CHANNEL_REGISTER mvIpcGetChnRxHwPtr(MV_U32 link);
+MV_U32 mvIpcGetFreeMemMasterPercent(MV_U32 link);
+MV_STATUS mvIpcCommonInit(void);
+
+#endif /*__mv_ipc_common_h*/
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_doorbell.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_doorbell.c
new file mode 100644
index 0000000..0ee2608
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_doorbell.c
@@ -0,0 +1,190 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+*******************************************************************************/
+
+#include "mvTypes.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "cpu/mvCpu.h"
+#include "mvIpc.h"
+#include "mvOs.h"
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/init.h>
+#include <linux/moduleparam.h>
+#include <asm/irq_regs.h>
+
+#include "mvDebug.h"
+#include "mvCommon.h"
+#include "mvIpc.h"
+#include "mv_ipc_doorbell.h"
+#include "mv_ipc_common.h"
+#include "mv_ipc_node.h"
+#include "include/mach/smp.h"
+
+/*#define IPC_DRV_DEBUG*/
+#ifdef IPC_DRV_DEBUG
+#define ipc_debug       printk
+#else
+#define ipc_debug(x ...)
+#endif
+
+static MV_U8 **enabledChannels;
+
+/***********************************************************************************
+ * mvIpcDoorbellInit
+ *
+ * DESCRIPTION:
+ *              Init the structures
+ *
+ * INPUT:
+ *		None
+ * OUTPUT:
+ *       None
+ * RETURN:
+ *		None
+ *
+ ************************************************************************************/
+MV_VOID mvIpcDoorbellInit(MV_U32 link)
+{
+	if (NULL == enabledChannels)
+		enabledChannels = mvOsMalloc(sizeof(MV_U8 *) * mvIpcGetNumOfLinks());
+
+	enabledChannels[link] = mvOsMalloc(sizeof(MV_U8) * mvIpcChnNumMax());
+	mvOsMemset(enabledChannels[link], '\0', mvIpcChnNumMax());
+
+	/*request_irq for doorbell done in assembly*/
+
+	return;
+}
+
+/***********************************************************************************
+ * mvIpcSendDoorbell
+ *
+ * DESCRIPTION:
+ *              Send an IPC doorbell to target CPU
+ *
+ * INPUT:
+ *		cpuId - the id of the target CPU
+ *		chnId - The channel ID
+ * OUTPUT:
+ *       None
+ * RETURN:
+ *		MV_OK or MV_ERROR
+ *
+ ************************************************************************************/
+MV_VOID mvIpcSendDoorbell(MV_U32 linkId, MV_U32 chnId)
+{
+	MV_U32 doorbellNum;
+	MV_U32 cpuBitMask;
+
+	cpuBitMask   = (1 << mvIpcGetlinkRemoteNodeId(linkId));
+	doorbellNum  = IPC_BASE_DOORBELL + chnId;
+
+	/* Use private doorbell 15 for IPC */
+	MV_REG_WRITE(CPU_SW_TRIG_IRQ, (cpuBitMask << 8) | doorbellNum);
+
+	return;
+}
+
+/***********************************************************************************
+ * registerChnInISRDoorbell
+ *
+ * DESCRIPTION:
+ *		Enable/disable doorbell for the given channel
+ *
+ * INPUT:
+ *		linkId - Link id
+ *		chnId -  Channel id
+ *		enable - Disable or enable the interrupt
+ * OUTPUT:
+ *       None
+ * RETURN:
+ *		MV_OK or MV_ERROR
+ *
+ ************************************************************************************/
+MV_VOID registerChnInISRDoorbell(MV_U32 linkId, MV_U32 chnId, MV_BOOL enable)
+{
+	if (MV_TRUE == enable) {
+		enabledChannels[linkId][chnId] = 1;
+		/* Set the doorbell corresponding to channel */
+		MV_REG_BIT_SET(CPU_DOORBELL_IN_MASK_REG, (1));
+	} else {
+		enabledChannels[linkId][chnId] = 0;
+		/* Reset the doorbell corresponding to channel */
+		MV_REG_BIT_RESET(CPU_DOORBELL_IN_MASK_REG, (1));
+	}
+}
+
+/*******************************************************************************
+ * do_ipc_rx_irq()                                                             *
+ *  rx interrupt service routine                                               *
+ ******************************************************************************/
+void do_ipc_rx_irq(int irq, struct pt_regs *regs)
+{
+	MV_U32 linkId, chnId;
+	int read_msgs = IPC_RX_MAX_MSGS_PER_ISR;
+	struct pt_regs *old_regs = set_irq_regs(regs);
+
+	ipc_debug(KERN_INFO "IPC: RX callback. got irq no = %d\n", irq);
+
+	irq_enter();
+	/*Disable interrpt*/
+	MV_REG_BIT_RESET(CPU_DOORBELL_IN_MASK_REG, (1));
+
+	/*NOTE:
+	        This ISR may be customised by user application requerements to make it more efficient*/
+
+	/* Scan all rx flags*/
+	for (linkId = 0; linkId < mvIpcGetNumOfLinks(); linkId++) {
+		for (chnId = 0; chnId < mvIpcChnNum(linkId); chnId++) {
+			/*Check if RX flag raised*/
+			if ((enabledChannels[linkId][chnId] == 1) &&
+			    (mvIpcRxMsgFlagCheck(linkId, chnId) == MV_TRUE)) {
+				/*If ready ti RX, start get the messages*/
+				ipc_debug(KERN_INFO "Got message in channel %d\n", chnId);
+				while (read_msgs) {
+					if (mvIpcRxMsg(linkId, chnId) != MV_OK)
+						break;
+					read_msgs--;
+				}
+			}
+		}
+	}
+
+	/*Enable interrpt*/
+	MV_REG_BIT_SET(CPU_DOORBELL_IN_MASK_REG, (1));
+	irq_exit();
+
+	if (read_msgs == IPC_RX_MAX_MSGS_PER_ISR)
+		ipc_debug(KERN_WARNING "IPC: Received interrupt with no messages\n");
+
+	set_irq_regs(old_regs);
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_doorbell.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_doorbell.h
new file mode 100644
index 0000000..a556539
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_doorbell.h
@@ -0,0 +1,74 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+********************************************************************************
+   Marvell Commercial License Option
+
+   If you received this File from Marvell and you have entered into a commercial
+   license agreement (a "Commercial License") with Marvell, the File is licensed
+   to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+********************************************************************************
+   Marvell BSD License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File under the following licensing terms.
+   Redistribution and use in source and binary forms, with or without modification,
+   are permitted provided that the following conditions are met:
+
+*   Redistributions of source code must retain the above copyright notice,
+            this list of conditions and the following disclaimer.
+
+*   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+*   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+   ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+   ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#ifndef __mv_ipc_doorbell_h
+#define __mv_ipc_doorbell_h
+
+#define IPC_BASE_DOORBELL                       12
+#define IPC_RX_MAX_MSGS_PER_ISR         50
+
+MV_VOID mvIpcSendDoorbell(MV_U32 linkId, MV_U32 chnId);
+MV_VOID registerChnInISRDoorbell(MV_U32 linkId, MV_U32 chnId, MV_BOOL enable);
+MV_VOID mvIpcDoorbellInit(MV_U32 linkId);
+
+#endif /*__mv_ipc_doorbell_h*/
\ No newline at end of file
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_node.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_node.h
new file mode 100644
index 0000000..3d6a4b9
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_node.h
@@ -0,0 +1,81 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+*******************************************************************************/
+
+#ifndef __mv_ipc_node_h
+#define __mv_ipc_node_h
+
+#include "mvTypes.h"
+#include "mv_ipc_doorbell.h"
+#include "mv_ipc_poll.h"
+
+/*NOTE:
+        This files defines node configuration, the data used by mv_ipc_common
+        to implement API for OS/HW/HAL layers.
+        For AMP node part of data may by irrelevant,
+        because single mv_ipc_node.h used, so configuration will differ in runtime*/
+
+/*Unique ID of the IPC node, all nodes should be numbered sequentially from 0*/
+#define MV_IPC_NODE_ID 0
+
+/*Number of links established with other nodes*/
+#define MV_IPC_LINKS_NUM 2
+
+#define MV_IPC_CHN_NUM_MAX 8
+/*Sizes of TX/RX queues for each channel (slave node doesnt know the sizes)*/
+/*For slave the value will be ignored*/
+#define MV_IPC_CHN_INFO_TABLE  { \
+		{ { 16 }, { 32 }, { 16 }, { 32 } }, \
+		{ { 16 }, { 32 }, { 16 }, { 32 }, { 16 }, { 32 }, { 16 }, { 32 } } \
+}
+
+/*Set HW Layer mode*/
+/*#define MV_IPC_HW_LAYER_ACTUAL        MV_IPC_HW_LAYER_POLLING_ACTIVE*/
+#define MV_IPC_HW_LAYER_ACTUAL  MV_IPC_HW_LAYER_INTERRUPT_ISR
+
+#define MV_IPC_HW_LAYERS_NUM    2
+/*HW layers function, send trigger is TX done signal,
+        register channel is interrupt and channel enable function*/
+#define MV_IPC_HW_LAYER_API_TABLE  { \
+		{ mvIpcSendTriggerPoll, registerChnInISRPoll },         /*MV_IPC_HW_LAYER_POLLING_ACTIVE*/ \
+		{ mvIpcSendDoorbell, registerChnInISRDoorbell },        /*MV_IPC_HW_LAYER_INTERRUPT_ISR*/ \
+}
+
+/*Link info array, set number of channels,
+   master/slave. shmem phys adrress and size*/
+/*numOfChn		isMaster, shmemAddr,		shmemSize*/
+#define MV_IPC_LINK_INFO_TABLE { \
+		{ 4,             MV_TRUE,        NULL,           0x60000000,             0x100000 }, \
+		{ 8,             MV_TRUE,        NULL,           0x60100000,             0x100000 }, \
+}
+
+/*Division of free malloc area between master and slave*/
+#define MV_IPC_MASTER_FREE_REGION_PERCENT_TBL {	\
+		50, 50		\
+}
+
+#endif /*__mv_ipc_node_h*/
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_os.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_os.c
new file mode 100644
index 0000000..c8d92d5
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_os.c
@@ -0,0 +1,178 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+*******************************************************************************/
+
+#include "mvTypes.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "cpu/mvCpu.h"
+#include "mvIpc.h"
+#include "mvOs.h"
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/init.h>
+#include <linux/moduleparam.h>
+#include <asm/irq_regs.h>
+
+#include "mvDebug.h"
+#include "mvCommon.h"
+#include "mvIpc.h"
+#include "mv_ipc_os.h"
+#include "mv_ipc_common.h"
+#include "mv_ipc_node.h"
+#include "mv_ipc_doorbell.h"
+#include "mv_ipc_poll.h"
+#include "include/mach/smp.h"
+
+unsigned int mv_ipc_sh_mem_base[MV_IPC_LINKS_NUM], mv_ipc_sh_mem_size[MV_IPC_LINKS_NUM];
+
+void   *sh_virt_base[MV_IPC_LINKS_NUM];
+unsigned int virt_phys_offset[MV_IPC_LINKS_NUM];
+bool ipcInitialized = 0;
+
+MV_U8 **enabledChannels;
+
+/*#define IPC_DRV_DEBUG*/
+#ifdef IPC_DRV_DEBUG
+#define ipc_debug       printk
+#else
+#define ipc_debug(x ...)
+#endif
+
+/*******************************************************************************
+ * ipc_init_shared_stack()                                                     *
+ *   Initialize the shared stack used for communication
+ ******************************************************************************/
+int mvIpcOsSharedStack(unsigned int link, unsigned int sh_phys_base,
+		       unsigned int sh_mem_size)
+{
+	mv_ipc_sh_mem_base[link] = sh_phys_base;
+	mv_ipc_sh_mem_size[link] = sh_mem_size;
+
+	/* Map shared memory and initialize shared stack */
+	sh_virt_base[link]  = ioremap(sh_phys_base, sh_mem_size);
+	if (!sh_virt_base[link]) {
+		printk(KERN_ERR "IPC: Unable to map physical shared mem block (%#010x - %#010x)\n",
+		       sh_phys_base, sh_phys_base + sh_mem_size);
+		return 0;
+	}
+
+	virt_phys_offset[link] = (unsigned int)sh_virt_base[link] - sh_phys_base;
+
+	ipc_debug(KERN_INFO "IPC: Remaped Shared memory PA %#010x to VA %#010x\n",
+		  (unsigned int)sh_phys_base, (unsigned int)sh_virt_base[link]);
+
+	return 1;
+}
+
+/*******************************************************************************
+ * ipc_virt_to_phys()                                                          *
+ *   address translation for shared stack
+ ******************************************************************************/
+void *mvIpcOsVirt2Phys(unsigned int link, void *virt_addr)
+{
+	void *phys_addr = 0;
+
+	if ((virt_addr >= sh_virt_base[link]) && (virt_addr < (sh_virt_base[link] +
+							       mv_ipc_sh_mem_size[link])))
+		phys_addr = (void *)((unsigned int)virt_addr - virt_phys_offset[link]);
+
+	return phys_addr;
+}
+
+/*******************************************************************************
+ * ipc_phys_to_virt()                                                          *
+ *   address translation for shared stack
+ ******************************************************************************/
+void *mvIpcOsPhys2Virt(unsigned int link, void *phys_addr)
+{
+	void *virt_addr = 0;
+
+	if (((int)phys_addr >= mv_ipc_sh_mem_base[link]) &&
+			((int)phys_addr < (mv_ipc_sh_mem_base[link] + mv_ipc_sh_mem_size[link])))
+		virt_addr = (void *)((unsigned int)phys_addr + virt_phys_offset[link]);
+
+	return virt_addr;
+}
+
+/*******************************************************************************
+ * ipc_get_virt_base()                                                         *
+ *   address translation for base of shared stack
+ ******************************************************************************/
+void *mvIpcOsGetVirtBase(unsigned int link)
+{
+	return sh_virt_base[link];
+}
+
+/*******************************************************************************
+ * mvOsSync()                                                                  *
+ *   Barrier/ cache invalidate function
+ ******************************************************************************/
+void mvOsSync(void)
+{
+	dmb();
+}
+
+/*******************************************************************************
+ * ipc_init_module()                                                           *
+ *   intialize and register IPC driver interface                               *
+ ******************************************************************************/
+static int __init ipc_init_module(void)
+{
+	MV_STATUS status;
+
+	status = mvIpcCommonInit();
+
+	ipcInitialized = 1;
+
+	printk(KERN_INFO "IPC: Driver initialized successfully\n");
+
+	return 0;
+}
+
+/*******************************************************************************
+ * ipc_cleanup_module()                                                        *
+ *   close IPC driver                                                          *
+ ******************************************************************************/
+static void __exit ipc_cleanup_module(void)
+{
+	ipcInitialized = 0;
+
+	mvIpcClose(0);
+
+	/* Unmap shared memory space */
+	iounmap(sh_virt_base[0]);
+}
+
+module_init(ipc_init_module);
+module_exit(ipc_cleanup_module);
+MODULE_DESCRIPTION("Marvell Inter Processor Communication (IPC) Driver");
+MODULE_AUTHOR("Yehuda Yitschak <yehuday@marvell.com>");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_os.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_os.h
new file mode 100644
index 0000000..d4c3a00
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_os.h
@@ -0,0 +1,40 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+*******************************************************************************/
+
+#ifndef __mv_ipc_os_h
+#define __mv_ipc_os_h
+
+void *mvIpcOsGetVirtBase(unsigned int link);
+int mvIpcOsSharedStack(unsigned int link, unsigned int sh_phys_base,
+		       unsigned int sh_mem_size);
+void mvOsSync(void);
+
+void *mvIpcOsVirt2Phys(unsigned int link, void *virt_addr);
+void *mvIpcOsPhys2Virt(unsigned int link, void *phys_addr);
+
+#endif /*__mv_ipc_os_h*/
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_poll.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_poll.c
new file mode 100644
index 0000000..f8042cf
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_poll.c
@@ -0,0 +1,186 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+*******************************************************************************/
+
+#include "mvTypes.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "cpu/mvCpu.h"
+#include "mvIpc.h"
+#include "mvOs.h"
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/init.h>
+#include <linux/moduleparam.h>
+#include <asm/irq_regs.h>
+
+#include "mvDebug.h"
+#include "mvCommon.h"
+#include "mvIpc.h"
+#include "mv_ipc_poll.h"
+#include "mv_ipc_common.h"
+#include "mv_ipc_node.h"
+#include "include/mach/smp.h"
+
+/*#define IPC_DRV_DEBUG*/
+#ifdef IPC_DRV_DEBUG
+#define ipc_debug       printk
+#else
+#define ipc_debug(x ...)
+#endif
+
+static MV_U8 **enabledChannels = NULL;
+struct timer_list poll_timer;
+void do_ipc_rx_poll(unsigned long);
+
+/***********************************************************************************
+ * mvIpcPollInit
+ *
+ * DESCRIPTION:
+ *              Init the structures
+ *
+ * INPUT:
+ *		None
+ * OUTPUT:
+ *       None
+ * RETURN:
+ *		None
+ *
+ ************************************************************************************/
+MV_VOID mvIpcPollInit(MV_U32 link)
+{
+	MV_U32 firstRunFlag = 0;
+
+	if (NULL == enabledChannels) {
+		enabledChannels = mvOsMalloc(sizeof(MV_U8 *) * mvIpcGetNumOfLinks());
+		firstRunFlag = 1;
+	}
+	enabledChannels[link] = mvOsMalloc(sizeof(MV_U8) * mvIpcChnNumMax());
+	mvOsMemset(enabledChannels[link], '\0', mvIpcChnNumMax());
+
+	/*If passive polling mode, do not start timer event*/
+	if (mvIpcGetHwLayerId(link) == MV_IPC_HW_LAYER_POLLING_PASSIVE)
+		return;
+
+	/*If timer event started before, do not start timer event*/
+	if (firstRunFlag == 0)
+		return;
+
+	/*Start timer event*/
+	init_timer(&poll_timer);
+	poll_timer.function = do_ipc_rx_poll;
+	poll_timer.expires = jiffies + MV_IPC_POLL_PERIOD;
+	add_timer(&poll_timer);
+
+	/*TODO this timer mechanism working in 10ms resolution,
+	may be not good for real application*/
+
+	return;
+}
+
+/***********************************************************************************
+ * mvIpcSendTriggerPoll
+ *
+ * DESCRIPTION:
+ *              Trigger placeholder for polling mode, do nothing
+ *
+ * INPUT:
+ *		cpuId - the id of the target CPU
+ *		chnId - The channel ID
+ * OUTPUT:
+ *       None
+ * RETURN:
+ *		MV_OK or MV_ERROR
+ *
+ ************************************************************************************/
+MV_VOID mvIpcSendTriggerPoll(MV_U32 linkId, MV_U32 chnId)
+{
+	return;
+}
+
+/***********************************************************************************
+ * mvIpcEnableChnRx
+ *
+ * DESCRIPTION:
+ *		Unmasks the doorbell for the given channel
+ *
+ * INPUT:
+ *		irq - number of irq/doorbell to unmask
+ * OUTPUT:
+ *       None
+ * RETURN:
+ *		MV_OK or MV_ERROR
+ *
+ ************************************************************************************/
+MV_VOID registerChnInISRPoll(MV_U32 linkId, MV_U32 chnId, MV_BOOL enable)
+{
+	if (MV_TRUE == enable)
+		enabledChannels[linkId][chnId] = 1;
+	else
+		enabledChannels[linkId][chnId] = 0;
+}
+
+/*******************************************************************************
+ * do_ipc_rx_poll()                                                            *
+ *  rx polling service routine                                                 *
+ ******************************************************************************/
+void do_ipc_rx_poll(unsigned long data)
+{
+	MV_U32 linkId, chnId;
+	int read_msgs = IPC_RX_MAX_MSGS_PER_ISR;
+
+	ipc_debug(KERN_INFO "IPC: RX polling");
+
+	/*NOTE:
+	        This ISR may be customised by user application requerements to make it more efficient*/
+
+	/* Scan all rx flags*/
+	for (linkId = 0; linkId < mvIpcGetNumOfLinks(); linkId++) {
+		for (chnId = 0; chnId < mvIpcChnNum(linkId); chnId++) {
+			/*Check if RX flag raised*/
+			if ((enabledChannels[linkId][chnId] == 1) &&
+			    (mvIpcRxMsgFlagCheck(linkId, chnId) == MV_TRUE)) {
+				/*If ready ti RX, start get the messages*/
+				ipc_debug(KERN_INFO "Got message in channel %d\n", chnId);
+				while (read_msgs) {
+					if (mvIpcRxMsg(linkId, chnId) != MV_OK)
+						break;
+					read_msgs--;
+				}
+			}
+		}
+	}
+
+	if (read_msgs == IPC_RX_MAX_MSGS_PER_ISR)
+		ipc_debug(KERN_WARNING "IPC: Polling loop with no messages\n");
+
+	poll_timer.expires = jiffies + MV_IPC_POLL_PERIOD;
+	add_timer(&poll_timer);
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_poll.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_poll.h
new file mode 100644
index 0000000..7e804dc
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/linux_amp/mv_ipc_poll.h
@@ -0,0 +1,74 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+********************************************************************************
+   Marvell Commercial License Option
+
+   If you received this File from Marvell and you have entered into a commercial
+   license agreement (a "Commercial License") with Marvell, the File is licensed
+   to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+********************************************************************************
+   Marvell BSD License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File under the following licensing terms.
+   Redistribution and use in source and binary forms, with or without modification,
+   are permitted provided that the following conditions are met:
+
+*   Redistributions of source code must retain the above copyright notice,
+            this list of conditions and the following disclaimer.
+
+*   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+*   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+   ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+   ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#ifndef __mv_ipc_poll_h
+#define __mv_ipc_poll_h
+
+#define IPC_RX_MAX_MSGS_PER_ISR         50
+#define MV_IPC_POLL_PERIOD                      1
+
+MV_VOID mvIpcSendTriggerPoll(MV_U32 linkId, MV_U32 chnId);
+MV_VOID registerChnInISRPoll(MV_U32 linkId, MV_U32 chnId, MV_BOOL enable);
+MV_VOID mvIpcPollInit(MV_U32 linkId);
+
+#endif /*__mv_ipc_poll_h*/
\ No newline at end of file
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/mv_ipc.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/mv_ipc.c
deleted file mode 100644
index e1ab9c7..0000000
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/mv_ipc.c
+++ /dev/null
@@ -1,238 +0,0 @@
-/* This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/init.h>
-#include <linux/moduleparam.h>
-#include <asm/irq_regs.h>
-
-#include "mvTypes.h"
-#include "mvOs.h"
-#include "mvDebug.h"
-#include "mvCommon.h"
-#include "mvIpc.h"
-#include "mv_ipc.h"
-#include "ctrlEnv/mvCtrlEnvLib.h"
-#include "cpu/mvCpu.h"
-#include "include/mach/smp.h"
-
-
-extern unsigned int sh_mem_base, sh_mem_size;
-
-void   *sh_virt_base;
-void   *sh_mem_stack;
-unsigned int sh_mem_remain;
-unsigned int virt_phys_offset;
-bool   ipcInitialized = 0;
-
-MV_IPC_CHN ipc_drv_channels[MAX_IPC_CHANNELS];
-
-#define IPC_RX_MAX_MSGS_PER_ISR		50
-
-//#define IPC_DRV_DEBUG
-#ifdef IPC_DRV_DEBUG
-#define ipc_debug	printk
-#else
-#define ipc_debug(x...)
-#endif
-
-/****************************************************************************************
- * ipc_sh_malloc()                                 				        		*
- *   Allocate memory on AMP shared space
- ***************************************************************************************/
-void* ipc_sh_malloc(unsigned int size)
-{
-	void *ptr;
-
-	if(size > sh_mem_remain)
-		return NULL;
-
-	ptr = sh_mem_stack;
-
-	sh_mem_stack  += size;
-	sh_mem_remain -= size;
-
-	return ptr;
-}
-
-/****************************************************************************************
- * ipc_virt_to_phys()                                 				        		*
- *   address translation for shared stack
- ***************************************************************************************/
-void* ipc_virt_to_phys(void *virt_addr)
-{
-	void *phys_addr = 0;
-
-	if((virt_addr >= sh_virt_base) && (virt_addr < (sh_virt_base + sh_mem_size)))
-		phys_addr = (void *)((unsigned int)virt_addr - virt_phys_offset);
-
-	return phys_addr;
-}
-
-/****************************************************************************************
- * ipc_phys_to_virt()                                 				        		*
- *   address translation for shared stack
- ***************************************************************************************/
-void* ipc_phys_to_virt(void *phys_addr)
-{
-	void *virt_addr = 0;
-
-	if(((int)phys_addr >= sh_mem_base) && ((int)phys_addr < (sh_mem_base + sh_mem_size)))
-		virt_addr = (void *)((unsigned int)phys_addr + virt_phys_offset);
-
-	return virt_addr;
-}
-
-/****************************************************************************************
- * ipc_init_shared_stack()                                 				        		*
- *   Initialize the shared stack used for communication
- ***************************************************************************************/
-static int __init ipc_init_shared_stack(unsigned int sh_phys_base, unsigned int sh_mem_size,
-										unsigned int reserved, unsigned int baseIdx)
-{
-	if(sh_mem_size < reserved) {
-		printk(KERN_ERR "IPC: Shared mem size %d smaller then reserved %d\n", sh_mem_size, reserved);
-		return 0;
-	}
-
-	/* Map shared memory and initialize shared stack */
-	sh_virt_base  = ioremap(sh_phys_base, sh_mem_size);
-	if(!sh_virt_base) {
-		printk(KERN_ERR "IPC: Unable to map physical shared mem block (%#010x - %#010x)\n",
-			sh_phys_base, sh_phys_base + sh_mem_size );
-		return 0;
-	}
-
-	virt_phys_offset = (unsigned int)sh_virt_base - sh_phys_base;
-
-	/* Reserve space shared by both amp groups */
-	sh_mem_stack   = sh_virt_base + reserved;
-	sh_mem_remain  = sh_mem_size  - reserved;
-
-	/* Each group receives half of remaining memory */
-	sh_mem_stack  += ((sh_mem_remain >> 1) * baseIdx);
-	sh_mem_remain -= (sh_mem_remain >> 1);
-
-	ipc_debug(KERN_INFO "IPC: Remaped Shared memory PA %#010x to VA %#010x\n",
-	          (unsigned int) sh_phys_base, (unsigned int) sh_virt_base);
-
-	ipc_debug(KERN_INFO "IPC: Based shared stack %#010x\n", (unsigned int) sh_mem_stack);
-
-	return 1;
-}
-
-/****************************************************************************************
- * ipc_open_chn()                                 				        		*
- *   Initialize and register IPC network interface 										*
- ***************************************************************************************/
-int ipc_open_chn(int chnId, IPC_RX_CLBK rx_clbk)
-{
-	MV_STATUS ret;
-
-	ret = mvIpcOpenChannel(chnId);
-	if(ret != MV_OK)
-		return -1;
-
-	ipc_drv_channels[chnId].rxCallback = rx_clbk;
-	return 0;
-}
-
-/****************************************************************************************
- * do_ipc_rx_irq()                                 				        		*
- *  rx interrupt service routine 												*
- ***************************************************************************************/
-void do_ipc_rx_irq(int irq, struct pt_regs *regs)
-{
-	int chnId = 0;
-	MV_IPC_MSG *msg;
-	int read_msgs = IPC_RX_MAX_MSGS_PER_ISR;
-	struct pt_regs *old_regs = set_irq_regs(regs);
-
-	ipc_debug(KERN_INFO "IPC: RX callback. got irq no = %d\n", irq);
-
-	irq_enter();
-	mvIpcDisableChnRx(irq);
-
-	/* Pull msg from IPC HAL until no more msgs*/
-	while (read_msgs)
-	{
-		if(mvIpcRxMsg(&chnId, &msg, irq) == MV_FALSE)
-			break;
-
-		if(ipc_drv_channels[chnId].rxCallback != 0)
-			ipc_drv_channels[chnId].rxCallback(msg);
-
-		read_msgs--;
-	}
-
-	mvIpcEnableChnRx(irq);
-	irq_exit();
-
-	if(read_msgs == IPC_RX_MAX_MSGS_PER_ISR)
-		ipc_debug(KERN_WARNING "IPC: Received interrupt with no messages\n");
-
-	set_irq_regs(old_regs);
-}
-
-/****************************************************************************************
- * ipc_init_module()                                 				        		*
- *   intialize and register IPC driver interface 										*
- ***************************************************************************************/
-static int __init ipc_init_module(void)
-{
-	unsigned int cpuId = whoAmI();
-	MV_STATUS status;
-	int chnId;
-
-	/* Initialize shared memory - Reserve space for ipc queues */
-	ipc_init_shared_stack(sh_mem_base, sh_mem_size, MV_IPC_QUEUE_MEM, (cpuId != 0));
-
-	status = mvIpcInit(sh_virt_base, (master_cpu_id == 0));
-	if(status != MV_OK) {
-		printk(KERN_ERR "IPC: IPC HAL initialization failed\n");
-	}
-
-	/* Reset Rx callback pointers */
-	for(chnId = 0; chnId < MAX_IPC_CHANNELS; chnId++)
-		ipc_drv_channels[chnId].rxCallback = 0;
-
-	ipcInitialized = 1;
-
-	printk(KERN_INFO "IPC: Driver initialized successfully\n");
-
-	return 0;
-}
-
-/****************************************************************************************
- * ipc_cleanup_module()                                 				        	*
- *   close IPC driver 																*
- ***************************************************************************************/
-static void __exit ipc_cleanup_module(void)
-{
-	ipcInitialized = 0;
-
-	mvIpcClose();
-
-	/* Unmap shared memory space */
-	iounmap(sh_virt_base);
-}
-
-module_init(ipc_init_module);
-module_exit(ipc_cleanup_module);
-MODULE_DESCRIPTION("Marvell Inter Processor Communication (IPC) Driver");
-MODULE_AUTHOR("Yehuda Yitschak <yehuday@marvell.com>");
-MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/mv_ipc.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/mv_ipc.h
deleted file mode 100644
index 481474a..0000000
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc/mv_ipc.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/*******************************************************************************
-Copyright (C) Marvell International Ltd. and its affiliates
-
-This software file (the "File") is owned and distributed by Marvell
-International Ltd. and/or its affiliates ("Marvell") under the following
-alternative licensing terms.  Once you have made an election to distribute the
-File under one of the following license alternatives, please (i) delete this
-introductory statement regarding license alternatives, (ii) delete the two
-license alternatives that you have not elected to use and (iii) preserve the
-Marvell copyright notice above.
-
-
-********************************************************************************
-Marvell GPL License Option
-
-If you received this File from Marvell, you may opt to use, redistribute and/or
-modify this File in accordance with the terms and conditions of the General
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is
-available along with the File in the license.txt file or by writing to the Free
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
-
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
-DISCLAIMED.  The GPL License provides additional details about this warranty
-disclaimer.
-*******************************************************************************/
-
-#ifndef __MV_IPC_H__
-#define __MV_IPC_H__
-
-
-#define ipc_attach_chn(chnId, cpu, ret) 	mvIpcAttachChannel(chnId, cpu, ret)
-#define ipc_dettach_chn(chnId) 				mvIpcDettachChannel(chnId)
-#define ipc_close_chn(chnId)		 		mvIpcCloseChannel(chnId)
-#define ipc_tx_msg(chnId, msg)		 		mvIpcTxMsg(chnId, msg)
-#define ipc_tx_ready(chnId)		 			mvIpcIsTxReady(chnId)
-#define ipc_release_msg(chnId, msg)			mvIpcReleaseMsg(chnId, msg)
-
-typedef int (*IPC_RX_CLBK)(MV_IPC_MSG *msg);
-
-typedef struct __ipc_channel_info
-{
-	IPC_RX_CLBK  rxCallback;
-
-} MV_IPC_CHN;
-
-void* ipc_sh_malloc(unsigned int size);
-void* ipc_virt_to_phys(void *virt_addr);
-void* ipc_phys_to_virt(void *phys_addr);
-int ipc_open_chn(int chnId, IPC_RX_CLBK rx_clbk);
-
-#endif /* __MV_IPC_H__ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc_net/Makefile b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc_net/Makefile
index 80d5b9e..e4a97ce 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc_net/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc_net/Makefile
@@ -1,5 +1,5 @@
 #
-# Makefile for the Marvell Gigabit Ethernet driver
+# Makefile for the Marvell IPC Pseudo Network driver
 #
 ifneq ($(MACHINE),)
 include $(srctree)/$(MACHINE)/config/mvRules.mk
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc_net/ipc_net.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc_net/ipc_net.c
index 3092460..4a7c4e1 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc_net/ipc_net.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_ipc_net/ipc_net.c
@@ -28,7 +28,7 @@
 #include "mvCommon.h"
 #include "mvStack.h"
 #include "mvIpc.h"
-#include "mv_ipc/mv_ipc.h"
+#include "mv_ipc/linux_amp/mv_ipc_os.h"
 #include "cpu/mvCpu.h"
 
 //#define IPC_NET_DEBUG
@@ -38,10 +38,23 @@
 #define ipcnet_dbg(x...)
 #endif
 
+#define ipc_attach_chn(linkId, chnId, cpu, ret)		mvIpcAttachChannel(linkId, chnId, cpu, ret)
+#define ipc_dettach_chn(linkId, chnId)				mvIpcDettachChannel(linkId, chnId)
+#define ipc_close_chn(linkId, chnId)				mvIpcCloseChannel(linkId, chnId)
+#define ipc_tx_msg(linkId, chnId, msg)				mvIpcTxMsg(linkId, chnId, msg)
+#define ipc_tx_ready(linkId, chnId)					mvIpcIsTxReady(linkId, chnId)
+#define ipc_release_msg(linkId, chnId, msg)			mvIpcReleaseMsg(linkId, chnId, msg)
+#define ipc_sh_malloc(linkId, size)					mvIpcShmemMalloc(linkId, size)
+#define ipc_open_chn(linkId, chnId, rx_clbk)		mvIpcOpenChannel(linkId, chnId, rx_clbk)
+#define ipc_enable_chn_rx(linkId, chnId)			mvIpcEnableChnRx(linkId, chnId)
+#define ipc_virt_to_phys(linkId, virt_addr)			mvIpcOsVirt2Phys(linkId, virt_addr)
+#define ipc_phys_to_virt(linkId, phys_addr)			mvIpcOsPhys2Virt(linkId, phys_addr)
+
 #define IPC_NET_WRAP                (4 + ETH_HLEN + 4)
 #define IPC_NET_RX_BUF_SIZE(mtu) 	MV_ALIGN_UP(((mtu) + IPC_NET_WRAP), CPU_D_CACHE_LINE_SIZE)
-#define IPC_NET_MAX_TX_DESC			256
+#define IPC_NET_MAX_TX_DESC			32
 #define IPC_NET_MTU_SIZE			1500
+#define IPC_NET_LINK_ID				0
 #define IPC_NET_CHANNEL_ID			0
 #define IPC_NET_BUFF_USED(ptr)      (ptr)
 #define IPC_NET_ALLOC_TIME(ptr)     (ptr + 1)
@@ -70,7 +83,7 @@ struct ipc_net_device
 	struct timer_list 	watchdog_timer;
 	u32 				watchdog_timeo;
 	struct net_device_stats 	stats;
-	u32*				sh_buff_fifo[IPC_NET_MAX_TX_DESC];
+	u32					*sh_buff_fifo[IPC_NET_MAX_TX_DESC];
 	int  				next_sh_buff;
 	spinlock_t         	lock;
 	u32					target_cpu;
@@ -108,7 +121,7 @@ static void ipc_net_watchdog(unsigned long data)
 
     spin_lock(&priv->lock);
 
-	if (ipc_tx_ready(IPC_NET_CHANNEL_ID) == MV_OK) {
+	if (ipc_tx_ready(IPC_NET_LINK_ID, IPC_NET_CHANNEL_ID) == MV_OK) {
 		if (netif_queue_stopped(dev) && (dev->flags & IFF_UP))
 			netif_wake_queue(dev);
 	}
@@ -158,8 +171,8 @@ int ipc_net_stop( struct net_device *dev )
 
 	del_timer_sync(&dev->watchdog_timer);
 
-	if(mvIpcDettachChannel(IPC_NET_CHANNEL_ID) != MV_OK) {
-		printk("IPC NET: Failed to detach channel %d", IPC_NET_CHANNEL_ID);
+	if(mvIpcDettachChannel(IPC_NET_LINK_ID, IPC_NET_CHANNEL_ID) != MV_OK) {
+		printk("IPC NET: Failed to detach channel %d %d", IPC_NET_LINK_ID, IPC_NET_CHANNEL_ID);
 	}
 
 	printk(KERN_NOTICE "%s: stopped\n", dev->name);
@@ -171,7 +184,7 @@ int ipc_net_stop( struct net_device *dev )
  * ipc_net_get_buff()                                 				        		*
  *   Allocate a shared buffer from buffer pool
  ***************************************************************************************/
-static INLINE u32* ipc_net_get_buff(struct ipc_net_device *priv)
+static INLINE u32 *ipc_net_get_buff(struct ipc_net_device *priv)
 {
 	int cnt;
 	u32 used, *buff;
@@ -253,11 +266,11 @@ static int ipc_net_xmit(struct sk_buff *skb, struct net_device *dev)
 	memcpy(IPC_NET_DATA_PTR(sh_buf), skb->data, skb->len);
 
 	msg.type  = IPC_NET_SHARED_BUF;
-	msg.ptr   = ipc_virt_to_phys((void*)sh_buf);
+	msg.ptr   = ipc_virt_to_phys(0,(void*)sh_buf);
 	msg.size  = skb->len;
 	msg.value = (MV_U32)sh_buf;
 
-	status = ipc_tx_msg(IPC_NET_CHANNEL_ID, &msg);
+	status = ipc_tx_msg(IPC_NET_LINK_ID, IPC_NET_CHANNEL_ID, &msg);
 
 	priv->stats.tx_bytes += skb->len;
 	priv->stats.tx_packets++;
@@ -293,7 +306,7 @@ int ipc_net_rx(MV_IPC_MSG *msg)
 	struct ipc_net_device *priv = (struct ipc_net_device *)ipc_net_dev;
 	struct net_device *dev = priv->net_dev;
 	struct sk_buff *skb;
-	u32* ptr_virt;
+	u32 *ptr_virt;
 	u32 size;
 
 	ipcnet_dbg("Recieved msg %d, %d, 0x%08x, 0x%08x\n", msg->type, msg->size, msg->ptr, msg->value);
@@ -303,11 +316,11 @@ int ipc_net_rx(MV_IPC_MSG *msg)
 		skb = dev_alloc_skb(IPC_NET_RX_BUF_SIZE(dev->mtu));
 		if (unlikely(!skb)) {
 			printk(KERN_ERR "%s: skb alloc failure!\n", dev->name);
-			ipc_release_msg(IPC_NET_CHANNEL_ID, msg);
+			ipc_release_msg(IPC_NET_LINK_ID, IPC_NET_CHANNEL_ID, msg);
 			return MV_ERROR;
 		}
 
-		ptr_virt = (u32*)ipc_phys_to_virt(msg->ptr);
+		ptr_virt = (u32 *)ipc_phys_to_virt(0,msg->ptr);
 		if(ptr_virt == 0) {
 			printk(KERN_ERR "IPC NET: Unable to map shared buf ptr 0x%08x\n", (u32)msg->ptr);
 
@@ -322,11 +335,11 @@ int ipc_net_rx(MV_IPC_MSG *msg)
 		memcpy(skb->data, IPC_NET_DATA_PTR(ptr_virt), size);
 
 		*(IPC_NET_BUFF_USED(ptr_virt)) = 0;
-		ipc_release_msg(IPC_NET_CHANNEL_ID, msg);
+		ipc_release_msg(IPC_NET_LINK_ID, IPC_NET_CHANNEL_ID, msg);
 	}
 	else {
 		ipcnet_dbg("IPC NET: Received unknown msg type %d\n", msg->type);
-		ipc_release_msg(IPC_NET_CHANNEL_ID, msg);
+		ipc_release_msg(IPC_NET_LINK_ID, IPC_NET_CHANNEL_ID, msg);
 		return -1;
 	}
 
@@ -358,7 +371,7 @@ static void ipc_net_link_worker(struct work_struct *dummy)
 	MV_STATUS ret;
 	int attached;
 
-	ret = ipc_attach_chn(IPC_NET_CHANNEL_ID, ipc_net_dev->target_cpu, &attached);
+	ret = ipc_attach_chn(IPC_NET_LINK_ID, IPC_NET_CHANNEL_ID, ipc_net_dev->target_cpu, &attached);
 	if(ret != MV_OK){
 		printk(KERN_ERR "IPC NET: IPC attach returned error for target CPU %d\n", ipc_net_dev->target_cpu);
 		return;
@@ -420,7 +433,7 @@ static INLINE int ipc_net_init_buff_pool(struct ipc_net_device *priv, int mtu)
 	u32 *sh_mem_ptr;
 
 	for(i = 0; i < IPC_NET_MAX_TX_DESC; i++) {
-		sh_mem_ptr = (u32*)ipc_sh_malloc(IPC_NET_RX_BUF_SIZE(mtu));
+		sh_mem_ptr = (u32 *)ipc_sh_malloc(0,IPC_NET_RX_BUF_SIZE(mtu));
 		if(!sh_mem_ptr){
 			ipcnet_dbg(KERN_ERR "IPC NET: Failed to allocate shared mem of size %d\n", mtu);
 			return 0;
@@ -491,6 +504,24 @@ static int ipc_net_init(void *platform_data)
 
 	priv->target_cpu = target_cpu;
 
+	/* Initialize IPC driver */
+	printk(KERN_ERR "IPC NET:Going open chn\n");
+	do {
+		status = ipc_open_chn(IPC_NET_LINK_ID, IPC_NET_CHANNEL_ID, ipc_net_rx);
+		printk(KERN_ERR "IPC NET: open chn status %d\n", status);
+		if (status == MV_NOT_STARTED)
+			continue;
+
+		if (status != MV_OK) {
+			printk(KERN_ERR "IPC NET: Failed to open IPC channel %d %d",
+					IPC_NET_LINK_ID, IPC_NET_CHANNEL_ID);
+			goto open_fail;
+		}
+	} while (status != MV_OK);
+
+	/* Enable channel for RX */
+	ipc_enable_chn_rx(IPC_NET_LINK_ID, IPC_NET_CHANNEL_ID);
+
 	success = ipc_net_init_buff_pool(priv, dev->mtu);
 	if(!success)
 	{
@@ -498,19 +529,12 @@ static int ipc_net_init(void *platform_data)
 		goto open_fail;
 	}
 
-	/* Initialize IPC driver */
-	status = ipc_open_chn(IPC_NET_CHANNEL_ID, ipc_net_rx);
-	if(status != MV_OK) {
-		printk(KERN_ERR "IPC NET: Failed to open IPC channel %d", IPC_NET_CHANNEL_ID);
-		goto open_fail;
-	}
-
 	if (register_netdev(dev)) {
 		printk(KERN_ERR "failed to register %s\n", dev->name);
 		goto open_fail;
 	} else {
-		printk(KERN_INFO "IPC NET: Registered %s, ifindex = %d, Channel = %d, cpu = %d",
-				dev->name, dev->ifindex, IPC_NET_CHANNEL_ID, priv->target_cpu);
+		printk(KERN_INFO "IPC NET: Registered %s, ifindex = %d, Channel = %d %d, cpu = %d",
+				dev->name, dev->ifindex, IPC_NET_LINK_ID, IPC_NET_CHANNEL_ID, priv->target_cpu);
 	}
 
 	ipc_net_dev = priv;
diff --git a/tools/amp/amp_make.pl b/tools/amp/amp_make.pl
index 7f13ce2..5614462 100644
--- a/tools/amp/amp_make.pl
+++ b/tools/amp/amp_make.pl
@@ -111,6 +111,7 @@ for (; ($g_id < 2) and ($g_id >= 0); $g_id += $add)
 	}
 
 	system("cp ./arch/arm/boot/uImage $out_dir/uImage_g$g_id");
+	system("cp .config .config_g$g_id");
 	print "\nAMP: Image $g_id ready at $out_dir/uImage_g$g_id\n";
 }
 
-- 
1.7.5.4

