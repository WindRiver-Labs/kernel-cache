From 28c1f581e5b31c03386388f222c9047c73b9da9c Mon Sep 17 00:00:00 2001
From: Nadav Haklai <nadavh@marvell.com>
Date: Sun, 6 Jul 2014 13:07:11 +0300
Subject: [PATCH 1760/1825] fix: neta: ac3: Add support for missing neta ports

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 217ff4267f4115963c2ce67d93fd58159b0c2a5b

	- Add missing neta related initializations
	- Increment number of supported ports
	- Enable NETA in defconfig
	- Align NETA configurations with Armada XP

Change-Id: I9718353a26957dfed2e9f0741b8894ce27afb463
Signed-off-by: Nadav Haklai <nadavh@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/8988
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Yehuda Yitschak <yehuday@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/configs/msys_defconfig                    |    8 ++
 arch/arm/mach-msys/core.c                          |  134 ++++++++++++++++++++
 .../mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.c   |    2 +-
 3 files changed, 143 insertions(+), 1 deletions(-)

diff --git a/arch/arm/configs/msys_defconfig b/arch/arm/configs/msys_defconfig
index 81a3f1f..d8dcf3a 100644
--- a/arch/arm/configs/msys_defconfig
+++ b/arch/arm/configs/msys_defconfig
@@ -18,8 +18,16 @@ CONFIG_MODULE_UNLOAD=y
 CONFIG_PARTITION_ADVANCED=y
 CONFIG_EFI_PARTITION=y
 CONFIG_ARCH_MSYS=y
+CONFIG_MV_ETH_PORTS_NUM=2
+CONFIG_MV_ETH_RXQ=8
+CONFIG_MV_ETH_TXQ=8
+CONFIG_NET_SKB_HEADROOM=96
 CONFIG_MV_HAL_RULES_PATH="arch/arm/mach-armadaxp/mv_hal_support/mvRules.mk"
 CONFIG_MV_PMU_PROC=y
+CONFIG_MV_ETH_GRO_DEF=y
+CONFIG_MV_ETH_TSO_DEF=y
+CONFIG_MV_ETH_RX_DESC_PREFETCH=y
+CONFIG_MV_ETH_RX_PKT_PREFETCH=y
 CONFIG_MV_ETH_GROUP0_CPU=0x3
 # CONFIG_SWP_EMULATE is not set
 CONFIG_SHEEVA_ERRATA_ARM_CPU_PMU_RESET=y
diff --git a/arch/arm/mach-msys/core.c b/arch/arm/mach-msys/core.c
index 692ebcc..9f07085 100644
--- a/arch/arm/mach-msys/core.c
+++ b/arch/arm/mach-msys/core.c
@@ -119,6 +119,11 @@ static struct sys_timer msys_timer = {
 	.init = msys_timer_init,
 };
 
+#ifdef CONFIG_MV_INCLUDE_GIG_ETH
+MV_U8 mvMacAddr[MV_UBOOT_ETH_PORTS][6];
+MV_U16 mvMtu[MV_UBOOT_ETH_PORTS] = {0};
+#endif
+
 /*
  * Helpers to get DDR bank info
  */
@@ -447,6 +452,130 @@ void __init serial_initialize(int port)
 	}
 }
 
+/*******
+ * GBE *
+ *******/
+#ifdef CONFIG_MV_ETHERNET
+#if defined(CONFIG_MV_ETH_LEGACY)
+static struct platform_device mv88fx_eth = {
+	.name		= "mv88fx_eth",
+	.id		= 0,
+	.num_resources	= 0,
+};
+#endif /* CONFIG_MV_ETH_LEGACY */
+
+#if defined(CONFIG_MV_ETH_NETA) || defined(CONFIG_MV_ETH_NETA_MODULE)
+static void mv_neta_giga_pdev_register(struct platform_device *pdev)
+{
+	struct mv_neta_pdata *plat_data = (struct mv_neta_pdata *)pdev->dev.platform_data;
+	int speed, port = pdev->id;
+
+	/* Global Parameters */
+	plat_data->ctrl_model = mvCtrlModelGet();
+	plat_data->ctrl_rev = mvCtrlRevGet();
+	plat_data->pclk = mvCpuPclkGet();
+	plat_data->tclk = mvBoardTclkGet();
+	plat_data->max_port = mvCtrlEthMaxPortGet();
+	plat_data->max_cpu = mvCtrlEthMaxCPUsGet();
+	/* Per port parameters */
+	plat_data->cpu_mask  = (1 << nr_cpu_ids) - 1;
+	plat_data->phy_addr = mvBoardPhyAddrGet(port);
+	plat_data->tx_csum_limit = MV_ETH_TX_CSUM_MAX_SIZE;
+	plat_data->is_sgmii = mvBoardIsPortInSgmii(port);
+	plat_data->is_rgmii = mvBoardIsPortInRgmii(port);
+	plat_data->duplex = DUPLEX_FULL;
+
+	if (port < MV_UBOOT_ETH_PORTS) {
+		plat_data->mtu = mvMtu[port];
+		if (plat_data->mtu == 0)
+			plat_data->mtu = 1500;
+		memcpy(plat_data->mac_addr, mvMacAddr[port], 6);
+		if (is_zero_ether_addr(plat_data->mac_addr))
+			pr_warning("Warning: port #%d - zero MAC address\n", port);
+	} else {
+		plat_data->mtu = 1500;
+		memset(plat_data->mac_addr, 0, 6);
+	}
+	speed = mvBoardMacSpeedGet(port);
+	switch (speed) {
+	case BOARD_MAC_SPEED_10M:
+		plat_data->speed = SPEED_10;
+		break;
+	case BOARD_MAC_SPEED_100M:
+		plat_data->speed = SPEED_100;
+		break;
+	case BOARD_MAC_SPEED_1000M:
+		plat_data->speed = SPEED_1000;
+		break;
+	case BOARD_MAC_SPEED_AUTO:
+	default:
+		plat_data->speed = 0;
+		break;
+	}
+	pr_info("Register platform device: %s_%d\n", pdev->name, pdev->id);
+	platform_device_register(pdev);
+}
+static struct resource mv_neta_ge0_resources[] = {
+	{
+		.start          = IRQ_AURORA_GBE0_FIC,
+		.end            = IRQ_AURORA_GBE0_FIC,
+		.flags          = IORESOURCE_IRQ,
+	},
+};
+static struct mv_neta_pdata mv_neta_ge0_pdata = {
+	.mtu = 1500,
+	.phy_addr = 0,
+};
+static struct platform_device mv_neta_ge0_plat = {
+	.name           = MV_NETA_PORT_NAME,
+	.id		= 0,
+	.num_resources  = ARRAY_SIZE(mv_neta_ge0_resources),
+	.resource       = mv_neta_ge0_resources,
+	.dev            = {
+		.platform_data = &mv_neta_ge0_pdata,
+	},
+};
+static struct resource mv_neta_ge1_resources[] = {
+	{
+		.start          = IRQ_AURORA_GBE1_FIC,
+		.end            = IRQ_AURORA_GBE1_FIC,
+		.flags          = IORESOURCE_IRQ,
+	},
+};
+static struct mv_neta_pdata mv_neta_ge1_pdata = {
+	.mtu = 1500,
+	.phy_addr = -1,
+};
+static struct platform_device mv_neta_ge1_plat = {
+	.name           = MV_NETA_PORT_NAME,
+	.id             = 1,
+	.num_resources  = ARRAY_SIZE(mv_neta_ge1_resources),
+	.resource       = mv_neta_ge1_resources,
+	.dev            = {
+		.platform_data = &mv_neta_ge1_pdata,
+	},
+};
+#endif /* CONFIG_MV_ETH_NETA || CONFIG_MV_ETH_NETA_MODULE */
+
+static void __init eth_init(void)
+{
+#if defined(CONFIG_MV_ETH_LEGACY)
+	platform_device_register(&mv88fx_eth);
+#endif /* CONFIG_MV_ETH_LEGACY */
+
+#if defined(CONFIG_MV_ETH_NETA) || defined(CONFIG_MV_ETH_NETA_MODULE)
+	if ((mvUnitMapIsMine(ETH0) == MV_TRUE) &&
+		(mvCtrlPwrClckGet(ETH_GIG_UNIT_ID, 0))) {
+		mv_neta_giga_pdev_register(&mv_neta_ge0_plat);
+	}
+	if ((mvUnitMapIsMine(ETH1) == MV_TRUE) &&
+		(mvCtrlPwrClckGet(ETH_GIG_UNIT_ID, 1))) {
+		mv_neta_giga_pdev_register(&mv_neta_ge1_plat);
+	}
+#endif /* CONFIG_MV_ETH_NETA) || CONFIG_MV_ETH_NETA_MODULE */
+}
+#endif /* CONFIG_MV_ETHERNET */
+
 
 /************
  * GPIO
@@ -899,6 +1028,11 @@ static void __init msys_bc2_rd_init(void)
 	msys_sdio_init();
 #endif
 
+#ifdef CONFIG_MV_ETHERNET
+	/* Ethernet */
+	eth_init();
+#endif
+
 	/* NAND */
 #ifdef CONFIG_MTD_NAND_NFC
 	msys_db_nfc_init();
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.c b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.c
index 828c1d0..7c71f5e 100644
--- a/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.c
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.c
@@ -104,7 +104,7 @@ MV_UNIT_ID mvCtrlSocUnitNums[MAX_UNITS_ID][MV_MSYS_INDEX_MAX] = {
 /*			    BC2		AC3 */
 /* DRAM_UNIT_ID         */ { 1,		1, },
 /* PEX_UNIT_ID          */ { 1,		1, },
-/* ETH_GIG_UNIT_ID      */ { 2,		1, },
+/* ETH_GIG_UNIT_ID      */ { 2,		2, },
 /* XOR_UNIT_ID          */ { 1,		1, },
 /* UART_UNIT_ID         */ { 2,		2, },
 /* SPI_UNIT_ID          */ { 2,		1, },
-- 
1.7.5.4

