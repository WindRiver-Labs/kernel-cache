From 47764ee2d725383f109fd3431abfe2ec46907a39 Mon Sep 17 00:00:00 2001
From: Yosi <tyosi@marvell.com>
Date: Sun, 11 May 2014 16:34:05 +0300
Subject: [PATCH 1651/1825] hwmon: alp: enabled thermal sensor on ALP

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 781817861bd6ee14cb147cba02c3fd568999291b

	Added support for Thermal Sensor in ALP
	Removed option for minimum temperature threshold since it is not supported.
	Setting maximum temperature threshold is not supported, since it requires information from HW.

Change-Id: I7e72e0a4d1b547f87bfc04ead2e1babc45afc69a
Signed-off-by: Yosi <tyosi@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/7932
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Shadi Ammouri <shadi@marvell.com>
Reviewed-by: Hanna Hawa <hannah@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/configs/avanta_lp_defconfig |    1 -
 arch/arm/mach-avantalp/core.c        |    2 -
 arch/arm/mach-avantalp/hwmon.c       |  164 ++++++++++++----------------------
 3 files changed, 59 insertions(+), 108 deletions(-)

diff --git a/arch/arm/configs/avanta_lp_defconfig b/arch/arm/configs/avanta_lp_defconfig
index 9a0cfd1..376c2c5 100644
--- a/arch/arm/configs/avanta_lp_defconfig
+++ b/arch/arm/configs/avanta_lp_defconfig
@@ -118,7 +118,6 @@ CONFIG_I2C_CHARDEV=y
 CONFIG_I2C_MV64XXX=y
 CONFIG_SPI=y
 CONFIG_GPIO_SYSFS=y
-# CONFIG_HWMON is not set
 CONFIG_WATCHDOG=y
 CONFIG_ORION_WATCHDOG=y
 CONFIG_SOUND=y
diff --git a/arch/arm/mach-avantalp/core.c b/arch/arm/mach-avantalp/core.c
index dcf13ef..b5dd259 100644
--- a/arch/arm/mach-avantalp/core.c
+++ b/arch/arm/mach-avantalp/core.c
@@ -1845,10 +1845,8 @@ static void __init alp_board_init(void)
 	alp_wdt_init();
 	if (mvCtrlRevGet() > MV_88F66X0_Z3_ID)
 		alp_dragonite_init();
-#if 0
 	alp_hwmon_init();
 #endif
-#endif
 }
 
 static void board_restart(char mode, const char *cmd)
diff --git a/arch/arm/mach-avantalp/hwmon.c b/arch/arm/mach-avantalp/hwmon.c
index 5d3e62c..5c39435 100644
--- a/arch/arm/mach-avantalp/hwmon.c
+++ b/arch/arm/mach-avantalp/hwmon.c
@@ -27,26 +27,26 @@
 #include <asm/io.h>
 #include <linux/slab.h>
 #include <linux/interrupt.h>
+#include <linux/delay.h>
 
 /* Termal Sensor Registers */
-#define TSEN_STATUS_REG				0x184C4
-#define	TSEN_STATUS_TEMP_OUT_OFFSET		1
-#define	TSEN_STATUS_TEMP_OUT_MASK		(0x1FF << TSEN_STATUS_TEMP_OUT_OFFSET)
-
-#define TSEN_CONF_REG				0x184D0
-#define	TSEN_CONF_OTF_CALIB_MASK		(0x1 << 30)
-#define	TSEN_CONF_START_CALIB_MASK		(0x1 << 25)
-#define	TSEN_CONF_REF_CAL_MASK			(0x1FF << 11)
-#define	TSEN_CONF_SOFT_RESET_MASK		(0x1 << 1)
+#define TSEN_STATUS_REG				0xE8078
+#define	TSEN_STATUS_TEMP_OUT_MASK		0x1FF
+#define	TSEN_STATUS_TEMP_VALID_MASK		0x400
+
+#define TSEN_CONT_MSB_REG			0xE8080
+#define TSEN_CONT_MSB_UNIT_CTRL_OFFSET		27
+#define TSEN_CONT_MSB_UNIT_CTRL_MASK		(0x7 << TSEN_CONT_MSB_UNIT_CTRL_OFFSET)
+#define TSEN_CONT_MSB_READOUT_INVERT_OFFSET	15
+#define TSEN_CONT_MSB_READOUT_INVERT_MASK	(0x1 << TSEN_CONT_MSB_READOUT_INVERT_OFFSET)
+#define TSEN_CONT_MSB_DISABLE_RST_OFFSET	8
+#define TSEN_CONT_MSB_DISABLE_RST_MASK		(0x1 << TSEN_CONT_MSB_DISABLE_RST_OFFSET)
 
 #define ALP_OVERHEAT_TEMP	105		/* milidegree Celsius */
 #define ALP_OVERHEAT_DELAY	0x700
-#define ALP_OVERCOOL_TEMP	10		/* milidegree Celsius */
-#define	ALP_OVERCOOL_DELAY	0x700
 #define ALP_OVERHEAT_MIN	0
 #define ALP_OVERHEAT_MAX	110000
-#define ALP_OVERCOOL_MIN	0
-#define ALP_OVERCOOL_MAX	110000
+
 #define PMU_THERMAL_MNGR_REG	0x184c4
 #define	PMU_INT_MASK_REG        0x1C124
 #define	PMU_INT_CAUSE_REG	0x1c120
@@ -66,23 +66,21 @@
 #define	PMU_TM_COOLING_DLY_REG	0x184c8
 
 /* Junction Temperature */
-#define ALP_TSEN_TEMP2RAW(x) ((3153000 - (13825 * x)) / 10000)
-#define ALP_TSEN_RAW2TEMP(x) ((3153000 - (10000 * x)) / 13825)
+#define ALP_TSEN_TEMP2RAW(x) ((3239600 - (13616 * x)) / 10000)
+#define ALP_TSEN_RAW2TEMP(x) ((3239600 - (10000 * x)) / 13616)
 
 #define LABEL "T-junction"
 static struct device *hwmon_dev;
-unsigned int temp_min = ALP_OVERCOOL_TEMP;
 unsigned int temp_max = ALP_OVERHEAT_TEMP;
 
 typedef enum {
 	SHOW_TEMP,
 	TEMP_MAX,
-	TEMP_MIN,
 	SHOW_NAME,
 	SHOW_TYPE,
 	SHOW_LABEL } SHOW;
 
-static void alp_temp_set_thresholds(unsigned int max, unsigned int min)
+static void alp_temp_set_thresholds(unsigned int max)
 {
 	u32 temp, reg;
 
@@ -96,61 +94,32 @@ static void alp_temp_set_thresholds(unsigned int max, unsigned int min)
 	reg &= ~PMU_TM_OVRHEAT_THRSH_MASK;
 	reg |= (temp << PMU_TM_OVRHEAT_THRSH_OFFS);
 	writel(reg, (INTER_REGS_VIRT_BASE | PMU_THERMAL_MNGR_REG));
-
-	/* Set the cool threshole & delay */
-	temp = ALP_TSEN_TEMP2RAW(min);
-	reg = readl(INTER_REGS_VIRT_BASE | PMU_THERMAL_MNGR_REG);
-	reg &= ~PMU_TM_COOL_THRSH_MASK;
-	reg |= (temp << PMU_TM_COOL_THRSH_OFFS);
-	writel(reg, (INTER_REGS_VIRT_BASE | PMU_THERMAL_MNGR_REG));
 }
 
 static int alp_temp_init_sensor(void)
 {
 	u32 reg;
 
-	/* init the TSEN sensor once */
-	/* Enable On-The-Fly Calibration mode */
-	reg = readl(INTER_REGS_VIRT_BASE | TSEN_CONF_REG);
-	reg |= TSEN_CONF_OTF_CALIB_MASK;
-	writel(reg, (INTER_REGS_VIRT_BASE | TSEN_CONF_REG));
-
-	/* Set the Reference Count value */
-	reg = readl(INTER_REGS_VIRT_BASE | TSEN_CONF_REG);
-	reg &= ~(TSEN_CONF_REF_CAL_MASK);
-	reg |= (0xf1 << 11);
-	writel(reg, (INTER_REGS_VIRT_BASE | TSEN_CONF_REG));
-
-	/* Do not start calibration sequence */
-	reg = readl(INTER_REGS_VIRT_BASE | TSEN_CONF_REG);
-	reg &= ~(TSEN_CONF_START_CALIB_MASK);
-	writel(reg, (INTER_REGS_VIRT_BASE | TSEN_CONF_REG));
-
-	/* Initiate Soft Reset
-	reg = readl(INTER_REGS_VIRT_BASE | TSEN_CONF_REG);
-	reg |= TSEN_CONF_SOFT_RESET_MASK;
-	writel(reg, (INTER_REGS_VIRT_BASE | TSEN_CONF_REG));
-	*/
-	//udelay(1000);
-
-	/* Exit from Soft Reset
-	reg = readl(INTER_REGS_VIRT_BASE | TSEN_CONF_REG);
-	reg &= ~(TSEN_CONF_SOFT_RESET_MASK);
-	writel(reg, (INTER_REGS_VIRT_BASE | TSEN_CONF_REG));
-	*/
-	//udelay(10000);
-
-
-	/* Set thresholds */
-	alp_temp_set_thresholds(temp_max, temp_min);
-
-	/* Set delays */
-	writel(ALP_OVERHEAT_DELAY, (INTER_REGS_VIRT_BASE | PMU_TM_OVRHEAT_DLY_REG));
-	writel(ALP_OVERCOOL_DELAY, (INTER_REGS_VIRT_BASE | PMU_TM_COOLING_DLY_REG));
-
-	/* Clear & unmask cooling/overheat interrupts */
-	writel(0, (INTER_REGS_VIRT_BASE | PMU_INT_CAUSE_REG));
-	writel((PMU_INT_OVRHEAT_MASK | PMU_INT_COOLING_MASK), (INTER_REGS_VIRT_BASE | PMU_INT_MASK_REG));
+	/* Set Temp sensor 0 to read */
+	reg = readl(INTER_REGS_VIRT_BASE | TSEN_CONT_MSB_REG);
+	reg &= ~TSEN_CONT_MSB_UNIT_CTRL_MASK;
+	reg |= (0x0 << TSEN_CONT_MSB_UNIT_CTRL_OFFSET);
+
+	/* Disable readout invert */
+	reg &= ~TSEN_CONT_MSB_READOUT_INVERT_MASK;
+	reg |= (0x0 << TSEN_CONT_MSB_READOUT_INVERT_OFFSET);
+
+	/* Disable reset */
+	reg &= ~TSEN_CONT_MSB_DISABLE_RST_MASK;
+	reg |= (0x0 << TSEN_CONT_MSB_DISABLE_RST_OFFSET);
+	writel(reg, (INTER_REGS_VIRT_BASE | TSEN_CONT_MSB_REG));
+
+	udelay(20);
+
+	/* Enable reset */
+	reg &= ~TSEN_CONT_MSB_DISABLE_RST_MASK;
+	reg |= (0x1 << TSEN_CONT_MSB_DISABLE_RST_OFFSET);
+	writel(reg, (INTER_REGS_VIRT_BASE | TSEN_CONT_MSB_REG));
 
 	return 0;
 }
@@ -158,9 +127,21 @@ static int alp_temp_init_sensor(void)
 static int alp_temp_read_temp(void)
 {
 	int reg;
+	int timeOut = 0;
+
+	/* Wait for temperature reading to be valid */
+	do {
+		reg = readl(INTER_REGS_VIRT_BASE | TSEN_STATUS_REG);
+		udelay(20);
+		timeOut++;
+		if (timeOut > 1000)
+			return 0;
+
+	} while (!(reg & TSEN_STATUS_TEMP_VALID_MASK));
+
+	/* calculate the temperature */
+	reg = reg & TSEN_STATUS_TEMP_OUT_MASK;
 
-	reg = readl(INTER_REGS_VIRT_BASE | TSEN_STATUS_REG);
-	reg = (reg & TSEN_STATUS_TEMP_OUT_MASK) >> TSEN_STATUS_TEMP_OUT_OFFSET;
 	return ALP_TSEN_RAW2TEMP(reg);
 }
 
@@ -186,11 +167,6 @@ static ssize_t show_alarm(struct device *dev, struct device_attribute
 		alarm = 1;
 		writel ((reg & ~PMU_INT_OVRHEAT_MASK), (INTER_REGS_VIRT_BASE | PMU_INT_CAUSE_REG));
 	}
-	else if (reg & PMU_INT_COOLING_MASK)
-	{
-		alarm = 2;
-		writel ((reg & ~PMU_INT_COOLING_MASK), (INTER_REGS_VIRT_BASE | PMU_INT_CAUSE_REG));
-	}
 
 	return sprintf(buf, "%d\n", alarm);
 }
@@ -215,11 +191,9 @@ static ssize_t show_temp(struct device *dev,
 	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
 
 	if (attr->index == SHOW_TEMP)
-		ret = sprintf(buf, "%d \n", alp_temp_read_temp());
+		ret = sprintf(buf, "%d\n", alp_temp_read_temp());
 	else if (attr->index == TEMP_MAX)
 		ret = sprintf(buf, "%d\n", temp_max);
-	else if (attr->index == TEMP_MIN)
-		ret = sprintf(buf, "%d\n", temp_min);
 	else
 		ret = sprintf(buf, "%d\n", -1);
 
@@ -236,29 +210,20 @@ static ssize_t set_temp(struct device *dev, struct device_attribute *devattr,
 		printk(KERN_WARNING "Invalid input string for temperature!");
 
 	if (attr->index == TEMP_MAX) {
-		if((temp < ALP_OVERHEAT_MIN) || (temp > ALP_OVERHEAT_MAX))
+		if (temp > ALP_OVERHEAT_MAX)
 			printk(KERN_WARNING "Invalid max temperature input (out of range: %d-%d)!",
 				ALP_OVERHEAT_MIN, ALP_OVERHEAT_MAX);
 		else {
 			temp_max = temp;
-			alp_temp_set_thresholds(temp_max, temp_min);
-		}
-	}
-	else if (attr->index == TEMP_MIN) {
-		if((temp < ALP_OVERCOOL_MIN) || (temp > ALP_OVERCOOL_MAX))
-			printk(KERN_WARNING "Invalid min temperature input (out of range: %d-%d)!",
-				ALP_OVERCOOL_MIN, ALP_OVERCOOL_MAX);
-		else {
-			temp_min = temp;
-			alp_temp_set_thresholds(temp_max, temp_min);
+			alp_temp_set_thresholds(temp_max);
 		}
 	}
 	else
 		printk(KERN_ERR "alp-temp: Invalid sensor attribute!");
 
-	/* Clear & unmask cooling/overheat interrupts */
+	/* Clear & unmask overheat interrupts */
 	writel (0, (INTER_REGS_VIRT_BASE | PMU_INT_CAUSE_REG));
-	writel((PMU_INT_OVRHEAT_MASK | PMU_INT_COOLING_MASK), (INTER_REGS_VIRT_BASE | PMU_INT_MASK_REG));
+	writel(PMU_INT_OVRHEAT_MASK, (INTER_REGS_VIRT_BASE | PMU_INT_MASK_REG));
 
 	printk(KERN_INFO "set_temp got string: %d\n", temp);
 	return count;
@@ -269,7 +234,7 @@ static irqreturn_t alp_temp_irq_handler(int irq, void *data)
 	u32 val, mask;
 	mask = readl(INTER_REGS_VIRT_BASE | PMU_INT_MASK_REG);
 	val = (readl(INTER_REGS_VIRT_BASE | PMU_INT_CAUSE_REG) & mask);
-	/* Mask cooling/overheat interrupt */
+	/* Mask overheat interrupt */
 	writel((mask & ~val), (INTER_REGS_VIRT_BASE | PMU_INT_MASK_REG));
 
 	printk(KERN_WARNING "WARNING: %s threshold was triggered\n",
@@ -277,8 +242,6 @@ static irqreturn_t alp_temp_irq_handler(int irq, void *data)
 
 	if (val & PMU_INT_OVRHEAT_MASK)
 		val &= ~PMU_INT_OVRHEAT_MASK;
-	else if (val & PMU_INT_COOLING_MASK)
-		val &= ~PMU_INT_COOLING_MASK;
 
 	/* Clear cooling/overheat interrupt */
 	writel(val, (INTER_REGS_VIRT_BASE | PMU_INT_CAUSE_REG));
@@ -286,7 +249,7 @@ static irqreturn_t alp_temp_irq_handler(int irq, void *data)
 	return IRQ_HANDLED;
 }
 
-/* TODO - Add read/write support in order to support setting max/min */
+/* TODO - Add read/write support in order to support setting max */
 static SENSOR_DEVICE_ATTR(temp1_type, S_IRUGO, show_info, NULL,
 			  SHOW_TYPE);
 static SENSOR_DEVICE_ATTR(temp1_label, S_IRUGO, show_info, NULL,
@@ -295,8 +258,6 @@ static SENSOR_DEVICE_ATTR(temp1_input, S_IRUGO, show_temp, NULL,
 			  SHOW_TEMP);
 static SENSOR_DEVICE_ATTR(temp1_max, S_IRWXUGO, show_temp, set_temp,
 			  TEMP_MAX);
-static SENSOR_DEVICE_ATTR(temp1_min, S_IRWXUGO, show_temp, set_temp,
-			  TEMP_MIN);
 static DEVICE_ATTR(temp1_crit_alarm, S_IRUGO, show_alarm, NULL);
 static SENSOR_DEVICE_ATTR(name, S_IRUGO, show_name, NULL, SHOW_NAME);
 
@@ -305,7 +266,6 @@ static struct attribute *alp_temp_attributes[] = {
 	&dev_attr_temp1_crit_alarm.attr,
 	&sensor_dev_attr_temp1_input.dev_attr.attr,
 	&sensor_dev_attr_temp1_max.dev_attr.attr,
-	&sensor_dev_attr_temp1_min.dev_attr.attr,
 	&sensor_dev_attr_temp1_type.dev_attr.attr,
 	&sensor_dev_attr_temp1_label.dev_attr.attr,
 	NULL
@@ -317,7 +277,7 @@ static const struct attribute_group alp_temp_group = {
 
 static int __devinit alp_temp_probe(struct platform_device *pdev)
 {
-	int err, irq;
+	int err;
 
 	err = alp_temp_init_sensor();
 	if (err)
@@ -333,16 +293,10 @@ static int __devinit alp_temp_probe(struct platform_device *pdev)
 			err);
 		goto exit;
 	}
-
-	/* Register cooling/overheat interrupt */
-	irq = IRQ_AURORA_PMU;
-	err = request_irq(irq, alp_temp_irq_handler, IRQF_DISABLED ,
-				"alp-temp", NULL);
-	if (err)
-		printk(KERN_INFO "unable to request IRQ%d for alp-temp\n", irq);
 	printk(KERN_INFO "Avanta LP hwmon thermal sensor initialized.\n");
 
 	return 0;
+
 exit:
 	sysfs_remove_group(&pdev->dev.kobj, &alp_temp_group);
 	return err;
-- 
1.7.5.4

