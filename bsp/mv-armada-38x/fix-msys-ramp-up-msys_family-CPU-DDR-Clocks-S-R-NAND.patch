From a95b16228960a90eee986c9dfe2b63ab266b0aef Mon Sep 17 00:00:00 2001
From: Omri Itach <omrii@marvell.com>
Date: Tue, 7 Jan 2014 17:39:04 +0200
Subject: [PATCH 1275/1825] fix: msys: ramp up msys_family (CPU/DDR Clocks,
 S@R, NAND ECC, etc...)

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 2020d0bd588ce4497c29a8631e12bc9443c4919f

	Added:
	- mvBoardIsPortInMii - needed for NETA usage
	- mvCpuDdrClkGet - Read DDR BUS clock
	- NAND SoC configuration (NAND PUP / NfArbiterEn/ NAND MUX)

	Fixed:
	- mvCtrlNandClkSet - fixed ECC divider register offsets and field masks
	- mvCpuPclkGet - read correct CPU/DDR clocks, instead of Switch Core Clock
	- mvBoardTclkGet - use fixed Tclk of 200Mhz
	- mvBoardIdGet   - use fixed DB_98DX4251_BP_ID (TWSI errors)
	- Added error handling (STATUS returned) to S@R routines:
	- mvBoardCoreFreqGet, mvBoardCpuFreqGet, mvBoardTmFreqGet, mvBoardBootDevGet

Change-Id: I7046ec4cb57b6599572b8e333e064197aea45d02
Signed-off-by: Omri Itach <omrii@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/5044
Reviewed-by: Eli Nidam <elini@marvell.com>
Tested-by: Star_Automation <star@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../mach-msys/msys_family/boardEnv/mvBoardEnvLib.c |   59 +++++++++++++------
 .../mach-msys/msys_family/boardEnv/mvBoardEnvLib.h |    9 ++-
 .../msys_family/boardEnv/mvBoardEnvSpec.h          |    5 +-
 arch/arm/mach-msys/msys_family/cpu/mvCpu.c         |   40 +++++++++++--
 arch/arm/mach-msys/msys_family/cpu/mvCpu.h         |    1 +
 .../mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.c   |   30 +++++++---
 .../mach-msys/msys_family/ctrlEnv/mvCtrlEnvRegs.h  |   18 +++---
 7 files changed, 114 insertions(+), 48 deletions(-)

diff --git a/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvLib.c b/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvLib.c
index 92dc1ef..a7ced52 100644
--- a/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvLib.c
+++ b/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvLib.c
@@ -338,6 +338,29 @@ MV_BOOL mvBoardIsPortInGmii(MV_U32 ethPortNum)
 {
 	return MV_FALSE;
 }
+
+/*******************************************************************************
+* mvBoardIsPortInMii
+*
+* DESCRIPTION:
+*	This routine returns MV_TRUE for port number works in MII or MV_FALSE
+*	For all other options.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE - port in MII.
+*       MV_FALSE - other.
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsPortInMii(MV_U32 ethPortNum)
+{
+	return MV_FALSE;
+}
 /*******************************************************************************
 * mvBoardSwitchCpuPortGet - Get the the Ethernet Switch CPU port
 *
@@ -515,14 +538,8 @@ MV_U32 freq_tbl[] = {
 
 MV_U32 mvBoardTclkGet(MV_VOID)
 {
-	MV_U32  freq;
-
-	freq = MSAR_CORE_CLK(0, MV_DFX_REG_READ(DFX_DEVICE_SAR_REG(1)));
-	printf("%s: Core Clock from DFX S@R register = 0x%x\n", __func__, freq);
-	printf("%s: Using Hard-coded value instead from freq_tbl[2] = TClock @ 200 [MHz]\n", __func__);
-
-	return freq_tbl[2];
-
+	/* Tclock is constant at 200MHz (not sampled @ reset)  */
+	return 200000000;
 }
 
 /*******************************************************************************
@@ -1190,9 +1207,9 @@ MV_U32 mvBoardIdGet(MV_VOID)
 	MV_U8 boardId;
 
 	if (count++ < 0)
-		printf("%s: TODO fix read from TWSI of boardID (using hard-coded value RD_98DX4051_ID)\n", __func__);
+		printf("%s: TODO fix read from TWSI of boardID (using hard-coded value DB_98DX4251_BP_ID)\n", __func__);
 
-	return RD_98DX4051_ID;
+	return DB_98DX4251_BP_ID;
 
 	if (gBoardId == -1) {
 		if (MV_ERROR == mvBoardTwsiRead(BOARD_DEV_TWSI_PLD, 1, 0, &boardId)) {
@@ -1354,8 +1371,7 @@ MV_STATUS mvBoardTwsiSatRSet(MV_U8 satrIndex, MV_U8 devNum, MV_U8 regNum, MV_U8
 /*******************************************************************************
 * SatR Configuration functions
 *******************************************************************************/
-//MV_U8 mvBoardFabFreqGet(MV_VOID)
-MV_U8 mvBoardCoreFreqGet(MV_VOID)
+MV_STATUS mvBoardCoreFreqGet(MV_U8 *value)
 {
 	MV_U8 sar0;
 	MV_STATUS rc1;
@@ -1364,7 +1380,8 @@ MV_U8 mvBoardCoreFreqGet(MV_VOID)
 	if (MV_ERROR == rc1)
 		return MV_ERROR;
 
-	return ( sar0 & 0x7);
+	*value = sar0 & 0x7;
+	return MV_OK;
 }
 
 /*******************************************************************************/
@@ -1390,7 +1407,7 @@ MV_STATUS mvBoardCoreFreqSet(MV_U8 freqVal)
 	return MV_OK;
 }
 /*******************************************************************************/
-MV_U8 mvBoardCpuFreqGet(MV_VOID)
+MV_STATUS mvBoardCpuFreqGet(MV_U8 *value)
 {
 	MV_U8 sar1, sar2;
 	MV_STATUS rc1;
@@ -1401,7 +1418,8 @@ MV_U8 mvBoardCpuFreqGet(MV_VOID)
 	if ((MV_ERROR == rc1) || (MV_ERROR == rc2))
 		return MV_ERROR;
 
-	return ((((sar2 & 0x1)) << 3) | ((sar1 & 0x18) >> 3));
+	*value = ((((sar2 & 0x1)) << 3) | ((sar1 & 0x18) >> 3));
+	return MV_OK;
 }
 
 /*******************************************************************************/
@@ -1433,7 +1451,7 @@ MV_STATUS mvBoardCpuFreqSet(MV_U8 freqVal)
 }
 
 /*******************************************************************************/
-MV_U8 mvBoardTmFreqGet(MV_VOID)
+MV_STATUS mvBoardTmFreqGet(MV_U8 *value)
 {
 	MV_U8 sar2;
 	MV_STATUS rc2;
@@ -1442,7 +1460,8 @@ MV_U8 mvBoardTmFreqGet(MV_VOID)
 	if (MV_ERROR == rc2)
 		return MV_ERROR;
 
-	return ((sar2 & 0x0E) >> 1);
+	*value = ((sar2 & 0x0E) >> 1);
+	return MV_OK;
 }
 
 /*******************************************************************************/
@@ -1466,7 +1485,7 @@ MV_STATUS mvBoardTmFreqSet(MV_U8 freqVal)
 }
 
 /*******************************************************************************/
-MV_U8 mvBoardBootDevGet(MV_VOID)
+MV_STATUS mvBoardBootDevGet(MV_U8 *value)
 {
 	MV_U8 sar;
 	MV_STATUS rc;
@@ -1475,8 +1494,10 @@ MV_U8 mvBoardBootDevGet(MV_VOID)
 	if (MV_ERROR == rc)
 		return MV_ERROR;
 
-	return (sar & 0x7);
+	*value = (sar & 0x7);
+	return MV_OK;
 }
+
 /*******************************************************************************/
 MV_STATUS mvBoardBootDevSet(MV_U8 val)
 {
diff --git a/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvLib.h b/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvLib.h
index c010162..1031ec1 100644
--- a/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvLib.h
+++ b/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvLib.h
@@ -261,6 +261,7 @@ MV_BOOL mvBoardIsEthConnected(MV_U32 ethNum);
 MV_BOOL mvBoardIsEthActive(MV_U32 ethNum);
 MV_BOOL mvBoardIsPortInSgmii(MV_U32 ethPortNum);
 MV_BOOL mvBoardIsPortInGmii(MV_U32 ethPortNum);
+MV_BOOL mvBoardIsPortInMii(MV_U32 ethPortNum);
 MV_BOOL mvBoardIsPortInRgmii(MV_U32 ethPortNum);
 MV_32 mvBoardPhyAddrGet(MV_U32 ethPortNum);
 
@@ -294,11 +295,11 @@ MV_U32 mvBoardSledCpuNumGet(MV_VOID);
 MV_STATUS mvBoardTwsiRead(MV_BOARD_TWSI_CLASS class1, MV_U8 devNum, MV_U8 regNum, MV_U8 *pData);
 MV_STATUS mvBoardTwsiSatRGet(MV_U8 satrIndex, MV_U8 devNum, MV_U8 regNum, MV_U8 *pData);
 MV_STATUS mvBoardTwsiSatRSet(MV_U8 satrIndex, MV_U8 devNum, MV_U8 regNum, MV_U8 regVal);
-MV_U8 mvBoardCpuFreqGet(MV_VOID);
+MV_STATUS mvBoardCpuFreqGet(MV_U8 *value);
 MV_STATUS mvBoardCpuFreqSet(MV_U8 freqVal);
 MV_U8 mvBoardCpuFreqModeGet(MV_VOID);
 MV_STATUS mvBoardCpuFreqModeSet(MV_U8 freqVal);
-MV_U8 mvBoardBootDevGet(MV_VOID);
+MV_STATUS mvBoardBootDevGet(MV_U8 *value);
 MV_STATUS mvBoardBootDevSet(MV_U8 val);
 MV_U8 mvBoardCpuCoresNumGet(MV_VOID);
 MV_STATUS mvBoardCpuCoresNumSet(MV_U8 val);
@@ -306,8 +307,8 @@ MV_STATUS mvBoardConIdSet(MV_U16 conf);
 MV_U16 mvBoardConfIdGet(MV_VOID);
 MV_STATUS mvBoardDramBusWidthSet(MV_U16 conf);
 MV_U16 mvBoardDramBusWidthGet(MV_VOID);
-MV_U8 mvBoardCoreFreqGet(MV_VOID);
-MV_U8 mvBoardTmFreqGet(MV_VOID);
+MV_STATUS mvBoardCoreFreqGet(MV_U8 *value);
+MV_STATUS mvBoardTmFreqGet(MV_U8 *value);
 MV_STATUS mvBoardTmFreqSet(MV_U8 freqVal);
 MV_STATUS mvBoardCoreFreqSet(MV_U8 freqVal);
 
diff --git a/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvSpec.h b/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvSpec.h
index aa7040f..1f1f4e2 100644
--- a/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvSpec.h
+++ b/arch/arm/mach-msys/msys_family/boardEnv/mvBoardEnvSpec.h
@@ -76,8 +76,9 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define BOARD_ID_BASE				0x0
 
 /* New board ID numbers */
-#define RD_98DX4051_ID				(BOARD_ID_BASE)
-#define DB_98DX4251_BP_ID			(RD_98DX4051_ID + 1)
+#define DB_98DX4251_BP_ID			(BOARD_ID_BASE)
+#define RD_98DX4051_ID				(DB_98DX4251_BP_ID + 1)
+
 #define MV_MAX_BOARD_ID				(DB_98DX4251_BP_ID + 1)
 #define INVALID_BAORD_ID			0xFFFF
 
diff --git a/arch/arm/mach-msys/msys_family/cpu/mvCpu.c b/arch/arm/mach-msys/msys_family/cpu/mvCpu.c
index c39d8e6..e9bcb06 100644
--- a/arch/arm/mach-msys/msys_family/cpu/mvCpu.c
+++ b/arch/arm/mach-msys/msys_family/cpu/mvCpu.c
@@ -96,11 +96,39 @@ MV_U32 mvCpuPclkGet(MV_VOID)
 {
 	MV_U32 idx;
 	MV_U32 freqMhz;
-	MV_U32 coreClockTbl[8] = MV_CORE_CLK_TBL;
+	MV_CPUDDR_MODE clockRatioTbl[8] = MV_CPU_DDR_CLK_TBL;
+	MV_U32 sar2 = MV_DFX_REG_READ(DFX_DEVICE_SAR_REG(1));
+
+	idx = MSAR_CPU_DDR_CLK(0, sar2);
+	freqMhz = clockRatioTbl[idx].cpuFreq * 1000000;
+	return freqMhz;
+}
+
+/*******************************************************************************
+* mvCpuDdrClkGet - Get the DDR clock
+*
+* DESCRIPTION:
+*       This routine extract the DDR clock.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit clock cycles in Hertz.
+*
+*******************************************************************************/
+MV_U32 mvCpuDdrClkGet(MV_VOID)
+{
+	MV_U32 idx;
+	MV_U32 freqMhz;
+	MV_CPUDDR_MODE clockRatioTbl[8] = MV_CPU_DDR_CLK_TBL;
 	MV_U32 sar2 = MV_DFX_REG_READ(DFX_DEVICE_SAR_REG(1));
 
-	idx = MSAR_CORE_CLK(0, sar2);
-	freqMhz = coreClockTbl[idx] * 1000000;
+	idx = MSAR_CPU_DDR_CLK(0, sar2);
+	freqMhz = clockRatioTbl[idx].ddrFreq * 1000000;
 	return freqMhz;
 }
 /*******************************************************************************
@@ -115,14 +143,14 @@ MV_U32 mvCpuPclkGet(MV_VOID)
 *******************************************************************************/
 MV_U32 mvCpuL2ClkGet(MV_VOID)
 {
-	MV_U32 idx;
+/*	MV_U32 idx;
 	MV_U32 freqMhz;
 	MV_CPUDDR_MODE clockRatioTbl[8] = MV_CPU_DDR_CLK_TBL;
 	MV_U32 sar2 = MV_DFX_REG_READ(DFX_DEVICE_SAR_REG(1));
 
 	idx = MSAR_CPU_DDR_CLK(0, sar2);
-	freqMhz = clockRatioTbl[idx].cpuFreq * 1000000;
-	return freqMhz;
+	freqMhz = clockRatioTbl[idx].cpuFreq * 1000000; */
+	return 200000000;
 }
 
 /*******************************************************************************
diff --git a/arch/arm/mach-msys/msys_family/cpu/mvCpu.h b/arch/arm/mach-msys/msys_family/cpu/mvCpu.h
index c4e38d6..297cf9c 100644
--- a/arch/arm/mach-msys/msys_family/cpu/mvCpu.h
+++ b/arch/arm/mach-msys/msys_family/cpu/mvCpu.h
@@ -102,6 +102,7 @@ typedef struct _mvCpuArmClkRatio {
 } MV_CPU_ARM_CLK_RATIO;
 
 MV_U32  mvCpuPclkGet(MV_VOID);
+MV_U32 mvCpuDdrClkGet(MV_VOID);
 MV_VOID mvCpuNameGet(char *pNameBuff);
 MV_U32  mvCpuL2ClkGet(MV_VOID);
 MV_U32  mvCpuIfPrintSystemConfig(MV_8 *buffer, MV_U32 index);
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.c b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.c
index aabdc30..d62a1d56 100644
--- a/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.c
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvLib.c
@@ -219,6 +219,15 @@ MV_STATUS mvCtrlEnvInit(MV_VOID)
 	if (MV_OK != mvCtrlSerdesPhyConfig())
 		mvOsPrintf("mvCtrlEnvInit: Can't init some or all SERDES lanes\n");
 
+	/* Enable NAND Flash PUP (Pack-Unpack)
+	 * HW machanism to accelerate transactions (controlled by SoC register) */
+	MV_REG_BIT_SET(PUP_EN_REG, BIT4);
+
+	/* Configure NAND flush enabled */
+	MV_REG_BIT_SET(SOC_DEV_MUX_REG, BIT0);
+
+	/* Set NfArbiterEn to NAND Flash (Disable arbitration between device and NAND) */
+	MV_REG_BIT_RESET(SOC_DEV_MUX_REG, BIT27);
 
 	mvOsDelay(100);
 
@@ -1530,22 +1539,25 @@ void mvCtrlGetPexActive(MV_BOOL *pPexActive, int size)
 *******************************************************************************/
 void mvCtrlNandClkSet(int nClock)
 {
-	/* Set the division ratio of ECC Clock 0x00018748[13:8] (by default it's double of core clock) */
-	MV_U32 nVal = MV_DFX_REG_READ(CORE_DIV_CLK_CTRL(1));
+	DB(mvOsPrintf("%s: CPU (PLL_1) clock)  = %d, dividor = %d\n", __func__, mvCpuPclkGet(), nClock));
 
+	/* Set the division ratio of ECC Clock 0x000F8270[9:6] (ECC clock = CPU / dividor) */
+	MV_U32 nVal = MV_DFX_REG_READ(CORE_DIV_CLK_CTRL(2));
 	nVal &= ~(NAND_ECC_DIVCKL_RATIO_MASK);
 	nVal |= (nClock << NAND_ECC_DIVCKL_RATIO_OFFS);
-	MV_DFX_REG_WRITE(CORE_DIV_CLK_CTRL(1), nVal);
+	MV_DFX_REG_WRITE(CORE_DIV_CLK_CTRL(2), nVal);
 
-	/* Set reload force of ECC clock 0x00018740[7:0] to 0x2 (meaning you will force only the ECC clock) */
+	/* Set reload force of ECC clock 0x000F8268[27:21] to 0x40 (force the dividor only the NAND ECC clock) */
 	nVal = MV_DFX_REG_READ(CORE_DIV_CLK_CTRL(0));
 	nVal &= ~(CORE_DIVCLK_RELOAD_FORCE_MASK);
-	nVal |= CORE_DIVCLK_RELOAD_FORCE_VAL;
+	nVal |= (CORE_DIVCLK_RELOAD_FORCE_VAL << CORE_DIVCLK_RELOAD_FORCE_OFFS);
 	MV_DFX_REG_WRITE(CORE_DIV_CLK_CTRL(0), nVal);
 
-	/* Set reload ratio bit 0x00018740[8] to 1'b1 */
-	MV_DFX_REG_BIT_SET(CORE_DIV_CLK_CTRL(0), CORE_DIVCLK_RELOAD_RATIO_MASK);
+	/* Set reload ratio bit 0x000F8270[10] to 1'b1 */
+	MV_DFX_REG_BIT_SET(CORE_DIV_CLK_CTRL(2), CORE_DIVCLK_RELOAD_RATIO_MASK);
 	mvOsDelay(1); /*  msec */
-	/* Set reload ratio bit 0x00018740[8] to 0'b1 */
-	MV_DFX_REG_BIT_RESET(CORE_DIV_CLK_CTRL(0), CORE_DIVCLK_RELOAD_RATIO_MASK);
+	/* Set reload ratio bit 0x000F8270[10] to 0'b1 */
+	MV_DFX_REG_BIT_RESET(CORE_DIV_CLK_CTRL(2), CORE_DIVCLK_RELOAD_RATIO_MASK);
 }
+
+
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvRegs.h b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvRegs.h
index ac09996..912d0a3 100644
--- a/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvRegs.h
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvRegs.h
@@ -175,8 +175,6 @@ extern "C" {
 #define MPP_CONTROL_REG(id)			(0x18000 + (id * 4))
 
 /* Sample at Reset */
-//#define MPP_SAMPLE_AT_RESET(id)			(0x18230 + (id * 4))
-
 #define DFX_DEVICE_SAR_REG(x)			(0xf8200 +(x*4))
 
 #define MSAR_CORE_CLK(sar1, sar2)		(((sar2) >> 21) & 0x7)		/* PLL 0 config */
@@ -207,8 +205,8 @@ extern "C" {
 								DFX Server Units - BC2 specific registers/
 								Device Control 8	*/
 
-#define CORE_DIVCLK_RELOAD_RATIO_OFFS		8
-#define CORE_DIVCLK_RELOAD_RATIO_MASK		(2 << CORE_DIVCLK_RELOAD_RATIO_OFFS)
+#define CORE_DIVCLK_RELOAD_RATIO_OFFS		10
+#define CORE_DIVCLK_RELOAD_RATIO_MASK		(1 << CORE_DIVCLK_RELOAD_RATIO_OFFS)
 
 #define NAND_ECC_DIVCKL_RATIO_OFFS		6
 #define NAND_ECC_DIVCKL_RATIO_MASK		(0xF << NAND_ECC_DIVCKL_RATIO_OFFS)
@@ -245,11 +243,15 @@ extern "C" {
 #define TSEN_OTF_CALIB_OFS 	4
 #define TSEN_OTF_CALIB_MSK 	(1 << TSEN_OTF_CALIB_OFS)
 
+/*********************************/
+/* SoC Device Multiplex Register */
+/*********************************/
+#define SOC_DEV_MUX_REG				0x18208
 
-
-
-
-
+/*****************/
+/* PUP registers */
+/*****************/
+#define PUP_EN_REG				0x1864C
 
 /*****************/
 /*  registers */
-- 
1.7.5.4

