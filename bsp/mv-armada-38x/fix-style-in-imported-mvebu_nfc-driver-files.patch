From 84e05dc61018dc6ddbe5023c232416e14d69b164 Mon Sep 17 00:00:00 2001
From: Nadav Haklai <nadavh@marvell.com>
Date: Mon, 17 Feb 2014 19:14:46 +0200
Subject: [PATCH 1366/1825] fix style in imported mvebu_nfc driver files

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 060fd0cffc2c5191c72f6c8ab4345e8a8b271d6b

Change-Id: Ie32bda097c53b34978ec00214f285f88cd67ae0f
Signed-off-by: Marcin Wojtas <mw@semihalf.com>
Signed-off-by: Nadav Haklai <nadavh@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/5726
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/plat-armada/mv_hal/nfc/mvNfc.c |  110 ++++++++++++++++---------------
 arch/arm/plat-armada/mv_hal/nfc/mvNfc.h |  102 ++++++++++++++--------------
 2 files changed, 107 insertions(+), 105 deletions(-)

diff --git a/arch/arm/plat-armada/mv_hal/nfc/mvNfc.c b/arch/arm/plat-armada/mv_hal/nfc/mvNfc.c
index 360f785..0e6a3e8 100644
--- a/arch/arm/plat-armada/mv_hal/nfc/mvNfc.c
+++ b/arch/arm/plat-armada/mv_hal/nfc/mvNfc.c
@@ -149,8 +149,8 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define MV_CPU_TO_LE32(x)	(x)
 #endif
 
-#define DBGPRINT(x) 	printk x
-#define DBGLVL	 	KERN_INFO
+#define DBGPRINT(x)	printk(x)
+#define DBGLVL		KERN_INFO
 
 /***********/
 /* Typedef */
@@ -252,7 +252,7 @@ MV_NFC_FLASH_INFO flashDeviceInfo[] = {
 	.tRC = 25,		/* tWC, ND_nRE cycle duration */
 	.tRH = 10,		/* tRH, ND_nRE high duration */
 	.tRP = 15,		/* tRP, ND_nRE pulse width */
-	.tR = 25000, 		/* tR = tR+tRR+tWB+1, ND_nWE high to ND_nRE low for read - 25000+20+100+1 */
+	.tR = 25000,		/* tR = tR+tRR+tWB+1, ND_nWE high to ND_nRE low for read - 25000+20+100+1 */
 	.tWHR = 60,		/* tWHR, ND_nWE high to ND_nRE low delay for status read */
 	.tAR = 10,		/* tAR, ND_ALE low to ND_nRE low delay */
 	.tRHW = 30,		/* tRHW, ND_nRE high to ND_nWE low delay */
@@ -370,7 +370,7 @@ MV_NFC_FLASH_INFO flashDeviceInfo[] = {
 	.tRC = 40,		/* tWC, ND_nRE cycle duration */
 	.tRH = 15,		/* tRH, ND_nRE high duration */
 	.tRP = 25,		/* tRP, ND_nRE pulse width */
-	.tR = 25000, 		/* tR = data transfer from cell to register, maximum 60,000ns */
+	.tR = 25000,		/* tR = data transfer from cell to register, maximum 60,000ns */
 	.tWHR = 60,		/* tWHR, ND_nWE high to ND_nRE low delay for status read */
 	.tAR = 10,		/* tAR, ND_ALE low to ND_nRE low delay */
 	.tRHW = 30,		/* tRHW, ND_nRE high to ND_nWE low delay 32 clocks */
@@ -394,7 +394,7 @@ MV_NFC_FLASH_INFO flashDeviceInfo[] = {
 	.tRC = 22,		/* tWC, ND_nRE cycle duration */
 	.tRH = 10,		/* tRH, ND_nRE high duration */
 	.tRP = 12,		/* tRP, ND_nRE pulse width */
-	.tR = 25000, 		/* tR = data transfer from cell to register, maximum 60,000ns */
+	.tR = 25000,		/* tR = data transfer from cell to register, maximum 60,000ns */
 	.tWHR = 60,		/* tWHR, ND_nWE high to ND_nRE low delay for status read */
 	.tAR = 10,		/* tAR, ND_ALE low to ND_nRE low delay */
 	.tRHW = 100,		/* tRHW, ND_nRE high to ND_nWE low delay 32 clocks */
@@ -418,7 +418,7 @@ MV_NFC_FLASH_INFO flashDeviceInfo[] = {
 	.tRC = 22,		/* tWC, ND_nRE cycle duration */
 	.tRH = 10,		/* tRH, ND_nRE high duration */
 	.tRP = 12,		/* tRP, ND_nRE pulse width */
-	.tR = 25000, 		/* tR = data transfer from cell to register, maximum 60,000ns */
+	.tR = 25000,		/* tR = data transfer from cell to register, maximum 60,000ns */
 	.tWHR = 60,		/* tWHR, ND_nWE high to ND_nRE low delay for status read */
 	.tAR = 10,		/* tAR, ND_ALE low to ND_nRE low delay */
 	.tRHW = 100,		/* tRHW, ND_nRE high to ND_nWE low delay 32 clocks */
@@ -553,7 +553,7 @@ MV_NFC_FLASH_INFO flashDeviceInfo[] = {
 };
 
 /* Defined Command set */
-#define 	MV_NFC_FLASH_SP_CMD_SET_IDX		0
+#define	MV_NFC_FLASH_SP_CMD_SET_IDX		0
 #define		MV_NFC_FLASH_LP_CMD_SET_IDX		1
 static MV_NFC_FLASH_CMD_SET flashCmdSet[] = {
 	{
@@ -645,9 +645,9 @@ static MV_STATUS mvNfcDeviceModeSet(MV_NFC_CTRL *nfcCtrl, MV_NFC_ONFI_MODE mode)
 *
 * RETURN:
 *       MV_OK		- On success,
-*	MV_BAD_PARAM 	- The required ECC mode not supported by flash.
+*	MV_BAD_PARAM	- The required ECC mode not supported by flash.
 *	MV_NOT_SUPPORTED- The underlying flash device is not supported by HAL.
-*	MV_TIMEOUT 	- Error accessing the underlying flahs device.
+*	MV_TIMEOUT	- Error accessing the underlying flahs device.
 *	MV_FAIL		- On failure
 *******************************************************************************/
 MV_STATUS mvNfcInit(MV_NFC_INFO *nfcInfo, MV_NFC_CTRL *nfcCtrl, struct MV_NFC_HAL_DATA *halData)
@@ -2305,7 +2305,7 @@ MV_STATUS mvNfcUnitStateStore(MV_U32 *stateData, MV_U32 *len)
 * mvDfcWait4Complete
 *
 * DESCRIPTION:
-*  	Wait for event or process to complete
+*       Wait for event or process to complete
 *
 * INPUT:
 *	statMask: bit to wait from in status register NDSR
@@ -2315,8 +2315,8 @@ MV_STATUS mvNfcUnitStateStore(MV_U32 *stateData, MV_U32 *len)
 *	None.
 *
 * RETURN:
-*       MV_OK		- On success,
-*	MV_TIMEOUT 	- Error accessing the underlying flahs device.
+*	MV_OK		- On success,
+*	MV_TIMEOUT	- Error accessing the underlying flahs device.
 *******************************************************************************/
 static MV_STATUS mvDfcWait4Complete(MV_U32 statMask, MV_U32 usec)
 {
@@ -2338,7 +2338,7 @@ static MV_STATUS mvDfcWait4Complete(MV_U32 statMask, MV_U32 usec)
 * mvNfcDeviceFeatureSet
 *
 * DESCRIPTION:
-*  	Set a NAND device feature according to user's request.
+*       Set a NAND device feature according to user's request.
 *
 * INPUT:
 *	nfcCtrl	- NFC control structure.
@@ -2351,8 +2351,8 @@ static MV_STATUS mvDfcWait4Complete(MV_U32 statMask, MV_U32 usec)
 *	None.
 *
 * RETURN:
-*       MV_OK		- On success,
-*	MV_TIMEOUT 	- Error accessing the underlying flahs device.
+*	MV_OK		- On success,
+*	MV_TIMEOUT	- Error accessing the underlying flahs device.
 *******************************************************************************/
 static MV_STATUS mvNfcDeviceFeatureSet(MV_NFC_CTRL *nfcCtrl, MV_U8 cmd, MV_U8 addr, MV_U32 data0, MV_U32 data1)
 {
@@ -2422,7 +2422,7 @@ Error_1:
 * mvNfcDeviceFeatureGet
 *
 * DESCRIPTION:
-*  	Get a NAND device feature according to user's request.
+*       Get a NAND device feature according to user's request.
 *
 * INPUT:
 *	nfcCtrl	- NFC control structure.
@@ -2434,8 +2434,8 @@ Error_1:
 *	data1	- Bytes 4-7 of data.
 *
 * RETURN:
-*       MV_OK		- On success,
-*	MV_TIMEOUT 	- Error accessing the underlying flahs device.
+*	MV_OK		- On success,
+*	MV_TIMEOUT	- Error accessing the underlying flahs device.
 *******************************************************************************/
 static MV_STATUS mvNfcDeviceFeatureGet(MV_NFC_CTRL *nfcCtrl, MV_U8 cmd, MV_U8 addr, MV_U32 *data0, MV_U32 *data1)
 {
@@ -2515,7 +2515,7 @@ Error_2:
 * mvNfcDeviceModeSet
 *
 * DESCRIPTION:
-*  	Change flash working mode according to the flags
+*       Change flash working mode according to the flags
 *	field.
 *
 * INPUT:
@@ -2526,9 +2526,9 @@ Error_2:
 *	None.
 *
 * RETURN:
-*       MV_OK		- On success,
-*	MV_BAD_VALUE    - Wrong mode
-*	MV_TIMEOUT 	- Error accessing the underlying flahs device.
+*	MV_OK		- On success,
+*	MV_BAD_VALUE	- Wrong mode
+*	MV_TIMEOUT	- Error accessing the underlying flahs device.
 *******************************************************************************/
 static MV_STATUS mvNfcDeviceModeSet(MV_NFC_CTRL *nfcCtrl, MV_NFC_ONFI_MODE mode)
 {
@@ -2609,8 +2609,8 @@ Error_3:
 *	id: Manufacturer and Device Id detected (valid only if return is MV_OK).
 *
 * RETURN:
-*       MV_OK		- On success,
-*	MV_TIMEOUT 	- Error accessing the underlying flahs device.
+*	MV_OK		- On success,
+*	MV_TIMEOUT	- Error accessing the underlying flahs device.
 *	MV_FAIL		- On failure
 *******************************************************************************/
 static MV_STATUS mvNfcReadIdNative(MV_NFC_CHIP_SEL cs, MV_U16 *id)
@@ -2733,71 +2733,73 @@ static MV_STATUS mvNfcTimingSet(MV_U32 tclk, MV_NFC_FLASH_INFO *flInfo)
 	trp_nfc = (trp - 1);
 
 	if (check_limit(tadl_nfc, 5) != tadl_nfc) {
-/*		ret = MV_OUT_OF_RANGE; */
+		/* ret = MV_OUT_OF_RANGE; */
 		tadl_nfc = check_limit(tadl_nfc, 5);
 	}
 
 	if (check_limit(tch_nfc, 3) != tch_nfc) {
-/*		ret = MV_OUT_OF_RANGE; */
+		/* ret = MV_OUT_OF_RANGE; */
 		tch_nfc = check_limit(tch_nfc, 3);
 	}
 
 	if (check_limit(tcs_nfc, 3) != tcs_nfc) {
-/*		ret = MV_OUT_OF_RANGE; */
+		/* ret = MV_OUT_OF_RANGE; */
 		tcs_nfc = check_limit(tcs_nfc, 3);
 	}
 
 	if (check_limit(twh_nfc, 3) != twh_nfc) {
-/*		ret = MV_OUT_OF_RANGE; */
+		/* ret = MV_OUT_OF_RANGE; */
 		twh_nfc = check_limit(twh_nfc, 3);
 	}
 
 	if (check_limit(twp_nfc, 3) != twp_nfc) {
-/*		ret = MV_OUT_OF_RANGE; */
+		/* ret = MV_OUT_OF_RANGE; */
 		twp_nfc = check_limit(twp_nfc, 3);
 	}
 
 	if (check_limit(trh_nfc, 3) != trh_nfc) {
-/*		ret = MV_OUT_OF_RANGE; */
+		/* ret = MV_OUT_OF_RANGE; */
 		trh_nfc = check_limit(trh_nfc, 3);
 	}
 
 	if (check_limit(trp_nfc, 4) != trp_nfc) {
-/*		ret = MV_OUT_OF_RANGE; */
+		/* ret = MV_OUT_OF_RANGE; */
 		trp_nfc = check_limit(trp_nfc, 4);
 	}
 
-	reg =  ((tadl_nfc << NFC_TMNG0_TADL_OFFS) | \
-		(0x1 << NFC_TMNG0_SEL_CNTR_OFFS) | \
-		(0x4 << NFC_TMNG0_RD_CNT_DEL_OFFS) | \
-		(tch_nfc << NFC_TMNG0_TCH_OFFS) | \
-		(tcs_nfc << NFC_TMNG0_TCS_OFFS) | \
-		(twh_nfc << NFC_TMNG0_TWH_OFFS) | \
-		(twp_nfc << NFC_TMNG0_TWP_OFFS) | \
-		(0x0 << NFC_TMNG0_SEL_NRE_EDGE_OFFS) | \
-		((trp_nfc >> 3) << NFC_TMNG0_ETRP_OFFS) | \
-		(trh_nfc << NFC_TMNG0_TRH_OFFS) | \
+	reg =  ((tadl_nfc << NFC_TMNG0_TADL_OFFS) |
+		(0x1 << NFC_TMNG0_SEL_CNTR_OFFS) |
+		(0x4 << NFC_TMNG0_RD_CNT_DEL_OFFS) |
+		(tch_nfc << NFC_TMNG0_TCH_OFFS) |
+		(tcs_nfc << NFC_TMNG0_TCS_OFFS) |
+		(twh_nfc << NFC_TMNG0_TWH_OFFS) |
+		(twp_nfc << NFC_TMNG0_TWP_OFFS) |
+		(0x0 << NFC_TMNG0_SEL_NRE_EDGE_OFFS) |
+		((trp_nfc >> 3) << NFC_TMNG0_ETRP_OFFS) |
+		(trh_nfc << NFC_TMNG0_TRH_OFFS) |
 		((trp_nfc & 0x7) << NFC_TMNG0_TRP_OFFS));
 	MV_REG_WRITE(NFC_TIMING_0_REG, reg);
 
 	/* Calculate the timing configurations for register1 */
 	tr_nfc = (ns_clk(flInfo->tR, clk2ns) - tch_nfc - 3);
-	trhw_nfc = (ns_clk(flInfo->tRHW, clk2ns) % 16) ? ((ns_clk(flInfo->tRHW, clk2ns) / 16) + 1) : (ns_clk(flInfo->tRHW, clk2ns) / 16);
+	trhw_nfc = (ns_clk(flInfo->tRHW, clk2ns) % 16) ? ((ns_clk(flInfo->tRHW,
+					clk2ns) / 16) + 1) : (ns_clk(flInfo->tRHW, clk2ns) / 16);
 
 	/*
 	 * For simplicity Assuming that tar == twhr
 	 * loop over all 16 possible values of tWHR_NFC and find smallest possible value (if possible!!!)
 	 */
 	twhr_nfc = 17; /* big number */
-	for (i=0; i<16; i++) {
-		if ( (maxx(twh_nfc, tch_nfc) + maxx (i, maxx(0, i - maxx(twh_nfc, tch_nfc))) + 2) >= ns_clk(flInfo->tWHR, clk2ns))
+	for (i = 0; i < 16; i++) {
+		if ((maxx(twh_nfc, tch_nfc) + maxx(i, maxx(0, i - maxx(twh_nfc, tch_nfc))) + 2) >=
+		     ns_clk(flInfo->tWHR, clk2ns))
 			if (twhr_nfc > i)
 				twhr_nfc = i;
 	}
 
 	if (twhr_nfc >= 16) {
 		twhr_nfc = 15; /* worst case - best we can do */
-/*		ret = MV_OUT_OF_RANGE; */
+		/* ret = MV_OUT_OF_RANGE; */
 	}
 
 	tar_nfc = twhr_nfc; /* our initial assumption */
@@ -2814,29 +2816,29 @@ static MV_STATUS mvNfcTimingSet(MV_U32 tclk, MV_NFC_FLASH_INFO *flInfo)
 #endif
 
 	if (check_limit(tr_nfc, 16) != tr_nfc) {
-/*		ret = MV_OUT_OF_RANGE; */
+		/* ret = MV_OUT_OF_RANGE; */
 		tr_nfc = check_limit(tr_nfc, 16);
 	}
 
 	if (check_limit(trhw_nfc, 2) != trhw_nfc) {
-/*		ret = MV_OUT_OF_RANGE; */
+		/* ret = MV_OUT_OF_RANGE; */
 		trhw_nfc = check_limit(trhw_nfc, 2);
 	}
 
 	if (check_limit(twhr_nfc, 4) != twhr_nfc) {
-/*		ret = MV_OUT_OF_RANGE; */
+		/* ret = MV_OUT_OF_RANGE; */
 		twhr_nfc = check_limit(twhr_nfc, 4);
 	}
 
 	if (check_limit(tar_nfc, 4) != tar_nfc) {
-/*		ret = MV_OUT_OF_RANGE; */
+		/* ret = MV_OUT_OF_RANGE; */
 		tar_nfc = check_limit(tar_nfc, 5);
 	}
 
-	reg = ((tr_nfc << NFC_TMNG1_TR_OFFS) | \
-		(tr_pre_nfc << NFC_TMNG1_PRESCALE_OFFS) | \
-		(trhw_nfc << NFC_TMNG1_TRHW_OFFS) | \
-		(twhr_nfc << NFC_TMNG1_TWHR_OFFS) | \
+	reg = ((tr_nfc << NFC_TMNG1_TR_OFFS) |
+		(tr_pre_nfc << NFC_TMNG1_PRESCALE_OFFS) |
+		(trhw_nfc << NFC_TMNG1_TRHW_OFFS) |
+		(twhr_nfc << NFC_TMNG1_TWHR_OFFS) |
 		(tar_nfc << NFC_TMNG1_TAR_OFFS));
 #ifndef MTD_NAND_NFC_NEGLECT_RNB
 	reg |= (0x1 << NFC_TMNG1_WAIT_MODE_OFFS);
@@ -2869,7 +2871,7 @@ static MV_U32 mvNfcColBits(MV_U32 pg_size)
 		pg_size >>= 1;
 	};
 
-	return (shift - 1);
+	return shift - 1;
 }
 
 /*******************************************************************************
diff --git a/arch/arm/plat-armada/mv_hal/nfc/mvNfc.h b/arch/arm/plat-armada/mv_hal/nfc/mvNfc.h
index 1781c25..36e73f3 100644
--- a/arch/arm/plat-armada/mv_hal/nfc/mvNfc.h
+++ b/arch/arm/plat-armada/mv_hal/nfc/mvNfc.h
@@ -152,7 +152,7 @@ extern "C" {
 #endif
 
 /********************************/
-/* Enums and structures 	*/
+/* Enums and structures		*/
 /********************************/
 
 /* Maximum Chain length */
@@ -167,14 +167,14 @@ extern "C" {
 #define MV_NFC_MAX_CHUNK_SIZE		(2048)
 
 /* Nand controller status bits.		*/
-#define MV_NFC_STATUS_CMD_REQ 		0x1
-#define MV_NFC_STATUS_RDD_REQ 		0x2
-#define MV_NFC_STATUS_WRD_REQ 		0x4
-#define MV_NFC_STATUS_COR_ERROR 	0x8
-#define MV_NFC_STATUS_UNC_ERROR 	0x10
-#define MV_NFC_STATUS_BBD 		0x20	/* Bad Block Detected */
-#define MV_NFC_STATUS_CMDD 		0x80	/* Command Done */
-#define MV_NFC_STATUS_PAGED 		0x200	/* Page Done */
+#define MV_NFC_STATUS_CMD_REQ		0x1
+#define MV_NFC_STATUS_RDD_REQ		0x2
+#define MV_NFC_STATUS_WRD_REQ		0x4
+#define MV_NFC_STATUS_COR_ERROR		0x8
+#define MV_NFC_STATUS_UNC_ERROR		0x10
+#define MV_NFC_STATUS_BBD		0x20	/* Bad Block Detected */
+#define MV_NFC_STATUS_CMDD		0x80	/* Command Done */
+#define MV_NFC_STATUS_PAGED		0x200	/* Page Done */
 #define MV_NFC_STATUS_RDY		0x800	/* Device Ready */
 
 /* Nand controller interrupt bits.	*/
@@ -233,15 +233,15 @@ typedef enum {
 
 
 /*
- * 	ioMode		The access mode by which the unit will operate (PDMA / PIO).
- * 	eccMode		The ECC mode to configure the controller to.
- * 	ifMode		The NAND chip connection mode, 8-bit / 16-bit / gang mode.
- * 	autoStatusRead	Whether to automatically read the flash status after each
+ *	ioMode		The access mode by which the unit will operate (PDMA / PIO).
+ *	eccMode		The ECC mode to configure the controller to.
+ *	ifMode		The NAND chip connection mode, 8-bit / 16-bit / gang mode.
+ *	autoStatusRead	Whether to automatically read the flash status after each
  *			erase / write commands.
  *	tclk		System TCLK.
- * 	readyBypass	Whether to wait for the RnB sugnal to be deasserted after
+ *	readyBypass	Whether to wait for the RnB sugnal to be deasserted after
  *			waiting the tR or skip it and move directly to the next step.
- * 	osHandle	OS specific handle used for allocating command buffer
+ *	osHandle	OS specific handle used for allocating command buffer
  *	regsPhysAddr	Physical address of internal registers (used in DMA
  *			mode only)
  *	dataPdmaIntMask Interrupt mask for PDMA data channel (used in DMA mode
@@ -250,10 +250,10 @@ typedef enum {
  *			mode only).
  */
 typedef struct {
-	MV_NFC_IO_MODE 		ioMode;
-	MV_NFC_ECC_MODE 	eccMode;
-	MV_NFC_IF_MODE 		ifMode;
-	MV_BOOL 		autoStatusRead;
+	MV_NFC_IO_MODE		ioMode;
+	MV_NFC_ECC_MODE		eccMode;
+	MV_NFC_IF_MODE		ifMode;
+	MV_BOOL			autoStatusRead;
 	MV_U32			tclk;
 	MV_BOOL			readyBypass;
 	MV_VOID			*osHandle;
@@ -297,20 +297,20 @@ typedef enum {
 
 /*
  * Nand information structure.
- * 	flashId 	The ID of the flash information structure representing the timing
- *		    	and physical layout data of the flash device.
- *	cmdsetId  	The ID of the command-set structure holding the access
- *		   	commands for the flash device.
- *      flashWidth 	Flash device interface width in bits.
- * 	autoStatusRead	Whether to automatically read the flash status after each
- *		    	erase / write commands.
- * 	tclk		System TCLK.
- * 	readyBypass	Whether to wait for the RnB signal to be deasserted after
- * 			waiting the tR or skip it and move directly to the next step.
- *      ioMode		Controller access mode (PDMA / PIO).
- *      eccMode		Flash ECC mode (Hamming, BCH, None).
- *      ifMode		Flash interface mode.
- *      currC		The current flash CS currently being accessed.
+ *	flashId		The ID of the flash information structure representing the timing
+ *			and physical layout data of the flash device.
+ *	cmdsetId	The ID of the command-set structure holding the access
+ *			commands for the flash device.
+ *	flashWidth	Flash device interface width in bits.
+ *	autoStatusRead	Whether to automatically read the flash status after each
+ *			erase / write commands.
+ *	tclk		System TCLK.
+ *	readyBypass	Whether to wait for the RnB signal to be deasserted after
+ *			waiting the tR or skip it and move directly to the next step.
+ *	ioMode		Controller access mode (PDMA / PIO).
+ *	eccMode		Flash ECC mode (Hamming, BCH, None).
+ *	ifMode		Flash interface mode.
+ *	currC		The current flash CS currently being accessed.
  *	dataChanHndl	Pointer to the data DMA channel
  *	cmdChanHndl	Pointer to the command DMA Channel
  *	cmdBuff		Command buffer information (used in DMA only)
@@ -324,17 +324,17 @@ typedef enum {
 typedef struct {
 	MV_U32		flashIdx;
 	MV_U32		cmdsetIdx;
-	MV_U32 		flashWidth;
-	MV_U32 		dfcWidth;
-	MV_BOOL 	autoStatusRead;
+	MV_U32		flashWidth;
+	MV_U32		dfcWidth;
+	MV_BOOL		autoStatusRead;
 	MV_BOOL		readyBypass;
-	MV_NFC_IO_MODE 	ioMode;
-	MV_NFC_ECC_MODE eccMode;
-	MV_NFC_IF_MODE 	ifMode;
-	MV_NFC_CHIP_SEL currCs;
+	MV_NFC_IO_MODE	ioMode;
+	MV_NFC_ECC_MODE	eccMode;
+	MV_NFC_IF_MODE	ifMode;
+	MV_NFC_CHIP_SEL	currCs;
 #ifdef MV_INCLUDE_PDMA
-	MV_PDMA_CHANNEL dataChanHndl;
-	MV_PDMA_CHANNEL cmdChanHndl;
+	MV_PDMA_CHANNEL	dataChanHndl;
+	MV_PDMA_CHANNEL	cmdChanHndl;
 #endif
 	MV_BUF_INFO	cmdBuff;
 	MV_BUF_INFO	cmdDescBuff;
@@ -376,10 +376,10 @@ typedef struct {
  *			offset buffOffset[i].
  */
 typedef struct {
-	MV_NFC_CMD_TYPE cmd;
+	MV_NFC_CMD_TYPE	cmd;
 	MV_U32		pageAddr;
 	MV_U32		pageCount;
-	MV_U32 		*virtAddr;
+	MV_U32		*virtAddr;
 	MV_U32		physAddr;
 	MV_U32		numSgBuffs;
 	MV_U32		sgBuffAddr[MV_NFC_RW_MAX_BUFF_NUM];
@@ -401,28 +401,28 @@ struct MV_NFC_HAL_DATA {
 
 
 /********************************/
-/* Functions API 		*/
+/* Functions API		*/
 /********************************/
 MV_STATUS mvNfcInit(MV_NFC_INFO *nfcInfo, MV_NFC_CTRL *nfcCtrl, struct MV_NFC_HAL_DATA *halData);
 MV_STATUS mvNfcSelectChip(MV_NFC_CTRL *nfcCtrl, MV_NFC_CHIP_SEL chip);
-MV_STATUS mvNfcCommandPio(MV_NFC_CTRL *nfcCtrl, MV_NFC_MULTI_CMD * cmd_desc, MV_BOOL next);
+MV_STATUS mvNfcCommandPio(MV_NFC_CTRL *nfcCtrl, MV_NFC_MULTI_CMD *cmd_desc, MV_BOOL next);
 MV_STATUS mvNfcCommandMultiple(MV_NFC_CTRL *nfcCtrl, MV_NFC_MULTI_CMD *descInfo, MV_U32 descCnt);
-MV_U32 	  mvNfcStatusGet(MV_NFC_CTRL *nfcCtrl, MV_NFC_CMD_TYPE cmd, MV_U32 *value);
+MV_U32    mvNfcStatusGet(MV_NFC_CTRL *nfcCtrl, MV_NFC_CMD_TYPE cmd, MV_U32 *value);
 MV_STATUS mvNfcIntrSet(MV_NFC_CTRL *nfcCtrl, MV_U32 intMask, MV_BOOL enable);
 MV_STATUS mvNfcReadWrite(MV_NFC_CTRL *nfcCtrl, MV_NFC_CMD_TYPE cmd, MV_U32 *virtBufAddr, MV_U32 physBuffAddr);
-MV_VOID   mvNfcReadWritePio(MV_NFC_CTRL *nfcCtrl, MV_U32 * buff, MV_U32 data_len, MV_NFC_PIO_RW_MODE mode);
+MV_VOID   mvNfcReadWritePio(MV_NFC_CTRL *nfcCtrl, MV_U32 *buff, MV_U32 data_len, MV_NFC_PIO_RW_MODE mode);
 MV_VOID   mvNfcAddress2RowConvert(MV_NFC_CTRL *nfcCtrl, MV_U32 address, MV_U32 *row, MV_U32 *colOffset);
 MV_VOID   mvNfcAddress2BlockConvert(MV_NFC_CTRL *nfcCtrl, MV_U32 address, MV_U32 *blk);
-MV_8 	 *mvNfcFlashModelGet(MV_NFC_CTRL *nfcCtrl);
+MV_8     *mvNfcFlashModelGet(MV_NFC_CTRL *nfcCtrl);
 MV_STATUS mvNfcFlashPageSizeGet(MV_NFC_CTRL *nfcCtrl, MV_U32 *size, MV_U32 *totalSize);
 MV_STATUS mvNfcFlashBlockSizeGet(MV_NFC_CTRL *nfcCtrl, MV_U32 *size);
 MV_STATUS mvNfcFlashBlockNumGet(MV_NFC_CTRL *nfcCtrl, MV_U32 *numBlocks);
 MV_STATUS mvNfcDataLength(MV_NFC_CTRL *nfcCtrl, MV_NFC_CMD_TYPE cmd, MV_U32 *data_len);
-MV_STATUS mvNfcTransferDataLength(MV_NFC_CTRL *nfcCtrl, MV_NFC_CMD_TYPE cmd, MV_U32 * data_len);
+MV_STATUS mvNfcTransferDataLength(MV_NFC_CTRL *nfcCtrl, MV_NFC_CMD_TYPE cmd, MV_U32 *data_len);
 MV_STATUS mvNfcFlashIdGet(MV_NFC_CTRL *nfcCtrl, MV_U32 *flashId);
 MV_STATUS mvNfcUnitStateStore(MV_U32 *stateData, MV_U32 *len);
 MV_NFC_ECC_MODE mvNfcEccModeSet(MV_NFC_CTRL *nfcCtrl, MV_NFC_ECC_MODE eccMode);
-MV_U32 	  mvNfcBadBlockPageNumber(MV_NFC_CTRL *nfcCtrl);
+MV_U32    mvNfcBadBlockPageNumber(MV_NFC_CTRL *nfcCtrl);
 MV_STATUS mvNfcReset(void);
 
 #ifdef __cplusplus
-- 
1.7.5.4

