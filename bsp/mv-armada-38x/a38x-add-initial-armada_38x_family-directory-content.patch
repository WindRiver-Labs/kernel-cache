From 6f2624ab081649137cb2721275a746416b484528 Mon Sep 17 00:00:00 2001
From: Nadav Haklai <nadavh@marvell.com>
Date: Thu, 10 Oct 2013 13:57:31 +0200
Subject: [PATCH 1086/1825] a38x: add initial armada_38x_family directory
 contents

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 03f956dcc808ed02f751986d4be9cda72214a18b

	import from Armada 375 family code

Change-Id: I25b1994221c58dd297f609e85fad2a83a8abd6dc
Signed-off-by: Nadav Haklai <nadavh@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/3670
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../armada_38x_family/boardEnv/mvBoardEnvLib.c     | 2426 ++++++++++++++++++++
 .../armada_38x_family/boardEnv/mvBoardEnvLib.h     |  478 ++++
 .../armada_38x_family/boardEnv/mvBoardEnvSpec.c    |  302 +++
 .../armada_38x_family/boardEnv/mvBoardEnvSpec.h    |  142 ++
 .../mach-armada38x/armada_38x_family/cpu/mvCpu.c   |  309 +++
 .../mach-armada38x/armada_38x_family/cpu/mvCpu.h   |  112 +
 .../armada_38x_family/ctrlEnv/mvCtrlEnvAddrDec.c   |  363 +++
 .../armada_38x_family/ctrlEnv/mvCtrlEnvAddrDec.h   |  194 ++
 .../armada_38x_family/ctrlEnv/mvCtrlEnvAsm.h       |   97 +
 .../armada_38x_family/ctrlEnv/mvCtrlEnvLib.c       | 1735 ++++++++++++++
 .../armada_38x_family/ctrlEnv/mvCtrlEnvLib.h       |  365 +++
 .../armada_38x_family/ctrlEnv/mvCtrlEnvRegs.h      |  359 +++
 .../armada_38x_family/ctrlEnv/mvCtrlEnvSpec.h      |  524 +++++
 .../armada_38x_family/ctrlEnv/mvCtrlEthCompLib.c   |  467 ++++
 .../armada_38x_family/ctrlEnv/mvCtrlEthCompLib.h   |  166 ++
 .../armada_38x_family/ctrlEnv/mvSemaphore.c        |  123 +
 .../armada_38x_family/ctrlEnv/mvSemaphore.h        |  106 +
 .../armada_38x_family/ctrlEnv/mvUnitMap.c          |  231 ++
 .../armada_38x_family/ctrlEnv/mvUnitMap.h          |  158 ++
 .../armada_38x_family/ctrlEnv/sys/mvAhbToMbus.c    |  742 ++++++
 .../armada_38x_family/ctrlEnv/sys/mvAhbToMbus.h    |   93 +
 .../ctrlEnv/sys/mvAhbToMbusRegs.h                  |  142 ++
 .../armada_38x_family/ctrlEnv/sys/mvCpuIf.c        |  955 ++++++++
 .../armada_38x_family/ctrlEnv/sys/mvCpuIf.h        |  119 +
 .../armada_38x_family/ctrlEnv/sys/mvCpuIfInit.S    |  167 ++
 .../armada_38x_family/ctrlEnv/sys/mvCpuIfRegs.h    |  357 +++
 .../armada_38x_family/device/mvDevice.c            |  291 +++
 .../armada_38x_family/device/mvDevice.h            |   99 +
 .../armada_38x_family/device/mvDeviceRegs.h        |  281 +++
 29 files changed, 11903 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.c
 create mode 100644 arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.h
 create mode 100644 arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvSpec.c
 create mode 100644 arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvSpec.h
 create mode 100644 arch/arm/mach-armada38x/armada_38x_family/cpu/mvCpu.c
 create mode 100644 arch/arm/mach-armada38x/armada_38x_family/cpu/mvCpu.h
 create mode 100644 arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvAddrDec.c
 create mode 100644 arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvAddrDec.h
 create mode 100644 arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvAsm.h
 create mode 100644 arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.c
 create mode 100644 arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.h
 create mode 100644 arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvRegs.h
 create mode 100644 arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvSpec.h
 create mode 100644 arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEthCompLib.c
 create mode 100644 arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEthCompLib.h
 create mode 100644 arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvSemaphore.c
 create mode 100644 arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvSemaphore.h
 create mode 100644 arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvUnitMap.c
 create mode 100644 arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvUnitMap.h
 create mode 100644 arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/sys/mvAhbToMbus.c
 create mode 100644 arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/sys/mvAhbToMbus.h
 create mode 100644 arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/sys/mvAhbToMbusRegs.h
 create mode 100644 arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/sys/mvCpuIf.c
 create mode 100644 arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/sys/mvCpuIf.h
 create mode 100644 arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/sys/mvCpuIfInit.S
 create mode 100644 arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/sys/mvCpuIfRegs.h
 create mode 100644 arch/arm/mach-armada38x/armada_38x_family/device/mvDevice.c
 create mode 100644 arch/arm/mach-armada38x/armada_38x_family/device/mvDevice.h
 create mode 100644 arch/arm/mach-armada38x/armada_38x_family/device/mvDeviceRegs.h

diff --git a/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.c b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.c
new file mode 100644
index 0000000..88b5cc2
--- /dev/null
+++ b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.c
@@ -0,0 +1,2426 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+********************************************************************************
+   Marvell Commercial License Option
+
+   If you received this File from Marvell and you have entered into a commercial
+   license agreement (a "Commercial License") with Marvell, the File is licensed
+   to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+********************************************************************************
+   Marvell BSD License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File under the following licensing terms.
+   Redistribution and use in source and binary forms, with or without modification,
+   are permitted provided that the following conditions are met:
+
+*   Redistributions of source code must retain the above copyright notice,
+            this list of conditions and the following disclaimer.
+
+*   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+*   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+   ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+   ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "cpu/mvCpu.h"
+#include "cntmr/mvCntmr.h"
+#include "gpp/mvGpp.h"
+#include "twsi/mvTwsi.h"
+#include "pex/mvPex.h"
+#include "pci/mvPci.h"
+#include "device/mvDevice.h"
+
+#if defined(CONFIG_MV_ETH_NETA)
+#include "neta/gbe/mvEthRegs.h"
+#elif defined(CONFIG_MV_ETH_PP2)
+#include "pp2/gbe/mvPp2GbeRegs.h"
+#endif
+
+#include "gpp/mvGppRegs.h"
+
+/* defines  */
+#undef MV_DEBUG
+#ifdef MV_DEBUG
+#define DB(x)   x
+#else
+#define DB(x)
+#endif
+
+extern MV_BOARD_INFO *boardInfoTbl[];
+extern MV_BOARD_SATR_INFO boardSatrInfo[];
+MV_BOARD_CONFIG_TYPE_INFO boardConfigTypesInfo[] = MV_BOARD_CONFIG_INFO;
+
+/* Locals */
+static MV_DEV_CS_INFO *boardGetDevEntry(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
+static MV_BOARD_INFO *board = NULL;
+
+
+/*******************************************************************************
+* mvBoardEnvInit
+*
+* DESCRIPTION:
+*	In this function the board environment take care of device bank
+*	initialization.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvBoardEnvInit(MV_VOID)
+{
+	MV_U32 nandDev;
+	MV_U32 norDev;
+
+	mvBoardIdSet(mvBoardIdGet());
+	MV_U32 syncCtrl = 0;
+
+	nandDev = boardGetDevCSNum(0, BOARD_DEV_NAND_FLASH);
+	if (nandDev != 0xFFFFFFFF) {
+		/* Set NAND interface access parameters */
+		MV_REG_WRITE(DEV_BANK_PARAM_REG(nandDev), board->nandFlashReadParams);
+		MV_REG_WRITE(DEV_BANK_PARAM_REG_WR(nandDev), board->nandFlashWriteParams);
+		MV_REG_WRITE(DEV_NAND_CTRL_REG, board->nandFlashControl);
+		/* Set Ready Polarity to Active High */
+		syncCtrl |= SYNC_CTRL_READY_POL(nandDev);
+	}
+
+	norDev = boardGetDevCSNum(0, BOARD_DEV_NOR_FLASH);
+	if (norDev != 0xFFFFFFFF) {
+		/* Set NOR interface access parameters */
+		MV_REG_WRITE(DEV_BANK_PARAM_REG(norDev), board->norFlashReadParams);
+		MV_REG_WRITE(DEV_BANK_PARAM_REG_WR(norDev), board->norFlashWriteParams);
+		/* Ignore Ready signal */
+		syncCtrl |= SYNC_CTRL_READY_IGNORE(norDev);
+	}
+
+	if (nandDev != 0xFFFFFFFF || norDev != 0xFFFFFFFF) {
+		/* Set TCLK Divide Value to 1:1 */
+		syncCtrl |= 0x1;
+		/* Finally - write the Bus Sync Control configuration */
+		MV_REG_WRITE(DEV_BUS_SYNC_CTRL, syncCtrl);
+	}
+
+	/* Set GPP Out value */
+	MV_REG_WRITE(GPP_DATA_OUT_REG(0), board->gppOutValLow);
+	MV_REG_WRITE(GPP_DATA_OUT_REG(1), board->gppOutValMid);
+	MV_REG_WRITE(GPP_DATA_OUT_REG(2), board->gppOutValHigh);
+
+	/* set GPP polarity */
+	mvGppPolaritySet(0, 0xFFFFFFFF, board->gppPolarityValLow);
+	mvGppPolaritySet(1, 0xFFFFFFFF, board->gppPolarityValMid);
+	mvGppPolaritySet(2, 0xFFFFFFFF, board->gppPolarityValHigh);
+
+	/* Set GPP Out Enable */
+	mvGppTypeSet(0, 0xFFFFFFFF, board->gppOutEnValLow);
+	mvGppTypeSet(1, 0xFFFFFFFF, board->gppOutEnValMid);
+	mvGppTypeSet(2, 0xFFFFFFFF, board->gppOutEnValHigh);
+}
+
+/*******************************************************************************
+* mvBoardModelGet - Get Board model
+*
+* DESCRIPTION:
+*       This function returns 16bit describing board model.
+*       Board model is constructed of one byte major and minor numbers in the
+*       following manner:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       String describing board model.
+*
+*******************************************************************************/
+MV_U16 mvBoardModelGet(MV_VOID)
+{
+	return mvBoardIdGet() >> 16;
+}
+
+/*******************************************************************************
+* mbBoardRevlGet - Get Board revision
+*
+* DESCRIPTION:
+*       This function returns a 32bit describing the board revision.
+*       Board revision is constructed of 4bytes. 2bytes describes major number
+*       and the other 2bytes describes minor munber.
+*       For example for board revision 3.4 the function will return
+*       0x00030004.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       String describing board model.
+*
+*******************************************************************************/
+MV_U16 mvBoardRevGet(MV_VOID)
+{
+	return mvBoardIdGet() & 0xFFFF;
+}
+
+/*******************************************************************************
+* mvBoardNameGet - Get Board name
+*
+* DESCRIPTION:
+*       This function returns a string describing the board model and revision.
+*       String is extracted from board I2C EEPROM.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       pNameBuff - Buffer to contain board name string. Minimum size 32 chars.
+*
+* RETURN:
+*
+*       MV_ERROR if informantion can not be read.
+*******************************************************************************/
+MV_STATUS mvBoardNameGet(char *pNameBuff, MV_U32 size)
+{
+	mvOsSNPrintf(pNameBuff, size, "%s", board->boardName);
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvBoardIsPortInSgmii -
+*
+* DESCRIPTION:
+*       This routine returns MV_TRUE for port number works in SGMII or MV_FALSE
+*	For all other options.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE - port in SGMII.
+*       MV_FALSE - other.
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsPortInSgmii(MV_U32 ethPortNum)
+{
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvBoardIsPortInGmii
+*
+* DESCRIPTION:
+*       This routine returns MV_TRUE for port number works in SGMII or MV_FALSE
+*	For all other options.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE - port in SGMII.
+*       MV_FALSE - other.
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsPortInGmii(MV_U32 ethPortNum)
+{
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvBoardPhyAddrGet - Get the phy address
+*
+* DESCRIPTION:
+*       This routine returns the Phy address of a given ethernet port.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit describing Phy address, -1 if the port number is wrong.
+*
+*******************************************************************************/
+MV_32 mvBoardPhyAddrGet(MV_U32 ethPortNum)
+{
+	if (ethPortNum >= board->numBoardMacInfo) {
+		DB(mvOsPrintf("%s: Error: invalid ethPortNum (%d)\n", __func__, ethPortNum));
+		return MV_ERROR;
+	}
+
+	return board->pBoardMacInfo[ethPortNum].boardEthSmiAddr;
+}
+
+/*******************************************************************************
+* mvBoardPhyAddrSet - Set the phy address
+*
+* DESCRIPTION:
+*       This routine sets the Phy address of a given ethernet port.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*       smiAddr    - requested phy address
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvBoardPhyAddrSet(MV_U32 ethPortNum, MV_U32 smiAddr)
+{
+	if (ethPortNum >= board->numBoardMacInfo) {
+		DB(mvOsPrintf("%s: Error: invalid ethPortNum (%d)\n", __func__, ethPortNum));
+		return;
+	}
+
+	board->pBoardMacInfo[ethPortNum].boardEthSmiAddr = smiAddr;
+}
+
+/*******************************************************************************
+* mvBoardSpecInitGet -
+*
+* DESCRIPTION:
+*       This routine returns the board specific initializtion information.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       A pointer to the array holding the board specific initializations.
+*
+*******************************************************************************/
+MV_BOARD_SPEC_INIT *mvBoardSpecInitGet(MV_VOID)
+{
+	return board->pBoardSpecInit;
+}
+
+/*******************************************************************************
+* mvBoardMacSpeedGet - Get the Mac speed
+*
+* DESCRIPTION:
+*       This routine returns the Mac speed if pre define of a given ethernet port.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_BOARD_MAC_SPEED, -1 if the port number is wrong.
+*
+*******************************************************************************/
+MV_BOARD_MAC_SPEED mvBoardMacSpeedGet(MV_U32 ethPortNum)
+{
+	if (ethPortNum >= board->numBoardMacInfo) {
+		mvOsPrintf("%s: Error: wrong eth port (%d)\n", __func__, ethPortNum);
+		return BOARD_MAC_SPEED_100M;
+	}
+
+	return board->pBoardMacInfo[ethPortNum].boardMacSpeed;
+}
+
+/*******************************************************************************
+* mvBoardIsPortLoopback -
+*
+* DESCRIPTION:
+*       This routine returns MV_TRUE for loopback port number or MV_FALSE
+*	For all other options.
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE - port is loopback.
+*       MV_FALSE - other.
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsPortLoopback(MV_U32 ethPortNum)
+{
+	return (ethPortNum == 2);
+}
+
+/*******************************************************************************
+* mvBoardTclkGet
+*
+* DESCRIPTION:
+*       This routine extract the controller core clock, aka, TCLK clock.
+*
+* INPUT:
+* 	None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit clock cycles in Hertz.
+*
+*******************************************************************************/
+MV_U32 mvBoardTclkGet(MV_VOID)
+{
+	MV_U32 tclk;
+	tclk = (MV_REG_READ(MPP_SAMPLE_AT_RESET(1)));
+	tclk = ((tclk & 0x400000) >> 22);
+	switch (tclk) {
+	case 0:
+		return MV_BOARD_TCLK_166MHZ;
+	case 1:
+		return MV_BOARD_TCLK_200MHZ;
+	default:
+		return MV_BOARD_TCLK_200MHZ;
+	}
+}
+
+/*******************************************************************************
+* mvBoardSysClkGet - Get the board SysClk (CPU bus clock , i.e. DDR clock)
+*
+* DESCRIPTION:
+*       This routine extract the CPU bus clock.
+*
+* INPUT:
+*       countNum - Counter number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit clock cycles in Hertz.
+*
+*******************************************************************************/
+MV_U32 mvBoardSysClkGet(MV_VOID)
+{
+	MV_FREQ_MODE freqMode;
+	if (MV_ERROR != mvCtrlCpuDdrL2FreqGet(&freqMode))
+		return (MV_U32)(1000000 * freqMode.ddrFreq);
+	else
+		return MV_ERROR;
+}
+
+/*******************************************************************************
+* mvBoardDebugLedNumGet - Get number of debug Leds
+*
+* DESCRIPTION:
+* INPUT:
+*       boardId
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_U32 mvBoardDebugLedNumGet(MV_U32 boardId)
+{
+	return board->activeLedsNumber;
+}
+
+/*******************************************************************************
+* mvBoardDebugLed - Set the board debug Leds
+*
+* DESCRIPTION: turn on/off status leds.
+*              Note: assume MPP leds are part of group 0 only.
+*
+* INPUT:
+*       hexNum - Number to be displied in hex by Leds.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvBoardDebugLed(MV_U32 hexNum)
+{
+	/* empty */
+}
+
+/*******************************************************************************
+* mvBoarGpioPinNumGet
+*
+* DESCRIPTION:
+*
+* INPUT:
+*	gppClass - MV_BOARD_GPP_CLASS enum.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*       GPIO pin number. The function return -1 for bad parameters.
+*
+*******************************************************************************/
+MV_32 mvBoarGpioPinNumGet(MV_BOARD_GPP_CLASS gppClass, MV_U32 index)
+{
+	MV_U32 i, indexFound = 0;
+
+	for (i = 0; i < board->numBoardGppInfo; i++) {
+		if (board->pBoardGppInfo[i].devClass == gppClass) {
+			if (indexFound == index)
+				return (MV_U32)board->pBoardGppInfo[i].gppPinNum;
+			else
+				indexFound++;
+		}
+	}
+
+	return MV_ERROR;
+}
+
+/*******************************************************************************
+* mvBoardReset
+*
+* DESCRIPTION:
+*	Reset the board
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*       None
+*
+*******************************************************************************/
+MV_VOID mvBoardReset(MV_VOID)
+{
+	MV_32 resetPin;
+
+	/* Get gpp reset pin if define */
+	resetPin = mvBoardResetGpioPinGet();
+	if (resetPin != MV_ERROR)
+		MV_REG_BIT_RESET(GPP_DATA_OUT_REG((int)(resetPin/32)), (1 << (resetPin % 32)));
+	else
+	{
+		/* No gpp reset pin was found, try to reset using system reset out */
+		MV_REG_BIT_SET( CPU_RSTOUTN_MASK_REG , BIT0);
+		MV_REG_BIT_SET( CPU_SYS_SOFT_RST_REG , BIT0);
+	}
+}
+
+/*******************************************************************************
+* mvBoardResetGpioPinGet
+*
+* DESCRIPTION:
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*       GPIO pin number. The function return -1 for bad parameters.
+*
+*******************************************************************************/
+MV_32 mvBoardResetGpioPinGet(MV_VOID)
+{
+	return mvBoarGpioPinNumGet(BOARD_GPP_RESET, 0);
+}
+
+/*******************************************************************************
+* mvBoardSDIOGpioPinGet
+*
+* DESCRIPTION:
+*	used for hotswap detection
+* INPUT:
+*	type - Type of SDIO GPP to get.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*       GPIO pin number. The function return -1 for bad parameters.
+*
+*******************************************************************************/
+MV_32 mvBoardSDIOGpioPinGet(MV_BOARD_GPP_CLASS type)
+{
+	if (type != BOARD_GPP_SDIO_POWER &&
+	    type != BOARD_GPP_SDIO_DETECT &&
+	    type != BOARD_GPP_SDIO_WP)
+		return MV_FAIL;
+
+	return mvBoarGpioPinNumGet(type, 0);
+}
+
+/*******************************************************************************
+* mvBoardUSBVbusGpioPinGet - return Vbus input GPP
+*
+* DESCRIPTION:
+*
+* INPUT:
+*		int  devNo.
+*
+* OUTPUT:
+*		None.
+*
+* RETURN:
+*       GPIO pin number. The function return -1 for bad parameters.
+*
+*******************************************************************************/
+MV_32 mvBoardUSBVbusGpioPinGet(MV_32 devId)
+{
+	return mvBoarGpioPinNumGet(BOARD_GPP_USB_VBUS, devId);
+}
+
+/*******************************************************************************
+* mvBoardUSBVbusEnGpioPinGet - return Vbus Enable output GPP
+*
+* DESCRIPTION:
+*
+* INPUT:
+*		int  devNo.
+*
+* OUTPUT:
+*		None.
+*
+* RETURN:
+*       GPIO pin number. The function return -1 for bad parameters.
+*
+*******************************************************************************/
+MV_32 mvBoardUSBVbusEnGpioPinGet(MV_32 devId)
+{
+	return mvBoarGpioPinNumGet(BOARD_GPP_USB_VBUS_EN, devId);
+}
+
+/*******************************************************************************
+* mvBoardGpioIntMaskGet - Get GPIO mask for interrupt pins
+*
+* DESCRIPTION:
+*		This function returns a 32-bit mask of GPP pins that connected to
+*		interrupt generating sources on board.
+*		For example if UART channel A is hardwired to GPP pin 8 and
+*		UART channel B is hardwired to GPP pin 4 the fuinction will return
+*		the value 0x000000110
+*
+* INPUT:
+*		None.
+*
+* OUTPUT:
+*		None.
+*
+* RETURN:
+*		See description. The function return -1 if board is not identified.
+*
+*******************************************************************************/
+MV_U32 mvBoardGpioIntMaskGet(MV_U32 gppGrp)
+{
+	switch (gppGrp) {
+	case 0:
+		return board->intsGppMaskLow;
+		break;
+	case 1:
+		return board->intsGppMaskMid;
+		break;
+	case 2:
+		return board->intsGppMaskHigh;
+		break;
+	default:
+		return MV_ERROR;
+	}
+}
+
+/*******************************************************************************
+* mvBoardSlicMppModeGet - Get board MPP Group type for SLIC unit (pre-defined)
+*
+* DESCRIPTION:
+*	if not using auto detection mudules according to board configuration settings,
+*	use pre-defined SLIC type from board information
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit value describing MPP control register value.
+*
+*******************************************************************************/
+MV_U32 mvBoardSlicUnitTypeGet(MV_VOID)
+{
+	return board->pBoardModTypeValue->boardMppSlic;
+}
+
+/*******************************************************************************
+* mvBoardSlicUnitTypeSet - Get board MPP Group type for SLIC unit (pre-defined)
+*
+* DESCRIPTION:
+*	if not using auto detection mudules according to board configuration settings,
+*	use pre-defined SLIC type from board information
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit value describing MPP control register value.
+*
+*******************************************************************************/
+MV_VOID mvBoardSlicUnitTypeSet(MV_U32 slicType)
+{
+	board->pBoardModTypeValue->boardMppSlic = slicType;
+}
+/*******************************************************************************
+* mvBoardMppGet - Get board dependent MPP register value
+*
+* DESCRIPTION:
+*	MPP settings are derived from board design.
+*	MPP group consist of 8 MPPs. An MPP group represents MPP
+*	control register.
+*       This function retrieves board dependend MPP register value.
+*
+* INPUT:
+*       mppGroupNum - MPP group number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit value describing MPP control register value.
+*
+*******************************************************************************/
+MV_32 mvBoardMppGet(MV_U32 mppGroupNum)
+{
+	return board->pBoardMppConfigValue->mppGroup[mppGroupNum];
+}
+
+/*******************************************************************************
+* mvBoardMppSet - Set board dependent MPP register value
+*
+* DESCRIPTION:
+*	This function updates board dependend MPP register value.
+*
+* INPUT:
+*       mppGroupNum - MPP group number.
+*	mppValue - new MPP value to be written
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       -None
+*
+*******************************************************************************/
+MV_VOID mvBoardMppSet(MV_U32 mppGroupNum, MV_U32 mppValue)
+{
+	board->pBoardMppConfigValue->mppGroup[mppGroupNum] = mppValue;
+}
+
+/*******************************************************************************
+* mvBoardMppTypeSet - Set board dependent MPP Group Type value
+*
+* DESCRIPTION:
+*	This function updates board dependend MPP Group Type value.
+*
+* INPUT:
+*       mppGroupNum - MPP group number.
+*	groupType - new MPP Group type. derrive MPP Value using groupType
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       -None
+*
+*******************************************************************************/
+MV_VOID mvBoardMppTypeSet(MV_U32 mppGroupNum, MV_U32 groupType)
+{
+	MV_U32 mppVal;
+	MV_U32 mppGroups[MV_BOARD_MAX_MPP_GROUPS][MV_BOARD_MPP_GROUPS_MAX_TYPES] = MPP_GROUP_TYPES;
+
+	mppVal = mppGroups[mppGroupNum][groupType];
+	mvBoardMppSet(mppGroupNum,mppVal);
+
+	/* add Group types update here (if needed for later usage),
+	 * and add mvBoardMppTypeGet to detect which type is in use currently */
+}
+
+/*******************************************************************************
+* mvBoardInfoUpdate - Update Board information structures according to auto-detection.
+*
+* DESCRIPTION:
+*	Update board information according to detection using TWSI bus.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	None.
+*
+*******************************************************************************/
+MV_VOID mvBoardInfoUpdate(MV_VOID)
+{
+	MV_U32 ethComplex;
+
+	/* Update SMI phy address for MAC0/1 */
+	ethComplex = mvBoardEthComplexConfigGet();
+
+	if (ethComplex & MV_ETHCOMP_GE_MAC0_2_RGMII0)
+		mvBoardPhyAddrSet(0, 0x0);
+	else
+		mvBoardPhyAddrSet(0, -1); /* no SMI address if connected to switch */
+
+	/* Update MPP group types and values according to board configuration */
+	mvBoardMppIdUpdate();
+
+}
+
+/*******************************************************************************
+* mvBoardMppIdUpdate - Update MPP ID's according to modules auto-detection.
+*
+* DESCRIPTION:
+*	Update MPP ID's according to boot source
+*	Update board information for changed mpp values
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	None.
+*
+*******************************************************************************/
+MV_VOID mvBoardMppIdUpdate(MV_VOID)
+{
+	/* MPP Groups initialization : */
+	/* Set Group 0-1 - Boot device (else if booting from SPI1: Set Groups 3-4) */
+	mvBoardBootDeviceGroupSet();
+}
+
+
+/*******************************************************************************
+* mvBoardBootDeviceGroupSet - test board Boot configuration and set MPP groups
+*
+* DESCRIPTION:
+*   read board BOOT configuration and set MPP groups accordingly
+*	-  Sets groups 0-1 for NAND or SPI0 Boot
+*	   Or   groups 3-4 for SPI1 Boot
+*	- return Selected boot device
+*
+* INPUT:
+*
+* OUTPUT:  None.
+*
+* RETURN:
+*       the selected MV_BOARD_BOOT_SRC
+*
+*******************************************************************************/
+MV_BOARD_BOOT_SRC mvBoardBootDeviceGroupSet()
+{
+	MV_BOARD_BOOT_SRC bootSrc = mvBoardBootDeviceGet();
+
+	switch (bootSrc) {
+	case MSAR_0_BOOT_NAND_NEW:
+		mvBoardMppTypeSet(0, NAND_BOOT_V2);
+		mvBoardMppTypeSet(1, NAND_BOOT_V2);
+		break;
+	case MSAR_0_BOOT_SPI_FLASH:
+		mvBoardMppTypeSet(0, SPI0_BOOT);
+		mvBoardMppTypeSet(1, SPI0_BOOT);
+		break;
+	default:
+		return MV_ERROR;
+	}
+	return bootSrc;
+}
+
+/*******************************************************************************
+* mvBoardBootDeviceGet -   Get the Selected S@R boot device
+*
+* DESCRIPTION:
+*   read board BOOT configuration from S@R and return Boot device accordingly
+*
+* INPUT:
+*
+* OUTPUT:  None.
+*
+* RETURN:
+*       the selected MV_BOARD_BOOT_SRC
+*
+*******************************************************************************/
+MV_BOARD_BOOT_SRC mvBoardBootDeviceGet()
+{
+	MV_U32 satrBootDeviceValue = mvCtrlSatRRead(MV_SATR_BOOT_DEVICE);
+	MV_SATR_BOOT_TABLE satrTable[] = MV_SATR_TABLE_VAL;
+	MV_SATR_BOOT_TABLE satrBootEntry = satrTable[satrBootDeviceValue];
+
+	if (satrBootEntry.bootSrc != MSAR_0_BOOT_SPI_FLASH)
+		return satrBootEntry.bootSrc;
+
+	/* if boot source is SPI ,verify which CS (0/1) */
+	if (mvBoardBootAttrGet(satrBootDeviceValue, 1) == MSAR_0_SPI0)
+		return MSAR_0_BOOT_SPI_FLASH;
+	else
+		return MSAR_0_BOOT_SPI1_FLASH;
+}
+
+/*******************************************************************************
+* mvBoardBootAttrGet -  Get the selected S@R Boot device attributes[1/2/3]
+*
+* DESCRIPTION:
+*   read board BOOT configuration and return attributes accordingly
+*
+* INPUT:  satrBootDevice - BOOT_DEVICE value from S@R.*
+*         attrNum - attribute number [1/2/3]
+* OUTPUT:  None.
+*
+* RETURN:
+*       the selected attribute value
+*
+*******************************************************************************/
+MV_U32 mvBoardBootAttrGet(MV_U32 satrBootDeviceValue, MV_U8 attrNum)
+{
+	MV_SATR_BOOT_TABLE satrTable[] = MV_SATR_TABLE_VAL;
+	MV_SATR_BOOT_TABLE satrBootEntry = satrTable[satrBootDeviceValue];
+
+	switch (attrNum) {
+	case 1:
+		return satrBootEntry.attr1;
+		break;
+	case 2:
+		return satrBootEntry.attr2;
+		break;
+	case 3:
+		return satrBootEntry.attr3;
+		break;
+	default:
+		return MV_ERROR;
+	}
+}
+
+/*******************************************************************************
+* mvBoardIsLaneSGMII - check if a board lane is configured to SGMII-0
+*
+* DESCRIPTION:
+*	test board configuration regarding lanes-1/2/3
+*	if one of them is configured to SGMII-0 , will return its MV_ETH_COMPLEX_TOPOLOGY define
+*	else return error
+*
+* INPUT:  None.
+*
+* OUTPUT:  None.
+*
+* RETURN:
+*       value =MV_ETH_COMPLEX_GE_MAC0_COMPHY_1/2/3 if lanes 1/2/3 are SGMII-0 (adaptively)
+*       or -1 if none of them is SGMII-0
+*
+*******************************************************************************/
+MV_ETH_COMPLEX_TOPOLOGY mvBoardLaneSGMIIGet()
+{
+	MV_U32 laneConfig;
+	/* Lane 1 */
+	laneConfig = mvCtrlSysConfigGet(MV_CONFIG_LANE1);
+	if (laneConfig == MV_ERROR)
+		return MV_ERROR;
+	else if (laneConfig == 0x1)
+		return MV_ETHCOMP_GE_MAC0_2_COMPHY_1;
+	/* Lane 2 */
+	laneConfig = mvCtrlSysConfigGet(MV_CONFIG_LANE2);
+	if (laneConfig == MV_ERROR)
+		return MV_ERROR;
+	else if (laneConfig == 0x0)
+		return MV_ETHCOMP_GE_MAC0_2_COMPHY_2;
+	/* Lane 3 */
+	laneConfig = mvCtrlSysConfigGet(MV_CONFIG_LANE3);
+	if (laneConfig == MV_ERROR)
+		return MV_ERROR;
+	else if (laneConfig == 0x1)
+		return MV_ETHCOMP_GE_MAC0_2_COMPHY_3;
+
+	mvOsPrintf("%s: Error: unexpected value for Serdes Lane board configuration\n", __func__);
+	return MV_ERROR;
+}
+
+/*******************************************************************************
+* mvBoardIsInternalSwitchConnectedToPort
+*
+* DESCRIPTION:
+*       This routine returns port's connection status
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       1 - if ethPortNum is connected to switch, 0 otherwise
+*
+*******************************************************************************/
+MV_STATUS mvBoardIsInternalSwitchConnectedToPort(MV_U32 ethPortNum)
+{
+	MV_U32 ethComplex = mvBoardEthComplexConfigGet();
+
+	if (ethPortNum >= board->numBoardMacInfo) {
+		mvOsPrintf("%s: Error: Illegal port number(%u)\n", __func__, ethPortNum);
+		return MV_FALSE;
+	}
+
+	/* Check if internal switch is connected */
+	if ((ethPortNum == 0) && (ethComplex & MV_ETHCOMP_GE_MAC0_2_SW_P6))
+		return MV_TRUE;
+	else if ((ethPortNum == 1) && (ethComplex & MV_ETHCOMP_GE_MAC1_2_SW_P4))
+		return MV_TRUE;
+	else
+		return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvBoardIsInternalSwitchConnected
+*
+* DESCRIPTION:
+*       This routine returns port's connection status
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       1 - if ethPortNum is connected to switch, 0 otherwise
+*
+*******************************************************************************/
+MV_STATUS mvBoardIsInternalSwitchConnected(void)
+{
+	MV_U32 ethComplex = mvBoardEthComplexConfigGet();
+
+	if ((ethComplex & MV_ETHCOMP_GE_MAC0_2_SW_P6) ||
+	    (ethComplex & MV_ETHCOMP_GE_MAC1_2_SW_P4))
+		return MV_TRUE;
+	else
+		return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvBoardSwitchConnectedPortGet -
+*
+* DESCRIPTION:
+*       This routine returns the switch port connected to the ethPort
+*
+* INPUT:
+*       ethPortNum - Ethernet port number.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	switch port connected to the ethPort
+*
+*******************************************************************************/
+MV_32 mvBoardSwitchConnectedPortGet(MV_U32 ethPort)
+{
+	MV_U32 ethComplex = mvBoardEthComplexConfigGet();
+
+	if (ethPort >= board->numBoardMacInfo) {
+		mvOsPrintf("%s: Error: Illegal port number(%u)\n", __func__, ethPort);
+		return MV_FALSE;
+	}
+
+	if ((ethPort == 0) && (ethComplex & MV_ETHCOMP_GE_MAC0_2_SW_P6))
+		return 6;
+	else if ((ethPort == 1) && (ethComplex & MV_ETHCOMP_GE_MAC1_2_SW_P4))
+		return 4;
+	else
+		return -1;
+
+}
+
+/*******************************************************************************
+* mvBoardSwitchPortsMaskGet -
+*
+* DESCRIPTION:
+*       This routine returns a mask describing all the connected switch ports
+*
+* INPUT:
+*       switchIdx - index of the switch. Only 0 is supported.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_U32 mvBoardSwitchPortsMaskGet(MV_U32 switchIdx)
+{
+	MV_U32 mask = 0, c = mvBoardEthComplexConfigGet();
+
+	if (c & MV_ETHCOMP_SW_P0_2_GE_PHY_P0)
+		mask |= BIT0;
+	if (c & MV_ETHCOMP_SW_P1_2_GE_PHY_P1)
+		mask |= BIT1;
+	if (c & MV_ETHCOMP_SW_P2_2_GE_PHY_P2)
+		mask |= BIT2;
+	if (c & MV_ETHCOMP_SW_P3_2_GE_PHY_P3)
+		mask |= BIT3;
+	if ((c & MV_ETHCOMP_SW_P4_2_RGMII0) || (c & MV_ETHCOMP_GE_MAC1_2_SW_P4))
+		mask |= BIT4;
+	if (c & MV_ETHCOMP_GE_MAC0_2_SW_P6)
+		mask |= BIT6;
+
+	return mask;
+}
+
+/*******************************************************************************
+* mvBoardSwitchPortForceLinkGet
+*
+* DESCRIPTION:
+*       Return the switch ports force link bitmask.
+*
+* INPUT:
+*       switchIdx - index of the switch. Only 0 is supported.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       the ports bitmask, -1 if the switch is not connected.
+*
+*******************************************************************************/
+MV_U32 mvBoardSwitchPortForceLinkGet(MV_U32 switchIdx)
+{
+	return board->switchforceLinkMask;
+}
+
+/*******************************************************************************
+* mvBoardFreqModesNumGet
+*
+* DESCRIPTION:
+*      Return the number of supported frequency modes for this board
+*
+*
+* INPUT:
+*      None.
+*
+* OUTPUT:
+*      None.
+*
+* RETURN:
+*      Number of supported frequency modes
+*
+*******************************************************************************/
+MV_U32 mvBoardFreqModesNumGet()
+{
+	MV_U16 ctrlModel = mvCtrlModelGet();
+
+	if (ctrlModel == MV_6720_DEV_ID)
+		return FREQ_MODES_NUM_6720;
+
+	mvOsPrintf("%s: Error: Illegal ctrl Model (%x)\n", __func__, ctrlModel);
+	return MV_ERROR;
+}
+
+
+/*******************************************************************************
+* mvBoardConfigWrite - write MPP's config and Board general environment configuration
+*
+* DESCRIPTION:
+*       This function writes the environment information that was initialized
+*       by mvBoardConfigInit, such as MPP settings, Mux configuration,
+*       and Board specific initializations.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvBoardConfigWrite(void)
+{
+	MV_U32 mppGroup, i, reg;
+	MV_BOARD_SPEC_INIT *boardSpec;
+
+	for (mppGroup = 0; mppGroup < MV_MPP_MAX_GROUP; mppGroup++) {
+		MV_REG_WRITE(mvCtrlMppRegGet(mppGroup), mvBoardMppGet(mppGroup));
+	}
+
+	boardSpec = mvBoardSpecInitGet();
+	if (boardSpec != NULL) {
+		i = 0;
+		while (boardSpec[i].reg != TBL_TERM) {
+			reg = MV_REG_READ(boardSpec[i].reg);
+			reg &= ~boardSpec[i].mask;
+			reg |= (boardSpec[i].val & boardSpec[i].mask);
+			MV_REG_WRITE(boardSpec[i].reg, reg);
+			i++;
+		}
+	}
+}
+
+/*******************************************************************************
+* mvBoardGppConfigGet
+*
+* DESCRIPTION:
+*	Get board configuration according to the input configuration GPP's.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	The value of the board configuration GPP's.
+*
+*******************************************************************************/
+MV_U32 mvBoardGppConfigGet(void)
+{
+	MV_U32 gpp, i, result = 0;
+
+	for (i = 0; i < board->numBoardGppInfo; i++) {
+		if (board->pBoardGppInfo[i].devClass == BOARD_GPP_CONF) {
+			gpp = board->pBoardGppInfo[i].gppPinNum;
+			result <<= 1;
+			result |= (mvGppValueGet(gpp >> 5, 1 << (gpp & 0x1F)) >> (gpp & 0x1F));
+		}
+	}
+
+	return result;
+}
+
+/*******************************************************************************
+* mvBoardTdmSpiModeGet - return SLIC/DAA connection
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_32 mvBoardTdmSpiModeGet(MV_VOID)
+{
+	return 0;
+}
+
+/*******************************************************************************
+* mvBoardTdmDevicesCountGet
+*
+* DESCRIPTION:
+*	Return the number of TDM devices on board.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	Number of devices.
+*
+*******************************************************************************/
+MV_U8 mvBoardTdmDevicesCountGet(void)
+{
+	MV_16 index = board->boardTdmInfoIndex;
+
+	if (index == -1)
+		return 0;
+
+	return board->numBoardTdmInfo[index];
+}
+
+/*******************************************************************************
+* mvBoardTdmSpiCsGet
+*
+* DESCRIPTION:
+*	Return the SPI Chip-select number for a given device.
+*
+* INPUT:
+*	devId	- The Slic device ID to get the SPI CS for.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	The SPI CS if found, -1 otherwise.
+*
+*******************************************************************************/
+MV_U8 mvBoardTdmSpiCsGet(MV_U8 devId)
+{
+	MV_16 index;
+
+	index = board->boardTdmInfoIndex;
+	if (index == -1)
+		return 0;
+
+	if (devId >= board->numBoardTdmInfo[index])
+		return -1;
+
+	return board->pBoardTdmInt2CsInfo[index][devId].spiCs;
+}
+
+/*******************************************************************************
+* mvBoardMppModuleTypePrint
+*
+* DESCRIPTION:
+*	Print on-board detected modules.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	None.
+*
+*******************************************************************************/
+MV_VOID mvBoardMppModuleTypePrint(MV_VOID)
+{
+	MV_U32 ethConfig = mvBoardEthComplexConfigGet();
+
+	mvOsOutput("Board configuration detected:\n");
+
+	/* TDM */
+	if (mvBoardTdmDevicesCountGet() > 0)
+		mvOsOutput("       TDM module.\n");
+
+	/* LCD DVI Module */
+	if (mvBoardIsLcdDviModuleConnected())
+		mvOsOutput("       LCD DVI module.\n");
+
+	/* Switch Module */
+	if ((ethConfig & MV_ETHCOMP_GE_MAC0_2_SW_P6) &&
+		!(ethConfig & MV_ETHCOMP_GE_MAC1_2_SW_P4))
+		mvOsOutput("       Ethernet Switch port 6 on MAC0 [Default]\n");
+	else if ((ethConfig & MV_ETHCOMP_GE_MAC1_2_SW_P4) &&
+		!(ethConfig & MV_ETHCOMP_GE_MAC0_2_SW_P6))
+		mvOsOutput("       Ethernet Switch port 4 on MAC1 [Default]\n");
+	else if ((ethConfig & MV_ETHCOMP_GE_MAC0_2_SW_P6) &&
+		(ethConfig & MV_ETHCOMP_GE_MAC1_2_SW_P4)) {
+		mvOsOutput("       Ethernet Switch port 6 on MAC0 [Default]\n");
+		mvOsOutput("       Ethernet Switch port 4 on MAC1\n");
+	}
+
+	/* RGMII */
+	if (ethConfig & MV_ETHCOMP_GE_MAC0_2_RGMII0)
+		mvOsOutput("       RGMII0 Module on MAC0\n");
+	if (ethConfig & MV_ETHCOMP_GE_MAC1_2_RGMII1)
+		mvOsOutput("       RGMII1 on MAC1\n");
+	if (ethConfig & MV_ETHCOMP_SW_P4_2_RGMII0)
+		mvOsOutput("       RGMII0 Module on Switch port #4\n");
+
+	/* Internal GE Quad Phy */
+	if (ethConfig & MV_ETHCOMP_GE_MAC0_2_GE_PHY_P0)
+			mvOsOutput("       GE-PHY-0 on MAC0\n");
+	if (ethConfig & MV_ETHCOMP_GE_MAC1_2_GE_PHY_P3)
+			mvOsOutput("       GE-PHY-3 on MAC1\n");
+	if ((ethConfig & MV_ETHCOMP_SW_P0_2_GE_PHY_P0) && (ethConfig & MV_ETHCOMP_SW_P1_2_GE_PHY_P1)
+		&& (ethConfig & MV_ETHCOMP_SW_P2_2_GE_PHY_P2) && (ethConfig & MV_ETHCOMP_SW_P3_2_GE_PHY_P3))
+			mvOsOutput("       4xGE-PHY Module on 4 Switch ports\n");
+	else {
+		if (ethConfig & MV_ETHCOMP_SW_P0_2_GE_PHY_P0)
+			mvOsOutput("       GE-PHY-0 Module on Switch port #0\n");
+		if (ethConfig & MV_ETHCOMP_SW_P1_2_GE_PHY_P1)
+			mvOsOutput("       GE-PHY-1 Module on Switch port #1\n");
+		if (ethConfig & MV_ETHCOMP_SW_P2_2_GE_PHY_P2)
+			mvOsOutput("       GE-PHY-2 Module on Switch port #2\n");
+		if (ethConfig & MV_ETHCOMP_SW_P3_2_GE_PHY_P3)
+			mvOsOutput("       GE-PHY-3 Module on Switch port #3\n");
+	}
+
+
+
+
+}
+
+MV_VOID mvBoardOtherModuleTypePrint(MV_VOID)
+{
+	/* Pex Module */
+	if (mvBoardIsPexModuleConnected())
+		mvOsOutput("       PEX module.\n");
+	/* SETM Module */
+	if (mvBoardIsSetmModuleConnected())
+		mvOsOutput("       SETM module.\n");
+	/* LVDS Module */
+	if (mvBoardIsLvdsModuleConnected())
+		mvOsOutput("       LVDS module.\n");
+}
+
+/*******************************************************************************
+* mvBoardIsGbEPortConnected
+*
+* DESCRIPTION:
+*	Checks if a given GbE port is actually connected to the GE-PHY, internal Switch or any RGMII module.
+*
+* INPUT:
+*	port - GbE port number (0 or 1).
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	MV_TRUE if port is connected, MV_FALSE otherwise.
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsGbEPortConnected(MV_U32 ethPortNum)
+{
+	return MV_FALSE;
+}
+
+/* Board devices API managments */
+
+/*******************************************************************************
+* mvBoardGetDeviceNumber - Get number of device of some type on the board
+*
+* DESCRIPTION:
+*
+* INPUT:
+*		devType - The device type ( Flash,RTC , etc .. )
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       If the device is found on the board the then the functions returns the
+*		number of those devices else the function returns 0
+*
+*
+*******************************************************************************/
+MV_32 mvBoardGetDevicesNumber(MV_BOARD_DEV_CLASS devClass)
+{
+	MV_U32 foundIndex = 0, devNum;
+
+	for (devNum = START_DEV_CS; devNum < board->numBoardDeviceIf; devNum++)
+		if (board->pDevCsInfo[devNum].devClass == devClass)
+			foundIndex++;
+
+	return foundIndex;
+}
+
+/*******************************************************************************
+* mvBoardGetDeviceBaseAddr - Get base address of a device existing on the board
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       devIndex - The device sequential number on the board
+*		devType - The device type ( Flash,RTC , etc .. )
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       If the device is found on the board the then the functions returns the
+*	Base address else the function returns 0xffffffff
+*
+*
+*******************************************************************************/
+MV_32 mvBoardGetDeviceBaseAddr(MV_32 devNum, MV_BOARD_DEV_CLASS devClass)
+{
+	MV_DEV_CS_INFO *devEntry = boardGetDevEntry(devNum, devClass);
+
+	if (devEntry)
+		return mvCpuIfTargetWinBaseLowGet(DEV_TO_TARGET(devEntry->deviceCS));
+
+	return 0xFFFFFFFF;
+}
+
+/*******************************************************************************
+* mvBoardGetDeviceBusWidth - Get Bus width of a device existing on the board
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       devIndex - The device sequential number on the board
+*		devType - The device type ( Flash,RTC , etc .. )
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       If the device is found on the board the then the functions returns the
+*		Bus width else the function returns 0xffffffff
+*
+*
+*******************************************************************************/
+MV_32 mvBoardGetDeviceBusWidth(MV_32 devNum, MV_BOARD_DEV_CLASS devClass)
+{
+	MV_DEV_CS_INFO *devEntry = boardGetDevEntry(devNum, devClass);
+
+	if (devEntry)
+		return devEntry->busWidth;
+
+	return 0xFFFFFFFF;
+}
+
+/*******************************************************************************
+* mvBoardGetDeviceWidth - Get dev width of a device existing on the board
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       devIndex - The device sequential number on the board
+*		devType - The device type ( Flash,RTC , etc .. )
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       If the device is found on the board the then the functions returns the
+*		dev width else the function returns 0xffffffff
+*
+*
+*******************************************************************************/
+MV_32 mvBoardGetDeviceWidth(MV_32 devNum, MV_BOARD_DEV_CLASS devClass)
+{
+	MV_DEV_CS_INFO *devEntry = boardGetDevEntry(devNum, devClass);
+
+	if (devEntry)
+		return devEntry->devWidth;
+
+	return MV_ERROR;
+}
+
+/*******************************************************************************
+* mvBoardGetDeviceWinSize - Get the window size of a device existing on the board
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       devIndex - The device sequential number on the board
+*		devType - The device type ( Flash,RTC , etc .. )
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       If the device is found on the board the then the functions returns the
+*		window size else the function returns 0xffffffff
+*
+*
+*******************************************************************************/
+MV_32 mvBoardGetDeviceWinSize(MV_32 devNum, MV_BOARD_DEV_CLASS devClass)
+{
+	MV_DEV_CS_INFO *devEntry = boardGetDevEntry(devNum, devClass);
+
+	if (devEntry)
+		return mvCpuIfTargetWinSizeGet(DEV_TO_TARGET(devEntry->deviceCS));
+
+	return 0xFFFFFFFF;
+}
+
+/*******************************************************************************
+* boardGetDevEntry - returns the entry pointer of a device on the board
+*
+* DESCRIPTION:
+*
+* INPUT:
+*	devIndex - The device sequential number on the board
+*	devType - The device type ( Flash,RTC , etc .. )
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	If the device is found on the board the then the functions returns the
+*	dev number else the function returns 0x0
+*
+*******************************************************************************/
+static MV_DEV_CS_INFO *boardGetDevEntry(MV_32 devNum, MV_BOARD_DEV_CLASS devClass)
+{
+	MV_U32 foundIndex = 0, devIndex;
+
+	for (devIndex = START_DEV_CS; devIndex < board->numBoardDeviceIf; devIndex++) {
+		if (board->pDevCsInfo[devIndex].devClass == devClass) {
+			if (foundIndex == devNum)
+				return &(board->pDevCsInfo[devIndex]);
+			foundIndex++;
+		}
+	}
+
+	/* device not found */
+	return NULL;
+}
+
+/*******************************************************************************
+* boardGetDevCSNum
+*
+* DESCRIPTION:
+*	Return the device's chip-select number.
+*
+* INPUT:
+*	devIndex - The device sequential number on the board
+*	devType - The device type ( Flash,RTC , etc .. )
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	If the device is found on the board the then the functions returns the
+*	dev number else the function returns 0x0
+*
+*******************************************************************************/
+MV_U32 boardGetDevCSNum(MV_32 devNum, MV_BOARD_DEV_CLASS devClass)
+{
+	MV_DEV_CS_INFO *devEntry = boardGetDevEntry(devNum, devClass);
+
+	if (devEntry)
+		return devEntry->deviceCS;
+
+	return 0xFFFFFFFF;
+}
+
+/*******************************************************************************
+* mvBoardTwsiAddrTypeGet
+*
+* DESCRIPTION:
+*	Return the TWSI address type for a given twsi device class.
+*
+* INPUT:
+*	twsiClass - The TWSI device to return the address type for.
+*	index	  - The TWSI device index (Pass 0 in case of a single
+*		    device)
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	The TWSI address type.
+*
+*******************************************************************************/
+MV_U8 mvBoardTwsiAddrTypeGet(MV_BOARD_TWSI_CLASS twsiClass, MV_U32 index)
+{
+	int i;
+	MV_U32 indexFound = 0;
+
+	for (i = 0; i < board->numBoardTwsiDev; i++) {
+		if (board->pBoardTwsiDev[i].devClass == twsiClass) {
+			if (indexFound == index)
+				return board->pBoardTwsiDev[i].twsiDevAddrType;
+			else
+				indexFound++;
+		}
+	}
+	DB(mvOsPrintf("%s: Error: read TWSI address type failed\n", __func__));
+	return MV_ERROR;
+}
+
+/*******************************************************************************
+* mvBoardTwsiAddrGet
+*
+* DESCRIPTION:
+*	Return the TWSI address for a given twsi device class.
+*
+* INPUT:
+*	twsiClass - The TWSI device to return the address type for.
+*	index	  - The TWSI device index (Pass 0 in case of a single
+*		    device)
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	The TWSI address.
+*
+*******************************************************************************/
+MV_U8 mvBoardTwsiAddrGet(MV_BOARD_TWSI_CLASS twsiClass, MV_U32 index)
+{
+	int i;
+
+	for (i = 0; i < board->numBoardTwsiDev; i++) {
+		if ((board->pBoardTwsiDev[i].devClass == twsiClass) \
+				&& (board->pBoardTwsiDev[i].devClassId == index)){
+			return board->pBoardTwsiDev[i].twsiDevAddr;
+		}
+	}
+
+	return 0xFF;
+}
+
+/*******************************************************************************
+* mvBoardEthComplexConfigGet - Return ethernet complex board configuration.
+*
+* DESCRIPTION:
+*	Returns the ethernet / Sata complex configuration from the board spec
+*	structure.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit value describing the ethernet complex config.
+*
+*******************************************************************************/
+MV_U32 mvBoardEthComplexConfigGet(MV_VOID)
+{
+	return board->pBoardModTypeValue->ethSataComplexOpt;
+}
+
+/*******************************************************************************
+* mvBoardEthComplexConfigSet - Set ethernet complex board configuration.
+*
+* DESCRIPTION:
+*	Sets the ethernet / Sata complex configuration in the board spec
+*	structure.
+*
+* INPUT:
+*       ethConfig - 32bit value describing the ethernet complex config.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	None.
+*
+*******************************************************************************/
+MV_VOID mvBoardEthComplexConfigSet(MV_U32 ethConfig)
+{
+	/* Set ethernet complex configuration. */
+	board->pBoardModTypeValue->ethSataComplexOpt = ethConfig;
+	return;
+}
+
+/*******************************************************************************
+* mvBoardSatrInfoConfig
+*
+* DESCRIPTION:
+*	Return the SAR fields information for a given SAR class.
+*
+* INPUT:
+*	satrClass - The SATR field to return the information for.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	MV_BOARD_SATR_INFO struct with mask, offset and register number.
+*
+*******************************************************************************/
+MV_STATUS mvBoardSatrInfoConfig(MV_SATR_TYPE_ID satrClass, MV_BOARD_SATR_INFO *satrInfo, MV_BOOL read)
+{
+	int i, start, end;
+	MV_U32 boardId = mvBoardIdGet();
+
+	if (read == MV_TRUE) {	/* if read request, check read SATR fields */
+		start = 0;
+		end = MV_SATR_READ_MAX_OPTION;
+	} else {		/* if write request, check write SATR fields */
+		start = MV_SATR_READ_MAX_OPTION;
+		end = MV_SATR_WRITE_MAX_OPTION;
+	}
+
+	/* verify existence of requested SATR type, pull its data,
+	 * and check if field is relevant to current running board */
+	for (i = start; i < end ; i++)
+		if (boardSatrInfo[i].satrId == satrClass) {
+			*satrInfo = boardSatrInfo[i];
+			if (boardSatrInfo[i].isActiveForBoard[boardId])
+				return MV_OK;
+			else
+				return MV_ERROR;
+		}
+	DB(mvOsPrintf("%s: Error: requested MV_SATR_TYPE_ID was not found (%d)\n", __func__,satrClass));
+	return MV_ERROR;
+}
+
+/*******************************************************************************
+* mvBoardConfigTypeGet
+*
+* DESCRIPTION:
+*	Return the Config type fields information for a given Config type class.
+*
+* INPUT:
+*	configClass - The Config type field to return the information for.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	MV_BOARD_CONFIG_TYPE_INFO struct with mask, offset and register number.
+*
+*******************************************************************************/
+MV_BOOL mvBoardConfigTypeGet(MV_CONFIG_TYPE_ID configClass, MV_BOARD_CONFIG_TYPE_INFO *configInfo)
+{
+	int i;
+	MV_U32 boardId = mvBoardIdGet();
+
+	/* verify existence of requested config type, pull its data,
+	 * and check if field is relevant to current running board */
+	for (i = 0; i < MV_CONFIG_TYPE_MAX_OPTION ; i++)
+		if (boardConfigTypesInfo[i].configId == configClass) {
+			*configInfo = boardConfigTypesInfo[i];
+			if (boardConfigTypesInfo[i].isActiveForBoard[boardId])
+				return MV_TRUE;
+			else
+				return MV_FALSE;
+		}
+	mvOsPrintf("%s: Error: requested MV_CONFIG_TYPE_ID was not found (%d)\n", __func__, configClass);
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvBoardExtPhyBufferSelect - enable/disable buffer status
+*
+* DESCRIPTION:
+*	This function enables/disables the buffer status.
+*
+* INPUT:
+*	enable - Boolean to indicate requested status
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	None.
+*
+*******************************************************************************/
+MV_STATUS mvBoardExtPhyBufferSelect(MV_BOOL enable)
+{
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvBoardNandWidthGet -
+*
+* DESCRIPTION: Get the width of the first NAND device in bytes
+*
+* INPUT:
+*
+* OUTPUT:
+*       None.
+*
+* RETURN: 1, 2, 4 or MV_ERROR
+*
+*
+*******************************************************************************/
+MV_32 mvBoardNandWidthGet(void)
+{
+	MV_U32 devNum;
+	MV_U32 devWidth;
+
+	for (devNum = START_DEV_CS; devNum < board->numBoardDeviceIf; devNum++) {
+		devWidth = mvBoardGetDeviceWidth(devNum, BOARD_DEV_NAND_FLASH);
+		if (devWidth != MV_ERROR)
+			return devWidth / 8;
+	}
+
+	DB(mvOsPrintf("%s: Error: NAND device was not found\n", __func__));
+	return MV_ERROR;
+}
+
+/*******************************************************************************
+* mvBoardIdSet - Set Board model
+*
+* DESCRIPTION:
+*       This function sets the board ID.
+*       Board ID is 32bit word constructed of board model (16bit) and
+*       board revision (16bit) in the following way: 0xMMMMRRRR.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       void
+*
+*******************************************************************************/
+MV_VOID mvBoardIdSet(MV_U32 boardId)
+{
+	if (boardId >= MV_MAX_BOARD_ID)
+		mvOsPrintf("%s: Error: wrong boardId (%d)\n", __func__, boardId);
+
+	board = boardInfoTbl[boardId];
+}
+
+/*******************************************************************************
+* mvBoardIdGet - Get Board model
+*
+* DESCRIPTION:
+*       This function returns board ID.
+*       Board ID is 32bit word constructed of board model (16bit) and
+*       board revision (16bit) in the following way: 0xMMMMRRRR.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit board ID number, '-1' if board is undefined.
+*
+*******************************************************************************/
+MV_U32 mvBoardIdGet(MV_VOID)
+{
+	MV_U32 boardId, value;
+	/*Fake board ID, TODO fix*/
+	return 0x0;
+
+	value = MV_REG_READ(MPP_SAMPLE_AT_RESET(1));
+	boardId = ((value & (0xF0)) >> 4);
+
+	if (boardId >= MV_MAX_BOARD_ID) {
+		mvOsPrintf("%s: Error: read wrong board (%d)\n", __func__, boardId);
+		return MV_INVALID_BOARD_ID;
+	}
+	return boardId;
+}
+
+/*******************************************************************************
+* mvBoardTwsiGet -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*	device num - one of three devices
+*	reg num - 0 or 1
+*
+* OUTPUT:
+*		None.
+*
+* RETURN:
+*		reg value
+*
+*******************************************************************************/
+MV_STATUS mvBoardTwsiGet(MV_BOARD_TWSI_CLASS twsiClass, MV_U8 devNum, MV_U8 regNum, MV_U8 *pData)
+{
+	MV_TWSI_SLAVE twsiSlave;
+	MV_TWSI_ADDR slave;
+	MV_U8 data;
+
+	/* TWSI init */
+	slave.type = ADDR7_BIT;
+	slave.address = 0;
+	mvTwsiInit(0, TWSI_SPEED, mvBoardTclkGet(), &slave, 0);
+
+	DB(mvOsPrintf("Board: TWSI Read device\n"));
+	twsiSlave.slaveAddr.address = mvBoardTwsiAddrGet(twsiClass, devNum);
+	twsiSlave.slaveAddr.type = mvBoardTwsiAddrTypeGet(twsiClass, devNum);
+
+	twsiSlave.validOffset = MV_TRUE;
+	/* Use offset as command */
+	twsiSlave.offset = regNum;
+	twsiSlave.moreThen256 = MV_FALSE;
+
+	if (MV_OK != mvTwsiRead(0, &twsiSlave, &data, 1)) {
+		mvOsPrintf("%s: Twsi Read fail\n", __func__);
+		return MV_ERROR;
+	}
+	DB(mvOsPrintf("Board: Read S@R succeded\n"));
+
+	*pData = data;
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvBoardTwsiSatRSet
+*
+* DESCRIPTION:
+*
+* INPUT:
+*	devNum - one of three devices
+*	regNum - 0 or 1
+*	regVal - value
+*
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	reg value
+*
+*******************************************************************************/
+MV_STATUS mvBoardTwsiSet(MV_BOARD_TWSI_CLASS twsiClass, MV_U8 devNum, MV_U8 regNum, MV_U8 regVal)
+{
+	MV_TWSI_SLAVE twsiSlave;
+	MV_TWSI_ADDR slave;
+
+	/* TWSI init */
+	slave.type = ADDR7_BIT;
+	slave.address = 0;
+	mvTwsiInit(0, TWSI_SPEED, mvBoardTclkGet(), &slave, 0);
+
+	/* Read MPP module ID */
+	twsiSlave.slaveAddr.address = mvBoardTwsiAddrGet(twsiClass, devNum);
+	twsiSlave.slaveAddr.type = mvBoardTwsiAddrTypeGet(twsiClass, devNum);
+	twsiSlave.validOffset = MV_TRUE;
+	DB(mvOsPrintf("%s: TWSI Write addr %x, type %x, data %x\n", __func__,
+		      twsiSlave.slaveAddr.address, twsiSlave.slaveAddr.type, regVal));
+	/* Use offset as command */
+	twsiSlave.offset = regNum;
+	twsiSlave.moreThen256 = MV_FALSE;
+	if (MV_OK != mvTwsiWrite(0, &twsiSlave, &regVal, 1)) {
+		DB(mvOsPrintf("%s: Write S@R fail\n", __func__));
+		return MV_ERROR;
+	}
+	DB(mvOsPrintf("%s: Write S@R succeded\n", __func__));
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+ * SatR Configuration functions
+ */
+
+MV_U8 mvBoardCpuCoresNumGet(MV_VOID)
+{
+	return 1;
+}
+
+/*******************************************************************************
+* End of SatR Configuration functions
+*******************************************************************************/
+
+/*******************************************************************************
+* mvBoardMppModulesScan
+*
+* DESCRIPTION:
+*	Scan for modules connected through MPP lines.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None
+*
+* RETURN:
+*       MV_STATUS - MV_OK, MV_ERROR.
+*
+*******************************************************************************/
+MV_STATUS mvBoardMppModulesScan(void)
+{
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvBoardIsPexModuleConnected
+*
+* DESCRIPTION:
+*	Check if PEX module is connected to the board.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None
+*
+* RETURN:
+*       MV_TRUE / MV_FALSE
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsPexModuleConnected(void)
+{
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvBoardIsSetmModuleConnected
+*
+* DESCRIPTION:
+*	Check if SETM module is connected to the board.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None
+*
+* RETURN:
+*       MV_TRUE / MV_FALSE
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsSetmModuleConnected(void)
+{
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvBoardIsLvdsModuleConnected
+*
+* DESCRIPTION:
+*	Check if LVDS module is connected to the board.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None
+*
+* RETURN:
+*       MV_TRUE / MV_FALSE
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsLvdsModuleConnected(void)
+{
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvBoardIsLcdDviModuleConnected
+*
+* DESCRIPTION:
+*	Check if LVDS module is connected to the board.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None
+*
+* RETURN:
+*       MV_TRUE / MV_FALSE
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsLcdDviModuleConnected(void)
+{
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvBoardTwsiMuxChannelSet
+*
+* DESCRIPTION:
+*	Set the channel number of the on-board TWSI mux.
+*
+* INPUT:
+*	chNum	- The channel number to set.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*       MV_STATUS - MV_OK, MV_ERROR.
+*
+*******************************************************************************/
+MV_STATUS mvBoardTwsiMuxChannelSet(MV_U8 muxChNum)
+{
+	return MV_ERROR;
+}
+
+/*******************************************************************************
+* mvBoardTwsiReadByteThruMux
+*
+* DESCRIPTION:
+*	Read a single byte from a TWSI device through the TWSI Mux.
+*
+* INPUT:
+*	muxChNum	- The Twsi Mux channel number to read through.
+*	chNum		- The TWSI channel number.
+*	pTwsiSlave	- The TWSI slave address.
+*	data		- Buffer to read into (1 byte).
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*       MV_STATUS - MV_OK, MV_ERROR.
+*
+*******************************************************************************/
+MV_STATUS mvBoardTwsiReadByteThruMux(MV_U8 muxChNum, MV_U8 chNum,
+				     MV_TWSI_SLAVE *pTwsiSlave, MV_U8 *data)
+{
+	return MV_ERROR;
+}
+
+/*******************************************************************************
+* mvBoardSmiScanModeGet - Get Switch SMI scan mode
+*
+* DESCRIPTION:
+*       This routine returns Switch SMI scan mode.
+*
+* INPUT:
+*       switchIdx - index of the switch. Only 0 is supported.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       1 for SMI_MANUAL_MODE, -1 if the port number is wrong or if not relevant.
+*
+*******************************************************************************/
+MV_32 mvBoardSmiScanModeGet(MV_U32 switchIdx)
+{
+	return BOARD_ETH_SWITCH_SMI_SCAN_MODE;
+}
+
+/*******************************************************************************
+* mvBoardSwitchCpuPortGet - Get the the Ethernet Switch CPU port
+*
+* DESCRIPTION:
+*	This routine returns the Switch CPU port if connected, -1 else.
+*
+* INPUT:
+*	switchIdx - index of the switch. Only 0 is supported.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	the Switch CPU port, -1 if the switch is not connected.
+*
+*******************************************************************************/
+MV_U32 mvBoardSwitchCpuPortGet(MV_U32 switchIdx)
+{
+	MV_U32 c = board->pBoardModTypeValue->ethSataComplexOpt;
+	MV_U32 cpuPort = -1;
+
+	if (c & MV_ETHCOMP_GE_MAC0_2_SW_P6)
+		cpuPort = 6;
+	else if (c & MV_ETHCOMP_GE_MAC1_2_SW_P4)
+		cpuPort = 4;
+	else
+		mvOsPrintf("%s: Error: No CPU port.\n", __func__);
+
+	return cpuPort;
+}
+
+/*******************************************************************************
+* mvBoardIsEthConnected - detect if a certain Ethernet port is active
+*
+* DESCRIPTION:
+*	This routine returns true if a certain Ethernet port is active
+*
+* INPUT:
+*	ethNum - index of the ethernet port requested
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*	MV_TRUE if the requested ethernet port is connected.
+*
+*******************************************************************************/
+MV_U32 mvBoardIsEthConnected(MV_U32 ethNum)
+{
+	if (ethNum == 0)
+		return MV_TRUE;
+
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvBoardIsQsgmiiModuleConnected
+*
+* DESCRIPTION:
+*       This routine returns whether the QSGMII module is connected or not.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if QSGMII module is connected, MV_FALSE otherwise.
+*
+*******************************************************************************/
+MV_BOOL mvBoardIsQsgmiiModuleConnected(MV_VOID)
+{
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvBoardGePhySwitchPortGet
+*
+* DESCRIPTION:
+*       This routine returns whether the internal GE PHY is connected to
+*	Switch Port 0, Switch port 5 or not connected to any Switch port.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       0 if the internal GE PHY is connected to Switch Port 0,
+*	5 if the internal GE PHY is connected to Switch Port 5,
+*	-1 otherwise.
+*
+*******************************************************************************/
+MV_32 mvBoardGePhySwitchPortGet(MV_VOID)
+{
+	return -1;
+}
+
+/*******************************************************************************
+* mvBoardRgmiiASwitchPortGet
+*
+* DESCRIPTION:
+*       This routine returns whether RGMII-A is connected to
+*	Switch Port 5, Switch port 6 or not connected to any Switch port.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       5 if the internal GE PHY is connected to Switch Port 5,
+*	6 if the internal GE PHY is connected to Switch Port 6,
+*	-1 otherwise.
+*
+*******************************************************************************/
+MV_32 mvBoardRgmiiASwitchPortGet(MV_VOID)
+{
+	return -1;
+}
+
+/*******************************************************************************
+* mvBoardSwitchPortMap
+*
+* DESCRIPTION:
+*	Map front panel connector number to switch port number.
+*
+* INPUT:
+*	switchIdx - The switch index.
+*	switchPortNum - The switch port number to get the mapping for.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	The switch port mapping.
+*	OR -1 if the port number is wrong or if not relevant.
+*
+*******************************************************************************/
+MV_32 mvBoardSwitchPortMap(MV_U32 switchIdx, MV_U32 switchPortNum)
+{
+	MV_U32 ethComplex = mvBoardEthComplexConfigGet();
+	if (switchPortNum >= BOARD_ETH_SWITCH_PORT_NUM) {
+		mvOsPrintf("%s: Error: wrong switch port number (%d)\n", __func__, switchPortNum);
+		return -1;
+	}
+
+	if ((switchPortNum == 0) && (ethComplex & MV_ETHCOMP_SW_P0_2_GE_PHY_P0))
+		return 0;
+	else if ((switchPortNum == 1) && (ethComplex & MV_ETHCOMP_SW_P1_2_GE_PHY_P1))
+		return 1;
+	else if ((switchPortNum == 2) && (ethComplex & MV_ETHCOMP_SW_P2_2_GE_PHY_P2))
+		return 2;
+	else if ((switchPortNum == 3) && (ethComplex & MV_ETHCOMP_SW_P3_2_GE_PHY_P3))
+		return 3;
+	else if ((switchPortNum == 4) && (ethComplex & MV_ETHCOMP_SW_P4_2_RGMII0))
+		return 4;
+
+	mvOsPrintf("%s: Error: switch port map not found\n", __func__);
+	return -1;
+}
+
+/*******************************************************************************
+* mvBoardPexInfoGet - Get board PEX Info
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*******************************************************************************/
+MV_BOARD_PEX_INFO *mvBoardPexInfoGet(void)
+{
+	return &board->boardPexInfo;
+}
+
+/*******************************************************************************
+* mvBoardConfigAutoDetectEnabled
+*
+* DESCRIPTION:
+*	Indicate if the board supports auto configuration and detection of
+*	modules. This is usually enabled for DB boards only.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*	None.
+*
+* RETURN:
+*       MV_TRUE if auto-config/detection is enabled.
+*	MV_FALSE otherwise.
+*
+*******************************************************************************/
+MV_BOOL mvBoardConfigAutoDetectEnabled()
+{
+	return board->configAutoDetect;
+}
diff --git a/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.h b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.h
new file mode 100644
index 0000000..2bcda7f
--- /dev/null
+++ b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvLib.h
@@ -0,0 +1,478 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+********************************************************************************
+   Marvell Commercial License Option
+
+   If you received this File from Marvell and you have entered into a commercial
+   license agreement (a "Commercial License") with Marvell, the File is licensed
+   to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+********************************************************************************
+   Marvell BSD License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File under the following licensing terms.
+   Redistribution and use in source and binary forms, with or without modification,
+   are permitted provided that the following conditions are met:
+
+*   Redistributions of source code must retain the above copyright notice,
+            this list of conditions and the following disclaimer.
+
+*   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+*   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+   ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+   ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvBoardEnvLibh
+#define __INCmvBoardEnvLibh
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* defines */
+/* The below constant macros defines the board I2C EEPROM data offsets */
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "mvSysHwConfig.h"
+#include "boardEnv/mvBoardEnvSpec.h"
+#include "twsi/mvTwsi.h"
+
+#define BOARD_ETH_SWITCH_PORT_NUM       7
+#define BOARD_ETH_SWITCH_SMI_SCAN_MODE	1	/* Use manual scanning mode */
+#define MV_BOARD_MAX_MPP                9       /* number of MPP conf registers */
+#define MV_BOARD_MAX_MPP_GROUPS         9
+#define MV_BOARD_MPP_GROUPS_MAX_TYPES   8
+#define MV_BOARD_NAME_LEN               0x20
+
+typedef enum _devBoardSlicType {
+	MV_BOARD_SLIC_DISABLED,
+	MV_BOARD_SLIC_SSI_ID, /* Lantiq Integrated SLIC */
+	MV_BOARD_SLIC_ISI_ID, /* Silicon Labs ISI Bus */
+	MV_BOARD_SLIC_ZSI_ID, /* Zarlink ZSI Bus */
+	MV_BOARD_SLIC_EXTERNAL_ID /* Cross vendor external SLIC */
+} MV_BOARD_SLIC_TYPE;
+
+typedef enum _devBoardOtherTypeClass {
+	MV_BOARD_NONE    = 0x00000000,
+	MV_BOARD_LVDS    = 0x00000001,
+	MV_BOARD_PEX     = 0x00000002,
+	MV_BOARD_SWITCH  = 0x00000004,
+	MV_BOARD_SETM    = 0x00000008,
+	MV_BOARD_UNKNOWN = 0x80000000
+} MV_BOARD_OTHER_TYPE_CLASS;
+
+/* omriii:  decide between MODULE_TYPE or MPP_TYPE */
+typedef struct _boardMppTypeInfo {
+	MV_BOARD_SLIC_TYPE boardMppSlic;
+
+	/* Ethernet / Sata complex                      */
+	/* A bitmask of MV_ETH_SATA_COMPLEX_OPTIONS     */
+	MV_U32 ethSataComplexOpt;
+	MV_U32 ethPortsMode;    /* bitmask of MV_ETH_PORT_MODE */
+} MV_BOARD_MPP_TYPE_INFO;
+
+typedef enum _devBoardClass {
+	BOARD_DEV_NOR_FLASH,
+	BOARD_DEV_NAND_FLASH,
+	BOARD_DEV_SEVEN_SEG,
+	BOARD_DEV_FPGA,
+	BOARD_DEV_SRAM,
+	BOARD_DEV_SPI_FLASH,
+	BOARD_DEV_OTHER
+} MV_BOARD_DEV_CLASS;
+
+typedef enum _devTwsiBoardClass {
+	BOARD_TWSI_RTC,
+	BOARD_DEV_TWSI_EXP,
+	BOARD_DEV_TWSI_SATR,
+	BOARD_TWSI_MUX,
+	BOARD_DEV_TWSI_EEPROM,
+	BOARD_DEV_TWSI_IO_EXPANDER,
+	BOARD_TWSI_OTHER
+} MV_BOARD_TWSI_CLASS;
+
+typedef enum _devGppBoardClass {
+	BOARD_GPP_RTC,
+	BOARD_GPP_MV_SWITCH,
+	BOARD_GPP_USB_VBUS,
+	BOARD_GPP_USB_VBUS_EN,
+	BOARD_GPP_USB_OC,
+	BOARD_GPP_USB_HOST_DEVICE,
+	BOARD_GPP_REF_CLCK,
+	BOARD_GPP_VOIP_SLIC,
+	BOARD_GPP_LIFELINE,
+	BOARD_GPP_BUTTON,
+	BOARD_GPP_TS_BUTTON_C,
+	BOARD_GPP_TS_BUTTON_U,
+	BOARD_GPP_TS_BUTTON_D,
+	BOARD_GPP_TS_BUTTON_L,
+	BOARD_GPP_TS_BUTTON_R,
+	BOARD_GPP_POWER_BUTTON,
+	BOARD_GPP_RESTOR_BUTTON,
+	BOARD_GPP_WPS_BUTTON,
+	BOARD_GPP_HDD0_POWER,
+	BOARD_GPP_HDD1_POWER,
+	BOARD_GPP_FAN_POWER,
+	BOARD_GPP_RESET,
+	BOARD_GPP_POWER_ON_LED,
+	BOARD_GPP_HDD_POWER,
+	BOARD_GPP_SDIO_POWER,
+	BOARD_GPP_SDIO_DETECT,
+	BOARD_GPP_SDIO_WP,
+	BOARD_GPP_SWITCH_PHY_INT,
+	BOARD_GPP_TSU_DIRCTION,
+	BOARD_GPP_PEX_RESET,
+	BOARD_GPP_CONF,
+	BOARD_GPP_PON_XVR_TX,
+	BOARD_GPP_SYS_LED,
+	BOARD_GPP_PON_LED,
+	BOARD_GPP_OTHER
+} MV_BOARD_GPP_CLASS;
+
+typedef struct _devCsInfo {
+	MV_U8 deviceCS;
+	MV_U32 params;
+	MV_U32 devClass;        /* MV_BOARD_DEV_CLASS */
+	MV_U8 devWidth;
+	MV_U8 busWidth;
+} MV_DEV_CS_INFO;
+
+typedef struct _boardLedInfo {
+	MV_U8 activeLedsNumber;
+	MV_U8 ledsPolarity;     /* '0' or '1' to turn on led */
+	MV_U8 *gppPinNum;       /* Pointer to GPP values */
+} MV_BOARD_LED_INFO;
+
+typedef struct _boardGppInfo {
+	MV_BOARD_GPP_CLASS devClass;
+	MV_U8 gppPinNum;
+} MV_BOARD_GPP_INFO;
+
+typedef struct _boardTwsiInfo {
+	MV_BOARD_TWSI_CLASS devClass;
+	MV_U8 devClassId;
+	MV_U8 twsiDevAddr;
+	MV_U8 twsiDevAddrType;
+} MV_BOARD_TWSI_INFO;
+
+typedef struct _boardSatrInfo {
+	MV_SATR_TYPE_ID satrId;
+	MV_U32 mask;
+	MV_U32 offset;
+	MV_U32 regNum;
+	MV_U32 isActiveForBoard[MV_MAX_BOARD_ID];
+} MV_BOARD_SATR_INFO;
+
+typedef struct _boardConfigTypesInfo {
+	MV_CONFIG_TYPE_ID configId;
+	MV_U32 mask;
+	MV_U32 offset;
+	MV_U32 expanderNum;
+	MV_U32 regNum;
+	MV_U32 isActiveForBoard[MV_MAX_BOARD_ID];
+} MV_BOARD_CONFIG_TYPE_INFO;
+
+typedef enum _boardMacSpeed {
+	BOARD_MAC_SPEED_10M,
+	BOARD_MAC_SPEED_100M,
+	BOARD_MAC_SPEED_1000M,
+	BOARD_MAC_SPEED_AUTO
+} MV_BOARD_MAC_SPEED;
+
+typedef struct _boardMacInfo {
+	MV_BOARD_MAC_SPEED boardMacSpeed;
+	MV_32 boardEthSmiAddr;
+} MV_BOARD_MAC_INFO;
+
+typedef struct _boardMppInfo {
+	MV_U32 mppGroup[MV_BOARD_MAX_MPP];
+} MV_BOARD_MPP_INFO;
+
+typedef enum {
+	BOARD_EPON_CONFIG,
+	BOARD_GPON_CONFIG,
+	BOARD_PON_NONE,
+	BOARD_PON_AUTO
+} MV_BOARD_PON_CONFIG;
+
+typedef struct {
+	MV_U8 spiCs;
+} MV_BOARD_TDM_INFO;
+
+typedef struct _boardPexInfo {
+	MV_PEX_UNIT_CFG pexUnitCfg[MV_PEX_MAX_UNIT];
+	MV_U32 boardPexIfNum;
+} MV_BOARD_PEX_INFO;
+
+typedef struct {
+	MV_U8 spiId;
+} MV_BOARD_TDM_SPI_INFO;
+
+typedef enum {
+	BOARD_TDM_SLIC_880 = 0,
+	BOARD_TDM_SLIC_792,
+	BOARD_TDM_SLIC_3215,
+	BOARD_TDM_SLIC_OTHER,
+	BOARD_TDM_SLIC_COUNT
+} MV_BOARD_TDM_SLIC_TYPE;
+
+/* Board specific initialization. Performed before initializing the SoC. */
+typedef struct {
+	MV_U32 reg;
+	MV_U32 mask;
+	MV_U32 val;
+} MV_BOARD_SPEC_INIT;
+
+typedef struct _boardInfo {
+	char boardName[MV_BOARD_NAME_LEN];
+	MV_U8 numBoardMppTypeValue;
+	MV_BOARD_MPP_TYPE_INFO *pBoardModTypeValue;
+	MV_U8 numBoardMppConfigValue;
+	MV_BOARD_MPP_INFO *pBoardMppConfigValue;
+	MV_U32 intsGppMaskLow;
+	MV_U32 intsGppMaskMid;
+	MV_U32 intsGppMaskHigh;
+	MV_U8 numBoardDeviceIf;
+	MV_DEV_CS_INFO *pDevCsInfo;
+	MV_U8 numBoardTwsiDev;
+	MV_BOARD_TWSI_INFO *pBoardTwsiDev;
+	MV_U8 numBoardMacInfo;
+	MV_BOARD_MAC_INFO *pBoardMacInfo;
+	MV_U8 numBoardGppInfo;
+	MV_BOARD_GPP_INFO *pBoardGppInfo;
+	MV_U8 activeLedsNumber;
+	MV_U8 *pLedGppPin;
+	MV_U8 ledsPolarity;     /* '0' or '1' to turn on led */
+
+	MV_U8 pmuPwrUpPolarity;
+	MV_U32 pmuPwrUpDelay;
+	/* GPP values */
+	MV_U32 gppOutEnValLow;
+	MV_U32 gppOutEnValMid;
+	MV_U32 gppOutEnValHigh;
+	MV_U32 gppOutValLow;
+	MV_U32 gppOutValMid;
+	MV_U32 gppOutValHigh;
+	MV_U32 gppPolarityValLow;
+	MV_U32 gppPolarityValMid;
+	MV_U32 gppPolarityValHigh;
+
+	/* External Switch Configuration */
+	MV_U32 switchforceLinkMask;
+
+	/* PON configuration. */
+	MV_BOARD_PON_CONFIG ponConfigValue;
+	/* TDM configuration:
+	 * We hold a different configuration array for each possible slic that
+	 * can be connected to board.
+	 * When modules are scanned, then we select the index of the relevant
+	 * slic's information array.
+	 * For RD and Customers boards we only need to initialize a single
+	 * entry of the arrays below, and set the boardTdmInfoIndex to 0.
+	 */
+	MV_U8 numBoardTdmInfo[BOARD_TDM_SLIC_COUNT];
+	MV_BOARD_TDM_INFO *pBoardTdmInt2CsInfo[BOARD_TDM_SLIC_COUNT];
+	MV_16 boardTdmInfoIndex;
+
+	/* Board specific initialization. Performed before initializing the SoC. */
+	MV_BOARD_SPEC_INIT      *pBoardSpecInit;
+	/* Deep-Idle power up delay */
+	MV_U32 deepIdlePwrUpDelay;
+
+	/* NAND init params */
+	MV_U32 nandFlashReadParams;
+	MV_U32 nandFlashWriteParams;
+	MV_U32 nandFlashControl;
+	MV_BOARD_TDM_SPI_INFO *pBoardTdmSpiInfo;
+	MV_BOARD_PEX_INFO boardPexInfo;         /* filled in runtime */
+	MV_U32 norFlashReadParams;
+	MV_U32 norFlashWriteParams;
+
+	/* Indicates if auto-detection of modules is enabled on this board. */
+	/* Set to MV_FALSE for any board that is not a DB. */
+	MV_BOOL configAutoDetect;
+} MV_BOARD_INFO;
+
+/* {{MV_CONFIG_TYPE_ID ConfigID, MV_U32 Mask,  Offset, expanderNum,  regNum,    isActiveForBoard[]}} */
+#define MV_BOARD_CONFIG_INFO { \
+	{ MV_CONFIG_MAC0,			0x3,	0,	0,	0,	{0 } },\
+	{ MV_CONFIG_MAC1,			0xC,	2,	0,	0,	{0 } },\
+	{ MV_CONFIG_PON_SERDES,			0x10,	4,	0,	0,	{0 } },\
+	{ MV_CONFIG_PON_BEN_POLARITY,	0x20,	5,	0,	0,	{0 } },\
+	{ MV_CONFIG_SGMII0_CAPACITY,	0x40,	6,	0,	0,	{0 } },\
+	{ MV_CONFIG_SGMII1_CAPACITY,	0x80,	7,	0,	0,	{0 } },\
+	{ MV_CONFIG_SLIC_TDM_DEVICE,	0x3,	0,	0,	1,	{0 } },\
+	{ MV_CONFIG_LANE1,			0xC,	2,	0,	1,	{0 } },\
+	{ MV_CONFIG_LANE2,			0x10,	4,	0,	1,	{0 } },\
+	{ MV_CONFIG_LANE3,			0X60,	5,	0,	1,	{0 } },\
+	{ MV_CONFIG_DEVICE_BUS_MODULE, 0x3,	0,	1,	0,	{0 } },\
+};
+
+
+/* Boot device bus width */
+#define MSAR_0_BOOT_DEV_BUS_WIDTH_OFFS          3
+/* Bus width field meaning for NOR/NAND */
+#define MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT          (0x0 << MSAR_0_BOOT_DEV_BUS_WIDTH_OFFS)
+#define MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT         (0x1 << MSAR_0_BOOT_DEV_BUS_WIDTH_OFFS)
+#define MSAR_0_BOOT_DEV_BUS_WIDTH_32BIT         (0x2 << MSAR_0_BOOT_DEV_BUS_WIDTH_OFFS)
+/* Bus width field meaning for SPI */
+#define MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24_16BIT  (0x1 << MSAR_0_BOOT_DEV_BUS_WIDTH_OFFS)
+#define MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT     (0x0 << MSAR_0_BOOT_DEV_BUS_WIDTH_OFFS)
+
+/* NAND page size */
+#define MSAR_0_NAND_PAGE_SZ_OFFS                11
+#define MSAR_0_NAND_PAGE_SZ_512B                (0x0 << MSAR_0_NAND_PAGE_SZ_OFFS)
+#define MSAR_0_NAND_PAGE_SZ_2KB                 (0x1 << MSAR_0_NAND_PAGE_SZ_OFFS)
+#define MSAR_0_NAND_PAGE_SZ_4KB                 (0x2 << MSAR_0_NAND_PAGE_SZ_OFFS)
+#define MSAR_0_NAND_PAGE_SZ_8KB                 (0x3 << MSAR_0_NAND_PAGE_SZ_OFFS)
+
+/* NAND ECC */
+#define MSAR_0_NAND_ECC_OFFS                    14
+#define MSAR_0_NAND_ECC_4BIT                    (0x0 << MSAR_0_NAND_ECC_OFFS)
+#define MSAR_0_NAND_ECC_8BIT                    (0x1 << MSAR_0_NAND_ECC_OFFS)
+#define MSAR_0_NAND_ECC_12BIT                   (0x2 << MSAR_0_NAND_ECC_OFFS)
+#define MSAR_0_NAND_ECC_16BIT                   (0x3 << MSAR_0_NAND_ECC_OFFS)
+
+#define MSAR_0_SPI0                             0
+#define MSAR_0_SPI1                             1
+
+MV_VOID mvBoardEnvInit(MV_VOID);
+MV_U16 mvBoardModelGet(MV_VOID);
+MV_U16 mvBoardRevGet(MV_VOID);
+MV_STATUS mvBoardNameGet(char *pNameBuff, MV_U32 size);
+MV_BOARD_SPEC_INIT *mvBoardSpecInitGet(MV_VOID);
+MV_BOOL mvBoardIsPortInSgmii(MV_U32 ethPortNum);
+MV_BOOL mvBoardIsPortInGmii(MV_U32 ethPortNum);
+MV_32 mvBoardSwitchPortMap(MV_U32 switchIdx, MV_U32 switchPortNum);
+MV_BOOL mvBoardIsPortLoopback(MV_U32 ethPortNum);
+MV_32 mvBoardPhyAddrGet(MV_U32 ethPortNum);
+MV_VOID mvBoardPhyAddrSet(MV_U32 ethPortNum, MV_U32 smiAddr);
+MV_STATUS mvBoardSatrInfoConfig(MV_SATR_TYPE_ID satrClass, MV_BOARD_SATR_INFO *satrInfo, MV_BOOL read);
+MV_STATUS mvBoardConfigTypeGet(MV_CONFIG_TYPE_ID configClass, MV_BOARD_CONFIG_TYPE_INFO *configInfo);
+MV_STATUS mvBoardExtPhyBufferSelect(MV_BOOL enable);
+MV_U32 mvBoardTclkGet(MV_VOID);
+MV_U32 mvBoardSysClkGet(MV_VOID);
+MV_U32 mvBoardDebugLedNumGet(MV_U32 boardId);
+MV_VOID mvBoardDebugLed(MV_U32 hexNum);
+MV_32 mvBoarGpioPinNumGet(MV_BOARD_GPP_CLASS class, MV_U32 index);
+MV_VOID mvBoardReset(MV_VOID);
+MV_32 mvBoardResetGpioPinGet(MV_VOID);
+MV_32 mvBoardSDIOGpioPinGet(MV_BOARD_GPP_CLASS type);
+MV_32 mvBoardUSBVbusGpioPinGet(MV_32 devId);
+MV_32 mvBoardUSBVbusEnGpioPinGet(MV_32 devId);
+MV_BOOL mvBoardIsOurPciSlot(MV_U32 busNum, MV_U32 slotNum);
+MV_U32 mvBoardGpioIntMaskGet(MV_U32 gppGrp);
+MV_U32 mvBoardSlicUnitTypeGet(MV_VOID);
+MV_VOID mvBoardSlicUnitTypeSet(MV_U32 slicType);
+MV_32 mvBoardMppGet(MV_U32 mppGroupNum);
+MV_VOID mvBoardMppTypeSet(MV_U32 mppGroupNum, MV_U32 groupType);
+MV_VOID mvBoardMppSet(MV_U32 mppGroupNum, MV_U32 mppValue);
+MV_U32 mvBoardGppConfigGet(void);
+MV_32 mvBoardTdmSpiModeGet(MV_VOID);
+MV_U8 mvBoardTdmDevicesCountGet(void);
+MV_U8 mvBoardTdmSpiCsGet(MV_U8 devId);
+MV_VOID mvBoardMppModuleTypePrint(MV_VOID);
+MV_VOID mvBoardOtherModuleTypePrint(MV_VOID);
+MV_BOOL mvBoardIsGbEPortConnected(MV_U32 ethPortNum);
+MV_32 mvBoardGetDevicesNumber(MV_BOARD_DEV_CLASS devClass);
+MV_32 mvBoardGetDeviceBaseAddr(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
+MV_32 mvBoardGetDeviceBusWidth(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
+MV_32 mvBoardGetDeviceWidth(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
+MV_32 mvBoardGetDeviceWinSize(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
+MV_U32 boardGetDevCSNum(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
+MV_U8 mvBoardTwsiAddrTypeGet(MV_BOARD_TWSI_CLASS twsiClass, MV_U32 index);
+MV_U8 mvBoardTwsiAddrGet(MV_BOARD_TWSI_CLASS twsiClass, MV_U32 index);
+MV_32 mvBoardNandWidthGet(void);
+MV_U32 mvBoardEthComplexConfigGet(MV_VOID);
+MV_VOID mvBoardEthComplexConfigSet(MV_U32 ethConfig);
+MV_U32 mvBoardIdGet(MV_VOID);
+MV_VOID mvBoardIdSet(MV_U32 boardId);
+MV_U32 mvBoardSledCpuNumGet(MV_VOID);
+MV_VOID mvBoardInfoUpdate(MV_VOID);
+MV_VOID mvBoardMppIdUpdate(MV_VOID);
+MV_STATUS mvBoardEthComplexInfoUpdate(MV_VOID);
+MV_VOID mvBoardConfigWrite(MV_VOID);
+MV_ETH_COMPLEX_TOPOLOGY mvBoardMac0ConfigGet(MV_VOID);
+MV_ETH_COMPLEX_TOPOLOGY mvBoardMac1ConfigGet(MV_VOID);
+MV_ETH_COMPLEX_TOPOLOGY mvBoardLaneSGMIIGet(MV_VOID);
+MV_BOARD_BOOT_SRC mvBoardBootDeviceGroupSet(MV_VOID);
+MV_BOARD_BOOT_SRC mvBoardBootDeviceGet(MV_VOID);
+MV_U32 mvBoardBootAttrGet(MV_U32 satrBootDeviceValue, MV_U8 attrNum);
+MV_STATUS mvBoardTwsiGet(MV_BOARD_TWSI_CLASS twsiClass, MV_U8 devNum, MV_U8 regNum, MV_U8 *pData);
+MV_STATUS mvBoardTwsiSet(MV_BOARD_TWSI_CLASS twsiClass, MV_U8 devNum, MV_U8 regNum, MV_U8 regVal);
+MV_U8 mvBoardCpuFreqGet(MV_VOID);
+MV_STATUS mvBoardCpuFreqSet(MV_U8 freqVal);
+MV_U8 mvBoardCpuCoresNumGet(MV_VOID);
+MV_STATUS mvBoardMppModulesScan(void);
+MV_BOOL mvBoardIsPexModuleConnected(void);
+MV_BOOL mvBoardIsSetmModuleConnected(void);
+MV_STATUS mvBoardIsInternalSwitchConnectedToPort(MV_U32 ethPortNum);
+MV_STATUS mvBoardIsInternalSwitchConnected(void);
+MV_U32 mvBoardSwitchPortForceLinkGet(MV_U32 switchIdx);
+MV_BOOL mvBoardIsLvdsModuleConnected(void);
+MV_BOOL mvBoardIsLcdDviModuleConnected(void);
+MV_STATUS mvBoardTwsiMuxChannelSet(MV_U8 muxChNum);
+MV_STATUS mvBoardTwsiReadByteThruMux(MV_U8 muxChNum, MV_U8 chNum, MV_TWSI_SLAVE *pTwsiSlave, MV_U8 *data);
+MV_32 mvBoardSmiScanModeGet(MV_U32 switchIdx);
+MV_BOOL mvBoardIsQsgmiiModuleConnected(void);
+MV_32 mvBoardGePhySwitchPortGet(void);
+MV_32 mvBoardRgmiiASwitchPortGet(void);
+MV_BOARD_MAC_SPEED mvBoardMacSpeedGet(MV_U32 ethPortNum);
+MV_U32 mvBoardSwitchCpuPortGet(MV_U32 switchIdx);
+MV_U32 mvBoardIsEthConnected(MV_U32 ethNum);
+MV_32 mvBoardSwitchIrqGet(MV_VOID);
+MV_32 mvBoardSwitchConnectedPortGet(MV_U32 ethPort);
+MV_U32 mvBoardSwitchPortsMaskGet(MV_U32 switchIdx);
+MV_BOOL mvBoardConfigAutoDetectEnabled(void);
+MV_32 mvBoardSmiScanModeGet(MV_U32 switchIdx);
+MV_BOARD_PEX_INFO *mvBoardPexInfoGet(void);
+MV_STATUS mvBoardConfIdSet(MV_U16 conf);
+MV_U16 mvBoardPexModeGet(MV_VOID);
+MV_STATUS mvBoardPexModeSet(MV_U16 conf);
+MV_U32 mvBoardFreqModesNumGet(void);
+
+#ifdef __cplusplus
+}
+#endif  /* __cplusplus */
+
+#endif  /* __INCmvBoardEnvLibh */
diff --git a/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvSpec.c b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvSpec.c
new file mode 100644
index 0000000..f041852
--- /dev/null
+++ b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvSpec.c
@@ -0,0 +1,302 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+********************************************************************************
+   Marvell Commercial License Option
+
+   If you received this File from Marvell and you have entered into a commercial
+   license agreement (a "Commercial License") with Marvell, the File is licensed
+   to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+********************************************************************************
+   Marvell BSD License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File under the following licensing terms.
+   Redistribution and use in source and binary forms, with or without modification,
+   are permitted provided that the following conditions are met:
+
+*   Redistributions of source code must retain the above copyright notice,
+            this list of conditions and the following disclaimer.
+
+*   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+*   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+   ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+   ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#include "mvCommon.h"
+#include "mvBoardEnvLib.h"
+#include "mvBoardEnvSpec.h"
+#include "twsi/mvTwsi.h"
+#include "pex/mvPexRegs.h"
+
+#define ARRSZ(x)                (sizeof(x) / sizeof(x[0]))
+
+/*******************************************************************************
+ * Armada 375 DB-88F6720 board */
+/*******************************************************************************/
+
+#define DB_88F6720_BOARD_NOR_READ_PARAMS	0x403E07CF
+#define DB_88F6720_BOARD_NOR_WRITE_PARAMS	0x000F0F0F
+
+#define DB_88F6720_BOARD_NAND_READ_PARAMS	0x003E07CF
+#define DB_88F6720_BOARD_NAND_WRITE_PARAMS	0x000F0F0F
+
+MV_BOARD_TWSI_INFO db88f6720InfoBoardTwsiDev[] = {
+	/* {{MV_BOARD_DEV_CLASS devClass, MV_U8 devClassId,  MV_U8 twsiDevAddr, MV_U8 twsiDevAddrType}} */
+	{ BOARD_DEV_TWSI_SATR,		0,	0x4C,	   ADDR7_BIT	},
+	{ BOARD_DEV_TWSI_SATR,		1,	0x4D,	   ADDR7_BIT	},
+	{ BOARD_DEV_TWSI_EEPROM,	0,	0x52,	   ADDR7_BIT	},
+};
+
+MV_BOARD_MAC_INFO db88f6720InfoBoardMacInfo[] = {
+	/* {{MV_BOARD_MAC_SPEED boardMacSpeed, MV_8 boardEthSmiAddr}} */
+	{ BOARD_MAC_SPEED_AUTO, 0x0									}
+};
+MV_BOARD_MPP_TYPE_INFO db88f6720InfoBoardModTypeInfo[] = {
+	{
+		.boardMppSlic = MV_BOARD_SLIC_DISABLED,
+		.ethSataComplexOpt = MV_ETHCOMP_GE_MAC0_2_RGMII0,
+		.ethPortsMode = 0x0
+	}
+};
+
+MV_DEV_CS_INFO db88f6720InfoBoardDeCsInfo[] = {
+	/*{deviceCS, params, devType, devWidth, busWidth }*/
+#if defined(MV_INCLUDE_SPI)
+	{ SPI_CS0, N_A, BOARD_DEV_SPI_FLASH, 8, 8 }, /* SPI DEV */
+#endif
+#if defined(MV_INCLUDE_NOR)
+	{DEV_BOOCS, N_A, BOARD_DEV_NOR_FLASH, 16, 16}, /* NOR DEV */
+#endif
+#if defined(MV_INCLUDE_LEGACY_NAND)
+	{DEV_BOOCS, N_A, BOARD_DEV_NAND_FLASH, 16, 16}  /* NAND DEV */
+#endif
+};
+
+MV_BOARD_MPP_INFO db88f6720InfoBoardMppConfigValue[] = {
+	{ {
+		  DB_88F6720_MPP0_7,
+		  DB_88F6720_MPP8_15,
+		  DB_88F6720_MPP16_23,
+		  DB_88F6720_MPP24_31,
+		  DB_88F6720_MPP32_39,
+		  DB_88F6720_MPP40_47,
+		  DB_88F6720_MPP48_55,
+		  DB_88F6720_MPP56_63,
+		  DB_88F6720_MPP64_67,
+	 } }
+};
+
+MV_BOARD_INFO db88f6720_board_info = {
+	.boardName			= "DB-88F6720",
+	.numBoardMppTypeValue		= ARRSZ(db88f6720InfoBoardModTypeInfo),
+	.pBoardModTypeValue		= db88f6720InfoBoardModTypeInfo,
+	.pBoardMppConfigValue		= db88f6720InfoBoardMppConfigValue,
+	.intsGppMaskLow			= 0,
+	.intsGppMaskMid			= 0,
+	.intsGppMaskHigh		= 0,
+	.numBoardDeviceIf		= ARRSZ(db88f6720InfoBoardDeCsInfo),
+	.pDevCsInfo			= db88f6720InfoBoardDeCsInfo,
+	.numBoardTwsiDev		= ARRSZ(db88f6720InfoBoardTwsiDev),
+	.pBoardTwsiDev			= db88f6720InfoBoardTwsiDev,
+	.numBoardMacInfo		= ARRSZ(db88f6720InfoBoardMacInfo),
+	.pBoardMacInfo			= db88f6720InfoBoardMacInfo,
+	.numBoardGppInfo		= 0,
+	.pBoardGppInfo			= 0,
+	.activeLedsNumber		= 0,
+	.pLedGppPin			= NULL,
+	.ledsPolarity			= 0,
+
+	/* PMU Power */
+	.pmuPwrUpPolarity		= 0,
+	.pmuPwrUpDelay			= 80000,
+
+	/* GPP values */
+	.gppOutEnValLow			= DB_88F6720_GPP_OUT_ENA_LOW,
+	.gppOutEnValMid			= DB_88F6720_GPP_OUT_ENA_MID,
+	.gppOutEnValHigh		= DB_88F6720_GPP_OUT_ENA_HIGH,
+	.gppOutValLow			= DB_88F6720_GPP_OUT_VAL_LOW,
+	.gppOutValMid			= DB_88F6720_GPP_OUT_VAL_MID,
+	.gppOutValHigh			= DB_88F6720_GPP_OUT_VAL_HIGH,
+	.gppPolarityValLow		= DB_88F6720_GPP_POL_LOW,
+	.gppPolarityValMid		= DB_88F6720_GPP_POL_MID,
+	.gppPolarityValHigh		= DB_88F6720_GPP_POL_HIGH,
+
+	/* External Switch Configuration */
+	.switchforceLinkMask		= 0x0,
+
+	/* TDM */
+	.numBoardTdmInfo		= {},
+	.pBoardTdmInt2CsInfo		= {},
+	.boardTdmInfoIndex		= -1,
+
+	.pBoardSpecInit			= NULL,
+
+	/* NAND init params */
+	.nandFlashReadParams		= DB_88F6720_BOARD_NAND_READ_PARAMS,
+	.nandFlashWriteParams		= DB_88F6720_BOARD_NAND_WRITE_PARAMS,
+	.nandFlashControl		= 0,
+	/* NOR init params */
+	.norFlashReadParams		= DB_88F6720_BOARD_NOR_READ_PARAMS,
+	.norFlashWriteParams		= DB_88F6720_BOARD_NOR_WRITE_PARAMS,
+	/* Enable modules auto-detection. */
+	.configAutoDetect		= MV_TRUE
+};
+
+/*******************************************************************************
+ * Armada 375 Customer board */
+/*******************************************************************************/
+
+#define A375_CUSTOMER_BOARD_NOR_READ_PARAMS		0x403E07CF
+#define A375_CUSTOMER_BOARD_NOR_WRITE_PARAMS	0x000F0F0F
+
+#define A375_CUSTOMER_BOARD_NAND_READ_PARAMS	0x003E07CF
+#define A375_CUSTOMER_BOARD_NAND_WRITE_PARAMS	0x000F0F0F
+
+MV_BOARD_TWSI_INFO armada_375_customer_InfoBoardTwsiDev[] = {
+	/* {{MV_BOARD_DEV_CLASS devClass, MV_U8 devClassId,  MV_U8 twsiDevAddr, MV_U8 twsiDevAddrType}} */
+	{ BOARD_DEV_TWSI_SATR,		0,	0x4C,	   ADDR7_BIT	},
+	{ BOARD_DEV_TWSI_SATR,		1,	0x4D,	   ADDR7_BIT	},
+	{ BOARD_DEV_TWSI_EEPROM,	0,	0x52,	   ADDR7_BIT	},
+};
+
+MV_BOARD_MAC_INFO armada_375_customer_InfoBoardMacInfo[] = {
+	/* {{MV_BOARD_MAC_SPEED boardMacSpeed, MV_8 boardEthSmiAddr}} */
+	{ BOARD_MAC_SPEED_AUTO, 0x0									}
+};
+MV_BOARD_MPP_TYPE_INFO armada_375_customer_InfoBoardModTypeInfo[] = {
+	{
+		.boardMppSlic = MV_BOARD_SLIC_DISABLED,
+		.ethSataComplexOpt = MV_ETHCOMP_GE_MAC0_2_RGMII0,
+		.ethPortsMode = 0x0
+	}
+};
+
+MV_DEV_CS_INFO armada_375_customer_InfoBoardDeCsInfo[] = {
+	/*{deviceCS, params, devType, devWidth, busWidth }*/
+#if defined(MV_INCLUDE_SPI)
+	{ SPI_CS0, N_A, BOARD_DEV_SPI_FLASH, 8, 8 }, /* SPI DEV */
+#endif
+#if defined(MV_INCLUDE_NOR)
+	{DEV_BOOCS, N_A, BOARD_DEV_NOR_FLASH, 16, 16}, /* NOR DEV */
+#endif
+#if defined(MV_INCLUDE_LEGACY_NAND)
+	{DEV_BOOCS, N_A, BOARD_DEV_NAND_FLASH, 16, 16}  /* NAND DEV */
+#endif
+};
+
+MV_BOARD_MPP_INFO armada_375_customer_InfoBoardMppConfigValue[] = {
+	{ {
+		  A375_CUSTOMER_BOARD_MPP0_7,
+		  A375_CUSTOMER_BOARD_MPP8_15,
+		  A375_CUSTOMER_BOARD_MPP16_23,
+		  A375_CUSTOMER_BOARD_MPP24_31,
+		  A375_CUSTOMER_BOARD_MPP32_39,
+		  A375_CUSTOMER_BOARD_MPP40_47,
+		  A375_CUSTOMER_BOARD_MPP48_55,
+		  A375_CUSTOMER_BOARD_MPP56_63,
+		  A375_CUSTOMER_BOARD_MPP64_67,
+	 } }
+};
+
+MV_BOARD_INFO armada_375_customer_board_info = {
+	.boardName			= "A375-CUSTOMER-BOARD",
+	.numBoardMppTypeValue		= ARRSZ(armada_375_customer_InfoBoardModTypeInfo),
+	.pBoardModTypeValue		= armada_375_customer_InfoBoardModTypeInfo,
+	.pBoardMppConfigValue		= armada_375_customer_InfoBoardMppConfigValue,
+	.intsGppMaskLow			= 0,
+	.intsGppMaskMid			= 0,
+	.intsGppMaskHigh		= 0,
+	.numBoardDeviceIf		= ARRSZ(armada_375_customer_InfoBoardDeCsInfo),
+	.pDevCsInfo			= armada_375_customer_InfoBoardDeCsInfo,
+	.numBoardTwsiDev		= ARRSZ(armada_375_customer_InfoBoardTwsiDev),
+	.pBoardTwsiDev			= armada_375_customer_InfoBoardTwsiDev,
+	.numBoardMacInfo		= ARRSZ(armada_375_customer_InfoBoardMacInfo),
+	.pBoardMacInfo			= armada_375_customer_InfoBoardMacInfo,
+	.numBoardGppInfo		= 0,
+	.pBoardGppInfo			= 0,
+	.activeLedsNumber		= 0,
+	.pLedGppPin			= NULL,
+	.ledsPolarity			= 0,
+
+	/* PMU Power */
+	.pmuPwrUpPolarity		= 0,
+	.pmuPwrUpDelay			= 80000,
+
+	/* GPP values */
+	.gppOutEnValLow			= A375_CUSTOMER_BOARD_GPP_OUT_ENA_LOW,
+	.gppOutEnValMid			= A375_CUSTOMER_BOARD_GPP_OUT_ENA_MID,
+	.gppOutEnValHigh		= A375_CUSTOMER_BOARD_GPP_OUT_ENA_HIGH,
+	.gppOutValLow			= A375_CUSTOMER_BOARD_GPP_OUT_VAL_LOW,
+	.gppOutValMid			= A375_CUSTOMER_BOARD_GPP_OUT_VAL_MID,
+	.gppOutValHigh			= A375_CUSTOMER_BOARD_GPP_OUT_VAL_HIGH,
+	.gppPolarityValLow		= A375_CUSTOMER_BOARD_GPP_POL_LOW,
+	.gppPolarityValMid		= A375_CUSTOMER_BOARD_GPP_POL_MID,
+	.gppPolarityValHigh		= A375_CUSTOMER_BOARD_GPP_POL_HIGH,
+
+	/* External Switch Configuration */
+	.switchforceLinkMask		= 0x0,
+
+	/* TDM */
+	.numBoardTdmInfo		= {},
+	.pBoardTdmInt2CsInfo		= {},
+	.boardTdmInfoIndex		= -1,
+
+	.pBoardSpecInit			= NULL,
+
+	/* NAND init params */
+	.nandFlashReadParams		= A375_CUSTOMER_BOARD_NAND_READ_PARAMS,
+	.nandFlashWriteParams		= A375_CUSTOMER_BOARD_NAND_WRITE_PARAMS,
+	.nandFlashControl		= 0,
+	/* NOR init params */
+	.norFlashReadParams		= A375_CUSTOMER_BOARD_NOR_READ_PARAMS,
+	.norFlashWriteParams		= A375_CUSTOMER_BOARD_NOR_WRITE_PARAMS,
+	/* Enable modules auto-detection. */
+	.configAutoDetect		= MV_TRUE
+};
+
+/*
+ * All supported Armada 375 boards
+ */
+MV_BOARD_INFO *boardInfoTbl[] = {
+	&db88f6720_board_info,
+	&armada_375_customer_board_info,
+};
diff --git a/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvSpec.h b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvSpec.h
new file mode 100644
index 0000000..d8b9455
--- /dev/null
+++ b/arch/arm/mach-armada38x/armada_38x_family/boardEnv/mvBoardEnvSpec.h
@@ -0,0 +1,142 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+********************************************************************************
+   Marvell Commercial License Option
+
+   If you received this File from Marvell and you have entered into a commercial
+   license agreement (a "Commercial License") with Marvell, the File is licensed
+   to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+********************************************************************************
+   Marvell BSD License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File under the following licensing terms.
+   Redistribution and use in source and binary forms, with or without modification,
+   are permitted provided that the following conditions are met:
+
+*   Redistributions of source code must retain the above copyright notice,
+            this list of conditions and the following disclaimer.
+
+*   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+*   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+   ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+   ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvBoardEnvSpech
+#define __INCmvBoardEnvSpech
+
+#include "mvSysHwConfig.h"
+
+/* I2C bus addresses */
+#define MV_BOARD_DIMM0_I2C_ADDR                 0x56
+#define MV_BOARD_DIMM0_I2C_ADDR_TYPE            ADDR7_BIT
+#define MV_BOARD_DIMM1_I2C_ADDR                 0x57
+#define MV_BOARD_DIMM1_I2C_ADDR_TYPE            ADDR7_BIT
+#define MV_BOARD_DIMM_I2C_CHANNEL               0x0
+
+/* Board specific configuration */
+/* ============================ */
+#ifndef MV_ASMLANGUAGE
+/* New board ID numbers */
+
+/* boards ID numbers */
+#define BOARD_ID_BASE                   0x0
+#define DB_6720_ID                      (BOARD_ID_BASE)
+#define A375_CUSTOMER_ID                (DB_6720_ID + 1)
+#define MV_MAX_BOARD_ID                 (A375_CUSTOMER_ID + 1)
+#define MV_INVALID_BOARD_ID             0xFFFFFFFF
+
+/*******************************************************************************
+ * Armada 375 DB-88F6720 board */
+/******************************************************************************/
+/*SPI, NAND cases*/
+#define GROUP1_DEFAULT_MPP_SPI_I2C         0x22000022  /* SPI , I2C */
+#define DB_88F6720_MPP0_7               0x00020020  /* SPI */
+#define DB_88F6720_MPP8_15              0x22000022  /* SPI , I2C */
+#define DB_88F6720_MPP16_23             0x22222222	/* UART, TDM*/
+#define DB_88F6720_MPP24_31             0x33333333  /* SDIO*/
+#define DB_88F6720_MPP32_39             0x04403330  /* SPI, SMI */
+#define DB_88F6720_MPP40_47             0x22002044  /* UART1, GE0  */
+#define DB_88F6720_MPP48_55             0x22222222  /*GE0*/
+#define DB_88F6720_MPP56_63             0x44444422  /* GE0 , LED_MATRIX */
+#define DB_88F6720_MPP64_67				0x004		/* LED_MATRIX */
+
+#define DB_88F6720_GPP_OUT_ENA_LOW      0xFFFFFFFF
+#define DB_88F6720_GPP_OUT_ENA_MID      0xFFFFFFFF
+#define DB_88F6720_GPP_OUT_ENA_HIGH     0xFFFFFFFF
+#define DB_88F6720_GPP_OUT_VAL_LOW      0x0
+#define DB_88F6720_GPP_OUT_VAL_MID      0x0
+#define DB_88F6720_GPP_OUT_VAL_HIGH     0x0
+#define DB_88F6720_GPP_POL_LOW          0x0
+#define DB_88F6720_GPP_POL_MID          0x0
+#define DB_88F6720_GPP_POL_HIGH         0x0
+
+/*******************************************************************************
+ * Armada 375 Customer board */
+/******************************************************************************/
+/*SPI, NAND cases*/
+#define GROUP1_DEFAULT_MPP_SPI_I2C         0x22000022  /* SPI , I2C */
+#define A375_CUSTOMER_BOARD_MPP0_7               0x00020020  /* SPI */
+#define A375_CUSTOMER_BOARD_MPP8_15              0x22000022  /* SPI , I2C */
+#define A375_CUSTOMER_BOARD_MPP16_23             0x22222222	/* UART, TDM*/
+#define A375_CUSTOMER_BOARD_MPP24_31             0x33333333  /* SDIO*/
+#define A375_CUSTOMER_BOARD_MPP32_39             0x04403330  /* SPI, SMI */
+#define A375_CUSTOMER_BOARD_MPP40_47             0x22002044  /* UART1, GE0  */
+#define A375_CUSTOMER_BOARD_MPP48_55             0x22222222  /*GE0*/
+#define A375_CUSTOMER_BOARD_MPP56_63             0x44444422  /* GE0 , LED_MATRIX */
+#define A375_CUSTOMER_BOARD_MPP64_67				0x004		/* LED_MATRIX */
+
+#define A375_CUSTOMER_BOARD_GPP_OUT_ENA_LOW      0xFFFFFFFF
+#define A375_CUSTOMER_BOARD_GPP_OUT_ENA_MID      0xFFFFFFFF
+#define A375_CUSTOMER_BOARD_GPP_OUT_ENA_HIGH     0xFFFFFFFF
+#define A375_CUSTOMER_BOARD_GPP_OUT_VAL_LOW      0x0
+#define A375_CUSTOMER_BOARD_GPP_OUT_VAL_MID      0x0
+#define A375_CUSTOMER_BOARD_GPP_OUT_VAL_HIGH     0x0
+#define A375_CUSTOMER_BOARD_GPP_POL_LOW          0x0
+#define A375_CUSTOMER_BOARD_GPP_POL_MID          0x0
+#define A375_CUSTOMER_BOARD_GPP_POL_HIGH         0x0
+
+
+#endif  /* MV_ASMLANGUAGE */
+
+#endif  /* __INCmvBoardEnvSpech */
diff --git a/arch/arm/mach-armada38x/armada_38x_family/cpu/mvCpu.c b/arch/arm/mach-armada38x/armada_38x_family/cpu/mvCpu.c
new file mode 100644
index 0000000..ef72889
--- /dev/null
+++ b/arch/arm/mach-armada38x/armada_38x_family/cpu/mvCpu.c
@@ -0,0 +1,309 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "cpu/mvCpu.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvCtrlEnvRegs.h"
+#include "ctrlEnv/sys/mvCpuIfRegs.h"
+#include "boardEnv/mvBoardEnvLib.h"
+
+/* defines  */
+#ifdef MV_DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+/* locals */
+
+/*******************************************************************************
+* mvCpuPclkGet - Get the CPU pClk (pipe clock)
+*
+* DESCRIPTION:
+*       This routine extract the CPU core clock.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit clock cycles in MHertz.
+*
+*******************************************************************************/
+MV_U32 mvCpuPclkGet(MV_VOID)
+{
+	MV_FREQ_MODE freqMode;
+
+	if (MV_ERROR != mvCtrlCpuDdrL2FreqGet(&freqMode))
+		return (MV_U32)(1000000 * freqMode.cpuFreq);
+	else
+		return (MV_U32)MV_ERROR;
+}
+
+/*******************************************************************************
+* mvCpuL2ClkGet - Get the CPU L2 (CPU bus clock)
+*
+* DESCRIPTION:
+*       This routine extract the CPU L2 clock.
+*
+* RETURN:
+*       32bit clock cycles in Hertz.
+*
+*******************************************************************************/
+MV_U32 mvCpuL2ClkGet(MV_VOID)
+{
+	MV_FREQ_MODE freqMode;
+
+	if (MV_ERROR != mvCtrlCpuDdrL2FreqGet(&freqMode))
+		return (MV_U32)(1000000 * freqMode.l2Freq);
+	else
+		return (MV_U32)MV_ERROR;;
+}
+
+/*******************************************************************************
+* mvCpuNameGet - Get CPU name
+*
+* DESCRIPTION:
+*       This function returns a string describing the CPU model and revision.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       pNameBuff - Buffer to contain board name string. Minimum size 32 chars.
+*
+* RETURN:
+*       None.
+*******************************************************************************/
+MV_VOID mvCpuNameGet(char *pNameBuff)
+{
+	MV_U32 cpuModel;
+	MV_U32 archType;
+
+	cpuModel = mvOsCpuPartGet();
+	archType = mvOsCpuThumbEEGet();
+
+	/* The CPU module is indicated in the Processor Version Register (PVR) */
+	switch (cpuModel & 0xfff) {
+	case CPU_PART_ARM_V6UP:
+	case CPU_PART_ARM_V7UP:
+	case CPU_PART_MRVLPJ4B_UP:
+		if (archType == 0x1)
+			mvOsSPrintf(pNameBuff, "%s (Rev %d)", "Marvell PJ4B (581) v7", mvOsCpuRevGet());
+		else
+			mvOsSPrintf(pNameBuff, "%s (Rev %d)", "Marvell PJ4B (581) v6", mvOsCpuRevGet());
+		break;
+	case CPU_PART_MRVLPJ4B_MP:
+	case CPU_PART_ARM_V6MP:
+		if (archType == 0x1)
+			mvOsSPrintf(pNameBuff, "%s (Rev %d)", "Marvell PJ4B (584) v7", mvOsCpuRevGet());
+		else
+			mvOsSPrintf(pNameBuff, "%s (Rev %d)", "Marvell PJ4B (584) v6", mvOsCpuRevGet());
+		break;
+	case CPU_PART_ARM_CA9:
+		mvOsSPrintf(pNameBuff, "%s (Rev %d)", "ARM Cortex A9 MPCore", mvOsCpuRevGet());
+		break;
+
+	default:
+		mvOsSPrintf(pNameBuff, "??? (0x%04x) (Rev %d)", cpuModel, mvOsCpuRevGet());
+		break;
+	}
+}
+
+#define MV_PROC_STR_SIZE 50
+
+static void mvCpuIfGetL2EccMode(MV_8 *buf)
+{
+	MV_U32 regVal = MV_REG_READ(CPU_L2_AUX_CTRL_REG);
+	if ((regVal & CL2ACR_ECC_MASK) == CL2ACR_ECC_EN)
+		mvOsSPrintf(buf, "L2 ECC Enabled");
+	else
+		mvOsSPrintf(buf, "L2 ECC Disabled");
+}
+
+static void mvCpuIfGetL2ParityMode(MV_8 *buf)
+{
+	MV_U32 regVal = MV_REG_READ(CPU_L2_AUX_CTRL_REG);
+	if ((regVal & CL2ACR_PARITY_MASK) == CL2ACR_PARITY_EN)
+		mvOsSPrintf(buf, "L2 Parity Enabled");
+	else
+		mvOsSPrintf(buf, "L2 Parity Disabled");
+}
+
+static void mvCpuIfGetL2Mode(MV_8 *buf)
+{
+	MV_U32 regVal = MV_REG_READ(CPU_L2_CTRL_REG);
+	if (regVal & CL2CR_L2_EN_MASK)
+		mvOsSPrintf(buf, "L2 Enabled");
+	else
+		mvOsSPrintf(buf, "L2 Disabled");
+}
+
+static void mvCpuIfGetL2PrefetchMode(MV_8 *buf)
+{				/* valid for PJ4B as well */
+	MV_U32 regVal = MV_REG_READ(CPU_L2_AUX_CTRL_REG);
+	if ((regVal & CL2ACR_PFU_MASK) == CL2ACR_PFU_DIS)
+		mvOsSPrintf(buf, "L2 Prefetch Disabled");
+	else
+		mvOsSPrintf(buf, "L2 Prefetch Enabled");
+}
+
+static void mvCpuIfGetWriteAllocMode(MV_8 *buf)
+{
+	MV_U32 regVal = MV_REG_READ(CPU_L2_AUX_CTRL_REG);
+	if ((regVal & CL2ACR_FORCE_WA_MASK) == CL2ACR_FORCE_NO_WA)
+		mvOsSPrintf(buf, "L2 Write Allocate Disabled");
+	else
+		mvOsSPrintf(buf, "L2 Write Allocate Enabled");
+}
+
+static void mvCpuIfGetCpuStreamMode(MV_8 *buf)
+{				/* valid for PJ4B as well */
+	MV_U32 regVal = 0;
+	__asm volatile ("mrc p15, 1, %0, c15, c1, 0" : "=r" (regVal));	/* Read Marvell extra features register */
+	if (regVal & BIT29)
+		mvOsSPrintf(buf, "CPU Streaming Enabled");
+	else
+		mvOsSPrintf(buf, "CPU Streaming Disabled");
+}
+
+static void mvCpuIfPrintCpuRegs(void)
+{
+	MV_U32 regVal = 0;
+
+	__asm volatile ("mrc p15, 1, %0, c15, c1, 0" : "=r" (regVal));	/* Read Marvell extra features register0 */
+	mvOsPrintf("Extra Features Reg[0] = 0x%x\n", regVal);
+
+	__asm volatile ("mrc p15, 1, %0, c15, c1, 1" : "=r" (regVal));	/* Read Marvell extra features register1 */
+	mvOsPrintf("Extra Features Reg[1] = 0x%x\n", regVal);
+
+	__asm volatile ("mrc	p15, 0, %0, c1, c0, 0" : "=r" (regVal));	/* Read Control register */
+	mvOsPrintf("Control Reg = 0x%x\n", regVal);
+
+	__asm volatile ("mrc	p15, 0, %0, c0, c0, 0" : "=r" (regVal));	/* Read Main ID register */
+	mvOsPrintf("Main ID Reg = 0x%x\n", regVal);
+
+	__asm volatile ("mrc	p15, 0, %0, c0, c0, 1" : "=r" (regVal));	/* Read Cache Type register */
+	mvOsPrintf("Cache Type Reg = 0x%x\n", regVal);
+
+	regVal = MV_REG_READ(CPU_L2_CTRL_REG);
+	mvOsPrintf("L2 Control Reg = 0x%x\n", regVal);
+
+	regVal = MV_REG_READ(CPU_L2_AUX_CTRL_REG);
+	mvOsPrintf("L2 Auxilary Control Reg = 0x%x\n", regVal);
+
+}
+
+MV_U32 mvCpuIfPrintSystemConfig(MV_8 *buffer, MV_U32 index)
+{
+	MV_U32 count = 0;
+
+	MV_8 L2_ECC_str[MV_PROC_STR_SIZE];
+	MV_8 L2_En_str[MV_PROC_STR_SIZE];
+	MV_8 L2_Prefetch_str[MV_PROC_STR_SIZE];
+	MV_8 Write_Alloc_str[MV_PROC_STR_SIZE];
+	MV_8 Cpu_Stream_str[MV_PROC_STR_SIZE];
+	MV_8 L2_Parity_str[MV_PROC_STR_SIZE];
+
+	mvCpuIfGetL2Mode(L2_En_str);
+	mvCpuIfGetL2EccMode(L2_ECC_str);
+	mvCpuIfGetL2ParityMode(L2_Parity_str);
+	mvCpuIfGetL2PrefetchMode(L2_Prefetch_str);
+	mvCpuIfGetWriteAllocMode(Write_Alloc_str);
+	mvCpuIfGetCpuStreamMode(Cpu_Stream_str);
+	mvCpuIfPrintCpuRegs();
+
+	count += mvOsSPrintf(buffer + count + index, "%s\n", L2_En_str);
+	count += mvOsSPrintf(buffer + count + index, "%s\n", L2_ECC_str);
+	count += mvOsSPrintf(buffer + count + index, "%s\n", L2_Parity_str);
+	count += mvOsSPrintf(buffer + count + index, "%s\n", L2_Prefetch_str);
+	count += mvOsSPrintf(buffer + count + index, "%s\n", Write_Alloc_str);
+	count += mvOsSPrintf(buffer + count + index, "%s\n", Cpu_Stream_str);
+	return count;
+}
+
+/*******************************************************************************
+* whoAmI - Get the CPU ID
+*
+* DESCRIPTION:
+*       This function returns CPU ID in multiprocessor system
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       none.
+*
+* RETURN:
+*       CPU ID.
+*******************************************************************************/
+unsigned int whoAmI(void)
+{
+	MV_U32 value;
+
+	__asm__ __volatile__("mrc p15, 0, %0, c0, c0, 5   @ read CPUID reg\n" : "=r"(value) : : "memory");
+	return value & 0x1;
+}
diff --git a/arch/arm/mach-armada38x/armada_38x_family/cpu/mvCpu.h b/arch/arm/mach-armada38x/armada_38x_family/cpu/mvCpu.h
new file mode 100644
index 0000000..8eafae0
--- /dev/null
+++ b/arch/arm/mach-armada38x/armada_38x_family/cpu/mvCpu.h
@@ -0,0 +1,112 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvCpuh
+#define __INCmvCpuh
+
+#include "mvCommon.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#ifndef MV_ASMLANGUAGE
+#include "mvOs.h"
+#endif
+
+#define MASTER_CPU 0
+/* defines */
+#define CPU_PART_MRVL131                0x131
+#define CPU_PART_ARM926                 0x926
+#define CPU_PART_ARM946                 0x946
+#define CPU_PART_MRVL_A9                0xC09
+#define CPU_PART_MRVL571                0x571
+#define CPU_PART_MRVL521                0x521
+
+#define CPU_PART_ARM_V6UP               0xb76
+#define CPU_PART_ARM_V7UP               0xc08
+#define CPU_PART_ARM_CA9                0xc09
+#define CPU_PART_ARM_V6MP               0xb02
+
+#define CPU_PART_MRVLPJ4B_UP               0x581
+#define CPU_PART_MRVLPJ4B_MP               0x584
+
+#define MV_CPU_ARM_CLK_ELM_SIZE	    12
+#define MV_CPU_ARM_CLK_RATIO_OFF    8
+#define MV_CPU_ARM_CLK_DDR_OFF	    4
+
+#ifndef MV_ASMLANGUAGE
+typedef struct _mvCpuArmClkRatio {
+	MV_U32	vco2cpu;	/* VCO:PCLK0(CPU) clock ratio */
+	MV_U32	vco2l2c;	/* VCO:NB(L2 cache) clock ratio */
+	MV_U32	vco2hcl;	/* VCO:HCLK(DDR controller) clock ratio */
+	MV_U32	vco2ddr;	/* VCO:DDR(DDR memory) clock ratio */
+
+} MV_CPU_ARM_CLK_RATIO;
+
+MV_U32  mvCpuPclkGet(MV_VOID);
+MV_VOID mvCpuNameGet(char *pNameBuff);
+MV_U32  mvCpuL2ClkGet(MV_VOID);
+MV_U32  mvCpuIfPrintSystemConfig(MV_8 *buffer, MV_U32 index);
+MV_U32  whoAmI(MV_VOID);
+
+#endif /* MV_ASMLANGUAGE */
+
+#endif /* __INCmvCpuh */
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvAddrDec.c b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvAddrDec.c
new file mode 100644
index 0000000..607a208
--- /dev/null
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvAddrDec.c
@@ -0,0 +1,363 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/* includes */
+#include "mvCommon.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "sys/mvCpuIf.h"
+
+#undef MV_DEBUG
+
+/* defines  */
+#ifdef MV_DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+/* Default Attributes array */
+MV_TARGET_ATTRIB mvTargetDefaultsArray[] = TARGETS_DEF_ARRAY;
+extern MV_TARGET sampleAtResetTargetArray[];
+
+/*******************************************************************************
+* mvCtrlAttribGet -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_STATUS mvCtrlAttribGet(MV_TARGET target, MV_TARGET_ATTRIB *targetAttrib)
+{
+	targetAttrib->attrib = mvTargetDefaultsArray[MV_CHANGE_BOOT_CS(target)].attrib;
+	targetAttrib->targetId = mvTargetDefaultsArray[MV_CHANGE_BOOT_CS(target)].targetId;
+
+	return MV_OK;
+}
+/*******************************************************************************/
+MV_STATUS mvCtrlAttribSet(MV_TARGET target, MV_TARGET_ATTRIB *targetAttrib)
+{
+	mvTargetDefaultsArray[MV_CHANGE_BOOT_CS(target)].attrib  = targetAttrib->attrib;
+	mvTargetDefaultsArray[MV_CHANGE_BOOT_CS(target)].targetId= targetAttrib->targetId;
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCtrlGetAttrib
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_TARGET mvCtrlTargetGet(MV_TARGET_ATTRIB *targetAttrib)
+{
+	MV_TARGET target;
+	MV_TARGET x;
+	for (target = SDRAM_CS0; target < MAX_TARGETS; target++) {
+		x = MV_CHANGE_BOOT_CS(target);
+		if ((mvTargetDefaultsArray[x].attrib == targetAttrib->attrib) &&
+		    (mvTargetDefaultsArray[MV_CHANGE_BOOT_CS(target)].targetId == targetAttrib->targetId)) {
+			/* found it */
+			break;
+		}
+	}
+
+	return target;
+}
+
+/*******************************************************************************
+* mvCtrlTargetByWinInfoGet -
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_TARGET mvCtrlTargetByWinInfoGet(MV_UNIT_WIN_INFO *unitWinInfo)
+{
+	MV_TARGET target;
+	MV_TARGET x;
+	for (target = SDRAM_CS0; target < MAX_TARGETS; target++) {
+		x = MV_CHANGE_BOOT_CS(target);
+		if ((mvTargetDefaultsArray[x].attrib == unitWinInfo->attrib) &&
+		    (mvTargetDefaultsArray[MV_CHANGE_BOOT_CS(target)].targetId == unitWinInfo->targetId)) {
+			/* found it */
+			break;
+		}
+	}
+
+	return target;
+}
+
+/*******************************************************************************
+* mvCtrlAddrWinMapBuild
+*
+* DESCRIPTION:
+*	Build the windows address decoding table, to be used for initializing
+*	the unit's address decoding windows.
+*
+* INPUT:
+*	pAddrWinMap: An array to hold the address decoding windows parameters.
+*	len: Number of entries in pAddrWinMap.
+*
+* OUTPUT:
+*	pAddrWinMap: Address window information.
+*
+* RETURN:
+*	MV_BAD_PARAM: input array is smaller than needed to store all window
+*	addresses.
+*	MV_ERROR: Otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvCtrlAddrWinMapBuild(MV_UNIT_WIN_INFO *pAddrWinMap, MV_U32 len)
+{
+	MV_CPU_DEC_WIN cpuAddrDecWin;
+	MV_U32 i, j;
+	MV_TARGET_ATTRIB targetAttrib;
+	MV_STATUS status;
+	MV_U64 startAddr, endAddr;
+	MV_UNIT_WIN_INFO ioDdrWin[4];
+	MV_U32 base;
+	MV_U64 size;
+
+	/* Check size of CPU address win table */
+	if (len <= MAX_TARGETS) {
+		mvOsPrintf("%s: Table size is too small.\n", __func__);
+		return MV_BAD_PARAM;
+	}
+
+	/* Prepare an array of DRAM info */
+	base = 0x0;
+	j = 0;
+	for (i = SDRAM_CS0; i <= SDRAM_CS3; i++) {
+		status = mvCpuIfTargetWinGet(i, &cpuAddrDecWin);
+		if (status != MV_OK) {
+			if (status == MV_NO_SUCH) {
+				ioDdrWin[i].enable = MV_FALSE;
+				continue;
+			} else {
+				mvOsPrintf("%s: mvCpuIfTargetWinGet() failed.\n", __func__);
+				return MV_ERROR;
+			}
+		}
+
+		/* As all IO address decode windows support only 32-bit
+		** addresses, limit the DRAM base / size to 4GB max.
+		*/
+		startAddr = (MV_U64)((((MV_U64)cpuAddrDecWin.addrWin.baseHigh << 32ll)) +
+				(MV_U64)cpuAddrDecWin.addrWin.baseLow);
+		endAddr = (MV_U64)(startAddr + (MV_U64)cpuAddrDecWin.addrWin.size) - 1;
+		if (endAddr > 0xFFFFFFFFll) {
+			if (startAddr <= 0xFFFFFFFFll)
+				cpuAddrDecWin.addrWin.size = (0x100000000ll -
+						cpuAddrDecWin.addrWin.baseLow);
+			else
+				cpuAddrDecWin.enable = MV_FALSE;
+		}
+
+		if (cpuAddrDecWin.enable == MV_FALSE)
+			continue;
+
+		/* If the endAddr passes minBase, then we need to split
+		 * this window to several windows up to minBase.
+		 * For example: minBase=0xE0000000, and CS0=2, CS1=2G,
+		 * Then we need to split the windwos as follows:
+		 * Win0: CS-0, 2GB (Base 0x0)
+		 * win1: CS-1, 1GB (Base 0x80000000)
+		 * Win2: CS-1, 0.5GB (Base 0xC0000000)
+		 */
+		if (endAddr > MV_DRAM_IO_RESERVE_BASE)
+			/* Need to cut down this CS to IO reserve base
+			** address.
+			*/
+			size = MV_DRAM_IO_RESERVE_BASE -
+				cpuAddrDecWin.addrWin.baseLow;
+		else
+			size = cpuAddrDecWin.addrWin.size;
+
+		if (mvCtrlAttribGet(i, &targetAttrib) != MV_OK) {
+			mvOsPrintf("%s: mvCtrlAttribGet() failed.\n", __func__);
+			return MV_ERROR;
+		}
+		/* Now, spread the last CS into several windows, and make sure
+		** that each of has a power-of-2 size.
+		*/
+		while (size != 0) {
+			ioDdrWin[j].enable = MV_TRUE;
+			ioDdrWin[j].attrib = targetAttrib.attrib;
+			ioDdrWin[j].targetId = targetAttrib.targetId;
+			ioDdrWin[j].addrWin.baseHigh = 0;
+			if (MV_IS_POWER_OF_2(size))
+				ioDdrWin[j].addrWin.size = size;
+			else
+				ioDdrWin[j].addrWin.size = (MV_U64)(1ll << (MV_U64)mvLog2(size));
+			size -= ioDdrWin[j].addrWin.size;
+			ioDdrWin[j].addrWin.baseLow = base;
+			base += ioDdrWin[j].addrWin.size;
+			j++;
+		}
+	}
+
+	for (; j < 4; j++)
+		ioDdrWin[j].enable = MV_FALSE;
+
+	/* Fill in the pAddrWinMap fields       */
+	for (i = 0; i < MAX_TARGETS; i++) {
+		if (MV_TARGET_IS_DRAM(i)) {
+			pAddrWinMap[i].addrWin.baseLow = ioDdrWin[i].addrWin.baseLow;
+			pAddrWinMap[i].addrWin.baseHigh = ioDdrWin[i].addrWin.baseHigh;
+			pAddrWinMap[i].addrWin.size = ioDdrWin[i].addrWin.size;
+			pAddrWinMap[i].enable = ioDdrWin[i].enable;
+			pAddrWinMap[i].attrib = ioDdrWin[i].attrib;
+			pAddrWinMap[i].targetId = ioDdrWin[i].targetId;
+		} else {
+			status = mvCpuIfTargetWinGet(i, &cpuAddrDecWin);
+			if (status != MV_OK) {
+				if (status == MV_NO_SUCH) {
+					pAddrWinMap[i].enable = MV_FALSE;
+					continue;
+				} else {
+					mvOsPrintf("mvCtrlAddrWinMapBuild()"
+					" - mvCpuIfTargetWinGet() failed.\n");
+					return MV_ERROR;
+				}
+			}
+
+			pAddrWinMap[i].addrWin.baseLow =
+				cpuAddrDecWin.addrWin.baseLow;
+			pAddrWinMap[i].addrWin.baseHigh =
+				cpuAddrDecWin.addrWin.baseHigh;
+			pAddrWinMap[i].addrWin.size =
+				cpuAddrDecWin.addrWin.size;
+			pAddrWinMap[i].enable = cpuAddrDecWin.enable;
+
+			if (mvCtrlAttribGet(i, &targetAttrib) != MV_OK) {
+				mvOsPrintf("mvCtrlAddrWinMapBuild() - "
+						"mvCtrlAttribGet() failed.\n");
+				return MV_ERROR;
+			}
+			pAddrWinMap[i].attrib = targetAttrib.attrib;
+			pAddrWinMap[i].targetId = targetAttrib.targetId;
+		}
+	}
+	pAddrWinMap[i].addrWin.baseLow = TBL_TERM;
+	pAddrWinMap[i].addrWin.baseHigh = TBL_TERM;
+	pAddrWinMap[i].addrWin.size = TBL_TERM;
+	pAddrWinMap[i].enable = TBL_TERM;
+	pAddrWinMap[i].attrib = TBL_TERM;
+	pAddrWinMap[i].targetId = TBL_TERM;
+
+	return MV_OK;
+}
+
+MV_STATUS mvCtrlAddrWinInfoGet(MV_UNIT_WIN_INFO *pAddrWinInfo, MV_ULONG physAddr)
+{
+	MV_CPU_DEC_WIN cpuAddrDecWin;
+	MV_U32 i;
+	MV_TARGET_ATTRIB targetAttrib;
+	MV_STATUS status;
+
+	for (i = 0; i < MAX_TARGETS; i++) {
+		status = mvCpuIfTargetWinGet(i, &cpuAddrDecWin);
+		if (status != MV_OK)
+			continue;
+
+		if ((physAddr >= cpuAddrDecWin.addrWin.baseLow) &&
+		    (physAddr < cpuAddrDecWin.addrWin.baseLow + cpuAddrDecWin.addrWin.size)) {
+			/* Found */
+			pAddrWinInfo->addrWin.baseLow = cpuAddrDecWin.addrWin.baseLow;
+			pAddrWinInfo->addrWin.baseHigh = cpuAddrDecWin.addrWin.baseHigh;
+			pAddrWinInfo->addrWin.size = cpuAddrDecWin.addrWin.size;
+
+			if (mvCtrlAttribGet(i, &targetAttrib) != MV_OK) {
+				mvOsPrintf("mvCtrlAddrWinMapBuild() - mvCtrlAttribGet() failed.\n");
+				return MV_ERROR;
+			}
+			pAddrWinInfo->attrib = targetAttrib.attrib;
+			pAddrWinInfo->targetId = targetAttrib.targetId;
+			return MV_OK;
+		}
+	}
+
+	/* not found */
+	return MV_NOT_FOUND;
+}
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvAddrDec.h b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvAddrDec.h
new file mode 100644
index 0000000..dcecd06
--- /dev/null
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvAddrDec.h
@@ -0,0 +1,194 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvCtrlEnvAddrDech
+#define __INCmvCtrlEnvAddrDech
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* includes */
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvCtrlEnvRegs.h"
+
+
+/* defines  */
+/* DUnit attributes */
+#define ATMWCR_WIN_DUNIT_CS0_OFFS		0
+#define ATMWCR_WIN_DUNIT_CS0_MASK		BIT0
+#define ATMWCR_WIN_DUNIT_CS0_REQ		(0 << ATMWCR_WIN_DUNIT_CS0_OFFS)
+
+#define ATMWCR_WIN_DUNIT_CS1_OFFS		1
+#define ATMWCR_WIN_DUNIT_CS1_MASK		BIT1
+#define ATMWCR_WIN_DUNIT_CS1_REQ 		(0 << ATMWCR_WIN_DUNIT_CS1_OFFS)
+
+#define ATMWCR_WIN_DUNIT_CS2_OFFS		2
+#define ATMWCR_WIN_DUNIT_CS2_MASK		BIT2
+#define ATMWCR_WIN_DUNIT_CS2_REQ 		(0 << ATMWCR_WIN_DUNIT_CS2_OFFS)
+
+#define ATMWCR_WIN_DUNIT_CS3_OFFS		3
+#define ATMWCR_WIN_DUNIT_CS3_MASK		BIT3
+#define ATMWCR_WIN_DUNIT_CS3_REQ 		(0 << ATMWCR_WIN_DUNIT_CS3_OFFS)
+
+/* RUnit (Device)  attributes */
+#define ATMWCR_WIN_RUNIT_DEVCS0_OFFS		0
+#define ATMWCR_WIN_RUNIT_DEVCS0_MASK		BIT0
+#define ATMWCR_WIN_RUNIT_DEVCS0_REQ		(0 << ATMWCR_WIN_RUNIT_DEVCS0_OFFS)
+
+#define ATMWCR_WIN_RUNIT_DEVCS1_OFFS		1
+#define ATMWCR_WIN_RUNIT_DEVCS1_MASK		BIT1
+#define ATMWCR_WIN_RUNIT_DEVCS1_REQ 		(0 << ATMWCR_WIN_RUNIT_DEVCS1_OFFS)
+
+#define ATMWCR_WIN_RUNIT_DEVCS2_OFFS		2
+#define ATMWCR_WIN_RUNIT_DEVCS2_MASK		BIT2
+#define ATMWCR_WIN_RUNIT_DEVCS2_REQ 		(0 << ATMWCR_WIN_RUNIT_DEVCS2_OFFS)
+
+#define ATMWCR_WIN_RUNIT_BOOTCS_OFFS		4
+#define ATMWCR_WIN_RUNIT_BOOTCS_MASK		BIT4
+#define ATMWCR_WIN_RUNIT_BOOTCS_REQ 		(0 << ATMWCR_WIN_RUNIT_BOOTCS_OFFS)
+
+/* LMaster (PCI)  attributes */
+#define ATMWCR_WIN_LUNIT_BYTE_SWP_OFFS		0
+#define ATMWCR_WIN_LUNIT_BYTE_SWP_MASK		BIT0
+#define ATMWCR_WIN_LUNIT_BYTE_SWP		(0 << ATMWCR_WIN_LUNIT_BYTE_SWP_OFFS)
+#define ATMWCR_WIN_LUNIT_BYTE_NO_SWP		(1 << ATMWCR_WIN_LUNIT_BYTE_SWP_OFFS)
+
+
+#define ATMWCR_WIN_LUNIT_WORD_SWP_OFFS		1
+#define ATMWCR_WIN_LUNIT_WORD_SWP_MASK		BIT1
+#define ATMWCR_WIN_LUNIT_WORD_SWP		(0 << ATMWCR_WIN_LUNIT_WORD_SWP_OFFS)
+#define ATMWCR_WIN_LUNIT_WORD_NO_SWP		(1 << ATMWCR_WIN_LUNIT_WORD_SWP_OFFS)
+
+#define ATMWCR_WIN_LUNIT_NO_SNOOP		BIT2
+
+#define ATMWCR_WIN_LUNIT_TYPE_OFFS		3
+#define ATMWCR_WIN_LUNIT_TYPE_MASK		BIT3
+#define ATMWCR_WIN_LUNIT_TYPE_IO		(0 << ATMWCR_WIN_LUNIT_TYPE_OFFS)
+#define ATMWCR_WIN_LUNIT_TYPE_MEM		(1 << ATMWCR_WIN_LUNIT_TYPE_OFFS)
+
+#define ATMWCR_WIN_LUNIT_FORCE64_OFFS		4
+#define ATMWCR_WIN_LUNIT_FORCE64_MASK		BIT4
+#define ATMWCR_WIN_LUNIT_FORCE64		(0 << ATMWCR_WIN_LUNIT_FORCE64_OFFS)
+
+#define ATMWCR_WIN_LUNIT_ORDERING_OFFS		6
+#define ATMWCR_WIN_LUNIT_ORDERING_MASK		BIT6
+#define ATMWCR_WIN_LUNIT_ORDERING		(1 << ATMWCR_WIN_LUNIT_FORCE64_OFFS)
+
+/* PEX Attributes */
+#define ATMWCR_WIN_PEX_TYPE_OFFS		3
+#define ATMWCR_WIN_PEX_TYPE_MASK		BIT3
+#define ATMWCR_WIN_PEX_TYPE_IO			(0 << ATMWCR_WIN_PEX_TYPE_OFFS)
+#define ATMWCR_WIN_PEX_TYPE_MEM			(1 << ATMWCR_WIN_PEX_TYPE_OFFS)
+
+/* typedefs */
+
+/* Unsupported attributes for address decode:                               */
+/* 2) PCI0/1_REQ64n control                                                 */
+
+typedef struct _mvTargetAttrib {
+	MV_U8			attrib;			/* chip select attributes */
+	MV_TARGET_ID 		targetId; 		/* Target Id of this MV_TARGET */
+} MV_TARGET_ATTRIB;
+
+
+/* This structure describes address decode window                           */
+typedef struct _mvDecWin {
+    MV_TARGET	target;         /* Target for addr decode window        */
+    MV_ADDR_WIN	addrWin;        /* Address window of target             */
+    MV_BOOL	enable;         /* Window enable/disable                */
+} MV_DEC_WIN;
+
+typedef struct _mvDecWinParams {
+    MV_TARGET_ID    targetId;   /* Target ID field */
+    MV_U8           attrib;     /* Attribute field */
+    MV_U32          baseAddr;   /* Base address in register format */
+    MV_U32          size;       /* Size in register format */
+} MV_DEC_WIN_PARAMS;
+
+
+/* mvCtrlEnvAddrDec API list */
+
+MV_STATUS mvCtrlAttribGet(MV_TARGET target, MV_TARGET_ATTRIB *targetAttrib);
+MV_STATUS mvCtrlAttribSet(MV_TARGET target, MV_TARGET_ATTRIB *targetAttrib);
+
+MV_TARGET mvCtrlTargetGet(MV_TARGET_ATTRIB *targetAttrib);
+MV_TARGET mvCtrlTargetByWinInfoGet(MV_UNIT_WIN_INFO *unitWinInfo);
+
+MV_STATUS mvCtrlAddrDecToParams(MV_DEC_WIN *pAddrDecWin, MV_DEC_WIN_PARAMS *pWinParam);
+
+MV_STATUS mvCtrlParamsToAddrDec(MV_DEC_WIN_PARAMS *pWinParam, MV_DEC_WIN *pAddrDecWin);
+
+MV_STATUS mvCtrlAddrWinMapBuild(MV_UNIT_WIN_INFO *pAddrWinMap, MV_U32 len);
+
+MV_STATUS mvCtrlAddrWinInfoGet(MV_UNIT_WIN_INFO *pAddrWinInfo, MV_ULONG physAddr);
+
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+
+#endif /* __INCmvCtrlEnvAddrDech */
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvAsm.h b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvAsm.h
new file mode 100644
index 0000000..1a14a79
--- /dev/null
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvAsm.h
@@ -0,0 +1,97 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvCtrlEnvAsmh
+#define __INCmvCtrlEnvAsmh
+#include "pex/mvPexRegs.h"
+
+#define CHIP_BOND_REG			0x18238
+#define PCKG_OPT_MASK_AS 		#3
+#define PXCCARI_REVID_MASK_AS		#PXCCARI_REVID_MASK
+
+/* Read device ID into toReg bits 15:0 from 0xd0000000 */
+/* defines  */
+#define MV_DV_CTRL_MODEL_GET_ASM(toReg, tmpReg) \
+	MV_DV_REG_READ_ASM(toReg, tmpReg, CHIP_BOND_REG);\
+	and     toReg, toReg, PCKG_OPT_MASK_AS			/* Mask for package ID */
+
+/* Read device ID into toReg bits 15:0 from 0xf1000000*/
+#define MV_CTRL_MODEL_GET_ASM(toReg, tmpReg) \
+	MV_REG_READ_ASM(toReg, tmpReg, CHIP_BOND_REG);\
+	and     toReg, toReg, PCKG_OPT_MASK_AS			/* Mask for package ID */
+
+/* Read Revision into toReg bits 7:0 0xd0000000*/
+#define MV_DV_CTRL_REV_GET_ASM(toReg, tmpReg)	\
+	/* Read device revision */			\
+	MV_DV_REG_READ_ASM(toReg, tmpReg, PEX_CFG_DIRECT_ACCESS(0, PEX_CLASS_CODE_AND_REVISION_ID));\
+	and     toReg, toReg, PXCCARI_REVID_MASK_AS		/* Mask for calss ID */
+
+/* Read Revision into toReg bits 7:0 0xf1000000*/
+#define MV_CTRL_REV_GET_ASM(toReg, tmpReg)	\
+	/* Read device revision */			\
+	MV_REG_READ_ASM(toReg, tmpReg, PEX_CFG_DIRECT_ACCESS(0, PEX_CLASS_CODE_AND_REVISION_ID));\
+	and     toReg, toReg, PXCCARI_REVID_MASK_AS		/* Mask for calss ID */
+
+#endif /* __INCmvCtrlEnvAsmh */
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.c b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.c
new file mode 100644
index 0000000..4e181e0
--- /dev/null
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.c
@@ -0,0 +1,1735 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+********************************************************************************
+   Marvell Commercial License Option
+
+   If you received this File from Marvell and you have entered into a commercial
+   license agreement (a "Commercial License") with Marvell, the File is licensed
+   to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+********************************************************************************
+   Marvell BSD License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File under the following licensing terms.
+   Redistribution and use in source and binary forms, with or without modification,
+   are permitted provided that the following conditions are met:
+
+*   Redistributions of source code must retain the above copyright notice,
+            this list of conditions and the following disclaimer.
+
+*   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+*   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+   ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+   ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "mvCommon.h"
+#include "mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "ctrlEnv/mvCtrlEthCompLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "gpp/mvGpp.h"
+#include "gpp/mvGppRegs.h"
+#include "mvSysEthConfig.h"
+
+#include "pex/mvPex.h"
+#include "pex/mvPexRegs.h"
+
+#if defined(MV_INCLUDE_GIG_ETH)
+#if defined(MV_ETH_LEGACY)
+#include "eth/mvEth.h"
+#elif defined(CONFIG_MV_ETH_NETA)
+#include "neta/gbe/mvNeta.h"
+#elif defined(CONFIG_MV_ETH_PP2)
+#include "pp2/gbe/mvPp2Gbe.h"
+#endif /* MV_ETH_LEGACY or MV_ETH_NETA  or PP2*/
+#endif
+
+#if defined(MV_INCLUDE_XOR)
+#include "xor/mvXor.h"
+#endif
+
+#if defined(MV_INCLUDE_SATA)
+#include "sata/CoreDriver/mvSata.h"
+#endif
+#if defined(MV_INCLUDE_USB)
+#include "usb/mvUsb.h"
+#endif
+
+#if defined(MV_INCLUDE_TDM)
+#include "mvSysTdmConfig.h"
+#endif
+
+#include "ddr2_3/mvDramIfRegs.h"
+
+/* defines  */
+#undef MV_DEBUG
+#ifdef MV_DEBUG
+#define DB(x)   x
+#else
+#define DB(x)
+#endif
+
+/*
+ * Control Environment internal data structure
+ * Note: it should be initialized dynamically only once.
+ */
+#define MV_INVALID_CTRL_REV     0xff
+
+typedef struct _ctrlEnvInfo {
+	MV_U16 ctrlModel;
+	MV_U8 ctrlRev;
+} CTRL_ENV_INFO;
+
+CTRL_ENV_INFO ctrlEnvInfo = {};
+
+MV_U32 satrOptionsConfig[MV_SATR_READ_MAX_OPTION];
+MV_U32 boardOptionsConfig[MV_CONFIG_TYPE_MAX_OPTION];
+
+MV_BOARD_SATR_INFO boardSatrInfo[] = MV_SAR_INFO;
+
+/*******************************************************************************
+* mvCtrlGetCpuNum
+*
+* DESCRIPTION: Read number of cores enabled by SatR
+*
+* INPUT: None
+*
+* OUTPUT: None
+*
+* RETURN:
+*        Number of cores enabled
+*
+*******************************************************************************/
+MV_U32 mvCtrlGetCpuNum(MV_VOID)
+{
+	MV_U32 cpu1Enabled;
+
+	cpu1Enabled = mvCtrlSatRRead(MV_SATR_CPU1_ENABLE);
+	if (cpu1Enabled == MV_ERROR) {
+		DB(mvOsPrintf("%s: Error: MV_SATR_CPU1_ENABLE is not active for board (using default)\n", __func__));
+		return 0;
+	} else
+		return cpu1Enabled;
+}
+
+/*******************************************************************************
+* mvCtrlIsValidSatR
+*
+* DESCRIPTION: check frequency modes table and verify current mode is supported
+*
+* INPUT: None
+*
+* OUTPUT: None
+*
+* RETURN:
+*        MV_TRUE - if current cpu/ddr/l2 frequency mode is supported for board
+*
+*******************************************************************************/
+MV_BOOL mvCtrlIsValidSatR(MV_VOID)
+{
+	MV_U32 i, cpuFreqMode, maxFreqModes = mvBoardFreqModesNumGet();
+	MV_FREQ_MODE pFreqModes[] = MV_USER_SAR_FREQ_MODES;
+
+	cpuFreqMode =  mvCtrlSatRRead(MV_SATR_CPU_DDR_L2_FREQ);
+
+	for (i = 0; i < maxFreqModes; i++) {
+		if (cpuFreqMode == pFreqModes[i].id)
+			return MV_TRUE;
+	}
+
+	return MV_FALSE;
+}
+
+#ifdef MV_INCLUDE_PEX
+MV_STATUS mvCtrlUpdatePexId(MV_VOID)
+{
+	return MV_ERROR;
+}
+
+#endif
+
+#define MV_6720_INDEX		0
+#define MV_67xx_INDEX_MAX	1
+
+static MV_U32 mvCtrlDevIdIndexGet(MV_U32 devId)
+{
+	return MV_6720_INDEX;
+}
+
+static MV_VOID mvCtrlPexConfig(MV_VOID)
+{
+	MV_U8 pexUnit;
+	MV_U32 pexIfNum = mvCtrlSocUnitInfoNumGet(PEX_UNIT_ID);
+
+	MV_BOARD_PEX_INFO *boardPexInfo = mvBoardPexInfoGet();
+
+	memset(boardPexInfo, 0, sizeof(MV_BOARD_PEX_INFO));
+
+	for (pexUnit = 0; pexUnit < pexIfNum; pexUnit++)
+		boardPexInfo->pexUnitCfg[pexUnit] = PEX_BUS_MODE_X1;
+
+	boardPexInfo->boardPexIfNum = pexIfNum;
+}
+
+
+MV_UNIT_ID mvCtrlSocUnitNums[MAX_UNITS_ID][MV_67xx_INDEX_MAX] = {
+/*                          6720 */
+/* DRAM_UNIT_ID         */ { 1, },
+/* PEX_UNIT_ID          */ { 2, },
+/* ETH_GIG_UNIT_ID      */ { 2, },
+/* USB_UNIT_ID          */ { 1, },
+/* USB3_UNIT_ID          */ { 1, },
+/* IDMA_UNIT_ID         */ { 0, },
+/* XOR_UNIT_ID          */ { 2, },
+/* SATA_UNIT_ID         */ { 2, },
+/* TDM_32CH_UNIT_ID     */ { 1, },
+/* UART_UNIT_ID         */ { 2, },
+/* CESA_UNIT_ID         */ { 1, },
+/* SPI_UNIT_ID          */ { 2, },
+/* AUDIO_UNIT_ID        */ { 1, },
+/* SDIO_UNIT_ID         */ { 1, },
+/* TS_UNIT_ID           */ { 0, },
+/* XPON_UNIT_ID         */ { 1, },
+/* BM_UNIT_ID           */ { 1, },
+/* PNC_UNIT_ID          */ { 1, },
+/* I2C_UNIT_ID          */ { 2, },
+};
+
+MV_U32 mvCtrlSocUnitInfoNumGet(MV_UNIT_ID unit)
+{
+	MV_U32 devId, devIdIndex;
+
+	if (unit >= MAX_UNITS_ID) {
+		mvOsPrintf("%s: Error: Wrong unit type (%u)\n", __func__, unit);
+		return 0;
+	}
+
+	devId = mvCtrlModelGet();
+	devIdIndex = mvCtrlDevIdIndexGet(devId);
+	return mvCtrlSocUnitNums[unit][devIdIndex];
+}
+
+/*******************************************************************************
+* mvCtrlEnvInit - Initialize Marvell controller environment.
+*
+* DESCRIPTION:
+*       This function get environment information and initialize controller
+*       internal/external environment. For example
+*       1) MPP settings according to board MPP macros.
+*		NOTE: It is the user responsibility to shut down all DMA channels
+*		in device and disable controller sub units interrupts during
+*		boot process.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS mvCtrlEnvInit(MV_VOID)
+{
+	MV_U32 i, gppMask;
+
+	/* Set I2C MPP's(MPP Group 1), before reading board configuration, using TWSI read */
+	MV_REG_WRITE(mvCtrlMppRegGet(1), GROUP1_DEFAULT_MPP_SPI_I2C);
+
+	mvCtrlSatrInit();
+
+	/* If set to Auto detect, read board config info, update MPP group types*/
+	if (mvBoardConfigAutoDetectEnabled()) {
+		mvBoardInfoUpdate();
+	}
+
+	mvCtrlPexConfig();
+
+	/* write MPP's config and Board general config */
+	mvBoardConfigWrite();
+
+	/* disable all GPIO interrupts */
+	for (i = 0; i < MV_GPP_MAX_GROUP; i++) {
+		MV_REG_WRITE(GPP_INT_MASK_REG(i), 0x0);
+		MV_REG_WRITE(GPP_INT_LVL_REG(i), 0x0);
+	}
+
+	/* clear all int */
+	for (i = 0; i < MV_GPP_MAX_GROUP; i++)
+		MV_REG_WRITE(GPP_INT_CAUSE_REG(i), 0x0);
+
+	/* Set gpp interrupts as needed */
+	for (i = 0; i < MV_GPP_MAX_GROUP; i++) {
+		gppMask = mvBoardGpioIntMaskGet(i);
+		mvGppTypeSet(i, gppMask, (MV_GPP_IN & gppMask));
+		mvGppPolaritySet(i, gppMask, (MV_GPP_IN_INVERT & gppMask));
+	}
+
+	/*Disabled for kernel compilation*/
+	/*mvEthComplexInit(mvBoardEthComplexConfigGet());*/
+
+	/*
+	 * Enable NAND Flash PUP (Pack-Unpack)
+	 * HW machanism to accelerate transactions (controlled by SoC register)
+	 */
+	MV_REG_BIT_SET(PUP_EN_REG, BIT4);
+
+#ifdef MV_NOR_BOOT
+	/*Enable PUP bit for NOR*/
+	MV_REG_BIT_SET(PUP_EN_REG, BIT6);
+#endif
+	/* XXX: Following setting should be configured by u-boot */
+	/* Disable arbitration between device and NAND */
+	MV_REG_BIT_RESET(SOC_DEV_MUX_REG, BIT27);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCtrlSatRWrite
+*
+* DESCRIPTION: Write S@R configuration Field
+*
+* INPUT: satrField - Field description enum
+*        val       - value to write (if write action requested)
+*
+* OUTPUT: None
+*
+* RETURN:
+*       write action:
+*       if value is writen succesfully - returns the written value
+*       else if write failed - returns MV_ERROR
+*
+*******************************************************************************/
+MV_STATUS mvCtrlSatRWrite(MV_SATR_TYPE_ID satrWriteField, MV_SATR_TYPE_ID satrReadField, MV_U8 val)
+{
+	MV_BOARD_SATR_INFO satrInfo;
+	MV_U8 readValue, verifyValue;
+
+	if (satrReadField >= MV_SATR_READ_MAX_OPTION ||
+		satrWriteField >= MV_SATR_WRITE_MAX_OPTION) {
+		mvOsPrintf("%s: Error: wrong MV_SATR_TYPE_ID field value (%d).\n", __func__ ,satrWriteField);
+		return MV_ERROR;
+	}
+
+	if (mvBoardSatrInfoConfig(satrWriteField, &satrInfo, MV_FALSE) != MV_OK) {
+		mvOsPrintf("%s: Error: Requested S@R field is not relevant for this board\n", __func__);
+		return MV_ERROR;
+	}
+
+	/* read */
+	if (mvBoardTwsiGet(BOARD_DEV_TWSI_SATR, satrInfo.regNum, 0, &readValue) != MV_OK) {
+		mvOsPrintf("%s: Error: Read from S@R failed\n", __func__);
+		return MV_ERROR;
+	}
+
+	/* #1 Workaround for mirrored bits bug (for freq. mode SatR value only!)
+	 * Bug: all freq. mode bits are reversed when sampled at reset from I2C
+	 *		(caused due to a bug in board design)
+	 * Solution: reverse them before write to I2C
+	 *		(reverse only 5 bits - size of SatR field) */
+	if (satrWriteField == MV_SATR_WRITE_CPU_FREQ)
+		val = mvReverseBits(val) >> 3 ;
+
+	/* modify */
+	readValue &= ~(satrInfo.mask);             /* clean old value */
+	readValue |= (val <<  satrInfo.offset);    /* save new value */
+
+	/* write */
+	if (mvBoardTwsiSet(BOARD_DEV_TWSI_SATR, satrInfo.regNum, 0, readValue) != MV_OK) {
+		mvOsPrintf("%s: Error: Write to S@R failed\n", __func__);
+		return MV_ERROR;
+	}
+
+	/* verify */
+	if (mvBoardTwsiGet(BOARD_DEV_TWSI_SATR, satrInfo.regNum, 0, &verifyValue) != MV_OK) {
+		mvOsPrintf("%s: Error: 2nd Read from S@R failed\n", __func__);
+		return MV_ERROR;
+	}
+
+	if (readValue != verifyValue) {
+		mvOsPrintf("%s: Error: Write to S@R failed : written value doesn't match\n", __func__);
+		return MV_ERROR;
+	}
+
+	/* #2 Workaround for mirrored bits bug (for freq. mode SatR value only!)
+	 * Reverse bits again to locally save them properly */
+	if (satrWriteField == MV_SATR_WRITE_CPU_FREQ)
+		val = mvReverseBits(val) >> 3 ;
+
+	/* Save written value in global array */
+	satrOptionsConfig[satrReadField] = val;
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCtrlSatRRead
+*
+* DESCRIPTION: Read S@R configuration Field
+*
+* INPUT: satrField - Field description enum
+*
+* OUTPUT: None
+*
+* RETURN:
+*	if field is valid - returns requested S@R field value
+*       else if field is not relevant for running board, return 0xFFFFFFF.
+*
+*******************************************************************************/
+MV_U32 mvCtrlSatRRead(MV_SATR_TYPE_ID satrField)
+{
+	MV_BOARD_SATR_INFO satrInfo;
+	if (satrField < MV_SATR_READ_MAX_OPTION &&
+			mvBoardSatrInfoConfig(satrField, &satrInfo, MV_TRUE) == MV_OK)
+		return satrOptionsConfig[satrField];
+	else
+		return MV_ERROR;
+}
+
+/*******************************************************************************
+* mvCtrlSmiMasterSet - alter Group 4 MPP type, between CPU SMI control and SWITCH SMI control
+*
+* DESCRIPTION: Read board configuration which is relevant to MPP group 4 interfaces,
+* 		to derive the correct group type, and according to input SMI conrtol,
+* 		write the correct MPP value.
+*
+* INPUT: smiCtrl - enum to select between SWITCH/CPU SMI controll
+*
+* OUTPUT: None
+*
+* RETURN: None
+*
+*******************************************************************************/
+MV_VOID mvCtrlSmiMasterSet(MV_SMI_CTRL smiCtrl)
+{
+	MV_BOOL isSwSMICtrl   = (smiCtrl == SWITCH_SMI_CTRL ? MV_TRUE : MV_FALSE);
+	MV_BOOL isBootDevSPI1 = (MSAR_0_BOOT_SPI1_FLASH == mvBoardBootDeviceGet());
+	MV_BOOL isRefClkOut   = !( mvBoardSlicUnitTypeGet() == SLIC_LANTIQ_ID ); 	/* if not using Lantiq TDM, define REF_CLK_OUT */
+	MV_U8 groupTypeSelect = 0;
+
+	if (! ((smiCtrl == SWITCH_SMI_CTRL) || (smiCtrl == CPU_SMI_CTRL)) ) {
+		DB(mvOsPrintf("mvCtrlSMISet: SMI ctrl initialize failed\n"));
+		return;
+	}
+
+	/* MPP settings :
+	 * Test board configuration relevant to MPP group 4, and derive the correct group type */
+
+	if (isRefClkOut)	/* add first REF_CLK_OUT group type */
+		groupTypeSelect += GE1_CPU_SMI_CTRL_REF_CLK_OUT;
+
+	if (isSwSMICtrl)	/* add first SW_SMI group type */
+		groupTypeSelect += GE1_SW_SMI_CTRL_TDM_LQ_UNIT;
+
+	if (isBootDevSPI1)	/* add first SPI1 group type */
+		groupTypeSelect += SPI1_CPU_SMI_CTRL_TDM_LQ_UNIT;
+
+	mvBoardMppTypeSet(4, groupTypeSelect);	/* Set MPP value according to group type */
+	MV_REG_WRITE(mvCtrlMppRegGet(4), mvBoardMppGet(4));
+
+	/* Mux settings :
+	 * Add mux configuration setup here ! */
+}
+
+/*******************************************************************************
+* mvCtrlCpuDdrL2FreqGet - Get the selected S@R Frequency mode
+*
+* DESCRIPTION:
+*   read board BOOT configuration and return the selcted S@R Frequency mode
+*
+* INPUT:  freqMode - MV_FREQ_MODE struct to return the freq mode
+*
+* OUTPUT: None,
+*
+* RETURN:
+*       MV_STATUS to indicate a successful read.
+*
+*******************************************************************************/
+MV_STATUS mvCtrlCpuDdrL2FreqGet(MV_FREQ_MODE *freqMode)
+{
+	MV_FREQ_MODE freqTable[] = MV_SAR_FREQ_MODES;
+	MV_U32 freqModeSatRValue = mvCtrlSatRRead(MV_SATR_CPU_DDR_L2_FREQ);
+
+	if (MV_ERROR != freqModeSatRValue) {
+		*freqMode = freqTable[freqModeSatRValue];
+		return MV_OK;
+	}
+
+	DB(mvOsPrintf("%s: Error Read from S@R fail\n", __func__));
+	return MV_ERROR;
+}
+
+/*******************************************************************************
+* mvCtrlSysConfigGet
+*
+* DESCRIPTION: Read Board configuration Field
+*
+* INPUT: configField - Field description enum
+*
+* OUTPUT: None
+*
+* RETURN:
+*	if field is valid - returns requested Board configuration field value
+*
+*******************************************************************************/
+MV_U32 mvCtrlSysConfigGet(MV_CONFIG_TYPE_ID configField)
+{
+	MV_BOARD_CONFIG_TYPE_INFO configInfo;
+
+	if (!mvBoardConfigAutoDetectEnabled()) {
+		mvOsPrintf("%s: Error reading board configuration", __func__);
+		mvOsPrintf("- Auto detection is disabled\n");
+		return MV_ERROR;
+	}
+
+	if (configField < MV_CONFIG_TYPE_MAX_OPTION &&
+		mvBoardConfigTypeGet(configField, &configInfo) != MV_TRUE) {
+		mvOsPrintf("%s: Error: Requested board config", __func__);
+		mvOsPrintf("is not valid for this board(%d)\n", configField);
+		return -1;
+	}
+
+	return boardOptionsConfig[configField];
+
+}
+
+/*******************************************************************************
+* mvCtrlSatrInit
+* DESCRIPTION: Initialize S@R configuration
+*               1. initialize all S@R and fields
+*               2. read relevant S@R fields (direct memory access)
+*               **from this point, all reads from S@R will use mvCtrlSatRRead/Write functions**
+*
+* INPUT:  None
+*
+* OUTPUT: None
+*
+* RETURN: NONE
+*
+*******************************************************************************/
+MV_VOID mvCtrlSatrInit(void)
+{
+	MV_U32 satrVal[2];
+	MV_BOARD_SATR_INFO satrInfo;
+	MV_U32 i;
+
+	/* initialize all S@R & Board configuration fields to -1 (MV_ERROR) */
+	memset(&satrOptionsConfig, 0x0, sizeof(MV_U32) * MV_SATR_READ_MAX_OPTION );
+
+	/* Read Sample @ Reset configuration, memory access read : */
+	satrVal[0] = MV_REG_READ(MPP_SAMPLE_AT_RESET(0));
+	satrVal[1] = MV_REG_READ(MPP_SAMPLE_AT_RESET(1));
+
+	for (i = 0; i < MV_SATR_READ_MAX_OPTION; i++)
+		if (mvBoardSatrInfoConfig(i, &satrInfo, MV_TRUE) == MV_OK)
+			satrOptionsConfig[satrInfo.satrId] = ((satrVal[satrInfo.regNum]  & (satrInfo.mask)) >> (satrInfo.offset));
+
+}
+
+/*******************************************************************************
+* mvCtrlDevFamilyIdGet - Get Device ID
+*
+* DESCRIPTION:
+*       This function returns Device ID.
+*
+* INPUT:
+*       ctrlModel.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit board Device ID number, '-1' if Device ID is undefined.
+*
+*******************************************************************************/
+MV_U32 mvCtrlDevFamilyIdGet(MV_U16 ctrlModel)
+{
+	return MV_88F67X0;
+}
+
+/*******************************************************************************
+* mvCtrlMppRegGet - return reg address of mpp group
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       mppGroup - MPP group.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_U32 - Register address.
+*
+*******************************************************************************/
+MV_U32 mvCtrlMppRegGet(MV_U32 mppGroup)
+{
+	MV_U32 ret;
+
+	if (mppGroup >= MV_MPP_MAX_GROUP)
+		mppGroup = 0;
+
+	ret = MPP_CONTROL_REG(mppGroup);
+
+	return ret;
+}
+
+#if defined(MV_INCLUDE_PEX)
+/*******************************************************************************
+* mvCtrlPexMaxIfGet
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of PEX interfaces.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of PEX interfaces. If controller
+*		ID is undefined the function returns '0'.
+*
+*******************************************************************************/
+MV_U32 mvCtrlPexMaxIfGet(MV_VOID)
+{
+	return mvCtrlSocUnitInfoNumGet(PEX_UNIT_ID);
+}
+
+#endif
+
+/*******************************************************************************
+* mvCtrlPexMaxUnitGet
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of PEX units.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of PEX units. If controller
+*		ID is undefined the function returns '0'.
+*
+*******************************************************************************/
+MV_U32 mvCtrlPexMaxUnitGet(MV_VOID)
+{
+	return mvCtrlSocUnitInfoNumGet(PEX_UNIT_ID);
+}
+
+/*******************************************************************************
+* mvCtrlPexActiveUnitNumGet
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of PEX units.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of PEX units. If controller
+*		ID is undefined the function returns '0'.
+*
+*******************************************************************************/
+MV_U32 mvCtrlPexActiveUnitNumGet(MV_VOID)
+{
+	return mvCtrlSocUnitInfoNumGet(PEX_UNIT_ID);
+}
+
+#if defined(MV_INCLUDE_PCI)
+/*******************************************************************************
+* mvCtrlPciMaxIfGet
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of PEX interfaces.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of PEX interfaces. If controller
+*		ID is undefined the function returns '0'.
+*
+*******************************************************************************/
+#ifndef mvCtrlPciMaxIfGet
+MV_U32 mvCtrlPciMaxIfGet(MV_VOID)
+{
+	return 1;
+}
+
+#endif
+#endif
+
+/*******************************************************************************
+* mvCtrlEthMaxPortGet - Get Marvell controller number of etherent ports.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of etherent port.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of etherent port.
+*
+*******************************************************************************/
+MV_U32 mvCtrlEthMaxPortGet(MV_VOID)
+{
+	return MV_ETH_MAX_PORTS;
+}
+
+#if defined(MV_INCLUDE_SATA)
+/*******************************************************************************
+* mvCtrlSataMaxPortGet - Get Marvell controller number of Sata ports.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of Sata ports.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of Sata ports.
+*
+*******************************************************************************/
+MV_U32 mvCtrlSataMaxPortGet(MV_VOID)
+{
+	return mvCtrlSocUnitInfoNumGet(SATA_UNIT_ID);
+}
+
+#endif
+
+#if defined(MV_INCLUDE_XOR)
+/*******************************************************************************
+* mvCtrlXorMaxChanGet - Get Marvell controller number of XOR channels.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of XOR channels.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of XOR channels.
+*
+*******************************************************************************/
+MV_U32 mvCtrlXorMaxChanGet(MV_VOID)
+{
+	return mvCtrlSocUnitInfoNumGet(XOR_UNIT_ID);
+}
+
+/*******************************************************************************
+* mvCtrlXorMaxUnitGet - Get Marvell controller number of XOR units.
+*
+* DESCRIPTION:
+*       This function returns Marvell controller number of XOR units.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Marvell controller number of XOR units.
+*
+*******************************************************************************/
+MV_U32 mvCtrlXorMaxUnitGet(MV_VOID)
+{
+	return mvCtrlSocUnitInfoNumGet(XOR_UNIT_ID);
+}
+
+#endif
+
+#if defined(MV_INCLUDE_USB)
+/*******************************************************************************
+* mvCtrlUsbMaxGet - Get number of Marvell Usb  controllers
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       returns number of Marvell USB  controllers.
+*
+*******************************************************************************/
+MV_U32 mvCtrlUsbMaxGet(void)
+{
+	return mvCtrlSocUnitInfoNumGet(USB_UNIT_ID);
+}
+
+/*******************************************************************************
+* mvCtrlUsb3MaxGet - Get number of Marvell USB 3.0 controllers
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       returns number of Marvell USB 3.0 controllers.
+*
+*******************************************************************************/
+MV_U32 mvCtrlUsb3MaxGet(void)
+{
+	return mvCtrlSocUnitInfoNumGet(USB3_UNIT_ID);
+}
+
+#endif
+
+#if defined(MV_INCLUDE_SDIO)
+/*******************************************************************************
+* mvCtrlSdioSupport - Return if this controller has integrated SDIO flash support
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if SDIO is supported and MV_FALSE otherwise
+*
+*******************************************************************************/
+MV_U32 mvCtrlSdioSupport(MV_VOID)
+{
+	return mvCtrlSocUnitInfoNumGet(SDIO_UNIT_ID) ? MV_TRUE : MV_FALSE;
+}
+
+#endif
+
+/*******************************************************************************
+* mvCtrlTdmSupport - Return if this controller has integrated TDM flash support
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if TDM is supported and MV_FALSE otherwise
+*
+*******************************************************************************/
+MV_U32 mvCtrlTdmSupport(MV_VOID)
+{
+	return mvCtrlSocUnitInfoNumGet(TDM_UNIT_ID) ? MV_TRUE : MV_FALSE;
+}
+
+/*******************************************************************************
+* mvCtrlTdmMaxGet - Return the maximum number of TDM ports.
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       The number of TDM ports in device.
+*
+*******************************************************************************/
+MV_U32 mvCtrlTdmMaxGet(MV_VOID)
+{
+	return mvCtrlSocUnitInfoNumGet(TDM_UNIT_ID);
+}
+
+/*******************************************************************************
+* mvCtrlTdmUnitTypeGet - return the TDM unit type being used
+*
+* DESCRIPTION:
+*	if auto detection enabled, read TDM unit from board configuration
+*	else , read pre-defined TDM unit from board information struct.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	The TDM unit type.
+*
+*******************************************************************************/
+MV_TDM_UNIT_TYPE mvCtrlTdmUnitTypeGet(MV_VOID)
+{
+	return TDM_UNIT_2CH;
+}
+
+
+/*******************************************************************************
+ * mvCtrlTdmUnitIrqGet
+ *
+ * DESCRIPTION:
+ *	Return the TDM unit IRQ number depending on the TDM unit compilation
+ *	options.
+ *
+ * INPUT:
+ *	None.
+ *
+ * OUTPUT:
+ *	None.
+ *
+ * RETURN:
+ *	None.
+ ******************************************************************************/
+MV_U32 mvCtrlTdmUnitIrqGet(MV_VOID)
+{
+	return MV_TDM_IRQ_NUM;
+}
+
+/*******************************************************************************
+* mvCtrlModelGet - Get Marvell controller device model (Id)
+*
+* DESCRIPTION:
+*       This function returns 16bit describing the device model (ID) as defined
+*       in Vendor ID configuration register
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       16bit desscribing Marvell controller ID
+*
+*******************************************************************************/
+MV_U16 mvCtrlModelGet(MV_VOID)
+{
+	return MV_6720_DEV_ID;
+}
+
+/*******************************************************************************
+* mvCtrlRevGet - Get Marvell controller device revision number
+*
+* DESCRIPTION:
+*       This function returns 8bit describing the device revision as defined
+*       Revision ID Register.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       8bit desscribing Marvell controller revision number
+*
+*******************************************************************************/
+MV_U8 mvCtrlRevGet(MV_VOID)
+{
+	MV_U8 value;
+
+	value = MV_REG_READ(DEV_VERSION_ID_REG);
+	return  ((value & (REVISON_ID_MASK) ) >> REVISON_ID_OFFS);
+}
+
+/*******************************************************************************
+* mvCtrlNameGet - Get Marvell controller name
+*
+* DESCRIPTION:
+*       This function returns a string describing the device model and revision.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       pNameBuff - Buffer to contain device name string. Minimum size 30 chars.
+*
+* RETURN:
+*
+*       MV_ERROR if informantion can not be read.
+*******************************************************************************/
+MV_STATUS mvCtrlNameGet(char *pNameBuff)
+{
+	mvOsSPrintf(pNameBuff, "%s%x Rev %d", SOC_NAME_PREFIX, mvCtrlModelGet(), mvCtrlRevGet());
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCtrlModelRevGet - Get Controller Model (Device ID) and Revision
+*
+* DESCRIPTION:
+*       This function returns 32bit value describing both Device ID and Revision
+*       as defined in PCI Express Device and Vendor ID Register and device revision
+*	    as defined in PCI Express Class Code and Revision ID Register.
+
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit describing both controller device ID and revision number
+*
+*******************************************************************************/
+MV_U32 mvCtrlModelRevGet(MV_VOID)
+{
+	return (mvCtrlModelGet() << 16) | mvCtrlRevGet();
+}
+
+/*******************************************************************************
+* mvCtrlModelRevNameGet - Get Marvell controller name
+*
+* DESCRIPTION:
+*       This function returns a string describing the device model and revision.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       pNameBuff - Buffer to contain device name string. Minimum size 30 chars.
+*
+* RETURN:
+*
+*       MV_ERROR if informantion can not be read.
+*******************************************************************************/
+MV_STATUS mvCtrlModelRevNameGet(char *pNameBuff)
+{
+	/* mvCtrlModelRevGet(); */
+	mvCtrlNameGet(pNameBuff);
+	return MV_OK;
+}
+
+static const char *cntrlName[] = TARGETS_NAME_ARRAY;
+
+/*******************************************************************************
+* mvCtrlTargetNameGet - Get Marvell controller target name
+*
+* DESCRIPTION:
+*       This function convert the trget enumeration to string.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Target name (const MV_8 *)
+*******************************************************************************/
+const MV_8 *mvCtrlTargetNameGet(MV_TARGET target)
+{
+	if (target >= MAX_TARGETS)
+		return "target unknown";
+
+	return cntrlName[target];
+}
+
+/*******************************************************************************
+* mvCtrlPexAddrDecShow - Print the PEX address decode map (BARs and windows).
+*
+* DESCRIPTION:
+*		This function print the PEX address decode map (BARs and windows).
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+#if defined(MV_INCLUDE_PEX)
+static MV_VOID mvCtrlPexAddrDecShow(MV_VOID)
+{
+	MV_PEX_BAR pexBar;
+	MV_PEX_DEC_WIN win;
+	MV_U32 pexIf;
+	MV_U32 bar, winNum;
+	MV_BOARD_PEX_INFO *boardPexInfo = mvBoardPexInfoGet();
+	MV_U32 pexHWInf = 0;
+
+	for (pexIf = 0; pexIf < boardPexInfo->boardPexIfNum; pexIf++) {
+		pexHWInf = pexIf;
+
+
+		if (MV_FALSE == mvCtrlPwrClckGet(PEX_UNIT_ID, pexHWInf))
+			continue;
+		mvOsOutput("\n");
+		mvOsOutput("PEX%d:\n", pexHWInf);
+		mvOsOutput("-----\n");
+
+		mvOsOutput("\nPex Bars\n\n");
+
+		for (bar = 0; bar < PEX_MAX_BARS; bar++) {
+			memset(&pexBar, 0, sizeof(MV_PEX_BAR));
+
+			mvOsOutput("%s ", pexBarNameGet(bar));
+
+			if (mvPexBarGet(pexHWInf, bar, &pexBar) == MV_OK) {
+				if (pexBar.enable) {
+					mvOsOutput("base %08x, ", pexBar.addrWin.baseLow);
+					if (pexBar.addrWin.size == 0)
+						mvOsOutput("size %3dGB ", 4);
+					else
+						mvSizePrint(pexBar.addrWin.size);
+					mvOsOutput("\n");
+				} else
+					mvOsOutput("disable\n");
+			}
+		}
+		mvOsOutput("\nPex Decode Windows\n\n");
+
+		for (winNum = 0; winNum < PEX_MAX_TARGET_WIN - 2; winNum++) {
+			memset(&win, 0, sizeof(MV_PEX_DEC_WIN));
+
+			mvOsOutput("win%d - ", winNum);
+
+			if (mvPexTargetWinRead(pexHWInf, winNum, &win) == MV_OK) {
+				if (win.winInfo.enable) {
+					mvOsOutput("%s base %08x, ",
+						   mvCtrlTargetNameGet(mvCtrlTargetByWinInfoGet(&win.winInfo)),
+						   win.winInfo.addrWin.baseLow);
+					mvOsOutput("....");
+					mvSizePrint(win.winInfo.addrWin.size);
+
+					mvOsOutput("\n");
+				} else
+					mvOsOutput("disable\n");
+			}
+		}
+
+		memset(&win, 0, sizeof(MV_PEX_DEC_WIN));
+
+		mvOsOutput("default win - ");
+
+		if (mvPexTargetWinRead(pexHWInf, MV_PEX_WIN_DEFAULT, &win) == MV_OK) {
+			mvOsOutput("%s ", mvCtrlTargetNameGet(win.target));
+			mvOsOutput("\n");
+		}
+		memset(&win, 0, sizeof(MV_PEX_DEC_WIN));
+
+		mvOsOutput("Expansion ROM - ");
+
+		if (mvPexTargetWinRead(pexHWInf, MV_PEX_WIN_EXP_ROM, &win) == MV_OK) {
+			mvOsOutput("%s ", mvCtrlTargetNameGet(win.target));
+			mvOsOutput("\n");
+		}
+	}
+}
+
+#endif
+
+/*******************************************************************************
+* mvUnitAddrDecShow - Print the Unit's address decode map.
+*
+* DESCRIPTION:
+*       This is a generic function for printing the different unit's address
+*	decode map.
+*
+* INPUT:
+*       unit	- The unit to print the address decode for.
+*	name	- The unit's name.
+*	winGetFuncPtr - A pointer to the HAL's window get function.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+static void mvUnitAddrDecShow(MV_U8 numUnits, MV_UNIT_ID unitId,
+			      const char *name, MV_WIN_GET_FUNC_PTR winGetFuncPtr)
+{
+	MV_UNIT_WIN_INFO win;
+	MV_U32 unit, i;
+
+	for (unit = 0; unit < numUnits; unit++) {
+		if (MV_FALSE == mvCtrlPwrClckGet(unitId, unit))
+			continue;
+		mvOsOutput("\n");
+		mvOsOutput("%s %d:\n", name, unit);
+		mvOsOutput("----\n");
+
+		for (i = 0; i < 16; i++) {
+			memset(&win, 0, sizeof(MV_UNIT_WIN_INFO));
+
+			mvOsOutput("win%d - ", i);
+
+			if (winGetFuncPtr(unit, i, &win) == MV_OK) {
+				if (win.enable) {
+					mvOsOutput("%s base %08x, ",
+						   mvCtrlTargetNameGet(mvCtrlTargetByWinInfoGet(&win)),
+						   win.addrWin.baseLow);
+					mvOsOutput("....");
+					if (win.addrWin.size == 0)
+						mvOsOutput("size %3dGB ", 4);
+					else
+						mvSizePrint(win.addrWin.size);
+					mvOsOutput("\n");
+				} else
+					mvOsOutput("disable\n");
+			}
+		}
+	}
+}
+
+/*******************************************************************************
+* mvCtrlAddrDecShow - Print the Controller units address decode map.
+*
+* DESCRIPTION:
+*		This function the Controller units address decode map.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvCtrlAddrDecShow(MV_VOID)
+{
+	mvCpuIfAddDecShow();
+	mvAhbToMbusAddDecShow();
+#if defined(MV_INCLUDE_PEX)
+	mvCtrlPexAddrDecShow();
+#endif
+
+#if defined(MV_INCLUDE_USB)
+	mvUnitAddrDecShow(mvCtrlUsbMaxGet(), USB_UNIT_ID, "USB", mvUsbWinRead);
+#endif
+
+#if defined(MV_INCLUDE_GIG_ETH)
+#if defined(MV_ETH_LEGACY)
+	mvUnitAddrDecShow(mvCtrlEthMaxPortGet(), ETH_GIG_UNIT_ID, "ETH", mvEthWinRead);
+#elif defined(CONFIG_MV_ETH_NETA)
+	mvUnitAddrDecShow(mvCtrlEthMaxPortGet(), ETH_GIG_UNIT_ID, "ETH", mvNetaWinRead);
+#else
+	mvUnitAddrDecShow(mvCtrlEthMaxPortGet(), ETH_GIG_UNIT_ID, "ETH", mvPp2WinRead);
+#endif
+#endif
+
+#if defined(MV_INCLUDE_XOR)
+	mvUnitAddrDecShow(mvCtrlXorMaxChanGet(), XOR_UNIT_ID, "XOR", mvXorTargetWinRead);
+#endif
+
+#if defined(MV_INCLUDE_SATA)
+	mvUnitAddrDecShow(mvCtrlSataMaxPortGet(), SATA_UNIT_ID, "Sata", mvSataWinRead);
+#endif
+}
+
+/*******************************************************************************
+* ctrlSizeToReg - Extract size value for register assignment.
+*
+* DESCRIPTION:
+*       Address decode size parameter must be programed from LSB to MSB as
+*       sequence of 1's followed by sequence of 0's. The number of 1's
+*       specifies the size of the window in 64 KB granularity (e.g. a
+*       value of 0x00ff specifies 256x64k = 16 MB).
+*       This function extract the size value from the size parameter according
+*       to given aligment paramter. For example for size 0x1000000 (16MB) and
+*       aligment 0x10000 (64KB) the function will return 0x00FF.
+*
+* INPUT:
+*       size - Size.
+*       alignment - Size alignment. Note that alignment must be power of 2!
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit describing size register value correspond to size parameter.
+*       If value is '-1' size parameter or aligment are invalid.
+*******************************************************************************/
+MV_U32 ctrlSizeToReg(MV_U32 size, MV_U32 alignment)
+{
+	MV_U32 retVal;
+
+	/* Check size parameter alignment               */
+	if ((0 == size) || (MV_IS_NOT_ALIGN(size, alignment))) {
+		DB(mvOsPrintf("ctrlSizeToReg: ERR. Size is zero or not aligned.\n"));
+		return -1;
+	}
+
+	/* Take out the "alignment" portion out of the size parameter */
+	alignment--;                    /* Now the alignmet is a sequance of '1' (e.g. 0xffff)          */
+	/* and size is 0x1000000 (16MB) for example     */
+	while (alignment & 1) {         /* Check that alignmet LSB is set       */
+		size = (size >> 1);     /* If LSB is set, move 'size' one bit to right      */
+		alignment = (alignment >> 1);
+	}
+
+	/* If after the alignment first '0' was met we still have '1' in                */
+	/* it then aligment is invalid (not power of 2)                                 */
+	if (alignment) {
+		DB(mvOsPrintf("ctrlSizeToReg: ERR. Alignment parameter 0x%x invalid.\n", (MV_U32)alignment));
+		return -1;
+	}
+
+	/* Now the size is shifted right according to aligment: 0x0100                  */
+	size--;                 /* Now the size is a sequance of '1': 0x00ff                    */
+	retVal = size;
+
+	/* Check that LSB to MSB is sequence of 1's followed by sequence of 0's         */
+	while (size & 1)                /* Check that LSB is set    */
+		size = (size >> 1);     /* If LSB is set, move one bit to the right         */
+
+	if (size) {                     /* Sequance of 1's is over. Check that we have no other 1's         */
+		DB(mvOsPrintf("ctrlSizeToReg: ERR. Size parameter 0x%x invalid.\n", size));
+		return -1;
+	}
+	return retVal;
+}
+
+/*******************************************************************************
+* ctrlRegToSize - Extract size value from register value.
+*
+* DESCRIPTION:
+*       This function extract a size value from the register size parameter
+*       according to given aligment paramter. For example for register size
+*       value 0xff and aligment 0x10000 the function will return 0x01000000.
+*
+* INPUT:
+*       regSize   - Size as in register format.	See ctrlSizeToReg.
+*       alignment - Size alignment.	Note that alignment must be power of 2!
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit describing size.
+*       If value is '-1' size parameter or aligment are invalid.
+*******************************************************************************/
+MV_U32 ctrlRegToSize(MV_U32 regSize, MV_U32 alignment)
+{
+	MV_U32 temp;
+
+	/* Check that LSB to MSB is sequence of 1's followed by sequence of 0's         */
+	temp = regSize;                 /* Now the size is a sequance of '1': 0x00ff            */
+
+	while (temp & 1)                /* Check that LSB is set                                    */
+		temp = (temp >> 1);     /* If LSB is set, move one bit to the right         */
+
+	if (temp) {                     /* Sequance of 1's is over. Check that we have no other 1's         */
+		DB(mvOsPrintf("%s: ERR: Size parameter 0x%x invalid.\n", __func__, regSize));
+		return -1;
+	}
+
+	/* Check that aligment is a power of two                                        */
+	temp = alignment - 1;           /* Now the alignmet is a sequance of '1' (0xffff)          */
+
+	while (temp & 1)                /* Check that alignmet LSB is set                           */
+		temp = (temp >> 1);     /* If LSB is set, move 'size' one bit to right      */
+
+	/* If after the 'temp' first '0' was met we still have '1' in 'temp'            */
+	/* then 'temp' is invalid (not power of 2)                                      */
+	if (temp) {
+		DB(mvOsPrintf("%s: ERR: Alignment parameter 0x%x invalid.\n", __func__, alignment));
+		return -1;
+	}
+
+	regSize++;              /* Now the size is 0x0100                                       */
+
+	/* Add in the "alignment" portion to the register size parameter                */
+	alignment--;                            /* Now the alignmet is a sequance of '1' (e.g. 0xffff)          */
+
+	while (alignment & 1) {                 /* Check that alignmet LSB is set                       */
+		regSize = (regSize << 1);       /* LSB is set, move 'size' one bit left     */
+		alignment = (alignment >> 1);
+	}
+
+	return regSize;
+}
+
+/*******************************************************************************
+* ctrlSizeRegRoundUp - Round up given size
+*
+* DESCRIPTION:
+*       This function round up a given size to a size that fits the
+*       restrictions of size format given an aligment parameter.
+*		to given aligment paramter. For example for size parameter 0xa1000 and
+*		aligment 0x1000 the function will return 0xFF000.
+*
+* INPUT:
+*       size - Size.
+*		alignment - Size alignment.	Note that alignment must be power of 2!
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit describing size value correspond to size in register.
+*******************************************************************************/
+MV_U32 ctrlSizeRegRoundUp(MV_U32 size, MV_U32 alignment)
+{
+	MV_U32 msbBit = 0;
+	MV_U32 retSize;
+
+	/* Check if size parameter is already comply with restriction   */
+	if (!(-1 == ctrlSizeToReg(size, alignment)))
+		return size;
+
+	while (size) {
+		size = (size >> 1);
+		msbBit++;
+	}
+
+	retSize = (1 << msbBit);
+
+	if (retSize < alignment)
+		return alignment;
+	else
+		return retSize;
+}
+
+/*******************************************************************************
+* mvCtrlIsBootFromNOR
+*
+* DESCRIPTION:
+*       Check if device is configured to boot from NOR flash according to the
+*	SAR registers.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if device boot from SPI.
+*******************************************************************************/
+MV_BOOL mvCtrlIsBootFromNOR(MV_VOID)
+{
+	return MV_TRUE;
+}
+
+/*******************************************************************************
+* mvCtrlIsBootFromSPI
+*
+* DESCRIPTION:
+*       Check if device is configured to boot from SPI flash according to the
+*	SAR registers.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if device boot from SPI.
+*******************************************************************************/
+MV_BOOL mvCtrlIsBootFromSPI(MV_VOID)
+{
+	return MV_TRUE; // omriii : return to false
+}
+
+/*******************************************************************************
+* mvCtrlIsBootFromNAND
+*
+* DESCRIPTION:
+*       Check if device is confiogured to boot from NAND flash according to the SAR
+*	registers.
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if device boot from NAND.
+*******************************************************************************/
+MV_BOOL mvCtrlIsBootFromNAND(MV_VOID)
+{
+	return MV_FALSE;
+}
+
+#if defined(MV_INCLUDE_CLK_PWR_CNTRL)
+/*******************************************************************************
+* mvCtrlPwrClckSet - Set Power State for specific Unit
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+*******************************************************************************/
+MV_VOID mvCtrlPwrClckSet(MV_UNIT_ID unitId, MV_U32 index, MV_BOOL enable)
+{
+	/* Clock gating is not supported on FPGA */
+	if (mvCtrlModelGet() == MV_FPGA_DEV_ID)
+		return;
+
+	switch (unitId) {
+#if defined(MV_INCLUDE_PEX)
+	case PEX_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_PEX_STOP_CLK_MASK(index));
+		else
+			MV_REG_BIT_SET(POWER_MNG_CTRL_REG, PMC_PEX_STOP_CLK_MASK(index));
+
+		break;
+#endif
+#if defined(MV_INCLUDE_INTEG_SATA)
+	case SATA_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_SATA_STOP_CLK_MASK);
+		else
+			MV_REG_BIT_SET(POWER_MNG_CTRL_REG, PMC_SATA_STOP_CLK_MASK);
+
+		break;
+#endif
+#if defined(MV_INCLUDE_USB)
+	case USB_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_USB_STOP_CLK_MASK);
+		else
+			MV_REG_BIT_SET(POWER_MNG_CTRL_REG, PMC_USB_STOP_CLK_MASK);
+
+		break;
+#endif
+#if defined(MV_INCLUDE_SDIO)
+	case SDIO_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_SDIO_STOP_CLK_MASK);
+		else
+			MV_REG_BIT_SET(POWER_MNG_CTRL_REG, PMC_SDIO_STOP_CLK_MASK);
+
+		break;
+#endif
+	case TDM_UNIT_ID:
+		if (enable == MV_FALSE)
+			MV_REG_BIT_RESET(POWER_MNG_CTRL_REG, PMC_TDM_STOP_CLK_MASK);
+		else
+			MV_REG_BIT_SET(POWER_MNG_CTRL_REG, PMC_TDM_STOP_CLK_MASK);
+		break;
+	default:
+		break;
+	}
+}
+
+/*******************************************************************************
+ * mvCtrlPwrClckGet - Get Power State of specific Unit
+ *
+ * DESCRIPTION:
+ *
+ * INPUT:
+ *
+ * OUTPUT:
+ *
+ * RETURN:
+ ******************************************************************************/
+MV_BOOL mvCtrlPwrClckGet(MV_UNIT_ID unitId, MV_U32 index)
+{
+	MV_BOOL state = MV_TRUE;
+
+	/* Clock gating is not supported on FPGA */
+	if (mvCtrlModelGet() == MV_FPGA_DEV_ID)
+		return MV_TRUE;
+
+	MV_U32 reg = MV_REG_READ(POWER_MNG_CTRL_REG);
+	switch (unitId) {
+#if defined(MV_INCLUDE_PEX)
+	case PEX_UNIT_ID:
+		if ((reg & PMC_PEX_STOP_CLK_MASK(index)) == PMC_PEX_STOP_CLK_STOP(index))
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_SATA)
+	case SATA_UNIT_ID:
+		if ((reg & PMC_SATA_STOP_CLK_MASK) == PMC_SATA_STOP_CLK_STOP)
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_USB)
+	case USB_UNIT_ID:
+		if ((reg & PMC_USB_STOP_CLK_MASK) == PMC_USB_STOP_CLK_STOP)
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_SDIO)
+	case SDIO_UNIT_ID:
+		if ((reg & PMC_SDIO_STOP_CLK_MASK) == PMC_SDIO_STOP_CLK_STOP)
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+#if defined(MV_INCLUDE_TDM)
+	case TDM_UNIT_ID:
+		if ((reg & PMC_TDM_STOP_CLK_MASK) == PMC_TDM_STOP_CLK_STOP)
+			state = MV_FALSE;
+		else
+			state = MV_TRUE;
+		break;
+#endif
+	default:
+		state = MV_TRUE;
+		break;
+	}
+
+	return state;
+}
+
+#else
+MV_VOID mvCtrlPwrClckSet(MV_UNIT_ID unitId, MV_U32 index, MV_BOOL enable)
+{
+	return;
+}
+
+MV_BOOL mvCtrlPwrClckGet(MV_UNIT_ID unitId, MV_U32 index)
+{
+	return MV_TRUE;
+}
+
+#endif /* #if defined(MV_INCLUDE_CLK_PWR_CNTRL) */
+
+MV_U32 mvCtrlDDRBudWidth(MV_VOID)
+{
+	MV_U32 reg;
+
+	reg = MV_REG_READ(REG_SDRAM_CONFIG_ADDR);
+
+	return (reg & (0x1 << REG_SDRAM_CONFIG_DDR_BUS_OFFS)) ? 32 : 16;
+}
+
+MV_BOOL mvCtrlDDRThruXbar(MV_VOID)
+{
+	MV_U32 reg;
+
+	reg = MV_REG_READ(0x20184);
+
+	return (reg & 0x1) ? MV_FALSE : MV_TRUE;
+}
+
+MV_BOOL mvCtrlDDRECC(MV_VOID)
+{
+	MV_U32 reg;
+
+	reg = MV_REG_READ(REG_SDRAM_CONFIG_ADDR);
+
+	return (reg & (0x1 << REG_SDRAM_CONFIG_ECC_OFFS)) ? MV_TRUE : MV_FALSE;
+}
+
+
+/*******************************************************************************
+* mvCtrlGetJuncTemp
+*
+* DESCRIPTION:
+*       Read temperature, calibrate at first time the TSEN
+*
+* INPUT:
+*	None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Tj value.
+*******************************************************************************/
+MV_U32 mvCtrlGetJuncTemp(MV_VOID)
+{
+	/*Used Hard Coded values, TODO sync with Spec*/
+	MV_32 reg = 0;
+
+	/* init the TSEN sensor once */
+	if ((MV_REG_READ(TSEN_STATE_REG) & TSEN_STATE_MASK) == 0) {
+		MV_REG_BIT_RESET(TSEN_STATE_REG, TSEN_STATE_MASK);
+
+		MV_REG_WRITE(TSEN_STATE_REG, 0x8011E214);
+
+		reg = MV_REG_READ(TSEN_CONF_REG);
+
+		reg = 0x00a80909;
+		MV_REG_WRITE(TSEN_CONF_REG, reg);
+		mvOsDelay(10);
+	}
+
+	reg = MV_REG_READ(TSEN_STATUS_REG);
+	reg = (reg & TSEN_STATUS_TEMP_OUT_MASK) >> TSEN_STATUS_TEMP_OUT_OFFSET;
+
+	return (3171900 - (10000 * reg)) / 13553;
+}
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.h b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.h
new file mode 100644
index 0000000..fbce500
--- /dev/null
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvLib.h
@@ -0,0 +1,365 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+********************************************************************************
+   Marvell Commercial License Option
+
+   If you received this File from Marvell and you have entered into a commercial
+   license agreement (a "Commercial License") with Marvell, the File is licensed
+   to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+********************************************************************************
+   Marvell BSD License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File under the following licensing terms.
+   Redistribution and use in source and binary forms, with or without modification,
+   are permitted provided that the following conditions are met:
+
+*   Redistributions of source code must retain the above copyright notice,
+            this list of conditions and the following disclaimer.
+
+*   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+*   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+   ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+   ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvCtrlEnvLibh
+#define __INCmvCtrlEnvLibh
+
+#include "mvSysHwConfig.h"
+#include "mvCommon.h"
+#include "mvTypes.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ctrlEnv/mvCtrlEnvRegs.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+
+typedef enum _mvSatRTypeID {
+	// "Bios" Device
+	MV_SATR_CPU_DDR_L2_FREQ,
+	MV_SATR_CORE_CLK_SELECT,
+	MV_SATR_CPU1_ENABLE,
+	MV_SATR_SSCG_DISABLE,
+	// Jumpers  - change by removing Jumper. S@R will be changed by this option
+	MV_SATR_I2C0_SERIAL_ROM,
+	MV_SATR_EXTERNAL_CPU_RESET,
+	MV_SATR_EXTERNAL_CORE_RESET,
+	// DIP Switch - change by removing Switch. S@R will be changed by this option:
+	MV_SATR_BOOT_DEVICE,
+	// DPR's -modified by moving resistor with solderer. S@R will be changed by this
+	MV_SATR_CPU_PLL_XTAL_BYPASS,
+	MV_SATR_CPU0_ENDIANESS,
+	MV_SATR_CPU0_NMFI,
+	MV_SATR_CPU0_THUMB,
+	MV_SATR_PEX0_CLOCK,
+	MV_SATR_PEX1_CLOCK,
+	MV_SATR_REF_CLOCK_ENABLE,
+	MV_SATR_EFUSE_BYPASS,
+	MV_SATR_POR_BYPASS,
+	MV_SATR_TESTER_OPTIONS,
+	MV_SATR_BOARD_ID,
+	MV_SATR_READ_MAX_OPTION,
+	MV_SATR_WRITE_CPU_FREQ,
+	MV_SATR_WRITE_CORE_CLK_SELECT,
+	MV_SATR_WRITE_CPU1_ENABLE,
+	MV_SATR_WRITE_SSCG_DISABLE,
+	MV_SATR_WRITE_MAX_OPTION
+} MV_SATR_TYPE_ID;
+
+typedef enum _mvConfigTypeID {
+	MV_CONFIG_MAC0,
+	MV_CONFIG_MAC1,
+	MV_CONFIG_PON_SERDES,
+	MV_CONFIG_PON_BEN_POLARITY,
+	MV_CONFIG_SGMII0_CAPACITY,
+	MV_CONFIG_SGMII1_CAPACITY,
+	MV_CONFIG_LANE1,
+	MV_CONFIG_LANE2,
+	MV_CONFIG_LANE3,
+	MV_CONFIG_DEVICE_BUS_MODULE,
+	MV_CONFIG_SLIC_TDM_DEVICE,
+	MV_CONFIG_TYPE_MAX_OPTION
+} MV_CONFIG_TYPE_ID;
+
+typedef enum _mvIoExpanderTypeID {
+	MV_IO_EXPANDER_SFP0_TX_DIS,
+	MV_IO_EXPANDER_SFP0_PRSNT,
+	MV_IO_EXPANDER_SFP0_TX_FAULT,
+	MV_IO_EXPANDER_SFP0_LOS,
+	MV_IO_EXPANDER_SFP1_PRSNT,
+	MV_IO_EXPANDER_SFP1_TX_FAULT,
+	MV_IO_EXPANDER_SFP1_LOS,
+	MV_IO_EXPANDER_SFP1_TX_DIS,
+	MV_IO_EXPANDER_USB_VBUS,
+	MV_IO_EXPANDER_MAC0_RJ45_PORT_LED,
+	MV_IO_EXPANDER_MAC0_SFP_PORT_LED,
+	MV_IO_EXPANDER_MAC1_RJ45_PORT_LED,
+	MV_IO_EXPANDER_MAC1_SFP_PORT_LED,
+	MV_IO_EXPANDER_PON_PORT_LED,
+	MV_IO_EXPANDER_SD_STATUS,
+	MV_IO_EXPANDER_SD_WRITE_PROTECT,
+	MV_IO_EXPANDER_JUMPER1,
+	MV_IO_EXPANDER_JUMPER2_EEPROM_ENABLED,
+	MV_IO_EXPANDER_JUMPER3,
+	MV_IO_EXPANDER_EXT_PHY_SMI_EN,
+	MV_IO_EXPANDER_SPI1_CS_MSB0,
+	MV_IO_EXPANDER_SPI1_CS_MSB1,
+	MV_IO_EXPANDER_INTEG_PHY_PORTS_LED,
+	MV_IO_EXPANDER_USB_SUPER_SPEED,
+} MV_IO_EXPANDER_TYPE_ID;
+
+/* This enumerator describes the possible SMI control options */
+typedef enum _mvSMIctrl {
+	CPU_SMI_CTRL,
+	SWITCH_SMI_CTRL,
+} MV_SMI_CTRL;
+
+/* typedefs */
+typedef MV_STATUS (*MV_WIN_GET_FUNC_PTR)(MV_U32, MV_U32, MV_UNIT_WIN_INFO*);
+
+/* This enumerator describes the possible HW cache coherency policies the
+ * controllers supports.
+ */
+typedef enum _mvCachePolicy {
+	NO_COHERENCY,   /* No HW cache coherency support                        */
+	WT_COHERENCY,   /* HW cache coherency supported in Write Through policy */
+	WB_COHERENCY    /* HW cache coherency supported in Write Back policy    */
+} MV_CACHE_POLICY;
+
+/* The swapping is referred to a 64-bit words (as this is the controller
+ * internal data path width). This enumerator describes the possible
+ * data swap types. Below is an example of the data 0x0011223344556677
+ */
+typedef enum _mvSwapType {
+	MV_BYTE_SWAP,           /* Byte Swap                77 66 55 44 33 22 11 00 */
+	MV_NO_SWAP,             /* No swapping              00 11 22 33 44 55 66 77 */
+	MV_BYTE_WORD_SWAP,      /* Both byte and word swap  33 22 11 00 77 66 55 44 */
+	MV_WORD_SWAP,           /* Word swap                44 55 66 77 00 11 22 33 */
+	SWAP_TYPE_MAX           /* Delimiter for this enumerator                    */
+} MV_SWAP_TYPE;
+
+/*
+ * Define the different Ethernet complex sources for the RGMIIA/B and
+ * the FE/GE phy interfaces.
+ */
+typedef enum {
+	MV_ETHCOMP_SW_P0_2_GE_PHY_P0		=	BIT0,
+	MV_ETHCOMP_SW_P1_2_GE_PHY_P1		=	BIT1,
+	MV_ETHCOMP_SW_P2_2_GE_PHY_P2		=	BIT2,
+	MV_ETHCOMP_SW_P3_2_GE_PHY_P3		=	BIT3,
+	MV_ETHCOMP_SW_P4_2_RGMII0		=	BIT4,
+	/* Switch port 5 does not exist, ==> BIT5 is omitted */
+	MV_ETHCOMP_GE_MAC0_2_SW_P6		=	BIT6,
+	MV_ETHCOMP_GE_MAC0_2_GE_PHY_P0		=	BIT7,
+	MV_ETHCOMP_GE_MAC0_2_RGMII0		=	BIT8,
+	MV_ETHCOMP_GE_MAC0_2_COMPHY_1		=	BIT9,
+	MV_ETHCOMP_GE_MAC0_2_COMPHY_2		=	BIT10,
+	MV_ETHCOMP_GE_MAC0_2_COMPHY_3		=	BIT11,
+	MV_ETHCOMP_GE_MAC1_2_SW_P4		=	BIT12,
+	MV_ETHCOMP_GE_MAC1_2_GE_PHY_P3		=	BIT13,
+	MV_ETHCOMP_GE_MAC1_2_RGMII1		=	BIT14,
+	MV_ETHCOMP_GE_MAC1_2_PON_ETH_SERDES	=	BIT15,
+	MV_ETHCOMP_P2P_MAC_2_PON_ETH_SERDES	=	BIT16,
+} MV_ETH_COMPLEX_TOPOLOGY;
+
+typedef enum {
+	EPM_DEFAULT = 0x0,      /* RGMII */
+	EPM_MAC0_MII = 0x01,
+	EPM_MAC1_MII = 0x10,
+	EPM_SW_PORT_5_MII = 0x100,
+	EPM_SW_PORT_6_MII = 0x1000
+} MV_ETH_PORT_MODE;
+
+typedef enum {
+	SERDES_UNIT_UNCONNECTED = 0x0,
+	SERDES_UNIT_PEX         = 0x1,
+	SERDES_UNIT_SATA        = 0x2,
+	SERDES_UNIT_SGMII0      = 0x3,
+	SERDES_UNIT_SGMII1      = 0x4,
+	SERDES_UNIT_SGMII2      = 0x5,
+	SERDES_UNIT_SGMII3      = 0x6,
+	SERDES_UNIT_QSGMII      = 0x7,
+	SERDES_UNIT_LAST
+} MV_SERDES_UNIT_INDX;
+
+typedef enum {
+	PEX_BUS_DISABLED        = 0,
+	PEX_BUS_MODE_X1         = 1,
+	PEX_BUS_MODE_X4         = 2,
+	PEX_BUS_MODE_X8         = 3
+} MV_PEX_UNIT_CFG;
+
+/* Configuration per SERDES line.
+   Each nibble is MV_SERDES_LINE_TYPE */
+typedef struct _boardSerdesConf {
+	MV_U32 enableSerdesConfiguration;       /*This will determine if mvCtrlSerdesPhyConfig will configure the serdes*/
+	MV_U32 serdesLine0_7;                   /* Lines 0 to 7 SERDES MUX one nibble per line */
+	MV_U32 serdesLine8_15;                  /* Lines 8 to 15 SERDES MUX one nibble per line */
+	MV_PEX_UNIT_CFG pex0Mod;
+	MV_PEX_UNIT_CFG pex1Mod;
+	MV_PEX_UNIT_CFG pex2Mod;
+	MV_PEX_UNIT_CFG pex3Mod;
+	MV_U32 busSpeed;        /* Bus speed - one bit per SERDES line:
+	                           Low speed (0)		High speed (1)
+	                           PEX	2.5 G (10 bit)		5 G (20 bit)
+	                           SATA	1.5 G			3 G
+	                           SGMII        1.25 Gbps		3.125 Gbps	*/
+} MV_SERDES_CFG;
+
+/* Termal Sensor Registers */
+#define TSEN_STATE_REG							0xE8070
+#define TSEN_STATE_OFFSET						31
+#define TSEN_STATE_MASK							(0x1 << TSEN_STATE_OFFSET)
+
+#define TSEN_CONF_REG							0xE8074
+#define TSEN_CONF_OTF_CALIB_MASK				(0x1 << 8)
+
+#define TSEN_STATUS_REG							0xE8078
+#define TSEN_STATUS_TEMP_OUT_OFFSET				0
+#define TSEN_STATUS_TEMP_OUT_MASK				(0x1FF << TSEN_STATUS_TEMP_OUT_OFFSET)
+
+
+/* BIOS Modes related defines */
+#define SAR_CPU_FAB_GET(cpu, fab)       (((cpu & 0x7) << 21) | ((fab & 0xF) << 24))
+
+/* mcspLib.h API list */
+MV_STATUS mvCtrlSatRWrite(MV_SATR_TYPE_ID satrWriteField, MV_SATR_TYPE_ID satrReadField, MV_U8 val);
+MV_U32 mvCtrlSatRRead(MV_SATR_TYPE_ID satrField);
+MV_STATUS mvCtrlCpuDdrL2FreqGet(MV_FREQ_MODE *freqMode);
+MV_VOID mvCtrlSatrInit(MV_VOID);
+MV_VOID mvCtrlSysConfigInit(MV_VOID);
+MV_U32 mvCtrlSysConfigGet(MV_CONFIG_TYPE_ID configField);
+MV_U32 mvCtrlGetCpuNum(MV_VOID);
+MV_U32 mvCtrlGetQuadNum(MV_VOID);
+MV_STATUS mvCtrlUpdatePexId(MV_VOID);
+MV_BOOL mvCtrlIsValidSatR(MV_VOID);
+MV_BOOL mvCtrlIsEepromEnabled(MV_VOID);
+MV_STATUS mvCtrlEepromEnable(MV_BOOL enable);
+MV_STATUS mvCtrlBoardConfigGet(MV_U8 *tempVal);
+MV_U32 mvCtrlSocUnitInfoNumGet(MV_UNIT_ID unit);
+MV_STATUS mvCtrlEnvInit(MV_VOID);
+MV_U32    mvCtrlMppRegGet(MV_U32 mppGroup);
+MV_U32 mvCtrlGetJuncTemp(MV_VOID);
+MV_STATUS mvEthComplexInit(MV_U32 ethCompConfig);
+
+#if defined(MV_INCLUDE_PEX)
+MV_U32 mvCtrlPexMaxIfGet(MV_VOID);
+MV_U32 mvCtrlPexMaxUnitGet(MV_VOID);
+#else
+#define mvCtrlPciMaxIfGet()             1
+#endif
+MV_U32 mvCtrlPexActiveUnitNumGet(MV_VOID);
+
+#if defined(MV_INCLUDE_PCI)
+#define mvCtrlPciIfMaxIfGet()           1
+#else
+#define mvCtrlPciIfMaxIfGet()           0
+#endif
+
+MV_U32 mvCtrlEthMaxPortGet(MV_VOID);
+MV_U32 mvCtrlSataMaxPortGet(MV_VOID);
+#if defined(MV_INCLUDE_XOR)
+MV_U32 mvCtrlXorMaxChanGet(MV_VOID);
+MV_U32 mvCtrlXorMaxUnitGet(MV_VOID);
+#endif
+#if defined(MV_INCLUDE_USB)
+MV_U32 mvCtrlUsbMaxGet(MV_VOID);
+MV_U32 mvCtrlUsb3MaxGet(MV_VOID);
+#endif
+#if defined(MV_INCLUDE_SDIO)
+MV_U32 mvCtrlSdioSupport(MV_VOID);
+#endif
+MV_U32 mvCtrlTdmSupport(MV_VOID);
+MV_U32 mvCtrlTdmMaxGet(MV_VOID);
+MV_TDM_UNIT_TYPE mvCtrlTdmUnitTypeGet(MV_VOID);
+MV_U32 mvCtrlTdmUnitIrqGet(MV_VOID);
+MV_U32 mvCtrlDevFamilyIdGet(MV_U16 ctrlModel);
+MV_U16 mvCtrlModelGet(MV_VOID);
+MV_U8 mvCtrlRevGet(MV_VOID);
+MV_STATUS mvCtrlNameGet(char *pNameBuff);
+MV_U32 mvCtrlModelRevGet(MV_VOID);
+MV_STATUS mvCtrlModelRevNameGet(char *pNameBuff);
+MV_VOID mvCtrlAddrDecShow(MV_VOID);
+const MV_8 *mvCtrlTargetNameGet(MV_TARGET target);
+MV_U32    ctrlSizeToReg(MV_U32 size, MV_U32 alignment);
+MV_U32    ctrlRegToSize(MV_U32 regSize, MV_U32 alignment);
+MV_U32    ctrlSizeRegRoundUp(MV_U32 size, MV_U32 alignment);
+MV_U32 mvCtrlSysRstLengthCounterGet(MV_VOID);
+MV_STATUS ctrlWinOverlapTest(MV_ADDR_WIN *pAddrWin1, MV_ADDR_WIN *pAddrWin2);
+MV_STATUS ctrlWinWithinWinTest(MV_ADDR_WIN *pAddrWin1, MV_ADDR_WIN *pAddrWin2);
+MV_VOID mvCtrlSmiMasterSet(MV_SMI_CTRL smiCtrl);
+MV_VOID mvCtrlPwrClckSet(MV_UNIT_ID unitId, MV_U32 index, MV_BOOL enable);
+MV_BOOL mvCtrlPwrClckGet(MV_UNIT_ID unitId, MV_U32 index);
+MV_BOOL mvCtrlIsBootFromNOR(MV_VOID);
+MV_BOOL mvCtrlIsBootFromSPI(MV_VOID);
+MV_BOOL mvCtrlIsBootFromNAND(MV_VOID);
+MV_U32 mvCtrlDDRBudWidth(MV_VOID);
+MV_BOOL mvCtrlDDRThruXbar(MV_VOID);
+MV_BOOL mvCtrlDDRECC(MV_VOID);
+
+#define MV_SAR_INFO { \
+{ MV_SATR_CPU_DDR_L2_FREQ,	 0x003E0000,	17,	1, {1} },\
+{ MV_SATR_CORE_CLK_SELECT,	 0x00400000,	22,	1, {1} },\
+{ MV_SATR_CPU1_ENABLE,		 0x00008000,	15,	0, {1} },\
+{ MV_SATR_SSCG_DISABLE,		 0x00000002,	1,	0, {1} },\
+{ MV_SATR_I2C0_SERIAL_ROM,	 0X00000001,	0,	0, {1} },\
+{ MV_SATR_EXTERNAL_CPU_RESET,	 0X00000000,	0,	0, {1} },\
+{ MV_SATR_EXTERNAL_CORE_RESET,	 0X00000000,	0,	0, {1} },\
+{ MV_SATR_BOOT_DEVICE,		 0X000001F8,	3,	0, {1} },\
+{ MV_SATR_CPU_PLL_XTAL_BYPASS,	 0x00000200,	9,	0, {1} },\
+{ MV_SATR_PEX0_CLOCK,		 0x00000400,	10,	0, {1} },\
+{ MV_SATR_PEX1_CLOCK,		 0x00000800,	11,	0, {1} },\
+{ MV_SATR_REF_CLOCK_ENABLE,	 0x00000004,	2,	0, {1} },\
+{ MV_SATR_TESTER_OPTIONS,	 0x00080000,	19,	0, {1} },\
+{ MV_SATR_CPU0_ENDIANESS,	 0x00001000,	12,	0, {1} },\
+{ MV_SATR_CPU0_NMFI,		 0x00002000,	13,	0, {1} },\
+{ MV_SATR_CPU0_THUMB,		 0x00004000,	14,	0, {1} },\
+{ MV_SATR_EFUSE_BYPASS,		 0x00020000,	17,	0, {1} },\
+{ MV_SATR_POR_BYPASS,		 0x00100000,	20,	0, {1} },\
+{ MV_SATR_BOARD_ID,		 0x000000F0,	4,	1, {1} },\
+{ MV_SATR_WRITE_CPU_FREQ,	 0X0000001F,	0,	0, {1} },\
+{ MV_SATR_WRITE_CORE_CLK_SELECT, 0x00000001,	0,	1, {1} },\
+{ MV_SATR_WRITE_CPU1_ENABLE,	 0x00000002,	1,	1, {1} },\
+{ MV_SATR_WRITE_SSCG_DISABLE,	 0x00000004,	2,	1, {1} },\
+};
+
+#endif /* __INCmvCtrlEnvLibh */
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvRegs.h b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvRegs.h
new file mode 100644
index 0000000..fa7861f
--- /dev/null
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvRegs.h
@@ -0,0 +1,359 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+********************************************************************************
+   Marvell Commercial License Option
+
+   If you received this File from Marvell and you have entered into a commercial
+   license agreement (a "Commercial License") with Marvell, the File is licensed
+   to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+********************************************************************************
+   Marvell BSD License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File under the following licensing terms.
+   Redistribution and use in source and binary forms, with or without modification,
+   are permitted provided that the following conditions are met:
+
+*   Redistributions of source code must retain the above copyright notice,
+        this list of conditions and the following disclaimer.
+
+*   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+*   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+   ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+   ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvCtrlEnvRegsh
+#define __INCmvCtrlEnvRegsh
+
+#include "mvTypes.h"
+#include "mvCtrlEnvSpec.h"
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* CV Support */
+#define PEX0_MEM0       PEX0_MEM
+#define PCI0_MEM0       PEX0_MEM
+
+/* Controller revision info */
+#define PCI_CLASS_CODE_AND_REVISION_ID          0x008
+#define PCCRIR_REVID_OFFS                       0               /* Revision ID */
+#define PCCRIR_REVID_MASK                       (0xff << PCCRIR_REVID_OFFS)
+
+/* Controler environment registers offsets */
+#define MV_TDM_IRQ_NUM                          56
+
+/* CIB registers offsets */
+#define MV_CIB_CTRL_CFG_REG                     (MV_COHERENCY_FABRIC_OFFSET + 0x80)
+
+/*
+ * SoC Device Multiplex Register
+ */
+#define SOC_DEV_MUX_REG				0x18208
+
+/*
+ * Power Management Clock (PMC) Gating Control Register
+ */
+#define POWER_MNG_CTRL_REG			0x18220
+
+#define PMC_TDM_STOP_CLK_OFFS			25
+#define PMC_TDM_STOP_CLK_MASK			(1 << PMC_TDM_STOP_CLK_OFFS)
+#define PMC_TDM_STOP_CLK_EN			(1 << PMC_TDM_STOP_CLK_OFFS)
+#define PMC_TDM_STOP_CLK_STOP			(0 << PMC_TDM_STOP_CLK_OFFS)
+
+#define PMC_PEX_STOP_CLK_OFFS(port)		((port) + 5)
+#define PMC_PEX_STOP_CLK_MASK(port)		(1 << PMC_PEX_STOP_CLK_OFFS(port))
+#define PMC_PEX_STOP_CLK_EN(port)		(1 << PMC_PEX_STOP_CLK_OFFS(port))
+#define PMC_PEX_STOP_CLK_STOP(port)		(0 << PMC_PEX_STOP_CLK_OFFS(port))
+
+#define PMC_USB_STOP_CLK_OFFS			18
+#define PMC_USB_STOP_CLK_MASK			(1 << PMC_USB_STOP_CLK_OFFS)
+#define PMC_USB_STOP_CLK_EN			(1 << PMC_USB_STOP_CLK_OFFS)
+#define PMC_USB_STOP_CLK_STOP			(0 << PMC_USB_STOP_CLK_OFFS)
+
+#define PMC_SDIO_STOP_CLK_OFFS			17
+#define PMC_SDIO_STOP_CLK_MASK			(1 << PMC_SDIO_STOP_CLK_OFFS)
+#define PMC_SDIO_STOP_CLK_EN			(1 << PMC_SDIO_STOP_CLK_OFFS)
+#define PMC_SDIO_STOP_CLK_STOP			(0 << PMC_SDIO_STOP_CLK_OFFS)
+
+#define PMC_XOR_STOP_CLK_OFFS(xor_id)		(xor_id == 0 ? 22 : 28)
+#define PMC_XOR_STOP_CLK_MASK(xor_id)		(1 << PMC_XOR_STOP_CLK_OFFS(xor_id))
+#define PMC_XOR_STOP_CLK_EN(xor_id)		(1 << PMC_XOR_STOP_CLK_OFFS(xor_id))
+#define PMC_XOR_STOP_CLK_STOP(xor_id)		(0 << PMC_XOR_STOP_CLK_OFFS(xor_id))
+
+#define PMC_SATA_STOP_CLK_OFFS			14
+#define PMC_SATA_STOP_CLK_MASK			(3 << PMC_SATA_STOP_CLK_OFFS)
+#define PMC_SATA_STOP_CLK_EN			(3 << PMC_SATA_STOP_CLK_OFFS)
+#define PMC_SATA_STOP_CLK_STOP			(0 << PMC_SATA_STOP_CLK_OFFS)
+
+#define MPP_CONTROL_REG(id)                     (0x18000 + (id * 4))
+
+/* Sample at Reset */
+#define MPP_SAMPLE_AT_RESET(id)		(0xE8200 + ( id * 0x4 ))
+#define SATR_DEVICE_ID_2_0_OFFS		21
+#define SATR_DEVICE_ID_2_0_MASK		(3 << SATR_DEVICE_ID_2_0_OFFS)
+
+/* Core Divider Clock Control */
+#define CORE_DIV_CLK_CTRL(num)		(0xE8250 + ((num) * 0x4))
+
+#define DEV_ID_REG			0x18238
+#define VENDOR_ID_OFFS			0
+#define VENDOR_ID_MASK			0xFFFF
+#define DEVICE_ID_OFFS			16
+#define DEVICE_ID_MASK			0xFFFF0000
+#define DEV_VERSION_ID_REG		0x1823C
+#define REVISON_ID_OFFS			8
+#define REVISON_ID_MASK			0xF00
+
+/* SYSRSTn Length Counter */
+#define SYSRST_LENGTH_COUNTER_REG               0x18250
+#define SLCR_COUNT_OFFS                         0
+#define SLCR_COUNT_MASK                         (0x1FFFFFFF << SLCR_COUNT_OFFS)
+#define SLCR_CLR_OFFS                           31
+#define SLCR_CLR_MASK                           (1 << SLCR_CLR_OFFS)
+
+/* Device ID */
+#define CHIP_BOND_REG                           0x18238
+#define PCKG_OPT_MASK                           0x3
+
+/*****************/
+/* PUP registers */
+/*****************/
+#define PUP_EN_REG                              0x1864C
+
+/* Extract CPU, L2, DDR clocks SAR value from
+** SAR bits 24-27
+*/
+
+#ifndef MV_ASMLANGUAGE
+
+typedef enum {
+	MSAR_0_BOOT_NOR_FLASH,
+	MSAR_0_BOOT_NAND_NEW,
+	MSAR_0_BOOT_UART,
+	MSAR_0_BOOT_SPI_FLASH,
+	MSAR_0_BOOT_PEX,
+	MSAR_0_BOOT_SATA,
+	MSAR_0_BOOT_PROMPT,
+	MSAR_0_BOOT_SPI1_FLASH
+} MV_BOARD_BOOT_SRC;
+
+typedef struct _mvSATRBootTable {
+	MV_BOARD_BOOT_SRC bootSrc;
+	MV_U32 attr1;                           /* Device width/Port */
+	MV_U32 attr2;                           /* ALE TIming Parameters/Page Size/Serdes Lane/Address cycles */
+	MV_U32 attr3;                           /* Dev_Wen Dev_Oen Muxed/Address cycle/SPI interface */
+} MV_SATR_BOOT_TABLE;
+
+#define MV_SATR_TABLE_VAL { \
+/*00*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, 0, 0 }, \
+/*01*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT,             0, 1 }, \
+/*02*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, 0, 0 }, \
+/*03*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT,             0, 1 }, \
+/*04*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, 0, 0 }, \
+/*05*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT,             0, 1 }, \
+/*06*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, 0, 0 }, \
+/*07*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT,             0, 1 }, \
+/*08*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 0, 0 }, \
+/*09*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 6, 1 }, \
+/*10*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 0, 0 }, \
+/*11*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 6, 1 }, \
+/*12*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 4, 0 }, \
+/*13*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 6, 1 }, \
+/*14*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 5, 0 }, \
+/*15*/ { MSAR_0_BOOT_NOR_FLASH,  MSAR_0_BOOT_DEV_BUS_WIDTH_16BIT, 5, 1 }, \
+/*16*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_512B, MSAR_0_NAND_ECC_4BIT }, \
+/*17*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_512B, MSAR_0_NAND_ECC_4BIT }, \
+/*18*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_4BIT },	\
+/*19*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_8BIT },	\
+/*20*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_12BIT }, \
+/*21*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_2KB, MSAR_0_NAND_ECC_16BIT }, \
+/*22*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_4BIT },	\
+/*23*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_8BIT },	\
+/*24*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_12BIT }, \
+/*25*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_4KB, MSAR_0_NAND_ECC_16BIT }, \
+/*26*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_4BIT },	\
+/*27*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_8BIT },	\
+/*28*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_12BIT }, \
+/*29*/ { MSAR_0_BOOT_NAND_NEW, MSAR_0_BOOT_DEV_BUS_WIDTH_8BIT, MSAR_0_NAND_PAGE_SZ_8KB, MSAR_0_NAND_ECC_16BIT }, \
+/*30*/ { 0,           5,            60,          60           }, \
+/*31*/ { 0,           2,            40,          40           }, \
+/*32*/ {-1, -1, -1, -1 },\
+/*33*/ {-1, -1, -1, -1 },\
+/*34*/ {-1, -1, -1, -1 },\
+/*35*/ {-1, -1, -1, -1 },\
+/*36*/ {-1, -1, -1, -1 },\
+/*37*/ {-1, -1, -1, -1 },\
+/*38*/ { 0,           1,            2,            2              }, \
+/*39*/ { 0,           3,            6,            6              }, \
+/*40*/ { 0,           3,            5,            5              }, \
+/*41*/ { 0,           2,            6,            3              }, \
+/*42*/ { 0,           4,            10,          5              }, \
+/*43*/ { 0,           3,            6,            6              }, \
+/*44*/ { 0,           2,            4,            4              }, \
+/*45*/ { 0,           3,            6,            3              }, \
+/*46*/ { 0,           2,            5,            5              }, \
+/*47*/ { MSAR_0_BOOT_PROMPT,         2,            5,            5              }, \
+/*48*/ { MSAR_0_BOOT_UART,               1,            3,            3              }, \
+/*49*/ { MSAR_0_BOOT_SATA,                5,            10,          10           }, \
+/*50*/ { MSAR_0_BOOT_PEX,   3,            8,            4              }, \
+/*51*/ { MSAR_0_BOOT_PEX,   1,            2,            1              }, \
+/*52*/ { 0,           3,            6,            3              }, \
+/*53*/ { 0,           2,            8,            4              }, \
+/*54*/ { 0,           5,            10,          5              }, \
+/*55*/ { 0,           1,            20,          20           }, \
+/*56*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24_16BIT, 60        }, \
+/*57*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT, 60               }, \
+/*58*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI1, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24_16BIT, 60        }, \
+/*59*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI1, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT, 60               }, \
+/*60*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24_16BIT, 60        }, \
+/*61*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI0, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT, 60               }, \
+/*62*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI1, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_24_16BIT, 60        }, \
+/*63*/ { MSAR_0_BOOT_SPI_FLASH,     MSAR_0_SPI1, MSAR_0_BOOT_DEV_BUS_WIDTH_SPI_32BIT, 40               } \
+}
+
+typedef struct {
+	MV_U8 id;
+	MV_U32 cpuFreq;
+	MV_U32 ddrFreq;
+	MV_U32 l2Freq;
+} MV_FREQ_MODE;
+
+#define MV_SAR_FREQ_MODES { \
+		{ 0,  266,  266, 133 }, \
+		{ 1,  333,  167, 167 }, \
+		{ 2,  333,  222, 167 }, \
+		{ 3,  333,  333, 167 }, \
+		{ 4,  400,  200, 200 }, \
+		{ 5,  400,  267, 200 }, \
+		{ 6,  400,  400, 200 }, \
+		{ 7,  500,  250, 250 }, \
+		{ 8,  500,  334, 250 }, \
+		{ 9,  500,  400, 250 }, \
+		{ 10, 533,  267, 267 }, \
+		{ 11, 533,  356, 267 }, \
+		{ 12, 533,  533, 267 }, \
+		{ 13, 600,  300, 300 }, \
+		{ 14, 600,  400, 300 }, \
+		{ 15, 600,  600, 300 }, \
+		{ 16, 666,  333, 333 }, \
+		{ 17, 666,  444, 333 }, \
+		{ 18, 666,  666, 333 }, \
+		{ 19, 800,  267, 400 }, \
+		{ 20, 800,  400, 400 }, \
+		{ 21, 800,  534, 400 }, \
+		{ 22, 900,  300, 450 }, \
+		{ 23, 900,  450, 450 }, \
+		{ 24, 900,  600, 450 }, \
+		{ 25, 1000, 500, 500 }, \
+		{ 26, 1000, 667, 500 }, \
+		{ 27, 1000, 500, 333 }, \
+		{ 28, 400,  400, 400 }, \
+		{ 29, 1100, 550, 550 } \
+};
+
+#define MV_USER_SAR_FREQ_MODES { \
+		{ 6,  400,  400, 200 }, \
+		{ 14, 600,  400, 300 }, \
+		{ 21, 800,  534, 400 }, \
+		{ 25, 1000, 500, 500 }, \
+};
+
+/* These macros help units to identify a target Mport Arbiter group */
+#define MV_TARGET_IS_DRAM(target)   \
+	((target >= SDRAM_CS0) && (target <= SDRAM_CS3))
+
+#define MV_TARGET_IS_PEX0(target)   \
+	((target >= PEX0_MEM) && (target <= PEX0_IO))
+#define MV_TARGET_IS_PEX1(target)   \
+	((target >= PEX1_MEM) && (target <= PEX1_IO))
+
+#define MV_TARGET_IS_PEX(target)        ((target >= PEX0_MEM) && (target <= PEX1_IO))
+
+#define MV_TARGET_IS_DEVICE(target)     ((target >= DEVICE_CS0) && (target <= DEVICE_CS3))
+
+#define MV_CHANGE_BOOT_CS(target) target
+
+#define START_DEV_CS            DEV_CS0
+#define DEV_TO_TARGET(dev)      ((dev) + START_DEV_CS)
+
+#define PCI_IF0_MEM0            PEX0_MEM
+
+/* This enumerator defines the Marvell controller target ID (see Address map) */
+typedef enum _mvTargetId {
+	DRAM_TARGET_ID   = 0,  /* Port 0  -> DRAM interface             */
+	DEV_TARGET_ID    = 1,  /* Port 1  -> Device bus, BootROM, SPI, UART,
+				*	     GPIO, MPP, and Miscellaneous */
+	USB3_TARGET_ID   = 5,  /* Port 5  -> USB3 Unit,                 */
+	PEX_TARGET_ID    = 4,  /* Port 4  -> PCI Express 0 and 1        */
+	CRYPT_TARGET_ID  = 9,  /* Port 9  -> Crypto Engine SRAM         */
+	PP2_TARGET_ID = 15,    /* Port 12 -> PP2 Unit                   */
+	MAX_TARGETS_ID
+} MV_TARGET_ID;
+
+/*
+        This enum should reflect the units numbers in register
+        space which we will need when accessing the HW
+ */
+
+typedef enum {
+	PEX0_0x4        = 0,
+	PEX0_1x4        = 1,
+	PEX0_2x4        = 2,
+	PEX0_3x4        = 3,
+	PEX1_0x4        = 4,
+	PEX1_1x4        = 5,
+	PEX1_2x4        = 6,
+	PEX1_3x4        = 7,
+	PEX2_0x4        = 8,
+	PEX3_0x4        = 9,
+	PEXIF_MAX       = 10
+} MV_PEXIF_INDX;
+
+#endif /* MV_ASMLANGUAGE */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvSpec.h b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvSpec.h
new file mode 100644
index 0000000..af055283
--- /dev/null
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEnvSpec.h
@@ -0,0 +1,524 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+********************************************************************************
+   Marvell Commercial License Option
+
+   If you received this File from Marvell and you have entered into a commercial
+   license agreement (a "Commercial License") with Marvell, the File is licensed
+   to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+********************************************************************************
+   Marvell BSD License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File under the following licensing terms.
+   Redistribution and use in source and binary forms, with or without modification,
+   are permitted provided that the following conditions are met:
+
+*   Redistributions of source code must retain the above copyright notice,
+        this list of conditions and the following disclaimer.
+
+*   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+*   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+   ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+   ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvCtrlEnvSpech
+#define __INCmvCtrlEnvSpech
+
+#include "mvDeviceId.h"
+#include "mvSysHwConfig.h"
+
+#include "ctrlEnv/sys/mvCpuIfRegs.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#define MV_ARM_SOC
+#define SOC_NAME_PREFIX                         "MV88F"
+
+/*
+ * Armada-375 Units Address decoding
+ */
+#define MV_DRAM_REGS_OFFSET                     (0x0)
+#define MV_AURORA_L2_REGS_OFFSET                (0x8000)
+#define MV_RTC_REGS_OFFSET                      (0x10300)
+#define MV_DEV_BUS_REGS_OFFSET                  (0x10400)
+#define MV_SPI_REGS_OFFSET(unit)                (0x10600 + (unit * 0x80))
+#define MV_TWSI_SLAVE_REGS_OFFSET(chanNum)      (0x11000 + (chanNum * 0x100))
+#define MV_UART_REGS_OFFSET(chanNum)            (0x12000 + (chanNum * 0x100))
+#define MV_MPP_REGS_OFFSET                      (0x18000)
+#define MV_GPP_REGS_OFFSET(unit)                (0x18100 + ((unit) * 0x40))
+#define MV_MISC_REGS_OFFSET                     (0x18200)
+#define MV_COMMON_PHY_REGS_OFFSET               (0x18300)
+#define MV_IP_CONFIG_REGS_OFFSET                (0x18400)
+#define MV_CLK_CMPLX_REGS_OFFSET        	(0x18700)
+#define MV_ETH_COMPLEX_OFFSET			(0x18900)
+#define MV_MBUS_REGS_OFFSET                     (0x20000)
+#define CPU_GLOBAL_BASE                         (MV_MBUS_REGS_OFFSET)
+#define MV_COHERENCY_FABRIC_OFFSET              (0x20200) /* ??? IO Error Control Register = Offset: 0x00020200 */
+#define MV_CIB_CTRL_STATUS_OFFSET               (0x20280)
+#define MV_CNTMR_REGS_OFFSET                    (0x20300)
+
+/*
+ * CPU virtual/banked registers: 0x21000 to 0x21100 (64 registers).
+ * Physical registers:
+ * 	CPU0: 0x21800 - 0x21900
+ * 	CPU1: 0x21900 - 0x21a00
+ */
+#define MV_CPUIF_LOCAL_REGS_OFFSET              (0x21000)
+#define MV_CPUIF_REGS_OFFSET(cpu)               (0x21800 + (cpu) * 0x100)
+#define MV_CPU_HW_SEM_OFFSET                    (0x20500)
+
+/* PPv2 register base addresses */
+#define MV_PP2_REG_BASE                         (0xF0000)
+#define MV_ETH_BASE_ADDR                        (0xC0000)
+#define LMS_REG_BASE                            (MV_ETH_BASE_ADDR)
+#define MIB_COUNTERS_REG_BASE                   (MV_ETH_BASE_ADDR + 0x1000)
+#define GOP_MNG_REG_BASE                        (MV_ETH_BASE_ADDR + 0x3000)
+#define GOP_REG_BASE(port)                      (MV_ETH_BASE_ADDR + 0x4000 + ((port) / 2) * 0x3000 + ((port) % 2) * 0x1000)
+#define MV_PON_REGS_OFFSET                      (MV_ETH_BASE_ADDR + 0x8000)
+
+#define MV_PON_EXIST
+#define MV_ETH_MAX_TCONT                        16
+#define MV_ETH_RXQ_TOTAL_NUM                    32
+
+#define MV_PEX_IF_REGS_OFFSET(pexIf)            (pexIf < 8 ? (0x40000 + ((pexIf) / 4) * 0x40000 + ((pexIf) % 4) * 0x4000) \
+						 : (0x42000 + ((pexIf) % 8) * 0x40000))
+#define MV_USB_REGS_OFFSET(dev)                 (0x50000)
+#define MV_USB3_REGS_OFFSET(dev)                (0x5FF80)
+#define MV_XOR_REGS_OFFSET(unit)                (0x60800)
+#define MV_CESA_TDMA_REGS_OFFSET(chanNum)       (0x90000 + (chanNum * 0x2000))
+#define MV_CESA_REGS_OFFSET(chanNum)            (0x9D000 + (chanNum * 0x2000))
+#define MV_SATA_REGS_OFFSET                     (0xA0000)
+#define MV_COMM_UNIT_REGS_OFFSET                (0xB0000)
+#define MV_NFC_REGS_OFFSET                      (0xD0000)
+#define MV_SDMMC_REGS_OFFSET                    (0xD4000)
+
+#define MV_ETH_SMI_PORT   0
+
+/*
+ * Miscellanuous Controller Configurations
+ */
+
+#define INTER_REGS_SIZE                         _1M
+
+/* This define describes the TWSI interrupt bit and location */
+#define TWSI_CPU_MAIN_INT_CAUSE_REG(cpu)        CPU_MAIN_INT_CAUSE_REG(1, (cpu))
+#define TWSI0_CPU_MAIN_INT_BIT(ch)              ((ch) + 3)
+#define TWSI_SPEED                              100000
+
+#define MV_GPP_MAX_PINS                         68
+#define MV_GPP_MAX_GROUP                        3       /* group == configuration register? */
+#define MV_CNTMR_MAX_COUNTER            17              /* 4 global + 1 global WD + 2 per CPU + 4 CPU WD*/
+
+#define MV_IO_EXP_MAX_REGS			3
+
+#define MV_UART_MAX_CHAN                        4
+
+#define MV_XOR_MAX_UNIT                         2       /* XOR unit == XOR engine */
+#define MV_XOR_MAX_CHAN                         4       /* total channels for all units together*/
+#define MV_XOR_MAX_CHAN_PER_UNIT                2       /* channels for units */
+
+#define MV_SATA_MAX_CHAN                        2
+
+#define MV_MPP_MAX_GROUP                        9
+
+#define MV_DRAM_MAX_CS                          4
+#define MV_SPI_MAX_CS                           8
+/* This define describes the maximum number of supported PCI\PCIX Interfaces */
+#ifdef MV_INCLUDE_PCI
+	#define MV_PCI_MAX_IF                   1
+	#define MV_PCI_START_IF                 0
+	#define PCI_HOST_BUS_NUM(pciIf)         (pciIf)
+	#define PCI_HOST_DEV_NUM(pciIf)         0
+#else
+	#define MV_PCI_MAX_IF                   0
+	#define MV_PCI_START_IF                 0
+#endif
+
+/* This define describes the maximum number of supported PEX Interfaces */
+#define MV_PEX_MAX_IF                           2
+#define MV_PEX_MAX_UNIT                         2
+#ifdef MV_INCLUDE_PEX
+#define MV_INCLUDE_PEX0
+#define MV_DISABLE_PEX_DEVICE_BAR
+
+#define MV_PEX_START_IF                         MV_PCI_MAX_IF
+ #define PEX_HOST_BUS_NUM(pciIf)               (pciIf)
+ #define PEX_HOST_DEV_NUM(pciIf)               0
+#else
+ #undef MV_INCLUDE_PEX0
+#endif
+
+#define PCI_IO(pciIf)                           (PEX0_IO + 2 * (pciIf))
+#define PCI_MEM(pciIf, memNum)                  (PEX0_MEM0 + 2 * (pciIf))
+/* This define describes the maximum number of supported PCI Interfaces         */
+#define MV_IDMA_MAX_CHAN                        4
+#define MV_DEVICE_MAX_CS                        4
+
+#ifndef MV_USB_MAX_PORTS
+#define MV_USB_MAX_PORTS 3
+#endif
+
+/* CESA version #3: One channel, 2KB SRAM, TDMA, CHAIN Mode support */
+#define MV_CESA_VERSION                         3 /*TODO verify */
+#define MV_CESA_SRAM_SIZE                       (2 * 1024)
+
+/* This define describes the maximum number of supported Ethernet ports */
+#define MV_PON_PORT_ID				7
+#define MV_ETH_MAX_PORTS                        4
+#define MV_ETH_MAX_RXQ                          16/* Maximum number of RXQs can be mapped to each port */
+#define MV_ETH_MAX_TXQ                          8
+#define MV_ETH_RXQ_TOTAL_NUM                    32      /* Total number of RXQs for usage by all ports */
+#define MV_ETH_MAX_TCONT                        16      /* Maximum number of TCONTs supported by PON port */
+#define MV_ETH_TX_CSUM_MAX_SIZE                 9800
+
+/* This define describes the the support of USB */
+#define MV_USB_VERSION                          1
+
+#define MV_SPI_VERSION                          2
+
+#define MV_INCLUDE_SDRAM_CS0
+#define  MV_INCLUDE_SDRAM_CS1
+#undef  MV_INCLUDE_SDRAM_CS2
+#undef  MV_INCLUDE_SDRAM_CS3
+
+#define MV_INCLUDE_DEVICE_CS0
+#define MV_INCLUDE_DEVICE_CS1
+#define MV_INCLUDE_DEVICE_CS2
+#define MV_INCLUDE_DEVICE_CS3
+
+#ifndef MV_ASMLANGUAGE
+
+#define TBL_UNUSED      0       /* Used to mark unused entry */
+#define FREQ_MODES_NUM          29
+#define FREQ_MODES_NUM_6720	3
+
+#define MPP_GROUP_0_TYPE { \
+	0x55555555,     /* NAND_V2_BOOT_DEVICE  */ \
+	0x00020020,     /* SPI_BOOT_DEVICE	*/ \
+}
+
+typedef enum {
+	NAND_BOOT_V2,
+	SPI0_BOOT,
+	SPI0_BOOT_SPDIF_AUDIO,
+} MV_GROUP_0_TYPE;
+
+#define MPP_GROUP_1_TYPE { \
+	0x22555555,     /* NAND_V2_BOOT_DEVICE  */ \
+	0x22000022,     /* SPI_BOOT_DEVICE	*/ \
+}
+
+#define MV_GROUP_1_TYPE         MV_GROUP_0_TYPE
+
+#define MPP_GROUP_2_TYPE { \
+	0x22222222,     /* UART, TDM  */ \
+	0x22222222,     /* UART, TDM  */ \
+}
+
+typedef enum {
+	SLIC_SSI_DEV,
+	SLIC_ISI_DEV,
+	SLIC_ZSI_DEV,
+	SLIC_EXTERNAL_DEV
+} MV_GROUP_2_TYPE;
+
+#define MPP_GROUP_3_TYPE { \
+	0x33333333,     /* SDIO */ \
+	0x33333333,     /* SDIO	*/ \
+}
+
+typedef enum {
+	GE1_UNIT,
+	SDIO_UNIT,
+	SPI1_UNIT,
+	SDIO_SPI1_UNIT,
+} MV_GROUP_3_TYPE;
+
+#define MPP_GROUP_4_TYPE { \
+	0x04403330,     /* SPI, SMI */ \
+	0x04403330,     /* SPI, SMI */ \
+}
+
+typedef enum {
+	GE1_CPU_SMI_CTRL_TDM_LQ_UNIT,
+	GE1_CPU_SMI_CTRL_REF_CLK_OUT,
+	GE1_SW_SMI_CTRL_TDM_LQ_UNIT,
+	GE1_SW_SMI_CTRL_REF_CLK_OUT,
+	SPI1_CPU_SMI_CTRL_TDM_LQ_UNIT,
+	SPI1_CPU_SMI_CTRL_REF_CLK_OUT,
+	SPI1_SW_SMI_CTRL_TDM_LQ_UNIT,
+	SPI1_SW_SMI_CTRL_REF_CLK_OUT,
+} MV_GROUP_4_TYPE;
+
+#define MPP_GROUP_5_TYPE { \
+	0x22002044,     /* UART1, GE0 */ \
+	0x22002044,     /* UART1, GE0 */ \
+}
+typedef enum {
+	GE0_UNIT_PON_TX_FAULT,
+	GE0_UNIT_PON_CLK_OUT,
+	SWITCH_P4_PON_TX_FAULT,
+	SWITCH_P4_PON_CLK_OUT,
+} MV_GROUP_5_TYPE;
+
+#define MPP_GROUP_6_TYPE { \
+	0x22222222,     /* GE0  */ \
+	0x22222222,     /* GE0	*/ \
+}
+
+typedef enum {
+	GE0_UNIT,
+	SWITCH_P4,
+} MV_GROUP_6_TYPE;
+
+#define MPP_GROUP_7_TYPE { \
+	0x00000022,     /* GE0 , LED  */ \
+	0x00000022,     /* GE0 , LED  */ \
+}
+
+typedef enum {
+	SWITCH_P4_LED_MATRIX,
+	GE0_UNIT_LED_MATRIX,
+	SWITCH_P4_UA1_PTP,
+	GE0_UNIT_UA1_PTP,
+} MV_GROUP_7_TYPE;
+
+#define MPP_GROUP_8_TYPE { \
+		0x000,\
+}
+
+typedef enum {
+	LED_MATRIX_PTP,
+} MV_GROUP_8_TYPE;
+
+#define MPP_GROUP_TYPES { \
+	MPP_GROUP_0_TYPE, \
+	MPP_GROUP_1_TYPE, \
+	MPP_GROUP_2_TYPE, \
+	MPP_GROUP_3_TYPE, \
+	MPP_GROUP_4_TYPE, \
+	MPP_GROUP_5_TYPE, \
+	MPP_GROUP_6_TYPE, \
+	MPP_GROUP_7_TYPE, \
+	MPP_GROUP_8_TYPE, \
+}
+
+/* This enumerator defines the Marvell Units ID      */
+typedef enum {
+	SLIC_EXTERNAL_ID,
+	SLIC_ZARLINK_ID,
+	SLIC_SILABS_ID,
+	SLIC_LANTIQ_ID
+} MV_SLIC_UNIT_TYPE;
+
+typedef enum {
+	TDM_UNIT_2CH,
+	TDM_UNIT_8CH
+} MV_TDM_UNIT_TYPE;
+
+typedef enum _mvUnitId {
+	DRAM_UNIT_ID,
+	PEX_UNIT_ID,
+	ETH_GIG_UNIT_ID,
+	USB_UNIT_ID,
+	USB3_UNIT_ID,
+	IDMA_UNIT_ID,
+	XOR_UNIT_ID,
+	SATA_UNIT_ID,
+	TDM_UNIT_ID,
+	UART_UNIT_ID,
+	CESA_UNIT_ID,
+	SPI_UNIT_ID,
+	AUDIO_UNIT_ID,
+	SDIO_UNIT_ID,
+	TS_UNIT_ID,
+	XPON_UNIT_ID,
+	BM_UNIT_ID,
+	PNC_UNIT_ID,
+	I2C_UNIT_ID,
+	MAX_UNITS_ID
+} MV_UNIT_ID;
+
+/* This enumerator describes the Marvell controller possible devices that   */
+/* can be connected to its device interface.                                */
+typedef enum _mvDevice {
+#if defined(MV_INCLUDE_DEVICE_CS0)
+	DEV_CS0 = 0,    /* Device connected to dev CS[0]    */
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS1)
+	DEV_CS1 = 1,        /* Device connected to dev CS[1]    */
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS2)
+	DEV_CS2 = 2,        /* Device connected to dev CS[2]    */
+#endif
+#if defined(MV_INCLUDE_DEVICE_CS3)
+	DEV_CS3 = 3,    /* Device connected to dev CS[2]    */
+#endif
+	BOOT_CS,        /* Device connected to BOOT dev    */
+	MV_DEV_MAX_CS = MV_DEVICE_MAX_CS
+} MV_DEVICE;
+
+/* This enumerator described the possible Controller paripheral targets.    */
+/* Controller peripherals are designated memory/IO address spaces that the  */
+/* controller can access. They are also refered as "targets"                */
+typedef enum _mvTarget {
+	TBL_TERM = -1,	/* none valid target, used as targets list terminator*/
+	SDRAM_CS0,	/*  0 SDRAM chip select 0	*/
+	SDRAM_CS1,	/*  1 SDRAM chip select 1	*/
+	SDRAM_CS2,	/*  2 SDRAM chip select 2	*/
+	SDRAM_CS3,	/*  3 SDRAM chip select 3	*/
+	DEVICE_CS0,	/*  4 Device chip select 0	*/
+	DEVICE_CS1,	/*  5 Device chip select 1	*/
+	DEVICE_CS2,	/*  6 Device chip select 2	*/
+	DEVICE_CS3,	/*  7 Device chip select 3	*/
+	PEX0_MEM,	/*  8 PCI Express 0 Memory	*/
+	PEX0_IO,	/*  9 PCI Express 0 IO		*/
+	PEX1_MEM,	/* 10 PCI Express 1 Memory	*/
+	PEX1_IO,	/* 11 PCI Express 1 IO		*/
+	INTER_REGS,	/* 12 Internal registers	*/
+	DMA_UART,	/* 13 DMA based UART request	*/
+	SPI_CS0,	/* 14 SPI_CS0			*/
+	SPI_CS1,	/* 15 SPI_CS1			*/
+	SPI_CS2,	/* 16 SPI_CS2			*/
+	SPI_CS3,	/* 17 SPI_CS3			*/
+	SPI_CS4,	/* 18 SPI_CS4			*/
+	SPI_CS5,	/* 19 SPI_CS5			*/
+	SPI_CS6,	/* 20 SPI_CS6			*/
+	SPI_CS7,	/* 21 SPI_CS7			*/
+	BOOT_ROM_CS,	/* 22 BOOT_ROM_CS		*/
+	DEV_BOOCS,	/* 23 DEV_BOOCS			*/
+	USB3,           /* 24 USB3                      */
+	CRYPT0_ENG,     /* 25 Crypto0 Engine            */
+	PP2_CPU0,	/* 26 PP2 - CPU 0		*/
+	PP2_CPU1,	/* 27 PP2 - CPU 1		*/
+	MAX_TARGETS
+} MV_TARGET;
+
+#ifdef AURORA_IO_CACHE_COHERENCY
+#define DRAM_CS0_ATTR           0x1E
+#define DRAM_CS1_ATTR           0x1D
+#define DRAM_CS2_ATTR           0x1B
+#define DRAM_CS3_ATTR           0x17
+#else
+#define DRAM_CS0_ATTR           0x0E
+#define DRAM_CS1_ATTR           0x0D
+#define DRAM_CS2_ATTR           0x0B
+#define DRAM_CS3_ATTR           0x07
+#endif
+
+#define MAIN_BOOT_ATTR         0x1D    /* BootROM */
+#define SEC_BOOT_ATTR          0x2F    /* Boot Device CS */
+
+#define TARGETS_DEF_ARRAY {                                                 \
+	{ DRAM_CS0_ATTR, DRAM_TARGET_ID },	/* SDRAM_CS0             */ \
+	{ DRAM_CS1_ATTR, DRAM_TARGET_ID },	/* SDRAM_CS1             */ \
+	{ DRAM_CS2_ATTR, DRAM_TARGET_ID },	/* SDRAM_CS0             */ \
+	{ DRAM_CS3_ATTR, DRAM_TARGET_ID },	/* SDRAM_CS1             */ \
+	{ 0x3E, DEV_TARGET_ID	},		/* DEVICE_CS0            */ \
+	{ 0x3D, DEV_TARGET_ID	},		/* DEVICE_CS1            */ \
+	{ 0x3B, DEV_TARGET_ID	},		/* DEVICE_CS2            */ \
+	{ 0x37, DEV_TARGET_ID	},		/* DEVICE_CS3            */ \
+	{ 0xE8, PEX_TARGET_ID	},		/* PEX0_LANE0_MEM        */ \
+	{ 0xE0, PEX_TARGET_ID	},		/* PEX0_LANE0_IO         */ \
+	{ 0xD8, PEX_TARGET_ID	},		/* PEX1_LANE0_MEM        */ \
+	{ 0xD0, PEX_TARGET_ID	},		/* PEX1_LANE0_IO         */ \
+	{ 0xFF, 0xFF		},		/* INTER_REGS            */ \
+	{ 0x01, DEV_TARGET_ID	},		/* DMA_UART              */ \
+	{ 0x1E, DEV_TARGET_ID	},		/* SPI_CS0               */ \
+	{ 0x5E, DEV_TARGET_ID	},		/* SPI_CS1               */ \
+	{ 0x9E, DEV_TARGET_ID	},		/* SPI_CS2               */ \
+	{ 0xDE, DEV_TARGET_ID	},		/* SPI_CS3               */ \
+	{ 0x1F, DEV_TARGET_ID	},		/* SPI_CS4               */ \
+	{ 0x5F, DEV_TARGET_ID	},		/* SPI_CS5               */ \
+	{ 0x9F, DEV_TARGET_ID	},		/* SPI_CS6               */ \
+	{ 0xDF, DEV_TARGET_ID	},		/* SPI_CS7               */ \
+	{ MAIN_BOOT_ATTR, DEV_TARGET_ID },	/* Main Boot device      */ \
+	{ SEC_BOOT_ATTR, DEV_TARGET_ID  },	/* Secondary Boot device */ \
+	{ 0x00, USB3_TARGET_ID },               /* USB3                  */ \
+	{ 0x01, CRYPT_TARGET_ID	},		/* CRYPT_ENG0            */ \
+	{ 0x00, PP2_TARGET_ID	},		/* PP2 - CPU 0           */ \
+	{ 0x01, PP2_TARGET_ID	},		/* PP2 - CPU 1           */ \
+}
+
+#define CESA_TARGET_NAME_DEF    ("CRYPT_ENG0", "CRYPT_ENG1")
+#define TARGETS_NAME_ARRAY      {			\
+	"SDRAM_CS0",		/* SDRAM_CS0 */		\
+	"SDRAM_CS1",		/* SDRAM_CS1 */		\
+	"SDRAM_CS2",		/* SDRAM_CS1 */		\
+	"SDRAM_CS3",		/* SDRAM_CS1 */		\
+	"DEVICE_CS0",		/* DEVICE_CS0 */	\
+	"DEVICE_CS1",		/* DEVICE_CS1 */	\
+	"DEVICE_CS2",		/* DEVICE_CS2 */	\
+	"DEVICE_CS3",		/* DEVICE_CS3 */	\
+	"PEX0_MEM",		/* PEX0_MEM */		\
+	"PEX0_IO",		/* PEX0_IO */		\
+	"PEX1_MEM",		/* PEX1_MEM */		\
+	"PEX1_IO",		/* PEX1_IO */		\
+	"INTER_REGS",		/* INTER_REGS */	\
+	"DMA_UART",		/* DMA_UART */		\
+	"SPI_CS0",		/* SPI_CS0 */		\
+	"SPI_CS1",		/* SPI_CS1 */		\
+	"SPI_CS2",		/* SPI_CS2 */		\
+	"SPI_CS3",		/* SPI_CS3 */		\
+	"SPI_CS4",		/* SPI_CS4 */		\
+	"SPI_CS5",		/* SPI_CS5 */		\
+	"SPI_CS6",		/* SPI_CS6 */		\
+	"SPI_CS7",		/* SPI_CS7 */		\
+	"BOOT_ROM_CS",		/* BOOT_ROM_CS */	\
+	"DEV_BOOTCS",		/* DEV_BOOCS */		\
+	"USB3",                 /* USB3 */              \
+	"CRYPT1_ENG",		/* CRYPT1_ENG */	\
+	"PP2 - CPU 0",		/* PP2 - CPU 0 */	\
+	"PP2 - CPU 1"		/* PP2 - CPU 1 */	\
+}
+
+#endif /* MV_ASMLANGUAGE */
+
+#ifdef __cplusplus
+}
+#endif  /* __cplusplus */
+
+#endif  /* __INCmvCtrlEnvSpech */
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEthCompLib.c b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEthCompLib.c
new file mode 100644
index 0000000..7634101
--- /dev/null
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEthCompLib.c
@@ -0,0 +1,467 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    * 	Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *	Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *	Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include <mvCommon.h>
+#include <mvOs.h>
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "mvCtrlEthCompLib.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "pp2/gmac/mvEthGmacRegs.h"
+#include "pp2/gbe/mvPp2Gbe.h"
+
+static void mvEthComplexGbePhySrcSet(MV_U32 phy, MV_U32 src)
+{
+	MV_U32 reg;
+
+	reg = MV_REG_READ(MV_ETHCOMP_CTRL_REG);
+	reg &= ~ETHCC_GBE_PHY_PORT_SMI_SRC_MASK(phy);
+
+	src <<= ETHCC_GBE_PHY_PORT_SMI_SRC_OFFSET(phy);
+	src &= ETHCC_GBE_PHY_PORT_SMI_SRC_MASK(phy);
+
+	reg |= src;
+
+	MV_REG_WRITE(MV_ETHCOMP_CTRL_REG, reg);
+}
+
+static MV_U32 mvEthComplexSwPortSrcCalc(MV_U32 swPort, enum mvSwPortSrc src)
+{
+	MV_U32 val = 0x0;
+
+	if (swPort != 0 && swPort != 3 && swPort != 4 && swPort != 6) {
+		mvOsPrintf("%s: Wrong switch port (%d)\n",
+			   __func__, swPort);
+		return 0x0;
+	}
+
+	switch (swPort) {
+	case 0:
+	case 3:
+		if (src == ETHC_SW_PORT_SRC_GBE_PHY)
+			val = 0x1;
+		else if (src == ETHC_SW_PORT_SRC_NC)
+			val = 0x0;
+		else {
+			mvOsPrintf("%s: Wrong src (%d) for switch port (%d)\n",
+				   __func__, src, swPort);
+		}
+		break;
+	case 4:
+		if (src == ETHC_SW_PORT_SRC_MPP)
+			val = 0x1;
+		else if (src == ETHC_SW_PORT_SRC_GBE_MAC)
+			val = 0x0;
+		else {
+			mvOsPrintf("%s: Wrong src (%d) for switch port (%d)\n",
+				   __func__, src, swPort);
+		}
+		break;
+	case 6:
+		if (src == ETHC_SW_PORT_SRC_GBE_MAC)
+			val = 0x1;
+		else if (src == ETHC_SW_PORT_SRC_NC)
+			val = 0x0;
+		else {
+			mvOsPrintf("%s: Wrong src (%d) for switch port (%d)\n",
+				   __func__, src, swPort);
+		}
+		break;
+	}
+
+	return val;
+}
+
+static void mvEthComplexSwPortSrcSet(MV_U32 swPort, MV_U32 src)
+{
+	MV_U32 reg;
+
+	reg = MV_REG_READ(MV_ETHCOMP_CTRL_REG);
+	reg &= ~ETHCC_SW_PORT_SRC_MASK(swPort);
+
+	src <<= ETHCC_SW_PORT_SRC_OFFSET(swPort);
+	src &= ETHCC_SW_PORT_SRC_MASK(swPort);
+
+	reg |= src;
+
+	MV_REG_WRITE(MV_ETHCOMP_CTRL_REG, reg);
+}
+
+static void mvEthComplexGbePortSrcSet(MV_U32 port, MV_U32 src)
+{
+	MV_U32 reg;
+
+	reg = MV_REG_READ(MV_ETHCOMP_CTRL_REG);
+	reg &= ~ETHCC_GBE_MAC_SRC_MASK(port);
+
+	src <<= ETHCC_GBE_MAC_SRC_OFFSET(port);
+	src &= ETHCC_GBE_MAC_SRC_MASK(port);
+
+	reg |= src;
+
+	MV_REG_WRITE(MV_ETHCOMP_CTRL_REG, reg);
+}
+
+/*
+ * Set speed Gbe Port 0 when it is connected to switch port 6
+ */
+static void mvEthComplexGbeToSwitchSpeedSet(MV_ETH_PORT_SPEED speed)
+{
+	MV_U32 reg;
+
+	if (speed != MV_ETH_SPEED_1000 && speed != MV_ETH_SPEED_2000) {
+		mvOsPrintf("%s: wrong speed (%d)\n", __func__, speed);
+		return;
+	}
+
+	reg = MV_REG_READ(MV_ETHCOMP_CTRL_REG);
+	reg &= ~ETHCC_GE_MAC0_SW_PORT_6_SPEED_MASK;
+
+	if (speed == MV_ETH_SPEED_2000)
+		reg |= (0x1 << ETHCC_GE_MAC0_SW_PORT_6_SPEED_OFFSET);
+	else
+		reg |= (0x0 << ETHCC_GE_MAC0_SW_PORT_6_SPEED_OFFSET);
+
+	MV_REG_WRITE(MV_ETHCOMP_CTRL_REG, reg);
+
+	if (speed == MV_ETH_SPEED_2000) {
+		reg = MV_REG_READ(MV_ETHCOMP_SW_CONFIG_RESET_CTRL);
+		reg &= ~ETHSCRC_PORT_2G_SELECT_MASK;
+		reg |= (0x1 << ETHSCRC_PORT_2G_SELECT_OFFSET);
+		MV_REG_WRITE(MV_ETHCOMP_SW_CONFIG_RESET_CTRL, reg);
+	}
+}
+
+static void mvEthComplexPortDpClkSrcSet(MV_U32 port, MV_U32 src)
+{
+	MV_U32 reg;
+
+	reg = MV_REG_READ(MV_ETHCOMP_GOP_CTRL_STAT_REG);
+	reg &= ~ETHCGCS_PORT_DP_CLK_SRC_MASK(port);
+
+	src <<= ETHCGCS_PORT_DP_CLK_SRC_OFFSET(port);
+	src &= ETHCGCS_PORT_DP_CLK_SRC_MASK(port);
+
+	reg |= src;
+
+	MV_REG_WRITE(MV_ETHCOMP_GOP_CTRL_STAT_REG, reg);
+}
+
+static void mvEthComplexGopDevEnable(void)
+{
+	MV_U32 reg;
+
+	reg = MV_REG_READ(MV_ETHCOMP_GOP_CTRL_STAT_REG);
+	reg &= ~ETHCGCS_GOP_ENABLE_DEV_MASK;
+	reg |= (0x1 << ETHCGCS_GOP_ENABLE_DEV_OFFSET);
+
+	MV_REG_WRITE(MV_ETHCOMP_GOP_CTRL_STAT_REG, reg);
+}
+
+static void mvEthComplexSwResetSet(MV_BOOL setReset)
+{
+	MV_U32 reg;
+
+	reg = MV_REG_READ(MV_ETHCOMP_SW_CONFIG_RESET_CTRL);
+	reg &= ~ETHSCRC_SWITCH_RESET_MASK;
+
+	if (setReset == MV_TRUE)
+		reg |= (0x0 << ETHSCRC_SWITCH_RESET_OFFSET);
+	else
+		reg |= (0x1 << ETHSCRC_SWITCH_RESET_OFFSET);
+
+	MV_REG_WRITE(MV_ETHCOMP_SW_CONFIG_RESET_CTRL, reg);
+}
+
+static void mvEthComplexComPhySelectorSet(MV_U32 phy, MV_U32 val)
+{
+	MV_U32 reg;
+
+	reg = MV_REG_READ(MV_COMMON_PHY_SELECTORS_REG);
+	reg &= ~ETHCPS_COMPHY_SELECTOR_MASK(phy);
+
+	val <<= ETHCPS_COMPHY_SELECTOR_OFFSET(phy);
+	val &= ETHCPS_COMPHY_SELECTOR_MASK(phy);
+
+	reg |= val;
+
+	MV_REG_WRITE(MV_COMMON_PHY_SELECTORS_REG, reg);
+}
+
+static void mvEthComplexGbePhyPowerSet(MV_U32 phy, MV_BOOL setPowerUp)
+{
+	MV_U32 reg;
+
+	reg = MV_REG_READ(MV_ETHCOMP_GBE_PHY_CTRL1_REG(phy));
+	reg &= ~ETHCGPC1_PHY_POWER_DOWN_MASK;
+
+	if (setPowerUp == MV_TRUE)
+		reg |= (0x0 << ETHCGPC1_PHY_POWER_DOWN_OFFSET);
+	else
+		reg |= (0x3 << ETHCGPC1_PHY_POWER_DOWN_OFFSET);
+
+	MV_REG_WRITE(MV_ETHCOMP_GBE_PHY_CTRL1_REG(phy), reg);
+}
+
+static void mvEthComplexGbePhyPowerCycle(MV_U32 phy)
+{
+	mvEthComplexGbePhyPowerSet(phy, MV_FALSE);
+	mvOsDelay(100);
+	mvEthComplexGbePhyPowerSet(phy, MV_TRUE);
+}
+
+static void mvEthComplexGbePhyPdConfigEdetASet(MV_U32 phy, MV_U32 val)
+{
+	MV_U32 reg;
+
+	reg = MV_REG_READ(MV_ETHCOMP_GBE_PHY_CTRL1_REG(phy));
+	reg &= ~ETHCGPC1_PD_CFG_EDED_A_MASK;
+
+	val <<= ETHCGPC1_PD_CFG_EDED_A_OFFSET;
+	val &= ETHCGPC1_PD_CFG_EDED_A_MASK;
+
+	reg |= val;
+
+	MV_REG_WRITE(MV_ETHCOMP_GBE_PHY_CTRL1_REG(phy), reg);
+}
+
+static void mvEthComplexGbePhyPsEnaXcSSet(MV_U32 phy, MV_U32 val)
+{
+	MV_U32 reg;
+
+	reg = MV_REG_READ(MV_ETHCOMP_GBE_PHY_CTRL1_REG(phy));
+	reg &= ~ETHCGPC1_PS_ENA_XCS_MASK;
+
+	val <<= ETHCGPC1_PS_ENA_XCS_OFFSET;
+	val &= ETHCGPC1_PS_ENA_XCS_MASK;
+
+	reg |= val;
+
+	MV_REG_WRITE(MV_ETHCOMP_GBE_PHY_CTRL1_REG(phy), reg);
+}
+
+static void mvEthComplexGbePhyResetSet(MV_BOOL setReset)
+{
+	MV_U32 reg;
+
+	reg = MV_REG_READ(MV_ETHCOMP_QUAD_GBE_PHY_CTRL_STAT_REG);
+
+	reg &= ~ETHQPCS_DPLL_RESET_MASK;
+	reg &= ~ETHQPCS_RESET_MASK;
+
+	if (setReset == MV_TRUE) {
+		reg |= (0x0 << ETHQPCS_RESET_OFFSET);
+		reg |= (0x0 << ETHQPCS_DPLL_RESET_OFFSET);
+	} else {
+		reg |= (0x1 << ETHQPCS_RESET_OFFSET);
+		reg |= (0x1 << ETHQPCS_DPLL_RESET_OFFSET);
+	}
+
+	MV_REG_WRITE(MV_ETHCOMP_QUAD_GBE_PHY_CTRL_STAT_REG, reg);
+}
+
+static void mvEthComplexGopInit(int port, int isSgmii, int isPeriodicXon, int isAN)
+{
+	mvEthPortSgmiiSet(port, isSgmii);
+	mvEthPortPeriodicXonSet(port, isPeriodicXon);
+
+	if (isAN)
+		mvEthPortLinkSpeedFlowCtrl(port, MV_ETH_SPEED_AN, 0);
+	else
+		mvEthPortLinkSpeedFlowCtrl(port, MV_ETH_SPEED_1000, 1);
+
+	mvEthPortResetSet(port, MV_FALSE);
+}
+
+static void mvEthComplexMacToSwPort(MV_U32 port, MV_U32 swPort,
+				    MV_ETH_PORT_SPEED speed)
+{
+	MV_U32 src;
+
+	mvEthComplexSwResetSet(MV_FALSE);
+	mvOsDelay(200);
+
+	src = mvEthComplexSwPortSrcCalc(swPort, ETHC_SW_PORT_SRC_GBE_MAC);
+	mvEthComplexSwPortSrcSet(swPort, src);
+	mvEthComplexGbePortSrcSet(port, 0x1);
+
+	if (port == 0 && swPort == 6)
+		mvEthComplexGbeToSwitchSpeedSet(speed);
+	else
+		mvEthComplexPortDpClkSrcSet(port, 0x1);
+
+	mvEthComplexGopInit(port, MV_FALSE, MV_FALSE, MV_FALSE);
+	mvEthComplexComPhySelectorSet(2, 0x1);
+}
+
+static void mvEthComplexSwPortToRgmii(MV_U32 swPort, MV_U32 port)
+{
+	/* Not implemented */
+}
+
+static void mvEthComplexXponMacToPonSerdes(void)
+{
+	/* Not implemented */
+}
+
+static void mvEthComplexMacToGbePhy(MV_U32 port, MV_U32 phy, MV_U32 phyAddr)
+{
+	mvEthComplexGbePhySrcSet(phy, 0x0);
+	mvEthComplexGbePortSrcSet(port, 0x2);
+
+	if (port == 0)
+		mvEthComplexSwPortSrcSet(6, 0x0);
+
+	mvEthComplexPortDpClkSrcSet(port, 0x1);
+	mvEthComplexGbePhyPdConfigEdetASet(phy, 0x0);
+	mvEthComplexGbePhyPsEnaXcSSet(phy, 0x0);
+	mvEthComplexGbePhyResetSet(MV_FALSE);
+	mvEthComplexComPhySelectorSet(2, 0x1);
+	mvEthComplexGopInit(port, MV_FALSE, MV_FALSE, MV_TRUE);
+	mvEthPhyAddrSet(port, phy);
+}
+
+static void mvEthComplexMacToComPhy(MV_U32 port, MV_U32 comPhy)
+{
+	/* Not implemented */
+}
+
+static void mvEthComplexMac1ToPonSerdes(MV_U32 port)
+{
+	/* Not implemented */
+}
+
+static void mvEthComplexMacToRgmii(MV_U32 port, MV_U32 phy)
+{
+	mvEthComplexGbePortSrcSet(port, 0x0);
+	mvEthComplexPortDpClkSrcSet(port, 0x1);
+	mvEthComplexGopDevEnable();
+	mvEthComplexGopInit(port, MV_FALSE, MV_FALSE, MV_TRUE);
+	mvEthPhyAddrSet(port, phy);
+}
+
+static void mvEthComplexSwPortToGbePhy(MV_U32 swPort, MV_U32 phy)
+{
+	mvEthComplexSwPortSrcSet(swPort, 0x1);
+	mvEthComplexGbePhySrcSet(phy, 0x1);
+	mvEthComplexGbePhyResetSet(MV_FALSE);
+	mvEthComplexGbePhyPowerCycle(phy);
+}
+
+MV_STATUS mvEthComplexInit(MV_U32 ethCompConfig)
+{
+	MV_U32 c = ethCompConfig;
+
+	mvEthComplexGopDevEnable();
+
+	if (c & MV_ETHCOMP_GE_MAC0_2_SW_P6)
+		mvEthComplexMacToSwPort(0, 6, MV_ETH_SPEED_1000);
+
+	if (c & MV_ETHCOMP_GE_MAC0_2_GE_PHY_P0)
+		mvEthComplexMacToGbePhy(0, 0, mvBoardPhyAddrGet(0));
+
+	if (c & MV_ETHCOMP_GE_MAC0_2_RGMII0)
+		mvEthComplexMacToRgmii(0, mvBoardPhyAddrGet(0));
+
+	if (c & MV_ETHCOMP_GE_MAC0_2_COMPHY_1)
+		mvEthComplexMacToComPhy(0, 1);
+
+	if (c & MV_ETHCOMP_GE_MAC0_2_COMPHY_2)
+		mvEthComplexMacToComPhy(0, 2);
+
+	if (c & MV_ETHCOMP_GE_MAC0_2_COMPHY_3)
+		mvEthComplexMacToComPhy(0, 3);
+
+	if (c & MV_ETHCOMP_GE_MAC1_2_SW_P4)
+		mvEthComplexMacToSwPort(1, 4, MV_ETH_SPEED_1000);
+
+	if (c & MV_ETHCOMP_GE_MAC1_2_GE_PHY_P3)
+		mvEthComplexMacToGbePhy(1, 3, mvBoardPhyAddrGet(1));
+
+	if (c & MV_ETHCOMP_GE_MAC1_2_RGMII1)
+		mvEthComplexMacToRgmii(1, mvBoardPhyAddrGet(1));
+
+	if (c & MV_ETHCOMP_GE_MAC1_2_PON_ETH_SERDES)
+		mvEthComplexMac1ToPonSerdes(1);
+
+	if (c & MV_ETHCOMP_SW_P0_2_GE_PHY_P0)
+		mvEthComplexSwPortToGbePhy(0, 0);
+
+	if (c & MV_ETHCOMP_SW_P1_2_GE_PHY_P1)
+		mvEthComplexSwPortToGbePhy(0, 0);
+
+	if (c & MV_ETHCOMP_SW_P2_2_GE_PHY_P2)
+		mvEthComplexSwPortToGbePhy(0, 0);
+
+	if (c & MV_ETHCOMP_SW_P3_2_GE_PHY_P3)
+		mvEthComplexSwPortToGbePhy(3, 3);
+
+	if (c & MV_ETHCOMP_SW_P4_2_RGMII0)
+		mvEthComplexSwPortToRgmii(4, 0);
+
+	if (c & MV_ETHCOMP_P2P_MAC_2_PON_ETH_SERDES)
+		mvEthComplexXponMacToPonSerdes();
+
+	return MV_OK;
+}
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEthCompLib.h b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEthCompLib.h
new file mode 100644
index 0000000..ce96e25
--- /dev/null
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvCtrlEthCompLib.h
@@ -0,0 +1,166 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    * 	Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+    *	Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *	Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvCtrlEthCompLibh
+#define __INCmvCtrlEthCompLibh
+
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "mvSysEthConfig.h"
+
+/*******************************************************************************
+ * Ports Group Control and Status
+ */
+#define MV_ETHCOMP_GOP_CTRL_STAT_REG			MV_ETH_COMPLEX_BASE
+
+#define     ETHCGCS_PORT_DP_CLK_SRC_OFFSET(port)	((port == 0) ? 13 : 14)
+#define     ETHCGCS_PORT_DP_CLK_SRC_MASK(port)		(0x1 << ETHCGCS_PORT_DP_CLK_SRC_OFFSET(port))
+
+#define     ETHCGCS_GOP_ENABLE_DEV_OFFSET		19
+#define     ETHCGCS_GOP_ENABLE_DEV_MASK			(0x1 << ETHCGCS_GOP_ENABLE_DEV_OFFSET)
+
+/*******************************************************************************
+ * Ethernet Complex Control 0
+ */
+#define MV_ETHCOMP_CTRL_REG				(MV_ETH_COMPLEX_BASE + 0x10)
+
+#define     ETHCC_SW_PORT_SRC_OFFSET(port)		(port == 0 ? 4 : (port == 3 ? 5 : \
+							(port == 4 ? 6 : (port == 6 ? 7 : 4))))
+#define     ETHCC_SW_PORT_SRC_MASK(port)		(0x1 << ETHCC_SW_PORT_SRC_OFFSET(port))
+
+enum mvSwPortSrc {
+	ETHC_SW_PORT_SRC_NC,
+	ETHC_SW_PORT_SRC_GBE_MAC,
+	ETHC_SW_PORT_SRC_MPP,
+	ETHC_SW_PORT_SRC_GBE_PHY,
+};
+
+#define     ETHCC_GBE_MAC_SRC_OFFSET(port)		(port == 0 ? 10 : (port == 1 ? 12 : 10))
+#define     ETHCC_GBE_MAC_SRC_MASK(port)		(0x3 << ETHCC_GBE_MAC_SRC_OFFSET(port))
+
+#define     ETHCC_GBE_PHY_PORT_SMI_SRC_OFFSET(phy)	((phy >= 0 && phy <= 3) ? 14 + phy : 14)
+#define     ETHCC_GBE_PHY_PORT_SMI_SRC_MASK(phy)	(0x1 << ETHCC_GBE_PHY_PORT_SMI_SRC_OFFSET(phy))
+
+#define     ETHCC_GE_MAC0_SW_PORT_6_SPEED_OFFSET	18
+#define     ETHCC_GE_MAC0_SW_PORT_6_SPEED_MASK		(0x1 << ETHCC_GE_MAC0_SW_PORT_6_SPEED_OFFSET)
+
+#define     ETHCC_LOOPBACK_PORT_SPEED_OFFSET		19
+#define     ETHCC_LOOPBACK_PORT_SPEED_MASK		(0x1 << ETHCC_LOOPBACK_PORT_SPEED_OFFSET)
+
+/*******************************************************************************
+ * Switch Configuration and Reset Control
+ */
+#define MV_ETHCOMP_SW_CONFIG_RESET_CTRL			(MV_ETH_COMPLEX_BASE + 0x30)
+
+#define     ETHSCRC_SWITCH_RESET_OFFSET			0
+#define     ETHSCRC_SWITCH_RESET_MASK			(0x1 << ETHSCRC_SWITCH_RESET_OFFSET)
+
+#define     ETHSCRC_PORT_2G_SELECT_OFFSET		14
+#define     ETHSCRC_PORT_2G_SELECT_MASK			(0x1 << ETHSCRC_PORT_2G_SELECT_OFFSET)
+
+/*******************************************************************************
+ * GbE PHY <<%n>> Control 0.
+ * 0x000189A0 + n*4: where n (0-3) represents GPHY_Num.
+ */
+#define MV_ETHCOMP_GBE_PHY_CTRL0_REG(phy)		(MV_ETH_COMPLEX_BASE + 0xA0 + (phy * 0x4))
+
+#define     ETHCGPC0_PCS_PHY_ADDR_OFFSET		13
+#define     ETHCGPC0_PCS_PHY_ADDR_MASK			(0x1F << ETHCGPC0_PCS_PHY_ADDR_OFFSET)
+
+/*******************************************************************************
+ * GbE PHY <<%n>> Control 1.
+ * 0x000189B0 + n*4: where n (0-3) represents GPHY_Num.
+ */
+#define MV_ETHCOMP_GBE_PHY_CTRL1_REG(phy)		(MV_ETH_COMPLEX_BASE + 0xB0 + (phy * 0x4))
+
+#define     ETHCGPC1_PHY_POWER_DOWN_OFFSET		10
+#define     ETHCGPC1_PHY_POWER_DOWN_MASK		(0x3 << ETHCGPC1_PHY_POWER_DOWN_OFFSET)
+
+#define     ETHCGPC1_PS_ENA_XCS_OFFSET			12
+#define     ETHCGPC1_PS_ENA_XCS_MASK			(0x3 << ETHCGPC1_PS_ENA_XCS_OFFSET)
+
+#define     ETHCGPC1_PD_CFG_EDED_A_OFFSET		14
+#define     ETHCGPC1_PD_CFG_EDED_A_MASK			(0x7 << ETHCGPC1_PD_CFG_EDED_A_OFFSET)
+
+/*******************************************************************************
+ * Quad GbE PHY Common Control and Status
+ */
+#define MV_ETHCOMP_QUAD_GBE_PHY_CTRL_STAT_REG		(MV_ETH_COMPLEX_BASE + 0xD0)
+
+#define     ETHQPCS_RESET_OFFSET			0
+#define     ETHQPCS_RESET_MASK				(0x1 << ETHQPCS_DPLL_RESET_OFFSET)
+
+#define     ETHQPCS_DPLL_RESET_OFFSET			4
+#define     ETHQPCS_DPLL_RESET_MASK			(0x1 << ETHQPCS_DPLL_RESET_OFFSET)
+
+/*******************************************************************************
+ * Common PHYs Selectors
+ */
+#define MV_COMMON_PHY_SELECTORS_REG			MV_COMMON_PHY_REGS_OFFSET
+
+#define     ETHCPS_COMPHY_SELECTOR_OFFSET(phy)		(phy)
+#define     ETHCPS_COMPHY_SELECTOR_MASK(phy)		(0x1 << ETHCPS_COMPHY_SELECTOR_OFFSET(phy))
+
+MV_STATUS mvEthComplexInit(MV_U32 ethCompConfig);
+
+#endif /* __INCmvCtrlEthCompLibh */
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvSemaphore.c b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvSemaphore.c
new file mode 100644
index 0000000..3232328
--- /dev/null
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvSemaphore.c
@@ -0,0 +1,123 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "cpu/mvCpu.h"
+#include "ctrlEnv/mvSemaphore.h"
+
+MV_BOOL mvSemaLock(MV_32 num)
+{
+	MV_U32 tmp;
+	MV_U32 cpuId;
+	if (num > MV_MAX_SEMA)
+	{
+		mvOsPrintf("Invalid semaphore number\n");
+		return MV_FALSE;
+	}
+	cpuId = whoAmI();
+	do
+	{
+		tmp = MV_REG_BYTE_READ(MV_SEMA_REG_BASE+num);
+	} while ((tmp & 0xFF) != cpuId);
+	return MV_TRUE;
+}
+
+MV_BOOL mvSemaTryLock(MV_32 num)
+{
+	MV_U32 tmp;
+	if (num > MV_MAX_SEMA)
+	{
+		mvOsPrintf("Invalid semaphore number\n");
+		return MV_FALSE;
+	}
+	tmp = MV_REG_BYTE_READ(MV_SEMA_REG_BASE+num);
+	if ((tmp & 0xFF) != whoAmI())
+	{
+		return MV_FALSE;
+	}
+	else
+		return MV_TRUE;
+}
+
+MV_BOOL mvSemaUnlock(MV_32 num)
+{
+	if (num > MV_MAX_SEMA)
+	{
+		mvOsPrintf("Invalid semaphore number\n");
+		return MV_FALSE;
+	}
+	MV_REG_BYTE_WRITE(MV_SEMA_REG_BASE+(num), 0xFF);
+	return MV_TRUE;
+}
+
+MV_32 mvReadAmpReg(int regId)
+{
+	return MV_REG_READ(MV_AMP_GLOBAL_REG(regId));
+}
+
+MV_32 mvWriteAmpReg(int regId, MV_32 value)
+{
+	return MV_REG_WRITE(MV_AMP_GLOBAL_REG(regId), value);
+}
\ No newline at end of file
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvSemaphore.h b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvSemaphore.h
new file mode 100644
index 0000000..a5a94d3
--- /dev/null
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvSemaphore.h
@@ -0,0 +1,106 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#ifndef mvsemaphore_h
+#define mvsemaphore_h
+
+#ifdef MV_VXWORKS
+#include "common/mvTypes.h"
+#include "config.h"
+#endif
+
+#define MV_AMP_GLOBAL_REG(x)	(0x20980 + (4*x))
+#define ADR_WIN_EN_REG			0
+
+#define MV_SEMA_REG_BASE	(0x20500)
+#define MV_MAX_SEMA 	    	128
+#define MV_SEMA_SMI 		50
+#define MV_SEMA_RTC 		51
+#define MV_SEMA_NOR_FLASH 	0
+#define MV_SEMA_BOOT 		1
+#define MV_SEMA_PEX0 		2
+#define MV_SEMA_BRIDGE 		3
+#define MV_SEMA_IRQ 		4
+#define MV_SEMA_CLOCK		5
+#define MV_SEMA_L2		6
+#define MV_SEMA_TWSI		7
+#define MV_SEMA_ADR_WIN		8
+
+#define MV_SEMA_BARRIER(cpu)	(50 + cpu)
+
+
+MV_BOOL mvSemaLock(MV_32 num);
+MV_BOOL mvSemaTryLock(MV_32 num);
+MV_BOOL mvSemaUnlock(MV_32 num);
+MV_32   mvReadAmpReg(int regId);
+MV_32 	mvWriteAmpReg(int regId, MV_32 value);
+
+/* Turn on HW semapores only if AMP is enabled */
+#ifndef CONFIG_MV_AMP_ENABLE
+#define mvSemaLock
+#define mvSemaTryLock
+#define mvSemaUnlock
+#define mvHwBarrier
+#endif /* CONFIG_MV_AMP_ENABLE */
+
+#endif /* mvsemaphore_h */
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvUnitMap.c b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvUnitMap.c
new file mode 100644
index 0000000..9d9e172
--- /dev/null
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvUnitMap.c
@@ -0,0 +1,231 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "cpu/mvCpu.h"
+#include "boardEnv/mvBoardEnvLib.h"
+#include "ctrlEnv/mvUnitMap.h"
+
+static MV_BOOL mv_rsrc_limited = MV_FALSE;
+static MV_RES_MAP mv_res_table[] = {
+	/* Dividable units */
+	{0, "uart0"},
+	{0, "uart1"},
+	{0, "pex0"},
+	{0, "pex1"},
+	{0, "pex2"},
+	{0, "pex3"},
+	{0, "eth0"},
+	{0, "eth1"},
+	{0, "eth2"},
+	{0, "eth3"},
+	{0, "xor0"},
+	{0, "xor1"},
+	{0, "usb0"},
+	{0, "usb1"},
+	{0, "usb2"},
+	{0, "i2c0"},
+	{0, "i2c1"},
+	/* Single Allocation units */
+	{0, "sata"},
+	{0, "cesa"},
+	{0, "nor"},
+	{0, "nand"},
+	{0, "spi"},
+	{0, "tdm"},
+	{0, "sdio"},
+	{0, "lcd"},
+	{0, "hwmon"},
+	{0, "rtc"},
+	{0, "gpio"},
+	{0, "mstr"},
+	{-1, "last"}
+};
+
+MV_BOOL mvUnitMapIsRsrcLimited(void)
+{
+	return mv_rsrc_limited;
+}
+
+MV_VOID mvUnitMapSetRsrcLimited(MV_BOOL isLimited)
+{
+	mv_rsrc_limited = isLimited;
+}
+
+MV_BOOL mvUnitMapIsMine(MV_SOC_UNIT unitIdx)
+{
+	return mv_res_table[unitIdx].isMine;
+}
+
+MV_BOOL mvUnitMapIsPexMine(int pciIf)
+{
+	MV_SOC_UNIT unitIdx;
+
+	/* Map line Number to PEX unit number */
+	/* This is compatible to mvCtrlSerdesPhyConfig in BoardEnvLib.c */
+	if(pciIf < PEX1_0x4)
+		unitIdx = PEX0;
+	else if(pciIf < PEX2_0x4)
+		unitIdx = PEX1;
+	else if(pciIf < PEX3_0x4)
+		unitIdx = PEX2;
+	else
+		unitIdx = PEX3;
+
+	return mv_res_table[unitIdx].isMine;
+}
+
+MV_VOID mvUnitMapSetMine(MV_SOC_UNIT unitIdx)
+{
+	if (MV_TRUE == mv_res_table[unitIdx].isMine)
+		return;
+
+	mv_res_table[unitIdx].isMine = 1;
+}
+
+MV_BOOL mvUnitMapSetup(char* cmdLine, STRSTR_FUNCPTR strstr_func)
+{
+	int unitIdx;
+	char* match;
+
+	for (unitIdx = 0; mv_res_table[unitIdx].isMine != (-1); unitIdx++) {
+		char *unitName = mv_res_table[unitIdx].unitName;
+		int len;
+		match = strstr_func(cmdLine, unitName);
+		if (!match) continue;
+		/*Look for start delimiter*/
+		if (match > cmdLine) {
+			if (match[-1] != ' ' && match[-1] != ':') {
+				continue;
+			}
+		}
+		/* Calc string length without using strlen() */
+		while (*unitName++ != '\0');
+		len = unitName - mv_res_table[unitIdx].unitName - 1;
+		/*Look for end delimiter*/
+		if (match[len] != ' ' && match[len] != ':' && match[len] != '\0') {
+			continue;
+		}
+		mvUnitMapSetMine(unitIdx);
+	}
+	return MV_TRUE;
+}
+
+MV_U32 mvSocUnitMapFillFlagFormTable(void)
+{
+	int i;
+	MV_U32 flag = 0;
+	for (i = 0; mv_res_table[i].cpuId != -1; i++)
+	{
+	    if (mvSocUnitMapGet(i) == 0)//SLAVE_CPU)
+	    {
+		switch (i)
+		{
+		case UART0:  flag |= UART0_T0_CPU1;   	break;
+		case UART1:  flag |= UART1_TO_CPU1;   	break;
+		case PEX00:  flag |= PEX0_TO_CPU1;    	break;
+		case PEX10:  flag |= PEX1_TO_CPU1;    	break;
+		case GIGA0:  flag |= GIGA0_TO_CPU1;   	break;
+		case GIGA1:  flag |= GIGA1_TO_CPU1;   	break;
+		case GIGA2:  flag |= GIGA2_TO_CPU1;   	break;
+		case GIGA3:  flag |= GIGA3_TO_CPU1;   	break;
+		case SATA:   flag |= SATA_TO_CPU1;    	break;
+		case XOR:    flag |= XOR_TO_CPU1;	break;
+		case IDMA:   flag |= IDMA_TO_CPU1;    	break;
+		case USB0:   flag |= USB0_TO_CPU1;    	break;
+		case USB1:   flag |= USB1_TO_CPU1;    	break;
+		case USB2:   flag |= USB2_TO_CPU1;    	break;
+		case CESA:   flag |= CESA_TO_CPU1;    	break;
+		case NOR_FLASH: flag |= NOR_TO_CPU1;   break;
+		case NAND_FLASH: flag |= NAND_TO_CPU1;   break;
+		case SPI_FLASH: flag |= SPI_TO_CPU1;   break;
+		case TDM: flag |= TDM_TO_CPU1;   break;
+		default:
+			break;
+		}
+	    }
+	}
+
+	return flag;
+}*/
+MV_VOID mvUnitMapSetAllMine()
+{
+	int unitIdx;
+	for (unitIdx = 0; mv_res_table[unitIdx].isMine != (-1); unitIdx++) {
+		mvUnitMapSetMine(unitIdx);
+	}
+}
+
+MV_VOID mvUnitMapPrint()
+{
+	int unitIdx;
+	mvOsPrintf("  AMP: Resources ");
+	for (unitIdx = 0; mv_res_table[unitIdx].isMine != -1; unitIdx++) {
+		if (mv_res_table[unitIdx].isMine) {
+			mvOsPrintf("- %s ", mv_res_table[unitIdx].unitName);
+		}
+	}
+	mvOsPrintf("\n");
+}
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvUnitMap.h b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvUnitMap.h
new file mode 100644
index 0000000..0321d7b
--- /dev/null
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/mvUnitMap.h
@@ -0,0 +1,158 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#ifndef mvUnitMap_h
+#define mvUnitMap_h
+
+#ifdef MV_VXWORKS
+#include "common/mvTypes.h"
+#include "config.h"
+#endif
+
+typedef enum
+{
+	UART0=0,
+	UART1,
+	PEX0,
+	PEX1,
+	PEX2,
+	PEX3,
+	ETH0,
+	ETH1,
+	ETH2,
+	ETH3,
+	XOR0,
+	XOR1,
+	USB0,
+	USB1,
+	USB2,
+	I2C0,
+	I2C1,
+	SATA,
+	CESA,
+	NOR,
+	NAND,
+	SPI,
+	TDM,
+	SDIO,
+	LCD,
+	HWMON,
+	RTC,
+	GPIO,
+	MSTR,
+	MAX_UNITS
+} MV_SOC_UNIT;
+
+/* binary flags for mvSocUnitMapFillTableFormBitMap */
+/*#define UART0_T0_CPU1	0x0001
+#define UART1_TO_CPU1	0x0002
+#define PEX0_TO_CPU1	0x0004
+#define PEX1_TO_CPU1	0x0008
+#define GIGA0_TO_CPU1	0x0010
+#define GIGA1_TO_CPU1	0x0020
+#define GIGA2_TO_CPU1	0x0040
+#define GIGA3_TO_CPU1	0x0080
+#define SATA_TO_CPU1	0x0100
+#define XOR_TO_CPU1		0x0200
+#define IDMA_TO_CPU1	0x0400
+#define USB0_TO_CPU1	0x0800
+#define USB1_TO_CPU1    0x1000
+#define USB2_TO_CPU1    0x2000
+#define CESA_TO_CPU1	0x4000
+#define NOR_TO_CPU1		0x8000
+#define NAND_TO_CPU1	0x10000
+#define SPI_TO_CPU1		0x20000
+#define TDM_TO_CPU1		0x40000
+
+#define CPU1_DEFAULT_INTERFACE (UART1_TO_CPU1 | PEX1_TO_CPU1 | GIGA2_TO_CPU1 | GIGA3_TO_CPU1 | IDMA_TO_CPU1 | USB1_TO_CPU1)*/
+
+typedef struct __MV_RES_MAP
+{
+	int	isMine;
+	char*	unitName;
+} MV_RES_MAP;
+
+typedef char *(*STRSTR_FUNCPTR)(const char *s1, const char *s2);
+
+#ifdef CONFIG_MV_AMP_ENABLE
+
+MV_BOOL mvUnitMapIsMine(MV_SOC_UNIT unitIdx);
+MV_BOOL mvUnitMapIsPexMine(int pciIf);
+MV_VOID mvUnitMapSetMine(MV_SOC_UNIT unitIdx);
+MV_BOOL mvUnitMapSetup(char* p, STRSTR_FUNCPTR strstr_func);
+MV_VOID mvUnitMapSetAllMine(void);
+MV_VOID mvUnitMapPrint(void);
+MV_BOOL mvUnitMapIsRsrcLimited(void);
+MV_VOID mvUnitMapSetRsrcLimited(MV_BOOL isLimited);
+#else /* CONFIG_MV_AMP_ENABLE */
+#define mvUnitMapIsMine(rsrc) 		MV_TRUE
+#define mvUnitMapIsPexMine(pciIf) 	MV_TRUE
+#define mvUnitMapIsRsrcLimited 	  	MV_TRUE
+#define mvUnitMapSetRsrcLimited(limit)
+#define mvUnitMapSetMine(rsrc)
+#define mvUnitMapSetAllMine
+#define mvUnitMapPrint
+#define mvUnitMapSetup(str, strstr_func) MV_TRUE
+#endif /* CONFIG_MV_AMP_ENABLE */
+
+#endif /* mvUnitMap_h */
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/sys/mvAhbToMbus.c b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/sys/mvAhbToMbus.c
new file mode 100644
index 0000000..1f2d954
--- /dev/null
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/sys/mvAhbToMbus.c
@@ -0,0 +1,742 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/* includes */
+#include "ctrlEnv/sys/mvAhbToMbus.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+#include "mvCpuIfRegs.h"
+
+#undef MV_DEBUG
+/* defines  */
+#ifdef MV_DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+/* typedefs */
+
+/* CPU address remap registers offsets are inconsecutive. This struct		*/
+/* describes address remap register offsets					*/
+typedef struct _ahbToMbusRemapRegOffs {
+	MV_U32 lowRegOffs;	/* Low 32-bit remap register offset             */
+	MV_U32 highRegOffs;	/* High 32 bit remap register offset            */
+} AHB_TO_MBUS_REMAP_REG_OFFS;
+
+/* locals   */
+static MV_STATUS ahbToMbusRemapRegOffsGet(MV_U32 winNum, AHB_TO_MBUS_REMAP_REG_OFFS *pRemapRegs);
+
+/*******************************************************************************
+* mvAhbToMbusInit - Initialize Ahb To Mbus Address Map !
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_OK laways.
+*
+*******************************************************************************/
+MV_STATUS mvAhbToMbusInit(void)
+{
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvAhbToMbusWinSet - Set CPU-to-peripheral winNum address window
+*
+* DESCRIPTION:
+*       This function sets
+*       address window, also known as address decode window.
+*       A new address decode window is set for specified winNum address window.
+*       If address decode window parameter structure enables the window,
+*       the routine will also enable the winNum window, allowing CPU to access
+*       the winNum window.
+*
+* INPUT:
+*       winNum      - Windows number.
+*       pAddrDecWin - CPU winNum window data structure.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_OK if CPU winNum window was set correctly, MV_ERROR in case of
+*       address window overlapps with other active CPU winNum window or
+*		trying to assign 36bit base address while CPU does not support that.
+*       The function returns MV_NOT_SUPPORTED, if the winNum is unsupported.
+*
+*******************************************************************************/
+MV_STATUS mvAhbToMbusWinSet(MV_U32 winNum, MV_AHB_TO_MBUS_DEC_WIN *pAddrDecWin)
+{
+	MV_TARGET_ATTRIB targetAttribs;
+	MV_DEC_REGS decRegs;
+	MV_U32 sizeToReg;
+
+	if (winNum >= MAX_AHB_TO_MBUS_WINS) {
+		mvOsPrintf("%s: Error: Invalid winNum %d\n", __func__, winNum);
+		return MV_NOT_SUPPORTED;
+	}
+
+	/* check if address is aligned to the size */
+	if (MV_IS_NOT_ALIGN(pAddrDecWin->addrWin.baseLow, pAddrDecWin->addrWin.size)) {
+		mvOsPrintf("%s: Error: Setting AHB to MBUS window %d to "
+			   "target %s.\nAddress 0x%08x is unaligned to size 0x%llx.\n",
+			   __func__, winNum, mvCtrlTargetNameGet(pAddrDecWin->target),
+			   pAddrDecWin->addrWin.baseLow, pAddrDecWin->addrWin.size);
+		return MV_ERROR;
+	}
+
+	/* Size parameter validity check */
+	if (MV_IS_NOT_ALIGN(pAddrDecWin->addrWin.size, ATMWCR_WIN_SIZE_ALIGNMENT)) {
+		mvOsPrintf("%s: Failed, size not aligned to 0x%x.\n",
+			   __func__, ATMWCR_WIN_SIZE_ALIGNMENT);
+		return MV_BAD_PARAM;
+	}
+
+	/* Write to address decode Base Address Register */
+	decRegs.baseReg = (pAddrDecWin->addrWin.baseLow & ATMWBR_BASE_MASK);
+
+	/* Get size register value according to window size */
+	sizeToReg = (pAddrDecWin->addrWin.size / ATMWCR_WIN_SIZE_ALIGNMENT) - 1;
+
+	/* set size */
+	decRegs.ctrlReg = (sizeToReg << ATMWCR_WIN_SIZE_OFFS);
+
+	/* enable/disable */
+	if (MV_TRUE == pAddrDecWin->enable)
+		decRegs.ctrlReg |= ATMWCR_WIN_ENABLE;
+	else
+		decRegs.ctrlReg &= ~ATMWCR_WIN_ENABLE;
+
+	mvCtrlAttribGet(pAddrDecWin->target, &targetAttribs);
+
+	/* set attributes */
+	decRegs.ctrlReg &= ~ATMWCR_WIN_ATTR_MASK;
+	decRegs.ctrlReg |= targetAttribs.attrib << ATMWCR_WIN_ATTR_OFFS;
+	/* set target ID */
+	decRegs.ctrlReg &= ~ATMWCR_WIN_TARGET_MASK;
+	decRegs.ctrlReg |= targetAttribs.targetId << ATMWCR_WIN_TARGET_OFFS;
+
+#if !defined(MV_RUN_FROM_FLASH)
+	/* To be on the safe side: disable window before writing new values. */
+	if (winNum != MV_AHB_TO_MBUS_INTREG_WIN)
+		mvAhbToMbusWinEnable(winNum, MV_FALSE);
+#endif
+
+	/* Write to address decode Base Address Register */
+	if (winNum != MV_AHB_TO_MBUS_INTREG_WIN)
+		MV_REG_WRITE(AHB_TO_MBUS_WIN_BASE_REG(winNum), decRegs.baseReg);
+	else
+		MV_REG_WRITE(AHB_TO_MBUS_WIN_INTEREG_REG, decRegs.baseReg);
+
+	/* Internal register space have no size */
+	/* register. Do not perform size register assigment for those targets   */
+	if (winNum != MV_AHB_TO_MBUS_INTREG_WIN) {
+		/* Write to address decode Size Register */
+		MV_REG_WRITE(AHB_TO_MBUS_WIN_CTRL_REG(winNum), decRegs.ctrlReg);
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvAhbToMbusWinGet - Get CPU-to-peripheral winNum address window
+*
+* DESCRIPTION:
+*		Get the CPU peripheral winNum address window.
+*
+* INPUT:
+*       winNum - Peripheral winNum enumerator
+*
+* OUTPUT:
+*       pAddrDecWin - CPU winNum window information data structure.
+*
+* RETURN:
+*       MV_OK if winNum exist, MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvAhbToMbusWinGet(MV_U32 winNum, MV_AHB_TO_MBUS_DEC_WIN *pAddrDecWin)
+{
+	MV_DEC_REGS decRegs;
+	MV_TARGET_ATTRIB targetAttrib;
+	MV_U32 sizeRegVal;
+
+	if (winNum >= MAX_AHB_TO_MBUS_WINS) {
+		mvOsPrintf("%s: Error: Invalid winNum %d\n", __func__, winNum);
+		return MV_NOT_SUPPORTED;
+	}
+
+	/* Internal register space size have no size register */
+	if (winNum != MV_AHB_TO_MBUS_INTREG_WIN)
+		decRegs.ctrlReg = MV_REG_READ(AHB_TO_MBUS_WIN_CTRL_REG(winNum));
+	else
+		decRegs.ctrlReg = 0;
+
+	/* Read base and size   */
+	if (winNum != MV_AHB_TO_MBUS_INTREG_WIN)
+		decRegs.baseReg = MV_REG_READ(AHB_TO_MBUS_WIN_BASE_REG(winNum));
+	else
+		decRegs.baseReg = MV_REG_READ(AHB_TO_MBUS_WIN_INTEREG_REG);
+
+	pAddrDecWin->addrWin.baseHigh = 0;
+	pAddrDecWin->addrWin.baseLow = decRegs.baseReg & ATMWBR_BASE_MASK;
+	sizeRegVal = (decRegs.ctrlReg & ATMWCR_WIN_SIZE_MASK) >> ATMWCR_WIN_SIZE_OFFS;
+	pAddrDecWin->addrWin.size = (sizeRegVal + 1) * ATMWCR_WIN_SIZE_ALIGNMENT;
+
+	if (winNum == MV_AHB_TO_MBUS_INTREG_WIN) {
+		pAddrDecWin->addrWin.size = INTER_REGS_SIZE;
+		pAddrDecWin->target = INTER_REGS;
+		pAddrDecWin->enable = MV_TRUE;
+		return MV_OK;
+	}
+
+	if (decRegs.ctrlReg & ATMWCR_WIN_ENABLE)
+		pAddrDecWin->enable = MV_TRUE;
+	else
+		pAddrDecWin->enable = MV_FALSE;
+
+	if (-1 == pAddrDecWin->addrWin.size)
+		return MV_ERROR;
+
+	/* attrib and targetId */
+	targetAttrib.attrib = (decRegs.ctrlReg & ATMWCR_WIN_ATTR_MASK) >> ATMWCR_WIN_ATTR_OFFS;
+	targetAttrib.targetId = (decRegs.ctrlReg & ATMWCR_WIN_TARGET_MASK) >> ATMWCR_WIN_TARGET_OFFS;
+
+	pAddrDecWin->target = mvCtrlTargetGet(&targetAttrib);
+
+	return MV_OK;
+}
+
+/*
+ * Straight forward function what returns _only_ the index of the
+ * memory window according to provided SoC target.
+ */
+MV_STATUS mvAhbToMbusWinNumByTargetGet(MV_TARGET target, MV_U32 *pWinNum)
+{
+	MV_TARGET_ATTRIB targetAttribs;
+	MV_U32 winNum, ctrlReg, targetId;
+
+	if (pWinNum == NULL) {
+		mvOsPrintf("%s: Error: pWinNum is NULL\n", __func__);
+		return MV_FAIL;
+	}
+
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("%s: Error: target %d is illegal\n", __func__, target);
+		return MV_FAIL;
+	}
+
+	if (target == INTER_REGS) {
+		*pWinNum = MV_AHB_TO_MBUS_INTREG_WIN;
+		return MV_OK;
+	}
+
+	if (mvCtrlAttribGet(target, &targetAttribs) != MV_OK) {
+		mvOsPrintf("%s: Error: mvCtrlAttribGet(target = %d) failed\n",
+			   __func__, target);
+		return MV_FAIL;
+	}
+
+	for (winNum = 0; winNum < MAX_AHB_TO_MBUS_WINS; winNum++) {
+		if (winNum == MV_AHB_TO_MBUS_INTREG_WIN)
+			continue;
+
+		ctrlReg = MV_REG_READ(AHB_TO_MBUS_WIN_CTRL_REG(winNum));
+		targetId = (ctrlReg & ATMWCR_WIN_TARGET_MASK) >> ATMWCR_WIN_TARGET_OFFS;
+
+		if (targetId == targetAttribs.targetId) {
+			*pWinNum = winNum;
+			return MV_OK;
+		}
+
+	}
+
+	return MV_FAIL;
+}
+
+/*******************************************************************************
+* mvAhbToMbusWinTargetGet - Get Window number associated with target
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_U32 mvAhbToMbusWinTargetGet(MV_TARGET target)
+{
+	MV_AHB_TO_MBUS_DEC_WIN decWin;
+	MV_U32 winNum;
+
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("%s: Error: target %d is illegal\n", __func__, target);
+		return 0xffffffff;
+	}
+
+	if (INTER_REGS == target)
+		return MV_AHB_TO_MBUS_INTREG_WIN;
+
+	for (winNum = 0; winNum < MAX_AHB_TO_MBUS_WINS; winNum++) {
+		if (winNum == MV_AHB_TO_MBUS_INTREG_WIN)
+			continue;
+
+		if (mvAhbToMbusWinGet(winNum, &decWin) != MV_OK) {
+			mvOsPrintf("%s: Error: mvAhbToMbusWinGet(winNum = %d) failed\n",
+				   __func__, winNum);
+			return 0xffffffff;
+		}
+
+		if (decWin.enable == MV_TRUE) {
+			if (decWin.target == target)
+				return winNum;
+		}
+	}
+
+	return 0xFFFFFFFF;
+}
+
+/*******************************************************************************
+* mvAhbToMbusWinAvailGet - Get First Available window number.
+*
+* DESCRIPTION:
+*
+* INPUT:
+*
+* OUTPUT:
+*
+* RETURN:
+*
+*******************************************************************************/
+MV_U32 mvAhbToMbusWinAvailGet(MV_VOID)
+{
+	MV_AHB_TO_MBUS_DEC_WIN decWin;
+	MV_U32 winNum;
+
+	for (winNum = 0; winNum < MAX_AHB_TO_MBUS_WINS; winNum++) {
+		if (winNum == MV_AHB_TO_MBUS_INTREG_WIN)
+			continue;
+
+		if (mvAhbToMbusWinGet(winNum, &decWin) != MV_OK) {
+			mvOsPrintf("mvAhbToMbusWinTargetGet: mvAhbToMbusWinGet fail\n");
+			return 0xffffffff;
+		}
+
+		if (decWin.enable == MV_FALSE)
+			return winNum;
+	}
+
+	return 0xFFFFFFFF;
+}
+
+/*******************************************************************************
+* mvAhbToMbusWinEnable - Enable/disable a CPU address decode window
+*
+* DESCRIPTION:
+*       This function enable/disable a CPU address decode window.
+*       if parameter 'enable' == MV_TRUE the routine will enable the
+*       window, thus enabling CPU accesses (before enabling the window it is
+*       tested for overlapping). Otherwise, the window will be disabled.
+*
+* INPUT:
+*       winNum - Peripheral winNum enumerator.
+*       enable - Enable/disable parameter.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_ERROR if protection window number was wrong, or the window
+*       overlapps other winNum window.
+*
+*******************************************************************************/
+MV_STATUS mvAhbToMbusWinEnable(MV_U32 winNum, MV_BOOL enable)
+{
+
+	/* Parameter checking   */
+	if (winNum >= MAX_AHB_TO_MBUS_WINS) {
+		mvOsPrintf("mvAhbToMbusWinEnable: ERR. Invalid winNum %d\n", winNum);
+		return MV_NOT_SUPPORTED;
+	}
+
+	/* Internal registers bar can't be disable or enabled */
+	if (winNum == MV_AHB_TO_MBUS_INTREG_WIN)
+		return (enable ? MV_OK : MV_ERROR);
+
+
+	if (enable == MV_TRUE) {
+		/* enable the window */
+		MV_REG_BIT_SET(AHB_TO_MBUS_WIN_CTRL_REG(winNum), ATMWCR_WIN_ENABLE);
+	} else {
+		/* Disable address decode winNum window                             */
+		MV_REG_BIT_RESET(AHB_TO_MBUS_WIN_CTRL_REG(winNum), ATMWCR_WIN_ENABLE);
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvAhbToMbusWinRemap - Set CPU remap register for address windows.
+*
+* DESCRIPTION:
+*       After a CPU address hits one of PCI address decode windows there is an
+*       option to remap the address to a different one. For example, CPU
+*       executes a read from PCI winNum window address 0x1200.0000. This
+*       can be modified so the address on the PCI bus would be 0x1400.0000
+*       Using the PCI address remap mechanism.
+*
+* INPUT:
+*       winNum      - Peripheral winNum enumerator. Must be a PCI winNum.
+*       pAddrDecWin - CPU winNum window information data structure.
+*                     Note that caller has to fill in the base field only. The
+*                     size field is ignored.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_ERROR if winNum is not a PCI one, MV_OK otherwise.
+*
+*******************************************************************************/
+MV_U32 mvAhbToMbusWinRemap(MV_U32 winNum, MV_ADDR_WIN *pAddrWin)
+{
+	MV_U32 baseAddr;
+	AHB_TO_MBUS_REMAP_REG_OFFS remapRegOffs;
+	MV_U32 effectiveBaseAddress = 0, baseAddrValue = 0, windowSizeValue = 0;
+
+	/* Get registers offsets of given winNum                */
+	if (MV_NO_SUCH == ahbToMbusRemapRegOffsGet(winNum, &remapRegOffs))
+		return 0xffffffff;
+
+	/* 1) Set address remap low */
+	baseAddr = pAddrWin->baseLow;
+
+	/* BaseLow[31:16] => base register [31:16]              */
+	baseAddr = baseAddr & ATMWRLR_REMAP_LOW_MASK;
+
+	MV_REG_WRITE(remapRegOffs.lowRegOffs, baseAddr);
+	MV_REG_WRITE(remapRegOffs.highRegOffs, pAddrWin->baseHigh);
+
+	baseAddrValue = MV_REG_READ(AHB_TO_MBUS_WIN_BASE_REG(winNum));
+	windowSizeValue = MV_REG_READ(AHB_TO_MBUS_WIN_CTRL_REG(winNum));
+
+	baseAddrValue &= ATMWBR_BASE_MASK;
+	windowSizeValue &= ATMWCR_WIN_SIZE_MASK;
+
+	/* Start calculating the effective Base Address */
+	effectiveBaseAddress = baseAddrValue;
+
+	/* The effective base address will be combined from the chopped (if any)
+	   remap value (according to the size value and remap mechanism) and the
+	   window's base address */
+	effectiveBaseAddress |= (((windowSizeValue) | 0xffff) & pAddrWin->baseLow);
+	/* If the effectiveBaseAddress exceed the window boundaries return an
+	   invalid value. */
+
+	if (effectiveBaseAddress > (baseAddrValue + (windowSizeValue | 0xffff))) {
+		mvOsPrintf("mvAhbToMbusPciRemap: Error\n");
+		return 0xffffffff;
+	}
+
+	return effectiveBaseAddress;
+}
+
+/*******************************************************************************
+* mvAhbToMbusWinTargetSwap - Swap AhbToMbus windows between targets
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       target1      - CPU Interface target 1
+*       target2      - CPU Interface target 2
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_ERROR if targets are illigal, or if one of the targets is not
+*	    associated to a valid window .
+*       MV_OK otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvAhbToMbusWinTargetSwap(MV_TARGET target1, MV_TARGET target2)
+{
+	MV_U32 winNum1, winNum2;
+	MV_AHB_TO_MBUS_DEC_WIN winDec1, winDec2, winDecTemp;
+	AHB_TO_MBUS_REMAP_REG_OFFS remapRegs1, remapRegs2;
+	MV_U32 remapBaseLow1 = 0, remapBaseLow2 = 0;
+	MV_U32 remapBaseHigh1 = 0, remapBaseHigh2 = 0;
+
+	/* Check parameters */
+	if (target1 >= MAX_TARGETS) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: target %d is illegal\n", target1);
+		return MV_ERROR;
+	}
+
+	if (target2 >= MAX_TARGETS) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: target %d is illegal\n", target1);
+		return MV_ERROR;
+	}
+
+	/* get window associated with this target */
+	winNum1 = mvAhbToMbusWinTargetGet(target1);
+
+	if (winNum1 == 0xffffffff) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: target %d has illigal win %d\n", target1, winNum1);
+		return MV_ERROR;
+	}
+
+	/* get window associated with this target */
+	winNum2 = mvAhbToMbusWinTargetGet(target2);
+	if (winNum2 == 0xffffffff) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: target %d has illigal win %d\n", target2, winNum2);
+		return MV_ERROR;
+	}
+
+	/* now Get original values of both Windows */
+	if (MV_OK != mvAhbToMbusWinGet(winNum1, &winDec1)) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: mvAhbToMbusWinGet failed win %d\n", winNum1);
+		return MV_ERROR;
+	}
+	if (MV_OK != mvAhbToMbusWinGet(winNum2, &winDec2)) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: mvAhbToMbusWinGet failed win %d\n", winNum2);
+		return MV_ERROR;
+	}
+
+	/* disable both windows */
+	if (MV_OK != mvAhbToMbusWinEnable(winNum1, MV_FALSE)) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: failed to enable window %d\n", winNum1);
+		return MV_ERROR;
+	}
+	if (MV_OK != mvAhbToMbusWinEnable(winNum2, MV_FALSE)) {
+		mvOsPrintf("mvAhbToMbusWinTargetSwap: failed to enable windo %d\n", winNum2);
+		return MV_ERROR;
+	}
+
+	/* now swap targets */
+
+	/* first save winDec2 values */
+	winDecTemp.addrWin.baseHigh = winDec2.addrWin.baseHigh;
+	winDecTemp.addrWin.baseLow = winDec2.addrWin.baseLow;
+	winDecTemp.addrWin.size = winDec2.addrWin.size;
+	winDecTemp.enable = winDec2.enable;
+	winDecTemp.target = winDec2.target;
+
+	/* winDec2 = winDec1 */
+	winDec2.addrWin.baseHigh = winDec1.addrWin.baseHigh;
+	winDec2.addrWin.baseLow = winDec1.addrWin.baseLow;
+	winDec2.addrWin.size = winDec1.addrWin.size;
+	winDec2.enable = winDec1.enable;
+	winDec2.target = winDec1.target;
+
+	/* winDec1 = winDecTemp */
+	winDec1.addrWin.baseHigh = winDecTemp.addrWin.baseHigh;
+	winDec1.addrWin.baseLow = winDecTemp.addrWin.baseLow;
+	winDec1.addrWin.size = winDecTemp.addrWin.size;
+	winDec1.enable = winDecTemp.enable;
+	winDec1.target = winDecTemp.target;
+
+	/* now set the new values */
+	mvAhbToMbusWinSet(winNum1, &winDec1);
+	mvAhbToMbusWinSet(winNum2, &winDec2);
+
+	/* now we will treat the remap windows if exist */
+
+	/* now check if one or both windows has a remap window
+	   as well after the swap ! */
+
+	/* if a window had a remap value differnt than the base value
+	   before the swap , then after the swap the remap value will be
+	   equal to the base value unless both windows has a remap windows */
+
+	/* first get old values */
+	if (MV_NO_SUCH != ahbToMbusRemapRegOffsGet(winNum1, &remapRegs1)) {
+		remapBaseLow1 = MV_REG_READ(remapRegs1.lowRegOffs);
+		remapBaseHigh1 = MV_REG_READ(remapRegs1.highRegOffs);
+	}
+	if (MV_NO_SUCH != ahbToMbusRemapRegOffsGet(winNum2, &remapRegs2)) {
+		remapBaseLow2 = MV_REG_READ(remapRegs2.lowRegOffs);
+		remapBaseHigh2 = MV_REG_READ(remapRegs2.highRegOffs);
+	}
+
+	/* now do the swap */
+	if (MV_NO_SUCH != ahbToMbusRemapRegOffsGet(winNum1, &remapRegs1)) {
+		if (MV_NO_SUCH != ahbToMbusRemapRegOffsGet(winNum2, &remapRegs2)) {
+			/* Two windows has a remap !!! so swap */
+
+			MV_REG_WRITE(remapRegs2.highRegOffs, remapBaseHigh1);
+			MV_REG_WRITE(remapRegs2.lowRegOffs, remapBaseLow1);
+
+			MV_REG_WRITE(remapRegs1.highRegOffs, remapBaseHigh2);
+			MV_REG_WRITE(remapRegs1.lowRegOffs, remapBaseLow2);
+		} else {
+			/* remap == base */
+			MV_REG_WRITE(remapRegs1.highRegOffs, winDec1.addrWin.baseHigh);
+			MV_REG_WRITE(remapRegs1.lowRegOffs, winDec1.addrWin.baseLow);
+		}
+	} else if (MV_NO_SUCH != ahbToMbusRemapRegOffsGet(winNum2, &remapRegs2)) {
+		/* remap == base */
+		MV_REG_WRITE(remapRegs2.highRegOffs, winDec2.addrWin.baseHigh);
+		MV_REG_WRITE(remapRegs2.lowRegOffs, winDec2.addrWin.baseLow);
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* ahbToMbusRemapRegOffsGet - Get CPU address remap register offsets
+*
+* DESCRIPTION:
+* 		CPU to PCI address remap registers offsets are inconsecutive.
+*		This function returns PCI address remap registers offsets.
+*
+* INPUT:
+*       winNum - Address decode window number. See MV_U32 enumerator.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*		MV_ERROR if winNum is not a PCI one.
+*
+*******************************************************************************/
+static MV_STATUS ahbToMbusRemapRegOffsGet(MV_U32 winNum, AHB_TO_MBUS_REMAP_REG_OFFS *pRemapRegs)
+{
+	switch (winNum) {
+	case 0:
+	case 1:
+		pRemapRegs->lowRegOffs = AHB_TO_MBUS_WIN_REMAP_LOW_REG(winNum);
+		pRemapRegs->highRegOffs = AHB_TO_MBUS_WIN_REMAP_HIGH_REG(winNum);
+		break;
+	case 2:
+	case 3:
+		pRemapRegs->lowRegOffs = AHB_TO_MBUS_WIN_REMAP_LOW_REG(winNum);
+		pRemapRegs->highRegOffs = AHB_TO_MBUS_WIN_REMAP_HIGH_REG(winNum);
+		break;
+	case 4:
+	case 5:
+	case 6:
+	case 7:
+		pRemapRegs->lowRegOffs = AHB_TO_MBUS_WIN_REMAP_LOW_REG(winNum);
+		pRemapRegs->highRegOffs = AHB_TO_MBUS_WIN_REMAP_HIGH_REG(winNum);
+		break;
+	default:
+		pRemapRegs->lowRegOffs = 0;
+		pRemapRegs->highRegOffs = 0;
+
+		DB(mvOsPrintf("ahbToMbusRemapRegOffsGet: ERR. Invalid winNum %d\n", winNum));
+		return MV_NO_SUCH;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvAhbToMbusAddDecShow - Print the AHB to MBus bridge address decode map.
+*
+* DESCRIPTION:
+*		This function print the CPU address decode map.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvAhbToMbusAddDecShow(MV_VOID)
+{
+	MV_AHB_TO_MBUS_DEC_WIN win;
+	MV_U32 winNum;
+	mvOsOutput("\n");
+	mvOsOutput("AHB To MBUS Bridge:\n");
+	mvOsOutput("-------------------\n");
+
+	for (winNum = 0; winNum < MAX_AHB_TO_MBUS_WINS; winNum++) {
+		memset(&win, 0, sizeof(MV_AHB_TO_MBUS_DEC_WIN));
+
+		mvOsOutput("win%d - ", winNum);
+
+		if (mvAhbToMbusWinGet(winNum, &win) == MV_OK) {
+			if (win.enable) {
+				mvOsOutput("%s base %08x, ", mvCtrlTargetNameGet(win.target), win.addrWin.baseLow);
+				mvOsOutput("....");
+				mvSizePrint(win.addrWin.size);
+
+				mvOsOutput("\n");
+			} else
+				mvOsOutput("disable\n");
+		}
+	}
+}
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/sys/mvAhbToMbus.h b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/sys/mvAhbToMbus.h
new file mode 100644
index 0000000..b5969a0
--- /dev/null
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/sys/mvAhbToMbus.h
@@ -0,0 +1,93 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvAhbToMbush
+#define __INCmvAhbToMbush
+
+/* includes */
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvAhbToMbusRegs.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+
+/* defines  */
+typedef struct _mvAhbtoMbusDecWin {
+	MV_TARGET	target;
+	MV_ADDR_WIN	addrWin;    /* An address window*/
+	MV_BOOL		enable;     /* Address decode window is enabled/disabled    */
+} MV_AHB_TO_MBUS_DEC_WIN;
+
+/* mvAhbToMbus.h API list */
+
+MV_STATUS mvAhbToMbusInit(MV_VOID);
+MV_STATUS mvAhbToMbusWinSet(MV_U32 winNum, MV_AHB_TO_MBUS_DEC_WIN *pAddrDecWin);
+MV_STATUS mvAhbToMbusWinGet(MV_U32 winNum, MV_AHB_TO_MBUS_DEC_WIN *pAddrDecWin);
+MV_STATUS mvAhbToMbusWinEnable(MV_U32 winNum, MV_BOOL enable);
+MV_U32    mvAhbToMbusWinRemap(MV_U32 winNum, MV_ADDR_WIN *pAddrDecWin);
+MV_STATUS mvAhbToMbusWinNumByTargetGet(MV_TARGET target, MV_U32 *pWinNum);
+MV_U32	  mvAhbToMbusWinTargetGet(MV_TARGET target);
+MV_U32    mvAhbToMbusWinAvailGet(MV_VOID);
+MV_STATUS mvAhbToMbusWinTargetSwap(MV_TARGET target1, MV_TARGET target2);
+MV_VOID   mvAhbToMbusAddDecShow(MV_VOID);
+
+#endif /* __INCmvAhbToMbush */
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/sys/mvAhbToMbusRegs.h b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/sys/mvAhbToMbusRegs.h
new file mode 100644
index 0000000..d459aee
--- /dev/null
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/sys/mvAhbToMbusRegs.h
@@ -0,0 +1,142 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+
+#ifndef __INCmvAhbToMbusRegsh
+#define __INCmvAhbToMbusRegsh
+
+#define MAX_AHB_TO_MBUS_WINS			21
+#define MAX_AHB_TO_MBUS_REMAP_WINS		8
+#define MV_AHB_TO_MBUS_INTREG_WIN		20
+
+/***********************/
+/* AHB TO MBUS WINDOWS */
+/***********************/
+/* Window-X Control Registers */
+#define AHB_TO_MBUS_WIN_CTRL_REG(winNum)	((winNum < MAX_AHB_TO_MBUS_REMAP_WINS) ? \
+						 (MV_MBUS_REGS_OFFSET + winNum * 0x10) : \
+						 (MV_MBUS_REGS_OFFSET + 0x90 + (winNum-8)*0x08))
+#define ATMWCR_WIN_ENABLE			BIT0
+#define ATMWCR_WIN_TARGET_OFFS			4
+#define ATMWCR_WIN_TARGET_MASK			(0xf << ATMWCR_WIN_TARGET_OFFS)
+#define ATMWCR_WIN_ATTR_OFFS			8
+#define ATMWCR_WIN_ATTR_MASK			(0xff << ATMWCR_WIN_ATTR_OFFS)
+#define ATMWCR_WIN_SIZE_OFFS			16
+#define ATMWCR_WIN_SIZE_MASK			(0xffff << ATMWCR_WIN_SIZE_OFFS)
+#define ATMWCR_WIN_SIZE_ALIGNMENT		0x10000
+
+/* Window-X Base Register */
+#define AHB_TO_MBUS_WIN_BASE_REG(winNum)	((winNum < MAX_AHB_TO_MBUS_REMAP_WINS) ? \
+						 (MV_MBUS_REGS_OFFSET + 0x4 + winNum*0x10) : \
+						 (MV_MBUS_REGS_OFFSET + 0x94 + (winNum-8)*0x08))
+#define ATMWBR_BASE_OFFS			16
+#define ATMWBR_BASE_MASK			(0xffff << 	ATMWBR_BASE_OFFS)
+#define ATMWBR_BASE_ALIGNMENT			0x10000
+
+/* Window-X Remap Low Register */
+#define AHB_TO_MBUS_WIN_REMAP_LOW_REG(winNum)	((winNum < MAX_AHB_TO_MBUS_REMAP_WINS) ? \
+						 (MV_MBUS_REGS_OFFSET + 0x8 + winNum*0x10) : \
+						 (0))
+#define ATMWRLR_REMAP_LOW_OFFS			16
+#define ATMWRLR_REMAP_LOW_MASK			(0xffff << ATMWRLR_REMAP_LOW_OFFS)
+#define ATMWRLR_REMAP_LOW_ALIGNMENT		0x10000
+
+/* Window-X Remap Hi Register */
+#define AHB_TO_MBUS_WIN_REMAP_HIGH_REG(winNum)	((winNum < MAX_AHB_TO_MBUS_REMAP_WINS) ? \
+						 (MV_MBUS_REGS_OFFSET + 0xC + winNum*0x10) : \
+						 (0))
+#define ATMWRHR_REMAP_HIGH_OFFS			0
+#define ATMWRHR_REMAP_HIGH_MASK			(0xffffffff << ATMWRHR_REMAP_HIGH_OFFS)
+
+/*****************************/
+/* INTERNAL REGISTERS WINDOW */
+/*****************************/
+/* Internal Registers Base Address in set to be window 20 */
+#define AHB_TO_MBUS_WIN_INTEREG_REG		(MV_MBUS_REGS_OFFSET + 0x80)
+
+/************************/
+/* SDRAM DECODE WINDOWS */
+/************************/
+/* All DRAM Window definitions are declared under the ddr2_3 HAL */
+
+/****************************/
+/* SRAM (L2) DECODE WINDOWS */
+/****************************/
+#define SRAM_WIN_CTRL_REG(winNum)		(MV_MBUS_REGS_OFFSET + 0x240 + winNum * 0x4)
+#define SRAMWCR_ENABLE				BIT0
+#define SRAMWCR_SIZE_OFFS			8
+#define SRAMWCR_SIZE_MASK			(0x7 << SRAMWCR_SIZE_OFFS)
+#define SRAMWCR_BASE_OFFS			16
+#define SRAMWCR_BASE_MASK			(0xFFFF << SRAMWCR_BASE_OFFS)
+
+/**********************/
+/* MBUS BRIDGE WINDOW */
+/**********************/
+#define MBUS_BRIDGE_WIN_CTRL_REG		(MV_MBUS_REGS_OFFSET + 0x250)
+#define BRIDGWCR_ENABLE				BIT0
+#define BRIDGWCR_SIZE_OFFS			16
+#define BRIDGWCR_SIZE_MASK			(0xFFFF << BRIDGWCR_SIZE_OFFS)
+#define MBUS_BRIDGE_WIN_BASE_REG		(MV_MBUS_REGS_OFFSET + 0x254)
+
+#endif /* __INCmvAhbToMbusRegsh */
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/sys/mvCpuIf.c b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/sys/mvCpuIf.c
new file mode 100644
index 0000000..3898bc4
--- /dev/null
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/sys/mvCpuIf.c
@@ -0,0 +1,955 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/* includes */
+/*#include "cpu/mvCpu.h" *//* whoAmI() */
+#include "ctrlEnv/sys/mvCpuIf.h"
+#include "ctrlEnv/sys/mvAhbToMbusRegs.h"
+#include "cpu/mvCpu.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "mvSysHwConfig.h"
+#include "ddr2_3/mvDramIf.h"
+#include "ddr2_3/mvDramIfRegs.h"
+#include "pex/mvPexRegs.h"
+
+/*#define MV_DEBUG*/
+/* defines  */
+
+#ifdef MV_DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+/* locals   */
+/* static functions */
+static MV_BOOL cpuTargetWinOverlap(MV_TARGET target, MV_ADDR_WIN *pAddrWin);
+
+MV_STATUS mvCpuIfVerify(MV_CPU_DEC_WIN *cpuAddrWinMap)
+{
+	MV_CPU_DEC_WIN win;
+	MV_U32 target;
+	MV_32 diff;
+
+	for (target = 0; target < MAX_TARGETS; target++) {
+		memset(&win, 0, sizeof(MV_CPU_DEC_WIN));
+
+		if(win.enable == cpuAddrWinMap->enable)
+		{
+			if(win.enable)
+			{
+				diff  = (win.addrWin.baseLow  - cpuAddrWinMap->addrWin.baseLow);
+				diff |= (win.addrWin.baseHigh - cpuAddrWinMap->addrWin.baseHigh);
+				diff |= (win.addrWin.size     - cpuAddrWinMap->addrWin.size);
+				/*TODO - Need to compare the window attributes as well */
+
+				if(diff)
+				{
+					mvOsOutput("mvCpuIfVerify: Mismatched window size in target %d\n", target);
+					return MV_ERROR;
+				}
+			}
+		}
+		else
+		{
+			mvOsOutput("mvCpuIfVerify: Mismatched enable field in target %d\n", target);
+			return MV_ERROR;
+		}
+	}
+	return MV_OK;
+}
+/*******************************************************************************
+* mvCpuIfInitForCpu - Initialize Controller CPU interface
+*
+* DESCRIPTION:
+*       This function initialize Controller CPU interface:
+*       1. Set CPU interface configuration registers.
+*       2. Set CPU master Pizza arbiter control according to static
+*          configuration described in configuration file.
+*       3. Opens CPU address decode windows. DRAM windows are assumed to be
+*		   already set (auto detection).
+*
+* INPUT:
+*       cpu      	- CPU id.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS mvCpuIfInitForCpu(MV_U32 cpu, MV_CPU_DEC_WIN *cpuAddrWinMap)
+{
+	MV_U32 regVal, i;
+	MV_TARGET target;
+	MV_ADDR_WIN addrWin;
+	MV_U32 minBase = 0xFFFFFFFF;
+	MV_U32 minSize;
+
+	if (cpuAddrWinMap == NULL) {
+		DB(mvOsPrintf("%s: CPU map NULL pointer\n", __func__));
+		return MV_ERROR;
+	}
+
+	/* Set IO Bypass base address and size according to the cpuAddrWinMap */
+	for (target = 0; cpuAddrWinMap[target].enable != TBL_TERM; target++) {
+		if ((MV_TARGET_IS_DRAM(target)) || (DIS == cpuAddrWinMap[target].enable))
+			continue;
+		if (cpuAddrWinMap[target].addrWin.baseLow == 0)
+			continue;
+		if (cpuAddrWinMap[target].addrWin.baseLow < minBase)
+			minBase = cpuAddrWinMap[target].addrWin.baseLow;
+	}
+	if (minBase != 0x0) {
+		minSize = 0xFFFFFFFF - minBase + 1;
+		if (!MV_IS_POWER_OF_2(minSize)) {
+			/* Round up to next power of 2. */
+			minSize = (1 << (mvLog2(minSize) + 1));
+			minBase = 0xFFFFFFFF - minSize + 1;
+		}
+
+		/* Now write the base and size */
+		MV_REG_WRITE(MBUS_BRIDGE_WIN_BASE_REG, minBase);
+		/* Align window size to 64KB */
+		regVal = (minSize / SDRAMWBR_BASE_ALIGNMENT) - 1;
+		regVal = (regVal << 16) | 0x1;
+		MV_REG_WRITE(MBUS_BRIDGE_WIN_CTRL_REG, regVal);
+	}
+
+	/* Set CPU Configuration register */
+	regVal = MV_REG_READ(CPU_CONFIG_REG(cpu));
+	regVal &= ~CPU_CONFIG_DEFAULT_MASK;
+	regVal |= CPU_CONFIG_DEFAULT;
+	MV_REG_WRITE(CPU_CONFIG_REG(cpu), regVal);
+
+	for (i = 0; i < MAX_AHB_TO_MBUS_WINS-2; i++)
+		mvAhbToMbusWinEnable(i, MV_FALSE);
+
+	/* Disable all SRAM windows */
+	mvCpuIfSramWinDisable();
+
+	/* First disable all CPU target windows  */
+	for (target = 0; cpuAddrWinMap[target].enable != TBL_TERM; target++) {
+		if ((MV_TARGET_IS_DRAM(target)) || (target == INTER_REGS))
+			continue;
+#ifdef CONFIG_MV_AMP_ENABLE
+		if(target == BOOT_ROM_CS)
+			continue;
+#endif
+
+#if defined(MV_MEM_OVER_PEX_WA) || defined(MV_UART_OVER_PEX_WA)
+		/* If the target PEX or PCI and memory is over PEX or PCI we don't touch this CPU windows */
+		if (MV_TARGET_IS_PEX(target))
+			continue;
+#endif
+#if defined(MV_RUN_FROM_FLASH)
+		/* Don't disable the boot device.                               */
+		if (target == DEV_BOOCS)
+			continue;
+#endif /* MV_RUN_FROM_FLASH */
+		mvCpuIfTargetWinEnable(MV_CHANGE_BOOT_CS(target), MV_FALSE);
+	}
+
+#if defined(MV_RUN_FROM_FLASH)
+	/* Resize the bootcs windows before other windows, because this     */
+	/* window is enabled and will cause an overlap if not resized.      */
+	target = DEV_BOOCS;
+
+	if (MV_OK != mvCpuIfTargetWinSet(target, &cpuAddrWinMap[target])) {
+		DB(mvOsPrintf("%s: ERR: mvCpuIfTargetWinSet failed\n", __func__));
+		return MV_ERROR;
+	}
+
+	addrWin.baseLow = cpuAddrWinMap[target].addrWin.baseLow;
+	addrWin.baseHigh = cpuAddrWinMap[target].addrWin.baseHigh;
+	if (0xffffffff == mvAhbToMbusWinRemap(cpuAddrWinMap[target].winNum, &addrWin)) {
+		DB(mvOsPrintf("%s: WARN: mvAhbToMbusWinRemap can't remap winNum=%d\n",
+			      __func__, cpuAddrWinMap[target].winNum));
+	}
+#endif /* MV_RUN_FROM_FLASH */
+
+	/* Go through all targets in user table until table terminator                  */
+	for (target = 0; cpuAddrWinMap[target].enable != TBL_TERM; target++) {
+
+#if defined(MV_RUN_FROM_FLASH)
+		if (target == DEV_BOOCS)
+			continue;
+#endif /* MV_RUN_FROM_FLASH */
+
+		/* if DRAM auto sizing is used do not initialized DRAM target windows,  */
+		/* assuming this already has been done earlier.                         */
+#ifdef	MV_DRAM_AUTO_SIZE
+		if (MV_TARGET_IS_DRAM(target))
+			continue;
+#endif
+
+#if defined(MV_MEM_OVER_PEX_WA) || defined(MV_UART_OVER_PEX_WA)
+		/* If the target PEX or PCI and memory is over PEX or PCI we don't touch this CPU windows */
+		if (MV_TARGET_IS_PEX(target))
+			continue;
+#endif
+		if ((0 == cpuAddrWinMap[target].addrWin.size) || (DIS == cpuAddrWinMap[target].enable))
+			continue;
+		else {
+			if (MV_OK != mvCpuIfTargetWinSet(target, &cpuAddrWinMap[target])) {
+				DB(mvOsPrintf("%s: ERR: mvCpuIfTargetWinSet failed\n", __func__));
+				return MV_ERROR;
+			}
+			addrWin.baseLow = cpuAddrWinMap[target].addrWin.baseLow;
+			addrWin.baseHigh = cpuAddrWinMap[target].addrWin.baseHigh;
+			if (0xffffffff == mvAhbToMbusWinRemap(cpuAddrWinMap[target].winNum, &addrWin)) {
+				DB(mvOsPrintf("%s: WARN: mvAhbToMbusWinRemap can't remap winNum=%d\n",
+					      __func__, cpuAddrWinMap[target].winNum));
+			}
+		}
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************/
+MV_STATUS mvCpuIfInit(MV_CPU_DEC_WIN *cpuAddrWinMap)
+{
+	return mvCpuIfInitForCpu(whoAmI(), cpuAddrWinMap);
+}
+
+/*******************************************************************************
+* mvCpuIfDramInit - Initialize Controller DRAM Fastpath windows
+*
+* DESCRIPTION:
+*       This function initialize Controller DRAM Fastpath windows
+*		It takes the CS size information from the 0x1500 scratch registers
+*		and sets the correct windows sizes and base addresses accordingly
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS mvCpuIfDramInit()
+{
+	MV_U64 base = 0;
+	MV_U32 size, cs, temp;
+
+	for (cs = 0; cs < SDRAM_MAX_CS; cs++) {
+		size = MV_REG_READ(SDRAM_SIZE_REG(cs)) & SDRAM_ADDR_MASK;
+		if (size != 0) {
+			size |= ~(SDRAM_ADDR_MASK);
+
+			/* Set Base Address */
+			temp = (base & 0xFF000000ll) | ((base >> 32) & 0xF);
+			MV_REG_WRITE(SDRAM_WIN_BASE_REG(cs), temp);
+
+			/* Check if out of max window size and resize the window */
+#if 0
+			if (base+size > SDRAM_MAX_ADDR) {
+				size = SDRAM_MAX_ADDR - base - 1;
+				MV_REG_WRITE(SDRAM_SIZE_REG(cs), 0);
+			}
+#endif
+			temp = (MV_REG_READ(SDRAM_WIN_CTRL_REG(cs)) & ~(SDRAM_ADDR_MASK)) | (1<<SDRAM_WIN_CTRL_WIN_ENA_OFFS);
+			temp |= (size & SDRAM_ADDR_MASK);
+
+			MV_REG_WRITE(SDRAM_WIN_CTRL_REG(cs), temp);
+			base += ((MV_U64)size + 1);
+		}
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCpuIfTargetWinSet - Set CPU-to-peripheral target address window
+*
+* DESCRIPTION:
+*       This function sets a peripheral target (e.g. SDRAM bank0, PCI0_MEM0)
+*       address window, also known as address decode window.
+*       A new address decode window is set for specified target address window.
+*       If address decode window parameter structure enables the window,
+*       the routine will also enable the target window, allowing CPU to access
+*       the target window.
+*
+* INPUT:
+*       target      - Peripheral target enumerator.
+*       pAddrDecWin - CPU target window data structure.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_OK if CPU target window was set correctly, MV_ERROR in case of
+*       address window overlapps with other active CPU target window or
+*		trying to assign 36bit base address while CPU does not support that.
+*       The function returns MV_NOT_SUPPORTED, if the target is unsupported.
+*
+*******************************************************************************/
+MV_STATUS mvCpuIfTargetWinSet(MV_TARGET target, MV_CPU_DEC_WIN *pAddrDecWin)
+{
+	MV_AHB_TO_MBUS_DEC_WIN decWin;
+	MV_U32 existingWinNum;
+	MV_DRAM_DEC_WIN addrDecWin;
+
+	target = MV_CHANGE_BOOT_CS(target);
+
+	/* Check parameters */
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("mvCpuIfTargetWinSet: target %d is illegal\n", target);
+		return MV_ERROR;
+	}
+
+	/* 2) Check if the requested window overlaps with current windows */
+	if (MV_TRUE == cpuTargetWinOverlap(target, &pAddrDecWin->addrWin)) {
+		mvOsPrintf("mvCpuIfTargetWinSet: ERR. Target %d overlap\n", target);
+		return MV_BAD_PARAM;
+	}
+
+	if (MV_TARGET_IS_DRAM(target)) {
+		/* copy relevant data to MV_DRAM_DEC_WIN structure */
+		addrDecWin.addrWin.baseHigh = pAddrDecWin->addrWin.baseHigh;
+		addrDecWin.addrWin.baseLow = pAddrDecWin->addrWin.baseLow;
+		addrDecWin.addrWin.size = pAddrDecWin->addrWin.size;
+		addrDecWin.enable = pAddrDecWin->enable;
+
+		if (mvDramIfWinSet(target, &addrDecWin) != MV_OK) {
+			mvOsPrintf("mvCpuIfTargetWinSet: mvDramIfWinSet Failed\n");
+			return MV_ERROR;
+		}
+	} else {
+		/* copy relevant data to MV_AHB_TO_MBUS_DEC_WIN structure */
+		decWin.addrWin.baseLow = pAddrDecWin->addrWin.baseLow;
+		decWin.addrWin.baseHigh = pAddrDecWin->addrWin.baseHigh;
+		decWin.addrWin.size = pAddrDecWin->addrWin.size;
+		decWin.enable = pAddrDecWin->enable;
+		decWin.target = target;
+
+		existingWinNum = mvAhbToMbusWinTargetGet(target);
+
+		/* check if there is already another Window configured
+		   for this target */
+		if ((existingWinNum < MAX_AHB_TO_MBUS_WINS) && (existingWinNum != pAddrDecWin->winNum)) {
+			/* if we want to enable the new window number
+			   passed by the user , then the old one should
+			   be disabled */
+			if (MV_TRUE == pAddrDecWin->enable) {
+				/* be sure it is disabled */
+				mvAhbToMbusWinEnable(existingWinNum, MV_FALSE);
+			}
+		}
+
+		if (mvAhbToMbusWinSet(pAddrDecWin->winNum, &decWin) != MV_OK) {
+			mvOsPrintf("mvCpuIfTargetWinSet: mvAhbToMbusWinSet Failed\n");
+			return MV_ERROR;
+		}
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCpuIfTargetWinGet - Get CPU-to-peripheral target address window
+*
+* DESCRIPTION:
+*		Get the CPU peripheral target address window.
+*
+* INPUT:
+*       target - Peripheral target enumerator
+*
+* OUTPUT:
+*       pAddrDecWin - CPU target window information data structure.
+*
+* RETURN:
+*       MV_OK if target exist, MV_ERROR otherwise.
+*
+*******************************************************************************/
+MV_STATUS mvCpuIfTargetWinGet(MV_TARGET target, MV_CPU_DEC_WIN *pAddrDecWin)
+{
+	MV_U32 winNum = 0xffffffff;
+	MV_AHB_TO_MBUS_DEC_WIN decWin;
+	MV_DRAM_DEC_WIN addrDecWin;
+
+	target = MV_CHANGE_BOOT_CS(target);
+
+	/* Check parameters */
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("mvCpuIfTargetWinGet: target %d is illegal\n", target);
+		return MV_ERROR;
+	}
+
+	if (MV_TARGET_IS_DRAM(target)) {
+		if (mvDramIfWinGet(target, &addrDecWin) != MV_OK) {
+			mvOsPrintf("mvCpuIfTargetWinGet: Failed to get window target %d\n", target);
+			return MV_ERROR;
+		}
+
+		/* copy relevant data to MV_CPU_DEC_WIN structure */
+		pAddrDecWin->addrWin.baseLow = addrDecWin.addrWin.baseLow;
+		pAddrDecWin->addrWin.baseHigh = addrDecWin.addrWin.baseHigh;
+		pAddrDecWin->addrWin.size = (MV_U64)addrDecWin.addrWin.size;
+		pAddrDecWin->enable = addrDecWin.enable;
+		pAddrDecWin->winNum = target;
+	} else {
+		/* get the Window number associated with this target */
+		winNum = mvAhbToMbusWinTargetGet(target);
+		if (winNum >= MAX_AHB_TO_MBUS_WINS)
+			return MV_NO_SUCH;
+
+		if (mvAhbToMbusWinGet(winNum, &decWin) != MV_OK) {
+			mvOsPrintf("%s: mvAhbToMbusWinGet Failed at winNum = %d\n", __func__, winNum);
+			return MV_ERROR;
+		}
+
+		/* copy relevant data to MV_CPU_DEC_WIN structure */
+		pAddrDecWin->addrWin.baseLow = decWin.addrWin.baseLow;
+		pAddrDecWin->addrWin.baseHigh = decWin.addrWin.baseHigh;
+		pAddrDecWin->addrWin.size = decWin.addrWin.size;
+		pAddrDecWin->enable = decWin.enable;
+		pAddrDecWin->winNum = winNum;
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCpuIfTargetWinEnable - Enable/disable a CPU address decode window
+*
+* DESCRIPTION:
+*       This function enable/disable a CPU address decode window.
+*       if parameter 'enable' == MV_TRUE the routine will enable the
+*       window, thus enabling CPU accesses (before enabling the window it is
+*       tested for overlapping). Otherwise, the window will be disabled.
+*
+* INPUT:
+*       target - Peripheral target enumerator.
+*       enable - Enable/disable parameter.
+*
+* OUTPUT:
+*       N/A
+*
+* RETURN:
+*       MV_ERROR if protection window number was wrong, or the window
+*       overlapps other target window.
+*
+*******************************************************************************/
+MV_STATUS mvCpuIfTargetWinEnable(MV_TARGET target, MV_BOOL enable)
+{
+	MV_U32 winNum, temp;
+	MV_CPU_DEC_WIN addrDecWin;
+
+	target = MV_CHANGE_BOOT_CS(target);
+
+	/* Check parameters */
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("mvCpuIfTargetWinEnable: target %d is illegal\n", target);
+		return MV_ERROR;
+	}
+
+	/* get the window and check if it exist */
+	temp = mvCpuIfTargetWinGet(target, &addrDecWin);
+	if (MV_NO_SUCH == temp) {
+		return (enable ? MV_ERROR : MV_OK);
+	} else if (MV_OK != temp) {
+		mvOsPrintf("%s: ERR. Getting target %d failed.\n", __func__, target);
+		return MV_ERROR;
+	}
+
+	/* check overlap */
+	if (MV_TRUE == enable) {
+		if (MV_TRUE == cpuTargetWinOverlap(target, &addrDecWin.addrWin)) {
+			DB(mvOsPrintf("%s: ERR. Target %d overlap\n", __func__, target));
+			return MV_ERROR;
+		}
+	}
+
+	if (MV_TARGET_IS_DRAM(target)) {
+		if (mvDramIfWinEnable(target, enable) != MV_OK) {
+			mvOsPrintf("mvCpuIfTargetWinGet: mvDramIfWinEnable Failed at \n");
+			return MV_ERROR;
+		}
+	} else {
+		/* get the Window number associated with this target */
+		winNum = mvAhbToMbusWinTargetGet(target);
+
+		if (winNum >= MAX_AHB_TO_MBUS_WINS)
+			return (enable ? MV_ERROR : MV_OK);
+
+		if (mvAhbToMbusWinEnable(winNum, enable) != MV_OK) {
+			mvOsPrintf("mvCpuIfTargetWinGet: Failed to enable window = %d\n", winNum);
+			return MV_ERROR;
+		}
+	}
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvCpuIfTargetWinSizeGet - Get CPU target address window size
+*
+* DESCRIPTION:
+*		Get the size of CPU-to-peripheral target window.
+*
+* INPUT:
+*       target - Peripheral target enumerator
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit size. Function also returns '0' if window is closed.
+*		Function returns 0xFFFFFFFF in case of an error.
+*
+*******************************************************************************/
+MV_U32 mvCpuIfTargetWinSizeGet(MV_TARGET target)
+{
+	MV_CPU_DEC_WIN addrDecWin;
+
+	target = MV_CHANGE_BOOT_CS(target);
+
+	/* Check parameters */
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("mvCpuIfTargetWinSizeGet: target %d is illegal\n", target);
+		return 0;
+	}
+
+	/* Get the winNum window */
+	if (MV_OK != mvCpuIfTargetWinGet(target, &addrDecWin)) {
+		mvOsPrintf("mvCpuIfTargetWinSizeGet:ERR. Getting target %d failed.\n", target);
+		return 0;
+	}
+
+	/* Check if window is enabled   */
+	if (addrDecWin.enable == MV_TRUE)
+		return (addrDecWin.addrWin.size);
+	else
+		return 0;	/* Window disabled. return 0 */
+}
+
+/*******************************************************************************
+* mvCpuIfTargetWinBaseLowGet - Get CPU target address window base low
+*
+* DESCRIPTION:
+*       CPU-to-peripheral target address window base is constructed of
+*       two parts: Low and high.
+*		This function gets the CPU peripheral target low base address.
+*
+* INPUT:
+*       target - Peripheral target enumerator
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit low base address.
+*
+*******************************************************************************/
+MV_U32 mvCpuIfTargetWinBaseLowGet(MV_TARGET target)
+{
+	MV_CPU_DEC_WIN addrDecWin;
+
+	target = MV_CHANGE_BOOT_CS(target);
+
+	/* Check parameters */
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("mvCpuIfTargetWinBaseLowGet: target %d is illegal\n", target);
+		return 0xffffffff;
+	}
+
+	/* Get the target window */
+	if (MV_OK != mvCpuIfTargetWinGet(target, &addrDecWin)) {
+		mvOsPrintf("mvCpuIfTargetWinBaseLowGet:ERR. Getting target %d failed.\n", target);
+		return 0xffffffff;
+	}
+
+	if (MV_FALSE == addrDecWin.enable)
+		return 0xffffffff;
+
+	return (addrDecWin.addrWin.baseLow);
+}
+
+/*******************************************************************************
+* mvCpuIfTargetWinBaseHighGet - Get CPU target address window base high
+*
+* DESCRIPTION:
+*       CPU-to-peripheral target address window base is constructed of
+*       two parts: Low and high.
+*		This function gets the CPU peripheral target high base address.
+*
+* INPUT:
+*       target - Peripheral target enumerator
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       32bit high base address.
+*
+*******************************************************************************/
+MV_U32 mvCpuIfTargetWinBaseHighGet(MV_TARGET target)
+{
+	MV_CPU_DEC_WIN addrDecWin;
+
+	target = MV_CHANGE_BOOT_CS(target);
+
+	/* Check parameters */
+	if (target >= MAX_TARGETS) {
+		mvOsPrintf("mvCpuIfTargetWinBaseLowGet: target %d is illegal\n", target);
+		return 0xffffffff;
+	}
+
+	/* Get the target window */
+	if (MV_OK != mvCpuIfTargetWinGet(target, &addrDecWin)) {
+		mvOsPrintf("mvCpuIfTargetWinBaseHighGet:ERR. Getting target %d failed.\n", target);
+		return 0xffffffff;
+	}
+
+	if (MV_FALSE == addrDecWin.enable)
+		return 0;
+
+	return (addrDecWin.addrWin.baseHigh);
+}
+
+
+/*******************************************************************************
+* mvCpuIfSramWinDisable
+*
+* DESCRIPTION:
+*	Disable the SRAM windows.
+*
+* INPUT:
+*		None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_OK on success.
+*
+*******************************************************************************/
+MV_STATUS mvCpuIfSramWinDisable(MV_VOID)
+{
+	MV_U32 i;
+
+	for (i = 0; i < 4; i++)
+		MV_REG_WRITE(SRAM_WIN_CTRL_REG(i), SRAM_WIN_CTRL_DEFAULT_VAL);
+
+	return MV_OK;
+}
+
+
+#if defined(MV_INCLUDE_PEX)
+/*******************************************************************************
+* mvCpuIfPexRemap - Set CPU remap register for address windows.
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       pexTarget   - Peripheral target enumerator. Must be a PEX target.
+*       pAddrDecWin - CPU target window information data structure.
+*                     Note that caller has to fill in the base field only. The
+*                     size field is ignored.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_ERROR if target is not a PEX one, MV_OK otherwise.
+*
+*******************************************************************************/
+MV_U32 mvCpuIfPexRemap(MV_TARGET pexTarget, MV_ADDR_WIN *pAddrDecWin)
+{
+	MV_U32 winNum;
+
+	/* Check parameters */
+	if (mvCtrlPexMaxIfGet() > 1) {
+		if ((!MV_TARGET_IS_PEX0(pexTarget)) &&
+			(!MV_TARGET_IS_PEX1(pexTarget))) {
+			mvOsPrintf("mvCpuIfPexRemap: target %d is illegal\n", pexTarget);
+			return 0xffffffff;
+		}
+	} else {
+		if (!MV_TARGET_IS_PEX0(pexTarget)) {
+			mvOsPrintf("mvCpuIfPexRemap: target %d is illegal\n", pexTarget);
+			return 0xffffffff;
+		}
+	}
+
+	/* get the Window number associated with this target */
+	winNum = mvAhbToMbusWinTargetGet(pexTarget);
+
+	if (winNum >= MAX_AHB_TO_MBUS_WINS) {
+		mvOsPrintf("mvCpuIfPexRemap: mvAhbToMbusWinTargetGet Failed\n");
+		return 0xffffffff;
+	}
+
+	return mvAhbToMbusWinRemap(winNum, pAddrDecWin);
+}
+#endif
+
+#if defined(MV_INCLUDE_PCI)
+/*******************************************************************************
+* mvCpuIfPciRemap - Set CPU remap register for address windows.
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       pciTarget   - Peripheral target enumerator. Must be a PCI target.
+*       pAddrDecWin - CPU target window information data structure.
+*                     Note that caller has to fill in the base field only. The
+*                     size field is ignored.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_ERROR if target is not a PCI one, MV_OK otherwise.
+*
+*******************************************************************************/
+MV_U32 mvCpuIfPciRemap(MV_TARGET pciIfTarget, MV_ADDR_WIN *pAddrDecWin)
+{
+	MV_U32 winNum;
+
+	/* get the Window number associated with this target */
+	winNum = mvAhbToMbusWinTargetGet(pciIfTarget);
+
+	if (winNum >= MAX_AHB_TO_MBUS_WINS) {
+		mvOsPrintf("mvCpuIfPexRemap: mvAhbToMbusWinTargetGet Failed\n");
+		return 0xffffffff;
+	}
+
+	return mvAhbToMbusWinRemap(winNum, pAddrDecWin);
+}
+#endif
+
+/*******************************************************************************
+* mvCpuIfTargetOfBaseAddressGet - Get the target according to base address
+*
+* DESCRIPTION:
+*
+* INPUT:
+*       baseAddress -  base address to be checked
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       the target number that baseAddress belongs to or MAX_TARGETS is not
+*       found
+*
+*******************************************************************************/
+MV_TARGET mvCpuIfTargetOfBaseAddressGet(MV_U32 baseAddress)
+{
+	MV_CPU_DEC_WIN win;
+	MV_U32 target;
+
+	for (target = 0; target < MAX_TARGETS; target++) {
+		if (mvCpuIfTargetWinGet(target, &win) == MV_OK) {
+			if (win.enable) {
+				if ((baseAddress >= win.addrWin.baseLow) &&
+				    (baseAddress < win.addrWin.baseLow + win.addrWin.size))
+					break;
+			}
+		} else
+			return MAX_TARGETS;
+	}
+
+	return target;
+}
+
+/*******************************************************************************
+* cpuTargetWinOverlap - Detect CPU address decode windows overlapping
+*
+* DESCRIPTION:
+*       An unpredicted behaviur is expected in case CPU address decode
+*       windows overlapps.
+*       This function detects CPU address decode windows overlapping of a
+*       specified target. The function does not check the target itself for
+*       overlapping. The function also skipps disabled address decode windows.
+*
+* INPUT:
+*       target      - Peripheral target enumerator.
+*       pAddrDecWin - An address decode window struct.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_TRUE if the given address window overlaps current address
+*       decode map, MV_FALSE otherwise.
+*
+*******************************************************************************/
+static MV_BOOL cpuTargetWinOverlap(MV_TARGET target, MV_ADDR_WIN *pAddrWin)
+{
+	MV_U32 targetNum;
+	MV_CPU_DEC_WIN addrDecWin;
+	MV_STATUS status;
+
+	for (targetNum = 0; targetNum < MAX_TARGETS; targetNum++) {
+		/* don't check our target or illegal targets */
+		if (targetNum == target)
+			continue;
+
+		/* Get window parameters        */
+		status = mvCpuIfTargetWinGet(targetNum, &addrDecWin);
+		if (MV_NO_SUCH == status)
+			continue;
+
+		if (MV_OK != status) {
+			DB(mvOsPrintf("cpuTargetWinOverlap: ERR. TargetWinGet failed\n"));
+			return MV_TRUE;
+		}
+
+		/* Do not check disabled windows        */
+		if (MV_FALSE == addrDecWin.enable)
+			continue;
+
+		if (MV_TRUE == mvWinOverlapTest(pAddrWin, &addrDecWin.addrWin)) {
+			DB(mvOsPrintf("cpuTargetWinOverlap: Required target %d overlap current %d\n",
+				      target, targetNum));
+			return MV_TRUE;
+		}
+	}
+
+	return MV_FALSE;
+}
+
+/*******************************************************************************
+* mvCpuIfAddDecShow - Print the CPU address decode map.
+*
+* DESCRIPTION:
+*		This function print the CPU address decode map.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvCpuIfAddDecShow(MV_VOID)
+{
+	MV_CPU_DEC_WIN win;
+	MV_U32 target;
+
+	mvOsOutput("\n");
+	mvOsOutput("CPU Interface\n");
+	mvOsOutput("-------------\n");
+
+	for (target = 0; target < MAX_TARGETS; target++) {
+		memset(&win, 0, sizeof(MV_CPU_DEC_WIN));
+
+		mvOsOutput("%s ", mvCtrlTargetNameGet(target));
+		mvOsOutput("....");
+
+		if (mvCpuIfTargetWinGet(target, &win) == MV_OK) {
+			if (win.enable) {
+				mvOsOutput("base %01x%08x, ", win.addrWin.baseHigh, win.addrWin.baseLow);
+				mvSizePrint(win.addrWin.size);
+				mvOsOutput("\n");
+			} else
+				mvOsOutput("disable\n");
+		} else if (mvCpuIfTargetWinGet(target, &win) == MV_NO_SUCH) {
+			mvOsOutput("no such\n");
+		}
+	}
+}
+
+/*******************************************************************************
+* mvCpuIfLvdsPadsEnable
+*
+* DESCRIPTION:
+*	Enable / Disable the LVDS pads.
+*
+* INPUT:
+*	enable - MV_TRUE to enable the pads, MV_FALSE to disable.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_OK on success.
+*
+*******************************************************************************/
+MV_STATUS mvCpuIfLvdsPadsEnable(MV_BOOL enable)
+{
+	MV_U32 reg;
+	MV_U32 i;
+
+	reg = MV_REG_READ(LVDS_PADS_CTRL_REG);
+
+	for (i = 0; i < 5; i++) {
+		reg &= ~LVDS_PADS_CONF_PD_MASK(i);
+		reg |= LVDS_PADS_CONF_PD_EN(i, enable);
+	}
+
+	MV_REG_WRITE(LVDS_PADS_CTRL_REG, reg);
+
+	return MV_OK;
+}
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/sys/mvCpuIf.h b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/sys/mvCpuIf.h
new file mode 100644
index 0000000..19467fe
--- /dev/null
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/sys/mvCpuIf.h
@@ -0,0 +1,119 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvCpuIfh
+#define __INCmvCpuIfh
+
+/* includes */
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/sys/mvCpuIfRegs.h"
+#include "ctrlEnv/sys/mvAhbToMbus.h"
+#if defined(MV_INCLUDE_PEX)
+#include "pex/mvPex.h"
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* defines  */
+
+/* typedefs */
+/* This structure describes CPU interface address decode window	*/
+typedef struct _mvCpuIfDecWin {
+	MV_ADDR_WIN	addrWin;	/* An address window */
+	MV_U32		winNum;		/* Window Number in the AHB To Mbus bridge */
+	MV_BOOL		enable;		/* Address decode window is enabled/disabled */
+} MV_CPU_DEC_WIN;
+
+/* mvCpuIfLib.h API list */
+
+/* mvCpuIfLib.h API list */
+
+MV_STATUS mvCpuIfInit(MV_CPU_DEC_WIN *cpuAddrWinMap);
+MV_STATUS mvCpuIfVerify(MV_CPU_DEC_WIN *cpuAddrWinMap);
+MV_STATUS mvCpuIfDramInit(MV_VOID);
+MV_STATUS mvCpuIfTargetWinSet(MV_TARGET target, MV_CPU_DEC_WIN *pAddrDecWin);
+MV_STATUS mvCpuIfTargetWinGet(MV_TARGET target, MV_CPU_DEC_WIN *pAddrDecWin);
+MV_STATUS mvCpuIfTargetWinEnable(MV_TARGET target, MV_BOOL enable);
+MV_U32    mvCpuIfTargetWinSizeGet(MV_TARGET target);
+MV_U32    mvCpuIfTargetWinBaseLowGet(MV_TARGET target);
+MV_U32    mvCpuIfTargetWinBaseHighGet(MV_TARGET target);
+MV_TARGET mvCpuIfTargetOfBaseAddressGet(MV_U32 baseAddress);
+MV_STATUS mvCpuIfSramWinDisable(MV_VOID);
+#if defined(MV_INCLUDE_PEX)
+MV_U32    mvCpuIfPexRemap(MV_TARGET pexTarget, MV_ADDR_WIN *pAddrDecWin);
+#endif
+#if defined(MV_INCLUDE_PCI)
+MV_U32 	  mvCpuIfPciRemap(MV_TARGET pciTarget, MV_ADDR_WIN *pAddrDecWin);
+#endif
+MV_VOID   mvCpuIfAddDecShow(MV_VOID);
+
+MV_STATUS mvCpuIfLvdsPadsEnable(MV_BOOL enable);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __INCmvCpuIfh */
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/sys/mvCpuIfInit.S b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/sys/mvCpuIfInit.S
new file mode 100644
index 0000000..2ed66c8
--- /dev/null
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/sys/mvCpuIfInit.S
@@ -0,0 +1,167 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#define MV_ASMLANGUAGE
+#include "mvCommon.h"
+#include "mvOsAsm.h"
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "mvDeviceId.h"
+#include "mvCtrlEnvRegs.h"
+#include "mvCpuIfRegs.h"
+#include "mvCtrlEnvAsm.h"
+
+
+/*******************************************************************************
+* mvCpuIfPreInit - Make early initialization of CPU interface.
+*
+* DESCRIPTION:
+*       The function will initialize the CPU interface parameters that must
+*       be initialize before any BUS activity towards the DDR interface,
+*       which means it must be executed from ROM. Because of that, the function
+*       is implemented in assembly code.
+*       The function configure the following CPU config register parameters:
+*       1) CPU2MbusLTickDrv
+*       2) CPU2MbusLTickSample.
+*       NOTE: This function must be called AFTER the internal register
+*       base is modified to INTER_REGS_VIRT_BASE.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*       r11 holds return function address.
+*******************************************************************************/
+#define MV88F6281_PCKG_OPT	2
+#define MV88F6192_PCKG_OPT	1
+#define MV88F6180_PCKG_OPT	0
+
+	.globl _mvCpuIfPreInit
+_mvCpuIfPreInit:
+
+	mov     r11, LR     		/* Save link register */
+	b       done
+#if 0
+	/* Read device ID  */
+	MV_CTRL_MODEL_GET_ASM(r4, r5);
+
+	/* goto calcConfigReg if device is 6281/6282 */
+	ldr     r5, =MV88F6281_PCKG_OPT
+	cmp     r4, r5
+	beq     calcConfigReg
+
+	/* goto calcConfigReg if device is 6192/6190 */
+	ldr     r5, =MV88F6192_PCKG_OPT
+	cmp     r4, r5
+	beq     calcConfigReg
+
+	/* Else 6180 */
+	/* Get the "sample on reset" register */
+	MV_REG_READ_ASM (r4, r5, MPP_SAMPLE_AT_RESET)
+	ldr    r5, =MSAR_CPUCLCK_MASK_6180
+	and    r5, r4, r5
+	mov    r5, r5, lsr #MSAR_CPUCLCK_OFFS_6180
+
+	ldr    r4, =CPU_2_MBUSL_DDR_CLK_1x3
+	cmp    r5, #CPU_2_DDR_CLK_1x3_1
+	beq    setConfigReg
+
+	ldr    r4, =CPU_2_MBUSL_DDR_CLK_1x4
+	cmp    r5, #CPU_2_DDR_CLK_1x4_1
+	beq    setConfigReg
+	b    setConfigReg
+
+calcConfigReg:
+	/* Get the "sample on reset" register */
+	MV_REG_READ_ASM (r4, r5, MPP_SAMPLE_AT_RESET)
+	ldr    r5, =MSAR_DDRCLCK_RTIO_MASK
+	and    r5, r4, r5
+	mov    r5, r5, lsr #MSAR_DDRCLCK_RTIO_OFFS
+
+	ldr    r4, =CPU_2_MBUSL_DDR_CLK_1x3
+	cmp    r5, #CPU_2_DDR_CLK_1x3
+	beq    setConfigReg
+
+	ldr    r4, =CPU_2_MBUSL_DDR_CLK_1x4
+	cmp    r5, #CPU_2_DDR_CLK_1x4
+	beq    setConfigReg
+
+	/* Else */
+	ldr    r4, =0
+
+setConfigReg:
+	/* Read CPU Config register */
+	MV_REG_READ_ASM (r7, r5, CPU_CONFIG_REG)
+	ldr    r5, =~(CCR_CPU_2_MBUSL_TICK_DRV_MASK | CCR_CPU_2_MBUSL_TICK_SMPL_MASK)
+	and    r7, r7, r5       /* Clear register fields */
+	orr    r7, r7, r4       /* Set the values according to the findings */
+	MV_REG_WRITE_ASM (r7, r5, CPU_CONFIG_REG)
+#endif
+
+done:
+	mov     PC, r11         /* r11 is saved link register */
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/sys/mvCpuIfRegs.h b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/sys/mvCpuIfRegs.h
new file mode 100644
index 0000000..725d769
--- /dev/null
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/sys/mvCpuIfRegs.h
@@ -0,0 +1,357 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef __INCmvCpuIfRegsh
+#define __INCmvCpuIfRegsh
+
+/****************************************/
+/* ARM Control and Status Registers Map */
+/****************************************/
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ctrlEnv/mvCtrlEnvRegs.h"
+
+#define MV_CPUIF_REGS_BASE(cpu)			(MV_CPUIF_REGS_OFFSET(cpu))
+#define MV_MISC_REGS_BASE			(MV_MISC_REGS_OFFSET)
+#define MV_IP_CONFIG_REGS_BASE			(MV_IP_CONFIG_REGS_OFFSET)
+#define MV_CLK_CMPLX_REGS_BASE			(MV_CLK_CMPLX_REGS_OFFSET)
+#define MV_L2C_REGS_BASE			(MV_AURORA_L2_REGS_OFFSET)
+#define MV_CPUIF_SHARED_REGS_BASE		(MV_MBUS_REGS_OFFSET)
+#define MV_COHERENCY_FABRIC_REGS_BASE		(MV_COHERENCY_FABRIC_OFFSET)
+
+#define CPU_CONFIG_REG(cpu)			(MV_CPUIF_REGS_BASE(cpu))
+#define CPU_CTRL_STAT_REG(cpu)			(MV_CPUIF_REGS_BASE(cpu) + 0x8)
+
+#define PCIE_BOOT_ADDR_REG			(MV_MISC_REGS_BASE + 0xD4)
+#define CPU_RESUME_ADDR_REG			(PCIE_BOOT_ADDR_REG)
+
+#define CPU_SOFT_RESET_REG(cpu)			(MV_MBUS_REGS_OFFSET + 0x800 + (cpu) * 0x8)
+
+#define CPU_RSTOUTN_MASK_REG			(MV_MISC_REGS_BASE + 0x54)
+#define CPU_SYS_SOFT_RST_REG			(MV_MISC_REGS_BASE + 0x58)
+#define CPU_L2_CTRL_REG				(MV_L2C_REGS_BASE + 0x100)
+#define CPU_L2_AUX_CTRL_REG			(MV_L2C_REGS_BASE + 0x104)
+#define SOC_CTRL_REG				(MV_MISC_REGS_BASE + 0x4)
+#define LVDS_PADS_CTRL_REG			(MV_MISC_REGS_BASE + 0xF0)
+#define SOC_COHERENCY_FABRIC_CTRL_REG		(MV_COHERENCY_FABRIC_REGS_BASE)
+#define SOC_COHERENCY_FABRIC_CFG_REG		(MV_COHERENCY_FABRIC_REGS_BASE + 0x4)
+#define SOC_CIB_CTRL_CFG_REG			(MV_COHERENCY_FABRIC_REGS_BASE + 0x80)
+
+#define Fabric_Units_Priority_Control_REG	(MV_MBUS_REGS_OFFSET + 0x424)
+#define Fabric_Units_Prefetch_Control_REG	(MV_MBUS_REGS_OFFSET + 0x42c)
+#define CPUs_Data_PFen (0xf << 8)
+#define CPUs_Data_PFen_MASK (0xf << 8)
+#define CPU_PRIO_HIGH  0x2
+#define CPUs_PRIO_MASK 0xff
+#define CPU0_PRIO_HIGH (CPU_PRIO_HIGH << 0)
+#define CPU1_PRIO_HIGH (CPU_PRIO_HIGH << 2)
+#define CPU2_PRIO_HIGH (CPU_PRIO_HIGH << 4)
+#define CPU3_PRIO_HIGH (CPU_PRIO_HIGH << 6)
+/*   SoC Control Register bits  */
+#define PCIE0_QUADX1_EN				(1<<7)
+#define PCIE1_QUADX1_EN				(1<<8)
+
+/* IP Configuration registers */
+#define USB_CLUSTER_CONTROL                    (MV_IP_CONFIG_REGS_BASE)
+
+/* ARM Configuration register */
+/* CPU_CONFIG_REG (CCR) */
+
+/* Reset vector location */
+#define CCR_VEC_INIT_LOC_OFFS			1
+#define CCR_VEC_INIT_LOC_MASK			(1 << CCR_VEC_INIT_LOC_OFFS)
+/* reset at 0x00000000 */
+#define CCR_VEC_INIT_LOC_0000			(0 << CCR_VEC_INIT_LOC_OFFS)
+/* reset at 0xFFFF0000 */
+#define CCR_VEC_INIT_LOC_FF00			(1 << CCR_VEC_INIT_LOC_OFFS)
+
+#define CCR_ENDIAN_INIT_OFFS			3
+#define CCR_ENDIAN_INIT_MASK			(1 << CCR_ENDIAN_INIT_OFFS)
+#define CCR_ENDIAN_INIT_LITTLE			(0 << CCR_ENDIAN_INIT_OFFS)
+#define CCR_ENDIAN_INIT_BIG			(1 << CCR_ENDIAN_INIT_OFFS)
+
+#define CCR_ARM_ID_SEL_OFFS			4
+#define CCR_CPU_ID_SEL_MASK			(1 << CCR_ARM_ID_SEL_OFFS)
+#define CCR_CPU_ID_SEL_ARM			(0 << CCR_ARM_ID_SEL_OFFS)
+#define CCR_CPU_ID_SEL_MRVL			(1 << CCR_ARM_ID_SEL_OFFS)
+
+#define CCR_TE_INIT_OFFS			5
+#define CCR_TE_INIT_MASK			(1 << CCR_NCB_BLOCKING_OFFS)
+#define CCR_TE_INIT_ARM				(0 << CCR_NCB_BLOCKING_OFFS)
+#define CCR_TE_INIT_THUMB			(1 << CCR_NCB_BLOCKING_OFFS)
+
+#define CCR_NFMI_EN_OFFS			6
+#define CCR_NFMI_EN_MASK			(1 << CCR_NFMI_EN_OFFS)
+#define CCR_NFMI_EN_DIS				(0 << CCR_NFMI_EN_OFFS)
+#define CCR_NFMI_EN_EN				(1 << CCR_NFMI_EN_OFFS)
+
+#define CCR_CORE_MODE_OFFS			9
+#define CCR_CORE_MODE_MASK			(3 << CCR_CORE_MODE_OFFS)
+#define CCR_CORE_MODE_ARM1176			(0 << CCR_CORE_MODE_OFFS)
+#define CCR_CORE_MODE_CORTEX_A8			(1 << CCR_CORE_MODE_OFFS)
+#define CCR_CORE_MODE_ARM11_MPC			(2 << CCR_CORE_MODE_OFFS)
+
+#define CCR_UBIT_INIT_OFFS			11
+#define CCR_UBIT_INIT_MASK			(1 << CCR_UBIT_INIT_OFFS)
+#define CCR_UBIT_INIT_DIS			(0 << CCR_UBIT_INIT_OFFS)
+#define CCR_UBIT_INIT_EN			(1 << CCR_UBIT_INIT_OFFS)
+
+#define CCR_PCLK_WFI_OFFS			15
+#define CCR_PCLK_WFI_MASK			(1 << CCR_PCLK_WFI_OFFS)
+#define CCR_PCLK_WFI_DIS			(0 << CCR_PCLK_WFI_OFFS)
+#define CCR_PCLK_WFI_EN				(1 << CCR_PCLK_WFI_OFFS)
+
+#define CCR_SHARED_L2_OFFS			16
+#define CCR_SHARED_L2_MASK			(1 << CCR_SHARED_L2_OFFS)
+#define CCR_SHARED_L2_DIS			(0 << CCR_SHARED_L2_OFFS)
+#define CCR_SHARED_L2_EN			(1 << CCR_SHARED_L2_OFFS)
+
+#define CCR_SP_IN_MP_OFFS			17
+#define CCR_SP_IN_MP_MASK			(1 << CCR_SP_IN_MP_OFFS)
+#define CCR_SP_IN_MP_DIS			(0 << CCR_SP_IN_MP_OFFS)
+#define CCR_SP_IN_MP_EN				(1 << CCR_SP_IN_MP_OFFS)
+
+#define CCR_SRAM_LOW_LEAK_OFFS			19
+#define CCR_SRAM_LOW_LEAK_MASK			(1 << CCR_SRAM_LOW_LEAK_OFFS)
+#define CCR_SRAM_LOW_LEAK_EN			(0 << CCR_SRAM_LOW_LEAK_OFFS)
+#define CCR_SRAM_LOW_LEAK_DIS			(1 << CCR_SRAM_LOW_LEAK_OFFS)
+
+#define CCR_CLUSTER_ID_OFFS			24
+#define CCR_CLUSTER_ID_MASK			(0xF << CCR_SRAM_LOW_LEAK_OFFS)
+
+/* ARM Control and Status register */
+/* CPU_CTRL_STAT_REG (CCSR) */
+
+#define CCSR_SMP_N_AMP_OFFS			0
+#define CCSR_SMP_N_AMP_MASK			(1 << CCSR_SMP_N_AMP_OFFS)
+
+#define CCSR_ENDIAN_STATUS_OFFS			15
+#define CCSR_ENDIAN_STATUS_MASK			(1 << CCSR_ENDIAN_STATUS_OFFS)
+#define CCSR_ENDIAN_STATUS_LITTLE		(0 << CCSR_ENDIAN_STATUS_OFFS)
+#define CCSR_ENDIAN_STATUS_BIG			(1 << CCSR_ENDIAN_STATUS_OFFS)
+
+/* RSTOUTn Mask Register */
+/* CPU_RSTOUTN_MASK_REG (CRMR) */
+
+#define CRMR_SOFT_RST_OUT_OFFS			0
+#define CRMR_SOFT_RST_OUT_MASK			(1 << CRMR_SOFT_RST_OUT_OFFS)
+#define CRMR_SOFT_RST_OUT_ENABLE		(1 << CRMR_SOFT_RST_OUT_OFFS)
+#define CRMR_SOFT_RST_OUT_DISABLE		(0 << CRMR_SOFT_RST_OUT_OFFS)
+
+#define CRMR_PEX_SYSRST_OUT_OFFS(bus)		(1 + ((bus) & 0x3))
+#define CRMR_PEX_SYSRST_OUT_MASK(bus)		(1 << CRMR_PEX_SYSRST_OUT_OFFS(bus))
+#define CRMR_PEX_SYSRST_OUT_ENABLE(bus)		(1 << CRMR_PEX_SYSRST_OUT_OFFS(bus))
+#define CRMR_PEX_SYSRST_OUT_DISABLE(bus)	(0 << CRMR_PEX_SYSRST_OUT_OFFS(bus))
+
+#define CRMR_PEX_TRST_OUT_OFFS(bus)		(5 + ((bus) & 0x3))
+#define CRMR_PEX_TRST_OUT_MASK(bus)		(1 << CRMR_PEX_TRST_OUT_OFFS(bus))
+#define CRMR_PEX_TRST_OUT_ENABLE(bus)		(1 << CRMR_PEX_TRST_OUT_OFFS(bus))
+#define CRMR_PEX_TRST_OUT_DISABLE(bus)		(0 << CRMR_PEX_TRST_OUT_OFFS(bus))
+
+/* System Software Reset Register */
+/* CPU_SYS_SOFT_RST_REG (CSSRR) */
+
+#define CSSRR_SYSTEM_SOFT_RST			BIT0
+
+
+/* CPU_L2_CTRL_REG fields */
+
+#define CL2CR_L2_EN_OFFS			0
+#define CL2CR_L2_EN_MASK			(1 << CL2CR_L2_EN_OFFS)
+
+/* CPU_L2_AUX_CTRL_REG fields */
+
+#define CL2ACR_WB_WT_ATTR_OFFS			0
+#define CL2ACR_WB_WT_ATTR_MASK			(3 << CL2ACR_WB_WT_ATTR_OFFS)
+#define CL2ACR_WB_WT_ATTR_PAGE			(0 << CL2ACR_WB_WT_ATTR_OFFS)
+#define CL2ACR_WB_WT_ATTR_WB			(1 << CL2ACR_WB_WT_ATTR_OFFS)
+#define CL2ACR_WB_WT_ATTR_WT			(2 << CL2ACR_WB_WT_ATTR_OFFS)
+
+#define CL2ACR_PFU_OFFS				2
+#define CL2ACR_PFU_MASK				(1 << CL2ACR_PFU_OFFS)
+#define CL2ACR_PFU_EN				(1 << CL2ACR_PFU_OFFS)
+#define CL2ACR_PFU_DIS				(0 << CL2ACR_PFU_OFFS)
+
+#define CL2ACR_L2_SIZE_OFFS			10
+#define CL2ACR_L2_SIZE_MASK			(3 << CL2ACR_L2_SIZE_OFFS)
+#define CL2ACR_L2_SIZE_KB(reg)			((((((reg) & 0x3) & CL2ACR_L2_SIZE_MASK) \
+						>> CL2ACR_PFU_OFFS) + 1) * _512K)
+
+#define CL2ACR_ASSOC_OFFS			13
+#define CL2ACR_ASSOC_MASK			(0xF << CL2ACR_ASSOC_OFFS)
+
+#define CL2ACR_L2_WAY_SZ_OFFS			17
+#define CL2ACR_L2_WAY_SZ_MASK			(7 << CL2ACR_L2_WAY_SZ_OFFS)
+#define CL2ACR_L2_WAY_SZ_KB(reg)		(_16K << (((((reg) & 0x7) & CL2ACR_L2_SIZE_MASK) \
+						>> CL2ACR_L2_WAY_SZ_OFFS)))
+
+#define CL2ACR_ECC_OFFS				20
+#define CL2ACR_ECC_MASK				(1 << CL2ACR_ECC_OFFS)
+#define CL2ACR_ECC_EN				(1 << CL2ACR_ECC_OFFS)
+#define CL2ACR_ECC_DIS				(0 << CL2ACR_ECC_OFFS)
+
+#define CL2ACR_PARITY_OFFS			21
+#define CL2ACR_PARITY_MASK			(1 << CL2ACR_PARITY_OFFS)
+#define CL2ACR_PARITY_EN			(1 << CL2ACR_PARITY_OFFS)
+#define CL2ACR_PARITY_DIS			(0 << CL2ACR_PARITY_OFFS)
+
+#define CL2ACR_INVAL_UCE_OFFS			22
+#define CL2ACR_INVAL_UCE_MASK			(1 << CL2ACR_INVAL_UCE_OFFS)
+#define CL2ACR_INVAL_UCE_EN			(1 << CL2ACR_INVAL_UCE_OFFS)
+#define CL2ACR_INVAL_UCE_DIS			(0 << CL2ACR_INVAL_UCE_OFFS)
+
+#define CL2ACR_FORCE_WA_OFFS			23
+#define CL2ACR_FORCE_WA_MASK			(3 << CL2ACR_FORCE_WA_OFFS)
+#define CL2ACR_FORCE_WA_DISABLE			(0 << CL2ACR_FORCE_WA_OFFS)
+#define CL2ACR_FORCE_NO_WA			(1 << CL2ACR_FORCE_WA_OFFS)
+#define CL2ACR_FORCE_WA				(2 << CL2ACR_FORCE_WA_OFFS)
+
+#define CL2ACR_REP_STRGY_OFFS			27
+#define CL2ACR_REP_STRGY_MASK			(3 << CL2ACR_REP_STRGY_OFFS)
+
+#define CL2ACR_REP_STRGY_LFSR_MASK              (0x1 << CL2ACR_REP_STRGY_OFFS)
+#define CL2ACR_REP_STRGY_semiPLRU_MASK		(0x2 << CL2ACR_REP_STRGY_OFFS)
+#define CL2ACR_REP_STRGY_semiPLRU_WA_MASK	(0x3 << CL2ACR_REP_STRGY_OFFS)
+#define CL2_DUAL_EVICTION			(0x1 << 4)
+#define CL2_PARITY_ENABLE			(0x1 << 21)
+#define CL2_InvalEvicLineUCErr			(0x1 << 22)
+
+/* SOC_CTRL_REG fields */
+#define SCR_PEX_ENA_OFFS(pex)			((pex) & 0x3)
+#define SCR_PEX_ENA_MASK(pex)			(1 << pex)
+
+#define SCR_PEX_4BY1_OFFS(pex)			((pex) + 7)
+#define SCR_PEX_4BY1_MASK(pex)			(1 << SCR_PEX_4BY1_OFFS(pex))
+
+#define SCR_PEX0_4BY1_OFFS			7
+#define SCR_PEX0_4BY1_MASK			(1 << SCR_PEX0_4BY1_OFFS)
+
+#define SCR_PEX1_4BY1_OFFS			8
+#define SCR_PEX1_4BY1_MASK			(1 << SCR_PEX1_4BY1_OFFS)
+
+#define PCIE1_CLK_OUT_EN_OFF                   5
+#define PCIE1_CLK_OUT_EN_MASK                  (1 << PCIE1_CLK_OUT_EN_OFF)
+
+#define PCIE0_CLK_OUT_EN_OFF                   4
+#define PCIE0_CLK_OUT_EN_MASK                  (1 << PCIE0_CLK_OUT_EN_OFF)
+
+/* LVDS_PADS_CTRL_REG fields */
+#define LVDS_PADS_CONF_PD_OFFS(idx)		(16 + idx)
+#define LVDS_PADS_CONF_PD_MASK(idx)		(1 << (16 + idx))
+#define LVDS_PADS_CONF_PD_EN(idx, en)		((en ? 0 : 1) << LVDS_PADS_CONF_PD_OFFS(idx))
+
+#define CPU_IO_SYNC_BARRIER_PER_CPU_REG(cpu)	(MV_CPUIF_REGS_BASE(cpu) + 0x10)
+#define CPU_IO_SYNC_BARRIER_REG			(MV_CPUIF_LOCAL_REGS_OFFSET + 0x10)
+
+/*******************************************/
+/* Main Interrupt Controller Registers Map */
+/*******************************************/
+#define CPU_MAIN_INT_CAUSE_REG(vec, cpu)	(MV_CPUIF_REGS_BASE(cpu) + 0x80 + (vec * 0x4))
+#define CPU_MAIN_INT_TWSI_OFFS(i)		(2 + i)
+#define CPU_MAIN_INT_CAUSE_TWSI(i)		(31 + i)
+
+#define CPU_CF_LOCAL_MASK_REG(cpu)		(MV_CPUIF_REGS_BASE(cpu) + 0xc4)
+#define CPU_CF_LOCAL_MASK_PMU_MASK_OFFS		18
+#define CPU_INT_SOURCE_CONTROL_REG(i)		(MV_CPUIF_SHARED_REGS_BASE + 0xB00 + (i * 0x4))
+
+#define CPU_INT_SOURCE_CONTROL_IRQ_OFFS		28
+#define CPU_INT_SOURCE_CONTROL_IRQ_MASK		(1 << CPU_INT_SOURCE_CONTROL_IRQ_OFFS )
+
+#define CPU_INT_SET_ENABLE_REG			(MV_CPUIF_SHARED_REGS_BASE + 0xA30)
+#define CPU_INT_CLEAR_ENABLE_REG		(MV_CPUIF_SHARED_REGS_BASE + 0xA34)
+
+#define CPU_INT_SET_MASK_OFFS			(0xB8)
+#define CPU_INT_CLEAR_MASK_OFFS			(0xBC)
+
+#define CPU_INT_SET_MASK_LOCAL_REG		(MV_CPUIF_LOCAL_REGS_OFFSET + CPU_INT_SET_MASK_OFFS)
+#define CPU_INT_CLEAR_MASK_LOCAL_REG		(MV_CPUIF_LOCAL_REGS_OFFSET + CPU_INT_CLEAR_MASK_OFFS)
+
+#define MV_IRQ_NR				116
+
+/*******************************************/
+/* ARM Doorbell Registers Map              */
+/*******************************************/
+#define CPU_SW_TRIG_IRQ				(MV_MBUS_REGS_OFFSET + 0xA04)
+#define CPU_DOORBELL_IN_REG			(MV_CPUIF_LOCAL_REGS_OFFSET + 0x78)
+#define CPU_DOORBELL_IN_MASK_REG		(MV_CPUIF_LOCAL_REGS_OFFSET + 0x7C)
+#define CPU_HOST_TO_ARM_DRBL_REG(cpu)		(MV_CPUIF_REGS_BASE(cpu) + 0x78)
+#define CPU_HOST_TO_ARM_MASK_REG(cpu)		(MV_CPUIF_REGS_BASE(cpu) + 0x7C)
+#define CPU_ARM_TO_HOST_DRBL_REG(cpu)		(MV_CPUIF_REGS_BASE(cpu) + 0x70)
+#define CPU_ARM_TO_HOST_MASK_REG(cpu)		(MV_CPUIF_REGS_BASE(cpu) + 0x74)
+
+/*******************************************/
+/* CLOCK Complex Registers Map             */
+/*******************************************/
+#define CPU_DIV_CLK_CTRL0_REG			(MV_CLK_CMPLX_REGS_OFFSET)
+#define CPU_DIV_CLK_CTRL0_RESET_MASK_OFFS	8
+#define CPU_DIV_CLK_CTRL2_RATIO_FULL0_REG	(MV_CLK_CMPLX_REGS_OFFSET + 0x8)
+#define CPU_DIV_CLK_CTRL2_NB_RATIO_OFFS		16
+#define CPU_DIV_CLK_CTRL3_RATIO_FULL1_REG	(MV_CLK_CMPLX_REGS_OFFSET + 0xC)
+#define CPU_DIV_CLK_CTRL3_CPU_RATIO_OFFS	8
+
+/* CPU control register map */
+/* Set bits means value is about to change according to new value */
+#define CPU_CONFIG_DEFAULT_MASK         	(CCR_VEC_INIT_LOC_MASK)
+#define CPU_CONFIG_DEFAULT                      (CCR_VEC_INIT_LOC_FF00)
+
+#endif /* __INCmvCpuIfRegsh */
diff --git a/arch/arm/mach-armada38x/armada_38x_family/device/mvDevice.c b/arch/arm/mach-armada38x/armada_38x_family/device/mvDevice.c
new file mode 100644
index 0000000..74c7f27
--- /dev/null
+++ b/arch/arm/mach-armada38x/armada_38x_family/device/mvDevice.c
@@ -0,0 +1,291 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#include "mvTypes.h"
+#include "mvOs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "device/mvDevice.h"
+
+/* defines  */
+#ifdef DEBUG
+#define DB(x)	x
+#else
+#define DB(x)
+#endif
+
+/*******************************************************************************
+* mvDevPramSet - Set device interface bank parameters
+*
+* DESCRIPTION:
+*       This function sets a device bank parameters to a given device.
+*
+* INPUT:
+*       device      - Device number. See MV_DEVICE enumerator.
+*       *pDevParams - Device bank parameter struct.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvDevIfPramSet(MV_DEVICE device, MV_DEVICE_PARAM *pDevParams)
+{
+	MV_U32 devParam = 0;
+	/* check parameters */
+	if (device >= MV_DEV_MAX_CS) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. Invalid Device num %d\n", device));
+		return MV_BAD_PARAM;
+	}
+	if (pDevParams->turnOff > MAX_DBP_TURNOFF) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->turnOff out of range\n"));
+		return MV_ERROR;
+	}
+	if (pDevParams->acc2First > MAX_DBP_ACC2FIRST) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->acc2First out of range\n"));
+		return MV_ERROR;
+	}
+	if (pDevParams->acc2Next > MAX_DBP_ACC2NEXT) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->acc2Next out of range\n"));
+		return MV_ERROR;
+	}
+	if (pDevParams->ale2Wr > MAX_DBP_ALE2WR) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->ale2Wr out of range\n"));
+		return MV_ERROR;
+	}
+	if (pDevParams->wrLow > MAX_DBP_WRLOW) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->ale2Wr out of range\n"));
+		return MV_ERROR;
+	}
+	if (pDevParams->wrHigh > MAX_DBP_WRHIGH) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->ale2Wr out of range\n"));
+		return MV_ERROR;
+	}
+	if ((pDevParams->badrSkew << DBP_BADRSKEW_OFFS) > DBP_BADRSKEW_2CYCLE) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->badrSkew out of range\n"));
+		return MV_ERROR;
+	}
+	if ((pDevParams->deviceWidth != 8) && (pDevParams->deviceWidth != 16) && (pDevParams->deviceWidth != 32)) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->deviceWidth out of range\n"));
+		return MV_ERROR;
+	}
+
+	/* devParam = MV_REG_READ(DEV_BANK_PARAM_REG(device)); */
+	/* setting values */
+	devParam |= DBP_TURNOFF_SET(pDevParams->turnOff);
+	devParam |= DBP_ACC2FIRST_SET(pDevParams->acc2First);
+	devParam |= DBP_ACC2NEXT_SET(pDevParams->acc2Next);
+	devParam |= ((pDevParams->badrSkew & DBP_BADRSKEW_MASK) << DBP_BADRSKEW_OFFS);
+
+	switch (pDevParams->deviceWidth) {
+	case 8:
+		devParam |= DBP_DEVWIDTH_8BIT;
+		break;
+	case 16:
+		devParam |= DBP_DEVWIDTH_16BIT;
+		break;
+	case 32:
+		devParam |= DBP_DEVWIDTH_32BIT;
+		break;
+	default:
+		return MV_ERROR;
+	}
+
+	MV_REG_WRITE(DEV_BANK_PARAM_REG(device), devParam);
+
+	devParam = 0;
+	devParam |= DBP_ALE2WR_SET(pDevParams->ale2Wr);
+	devParam |= DBP_WRLOW_SET(pDevParams->wrLow);
+	devParam |= DBP_WRHIGH_SET(pDevParams->wrHigh);
+	MV_REG_WRITE(DEV_BANK_PARAM_REG_WR(device), devParam);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvDevPramget - Get device interface bank parameters
+*
+* DESCRIPTION:
+*       This function retrieves a device bank parameter settings.
+*
+* INPUT:
+*       device      - Device number. See MV_DEVICE enumerator.
+*
+* OUTPUT:
+*       *pDevParams - Device bank parameter struct.
+*
+* RETURN:
+*       MV_BAD_PARAM for bad parameters ,MV_ERROR on error ! otherwise MV_OK
+*
+*******************************************************************************/
+MV_STATUS mvDevPramGet(MV_DEVICE device, MV_DEVICE_PARAM *pDevParams)
+{
+	MV_U32 devParam = 0;
+
+	/* check parameters */
+	if (device >= MV_DEV_MAX_CS) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. Invalid Device num %d\n", device));
+		return MV_BAD_PARAM;
+
+	}
+
+	devParam = MV_REG_READ(DEV_BANK_PARAM_REG(device));
+
+	pDevParams->turnOff = DBP_TURNOFF_GET(devParam);
+	pDevParams->acc2First = DBP_ACC2FIRST_GET(devParam);
+	pDevParams->acc2Next = DBP_ACC2NEXT_GET(devParam);
+	pDevParams->badrSkew = (devParam & DBP_BADRSKEW_MASK) >> DBP_BADRSKEW_OFFS;
+
+	switch (devParam & DBP_DEVWIDTH_MASK) {
+	case DBP_DEVWIDTH_8BIT:
+		pDevParams->deviceWidth = 8;
+		break;
+	case DBP_DEVWIDTH_16BIT:
+		pDevParams->deviceWidth = 16;
+		break;
+	case DBP_DEVWIDTH_32BIT:
+		pDevParams->deviceWidth = 32;
+		break;
+	default:
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. pDevParams->deviceWidth non valid value\n"));
+		return MV_ERROR;
+		break;
+	}
+
+	devParam = MV_REG_READ(DEV_BANK_PARAM_REG_WR(device));
+	pDevParams->ale2Wr = DBP_ALE2WR_GET(devParam);
+	pDevParams->wrLow = DBP_WRLOW_GET(devParam);
+	pDevParams->wrHigh = DBP_WRHIGH_GET(devParam);
+
+	return MV_OK;
+}
+
+/*******************************************************************************
+* mvDevWidthGet - Get device width parameter
+*
+* DESCRIPTION:
+*       This function gets width parameter of a given device.
+*
+* INPUT:
+*       device - Device number. See MV_DEVICE enumerator.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       Device width in bits (8,16,32...).
+*
+*******************************************************************************/
+MV_U32 mvDevWidthGet(MV_DEVICE device)
+{
+	MV_U32 devParam;
+
+	/* check parameters */
+	if (device >= MV_DEV_MAX_CS) {
+		DB(mvOsPrintf("mvDevIfPramSet: ERR. Invalid Device num %d\n", device));
+		return MV_BAD_PARAM;
+	}
+
+	devParam = MV_REG_READ(DEV_BANK_PARAM_REG(device));
+
+	devParam = (devParam & DBP_DEVWIDTH_MASK) >> DBP_DEVWIDTH_OFFS;
+
+	return (MV_U32) (0x8 << devParam);
+
+}
+
+/*******************************************************************************
+* mvDevNandDevCsSet - Set NAND chip-select, care mode and init sequence
+*
+* DESCRIPTION:
+*       This function set the NAND flash controller registers with NAND
+*       device chip-select.
+*
+* INPUT:
+*       devNum   - Device number. See MV_DEVICE enumerator.
+*       careMode - NAND device care mode (0 = Don't care, '1' = care).
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       None.
+*
+*******************************************************************************/
+MV_VOID mvDevNandDevCsSet(MV_DEVICE device, MV_BOOL careMode)
+{
+	MV_U32 nfCtrlReg;	/* NAND Flash Control Register */
+
+	/* Set chip select */
+	nfCtrlReg = MV_REG_READ(DEV_NAND_CTRL_REG);
+
+	nfCtrlReg |= (DINFCR_NF_CS_MASK(device));
+
+	if (careMode)
+		nfCtrlReg |= (DINFCR_NF_ACT_CE_MASK(device));
+	else
+		nfCtrlReg &= ~(DINFCR_NF_ACT_CE_MASK(device));
+
+	MV_REG_WRITE(DEV_NAND_CTRL_REG, nfCtrlReg);
+}
diff --git a/arch/arm/mach-armada38x/armada_38x_family/device/mvDevice.h b/arch/arm/mach-armada38x/armada_38x_family/device/mvDevice.h
new file mode 100644
index 0000000..2f7d33f
--- /dev/null
+++ b/arch/arm/mach-armada38x/armada_38x_family/device/mvDevice.h
@@ -0,0 +1,99 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#ifndef __INCmvDeviceH
+#define __INCmvDeviceH
+
+#include "device/mvDeviceRegs.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "ctrlEnv/mvCtrlEnvAddrDec.h"
+
+/* This structure describes device interface parameters to be assigned to   */
+/* device bank parameter                                                    */
+typedef struct _mvDeviceParam {
+				/* boundary values */
+    MV_U32       turnOff;	/* 0x0 - 0xf       */
+    MV_U32       acc2First;	/* 0x0 - 0x1f      */
+    MV_U32       acc2Next;	/* 0x0 - 0x1f      */
+    MV_U32       ale2Wr;	/* 0x0 - 0xf       */
+    MV_U32       wrLow;		/* 0x0 - 0xf       */
+    MV_U32       wrHigh;	/* 0x0 - 0xf       */
+    MV_U32       badrSkew;	/* 0x0 - 0x2       */
+    MV_U32       deviceWidth;	/* in Bytes        */
+} MV_DEVICE_PARAM;
+
+
+/* mvDevPramSet - Set device interface bank parameters */
+MV_STATUS mvDevIfPramSet(MV_DEVICE device, MV_DEVICE_PARAM *pDevParams);
+
+/* mvDevPramget - Get device interface bank parameters */
+MV_STATUS mvDevPramGet(MV_DEVICE device, MV_DEVICE_PARAM *pDevParams);
+
+/* mvDevWidthGet - Get device width parameter*/
+MV_U32 mvDevWidthGet(MV_DEVICE device);
+
+/* mvDevNandDevCsSet - Set the NAND flash control registers with NAND device- */
+/* select and care mode */
+MV_VOID mvDevNandDevCsSet(MV_DEVICE device, MV_BOOL careMode);
+
+#endif /* #ifndef __INCmvDeviceH */
diff --git a/arch/arm/mach-armada38x/armada_38x_family/device/mvDeviceRegs.h b/arch/arm/mach-armada38x/armada_38x_family/device/mvDeviceRegs.h
new file mode 100644
index 0000000..fb01c9b
--- /dev/null
+++ b/arch/arm/mach-armada38x/armada_38x_family/device/mvDeviceRegs.h
@@ -0,0 +1,281 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#ifndef __INCmvDeviceRegsH
+#define __INCmvDeviceRegsH
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#define MV_DEVICE_MAX_XBAR_TIMEOUT  0x0FFF
+/* TODO - usage of DEV_BANK_PARAM_REG_DV is unclear */
+/* #define DEV_BANK_PARAM_REG_DV	    0x80000000 */
+/* registers offsets */
+
+static INLINE MV_U32 DEV_BANK_PARAM_REG(int num)
+{
+	switch (num) {
+	case (DEV_BOOCS):
+		return MV_DEV_BUS_REGS_OFFSET + 0x00;
+	case (DEVICE_CS0):
+		return MV_DEV_BUS_REGS_OFFSET + 0x08;
+	case (DEVICE_CS1):
+		return MV_DEV_BUS_REGS_OFFSET + 0x10;
+#ifdef MV_INCLUDE_DEVICE_CS2
+	case (DEVICE_CS2):
+		return MV_DEV_BUS_REGS_OFFSET + 0x18;
+#endif
+#ifdef MV_INCLUDE_DEVICE_CS3
+	case (DEVICE_CS3):
+		return MV_DEV_BUS_REGS_OFFSET + 0x20;
+#endif
+	default:
+		return 0xFFFFFFFF;
+	}
+}
+
+#define DEV_BANK_PARAM_REG_WR(num)	(DEV_BANK_PARAM_REG(num)+0x4)
+#define DEV_NAND_CTRL_REG		(MV_DEV_BUS_REGS_OFFSET + 0x0470)
+#define DEV_BUS_SYNC_CTRL		(MV_DEV_BUS_REGS_OFFSET + 0xC8)
+/* Select Ready Polarity bit for CS in DEV_BUS_SYNC_CTRL */
+#define SYNC_CTRL_READY_POL(cs)		(cs == DEV_BOOCS ? 0x20 : \
+					(cs == DEVICE_CS0 ? 0x400 : \
+					(cs == DEVICE_CS1 ? 0x8000 : \
+					(cs == DEVICE_CS2 ? 0x100000 : \
+					(cs == DEVICE_CS3 ? 0x2000000 : 0)))))
+/* Select Ready Ignore bit for CS in DEV_BUS_SYNC_CTRL */
+#define SYNC_CTRL_READY_IGNORE(cs)	(cs == DEV_BOOCS ? 0x10 : \
+					(cs == DEVICE_CS0 ? 0x200 : \
+					(cs == DEVICE_CS1 ? 0x4000 : \
+					(cs == DEVICE_CS2 ? 0x80000 : \
+					(cs == DEVICE_CS3 ? 0x100000 : 0)))))
+/* Device Bank Parameters register fields (DBP_REG)*/
+/* Boot Device Bank Parameters (DBP) register fields (DEV_BOOT_BANK_PARAM_REG)*/
+/* DBP_XXX_MASK_HIGH is the offset of the extend bit from the msb of the input value */
+
+#define DBP_TURNOFF_OFFS_LOW		0
+#define DBP_TURNOFF_MASK_LOW		0x3F
+#define MAX_DBP_TURNOFF			0xf
+
+
+#define DBP_TURNOFF_SET(value)			\
+((value & DBP_TURNOFF_MASK_LOW) << DBP_TURNOFF_OFFS_LOW)
+
+#define DBP_TURNOFF_GET(value)			\
+((value >> DBP_TURNOFF_OFFS_LOW) & DBP_TURNOFF_MASK_LOW)
+
+#define DBP_ACC2FIRST_OFFS_LOW		6
+#define DBP_ACC2FIRST_MASK_LOW		0x3f
+#define MAX_DBP_ACC2FIRST		0x3f
+
+#define DBP_ACC2FIRST_SET(value)			\
+((value & DBP_ACC2FIRST_MASK_LOW) << DBP_ACC2FIRST_OFFS_LOW)
+
+#define DBP_ACC2FIRST_GET(value)			\
+((value >> DBP_ACC2FIRST_OFFS_LOW) & DBP_ACC2FIRST_MASK_LOW)
+
+#define DBP_ACC2NEXT_OFFS_LOW		17
+#define DBP_ACC2NEXT_MASK_LOW		0x3f
+#define MAX_DBP_ACC2NEXT		0x3f
+
+#define DBP_ACC2NEXT_SET(value)			\
+((value & DBP_ACC2FIRST_MASK_LOW) << DBP_ACC2FIRST_OFFS_LOW)
+
+#define DBP_ACC2NEXT_GET(value)			\
+((value >> DBP_ACC2NEXT_OFFS_LOW) & DBP_ACC2NEXT_MASK_LOW)
+
+#define DBP_DEVWIDTH_OFFS		30 /* Device Width */
+#define DBP_DEVWIDTH_MASK		(0x3 << DBP_DEVWIDTH_OFFS)
+#define DBP_DEVWIDTH_8BIT		(0x0 << DBP_DEVWIDTH_OFFS)
+#define DBP_DEVWIDTH_16BIT		(0x1 << DBP_DEVWIDTH_OFFS)
+#define DBP_DEVWIDTH_32BIT		(0x2 << DBP_DEVWIDTH_OFFS)
+
+#define DBP_BADRSKEW_OFFS		28
+#define DBP_BADRSKEW_MASK		(0x3 << DBP_BADRSKEW_OFFS)
+#define DBP_BADRSKEW_NOGAP		(0x0 << DBP_BADRSKEW_OFFS)
+#define DBP_BADRSKEW_1CYCLE		(0x1 << DBP_BADRSKEW_OFFS)
+#define DBP_BADRSKEW_2CYCLE		(0x2 << DBP_BADRSKEW_OFFS)
+
+
+#define DBP_ALE2WR_OFFS_LOW		0
+#define DBP_ALE2WR_MASK_LOW		0x3f
+#define MAX_DBP_ALE2WR			0x3F
+
+#define DBP_ALE2WR_SET(value)			\
+((value & DBP_ALE2WR_MASK_LOW) << DBP_ALE2WR_OFFS_LOW)
+
+#define DBP_ALE2WR_GET(value)			\
+((value >> DBP_ALE2WR_OFFS_LOW) & DBP_ALE2WR_MASK_LOW)
+
+#define DBP_WRLOW_OFFS_LOW		8
+#define DBP_WRLOW_MASK_LOW		0x3F
+#define MAX_DBP_WRLOW			0x3F
+
+#define DBP_WRLOW_SET(value)			\
+((value & DBP_WRLOW_MASK_LOW) << DBP_WRLOW_OFFS_LOW)
+
+#define DBP_WRLOW_GET(value)			\
+((value >> DBP_WRLOW_OFFS_LOW) & DBP_WRLOW_MASK_LOW)
+
+#define DBP_WRHIGH_OFFS_LOW		16
+#define DBP_WRHIGH_MASK_LOW		0x3F
+#define MAX_DBP_WRHIGH			0x3F
+
+#define DBP_WRHIGH_SET(value)			\
+((value & DBP_WRHIGH_MASK_LOW) << DBP_WRHIGH_OFFS_LOW)
+
+#define DBP_WRHIGH_GET(value)			\
+((value >> DBP_WRHIGH_OFFS_LOW) & DBP_WRHIGH_MASK_LOW)
+
+
+/* Device Interface Control register fields (DIC) (DIC_REG)*/
+#define DIC_TIMEOUT_OFFS 	0 /* Timeout Timer Preset Value. */
+#define DIC_TIMEOUT_MASK 	(0xffff << DIC_TIMEOUT_OFFS)
+#define MAX_DIC_TIMEOUT		0xffff
+
+/* NAND Flash Control register fields (NF) (NF_REG)*/
+#define NF_BOOTCS_OFFS			0 /* Define if BOOTCS is connected to NAND Flash */
+#define NF_BOOT_MASK			(1 << NF_BOOTCS_OFFS)
+#define NF_BOOT_NC			(0 << NF_BOOTCS_OFFS)
+#define NF_BOOT_C			(1 << NF_BOOTCS_OFFS)
+
+#define NF_BOOTCS_CE_ACT_OFFS		1 /* Define if NAND Flash on BOOTCS is CE care or CE don't care */
+#define NF_BOOTCS_CE_ACT_MASK 		(1 << NF_BOOTCS_CE_ACT_OFFS)
+#define NF_BOOTCS_CE_ACT_NCARE		(0 << NF_BOOTCS_CE_ACT_OFFS)
+#define NF_BOOTCS_CE_ACT_CARE		(1 << NF_BOOTCS_CE_ACT_OFFS)
+
+#define NF_CS0_OFFS			2 /* Define if CS0 is connected to NAND Flash */
+#define NF_CS0_MASK			(1 << NF_CS0_OFFS)
+#define NF_CS0_NC			(0 << NF_CS0_OFFS)
+#define NF_CS0_C			(1 << NF_CS0_OFFS)
+
+#define NF_CS0_CE_ACT_OFFS		3 /* Define if NAND Flash on CS0 is CE care or CE don't care */
+#define NF_CS0_CE_ACT_MASK 		(1 << NF_CS0_CE_ACT_OFFS)
+#define NF_CS0_CE_ACT_NCARE		(0 << NF_CS0_CE_ACT_OFFS)
+#define NF_CS0_CE_ACT_CARE		(1 << NF_CS0_CE_ACT_OFFS)
+
+#define NF_CS1_OFFS			4 /* Define if CS1 is connected to NAND Flash */
+#define NF_CS1_MASK			(1 << NF_CS1_OFFS)
+#define NF_CS1_NC			(0 << NF_CS1_OFFS)
+#define NF_CS1_C			(1 << NF_CS1_OFFS)
+
+#define NF_CS1_CE_ACT_OFFS		5 /* Define if NAND Flash on CS1 is CE care or CE don't care */
+#define NF_CS1_CE_ACT_MASK		(1 << NF_CS1_CE_ACT_OFFS)
+#define NF_CS1_CE_ACT_NCARE		(0 << NF_CS1_CE_ACT_OFFS)
+#define NF_CS1_CE_ACT_CARE		(1 << NF_CS1_CE_ACT_OFFS)
+
+#define NF_CS2_OFFS			6 /* Define if CS2 is connected to NAND Flash */
+#define NF_CS2_MASK			(1 << NF_CS2_OFFS)
+#define NF_CS2_NC			(0 << NF_CS2_OFFS)
+#define NF_CS2_C			(1 << NF_CS2_OFFS)
+
+#define NF_CS2_CE_ACT_OFFS		7 /* Define if NAND Flash on CS2 is CE care or CE don't care */
+#define NF_CS2_CE_ACT_MASK		(1 << NF_CS2_CE_ACT_OFFS)
+#define NF_CS2_CE_ACT_NCARE		(0 << NF_CS2_CE_ACT_OFFS)
+#define NF_CS2_CE_ACT_CARE		(1 << NF_CS2_CE_ACT_OFFS)
+
+#define NF_INIT_SEQ_OFFS		8 /* NAND Flash initialization sequence */
+#define NF_INIT_SEQ_MASK		(1 << NF_INIT_SEQ_OFFS)
+#define NF_INIT_SEQ_EN			(0 << NF_INIT_SEQ_OFFS)
+#define NF_INIT_SEQ_DIS			(1 << NF_INIT_SEQ_OFFS)
+
+#define NF_OE_HIGHW_OFFS		9 /* NAND Flash OE high width in core clocks units (value + 1) */
+#define NF_OE_HIGHW_MASK		(0x1f << NF_OE_HIGHW_OFFS)
+#define MAX_OE_HIGHW			(0x1f << NF_OE_HIGHW_OFFS)
+
+#define NF_TREADY_OFFS			14 /* NAND Flash time ready in core clocks units (value + 1) */
+#define NF_TREADY_MASK			(0x1f << NF_TREADY_OFFS)
+#define MAX_TREADY			(0x1f << NF_TREADY_OFFS)
+
+#define NF_OE_TCTRL_OFFS		19 /* NAND Flash OE toggle control */
+#define NF_OE_TCTRL_MASK		(1 << NF_OE_TCTRL_OFFS)
+#define NF_OE_TCTRL_1_CYC_AFT		(0 << NF_OE_TCTRL_OFFS)
+#define NF_OE_TCTRL_SAME_CYC		(1 << NF_OE_TCTRL_OFFS)
+
+#define NF_CS3_OFFS			20 /* Define if CS3 is connected to NAND Flash */
+#define NF_CS3_MASK			(1 << NF_CS3_OFFS)
+#define NF_CS3_NC			(0 << NF_CS3_OFFS)
+#define NF_CS3_C			(1 << NF_CS3_OFFS)
+
+#define NF_CS3_CE_ACT_OFFS		21 /* Define if NAND Flash on CS3 is CE care or CE don't care */
+#define NF_CS3_CE_ACT_MASK		(1 << NF_CS3_CE_ACT_OFFS)
+#define NF_CS3_CE_ACT_NCARE		(0 << NF_CS3_CE_ACT_OFFS)
+#define NF_CS3_CE_ACT_CARE		(1 << NF_CS3_CE_ACT_OFFS)
+
+
+/* Device Interface NAND Flash Control Register (DINFCR) */
+#define DINFCR_NF_CS_MASK(csNum)         \
+(csNum == BOOT_CS) ?  0x1 : ((csNum == DEV_CS3) ? (0x1 << 20) : (0x1 << (((csNum+1) % MV_DEV_MAX_CS) * 2)))
+
+
+#define DINFCR_NF_ACT_CE_MASK(csNum)     \
+(csNum == DEV_CS3) ? (0x2 << 20) : (0x2 << (((csNum+1) % MV_DEV_MAX_CS) * 2))
+
+#define NAND_ACTCEBOOT_BIT	BIT1
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* #ifndef __INCmvDeviceRegsH */
-- 
1.7.5.4

