From c2fc0accb91c233f8da2a66154dd1f61c8100233 Mon Sep 17 00:00:00 2001
From: Nadav Haklai <nadavh@marvell.com>
Date: Mon, 21 Sep 2015 11:39:27 +0300
Subject: [PATCH 108/150] ARM: mvebu: cpufreq: Protect entring WFI by
 disabling the ACP port

According to ARM, The traffic on the ACP port of the SCU can wake the CPU
from wfi. When executing wfi as part of entering cpufreq on Armada 380 SoC,
such wake event can lead to system hang.

In order to avoid this scenraio, before entreing wfi we quiet the ACP port
by disabling the CIB ack mechanism of the SOC and wait until it is empty.
To insure the execution sequence isb is added before the wfi.

This patch supports cpufreq with single CPU only

Signed-off-by: Nadav Haklai <nadavh@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/23689

Fix check-patch error (line over 80 char) by using shorter definition:
CIB_CONTROL_AND_CONFIG_EMPTY_STAT_OFFSET instead of
CIB_CONTROL_AND_CONFIG_EMPTY_STATUS_OFFSET
Signed-off-by: Grzegorz Jaszczyk <jaz@semihalf.com>

Change-Id: I14e6d2135c73cbfebf8fc3ea5d8eb934dce62f18
Reviewed-on: http://vgitil04.il.marvell.com:8080/27315
Reviewed-by: Nadav Haklai <nadavh@marvell.com>
Tested-by: Lior Amsalem <alior@marvell.com>
[zou:Original patch taken from
https://github.com/MarvellEmbeddedProcessors/linux-marvell-prv.git linux-4.4.1-devel]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 arch/arm/boot/dts/armada-38x.dtsi |    2 +-
 arch/arm/mach-mvebu/pmsu.c        |   32 ++++++++++++++++++++++++++++++++
 2 files changed, 33 insertions(+), 1 deletions(-)

diff --git a/arch/arm/boot/dts/armada-38x.dtsi b/arch/arm/boot/dts/armada-38x.dtsi
index d5ccb31..08b9190 100644
--- a/arch/arm/boot/dts/armada-38x.dtsi
+++ b/arch/arm/boot/dts/armada-38x.dtsi
@@ -448,7 +448,7 @@
 
 			pmsu@22000 {
 				compatible = "marvell,armada-380-pmsu";
-				reg = <0x22000 0x1000>;
+				reg = <0x22000 0x1000>, <0x20280 0x4>;
 			};
 
 			eth0: ethernet@70000 {
diff --git a/arch/arm/mach-mvebu/pmsu.c b/arch/arm/mach-mvebu/pmsu.c
index 50c95a1..fa6d26c 100644
--- a/arch/arm/mach-mvebu/pmsu.c
+++ b/arch/arm/mach-mvebu/pmsu.c
@@ -82,6 +82,15 @@
 #define PMSU_POWERDOWN_DELAY_MASK		0xFFFE
 #define PMSU_DFLT_ARMADA38X_DELAY	        0x64
 
+/* CIB Control and Configuration */
+#define CIB_CONTROL_AND_CONFIG_ACCK_EN_OFFSET		9
+#define CIB_CONTROL_AND_CONFIG_ACCK_EN_MASK		0x1
+#define CIB_CONTROL_AND_CONFIG_ACCK_EN_DISABLE		0x1
+#define CIB_CONTROL_AND_CONFIG_ACCK_ENABLE		0x0
+#define CIB_CONTROL_AND_CONFIG_EMPTY_STAT_OFFSET	13
+#define CIB_CONTROL_AND_CONFIG_EMPTY_STATUS_MASK	0x1
+#define CIB_CONTROL_AND_CONFIG_NOT_EMPTY		0x0
+
 /* CA9 MPcore SoC Control registers */
 
 #define MPCORE_RESET_CTL		    0x64
@@ -103,6 +112,7 @@ extern void armada_38x_cpu_resume(void);
 
 static phys_addr_t pmsu_mp_phys_base;
 static void __iomem *pmsu_mp_base;
+static void __iomem *cib_control;
 
 static void *mvebu_cpu_resume;
 static int (*mvebu_pmsu_dfs_request_ptr)(int cpu);
@@ -203,6 +213,14 @@ static int __init mvebu_v7_pmsu_init(void)
 		goto out;
 	}
 
+	cib_control = of_iomap(np, 1);
+	if (!cib_control) {
+		pr_err("unable to map registers\n");
+		iounmap(pmsu_mp_base);
+		ret = -ENOMEM;
+		goto out;
+	}
+
  out:
 	of_node_put(np);
 	return ret;
@@ -573,7 +591,21 @@ static void mvebu_pmsu_dfs_request_local(void *data)
 	reg |= PMSU_CTL_CFG_DFS_REQ;
 	writel(reg, pmsu_mp_base + PMSU_CTL_CFG(cpu));
 
+	/* before enter wfi need to empty the CIB */
+	reg = readl(cib_control);
+	reg |= (CIB_CONTROL_AND_CONFIG_ACCK_EN_DISABLE <<
+			CIB_CONTROL_AND_CONFIG_ACCK_EN_OFFSET);
+
+	writel(reg, cib_control);
+
+	/* wait until CIB is empty */
+	while (((readl(cib_control) >> CIB_CONTROL_AND_CONFIG_EMPTY_STAT_OFFSET)
+			& CIB_CONTROL_AND_CONFIG_EMPTY_STATUS_MASK) ==
+			CIB_CONTROL_AND_CONFIG_NOT_EMPTY)
+		;
+
 	/* The fact of entering idle will trigger the DFS transition */
+	isb();
 	wfi();
 
 	/*
-- 
1.7.5.4

