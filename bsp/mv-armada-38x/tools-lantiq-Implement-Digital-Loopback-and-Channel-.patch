From b15d2b23149fb9020bdbe6a334c5f117efb6b003 Mon Sep 17 00:00:00 2001
From: Eran Ben-Avi <benavi@marvell.com>
Date: Thu, 11 Jul 2013 16:52:07 +0300
Subject: [PATCH 0787/1825] tools/lantiq: Implement Digital Loopback and
 Channel Balancing tests.

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 6b698d507f5464a70301d797fb042a0d30814781

	The new Lantiq DuSLIC-xT driver introduces loopback mode which can
	be used to implement these tests. The Zarlink version of the
	mv_voice_tool was used as reference.

Change-Id: I46b608ddf96d177d4a0105743fbb433d15c45f8f
Signed-off-by: Piotr Ziecik <kosmo@semihalf.com>
Signed-off-by: Eran Ben-Avi <benavi@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 tools/voice/lantiq/kernel/libtapi.c       |   13 ++
 tools/voice/lantiq/kernel/libtapi.h       |    2 +
 tools/voice/lantiq/kernel/mv_voice_tool.c |  271 +++++++++++++++++++++++++++++
 3 files changed, 286 insertions(+), 0 deletions(-)

diff --git a/tools/voice/lantiq/kernel/libtapi.c b/tools/voice/lantiq/kernel/libtapi.c
index aebd84d..3712563 100644
--- a/tools/voice/lantiq/kernel/libtapi.c
+++ b/tools/voice/lantiq/kernel/libtapi.c
@@ -651,3 +651,16 @@ tapi_pcm_channel_activate(tapi_handle_t th, unsigned int device,
 
 	return(ioctl(th->fd, IFX_TAPI_PCM_ACTIVATION_SET, &pcmact));
 }
+
+int
+tapi_test_loop(tapi_handle_t th, unsigned int device,
+				      unsigned int channel, unsigned int enable)
+{
+	IFX_TAPI_TEST_LOOP_t tloop;
+
+	tloop.dev	= device;
+	tloop.ch	= channel;
+	tloop.bAnalog	= enable;
+
+	return(ioctl(th->fd, IFX_TAPI_TEST_LOOP, &tloop));
+}
diff --git a/tools/voice/lantiq/kernel/libtapi.h b/tools/voice/lantiq/kernel/libtapi.h
index 1b774cd..44c6c03 100644
--- a/tools/voice/lantiq/kernel/libtapi.h
+++ b/tools/voice/lantiq/kernel/libtapi.h
@@ -334,5 +334,7 @@ extern int tapi_pcm_channel_config(tapi_handle_t th, unsigned int device,
 		tapi_pcm_coding_t coding);
 extern int tapi_pcm_channel_activate(tapi_handle_t th, unsigned int device,
 							  unsigned int channel);
+extern int tapi_test_loop(tapi_handle_t th, unsigned int device,
+				     unsigned int channel, unsigned int enable);
 
 #endif /* _LIBTAPI_H */
diff --git a/tools/voice/lantiq/kernel/mv_voice_tool.c b/tools/voice/lantiq/kernel/mv_voice_tool.c
index 24c29af..c0f7578 100644
--- a/tools/voice/lantiq/kernel/mv_voice_tool.c
+++ b/tools/voice/lantiq/kernel/mv_voice_tool.c
@@ -134,6 +134,7 @@ static void sw_loopback(int tdm_fd, unsigned char line_id);
 static void sw_loopback_two_phones_test(int tdm_fd, unsigned char line0, unsigned char line1);
 static void sw_loopback_multi_phones_test(int tdm_fd, unsigned char start_line, unsigned char end_line);
 static void slic_digital_loopback(int tdm_fd, unsigned long int iterations);
+static void channel_balancing_test(int tdm_fd, unsigned long int iterations);
 static void wait_for_event(int block);
 static void release(int signum);
 
@@ -196,6 +197,8 @@ int main(void)
 		printf("  5. Self echo on local phone\n");
 		printf("  6. Loopback two local phones\n");
 		printf("  7. Multiple local phone pairs loopback\n");
+		printf("  8. Digital Loopback (incremental pattern)\n");
+		printf("  9. Channel balancing\n");
 		printf("  a. Start Phone devices\n");
 		printf("  b. Stop Phone devices\n");
 #if defined(MV_TDM_USE_DCO)
@@ -276,6 +279,24 @@ int main(void)
 				sw_loopback_multi_phones_test(tdm_fd, line0_id, line1_id);
 				break;
 
+			case '8':
+				printf("%s Enter number of iterations(must be greater than 3): ", TOOL_PREFIX);
+				gets(str);
+				iterations = (unsigned long int)atoi(str);
+				if(iterations < 4) {
+					printf("Requires at least 4 iterations  - try again\n");
+					break;
+				}
+				slic_digital_loopback(tdm_fd, iterations);
+				break;
+
+			case '9':
+				printf("%s Enter number of iterations('0' - for infinite loop): ", TOOL_PREFIX);
+				gets(str);
+				iterations = (unsigned long int)atoi(str);
+				channel_balancing_test(tdm_fd, iterations);
+				break;
+
 			case 'a':
 				/* Start Telephony */
 				if(ioctl(tdm_fd, TDM_DEV_TDM_START, &tdm_params)) {
@@ -785,3 +806,253 @@ static void wait_for_event(int block)
 		break;
 	}
 }
+
+static int slic_dl_data_compare(int ch)
+{
+	int i = 0, offset = (ch * pcm_bytes * 80);
+
+	/* Align Tx & Rx data start */
+	while((aud_buf[1][offset] != aud_buf[0][offset+i]) && (i < (pcm_bytes * 80)))
+		i++;
+
+	if(i >= (offset + (pcm_bytes * 80))) {
+		printf("\nError, first Tx byte not found inside Rx buffer\n");
+		return -1;
+	}
+
+	if(memcmp(&aud_buf[0][offset+i], &aud_buf[1][offset], ((pcm_bytes * 80) - i))) {
+		printf("\nDump buffers:\n");
+		for(i = offset; i < (offset +(pcm_bytes * 80)); i++)
+			printf("write[%d] = 0x%x, read[%d] = 0x%x\n", i, aud_buf[1][i], i, aud_buf[0][i]);
+		return -1;
+	} else {
+		return 0;
+	}
+}
+
+static void slic_digital_loopback(int tdm_fd, unsigned long int iterations)
+{
+	fd_set rd_fds, wr_fds;
+	struct timeval timeout = {0, TIMEOUT};
+	int msg_len, cmp_status = 0, ch;
+	unsigned long int loops = 0, index;
+
+	if (tdm_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return;
+	}
+
+	/* Put SLIC/s in loopback mode */
+	for(ch = 0; ch < total_lines; ch++)
+		tapi_test_loop(th, TAPI_DEVICE, ch, 1);
+
+	/* Wait a bit */
+	sleep(1);
+
+	/* Put SLIC/s in TALK mode */
+	for(ch = 0; ch < total_lines; ch++)
+		tapi_line_feed_set(th, TAPI_DEVICE, ch, TAPI_LINE_FEED_ACTIVE);
+
+	/* Fill Tx buffer with incremental pattern */
+	for(ch = 0; ch < total_lines; ch++) {
+		for(index = 0; index < (80 * pcm_bytes); index++)
+			aud_buf[1][index + (80 * pcm_bytes * ch)] = (index+ch+2);
+	}
+
+	if (ioctl(tdm_fd, TDM_DEV_PCM_START, 0)) {
+		printf("Error, unable to start pcm bus\n");
+		return;
+	}
+
+	while (loops < iterations) {
+		FD_ZERO(&rd_fds);
+		FD_ZERO(&wr_fds);
+		FD_SET(tdm_fd, &rd_fds);
+		FD_SET(tdm_fd, &wr_fds);
+
+		/* Wait for event  */
+		if (select(tdm_fd+1, &rd_fds, &wr_fds, NULL, &timeout) == 0) {
+			printf("Error, timeout while polling(%dusec)\n", TIMEOUT);
+			goto slic_dl_out;
+		}
+
+		/* Write */
+		if (FD_ISSET(tdm_fd, &wr_fds)) {
+			msg_len = write(tdm_fd, aud_buf[1], buff_size);
+			if (msg_len < buff_size) {
+				printf("write() failed\n");
+				goto slic_dl_out;
+			}
+		}
+
+		/* Read */
+		if (FD_ISSET(tdm_fd, &rd_fds)) {
+			memset(aud_buf[0], 0, buff_size);
+			msg_len = read(tdm_fd, aud_buf[0], buff_size);
+			if (msg_len < buff_size) {
+				printf("read() failed\n");
+				goto slic_dl_out;
+			}
+
+			if(loops++ > 3) {
+				for(ch = 0; ch < total_lines; ch++) {
+					if(slic_dl_data_compare(ch)) {
+						printf("\nERROR - data miscompare(loops=%d) !!!\n",loops);
+						cmp_status = 1;
+						goto slic_dl_out;
+					}
+				}
+			}
+		}
+
+		/* Reload timeout */
+		timeout.tv_usec = TIMEOUT;
+	}
+
+slic_dl_out:
+	if(cmp_status == 0)
+		printf("\nDigital loopback test(%d lines) - PASS !!!\n",total_lines);
+
+	if (ioctl(tdm_fd, TDM_DEV_PCM_STOP, 0)) {
+		printf("Error, unable to stop pcm bus\n");
+		return;
+	}
+
+	/* Disable loopback mode */
+	for(ch = 0; ch < total_lines; ch++)
+		tapi_test_loop(th, TAPI_DEVICE, ch, 0);
+
+	/* Put SLIC/s in STANDBY mode */
+	for(ch = 0; ch < total_lines; ch++)
+		tapi_line_feed_set(th, TAPI_DEVICE, ch, TAPI_LINE_FEED_STANDBY);
+}
+
+static void channel_balancing_test(int tdm_fd, unsigned long int iterations)
+{
+	fd_set rd_fds, wr_fds;
+	struct timeval timeout = {0, TIMEOUT};
+	int msg_len, cmp_status = 0, ch, cb_loop = 0, i;
+	unsigned long int loops = 0, index;
+
+	if (tdm_fd <= 0) {
+		printf("Device %s is not accessible\n", dev_name);
+		return;
+	}
+
+	/* Fill Tx buffer with incremental pattern */
+	for(ch = 0; ch < total_lines; ch++) {
+		for(index = 0; index < (80 * pcm_bytes); index+=2)
+			*((unsigned short*)&aud_buf[1][(80 * pcm_bytes * ch) + index]) = (((index+3) << 8)+ (index+1));
+	}
+
+	/* Put SLIC/s in loopback mode */
+	for(ch = 0; ch < total_lines; ch++)
+		tapi_test_loop(th, TAPI_DEVICE, ch, 1);
+
+	/* Wait a bit */
+	sleep(1);
+
+	/* Put SLIC/s in TALK mode */
+	for(ch = 0; ch < total_lines; ch++)
+		tapi_line_feed_set(th, TAPI_DEVICE, ch, TAPI_LINE_FEED_ACTIVE);
+
+	/* Wait a bit */
+	sleep(1);
+
+	if (iterations == 0)
+		iterations = (unsigned long int)(-1); /* Assume infinite */
+
+	while (loops < iterations) {
+		cb_loop = 0;
+		i = 0;
+
+		if (ioctl(tdm_fd, TDM_DEV_PCM_START, 0)) {
+			printf("Error, unable to start pcm bus\n");
+			return;
+		}
+
+		while (cb_loop == 0) {
+			FD_ZERO(&rd_fds);
+			FD_ZERO(&wr_fds);
+			FD_SET(tdm_fd, &rd_fds);
+			FD_SET(tdm_fd, &wr_fds);
+
+			/* Wait for event  */
+			if (select(tdm_fd+1, &rd_fds, &wr_fds, NULL, &timeout) == 0) {
+				printf("Error, timeout while polling(%dusec)\n", TIMEOUT);
+				goto cb_out;
+			}
+
+			/* Write */
+			if (FD_ISSET(tdm_fd, &wr_fds)) {
+				msg_len = write(tdm_fd, aud_buf[1], buff_size);
+				if (msg_len < buff_size) {
+					printf("write() failed\n");
+					goto cb_out;
+				}
+			}
+
+			/* Read */
+			if (FD_ISSET(tdm_fd, &rd_fds)) {
+				memset(aud_buf[0], 0, buff_size);
+				msg_len = read(tdm_fd, aud_buf[0], buff_size);
+				if (msg_len < buff_size) {
+					printf("read() failed\n");
+					goto cb_out;
+				}
+
+				if(i > 3) {
+					for(ch = 1; ch < total_lines; ch++) {
+						if(memcmp(aud_buf[0], &aud_buf[0][(ch * pcm_bytes * 80)], (pcm_bytes * 80))) {
+							printf("\nERROR - data miscompare(ch=%d) !!!\n", ch);
+							cmp_status = 1;
+							goto cb_out;
+						}
+					}
+
+					cb_loop = 1;
+				}
+				i++;
+			}
+
+			/* Reload timeout */
+			timeout.tv_usec = TIMEOUT;
+		}
+
+		loops++;
+		if (ioctl(tdm_fd, TDM_DEV_PCM_STOP, 0)) {
+			printf("Error, unable to stop pcm bus\n");
+			return;
+		}
+		printf("loop #%u\n", loops);
+		sleep(1);
+	}
+
+cb_out:
+	if(cmp_status == 0) {
+		printf("\nChannel balancing test PASSED !!!\n");
+	} else {
+		printf("Dump Rx buffer:\n");
+		for(ch = 0; ch < total_lines; ch++) {
+			printf("Buffer #%d: ", ch);
+			for(i = 0; i < (pcm_bytes * 80); i++) {
+				printf("0x%x ", aud_buf[0][(ch * pcm_bytes * 80) + i]);
+			}
+			printf("\n\n");
+			sleep(1);
+		}
+	}
+
+	if (ioctl(tdm_fd, TDM_DEV_PCM_STOP, 0)) {
+		printf("Error, unable to stop pcm bus\n");
+		return;
+	}
+
+	/* Disable loopback mode */
+	for(ch = 0; ch < total_lines; ch++)
+		tapi_test_loop(th, TAPI_DEVICE, ch, 0);
+
+	/* Put SLIC/s in STANDBY mode */
+	for(ch = 0; ch < total_lines; ch++)
+		tapi_line_feed_set(th, TAPI_DEVICE, ch, TAPI_LINE_FEED_STANDBY);
+}
-- 
1.7.5.4

