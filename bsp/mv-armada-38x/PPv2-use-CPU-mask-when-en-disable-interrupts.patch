From f7bf20935f4bcd6f0f2a9ec832a4c3110f569aa2 Mon Sep 17 00:00:00 2001
From: Yoni Farhadian <yonif@marvell.com>
Date: Wed, 17 Jul 2013 16:15:08 +0300
Subject: [PATCH 0843/1825] PPv2: use CPU mask when en/disable interrupts

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit ec5a9313b27550e0e594685073519c89a3c718fa

	Change En/Disable PPv2 interrupts API to work with cpu mask instead of per cpu

Change-Id: I30d8003d4cd0dc3028f12e15686fb0fbd13a12b7
Signed-off-by: Yoni Farhadian <yonif@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/2711
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Reviewed-by: Nadav Haklai <nadavh@marvell.com>
Tested-by: Nadav Haklai <nadavh@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c      |   43 +++++++------------
 arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.c     |   15 +++----
 arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.h     |    4 +-
 arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2GbeRegs.h |    5 +-
 4 files changed, 28 insertions(+), 39 deletions(-)

diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
index 890f228..8dfda8e 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
@@ -365,20 +365,21 @@ int mv_eth_napi_set_cpu_affinity(int port, int group, int cpu_mask)
 	mv_eth_interrupts_mask(pp);
 	smp_call_function_many(cpu_online_mask, (smp_call_func_t)mv_eth_interrupts_mask, (void *)pp, 1);
 	/* update group's CPU mask - remove old CPUs using this group */
-	for_each_possible_cpu(cpu) {
-		if (pp->cpu_config[cpu]->napi_group == napi_group) {
-			mvPp2GbeCpuInterruptsDisable(port, cpu);
+	for_each_possible_cpu(cpu)
+		if ((1 << cpu) & napi_group->cpu_mask)
 			pp->cpu_config[cpu]->napi_group = NULL;
-		}
-	}
+
+	mvPp2GbeCpuInterruptsDisable(port, napi_group->cpu_mask);
+
 	napi_group->cpu_mask = cpu_mask;
 	napi_group->cause_rx_tx = 0;
 
 	for_each_possible_cpu(cpu)
-		if ((1 << cpu) & cpu_mask) {
-			mvPp2GbeCpuInterruptsEnable(port, cpu);
+		if ((1 << cpu) & cpu_mask)
 			pp->cpu_config[cpu]->napi_group = napi_group;
-		}
+
+	mvPp2GbeCpuInterruptsEnable(port, cpu_mask);
+
 	/* mask rx interrupts for every cpu according to its napi group */
 	mv_eth_interrupts_unmask(pp);
 	smp_call_function_many(cpu_online_mask, (smp_call_func_t)mv_eth_interrupts_unmask, (void *)pp, 1);
@@ -2733,11 +2734,10 @@ irqreturn_t mv_eth_isr(int irq, void *dev_id)
 	struct eth_port *pp = (struct eth_port *)dev_id;
 	struct napi_group_ctrl *napi_group = pp->cpu_config[smp_processor_id()]->napi_group;
 	struct napi_struct *napi = napi_group->napi;
-	int cpu;
 
 #ifdef CONFIG_MV_ETH_DEBUG_CODE
 	if (pp->dbg_flags & MV_ETH_F_DBG_ISR) {
-		printk(KERN_ERR "%s: port=%d, cpu=%d, mask=0x%x, cause=0x%x\n",
+		pr_info("%s: port=%d, cpu=%d, mask=0x%x, cause=0x%x\n",
 			__func__, pp->port, smp_processor_id(),
 			mvPp2RdReg(MV_PP2_ISR_RX_TX_MASK_REG(MV_PPV2_PORT_PHYS(pp->port))),
 			mvPp2GbeIsrCauseRxTxGet(pp->port));
@@ -2747,10 +2747,7 @@ irqreturn_t mv_eth_isr(int irq, void *dev_id)
 	STAT_INFO(pp->stats.irq++);
 
 	/* Mask all interrupts for cpus in this group */
-	for_each_possible_cpu(cpu) {
-		if ((1 << cpu) & napi_group->cpu_mask)
-			mvPp2GbeCpuInterruptsDisable(pp->port, cpu);
-	}
+	mvPp2GbeCpuInterruptsDisable(pp->port, napi_group->cpu_mask);
 
 	/* Verify that the device not already on the polling list */
 	if (napi_schedule_prep(napi)) {
@@ -2759,8 +2756,9 @@ irqreturn_t mv_eth_isr(int irq, void *dev_id)
 	} else {
 		STAT_INFO(pp->stats.irq_err++);
 #ifdef CONFIG_MV_ETH_DEBUG_CODE
-		printk(KERN_ERR "mv_eth_isr ERROR: port=%d, cpu=%d\n", pp->port, smp_processor_id());
-#endif /* CONFIG_MV_ETH_DEBUG_CODE */
+		pr_err("mv_eth_isr ERROR: port=%d, cpu=%d, napi group id=%d, napi cpu_mask=0x%x\n",
+				pp->port, smp_processor_id(), napi_group->id, napi_group->cpu_mask);
+#endif
 	}
 
 	return IRQ_HANDLED;
@@ -2858,7 +2856,7 @@ void mv_eth_link_event(struct eth_port *pp, int print)
 /***********************************************************************************************/
 int mv_eth_poll(struct napi_struct *napi, int budget)
 {
-	int rx_done = 0, cpu;
+	int rx_done = 0;
 	struct napi_group_ctrl *napi_group;
 	MV_U32 causeRxTx;
 	struct eth_port *pp = MV_ETH_PRIV(napi->dev);
@@ -2955,8 +2953,6 @@ int mv_eth_poll(struct napi_struct *napi, int budget)
 #endif /* CONFIG_MV_ETH_DEBUG_CODE */
 
 	if (budget > 0) {
-		unsigned long flags;
-
 		causeRxTx = 0;
 
 		napi_complete(napi);
@@ -2967,15 +2963,8 @@ int mv_eth_poll(struct napi_struct *napi, int budget)
 		if (pp->rx_adaptive_coal_cfg)
 			mv_eth_adaptive_rx_update(pp);
 
-		/* TODO: do we need irq_save */
-		local_irq_save(flags);
 		/* Enable interrupts for all cpus belong to this group */
-		for_each_possible_cpu(cpu) {
-			if (!((1 << cpu) & napi_group->cpu_mask))
-				continue;
-			mvPp2GbeCpuInterruptsEnable(pp->port, cpu);
-		}
-		local_irq_restore(flags);
+		mvPp2GbeCpuInterruptsEnable(pp->port, napi_group->cpu_mask);
 	}
 	napi_group->cause_rx_tx = causeRxTx;
 
diff --git a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.c b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.c
index 90e0977..ebdb423 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.c
+++ b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.c
@@ -246,8 +246,7 @@ MV_STATUS mvPp2DefaultsSet(int port)
 		}
 
 	/* At default, mask all interrupts to all cpus */
-	for (i = 0; i < mvPp2HalData.maxCPUs; i++)
-		mvPp2GbeCpuInterruptsDisable(port, i);
+	mvPp2GbeCpuInterruptsDisable(port, (1 << mvPp2HalData.maxCPUs) - 1);
 
 	return MV_OK;
 
@@ -1127,19 +1126,19 @@ MV_STATUS mvPp2RxFifoInit(int portNum)
 /*******************************/
 /*       Interrupts API        */
 /*******************************/
-MV_VOID mvPp2GbeCpuInterruptsDisable(int port, int cpu)
+MV_VOID mvPp2GbeCpuInterruptsDisable(int port, int cpuMask)
 {
-	if ((cpu < 0) || mvPp2PortCheck(port))
+	if (mvPp2PortCheck(port))
 		return;
 
-	mvPp2WrReg(MV_PP2_ISR_ENABLE_REG(port), MV_PP2_ISR_DISABLE_INTERRUPT(cpu));
+	mvPp2WrReg(MV_PP2_ISR_ENABLE_REG(port), MV_PP2_ISR_DISABLE_INTERRUPT(cpuMask));
 }
 
-MV_VOID mvPp2GbeCpuInterruptsEnable(int port, int cpu)
+MV_VOID mvPp2GbeCpuInterruptsEnable(int port, int cpuMask)
 {
-	if ((cpu < 0) || mvPp2PortCheck(port))
+	if (mvPp2PortCheck(port))
 		return;
-	mvPp2WrReg(MV_PP2_ISR_ENABLE_REG(port), MV_PP2_ISR_ENABLE_INTERRUPT(cpu));
+	mvPp2WrReg(MV_PP2_ISR_ENABLE_REG(port), MV_PP2_ISR_ENABLE_INTERRUPT(cpuMask));
 }
 
 MV_STATUS mvPp2RxqTimeCoalSet(int port, int rxq, MV_U32 uSec)
diff --git a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.h b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.h
index 2ceec92..f610e5f 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.h
+++ b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2Gbe.h
@@ -596,8 +596,8 @@ MV_STATUS mvPp2TxqWrrPrioSet(int port, int txp, int txq, int weight);
 /*****************************/
 /*      Interrupts API       */
 /*****************************/
-MV_VOID		mvPp2GbeCpuInterruptsDisable(int port, int cpu);
-MV_VOID		mvPp2GbeCpuInterruptsEnable(int port, int cpu);
+MV_VOID		mvPp2GbeCpuInterruptsDisable(int port, int cpuMask);
+MV_VOID		mvPp2GbeCpuInterruptsEnable(int port, int cpuMask);
 MV_STATUS	mvPp2RxqTimeCoalSet(int port, int rxq, MV_U32 uSec);
 unsigned int	mvPp2RxqTimeCoalGet(int port, int rxq);
 MV_STATUS	mvPp2GbeIsrRxqGroup(int port, int rxqNum);
diff --git a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2GbeRegs.h b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2GbeRegs.h
index b9e799e..f477894 100644
--- a/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2GbeRegs.h
+++ b/arch/arm/plat-armada/mv_hal/pp2/gbe/mvPp2GbeRegs.h
@@ -279,11 +279,12 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #define MV_PP2_ISR_ENABLE_INTERRUPT_OFFS	0
 #define MV_PP2_ISR_ENABLE_INTERRUPT_MASK	0xFFFF
-#define MV_PP2_ISR_ENABLE_INTERRUPT(cpu)	((1 << cpu) & MV_PP2_ISR_ENABLE_INTERRUPT_MASK)
+#define MV_PP2_ISR_ENABLE_INTERRUPT(cpuMask)	(((cpuMask) << MV_PP2_ISR_ENABLE_INTERRUPT_OFFS)\
+							& MV_PP2_ISR_ENABLE_INTERRUPT_MASK)
 
 #define MV_PP2_ISR_DISABLE_INTERRUPT_OFFS	16
 #define MV_PP2_ISR_DISABLE_INTERRUPT_MASK	(0xFFFF << MV_PP2_ISR_DISABLE_INTERRUPT_OFFS)
-#define MV_PP2_ISR_DISABLE_INTERRUPT(cpu)	(((1 << cpu) << MV_PP2_ISR_DISABLE_INTERRUPT_OFFS)\
+#define MV_PP2_ISR_DISABLE_INTERRUPT(cpuMask)	(((cpuMask) << MV_PP2_ISR_DISABLE_INTERRUPT_OFFS)\
 							& MV_PP2_ISR_DISABLE_INTERRUPT_MASK)
 
 
-- 
1.7.5.4

