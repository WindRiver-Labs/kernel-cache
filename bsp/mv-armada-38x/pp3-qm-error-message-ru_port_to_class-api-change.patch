From 8d88004470a020eb4554e0eec70984b085ca62a0 Mon Sep 17 00:00:00 2001
From: Dovrat <dovrat@marvell.com>
Date: Sun, 13 Apr 2014 10:39:09 +0300
Subject: [PATCH 1557/1825] pp3: qm: error message, ru_port_to_class api
 change

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit c1de612c0453a2ddd7916c3e71e443e4c945374c

Change-Id: If255da9677e97140a62a78d8e82e83e31a8deebb
Signed-off-by: Dovrat <dovrat@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/7114
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Eliezer Ben Zeev <eliezerb@marvell.com>
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Tested-by: Dmitri Epshtein <dima@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 drivers/net/ethernet/marvell/pp3/qm/mv_qm.c |  160 ++++++++++++++++++---------
 drivers/net/ethernet/marvell/pp3/qm/mv_qm.h |   19 +--
 2 files changed, 117 insertions(+), 62 deletions(-)

diff --git a/drivers/net/ethernet/marvell/pp3/qm/mv_qm.c b/drivers/net/ethernet/marvell/pp3/qm/mv_qm.c
index a812b53..5489270 100644
--- a/drivers/net/ethernet/marvell/pp3/qm/mv_qm.c
+++ b/drivers/net/ethernet/marvell/pp3/qm/mv_qm.c
@@ -284,11 +284,15 @@ int qm_dma_queue_memory_type_set(u32 queue, u32 memory_type)
 	struct dma_q_memory_allocation        reg_q_memory_allocation;
 	u32 reg_base_address, reg_size, reg_offset;
 
-	if ((queue       <       QM_QUEUE_MIN) || (queue       >       QM_QUEUE_MAX))
+	if ((queue       <       QM_QUEUE_MIN) || (queue       >       QM_QUEUE_MAX)) {
+		pr_err("queue %d is out of range %d .. %d\n", queue, QM_QUEUE_MIN, QM_QUEUE_MAX);
 		return rc;
-	if ((memory_type < QM_MEMORY_TYPE_MIN) || (memory_type > QM_MEMORY_TYPE_MAX))
+	}
+	if ((memory_type < QM_MEMORY_TYPE_MIN) || (memory_type > QM_MEMORY_TYPE_MAX)) {
+		pr_err("memory type %d is out of range %d .. %d\n",
+			memory_type, QM_MEMORY_TYPE_MIN, QM_MEMORY_TYPE_MAX);
 		return rc;
-
+	}
 	reg_base_address =      qm.dma.Q_memory_allocation;
 	reg_size   =   qm_reg_size.dma.Q_memory_allocation;
 	reg_offset = qm_reg_offset.dma.Q_memory_allocation * (queue/32);
@@ -356,44 +360,70 @@ int qm_default_set(void)
 	int rc = !OK;
 
 	rc = qm_ru_port_to_class_def_set();
-	if (rc != OK)
+	if (rc != OK) {
+		pr_err("setting ru_port_to_class failed\n");
 		return rc;
+	}
 	rc = qm_ru_pool_sid_number_def_set();
-	if (rc != OK)
+	if (rc != OK) {
+		pr_err("setting ru_pool_sid_number failed\n");
 		return rc;
+	}
 	rc = qm_dqf_port_data_fifo_def_set();
-	if (rc != OK)
+	if (rc != OK) {
+		pr_err("setting dqf_port_data_fifo failed\n");
 		return rc;
+	}
 	rc = qm_dqf_port_credit_thr_def_set();
-	if (rc != OK)
+	if (rc != OK) {
+		pr_err("setting dqf_port_credit_thr failed\n");
 		return rc;
+	}
 	rc = qm_dqf_port_ppc_map_def_set();
-	if (rc != OK)
+	if (rc != OK) {
+		pr_err("setting dqf_port_ppc_map failed\n");
 		return rc;
+	}
 	rc = qm_dma_qos_attr_def_set();
-	if (rc != OK)
+	if (rc != OK) {
+		pr_err("setting dma_qos_attr failed\n");
 		return rc;
+	}
 	rc = qm_dma_domain_attr_def_set();
-	if (rc != OK)
+	if (rc != OK) {
+		pr_err("setting dma_domain_attr failed\n");
 		return rc;
+	}
 	rc = qm_dma_cache_attr_def_set();
-	if (rc != OK)
+	if (rc != OK) {
+		pr_err("setting dma_cache_attr failed\n");
 		return rc;
+	}
 	rc = qm_pfe_qos_attr_def_set();
-	if (rc != OK)
+	if (rc != OK) {
+		pr_err("setting pfe_qos_attr failed\n");
 		return rc;
+	}
 	rc = qm_pfe_domain_attr_def_set();
-	if (rc != OK)
+	if (rc != OK) {
+		pr_err("setting pfe_domain_attr failed\n");
 		return rc;
+	}
 	rc = qm_pfe_cache_attr_def_set();
-	if (rc != OK)
+	if (rc != OK) {
+		pr_err("setting pfe_cache_attr failed\n");
 		return rc;
+	}
 	rc = qm_ql_thr_def_set();
-	if (rc != OK)
+	if (rc != OK) {
+		pr_err("setting ql_thr failed\n");
 		return rc;
+	}
 	rc = qm_ql_q_profile_def_set();
-	if (rc != OK)
+	if (rc != OK) {
+		pr_err("setting ql_q_profile failed\n");
 		return rc;
+	}
 
 	return rc;
 }
@@ -416,10 +446,18 @@ int qm_ru_pool_sid_number_set(u32 pool0_sid_num, u32 pool1_sid_num)
 	struct reorder_ru_pool         reg_ru_pool;
 	u32 reg_base_address, reg_size, reg_offset;
 
-	if ((pool0_sid_num < QM_POOL0_SID_NUM_MIN) || (pool0_sid_num > QM_POOL0_SID_NUM_MAX))
+	if ((pool0_sid_num < QM_POOL0_SID_NUM_MIN) || (pool0_sid_num > QM_POOL0_SID_NUM_MAX)) {
+		pr_err("pool 0 eorder number of SID is 4096\n");
+		return rc;
+	}
+	if ((pool1_sid_num < QM_POOL1_SID_NUM_MIN) || (pool1_sid_num > QM_POOL1_SID_NUM_MAX)) {
+		pr_err("pool 1 reorder number of SID is 4096\n");
 		return rc;
-	if ((pool1_sid_num < QM_POOL1_SID_NUM_MIN) || (pool1_sid_num > QM_POOL1_SID_NUM_MAX))
+	}
+	if ((pool0_sid_num + pool1_sid_num > QM_POOL1_SID_NUM_MAX)) {
+		pr_err("pool 0&1 reorder number of SID is not larger than 4096\n");
 		return rc;
+	}
 
 	reg_base_address =      qm.reorder.ru_pool;
 	reg_size   =   qm_reg_size.reorder.ru_pool;
@@ -444,70 +482,92 @@ int qm_ru_pool_sid_number_set(u32 pool0_sid_num, u32 pool1_sid_num)
 	rc = qm_register_write(reg_base_address, reg_offset, reg_size, (u32 *)&reg_ru_pool);
 	return rc;
 }
+/*
+ * port_class holds class values which are in the range 0 to 63.
+ * Default values are:
+ * for input port  0 to  6 (cMac and eMac) class is 1 to 7 (respectively).
+ * for input poer 7 class 0 (not valid)
+ * For input port  8 to 71 (hMac) class is 8.
+ * For Input port 72 to 89  (PPC) class is 9.
+ * Port input 90 to 287 are not used so class is 0.
+ * Classes 10 to 63 are left unused for future use.
+ * port_pool holds pool  values which are either 0 or 1 (default values are pool 0 for all input ports)
+ */
 
 int qm_ru_port_to_class_def_set(void)
 {
 	int rc = !OK;
-	u32 port_class_arr, port_pool_arr, arrays_size, input_port;
+	u32 port_class, port_pool, input_port;
 
-	port_pool_arr  = QM_PORT_ARR_DEF;
-	arrays_size    = QM_ARRAYS_SIZE_DEF;
+	port_pool  = QM_INPUT_PORT_POOL_DEF;
 
 	/* cMac and eMac */
 	for (input_port = QM_INPUT_PORT_CMAC_EMAC_MIN; input_port <= QM_INPUT_PORT_CMAC_EMAC_MAX; input_port++) {
-		port_class_arr = QM_CLASS_ARR_CMAC_EMAC_DEF;
-		rc = qm_ru_port_to_class_set(&port_class_arr, &port_pool_arr, input_port);
-		if (rc != OK)
+		port_class = QM_CLASS_ARR_CMAC_EMAC_DEF(input_port);
+		rc = qm_ru_port_to_class_set(input_port, port_class, port_pool);
+		if (rc != OK) {
+			pr_err("setting class %d and pool %d to input port %d failed\n",
+				port_class, port_pool, input_port);
 			return rc;
+		}
 	}
 
 	/* hMac */
 	for (input_port = QM_INPUT_PORT_HMAC_MIN; input_port <= QM_INPUT_PORT_HMAC_MAX; input_port++) {
-		port_class_arr = QM_CLASS_ARR_HMAC_DEF;
-		rc = qm_ru_port_to_class_set(&port_class_arr, &port_pool_arr, input_port);
-		if (rc != OK)
+		port_class = QM_CLASS_ARR_HMAC_DEF;
+		rc = qm_ru_port_to_class_set(input_port, port_class, port_pool);
+		if (rc != OK) {
+			pr_err("setting class %d and pool %d to input port %d failed\n",
+				port_class, port_pool, input_port);
 			return rc;
+		}
 	}
 
 	/* PPC */
 	for (input_port = QM_INPUT_PORT_PPC_MIN; input_port <= QM_INPUT_PORT_PPC_MAX; input_port++) {
-		port_class_arr = QM_CLASS_ARR_PPC_DEF;
-		rc = qm_ru_port_to_class_set(&port_class_arr, &port_pool_arr, input_port);
-		if (rc != OK)
+		port_class = QM_CLASS_ARR_PPC_DEF;
+		rc = qm_ru_port_to_class_set(input_port, port_class, port_pool);
+		if (rc != OK) {
+			pr_err("setting class %d and pool %d to input port %d failed\n",
+				port_class, port_pool, input_port);
 			return rc;
+		}
+	}
+
+	/* Invlaid */
+	for (input_port = QM_INPUT_PORT_PPC_MAX+1; input_port <= QM_INPUT_PORT_MAX; input_port++) {
+		port_class = 0;
+		rc = qm_ru_port_to_class_set(input_port, port_class, port_pool);
+		if (rc != OK) {
+			pr_err("setting class %d and pool %d to input port %d failed\n",
+				port_class, port_pool, input_port);
+			return rc;
+		}
 	}
 
 	rc = OK;
 	return rc;
 }
-/*
-port_class_arr holds class values which are in the range 0 to 63.
-Default values are:
-for input port  0 to  7 (cMac and eMac) class is 0 to 7 (respectively).
-For input port  8 to 71 (hMac) class is 8.
-For Input port 72 to 89  (PPC) class is 9.
-Port input 90 to 287 are not used so disregard their value.
-Classes 10 to 63 are left unused for future use.
-
-port_pool_arr holds pool  values which are either 0 or 1 (default values are pool 0 for all input ports)
-
-arrays_size holds the size of each array. Size can be a value from 90
-(current implementation to 288 (since input port is 0 to 287)
-*/
 
-int qm_ru_port_to_class_set(u32 *port_class_arr, u32 *port_pool_arr, u32 input_port)
+int qm_ru_port_to_class_set(u32 input_port, u32 port_class, u32 port_pool)
 {
 	int rc = -QM_INPUT_NOT_IN_RANGE;
 /*	struct reorder_ru_pool       reg_ru_pool;*/
 	u32 reg_base_address, reg_size, reg_offset;
 	struct reorder_ru_port2class reg_ru_port2class;
 
-	if ((*port_class_arr < QM_CLASS_ARR_MIN)   || (*port_class_arr >   QM_CLASS_ARR_MAX))
+	if ((port_class < QM_CLASS_ARR_MIN)   || (port_class > QM_CLASS_ARR_MAX)) {
+		pr_err("port class %d is not in range %d .. %d\n", port_class, QM_CLASS_ARR_MIN, QM_CLASS_ARR_MAX);
 		return rc;
-	if ((*port_pool_arr  < QM_PORT_ARR_MIN)    || (*port_pool_arr  >    QM_PORT_ARR_MAX))
+	}
+	if ((port_pool  < QM_PORT_ARR_MIN)    || (port_pool  > QM_PORT_ARR_MAX)) {
+		pr_err("port pool %d is not in range %d .. %d\n", port_pool, QM_PORT_ARR_MIN, QM_PORT_ARR_MAX);
 		return rc;
-	if ((input_port      < QM_ARRAYS_SIZE_MIN) || (input_port      > QM_ARRAYS_SIZE_MAX))
+	}
+	if ((input_port < QM_INPUT_PORT_MIN) || (input_port > QM_INPUT_PORT_MAX)) {
+		pr_err("input port %d is not in range %d .. %d\n", input_port, QM_INPUT_PORT_MIN, QM_INPUT_PORT_MAX);
 		return rc;
+	}
 
 	reg_base_address =      qm.reorder.ru_port2class;
 	reg_size   =   qm_reg_size.reorder.ru_port2class;
@@ -516,8 +576,8 @@ int qm_ru_port_to_class_set(u32 *port_class_arr, u32 *port_pool_arr, u32 input_p
 	rc = qm_register_read(reg_base_address, reg_offset, reg_size, (u32 *)&reg_ru_port2class);
 	if (rc != OK)
 		return rc;
-	reg_ru_port2class.ru_class = *port_class_arr;
-	reg_ru_port2class.ru_pool  = *port_pool_arr;
+	reg_ru_port2class.ru_class = port_class;
+	reg_ru_port2class.ru_pool  = port_pool;
 	rc = qm_register_write(reg_base_address, reg_offset, reg_size, (u32 *)&reg_ru_port2class);
 	return rc;
 }
diff --git a/drivers/net/ethernet/marvell/pp3/qm/mv_qm.h b/drivers/net/ethernet/marvell/pp3/qm/mv_qm.h
index e277566..13e640a 100644
--- a/drivers/net/ethernet/marvell/pp3/qm/mv_qm.h
+++ b/drivers/net/ethernet/marvell/pp3/qm/mv_qm.h
@@ -103,11 +103,10 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define QM_POOL0_SID_NUM_DEF	QM_POOL0_SID_NUM_MAX
 #define QM_POOL1_SID_NUM_DEF	QM_POOL1_SID_NUM_MIN
 
-#define QM_CLASS_ARR_CMAC_EMAC_DEF	input_port	/*    0 */
+#define QM_CLASS_ARR_CMAC_EMAC_DEF(_input_port)		(((_input_port) == 7) ? 0 : (input_port+1))
 #define QM_CLASS_ARR_HMAC_DEF		0x00000008	/*    8 */
 #define QM_CLASS_ARR_PPC_DEF		0x00000009	/*    9 */
-#define QM_PORT_ARR_DEF				         0	/*    0 */
-#define QM_ARRAYS_SIZE_DEF			0x0000005A	/*   90 */
+#define QM_INPUT_PORT_POOL_DEF		         0	/*    0 */
 
 #define QM_PORT_DEPTH_ARR_PPC0_DEF		    (2 * QM_SIZE_OF_PORT_DEPTH_ARR_PPC_IN_BYTES)	/* 2*144B */
 #define QM_PORT_DEPTH_ARR_PPC1_DEF		    (1 * QM_SIZE_OF_PORT_DEPTH_ARR_PPC_IN_BYTES)	/* 1*144B */
@@ -205,8 +204,8 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define QM_CLASS_ARR_MAX		0x00000009	/*    9 */
 #define QM_PORT_ARR_MIN			         0	/*    0 */
 #define QM_PORT_ARR_MAX			0x00000001	/*    1 */
-#define QM_ARRAYS_SIZE_MIN		0x0000005A	/*   90 */
-#define QM_ARRAYS_SIZE_MAX		0x00000120	/*  288 */
+#define QM_INPUT_PORT_MIN		0x00000000	/*    0 */
+#define QM_INPUT_PORT_MAX		0x0000011F	/*  287 */
 
 #define QM_INPUT_PORT_CMAC_EMAC_MIN	         0	/*    0 */
 #define QM_INPUT_PORT_CMAC_EMAC_MAX	0x00000007	/*    7 */
@@ -434,13 +433,9 @@ int qm_ru_port_to_class_def_set(void);
  *		0 - success
  */
 int qm_ru_port_to_class_set(
-				u32 *port_class_arr, /* class number in reorder unit. 0 to 63 */
-				u32 *port_pool_arr, /* holds pool  values which are either 0 or 1 */
-				u32 input_port); /* input port that arrive with the packet. 0 to 287 */
-/*
-				u32 reorder_class, / * class number in reorder unit. 0 to 63 * /
-				u32 input_port, / * input port that arrive with the packet. 0 to 287 * /
-*/
+				u32 input_port, /* input port that arrive with the packet. 0 to 287 */
+				u32 port_class, /* class number in reorder unit. 0 to 63 */
+				u32 port_pool); /* holds pool  values which are either 0 or 1 */
 
 /**
  *  Configure DQF fifo base and depth thresholds with default values
-- 
1.7.5.4

