From c2983791f5f579ca59dd4e26823abbb1a35f3daa Mon Sep 17 00:00:00 2001
From: Kosta Zertsekel <konszert@marvell.com>
Date: Mon, 11 Mar 2013 03:39:25 +0200
Subject: [PATCH 0460/1825] ALP: fix boot on FPGA board

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit eda2f37e6dde3511dd3f784b3cf3107aaf24e76f

UP - stable boot.
SMP - stable boot without L2 Cache.

Signed-off-by: Kosta Zertsekel <konszert@marvell.com>
Change-Id: I6d32b2f0f5dbf1e3fe287ac6bf74360d90dd40ef
Reviewed-on: http://vgitil04.il.marvell.com:8080/1236
Reviewed-by: Eran Ben-Avi <benavi@marvell.com>
Tested-by: Eran Ben-Avi <benavi@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/Kconfig                                  |    9 +-
 arch/arm/configs/avanta_lp_fpga_defconfig         |   41 +--
 arch/arm/kernel/Makefile                          |    2 +-
 arch/arm/kernel/setup.c                           |    2 +-
 arch/arm/kernel/smp_twd.c                         |    6 +-
 arch/arm/mach-armada370/core.c                    |    3 +-
 arch/arm/mach-armadaxp/time.c                     |    2 +-
 arch/arm/mach-avantalp/Makefile                   |    8 +-
 arch/arm/mach-avantalp/clock.c                    |   50 ---
 arch/arm/mach-avantalp/clock.h                    |    5 -
 arch/arm/mach-avantalp/config/mvRules.mk          |    2 +-
 arch/arm/mach-avantalp/config/mvSysHwConfig.h     |    5 +
 arch/arm/mach-avantalp/core.c                     |   15 +-
 arch/arm/mach-avantalp/include/mach/entry-macro.S |    1 +
 arch/arm/mach-avantalp/include/mach/irqs.h        |    4 +-
 arch/arm/mach-avantalp/localtimer.c               |    2 +
 arch/arm/mach-avantalp/platsmp.c                  |    1 +
 arch/arm/mach-avantalp/sysmap.c                   |    2 -
 arch/arm/mach-avantalp/time.c                     |  441 +++++++--------------
 arch/arm/plat-armada/Kconfig                      |   43 ++-
 drivers/tty/serial/8250/8250_dw.c                 |   14 +-
 drivers/tty/serial/8250/Kconfig                   |    2 +-
 22 files changed, 224 insertions(+), 436 deletions(-)
 delete mode 100644 arch/arm/mach-avantalp/clock.c
 delete mode 100644 arch/arm/mach-avantalp/clock.h

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index d908bea..8c0b39e 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -680,8 +680,8 @@ config ARCH_ORION5X
 	  Orion-2 (5281), Orion-1-90 (6183).
 
 config ARCH_AVANTA_LP
-bool "Marvell Avanta LP"
-#	select PCI
+	bool "Marvell Avanta LP"
+	select PCI
 #	select ARCH_HAS_CPUFREQ
 #	select ARCH_SUPPORTS_MSI
 	select CPU_V7
@@ -692,19 +692,19 @@ bool "Marvell Avanta LP"
 	select PLAT_ARMADA
 	select HAVE_REGS_AND_STACK_ACCESS_API
 	select COMMON_CLKDEV
+	select HAVE_SMP
 	select CLKSRC_MMIO
 	select CLKDEV_LOOKUP
 	select NEED_MACH_IO_H
 	select NEED_MACH_MEMORY_H
 	select DMABOUNCE
+#	select CACHE_L2X0
 	select MIGHT_HAVE_CACHE_L2X0
 #	bool "ARM Ltd. Versatile Express family"
 #	select ARCH_WANT_OPTIONAL_GPIOLIB
 #	select ARM_AMBA
 #	select ARM_TIMER_SP804
-#	select CLKDEV_LOOKUP
 #	select HAVE_MACH_CLKDEV
-#	select GENERIC_CLOCKEVENTS
 #	select HAVE_CLK
 #	select HAVE_PATA_PLATFORM
 #	select ICST
@@ -1682,7 +1682,6 @@ config ARM_ARCH_TIMER
 
 config HAVE_ARM_TWD
 	bool
-	depends on SMP
 	select TICK_ONESHOT
 	help
 	  This options enables support for the ARM timer and watchdog unit
diff --git a/arch/arm/configs/avanta_lp_fpga_defconfig b/arch/arm/configs/avanta_lp_fpga_defconfig
index 38a29ff..6819ee8 100644
--- a/arch/arm/configs/avanta_lp_fpga_defconfig
+++ b/arch/arm/configs/avanta_lp_fpga_defconfig
@@ -11,41 +11,21 @@ CONFIG_KPROBES=y
 CONFIG_MODULES=y
 CONFIG_MODULE_UNLOAD=y
 # CONFIG_BLK_DEV_BSG is not set
+CONFIG_PARTITION_ADVANCED=y
 CONFIG_ARCH_AVANTA_LP=y
-CONFIG_AVANTA_LP_REV_XX=y
-CONFIG_MV_INCLUDE_PCI=y
+# CONFIG_MV_INCLUDE_CESA is not set
+# CONFIG_MV_INCLUDE_TDM is not set
+# CONFIG_MV_INCLUDE_SPI is not set
+# CONFIG_MV_INCLUDE_SWITCH is not set
+# CONFIG_MV_INCLUDE_PEX is not set
+# CONFIG_MV_INCLUDE_USB is not set
 # CONFIG_MV_INCLUDE_XOR is not set
 # CONFIG_MV_INCLUDE_NFC is not set
 # CONFIG_MV_INCLUDE_LEGACY_NAND is not set
-# CONFIG_MV_INCLUDE_SWITCH is not set
-# CONFIG_MV_INCLUDE_SFLASH_MTD is not set
-CONFIG_MV_ETH_NETA=y
-CONFIG_MV_ETH_PORTS_NUM=4
-CONFIG_MV_ETH_RXQ=8
-CONFIG_MV_ETH_TXQ=8
-CONFIG_NET_SKB_HEADROOM=96
-CONFIG_MV_ETH_NFP=y
-CONFIG_MV_ETH_BM_PORT_0_SHORT_BUF_NUM=4096
-CONFIG_MV_ETH_BM_PORT_1_SHORT_BUF_NUM=4096
-CONFIG_MV_ETH_BM_PORT_2_SHORT_BUF_NUM=4096
-# CONFIG_MV_ETH_PNC is not set
-CONFIG_MV_ETH_GRO_DEF=y
-CONFIG_MV_ETH_TSO_DEF=y
-# CONFIG_MV_ETH_STAT_INF is not set
-CONFIG_MV_ETH_RX_COAL_PKTS=64
-CONFIG_MV_ETH_RX_COAL_USEC=200
-CONFIG_MV_ETH_RX_DESC_PREFETCH=y
-CONFIG_MV_ETH_RX_PKT_PREFETCH=y
-CONFIG_MV_ETH_RX_POLL_WEIGHT=128
-# CONFIG_MV_ETH_REDUCE_BURST_SIZE_WA is not set
-# CONFIG_SWP_EMULATE is not set
-# CONFIG_SHEEVA_ERRATA_ARM_CPU_5980 is not set
-# CONFIG_SHEEVA_ERRATA_ARM_CPU_6043 is not set
-# CONFIG_SHEEVA_ERRATA_ARM_CPU_6075 is not set
-# CONFIG_SHEEVA_ERRATA_ARM_CPU_6076 is not set
-# CONFIG_SHEEVA_ERRATA_ARM_CPU_6136 is not set
+# CONFIG_MV_INCLUDE_INTEG_SATA is not set
+# CONFIG_MV_INCLUDE_NOR is not set
+# CONFIG_MV_INCLUDE_SDIO is not set
 CONFIG_PCI_DEBUG=y
-CONFIG_SMP=y
 CONFIG_AEABI=y
 CONFIG_UACCESS_WITH_MEMCPY=y
 CONFIG_ZBOOT_ROM_TEXT=0x0
@@ -162,7 +142,6 @@ CONFIG_JFFS2_FS=y
 CONFIG_NFS_FS=y
 CONFIG_NFS_V3=y
 CONFIG_ROOT_NFS=y
-CONFIG_PARTITION_ADVANCED=y
 CONFIG_NLS_CODEPAGE_437=y
 CONFIG_NLS_CODEPAGE_850=y
 CONFIG_NLS_ISO8859_1=y
diff --git a/arch/arm/kernel/Makefile b/arch/arm/kernel/Makefile
index eef62a8..8de8eb2 100644
--- a/arch/arm/kernel/Makefile
+++ b/arch/arm/kernel/Makefile
@@ -37,7 +37,7 @@ obj-$(CONFIG_PCI)		+= bios32.o isa.o
 obj-$(CONFIG_ARM_CPU_SUSPEND)	+= sleep.o suspend.o
 obj-$(CONFIG_SMP)		+= smp.o smp_tlb.o
 obj-$(CONFIG_HAVE_ARM_SCU)	+= smp_scu.o
-obj-y				+= smp_twd.o
+obj-$(CONFIG_HAVE_ARM_TWD)	+= smp_twd.o
 obj-$(CONFIG_ARM_ARCH_TIMER)	+= arch_timer.o
 obj-$(CONFIG_DYNAMIC_FTRACE)	+= ftrace.o insn.o
 obj-$(CONFIG_FUNCTION_GRAPH_TRACER)	+= ftrace.o insn.o
diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index 797639e..d870e05 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -927,7 +927,7 @@ static struct machine_desc * __init setup_machine_tags(unsigned int nr)
 	 * If we have the old style parameters, convert them to
 	 * a tag list.
 	 */
-if (read_tag(tags->hdr.tag) != ATAG_CORE)
+	if (read_tag(tags->hdr.tag) != ATAG_CORE)
 		convert_to_tag_list(tags);
 #endif
 
diff --git a/arch/arm/kernel/smp_twd.c b/arch/arm/kernel/smp_twd.c
index bf6a062..21cb386 100644
--- a/arch/arm/kernel/smp_twd.c
+++ b/arch/arm/kernel/smp_twd.c
@@ -227,7 +227,7 @@ static struct clk *twd_get_clock(void)
 /*
  * Setup the local clock events for a CPU.
  */
-static int __cpuinit twd_timer_setup(struct clock_event_device *clk)
+int __cpuinit twd_timer_setup(struct clock_event_device *clk)
 {
 	struct clock_event_device **this_cpu_clk;
 	int cpu = smp_processor_id();
@@ -258,7 +258,7 @@ static int __cpuinit twd_timer_setup(struct clock_event_device *clk)
 		 * need to calibrate the rate instead.
 		 */
 		if (!IS_ERR_OR_NULL(twd_clk))
-			twd_timer_rate = 12500000; /* clk_get_rate(twd_clk); */
+			twd_timer_rate = clk_get_rate(twd_clk);
 		else
 			twd_calibrate_rate();
 
@@ -310,9 +310,11 @@ static int __init twd_local_timer_common_register(void)
 		goto out_free;
 	}
 
+#ifdef CONFIG_SMP
 	err = local_timer_register(&twd_lt_ops);
 	if (err)
 		goto out_irq;
+#endif
 
 	return 0;
 
diff --git a/arch/arm/mach-armada370/core.c b/arch/arm/mach-armada370/core.c
index df06d16..c51af27 100644
--- a/arch/arm/mach-armada370/core.c
+++ b/arch/arm/mach-armada370/core.c
@@ -847,7 +847,8 @@ void print_board_info(void)
 #endif
 	printk("\n  LSP version: %s\n", LSP_VERSION);
 	printk("\n\n");
-	printk(" Detected Tclk %d, SysClk %d, FabricClk %d\n",mvTclk, mvSysclk, mvCpuL2ClkGet());
+	printk(" Detected Tclk %d, SysClk %d, FabricClk %d\n",
+	       mvTclk, mvSysclk, mvCpuL2ClkGet());
 }
 
 #ifdef	CONFIG_AURORA_IO_CACHE_COHERENCY
diff --git a/arch/arm/mach-armadaxp/time.c b/arch/arm/mach-armadaxp/time.c
index 4486c86..8975159 100644
--- a/arch/arm/mach-armadaxp/time.c
+++ b/arch/arm/mach-armadaxp/time.c
@@ -417,7 +417,7 @@ static void __init axp_timer_init(void)
 	/* FPGA is hardcoded to 25Mhx and DSMP-A0 ref clock for the timers is 25MHz */
 	axp_time_init(25000000);
 #else
-	axp_time_init(mvCpuL2ClkGet());  /* DSMP-Z1 clock is taken from Fabric */
+	axp_time_init(mvCpuL2ClkGet());
 #endif
 }
 
diff --git a/arch/arm/mach-avantalp/Makefile b/arch/arm/mach-avantalp/Makefile
index 35c5f21..898113b 100644
--- a/arch/arm/mach-avantalp/Makefile
+++ b/arch/arm/mach-avantalp/Makefile
@@ -51,11 +51,11 @@ QD_OBJS		= $(HAL_QD_DIR)/src/driver/gtDrvConfig.o $(HAL_QD_DIR)/src/driver/gtDrv
 		  $(HAL_QD_DIR)/src/msapi/gtPIRL2.o $(HAL_QD_DIR)/src/msapi/gtCCPVT.o		\
 		  $(HAL_QD_DIR)/src/msapi/gtPCSCtrl.o $(HAL_QD_DIR)/src/msapi/gtBrgStu.o
 
-LSP_OBJS        = core.o irq.o time.o leds.o sysmap.o export.o clock.o
+LSP_OBJS        = core.o irq.o leds.o sysmap.o export.o time.o
 
-obj-y   				:=  avantalp.o
-avantalp-objs  				:=$(LSP_OBJS) $(COMMON_OBJS) $(OSSERVICES_OBJS) $(HAL_OBJS) 	\
-					  $(KW_FAM_OBJS)
+obj-y   				:= avantalp.o
+avantalp-objs  				:= $(LSP_OBJS) $(COMMON_OBJS) $(OSSERVICES_OBJS) $(HAL_OBJS) 	\
+					   $(KW_FAM_OBJS)
 
 avantalp-$(CONFIG_MV_INCLUDE_SDIO) 	+= $(HAL_SDMMC_DIR)/mvSdmmcAddrDec.o
 avantalp-$(CONFIG_MV_INCLUDE_XOR) 	+= $(HAL_XOR_DIR)/mvXor.o $(HAL_XOR_DIR)/mvXorAddrDec.o		\
diff --git a/arch/arm/mach-avantalp/clock.c b/arch/arm/mach-avantalp/clock.c
deleted file mode 100644
index 15b04ae..0000000
--- a/arch/arm/mach-avantalp/clock.c
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- *  linux/arch/arm/mach-dove/clock.c
- */
-
-/* TODO: Implement the functions below...	*/
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/list.h>
-#include <linux/errno.h>
-#include <linux/err.h>
-#include <linux/string.h>
-#include <linux/clk.h>
-#include <linux/spinlock.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-
-#include <mach/hardware.h>
-
-#include "clock.h"
-
-int clk_enable(struct clk *clk)
-{
-	return 0;
-}
-EXPORT_SYMBOL(clk_enable);
-
-void clk_disable(struct clk *clk)
-{
-}
-EXPORT_SYMBOL(clk_disable);
-
-unsigned long clk_get_rate(struct clk *clk)
-{
-	return 0;
-}
-EXPORT_SYMBOL(clk_get_rate);
-
-
-void clks_register(struct clk *clks, size_t num)
-{
-}
-
-static int __init clk_init(void)
-{
-	/* TODO: Call clks_register with appropriate params. */
-	clks_register(NULL, 0);
-	return 0;
-}
-arch_initcall(clk_init);
diff --git a/arch/arm/mach-avantalp/clock.h b/arch/arm/mach-avantalp/clock.h
deleted file mode 100644
index 3fd3a3b..0000000
--- a/arch/arm/mach-avantalp/clock.h
+++ /dev/null
@@ -1,5 +0,0 @@
-struct clk {
-	unsigned int dummy;
-};
-
-void clks_register(struct clk *clks, size_t num);
diff --git a/arch/arm/mach-avantalp/config/mvRules.mk b/arch/arm/mach-avantalp/config/mvRules.mk
index 173e106..95fdde7 100644
--- a/arch/arm/mach-avantalp/config/mvRules.mk
+++ b/arch/arm/mach-avantalp/config/mvRules.mk
@@ -35,7 +35,7 @@ HAL_SATA_DIR      = $(HAL_DIR)/sata/CoreDriver/
 HAL_QD_DIR        = $(HAL_DIR)/qd-dsdt
 HAL_SFLASH_DIR    = $(HAL_DIR)/sflash
 HAL_CNTMR_DIR     = $(HAL_DIR)/cntmr
-HAL_DRAM_DIR      = $(HAL_DIR)/ddr2_3/
+HAL_DRAM_DIR      = $(HAL_DIR)/ddr2_3
 #HAL_DRAM_SPD_DIR  = $(HAL_DIR)/ddr2_3/spd
 HAL_GPP_DIR       = $(HAL_DIR)/gpp
 HAL_TWSI_DIR      = $(HAL_DIR)/twsi
diff --git a/arch/arm/mach-avantalp/config/mvSysHwConfig.h b/arch/arm/mach-avantalp/config/mvSysHwConfig.h
index b353a04..3280aba 100755
--- a/arch/arm/mach-avantalp/config/mvSysHwConfig.h
+++ b/arch/arm/mach-avantalp/config/mvSysHwConfig.h
@@ -31,6 +31,11 @@ disclaimer.
 #ifndef __INCmvSysHwConfigh
 #define __INCmvSysHwConfigh
 
+/* Glue between Linux .config and defines for shared code */
+#ifdef CONFIG_MACH_AVANTA_LP_FPGA
+#define MACH_AVANTA_LP_FPGA
+#endif
+
 #define CONFIG_MARVELL	1
 
 /* includes */
diff --git a/arch/arm/mach-avantalp/core.c b/arch/arm/mach-avantalp/core.c
index 60aa425..cd4c2b4 100755
--- a/arch/arm/mach-avantalp/core.c
+++ b/arch/arm/mach-avantalp/core.c
@@ -665,10 +665,14 @@ static void cpu_fabric_common_init(void)
 extern MV_TARGET_ATTRIB mvTargetDefaultsArray[];
 static void __init alp_fpga_init(void)
 {
-	/* Call Aurora/cpu special configurations */
+#if 1 /* kostaz: disabling l2+iocc init for SMP boot test */
 	cpu_fabric_common_init();
+#endif
 
 #if 0
+	/* Call Aurora/cpu special configurations */
+	cpu_fabric_common_init();
+
 	/* Select appropriate Board ID for Machine */
 	gBoardId = MV_BOARD_ID_AVANTA_LP_FPGA;
 	/* Bypass serdes reconfiguration since already done at bootloader */
@@ -722,14 +726,19 @@ static void __init alp_fpga_init(void)
 
 	serial_initialize(0);
 
-	if (mvCpuIfInit(mv_sys_map()))
+	if( mvCpuIfInit(mv_sys_map())) {
 		printk("Cpu Interface initialization failed.\n");
+		return;
 }
+}
+
+extern void __init alp_init_irq(void);
 
 MACHINE_START(AVANTA_LP_FPGA, "Marvell Avanta LP FPGA Board")
-	.atag_offset	= 0x00000100,
+	.atag_offset	= 0x100,
 	.map_io		= alp_map_io,
 	.init_irq	= alp_init_irq,
 	.timer		= &alp_timer,
+	.handle_irq	= gic_handle_irq,
 	.init_machine	= alp_fpga_init,
 MACHINE_END
diff --git a/arch/arm/mach-avantalp/include/mach/entry-macro.S b/arch/arm/mach-avantalp/include/mach/entry-macro.S
index ecd3952..9221579 100755
--- a/arch/arm/mach-avantalp/include/mach/entry-macro.S
+++ b/arch/arm/mach-avantalp/include/mach/entry-macro.S
@@ -8,6 +8,7 @@
  * warranty of any kind, whether express or implied.
  */
 
+#include <mach/hardware.h>
 #include <asm/hardware/entry-macro-gic.S>
 
 	.macro	disable_fiq
diff --git a/arch/arm/mach-avantalp/include/mach/irqs.h b/arch/arm/mach-avantalp/include/mach/irqs.h
index 6d90793..4906f3f 100644
--- a/arch/arm/mach-avantalp/include/mach/irqs.h
+++ b/arch/arm/mach-avantalp/include/mach/irqs.h
@@ -22,14 +22,14 @@
 #define IRQ_LOCALWDOG		30
 #define NR_IRQS			192
 
-#if 0
+#if 1
 #define IRQ_AURORA_IN_DRBL_LOW	0
 #define IRQ_AURORA_IN_DRBL_HIGH	1
 #define IRQ_AURORA_OUT_DRBL 	2
 #define IRQ_AURORA_MP		3
 #define IRQ_AURORA_SOC_ERROR	4
 #define IRQ_AURORA_TIMER0	5
-#define IRQ_LOCALTIMER 		IRQ_AURORA_TIMER0
+/* kostaz #define IRQ_LOCALTIMER 		IRQ_AURORA_TIMER0 */
 #define IRQ_AURORA_TIMER1	6
 #define IRQ_AURORA_WD		7
 #define IRQ_AURORA_GBE0_FIC	8
diff --git a/arch/arm/mach-avantalp/localtimer.c b/arch/arm/mach-avantalp/localtimer.c
index 0fb3961..d72786a 100644
--- a/arch/arm/mach-avantalp/localtimer.c
+++ b/arch/arm/mach-avantalp/localtimer.c
@@ -16,6 +16,8 @@
 #include <asm/localtimer.h>
 #include <mach/irqs.h>
 
+int __cpuinit twd_timer_setup(struct clock_event_device *clk);
+
 /*
  * Setup the local clock events for a CPU.
  */
diff --git a/arch/arm/mach-avantalp/platsmp.c b/arch/arm/mach-avantalp/platsmp.c
index ebe0343..cd4f350 100644
--- a/arch/arm/mach-avantalp/platsmp.c
+++ b/arch/arm/mach-avantalp/platsmp.c
@@ -11,6 +11,7 @@
 #include <linux/init.h>
 #include <linux/errno.h>
 #include <linux/smp.h>
+#include <asm/smp_plat.h>
 #include <linux/io.h>
 
 #include <asm/unified.h>
diff --git a/arch/arm/mach-avantalp/sysmap.c b/arch/arm/mach-avantalp/sysmap.c
index 7d44db8..ce18bba 100644
--- a/arch/arm/mach-avantalp/sysmap.c
+++ b/arch/arm/mach-avantalp/sysmap.c
@@ -14,7 +14,6 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
-
 #include "mvSysHwConfig.h"
 #include "ctrlEnv/sys/mvCpuIf.h"
 #include "boardEnv/mvBoardEnvLib.h"
@@ -97,7 +96,6 @@ u32 mv_crypto_virt_base_get(u8 chan)
 void __init alp_map_io(void)
 {
 	iotable_init(MEM_TABLE, ARRAY_SIZE(MEM_TABLE));
-	twd_base = INTER_REGS_BASE + A9_MPCORE_TWD;
 }
 
 static u32 mv_pci_mem_base[] =
diff --git a/arch/arm/mach-avantalp/time.c b/arch/arm/mach-avantalp/time.c
index 8204176..568ab89 100644
--- a/arch/arm/mach-avantalp/time.c
+++ b/arch/arm/mach-avantalp/time.c
@@ -6,9 +6,6 @@
  * This file is licensed under the terms of the GNU General Public
  * License version 2.  This program is licensed "as is" without any
  * warranty of any kind, whether express or implied.
- *
- * Timer 0 is used as free-running clocksource, while timer 1 is
- * used as clock_event_device.
  */
 
 #include <linux/kernel.h>
@@ -20,84 +17,47 @@
 #include <linux/irq.h>
 #include <asm/mach/time.h>
 #include <mach/hardware.h>
+#include <ca9x2.h>
 #include <asm/localtimer.h>
 #include <asm/sched_clock.h>
-
 #include <linux/clk.h>
+#include <linux/clkdev.h>
 #include <linux/clockchips.h>
 #include <linux/delay.h>
 #include <linux/io.h>
 #include <asm/smp_twd.h>
 
-
 #include "boardEnv/mvBoardEnvLib.h"
 #include "cpu/mvCpu.h"
 
-#ifdef CONFIG_SMP
-static struct clock_event_device __percpu ** axp_local_clockevent;
-#endif
-
 extern void axp_irq_mask(struct irq_data *d);
 extern void axp_irq_unmask(struct irq_data *d);
-extern unsigned int master_cpu_id;
-
-#define  TIMER_CTRL		(MV_CNTMR_REGS_OFFSET + 0x0000)
-#define  TIMER_WD_RELOAD	(MV_CNTMR_REGS_OFFSET + 0x0020)
-#define  TIMER_WD_VAL		(MV_CNTMR_REGS_OFFSET + 0x0024)
-#define  TIMER_CAUSE		(MV_CNTMR_REGS_OFFSET + 0x0028)
-
-#define  TIMER_EN(x)		(0x0001 << (2 * x))
-#define  TIMER_RELOAD_EN(x)	(0x0002 << (2 * x))
-#define  TIMER_RELOAD(x)	(MV_CNTMR_REGS_OFFSET + 0x0010 + (8 * x))
-#define  TIMER_VAL(x)		(MV_CNTMR_REGS_OFFSET + 0x0014 + (8 * x))
-#define  INT_TIMER_CLR(x)	(~(1 << (8*x)))
-
-
-#define  LCL_TIMER_BASE		(0x21000 | 0x40)
-#define  LCL_TIMER_CTRL		(LCL_TIMER_BASE + 0x0000)
-#define    LCL_TIMER0_EN		0x0001
-#define    LCL_TIMER0_RELOAD_EN		0x0002
-#define    LCL_TIMER1_EN		0x0004
-#define    LCL_TIMER1_RELOAD_EN		0x0008
-#define  LCL_TIMER0_RELOAD	(LCL_TIMER_BASE + 0x0010)
-#define  LCL_TIMER0_VAL		(LCL_TIMER_BASE + 0x0014)
-#define  LCL_TIMER1_RELOAD	(LCL_TIMER_BASE + 0x0018)
-#define  LCL_TIMER1_VAL		(LCL_TIMER_BASE + 0x001c)
-#define  LCL_TIMER_WD_RELOAD	(LCL_TIMER_BASE + 0x0020)
-#define  LCL_TIMER_WD_VAL	(LCL_TIMER_BASE + 0x0024)
-#define  LCL_TIMER_CAUSE	(LCL_TIMER_BASE + 0x0028)
-#define   LCL_INT_TIMER0_CLR 	~(1 << 0)
-#define   LCL_INT_TIMER1_CLR	~(1 << 8)
-#define LCL_TIMER_TURN_25MHZ	(1 << 11)
+
+/* SoC global timer */
+#define TIMER_CTRL		(MV_CNTMR_REGS_OFFSET + 0x0000)
+#define  TIMER_EN(x)		(1 << (2 * x))
+#define  TIMER_RELOAD_EN(x)	(2 << (2 * x))
+#define TIMER_CAUSE		(MV_CNTMR_REGS_OFFSET + 0x0004)
+#define  TIMER_INT_CLR(x)	(~(1 << (8 * x)))
+#define TIMER_RELOAD(x)		(MV_CNTMR_REGS_OFFSET + 0x0010 + (8 * x))
+#define TIMER_VAL(x)		(MV_CNTMR_REGS_OFFSET + 0x0014 + (8 * x))
 
 #define TIMER_TURN_25MHZ(x)	(1 << (11 + x))
 #define BRIDGE_CAUSE		(MV_MBUS_REGS_OFFSET | 0x0260)
 #define BRIDGE_MASK		(MV_MBUS_REGS_OFFSET | 0x10c4)
-#define BRIDGE_INT_TIMER(x)	(1 << (24 + x))
+#define BRIDGE_INT_TIMER(x)	(1 << (22 + x))
 
-/*
- * Number of timer ticks per jiffy.
- */
 static u32 ticks_per_jiffy;
-static unsigned int soc_timer_id;
 
 static u32 notrace alp_clksrc_read32(void)
 {
-	u32 cyc = ~MV_REG_READ(TIMER_VAL(soc_timer_id));
+	u32 cyc = ~MV_REG_READ(TIMER_VAL(0));
 	return cyc;
 }
 
-static void __init alp_setup_sched_clock(unsigned long tclk)
-{
-	setup_sched_clock(alp_clksrc_read32, 32, tclk);
-}
-
-/*
- * Clocksource handling.
- */
 static cycle_t alp_clksrc_read(struct clocksource *cs)
 {
-	return (0xffffffff - MV_REG_READ(TIMER_VAL(soc_timer_id)));
+	return (0xffffffff - MV_REG_READ(TIMER_VAL(0)));
 }
 
 static struct clocksource alp_clksrc = {
@@ -109,345 +69,212 @@ static struct clocksource alp_clksrc = {
 	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
 };
 
-
-/*
- * Clockevent handling.
- */
-int axp_clkevt_next_event(unsigned long delta, struct clock_event_device *dev)
+int alp_clkevt_next_event(unsigned long delta, struct clock_event_device *evt)
 {
 	unsigned long flags;
 	u32 u;
 
 	if (delta == 0)
-		return -ETIME;	
+		return -ETIME;
 
 	local_irq_save(flags);
 
 	/* Clear and enable clockevent timer interrupt */
-	MV_REG_WRITE(LCL_TIMER_CAUSE, LCL_INT_TIMER0_CLR);
-	/*axp_irq_unmask(IRQ_LOCALTIMER);*/
-	axp_irq_unmask(irq_get_irq_data(IRQ_LOCALTIMER));
+	MV_REG_WRITE(TIMER_CAUSE, TIMER_INT_CLR(1));
 
 	/* Setup new clockevent timer value */
-	MV_REG_WRITE(LCL_TIMER0_VAL, delta);
-
+	MV_REG_WRITE(TIMER_VAL(1), delta);
 
 	/* Enable the timer */
-	u = MV_REG_READ(LCL_TIMER_CTRL);
-	u = (u & ~LCL_TIMER0_RELOAD_EN) | LCL_TIMER0_EN;
-	MV_REG_WRITE(LCL_TIMER_CTRL, u);
+	u = MV_REG_READ(TIMER_CTRL);
+	u = (u & ~TIMER_RELOAD_EN(1)) | TIMER_EN(1);
+	MV_REG_WRITE(TIMER_CTRL, u);
 
 	local_irq_restore(flags);
-
 	return 0;
 }
 
-static void axp_clkevt_mode(enum clock_event_mode mode, struct clock_event_device *dev)
+static void alp_clkevt_mode(enum clock_event_mode mode, struct clock_event_device *evt)
 {
 	unsigned long flags;
 	u32 u;
 	local_irq_save(flags);
 
-	if ((mode == CLOCK_EVT_MODE_PERIODIC) ||
-	    (mode == CLOCK_EVT_MODE_ONESHOT)) {
+	if (mode == CLOCK_EVT_MODE_PERIODIC || mode == CLOCK_EVT_MODE_ONESHOT) {
 		/* Setup timer to fire at 1/HZ intervals */
-		MV_REG_WRITE(LCL_TIMER0_RELOAD, (ticks_per_jiffy - 1));
-		MV_REG_WRITE(LCL_TIMER0_VAL, (ticks_per_jiffy - 1));
-
-		/* Enable timer interrupt */
-		axp_irq_unmask(irq_get_irq_data(IRQ_LOCALTIMER));
+		MV_REG_WRITE(TIMER_RELOAD(1), ticks_per_jiffy - 1);
+		MV_REG_WRITE(TIMER_VAL(1), ticks_per_jiffy - 1);
 
 		/* Enable timer */
-		u = MV_REG_READ(LCL_TIMER_CTRL);
-		u |= (LCL_TIMER0_EN | LCL_TIMER0_RELOAD_EN);
-		MV_REG_WRITE(LCL_TIMER_CTRL, u);
+		u = MV_REG_READ(TIMER_CTRL);
+		u |= TIMER_EN(1) | TIMER_RELOAD_EN(1);
+		MV_REG_WRITE(TIMER_CTRL, u);
 	} else {
 		/* Disable timer */
-		u = MV_REG_READ(LCL_TIMER_CTRL);
-		u &= ~LCL_TIMER0_EN;
-		MV_REG_WRITE(LCL_TIMER_CTRL, u);
+		u = MV_REG_READ(TIMER_CTRL);
+		u &= ~TIMER_EN(1);
+		MV_REG_WRITE(TIMER_CTRL, u);
 
-		/* Disable timer interrupt */
-		//axp_irq_mask(IRQ_LOCALTIMER);
-		axp_irq_mask(irq_get_irq_data(IRQ_LOCALTIMER));
-
-
-		/* ACK pending timer interrupt */
-		MV_REG_WRITE(LCL_TIMER_CAUSE, LCL_INT_TIMER0_CLR);
+		/* Ack pending timer interrupt */
+		MV_REG_WRITE(TIMER_CAUSE, TIMER_INT_CLR(1));
 	}
 
 	local_irq_restore(flags);
 }
 
-static struct clock_event_device axp_clkevt;
-static irqreturn_t axp_timer_interrupt(int irq, void *dev_id)
-{
-	/* ACK timer interrupt and call event handler */
-	MV_REG_WRITE(LCL_TIMER_CAUSE, LCL_INT_TIMER0_CLR);
-	axp_clkevt.event_handler(&axp_clkevt);
+static struct clock_event_device alp_clkevt;
 
+static irqreturn_t alp_timer_interrupt(int irq, void *dev_id)
+{
+	/* Ack timer interrupt */
+	MV_REG_WRITE(TIMER_CAUSE, TIMER_INT_CLR(1));
+	alp_clkevt.event_handler(&alp_clkevt);
 	return IRQ_HANDLED;
 }
 
-static struct irqaction axp_timer_irq = {
-	.name		= "axp_tick",
+static struct irqaction alp_timer_irq = {
+	.name		= "alp_clk_evt",
 	.flags		= IRQF_DISABLED | IRQF_TIMER,
-	.handler	= axp_timer_interrupt,
-	.dev_id         = &axp_clkevt,
+	.handler	= alp_timer_interrupt,
+	.dev_id		= &alp_clkevt,
 };
 
-
 /*
- * Setup the local clock events for a CPU.
+ * Implement clock API.
  */
-void __cpuinit mv_timer_setup(struct clock_event_device *clk, unsigned int fabric_clk)
+int clk_enable(struct clk *clk)
 {
-	unsigned int cpu = smp_processor_id();
-
-	clk->features		= (CLOCK_EVT_FEAT_ONESHOT | CLOCK_EVT_FEAT_PERIODIC),
-	clk->shift		= 32,
-	clk->rating		= 300,
-	clk->set_next_event	= axp_clkevt_next_event,
-	clk->set_mode		= axp_clkevt_mode,
-	clk->cpumask		= cpumask_of(cpu);
-	clk->mult		= div_sc(fabric_clk, NSEC_PER_SEC, clk->shift);
-	clk->max_delta_ns	= clockevent_delta2ns(0xffffffff, clk);
-	clk->min_delta_ns	= clockevent_delta2ns(0x1, clk);
+	return 0;
 }
 
-/*
- * Resume timer from suspend to RAM
- * TODO - need to implement kernel hooks for suspend/resume
- */
-void alp_timer_resume(void)
+void clk_disable(struct clk *clk)
 {
-	u32 u;
-
-	pr_info("Resuming Avantalp SOC Timer %d\n", soc_timer_id);
+	/* Empty */
+}
 
-	MV_REG_WRITE(TIMER_VAL(soc_timer_id), 0xffffffff);
-	MV_REG_WRITE(TIMER_RELOAD(soc_timer_id), 0xffffffff);
+#ifdef CONFIG_HAVE_ARM_TWD
+struct clk {
+	unsigned int rate;
+};
 
-	u = MV_REG_READ(BRIDGE_MASK);
-	u &= ~BRIDGE_INT_TIMER(soc_timer_id);
-	MV_REG_WRITE(BRIDGE_MASK, u);
+static struct clk twd_clk = {
+	.rate = 12500000,
+};
 
-	u = MV_REG_READ(TIMER_CTRL);
-	u |= (TIMER_EN(soc_timer_id) | TIMER_RELOAD_EN(soc_timer_id) |
-			TIMER_TURN_25MHZ(soc_timer_id));
-	MV_REG_WRITE(TIMER_CTRL, u);
+unsigned long clk_get_rate(struct clk *clk)
+{
+	return clk->rate;
 }
 
-static void broadcast_timer_set_mode(enum clock_event_mode mode,
-	struct clock_event_device *evt)
+long clk_round_rate(struct clk *clk, unsigned long rate)
 {
+	return clk->rate;
 }
 
-static void __cpuinit broadcast_timer_setup(struct clock_event_device *evt)
+int clk_set_rate(struct clk *clk, unsigned long rate)
 {
-	evt->name	= "alp_dummy_timer";
-	evt->features	= CLOCK_EVT_FEAT_ONESHOT |
-			  CLOCK_EVT_FEAT_PERIODIC |
-			  CLOCK_EVT_FEAT_DUMMY;
-	evt->rating	= 400;
-	evt->mult	= 1;
-	evt->set_mode	= broadcast_timer_set_mode;
-
-	clockevents_register_device(evt);
+	return 0;
 }
 
-#ifndef CONFIG_SMP
-/*
- * Timer (local or broadcast) support
- */
-static DEFINE_PER_CPU(struct clock_event_device, percpu_clockevent);
-extern int __cpuinit twd_timer_setup(struct clock_event_device *clk);
+static struct clk_lookup clk_twd_lookup = {
+	.dev_id = "smp_twd",
+	.con_id = NULL,
+	.clk = &twd_clk,
+};
 
-void __cpuinit alp_percpu_timer_setup(void)
-{
-	unsigned int cpu = 0; /* smp_processor_id(); */
-	struct clock_event_device *evt = &per_cpu(percpu_clockevent, cpu);
-	evt->cpumask = cpumask_of(cpu);
-	evt->broadcast = NULL; /* smp_timer_broadcast; */
-	evt->irq = IRQ_LOCALTIMER;
-	twd_timer_setup(evt);
-}
+static DEFINE_TWD_LOCAL_TIMER(twd_local_timer,
+			      INTER_REGS_PHYS_BASE + A9_MPCORE_TWD,
+			      IRQ_LOCALTIMER);
 
-void __cpuinit alp_up_mode_local_timer_setup(void)
+static void __init alp_twd_init(void)
 {
-	alp_percpu_timer_setup();
+	int err = twd_local_timer_register(&twd_local_timer);
+	if (err)
+		pr_err("twd_local_timer_register failed %d\n", err);
+
+	clkdev_add(&clk_twd_lookup);	
 }
+#else
+#define alp_twd_init()	do { } while(0)
 #endif
 
-void __init alp_time_init(unsigned int fabric_clk)
+/* Setup free-running clocksource timer */
+static void alp_setup_clocksource(int timer, long rate)
 {
-	u32 u;
-	soc_timer_id = 0;
-
-	printk("Initializing AvantaLP SOC Timer %d\n", soc_timer_id);
+	u32 i = timer, u;
+	void __iomem *base = (void __iomem *)(INTER_REGS_BASE + TIMER_VAL(i));
 
-	ticks_per_jiffy = (fabric_clk + HZ/2) / HZ;
+	MV_REG_WRITE(TIMER_VAL(i), 0xffffffff);
+	MV_REG_WRITE(TIMER_RELOAD(i), 0xffffffff);
 
-	alp_setup_sched_clock(fabric_clk);
-
-	/* Setup free-running clocksource timer (interrupts disabled) */
-	MV_REG_WRITE(TIMER_VAL(soc_timer_id), 0xffffffff);
-	MV_REG_WRITE(TIMER_RELOAD(soc_timer_id), 0xffffffff);
+	/* Disable timer interrupt */
 	u = MV_REG_READ(BRIDGE_MASK);
-	u &= ~BRIDGE_INT_TIMER(soc_timer_id);
+	u &= ~BRIDGE_INT_TIMER(i);
 	MV_REG_WRITE(BRIDGE_MASK, u);
+
+	/* Config clock source for timer */
 	u = MV_REG_READ(TIMER_CTRL);
-#if !defined (CONFIG_MACH_AVANTA_LP_FPGA)
-	u |= (TIMER_EN(soc_timer_id) | TIMER_RELOAD_EN(soc_timer_id) | TIMER_TURN_25MHZ(soc_timer_id));
+#if !defined(CONFIG_MACH_AVANTA_LP_FPGA)
+	u |= (TIMER_EN(i) | TIMER_RELOAD_EN(i) | TIMER_TURN_25MHZ(i));
 #else
-	u |= (TIMER_EN(soc_timer_id) | TIMER_RELOAD_EN(soc_timer_id));
+	u |= (TIMER_EN(i) | TIMER_RELOAD_EN(i));
 #endif
 	MV_REG_WRITE(TIMER_CTRL, u);
-	alp_clksrc.mult = clocksource_hz2mult(fabric_clk, alp_clksrc.shift);
-	clocksource_register(&alp_clksrc);
 
-#ifdef CONFIG_SMP
-	percpu_timer_setup();
-#else
-	alp_up_mode_local_timer_setup();
-#endif
+	clocksource_mmio_init(base, "alp_clk_source",
+		rate, 200, 32, clocksource_mmio_readl_down);
 
-#if 0
-	/* Setup clockevent timer (interrupt-driven) */
-	axp_clkevt.name = "axp_tick";
-	axp_clkevt.irq = IRQ_LOCALTIMER;
-	mv_timer_setup(&axp_clkevt, fabric_clk);
-	setup_irq(IRQ_LOCALTIMER, &axp_timer_irq);
-	clockevents_register_device(&axp_clkevt);
-#endif
+	alp_clksrc.mult = clocksource_hz2mult(rate, alp_clksrc.shift);
+	setup_sched_clock(alp_clksrc_read32, 32, rate);
+	clocksource_register(&alp_clksrc);
 }
 
-static void __init alp_timer_init(void)
+static void alp_setup_clockevent(int irq, long rate)
 {
-#if defined (CONFIG_MACH_AVANTA_LP_FPGA)
-	/* FPGA is hardcoded to 25Mhx and DSMP-A0 ref clock for the timers is 25MHz */
-	alp_time_init(12500000);
-#else
-	alp_time_init(mvCpuL2ClkGet());  /* DSMP-Z1 clock is taken from Fabric */
-#endif
-}
-
-struct sys_timer alp_timer = {
-	.init = alp_timer_init,
-};
-
-
-#if defined (CONFIG_SMP) && defined (CONFIG_LOCAL_TIMERS)
-/*
- * Used on SMP for either the local timer or IPI_TIMER
- */
-/*void local_timer_interrupt(void)
-{
-	struct clock_event_device *clk = &__get_cpu_var(axp_local_clockevent);
-
-	clk->event_handler(clk);
-}
-*/
-
-/*
- * local_timer_ack: checks for a local timer interrupt.
- *
- * If a local timer interrupt has occurred, acknowledge and return 1.
- * Otherwise, return 0.
- */
+	struct clock_event_device *evt = &alp_clkevt;
+	unsigned int cpu = smp_processor_id();
 
-int local_timer_ack(void)
-{
-	if(MV_REG_READ(LCL_TIMER_CAUSE) & ~LCL_INT_TIMER0_CLR) {
-		MV_REG_WRITE(LCL_TIMER_CAUSE, LCL_INT_TIMER0_CLR);
-		return 1;
-	}
-	return 0;
+	evt->name = "alp_clkevt";
+	evt->irq = irq;
+	evt->features		= (CLOCK_EVT_FEAT_ONESHOT | CLOCK_EVT_FEAT_PERIODIC),
+	evt->shift		= 32,
+	evt->rating		= 300,
+	evt->set_next_event	= alp_clkevt_next_event,
+	evt->set_mode		= alp_clkevt_mode,
+	evt->cpumask		= cpumask_of(cpu);
+	evt->mult		= div_sc(rate, NSEC_PER_SEC, evt->shift);
+	evt->max_delta_ns	= clockevent_delta2ns(0xffffffff, evt);
+	evt->min_delta_ns	= clockevent_delta2ns(0x1, evt);
+
+	setup_irq(irq, &alp_timer_irq);
+	clockevents_config_and_register(evt, rate, 0xf, 0xffffffff);
+	/* clockevents_register_device(evt); */
 }
 
-static irqreturn_t axp_localtimer_handler(int irq, void *dev_id)
+static void __init alp_timer_init(void)
 {
+	u32 rate;
 
-	struct clock_event_device *evt = *(struct clock_event_device **)dev_id;
-	if (local_timer_ack()) {
-		evt->event_handler(evt);
-		return IRQ_HANDLED;
-	}
+#ifdef CONFIG_MACH_AVANTA_LP_FPGA
+	rate = 12500000;
+#else
+	rate = mvCpuL2ClkGet();
+#endif
 
-	return IRQ_NONE;
-}
+	printk("Initializing AvantaLP SoC Timers\n");
+	ticks_per_jiffy = (rate + HZ/2) / HZ;
 
-#if 0
-/*
- * Setup the local clock events for a CPU.
- */
- __cpuinit local_timer_setup(struct clock_event_device *clk)
-{
-	unsigned int fabric_clk = 12500000;
-	static cpu0_flag=0;
-	int cpu = smp_processor_id();
-	struct clock_event_device **this_cpu_clk;
-
-	if (!axp_local_clockevent) {
-		int err;
-
-		axp_local_clockevent = alloc_percpu(struct clock_event_device *);
-		if (!axp_local_clockevent) {
-			pr_err("axp_local_clockevent: can't allocate memory\n");
-			return 0;
-		}
-		err = request_percpu_irq(IRQ_LOCALTIMER, axp_localtimer_handler,
-				"axp_local_clockevent", axp_local_clockevent);
-		if (err) {
-			pr_err("axp_local_clockevent: can't register interrupt %d (%d)\n",
-				IRQ_LOCALTIMER, err);
-			return 0;
-		}
-	}
+printk("oooooooo: %s:%d: ~~~~~~~~~~~~~~~\n", __func__, __LINE__);
+	alp_setup_clocksource(0, rate);
 
-	pr_err("oooooooo: %s:%s:%d: #####################################################\n", __FILE__, __func__, __LINE__);
-	if((cpu) || (!cpu && !cpu0_flag)){
-		ticks_per_jiffy = (fabric_clk + HZ/2) / HZ;
-		clk->name = "local_timer";
-		clk->irq = IRQ_LOCALTIMER;
-		mv_timer_setup(clk, fabric_clk);
-		this_cpu_clk = __this_cpu_ptr(axp_local_clockevent);
-		*this_cpu_clk = clk;
-		pr_err("oooooooo: #####################################################\n");
-		pr_err("oooooooo: #####################################################\n");
-		pr_err("oooooooo: calling to clockevents_register_device()\n");
-		pr_err("oooooooo: #####################################################\n");
-		pr_err("oooooooo: #####################################################\n");
-		clockevents_register_device(clk);
-	 if(!cpu)
-		cpu0_flag++;
-	}
-	enable_percpu_irq(clk->irq, 0);
-	return 0;
-}
+printk("oooooooo: %s:%d: ~~~~~~~~~~~~~~~\n", __func__, __LINE__);
 
-#ifdef CONFIG_HOTPLUG_CPU
-/*
- * take a local timer down
- */
-void  __cpuexit local_timer_stop(struct clock_event_device * evt)
-{
-	unsigned long flags;
-	u32 u;
-	local_irq_save(flags);
-
-	/* Disable timer */
-	u = MV_REG_READ(LCL_TIMER_CTRL);
-	u &= ~LCL_TIMER0_EN;
-	MV_REG_WRITE(LCL_TIMER_CTRL, u);
-	MV_REG_WRITE(LCL_TIMER_CAUSE, LCL_INT_TIMER0_CLR);
-	/* Disable timer interrupt */
-	/*axp_irq_mask(IRQ_LOCALTIMER);*/
-	axp_irq_mask(irq_get_irq_data(IRQ_LOCALTIMER));
-
-	local_irq_restore(flags);
+	alp_setup_clockevent(IRQ_AURORA_GLOB_TIMER1, rate);
+printk("oooooooo: %s:%d: ~~~~~~~~~~~~~~~\n", __func__, __LINE__);
+	alp_twd_init();
+printk("oooooooo: %s:%d: ~~~~~~~~~~~~~~~\n", __func__, __LINE__);
 }
-#endif
-#endif /* #if 0 */
-#endif	/* CONFIG_LOCAL_TIMERS && CONFIG_SMP */
 
+struct sys_timer alp_timer = {
+	.init = alp_timer_init,
+};
diff --git a/arch/arm/plat-armada/Kconfig b/arch/arm/plat-armada/Kconfig
index 4a52ec8..c822411f 100644
--- a/arch/arm/plat-armada/Kconfig
+++ b/arch/arm/plat-armada/Kconfig
@@ -1,6 +1,6 @@
 if PLAT_ARMADA
 
-menu "Armada SoC options"
+menu "Marvell SoC options"
 	depends on PLAT_ARMADA
 
 config JTAG_DEBUG
@@ -11,12 +11,12 @@ config JTAG_DEBUG
            Enable the JTAG debugger taking over the CPU by disabling "wait for interrupt" idle loop."
 
 
-menu "Armada SoC Included Features"
+menu "Marvell SoC Included Features"
 
-if ARMADA_XP
+if ARMADA_XP || AVANTA_LP
 config MV_INCLUDE_PEX
 	bool "PCI Express Support"
-	depends on PCI && (MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP)
+	depends on PCI && (MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP || AVANTA_LP)
 	default y
 	select MV_PEX_2_1X4
 	select MV_PEX_3_1X4
@@ -67,75 +67,82 @@ endif
 
 config MV_INCLUDE_PCI
 	bool "PCI Support"
-	depends on PCI && (MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP || ARMADA_370)
+	depends on PCI && (MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP || ARMADA_370 || AVANTA_LP)
 	default n
         ---help---
         Please don't change this configs unless you know what you are doing.
 
 config MV_INCLUDE_USB
 	bool "USB Support"
-	depends on MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP || ARMADA_370
+	depends on MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP || ARMADA_370 || AVANTA_LP
 	default y
         ---help---
         Please don't change this configs unless you know what you are doing.
 
 config MV_INCLUDE_XOR
 	bool "XOR Support"
-	depends on MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP || ARMADA_370
+	depends on MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP || ARMADA_370 || AVANTA_LP
 	default y
         ---help---
         Please don't change this configs unless you know what you are doing.
 
 config MV_INCLUDE_CESA
 	bool "CESA Support"
-	depends on MV88F6500 || MV88F6082 || MV88F6183 || MV88F6281 || MV78XX0 || ARMADA_XP || ARMADA_370
+	depends on MV88F6500 || MV88F6082 || MV88F6183 || MV88F6281 || MV78XX0 \
+		|| ARMADA_XP || ARMADA_370 || AVANTA_LP
 	default y
         ---help---
         Please don't change this configs unless you know what you are doing.
 
 config MV_INCLUDE_NFC
 	bool "Nand Flash Controller Support"
-	depends on MV88F6500 || ARMADA_XP || ARMADA_370
+	depends on MV88F6500 || ARMADA_XP || ARMADA_370 || AVANTA_LP
 	default y
         ---help---
         Please don't change this configs unless you know what you are doing.
 
 config MV_INCLUDE_LEGACY_NAND
 	bool "Legacy NAND Support"
-	depends on MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP || ARMADA_370
+	depends on MV88F6500 || MV88F6281 || MV78XX0 \
+		|| ARMADA_XP || ARMADA_370 || AVANTA_LP
 	default y
         ---help---
         Please don't change this configs unless you know what you are doing.
 
 config MV_INCLUDE_INTEG_SATA
 	bool "Integrated SATA Support"
-	depends on MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP || ARMADA_370
+	depends on MV88F6500 || MV88F6281 || MV78XX0 || \
+		   ARMADA_XP || ARMADA_370 || AVANTA_LP
 	default y
         ---help---
         Please don't change this configs unless you know what you are doing.
 
 config MV_INCLUDE_TDM
 	bool "Integrated TDM Support"
-	depends on MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP || ARMADA_370
+	depends on MV88F6500 || MV88F6281 || MV78XX0 || \
+		   ARMADA_XP || ARMADA_370 || AVANTA_LP
 	default y
         ---help---
         Please don't change this configs unless you know what you are doing.
 
 config MV_INCLUDE_GIG_ETH
 	bool "Giga Ethernet Support"
-	depends on MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP || ARMADA_370
+	depends on MV88F6500 || MV88F6281 || MV78XX0 || \
+		   ARMADA_XP || ARMADA_370
 	default y
 
 config MV_INCLUDE_SPI
 	bool "SPI Support"
-	depends on MV88F6500 || MV88F6281 || (MV78XX0 && !MV78XX0_Z0) || ARMADA_XP || ARMADA_370
+	depends on MV88F6500 || MV88F6281 || (MV78XX0 && !MV78XX0_Z0) || \
+		   ARMADA_XP || ARMADA_370 || AVANTA_LP
 	default y
         ---help---
         Please don't change this configs unless you know what you are doing.
 
 config MV_INCLUDE_NOR
 	bool "NOR Support"
-	depends on MV88F6500 || MV88F6281 || (MV78XX0 && !MV78XX0_Z0) || ARMADA_XP
+	depends on MV88F6500 || MV88F6281 || (MV78XX0 && !MV78XX0_Z0) || \
+		   ARMADA_XP || AVANTA_LP
 	default y
         ---help---
         Please don't change this configs unless you know what you are doing.
@@ -143,7 +150,7 @@ config MV_INCLUDE_NOR
 
 config MV_INCLUDE_SDIO
 	bool "SDIO Support"
-	depends on MV88F6500 || MV88F6281 || ARMADA_XP || ARMADA_370
+	depends on MV88F6500 || MV88F6281 || ARMADA_XP || ARMADA_370 || AVANTA_LP
 	default y
         ---help---
         Please don't change this configs unless you know what you are doing.
@@ -164,13 +171,13 @@ config MV_INCLUDE_PON
 
 config MV_INCLUDE_SWITCH
         bool "Ethernet Switch Support"
-        depends on MV88F6500 || MV88F6281 || MV78XX0 || ARMADA_XP || ARMADA_370
+        depends on MV88F6500 || MV88F6281 || MV78XX0 || \
+		   ARMADA_XP || ARMADA_370 || AVANTA_LP
         default y
 
 endmenu
 
 
-
 menu "Armada AMP options"
 
 config MV_AMP_ENABLE
diff --git a/drivers/tty/serial/8250/8250_dw.c b/drivers/tty/serial/8250/8250_dw.c
index 684cf96..11ccb9f 100644
--- a/drivers/tty/serial/8250/8250_dw.c
+++ b/drivers/tty/serial/8250/8250_dw.c
@@ -89,11 +89,16 @@ static int dw8250_handle_irq(struct uart_port *p)
 
 static int __devinit dw8250_probe(struct platform_device *pdev)
 {
+#ifndef CONFIG_USE_OF
+struct plat_serial8250_port *p = pdev->dev.platform_data;
+#endif
 	struct uart_port port = {};
 	struct resource *regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	struct resource *irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+#ifdef CONFIG_USE_OF
 	struct device_node *np = pdev->dev.of_node;
 	u32 val;
+#endif
 	struct dw8250_data *data;
 
 	if (!regs || !irq) {
@@ -118,6 +123,7 @@ static int __devinit dw8250_probe(struct platform_device *pdev)
 	port.iotype = UPIO_MEM;
 	port.serial_in = dw8250_serial_in;
 	port.serial_out = dw8250_serial_out;
+#ifdef CONFIG_USE_OF
 	if (!of_property_read_u32(np, "reg-io-width", &val)) {
 		switch (val) {
 		case 1:
@@ -142,7 +148,13 @@ static int __devinit dw8250_probe(struct platform_device *pdev)
 		return -EINVAL;
 	}
 	port.uartclk = val;
-
+#else
+	port.iotype = p->iotype;
+        port.serial_in = dw8250_serial_in32;
+        port.serial_out = dw8250_serial_out32;
+        port.regshift = p->regshift;
+        port.uartclk = p->uartclk;
+#endif
 	data->line = serial8250_register_port(&port);
 	if (data->line < 0)
 		return data->line;
diff --git a/drivers/tty/serial/8250/Kconfig b/drivers/tty/serial/8250/Kconfig
index a51bc0c..2473309 100644
--- a/drivers/tty/serial/8250/Kconfig
+++ b/drivers/tty/serial/8250/Kconfig
@@ -274,7 +274,7 @@ config SERIAL_8250_FSL
 
 config SERIAL_8250_DW
 	tristate "Support for Synopsys DesignWare 8250 quirks"
-	depends on SERIAL_8250 && (OF || ARMADA_XP || MACH_AVANTA_LP_FPGA)
+	depends on SERIAL_8250 && (OF || ARMADA_XP || AVANTA_LP)
 	help
 	  Selecting this option will enable handling of the extra features
 	  present in the Synopsys DesignWare APB UART.
-- 
1.7.5.4

