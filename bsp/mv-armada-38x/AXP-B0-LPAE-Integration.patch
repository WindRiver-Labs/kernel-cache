From ed8832cb51e0acc21eb7a29978bc5952dcd56832 Mon Sep 17 00:00:00 2001
From: Tawfik Bayouk <tawfik@marvell.com>
Date: Mon, 3 Sep 2012 19:04:01 +0300
Subject: [PATCH 0240/1825] AXP-B0 LPAE Integration

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 6c7ab7e3ba237d576b85e9dde6db1780b1940bec

Change-Id: I9bbb97d158fd56b9377b2e5bbfa65373d1fa7847
Signed-off-by: Tawfik Bayouk <tawfik@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/Kconfig                                   |    2 +
 arch/arm/mach-armadaxp/config/mvSysHwConfig.h      |    6 +++
 arch/arm/mach-armadaxp/core.c                      |   37 +++++++++++++++++--
 arch/arm/mach-armadaxp/mv_hal_if/mvSysNeta.c       |    2 +-
 arch/arm/mach-armadaxp/mv_hal_if/mvSysPci.c        |    4 +-
 arch/arm/plat-armada/common/mvCommon.c             |   32 +++++++++++------
 arch/arm/plat-armada/common/mvCommon.h             |    2 +-
 arch/arm/plat-armada/common/mvTypes.h              |    2 +-
 arch/arm/plat-armada/mv_hal/cesa/mvCesaAddrDec.c   |    2 +-
 arch/arm/plat-armada/mv_hal/ddr2_3/mvDramIf.c      |    6 ++--
 arch/arm/plat-armada/mv_hal/ddr2_3/mvDramIfRegs.h  |    2 +
 .../plat-armada/mv_hal/neta/gbe/mvNetaAddrDec.c    |    4 +-
 arch/arm/plat-armada/mv_hal/pex/mvPexAddrDec.c     |    2 +-
 .../mv_hal/sata/CoreDriver/mvSataAddrDec.c         |    2 +-
 arch/arm/plat-armada/mv_hal/sdmmc/mvSdmmcAddrDec.c |    2 +-
 arch/arm/plat-armada/mv_hal/usb/mvUsbAddrDec.c     |    2 +-
 16 files changed, 78 insertions(+), 31 deletions(-)

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 2be42bb..e59a0cf 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -632,6 +632,8 @@ config ARCH_ARMADA_XP
 	select CLKSRC_MMIO
 	select CLKDEV_LOOKUP
 	select NEED_MACH_MEMORY_H
+	select DMABOUNCE
+
 
 config ARCH_MV78XX0
 	bool "Marvell MV78xx0"
diff --git a/arch/arm/mach-armadaxp/config/mvSysHwConfig.h b/arch/arm/mach-armadaxp/config/mvSysHwConfig.h
index 4f742f3..b0f7c6e 100644
--- a/arch/arm/mach-armadaxp/config/mvSysHwConfig.h
+++ b/arch/arm/mach-armadaxp/config/mvSysHwConfig.h
@@ -265,6 +265,12 @@ disclaimer.
  #define MV_TDM_USE_EXTERNAL_PCLK_SOURCE
 #endif
 
+/****************************************************************/
+/******************* LPAE configuration *************************/
+/****************************************************************/
+#ifdef CONFIG_ARM_LPAE
+#define ARM_LPAE_SUPPORT
+#endif
 /* We use the following registers to store DRAM interface pre configuration   */
 /* auto-detection results													  */
 /* IMPORTANT: We are using mask register for that purpose. Before writing     */
diff --git a/arch/arm/mach-armadaxp/core.c b/arch/arm/mach-armadaxp/core.c
index eecdcb5..24acb3e 100644
--- a/arch/arm/mach-armadaxp/core.c
+++ b/arch/arm/mach-armadaxp/core.c
@@ -1198,7 +1198,7 @@ static struct platform_device armadaxp_xor00_channel = {
 	.resource	= armadaxp_xor00_resources,
 	.dev		= {
 		.dma_mask		= &armadaxp_xor_dmamask,
-		.coherent_dma_mask	= DMA_BIT_MASK(64),
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
 		.platform_data		= &armadaxp_xor00_data,
 	},
 };
@@ -1224,7 +1224,7 @@ static struct platform_device armadaxp_xor01_channel = {
 	.resource	= armadaxp_xor01_resources,
 	.dev		= {
 		.dma_mask		= &armadaxp_xor_dmamask,
-		.coherent_dma_mask	= DMA_BIT_MASK(64),
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
 		.platform_data		= &armadaxp_xor01_data,
 	},
 };
@@ -1296,7 +1296,7 @@ static struct platform_device armadaxp_xor10_channel = {
 	.resource	= armadaxp_xor10_resources,
 	.dev		= {
 		.dma_mask		= &armadaxp_xor_dmamask,
-		.coherent_dma_mask	= DMA_BIT_MASK(64),
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
 		.platform_data		= &armadaxp_xor10_data,
 	},
 };
@@ -1322,7 +1322,7 @@ static struct platform_device armadaxp_xor11_channel = {
 	.resource	= armadaxp_xor11_resources,
 	.dev		= {
 		.dma_mask		= &armadaxp_xor_dmamask,
-		.coherent_dma_mask	= DMA_BIT_MASK(64),
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
 		.platform_data		= &armadaxp_xor11_data,
 	},
 };
@@ -1603,6 +1603,34 @@ void __init axp_tag_fixup_mem32(struct machine_desc *mdesc, struct tag *t,
 }
 #endif /* CONFIG_FB_DOVE */
 
+void __init axp_tag_fixup(struct tag *t, char **from,
+			    struct meminfo *meminfo)
+{
+	int i = 0;
+	__u64 base = 0x0ll;
+	for (; t->hdr.size; t = tag_next(t))
+		if (t->hdr.tag == ATAG_MEM64) {
+#if 0
+			i++;
+			if (i > 3) {
+				t->u.mem64.start = 0x0;
+				t->u.mem64.size = 0x0;
+			} else if (i == 1) {
+				t->u.mem64.start = base;
+				t->u.mem64.size = (2ll << 30ll);
+			} else if (i == 2) {
+				t->u.mem64.start = base;
+				t->u.mem64.size = (uint64_t)(1ll << 30ll);
+			} else {
+				t->u.mem64.start = base;
+				t->u.mem64.size = (uint64_t)(2ll << 30ll);
+			}
+			base += (2ll << 30ll);
+#endif
+			printk(KERN_ERR "Base 0x%llx, Size 0x%llx.\n",
+				t->u.mem64.start, t->u.mem64.size);
+		}
+}
 
 MACHINE_START(ARMADA_XP_DB, "Marvell Armada XP Development Board")
 	/* MAINTAINER("MARVELL") */
@@ -1611,6 +1639,7 @@ MACHINE_START(ARMADA_XP_DB, "Marvell Armada XP Development Board")
 	.init_irq	= axp_init_irq,
 	.timer		= &axp_timer,
 	.init_machine	= axp_db_init,
+	.fixup		= axp_tag_fixup,
 #ifdef CONFIG_FB_DOVE
 	/* reserve memory for LCD */
 	.fixup		= axp_tag_fixup_mem32,
diff --git a/arch/arm/mach-armadaxp/mv_hal_if/mvSysNeta.c b/arch/arm/mach-armadaxp/mv_hal_if/mvSysNeta.c
index fe2be33..4eadde2 100644
--- a/arch/arm/mach-armadaxp/mv_hal_if/mvSysNeta.c
+++ b/arch/arm/mach-armadaxp/mv_hal_if/mvSysNeta.c
@@ -108,7 +108,7 @@ void 	mvSysNetaInit(void)
 			addrWinMap[i].attrib |= 0x30;
 		}
 #endif
-		mvOsPrintf("%d - Base 0x%08x , Size = 0x%08x.\n", i,
+		mvOsPrintf("%d - Base 0x%08x , Size = 0x%08llx.\n", i,
                                 addrWinMap[i].addrWin.baseLow,
                                 addrWinMap[i].addrWin.size);
 	}
diff --git a/arch/arm/mach-armadaxp/mv_hal_if/mvSysPci.c b/arch/arm/mach-armadaxp/mv_hal_if/mvSysPci.c
index a537357..ce4e013 100644
--- a/arch/arm/mach-armadaxp/mv_hal_if/mvSysPci.c
+++ b/arch/arm/mach-armadaxp/mv_hal_if/mvSysPci.c
@@ -666,7 +666,7 @@ MV_STATUS mvPciProtWinSet(MV_U32 pciIf,
 	if (MV_TRUE != pciWinIsValid(pProtWin->addrWin.baseLow, 
                                  pProtWin->addrWin.size))
 	{
-        mvOsPrintf("mvPciProtWinSet: ERR. Win base 0x%x unaligned to size 0x%x\n",
+        mvOsPrintf("mvPciProtWinSet: ERR. Win base 0x%x unaligned to size 0x%llx\n",
                    pProtWin->addrWin.baseLow, pProtWin->addrWin.size);
 
 		return MV_BAD_PARAM;
@@ -976,7 +976,7 @@ MV_STATUS mvPciTargetRemap(MV_U32 pciIf,
 	if (MV_IS_NOT_ALIGN(pAddrWin->baseLow, PBARR_REMAP_ALIGNMENT))
 	{
 		mvOsPrintf("mvPciTargetRemap: Error remapping PCI interface %d bar %s."\
-				   "\nAddress 0x%08x is unaligned to size 0x%x.\n",
+				   "\nAddress 0x%08x is unaligned to size 0x%llx.\n",
 				   pciIf,
 				   pciBarNameGet(bar),
                    pAddrWin->baseLow,
diff --git a/arch/arm/plat-armada/common/mvCommon.c b/arch/arm/plat-armada/common/mvCommon.c
index 22eb180..e2a6e10 100644
--- a/arch/arm/plat-armada/common/mvCommon.c
+++ b/arch/arm/plat-armada/common/mvCommon.c
@@ -164,30 +164,30 @@ MV_STATUS mvMacHexToStr(MV_U8 *macHex, char *macStr)
 *       None.
 *
 *******************************************************************************/
-MV_VOID mvSizePrint(MV_U32 size)
+MV_VOID mvSizePrint(MV_U64 size)
 {
 	mvOsOutput("size ");
 
 	if (size >= _1G) {
-		mvOsOutput("%3dGB ", size / _1G);
-		size %= _1G;
+		mvOsOutput("%3lldGB ", (MV_U64)(size >> 30));
+		size &= (MV_U64)(_1G - 1);
 		if (size)
 			mvOsOutput("+");
 	}
 	if (size >= _1M) {
-		mvOsOutput("%3dMB ", size / _1M);
+		mvOsOutput("%3lldMB ", size / _1M);
 		size %= _1M;
 		if (size)
 			mvOsOutput("+");
 	}
 	if (size >= _1K) {
-		mvOsOutput("%3dKB ", size / _1K);
+		mvOsOutput("%3lldKB ", size / _1K);
 		size %= _1K;
 		if (size)
 			mvOsOutput("+");
 	}
 	if (size > 0)
-		mvOsOutput("%3dB ", size);
+		mvOsOutput("%3lldB ", size);
 
 }
 
@@ -301,6 +301,13 @@ MV_U32 mvLog2(MV_U32 num)
 *******************************************************************************/
 MV_STATUS mvWinOverlapTest(MV_ADDR_WIN *pAddrWin1, MV_ADDR_WIN *pAddrWin2)
 {
+#ifdef ARM_LPAE_SUPPORT
+	/* Need to cancel overlap testing when in LPAE mode, because we use the
+	** MBUS Bridge Windows to access IO windows, and thus there will be
+	** always an overlap between the IO & DRAM windows.
+	*/
+	return MV_FALSE;
+#else
 	MV_U32 winBase1, winBase2;
 	MV_U32 winTop1, winTop2;
 
@@ -319,6 +326,7 @@ MV_STATUS mvWinOverlapTest(MV_ADDR_WIN *pAddrWin1, MV_ADDR_WIN *pAddrWin2)
 		return MV_TRUE;
 	else
 		return MV_FALSE;
+#endif
 }
 
 /*******************************************************************************
@@ -340,13 +348,13 @@ MV_STATUS mvWinOverlapTest(MV_ADDR_WIN *pAddrWin1, MV_ADDR_WIN *pAddrWin2)
 *******************************************************************************/
 MV_STATUS mvWinWithinWinTest(MV_ADDR_WIN *pAddrWin1, MV_ADDR_WIN *pAddrWin2)
 {
-	MV_U32 winBase1, winBase2;
-	MV_U32 winTop1, winTop2;
+	MV_U64 winBase1, winBase2;
+	MV_U64 winTop1, winTop2;
 
-	winBase1 = pAddrWin1->baseLow;
-	winBase2 = pAddrWin2->baseLow;
-	winTop1 = winBase1 + pAddrWin1->size - 1;
-	winTop2 = winBase2 + pAddrWin2->size - 1;
+	winBase1 = ((MV_U64)pAddrWin1->baseHigh << 32) + (MV_U32)pAddrWin1->baseLow;
+	winBase2 = ((MV_U64)pAddrWin2->baseHigh << 32) + (MV_U32)pAddrWin2->baseLow;
+	winTop1 = winBase1 + (MV_U64)pAddrWin1->size - 1;
+	winTop2 = winBase2 + (MV_U64)pAddrWin2->size - 1;
 
 	if (((winBase1 >= winBase2) && (winBase1 <= winTop2)) || ((winTop1 >= winBase2) && (winTop1 <= winTop2)))
 		return MV_TRUE;
diff --git a/arch/arm/plat-armada/common/mvCommon.h b/arch/arm/plat-armada/common/mvCommon.h
index 1301e01..5f5d2bb 100644
--- a/arch/arm/plat-armada/common/mvCommon.h
+++ b/arch/arm/plat-armada/common/mvCommon.h
@@ -381,7 +381,7 @@ void mvBinToAscii(const MV_U8 *bin, char *asciiStr, int size);
 
 MV_STATUS mvMacStrToHex(const char *macStr, MV_U8 *macHex);
 MV_STATUS mvMacHexToStr(MV_U8 *macHex, char *macStr);
-void mvSizePrint(MV_U32);
+void mvSizePrint(MV_U64);
 
 MV_U32 mvLog2(MV_U32 num);
 
diff --git a/arch/arm/plat-armada/common/mvTypes.h b/arch/arm/plat-armada/common/mvTypes.h
index 814db81..14a45e5 100644
--- a/arch/arm/plat-armada/common/mvTypes.h
+++ b/arch/arm/plat-armada/common/mvTypes.h
@@ -191,7 +191,7 @@ typedef enum {
 typedef struct _mvAddrWin {
 	MV_U32 baseLow;		/* 32bit base low       */
 	MV_U32 baseHigh;	/* 32bit base high      */
-	MV_U32 size;		/* 32bit size           */
+	MV_U64 size;		/* 64bit size           */
 } MV_ADDR_WIN;
 
 /* This binary enumerator describes protection attribute status             */
diff --git a/arch/arm/plat-armada/mv_hal/cesa/mvCesaAddrDec.c b/arch/arm/plat-armada/mv_hal/cesa/mvCesaAddrDec.c
index 555b1bc..6946464 100644
--- a/arch/arm/plat-armada/mv_hal/cesa/mvCesaAddrDec.c
+++ b/arch/arm/plat-armada/mv_hal/cesa/mvCesaAddrDec.c
@@ -178,7 +178,7 @@ static MV_STATUS mvCesaTdmaWinWrite(MV_U8 chan, MV_U32 winNum, MV_UNIT_WIN_INFO
 	/* check if address is aligned to the size */
 	if (MV_IS_NOT_ALIGN(pDecWin->addrWin.baseLow, pDecWin->addrWin.size)) {
 		mvOsPrintf("mvCesaTdmaWinSet: Error setting CESA TDMA window %d.\n"
-			   "Address 0x%08x is unaligned to size 0x%x.\n",
+			   "Address 0x%08x is unaligned to size 0x%llx.\n",
 			   winNum, pDecWin->addrWin.baseLow, pDecWin->addrWin.size);
 		return MV_ERROR;
 	}
diff --git a/arch/arm/plat-armada/mv_hal/ddr2_3/mvDramIf.c b/arch/arm/plat-armada/mv_hal/ddr2_3/mvDramIf.c
index fb3e743..0c026ea 100644
--- a/arch/arm/plat-armada/mv_hal/ddr2_3/mvDramIf.c
+++ b/arch/arm/plat-armada/mv_hal/ddr2_3/mvDramIf.c
@@ -216,7 +216,7 @@ MV_STATUS mvDramIfWinSet(MV_TARGET target, MV_DRAM_DEC_WIN *pAddrDecWin)
 	/* check if address is aligned to the size */
 	if (MV_IS_NOT_ALIGN(pAddrDecWin->addrWin.baseLow, pAddrDecWin->addrWin.size)) {
 		mvOsPrintf("mvDramIfWinSet:Error setting DRAM interface window %d."
-			   "\nAddress 0x%08x is unaligned to size 0x%x.\n",
+			   "\nAddress 0x%08x is unaligned to size 0x%llx.\n",
 			   target, pAddrDecWin->addrWin.baseLow, pAddrDecWin->addrWin.size);
 		return MV_ERROR;
 	}
@@ -275,7 +275,7 @@ MV_STATUS mvDramIfWinGet(MV_TARGET target, MV_DRAM_DEC_WIN *pAddrDecWin)
 
 	sizeRegVal = (sizeReg & SDRAMWCR_SIZE_MASK) >> SDRAMWCR_SIZE_OFFS;
 
-	pAddrDecWin->addrWin.size = (sizeRegVal + 1) * SDRAMWCR_SIZE_ALLIGNMENT;
+	pAddrDecWin->addrWin.size = (MV_U64)((sizeRegVal + 1) * SDRAMWCR_SIZE_ALLIGNMENT);
 
 	/* Check if ctrlRegToSize returned OK */
 	if (-1 == pAddrDecWin->addrWin.size) {
@@ -286,7 +286,7 @@ MV_STATUS mvDramIfWinGet(MV_TARGET target, MV_DRAM_DEC_WIN *pAddrDecWin)
 	/* Extract base address                                         */
 	/* Base register [31:16] ==> baseLow[31:16]             */
 	pAddrDecWin->addrWin.baseLow = baseReg & SDRAMWBR_BASE_MASK;
-	pAddrDecWin->addrWin.baseHigh = 0;
+	pAddrDecWin->addrWin.baseHigh = baseReg & SDRAMWBR_BASE_EXT_MASK;
 
 	if (sizeReg & SDRAMWCR_ENABLE)
 		pAddrDecWin->enable = MV_TRUE;
diff --git a/arch/arm/plat-armada/mv_hal/ddr2_3/mvDramIfRegs.h b/arch/arm/plat-armada/mv_hal/ddr2_3/mvDramIfRegs.h
index 7953fad..2a00716 100644
--- a/arch/arm/plat-armada/mv_hal/ddr2_3/mvDramIfRegs.h
+++ b/arch/arm/plat-armada/mv_hal/ddr2_3/mvDramIfRegs.h
@@ -75,6 +75,8 @@ extern "C" {
 #define SDRAM_WIN_BASE_REG(winNum)		(MV_DDR_WIN_REGS_BASE + 0x180 + winNum * 0x8)
 #define SDRAMWBR_BASE_OFFS			24
 #define SDRAMWBR_BASE_MASK			(0xFF << SDRAMWBR_BASE_OFFS)
+#define SDRAMWBR_BASE_EXT_MASK			(0xF)
+
 #define SDRAMWBR_BASE_ALIGNMENT			0x10000
 
 #define SDRAM_WIN_CTRL_REG(winNum)		(MV_DDR_WIN_REGS_BASE + 0x184 + winNum * 0x8)
diff --git a/arch/arm/plat-armada/mv_hal/neta/gbe/mvNetaAddrDec.c b/arch/arm/plat-armada/mv_hal/neta/gbe/mvNetaAddrDec.c
index 8421d75..0a238bf 100644
--- a/arch/arm/plat-armada/mv_hal/neta/gbe/mvNetaAddrDec.c
+++ b/arch/arm/plat-armada/mv_hal/neta/gbe/mvNetaAddrDec.c
@@ -184,7 +184,7 @@ MV_STATUS mvNetaWinWrite(MV_U32 port, MV_U32 winNum, MV_UNIT_WIN_INFO *pAddrDecW
 	if (!MV_IS_POWER_OF_2(size)) {
 		/* try to get a good size */
 		pAddrDecWin->addrWin.size = 1 << (mvLog2(size) + 1);
-		mvOsPrintf("%s: WARN. Wrong window size %d, rounding to %d\n",
+		mvOsPrintf("%s: WARN. Wrong window size %d, rounding to %lld\n",
 			__func__, size, pAddrDecWin->addrWin.size);
 		size = pAddrDecWin->addrWin.size;
 	}
@@ -198,7 +198,7 @@ MV_STATUS mvNetaWinWrite(MV_U32 port, MV_U32 winNum, MV_UNIT_WIN_INFO *pAddrDecW
 	/* check if address is aligned to the size */
 	if (MV_IS_NOT_ALIGN(pAddrDecWin->addrWin.baseLow, pAddrDecWin->addrWin.size)) {
 		mvOsPrintf("mvNetaWinSet: Error setting Ethernet window %d.\n"
-			   "Address 0x%08x is unaligned to size 0x%x.\n",
+			   "Address 0x%08x is unaligned to size 0x%llx.\n",
 			   winNum, pAddrDecWin->addrWin.baseLow, pAddrDecWin->addrWin.size);
 		return MV_ERROR;
 	}
diff --git a/arch/arm/plat-armada/mv_hal/pex/mvPexAddrDec.c b/arch/arm/plat-armada/mv_hal/pex/mvPexAddrDec.c
index 75f8a00..ef8b451 100644
--- a/arch/arm/plat-armada/mv_hal/pex/mvPexAddrDec.c
+++ b/arch/arm/plat-armada/mv_hal/pex/mvPexAddrDec.c
@@ -661,7 +661,7 @@ MV_STATUS mvPexTargetWinRemap(MV_U32 pexIf, MV_U32 winNum, MV_PEX_REMAP_WIN *pAd
 
 	if (MV_IS_NOT_ALIGN(pAddrWin->addrWin.baseLow, PXWRR_REMAP_ALIGNMENT)) {
 		mvOsPrintf("mvPexTargetWinRemap: Error remap PEX interface %d win %d."
-			   "\nAddress 0x%08x is unaligned to size 0x%x.\n",
+			   "\nAddress 0x%08x is unaligned to size 0x%llx.\n",
 			   pexIf, winNum, pAddrWin->addrWin.baseLow, pAddrWin->addrWin.size);
 		return MV_ERROR;
 	}
diff --git a/arch/arm/plat-armada/mv_hal/sata/CoreDriver/mvSataAddrDec.c b/arch/arm/plat-armada/mv_hal/sata/CoreDriver/mvSataAddrDec.c
index 1d6f99a..20483fc 100644
--- a/arch/arm/plat-armada/mv_hal/sata/CoreDriver/mvSataAddrDec.c
+++ b/arch/arm/plat-armada/mv_hal/sata/CoreDriver/mvSataAddrDec.c
@@ -206,7 +206,7 @@ MV_STATUS mvSataWinWrite(MV_U32 dev, MV_U32 winNum, MV_UNIT_WIN_INFO *pAddrDecWi
 	/* check if address is aligned to the size */
 	if (MV_IS_NOT_ALIGN(pAddrDecWin->addrWin.baseLow, pAddrDecWin->addrWin.size)) {
 		mvOsPrintf("mvSataWinSet:Error setting SATA window %d.\n"
-			   "Address 0x%08x is unaligned to size 0x%x.\n",
+			   "Address 0x%08x is unaligned to size 0x%llx.\n",
 			   winNum, pAddrDecWin->addrWin.baseLow, pAddrDecWin->addrWin.size);
 		return MV_ERROR;
 	}
diff --git a/arch/arm/plat-armada/mv_hal/sdmmc/mvSdmmcAddrDec.c b/arch/arm/plat-armada/mv_hal/sdmmc/mvSdmmcAddrDec.c
index c58adce..1c91de4 100644
--- a/arch/arm/plat-armada/mv_hal/sdmmc/mvSdmmcAddrDec.c
+++ b/arch/arm/plat-armada/mv_hal/sdmmc/mvSdmmcAddrDec.c
@@ -200,7 +200,7 @@ MV_STATUS mvSdmmcWinWrite(MV_U32 dev, MV_U32 winNum, MV_UNIT_WIN_INFO *pAddrDecW
 	/* check if address is aligned to the size */
 	if (MV_IS_NOT_ALIGN(pAddrDecWin->addrWin.baseLow, pAddrDecWin->addrWin.size)) {
 		mvOsPrintf("mvSdmmcWinWrite:Error setting SDMMC window %d.\n"
-			   "Address 0x%08x is unaligned to size 0x%x.\n",
+			   "Address 0x%08x is unaligned to size 0x%llx.\n",
 			   winNum, pAddrDecWin->addrWin.baseLow, pAddrDecWin->addrWin.size);
 		return MV_ERROR;
 	}
diff --git a/arch/arm/plat-armada/mv_hal/usb/mvUsbAddrDec.c b/arch/arm/plat-armada/mv_hal/usb/mvUsbAddrDec.c
index cecafd4..2e04579 100644
--- a/arch/arm/plat-armada/mv_hal/usb/mvUsbAddrDec.c
+++ b/arch/arm/plat-armada/mv_hal/usb/mvUsbAddrDec.c
@@ -193,7 +193,7 @@ MV_STATUS mvUsbWinWrite(MV_U32 dev, MV_U32 winNum, MV_UNIT_WIN_INFO *pDecWin)
 	/* check if address is aligned to the size */
 	if (MV_IS_NOT_ALIGN(pDecWin->addrWin.baseLow, pDecWin->addrWin.size)) {
 		mvOsPrintf("mvUsbWinWrite:Error setting USB window %d.\n"
-			   "Address 0x%08x is unaligned to size 0x%x.\n",
+			   "Address 0x%08x is unaligned to size 0x%llx.\n",
 			   winNum, pDecWin->addrWin.baseLow, pDecWin->addrWin.size);
 		return MV_ERROR;
 	}
-- 
1.7.5.4

