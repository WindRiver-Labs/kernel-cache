From 75cc15f063c8e80ce4662053b3d06125665ca50a Mon Sep 17 00:00:00 2001
From: Nadav Haklai <nadavh@marvell.com>
Date: Tue, 29 Oct 2013 17:48:02 +0200
Subject: [PATCH 1123/1825] smp: a38x: Add SMP support for Armada 385 SoC

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 7c67d061da4acb0c20d93209fc871ac284a17418

	- Remove old pen release code
	- Clean CPU1 WA that was ported from A375
	- Fix CPU_RESUME_ADDR_REG to match the BootROM address
	- Temporary open window to the bootROM
	- Update A385 defconfig

Change-Id: I2bf03fc859cb029f3376df707767f99bb514d1c4
Signed-off-by: Nadav Haklai <nadavh@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/3903
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/configs/armada_385_v7smp_defconfig        |    7 +-
 arch/arm/mach-armada38x/Kconfig                    |   10 --
 .../armada_38x_family/ctrlEnv/sys/mvCpuIfRegs.h    |    3 +-
 arch/arm/mach-armada38x/ca9x2.h                    |    8 --
 arch/arm/mach-armada38x/core.c                     |   46 +---------
 arch/arm/mach-armada38x/headsmp.S                  |   35 --------
 arch/arm/mach-armada38x/platsmp.c                  |   90 +++-----------------
 arch/arm/mach-armada38x/sysmap.c                   |    2 +-
 8 files changed, 19 insertions(+), 182 deletions(-)

diff --git a/arch/arm/configs/armada_385_v7smp_defconfig b/arch/arm/configs/armada_385_v7smp_defconfig
index b71b26e..0d38acc 100644
--- a/arch/arm/configs/armada_385_v7smp_defconfig
+++ b/arch/arm/configs/armada_385_v7smp_defconfig
@@ -14,6 +14,7 @@ CONFIG_MODULE_UNLOAD=y
 CONFIG_ARCH_ARMADA38X=y
 # CONFIG_MV_INCLUDE_CESA is not set
 # CONFIG_MV_INCLUDE_TDM is not set
+CONFIG_MV_ETH_PORTS_NUM=2
 CONFIG_MV_ETH_TXQ=8
 # CONFIG_NET_SKB_RECYCLE is not set
 # CONFIG_MV_INCLUDE_USB is not set
@@ -23,12 +24,8 @@ CONFIG_MV_ETH_TXQ=8
 CONFIG_MV_ETH_TXQ_DESC=1024
 CONFIG_MV_ETH_DEBUG_CODE=y
 CONFIG_MV_ETH_STAT_DBG=y
-CONFIG_MV_ETH_GROUP0_CPU=0x3
+CONFIG_MV_ETH_GROUP0_CPU=0x1
 # CONFIG_SWP_EMULATE is not set
-CONFIG_PL310_ERRATA_588369=y
-CONFIG_PL310_ERRATA_727915=y
-CONFIG_PL310_ERRATA_753970=y
-CONFIG_PL310_ERRATA_769419=y
 CONFIG_PCI_DEBUG=y
 CONFIG_SMP=y
 CONFIG_NR_CPUS=2
diff --git a/arch/arm/mach-armada38x/Kconfig b/arch/arm/mach-armada38x/Kconfig
index 5aa37a1..fef3e29 100644
--- a/arch/arm/mach-armada38x/Kconfig
+++ b/arch/arm/mach-armada38x/Kconfig
@@ -4,16 +4,6 @@ config MV_HAL_RULES_PATH
 	string "path of the mvRules.mk file for HAL drivers"
 	default "arch/arm/mach-armada38x/mv_hal_support/mvRules.mk"
 
-config A38X_CPU1_ENABLE_WA
-	depends on SMP
-	bool "SMP CPU1 Enable WA"
-	default y
-	help
-	  Due to internal bootrom issue, CPU[1] initial jump code
-	  (four instructions) should be placed in SoC SRAM memory.
-	  Furthermore, MMU and SoC memory windows should be configured
-	  appropriately to enable CPU[1] to boot.
-
 menu "Marvell Armada-38x Options"
 
 config ARMADA_38X
diff --git a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/sys/mvCpuIfRegs.h b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/sys/mvCpuIfRegs.h
index b80b8e2..fb6cf6d 100644
--- a/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/sys/mvCpuIfRegs.h
+++ b/arch/arm/mach-armada38x/armada_38x_family/ctrlEnv/sys/mvCpuIfRegs.h
@@ -83,7 +83,8 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define CPU_CTRL_STAT_REG(cpu)			(MV_CPUIF_REGS_BASE(cpu) + 0x8)
 
 #define PCIE_BOOT_ADDR_REG			(MV_MISC_REGS_BASE + 0xD4)
-#define CPU_RESUME_ADDR_REG			(PCIE_BOOT_ADDR_REG)
+
+#define CPU_RESUME_ADDR_REG(cpu)		(MV_CPUIF_SHARED_REGS_BASE + (0x2124) + (cpu)*0x100)
 
 #define CPU_SOFT_RESET_REG(cpu)			(MV_MBUS_REGS_OFFSET + 0x800 + (cpu) * 0x8)
 
diff --git a/arch/arm/mach-armada38x/ca9x2.h b/arch/arm/mach-armada38x/ca9x2.h
index 6a1cb16..5e4a738 100644
--- a/arch/arm/mach-armada38x/ca9x2.h
+++ b/arch/arm/mach-armada38x/ca9x2.h
@@ -1,14 +1,6 @@
 #ifndef __MACH_MV_CA9X2_H
 #define __MACH_MV_CA9X2_H
 
-#if defined(CONFIG_SMP) && defined(CONFIG_A38X_CPU1_ENABLE_WA)
-void a38x_secondary_startup(void);
-void a38x_smp_cpu1_enable_wa(void);
-
-extern void *a38x_smp_cpu1_enable_code_start;
-extern void *a38x_smp_cpu1_enable_code_end;
-#endif
-
 /*
  * Physical base addresses
  */
diff --git a/arch/arm/mach-armada38x/core.c b/arch/arm/mach-armada38x/core.c
index 8a997c1..2a613cc 100644
--- a/arch/arm/mach-armada38x/core.c
+++ b/arch/arm/mach-armada38x/core.c
@@ -659,10 +659,12 @@ static void __init eth_init(void)
 	    (mvCtrlPwrClckGet(ETH_GIG_UNIT_ID, 1))) {
 		mv_neta_giga_pdev_register(&mv_neta_ge1_plat);
 	}
+#if 0
 	if ((devId != MV_6810_DEV_ID) && (mvUnitMapIsMine(ETH2) == MV_TRUE) &&
 	    (mvCtrlPwrClckGet(ETH_GIG_UNIT_ID, 2))) {
 		mv_neta_giga_pdev_register(&mv_neta_ge2_plat);
 	}
+#endif
 #endif /* CONFIG_MV_ETH_NETA) || CONFIG_MV_ETH_NETA_MODULE */
 }
 #endif /* CONFIG_MV_ETHERNET */
@@ -1103,48 +1105,6 @@ static void print_board_info(void)
 }
 
 /*******************************************************************************
- * SMP WA to enable CPU1
- * Note: This function is called before PUnit IO windows are configured.
- */
-#if defined(CONFIG_SMP) && defined(CONFIG_A38X_CPU1_ENABLE_WA)
-
-void a38x_smp_cpu1_enable_wa(void)
-{
-	MV_AHB_TO_MBUS_DEC_WIN mbus_win;
-	u32 code_len, win_num, sram_phys_base = 0xFFFF0000;
-	void __iomem *sram_virt_base;
-
-	mbus_win.target			= CRYPT0_ENG;
-	mbus_win.addrWin.baseLow	= sram_phys_base;
-	mbus_win.addrWin.baseHigh	= 0x0;
-	mbus_win.addrWin.size		= SZ_64K;
-	mbus_win.enable			= MV_TRUE;
-
-	if (mvAhbToMbusWinNumByTargetGet(CRYPT0_ENG, &win_num) != MV_OK) {
-		pr_err("%s: Error: mvAhbToMbusWinNumByTargetGet(target = %d) failed\n",
-		       __func__, CRYPT0_ENG);
-		return;
-	}
-
-	if (mvAhbToMbusWinSet(win_num, &mbus_win) != MV_OK) {
-		pr_err("%s: Error: mvAhbToMbusWinSet(win_num = %d) failed\n",
-		       __func__, win_num);
-		return;
-	}
-
-	sram_virt_base = ioremap(sram_phys_base, SZ_64K);
-
-	code_len = 4 * (&a38x_smp_cpu1_enable_code_end - &a38x_smp_cpu1_enable_code_start);
-	memcpy(sram_virt_base, &a38x_smp_cpu1_enable_code_start, code_len);
-}
-#else
-void a38x_smp_cpu1_enable_wa(void)
-{
-	/* nothing */
-}
-#endif
-
-/*******************************************************************************
  * IOCC sync implementation
  */
 #ifdef CONFIG_AURORA_IO_CACHE_COHERENCY
@@ -1236,7 +1196,7 @@ static void __init a38x_init_iocc(void)
 	scu_enable(scu_base);
 #endif
 
-	dma_io_sync_wa_init();
+/*	dma_io_sync_wa_init(); */
 
 	return;
 }
diff --git a/arch/arm/mach-armada38x/headsmp.S b/arch/arm/mach-armada38x/headsmp.S
index 2c12869..956bfa3 100644
--- a/arch/arm/mach-armada38x/headsmp.S
+++ b/arch/arm/mach-armada38x/headsmp.S
@@ -3,24 +3,6 @@
 
 	__INIT
 
-#ifdef CONFIG_A38X_CPU1_ENABLE_WA
-
-#define CPU_RESUME_ADDR_REG 0xf10182d4
-
-.global a38x_smp_cpu1_enable_code_start
-.global a38x_smp_cpu1_enable_code_end
-
-ENTRY(a38x_smp_cpu1_enable_code_start)
-a38x_smp_cpu1_enable_code_start:
-	ldr	r0, [pc, #4]
-	ldr	r1, [r0]
-	mov	pc, r1
-	.word	CPU_RESUME_ADDR_REG
-a38x_smp_cpu1_enable_code_end:
-ENDPROC(a38x_smp_cpu1_enable_code_end)
-
-#endif /* CONFIG_A38X_CPU1_ENABLE_WA */
-
 /*
  *   The secondary kernel init calls v7_flush_dcache_all before it enables
  *   the L1; however, the L1 comes out of reset in an undefined state, so
@@ -69,22 +51,5 @@ ENDPROC(v7_invalidate_l1)
  */
 ENTRY(a38x_secondary_startup)
 	bl      v7_invalidate_l1
-	mrc	p15, 0, r0, c0, c0, 5
-	and	r0, r0, #15
-	adr	r4, 1f
-	ldmia	r4, {r5, r6}
-	sub	r4, r4, r5
-	add	r6, r6, r4
-pen:	ldr	r7, [r6]
-	cmp	r7, r0
-	bne	pen
-
-	/*
-	 * we've been released from the holding pen: secondary_stack
-	 * should now contain the SVC stack for this core
-	 */
 	b	secondary_startup
 
-	.align
-1:	.long	.
-	.long	pen_release
diff --git a/arch/arm/mach-armada38x/platsmp.c b/arch/arm/mach-armada38x/platsmp.c
index dca1f6f..d67a5e5 100644
--- a/arch/arm/mach-armada38x/platsmp.c
+++ b/arch/arm/mach-armada38x/platsmp.c
@@ -53,100 +53,32 @@ void __init platform_smp_prepare_cpus(unsigned int max_cpus)
 	 */
 	scu_enable(scu_base);
 
-	a38x_smp_cpu1_enable_wa();
-
-	/*
-	 * Write the address of secondary startup into the
-	 * system-wide flags register. The boot monitor waits
-	 * until it receives a soft interrupt, and then the
-	 * secondary CPU branches to this address.
-	 */
-	writel(virt_to_phys(a38x_secondary_startup),
-	       INTER_REGS_VIRT_BASE + CPU_RESUME_ADDR_REG);
 }
 
-/*
- * control for which core is the next to come out of the secondary
- * boot "holding pen"
- */
-int __cpuinitdata pen_release = -1;
-
-/*
- * Write pen_release in a way that is guaranteed to be visible to all
- * observers, irrespective of whether they're taking part in coherency
- * or not.  This is necessary for the hotplug code to work reliably.
- */
-static void __cpuinit write_pen_release(int val)
-{
-	pen_release = val;
-	smp_wmb();
-	__cpuc_flush_dcache_area((void *)&pen_release, sizeof(pen_release));
-	outer_clean_range(__pa(&pen_release), __pa(&pen_release + 1));
-}
-
-static DEFINE_SPINLOCK(boot_lock);
-
 void __cpuinit platform_secondary_init(unsigned int cpu)
 {
-	/*
-	 * if any interrupts are already enabled for the primary
-	 * core (e.g. timer irq), then they will not have been enabled
-	 * for us: do so
-	 */
 	gic_secondary_init(0);
-
-	/*
-	 * let the primary processor know we're out of the
-	 * pen, then head off into the C entry point
-	 */
-	write_pen_release(-1);
-
-	/*
-	 * Synchronise with the boot thread.
-	 */
-	spin_lock(&boot_lock);
-	spin_unlock(&boot_lock);
 }
 
 int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
-	unsigned long timeout;
+	/* Open windows to bootROM - need to fix */
+	writel(0xf1d11, 0x20098 + INTER_REGS_VIRT_BASE);
+	writel(0xfff00000, 0x2009c + INTER_REGS_VIRT_BASE);
 
 	/*
-	 * Set synchronisation state between this boot processor
-	 * and the secondary one
-	 */
-
-	spin_lock(&boot_lock);
-
-	/*
-	 * This is really belt and braces; we hold unintended secondary
-	 * CPUs in the holding pen until we're ready for them.  However,
-	 * since we haven't sent them a soft interrupt, they shouldn't
-	 * be there.
-	 */
-	write_pen_release(cpu_logical_map(cpu));
-
+	* Write the address of secondary startup into the
+	* system-wide flags register. The boot monitor waits
+	* until it receives a soft interrupt, and then the
+	* secondary CPU branches to this address.
+	*/
+	writel(virt_to_phys(a38x_secondary_startup),
+	       INTER_REGS_VIRT_BASE + CPU_RESUME_ADDR_REG(cpu));
 	/*
 	 * Get CPU out of software reset state.
 	 */
 	writel(0, CPU_SOFT_RESET_REG(cpu_logical_map(cpu)) +
 	       INTER_REGS_VIRT_BASE);
 
-	timeout = jiffies + (1 * HZ);
-	while (time_before(jiffies, timeout)) {
-		smp_rmb();
-		if (pen_release == -1)
-			break;
-
-		udelay(10);
-	}
-
-	/*
-	 * now the secondary core is starting up let it run its
-	 * calibrations, then wait for it to finish
-	 */
-	spin_unlock(&boot_lock);
-
-	return pen_release != -1 ? -ENOSYS : 0;
+	return 0;
 }
diff --git a/arch/arm/mach-armada38x/sysmap.c b/arch/arm/mach-armada38x/sysmap.c
index cdbdc07..ba3b6b1 100644
--- a/arch/arm/mach-armada38x/sysmap.c
+++ b/arch/arm/mach-armada38x/sysmap.c
@@ -64,7 +64,7 @@ MV_CPU_DEC_WIN SYSMAP_A38X_68XX[] = {
 	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS}, /* SPI_CS5 */
 	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS}, /* SPI_CS6 */
 	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS}, /* SPI_CS7 */
-	{{BOOTROM_PHYS_BASE,		0,	BOOTROM_SIZE		},	9,		DIS}, /* BOOTROM */
+	{{BOOTROM_PHYS_BASE,		0,	BOOTROM_SIZE		},	9,		EN}, /* BOOTROM */
 	{{DEVICE_BOOTCS_PHYS_BASE,	0,	DEVICE_BOOTCS_SIZE	},	10,		 EN}, /* DEV_BOOCS */
 	{{USB3_REGS_PHYS_BASE,		0,	USB3_REGS_SIZE		},	11,		 EN}, /* USB3 */
 	{{CRYPT_ENG_PHYS_BASE(0),	0,	CRYPT_ENG_SIZE		},	12,		 EN}, /* CRYPT_ENG */
-- 
1.7.5.4

