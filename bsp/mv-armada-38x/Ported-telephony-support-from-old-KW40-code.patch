From a1619bf15577d2e0a622b3fa4b9a70d758bc2d18 Mon Sep 17 00:00:00 2001
From: Yehuda Yitschak <yehuday@marvell.com>
Date: Thu, 15 Nov 2012 11:24:42 +0200
Subject: [PATCH 0366/1825] Ported telephony support from old KW40 code

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 4e07906c11db231167239c72b8417ba584d4d036

Change-Id: I9bd3e15cdccf471c983feba85e120052dc11bb45
Signed-off-by: Yehuda Yitschak <yehuday@marvell.com>
Signed-off-by: Kosta Zertsekel <konszert@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../plat-armada/mv_drivers_lsp/mv_phone/Kconfig    |   78 +-
 .../plat-armada/mv_drivers_lsp/mv_phone/Makefile   |   41 +-
 .../mv_drivers_lsp/mv_phone/slic/vpapi_dev.c       | 1024 ++++++++++++++++++++
 .../mv_drivers_lsp/mv_phone/slic/vpapi_dev.h       |  265 +++++
 .../plat-armada/mv_drivers_lsp/mv_phone/tdm/tal.c  |  158 +++
 .../plat-armada/mv_drivers_lsp/mv_phone/tdm/tal.h  |   73 ++
 .../mv_drivers_lsp/mv_phone/tdm/tdm_if.c           |  522 ++++++++++
 .../mv_drivers_lsp/mv_phone/tdm/tdm_if.h           |  118 +++
 .../mv_drivers_lsp/mv_phone/tdm/test/Makefile      |   12 +
 .../mv_drivers_lsp/mv_phone/tdm/test/tdm_dev.c     |  394 ++++++++
 .../mv_drivers_lsp/mv_phone/tdm/test/tdm_dev.h     |   86 ++
 .../mv_hal/voiceband/commUnit/mvCommUnit.c         |  769 ++++++++++-----
 .../mv_hal/voiceband/commUnit/mvCommUnit.h         |   16 +-
 .../mv_hal/voiceband/commUnit/mvCommUnitRegs.h     |  135 ++-
 .../arm/plat-armada/mv_hal/voiceband/mvCompVer.txt |    1 -
 .../arm/plat-armada/mv_hal/voiceband/mvSysTdmSpi.h |   42 +-
 arch/arm/plat-armada/mv_hal/voiceband/tdm/mvTdm.c  |   71 +-
 arch/arm/plat-armada/mv_hal/voiceband/tdm/mvTdm.h  |    9 +-
 .../plat-armada/mv_hal/voiceband/tdm/mvTdmRegs.h   |   89 +-
 19 files changed, 3439 insertions(+), 464 deletions(-)
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_phone/slic/vpapi_dev.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_phone/slic/vpapi_dev.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/tal.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/tal.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/tdm_if.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/tdm_if.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/test/Makefile
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/test/tdm_dev.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/test/tdm_dev.h

diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/Kconfig b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/Kconfig
index 7710d8b..2d21470 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/Kconfig
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/Kconfig
@@ -4,39 +4,41 @@ menu "Telephony options"
 config  MV_PHONE
 	bool "Support for Marvell telephony(VoIP)"
 	depends on MV_INCLUDE_TDM && PHONE
-	default m
+	default y
 	---help---
-	  Choosing this option enables the Marvell telephony underlying 
-	  support for various VoIP applications. 
+	  Choosing this option enables the Marvell telephony underlying
+	  support for various VoIP applications.
 	  Note, kernel Telephony subsystem must be chosen too.
 
-choice 
-	prompt "TDM unit"
+choice
+	prompt "TDM Unit"
 	depends on MV_PHONE
+	default MV_TDM_SUPPORT
 
 config MV_TDM_SUPPORT
 	bool "Support legacy TDM(2 channels)"
 
 config MV_COMM_UNIT_SUPPORT
-	depends on ARCH_FEROCEON_KW2
+	depends on ARCH_FEROCEON_KW2 || ARCH_ARMADA_XP
 	bool "Support CommUnit(up to 32 channels)"
 
 endchoice
 
-choice 
-	prompt "SLIC vendor"
+choice
+	prompt "SLIC Vendor"
 	depends on MV_PHONE
+	default ZARLINK_SLIC_SUPPORT
 
-config SILABS_SLIC_SUPPORT
-	bool "Support Silicon Labs devices"
+#config SILABS_SLIC_SUPPORT
+#	bool "Support Silicon Labs devices"
 
 config ZARLINK_SLIC_SUPPORT
 	bool "Support Zarlink/Legirity devices"
 
 endchoice
 
-choice 
-	prompt "SLIC type"
+choice
+	prompt "SLIC Device"
 	depends on MV_PHONE && SILABS_SLIC_SUPPORT
 
 config SILABS_SLIC_3215
@@ -47,9 +49,10 @@ config SILABS_SLIC_3217
 
 endchoice
 
-choice 
-	prompt "SLIC type"
+choice
+	prompt "SLIC Device"
 	depends on MV_PHONE && ZARLINK_SLIC_SUPPORT
+	default ZARLINK_SLIC_VE880
 
 config ZARLINK_SLIC_VE880
 	bool "Support Zarlink VE880 SLIC family"
@@ -59,6 +62,32 @@ config ZARLINK_SLIC_VE792
 
 endchoice
 
+choice
+	prompt "PCM Clock Frequency"
+	depends on MV_PHONE
+	default MV_TDM_PCM_CLK_8MHZ
+	---help---
+	This menu selects the PCM clock frequency generated by the TDM master.
+	SLIC should be configured accordingly in order to maintain bus coherency.
+
+config MV_TDM_PCM_CLK_8MHZ
+	bool "Support 8MHz PCM clock"
+
+config MV_TDM_PCM_CLK_4MHZ
+	bool "Support 4MHz PCM clock"
+
+config MV_TDM_PCM_CLK_2MHZ
+	bool "Support 2MHz PCM clock"
+
+endchoice
+
+config MV_PHONE_USE_IRQ_PROCESSING
+	bool "Support Rx/Tx processing in interrupt context"
+	depends on MV_PHONE
+	default n
+	---help---
+	Choosing this option supports Rx/Tx voice processing in interrupt context, otherwise
+	processing is performed in tasklet context.
 
 config MV_TDM_USE_EXTERNAL_PCLK_SOURCE
 	bool "Support PCLK from external source"
@@ -67,27 +96,12 @@ config MV_TDM_USE_EXTERNAL_PCLK_SOURCE
 	---help---
 	Choosing this option enables TDM unit to use PCLK supplied by external source.
 
-config TDM_DEV_TEST_SUPPORT
-	bool "Support tdm testing"
-	depends on MV_INCLUDE_TDM
-	help
-	   The tdm testing device supports several basic telephony tests on Marvell TDM based platforms.
-
 config MV_PHONE_USE_SLIC_LIBS
-	bool "Use binary slic drivers"
+	bool "Use binary SLIC drivers"
+	depends on MV_PHONE
 	default y
 	---help---
-	Unselect this option only if you have source code of slic drivers.
+	Unselect this option only if you have source code of SLIC drivers.
 	If unsure, say "y"
 
-config MV_COMM_UNIT_FSYNC_STRB_SUPPORT
-	bool "Use CommUnit strobe pin as frame sync source"
-	default y
-	depends on MV_COMM_UNIT_SUPPORT
-	help
-	  The CommUnit frame sync 1/2/3 bit delay feature is not working in Z1 silicon revision, therefore
-	  the strobe pin can be used as tunable frame sync source.
-
 endmenu
-
-
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/Makefile b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/Makefile
index b8015aa..7bbfe78 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/Makefile
@@ -1,13 +1,19 @@
+
 #
 # Makefile for the Marvell Phone Device Driver
 #
-ifneq ($(MACHINE),)
-include $(srctree)/$(MACHINE)/config/mvRules.mk
+#
+
+ifeq ($(CONFIG_PLAT_ARMADA),y)
+	include $(srctree)/$(MACHINE)/config/mvRules.mk
 endif
 
 VB_SRC_PATH = ../../mv_hal/voiceband
+LSP_TDM_PATH = tdm
+LSP_SLIC_PATH = slic
+LSP_TDM_TEST_PATH = tdm/test
 
-obj-$(CONFIG_MV_TDM) += mv_phone.o
+obj-$(CONFIG_MV_INCLUDE_TDM) += mv_phone.o
 
 ifeq ($(CONFIG_MV_TDM_SUPPORT),y)
 	PHONE_OBJS = $(VB_SRC_PATH)/tdm/mvTdm.o $(VB_SRC_PATH)/tdm/mvTdmAddrDec.o
@@ -15,7 +21,7 @@ else # CONFIG_MV_COMM_UNIT_SUPPORT
 	PHONE_OBJS = $(VB_SRC_PATH)/commUnit/mvCommUnit.o $(VB_SRC_PATH)/commUnit/mvCommUnitAddrDec.o
 endif
 
-PHONE_OBJS += tdm_if.o tal.o ../../../../../$(MACHINE)/mv_hal_if/mvSysTdm.o
+PHONE_OBJS += $(LSP_TDM_PATH)/tdm_if.o $(LSP_TDM_PATH)/tal.o ../../../../../$(MACHINE)/mv_hal_if/mvSysTdm.o
 
 EXTRA_CFLAGS += -DMV_KERNEL_SLIC_SUPPORT
 
@@ -25,8 +31,8 @@ ifeq ($(CONFIG_SILABS_SLIC_SUPPORT),y)
 	SILABS_BASE_PATH = $(VB_SRC_PATH)/slic/silabs/
 	SILABS_SRC_PATH = $(SILABS_BASE_PATH)/src
 	SILABS_CUSTOM_PATH = $(SILABS_BASE_PATH)/custom
-	EXTRA_CFLAGS += -I$(srctree)/$(MACHINE)/../plat-feroceon/mv_hal/voiceband/slic/silabs/inc \
-			-I$(srctree)/$(MACHINE)/../plat-feroceon/mv_hal/voiceband/slic/silabs/custom
+	EXTRA_CFLAGS += -I$(srctree)/$(MACHINE)/../plat-armada/mv_hal/voiceband/slic/silabs/inc \
+			-I$(srctree)/$(MACHINE)/../plat-armada/mv_hal/voiceband/slic/silabs/custom
 
 
 SILABS_OBJS = $(SILABS_SRC_PATH)/proslic.o $(SILABS_SRC_PATH)/proslic_version.o
@@ -51,9 +57,9 @@ ifeq ($(CONFIG_ZARLINK_SLIC_VE880),y)
 	ZARLINK_ARCH_MARVELL_PATH = $(VB_SRC_PATH)/slic/zarlink/arch_marvell
 	ZARLINK_VP880API_SRC_PATH = $(ZARLINK_BASE_PATH)/vp880_api
 
-	EXTRA_CFLAGS += -I$(srctree)/$(MACHINE)/../plat-feroceon/mv_hal/voiceband/slic/zarlink/api_lib/includes \
-			-I$(srctree)/$(MACHINE)/../plat-feroceon/mv_hal/voiceband/slic/zarlink/arch_marvell \
-			-I$(srctree)/$(MACHINE)/../plat-feroceon/mv_hal/voiceband/slic/zarlink/api_lib/vp880_api
+	EXTRA_CFLAGS += -I$(srctree)/$(MACHINE)/../plat-armada/mv_hal/voiceband/slic/zarlink/api_lib/includes \
+			-I$(srctree)/$(MACHINE)/../plat-armada/mv_hal/voiceband/slic/zarlink/arch_marvell \
+			-I$(srctree)/$(MACHINE)/../plat-armada/mv_hal/voiceband/slic/zarlink/api_lib/vp880_api
 
 	ZARLINK_OBJS =  $(ZARLINK_COMMON_SRC_PATH)/vp_api.o  $(ZARLINK_COMMON_SRC_PATH)/vp_api_common.o \
 			$(ZARLINK_COMMON_SRC_PATH)/vp_api_cslac_seq.o $(ZARLINK_COMMON_SRC_PATH)/vp_debug.o \
@@ -61,7 +67,7 @@ ifeq ($(CONFIG_ZARLINK_SLIC_VE880),y)
 			$(ZARLINK_VP880API_SRC_PATH)/apiCal.o $(ZARLINK_VP880API_SRC_PATH)/apicnt.o \
 			$(ZARLINK_VP880API_SRC_PATH)/apiInit.o $(ZARLINK_VP880API_SRC_PATH)/apiquery.o \
 			$(ZARLINK_VP880API_SRC_PATH)/apiseq.o
-	
+
 	SLIC_LIB_NAME=zarlink_880.lib
 endif
 
@@ -72,9 +78,9 @@ ifeq ($(CONFIG_ZARLINK_SLIC_VE792),y)
 	ZARLINK_ARCH_MARVELL_PATH = $(VB_SRC_PATH)/slic/zarlink/arch_marvell
 	ZARLINK_VP792API_SRC_PATH = $(ZARLINK_BASE_PATH)/vp792_api
 
-	EXTRA_CFLAGS += -I$(srctree)/$(MACHINE)/../plat-feroceon/mv_hal/voiceband/slic/zarlink/vp792_api_lib/includes \
-			-I$(srctree)/$(MACHINE)/../plat-feroceon/mv_hal/voiceband/slic/zarlink/arch_marvell \
-			-I$(srctree)/$(MACHINE)/../plat-feroceon/mv_hal/voiceband/slic/zarlink/vp792_api_lib/vp792_api
+	EXTRA_CFLAGS += -I$(srctree)/$(MACHINE)/../plat-armada/mv_hal/voiceband/slic/zarlink/vp792_api_lib/includes \
+			-I$(srctree)/$(MACHINE)/../plat-armada/mv_hal/voiceband/slic/zarlink/arch_marvell \
+			-I$(srctree)/$(MACHINE)/../plat-armada/mv_hal/voiceband/slic/zarlink/vp792_api_lib/vp792_api
 
 	ZARLINK_OBJS =  $(ZARLINK_COMMON_SRC_PATH)/vp_api_config.o  $(ZARLINK_COMMON_SRC_PATH)/vp_api_common.o \
 			$(ZARLINK_COMMON_SRC_PATH)/vp_api_init.o  $(ZARLINK_COMMON_SRC_PATH)/vp_api_query.o \
@@ -84,23 +90,22 @@ ifeq ($(CONFIG_ZARLINK_SLIC_VE792),y)
 			$(ZARLINK_VP792API_SRC_PATH)/vp792_control.o $(ZARLINK_VP792API_SRC_PATH)/vp792_init.o \
 			$(ZARLINK_VP792API_SRC_PATH)/vp792_query.o $(ZARLINK_VP792API_SRC_PATH)/vp792_firmware.o \
 			$(ZARLINK_ARCH_MARVELL_PATH)/Le71HP0410G_init.o
-			
+
 	SLIC_LIB_NAME=zarlink_792.lib
 
 endif
 
-PHONE_OBJS += vpapi_dev.o
+PHONE_OBJS += $(LSP_SLIC_PATH)/vpapi_dev.o
 
 endif
 
 ifeq ($(CONFIG_MV_PHONE_USE_SLIC_LIBS),y)
 $(obj)/lib.a:
-	cp $(obj)/libs/$(SLIC_LIB_NAME) $(obj)/lib.a
+	cp $(obj)/$(LSP_SLIC_PATH)/libs/$(SLIC_LIB_NAME) $(obj)/lib.a
 else
 	lib-$(CONFIG_ZARLINK_SLIC_SUPPORT) := $(ZARLINK_OBJS) $(SILABS_OBJS)
 endif
 
-obj-y := mv_phone.o test/
+obj-y := mv_phone.o $(LSP_TDM_TEST_PATH)/
 
 mv_phone-objs := $(PHONE_OBJS) lib.a
-
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/slic/vpapi_dev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/slic/vpapi_dev.c
new file mode 100644
index 0000000..87add03
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/slic/vpapi_dev.c
@@ -0,0 +1,1024 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include "vpapi_dev.h"
+
+/* Defines */
+#define GET_DEV_STATUS(deviceId)	vpapi_dev_status[deviceId]
+#define GET_LINE_STATUS(lineId)		vpapi_line_status[lineId]
+#define REGISTER_DEVICE(deviceId)	\
+	vpapi_dev_status[deviceId] = 1;
+#define REGISTER_LINE(lineId)		\
+	vpapi_line_status[lineId] = 1;
+
+#define MAX_PROFILE_SIZE		128
+#define GET_DEVICE(lineId)		(lineId/MAX_LINES_PER_DEVICE)
+#define GET_LINE(lineId)		(lineId % MAX_LINES_PER_DEVICE)
+#define MAX_EVENT_QUEUE_SIZE		256
+#define VPAPI_TICK_TIMER_PERIOD		1
+#define VPAPI_MOD_NAME                  "vpapi"
+
+/* VE880 */
+#if defined(CONFIG_ZARLINK_SLIC_VE880)
+
+#define MAX_DEVICES			2
+#define MAX_LINES			4
+#define MAX_LINES_PER_DEVICE		2
+
+static VpDevCtxType pDevCtx[MAX_DEVICES];
+static VpLineCtxType pLineCtx[MAX_DEVICES][MAX_LINES_PER_DEVICE];
+static Vp880DeviceObjectType pDevObj[MAX_DEVICES];
+static Vp880LineObjectType pLineObj[MAX_DEVICES][MAX_LINES_PER_DEVICE];
+
+/* VE792 */
+#elif defined(CONFIG_ZARLINK_SLIC_VE792)
+
+#define MAX_DEVICES			4
+#define MAX_LINES			32
+#define MAX_LINES_PER_DEVICE		8
+
+static VpDevCtxType pDevCtx[MAX_DEVICES];
+static VpLineCtxType pLineCtx[MAX_DEVICES][MAX_LINES_PER_DEVICE];
+static Vp792DeviceObjectType pDevObj[MAX_DEVICES];
+static Vp792LineObjectType pLineObj[MAX_DEVICES][MAX_LINES_PER_DEVICE];
+
+extern int BattOn(int vbhSetting, int vblSetting, int vbpSetting);
+extern int BattOff(void);
+
+#endif
+
+static void vpapi_tick_handler(unsigned long data);
+static ssize_t vpapi_read(struct file *file, char __user *buf, size_t size, loff_t * ppos);
+static ssize_t vpapi_write(struct file *file, const char __user *buf, size_t size, loff_t * ppos);
+static unsigned int vpapi_poll(struct file *pFile, poll_table *pPollTable);
+static int vpapi_ioctl(struct inode *pInode, struct file *pFile, unsigned int cmd, unsigned long arg);
+#ifdef HAVE_UNLOCKED_IOCTL
+static long vpapi_unlocked_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
+#endif
+static int vpapi_open(struct inode *pInode, struct file *pFile);
+static int vpapi_release(struct inode *pInode, struct file *pFile);
+//static int __init vpapi_module_init(void);
+//static void __exit vpapi_module_exit(void);
+
+/* VP-API-II Dispatchers */
+static int vpapi_make_dev_object(unsigned long arg);
+static int vpapi_make_line_object(unsigned long arg);
+static int vpapi_map_line_id(unsigned long arg);
+static int vpapi_map_slac_id(unsigned long arg);
+static int vpapi_free_line_context(unsigned long arg);
+static int vpapi_init_device(unsigned long arg);
+static int vpapi_cal_line(unsigned long arg);
+static int vpapi_set_line_state(unsigned long arg);
+static int vpapi_set_option(unsigned long arg);
+int vpapi_get_event(unsigned long arg);
+#if defined(CONFIG_ZARLINK_SLIC_VE792)
+static int vpapi_batt_on(unsigned long arg);
+static int vpapi_batt_off(unsigned long arg);
+#endif
+#if defined(CONFIG_ZARLINK_SLIC_VE880)
+static int vpapi_reg_read(unsigned long arg);
+static int vpapi_reg_write(unsigned long arg);
+#endif
+
+/* Enumurators */
+typedef struct {
+	unsigned char valid;		/* valid event */
+	VpEventType vp_event;
+} vpapi_event;
+
+
+/* Structs */
+static struct file_operations vpapi_fops = {
+    owner:      THIS_MODULE,
+    llseek:     NULL,
+    read:       vpapi_read,
+    write:      vpapi_write,
+    poll:       vpapi_poll,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)
+    ioctl:	vpapi_ioctl,
+#endif
+#ifdef HAVE_UNLOCKED_IOCTL
+    unlocked_ioctl: vpapi_unlocked_ioctl,
+#endif
+    open:       vpapi_open,
+    release:    vpapi_release,
+    fasync:     NULL
+};
+
+/* Globals */
+static DEFINE_SPINLOCK(vpapi_lock);
+static DECLARE_WAIT_QUEUE_HEAD(vpapi_wait);
+static atomic_t event_count;
+static atomic_t vpapi_init;
+static atomic_t vpapi_in_ioctl;
+static vpapi_event event_queue[MAX_EVENT_QUEUE_SIZE];
+static u8 vpapi_dev_status[MAX_DEVICES];
+static u8 vpapi_line_status[MAX_LINES];
+static volatile u32 next_event = 0, curr_event = 0;
+static struct timer_list vpapi_timer;
+static u16 total_devs = 0, total_lines = 0;
+
+
+static struct miscdevice vpapi_misc_dev = {
+	.minor = SLICDEV_MINOR,
+	.name = VPAPI_MOD_NAME,
+	.fops = &vpapi_fops,
+};
+
+static ssize_t vpapi_read(struct file *file, char __user *buf, size_t size, loff_t * ppos)
+{
+	return 0;
+}
+
+static ssize_t vpapi_write(struct file *file, const char __user *buf, size_t size, loff_t * ppos)
+{
+	return 0;
+}
+
+static unsigned int vpapi_poll(struct file *pFile, poll_table *pPollTable)
+{
+	int mask = 0;
+
+	poll_wait(pFile, &vpapi_wait, pPollTable);
+
+	if(atomic_read(&event_count) > 0) {
+		mask |= POLLPRI;
+	}
+
+	return mask;
+}
+
+static int vpapi_ioctl(struct inode *pInode, struct file *pFile, unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+
+	/* Argument checking */
+	if (_IOC_TYPE(cmd) != VPAPI_MOD_IOCTL_MAGIC) {
+		printk("%s: invalid VPAPI MOD Magic Num %i %i\n", __func__, _IOC_TYPE(cmd), VPAPI_MOD_IOCTL_MAGIC);
+		return -ENOTTY;
+	}
+
+	if ((_IOC_NR(cmd) > VPAPI_MOD_IOCTL_MAX) || (_IOC_NR(cmd) < VPAPI_MOD_IOCTL_MIN)) {
+		printk("%s: invalid VPAPI MOD IOCTL request\n", __func__);
+		return -ENOTTY;
+	}
+
+	if (_IOC_DIR(cmd) & _IOC_READ) {
+		ret = !access_ok(VERIFY_WRITE, (void __user*)arg, _IOC_SIZE(cmd));
+	}
+	else if (_IOC_DIR(cmd) & _IOC_WRITE) {
+		ret = !access_ok(VERIFY_READ, (void __user*)arg, _IOC_SIZE(cmd));
+	}
+
+	if (ret) {
+		printk("%s: invalid VPAPI MOD access type %i from cmd %i\n", __func__, _IOC_DIR(cmd), cmd);
+		return -EFAULT;
+	}
+
+#if defined(SLIC_TIMER_EVENT_SUPPORT)
+	/* Disable timer routine processing */
+	atomic_set(&vpapi_in_ioctl, 1);
+#endif
+
+	switch (cmd) {
+		case VPAPI_MOD_IOX_MK_DEV_OBJ:
+			//printk("ioctl: VPAPI_MOD_IOX_MK_DEV_OBJ\n");
+			ret = vpapi_make_dev_object(arg);
+			break;
+
+		case VPAPI_MOD_IOX_MK_LN_OBJ:
+			//printk("ioctl: VPAPI_MOD_IOX_MK_LN_OBJ\n");
+			ret = vpapi_make_line_object(arg);
+			break;
+
+		case VPAPI_MOD_IOX_MAP_LN_ID:
+			//printk("ioctl: VPAPI_MOD_IOX_MAP_LN_ID\n");
+			ret = vpapi_map_line_id(arg);
+			break;
+
+		case VPAPI_MOD_IOX_MAP_SLAC_ID:
+			//printk("ioctl: VPAPI_MOD_IOX_MAP_SLAC_ID\n");
+			ret  = vpapi_map_slac_id(arg);
+			break;
+
+		case VPAPI_MOD_IOX_FREE_LN_CTX:
+			//printk("ioctl: VPAPI_MOD_IOX_FREE_LN_CTX\n");
+			ret = vpapi_free_line_context(arg);
+			break;
+
+		case VPAPI_MOD_IOX_INIT_DEV:
+			//printk("ioctl: VPAPI_MOD_IOX_INIT_DEV\n");
+			ret = vpapi_init_device(arg);
+			break;
+
+		case VPAPI_MOD_IOX_CAL_LN:
+			//printk("ioctl: VPAPI_MOD_IOX_CAL_LN\n");
+			ret = vpapi_cal_line(arg);
+			break;
+
+		case VPAPI_MOD_IOX_SET_LN_ST:
+			//printk("ioctl: VPAPI_MOD_IOX_SET_LN_ST\n");
+			ret = vpapi_set_line_state(arg);
+			break;
+
+		case VPAPI_MOD_IOX_SET_OPTION:
+			//printk("ioctl: VPAPI_MOD_IOX_SET_OPTION\n");
+			ret = vpapi_set_option(arg);
+			break;
+
+		case VPAPI_MOD_IOX_GET_EVENT:
+			//printk("ioctl: VPAPI_MOD_IOX_GET_EVENT\n");
+			ret = vpapi_get_event(arg);
+			break;
+
+#if defined(CONFIG_ZARLINK_SLIC_VE792)
+		case VPAPI_MOD_IOX_BATT_ON:
+			//printk("ioctl: VPAPI_MOD_IOX_BATT_ON\n");
+			ret = vpapi_batt_on(arg);
+			break;
+
+		case VPAPI_MOD_IOX_BATT_OFF:
+			//printk("ioctl: VPAPI_MOD_IOX_BATT_OFF\n");
+			ret = vpapi_batt_off(arg);
+			break;
+#endif
+#if defined(CONFIG_ZARLINK_SLIC_VE880)
+		case VPAPI_MOD_IOX_REG_READ:
+			ret = vpapi_reg_read(arg);
+			break;
+
+		case VPAPI_MOD_IOX_REG_WRITE:
+			ret = vpapi_reg_write(arg);
+			break;
+#endif
+		default:
+			printk("%s: error, ioctl command(0x%x) not supported !!!\n", __func__, cmd);
+			ret = -EFAULT;
+			break;
+	}
+
+#if defined(SLIC_TIMER_EVENT_SUPPORT)
+	/* Enable timer routine processing */
+	atomic_set(&vpapi_in_ioctl, 0);
+#endif
+
+	return ret;
+}
+
+#ifdef HAVE_UNLOCKED_IOCTL
+static long
+vpapi_unlocked_ioctl(
+	struct file *filp,
+	unsigned int cmd,
+	unsigned long arg)
+{
+	return vpapi_ioctl(NULL, filp, cmd, arg);
+}
+#endif
+
+static int vpapi_make_dev_object(unsigned long arg)
+{
+	VpApiModMkDevObjType data;
+	VpDeviceType deviceType;
+	VpDeviceIdType deviceId;
+
+	/* Get user data */
+	if(copy_from_user(&data, (void*)arg, sizeof(VpApiModMkDevObjType))) {
+			printk("%s: copy_from_user failed\n", __func__);
+			return -EFAULT;
+	}
+
+	deviceType = data.deviceType;
+	deviceId = data.deviceId;
+
+	data.status = VpMakeDeviceObject(deviceType, deviceId, &pDevCtx[deviceId], &pDevObj[deviceId]);
+
+	/* Copy status back to user */
+	if(copy_to_user((void*)arg, &data, sizeof(VpApiModMkDevObjType))) {
+		printk("%s: copy_to_user failed\n", __func__);
+		return  -EFAULT;
+	}
+
+	return 0;
+}
+
+static int vpapi_make_line_object(unsigned long arg)
+{
+	VpApiModMkLnObjType data;
+	VpTermType termType;
+	VpLineIdType lineId;
+	VpDeviceIdType deviceId;
+
+	/* Get user data */
+	if(copy_from_user(&data, (void*)arg, sizeof(VpApiModMkLnObjType))) {
+			printk("%s: copy_from_user failed\n", __func__);
+			return -EFAULT;
+	}
+
+	termType = data.termType;
+	lineId = GET_LINE(data.lineId);
+	deviceId = GET_DEVICE(data.lineId);
+
+	data.status = VpMakeLineObject(termType, lineId, &pLineCtx[deviceId][lineId],
+				&pLineObj[deviceId][lineId], &pDevCtx[deviceId]);
+
+	/* Copy status back to user */
+	if(copy_to_user((void*)arg, &data, sizeof(VpApiModMkLnObjType))) {
+		printk("%s: copy_to_user failed\n", __func__);
+		return  -EFAULT;
+	}
+
+
+	return 0;
+}
+
+static int vpapi_map_line_id(unsigned long arg)
+{
+	VpApiModMapLnIdType data;
+	VpLineIdType lineId;
+	VpDeviceIdType deviceId;
+
+	/* Get user data */
+	if(copy_from_user(&data, (void*)arg, sizeof(VpApiModMapLnIdType))) {
+			printk("%s: copy_from_user failed\n", __func__);
+			return -EFAULT;
+	}
+
+	lineId = GET_LINE(data.lineId);
+	deviceId = GET_DEVICE(data.lineId);
+
+	data.status = VpMapLineId(&pLineCtx[deviceId][lineId], data.lineId);
+
+	/* Copy status back to user */
+	if(copy_to_user((void*)arg, &data, sizeof(VpApiModMapLnIdType))) {
+		printk("%s: copy_to_user failed\n", __func__);
+		return  -EFAULT;
+	}
+
+	return 0;
+}
+
+static int vpapi_map_slac_id(unsigned long arg)
+{
+	VpApiModMapSlacIdType data;
+	VpDeviceIdType deviceId;
+	u8 slacId;
+
+	/* Get user data */
+	if(copy_from_user(&data, (void*)arg, sizeof(VpApiModMapSlacIdType))) {
+			printk("%s: copy_from_user failed\n", __func__);
+			return -EFAULT;
+	}
+
+	deviceId = data.deviceId;
+	slacId = data.slacId;
+
+	data.status = VpMapSlacId(&pDevCtx[deviceId], slacId);
+
+	/* Copy status back to user */
+	if(copy_to_user((void*)arg, &data, sizeof(VpApiModMapSlacIdType))) {
+		printk("%s: copy_to_user failed\n", __func__);
+		return  -EFAULT;
+	}
+
+	return 0;
+
+}
+
+static int vpapi_free_line_context(unsigned long arg)
+{
+	VpApiModFreeLnCtxType data;
+	VpLineIdType lineId;
+	VpDeviceIdType deviceId;
+
+	/* Get user data */
+	if(copy_from_user(&data, (void*)arg, sizeof(VpApiModFreeLnCtxType))) {
+			printk("%s: copy_from_user failed\n", __func__);
+			return -EFAULT;
+	}
+
+	lineId = GET_LINE(data.lineId);
+	deviceId = GET_DEVICE(data.lineId);
+
+	data.status = VpFreeLineCtx(&pLineCtx[deviceId][lineId]);
+
+	if(data.status == VP_STATUS_SUCCESS) {
+		vpapi_line_status[data.lineId] = 0;
+		total_lines--;
+#if defined(SLIC_TIMER_EVENT_SUPPORT)
+		if(total_lines == 0) {
+			atomic_set(&vpapi_init, 0);
+			del_timer(&vpapi_timer);
+		}
+#endif
+	}
+
+	/* Copy status back to user */
+	if(copy_to_user((void*)arg, &data, sizeof(VpApiModFreeLnCtxType))) {
+		printk("%s: copy_to_user failed\n", __func__);
+		return  -EFAULT;
+	}
+
+	return 0;
+}
+
+static int vpapi_init_device(unsigned long arg)
+{
+	VpApiModInitDeviceType data;
+	VpDeviceIdType deviceId;
+	VpProfileDataType devProfile[MAX_PROFILE_SIZE];
+	VpProfileDataType acProfile[MAX_PROFILE_SIZE];
+	VpProfileDataType dcProfile[MAX_PROFILE_SIZE];
+	VpProfileDataType ringProfile[MAX_PROFILE_SIZE];
+	VpProfileDataType fxoAcProfile[MAX_PROFILE_SIZE];
+	VpProfileDataType fxoCfgProfile[MAX_PROFILE_SIZE];
+	VpProfilePtrType pDevProfile = NULL, pAcProfile = NULL;
+	VpProfilePtrType pDcProfile = NULL, pRingProfile = NULL;
+	VpProfilePtrType pFxoAcProfile = NULL, pFxoCfgProfile = NULL;
+	u16 devProfileSize, acProfileSize, dcProfileSize;
+	u16 ringProfileSize, fxoAcProfileSize, fxoCfgProfileSize;
+
+	/* Get user data */
+	if(copy_from_user(&data, (void*)arg, sizeof(VpApiModInitDeviceType))) {
+			printk("%s: copy_from_user failed\n", __func__);
+			return -EFAULT;
+	}
+
+	deviceId = data.deviceId;
+	devProfileSize = data.devProfileSize;
+	acProfileSize = data.acProfileSize;
+	dcProfileSize = data.dcProfileSize;
+	ringProfileSize = data.ringProfileSize;
+	fxoAcProfileSize = data.fxoAcProfileSize;
+	fxoCfgProfileSize = data.fxoCfgProfileSize;
+
+	if(devProfileSize) {
+		/* Get device profile */
+		if(copy_from_user(devProfile, (void*)data.pDevProfile, (sizeof(VpProfileDataType)*devProfileSize))) {
+			printk("%s: copy_from_user failed\n", __func__);
+			return -EFAULT;
+		}
+		pDevProfile = devProfile;
+	}
+
+	if(acProfileSize) {
+		/* Get AC profile */
+		if(copy_from_user(acProfile, (void*)data.pAcProfile, (sizeof(VpProfileDataType)*acProfileSize))) {
+			printk("%s: copy_from_user failed\n", __func__);
+			return -EFAULT;
+		}
+		pAcProfile = acProfile;
+	}
+
+	if(dcProfileSize) {
+		/* Get DC profile */
+		if(copy_from_user(dcProfile, (void*)data.pDcProfile, (sizeof(VpProfileDataType)*dcProfileSize))) {
+			printk("%s: copy_from_user failed\n", __func__);
+			return -EFAULT;
+		}
+		pDcProfile = dcProfile;
+	}
+
+	if(ringProfileSize) {
+		/* Get ring profile */
+		if(copy_from_user(ringProfile, (void*)data.pRingProfile, (sizeof(VpProfileDataType)*ringProfileSize))) {
+			printk("%s: copy_from_user failed\n", __func__);
+			return -EFAULT;
+		}
+		pRingProfile = ringProfile;
+	}
+
+	if(fxoAcProfileSize) {
+		/* Get FXO AC profile */
+		if(copy_from_user(fxoAcProfile, (void*)data.pFxoAcProfile, (sizeof(VpProfileDataType)*fxoAcProfileSize))) {
+			printk("%s: copy_from_user failed\n", __func__);
+			return -EFAULT;
+		}
+		pFxoAcProfile = fxoAcProfile;
+	}
+
+	if(fxoCfgProfileSize) {
+		/* Get FXO configuration profile */
+		if(copy_from_user(fxoCfgProfile, (void*)data.pFxoCfgProfile,
+					 (sizeof(VpProfileDataType)*fxoCfgProfileSize))) {
+			printk("%s: copy_from_user failed\n", __func__);
+			return -EFAULT;
+		}
+		pFxoCfgProfile = fxoCfgProfile;
+	}
+
+	data.status = VpInitDevice(&pDevCtx[deviceId], pDevProfile, pAcProfile, pDcProfile, pRingProfile,
+					 pFxoAcProfile, pFxoCfgProfile);
+
+	if(data.status == VP_STATUS_SUCCESS) {
+		total_devs++;
+		REGISTER_DEVICE(deviceId);
+
+		if(!atomic_read(&vpapi_init)) {
+#if defined(SLIC_TIMER_EVENT_SUPPORT)
+			memset(&vpapi_timer, 0, sizeof(struct timer_list));
+			init_timer(&vpapi_timer);
+			vpapi_timer.function = vpapi_tick_handler;
+			vpapi_timer.data = -1;
+			vpapi_timer.expires = jiffies + VPAPI_TICK_TIMER_PERIOD;
+			add_timer(&vpapi_timer);
+#endif
+			atomic_set(&vpapi_init, 1);
+		}
+	}
+
+	/* Copy status back to user */
+	if(copy_to_user((void*)arg, &data, sizeof(VpApiModInitDeviceType))) {
+		printk("%s: copy_to_user failed\n", __func__);
+		return  -EFAULT;
+	}
+
+	return 0;
+}
+
+static int vpapi_cal_line(unsigned long arg)
+{
+	VpApiModCalLnType data;
+	VpLineIdType lineId;
+	VpDeviceIdType deviceId;
+
+	/* Get user data */
+	if(copy_from_user(&data, (void*)arg, sizeof(VpApiModCalLnType))) {
+			printk("%s: copy_from_user failed\n", __func__);
+			return -EFAULT;
+	}
+
+	lineId = GET_LINE(data.lineId);
+	deviceId = GET_DEVICE(data.lineId);
+
+	data.status = VpCalLine(&pLineCtx[deviceId][lineId]);
+
+	if(data.status == VP_STATUS_SUCCESS) {
+		total_lines++;
+		REGISTER_LINE(data.lineId);
+	}
+
+	/* Copy status back to user */
+	if(copy_to_user((void*)arg, &data, sizeof(VpApiModCalLnType))) {
+		printk("%s: copy_to_user failed\n", __func__);
+		return  -EFAULT;
+	}
+
+	return 0;
+}
+
+static int vpapi_set_line_state(unsigned long arg)
+{
+	VpApiModSetLnStType data;
+	VpLineIdType lineId;
+	VpDeviceIdType deviceId;
+	VpLineStateType state;
+
+	/* Get user data */
+	if(copy_from_user(&data, (void*)arg, sizeof(VpApiModSetLnStType))) {
+			printk("%s: copy_from_user failed\n", __func__);
+			return -EFAULT;
+	}
+
+	lineId = GET_LINE(data.lineId);
+	deviceId = GET_DEVICE(data.lineId);
+	state = data.state;
+
+	data.status = VpSetLineState(&pLineCtx[deviceId][lineId], state);
+
+	/* Copy status back to user */
+	if(copy_to_user((void*)arg, &data, sizeof(VpApiModSetLnStType))) {
+		printk("%s: copy_to_user failed\n", __func__);
+		return  -EFAULT;
+	}
+
+	return 0;
+}
+
+static int vpapi_set_option(unsigned long arg)
+{
+	VpApiModSetOptionType data;
+	u8 lineRequest;
+	VpLineIdType lineId;
+	VpDeviceIdType deviceId;
+	VpOptionIdType option;
+	void *pOptInfo;
+	long size;
+
+	/* Get user data */
+	if(copy_from_user(&data, (void*)arg, sizeof(VpApiModSetOptionType))) {
+			printk("%s: copy_from_user failed\n", __func__);
+			return -EFAULT;
+	}
+
+	option = data.option;
+	lineRequest = data.lineRequest;
+	deviceId = data.deviceId;
+	lineId = GET_LINE(data.lineId);
+
+	switch(option) {
+		case VP_OPTION_ID_TIMESLOT:
+			size = sizeof(VpOptionTimeslotType);
+			pOptInfo = (VpOptionTimeslotType*)kmalloc(size, GFP_KERNEL);
+			break;
+		case VP_OPTION_ID_CODEC:
+			size = sizeof(VpOptionCodecType);
+			pOptInfo = (VpOptionCodecType*)kmalloc(size, GFP_KERNEL);
+			break;
+		case VP_OPTION_ID_LOOPBACK:
+			size = sizeof(VpOptionLoopbackType);
+			pOptInfo = (VpOptionLoopbackType*)kmalloc(size, GFP_KERNEL);
+			break;
+		case VP_OPTION_ID_EVENT_MASK:
+			size = sizeof(VpOptionEventMaskType);
+			pOptInfo = (VpOptionEventMaskType*)kmalloc(size, GFP_KERNEL);
+			break;
+		case VP_OPTION_ID_LINE_STATE:
+			size = sizeof(VpOptionLineStateType);
+			pOptInfo = (VpOptionLineStateType*)kmalloc(size, GFP_KERNEL);
+			break;
+		default:
+			printk("%s: option(%d) not supported\n",__func__, option);
+			return -EFAULT;
+	}
+
+	/* Get option info */
+	if(copy_from_user(pOptInfo, (void*)data.pValue, size)) {
+			printk("%s: copy_from_user failed\n", __func__);
+			kfree(pOptInfo);
+			return -EFAULT;
+	}
+
+	/* Set option to line/device */
+	if(lineRequest)
+		data.status = VpSetOption(&pLineCtx[deviceId][lineId], VP_NULL, option, pOptInfo);
+	else
+		data.status = VpSetOption(VP_NULL, &pDevCtx[deviceId], option, pOptInfo);
+
+
+	kfree(pOptInfo);
+
+	/* Copy status back to user */
+	if(copy_to_user((void*)arg, &data, sizeof(VpApiModSetOptionType))) {
+		printk("%s: copy_to_user failed\n", __func__);
+		return  -EFAULT;
+	}
+
+	return 0;
+}
+
+int vpapi_get_event(unsigned long arg)
+{
+	VpApiModGetEventType data;
+	VpDeviceIdType deviceId;
+
+	/* Get user data */
+	if(copy_from_user(&data, (void*)arg, sizeof(VpApiModGetEventType))) {
+			printk("%s: copy_from_user failed\n", __func__);
+			return -EFAULT;
+	}
+
+	deviceId = data.deviceId;
+
+	if(atomic_read(&event_count) == 0) {
+		data.newEvent = FALSE;
+	}
+	else {
+		/* Copy event info back to user */
+		if(copy_to_user(data.pEvent, &event_queue[curr_event].vp_event, sizeof(VpEventType))) {
+			printk("%s: copy_to_user failed\n", __func__);
+			return  -EFAULT;
+		}
+
+		event_queue[curr_event].valid = 0;
+		data.newEvent = TRUE;
+		atomic_dec(&event_count);
+		curr_event++;
+		if(curr_event == MAX_EVENT_QUEUE_SIZE)
+			curr_event = 0;
+	}
+
+	/* Copy status and event info back to user */
+	if(copy_to_user((void*)arg, &data, sizeof(VpApiModGetEventType))) {
+		printk("%s: copy_to_user failed\n", __func__);
+		return  -EFAULT;
+	}
+
+	return 0;
+}
+#if defined(CONFIG_ZARLINK_SLIC_VE792)
+static int vpapi_batt_on(unsigned long arg)
+{
+	VpModBatteryOnType data;
+	int vbh, vbl, vbp;
+
+	/* Get user data */
+	if(copy_from_user(&data, (void*)arg, sizeof(VpModBatteryOnType))) {
+			printk("%s: copy_from_user failed\n", __func__);
+			return -EFAULT;
+	}
+
+	vbh = data.vbh;
+	vbl = data.vbl;
+	vbp = data.vbp;
+
+	data.status = BattOn(vbh, vbl, vbp);
+
+	/* Copy status and event info back to user */
+	if(copy_to_user((void*)arg, &data, sizeof(VpModBatteryOnType))) {
+		printk("%s: copy_to_user failed\n", __func__);
+		return  -EFAULT;
+	}
+
+	return 0;
+}
+
+static int vpapi_batt_off(unsigned long arg)
+{
+	VpModBatteryOffType data;
+
+	/* Get user data */
+	if(copy_from_user(&data, (void*)arg, sizeof(VpModBatteryOffType))) {
+			printk("%s: copy_from_user failed\n", __func__);
+			return -EFAULT;
+	}
+
+	data.status = BattOff();
+
+	/* Copy status and event info back to user */
+	if(copy_to_user((void*)arg, &data, sizeof(VpModBatteryOffType))) {
+		printk("%s: copy_to_user failed\n", __func__);
+		return  -EFAULT;
+	}
+
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_ZARLINK_SLIC_VE880)
+static int vpapi_reg_read(unsigned long arg)
+{
+	VpModRegOpType data;
+	VpLineIdType	line_id;
+	unsigned char	cmd;
+	unsigned short  cmd_len;
+	unsigned char *buff_p = NULL;
+	unsigned char ec_val[] = {0x1, 0x2};
+
+	/* Get user data */
+	if(copy_from_user(&data, (void*)arg, sizeof(VpModRegOpType))) {
+			printk("%s: copy_from_user failed\n", __func__);
+			return -EFAULT;
+	}
+
+	line_id = data.lineId;
+	cmd = data.cmd;
+	cmd_len = data.cmdLen;
+	buff_p = data.buff;
+
+	VpMpiCmd(GET_DEVICE(line_id), ec_val[GET_LINE(line_id)], (cmd | 1), cmd_len, buff_p);
+
+	/* Copy status and event info back to user */
+	if(copy_to_user((void*)arg, &data, sizeof(VpModRegOpType))) {
+		printk("%s: copy_to_user failed\n", __func__);
+		return  -EFAULT;
+	}
+
+	return 0;
+}
+
+static int vpapi_reg_write(unsigned long arg)
+{
+	VpModRegOpType data;
+	VpLineIdType	line_id;
+	unsigned char	cmd;
+	unsigned short  cmd_len;
+	unsigned char *buff_p = NULL;
+	unsigned char ec_val[] = {0x1, 0x2};
+
+	/* Get user data */
+	if(copy_from_user(&data, (void*)arg, sizeof(VpModRegOpType))) {
+			printk("%s: copy_from_user failed\n", __func__);
+			return -EFAULT;
+	}
+
+	line_id = data.lineId;
+	cmd = data.cmd;
+	cmd_len = data.cmdLen;
+	buff_p = data.buff;
+
+	VpMpiCmd(GET_DEVICE(line_id), ec_val[GET_LINE(line_id)], cmd, cmd_len, buff_p);
+
+	return 0;
+}
+#endif
+
+static int vpapi_open(struct inode *pInode, struct file *pFile)
+{
+	try_module_get(THIS_MODULE);
+	return 0;
+}
+
+static int vpapi_release(struct inode *pInode, struct file *pFile)
+{
+	module_put(THIS_MODULE);
+	return 0;
+}
+
+#if defined(SLIC_TIMER_EVENT_SUPPORT)
+static void vpapi_tick_handler(unsigned long data)
+{
+	u8 deviceId;
+	unsigned long flags;
+	vpapi_event *pEvent;
+#if !defined(CONFIG_ZARLINK_SLIC_VE792)
+	bool eventStatus;
+#endif
+
+	/* Check if events are already active and not processing IOCTL */
+	if((atomic_read(&vpapi_init) == 0) || (atomic_read(&vpapi_in_ioctl) == 1))
+		goto timer_exit;
+
+	spin_lock_irqsave(&vpapi_lock, flags);
+
+	for(deviceId = 0; deviceId < MAX_DEVICES; deviceId++) {
+
+		if(GET_DEV_STATUS(deviceId) == 0)
+			continue;
+
+		/* Check for free resources */
+		if(atomic_read(&event_count) >= MAX_EVENT_QUEUE_SIZE)
+			goto timer_exit;
+
+#if !defined(CONFIG_ZARLINK_SLIC_VE792)
+		if(VP_STATUS_SUCCESS == VpApiTick(&pDevCtx[deviceId], &eventStatus)) {
+			if(eventStatus == TRUE) {
+#endif
+				pEvent = &event_queue[next_event];
+				while(VpGetEvent(&pDevCtx[deviceId], &pEvent->vp_event) == TRUE) {
+					if(pEvent->vp_event.status != VP_STATUS_SUCCESS) {
+						printk("%s: bad status(%d)\n", __func__, pEvent->vp_event.status);
+						break;
+					}
+
+					if(pEvent->vp_event.eventId == 0)  {
+						printk("%s: warning, empty event\n", __func__);
+						break;
+					}
+
+					next_event++;
+					if(next_event == MAX_EVENT_QUEUE_SIZE) {
+						next_event = 0;
+					}
+
+					atomic_inc(&event_count);
+
+					if(pEvent->valid == 0) {
+						pEvent->valid = 1;
+					}
+					else {
+						printk("%s: error, event(%u) was overrided\n", __func__, next_event);
+						break;
+					}
+
+					pEvent = &event_queue[next_event];
+				}
+#if !defined(CONFIG_ZARLINK_SLIC_VE792)
+			}
+		}
+#endif
+	}
+
+
+	spin_unlock_irqrestore(&vpapi_lock, flags);
+
+timer_exit:
+
+	/* Checks if user application should be signaled */
+	if(atomic_read(&event_count) > 0) {
+		wake_up_interruptible(&vpapi_wait);
+	}
+
+	/* Schedule next timer tick */
+	vpapi_timer.expires = jiffies + VPAPI_TICK_TIMER_PERIOD;
+	add_timer(&vpapi_timer);
+}
+#endif
+
+int __init vpapi_module_init(void)
+{
+	int status;
+
+	printk("Loading Marvell %s device\n", VPAPI_MOD_NAME);
+	status = misc_register(&vpapi_misc_dev);
+
+	/* Register VPAPI device module */
+	if (status < 0) {
+		printk("Error, failed to load %s module(%d)\n", VPAPI_MOD_NAME, status);
+		return status;
+	}
+
+	atomic_set(&vpapi_init, 0);
+	atomic_set(&vpapi_in_ioctl, 0);
+	total_devs = 0;
+	total_lines = 0;
+	next_event = 0;
+	curr_event = 0;
+	memset(vpapi_dev_status, 0, MAX_DEVICES);
+	memset(vpapi_line_status, 0, MAX_LINES);
+
+	/* Reset event counter */
+	atomic_set(&event_count, 0);
+
+	/* Clear event queue */
+	memset(event_queue, 0, (MAX_EVENT_QUEUE_SIZE * sizeof(vpapi_event)));
+
+	return 0;
+}
+
+void __exit vpapi_module_exit(void)
+{
+	printk("Unloading %s device module\n", VPAPI_MOD_NAME);
+
+#if defined(SLIC_TIMER_EVENT_SUPPORT)
+	if(total_lines == 0)
+		del_timer(&vpapi_timer);
+#endif
+
+	/* Unregister VPAPI misc device */
+	misc_deregister(&vpapi_misc_dev);
+
+	return;
+}
+
+/* Module stuff */
+module_init(vpapi_module_init);
+module_exit(vpapi_module_exit);
+MODULE_DESCRIPTION("Zarlink VPAPI-II Device");
+MODULE_AUTHOR("Eran Ben-Avi <benavi@marvell.com>");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/slic/vpapi_dev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/slic/vpapi_dev.h
new file mode 100644
index 0000000..18c2d9c
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/slic/vpapi_dev.h
@@ -0,0 +1,265 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef _VPAPI_DEV_H_
+#define _VPAPI_DEV_H_
+
+#include "vp_api_common.h"
+#if defined(CONFIG_ZARLINK_SLIC_VE880)
+#include "vp880_api.h"
+#elif defined(CONFIG_ZARLINK_SLIC_VE792)
+#include "vp792_api.h"
+#endif
+
+#define VPAPI_MOD_IOCTL_MAGIC           'z'
+
+#define VPAPI_MOD_IOCTL_MIN 		1
+
+/* VP-API System Configuration Functions */
+#define VPAPI_MOD_IOX_MK_DEV_OBJ	_IOWR(VPAPI_MOD_IOCTL_MAGIC, 1, VpApiModMkDevObjType)
+#define VPAPI_MOD_IOX_MK_LN_OBJ		_IOWR(VPAPI_MOD_IOCTL_MAGIC, 2, VpApiModMkLnObjType)
+#define VPAPI_MOD_IOX_MAP_LN_ID		_IOWR(VPAPI_MOD_IOCTL_MAGIC, 3, VpApiModMapLnIdType)
+#define VPAPI_MOD_IOX_MAP_SLAC_ID	_IOWR(VPAPI_MOD_IOCTL_MAGIC, 4, VpApiModMapSlacIdType)
+#define VPAPI_MOD_IOX_FREE_LN_CTX	_IOWR(VPAPI_MOD_IOCTL_MAGIC, 5, VpApiModFreeLnCtxType)
+
+/* VP-API Initialization Functions */
+#define VPAPI_MOD_IOX_INIT_DEV		_IOWR(VPAPI_MOD_IOCTL_MAGIC, 6, VpApiModInitDeviceType)
+#define VPAPI_MOD_IOX_CAL_LN		_IOWR(VPAPI_MOD_IOCTL_MAGIC, 7, VpApiModCalLnType)
+
+/* VP-API Control Functions */
+#define VPAPI_MOD_IOX_SET_LN_ST		_IOWR(VPAPI_MOD_IOCTL_MAGIC, 8, VpApiModSetLnStType)
+#define VPAPI_MOD_IOX_SET_OPTION	_IOWR(VPAPI_MOD_IOCTL_MAGIC, 9, VpApiModSetOptionType)
+
+/* VP-API Status and Query Functions */
+#define VPAPI_MOD_IOX_GET_EVENT		_IOWR(VPAPI_MOD_IOCTL_MAGIC, 10, VpApiModGetEventType)
+
+/* VE792 Battery Control */
+#define VPAPI_MOD_IOX_BATT_ON		_IOWR(VPAPI_MOD_IOCTL_MAGIC, 11, VpModBatteryOnType)
+#define VPAPI_MOD_IOX_BATT_OFF		_IOWR(VPAPI_MOD_IOCTL_MAGIC, 12, VpModBatteryOffType)
+
+/* SLIC register read/write */
+#define VPAPI_MOD_IOX_REG_READ		_IOWR(VPAPI_MOD_IOCTL_MAGIC, 13, VpModRegOpType)
+#define VPAPI_MOD_IOX_REG_WRITE		_IOWR(VPAPI_MOD_IOCTL_MAGIC, 14, VpModRegOpType)
+
+#define VPAPI_MOD_IOCTL_MAX 		14
+#define MAX_SLIC_RDWR_BUFF_SIZE		128
+
+
+/******************** VP-API System Configuration Structs *********************/
+typedef struct VpApiModMkDevObj {
+	/* Input arg(s) */
+	VpDeviceType	deviceType;
+	VpDeviceIdType	deviceId;
+
+	/* Output arg(s) */
+	VpStatusType		status;
+} VpApiModMkDevObjType;
+
+
+typedef struct VpApiModMkLnObj {
+	/* Input arg(s) */
+	VpTermType	termType;
+	VpLineIdType	lineId;
+
+	/* Output arg(s) */
+	VpStatusType	status;
+} VpApiModMkLnObjType;
+
+typedef struct VpApiModMapLnId {
+	/* Input arg(s) */
+	VpLineIdType	lineId;
+
+	/* Output arg(s) */
+	VpStatusType	status;
+} VpApiModMapLnIdType;
+
+typedef struct VpApiModMapSlacId {
+	/* Input arg(s) */
+	VpDeviceIdType	deviceId;
+	unsigned char	slacId;
+
+	/* Output arg(s) */
+	VpStatusType	status;
+} VpApiModMapSlacIdType;
+
+typedef struct VpApiModFreeLnCtx {
+	/* Input arg(s) */
+	VpLineIdType	lineId;
+
+	/* Output arg(s) */
+	VpStatusType	status;
+} VpApiModFreeLnCtxType;
+
+
+/************************ VP-API Initialization Structs ************************/
+typedef struct VpApiModInitDevice {
+	/* Input arg(s) */
+	VpDeviceIdType		deviceId;
+	VpProfilePtrType	pDevProfile;
+	VpProfilePtrType	pAcProfile;
+	VpProfilePtrType	pDcProfile;
+	VpProfilePtrType	pRingProfile;
+	VpProfilePtrType	pFxoAcProfile;
+	VpProfilePtrType	pFxoCfgProfile;
+	unsigned short		devProfileSize;
+	unsigned short		acProfileSize;
+	unsigned short		dcProfileSize;
+	unsigned short		ringProfileSize;
+	unsigned short		fxoAcProfileSize;
+	unsigned short		fxoCfgProfileSize;
+
+	/* Output arg(s) */
+	VpStatusType		status;
+} VpApiModInitDeviceType;
+
+typedef struct VpApiModCalLn {
+	/* Input arg(s) */
+	VpLineIdType	lineId;
+
+	/* Output arg(s) */
+	VpStatusType	status;
+} VpApiModCalLnType;
+
+
+/****************************VP-API Control Structs ***************************/
+typedef struct VpApiModSetLnSt {
+	/* Input arg(s) */
+	VpLineIdType	lineId;
+	VpLineStateType	state;
+
+	/* Output arg(s) */
+	VpStatusType	status;
+} VpApiModSetLnStType;
+
+
+typedef struct VpApiModSetOption {
+	/* Input arg(s) */
+	unsigned char	lineRequest;
+	VpLineIdType	lineId;
+	VpDeviceIdType	deviceId;
+	VpOptionIdType	option;
+	void		*pValue;
+
+	/* Output arg(s) */
+	VpStatusType	status;
+} VpApiModSetOptionType;
+
+#if 0
+typedef struct VpApiModLowLvlCmd {
+	/* Input arg(s) */
+	const VpModLineRegNumType	lineRegNum;
+	uint8				*pCmdData;
+	const uint8			len;
+	const uint16			handle;
+
+	/* Output arg(s) */
+	VpStatusType			status;
+} VpApiModLowLvlCmdType;
+#endif
+
+/********************** VP-API Status and Query Structs ***********************/
+typedef struct VpApiModGetEvent {
+	/* Input arg(s) */
+	VpDeviceIdType	deviceId;
+
+	/* Output arg(s) */
+	bool		newEvent;
+	VpEventType	*pEvent;
+} VpApiModGetEventType;
+
+/********************** VE792 Battery Control ***********************/
+typedef struct VpModBatteryOn {
+	/* Input arg(s) */
+	int	vbh;
+	int	vbl;
+	int	vbp;
+
+	/* Output arg(s) */
+	int	status;
+} VpModBatteryOnType;
+
+typedef struct VpModBatteryOff {
+
+	/* Output arg(s) */
+	int	status;
+} VpModBatteryOffType;
+
+/********************** SLIC register read/write ********************/
+typedef struct VpModRegOp {
+	/* Input arg(s) */
+	VpLineIdType	lineId;
+	unsigned char	cmd;
+	unsigned short  cmdLen;
+	unsigned char buff[MAX_SLIC_RDWR_BUFF_SIZE];
+
+	/* Output arg(s) */
+	VpStatusType	status;
+} VpModRegOpType;
+
+/* APIs */
+int vpapi_module_init(void);
+void vpapi_module_exit(void);
+
+
+#endif /*_VPAPI_DEV_H_*/
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/tal.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/tal.c
new file mode 100644
index 0000000..27aba8e
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/tal.c
@@ -0,0 +1,158 @@
+
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************/
+
+/* Marvell Telephony Adaptation Layer */
+
+#include "tal.h"
+#include "tdm_if.h"
+
+/* GLobals */
+static tdm_if_register_ops_t tal_tdm_if_register_ops;
+static tal_mmp_ops_t* tal_mmp_ops;
+static tdm_if_params_t tal_tdm_if_params;
+
+/* Static APIs */
+static void tal_pcm_tx_callback(uint8_t* tx_buff, int size);
+static void tal_pcm_rx_callback(uint8_t* rx_buff, int size);
+
+/*---------------------------------------------------------------------------*
+ * tal_init
+ * Issue telephony subsytem initialization and callbacks registration
+ *---------------------------------------------------------------------------*/
+tal_stat_t tal_init(tal_params_t* tal_params, tal_mmp_ops_t* mmp_ops)
+{
+	if((tal_params == NULL) || (mmp_ops == NULL))
+	{
+		mvOsPrintf("%s: Error, bad parameters\n",__FUNCTION__);
+		return TAL_STAT_BAD_PARAM;
+	}
+
+	if(mmp_ops->tal_mmp_rx_callback == NULL ||
+	   mmp_ops->tal_mmp_tx_callback == NULL)
+	{
+		mvOsPrintf("%s:Error, missing callbacks(MMP)\n",__FUNCTION__);
+		return TAL_STAT_BAD_PARAM;
+	}
+
+	/* Convert tal_params to tdm_if_params */
+	memcpy(&tal_tdm_if_params, tal_params, sizeof(tal_params_t));
+
+	/* Assign MMP operations */
+	tal_mmp_ops = mmp_ops;
+
+	/* Clear tdm_if operations structure */
+	memset(&tal_tdm_if_register_ops, 0, sizeof(tdm_if_register_ops_t));
+
+	/* Assign tdm_if operations */
+	tal_tdm_if_register_ops.tdm_if_pcm_ops.pcm_tx_callback = tal_pcm_tx_callback;
+	tal_tdm_if_register_ops.tdm_if_pcm_ops.pcm_rx_callback = tal_pcm_rx_callback;
+
+	/* Dispatch tdm_if driver */
+	if(tdm_if_init(&tal_tdm_if_register_ops, &tal_tdm_if_params) != MV_OK)
+	{
+		mvOsPrintf("%s: Error, could not initialize tdm_if driver !!!\n",__FUNCTION__);
+		return TAL_STAT_INIT_ERROR;
+	}
+
+	/* Verify control callbacks were assigned properly */
+	if(tal_tdm_if_register_ops.tdm_if_ctl_ops.ctl_pcm_start == NULL ||
+	   tal_tdm_if_register_ops.tdm_if_ctl_ops.ctl_pcm_stop == NULL)
+	{
+		mvOsPrintf("%s:Error, missing callbacks(tdm_if)\n",__FUNCTION__);
+		return TAL_STAT_BAD_PARAM;
+	}
+
+	return TAL_STAT_OK;
+}
+
+
+/*---------------------------------------------------------------------------*
+ * tal_pcm_tx_completion
+ * Tx callback
+ *---------------------------------------------------------------------------*/
+
+static void tal_pcm_tx_callback(uint8_t* tx_buff, int size)
+{
+	tal_mmp_ops->tal_mmp_tx_callback(tx_buff, size);
+}
+
+/*---------------------------------------------------------------------------*
+ * tal_pcm_rx_completion
+ * Rx callback
+ *---------------------------------------------------------------------------*/
+
+static void tal_pcm_rx_callback(uint8_t* rx_buff, int size)
+{
+	tal_mmp_ops->tal_mmp_rx_callback(rx_buff, size);
+}
+
+/*---------------------------------------------------------------------------*
+ * tal_pcm_start
+ * Start PCM bus
+ *---------------------------------------------------------------------------*/
+tal_stat_t tal_pcm_start(void)
+{
+	tal_tdm_if_register_ops.tdm_if_ctl_ops.ctl_pcm_start();
+	return TAL_STAT_OK;
+}
+
+/*---------------------------------------------------------------------------*
+ * tal_pcm_stop
+ * Stop PCM bus
+ *---------------------------------------------------------------------------*/
+tal_stat_t tal_pcm_stop(void)
+{
+	tal_tdm_if_register_ops.tdm_if_ctl_ops.ctl_pcm_stop();
+	return TAL_STAT_OK;
+}
+
+/*---------------------------------------------------------------------------*
+ * tal_exit
+ * Stop TDM channels and release all resources
+ *---------------------------------------------------------------------------*/
+tal_stat_t tal_exit(void)
+{
+	tdm_if_exit();
+	return TAL_STAT_OK;
+}
+
+/*---------------------------------------------------------------------------*
+ * tal_stats_get
+ * Get TDM statistics
+ *---------------------------------------------------------------------------*/
+tal_stat_t tal_stats_get(tal_stats_t* tal_stats)
+{
+	tdm_if_stats_t stats;
+
+	tdm_if_stats_get(&stats);
+	memcpy(tal_stats, &stats, sizeof(tal_stats_t));
+
+	return TAL_STAT_OK;
+}
+
+
+
+/* EXPORTS */
+EXPORT_SYMBOL(tal_init);
+EXPORT_SYMBOL(tal_pcm_start);
+EXPORT_SYMBOL(tal_pcm_stop);
+EXPORT_SYMBOL(tal_exit);
+EXPORT_SYMBOL(tal_stats_get);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/tal.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/tal.h
new file mode 100644
index 0000000..4216bc9
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/tal.h
@@ -0,0 +1,73 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************/
+
+/* Marvell Telephony Adaptation Layer */
+
+#ifndef _TAL_H_
+#define _TAL_H_
+
+#include "mvOs.h" /* for kernel abstraction wrappers */
+
+/* Defines */
+#define TAL_MAX_PHONE_LINES	32
+
+/* Enumerators */
+typedef enum {
+	TAL_PCM_FORMAT_1BYTE = 1,
+	TAL_PCM_FORMAT_2BYTES = 2,
+	TAL_PCM_FORMAT_4BYTES = 4
+} tal_pcm_format_t;
+
+typedef enum {
+	TAL_STAT_OK = 0,
+	TAL_STAT_BAD_PARAM,
+	TAL_STAT_INIT_ERROR
+} tal_stat_t;
+
+/* Structures */
+typedef struct {
+	tal_pcm_format_t pcm_format;
+	unsigned short pcm_slot[TAL_MAX_PHONE_LINES];
+	unsigned char sampling_period;
+	unsigned short total_lines;
+	unsigned short test_enable;
+} tal_params_t;
+
+typedef struct {
+	int tdm_init;
+	unsigned int rx_miss;
+	unsigned int tx_miss;
+	unsigned int rx_over;
+	unsigned int tx_under;
+} tal_stats_t;
+
+typedef struct {
+	void (*tal_mmp_rx_callback)(unsigned char* rx_buff, int size);
+	void (*tal_mmp_tx_callback)(unsigned char* tx_buff, int size);
+} tal_mmp_ops_t;
+
+/* APIs */
+tal_stat_t tal_init(tal_params_t* tal_params, tal_mmp_ops_t* mmp_ops);
+tal_stat_t tal_stats_get(tal_stats_t* tal_stats);
+tal_stat_t tal_pcm_start(void);
+tal_stat_t tal_pcm_stop(void);
+tal_stat_t tal_exit(void);
+
+#endif /* _TAL_H */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/tdm_if.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/tdm_if.c
new file mode 100644
index 0000000..b2dd7bd
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/tdm_if.c
@@ -0,0 +1,522 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+#include "tdm_if.h"
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#ifndef CONFIG_MV_TDM_SUPPORT
+#include "gpp/mvGppRegs.h"
+#endif
+
+
+/* TDM Interrupt Service Routine */
+static irqreturn_t tdm_if_isr(int irq, void* dev_id);
+
+/* PCM start/stop */
+static void tdm_if_pcm_start(void);
+static void tdm_if_pcm_stop(void);
+
+/* Rx/Tx Tasklets  */
+#ifndef CONFIG_MV_PHONE_USE_IRQ_PROCESSING
+static void tdm_if_pcm_rx_process(unsigned long arg);
+static void tdm_if_pcm_tx_process(unsigned long arg);
+#else
+static inline void tdm_if_pcm_rx_process(void);
+static inline void tdm_if_pcm_tx_process(void);
+#endif
+/* TDM proc-fs statistics */
+static int proc_tdm_init_read(char *buffer, char **buffer_location, off_t offset,
+                            int buffer_length, int *zero, void *ptr);
+static int proc_rx_miss_read(char *buffer, char **buffer_location, off_t offset,
+                            int buffer_length, int *zero, void *ptr);
+static int proc_tx_miss_read(char *buffer, char **buffer_location, off_t offset,
+                            int buffer_length, int *zero, void *ptr);
+static int proc_rx_over_read(char *buffer, char **buffer_location, off_t offset,
+                            int buffer_length, int *zero, void *ptr);
+static int proc_tx_under_read(char *buffer, char **buffer_location, off_t offset,
+                            int buffer_length, int *zero, void *ptr);
+
+
+/* Module */
+static int __init tdm_if_module_init(void);
+static void __exit tdm_if_module_exit(void);
+
+/* Globals */
+static tdm_if_register_ops_t* tdm_if_register_ops;
+#ifndef CONFIG_MV_PHONE_USE_IRQ_PROCESSING
+static DECLARE_TASKLET(tdm_if_rx_tasklet, tdm_if_pcm_rx_process, 0);
+static DECLARE_TASKLET(tdm_if_tx_tasklet, tdm_if_pcm_tx_process, 0);
+#endif
+static DEFINE_SPINLOCK(tdm_if_lock);
+static unsigned char *rxBuff = NULL, *txBuff = NULL;
+static char irqnr;
+static unsigned int rx_miss = 0, tx_miss = 0;
+static unsigned int rx_over = 0, tx_under = 0;
+static struct proc_dir_entry *tdm_stats;
+static int pcm_enable = 0;
+static int irq_init = 0;
+static int tdm_init = 0;
+static int buff_size = 0;
+static unsigned short test_enable = 0;
+
+static int proc_tdm_init_read(char *buffer, char **buffer_location, off_t offset,
+                            int buffer_length, int *zero, void *ptr)
+{
+	return sprintf(buffer, "%u\n", tdm_init);
+}
+
+static int proc_rx_miss_read(char *buffer, char **buffer_location, off_t offset,
+                            int buffer_length, int *zero, void *ptr)
+{
+	return sprintf(buffer, "%u\n", rx_miss);
+}
+
+static int proc_tx_miss_read(char *buffer, char **buffer_location, off_t offset,
+                            int buffer_length, int *zero, void *ptr)
+{
+	return sprintf(buffer, "%u\n", tx_miss);
+}
+
+static int proc_rx_over_read(char *buffer, char **buffer_location, off_t offset,
+                            int buffer_length, int *zero, void *ptr)
+{
+	return sprintf(buffer, "%u\n", rx_over);
+}
+
+static int proc_tx_under_read(char *buffer, char **buffer_location, off_t offset,
+                            int buffer_length, int *zero, void *ptr)
+{
+	return sprintf(buffer, "%u\n", tx_under);
+}
+
+MV_STATUS tdm_if_init(tdm_if_register_ops_t* register_ops, tdm_if_params_t* tdm_if_params)
+{
+	MV_TDM_PARAMS tdm_params;
+
+	printk("Loading Marvell Telephony Driver\n");
+
+	/* Check if any SLIC module exists */
+	if(mvBoardTdmDevicesCountGet() == 0) {
+		mvCtrlPwrClckSet(TDM_2CH_UNIT_ID, 0, MV_FALSE);
+		printk("%s: Warning, no SLIC module is connected\n",__FUNCTION__);
+		return MV_OK;
+	}
+
+	/* Check that selected TDM unit is active */
+	if (MV_FALSE == mvCtrlPwrClckGet(mvCtrlTdmUnitTypeGet(), 0)) {
+		printk("%s: Warning, TDM is powered off\n",__FUNCTION__);
+		return MV_OK;
+	}
+
+
+	if((register_ops == NULL) || (tdm_if_params == NULL)) {
+		printk("%s: bad parameters\n",__FUNCTION__);
+		return MV_ERROR;
+
+	}
+
+	/* Check callbacks */
+	if(register_ops->tdm_if_pcm_ops.pcm_tx_callback == NULL ||
+	   register_ops->tdm_if_pcm_ops.pcm_rx_callback == NULL ) {
+		printk("%s: missing parameters\n",__FUNCTION__);
+		return MV_ERROR;
+	}
+
+	/* Reset globals */
+	rxBuff = txBuff = NULL;
+#ifdef CONFIG_MV_TDM_SUPPORT
+	pcm_enable = 0;
+#else
+	pcm_enable = 1;
+#endif
+	irq_init = 0;
+	tdm_init = 0;
+
+	/* Extract test enable */
+	test_enable = tdm_if_params->test_enable;
+
+	/* Calculate Rx/Tx buffer size(use in callbacks) */
+	buff_size = (tdm_if_params->pcm_format * tdm_if_params->total_lines * 80 *
+				(tdm_if_params->sampling_period/MV_TDM_BASE_SAMPLING_PERIOD));
+
+	/* Extract TDM irq number */
+	irqnr = mvCtrlTdmUnitIrqGet();
+
+	/* Start Marvell trace */
+	TRC_START();
+	TRC_INIT(NULL, NULL, 0, 0);
+	TRC_REC("->%s\n",__FUNCTION__);
+
+	/* Assign TDM parameters */
+	memcpy(&tdm_params, tdm_if_params, sizeof(MV_TDM_PARAMS));
+
+	/* Assign control callbacks */
+	tdm_if_register_ops = register_ops;
+	tdm_if_register_ops->tdm_if_ctl_ops.ctl_pcm_start = tdm_if_pcm_start;
+	tdm_if_register_ops->tdm_if_ctl_ops.ctl_pcm_stop = tdm_if_pcm_stop;
+
+	/* TDM init */
+	if(mvSysTdmInit(&tdm_params) != MV_OK) {
+			printk("%s: Error, TDM initialization failed !!!\n",__FUNCTION__);
+			return MV_ERROR;
+	}
+	tdm_init = 1;
+
+	/* Register TDM interrupt */
+	if (request_irq(irqnr, tdm_if_isr, IRQF_DISABLED, "tdm", NULL)) {
+		printk("%s: Failed to connect irq(%d)\n", __FUNCTION__, irqnr);
+		return MV_ERROR;
+	}
+	irq_init = 1;
+
+	/* Create TDM procFS statistics */
+	tdm_stats = proc_mkdir("tdm", NULL);
+	create_proc_read_entry("tdm_init", 0, tdm_stats, proc_tdm_init_read, NULL);
+	create_proc_read_entry("rx_miss", 0, tdm_stats, proc_rx_miss_read, NULL);
+	create_proc_read_entry("tx_miss", 0, tdm_stats, proc_tx_miss_read, NULL);
+	create_proc_read_entry("rx_over", 0, tdm_stats, proc_rx_over_read, NULL);
+	create_proc_read_entry("tx_under", 0, tdm_stats, proc_tx_under_read, NULL);
+
+	TRC_REC("Marvell Telephony Driver Loaded Successfully\n");
+
+#ifdef CONFIG_MV_COMM_UNIT_SUPPORT
+	/* WA to stop the MCDMA gracefully after commUnit initialization */
+	tdm_if_pcm_stop();
+#endif
+
+	TRC_REC("<-%s\n",__FUNCTION__);
+	return MV_OK;
+}
+
+
+void tdm_if_exit(void)
+{
+	/* Check if already stopped */
+	if(!irq_init && !pcm_enable && !tdm_init)
+		return;
+
+	TRC_REC("->%s\n",__FUNCTION__);
+
+	if(irq_init) {
+		/* Release IRQ */
+		free_irq(irqnr, NULL);
+		irq_init = 0;
+	}
+
+	/* Stop PCM data sampling */
+	if(pcm_enable)
+		tdm_if_pcm_stop();
+
+	if(tdm_init) {
+#ifdef CONFIG_MV_TDM_SUPPORT
+		mvTdmRelease();
+#else
+		mvCommUnitRelease();
+#endif
+		tdm_init = 0;
+
+		/* Remove proc directory & entries */
+		remove_proc_entry("tdm_init", tdm_stats);
+		remove_proc_entry("rx_miss", tdm_stats);
+		remove_proc_entry("tx_miss", tdm_stats);
+		remove_proc_entry("rx_over", tdm_stats);
+		remove_proc_entry("tx_under", tdm_stats);
+		remove_proc_entry("tdm", NULL);
+	}
+
+	TRC_REC("<-%s\n",__FUNCTION__);
+
+	TRC_OUTPUT();
+	TRC_RELEASE();
+}
+
+static void tdm_if_pcm_start(void)
+{
+	unsigned long flags;
+
+	TRC_REC("->%s\n",__FUNCTION__);
+
+	spin_lock_irqsave(&tdm_if_lock, flags);
+	if(!pcm_enable) {
+		rxBuff = txBuff = NULL;
+		pcm_enable = 1;
+#ifdef CONFIG_MV_TDM_SUPPORT
+		mvTdmPcmStart();
+#else
+		mvCommUnitPcmStart();
+#endif
+	}
+	spin_unlock_irqrestore(&tdm_if_lock, flags);
+
+	TRC_REC("<-%s\n",__FUNCTION__);
+	return;
+}
+
+static void tdm_if_pcm_stop(void)
+{
+	unsigned long flags;
+
+	TRC_REC("->%s\n",__FUNCTION__);
+
+	spin_lock_irqsave(&tdm_if_lock, flags);
+	if(pcm_enable) {
+		pcm_enable = 0;
+		rxBuff = txBuff = NULL;
+#ifdef CONFIG_MV_TDM_SUPPORT
+		mvTdmPcmStop();
+#else
+		mvCommUnitPcmStop();
+#endif
+	}
+	spin_unlock_irqrestore(&tdm_if_lock, flags);
+
+	TRC_REC("<-%s\n",__FUNCTION__);
+	return;
+}
+
+static irqreturn_t tdm_if_isr(int irq, void* dev_id)
+{
+	MV_TDM_INT_INFO tdm_int_info;
+	unsigned int int_type;
+
+	TRC_REC("->%s\n",__FUNCTION__);
+
+	/* Extract interrupt information from low level ISR */
+#ifdef CONFIG_MV_TDM_SUPPORT
+	mvTdmIntLow(&tdm_int_info);
+#else
+	mvCommUnitIntLow(&tdm_int_info);
+#endif
+
+	int_type = tdm_int_info.intType;
+	/*device_id = tdm_int_info.cs;*/
+
+	/* Nothing to do - return */
+	if(int_type == MV_EMPTY_INT)
+		goto out;
+
+	/* Support multiple interrupt handling */
+	/* RX interrupt */
+	if(int_type & MV_RX_INT) {
+		if(rxBuff != NULL) {
+			rx_miss++;
+			TRC_REC("%s: Warning, missed Rx buffer processing !!!\n",__FUNCTION__);
+		}
+		else {
+			rxBuff = tdm_int_info.tdmRxBuff;
+#ifdef CONFIG_MV_PHONE_USE_IRQ_PROCESSING
+			TRC_REC("%s: running Rx in ISR\n", __FUNCTION__);
+			tdm_if_pcm_rx_process();
+#else
+			/* Schedule Rx processing within SOFT_IRQ context */
+			TRC_REC("%s: schedule Rx tasklet\n", __FUNCTION__);
+			tasklet_hi_schedule(&tdm_if_rx_tasklet);
+#endif
+		}
+	}
+
+	/* TX interrupt */
+	if(int_type & MV_TX_INT) {
+		if(txBuff != NULL) {
+			tx_miss++;
+			TRC_REC("%s: Warning, missed Tx buffer processing !!!\n",__FUNCTION__);
+		}
+		else {
+			txBuff = tdm_int_info.tdmTxBuff;
+#ifdef CONFIG_MV_PHONE_USE_IRQ_PROCESSING
+			TRC_REC("%s: running Tx in ISR\n", __FUNCTION__);
+			tdm_if_pcm_tx_process();
+#else
+			/* Schedule Tx processing within SOFT_IRQ context */
+			TRC_REC("%s: schedule Tx tasklet\n", __FUNCTION__);
+			tasklet_hi_schedule(&tdm_if_tx_tasklet);
+#endif
+		}
+	}
+
+	/* PHONE interrupt */
+	if(int_type & MV_PHONE_INT) {
+		/* TBD */
+	}
+
+	/* ERROR interrupt */
+	if(int_type & MV_ERROR_INT) {
+		if(int_type & MV_RX_ERROR_INT)
+			rx_over++;
+
+		if(int_type & MV_TX_ERROR_INT)
+			tx_under++;
+	}
+
+
+out:
+	TRC_REC("<-%s\n",__FUNCTION__);
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_MV_PHONE_USE_IRQ_PROCESSING
+static inline void tdm_if_pcm_rx_process(void)
+#else
+/* Rx tasklet */
+static void tdm_if_pcm_rx_process(unsigned long arg)
+#endif
+{
+	TRC_REC("->%s\n",__FUNCTION__);
+	if(pcm_enable) {
+		if(rxBuff == NULL) {
+			TRC_REC("%s: Error, empty Rx processing\n",__FUNCTION__);
+			return;
+		}
+
+		/* Fill TDM Rx aggregated buffer */
+#ifdef CONFIG_MV_TDM_SUPPORT
+		if(mvTdmRx(rxBuff) == MV_OK)
+			tdm_if_register_ops->tdm_if_pcm_ops.pcm_rx_callback(rxBuff, buff_size); /* Dispatch Rx handler */
+#else
+		if(mvCommUnitRx(rxBuff) == MV_OK) {
+			tdm_if_register_ops->tdm_if_pcm_ops.pcm_rx_callback(rxBuff, buff_size); /* Dispatch Rx handler */
+			/* Since data buffer is shared among MCDMA and CPU, need to invalidate
+				before it accessed by MCDMA	*/
+			mvOsCacheInvalidate(NULL, rxBuff, buff_size);
+		}
+#endif
+		else
+			printk("%s: could not fill Rx buffer\n",__FUNCTION__);
+
+	}
+
+	/* Clear rxBuff for next iteration */
+	rxBuff = NULL;
+
+	TRC_REC("<-%s\n",__FUNCTION__);
+	return;
+}
+
+#ifdef CONFIG_MV_PHONE_USE_IRQ_PROCESSING
+static inline void tdm_if_pcm_tx_process(void)
+#else
+/* Tx tasklet */
+static void tdm_if_pcm_tx_process(unsigned long arg)
+#endif
+{
+	TRC_REC("->%s\n",__FUNCTION__);
+
+	if(pcm_enable) {
+		if(txBuff == NULL) {
+			TRC_REC("%s: Error, empty Tx processing\n",__FUNCTION__);
+			return;
+		}
+
+		/* Dispatch Tx handler */
+		tdm_if_register_ops->tdm_if_pcm_ops.pcm_tx_callback(txBuff, buff_size);
+
+		if(test_enable == 0) {
+			/* Fill Tx aggregated buffer */
+#ifdef CONFIG_MV_TDM_SUPPORT
+			if(mvTdmTx(txBuff) != MV_OK)
+#else
+			if(mvCommUnitTx(txBuff) != MV_OK)
+#endif /* CONFIG_MV_TDM_SUPPORT */
+				printk("%s: could not fill Tx buffer\n",__FUNCTION__);
+		}
+	}
+
+	/* Clear txBuff for next iteration */
+	txBuff = NULL;
+
+	TRC_REC("<-%s\n",__FUNCTION__);
+	return;
+}
+
+void tdm_if_stats_get(tdm_if_stats_t* tdm_if_stats)
+{
+	tdm_if_stats->tdm_init = tdm_init;
+	tdm_if_stats->rx_miss = rx_miss;
+	tdm_if_stats->tx_miss = tx_miss;
+	tdm_if_stats->rx_over = rx_over;
+	tdm_if_stats->tx_under = tx_under;
+
+	return;
+}
+
+static int __init tdm_if_module_init(void)
+{
+	/* The real init is done later */
+	return 0;
+}
+
+static void __exit tdm_if_module_exit(void)
+{
+	tdm_if_exit();
+	return;
+}
+
+/* Module stuff */
+module_init(tdm_if_module_init);
+module_exit(tdm_if_module_exit);
+MODULE_DESCRIPTION("Marvell TDM I/F Device Driver - www.marvell.com");
+MODULE_AUTHOR("Eran Ben-Avi <benavi@marvell.com>");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/tdm_if.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/tdm_if.h
new file mode 100644
index 0000000..3581229
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/tdm_if.h
@@ -0,0 +1,118 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef _TDM_IF_H_
+#define _TDM_IF_H_
+
+#include "mvSysTdmApi.h"
+#ifdef CONFIG_MV_TDM_SUPPORT
+ #include "voiceband/tdm/mvTdm.h"
+#else
+ #include "voiceband/commUnit/mvCommUnit.h"
+#endif
+#include "ctrlEnv/mvCtrlEnvSpec.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "boardEnv/mvBoardEnvLib.h"
+
+
+/* Structures */
+typedef struct {
+	int tdm_init;
+	unsigned int rx_miss;
+	unsigned int tx_miss;
+	unsigned int rx_over;
+	unsigned int tx_under;
+} tdm_if_stats_t;
+
+typedef struct {
+	MV_PCM_FORMAT pcm_format;
+	unsigned short pcm_slot[32];
+	unsigned char sampling_period;
+	unsigned short total_lines;
+	unsigned short test_enable;
+} tdm_if_params_t;
+
+/* control callbacks */
+typedef struct {
+	void (*ctl_pcm_start)(void);
+	void (*ctl_pcm_stop)(void);
+} tdm_if_ctl_ops_t;
+
+/* pcm callbacks */
+typedef struct {
+	void (*pcm_tx_callback)(unsigned char* tx_buff, int size);
+	void (*pcm_rx_callback)(unsigned char* rx_buff, int size);
+} tdm_if_pcm_ops_t;
+
+typedef struct {
+	tdm_if_ctl_ops_t tdm_if_ctl_ops;
+	tdm_if_pcm_ops_t tdm_if_pcm_ops;
+} tdm_if_register_ops_t;
+
+/* APIs */
+void tdm_if_stats_get(tdm_if_stats_t* tdm_if_stats);
+MV_STATUS tdm_if_init(tdm_if_register_ops_t* register_ops, tdm_if_params_t* tdm_if_params);
+void tdm_if_exit(void);
+
+#endif /*_TDM_IF_H_*/
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/test/Makefile b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/test/Makefile
new file mode 100644
index 0000000..669d894
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/test/Makefile
@@ -0,0 +1,12 @@
+
+
+#
+# Makefile for the Marvell Phone Device Driver Test Module
+#
+#
+
+ifeq ($(CONFIG_PLAT_ARMADA),y)
+	include $(srctree)/$(MACHINE)/config/mvRules.mk
+endif
+
+obj-$(CONFIG_MV_INCLUDE_TDM) += tdm_dev.o
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/test/tdm_dev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/test/tdm_dev.c
new file mode 100644
index 0000000..ea8329b
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/test/tdm_dev.c
@@ -0,0 +1,394 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+******************************************************************************/
+
+#include "tdm_dev.h"
+#include "mv_phone/tdm/tal.h"
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/version.h>
+#ifdef CONFIG_MV_TDM_SUPPORT
+ #include "voiceband/tdm/mvTdm.h"
+#else
+ #include "voiceband/commUnit/mvCommUnit.h"
+#endif
+
+#define TDM_DEV_NAME 	"tdm"
+#define DISABLE		0
+#define ENABLE		1
+
+/* GLobals */
+static DECLARE_WAIT_QUEUE_HEAD(tdm_dev_wait);
+static DEFINE_SPINLOCK(tdm_dev_lock);
+static tal_params_t tdm_dev_params;
+static tal_mmp_ops_t tdm_dev_ops;
+static atomic_t tdm_init, rx_ready, tx_ready;
+static unsigned char *rx_buff_p = NULL, *tx_buff_p = NULL;
+static unsigned char rx_temp_buff[MV_TDM_TOTAL_CHANNELS * MV_TDM_TOTAL_CH_SAMPLES * 4];
+
+/* Forward declarations */
+static int tdm_dev_tdm_start(unsigned long arg);
+static ssize_t tdm_dev_read(struct file *file_p, char __user *buf, size_t size, loff_t * ppos);
+static ssize_t tdm_dev_write(struct file *file_p, const char __user *buf, size_t size, loff_t * ppos);
+static unsigned int tdm_dev_poll(struct file *file_p, poll_table *poll_table_p);
+static int tdm_dev_ioctl(struct inode *inode_p, struct file *file_p, unsigned int cmd, unsigned long arg);
+#ifdef HAVE_UNLOCKED_IOCTL
+static long tdm_dev_unlocked_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
+#endif
+static int tdm_dev_open(struct inode *inode_p, struct file *file_p);
+static int tdm_dev_release(struct inode *inode_p, struct file *file_p);
+void tdm_dev_tx_callback(unsigned char* tx_buff, int size);
+void tdm_dev_rx_callback(unsigned char* rx_buff, int size);
+static int __init tdm_dev_init(void);
+static void __exit tdm_dev_exit(void);
+
+static struct file_operations tdm_dev_fops = {
+    owner:      THIS_MODULE,
+    llseek:     NULL,
+    read:       tdm_dev_read,
+    write:      tdm_dev_write,
+    poll:       tdm_dev_poll,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)
+    ioctl:	tdm_dev_ioctl,
+#endif
+#ifdef HAVE_UNLOCKED_IOCTL
+    unlocked_ioctl: tdm_dev_unlocked_ioctl,
+#endif
+    open:       tdm_dev_open,
+    release:    tdm_dev_release,
+    fasync:     NULL
+};
+
+static struct miscdevice tdm_dev_misc_dev = {
+	.minor = TDMDEV_MINOR,
+	.name = TDM_DEV_NAME,
+	.fops = &tdm_dev_fops,
+};
+
+
+static int __init tdm_dev_init(void)
+{
+	int status;
+
+	printk("Loading Marvell tdm device\n");
+	status = misc_register(&tdm_dev_misc_dev);
+
+	/* Register tdm device */
+	if (status < 0) {
+		printk("Error, failed to load %s device(status %d)\n", TDM_DEV_NAME, status);
+		return status;
+	}
+
+	atomic_set(&tdm_init, DISABLE);
+
+	return 0;
+}
+
+static int tdm_dev_tdm_start(unsigned long arg)
+{
+	tdm_dev_params_t data;
+	int i;
+
+	/* Get user data */
+	if(copy_from_user(&data, (void*)arg, sizeof(tdm_dev_params_t))) {
+		printk("%s: copy_from_user failed\n", __FUNCTION__);
+		return -EFAULT;
+	}
+
+	/* Check parameters */
+	if((data.pcm_format != 1) && (data.pcm_format != 2) && (data.pcm_format != 4)) {
+		printk("%s: bad parameter(pcm_format=%u)\n", __FUNCTION__, data.pcm_format);
+		return -EFAULT;
+	}
+
+	if(data.total_lines > MV_TDM_TOTAL_CHANNELS) {
+		printk("%s: bad parameter(data.total_lines=%u)\n", __FUNCTION__, data.total_lines);
+		return -EFAULT;
+	}
+
+	tdm_dev_params.pcm_format = (tal_pcm_format_t)data.pcm_format;
+	/* Fill time slot table */
+	for(i = 0; i < data.total_lines; i++)
+		tdm_dev_params.pcm_slot[i] = ((i+1) * data.pcm_format); /* skip time slot #0 */
+
+	tdm_dev_params.sampling_period = MV_TDM_BASE_SAMPLING_PERIOD;
+	tdm_dev_params.total_lines = data.total_lines;
+	tdm_dev_params.test_enable = 1;
+
+	/* Assign Rx/Tx callbacks */
+	tdm_dev_ops.tal_mmp_rx_callback = tdm_dev_rx_callback;
+	tdm_dev_ops.tal_mmp_tx_callback = tdm_dev_tx_callback;
+
+	if(tal_init(&tdm_dev_params, &tdm_dev_ops) != MV_OK) {
+		printk("%s: Error, could not init tdm driver\n",__FUNCTION__);
+		return -EFAULT;
+	}
+
+	/* Prepare globals */
+	atomic_set(&tdm_init, ENABLE);
+	atomic_set(&rx_ready, DISABLE);
+	atomic_set(&tx_ready, DISABLE);
+	rx_buff_p = NULL;
+	tx_buff_p = NULL;
+
+	return 0;
+}
+
+static ssize_t tdm_dev_read(struct file *file_p, char __user *buf, size_t size, loff_t * ppos)
+{
+	size_t ret = size;
+
+	TRC_REC("->%s\n",__FUNCTION__);
+
+	if(rx_buff_p != NULL) {
+		if (copy_to_user(buf, rx_buff_p, size))
+			ret = -EFAULT;
+		rx_buff_p = NULL;
+		atomic_set(&rx_ready, DISABLE);
+	} else {
+		ret = 0;
+		TRC_REC("%s: missed Rx buffer\n",__FUNCTION__);
+	}
+
+	TRC_REC("<-%s\n",__FUNCTION__);
+
+	return ret;
+}
+
+static ssize_t tdm_dev_write(struct file *file_p, const char __user *buf, size_t size, loff_t * ppos)
+{
+	unsigned long flags = 0;
+	MV_STATUS status;
+	size_t ret = size;
+
+	TRC_REC("->%s\n",__FUNCTION__);
+
+	if(tx_buff_p != NULL) {
+		if (copy_from_user(tx_buff_p, buf, size))
+			ret = -EFAULT;
+		atomic_set(&tx_ready, DISABLE);
+		spin_lock_irqsave(&tdm_dev_lock, flags);
+#ifdef CONFIG_MV_TDM_SUPPORT
+		status = mvTdmTx(tx_buff_p);
+#else
+		status = mvCommUnitTx(tx_buff_p);
+#endif
+		spin_unlock_irqrestore(&tdm_dev_lock, flags);
+		tx_buff_p = NULL;
+		if(status != MV_OK)
+			printk("%s: could not fill Tx buffer\n",__FUNCTION__);
+	} else {
+		ret = 0;
+		TRC_REC("%s: missed Tx buffer\n",__FUNCTION__);
+	}
+	TRC_REC("<-%s\n",__FUNCTION__);
+
+	return ret;
+}
+
+static unsigned int tdm_dev_poll(struct file *file_p, poll_table *poll_table_p)
+{
+	int mask = 0;
+
+	TRC_REC("->%s\n",__FUNCTION__);
+
+	poll_wait(file_p, &tdm_dev_wait, poll_table_p);
+
+	if(atomic_read(&rx_ready)) {
+		mask |= POLLIN | POLLRDNORM;	/* readable */
+		TRC_REC("poll can read\n");
+	}
+
+	if(atomic_read(&tx_ready)) {
+		mask |= POLLOUT | POLLWRNORM;	/* writable */
+		TRC_REC("poll can write\n");
+	}
+
+	TRC_REC("<-%s\n",__FUNCTION__);
+	return mask;
+}
+
+static int tdm_dev_ioctl(struct inode *inode_p, struct file *file_p, unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+
+	/* Argument checking */
+	if (_IOC_TYPE(cmd) != TDM_DEV_IOCTL_MAGIC) {
+		printk("%s: invalid TDM DEV Magic Num %i %i\n", __FUNCTION__, _IOC_TYPE(cmd), TDM_DEV_IOCTL_MAGIC);
+		return -ENOTTY;
+	}
+
+	if ((_IOC_NR(cmd) > TDM_DEV_IOCTL_MAX) || (_IOC_NR(cmd) < TDM_DEV_IOCTL_MIN)) {
+		printk("%s: invalid TDM DEV IOCTL request\n", __FUNCTION__);
+		return -ENOTTY;
+	}
+
+	if (_IOC_DIR(cmd) & _IOC_READ) {
+		ret = !access_ok(VERIFY_WRITE, (void __user*)arg, _IOC_SIZE(cmd));
+	}
+	else if (_IOC_DIR(cmd) & _IOC_WRITE) {
+		ret = !access_ok(VERIFY_READ, (void __user*)arg, _IOC_SIZE(cmd));
+	}
+
+	if (ret) {
+		printk("%s: invalid TDM DEV access type %i from cmd %i\n", __FUNCTION__, _IOC_DIR(cmd), cmd);
+		return -EFAULT;
+	}
+
+	switch (cmd) {
+		case TDM_DEV_TDM_START:
+			printk("ioctl: TDM_DEV_TDM_START\n");
+			ret = tdm_dev_tdm_start(arg);
+			break;
+
+		case TDM_DEV_TDM_STOP:
+			atomic_set(&tdm_init, DISABLE);
+			tal_exit();
+			printk("ioctl: TDM_DEV_TDM_STOP\n");
+			break;
+
+		case TDM_DEV_PCM_START:
+			printk("ioctl: TDM_DEV_PCM_START\n");
+			atomic_set(&rx_ready, DISABLE);
+			atomic_set(&tx_ready, DISABLE);
+			rx_buff_p = NULL;
+			tx_buff_p = NULL;
+			tal_pcm_start();
+			break;
+
+		case TDM_DEV_PCM_STOP:
+			tal_pcm_stop();
+			printk("ioctl: TDM_DEV_PCM_STOP\n");
+			break;
+	}
+
+	return ret;
+}
+
+#ifdef HAVE_UNLOCKED_IOCTL
+static long
+tdm_dev_unlocked_ioctl(
+	struct file *filp,
+	unsigned int cmd,
+	unsigned long arg)
+{
+	return tdm_dev_ioctl(NULL, filp, cmd, arg);
+}
+#endif
+
+static int tdm_dev_open(struct inode *inode_p, struct file *file_p)
+{
+	try_module_get(THIS_MODULE);
+	return 0;
+}
+
+static int tdm_dev_release(struct inode *inode_p, struct file *file_p)
+{
+	module_put(THIS_MODULE);
+	return 0;
+}
+
+void tdm_dev_tx_callback(unsigned char* tx_buff, int size)
+{
+	TRC_REC("->%s\n",__FUNCTION__);
+
+	tx_buff_p = tx_buff;
+	atomic_set(&tx_ready, ENABLE);
+	wake_up_interruptible(&tdm_dev_wait);
+
+	TRC_REC("<-%s\n",__FUNCTION__);
+	return;
+}
+
+void tdm_dev_rx_callback(unsigned char* rx_buff, int size)
+{
+	TRC_REC("->%s\n",__FUNCTION__);
+
+	rx_buff_p = rx_temp_buff;
+	memcpy(rx_buff_p, rx_buff, size);
+	atomic_set(&rx_ready, ENABLE);
+	wake_up_interruptible(&tdm_dev_wait);
+
+	TRC_REC("<-%s\n",__FUNCTION__);
+	return;
+}
+
+static void __exit tdm_dev_exit(void)
+{
+	printk("Marvell telephony test device exits\n");
+
+	/* Stop TDM channels and release all resources */
+	tal_exit();
+
+	/* Unregister tdm misc device */
+	misc_deregister(&tdm_dev_misc_dev);
+}
+
+/* Module stuff */
+module_init(tdm_dev_init);
+module_exit(tdm_dev_exit);
+MODULE_DESCRIPTION("Marvell Telephony Test Device - www.marvell.com");
+MODULE_AUTHOR("Eran Ben-Avi <benavi@marvell.com>");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/test/tdm_dev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/test/tdm_dev.h
new file mode 100644
index 0000000..447693e
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_phone/tdm/test/tdm_dev.h
@@ -0,0 +1,86 @@
+/*******************************************************************************
+Copyright (C) Marvell International Ltd. and its affiliates
+
+This software file (the "File") is owned and distributed by Marvell
+International Ltd. and/or its affiliates ("Marvell") under the following
+alternative licensing terms.  Once you have made an election to distribute the
+File under one of the following license alternatives, please (i) delete this
+introductory statement regarding license alternatives, (ii) delete the two
+license alternatives that you have not elected to use and (iii) preserve the
+Marvell copyright notice above.
+
+********************************************************************************
+Marvell Commercial License Option
+
+If you received this File from Marvell and you have entered into a commercial
+license agreement (a "Commercial License") with Marvell, the File is licensed
+to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+Marvell GPL License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
+disclaimer.
+********************************************************************************
+Marvell BSD License Option
+
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+    *   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+        used to endorse or promote products derived from this software without
+        specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+#ifndef _TDM_DEV_H_
+#define _TDM_DEV_H_
+
+#define TDM_DEV_IOCTL_MAGIC		't'
+
+#define TDM_DEV_IOCTL_MIN 		1
+
+#define TDM_DEV_TDM_START		_IOWR(TDM_DEV_IOCTL_MAGIC, 1, tdm_dev_params_t)
+#define TDM_DEV_TDM_STOP		_IO(TDM_DEV_IOCTL_MAGIC, 2)
+#define TDM_DEV_PCM_START		_IO(TDM_DEV_IOCTL_MAGIC, 3)
+#define TDM_DEV_PCM_STOP		_IO(TDM_DEV_IOCTL_MAGIC, 4)
+
+#define TDM_DEV_IOCTL_MAX 		4
+
+typedef struct tdm_dev_params {
+	unsigned char pcm_format;
+	unsigned short total_lines;
+} tdm_dev_params_t;
+
+/* APIs */
+
+#endif /*_TDM_DEV_H_*/
diff --git a/arch/arm/plat-armada/mv_hal/voiceband/commUnit/mvCommUnit.c b/arch/arm/plat-armada/mv_hal/voiceband/commUnit/mvCommUnit.c
index 4682a75..ccab519 100644
--- a/arch/arm/plat-armada/mv_hal/voiceband/commUnit/mvCommUnit.c
+++ b/arch/arm/plat-armada/mv_hal/voiceband/commUnit/mvCommUnit.c
@@ -64,14 +64,19 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #include "voiceband/commUnit/mvCommUnit.h"
 
-#undef MV_COMM_UNIT_DEBUG
+#undef	MV_COMM_UNIT_DEBUG
+#define	MV_COMM_UNIT_RPT_SUPPORT /* Repeat mode must be set */
+#undef	MV_COMM_UNIT_TEST_SUPPORT
 
 /* defines */
 #define TOTAL_CHAINS		2
 #define CONFIG_RBSZ		16
 #define NEXT_BUFF(buff)		((buff + 1) % TOTAL_CHAINS)
 #define PREV_BUFF(buff)		(buff == 0 ? (TOTAL_CHAINS-1) : (buff-1))
-#define MAX_POLL_USEC		10000	/* 10ms */
+#define MAX_POLL_USEC		100000	/* 100ms */
+#define IS_KW2_A0(model, rev)	((((model & 0xff00) == 0x6500) && (rev > 1)) ? 1 : 0)
+#define COMM_UNIT_SW_RST	(1 << 5)
+#define OLD_INT_WA_BIT		(1 << 15)
 
 /* globals */
 static MV_STATUS tdmEnable;
@@ -88,21 +93,21 @@ static MV_TDM_MCDMA_RX_DESC *mcdmaRxDescPtr[TOTAL_CHAINS];
 static MV_TDM_MCDMA_TX_DESC *mcdmaTxDescPtr[TOTAL_CHAINS];
 static MV_ULONG mcdmaRxDescPhys[TOTAL_CHAINS], mcdmaTxDescPhys[TOTAL_CHAINS];
 static MV_TDM_DPRAM_ENTRY defDpramEntry = { 0, 0, 0x1, 0x1, 0, 0, 0x1, 0, 0, 0, 0 };
+static MV_U16 ctrlModel;
+static MV_U16 ctrlRev;
 
-#ifdef MV_COMM_UNIT_DEBUG
-static MV_U8 *iqcVirt;
-static MV_ULONG iqcPhys;
-#endif
-
-/* static APIs */
+/* Static APIs */
+static MV_VOID mvCommUnitDescChainBuild(MV_VOID);
+static MV_VOID mvCommUnitMcdmaMcscStart(MV_VOID);
+static MV_VOID mvCommUnitMcdmaStop(MV_VOID);
+static MV_VOID mvCommUnitMcdmaMcscAbort(MV_VOID);
 
 MV_STATUS mvCommUnitHalInit(MV_TDM_PARAMS *tdmParams, MV_TDM_HAL_DATA *halData)
 {
-	MV_U8 index;
-	MV_U16 pcmSlot;
+	MV_U16 pcmSlot, index;
 	MV_U32 buffSize, chan;
-	MV_U32 totalRxDescSize, totalTxDescSize;
-	MV_U32 rxDescPhysAddr, txDescPhysAddr, maxPoll;
+	MV_U32 totalRxDescSize, totalTxDescSize, chMask;
+	MV_U32 maxPoll, clkSyncCtrlReg;
 	MV_TDM_DPRAM_ENTRY actDpramEntry, *pActDpramEntry;
 
 	MV_TRC_REC("->%s\n", __func__);
@@ -115,6 +120,8 @@ MV_STATUS mvCommUnitHalInit(MV_TDM_PARAMS *tdmParams, MV_TDM_HAL_DATA *halData)
 	totalChannels = tdmParams->totalChannels;
 	prevRxBuff = 0;
 	nextTxBuff = 0;
+	ctrlModel = halData->model;
+	ctrlRev = halData->ctrlRev;
 
 	/* Check parameters */
 	if ((tdmParams->totalChannels > MV_TDM_TOTAL_CHANNELS) ||
@@ -131,17 +138,6 @@ MV_STATUS mvCommUnitHalInit(MV_TDM_PARAMS *tdmParams, MV_TDM_HAL_DATA *halData)
 	/* Calculate single Rx/Tx buffer size */
 	buffSize = (sampleSize * MV_TDM_TOTAL_CH_SAMPLES * samplingCoeff);
 
-#ifdef MV_COMM_UNIT_DEBUG
-#if 0
-	iqcVirt = (MV_U8 *) mvOsIoUncachedMalloc(NULL, 516, &iqcPhys, NULL);
-
-	if ((MV_U32) iqcVirt & 0x3f)
-		mvOsPrintf("Error, unaligned IQC buffer(0x%x)\n", (MV_U32) iqcVirt);
-
-	memset(iqcVirt, 0, 516);
-#endif
-#endif
-
 	/* Allocate cached data buffers for all channels */
 	TRC_REC("%s: allocate %dB for data buffers\n", __func__, (buffSize * totalChannels));
 	for (index = 0; index < TOTAL_CHAINS; index++) {
@@ -161,13 +157,17 @@ MV_STATUS mvCommUnitHalInit(MV_TDM_PARAMS *tdmParams, MV_TDM_HAL_DATA *halData)
 		/* Clear buffers */
 		memset(rxBuffVirt[index], 0, (buffSize * totalChannels));
 		memset(txBuffVirt[index], 0, (buffSize * totalChannels));
-#if 0
+#ifdef MV_COMM_UNIT_TEST_SUPPORT
+	/* Fill Tx buffers with incremental pattern */
 		{
-			int i;
-			for (i = 0; i < 160; i += 2)
-				*(MV_U16 *) (txBuffVirt[index] + i) = (MV_U16) (0xca00 + ((i / 2) + (index * 80)));
+			int i, j;
+			for (j = 0; j < totalChannels; j++) {
+				for (i = 0; i < buffSize; i++)
+					*(MV_U8 *) (txBuffVirt[index]+i+(j*buffSize)) = (MV_U8)(i+1);
+			}
 		}
 #endif
+
 		/* Flush+Inv buffers */
 		mvOsCacheFlushInv(NULL, rxBuffVirt[index], (buffSize * totalChannels));
 		mvOsCacheFlushInv(NULL, txBuffVirt[index], (buffSize * totalChannels));
@@ -196,40 +196,6 @@ MV_STATUS mvCommUnitHalInit(MV_TDM_PARAMS *tdmParams, MV_TDM_HAL_DATA *halData)
 		memset(mcdmaTxDescPtr[index], 0, totalTxDescSize);
 	}
 
-	/* Initialize descriptors fields */
-	for (chan = 0; chan < totalChannels; chan++) {
-		for (index = 0; index < TOTAL_CHAINS; index++) {
-			/* Associate data buffers to descriptors physBuffPtr */
-			((MV_TDM_MCDMA_RX_DESC *) (mcdmaRxDescPtr[index] + chan))->physBuffPtr =
-			    (MV_U32) (rxBuffPhys[index] + (chan * buffSize));
-			((MV_TDM_MCDMA_TX_DESC *) (mcdmaTxDescPtr[index] + chan))->physBuffPtr =
-			    (MV_U32) (txBuffPhys[index] + (chan * buffSize));
-
-			/* Build cyclic descriptors chain for each channel */
-			((MV_TDM_MCDMA_RX_DESC *) (mcdmaRxDescPtr[index] + chan))->physNextDescPtr =
-			    (MV_U32) (mcdmaRxDescPhys[((index + 1) % TOTAL_CHAINS)] +
-				      (chan * sizeof(MV_TDM_MCDMA_RX_DESC)));
-
-			((MV_TDM_MCDMA_TX_DESC *) (mcdmaTxDescPtr[index] + chan))->physNextDescPtr =
-			    (MV_U32) (mcdmaTxDescPhys[((index + 1) % TOTAL_CHAINS)] +
-				      (chan * sizeof(MV_TDM_MCDMA_TX_DESC)));
-
-			/* Set Byte_Count/Buffer_Size Rx descriptor fields */
-			((MV_TDM_MCDMA_RX_DESC *) (mcdmaRxDescPtr[index] + chan))->byteCnt = 0;
-			((MV_TDM_MCDMA_RX_DESC *) (mcdmaRxDescPtr[index] + chan))->buffSize = buffSize;
-
-			/* Set Shadow_Byte_Count/Byte_Count Tx descriptor fields */
-			((MV_TDM_MCDMA_TX_DESC *) (mcdmaTxDescPtr[index] + chan))->shadowByteCnt = buffSize;
-			((MV_TDM_MCDMA_TX_DESC *) (mcdmaTxDescPtr[index] + chan))->byteCnt = buffSize;
-
-			/* Set Command/Status Rx/Tx descriptor fields */
-			((MV_TDM_MCDMA_RX_DESC *) (mcdmaRxDescPtr[index] + chan))->cmdStatus =
-			    (CONFIG_MCDMA_DESC_CMD_STATUS);
-			((MV_TDM_MCDMA_TX_DESC *) (mcdmaTxDescPtr[index] + chan))->cmdStatus =
-			    (CONFIG_MCDMA_DESC_CMD_STATUS);
-		}
-	}
-
 	/* Poll MCDMA for reset completion */
 	maxPoll = 0;
 	while ((maxPoll < MAX_POLL_USEC) && !(MV_REG_READ(MCDMA_GLOBAL_CONTROL_REG) & MCDMA_RID_MASK)) {
@@ -279,6 +245,18 @@ MV_STATUS mvCommUnitHalInit(MV_TDM_PARAMS *tdmParams, MV_TDM_HAL_DATA *halData)
 	/**********************/
 	/* MCSC Configuration */
 	/**********************/
+
+	if (IS_KW2_A0(ctrlModel, ctrlRev)) {
+		/* Disable Rx/Tx channel balancing & Linear mode fix */
+		MV_REG_BIT_SET(MCSC_GLOBAL_CONFIG_REG, MCSC_GLOBAL_CONFIG_TCBD_MASK);
+#if 0
+		/* Unmask Rx/Tx channel balancing */
+		chMask = (0xffffffff & ~((MV_U32)((1 << totalChannels) - 1)));
+		MV_REG_WRITE(MCSC_RX_CHANNEL_BALANCING_MASK_REG, chMask);
+		MV_REG_WRITE(MCSC_TX_CHANNEL_BALANCING_MASK_REG, chMask);
+#endif
+	}
+
 	for (chan = 0; chan < totalChannels; chan++) {
 		MV_REG_WRITE(MCSC_CHx_RECEIVE_CONFIG_REG(chan), CONFIG_MRCRx);
 		MV_REG_WRITE(MCSC_CHx_TRANSMIT_CONFIG_REG(chan), CONFIG_MTCRx);
@@ -293,75 +271,118 @@ MV_STATUS mvCommUnitHalInit(MV_TDM_PARAMS *tdmParams, MV_TDM_HAL_DATA *halData)
 	/*************************************************/
 	/* Time Division Multiplexing(TDM) Configuration */
 	/*************************************************/
-	/* Reset all Rx/Tx DPRAM entries to default value */
 	pActDpramEntry = &actDpramEntry;
 	memcpy(&actDpramEntry, &defDpramEntry, sizeof(MV_TDM_DPRAM_ENTRY));
-	for (index = 0; index < MV_TDM_MAX_DPRAM_ENTRIES; index++) {
+	/* Set repeat mode bits for (sampleSize > 1) */
+	pActDpramEntry->rpt = ((sampleSize == MV_PCM_FORMAT_1BYTE) ? 0 : 1);
+
+	/* Reset all Rx/Tx DPRAM entries to default value */
+	for (index = 0; index < (2 * MV_TDM_MAX_HALF_DPRAM_ENTRIES); index++) {
 		MV_REG_WRITE(FLEX_TDM_RDPR_REG(index), *((MV_U32 *) pActDpramEntry));
 		MV_REG_WRITE(FLEX_TDM_TDPR_REG(index), *((MV_U32 *) pActDpramEntry));
 	}
 
-	/* Fill active Rx/Tx DPRAM entries */
-	pActDpramEntry->mask = 0xff;
+	/* Set active Rx/Tx DPRAM entries */
 	for (chan = 0; chan < totalChannels; chan++) {
+		/* Same time slot number for both Rx & Tx */
 		pcmSlot = tdmParams->pcmSlot[chan];
+
+		/* Verify time slot is within frame boundries */
+		if (pcmSlot >= halData->frameTs) {
+			mvOsPrintf("Error, time slot(%d) exceeded maximum(%d)\n", pcmSlot, halData->frameTs);
+			return MV_ERROR;
+		}
+
+		/* Verify time slot is aligned to sample size */
+		if ((sampleSize > MV_PCM_FORMAT_1BYTE) && (pcmSlot & 1)) {
+			mvOsPrintf("Error, time slot(%d) not aligned to Linear PCM sample size\n", pcmSlot);
+			return MV_ERROR;
+		}
+
+		/* Update relevant DPRAM fields */
 		pActDpramEntry->ch = chan;
-		for (index = 0; index < sampleSize; index++) {
-			MV_REG_WRITE(FLEX_TDM_RDPR_REG((pcmSlot + index)), *((MV_U32 *) pActDpramEntry));
-			MV_REG_WRITE(FLEX_TDM_TDPR_REG((pcmSlot + index)), *((MV_U32 *) pActDpramEntry));
+		pActDpramEntry->mask = 0xff;
+
+		/* Extract physical DPRAM entry id */
+		index = ((sampleSize == MV_PCM_FORMAT_1BYTE) ? pcmSlot : (pcmSlot / 2));
+
+		/* DPRAM low half */
+		MV_REG_WRITE(FLEX_TDM_RDPR_REG(index), *((MV_U32 *) pActDpramEntry));
+		MV_REG_WRITE(FLEX_TDM_TDPR_REG(index), *((MV_U32 *) pActDpramEntry));
+
+		/* DPRAM high half(mirroring DPRAM low half) */
+		pActDpramEntry->mask = 0;
+		MV_REG_WRITE(FLEX_TDM_RDPR_REG((MV_TDM_MAX_HALF_DPRAM_ENTRIES + index)), *((MV_U32 *) pActDpramEntry));
+		MV_REG_WRITE(FLEX_TDM_TDPR_REG((MV_TDM_MAX_HALF_DPRAM_ENTRIES + index)), *((MV_U32 *) pActDpramEntry));
+
+		/* WideBand mode */
+		if (sampleSize == MV_PCM_FORMAT_4BYTES) {
+			index = (index + (halData->frameTs / sampleSize));
+			/* DPRAM low half */
+			pActDpramEntry->mask = 0xff;
+			MV_REG_WRITE(FLEX_TDM_RDPR_REG(index), *((MV_U32 *) pActDpramEntry));
+			MV_REG_WRITE(FLEX_TDM_TDPR_REG(index), *((MV_U32 *) pActDpramEntry));
+
+			/* DPRAM high half(mirroring DPRAM low half) */
+			pActDpramEntry->mask = 0;
+			MV_REG_WRITE(FLEX_TDM_RDPR_REG((MV_TDM_MAX_HALF_DPRAM_ENTRIES + index)), *((MV_U32 *) pActDpramEntry));
+			MV_REG_WRITE(FLEX_TDM_TDPR_REG((MV_TDM_MAX_HALF_DPRAM_ENTRIES + index)), *((MV_U32 *) pActDpramEntry));
 		}
 	}
 
-	/* Fill non-active Rx/Tx DPRAM entries(except last) */
+	/* Fill last Tx/Rx DPRAM entry('LAST'=1) */
 	pActDpramEntry->mask = 0;
 	pActDpramEntry->ch = 0;
-
-	/* Fill last Tx DPRAM entry('LAST'=1) */
 	pActDpramEntry->last = 1;
-	MV_REG_WRITE(FLEX_TDM_TDPR_REG((MV_TDM_MAX_DPRAM_ENTRIES - 1)), *((MV_U32 *) pActDpramEntry));
-#if !defined(MV_COMM_UNIT_FSYNC_STRB_SUPPORT)
-	MV_REG_WRITE(FLEX_TDM_RDPR_REG((MV_TDM_MAX_DPRAM_ENTRIES - 1)), *((MV_U32 *) pActDpramEntry));
-#else
-	/* Spread last Rx byte on 8 entries in bit mode */
-	pActDpramEntry->last = 0;
-	pActDpramEntry->mask = 1;
-	pActDpramEntry->byte = 0;
-	pActDpramEntry->tbs = 0;
-	for (index = (MV_TDM_MAX_DPRAM_ENTRIES - 1); index < (MV_TDM_MAX_DPRAM_ENTRIES + 7); index++) {
-		if (index == (MV_TDM_MAX_DPRAM_ENTRIES + 6)) {
-			pActDpramEntry->last = 1;
-			pActDpramEntry->tbs = 1;
-			pActDpramEntry->strb = 3;
-		}
 
-		MV_REG_WRITE(FLEX_TDM_RDPR_REG(index), *((MV_U32 *) pActDpramEntry));
-	}
-#endif /* MV_COMM_UNIT_FSYNC_STRB_SUPPORT */
+	/* Index for last entry */
+	if (sampleSize == MV_PCM_FORMAT_1BYTE)
+		index = (halData->frameTs - 1);
+	else
+		index = ((halData->frameTs / 2) - 1);
+
+	/* Low half */
+	MV_REG_WRITE(FLEX_TDM_TDPR_REG(index), *((MV_U32 *) pActDpramEntry));
+	MV_REG_WRITE(FLEX_TDM_RDPR_REG(index), *((MV_U32 *) pActDpramEntry));
+	/* High half */
+	MV_REG_WRITE(FLEX_TDM_TDPR_REG((MV_TDM_MAX_HALF_DPRAM_ENTRIES + index)), *((MV_U32 *) pActDpramEntry));
+	MV_REG_WRITE(FLEX_TDM_RDPR_REG((MV_TDM_MAX_HALF_DPRAM_ENTRIES + index)), *((MV_U32 *) pActDpramEntry));
 
 	/* Set TDM_CLK_AND_SYNC_CONTROL register */
-	MV_REG_WRITE(TDM_CLK_AND_SYNC_CONTROL_REG, CONFIG_TDM_CLK_AND_SYNC_CONTROL);
+	clkSyncCtrlReg = MV_REG_READ(TDM_CLK_AND_SYNC_CONTROL_REG);
+	clkSyncCtrlReg &= ~(TDM_TX_FSYNC_OUT_ENABLE_MASK | TDM_RX_FSYNC_OUT_ENABLE_MASK |
+			TDM_TX_CLK_OUT_ENABLE_MASK | TDM_RX_CLK_OUT_ENABLE_MASK);
+	clkSyncCtrlReg |= CONFIG_TDM_CLK_AND_SYNC_CONTROL;
+	MV_REG_WRITE(TDM_CLK_AND_SYNC_CONTROL_REG, clkSyncCtrlReg);
 
 	/* Set TDM TCR register */
 	MV_REG_WRITE(FLEX_TDM_CONFIG_REG, (MV_REG_READ(FLEX_TDM_CONFIG_REG) | CONFIG_FLEX_TDM_CONFIG));
 
+#if 0
+	/* Set TDM_PLUS_MINUS_DELAY_CTRL_FSYNC_OUT register */
+	MV_REG_WRITE(TDM_PLUS_MINUS_DELAY_CTRL_FSYNC_OUT_REG, CONFIG_TDM_PLUS_MINUS_DELAY_CTRL_FSYNC_OUT);
+
+	/* Set TDM_PLUS_MINUS_DELAY_CTRL_FSYNC_IN register */
+	MV_REG_WRITE(TDM_PLUS_MINUS_DELAY_CTRL_FSYNC_IN_REG, CONFIG_TDM_PLUS_MINUS_DELAY_CTRL_FSYNC_IN);
+
+	/* Restart calculation */
+	MV_REG_BIT_SET(TDM_PLUS_MINUS_DELAY_CTRL_FSYNC_OUT_REG,
+				(TX_SYNC_DELAY_OUT_RESTART_CALC_MASK | RX_SYNC_DELAY_OUT_RESTART_CALC_MASK));
+	MV_REG_BIT_SET(TDM_PLUS_MINUS_DELAY_CTRL_FSYNC_IN_REG,
+				(TX_SYNC_DELAY_IN_RESTART_CALC_MASK | RX_SYNC_DELAY_IN_RESTART_CALC_MASK));
+	mvOsDelay(1);
+	MV_REG_BIT_RESET(TDM_PLUS_MINUS_DELAY_CTRL_FSYNC_OUT_REG,
+				(TX_SYNC_DELAY_OUT_RESTART_CALC_MASK | RX_SYNC_DELAY_OUT_RESTART_CALC_MASK));
+	MV_REG_BIT_RESET(TDM_PLUS_MINUS_DELAY_CTRL_FSYNC_IN_REG,
+				(TX_SYNC_DELAY_IN_RESTART_CALC_MASK | RX_SYNC_DELAY_IN_RESTART_CALC_MASK));
+#endif
+
 	/* Set TDM_CLK_DIVIDER_CONTROL register */
 	/*MV_REG_WRITE(TDM_CLK_DIVIDER_CONTROL_REG, TDM_RX_FIXED_DIV_ENABLE_MASK); */
 
 	/* Enable SLIC/s interrupt detection(before Rx/Tx are active) */
 	/*MV_REG_WRITE(TDM_MASK_REG, TDM_SLIC_INT); */
 
-	/* Errata(#1) */
-	MV_REG_BIT_RESET(0xb8ad0, BIT16);
-	MV_REG_BIT_RESET(0xb8ad4, BIT16);
-	MV_REG_BIT_RESET(0xb8ad8, BIT16);
-
-#ifdef MV_COMM_UNIT_DEBUG
-	/* Enable IQC */
-	/* MV_REG_WRITE(0xb2814, (MV_U32)iqcVirt);
-	   MV_REG_WRITE(0xb2818, (MV_U32)(iqcVirt+512));
-	   MV_REG_WRITE(0xb2824, 0xffffffff); */
-#endif
-
 	/**********************************************************************/
 	/* Time Division Multiplexing(TDM) Interrupt Controller Configuration */
 	/**********************************************************************/
@@ -377,60 +398,32 @@ MV_STATUS mvCommUnitHalInit(MV_TDM_PARAMS *tdmParams, MV_TDM_HAL_DATA *halData)
 	MV_REG_WRITE(MCSC_GLOBAL_INT_CAUSE_REG, MCSC_GLOBAL_INT_CAUSE_INIT_DONE_MASK);
 	MV_REG_WRITE(MCSC_EXTENDED_INT_CAUSE_REG, 0);
 
-	/* Set current Rx/Tx descriptors  */
-	for (chan = 0; chan < totalChannels; chan++) {
-		rxDescPhysAddr = mcdmaRxDescPhys[0] + (chan * sizeof(MV_TDM_MCDMA_RX_DESC));
-		txDescPhysAddr = mcdmaTxDescPhys[0] + (chan * sizeof(MV_TDM_MCDMA_TX_DESC));
-		MV_REG_WRITE(MCDMA_CURRENT_RECEIVE_DESC_PTR_REG(chan), rxDescPhysAddr);
-		MV_REG_WRITE(MCDMA_CURRENT_TRANSMIT_DESC_PTR_REG(chan), txDescPhysAddr);
-	}
-
-	/* Set Rx/Tx periodical interrupts */
-	MV_REG_WRITE(VOICE_PERIODICAL_INT_CONTROL_REG, CONFIG_VOICE_PERIODICAL_INT_CONTROL);
-
-	/* MCSC Global Tx Enable */
-	MV_REG_BIT_SET(MCSC_GLOBAL_CONFIG_REG, MCSC_GLOBAL_CONFIG_TXEN_MASK);
-
-	/* Enable MCSC-Tx & MCDMA-Rx */
-	for (chan = 0; chan < totalChannels; chan++) {
-		/* Enable Tx in TMCCx */
-		MV_REG_BIT_SET(MCSC_CHx_TRANSMIT_CONFIG_REG(chan), MTCRx_ET_MASK);
-
-		/* Enable Rx in: MCRDPx */
-		MV_REG_BIT_SET(MCDMA_RECEIVE_CONTROL_REG(chan), MCDMA_ERD_MASK);
-	}
+#ifdef MV_COMM_UNIT_DEBUG
+	mvCommUnitShow();
+#endif
 
-	/* MCSC Global Rx Enable */
-	MV_REG_BIT_SET(MCSC_GLOBAL_CONFIG_REG, MCSC_GLOBAL_CONFIG_RXEN_MASK);
+	/* Enable PCM */
+	mvCommUnitPcmStart();
 
-	/* Enable MCSC-Rx & MCDMA-Tx */
-	for (chan = 0; chan < totalChannels; chan++) {
-		/* Enable Rx in RMCCx */
-		MV_REG_BIT_SET(MCSC_CHx_RECEIVE_CONFIG_REG(chan), MRCRx_ER_MASK);
+	/* Mark TDM I/F as enabled */
+	tdmEnable = MV_TRUE;
 
-		/* Enable Tx in MCTDPx */
-		MV_REG_BIT_SET(MCDMA_TRANSMIT_CONTROL_REG(chan), MCDMA_TXD_MASK);
-	}
+	/* Enable PCLK */
+	MV_REG_WRITE(TDM_DATA_DELAY_AND_CLK_CTRL_REG, (MV_REG_READ(TDM_DATA_DELAY_AND_CLK_CTRL_REG) |
+				CONFIG_TDM_DATA_DELAY_AND_CLK_CTRL));
 
-	/* Wait enough time until MCDMA FIFOs are loaded with data for all active channels */
-	mvOsDelay(100);
+	/* Restore old periodic interrupt mechanism WA */
+	/* MV_REG_BIT_SET(TDM_DATA_DELAY_AND_CLK_CTRL_REG, OLD_INT_WA_BIT); */
 
 	/* Enable TDM */
 	MV_REG_BIT_SET(FLEX_TDM_CONFIG_REG, TDM_TEN_MASK);
 
-	/* Mark TDM I/F as enabled */
-	tdmEnable = MV_TRUE;
-
-	/* MCSC Enter Hunt State */
-	for (chan = 0; chan < totalChannels; chan++)
-		MV_REG_BIT_SET(MCSC_CHx_RECEIVE_CONFIG_REG(chan), MRCRx_ENTER_HUNT_MASK);
-
-
+#if 0
 	/* Poll for Enter Hunt Execution Status */
 	for (chan = 0; chan < totalChannels; chan++) {
 		maxPoll = 0;
 		while ((maxPoll < MAX_POLL_USEC) &&
-		       !(MV_REG_READ(MCSC_CHx_COMM_EXEC_STAT_REG(chan)) & MCSC_EH_E_STAT_MASK)) {
+			!(MV_REG_READ(MCSC_CHx_COMM_EXEC_STAT_REG(chan)) & MCSC_EH_E_STAT_MASK)) {
 			mvOsUDelay(1);
 			maxPoll++;
 		}
@@ -442,111 +435,126 @@ MV_STATUS mvCommUnitHalInit(MV_TDM_PARAMS *tdmParams, MV_TDM_HAL_DATA *halData)
 
 		MV_REG_BIT_RESET(MCSC_CHx_RECEIVE_CONFIG_REG(chan), MRCRx_ENTER_HUNT_MASK);
 	}
-
-#ifdef MV_COMM_UNIT_DEBUG
-	mvCommUnitShow();
 #endif
+
 	MV_TRC_REC("<-%s\n", __func__);
 	return MV_OK;
 }
 
 MV_VOID mvCommUnitRelease(MV_VOID)
 {
-	MV_U32 buffSize, totalRxDescSize, totalTxDescSize, index, chan;
-	MV_U32 maxPoll;
+	MV_U32 buffSize, totalRxDescSize, totalTxDescSize, index;
 
 	MV_TRC_REC("->%s\n", __func__);
 
-	/* Disable Rx/Tx periodical interrupts */
-	MV_REG_WRITE(VOICE_PERIODICAL_INT_CONTROL_REG, 0xffffffff);
+	if (tdmEnable == MV_TRUE) {
 
-	/**********************************/
-	/* Stop MCSC/Rx, MCDMA/Tx and TDM */
-	/**********************************/
-	/* MCSC Rx Abort */
-	for (chan = 0; chan < totalChannels; chan++)
-		MV_REG_BIT_SET(MCSC_CHx_RECEIVE_CONFIG_REG(chan), MRCRx_ABORT_MASK);
+		/* Mark TDM I/F as disabled */
+		tdmEnable = MV_FALSE;
 
-	for (chan = 0; chan < totalChannels; chan++) {
-		maxPoll = 0;
-		while ((maxPoll < MAX_POLL_USEC)
-		       && !(MV_REG_READ(MCSC_CHx_COMM_EXEC_STAT_REG(chan)) & MCSC_ABR_E_STAT_MASK)) {
-			mvOsUDelay(1);
-			maxPoll++;
-		}
+		mvCommUnitPcmStop();
 
-		if (maxPoll >= MAX_POLL_USEC) {
-			mvOsPrintf("%s: Error, MCSC Rx abort timeout(ch%d)\n", __func__, chan);
-			return;
+		mvCommUnitMcdmaMcscAbort();
+
+		if (IS_KW2_A0(ctrlModel, ctrlRev)) {
+			mvOsUDelay(10);
+			MV_REG_BIT_RESET(MCSC_GLOBAL_CONFIG_REG, MCSC_GLOBAL_CONFIG_MAI_MASK);
 		}
 
-		MV_REG_BIT_RESET(MCSC_CHx_RECEIVE_CONFIG_REG(chan), MRCRx_ABORT_MASK);
-	}
+		/* Disable TDM */
+		MV_REG_BIT_RESET(FLEX_TDM_CONFIG_REG, TDM_TEN_MASK);
 
-	/* MCDMA Tx Abort */
-	for (chan = 0; chan < totalChannels; chan++)
-		MV_REG_BIT_SET(MCDMA_TRANSMIT_CONTROL_REG(chan), MCDMA_AT_MASK);
+		/* Disable PCLK */
+		MV_REG_BIT_RESET(TDM_DATA_DELAY_AND_CLK_CTRL_REG, (TX_CLK_OUT_ENABLE_MASK | RX_CLK_OUT_ENABLE_MASK));
 
-	for (chan = 0; chan < totalChannels; chan++) {
-		maxPoll = 0;
-		while ((maxPoll < MAX_POLL_USEC) && (MV_REG_READ(MCDMA_RECEIVE_CONTROL_REG(chan)) & MCDMA_ERD_MASK)) {
-			mvOsUDelay(1);
-			maxPoll++;
-		}
+		/* Reset CommUnit blocks to default settings */
+		MV_REG_BIT_RESET(0x18220, COMM_UNIT_SW_RST);
+		mvOsUDelay(1);
+		MV_REG_BIT_SET(0x18220, COMM_UNIT_SW_RST);
+		mvOsDelay(10);
 
-		if (maxPoll >= MAX_POLL_USEC) {
-			mvOsPrintf("%s: Error, MCDMA Rx abort timeout(ch%d)\n", __func__, chan);
-			return;
-		}
+		/* Calculate total Rx/Tx buffer size */
+		buffSize = (sampleSize * MV_TDM_TOTAL_CH_SAMPLES * samplingCoeff * totalChannels)
+				+ CPU_D_CACHE_LINE_SIZE;
 
-		maxPoll = 0;
-		while ((maxPoll < MAX_POLL_USEC) && (MV_REG_READ(MCDMA_TRANSMIT_CONTROL_REG(chan)) & MCDMA_AT_MASK)) {
-			mvOsUDelay(1);
-			maxPoll++;
-		}
+		/* Calculate total MCDMA Rx/Tx descriptors chain size */
+		totalRxDescSize = totalChannels * sizeof(MV_TDM_MCDMA_RX_DESC);
+		totalTxDescSize = totalChannels * sizeof(MV_TDM_MCDMA_TX_DESC);
 
-		if (maxPoll >= MAX_POLL_USEC) {
-			mvOsPrintf("%s: Error, MCDMA Tx abort timeout(ch%d)\n", __func__, chan);
-			return;
+		for (index = 0; index < TOTAL_CHAINS; index++) {
+			/* Release Rx/Tx data buffers */
+			mvOsIoCachedFree(NULL, buffSize, rxBuffPhys[index], rxBuffVirt[index], 0);
+			mvOsIoCachedFree(NULL, buffSize, txBuffPhys[index], txBuffVirt[index], 0);
+
+			/* Release MCDMA Rx/Tx descriptors */
+			mvOsIoUncachedFree(NULL, totalRxDescSize, mcdmaRxDescPhys[index], mcdmaRxDescPtr[index], 0);
+			mvOsIoUncachedFree(NULL, totalTxDescSize, mcdmaTxDescPhys[index], mcdmaTxDescPtr[index], 0);
 		}
 	}
 
-	/* Clear MCSC Rx/Tx channel enable */
+	MV_TRC_REC("<-%s\n", __func__);
+}
+
+static MV_VOID mvCommUnitMcdmaMcscStart(MV_VOID)
+{
+	MV_U32 chan, rxDescPhysAddr, txDescPhysAddr;
+
+	MV_TRC_REC("->%s\n", __func__);
+
+	mvCommUnitDescChainBuild();
+
+	/* Set current Rx/Tx descriptors  */
 	for (chan = 0; chan < totalChannels; chan++) {
-		MV_REG_BIT_RESET(MCSC_CHx_RECEIVE_CONFIG_REG(chan), MRCRx_ER_MASK);
-		MV_REG_BIT_RESET(MCSC_CHx_TRANSMIT_CONFIG_REG(chan), MTCRx_ET_MASK);
-		/*MV_REG_BIT_RESET(MCDMA_RECEIVE_CONTROL_REG(chan), MCDMA_ERD_MASK);
-		MV_REG_BIT_RESET(MCDMA_TRANSMIT_CONTROL_REG(chan), MCDMA_TXD_MASK);*/
+		rxDescPhysAddr = mcdmaRxDescPhys[0] + (chan * sizeof(MV_TDM_MCDMA_RX_DESC));
+		txDescPhysAddr = mcdmaTxDescPhys[0] + (chan * sizeof(MV_TDM_MCDMA_TX_DESC));
+		MV_REG_WRITE(MCDMA_CURRENT_RECEIVE_DESC_PTR_REG(chan), rxDescPhysAddr);
+		MV_REG_WRITE(MCDMA_CURRENT_TRANSMIT_DESC_PTR_REG(chan), txDescPhysAddr);
 	}
 
-	/* MCSC Global Rx/Tx Disable */
-	MV_REG_BIT_RESET(MCSC_GLOBAL_CONFIG_REG, MCSC_GLOBAL_CONFIG_RXEN_MASK);
-	MV_REG_BIT_RESET(MCSC_GLOBAL_CONFIG_REG, MCSC_GLOBAL_CONFIG_TXEN_MASK);
+	/* Restore MCDMA Rx/Tx control registers */
+	for (chan = 0; chan < totalChannels; chan++) {
+		/* Set RMCCx */
+		MV_REG_WRITE(MCDMA_RECEIVE_CONTROL_REG(chan), CONFIG_RMCCx);
 
-	/* Disable TDM */
-	MV_REG_BIT_RESET(FLEX_TDM_CONFIG_REG, TDM_TEN_MASK);
+		/* Set TMCCx */
+		MV_REG_WRITE(MCDMA_TRANSMIT_CONTROL_REG(chan), CONFIG_TMCCx);
+	}
 
-	/* Calculate total Rx/Tx buffer size */
-	buffSize = (sampleSize * MV_TDM_TOTAL_CH_SAMPLES * samplingCoeff * totalChannels)
-	    + CPU_D_CACHE_LINE_SIZE;
+	/* Set Rx/Tx periodical interrupts */
+	MV_REG_WRITE(VOICE_PERIODICAL_INT_CONTROL_REG, CONFIG_VOICE_PERIODICAL_INT_CONTROL);
 
-	/* Calculate total MCDMA Rx/Tx descriptors chain size */
-	totalRxDescSize = totalChannels * sizeof(MV_TDM_MCDMA_RX_DESC);
-	totalTxDescSize = totalChannels * sizeof(MV_TDM_MCDMA_TX_DESC);
+	/* MCSC Global Tx Enable */
+	if (tdmEnable == MV_FALSE)
+		MV_REG_BIT_SET(MCSC_GLOBAL_CONFIG_REG, MCSC_GLOBAL_CONFIG_TXEN_MASK);
 
-	for (index = 0; index < TOTAL_CHAINS; index++) {
-		/* Release Rx/Tx data buffers */
-		mvOsIoCachedFree(NULL, buffSize, rxBuffPhys[index], rxBuffVirt[index], 0);
-		mvOsIoCachedFree(NULL, buffSize, txBuffPhys[index], txBuffVirt[index], 0);
+	/* Enable MCSC-Tx & MCDMA-Rx */
+	for (chan = 0; chan < totalChannels; chan++) {
+		/* Enable Tx in TMCCx */
+		if (tdmEnable == MV_FALSE)
+			MV_REG_BIT_SET(MCSC_CHx_TRANSMIT_CONFIG_REG(chan), MTCRx_ET_MASK);
 
-		/* Release MCDMA Rx/Tx descriptors */
-		mvOsIoUncachedFree(NULL, totalRxDescSize, mcdmaRxDescPhys[index], mcdmaRxDescPtr[index], 0);
-		mvOsIoUncachedFree(NULL, totalTxDescSize, mcdmaTxDescPhys[index], mcdmaTxDescPtr[index], 0);
+		/* Enable Rx in: MCRDPx */
+		MV_REG_BIT_SET(MCDMA_RECEIVE_CONTROL_REG(chan), MCDMA_ERD_MASK);
 	}
 
-#ifdef MV_COMM_UNIT_DEBUG
-	/*mvOsIoUncachedFree(NULL, 516, iqcPhys, iqcVirt, 0); */
-#endif
+	/* MCSC Global Rx Enable */
+	if (tdmEnable == MV_FALSE)
+		MV_REG_BIT_SET(MCSC_GLOBAL_CONFIG_REG, MCSC_GLOBAL_CONFIG_RXEN_MASK);
+
+	/* Enable MCSC-Rx & MCDMA-Tx */
+	for (chan = 0; chan < totalChannels; chan++) {
+		/* Enable Rx in RMCCx */
+		if (tdmEnable == MV_FALSE)
+			MV_REG_BIT_SET(MCSC_CHx_RECEIVE_CONFIG_REG(chan), MRCRx_ER_MASK);
+
+		/* Enable Tx in MCTDPx */
+		MV_REG_BIT_SET(MCDMA_TRANSMIT_CONTROL_REG(chan), MCDMA_TXD_MASK);
+	}
+
+	/* Disable Rx/Tx return to half */
+	MV_REG_BIT_RESET(FLEX_TDM_CONFIG_REG, (TDM_RR2HALF_MASK | TDM_TR2HALF_MASK));
+	/* Wait at least 1 frame */
+	mvOsUDelay(200);
 
 	MV_TRC_REC("<-%s\n", __func__);
 }
@@ -558,9 +566,12 @@ MV_VOID mvCommUnitPcmStart(MV_VOID)
 	MV_TRC_REC("->%s\n", __func__);
 
 	if (pcmEnable == MV_FALSE) {
+
 		/* Mark PCM I/F as enabled  */
 		pcmEnable = MV_TRUE;
 
+		mvCommUnitMcdmaMcscStart();
+
 		/* Clear TDM cause and mask registers */
 		MV_REG_WRITE(COMM_UNIT_TOP_MASK_REG, 0);
 		MV_REG_WRITE(TDM_MASK_REG, 0);
@@ -582,9 +593,172 @@ MV_VOID mvCommUnitPcmStart(MV_VOID)
 	MV_TRC_REC("<-%s\n", __func__);
 }
 
+static MV_VOID mvCommUnitMcdmaMcscAbort(MV_VOID)
+{
+	MV_U32 chan, maxPoll;
+
+	MV_TRC_REC("->%s\n", __func__);
+
+	/* Abort MCSC/MCDMA in case we got here from mvCommUnitRelease() */
+	if (tdmEnable == MV_FALSE) {
+
+#if 0
+		/* MCSC Rx Abort */
+		for (chan = 0; chan < totalChannels; chan++)
+			MV_REG_BIT_SET(MCSC_CHx_RECEIVE_CONFIG_REG(chan), MRCRx_ABORT_MASK);
+
+		for (chan = 0; chan < totalChannels; chan++) {
+			maxPoll = 0;
+			while ((maxPoll < MAX_POLL_USEC) &&
+				!(MV_REG_READ(MCSC_CHx_COMM_EXEC_STAT_REG(chan)) & MCSC_ABR_E_STAT_MASK)) {
+				mvOsUDelay(1);
+				maxPoll++;
+			}
+
+			if (maxPoll >= MAX_POLL_USEC) {
+				mvOsPrintf("%s: Error, MCSC Rx abort timeout(ch%d)\n", __func__, chan);
+				return;
+			}
+
+			MV_REG_BIT_RESET(MCSC_CHx_RECEIVE_CONFIG_REG(chan), MRCRx_ABORT_MASK);
+		}
+
+		/* MCDMA Tx Abort */
+		for (chan = 0; chan < totalChannels; chan++)
+			MV_REG_BIT_SET(MCDMA_TRANSMIT_CONTROL_REG(chan), MCDMA_AT_MASK);
+
+		for (chan = 0; chan < totalChannels; chan++) {
+			maxPoll = 0;
+			while ((maxPoll < MAX_POLL_USEC) &&
+				(MV_REG_READ(MCDMA_RECEIVE_CONTROL_REG(chan)) & MCDMA_ERD_MASK)) {
+				mvOsUDelay(1);
+				maxPoll++;
+			}
+
+			if (maxPoll >= MAX_POLL_USEC) {
+				mvOsPrintf("%s: Error, MCDMA Rx abort timeout(ch%d)\n", __func__, chan);
+				return;
+			}
+
+			maxPoll = 0;
+			while ((maxPoll < MAX_POLL_USEC) &&
+				(MV_REG_READ(MCDMA_TRANSMIT_CONTROL_REG(chan)) & MCDMA_AT_MASK)) {
+				mvOsUDelay(1);
+				maxPoll++;
+			}
+
+			if (maxPoll >= MAX_POLL_USEC) {
+				mvOsPrintf("%s: Error, MCDMA Tx abort timeout(ch%d)\n", __func__, chan);
+				return;
+			}
+		}
+#endif
+		/* Clear MCSC Rx/Tx channel enable */
+		for (chan = 0; chan < totalChannels; chan++) {
+			MV_REG_BIT_RESET(MCSC_CHx_RECEIVE_CONFIG_REG(chan), MRCRx_ER_MASK);
+			MV_REG_BIT_RESET(MCSC_CHx_TRANSMIT_CONFIG_REG(chan), MTCRx_ET_MASK);
+		}
+
+		/* MCSC Global Rx/Tx Disable */
+		MV_REG_BIT_RESET(MCSC_GLOBAL_CONFIG_REG, MCSC_GLOBAL_CONFIG_RXEN_MASK);
+		MV_REG_BIT_RESET(MCSC_GLOBAL_CONFIG_REG, MCSC_GLOBAL_CONFIG_TXEN_MASK);
+	}
+
+	MV_TRC_REC("<-%s\n", __func__);
+}
+
+static MV_VOID mvCommUnitMcdmaStop(MV_VOID)
+{
+	MV_U32 index, chan, maxPoll, currTxDesc;
+	MV_U32 currRxDesc, nextTxBuff = 0, nextRxBuff = 0;
+
+	MV_TRC_REC("->%s\n", __func__);
+
+	/***************************/
+	/*    Stop MCDMA - Rx/Tx   */
+	/***************************/
+	for (chan = 0; chan < totalChannels; chan++) {
+		currRxDesc = MV_REG_READ(MCDMA_CURRENT_RECEIVE_DESC_PTR_REG(chan));
+		for (index = 0; index < TOTAL_CHAINS; index++) {
+			if (currRxDesc == (mcdmaRxDescPhys[index] + (chan*(sizeof(MV_TDM_MCDMA_RX_DESC))))) {
+				nextRxBuff = NEXT_BUFF(index);
+				break;
+			}
+		}
+
+		if (index == TOTAL_CHAINS) {
+			mvOsPrintf("%s: ERROR, couldn't Rx descriptor match for chan(%d)\n", __func__, chan);
+			break;
+		}
+
+		((MV_TDM_MCDMA_RX_DESC *) (mcdmaRxDescPtr[nextRxBuff] + chan))->physNextDescPtr = 0;
+		((MV_TDM_MCDMA_RX_DESC *) (mcdmaRxDescPtr[nextRxBuff] + chan))->cmdStatus = (LAST_BIT | OWNER);
+	}
+
+	for (chan = 0; chan < totalChannels; chan++) {
+		currTxDesc = MV_REG_READ(MCDMA_CURRENT_TRANSMIT_DESC_PTR_REG(chan));
+		for (index = 0; index < TOTAL_CHAINS; index++) {
+			if (currTxDesc == (mcdmaTxDescPhys[index] + (chan*(sizeof(MV_TDM_MCDMA_TX_DESC))))) {
+				nextTxBuff = NEXT_BUFF(index);
+				break;
+			}
+		}
+
+		if (index == TOTAL_CHAINS) {
+			mvOsPrintf("%s: ERROR, couldn't Tx descriptor match for chan(%d)\n", __func__, chan);
+			return;
+		}
+
+		((MV_TDM_MCDMA_TX_DESC *) (mcdmaTxDescPtr[nextTxBuff] + chan))->physNextDescPtr = 0;
+		((MV_TDM_MCDMA_TX_DESC *) (mcdmaTxDescPtr[nextTxBuff] + chan))->cmdStatus = (LAST_BIT | OWNER);
+	}
+
+	for (chan = 0; chan < totalChannels; chan++) {
+		maxPoll = 0;
+		while ((maxPoll < MAX_POLL_USEC) &&
+			(MV_REG_READ(MCDMA_TRANSMIT_CONTROL_REG(chan)) & MCDMA_TXD_MASK)) {
+			mvOsUDelay(1);
+			maxPoll++;
+		}
+
+		if (maxPoll >= MAX_POLL_USEC) {
+			mvOsPrintf("%s: Error, MCDMA TXD polling timeout(ch%d)\n", __func__, chan);
+			return;
+		}
+
+		maxPoll = 0;
+		while ((maxPoll < MAX_POLL_USEC) &&
+			(MV_REG_READ(MCDMA_RECEIVE_CONTROL_REG(chan)) & MCDMA_ERD_MASK)) {
+			mvOsUDelay(1);
+			maxPoll++;
+		}
+
+		if (maxPoll >= MAX_POLL_USEC) {
+			mvOsPrintf("%s: Error, MCDMA ERD polling timeout(ch%d)\n", __func__, chan);
+			return;
+		}
+	}
+
+	/* Disable Rx/Tx periodical interrupts */
+	MV_REG_WRITE(VOICE_PERIODICAL_INT_CONTROL_REG, 0xffffffff);
+
+	/* Enable Rx/Tx return to half */
+	MV_REG_BIT_SET(FLEX_TDM_CONFIG_REG, (TDM_RR2HALF_MASK | TDM_TR2HALF_MASK));
+	/* Wait at least 1 frame */
+	mvOsUDelay(200);
+
+	if (IS_KW2_A0(ctrlModel, ctrlRev)) {
+		/* Manual reset to channel-balancing mechanism */
+		MV_REG_BIT_SET(MCSC_GLOBAL_CONFIG_REG, MCSC_GLOBAL_CONFIG_MAI_MASK);
+		mvOsUDelay(1);
+	}
+
+	MV_TRC_REC("<-%s\n", __func__);
+}
+
 MV_VOID mvCommUnitPcmStop(MV_VOID)
 {
-	MV_U32 index, buffSize;
+	MV_U32 buffSize, index;
 
 	MV_TRC_REC("->%s\n", __func__);
 
@@ -592,10 +766,6 @@ MV_VOID mvCommUnitPcmStop(MV_VOID)
 		/* Mark PCM I/F as disabled  */
 		pcmEnable = MV_FALSE;
 
-		/* Calculate total Rx/Tx buffer size */
-		buffSize = (sampleSize * MV_TDM_TOTAL_CH_SAMPLES * samplingCoeff * totalChannels);
-
-		/* CommUnit still active, only mask interrupts */
 		/* Clear TDM cause and mask registers */
 		MV_REG_WRITE(COMM_UNIT_TOP_MASK_REG, 0);
 		MV_REG_WRITE(TDM_MASK_REG, 0);
@@ -608,19 +778,19 @@ MV_VOID mvCommUnitPcmStop(MV_VOID)
 		MV_REG_WRITE(MCSC_GLOBAL_INT_CAUSE_REG, MCSC_GLOBAL_INT_CAUSE_INIT_DONE_MASK);
 		MV_REG_WRITE(MCSC_EXTENDED_INT_CAUSE_REG, 0);
 
-#if 0
-		/* Clear Rx/Tx buffers */
+		mvCommUnitMcdmaStop();
+
+		/* Calculate total Rx/Tx buffer size */
+		buffSize = (sampleSize * MV_TDM_TOTAL_CH_SAMPLES * samplingCoeff * totalChannels);
+
+		/* Clear Rx buffers */
 		for (index = 0; index < TOTAL_CHAINS; index++) {
 			memset(rxBuffVirt[index], 0, buffSize);
-			memset(txBuffVirt[index], 0, buffSize);
 
 			/* Flush+Inv buffers */
-			mvOsCacheFlushInv(NULL, rxBuffVirt[index], buffSize);
 			mvOsCacheFlushInv(NULL, txBuffVirt[index], buffSize);
 		}
-#endif
-		/* Enable SLIC/s interrupt detection */
-		/*MV_REG_WRITE(TDM_MASK_REG, TDM_SLIC_INT); */
+
 	}
 
 	MV_TRC_REC("<-%s\n", __func__);
@@ -628,15 +798,27 @@ MV_VOID mvCommUnitPcmStop(MV_VOID)
 
 MV_STATUS mvCommUnitTx(MV_U8 *pTdmTxBuff)
 {
-	MV_U32 buffSize;
+	MV_U32 buffSize, index;
+	MV_U8 tmp;
 
 	MV_TRC_REC("->%s\n", __func__);
 
 	/* Calculate total Tx buffer size */
 	buffSize = (sampleSize * MV_TDM_TOTAL_CH_SAMPLES * samplingCoeff * totalChannels);
 
+	if (sampleSize > MV_PCM_FORMAT_1BYTE) {
+		TRC_REC("Linear mode(Tx): swapping bytes\n");
+			for (index = 0; index < buffSize; index += 2) {
+				tmp = pTdmTxBuff[index];
+				pTdmTxBuff[index] = pTdmTxBuff[index+1];
+				pTdmTxBuff[index+1] = tmp;
+			}
+		TRC_REC("Linear mode(Tx): swapping bytes...done.\n");
+	}
+
 	/* Flush+Invalidate the next Tx buffer */
-	mvOsCacheFlushInv(NULL, pTdmTxBuff, buffSize);
+	mvOsCacheFlush(NULL, pTdmTxBuff, buffSize);
+	mvOsCacheInvalidate(NULL, pTdmTxBuff, buffSize);
 
 	MV_TRC_REC("<-%s\n", __func__);
 	return MV_OK;
@@ -644,7 +826,8 @@ MV_STATUS mvCommUnitTx(MV_U8 *pTdmTxBuff)
 
 MV_STATUS mvCommUnitRx(MV_U8 *pTdmRxBuff)
 {
-	MV_U32 buffSize;
+	MV_U32 buffSize, index;
+	MV_U8 tmp;
 
 	MV_TRC_REC("->%s\n", __func__);
 
@@ -654,6 +837,16 @@ MV_STATUS mvCommUnitRx(MV_U8 *pTdmRxBuff)
 	/* Invalidate current received buffer from cache */
 	mvOsCacheInvalidate(NULL, pTdmRxBuff, buffSize);
 
+	if (sampleSize > MV_PCM_FORMAT_1BYTE) {
+		TRC_REC("  -> Linear mode(Rx): swapping bytes\n");
+			for (index = 0; index < buffSize; index += 2) {
+				tmp = pTdmRxBuff[index];
+				pTdmRxBuff[index] = pTdmRxBuff[index+1];
+				pTdmRxBuff[index+1] = tmp;
+			}
+		TRC_REC("  <- Linear mode(Rx): swapping bytes...done.\n");
+	}
+
 	MV_TRC_REC("<-%s\n", __func__);
 	return MV_OK;
 }
@@ -662,8 +855,8 @@ MV_STATUS mvCommUnitRx(MV_U8 *pTdmRxBuff)
 MV_VOID mvCommUnitIntLow(MV_TDM_INT_INFO *pTdmIntInfo)
 {
 	MV_U32 causeReg, maskReg, causeAndMask;
-	MV_U32 slicInt = 0, intAckBits = 0, currRxDesc, currTxDesc;
-	MV_U8 cs, index;
+	MV_U32 intAckBits = 0, currDesc;
+	MV_U8 index;
 
 	MV_TRC_REC("->%s\n", __func__);
 
@@ -709,42 +902,42 @@ MV_VOID mvCommUnitIntLow(MV_TDM_INT_INFO *pTdmIntInfo)
 	/* Handle TDM Error/s */
 	if (causeAndMask & TDM_ERROR_INT) {
 		mvOsPrintf("TDM Error: TDM_CAUSE_REG = 0x%x\n", causeReg);
-		pTdmIntInfo->intType |= MV_ERROR_INT;
+		/*pTdmIntInfo->intType |= MV_ERROR_INT;*/
 		intAckBits |= (causeAndMask & TDM_ERROR_INT);
 	}
 
-	/* Handle Tx */
-	if (causeAndMask & TDM_TX_INT) {
-		currTxDesc = MV_REG_READ(MCDMA_CURRENT_TRANSMIT_DESC_PTR_REG(0));
-		MV_TRC_REC("currTxDesc = 0x%x\n", currTxDesc);
-		for (index = 0; index < TOTAL_CHAINS; index++) {
-			if (currTxDesc == mcdmaTxDescPhys[index]) {
-				nextTxBuff = NEXT_BUFF(index);
-				break;
+	if (causeAndMask & (TDM_TX_INT | TDM_RX_INT)) {
+		/* MCDMA current Tx desc. pointer is unreliable, thus, checking Rx desc. pointer only */
+		currDesc = MV_REG_READ(MCDMA_CURRENT_RECEIVE_DESC_PTR_REG(0));
+		MV_TRC_REC("currDesc = 0x%x\n", currDesc);
+
+		/* Handle Tx */
+		if (causeAndMask & TDM_TX_INT) {
+			for (index = 0; index < TOTAL_CHAINS; index++) {
+				if (currDesc == mcdmaRxDescPhys[index]) {
+					nextTxBuff = NEXT_BUFF(index);
+					break;
+				}
 			}
+			MV_TRC_REC("Tx interrupt(nextTxBuff=%d)!!!\n", nextTxBuff);
+			pTdmIntInfo->tdmTxBuff = txBuffVirt[nextTxBuff];
+			pTdmIntInfo->intType |= MV_TX_INT;
+			intAckBits |= TDM_TX_INT;
 		}
-		MV_TRC_REC("Tx interrupt(nextTxBuff=%d)!!!\n", nextTxBuff);
-		pTdmIntInfo->tdmTxBuff = txBuffVirt[nextTxBuff];
-		pTdmIntInfo->intType |= MV_TX_INT;
-		intAckBits |= TDM_TX_INT;
-	}
-
-	/* Handle Rx */
-	if (causeAndMask & TDM_RX_INT) {
-		currRxDesc = MV_REG_READ(MCDMA_CURRENT_RECEIVE_DESC_PTR_REG(0));
-		MV_TRC_REC("currRxDesc = 0x%x\n", currRxDesc);
 
-		for (index = 0; index < TOTAL_CHAINS; index++) {
-			if (currRxDesc == mcdmaRxDescPhys[index]) {
-				prevRxBuff = PREV_BUFF(index);
-				break;
+		/* Handle Rx */
+		if (causeAndMask & TDM_RX_INT) {
+			for (index = 0; index < TOTAL_CHAINS; index++) {
+				if (currDesc == mcdmaRxDescPhys[index]) {
+					prevRxBuff = PREV_BUFF(index);
+					break;
+				}
 			}
+			MV_TRC_REC("Rx interrupt(prevRxBuff=%d)!!!\n", prevRxBuff);
+			pTdmIntInfo->tdmRxBuff = rxBuffVirt[prevRxBuff];
+			pTdmIntInfo->intType |= MV_RX_INT;
+			intAckBits |= TDM_RX_INT;
 		}
-
-		MV_TRC_REC("Rx interrupt(prevRxBuff=%d)!!!\n", prevRxBuff);
-		pTdmIntInfo->tdmRxBuff = rxBuffVirt[prevRxBuff];
-		pTdmIntInfo->intType |= MV_RX_INT;
-		intAckBits |= TDM_RX_INT;
 	}
 
 	/* Clear TDM interrupts */
@@ -754,14 +947,61 @@ MV_VOID mvCommUnitIntLow(MV_TDM_INT_INFO *pTdmIntInfo)
 	return;
 }
 
+static MV_VOID mvCommUnitDescChainBuild(MV_VOID)
+{
+	MV_U32 chan, index, buffSize;
+
+	TRC_REC("->%s\n", __func__);
+
+	/* Calculate single Rx/Tx buffer size */
+	buffSize = (sampleSize * MV_TDM_TOTAL_CH_SAMPLES * samplingCoeff);
+
+	/* Initialize descriptors fields */
+	for (chan = 0; chan < totalChannels; chan++) {
+		for (index = 0; index < TOTAL_CHAINS; index++) {
+			/* Associate data buffers to descriptors physBuffPtr */
+			((MV_TDM_MCDMA_RX_DESC *) (mcdmaRxDescPtr[index] + chan))->physBuffPtr =
+			    (MV_U32) (rxBuffPhys[index] + (chan * buffSize));
+			((MV_TDM_MCDMA_TX_DESC *) (mcdmaTxDescPtr[index] + chan))->physBuffPtr =
+			    (MV_U32) (txBuffPhys[index] + (chan * buffSize));
+
+			/* Build cyclic descriptors chain for each channel */
+			((MV_TDM_MCDMA_RX_DESC *) (mcdmaRxDescPtr[index] + chan))->physNextDescPtr =
+			    (MV_U32) (mcdmaRxDescPhys[((index + 1) % TOTAL_CHAINS)] +
+				      (chan * sizeof(MV_TDM_MCDMA_RX_DESC)));
+
+			((MV_TDM_MCDMA_TX_DESC *) (mcdmaTxDescPtr[index] + chan))->physNextDescPtr =
+			    (MV_U32) (mcdmaTxDescPhys[((index + 1) % TOTAL_CHAINS)] +
+				      (chan * sizeof(MV_TDM_MCDMA_TX_DESC)));
+
+			/* Set Byte_Count/Buffer_Size Rx descriptor fields */
+			((MV_TDM_MCDMA_RX_DESC *) (mcdmaRxDescPtr[index] + chan))->byteCnt = 0;
+			((MV_TDM_MCDMA_RX_DESC *) (mcdmaRxDescPtr[index] + chan))->buffSize = buffSize;
+
+			/* Set Shadow_Byte_Count/Byte_Count Tx descriptor fields */
+			((MV_TDM_MCDMA_TX_DESC *) (mcdmaTxDescPtr[index] + chan))->shadowByteCnt = buffSize;
+			((MV_TDM_MCDMA_TX_DESC *) (mcdmaTxDescPtr[index] + chan))->byteCnt = buffSize;
+
+			/* Set Command/Status Rx/Tx descriptor fields */
+			((MV_TDM_MCDMA_RX_DESC *) (mcdmaRxDescPtr[index] + chan))->cmdStatus =
+			    (CONFIG_MCDMA_DESC_CMD_STATUS);
+			((MV_TDM_MCDMA_TX_DESC *) (mcdmaTxDescPtr[index] + chan))->cmdStatus =
+			    (CONFIG_MCDMA_DESC_CMD_STATUS);
+		}
+	}
+
+	TRC_REC("<-%s\n", __func__);
+	return;
+}
+
 MV_VOID mvCommUnitIntEnable(MV_U8 deviceId)
 {
-	MV_REG_BIT_SET(MV_GPP_IRQ_MASK_REG(0), BIT23);
+	/* MV_REG_BIT_SET(MV_GPP_IRQ_MASK_REG(0), BIT23); */
 }
 
 MV_VOID mvCommUnitIntDisable(MV_U8 deviceId)
 {
-	MV_REG_BIT_RESET(MV_GPP_IRQ_MASK_REG(0), BIT23);
+	/* MV_REG_BIT_RESET(MV_GPP_IRQ_MASK_REG(0), BIT23); */
 }
 
 MV_VOID mvCommUnitShow(MV_VOID)
@@ -774,12 +1014,9 @@ MV_VOID mvCommUnitShow(MV_VOID)
 			   (MV_U32) rxBuffPhys[index]);
 		mvOsPrintf("Tx Buff(%d): virt = 0x%x, phys = 0x%x\n", index, (MV_U32) txBuffVirt[index],
 			   (MV_U32) txBuffPhys[index]);
-
 		mvOsPrintf("Rx Desc(%d): virt = 0x%x, phys = 0x%x\n", index,
 			   (MV_U32) mcdmaRxDescPtr[index], (MV_U32) mcdmaRxDescPhys[index]);
-
 		mvOsPrintf("Tx Desc(%d): virt = 0x%x, phys = 0x%x\n", index,
 			   (MV_U32) mcdmaTxDescPtr[index], (MV_U32) mcdmaTxDescPhys[index]);
-
 	}
 }
diff --git a/arch/arm/plat-armada/mv_hal/voiceband/commUnit/mvCommUnit.h b/arch/arm/plat-armada/mv_hal/voiceband/commUnit/mvCommUnit.h
index 4342b23..620e458 100644
--- a/arch/arm/plat-armada/mv_hal/voiceband/commUnit/mvCommUnit.h
+++ b/arch/arm/plat-armada/mv_hal/voiceband/commUnit/mvCommUnit.h
@@ -75,7 +75,7 @@ extern "C" {
 
 /* Defines */
 #define MV_TDM_TOTAL_CHANNELS		32
-#define MV_TDM_MAX_DPRAM_ENTRIES	128	/* ignore 128 top entries */
+#define MV_TDM_MAX_HALF_DPRAM_ENTRIES	128
 #define MV_TDM_MAX_SAMPLING_PERIOD	30	/* ms */
 #define MV_TDM_BASE_SAMPLING_PERIOD	10	/* ms */
 #define MV_TDM_TOTAL_CH_SAMPLES		80	/* samples */
@@ -85,7 +85,10 @@ extern "C" {
 #define MV_RX_INT 			BIT0
 #define	MV_TX_INT 			BIT1
 #define	MV_PHONE_INT 			BIT2
-#define	MV_ERROR_INT 			BIT3
+#define	MV_RX_ERROR_INT 		BIT3
+#define	MV_TX_ERROR_INT 		BIT4
+#define MV_DMA_ERROR_INT		BIT5
+#define MV_ERROR_INT			(MV_RX_ERROR_INT | MV_TX_ERROR_INT | MV_DMA_ERROR_INT)
 
 #define TDM_SLIC_INT		(EXT_INT_SLIC0_MASK | EXT_INT_SLIC1_MASK | EXT_INT_SLIC2_MASK | EXT_INT_SLIC3_MASK)
 #define TDM_TX_INT		 TX_VOICE_INT_PULSE_MASK
@@ -116,15 +119,18 @@ extern "C" {
 #define CONFIG_TDM_CLK_AND_SYNC_CONTROL	(TDM_TX_CLK_OUT_ENABLE_MASK | TDM_RX_CLK_OUT_ENABLE_MASK | \
 					 TDM_REFCLK_DIVIDER_BYPASS_MASK)
 #else
-#define CONFIG_TDM_CLK_AND_SYNC_CONTROL	(TDM_REFCLK_DIVIDER_BYPASS_MASK)
+#define CONFIG_TDM_CLK_AND_SYNC_CONTROL	(TDM_REFCLK_DIVIDER_BYPASS_MASK | TDM_OUT_CLK_SRC_CTRL_AFTER_DIV)
 #endif				/* MV_TDM_USE_EXTERNAL_PCLK_SOURCE */
 
 #define CONFIG_VOICE_PERIODICAL_INT_CONTROL (((MV_TDM_TOTAL_CH_SAMPLES-1) << RX_VOICE_INT_CNT_REF_OFFS) | \
 					     ((MV_TDM_TOTAL_CH_SAMPLES-1) << TX_VOICE_INT_CNT_REF_OFFS) | \
-					     (1 << RX_FIRST_DELAY_REF_OFFS) | (2 << TX_FIRST_DELAY_REF_OFFS))
+					     (1 << RX_FIRST_DELAY_REF_OFFS) | (4 << TX_FIRST_DELAY_REF_OFFS))
 #define CONFIG_TDM_CAUSE    		    (TDM_RX_INT | TDM_TX_INT /*| TDM_ERROR_INT*/)
 #define CONFIG_COMM_UNIT_TOP_MASK	    (TDM_SUM_INT_MASK | MCSC_SUM_INT_MASK)
 #define CONFIG_FLEX_TDM_CONFIG		    (TDM_SE_MASK | TDM_COMMON_RX_TX_MASK | TSD_NO_DELAY | RSD_NO_DELAY)
+#define	CONFIG_TDM_DATA_DELAY_AND_CLK_CTRL		(TX_CLK_OUT_ENABLE_MASK | RX_CLK_OUT_ENABLE_MASK)
+#define CONFIG_TDM_PLUS_MINUS_DELAY_CTRL_FSYNC_OUT	(TX_SYNC_DELAY_OUT_MINUS | RX_SYNC_DELAY_OUT_MINUS)
+#define CONFIG_TDM_PLUS_MINUS_DELAY_CTRL_FSYNC_IN	(TX_SYNC_DELAY_IN_MINUS | RX_SYNC_DELAY_IN_MINUS)
 
 /* Structures */
 	typedef struct {
@@ -145,6 +151,8 @@ extern "C" {
 		MV_U8 spiMode;
 		MV_U8 maxCs;
 		MV_U16 model;
+		MV_U16 ctrlRev;
+		MV_FRAME_TS frameTs;
 	} MV_TDM_HAL_DATA;
 
 	typedef struct {
diff --git a/arch/arm/plat-armada/mv_hal/voiceband/commUnit/mvCommUnitRegs.h b/arch/arm/plat-armada/mv_hal/voiceband/commUnit/mvCommUnitRegs.h
index 49ebb03..73acd58 100644
--- a/arch/arm/plat-armada/mv_hal/voiceband/commUnit/mvCommUnitRegs.h
+++ b/arch/arm/plat-armada/mv_hal/voiceband/commUnit/mvCommUnitRegs.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -143,6 +143,8 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define MCSC_EXTENDED_INT_CAUSE_REG		(MV_COMM_UNIT_REGS_BASE + 0x2808)
 #define MCSC_GLOBAL_INT_MASK_REG		(MV_COMM_UNIT_REGS_BASE + 0x280C)
 #define MCSC_EXTENDED_INT_MASK_REG		(MV_COMM_UNIT_REGS_BASE + 0x2810)
+#define MCSC_TX_CHANNEL_BALANCING_MASK_REG	(MV_COMM_UNIT_REGS_BASE + 0x284C)
+#define MCSC_RX_CHANNEL_BALANCING_MASK_REG	(MV_COMM_UNIT_REGS_BASE + 0x2850)
 
 /* MCSC_CHx_COMM_EXEC_STAT_REG bits */
 #define MCSC_ABR_E_STAT_OFFS			25
@@ -171,6 +173,14 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define MTCRx_MODE_MASK				(1 << MTCRx_MODE_OFFS)
 
 /* MCSC_GLOBAL_CONFIG_REG bits */
+#define MCSC_GLOBAL_CONFIG_RCBD_OFFS		19
+#define MCSC_GLOBAL_CONFIG_RCBD_MASK		(1 << MCSC_GLOBAL_CONFIG_RCBD_OFFS)
+#define MCSC_GLOBAL_CONFIG_TCBD_OFFS		20
+#define MCSC_GLOBAL_CONFIG_TCBD_MASK		(1 << MCSC_GLOBAL_CONFIG_TCBD_OFFS)
+#define MCSC_GLOBAL_CONFIG_MAI_OFFS		21
+#define MCSC_GLOBAL_CONFIG_MAI_MASK		(1 << MCSC_GLOBAL_CONFIG_MAI_OFFS)
+#define MCSC_GLOBAL_CONFIG_LMD_OFFS		22
+#define MCSC_GLOBAL_CONFIG_LMD_MASK		(1 << MCSC_GLOBAL_CONFIG_LMD_OFFS)
 #define MCSC_GLOBAL_CONFIG_ARBM_OFFS		29
 #define MCSC_GLOBAL_CONFIG_ARBM_MASK		(1 << MCSC_GLOBAL_CONFIG_ARBM_OFFS)
 #define MCSC_GLOBAL_CONFIG_RXEN_OFFS		30
@@ -242,6 +252,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define MCDMA_FSIZE_1BLK			0x1
 #define MCDMA_TBSZ_OFFS				8
 #define MCDMA_TBSZ_MASK				(0x3 << MCDMA_TBSZ_OFFS)
+#define MCDMA_TBSZ_8BYTE			(0x0 << MCDMA_TBSZ_OFFS)
 #define MCDMA_TBSZ_16BYTE			(0x1 << MCDMA_TBSZ_OFFS)
 #define MCDMA_TBSZ_32BYTE			(0x2 << MCDMA_TBSZ_OFFS)
 
@@ -271,6 +282,9 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define TDM_CLK_AND_SYNC_CONTROL_REG		(MV_COMM_UNIT_REGS_BASE + 0x881C)
 #define TDM_CLK_DIVIDER_CONTROL_REG		(MV_COMM_UNIT_REGS_BASE + 0x8820)
 #define TDM_RESV_CLK_DIVIDER_CONTROL_REG	(MV_COMM_UNIT_REGS_BASE + 0x8824)
+#define TDM_DATA_DELAY_AND_CLK_CTRL_REG		(MV_COMM_UNIT_REGS_BASE + 0x8CD0)
+#define TDM_PLUS_MINUS_DELAY_CTRL_FSYNC_OUT_REG	(MV_COMM_UNIT_REGS_BASE + 0x8CD4)
+#define TDM_PLUS_MINUS_DELAY_CTRL_FSYNC_IN_REG	(MV_COMM_UNIT_REGS_BASE + 0x8CD8)
 
 /* TDM_CLK_AND_SYNC_CONTROL_REG bits */
 #define TDM_TX_FSYNC_OUT_ENABLE_OFFS		0
@@ -291,8 +305,16 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define TDM_RX_REFCLK_DIVIDER_2MHZ		BIT15
 #define TDM_RX_REFCLK_DIVIDER_4MHZ		BIT16
 #define TDM_RX_REFCLK_DIVIDER_8MHZ		BIT17
+#define TDM_FSYNC_INVERT_OFFS			19
+#define TDM_FSYNC_INVERT_DISABLE		(0 << TDM_FSYNC_INVERT_OFFS)
+#define TDM_FSYNC_INVERT_ENABLE			(1 << TDM_FSYNC_INVERT_OFFS)
 #define TDM_REFCLK_DIVIDER_BYPASS_OFFS		20
 #define TDM_REFCLK_DIVIDER_BYPASS_MASK		(3 << TDM_REFCLK_DIVIDER_BYPASS_OFFS)
+#define TDM_OUT_CLK_SRC_CTRL_OFFS		24
+#define TDM_OUT_CLK_SRC_CTRL_BEFORE_DIV		(0 << TDM_OUT_CLK_SRC_CTRL_OFFS)
+#define TDM_OUT_CLK_SRC_CTRL_AFTER_DIV		(1 << TDM_OUT_CLK_SRC_CTRL_OFFS)
+#define TDM_PROG_TDM_SLIC_RESET_OFFS		31
+#define TDM_PROG_TDM_SLIC_RESET_MASK		(1 << TDM_PROG_TDM_SLIC_RESET_OFFS)
 
 /* TDM_RX_CLK_DIVIDER_CONTROL_REG bits */
 #define TDM_RX_FIXED_DIV_ENABLE_OFFS		31
@@ -303,6 +325,10 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define TDM_TX_FIXED_DIV_ENABLE_MASK		(1 << TDM_TX_FIXED_DIV_ENABLE_OFFS)
 
 /* FLEX_TDM_CONFIG_REG bits */
+#define TDM_RR2HALF_OFFS			15
+#define TDM_RR2HALF_MASK			(1 << TDM_RR2HALF_OFFS)
+#define TDM_TR2HALF_OFFS			16
+#define TDM_TR2HALF_MASK			(1 << TDM_TR2HALF_OFFS)
 #define TDM_SE_OFFS				20
 #define TDM_SE_MASK				(1 << TDM_SE_OFFS)
 #define TDM_COMMON_RX_TX_OFFS			23
@@ -322,6 +348,54 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define TDM_TEN_OFFS				31
 #define TDM_TEN_MASK				(1 << TDM_TEN_OFFS)
 
+/* TDM_DATA_DELAY_AND_CLK_CTRL_REG bits */
+#define TX_CLK_OUT_ENABLE_OFFS			0
+#define TX_CLK_OUT_ENABLE_MASK			(1 << TX_CLK_OUT_ENABLE_OFFS)
+#define RX_CLK_OUT_ENABLE_OFFS			1
+#define RX_CLK_OUT_ENABLE_MASK			(1 << RX_CLK_OUT_ENABLE_OFFS)
+#define FIXED_POINT_RX_SYNC_OFFS		2
+#define FIXED_POINT_RX_SYNC_MASK		(1 << FIXED_POINT_RX_SYNC_OFFS)
+#define TX_DELAY_HOTBIT_OFFS			4
+#define TX_NO_DELAY				(0 << TX_DELAY_HOTBIT_OFFS)
+#define TX_1BIT_DELAY				(1 << TX_DELAY_HOTBIT_OFFS)
+#define TX_2BIT_DELAY				(2 << TX_DELAY_HOTBIT_OFFS)
+#define TX_3BIT_DELAY				(4 << TX_DELAY_HOTBIT_OFFS)
+#define TX_4BIT_DELAY				(8 << TX_DELAY_HOTBIT_OFFS)
+#define RX_DELAY_HOTBIT_OFFS			8
+#define RX_NO_DELAY				(0 << RX_DELAY_HOTBIT_OFFS)
+#define RX_1BIT_DELAY				(1 << RX_DELAY_HOTBIT_OFFS)
+#define RX_2BIT_DELAY				(2 << RX_DELAY_HOTBIT_OFFS)
+#define RX_3BIT_DELAY				(4 << RX_DELAY_HOTBIT_OFFS)
+#define RX_4BIT_DELAY				(8 << RX_DELAY_HOTBIT_OFFS)
+
+/* TDM_PLUS_MINUS_DELAY_CTRL_FSYNC_OUT_REG bits */
+#define TX_SYNC_DELAY_OUT_OFFS			0
+#define TX_SYNC_DELAY_OUT_PLUS_MINUS_OFFS	14
+#define TX_SYNC_DELAY_OUT_PLUS			(0 << TX_SYNC_DELAY_OUT_PLUS_MINUS_OFFS)
+#define TX_SYNC_DELAY_OUT_MINUS			(1 << TX_SYNC_DELAY_OUT_PLUS_MINUS_OFFS)
+#define TX_SYNC_DELAY_OUT_RESTART_CALC_OFFS	15
+#define TX_SYNC_DELAY_OUT_RESTART_CALC_MASK	(1 << TX_SYNC_DELAY_OUT_RESTART_CALC_OFFS)
+#define RX_SYNC_DELAY_OUT_OFFS			16
+#define RX_SYNC_DELAY_OUT_PLUS_MINUS_OFFS	30
+#define RX_SYNC_DELAY_OUT_PLUS			(0 << RX_SYNC_DELAY_OUT_PLUS_MINUS_OFFS)
+#define RX_SYNC_DELAY_OUT_MINUS			(1 << RX_SYNC_DELAY_OUT_PLUS_MINUS_OFFS)
+#define RX_SYNC_DELAY_OUT_RESTART_CALC_OFFS	31
+#define RX_SYNC_DELAY_OUT_RESTART_CALC_MASK	(1 << RX_SYNC_DELAY_OUT_RESTART_CALC_OFFS)
+
+/* TDM_PLUS_MINUS_DELAY_CTRL_FSYNC_IN_REG bits */
+#define TX_SYNC_DELAY_IN_OFFS			0
+#define TX_SYNC_DELAY_IN_PLUS_MINUS_OFFS	14
+#define TX_SYNC_DELAY_IN_PLUS			(0 << TX_SYNC_DELAY_IN_PLUS_MINUS_OFFS)
+#define TX_SYNC_DELAY_IN_MINUS			(1 << TX_SYNC_DELAY_IN_PLUS_MINUS_OFFS)
+#define TX_SYNC_DELAY_IN_RESTART_CALC_OFFS	15
+#define TX_SYNC_DELAY_IN_RESTART_CALC_MASK	(1 << TX_SYNC_DELAY_IN_RESTART_CALC_OFFS)
+#define RX_SYNC_DELAY_IN_OFFS			16
+#define RX_SYNC_DELAY_IN_PLUS_MINUS_OFFS	30
+#define RX_SYNC_DELAY_IN_PLUS			(0 << RX_SYNC_DELAY_IN_PLUS_MINUS_OFFS)
+#define RX_SYNC_DELAY_IN_MINUS			(1 << RX_SYNC_DELAY_IN_PLUS_MINUS_OFFS)
+#define RX_SYNC_DELAY_IN_RESTART_CALC_OFFS	31
+#define RX_SYNC_DELAY_IN_RESTART_CALC_MASK	(1 << RX_SYNC_DELAY_IN_RESTART_CALC_OFFS)
+
 /************************************************/
 /*	Shared Bus to Crossbar Bridge		*/
 /************************************************/
@@ -371,4 +445,3 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define MV_COMM_UNIT_WIN_SIZE_ALIGN	_64K
 
 #endif /*__INCmvCommUnitRegsh*/
-
diff --git a/arch/arm/plat-armada/mv_hal/voiceband/mvCompVer.txt b/arch/arm/plat-armada/mv_hal/voiceband/mvCompVer.txt
index 3afa556..ca36d3e 100644
--- a/arch/arm/plat-armada/mv_hal/voiceband/mvCompVer.txt
+++ b/arch/arm/plat-armada/mv_hal/voiceband/mvCompVer.txt
@@ -1,4 +1,3 @@
 Global HAL Version: FEROCEON_HAL_3_1_7
 Unit HAL Version: 3.1.3
 Description: This component includes an implementation of the unit HAL drivers
-
diff --git a/arch/arm/plat-armada/mv_hal/voiceband/mvSysTdmSpi.h b/arch/arm/plat-armada/mv_hal/voiceband/mvSysTdmSpi.h
index 1ea3892..b0ffc6c 100644
--- a/arch/arm/plat-armada/mv_hal/voiceband/mvSysTdmSpi.h
+++ b/arch/arm/plat-armada/mv_hal/voiceband/mvSysTdmSpi.h
@@ -61,18 +61,11 @@ ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
-
-#ifndef __INCvoicebandh
-#define __INCvoicebandh
+#ifndef __MV_SYS_TDM_SPI_H__
+#define __MV_SYS_TDM_SPI_H__
 
 #include "mvOs.h"
 
-/* Defines */
-#define ON_HOOK			(1 << MV_ON_HOOK)
-#define OFF_HOOK		(1 << MV_OFF_HOOK)
-#define LINE_NO_SUCH		0xFFFF
-#define MV_SLIC_MAX_EVENTS	64
-
 /* Enumerators */
 typedef enum {
 	MV_NARROW_BAND = 0,
@@ -80,37 +73,16 @@ typedef enum {
 } MV_BAND_MODE;
 
 typedef enum {
-	MV_LINE_FXO = 0,
-	MV_LINE_FXS
-} MV_LINE;
-
-typedef enum {
-	MV_ON_HOOK = 0,
-	MV_OFF_HOOK
-} MV_HOOK_STATE;
-
-typedef enum {
 	MV_PCM_FORMAT_1BYTE = 1,
 	MV_PCM_FORMAT_2BYTES = 2,
 	MV_PCM_FORMAT_4BYTES = 4
 } MV_PCM_FORMAT;
 
 typedef enum {
-	LINEFEED_OPEN = 0,
-	LINEFEED_FORWARD_ACTIVE,
-	LINEFEED_FORWARD_ON_HOOK_TRANSMISSION,
-	LINEFEED_TIP_OPEN,
-	LINEFEED_RINGING,
-	LINEFEED_REVERESE_ACTIVE,
-	LINEFEED_REVERSE_ON_HOOK_TRANSMISSION,
-	LINEFEED_RING_OPEN
-} MV_LINEFEED_STATE;
-
-typedef struct {
-	MV_U8 deviceId;
-	MV_U16 lineId;
-	MV_U8 event;
-} MV_SLIC_EVENT_INFO;
+	MV_FRAME_32TS = 32,
+	MV_FRAME_64TS = 64,
+	MV_FRAME_128TS = 128
+} MV_FRAME_TS;
 
 /* APIs */
 MV_VOID mvSysTdmSpiRead(MV_U16 lineId, MV_U8 *cmdBuff, MV_U8 cmdSize, MV_U8 *dataBuff, MV_U8 dataSize);
@@ -118,4 +90,4 @@ MV_VOID mvSysTdmSpiWrite(MV_U16 lineId, MV_U8 *cmdBuff, MV_U8 cmdSize, MV_U8 *da
 MV_VOID mvSysTdmIntEnable(MV_U8 deviceId);
 MV_VOID mvSysTdmIntDisable(MV_U8 deviceId);
 
-#endif /* __INCvoicbandh */
+#endif /* __MV_SYS_TDM_SPI_H__ */
diff --git a/arch/arm/plat-armada/mv_hal/voiceband/tdm/mvTdm.c b/arch/arm/plat-armada/mv_hal/voiceband/tdm/mvTdm.c
index 1ba9a5b..eb76460 100644
--- a/arch/arm/plat-armada/mv_hal/voiceband/tdm/mvTdm.c
+++ b/arch/arm/plat-armada/mv_hal/voiceband/tdm/mvTdm.c
@@ -109,8 +109,8 @@ static MV_TDM_CH_INFO *tdmChInfo[MV_TDM_TOTAL_CHANNELS] = { NULL, NULL };
 
 MV_STATUS mvTdmHalInit(MV_TDM_PARAMS *tdmParams, MV_TDM_HAL_DATA *halData)
 {
-	MV_U8 ch, sample;
-	MV_U32 pcmCtrlReg, delay = 0, wbDelay = 0;
+	MV_U8 ch;
+	MV_U32 pcmCtrlReg, nbDelay = 0, wbDelay = 0;
 	MV_U32 chDelay[4] = { 0, 0, 0, 0 };
 
 	MV_TRC_REC("->%s\n", __func__);
@@ -130,14 +130,10 @@ MV_STATUS mvTdmHalInit(MV_TDM_PARAMS *tdmParams, MV_TDM_HAL_DATA *halData)
 
 	/* Extract pcm format & band mode */
 	if (pcmFormat == MV_PCM_FORMAT_4BYTES) {
-		sample = MV_PCM_FORMAT_2BYTES;
+		pcmFormat = MV_PCM_FORMAT_2BYTES;
 		tdmBandMode = MV_WIDE_BAND;
 	} else {
 		tdmBandMode = MV_NARROW_BAND;
-		if (pcmFormat == MV_PCM_FORMAT_2BYTES)
-			sample = MV_PCM_FORMAT_2BYTES;
-		else
-			sample = MV_PCM_FORMAT_1BYTE;
 	}
 
 	/* Allocate aggregated buffers for data transport */
@@ -157,9 +153,9 @@ MV_STATUS mvTdmHalInit(MV_TDM_PARAMS *tdmParams, MV_TDM_HAL_DATA *halData)
 
 	/* Calculate CH(0/1) Delay Control for narrow/wideband modes */
 	for (ch = 0; ch < MV_TDM_TOTAL_CHANNELS; ch++) {
-		delay = ((tdmParams->pcmSlot[ch] * PCM_SLOT_PCLK) + 1);
-		wbDelay = (delay + (2 * PCM_SLOT_PCLK));
-		chDelay[ch] = ((delay << CH_RX_DELAY_OFFS) | (delay << CH_TX_DELAY_OFFS));
+		nbDelay = ((tdmParams->pcmSlot[ch] * PCM_SLOT_PCLK) + 1);
+		wbDelay = (nbDelay + ((halData->frameTs / 2) * PCM_SLOT_PCLK)); /* Offset required by ZARLINK VE880 SLIC */
+		chDelay[ch] = ((nbDelay << CH_RX_DELAY_OFFS) | (nbDelay << CH_TX_DELAY_OFFS));
 		chDelay[(ch + 2)] = ((wbDelay << CH_RX_DELAY_OFFS) | (wbDelay << CH_TX_DELAY_OFFS));
 	}
 
@@ -170,25 +166,23 @@ MV_STATUS mvTdmHalInit(MV_TDM_PARAMS *tdmParams, MV_TDM_HAL_DATA *halData)
 	MV_REG_WRITE(INT_EVENT_MASK_REG, 0x3ffff);	/* all interrupt bits latched in status */
 	MV_REG_WRITE(INT_STATUS_MASK_REG, 0);	/* disable interrupts */
 	MV_REG_WRITE(INT_STATUS_REG, 0);	/* clear int status register */
-	if ((halData->model & 0xff00) == MV_65XX_DEV_ID) {
-		/* Bypass clock divider */
-		MV_REG_WRITE(PCM_CLK_RATE_DIV_REG, PCM_DIV_PASS);	/* PCM PCLK freq */
-	} else {
-		MV_REG_WRITE(PCM_CLK_RATE_DIV_REG, PCM_8192KHZ);	/* PCM PCLK freq */
-	}
+
+	/* Bypass clock divider */
+	MV_REG_WRITE(PCM_CLK_RATE_DIV_REG, PCM_DIV_PASS);	/* PCM PCLK freq */
+
 	MV_REG_WRITE(DUMMY_RX_WRITE_DATA_REG, 0);	/* Padding on Rx completion */
 	MV_REG_BYTE_WRITE(SPI_GLOBAL_CTRL_REG, MV_REG_READ(SPI_GLOBAL_CTRL_REG) | SPI_GLOBAL_ENABLE);
 	MV_REG_BYTE_WRITE(SPI_CLK_PRESCALAR_REG, SPI_CLK_2MHZ);	/* SPI SCLK freq */
-	MV_REG_WRITE(FRAME_TIMESLOT_REG, TIMESLOTS128_8192KHZ);	/* Number of timeslots (PCLK) */
+	MV_REG_WRITE(FRAME_TIMESLOT_REG, (MV_U32)halData->frameTs); /* Number of timeslots (PCLK) */
 
 	if (tdmBandMode == MV_NARROW_BAND) {
-		pcmCtrlReg = (CONFIG_PCM_CRTL | ((sample - 1) << PCM_SAMPLE_SIZE_OFFS));
+		pcmCtrlReg = (CONFIG_PCM_CRTL | (((MV_U8)pcmFormat - 1) << PCM_SAMPLE_SIZE_OFFS));
 		MV_REG_WRITE(PCM_CTRL_REG, pcmCtrlReg);	/* PCM configuration */
 		MV_REG_WRITE(CH_DELAY_CTRL_REG(0), chDelay[0]);	/* CH0 delay control register */
 		MV_REG_WRITE(CH_DELAY_CTRL_REG(1), chDelay[1]);	/* CH1 delay control register */
 	} else {		/* MV_WIDE_BAND */
 
-		pcmCtrlReg = (CONFIG_WB_PCM_CRTL | ((sample - 1) << PCM_SAMPLE_SIZE_OFFS));
+		pcmCtrlReg = (CONFIG_WB_PCM_CRTL | (((MV_U8)pcmFormat - 1) << PCM_SAMPLE_SIZE_OFFS));
 		MV_REG_WRITE(PCM_CTRL_REG, pcmCtrlReg);	/* PCM configuration - WB support */
 		MV_REG_WRITE(CH_DELAY_CTRL_REG(0), chDelay[0]);	/* CH0 delay control register */
 		MV_REG_WRITE(CH_DELAY_CTRL_REG(1), chDelay[1]);	/* CH1 delay control register */
@@ -486,7 +480,7 @@ MV_VOID mvTdmIntLow(MV_TDM_INT_INFO *tdmIntInfo)
 
 	/* Read Status & mask registers */
 	statusReg = MV_REG_READ(INT_STATUS_REG);
-	maskReg = MV_REG_READ(INT_EVENT_MASK_REG);
+	maskReg = MV_REG_READ(INT_STATUS_MASK_REG);
 	MV_TRC_REC("CAUSE(0x%x), MASK(0x%x)\n", statusReg, maskReg);
 
 	/* Refer only to unmasked bits */
@@ -514,13 +508,13 @@ MV_VOID mvTdmIntLow(MV_TDM_INT_INFO *tdmIntInfo)
 	if (statusAndMask & DMA_ABORT_BIT) {
 		mvOsPrintf("DMA data abort. Address: 0x%08x, Info: 0x%08x\n",
 			   MV_REG_READ(DMA_ABORT_ADDR_REG), MV_REG_READ(DMA_ABORT_INFO_REG));
-		tdmIntInfo->intType |= MV_ERROR_INT;
+		tdmIntInfo->intType |= MV_DMA_ERROR_INT;
 	}
 
 	for (ch = 0; ch < MV_TDM_TOTAL_CHANNELS; ch++) {
 		if (statusAndMask & TDM_INT_TX(ch)) {
 			/* Give next buff to TDM and set curr buff as empty */
-			if (statusAndMask & TX_BIT(ch)) {
+			if ((statusAndMask & TX_BIT(ch)) && tdmEnable) {
 				MV_TRC_REC("Tx interrupt(ch%d) !!!\n", ch);
 
 				/* MV_OK -> Tx is done for both channels */
@@ -532,23 +526,30 @@ MV_VOID mvTdmIntLow(MV_TDM_INT_INFO *tdmIntInfo)
 			}
 
 			if (statusAndMask & TX_UNDERFLOW_BIT(ch)) {
+				MV_TRC_REC("Tx underflow(ch%d) - checking for root cause...\n", ch);
 				if (tdmEnable) {
-					mvOsPrintf("Tx underflow on ch(%d) !!!\n", ch);
+					MV_TRC_REC("Tx underflow ERROR\n");
+					tdmIntInfo->intType |= MV_TX_ERROR_INT;
+					if (!(statusAndMask & TX_BIT(ch))) {
+						MV_TRC_REC("Trying to recover for ch(%d)\n", ch);
+						/* Set HW ownership */
+						MV_REG_BYTE_WRITE(CH_BUFF_OWN_REG(ch) + TX_OWN_BYTE_OFFS, OWN_BY_HW);
+						/* Enable Tx */
+						MV_REG_BYTE_WRITE(CH_ENABLE_REG(ch) + TX_ENABLE_BYTE_OFFS, CH_ENABLE);
+					}
 				} else {
+					MV_TRC_REC("Expected Tx underflow(not an error)\n");
 					MV_REG_WRITE(INT_STATUS_MASK_REG,
 						     MV_REG_READ(INT_STATUS_MASK_REG) & (~(TDM_INT_TX(ch))));
 				}
-
-				/*tdmIntInfo->intType |= MV_ERROR_INT;
-				   MV_REG_WRITE(INT_EVENT_MASK_REG, (maskReg & (~(TDM_INT_TX(ch))))); */
 			}
 		}
 
 		if (statusAndMask & TDM_INT_RX(ch)) {
-			if (statusAndMask & RX_BIT(ch)) {
+			if ((statusAndMask & RX_BIT(ch)) && tdmEnable) {
 				MV_TRC_REC("Rx interrupt(ch%d) !!!\n", ch);
 
-				/* MV_OK -> Tx is done for both channels */
+				/* MV_OK -> Rx is done for both channels */
 				if (mvTdmChRxLow(ch) == MV_OK) {
 					MV_TRC_REC("Assign Rx aggregate buffer for further processing\n");
 					tdmIntInfo->tdmRxBuff = rxAggrBuffVirt;
@@ -557,14 +558,22 @@ MV_VOID mvTdmIntLow(MV_TDM_INT_INFO *tdmIntInfo)
 			}
 
 			if (statusAndMask & RX_OVERFLOW_BIT(ch)) {
+				MV_TRC_REC("Rx overflow(ch%d) - checking for root cause...\n", ch);
 				if (tdmEnable) {
-					mvOsPrintf("Rx overflow on ch(%d) !!!\n", ch);
+					MV_TRC_REC("Rx overflow ERROR\n");
+					tdmIntInfo->intType |= MV_RX_ERROR_INT;
+					if (!(statusAndMask & RX_BIT(ch))) {
+						MV_TRC_REC("Trying to recover for ch(%d)\n", ch);
+						/* Set HW ownership */
+						MV_REG_BYTE_WRITE(CH_BUFF_OWN_REG(ch) + RX_OWN_BYTE_OFFS, OWN_BY_HW);
+						/* Enable Rx */
+						MV_REG_BYTE_WRITE(CH_ENABLE_REG(ch) + RX_ENABLE_BYTE_OFFS, CH_ENABLE);
+					}
 				} else {
+					MV_TRC_REC("Expected Rx overflow(not an error)\n");
 					MV_REG_WRITE(INT_STATUS_MASK_REG,
 						     MV_REG_READ(INT_STATUS_MASK_REG) & (~(TDM_INT_RX(ch))));
 				}
-				/*tdmIntInfo->intType |= MV_ERROR_INT;
-				   MV_REG_WRITE(INT_EVENT_MASK_REG, (maskReg & (~(TDM_INT_RX(ch))))); */
 			}
 		}
 	}
diff --git a/arch/arm/plat-armada/mv_hal/voiceband/tdm/mvTdm.h b/arch/arm/plat-armada/mv_hal/voiceband/tdm/mvTdm.h
index bde7cd0..3909a7f 100644
--- a/arch/arm/plat-armada/mv_hal/voiceband/tdm/mvTdm.h
+++ b/arch/arm/plat-armada/mv_hal/voiceband/tdm/mvTdm.h
@@ -82,13 +82,17 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define MV_TDM_INT_COUNTER					2
 #define MV_TDM_MAX_SAMPLING_PERIOD				30	/* ms */
 #define MV_TDM_BASE_SAMPLING_PERIOD				10	/* ms */
+#define MV_TDM_TOTAL_CH_SAMPLES					80	/* samples */
 
 /* TDM IRQ types */
 #define MV_EMPTY_INT		0
 #define MV_RX_INT 		BIT0
 #define	MV_TX_INT 		BIT1
 #define	MV_PHONE_INT 		BIT2
-#define	MV_ERROR_INT 		BIT3
+#define	MV_RX_ERROR_INT 	BIT3
+#define	MV_TX_ERROR_INT 	BIT4
+#define MV_DMA_ERROR_INT	BIT5
+#define MV_ERROR_INT		(MV_RX_ERROR_INT | MV_TX_ERROR_INT | MV_DMA_ERROR_INT)
 
 /* PCM SLOT configuration */
 
@@ -154,7 +158,10 @@ typedef struct {
 
 typedef struct {
 	MV_U8 spiMode;
+	MV_U8 maxCs;
 	MV_U16 model;
+	MV_U16 ctrlRev;
+	MV_FRAME_TS frameTs;
 } MV_TDM_HAL_DATA;
 
 /* APIs */
diff --git a/arch/arm/plat-armada/mv_hal/voiceband/tdm/mvTdmRegs.h b/arch/arm/plat-armada/mv_hal/voiceband/tdm/mvTdmRegs.h
index 81519eb..7304e5d 100644
--- a/arch/arm/plat-armada/mv_hal/voiceband/tdm/mvTdmRegs.h
+++ b/arch/arm/plat-armada/mv_hal/voiceband/tdm/mvTdmRegs.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 Copyright (C) Marvell International Ltd. and its affiliates
 
-This software file (the "File") is owned and distributed by Marvell 
+This software file (the "File") is owned and distributed by Marvell
 International Ltd. and/or its affiliates ("Marvell") under the following
 alternative licensing terms.  Once you have made an election to distribute the
 File under one of the following license alternatives, please (i) delete this
@@ -19,45 +19,45 @@ to you under the terms of the applicable Commercial License.
 ********************************************************************************
 Marvell GPL License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File in accordance with the terms and conditions of the General 
-Public License Version 2, June 1991 (the "GPL License"), a copy of which is 
-available along with the File in the license.txt file or by writing to the Free 
-Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or 
-on the worldwide web at http://www.gnu.org/licenses/gpl.txt. 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File in accordance with the terms and conditions of the General
+Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+available along with the File in the license.txt file or by writing to the Free
+Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
 
-THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY 
-DISCLAIMED.  The GPL License provides additional details about this warranty 
+THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 ********************************************************************************
 Marvell BSD License Option
 
-If you received this File from Marvell, you may opt to use, redistribute and/or 
-modify this File under the following licensing terms. 
-Redistribution and use in source and binary forms, with or without modification, 
+If you received this File from Marvell, you may opt to use, redistribute and/or
+modify this File under the following licensing terms.
+Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
     *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer. 
+	this list of conditions and the following disclaimer.
 
     *   Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution. 
-
-    *   Neither the name of Marvell nor the names of its contributors may be 
-        used to endorse or promote products derived from this software without 
-        specific prior written permission. 
-    
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR 
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
@@ -221,19 +221,19 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 /*********************************/
 /*        SPI Register Map       */
 /*********************************/
-#define SPI_CLK_PRESCALAR_REG	(MV_TDM_REGS_BASE +0x3100)
-#define SPI_GLOBAL_CTRL_REG	(MV_TDM_REGS_BASE +0x3104)
-#define SPI_CTRL_REG		(MV_TDM_REGS_BASE +0x3108)
-#define SPI_MICRO_WIRE_CTRL_REG	(MV_TDM_REGS_BASE +0x310c)
-#define SPI_TWSI_CTRL_REG	(MV_TDM_REGS_BASE +0x3110)
-#define SPI_MV_STATUS_REG	(MV_TDM_REGS_BASE +0x311c)
-#define SPI_INT_MASK_REG	(MV_TDM_REGS_BASE +0x3120)
-#define SPI_DATA_REG		(MV_TDM_REGS_BASE +0x3124)
-#define SPI_ADDR_REG		(MV_TDM_REGS_BASE +0x3128)
-#define SPI_CODEC_CMD_LO_REG	(MV_TDM_REGS_BASE +0x3130)
-#define SPI_CODEC_CMD_HI_REG	(MV_TDM_REGS_BASE +0x3134)
-#define SPI_CODEC_CTRL_REG	(MV_TDM_REGS_BASE +0x3138)
-#define SPI_CODEC_READ_DATA_REG	(MV_TDM_REGS_BASE +0x313c)
+#define SPI_CLK_PRESCALAR_REG	(MV_TDM_REGS_BASE + 0x3100)
+#define SPI_GLOBAL_CTRL_REG	(MV_TDM_REGS_BASE + 0x3104)
+#define SPI_CTRL_REG		(MV_TDM_REGS_BASE + 0x3108)
+#define SPI_MICRO_WIRE_CTRL_REG	(MV_TDM_REGS_BASE + 0x310c)
+#define SPI_TWSI_CTRL_REG	(MV_TDM_REGS_BASE + 0x3110)
+#define SPI_MV_STATUS_REG	(MV_TDM_REGS_BASE + 0x311c)
+#define SPI_INT_MASK_REG	(MV_TDM_REGS_BASE + 0x3120)
+#define SPI_DATA_REG		(MV_TDM_REGS_BASE + 0x3124)
+#define SPI_ADDR_REG		(MV_TDM_REGS_BASE + 0x3128)
+#define SPI_CODEC_CMD_LO_REG	(MV_TDM_REGS_BASE + 0x3130)
+#define SPI_CODEC_CMD_HI_REG	(MV_TDM_REGS_BASE + 0x3134)
+#define SPI_CODEC_CTRL_REG	(MV_TDM_REGS_BASE + 0x3138)
+#define SPI_CODEC_READ_DATA_REG	(MV_TDM_REGS_BASE + 0x313c)
 
 /* SPI CLK_PRESCALAR_REG bits */
 #define SPI_CLK_2MHZ	0x2A64  /* refers to tclk = 200MHz */
@@ -276,7 +276,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #define TDM_MBUS_MAX_WIN	4
 #define TDM_WIN_CTRL_REG(win)	((MV_TDM_REGS_BASE + 0x4030) + (win<<4))
-#define TDM_WIN_BASE_REG(win)	((MV_TDM_REGS_BASE +0x4034) + (win<<4))
+#define TDM_WIN_BASE_REG(win)	((MV_TDM_REGS_BASE + 0x4034) + (win<<4))
 
 /* TDM_WIN_CTRL_REG bits */
 #define TDM_WIN_ENABLE_OFFS	0
@@ -297,4 +297,3 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 
 #endif /*__INCmvTdmRegsh*/
-
-- 
1.7.5.4

