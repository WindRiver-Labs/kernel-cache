From f518f112ee7f1421d1dba8c47ba314be0b4fa5ba Mon Sep 17 00:00:00 2001
From: OmriOmri Itach <omrii@marvell.com>
Date: Sun, 24 Mar 2013 18:11:31 +0200
Subject: [PATCH 0521/1825] Avanta LP: S@R Init sequnce: Added IO Expanders
 mapping & EEPROM jumper detection

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 07f3ca46fe1b42d4bb5916608f1055dd8ffb20dc

IO Expanders, added:
1. IO Expanders mapping struct for DB-6660 and DB-6650
2. mvBoardIoExpanderTypeGet  - read IO Expanders struct information
3. mvBoardIoExpanderValueGet - read value of IO Expander field
4. mvCtrlIsEepromEnabled     - read EEPROM jumper state from IO Expander

S@R init sequence:
1. added mvCtrlConfigurationRead - verify EEPROM Jumper and boardID,
        and read board configuration acording to detection, from EEPROM / DIP-Switch.
2. modified mvBoardTwsiAddrGet to implicitly verify device number (added devClassId)
3. aligned boardConfigTypesInfo fields to be shared between DB-6660 and DB-6650

Change-Id: I15c4c17f068fcd3d83427bf96ffbda7c4d1b3a1e
Reviewed-on: http://vgitil04.il.marvell.com:8080/1384
Reviewed-by: Omri Itach <omrii@marvell.com>
Tested-by: Omri Itach <omrii@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../avanta_lp_family/boardEnv/mvBoardEnvLib.c      |   96 ++++++++++--
 .../avanta_lp_family/boardEnv/mvBoardEnvLib.h      |   17 ++-
 .../avanta_lp_family/boardEnv/mvBoardEnvSpec.c     |  166 +++++++++++++-------
 .../avanta_lp_family/boardEnv/mvBoardEnvSpec.h     |   38 +++---
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c        |  119 +++++++++++----
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h        |   33 ++++-
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h       |    2 +
 7 files changed, 345 insertions(+), 126 deletions(-)
 mode change 100644 => 100755 arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.c

diff --git a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
index 140ebbd..afcf5c7 100755
--- a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
@@ -91,12 +91,15 @@
 #endif
 
 extern MV_BOARD_INFO *boardInfoTbl[];
+extern MV_BOARD_SAR_INFO boardSarInfo[];
+extern MV_BOARD_CONFIG_TYPE_INFO boardConfigTypesInfo[];
 
 /* Locals */
 static MV_DEV_CS_INFO *boardGetDevEntry(MV_32 devNum, MV_BOARD_DEV_CLASS devClass);
 static MV_U32 gBoardId = MV_INVALID_BOARD_ID;
 static MV_BOARD_INFO *board = NULL;
 
+
 /*******************************************************************************
 * mvBoardEnvInit
 *
@@ -1567,6 +1570,36 @@ MV_U32 boardGetDevCSNum(MV_32 devNum, MV_BOARD_DEV_CLASS devClass)
 }
 
 /*******************************************************************************
+* mvBoardIoExpValGet - read a specified value from IO Expanders
+*
+* DESCRIPTION:
+*       This function returns specified value from IO Expanders
+*
+* INPUT:
+*       ioClass - Field identifier
+*       ioInfo  - relevant IO Expander information
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_U8  :return requested value , if TWSI read was succesfull, else 0xFF.
+*
+*******************************************************************************/
+MV_U8 mvBoardIoExpValGet(MV_BOARD_IO_EXPANDER_TYPE_INFO ioInfo)
+{
+	MV_U8 tempVal, mask;
+
+	tempVal = mvBoardTwsiGet(BOARD_DEV_TWSI_IO_EXPANDER, ioInfo.expanderNum, ioInfo.regNum);
+	if ((MV_8)MV_ERROR != (MV_8)tempVal) {
+		mask = (1 << ioInfo.offset);
+		return ( (tempVal & mask) >> ioInfo.offset);
+	}
+	else
+		return 0xFF;
+}
+
+/*******************************************************************************
 * mvBoardTwsiAddrTypeGet
 *
 * DESCRIPTION:
@@ -1622,14 +1655,11 @@ MV_U8 mvBoardTwsiAddrTypeGet(MV_BOARD_TWSI_CLASS twsiClass, MV_U32 index)
 MV_U8 mvBoardTwsiAddrGet(MV_BOARD_TWSI_CLASS twsiClass, MV_U32 index)
 {
 	int i;
-	MV_U32 indexFound = 0;
 
 	for (i = 0; i < board->numBoardTwsiDev; i++) {
-		if (board->pBoardTwsiDev[i].devClass == twsiClass) {
-			if (indexFound == index)
-				return board->pBoardTwsiDev[i].twsiDevAddr;
-			else
-				indexFound++;
+		if ((board->pBoardTwsiDev[i].devClass == twsiClass) \
+				&& (board->pBoardTwsiDev[i].devClassId == index)){
+			return board->pBoardTwsiDev[i].twsiDevAddr;
 		}
 	}
 
@@ -1701,11 +1731,18 @@ MV_VOID mvBoardEthComplexConfigSet(MV_U32 ethConfig)
 MV_STATUS mvBoardSarInfoGet(MV_SATR_TYPE_ID sarClass, MV_BOARD_SAR_INFO *sarInfo)
 {
 	int i;
+	MV_U32 boardId = mvBoardIdGet();
 
-	for (i = 0; i < board->numBoardSarInfo; i++)
-		if (board->pBoardSarInfo[i].sarid == sarClass) {
-			*sarInfo = board->pBoardSarInfo[i];
-			return MV_OK;
+	if (sarInfo == NULL )
+		return MV_ERROR;
+
+	/* verify existence of requested SATR type, pull its data,
+	 * and check if field is relevant to current running board */
+	for (i = 0; i < MV_SATR_READ_MAX_OPTION ; i++)
+		if (boardSarInfo[i].sarid == sarClass) {
+			*sarInfo = boardSarInfo[i];
+			if (boardSarInfo[i].isActiveForBoard[boardId])
+				return MV_OK;
 		}
 	return MV_ERROR;
 }
@@ -1729,10 +1766,43 @@ MV_STATUS mvBoardSarInfoGet(MV_SATR_TYPE_ID sarClass, MV_BOARD_SAR_INFO *sarInfo
 MV_STATUS mvBoardConfigTypeGet(MV_CONFIG_TYPE_ID configClass, MV_BOARD_CONFIG_TYPE_INFO *configInfo)
 {
 	int i;
+	MV_U32 boardId = mvBoardIdGet();
+
+	/* verify existence of requested config type, pull its data,
+	 * and check if field is relevant to current running board */
+	for (i = 0; i < MV_CONFIG_TYPE_MAX_OPTION ; i++)
+		if (boardConfigTypesInfo[i].configid == configClass) {
+			*configInfo = boardConfigTypesInfo[i];
+			if (boardConfigTypesInfo[i].isActiveForBoard[boardId])
+				return MV_OK;
+		}
+	return MV_ERROR;
+}
+
+/*******************************************************************************
+* mvBoardIoExpanderTypeGet
+*
+* DESCRIPTION:
+*	Return the Config type fields information for a given Config type class.
+*
+* INPUT:
+*	configClass - The Config type field to return the information for.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*	MV_BOARD_CONFIG_TYPE_INFO struct with mask, offset and register number.
+*
+*******************************************************************************/
+MV_STATUS mvBoardIoExpanderTypeGet(MV_IO_EXPANDER_TYPE_ID ioClass, MV_BOARD_IO_EXPANDER_TYPE_INFO *ioInfo)
+{
+	int i;
 
-	for (i = 0; i < board->numBoardConfigTypes; i++)
-		if (board->pBoardConfigTypes[i].configid == configClass) {
-			*configInfo = board->pBoardConfigTypes[i];
+	/* verify existance of requested config type, pull its data */
+	for (i = 0; i < board->numBoardIoExpanderInfo ; i++)
+		if (board->pBoardIoExpanderInfo[i].ioFieldid == ioClass) {
+			*ioInfo = board->pBoardIoExpanderInfo[i];
 			return MV_OK;
 		}
 	return MV_ERROR;
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h
index 93c5284..fffbfca 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h
@@ -208,6 +208,7 @@ typedef struct _boardGppInfo {
 
 typedef struct _boardTwsiInfo {
 	MV_BOARD_TWSI_CLASS devClass;
+	MV_U8 devClassId;
 	MV_U8 twsiDevAddr;
 	MV_U8 twsiDevAddrType;
 } MV_BOARD_TWSI_INFO;
@@ -224,10 +225,18 @@ typedef struct _boardConfigTypesInfo {
 	MV_CONFIG_TYPE_ID configid;
 	MV_U32 mask;
 	MV_U32 offset;
+	MV_U32 expanderNum;
 	MV_U32 regNum;
 	MV_U32 isActiveForBoard[MV_MAX_BOARD_ID];
 } MV_BOARD_CONFIG_TYPE_INFO;
 
+typedef struct _boardIoExapnderTypesInfo {
+	MV_IO_EXPANDER_TYPE_ID ioFieldid;
+	MV_U32 offset;
+	MV_U32 expanderNum;
+	MV_U32 regNum;
+} MV_BOARD_IO_EXPANDER_TYPE_INFO;
+
 typedef enum _boardMacSpeed {
 	BOARD_MAC_SPEED_10M,
 	BOARD_MAC_SPEED_100M,
@@ -306,10 +315,8 @@ typedef struct _boardInfo {
 	MV_U32 intsGppMaskHigh;
 	MV_U8 numBoardDeviceIf;
 	MV_DEV_CS_INFO *pDevCsInfo;
-	MV_U8 numBoardSarInfo;
-	MV_BOARD_SAR_INFO *pBoardSarInfo;
-	MV_U8 numBoardConfigTypes;
-	MV_BOARD_CONFIG_TYPE_INFO *pBoardConfigTypes;
+	MV_U8 numBoardIoExpanderInfo;
+	MV_BOARD_IO_EXPANDER_TYPE_INFO *pBoardIoExpanderInfo;
 	MV_U8 numBoardTwsiDev;
 	MV_BOARD_TWSI_INFO *pBoardTwsiDev;
 	MV_U8 numBoardMacInfo;
@@ -411,11 +418,13 @@ MV_BOOL mvBoardIsPortInSgmii(MV_U32 ethPortNum);
 MV_BOOL mvBoardIsPortInGmii(MV_U32 ethPortNum);
 MV_BOOL mvBoardIsPortLoopback(MV_U32 ethPortNum);
 MV_32 mvBoardPhyAddrGet(MV_U32 ethPortNum);
+MV_U8 mvBoardIoExpValGet(MV_BOARD_IO_EXPANDER_TYPE_INFO ioInfo);
 MV_32 mvBoardPhyLinkCryptPortAddrGet(MV_U32 ethPortNum);
 
 MV_32 mvBoardQuadPhyAddr0Get(MV_U32 ethPortNum);
 MV_STATUS mvBoardSarInfoGet(MV_SATR_TYPE_ID sarClass, MV_BOARD_SAR_INFO *sarInfo);
 MV_STATUS mvBoardConfigTypeGet(MV_CONFIG_TYPE_ID configClass, MV_BOARD_CONFIG_TYPE_INFO *configInfo);
+MV_STATUS mvBoardIoExpanderTypeGet(MV_IO_EXPANDER_TYPE_ID ioClass, MV_BOARD_IO_EXPANDER_TYPE_INFO *ioInfo);
 MV_U32 mvBoardTclkGet(MV_VOID);
 MV_U32 mvBoardSysClkGet(MV_VOID);
 MV_U32 mvBoardDebugLedNumGet(MV_U32 boardId);
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.c b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.c
old mode 100644
new mode 100755
index 09b44cd..0d797c9
--- a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.c
@@ -70,8 +70,8 @@
 #define ARRSZ(x)                (sizeof(x) / sizeof(x[0]))
 
 MV_BOARD_SAR_INFO boardSarInfo[] = {
-/* {{MV_SATR_TYPE_ID SarID, MV_U32 Mask, MV_U32 Offset, MV_U32 regNum}} */
-	{ MV_SATR_CPU_FREQ,		 0x003E0000,	  17,	       1, {1,0,0,0} },
+/* {	{MV_SATR_TYPE_ID SarID,		MV_U32 Mask,   	      Offset, regNum , 	       isActiveForBoard[]}} */
+	{ MV_SATR_CPU_DDR_L2_FREQ,		 0x003E0000,	  17,	       1, {1,0,0,0} },
 	{ MV_SATR_CORE_CLK_SELECT,	 0x00400000,	  22,	       1, {1,0,0,0} },
 	{ MV_SATR_CPU1_ENABLE,		 0x00008000,	  15,	       0, {1,0,0,0} },
 	{ MV_SATR_SSCG_DISABLE,		 0x00000002,	  1,	       0, {1,0,0,0} },
@@ -97,17 +97,67 @@ MV_BOARD_SAR_INFO boardSarInfo[] = {
 };
 
 MV_BOARD_CONFIG_TYPE_INFO boardConfigTypesInfo[] = {
-/* {{MV_CONFIG_TYPE_ID ConfigID, MV_U32 Mask, MV_U32 Offset, MV_U32 regNum}} */
-	{ MV_CONFIG_MAC0,	       0x3,	 0,	   0, {1,0,0,0} }, /* Reg#0, BITS [0:1] */
-	{ MV_CONFIG_MAC1,	       0xC,	 2,	   0, {1,0,0,0} }, /* Reg#0, BITS [2:3] */
-	{ MV_CONFIG_PON_SERDES,	       0x10,	 4,	   0, {1,0,0,0} }, /* Reg#0, BITS [4] */
-	{ MV_CONFIG_PON_BEN_POLARITY,  0x20,	 5,	   0, {1,0,0,0} }, /* Reg#0, BITS [5] */
-	{ MV_CONFIG_SGMII0_CAPACITY,   0x40,	 6,	   0, {1,0,0,0} }, /* Reg#0, BITS [6] */
-	{ MV_CONFIG_SGMII1_CAPACITY,   0x80,	 7,	   0, {1,0,0,0} }, /* Reg#0, BITS [7] */
-	{ MV_CONFIG_LANE1,	       0x3,	 0,	   1, {1,0,0,0} }, /* Reg#1, BITS [0:1] */
-	{ MV_CONFIG_LANE2,	       0x4,	 2,	   1, {1,0,0,0} }, /* Reg#1, BITS [2] */
-	{ MV_CONFIG_LANE3,	       0X18,	 3,	   1, {1,0,0,0} }, /* Reg#1, BITS [3:4] */
-	{ MV_CONFIG_DEVICE_BUS_MODULE, 0x60,	 5,	   1, {1,0,0,0} }, /* Reg#1, BITS [5:6] */
+/* {{MV_CONFIG_TYPE_ID ConfigID, MV_U32 Mask,  Offset, expanderNum,  regNum,    isActiveForBoard[]}} */
+	{ MV_CONFIG_MAC0,	       0x3,	0,	 0,		0, 	{ 1, 0, 1, 0 } }, /* Exp#0, Reg#0, BITS [0:1] */
+	{ MV_CONFIG_MAC1,	       0xC,	2,	 0,		0, 	{ 1, 0, 1, 0 } }, /* Exp#0, Reg#0, BITS [2:3] */
+	{ MV_CONFIG_PON_SERDES,	       0x10,	4,	 0,		0, 	{ 1, 0, 1, 0 } }, /* Exp#0, Reg#0, BITS [4]   */
+	{ MV_CONFIG_PON_BEN_POLARITY,  0x20,	5,	 0,		0, 	{ 1, 0, 1, 0 } }, /* Exp#0, Reg#0, BITS [5]   */
+	{ MV_CONFIG_SGMII0_CAPACITY,   0x40,	6,	 0,		0, 	{ 1, 0, 0, 0 } }, /* Exp#0, Reg#0, BITS [6]   */
+	{ MV_CONFIG_SGMII1_CAPACITY,   0x80,	7,	 0,		0, 	{ 1, 0, 1, 0 } }, /* Exp#0, Reg#0, BITS [7]   */
+	{ MV_CONFIG_SLIC_TDM_DEVICE,   0x3,	0,	 0,		1, 	{ 1, 0, 1, 0 } }, /* Exp#0, Reg#1, BITS [0:1] */
+	{ MV_CONFIG_LANE1,	       0xC,	2,	 0,		1, 	{ 1, 0, 0, 0 } }, /* Exp#0, Reg#1, BITS [2:3] */
+	{ MV_CONFIG_LANE2,	       0x10,	4,	 0,		1, 	{ 1, 0, 0, 0 } }, /* Exp#0, Reg#1, BITS [4]   */
+	{ MV_CONFIG_LANE3,	       0X60,	5,	 0,		1, 	{ 1, 0, 0, 0 } }, /* Exp#0, Reg#1, BITS [5:6] */
+	{ MV_CONFIG_DEVICE_BUS_MODULE, 0x3,	0,	 1,		0, 	{ 1, 0, 0, 0 } }, /* Exp#1, Reg#0, BITS [0:1] */
+};
+
+MV_BOARD_IO_EXPANDER_TYPE_INFO db88f6660InfoBoardIOExpanderInfo[] = {
+/* {{MV_CONFIG_TYPE_ID ConfigID,      MV_U32 Offset,	 expanderNum,  regNum,   }} */
+		/* 1st IO Expander Register*/
+	{ MV_IO_EXPANDER_SFP0_TX_DIS,		 0,		 1,	 1},
+	{ MV_IO_EXPANDER_SFP0_PRSNT,		 1,		 1,	 1},
+	{ MV_IO_EXPANDER_SFP0_TX_FAULT,		 2,		 1,	 1},
+	{ MV_IO_EXPANDER_SFP0_LOS,		 3,		 1,	 1},
+	{ MV_IO_EXPANDER_USB_VBUS,		 4,		 1,	 1},
+	{ MV_IO_EXPANDER_MAC0_RJ45_PORT_LED,	 5,		 1,	 1},
+	{ MV_IO_EXPANDER_MAC0_SFP_PORT_LED,	 6,		 1,	 1},
+	{ MV_IO_EXPANDER_PON_PORT_LED,		 7,		 1,	 1},
+		/* 2nd IO Expander Register*/
+	{ MV_IO_EXPANDER_SD_STATUS,		 0,		 2,	 0},
+	{ MV_IO_EXPANDER_SD_WRITE_PROTECT,	 1,		 2,	 0},
+	{ MV_IO_EXPANDER_SFP1_PRSNT,		 2,		 2,	 0},
+	{ MV_IO_EXPANDER_SFP1_TX_FAULT,		 3,		 2,	 0},
+	{ MV_IO_EXPANDER_SFP1_LOS,		 4,		 2,	 0},
+	{ MV_IO_EXPANDER_JUMPER1_EEPROM_ENABLED, 6,		 2,	 0},
+	{ MV_IO_EXPANDER_JUMPER2,		 7,		 2,	 0},
+		/* 3rd IO Expander Register*/
+	{ MV_IO_EXPANDER_EXT_PHY_SMI_EN,	 0,		 2,	 1},
+	{ MV_IO_EXPANDER_SFP1_TX_DIS,		 1,		 2,	 1},
+	{ MV_IO_EXPANDER_SPI1_CS_MSB0,		 2,		 2,	 1},
+	{ MV_IO_EXPANDER_SPI1_CS_MSB1,		 3,		 2,	 1},
+	{ MV_IO_EXPANDER_MAC1_SFP_PORT_LED,	 4,		 2,	 1},
+	{ MV_IO_EXPANDER_MAC1_RJ45_PORT_LED,	 5,		 2,	 1},
+	{ MV_IO_EXPANDER_INTEG_PHY_PORTS_LED,	 6,		 2,	 1},
+	{ MV_IO_EXPANDER_USB_SUPER_SPEED,	 7,		 2,	 1},
+};
+
+MV_BOARD_IO_EXPANDER_TYPE_INFO db88f6650InfoBoardIOExpanderInfo[] = {
+/* {{MV_CONFIG_TYPE_ID ConfigID,      MV_U32 Offset,	 expanderNum,  regNum,   }} */
+		/* 2nd IO Expander Register*/
+	{ MV_IO_EXPANDER_USB_VBUS,		 0,		 2,	 0},
+	{ MV_IO_EXPANDER_SFP1_PRSNT,		 2,		 2,	 0},
+	{ MV_IO_EXPANDER_SFP1_TX_FAULT,		 3,		 2,	 0},
+	{ MV_IO_EXPANDER_SFP1_LOS,		 4,		 2,	 0},
+	{ MV_IO_EXPANDER_JUMPER1_EEPROM_ENABLED, 6,		 2,	 0},
+	{ MV_IO_EXPANDER_JUMPER2,		 7,		 2,	 0},
+		/* 3rd IO Expander Register*/
+	{ MV_IO_EXPANDER_EXT_PHY_SMI_EN,	 0,		 2,	 1},
+	{ MV_IO_EXPANDER_SFP1_TX_DIS,		 1,		 2,	 1},
+	{ MV_IO_EXPANDER_MAC0_RJ45_PORT_LED,	 2,		 2,	 1},
+	{ MV_IO_EXPANDER_PON_PORT_LED,		 3,		 2,	 1},
+	{ MV_IO_EXPANDER_MAC1_SFP_PORT_LED,	 4,		 2,	 1},
+	{ MV_IO_EXPANDER_MAC1_RJ45_PORT_LED,	 5,		 2,	 1},
+	{ MV_IO_EXPANDER_INTEG_PHY_PORTS_LED,	 6,		 2,	 1},
 };
 
 /*******************************************************************************
@@ -163,25 +213,25 @@ MV_BOARD_INFO avanta_lp_fpga_board_info = {
 };
 
 /*******************************************************************************
- * AvantaLP DB-88F6600 board */
+ * AvantaLP DB-88F6660 board */
 /*******************************************************************************/
 
-MV_BOARD_TWSI_INFO db88f6600InfoBoardTwsiDev[] = {
-	/* {{MV_BOARD_DEV_CLASS devClass, MV_U8 twsiDevAddr, MV_U8 twsiDevAddrType}} */
-	{ BOARD_DEV_TWSI_SATR,	      0x4C,	   ADDR7_BIT				    },
-	{ BOARD_DEV_TWSI_SATR,	      0x4D,	   ADDR7_BIT				    },
-	{ BOARD_DEV_TWSI_EEPROM,      0x54,	   ADDR7_BIT				    },
-	{ BOARD_DEV_TWSI_IO_EXPANDER, 0x21,	   ADDR7_BIT				    },
-	{ BOARD_DEV_TWSI_IO_EXPANDER, 0x22,	   ADDR7_BIT				    },  /*omriii : re-verify that 0x22 is also IO_EXPANDER for 6600 board */
-	{ BOARD_DEV_TWSI_IO_EXPANDER, 0x24,	   ADDR7_BIT				    },  /*omriii : re-verify that 0x22 is also IO_EXPANDER for 6600 board */
+MV_BOARD_TWSI_INFO db88f6660InfoBoardTwsiDev[] = {
+	/* {{MV_BOARD_DEV_CLASS devClass, MV_U8 devClassId,  MV_U8 twsiDevAddr, MV_U8 twsiDevAddrType}} */
+	{ BOARD_DEV_TWSI_SATR,		0,	0x4C,	   ADDR7_BIT	},
+	{ BOARD_DEV_TWSI_SATR,		1,	0x4D,	   ADDR7_BIT	},
+	{ BOARD_DEV_TWSI_EEPROM,	0,	0x54,	   ADDR7_BIT	},
+	{ BOARD_DEV_TWSI_IO_EXPANDER,	0,	0x21,	   ADDR7_BIT	},
+	{ BOARD_DEV_TWSI_IO_EXPANDER,	1,	0x22,	   ADDR7_BIT	},
+	{ BOARD_DEV_TWSI_IO_EXPANDER,	2,	0x24,	   ADDR7_BIT	},
 };
-MV_BOARD_MAC_INFO db88f6600InfoBoardMacInfo[] = {
+MV_BOARD_MAC_INFO db88f6660InfoBoardMacInfo[] = {
 	/* {{MV_BOARD_MAC_SPEED boardMacSpeed, MV_U8 boardEthSmiAddr}} */
 	{ BOARD_MAC_SPEED_AUTO, 0x8									},
 	{ BOARD_MAC_SPEED_AUTO, 0x9									},
 	{ N_A,			N_A									}
 };
-MV_BOARD_MPP_TYPE_INFO db88f6600InfoBoardModTypeInfo[] = {
+MV_BOARD_MPP_TYPE_INFO db88f6660InfoBoardModTypeInfo[] = {
 	{
 		.boardMppTdm = MV_BOARD_AUTO,
 		.ethSataComplexOpt = DB_88F6660_ETH_DEFAULT,
@@ -189,26 +239,26 @@ MV_BOARD_MPP_TYPE_INFO db88f6600InfoBoardModTypeInfo[] = {
 	}
 };
 
-MV_BOARD_MPP_GROUP_INFO db88f6600InfoBoardMppGroupConfig[] = {
+MV_BOARD_MPP_GROUP_INFO db88f6660InfoBoardMppGroupConfig[] = {
 	{ {
-		  DB_88F6600_GROUP_0_TYPE,
-		  DB_88F6600_GROUP_1_TYPE,
-		  DB_88F6600_GROUP_2_TYPE,
-		  DB_88F6600_GROUP_3_TYPE,
-		  DB_88F6600_GROUP_4_TYPE,
-		  DB_88F6600_GROUP_5_TYPE,
-		  DB_88F6600_GROUP_6_TYPE,
-		  DB_88F6600_GROUP_7_TYPE,
-		  DB_88F6600_GROUP_8_TYPE,
+		  DB_88F6660_GROUP_0_TYPE,
+		  DB_88F6660_GROUP_1_TYPE,
+		  DB_88F6660_GROUP_2_TYPE,
+		  DB_88F6660_GROUP_3_TYPE,
+		  DB_88F6660_GROUP_4_TYPE,
+		  DB_88F6660_GROUP_5_TYPE,
+		  DB_88F6660_GROUP_6_TYPE,
+		  DB_88F6660_GROUP_7_TYPE,
+		  DB_88F6660_GROUP_8_TYPE,
 	  } }
 };
 
-MV_BOARD_INFO db88f6600_board_info = {
-	.boardName			= "DB-88F6600",
-	.numBoardMppTypeValue		= ARRSZ(db88f6600InfoBoardModTypeInfo),
-	.pBoardModTypeValue		= db88f6600InfoBoardModTypeInfo,
-	.numBoardMppGroupValue		= ARRSZ(db88f6600InfoBoardMppGroupConfig),
-	.pBoardMppGroupValue		= db88f6600InfoBoardMppGroupConfig,
+MV_BOARD_INFO db88f6660_board_info = {
+	.boardName			= "DB-88F6660",
+	.numBoardMppTypeValue		= ARRSZ(db88f6660InfoBoardModTypeInfo),
+	.pBoardModTypeValue		= db88f6660InfoBoardModTypeInfo,
+	.numBoardMppGroupValue		= ARRSZ(db88f6660InfoBoardMppGroupConfig),
+	.pBoardMppGroupValue		= db88f6660InfoBoardMppGroupConfig,
 	.numBoardSerdesConfigValue	= 0,
 	.pBoardSerdesConfigValue	= 0,
 	.intsGppMaskLow			= 0,
@@ -216,14 +266,12 @@ MV_BOARD_INFO db88f6600_board_info = {
 	.intsGppMaskHigh		= 0,
 	.numBoardDeviceIf		= 0,
 	.pDevCsInfo			= 0,
-	.numBoardSarInfo		= ARRSZ(boardSarInfo),
-	.pBoardSarInfo			= boardSarInfo,
-	.numBoardConfigTypes		= ARRSZ(boardConfigTypesInfo),
-	.pBoardConfigTypes		= boardConfigTypesInfo,
-	.numBoardTwsiDev		= ARRSZ(db88f6600InfoBoardTwsiDev),
-	.pBoardTwsiDev			= db88f6600InfoBoardTwsiDev,
-	.numBoardMacInfo		= ARRSZ(db88f6600InfoBoardMacInfo),
-	.pBoardMacInfo			= db88f6600InfoBoardMacInfo,
+	.numBoardIoExpanderInfo		= ARRSZ(db88f6660InfoBoardIOExpanderInfo),
+	.pBoardIoExpanderInfo		= db88f6660InfoBoardIOExpanderInfo,
+	.numBoardTwsiDev		= ARRSZ(db88f6660InfoBoardTwsiDev),
+	.pBoardTwsiDev			= db88f6660InfoBoardTwsiDev,
+	.numBoardMacInfo		= ARRSZ(db88f6660InfoBoardMacInfo),
+	.pBoardMacInfo			= db88f6660InfoBoardMacInfo,
 	.numBoardGppInfo		= 0,
 	.pBoardGppInfo			= 0,
 	.activeLedsNumber		= 0,
@@ -235,15 +283,15 @@ MV_BOARD_INFO db88f6600_board_info = {
 	.pmuPwrUpDelay			= 80000,
 
 	/* GPP values */
-	.gppOutEnValLow			= DB_88F6600_GPP_OUT_ENA_LOW,
-	.gppOutEnValMid			= DB_88F6600_GPP_OUT_ENA_MID,
-	.gppOutEnValHigh		= DB_88F6600_GPP_OUT_ENA_HIGH,
-	.gppOutValLow			= DB_88F6600_GPP_OUT_VAL_LOW,
-	.gppOutValMid			= DB_88F6600_GPP_OUT_VAL_MID,
-	.gppOutValHigh			= DB_88F6600_GPP_OUT_VAL_HIGH,
-	.gppPolarityValLow		= DB_88F6600_GPP_POL_LOW,
-	.gppPolarityValMid		= DB_88F6600_GPP_POL_MID,
-	.gppPolarityValHigh		= DB_88F6600_GPP_POL_HIGH,
+	.gppOutEnValLow			= DB_88F6660_GPP_OUT_ENA_LOW,
+	.gppOutEnValMid			= DB_88F6660_GPP_OUT_ENA_MID,
+	.gppOutEnValHigh		= DB_88F6660_GPP_OUT_ENA_HIGH,
+	.gppOutValLow			= DB_88F6660_GPP_OUT_VAL_LOW,
+	.gppOutValMid			= DB_88F6660_GPP_OUT_VAL_MID,
+	.gppOutValHigh			= DB_88F6660_GPP_OUT_VAL_HIGH,
+	.gppPolarityValLow		= DB_88F6660_GPP_POL_LOW,
+	.gppPolarityValMid		= DB_88F6660_GPP_POL_MID,
+	.gppPolarityValHigh		= DB_88F6660_GPP_POL_HIGH,
 
 	/* TDM */
 	.numBoardTdmInfo		= {},
@@ -396,6 +444,6 @@ MV_BOARD_INFO avanta_lp_customer_board_info = {
  * All supported avanta boards
  */
 MV_BOARD_INFO *boardInfoTbl[] = {
-	&db88f6600_board_info,
+	&db88f6660_board_info,
 	&avanta_lp_fpga_board_info,
-};
\ No newline at end of file
+};
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.h b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.h
index ba1ff7a..f7c4b89 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvSpec.h
@@ -110,27 +110,27 @@
  */
 
 /* default MPP Types */
-#define DB_88F6600_GROUP_0_TYPE         NAND_BOOT_V2
-#define DB_88F6600_GROUP_1_TYPE         NAND_BOOT_V2
-#define DB_88F6600_GROUP_2_TYPE         SLIC_LANTIQ_UNIT
-#define DB_88F6600_GROUP_3_TYPE         GE1_UNIT
-#define DB_88F6600_GROUP_4_TYPE         GE1_CPU_SMI_CTRL_TDM_LQ_UNIT
-#define DB_88F6600_GROUP_5_TYPE         SWITCH_P4_PON_TX_FAULT
-#define DB_88F6600_GROUP_6_TYPE         SWITCH_P4
-#define DB_88F6600_GROUP_7_TYPE         SWITCH_P4_LED_MATRIX
-#define DB_88F6600_GROUP_8_TYPE         LED_MATRIX_PTP
+#define DB_88F6660_GROUP_0_TYPE         NAND_BOOT_V2
+#define DB_88F6660_GROUP_1_TYPE         NAND_BOOT_V2
+#define DB_88F6660_GROUP_2_TYPE         SLIC_LANTIQ_UNIT
+#define DB_88F6660_GROUP_3_TYPE         GE1_UNIT
+#define DB_88F6660_GROUP_4_TYPE         GE1_CPU_SMI_CTRL_TDM_LQ_UNIT
+#define DB_88F6660_GROUP_5_TYPE         SWITCH_P4_PON_TX_FAULT
+#define DB_88F6660_GROUP_6_TYPE         SWITCH_P4
+#define DB_88F6660_GROUP_7_TYPE         SWITCH_P4_LED_MATRIX
+#define DB_88F6660_GROUP_8_TYPE         LED_MATRIX_PTP
 
 #define DB_88F6660_ETH_DEFAULT (MV_ETH_COMPLEX_GE_MAC0_SW_P6 | MV_ETH_COMPLEX_GE_MAC1_RGMII1 | MV_ETH_COMPLEX_SW_P0_QUAD_PHY_P0 | MV_ETH_COMPLEX_SW_P3_QUAD_PHY_P3 | MV_ETH_COMPLEX_SW_P4_RGMII1)
 
-#define DB_88F6600_GPP_OUT_ENA_LOW      0x0
-#define DB_88F6600_GPP_OUT_ENA_MID      0x0
-#define DB_88F6600_GPP_OUT_ENA_HIGH     0x0
-#define DB_88F6600_GPP_OUT_VAL_LOW      0x0
-#define DB_88F6600_GPP_OUT_VAL_MID      0x0
-#define DB_88F6600_GPP_OUT_VAL_HIGH     0x0
-#define DB_88F6600_GPP_POL_LOW          0x0
-#define DB_88F6600_GPP_POL_MID          0x0
-#define DB_88F6600_GPP_POL_HIGH         0x0
+#define DB_88F6660_GPP_OUT_ENA_LOW      0x0
+#define DB_88F6660_GPP_OUT_ENA_MID      0x0
+#define DB_88F6660_GPP_OUT_ENA_HIGH     0x0
+#define DB_88F6660_GPP_OUT_VAL_LOW      0x0
+#define DB_88F6660_GPP_OUT_VAL_MID      0x0
+#define DB_88F6660_GPP_OUT_VAL_HIGH     0x0
+#define DB_88F6660_GPP_POL_LOW          0x0
+#define DB_88F6660_GPP_POL_MID          0x0
+#define DB_88F6660_GPP_POL_HIGH         0x0
 
 /*******************************************************************************
 * AvanataLP customer board
@@ -157,4 +157,4 @@
 
 #endif  /* MV_ASMLANGUAGE */
 
-#endif  /* __INCmvBoardEnvSpech */
\ No newline at end of file
+#endif  /* __INCmvBoardEnvSpech */
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
index 9e840c4..b23a86a 100755
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
@@ -221,7 +221,7 @@ MV_STATUS mvCtrlSatRWrite(MV_SATR_TYPE_ID satrWriteField, MV_SATR_TYPE_ID satrRe
 	MV_U32 readVal, tmpVal;
 
 	if ((satrReadField < MV_SATR_READ_MAX_OPTION) && (satrWriteField < MV_SATR_WRITE_MAX_OPTION)) {
-		if ( mvBoardSarInfoGet(satrWriteField, &sarInfo) && sarInfo.isActiveForBoard[mvBoardIdGet()]) {
+		if ( mvBoardSarInfoGet(satrWriteField, &sarInfo)) {
 
 			/* read */
 			readVal = mvBoardTwsiGet(BOARD_DEV_TWSI_SATR, sarInfo.regNum, 0);
@@ -334,7 +334,7 @@ MV_VOID mvCtrlSMISet(MV_SMI_CTRL smiCtrl)
 MV_STATUS mvCtrlCpuDdrL2FreqGet(MV_FREQ_MODE *freqMode)
 {
 	MV_FREQ_MODE freqTable[] = MV_SAR_FREQ_MODES;
-	MV_U32 freqModeSatRValue = mvCtrlSatRRead(MV_SATR_CPU_FREQ);
+	MV_U32 freqModeSatRValue = mvCtrlSatRRead(MV_SATR_CPU_DDR_L2_FREQ);
 	if (MV_ERROR != freqModeSatRValue) {
 		*freqMode = freqTable[freqModeSatRValue];
 		return MV_OK;
@@ -369,9 +369,10 @@ MV_U32 mvCtrlConfigGet(MV_CONFIG_TYPE_ID configField)
 * mvCtrlSatrInit
 *
 * DESCRIPTION: Initialize S@R configuration
-*               1. initialize all S@R fields with 0xFF
-*               2. read boardID and according to ID, read relevant S@R fields(using TWSI/EEPROM)
-*	        **from this point, all S@R reads will be done using mvCtrlSatRRead/Write functions**
+*               1. initialize all S@R and board configuration fields with 0xFF
+*               2. read relevant S@R fields (direct memory access)
+*               3. read relevant board configuration (using TWSI/EEPROM access)
+*	        **from this point, all reads from S@R & board config will use mvCtrlSatRRead/Write functions**
 *
 * INPUT:  None
 *
@@ -382,46 +383,106 @@ MV_U32 mvCtrlConfigGet(MV_CONFIG_TYPE_ID configField)
 *******************************************************************************/
 void mvCtrlSatrInit(void)
 {
-	MV_U8 tempVal[2];
+	MV_U8 tempVal[MV_IO_EXP_MAX_REGS];
 	MV_BOARD_SAR_INFO sarInfo;
 	MV_BOARD_CONFIG_TYPE_INFO confInfo;
 	int i = 0;
 
 	/* initialize all S@R & Board configuration fields to -1 (MV_ERROR) */
-	memset(&satrOptionsConfig, 0xff, (sizeof(MV_U32) * MV_SATR_READ_MAX_OPTION) );
-
-	for (i = 0; i < MV_CONFIG_TYPE_MAX_OPTION; i++)
-		boardOptionsConfig[i] = MV_ERROR;
-
-	/* detect board ID to determine which S@R fields are relevant */
-	/* omriii : add boardID=mvBoardIdGet(); ??? */
+	memset(&satrOptionsConfig, 0xff, sizeof(MV_U32) * MV_SATR_READ_MAX_OPTION );
+	memset(&boardOptionsConfig, 0xff, sizeof(MV_U32) * MV_CONFIG_TYPE_MAX_OPTION );
 
 	/* Read Sample @ Reset configuration, memory access read : */
 	for (i = 0; i < MV_SATR_READ_MAX_OPTION; i++) {
-		if ( mvBoardSarInfoGet(i, &sarInfo) && sarInfo.isActiveForBoard[mvBoardIdGet()]) {
+		if ( mvBoardSarInfoGet(i, &sarInfo) ) {
 			tempVal[0] = MV_REG_READ(MPP_SAMPLE_AT_RESET(sarInfo.regNum));
 			satrOptionsConfig[sarInfo.sarid] = ((tempVal[0]  & (sarInfo.mask)) >> sarInfo.offset);
 		}
 	}
 
-	/*Read rest of Board Configuration, EEPROM / Deep Switch access read : */
-	tempVal[0] = mvBoardTwsiGet(BOARD_DEV_TWSI_EEPROM, 0, 0);               /* EEPROM Reg#0 */
-	tempVal[1] = mvBoardTwsiGet(BOARD_DEV_TWSI_EEPROM, 0, 1);               /* EEPROM Reg#1 */
-	if (((MV_8)MV_ERROR == (MV_8)tempVal[0]) || ((MV_8)MV_ERROR == (MV_8)tempVal[1]) ) {
-		/* EEPROM is not valid , data is jumpered to deep switch- read from there */
-		tempVal[0] = mvBoardTwsiGet(BOARD_DEV_TWSI_IO_EXPANDER, 0, 0);  /* Deep Switch Reg#0 */
-		tempVal[1] = mvBoardTwsiGet(BOARD_DEV_TWSI_IO_EXPANDER, 0, 1);  /* Deep Switch Reg#1 */
-		/* omriii : verify reads from BOARD_DEV_TWSI_IO_EXPANDER are correct */
+	/*Read rest of Board Configuration, EEPROM / Dip Switch access read : */
+	if (mvCtrlBoardConfigGet((MV_U8**)&tempVal)) {
+		/* Save values Locally in tempVal[3] */
+		for (i = 0; i < MV_CONFIG_TYPE_MAX_OPTION; i++) {
+			if ( mvBoardConfigTypeGet(i, &confInfo) ) {
+				/* each Expander conatins 2 registers */
+				tempRegNum= confInfo.expanderNum * 2 + confInfo.regNum;
+				boardOptionsConfig[confInfo.configid] = ((tempVal[tempRegNum] & (confInfo.mask)) >> confInfo.offset);
+			}
+		}
+	}
+}
+
+/*******************************************************************************
+* mvCtrlBoardConfigGet - read Board Configuration, from EEPROM / Dip Switch
+*
+* DESCRIPTION:
+*       This function reads all board configuration from EEPROM / Dip Switch:
+*	1. read the EEPROM enable jumper, and read from configured device
+*	2. read first 2 registers for all boards
+*	3. read specific registers for specific boards
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_BOOL :  MV_TRUE if EEPROM enabled, else return MV_FALSE.
+*
+*******************************************************************************/
+MV_STATUS mvCtrlBoardConfigGet(MV_U8 **tempVal)
+{
+	MV_U32 boardId = mvBoardIdGet();
+	MV_BOOL isEepromEnabled = mvCtrlIsEepromEnabled();
+	MV_BOARD_TWSI_CLASS twsiClass= (isEepromEnabled ? BOARD_DEV_TWSI_EEPROM : BOARD_DEV_TWSI_IO_EXPANDER);
+
+	(*tempVal)[0] = mvBoardTwsiGet(twsiClass, 0, 0);		/* EEPROM/Dip Switch Reg#0 */
+	(*tempVal)[1] = mvBoardTwsiGet(twsiClass, 0, 1);		/* EEPROM/Dip Switch Reg#1 */
+
+	if (boardId == DB_6660_ID) { /* DB-6660 has another register for board configuration */
+		if (isEepromEnabled)
+			(*tempVal)[2] = mvBoardTwsiGet(BOARD_DEV_TWSI_EEPROM, 0, 2);		/* EEPROM Reg#2 */
+		else
+			(*tempVal)[2] = mvBoardTwsiGet(BOARD_DEV_TWSI_IO_EXPANDER, 1, 0);	/* Dip Switch Reg#1 */
 	}
 
-	if (((MV_8)MV_ERROR == (MV_8)tempVal[0]) || ((MV_8)MV_ERROR == (MV_8)tempVal[1]))
-		/* Deep Switch reading failed - omriii : use defaults (which iszeros for all fields) ??? */
-		tempVal[0] = tempVal[1] = 0x0;
+	/* verify that all TWSI reads were successfull */
+	if (((MV_8)MV_ERROR == (*tempVal)[0]) || ((MV_8)MV_ERROR == (*tempVal)[1]))
+		return MV_ERROR;
+
+	if ((boardId == DB_6660_ID) && ((MV_8)MV_ERROR == (*tempVal)[2]))
+		return MV_ERROR;
+
+	return MV_OK;
+}
 
-	/* Save values Locally */
-	for (i = 0; i < MV_CONFIG_TYPE_MAX_OPTION; i++)
-		if ( mvBoardConfigTypeGet(i, &confInfo) && confInfo.isActiveForBoard[mvBoardIdGet()])
-			boardOptionsConfig[confInfo.configid] = ((tempVal[confInfo.regNum] & (confInfo.mask)) >> confInfo.offset);
+/*******************************************************************************
+* mvCtrlIsEepromEnabled - read jumper and verify if EEPROM is enabled
+*
+* DESCRIPTION:
+*       This function returns MV_TRUE if board configuration jumper is set to EEPROM.
+*
+* INPUT:
+*       None.
+*
+* OUTPUT:
+*       None.
+*
+* RETURN:
+*       MV_BOOL :  MV_TRUE if EEPROM enabled, else return MV_FALSE.
+*
+*******************************************************************************/
+MV_BOOL mvCtrlIsEepromEnabled()
+{
+	MV_BOARD_IO_EXPANDER_TYPE_INFO ioInfo;
+
+	if(mvBoardIoExpanderTypeGet(MV_IO_EXPANDER_JUMPER1_EEPROM_ENABLED ,&ioInfo))
+	{
+		return (mvBoardIoExpValGet(ioInfo) == 0x1);
+	}
+	else return MV_FALSE;
 }
 
 /*******************************************************************************
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h
index 20a2f2f..72c7929 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h
@@ -75,7 +75,7 @@
 
 typedef enum _mvSatRTypeID {
 	// "Bios" Device
-	MV_SATR_CPU_FREQ,
+	MV_SATR_CPU_DDR_L2_FREQ,
 	MV_SATR_CORE_CLK_SELECT,
 	MV_SATR_CPU1_ENABLE,
 	MV_SATR_SSCG_DISABLE,
@@ -116,9 +116,37 @@ typedef enum _mvConfigTypeID {
 	MV_CONFIG_LANE2,
 	MV_CONFIG_LANE3,
 	MV_CONFIG_DEVICE_BUS_MODULE,
+	MV_CONFIG_SLIC_TDM_DEVICE,
 	MV_CONFIG_TYPE_MAX_OPTION
 } MV_CONFIG_TYPE_ID;
 
+typedef enum _mvIoExpanderTypeID {
+	MV_IO_EXPANDER_SFP0_TX_DIS,
+	MV_IO_EXPANDER_SFP0_PRSNT,
+	MV_IO_EXPANDER_SFP0_TX_FAULT,
+	MV_IO_EXPANDER_SFP0_LOS,
+	MV_IO_EXPANDER_SFP1_PRSNT,
+	MV_IO_EXPANDER_SFP1_TX_FAULT,
+	MV_IO_EXPANDER_SFP1_LOS,
+	MV_IO_EXPANDER_SFP1_TX_DIS,
+	MV_IO_EXPANDER_USB_VBUS,
+	MV_IO_EXPANDER_MAC0_RJ45_PORT_LED,
+	MV_IO_EXPANDER_MAC0_SFP_PORT_LED,
+	MV_IO_EXPANDER_MAC1_RJ45_PORT_LED,
+	MV_IO_EXPANDER_MAC1_SFP_PORT_LED,
+	MV_IO_EXPANDER_PON_PORT_LED,
+	MV_IO_EXPANDER_SD_STATUS,
+	MV_IO_EXPANDER_SD_WRITE_PROTECT,
+	MV_IO_EXPANDER_JUMPER1_EEPROM_ENABLED,
+	MV_IO_EXPANDER_JUMPER2,
+	MV_IO_EXPANDER_JUMPER3,
+	MV_IO_EXPANDER_EXT_PHY_SMI_EN,
+	MV_IO_EXPANDER_SPI1_CS_MSB0,
+	MV_IO_EXPANDER_SPI1_CS_MSB1,
+	MV_IO_EXPANDER_INTEG_PHY_PORTS_LED,
+	MV_IO_EXPANDER_USB_SUPER_SPEED,
+} MV_IO_EXPANDER_TYPE_ID;
+
 /* This enumerator describes the possible SMI control options */
 typedef enum _mvSMIctrl {
 	CPU_SMI_CTRL,
@@ -241,7 +269,8 @@ MV_U32 mvCtrlGetCpuNum(MV_VOID);
 MV_U32 mvCtrlGetQuadNum(MV_VOID);
 MV_STATUS mvCtrlUpdatePexId(MV_VOID);
 MV_BOOL mvCtrlIsValidSatR(MV_VOID);
-
+MV_BOOL mvCtrlIsEepromEnabled(MV_VOID);
+MV_STATUS mvCtrlBoardConfigGet(MV_U8 **tempVal);
 MV_STATUS mvCtrlEnvInit(MV_VOID);
 MV_U32    mvCtrlMppRegGet(MV_U32 mppGroup);
 
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h
index 3749fee..aca6751 100755
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h
@@ -159,6 +159,8 @@ extern "C" {
 #define MV_GPP_MAX_GROUP                        3       /* group == configuration register? */
 #define MV_CNTMR_MAX_COUNTER            17              /* 4 global + 1 global WD + 2 per CPU + 4 CPU WD*/
 
+#define MV_IO_EXP_MAX_REGS			3
+
 #define MV_UART_MAX_CHAN                        4
 
 #define MV_XOR_MAX_UNIT                         2       /* XOR unit == XOR engine */
-- 
1.7.5.4

