From d7576fd12b22ccd2d3d22dba788116a8b1c97c09 Mon Sep 17 00:00:00 2001
From: Shadi Ammouri <shadi@marvell.com>
Date: Sun, 8 Dec 2013 09:16:28 +0200
Subject: [PATCH 1185/1825] a380: irq: Align irq.c with ALP implementation

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit cca8d2005ca69da3d9cca22ffd5f74fc306607b6

	Align irq.c contents for A380 with that of ALP. And add
	support for ppi interrupts (used by Neta drivers).

Change-Id: If1cc9ae6b7a2f845a1028b30177096b56f6ee0ca
Signed-off-by: Shadi Ammouri <shadi@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/4621
Tested-by: Igor Patrik <igorp@marvell.com>
Reviewed-by: Igor Patrik <igorp@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-armada38x/include/mach/irqs.h |    2 +-
 arch/arm/mach-armada38x/irq.c               |  327 +++++++++++++++++++--------
 2 files changed, 235 insertions(+), 94 deletions(-)

diff --git a/arch/arm/mach-armada38x/include/mach/irqs.h b/arch/arm/mach-armada38x/include/mach/irqs.h
index a8e0f2f..22db20e 100644
--- a/arch/arm/mach-armada38x/include/mach/irqs.h
+++ b/arch/arm/mach-armada38x/include/mach/irqs.h
@@ -245,7 +245,7 @@
 /*
  * Total number of interrupts
  */
-#define NR_IRQS			(IRQ_START_PRIV_ERROR + NR_IRQS_PRIV_ERROR)
+#define NR_IRQS			(IRQ_START_PRIV_LOCAL_SUM + NR_IRQS_PRIV_LOCAL_SUM)
 #define NR_GPIO_IRQS		NR_IRQS_GLOBAL_GPIO
 
 /*
diff --git a/arch/arm/mach-armada38x/irq.c b/arch/arm/mach-armada38x/irq.c
index b2fcfe9..b0d76ef 100644
--- a/arch/arm/mach-armada38x/irq.c
+++ b/arch/arm/mach-armada38x/irq.c
@@ -18,25 +18,35 @@
 #include "ca9x2.h"
 #include "mvOs.h"
 #include "gpp/mvGppRegs.h"
+#include "cpu/mvCpu.h"
 
-#define SOC_PPI_CAUSE			0x21880
-#define SOC_PPI_MASK_SET		0x218b8
-#define SOC_PPI_MASK_CLEAR		0x218bc
+/* CPU-shared registers  */
+#define SOC_LOCAL_SUM_CAUSE		0x20260
+#define SOC_LOCAL_SUM_CAUSE_BITS	0xffc71111
+
+/*
+ * CPU-private registers
+ */
+#define SOC_PPI_CAUSE(cpu)		(MV_CPUIF_REGS_BASE(cpu) | (0x80))
+#define SOC_PPI_MASK_SET(cpu)		(MV_CPUIF_REGS_BASE(cpu) | CPU_INT_SET_MASK_OFFS)
+#define SOC_PPI_MASK_CLEAR(cpu)		(MV_CPUIF_REGS_BASE(cpu) | CPU_INT_CLEAR_MASK_OFFS)
 #define SOC_PPI_CAUSE_BITS		0x1fffffff
 
+#define SOC_LOCAL_SUM_MASK		0x218c4
+
 static DEFINE_RAW_SPINLOCK(irq_controller_lock);
 
-/*
+/*******************************************************************************
  * Global GPIO interrupt handling
  */
 static void a38x_gpio_irq_mask(struct irq_data *d)
 {
 	u32 irq = d->irq, bitmask, reg;
 
-	if (irq < IRQ_START_GLOBAL_GPIO ||
-	    irq >= IRQ_START_GLOBAL_GPIO + NR_IRQS_GLOBAL_GPIO) {
+	if (irq <  IRQ_START_GLOBAL_GPIO ||
+			irq >= IRQ_START_GLOBAL_GPIO + NR_IRQS_GLOBAL_GPIO) {
 		WARN(1, "Error: wrong GPIO irq %d\n", irq);
-		return;		/* wrong  */
+		return; /* wrong  */
 	}
 
 	bitmask = 1 << (irq & 0x1F);
@@ -48,10 +58,10 @@ static void a38x_gpio_irq_unmask(struct irq_data *d)
 {
 	u32 irq = d->irq, bitmask, reg;
 
-	if (irq < IRQ_START_GLOBAL_GPIO ||
+	if (irq <  IRQ_START_GLOBAL_GPIO ||
 	    irq >= IRQ_START_GLOBAL_GPIO + NR_IRQS_GLOBAL_GPIO) {
 		WARN(1, "Error: wrong GPIO irq %d\n", irq);
-		return;		/* wrong  */
+		return; /* wrong  */
 	}
 
 	bitmask = 1 << (irq & 0x1F);
@@ -60,23 +70,22 @@ static void a38x_gpio_irq_unmask(struct irq_data *d)
 }
 
 static struct irq_chip a38x_irq_chip = {
-	.name = "a38x_gpio_irq",
-	.irq_mask = a38x_gpio_irq_mask,
-	.irq_mask_ack = a38x_gpio_irq_mask,
-	.irq_unmask = a38x_gpio_irq_unmask,
-	.irq_disable = a38x_gpio_irq_mask,
-	.irq_enable = a38x_gpio_irq_unmask,
+	.name		= "a38x_gpio_irq",
+	.irq_mask	= a38x_gpio_irq_mask,
+	.irq_mask_ack	= a38x_gpio_irq_mask,
+	.irq_unmask	= a38x_gpio_irq_unmask,
+	.irq_disable	= a38x_gpio_irq_mask,
+	.irq_enable	= a38x_gpio_irq_unmask,
 };
 
 /*
  * gpio_cascade_irq is in [85:88] or [90:94]
  */
-static void a38x_gpio_cascade_irq_handler(unsigned int gpio_cascade_irq,
-					  struct irq_desc *desc)
+static void a38x_gpio_cascade_irq_handler(u32 gpio_cascade_irq,
+					 struct irq_desc *desc)
 {
 	struct irq_chip *chip = irq_desc_get_chip(desc);
-	u32 bit, n, gpio_group, irq;
-	unsigned long cause, mask;
+	u32 bit, n, gpio_group, irq, cause, mask;
 
 	chained_irq_enter(chip, desc);
 
@@ -118,153 +127,285 @@ static void __init a38x_cascade_irq_gpio_global(void)
 		set_irq_flags(irq, IRQF_VALID);
 	}
 
-	irq_set_chained_handler(IRQ_GLOBAL_GPIO_0_7,
-				a38x_gpio_cascade_irq_handler);
-	irq_set_chained_handler(IRQ_GLOBAL_GPIO_8_15,
-				a38x_gpio_cascade_irq_handler);
-	irq_set_chained_handler(IRQ_GLOBAL_GPIO_16_23,
-				a38x_gpio_cascade_irq_handler);
-	irq_set_chained_handler(IRQ_GLOBAL_GPIO_24_31,
-				a38x_gpio_cascade_irq_handler);
-	irq_set_chained_handler(IRQ_GLOBAL_GPIO_32_39,
-				a38x_gpio_cascade_irq_handler);
-	irq_set_chained_handler(IRQ_GLOBAL_GPIO_40_47,
-				a38x_gpio_cascade_irq_handler);
-	irq_set_chained_handler(IRQ_GLOBAL_GPIO_48_55,
-				a38x_gpio_cascade_irq_handler);
-	irq_set_chained_handler(IRQ_GLOBAL_GPIO_56_63,
-				a38x_gpio_cascade_irq_handler);
-	irq_set_chained_handler(IRQ_GLOBAL_GPIO_64_66,
-				a38x_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_GLOBAL_GPIO_0_7,   a38x_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_GLOBAL_GPIO_8_15,  a38x_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_GLOBAL_GPIO_16_23, a38x_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_GLOBAL_GPIO_24_31, a38x_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_GLOBAL_GPIO_32_39, a38x_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_GLOBAL_GPIO_40_47, a38x_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_GLOBAL_GPIO_48_55, a38x_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_GLOBAL_GPIO_56_63, a38x_gpio_cascade_irq_handler);
+	irq_set_chained_handler(IRQ_GLOBAL_GPIO_64_66, a38x_gpio_cascade_irq_handler);
 }
 
-/*
- * Handle SOC PPI (Private Peripheral Interrupts).
+/* Mask and Unmaks registers are the same in case of some interrupts.
+ * For example, Local Summary interrupts.
  */
-struct mpic_chip_regs {
-	unsigned long cause;
-	unsigned long mask;
-	unsigned long unmask;
+struct a38x_irq_chip_regs {
+	u32 cause;
+	u32 mask;
+	u32 unmask;
 };
 
-struct mpic_data {
+struct a38x_irq_chip_data {
 	int irq_base;
 	struct irq_domain *domain;
-	struct mpic_chip_regs regs;
+	struct a38x_irq_chip_regs regs;
+	u32 mask;
 };
 
-static struct mpic_data mpic_data = {
+/*******************************************************************************
+ * CPU-private Local Summary interrupts
+ */
+static struct a38x_irq_chip_data a38x_local_summary_chip_data = {
 	.regs = {
-		 .cause = INTER_REGS_VIRT_BASE + SOC_PPI_CAUSE,
-		 .mask = INTER_REGS_VIRT_BASE + SOC_PPI_MASK_SET,
-		 .unmask = INTER_REGS_VIRT_BASE + SOC_PPI_MASK_CLEAR,
-		 }
+		.cause	= INTER_REGS_VIRT_BASE + SOC_LOCAL_SUM_CAUSE,
+		.mask	= INTER_REGS_VIRT_BASE + SOC_LOCAL_SUM_MASK,
+		.unmask	= INTER_REGS_VIRT_BASE + SOC_LOCAL_SUM_MASK,
+	},
+	.mask = SOC_LOCAL_SUM_CAUSE_BITS,
 };
 
-static inline u_int
-mpic_hw_irq(struct mpic_data *mpic, u_int irq)
+static void a38x_local_summary_irq_mask(struct irq_data *d)
 {
-	return irq - mpic->irq_base;
+	u32 mask;
+	struct a38x_irq_chip_data *chd = irq_get_chip_data(d->irq);
+
+	/* To mask IRQ, set its bit to zero. */
+	raw_spin_lock(&irq_controller_lock);
+	mask = readl_relaxed(chd->regs.mask);
+	mask &= ~(1 << d->hwirq);
+	writel_relaxed(mask, chd->regs.mask);
+	raw_spin_unlock(&irq_controller_lock);
 }
 
-static void mpic_irq_mask(struct irq_data *d)
+static void a38x_local_summary_irq_unmask(struct irq_data *d)
 {
-	struct mpic_data *mpic = irq_get_chip_data(d->irq);
+	u32 mask;
+	struct a38x_irq_chip_data *chd = irq_get_chip_data(d->irq);
 
+	/* To unmask IRQ, set its bit to one. */
 	raw_spin_lock(&irq_controller_lock);
-	writel_relaxed(mpic_hw_irq(mpic, d->irq), mpic->regs.mask);
+	mask = readl_relaxed(chd->regs.unmask);
+	mask |= (1 << d->hwirq);
+	writel_relaxed(mask, chd->regs.unmask);
 	raw_spin_unlock(&irq_controller_lock);
 }
 
-static void mpic_irq_unmask(struct irq_data *d)
+
+static struct irq_chip a38x_local_summary_irq_chip = {
+	.irq_mask	= a38x_local_summary_irq_mask,
+	.irq_unmask	= a38x_local_summary_irq_unmask,
+};
+
+static void
+a38x_handle_cascade_irq_local_summary(u32 irq, struct irq_desc *desc)
 {
-	struct mpic_data *mpic = irq_get_chip_data(d->irq);
+	struct a38x_irq_chip_data *chd = &a38x_local_summary_chip_data;
+	u32 cause, virt_irq;
+
+	chained_irq_enter(irq_get_chip(irq), desc);
 
 	raw_spin_lock(&irq_controller_lock);
-	writel_relaxed(mpic_hw_irq(mpic, d->irq), mpic->regs.unmask);
+	cause = readl_relaxed(chd->regs.cause);
 	raw_spin_unlock(&irq_controller_lock);
+
+	/* leave only relevant cause bits */
+	cause &= chd->mask;
+	if (cause == 0) {
+		pr_warn("%s: Zero interrupt cause reg 0x%08x\n",
+			__func__, chd->regs.cause);
+		goto out; /* spurious irq ? */
+	}
+
+	virt_irq = ffs(cause) - 1 + chd->irq_base;
+	generic_handle_irq(virt_irq);
+
+ out:
+	chained_irq_exit(irq_get_chip(irq), desc);
+}
+
+static int
+a38x_local_sumary_irq_domain_map(struct irq_domain *d, u32 irq,
+				irq_hw_number_t hwirq)
+{
+	irq_set_chip_and_handler(irq,
+		&a38x_local_summary_irq_chip, handle_percpu_devid_irq);
+	irq_set_chip_data(irq, d->host_data);
+	set_irq_flags(irq, IRQF_VALID | IRQF_PROBE);
+	return 0;
 }
 
-static struct irq_chip mpic_chip = {
-	.irq_mask = mpic_irq_mask,
-	.irq_unmask = mpic_irq_unmask,
+static struct irq_domain_ops a38x_local_summary_irq_domain_ops = {
+	.map	= a38x_local_sumary_irq_domain_map,
 };
 
-static void mpic_handle_cascade_irq(unsigned int irq, struct irq_desc *desc)
+static void __init
+a38x_cascade_irq_local_summary(int chained_irq, int irq, int nr_irqs)
 {
-	struct mpic_data *mpic = &mpic_data;
-	struct irq_chip *chip = irq_get_chip(irq);
-	unsigned long cause;
+	struct a38x_irq_chip_data *chd = &a38x_local_summary_chip_data;
 
-	chained_irq_enter(chip, desc);
+	chd->irq_base = irq_alloc_descs(-1, irq, nr_irqs, 0);
+	if (IS_ERR_VALUE(chd->irq_base))
+		BUG();
+
+	chd->domain = irq_domain_add_legacy(NULL, nr_irqs, chd->irq_base,
+				    0, &a38x_local_summary_irq_domain_ops, chd);
+	WARN_ON(!chd->domain);
+	irq_set_chained_handler(chained_irq, a38x_handle_cascade_irq_local_summary);
+}
+
+/*******************************************************************************
+ * CPU-private Peripherals interrupts (PPI)
+ */
+static struct a38x_irq_chip_data a38x_ppi_chip_data_g0 = {
+	.regs = {
+		.cause	= INTER_REGS_VIRT_BASE + SOC_PPI_CAUSE(0),
+		.mask	= INTER_REGS_VIRT_BASE + SOC_PPI_MASK_SET(0),
+		.unmask	= INTER_REGS_VIRT_BASE + SOC_PPI_MASK_CLEAR(0),
+	},
+	.mask = SOC_PPI_CAUSE_BITS,
+};
+
+static struct a38x_irq_chip_data a38x_ppi_chip_data_g1 = {
+	.regs = {
+		.cause	= INTER_REGS_VIRT_BASE + SOC_PPI_CAUSE(1),
+		.mask	= INTER_REGS_VIRT_BASE + SOC_PPI_MASK_SET(1),
+		.unmask	= INTER_REGS_VIRT_BASE + SOC_PPI_MASK_CLEAR(1),
+	},
+	.mask = SOC_PPI_CAUSE_BITS,
+};
+
+static void a38x_ppi_irq_mask(struct irq_data *d)
+{
+	struct a38x_irq_chip_data *chd = irq_get_chip_data(d->irq);
 
 	raw_spin_lock(&irq_controller_lock);
-	cause = readl_relaxed(mpic->regs.cause);
+	writel_relaxed(d->hwirq, chd->regs.mask);
+	raw_spin_unlock(&irq_controller_lock);
+}
+
+static void a38x_ppi_irq_unmask(struct irq_data *d)
+{
+	struct a38x_irq_chip_data *chd = irq_get_chip_data(d->irq);
+
+	raw_spin_lock(&irq_controller_lock);
+	writel_relaxed(d->hwirq, chd->regs.unmask);
+	raw_spin_unlock(&irq_controller_lock);
+}
+
+static struct irq_chip a38x_ppi_irq_chip = {
+	.irq_mask	= a38x_ppi_irq_mask,
+	.irq_unmask	= a38x_ppi_irq_unmask,
+};
+
+static void a38x_ppi_handle_cascade_irq(u32 irq, struct irq_desc *desc)
+{
+	struct a38x_irq_chip_data *chd = irq_get_chip_data(IRQ_START_PRIV_SOC_PPI);
+	u32 cause, virt_irq;
+
+	chained_irq_enter(irq_get_chip(irq), desc);
+
+	raw_spin_lock(&irq_controller_lock);
+	cause = readl_relaxed(chd->regs.cause);
 	raw_spin_unlock(&irq_controller_lock);
 
 	/* leave only relevant cause bits */
-	cause &= SOC_PPI_CAUSE_BITS;
-	if (cause == 0)
-		goto out;	/* spurious irq ? */
+	cause &= chd->mask;
+	if (cause == 0) {
+		pr_warn("%s: Zero interrupt cause reg 0x%08x\n",
+			__func__, chd->regs.cause);
+		goto out; /* spurious irq ? */
+	}
 
-	irq = ffs(cause) - 1;
+	virt_irq = ffs(cause) - 1 + chd->irq_base;
+	generic_handle_irq(virt_irq);
 
-	generic_handle_irq(mpic->irq_base + irq);
+ out:
+	chained_irq_exit(irq_get_chip(irq), desc);
+}
 
-out:
-	chained_irq_exit(chip, desc);
+static int
+a38x_ppi_irq_domain_map(struct irq_domain *d, u32 irq, irq_hw_number_t hwirq)
+{
+	irq_set_status_flags(irq, IRQ_LEVEL);
+	irq_set_chip_data(irq, d->host_data);
+	irq_set_chip_and_handler(irq, &a38x_ppi_irq_chip, handle_level_irq);
+	set_irq_flags(irq, IRQF_VALID);
+
+	return 0;
 }
 
-static void __init a38x_cascade_irq_mpic(int chained_irq, int irq_start, int nr_irqs)
+static struct irq_domain_ops a38x_ppi_irq_domain_ops = {
+	.map	= a38x_ppi_irq_domain_map,
+};
+
+static void __init
+a38x_cascade_irq_ppi(int chained_irq, int irq, int nr_irqs)
 {
-	int irq;
-	struct mpic_data *mpic = &mpic_data;
+	struct a38x_irq_chip_data *chd;
 
-	mpic->irq_base = irq_alloc_descs(-1, irq_start, nr_irqs, 0);
-	if (IS_ERR_VALUE(mpic->irq_base))
+	if (whoAmI())
+		chd = &a38x_ppi_chip_data_g1;
+	else
+		chd = &a38x_ppi_chip_data_g0;
+
+	chd->irq_base = irq_alloc_descs(-1, irq, nr_irqs, 0);
+	if (IS_ERR_VALUE(chd->irq_base))
 		BUG();
 
-	for (irq = irq_start; irq < irq_start + nr_irqs; irq++) {
-		irq_set_status_flags(irq, IRQ_LEVEL);
-		irq_set_chip_and_handler(irq, &mpic_chip, handle_level_irq);
-		irq_set_chip_data(irq, &mpic_data);
-		set_irq_flags(irq, IRQF_VALID);
-	}
+	chd->domain = irq_domain_add_legacy(NULL, nr_irqs, chd->irq_base,
+					    0, &a38x_ppi_irq_domain_ops, chd);
+	WARN_ON(!chd->domain);
+	irq_set_chained_handler(chained_irq, a38x_ppi_handle_cascade_irq);
 
-	irq_set_chained_handler(chained_irq, mpic_handle_cascade_irq);
+	a38x_cascade_irq_local_summary(IRQ_PRIV_MP_LOCAL_SUMMARY,
+			      IRQ_START_PRIV_LOCAL_SUM, NR_IRQS_PRIV_LOCAL_SUM);
 }
 
+/*******************************************************************************
+ * CPU-private GPIO interrupts
+ */
 static void __init a38x_cascade_irq_gpio_private(void)
 {
 	/* TBD */
 }
 
+/*******************************************************************************
+ * Global MSI interrupts
+ */
 static void __init a38x_cascade_irq_msi_global(void)
 {
 	/* TBD */
 }
 
+/*******************************************************************************
+ * CPU-private MSI interrupts
+ */
 static void __init a38x_cascade_irq_msi_private(void)
 {
 	/* TBD */
 }
 
+/*******************************************************************************
+ * CPU-private error interrupts
+ */
 static void __init a38x_cascade_irq_errors(void)
 {
 	/* TBD */
 }
 
-/*
+/*******************************************************************************
  * Init GIC and MPIC and setup cascade irq
- * handling for GPIO, MSI and Error interrupts.
+ * handling for Local Summary, GPIO, MSI and Error interrupts.
  */
 void __init a38x_init_irq(void)
 {
-	gic_init(0, 29,
-		 (void __iomem *)(INTER_REGS_VIRT_BASE + A9_MPCORE_GIC_DIST),
-		 (void __iomem *)(INTER_REGS_VIRT_BASE + A9_MPCORE_GIC_CPU));
+	gic_init(0, 29, (void __iomem *)(INTER_REGS_VIRT_BASE + A9_MPCORE_GIC_DIST),
+			(void __iomem *)(INTER_REGS_VIRT_BASE + A9_MPCORE_GIC_CPU));
 
-	a38x_cascade_irq_mpic(IRQ_PRIV_MPIC_PPI_IRQ, IRQ_START_PRIV_SOC_PPI, NR_IRQS_PRIV_SOC_PPI);
+	a38x_cascade_irq_ppi(IRQ_PRIV_MPIC_PPI_IRQ,
+			    IRQ_START_PRIV_SOC_PPI, NR_IRQS_PRIV_SOC_PPI);
 
 	a38x_cascade_irq_gpio_global();
 	a38x_cascade_irq_gpio_private();
-- 
1.7.5.4

