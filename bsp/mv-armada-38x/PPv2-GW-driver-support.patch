From 654ad468dc56687b44b4f0963a13e7f4aa08fa37 Mon Sep 17 00:00:00 2001
From: Yoni Farhadian <yonif@marvell.com>
Date: Tue, 21 May 2013 13:37:46 +0300
Subject: [PATCH 0668/1825] PPv2: GW driver support

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 8d509af11da1d2828deea7e0a7f3f43ab211a426

Change-Id: I47a4736af5ffe71d1e4e17cd4d3cd9a8cd79fd13
Signed-off-by: Yoni Farhadian <yonif@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/1893
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Tested-by: Dmitri Epshtein <dima@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../avanta_lp_family/boardEnv/mvBoardEnvLib.h      |    2 +-
 arch/arm/mach-avantalp/core.c                      |   56 +----
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_gw_mgr.c      |    6 +-
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.c  |    2 +-
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c      |    4 +-
 .../mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h      |    1 -
 .../mv_drivers_lsp/mv_switch/mv_switch.c           |  238 ++++++++------------
 .../mv_drivers_lsp/mv_switch/mv_switch.h           |    4 +
 .../mv_drivers_lsp/mv_switch/mv_switch_sysfs.c     |    8 +-
 .../mv_hal/qd-dsdt-3.3/src/msapi/gtSysConfig.c     |    3 +
 .../mv_hal/qd-dsdt-3.3/src/platform/gtMiiSmiIf.c   |    2 +
 11 files changed, 121 insertions(+), 205 deletions(-)

diff --git a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h
index f379357..0f20fcb 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.h
@@ -78,7 +78,7 @@ extern "C" {
 #include "twsi/mvTwsi.h"
 
 #define BOARD_ETH_SWITCH_PORT_NUM       7
-#define BOARD_ETH_SWITCH_SMI_SCAN_MODE	2
+#define BOARD_ETH_SWITCH_SMI_SCAN_MODE	1	/* Use manual scanning mode */
 #define MV_BOARD_MAX_MPP                9       /* number of MPP conf registers */
 #define MV_BOARD_MAX_MPP_GROUPS         9
 #define MV_BOARD_MPP_GROUPS_MAX_TYPES   8
diff --git a/arch/arm/mach-avantalp/core.c b/arch/arm/mach-avantalp/core.c
index 8192683..1ccb3c3 100644
--- a/arch/arm/mach-avantalp/core.c
+++ b/arch/arm/mach-avantalp/core.c
@@ -67,7 +67,7 @@
 #include <linux/mv_pp2.h>
 #endif
 
-#if defined(CONFIG_MV_ETH_SWITCH)
+#if defined(CONFIG_MV_INCLUDE_SWITCH)
 #include <linux/mv_switch.h>
 #endif
 
@@ -663,50 +663,15 @@ static struct platform_device mv_pp2_ge3_plat = {
 
 static void __init eth_init(void)
 {
-#ifdef CONFIG_MV_ETH_NETA
-	struct netaSmpGroupStruct *netaSmpGroupStruct;
-	int cpu, found = 0, portMask;
-	netaSmpGroupStruct = kzalloc(sizeof(struct netaSmpGroupStruct), GFP_KERNEL);
-
-	if (!netaSmpGroupStruct) {
-		printk(KERN_ERR "no memory for private data\n");
-		return;
-	} else {
-#ifdef  CONFIG_SMP
-		netaSmpGroupStruct->cpuMask  = group_cpu_mask;
-#else
-		netaSmpGroupStruct->cpuMask  = 1;
-#endif
-		portMask  = (mvUnitMapIsMine(ETH0) == MV_TRUE);
-		portMask |= (mvUnitMapIsMine(ETH1) == MV_TRUE) << 1;
-		portMask |= (mvUnitMapIsMine(ETH2) == MV_TRUE) << 2;
-		portMask |= (mvUnitMapIsMine(ETH3) == MV_TRUE) << 3;
-
-		netaSmpGroupStruct->portMask = portMask;
-	}
-
-	for (cpu = 0; cpu < CONFIG_NR_CPUS; cpu++)
-		if (MV_BIT_CHECK(netaSmpGroupStruct->cpuMask, cpu))
-			found = 1;
-
-	if (!found) {
-		printk(KERN_ERR "%s: cpuMask does not contain any of the CPUs \n", __func__);
-		printk(KERN_ERR "%s: not initializing network driver\n", __func__);
-		return;
-	}
-	mv88fx_neta.dev.platform_data = netaSmpGroupStruct;
-
-#elif defined (CONFIG_MV_ETH_PP2)
 	mv_pp2_giga_pdev_register(&mv_pp2_ge0_plat);
 	mv_pp2_giga_pdev_register(&mv_pp2_ge1_plat);
 	mv_pp2_giga_pdev_register(&mv_pp2_ge2_plat);
 	mv_pp2_giga_pdev_register(&mv_pp2_ge3_plat);
-#endif
 }
 
 #endif /* CONFIG_MV_ETHERNET */
 
-#ifdef CONFIG_MV_ETH_SWITCH
+#ifdef CONFIG_MV_INCLUDE_SWITCH
 static void mv_switch_pdev_register(struct platform_device *pdev)
 {
 	struct mv_switch_pdata *plat_data = (struct mv_switch_pdata *)pdev->dev.platform_data;
@@ -719,10 +684,7 @@ static void mv_switch_pdev_register(struct platform_device *pdev)
 	plat_data->phy_addr = mvBoardPhyAddrGet(plat_data->gbe_port);
 	plat_data->switch_cpu_port = mvBoardSwitchCpuPortGet(plat_data->index);
 	plat_data->smi_scan_mode = mvBoardSmiScanModeGet(plat_data->index);
-	plat_data->qsgmii_module = 0; /* not relevant for alp */
-	plat_data->gephy_on_port = mvBoardGePhySwitchPortGet();
-	plat_data->rgmiia_on_port = mvBoardRgmiiASwitchPortGet();
-	plat_data->switch_irq = mvBoardSwitchIrqGet();
+	plat_data->switch_irq = IRQ_GLOBAL_ETH_COMPLEX;
 
 	platform_device_register(pdev);
 }
@@ -741,11 +703,11 @@ static struct mv_switch_pdata mv_switch0_plat_data = {
 	.gbe_port = 0,
 	.gephy_on_port = -1,
 	.switch_cpu_port = 5,
-	.tag_mode = MV_TAG_TYPE_DSA,
-        .preset = MV_PRESET_SINGLE_VLAN,
+	.tag_mode = MV_TAG_TYPE_MH,
+	.preset = MV_PRESET_PER_PORT_VLAN,
 	.vid = 0,
-	.port_mask = 0x3f,
-	.connected_port_mask = 0x1e,
+	.port_mask = 0x7f,
+	.connected_port_mask = 0x4f,
 	.mtu = 1500,
 };
 
@@ -763,14 +725,14 @@ static void __init switch_init(void)
 {
 	mv_switch_pdev_register(&mv_switch0_plat_dev);
 }
-#endif /* CONFIG_MV_ETH_SWITCH */
+#endif /* CONFIG_MV_INCLUDE_SWITCH */
 
 static void alp_init_eth(void)
 {
 #ifdef CONFIG_MV_ETHERNET
 	mvSysEthPhyInit();
 	eth_init();
-#ifdef CONFIG_MV_ETH_SWITCH
+#ifdef CONFIG_MV_INCLUDE_SWITCH
 	switch_init();
 #endif
 #endif
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_gw_mgr.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_gw_mgr.c
index d5240d2..cad0289 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_gw_mgr.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_gw_mgr.c
@@ -25,7 +25,7 @@ DISCLAIMED.  The GPL License provides additional details about this warranty
 disclaimer.
 *******************************************************************************/
 
-#ifdef CONFIG_MV_ETH_SWITCH
+#ifdef CONFIG_MV_INCLUDE_SWITCH
 
 #include "mvCommon.h"
 #include "mvDebug.h"
@@ -90,7 +90,6 @@ static int __init mv_gw_mgr_init(void)
 	int vid, gbe_port;
 	struct eth_port *pp;
 
-
 	/* get default switch configuration parameteres for preset init */
 	mv_switch_default_config_get(&tag_mode, &preset, &vid, &gbe_port);
 
@@ -114,9 +113,10 @@ static int __init mv_gw_mgr_init(void)
 	/* set mux ops to be used by switch driver */
 	mux_ops.update_link = mv_mux_update_link;
 	mv_switch_mux_ops_set(&mux_ops);
+	mv_switch_interrupt_unmask();
 
 	return 0;
 }
 
 late_initcall(mv_gw_mgr_init);
-#endif /* CONFIG_MV_ETH_SWITCH */
+#endif /* CONFIG_MV_INCLUDE_SWITCH */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.c
index 4880461..18da99c 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_mux_netdev.c
@@ -87,7 +87,7 @@ int mv_mux_rx(struct sk_buff *skb, struct net_device *root_dev)
 
 
 #ifdef CONFIG_MV_ETH_DEBUG_CODE
-	if (pp->flags & MV_ETH_F_DBG_RX) {
+	if (pp->dbg_flags & MV_ETH_F_DBG_RX) {
 		printk(KERN_ERR "\n%s - %s: port=%d, cpu=%d\n", dev->name, __func__, pp->port, smp_processor_id());
 		mv_eth_skb_print(skb);
 		mvDebugMemDump(skb->data, 64, 1);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
index 11b4741..1577a2f 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.c
@@ -3333,10 +3333,10 @@ void mv_eth_config_show(void)
 	printk(KERN_ERR "  o Driver debug messages enabled\n");
 #endif
 
-#if defined(CONFIG_MV_ETH_SWITCH)
+#if defined(CONFIG_MV_INCLUDE_SWITCH)
 	printk(KERN_ERR "  o Switch support enabled\n");
 
-#endif /* CONFIG_MV_ETH_SWITCH */
+#endif /* CONFIG_MV_INCLUDE_SWITCH */
 
 	printk(KERN_ERR "\n");
 }
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
index f0d1143..fee856f 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_pp2/net_dev/mv_netdev.h
@@ -387,7 +387,6 @@ struct eth_port {
 	struct cpu_ctrl	*cpu_config[CONFIG_NR_CPUS];
 	MV_U32  sgmii_serdes;
 	int	pm_mode;
-	int	link_irq;
 };
 
 enum eth_pm_mode {
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.c
index ac9f636..c3ec83c 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.c
@@ -49,8 +49,6 @@ disclaimer.
 #endif
 
 unsigned int mv_switch_link_detection_init(struct mv_switch_pdata *plat_data);
-void mv_eth_switch_interrupt_clear(void);
-void mv_eth_switch_interrupt_unmask(void);
 
 #define MV_SWITCH_DEF_INDEX     0
 #define MV_ETH_PORT_0           0
@@ -80,9 +78,6 @@ static GT_QD_DEV qddev, *qd_dev = NULL;
 static GT_SYS_CONFIG qd_cfg;
 
 static int qd_cpu_port = -1;
-static int qsgmii_module = 0;
-static int gephy_on_port = -1;
-static int rgmiia_on_port = -1;
 static int enabled_ports_mask = 0;
 static int switch_ports_mask = 0;
 static MV_TAG_TYPE tag_mode;
@@ -93,6 +88,7 @@ static int gbe_port;
 static struct mux_device_ops *mux_ops = NULL;
 
 #ifdef CONFIG_MV_ETH_SWITCH_LINK
+static struct tasklet_struct link_tasklet;
 static int switch_irq = -1;
 int switch_link_poll = 0;
 static struct timer_list switch_link_timer;
@@ -103,35 +99,39 @@ static spinlock_t switch_lock;
 static GT_BOOL mv_switch_mii_read(GT_QD_DEV *dev, unsigned int phy, unsigned int reg, unsigned int *data)
 {
 	unsigned long flags;
-	unsigned short tmp;
-	MV_STATUS status;
+	MV_U32 result, offset = 0;
 
 	spin_lock_irqsave(&switch_lock, flags);
-	status = mvEthPhyRegRead(phy, reg, &tmp);
-	spin_unlock_irqrestore(&switch_lock, flags);
-	*data = tmp;
 
-	if (status == MV_OK)
-		return GT_TRUE;
+	offset |= (0x3 << 16);
+	offset |= (phy << 7);
+	offset |= (reg << 2);
+
+	result = MV_REG_READ(offset);
+
+	*data = result;
+
+	spin_unlock_irqrestore(&switch_lock, flags);
 
-	return GT_FALSE;
+	return GT_TRUE;
 }
 
 static GT_BOOL mv_switch_mii_write(GT_QD_DEV *dev, unsigned int phy, unsigned int reg, unsigned int data)
 {
 	unsigned long flags;
-	unsigned short tmp;
-	MV_STATUS status;
+	MV_U32 offset = 0;
 
 	spin_lock_irqsave(&switch_lock, flags);
-	tmp = (unsigned short)data;
-	status = mvEthPhyRegWrite(phy, reg, tmp);
-	spin_unlock_irqrestore(&switch_lock, flags);
 
-	if (status == MV_OK)
-		return GT_TRUE;
+	offset |= (0x3 << 16);
+	offset |= (phy << 7);
+	offset |= (reg << 2);
+
+	MV_REG_WRITE(offset, data);
+
+	spin_unlock_irqrestore(&switch_lock, flags);
 
-	return GT_FALSE;
+	return GT_TRUE;
 }
 
 static int mv_switch_port_db_get(int port)
@@ -470,12 +470,8 @@ void mv_switch_link_update_event(MV_U32 port_mask, int force_link_check)
 
 	for (p = 0; p < qd_dev->numOfPorts; p++) {
 		if (MV_BIT_CHECK(port_mask, p)) {
-			if ((!qsgmii_module) || (p == gephy_on_port)) { /* liron, TODO: || (p == rgmiia_on_port)  */
-				/* this is needed to clear the PHY interrupt */
-				gprtGetPhyIntStatus(qd_dev, p, &phy_cause);
-			} else {
-				phy_cause |= GT_LINK_STATUS_CHANGED;
-			}
+			/* this is needed to clear the PHY interrupt */
+			gprtGetPhyIntStatus(qd_dev, p, &phy_cause);
 
 			if (force_link_check)
 				phy_cause |= GT_LINK_STATUS_CHANGED;
@@ -551,26 +547,31 @@ void mv_switch_link_timer_function(unsigned long data)
 
 static irqreturn_t mv_switch_isr(int irq, void *dev_id)
 {
+	mv_switch_interrupt_mask();
+
+	tasklet_schedule(&link_tasklet);
+
+	return IRQ_HANDLED;
+}
+
+void mv_switch_tasklet(unsigned long data)
+{
 	GT_DEV_INT_STATUS devIntStatus;
 	MV_U32 port_mask = 0;
 
-	if (!qsgmii_module) {
-		if (geventGetDevIntStatus(qd_dev, &devIntStatus) != GT_OK)
-			printk(KERN_ERR "geventGetDevIntStatus failed\n");
+	/* TODO: verify that switch interrupt occured */
 
-		if (devIntStatus.devIntCause & GT_DEV_INT_PHY)
-			port_mask = devIntStatus.phyInt & 0xFF;
-	}
-	/* TODO - qsgmii */
+	if (geventGetDevIntStatus(qd_dev, &devIntStatus) != GT_OK)
+		printk(KERN_ERR "geventGetDevIntStatus failed\n");
 
-	if (gephy_on_port >= 0)
-		port_mask |= (1 << gephy_on_port);
+	if (devIntStatus.devIntCause & GT_DEV_INT_PHY)
+		port_mask = devIntStatus.phyInt & 0xFF;
 
-	mv_switch_link_update_event(port_mask, 0);
+	mv_switch_link_update_event(port_mask, 1/* ALP Z1 WA - link change bit not rising in time */);
 
-	mv_eth_switch_interrupt_clear();
+	mv_switch_interrupt_clear();
 
-	return IRQ_HANDLED;
+	mv_switch_interrupt_unmask();
 }
 #endif /* CONFIG_MV_ETH_SWITCH_LINK */
 
@@ -639,18 +640,6 @@ int mv_switch_load(struct mv_switch_pdata *plat_data)
 	printk(KERN_ERR "    o No. of Ports  : %d\n", qd_dev->numOfPorts);
 	printk(KERN_ERR "    o CPU Port      : %ld\n", qd_dev->cpuPortNum);
 
-	qsgmii_module = plat_data->qsgmii_module;
-	if (qsgmii_module)
-		printk(KERN_ERR "    o QSGMII Module Detected\n");
-
-	gephy_on_port = plat_data->gephy_on_port;
-	if (gephy_on_port >= 0)
-		printk(KERN_ERR "    o Internal GE PHY Connected to Switch Port %d Detected\n", gephy_on_port);
-
-	rgmiia_on_port = plat_data->rgmiia_on_port;
-	if (rgmiia_on_port >= 0)
-		printk(KERN_ERR "    o RGMII-A Connected to Switch Port %d Detected\n", rgmiia_on_port);
-
 	/* disable all disconnected ports */
 	for (p = 0; p < qd_dev->numOfPorts; p++) {
 		/* Do nothing for ports that are not part of the given switch_port_mask */
@@ -763,9 +752,6 @@ int mv_switch_unload(unsigned int switch_ports_mask)
 	}
 	qd_dev = NULL;
 	qd_cpu_port = -1;
-	qsgmii_module = 0;
-	gephy_on_port = -1;
-	rgmiia_on_port = -1;
 
 #ifdef CONFIG_MV_ETH_SWITCH_LINK
 	switch_irq = -1;
@@ -853,6 +839,7 @@ int mv_switch_init(struct mv_switch_pdata *plat_data)
 	case GT_88E6165:
 	case GT_88E6171:
 	case GT_88E6351:
+	case GT_88E6352:
 		break;		/* do nothing */
 
 	default:
@@ -987,50 +974,37 @@ int mv_switch_preset_init(MV_SWITCH_PRESET_TYPE preset, MV_TAG_TYPE tag_mode, in
 	return 0;
 }
 
-void mv_eth_switch_interrupt_unmask(void)
+void mv_switch_interrupt_mask(void)
 {
-#ifdef MV_INCLUDE_ETH_COMPLEX
 	MV_U32 reg;
 
-	reg = MV_REG_READ(MV_ETHCOMP_INT_MAIN_MASK_REG);
-
-	if (qsgmii_module) {
-		reg |= (MV_ETHCOMP_PCS0_LINK_INT_MASK |
-			MV_ETHCOMP_PCS1_LINK_INT_MASK |
-			MV_ETHCOMP_PCS2_LINK_INT_MASK |
-			MV_ETHCOMP_PCS3_LINK_INT_MASK);
-	}
-
-	if (gephy_on_port >= 0)
-		reg |= MV_ETHCOMP_GEPHY_INT_MASK;
+	reg = MV_REG_READ(0x18954/*MV_ETHCOMP_INT_MAIN_MASK_REG*/);
 
-	reg |= MV_ETHCOMP_SWITCH_INT_MASK;
+	reg &= ~0x1/*MV_ETHCOMP_SWITCH_INT_MASK*/;
 
-	MV_REG_WRITE(MV_ETHCOMP_INT_MAIN_MASK_REG, reg);
-#endif /* MV_INCLUDE_ETH_COMPLEX */
+	MV_REG_WRITE(0x18954/*MV_ETHCOMP_INT_MAIN_MASK_REG*/, reg);
 }
 
-void mv_eth_switch_interrupt_clear(void)
+void mv_switch_interrupt_unmask(void)
 {
-#ifdef MV_INCLUDE_ETH_COMPLEX
 	MV_U32 reg;
 
-	reg = MV_REG_READ(MV_ETHCOMP_INT_MAIN_CAUSE_REG);
+	reg = MV_REG_READ(0x18954/*MV_ETHCOMP_INT_MAIN_MASK_REG*/);
 
-	if (qsgmii_module) {
-		reg &= ~(MV_ETHCOMP_PCS0_LINK_INT_MASK |
-			 MV_ETHCOMP_PCS1_LINK_INT_MASK |
-			 MV_ETHCOMP_PCS2_LINK_INT_MASK |
-			 MV_ETHCOMP_PCS3_LINK_INT_MASK);
-	}
+	reg |= 0x1/*MV_ETHCOMP_SWITCH_INT_MASK*/;
 
-	if (gephy_on_port >= 0)
-		reg &= ~MV_ETHCOMP_GEPHY_INT_MASK;
+	MV_REG_WRITE(0x18954/*MV_ETHCOMP_INT_MAIN_MASK_REG*/, reg);
+}
 
-	reg &= ~MV_ETHCOMP_SWITCH_INT_MASK;
+void mv_switch_interrupt_clear(void)
+{
+	MV_U32 reg;
 
-	MV_REG_WRITE(MV_ETHCOMP_INT_MAIN_CAUSE_REG, reg);
-#endif /* MV_INCLUDE_ETH_COMPLEX */
+	reg = MV_REG_READ(0x18950/*MV_ETHCOMP_INT_MAIN_CAUSE_REG*/);
+
+	reg &= ~0x1/*MV_ETHCOMP_SWITCH_INT_MASK*/;
+
+	MV_REG_WRITE(0x18950/*MV_ETHCOMP_INT_MAIN_CAUSE_REG*/, reg);
 }
 
 unsigned int mv_switch_link_detection_init(struct mv_switch_pdata *plat_data)
@@ -1048,57 +1022,40 @@ unsigned int mv_switch_link_detection_init(struct mv_switch_pdata *plat_data)
 
 	switch_irq = plat_data->switch_irq;
 
-	if (!qsgmii_module) {
-		connected_phys_mask = plat_data->connected_port_mask & ~(1 << qd_cpu_port);
+	connected_phys_mask = plat_data->connected_port_mask & ~(1 << qd_cpu_port);
 
-		if (!link_init_done) {
-			/* Enable Phy Link Status Changed interrupt at Phy level for the all enabled ports */
-			for (p = 0; p < qd_dev->numOfPorts; p++) {
-				if (MV_BIT_CHECK(connected_phys_mask, p) && (p != qd_cpu_port)) {
-					if (gprtPhyIntEnable(qd_dev, p, (GT_LINK_STATUS_CHANGED)) != GT_OK)
-						printk(KERN_ERR "gprtPhyIntEnable failed port %d\n", p);
-				}
+	if (!link_init_done) {
+		/* Enable Phy Link Status Changed interrupt at Phy level for the all enabled ports */
+		for (p = 0; p < qd_dev->numOfPorts; p++) {
+			if (MV_BIT_CHECK(connected_phys_mask, p) && (p != qd_cpu_port)) {
+				if (gprtPhyIntEnable(qd_dev, p, (GT_LINK_STATUS_CHANGED)) != GT_OK)
+					printk(KERN_ERR "gprtPhyIntEnable failed port %d\n", p);
 			}
+		}
 
-			if (switch_irq != -1) {
-				/* Interrupt supported */
+		if (switch_irq != -1) {
+			/* Interrupt supported */
 
-				if ((qd_dev->deviceId == GT_88E6161) || (qd_dev->deviceId == GT_88E6165) ||
-				    (qd_dev->deviceId == GT_88E6351) || (qd_dev->deviceId == GT_88E6171)) {
-					GT_DEV_EVENT gt_event = { GT_DEV_INT_PHY, 0, connected_phys_mask };
+			if ((qd_dev->deviceId == GT_88E6161) || (qd_dev->deviceId == GT_88E6165) ||
+			    (qd_dev->deviceId == GT_88E6351) || (qd_dev->deviceId == GT_88E6171) ||
+			    (qd_dev->deviceId == GT_88E6352)) {
+				GT_DEV_EVENT gt_event = { GT_DEV_INT_PHY, 0, connected_phys_mask };
 
-					if (eventSetDevInt(qd_dev, &gt_event) != GT_OK)
-						printk(KERN_ERR "eventSetDevInt failed\n");
+				if (eventSetDevInt(qd_dev, &gt_event) != GT_OK)
+					printk(KERN_ERR "eventSetDevInt failed\n");
 
-					if (eventSetActive(qd_dev, GT_DEVICE_INT) != GT_OK)
-						printk(KERN_ERR "eventSetActive failed\n");
-				} else {
-					if (eventSetActive(qd_dev, GT_PHY_INTERRUPT) != GT_OK)
-						printk(KERN_ERR "eventSetActive failed\n");
-				}
+				if (eventSetActive(qd_dev, GT_DEVICE_INT) != GT_OK)
+					printk(KERN_ERR "eventSetActive failed\n");
+			} else {
+				if (eventSetActive(qd_dev, GT_PHY_INTERRUPT) != GT_OK)
+					printk(KERN_ERR "eventSetActive failed\n");
 			}
 		}
 	}
 
 	if (!link_init_done) {
-		if (gephy_on_port >= 0) {
-			if (gprtPhyIntEnable(qd_dev, gephy_on_port, (GT_LINK_STATUS_CHANGED)) != GT_OK)
-				printk(KERN_ERR "gprtPhyIntEnable failed port %d\n", gephy_on_port);
-		}
-	}
-
-	if (qsgmii_module)
-		connected_phys_mask = 0x0F;	/* Switch ports 0, 1, 2, 3 connected to QSGMII */
-
-	if (gephy_on_port >= 0)
-		connected_phys_mask |= (1 << gephy_on_port);
-
-	if (rgmiia_on_port >= 0)
-		connected_phys_mask |= (1 << rgmiia_on_port);
-
-	if (!link_init_done) {
 		/* we want to use a timer for polling link status if no interrupt is available for all or some of the PHYs */
-		if ((switch_irq == -1)) { /* liron, TODO: || (rgmiia_on_port >= 0) */
+		if (switch_irq == -1) {
 			/* Use timer for polling */
 			switch_link_poll = 1;
 			init_timer(&switch_link_timer);
@@ -1106,20 +1063,18 @@ unsigned int mv_switch_link_detection_init(struct mv_switch_pdata *plat_data)
 
 			if (switch_irq == -1)
 				switch_link_timer.data = connected_phys_mask;
-			else		/* timer only for RGMII-A connected port */
-				switch_link_timer.data = (1 << rgmiia_on_port);
 
 			switch_link_timer.expires = jiffies + (HZ);	/* 1 second */
 			add_timer(&switch_link_timer);
-		}
-	}
+		} else {
+			/* create tasklet for interrupt handling */
+			tasklet_init(&link_tasklet, mv_switch_tasklet, 0);
 
-	if (!link_init_done) {
-		if (switch_irq != -1) {
-			mv_eth_switch_interrupt_unmask();
 			/* Interrupt supported */
 			if (request_irq(switch_irq, mv_switch_isr, (IRQF_DISABLED | IRQF_SAMPLE_RANDOM), "switch", NULL))
 				printk(KERN_ERR "failed to assign irq%d\n", switch_irq);
+
+			/* interrupt unmasking will be done by GW manager */
 		}
 	}
 
@@ -1406,8 +1361,6 @@ int mv_switch_reg_read(int port, int reg, int type, MV_U16 *value)
 
 	switch (type) {
 	case MV_SWITCH_PHY_ACCESS:
-		if (qsgmii_module)
-			printk(KERN_ERR "warning: cannot read Switch PHY register when QSGMII module is connected\n");
 		status = gprtGetPhyReg(qd_dev, port, reg, value);
 		break;
 
@@ -1450,8 +1403,6 @@ int mv_switch_reg_write(int port, int reg, int type, MV_U16 value)
 
 	switch (type) {
 	case MV_SWITCH_PHY_ACCESS:
-		if (qsgmii_module)
-			printk(KERN_ERR "warning: cannot write Switch PHY register when QSGMII module is connected\n");
 		status = gprtSetPhyReg(qd_dev, port, reg, value);
 		break;
 
@@ -1569,17 +1520,14 @@ int mv_switch_port_add(int switch_port, u16 grp_id)
 	if (gstpSetPortState(qd_dev, switch_port, GT_PORT_FORWARDING) != GT_OK)
 		printk(KERN_ERR "gstpSetPortState failed\n");
 #ifdef CONFIG_MV_ETH_SWITCH_LINK
-	if (!qsgmii_module) {
-		/* Enable Phy Link Status Changed interrupt at Phy level for the port */
-		if (gprtPhyIntEnable(qd_dev, switch_port, (GT_LINK_STATUS_CHANGED)) != GT_OK)
-			printk(KERN_ERR "gprtPhyIntEnable failed port %d\n", switch_port);
-	}
+	/* Enable Phy Link Status Changed interrupt at Phy level for the port */
+	if (gprtPhyIntEnable(qd_dev, switch_port, (GT_LINK_STATUS_CHANGED)) != GT_OK)
+		printk(KERN_ERR "gprtPhyIntEnable failed port %d\n", switch_port);
 #endif /* CONFIG_MV_ETH_SWITCH_LINK */
 
 	db_port_mask[grp_id] = port_map;
 	enabled_ports_mask |= (1 << switch_port);
 	/* TODO if new mux */
-	//mv_switch_mux_create(NULL/*TODO name*/, 0/*TODO gbe_port*/, grp_id, port_map | (1 << qd_cpu_port), NULL/*TODO tag*/);
 
 	return 0;
 }
@@ -1614,11 +1562,9 @@ int mv_switch_port_del(int switch_port)
 	port_map = db_port_mask[grp_id] & ~(1 << switch_port);
 
 #ifdef CONFIG_MV_ETH_SWITCH_LINK
-	if (!qsgmii_module) {
-		/* Disable link change interrupts on unmapped port */
-		if (gprtPhyIntEnable(qd_dev, switch_port, 0) != GT_OK)
-			printk(KERN_ERR "gprtPhyIntEnable failed on port #%d\n", switch_port);
-	}
+	/* Disable link change interrupts on unmapped port */
+	if (gprtPhyIntEnable(qd_dev, switch_port, 0) != GT_OK)
+		printk(KERN_ERR "gprtPhyIntEnable failed on port #%d\n", switch_port);
 #endif /* CONFIG_MV_ETH_SWITCH_LINK */
 
 	/* Disable unmapped port */
@@ -1693,7 +1639,7 @@ static int __init mv_switch_init_module(void)
 {
 	return platform_driver_register(&mv_switch_driver);
 }
-late_initcall(mv_switch_init_module);
+module_init(mv_switch_init_module);
 
 static void __exit mv_switch_cleanup_module(void)
 {
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.h
index e156c2b..16aa76f 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.h
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch.h
@@ -47,6 +47,10 @@ struct mux_device_ops {
 	int	(*update_link)(void *cookie, int link_up);
 };
 
+void mv_switch_interrupt_mask(void);
+void mv_switch_interrupt_unmask(void);
+void mv_switch_interrupt_clear(void);
+
 int     mv_switch_unload(unsigned int switch_ports_mask);
 void    mv_switch_link_update_event(MV_U32 port_mask, int force_link_check);
 int     mv_switch_jumbo_mode_set(int max_size);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch_sysfs.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch_sysfs.c
index 15af68a4..c2e7ddf 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch_sysfs.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_switch/mv_switch_sysfs.c
@@ -157,14 +157,14 @@ int __devinit mv_switch_sysfs_init(void)
 	int err;
 	struct device *pd;
 
-	pd = bus_find_device_by_name(&platform_bus_type, NULL, "neta");
+	pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
 	if (!pd) {
-		platform_device_register_simple("neta", -1, NULL, 0);
-		pd = bus_find_device_by_name(&platform_bus_type, NULL, "neta");
+		platform_device_register_simple("pp2", -1, NULL, 0);
+		pd = bus_find_device_by_name(&platform_bus_type, NULL, "pp2");
 	}
 
 	if (!pd) {
-		printk(KERN_ERR "%s: cannot find neta device\n", __func__);
+		printk(KERN_ERR "%s: cannot find pp2 device\n", __func__);
 		pd = &platform_bus;
 	}
 
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtSysConfig.c b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtSysConfig.c
index 14f84be..bff020f 100644
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtSysConfig.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/msapi/gtSysConfig.c
@@ -295,6 +295,9 @@ GT_STATUS qdLoadDriver
     if((dev->deviceId&0xfff8)==GT_88EC000) /* device id 0xc00 - 0xc07 are GT_88EC0XX */
       dev->deviceId=GT_88EC000;
 
+	if (dev->deviceId == 0xc10)
+		dev->deviceId = GT_88E6352;
+
     switch(dev->deviceId)
     {
         case GT_88E6021:
diff --git a/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/platform/gtMiiSmiIf.c b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/platform/gtMiiSmiIf.c
index d38e90b..8f2fbaa 100644
--- a/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/platform/gtMiiSmiIf.c
+++ b/arch/arm/plat-armada/mv_hal/qd-dsdt-3.3/src/platform/gtMiiSmiIf.c
@@ -257,6 +257,7 @@ GT_U16 miiSmiManualIfInit
         case 0x3500:    /* Agate */
         case 0x1100:    /* Pearl */
         case 0x3100:    /* Pearl */
+	case 0xc100:	/* ALP Fix */
             return data;
         default:
             break;
@@ -300,6 +301,7 @@ GT_STATUS miiSmiIfReadRegister
 )
 {
     unsigned int tmpData;
+
 #ifdef GT_RMGMT_ACCESS
     if((dev->accessMode == SMI_MULTI_ADDR_MODE) &&
        (dev->fgtHwAccessMod == HW_ACCESS_MODE_SMI))
-- 
1.7.5.4

