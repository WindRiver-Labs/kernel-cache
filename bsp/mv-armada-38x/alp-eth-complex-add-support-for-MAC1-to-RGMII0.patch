From 96b0140ec7b35741fd94418191a2c1cb4fb23095 Mon Sep 17 00:00:00 2001
From: Hanna Hawa <hannah@marvell.com>
Date: Wed, 19 Mar 2014 16:42:22 +0200
Subject: [PATCH 1493/1825] alp: eth complex: add support for MAC1 to RGMII0

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 6b389d7fd6f7e04f5aeeda1bac9b344fc50c5bac

	Add support for MAC1 to RGMII0
	- Add option for boardConfig to MAC1 "RGMII-0"
	- Update MPP's of RGMII0
	- Check conflict between MAC1/0 to RGMII0
	Supported and tested on ALP-A0 boards

Change-Id: Id1500afb9bb5f8ac67572b0bd64fc4251e9c2fa5
Signed-off-by: Hanna Hawa <hannah@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/6540
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Omri Itach <omrii@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../avanta_lp_family/boardEnv/mvBoardEnvLib.c      |   70 ++++++++++++-------
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c        |    4 +-
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h        |    1 +
 .../avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h       |   58 ++++++++++-------
 .../avanta_lp_family/ctrlEnv/mvCtrlEthCompLib.c    |    8 +-
 5 files changed, 85 insertions(+), 56 deletions(-)

diff --git a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
index 1f1801f..2c13ea0 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/boardEnv/mvBoardEnvLib.c
@@ -927,7 +927,7 @@ MV_VOID mvBoardInfoUpdate(MV_VOID)
 	else if (ethComplex & MV_ETHCOMP_GE_MAC0_2_RGMII0) {
 		/* External PHY SMI address (extenal module) for Zx revision is
 		** 0x8, for A0 the module is on board with address 0x5 */
-		if (mvCtrlRevGet() < MV_88F66X0_Z3_ID)
+		if (mvCtrlRevGet() <= MV_88F66X0_Z3_ID)
 			smiAddress = 0x8;
 		else
 			smiAddress = 0x5;
@@ -946,8 +946,10 @@ MV_VOID mvBoardInfoUpdate(MV_VOID)
 	if (ethComplex & MV_ETHCOMP_GE_MAC1_2_GE_PHY_P3)
 		smiAddress = 0x3;
 	/* MAC1 to RGMII, or MAC1 to SGMII: both configs use the same SMI address (0x1) */
-	else if (ethComplex & MV_ETHCOMP_GE_MAC1_2_RGMII1 || ethComplex & MV_ETHCOMP_GE_MAC1_2_PON_ETH_SERDES)
+	else if (ethComplex & (MV_ETHCOMP_GE_MAC1_2_RGMII1 | MV_ETHCOMP_GE_MAC1_2_PON_ETH_SERDES))
 		smiAddress = 0x1;
+	else if (ethComplex & MV_ETHCOMP_GE_MAC1_2_RGMII0)
+		smiAddress = 0x5;
 	else {
 		smiAddress = -1; /* no SMI address if connected to switch */
 		macSpeed = BOARD_MAC_SPEED_1000M;
@@ -1053,6 +1055,7 @@ MV_VOID mvBoardMppIdUpdate(MV_VOID)
 	MV_BOARD_BOOT_SRC bootDev;
 	MV_SLIC_UNIT_TYPE slicDev;
 	MV_U32 ethComplexOptions = mvBoardEthComplexConfigGet();
+	MV_BOOL singleCpu, tdmLqUnit;
 
 	/* MPP Groups initialization : */
 	/* Set Group 0-1 - Boot device (else if booting from SPI1: Set Groups 3-4) */
@@ -1064,37 +1067,32 @@ MV_VOID mvBoardMppIdUpdate(MV_VOID)
 
 	/* Groups 3-4  - (only if not Booting from SPI1)*/
 	if (bootDev != MSAR_0_BOOT_SPI1_FLASH) {
-		if (ethComplexOptions & MV_ETHCOMP_GE_MAC1_2_RGMII1 ||
-				ethComplexOptions & MV_ETHCOMP_GE_MAC1_2_PON_ETH_SERDES) {
-			mvBoardMppTypeSet(3, GE1_UNIT);
-			if (slicDev == SLIC_LANTIQ_ID)
-				mvBoardMppTypeSet(4, GE1_CPU_SMI_CTRL_TDM_LQ_UNIT);
-			else /* REF_CLK_OUT */
-				mvBoardMppTypeSet(4, GE1_CPU_SMI_CTRL_REF_CLK_OUT);
+		tdmLqUnit = (slicDev == SLIC_LANTIQ_ID);
+		if (ethComplexOptions & (MV_ETHCOMP_GE_MAC1_2_RGMII1 | MV_ETHCOMP_GE_MAC1_2_PON_ETH_SERDES)) {
+			mvBoardMppTypeSet(3, GE1_RGMII1_UNIT);
+			mvBoardMppTypeSet(4, (tdmLqUnit ? GE1_RGMII1_CPU_SMI_CTRL_TDM_LQ_UNIT : \
+						GE1_RGMII1_CPU_SMI_CTRL_REF_CLK_OUT));
 		} else { /* if RGMII-1 isn't used, set SPI1 MPP's */
 			mvBoardMppTypeSet(3, SDIO_SPI1_UNIT);
-			if (slicDev == SLIC_LANTIQ_ID)
-				mvBoardMppTypeSet(4, SPI1_CPU_SMI_CTRL_TDM_LQ_UNIT);
-			else /* REF_CLK_OUT */
-				mvBoardMppTypeSet(4, SPI1_CPU_SMI_CTRL_REF_CLK_OUT);
+			mvBoardMppTypeSet(4, (tdmLqUnit ? SPI1_CPU_SMI_CTRL_TDM_LQ_UNIT : \
+						SPI1_CPU_SMI_CTRL_REF_CLK_OUT));
 		}
 	}
 
-	/* Groups 5-6-7 Set GE0 or Switch port 4 */
+	/* Groups 5-6-7 Set GE0, GE1_RGMII0, or Switch port 4 */
+	singleCpu = (mvCtrlGetCpuNum() == 0); /* if using Dual CPU ,set UART1 */
 	if (ethComplexOptions & MV_ETHCOMP_GE_MAC0_2_RGMII0) {
 		mvBoardMppTypeSet(5, GE0_UNIT_PON_TX_FAULT);
 		mvBoardMppTypeSet(6, GE0_UNIT);
-		if (mvCtrlGetCpuNum() == 0) /* if using Dual CPU ,set UART1 */
-			mvBoardMppTypeSet(7, GE0_UNIT_LED_MATRIX);
-		else
-			mvBoardMppTypeSet(7, GE0_UNIT_UA1_PTP);
+		mvBoardMppTypeSet(7, (singleCpu ? GE0_UNIT_LED_MATRIX : GE0_UNIT_UA1_PTP));
 	} else if (ethComplexOptions & MV_ETHCOMP_SW_P4_2_RGMII0) {
 		mvBoardMppTypeSet(5, SWITCH_P4_PON_TX_FAULT);
 		mvBoardMppTypeSet(6, SWITCH_P4);
-		if (mvCtrlGetCpuNum() == 0) /* if using Dual CPU ,set UART1 */
-			mvBoardMppTypeSet(7, SWITCH_P4_LED_MATRIX);
-		else
-			mvBoardMppTypeSet(7, SWITCH_P4_UA1_PTP);
+		mvBoardMppTypeSet(7, (singleCpu ? SWITCH_P4_LED_MATRIX : SWITCH_P4_UA1_PTP));
+	} else if (ethComplexOptions & MV_ETHCOMP_GE_MAC1_2_RGMII0) {
+		mvBoardMppTypeSet(5, GE1_RGMII0_UNIT_PON_TX_FAULT);
+		mvBoardMppTypeSet(6, GE1_RGMII0_UNIT);
+		mvBoardMppTypeSet(7, (singleCpu ? GE1_RGMII0_UNIT_LED_MATRIX : GE1_RGMII0_UNIT_UA1_PTP));
 	}
 }
 
@@ -1432,6 +1430,9 @@ MV_ETH_COMPLEX_TOPOLOGY mvBoardMac1ConfigGet()
 	case 0x2:
 		return MV_ETHCOMP_GE_MAC1_2_GE_PHY_P3;
 		break;
+	case 0x3:
+		return MV_ETHCOMP_GE_MAC1_2_RGMII0;
+		break;
 	default:
 		mvOsPrintf("%s: Error: Configuration conflict for MAC1 connection.\n", __func__);
 		return MV_ERROR;
@@ -1920,7 +1921,9 @@ MV_VOID mvBoardConfigurationPrint(MV_VOID)
 	if (ethConfig & MV_ETHCOMP_GE_MAC0_2_RGMII0)
 		mvOsOutput("\tRGMII0 Module on MAC0\n");
 	if (ethConfig & MV_ETHCOMP_GE_MAC1_2_RGMII1)
-		mvOsOutput("\tRGMII1 on MAC1\n");
+		mvOsOutput("\tRGMII1 Module on MAC1\n");
+	if (ethConfig & MV_ETHCOMP_GE_MAC1_2_RGMII0)
+		mvOsOutput("\tRGMII0 Module on MAC1\n");
 	if (ethConfig & MV_ETHCOMP_SW_P4_2_RGMII0_EXT_PHY)
 		mvOsOutput("\tExternal PHY-RGMII0 Module on Switch port #4, 1G speed\n");
 	else if (ethConfig & MV_ETHCOMP_SW_P4_2_RGMII0)
@@ -3159,6 +3162,7 @@ MV_BOOL mvBoardIsEthConnected(MV_U32 ethNum)
 
 	if (ethNum == 1 && ((c & MV_ETHCOMP_GE_MAC1_2_GE_PHY_P3) ||
 			(c & MV_ETHCOMP_GE_MAC1_2_RGMII1) ||
+			(c & MV_ETHCOMP_GE_MAC1_2_RGMII0) ||
 			(c & MV_ETHCOMP_GE_MAC1_2_PON_ETH_SERDES) ||
 			(c & MV_ETHCOMP_GE_MAC1_2_SW_P4)))
 			isConnected = MV_TRUE;
@@ -3211,6 +3215,7 @@ MV_BOOL mvBoardIsEthActive(MV_U32 ethNum)
 
 	if (ethNum == 1 && ((c & MV_ETHCOMP_GE_MAC1_2_GE_PHY_P3) ||
 			(c & MV_ETHCOMP_GE_MAC1_2_RGMII1) ||
+			(c & MV_ETHCOMP_GE_MAC1_2_RGMII0) ||
 			(c & MV_ETHCOMP_GE_MAC1_2_PON_ETH_SERDES) ||
 			((c & MV_ETHCOMP_GE_MAC1_2_SW_P4) && mvBoardMacCpuPortGet() == 1)))
 			isActive = MV_TRUE;
@@ -3294,9 +3299,11 @@ MV_BOOL mvBoardConfigAutoDetectEnabled()
 MV_STATUS mvBoardConfigVerify(MV_CONFIG_TYPE_ID field, MV_U8 writeVal)
 {
 	MV_U32 c = mvBoardEthComplexConfigGet();
-	/* 0x2 = SATA1, 0x3 = Unconnected are supported only for A0 */
-	if ((field == MV_CONFIG_LANE1 && (writeVal == 0x2 || writeVal == 0x3)) \
-			&& (mvCtrlRevGet() <= MV_88F66X0_Z3_ID)) {
+	/* Config Lane1: 0x2 = SATA1, 0x3 = Unconnected are supported only for A0
+	** config MAC1 to RGMII0 are supported only for A0 */
+	if (((field == MV_CONFIG_LANE1 && (writeVal == 0x2 || writeVal == 0x3)) ||
+			(field == MV_CONFIG_MAC1 && writeVal == 0x3)) &&
+			(mvCtrlRevGet() <= MV_88F66X0_Z3_ID)) {
 		mvOsPrintf("Error: this option is not supported in Z stepping revision\n");
 		return MV_ERROR;
 	}
@@ -3304,6 +3311,17 @@ MV_STATUS mvBoardConfigVerify(MV_CONFIG_TYPE_ID field, MV_U8 writeVal)
 		mvOsPrintf("Warning: MAC1 is connected to PON Serdes\n");
 		return MV_ERROR;
 	}
+	/* 0x3 = RGMII0, check if MAC0 is connected to RGMII0 */
+	if (field == MV_CONFIG_MAC1 && writeVal == 0x3 && (c & MV_ETHCOMP_GE_MAC0_2_RGMII0)) {
+		mvOsPrintf("Warning: MAC0 is connected to RGMII0 Module\n");
+		return MV_ERROR;
+	}
+	/* 0x2 = RGMII0, check if MAC1 is connected to RGMII0 */
+	if (field == MV_CONFIG_MAC0 && writeVal == 0x2 && (c & MV_ETHCOMP_GE_MAC1_2_RGMII0)) {
+		mvOsPrintf("Warning: MAC1 is connected to RGMII0 Module\n");
+		return MV_ERROR;
+	}
+
 	return MV_OK;
 
 }
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
index a5e0b5a..be2e259 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.c
@@ -530,10 +530,10 @@ MV_VOID mvCtrlSmiMasterSet(MV_SMI_CTRL smiCtrl)
 		* Test board configuration relevant to MPP group 4, and derive the correct group type */
 
 		if (isRefClkOut)	/* add first REF_CLK_OUT group type */
-			groupTypeSelect += GE1_CPU_SMI_CTRL_REF_CLK_OUT;
+			groupTypeSelect += GE1_RGMII1_CPU_SMI_CTRL_REF_CLK_OUT;
 
 		if (smiCtrl == SWITCH_SMI_CTRL)	/* add first SW_SMI group type */
-			groupTypeSelect += GE1_SW_SMI_CTRL_TDM_LQ_UNIT;
+			groupTypeSelect += GE1_RGMII1_SW_SMI_CTRL_TDM_LQ_UNIT;
 
 		if (isSPI1Enabled)	/* add first SPI1 group type */
 			groupTypeSelect += SPI1_CPU_SMI_CTRL_TDM_LQ_UNIT;
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h
index 9c23927..568fe61 100755
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvLib.h
@@ -179,6 +179,7 @@ typedef enum {
 	MV_ETHCOMP_P2P_MAC_2_PON_ETH_SERDES	=	BIT16,
 	MV_ETHCOMP_P2P_MAC0_2_SW_SPEED_2G	=	BIT17,
 	MV_ETHCOMP_GE_MAC0_2_COMPHY_SPEED_2G	=	BIT18,
+	MV_ETHCOMP_GE_MAC1_2_RGMII0		=	BIT19,
 } MV_ETH_COMPLEX_TOPOLOGY;
 
 typedef enum {
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h
index 2f033cc..aa70576 100644
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEnvSpec.h
@@ -304,36 +304,36 @@ typedef enum {
 } MV_GROUP_2_TYPE;
 
 #define MPP_GROUP_3_TYPE { \
-	0x22222222,     /* GE1  */ \
+	0x22222222,     /* GE1_RGMII1  */ \
 	0x00333333,     /* SDIO	*/ \
 	0x33000000,     /* SPI1_BOOT (SPI1_[CSn(0),MOSI])	*/ \
 	0x33333333,     /* SDIO & SPI1 */ \
 }
 
 typedef enum {
-	GE1_UNIT,
+	GE1_RGMII1_UNIT,
 	SDIO_UNIT,
 	SPI1_UNIT,
 	SDIO_SPI1_UNIT,
 } MV_GROUP_3_TYPE;
 
 #define MPP_GROUP_4_TYPE { \
-	0x04422222,     /* GE1,  CPU SMI CONTROL,    TDM_LQ_UNIT */ \
-	0x44422222,     /* GE1,  CPU SMI CONTROL,    REF_CLK_OUT */ \
-	0x05522222,     /* GE1,  SWITCH SMI CONTROL, TDM_LQ_UNIT */ \
-	0x45522222,     /* GE1,  SWITCH SMI CONTROL, REF_CLK_OUT */ \
-	0x04423333,     /* SPI1, CPU SMI CONTROL,    TDM_LQ_UNIT */ \
-	0x44423333,     /* SPI1, CPU SMI CONTROL,    REF_CLK_OUT */ \
-	0x05523333,     /* SPI1, SWITCH SMI CONTROL, TDM_LQ_UNIT */ \
-	0x45523333,     /* SPI1, SWITCH SMI CONTROL, REF_CLK_OUT */ \
-	0x00023330,	/* SPI1, NO SMI CONTROL, SD_Stat (GPIO_input) */\
+	0x04422222,	/* GE1_RGMII1,	CPU SMI CONTROL,	TDM_LQ_UNIT */		\
+	0x44422222,	/* GE1_RGMII1,	CPU SMI CONTROL,	REF_CLK_OUT */		\
+	0x05522222,	/* GE1_RGMII1,	SWITCH SMI CONTROL,	TDM_LQ_UNIT */		\
+	0x45522222,	/* GE1_RGMII1,	SWITCH SMI CONTROL,	REF_CLK_OUT */		\
+	0x04423333,	/* SPI1,	CPU SMI CONTROL,	TDM_LQ_UNIT */		\
+	0x44423333,	/* SPI1,	CPU SMI CONTROL,	REF_CLK_OUT */		\
+	0x05523333,	/* SPI1,	SWITCH SMI CONTROL,	TDM_LQ_UNIT */		\
+	0x45523333,	/* SPI1,	SWITCH SMI CONTROL,	REF_CLK_OUT */		\
+	0x00023330,	/* SPI1,	NO SMI CONTROL,		SD_Stat (GPIO_input) */	\
 }
 
 typedef enum {
-	GE1_CPU_SMI_CTRL_TDM_LQ_UNIT,
-	GE1_CPU_SMI_CTRL_REF_CLK_OUT,
-	GE1_SW_SMI_CTRL_TDM_LQ_UNIT,
-	GE1_SW_SMI_CTRL_REF_CLK_OUT,
+	GE1_RGMII1_CPU_SMI_CTRL_TDM_LQ_UNIT,
+	GE1_RGMII1_CPU_SMI_CTRL_REF_CLK_OUT,
+	GE1_RGMII1_SW_SMI_CTRL_TDM_LQ_UNIT,
+	GE1_RGMII1_SW_SMI_CTRL_REF_CLK_OUT,
 	SPI1_CPU_SMI_CTRL_TDM_LQ_UNIT,
 	SPI1_CPU_SMI_CTRL_REF_CLK_OUT,
 	SPI1_SW_SMI_CTRL_TDM_LQ_UNIT,
@@ -342,39 +342,49 @@ typedef enum {
 } MV_GROUP_4_TYPE;
 
 #define MPP_GROUP_5_TYPE { \
-	0x22122220,     /* GE0      , PON_TX_FAULT */ \
-	0x22122222,     /* GE0      , PON_CLK_OUT */ \
-	0x44122220,     /* SWITCH_P4, PON_TX_FAULT	 */ \
-	0x44122222,     /* SWITCH_P4, PON_CLK_OUT	 */ \
+	0x22122220,	/* GE0,		PON_TX_FAULT	*/ \
+	0x22122222,	/* GE0,		PON_CLK_OUT	*/ \
+	0x33122220,	/* GE1_RGMII0,	PON_TX_FAULT	*/ \
+	0x33122222,	/* GE1_RGMII0,	PON_CLK_OUT	*/ \
+	0x44122220,	/* SWITCH_P4,	PON_TX_FAULT	*/ \
+	0x44122222,	/* SWITCH_P4,	PON_CLK_OUT	*/ \
 }
 typedef enum {
 	GE0_UNIT_PON_TX_FAULT,
 	GE0_UNIT_PON_CLK_OUT,
+	GE1_RGMII0_UNIT_PON_TX_FAULT,
+	GE1_RGMII0_UNIT_PON_CLK_OUT,
 	SWITCH_P4_PON_TX_FAULT,
 	SWITCH_P4_PON_CLK_OUT,
 } MV_GROUP_5_TYPE;
 
 #define MPP_GROUP_6_TYPE { \
-	0x22222222,     /* GE0  */ \
+	0x22222222,     /* GE0		*/ \
+	0x33333333,     /* GE1_RGMII0	*/ \
 	0x44444444,     /* SWITCH_P4	*/ \
 }
 
 typedef enum {
 	GE0_UNIT,
+	GE1_RGMII0_UNIT,
 	SWITCH_P4,
 } MV_GROUP_6_TYPE;
 
 #define MPP_GROUP_7_TYPE { \
-	0x44444444,     /* SWITCH_P4 , LED_MATRIX       */ \
-	0x44444422,     /* GE0	     , LED_MATRIX       */ \
-	0x20220244,     /* SWITCH_P4 , UA1 ,  PTP       */ \
-	0x20220222,     /* GE0	     , UA1 ,  PTP       */ \
+	0x44444444,	/* SWITCH_P4,	LED_MATRIX		*/ \
+	0x44444433,	/* GE1_RGMII0,	LED_MATRIX		*/ \
+	0x44444422,	/* GE0,		LED_MATRIX		*/ \
+	0x20220244,	/* SWITCH_P4,	UA1,		PTP	*/ \
+	0x20220233,	/* GE1_RGMII0,	UA1,		PTP	*/ \
+	0x20220222,	/* GE0,		UA1,		PTP	*/ \
 }
 
 typedef enum {
 	SWITCH_P4_LED_MATRIX,
+	GE1_RGMII0_UNIT_LED_MATRIX,
 	GE0_UNIT_LED_MATRIX,
 	SWITCH_P4_UA1_PTP,
+	GE1_RGMII0_UNIT_UA1_PTP,
 	GE0_UNIT_UA1_PTP,
 } MV_GROUP_7_TYPE;
 
diff --git a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEthCompLib.c b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEthCompLib.c
index 773e452..5202c02 100755
--- a/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEthCompLib.c
+++ b/arch/arm/mach-avantalp/avanta_lp_family/ctrlEnv/mvCtrlEthCompLib.c
@@ -421,7 +421,7 @@ static void mvEthComplexMac1ToPonSerdes(MV_U32 port)
 	mvEthComplexGponPhySrcSet(0x1);
 }
 
-static void mvEthComplexMacToRgmii(MV_U32 port, MV_U32 phy)
+static void mvEthComplexMacToRgmii(MV_U32 port)
 {
 	mvEthComplexGbePortSrcSet(port, 0x0);
 	mvEthComplexPortDpClkSrcSet(port, 0x1);
@@ -456,7 +456,7 @@ MV_STATUS mvEthComplexInit(MV_U32 ethCompConfig)
 		mvEthComplexMacToGbePhy(0, 0, mvBoardPhyAddrGet(0));
 
 	if (c & MV_ETHCOMP_GE_MAC0_2_RGMII0)
-		mvEthComplexMacToRgmii(0, mvBoardPhyAddrGet(0));
+		mvEthComplexMacToRgmii(0);
 
 	if (c & MV_ETHCOMP_GE_MAC0_2_COMPHY_1)
 		mvEthComplexMacToComPhy(0, 1, c);
@@ -473,8 +473,8 @@ MV_STATUS mvEthComplexInit(MV_U32 ethCompConfig)
 	if (c & MV_ETHCOMP_GE_MAC1_2_GE_PHY_P3)
 		mvEthComplexMacToGbePhy(1, 3, mvBoardPhyAddrGet(1));
 
-	if (c & MV_ETHCOMP_GE_MAC1_2_RGMII1)
-		mvEthComplexMacToRgmii(1, mvBoardPhyAddrGet(1));
+	if (c & (MV_ETHCOMP_GE_MAC1_2_RGMII1 | MV_ETHCOMP_GE_MAC1_2_RGMII0))
+		mvEthComplexMacToRgmii(1);
 
 	if (c & MV_ETHCOMP_GE_MAC1_2_PON_ETH_SERDES)
 		mvEthComplexMac1ToPonSerdes(1);
-- 
1.7.5.4

