From 1cbc32f390530e6fec5304d28909ddeb01a7f5a7 Mon Sep 17 00:00:00 2001
From: Victor Gu <xigu@marvell.com>
Date: Sun, 23 Feb 2014 13:00:32 +0800
Subject: [PATCH 1383/1825] alp: tools: Imported Lantiq DFEV mv_voice_tool.

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit edd5cf93d5d1935c5c65de665cebc07007e8a6e4

    This commit integrates Lantiq DFEV susbsystem
    testing tool into LSP.

Signed-off-by: Piotr Ziecik <kosmo@semihalf.com>
Signed-off-by: Victor Gu <xigu@marvell.com>:

Change-Id: If93aef26db701e21d672a682c4f02b278fa7bb9b
Reviewed-on: http://vgitil04.il.marvell.com:8080/5873
Reviewed-by: Yehuda Yitschak <yehuday@marvell.com>
Tested-by: Yehuda Yitschak <yehuday@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 tools/voice/lantiq-dfev/Makefile        |   23 +
 tools/voice/lantiq-dfev/README          |  113 ++++++
 tools/voice/lantiq-dfev/libtapi-fw.c    |  103 +++++
 tools/voice/lantiq-dfev/libtapi.c       |  668 +++++++++++++++++++++++++++++++
 tools/voice/lantiq-dfev/libtapi.h       |  342 ++++++++++++++++
 tools/voice/lantiq-dfev/mv_voice_tool.c |  612 ++++++++++++++++++++++++++++
 6 files changed, 1861 insertions(+), 0 deletions(-)
 create mode 100644 tools/voice/lantiq-dfev/Makefile
 create mode 100644 tools/voice/lantiq-dfev/README
 create mode 100644 tools/voice/lantiq-dfev/libtapi-fw.c
 create mode 100644 tools/voice/lantiq-dfev/libtapi.c
 create mode 100644 tools/voice/lantiq-dfev/libtapi.h
 create mode 100644 tools/voice/lantiq-dfev/mv_voice_tool.c

diff --git a/tools/voice/lantiq-dfev/Makefile b/tools/voice/lantiq-dfev/Makefile
new file mode 100644
index 0000000..8b2b948
--- /dev/null
+++ b/tools/voice/lantiq-dfev/Makefile
@@ -0,0 +1,23 @@
+CC := $(CROSS_COMPILE)gcc
+LD := $(CROSS_COMPILE)ld
+AR := $(CROSS_COMPILE)ar
+
+LIBTAPI := libtapi.o libtapi-fw.o
+LIBS := libtapi.a
+TOOL := mv_voice_tool
+
+CFLAGS += $(EXTRA_CFLAGS)
+
+all:	$(TOOL)
+
+$(TOOL): $(TOOL).c $(LIBS)
+	$(CC) $(CFLAGS) -static -o mv_voice_tool $^
+
+libtapi.o: libtapi.c
+	$(CC) $(CFLAGS) -static -c -o $@ $<
+
+libtapi.a: $(LIBTAPI)
+	$(AR) rcs $@ $^
+
+clean:
+	rm -f *.o *.a mv_voice_tool
diff --git a/tools/voice/lantiq-dfev/README b/tools/voice/lantiq-dfev/README
new file mode 100644
index 0000000..c119d11
--- /dev/null
+++ b/tools/voice/lantiq-dfev/README
@@ -0,0 +1,113 @@
++------------------------------------------------------+
+| How to compile Lantiq DFEV drivers and mv_voice_tool |
++------------------------------------------------------+
+
+1. Unpack configure and build LSP using avanta_lp_amp_defconfig.
+   Make sure that the following options are configured as shown below:
+
+	CONFIG_DFEV_SLIC_SUPPORT=y
+	# CONFIG_MV_IPC_NET is not set
+
+2. Build Lantiq lib_ifxos-1.5.17:
+
+	$ cd lib_ifxos-1.5.17
+	$ ./configure								\
+		--host=arm-marvell-linux-gnueabi				\
+		--enable-linux-26						\
+		--enable-kernelbuild=<path-to-lsp>				\
+		--enable-kernelincl=<path-to-lsp>/include			\
+		--with-kernel-module
+	$ make
+	$ ls -l src/drv_ifxos.ko
+
+3. Build Lantiq drv_tapi-4.11.0.1:
+
+	$ cd drv_tapi-4.11.0.1
+	$ ./configure								\
+		--host=arm-marvell-linux-gnueabi				\
+		--enable-linux-26						\
+		--with-kernel-build=<path-to-lsp>				\
+		--with-kernel-incl=<path-to-lsp>/include			\
+		--with-kernel-module						\
+		--with-ifxos-incl=<path-to-lib_ifxos-1.5.17>/src/include	\
+		--enable-module							\
+		--enable-tapi4							\
+		--enable-cont-measurement					\
+		--enable-dtmf							\
+		--enable-hsm							\
+		--enable-metering						\
+		--enable-nlt							\
+		--enable-pcm							\
+		--enable-phone-detection					\
+		--enable-voice
+	$ make
+	$ ls -l src/drv_tapi.ko
+
+4. Build Lantiq drv_sdd-1.0.3.0:
+
+	$ cd drv_sdd-1.0.3.0
+	$ ./configure								\
+		--host=arm-marvell-linux-gnueabi				\
+		--enable-linux-26						\
+		--with-kernel-build=<path-to-lsp>				\
+		--with-kernel-incl=<path-to-lsp>/include			\
+		--with-ifxos-incl=<path-to-lib_ifxos-1.5.17>/src/include	\
+		--with-tapi-incl=<path-to-drv_tapi-4.11.0.1>/include
+	$ make
+	$ ls -l src/drv_sdd.ko
+
+5. Build DFEV driver:
+
+	$ cd drv_dfev
+	$ make -C <path-to-lsp> M=$PWD						\
+		ARCH=arm CROSS_COMPILE=arm-marvell-linux-gnueabi-		\
+		DRV_SDD=<path-to-drv_sdd-1.0.3.0>				\
+		LIB_IFXOS=<path-to-lib_ifxos-1.5.17>
+	$ ls -l drv_dfev.ko
+
+6. Build VMMC interface:
+
+	$ cd vmmc_if
+	$ make -C <path-to-lsp> M=$PWD						\
+		ARCH=arm CROSS_COMPILE=arm-marvell-linux-gnueabi-		\
+		DRV_SDD=<path-to-drv_sdd-1.0.3.0>				\
+		LIB_IFXOS=<path-to-lib_ifxos-1.5.17>
+	$ ls -l vmmc_if.ko
+
+7. Build mv_voice_tool for Lantiq SLIC:
+
+	$ cd mv_voice_tool
+	$ make ARCH=arm CROSS_COMPILE=arm-marvell-linux-gnueabi-		\
+		EXTRA_CFLAGS="-I<path-to-lib_ifxos-1.5.17>/src/include		\
+			-I<path-to-drv_tapi-4.11.0.1>/include			\
+			-I<path-to-drv_sdd-1.0.3.0>/include			\
+			-I<path-to-lsp>/arch/arm/plat-armada/mv_drivers_lsp/mv_phone"
+	$ ls -l mv_voice_tool
+
++---------------------------------------------+
+| How to run Lantiq drivers and mv_voice_tool |
++---------------------------------------------+
+
+1. Copy all modules and mv_voice_tool to the target and run it in AMP mode.
+
+2. Make device nodes under /dev:
+	# mknod /dev/tal c 10 74
+	# mknod /dev/sdd c 253 0
+
+3a. Load drivers (on Host CPU):
+	# insmod drv_ifxos.ko && insmod drv_tapi.ko && insmod drv_sdd.ko && insmod vmmc_if.ko
+
+3b. Load drivers (on DFEV CPU):
+	# insmod drv_dfev.ko
+
+4. Run mv_voice_tool (on Host CPU):
+	# ./mv_voice_tool
+
++------------+
+| Known Bugs |
++------------+
+
+1. The demo uses IRQ instead of FIQ to handle SDD firmware calls
+   due to problems with FIQ interrupts on Avanta-LP. As result
+   SDD real-time timing requirements cannot be achieved and silent
+   "clicking" sound might be heard on the line.
diff --git a/tools/voice/lantiq-dfev/libtapi-fw.c b/tools/voice/lantiq-dfev/libtapi-fw.c
new file mode 100644
index 0000000..2fce16f
--- /dev/null
+++ b/tools/voice/lantiq-dfev/libtapi-fw.c
@@ -0,0 +1,103 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+********************************************************************************
+   Marvell Commercial License Option
+
+   If you received this File from Marvell and you have entered into a commercial
+   license agreement (a "Commercial License") with Marvell, the File is licensed
+   to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+********************************************************************************
+   Marvell BSD License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File under the following licensing terms.
+   Redistribution and use in source and binary forms, with or without modification,
+   are permitted provided that the following conditions are met:
+
+*   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+*   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+*   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+   ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+   ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+unsigned char tapi_bbd_blob[] = {
+	/* Source: R600.BIN */
+	0x00, 0x0A, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x21, 0x62, 0x62, 0x64,
+	0x4D, 0x41, 0x52, 0x56, 0x0D, 0x07, 0x0A, 0xFF, 0x10, 0x01, 0x00, 0x01,
+	0x00, 0x00, 0x01, 0x08, 0x00, 0x00, 0x80, 0xE7, 0x31, 0xE1, 0x6F, 0xE8,
+	0x34, 0x45, 0xDA, 0x40, 0xBB, 0xD9, 0xEA, 0x68, 0x2A, 0x57, 0x2C, 0x9A,
+	0xDA, 0x8D, 0xF2, 0xF2, 0x4C, 0x9F, 0xEA, 0x2D, 0x40, 0x00, 0x7F, 0xFF,
+	0xF2, 0x5B, 0x02, 0x07, 0xFF, 0xA7, 0xFF, 0xDC, 0xFF, 0x84, 0x00, 0x00,
+	0x00, 0x8A, 0xFF, 0x5C, 0x00, 0x7C, 0xFF, 0xC7, 0x22, 0x12, 0xE8, 0x41,
+	0x33, 0xD7, 0xC5, 0x30, 0x20, 0xFF, 0x99, 0xA7, 0x16, 0x98, 0x3B, 0x70,
+	0xD0, 0x84, 0x46, 0xD1, 0xAC, 0x0C, 0x24, 0x4E, 0x8D, 0xA3, 0x14, 0xD5,
+	0x5E, 0x22, 0xB3, 0xC4, 0x73, 0x20, 0xA2, 0x69, 0x65, 0x84, 0x8C, 0x54,
+	0x5C, 0x67, 0x6E, 0x42, 0x8D, 0xD8, 0x7E, 0xE9, 0x7F, 0x0E, 0x80, 0xBB,
+	0x7F, 0xFF, 0x7F, 0xF4, 0x37, 0xED, 0x28, 0xE4, 0x7F, 0xFF, 0x20, 0x00,
+	0x7F, 0xFF, 0xFA, 0xF1, 0xFE, 0x7F, 0x01, 0x66, 0xFD, 0xB2, 0x00, 0xBD,
+	0xFF, 0x43, 0x00, 0xF4, 0xFF, 0x26, 0x00, 0x92, 0xFF, 0xBF, 0x24, 0xF1,
+	0xE8, 0x9D, 0x37, 0x7C, 0xC8, 0x52, 0x21, 0xC4, 0x9B, 0xFA, 0x14, 0xF2,
+	0x3B, 0x70, 0xD0, 0x84, 0x46, 0xD1, 0xAC, 0x0C, 0x24, 0x4E, 0x8D, 0xA3,
+	0x14, 0xD5, 0x5D, 0x96, 0xB3, 0xFD, 0x72, 0xC6, 0xA1, 0xD6, 0x65, 0x42,
+	0x8B, 0xE5, 0x5C, 0x7A, 0x7B, 0x75, 0x7F, 0x9E, 0x25, 0xF3, 0x4A, 0xC8,
+	0x7F, 0xFF, 0xFD, 0xF9, 0x2C, 0x2F, 0x1B, 0x04, 0xF2, 0x1D, 0x08, 0x13,
+	0xFA, 0x2D, 0x03, 0xD9, 0xFD, 0x03, 0x02, 0x02, 0xFE, 0x25, 0x01, 0x4E,
+	0x7F, 0xCF, 0x20, 0x00, 0xDB, 0x06, 0x4B, 0x72, 0xD0, 0x1C, 0x39, 0x99,
+	0x0A, 0x3D, 0x09, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0xC9,
+	0x00, 0x06, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00,
+	0x2D, 0xE4, 0x7C, 0xF4, 0x3B, 0x6F, 0x1A, 0xD6, 0xC4, 0x5F, 0x12, 0x0B,
+	0x0B, 0x85, 0x00, 0x00, 0x12, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x18,
+	0x04, 0x00, 0x05, 0x14, 0x04, 0x00, 0x03, 0x33, 0x3F, 0x1C, 0x06, 0x66,
+	0x0A, 0xAA, 0x48, 0xB4, 0x2E, 0xE0, 0x37, 0x89, 0x00, 0x00, 0x4A, 0x3D,
+	0x12, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1C, 0x04, 0x00, 0x04, 0x18,
+	0x99, 0x90, 0xB8, 0x28, 0xF7, 0xC8, 0x00, 0xC8, 0x17, 0x0A, 0x0A, 0x3D,
+	0x17, 0x0A, 0x07, 0xAE, 0x23, 0x8E, 0x19, 0x99, 0x7E, 0xB8, 0x26, 0x66,
+	0x12, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x04, 0x00, 0x06, 0x08,
+	0x55, 0x55, 0x33, 0x33, 0x00, 0x1B, 0x14, 0x28, 0x12, 0x00, 0x00, 0x01,
+	0x00, 0x00, 0x00, 0x0C, 0x04, 0x00, 0x0C, 0x08, 0x00, 0x14, 0x00, 0xFF,
+	0xDA, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+
+unsigned int tapi_bbd_blob_size = sizeof(tapi_bbd_blob);
diff --git a/tools/voice/lantiq-dfev/libtapi.c b/tools/voice/lantiq-dfev/libtapi.c
new file mode 100644
index 0000000..9b781da
--- /dev/null
+++ b/tools/voice/lantiq-dfev/libtapi.c
@@ -0,0 +1,668 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+********************************************************************************
+   Marvell Commercial License Option
+
+   If you received this File from Marvell and you have entered into a commercial
+   license agreement (a "Commercial License") with Marvell, the File is licensed
+   to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+********************************************************************************
+   Marvell BSD License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File under the following licensing terms.
+   Redistribution and use in source and binary forms, with or without modification,
+   are permitted provided that the following conditions are met:
+
+*   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+*   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+*   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+   ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+   ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#include <stdio.h>
+#include <string.h>
+#include <malloc.h>
+#include <fcntl.h>
+#include <poll.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#include <ifx_types.h>
+#include <drv_tapi_io.h>
+#include <drv_sdd_io.h>
+
+#include "libtapi.h"
+
+#define ARRAY_SIZE(array)       (sizeof(array) / sizeof((array)[0]))
+
+struct tapi_handle {
+	int fd;
+};
+
+static const IFX_TAPI_EVENT_ID_t tapi_event_tanslation_table[] = {
+	[TAPI_EVENT_NONE]               = IFX_TAPI_EVENT_NONE,
+	[TAPI_EVENT_IO_GENERAL_NONE]    = IFX_TAPI_EVENT_IO_GENERAL_NONE,
+	[TAPI_EVENT_IO_INTERRUPT_NONE]  = IFX_TAPI_EVENT_IO_INTERRUPT_NONE,
+	[TAPI_EVENT_FXS_NONE]           = IFX_TAPI_EVENT_FXS_NONE,
+	[TAPI_EVENT_FXS_RING]           = IFX_TAPI_EVENT_FXS_RING,
+	[TAPI_EVENT_FXS_RINGBURST_END]  = IFX_TAPI_EVENT_FXS_RINGBURST_END,
+	[TAPI_EVENT_FXS_RINGING_END]    = IFX_TAPI_EVENT_FXS_RINGING_END,
+	[TAPI_EVENT_FXS_ONHOOK]         = IFX_TAPI_EVENT_FXS_ONHOOK,
+	[TAPI_EVENT_FXS_OFFHOOK]        = IFX_TAPI_EVENT_FXS_OFFHOOK,
+	[TAPI_EVENT_FXS_FLASH]          = IFX_TAPI_EVENT_FXS_FLASH,
+	[TAPI_EVENT_FXS_ONHOOK_INT]     = IFX_TAPI_EVENT_FXS_ONHOOK_INT,
+	[TAPI_EVENT_FXS_OFFHOOK_INT]    = IFX_TAPI_EVENT_FXS_OFFHOOK_INT,
+	[TAPI_EVENT_CONTMEASUREMENT]    = IFX_TAPI_EVENT_CONTMEASUREMENT,
+	[TAPI_EVENT_FXS_RAW_ONHOOK]     = IFX_TAPI_EVENT_FXS_RAW_ONHOOK,
+	[TAPI_EVENT_FXS_RAW_OFFHOOK]    = IFX_TAPI_EVENT_FXS_RAW_OFFHOOK,
+	[TAPI_EVENT_FXS_LINE_MODE]      = IFX_TAPI_EVENT_FXS_LINE_MODE,
+	[TAPI_EVENT_FXS_COMTEL_END]     = IFX_TAPI_EVENT_FXS_COMTEL_END,
+	[TAPI_EVENT_FXO_NONE]           = IFX_TAPI_EVENT_FXO_NONE,
+	[TAPI_EVENT_FXO_BAT_FEEDED]     = IFX_TAPI_EVENT_FXO_BAT_FEEDED,
+	[TAPI_EVENT_FXO_BAT_DROPPED]    = IFX_TAPI_EVENT_FXO_BAT_DROPPED,
+	[TAPI_EVENT_FXO_POLARITY]       = IFX_TAPI_EVENT_FXO_POLARITY,
+	[TAPI_EVENT_FXO_RING_START]     = IFX_TAPI_EVENT_FXO_RING_START,
+	[TAPI_EVENT_FXO_RING_STOP]      = IFX_TAPI_EVENT_FXO_RING_STOP,
+	[TAPI_EVENT_FXO_OSI]            = IFX_TAPI_EVENT_FXO_OSI,
+	[TAPI_EVENT_FXO_APOH]           = IFX_TAPI_EVENT_FXO_APOH,
+	[TAPI_EVENT_FXO_NOPOH]          = IFX_TAPI_EVENT_FXO_NOPOH,
+	[TAPI_EVENT_LT_GR909_RDY]       = IFX_TAPI_EVENT_LT_GR909_RDY,
+	[TAPI_EVENT_NLT_END]            = IFX_TAPI_EVENT_NLT_END,
+	[TAPI_EVENT_LINE_MEASURE_CAPACITANCE_RDY] =
+		IFX_TAPI_EVENT_LINE_MEASURE_CAPACITANCE_RDY,
+	[TAPI_EVENT_LINE_MEASURE_CAPACITANCE_GND_RDY] =
+		IFX_TAPI_EVENT_LINE_MEASURE_CAPACITANCE_GND_RDY,
+	[TAPI_EVENT_PULSE_NONE] = IFX_TAPI_EVENT_PULSE_NONE,
+	[TAPI_EVENT_PULSE_DIGIT]        = IFX_TAPI_EVENT_PULSE_DIGIT,
+	[TAPI_EVENT_PULSE_START]        = IFX_TAPI_EVENT_PULSE_START,
+	[TAPI_EVENT_DTMF_NONE]          = IFX_TAPI_EVENT_DTMF_NONE,
+	[TAPI_EVENT_DTMF_DIGIT]         = IFX_TAPI_EVENT_DTMF_DIGIT,
+	[TAPI_EVENT_DTMF_END]           = IFX_TAPI_EVENT_DTMF_END,
+	[TAPI_EVENT_CALIBRATION_NONE]   = IFX_TAPI_EVENT_CALIBRATION_NONE,
+	[TAPI_EVENT_CALIBRATION_END]    = IFX_TAPI_EVENT_CALIBRATION_END,
+	[TAPI_EVENT_CALIBRATION_END_INT] =
+		IFX_TAPI_EVENT_CALIBRATION_END_INT,
+	[TAPI_EVENT_CALIBRATION_END_SINT] =
+		IFX_TAPI_EVENT_CALIBRATION_END_SINT,
+	[TAPI_EVENT_METERING_NONE]      = IFX_TAPI_EVENT_METERING_NONE,
+	[TAPI_EVENT_METERING_END]       = IFX_TAPI_EVENT_METERING_END,
+	[TAPI_EVENT_CID_TX_NONE]        = IFX_TAPI_EVENT_CID_TX_NONE,
+	[TAPI_EVENT_CID_TX_SEQ_START]   = IFX_TAPI_EVENT_CID_TX_SEQ_START,
+	[TAPI_EVENT_CID_TX_SEQ_END]     = IFX_TAPI_EVENT_CID_TX_SEQ_END,
+	[TAPI_EVENT_CID_TX_INFO_START]  = IFX_TAPI_EVENT_CID_TX_INFO_START,
+	[TAPI_EVENT_CID_TX_INFO_END]    = IFX_TAPI_EVENT_CID_TX_INFO_END,
+	[TAPI_EVENT_CID_TX_NOACK_ERR]   = IFX_TAPI_EVENT_CID_TX_NOACK_ERR,
+	[TAPI_EVENT_CID_TX_RINGCAD_ERR] = IFX_TAPI_EVENT_CID_TX_RINGCAD_ERR,
+	[TAPI_EVENT_CID_TX_UNDERRUN_ERR] =
+		IFX_TAPI_EVENT_CID_TX_UNDERRUN_ERR,
+	[TAPI_EVENT_CID_TX_NOACK2_ERR]  = IFX_TAPI_EVENT_CID_TX_NOACK2_ERR,
+	[TAPI_EVENT_CIDSM_END]          = IFX_TAPI_EVENT_CIDSM_END,
+	[TAPI_EVENT_CID_TX_END]         = IFX_TAPI_EVENT_CID_TX_END,
+	[TAPI_EVENT_CID_RX_NONE]        = IFX_TAPI_EVENT_CID_RX_NONE,
+	[TAPI_EVENT_CID_RX_CAS]         = IFX_TAPI_EVENT_CID_RX_CAS,
+	[TAPI_EVENT_CID_RX_END]         = IFX_TAPI_EVENT_CID_RX_END,
+	[TAPI_EVENT_CID_RX_CD]          = IFX_TAPI_EVENT_CID_RX_CD,
+	[TAPI_EVENT_CID_RX_ERROR_READ]  = IFX_TAPI_EVENT_CID_RX_ERROR_READ,
+	[TAPI_EVENT_CID_RX_ERROR1]      = IFX_TAPI_EVENT_CID_RX_ERROR1,
+	[TAPI_EVENT_CID_RX_ERROR2]      = IFX_TAPI_EVENT_CID_RX_ERROR2,
+	[TAPI_EVENT_TONE_GEN_NONE]      = IFX_TAPI_EVENT_TONE_GEN_NONE,
+	[TAPI_EVENT_TONE_GEN_BUSY]      = IFX_TAPI_EVENT_TONE_GEN_BUSY,
+	[TAPI_EVENT_TONE_GEN_END]       = IFX_TAPI_EVENT_TONE_GEN_END,
+	[TAPI_EVENT_TONE_GEN_END_RAW]   = IFX_TAPI_EVENT_TONE_GEN_END_RAW,
+	[TAPI_EVENT_TONE_DET_NONE]      = IFX_TAPI_EVENT_TONE_DET_NONE,
+	[TAPI_EVENT_TONE_DET_RECEIVE]   = IFX_TAPI_EVENT_TONE_DET_RECEIVE,
+	[TAPI_EVENT_TONE_DET_TRANSMIT]  = IFX_TAPI_EVENT_TONE_DET_TRANSMIT,
+	[TAPI_EVENT_TONE_DET_CPT]       = IFX_TAPI_EVENT_TONE_DET_CPT,
+	[TAPI_EVENT_TONE_DET_CPT_END]   = IFX_TAPI_EVENT_TONE_DET_CPT_END,
+	[TAPI_EVENT_TONE_DET_MF_R2_START] =
+		IFX_TAPI_EVENT_TONE_DET_MF_R2_START,
+	[TAPI_EVENT_TONE_DET_MF_R2_END] = IFX_TAPI_EVENT_TONE_DET_MF_R2_END,
+	[TAPI_EVENT_FAXMODEM_NONE]      = IFX_TAPI_EVENT_FAXMODEM_NONE,
+	[TAPI_EVENT_FAXMODEM_DIS]       = IFX_TAPI_EVENT_FAXMODEM_DIS,
+	[TAPI_EVENT_FAXMODEM_CED]       = IFX_TAPI_EVENT_FAXMODEM_CED,
+	[TAPI_EVENT_FAXMODEM_PR]        = IFX_TAPI_EVENT_FAXMODEM_PR,
+	[TAPI_EVENT_FAXMODEM_AM]        = IFX_TAPI_EVENT_FAXMODEM_AM,
+	[TAPI_EVENT_FAXMODEM_CNGFAX]    = IFX_TAPI_EVENT_FAXMODEM_CNGFAX,
+	[TAPI_EVENT_FAXMODEM_CNGMOD]    = IFX_TAPI_EVENT_FAXMODEM_CNGMOD,
+	[TAPI_EVENT_FAXMODEM_V21L]      = IFX_TAPI_EVENT_FAXMODEM_V21L,
+	[TAPI_EVENT_FAXMODEM_V18A]      = IFX_TAPI_EVENT_FAXMODEM_V18A,
+	[TAPI_EVENT_FAXMODEM_V27]       = IFX_TAPI_EVENT_FAXMODEM_V27,
+	[TAPI_EVENT_FAXMODEM_BELL]      = IFX_TAPI_EVENT_FAXMODEM_BELL,
+	[TAPI_EVENT_FAXMODEM_V22]       = IFX_TAPI_EVENT_FAXMODEM_V22,
+	[TAPI_EVENT_FAXMODEM_V22ORBELL] = IFX_TAPI_EVENT_FAXMODEM_V22ORBELL,
+	[TAPI_EVENT_FAXMODEM_V32AC]     = IFX_TAPI_EVENT_FAXMODEM_V32AC,
+	[TAPI_EVENT_FAXMODEM_V8BIS]     = IFX_TAPI_EVENT_FAXMODEM_V8BIS,
+	[TAPI_EVENT_FAXMODEM_HOLDEND]   = IFX_TAPI_EVENT_FAXMODEM_HOLDEND,
+	[TAPI_EVENT_FAXMODEM_CEDEND]    = IFX_TAPI_EVENT_FAXMODEM_CEDEND,
+	[TAPI_EVENT_FAXMODEM_CAS_BELL]  = IFX_TAPI_EVENT_FAXMODEM_CAS_BELL,
+	[TAPI_EVENT_FAXMODEM_V21H]      = IFX_TAPI_EVENT_FAXMODEM_V21H,
+	[TAPI_EVENT_FAXMODEM_VMD]       = IFX_TAPI_EVENT_FAXMODEM_VMD,
+	[TAPI_EVENT_LIN_NONE]           = IFX_TAPI_EVENT_LIN_NONE,
+	[TAPI_EVENT_LIN_UNDERFLOW]      = IFX_TAPI_EVENT_LIN_UNDERFLOW,
+	[TAPI_EVENT_COD_NONE]           = IFX_TAPI_EVENT_COD_NONE,
+	[TAPI_EVENT_COD_DEC_CHG]        = IFX_TAPI_EVENT_COD_DEC_CHG,
+	[TAPI_EVENT_COD_ROOM_NOISE]     = IFX_TAPI_EVENT_COD_ROOM_NOISE,
+	[TAPI_EVENT_COD_ROOM_SILENCE]   = IFX_TAPI_EVENT_COD_ROOM_SILENCE,
+	[TAPI_EVENT_COD_ANNOUNCE_END]   = IFX_TAPI_EVENT_COD_ANNOUNCE_END,
+	[TAPI_EVENT_COD_MOS]            = IFX_TAPI_EVENT_COD_MOS,
+	[TAPI_EVENT_RTP_NONE]           = IFX_TAPI_EVENT_RTP_NONE,
+	[TAPI_EVENT_RTP_FIRST]          = IFX_TAPI_EVENT_RTP_FIRST,
+	[TAPI_EVENT_RTP_EXT_BROKEN]     = IFX_TAPI_EVENT_RTP_EXT_BROKEN,
+	[TAPI_EVENT_RTP_EXT_SSRC_CHANGED] =
+		IFX_TAPI_EVENT_RTP_EXT_SSRC_CHANGED,
+	[TAPI_EVENT_AAL_NONE]           = IFX_TAPI_EVENT_AAL_NONE,
+	[TAPI_EVENT_RFC2833_NONE]       = IFX_TAPI_EVENT_RFC2833_NONE,
+	[TAPI_EVENT_RFC2833_EVENT]      = IFX_TAPI_EVENT_RFC2833_EVENT,
+	[TAPI_EVENT_KPI_NONE]           = IFX_TAPI_EVENT_KPI_NONE,
+	[TAPI_EVENT_KPI_INGRESS_FIFO_FULL] =
+		IFX_TAPI_EVENT_KPI_INGRESS_FIFO_FULL,
+	[TAPI_EVENT_KPI_SOCKET_FAILURE] = IFX_TAPI_EVENT_KPI_SOCKET_FAILURE,
+	[TAPI_EVENT_T38_NONE]           = IFX_TAPI_EVENT_T38_NONE,
+	[TAPI_EVENT_T38_ERROR_GEN]      = IFX_TAPI_EVENT_T38_ERROR_GEN,
+	[TAPI_EVENT_T38_ERROR_OVLD]     = IFX_TAPI_EVENT_T38_ERROR_OVLD,
+	[TAPI_EVENT_T38_ERROR_READ]     = IFX_TAPI_EVENT_T38_ERROR_READ,
+	[TAPI_EVENT_T38_ERROR_WRITE]    = IFX_TAPI_EVENT_T38_ERROR_WRITE,
+	[TAPI_EVENT_T38_ERROR_DATA]     = IFX_TAPI_EVENT_T38_ERROR_DATA,
+	[TAPI_EVENT_T38_ERROR_SETUP]    = IFX_TAPI_EVENT_T38_ERROR_SETUP,
+	[TAPI_EVENT_T38_FDP_REQ]        = IFX_TAPI_EVENT_T38_FDP_REQ,
+	[TAPI_EVENT_T38_STATE_CHANGE]   = IFX_TAPI_EVENT_T38_STATE_CHANGE,
+	[TAPI_EVENT_JB_NONE]            = IFX_TAPI_EVENT_JB_NONE,
+	[TAPI_EVENT_DOWNLOAD_NONE]      = IFX_TAPI_EVENT_DOWNLOAD_NONE,
+	[TAPI_EVENT_INFO_NONE]          = IFX_TAPI_EVENT_INFO_NONE,
+	[TAPI_EVENT_INFO_MBX_CONGESTION] =
+		IFX_TAPI_EVENT_INFO_MBX_CONGESTION,
+	[TAPI_EVENT_DEBUG_NONE]         = IFX_TAPI_EVENT_DEBUG_NONE,
+	[TAPI_EVENT_DEBUG_CERR]         = IFX_TAPI_EVENT_DEBUG_CERR,
+	[TAPI_EVENT_GPIO_HL]            = IFX_TAPI_EVENT_GPIO_HL,
+	[TAPI_EVENT_GPIO_LH]            = IFX_TAPI_EVENT_GPIO_LH,
+	[TAPI_EVENT_LL_DRIVER_NONE]     = IFX_TAPI_EVENT_LL_DRIVER_NONE,
+	[TAPI_EVENT_LL_DRIVER_WD_FAIL]  = IFX_TAPI_EVENT_LL_DRIVER_WD_FAIL,
+	[TAPI_EVENT_FAULT_GENERAL_NONE] = IFX_TAPI_EVENT_FAULT_GENERAL_NONE,
+	[TAPI_EVENT_FAULT_GENERAL]      = IFX_TAPI_EVENT_FAULT_GENERAL,
+	[TAPI_EVENT_FAULT_GENERAL_CHINFO] =
+		IFX_TAPI_EVENT_FAULT_GENERAL_CHINFO,
+	[TAPI_EVENT_FAULT_GENERAL_DEVINFO] =
+		IFX_TAPI_EVENT_FAULT_GENERAL_DEVINFO,
+	[TAPI_EVENT_TYPE_FAULT_GENERAL] = IFX_TAPI_EVENT_TYPE_FAULT_GENERAL,
+	[TAPI_EVENT_FAULT_LINE_NONE]    = IFX_TAPI_EVENT_FAULT_LINE_NONE,
+	[TAPI_EVENT_FAULT_LINE_GK_POS]  = IFX_TAPI_EVENT_FAULT_LINE_GK_POS,
+	[TAPI_EVENT_FAULT_LINE_GK_NEG]  = IFX_TAPI_EVENT_FAULT_LINE_GK_NEG,
+	[TAPI_EVENT_FAULT_LINE_GK_LOW]  = IFX_TAPI_EVENT_FAULT_LINE_GK_LOW,
+	[TAPI_EVENT_FAULT_LINE_GK_HIGH] = IFX_TAPI_EVENT_FAULT_LINE_GK_HIGH,
+	[TAPI_EVENT_FAULT_LINE_OVERTEMP] =
+		IFX_TAPI_EVENT_FAULT_LINE_OVERTEMP,
+	[TAPI_EVENT_FAULT_LINE_OVERCURRENT] =
+		IFX_TAPI_EVENT_FAULT_LINE_OVERCURRENT,
+	[TAPI_EVENT_FAULT_LINE_GK_LOW_INT] =
+		IFX_TAPI_EVENT_FAULT_LINE_GK_LOW_INT,
+	[TAPI_EVENT_FAULT_LINE_GK_HIGH_INT] =
+		IFX_TAPI_EVENT_FAULT_LINE_GK_HIGH_INT,
+	[TAPI_EVENT_FAULT_LINE_GK_LOW_END] =
+		IFX_TAPI_EVENT_FAULT_LINE_GK_LOW_END,
+	[TAPI_EVENT_FAULT_LINE_GK_HIGH_END] =
+		IFX_TAPI_EVENT_FAULT_LINE_GK_HIGH_END,
+	[TAPI_EVENT_FAULT_LINE_OVERTEMP_END] =
+		IFX_TAPI_EVENT_FAULT_LINE_OVERTEMP_END,
+	[TAPI_EVENT_FAULT_HW_NONE]      = IFX_TAPI_EVENT_FAULT_HW_NONE,
+	[TAPI_EVENT_FAULT_HW_SPI_ACCESS] =
+		IFX_TAPI_EVENT_FAULT_HW_SPI_ACCESS,
+	[TAPI_EVENT_FAULT_HW_CLOCK_FAIL] =
+		IFX_TAPI_EVENT_FAULT_HW_CLOCK_FAIL,
+	[TAPI_EVENT_FAULT_HW_CLOCK_FAIL_END] =
+		IFX_TAPI_EVENT_FAULT_HW_CLOCK_FAIL_END,
+	[TAPI_EVENT_FAULT_HW_FAULT]     = IFX_TAPI_EVENT_FAULT_HW_FAULT,
+	[TAPI_EVENT_FAULT_HW_SYNC]      = IFX_TAPI_EVENT_FAULT_HW_SYNC,
+	[TAPI_EVENT_FAULT_HW_RESET]     = IFX_TAPI_EVENT_FAULT_HW_RESET,
+	[TAPI_EVENT_FAULT_HW_SSI_ERR]   = IFX_TAPI_EVENT_FAULT_HW_SSI_ERR,
+	[TAPI_EVENT_FAULT_HW_SSI_ERR_END] =
+		IFX_TAPI_EVENT_FAULT_HW_SSI_ERR_END,
+	[TAPI_EVENT_FAULT_FW_NONE]      = IFX_TAPI_EVENT_FAULT_FW_NONE,
+	[TAPI_EVENT_FAULT_FW_EBO_UF]    = IFX_TAPI_EVENT_FAULT_FW_EBO_UF,
+	[TAPI_EVENT_FAULT_FW_EBO_OF]    = IFX_TAPI_EVENT_FAULT_FW_EBO_OF,
+	[TAPI_EVENT_FAULT_FW_CBO_UF]    = IFX_TAPI_EVENT_FAULT_FW_CBO_UF,
+	[TAPI_EVENT_FAULT_FW_CBO_OF]    = IFX_TAPI_EVENT_FAULT_FW_CBO_OF,
+	[TAPI_EVENT_FAULT_FW_CBI_OF]    = IFX_TAPI_EVENT_FAULT_FW_CBI_OF,
+	[TAPI_EVENT_FAULT_FW_WATCHDOG]  = IFX_TAPI_EVENT_FAULT_FW_WATCHDOG,
+	[TAPI_EVENT_FAULT_SW_NONE]      = IFX_TAPI_EVENT_FAULT_SW_NONE,
+	[TAPI_EVENT_FAULT_HDLC_NONE]    = IFX_TAPI_EVENT_FAULT_HDLC_NONE,
+	[TAPI_EVENT_FAULT_HDLC_FRAME_LENGTH] =
+		IFX_TAPI_EVENT_FAULT_HDLC_FRAME_LENGTH,
+	[TAPI_EVENT_FAULT_HDLC_NO_KPI_PATH] =
+		IFX_TAPI_EVENT_FAULT_HDLC_NO_KPI_PATH,
+	[TAPI_EVENT_FAULT_HDLC_TX_OVERFLOW] =
+		IFX_TAPI_EVENT_FAULT_HDLC_TX_OVERFLOW,
+	[TAPI_EVENT_FAULT_HDLC_DISABLED] =
+		IFX_TAPI_EVENT_FAULT_HDLC_DISABLED,
+};
+
+tapi_handle_t
+tapi_open(const char *tapidev)
+{
+	tapi_handle_t th;
+
+	th = malloc(sizeof(tapi_handle_t));
+	if (th == NULL)
+		return NULL;
+
+	th->fd = open(tapidev, O_RDWR);
+	if (th->fd < 0) {
+		free(th);
+		return NULL;
+	}
+
+	return th;
+}
+
+void
+tapi_close(tapi_handle_t th)
+{
+	close(th->fd);
+	free(th);
+}
+
+int
+tapi_fw_download(tapi_handle_t th, unsigned int device, const char *fwfile)
+{
+	SDD_FW_Download_t fwdl;
+	off_t fwsize;
+	int fwh, r;
+	void *fw;
+
+	fwdl.dev        = device;
+	fwdl.pPRAMfw    = NULL;
+	fwdl.pram_size  = 0;
+	r = ioctl(th->fd, FIO_SDD_FW_DOWNLOAD, &fwdl);
+
+	return r;
+}
+
+int
+tapi_dev_start(tapi_handle_t th, unsigned int device)
+{
+	IFX_TAPI_DEV_START_CFG_t devstart;
+
+	devstart.dev    = device;
+	devstart.nMode  = IFX_TAPI_INIT_MODE_DEFAULT;
+
+	return ioctl(th->fd, IFX_TAPI_DEV_START, &devstart);
+}
+
+int
+tapi_dev_stop(tapi_handle_t th, unsigned int device)
+{
+	IFX_TAPI_DEV_START_CFG_t devstart;
+
+	devstart.dev    = device;
+	devstart.nMode  = IFX_TAPI_INIT_MODE_DEFAULT;
+
+	return ioctl(th->fd, IFX_TAPI_DEV_STOP, &devstart);
+}
+
+int
+tapi_bbd_download(tapi_handle_t th, unsigned int device, unsigned int channel,
+		  const char *bbdfile)
+{
+	SDD_BBD_Download_t bbddl;
+	off_t bbdsize;
+	int bbdh, r;
+	void *bbd;
+
+	if (bbdfile != NULL) {
+		bbdh = open(bbdfile, O_RDONLY);
+		if (bbdh < 0)
+			return -1;
+
+		bbdsize = lseek(bbdh, 0, SEEK_END);
+		if (bbdsize == -1) {
+			close(bbdh);
+			return -1;
+		}
+
+		bbd = mmap(NULL, bbdsize, PROT_READ, MAP_SHARED, bbdh, 0);
+		if (bbd == MAP_FAILED) {
+			close(bbdh);
+			return -1;
+		}
+
+		bbddl.dev       = device;
+		bbddl.buf       = bbd;
+		bbddl.size      = bbdsize;
+		if (channel == -1) {
+			bbddl.ch = 0;
+			bbddl.bBroadcast = 1;
+		} else {
+			bbddl.ch = channel;
+			bbddl.bBroadcast = 0;
+		}
+		r = ioctl(th->fd, FIO_SDD_BBD_DOWNLOAD, &bbddl);
+
+		munmap(bbd, bbdsize);
+		close(bbdh);
+	} else {
+		bbddl.dev       = device;
+		bbddl.buf       = tapi_bbd_blob;
+		bbddl.size      = tapi_bbd_blob_size;
+		if (channel == -1) {
+			bbddl.ch = 0;
+			bbddl.bBroadcast = 1;
+		} else {
+			bbddl.ch = channel;
+			bbddl.bBroadcast = 0;
+		}
+		r = ioctl(th->fd, FIO_SDD_BBD_DOWNLOAD, &bbddl);
+	}
+
+	return r;
+}
+
+int
+tapi_line_type_set(tapi_handle_t th, unsigned int device, unsigned int channel,
+		   tapi_line_type_t linetype)
+{
+	IFX_TAPI_LINE_TYPE_CFG_t lt;
+	const IFX_TAPI_LINE_TYPE_t ltmap[] = {
+		[TAPI_LINE_TYPE_FXS_NB]         = IFX_TAPI_LINE_TYPE_FXS_NB,
+		[TAPI_LINE_TYPE_FXS_WB]         = IFX_TAPI_LINE_TYPE_FXS_WB,
+		[TAPI_LINE_TYPE_FXS_AUTO]       = IFX_TAPI_LINE_TYPE_FXS_AUTO,
+		[TAPI_LINE_TYPE_FXO_NB]         = IFX_TAPI_LINE_TYPE_FXO_NB,
+	};
+
+	lt.dev          = device;
+	lt.ch           = channel;
+	lt.lineType     = ltmap[linetype];
+	lt.nDaaCh       = 0;
+
+	return ioctl(th->fd, IFX_TAPI_LINE_TYPE_SET, &lt);
+}
+
+int
+tapi_line_feed_set(tapi_handle_t th, unsigned int device, unsigned int channel,
+		   tapi_line_feed_t linefeed)
+{
+	IFX_TAPI_LINE_FEED_t lf;
+	const lfmap[] = {
+		[TAPI_LINE_FEED_ACTIVE]         = IFX_TAPI_LINE_FEED_ACTIVE,
+		[TAPI_LINE_FEED_ACTIVE_REV]     = IFX_TAPI_LINE_FEED_ACTIVE_REV,
+		[TAPI_LINE_FEED_STANDBY]        = IFX_TAPI_LINE_FEED_STANDBY,
+		[TAPI_LINE_FEED_HIGH_IMPEDANCE] = IFX_TAPI_LINE_FEED_HIGH_IMPEDANCE,
+		[TAPI_LINE_FEED_DISABLED]       = IFX_TAPI_LINE_FEED_DISABLED,
+	};
+
+	lf.dev          = device;
+	lf.ch           = channel;
+	lf.lineMode     = lfmap[linefeed];
+
+	return ioctl(th->fd, IFX_TAPI_LINE_FEED_SET, &lf);
+}
+
+int
+tapi_line_calibrate(tapi_handle_t th, unsigned int device, unsigned int channel)
+{
+	IFX_TAPI_CALIBRATION_t cal;
+
+	cal.dev         = device;
+	cal.ch          = channel;
+
+	return ioctl(th->fd, IFX_TAPI_CALIBRATION_START, &cal);
+}
+
+int
+tapi_ring_start(tapi_handle_t th, unsigned int device, unsigned int channel)
+{
+	IFX_TAPI_RING_t ring;
+
+	ring.dev        = device;
+	ring.ch         = channel;
+
+	return ioctl(th->fd, IFX_TAPI_RING_START, &ring);
+}
+
+int
+tapi_ring_stop(tapi_handle_t th, unsigned int device, unsigned int channel)
+{
+	IFX_TAPI_RING_t ring;
+
+	ring.dev        = device;
+	ring.ch         = channel;
+
+	return ioctl(th->fd, IFX_TAPI_RING_STOP, &ring);
+}
+
+tapi_line_hook_t
+tapi_hook_status_get(tapi_handle_t th, unsigned int device, unsigned int channel)
+{
+	IFX_TAPI_LINE_HOOK_STATUS_GET_t hook;
+	const IFX_TAPI_LINE_HOOK_t hmap[] = {
+		[IFX_TAPI_LINE_ONHOOK]  = TAPI_LINE_ONHOOK,
+		[IFX_TAPI_LINE_OFFHOOK] = TAPI_LINE_OFFHOOK,
+	};
+	int r;
+
+	hook.dev        = device;
+	hook.ch         = channel;
+	r = ioctl(th->fd, IFX_TAPI_LINE_HOOK_STATUS_GET, &hook);
+	if (r < 0)
+		return r;
+
+	return hmap[hook.hookMode];
+}
+
+static tapi_event_id_t
+tapi_translate_event_id(IFX_TAPI_EVENT_ID_t ifx_id)
+{
+	tapi_event_id_t id;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(tapi_event_tanslation_table); i++)
+		if (ifx_id == tapi_event_tanslation_table[i])
+			return i;
+
+	return -1;
+}
+
+int
+tapi_event_enable(tapi_handle_t th, unsigned int device, unsigned int channel,
+		  tapi_event_id_t event)
+{
+	IFX_TAPI_EVENT_t ifx_event;
+
+	memset(&ifx_event, 0, sizeof(ifx_event));
+	ifx_event.dev           = device;
+	ifx_event.ch            = channel;
+	ifx_event.id            = tapi_event_tanslation_table[event];
+
+	return ioctl(th->fd, IFX_TAPI_EVENT_ENABLE, &ifx_event);
+}
+
+int
+tapi_event_get(tapi_handle_t th, unsigned int device, int timeout,
+	       tapi_event_t *event)
+{
+	IFX_TAPI_EVENT_t ifx_event;
+	struct pollfd fds;
+	int r;
+
+	fds.fd          = th->fd;
+	fds.events      = POLLIN | POLLERR;
+	fds.revents     = 0;
+
+	r = poll(&fds, 1, timeout);
+	if (r <= 0)
+		return r;
+
+	memset(&ifx_event, 0, sizeof(ifx_event));
+	ifx_event.dev   = device;
+	ifx_event.ch    = IFX_TAPI_EVENT_ALL_CHANNELS;
+
+	if (ioctl(th->fd, IFX_TAPI_EVENT_GET, &ifx_event) < 0)
+		return -1;
+
+	event->device   = ifx_event.dev;
+	event->channel  = ifx_event.ch;
+	event->event    = tapi_translate_event_id(ifx_event.id);
+
+	return r;
+}
+
+int
+tapi_pcm_if_config(tapi_handle_t th, unsigned int device,
+		   tapi_pcm_if_mode_t mode, tapi_pcm_if_freq_t freq,
+		   tapi_pcm_if_slope_t rxslope, tapi_pcm_if_slope_t txslope)
+{
+	IFX_TAPI_PCM_IF_CFG_t pcmifcfg;
+	const IFX_TAPI_PCM_IF_MODE_t modemap[] = {
+		[TAPI_PCM_IF_MODE_SLAVE_AUTOFREQ] =
+			IFX_TAPI_PCM_IF_MODE_SLAVE_AUTOFREQ,
+		[TAPI_PCM_IF_MODE_SLAVE]        = IFX_TAPI_PCM_IF_MODE_SLAVE,
+		[TAPI_PCM_IF_MODE_MASTER]       = IFX_TAPI_PCM_IF_MODE_MASTER,
+	};
+	const IFX_TAPI_PCM_IF_DCLFREQ_t freqmap[] = {
+		[TAPI_PCM_IF_FREQ_512KHZ]       = IFX_TAPI_PCM_IF_DCLFREQ_512,
+		[TAPI_PCM_IF_FREQ_1024KHZ]      = IFX_TAPI_PCM_IF_DCLFREQ_1024,
+		[TAPI_PCM_IF_FREQ_1536KHZ]      = IFX_TAPI_PCM_IF_DCLFREQ_1536,
+		[TAPI_PCM_IF_FREQ_2048KHZ]      = IFX_TAPI_PCM_IF_DCLFREQ_2048,
+		[TAPI_PCM_IF_FREQ_4096KHZ]      = IFX_TAPI_PCM_IF_DCLFREQ_4096,
+		[TAPI_PCM_IF_FREQ_8192KHZ]      = IFX_TAPI_PCM_IF_DCLFREQ_8192,
+		[TAPI_PCM_IF_FREQ_16384KHZ]     = IFX_TAPI_PCM_IF_DCLFREQ_16384,
+	};
+	const IFX_TAPI_PCM_IF_SLOPE_t slopemap[] = {
+		[TAPI_PCM_IF_SLOPE_RISE]        = IFX_TAPI_PCM_IF_SLOPE_RISE,
+		[TAPI_PCM_IF_SLOPE_FALL]        = IFX_TAPI_PCM_IF_SLOPE_FALL,
+	};
+
+	pcmifcfg.dev            = device;
+	pcmifcfg.nHighway       = 0;
+	pcmifcfg.nOpMode        = modemap[mode];
+	pcmifcfg.nDCLFreq       = freqmap[freq];
+	pcmifcfg.nDoubleClk     = IFX_DISABLE;
+	pcmifcfg.nSlopeRX       = slopemap[rxslope];
+	pcmifcfg.nSlopeTX       = slopemap[txslope];
+	pcmifcfg.nOffsetRX      = IFX_TAPI_PCM_IF_OFFSET_NONE;
+	pcmifcfg.nOffsetTX      = IFX_TAPI_PCM_IF_OFFSET_NONE;
+	pcmifcfg.nDrive         = IFX_TAPI_PCM_IF_DRIVE_ENTIRE;
+	pcmifcfg.nShift         = IFX_DISABLE;
+	pcmifcfg.nMCTS          = 0x00;
+
+	return ioctl(th->fd, IFX_TAPI_PCM_IF_CFG_SET, &pcmifcfg);
+}
+
+int
+tapi_pcm_channel_config(tapi_handle_t th, unsigned int device,
+			unsigned int channel, unsigned int slotrx, unsigned int slottx,
+			tapi_pcm_coding_t coding)
+{
+	IFX_TAPI_PCM_CFG_t pcmcfg;
+	const IFX_TAPI_PCM_RES_t codingmap[] = {
+		[TAPI_PCM_CODING_NB_ALAW_8BIT]  = IFX_TAPI_PCM_RES_NB_ALAW_8BIT,
+		[TAPI_PCM_CODING_NB_ULAW_8BIT]  = IFX_TAPI_PCM_RES_NB_ULAW_8BIT,
+		[TAPI_PCM_CODING_NB_LINEAR_16BIT] =
+			IFX_TAPI_PCM_RES_NB_LINEAR_16BIT,
+		[TAPI_PCM_CODING_WB_ALAW_8BIT]  = IFX_TAPI_PCM_RES_WB_ALAW_8BIT,
+		[TAPI_PCM_CODING_WB_ULAW_8BIT]  = IFX_TAPI_PCM_RES_WB_ULAW_8BIT,
+		[TAPI_PCM_CODING_WB_LINEAR_16BIT] =
+			IFX_TAPI_PCM_RES_WB_LINEAR_16BIT,
+		[TAPI_PCM_CODING_WB_G722]       = IFX_TAPI_PCM_RES_WB_G722,
+		[TAPI_PCM_CODING_NB_G726_16]    = IFX_TAPI_PCM_RES_NB_G726_16,
+		[TAPI_PCM_CODING_NB_G726_24]    = IFX_TAPI_PCM_RES_NB_G726_24,
+		[TAPI_PCM_CODING_NB_G726_32]    = IFX_TAPI_PCM_RES_NB_G726_32,
+		[TAPI_PCM_CODING_NB_G726_40]    = IFX_TAPI_PCM_RES_NB_G726_40,
+		[TAPI_PCM_CODING_WB_LINEAR_SPLIT_16BIT] =
+			IFX_TAPI_PCM_RES_WB_LINEAR_SPLIT_16BIT,
+	};
+
+	pcmcfg.dev              = device;
+	pcmcfg.ch               = channel;
+	pcmcfg.nTimeslotRX      = slotrx;
+	pcmcfg.nTimeslotTX      = slottx;
+	pcmcfg.nHighway         = 0;
+	pcmcfg.nResolution      = codingmap[coding];
+	pcmcfg.nSampleSwap      = IFX_TAPI_PCM_SAMPLE_SWAP_DISABLED;
+	pcmcfg.nBitPacking      = IFX_TAPI_PCM_BITPACK_LSB;
+
+	return ioctl(th->fd, IFX_TAPI_PCM_CFG_SET, &pcmcfg);
+}
+
+int
+tapi_pcm_channel_activate(tapi_handle_t th, unsigned int device,
+			  unsigned int channel)
+{
+	IFX_TAPI_PCM_ACTIVATION_t pcmact;
+
+	pcmact.dev      = device;
+	pcmact.ch       = channel;
+	pcmact.mode     = IFX_ENABLE;
+
+	return ioctl(th->fd, IFX_TAPI_PCM_ACTIVATION_SET, &pcmact);
+}
+
+int
+tapi_test_loop(tapi_handle_t th, unsigned int device,
+	       unsigned int channel, unsigned int enable)
+{
+	IFX_TAPI_TEST_LOOP_t tloop;
+
+	tloop.dev       = device;
+	tloop.ch        = channel;
+	tloop.bAnalog   = enable;
+
+	return ioctl(th->fd, IFX_TAPI_TEST_LOOP, &tloop);
+}
+
+int
+tapi_phone_volume_set(tapi_handle_t th, unsigned int device,
+		      unsigned int channel, int rxgain, int txgain)
+{
+	IFX_TAPI_LINE_VOLUME_t volume;
+
+	volume.dev      = device;
+	volume.ch       = channel;
+	volume.nGainRx  = rxgain;
+	volume.nGainTx  = txgain;
+
+	return ioctl(th->fd, IFX_TAPI_PHONE_VOLUME_SET, &volume);
+}
diff --git a/tools/voice/lantiq-dfev/libtapi.h b/tools/voice/lantiq-dfev/libtapi.h
new file mode 100644
index 0000000..45a6d2d
--- /dev/null
+++ b/tools/voice/lantiq-dfev/libtapi.h
@@ -0,0 +1,342 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+********************************************************************************
+   Marvell Commercial License Option
+
+   If you received this File from Marvell and you have entered into a commercial
+   license agreement (a "Commercial License") with Marvell, the File is licensed
+   to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+********************************************************************************
+   Marvell BSD License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File under the following licensing terms.
+   Redistribution and use in source and binary forms, with or without modification,
+   are permitted provided that the following conditions are met:
+
+*   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+*   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+*   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+   ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+   ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#ifndef _LIBTAPI_H
+#define _LIBTAPI_H
+
+extern unsigned char tapi_bbd_blob[];
+extern unsigned int tapi_bbd_blob_size;
+
+struct tapi_handle;
+typedef struct tapi_handle *tapi_handle_t;
+
+typedef enum {
+	TAPI_LINE_TYPE_FXS_NB,
+	TAPI_LINE_TYPE_FXS_WB,
+	TAPI_LINE_TYPE_FXS_AUTO,
+	TAPI_LINE_TYPE_FXO_NB,
+} tapi_line_type_t;
+
+typedef enum {
+	TAPI_LINE_FEED_ACTIVE,
+	TAPI_LINE_FEED_ACTIVE_REV,
+	TAPI_LINE_FEED_STANDBY,
+	TAPI_LINE_FEED_HIGH_IMPEDANCE,
+	TAPI_LINE_FEED_DISABLED,
+} tapi_line_feed_t;
+
+typedef enum {
+	TAPI_LINE_ONHOOK,
+	TAPI_LINE_OFFHOOK,
+} tapi_line_hook_t;
+
+typedef enum {
+	TAPI_EVENT_NONE,
+	TAPI_EVENT_IO_GENERAL_NONE,
+	TAPI_EVENT_IO_INTERRUPT_NONE,
+	TAPI_EVENT_FXS_NONE,
+	TAPI_EVENT_FXS_RING,
+	TAPI_EVENT_FXS_RINGBURST_END,
+	TAPI_EVENT_FXS_RINGING_END,
+	TAPI_EVENT_FXS_ONHOOK,
+	TAPI_EVENT_FXS_OFFHOOK,
+	TAPI_EVENT_FXS_FLASH,
+	TAPI_EVENT_FXS_ONHOOK_INT,
+	TAPI_EVENT_FXS_OFFHOOK_INT,
+	TAPI_EVENT_CONTMEASUREMENT,
+	TAPI_EVENT_FXS_RAW_ONHOOK,
+	TAPI_EVENT_FXS_RAW_OFFHOOK,
+	TAPI_EVENT_FXS_LINE_MODE,
+	TAPI_EVENT_FXS_COMTEL_END,
+	TAPI_EVENT_FXO_NONE,
+	TAPI_EVENT_FXO_BAT_FEEDED,
+	TAPI_EVENT_FXO_BAT_DROPPED,
+	TAPI_EVENT_FXO_POLARITY,
+	TAPI_EVENT_FXO_RING_START,
+	TAPI_EVENT_FXO_RING_STOP,
+	TAPI_EVENT_FXO_OSI,
+	TAPI_EVENT_FXO_APOH,
+	TAPI_EVENT_FXO_NOPOH,
+	TAPI_EVENT_LT_GR909_RDY,
+	TAPI_EVENT_NLT_END,
+	TAPI_EVENT_LINE_MEASURE_CAPACITANCE_RDY,
+	TAPI_EVENT_LINE_MEASURE_CAPACITANCE_GND_RDY,
+	TAPI_EVENT_PULSE_NONE,
+	TAPI_EVENT_PULSE_DIGIT,
+	TAPI_EVENT_PULSE_START,
+	TAPI_EVENT_DTMF_NONE,
+	TAPI_EVENT_DTMF_DIGIT,
+	TAPI_EVENT_DTMF_END,
+	TAPI_EVENT_CALIBRATION_NONE,
+	TAPI_EVENT_CALIBRATION_END,
+	TAPI_EVENT_CALIBRATION_END_INT,
+	TAPI_EVENT_CALIBRATION_END_SINT,
+	TAPI_EVENT_METERING_NONE,
+	TAPI_EVENT_METERING_END,
+	TAPI_EVENT_CID_TX_NONE,
+	TAPI_EVENT_CID_TX_SEQ_START,
+	TAPI_EVENT_CID_TX_SEQ_END,
+	TAPI_EVENT_CID_TX_INFO_START,
+	TAPI_EVENT_CID_TX_INFO_END,
+	TAPI_EVENT_CID_TX_NOACK_ERR,
+	TAPI_EVENT_CID_TX_RINGCAD_ERR,
+	TAPI_EVENT_CID_TX_UNDERRUN_ERR,
+	TAPI_EVENT_CID_TX_NOACK2_ERR,
+	TAPI_EVENT_CIDSM_END,
+	TAPI_EVENT_CID_TX_END,
+	TAPI_EVENT_CID_RX_NONE,
+	TAPI_EVENT_CID_RX_CAS,
+	TAPI_EVENT_CID_RX_END,
+	TAPI_EVENT_CID_RX_CD,
+	TAPI_EVENT_CID_RX_ERROR_READ,
+	TAPI_EVENT_CID_RX_ERROR1,
+	TAPI_EVENT_CID_RX_ERROR2,
+	TAPI_EVENT_TONE_GEN_NONE,
+	TAPI_EVENT_TONE_GEN_BUSY,
+	TAPI_EVENT_TONE_GEN_END,
+	TAPI_EVENT_TONE_GEN_END_RAW,
+	TAPI_EVENT_TONE_DET_NONE,
+	TAPI_EVENT_TONE_DET_RECEIVE,
+	TAPI_EVENT_TONE_DET_TRANSMIT,
+	TAPI_EVENT_TONE_DET_CPT,
+	TAPI_EVENT_TONE_DET_CPT_END,
+	TAPI_EVENT_TONE_DET_MF_R2_START,
+	TAPI_EVENT_TONE_DET_MF_R2_END,
+	TAPI_EVENT_FAXMODEM_NONE,
+	TAPI_EVENT_FAXMODEM_DIS,
+	TAPI_EVENT_FAXMODEM_CED,
+	TAPI_EVENT_FAXMODEM_PR,
+	TAPI_EVENT_FAXMODEM_AM,
+	TAPI_EVENT_FAXMODEM_CNGFAX,
+	TAPI_EVENT_FAXMODEM_CNGMOD,
+	TAPI_EVENT_FAXMODEM_V21L,
+	TAPI_EVENT_FAXMODEM_V18A,
+	TAPI_EVENT_FAXMODEM_V27,
+	TAPI_EVENT_FAXMODEM_BELL,
+	TAPI_EVENT_FAXMODEM_V22,
+	TAPI_EVENT_FAXMODEM_V22ORBELL,
+	TAPI_EVENT_FAXMODEM_V32AC,
+	TAPI_EVENT_FAXMODEM_V8BIS,
+	TAPI_EVENT_FAXMODEM_HOLDEND,
+	TAPI_EVENT_FAXMODEM_CEDEND,
+	TAPI_EVENT_FAXMODEM_CAS_BELL,
+	TAPI_EVENT_FAXMODEM_V21H,
+	TAPI_EVENT_FAXMODEM_VMD,
+	TAPI_EVENT_LIN_NONE,
+	TAPI_EVENT_LIN_UNDERFLOW,
+	TAPI_EVENT_COD_NONE,
+	TAPI_EVENT_COD_DEC_CHG,
+	TAPI_EVENT_COD_ROOM_NOISE,
+	TAPI_EVENT_COD_ROOM_SILENCE,
+	TAPI_EVENT_COD_ANNOUNCE_END,
+	TAPI_EVENT_COD_MOS,
+	TAPI_EVENT_RTP_NONE,
+	TAPI_EVENT_RTP_FIRST,
+	TAPI_EVENT_RTP_EXT_BROKEN,
+	TAPI_EVENT_RTP_EXT_SSRC_CHANGED,
+	TAPI_EVENT_AAL_NONE,
+	TAPI_EVENT_RFC2833_NONE,
+	TAPI_EVENT_RFC2833_EVENT,
+	TAPI_EVENT_KPI_NONE,
+	TAPI_EVENT_KPI_INGRESS_FIFO_FULL,
+	TAPI_EVENT_KPI_SOCKET_FAILURE,
+	TAPI_EVENT_T38_NONE,
+	TAPI_EVENT_T38_ERROR_GEN,
+	TAPI_EVENT_T38_ERROR_OVLD,
+	TAPI_EVENT_T38_ERROR_READ,
+	TAPI_EVENT_T38_ERROR_WRITE,
+	TAPI_EVENT_T38_ERROR_DATA,
+	TAPI_EVENT_T38_ERROR_SETUP,
+	TAPI_EVENT_T38_FDP_REQ,
+	TAPI_EVENT_T38_STATE_CHANGE,
+	TAPI_EVENT_JB_NONE,
+	TAPI_EVENT_DOWNLOAD_NONE,
+	TAPI_EVENT_INFO_NONE,
+	TAPI_EVENT_INFO_MBX_CONGESTION,
+	TAPI_EVENT_DEBUG_NONE,
+	TAPI_EVENT_DEBUG_CERR,
+	TAPI_EVENT_GPIO_HL,
+	TAPI_EVENT_GPIO_LH,
+	TAPI_EVENT_LL_DRIVER_NONE,
+	TAPI_EVENT_LL_DRIVER_WD_FAIL,
+	TAPI_EVENT_FAULT_GENERAL_NONE,
+	TAPI_EVENT_FAULT_GENERAL,
+	TAPI_EVENT_FAULT_GENERAL_CHINFO,
+	TAPI_EVENT_FAULT_GENERAL_DEVINFO,
+	TAPI_EVENT_TYPE_FAULT_GENERAL,
+	TAPI_EVENT_FAULT_LINE_NONE,
+	TAPI_EVENT_FAULT_LINE_GK_POS,
+	TAPI_EVENT_FAULT_LINE_GK_NEG,
+	TAPI_EVENT_FAULT_LINE_GK_LOW,
+	TAPI_EVENT_FAULT_LINE_GK_HIGH,
+	TAPI_EVENT_FAULT_LINE_OVERTEMP,
+	TAPI_EVENT_FAULT_LINE_OVERCURRENT,
+	TAPI_EVENT_FAULT_LINE_GK_LOW_INT,
+	TAPI_EVENT_FAULT_LINE_GK_HIGH_INT,
+	TAPI_EVENT_FAULT_LINE_GK_LOW_END,
+	TAPI_EVENT_FAULT_LINE_GK_HIGH_END,
+	TAPI_EVENT_FAULT_LINE_OVERTEMP_END,
+	TAPI_EVENT_FAULT_HW_NONE,
+	TAPI_EVENT_FAULT_HW_SPI_ACCESS,
+	TAPI_EVENT_FAULT_HW_CLOCK_FAIL,
+	TAPI_EVENT_FAULT_HW_CLOCK_FAIL_END,
+	TAPI_EVENT_FAULT_HW_FAULT,
+	TAPI_EVENT_FAULT_HW_SYNC,
+	TAPI_EVENT_FAULT_HW_RESET,
+	TAPI_EVENT_FAULT_HW_SSI_ERR,
+	TAPI_EVENT_FAULT_HW_SSI_ERR_END,
+	TAPI_EVENT_FAULT_FW_NONE,
+	TAPI_EVENT_FAULT_FW_EBO_UF,
+	TAPI_EVENT_FAULT_FW_EBO_OF,
+	TAPI_EVENT_FAULT_FW_CBO_UF,
+	TAPI_EVENT_FAULT_FW_CBO_OF,
+	TAPI_EVENT_FAULT_FW_CBI_OF,
+	TAPI_EVENT_FAULT_FW_WATCHDOG,
+	TAPI_EVENT_FAULT_SW_NONE,
+	TAPI_EVENT_FAULT_HDLC_NONE,
+	TAPI_EVENT_FAULT_HDLC_FRAME_LENGTH,
+	TAPI_EVENT_FAULT_HDLC_NO_KPI_PATH,
+	TAPI_EVENT_FAULT_HDLC_TX_OVERFLOW,
+	TAPI_EVENT_FAULT_HDLC_DISABLED,
+} tapi_event_id_t;
+
+typedef struct {
+	unsigned int device;
+	unsigned int channel;
+	tapi_event_id_t event;
+} tapi_event_t;
+
+typedef enum {
+	TAPI_PCM_IF_MODE_SLAVE_AUTOFREQ,
+	TAPI_PCM_IF_MODE_SLAVE,
+	TAPI_PCM_IF_MODE_MASTER,
+} tapi_pcm_if_mode_t;
+
+typedef enum {
+	TAPI_PCM_IF_FREQ_512KHZ,
+	TAPI_PCM_IF_FREQ_1024KHZ,
+	TAPI_PCM_IF_FREQ_1536KHZ,
+	TAPI_PCM_IF_FREQ_2048KHZ,
+	TAPI_PCM_IF_FREQ_4096KHZ,
+	TAPI_PCM_IF_FREQ_8192KHZ,
+	TAPI_PCM_IF_FREQ_16384KHZ,
+} tapi_pcm_if_freq_t;
+
+typedef enum {
+	TAPI_PCM_IF_SLOPE_RISE,
+	TAPI_PCM_IF_SLOPE_FALL,
+} tapi_pcm_if_slope_t;
+
+typedef enum {
+	TAPI_PCM_CODING_NB_ALAW_8BIT,
+	TAPI_PCM_CODING_NB_ULAW_8BIT,
+	TAPI_PCM_CODING_NB_LINEAR_16BIT,
+	TAPI_PCM_CODING_WB_ALAW_8BIT,
+	TAPI_PCM_CODING_WB_ULAW_8BIT,
+	TAPI_PCM_CODING_WB_LINEAR_16BIT,
+	TAPI_PCM_CODING_WB_G722,
+	TAPI_PCM_CODING_NB_G726_16,
+	TAPI_PCM_CODING_NB_G726_24,
+	TAPI_PCM_CODING_NB_G726_32,
+	TAPI_PCM_CODING_NB_G726_40,
+	TAPI_PCM_CODING_WB_LINEAR_SPLIT_16BIT,
+} tapi_pcm_coding_t;
+
+extern tapi_handle_t tapi_open(const char *tapidev);
+extern void tapi_close(tapi_handle_t th);
+extern int tapi_fw_download(tapi_handle_t th, unsigned int device,
+			    const char *fwfile);
+extern int tapi_dev_start(tapi_handle_t th, unsigned int device);
+extern int tapi_dev_stop(tapi_handle_t th, unsigned int device);
+extern int tapi_bbd_download(tapi_handle_t th, unsigned int device,
+			     unsigned int channel, const char *bbdfile);
+extern int tapi_line_calibrate(tapi_handle_t th, unsigned int device,
+			       unsigned int channel);
+extern int tapi_line_type_set(tapi_handle_t th, unsigned int device,
+			      unsigned int channel, tapi_line_type_t linetype);
+extern int tapi_line_feed_set(tapi_handle_t th, unsigned int device,
+			      unsigned int channel, tapi_line_feed_t linefeed);
+extern int tapi_ring_start(tapi_handle_t th, unsigned int device,
+			   unsigned int channel);
+extern int tapi_ring_stop(tapi_handle_t th, unsigned int device,
+			  unsigned int channel);
+extern tapi_line_hook_t tapi_hook_status_get(tapi_handle_t th,
+					     unsigned int device, unsigned int channel);
+extern int tapi_event_get(tapi_handle_t th, unsigned int device, int timeout,
+			  tapi_event_t *event);
+extern int tapi_event_enable(tapi_handle_t th, unsigned int device,
+			     unsigned int channel, tapi_event_id_t event);
+extern int tapi_pcm_if_config(tapi_handle_t th, unsigned int device,
+			      tapi_pcm_if_mode_t mode, tapi_pcm_if_freq_t freq,
+			      tapi_pcm_if_slope_t rxslope, tapi_pcm_if_slope_t txslope);
+extern int tapi_pcm_channel_config(tapi_handle_t th, unsigned int device,
+				   unsigned int channel, unsigned int slotrx, unsigned int slottx,
+				   tapi_pcm_coding_t coding);
+extern int tapi_pcm_channel_activate(tapi_handle_t th, unsigned int device,
+				     unsigned int channel);
+extern int tapi_test_loop(tapi_handle_t th, unsigned int device,
+			  unsigned int channel, unsigned int enable);
+extern int tapi_phone_volume_set(tapi_handle_t th, unsigned int device,
+				 unsigned int channel, int rxgain, int txgain);
+
+#endif /* _LIBTAPI_H */
diff --git a/tools/voice/lantiq-dfev/mv_voice_tool.c b/tools/voice/lantiq-dfev/mv_voice_tool.c
new file mode 100644
index 0000000..2dbe7ca
--- /dev/null
+++ b/tools/voice/lantiq-dfev/mv_voice_tool.c
@@ -0,0 +1,612 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+********************************************************************************
+   Marvell Commercial License Option
+
+   If you received this File from Marvell and you have entered into a commercial
+   license agreement (a "Commercial License") with Marvell, the File is licensed
+   to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+********************************************************************************
+   Marvell BSD License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File under the following licensing terms.
+   Redistribution and use in source and binary forms, with or without modification,
+   are permitted provided that the following conditions are met:
+
+*   Redistributions of source code must retain the above copyright notice,
+	    this list of conditions and the following disclaimer.
+
+*   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+*   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+   ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+   ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <sys/ioctl.h>
+
+#include "tdm/test/tal_dev.h"
+#include "libtapi.h"
+
+#define TAPI_DEVICE                     0
+#define TAPI_CHANNELS                   2
+#define TOOL_PREFIX                     ">> "
+
+#define TIMEOUT                         11000 /* usec */
+#define BUFF_ADDR(buff, line)           ((unsigned char *)buff + (line * 80 * pcm_bytes))
+#define CH_BUFF_SIZE                    (80 * pcm_bytes)
+
+static int tal_fd;
+static tapi_handle_t th;
+static unsigned char hook_state[TAPI_CHANNELS];
+static unsigned int cal_lines;
+static int offhook_count;
+static int buff_size;
+static int slic_init;
+static int pcm_bytes;
+
+static unsigned short f1Mem;
+static unsigned short f2Mem;
+static unsigned char aud_buf[2][320 * TAPI_CHANNELS];
+
+/* sin table, 256 points */
+static short sinTbl[] = { 0,      402,    804,    1205,   1606,   2005,   2404,   2801,   3196,   3590,   3981,   4370,   4756,
+			  5139,   5519,   5896,   6270,   6639,   7005,   7366,   7723,   8075,   8423,   8765,   9102,   9433,  9759,   10079, 10393,
+			  10701,  11002,  11297,  11585,  11865,  12139,  12405,  12664,  12915,  13159,  13394,  13622,  13841, 14052,
+			  14255,  14449,  14634,  14810,  14977,  15136,  15285,  15425,  15556,  15678,  15790,  15892,  15985, 16068,
+			  16142,  16206,  16260,  16304,  16339,  16363,  16378,  16383,  16378,  16363,  16339,  16304,  16260, 16206,
+			  16142,  16068,  15985,  15892,  15790,  15678,  15556,  15425,  15285,  15136,  14977,  14810,  14634, 14449,
+			  14255,  14052,  13841,  13622,  13394,  13159,  12915,  12664,  12405,  12139,  11865,  11585,  11297, 11002,
+			  10701,  10393,  10079,  9759,   9433,   9102,   8765,   8423,   8075,   7723,   7366,   7005,   6639,  6270,   5896,  5519,
+			  5139,   4756,   4370,   3981,   3590,   3196,   2801,   2404,   2005,   1606,   1205,   804,    402,   0,      -402,  -804, -1205, -1606,
+			  -2005,  -2404,  -2801,  -3196,  -3590,  -3981,  -4370,  -4756,  -5139,  -5519,  -5896,  -6270,  -6639, -7005,
+			  -7366,  -7723,  -8075,  -8423,  -8765,  -9102,  -9433,  -9759,  -10079, -10393, -10701, -11002, -11297,
+			  -11585, -11865, -12139, -12405, -12664, -12915, -13159, -13394, -13622, -13841, -14052, -14255,
+			  -14449, -14634, -14810, -14977, -15136, -15285, -15425, -15556, -15678, -15790, -15892, -15985,
+			  -16068, -16142, -16206, -16260, -16304, -16339, -16363, -16378, -16383, -16378, -16363, -16339,
+			  -16304, -16260, -16206, -16142, -16068, -15985, -15892, -15790, -15678, -15556, -15425, -15285,
+			  -15136, -14977, -14810, -14634, -14449, -14255, -14052, -13841, -13622, -13394, -13159, -12915,
+			  -12664, -12405, -12139, -11865, -11585, -11297, -11002, -10701, -10393, -10079, -9759,  -9433,  -9102,
+			  -8765,  -8423,  -8075,  -7723,  -7366,  -7005,  -6639,  -6270,  -5896,  -5519,  -5139,  -4756,  -4370, -3981,
+			  -3590,  -3196,  -2801,  -2404,  -2005,  -1606,  -1205,  -804,   -402,   0 };
+
+static void wait_for_event(int block)
+{
+	tapi_event_t event;
+
+	if (tapi_event_get(th, TAPI_DEVICE, (block) ? -1 : 0, &event) <= 0)
+		return;
+
+	switch (event.event) {
+	case TAPI_EVENT_FXS_ONHOOK:
+		printf("on-hook(%d)\n", event.channel);
+		hook_state[event.channel] = 0;
+		offhook_count--;
+		tapi_line_feed_set(th, event.device, event.channel,
+				   TAPI_LINE_FEED_STANDBY);
+		break;
+	case TAPI_EVENT_FXS_OFFHOOK:
+		printf("off-hook(%d)\n", event.channel);
+		hook_state[event.channel] = 1;
+		offhook_count++;
+		tapi_line_feed_set(th, event.device, event.channel,
+				   TAPI_LINE_FEED_ACTIVE);
+		break;
+	case TAPI_EVENT_CALIBRATION_END:
+		cal_lines += 1;
+		break;
+	default:
+		break;
+	}
+}
+
+static void release(int signum)
+{
+	/* Stop SLIC/s */
+	if (slic_init) {
+		printf("\n%s Stopping SLIC\n", TOOL_PREFIX);
+		tapi_dev_stop(th, TAPI_DEVICE);
+		printf("\n%s Stopped SLIC\n", TOOL_PREFIX);
+		slic_init = 0;
+	} else
+		printf("\n%s SLIC already stopped\n", TOOL_PREFIX);
+
+	/* Stop TAL */
+	if (ioctl(tal_fd, TAL_DEV_EXIT, 0)) {
+		printf("\n%s Error, unable to stop TAL\n", TOOL_PREFIX);
+		return;
+	} else
+		printf("\n%s TAL stopped\n", TOOL_PREFIX);
+
+	if (signum) {
+		close(tal_fd);
+		tapi_close(th);
+		exit(0);
+	}
+}
+
+static void gen_tone(unsigned short freq, unsigned char line_id, unsigned char *tx_buff)
+{
+	short i;
+	short buf[80];
+	short sample;
+
+	for (i = 0; i < 80; i++) {
+		sample = (sinTbl[f1Mem >> 8] + sinTbl[f2Mem >> 8]) >> 2;
+#ifndef CONFIG_CPU_BIG_ENDIAN
+		buf[i] = sample;
+#else
+		buf[i] = ((sample & 0xff) << 8) + (sample >> 8);
+#endif
+		f1Mem += freq;
+		f2Mem += freq;
+	}
+	memcpy(BUFF_ADDR(tx_buff, line_id), (void *)buf, 160);
+}
+
+static void sw_tone_test(int tal_fd, unsigned char line_id)
+{
+	fd_set wr_fds;
+	struct timeval timeout = { 0, TIMEOUT };
+	int msg_len, x;
+	char str[4];
+
+	if (tal_fd <= 0) {
+		printf("%s Device is not accessible\n", TOOL_PREFIX);
+		return;
+	}
+
+	while (1) {
+		printf("%s Choose frequency: (1) 300HZ (2) 630HZ (3) 1000HZ (4) Back to main menu: ", TOOL_PREFIX);
+		fgets(str, sizeof(str), stdin);
+		printf("%s Waiting for off-hook...\n", TOOL_PREFIX);
+
+		if (str[0] == '1')
+			x = 2457;
+			/* printf("%s Generating 300HZ tone\n", TOOL_PREFIX); */
+		else if (str[0] == '2')
+			x = 5161;
+			/* printf("%s Generating 630HZ tone\n", TOOL_PREFIX); */
+		else if (str[0] == '3')
+			x = 8192;
+			/* printf("%s Generating 1000HZ tone\n", TOOL_PREFIX); */
+		else if (str[0] == '4')
+			return;
+		else {
+			printf("%s Input error - try again\n", TOOL_PREFIX);
+			continue;
+		}
+
+		/* Wait until both lines go off-hook */
+		while (hook_state[line_id] == 0)
+			wait_for_event(1);
+
+		if (ioctl(tal_fd, TAL_DEV_PCM_START, 0)) {
+			printf("Error, unable to start pcm bus\n");
+			return;
+		}
+
+		printf("%s Waiting for on-hook to return to menu.\n", TOOL_PREFIX);
+
+		while (hook_state[line_id] == 1) {
+			FD_ZERO(&wr_fds);
+			FD_SET(tal_fd, &wr_fds);
+
+			/* Wait for event  */
+			if (select(tal_fd + 1, NULL, &wr_fds, NULL, &timeout) == 0) {
+				printf("Error, timeout while polling(%dusec)\n", TIMEOUT);
+				return;
+			}
+
+			/* Write */
+			if (FD_ISSET(tal_fd, &wr_fds)) {
+				gen_tone(x, line_id, aud_buf[1]);
+				if (pcm_bytes == 4)
+					gen_tone(x, line_id, (aud_buf[1] + 160));
+
+				msg_len = write(tal_fd, aud_buf[1], buff_size);
+				if (msg_len <= 0) {
+					printf("write() failed\n");
+					return;
+				}
+			}
+
+			/* Check hook state */
+			wait_for_event(0);
+
+			/* Reload timeout */
+			timeout.tv_usec = TIMEOUT;
+		}
+
+		if (ioctl(tal_fd, TAL_DEV_PCM_STOP, 0)) {
+			printf("Error, unable to stop pcm bus\n");
+			return;
+		}
+	}
+}
+
+static void sw_loopback(int tal_fd, unsigned char line_id)
+{
+	fd_set rd_fds, wr_fds;
+	struct timeval timeout = { 0, TIMEOUT };
+	int msg_len;
+
+	if (tal_fd <= 0) {
+		printf("%s Device is not accessible\n", TOOL_PREFIX);
+		return;
+	}
+
+	/* Wait until line goes off-hook */
+	while (hook_state[line_id] == 0)
+		wait_for_event(1);
+
+	if (ioctl(tal_fd, TAL_DEV_PCM_START, 0)) {
+		printf("Error, unable to start pcm bus\n");
+		return;
+	}
+
+	while (hook_state[line_id] == 1) {
+		FD_ZERO(&rd_fds);
+		FD_ZERO(&wr_fds);
+		FD_SET(tal_fd, &rd_fds);
+		FD_SET(tal_fd, &wr_fds);
+
+		/* Wait for event  */
+		if (select(tal_fd + 1, &rd_fds, &wr_fds, NULL, &timeout) == 0) {
+			printf("Error, timeout while polling(%dusec)\n", TIMEOUT);
+			return;
+		}
+
+		/* Read */
+		if (FD_ISSET(tal_fd, &rd_fds)) {
+			/* printf("Rd\n"); */
+			msg_len = read(tal_fd, aud_buf[0], buff_size);
+			if (msg_len <= 0) {
+				printf("read() failed\n");
+				return;
+			}
+			memcpy(BUFF_ADDR(aud_buf[1], line_id), BUFF_ADDR(aud_buf[0], line_id), CH_BUFF_SIZE);
+		}
+
+		/* Write */
+		if (FD_ISSET(tal_fd, &wr_fds)) {
+			/* printf("Wr\n"); */
+			msg_len = write(tal_fd, aud_buf[1], buff_size);
+			if (msg_len <= 0) {
+				printf("write() failed\n");
+				return;
+			}
+		}
+
+		/* Check hook state */
+		wait_for_event(0);
+
+		/* Reload timeout */
+		timeout.tv_usec = TIMEOUT;
+	}
+
+	if (ioctl(tal_fd, TAL_DEV_PCM_STOP, 0)) {
+		printf("Error, unable to stop pcm bus\n");
+		return;
+	}
+}
+
+static void sw_loopback_two_phones_test(int tal_fd, unsigned char line0, unsigned char line1)
+{
+	fd_set rd_fds, wr_fds;
+	struct timeval timeout = { 0, TIMEOUT };
+	int msg_len;
+
+	if (tal_fd <= 0) {
+		printf("%s Device is not accessible\n", TOOL_PREFIX);
+		return;
+	}
+
+	/* Wait until both lines go off-hook */
+	while ((hook_state[line0] == 0) || (hook_state[line1] == 0))
+		wait_for_event(1);
+
+	if (ioctl(tal_fd, TAL_DEV_PCM_START, 0)) {
+		printf("Error, unable to start pcm bus\n");
+		return;
+	}
+
+	while ((hook_state[line0] == 1) && (hook_state[line1] == 1)) {
+		FD_ZERO(&rd_fds);
+		FD_ZERO(&wr_fds);
+		FD_SET(tal_fd, &rd_fds);
+		FD_SET(tal_fd, &wr_fds);
+
+		/* Wait for event  */
+		if (select(tal_fd + 1, &rd_fds, &wr_fds, NULL, &timeout) == 0) {
+			printf("Error, timeout while polling(%dusec)\n", TIMEOUT);
+			return;
+		}
+
+		/* Read */
+		if (FD_ISSET(tal_fd, &rd_fds)) {
+			msg_len = read(tal_fd, aud_buf[0], buff_size);
+			if (msg_len <= 0) {
+				printf("read() failed\n");
+				return;
+			}
+			memcpy(BUFF_ADDR(aud_buf[1], line0), BUFF_ADDR(aud_buf[0], line1), CH_BUFF_SIZE);
+			memcpy(BUFF_ADDR(aud_buf[1], line1), BUFF_ADDR(aud_buf[0], line0), CH_BUFF_SIZE);
+		}
+
+		/* Write */
+		if (FD_ISSET(tal_fd, &wr_fds)) {
+			msg_len = write(tal_fd, aud_buf[1], buff_size);
+			if (msg_len <= 0) {
+				printf("write() failed\n");
+				return;
+			}
+		}
+
+		/* Check hook state */
+		wait_for_event(0);
+
+		/* Reload timeout */
+		timeout.tv_usec = TIMEOUT;
+	}
+
+	if (ioctl(tal_fd, TAL_DEV_PCM_STOP, 0)) {
+		printf("Error, unable to stop pcm bus\n");
+		return;
+	}
+}
+
+int main(int argc, char *argv[])
+{
+	int fdflags, rxgain, txgain;
+	tal_dev_params_t tal_params;
+	unsigned int i, j;
+	char str[8];
+
+	/* Open TAL device */
+	tal_fd = open("/dev/tal", O_RDWR);
+	if (tal_fd < 0) {
+		printf("%s Cannot open TAL device.\n", TOOL_PREFIX);
+		return 1;
+	}
+
+	fdflags = fcntl(tal_fd, F_GETFL, 0);
+	fdflags |= O_NONBLOCK;
+	fcntl(tal_fd, F_SETFL, fdflags);
+
+	printf("\n%s Please enter PCM sample size (2/4): ", TOOL_PREFIX);
+	fgets(str, sizeof(str), stdin);
+	pcm_bytes = atoi(str);
+
+	/* Calculate total lines buffer size */
+	buff_size = (80 * pcm_bytes * TAPI_CHANNELS);
+
+	/* Fill TAL info */
+	tal_params.pcm_format = pcm_bytes;
+	tal_params.total_lines = TAPI_CHANNELS;
+
+	/* Open TAPI device */
+	th = tapi_open("/dev/sdd");
+	if (th == NULL) {
+		printf("%s Error, could not open tapi device.\n", TOOL_PREFIX);
+		return 1;
+	}
+
+	/* Handle termination gracefully */
+	if (signal(SIGINT, release) == SIG_IGN)
+		signal(SIGINT, SIG_IGN);
+
+	/* Issue main menu */
+	printf("\n !!! Remember to start phone devices before performing any action !!!\n", TOOL_PREFIX);
+	while (1) {
+		printf("\n  Marvell Voice Tool (DFEV Edition):\n");
+		printf("  2. Start ring\n");
+		printf("  3. Stop ring\n");
+		printf("  4. Start SW Dial tone\n");
+		printf("  5. Self echo on local phone\n");
+		printf("  6. Loopback two local phones\n");
+		printf("  a. Start Phone devices\n");
+		printf("  b. Stop Phone devices\n");
+		printf("  g. Set line gain\n");
+		printf("  q. Quit\n");
+		printf("\n%s Please select option: ", TOOL_PREFIX);
+
+		fgets(str, sizeof(str), stdin);
+		switch (str[0]) {
+		case '2':
+			printf("%s Enter line id: ", TOOL_PREFIX);
+			fgets(str, sizeof(str), stdin);
+			i = atoi(str);
+			printf("%s Start ringing on line %d\n", TOOL_PREFIX, i);
+			if (tapi_ring_start(th, TAPI_DEVICE, i) < 0)
+				printf("%s Error, could not change line state.\n", TOOL_PREFIX);
+			break;
+
+		case '3':
+			printf("%s Enter line id: ", TOOL_PREFIX);
+			fgets(str, sizeof(str), stdin);
+			i = atoi(str);
+			printf("%s Stop ringing on line %d\n", TOOL_PREFIX, i);
+			if (tapi_ring_stop(th, TAPI_DEVICE, i) < 0)
+				printf("%s Error, could not change line state.\n", TOOL_PREFIX);
+			break;
+
+		case '4':
+			printf("%s Enter line id: ", TOOL_PREFIX);
+			fgets(str, sizeof(str), stdin);
+			i = atoi(str);
+			sw_tone_test(tal_fd, i);
+			break;
+
+		case '5':
+			printf("%s Enter line id: ", TOOL_PREFIX);
+			fgets(str, sizeof(str), stdin);
+			printf("%s Waiting for off-hook...\n", TOOL_PREFIX);
+			i = atoi(str);
+			sw_loopback(tal_fd, i);
+			break;
+		case '6':
+			printf("%s Enter line #0: ", TOOL_PREFIX);
+			fgets(str, sizeof(str), stdin);
+			i = atoi(str);
+			printf("%s Enter line #1: ", TOOL_PREFIX);
+			fgets(str, sizeof(str), stdin);
+			printf("Waiting for off-hook...\n");
+			j = atoi(str);
+			if (i >= TAPI_CHANNELS || j >= TAPI_CHANNELS) {
+				printf("%s Error, line must be in the range of 0-%d\n", TOOL_PREFIX, (TAPI_CHANNELS - 1));
+				break;
+			}
+
+			sw_loopback_two_phones_test(tal_fd, i, j);
+			break;
+
+		case 'a':
+			/* Start Telephony */
+			if (ioctl(tal_fd, TAL_DEV_INIT, &tal_params)) {
+				printf("%s Error, unable to init TAL\n", TOOL_PREFIX);
+				return 1;
+			}
+
+			if (tapi_fw_download(th, TAPI_DEVICE, NULL) < 0) {
+				printf("%s Error, could not load tapi firmware.\n", TOOL_PREFIX);
+				break;
+			}
+
+			if (tapi_dev_start(th, TAPI_DEVICE) < 0) {
+				printf("%s Error, could not start tapi device.\n", TOOL_PREFIX);
+				break;
+			}
+
+			if (tapi_bbd_download(th, TAPI_DEVICE, -1, NULL) < 0) {
+				printf("%s Error, could not load tapi configuration.\n", TOOL_PREFIX);
+				break;
+			}
+
+			for (i = 0; i < TAPI_CHANNELS; i++) {
+				if (tapi_event_enable(th, TAPI_DEVICE, i, TAPI_EVENT_FXS_ONHOOK) < 0) {
+					printf("%s Error, could enable event reporting.\n", TOOL_PREFIX);
+					break;
+				}
+
+				if (tapi_event_enable(th, TAPI_DEVICE, i, TAPI_EVENT_FXS_OFFHOOK) < 0) {
+					printf("%s Error, could enable event reporting.\n", TOOL_PREFIX);
+					break;
+				}
+
+				if (tapi_event_enable(th, TAPI_DEVICE, i, TAPI_EVENT_CALIBRATION_END) < 0) {
+					printf("%s Error, could enable event reporting.\n", TOOL_PREFIX);
+					break;
+				}
+			}
+
+			if (i != TAPI_CHANNELS)
+				break;
+
+			/* Wait to device/s and line/s calibration to finish */
+			cal_lines = 0;
+			while (cal_lines < TAPI_CHANNELS) {
+				printf("%s SLIC: Calibrating line %u ...\n", TOOL_PREFIX, cal_lines);
+
+				if (tapi_line_calibrate(th, TAPI_DEVICE, cal_lines) < 0) {
+					printf("%s Error, could not calibrate line.\n", TOOL_PREFIX);
+					break;
+				}
+
+				wait_for_event(1);
+			}
+
+			if (cal_lines != TAPI_CHANNELS)
+				break;
+
+			for (i = 0; i < TAPI_CHANNELS; i++) {
+				if (tapi_line_feed_set(th, TAPI_DEVICE, i, TAPI_LINE_FEED_STANDBY) < 0) {
+					printf("%s Error, could not set line feed.\n", TOOL_PREFIX);
+					break;
+				}
+			}
+
+			if (i != TAPI_CHANNELS)
+				break;
+
+			slic_init = 1;
+			break;
+
+		case 'b':
+			release(0);
+			break;
+
+		case 'g':
+			printf("%s Enter line id: ", TOOL_PREFIX);
+			fgets(str, sizeof(str), stdin);
+			i = atoi(str);
+
+			printf("%s Enter RX gain [dB]: ", TOOL_PREFIX);
+			fgets(str, sizeof(str), stdin);
+			rxgain = atoi(str);
+
+			printf("%s Enter TX gain [dB]: ", TOOL_PREFIX);
+			fgets(str, sizeof(str), stdin);
+			txgain = atoi(str);
+
+			if (tapi_phone_volume_set(th, TAPI_DEVICE, i, rxgain, txgain) < 0)
+				printf("%s Error, could not set line gain.\n", TOOL_PREFIX);
+			break;
+
+		case 'q':
+			goto voice_out;
+
+		default:
+			printf("Option is not supported - try again\n");
+			break;
+		}
+	}
+
+voice_out:
+	release(1);
+
+	return 0;
+}
-- 
1.7.5.4

