From 8547ce8537c28bcee3f7b2fd00440ef7b8ffbb31 Mon Sep 17 00:00:00 2001
From: Ofer Heifetz <oferh@marvell.com>
Date: Tue, 4 Mar 2014 15:35:16 +0200
Subject: [PATCH 1425/1825] prestera: msys: add prestera driver support

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 1162a3d44c7cdb403c90933cbafa30910b0de77e

        This commit adds the mvPP (prestera) driver to LSP, a new driver
        was added to the mv_driver_lsp directory called mv_prestra.
        The driver is enabled by default for MSYS and supports
        currently MSYS only.
        Changes:
        - The DFX register mapping was modified to be after the switch
          address space (1MB)
        - Switch registers are mapped to CPU (64MB)
        - Added a mapping between the DRAM and switch (2MB) for DMA
          (used by Rx/Tx/AU). To allocate memory user needs to set the
          Linux memory to be less than the physical DDR size by 2MB
          (in uboot set: mem=[phy_mem_size]-2M)
        - the /proc/mvPP entry can be used to see some driver internal
          information/counters
        The driver was tested on BC2 DB system (w and w/o pex) using
        CPSS v4.1.
        Tested features via CPSS:
                - NA learning
                - link status interrupts
                - RX/TX from CPU

Change-Id: Ic8126fa299d84fb6e68412f70bfb6590f908ea2c
Signed-off-by: Ofer Heifetz <oferh@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/6140
Reviewed-by: Omri Itach <omrii@marvell.com>
Reviewed-by: Yehuda Yitschak <yehuday@marvell.com>
Tested-by: Yehuda Yitschak <yehuday@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-msys/Makefile                        |    1 +
 arch/arm/mach-msys/config/mvRules.mk               |    6 +-
 arch/arm/mach-msys/include/mach/msys.h             |   20 +-
 .../mach-msys/msys_family/ctrlEnv/mvCtrlEnvRegs.h  |    1 +
 .../mach-msys/msys_family/ctrlEnv/mvCtrlEnvSpec.h  |   97 +-
 .../msys_family/ctrlEnv/sys/mvAhbToMbus.c          |   55 +-
 arch/arm/mach-msys/sysmap.c                        |    4 +-
 arch/arm/plat-armada/Kconfig                       |   10 +
 .../mv_drivers_lsp/mv_prestera/Makefile            |   10 +
 .../mv_drivers_lsp/mv_prestera/mv_prestera.c       | 1289 ++++++++++++++++
 .../mv_drivers_lsp/mv_prestera/mv_prestera.h       |  138 ++
 .../mv_drivers_lsp/mv_prestera/mv_prestera_glob.h  |  200 +++
 .../mv_drivers_lsp/mv_prestera/mv_prestera_irq.c   |  265 ++++
 .../mv_drivers_lsp/mv_prestera/mv_prestera_irq.h   |  133 ++
 .../mv_drivers_lsp/mv_prestera/mv_prestera_smi.c   | 1004 +++++++++++++
 .../mv_drivers_lsp/mv_prestera/mv_prestera_smi.h   |   90 ++
 .../mv_prestera/mv_prestera_smi_glob.h             |  204 +++
 .../mv_drivers_lsp/mv_prestera/mv_pss_api.c        | 1565 ++++++++++++++++++++
 .../mv_drivers_lsp/mv_prestera/mv_pss_api.h        | 1189 +++++++++++++++
 19 files changed, 6176 insertions(+), 105 deletions(-)
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/Makefile
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_glob.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_irq.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_irq.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_smi.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_smi.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_smi_glob.h
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_pss_api.c
 create mode 100644 arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_pss_api.h

diff --git a/arch/arm/mach-msys/Makefile b/arch/arm/mach-msys/Makefile
index 4a76f1c..39fdaae 100644
--- a/arch/arm/mach-msys/Makefile
+++ b/arch/arm/mach-msys/Makefile
@@ -57,6 +57,7 @@ obj-$(CONFIG_MV_ETH_NETA)		+= $(LSP_NETA_DIR)/
 # drivers part
 obj-$(CONFIG_MV_INCLUDE_GIG_ETH)	+= $(LSP_PHY_DIR)/phy_sysfs.o
 obj-$(CONFIG_MV_USE_XOR_ENGINE) 	+= $(PLAT_DRIVERS)/mv_xor/
+obj-$(CONFIG_MV_INCLUDE_PRESTERA) 	+= $(PLAT_DRIVERS)/mv_prestera/
 obj-$(CONFIG_ERROR_HANDLING)		+= $(LSP_ERR_DIR)/mv_error.o
 obj-y					+= $(PLAT_DRIVERS)/mv_gpio/
 obj-$(CONFIG_MV_DBG_TRACE)              += $(PLAT_DRIVERS)/mv_trace/
diff --git a/arch/arm/mach-msys/config/mvRules.mk b/arch/arm/mach-msys/config/mvRules.mk
index 9c7545c..a1d8063 100644
--- a/arch/arm/mach-msys/config/mvRules.mk
+++ b/arch/arm/mach-msys/config/mvRules.mk
@@ -85,6 +85,9 @@ LSP_MUX_DIR       = $(PLAT_DRIVERS)/mv_mux
 LSP_ERR_DIR       = $(PLAT_DRIVERS)/mv_error
 LSP_IPC_DIR       = $(PLAT_DRIVERS)/mv_ipc/linux_amp
 
+ifeq ($(CONFIG_MV_INCLUDE_PRESTERA),y)
+LSP_PRESTERA_DIR  = $(PLAT_DRIVERS)/mv_prestera
+endif
 
 # Environment components
 MSYS_FAM_DIR	= msys_family
@@ -112,7 +115,8 @@ LSP_PATH        = -I$(LSP_PATH_I)
 CONFIG_PATH     = -I$(LSP_PATH_I)/$(CONFIG_DIR)
 HAL_IF_PATH	= -I$(LSP_PATH_I)/$(HAL_IF)
 DRIVERS_LSP_PATH = -I$(PLAT_PATH_I)/$(PLAT_DRIVERS) -I$(PLAT_PATH_I)/$(LSP_NETWORK_DIR) -I$(PLAT_PATH_I)/$(LSP_SWITCH_DIR) \
-		-I$(PLAT_PATH_I)/$(LSP_TRACE_DIR) -I$(PLAT_PATH_I)/$(LSP_NETA_DIR) -I$(PLAT_PATH_I)/$(LSP_IPC_DIR)
+		-I$(PLAT_PATH_I)/$(LSP_TRACE_DIR) -I$(PLAT_PATH_I)/$(LSP_NETA_DIR) -I$(PLAT_PATH_I)/$(LSP_IPC_DIR) \
+		-I$(PLAT_PATH_I)/$(LSP_PRESTERA_DIR)
 
 EXTRA_INCLUDE  	= $(OSSERV_PATH) $(COMMON_PATH) $(HAL_PATH)  $(MSYS_FAM_PATH) \
                   $(LSP_PATH) $(CONFIG_PATH) $(DRIVERS_LSP_PATH) $(HAL_IF_PATH)
diff --git a/arch/arm/mach-msys/include/mach/msys.h b/arch/arm/mach-msys/include/mach/msys.h
index f624f77..5374568 100644
--- a/arch/arm/mach-msys/include/mach/msys.h
+++ b/arch/arm/mach-msys/include/mach/msys.h
@@ -90,14 +90,6 @@ disclaimer.
 #define INTER_REGS_BASE			INTER_REGS_VIRT_BASE /* For compatibility */
 /* #define INTER_REGS_SIZE		SZ_1M */
 
-/*
- * DFX Internal registers.
- * PHYS: 0xF1100000 - 0xF1200000
- * VIRT: 0xFB100000 - 0xFB200000
- */
-#define DFX_REGS_PHYS_BASE		0xF1100000
-#define DFX_REGS_VIRT_BASE		0xFB100000
-#define DFX_REGS_SIZE			SZ_1M
 
 /*
  * Uart registers.
@@ -170,6 +162,18 @@ disclaimer.
  * Free area from 0xF9000000 to 0xFFF00000 (111MB).
  * This can be used to map a larger window for PCI / SPI / Device-CS....
  */
+#define SWITCH_REGS_PHYS_BASE		0xF8000000
+#define SWITCH_REGS_VIRT_BASE		0xFB400000
+#define SWITCH_REGS_SIZE		SZ_64M
+
+/*
+ * DFX Internal registers.
+ * PHYS: 0xF1100000 - 0xF1200000
+ * VIRT: 0xFB100000 - 0xFB200000
+ */
+#define DFX_REGS_PHYS_BASE              0xFC000000
+#define DFX_REGS_VIRT_BASE              0xFF400000
+#define DFX_REGS_SIZE                   SZ_1M
 
 
 /*
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvRegs.h b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvRegs.h
index b88f3a4..44da435 100644
--- a/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvRegs.h
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvRegs.h
@@ -280,6 +280,7 @@ extern "C" {
 typedef enum _mvTargetId {
 	DRAM_TARGET_ID   = 0,	/* Port 0 -> DRAM interface		*/
 	DEV_TARGET_ID    = 1,	/* Port 1 -> Device port, BootROM, SPI	*/
+	SWITCH_TARGET_ID = 3,	/* Port 3 -> Switching Core Adapter/units */
 	PEX0_TARGET_ID   = 4,	/* Port 4 -> PCI Express 0		*/
 	DFX_TARGET_ID    = 8,	/* Port 8 -> DFX Server			*/
 	CRYPT_TARGET_ID  = 9,	/* Port 9 --> Crypto Engine SRAM	*/
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvSpec.h b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvSpec.h
index f78d5a5..2db8944 100644
--- a/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvSpec.h
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/mvCtrlEnvSpec.h
@@ -269,17 +269,18 @@ typedef enum _mvTarget {
 	PEX0_IO,	/*  9 PCI Express 0 IO		*/
 	INTER_REGS,	/* 10 Internal registers	*/
 	DFX_REGS,	/* 11 DFX Internal registers	*/
-	DMA_UART,	/* 12 DMA based UART request	*/
-	SPI_CS0,	/* 13 SPI_CS0			*/
-	SPI_CS1,	/* 14 SPI_CS1			*/
-	SPI_CS2,	/* 15 SPI_CS2			*/
-	SPI_CS3,	/* 16 SPI_CS3			*/
-	SPI_CS4,	/* 17 SPI_CS4			*/
-	SPI_CS5,	/* 18 SPI_CS5			*/
-	SPI_CS6,	/* 19 SPI_CS6			*/
-	SPI_CS7,	/* 20 SPI_CS7			*/
-	BOOT_ROM_CS, 	/* 21 BOOT_ROM_CS		*/
-	DEV_BOOCS,	/* 22 DEV_BOOCS			*/
+	SWITCH,		/* 12 SWITCH			*/
+	DMA_UART,	/* 13 DMA based UART request	*/
+	SPI_CS0,	/* 14 SPI_CS0			*/
+	SPI_CS1,	/* 15 SPI_CS1			*/
+	SPI_CS2,	/* 16 SPI_CS2			*/
+	SPI_CS3,	/* 17 SPI_CS3			*/
+	SPI_CS4,	/* 18 SPI_CS4			*/
+	SPI_CS5,	/* 19 SPI_CS5			*/
+	SPI_CS6,	/* 20 SPI_CS6			*/
+	SPI_CS7,	/* 21 SPI_CS7			*/
+	BOOT_ROM_CS,	/* 22 BOOT_ROM_CS		*/
+	DEV_BOOCS,	/* 23 DEV_BOOCS			*/
 	MAX_TARGETS
 } MV_TARGET;
 
@@ -296,55 +297,57 @@ typedef enum _mvTarget {
 #endif
 
 #define TARGETS_DEF_ARRAY	{			\
-	{DRAM_CS0_ATTR, DRAM_TARGET_ID   },	/*  0 SDRAM_CS0 */	\
-	{DRAM_CS1_ATTR, DRAM_TARGET_ID   },	/*  1 SDRAM_CS1 */	\
-	{DRAM_CS2_ATTR, DRAM_TARGET_ID   },	/*  2 SDRAM_CS0 */	\
-	{DRAM_CS3_ATTR, DRAM_TARGET_ID   },	/*  3 SDRAM_CS1 */	\
-	{0x3E, DEV_TARGET_ID    },		/*  4 DEVICE_CS0 */	\
-	{0x3D, DEV_TARGET_ID    },		/*  5 DEVICE_CS1 */	\
-	{0x3B, DEV_TARGET_ID    },		/*  6 DEVICE_CS2 */	\
-	{0x37, DEV_TARGET_ID    },		/*  7 DEVICE_CS3 */	\
+	{DRAM_CS0_ATTR, DRAM_TARGET_ID	},	/*  0 SDRAM_CS0 */	\
+	{DRAM_CS1_ATTR, DRAM_TARGET_ID	},	/*  1 SDRAM_CS1 */	\
+	{DRAM_CS2_ATTR, DRAM_TARGET_ID	},	/*  2 SDRAM_CS0 */	\
+	{DRAM_CS3_ATTR, DRAM_TARGET_ID	},	/*  3 SDRAM_CS1 */	\
+	{0x3E, DEV_TARGET_ID	},		/*  4 DEVICE_CS0 */	\
+	{0x3D, DEV_TARGET_ID	},		/*  5 DEVICE_CS1 */	\
+	{0x3B, DEV_TARGET_ID	},		/*  6 DEVICE_CS2 */	\
+	{0x37, DEV_TARGET_ID	},		/*  7 DEVICE_CS3 */	\
 	{0xE8, PEX0_TARGET_ID	},		/*  8 PEX0_LANE0_MEM */	\
 	{0xE0, PEX0_TARGET_ID	},		/*  9 PEX0_LANE0_IO */	\
-	{0xFF, 0xFF             },		/* 10 INTER_REGS */	\
+	{0xFF, 0xFF		},		/* 10 INTER_REGS */	\
 	{0x00, DFX_TARGET_ID	},		/* 11 DFX_INTER_REGS */	\
-	{0x01, DEV_TARGET_ID    },		/* 12 DMA_UART */	\
-	{0x1E, DEV_TARGET_ID    },		/* 13 SPI_CS0 */	\
-	{0x5E, DEV_TARGET_ID    },		/* 14 SPI_CS1 */	\
-	{0x9E, DEV_TARGET_ID    },		/* 15 SPI_CS2 */	\
-	{0xDE, DEV_TARGET_ID    },		/* 16 SPI_CS3 */	\
-	{0x1F, DEV_TARGET_ID    },		/* 17 SPI_CS4 */	\
-	{0x5F, DEV_TARGET_ID    },		/* 18 SPI_CS5 */	\
-	{0x9F, DEV_TARGET_ID    },		/* 19 SPI_CS6 */	\
-	{0xDF, DEV_TARGET_ID    },		/* 20 SPI_CS7 */	\
-	{0x1D, DEV_TARGET_ID    },		/* 21 BOOT_ROM_CS (Main Boot device )*/	\
-	{0x2F, DEV_TARGET_ID    },		/* 22 DEV_BOOT_CS (Secondary Boot device,)*/	\
+	{0x00, SWITCH_TARGET_ID	},		/* 12 SWITCH_TARGET_REGS */\
+	{0x01, DEV_TARGET_ID	},		/* 13 DMA_UART */	\
+	{0x1E, DEV_TARGET_ID	},		/* 14 SPI_CS0 */	\
+	{0x5E, DEV_TARGET_ID	},		/* 15 SPI_CS1 */	\
+	{0x9E, DEV_TARGET_ID	},		/* 16 SPI_CS2 */	\
+	{0xDE, DEV_TARGET_ID	},		/* 17 SPI_CS3 */	\
+	{0x1F, DEV_TARGET_ID	},		/* 18 SPI_CS4 */	\
+	{0x5F, DEV_TARGET_ID	},		/* 19 SPI_CS5 */	\
+	{0x9F, DEV_TARGET_ID	},		/* 20 SPI_CS6 */	\
+	{0xDF, DEV_TARGET_ID	},		/* 21 SPI_CS7 */	\
+	{0x1D, DEV_TARGET_ID	},		/* 22 BOOT_ROM_CS (Main Boot device )*/	\
+	{0x2F, DEV_TARGET_ID	},		/* 23 DEV_BOOT_CS (Secondary Boot device,)*/	\
 }
 
 #define TARGETS_NAME_ARRAY	{			\
-	"SDRAM_CS0",    	/*  0 SDRAM_CS0 */	\
-	"SDRAM_CS1",    	/*  1 SDRAM_CS1 */	\
-	"SDRAM_CS2",    	/*  2 SDRAM_CS1 */	\
-	"SDRAM_CS3",    	/*  3 SDRAM_CS1 */	\
+	"SDRAM_CS0",		/*  0 SDRAM_CS0 */	\
+	"SDRAM_CS1",		/*  1 SDRAM_CS1 */	\
+	"SDRAM_CS2",		/*  2 SDRAM_CS1 */	\
+	"SDRAM_CS3",		/*  3 SDRAM_CS1 */	\
 	"DEVICE_CS0",		/*  4 DEVICE_CS0 */	\
 	"DEVICE_CS1",		/*  5 DEVICE_CS1 */	\
 	"DEVICE_CS2",		/*  6 DEVICE_CS2 */	\
 	"DEVICE_CS3",		/*  7 DEVICE_CS3 */	\
 	"PEX0_MEM",		/*  8 PEX0_MEM */	\
-	"PEX0_IO",		/*  9 PEX0_IO */		\
+	"PEX0_IO",		/*  9 PEX0_IO */	\
 	"INTER_REGS",		/* 10 INTER_REGS */	\
 	"DFX_INTER_REGS",	/* 11 INTER_REGS */	\
-	"DMA_UART",		/* 12 DMA_UART */	\
-	"SPI_CS0",		/* 13 SPI_CS0 */	\
-	"SPI_CS1",		/* 14 SPI_CS1 */	\
-	"SPI_CS2",		/* 15 SPI_CS2 */	\
-	"SPI_CS3",		/* 16 SPI_CS3 */	\
-	"SPI_CS4",		/* 17 SPI_CS4 */	\
-	"SPI_CS5",		/* 18 SPI_CS5 */	\
-	"SPI_CS6",		/* 19 SPI_CS6 */	\
-	"SPI_CS7",		/* 20 SPI_CS7 */	\
-	"BOOT_ROM_CS",		/* 21 BOOT_ROM_CS */	\
-	"DEV_BOOTCS",		/* 22 DEV_BOOCS */	\
+	"SWITCH_REGS",		/* 12 SWITCH_REGS */	\
+	"DMA_UART",		/* 13 DMA_UART */	\
+	"SPI_CS0",		/* 14 SPI_CS0 */	\
+	"SPI_CS1",		/* 15 SPI_CS1 */	\
+	"SPI_CS2",		/* 16 SPI_CS2 */	\
+	"SPI_CS3",		/* 17 SPI_CS3 */	\
+	"SPI_CS4",		/* 18 SPI_CS4 */	\
+	"SPI_CS5",		/* 19 SPI_CS5 */	\
+	"SPI_CS6",		/* 20 SPI_CS6 */	\
+	"SPI_CS7",		/* 22 SPI_CS7 */	\
+	"BOOT_ROM_CS",		/* 23 BOOT_ROM_CS */	\
+	"DEV_BOOTCS",		/* 24 DEV_BOOCS */	\
 }
 
 
diff --git a/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvAhbToMbus.c b/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvAhbToMbus.c
index 1cc1aa3..e4608ab 100644
--- a/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvAhbToMbus.c
+++ b/arch/arm/mach-msys/msys_family/ctrlEnv/sys/mvAhbToMbus.c
@@ -198,7 +198,6 @@ MV_STATUS mvAhbToMbusWinSet(MV_U32 winNum, MV_AHB_TO_MBUS_DEC_WIN *pAddrDecWin)
 	else
 		MV_REG_WRITE(AHB_TO_MBUS_WIN_INTEREG_REG, decRegs.baseReg);
 
-
 	/* Internal register space have no size */
 	/* register. Do not perform size register assigment for those targets   */
 	if (winNum != MV_AHB_TO_MBUS_INTREG_WIN) {
@@ -643,67 +642,27 @@ static MV_STATUS ahbToMbusRemapRegOffsGet(MV_U32 winNum, AHB_TO_MBUS_REMAP_REG_O
 	switch (winNum) {
 	case 0:
 	case 1:
-		pRemapRegs->lowRegOffs = AHB_TO_MBUS_WIN_REMAP_LOW_REG(winNum);
-		pRemapRegs->highRegOffs = AHB_TO_MBUS_WIN_REMAP_HIGH_REG(winNum);
-		break;
 	case 2:
 	case 3:
-		if ((mvCtrlModelGet() == MV_5281_DEV_ID) ||
-			(mvCtrlModelGet() == MV_1281_DEV_ID) ||
-			(mvCtrlModelGet() == MV_6183_DEV_ID) ||
-			(mvCtrlModelGet() == MV_6183L_DEV_ID) ||
-			(mvCtrlModelGet() == MV_6710_DEV_ID) ||
-			(mvCtrlModelGet() == MV_78130_DEV_ID) ||
-			(mvCtrlModelGet() == MV_78160_DEV_ID) ||
-			(mvCtrlModelGet() == MV_78230_DEV_ID) ||
-			(mvCtrlModelGet() == MV_78260_DEV_ID) ||
-			(mvCtrlModelGet() == MV_78460_DEV_ID) ||
-			(mvCtrlModelGet() == MV_78000_DEV_ID)) {
-			pRemapRegs->lowRegOffs = AHB_TO_MBUS_WIN_REMAP_LOW_REG(winNum);
-			pRemapRegs->highRegOffs = AHB_TO_MBUS_WIN_REMAP_HIGH_REG(winNum);
-			break;
-		} else {
-			pRemapRegs->lowRegOffs = 0;
-			pRemapRegs->highRegOffs = 0;
-
-			DB(mvOsPrintf("ahbToMbusRemapRegOffsGet: ERR. Invalid winNum %d\n", winNum));
-			return MV_NO_SUCH;
-		}
-		break;
 	case 4:
 	case 5:
 	case 6:
 	case 7:
-		if ((mvCtrlModelGet() == MV_5281_DEV_ID) ||
-			   (mvCtrlModelGet() == MV_1281_DEV_ID) ||
-			   (mvCtrlModelGet() == MV_6183_DEV_ID) ||
-			   (mvCtrlModelGet() == MV_6183L_DEV_ID) ||
-			   (mvCtrlModelGet() == MV_6710_DEV_ID) ||
-			   (mvCtrlModelGet() == MV_78130_DEV_ID) ||
-			   (mvCtrlModelGet() == MV_78160_DEV_ID) ||
-			   (mvCtrlModelGet() == MV_78230_DEV_ID) ||
-			   (mvCtrlModelGet() == MV_78260_DEV_ID) ||
-			   (mvCtrlModelGet() == MV_78460_DEV_ID) ||
-			   (mvCtrlModelGet() == MV_78000_DEV_ID)) {
-			pRemapRegs->lowRegOffs = AHB_TO_MBUS_WIN_REMAP_LOW_REG(winNum);
-			pRemapRegs->highRegOffs = AHB_TO_MBUS_WIN_REMAP_HIGH_REG(winNum);
-			break;
-		} else {
-			pRemapRegs->lowRegOffs = 0;
-			pRemapRegs->highRegOffs = 0;
-
-			DB(mvOsPrintf("ahbToMbusRemapRegOffsGet: ERR. Invalid winNum %d\n", winNum));
-			return MV_NO_SUCH;
-		}
+		pRemapRegs->lowRegOffs = AHB_TO_MBUS_WIN_REMAP_LOW_REG(winNum);
+		pRemapRegs->highRegOffs = AHB_TO_MBUS_WIN_REMAP_HIGH_REG(winNum);
 		break;
+
 	default:
 		pRemapRegs->lowRegOffs = 0;
 		pRemapRegs->highRegOffs = 0;
 
-		DB(mvOsPrintf("ahbToMbusRemapRegOffsGet: ERR. Invalid winNum %d\n", winNum));
+		DB(mvOsPrintf("%s: ERR. Invalid winNum %d\n", __func__, winNum));
 		return MV_NO_SUCH;
 	}
 
+	DB(mvOsPrintf("%s: winNum %d pRemapRegs->lowRegOffs 0x%x pRemapRegs->highRegOffs 0x%x\n",
+		__func__, winNum, pRemapRegs->lowRegOffs, pRemapRegs->highRegOffs));
+
 	return MV_OK;
 }
 
diff --git a/arch/arm/mach-msys/sysmap.c b/arch/arm/mach-msys/sysmap.c
index 618c643..eef3442 100644
--- a/arch/arm/mach-msys/sysmap.c
+++ b/arch/arm/mach-msys/sysmap.c
@@ -31,10 +31,11 @@ disclaimer.
 #include "boardEnv/mvBoardEnvLib.h"
 #include <asm/mach/map.h>
 
-static struct map_desc MEM_TABLE[] =	{
+static struct map_desc MEM_TABLE[] __initdata =	{
 	/* no use for pex mem remap */
 	{ INTER_REGS_VIRT_BASE,		__phys_to_pfn(INTER_REGS_PHYS_BASE),	INTER_REGS_SIZE,	MT_DEVICE},
 	{ DFX_REGS_VIRT_BASE,		__phys_to_pfn(DFX_REGS_PHYS_BASE),	DFX_REGS_SIZE,		MT_DEVICE},
+	{ SWITCH_REGS_VIRT_BASE,	__phys_to_pfn(SWITCH_REGS_PHYS_BASE),	SWITCH_REGS_SIZE,	MT_DEVICE},
 	{ PEX0_IO_VIRT_BASE,		__phys_to_pfn(PEX0_IO_PHYS_BASE),	PEX0_IO_SIZE,		MT_DEVICE},
 };
 
@@ -52,6 +53,7 @@ static MV_CPU_DEC_WIN SYSMAP_MSYS[] = {
 	{{PEX0_IO_PHYS_BASE,		0,	PEX0_IO_SIZE		},	TBL_UNUSED,	DIS},	/* PEX_IO */
 	{{INTER_REGS_PHYS_BASE,		0,	INTER_REGS_SIZE		},	0x14,		EN},	/* INTER_REGS */
 	{{DFX_REGS_PHYS_BASE,		0,	DFX_REGS_SIZE		},	0x1,		EN},	/* DFX_REGS */
+	{{SWITCH_REGS_PHYS_BASE,	0,	SWITCH_REGS_SIZE	},	0x2,		EN},	/* SWITCH_REGS*/
 	{{UART_REGS_BASE,		0,	UART_SIZE		},	TBL_UNUSED,	DIS},	/* DMA_UART */
 	{{SPI_CS0_PHYS_BASE,		0,	SPI_CS0_SIZE		},	0xe,		EN},	/* SPI_CS0 */
 	{{TBL_UNUSED,			0,	TBL_UNUSED,		},	TBL_UNUSED,	DIS},	/* SPI_CS1 */
diff --git a/arch/arm/plat-armada/Kconfig b/arch/arm/plat-armada/Kconfig
index 3f32e94c..e870405 100644
--- a/arch/arm/plat-armada/Kconfig
+++ b/arch/arm/plat-armada/Kconfig
@@ -193,6 +193,16 @@ config MV_INCLUDE_SWITCH
 	help
 	  TBD
 
+config MV_INCLUDE_PRESTERA
+	bool "Prestera Switch Support"
+	depends on ARCH_MSYS
+	default y
+	help
+	Add Prestera mvPP char device driver support,
+	used by user space to configure and interact with
+	Prestera Packet Procesors, currently supporting only MSYS.
+	This option should be enabled when using CPSS.
+
 config MV_SUPPORT_COMMON_MPP_FLASH
 	bool "Flash Support"
 	depends on ARMADA_38X
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/Makefile b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/Makefile
new file mode 100644
index 0000000..29350c0
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/Makefile
@@ -0,0 +1,10 @@
+#
+# Makefile for the Marvell Prestera Device Driver
+#
+ifneq ($(MACHINE),)
+include $(srctree)/$(MACHINE)/config/mvRules.mk
+endif
+
+
+obj-$(CONFIG_MV_INCLUDE_PRESTERA)	+= mvPrestera.o
+mvPrestera-objs				+= mv_prestera.o mv_prestera_irq.o mv_prestera_smi.o mv_pss_api.o
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera.c
new file mode 100644
index 0000000..cf5f22a
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera.c
@@ -0,0 +1,1289 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+********************************************************************************
+   Marvell Commercial License Option
+
+   If you received this File from Marvell and you have entered into a commercial
+   license agreement (a "Commercial License") with Marvell, the File is licensed
+   to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+********************************************************************************
+   Marvell BSD License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File under the following licensing terms.
+   Redistribution and use in source and binary forms, with or without modification,
+   are permitted provided that the following conditions are met:
+
+*   Redistributions of source code must retain the above copyright notice,
+    this list of conditions and the following disclaimer.
+
+*   Redistributions in binary form must reproduce the above copyright
+    notice, this list of conditions and the following disclaimer in the
+    documentation and/or other materials provided with the distribution.
+
+*   Neither the name of Marvell nor the names of its contributors may be
+    used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+   ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+   ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+********************************************************************************
+* mv_prestera.c
+*
+* DESCRIPTION:
+*	functions in kernel mode special for prestera.
+*
+* DEPENDENCIES:
+*
+*******************************************************************************/
+
+#include <asm/uaccess.h>
+#include <asm/unistd.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/cdev.h>
+#include <linux/proc_fs.h>
+#include <linux/interrupt.h>
+#include <linux/mm.h>
+#include <linux/dma-mapping.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/syscalls.h>
+#include <linux/sched.h>
+#include <linux/signal.h>
+#include <linux/kallsyms.h>
+
+#include "mvOs.h"
+#include "mvDeviceId.h"
+#include "ctrlEnv/mvCtrlEnvLib.h"
+#include "mvCommon.h"
+#include "mv_prestera_glob.h"
+#include "mv_prestera_smi.h"
+#include "mv_prestera_smi_glob.h"
+#include "mv_prestera_irq.h"
+#include "mv_prestera.h"
+#include "mv_pss_api.h"
+
+#undef MV_DEBUG
+
+/* defines  */
+#ifdef MV_DEBUG
+#define DB(x)   x
+#else
+#define DB(x)
+#endif
+
+#define PRV_CPSS_MAX_PP_DEVICES_CNS	3
+
+/* local variables and variables */
+static int			dev_open_nr;
+static int			dev_init_done;
+static struct prestera_device	*prestera_dev;
+static int			prestera_major = PRESTERA_MAJOR;
+static struct cdev		prestera_cdev;
+static const char		*prestera_dev_name = "mvPP";
+static unsigned long		pci_phys_addr[PRV_CPSS_MAX_PP_DEVICES_CNS];
+static int			pci_phys_blocks;
+static struct pp_dev		*ppdevs[PRV_CPSS_MAX_PP_DEVICES_CNS];
+static int			founddevs;
+static unsigned long		dma_base;
+static unsigned int		dma_len;
+static void			*dma_area;
+static void			*dma_tmp_virt;
+static dma_addr_t		dma_tmp_phys;
+
+
+/************************************************************************
+ *
+ * prestera_mapped_virt2phys: convert userspace address to physical
+ * Only for mmaped areas
+ *
+ */
+static unsigned long prestera_mapped_virt2phys(unsigned long address)
+{
+	int ppNum;
+
+	switch ((address & CPSS_VIRT_ADDR_MASK)) {
+	case CPSS_DMA_VIRT_ADDR:
+		address &= 0x0fffffff;
+		if (address >= dma_len)
+			return 0;
+		address += dma_base;
+		return address;
+
+	case CPSS_SWITCH_VIRT_ADDR:
+		/* PSS regs */
+		address -= CPSS_SWITCH_VIRT_ADDR;
+		ppNum = address >> 26;
+		if (ppNum >= pci_phys_blocks)
+			return 0;
+		address &= 0x03ffffff;
+		address += pci_phys_addr[ppNum];
+		return address;
+	}
+
+	/* default */
+	return 0;
+}
+
+
+/************************************************************************
+ *
+ * prestera_DmaRead: bspDmaRead() wrapper
+ */
+static int prestera_dma_read(unsigned long address,
+			     unsigned long length,
+			     unsigned long burstLimit,
+			     unsigned long buffer)
+{
+	unsigned long bufferPhys;
+	unsigned long tmpLength;
+
+	DB(mvOsPrintf("%s(address=0x%lx, length=0x%lx, burstLimit=0x%lx, buffer=0x%lx)\n",
+		      __func__,
+		      (unsigned long)(address),
+		      (unsigned long)(length),
+		      (unsigned long)burstLimit,
+		      (unsigned long)buffer));
+
+	/* first convert source address to physical */
+	address = prestera_mapped_virt2phys(address);
+	if (!address)
+		return -EFAULT;
+
+	bufferPhys = prestera_mapped_virt2phys(buffer);
+	if (bufferPhys)
+		return bspDmaRead(address, length, burstLimit, (unsigned long *)bufferPhys);
+
+	/* use dma_tmp buffer */
+	while (length > 0) {
+		tmpLength = (length > (PAGE_SIZE / 4)) ? PAGE_SIZE / 4 : length;
+
+		if (bspDmaRead(address, tmpLength, burstLimit, (unsigned long *)dma_tmp_phys))
+			return -EFAULT;
+
+		length -= tmpLength;
+		tmpLength *= 4;
+		if (copy_to_user((void *)buffer, dma_tmp_virt, tmpLength))
+			return -EFAULT;
+
+		address += tmpLength;
+		buffer += tmpLength;
+	}
+	return 0;
+}
+
+/************************************************************************
+ *
+ * prestera_DmaWrite: bspDmaRead() wrapper
+ */
+static int prestera_dma_write(unsigned long address,
+			      unsigned long length,
+			     unsigned long burstLimit,
+			     unsigned long buffer)
+{
+	unsigned long bufferPhys;
+	unsigned long tmpLength;
+
+	DB(mvOsPrintf("%s(address=0x%lx, length=0x%lx, burstLimit=0x%lx, buffer=0x%lx)\n",
+		      __func__,
+		      (unsigned long)(address),
+		      (unsigned long)(length),
+		      (unsigned long)burstLimit,
+		      (unsigned long)buffer));
+
+	/* first convert source address to physical */
+	address = prestera_mapped_virt2phys(address);
+	if (!address)
+		return -EFAULT;
+
+	bufferPhys = prestera_mapped_virt2phys(buffer);
+	if (bufferPhys)
+		return bspDmaWrite(address, (unsigned long *)bufferPhys, length, burstLimit);
+	/* use dma_tmp buffer */
+	while (length > 0) {
+		tmpLength = (length > (PAGE_SIZE / 4)) ? PAGE_SIZE / 4 : length;
+
+		if (copy_from_user(dma_tmp_virt, (void *)buffer, tmpLength * 4))
+			return -EFAULT;
+
+		if (bspDmaWrite(address, (unsigned long *)dma_tmp_phys, tmpLength, burstLimit))
+			return -EFAULT;
+
+		length -= tmpLength;
+		tmpLength *= 4;
+		address += tmpLength;
+		buffer += tmpLength;
+	}
+	return 0;
+}
+
+static loff_t prestera_lseek(struct file *filp, loff_t off, int whence)
+{
+	struct prestera_device	*dev;
+	loff_t			newpos;
+
+	dev = (struct prestera_device *)filp->private_data;
+
+	DB(mvOsPrintf("%s(whence=0x%lx, off=0x%lx)\n",
+		      __func__,
+		      (unsigned long)(whence),
+		      (unsigned long)(off)));
+
+	switch (whence) {
+	case 0: /* SEEK_SET */
+		newpos = off;
+		break;
+
+	case 1: /* SEEK_CUR */
+		newpos = filp->f_pos + off;
+		break;
+
+	case 2: /* SEEK_END */
+		newpos = dev->size + off;
+		break;
+
+	default: /* can't happend */
+		mvOsPrintf(KERN_ERR "%s whence %d ERROR\n", __func__, whence);
+		return -EINVAL;
+	}
+	if (newpos < 0)
+		return -EINVAL;
+
+	if (newpos >= dev->size)
+		return -EINVAL;
+
+	filp->f_pos = newpos;
+	return newpos;
+}
+
+#ifdef MV_DEBUG
+static void ioctl_cmd_pr(unsigned int cmd)
+{
+	char *dir;
+
+	static const char * const prestera_ioctls[] = {
+		[_IOC_NR(PRESTERA_IOC_HWRESET)]	= "HW_RESET",
+		[_IOC_NR(PRESTERA_IOC_INTCONNECT)] = "INT_CONNECT",
+		[_IOC_NR(PRESTERA_IOC_INTENABLE)] = "INT_ENABLE",
+		[_IOC_NR(PRESTERA_IOC_INTDISABLE)] = "INT_DISABLE",
+		[_IOC_NR(PRESTERA_IOC_WAIT)] = "WAIT",
+		[_IOC_NR(PRESTERA_IOC_FIND_DEV)] = "FIND_DEV",
+		[_IOC_NR(PRESTERA_IOC_PCICONFIGWRITEREG)] = "PCI_CONFIG_WRITE_REG",
+		[_IOC_NR(PRESTERA_IOC_PCICONFIGREADREG)] = "PCI_CONFIG_READ_REG",
+		[_IOC_NR(PRESTERA_IOC_GETINTVEC)] = "GET_INT_VEC",
+		[_IOC_NR(PRESTERA_IOC_FLUSH)] = "FLUSH",
+		[_IOC_NR(PRESTERA_IOC_INVALIDATE)] = "INVALIDATE",
+		[_IOC_NR(PRESTERA_IOC_GETBASEADDR)] = "GET_BASE_ADDR",
+		[_IOC_NR(PRESTERA_IOC_DMAWRITE)] = "DMA_WRITE",
+		[_IOC_NR(PRESTERA_IOC_DMAREAD)] = "DMA_READ",
+		[_IOC_NR(PRESTERA_IOC_GETDMASIZE)] = "GET_DMA_SIZE",
+		[_IOC_NR(PRESTERA_IOC_TWSIINITDRV)] = "TWSI_INIT_DRV",
+		[_IOC_NR(PRESTERA_IOC_TWSIWAITNOBUSY)] = "TWSI_WAIT_NO_BUSY",
+		[_IOC_NR(PRESTERA_IOC_TWSIWRITE)] = "TWSI_WRITE",
+		[_IOC_NR(PRESTERA_IOC_TWSIREAD)] = "TWSI_READ",
+		[_IOC_NR(PRESTERA_IOC_GETMAPPING)] = "GET_MAPPING",
+	};
+	#define PRESTERA_IOCTLS ARRAY_SIZE(prestera_ioctls)
+
+	switch (_IOC_DIR(cmd)) {
+	case _IOC_NONE:
+		dir = "--";
+		break;
+	case _IOC_READ:
+		dir = "r-";
+		break;
+	case _IOC_WRITE:
+		dir = "-w";
+		break;
+	case _IOC_READ | _IOC_WRITE:
+		dir = "rw";
+		break;
+	default:
+		dir = "*ERR*"; break;
+	}
+	mvOsPrintf("got ioctl '%c', dir=%s, #%d (0x%08x) ",
+		   _IOC_TYPE(cmd), dir, _IOC_NR(cmd), cmd);
+
+	if (_IOC_NR(cmd) < PRESTERA_IOCTLS)
+		mvOsPrintf("%s\n", prestera_ioctls[_IOC_NR(cmd)]);
+}
+#endif
+
+/************************************************************************
+ *
+ * prestera_ioctl: The device ioctl() implementation
+ */
+static long prestera_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	struct pp_dev			*dev = NULL;
+	struct GT_PCI_Dev_STC		gtDev;
+	struct GT_Intr2Vec		int2vec;
+	struct GT_VecotrCookie_STC	vector_cookie;
+	struct PciConfigReg_STC		pciConfReg;
+	struct GT_RANGE_STC		range;
+	struct intData			*intData;
+	int				i;
+	struct GT_DmaReadWrite_STC	dmaRWparams;
+	struct GT_TwsiReadWrite_STC	twsiRWparams;
+	unsigned long			temp_len;
+	struct GT_PCI_Mapping_STC	mapping;
+
+	if (_IOC_TYPE(cmd) == PRESTERA_SMI_IOC_MAGIC)
+		return prestera_smi_ioctl(cmd, arg);
+
+	/* don't even decode wrong cmds: better returning  ENOTTY than EFAULT */
+	if (_IOC_TYPE(cmd) != PRESTERA_IOC_MAGIC) {
+		mvOsPrintf("wrong ioctl magic key\n");
+		return -ENOTTY;
+	}
+
+#ifdef MV_DEBUG
+	if (cmd != PRESTERA_IOC_WAIT)
+		ioctl_cmd_pr(cmd);
+#endif
+
+	switch (cmd) {
+	case PRESTERA_IOC_DMAWRITE:
+		if (copy_from_user(&dmaRWparams, (struct GT_DmaReadWrite_STC *)arg, sizeof(dmaRWparams))) {
+			mvOsPrintf(KERN_ERR "copy_from_user failed\n");
+			return -EFAULT;
+		}
+		return prestera_dma_write(dmaRWparams.address,
+					  dmaRWparams.length,
+					  dmaRWparams.burstLimit,
+					  (unsigned long)dmaRWparams.buffer);
+
+	case PRESTERA_IOC_DMAREAD:
+		if (copy_from_user(&dmaRWparams, (struct GT_DmaReadWrite_STC *)arg, sizeof(dmaRWparams))) {
+			mvOsPrintf(KERN_ERR "copy_from_user failed\n");
+			return -EFAULT;
+		}
+		return prestera_dma_read(dmaRWparams.address,
+					 dmaRWparams.length,
+					 dmaRWparams.burstLimit,
+					 (unsigned long)dmaRWparams.buffer);
+
+	case PRESTERA_IOC_HWRESET:
+		mvOsPrintf("got PRESTERA_IOC_HWRESET, do nothing\n");
+		break;
+
+	case PRESTERA_IOC_INTCONNECT:
+		/* read and parse user data structure */
+		if (copy_from_user(&vector_cookie, (struct GT_VecotrCookie_STC *)arg,
+				   sizeof(struct GT_VecotrCookie_STC))) {
+			mvOsPrintf(KERN_ERR "copy_from_user failed\n");
+			return -EFAULT;
+		}
+
+		if (prestera_int_connect(vector_cookie.vector, 0,
+					 (struct intData **)&vector_cookie.cookie)) {
+			mvOsPrintf(KERN_ERR "prestera_int_connect failed\n");
+			return -EFAULT;
+		}
+
+		/* USER READS */
+		if (copy_to_user((struct GT_VecotrCookie_STC *)arg, &vector_cookie,
+				 sizeof(struct GT_VecotrCookie_STC))) {
+			mvOsPrintf(KERN_ERR "copy_to_user failed\n");
+			return -EFAULT;
+		}
+		break;
+
+	case PRESTERA_IOC_INTENABLE:
+		/* clear the mask reg on device 0x10 */
+		if (arg > 64)
+			send_sig_info(SIGSTOP, (struct siginfo *)1, current);
+		enable_irq(arg);
+		break;
+
+	case PRESTERA_IOC_INTDISABLE:
+		disable_irq(arg);
+		break;
+
+	case PRESTERA_IOC_WAIT:
+		/* cookie */
+		intData = (struct intData *)arg;
+
+		/* enable the interrupt vector */
+		enable_irq(intData->intVec);
+
+		if (down_interruptible(&intData->sem))
+			return -ERESTARTSYS;
+		break;
+
+	case PRESTERA_IOC_FIND_DEV:
+		/* read and parse user data structure */
+		if (copy_from_user(&gtDev, (struct GT_PCI_Dev_STC *) arg, sizeof(struct GT_PCI_Dev_STC))) {
+			mvOsPrintf(KERN_ERR "copy_from_user failed\n");
+			return -EFAULT;
+		}
+		for (i = 0; i < founddevs; i++) {
+			dev = ppdevs[i];
+			if ((gtDev.vendorId == dev->vendorId) &&
+			    (gtDev.devId == dev->devId)	&&
+			    (gtDev.instance == dev->instance))
+				break;
+		}
+		if (i == founddevs)
+			return -ENODEV;
+
+		/* Found */
+		gtDev.busNo = dev->busNo;
+		gtDev.devSel = dev->devSel;
+		gtDev.funcNo = dev->funcNo;
+
+		DB(mvOsPrintf("PCI_FIND_DEV: pci? %d bus# %ld devSel %ld func# %ld vendId 0x%X devId 0x%X inst %ld\n",
+			      dev->on_pci_bus, gtDev.busNo, gtDev.devSel,
+			      gtDev.funcNo, gtDev.vendorId, gtDev.devId, gtDev.instance));
+
+		/* READ */
+		if (copy_to_user((struct GT_PCI_Dev_STC *)arg, &gtDev, sizeof(struct GT_PCI_Dev_STC))) {
+			mvOsPrintf(KERN_ERR "copy_from_user failed\n");
+			return -EFAULT;
+		}
+		break;
+
+	case PRESTERA_IOC_GETMAPPING:
+		/* read and parse user data structure */
+		if (copy_from_user(&mapping, (struct GT_PCI_Mapping_STC *)arg,
+				   sizeof(struct GT_PCI_Mapping_STC))) {
+			mvOsPrintf(KERN_ERR "copy_from_user failed\n");
+			return -EFAULT;
+		}
+
+		for (i = 0; i < founddevs; i++) {
+			dev = ppdevs[i];
+			if ((mapping.vendorId == dev->vendorId) &&
+			    (mapping.devId == dev->devId) &&
+			    (mapping.busNo == dev->busNo) &&
+			    (mapping.devSel == dev->devSel) &&
+			    (mapping.funcNo == dev->funcNo))
+				break;
+		}
+		if (i == founddevs)
+			return -ENODEV;
+
+		/* Found */
+		mapping.mapConfig.addr = dev->config.mmapbase;
+		mapping.mapConfig.length = (size_t)(dev->config.size);
+		mapping.mapConfig.offset = (size_t)(dev->config.mmapoffset);
+		mapping.mapRegs.addr = dev->ppregs.mmapbase;
+		mapping.mapRegs.length = (size_t)(dev->ppregs.size);
+		mapping.mapRegs.offset = (size_t)(dev->ppregs.mmapoffset);
+
+		if (copy_to_user((struct GT_PCI_Mapping_STC *)arg, &mapping, sizeof(struct GT_PCI_Mapping_STC))) {
+			mvOsPrintf(KERN_ERR "copy_to_user failed\n");
+			return -EFAULT;
+		}
+		break;
+
+	case PRESTERA_IOC_PCICONFIGWRITEREG:
+		/* read and parse user data structure */
+		if (copy_from_user(&pciConfReg, (struct PciConfigReg_STC *)arg, sizeof(struct PciConfigReg_STC))) {
+			mvOsPrintf(KERN_ERR "copy_from_user failed\n");
+			return -EFAULT;
+		}
+
+		for (i = 0; i < founddevs; i++) {
+			dev = ppdevs[i];
+			if ((pciConfReg.busNo == dev->busNo) &&
+			    (pciConfReg.devSel == dev->devSel) &&
+			    (pciConfReg.funcNo == dev->funcNo))
+				break;
+		}
+		if (i == founddevs)
+			return -ENODEV;
+
+		DB(mvOsPrintf("PCI_CONFIG_WRITE_REG: is_pci %d busNo %ld devSel %ld funcNo %ld regAddr %ld data %ld\n",
+			      dev->on_pci_bus, pciConfReg.busNo, pciConfReg.devSel,
+			      pciConfReg.funcNo, pciConfReg.regAddr, pciConfReg.data));
+
+		if (dev->on_pci_bus) {
+			if (bspPciConfigWriteReg(pciConfReg.busNo, pciConfReg.devSel,
+						  pciConfReg.funcNo, pciConfReg.regAddr,
+						  pciConfReg.data) != MV_OK) {
+				mvOsPrintf(KERN_ERR "bspPciConfigWriteReg failed\n");
+				return -EFAULT;
+			}
+		}
+		break;
+
+	case PRESTERA_IOC_PCICONFIGREADREG:
+		/* read and parse user data structure */
+		if (copy_from_user(&pciConfReg, (struct PciConfigReg_STC *) arg, sizeof(struct PciConfigReg_STC))) {
+			mvOsPrintf(KERN_ERR "copy_from_user failed\n");
+			return -EFAULT;
+		}
+
+		for (i = 0; i < founddevs; i++) {
+			dev = ppdevs[i];
+			if ((pciConfReg.busNo == dev->busNo) &&
+			    (pciConfReg.devSel == dev->devSel) &&
+			    (pciConfReg.funcNo == dev->funcNo))
+				break;
+		}
+
+		if (i == founddevs)
+			return -ENODEV;
+
+		pciConfReg.data = 0;
+
+		if (dev->on_pci_bus) {
+			if (bspPciConfigReadReg(pciConfReg.busNo,
+					     pciConfReg.devSel,
+					     pciConfReg.funcNo,
+					     pciConfReg.regAddr,
+					     &(pciConfReg.data)) != MV_OK) {
+				mvOsPrintf(KERN_ERR "bspPciConfigReadReg failed\n");
+				return -EFAULT;
+			}
+		}
+
+		DB(mvOsPrintf("PCI_CONFIG_READ_REG: is_pci %d busNo %ld devSel %ld funcNo %ld regAddr %ld data %ld\n",
+			      dev->on_pci_bus, pciConfReg.busNo, pciConfReg.devSel,
+			      pciConfReg.funcNo, pciConfReg.regAddr, pciConfReg.data));
+
+		if (copy_to_user((struct PciConfigReg_STC *)arg, &pciConfReg, sizeof(struct PciConfigReg_STC))) {
+			mvOsPrintf(KERN_ERR "copy_to_user failed\n");
+			return -EFAULT;
+		}
+
+		break;
+
+	case PRESTERA_IOC_GETINTVEC:
+		if (copy_from_user(&int2vec, (struct GT_Intr2Vec *)arg, sizeof(struct GT_Intr2Vec))) {
+			mvOsPrintf(KERN_ERR "copy_from_user failed\n");
+			return -EFAULT;
+		}
+
+		if (MV_OK != bspPciGetIntVec(int2vec.intrLine, (void *)&int2vec.vector)) {
+			mvOsPrintf(KERN_ERR "bspPciGetIntVec failed\n");
+			return -EFAULT;
+		}
+
+		if (copy_to_user((struct GT_Intr2Vec *)arg, &int2vec, sizeof(struct GT_Intr2Vec))) {
+			mvOsPrintf(KERN_ERR "copy_to_user failed\n");
+			return -EFAULT;
+		}
+		break;
+
+	case PRESTERA_IOC_FLUSH:
+		/* read and parse user data structure */
+		if (copy_from_user(&range, (struct GT_RANGE_STC *)arg, sizeof(struct GT_RANGE_STC))) {
+			mvOsPrintf(KERN_ERR "copy_from_user failed\n");
+			return -EFAULT;
+		}
+		pci_map_single(NULL, (void *)range.address, range.length, PCI_DMA_TODEVICE);
+		break;
+
+	case PRESTERA_IOC_INVALIDATE:
+		/* read and parse user data structure */
+		if (copy_from_user(&range, (struct GT_RANGE_STC *)arg, sizeof(struct GT_RANGE_STC))) {
+			mvOsPrintf(KERN_ERR "copy_from_user failed\n");
+			return -EFAULT;
+		}
+		pci_map_single(NULL, (void *)range.address, range.length, PCI_DMA_FROMDEVICE);
+		break;
+
+	case PRESTERA_IOC_GETBASEADDR:
+		if (copy_to_user((void *)arg, &dma_base, sizeof(long))) {
+			mvOsPrintf(KERN_ERR "copy_to_user failed\n");
+			return -EFAULT;
+		}
+		break;
+
+	case PRESTERA_IOC_GETDMASIZE:
+		temp_len = dma_len;
+
+		if (copy_to_user((void *)arg, &temp_len, sizeof(unsigned long))) {
+			mvOsPrintf(KERN_ERR "copy_to_user failed\n");
+			return -EFAULT;
+		}
+		break;
+
+	case PRESTERA_IOC_TWSIINITDRV:
+		if (bspTwsiInitDriver() != MV_OK) {
+			mvOsPrintf(KERN_ERR "bspTwsiInitDriver failed\n");
+			return -EFAULT;
+		}
+		break;
+
+	case PRESTERA_IOC_TWSIWAITNOBUSY:
+		if (bspTwsiWaitNotBusy() != MV_OK) {
+			mvOsPrintf(KERN_ERR "bspTwsiWaitNotBusy failed\n");
+			return -EFAULT;
+		}
+		break;
+
+	case PRESTERA_IOC_TWSIWRITE:
+		/* read and parse user data structure */
+		if (copy_from_user(&twsiRWparams, (struct GT_TwsiReadWrite_STC *)arg,
+				   sizeof(struct GT_TwsiReadWrite_STC))) {
+			mvOsPrintf(KERN_ERR "copy_from_user failed\n");
+			return -EFAULT;
+		}
+		if (bspTwsiMasterWriteTrans(twsiRWparams.devId, twsiRWparams.pData,
+					     twsiRWparams.len, twsiRWparams.stop) != MV_OK) {
+			mvOsPrintf(KERN_ERR "bspTwsiMasterWriteTrans failed\n");
+			return -EFAULT;
+		}
+
+		break;
+
+	case PRESTERA_IOC_TWSIREAD:
+		/* read and parse user data structure */
+		if (copy_from_user(&twsiRWparams, (struct GT_TwsiReadWrite_STC *)arg,
+				   sizeof(struct GT_TwsiReadWrite_STC))) {
+			mvOsPrintf(KERN_ERR "copy_from_user failed\n");
+			return -EFAULT;
+		}
+		if (bspTwsiMasterReadTrans(twsiRWparams.devId, twsiRWparams.pData,
+					    twsiRWparams.len, twsiRWparams.stop) != MV_OK) {
+			mvOsPrintf(KERN_ERR "bspTwsiMasterReadTrans failed\n");
+			return -EFAULT;
+		}
+		if (copy_to_user((struct GT_TwsiReadWrite_STC *)arg, &twsiRWparams,
+				 sizeof(struct GT_TwsiReadWrite_STC))) {
+			mvOsPrintf(KERN_ERR "copy_to_user failed\n");
+			return -EFAULT;
+		}
+
+		break;
+
+	default:
+		mvOsPrintf(KERN_WARNING "Unknown ioctl (%d)\n", _IOC_NR(cmd));
+		return -EFAULT;
+	}
+	return 0;
+}
+
+/*
+ * open and close: just keep track of how many times the device is
+ * mapped, to avoid releasing it.
+ */
+
+void prestera_vma_open(struct vm_area_struct *vma)
+{
+	dev_open_nr++;
+}
+
+void prestera_vma_close(struct vm_area_struct *vma)
+{
+	dev_open_nr--;
+}
+
+struct vm_operations_struct prestera_vm_ops = {
+	.open	= prestera_vma_open,
+	.close	= prestera_vma_close,
+};
+
+
+
+/************************************************************************
+ *
+ * prestera_mmap: The device mmap() implementation
+ */
+static int prestera_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	unsigned long	phys;
+	unsigned long	ppNum;
+	unsigned long	offset;
+	unsigned long	pageSize;
+	int		rc;
+	struct pp_dev	*ppdev;
+
+	if (((vma->vm_pgoff) << PAGE_SHIFT) & (PAGE_SIZE - 1)) {
+		/* need aligned offsets */
+		mvOsPrintf("prestera_mmap offset not aligned\n");
+		return -ENXIO;
+	}
+
+	/* bind the prestera_vm_ops */
+	vma->vm_ops = &prestera_vm_ops;
+
+	/* VM_IO for I/O memory */
+	vma->vm_flags |= VM_IO;
+
+	/* disable caching on mapped memory */
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+	vma->vm_private_data = prestera_dev;
+
+	switch (vma->vm_start & CPSS_VIRT_ADDR_MASK) {
+	case CPSS_DMA_VIRT_ADDR:
+		if (vma->vm_start < CPSS_CPU_VIRT_ADDR) {
+			/* DMA memory */
+			phys = dma_base;
+			pageSize = dma_len;
+
+			break;
+		} else {
+			/* CPU registers */
+			offset = vma->vm_start - (vma->vm_pgoff << PAGE_SHIFT);
+			ppdev = NULL;
+
+			for (ppNum = 0; ppNum < founddevs; ppNum++) {
+				ppdev = ppdevs[ppNum];
+				if (ppdev->config.mmapbase == offset)
+					break;
+			}
+			if (ppNum >= founddevs)
+				return 1;
+
+			phys = ppdev->config.phys;
+			pageSize = ppdev->config.size;
+
+			if (pageSize > vma->vm_end - vma->vm_start)
+				pageSize = vma->vm_end - vma->vm_start;
+
+			break;
+		}
+
+	case CPSS_SWITCH_VIRT_ADDR:
+		/* switch regs */
+		ppdev = NULL;
+		for (ppNum = 0; ppNum < founddevs; ppNum++) {
+			ppdev = ppdevs[ppNum];
+			if (ppdev->ppregs.mmapbase == (unsigned long)(vma->vm_start))
+				break;
+		}
+		if (ppNum >= founddevs)
+			return 1;
+
+		phys = ppdev->ppregs.phys;
+		pageSize = ppdev->ppregs.size;
+
+		break;
+
+	default:
+		/* ??? */
+		mvOsPrintf("unknown range (0%0x)\n", (int)vma->vm_start);
+		return 1;
+	}
+
+
+	DB(mvOsPrintf("%s: remap_pfn_range(0x%lx, 0x%lx, 0x%lx, 0x%lx)\n",
+		      __func__, (unsigned long)(vma->vm_start),
+		      (unsigned long)(phys >> PAGE_SHIFT),
+		      (unsigned long)pageSize,
+		      (unsigned long)vma->vm_page_prot));
+
+	rc = remap_pfn_range(vma,
+			vma->vm_start,
+			phys >> PAGE_SHIFT,
+			pageSize,
+			vma->vm_page_prot);
+	if (rc) {
+		mvOsPrintf("remap_pfn_range(0x%lx) failed (rc=%d)\n", vma->vm_start, rc);
+		return 1;
+	}
+
+	prestera_vma_open(vma);
+
+	return 0;
+}
+
+/************************************************************************
+ *
+ * prestera_open: The device open() implementation
+ */
+static int prestera_open(struct inode *inode, struct file *filp)
+{
+	if (down_interruptible(&prestera_dev->sem))
+		return -ERESTARTSYS;
+
+	if (!dev_init_done) {
+		up(&prestera_dev->sem);
+		return -EIO;
+	}
+
+#ifndef SHARED_MEMORY
+	/* Avoid single-usage restriction for shared memory:
+	 * device should be accessible for multiple clients. */
+	if (dev_open_nr) {
+		up(&prestera_dev->sem);
+		return -EBUSY;
+	}
+#endif
+
+	filp->private_data = prestera_dev;
+
+	dev_open_nr++;
+	up(&prestera_dev->sem);
+
+	mvOsPrintf(KERN_INFO "%s opened\n", prestera_dev_name);
+
+	return 0;
+}
+
+/************************************************************************
+ *
+ * prestera_release: The device close() implementation
+ */
+static int prestera_release(struct inode *inode, struct file *file)
+{
+	dev_open_nr--;
+
+	if (dev_open_nr == 0)
+		prestera_int_cleanup();
+
+	mvOsPrintf(KERN_DEBUG "%s released\n", prestera_dev_name);
+
+	return 0;
+}
+
+/************************************************************************
+ *
+ * proc read data rooutine
+ */
+int prestera_read_proc_mem(char		*page,
+			   char		**start,
+			   off_t	offset,
+			   int		count,
+			   int		*eof,
+			   void		*data)
+{
+	int		len;
+	struct pp_dev	*ppdev;
+	unsigned long	address;
+	unsigned int	value;
+	unsigned long	*ptr;
+	int		i, j;
+
+	len = 0;
+
+	len += sprintf(page + len, "%s major # %d\n", prestera_dev_name, prestera_major);
+	len += sprintf(page + len, "short_bh_count %d\n", prestera_int_bh_cnt_get());
+	len += sprintf(page + len, "rx_DSR %d\n", prestera_smi_eth_port_rx_dsr_cnt());
+	len += sprintf(page + len, "tx_DSR %d\n", prestera_smi_eth_port_tx_dsr_cnt());
+
+	len += sprintf(page + len, "DMA area: 0x%lx(virt) ,base: 0x%lx(phys), len: 0x%x\n",
+		       (unsigned long)dma_area, dma_base, dma_len);
+
+	for (i = 0; i < founddevs; i++) {
+		ppdev = ppdevs[i];
+
+		len += sprintf(page + len, "Device %d\n", i);
+		len += sprintf(page + len, "\tbus(0x%0lx) slot(0x%0lx) func(0x%0lx)\n",
+			       (unsigned long)ppdev->busNo,
+			       (unsigned long)ppdev->devSel,
+			       (unsigned long)ppdev->funcNo);
+		len += sprintf(page + len, "\tvendor_id(0x%0x) device_id(0x%0x)\n", ppdev->vendorId, ppdev->devId);
+
+		len += sprintf(page + len, "CPU regs: 0x%lx(user virt) ,base: 0x%lx(kernel virt), len: 0x%lx\n",
+			  ppdev->config.mmapbase, ppdev->config.base, ppdev->config.size);
+
+		address = ppdev->config.base;
+		for (j = 0; j < 0x14; j += 4) {
+			ptr = (unsigned long *)address;
+			value = readl((void *)ptr);
+
+			len += sprintf(page + len, "\t\toff(0x%0x) add(%p) val(0x%0x)\n", j, ptr, le32_to_cpu(value));
+			address += 4;
+		}
+		/* Mask */
+		address = ppdev->config.base + 0x118;
+		ptr = (unsigned long *)address;
+		value = readl((void *)ptr);
+		len += sprintf(page + len, "\tMASK(0x%0x) add(%p) val(0x%0x)\n", 0x118, ptr, le32_to_cpu(value));
+
+		/* Cause */
+		address = ppdev->config.base + 0x114;
+		ptr = (unsigned long *)address;
+		value = readl((void *)ptr);
+		len += sprintf(page + len, "\tMASK(0x%0x) add(%p) val(0x%0x)\n", 0x114, ptr, le32_to_cpu(value));
+
+		len += sprintf(page + len, "PP regs: 0x%lx(user virt) ,base: 0x%lx(kernel virt), len: 0x%lx\n",
+			       ppdev->ppregs.mmapbase, ppdev->ppregs.base, ppdev->ppregs.size);
+
+		address = ppdev->ppregs.base;
+		ptr = (unsigned long *)(address + 0x0);
+		value = readl((void *)ptr);
+		len += sprintf(page + len, "\t\toff(0x%0x) val(0x%0x)\n", 0x0, le32_to_cpu(value));
+
+		ptr = (unsigned long *)(address + 0x50);
+		value = readl((void *)ptr);
+		len += sprintf(page + len, "\t\toff(0x%0x) val(0x%0x)\n", 0x50, le32_to_cpu(value));
+
+		ptr = (unsigned long *)(address + 0x1000000);
+		value = readl((void *)ptr);
+		len += sprintf(page + len, "\t\toff(0x%0x) val(0x%0x)\n", 0x1000000, le32_to_cpu(value));
+
+		ptr = (unsigned long *)(address + 0x2000000);
+		value = readl((void *)ptr);
+		len += sprintf(page + len, "\t\toff(0x%0x) val(0x%0x)\n", 0x2000000, le32_to_cpu(value));
+
+		ptr = (unsigned long *)(address + 0x3000000);
+		value = readl((void *)ptr);
+		len += sprintf(page + len, "\t\toff(0x%0x) val(0x%0x)\n", 0x3000000, le32_to_cpu(value));
+	}
+
+	*eof = 1;
+
+	return len;
+}
+
+static int ppdev_conf_set(void)
+{
+	struct pp_dev	*ppdev;
+	unsigned long	start;
+	unsigned long	len;
+
+	ppdev = kmalloc(sizeof(struct pp_dev), GFP_KERNEL);
+	if (NULL == ppdev) {
+		mvOsPrintf("kmalloc failed\n");
+		return -ENOMEM;
+	}
+
+	ppdev->devId = mvCtrlModelGet();
+	ppdev->vendorId = MARVELL_VEN_ID;
+	ppdev->instance = 0;
+	ppdev->busNo = 0;
+	ppdev->devSel = 0;
+	ppdev->funcNo = 0;
+	ppdev->on_pci_bus = 0;
+
+	/* configure the SWITCH register address space */
+	/* additional 1MB is reserved for DFX registers */
+	start = SWITCH_REGS_PHYS_BASE;
+	len = SWITCH_REGS_SIZE + _1M;
+
+	ppdev->ppregs.allocbase = start;
+	ppdev->ppregs.allocsize = len;
+	ppdev->ppregs.size = len;
+	ppdev->ppregs.phys = start;
+	ppdev->ppregs.base = (uintptr_t)(SWITCH_REGS_VIRT_BASE);
+	ppdev->ppregs.mmapbase = (uintptr_t)(CPSS_SWITCH_VIRT_ADDR);
+	ppdev->ppregs.mmapoffset = 0;
+
+	/* save phys address */
+	pci_phys_addr[pci_phys_blocks++] = start;
+
+	/* configure the CPU register address space */
+	start = INTER_REGS_PHYS_BASE;
+	len = _1M;
+
+	ppdev->config.allocbase = start;
+	ppdev->config.allocsize = len;
+	ppdev->config.size = len;
+	ppdev->config.phys = start;
+	ppdev->config.mmapbase = (uintptr_t)(CPSS_CPU_VIRT_ADDR);
+	ppdev->config.mmapoffset = 0;
+	ppdev->config.base = (uintptr_t)(INTER_REGS_VIRT_BASE);
+
+	ppdevs[founddevs++] = ppdev;
+
+	return 0;
+}
+
+static const struct file_operations prestera_fops = {
+	.llseek			= prestera_lseek,
+	.read			= prestera_smi_read,
+	.write			= prestera_smi_write,
+	.unlocked_ioctl		= prestera_ioctl,
+	.mmap			= prestera_mmap,
+	.open			= prestera_open,
+	.release		= prestera_release
+};
+
+#ifdef PRESTERA_SYSCALLS
+/************************************************************************
+*
+* syscall entries for fast calls
+*
+************************************************************************/
+/* fast call to prestera_ioctl() */
+asmlinkage long sys_prestera_ctl(unsigned int cmd, unsigned long arg)
+{
+	return prestera_ioctl(NULL, cmd, arg);
+}
+
+#define OWN_SYSCALLS 1
+
+#ifdef __NR_SYSCALL_BASE
+#  define __SYSCALL_TABLE_INDEX(name) (__NR_ ## name - __NR_SYSCALL_BASE)
+#else
+#  define __SYSCALL_TABLE_INDEX(name) (__NR_ ## name)
+#endif
+
+#define __TBL_ENTRY(name) { __SYSCALL_TABLE_INDEX(name), (long)sys_ ## name, 0 }
+static struct {
+	int entry_number;
+	long own_entry;
+	long saved_entry;
+} prestera_syscall[OWN_SYSCALLS] = {
+	__TBL_ENTRY(prestera_ctl)
+};
+#undef  __TBL_ENTRY
+
+/*******************************************************************************
+* prestera_syscall_init
+*
+* DESCRIPTION:
+*       None
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+static int prestera_syscall_init(void)
+{
+	int	k;
+	long	*syscall_tbl;
+
+	syscall_tbl = (long *)kallsyms_lookup_name("sys_call_table");
+
+	if (syscall_tbl == NULL) {
+		mvOsPrintf(KERN_ALERT "%s failed to get address of sys_call_table\n", __func__);
+		return -EFAULT;
+	}
+
+	for (k = 0; k < OWN_SYSCALLS; k++) {
+		prestera_syscall[k].saved_entry = syscall_tbl[prestera_syscall[k].entry_number];
+		syscall_tbl[prestera_syscall[k].entry_number] = prestera_syscall[k].own_entry;
+	}
+	return 0;
+}
+
+/*******************************************************************************
+* prestera_RestoreSyscalls
+*
+* DESCRIPTION:
+*       Restore original syscall entries.
+*
+* INPUTS:
+*       None
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       None
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+static int prestera_syscall_restore(void)
+{
+	int	k;
+	long	*syscall_tbl;
+
+	syscall_tbl = (long *)kallsyms_lookup_name("sys_call_table");
+
+	if (syscall_tbl == NULL) {
+		mvOsPrintf(KERN_ALERT "%s failed to get address of sys_call_table\n", __func__);
+		return -EFAULT;
+	}
+
+	for (k = 0; k < OWN_SYSCALLS; k++) {
+		if (prestera_syscall[k].saved_entry)
+			syscall_tbl[prestera_syscall[k].entry_number] = prestera_syscall[k].saved_entry;
+	}
+	return 0;
+}
+
+#endif /* PRESTERA_SYSCALLS */
+
+
+
+static int prestera_dma_init(void)
+{
+	dma_len  = _2M;
+	dma_area = (void *)bspCacheDmaMalloc(dma_len);
+	dma_base = bspVirt2Phys((unsigned long)((uintptr_t)dma_area));
+
+	DB(mvOsPrintf("DMA - dma_area: %p(v) ,dma_base: 0x%lx(p), dma_len: 0x%x\n",
+		      dma_area, dma_base, dma_len));
+
+	/* allocate temp area for bspDma operations */
+	dma_tmp_virt = dma_alloc_coherent(NULL, PAGE_SIZE, &dma_tmp_phys,
+					  GFP_DMA | GFP_KERNEL);
+	if (!dma_tmp_virt) {
+		mvOsPrintf(KERN_ERR "dma_alloc_coherent() failed\n");
+		return -ENOMEM;
+	}
+
+	/* open internal switch window for DMA */
+	writel(dma_base | PP_BA_ATTR,	SWITCH_REGS_VIRT_BASE | PP_WIN_BA(0));
+	writel(PP_UDID_DATTR,		SWITCH_REGS_VIRT_BASE | PP_UDID);
+	writel(PP_WIN_SIZE_VAL,		SWITCH_REGS_VIRT_BASE | PP_WIN_SR(0));
+	writel(PP_WIN_CTRL_AP,		SWITCH_REGS_VIRT_BASE | PP_WIN_CTRL(0));
+
+	return 0;
+}
+
+
+
+/************************************************************************
+ *
+ * prestera_cleanup:
+ */
+static void prestera_cleanup(void)
+{
+	int		i;
+	struct pp_dev	*ppdev;
+
+	dev_init_done = 0;
+
+	prestera_int_cleanup();
+
+	for (i = 0; i < founddevs; i++) {
+		ppdev = ppdevs[i];
+
+		/* Unmap the memory regions */
+		iounmap((void *)ppdev->config.base);
+		iounmap((void *)ppdev->ppregs.base);
+
+		/* relaese BAR0 */
+		release_mem_region(ppdev->config.allocbase, ppdev->config.allocsize);
+		/* relaese BAR1 */
+		release_mem_region(ppdev->ppregs.allocbase, ppdev->ppregs.allocsize);
+
+		kfree(ppdev);
+	}
+	founddevs = 0;
+
+	if (dma_tmp_virt) {
+		dma_free_coherent(NULL, PAGE_SIZE, dma_tmp_virt, dma_tmp_phys);
+		dma_tmp_virt = NULL;
+	}
+
+	bspCacheDmaFree(dma_area);
+
+#ifdef PRESTERA_SYSCALLS
+	prestera_syscall_restore();
+#endif
+	remove_proc_entry(prestera_dev_name, NULL);
+
+	cdev_del(&prestera_cdev);
+
+	unregister_chrdev_region(MKDEV(prestera_major, 0), 1);
+}
+
+/************************************************************************
+ *
+ * prestera_init:
+ */
+static int prestera_init(void)
+{
+	int rc = 0;
+
+	/* init static vars */
+	dev_open_nr = 0;
+	pci_phys_blocks = 0;
+	founddevs = 0;
+	dma_tmp_virt = NULL;
+	dma_base = 0;
+	dma_len = 0;
+	dma_area = NULL;
+
+	/* first thing register the device at OS */
+
+	/* Register your major. */
+	rc = register_chrdev_region(MKDEV(prestera_major, 0), 1, prestera_dev_name);
+	if (rc < 0) {
+		mvOsPrintf(KERN_ERR "%s: register_chrdev_region err= %d\n", __func__, rc);
+		return rc;
+	}
+
+	cdev_init(&prestera_cdev, &prestera_fops);
+
+	prestera_cdev.owner = THIS_MODULE;
+
+	rc = cdev_add(&prestera_cdev, MKDEV(prestera_major, 0), 1);
+	if (rc) {
+		unregister_chrdev_region(MKDEV(prestera_major, 0), 1);
+		mvOsPrintf(KERN_ERR "%s: cdev_add err= %d\n", __func__, rc);
+		return rc;
+	}
+
+	prestera_dev = kmalloc(sizeof(struct prestera_device), GFP_KERNEL);
+	if (!prestera_dev) {
+		mvOsPrintf(KERN_ERR "prestera_dev: Failed allocating memory for device\n");
+		rc = -ENOMEM;
+		goto fail;
+	}
+
+#ifdef PRESTERA_SYSCALLS
+	rc = prestera_syscall_init();
+	if (0 != rc)
+		goto fail;
+#endif
+
+	/* create /proc entry */
+	create_proc_read_entry(prestera_dev_name, 0, NULL, prestera_read_proc_mem, NULL);
+
+	/* initialize the device main semaphore */
+	sema_init(&prestera_dev->sem, 1);
+
+	prestera_int_init();
+
+	memset(pci_phys_addr, 0, sizeof(pci_phys_addr));
+
+	/* configure ppdev structure */
+	rc = ppdev_conf_set();
+	if (0 != rc)
+		goto fail;
+
+	rc = prestera_smi_init();
+	if (0 != rc)
+		goto fail;
+
+	rc = prestera_dma_init();
+	if (0 != rc)
+		goto fail;
+
+	dev_init_done = 1;
+
+	mvOsPrintf(KERN_INFO "%s driver initialized\n", prestera_dev_name);
+
+	return 0;
+
+fail:
+	prestera_cleanup();
+
+	mvOsPrintf(KERN_ERR "%s driver init failed, rc=%d\n", prestera_dev_name, rc);
+
+	return rc;
+}
+
+module_param(prestera_major, int, S_IRUGO);
+MODULE_AUTHOR("Ofer <oferh@marvell.com>");
+MODULE_DESCRIPTION("device driver for Marvell Prestera family switches");
+MODULE_LICENSE("GPL");
+module_init(prestera_init);
+module_exit(prestera_cleanup);
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera.h
new file mode 100644
index 0000000..0d16b86
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera.h
@@ -0,0 +1,138 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+********************************************************************************
+   Marvell Commercial License Option
+
+   If you received this File from Marvell and you have entered into a commercial
+   license agreement (a "Commercial License") with Marvell, the File is licensed
+   to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+********************************************************************************
+   Marvell BSD License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File under the following licensing terms.
+   Redistribution and use in source and binary forms, with or without modification,
+   are permitted provided that the following conditions are met:
+
+*   Redistributions of source code must retain the above copyright notice,
+    this list of conditions and the following disclaimer.
+
+*   Redistributions in binary form must reproduce the above copyright
+    notice, this list of conditions and the following disclaimer in the
+    documentation and/or other materials provided with the distribution.
+
+*   Neither the name of Marvell nor the names of its contributors may be
+    used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+   ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+   ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+********************************************************************************
+* mv_prestera.h
+*
+* DESCRIPTION:
+*       Includes defines and structures needed by the PP device driver
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+#ifndef __MV_PRESTERA
+#define __MV_PRESTERA
+
+#include <linux/version.h>
+#include "mv_prestera_glob.h"
+
+#ifdef __BIG_ENDIAN
+#define CPU_BE
+#else
+#define CPU_LE
+#endif
+
+#ifndef PRESTERA_MAJOR
+#define PRESTERA_MAJOR		254   /* major number */
+#endif
+
+
+/* Switch registers & reg values */
+#define PP_UDID				(0x00000204)		/* Unit default ID reg	*/
+#define PP_WIN_BA(n)			(0x0000020c + (8*n))	/* base address reg	*/
+#define PP_WIN_SR(n)			(0x00000210 + (8*n))	/* base window size reg	*/
+#define PP_WIN_CTRL(n)			(0x00000254 + (4*n))	/* window control reg	*/
+
+#define PP_ATTR				0x10
+#define PP_UDID_DATTR			(PP_ATTR << 4)
+#define PP_BA_ATTR			(PP_ATTR << 8)
+#define PP_WIN_MAX_SIZE			0xFFFF
+#define PP_WIN_SIZE_OFF			16
+#define PP_WIN_SIZE_VAL			(PP_WIN_MAX_SIZE << PP_WIN_SIZE_OFF)
+#define PP_WIN_CTRL_RW			0x3
+#define PP_WIN_CTRL_AP			(PP_WIN_CTRL_RW << 2)
+
+/* CPSS configurations */
+#define CPSS_DMA_VIRT_ADDR		0x50000000
+#define CPSS_SWITCH_VIRT_ADDR		0x60000000
+#define CPSS_CPU_VIRT_ADDR		0x58000000
+#define CPSS_VIRT_ADDR_MASK		0xf0000000
+
+struct prestera_device {
+	struct semaphore sem;                   /* Mutual exclusion semaphore   */
+	loff_t size;                            /* prestera mem size            */
+};
+
+struct mem_region {
+	unsigned long	phys;
+	unsigned long	allocbase;
+	unsigned long	size;
+	unsigned long	allocsize;
+	uintptr_t	base;
+	uintptr_t	mmapbase;
+	size_t		mmapoffset;
+};
+
+struct pp_dev {
+	unsigned short		devId;
+	unsigned short		vendorId;
+	unsigned short		on_pci_bus;
+	unsigned long		instance;
+	unsigned long		busNo;
+	unsigned long		devSel;
+	unsigned long		funcNo;
+	struct mem_region	config;       /* Configuration space */
+	struct mem_region	ppregs;       /* PP registers space */
+};
+
+
+#endif /* __MV_PRESTERA */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_glob.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_glob.h
new file mode 100644
index 0000000..87f7467
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_glob.h
@@ -0,0 +1,200 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+********************************************************************************
+   Marvell Commercial License Option
+
+   If you received this File from Marvell and you have entered into a commercial
+   license agreement (a "Commercial License") with Marvell, the File is licensed
+   to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+********************************************************************************
+   Marvell BSD License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File under the following licensing terms.
+   Redistribution and use in source and binary forms, with or without modification,
+   are permitted provided that the following conditions are met:
+
+*   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+*   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+*   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+   ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+   ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+********************************************************************************
+* mv_prestera_glob.h
+*
+* DESCRIPTION:
+*       This file includes the declaration of the struct we want to send to kernel mode,
+*       from user mode.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+#ifndef __MV_PRESTERA_GLOB
+#define __MV_PRESTERA_GLOB
+
+#define PRESTERA_SYSCALLS
+
+#ifndef __KERNEL__
+#include <sys/ioctl.h>
+/* uint32_t uintptr_t and so on */
+#include <inttypes.h>
+#include <stddef.h>
+#ifdef PRESTERA_SYSCALLS
+#include <linux/unistd.h>
+#endif
+#else /* !defined(__KERNEL__) */
+      /* uint32_t uintptr_t and so on */
+#include <linux/version.h>
+#include <linux/types.h>
+#endif /* !defined(__KERNEL__) */
+
+struct PciConfigReg_STC {
+	unsigned long busNo;
+	unsigned long devSel;
+	unsigned long funcNo;
+	unsigned long regAddr;
+	unsigned long data;
+};
+
+struct GT_PCI_Dev_STC {
+	unsigned short vendorId;
+	unsigned short devId;
+	unsigned long instance;
+	unsigned long busNo;
+	unsigned long devSel;
+	unsigned long funcNo;
+};
+
+struct GT_PCI_Mapping_STC {
+	unsigned long busNo;
+	unsigned long devSel;
+	unsigned long funcNo;
+	unsigned short vendorId;
+	unsigned short devId;
+	struct {
+		uintptr_t addr;
+		size_t length;
+		size_t offset;
+	} mapConfig, mapRegs;
+};
+
+/*TD*/
+struct GT_Intr2Vec {
+	unsigned long intrLine;
+	unsigned long bus;
+	unsigned long device;
+	unsigned long vector;
+};
+
+/*TD*/
+struct GT_VecotrCookie_STC {
+	unsigned long vector;
+	unsigned long cookie;
+};
+
+struct GT_RANGE_STC {
+	uintptr_t address;
+	size_t length;
+};
+
+struct GT_DmaReadWrite_STC {
+	unsigned long address;
+	unsigned long length;
+	unsigned long burstLimit;
+	void *buffer;
+};
+
+struct GT_TwsiReadWrite_STC {
+	unsigned char	devId;	/* I2c slave ID                              */
+	unsigned char	*pData;	/* Pointer to array of chars (address / data)*/
+	unsigned char	len;	/* pData array size (in chars).              */
+	unsigned char	stop;	/* Indicates if stop bit is needed in the end  */
+};
+
+
+#define PRESTERA_IOC_MAGIC 'p'
+#define PRESTERA_IOC_HWRESET		_IO(PRESTERA_IOC_MAGIC,		0)
+#define PRESTERA_IOC_INTCONNECT		_IOWR(PRESTERA_IOC_MAGIC,	3,	struct GT_VecotrCookie_STC)
+#define PRESTERA_IOC_INTENABLE		_IOW(PRESTERA_IOC_MAGIC,	4,	long)
+#define PRESTERA_IOC_INTDISABLE		_IOW(PRESTERA_IOC_MAGIC,	5,	long)
+#define PRESTERA_IOC_WAIT		_IOW(PRESTERA_IOC_MAGIC,	6,	long)
+#define PRESTERA_IOC_FIND_DEV		_IOWR(PRESTERA_IOC_MAGIC,	7,	struct GT_PCI_Dev_STC)
+#define PRESTERA_IOC_PCICONFIGWRITEREG	_IOW(PRESTERA_IOC_MAGIC,	8,	struct PciConfigReg_STC)
+#define PRESTERA_IOC_PCICONFIGREADREG	_IOWR(PRESTERA_IOC_MAGIC,	9,	struct PciConfigReg_STC)
+#define PRESTERA_IOC_GETINTVEC		_IOWR(PRESTERA_IOC_MAGIC,	10,	struct GT_Intr2Vec)
+#define PRESTERA_IOC_FLUSH		_IOW(PRESTERA_IOC_MAGIC,	11,	struct GT_RANGE_STC)
+#define PRESTERA_IOC_INVALIDATE		_IOW(PRESTERA_IOC_MAGIC,	12,	struct GT_RANGE_STC)
+#define PRESTERA_IOC_GETBASEADDR	_IOR(PRESTERA_IOC_MAGIC,	13,	long*)
+#define PRESTERA_IOC_DMAWRITE		_IOW(PRESTERA_IOC_MAGIC,	14,	struct GT_DmaReadWrite_STC)
+#define PRESTERA_IOC_DMAREAD		_IOW(PRESTERA_IOC_MAGIC,	15,	struct GT_DmaReadWrite_STC)
+#define PRESTERA_IOC_GETDMASIZE		_IOR(PRESTERA_IOC_MAGIC,	16,	long*)
+#define PRESTERA_IOC_TWSIINITDRV	_IO(PRESTERA_IOC_MAGIC,		17)
+#define PRESTERA_IOC_TWSIWAITNOBUSY	_IO(PRESTERA_IOC_MAGIC,		18)
+#define PRESTERA_IOC_TWSIWRITE		_IOW(PRESTERA_IOC_MAGIC,	19,	struct GT_TwsiReadWrite_STC)
+#define PRESTERA_IOC_TWSIREAD		_IOWR(PRESTERA_IOC_MAGIC,	20,	struct GT_TwsiReadWrite_STC)
+#define PRESTERA_IOC_GETMAPPING		_IOWR(PRESTERA_IOC_MAGIC,	29,	struct GT_PCI_Mapping_STC)
+
+#ifdef PRESTERA_SYSCALLS
+/********************************************************
+*
+* Syscall numbers for
+*
+*      long prestera_ctl(unsigned int cmd, unsigned long param)
+*
+********************************************************/
+#define   __NR_prestera_ctl   __NR_setxattr
+#endif /* PRESTERA_SYSCALLS */
+
+#ifndef __KERNEL__
+extern GT_32 gtPpFd;
+#ifdef PRESTERA_SYSCALLS
+#include <unistd.h>
+#include <sys/syscall.h>
+#define prestera_ctl(cmd, arg)    syscall(__NR_prestera_ctl, (cmd), (arg))
+#else
+#define prestera_ctl(cmd, arg)   ioctl(gtPpFd, cmd, arg)
+#endif
+#endif
+
+#endif /* __MV_PRESTERA_GLOB */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_irq.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_irq.c
new file mode 100644
index 0000000..2beb7ee
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_irq.c
@@ -0,0 +1,265 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+********************************************************************************
+   Marvell Commercial License Option
+
+   If you received this File from Marvell and you have entered into a commercial
+   license agreement (a "Commercial License") with Marvell, the File is licensed
+   to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+********************************************************************************
+   Marvell BSD License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File under the following licensing terms.
+   Redistribution and use in source and binary forms, with or without modification,
+   are permitted provided that the following conditions are met:
+
+*   Redistributions of source code must retain the above copyright notice,
+    this list of conditions and the following disclaimer.
+
+*   Redistributions in binary form must reproduce the above copyright
+    notice, this list of conditions and the following disclaimer in the
+    documentation and/or other materials provided with the distribution.
+
+*   Neither the name of Marvell nor the names of its contributors may be
+    used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+   ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+   ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+********************************************************************************
+* mv_prestera_irq.c
+*
+* DESCRIPTION:
+*       functions in kernel mode special for prestera IRQ.
+*
+* DEPENDENCIES:
+*
+*******************************************************************************/
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include "mv_prestera_irq.h"
+#include "mvOs.h"
+
+#define PRESTERA_MAX_INTERRUPTS 4
+#define SEMA_DEF_VAL		0
+
+static struct intData	*assigned_irq[PRESTERA_MAX_INTERRUPTS];
+static int		assinged_irq_nr;
+static int		short_bh_count;
+
+int prestera_int_bh_cnt_get(void)
+{
+	return short_bh_count;
+}
+
+/*******************************************************************************
+* prestera_tl_isr
+*
+* DESCRIPTION:
+*       This is the Prestera ISR reponsible for only scheduling the BH (Tasklet).
+*
+* INPUTS:
+*       irq     - the Interrupt ReQuest number
+*       dev_id  - the client data used as argument to the handler
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       IRQ_HANDLED allways
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+static irqreturn_t prestera_tl_isr(int		irq,
+				   void		*dev_id)
+{
+	/* disable the interrupt vector */
+	disable_irq_nosync(irq);
+
+	/* enqueue the PP task BH in the tasklet */
+	tasklet_hi_schedule((struct tasklet_struct *)dev_id);
+
+	short_bh_count++;
+
+	return IRQ_HANDLED;
+}
+
+
+/*******************************************************************************
+* prestera_bh
+*
+* DESCRIPTION:
+*       This is the Prestera DSR, reponsible for only signaling of the occurence
+*       of an event, any procecing will be done in the intTask (user space thread)
+*       it self.
+*
+* INPUTS:
+*       data    - the interrupt control data
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       None.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+static void prestera_bh(unsigned long data)
+{
+	/* awake any reading process */
+	up(&((struct intData *)data)->sem);
+}
+
+/*******************************************************************************
+* prestera_int_connect
+*
+* DESCRIPTION:
+*       connect and interrupt via register it at the kernel.
+*
+* INPUTS:
+*       intVec  - the interrupt vector number to connect
+*       routine - the bound routine for this interrupt vector
+*
+* OUTPUTS:
+*       cookie  - the interrupt control data
+*
+* RETURNS:
+*       0 on success, -1 otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+int prestera_int_connect(unsigned int		intVec,
+			 void			*routine,
+			 struct intData		**cookie)
+{
+	unsigned int		status;
+	struct tasklet_struct	*tasklet;
+	struct intData		*irq_data;
+
+	tasklet = kmalloc(sizeof(struct tasklet_struct), GFP_KERNEL);
+	if (NULL == tasklet) {
+		mvOsPrintf(KERN_ERR "kmalloc failed\n");
+		return -ENOMEM;
+	}
+
+	irq_data = kmalloc(sizeof(struct intData), GFP_KERNEL);
+	if (NULL == irq_data) {
+		mvOsPrintf(KERN_ERR "kmalloc failed\n");
+		return -ENOMEM;
+	}
+	*cookie = irq_data;
+
+	/* The user process will wait on it */
+	sema_init(&(irq_data->sem), SEMA_DEF_VAL);
+	irq_data->intVec = intVec;
+
+	/* For cleanup we will need the tasklet */
+	irq_data->tasklet = tasklet;
+
+	tasklet_init(tasklet, prestera_bh, (unsigned long)irq_data);
+
+	status = request_irq(intVec, prestera_tl_isr,
+			     IRQF_DISABLED,
+			     "mvPP",
+			     (void *)tasklet);
+	if (status) {
+		panic("Can not assign IRQ %d to PresteraDev\n", intVec);
+		return -1;
+	} else {
+		mvOsPrintf(KERN_DEBUG "%s: connected Prestera IRQ - %d\n", __func__, intVec);
+		disable_irq_nosync(intVec);
+		local_irq_disable();
+		if (assinged_irq_nr < PRESTERA_MAX_INTERRUPTS) {
+			assigned_irq[assinged_irq_nr++] = irq_data;
+			local_irq_enable();
+		} else {
+			local_irq_enable();
+			mvOsPrintf(KERN_DEBUG "%s: too many irqs assigned\n", __func__);
+		}
+
+		return 0;
+	}
+}
+
+
+void prestera_int_init(void)
+{
+	assinged_irq_nr = 0;
+	short_bh_count = 0;
+}
+
+
+/*******************************************************************************
+* prestera_int_cleanup
+*
+* DESCRIPTION:
+*       unbind all interrupts
+*
+* INPUTS:
+*       None
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       0 on success, -1 otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+int prestera_int_cleanup(void)
+{
+	struct intData	*irq_data;
+
+	while (assinged_irq_nr > 0) {
+		irq_data = assigned_irq[--assinged_irq_nr];
+
+		disable_irq_nosync(irq_data->intVec);
+		free_irq(irq_data->intVec, (void *)irq_data->tasklet);
+		tasklet_kill(irq_data->tasklet);
+		kfree(irq_data->tasklet);
+		kfree(irq_data);
+	}
+	return 0;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_irq.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_irq.h
new file mode 100644
index 0000000..26e1993
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_irq.h
@@ -0,0 +1,133 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+********************************************************************************
+   Marvell Commercial License Option
+
+   If you received this File from Marvell and you have entered into a commercial
+   license agreement (a "Commercial License") with Marvell, the File is licensed
+   to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+********************************************************************************
+   Marvell BSD License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File under the following licensing terms.
+   Redistribution and use in source and binary forms, with or without modification,
+   are permitted provided that the following conditions are met:
+
+*   Redistributions of source code must retain the above copyright notice,
+    this list of conditions and the following disclaimer.
+
+*   Redistributions in binary form must reproduce the above copyright
+    notice, this list of conditions and the following disclaimer in the
+    documentation and/or other materials provided with the distribution.
+
+*   Neither the name of Marvell nor the names of its contributors may be
+    used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+   ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+   ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+********************************************************************************
+* mv_prestera_irq.h
+*
+* DESCRIPTION:
+*       Includes defines and structures needed by the PP device driver
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+#ifndef __MV_PRESTERA_IRQ
+#define __MV_PRESTERA_IRQ
+
+#include <linux/semaphore.h>
+#include <linux/interrupt.h>
+#include "mv_prestera.h"
+
+struct intData {
+	unsigned long		intVec;		/* the interrupt vector we bind too */
+	struct semaphore	sem;		/* the semaphore on which the user waits */
+	struct tasklet_struct   *tasklet;	/* the tasklet - needit for cleanup */
+};
+
+/*******************************************************************************
+* prestera_int_connect
+*
+* DESCRIPTION:
+*       connect and interrupt via register it at the kernel.
+*
+* INPUTS:
+*       intVec  - the interrupt vector number to connect
+*       routine - the bound routine for this interrupt vector
+*
+* OUTPUTS:
+*       cookie  - the interrupt control data
+*
+* RETURNS:
+*       0 on success, -1 otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+int prestera_int_connect(unsigned int		intVec,
+			 void			*routine,
+			 struct intData		**cookie);
+
+/*******************************************************************************
+* prestera_int_cleanup
+*
+* DESCRIPTION:
+*       unbind all interrupts
+*
+* INPUTS:
+*       None
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       0 on success, -1 otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+int prestera_int_cleanup(void);
+void prestera_int_init(void);
+int prestera_int_bh_cnt_get(void);
+
+
+#endif /* __MV_PRESTERA_IRQ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_smi.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_smi.c
new file mode 100644
index 0000000..b19e1c2
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_smi.c
@@ -0,0 +1,1004 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+********************************************************************************
+   Marvell Commercial License Option
+
+   If you received this File from Marvell and you have entered into a commercial
+   license agreement (a "Commercial License") with Marvell, the File is licensed
+   to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+********************************************************************************
+   Marvell BSD License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File under the following licensing terms.
+   Redistribution and use in source and binary forms, with or without modification,
+   are permitted provided that the following conditions are met:
+
+*   Redistributions of source code must retain the above copyright notice,
+    this list of conditions and the following disclaimer.
+
+*   Redistributions in binary form must reproduce the above copyright
+    notice, this list of conditions and the following disclaimer in the
+    documentation and/or other materials provided with the distribution.
+
+*   Neither the name of Marvell nor the names of its contributors may be
+    used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+   ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+   ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************
+* mv_prestera_smi.c
+*
+* DESCRIPTION:
+*       functions in kernel mode special for prestera_smi.
+*
+* DEPENDENCIES:
+*
+*******************************************************************************/
+#include <asm/uaccess.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/cdev.h>
+#include <linux/proc_fs.h>
+#include <linux/interrupt.h>
+#include <linux/mm.h>
+#include <linux/version.h>
+
+#include "mv_prestera.h"
+#include "mv_prestera_smi_glob.h"
+#include "mv_pss_api.h"
+#include "mvOs.h"
+
+#undef MV_DEBUG
+
+/* defines  */
+#ifdef MV_DEBUG
+#define DB(x)   x
+#else
+#define DB(x)
+#endif
+
+/* local variables and variables */
+static int presteraSmi_initialized = -1;
+
+static int rx_DSR = -1;			/* rx DSR invocation counter */
+static int tx_DSR = -1;			/* tx DSR invocation counter */
+
+struct semaphore *netIfIntTaskSemPtr;   /*  netIfIntTask Signalling sema */
+struct semaphore netIfIntTaskSem;
+
+
+/******************************************************************************/
+/*********************** ethernet port FIFO section ***************************/
+/******************************************************************************/
+static unsigned long    *fifoPtr;	/* the FIFO pointer               */
+static unsigned long	occupied;	/* occupied segments counter      */
+static unsigned long	fifoSize;	/* FIFO size                      */
+static unsigned long    *frontPtr;	/* FIFO front pointer             */
+static unsigned long    *rearPtr;	/* FIFO rear pointer              */
+static unsigned long    *firstPtr;	/* first element in FIFO          */
+static unsigned long    *lastPtr;	/* last element in FIFO           */
+
+/*******************************************************************************
+* ethPortFifoInit
+*
+* DESCRIPTION:  This routine allocates kernel memory for the FIFO. It is called
+*               twice: once for the Rx and once for the Tx complete. The second
+*               invocation allocates the memory and sets the FIFO pointers.
+*
+* INPUTS:
+*       numOfElem - the number of elements (buffers and control data) needed
+*                   for Rx/TxEnd
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       -ENOMEM - if there is no sufficiant memory
+*       0 - on success.
+*
+*******************************************************************************/
+long ethPortFifoInit(unsigned long numOfElem)
+{
+	if (numOfElem == 0) {
+		mvOsPrintf(KERN_ERR "ethPortFifoInit:Err numOfElem is 0\n");
+		return -EPERM;
+	}
+
+	if (fifoSize == 0)
+		fifoSize = numOfElem;
+	else {
+		if (fifoPtr != NULL) {
+			mvOsPrintf(KERN_ERR "ethPortFifoInit: FIFIO allready initialized\n");
+			return -EPERM;
+		}
+
+		fifoSize += numOfElem;
+
+		fifoPtr = kmalloc((1 + fifoSize) * sizeof(unsigned long), GFP_KERNEL);
+
+		if (!fifoPtr) {
+			mvOsPrintf(KERN_ERR "ethPortFifoInit: Failed allocating memory for FIFO\n");
+			return -ENOMEM;
+		}
+
+		frontPtr = &fifoPtr[0];
+		rearPtr  = &fifoPtr[0];
+		firstPtr = &fifoPtr[0];
+		lastPtr  = &fifoPtr[1 + fifoSize];
+	}
+
+	return 0;
+}
+
+/*******************************************************************************
+* ethPortFifoEnQueue
+*
+* DESCRIPTION:  This routine adds the new data in the FIFO front.
+*
+* INPUTS:
+*       elem - the element data to insert in the FIFO front
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       1 - FIFO is full, insertion failed!
+*       0 - on success.
+*
+*******************************************************************************/
+long ethPortFifoEnQueue(unsigned long elem)
+{
+	unsigned long    *frontTmpPtr;
+
+	frontTmpPtr = frontPtr;
+
+	frontTmpPtr++;
+
+	/* need to wrap ? */
+	if (frontTmpPtr >= lastPtr)
+		frontTmpPtr = firstPtr;
+
+	if (frontTmpPtr == rearPtr) {
+		/* fifo was full, insertion failed */
+		mvOsPrintf(KERN_ERR "ethPortFifoInsert: fifo full err\n");
+		return 1;
+	} else {
+		/* success, put in the data and update fifo control front ptr */
+		*frontPtr = elem;
+		frontPtr = frontTmpPtr;
+		occupied++;
+	}
+	return 0;
+}
+
+/*******************************************************************************
+* ethPortFifoDeQueue
+*
+* DESCRIPTION:  This routine gets the first data element from the FIFO rear.
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       elemPtr <- pointer to update with the element got from FIFO rear
+*
+* RETURNS:
+*       1 - FIFO is empty.
+*       0 - on success.
+*
+*******************************************************************************/
+long ethPortFifoDeQueue(unsigned long *elemPtr)
+{
+	/* empty FIFO */
+	if (rearPtr == frontPtr) {
+		mvOsPrintf(KERN_ERR "ethPortFifoDeQueue: fifo is EMPTY\n");
+		return 1;
+	}
+
+	/* get the data */
+	*elemPtr = *rearPtr;
+
+	rearPtr++;
+
+	occupied--;
+
+	/* need to wrap ? */
+	if (rearPtr == lastPtr)
+		rearPtr = firstPtr;
+
+	return 0;
+}
+
+/*******************************************************************************
+* ethPortFifoEnQueuePossible
+*
+* DESCRIPTION:  This routine returns a status if the number of elements can be
+*               inserted to FIFO.
+*
+* INPUTS:
+*       itemsCnt - the number of elements the user wants to insert
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       1 - there in`t enough space for the elements.
+*       0 - there is enough space for the elements.
+*
+*******************************************************************************/
+long ethPortFifoEnQueuePossible(unsigned long elemCnt)
+{
+	if (fifoSize - occupied > elemCnt)
+		return 0;
+	else
+		return 1;
+}
+
+/******************************************************************************/
+/*********************** ethernet port FIFO section end ***********************/
+/******************************************************************************/
+/*******************************************************************************
+* dropThePacket
+*
+* DESCRIPTION:  This routine drops the packet.
+*
+*
+* INPUTS:
+*       ctrlSeg - packet segment control
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       <0 - the errno to pass to user app.
+*
+*******************************************************************************/
+static int dropThePacket(unsigned long ctrlSeg)
+{
+	unsigned long	readCnt;
+	unsigned long	sink;
+	unsigned long	*segmentPtr;
+	unsigned long	queueNum;
+	unsigned long	segNumber;
+
+	/* get the number of segments of the packet */
+	segNumber = (ETH_PORT_FIFO_ELEM_CNT_MASK & ctrlSeg);
+
+	/* allocate mem to copy the segments to */
+	segmentPtr = kmalloc(segNumber * sizeof(unsigned long), GFP_KERNEL);
+
+	if (!segmentPtr) {
+		mvOsPrintf(KERN_ERR "dropThePacket: Failed allocating memory\n");
+		return -ENOMEM;
+	}
+	readCnt = 0;
+
+	/* copy the segments from FIFO to allocated memory */
+	while (readCnt < segNumber) {
+		/* read the segment pointer */
+		if (ethPortFifoDeQueue(&segmentPtr[readCnt]) != 0) {
+			panic("dropThePacket: expecting more segments in fifo");
+			return -EIO;
+		}
+		readCnt++;
+
+		/* read the segment length, not needed by free routine */
+		if (ethPortFifoDeQueue(&sink) != 0) {
+			panic("dropThePacket: expecting more segments in fifo");
+			return -EIO;
+		}
+	}
+	/* get the queue number from control segment */
+	queueNum = (ctrlSeg & ETH_PORT_FIFO_QUE_NUM_MASK) >>
+		   ETH_PORT_FIFO_QUE_NUM_OFFSET;
+
+	bspEthRxPacketFree((unsigned char **)segmentPtr, readCnt, queueNum);
+	kfree(segmentPtr);
+	return -ENOBUFS;
+}
+
+/*******************************************************************************
+* prestera_smi_read
+*
+* DESCRIPTION:  This routine reads a packet from the network interface FIFO. The
+*               first segment in FIFO is the control, which includes some
+*               additional information regarding the packet. The next segments
+*               are the packet data and for Rx packets, the segment lengths.
+*
+* INPUTS:
+*       filp    - device descriptor
+*       count   - the number of segments in the buffer
+*       f_pos   - position in the file (not used)
+*
+* OUTPUTS:
+*       buf     <- the buffer to put the packet segments in
+*
+* RETURNS:
+*       >0 - the number of segments in the read packet.
+*       0 - there are no more packets to read.
+*
+*******************************************************************************/
+ssize_t prestera_smi_read(struct file       *filp,
+			 char              *buf,
+			 size_t count,
+			 loff_t            *f_pos)
+{
+	ssize_t readCnt;
+	unsigned long segNumber;
+	static unsigned long fifoData[MAX_SEG * 2 + 1];
+	unsigned long wordNumber;
+
+	readCnt = 0;
+
+	/* read the first segment (control segment) from  FIFO */
+	if (ethPortFifoDeQueue(&fifoData[readCnt++]) != 0)
+		/* fifo is empty, no more data */
+		return 0;
+
+	/* extract from control segment needed data */
+	segNumber = (ETH_PORT_FIFO_ELEM_CNT_MASK & fifoData[0]);
+	DB(mvOsPrintf("presteraSmi_read, segNumber=%ld\n", segNumber));
+
+	/* extract from the fifo the data segments */
+	if (ETH_PORT_FIFO_TYPE_RX_MASK & fifoData[0]) {
+		wordNumber = (segNumber * 2) + 1;
+
+		/* validate the number of words is not too big to copy to user */
+		if ((wordNumber * sizeof(unsigned long)) > count) {
+			/* The control segments indicates too many segments for the packet, */
+			/* we can not pass it to user, it is dropped and freed!             */
+			return dropThePacket(fifoData[0]);
+		}
+		/* RX packet segments */
+		while (readCnt < wordNumber) {
+			if (ethPortFifoDeQueue(&fifoData[readCnt]) != 0) {
+				panic("presteraSmi_read: expecting more segments in fifo");
+				return -EIO;
+			}
+			readCnt++;
+
+			if (ethPortFifoDeQueue(&fifoData[readCnt]) != 0) {
+				panic("presteraSmi_read: expecting more segments in fifo");
+				return -EIO;
+			}
+			readCnt++;
+		}
+	} else { /* TX Complete packet segments */
+		wordNumber = segNumber + 1;
+
+		/* validate the number of words is not too big to copy to user */
+		if ((wordNumber * sizeof(unsigned long)) > count) {
+			/* return the first segment back to the fifo */
+			if (ethPortFifoEnQueue(fifoData[0]) != 0) {
+				panic("presteraSmi_read: expecting that fifo is not full");
+				return -EIO;
+			}
+			/* put the rest of the segments back to the fifo*/
+			while (readCnt < wordNumber) {
+				if (ethPortFifoDeQueue(&fifoData[readCnt]) != 0) {
+					panic("presteraSmi_read: expecting more segments in fifo");
+					return -EIO;
+				}
+				if (ethPortFifoEnQueue(fifoData[readCnt]) != 0) {
+					panic("presteraSmi_read: expecting that fifo is not full");
+					return -EIO;
+				}
+				readCnt++;
+			}
+			return -ENOBUFS;
+		}
+
+		while (readCnt < wordNumber) {
+			if (ethPortFifoDeQueue(&fifoData[readCnt]) != 0) {
+				panic("presteraSmi_read: expecting more segments in fifo");
+				return -EIO;
+			}
+			readCnt++;
+		}
+	}
+
+	readCnt *= sizeof(unsigned long);
+
+	if (copy_to_user((char *)buf, (unsigned long *)fifoData, readCnt)) {
+		mvOsPrintf(KERN_ERR "presteraSmi_read: copy_to_user FAULT\n");
+		return -EFAULT;
+	}
+
+	return readCnt;
+}
+
+/*******************************************************************************
+* prestera_smi_write
+*
+* DESCRIPTION:  This routine sends the packet pointed by the segments in the buf
+*               poiner over the network interface.
+*
+* INPUTS:
+*       filp    - device descriptor
+*       buf     - the buffer to be written
+*       count   - the number of segments in the buffer
+*       f_pos   - position in the file (not used)
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       -1 - FIFO is empty.
+*       <0 - on success.
+*
+*******************************************************************************/
+ssize_t prestera_smi_write(struct file	*filp,
+			   const char	*buf,
+			   size_t	count,
+			   loff_t	*f_pos)
+{
+	unsigned char		*segmentListPtr[MAX_SEG];
+	unsigned long		segmentLen[MAX_SEG];
+	const unsigned long	*bufPtr;
+	unsigned long		txQueue;
+
+	bufPtr = (const unsigned long *)buf;
+
+	if (count > MAX_SEG) {
+		mvOsPrintf(KERN_ERR "%s: count too big\n", __func__);
+		return -1;
+	}
+
+	/* the segment list is first in the bufPtr array */
+	if (copy_from_user(segmentListPtr, &bufPtr[0], sizeof(unsigned long) * count)) {
+		mvOsPrintf(KERN_ERR "%s: copy_from_user FAULT\n", __func__);
+		return -EFAULT;
+	}
+
+	/* the segment length is second in the bufPtr array */
+	if (copy_from_user(segmentLen, &bufPtr[count], sizeof(unsigned long) * count)) {
+		mvOsPrintf(KERN_ERR "%s: copy_from_user FAULT\n", __func__);
+		return -EFAULT;
+	}
+
+	/* The txQueue is in the 8 leftmost bits of segmentLen[0].
+	   segmentLen[0] is very small and will never get to 2^24 size. gc
+	   Read about it in
+	   cpssEnabler/mainExtDrv/src/gtExtDrv/gtLinuxXcat/gtXcatEthPortControl.c
+	 */
+
+	txQueue = (segmentLen[0] & 0xff000000) >> 24;
+	segmentLen[0] &= 0x00ffffff;
+
+#ifdef MV_DEBUG
+	{
+		int i;
+		mvOsPrintf("txQueue = %ld\n", txQueue);
+		mvOsPrintf("in %s, Tx ", __func__);
+		for (i = 0; i < count; i++)
+			mvOsPrintf("seg[%d]=0x%X (%d) ", i,
+			       (int)segmentListPtr[i], (int)segmentLen[i]);
+		mvOsPrintf("\n");
+	}
+#endif
+
+	if (bspEthPortTxQueue(segmentListPtr, segmentLen, count, txQueue)) {
+		mvOsPrintf("%s: bspEthPortTxQueue err\n", __func__);
+		return -1;
+	}
+	DB(mvOsPrintf("%s: EXIT\n", __func__));
+	return 1;
+}
+
+int prestera_smi_eth_port_rx_dsr_cnt(void)
+{
+	return (rx_DSR == -1) ? 0 : rx_DSR;
+}
+
+
+int prestera_smi_eth_port_tx_dsr_cnt(void)
+{
+	return (tx_DSR == -1) ? 0 : tx_DSR;
+}
+
+
+/*******************************************************************************
+* prestera_smi_eth_port_rx_dsr
+*
+* DESCRIPTION:
+*       This is the PresteraSMI ethernet port Rx Deferred-Service-Routine (DSR),
+*       reponsible for inserting the packet segments and segment lengths to the
+*       FIFO. The routine wakes the netIfintTask thread.
+*
+* INPUTS:
+*       segmentList     - A list of pointers to the packets segments.
+*       segmentLen      - A list of segement length.
+*       numOfSegments   - The number of segment in segment list.
+*       queueNum        - the received queue number
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:ppTq
+*       0 on success, or
+*       1 otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+unsigned long prestera_smi_eth_port_rx_dsr(unsigned char	*segmentList[],
+					  unsigned long		segmentLen[],
+					  unsigned long		numOfSegments,
+					  unsigned long		queueNum)
+{
+	unsigned long firstElem;
+	int i;
+
+	/* validate that there is ample space for the packet in FIFO */
+	if (ethPortFifoEnQueuePossible(numOfSegments * 2 + 1) != 0)
+		return 1;
+
+	/* set the first element (packet control) and insert to FIFO */
+	firstElem = (queueNum << ETH_PORT_FIFO_QUE_NUM_OFFSET) |
+		    numOfSegments |
+		    ETH_PORT_FIFO_TYPE_RX_MASK;
+
+	if (ethPortFifoEnQueue(firstElem) != 0) {
+		panic("presteraSmi_eth_port_rx_DSR: ethPortFifoEnQueue failed\n");
+		return 1;
+	}
+
+	/* insert all packet segments and segment lengths to FIFO */
+	for (i = 0; i < numOfSegments; i++) {
+		if (ethPortFifoEnQueue((unsigned long)segmentList[i]) != 0) {
+			panic("presteraSmi_eth_port_rx_DSR: ethPortFifoEnQueue failed\n");
+			return 1;
+		}
+
+		if (ethPortFifoEnQueue((unsigned long)segmentLen[i]) != 0) {
+			panic("presteraSmi_eth_port_rx_DSR: ethPortFifoEnQueue failed\n");
+			return 1;
+		}
+	}
+	rx_DSR++;
+
+	/* awake reading process */
+	up(netIfIntTaskSemPtr);
+
+	return 0;
+}
+
+/*******************************************************************************
+* prestera_smi_eth_port_tx_end_dsr
+*
+* DESCRIPTION:
+*       This is the presteraSmi ethernet port Tx Complete Deferred-Service-Routine (DSR),
+*       reponsible for inserting the packet segments to the FIFO. The routine
+*       wakes the presteraSmi interrupt thread.
+*
+* INPUTS:
+*       segmentList     - A list of pointers to the packets segments.
+*       numOfSegments   - The number of segment in segment list.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       0 on success, or
+*       1 otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+unsigned long prestera_smi_eth_port_tx_end_dsr(unsigned char	*segmentList[],
+					      unsigned long	numOfSegments)
+{
+	int i;
+
+	/* validate that there is ample space for the packet in FIFO */
+	if (ethPortFifoEnQueuePossible(numOfSegments + 1) != 0) {
+		panic("presteraSmi_eth_port_tx_end_DSR: ethPortFifoEnQueue failed\n");
+		return 1;
+	}
+
+	if (ethPortFifoEnQueue(numOfSegments) != 0) {
+		panic("presteraSmi_eth_port_tx_end_DSR: ethPortFifoEnQueue failed\n");
+		return 1;
+	}
+
+	/* insert all packet segments to FIFO */
+	for (i = 0; i < numOfSegments; i++) {
+		if (ethPortFifoEnQueue((unsigned long)segmentList[i]) != 0) {
+			panic("presteraSmi_eth_port_tx_end_DSR: ethPortFifoEnQueue failed\n");
+			return 1;
+		}
+	}
+
+	tx_DSR++;
+
+	/* awake reading process */
+	up(netIfIntTaskSemPtr);
+
+	return 0;
+}
+
+/************************************************************************
+*
+*                   presteraSmi_cleanup
+*
+************************************************************************/
+void prestera_smi_cleanup(void)
+{
+	presteraSmi_initialized = -1;
+}
+
+#ifdef MV_DEBUG
+static void ioctl_cmd_pr(unsigned int cmd)
+{
+	char *dir;
+
+	static const char const *prestera_ioctls[] = {
+		[_IOC_NR(PRESTERA_SMI_IOC_WRITEREG)]		= "WRITEREG",
+		[_IOC_NR(PRESTERA_SMI_IOC_READREG)]		= "READREG",
+		[_IOC_NR(PRESTERA_SMI_IOC_WRITEREGDIRECT)]	= "WRITEREGDIRECT",
+		[_IOC_NR(PRESTERA_SMI_IOC_READREGDIRECT)]	= "READREGDIRECT",
+		[_IOC_NR(PRESTERA_SMI_IOC_WRITEREGFIELD)]	= "WRITEREGFIELD",
+		[_IOC_NR(PRESTERA_SMI_IOC_READREGRAM)]		= "READREGRAM",
+		[_IOC_NR(PRESTERA_SMI_IOC_WRITEREGRAM)]		= "WRITEREGRAM",
+		[_IOC_NR(PRESTERA_SMI_IOC_READREGVEC)]		= "READREGVEC",
+		[_IOC_NR(PRESTERA_SMI_IOC_WRITEREGVEC)]		= "WRITEREGVEC",
+		[_IOC_NR(PRESTERA_SMI_IOC_ETHPORTENABLE)]	= "ETHPORTENABLE",
+		[_IOC_NR(PRESTERA_SMI_IOC_ETHPORTDISABLE)]	= "ETHPORTDISABLE",
+		[_IOC_NR(PRESTERA_SMI_IOC_ETHPORTRXINIT)]	= "ETHPORTRXINIT",
+		[_IOC_NR(PRESTERA_SMI_IOC_ETHPORTTXINIT)]	= "ETHPORTTXINIT",
+		[_IOC_NR(PRESTERA_SMI_IOC_ETHPORTFREEBUF)]	= "ETHPORTFREEBUF",
+		[_IOC_NR(PRESTERA_SMI_IOC_ETHPORTRXBIND)]	= "ETHPORTRXBIND",
+		[_IOC_NR(PRESTERA_SMI_IOC_ETHPORTTXBIND)]	= "ETHPORTTXBIND",
+		[_IOC_NR(PRESTERA_SMI_IOC_NETIF_WAIT)]		= "NETIF_WAIT",
+		[_IOC_NR(PRESTERA_SMI_IOC_TXMODE_SET)]		= "TXMODE_SET",
+		[_IOC_NR(PRESTERA_SMI_IOC_CPUCODE_TO_QUEUE)]	= "CPUCODE_TO_QUEUE",
+		[_IOC_NR(PRESTERA_SMI_IOC_MUXSET)]		= "MUXSET",
+		[_IOC_NR(PRESTERA_SMI_IOC_MUXGET)]		= "MUXGET",
+};
+
+	#define PRESTERA_IOCTLS ARRAY_SIZE(prestera_ioctls)
+
+	switch (_IOC_DIR(cmd)) {
+	case _IOC_NONE:
+		dir = "--";
+		break;
+
+	case _IOC_READ:
+		dir = "r-";
+		break;
+
+	case _IOC_WRITE:
+		dir = "-w";
+		break;
+
+	case _IOC_READ | _IOC_WRITE:
+		dir = "rw";
+		break;
+
+	default:
+		dir = "*ERR*";
+		break;
+	}
+	mvOsPrintf("got ioctl '%c', dir=%s, #%d (0x%08x) ",
+		   _IOC_TYPE(cmd), dir, _IOC_NR(cmd), cmd);
+
+	if (_IOC_NR(cmd) < PRESTERA_IOCTLS)
+		mvOsPrintf("%s\n", prestera_ioctls[_IOC_NR(cmd)]);
+}
+#endif /* MV_DEBUG */
+
+
+/************************************************************************
+*
+*           presteraSmi_ioctl: ioctl() implementation
+*
+************************************************************************/
+int prestera_smi_ioctl(unsigned int cmd, unsigned long arg)
+{
+	struct SMI_REG		smiReg;
+	struct SMI_REG_RAM_STC	smiRegRam;
+	unsigned long		i;
+	unsigned long		smiRegVal;
+	unsigned int		numOfTxBufs;
+	unsigned int		txMode;
+	int			retStatus;
+	struct MUX_PARAM	muxParam;
+	struct RX_INIT_PARAM	rxParam;
+	struct RX_FREE_BUF_PARAM	bufFreeParam;
+	struct CPU_CODE_TO_QUEUE_PARAM	cpuCodeToQueueParam;
+
+	if (presteraSmi_initialized == -1)
+		return -ENODEV;
+
+#ifdef MV_DEBUG
+	ioctl_cmd_pr(cmd);
+#endif
+
+	/* GETTING DATA */
+	switch (cmd) {
+	case PRESTERA_SMI_IOC_ETHPORTRXBIND:
+	case PRESTERA_SMI_IOC_ETHPORTTXBIND:
+	case PRESTERA_SMI_IOC_ETHPORTENABLE:
+	case PRESTERA_SMI_IOC_ETHPORTDISABLE:
+		break;
+
+	case PRESTERA_SMI_IOC_READREG:
+	case PRESTERA_SMI_IOC_WRITEREG:
+		/* read and parse user data structurr */
+		if (copy_from_user(&smiReg, (struct SMI_REG *)arg, sizeof(struct SMI_REG)))
+			goto ioctlFault;
+		break;
+	case PRESTERA_SMI_IOC_MUXSET:
+		/* read and parse user data structurr */
+		if (copy_from_user(&muxParam, (struct MUX_PARAM *)arg, sizeof(struct MUX_PARAM)))
+			goto ioctlFault;
+		break;
+
+	case PRESTERA_SMI_IOC_READREGRAM:
+	case PRESTERA_SMI_IOC_WRITEREGRAM:
+		if (copy_from_user(&smiRegRam, (struct SMI_REG_RAM_STC *)arg,
+				   sizeof(struct SMI_REG_RAM_STC)))
+			goto ioctlFault;
+
+	case PRESTERA_SMI_IOC_TXMODE_SET:
+		if (copy_from_user(&txMode, (unsigned int *)arg, sizeof(unsigned int)))
+			goto ioctlFault;
+		break;
+
+	case PRESTERA_SMI_IOC_CPUCODE_TO_QUEUE:
+		/* read and parse user data structure */
+		if (copy_from_user(&cpuCodeToQueueParam,
+				   (struct CPU_CODE_TO_QUEUE_PARAM *)arg,
+				   sizeof(struct CPU_CODE_TO_QUEUE_PARAM)))
+			goto ioctlFault;
+		break;
+
+	case PRESTERA_SMI_IOC_ETHPORTTXINIT:
+		/* read and parse user data structure */
+		if (copy_from_user(&numOfTxBufs, (unsigned int *)arg, sizeof(unsigned int)))
+			goto ioctlFault;
+		break;
+	case PRESTERA_SMI_IOC_ETHPORTRXINIT:
+		/* read and parse user data structure */
+		if (copy_from_user(&rxParam, (struct RX_INIT_PARAM *)arg, sizeof(struct RX_INIT_PARAM)))
+			goto ioctlFault;
+		break;
+
+	case PRESTERA_SMI_IOC_ETHPORTFREEBUF:
+		/* read and parse user data structure */
+		if (copy_from_user(&bufFreeParam, (struct RX_FREE_BUF_PARAM *)arg, 2 * sizeof(long)))
+			goto ioctlFault;
+		if (copy_from_user(&bufFreeParam.segmentList,
+				   (struct RX_FREE_BUF_PARAM *)(arg + (2 * sizeof(long))),
+				   bufFreeParam.numOfSegments * sizeof(char *)))
+			goto ioctlFault;
+		break;
+
+	case PRESTERA_SMI_IOC_NETIF_WAIT:
+		break;
+
+	default:
+		mvOsPrintf(KERN_WARNING "Unknown ioctl (%x).\n", cmd);
+		break;
+	}
+	/* DOING SOMETHING */
+	switch (cmd) {
+	/* Note. Both bspSmiReadReg and bspSmiWriteReg perform indirect operation */
+
+	case PRESTERA_SMI_IOC_READREG:
+		/* Read the user params */
+		bspSmiReadReg(smiReg.slvId, 0, smiReg.regAddr, &smiReg.value);
+		break;
+
+	case PRESTERA_SMI_IOC_WRITEREG:
+		/* Write the user params */
+		bspSmiWriteReg(smiReg.slvId, 0, smiReg.regAddr, smiReg.value);
+		break;
+	case PRESTERA_SMI_IOC_MUXSET:
+		break;
+
+	case PRESTERA_SMI_IOC_MUXGET:
+		break;
+
+	case PRESTERA_SMI_IOC_READREGRAM:
+		for (i = 0; i < smiRegRam.arrLen; i++, smiRegRam.addr += 4) {
+			bspSmiReadReg(smiRegRam.devSlvId, 0, smiRegRam.addr, &smiRegVal);
+			if (copy_to_user((unsigned long *)(smiRegRam.dataArr + i),
+					 &smiRegVal,
+					 sizeof(smiRegVal)))
+				goto ioctlFault;
+		}
+		break;
+
+	case PRESTERA_SMI_IOC_WRITEREGRAM:
+		for (i = 0; i < smiRegRam.arrLen; i++, smiRegRam.addr += 4) {
+			if (copy_from_user(&smiRegVal,
+					   (unsigned long *)(smiRegRam.dataArr + i),
+					   sizeof(smiRegVal)))
+				goto ioctlFault;
+
+			bspSmiWriteReg(smiRegRam.devSlvId, 0, smiRegRam.addr, smiRegVal);
+		}
+		break;
+
+	case PRESTERA_SMI_IOC_ETHPORTENABLE:
+		bspEthPortEnable();
+		break;
+
+	case PRESTERA_SMI_IOC_ETHPORTDISABLE:
+		bspEthPortDisable();
+		break;
+
+	case PRESTERA_SMI_IOC_TXMODE_SET:
+		bspEthPortTxModeSet((void *)txMode);
+		break;
+
+	case PRESTERA_SMI_IOC_CPUCODE_TO_QUEUE:
+		bspEthCpuCodeToQueue(cpuCodeToQueueParam.cpuCode,
+				      cpuCodeToQueueParam.queue);
+		break;
+
+	case PRESTERA_SMI_IOC_ETHPORTTXINIT:
+		bspEthInit(1); /*?*/
+		DB(mvOsPrintf("tx bspEthInit - done\n"));
+		bspEthPortTxInit(numOfTxBufs);
+		ethPortFifoInit(numOfTxBufs * 2);
+		break;
+
+	case PRESTERA_SMI_IOC_ETHPORTRXINIT:
+		bspEthInit(1); /*?*/
+		DB(mvOsPrintf("rx: bspEthInit - done\n"));
+
+		DB(mvOsPrintf("IOCTL_ETHPORTRXINIT:rxParam.rxBufPoolPtr 0x%x\n",
+			(unsigned int)rxParam.rxBufPoolPtr));
+		retStatus = bspEthPortRxInit(rxParam.rxBufPoolSize,
+					      rxParam.rxBufPoolPtr,
+					      rxParam.rxBufSize,
+					      rxParam.numOfRxBufsPtr,
+					      rxParam.headerOffset,
+					      rxParam.rxQNum,
+					      rxParam.rxQbufPercentage);
+
+		if (retStatus != MV_OK) {
+			mvOsPrintf(KERN_ERR "PRESTERA_SMI_IOC_ETHPORTRXINIT,retStatus = %d\n", retStatus);
+			goto ioctlFault;
+		}
+		ethPortFifoInit((*(rxParam.numOfRxBufsPtr)) * 3);
+
+		break;
+
+	case PRESTERA_SMI_IOC_ETHPORTFREEBUF:
+		bspEthRxPacketFree(bufFreeParam.segmentList,
+				    bufFreeParam.numOfSegments,
+				    bufFreeParam.queueNum);
+
+		break;
+
+	case PRESTERA_SMI_IOC_ETHPORTRXBIND:
+		bspEthInputHookAdd((BSP_RX_CALLBACK_FUNCPTR)prestera_smi_eth_port_rx_dsr);
+
+		break;
+
+	case PRESTERA_SMI_IOC_ETHPORTTXBIND:
+		bspEthTxCompleteHookAdd((BSP_TX_COMPLETE_CALLBACK_FUNCPTR)prestera_smi_eth_port_tx_end_dsr);
+		break;
+
+	case PRESTERA_SMI_IOC_NETIF_WAIT:
+		DB(mvOsPrintf("netIfIntTaskSemPtr:%p\n", netIfIntTaskSemPtr));
+
+		if (down_interruptible(netIfIntTaskSemPtr))
+			return -ERESTARTSYS;
+		break;
+
+	default:
+		mvOsPrintf(KERN_WARNING "Unknown ioctl (%x).\n", cmd);
+		break;
+	}
+
+	/* Write back to user */
+	switch (cmd) {
+	case PRESTERA_SMI_IOC_READREG:
+	case PRESTERA_SMI_IOC_READREGDIRECT:
+		if (copy_to_user((struct SMI_REG *)arg, &smiReg, sizeof(struct SMI_REG)))
+			goto ioctlFault;
+		break;
+
+	case PRESTERA_SMI_IOC_MUXGET:
+		if (copy_to_user((struct MUX_PARAM *)arg, &muxParam, sizeof(struct MUX_PARAM)))
+			goto ioctlFault;
+		break;
+
+	case PRESTERA_SMI_IOC_NETIF_WAIT:
+	case PRESTERA_SMI_IOC_WRITEREG:
+	case PRESTERA_SMI_IOC_MUXSET:
+	case PRESTERA_SMI_IOC_READREGRAM:
+	case PRESTERA_SMI_IOC_WRITEREGRAM:
+	case PRESTERA_SMI_IOC_WRITEREGDIRECT:
+	case PRESTERA_SMI_IOC_WRITEREGFIELD:
+	case PRESTERA_SMI_IOC_ETHPORTENABLE:
+	case PRESTERA_SMI_IOC_ETHPORTDISABLE:
+	case PRESTERA_SMI_IOC_TXMODE_SET:
+	case PRESTERA_SMI_IOC_CPUCODE_TO_QUEUE:
+	case PRESTERA_SMI_IOC_ETHPORTTXINIT:
+	case PRESTERA_SMI_IOC_ETHPORTFREEBUF:
+	case PRESTERA_SMI_IOC_ETHPORTRXBIND:
+	case PRESTERA_SMI_IOC_ETHPORTTXBIND:
+	case PRESTERA_SMI_IOC_ETHPORTRXINIT:
+		break;
+
+	default:
+		mvOsPrintf(KERN_WARNING "Unknown ioctl (%x).\n", cmd);
+		break;
+	}
+	return 0;
+
+ioctlFault:
+	mvOsPrintf(KERN_ERR "IOCTL: FAULT\n");
+	return -EFAULT;
+}
+
+/************************************************************************
+*
+*                   presteraSmi_init
+*
+************************************************************************/
+int prestera_smi_init(void)
+{
+	netIfIntTaskSemPtr = &netIfIntTaskSem;
+
+	/* The netIf user process will wait on it */
+	sema_init(netIfIntTaskSemPtr, 1);
+
+	presteraSmi_initialized = 1;
+
+	rx_DSR = tx_DSR = 0;
+
+	fifoPtr = NULL;
+	occupied = 0;
+	fifoSize = 0;
+	frontPtr = NULL;
+	rearPtr = NULL;
+	firstPtr = NULL;
+	lastPtr = NULL;
+
+	DB(mvOsPrintf("%s done\n", __func__));
+
+	return 0;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_smi.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_smi.h
new file mode 100644
index 0000000..647fb09
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_smi.h
@@ -0,0 +1,90 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+********************************************************************************
+   Marvell Commercial License Option
+
+   If you received this File from Marvell and you have entered into a commercial
+   license agreement (a "Commercial License") with Marvell, the File is licensed
+   to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+********************************************************************************
+   Marvell BSD License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File under the following licensing terms.
+   Redistribution and use in source and binary forms, with or without modification,
+   are permitted provided that the following conditions are met:
+
+*   Redistributions of source code must retain the above copyright notice,
+    this list of conditions and the following disclaimer.
+
+*   Redistributions in binary form must reproduce the above copyright
+    notice, this list of conditions and the following disclaimer in the
+    documentation and/or other materials provided with the distribution.
+
+*   Neither the name of Marvell nor the names of its contributors may be
+    used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+   ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+   ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************
+
+* mv_prestera_smi.h
+*
+* DESCRIPTION:
+*       Includes defines and structures needed by the PP device driver
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+#ifndef __MV_PRESTERA_SMI
+#define __MV_PRESTERA_SMI
+
+#include <linux/semaphore.h>
+#include <linux/interrupt.h>
+#include "mv_prestera.h"
+
+int prestera_smi_init(void);
+int prestera_smi_ioctl(unsigned int, unsigned long);
+ssize_t prestera_smi_read(struct file *filp, char *buf, size_t count, loff_t *f_pos);
+ssize_t prestera_smi_write(struct file	*filp, const char *buf, size_t count, loff_t *f_pos);
+int prestera_smi_eth_port_rx_dsr_cnt(void);
+int prestera_smi_eth_port_tx_dsr_cnt(void);
+unsigned long prestera_smi_eth_port_tx_end_dsr(unsigned char*[], unsigned long);
+unsigned long prestera_smi_eth_port_rx_dsr(unsigned char*[], unsigned long[],
+					   unsigned long, unsigned long);
+#endif /* __MV_PRESTERA_SMI */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_smi_glob.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_smi_glob.h
new file mode 100644
index 0000000..270f098
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_prestera_smi_glob.h
@@ -0,0 +1,204 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+********************************************************************************
+   Marvell Commercial License Option
+
+   If you received this File from Marvell and you have entered into a commercial
+   license agreement (a "Commercial License") with Marvell, the File is licensed
+   to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+********************************************************************************
+   Marvell BSD License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File under the following licensing terms.
+   Redistribution and use in source and binary forms, with or without modification,
+   are permitted provided that the following conditions are met:
+
+*   Redistributions of source code must retain the above copyright notice,
+    this list of conditions and the following disclaimer.
+
+*   Redistributions in binary form must reproduce the above copyright
+    notice, this list of conditions and the following disclaimer in the
+    documentation and/or other materials provided with the distribution.
+
+*   Neither the name of Marvell nor the names of its contributors may be
+    used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+   ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+   ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************
+* presteraSmiGlob.h
+*
+* DESCRIPTION:
+*       This file includes the declaration of the struct we want to send to kernel mode,
+*       from user mode.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+#ifndef __PRESTERA_SMI_GLOB__
+#define __PRESTERA_SMI_GLOB__
+
+/************************ ethrnet port definitions ****************************/
+/* first 32 bit in Ethrnet Port FIFO (Rx and Tx) bits:                        */
+/*  0..6    - number of elements    (values of: 0..127)                       */
+/*  7..9    - queue number          (0..7)                                    */
+/*  10..30  - reserved                                                        */
+/*  31      - TxEnd or Rx flag      (0..1)                                    */
+#define ETH_PORT_FIFO_ELEM_CNT_MASK         0x0000007F
+#define ETH_PORT_FIFO_QUE_NUM_OFFSET        7
+#define ETH_PORT_FIFO_QUE_NUM_MASK          0x00000380
+#define ETH_PORT_FIFO_TYPE_RX_MASK          (1 << 31)
+#define MAX_SEG                             100
+
+#define GT_MAX_RX_QUEUE_CNS     8   /* maximum number of RX queues */
+
+struct SMI_REG {
+	unsigned long slvId;
+	unsigned long regAddr;
+	unsigned long value;
+};
+
+struct SMI_REG_RAM_STC {
+	unsigned long devSlvId;
+	unsigned long addr;
+	unsigned long *dataArr;
+	unsigned long arrLen;
+};
+
+struct SMI_REG_VEC_STC {
+	unsigned long devSlvId;
+	unsigned long   *addrArr;
+	unsigned long   *dataArr;
+	unsigned long arrLen;
+};
+
+struct write_smi_reg_field_STC {
+	unsigned long slvId;
+	unsigned long regAddr;
+	unsigned long mask;
+	unsigned long value;
+};
+
+struct RX_INIT_PARAM {
+	unsigned long rxBufPoolSize;
+	unsigned char *rxBufPoolPtr;
+	unsigned long rxBufSize;
+	unsigned long *numOfRxBufsPtr;
+	unsigned long headerOffset;
+	unsigned long rxQNum;
+	unsigned long rxQbufPercentage[GT_MAX_RX_QUEUE_CNS];
+};
+
+struct RX_FREE_BUF_PARAM {
+	unsigned long	numOfSegments;
+	unsigned long	queueNum;
+	unsigned char	*segmentList[MAX_SEG];
+};
+
+struct CPU_CODE_TO_QUEUE_PARAM {
+	unsigned long cpuCode;
+	unsigned char queue;
+};
+
+/*
+ * enum bspEthNetPortType_ENT
+ *
+ * Description:
+ *      This type defines types of switch ports for BSP ETH driver.
+ *
+ * Fields:
+ *      bspEthNetPortType_cpss_E   - packets forwarded to CPSS
+ *      bspEthNetPortType_raw_E    - packets forwarded to OS (without dsa removal)
+ *      bspEthNetPortType_linux_E  - packets forwarded to OS (with dsa removal)
+ *
+ * Note:
+ *      The enum has to be compatible with MV_NET_OWN and ap_packet.c
+ *
+ */
+enum bspEthNetPortType_ENT {
+	/* cpss = the packet is sent directly to cpss */
+	bspEthNetPortType_cpss_E    = 0,
+
+	/* raw = the packet is sent to the network stack WITHOUT removing the dsa */
+	bspEthNetPortType_raw_E    = 1,
+
+	/* linux = the packet is sent to the network stack AFTER removing the dsa */
+	bspEthNetPortType_linux_E    = 2,
+
+	bspEthNetPortType_numOfTypes
+} ;
+
+struct MUX_PARAM {
+	unsigned long			portNum;
+	enum bspEthNetPortType_ENT	portType;
+};
+
+
+ssize_t presteraSmi_read(struct file *filp, char *buf, size_t count, loff_t *f_pos);
+ssize_t presteraSmi_write(struct file *filp, const char *buf, size_t count, loff_t *f_pos);
+int presteraSmi_ioctl(unsigned int, unsigned long);
+int presteraSmi_init(void);
+
+
+
+/************************ IOCTLs ****************************/
+#define PRESTERA_SMI_IOC_MAGIC 's'
+#define PRESTERA_SMI_IOC_WRITEREG          _IOWR(PRESTERA_SMI_IOC_MAGIC, 0, struct SMI_REG)
+#define PRESTERA_SMI_IOC_READREG           _IOWR(PRESTERA_SMI_IOC_MAGIC, 1, struct SMI_REG)
+#define PRESTERA_SMI_IOC_WRITEREGDIRECT    _IOWR(PRESTERA_SMI_IOC_MAGIC, 2, struct SMI_REG)
+#define PRESTERA_SMI_IOC_READREGDIRECT     _IOWR(PRESTERA_SMI_IOC_MAGIC, 3, struct SMI_REG)
+#define PRESTERA_SMI_IOC_WRITEREGFIELD     _IOWR(PRESTERA_SMI_IOC_MAGIC, 7, struct write_smi_reg_field_STC)
+#define PRESTERA_SMI_IOC_READREGRAM        _IOWR(PRESTERA_SMI_IOC_MAGIC, 8, struct SMI_REG_RAM_STC)
+#define PRESTERA_SMI_IOC_WRITEREGRAM       _IOWR(PRESTERA_SMI_IOC_MAGIC, 9, struct SMI_REG_RAM_STC)
+#define PRESTERA_SMI_IOC_READREGVEC        _IOWR(PRESTERA_SMI_IOC_MAGIC, 10, struct SMI_REG_VEC_STC)
+#define PRESTERA_SMI_IOC_WRITEREGVEC       _IOWR(PRESTERA_SMI_IOC_MAGIC, 11, struct SMI_REG_VEC_STC)
+#define PRESTERA_SMI_IOC_ETHPORTENABLE     _IO(PRESTERA_SMI_IOC_MAGIC,   13)
+#define PRESTERA_SMI_IOC_ETHPORTDISABLE    _IO(PRESTERA_SMI_IOC_MAGIC,   14)
+#define PRESTERA_SMI_IOC_ETHPORTRXINIT     _IOWR(PRESTERA_SMI_IOC_MAGIC, 15, struct RX_INIT_PARAM)
+#define PRESTERA_SMI_IOC_ETHPORTTXINIT     _IOW(PRESTERA_SMI_IOC_MAGIC,  16, long)
+#define PRESTERA_SMI_IOC_ETHPORTFREEBUF    _IOW(PRESTERA_SMI_IOC_MAGIC,  17, struct RX_FREE_BUF_PARAM)
+#define PRESTERA_SMI_IOC_ETHPORTRXBIND     _IO(PRESTERA_SMI_IOC_MAGIC,   18)
+#define PRESTERA_SMI_IOC_ETHPORTTXBIND     _IO(PRESTERA_SMI_IOC_MAGIC,   19)
+#define PRESTERA_SMI_IOC_NETIF_WAIT                  _IO(PRESTERA_SMI_IOC_MAGIC,   20)
+#define PRESTERA_SMI_IOC_TXMODE_SET                  _IOW(PRESTERA_SMI_IOC_MAGIC,  21, long)
+#define PRESTERA_SMI_IOC_CPUCODE_TO_QUEUE  _IOW(PRESTERA_SMI_IOC_MAGIC,  22, long)
+#define PRESTERA_SMI_IOC_MUXSET            _IOW(PRESTERA_SMI_IOC_MAGIC,  23, long)
+#define PRESTERA_SMI_IOC_MUXGET            _IOW(PRESTERA_SMI_IOC_MAGIC,  24, long)
+
+#endif /* __PRESTERA_SMI_GLOB__ */
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_pss_api.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_pss_api.c
new file mode 100644
index 0000000..64f0546
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_pss_api.c
@@ -0,0 +1,1565 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+
+   This software file (the "File") is owned and distributed by Marvell
+   International Ltd. and/or its affiliates ("Marvell") under the following
+   alternative licensing terms.  Once you have made an election to distribute the
+   File under one of the following license alternatives, please (i) delete this
+   introductory statement regarding license alternatives, (ii) delete the two
+   license alternatives that you have not elected to use and (iii) preserve the
+   Marvell copyright notice above.
+
+********************************************************************************
+   Marvell Commercial License Option
+
+   If you received this File from Marvell and you have entered into a commercial
+   license agreement (a "Commercial License") with Marvell, the File is licensed
+   to you under the terms of the applicable Commercial License.
+
+********************************************************************************
+   Marvell GPL License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File in accordance with the terms and conditions of the General
+   Public License Version 2, June 1991 (the "GPL License"), a copy of which is
+   available along with the File in the license.txt file or by writing to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 or
+   on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+
+   THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
+   DISCLAIMED.  The GPL License provides additional details about this warranty
+   disclaimer.
+********************************************************************************
+   Marvell BSD License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File under the following licensing terms.
+   Redistribution and use in source and binary forms, with or without modification,
+   are permitted provided that the following conditions are met:
+
+*   Redistributions of source code must retain the above copyright notice,
+    this list of conditions and the following disclaimer.
+
+*   Redistributions in binary form must reproduce the above copyright
+    notice, this list of conditions and the following disclaimer in the
+    documentation and/or other materials provided with the distribution.
+
+*   Neither the name of Marvell nor the names of its contributors may be
+    used to endorse or promote products derived from this software without
+    specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+   ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+   ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************/
+
+/*******************************************************************************
+* pssBspApis.c - bsp APIs
+*
+* DESCRIPTION:
+*       API's supported by BSP.
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/reboot.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/sysctl.h>
+
+#include "mvTypes.h"
+#include "mvOs.h"
+#include "mv_pss_api.h"
+#include "eth-phy/mvEthPhy.h"
+#include "cpu/mvCpu.h"
+
+/* Defines */
+
+static inline void smiWaitForStatus(unsigned long devSlvId)
+{
+#ifdef SMI_WAIT_FOR_STATUS_DONE
+	unsigned long stat;
+	unsigned int timeOut;
+	int rc;
+
+	/* wait for write done */
+	timeOut = SMI_TIMEOUT_COUNTER;
+	do {
+		rc = smiReadReg(devSlvId, SMI_STATUS_REGISTER, &stat);
+		if (rc != MV_OK)
+			return;
+		if (--timeOut < 1)
+			return;
+	} while ((stat & SMI_STATUS_WRITE_DONE) == 0);
+#endif
+}
+
+#define  SMI_WRITE_ADDRESS_MSB_REGISTER	(0x00)
+#define  SMI_WRITE_ADDRESS_LSB_REGISTER	(0x01)
+#define  SMI_WRITE_DATA_MSB_REGISTER	(0x02)
+#define  SMI_WRITE_DATA_LSB_REGISTER	(0x03)
+
+#define  SMI_READ_ADDRESS_MSB_REGISTER	(0x04)
+#define  SMI_READ_ADDRESS_LSB_REGISTER	(0x05)
+#define  SMI_READ_DATA_MSB_REGISTER	(0x06)
+#define  SMI_READ_DATA_LSB_REGISTER	(0x07)
+
+#define  SMI_STATUS_REGISTER		(0x1f)
+
+#define SMI_STATUS_WRITE_DONE		(0x02)
+#define SMI_STATUS_READ_READY		(0x01)
+
+#define SMI_WAIT_FOR_STATUS_DONE
+#define SMI_TIMEOUT_COUNTER		10000
+
+#define STUB_FAIL do { mvOsPrintf(KERN_INFO "stub function %s returning MV_NOT_SUPPORTED\n", __func__);\
+		return MV_NOT_SUPPORTED; } while (1)
+
+#define STUB_FAIL_NULL do { mvOsPrintf(KERN_INFO "stub function %s returning MV_NOT_SUPPORTED\n", __func__);	\
+		return NULL; } while (1)
+
+#define STUB_OK do {   mvOsPrintf(KERN_INFO "stub function %s returning MV_OK\n", __func__);	\
+		return MV_OK; } while (1)
+
+#define STUB_TBD do { mvOsPrintf(KERN_INFO "stub function TBD %s returning MV_FAIL\n", __func__); \
+		return MV_FAIL; } while (1)
+
+static inline struct pci_dev *find_bdf(u32 bus, u32 device, u32 func)
+{
+	return pci_get_bus_and_slot(bus, PCI_DEVFN(device, func));
+}
+
+
+/* interrupt routine pointer */
+static MV_VOIDFUNCPTR bspIsrRoutine = (MV_VOIDFUNCPTR)-1;
+static unsigned long bspIsrParameter = -1;
+
+/*** reset ***/
+/*******************************************************************************
+* bspResetInit
+*
+* DESCRIPTION:
+*       This routine calls in init to do system init config for reset.
+*
+* INPUTS:
+*       none.
+*
+* OUTPUTS:
+*       none.
+*
+* RETURNS:
+*       MV_OK      - on success.
+*       MV_FAIL    - otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS bspResetInit(MV_VOID)
+{
+	return MV_OK;
+}
+
+/*******************************************************************************
+* bspReset
+*
+* DESCRIPTION:
+*       This routine calls to reset of CPU.
+*
+* INPUTS:
+*       none.
+*
+* OUTPUTS:
+*       none.
+*
+* RETURNS:
+*       MV_OK      - on success.
+*       MV_FAIL    - otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS bspReset(MV_VOID)
+{
+	kernel_restart(NULL);
+	return MV_OK;
+}
+
+/*** cache ***/
+/*******************************************************************************
+* bspCacheFlush
+*
+* DESCRIPTION:
+*       Flush to RAM content of cache
+*
+* INPUTS:
+*       type        - type of cache memory data/intraction
+*       address_PTR - starting address of memory block to flush
+*       size        - size of memory block
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK   - on success,
+*       MV_FAIL - othersise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS bspCacheFlush(enum bspCacheType	cacheType,
+			void			*address_PTR,
+			size_t			size)
+{
+	switch (cacheType) {
+	case bspCacheType_InstructionCache_E:
+		return MV_BAD_PARAM; /* only data cache supported */
+
+	case bspCacheType_DataCache_E:
+		break;
+
+	default:
+		return MV_BAD_PARAM;
+	}
+
+	/* our area doesn't need cache flush/invalidate	*/
+	return MV_OK;
+}
+
+/*******************************************************************************
+* bspCacheInvalidate
+*
+* DESCRIPTION:
+*       Invalidate current content of cache
+*
+* INPUTS:
+*       type        - type of cache memory data/intraction
+*       address_PTR - starting address of memory block to flush
+*       size        - size of memory block
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK   - on success,
+*       MV_FAIL - othersise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS bspCacheInvalidate(enum bspCacheType	cacheType,
+			     void			*address_PTR,
+			     size_t		size)
+{
+	switch (cacheType) {
+	case bspCacheType_InstructionCache_E:
+		return MV_BAD_PARAM; /* only data cache supported */
+
+	case bspCacheType_DataCache_E:
+		break;
+
+	default:
+		return MV_BAD_PARAM;
+	}
+
+	/* our area doesn't need cache flush/invalidate */
+	return MV_OK;
+}
+
+/*** DMA ***/
+/*******************************************************************************
+* bspDmaWrite
+*
+* DESCRIPTION:
+*       Write a given buffer to the given address using the Dma.
+*
+* INPUTS:
+*       address     - The destination address to write to.
+*       buffer      - The buffer to be written.
+*       length      - Length of buffer in words.
+*       burstLimit  - Number of words to be written on each burst.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK   - on success,
+*       MV_FAIL - othersise.
+*
+* COMMENTS:
+*       1.  The given buffer is allways 4 bytes aligned, any further allignment
+*           requirements should be handled internally by this function.
+*       2.  The given buffer may be allocated from an uncached memory space, and
+*           it's to the function to handle the cache flushing.
+*       3.  The Prestera Driver assumes that the implementation of the DMA is
+*           blocking, otherwise the Driver functionality might be damaged.
+*
+*******************************************************************************/
+MV_STATUS bspDmaWrite(unsigned long address,
+		      unsigned long  *buffer,
+		      unsigned long length,
+		      unsigned long burstLimit)
+{
+	STUB_FAIL;
+}
+
+/*******************************************************************************
+* bspDmaRead
+*
+* DESCRIPTION:
+*       Read a memory block from a given address.
+*
+* INPUTS:
+*       address     - The address to read from.
+*       length      - Length of the memory block to read (in words).
+*       burstLimit  - Number of words to be read on each burst.
+*
+* OUTPUTS:
+*       buffer  - The read data.
+*
+* RETURNS:
+*       MV_OK   - on success,
+*       MV_FAIL - othersise.
+*
+* COMMENTS:
+*       1.  The given buffer is allways 4 bytes aligned, any further allignment
+*           requirements should be handled internally by this function.
+*       2.  The given buffer may be allocated from an uncached memory space, and
+*           it's to the function to handle the cache flushing.
+*       3.  The Prestera Driver assumes that the implementation of the DMA is
+*           blocking, otherwise the Driver functionality might be damaged.
+*
+*******************************************************************************/
+MV_STATUS bspDmaRead(unsigned long address,
+		     unsigned long length,
+		     unsigned long burstLimit,
+		     unsigned long  *buffer)
+{
+	STUB_FAIL;
+}
+
+/*******************************************************************************
+* bspCacheDmaMalloc
+*
+* DESCRIPTION:
+*       Allocate a cache free area for DMA devices.
+*
+* INPUTS:
+*       size_t bytes - number of bytes to allocate
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       pointer to allocated data per success
+*       NULL - per failure to allocate space
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+static unsigned long dma_base = -1;
+static void *dma_area_base = (void *)-1;
+
+void *bspCacheDmaMalloc(size_t bytes)
+{
+	unsigned long dma_len = bytes;
+	void *dma_area;
+
+	if (dma_base == -1)
+		dma_base = __pa(high_memory);
+
+	request_mem_region(dma_base, dma_len, "prestera-dma");
+	dma_area = (unsigned long *)ioremap_nocache(dma_base, dma_len);
+
+	if (dma_area_base == (void *)-1)
+		dma_area_base = dma_area;
+
+	return dma_area;
+}
+
+/*******************************************************************************
+* bspCacheDmaFree
+*
+* DESCRIPTION:
+*       free a cache free area back to pool.
+*
+* INPUTS:
+*       size_t bytes - number of bytes to allocate
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK   - on success
+*       MV_FAIL - on error
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS bspCacheDmaFree(void *pBuf)
+{
+	STUB_FAIL;
+}
+
+/*** PCI ***/
+/*******************************************************************************
+* bspPciConfigWriteReg
+*
+* DESCRIPTION:
+*       This routine write register to the PCI configuration space.
+*
+* INPUTS:
+*       busNo    - PCI bus number.
+*       devSel   - the device devSel.
+*       funcNo   - function number.
+*       regAddr  - Register offset in the configuration space.
+*       data     - data to write.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK   - on success,
+*       MV_FAIL - othersise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS bspPciConfigWriteReg(unsigned long busNo,
+			       unsigned long devSel,
+			       unsigned long funcNo,
+			       unsigned long regAddr,
+			       unsigned long data)
+{
+	struct pci_dev *dev;
+
+	dev = find_bdf(busNo, devSel, funcNo);
+	if (dev) {
+		pci_write_config_dword(dev, regAddr, data);
+		pci_dev_put(dev);
+		return MV_OK;
+	} else
+		return MV_FAIL;
+}
+
+/*******************************************************************************
+* bspPciConfigReadReg
+*
+* DESCRIPTION:
+*       This routine read register from the PCI configuration space.
+*
+* INPUTS:
+*       busNo    - PCI bus number.
+*       devSel   - the device devSel.
+*       funcNo   - function number.
+*       regAddr  - Register offset in the configuration space.
+*
+* OUTPUTS:
+*       data     - the read data.
+*
+* RETURNS:
+*       MV_OK   - on success,
+*       MV_FAIL - othersise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS bspPciConfigReadReg(unsigned long	busNo,
+			      unsigned long	devSel,
+			      unsigned long	funcNo,
+			      unsigned long	regAddr,
+			      unsigned long	*data)
+{
+	struct pci_dev *dev;
+
+	dev = find_bdf(busNo, devSel, funcNo);
+	if (dev) {
+		pci_read_config_dword(dev, (int)regAddr, (unsigned int *)data);
+		pci_dev_put(dev);
+		return MV_OK;
+	} else
+		return MV_FAIL;
+}
+
+/*******************************************************************************
+* bspPciGetResourceStart
+*
+* DESCRIPTION:
+*       This routine performs pci_resource_start.
+*       In INTEL64 this function must be used instead of reading the bar
+*       directly.
+*
+* INPUTS:
+*       busNo    - PCI bus number.
+*       devSel   - the device devSel.
+*       funcNo   - function number.
+*       barNo    - Bar Number.
+*
+* OUTPUTS:
+*       ResourceStart - the address of the resource.
+*
+* RETURNS:
+*       MV_OK   - on success,
+*       MV_FAIL - othersise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS bspPciGetResourceStart(unsigned long		busNo,
+				 unsigned long		devSel,
+				 unsigned long		funcNo,
+				 unsigned long		barNo,
+				 unsigned long long	*resourceStart)
+{
+	struct pci_dev *dev;
+
+	dev = find_bdf(busNo, devSel, funcNo);
+	if (dev) {
+		*resourceStart = pci_resource_start(dev, barNo);
+		pci_dev_put(dev);
+		return MV_OK;
+	}
+	return MV_FAIL;
+}
+
+/*******************************************************************************
+* bspPciGetResourceLen
+*
+* DESCRIPTION:
+*       This routine performs pci_resource_len.
+*       In INTEL64 this function must be used instead of reading the bar
+*       directly.
+*
+* INPUTS:
+*       busNo    - PCI bus number.
+*       devSel   - the device devSel.
+*       funcNo   - function number.
+*       barNo    - Bar Number.
+*
+* OUTPUTS:
+*       ResourceLen - the address of the resource.
+*
+* RETURNS:
+*       MV_OK   - on success,
+*       MV_FAIL - othersise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS bspPciGetResourceLen(unsigned long		busNo,
+			       unsigned long		devSel,
+			       unsigned long		funcNo,
+			       unsigned long		barNo,
+			       unsigned long long	*resourceLen)
+{
+	struct pci_dev *dev;
+
+	dev = find_bdf(busNo, devSel, funcNo);
+	if (dev) {
+		*resourceLen = pci_resource_len(dev, barNo);
+		pci_dev_put(dev);
+		return MV_OK;
+	}
+	return MV_FAIL;
+}
+
+/*******************************************************************************
+* bspPciFindDev
+*
+* DESCRIPTION:
+*       This routine returns the next instance of the given device (defined by
+*       vendorId & devId).
+*
+* INPUTS:
+*       vendorId - The device vendor Id.
+*       devId    - The device Id.
+*       instance - The requested device instance.
+*
+* OUTPUTS:
+*       busNo    - PCI bus number.
+*       devSel   - the device devSel.
+*       funcNo   - function number.
+*
+* RETURNS:
+*       MV_OK   - on success,
+*       MV_FAIL - othersise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int bspPciFindDev(unsigned short	vendorId,
+		  unsigned short	devId,
+		  unsigned long		instance,
+		  unsigned long		*busNo,
+		  unsigned long		*devSel,
+		  unsigned long		*funcNo)
+{
+	struct pci_dev *dev = NULL;
+	int count = 0;
+
+	*busNo = *devSel = *funcNo = 0;
+
+	for_each_pci_dev(dev) {
+		if ((vendorId == 0xffff || dev->vendor == vendorId) &&
+		    (devId == 0xffff || dev->device == devId) &&
+		    /* skip the virtual bridge : 11ab8888 */
+		    (!((vendorId == MARVELL_VEN_ID) && (dev->device == 0x8888))) &&
+		    (count++ == instance)) {
+			*busNo = dev->bus->number;
+			*devSel = PCI_SLOT(dev->devfn);
+			*funcNo = PCI_FUNC(dev->devfn);
+			return MV_OK;
+		}
+	}
+
+	return MV_FAIL;
+}
+
+/*******************************************************************************
+* bspPciGetIntVec
+*
+* DESCRIPTION:
+*       This routine return the PCI interrupt vector.
+*
+* INPUTS:
+*       pciInt - PCI interrupt number.
+*
+* OUTPUTS:
+*       intVec - PCI interrupt vector.
+*
+* RETURNS:
+*       MV_OK      - on success.
+*       MV_FAIL    - otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS bspPciGetIntVec(enum bspPciInt_PCI_INT	pciInt,
+			  void				**intVec)
+{
+	MV_STATUS rc = MV_OK;
+
+	*intVec = (void *)(unsigned long)(IRQ_AURORA_SW_CORE0);
+	return rc;
+}
+
+/*******************************************************************************
+* bspPciGetIntMask
+*
+* DESCRIPTION:
+*       This routine return the PCI interrupt vector.
+*
+* INPUTS:
+*       pciInt - PCI interrupt number.
+*
+* OUTPUTS:
+*       intMask - PCI interrupt mask.
+*
+* RETURNS:
+*       MV_OK      - on success.
+*       MV_FAIL    - otherwise.
+*
+* COMMENTS:
+*       PCI interrupt mask should be used for interrupt disable/enable.
+*
+*******************************************************************************/
+MV_STATUS bspPciGetIntMask(enum bspPciInt_PCI_INT	pciInt,
+			   unsigned long		*intMask)
+{
+	return MV_OK;
+}
+
+/*******************************************************************************
+* bspPciEnableCombinedAccess
+*
+* DESCRIPTION:
+*       This function enables / disables the Pci writes / reads combining
+*       feature.
+*       Some system controllers support combining memory writes / reads. When a
+*       long burst write / read is required and combining is enabled, the master
+*       combines consecutive write / read transactions, if possible, and
+*       performs one burst on the Pci instead of two. (see comments)
+*
+* INPUTS:
+*       enWrCombine - MV_TRUE enables write requests combining.
+*       enRdCombine - MV_TRUE enables read requests combining.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK               - on sucess,
+*       MV_NOT_SUPPORTED    - if the controller does not support this feature,
+*       MV_FAIL             - otherwise.
+*
+* COMMENTS:
+*       1.  Example for combined write scenario:
+*           The controller is required to write a 32-bit data to address 0x8000,
+*           while this transaction is still in progress, a request for a write
+*           operation to address 0x8004 arrives, in this case the two writes are
+*           combined into a single burst of 8-bytes.
+*
+*******************************************************************************/
+MV_STATUS bspPciEnableCombinedAccess(MV_BOOL enWrCombine,
+				     MV_BOOL enRdCombine)
+{
+	STUB_FAIL;
+}
+
+/*******************************************************************************
+* bspEthInit
+*
+* DESCRIPTION: Init the ethernet HW and HAL
+*
+* INPUTS:
+*       port   - eth port number
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK if successful, or
+*       MV_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS bspEthInit(unsigned char port)
+{
+	STUB_OK;
+}
+
+/*******************************************************************************
+* bspSmiInitDriver
+*
+* DESCRIPTION:
+*       Init the TWSI interface
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       smiAccessMode - direct/indirect mode
+*
+* RETURNS:
+*       MV_OK               - on success
+*       MV_FAIL   - on hardware error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS bspSmiInitDriver(enum bspSmiAccessMode  *smiAccessMode)
+{
+	STUB_FAIL;
+}
+
+
+static inline MV_STATUS ethPhyRegRead(unsigned long phyAddr, unsigned long regOffs, MV_U16 *data)
+{
+	return mvEthPhyRegRead(phyAddr, regOffs, data);
+}
+
+static inline MV_STATUS ethPhyRegWrite(unsigned long phyAddr, unsigned long regOffs, MV_U16 data)
+{
+	return mvEthPhyRegWrite(phyAddr, regOffs, data);
+}
+
+MV_STATUS smiReadReg(unsigned long devSlvId, unsigned long regAddr, unsigned long *value)
+{
+	MV_STATUS ret;
+	MV_U16 temp1;
+
+	ret = ethPhyRegRead(devSlvId, regAddr, &temp1);
+	*value = temp1;
+	return (MV_OK == ret) ? MV_OK : MV_FAIL;
+}
+
+MV_STATUS smiWriteReg(unsigned long devSlvId, unsigned long regAddr, unsigned long value)
+{
+	/* Perform direct smi write reg */
+	MV_STATUS ret;
+
+	ret = ethPhyRegWrite(devSlvId, regAddr, value);
+	return (MV_OK == ret) ? MV_OK : MV_FAIL;
+}
+
+/*******************************************************************************
+* bspSmiReadReg
+*
+* DESCRIPTION:
+*       Reads a register from SMI slave.
+*
+* INPUTS:
+*       devSlvId - Slave Device ID
+*      actSmiAddr - actual smi addr to use (relevant for SX PPs)
+*       regAddr - Register address to read from.
+*
+* OUTPUTS:
+*       valuePtr     - Data read from register.
+*
+* RETURNS:
+*       MV_OK               - on success
+*       MV_ERROR   - on hardware error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS bspSmiReadReg(unsigned long devSlvId,
+			unsigned long actSmiAddr,
+			unsigned long regAddr,
+			unsigned long *valuePtr)
+{
+	/* Perform indirect smi read reg */
+	int		rc;
+	unsigned long	msb;
+	unsigned long	lsb;
+
+	static int first_time = 1;
+
+	if (first_time) {
+		enum bspSmiAccessMode smiAccessMode;
+		first_time = 0;
+		bspSmiInitDriver(&smiAccessMode);
+	}
+
+	/* write addr to read */
+	msb = regAddr >> 16;
+	lsb = regAddr & 0xFFFF;
+	rc = smiWriteReg(devSlvId, SMI_READ_ADDRESS_MSB_REGISTER, msb);
+	if (rc != MV_OK)
+		return rc;
+
+	rc = smiWriteReg(devSlvId, SMI_READ_ADDRESS_LSB_REGISTER, lsb);
+	if (rc != MV_OK)
+		return rc;
+
+	smiWaitForStatus(devSlvId);
+
+	/* read data */
+	rc = smiReadReg(devSlvId, SMI_READ_DATA_MSB_REGISTER, &msb);
+	if (rc != MV_OK)
+		return rc;
+
+	rc = smiReadReg(devSlvId, SMI_READ_DATA_LSB_REGISTER, &lsb);
+	if (rc != MV_OK)
+		return rc;
+
+	*valuePtr = ((msb & 0xFFFF) << 16) | (lsb & 0xFFFF);
+	return 0;
+}
+
+/*******************************************************************************
+* bspSmiWriteReg
+*
+* DESCRIPTION:
+*       Writes a register to an SMI slave.
+*
+* INPUTS:
+*       devSlvId - Slave Device ID
+*       actSmiAddr - actual smi addr to use (relevant for SX PPs)
+*       regAddr - Register address to read from.
+*       value   - data to be written.
+*
+* OUTPUTS:
+*        None,
+*
+* RETURNS:
+*       MV_OK               - on success
+*       MV_ERROR   - on hardware error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS bspSmiWriteReg(unsigned long devSlvId,
+			 unsigned long actSmiAddr,
+			 unsigned long regAddr,
+			 unsigned long value)
+{
+	/* Perform indirect smi write reg */
+	int rc;
+	unsigned long msb;
+	unsigned long lsb;
+
+	/* write addr to read */
+	msb = regAddr >> 16;
+	lsb = regAddr & 0xFFFF;
+	rc = smiWriteReg(devSlvId, SMI_READ_ADDRESS_MSB_REGISTER, msb);
+	if (rc != 0)
+		return rc;
+
+	rc = smiWriteReg(devSlvId, SMI_READ_ADDRESS_LSB_REGISTER, lsb);
+	if (rc != 0)
+		return rc;
+
+	/* write data to write */
+	msb = value >> 16;
+	lsb = value & 0xFFFF;
+	rc = smiWriteReg(devSlvId, SMI_WRITE_DATA_MSB_REGISTER, msb);
+	if (rc != MV_OK)
+		return rc;
+
+	rc = smiWriteReg(devSlvId, SMI_WRITE_DATA_LSB_REGISTER, lsb);
+	if (rc != MV_OK)
+		return rc;
+
+	smiWaitForStatus(devSlvId);
+
+	return MV_OK;
+}
+
+
+/*** TWSI ***/
+/*******************************************************************************
+* bspTwsiInitDriver
+*
+* DESCRIPTION:
+*       Init the TWSI interface
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK               - on success
+*       MV_ERROR   - on hardware error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS bspTwsiInitDriver(MV_VOID)
+{
+	STUB_FAIL;
+}
+
+/*******************************************************************************
+* bspTwsiWaitNotBusy
+*
+* DESCRIPTION:
+*       Wait for TWSI interface not BUSY
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK               - on success
+*       MV_ERROR   - on hardware error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS bspTwsiWaitNotBusy(MV_VOID)
+{
+	STUB_FAIL;
+}
+
+/*******************************************************************************
+* bspTwsiMasterReadTrans
+*
+* DESCRIPTION:
+*       do TWSI interface Transaction
+*
+* INPUTS:
+*    devId - I2c slave ID
+*    pData - Pointer to array of chars (address / data)
+*    len   - pData array size (in chars).
+*    stop  - Indicates if stop bit is needed.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK               - on success
+*       MV_ERROR   - on hardware error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS bspTwsiMasterReadTrans(unsigned char	devId,
+				 unsigned char	*pData,
+				 unsigned char	len,
+				 MV_BOOL	stop)
+{
+	STUB_FAIL;
+}
+
+/*******************************************************************************
+* bspTwsiMasterWriteTrans
+*
+* DESCRIPTION:
+*       do TWSI interface Transaction
+*
+* INPUTS:
+*    devId - I2c slave ID
+*    pData - Pointer to array of chars (address / data)
+*    len   - pData array size (in chars).
+*    stop  - Indicates if stop bit is needed.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK               - on success
+*       MV_ERROR   - on hardware error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS bspTwsiMasterWriteTrans(unsigned char	devId,
+				  unsigned char	*pData,
+				  unsigned char	len,
+				  MV_BOOL	stop)
+{
+	STUB_FAIL;
+}
+
+/*******************************************************************************
+* bspIsr
+*
+* DESCRIPTION:
+*       This is the ISR reponsible for PP.
+*
+* INPUTS:
+*       irq     - the Interrupt ReQuest number
+*       dev_id  - the client data used as argument to the handler
+*       regs    - holds a snapshot of the CPU context before interrupt
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       IRQ_HANDLED allways
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+static irqreturn_t bspIsr(int			irq,
+			  void			*dev_id,
+			  struct pt_regs	*regs)
+{
+	if (bspIsrRoutine != (MV_VOIDFUNCPTR)-1)
+		bspIsrRoutine();
+
+	return IRQ_HANDLED;
+}
+
+/*******************************************************************************
+* bspIntConnect
+*
+* DESCRIPTION:
+*       Connect a specified C routine to a specified interrupt vector.
+*
+* INPUTS:
+*       vector    - interrupt vector number to attach to
+*       routine   - routine to be called
+*       parameter - parameter to be passed to routine
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       MV_OK   - on success
+*       MV_FAIL - on error
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS bspIntConnect(unsigned long vector,
+			MV_VOIDFUNCPTR routine,
+			unsigned long parameter)
+{
+	int rc;
+
+	bspIsrParameter = parameter;
+	bspIsrRoutine   = routine;
+
+	rc = request_irq(vector,
+			(irq_handler_t)bspIsr,
+			IRQF_DISABLED, "PP_interrupt", (void *)&bspIsrParameter);
+
+	return (0 == rc) ? MV_OK : MV_FAIL;
+
+}
+
+/*******************************************************************************
+* extDrvIntEnable
+*
+* DESCRIPTION:
+*       Enable corresponding interrupt bits
+*
+* INPUTS:
+*       intMask - new interrupt bits
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK   - on success
+*       MV_FAIL - on error
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS bspIntEnable(unsigned long intMask)
+{
+	enable_irq(intMask);
+	return MV_OK;
+}
+
+/*******************************************************************************
+* bspIntDisable
+*
+* DESCRIPTION:
+*       Disable corresponding interrupt bits.
+*
+* INPUTS:
+*       intMask - new interrupt bits
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK   - on success
+*       MV_FAIL - on error
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+MV_STATUS bspIntDisable(unsigned long intMask)
+{
+	disable_irq(intMask);
+	return MV_OK;
+}
+
+unsigned long  bspVirt2Phys(unsigned long vAddr)
+{
+	if (!dma_area_base)
+		bspCacheDmaMalloc(1024);
+
+	if (vAddr ==  (unsigned long)dma_area_base) /* bspCacheDmaMalloc  is done once ! */
+		return dma_base;
+	else
+		return (unsigned long)__pa(vAddr);
+}
+
+unsigned long bspPhys2Virt(unsigned long pAddr)
+{
+	STUB_FAIL;
+}
+
+/*** Ethernet access MII with the Packet Processor ***/
+/*******************************************************************************
+* bspEthPortRxInit
+*
+* DESCRIPTION: Init the ethernet port Rx interface
+*
+* INPUTS:
+*       rxBufPoolSize   - buffer pool size
+*       rxBufPool_PTR   - the address of the pool
+*       rxBufSize       - the buffer requested size
+*       numOfRxBufs_PTR - number of requested buffers, and actual buffers created
+*       headerOffset    - packet header offset size
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK if successful, or
+*       MV_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS bspEthPortRxInit(unsigned long	rxBufPoolSize,
+			   unsigned char	*rxBufPool_PTR,
+			   unsigned long	rxBufSize,
+			   unsigned long	*numOfRxBufs_PTR,
+			   unsigned long	headerOffset,
+			   unsigned long	rxQNum,
+			   unsigned long	rxQbufPercentage[])
+{
+	STUB_FAIL;
+}
+
+/*******************************************************************************
+* bspEthPortTxInit
+*
+* DESCRIPTION: Init the ethernet port Tx interface
+*
+* INPUTS:
+*       numOfTxBufs - number of requested buffers
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK if successful, or
+*       MV_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS bspEthPortTxInit(unsigned long numOfTxBufs)
+{
+	STUB_FAIL;
+}
+
+/*******************************************************************************
+* bspEthPortEnable
+*
+* DESCRIPTION: Enable the ethernet port interface
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK if successful, or
+*       MV_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS bspEthPortEnable(MV_VOID)
+{
+	STUB_FAIL;
+}
+
+/*******************************************************************************
+* bspEthPortDisable
+*
+* DESCRIPTION: Disable the ethernet port interface
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK if successful, or
+*       MV_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS bspEthPortDisable(MV_VOID)
+{
+	STUB_FAIL;
+}
+
+/*******************************************************************************
+* bspEthInputHookAdd
+*
+* DESCRIPTION:
+*       This bind the user Rx callback
+*
+* INPUTS:
+*       userRxFunc - the user Rx callback function
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK if successful, or
+*       MV_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS bspEthInputHookAdd(BSP_RX_CALLBACK_FUNCPTR userRxFunc)
+{
+	STUB_FAIL;
+}
+
+/*******************************************************************************
+* bspEthPortTx
+*
+* DESCRIPTION:
+*       This function is called after a TxEnd event has been received, it passes
+*       the needed information to the Tapi part.
+*
+* INPUTS:
+*       segmentsList     - A list of pointers to the packets segments.
+*       segmentsLen      - A list of segment length.
+*       numOfSegments   - The number of segment in segment list.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK if successful, or
+*       MV_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS bspEthPortTx(unsigned char	*segmentsList[],
+		       unsigned long	segmentsLen[],
+		       unsigned long	numOfSegments)
+{
+	STUB_FAIL;
+}
+
+/*******************************************************************************
+* bspEthPortTxModeSet
+*
+* DESCRIPTION: Set the ethernet port tx mode
+*
+* INPUTS:
+*       if txMode == bspEthTxMode_asynch_E -- don't wait for TX done - free packet when interrupt received
+*       if txMode == bspEthTxMode_synch_E  -- wait to TX done and free packet immediately
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK if successful
+*       MV_NOT_SUPPORTED if input is wrong
+*       MV_FAIL if bspTxModeSetOn is zero
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS bspEthPortTxModeSet(void *stub)
+{
+	STUB_OK;
+}
+
+/*******************************************************************************
+* bspEthPortTxQueue
+*
+* DESCRIPTION:
+*       This function is called after a TxEnd event has been received, it passes
+*       the needed information to the Tapi part.
+*
+* INPUTS:
+*       segmentList     - A list of pointers to the packets segments.
+*       segmentLen      - A list of segment length.
+*       numOfSegments   - The number of segment in segment list.
+*       txQueue         - The TX queue.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK if successful, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS bspEthPortTxQueue(unsigned char	*segmentList[],
+			    unsigned long	segmentLen[],
+			    unsigned long	numOfSegments,
+			    unsigned long	txQueue)
+{
+	return bspEthPortTx(segmentList, segmentLen, numOfSegments);
+}
+
+/*******************************************************************************
+* bspEthTxCompleteHookAdd
+*
+* DESCRIPTION:
+*       This bind the user Tx complete callback
+*
+* INPUTS:
+*       userTxFunc - the user Tx callback function
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK if successful, or
+*       MV_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS bspEthTxCompleteHookAdd(BSP_TX_COMPLETE_CALLBACK_FUNCPTR userTxFunc)
+{
+	STUB_FAIL;
+}
+
+/*******************************************************************************
+* bspEthRxPacketFree
+*
+* DESCRIPTION:
+*       This routine frees the received Rx buffer.
+*
+* INPUTS:
+*       segmentsList     - A list of pointers to the packets segments.
+*       numOfSegments   - The number of segment in segment list.
+*       queueNum        - Receive queue number
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK if successful, or
+*       MV_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS bspEthRxPacketFree(unsigned char	*segmentsList[],
+			     unsigned long	numOfSegments,
+			     unsigned long	queueNum)
+{
+	STUB_FAIL;
+}
+
+/*******************************************************************************
+* bspEthCpuCodeToQueue
+*
+* DESCRIPTION:
+*       Binds DSA CPU code to RX queue.
+*
+* INPUTS:
+*       dsaCpuCode - DSA CPU code
+*       rxQueue    -  rx queue
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK if successful, or
+*       MV_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS bspEthCpuCodeToQueue(unsigned long dsaCpuCode,
+			       unsigned char rxQueue)
+{
+	STUB_OK;
+}
+
+/*******************************************************************************
+* bspPciFindDevReset
+*
+* DESCRIPTION:
+*       Reset gPPDevId to make chance to find internal PP again
+*
+* INPUTS:
+*       None
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       MV_OK   - on success,
+*
+* COMMENTS:
+*
+*******************************************************************************/
+MV_STATUS bspPciFindDevReset(void)
+{
+	STUB_OK;
+}
+
+
+/*******************************************************************************
+* bspWarmRestart
+*
+* DESCRIPTION:
+*       This routine performs warm restart.
+*
+* INPUTS:
+*       none.
+*
+* OUTPUTS:
+*       none.
+*
+* RETURNS:
+*       MV_OK      - on success.
+*       MV_FAIL    - otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+MV_STATUS bspWarmRestart(MV_VOID)
+{
+	STUB_FAIL;
+}
+
+
+int bspSmiScan(int instance, int noisy)
+{
+	int found1 = 0;
+	int found2 = 0;
+	int i;
+	unsigned long data;
+
+	/* scan for SMI devices */
+	for (i = 0; i < 32; i++) {
+		bspSmiReadReg(i, 0, 0x3, &data);
+		if (data == 0xffffffff || data == 0xffff)
+			continue;
+
+		bspSmiReadReg(i, 0, 0x50, &data);
+		if (data != 0x000011ab  && data != 0xab110000)
+			continue;
+
+		if (instance == found1++) {
+			bspSmiReadReg(i, 0, 0x4c, &data);
+			mvOsPrintf(KERN_INFO "Smi Scan found Marvell device at smi_addr 0x%x, reg 0x4c=0x%luX\n",
+				   i, data);
+			found2 = 1;
+			break;
+		}
+	}
+
+	if (!found2) {
+		if (noisy)
+			mvOsPrintf(KERN_INFO "Smi scan found no device\n");
+		return -1;
+	}
+
+	return i;
+}
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_pss_api.h b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_pss_api.h
new file mode 100644
index 0000000..e18b2db
--- /dev/null
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_prestera/mv_pss_api.h
@@ -0,0 +1,1189 @@
+/*******************************************************************************
+   Copyright (C) Marvell International Ltd. and its affiliates
+*******************************************************************************
+   Marvell BSD License Option
+
+   If you received this File from Marvell, you may opt to use, redistribute and/or
+   modify this File under the following licensing terms.
+   Redistribution and use in source and binary forms, with or without modification,
+   are permitted provided that the following conditions are met:
+
+*   Redistributions of source code must retain the above copyright notice,
+	this list of conditions and the following disclaimer.
+
+*   Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+
+*   Neither the name of Marvell nor the names of its contributors may be
+	used to endorse or promote products derived from this software without
+	specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+   ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+   ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+*******************************************************************************
+* pssBspApis.h - bsp APIs
+*
+* DESCRIPTION:
+*       Enable managment of cache memory
+*
+* DEPENDENCIES:
+*       None.
+*
+*******************************************************************************/
+
+#ifndef __MV_PSS_API
+#define __MV_PSS_API
+
+#include "mvTypes.h"
+
+/* Defines */
+
+#define PCIR_BARS       0x10
+#define PCIR_BAR(x)     (PCIR_BARS + (x) * 4)
+
+/*
+ * dev_id[15:10] bits of DeviceID register of Prestera (0x4C)
+ * determine the chip type (xCat or xCat2).
+ * dev_id[15:10] == 0x37 stands for xCat
+ * dev_id[15:10] == 0x39 stands for xCat2
+ */
+#define MV_PP_CHIP_TYPE_MASK                        0x000FC00
+#define MV_PP_CHIP_TYPE_OFFSET                      10
+
+/*
+ * Typedef: enum bspCacheType
+ *
+ * Description:
+ *             This type defines used cache types
+ *
+ * Fields:
+ *          bspCacheType_InstructionCache_E - cache of commands
+ *          bspCacheType_DataCache_E        - cache of data
+ *
+ * Note:
+ *      The enum has to be compatible with MV_MGMT_CACHE_TYPE.
+ *
+ */
+enum bspCacheType {
+	bspCacheType_InstructionCache_E,
+	bspCacheType_DataCache_E
+};
+
+/*
+ * Description: Enumeration For PCI interrupt lines.
+ *
+ * Enumerations:
+ *      bspPciInt_PCI_INT_A_E - PCI INT# A
+ *      bspPciInt_PCI_INT_B_ - PCI INT# B
+ *      bspPciInt_PCI_INT_C - PCI INT# C
+ *      bspPciInt_PCI_INT_D - PCI INT# D
+ *
+ * Assumption:
+ *      This enum should be identical to bspPciInt_PCI_INT.
+ */
+enum bspPciInt_PCI_INT {
+	bspPciInt_PCI_INT_A = 1,
+	bspPciInt_PCI_INT_B,
+	bspPciInt_PCI_INT_C,
+	bspPciInt_PCI_INT_D
+};
+
+/*
+ * enum bspSmiAccessMode
+ *
+ * Description:
+ *             PP SMI access mode.
+ *
+ * Fields:
+ *          bspSmiAccessMode_Direct_E   - direct access mode (single/parallel)
+ *          bspSmiAccessMode_inDirect_E - indirect access mode
+ *
+ * Note:
+ *      The enum has to be compatible with MV_MGMT_CACHE_TYPE.
+ *
+ */
+enum bspSmiAccessMode {
+	bspSmiAccessMode_Direct_E,
+	bspSmiAccessMode_inDirect_E
+};
+
+/*******************************************************************************
+* BSP_RX_CALLBACK_FUNCPTR
+*
+* DESCRIPTION:
+*       The prototype of the routine to be called after a packet was received
+*
+* INPUTS:
+*       segmentList     - A list of pointers to the packets segments.
+*       segmentLen      - A list of segment length.
+*       numOfSegments   - The number of segment in segment list.
+*       queueNum        - the received queue number
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_TRUE if it has handled the input packet and no further action should
+*               be taken with it, or
+*       MV_FALSE if it has not handled the input packet and normal processing.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+typedef int (*BSP_RX_CALLBACK_FUNCPTR)(unsigned char *segmentList[],
+				       unsigned long segmentLen[],
+				       unsigned long numOfSegments,
+				       unsigned long queueNum);
+
+/*******************************************************************************
+* BSP_TX_COMPLETE_CALLBACK_FUNCPTR
+*
+* DESCRIPTION:
+*       The prototype of the routine to be called after a packet was received
+*
+* INPUTS:
+*       segmentList     - A list of pointers to the packets segments.
+*       numOfSegments   - The number of segment in segment list.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_TRUE if it has handled the input packet and no further action should
+*               be taken with it, or
+*       MV_FALSE if it has not handled the input packet and normal processing.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+typedef int (*BSP_TX_COMPLETE_CALLBACK_FUNCPTR)(unsigned char *segmentList[],
+						unsigned long numOfSegments);
+
+/*** reset ***/
+/*******************************************************************************
+* bspResetInit
+*
+* DESCRIPTION:
+*       This routine calls in init to do system init config for reset.
+*
+* INPUTS:
+*       none.
+*
+* OUTPUTS:
+*       none.
+*
+* RETURNS:
+*       MV_OK      - on success.
+*       MV_FAIL    - otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+int bspResetInit(MV_VOID);
+
+/*******************************************************************************
+* bspReset
+*
+* DESCRIPTION:
+*       This routine calls to reset of CPU.
+*
+* INPUTS:
+*       none.
+*
+* OUTPUTS:
+*       none.
+*
+* RETURNS:
+*       MV_OK      - on success.
+*       MV_FAIL    - otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+int bspReset(MV_VOID);
+
+/*** PCI ***/
+/*******************************************************************************
+* bspPciConfigWriteReg
+*
+* DESCRIPTION:
+*       This routine write register to the PCI configuration space.
+*
+* INPUTS:
+*       busNo    - PCI bus number.
+*       devSel   - the device devSel.
+*       funcNo   - function number.
+*       regAddr  - Register offset in the configuration space.
+*       data     - data to write.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK   - on success,
+*       MV_FAIL - othersise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int bspPciConfigWriteReg(unsigned long busNo,
+			 unsigned long devSel,
+			 unsigned long funcNo,
+			 unsigned long regAddr,
+			 unsigned long data);
+
+
+/*******************************************************************************
+* bspPciConfigReadReg
+*
+* DESCRIPTION:
+*       This routine read register from the PCI configuration space.
+*
+* INPUTS:
+*       busNo    - PCI bus number.
+*       devSel   - the device devSel.
+*       funcNo   - function number.
+*       regAddr  - Register offset in the configuration space.
+*
+* OUTPUTS:
+*       data     - the read data.
+*
+* RETURNS:
+*       MV_OK   - on success,
+*       MV_FAIL - othersise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int bspPciConfigReadReg(unsigned long	busNo,
+			unsigned long	devSel,
+			unsigned long	funcNo,
+			unsigned long	regAddr,
+			unsigned long	*data);
+
+/*******************************************************************************
+* bspPciGetResourceStart
+*
+* DESCRIPTION:
+*       This routine performs pci_resource_start.
+*       In MIPS64 this function must be used instead of reading the bar
+*       directly.
+*
+* INPUTS:
+*       busNo    - PCI bus number.
+*       devSel   - the device devSel.
+*       funcNo   - function number.
+*       barNo    - Bar Number.
+*
+* OUTPUTS:
+*       ResourceStart - the address of the resource.
+*
+* RETURNS:
+*       MV_OK   - on success,
+*       MV_FAIL - othersise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int bspPciGetResourceStart(unsigned long	busNo,
+			   unsigned long	devSel,
+			   unsigned long	funcNo,
+			   unsigned long	barNo,
+			   unsigned long long	*resourceStart);
+
+/*******************************************************************************
+* bspPciGetResourceLen
+*
+* DESCRIPTION:
+*       This routine performs pci_resource_len.
+*       In MIPS64 this function must be used instead of reading the bar
+*       directly.
+*
+* INPUTS:
+*       busNo    - PCI bus number.
+*       devSel   - the device devSel.
+*       funcNo   - function number.
+*       barNo    - Bar Number.
+*
+* OUTPUTS:
+*       ResourceLen - the address of the resource.
+*
+* RETURNS:
+*       MV_OK   - on success,
+*       MV_FAIL - othersise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int bspPciGetResourceLen(unsigned long		busNo,
+			 unsigned long		devSel,
+			 unsigned long		funcNo,
+			 unsigned long		barNo,
+			 unsigned long long	*resourceLen);
+
+/*******************************************************************************
+* bspPciFindDev
+*
+* DESCRIPTION:
+*       This routine returns the next instance of the given device (defined by
+*       vendorId & devId).
+*
+* INPUTS:
+*       vendorId - The device vendor Id.
+*       devId    - The device Id.
+*       instance - The requested device instance.
+*
+* OUTPUTS:
+*       busNo    - PCI bus number.
+*       devSel   - the device devSel.
+*       funcNo   - function number.
+*
+* RETURNS:
+*       MV_OK   - on success,
+*       MV_FAIL - othersise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int bspPciFindDev(unsigned short	vendorId,
+		  unsigned short	devId,
+		  unsigned long		instance,
+		  unsigned long		*busNo,
+		  unsigned long		*devSel,
+		  unsigned long		*funcNo);
+
+/*******************************************************************************
+* bspPciGetIntVec
+*
+* DESCRIPTION:
+*       This routine return the PCI interrupt vector.
+*
+* INPUTS:
+*       pciInt - PCI interrupt number.
+*
+* OUTPUTS:
+*       intVec - PCI interrupt vector.
+*
+* RETURNS:
+*       MV_OK      - on success.
+*       MV_FAIL    - otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+int bspPciGetIntVec(enum bspPciInt_PCI_INT	pciInt,
+		    void			**intVec);
+
+/*******************************************************************************
+* bspPciGetIntMask
+*
+* DESCRIPTION:
+*       This routine return the PCI interrupt vector.
+*
+* INPUTS:
+*       pciInt - PCI interrupt number.
+*
+* OUTPUTS:
+*       intMask - PCI interrupt mask.
+*
+* RETURNS:
+*       MV_OK      - on success.
+*       MV_FAIL    - otherwise.
+*
+* COMMENTS:
+*       PCI interrupt mask should be used for interrupt disable/enable.
+*
+*******************************************************************************/
+int bspPciGetIntMask(enum bspPciInt_PCI_INT	pciInt,
+		     unsigned long		*intMask);
+
+/*******************************************************************************
+* bspPciEnableCombinedAccess
+*
+* DESCRIPTION:
+*       This function enables / disables the Pci writes / reads combining
+*       feature.
+*       Some system controllers support combining memory writes / reads. When a
+*       long burst write / read is required and combining is enabled, the master
+*       combines consecutive write / read transactions, if possible, and
+*       performs one burst on the Pci instead of two. (see comments)
+*
+* INPUTS:
+*       enWrCombine - MV_TRUE enables write requests combining.
+*       enRdCombine - MV_TRUE enables read requests combining.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK               - on sucess,
+*       MV_NOT_SUPPORTED    - if the controller does not support this feature,
+*       MV_FAIL             - otherwise.
+*
+* COMMENTS:
+*       1.  Example for combined write scenario:
+*           The controller is required to write a 32-bit data to address 0x8000,
+*           while this transaction is still in progress, a request for a write
+*           operation to address 0x8004 arrives, in this case the two writes are
+*           combined into a single burst of 8-bytes.
+*
+*******************************************************************************/
+int bspPciEnableCombinedAccess(MV_BOOL enWrCombine,
+			       MV_BOOL enRdCombine);
+
+/*** cache ***/
+/*******************************************************************************
+* bspCacheFlush
+*
+* DESCRIPTION:
+*       Flush to RAM content of cache
+*
+* INPUTS:
+*       type        - type of cache memory data/intraction
+*       address_PTR - starting address of memory block to flush
+*       size        - size of memory block
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK   - on success,
+*       MV_FAIL - othersise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int bspCacheFlush(enum bspCacheType	cacheType,
+		  void			*address_PTR,
+		  size_t		size);
+
+/*******************************************************************************
+* bspCacheInvalidate
+*
+* DESCRIPTION:
+*       Invalidate current content of cache
+*
+* INPUTS:
+*       type        - type of cache memory data/intraction
+*       address_PTR - starting address of memory block to flush
+*       size        - size of memory block
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK   - on success,
+*       MV_FAIL - othersise.
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int bspCacheInvalidate(enum bspCacheType	cacheType,
+		       void			*address_PTR,
+		       size_t			size);
+
+/*** DMA ***/
+/*******************************************************************************
+* bspDmaWrite
+*
+* DESCRIPTION:
+*       Write a given buffer to the given address using the Dma.
+*
+* INPUTS:
+*       address     - The destination address to write to.
+*       buffer      - The buffer to be written.
+*       length      - Length of buffer in words.
+*       burstLimit  - Number of words to be written on each burst.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK   - on success,
+*       MV_FAIL - othersise.
+*
+* COMMENTS:
+*       1.  The given buffer is allways 4 bytes aligned, any further allignment
+*           requirements should be handled internally by this function.
+*       2.  The given buffer may be allocated from an uncached memory space, and
+*           it's to the function to handle the cache flushing.
+*       3.  The Prestera Driver assumes that the implementation of the DMA is
+*           blocking, otherwise the Driver functionality might be damaged.
+*
+*******************************************************************************/
+int bspDmaWrite(unsigned long address,
+		unsigned long  *buffer,
+		unsigned long length,
+		unsigned long burstLimit);
+
+/*******************************************************************************
+* bspDmaRead
+*
+* DESCRIPTION:
+*       Read a memory block from a given address.
+*
+* INPUTS:
+*       address     - The address to read from.
+*       length      - Length of the memory block to read (in words).
+*       burstLimit  - Number of words to be read on each burst.
+*
+* OUTPUTS:
+*       buffer  - The read data.
+*
+* RETURNS:
+*       MV_OK   - on success,
+*       MV_FAIL - othersise.
+*
+* COMMENTS:
+*       1.  The given buffer is allways 4 bytes aligned, any further allignment
+*           requirements should be handled internally by this function.
+*       2.  The given buffer may be allocated from an uncached memory space, and
+*           it's to the function to handle the cache flushing.
+*       3.  The Prestera Driver assumes that the implementation of the DMA is
+*           blocking, otherwise the Driver functionality might be damaged.
+*
+*******************************************************************************/
+int bspDmaRead(unsigned long	address,
+	       unsigned long	length,
+	       unsigned long	burstLimit,
+	       unsigned long	*buffer);
+
+/*******************************************************************************
+* bspCacheDmaMalloc
+*
+* DESCRIPTION:
+*       Allocate a cache free area for DMA devices.
+*
+* INPUTS:
+*       size_t bytes - number of bytes to allocate
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       pointer to allocated data per success
+*       NULL - per failure to allocate space
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+void *bspCacheDmaMalloc(size_t bytes);
+
+/*******************************************************************************
+* bspCacheDmaFree
+*
+* DESCRIPTION:
+*       free a cache free area back to pool.
+*
+* INPUTS:
+*       size_t bytes - number of bytes to allocate
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK   - on success
+*       MV_FAIL - on error
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+int bspCacheDmaFree(void	*pBuf);
+
+/*** SMI ***/
+/*******************************************************************************
+* bspSmiInitDriver
+*
+* DESCRIPTION:
+*       Init the TWSI interface
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       smiAccessMode - direct/indirect mode
+*
+* RETURNS:
+*       MV_OK               - on success
+*       MV_ERROR   - on hardware error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int bspSmiInitDriver(enum bspSmiAccessMode  *smiAccessMode);
+
+/*******************************************************************************
+* bspSmiReadReg
+*
+* DESCRIPTION:
+*       Reads a register from SMI slave.
+*
+* INPUTS:
+*       devSlvId - Slave Device ID
+*		actSmiAddr - actual smi addr to use (relevant for SX PPs)
+*       regAddr - Register address to read from.
+*
+* OUTPUTS:
+*       valuePtr     - Data read from register.
+*
+* RETURNS:
+*       MV_OK               - on success
+*       MV_ERROR   - on hardware error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int bspSmiReadReg(unsigned long devSlvId,
+		  unsigned long actSmiAddr,
+		  unsigned long regAddr,
+		  unsigned long *valuePtr);
+
+/*******************************************************************************
+* bspSmiWriteReg
+*
+* DESCRIPTION:
+*       Writes a register to an SMI slave.
+*
+* INPUTS:
+*       devSlvId - Slave Device ID
+*		actSmiAddr - actual smi addr to use (relevant for SX PPs)
+*       regAddr - Register address to read from.
+*       value   - data to be written.
+*
+* OUTPUTS:
+*        None,
+*
+* RETURNS:
+*       MV_OK               - on success
+*       MV_ERROR   - on hardware error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int bspSmiWriteReg(unsigned long devSlvId,
+		   unsigned long actSmiAddr,
+		   unsigned long regAddr,
+		   unsigned long value);
+
+/*** TWSI ***/
+/*******************************************************************************
+* bspTwsiInitDriver
+*
+* DESCRIPTION:
+*       Init the TWSI interface
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK               - on success
+*       MV_ERROR   - on hardware error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int bspTwsiInitDriver(MV_VOID);
+
+/*******************************************************************************
+* bspTwsiWaitNotBusy
+*
+* DESCRIPTION:
+*       Wait for TWSI interface not BUSY
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK               - on success
+*       MV_ERROR   - on hardware error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int bspTwsiWaitNotBusy(MV_VOID);
+
+/*******************************************************************************
+* bspTwsiMasterReadTrans
+*
+* DESCRIPTION:
+*       do TWSI interface Transaction
+*
+* INPUTS:
+*    devId - I2c slave ID
+*    pData - Pointer to array of chars (address / data)
+*    len   - pData array size (in chars).
+*    stop  - Indicates if stop bit is needed.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK               - on success
+*       MV_ERROR   - on hardware error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int bspTwsiMasterReadTrans(unsigned char	devId,
+			   unsigned char	*pData,
+			   unsigned char	len,
+			   MV_BOOL		stop);
+
+/*******************************************************************************
+* bspTwsiMasterWriteTrans
+*
+* DESCRIPTION:
+*       do TWSI interface Transaction
+*
+* INPUTS:
+*    devId - I2c slave ID
+*    pData - Pointer to array of chars (address / data)
+*    len   - pData array size (in chars).
+*    stop  - Indicates if stop bit is needed.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK               - on success
+*       MV_ERROR   - on hardware error
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int bspTwsiMasterWriteTrans(unsigned char	devId,
+			    unsigned char	*pData,
+			    unsigned char	len,
+			    MV_BOOL		stop);
+
+/*** Ethernet Driver ***/
+/*******************************************************************************
+* bspEthPortRxInit
+*
+* DESCRIPTION: Init the ethernet port Rx interface
+*
+* INPUTS:
+*       rxBufPoolSize   - buffer pool size
+*       rxBufPool_PTR   - the address of the pool
+*       rxBufSize       - the buffer requested size
+*       numOfRxBufs_PTR - number of requested buffers, and actual buffers created
+*       headerOffset    - packet header offset size
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK if successful, or
+*       MV_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+int bspEthPortRxInit(unsigned long rxBufPoolSize,
+		     unsigned char *rxBufPool_PTR,
+		     unsigned long rxBufSize,
+		     unsigned long *numOfRxBufs_PTR,
+		     unsigned long headerOffset,
+		     unsigned long rxQNum,
+		     unsigned long rxQbufPercentage[]);
+
+/*******************************************************************************
+* bspEthPortTxInit
+*
+* DESCRIPTION: Init the ethernet port Tx interface
+*
+* INPUTS:
+*       numOfTxBufs - number of requested buffers
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK if successful, or
+*       MV_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+int bspEthPortTxInit(unsigned long numOfTxBufs);
+
+/*******************************************************************************
+* bspEthPortEnable
+*
+* DESCRIPTION: Enable the ethernet port interface
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK if successful, or
+*       MV_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+int bspEthPortEnable(MV_VOID);
+
+/*******************************************************************************
+* bspEthPortDisable
+*
+* DESCRIPTION: Disable the ethernet port interface
+*
+* INPUTS:
+*       None.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK if successful, or
+*       MV_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+int bspEthPortDisable(MV_VOID);
+
+/*******************************************************************************
+* bspEthPortTx
+*
+* DESCRIPTION:
+*       This function transmits a packet.
+*
+* INPUTS:
+*       segmentList     - A list of pointers to the packets segments.
+*       segmentLen      - A list of segment length.
+*       numOfSegments   - The number of segment in segment list.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK if successful, or
+*       MV_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+int bspEthPortTx(unsigned char *segmentList[],
+		 unsigned long segmentLen[],
+		 unsigned long numOfSegments);
+
+/*******************************************************************************
+* bspEthInputHookAdd
+*
+* DESCRIPTION:
+*       This bind the user Rx callback
+*
+* INPUTS:
+*       userRxFunc - the user Rx callback function
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK if successful, or
+*       MV_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+int bspEthInputHookAdd(BSP_RX_CALLBACK_FUNCPTR userRxFunc);
+
+/*******************************************************************************
+* bspEthTxCompleteHookAdd
+*
+* DESCRIPTION:
+*       This bind the user Tx complete callback
+*
+* INPUTS:
+*       userTxFunc - the user Tx callback function
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK if successful, or
+*       MV_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+int bspEthTxCompleteHookAdd(BSP_TX_COMPLETE_CALLBACK_FUNCPTR userTxFunc);
+
+/*******************************************************************************
+* bspEthRxPacketFree
+*
+* DESCRIPTION:
+*       This routine frees the received Rx buffer.
+*
+* INPUTS:
+*       segmentList     - A list of pointers to the packets segments.
+*       numOfSegments   - The number of segment in segment list.
+*       queueNum        - Receive queue number
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK if successful, or
+*       MV_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+int bspEthRxPacketFree(unsigned char *segmentList[],
+			unsigned long numOfSegments,
+			unsigned long queueNum);
+
+/*******************************************************************************
+* bspIntConnect
+*
+* DESCRIPTION:
+*       Connect a specified C routine to a specified interrupt vector.
+*
+* INPUTS:
+*       vector    - interrupt vector number to attach to
+*       routine   - routine to be called
+*       parameter - parameter to be passed to routine
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       MV_OK   - on success
+*       MV_FAIL - on error
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+int bspIntConnect(unsigned long		vector,
+		  MV_VOIDFUNCPTR	routine,
+		  unsigned long		parameter);
+
+/*******************************************************************************
+* extDrvIntEnable
+*
+* DESCRIPTION:
+*       Enable corresponding interrupt bits
+*
+* INPUTS:
+*       intMask - new interrupt bits
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK   - on success
+*       MV_FAIL - on error
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+int bspIntEnable(unsigned long intMask);
+
+/*******************************************************************************
+* extDrvIntDisable
+*
+* DESCRIPTION:
+*       Disable corresponding interrupt bits.
+*
+* INPUTS:
+*       intMask - new interrupt bits
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK   - on success
+*       MV_FAIL - on error
+*
+* COMMENTS:
+*       None
+*
+*******************************************************************************/
+int bspIntDisable(unsigned long intMask);
+
+/*******************************************************************************
+* bspEthPortTx
+*
+* DESCRIPTION:
+*       This function transmits a packet.
+*
+* INPUTS:
+*       segmentList     - A list of pointers to the packets segments.
+*       segmentLen      - A list of segment length.
+*       numOfSegments   - The number of segment in segment list.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK if successful, or
+*       MV_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+int bspEthPortTx(unsigned char *segmentList[],
+		 unsigned long segmentLen[],
+		 unsigned long numOfSegments);
+
+/*******************************************************************************
+* bspEthPortTxQueue
+*
+* DESCRIPTION:
+*       This function is called after a TxEnd event has been received, it passes
+*       the needed information to the Tapi part.
+*
+* INPUTS:
+*       segmentList     - A list of pointers to the packets segments.
+*       segmentLen      - A list of segment length.
+*       numOfSegments   - The number of segment in segment list.
+*       txQueue         - The TX queue.
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       GT_OK if successful, or
+*       GT_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+int bspEthPortTxQueue(unsigned char *segmentList[],
+		      unsigned long segmentLen[],
+		      unsigned long numOfSegments,
+		      unsigned long txQueue);
+
+/*******************************************************************************
+* bspEthCpuCodeToQueue
+*
+* DESCRIPTION:
+*       Binds DSA CPU code to RX queue.
+*
+* INPUTS:
+*       dsaCpuCode - DSA CPU code
+*       rxQueue    -  rx queue
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK if successful, or
+*       MV_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+int bspEthCpuCodeToQueue(unsigned long dsaCpuCode, unsigned char rxQueue);
+
+/*******************************************************************************
+* bspPciFindDevReset
+*
+* DESCRIPTION:
+*       Reset gPPDevId to make chance to find internal PP again
+*
+* INPUTS:
+*       None
+*
+* OUTPUTS:
+*       None
+*
+* RETURNS:
+*       MV_OK   - on success,
+*
+* COMMENTS:
+*
+*******************************************************************************/
+int bspPciFindDevReset(void);
+
+/*******************************************************************************
+* bspEthInit
+*
+* DESCRIPTION: Init the ethernet HW and HAL
+*
+* INPUTS:
+*       port   - eth port number
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK if successful, or
+*       MV_FAIL otherwise.
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+int bspEthInit(unsigned char port);
+
+/*******************************************************************************
+* bspEthPortTxModeSet
+*
+* DESCRIPTION: Set the ethernet port tx mode
+*
+* INPUTS:
+*       if txMode == bspEthTxMode_asynch_E -- don't wait for TX done - free packet when interrupt received
+*       if txMode == bspEthTxMode_synch_E  -- wait to TX done and free packet immediately
+*
+* OUTPUTS:
+*       None.
+*
+* RETURNS:
+*       MV_OK if successful
+*       MV_NOT_SUPPORTED if input is wrong
+*       MV_FAIL if bspTxModeSetOn is zero
+*
+* COMMENTS:
+*       None.
+*
+*******************************************************************************/
+int bspEthPortTxModeSet(void *stub);
+
+unsigned long  bspVirt2Phys(unsigned long vAddr);
+
+unsigned long  bspPhys2Virt(unsigned long pAddr);
+
+#endif /* __MV_PSS_API */
-- 
1.7.5.4

