From eaa1ed25dbde1d8fdc4917d45aee1292ab49f9cc Mon Sep 17 00:00:00 2001
From: Nadav Haklai <nadavh@marvell.com>
Date: Mon, 3 Mar 2014 13:25:36 +0200
Subject: [PATCH 1800/1825] crypto: ocf: align crypto/ocf to LSP v3.2

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 264ae05fc1b0575fb5823e284ff61a7b27f7642b

Change-Id: I28a7d582fe4077db6b00e6b7ad72599acf71829d
Signed-off-by: Grzegorz Jaszczyk <jaz@semihalf.com>
Signed-off-by: Nadav Haklai <nadavh@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/6068
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 crypto/ocf/Kconfig                                 |   10 +
 crypto/ocf/c7108/Makefile                          |    1 -
 crypto/ocf/c7108/aes-7108.c                        |    2 +-
 crypto/ocf/crypto.c                                |   18 +-
 crypto/ocf/cryptocteon/Makefile                    |    1 -
 crypto/ocf/cryptocteon/README.txt                  |    1 -
 crypto/ocf/cryptocteon/cavium_crypto.c             |   32 +-
 crypto/ocf/cryptodev.c                             |   40 +++
 crypto/ocf/cryptodev.h                             |    6 +-
 crypto/ocf/ep80579/Makefile                        |    2 +-
 crypto/ocf/kirkwood/Makefile                       |    1 -
 crypto/ocf/kirkwood/cesa/AES/mvAes.h               |    2 -
 crypto/ocf/kirkwood/cesa/AES/mvAesAlg.c            |    3 +-
 crypto/ocf/kirkwood/cesa/AES/mvAesApi.c            |    6 +-
 crypto/ocf/kirkwood/cesa/mvCesa.c                  |   18 +-
 crypto/ocf/kirkwood/cesa/mvCesa.h                  |    2 +-
 crypto/ocf/kirkwood/cesa/mvCesaRegs.h              |    1 -
 crypto/ocf/kirkwood/cesa/mvCesaTest.c              |    8 +-
 crypto/ocf/kirkwood/cesa_ocf_drv.c                 |  178 +++++-----
 crypto/ocf/kirkwood/mvHal/common/mvCommon.c        |    4 +-
 crypto/ocf/kirkwood/mvHal/common/mvDebug.c         |    1 -
 crypto/ocf/kirkwood/mvHal/common/mvDebug.h         |    1 -
 crypto/ocf/kirkwood/mvHal/common/mvStack.c         |   17 +-
 crypto/ocf/kirkwood/mvHal/common/mvStack.h         |   18 +-
 crypto/ocf/kirkwood/mvHal/common/mvTypes.h         |    1 -
 crypto/ocf/kirkwood/mvHal/dbg-trace.c              |    2 -
 .../mvHal/kw_family/boardEnv/mvBoardEnvLib.c       |  349 ++++++++++----------
 .../mvHal/kw_family/boardEnv/mvBoardEnvLib.h       |    6 +-
 .../mvHal/kw_family/boardEnv/mvBoardEnvSpec.c      |   10 +-
 .../mvHal/kw_family/ctrlEnv/mvCtrlEnvAddrDec.c     |    3 -
 .../mvHal/kw_family/ctrlEnv/mvCtrlEnvLib.c         |   52 ++--
 .../mvHal/kw_family/ctrlEnv/mvCtrlEnvLib.h         |    6 +-
 .../mvHal/kw_family/ctrlEnv/mvCtrlEnvRegs.h        |    6 +-
 .../mvHal/kw_family/ctrlEnv/sys/mvAhbToMbus.c      |    5 +-
 .../mvHal/kw_family/ctrlEnv/sys/mvAhbToMbusRegs.h  |    1 -
 .../kirkwood/mvHal/kw_family/ctrlEnv/sys/mvCpuIf.c |   18 +-
 .../mvHal/kw_family/ctrlEnv/sys/mvCpuIfRegs.h      |    1 -
 .../mvHal/kw_family/ctrlEnv/sys/mvSysAudio.c       |    1 -
 .../mvHal/kw_family/ctrlEnv/sys/mvSysAudio.h       |    1 -
 .../mvHal/kw_family/ctrlEnv/sys/mvSysDram.c        |    3 +-
 .../mvHal/kw_family/ctrlEnv/sys/mvSysPex.c         |    2 -
 .../mvHal/kw_family/ctrlEnv/sys/mvSysSata.c        |    3 -
 .../mvHal/kw_family/ctrlEnv/sys/mvSysSata.h        |    5 -
 .../mvHal/kw_family/ctrlEnv/sys/mvSysSdmmc.c       |    3 -
 .../mvHal/kw_family/ctrlEnv/sys/mvSysSdmmc.h       |    5 -
 .../mvHal/kw_family/ctrlEnv/sys/mvSysTdm.c         |    7 +-
 .../mvHal/kw_family/ctrlEnv/sys/mvSysTdm.h         |    1 -
 .../mvHal/kw_family/ctrlEnv/sys/mvSysUsb.c         |    2 -
 .../mvHal/kw_family/ctrlEnv/sys/mvSysXor.c         |    2 +-
 .../ocf/kirkwood/mvHal/kw_family/device/mvDevice.c |    3 -
 crypto/ocf/kirkwood/mvHal/linux_oss/mvOs.c         |    1 -
 crypto/ocf/kirkwood/mvHal/linux_oss/mvOs.h         |    2 -
 crypto/ocf/kirkwood/mvHal/mvSysHwConfig.h          |    1 -
 crypto/ocf/kirkwood/mvHal/mv_hal/cntmr/mvCntmr.c   |    1 -
 crypto/ocf/kirkwood/mvHal/mv_hal/cpu/mvCpuCntrs.h  |    1 -
 .../ocf/kirkwood/mvHal/mv_hal/cpu/mvCpuL2Cntrs.h   |    1 -
 crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDram.c   |    5 +-
 crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDramIf.c |    2 -
 .../kirkwood/mvHal/mv_hal/ddr1_2/mvDramIfConfig.S  |    7 +-
 crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIf.c   |   39 +--
 .../kirkwood/mvHal/mv_hal/ddr2/mvDramIfBasicInit.S |   10 +-
 .../kirkwood/mvHal/mv_hal/ddr2/mvDramIfConfig.S    |   11 +-
 .../mvHal/mv_hal/ddr2/mvDramIfStaticInit.h         |    1 -
 crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/spd/mvSpd.c  |    3 +-
 crypto/ocf/kirkwood/mvHal/mv_hal/eth/gbe/mvEth.c   |   13 +-
 .../ocf/kirkwood/mvHal/mv_hal/eth/gbe/mvEthGbe.h   |    2 -
 crypto/ocf/kirkwood/mvHal/mv_hal/eth/mvEth.h       |    2 -
 crypto/ocf/kirkwood/mvHal/mv_hal/gpp/mvGpp.c       |    4 +-
 crypto/ocf/kirkwood/mvHal/mv_hal/gpp/mvGpp.h       |    1 -
 crypto/ocf/kirkwood/mvHal/mv_hal/pci-if/mvPciIf.c  |    3 -
 crypto/ocf/kirkwood/mvHal/mv_hal/pci-if/mvPciIf.h  |    1 -
 .../ocf/kirkwood/mvHal/mv_hal/pci-if/mvPciIfRegs.h |    1 -
 .../mvHal/mv_hal/pci-if/pci_util/mvPciUtils.c      |   19 +-
 crypto/ocf/kirkwood/mvHal/mv_hal/pci/mvPci.c       |    8 +-
 crypto/ocf/kirkwood/mvHal/mv_hal/pci/mvPci.h       |    3 -
 crypto/ocf/kirkwood/mvHal/mv_hal/pci/mvPciRegs.h   |    1 -
 crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvPex.c       |   13 +-
 crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvPexRegs.h   |    2 -
 crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvVrtBrgPex.c |    2 -
 crypto/ocf/kirkwood/mvHal/mv_hal/sflash/mvSFlash.c |    1 -
 .../kirkwood/mvHal/mv_hal/sflash/mvSFlashSpec.h    |    1 -
 crypto/ocf/kirkwood/mvHal/mv_hal/spi/mvSpi.c       |   40 +--
 crypto/ocf/kirkwood/mvHal/mv_hal/spi/mvSpiCmnd.c   |    1 -
 crypto/ocf/kirkwood/mvHal/mv_hal/spi/mvSpiSpec.h   |    1 -
 crypto/ocf/kirkwood/mvHal/mv_hal/twsi/mvTwsi.c     |   90 +++---
 crypto/ocf/kirkwood/mvHal/mv_hal/twsi/mvTwsi.h     |    1 -
 crypto/ocf/safe/hmachack.h                         |    1 -
 crypto/ocf/talitos/talitos.c                       |    2 +-
 crypto/ocf/ubsec_ssb/Makefile                      |    1 -
 crypto/ocf/ubsec_ssb/ubsec_ssb.c                   |    1 -
 crypto/ocf/ubsec_ssb/ubsecvar.h                    |    1 -
 91 files changed, 554 insertions(+), 618 deletions(-)

diff --git a/crypto/ocf/Kconfig b/crypto/ocf/Kconfig
index 65a4461..47f4e21 100644
--- a/crypto/ocf/Kconfig
+++ b/crypto/ocf/Kconfig
@@ -31,6 +31,16 @@ config OCF_CRYPTOSOFT
 	  A software driver for the OCF framework that uses
 	  the kernel CryptoAPI.
 
+config OCF_DM_CRYPT
+	bool "OCF dm_crypt"
+	depends on OCF_OCF && DM_CRYPT
+	help
+	  The dm_crypt device mapper will use the OCF for encryption/decryption,
+	  in case of essiv, the essiv generation will use the kernel crypto APIs.
+	  When using the OCF dm_crypt, only the following encryption algorithms
+	  are supported:
+		DES-CBC, 3DES-CBC and AES-CBC.
+
 config OCF_SAFE
 	tristate "safenet (HW crypto engine)"
 	depends on OCF_OCF
diff --git a/crypto/ocf/c7108/Makefile b/crypto/ocf/c7108/Makefile
index e7e634b..dd9af55 100644
--- a/crypto/ocf/c7108/Makefile
+++ b/crypto/ocf/c7108/Makefile
@@ -9,4 +9,3 @@ EXTRA_CFLAGS += -I$(obj)/.. -I$(obj)/
 ifdef TOPDIR
 -include $(TOPDIR)/Rules.make
 endif
-
diff --git a/crypto/ocf/c7108/aes-7108.c b/crypto/ocf/c7108/aes-7108.c
index c57a58d..f39666d 100644
--- a/crypto/ocf/c7108/aes-7108.c
+++ b/crypto/ocf/c7108/aes-7108.c
@@ -816,7 +816,7 @@ cypher_7108_crypto_init(void)
 	memset(&a7108dev, 0, sizeof(a7108dev));
 	softc_device_init(&a7108dev, "aes7108", 0, a7108_methods);
 
-       	c7108_id = crypto_get_driverid(softc_get_device(&a7108dev), CRYPTOCAP_F_HARDWARE);
+	c7108_id = crypto_get_driverid(softc_get_device(&a7108dev), CRYPTOCAP_F_HARDWARE);
 	if (c7108_id < 0)
 		panic("7108: crypto device cannot initialize!");
 
diff --git a/crypto/ocf/crypto.c b/crypto/ocf/crypto.c
index 01b83f5..efaa3d1 100644
--- a/crypto/ocf/crypto.c
+++ b/crypto/ocf/crypto.c
@@ -834,8 +834,12 @@ crypto_dispatch(struct cryptop *crp)
 		KASSERT(cap != NULL, ("%s: Driver disappeared.", __func__));
 
 		result = crypto_invoke(cap, crp, 0);
-		if (result != 0)
+		if (result != 0) {
+			CRYPTO_Q_LOCK();
+			crypto_q_cnt--;
 			cryptostats.cs_drops++;
+			CRYPTO_Q_UNLOCK();
+		}
 	} else {
 		CRYPTO_Q_LOCK();
 		TAILQ_INSERT_TAIL(&crp_q, crp, crp_next);
@@ -1294,7 +1298,7 @@ crypto_proc(void *arg)
 	struct cryptocap *cap;
 	u_int32_t hid;
 	int result, hint;
-	unsigned long q_flags;
+	unsigned long q_flags, wait_flags;
 	int loopcount = 0;
 
 	set_current_state(TASK_INTERRUPTIBLE);
@@ -1451,10 +1455,12 @@ crypto_proc(void *arg)
 					list_empty(&crp_kq), crypto_all_kqblocked);
 			loopcount = 0;
 			CRYPTO_Q_UNLOCK();
-			wait_event_interruptible(cryptoproc_wait,
+			spin_lock_irqsave(&cryptoproc_wait.lock, wait_flags);
+			wait_event_interruptible_locked_irq(cryptoproc_wait,
 					!(list_empty(&crp_q) || crypto_all_qblocked) ||
 					!(list_empty(&crp_kq) || crypto_all_kqblocked) ||
 					kthread_should_stop());
+			spin_unlock_irqrestore(&cryptoproc_wait.lock, wait_flags);
 			if (signal_pending (current)) {
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
 				spin_lock_irq(&current->sigmask_lock);
@@ -1495,7 +1501,7 @@ crypto_ret_proc(void *arg)
 {
 	struct cryptop *crpt;
 	struct cryptkop *krpt;
-	unsigned long  r_flags;
+	unsigned long  r_flags, wait_flags;
 
 	set_current_state(TASK_INTERRUPTIBLE);
 
@@ -1531,10 +1537,12 @@ crypto_ret_proc(void *arg)
 			 */
 			dprintk("%s - sleeping\n", __FUNCTION__);
 			CRYPTO_RETQ_UNLOCK();
-			wait_event_interruptible(cryptoretproc_wait,
+			spin_lock_irqsave(&cryptoretproc_wait.lock, wait_flags);
+			wait_event_interruptible_locked_irq(cryptoretproc_wait,
 					!list_empty(&crp_ret_q) ||
 					!list_empty(&crp_ret_kq) ||
 					kthread_should_stop());
+			spin_unlock_irqrestore(&cryptoretproc_wait.lock, wait_flags);
 			if (signal_pending (current)) {
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
 				spin_lock_irq(&current->sigmask_lock);
diff --git a/crypto/ocf/cryptocteon/Makefile b/crypto/ocf/cryptocteon/Makefile
index eeed0d6..7e8da19 100644
--- a/crypto/ocf/cryptocteon/Makefile
+++ b/crypto/ocf/cryptocteon/Makefile
@@ -14,4 +14,3 @@ endif
 ifdef TOPDIR
 -include $(TOPDIR)/Rules.make
 endif
-
diff --git a/crypto/ocf/cryptocteon/README.txt b/crypto/ocf/cryptocteon/README.txt
index 807b2e5..e6941cb 100644
--- a/crypto/ocf/cryptocteon/README.txt
+++ b/crypto/ocf/cryptocteon/README.txt
@@ -8,4 +8,3 @@ cavium_crypto sourced from:
 
 and significantly modified to suit use with OCF.  All original
 copyright/ownership headers retained.
-
diff --git a/crypto/ocf/cryptocteon/cavium_crypto.c b/crypto/ocf/cryptocteon/cavium_crypto.c
index 28054d1..0254b9b 100644
--- a/crypto/ocf/cryptocteon/cavium_crypto.c
+++ b/crypto/ocf/cryptocteon/cavium_crypto.c
@@ -887,11 +887,11 @@ octo_des_cbc_md5_encrypt(
     }
 
     while (crypt_len > 0 || auth_len > 0) {
-    	uint32_t *first = data32;
+	uint32_t *first = data32;
 	mydata.data32[0] = *first;
 	SG_CONSUME(sg, data32, data_i, data_l);
 	mydata.data32[1] = *data32;
-    	if (crypt_off <= 0) {
+	if (crypt_off <= 0) {
 	    if (crypt_len > 0) {
 		CVMX_MT_3DES_ENC_CBC(*data);
 		CVMX_MF_3DES_RESULT(*data);
@@ -899,7 +899,7 @@ octo_des_cbc_md5_encrypt(
 	    }
 	} else
 	    crypt_off -= 8;
-    	if (auth_off <= 0) {
+	if (auth_off <= 0) {
 	    if (auth_len > 0) {
 		CVM_LOAD_MD5_UNIT(*data, next);
 		auth_len -= 8;
@@ -1041,18 +1041,18 @@ octo_des_cbc_md5_decrypt(
     }
 
     while (crypt_len > 0 || auth_len > 0) {
-    	uint32_t *first = data32;
+	uint32_t *first = data32;
 	mydata.data32[0] = *first;
 	SG_CONSUME(sg, data32, data_i, data_l);
 	mydata.data32[1] = *data32;
-    	if (auth_off <= 0) {
+	if (auth_off <= 0) {
 	    if (auth_len > 0) {
 		CVM_LOAD_MD5_UNIT(*data, next);
 		auth_len -= 8;
 	    }
 	} else
 	    auth_off -= 8;
-    	if (crypt_off <= 0) {
+	if (crypt_off <= 0) {
 	    if (crypt_len > 0) {
 		CVMX_MT_3DES_DEC_CBC(*data);
 		CVMX_MF_3DES_RESULT(*data);
@@ -1199,11 +1199,11 @@ octo_des_cbc_sha1_encrypt(
     }
 
     while (crypt_len > 0 || auth_len > 0) {
-    	uint32_t *first = data32;
+	uint32_t *first = data32;
 	mydata.data32[0] = *first;
 	SG_CONSUME(sg, data32, data_i, data_l);
 	mydata.data32[1] = *data32;
-    	if (crypt_off <= 0) {
+	if (crypt_off <= 0) {
 	    if (crypt_len > 0) {
 		CVMX_MT_3DES_ENC_CBC(*data);
 		CVMX_MF_3DES_RESULT(*data);
@@ -1211,7 +1211,7 @@ octo_des_cbc_sha1_encrypt(
 	    }
 	} else
 	    crypt_off -= 8;
-    	if (auth_off <= 0) {
+	if (auth_off <= 0) {
 	    if (auth_len > 0) {
 		CVM_LOAD_SHA_UNIT(*data, next);
 		auth_len -= 8;
@@ -1356,18 +1356,18 @@ octo_des_cbc_sha1_decrypt(
     }
 
     while (crypt_len > 0 || auth_len > 0) {
-    	uint32_t *first = data32;
+	uint32_t *first = data32;
 	mydata.data32[0] = *first;
 	SG_CONSUME(sg, data32, data_i, data_l);
 	mydata.data32[1] = *data32;
-    	if (auth_off <= 0) {
+	if (auth_off <= 0) {
 	    if (auth_len > 0) {
 		CVM_LOAD_SHA_UNIT(*data, next);
 		auth_len -= 8;
 	    }
 	} else
 	    auth_off -= 8;
-    	if (crypt_off <= 0) {
+	if (crypt_off <= 0) {
 	    if (crypt_len > 0) {
 		CVMX_MT_3DES_DEC_CBC(*data);
 		CVMX_MF_3DES_RESULT(*data);
@@ -1533,7 +1533,7 @@ octo_aes_cbc_md5_encrypt(
     }
 
     while (crypt_len > 0) {
-    	uint32_t *pdata32[3];
+	uint32_t *pdata32[3];
 
 	pdata32[0] = data32;
 	mydata[0].data32[0] = *data32;
@@ -1731,7 +1731,7 @@ octo_aes_cbc_md5_decrypt(
     }
 
     while (crypt_len > 0) {
-    	uint32_t *pdata32[3];
+	uint32_t *pdata32[3];
 
 	pdata32[0] = data32;
 	mydata[0].data32[0] = *data32;
@@ -1933,7 +1933,7 @@ octo_aes_cbc_sha1_encrypt(
     }
 
     while (crypt_len > 0) {
-    	uint32_t *pdata32[3];
+	uint32_t *pdata32[3];
 
 	pdata32[0] = data32;
 	mydata[0].data32[0] = *data32;
@@ -2151,7 +2151,7 @@ octo_aes_cbc_sha1_decrypt(
     }
 
     while (crypt_len > 0) {
-    	uint32_t *pdata32[3];
+	uint32_t *pdata32[3];
 
 	pdata32[0] = data32;
 	mydata[0].data32[0] = *data32;
diff --git a/crypto/ocf/cryptodev.c b/crypto/ocf/cryptodev.c
index a21b967..effba5e 100644
--- a/crypto/ocf/cryptodev.c
+++ b/crypto/ocf/cryptodev.c
@@ -126,6 +126,32 @@ static int cryptodev_cb(void *);
 static int cryptodev_open(struct inode *inode, struct file *filp);
 
 /*
+ * lock on driver table
+ * we track its state as spin_is_locked does not do anything on non-SMP boxes
+ */
+static spinlock_t	cryptodev_drivers_lock;
+static int		cryptodev_drivers_locked;		/* for non-SMP boxes */
+
+#define	CRYPTODEV_DRIVER_LOCK() \
+			({ \
+				spin_lock_irqsave(&cryptodev_drivers_lock, d_flags); \
+				cryptodev_drivers_locked = 1; \
+				dprintk("%s,%d: DRIVER_LOCK()\n", __FILE__, __LINE__); \
+			})
+#define	CRYPTODEV_DRIVER_UNLOCK() \
+			({ \
+				dprintk("%s,%d: DRIVER_UNLOCK()\n", __FILE__, __LINE__); \
+				cryptodev_drivers_locked = 0; \
+				spin_unlock_irqrestore(&cryptodev_drivers_lock, d_flags); \
+			})
+#define	CRYPTODEV_DRIVER_ASSERT() \
+			({ \
+				if (!cryptodev_drivers_locked) { \
+					dprintk("%s,%d: DRIVER_ASSERT!\n", __FILE__, __LINE__); \
+				} \
+			})
+
+/*
  * Check a crypto identifier to see if it requested
  * a valid crid and it's capabilities match.
  */
@@ -636,6 +662,7 @@ cryptodev_ioctl(
 	u_int32_t ses = 0;
 	int feat, fd, error = 0, crid;
 	mm_segment_t fs;
+	unsigned long d_flags;
 
 	dprintk("%s(cmd=%x arg=%lx)\n", __FUNCTION__, cmd, arg);
 
@@ -835,9 +862,11 @@ cryptodev_ioctl(
 			/* allow either HW or SW to be used */
 			crid = CRYPTOCAP_F_HARDWARE | CRYPTOCAP_F_SOFTWARE;
 		}
+		CRYPTODEV_DRIVER_LOCK();
 		error = crypto_newsession(&sid, (info.blocksize ? &crie : &cria), crid);
 		if (error) {
 			dprintk("%s(%s) - newsession %d\n",__FUNCTION__,CIOCGSESSSTR,error);
+			CRYPTODEV_DRIVER_UNLOCK();
 			goto bail;
 		}
 
@@ -846,6 +875,7 @@ cryptodev_ioctl(
 			crypto_freesession(sid);
 			error = EINVAL;
 			dprintk("%s(%s) - csecreate failed\n", __FUNCTION__, CIOCGSESSSTR);
+			CRYPTODEV_DRIVER_UNLOCK();
 			goto bail;
 		}
 		sop.ses = cse->ses;
@@ -854,6 +884,7 @@ cryptodev_ioctl(
 			/* return hardware/driver id */
 			sop.crid = CRYPTO_SESID2HID(cse->sid);
 		}
+		CRYPTODEV_DRIVER_UNLOCK();
 
 		if (copy_to_user((void*)arg, &sop, (cmd == CIOCGSESSION) ?
 					sizeof(struct session_op) : sizeof(sop))) {
@@ -872,14 +903,17 @@ bail:
 	case CIOCFSESSION:
 		dprintk("%s(CIOCFSESSION)\n", __FUNCTION__);
 		get_user(ses, (uint32_t*)arg);
+		CRYPTODEV_DRIVER_LOCK();
 		cse = csefind(fcr, ses);
 		if (cse == NULL) {
 			error = EINVAL;
 			dprintk("%s(CIOCFSESSION) - Fail %d\n", __FUNCTION__, error);
+			CRYPTODEV_DRIVER_UNLOCK();
 			break;
 		}
 		csedelete(fcr, cse);
 		error = csefree(cse);
+		CRYPTODEV_DRIVER_UNLOCK();
 		break;
 	case CIOCCRYPT:
 		dprintk("%s(CIOCCRYPT)\n", __FUNCTION__);
@@ -888,12 +922,15 @@ bail:
 			error = EFAULT;
 			goto bail;
 		}
+		CRYPTODEV_DRIVER_LOCK();
 		cse = csefind(fcr, cop.ses);
 		if (cse == NULL) {
 			error = EINVAL;
 			dprintk("%s(CIOCCRYPT) - Fail %d\n", __FUNCTION__, error);
+			CRYPTODEV_DRIVER_UNLOCK();
 			break;
 		}
+		CRYPTODEV_DRIVER_UNLOCK();
 		error = cryptodev_op(cse, &cop);
 		if(copy_to_user((void*)arg, &cop, sizeof(cop))) {
 			dprintk("%s(CIOCCRYPT) - bad return copy\n", __FUNCTION__);
@@ -1005,6 +1042,7 @@ cryptodev_release(struct inode *inode, struct file *filp)
 {
 	struct fcrypt *fcr = filp->private_data;
 	struct csession *cse, *tmp;
+	unsigned long d_flags;
 
 	dprintk("%s()\n", __FUNCTION__);
 	if (!filp) {
@@ -1012,11 +1050,13 @@ cryptodev_release(struct inode *inode, struct file *filp)
 		return(0);
 	}
 
+	CRYPTODEV_DRIVER_LOCK();
 	list_for_each_entry_safe(cse, tmp, &fcr->csessions, list) {
 		list_del(&cse->list);
 		(void)csefree(cse);
 	}
 	filp->private_data = NULL;
+	CRYPTODEV_DRIVER_UNLOCK();
 	kfree(fcr);
 	return(0);
 }
diff --git a/crypto/ocf/cryptodev.h b/crypto/ocf/cryptodev.h
index 30f6add..1f8cc57 100644
--- a/crypto/ocf/cryptodev.h
+++ b/crypto/ocf/cryptodev.h
@@ -185,7 +185,7 @@ struct session_op {
 	int		mackeylen;	/* mac key */
 	caddr_t		mackey;
 
-  	u_int32_t	ses;		/* returns: session # */
+	u_int32_t	ses;		/* returns: session # */
 };
 
 struct session2_op {
@@ -197,7 +197,7 @@ struct session2_op {
 	int		mackeylen;	/* mac key */
 	caddr_t		mackey;
 
-  	u_int32_t	ses;		/* returns: session # */
+	u_int32_t	ses;		/* returns: session # */
 	int		crid;		/* driver id + flags (rw) */
 	int		pad[4];		/* for future expansion */
 };
@@ -408,7 +408,7 @@ struct cryptkop {
 	int		(*krp_callback)(struct cryptkop *);
 };
 
-#include <ocf-compat.h>
+#include "ocf-compat.h"
 
 /*
  * Session ids are 64 bits.  The lower 32 bits contain a "local id" which
diff --git a/crypto/ocf/ep80579/Makefile b/crypto/ocf/ep80579/Makefile
index ff1cba6..e488374 100644
--- a/crypto/ocf/ep80579/Makefile
+++ b/crypto/ocf/ep80579/Makefile
@@ -72,7 +72,7 @@
 ####################Common variables and definitions########################
 
 ifndef ICP_ROOT
-#$(warning ICP_ROOT is undefined. Please set the path to EP80579 release package directory \
+$(warning ICP_ROOT is undefined. Please set the path to EP80579 release package directory \
         "-> setenv ICP_ROOT <path>")
 all fastdep:
 	:
diff --git a/crypto/ocf/kirkwood/Makefile b/crypto/ocf/kirkwood/Makefile
index 6dafd00..ae0fec2 100644
--- a/crypto/ocf/kirkwood/Makefile
+++ b/crypto/ocf/kirkwood/Makefile
@@ -16,4 +16,3 @@ EXTRA_CFLAGS += -DMV_LINUX -DMV_CPU_LE -DMV_ARM -DMV_INCLUDE_CESA -DMV_INCLUDE_P
 ifdef TOPDIR
 -include $(TOPDIR)/Rules.make
 endif
-
diff --git a/crypto/ocf/kirkwood/cesa/AES/mvAes.h b/crypto/ocf/kirkwood/cesa/AES/mvAes.h
index 969727f..d1d6687 100644
--- a/crypto/ocf/kirkwood/cesa/AES/mvAes.h
+++ b/crypto/ocf/kirkwood/cesa/AES/mvAes.h
@@ -58,5 +58,3 @@ int     aesBlockEncrypt128(MV_U8 mode, MV_U8 *IV, MV_U8 *expandedKey, int  keyLe
                     MV_U32 *plain, int numBlocks, MV_U32 *cipher);
 int     aesBlockDecrypt128(MV_U8 mode, MV_U8 *IV, MV_U8 *expandedKey, int  keyLen,
                     MV_U32 *plain, int numBlocks, MV_U32 *cipher);
-
-
diff --git a/crypto/ocf/kirkwood/cesa/AES/mvAesAlg.c b/crypto/ocf/kirkwood/cesa/AES/mvAesAlg.c
index f71201e..5213c6c 100644
--- a/crypto/ocf/kirkwood/cesa/AES/mvAesAlg.c
+++ b/crypto/ocf/kirkwood/cesa/AES/mvAesAlg.c
@@ -89,7 +89,7 @@ void ShiftRow128Dec(MV_U8 a[4][MAXBC]) {
 	/* Row 0 remains unchanged
 	 * The other three rows are shifted a variable amount
 	 */
-   	MV_U8 tmp[MAXBC];
+	MV_U8 tmp[MAXBC];
 
     tmp[0] = a[1][3];
     tmp[1] = a[1][0];
@@ -314,4 +314,3 @@ int rijndaelDecrypt128(MV_U8 a[4][MAXBC], MV_U8 rk[MAXROUNDS+1][4][MAXBC], int r
 
 	return 0;
 }
-
diff --git a/crypto/ocf/kirkwood/cesa/AES/mvAesApi.c b/crypto/ocf/kirkwood/cesa/AES/mvAesApi.c
index 6127883..bea842b 100644
--- a/crypto/ocf/kirkwood/cesa/AES/mvAesApi.c
+++ b/crypto/ocf/kirkwood/cesa/AES/mvAesApi.c
@@ -44,7 +44,7 @@ int     aesMakeKey(MV_U8 *expandedKey, MV_U8 *keyMaterial, int keyLen, int block
 	}
 
 	/* initialize key schedule: */
- 	for(i=0; i<keyLen/8; i++)
+	for(i=0; i<keyLen/8; i++)
     {
 		j = keyMaterial[i];
 		k[i % 4][i / 4] = j;
@@ -73,7 +73,7 @@ int     aesMakeKey(MV_U8 *expandedKey, MV_U8 *keyMaterial, int keyLen, int block
         }
     }
 #endif /* MV_AES_DEBUG */
-  	switch (keyLen)
+	switch (keyLen)
     {
 	    case 128:
             rounds = 10;
@@ -308,5 +308,3 @@ int     aesBlockDecrypt128(MV_U8 mode, MV_U8 *IV, MV_U8 *expandedKey, int  keyLe
 
 	return 0;
 }
-
-
diff --git a/crypto/ocf/kirkwood/cesa/mvCesa.c b/crypto/ocf/kirkwood/cesa/mvCesa.c
index 61bcf5d..d9fbe0c 100644
--- a/crypto/ocf/kirkwood/cesa/mvCesa.c
+++ b/crypto/ocf/kirkwood/cesa/mvCesa.c
@@ -415,7 +415,7 @@ MV_STATUS mvCesaHalInit (int numOfSession, int queueDepth, char* pSramBase, MV_U
     MV_REG_WRITE(IDMA_CURR_DESC_PTR_REG(0), 0);
     MV_REG_WRITE(IDMA_CTRL_HIGH_REG(0), ICCHR_ENDIAN_LITTLE
 #ifdef MV_CPU_LE
-      		| ICCHR_DESC_BYTE_SWAP_EN
+		| ICCHR_DESC_BYTE_SWAP_EN
 #endif
 		 );
     /* Clear Cause Byte of IDMA channel to be used */
@@ -455,10 +455,10 @@ MV_STATUS   mvCesaFinish (void)
     /* Free all resources: DMA list, etc. */
     for(req=0; req<cesaQueueDepth; req++)
     {
-    	pReq = &pCesaReqFirst[req];
+	pReq = &pCesaReqFirst[req];
         if(pReq->dmaDescBuf.bufVirtPtr != NULL)
         {
-        	mvOsIoCachedFree(cesaOsHandle,pReq->dmaDescBuf.bufSize,
+		mvOsIoCachedFree(cesaOsHandle,pReq->dmaDescBuf.bufSize,
 				 pReq->dmaDescBuf.bufPhysAddr,
 				 pReq->dmaDescBuf.bufVirtPtr,
 				 pReq->dmaDescBuf.memHandle);
@@ -1025,9 +1025,9 @@ MV_STATUS   mvCesaAction (MV_CESA_COMMAND *pCmd)
 		if(pReq->state == MV_CESA_PENDING) {
 			pNextActiveChain = pReq;
 			pEndCurrChain = MV_CESA_REQ_NEXT_PTR(pReq);
-        		/* Start Process new request */
- 	      		mvCesaReqProcessStart(pReq);
-    		}
+			/* Start Process new request */
+			mvCesaReqProcessStart(pReq);
+		}
     }
 
     chainReqNum++;
@@ -1105,7 +1105,7 @@ MV_STATUS mvCesaReadyGet(MV_CESA_RESULT* pResult)
 		/* Update pNextActiveChain to next chain head */
 		   while(pNextActiveChain->state == MV_CESA_CHAIN)
 			pNextActiveChain = MV_CESA_REQ_NEXT_PTR(pNextActiveChain);
-    	}
+	}
     }
 
     /* Check if there are more processed requests - can we remove pEndCurrChain ??? */
@@ -2106,7 +2106,7 @@ static INLINE int    mvCesaDmaCopyPrepare(MV_CESA_MBUF* pMbuf, MV_U8* pSramBuf,
                 MV_32BIT_LE(mvCesaSramVirtToPhys(NULL, (pSramBuf + size)));
             /* invalidate the buffer */
 	    if(skipFlush == MV_FALSE)
-            	mvOsCacheInvalidate(NULL, pBuf, bufSize);
+		mvOsCacheInvalidate(NULL, pBuf, bufSize);
         }
         else
         {
@@ -2115,7 +2115,7 @@ static INLINE int    mvCesaDmaCopyPrepare(MV_CESA_MBUF* pMbuf, MV_U8* pSramBuf,
                 MV_32BIT_LE(mvCesaSramVirtToPhys(NULL, (pSramBuf + size)));
             /* flush the buffer */
 	    if(skipFlush == MV_FALSE)
-            	mvOsCacheFlush(NULL, pBuf, bufSize);
+		mvOsCacheFlush(NULL, pBuf, bufSize);
         }
 
         /* Count number of used DMA descriptors */
diff --git a/crypto/ocf/kirkwood/cesa/mvCesa.h b/crypto/ocf/kirkwood/cesa/mvCesa.h
index 115274f..65352dc 100644
--- a/crypto/ocf/kirkwood/cesa/mvCesa.h
+++ b/crypto/ocf/kirkwood/cesa/mvCesa.h
@@ -138,7 +138,7 @@ typedef struct
 	MV_CESA_DIRECTION   direction;
 	MV_CESA_CRYPTO_ALG  cryptoAlgorithm;
 	MV_CESA_CRYPTO_MODE cryptoMode;
-   	MV_U8               cryptoKeyLength;
+	MV_U8               cryptoKeyLength;
 	MV_CESA_MAC_MODE    macMode;
 	MV_U8               macKeyLength;
 	MV_U8               digestSize;
diff --git a/crypto/ocf/kirkwood/cesa/mvCesaRegs.h b/crypto/ocf/kirkwood/cesa/mvCesaRegs.h
index c6eecae..340e407 100644
--- a/crypto/ocf/kirkwood/cesa/mvCesaRegs.h
+++ b/crypto/ocf/kirkwood/cesa/mvCesaRegs.h
@@ -354,4 +354,3 @@ typedef enum
 
 
 #endif /* __mvCesaRegs_h__ */
-
diff --git a/crypto/ocf/kirkwood/cesa/mvCesaTest.c b/crypto/ocf/kirkwood/cesa/mvCesaTest.c
index bbbc7ca..50f8bc9 100644
--- a/crypto/ocf/kirkwood/cesa/mvCesaTest.c
+++ b/crypto/ocf/kirkwood/cesa/mvCesaTest.c
@@ -2095,11 +2095,11 @@ void    cesaTestStart(int bufNum, int bufSize)
 				  &cesaReqBufs[i].bufPhysAddr,
 				  &cesaReqBufs[i].memHandle);
 		if(pBuf == NULL)
-    	{
-        	mvOsPrintf("testStart: Can't malloc %d bytes for pBuf\n",
+	{
+		mvOsPrintf("testStart: Can't malloc %d bytes for pBuf\n",
                     bufSize * bufNum * 2);
-        	return;
-    	}
+		return;
+	}
 
         memset(pBuf, 0, bufSize * bufNum * 2);
         mvOsCacheFlush(cesaTestOSHandle,pBuf, bufSize * bufNum * 2);
diff --git a/crypto/ocf/kirkwood/cesa_ocf_drv.c b/crypto/ocf/kirkwood/cesa_ocf_drv.c
index 430fb67..ed92968 100644
--- a/crypto/ocf/kirkwood/cesa_ocf_drv.c
+++ b/crypto/ocf/kirkwood/cesa_ocf_drv.c
@@ -226,13 +226,13 @@ get_usec(unsigned int start)
 		return 0;
 	}
 	else {
-        	do_gettimeofday (&tt_end);
-        	tt_end.tv_sec -= tt_start.tv_sec;
-        	tt_end.tv_usec -= tt_start.tv_usec;
-        	if (tt_end.tv_usec < 0) {
-                	tt_end.tv_usec += 1000 * 1000;
-                	tt_end.tv_sec -= 1;
-        	}
+		do_gettimeofday (&tt_end);
+		tt_end.tv_sec -= tt_start.tv_sec;
+		tt_end.tv_usec -= tt_start.tv_usec;
+		if (tt_end.tv_usec < 0) {
+			tt_end.tv_usec += 1000 * 1000;
+			tt_end.tv_sec -= 1;
+		}
 	}
 	printk("time taken is  %d\n", (unsigned int)(tt_end.tv_usec + tt_end.tv_sec * 1000000));
 	return (tt_end.tv_usec + tt_end.tv_sec * 1000000);
@@ -369,9 +369,9 @@ cesa_ocf_process(device_t dev, struct cryptop *crp, int hint)
 	cesa_ocf_cmd = kmalloc(sizeof(struct cesa_ocf_process), GFP_ATOMIC);
 
         if (cesa_ocf_cmd == NULL) {
-            	printk("%s,%d: ENOBUFS \n", __FILE__, __LINE__);
-            	goto p_error;
-      	}
+		printk("%s,%d: ENOBUFS \n", __FILE__, __LINE__);
+		goto p_error;
+	}
 	memset(cesa_ocf_cmd, 0, sizeof(struct cesa_ocf_process));
 
 	/* init cesa_process */
@@ -411,19 +411,19 @@ cesa_ocf_process(device_t dev, struct cryptop *crp, int hint)
 
 		p_mbuf_info->mbufSize = skb->len;
 		temp_len = skb->len;
-        	/* first skb fragment */
-        	p_buf_info->bufSize = skb_headlen(skb);
-        	p_buf_info->bufVirtPtr = skb->data;
+		/* first skb fragment */
+		p_buf_info->bufSize = skb_headlen(skb);
+		p_buf_info->bufVirtPtr = skb->data;
 		p_buf_info++;
 
-        	/* now handle all other skb fragments */
-        	for ( i = 0; i < skb_shinfo(skb)->nr_frags; i++ ) {
-            		skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
-            		p_buf_info->bufSize = frag->size;
-            		p_buf_info->bufVirtPtr = page_address(FRAG_PAGE(frag->page)) + frag->page_offset;
-            		p_buf_info++;
-        	}
-        	p_mbuf_info->numFrags = skb_shinfo(skb)->nr_frags + 1;
+		/* now handle all other skb fragments */
+		for ( i = 0; i < skb_shinfo(skb)->nr_frags; i++ ) {
+			skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
+			p_buf_info->bufSize = frag->size;
+			p_buf_info->bufVirtPtr = page_address(FRAG_PAGE(frag->page)) + frag->page_offset;
+			p_buf_info++;
+		}
+		p_mbuf_info->numFrags = skb_shinfo(skb)->nr_frags + 1;
 	}
 	/* handle UIO */
 	else if(crp->crp_flags & CRYPTO_F_IOV) {
@@ -486,7 +486,7 @@ cesa_ocf_process(device_t dev, struct cryptop *crp, int hint)
 			dprintk("%s,%d: cipher", __FILE__, __LINE__);
 
 			cesa_cmd->cryptoOffset = crd->crd_skip;
-    	              	cesa_cmd->cryptoLength = crd->crd_len;
+			cesa_cmd->cryptoLength = crd->crd_len;
 
 			if(crd->crd_flags & CRD_F_ENCRYPT) { /* encrypt */
 				dprintk(" encrypt \n");
@@ -498,14 +498,14 @@ cesa_ocf_process(device_t dev, struct cryptop *crp, int hint)
 					cesa_cmd->ivFromUser = 1;
 					ivp = crd->crd_iv;
 
-                                	/*
-                                 	 * do we have to copy the IV back to the buffer ?
-                                 	 */
-                                	if ((crd->crd_flags & CRD_F_IV_PRESENT) == 0) {
+					/*
+					 * do we have to copy the IV back to the buffer ?
+					 */
+					if ((crd->crd_flags & CRD_F_IV_PRESENT) == 0) {
 						dprintk("%s,%d: copy the IV back to the buffer\n", __FILE__, __LINE__);
 						cesa_cmd->ivOffset = crd->crd_inject;
 						crypto_copyback(crp->crp_flags, crp->crp_buf, crd->crd_inject, cesa_ocf_cur_ses->ivlen, ivp);
-                                	}
+					}
 					else {
 						dprintk("%s,%d: don't copy the IV back to the buffer \n", __FILE__, __LINE__);
 						p_mbuf_info->numFrags++;
@@ -529,9 +529,9 @@ cesa_ocf_process(device_t dev, struct cryptop *crp, int hint)
 					dprintk("%s,%d: random IV \n", __FILE__, __LINE__);
 					cesa_cmd->ivFromUser = 0;
 
-                                	/*
-                                 	 * do we have to copy the IV back to the buffer ?
-                                 	 */
+					/*
+					 * do we have to copy the IV back to the buffer ?
+					 */
 					/* in this mode the HAL will always copy the IV */
 					/* given by the session to the ivOffset  	*/
 					if ((crd->crd_flags & CRD_F_IV_PRESENT) == 0) {
@@ -620,10 +620,10 @@ cesa_ocf_process(device_t dev, struct cryptop *crp, int hint)
 			/* malloc a new cesa process and init it */
 			cesa_ocf_cmd_wa = kmalloc(sizeof(struct cesa_ocf_process), GFP_ATOMIC);
 
-        		if (cesa_ocf_cmd_wa == NULL) {
-            			printk("%s,%d: ENOBUFS \n", __FILE__, __LINE__);
-            			goto p_error;
-      			}
+			if (cesa_ocf_cmd_wa == NULL) {
+				printk("%s,%d: ENOBUFS \n", __FILE__, __LINE__);
+				goto p_error;
+			}
 			memcpy(cesa_ocf_cmd_wa, cesa_ocf_cmd, sizeof(struct cesa_ocf_process));
 			cesa_cmd_wa = &cesa_ocf_cmd_wa->cesa_cmd;
 			cesa_cmd_wa->pReqPrv = (void *)cesa_ocf_cmd_wa;
@@ -648,7 +648,7 @@ cesa_ocf_process(device_t dev, struct cryptop *crp, int hint)
 			}
 			else {
 				printk("%s,%d: Unsupporterd fragment wa mode \n", __FILE__, __LINE__);
-            			goto p_error;
+				goto p_error;
 			}
 
 			/* send the 2 actions to the HAL */
@@ -700,7 +700,7 @@ p_error:
 		kfree(cesa_ocf_cmd);
 	if(cesa_ocf_cmd_wa)
 		kfree(cesa_ocf_cmd_wa);
-       	return EINVAL;
+	return EINVAL;
 }
 
 /*
@@ -736,8 +736,8 @@ cesa_callback(unsigned long dummy)
 			        return;
 		        }
 #endif
-	    	    break;
-    	    }
+		    break;
+	    }
 	        res_idx++;
 		    break;
 	    }
@@ -768,7 +768,7 @@ cesa_callback(unsigned long dummy)
 			crypto_done(crp);
 		}
 		kfree(cesa_ocf_cmd);
-    	}
+	}
 #ifdef CESA_OCF_TASKLET
 	enable_irq(cesa_device.irq);
 #endif
@@ -786,7 +786,7 @@ cesa_interrupt_polling(void)
 
 	dprintk("%s()\n", __FUNCTION__);
 
-  	/* Read cause register */
+	/* Read cause register */
 	do {
 		cause = MV_REG_READ(MV_CESA_ISR_CAUSE_REG);
 		cause &= MV_CESA_CAUSE_ACC_DMA_ALL_MASK;
@@ -794,7 +794,7 @@ cesa_interrupt_polling(void)
 	} while (cause == 0);
 
 	/* clear interrupts */
-    	MV_REG_WRITE(MV_CESA_ISR_CAUSE_REG, 0);
+	MV_REG_WRITE(MV_CESA_ISR_CAUSE_REG, 0);
 
 	cesa_callback(0);
 
@@ -815,18 +815,18 @@ cesa_interrupt_handler(int irq, void *arg)
 
 	cesaTestTraceAdd(0);
 
-  	/* Read cause register */
+	/* Read cause register */
 	cause = MV_REG_READ(MV_CESA_ISR_CAUSE_REG);
 
-    	if( (cause & MV_CESA_CAUSE_ACC_DMA_ALL_MASK) == 0)
-    	{
+	if( (cause & MV_CESA_CAUSE_ACC_DMA_ALL_MASK) == 0)
+	{
         /* Empty interrupt */
 		dprintk("%s,%d: cesaTestReadyIsr: cause=0x%x\n", __FILE__, __LINE__, cause);
-        	return IRQ_HANDLED;
-    	}
+		return IRQ_HANDLED;
+	}
 
 	/* clear interrupts */
-    	MV_REG_WRITE(MV_CESA_ISR_CAUSE_REG, 0);
+	MV_REG_WRITE(MV_CESA_ISR_CAUSE_REG, 0);
 
 	cesaTestTraceAdd(1);
 #ifdef CESA_OCF_TASKLET
@@ -859,8 +859,8 @@ cesa_ocf_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 
 	/* leave first empty like in other implementations */
         for (i = 1; i < CESA_OCF_MAX_SES; i++) {
-       		if (cesa_ocf_sessions[i] == NULL)
-               		break;
+		if (cesa_ocf_sessions[i] == NULL)
+			break;
 	}
 
 	if(i >= CESA_OCF_MAX_SES) {
@@ -890,8 +890,8 @@ cesa_ocf_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 	count = 1;
         while (cri) {
 		if(count > 2) {
-        		printk("%s,%d: don't support more then 2 operations\n", __FILE__, __LINE__);
-        		goto error;
+			printk("%s,%d: don't support more then 2 operations\n", __FILE__, __LINE__);
+			goto error;
 		}
                 switch (cri->cri_alg) {
 		case CRYPTO_AES_CBC:
@@ -901,8 +901,8 @@ cesa_ocf_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 			cesa_ses->cryptoAlgorithm = MV_CESA_CRYPTO_AES;
 			cesa_ses->cryptoMode = MV_CESA_CRYPTO_CBC;
 			if(cri->cri_klen/8 > MV_CESA_MAX_CRYPTO_KEY_LENGTH) {
-        			printk("%s,%d: CRYPTO key too long.\n", __FILE__, __LINE__);
-        			goto error;
+				printk("%s,%d: CRYPTO key too long.\n", __FILE__, __LINE__);
+				goto error;
 			}
 			memcpy(cesa_ses->cryptoKey, cri->cri_key, cri->cri_klen/8);
 			dprintk("%s,%d: key length %d \n", __FILE__, __LINE__, cri->cri_klen/8);
@@ -916,8 +916,8 @@ cesa_ocf_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 			cesa_ses->cryptoAlgorithm = MV_CESA_CRYPTO_3DES;
 			cesa_ses->cryptoMode = MV_CESA_CRYPTO_CBC;
 			if(cri->cri_klen/8 > MV_CESA_MAX_CRYPTO_KEY_LENGTH) {
-        			printk("%s,%d: CRYPTO key too long.\n", __FILE__, __LINE__);
-        			goto error;
+				printk("%s,%d: CRYPTO key too long.\n", __FILE__, __LINE__);
+				goto error;
 			}
 			memcpy(cesa_ses->cryptoKey, cri->cri_key, cri->cri_klen/8);
 			cesa_ses->cryptoKeyLength = cri->cri_klen/8;
@@ -930,8 +930,8 @@ cesa_ocf_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 			cesa_ses->cryptoAlgorithm = MV_CESA_CRYPTO_DES;
 			cesa_ses->cryptoMode = MV_CESA_CRYPTO_CBC;
 			if(cri->cri_klen/8 > MV_CESA_MAX_CRYPTO_KEY_LENGTH) {
-        			printk("%s,%d: CRYPTO key too long.\n", __FILE__, __LINE__);
-        			goto error;
+				printk("%s,%d: CRYPTO key too long.\n", __FILE__, __LINE__);
+				goto error;
 			}
 			memcpy(cesa_ses->cryptoKey, cri->cri_key, cri->cri_klen/8);
 			cesa_ses->cryptoKeyLength = cri->cri_klen/8;
@@ -944,8 +944,8 @@ cesa_ocf_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 			cesa_ocf_cur_ses->digestlen = (cri->cri_alg == CRYPTO_MD5)? MV_CESA_MD5_DIGEST_SIZE : 12;
 			cesa_ses->macMode = (cri->cri_alg == CRYPTO_MD5)? MV_CESA_MAC_MD5 : MV_CESA_MAC_HMAC_MD5;
 			if(cri->cri_klen/8 > MV_CESA_MAX_CRYPTO_KEY_LENGTH) {
-        			printk("%s,%d: MAC key too long. \n", __FILE__, __LINE__);
-        			goto error;
+				printk("%s,%d: MAC key too long. \n", __FILE__, __LINE__);
+				goto error;
 			}
 			cesa_ses->macKeyLength = cri->cri_klen/8;
 			memcpy(cesa_ses->macKey, cri->cri_key, cri->cri_klen/8);
@@ -959,8 +959,8 @@ cesa_ocf_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 			cesa_ocf_cur_ses->digestlen = (cri->cri_alg == CRYPTO_SHA1)? MV_CESA_SHA1_DIGEST_SIZE : 12;
 			cesa_ses->macMode = (cri->cri_alg == CRYPTO_SHA1)? MV_CESA_MAC_SHA1 : MV_CESA_MAC_HMAC_SHA1;
 			if(cri->cri_klen/8 > MV_CESA_MAX_CRYPTO_KEY_LENGTH) {
-        			printk("%s,%d: MAC key too long. \n", __FILE__, __LINE__);
-        			goto error;
+				printk("%s,%d: MAC key too long. \n", __FILE__, __LINE__);
+				goto error;
 			}
 			cesa_ses->macKeyLength = cri->cri_klen/8;
 			memcpy(cesa_ses->macKey, cri->cri_key, cri->cri_klen/8);
@@ -995,10 +995,10 @@ cesa_ocf_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 		}
 		cesa_ses->direction = MV_CESA_DIR_ENCODE;
 		status = mvCesaSessionOpen(cesa_ses, &cesa_ocf_cur_ses->sid_encrypt);
-    		if(status != MV_OK) {
-        		printk("%s,%d: Can't open new session - status = 0x%x\n", __FILE__, __LINE__, status);
-        		goto error;
-    		}
+		if(status != MV_OK) {
+			printk("%s,%d: Can't open new session - status = 0x%x\n", __FILE__, __LINE__, status);
+			goto error;
+		}
 		/* decrypt session */
 		if( cesa_ses->operation == MV_CESA_MAC_THEN_CRYPTO ) {
 			cesa_ses->operation = MV_CESA_CRYPTO_THEN_MAC;
@@ -1009,9 +1009,9 @@ cesa_ocf_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 		cesa_ses->direction = MV_CESA_DIR_DECODE;
 		status = mvCesaSessionOpen(cesa_ses, &cesa_ocf_cur_ses->sid_decrypt);
 		if(status != MV_OK) {
-        		printk("%s,%d: Can't open new session - status = 0x%x\n", __FILE__, __LINE__, status);
-        		goto error;
-    		}
+			printk("%s,%d: Can't open new session - status = 0x%x\n", __FILE__, __LINE__, status);
+			goto error;
+		}
 
 		/* preapre one action sessions for case we will need to split an action */
 #ifdef CESA_OCF_SPLIT
@@ -1021,42 +1021,42 @@ cesa_ocf_newsession(device_t dev, u_int32_t *sid, struct cryptoini *cri)
 			cesa_ses->operation = MV_CESA_CRYPTO_ONLY;
 			cesa_ses->direction = MV_CESA_DIR_ENCODE;
 			status = mvCesaSessionOpen(cesa_ses, &cesa_ocf_cur_ses->frag_wa_encrypt);
-    			if(status != MV_OK) {
-        			printk("%s,%d: Can't open new session - status = 0x%x\n", __FILE__, __LINE__, status);
-        			goto error;
-    			}
+			if(status != MV_OK) {
+				printk("%s,%d: Can't open new session - status = 0x%x\n", __FILE__, __LINE__, status);
+				goto error;
+			}
 
 			cesa_ses->direction = MV_CESA_DIR_DECODE;
 			status = mvCesaSessionOpen(cesa_ses, &cesa_ocf_cur_ses->frag_wa_decrypt);
-    			if(status != MV_OK) {
-        			printk("%s,%d: Can't open new session - status = 0x%x\n", __FILE__, __LINE__, status);
-        			goto error;
-    			}
+			if(status != MV_OK) {
+				printk("%s,%d: Can't open new session - status = 0x%x\n", __FILE__, __LINE__, status);
+				goto error;
+			}
 			/* open one session for auth */
 			cesa_ses->operation = MV_CESA_MAC_ONLY;
 			cesa_ses->direction = MV_CESA_DIR_ENCODE;
 			status = mvCesaSessionOpen(cesa_ses, &cesa_ocf_cur_ses->frag_wa_auth);
 			if(status != MV_OK) {
-        			printk("%s,%d: Can't open new session - status = 0x%x\n", __FILE__, __LINE__, status);
+				printk("%s,%d: Can't open new session - status = 0x%x\n", __FILE__, __LINE__, status);
 				goto error;
-    			}
+			}
 		}
 #endif
 	}
 	else { /* only auth */
 		cesa_ses->operation = MV_CESA_MAC_ONLY;
 		cesa_ses->direction = MV_CESA_DIR_ENCODE;
-        	status = mvCesaSessionOpen(cesa_ses, &cesa_ocf_cur_ses->sid_encrypt);
+		status = mvCesaSessionOpen(cesa_ses, &cesa_ocf_cur_ses->sid_encrypt);
 		if(status != MV_OK) {
-        		printk("%s,%d: Can't open new session - status = 0x%x\n", __FILE__, __LINE__, status);
+			printk("%s,%d: Can't open new session - status = 0x%x\n", __FILE__, __LINE__, status);
 			goto error;
-    		}
+		}
 	}
 
         return 0;
 error:
-     	cesa_ocf_freesession(NULL, *sid);
-      	return EINVAL;
+	cesa_ocf_freesession(NULL, *sid);
+	return EINVAL;
 
 }
 
@@ -1083,13 +1083,13 @@ cesa_ocf_freesession(device_t dev, u_int64_t tid)
 
 	/* release session from HAL */
 	cesa_ocf_cur_ses = cesa_ocf_sessions[sid];
-     	if (cesa_ocf_cur_ses->sid_encrypt != -1) {
+	if (cesa_ocf_cur_ses->sid_encrypt != -1) {
 		mvCesaSessionClose(cesa_ocf_cur_ses->sid_encrypt);
 	}
 	if (cesa_ocf_cur_ses->sid_decrypt != -1) {
 		mvCesaSessionClose(cesa_ocf_cur_ses->sid_decrypt);
 	}
-     	if (cesa_ocf_cur_ses->frag_wa_encrypt != -1) {
+	if (cesa_ocf_cur_ses->frag_wa_encrypt != -1) {
 		mvCesaSessionClose(cesa_ocf_cur_ses->frag_wa_encrypt);
 	}
 	if (cesa_ocf_cur_ses->frag_wa_decrypt != -1) {
@@ -1099,7 +1099,7 @@ cesa_ocf_freesession(device_t dev, u_int64_t tid)
 		mvCesaSessionClose(cesa_ocf_cur_ses->frag_wa_auth);
 	}
 
-      	kfree(cesa_ocf_cur_ses);
+	kfree(cesa_ocf_cur_ses);
 	cesa_ocf_sessions[sid] = NULL;
 
         return 0;
@@ -1189,7 +1189,7 @@ mv_cesa_ocf_init(struct platform_device *pdev)
 
 	if( MV_OK != mvCesaInit(CESA_OCF_MAX_SES*5, CESA_Q_SIZE, cesa_device.reg,
 				NULL) ) {
-            	printk("%s,%d: mvCesaInit Failed. \n", __FILE__, __LINE__);
+		printk("%s,%d: mvCesaInit Failed. \n", __FILE__, __LINE__);
 		return EINVAL;
 	}
 
@@ -1204,7 +1204,7 @@ mv_cesa_ocf_init(struct platform_device *pdev)
 	/* register interrupt */
 	if( request_irq( cesa_device.irq, cesa_interrupt_handler,
                              (IRQF_DISABLED) , "cesa", &cesa_ocf_id) < 0) {
-            	printk("%s,%d: cannot assign irq %x\n", __FILE__, __LINE__, cesa_device.reg);
+		printk("%s,%d: cannot assign irq %x\n", __FILE__, __LINE__, cesa_device.reg);
 		return EINVAL;
         }
 
@@ -1242,7 +1242,7 @@ mv_cesa_ocf_exit(struct platform_device *pdev)
 
 
 	if( MV_OK != mvCesaFinish() ) {
-            	printk("%s,%d: mvCesaFinish Failed. \n", __FILE__, __LINE__);
+		printk("%s,%d: mvCesaFinish Failed. \n", __FILE__, __LINE__);
 		return;
 	}
 }
diff --git a/crypto/ocf/kirkwood/mvHal/common/mvCommon.c b/crypto/ocf/kirkwood/mvHal/common/mvCommon.c
index 0605391..53d9292 100644
--- a/crypto/ocf/kirkwood/mvHal/common/mvCommon.c
+++ b/crypto/ocf/kirkwood/mvHal/common/mvCommon.c
@@ -196,7 +196,7 @@ MV_VOID mvSizePrint(MV_U32 size)
 *******************************************************************************/
 MV_VOID mvHexToBin(const char* pHexStr, MV_U8* pBin, int size)
 {
-  	int     j, i;
+	int     j, i;
     char    tmp[3];
     MV_U8   byte;
 
@@ -273,5 +273,3 @@ MV_U32 mvLog2(MV_U32	num)
 	}
 	return result;
 }
-
-
diff --git a/crypto/ocf/kirkwood/mvHal/common/mvDebug.c b/crypto/ocf/kirkwood/mvHal/common/mvDebug.c
index d98a9e4..c9f60e1 100644
--- a/crypto/ocf/kirkwood/mvHal/common/mvDebug.c
+++ b/crypto/ocf/kirkwood/mvHal/common/mvDebug.c
@@ -323,4 +323,3 @@ void mvDebugUpdateTimeEntry(MV_DEBUG_TIMES* pTimeEntry)
         pTimeEntry->left--;
     }
 }
-
diff --git a/crypto/ocf/kirkwood/mvHal/common/mvDebug.h b/crypto/ocf/kirkwood/mvHal/common/mvDebug.h
index ed07a1f..7dae010 100644
--- a/crypto/ocf/kirkwood/mvHal/common/mvDebug.h
+++ b/crypto/ocf/kirkwood/mvHal/common/mvDebug.h
@@ -175,4 +175,3 @@ void    mvDebugModuleClearFlags(MV_MODULE_ID module, MV_U32 flags);
 
 
 #endif /* __INCmvDebug.h */
-
diff --git a/crypto/ocf/kirkwood/mvHal/common/mvStack.c b/crypto/ocf/kirkwood/mvHal/common/mvStack.c
index 8c77fc9..4ce7012 100644
--- a/crypto/ocf/kirkwood/mvHal/common/mvStack.c
+++ b/crypto/ocf/kirkwood/mvHal/common/mvStack.c
@@ -38,16 +38,16 @@ modify this File under the following licensing terms.
 Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
+	* Redistributions of source code must retain the above copyright notice,
+	  this list of conditions and the following disclaimer.
 
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
+	* Redistributions in binary form must reproduce the above copyright
+	  notice, this list of conditions and the following disclaimer in the
+	  documentation and/or other materials provided with the distribution.
 
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
+	* Neither the name of Marvell nor the names of its contributors may be
+	  used to endorse or promote products derived from this software without
+	  specific prior written permission.
 
 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
@@ -62,6 +62,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
 
+
 /********************************************************************************
 * mvQueue.c
 *
diff --git a/crypto/ocf/kirkwood/mvHal/common/mvStack.h b/crypto/ocf/kirkwood/mvHal/common/mvStack.h
index c97fec0..f435239 100644
--- a/crypto/ocf/kirkwood/mvHal/common/mvStack.h
+++ b/crypto/ocf/kirkwood/mvHal/common/mvStack.h
@@ -38,16 +38,16 @@ modify this File under the following licensing terms.
 Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
 
-    *   Redistributions of source code must retain the above copyright notice,
-	    this list of conditions and the following disclaimer.
+	* Redistributions of source code must retain the above copyright notice,
+	  this list of conditions and the following disclaimer.
 
-    *   Redistributions in binary form must reproduce the above copyright
-	notice, this list of conditions and the following disclaimer in the
-	documentation and/or other materials provided with the distribution.
+	* Redistributions in binary form must reproduce the above copyright
+	  notice, this list of conditions and the following disclaimer in the
+	  documentation and/or other materials provided with the distribution.
 
-    *   Neither the name of Marvell nor the names of its contributors may be
-	used to endorse or promote products derived from this software without
-	specific prior written permission.
+	* Neither the name of Marvell nor the names of its contributors may be
+	  used to endorse or promote products derived from this software without
+	  specific prior written permission.
 
 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
@@ -62,6 +62,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 *******************************************************************************/
 
+
 /********************************************************************************
 * mvStack.h - Header File for :
 *
@@ -188,4 +189,3 @@ MV_STATUS   mvStackDelete(void* stackHndl);
 void        mvStackStatus(void* stackHndl, MV_BOOL isPrintElements);
 
 #endif /* __mvStack_h__ */
-
diff --git a/crypto/ocf/kirkwood/mvHal/common/mvTypes.h b/crypto/ocf/kirkwood/mvHal/common/mvTypes.h
index de212a1..6896771 100644
--- a/crypto/ocf/kirkwood/mvHal/common/mvTypes.h
+++ b/crypto/ocf/kirkwood/mvHal/common/mvTypes.h
@@ -242,4 +242,3 @@ typedef struct
 #endif /* MV_ASMLANGUAGE */
 
 #endif /* __INCmvTypesh */
-
diff --git a/crypto/ocf/kirkwood/mvHal/dbg-trace.c b/crypto/ocf/kirkwood/mvHal/dbg-trace.c
index 6576d35..91df96f 100644
--- a/crypto/ocf/kirkwood/mvHal/dbg-trace.c
+++ b/crypto/ocf/kirkwood/mvHal/dbg-trace.c
@@ -106,5 +106,3 @@ void TRC_RELEASE(void)
         kfree(trc_arr);
         trc_index = 0;
 }
-
-
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/boardEnv/mvBoardEnvLib.c b/crypto/ocf/kirkwood/mvHal/kw_family/boardEnv/mvBoardEnvLib.c
index 0efeee2..86dd2da 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/boardEnv/mvBoardEnvLib.c
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/boardEnv/mvBoardEnvLib.c
@@ -775,7 +775,7 @@ MV_32 mvBoarGpioPinNumGet(MV_BOARD_GPP_CLASS class, MV_U32 index)
         for (i = 0; i < BOARD_INFO(boardId)->numBoardGppInfo; i++)
 		if (BOARD_INFO(boardId)->pBoardGppInfo[i].devClass == class) {
 			if (indexFound == index)
-        			return (MV_U32)BOARD_INFO(boardId)->pBoardGppInfo[i].gppPinNum;
+				return (MV_U32)BOARD_INFO(boardId)->pBoardGppInfo[i].gppPinNum;
 			else
 				indexFound++;
 
@@ -829,7 +829,7 @@ MV_VOID	mvBoardReset(MV_VOID)
 	resetPin = mvBoardResetGpioPinGet();
 	if (resetPin != MV_ERROR)
 	{
-        	MV_REG_BIT_RESET( GPP_DATA_OUT_REG(0) ,(1 << resetPin));
+		MV_REG_BIT_RESET( GPP_DATA_OUT_REG(0) ,(1 << resetPin));
 		MV_REG_BIT_RESET( GPP_DATA_OUT_EN_REG(0) ,(1 << resetPin));
 
 	}
@@ -1095,21 +1095,21 @@ MV_VOID mvBoardMppGroupIdUpdate(MV_VOID)
 		/* Update MPP output voltage for RGMII 1.8V. Set port to GMII for GMII module */
 		if ((mvBoardMppGroupTypeGet(devClass) == MV_BOARD_RGMII))
 			MV_REG_BIT_SET(MPP_OUTPUT_DRIVE_REG,MPP_1_8_RGMII1_OUTPUT_DRIVE | MPP_1_8_RGMII0_OUTPUT_DRIVE);
-        	else
+		else
 		{
 			if ((mvBoardMppGroupTypeGet(devClass) == MV_BOARD_GMII))
-        		{
+			{
 				MV_REG_BIT_RESET(MPP_OUTPUT_DRIVE_REG, BIT7 | BIT15);
-            			MV_REG_BIT_RESET(ETH_PORT_SERIAL_CTRL_1_REG(0),BIT3);
-            			MV_REG_BIT_RESET(ETH_PORT_SERIAL_CTRL_1_REG(1),BIT3);
-        		}
-        		else if ((mvBoardMppGroupTypeGet(devClass) == MV_BOARD_MII))
-        		{
+				MV_REG_BIT_RESET(ETH_PORT_SERIAL_CTRL_1_REG(0),BIT3);
+				MV_REG_BIT_RESET(ETH_PORT_SERIAL_CTRL_1_REG(1),BIT3);
+			}
+			else if ((mvBoardMppGroupTypeGet(devClass) == MV_BOARD_MII))
+			{
 				/* Assumption that the MDC & MDIO should be 3.3V */
 				MV_REG_BIT_RESET(MPP_OUTPUT_DRIVE_REG, BIT7 | BIT15);
 				/* Assumption that only ETH1 can be MII when using modules on DB */
-            			MV_REG_BIT_RESET(ETH_PORT_SERIAL_CTRL_1_REG(1),BIT3);
-        		}
+				MV_REG_BIT_RESET(ETH_PORT_SERIAL_CTRL_1_REG(1),BIT3);
+			}
 		}
 	}
 }
@@ -1249,33 +1249,33 @@ MV_VOID mvBoardMppMuxSet(MV_VOID)
 	mvTwsiInit(0, TWSI_SPEED, mvBoardTclkGet(), &slave, 0);
 
 	/* Read MPP module ID */
-    	DB(mvOsPrintf("Board: twsi exp set\n"));
-    	twsiSlave.slaveAddr.address = mvBoardTwsiExpAddrGet(MV_BOARD_MUX_I2C_ADDR_ENTRY);
-    	twsiSlave.slaveAddr.type = mvBoardTwsiExpAddrTypeGet(MV_BOARD_MUX_I2C_ADDR_ENTRY);
-    	twsiSlave.validOffset = MV_TRUE;
+	DB(mvOsPrintf("Board: twsi exp set\n"));
+	twsiSlave.slaveAddr.address = mvBoardTwsiExpAddrGet(MV_BOARD_MUX_I2C_ADDR_ENTRY);
+	twsiSlave.slaveAddr.type = mvBoardTwsiExpAddrTypeGet(MV_BOARD_MUX_I2C_ADDR_ENTRY);
+	twsiSlave.validOffset = MV_TRUE;
 	/* Offset is the first command after the address which indicate the register number to be read
 	   in next operation */
-    	twsiSlave.offset = 2;
-    	twsiSlave.moreThen256 = MV_FALSE;
+	twsiSlave.offset = 2;
+	twsiSlave.moreThen256 = MV_FALSE;
 
 
 
-    	if( MV_OK != mvTwsiWrite (0, &twsiSlave, &muxVal, 1) )
-    	{
-    		DB(mvOsPrintf("Board: twsi exp out val fail\n"));
-        	return;
-    	}
-    	DB(mvOsPrintf("Board: twsi exp out val succeded\n"));
+	if( MV_OK != mvTwsiWrite (0, &twsiSlave, &muxVal, 1) )
+	{
+		DB(mvOsPrintf("Board: twsi exp out val fail\n"));
+		return;
+	}
+	DB(mvOsPrintf("Board: twsi exp out val succeded\n"));
 
 	/* Change twsi exp to output */
-    	twsiSlave.offset = 6;
+	twsiSlave.offset = 6;
 	muxVal = 0;
 	if( MV_OK != mvTwsiWrite (0, &twsiSlave, &muxVal, 1) )
-    	{
-    		DB(mvOsPrintf("Board: twsi exp change to out fail\n"));
-        	return;
-    	}
-    	DB(mvOsPrintf("Board: twsi exp change to out succeded\n"));
+	{
+		DB(mvOsPrintf("Board: twsi exp change to out fail\n"));
+		return;
+	}
+	DB(mvOsPrintf("Board: twsi exp change to out succeded\n"));
 
 }
 
@@ -1302,7 +1302,7 @@ MV_VOID mvBoardTdmMppSet(MV_32 chType)
 	MV_U8 muxValMask = 1;
 	MV_U8 twsiVal;
 	MV_U32 maxMppGrp = 1;
-    	MV_TWSI_SLAVE twsiSlave;
+	MV_TWSI_SLAVE twsiSlave;
 	MV_TWSI_ADDR slave;
 
 	devId = mvCtrlModelGet();
@@ -1338,14 +1338,14 @@ MV_VOID mvBoardTdmMppSet(MV_32 chType)
 	mvTwsiInit(0, TWSI_SPEED, mvBoardTclkGet(), &slave, 0);
 
 	/* Read MPP module ID */
-    	DB(mvOsPrintf("Board: twsi exp set\n"));
-    	twsiSlave.slaveAddr.address = mvBoardTwsiExpAddrGet(devClass);
-    	twsiSlave.slaveAddr.type = ADDR7_BIT;
-    	twsiSlave.validOffset = MV_TRUE;
+	DB(mvOsPrintf("Board: twsi exp set\n"));
+	twsiSlave.slaveAddr.address = mvBoardTwsiExpAddrGet(devClass);
+	twsiSlave.slaveAddr.type = ADDR7_BIT;
+	twsiSlave.validOffset = MV_TRUE;
 	/* Offset is the first command after the address which indicate the register number to be read
 	   in next operation */
-    	twsiSlave.offset = 3;
-    	twsiSlave.moreThen256 = MV_FALSE;
+	twsiSlave.offset = 3;
+	twsiSlave.moreThen256 = MV_FALSE;
 
 	if(mvBoardIdGet() == RD_88F6281A_ID)
 	{
@@ -1356,15 +1356,15 @@ MV_VOID mvBoardTdmMppSet(MV_32 chType)
 	mvTwsiRead(0, &twsiSlave, &twsiVal, 1);
         muxVal = (twsiVal & muxValMask) | muxVal;
 
-    	if( MV_OK != mvTwsiWrite (0, &twsiSlave, &muxVal, 1) )
-    	{
-    		mvOsPrintf("Board: twsi exp out val fail\n");
-        	return;
-    	}
-    	DB(mvOsPrintf("Board: twsi exp out val succeded\n"));
+	if( MV_OK != mvTwsiWrite (0, &twsiSlave, &muxVal, 1) )
+	{
+		mvOsPrintf("Board: twsi exp out val fail\n");
+		return;
+	}
+	DB(mvOsPrintf("Board: twsi exp out val succeded\n"));
 
 	/* Change twsi exp to output */
-    	twsiSlave.offset = 7;
+	twsiSlave.offset = 7;
 	muxVal = 0xfe;
 	if(mvBoardIdGet() == RD_88F6281A_ID)
 		muxVal = 0xf3;
@@ -1373,13 +1373,13 @@ MV_VOID mvBoardTdmMppSet(MV_32 chType)
 	muxVal = (twsiVal & muxVal);
 
 	if( MV_OK != mvTwsiWrite (0, &twsiSlave, &muxVal, 1) )
-    	{
-    		mvOsPrintf("Board: twsi exp change to out fail\n");
-        	return;
-    	}
-    	DB(mvOsPrintf("Board: twsi exp change to out succeded\n"));
+	{
+		mvOsPrintf("Board: twsi exp change to out fail\n");
+		return;
+	}
+	DB(mvOsPrintf("Board: twsi exp change to out succeded\n"));
 	/* reset the line to 0 */
-    	twsiSlave.offset = 3;
+	twsiSlave.offset = 3;
 	muxVal = 0;
 	muxValMask = 1;
 
@@ -1391,17 +1391,17 @@ MV_VOID mvBoardTdmMppSet(MV_32 chType)
 	mvTwsiRead(0, &twsiSlave, &twsiVal, 1);
         muxVal = (twsiVal & muxValMask) | muxVal;
 
-    	if( MV_OK != mvTwsiWrite (0, &twsiSlave, &muxVal, 1) )
-    	{
-    		mvOsPrintf("Board: twsi exp out val fail\n");
-        	return;
-    	}
-    	DB(mvOsPrintf("Board: twsi exp out val succeded\n"));
+	if( MV_OK != mvTwsiWrite (0, &twsiSlave, &muxVal, 1) )
+	{
+		mvOsPrintf("Board: twsi exp out val fail\n");
+		return;
+	}
+	DB(mvOsPrintf("Board: twsi exp out val succeded\n"));
 
 	mvOsDelay(20);
 
 	/* set the line to 1 */
-    	twsiSlave.offset = 3;
+	twsiSlave.offset = 3;
 	muxVal = 1;
 	muxValMask = 1;
 
@@ -1425,11 +1425,11 @@ MV_VOID mvBoardTdmMppSet(MV_32 chType)
 	mvTwsiRead(0, &twsiSlave, &twsiVal, 1);
         muxVal = (twsiVal & muxValMask) | muxVal;
 
-    	if( MV_OK != mvTwsiWrite (0, &twsiSlave, &muxVal, 1) )
-    	{
-    		mvOsPrintf("Board: twsi exp out val fail\n");
-        	return;
-    	}
+	if( MV_OK != mvTwsiWrite (0, &twsiSlave, &muxVal, 1) )
+	{
+		mvOsPrintf("Board: twsi exp out val fail\n");
+		return;
+	}
 
 	/* TBD - 5 channels */
 #if defined(MV_TDM_5CHANNELS)
@@ -1444,10 +1444,10 @@ MV_VOID mvBoardTdmMppSet(MV_32 chType)
 	muxVal = (twsiVal & ~BIT2);
 
 	if( MV_OK != mvTwsiWrite (0, &twsiSlave, &muxVal, 1) )
-    	{
-    		mvOsPrintf("Board: twsi exp change to out fail\n");
-        	return;
-    	}
+	{
+		mvOsPrintf("Board: twsi exp change to out fail\n");
+		return;
+	}
 
 
 	twsiSlave.offset = 2;
@@ -1456,12 +1456,12 @@ MV_VOID mvBoardTdmMppSet(MV_32 chType)
 	muxVal = (twsiVal & ~BIT2);
 
 	if( MV_OK != mvTwsiWrite (0, &twsiSlave, &muxVal, 1) )
-    	{
-    		mvOsPrintf("Board: twsi exp change to out fail\n");
-        	return;
-    	}
+	{
+		mvOsPrintf("Board: twsi exp change to out fail\n");
+		return;
+	}
 #endif
-    	DB(mvOsPrintf("Board: twsi exp out val succeded\n"));
+	DB(mvOsPrintf("Board: twsi exp out val succeded\n"));
 
 
 }
@@ -1797,7 +1797,7 @@ static MV_DEV_CS_INFO*  boardGetDevEntry(MV_32 devNum, MV_BOARD_DEV_CLASS devCla
 
 		if (BOARD_INFO(boardId)->pDevCsInfo[devIndex].devClass == devClass)
 		{
-            		if (foundIndex == devNum)
+			if (foundIndex == devNum)
 			{
 				return &(BOARD_INFO(boardId)->pDevCsInfo[devIndex]);
 			}
@@ -2164,33 +2164,33 @@ MV_U32 mvBoardIdGet(MV_VOID)
 *******************************************************************************/
 MV_BOARD_MODULE_ID_CLASS mvBoarModuleTypeGet(MV_BOARD_MPP_GROUP_CLASS devClass)
 {
-    	MV_TWSI_SLAVE twsiSlave;
+	MV_TWSI_SLAVE twsiSlave;
 	MV_TWSI_ADDR slave;
-    	MV_U8 data;
+	MV_U8 data;
 
 	/* TWSI init */
 	slave.type = ADDR7_BIT;
 	slave.address = 0;
 	mvTwsiInit(0, TWSI_SPEED, mvBoardTclkGet(), &slave, 0);
 
-    	/* Read MPP module ID */
-    	DB(mvOsPrintf("Board: Read MPP module ID\n"));
-    	twsiSlave.slaveAddr.address = mvBoardTwsiExpAddrGet(devClass);
-    	twsiSlave.slaveAddr.type = mvBoardTwsiExpAddrTypeGet(devClass);
-    	twsiSlave.validOffset = MV_TRUE;
+	/* Read MPP module ID */
+	DB(mvOsPrintf("Board: Read MPP module ID\n"));
+	twsiSlave.slaveAddr.address = mvBoardTwsiExpAddrGet(devClass);
+	twsiSlave.slaveAddr.type = mvBoardTwsiExpAddrTypeGet(devClass);
+	twsiSlave.validOffset = MV_TRUE;
 	/* Offset is the first command after the address which indicate the register number to be read
 	   in next operation */
-    	twsiSlave.offset = 0;
-    	twsiSlave.moreThen256 = MV_FALSE;
+	twsiSlave.offset = 0;
+	twsiSlave.moreThen256 = MV_FALSE;
 
 
 
-    	if( MV_OK != mvTwsiRead (0, &twsiSlave, &data, 1) )
-    	{
-    		DB(mvOsPrintf("Board: Read MPP module ID fail\n"));
-        	return MV_ERROR;
-    	}
-    	DB(mvOsPrintf("Board: Read MPP module ID succeded\n"));
+	if( MV_OK != mvTwsiRead (0, &twsiSlave, &data, 1) )
+	{
+		DB(mvOsPrintf("Board: Read MPP module ID fail\n"));
+		return MV_ERROR;
+	}
+	DB(mvOsPrintf("Board: Read MPP module ID succeded\n"));
 
 	return data;
 }
@@ -2213,30 +2213,30 @@ MV_BOARD_MODULE_ID_CLASS mvBoarModuleTypeGet(MV_BOARD_MPP_GROUP_CLASS devClass)
 *******************************************************************************/
 MV_U8 mvBoarTwsiSatRGet(MV_U8 devNum, MV_U8 regNum)
 {
-    	MV_TWSI_SLAVE twsiSlave;
+	MV_TWSI_SLAVE twsiSlave;
 	MV_TWSI_ADDR slave;
-    	MV_U8 data;
+	MV_U8 data;
 
 	/* TWSI init */
 	slave.type = ADDR7_BIT;
 	slave.address = 0;
 	mvTwsiInit(0, TWSI_SPEED, mvBoardTclkGet(), &slave, 0);
 
-    	/* Read MPP module ID */
-    	DB(mvOsPrintf("Board: Read S@R device read\n"));
-    	twsiSlave.slaveAddr.address = mvBoardTwsiSatRAddrGet(devNum);
-    	twsiSlave.slaveAddr.type = mvBoardTwsiSatRAddrTypeGet(devNum);
-    	twsiSlave.validOffset = MV_TRUE;
+	/* Read MPP module ID */
+	DB(mvOsPrintf("Board: Read S@R device read\n"));
+	twsiSlave.slaveAddr.address = mvBoardTwsiSatRAddrGet(devNum);
+	twsiSlave.slaveAddr.type = mvBoardTwsiSatRAddrTypeGet(devNum);
+	twsiSlave.validOffset = MV_TRUE;
 	/* Use offset as command */
-    	twsiSlave.offset = regNum;
-    	twsiSlave.moreThen256 = MV_FALSE;
+	twsiSlave.offset = regNum;
+	twsiSlave.moreThen256 = MV_FALSE;
 
-    	if( MV_OK != mvTwsiRead (0, &twsiSlave, &data, 1) )
-    	{
-    		DB(mvOsPrintf("Board: Read S@R fail\n"));
-        	return MV_ERROR;
-    	}
-    	DB(mvOsPrintf("Board: Read S@R succeded\n"));
+	if( MV_OK != mvTwsiRead (0, &twsiSlave, &data, 1) )
+	{
+		DB(mvOsPrintf("Board: Read S@R fail\n"));
+		return MV_ERROR;
+	}
+	DB(mvOsPrintf("Board: Read S@R succeded\n"));
 
 	return data;
 }
@@ -2261,7 +2261,7 @@ MV_U8 mvBoarTwsiSatRGet(MV_U8 devNum, MV_U8 regNum)
 *******************************************************************************/
 MV_STATUS mvBoarTwsiSatRSet(MV_U8 devNum, MV_U8 regNum, MV_U8 regVal)
 {
-    	MV_TWSI_SLAVE twsiSlave;
+	MV_TWSI_SLAVE twsiSlave;
 	MV_TWSI_ADDR slave;
 
 	/* TWSI init */
@@ -2269,21 +2269,21 @@ MV_STATUS mvBoarTwsiSatRSet(MV_U8 devNum, MV_U8 regNum, MV_U8 regVal)
 	slave.address = 0;
 	mvTwsiInit(0, TWSI_SPEED, mvBoardTclkGet(), &slave, 0);
 
-    	/* Read MPP module ID */
-    	twsiSlave.slaveAddr.address = mvBoardTwsiSatRAddrGet(devNum);
-    	twsiSlave.slaveAddr.type = mvBoardTwsiSatRAddrTypeGet(devNum);
-    	twsiSlave.validOffset = MV_TRUE;
-    	DB(mvOsPrintf("Board: Write S@R device addr %x, type %x, data %x\n", twsiSlave.slaveAddr.address,\
+	/* Read MPP module ID */
+	twsiSlave.slaveAddr.address = mvBoardTwsiSatRAddrGet(devNum);
+	twsiSlave.slaveAddr.type = mvBoardTwsiSatRAddrTypeGet(devNum);
+	twsiSlave.validOffset = MV_TRUE;
+	DB(mvOsPrintf("Board: Write S@R device addr %x, type %x, data %x\n", twsiSlave.slaveAddr.address,\
 								twsiSlave.slaveAddr.type, regVal));
 	/* Use offset as command */
-    	twsiSlave.offset = regNum;
-    	twsiSlave.moreThen256 = MV_FALSE;
-    	if( MV_OK != mvTwsiWrite (0, &twsiSlave, &regVal, 1) )
-    	{
-    		DB(mvOsPrintf("Board: Write S@R fail\n"));
-        	return MV_ERROR;
-    	}
-    	DB(mvOsPrintf("Board: Write S@R succeded\n"));
+	twsiSlave.offset = regNum;
+	twsiSlave.moreThen256 = MV_FALSE;
+	if( MV_OK != mvTwsiWrite (0, &twsiSlave, &regVal, 1) )
+	{
+		DB(mvOsPrintf("Board: Write S@R fail\n"));
+		return MV_ERROR;
+	}
+	DB(mvOsPrintf("Board: Write S@R succeded\n"));
 
 	return MV_OK;
 }
@@ -2336,7 +2336,7 @@ MV_STATUS mvBoardFanPowerControl(MV_BOOL mode)
 {
 
 	MV_U8 val = 1, twsiVal;
-   	MV_TWSI_SLAVE twsiSlave;
+	MV_TWSI_SLAVE twsiSlave;
 	MV_TWSI_ADDR slave;
 
 	if(mvBoardIdGet() != RD_88F6281A_ID)
@@ -2348,14 +2348,14 @@ MV_STATUS mvBoardFanPowerControl(MV_BOOL mode)
 	mvTwsiInit(0, TWSI_SPEED, mvBoardTclkGet(), &slave, 0);
 
 	/* Read MPP module ID */
-    	DB(mvOsPrintf("Board: twsi exp set\n"));
-    	twsiSlave.slaveAddr.address = mvBoardTwsiExpAddrGet(1);
-    	twsiSlave.slaveAddr.type = ADDR7_BIT;
-    	twsiSlave.validOffset = MV_TRUE;
+	DB(mvOsPrintf("Board: twsi exp set\n"));
+	twsiSlave.slaveAddr.address = mvBoardTwsiExpAddrGet(1);
+	twsiSlave.slaveAddr.type = ADDR7_BIT;
+	twsiSlave.validOffset = MV_TRUE;
 	/* Offset is the first command after the address which indicate the register number to be read
 	   in next operation */
-    	twsiSlave.offset = 3;
-    	twsiSlave.moreThen256 = MV_FALSE;
+	twsiSlave.offset = 3;
+	twsiSlave.moreThen256 = MV_FALSE;
         if(mode == MV_TRUE)
             val = 0x1;
         else
@@ -2364,22 +2364,22 @@ MV_STATUS mvBoardFanPowerControl(MV_BOOL mode)
         val = (twsiVal & 0xfe) | val;
 
         if( MV_OK != mvTwsiWrite (0, &twsiSlave, &val, 1) )
-    	{
-    		DB(mvOsPrintf("Board: twsi exp out val fail\n"));
-        	return MV_ERROR;
-    	}
-    	DB(mvOsPrintf("Board: twsi exp out val succeded\n"));
+	{
+		DB(mvOsPrintf("Board: twsi exp out val fail\n"));
+		return MV_ERROR;
+	}
+	DB(mvOsPrintf("Board: twsi exp out val succeded\n"));
 
 	/* Change twsi exp to output */
-    	twsiSlave.offset = 7;
+	twsiSlave.offset = 7;
         mvTwsiRead(0, &twsiSlave, &twsiVal, 1);
         val = (twsiVal & 0xfe);
-    	if( MV_OK != mvTwsiWrite (0, &twsiSlave, &val, 1) )
-    	{
-    		DB(mvOsPrintf("Board: twsi exp change to out fail\n"));
-        	return MV_ERROR;
-    	}
-    	DB(mvOsPrintf("Board: twsi exp change to out succeded\n"));
+	if( MV_OK != mvTwsiWrite (0, &twsiSlave, &val, 1) )
+	{
+		DB(mvOsPrintf("Board: twsi exp change to out fail\n"));
+		return MV_ERROR;
+	}
+	DB(mvOsPrintf("Board: twsi exp change to out succeded\n"));
         return MV_OK;
 }
 
@@ -2401,7 +2401,7 @@ MV_STATUS mvBoardHDDPowerControl(MV_BOOL mode)
 {
 
 	MV_U8 val = 1, twsiVal;
-   	MV_TWSI_SLAVE twsiSlave;
+	MV_TWSI_SLAVE twsiSlave;
 	MV_TWSI_ADDR slave;
 
 	if(mvBoardIdGet() != RD_88F6281A_ID)
@@ -2413,37 +2413,37 @@ MV_STATUS mvBoardHDDPowerControl(MV_BOOL mode)
 	mvTwsiInit(0, TWSI_SPEED, mvBoardTclkGet(), &slave, 0);
 
 	/* Read MPP module ID */
-    	DB(mvOsPrintf("Board: twsi exp set\n"));
-    	twsiSlave.slaveAddr.address = mvBoardTwsiExpAddrGet(1);
-    	twsiSlave.slaveAddr.type = ADDR7_BIT;
-    	twsiSlave.validOffset = MV_TRUE;
+	DB(mvOsPrintf("Board: twsi exp set\n"));
+	twsiSlave.slaveAddr.address = mvBoardTwsiExpAddrGet(1);
+	twsiSlave.slaveAddr.type = ADDR7_BIT;
+	twsiSlave.validOffset = MV_TRUE;
 	/* Offset is the first command after the address which indicate the register number to be read
 	   in next operation */
-    	twsiSlave.offset = 3;
-    	twsiSlave.moreThen256 = MV_FALSE;
+	twsiSlave.offset = 3;
+	twsiSlave.moreThen256 = MV_FALSE;
         if(mode == MV_TRUE)
             val = 0x2;
         else
             val = 0;
         mvTwsiRead(0, &twsiSlave, &twsiVal, 1);
         val = (twsiVal & 0xfd) | val;
-    	if( MV_OK != mvTwsiWrite (0, &twsiSlave, &val, 1) )
-    	{
-    		DB(mvOsPrintf("Board: twsi exp out val fail\n"));
-        	return MV_ERROR;
-    	}
-    	DB(mvOsPrintf("Board: twsi exp out val succeded\n"));
+	if( MV_OK != mvTwsiWrite (0, &twsiSlave, &val, 1) )
+	{
+		DB(mvOsPrintf("Board: twsi exp out val fail\n"));
+		return MV_ERROR;
+	}
+	DB(mvOsPrintf("Board: twsi exp out val succeded\n"));
 
 	/* Change twsi exp to output */
-    	twsiSlave.offset = 7;
+	twsiSlave.offset = 7;
         mvTwsiRead(0, &twsiSlave, &twsiVal, 1);
         val = (twsiVal & 0xfd);
-    	if( MV_OK != mvTwsiWrite (0, &twsiSlave, &val, 1) )
-    	{
-    		DB(mvOsPrintf("Board: twsi exp change to out fail\n"));
-        	return MV_ERROR;
-    	}
-    	DB(mvOsPrintf("Board: twsi exp change to out succeded\n"));
+	if( MV_OK != mvTwsiWrite (0, &twsiSlave, &val, 1) )
+	{
+		DB(mvOsPrintf("Board: twsi exp change to out fail\n"));
+		return MV_ERROR;
+	}
+	DB(mvOsPrintf("Board: twsi exp change to out succeded\n"));
         return MV_OK;
 }
 
@@ -2465,7 +2465,7 @@ MV_STATUS mvBoardSDioWPControl(MV_BOOL mode)
 {
 
 	MV_U8 val = 1, twsiVal;
-   	MV_TWSI_SLAVE twsiSlave;
+	MV_TWSI_SLAVE twsiSlave;
 	MV_TWSI_ADDR slave;
 
 	if(mvBoardIdGet() != RD_88F6281A_ID)
@@ -2477,37 +2477,36 @@ MV_STATUS mvBoardSDioWPControl(MV_BOOL mode)
 	mvTwsiInit(0, TWSI_SPEED, mvBoardTclkGet(), &slave, 0);
 
 	/* Read MPP module ID */
-    	DB(mvOsPrintf("Board: twsi exp set\n"));
-    	twsiSlave.slaveAddr.address = mvBoardTwsiExpAddrGet(0);
-    	twsiSlave.slaveAddr.type = ADDR7_BIT;
-    	twsiSlave.validOffset = MV_TRUE;
+	DB(mvOsPrintf("Board: twsi exp set\n"));
+	twsiSlave.slaveAddr.address = mvBoardTwsiExpAddrGet(0);
+	twsiSlave.slaveAddr.type = ADDR7_BIT;
+	twsiSlave.validOffset = MV_TRUE;
 	/* Offset is the first command after the address which indicate the register number to be read
 	   in next operation */
-    	twsiSlave.offset = 3;
-    	twsiSlave.moreThen256 = MV_FALSE;
+	twsiSlave.offset = 3;
+	twsiSlave.moreThen256 = MV_FALSE;
         if(mode == MV_TRUE)
             val = 0x10;
         else
             val = 0;
         mvTwsiRead(0, &twsiSlave, &twsiVal, 1);
         val = (twsiVal & 0xef) | val;
-    	if( MV_OK != mvTwsiWrite (0, &twsiSlave, &val, 1) )
-    	{
-    		DB(mvOsPrintf("Board: twsi exp out val fail\n"));
-        	return MV_ERROR;
-    	}
-    	DB(mvOsPrintf("Board: twsi exp out val succeded\n"));
+	if( MV_OK != mvTwsiWrite (0, &twsiSlave, &val, 1) )
+	{
+		DB(mvOsPrintf("Board: twsi exp out val fail\n"));
+		return MV_ERROR;
+	}
+	DB(mvOsPrintf("Board: twsi exp out val succeded\n"));
 
 	/* Change twsi exp to output */
-    	twsiSlave.offset = 7;
+	twsiSlave.offset = 7;
         mvTwsiRead(0, &twsiSlave, &twsiVal, 1);
         val = (twsiVal & 0xef);
-    	if( MV_OK != mvTwsiWrite (0, &twsiSlave, &val, 1) )
-    	{
-    		DB(mvOsPrintf("Board: twsi exp change to out fail\n"));
-        	return MV_ERROR;
-    	}
-    	DB(mvOsPrintf("Board: twsi exp change to out succeded\n"));
+	if( MV_OK != mvTwsiWrite (0, &twsiSlave, &val, 1) )
+	{
+		DB(mvOsPrintf("Board: twsi exp change to out fail\n"));
+		return MV_ERROR;
+	}
+	DB(mvOsPrintf("Board: twsi exp change to out succeded\n"));
         return MV_OK;
 }
-
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/boardEnv/mvBoardEnvLib.h b/crypto/ocf/kirkwood/mvHal/kw_family/boardEnv/mvBoardEnvLib.h
index b7ee2e7..259aa59 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/boardEnv/mvBoardEnvLib.h
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/boardEnv/mvBoardEnvLib.h
@@ -276,17 +276,17 @@ typedef struct _boardInfo
 	MV_BOARD_MPP_TYPE_INFO*		pBoardMppTypeValue;
 	MV_U8				numBoardMppConfigValue;
 	MV_BOARD_MPP_INFO*		pBoardMppConfigValue;
-    	MV_U32				intsGppMaskLow;
+	MV_U32				intsGppMaskLow;
 	MV_U32				intsGppMaskHigh;
 	MV_U8				numBoardDeviceIf;
-    	MV_DEV_CS_INFO*			pDevCsInfo;
+	MV_DEV_CS_INFO*			pDevCsInfo;
 	MV_U8				numBoardTwsiDev;
 	MV_BOARD_TWSI_INFO*		pBoardTwsiDev;
 	MV_U8				numBoardMacInfo;
 	MV_BOARD_MAC_INFO*		pBoardMacInfo;
 	MV_U8				numBoardGppInfo;
 	MV_BOARD_GPP_INFO*		pBoardGppInfo;
-    	MV_U8				activeLedsNumber;
+	MV_U8				activeLedsNumber;
 	MV_U8*				pLedGppPin;
 	MV_U8				ledsPolarity;	/* '0' or '1' to turn on led */
 	/* GPP values */
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/boardEnv/mvBoardEnvSpec.c b/crypto/ocf/kirkwood/mvHal/kw_family/boardEnv/mvBoardEnvSpec.c
index e5246f3..c9260af 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/boardEnv/mvBoardEnvSpec.c
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/boardEnv/mvBoardEnvSpec.c
@@ -103,7 +103,7 @@ MV_BOARD_MAC_INFO db88f6281AInfoBoardMacInfo[] =
 
 MV_BOARD_MPP_TYPE_INFO db88f6281AInfoBoardMppTypeInfo[] =
 	/* {{MV_BOARD_MPP_TYPE_CLASS	boardMppGroup1,
- 		MV_BOARD_MPP_TYPE_CLASS	boardMppGroup2}} */
+		MV_BOARD_MPP_TYPE_CLASS	boardMppGroup2}} */
 	{{MV_BOARD_AUTO, MV_BOARD_AUTO}
 	};
 
@@ -306,7 +306,7 @@ MV_BOARD_MAC_INFO db88f6192AInfoBoardMacInfo[] =
 
 MV_BOARD_MPP_TYPE_INFO db88f6192AInfoBoardMppTypeInfo[] =
 	/* {{MV_BOARD_MPP_TYPE_CLASS	boardMppGroup1,
- 		MV_BOARD_MPP_TYPE_CLASS	boardMppGroup2}} */
+		MV_BOARD_MPP_TYPE_CLASS	boardMppGroup2}} */
 	{{MV_BOARD_AUTO, MV_BOARD_OTHER}
 	};
 
@@ -417,7 +417,7 @@ MV_BOARD_MAC_INFO rd88f6192AInfoBoardMacInfo[] =
 
 MV_BOARD_MPP_TYPE_INFO rd88f6192AInfoBoardMppTypeInfo[] =
 	/* {{MV_BOARD_MPP_TYPE_CLASS	boardMppGroup1,
- 		MV_BOARD_MPP_TYPE_CLASS	boardMppGroup2}} */
+		MV_BOARD_MPP_TYPE_CLASS	boardMppGroup2}} */
 	{{MV_BOARD_OTHER, MV_BOARD_OTHER}
 	};
 
@@ -542,7 +542,7 @@ MV_BOARD_GPP_INFO db88f6180AInfoBoardGppInfo[] =
 
 MV_BOARD_MPP_TYPE_INFO db88f6180AInfoBoardMppTypeInfo[] =
 	/* {{MV_BOARD_MPP_TYPE_CLASS	boardMppGroup1,
- 		MV_BOARD_MPP_TYPE_CLASS	boardMppGroup2}} */
+		MV_BOARD_MPP_TYPE_CLASS	boardMppGroup2}} */
 	{{MV_BOARD_OTHER, MV_BOARD_AUTO}
 	};
 
@@ -844,5 +844,3 @@ MV_BOARD_INFO*	boardInfoTbl[] = 	{
                     &dbCustomerInfo,
                     &sheevaPlugInfo
 					};
-
-
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvAddrDec.c b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvAddrDec.c
index fcc66c4..20bd3a3 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvAddrDec.c
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvAddrDec.c
@@ -291,6 +291,3 @@ MV_STATUS mvCtrlParamsToAddrDec(MV_DEC_WIN_PARAMS *pWinParam,
 
     return MV_OK;
 }
-
-
-
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvLib.c b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvLib.c
index 15db1e6..6c9da6c 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvLib.c
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvLib.c
@@ -131,7 +131,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *******************************************************************************/
 MV_STATUS mvCtrlEnvInit(MV_VOID)
 {
-    	MV_U32 mppGroup;
+	MV_U32 mppGroup;
 	MV_U32 devId;
 	MV_U32 boardId;
 	MV_U32 i;
@@ -224,32 +224,32 @@ MV_STATUS mvCtrlEnvInit(MV_VOID)
     if (devId != MV_6180_DEV_ID)
     {
         i = 0;
-    	for (mppGroup = 2; mppGroup < 5; mppGroup++)
-    	{
-    		if ((mppGroupType == MV_BOARD_OTHER) ||
-    			(boardId == RD_88F6281A_ID) ||
-    			(boardId == RD_88F6192A_ID) ||
+	for (mppGroup = 2; mppGroup < 5; mppGroup++)
+	{
+		if ((mppGroupType == MV_BOARD_OTHER) ||
+			(boardId == RD_88F6281A_ID) ||
+			(boardId == RD_88F6192A_ID) ||
                 (boardId == RD_88F6190A_ID) ||
                 (boardId == RD_88F6281A_PCAC_ID) ||
                 (boardId == SHEEVA_PLUG_ID))
-    			mppVal = mvBoardMppGet(mppGroup);
-    		else
-    		{
-    			mppVal = mppGroup1[mppGroupType][i];
-    			i++;
-    		}
-
-    		/* Group 2 is shared mpp[23:16] */
-    		if (mppGroup == 2)
-    		{
+			mppVal = mvBoardMppGet(mppGroup);
+		else
+		{
+			mppVal = mppGroup1[mppGroupType][i];
+			i++;
+		}
+
+		/* Group 2 is shared mpp[23:16] */
+		if (mppGroup == 2)
+		{
                 bootVal = MV_REG_READ(mvCtrlMppRegGet(mppGroup));
-    			mppVal &= ~0xffff;
-    			bootVal &= 0xffff;
-    			mppVal |= bootVal;
-    		}
+			mppVal &= ~0xffff;
+			bootVal &= 0xffff;
+			mppVal |= bootVal;
+		}
 
-    		MV_REG_WRITE(mvCtrlMppRegGet(mppGroup), mppVal);
-    	}
+		MV_REG_WRITE(mvCtrlMppRegGet(mppGroup), mppVal);
+	}
     }
 
 	if ((devId == MV_6192_DEV_ID) || (devId == MV_6190_DEV_ID))
@@ -965,7 +965,7 @@ MV_VOID mvCtrlAddrDecShow(MV_VOID)
 	mvPexAddrDecShow();
 #endif
 #if defined(MV_INCLUDE_USB)
-    	mvUsbAddrDecShow();
+	mvUsbAddrDecShow();
 #endif
 #if defined(MV_INCLUDE_GIG_ETH)
 	mvEthAddrDecShow();
@@ -1079,7 +1079,7 @@ MV_U32	ctrlSizeToReg(MV_U32 size, MV_U32 alignment)
 *******************************************************************************/
 MV_U32	ctrlRegToSize(MV_U32 regSize, MV_U32 alignment)
 {
-   	MV_U32 temp;
+	MV_U32 temp;
 
 	/* Check that LSB to MSB is sequence of 1's followed by sequence of 0's		*/
 	temp = regSize;		/* Now the size is a sequance of '1': 0x00ff		*/
@@ -1093,7 +1093,7 @@ MV_U32	ctrlRegToSize(MV_U32 regSize, MV_U32 alignment)
 	{
 		DB(mvOsPrintf("ctrlRegToSize: ERR. Size parameter 0x%x invalid.\n",
 					regSize));
-	   	return -1;
+		return -1;
 	}
 
 
@@ -1821,5 +1821,3 @@ MV_VOID   mvMPPConfigToDefault(MV_VOID)
 
     MV_REG_WRITE(mvCtrlMppRegGet(0), mppVal);
 }
-
-
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvLib.h b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvLib.h
index ec098f8..2c7e8fa 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvLib.h
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvLib.h
@@ -107,10 +107,10 @@ typedef enum _mvSwapType
 /* For example, Read only premission is presented as "1" in register field. */
 typedef enum _mvAccessRights
 {
-    	NO_ACCESS_ALLOWED = 0,  /* No access allowed            */
-    	READ_ONLY         = 1,  /* Read only permission         */
+	NO_ACCESS_ALLOWED = 0,  /* No access allowed            */
+	READ_ONLY         = 1,  /* Read only permission         */
 	ACC_RESERVED	  = 2,	/* Reserved access right		*/
-    	FULL_ACCESS       = 3,  /* Read and Write permission    */
+	FULL_ACCESS       = 3,  /* Read and Write permission    */
 	MAX_ACC_RIGHTS
 }MV_ACCESS_RIGHTS;
 
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvRegs.h b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvRegs.h
index 2ea281a..34b805f 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvRegs.h
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/mvCtrlEnvRegs.h
@@ -244,9 +244,9 @@ extern "C" {
 #ifndef MV_ASMLANGUAGE
 /* CPU clock for 6281,6192  0->Resereved */
 #define MV_CPU_CLCK_TBL { 	0,		0, 		0, 		0,	\
-			     	600000000, 	0,		800000000,	1000000000,	\
-			     	0,	 	1200000000,	0,		0,		\
-			     	1500000000,	0,		0,		0}
+				600000000, 	0,		800000000,	1000000000,	\
+				0,	 	1200000000,	0,		0,		\
+				1500000000,	0,		0,		0}
 
 /* DDR clock RATIO for 6281,6192 {0,0}->Reserved */
 #define MV_DDR_CLCK_RTIO_TBL	{\
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvAhbToMbus.c b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvAhbToMbus.c
index d21bb07..00f8f71 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvAhbToMbus.c
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvAhbToMbus.c
@@ -990,7 +990,7 @@ static MV_STATUS ahbToMbusRemapRegOffsGet(MV_U32 winNum,
 
 			DB(mvOsPrintf("ahbToMbusRemapRegOffsGet: ERR. Invalid winNum %d\n",
 						winNum));
-		   	return MV_NO_SUCH;
+			return MV_NO_SUCH;
 		}
 	}
 
@@ -1033,7 +1033,7 @@ MV_VOID mvAhbToMbusAddDecShow(MV_VOID)
 			{
 				mvOsOutput( "%s base %08x, ",
 				mvCtrlTargetNameGet(win.target), win.addrWin.baseLow );
-                		mvOsOutput( "...." );
+				mvOsOutput( "...." );
 				mvSizePrint( win.addrWin.size );
 
 				mvOsOutput( "\n" );
@@ -1045,4 +1045,3 @@ MV_VOID mvAhbToMbusAddDecShow(MV_VOID)
 	}
 
 }
-
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvAhbToMbusRegs.h b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvAhbToMbusRegs.h
index 518b9d1..fd3c95f 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvAhbToMbusRegs.h
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvAhbToMbusRegs.h
@@ -140,4 +140,3 @@ target_addr[63:32] = (RemapHigh[31:0]
 
 
 #endif /* __INCmvAhbToMbusRegsh */
-
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvCpuIf.c b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvCpuIf.c
index 8a72ded..fff4529 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvCpuIf.c
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvCpuIf.c
@@ -134,7 +134,7 @@ MV_STATUS mvCpuIfInit(MV_CPU_DEC_WIN *cpuAddrWinMap)
 
 	/* First disable all CPU target windows  */
 	for (target = 0; cpuAddrWinMap[target].enable != TBL_TERM; target++)
-    	{
+	{
 		if ((MV_TARGET_IS_DRAM(target))||(target == INTER_REGS))
 		{
 			continue;
@@ -156,7 +156,7 @@ MV_STATUS mvCpuIfInit(MV_CPU_DEC_WIN *cpuAddrWinMap)
 		}
 #endif
 #if defined(MV_RUN_FROM_FLASH)
-        	/* Don't disable the boot device.                               */
+		/* Don't disable the boot device.                               */
 		if (target == DEV_BOOCS)
 		{
 			continue;
@@ -166,8 +166,8 @@ MV_STATUS mvCpuIfInit(MV_CPU_DEC_WIN *cpuAddrWinMap)
 	}
 
 #if defined(MV_RUN_FROM_FLASH)
-    	/* Resize the bootcs windows before other windows, because this     */
-    	/* window is enabled and will cause an overlap if not resized.      */
+	/* Resize the bootcs windows before other windows, because this     */
+	/* window is enabled and will cause an overlap if not resized.      */
 	target = DEV_BOOCS;
 
 	if (MV_OK != mvCpuIfTargetWinSet(target, &cpuAddrWinMap[target]))
@@ -188,7 +188,7 @@ MV_STATUS mvCpuIfInit(MV_CPU_DEC_WIN *cpuAddrWinMap)
 
 	/* Go through all targets in user table until table terminator			*/
 	for (target = 0; cpuAddrWinMap[target].enable != TBL_TERM; target++)
-    	{
+	{
 
 #if defined(MV_RUN_FROM_FLASH)
 	if (target == DEV_BOOCS)
@@ -305,10 +305,10 @@ MV_STATUS mvCpuIfTargetWinSet(MV_TARGET target, MV_CPU_DEC_WIN *pAddrDecWin)
 		return MV_ERROR;
 	}
 
-    	/* 2) Check if the requested window overlaps with current windows		*/
-    	if (MV_TRUE == cpuTargetWinOverlap(target, &pAddrDecWin->addrWin))
+	/* 2) Check if the requested window overlaps with current windows		*/
+	if (MV_TRUE == cpuTargetWinOverlap(target, &pAddrDecWin->addrWin))
 	{
-        	mvOsPrintf("mvCpuIfTargetWinSet: ERR. Target %d overlap\n", target);
+		mvOsPrintf("mvCpuIfTargetWinSet: ERR. Target %d overlap\n", target);
 		return MV_BAD_PARAM;
 	}
 
@@ -1032,5 +1032,3 @@ MV_VOID mvCpuIfEnablePex(MV_U32 pexIf, MV_PEX_TYPE pexType)
 	MV_REG_BIT_SET(CPU_CTRL_STAT_REG,CCSR_PCI_ACCESS_MASK);
 }
 #endif
-
-
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvCpuIfRegs.h b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvCpuIfRegs.h
index 20b4a46..6830bb0 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvCpuIfRegs.h
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvCpuIfRegs.h
@@ -301,4 +301,3 @@ while ARM boot is still in progress
 #define CPU_CTRL_STAT_DEFAULT                   (CCSR_PCI_ACCESS_ENABLE)
 
 #endif /* __INCmvCpuIfRegsh */
-
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysAudio.c b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysAudio.c
index 8475956..96d5956 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysAudio.c
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysAudio.c
@@ -321,4 +321,3 @@ MV_STATUS mvAudioInit(MV_VOID)
 
     return MV_OK;
 }
-
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysAudio.h b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysAudio.h
index 216d797..f30611e 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysAudio.h
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysAudio.h
@@ -120,4 +120,3 @@ MV_VOID   mvAudioAddrDecShow(MV_VOID);
 
 
 #endif
-
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysDram.c b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysDram.c
index f2e34ad..8283dcf 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysDram.c
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysDram.c
@@ -207,7 +207,7 @@ MV_STATUS mvDramIfWinGet(MV_TARGET target, MV_DRAM_DEC_WIN *pAddrDecWin)
 	pAddrDecWin->addrWin.size = ctrlRegToSize(sizeRegVal,
 							SCSR_SIZE_ALIGNMENT);
 
-    	/* Check if ctrlRegToSize returned OK */
+	/* Check if ctrlRegToSize returned OK */
 	if (-1 == pAddrDecWin->addrWin.size)
 	{
 		mvOsPrintf("mvDramIfWinGet: size of target %d is Illigal\n", target);
@@ -345,4 +345,3 @@ static MV_BOOL sdramIfWinOverlap(MV_TARGET target, MV_ADDR_WIN *pAddrWin)
 
 	return MV_FALSE;
 }
-
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysPex.c b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysPex.c
index 65a9740..62423bc 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysPex.c
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysPex.c
@@ -1693,5 +1693,3 @@ MV_VOID mvPexAddrDecShow(MV_VOID)
 
 	}
 }
-
-
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysSata.c b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysSata.c
index 4c0485f..eed8cba 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysSata.c
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysSata.c
@@ -425,6 +425,3 @@ MV_STATUS mvSataWinInit(MV_VOID)
     }
     return MV_OK;
 }
-
-
-
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysSata.h b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysSata.h
index e401992..0ee55de 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysSata.h
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysSata.h
@@ -121,8 +121,3 @@ MV_VOID   mvSataAddrDecShow(MV_VOID);
 
 
 #endif
-
-
-
-
-
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysSdmmc.c b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysSdmmc.c
index 682f6f1..e61d5e0 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysSdmmc.c
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysSdmmc.c
@@ -422,6 +422,3 @@ MV_STATUS mvSdmmcWinInit(MV_VOID)
     }
     return MV_OK;
 }
-
-
-
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysSdmmc.h b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysSdmmc.h
index f8357c1..d52d19e 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysSdmmc.h
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysSdmmc.h
@@ -118,8 +118,3 @@ MV_VOID   mvSdmmcAddrDecShow(MV_VOID);
 
 
 #endif
-
-
-
-
-
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysTdm.c b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysTdm.c
index 680f710..2f56e60 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysTdm.c
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysTdm.c
@@ -193,8 +193,8 @@ MV_STATUS mvTdmWinSet(MV_U32 winNum, MV_TDM_DEC_WIN *pAddrDecWin)
 
     /* Check if the requested window overlapps with current windows         */
     if (MV_TRUE == tdmWinOverlapDetect(winNum, &pAddrDecWin->addrWin))
-   	{
-       	mvOsPrintf("mvTdmWinSet: ERR. Window %d overlap\n", winNum);
+	{
+	mvOsPrintf("mvTdmWinSet: ERR. Window %d overlap\n", winNum);
 		return MV_ERROR;
 	}
 
@@ -401,7 +401,7 @@ static MV_STATUS tdmWinOverlapDetect(MV_U32 winNum, MV_ADDR_WIN *pAddrWin)
 			if (MV_OK != mvTdmWinGet(winNumIndex, &addrDecWin))
 			{
 				DB(mvOsPrintf("dmaWinOverlapDetect: ERR. TargetWinGet failed\n"));
-            		return MV_ERROR;
+			return MV_ERROR;
 			}
 
 			if (MV_TRUE == ctrlWinOverlapTest(pAddrWin, &(addrDecWin.addrWin)))
@@ -459,4 +459,3 @@ MV_VOID mvTdmAddrDecShow(MV_VOID)
 		}
 	}
 }
-
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysTdm.h b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysTdm.h
index 3603095..88810ff 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysTdm.h
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysTdm.h
@@ -103,4 +103,3 @@ MV_VOID mvTdmAddrDecShow(MV_VOID);
 #define TDM_BASE_MASK		(0xffff<<TDM_BASE_OFFS)
 
 #endif /*__INCmvSysTdmh*/
-
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysUsb.c b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysUsb.c
index 195b5e1..0e552e6 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysUsb.c
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysUsb.c
@@ -493,5 +493,3 @@ MV_VOID mvUsbAddrDecShow(MV_VOID)
         }
     }
 }
-
-
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysXor.c b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysXor.c
index 9f0a52a..01bc362 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysXor.c
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/ctrlEnv/sys/mvSysXor.c
@@ -324,7 +324,7 @@ MV_STATUS mvXorTargetWinGet(MV_U32 unit,MV_U32 winNum, MV_XOR_DEC_WIN *pAddrDecW
 
     for (chan = 0; chan < MV_XOR_MAX_CHAN_PER_UNIT; chan++) /* we should scan here all channels per unit */
     {
-    	/* Check if enable bit is equal for all channels */
+	/* Check if enable bit is equal for all channels */
         if ((MV_REG_READ(XOR_WINDOW_CTRL_REG(unit,chan)) &
              XEXWCR_WIN_EN_MASK(winNum)) != chanWinEn)
         {
diff --git a/crypto/ocf/kirkwood/mvHal/kw_family/device/mvDevice.c b/crypto/ocf/kirkwood/mvHal/kw_family/device/mvDevice.c
index a327944..722971f 100644
--- a/crypto/ocf/kirkwood/mvHal/kw_family/device/mvDevice.c
+++ b/crypto/ocf/kirkwood/mvHal/kw_family/device/mvDevice.c
@@ -70,6 +70,3 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #else
 	#define DB(x)
 #endif
-
-
-
diff --git a/crypto/ocf/kirkwood/mvHal/linux_oss/mvOs.c b/crypto/ocf/kirkwood/mvHal/linux_oss/mvOs.c
index 749b885..ecd9d60 100644
--- a/crypto/ocf/kirkwood/mvHal/linux_oss/mvOs.c
+++ b/crypto/ocf/kirkwood/mvHal/linux_oss/mvOs.c
@@ -208,4 +208,3 @@ static MV_U32 read_p15_c0 (void)
 
 	return value;
 }
-
diff --git a/crypto/ocf/kirkwood/mvHal/linux_oss/mvOs.h b/crypto/ocf/kirkwood/mvHal/linux_oss/mvOs.h
index 9122a52..c9d4e1a 100644
--- a/crypto/ocf/kirkwood/mvHal/linux_oss/mvOs.h
+++ b/crypto/ocf/kirkwood/mvHal/linux_oss/mvOs.h
@@ -419,5 +419,3 @@ void mvOsIoCachedFree( void* osHandle, MV_U32 size, MV_ULONG phyAddr, void* pVir
 int mvOsRand(void);
 
 #endif /* _MV_OS_LNX_H_ */
-
-
diff --git a/crypto/ocf/kirkwood/mvHal/mvSysHwConfig.h b/crypto/ocf/kirkwood/mvHal/mvSysHwConfig.h
index 116b941..b02bbcb 100644
--- a/crypto/ocf/kirkwood/mvHal/mvSysHwConfig.h
+++ b/crypto/ocf/kirkwood/mvHal/mvSysHwConfig.h
@@ -372,4 +372,3 @@ otherwise the following defines will be ignored */
 
 
 #endif /* __INCmvSysHwConfigh */
-
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/cntmr/mvCntmr.c b/crypto/ocf/kirkwood/mvHal/mv_hal/cntmr/mvCntmr.c
index 4fe2e9c..69d8d6b 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/cntmr/mvCntmr.c
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/cntmr/mvCntmr.c
@@ -373,4 +373,3 @@ MV_STATUS mvCntmrStart(MV_U32 countNum, MV_U32 value,
 
 	return MV_OK;
 }
-
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/cpu/mvCpuCntrs.h b/crypto/ocf/kirkwood/mvHal/mv_hal/cpu/mvCpuCntrs.h
index 3428a71..27e83c0 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/cpu/mvCpuCntrs.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/cpu/mvCpuCntrs.h
@@ -210,4 +210,3 @@ static INLINE void mvCpuCntrsReadAfter(MV_CPU_CNTRS_EVENT* pEvent)
 
 
 #endif /* __mvCpuCntrs_h__ */
-
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/cpu/mvCpuL2Cntrs.h b/crypto/ocf/kirkwood/mvHal/mv_hal/cpu/mvCpuL2Cntrs.h
index 77ba5e5..8b96ef8 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/cpu/mvCpuL2Cntrs.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/cpu/mvCpuL2Cntrs.h
@@ -148,4 +148,3 @@ static INLINE void mvCpuL2CntrsReadAfter(MV_CPU_L2_CNTRS_EVENT* pEvent)
 
 
 #endif /* __mvCpuL2Cntrs_h__ */
-
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDram.c b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDram.c
index 413dca3..2fcaf59 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDram.c
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDram.c
@@ -272,7 +272,7 @@ MV_STATUS dimmSpdCpy(MV_VOID)
     {
 	twsiSlave.offset = i;
 	if( MV_OK != mvTwsiWrite (MV_BOARD_DIMM_I2C_CHANNEL,
-	    			&twsiSlave, &data[i], 1) )
+				&twsiSlave, &data[i], 1) )
 	{
 	    mvOsPrintf("DRAM: ERR. no DIMM in dimmNum 1 byte %d \n",i);
 	    return MV_FAIL;
@@ -681,7 +681,7 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
     /* Module Serial Number */
     for(i = 0; i < sizeof(MV_U32); i++)
     {
-    	temp |= spdRawData[95+i] << 8*i;
+	temp |= spdRawData[95+i] << 8*i;
     }
     mvOsOutput("DIMM Serial No.                 %ld (%lx)\n", (long)temp,
                                     (long)temp);
@@ -1476,4 +1476,3 @@ static MV_U32  cas2ps(MV_U8 spd_byte)
 
     return (ns*1000 + ns10*10);
 }
-
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDramIf.c b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDramIf.c
index 569ee43..b9ac463 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDramIf.c
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDramIf.c
@@ -1595,5 +1595,3 @@ MV_32 mvDramIfBankBaseGet(MV_U32 bankNum)
 		return -1;
 	}
 }
-
-
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDramIfConfig.S b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDramIfConfig.S
index efb088e..963c6c9 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDramIfConfig.S
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr1_2/mvDramIfConfig.S
@@ -481,7 +481,7 @@ ddr2FtdllVal:
         ldr     r2, =MV_5281_DEV_ID
         cmp     r3, r2
 	bne	2f
-    	MV_CTRL_REV_GET_ASM(r3, r2)
+	MV_CTRL_REV_GET_ASM(r3, r2)
         cmp     r3, #MV_5281_D0_REV
         beq     orin2_d0_ddr2_ftdll_val
         cmp     r3, #MV_5281_D1_REV
@@ -559,7 +559,7 @@ ddr1FtdllVal:
         ldr     r2, =MV_5281_DEV_ID
         cmp     r3, r2
 	bne	2f
-    	MV_CTRL_REV_GET_ASM(r3, r2)
+	MV_CTRL_REV_GET_ASM(r3, r2)
         cmp     r3, #MV_5281_D0_REV
         bge     orin2_ddr1_ftdll_val
 	b	ddr1_default_val
@@ -579,7 +579,7 @@ orin2_ddr1_ftdll_val:
         ldr     r2, =MV_5181_DEV_ID
         cmp     r3, r2
 	bne	3f
-    	MV_CTRL_REV_GET_ASM(r3, r2)
+	MV_CTRL_REV_GET_ASM(r3, r2)
         cmp     r3, #MV_5181_B1_REV
         bge     orin1_ddr1_ftdll_val
 	b	ddr1_default_val
@@ -665,4 +665,3 @@ load_from_stack:
 no_stack_l:
 
         mov     pc, lr
-
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIf.c b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIf.c
index 27e7042..dc10ce1 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIf.c
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIf.c
@@ -122,7 +122,7 @@ MV_U32 mvDramCsSizeGet(MV_U32 csNum)
 
 	if(MV_OK == mvDramBankInfoGet(csNum, &bankInfo))
 	{
-        	if (0 == bankInfo.size)
+		if (0 == bankInfo.size)
 			return 0;
 
 		/* Note that the Dimm width might be different then the device DRAM width */
@@ -221,7 +221,7 @@ MV_STATUS mvDramIfDetect(MV_U32 forcedCl, MV_BOOL eccDisable)
 				return MV_ERROR;
 			}
 
-            		/* All banks must support the Mclk freqency */
+			/* All banks must support the Mclk freqency */
 			if(bankInfo[i].minCycleTimeAtMaxCasLatPs > busClkPs)
 			{
 				mvOsOutput("Dram: ERR. Bank %d doesn't support memory clock!!!\n", i);
@@ -292,7 +292,7 @@ MV_STATUS mvDramIfDetect(MV_U32 forcedCl, MV_BOOL eccDisable)
 	{
 		i = MV_DRAM_CS_order[j];
 
-        	if (0 == bankInfo[i].size)
+		if (0 == bankInfo[i].size)
 			continue;
 
 			/* Init the CPU window decode */
@@ -340,7 +340,7 @@ MV_STATUS mvDramIfDetect(MV_U32 forcedCl, MV_BOOL eccDisable)
 				if (base < 0xC0000000)
 				{
 					DB(mvOsPrintf("Dram: Enable window %d base 0x%x, size=0x%x\n",i, base, size));
-           			if (MV_OK != mvCpuIfTargetWinSet(i, &dramDecWin))
+				if (MV_OK != mvCpuIfTargetWinSet(i, &dramDecWin))
 					{
 						mvOsPrintf("Dram: ERR. Fail to set bank %d!!!\n", SDRAM_CS0 + i);
 						return 	MV_ERROR;
@@ -384,7 +384,7 @@ MV_STATUS mvDramIfDetect(MV_U32 forcedCl, MV_BOOL eccDisable)
 
 	/* calc SDRAM_MODE_REG  and save it to temp register */
 	temp = sdramModeRegCalc(minCas);
-    	if(-1 == temp)
+	if(-1 == temp)
 	{
 		mvOsOutput("Dram: ERR. sdramModeRegCalc failed !!!\n");
 		return MV_ERROR;
@@ -415,18 +415,18 @@ MV_STATUS mvDramIfDetect(MV_U32 forcedCl, MV_BOOL eccDisable)
 		}
 	}
 
-  	temp = dunitCtrlLowRegCalc(&bankInfo[0], minCas, busClk, TTMode );
-   	if(-1 == temp)
+	temp = dunitCtrlLowRegCalc(&bankInfo[0], minCas, busClk, TTMode );
+	if(-1 == temp)
 	{
 		mvOsOutput("Dram: ERR. dunitCtrlLowRegCalc failed !!!\n");
 		return MV_ERROR;
 	}
 	DB(mvOsPrintf("Dram: dunitCtrlLowRegCalc - %x\n",temp);)
-  	MV_REG_WRITE(DRAM_BUF_REG3, temp);
+	MV_REG_WRITE(DRAM_BUF_REG3, temp);
 
 	/* calc D_UNIT_CONTROL_HIGH  and save it to temp register */
-  	temp = dunitCtrlHighRegCalc(&bankInfo[0], busClk);
-   	if(-1 == temp)
+	temp = dunitCtrlHighRegCalc(&bankInfo[0], busClk);
+	if(-1 == temp)
 	{
 		mvOsOutput("Dram: ERR. dunitCtrlHighRegCalc failed !!!\n");
 		return MV_ERROR;
@@ -438,11 +438,11 @@ MV_STATUS mvDramIfDetect(MV_U32 forcedCl, MV_BOOL eccDisable)
 		/* turn off sample stage if no ecc */
 		temp &= ~SDRAM__D2P_EN;;
 	}
-  	MV_REG_WRITE(DRAM_BUF_REG13, temp);
+	MV_REG_WRITE(DRAM_BUF_REG13, temp);
 
 	/* calc SDRAM_ADDR_CTRL_REG  and save it to temp register */
 	temp = sdramAddrCtrlRegCalc(&bankInfo[0],&bankInfo[2]);
-    	if(-1 == temp)
+	if(-1 == temp)
 	{
 		mvOsOutput("Dram: ERR. sdramAddrCtrlRegCalc failed !!!\n");
 		return MV_ERROR;
@@ -452,7 +452,7 @@ MV_STATUS mvDramIfDetect(MV_U32 forcedCl, MV_BOOL eccDisable)
 
 	/* calc SDRAM_TIMING_CTRL_LOW_REG  and save it to temp register */
 	temp = sdramTimeCtrlLowRegCalc(&bankInfo[0], minCas, busClk);
-    	if(-1 == temp)
+	if(-1 == temp)
 	{
 		mvOsOutput("Dram: ERR. sdramTimeCtrlLowRegCalc failed !!!\n");
 		return MV_ERROR;
@@ -462,7 +462,7 @@ MV_STATUS mvDramIfDetect(MV_U32 forcedCl, MV_BOOL eccDisable)
 
 	/* calc SDRAM_TIMING_CTRL_HIGH_REG  and save it to temp register */
 	temp = sdramTimeCtrlHighRegCalc(&bankInfo[0], busClk);
-    	if(-1 == temp)
+	if(-1 == temp)
 	{
 		mvOsOutput("Dram: ERR. sdramTimeCtrlHighRegCalc failed !!!\n");
 		return MV_ERROR;
@@ -496,7 +496,7 @@ MV_STATUS mvDramIfDetect(MV_U32 forcedCl, MV_BOOL eccDisable)
 	/* Note that DDR SDRAM Address/Control and Data pad calibration     */
 	/* settings is done in mvSdramIfConfig.s                            */
 
- 	return MV_OK;
+	return MV_OK;
 }
 
 
@@ -881,7 +881,7 @@ static MV_U32 sdramConfigRegCalc(MV_DRAM_BANK_INFO *pBankInfo,MV_DRAM_BANK_INFO
 	DB(mvOsPrintf("Dram: sdramConfigRegCalc set sdramConfig to 0x%x\n",
 				  sdramConfig));
 
- 	return sdramConfig;
+	return sdramConfig;
 }
 
 /*******************************************************************************
@@ -1015,7 +1015,7 @@ static MV_U32 dunitCtrlLowRegCalc(MV_DRAM_BANK_INFO *pBankInfo, MV_U32 minCas, M
 	MV_U32 sbOutR[4]={3,5,7,9} ;
 	MV_U32 sbOutU[4]={1,3,5,7} ;
 
-    	dunitCtrlLow = MV_REG_READ(SDRAM_DUNIT_CTRL_REG);
+	dunitCtrlLow = MV_REG_READ(SDRAM_DUNIT_CTRL_REG);
 
         DB(mvOsPrintf("Dram: dunitCtrlLowRegCalc\n"));
 
@@ -1470,11 +1470,11 @@ static void sdramDDr2OdtConfig(MV_DRAM_BANK_INFO *pBankInfo)
 			DB(mvOsPrintf("sdramDDr2OdtConfig: Invalid DRAM bank presence\n"));
 			return;
 	}
- 	/* DDR2 SDRAM ODT ctrl low  */
+	/* DDR2 SDRAM ODT ctrl low  */
 	DB(mvOsPrintf("Dram: DDR2 setting ODT ctrl low with: %x \n", odtCtrlLow));
 	MV_REG_WRITE(DRAM_BUF_REG7, odtCtrlLow);
 
- 	/* DDR2 SDRAM ODT ctrl high  */
+	/* DDR2 SDRAM ODT ctrl high  */
 	DB(mvOsPrintf("Dram: DDR2 setting ODT ctrl high with: %x \n", odtCtrlHigh));
 	MV_REG_WRITE(DRAM_BUF_REG8, odtCtrlHigh);
 
@@ -1852,4 +1852,3 @@ MV_U32 mvDramIfGetCSorder(MV_U32 csOrder )
 {
 	return DRAM_CS_Order[csOrder];
 }
-
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIfBasicInit.S b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIfBasicInit.S
index c6a4493..43fb4eb 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIfBasicInit.S
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIfBasicInit.S
@@ -187,7 +187,7 @@ _mvDramIfStaticInit:
         MV_REG_WRITE_ASM (r6, r5, SDRAM_DUNIT_CTRL_REG)
 #endif
 
-     	/*DDR SDRAM Initialization Control */
+	/*DDR SDRAM Initialization Control */
 	ldr	r6, =DSICR_INIT_EN
 	MV_REG_WRITE_ASM (r6, r1, DDR_SDRAM_INIT_CTRL_REG)
 2:	MV_REG_READ_ASM (r6, r1, DDR_SDRAM_INIT_CTRL_REG)
@@ -339,7 +339,7 @@ _mvDramIfBasicInit:
         MV_REG_WRITE_ASM (r6, r5, SDRAM_DUNIT_CTRL_REG)
 #endif
 
-     	/*DDR SDRAM Initialization Control */
+	/*DDR SDRAM Initialization Control */
 	ldr	r6, =DSICR_INIT_EN
 	MV_REG_WRITE_ASM (r6, r1, DDR_SDRAM_INIT_CTRL_REG)
 2:	MV_REG_READ_ASM (r6, r1, DDR_SDRAM_INIT_CTRL_REG)
@@ -931,7 +931,7 @@ _is_Second_Dimm_Exist:
         mov     r7, #DIMM_TYPE_OFFSET
         bl      _i2cRead                /* result in r7                       */
 
-     	tst     r7, #0x8               /* bit3 is '1' -> DDR 2 */
+	tst     r7, #0x8               /* bit3 is '1' -> DDR 2 */
         mov     PC, r13
 
 /*******************************************************************************
@@ -964,11 +964,11 @@ _mvDramIfGetDimmSizeFromSpd:
         bl      _i2cRead
 
 pass_read:
-      	ldr     r8, =(0x7 << SCSR_SIZE_OFFS)
+	ldr     r8, =(0x7 << SCSR_SIZE_OFFS)
         cmp	r7, #DRAM_RANK_DENSITY_128M
         beq     endDimmSize
 
-      	ldr     r8, =(0xf << SCSR_SIZE_OFFS)
+	ldr     r8, =(0xf << SCSR_SIZE_OFFS)
         cmp	r7, #DRAM_RANK_DENSITY_256M
         beq     endDimmSize
 
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIfConfig.S b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIfConfig.S
index 38060d9..751916d 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIfConfig.S
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIfConfig.S
@@ -481,7 +481,7 @@ no_stack_l1:
 _mvDramIfMemInit:
         stmdb	sp!, {r0,r1, r2, r3, r4, r5, r6}
 	mov     r6, LR                 /* Save link register */
-    	/* Check if dram bank 0 has to be init for ECC */
+	/* Check if dram bank 0 has to be init for ECC */
 	MV_REG_READ_ASM (r0, r5, SDRAM_SIZE_REG(0,0))
 	and 	r3, r0, #SCSR_WIN_EN
         cmp     r3, #0
@@ -493,7 +493,7 @@ _mvDramIfMemInit:
 	bl	_mvDramIfEccMemInit
 
 no_bank_0:
-    	/* Check if dram bank 1 has to be init for ECC */
+	/* Check if dram bank 1 has to be init for ECC */
         MV_REG_READ_ASM (r0, r5, SDRAM_SIZE_REG(0,1))
 	and 	r0, r0, #SCSR_WIN_EN
         cmp     r0, #0
@@ -501,8 +501,8 @@ no_bank_0:
 	mov	r0,#1
 	bl	_mvDramIfEccMemInit
 no_bank_1:
-    	/* Check if dram bank 2 has to be init for ECC */
-    	MV_REG_READ_ASM (r0, r5, SDRAM_SIZE_REG(0,2))
+	/* Check if dram bank 2 has to be init for ECC */
+	MV_REG_READ_ASM (r0, r5, SDRAM_SIZE_REG(0,2))
 	and 	r0, r0, #SCSR_WIN_EN
         cmp     r0, #0
 	beq   	no_bank_2
@@ -513,7 +513,7 @@ no_bank_1:
 	bl	_mvDramIfEccMemInit
 
 no_bank_2:
-    	/* Check if dram bank 3 has to be init for ECC */
+	/* Check if dram bank 3 has to be init for ECC */
 	MV_REG_READ_ASM (r0, r5, SDRAM_SIZE_REG(0,3))
 	and 	r0, r0, #SCSR_WIN_EN
 	cmp     r0, #0
@@ -525,4 +525,3 @@ no_bank_3:
 	ldmia	sp!, {r0, r1, r2, r3, r4, r5, r6}
 	mov     pc, lr
 #endif
-
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIfStaticInit.h b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIfStaticInit.h
index 6df9666..ac2a57a3 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIfStaticInit.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/mvDramIfStaticInit.h
@@ -176,4 +176,3 @@ Two DIMM 512M + ECC enabled, Registered DIMM  CAS Latency 2.5
 
 #endif /* MV_STATIC_DRAM_ON_BOARD */
 #endif /* __INCmvDramIfStaticInith */
-
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/spd/mvSpd.c b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/spd/mvSpd.c
index 856bd9e..94c89ed 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/spd/mvSpd.c
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/ddr2/spd/mvSpd.c
@@ -676,7 +676,7 @@ MV_VOID dimmSpdPrint(MV_U32 dimmNum)
     /* Module Serial Number */
     for(i = 0; i < sizeof(MV_U32); i++)
     {
-    	temp |= spdRawData[95+i] << 8*i;
+	temp |= spdRawData[95+i] << 8*i;
     }
     mvOsOutput("DIMM Serial No.                 %ld (%lx)\n", (long)temp,
                                     (long)temp);
@@ -1471,4 +1471,3 @@ static MV_U32  cas2ps(MV_U8 spd_byte)
 
     return (ns*1000 + ns10*10);
 }
-
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/eth/gbe/mvEth.c b/crypto/ocf/kirkwood/mvHal/mv_hal/eth/gbe/mvEth.c
index 617e35f..769631d 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/eth/gbe/mvEth.c
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/eth/gbe/mvEth.c
@@ -920,7 +920,7 @@ MV_PKT_INFO*    mvEthPortForceTxDone(void* pEthPortHndl, int txQueue)
 	/* pPktInfo is available only in descriptors which are last descriptors */
         pPktInfo = (MV_PKT_INFO*)pTxDesc->returnInfo;
 	if (pPktInfo)
-        	pPktInfo->status = pTxDesc->cmdSts;
+		pPktInfo->status = pTxDesc->cmdSts;
 
         pTxDesc->cmdSts = 0x0;
         pTxDesc->returnInfo = 0x0;
@@ -930,7 +930,7 @@ MV_PKT_INFO*    mvEthPortForceTxDone(void* pEthPortHndl, int txQueue)
 
         if (pPktInfo)
 		if (pPktInfo->status  & ETH_TX_LAST_DESC_MASK)
-            		return pPktInfo;
+			return pPktInfo;
     }
     MV_REG_WRITE( ETH_TX_CUR_DESC_PTR_REG(port, txQueue),
                     (MV_U32)ethDescVirtToPhy(pQueueCtrl, pQueueCtrl->pCurrentDescr) );
@@ -2941,12 +2941,3 @@ static void mvEthPortSgmiiConfig(int port)
 
     MV_REG_WRITE(ETH_PORT_SERIAL_CTRL_1_REG(port), regVal);
 }
-
-
-
-
-
-
-
-
-
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/eth/gbe/mvEthGbe.h b/crypto/ocf/kirkwood/mvHal/mv_hal/eth/gbe/mvEthGbe.h
index 83ad6ad..fa11699 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/eth/gbe/mvEthGbe.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/eth/gbe/mvEthGbe.h
@@ -747,5 +747,3 @@ static INLINE MV_STATUS   mvEthPortRxDone(void* pEthPortHndl, int rxQueue, MV_PK
 
 
 #endif /* __mvEthGbe_h__ */
-
-
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/eth/mvEth.h b/crypto/ocf/kirkwood/mvHal/mv_hal/eth/mvEth.h
index f078398..7474675 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/eth/mvEth.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/eth/mvEth.h
@@ -352,5 +352,3 @@ typedef struct _ethPortCtrl
 #include "eth/gbe/mvEthGbe.h"
 
 #endif /* __mvEth_h__ */
-
-
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/gpp/mvGpp.c b/crypto/ocf/kirkwood/mvHal/mv_hal/gpp/mvGpp.c
index ce0d65d..e81981c 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/gpp/mvGpp.c
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/gpp/mvGpp.c
@@ -215,7 +215,7 @@ MV_U32  mvGppPolarityGet(MV_U32 group, MV_U32 mask)
 {
     MV_U32  regVal;
 
-  	if (group >= MV_GPP_MAX_GROUP)
+	if (group >= MV_GPP_MAX_GROUP)
 	{
 		DB(mvOsPrintf("mvGppActiveSet: Error invalid group number \n"));
 		return MV_ERROR;
@@ -358,5 +358,3 @@ static MV_VOID gppRegSet (MV_U32 group, MV_U32 regOffs,MV_U32 mask,MV_U32 value)
 
 	MV_REG_WRITE(regOffs, gppData);
 }
-
-
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/gpp/mvGpp.h b/crypto/ocf/kirkwood/mvHal/mv_hal/gpp/mvGpp.h
index a777a2a..82603d7 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/gpp/mvGpp.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/gpp/mvGpp.h
@@ -115,4 +115,3 @@ MV_U32 mvGppValueGet(MV_U32 group, MV_U32 mask);
 MV_STATUS mvGppValueSet (MV_U32 group, MV_U32 mask, MV_U32 value);
 
 #endif /* #ifndef __INCmvGppH */
-
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/pci-if/mvPciIf.c b/crypto/ocf/kirkwood/mvHal/mv_hal/pci-if/mvPciIf.c
index 5ee430c..ca2710c 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/pci-if/mvPciIf.c
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/pci-if/mvPciIf.c
@@ -664,6 +664,3 @@ MV_U32  mvPciRealIfNumGet(MV_U32 pciIf)
 	return 0xffffffff;
 
 }
-
-
-
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/pci-if/mvPciIf.h b/crypto/ocf/kirkwood/mvHal/mv_hal/pci-if/mvPciIf.h
index 5f7caaa..bfce3b7 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/pci-if/mvPciIf.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/pci-if/mvPciIf.h
@@ -131,4 +131,3 @@ MV_U32  mvPciRealIfNumGet(MV_U32 pciIf);
 MV_VOID mvPciIfAddrDecShow(MV_VOID);
 
 #endif /* #ifndef __INCPCIIFH */
-
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/pci-if/mvPciIfRegs.h b/crypto/ocf/kirkwood/mvHal/mv_hal/pci-if/mvPciIfRegs.h
index c9638d1..3df6198 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/pci-if/mvPciIfRegs.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/pci-if/mvPciIfRegs.h
@@ -242,4 +242,3 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define PIPLR_MAXLATEN_MASK	(0xff << PIPLR_MAXLATEN_OFFS)
 
 #endif /* #ifndef __INCPCIIFREGSH */
-
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/pci-if/pci_util/mvPciUtils.c b/crypto/ocf/kirkwood/mvHal/mv_hal/pci-if/pci_util/mvPciUtils.c
index f216979..1bc2b22 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/pci-if/pci_util/mvPciUtils.c
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/pci-if/pci_util/mvPciUtils.c
@@ -83,9 +83,9 @@ There is no suppotr for Header type 01h of pci devices  ( PCI bridges )
 
 
 static MV_STATUS pciDetectDevice(MV_U32 pciIf,
-   								 MV_U32 bus,
-   								 MV_U32 dev,
-   								 MV_U32 func,
+								 MV_U32 bus,
+								 MV_U32 dev,
+								 MV_U32 func,
 								 MV_PCI_DEVICE *pPciAgent);
 
 static MV_U32 pciDetectDeviceBars(MV_U32 pciIf,
@@ -272,9 +272,9 @@ MV_STATUS mvPciScan(MV_U32 pciIf,
 *******************************************************************************/
 
 static MV_STATUS pciDetectDevice(MV_U32 pciIf,
-   								 MV_U32 bus,
-   								 MV_U32 dev,
-   								 MV_U32 func,
+								 MV_U32 bus,
+								 MV_U32 dev,
+								 MV_U32 func,
 								 MV_PCI_DEVICE *pPciAgent)
 {
 	MV_U32 pciData;
@@ -296,7 +296,7 @@ static MV_STATUS pciDetectDevice(MV_U32 pciIf,
 					(DB_88F5181_DDR1_PRPMC != mvBoardIdGet()) &&
 					(DB_88F5181_DDR1_PEXPCI != mvBoardIdGet()) &&
 					(DB_88F5181_DDR1_MNG != mvBoardIdGet()))
-    	{
+	{
 
 			if (mvBoardIsOurPciSlot(bus, dev) == MV_FALSE)
 			{
@@ -426,7 +426,7 @@ static MV_STATUS pciDetectDevice(MV_U32 pciIf,
 
 	pciDetectDeviceBars(pciIf,
 					  bus,dev,func,
-	 				 pPciAgent);
+					 pPciAgent);
 
 
 	/* check if we are bridge*/
@@ -1001,6 +1001,3 @@ MV_STATUS mvPciClassNameGet(MV_U32 baseClassCode, MV_8 *pType)
 	return MV_OK;
 
 }
-
-
-
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/pci/mvPci.c b/crypto/ocf/kirkwood/mvHal/mv_hal/pci/mvPci.c
index aec8af7..2e61d21 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/pci/mvPci.c
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/pci/mvPci.c
@@ -921,7 +921,7 @@ MV_U32 mvPciLocalBusNumGet(MV_U32 pciIf)
 		if (pciIf >= mvCtrlPciMaxIfGet())
 		{
 			mvOsPrintf("mvPciLocalBusNumGet: ERR. Invalid PCI interface %d\n",
-													   					pciIf);
+																		pciIf);
 			return 0xFFFFFFFF;
 		}
 	}
@@ -1030,7 +1030,7 @@ MV_U32 mvPciLocalDevNumGet(MV_U32 pciIf)
 		if (pciIf >= mvCtrlPciMaxIfGet())
 		{
 			mvOsPrintf("mvPciLocalDevNumGet: ERR. Invalid PCI interface %d\n",
-																   		pciIf);
+																		pciIf);
 			return 0xFFFFFFFF;
 		}
 	}
@@ -1041,7 +1041,3 @@ MV_U32 mvPciLocalDevNumGet(MV_U32 pciIf)
 
 	return (pciP2PConfig >> PPCR_DEV_NUM_OFFS);
 }
-
-
-
-
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/pci/mvPci.h b/crypto/ocf/kirkwood/mvHal/mv_hal/pci/mvPci.h
index 2f4ee1e..55244fa 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/pci/mvPci.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/pci/mvPci.h
@@ -180,6 +180,3 @@ MV_U32 mvPciLocalDevNumGet(MV_U32 pciIf);
 
 
 #endif /* #ifndef __INCPCIH */
-
-
-
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/pci/mvPciRegs.h b/crypto/ocf/kirkwood/mvHal/mv_hal/pci/mvPciRegs.h
index 69fe7e5..9b7c7a5 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/pci/mvPciRegs.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/pci/mvPciRegs.h
@@ -408,4 +408,3 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 
 #endif /* #ifndef __INCPCIREGSH */
-
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvPex.c b/crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvPex.c
index 5a30c93..84cf85a 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvPex.c
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvPex.c
@@ -88,10 +88,10 @@ MV_STATUS mvPexHalInit(MV_U32 pexIf, MV_PEX_TYPE pexType)
 	(mvCtrlModelGet() != MV_6192_DEV_ID) &&
     (mvCtrlModelGet() != MV_6190_DEV_ID) &&
 	(mvCtrlModelGet() != MV_6180_DEV_ID) &&
-        	(mvCtrlModelGet() != MV_6183_DEV_ID) &&
+		(mvCtrlModelGet() != MV_6183_DEV_ID) &&
 	(mvCtrlModelGet() != MV_6183L_DEV_ID) &&
-        	(mvCtrlModelGet() != MV_78100_DEV_ID) &&
-        	(mvCtrlModelGet() != MV_78200_DEV_ID) &&
+		(mvCtrlModelGet() != MV_78100_DEV_ID) &&
+		(mvCtrlModelGet() != MV_78200_DEV_ID) &&
 	(mvCtrlModelGet() != MV_76100_DEV_ID) &&
 	(mvCtrlModelGet() != MV_78XX0_DEV_ID))
     {
@@ -686,7 +686,7 @@ MV_STATUS mvPexHwConfigWrite(MV_U32 pexIf, MV_U32 bus, MV_U32 dev,
 	MV_REG_WRITE(PEX_CFG_ADDR_REG(pexIf), pexData);
 
 	/* Clear CPU pipe. Important where CPU can perform OOO execution */
-    	CPU_PIPE_FLUSH;
+	CPU_PIPE_FLUSH;
 
 	/* In order to let the PEX controller absorbed the address of the read 	*/
 	/* transaction we perform a validity check that the address was written */
@@ -999,7 +999,7 @@ MV_U32 mvPexLocalDevNumGet(MV_U32 pexIf)
 		if (pexIf >= mvCtrlPexMaxIfGet())
 		{
 			mvOsPrintf("mvPexLocalDevNumGet: ERR. Invalid PEX interface %d\n",
-																   		pexIf);
+																		pexIf);
 			return 0xFFFFFFFF;
 		}
 	}
@@ -1138,6 +1138,3 @@ MV_VOID mvPexPowerDown(MV_U32 pexIf)
 		MV_REG_WRITE((0x41B00 -(pexIf)*0x10000), 0x20800087);
 	}
 }
-
-
-
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvPexRegs.h b/crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvPexRegs.h
index 713a294..3302917 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvPexRegs.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvPexRegs.h
@@ -747,5 +747,3 @@ it only affects the assertion of the interrupt .*/
 #endif /* __cplusplus */
 
 #endif /* #ifndef __INCPEXREGSH */
-
-
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvVrtBrgPex.c b/crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvVrtBrgPex.c
index 59d0383..1306482 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvVrtBrgPex.c
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/pex/mvVrtBrgPex.c
@@ -309,5 +309,3 @@ void resetPexConfig(MV_U32 pexIf, MV_U32 bus, MV_U32 dev)
 		}
 	}
 }
-
-
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/sflash/mvSFlash.c b/crypto/ocf/kirkwood/mvHal/mv_hal/sflash/mvSFlash.c
index 2643699..2d4443a 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/sflash/mvSFlash.c
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/sflash/mvSFlash.c
@@ -1519,4 +1519,3 @@ const MV_8 * mvSFlashModelGet (MV_SFLASH_INFO * pFlinfo)
 
     return sflash[pFlinfo->index].deviceModel;
 }
-
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/sflash/mvSFlashSpec.h b/crypto/ocf/kirkwood/mvHal/mv_hal/sflash/mvSFlashSpec.h
index eeb4426..6a7fd13 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/sflash/mvSFlashSpec.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/sflash/mvSFlashSpec.h
@@ -230,4 +230,3 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define     	MV_S25FL_STATUS_BP_ALL              	(0x0F << MV_SFLASH_STATUS_REG_WP_OFFSET)
 
 #endif /* __INCmvSFlashSpecH */
-
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/spi/mvSpi.c b/crypto/ocf/kirkwood/mvHal/mv_hal/spi/mvSpi.c
index 39e0b72..55fecc1 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/spi/mvSpi.c
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/spi/mvSpi.c
@@ -113,32 +113,32 @@ static MV_STATUS mvSpi16bitDataTxRx (MV_U16 txData, MV_U16 * pRxData)
     /* check that the RX data is needed */
     if (pRxData)
     {
-    	if ((MV_U32)pRxData &  0x1) /* check if address is not alligned to 16bit */
-    	{
+	if ((MV_U32)pRxData &  0x1) /* check if address is not alligned to 16bit */
+	{
 #if defined(MV_CPU_LE)
-    		/* perform the data write to the buffer in two stages with 8bit each */
-    		MV_U8 * bptr = (MV_U8*)pRxData;
-    		MV_U16 data = MV_16BIT_LE(MV_REG_READ(MV_SPI_DATA_IN_REG));
-    		*bptr = (data & 0xFF);
-    		++bptr;
-    		*bptr = ((data >> 8) & 0xFF);
+		/* perform the data write to the buffer in two stages with 8bit each */
+		MV_U8 * bptr = (MV_U8*)pRxData;
+		MV_U16 data = MV_16BIT_LE(MV_REG_READ(MV_SPI_DATA_IN_REG));
+		*bptr = (data & 0xFF);
+		++bptr;
+		*bptr = ((data >> 8) & 0xFF);
 
 #elif defined(MV_CPU_BE)
 
-    		/* perform the data write to the buffer in two stages with 8bit each */
-    		MV_U8 * bptr = (MV_U8 *)pRxData;
-    		MV_U16 data = MV_16BIT_LE(MV_REG_READ(MV_SPI_DATA_IN_REG));
-    		*bptr = ((data >> 8) & 0xFF);
-    		++bptr;
-    		*bptr = (data & 0xFF);
+		/* perform the data write to the buffer in two stages with 8bit each */
+		MV_U8 * bptr = (MV_U8 *)pRxData;
+		MV_U16 data = MV_16BIT_LE(MV_REG_READ(MV_SPI_DATA_IN_REG));
+		*bptr = ((data >> 8) & 0xFF);
+		++bptr;
+		*bptr = (data & 0xFF);
 
 #else
     #error "CPU endianess isn't defined!\n"
 #endif
 
-    	}
-    	else
-        	*pRxData = MV_16BIT_LE(MV_REG_READ(MV_SPI_DATA_IN_REG));
+	}
+	else
+		*pRxData = MV_16BIT_LE(MV_REG_READ(MV_SPI_DATA_IN_REG));
     }
 
     return MV_OK;
@@ -181,7 +181,7 @@ static MV_STATUS mvSpi8bitDataTxRx (MV_U8 txData, MV_U8 * pRxData)
 
     /* check that the RX data is needed */
     if (pRxData)
-    	*pRxData = MV_REG_READ(MV_SPI_DATA_IN_REG);
+	*pRxData = MV_REG_READ(MV_SPI_DATA_IN_REG);
 
     return MV_OK;
 }
@@ -413,7 +413,7 @@ MV_STATUS mvSpiRead	(MV_U8* pRxBuff, MV_U32 buffSize)
 	/* TX/RX in 8bit chanks */
 	while (bytesLeft > 0)
 	{
-        	/* Transmitted and wait for the transfer to be completed */
+		/* Transmitted and wait for the transfer to be completed */
 		if ((ret = mvSpi8bitDataTxRx(MV_SPI_DUMMY_WRITE_8BITS, pRxBuff)) != MV_OK)
 			return ret;
 		/* increment the pointers */
@@ -572,5 +572,3 @@ MV_STATUS mvSpiReadWrite(MV_U8* pRxBuff, MV_U8* pTxBuff, MV_U32 buffSize)
 
 	return MV_OK;
 }
-
-
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/spi/mvSpiCmnd.c b/crypto/ocf/kirkwood/mvHal/mv_hal/spi/mvSpiCmnd.c
index a5d5a64..87eea12 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/spi/mvSpiCmnd.c
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/spi/mvSpiCmnd.c
@@ -246,4 +246,3 @@ MV_STATUS mvSpiWriteThenRead (MV_U8* pCmndBuff, MV_U32 cmndSize, MV_U8* pRxDataB
 
 	return ret;
 }
-
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/spi/mvSpiSpec.h b/crypto/ocf/kirkwood/mvHal/mv_hal/spi/mvSpiSpec.h
index e943787..2879c67 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/spi/mvSpiSpec.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/spi/mvSpiSpec.h
@@ -95,4 +95,3 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #define		MV_SPI_ADDRESS_BURST_LENGTH_MASK	(0x3  << MV_SPI_ADDRESS_BURST_LENGTH_OFFSET)
 
 #endif /* __INCmvSpiSpecH */
-
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/twsi/mvTwsi.c b/crypto/ocf/kirkwood/mvHal/mv_hal/twsi/mvTwsi.c
index c01be0f..a603f73 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/twsi/mvTwsi.c
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/twsi/mvTwsi.c
@@ -128,10 +128,10 @@ MV_STATUS mvTwsiStartBitSet(MV_U8 chanNum)
 
 	DB(mvOsPrintf("TWSI: mvTwsiStartBitSet \n"));
 	/* check Int flag */
-    	if(twsiMainIntGet(chanNum))
+	if(twsiMainIntGet(chanNum))
 		isIntFlag = MV_TRUE;
 	/* set start Bit */
-    	temp = MV_REG_READ(TWSI_CONTROL_REG(chanNum));
+	temp = MV_REG_READ(TWSI_CONTROL_REG(chanNum));
 	MV_REG_WRITE(TWSI_CONTROL_REG(chanNum), temp | TWSI_CONTROL_START_BIT);
 
 	/* in case that the int flag was set before i.e. repeated start bit */
@@ -140,7 +140,7 @@ MV_STATUS mvTwsiStartBitSet(MV_U8 chanNum)
 		twsiIntFlgClr(chanNum);
 	}
 
-   	/* wait for interrupt */
+	/* wait for interrupt */
 	timeout = 0;
 	while(!twsiMainIntGet(chanNum) && (timeout++ < TWSI_TIMEOUT_VALUE));
 
@@ -188,15 +188,15 @@ MV_STATUS mvTwsiStartBitSet(MV_U8 chanNum)
 *******************************************************************************/
 MV_STATUS mvTwsiStopBitSet(MV_U8 chanNum)
 {
-    	MV_U32	timeout, temp;
+	MV_U32	timeout, temp;
 
-    	/* Generate stop bit */
+	/* Generate stop bit */
 	temp = MV_REG_READ(TWSI_CONTROL_REG(chanNum));
-    	MV_REG_WRITE(TWSI_CONTROL_REG(chanNum), temp | TWSI_CONTROL_STOP_BIT);
+	MV_REG_WRITE(TWSI_CONTROL_REG(chanNum), temp | TWSI_CONTROL_STOP_BIT);
 
 	twsiIntFlgClr(chanNum);
 
-   	/* wait for stop bit to come down */
+	/* wait for stop bit to come down */
 	timeout = 0;
 	while( ((MV_REG_READ(TWSI_CONTROL_REG(chanNum)) & TWSI_CONTROL_STOP_BIT) != 0) && (timeout++ < TWSI_TIMEOUT_VALUE));
 
@@ -272,13 +272,13 @@ static MV_VOID twsiIntFlgClr(MV_U8 chanNum)
 	MV_U32 temp;
 
 	/* wait for 1 mili to prevent TWSI register write after write problems */
-   	mvOsDelay(1);
+	mvOsDelay(1);
 	/* clear the int flag bit */
 	temp = MV_REG_READ(TWSI_CONTROL_REG(chanNum));
-    	MV_REG_WRITE(TWSI_CONTROL_REG(chanNum),temp & ~(TWSI_CONTROL_INT_FLAG_SET));
+	MV_REG_WRITE(TWSI_CONTROL_REG(chanNum),temp & ~(TWSI_CONTROL_INT_FLAG_SET));
 
 	/* wait for 1 mili sec for the clear to take effect */
-   	mvOsDelay(1);
+	mvOsDelay(1);
 
 	return;
 }
@@ -306,7 +306,7 @@ static MV_VOID twsiAckBitSet(MV_U8 chanNum)
 
 	/*Set the Ack bit */
 	temp = MV_REG_READ(TWSI_CONTROL_REG(chanNum));
-    	MV_REG_WRITE(TWSI_CONTROL_REG(chanNum), temp | TWSI_CONTROL_ACK);
+	MV_REG_WRITE(TWSI_CONTROL_REG(chanNum), temp | TWSI_CONTROL_ACK);
 
 	/* Add delay of 1ms */
 	mvOsDelay(1);
@@ -339,9 +339,9 @@ static MV_VOID twsiAckBitSet(MV_U8 chanNum)
 *******************************************************************************/
 MV_U32 mvTwsiInit(MV_U8 chanNum, MV_HZ frequancy, MV_U32 Tclk, MV_TWSI_ADDR *pTwsiAddr, MV_BOOL generalCallEnable)
 {
-    	MV_U32	n,m,freq,margin,minMargin = 0xffffffff;
+	MV_U32	n,m,freq,margin,minMargin = 0xffffffff;
 	MV_U32	power;
-    	MV_U32	actualFreq = 0,actualN = 0,actualM = 0,val;
+	MV_U32	actualFreq = 0,actualN = 0,actualM = 0,val;
 
 	if(frequancy > 100000)
 	{
@@ -349,22 +349,22 @@ MV_U32 mvTwsiInit(MV_U8 chanNum, MV_HZ frequancy, MV_U32 Tclk, MV_TWSI_ADDR *pTw
 	}
 
 	DB(mvOsPrintf("TWSI: mvTwsiInit - Tclk = %d freq = %d\n",Tclk,frequancy));
-    	/* Calucalte N and M for the TWSI clock baud rate */
-    	for(n = 0 ; n < 8 ; n++)
-    	{
-        	for(m = 0 ; m < 16 ; m++)
-        	{
-            		power = 2 << n; /* power = 2^(n+1) */
-            		freq = Tclk/(10*(m+1)*power);
-            		margin = MV_ABS(frequancy - freq);
-            		if(margin < minMargin)
-            		{
-                		minMargin   = margin;
-                		actualFreq  = freq;
-                		actualN     = n;
-                		actualM     = m;
-            		}
-        	}
+	/* Calucalte N and M for the TWSI clock baud rate */
+	for(n = 0 ; n < 8 ; n++)
+	{
+		for(m = 0 ; m < 16 ; m++)
+		{
+			power = 2 << n; /* power = 2^(n+1) */
+			freq = Tclk/(10*(m+1)*power);
+			margin = MV_ABS(frequancy - freq);
+			if(margin < minMargin)
+			{
+				minMargin   = margin;
+				actualFreq  = freq;
+				actualN     = n;
+				actualM     = m;
+			}
+		}
 		}
 	DB(mvOsPrintf("TWSI: mvTwsiInit - actN %d actM %d actFreq %d\n",actualN , actualM, actualFreq));
 	/* Reset the TWSI logic */
@@ -372,14 +372,14 @@ MV_U32 mvTwsiInit(MV_U8 chanNum, MV_HZ frequancy, MV_U32 Tclk, MV_TWSI_ADDR *pTw
 
 	/* Set the baud rate */
 	val = ((actualM<< TWSI_BAUD_RATE_M_OFFS) | actualN << TWSI_BAUD_RATE_N_OFFS);
-    	MV_REG_WRITE(TWSI_STATUS_BAUDE_RATE_REG(chanNum),val);
+	MV_REG_WRITE(TWSI_STATUS_BAUDE_RATE_REG(chanNum),val);
 
-    	/* Enable the TWSI and slave */
+	/* Enable the TWSI and slave */
 	MV_REG_WRITE(TWSI_CONTROL_REG(chanNum), TWSI_CONTROL_ENA | TWSI_CONTROL_ACK);
 
 	/* set the TWSI slave address */
 	if( pTwsiAddr->type == ADDR10_BIT )/* 10 Bit deviceAddress */
-    	{
+	{
 		/* writing the 2 most significant bits of the 10 bit address*/
 		val = ((pTwsiAddr->address & TWSI_SLAVE_ADDR_10BIT_MASK) >> TWSI_SLAVE_ADDR_10BIT_OFFS );
 		/* bits 7:3 must be 0x11110 */
@@ -390,17 +390,17 @@ MV_U32 mvTwsiInit(MV_U8 chanNum, MV_HZ frequancy, MV_U32 Tclk, MV_TWSI_ADDR *pTw
 		/* write slave address */
 		MV_REG_WRITE(TWSI_SLAVE_ADDR_REG(chanNum),val);
 
-         	/* writing the 8 least significant bits of the 10 bit address*/
-        	val = (pTwsiAddr->address << TWSI_EXTENDED_SLAVE_OFFS) & TWSI_EXTENDED_SLAVE_MASK;
-        	MV_REG_WRITE(TWSI_EXTENDED_SLAVE_ADDR_REG(chanNum), val);
-    	}
-    	else /*7 bit address*/
-    	{
+		/* writing the 8 least significant bits of the 10 bit address*/
+		val = (pTwsiAddr->address << TWSI_EXTENDED_SLAVE_OFFS) & TWSI_EXTENDED_SLAVE_MASK;
+		MV_REG_WRITE(TWSI_EXTENDED_SLAVE_ADDR_REG(chanNum), val);
+	}
+	else /*7 bit address*/
+	{
 		/* set the 7 Bits address */
-        	MV_REG_WRITE(TWSI_EXTENDED_SLAVE_ADDR_REG(chanNum),0x0);
+		MV_REG_WRITE(TWSI_EXTENDED_SLAVE_ADDR_REG(chanNum),0x0);
 		val = (pTwsiAddr->address << TWSI_SLAVE_ADDR_7BIT_OFFS) & TWSI_SLAVE_ADDR_7BIT_MASK;
-        	MV_REG_WRITE(TWSI_SLAVE_ADDR_REG(chanNum), val);
-    	}
+		MV_REG_WRITE(TWSI_SLAVE_ADDR_REG(chanNum), val);
+	}
 
 	/* unmask twsi int */
     val = MV_REG_READ(TWSI_CONTROL_REG(chanNum));
@@ -452,11 +452,11 @@ static MV_U32 twsiStsGet(MV_U8 chanNum)
 *******************************************************************************/
 static MV_VOID twsiReset(MV_U8 chanNum)
 {
-    	/* Reset the TWSI logic */
-    	MV_REG_WRITE(TWSI_SOFT_RESET_REG(chanNum),0);
+	/* Reset the TWSI logic */
+	MV_REG_WRITE(TWSI_SOFT_RESET_REG(chanNum),0);
 
 	/* wait for 2 mili sec */
-   	mvOsDelay(2);
+	mvOsDelay(2);
 
 	return;
 }
@@ -490,7 +490,7 @@ static MV_VOID twsiReset(MV_U8 chanNum)
 MV_STATUS mvTwsiAddrSet(MV_U8 chanNum, MV_TWSI_ADDR *pTwsiAddr, MV_TWSI_CMD command)
 {
 	DB(mvOsPrintf("TWSI: mvTwsiAddr7BitSet addr %x , type %d, cmd is %s\n",pTwsiAddr->address,\
-		 			pTwsiAddr->type, ((command==MV_TWSI_WRITE)?"Write":"Read") ));
+					pTwsiAddr->type, ((command==MV_TWSI_WRITE)?"Write":"Read") ));
 	/* 10 Bit address */
 	if(pTwsiAddr->type == ADDR10_BIT)
 	{
diff --git a/crypto/ocf/kirkwood/mvHal/mv_hal/twsi/mvTwsi.h b/crypto/ocf/kirkwood/mvHal/mv_hal/twsi/mvTwsi.h
index 9017ff1..4635701 100644
--- a/crypto/ocf/kirkwood/mvHal/mv_hal/twsi/mvTwsi.h
+++ b/crypto/ocf/kirkwood/mvHal/mv_hal/twsi/mvTwsi.h
@@ -118,4 +118,3 @@ MV_STATUS mvTwsiWrite(MV_U8 chanNum, MV_TWSI_SLAVE *twsiSlave, MV_U8 *pBlock, MV
 #endif /* __cplusplus */
 
 #endif /* __INCmvTwsiH */
-
diff --git a/crypto/ocf/safe/hmachack.h b/crypto/ocf/safe/hmachack.h
index 598c958..cc1348b 100644
--- a/crypto/ocf/safe/hmachack.h
+++ b/crypto/ocf/safe/hmachack.h
@@ -34,4 +34,3 @@ u_int8_t hmac_opad_buffer[64] = {
     0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C
 };
 #endif /* HMAC_HACK */
-
diff --git a/crypto/ocf/talitos/talitos.c b/crypto/ocf/talitos/talitos.c
index 60854a1..185d2b6 100644
--- a/crypto/ocf/talitos/talitos.c
+++ b/crypto/ocf/talitos/talitos.c
@@ -533,7 +533,7 @@ talitos_process(device_t dev, struct cryptop *crp, int hint)
 		/*
 		 * haven't seen this algo the last sc_num_channels or more
 		 * use round robin in this case
-	 	 * nb: sc->sc_num_channels must be power of 2
+		 * nb: sc->sc_num_channels must be power of 2
 		 */
 		chsel = (chsel + 1) & (sc->sc_num_channels - 1);
 	} else {
diff --git a/crypto/ocf/ubsec_ssb/Makefile b/crypto/ocf/ubsec_ssb/Makefile
index f973efd..ee8a84a 100644
--- a/crypto/ocf/ubsec_ssb/Makefile
+++ b/crypto/ocf/ubsec_ssb/Makefile
@@ -9,4 +9,3 @@ EXTRA_CFLAGS += -I$(obj)/.. -I$(obj)/
 ifdef TOPDIR
 -include $(TOPDIR)/Rules.make
 endif
-
diff --git a/crypto/ocf/ubsec_ssb/ubsec_ssb.c b/crypto/ocf/ubsec_ssb/ubsec_ssb.c
index 1333b27..c02ec25 100644
--- a/crypto/ocf/ubsec_ssb/ubsec_ssb.c
+++ b/crypto/ocf/ubsec_ssb/ubsec_ssb.c
@@ -2217,4 +2217,3 @@ MODULE_AUTHOR("Daniel Mueller <daniel@danm.de>");
 MODULE_LICENSE("BSD");
 MODULE_DESCRIPTION("OCF driver for BCM5365P IPSec Core");
 MODULE_VERSION(DRV_MODULE_VERSION);
-
diff --git a/crypto/ocf/ubsec_ssb/ubsecvar.h b/crypto/ocf/ubsec_ssb/ubsecvar.h
index c808f95..301a570 100644
--- a/crypto/ocf/ubsec_ssb/ubsecvar.h
+++ b/crypto/ocf/ubsec_ssb/ubsecvar.h
@@ -225,4 +225,3 @@ struct ubsec_generic_ctx {
     u_int16_t   pc_offset;      /* crypto offset */
     u_int16_t   pc_type;        /* Cryptographic operation */
 };
-
-- 
1.7.5.4

