From e99d2539f11d0fc85667c0b6a2832689748cafe6 Mon Sep 17 00:00:00 2001
From: Uri Eliyahu <uriel@marvell.com>
Date: Mon, 17 Feb 2014 15:05:56 +0200
Subject: [PATCH 1367/1825] pp3: netdev init code update

https://github.com/MISL-EBU-System-SW/misl-windriver.git linux-3.4.69-14t2-read
commit 2cde98afa668c3cea9b9239872e9226f3b671a90

Change-Id: Id458bdbebbe5bff14e2201c0152f1e0f5cebe9c1
Signed-off-by: Uri Eliyahu <uriel@marvell.com>
Reviewed-on: http://vgitil04.il.marvell.com:8080/5760
Reviewed-by: Yelena Krivosheev <yelena@marvell.com>
Tested-by: Star_Automation <star@marvell.com>
Reviewed-by: Dmitri Epshtein <dima@marvell.com>
Tested-by: Dmitri Epshtein <dima@marvell.com>
Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 .../net/ethernet/marvell/pp3/net_dev/mv_netdev.c   |  349 ++++++++++++--------
 .../marvell/pp3/net_dev/mv_netdev_structs.h        |   42 ++-
 2 files changed, 240 insertions(+), 151 deletions(-)

diff --git a/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.c b/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.c
index dbeed64..68ed5ce 100644
--- a/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.c
+++ b/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev.c
@@ -21,7 +21,7 @@
 
 /* global data */
 struct pp3_dev_priv **pp3_ports;
-struct pp3_group **pp3_groups;
+struct pp3_group *pp3_groups[CONFIG_NR_CPUS][MAX_ETH_DEVICES];
 struct pp3_cpu **pp3_cpus;
 static int pp3_ports_num;
 static int pp3_initialized;
@@ -29,6 +29,159 @@ static int pp3_initialized;
 /* functions */
 static int mv_pp3_poll(struct napi_struct *napi, int budget);
 
+/* Trigger tx done timer in MVNETA_TX_DONE_TIMER_PERIOD msecs */
+static void mv_pp3_add_tx_done_timer(struct pp3_cpu *cpu_ctrl)
+{
+	if (test_and_set_bit(MV_CPU_F_TX_DONE_TIMER, &cpu_ctrl->flags) == 0) {
+		cpu_ctrl->tx_done_timer.expires = jiffies +
+			msecs_to_jiffies(MV_CPU_TX_DONE_TIMER_PERIOD);
+		add_timer_on(&cpu_ctrl->tx_done_timer, cpu_ctrl->cpu);
+	}
+}
+/* tx done timer callback */
+static void mv_pp3_tx_done_timer_callback(unsigned long data)
+{
+	struct pp3_cpu *cpu_ctrl = (struct pp3_cpu *)data;
+	struct	pp3_bm_pool *tx_done_pool = cpu_ctrl->tx_done_pool;
+	struct	pp3_queue *bm_msg_queue = cpu_ctrl->bm_msg_queue;
+
+	clear_bit(MV_CPU_F_TX_DONE_TIMER_BIT, &cpu_ctrl->flags);
+
+	mv_pp3_hmac_bm_buff_request(bm_msg_queue->frame, bm_msg_queue->rxq.phys_q,
+					tx_done_pool->pool, 100 /*TODO - request according to counter value*/);
+
+	/* TODO: update counter */
+
+	if (cpu_ctrl->tx_done_cnt - 100 > 0)
+		mv_pp3_add_tx_done_timer(cpu_ctrl);
+}
+
+/****************************************************************
+ * mv_pp3_isr							*
+ *	rx events , group interrupt handle			*
+ ***************************************************************/
+irqreturn_t mv_pp3_isr(int irq, int group_id)
+{
+	int cpu = smp_processor_id();
+	struct pp3_group *group = pp3_groups[cpu][group_id];
+	struct napi_struct *napi = group->napi;
+
+	STAT_INFO(group->stats.irq++);
+
+	/* TODO: interrupts Mask */
+
+	/* Verify that the device not already on the polling list */
+	if (napi_schedule_prep(napi)) {
+		/* schedule the work (rx+txdone+link) out of interrupt contxet */
+		__napi_schedule(napi);
+	} else {
+		STAT_INFO(group->stats.irq_err++);
+	}
+
+	/* TODO: interrupts unMask */
+
+	return IRQ_HANDLED;
+}
+
+/****************************************************************
+ * mv_pp3_poll							*
+ *	napi func - call to mv_pp3_rx for group's rxqs		*
+ ***************************************************************/
+static int mv_pp3_poll(struct napi_struct *napi, int budget)
+{
+	int rx_done = 0;
+	struct pp3_dev_priv *priv = MV_PP3_PRIV(napi->dev);
+	struct pp3_group *group = priv->groups[smp_processor_id()];
+
+	if (!test_bit(MV_ETH_F_STARTED_BIT, &(priv->flags))) {
+		napi_complete(napi);
+		return rx_done;
+	}
+
+
+	STAT_INFO(group->stats.rx_poll++);
+
+	/* TODO */
+
+
+	while (budget > 0 /* && group rxqs are not empty */) {
+
+		/* TODO
+			select rx_queue
+			call to mv_pp3_rx()
+			update counters and budget
+		*/
+	}
+
+	if (budget > 0)
+		napi_complete(napi);
+
+
+	return rx_done;
+}
+
+/****************************************************************
+ * mv_pp3_linux_pool_isr					*
+ *	linux poll full interrupt handler			*
+ ***************************************************************/
+irqreturn_t mv_pp3_done_pool_isr(int irq, int group_id)
+{
+	int cpu = smp_processor_id();
+	struct pp3_cpu *cpu_ctrl = pp3_cpus[cpu];
+
+	STAT_INFO(cpu_ctrl->stats.lnx_pool_irq++);
+
+	/* TODO: interrupts Mask */
+
+	tasklet_schedule(cpu_ctrl->bm_msg_tasklet);
+
+	/* TODO: interrupts UnMask */
+
+	return IRQ_HANDLED;
+
+}
+
+void mv_pp3_bm_tasklet(unsigned long data)
+{
+	int pool;
+	unsigned int  ph_addr, vr_addr;
+	struct	pp3_cpu *cpu_ctrl = (struct pp3_cpu *)data;
+	struct	pp3_bm_pool *tx_done_pool = cpu_ctrl->tx_done_pool;
+	struct	pp3_queue *bm_msg_queue = cpu_ctrl->bm_msg_queue;
+
+	while (mv_pp3_hmac_bm_buff_get(bm_msg_queue->frame, bm_msg_queue->rxq.phys_q,
+						&pool, &ph_addr, &vr_addr) != -1) {
+
+		if (pool == tx_done_pool->pool) {
+			dev_kfree_skb_any((struct sk_buff *)(&vr_addr));
+			cpu_ctrl->tx_done_cnt--;
+		}
+		/* TODO: registration mechanisem */
+		/* TODO: else call calback function */
+	}
+}
+
+/****************************************************************
+ * mv_pp3_chan_callback						*
+ *	channel callback function				*
+ ***************************************************************/
+void pp3_chan_callback(int chan, void *msg, int size)
+{
+	/* TODO: lock release*/
+}
+/*
+static const struct net_device_ops mv_pp3_netdev_ops = {
+	.ndo_open            = mv_pp3_open,
+	.ndo_stop            = mv_pp3_stop,
+	.ndo_start_xmit      = mv_pp3_tx,
+	.ndo_set_rx_mode     = mv_pp3_set_rx_mode,
+	.ndo_set_mac_address = mv_pp3_set_mac_addr,
+	.ndo_change_mtu      = mv_pp3_change_mtu,
+	.ndo_tx_timeout      = mv_pp3_tx_timeout,
+	.ndo_get_stats64     = mvneta_get_stats64,
+};
+
+*/
 /****************************************************************
  * mv_pp3_netdev_init						*
  *	Allocate and initialize net_device structures		*
@@ -71,7 +224,7 @@ struct net_device *mv_pp3_netdev_init(int mtu, u8 *mac, struct platform_device *
 static int mv_pp3_dev_priv_init(int index, struct net_device *dev)
 {
 	struct pp3_dev_priv *dev_priv;
-	int cpu, num, first, frame, i;
+	int cpu, num, first, frame, i, size, cfh_size;
 
 	dev_priv = MV_PP3_PRIV(dev);
 
@@ -90,7 +243,7 @@ static int mv_pp3_dev_priv_init(int index, struct net_device *dev)
 		group = dev_priv->groups[cpu];
 
 		/* init group rxqs */
-		/*pp3_config_mngr_rxq(emac_map, cpu, &first, &num, &frame);*/
+		/*pp3_config_mngr_rxq(emac_map, cpu, &first, &num, &frame, &size);*/
 		group->rxqs_num = num;
 		group->rxqs = kmalloc(sizeof(struct pp3_rxq *) * num, GFP_KERNEL);
 		memset(group->rxqs, 0, sizeof(struct pp3_rxq *) * num);
@@ -102,8 +255,7 @@ static int mv_pp3_dev_priv_init(int index, struct net_device *dev)
 			group->rxqs[i]->logic_q = i;
 			group->rxqs[i]->phys_q = first + i;
 			group->rxqs[i]->type = PP3_Q_TYPE_QM;
-			/*mv_pp3_hmac_rxq_init(frame, first + i);*/
-			/*group->rxqs[i]->hmac_queue = mv_pp3_hmac_rxq_get(frame, firts + i);*/
+			mv_pp3_hmac_rxq_init(frame, first + i, size);
 			group->rxqs[i]->dev_priv = dev_priv;
 			group->rxqs[i]->pkt_coal = CONFIG_PP3_RX_COAL_PKTS;
 			group->rxqs[i]->time_coal = CONFIG_PP3_RX_COAL_USEC;
@@ -113,7 +265,7 @@ static int mv_pp3_dev_priv_init(int index, struct net_device *dev)
 		/*pp3_config_mngr_emac_map(dev_priv->index, &dev_priv->emac_map);*/
 
 		/* init group txqs */
-		/*pp3_config_mngr_txq(dev_priv->index, cpu, &first, &num, &frame);*/
+		/*pp3_config_mngr_txq(dev_priv->index, cpu, &first, &num, &frame, &size, &cfh_size);*/
 		group->txqs_num = num;
 		group->txqs = kmalloc(sizeof(struct pp3_txq *) * num, GFP_KERNEL);
 		memset(group->txqs, 0, sizeof(struct pp3_txq *) * num);
@@ -125,8 +277,7 @@ static int mv_pp3_dev_priv_init(int index, struct net_device *dev)
 			group->txqs[i]->logic_q = i;
 			group->txqs[i]->phys_q = first + i;
 			group->txqs[i]->type = PP3_Q_TYPE_QM;
-			/*mv_pp3_hmac_txq_init(frame, first + i);*/
-			/*group->txqs[i]->hmac_queue = mv_pp3_hmac_txq_get(frame, firts + i);*/
+			mv_pp3_hmac_txq_init(frame, first + i, size, cfh_size);
 			group->txqs[i]->dev_priv = dev_priv;
 		}
 
@@ -144,8 +295,8 @@ static int mv_pp3_dev_priv_init(int index, struct net_device *dev)
 		memset(group->napi, 0, sizeof(struct napi_struct));
 		netif_napi_add(dev, group->napi, mv_pp3_poll, CONFIG_MV_ETH_RX_POLL_WEIGHT);
 
-
-		/* TODO: init pools */
+		pp3_groups[cpu][index] = group;
+		pp3_cpus[cpu]->dev_priv[index] = dev_priv;
 
 	} /* for */
 
@@ -248,7 +399,9 @@ static struct platform_driver mv_pp3_driver = {
 */
 static int mv_pp3_shared_probe(struct platform_device *pdev)
 {
-	int size, ret;
+	int size, ret, cpu, frame, queue;
+	unsigned int frames;
+	struct pp3_cpu *cpu_ctrl;
 	struct mv_pp3_plat_data *plat_data = (struct mv_pp3_plat_data *)pdev->dev.platform_data;
 
 	pp3_ports_num = plat_data->max_port;
@@ -257,16 +410,61 @@ static int mv_pp3_shared_probe(struct platform_device *pdev)
 		init sysfs
 		init window */
 
-	size = pp3_ports_num * sizeof(struct pp3_dev_priv *);
-	pp3_ports = kzalloc(size, GFP_KERNEL);
+	/* init dev_priv array */
+	pp3_ports = kzalloc(pp3_ports_num * sizeof(struct pp3_dev_priv *), GFP_KERNEL);
 	if (!pp3_ports)
 		goto out;
 
 	memset(pp3_ports, 0, size);
 
+	pp3_cpus = kzalloc(nr_cpu_ids * sizeof(struct pp3_cpu *), GFP_KERNEL);
+		if (!pp3_cpus)
+			goto out;
+
+	memset(pp3_cpus, 0, size);
+
 	/* if (mv_eth_bm_pools_init())
 		goto oom;*/
 
+	/* TODO QM pools init	*/
+	/* QM init		*/
+	/* TODO HMAC unit int	*/
+
+	/*mv_pp3_messenger_init();*/
+
+	for_each_possible_cpu(cpu) {
+		cpu_ctrl = kzalloc(sizeof(struct pp3_cpu), GFP_KERNEL);
+
+		if (!cpu_ctrl)
+			goto out;
+
+		pp3_cpus[cpu] = cpu_ctrl;
+
+		/* TODO: call to config manager: get frames bitmap per cpu */
+		/*pp3_config_mngr_frm_num(cpu, &frames);*/
+		cpu_ctrl->frame_bmp = frames;
+
+		/* TODO: call to config manager: get free pool id */
+		/* pp3_config_mngr_bm_pool_get(&pool_id);*/
+		/*cpu_ctrl->tx_done_pool =  bm_pool_init(pool_id);*/
+
+		/* TODO: call to config manager: get frame and queue num in order to manage bm pool */
+		/* pp3_config_mngr_bm_queue(cpu, &frame, &qeueu)*/
+		mv_pp3_hmac_bm_queue_init(frame, queue, size);
+		cpu_ctrl->bm_msg_tasklet = kmalloc(sizeof(struct tasklet_struct), GFP_KERNEL);
+		tasklet_init(pp3_cpus[cpu]->bm_msg_tasklet, mv_pp3_bm_tasklet, (unsigned long)pp3_cpus[cpu]);
+
+		/* init timer */
+		cpu_ctrl->tx_done_timer.function = mv_pp3_tx_done_timer_callback;
+		init_timer(&cpu_ctrl->tx_done_timer);
+		clear_bit(MV_CPU_F_TX_DONE_TIMER_BIT, &cpu_ctrl->flags);
+		cpu_ctrl->tx_done_timer.data = (unsigned long)pp3_cpus[cpu];
+
+		/* Channel create */
+		/*cpu_ctrl->chan_id = mv_pp3_chan_create(int size, 0, pp3_chan_callback);*/
+	}
+
+
 	/* TODO: set links interrupt */
 
 	pp3_initialized = 1;
@@ -315,131 +513,6 @@ static void __exit mv_pp3_cleanup_module(void)
 }
 module_exit(mv_pp3_cleanup_module);
 
-/****************************************************************
- * mv_pp3_isr							*
- *	rx events , group interrupt handle			*
- ***************************************************************/
-irqreturn_t mv_pp3_isr(int irq, int group_id)
-{
-	int cpu = smp_processor_id();
-	struct pp3_group *group = &pp3_groups[cpu][group_id];
-	struct napi_struct *napi = group->napi;
-
-	STAT_INFO(group->stats.irq++);
-
-	/* TODO: interrupts Mask */
-
-	/* Verify that the device not already on the polling list */
-	if (napi_schedule_prep(napi)) {
-		/* schedule the work (rx+txdone+link) out of interrupt contxet */
-		__napi_schedule(napi);
-	} else {
-		STAT_INFO(group->stats.irq_err++);
-	}
-
-	/* TODO: interrupts unMask */
-
-	return IRQ_HANDLED;
-}
-
-/****************************************************************
- * mv_pp3_poll							*
- *	napi func - call to mv_pp3_rx for group's rxqs		*
- ***************************************************************/
-static int mv_pp3_poll(struct napi_struct *napi, int budget)
-{
-	int rx_done = 0;
-	struct pp3_dev_priv *priv = MV_PP3_PRIV(napi->dev);
-	struct pp3_group *group = priv->groups[smp_processor_id()];
-
-	if (!test_bit(MV_ETH_F_STARTED_BIT, &(priv->flags))) {
-		napi_complete(napi);
-		return rx_done;
-	}
-
-
-	STAT_INFO(group->stats.rx_poll++);
-
-	/* TODO */
-
-
-	while (budget > 0 /* && group rxqs are not empty */) {
-
-		/* TODO
-			select rx_queue
-			call to mv_pp3_rx()
-			update counters and budget
-		*/
-	}
-
-	if (budget > 0)
-		napi_complete(napi);
-
-
-	return rx_done;
-}
-
-/****************************************************************
- * mv_pp3_linux_pool_isr					*
- *	linux poll full interrupt handler			*
- ***************************************************************/
-irqreturn_t mv_pp3_linux_pool_isr(int irq, int group_id)
-{
-	int cpu = smp_processor_id();
-	struct pp3_cpu *cpu_ctrl = pp3_cpus[cpu];
-
-	STAT_INFO(cpu_ctrl->stats.lnx_pool_irq++);
-
-	/* TODO: interrupts Mask */
-
-	tasklet_schedule(&cpu_ctrl->bm_msg_tasklet);
-
-	/* TODO: interrupts UnMask */
-
-	return IRQ_HANDLED;
-
-}
-
-void mv_pp3_bm_tasklet(unsigned long data)
-{
-	/* TODO
-		while (pool is not empty)
-		1 - read cfh from bm_msg_queue
-		2 - get pool ID from cfh
-		3 - get buffer ptr from cfh
-		4 - if pool ID is linux_pool_tx
-			free buffer
-		    else
-			use callback function, send buffer ptr to application
-	*/
-}
-
-/****************************************************************
- * mv_pp3_fw_isr					*
- *	linux poll full interrupt handler			*
- ***************************************************************/
-irqreturn_t mv_pp3_fw_isr(int irq, int group_id)
-{
-	int cpu = smp_processor_id();
-	struct pp3_cpu *cpu_ctrl = pp3_cpus[cpu];
-
-	STAT_INFO(cpu_ctrl->stats.lnx_fw_irq++);
-
-	/* TODO: interrupts Mask */
-
-	tasklet_schedule(&cpu_ctrl->fw_msg_tasklet);
-
-	/* TODO: interrupts UnMask */
-
-	return IRQ_HANDLED;
-
-}
-
-void mv_pp3_fw_tasklet(unsigned long data)
-{
-	/* TODO */
-}
-
 
 MODULE_DESCRIPTION("Marvell PPv3 Network Driver - www.marvell.com");
 MODULE_AUTHOR("Dmitri Epshtein <dima@marvell.com>");
diff --git a/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev_structs.h b/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev_structs.h
index 753bbb9..5a5126d 100644
--- a/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev_structs.h
+++ b/drivers/net/ethernet/marvell/pp3/net_dev/mv_netdev_structs.h
@@ -35,6 +35,9 @@ disclaimer.
 #define CONFIG_PP3_RX_COAL_USEC 10
 #define CONFIG_PP3_RX_COAL_PKTS 100
 
+/* Timer */
+#define MV_CPU_TX_DONE_TIMER_PERIOD 10
+
 
 #define MV_PP3_PRIV(dev)	((struct pp3_dev_priv *)(netdev_priv(dev)))
 
@@ -51,12 +54,12 @@ struct pp3_dev_priv {
 #define MV_ETH_F_STARTED_BIT		0
 #define MV_ETH_F_LINK_UP_BIT		1
 #define MV_ETH_F_CONNECT_LINUX_BIT	2
-#define MV_ETH_F_DBG_RX_BIT		3
-#define MV_ETH_F_DBG_TX_BIT		4
-#define MV_ETH_F_DBG_DUMP_BIT		5
-#define MV_ETH_F_DBG_ISR_BIT		6
-#define MV_ETH_F_DBG_POLL_BIT		7
-#define MV_ETH_F_DBG_BUFF_HDR_BIT	8
+#define MV_ETH_F_DBG_RX_BIT		4
+#define MV_ETH_F_DBG_TX_BIT		5
+#define MV_ETH_F_DBG_DUMP_BIT		6
+#define MV_ETH_F_DBG_ISR_BIT		7
+#define MV_ETH_F_DBG_POLL_BIT		8
+#define MV_ETH_F_DBG_BUFF_HDR_BIT	9
 
 
 #define MV_ETH_F_STARTED                (1 << MV_ETH_F_STARTED_BIT)
@@ -70,7 +73,6 @@ struct pp3_dev_priv {
 #define MV_ETH_F_DBG_BUFF_HDR		(1 << MV_ETH_F_DBG_BUFF_HDR_BIT)
 
 
-
 struct pp3_group_stats {
 	unsigned int irq;
 	unsigned int irq_err;
@@ -94,29 +96,34 @@ struct pp3_group {
 	struct	pp3_group_stats	stats;
 };
 
+#define MV_CPU_F_TX_DONE_TIMER_BIT	1
+#define MV_CPU_F_TX_DONE_TIMER          (1 << MV_CPU_F_TX_DONE_TIMER_BIT)
+
 struct pp3_cpu_stats {
 	unsigned int lnx_pool_irq;
 	unsigned int lnx_pool_irq_err;
 	unsigned int lnx_fw_irq;
 	unsigned int lnx_fw_irq_err;
-
 };
 
 struct pp3_cpu {
 	int	cpu;
-	int	frames_num;
+	int	frame_bmp;
 /*
 	not sure that pp3_frame is necessary
 	meanwhile not defined
 	struct	pp3_frame	**frame_ctrl;
 */
 	struct	pp3_dev_priv	*dev_priv[MAX_ETH_DEVICES];
-	struct	pp3_bm_pool	*tx_linux_pool;
+	struct	pp3_bm_pool	*tx_done_pool;
 	struct	pp3_queue	*bm_msg_queue;
-	struct	pp3_queue	*fw_msg_queue;
-	struct	tasklet_struct	bm_msg_tasklet;
-	struct	tasklet_struct	fw_msg_tasklet;
+	struct	tasklet_struct	*bm_msg_tasklet;
+	struct  timer_list	tx_done_timer;
 	struct	pp3_cpu_stats	stats;
+	unsigned long		flags;
+	int			tx_done_cnt;
+	int			chan_id;
+
 };
 
 struct pp3_xq_stats {
@@ -160,6 +167,15 @@ struct pp3_txq {
 	*/
 };
 
+struct	pp3_bm_pool {
+	int pool;
+	int capacity;
+	int buf_num;
+	int buf_size;
+	void *virt_base;
+	unsigned long phys_base;
+};
+
 struct pp3_queue {
 	int frame;
 	struct pp3_rxq rxq;
-- 
1.7.5.4

