From e7acbe0a0e0f38c93d6ab077408451fed1728878 Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Fri, 11 Jul 2008 14:02:59 +0800
Subject: [PATCH] nec emma3p platform support


Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/emma3p/common/Makefile       |   13 +
 arch/mips/emma3p/common/irq.c          |  142 ++++++++++++
 arch/mips/emma3p/common/irq_emma.c     |  120 ++++++++++
 arch/mips/emma3p/common/prom.c         |   77 +++++++
 arch/mips/emma3p/et10068/Makefile      |   14 ++
 arch/mips/emma3p/et10068/irq.c         |  108 +++++++++
 arch/mips/emma3p/et10068/irq_et10068.c |  198 +++++++++++++++++
 arch/mips/emma3p/et10068/led.c         |  200 +++++++++++++++++
 arch/mips/emma3p/et10068/platform.c    |  251 +++++++++++++++++++++
 arch/mips/emma3p/et10068/setup.c       |  172 ++++++++++++++
 arch/mips/pci/Makefile                 |    1 +
 arch/mips/pci/fixup-emma3p.c           |   96 ++++++++
 arch/mips/pci/ops-emma3p.c             |  198 +++++++++++++++++
 arch/mips/pci/pci-emma3p.c             |  115 ++++++++++
 include/asm-mips/emma3p/emma3p.h       |  381 ++++++++++++++++++++++++++++++++
 include/asm-mips/emma3p/et10068.h      |   30 +++
 include/asm-mips/mach-emma3p/irq.h     |   24 ++
 include/asm-mips/mach-emma3p/war.h     |   25 ++
 include/linux/pci_ids.h                |    1 +
 19 files changed, 2166 insertions(+), 0 deletions(-)

diff --git a/arch/mips/emma3p/common/Makefile b/arch/mips/emma3p/common/Makefile
new file mode 100644
index 0000000..18b20c3
--- /dev/null
+++ b/arch/mips/emma3p/common/Makefile
@@ -0,0 +1,13 @@
+#
+#  arch/mips/emma3p/common/Makefile
+#       Makefile for the common code of NEC EMMA3P based board.
+#
+#  Copyright (C) NEC Electronics Corporation 2005-2007
+#
+#  This program is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU General Public License as published by
+#  the Free Software Foundation; either version 2 of the License, or
+#  (at your option) any later version.
+#
+
+obj-$(CONFIG_ET10068)	+= irq.o irq_emma.o prom.o
diff --git a/arch/mips/emma3p/common/irq.c b/arch/mips/emma3p/common/irq.c
new file mode 100644
index 0000000..04beab5
--- /dev/null
+++ b/arch/mips/emma3p/common/irq.c
@@ -0,0 +1,142 @@
+/*
+ *  arch/mips/emma3p/common/irq.c
+ *      This file is common irq dispatcher.
+ *
+ *  Copyright (C) NEC Electronics Corporation 2005-2007
+ *
+ *  This file is based on the arch/mips/ddb5xxx/ddb5477/irq.c
+ *
+ *  Changes:
+ *		Wind River Systems, Inc.
+ *		- Ported to Linux 2.6.21 by Jack Tan <jack.tan@windriver.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/autoconf.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/types.h>
+
+#include <asm/system.h>
+#include <asm/mipsregs.h>
+#include <asm/debug.h>
+#include <asm/addrspace.h>
+#include <asm/bootinfo.h>
+
+#include <asm/emma3p/emma3p.h>
+
+
+static void emma_irq_dispatch(void)
+{
+	u32 intStatus;
+	u32 bitmask;
+	u32 i;
+
+	intStatus = emma_in32(EMMA_BHIF_INT_ST_0)
+	    & emma_in32(EMMA_BHIF_INT0_EN_0);
+
+#ifdef EMMA_SW_CASCADE
+	if (intStatus &
+	    (1 << ((EMMA_SW_CASCADE - EMMA_IRQ_BASE) & (32 - 1)))) {
+		u32 swIntStatus;
+		swIntStatus = emma_in32(EMMA_BHIF_SW_INT0)
+		    & emma_in32(EMMA_BHIF_SW_INT0_EN);
+		for (i = 0, bitmask = 1; i < 32; i++, bitmask <<= 1) {
+			if (swIntStatus & bitmask) {
+				do_IRQ(EMMA_SW_IRQ_BASE + i);
+				return;
+			}
+		}
+	}
+	/* ignoring SW interrupt */
+	intStatus &= ~(1UL << (EMMA_SW_CASCADE - EMMA_IRQ_BASE));
+#endif
+
+	for (i = 0, bitmask = 1; i < 32; i++, bitmask <<= 1) {
+		if (intStatus & bitmask) {
+			do_IRQ(EMMA_IRQ_BASE + i);
+			return;
+		}
+	}
+
+	intStatus = emma_in32(EMMA_BHIF_INT_ST_1)
+	    & emma_in32(EMMA_BHIF_INT0_EN_1);
+
+#ifdef EMMA_GPIO_CASCADE
+	if (intStatus &
+	    (1 << ((EMMA_GPIO_CASCADE - EMMA_IRQ_BASE) & (32 - 1)))) {
+		u32 gpioIntStatus;
+		gpioIntStatus = emma_in32(EMMA_GPIO0_INT)
+		    & emma_in32(EMMA_GPIO0_INT_CPUMEN);
+		for (i = 0, bitmask = 1; i < 32; i++, bitmask <<= 1) {
+			if (gpioIntStatus & bitmask) {
+				do_IRQ(EMMA_GPIO_IRQ_BASE + i);
+				return;
+			}
+		}
+
+		gpioIntStatus = emma_in32(EMMA_GPIO1_INT)
+		    & emma_in32(EMMA_GPIO1_INT_CPUMEN);
+		for (i = 32, bitmask = 1; i < 64; i++, bitmask <<= 1) {
+			if (gpioIntStatus & bitmask) {
+				do_IRQ(EMMA_GPIO_IRQ_BASE + i);
+				return;
+			}
+		}
+		gpioIntStatus = emma_in32(EMMA_GPIO2_INT)
+		    & emma_in32(EMMA_GPIO2_INT_CPUMEN);
+		for (i = 64, bitmask = 1; i < 96; i++, bitmask <<= 1) {
+			if (gpioIntStatus & bitmask) {
+				do_IRQ(EMMA_GPIO_IRQ_BASE + i);
+				return;
+			}
+		}
+	}
+
+	/* ignoring GPIO interrupt */
+	intStatus &=  ~(1UL << (EMMA_GPIO_CASCADE - EMMA_IRQ_BASE - 32));
+#endif
+
+	for (i = 32, bitmask = 1; i < 64; i++, bitmask <<= 1) {
+		if (intStatus & bitmask) {
+			do_IRQ(EMMA_IRQ_BASE + i);
+			return;
+		}
+	}
+}
+
+asmlinkage void plat_irq_dispatch(void)
+{
+	unsigned int pending = read_c0_status() & read_c0_cause();
+
+	if (pending & STATUSF_IP7) {
+		do_IRQ(CPU_IRQ_BASE + 7);
+	}
+	else if (pending & STATUSF_IP2) {
+		emma_irq_dispatch();
+	}
+	else if (pending & STATUSF_IP1) {
+		do_IRQ(CPU_IRQ_BASE + 1);
+	}
+	else if (pending & STATUSF_IP0) {
+		do_IRQ(CPU_IRQ_BASE + 0);
+	}
+	else
+		spurious_interrupt();
+
+}
+
diff --git a/arch/mips/emma3p/common/irq_emma.c b/arch/mips/emma3p/common/irq_emma.c
new file mode 100644
index 0000000..accf422
--- /dev/null
+++ b/arch/mips/emma3p/common/irq_emma.c
@@ -0,0 +1,120 @@
+/*
+ *  arch/mips/emma3p/common/irq_emma.c
+ *      This file defines the irq handler for EMMA.
+ *
+ *  Copyright (C) NEC Electronics Corporation 2005-2007
+ *
+ *  This file is based on the arch/mips/ddb5xxx/ddb5477/irq_5477.c
+ *
+ *  Changes:
+ *		Wind River Systems, Inc.
+ *		- Ported to Linux 2.6.21 by Jack Tan <jack.tan@windriver.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * EMMA defines 64 IRQs.
+ *
+ * This file exports one function:
+ *	emma_irq_init(u32 irq_base);
+ */
+
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/ptrace.h>
+
+#include <asm/debug.h>
+
+#include <asm/emma3p/emma3p.h>
+
+/* number of total irqs supported by EMMA */
+#define	NUM_EMMA_IRQ		96
+
+static int emma_irq_base = -1;
+
+void ll_emma_irq_enable(int);
+void ll_emma_irq_disable(int);
+
+static void emma_irq_enable(unsigned int irq)
+{
+	ll_emma_irq_enable(irq - emma_irq_base);
+}
+
+static void emma_irq_disable(unsigned int irq)
+{
+	ll_emma_irq_disable(irq - emma_irq_base);
+}
+
+#define	emma_irq_shutdown	emma_irq_disable
+
+/*
+static void emma_irq_end(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED | IRQ_INPROGRESS)))
+		ll_emma_irq_enable(irq - emma_irq_base);
+}
+*/
+
+struct irq_chip emma_irq_controller = {
+	.name = "emma_irq",
+	.ack = emma_irq_disable,
+	.mask = emma_irq_disable,
+	.mask_ack = emma_irq_disable,
+	.unmask = emma_irq_enable
+};
+
+void emma_irq_init(u32 irq_base)
+{
+	extern irq_desc_t irq_desc[];
+	u32 i;
+
+	for (i = irq_base; i < irq_base + NUM_EMMA_IRQ; i++) {
+		set_irq_chip_and_handler(i, &emma_irq_controller,
+					 handle_level_irq);
+	}
+
+	emma_irq_base = irq_base;
+}
+
+void ll_emma_irq_enable(int emma_irq)
+{
+	u32 reg_value;
+	u32 reg_bitmask;
+	u32 reg_index;
+
+	reg_index = EMMA_BHIF_INT0_EN_0
+	    + (EMMA_BHIF_INT0_EN_1 - EMMA_BHIF_INT0_EN_0)
+	    * (emma_irq / 32);
+	reg_value = emma_in32(reg_index);
+	reg_bitmask = 0x1 << (emma_irq % 32);
+	db_assert((reg_value & reg_bitmask) == 0);
+	emma_out32(reg_index, reg_value | reg_bitmask);
+}
+
+void ll_emma_irq_disable(int emma_irq)
+{
+	u32 reg_value;
+	u32 reg_bitmask;
+	u32 reg_index;
+
+	reg_index = EMMA_BHIF_INT0_EN_0
+	    + (EMMA_BHIF_INT0_EN_1 - EMMA_BHIF_INT0_EN_0)
+	    * (emma_irq / 32);
+	reg_value = emma_in32(reg_index);
+	reg_bitmask = 0x1 << (emma_irq % 32);
+	db_assert((reg_value & reg_bitmask) != 0);
+	emma_out32(reg_index, reg_value & ~reg_bitmask);
+}
diff --git a/arch/mips/emma3p/common/prom.c b/arch/mips/emma3p/common/prom.c
new file mode 100644
index 0000000..1c1b593
--- /dev/null
+++ b/arch/mips/emma3p/common/prom.c
@@ -0,0 +1,77 @@
+/*
+ *  arch/mips/emma3p/common/prom.c
+ *      This file is prom file.
+ *
+ *  Copyright (C) NEC Electronics Corporation 2004-2007
+ *
+ *  This file is based on the arch/mips/ddb5xxx/common/prom.c
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/bootmem.h>
+
+#include <asm/addrspace.h>
+#include <asm/bootinfo.h>
+#include <asm/emma3p/emma3p.h>
+#include <asm/debug.h>
+
+const char *get_system_type(void)
+{
+	switch (mips_machtype) {
+		case MACH_NEC_ET10068:
+			return "NEC EMMA3P ET10068";
+		default:
+			return "Unknown NEC board";
+	}
+}
+
+/* [jsun@junsun.net] PMON passes arguments in C main() style */
+void __init prom_init(void)
+{
+	int argc = fw_arg0;
+	char **arg = (char **)fw_arg1;
+	int i;
+
+	/* if user passes kernel args, ignore the default one */
+	if (argc > 1)
+		arcs_cmdline[0] = '\0';
+
+	/* arg[0] is "g", the rest is boot parameters */
+	for (i = 1; i < argc; i++) {
+		if (strlen(arcs_cmdline) + strlen(arg[i] + 1)
+		    >= sizeof(arcs_cmdline))
+			break;
+		strcat(arcs_cmdline, arg[i]);
+		strcat(arcs_cmdline, " ");
+	}
+
+#if defined(CONFIG_ET10068)
+	mips_machtype = MACH_NEC_ET10068;
+	/* 
+	 * 512MB + 256MB
+	 * 256M reserved for Audio CPU 
+	 */
+	add_memory_region(0, 0xa000000, BOOT_MEM_RAM);
+	add_memory_region(0x20000000, 0x10000000, BOOT_MEM_RAM);
+#endif
+
+}
+
+void __init prom_free_prom_memory(void)
+{
+}
diff --git a/arch/mips/emma3p/et10068/Makefile b/arch/mips/emma3p/et10068/Makefile
new file mode 100644
index 0000000..89d974c
--- /dev/null
+++ b/arch/mips/emma3p/et10068/Makefile
@@ -0,0 +1,14 @@
+#
+#  arch/mips/emma3p/et10068/Makefile
+#       Makefile for the common code of NEC EMMA3P based board.
+#
+#  Copyright (C) NEC Electronics Corporation 2005-2007
+#
+#  This program is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU General Public License as published by
+#  the Free Software Foundation; either version 2 of the License, or
+#  (at your option) any later version.
+#
+
+obj-$(CONFIG_ET10068) += irq.o irq_et10068.o setup.o led.o platform.o
+# EXTRA_AFLAGS := $(CFLAGS)
diff --git a/arch/mips/emma3p/et10068/irq.c b/arch/mips/emma3p/et10068/irq.c
new file mode 100644
index 0000000..79b269b
--- /dev/null
+++ b/arch/mips/emma3p/et10068/irq.c
@@ -0,0 +1,108 @@
+/*
+ *  arch/mips/emma3p/et10068/irq.c
+ *      This file defines the irq handler for EMMA3P.
+ *
+ *  Copyright (C) NEC Electronics Corporation 2004-2007
+ *
+ *  This file is based on the arch/mips/ddb5xxx/ddb5477/irq.c
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/autoconf.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/types.h>
+#include <linux/ptrace.h>
+
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/mipsregs.h>
+#include <asm/debug.h>
+#include <asm/addrspace.h>
+#include <asm/bootinfo.h>
+
+#include <asm/emma3p/emma3p.h>
+
+/*
+ * IRQ mapping
+ *
+ *  0-7: 8 CPU interrupts
+ *	0 -	software interrupt 0
+ *	1 - 	software interrupt 1
+ *	2 - 	most Vrc5477 interrupts are routed to this pin
+ *	3 - 	(optional) some other interrupts routed to this pin for debugg
+ *	4 - 	not used
+ *	5 - 	not used
+ *	6 - 	not used
+ *	7 - 	cpu timer (used by default)
+ *
+ */
+
+extern void emma_sw_irq_init(u32 base);
+extern void emma_gpio_irq_init(u32 base);
+extern void emma_irq_init(u32 base);
+extern void mips_cpu_irq_init(u32 base);
+extern asmlinkage void emma_handle_int(void);
+extern int setup_irq(unsigned int irq, struct irqaction *irqaction);
+static struct irqaction irq_cascade =
+    { no_action, 0, CPU_MASK_NONE, "cascade", NULL, NULL };
+
+void __init arch_init_irq(void)
+{
+	u32 reg;
+
+	db_run(printk("et10068_irq_setup invoked.\n"));
+
+	/* by default, interrupts are disabled. */
+	emma_out32(EMMA_BHIF_INT0_EN_0, 0);
+	emma_out32(EMMA_BHIF_INT0_EN_1, 0);
+	emma_out32(EMMA_BHIF_INT0_EN_2, 0);
+	emma_out32(EMMA_BHIF_INT1_EN_0, 0);
+	emma_out32(EMMA_BHIF_INT1_EN_1, 0);
+	emma_out32(EMMA_BHIF_INT1_EN_2, 0);
+	emma_out32(EMMA_BHIF_SW_INT0_EN, 0);
+
+	clear_c0_status(0xff00);
+	set_c0_status(0x0400);
+
+#define GPIO_PCI ((0x1UL << 10) | (0x1UL << 11))
+	/* setup GPIO interrupt for PCI interface */
+	/* direction input */
+	reg = emma_in32(EMMA_GPIO0_DIR);
+	emma_out32(EMMA_GPIO0_DIR, reg & ~GPIO_PCI);
+	/* disable interrupt */
+	reg = emma_in32(EMMA_GPIO0_INT_CPUMEN);
+	emma_out32(EMMA_GPIO0_INT_CPUMEN, reg & ~GPIO_PCI);
+	/* level triggerd */
+	reg = emma_in32(EMMA_GPIO0_INT_MODE);
+	emma_out32(EMMA_GPIO0_INT_MODE, reg | GPIO_PCI);
+	reg = emma_in32(EMMA_GPIO0_INT_CND_A);
+	emma_out32(EMMA_GPIO0_INT_CND_A, reg & ~GPIO_PCI);
+	/* interrupt clear */
+	emma_out32(EMMA_GPIO0_INT, ~GPIO_PCI);
+
+	/* init all controllers */
+	emma_irq_init(EMMA_IRQ_BASE);
+	emma_sw_irq_init(EMMA_SW_IRQ_BASE);
+	emma_gpio_irq_init(EMMA_GPIO_IRQ_BASE);
+	mips_cpu_irq_init(CPU_IRQ_BASE);
+
+	/* setup cascade interrupts */
+	setup_irq(CPU_IRQ_BASE + CPU_EMMA_CASCADE, &irq_cascade);
+	setup_irq(EMMA_SW_CASCADE, &irq_cascade);
+	setup_irq(EMMA_GPIO_CASCADE, &irq_cascade);
+
+}
diff --git a/arch/mips/emma3p/et10068/irq_et10068.c b/arch/mips/emma3p/et10068/irq_et10068.c
new file mode 100644
index 0000000..7cefc5b
--- /dev/null
+++ b/arch/mips/emma3p/et10068/irq_et10068.c
@@ -0,0 +1,198 @@
+/*
+ *  arch/mips/emma3p/et10068/irq_et10068.c
+ *      This file defines the irq handler for ET10068.
+ *
+ *  Copyright (C) NEC Electronics Corporation 2004-2007
+ *
+ *  This file is based on the arch/mips/ddb5xxx/ddb5477/irq_5477.c
+ *
+ *  Changes:
+ *		Wind River Systems, Inc.
+ *		- Ported to Linux 2.6.21 by Jack Tan <jack.tan@windriver.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/ptrace.h>
+
+#include <asm/debug.h>
+#include <asm/emma3p/emma3p.h>
+
+static int emma_sw_irq_base = -1;
+static int emma_gpio_irq_base = -1;
+
+void ll_emma_sw_irq_enable(int reg);
+void ll_emma_sw_irq_disable(int reg);
+void ll_emma_gpio_irq_enable(int reg);
+void ll_emma_gpio_irq_disable(int reg);
+
+static void emma_sw_irq_enable(unsigned int irq)
+{
+	ll_emma_sw_irq_enable(irq - emma_sw_irq_base);
+}
+
+static void emma_sw_irq_disable(unsigned int irq)
+{
+	ll_emma_sw_irq_disable(irq - emma_sw_irq_base);
+}
+
+struct irq_chip emma_sw_irq_controller = {
+	.name = "emma_sw_irq",
+	.ack = emma_sw_irq_disable,
+	.mask = emma_sw_irq_disable,
+	.mask_ack = emma_sw_irq_disable,
+	.unmask = emma_sw_irq_enable,
+};
+
+void emma_sw_irq_init(u32 irq_base)
+{
+	extern irq_desc_t irq_desc[];
+	u32 i;
+
+	for (i = irq_base; i < irq_base + NUM_EMMA_IRQ_SW; i++) {
+		set_irq_chip_and_handler(i, &emma_sw_irq_controller, handle_level_irq);
+	}
+
+	emma_sw_irq_base = irq_base;
+}
+
+void ll_emma_sw_irq_enable(int irq)
+{
+	u32 reg;
+
+	db_assert(irq >= 0);
+	db_assert(irq < NUM_EMMA_IRQ_SW);
+
+	reg = emma_in32(EMMA_BHIF_SW_INT0_EN);
+	reg |= 1 << irq;
+	emma_out32(EMMA_BHIF_SW_INT0_EN, reg);
+}
+
+void ll_emma_sw_irq_disable(int irq)
+{
+	u32 reg;
+
+	db_assert(irq >= 0);
+	db_assert(irq < 32);
+
+	reg = emma_in32(EMMA_BHIF_SW_INT0_EN);
+	reg &= ~(1 << irq);
+	emma_out32(EMMA_BHIF_SW_INT0_EN, reg);
+}
+
+static void emma_gpio_irq_enable(unsigned int irq)
+{
+	ll_emma_gpio_irq_enable(irq - emma_gpio_irq_base);
+}
+
+static void emma_gpio_irq_disable(unsigned int irq)
+{
+	ll_emma_gpio_irq_disable(irq - emma_gpio_irq_base);
+}
+
+static void emma_gpio_irq_ack(unsigned int irq)
+{
+	irq -= emma_gpio_irq_base;
+	if (irq < 32) {
+		emma_out32(EMMA_GPIO0_INT, ~(1 << irq));
+		ll_emma_gpio_irq_disable(irq);
+	} else if (irq < 64) {
+		irq -= 32;
+		emma_out32(EMMA_GPIO1_INT, ~(1 << irq));
+		ll_emma_gpio_irq_disable(irq + 32);
+	} else {
+		irq -= 64;
+		emma_out32(EMMA_GPIO2_INT, ~(1 << irq));
+		ll_emma_gpio_irq_disable(irq + 64);
+	}
+
+}
+
+static void emma_gpio_irq_end(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED | IRQ_INPROGRESS)))
+		ll_emma_gpio_irq_enable(irq - emma_gpio_irq_base);
+}
+
+
+struct irq_chip emma_gpio_irq_controller = {
+	.name = "emma_gpio_irq",
+	.ack = emma_gpio_irq_ack,
+	.mask = emma_gpio_irq_disable,
+	.mask_ack = emma_gpio_irq_ack,
+	.unmask = emma_gpio_irq_enable,
+	.end = emma_gpio_irq_end
+};
+
+void emma_gpio_irq_init(u32 irq_base)
+{
+	extern irq_desc_t irq_desc[];
+	u32 i;
+
+	for (i = irq_base; i < irq_base + NUM_EMMA_IRQ_GPIO; i++) {
+		set_irq_chip(i, &emma_gpio_irq_controller);
+	}
+
+	emma_gpio_irq_base = irq_base;
+}
+
+void ll_emma_gpio_irq_enable(int irq)
+{
+	u32 reg;
+
+	db_assert(irq >= 0);
+	db_assert(irq < NUM_EMMA_IRQ_GPIO);
+
+	if (irq < 32) {
+		reg = emma_in32(EMMA_GPIO0_INT_CPUMEN);
+		reg |= 1 << irq;
+		emma_out32(EMMA_GPIO0_INT_CPUMEN, reg);
+	} else if (irq < 64) {
+		irq -= 32;
+		reg = emma_in32(EMMA_GPIO1_INT_CPUMEN);
+		reg |= 1 << irq;
+		emma_out32(EMMA_GPIO1_INT_CPUMEN, reg);
+	} else {
+		irq -= 64;
+		reg = emma_in32(EMMA_GPIO2_INT_CPUMEN);
+		reg |= 1 << irq;
+		emma_out32(EMMA_GPIO2_INT_CPUMEN, reg);
+	}
+}
+
+void ll_emma_gpio_irq_disable(int irq)
+{
+	u32 reg;
+
+	db_assert(irq >= 0);
+	db_assert(irq < NUM_EMMA_IRQ_GPIO);
+
+	if (irq < 32) {
+		reg = emma_in32(EMMA_GPIO0_INT_CPUMEN);
+		reg &= ~(1 << irq);
+		emma_out32(EMMA_GPIO0_INT_CPUMEN, reg);
+	} else if (irq < 64) {
+		irq -= 32;
+		reg = emma_in32(EMMA_GPIO1_INT_CPUMEN);
+		reg &= ~(1 << irq);
+		emma_out32(EMMA_GPIO1_INT_CPUMEN, reg);
+	} else {
+		irq -= 64;
+		reg = emma_in32(EMMA_GPIO2_INT_CPUMEN);
+		reg &= ~(1 << irq);
+		emma_out32(EMMA_GPIO2_INT_CPUMEN, reg);
+	}
+}
diff --git a/arch/mips/emma3p/et10068/led.c b/arch/mips/emma3p/et10068/led.c
new file mode 100644
index 0000000..171f27b
--- /dev/null
+++ b/arch/mips/emma3p/et10068/led.c
@@ -0,0 +1,200 @@
+/*
+ *  Copyright 2008 Wind River Systems, Inc. 
+ *
+ *  Author: Jack Tan <jack.tan@windriver.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/string.h>
+#include <asm/emma3p/emma3p.h>
+
+#define	LED_BASE	(EMMA_GPIO0_BASE + 0x3c)
+#define	GPIO_LED	0x003f8000	
+
+#ifdef TEST_LED_WHEN_INIT
+extern void emma_time_init();
+
+static inline void emma_udelay(unsigned long usecs)                                                          
+{                                                                                                       
+    cycles_t cycles = get_cycles();                                                                     
+    cycles_t end_cycles = cycles + usecs * mips_hpt_frequency * 2 / 100000;                                  
+    do                                                                                                  
+    {                                                                                                   
+        cycles = get_cycles();                                                                          
+    } while (cycles<end_cycles);                                                                        
+}       
+
+static inline void emma_mdelay(unsigned long msecs)
+{
+	do
+	{
+		emma_udelay(1000);
+	} while (msecs--);
+}
+#endif
+
+void et10068_led_init(void)
+{
+	u32 reg;
+	reg = emma_in32(EMMA_GPIO0_DIR);
+	emma_out32(EMMA_GPIO0_DIR, reg | GPIO_LED);
+
+#ifdef TEST_LED_WHEN_INIT
+	emma_time_init();		/* set mips_hpt_frequency */
+#endif 
+}
+
+static inline void et10068_led_clear(void)
+{
+	emma_out32(LED_BASE, 0);
+	emma_out32(LED_BASE + 0x4, 0);
+	emma_out32(LED_BASE + 0x8, 0);
+	emma_out32(LED_BASE + 0xc, 0);
+	emma_out32(LED_BASE + 0x10, 0);
+	emma_out32(LED_BASE + 0x14, 0);
+	emma_out32(LED_BASE + 0x18, 0);
+}
+
+/*show all */
+static inline void et10068_led_all(void)
+{
+	emma_out32(LED_BASE, 1);
+	emma_out32(LED_BASE + 0x4, 1);
+	emma_out32(LED_BASE + 0x8, 1);
+	emma_out32(LED_BASE + 0xc, 1);
+	emma_out32(LED_BASE + 0x10, 1);
+	emma_out32(LED_BASE + 0x14, 1);
+	emma_out32(LED_BASE + 0x18, 1);
+}
+
+/* show S */
+static inline void et10068_led_start(void)
+{
+	emma_out32(LED_BASE, 1);
+	emma_out32(LED_BASE + 0x14, 1);
+	emma_out32(LED_BASE + 0x18, 1);
+	emma_out32(LED_BASE + 0x8, 1);
+	emma_out32(LED_BASE + 0xc, 1);
+}
+
+/* show R */
+static inline void et10068_led_restart(void)
+{
+	emma_out32(LED_BASE, 1);
+	emma_out32(LED_BASE + 0x4, 1);
+	emma_out32(LED_BASE + 0x18, 1);
+	emma_out32(LED_BASE + 0x14, 1);
+	emma_out32(LED_BASE + 0x10, 1);
+	emma_out32(LED_BASE + 0x8, 1);
+}
+
+/* show P */
+static inline void et10068_led_poweroff(void)
+{
+	emma_out32(LED_BASE, 1);
+	emma_out32(LED_BASE + 0x4, 1);
+	emma_out32(LED_BASE + 0x18, 1);
+	emma_out32(LED_BASE + 0x14, 1);
+	emma_out32(LED_BASE + 0x10, 1);
+}
+
+/* show H */
+static inline void et10068_led_halted(void)
+{
+	emma_out32(LED_BASE + 0x14, 1);
+	emma_out32(LED_BASE + 0x10, 1);
+	emma_out32(LED_BASE + 0x18, 1);
+	emma_out32(LED_BASE + 0x4, 1);
+	emma_out32(LED_BASE + 0x8, 1);
+}
+
+void show_default(int c)
+{
+	int i;
+	for(i=0; i<c; i++)
+	{
+		et10068_led_all();
+#ifdef TEST_LED_WHEN_INIT
+		emma_mdelay(500);
+#else
+		mdelay(500);
+#endif
+		et10068_led_clear();
+#ifdef TEST_LED_WHEN_INIT
+		emma_mdelay(300);
+#else
+		mdelay(300);
+#endif
+	}
+}
+
+static void show_restart(int c)
+{
+	int i;
+	for(i=0; i<c; i++)
+	{
+		et10068_led_restart();
+		mdelay(500);
+		et10068_led_clear();
+		mdelay(300);
+	}
+}
+
+static void show_poweroff(int c)
+{
+	int i;
+	for(i=0; i<c; i++)
+	{
+		et10068_led_poweroff();
+		mdelay(500);
+		et10068_led_clear();
+		mdelay(300);
+	}
+}
+
+static void show_halted(int c)
+{
+	int i;
+	for(i=0; i<c; i++)
+	{
+		et10068_led_halted();
+		mdelay(500);
+		et10068_led_clear();
+		mdelay(300);
+	}
+}
+
+void et10068_led(const char *str)
+{
+	switch (str[0])
+	{
+		case 'r':
+			show_restart(5);
+			break;
+		case 'p':
+			show_poweroff(5);
+			break;
+		case 'h':
+			show_halted(5);
+			break;
+		default:
+			show_default(5);
+			break;
+	}
+}
+
diff --git a/arch/mips/emma3p/et10068/platform.c b/arch/mips/emma3p/et10068/platform.c
new file mode 100644
index 0000000..45dcf62
--- /dev/null
+++ b/arch/mips/emma3p/et10068/platform.c
@@ -0,0 +1,251 @@
+/*
+ *  arch/mips/emma3p/et10068/platform.c
+ *      This file sets up platform devices for EMMA3P ET10068.
+ *
+ *  Copyright(C) MontaVista Software Inc, 2006
+ *
+ *  Author: dmitry pervushin <dpervushin@ru.mvista.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/ioport.h>
+#include <linux/serial_8250.h>
+#include <linux/mtd/physmap.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/addrspace.h>
+#include <asm/time.h>
+#include <asm/bcache.h>
+#include <asm/irq.h>
+#include <asm/reboot.h>
+#include <asm/gdb-stub.h>
+#include <asm/traps.h>
+#include <asm/debug.h>
+
+#include <asm/emma3p/emma3p.h>
+#include <linux/nec_candy_pd.h>
+
+#define I2C_EMMA "emma-iic" /* must be in sync with IIC driver */
+#define SERIAL_EMMA "serial8250"
+#define NAND_ET10068 "et10068-nand"
+#define SATA_EMMA "sata_emma" /* must be in sync with sata_emma.c DRV_NAME */
+
+
+static struct resource i2c_emma_resources_0[] = {
+	{ 
+		.name = NULL, 
+		.start = EMMA_IRQ_PIIC0,
+		.end = EMMA_IRQ_PIIC0, 
+		.flags = IORESOURCE_IRQ 
+	}, { 
+		.name = NULL, 
+		.start = KSEG1ADDR(EMMA_PIIC0_BASE), 
+		.end = KSEG1ADDR(EMMA_PIIC0_BASE + 0x1000), 
+		.flags = 0 
+	}, { 
+		.name = "pbrd", 
+		.start = KSEG1ADDR(EMMA_PBRD_BASE), 
+		.end = KSEG1ADDR(EMMA_PBRD_BASE + 0x1000),
+		.flags = 0 
+	}
+};
+
+struct resource i2c_emma_resources_1[] = {
+	{ 
+		.name = NULL, 
+		.start = EMMA_IRQ_PIIC1,
+		.end = EMMA_IRQ_PIIC1,
+		.flags = IORESOURCE_IRQ 
+	}, { 
+		.name = NULL,
+		.start = KSEG1ADDR(EMMA_PIIC1_BASE),
+		.end = KSEG1ADDR(EMMA_PIIC1_BASE + 0x1000),
+		.flags = 0 
+	}, { 
+		.name = "pbrd",
+		.start = KSEG1ADDR(EMMA_PBRD_BASE),
+		.end = KSEG1ADDR(EMMA_PBRD_BASE + 0x1000),
+		.flags = 0 
+	}
+};
+
+struct platform_device i2c_emma_devices[] = {
+	[0] = {
+		.name = I2C_EMMA,
+		.id = 0,
+		.resource = i2c_emma_resources_0,
+		.num_resources = ARRAY_SIZE(i2c_emma_resources_0),
+	},
+	[1] = {
+		.name = I2C_EMMA,
+		.id = 1,
+		.resource = i2c_emma_resources_1,
+		.num_resources = ARRAY_SIZE(i2c_emma_resources_1),
+	},
+};
+
+#define EMMA_SERIAL_CLOCK 24000000
+#define EMMA_SERIAL_FLAGS UPF_BOOT_AUTOCONF | UPF_SKIP_TEST
+
+#define EMMA_NAND_BASE		0x1c000000
+#define EMMA_NAND_SIZE		0x04000000	/* 64 MB */
+
+static struct resource et10068_nand_resources[] = {
+	{ 
+		.name = NULL,
+		.start = EMMA_NAND_BASE,
+		.end = EMMA_NAND_BASE + EMMA_NAND_SIZE,
+		.flags = 0 
+	}
+};
+
+static struct platform_device et10068_nand_devices = {
+	.name = NAND_ET10068,
+	.resource = et10068_nand_resources,
+	.num_resources = ARRAY_SIZE(et10068_nand_resources),
+};
+
+#define EMMA_SATA_PORT_OFFSET	0x0100
+
+static struct resource sata_emma_resources0[] = {
+	{ 
+		.name = NULL, 
+		.start = EMMA_IRQ_KSATA0,
+		.end = EMMA_IRQ_KSATA0,
+		.flags = IORESOURCE_IRQ 
+	}, { 
+		.name = NULL,
+		.start = KSEG1ADDR(EMMA_SATA_PORT_BASE+EMMA_SATA_PORT_OFFSET*0), 
+		.end = KSEG1ADDR(EMMA_SATA_PORT_BASE+EMMA_SATA_PORT_OFFSET*1), 
+		.flags = 0 /*IORESOURCE_MEM*/ 
+	}
+};
+
+static struct resource sata_emma_resources1[] = {
+	{ 
+		.name = NULL, 
+		.start = EMMA_IRQ_KSATA1,
+		.end = EMMA_IRQ_KSATA1,
+		.flags = IORESOURCE_IRQ 
+	}, { 
+		.name = NULL,
+		.start = KSEG1ADDR(EMMA_SATA_PORT_BASE+EMMA_SATA_PORT_OFFSET*1), 
+		.end = KSEG1ADDR(EMMA_SATA_PORT_BASE+EMMA_SATA_PORT_OFFSET*2), 
+		.flags = 0/*IORESOURCE_MEM*/ 
+	}
+};
+
+struct platform_device sata_emma_devices[] = {
+	[0] = {
+		.name = SATA_EMMA,
+		.id = 0,
+		.resource = sata_emma_resources0,
+		.num_resources = ARRAY_SIZE(sata_emma_resources0),
+	},
+	[1] = {
+		.name = SATA_EMMA,
+		.id = 1,
+		.resource = sata_emma_resources1,
+		.num_resources = ARRAY_SIZE(sata_emma_resources1),
+	},
+};
+
+
+#define EMMA3P_MAC_FLASH	0xbfe20000
+
+static struct nec_candy_platform_data nec_candy_pdata = {
+	.pmd_addr = 0x1f,
+	.rmii = 1,
+};
+
+static struct platform_device nec_candy_device = {
+	.name = "nec_candy",
+	.id = 0,
+	.dev.platform_data = &nec_candy_pdata,
+	.num_resources = 2,
+	.resource = (struct resource[]) {
+		{
+			.name	= "nec_candy_regs",
+			.start  = CPHYSADDR(EMMA_ETHER_BASE),
+			.end    = CPHYSADDR(EMMA_ETHER_BASE + 0x400),
+			.flags  = IORESOURCE_MEM,
+		},
+		{
+			.name	= "nec_candy_irq",
+			.start  = EMMA_IRQ_ETHER,
+			.end    = EMMA_IRQ_ETHER,
+			.flags  = IORESOURCE_IRQ,
+		},
+
+	},
+};
+
+
+static struct platform_device *devices[] = {
+	&i2c_emma_devices[0],
+	&i2c_emma_devices[1],
+	&et10068_nand_devices,
+	&sata_emma_devices[0],
+	&sata_emma_devices[1],
+	&nec_candy_device,
+};
+
+#ifdef CONFIG_MTD
+static struct mtd_partition et10068_parts[] = {
+	[0] = {
+		.name = "Root FS",
+		.offset = 0x00000000,
+		.size = 0x01500000,
+	},
+	[1] = {
+		.name = "kernel image",
+		.offset = MTDPART_OFS_APPEND,
+		.size = 0x00700000,
+	},
+	[2] = {
+		.name = "boot code area",
+		.offset = MTDPART_OFS_APPEND,
+		.size = 0x00200000,
+	},
+	[3] = {
+		.name = "boot env area",
+		.offset = MTDPART_OFS_APPEND,
+		.size = 0x00040000,
+		.mask_flags = MTD_WRITEABLE,  /* force read-only */
+	},
+	[4] = {
+		.name = "Free Area",
+		.offset = MTDPART_OFS_APPEND,
+		.size = 0x001C0000,
+	},
+};
+#endif
+
+static int __init platform_devices_setup(void)
+{
+#ifdef CONFIG_MTD
+	physmap_set_partitions(et10068_parts, ARRAY_SIZE(et10068_parts));
+#endif
+	memcpy(nec_candy_pdata.mac_addr, (void *) EMMA3P_MAC_FLASH, 6);
+	return platform_add_devices(devices, ARRAY_SIZE(devices));
+}
+
+arch_initcall(platform_devices_setup);
+
diff --git a/arch/mips/emma3p/et10068/setup.c b/arch/mips/emma3p/et10068/setup.c
new file mode 100644
index 0000000..f8dbd09
--- /dev/null
+++ b/arch/mips/emma3p/et10068/setup.c
@@ -0,0 +1,172 @@
+/*
+ *  arch/mips/emma3p/et10068/setup.c
+ *      This file is setup for EMMA3P ET10068.
+ *
+ *  Changes:
+ *		Wind River Systems, Inc.
+ *		- Make kgdb 8250 work properly. Jack Tan <jack.tan@windriver.com>
+ *
+ *  Copyright (C) NEC Electronics Corporation 2004-2007
+ *
+ *  This file is based on the arch/mips/ddb5xxx/ddb5477/setup.c.
+ *
+ *  Copyright 2001 MontaVista Software Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/autoconf.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/kdev_t.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/pci.h>
+#include <linux/fs.h>		/* for ROOT_DEV */
+#include <linux/ioport.h>
+#include <linux/param.h>	/* for HZ */
+#include <linux/major.h>
+#include <linux/kdev_t.h>
+#include <linux/root_dev.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <linux/kgdb.h>
+
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/addrspace.h>
+#include <asm/time.h>
+#include <asm/bcache.h>
+#include <asm/irq.h>
+#include <asm/reboot.h>
+#include <asm/gdb-stub.h>
+#include <asm/traps.h>
+#include <asm/debug.h>
+
+#include <asm/emma3p/emma3p.h>
+
+#define	USE_CPU_COUNTER_TIMER	/* whether we use cpu counter */
+
+extern void et10068_led(const char *);
+static int bus_frequency = 0;
+int mips_cpu_timer_irq;
+
+static void et10068_machine_restart(char *command)
+{
+	static void (*back_to_prom) (void) = (void (*)(void))0xbfc00000;
+
+	printk("EMMA3P ET10068 restart.\n");
+	et10068_led("restart");
+	back_to_prom();
+}
+
+static void et10068_machine_halt(void)
+{
+	printk("EMMA3P ET10068 halted.\n");
+	et10068_led("halted");
+	while (1) ;
+}
+
+static void et10068_machine_power_off(void)
+{
+	printk("EMMA3P ET10068 halted. Please turn off the power.\n");
+	et10068_led("poweroff");
+	while (1) ;
+}
+
+#ifdef CONFIG_EMMA_SUBCPU
+  static unsigned long emma3p_clock[4] = { 109333000, 164000000, 218667000, 328000000 };
+#else
+  static unsigned long emma3p_clock[4] = { 328000000, 262400000, 000000000, 000000000 };
+#endif
+
+static unsigned int __init detect_bus_frequency(unsigned long rtc_base)
+{
+	u32 reg;
+
+	/* detect from boot strap */
+	reg = emma_in32(EMMA_BHIF_CLKSEL);
+#ifdef CONFIG_EMMA_SUBCPU
+ 	reg = (reg >> 4) & 0x3;
+#else
+	reg = reg & 0x1;
+#endif
+	return emma3p_clock[reg];
+}
+
+void __init plat_time_init(void)
+{
+	if (bus_frequency == 0)
+		bus_frequency = detect_bus_frequency(0);
+
+	mips_hpt_frequency = bus_frequency / 2;
+}
+
+extern int setup_irq(unsigned int irq, struct irqaction *irqaction);
+
+extern void et10068_irq_setup(void);
+
+static void inline __init et10068_sio_setup(void)
+{
+	struct uart_port emma_port;
+	int emma_uart = 0;
+
+	memset(&emma_port, 0, sizeof(emma_port));
+
+	emma_port.flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST;
+	emma_port.iotype = UPIO_MEM;
+	emma_port.regshift = 2;	/* I/O addresses are every 8 bytes */
+	emma_port.uartclk = 24000000;	/* Clock rate of the chip */
+
+	emma_port.line = 0;
+	emma_port.mapbase = KSEG1ADDR(EMMA_PUART0_BASE + 3);
+	emma_port.membase = (u8*)emma_port.mapbase;
+	emma_port.irq = EMMA_IRQ_PUART0;
+	early_serial_setup(&emma_port);
+
+#ifdef CONFIG_KGDB
+#ifdef CONFIG_KGDB_SIMPLE_SERIAL
+	emma_uart = CONFIG_KGDB_PORT_NUM;
+#else
+	emma_uart = 1;
+#endif
+	emma_port.line = emma_uart;
+	emma_port.mapbase = KSEG1ADDR(EMMA_PUART0_BASE + 0x1000 * emma_uart + 3);
+	emma_port.membase = (u8*)emma_port.mapbase;
+	emma_port.irq = EMMA_IRQ_PUART0 + emma_uart;
+	early_serial_setup(&emma_port);
+#ifdef CONFIG_KGDB_8250_NOMODULE
+	kgdb8250_add_port(emma_uart, &emma_port);
+#endif
+#endif
+}
+
+void __init plat_mem_setup(void)
+{
+	extern int panic_timeout;
+
+	set_io_port_base(KSEG1);
+
+	_machine_restart = et10068_machine_restart;
+	_machine_halt = et10068_machine_halt;
+	pm_power_off = et10068_machine_power_off;
+
+	/* setup resource limits */
+	ioport_resource.end = ~0;
+
+	/* Reboot on panic */
+	panic_timeout = 50;
+
+	et10068_sio_setup();
+}
diff --git a/arch/mips/pci/Makefile b/arch/mips/pci/Makefile
index ed0c076..4a8b0ea 100644
--- a/arch/mips/pci/Makefile
+++ b/arch/mips/pci/Makefile
@@ -15,6 +15,7 @@ obj-$(CONFIG_MIPS_TX3927)	+= ops-tx3927.o
 obj-$(CONFIG_PCI_VR41XX)	+= ops-vr41xx.o pci-vr41xx.o
 obj-$(CONFIG_NEC_CMBVR4133)	+= fixup-vr4133.o
 obj-$(CONFIG_MARKEINS)		+= ops-emma2rh.o pci-emma2rh.o fixup-emma2rh.o
+obj-$(CONFIG_ET10068)		+= ops-emma3p.o pci-emma3p.o fixup-emma3p.o
 
 #
 # These are still pretty much in the old state, watch, go blind.
diff --git a/arch/mips/pci/fixup-emma3p.c b/arch/mips/pci/fixup-emma3p.c
new file mode 100644
index 0000000..6779698
--- /dev/null
+++ b/arch/mips/pci/fixup-emma3p.c
@@ -0,0 +1,96 @@
+/*
+ *  arch/mips/pci/fixup-emma3p.c
+ *      This file defines the PCI configration.
+ *
+ *  Copyright (C) NEC Electronics Corporation 2004-2007
+ *
+ *  This file is based on the arch/mips/ddb5xxx/ddb5477/pci.c
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+
+#include <asm/bootinfo.h>
+#include <asm/debug.h>
+
+#include <asm/emma3p/emma3p.h>
+
+#define EMMA_PCI_HOST_SLOT 20
+#define EMMA_USB_SLOT 14
+
+/*
+ * we fix up irqs based on the slot number.
+ * The first entry is at AD:11.
+ * Fortunately this works because, although we have two pci buses,
+ * they all have different slot numbers (except for rockhopper slot 20
+ * which is handled below).
+ *
+ */
+
+static unsigned char irq_map[][21] __initdata = {
+	[14] = {0, ET10068_PCI_IRQ_USB, 0, 0, 0, },
+	[15] = {0, ET10068_PCI_IRQ_ETHERNET, 0, 0, 0, },
+};
+
+static void __devinit nec_usb_controller_fixup(struct pci_dev *dev)
+{
+	printk("%s invoked (%d)\n", __FUNCTION__, PCI_SLOT(dev->devfn));
+	if (PCI_SLOT(dev->devfn) == EMMA_USB_SLOT) {
+		/* on board USB controller configuration */
+		pci_write_config_dword(dev, 0xe4, 0x00006c42);
+		pci_write_config_dword(dev, 0xe0, 0x0110b31f);
+	}
+}
+
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_NEC, PCI_DEVICE_ID_NEC_USB,
+			nec_usb_controller_fixup);
+
+/*
+ * Prevent the PCI layer from seeing the resources allocated to this device
+ * if it is the host bridge by marking it as such.  These resources are of
+ * no consequence to the PCI layer (they are handled elsewhere).
+ */
+static void __devinit emma_pci_host_fixup(struct pci_dev *dev)
+{
+	int i;
+
+	if (PCI_SLOT(dev->devfn) == EMMA_PCI_HOST_SLOT) {
+		dev->class &= 0xff;
+		dev->class |= PCI_CLASS_BRIDGE_HOST << 8;
+		for (i = 0; i < PCI_NUM_RESOURCES; i++) {
+			dev->resource[i].start = 0;
+			dev->resource[i].end = 0;
+			dev->resource[i].flags = 0;
+		}
+	}
+}
+
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_NEC, PCI_DEVICE_ID_NEC_EMMA3P,
+			 emma_pci_host_fixup);
+
+int __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return irq_map[slot][pin];
+}
+
+/* Do platform specific device initialization at pci_enable_device() time */
+int pcibios_plat_dev_init(struct pci_dev *dev)
+{
+	return 0;
+}
diff --git a/arch/mips/pci/ops-emma3p.c b/arch/mips/pci/ops-emma3p.c
new file mode 100644
index 0000000..858e291
--- /dev/null
+++ b/arch/mips/pci/ops-emma3p.c
@@ -0,0 +1,198 @@
+/*
+ *  arch/mips/pci/ops-emma3p.c
+ *      This file defines the PCI operation for EMMA3P.
+ *
+ *  Copyright (C) NEC Electronics Corporation 2004-2007
+ *
+ *  This file is based on the arch/mips/pci/ops-vr41xx.c
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+
+#include <asm/addrspace.h>
+#include <asm/debug.h>
+
+#include <asm/emma3p/emma3p.h>
+
+#undef DEBUG_PRINT_CONFIG_ACCESS	/* dump configration accesses */
+
+#define RTABORT (0x1 << 9)
+#define RMABORT (0x1 << 10)
+#define EMMA_PCI_SLOT_NUM 20	/* 0000:14:0 is a final PCI device */
+
+/*
+ * access config space
+ */
+
+static int check_args(struct pci_bus *bus, u32 devfn, u32 * bus_num)
+{
+	/* check if the bus is top-level */
+	if (bus->parent != NULL) {
+		*bus_num = bus->number;
+		db_assert(bus_num != 0);
+	} else
+		*bus_num = 0;
+
+	if (*bus_num == 0) {
+		/* Type 0 */
+		if (PCI_SLOT(devfn) > EMMA_PCI_SLOT_NUM)
+			return PCIBIOS_DEVICE_NOT_FOUND;
+	} else {
+		/* Type 1 */
+		if ((*bus_num >= 256) || (PCI_SLOT(devfn) >= 32))
+			return PCIBIOS_DEVICE_NOT_FOUND;
+	}
+	return 0;
+}
+
+static inline int set_pci_configuration_address(unsigned char bus_num,
+						unsigned int devfn, int where)
+{
+	u32 config_win0;
+
+	if (where > 0xff)
+		return -EINVAL;
+
+	emma_out32(EMMA_PCI_INT, ~RMABORT);
+	if (bus_num == 0)
+		/*
+		 * Type 0 configuration
+		 */
+		config_win0 = (1 << (11 + PCI_SLOT(devfn))) | (5 << 8);
+	else
+		/*
+		 * Type 1 configuration
+		 */
+		config_win0 = (bus_num << 16) | (PCI_SLOT(devfn) << 11) |
+		    (5 << 8) | (1 << 7);
+
+	emma_out32(EMMA_PCI_IWIN0_CTR, config_win0);
+
+	return 0;
+}
+
+static int pci_config_read(struct pci_bus *bus, unsigned int devfn, int where,
+			   int size, uint32_t * val)
+{
+	u32 bus_num;
+	u32 base = KSEG1ADDR(EMMA_PCI_CONFIG_BASE);
+	u32 backup_win0;
+	u32 data;
+
+	*val = 0xffffffffU;
+
+	if (check_args(bus, devfn, &bus_num) == PCIBIOS_DEVICE_NOT_FOUND)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	backup_win0 = emma_in32(EMMA_PCI_IWIN0_CTR);
+
+	if (set_pci_configuration_address(bus_num, devfn, where) < 0)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	data =
+	    readl((void __iomem *)(base + (PCI_FUNC(devfn) << 8) +
+				   (where & 0xfc)));
+#ifdef DEBUG_PRINT_CONFIG_ACCESS
+	printk("%02d: A:%08lx R:%08lx\n",
+	       PCI_SLOT(devfn), base + (where & 0xfc), data);
+#endif
+
+	switch (size) {
+	case 1:
+		*val = (data >> ((where & 3) << 3)) & 0xffU;
+		break;
+	case 2:
+		*val = (data >> ((where & 2) << 3)) & 0xffffU;
+		break;
+	case 4:
+		*val = data;
+		break;
+	default:
+		emma_out32(EMMA_PCI_IWIN0_CTR, backup_win0);
+		return PCIBIOS_FUNC_NOT_SUPPORTED;
+	}
+
+	emma_out32(EMMA_PCI_IWIN0_CTR, backup_win0);
+
+	if (emma_in32(EMMA_PCI_INT) & RMABORT)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int pci_config_write(struct pci_bus *bus, unsigned int devfn, int where,
+			    int size, u32 val)
+{
+	u32 bus_num;
+	u32 base = KSEG1ADDR(EMMA_PCI_CONFIG_BASE);
+	u32 backup_win0;
+	u32 data;
+	int shift;
+
+	if (check_args(bus, devfn, &bus_num) == PCIBIOS_DEVICE_NOT_FOUND)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	backup_win0 = emma_in32(EMMA_PCI_IWIN0_CTR);
+
+	if (set_pci_configuration_address(bus_num, devfn, where) < 0)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	/* read modify write */
+	data =
+	    readl((void __iomem *)(base + (PCI_FUNC(devfn) << 8) +
+				   (where & 0xfc)));
+
+	switch (size) {
+	case 1:
+		shift = (where & 3) << 3;
+		data &= ~(0xffU << shift);
+		data |= ((val & 0xffU) << shift);
+		break;
+	case 2:
+		shift = (where & 2) << 3;
+		data &= ~(0xffffU << shift);
+		data |= ((val & 0xffffU) << shift);
+		break;
+	case 4:
+		data = val;
+		break;
+	default:
+		emma_out32(EMMA_PCI_IWIN0_CTR, backup_win0);
+		return PCIBIOS_FUNC_NOT_SUPPORTED;
+	}
+
+	writel(data,
+	       (void __iomem *)(base + (PCI_FUNC(devfn) << 8) +
+				(where & 0xfc)));
+#ifdef DEBUG_PRINT_CONFIG_ACCESS
+	printk("%02d: A:%08lx W:%08lx\n",
+	       PCI_SLOT(devfn), base + (where & 0xfc), data);
+#endif
+
+	emma_out32(EMMA_PCI_IWIN0_CTR, backup_win0);
+	if (emma_in32(EMMA_PCI_INT) & RMABORT)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+struct pci_ops emma_pci_ops = {
+	.read = pci_config_read,
+	.write = pci_config_write,
+};
diff --git a/arch/mips/pci/pci-emma3p.c b/arch/mips/pci/pci-emma3p.c
new file mode 100644
index 0000000..d5d202e
--- /dev/null
+++ b/arch/mips/pci/pci-emma3p.c
@@ -0,0 +1,115 @@
+/*
+ *  arch/mips/pci/pci-emma3p.c
+ *      This file defines the PCI configration.
+ *
+ *  Copyright (C) NEC Electronics Corporation 2004-2007
+ *
+ *  This file is based on the arch/mips/ddb5xxx/ddb5477/pci.c
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+
+#include <asm/bootinfo.h>
+#include <asm/debug.h>
+
+#include <asm/emma3p/emma3p.h>
+
+static struct resource pci_io_resource = {
+	.name = "pci IO space",
+	.start = EMMA_PCI_IO_BASE,
+	.end = EMMA_PCI_IO_BASE + EMMA_PCI_IO_SIZE - 1,
+	.flags = IORESOURCE_IO,
+};
+
+static struct resource pci_mem_resource = {
+	.name = "pci memory space",
+	.start = EMMA_PCI_MEM_BASE,
+	.end = EMMA_PCI_MEM_BASE + EMMA_PCI_MEM_SIZE - 1,
+	.flags = IORESOURCE_MEM,
+};
+
+extern struct pci_ops emma_pci_ops;
+
+static struct pci_controller emma_pci_controller = {
+	.pci_ops = &emma_pci_ops,
+	.mem_resource = &pci_mem_resource,
+	.io_resource = &pci_io_resource,
+};
+
+static void __init emma_pci_init(void)
+{
+	unsigned long tmp;
+
+	/* setup PCI interface */
+	emma_out32(EMMA_PCI_CONTROL, 1);
+	emma_out32(EMMA_PCI_CONTROL, 0);
+
+	/* setup PCI interface */
+	emma_out32(EMMA_PCI_ARBIT_CTR, 0x3070f);
+
+	/* Configuration Cycle Type 0 */
+	emma_out32(EMMA_PCI_IWIN0_CTR, (1 << (11 + 20)) | (5 << 8) | 0x18);
+
+	/*
+	 * PCI_STATUS_DEVSEL_MEDIUM = 0x     200
+	 * PCI_STATUS_CAP_LIST      = 0x      10
+	 * PCI_COMMAND_MASTER       = 0x       4
+	 * PCI_COMMAND_MEMORY       = 0x       2
+	 *                            0x00000216
+	 */
+	emma_out32(EMMA_PCI_CONFIG_BASE + PCI_COMMAND,
+		    (PCI_STATUS_DEVSEL_MEDIUM << 16 ) |
+		    (PCI_STATUS_CAP_LIST << 16) |
+		    PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY);
+
+	emma_out32(EMMA_PCI_CONFIG_BASE + PCI_BASE_ADDRESS_0, 0x10000000);
+	emma_out32(EMMA_PCI_CONFIG_BASE + PCI_BASE_ADDRESS_1, 0x00000000);
+
+	emma_out32(EMMA_PCI_IWIN0_CTR, EMMA_PCI_IO_BASE | 0x118); /* 32MB */
+	emma_out32(EMMA_PCI_IWIN1_CTR, EMMA_PCI_MEM_BASE | 0x310); /* 64MB */
+
+	emma_out32(EMMA_PCI_INIT_ESWP, 0x00000101);
+
+	/*
+	 * Note: If the PCI target address space, which is specified by bootstrap,
+	 * is > 256MB, it will be better to use TWIN1 rather than TWIN0.
+	 * Because the TWIN0 always could only cover upto `strapped-window-size - 1'
+	 * address space.
+	 */
+	emma_out32(EMMA_PCI_TWIN_CTR, 0x00009200);
+	emma_out32(EMMA_PCI_TWIN_BADR, 0x00000000);
+	emma_out32(EMMA_PCI_TWIN0_DADR, 0x00000000);
+	emma_out32(EMMA_PCI_TWIN1_DADR, 0x00000000);
+
+	/* Alternate */
+	tmp = emma_in32(0xb0000028);
+	tmp |= 0xa0;  /* PCI extension 1 & 2 */
+	emma_out32(0xb0000028, tmp);
+
+}
+
+static int __init emma_pci_setup(void)
+{
+	emma_pci_init();
+	register_pci_controller(&emma_pci_controller);
+	return 0;
+}
+
+arch_initcall(emma_pci_setup);
diff --git a/include/asm-mips/emma3p/emma3p.h b/include/asm-mips/emma3p/emma3p.h
new file mode 100644
index 0000000..89fd07e
--- /dev/null
+++ b/include/asm-mips/emma3p/emma3p.h
@@ -0,0 +1,381 @@
+/*
+ *  include/asm-mips/emma3p/emma3p.h
+ *      This file is EMMA3P common header.
+ *
+ *  Copyright (C) NEC Electronics Corporation 2005-2007
+ *
+ *  This file based on include/asm-mips/ddb5xxx/ddb5xxx.h
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_EMMA3P_EMMA3P_H
+#define __ASM_EMMA3P_EMMA3P_H
+
+#include <irq.h>
+
+/*
+ * EMMA3P registers
+ */
+#define REGBASE 0x10000000
+
+#define EMMA_BHIF_BASE		(  0x0000+REGBASE)
+#define EMMA_ETHER_BASE 	(0x012000+REGBASE)
+#define EMMA_PBRD_BASE		(0x100000+REGBASE)
+#define EMMA_TIMER_BASE		(0x110000+REGBASE)
+#define EMMA_PCI_BASE		(0x200000+REGBASE)
+#define EMMA_SATA_PORT_BASE	(0x204000+REGBASE)
+
+#define EMMA_BHIF_STRAP_0	(0x0010+EMMA_BHIF_BASE)
+#define EMMA_BHIF_CLKSEL	(0x001c+EMMA_BHIF_BASE)
+#define EMMA_BHIF_ALTERNATE	(0x0028+EMMA_BHIF_BASE)
+#define EMMA_BHIF_INT_ST_0	(0x0030+EMMA_BHIF_BASE)
+#define EMMA_BHIF_INT_ST_1	(0x0034+EMMA_BHIF_BASE)
+#define EMMA_BHIF_INT_ST_2	(0x0038+EMMA_BHIF_BASE)
+#define EMMA_BHIF_INT0_EN_0	(0x0040+EMMA_BHIF_BASE)
+#define EMMA_BHIF_INT0_EN_1	(0x0044+EMMA_BHIF_BASE)
+#define EMMA_BHIF_INT0_EN_2	(0x0048+EMMA_BHIF_BASE)
+#define EMMA_BHIF_INT1_EN_0	(0x0050+EMMA_BHIF_BASE)
+#define EMMA_BHIF_INT1_EN_1	(0x0054+EMMA_BHIF_BASE)
+#define EMMA_BHIF_INT1_EN_2	(0x0058+EMMA_BHIF_BASE)
+#define EMMA_BHIF_SW_INT0	(0x01a0+EMMA_BHIF_BASE)
+#define EMMA_BHIF_SW_INT0_EN	(0x01a4+EMMA_BHIF_BASE)
+#define EMMA_BHIF_SW_INT0_CLR	(0x01a8+EMMA_BHIF_BASE)
+#define EMMA_BHIF_SUB_INT_ST_0	(0x0100+EMMA_BHIF_BASE)
+#define EMMA_BHIF_SUB_INT_ST_1	(0x0104+EMMA_BHIF_BASE)
+#define EMMA_BHIF_SUB_INT_ST_2	(0x0108+EMMA_BHIF_BASE)
+#define EMMA_BHIF_SUB_INT0_EN_0	(0x0110+EMMA_BHIF_BASE)
+#define EMMA_BHIF_SUB_INT0_EN_1	(0x0114+EMMA_BHIF_BASE)
+#define EMMA_BHIF_SUB_INT0_EN_2	(0x0118+EMMA_BHIF_BASE)
+#define EMMA_BHIF_SUB_INT1_EN_0	(0x0120+EMMA_BHIF_BASE)
+#define EMMA_BHIF_SUB_INT1_EN_1	(0x0124+EMMA_BHIF_BASE)
+#define EMMA_BHIF_SUB_INT1_EN_2	(0x0128+EMMA_BHIF_BASE)
+
+#define EMMA_PUART0_BASE	(0x1000+EMMA_PBRD_BASE)
+#define EMMA_PUART1_BASE	(0x2000+EMMA_PBRD_BASE)
+#define EMMA_PIIC0_BASE		(0x4000+EMMA_PBRD_BASE)
+#define EMMA_PIIC1_BASE		(0x5000+EMMA_PBRD_BASE)
+#define EMMA_PIIC2_BASE		(0x6000+EMMA_PBRD_BASE)
+
+#define EMMA_GPIO0_BASE		(0x0c00+EMMA_TIMER_BASE)
+#define EMMA_GPIO0_DIR		(  0xc0+EMMA_GPIO0_BASE)
+#define EMMA_GPIO0_INT		(  0xc8+EMMA_GPIO0_BASE)
+#define EMMA_GPIO0_INT_CPUMEN	(  0xd0+EMMA_GPIO0_BASE)
+#define EMMA_GPIO0_INT_CPUSEN	(  0xd8+EMMA_GPIO0_BASE)
+#define EMMA_GPIO0_INT_AUDDEN	(  0xdc+EMMA_GPIO0_BASE)
+#define EMMA_GPIO0_INT_MODE	(  0xe0+EMMA_GPIO0_BASE)
+#define EMMA_GPIO0_INT_CND_A	(  0xe8+EMMA_GPIO0_BASE)
+#define EMMA_GPIO0_INT_CND_B	(  0xf0+EMMA_GPIO0_BASE)
+
+#define EMMA_GPIO1_BASE		(0x0d00+EMMA_TIMER_BASE)
+#define EMMA_GPIO1_DIR		(  0xc0+EMMA_GPIO1_BASE)
+#define EMMA_GPIO1_INT		(  0xc8+EMMA_GPIO1_BASE)
+#define EMMA_GPIO1_INT_CPUMEN	(  0xd0+EMMA_GPIO1_BASE)
+#define EMMA_GPIO1_INT_CPUSEN	(  0xd8+EMMA_GPIO1_BASE)
+#define EMMA_GPIO1_INT_AUDDEN	(  0xdc+EMMA_GPIO1_BASE)
+#define EMMA_GPIO1_INT_MODE	(  0xe0+EMMA_GPIO1_BASE)
+#define EMMA_GPIO1_INT_CND_A	(  0xe8+EMMA_GPIO1_BASE)
+#define EMMA_GPIO1_INT_CND_B	(  0xf0+EMMA_GPIO1_BASE)
+
+#define EMMA_GPIO2_BASE		(0x0e00+EMMA_TIMER_BASE)
+#define EMMA_GPIO2_DIR		(  0xc0+EMMA_GPIO2_BASE)
+#define EMMA_GPIO2_INT		(  0xc8+EMMA_GPIO2_BASE)
+#define EMMA_GPIO2_INT_CPUMEN	(  0xd0+EMMA_GPIO2_BASE)
+#define EMMA_GPIO2_INT_CPUSEN	(  0xd8+EMMA_GPIO2_BASE)
+#define EMMA_GPIO2_INT_AUDDEN	(  0xdc+EMMA_GPIO2_BASE)
+#define EMMA_GPIO2_INT_MODE	(  0xe0+EMMA_GPIO2_BASE)
+#define EMMA_GPIO2_INT_CND_A	(  0xe8+EMMA_GPIO2_BASE)
+#define EMMA_GPIO2_INT_CND_B	(  0xf0+EMMA_GPIO2_BASE)
+
+#define EMMA_PCI_CONTROL	(0x0000+EMMA_PCI_BASE)
+#define EMMA_PCI_ARBIT_CTR	(0x0004+EMMA_PCI_BASE)
+#define EMMA_PCI_IWIN0_CTR	(0x0010+EMMA_PCI_BASE)
+#define EMMA_PCI_IWIN1_CTR	(0x0014+EMMA_PCI_BASE)
+#define EMMA_PCI_INIT_ESWP	(0x0018+EMMA_PCI_BASE)
+#define EMMA_PCI_INT		(0x0020+EMMA_PCI_BASE)
+#define EMMA_PCI_INT_EN		(0x0024+EMMA_PCI_BASE)
+#define EMMA_PCI_TWIN_CTR	(0x0030+EMMA_PCI_BASE)
+#define EMMA_PCI_TWIN_BADR	(0x0034+EMMA_PCI_BASE)
+#define EMMA_PCI_TWIN0_DADR	(0x0038+EMMA_PCI_BASE)
+#define EMMA_PCI_TWIN1_DADR	(0x003c+EMMA_PCI_BASE)
+
+#define EMMA_IDE_BRIDGE		(0x0100+EMMA_PCI_BASE)
+#define EMMA_IDE_CONFIG		(0x0200+EMMA_PCI_BASE)
+#define EMMA_IDE_PRIMARY	(0x0600+EMMA_PCI_BASE)
+
+#ifdef CONFIG_EMMA_SUBCPU
+#undef EMMA_BHIF_INT_ST_0
+#undef EMMA_BHIF_INT_ST_1
+#undef EMMA_BHIF_INT_ST_2
+#undef EMMA_BHIF_INT0_EN_0
+#undef EMMA_BHIF_INT0_EN_1
+#undef EMMA_BHIF_INT0_EN_2
+#undef EMMA_BHIF_INT1_EN_0
+#undef EMMA_BHIF_INT1_EN_1
+#undef EMMA_BHIF_INT1_EN_2
+#undef EMMA_GPIO0_INT_CPUMEN
+#undef EMMA_GPIO1_INT_CPUMEN
+#undef EMMA_GPIO2_INT_CPUMEN
+#define EMMA_BHIF_INT_ST_0	EMMA_BHIF_SUB_INT_ST_0
+#define EMMA_BHIF_INT_ST_1	EMMA_BHIF_SUB_INT_ST_1
+#define EMMA_BHIF_INT_ST_2	EMMA_BHIF_SUB_INT_ST_2
+#define EMMA_BHIF_INT0_EN_0	EMMA_BHIF_SUB_INT0_EN_0
+#define EMMA_BHIF_INT0_EN_1	EMMA_BHIF_SUB_INT0_EN_1
+#define EMMA_BHIF_INT0_EN_2	EMMA_BHIF_SUB_INT0_EN_2
+#define EMMA_BHIF_INT1_EN_0	EMMA_BHIF_SUB_INT1_EN_0
+#define EMMA_BHIF_INT1_EN_1	EMMA_BHIF_SUB_INT1_EN_1
+#define EMMA_BHIF_INT1_EN_2	EMMA_BHIF_SUB_INT1_EN_2
+#define EMMA_GPIO0_INT_CPUMEN	EMMA_GPIO0_INT_CPUSEN
+#define EMMA_GPIO1_INT_CPUMEN	EMMA_GPIO1_INT_CPUSEN
+#define EMMA_GPIO2_INT_CPUMEN	EMMA_GPIO2_INT_CPUSEN
+#endif
+
+/*
+ *  Memory map (physical address)
+ *
+ *  Note most of the following address must be properly aligned by the
+ *  corresponding size.  For example, if PCI_IO_SIZE is 16MB, then
+ *  PCI_IO_BASE must be aligned along 16MB boundary.
+ */
+
+/* the actual ram size is detected at run-time */
+#define EMMA_RAM_BASE		0x00000000
+
+#define EMMA_RAM_SIZE		0x30000000	/* 768 MB */
+
+#define EMMA_IO_BASE		0x10000000
+#define EMMA_IO_SIZE		0x01000000	/* 16 MB */
+
+#define EMMA_GENERALIO_BASE	0x11000000
+#define EMMA_GENERALIO_SIZE	0x01000000	/* 16 MB */
+
+#define EMMA_PCI_IO_BASE	0x12000000
+#define EMMA_PCI_IO_SIZE	0x02000000	/* 32 MB */
+
+#define EMMA_PCI_MEM_BASE	0x14000000
+#define EMMA_PCI_MEM_SIZE	0x04000000	/* 64 MB */
+
+#define EMMA_ROM_BASE		0x1e000000
+#define EMMA_ROM_SIZE		0x02000000	/* 32 MB */
+
+#define EMMA_PCI_CONFIG_BASE	EMMA_PCI_IO_BASE
+#define EMMA_PCI_CONFIG_SIZE	EMMA_PCI_IO_SIZE
+
+#define NUM_CPU_IRQ		8
+#define NUM_EMMA_IRQ		96
+#define NUM_EMMA_IRQ_SW		32
+#define NUM_EMMA_IRQ_GPIO	96
+
+#define CPU_IRQ_BASE		0
+#define EMMA_IRQ_BASE		(CPU_IRQ_BASE + NUM_CPU_IRQ)
+#define EMMA_SW_IRQ_BASE	(EMMA_IRQ_BASE + NUM_EMMA_IRQ)
+#define EMMA_GPIO_IRQ_BASE	(EMMA_SW_IRQ_BASE + NUM_EMMA_IRQ_SW)
+
+/*
+ * emma3p irq defs
+ */
+
+#define EMMA_IRQ_INT00		( 0 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT01		( 1 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT02		( 2 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT03		( 3 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT04		( 4 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT05		( 5 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT06		( 6 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT07		( 7 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT08		( 8 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT09		( 9 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT10		(10 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT11		(11 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT12		(12 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT13		(13 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT14		(14 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT15		(15 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT16		(16 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT17		(17 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT18		(18 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT19		(19 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT20		(20 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT21		(21 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT22		(22 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT23		(23 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT24		(24 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT25		(25 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT26		(26 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT27		(27 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT28		(28 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT29		(29 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT30		(30 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT31		(31 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT32		(32 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT33		(33 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT34		(34 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT35		(35 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT36		(36 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT37		(37 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT38		(38 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT39		(39 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT40		(40 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT41		(41 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT42		(42 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT43		(43 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT44		(44 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT45		(45 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT46		(46 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT47		(47 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT48		(48 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT49		(49 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT50		(50 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT51		(51 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT52		(52 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT53		(53 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT54		(54 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT55		(55 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT56		(56 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT57		(57 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT58		(58 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT59		(59 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT60		(60 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT61		(61 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT62		(62 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT63		(63 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT64		(64 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT65		(65 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT66		(66 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT67		(67 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT68		(68 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT69		(69 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT70		(70 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT71		(71 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT72		(72 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT73		(73 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT74		(74 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT75		(75 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT76		(76 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT77		(77 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT78		(78 + EMMA_IRQ_BASE)
+#define EMMA_IRQ_INT79		(79 + EMMA_IRQ_BASE)
+
+#define EMMA_SW_IRQ_INT00	( 0 + EMMA_SW_IRQ_BASE)
+#define EMMA_SW_IRQ_INT01	( 1 + EMMA_SW_IRQ_BASE)
+#define EMMA_SW_IRQ_INT02	( 2 + EMMA_SW_IRQ_BASE)
+#define EMMA_SW_IRQ_INT03	( 3 + EMMA_SW_IRQ_BASE)
+#define EMMA_SW_IRQ_INT04	( 4 + EMMA_SW_IRQ_BASE)
+#define EMMA_SW_IRQ_INT05	( 5 + EMMA_SW_IRQ_BASE)
+#define EMMA_SW_IRQ_INT06	( 6 + EMMA_SW_IRQ_BASE)
+#define EMMA_SW_IRQ_INT07	( 7 + EMMA_SW_IRQ_BASE)
+#define EMMA_SW_IRQ_INT08	( 8 + EMMA_SW_IRQ_BASE)
+#define EMMA_SW_IRQ_INT09	( 9 + EMMA_SW_IRQ_BASE)
+#define EMMA_SW_IRQ_INT10	(10 + EMMA_SW_IRQ_BASE)
+#define EMMA_SW_IRQ_INT11	(11 + EMMA_SW_IRQ_BASE)
+#define EMMA_SW_IRQ_INT12	(12 + EMMA_SW_IRQ_BASE)
+#define EMMA_SW_IRQ_INT13	(13 + EMMA_SW_IRQ_BASE)
+#define EMMA_SW_IRQ_INT14	(14 + EMMA_SW_IRQ_BASE)
+#define EMMA_SW_IRQ_INT15	(15 + EMMA_SW_IRQ_BASE)
+#define EMMA_SW_IRQ_INT16	(16 + EMMA_SW_IRQ_BASE)
+#define EMMA_SW_IRQ_INT17	(17 + EMMA_SW_IRQ_BASE)
+#define EMMA_SW_IRQ_INT18	(18 + EMMA_SW_IRQ_BASE)
+#define EMMA_SW_IRQ_INT19	(19 + EMMA_SW_IRQ_BASE)
+#define EMMA_SW_IRQ_INT20	(20 + EMMA_SW_IRQ_BASE)
+#define EMMA_SW_IRQ_INT21	(21 + EMMA_SW_IRQ_BASE)
+#define EMMA_SW_IRQ_INT22	(22 + EMMA_SW_IRQ_BASE)
+#define EMMA_SW_IRQ_INT23	(23 + EMMA_SW_IRQ_BASE)
+#define EMMA_SW_IRQ_INT24	(24 + EMMA_SW_IRQ_BASE)
+#define EMMA_SW_IRQ_INT25	(25 + EMMA_SW_IRQ_BASE)
+#define EMMA_SW_IRQ_INT26	(26 + EMMA_SW_IRQ_BASE)
+#define EMMA_SW_IRQ_INT27	(27 + EMMA_SW_IRQ_BASE)
+#define EMMA_SW_IRQ_INT28	(28 + EMMA_SW_IRQ_BASE)
+#define EMMA_SW_IRQ_INT29	(29 + EMMA_SW_IRQ_BASE)
+#define EMMA_SW_IRQ_INT30	(30 + EMMA_SW_IRQ_BASE)
+#define EMMA_SW_IRQ_INT31	(31 + EMMA_SW_IRQ_BASE)
+
+#define CPU_EMMA_CASCADE	2
+#define EMMA_SW_CASCADE		EMMA_IRQ_INT06
+#define EMMA_GPIO_CASCADE	EMMA_IRQ_INT46
+
+#define EMMA_IRQ_PUART0		EMMA_IRQ_INT48
+#define EMMA_IRQ_PUART1		EMMA_IRQ_INT49
+#define EMMA_IRQ_PIIC0		EMMA_IRQ_INT51
+#define EMMA_IRQ_PIIC1		EMMA_IRQ_INT52
+#define EMMA_IRQ_PIIC2		EMMA_IRQ_INT53
+
+#define EMMA_IRQ_KSATA0		EMMA_IRQ_INT35
+#define EMMA_IRQ_KSATA1		EMMA_IRQ_INT36
+
+#define EMMA_IRQ_ETHER		EMMA_IRQ_INT61
+
+/*
+ *  EMMA3P Register Access
+ */
+
+#define EMMA_BASE 		(0xa0000000)
+
+#ifndef __ASSEMBLY__
+static inline void emma_sync(void)
+{
+	volatile u32 *p = (volatile u32 *)0xb0000000;
+	(void)(*p);
+	__asm__ __volatile__("sync");
+}
+
+static inline void emma_out32(u32 offset, u32 val)
+{
+	*(volatile u32 *)(EMMA_BASE | offset) = val;
+	emma_sync();
+}
+
+static inline u32 emma_in32(u32 offset)
+{
+	u32 val = *(volatile u32 *)(EMMA_BASE | offset);
+	emma_sync();
+	return val;
+}
+
+static inline void emma_out16(u32 offset, u16 val)
+{
+	*(volatile u16 *)(EMMA_BASE | offset) = val;
+	emma_sync();
+}
+
+static inline u16 emma_in16(u32 offset)
+{
+	u16 val = *(volatile u16 *)(EMMA_BASE | offset);
+	emma_sync();
+	return val;
+}
+
+static inline void emma_out8(u32 offset, u8 val)
+{
+	*(volatile u8 *)(EMMA_BASE | offset) = val;
+	emma_sync();
+}
+
+static inline u8 emma_in8(u32 offset)
+{
+	u8 val = *(volatile u8 *)(EMMA_BASE | offset);
+	emma_sync();
+	return val;
+}
+#endif
+
+/*
+ * include the board dependent part
+ */
+#if defined(CONFIG_ET10068)
+#include <asm/emma3p/et10068.h>
+#else
+#error "Unknown EMMA3P board!"
+#endif
+
+#endif	/* __ASM_EMMA3P_EMMA3P_H */
diff --git a/include/asm-mips/emma3p/et10068.h b/include/asm-mips/emma3p/et10068.h
new file mode 100644
index 0000000..5a94ac8
--- /dev/null
+++ b/include/asm-mips/emma3p/et10068.h
@@ -0,0 +1,30 @@
+/*
+ *  include/asm-mips/emma3p/et10068p.h
+ *      This file is EMMA3P board depended header.
+ *
+ *  Copyright (C) NEC Electronics Corporation 2005-2007
+ *
+ *  This file based on include/asm-mips/ddb5xxx/ddb5xxx.h
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef ET10068_H
+#define ET10068_H
+
+#define ET10068_PCI_IRQ_USB		(EMMA_GPIO_IRQ_BASE + 10)
+#define ET10068_PCI_IRQ_ETHERNET	(EMMA_GPIO_IRQ_BASE + 11)
+
+#endif /* CONFIG_ET10068 */
diff --git a/include/asm-mips/mach-emma3p/irq.h b/include/asm-mips/mach-emma3p/irq.h
new file mode 100644
index 0000000..35d8e9a
--- /dev/null
+++ b/include/asm-mips/mach-emma3p/irq.h
@@ -0,0 +1,24 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#ifndef __ASM_MACH_EMMA_IRQ_H
+#define __ASM_MACH_EMMA_IRQ_H
+
+#define NR_IRQS	256
+
+#include_next <irq.h>
+
+#endif
diff --git a/include/asm-mips/mach-emma3p/war.h b/include/asm-mips/mach-emma3p/war.h
new file mode 100644
index 0000000..b660a4c
--- /dev/null
+++ b/include/asm-mips/mach-emma3p/war.h
@@ -0,0 +1,25 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2002, 2004, 2007 by Ralf Baechle <ralf@linux-mips.org>
+ */
+#ifndef __ASM_MIPS_MACH_EMMA2RH_WAR_H
+#define __ASM_MIPS_MACH_EMMA2RH_WAR_H
+
+#define R4600_V1_INDEX_ICACHEOP_WAR	0
+#define R4600_V1_HIT_CACHEOP_WAR	0
+#define R4600_V2_HIT_CACHEOP_WAR	0
+#define R5432_CP0_INTERRUPT_WAR		0
+#define BCM1250_M3_WAR			0
+#define SIBYTE_1956_WAR			0
+#define MIPS4K_ICACHE_REFILL_WAR	0
+#define MIPS_CACHE_SYNC_WAR		0
+#define TX49XX_ICACHE_INDEX_INV_WAR	0
+#define RM9000_CDEX_SMP_WAR		0
+#define ICACHE_REFILLS_WORKAROUND_WAR	0
+#define R10000_LLSC_WAR			0
+#define MIPS34K_MISSED_ITLB_WAR		0
+
+#endif /* __ASM_MIPS_MACH_EMMA2RH_WAR_H */
diff --git a/include/linux/pci_ids.h b/include/linux/pci_ids.h
index eafc9d6..3d38bf0 100644
--- a/include/linux/pci_ids.h
+++ b/include/linux/pci_ids.h
@@ -613,6 +613,7 @@
 #define PCI_DEVICE_ID_NEC_VRC5476       0x009b
 #define PCI_DEVICE_ID_NEC_VRC4173	0x00a5
 #define PCI_DEVICE_ID_NEC_VRC5477_AC97  0x00a6
+#define PCI_DEVICE_ID_NEC_EMMA3P	0x0177 /* EMMA PCI Host */
 #define PCI_DEVICE_ID_NEC_PC9821CS01    0x800c /* PC-9821-CS01 */
 #define PCI_DEVICE_ID_NEC_PC9821NRB06   0x800d /* PC-9821NR-B06 */
 
-- 
1.5.5.4

