From 9be720206eb95eafaeb1eef55ee089e9fb0f85a5 Mon Sep 17 00:00:00 2001
From: Chunbo Luo <chunbo.luo@windriver.com>
Date: Thu, 11 Sep 2008 15:35:00 +0800
Subject: [PATCH] nec_emma3p: ethernet driver

Add nec_candy driver for nec_emma3p

Signed-off-by: Jack Tan <jack.tan@windriver.com>
Signed-off-by: Chunbo Luo <chunbo.luo@windriver.com>
---
 arch/mips/mm/cache.c         |    1 +
 drivers/net/Kconfig          |   40 +
 drivers/net/Makefile         |    1 +
 drivers/net/nec_candy.c      | 1948 ++++++++++++++++++++++++++++++++++++++++++
 drivers/net/nec_candy.h      |  600 +++++++++++++
 include/linux/nec_candy_pd.h |   23 +
 6 files changed, 2613 insertions(+), 0 deletions(-)
 create mode 100644 drivers/net/nec_candy.c
 create mode 100644 drivers/net/nec_candy.h
 create mode 100644 include/linux/nec_candy_pd.h

diff --git a/arch/mips/mm/cache.c b/arch/mips/mm/cache.c
index 1eb7c71..7eb32ec 100644
--- a/arch/mips/mm/cache.c
+++ b/arch/mips/mm/cache.c
@@ -51,6 +51,7 @@ void (*_dma_cache_wback)(unsigned long start, unsigned long size);
 void (*_dma_cache_inv)(unsigned long start, unsigned long size);
 
 EXPORT_SYMBOL(_dma_cache_wback_inv);
+EXPORT_SYMBOL(_dma_cache_inv);
 
 #endif /* CONFIG_DMA_NONCOHERENT */
 
diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index cd5867f..3f63bcb 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -1250,6 +1250,46 @@ config IBMVETH
 
 source "drivers/net/ibm_newemac/Kconfig"
 
+config NEC_CANDY
+	tristate "NEC Candy Ethernet support"
+	depends on NET_ETHERNET && (NEC_CMBVR4133 || EMMA3P)
+	help
+	  This driver supports the NEC "Candy" Ethernet devices found
+	  on some NEC MIPS boards.
+
+config CANDY_NAPI
+	bool "Enable NAPI support"
+	depends on NEC_CANDY
+	default n
+	help
+	  NAPI is a driver API designed to reduce CPU and interrupt load
+	  when the driver is receiving lots of packets from the card.
+
+	  If your estimated Rx load is 10kpps or more, or if the card will be
+	  deployed on potentially unfriendly networks (e.g. in a firewall),
+	  then say Y here.
+
+	  You may want to say N here in case of low packets rates where latency
+	  is extremely important and no packet overload is likely.
+
+	  See <file:Documentation/networking/NAPI_HOWTO.txt> for more
+	  information.
+
+	  If in doubt, say Y.
+
+config CANDY_AFCE2
+	bool "Use Auto Flow Control"
+	depends on NEC_CANDY
+	default n
+	help
+	  Flow control is realized during full-duplex communication by using
+	  a PAUSE control frame conforming to IEEE 802.3x. During half-duplex
+	  communication, flow control is realized by a back-pressure function.
+	  Flow control is executed if the number of remaining receive buffer
+	  descriptors are less than a threshold value.
+
+	  If unsure, say N.
+
 config NET_PCI
 	bool "EISA, VLB, PCI and on board controllers"
 	depends on ISA || EISA || PCI
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index de81c8a..30502a0 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -222,6 +222,7 @@ obj-$(CONFIG_PASEMI_MAC) += pasemi_mac_driver.o
 pasemi_mac_driver-objs := pasemi_mac.o pasemi_mac_ethtool.o
 obj-$(CONFIG_MLX4_CORE) += mlx4/
 obj-$(CONFIG_ENC28J60) += enc28j60.o
+obj-$(CONFIG_NEC_CANDY) += nec_candy.o
 
 obj-$(CONFIG_MACB) += macb.o
 
diff --git a/drivers/net/nec_candy.c b/drivers/net/nec_candy.c
new file mode 100644
index 0000000..797ac4f
--- /dev/null
+++ b/drivers/net/nec_candy.c
@@ -0,0 +1,1948 @@
+/*
+ * drivers/net/nec_candy.c
+ *
+ * NEC candy ethernet driver.
+ *
+ * Author: Jun Sun <jsun@mvista.com>
+ *
+ * 2001-2006 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Changes:
+ *  MontaVista Software Inc. <source@mvista.com>
+ *  - Added MII interface library support
+ *  - Added Linux ethtool package support (based on 8139cp.c driver)
+ *  - Added network interface message level support
+ *  - Fixed VLTP register initialisation (set to zero)
+ *
+ *  MontaVista Software Inc. <source@mvista.com>
+ *  - Added support for VR4133 (CCR register defines additional bits).
+ *
+ *  MontaVista Software Inc. <source@mvista.com>
+ *  - Added support for NEC VR7701.
+ *
+ *  MontaVista Software Inc.<asapkov@ru.mvista.com> or <source@mvista.com>
+ *  - Added support for NEC CMB-VR4133.
+ *
+ *  MontaVista Software Inc. <source@mvista.com>
+ *  - Ported to 2.6 kernel.
+ *  - Added platform device support
+ *  - Added NAPI support
+ */
+
+#define DRV_NAME		"nec_candy"
+#define DRV_VERSION		"0.4"
+#define DRV_RELDATE		"June 20, 2006"
+
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/param.h>
+#include <linux/etherdevice.h>
+#include <linux/if.h>
+#include <linux/ethtool.h>
+#include <linux/mii.h>
+#include <linux/crc32.h>
+#include <linux/spinlock.h>
+#include <linux/dma-mapping.h>
+#include <linux/timer.h>
+#include <linux/platform_device.h>
+#include <linux/nec_candy_pd.h>
+
+#include <asm/addrspace.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/pgtable.h>
+
+#include "nec_candy.h"
+
+/***********************************************************************
+ * debug
+ ***********************************************************************/
+#define CANDY_DEF_MSG_ENABLE	(NETIF_MSG_DRV		| \
+				 NETIF_MSG_PROBE 	| \
+				 NETIF_MSG_LINK)
+
+static int debug = -1;
+
+#ifdef DEBUG_VERBOSE_NEC_CANDY
+#define DEBUG_NEC_CANDY
+#endif
+
+#ifdef DEBUG_NEC_CANDY
+#define ASSERT(x) if (!(x)) { panic("%s:%d - assert failed!\n", __FILE__, __LINE__); }
+#define VERIFY(x, y) ASSERT(x y)
+#define DEBUG(x)  do { x; } while (0)
+#else
+#define ASSERT(x)
+#define VERIFY(x, y) x
+#define DEBUG(x)
+#endif
+
+#ifdef DEBUG_VERBOSE_NEC_CANDY
+#define DEBUG_VERBOSE(x)  do { x; } while (0)
+#else
+#define DEBUG_VERBOSE(x)
+#endif
+
+/***********************************************************************
+ * global data
+ ***********************************************************************/
+
+/* These identify the driver base version and may not be removed. */
+static char version[] __devinitdata =
+    DRV_NAME ": 10/100 Ethernet driver v" DRV_VERSION " (" DRV_RELDATE ")";
+
+static struct candy_private *candy_priv_head = NULL;
+
+/***********************************************************************
+ * helpers
+ ***********************************************************************/
+#define	candy_in(x)	readl((void __iomem *) &x)
+#define	candy_out(x, y)	writel((unsigned long)y, (void __iomem *)&x)
+
+#define	candy_set_bits(x, mask)  candy_out(x, candy_in(x) | mask)
+#define	candy_clear_bits(x, mask)  candy_out(x, candy_in(x) & ~mask)
+
+#define	candy_set_macc1_bits(x, mask) \
+		candy_out(x, (candy_in(x) | mask) & MACC1_RESERVED)
+#define	candy_clear_macc1_bits(x, mask) \
+		candy_out(x, (candy_in(x) & ~mask) & MACC1_RESERVED)
+
+#define	candy_set_macc2_bits(x, mask) \
+		candy_out(x, (candy_in(x) | mask) & MACC2_RESERVED)
+#define	candy_clear_macc2_bits(x, mask) \
+		candy_out(x, (candy_in(x) & ~mask) & MACC2_RESERVED)
+
+#ifdef CONFIG_CANDY_NAPI
+#define CANDY_NAPI_MASK_INTS		(RCVDN)
+#define candy_unmask_napi_ints(p) \
+		candy_out((p)->msr, candy_in((p)->msr) | CANDY_NAPI_MASK_INTS)
+#define candy_mask_napi_ints(p) \
+		candy_out((p)->msr, candy_in((p)->msr) & ~CANDY_NAPI_MASK_INTS)
+#endif
+
+#define MEMSYNC(x)	\
+	do { volatile u32 *p = (volatile u32 *)x; (void)(*p); } while (0)
+
+/***********************************************************************
+ * low-level hardware functions
+ ***********************************************************************/
+
+static void
+mdio_write(struct net_device *dev, int phy_id, int location, int val)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	candy_regs *p = pp->regs;
+
+	/* wait for busy */
+	while (candy_in(p->mind) & BUSY) ;
+
+	/* start the write */
+
+	candy_out(p->madr,
+		  ((phy_id << FIAD_SHIFT) & FIAD_MASK) |
+		  (location & RGAD_MASK));
+	candy_out(p->mwtd, (ulong) val);
+}
+
+static int
+mdio_read(struct net_device *dev, int phy_id, int location)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	candy_regs *p = pp->regs;
+
+	/* wait for busy */
+	while (candy_in(p->mind) & BUSY) ;
+
+	/*  mac_reg->mcmd = 0; */
+	candy_out(p->madr,
+		  ((phy_id << FIAD_SHIFT) & FIAD_MASK) |
+		  (location & RGAD_MASK));
+	candy_out(p->mcmd, RSTAT);
+
+	/* wait for busy */
+	while (candy_in(p->mind) & BUSY) ;
+
+	return (ushort) candy_in(p->mrdd);
+}
+
+static void
+candy_set_media_speed(struct net_device *dev)
+{
+	struct candy_private *pp = dev->priv;
+	struct nec_candy_platform_data *pdata = pp->dev->platform_data;
+	int lpa, advertise, media, reg;
+	ulong ccr;
+
+	/*
+	 * As described in specs, SDP100 works with RMII mode, and is not
+	 * related to MII mode. Hence if MII selected, let's leave it ON.
+	 * this will be a workaround for VR4133A rev 2.0, formerly known as
+	 * WORKAROUND_E19_VR4133A.
+	 *
+	 * SPD100   10HALF  10FULL  100HALF 100FULL
+	 * mii      1       1       1       1
+	 * rmii     1       1       0       0
+	 */
+
+	/* load default settings */
+	ccr = SPD100 | MII_PIN_SELECT;
+	if (pdata->rmii)
+		ccr |= RMII_MODE;
+
+	reg = mdio_read(pp->mii_if.dev, pp->mii_if.phy_id, MII_BMCR);
+	if (!(reg & BMCR_ANENABLE))
+		lpa = advertise = 0;
+	else {
+		lpa = mdio_read(pp->mii_if.dev, pp->mii_if.phy_id, MII_LPA);
+		advertise = mdio_read(pp->mii_if.dev,
+				      pp->mii_if.phy_id, MII_ADVERTISE);
+	}
+
+	/*
+	 * If auto-negotiation is disabled or something weird is there,
+	 * conform to the control register.
+	 */
+	if (lpa == 0 || advertise == 0) {
+		pp->link_status.fullduplex = (reg & BMCR_FULLDPLX) ? 1 : 0;
+		if (reg & BMCR_SPEED100) {
+			if (pdata->rmii)
+				ccr &= ~SPD100;
+			pp->link_status.speed100 = 1;
+		} else {
+			pp->link_status.speed100 = 0;
+		}
+		candy_out(pp->regs->ccr, ccr);
+		return;
+	}
+
+	media = mii_nway_result(lpa & advertise);
+	switch (media) {
+		case LPA_10FULL:
+		case LPA_10HALF:
+			pp->link_status.speed100 = 0;
+			break;
+		default:
+			if (pdata->rmii)
+				ccr &= ~SPD100;
+			pp->link_status.speed100 = 1;
+	}
+
+	switch (media) {
+		case LPA_10HALF:
+		case LPA_100HALF:
+			pp->link_status.fullduplex = 0;
+			break;
+		default:
+			pp->link_status.fullduplex = 1;
+	}
+
+	candy_out(pp->regs->ccr, ccr);
+}
+
+static int
+candy_ethtool_ioctl(struct candy_private *pp, void *useraddr)
+{
+	u32 ethcmd;
+
+	/* dev_ioctl() in ../../net/core/dev.c has already checked
+	   capable(CAP_NET_ADMIN), so don't bother with that here.  */
+
+	if (get_user(ethcmd, (u32 *) useraddr))
+		return -EFAULT;
+
+	switch (ethcmd) {
+
+	case ETHTOOL_GDRVINFO:{
+			struct ethtool_drvinfo info = { ETHTOOL_GDRVINFO };
+			strcpy(info.driver, DRV_NAME);
+			strcpy(info.version, DRV_VERSION);
+			strcpy(info.bus_info, "");
+			info.regdump_len = CANDY_REGS_SIZE;
+			info.n_stats = 0;
+			if (copy_to_user(useraddr, &info, sizeof(info)))
+				return -EFAULT;
+			return 0;
+		}
+		/* get settings */
+	case ETHTOOL_GSET:{
+			struct ethtool_cmd ecmd = { ETHTOOL_GSET };
+			spin_lock_irq(&pp->lock);
+			mii_ethtool_gset(&pp->mii_if, &ecmd);
+			spin_unlock_irq(&pp->lock);
+			if (copy_to_user(useraddr, &ecmd, sizeof(ecmd)))
+				return -EFAULT;
+			return 0;
+		}
+		/* set settings */
+	case ETHTOOL_SSET:{
+			int r;
+			struct ethtool_cmd ecmd;
+			if (copy_from_user(&ecmd, useraddr, sizeof(ecmd)))
+				return -EFAULT;
+			spin_lock_irq(&pp->lock);
+			r = mii_ethtool_sset(&pp->mii_if, &ecmd);
+			spin_unlock_irq(&pp->lock);
+			return r;
+		}
+		/* restart autonegotiation */
+	case ETHTOOL_NWAY_RST:{
+			return mii_nway_restart(&pp->mii_if);
+		}
+		/* get link status */
+	case ETHTOOL_GLINK:{
+			struct ethtool_value edata = { ETHTOOL_GLINK };
+			edata.data = mii_link_ok(&pp->mii_if);
+			if (copy_to_user(useraddr, &edata, sizeof(edata)))
+				return -EFAULT;
+			return 0;
+		}
+
+		/* get message-level */
+	case ETHTOOL_GMSGLVL:{
+			struct ethtool_value edata = { ETHTOOL_GMSGLVL };
+			edata.data = pp->msg_enable;
+			if (copy_to_user(useraddr, &edata, sizeof(edata)))
+				return -EFAULT;
+			return 0;
+		}
+		/* set message-level */
+	case ETHTOOL_SMSGLVL:{
+			struct ethtool_value edata;
+			if (copy_from_user(&edata, useraddr, sizeof(edata)))
+				return -EFAULT;
+			pp->msg_enable = edata.data;
+			return 0;
+		}
+
+		/* register's dump */
+	case ETHTOOL_GREGS:{
+			struct ethtool_regs regs;
+			u8 *regbuf = kmalloc(CANDY_REGS_SIZE, GFP_KERNEL);
+			int rc;
+
+			if (!regbuf)
+				return -ENOMEM;
+			memset(regbuf, 0, CANDY_REGS_SIZE);
+
+			rc = copy_from_user(&regs, useraddr, sizeof(regs));
+			if (rc) {
+				rc = -EFAULT;
+				goto err_out_gregs;
+			}
+
+			if (regs.len > CANDY_REGS_SIZE)
+				regs.len = CANDY_REGS_SIZE;
+			if (regs.len < CANDY_REGS_SIZE) {
+				rc = -EINVAL;
+				goto err_out_gregs;
+			}
+
+			regs.version = CANDY_REGS_VER;
+			rc = copy_to_user(useraddr, &regs, sizeof(regs));
+			if (rc) {
+				rc = -EFAULT;
+				goto err_out_gregs;
+			}
+
+			useraddr += offsetof(struct ethtool_regs, data);
+
+			spin_lock_irq(&pp->lock);
+			memcpy_fromio(regbuf, pp->regs, CANDY_REGS_SIZE);
+			spin_unlock_irq(&pp->lock);
+
+			if (copy_to_user(useraddr, regbuf, regs.len))
+				rc = -EFAULT;
+
+		      err_out_gregs:
+			kfree(regbuf);
+			return rc;
+		}
+
+		/* get/set TX checksumming */
+	case ETHTOOL_GTXCSUM:{
+			struct ethtool_value edata = { ETHTOOL_GTXCSUM };
+
+			edata.data = (pp->ndev->features &
+				      NETIF_F_IP_CSUM) != 0;
+			if (copy_to_user(useraddr, &edata, sizeof(edata)))
+				return -EFAULT;
+			return 0;
+		}
+	case ETHTOOL_STXCSUM:{
+			struct ethtool_value edata;
+
+			if (copy_from_user(&edata, useraddr, sizeof(edata)))
+				return -EFAULT;
+
+			if (edata.data)
+				pp->ndev->features |= NETIF_F_IP_CSUM;
+			else
+				pp->ndev->features &= ~NETIF_F_IP_CSUM;
+
+			return 0;
+		}
+
+		/* get/set scatter-gather */
+	case ETHTOOL_GSG:{
+			struct ethtool_value edata = { ETHTOOL_GSG };
+
+			edata.data = (pp->ndev->features & NETIF_F_SG) != 0;
+			if (copy_to_user(useraddr, &edata, sizeof(edata)))
+				return -EFAULT;
+			return 0;
+		}
+	case ETHTOOL_SSG:{
+			struct ethtool_value edata;
+
+			if (copy_from_user(&edata, useraddr, sizeof(edata)))
+				return -EFAULT;
+
+			if (edata.data)
+				pp->ndev->features |= NETIF_F_SG;
+			else
+				pp->ndev->features &= ~NETIF_F_SG;
+
+			return 0;
+		}
+
+	default:
+		break;
+	}
+
+	return -EOPNOTSUPP;
+}
+
+static int
+candy_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	struct candy_private *pp = dev->priv;
+	struct mii_ioctl_data *mii = (struct mii_ioctl_data *) &rq->ifr_data;
+	int rc;
+
+	if (cmd == SIOCETHTOOL)
+		return candy_ethtool_ioctl(pp, (void *) rq->ifr_data);
+
+	spin_lock_irq(&pp->lock);
+	rc = generic_mii_ioctl(&pp->mii_if, mii, cmd, NULL);
+	spin_unlock_irq(&pp->lock);
+	return rc;
+}
+
+static void
+set_mac_addr(struct net_device *dev, u_char * addr)
+{
+	candy_regs *p = ((struct candy_private *) dev->priv)->regs;
+
+	candy_out(p->lsa2, (addr[0] << 8 | addr[1]) & LSA2_MASK);
+	candy_out(p->lsa1,
+		  addr[2] << 24 | addr[3] << 16 | addr[4] << 8 | addr[5]);
+}
+
+static void
+candy_filter_init(struct net_device *dev)
+{
+	candy_regs *p = ((struct candy_private *) dev->priv)->regs;
+
+	/* don't call while processing error recovery */
+
+	candy_out(p->ht1, 0);
+	candy_out(p->ht2, 0);
+
+#ifdef	WORKAROUND_E10_PRM_AMC
+	candy_out(p->afr, ABC);
+#else
+	candy_out(p->afr, PRM | ABC | AMC);
+#endif
+}
+
+/*
+ * This is called when system boots up and/or after ether chip is reset.
+ */
+static void
+candy_hw_init(struct net_device *dev)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	candy_regs *p = pp->regs;
+	unsigned int temp;
+	u32 afr, ht1, ht2;
+
+	/*
+	 * software reset - resets all modules; DMA, FIFO, MAC and MII/RMII
+	 *
+	 * FIXME: save and restore the contents of AFR and its friends.
+	 */
+
+	afr = candy_in(p->afr);
+	ht1 = candy_in(p->ht1);
+	ht2 = candy_in(p->ht2);
+
+	candy_out(p->ccr, SRT);
+	candy_in(p->isr);
+
+	candy_out(p->afr, afr);
+	candy_out(p->ht1, ht1);
+	candy_out(p->ht2, ht2);
+
+	/*
+	 * MII software reset
+	 */
+	/* we need to maintain CLKS[2:0] = 3'b001 during reset */
+	candy_out(p->miic, MISRT | CLKS33);
+	candy_out(p->miic, CLKS33);
+
+	/*
+	 * initialize MAC
+	 */
+	temp = TXFC | RXFC | CRCEN | PADEN;
+#ifdef WORKAROUND_E13_TXFC
+	temp &= ~TXFC;
+#endif
+#ifdef WORKAROUND_E21_PAD
+	temp &= ~PADEN;
+#endif
+	candy_out(p->macc1, temp);
+	candy_out(p->macc2, APD);
+	candy_out(p->ipgt, IPGT);
+	candy_out(p->ipgr, IPGR1 | IPGR2);
+	candy_out(p->clrt, LCOLW | RETRY);
+	candy_out(p->lmax, MAXF);
+	candy_out(p->vltp, 0x0);
+#ifdef EMMA3P
+	candy_out(p->miic, CLKS166);
+#else
+	candy_out(p->miic, CLKS66);
+#endif
+
+	/*
+	 * initialize DMA / FIFO
+	 */
+#ifdef EMMA3P
+	candy_out(p->txcfg, DTBS16);
+	candy_out(p->txfc, TPTV | TX_DRTH | TX_FLTH);
+	candy_out(p->rxcfg, DRBS16);
+	candy_out(p->rxfc, UWM | LWM | RX_DRTH16W);
+	candy_out(p->rxpd, AL | DUWM | DLWM);
+#else	/* EMMA3P */
+#ifdef WORKAROUND_E7_AFCE
+	candy_out(p->txcfg, DTBS8);
+#else
+	candy_out(p->txcfg, DTBS8 | AFCE);
+#endif
+	candy_out(p->txfc, TPTV | TX_DRTH | TX_FLTH);
+	candy_out(p->rxcfg, DRBS8);
+	candy_out(p->rxfc, UWM | LWM | RX_DRTH16W);
+	candy_out(p->rxpd, AL);
+#endif	/* EMMA3P */
+
+#ifdef CONFIG_CANDY_AFCE2
+	/* unfortunately AFCE1 function is useless. never enable it. */
+	candy_set_bits(p->txcfg, AFCE2 | AP0TE);
+#endif
+
+#ifdef EMMA3P
+	/*
+	 * mode configuration
+	 */
+	temp = 0x00800000; /* RSTH */
+	candy_out(p->mode, temp);
+#endif
+
+	/* Set pins for MII/RMII use */
+	candy_set_media_speed(dev);
+
+	netif_carrier_off(dev);
+	mii_check_media(&pp->mii_if, netif_msg_link(pp), 1);
+
+	if (pp->mii_if.full_duplex)
+		candy_set_macc1_bits(pp->regs->macc1, FULLD);
+	else
+		candy_clear_macc1_bits(pp->regs->macc1, FULLD);
+
+	/*
+	 * MAC software reset - set/clear these bits all together
+	 */
+	candy_set_macc2_bits(pp->regs->macc2, (MCRST | RFRST | TFRST));
+	udelay(3);
+	candy_clear_macc2_bits(pp->regs->macc2, (MCRST | RFRST | TFRST));
+
+	set_mac_addr(dev, dev->dev_addr);
+	/* afr, ht1, ht2 are initialized by candy_filter_init() */
+
+	/*
+	 * disable all interrupts until dev is opened later
+	 */
+	candy_out(p->msr, 0);
+}
+
+static void
+candy_down(struct net_device *dev)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	candy_regs *p = pp->regs;
+
+	DEBUG_VERBOSE(printk("candy_down() invoked.\n"));
+
+	candy_clear_macc1_bits(p->macc1, SRXEN);
+
+#ifdef CONFIG_CANDY_AFCE2
+	candy_clear_bits(p->txcfg, (TXE | AFCE2 | AP0TE));
+#else
+	candy_clear_bits(p->txcfg, TXE);
+#endif
+	candy_clear_bits(p->rxcfg, RXE);
+
+	/*
+	 * disable all interrupts until dev is opened later
+	 */
+	candy_out(p->msr, 0);
+}
+
+static void
+candy_up(struct net_device *dev)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	candy_regs *p = pp->regs;
+
+	DEBUG_VERBOSE(printk("candy_up() invoked.\n"));
+
+	/* set number of descriptors */
+	candy_out(p->rxpd, AL | DUWM | DLWM | (RX_RING_SIZE & RNOD_MASK));
+
+	/* set the receive descriptor pointer */
+	candy_out(p->rxdp, CPHYSADDR(&pp->rx_ring[pp->rx_head]));
+
+	/* enable transmit and receive */
+	candy_set_bits(p->txcfg, TXE);
+	candy_set_bits(p->rxcfg, RXE);
+
+	/* turn on interrupts */
+	candy_in(p->isr);
+	candy_out(p->msr, 0xffffffff & ISR_RESERVED);
+
+	/* start receiving */
+	candy_set_macc1_bits(p->macc1, SRXEN);
+}
+
+static void
+candy_set_filter(struct net_device *dev, int on)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	candy_regs *p = pp->regs;
+	struct dev_mc_list *mclist = dev->mc_list;
+	unsigned long ht[2];
+	int i;
+	u32 bit_nr;
+
+	DEBUG_VERBOSE(printk
+		      ("candy_set_filter() invoked - %s\n", on ? "on" : "off"));
+
+	ht[0] = ht[1] = 0;
+
+	if (on) {
+		for (i = 0, mclist = dev->mc_list;
+		     mclist && i < dev->mc_count; i++, mclist = mclist->next) {
+			bit_nr = (ether_crc(ETH_ALEN, mclist->dmi_addr) >> 23) & 0x3FUL;
+			__set_bit(bit_nr, ht);
+		}
+	}
+
+	/* lock ints */
+	candy_out(p->ht1, ht[1]);
+	candy_out(p->ht2, ht[0]);
+}
+
+/*
+ * Apparently candy tx can stall due to various reasons.
+ * This routine will attempt to recover from tx stall.
+ */
+static void
+candy_error_recover(struct net_device *dev)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	candy_regs *p = pp->regs;
+
+	spin_lock(&pp->lock);
+
+	netif_stop_queue(dev);
+
+	candy_down(dev);
+	candy_hw_init(dev);
+	candy_up(dev);
+
+	netif_wake_queue(dev);
+
+	/* restart transmitting */
+	candy_out(p->txdp, CPHYSADDR(&pp->tx_ring[pp->tx_head]));
+
+	spin_unlock(&pp->lock);
+}
+
+#if defined(WORKAROUND_E8_TX_STALL)
+/*
+ * This implements the workaround described for E-8
+ */
+static void
+tx_stall_recover(struct net_device *dev)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	candy_regs *p = pp->regs;
+
+	/* E-8 bug only happens when receiving is on */
+	if ((candy_in(p->macc1) & SRXEN) && (candy_in(p->rxcfg) & RXE)) {
+
+		candy_clear_macc1_bits(p->macc1, SRXEN);
+		candy_clear_bits(p->rxcfg, RXE);
+
+		udelay(20);
+
+		candy_out(p->txdp, CPHYSADDR(&pp->tx_ring[pp->tx_head]));
+
+		candy_set_bits(p->rxcfg, RXE);
+		candy_set_macc1_bits(p->macc1, SRXEN);
+
+	} else {
+		candy_out(p->txdp, CPHYSADDR(&pp->tx_ring[pp->tx_head]));
+	}
+}
+#endif
+
+/***********************************************************************
+ * hardware-independent helper routine
+ ***********************************************************************/
+static void
+candy_init_rings(struct net_device *dev)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	int i;
+
+	DEBUG_VERBOSE(printk("candy_init_rings() invoked.\n"));
+
+	/* tx rings */
+	for (i = 0; i < TX_RING_SIZE; i++) {
+		pp->tx_ring[i].status = 0;
+		pp->tx_ring[i].size = 0;
+		pp->tx_ring[i].pointer = 0;
+	}
+	/* this may be not necessary, if we reset every txdpr in intr */
+	pp->tx_ring[TX_RING_SIZE].status = 0;
+	pp->tx_ring[TX_RING_SIZE].size = 0x0;
+	pp->tx_ring[TX_RING_SIZE].pointer = CPHYSADDR(pp->tx_ring);
+
+	pp->tx_tail = pp->tx_stop = pp->tx_head = 0;
+	pp->tx_count = 0;
+
+	/* rx rings */
+	for (i = 0; i < RX_RING_SIZE; i++) {
+		pp->rx_ring[i].status = DB_LP;
+		pp->rx_ring[i].size = RX_BUF_SIZE;
+		pp->rx_ring[i].pointer = CPHYSADDR(pp->rx_skb[i]->data);
+	}
+	pp->rx_ring[RX_RING_SIZE].status = 0;	/* link back to the beginning */
+	pp->rx_ring[RX_RING_SIZE].size = 0xffff;
+	pp->rx_ring[RX_RING_SIZE].pointer = CPHYSADDR(pp->rx_ring);
+
+	pp->rx_head = 0;
+	pp->rx_disable = 0;
+}
+
+static void
+candy_check_intr(ulong isr)
+{
+	static const char *intr_name[32] = {
+		"carry flag",
+		"reserved",
+		"reserved",
+		"link failed",
+		"overflow",
+		"receive buffer desc request at zero",
+		"receive buffer desc request at alert level",
+		"receive done",
+
+		"reserved",
+		"reserved",
+		"control frame transmit",
+		"transmit aborted",
+		"underrun",
+		"transmit frame length exceed",
+		"transmit buffer descriptor request at NULL",
+		"transmit done",
+
+		"reserved",
+		"reserved",
+		"reserved",
+		"reserved",	/* 4 */
+		"reserved",
+		"reserved",
+		"reserved",
+		"reserved",
+
+		"reserved",
+		"reserved",
+		"reserved",
+		"reserved",	/* 4 */
+		"reserved",
+		"reserved",
+		"reserved",
+		"IBUS error"
+	};
+	ulong i, j;
+
+	for (i = 0, j = 1; i < 32; j <<= 1, i++) {
+		if (j & isr)
+			printk("\t%s\n", intr_name[i]);
+	}
+}
+
+static void
+reclaim_one_rx_desc(struct net_device *dev, char *buf)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	candy_regs *p = pp->regs;
+	struct candy_desc *dp = &pp->rx_ring[pp->rx_head];
+
+	if (buf != NULL) {
+		dp->pointer = CPHYSADDR(buf);
+	}
+	dp->status = DB_LP;	/* 1 stands for buffer vs link ptr */
+	dp->size = RX_BUF_SIZE;
+
+	/* we need to clean up cache here.  Otherwise we may have some
+	 * dirty cache while ether controller is feeding fresh pkt data
+	 * to the physical RAM.  Data corruption could happen.
+	 */
+	dma_cache_wback_inv(KSEG0ADDR(dp->pointer), RX_BUF_SIZE);
+
+	if (++pp->rx_head == RX_RING_SIZE)
+		pp->rx_head = 0;
+
+	/* tell hardware we have one descriptor to work with */
+	candy_out(p->rxpd, AL | DUWM | DLWM | 1);
+}
+
+static void
+restart_rx_hw(struct net_device *dev)
+{
+	struct candy_private *pp = (struct candy_private *)dev->priv;
+	candy_regs *p = pp->regs;
+
+	if (netif_msg_rx_status(pp))
+		printk(KERN_DEBUG "%s : re-enable SRXEN\n", dev->name);
+
+	/* restart receiving */
+	candy_out(p->rxdp, candy_in(p->rxdp));
+	udelay(23);
+	candy_set_macc1_bits(p->macc1, SRXEN);
+}
+
+static void
+handle_rx_error(struct net_device *dev, struct candy_desc *dp, ulong isr)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+
+	if (netif_msg_rx_err(pp))
+		printk(KERN_DEBUG "%s: rx_err, rx_ring[%d] error,"
+		       "status =%04x, size=%d, isr = 0x%08lx.\n",
+		       dev->name, pp->rx_head, dp->status, dp->size, isr);
+
+	/* log some errors that hardware doesn't log */
+	pp->stats.rx_errors++;
+	if (dp->status & OVRN)
+		pp->stats.rx_over_errors++;
+}
+
+#ifdef CONFIG_CANDY_NAPI
+
+static int candy_napi_rx(struct net_device *dev, int budget)
+{
+	struct candy_private *pp = (struct candy_private *)dev->priv;
+	candy_regs *p = pp->regs;
+	struct candy_desc *dp = &pp->rx_ring[pp->rx_head];
+	struct sk_buff *rxskb, *newskb;
+	int pkt_len, rnod;
+	int received = 0;
+
+	while ((dp->status & OWN) && (received < budget)) {
+
+		/* check rx_disable */
+		if (pp->rx_disable) {
+			rnod = candy_in(p->rxpd) & RNOD_MASK;
+			if (rnod >= RX_RESTART_BREAK) {
+				/* clear rx_disable, then restart_rx_hw() */
+				pp->rx_disable = 0;
+				restart_rx_hw(dev);
+			}
+		}
+
+		if ((dp->status & RXOK) == 0) { /* handle the error case */
+			handle_rx_error(dev, dp, 0);
+			reclaim_one_rx_desc(dev, NULL);
+			dp = &pp->rx_ring[pp->rx_head];
+			received++;
+			continue;
+		}
+
+		/* oversize? */
+		if (dp->size > ETH_FRAME_LEN + 4) {
+			if (netif_msg_rx_status(pp))
+				printk(KERN_DEBUG "%s: rx, oversized pkt\n",
+				       dev->name);
+			pkt_len = ETH_FRAME_LEN + 4;
+		} else {
+			pkt_len = dp->size;
+		}
+
+		/*
+		 * we got a good packet,
+		 * use the new skb to replace the received one
+		 */
+		rxskb = pp->rx_skb[pp->rx_head];
+
+		newskb = dev_alloc_skb(RX_BUF_SIZE);    /* allocate a new skb */
+		if (newskb == NULL) {
+			printk(KERN_ERR "%s: memory squeeze.\n", dev->name);
+			reclaim_one_rx_desc(dev, NULL);
+			pp->stats.rx_dropped++;
+			dp = &pp->rx_ring[pp->rx_head];
+			received++;
+			continue;
+		}
+
+		/* TODO: maybe we also want rx_copybreak for NAPI */
+
+		newskb->dev = dev;
+		skb_reserve(newskb, 2); /* align IP pkt to 16-byte */
+		pp->rx_skb[pp->rx_head] = newskb;
+		reclaim_one_rx_desc(dev, newskb->data);
+
+		skb_put(rxskb, pkt_len);
+		rxskb->protocol = eth_type_trans(rxskb, dev);
+		rxskb->ip_summed = CHECKSUM_UNNECESSARY;
+		netif_receive_skb(rxskb);
+		received++;
+		dev->last_rx = jiffies;
+
+		dp = &pp->rx_ring[pp->rx_head];
+	}
+
+	if (netif_msg_rx_status(pp))
+		printk(KERN_DEBUG "%s: rx, processed %d frames.\n",
+		       dev->name, received);
+
+	/*
+	 * we might fail to restart receiving due to budget.
+	 */
+	if (pp->rx_disable)
+		printk(KERN_DEBUG "%s: couldn't restart receiving "
+		       "budget=%d received=%d rxpd=%08x\n",
+		       dev->name, budget, received, candy_in(pp->regs->rxpd));
+
+	return received;
+}
+
+//static int candy_napi_poll(struct net_device *dev, int *budget)
+static int candy_napi_poll(struct napi_struct *napi, int budget)
+{
+	struct candy_private *pp = container_of(napi,struct candy_private,napi);
+	struct net_device *dev = pp->ndev;
+	int work_done;
+
+	spin_lock(&pp->rxlock);
+	work_done = 0;
+	work_done += candy_napi_rx(dev, budget);
+
+	if (work_done < budget) {
+		__netif_rx_complete(dev,napi);
+		candy_unmask_napi_ints(pp->regs);
+	}
+
+	spin_unlock(&pp->rxlock);
+
+	return work_done;
+}
+
+#else /* CONFIG_CANDY_NAPI */
+
+static void
+candy_rx(struct net_device *dev, ulong isr)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	candy_regs *p = pp->regs;
+	struct candy_desc *dp = &pp->rx_ring[pp->rx_head];
+	int pkt_len, rnod;
+	struct sk_buff *newskb;
+	struct sk_buff *rxskb;
+	int i;
+	int skb_size;
+
+	if (netif_msg_rx_status(pp)) {
+		printk(KERN_DEBUG "\trx_head = %d, {0x%04x, %u, 0x%08lx}\n",
+		       pp->rx_head, dp->status, dp->size, dp->pointer);
+	}
+
+	/* FIXME : we are fetching packets.  How do we know where the
+	 * end is?  When OWN bit is 0 (in previous linux driver)?
+	 *
+	 * Checking OWN bit alone is not reliable especially when kgdb
+	 * is used.  Hack to work around.  We really need to understand
+	 * what entries we can consume here.
+	 */
+	for (i = 0;; i++) {
+		dp = &pp->rx_ring[pp->rx_head];
+
+		/* check rx_disable */
+		if (pp->rx_disable) {
+			/*
+			 * Make sure the current RNOD is 4 or larger.
+			 * This was originally the workarond for VR4133A E-20,
+			 * but now it's renewed with RX_RESTART_BREAK.
+			 */
+			rnod = candy_in(p->rxpd) & RNOD_MASK;
+			if (rnod >= RX_RESTART_BREAK) {
+				pp->rx_disable = 0;
+				restart_rx_hw(dev);
+			}
+		}
+
+		if ((dp->status & OWN) == 0) {
+			/* no frame received in this descriptor yet */
+			break;
+		}
+
+		/* handle the error case */
+		if ((dp->status & RXOK) == 0) {
+			handle_rx_error(dev, dp, isr);
+			reclaim_one_rx_desc(dev, NULL);
+			continue;
+		}
+
+		/* oversize? */
+		if (dp->size > ETH_FRAME_LEN + 4) {
+			if (netif_msg_rx_status(pp))
+				printk(KERN_DEBUG "%s: rx, oversized pkt\n",
+				       dev->name);
+			pkt_len = ETH_FRAME_LEN + 4;
+		} else {
+			pkt_len = dp->size;
+		}
+
+		/* we got a good packet */
+
+		/* STRATEGY: ether packet has 14 bytes.  So we will
+		 * suffer from emulated unaligned access if we pass
+		 * the skb straight to upper layer.  An alternative is
+		 * to copy the buffer by offset of 2 and then pass it up.
+		 * Then the overhead is copying.
+		 *
+		 * In general, it is more beneficial to copy if we have smaller
+		 * packet.  Also, it is more beneficial to copy if we have
+		 * faster machines.
+		 *
+		 * To keep it flexible, we will leave rx_copybreak flexible.
+		 */
+
+		if (pkt_len < rx_copybreak) {
+			skb_size = pkt_len + 2;
+		} else {
+			skb_size = RX_BUF_SIZE;
+		}
+
+		/* allocate a new skb */
+		newskb = dev_alloc_skb(skb_size);
+		if (newskb == NULL) {
+			printk(KERN_ERR
+			       "%s: Memory squeeze, dropping packet.\n",
+			       dev->name);
+			reclaim_one_rx_desc(dev, NULL);
+			pp->stats.rx_dropped++;
+			continue;
+		}
+		newskb->dev = dev;
+		skb_reserve(newskb, 2); /* align IP pkt to 16-byte */
+
+		if (pkt_len <= rx_copybreak) {
+			/* we will copy */
+			rxskb = pp->rx_skb[pp->rx_head];
+
+			skb_copy_to_linear_data(newskb, rxskb->data, pkt_len);
+
+			rxskb = newskb;
+			reclaim_one_rx_desc(dev, NULL);
+		} else {
+			/* use the new skb to replace the recived one */
+			rxskb = pp->rx_skb[pp->rx_head];
+
+			pp->rx_skb[pp->rx_head] = newskb;
+			reclaim_one_rx_desc(dev, newskb->data);
+		}
+
+		skb_put(rxskb, pkt_len);
+		rxskb->protocol = eth_type_trans(rxskb, dev);
+		rxskb->ip_summed = CHECKSUM_UNNECESSARY;
+		netif_rx(rxskb);
+
+		dev->last_rx = jiffies;
+	}
+
+	/* rx_disable should be cleared */
+	WARN_ON(pp->rx_disable);
+
+	/*
+	 * when we are out here, should rxdp be the same as
+	 * &pp->rx_ring[pp->head]?
+	 */
+	if (netif_msg_rx_status(pp))
+		printk(KERN_DEBUG "%s: rx, processed %d frames.\n",
+		       dev->name, i);
+#ifdef SHOW_BUG
+	if ((candy_in(p->rxdp) != CPHYSADDR(&pp->rx_ring[pp->rx_head])) &&
+	    (candy_in(p->rxdp) != CPHYSADDR(&pp->rx_ring[RX_RING_SIZE]))) {
+		int i;
+		printk
+		    ("%s : unexpected out of rx - rx_ring[rx_head] = (%04x, %d)\n",
+		     dev->name, dp->status, dp->size);
+		for (i = 0; i < RX_RING_SIZE + 1; i++) {
+			if (p->rxdp == CPHYSADDR(&pp->rx_ring[i]))
+				break;
+		}
+		if (i == RX_RING_SIZE + 1)
+			panic("cannot find current rx tail");
+		printk("\trx_head = %d, rx_tail = %d\n", pp->rx_head, i);
+	}
+#endif
+	return;
+}
+
+#endif /* CONFIG_CANDY_NAPI */
+
+static void
+append_one_tx_desc(struct net_device *dev,
+		   ushort status,
+		   ushort size, ulong pointer, struct sk_buff *skb)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	struct candy_desc *dp = &pp->tx_ring[pp->tx_tail];
+#ifdef WORKAROUND_E10_VR4133
+	int i, shift = pointer % 4;
+#endif
+
+	dp->status = status;
+	dp->size = size;
+	dp->pointer = pointer;
+
+#ifdef WORKAROUND_E10_VR4133
+	if (shift && (size == 30 || size == 31)) {
+		if (skb_tailroom(skb) >= 4 - shift) {
+			shift = 4 - shift;
+			skb->data += shift;
+			dp->pointer += shift;
+			for (i = size + shift - 1; i >= 0; i--)
+				skb->data[i] = skb->data[i - shift];
+			dma_cache_wback_inv((ulong) (skb->data), skb->len);
+		} else if (skb_headroom(skb) >=  shift) {
+			skb->data -= shift;
+			dp->pointer -= shift;
+			for (i = 0; i < size; i++)
+				skb->data[i] = skb->data[i + shift];
+			dma_cache_wback_inv((ulong) (skb->data), skb->len);
+		} else {
+			panic("nec_candy.c: Unable to do a workaround for hardware bug (Restriction 10 for VR4133).\n");
+		}
+	}
+#endif
+	pp->tx_skb[pp->tx_tail] = skb;
+
+	pp->tx_count++;
+	if (++pp->tx_tail == TX_RING_SIZE)
+		pp->tx_tail = 0;
+}
+
+static void
+reclaim_one_tx_desc(struct net_device *dev)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	struct candy_desc *dp = &pp->tx_ring[pp->tx_head];
+
+	dp->status = 0;
+	dp->size = 0;
+	dp->pointer = 0;
+
+	/* free skb */
+	if (pp->tx_skb[pp->tx_head]) {
+		dev_kfree_skb_irq(pp->tx_skb[pp->tx_head]);
+		pp->tx_skb[pp->tx_head] = NULL;
+	}
+
+	pp->tx_count--;
+	if (++pp->tx_head == TX_RING_SIZE)
+		pp->tx_head = 0;
+}
+
+static void
+restart_tx_hw(struct net_device *dev)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	candy_regs *p = pp->regs;
+
+	append_one_tx_desc(dev, 0, 0, 0, NULL);
+
+	/*
+	 * FIXME: This problem is associated with system bus.
+	 *
+	 * Now we've added a NULL descriptor and are about to re-start xmit.
+	 * Beware of tx descs posted writes.
+	 */
+	MEMSYNC(pp->tx_ring);	/* read wherever, so long as uncached */
+
+	/* start */
+	pp->tx_stop = pp->tx_tail;
+	candy_out(p->txdp, CPHYSADDR(&pp->tx_ring[pp->tx_head]));
+}
+
+static void
+handle_tx_error(struct net_device *dev, struct candy_desc *dp, ulong isr)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+
+	if (netif_msg_tx_err(pp))
+		printk(KERN_DEBUG "%s: tx err, tx_ring[%d] error, "
+		       "status = %04x, isr = 0x%08lx.\n",
+		       dev->name, pp->tx_head, dp->status, isr);
+
+#if defined(WORKAROUND_E8_TX_STALL)
+	tx_stall_recover(dev);
+#endif
+
+	pp->stats.tx_errors++;
+	pp->stats.tx_aborted_errors++;
+	if (dp->status & TUDR)
+		pp->stats.tx_fifo_errors++;
+}
+
+static void
+candy_tx_done(struct net_device *dev, ulong isr)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	struct candy_desc *dp;
+
+	if (netif_msg_tx_done(pp))
+		printk(KERN_DEBUG "%s: tx done, process %d frames from %d\n",
+		       dev->name, pp->tx_tail > pp->tx_head ?
+		       pp->tx_tail - pp->tx_head :
+		       pp->tx_tail + TX_RING_SIZE - pp->tx_head, pp->tx_head);
+
+	spin_lock(&pp->lock);	/* sync with xmit() */
+
+	while (pp->tx_head != pp->tx_stop) {
+		dp = &pp->tx_ring[pp->tx_head];
+
+		/* deal with null descriptor, the "stop" packet */
+		if ((isr & TBDR) && (dp->status == 0)) {
+			reclaim_one_tx_desc(dev);
+			continue;
+		}
+
+		/* how about checking OWN bit */
+		if (!(dp->status & OWN)) {
+			if (netif_msg_tx_done(pp))
+				printk(KERN_DEBUG "%s: tx done, "
+				       "found pkt being sent. Break the loop\n",
+				       dev->name);
+			break;
+		}
+
+		/* handle error */
+		if (!(dp->status & TOK)) {
+			handle_tx_error(dev, dp, isr);
+		}
+
+		/* reclaim the descriptor */
+		if (!pp->tx_skb[pp->tx_head]) {
+			printk(KERN_ERR "%s: tx_done but without skb!\n",
+			       dev->name);
+		}
+		reclaim_one_tx_desc(dev);
+
+		/* FIXME: The Japanese version has a tx restart under
+		 * certain error conditions.  Don't understand it.
+		 */
+	}
+
+	/* check if tx has stopped */
+	if ((pp->tx_head == pp->tx_stop) && (pp->tx_stop != pp->tx_tail)) {
+		restart_tx_hw(dev);
+	}
+
+	/* check if queue were stopped */
+	if (netif_queue_stopped(dev) && (pp->tx_count < TX_RING_SIZE - 2)) {
+		if (netif_msg_tx_done(pp))
+			printk(KERN_DEBUG "%s: tx done, queue becomes free,"
+			       "wake up net queue\n", dev->name);
+		netif_wake_queue(dev);
+	}
+
+	spin_unlock(&pp->lock);
+}
+
+static void
+candy_update_stats(struct net_device *dev)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	candy_regs *p = pp->regs;
+
+	/* some stats we get from hardware, while the rest we do
+	 * counting by ourselves
+	 */
+	pp->stats.rx_packets = candy_in(p->rpkt);
+	pp->stats.tx_packets = candy_in(p->tpct);
+	pp->stats.rx_bytes = candy_in(p->rbyt);
+	pp->stats.tx_bytes = candy_in(p->tbyt);
+
+	/* we count rx_errors, tx_errors, rx_dropped, tx_dropped */
+
+	pp->stats.multicast = candy_in(p->rmca);
+	pp->stats.collisions = candy_in(p->tncl);
+
+	pp->stats.rx_length_errors = candy_in(p->rund) +
+	    candy_in(p->rovr) + candy_in(p->rfrg) + candy_in(p->rjbr);
+
+	/* we count rx_over_errors */
+
+	pp->stats.rx_crc_errors = candy_in(p->rfcs);
+	pp->stats.rx_frame_errors = candy_in(p->raln);
+
+	/* we count rx_fifo_errors and rx_missed_errors */
+
+	/* we count tx_aborted_errors */
+
+	pp->stats.tx_carrier_errors = candy_in(p->tcse);
+
+	/* we count tx_fifo_errors */
+
+	/* we don't have tx_heartbeat_errors */
+
+	pp->stats.tx_window_errors = candy_in(p->tlcl);
+
+	/* we don't have rx_compressed and tx_compressed */
+}
+
+/***********************************************************************
+ * high-level linux-related functions
+ ***********************************************************************/
+static int candy_open(struct net_device *dev);
+static int candy_close(struct net_device *dev);
+static irqreturn_t
+candy_interrupt(int irq, void *dev_instance)
+{
+	struct net_device *dev = (struct net_device *) dev_instance;
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	candy_regs *p = pp->regs;
+	ulong isr;
+
+	isr = candy_in(p->isr);
+
+	if (netif_msg_intr(pp)) {
+		printk(KERN_DEBUG "%s: intr, isr = 0x%08lx\n", dev->name, isr);
+		candy_check_intr(isr);
+	}
+
+	if (isr & BUSERR) {
+		printk(KERN_ERR "%s: bus error ... resetting\n", dev->name);
+		candy_error_recover(dev);
+		return IRQ_HANDLED;
+	}
+
+	if (isr & RBDRU) {
+		/*
+		 * disabling RX asap is a sane way not only for VR4133A E-20
+		 * but also for all variants.
+		 */
+		candy_clear_bits(p->macc1, SRXEN);
+		pp->rx_disable = 1;
+		pp->stats.rx_missed_errors++;
+		printk(KERN_ERR "%s : no more receive buffers. Stop receiving.\n",
+		       dev->name);
+	}
+
+	if (isr & OF)
+		pp->stats.rx_fifo_errors++;
+
+#ifdef CONFIG_CANDY_NAPI
+	if (isr & INT_ISR_RX_MASK) {
+		if (netif_rx_schedule_prep(dev,&pp->napi)) {
+			candy_mask_napi_ints(p);
+			__netif_rx_schedule(dev,&pp->napi);
+		}
+	}
+#else
+	if (isr & INT_ISR_RX_MASK) {
+		candy_rx(dev, isr);
+	}
+#endif
+
+	if (isr & INT_ISR_TX_MASK) {
+		candy_tx_done(dev, isr);
+	}
+
+	/* we may need to do something with other intrs too in the future */
+
+	return IRQ_HANDLED;
+}
+
+static void
+candy_get_phy_status(struct net_device *dev, int *duplex, int *linkup,
+		     int *speed)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	u16 reg;
+
+	reg = mdio_read(pp->mii_if.dev, pp->mii_if.phy_id, MII_BMCR);
+
+	if (!(reg & BMCR_ANENABLE)) {
+		/*
+		 * Auto-negotiation is disabled so the full duplex bit in
+		 * the control register tells us if the PHY is running
+		 * half or full duplex.
+		 */
+		*duplex = (reg & BMCR_FULLDPLX) ? 1 : 0;
+		*speed = (reg & BMCR_SPEED100) ? 1: 0;
+	} else {
+		/*
+		 * Auto-negotiation is enabled.  Figure out what was
+		 * negotiated by looking for the best mode in the union
+		 * of what we and our partner advertise.
+		 */
+		u16 advertise, partner, negotiated;
+
+		advertise = mdio_read(pp->mii_if.dev,
+				      pp->mii_if.phy_id, MII_ADVERTISE);
+		partner = mdio_read(pp->mii_if.dev, pp->mii_if.phy_id, MII_LPA);
+
+		negotiated = advertise & partner & ADVERTISE_ALL;
+		if (negotiated & ADVERTISE_100FULL) {
+			*duplex = 1;
+			*speed = 1;
+		} else if (negotiated & ADVERTISE_100HALF) {
+			*duplex = 0;
+			*speed = 1;
+		} else if (negotiated & ADVERTISE_10FULL) {
+			*duplex = 1;
+			*speed = 0;
+		} else {
+			*duplex = 0;
+			*speed = 0;
+		}
+	}
+
+	reg = mdio_read(pp->mii_if.dev, pp->mii_if.phy_id, MII_BMSR);
+
+	*linkup = (reg & BMSR_LSTATUS) != 0;
+}
+
+static void
+candy_poll_mii(unsigned long data)
+{
+	struct net_device *dev = (struct net_device *) data;
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	int phy_duplex, mac_duplex;
+	int phy_carrier, netif_carrier;
+	int phy_speed, mac_speed;
+
+	/* First, find out what's going on with the PHY. */
+	candy_get_phy_status(dev, &phy_duplex, &phy_carrier, &phy_speed);
+
+	/* Second, figure out the speed/duplex of the EMAC */
+	mac_duplex = pp->link_status.fullduplex;
+	mac_speed = pp->link_status.speed100;
+
+	/* Now see if there is a mismatch. */
+	if ((mac_duplex != phy_duplex || phy_speed != mac_speed)
+	    && phy_carrier) {
+		/* reset */
+		netif_stop_queue(dev);
+
+		candy_down(dev);
+		candy_hw_init(dev);
+		candy_up(dev);
+
+		netif_wake_queue(dev);
+	}
+
+	netif_carrier = netif_carrier_ok(dev) != 0;
+
+	if (phy_carrier != netif_carrier) {
+		if (phy_carrier) {
+			candy_set_media_speed(dev);
+			printk(KERN_INFO "%s: Link carrier restored.\n",
+			       dev->name);
+			netif_carrier_on(dev);
+		} else {
+			printk(KERN_INFO "%s: Link carrier lost.\n", dev->name);
+			netif_carrier_off(dev);
+		}
+	}
+
+	/* Set up the timer so we'll get called again in 2 seconds. */
+	mod_timer(&pp->phy_timer, jiffies + 2 * HZ);
+}
+
+static int
+candy_open(struct net_device *dev)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	int retval;
+
+	if (netif_msg_ifup(pp))
+		printk(KERN_DEBUG "%s: enabling interface\n", dev->name);
+
+	candy_init_rings(dev);
+
+	candy_hw_init(dev);
+	candy_filter_init(dev);
+	candy_up(dev);
+
+	/* request IRQ */
+	retval = request_irq(dev->irq, candy_interrupt, IRQF_SHARED,
+			     dev->name, dev);
+	if (retval) {
+		printk(KERN_ERR "%s: unable to get IRQ %d\n",
+		       dev->name, dev->irq);
+		return retval;
+	}
+
+#ifdef CONFIG_CANDY_NAPI
+	napi_enable(&pp->napi);
+#endif
+	init_timer(&pp->phy_timer);
+
+	pp->phy_timer.data = (unsigned long) dev;
+	pp->phy_timer.function = &candy_poll_mii;
+	candy_poll_mii((unsigned long) dev);
+
+	netif_start_queue(dev);
+
+	return 0;
+}
+
+static int
+candy_close(struct net_device *dev)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+
+#ifdef CONFIG_CANDY_NAPI
+	napi_disable(&pp->napi);
+#endif
+	if (netif_msg_ifdown(pp))
+		printk(KERN_DEBUG "%s: disabling interface\n", dev->name);
+
+	del_timer_sync(&pp->phy_timer);
+
+	if (netif_device_present(dev)) {
+		netif_stop_queue(dev);
+		netif_carrier_off(dev);
+		candy_down(dev);
+
+		/* free tx skb */
+		while (pp->tx_tail != pp->tx_head) {
+			if (pp->tx_skb[pp->tx_head]) {
+				dev_kfree_skb_irq(pp->tx_skb[pp->tx_head]);
+				pp->tx_skb[pp->tx_head] = NULL;
+			}
+
+			pp->tx_count--;
+			if (++pp->tx_head == TX_RING_SIZE)
+				pp->tx_head = 0;
+		}
+	}
+
+	free_irq(dev->irq, dev);
+
+	return 0;
+}
+
+static int
+candy_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	ulong flags;
+
+	if (netif_msg_tx_queued(pp))
+		printk(KERN_DEBUG "%s: tx queued, skblen %d\n",
+		       dev->name, skb->len);
+
+	/* check packet size */
+	if (skb->len > ETH_FRAME_LEN) {
+		printk(KERN_ERR "%s: packet size too big, %d\n", dev->name,
+		       skb->len);
+		pp->stats.tx_dropped++;
+		return 1;
+	}
+
+	spin_lock_irqsave(&pp->lock, flags);
+
+	/* check to see if tx_ring is full */
+	if (pp->tx_count >= TX_RING_SIZE - 1) {
+		printk(KERN_ERR "%s: TX ring full, packet dropped.\n",
+		       dev->name);
+		pp->stats.tx_dropped++;
+		spin_unlock_irqrestore(&pp->lock, flags);
+		/* why the queue was not stopped before we get here? */
+		netif_stop_queue(dev);
+		return 1;
+	}
+
+	/* add the descriptor */
+	{
+		ushort temp = skb->len;
+#ifdef WORKAROUND_E21_PAD
+		if (temp < 60)
+			temp = 60;
+#endif
+		dma_cache_wback_inv((ulong) (skb->data), skb->len);
+		append_one_tx_desc(dev, LAST | DB_LP, temp,
+				   CPHYSADDR(skb->data), skb);
+	}
+
+	/* logistics */
+	dev->trans_start = jiffies;
+
+	/* do we need to start sending or just append */
+	if ((pp->tx_head == pp->tx_stop) && (pp->tx_stop != pp->tx_tail)) {
+		restart_tx_hw(dev);
+	}
+
+	if (pp->tx_count >= TX_RING_SIZE - 2) {
+		netif_stop_queue(dev);
+	}
+
+	spin_unlock_irqrestore(&pp->lock, flags);
+
+	return 0;
+}
+
+static struct net_device_stats *
+candy_get_stats(struct net_device *dev)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	unsigned long flags;
+
+	if (netif_device_present(dev)) {
+		spin_lock_irqsave(&pp->lock, flags);
+		candy_update_stats(dev);
+		spin_unlock_irqrestore(&pp->lock, flags);
+	}
+	return &pp->stats;
+}
+
+static void
+candy_set_rx_mode(struct net_device *dev)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+	candy_regs *p = pp->regs;
+	ulong val;
+
+	DEBUG_VERBOSE(printk("candy_set_rx_mode() invoked.\n"));
+
+	/* TODO: need to acquire spinlock and stop receiving */
+
+	val = candy_in(p->afr);
+	val &= ~(PRO | PRM | AMC);
+	if (dev->flags & IFF_PROMISC) {
+		val |= PRO;
+	} else if ((dev->flags & IFF_ALLMULTI) || (dev->mc_count > 64)) {
+		/* disable promiscuous mode, use normal mode */
+		candy_set_filter(dev, 0);
+		val |= PRM;
+	} else if (dev->mc_count) {
+		/* walk the address list, and load the filter */
+		candy_set_filter(dev, 1);
+		val |= AMC;
+	}
+#ifdef	WORKAROUND_E10_PRM_AMC
+	candy_out(p->afr, val & ABC);
+#else
+	candy_out(p->afr, val);
+#endif
+}
+
+static void
+candy_tx_timeout(struct net_device *dev)
+{
+	struct candy_private *pp = (struct candy_private *) dev->priv;
+
+	printk(KERN_ERR "%s : tx_timeout.\n", dev->name);
+
+	pp->stats.tx_errors++;
+
+	candy_error_recover(dev);
+}
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+static void candy_poll_controller(struct net_device *dev)
+{
+	disable_irq(dev->irq);
+	candy_interrupt(dev->irq, dev);
+	enable_irq(dev->irq);
+}
+#endif
+
+static int nec_candy_probe(struct device *dev)
+{
+	int i, ret;
+	struct resource *res;
+	struct net_device *ndev;
+	candy_regs *p;
+	struct candy_private *pp;
+	struct nec_candy_platform_data *pdata = dev->platform_data;
+	struct platform_device *pdev = to_platform_device(dev);
+
+	printk(KERN_INFO "%s\n", version);
+
+	/*
+	 * hardware is already initialized.  We just need do some Linux
+	 * related initialization.
+	 */
+
+	/* create net_device structure */
+	ndev = alloc_etherdev(sizeof(struct candy_private));
+	if (!ndev) {
+		printk(KERN_ERR "ether device alloc failed. aborting\n");
+		ret = -EINVAL;
+		goto err1;
+	}
+
+	/* init some device related data/func ptrs */
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
+					   "nec_candy_regs");
+	if (!res) {
+		ret = -ENODEV;
+		goto err2;
+	}
+
+	if (!request_mem_region(res->start, res->end - res->start + 1,
+				"NEC_CANDY")) {
+		ret = -EBUSY;
+		goto err2;
+	}
+
+	ndev->base_addr = (unsigned long) ioremap(res->start,
+						  res->end - res->start + 1);
+	if (!ndev->base_addr) {
+		ret = -ENOMEM;
+		goto err3;
+	}
+
+	ndev->irq = platform_get_irq_byname(pdev, "nec_candy_irq");
+
+	for (i = 0; i < 6; i++)
+		ndev->dev_addr[i] = pdata->mac_addr[i];
+
+	ndev->open = candy_open;
+	ndev->stop = candy_close;
+	ndev->do_ioctl = candy_ioctl;
+	ndev->hard_start_xmit = candy_xmit;
+	ndev->get_stats = candy_get_stats;
+	ndev->set_multicast_list = candy_set_rx_mode;
+	ndev->tx_timeout = candy_tx_timeout;
+	ndev->watchdog_timeo = TX_TIMEOUT;
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	ndev->poll_controller = candy_poll_controller;
+#endif
+
+	/* init private data */
+	pp = (struct candy_private *) ndev->priv;
+	p = pp->regs = (candy_regs *) ndev->base_addr;
+	pp->dev = dev;
+
+#ifdef CONFIG_CANDY_NAPI
+	netif_napi_add(ndev, &pp->napi, candy_napi_poll,64);
+#endif
+	/* alloc tx/rx rings and rx buffers */
+
+	pp->tx_ring = kmalloc(sizeof(struct candy_desc) * (TX_RING_SIZE + 1), GFP_ATOMIC);
+	if (!pp->tx_ring) {
+		ret = -ENOMEM;
+		goto err4;
+	}
+	pp->rx_ring = kmalloc(sizeof(struct candy_desc) * (RX_RING_SIZE + 1), GFP_ATOMIC);
+	if (!pp->rx_ring) {
+		ret = -ENOMEM;
+		goto err5;
+	}
+
+	dma_cache_inv((ulong) pp->tx_ring,
+		      sizeof(struct candy_desc) * (TX_RING_SIZE + 1));
+	dma_cache_inv((ulong) pp->rx_ring,
+		      sizeof(struct candy_desc) * (RX_RING_SIZE + 1));
+
+	pp->tx_ring = (void *) KSEG1ADDR(pp->tx_ring);
+	pp->rx_ring = (void *) KSEG1ADDR(pp->rx_ring);
+
+	/* allocate rx skbs */
+	for (i = 0; i < RX_RING_SIZE; i++) {
+		pp->rx_skb[i] = dev_alloc_skb(RX_BUF_SIZE);
+		if (pp->rx_skb[i] == NULL) {
+			panic("%s: failed to alloc rx skb!", ndev->name);
+		}
+		pp->rx_skb[i]->dev = ndev;
+		skb_reserve(pp->rx_skb[i], 2); /* align IP pkt to 16-byte */
+		dma_cache_inv((ulong) pp->rx_skb[i]->data, RX_BUF_SIZE);
+	}
+
+	/* set up links */
+	pp->ndev = ndev;
+	pp->msg_enable = (debug < 0 ? CANDY_DEF_MSG_ENABLE : debug);
+	pp->next = candy_priv_head;
+	candy_priv_head = pp;
+	dev_set_drvdata(dev, ndev);
+	pp->mii_if.dev = ndev;
+	pp->mii_if.mdio_read = mdio_read;
+	pp->mii_if.mdio_write = mdio_write;
+	pp->mii_if.phy_id = pdata->pmd_addr;
+	pp->mii_if.phy_id_mask = 0x1f;
+	pp->mii_if.reg_num_mask = 0x1f;
+
+	spin_lock_init(&pp->lock);
+	spin_lock_init(&pp->rxlock);
+
+	/*==============================================================
+	 * hardware initialization
+	 *==============================================================
+	 */
+
+	/* TODO: maybe we want to make sure the chip is there */
+
+	/*
+	 * zero out counters
+	 */
+	candy_out(p->rbyt, 0);
+	candy_out(p->rpkt, 0);
+	candy_out(p->rfcs, 0);
+	candy_out(p->rmca, 0);
+	candy_out(p->rbca, 0);
+	candy_out(p->rxcf, 0);
+	candy_out(p->rxpf, 0);
+	candy_out(p->rxuo, 0);
+	candy_out(p->raln, 0);
+	candy_out(p->rflr, 0);
+	candy_out(p->rcde, 0);
+	candy_out(p->rfcr, 0);
+	candy_out(p->rund, 0);
+	candy_out(p->rovr, 0);
+	candy_out(p->rfrg, 0);
+	candy_out(p->rjbr, 0);
+	candy_out(p->r64, 0);
+	candy_out(p->r127, 0);
+	candy_out(p->r255, 0);
+	candy_out(p->r511, 0);
+	candy_out(p->r1k, 0);
+	candy_out(p->rmax, 0);
+	candy_out(p->rvbt, 0);
+
+	candy_out(p->tbyt, 0);
+	candy_out(p->tpct, 0);
+	candy_out(p->tfcs, 0);
+	candy_out(p->tmca, 0);
+	candy_out(p->tbca, 0);
+	candy_out(p->tuca, 0);
+	candy_out(p->txpf, 0);
+	candy_out(p->tdfr, 0);
+	candy_out(p->txdf, 0);
+	candy_out(p->tscl, 0);
+	candy_out(p->tmcl, 0);
+	candy_out(p->tlcl, 0);
+	candy_out(p->txcl, 0);
+	candy_out(p->tncl, 0);
+	candy_out(p->tcse, 0);
+	candy_out(p->time, 0);
+
+	ret = register_netdev(ndev);
+	if (ret != 0)
+		goto err6;
+
+	printk (KERN_INFO DRV_NAME ": Probe candy chip at "
+		"0x%08x, irq %d, Phy ID 0x%08x, "
+		"MAC Addr %02x:%02x:%02x:%02x:%02x:%02x\n",
+		res->start, ndev->irq, pp->mii_if.phy_id,
+		ndev->dev_addr[0], ndev->dev_addr[1],
+		ndev->dev_addr[2], ndev->dev_addr[3],
+		ndev->dev_addr[4], ndev->dev_addr[5]);
+
+	return 0;
+
+err6:
+	printk(KERN_ERR "Failed to register ethernet device\n");
+	for (i = 0; i < RX_RING_SIZE; i++)
+		dev_kfree_skb(pp->rx_skb[i]);
+	kfree(pp->rx_ring);
+err5:
+	kfree(pp->tx_ring);
+err4:
+	iounmap((void *) ndev->base_addr);
+err3:
+	release_mem_region(res->start, res->end - res->start + 1);
+err2:
+	free_netdev(ndev);
+err1:
+	return ret;
+}
+
+static int nec_candy_remove(struct device *dev)
+{
+	int i;
+	struct net_device *ndev = dev_get_drvdata(dev);
+	struct candy_private *pp = netdev_priv(ndev);
+	struct resource *res =
+		platform_get_resource_byname(to_platform_device(dev),
+					     IORESOURCE_MEM,
+					     "nec_candy_regs");
+
+	for (i = 0; i < RX_RING_SIZE; i++)
+		dev_kfree_skb(pp->rx_skb[i]);
+
+	kfree((void *)KSEG0ADDR(pp->rx_ring));
+	kfree((void *)KSEG0ADDR(pp->tx_ring));
+
+	iounmap((void *)ndev->base_addr);
+	release_mem_region(res->start, res->end - res->start + 1);
+
+	unregister_netdev(ndev);
+	free_netdev(ndev);
+
+	return 0;
+}
+
+static struct device_driver nec_candy_driver = {
+	.name		= "nec_candy",
+	.bus		= &platform_bus_type,
+	.probe		= nec_candy_probe,
+	.remove		= nec_candy_remove,
+};
+
+static int __init nec_candy_module_init(void)
+{
+	return driver_register(&nec_candy_driver);
+}
+
+static void __exit nec_candy_module_exit(void)
+{
+	driver_unregister(&nec_candy_driver);
+}
+
+module_init(nec_candy_module_init);
+module_exit(nec_candy_module_exit);
+
+#if defined(MODULE)
+MODULE_AUTHOR("Jun Sun, jsun@mvista.com or jsun@junsun.net");
+MODULE_DESCRIPTION("Ether driver for NEC Candy controller");
+MODULE_LICENSE("GPL");
+#endif
diff --git a/drivers/net/nec_candy.h b/drivers/net/nec_candy.h
new file mode 100644
index 0000000..0043116
--- /dev/null
+++ b/drivers/net/nec_candy.h
@@ -0,0 +1,600 @@
+/*
+ * drivers/net/nec_candy.h
+ *
+ * NEC Candy Ethernet driver.
+ *
+ * Author: Wade Farnsworth <wfarnsworth@mvista.com>
+ *
+ * 2001-2006 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#ifndef NEC_CANDY_H
+#define NEC_CANDY_H
+
+#include <asm/byteorder.h>
+
+/***********************************************************************
+ * Configure
+ ***********************************************************************/
+#define EMMA3P
+#ifdef EMMA3P
+#define VR4133A
+#endif
+
+#define TX_RING_SIZE	32
+#define RX_RING_SIZE	512
+
+#define RX_BUF_SIZE	1536
+#define ETH_FRAME_SIZE	1536
+
+#define TX_TIMEOUT	4*HZ
+
+#ifndef CONFIG_CANDY_NAPI
+/* rx_copybreak:  for smaller packet we copy them to avoid emulated
+ * unaligned access overhead.
+ *
+ * Set it to 1518 to always copy ( you should do that on fast machines)
+ *
+ * Set it to 0 to avoid any copy.
+ *
+ * On Korva, some value in the middle might be appropriate.
+ */
+static int rx_copybreak = 160;
+#endif
+
+/*
+ * RX_RESTART_BREAK: once RBDRU interrupt happens, candy stops receiving.
+ *
+ * Set it to 1 to immediately restart receiving with just one rx descriptor.
+ *
+ * Set it to RX_RING_SIZE to restart receiving when all rx buffer descriptors
+ * are reclaimed.
+ *
+ * As for VR4133A, please set it to 4 or larger as a workaround for bug E-20.
+ * This obsoletes WORKAROUND_E20_VR4133A.
+ */
+#define RX_RESTART_BREAK    16
+
+/***********************************************************************
+ * hardware bug workarounds
+ ***********************************************************************/
+
+#define WORKAROUND_E7_AFCE
+#define WORKAROUND_E10_PRM_AMC
+#define WORKAROUND_E13_TXFC
+#define WORKAROUND_E8_TX_STALL
+
+#if defined(CONFIG_NEC_CMB_VR7701)
+#undef WORKAROUND_E7_AFCE
+#undef WORKAROUND_E10_PRM_AMC
+#undef WORKAROUND_E13_TXFC
+#undef WORKAROUND_E8_TX_STALL
+#endif
+
+#ifdef CONFIG_NEC_CMBVR4133
+#undef WORKAROUND_E7_AFCE
+#undef WORKAROUND_E10_PRM_AMC
+#undef WORKAROUND_E13_TXFC
+#define WORKAROUND_E21_PAD
+#define WORKAROUND_E10_VR4133
+#endif
+
+#ifdef EMMA3P
+#undef WORKAROUND_E7_AFCE
+#undef WORKAROUND_E10_PRM_AMC
+#undef WORKAROUND_E13_TXFC
+#undef WORKAROUND_E8_TX_STALL
+#endif
+
+/*---------------------------------------------------------------------------*/
+/* MACC1 - MAC configuration register 1 (00H R/W)                            */
+/*---------------------------------------------------------------------------*/
+#define MACLB		0x00004000	/* MAC loopback */
+#define TXFC		0x00000800	/* Transmit flow control enable */
+#define RXFC		0x00000400	/* Receive flow control enable */
+#define SRXEN		0x00000200	/* Receive enable */
+#define PARF		0x00000100	/* Control packet pass */
+#define PUREP		0x00000080	/* Pure preamble */
+#define FLCHT		0x00000040	/* Length field check */
+#define NOBO		0x00000020	/* No Back Off */
+#define CRCEN		0x00000008	/* CRC append enable */
+#define PADEN		0x00000004	/* PAD append enable */
+#define FULLD		0x00000002	/* Full duplex enable */
+#define HUGEN		0x00000001	/* Large packet enable */
+#define MACC1_RESERVED	0x00004fef	/* reserved bit 0 */
+
+/*---------------------------------------------------------------------------*/
+/* MACC2 - MAC configuration register 2 (04H R/W)                            */
+/*---------------------------------------------------------------------------*/
+#define MCRST		0x00000400	/* MAC Control Block software reset */
+#define RFRST		0x00000200	/* Rx Function Block software reset */
+#define TFRST		0x00000100	/* Tx Function Block software reset */
+#define BPNB		0x00000040	/* Back Pressure No Back Off */
+#define APD		0x00000020	/* Auto VLAN PAD */
+#define VPD		0x00000010	/* VLAN PAD mode */
+#define MACC2_RESERVED	0x00000770	/* reserved bit 0 */
+
+/*---------------------------------------------------------------------------*/
+/* IPGT - Back-to-Back IPG register (08H R/W)                                */
+/*---------------------------------------------------------------------------*/
+#define IPGT		0x00000013	/* Back-To-Back IPG default value */
+#define IPGT_RESERVED	0x0000007f	/* reserved bit 0 */
+
+/*---------------------------------------------------------------------------*/
+/* IPGR - Non Back-to-Back IPG register (0CH R/W)                            */
+/*---------------------------------------------------------------------------*/
+#define IPGR1		0x00000e00	/* Back-To-Back IPG default value */
+#define IPGR2		0x00000013	/* Back-To-Back IPG default value */
+#define IPGR_RESERVED	0x00007f7f	/* reserved bit 0 */
+
+/*---------------------------------------------------------------------------*/
+/* CLRT - Collision register (10H R/W)                                       */
+/*---------------------------------------------------------------------------*/
+#define LCOLW		0x00003800	/* Late collision window dflt value */
+#define RETRY		0x0000000f	/* Max number of retry default value */
+#define CLRT_RESERVED	0x00003f0f	/* reserved bit 0 */
+
+/*---------------------------------------------------------------------------*/
+/* LMAX - Maximum Packet Length register (14H R/W)                           */
+/*---------------------------------------------------------------------------*/
+#define MAXF		0x000005f2	/* Max pkt length value (1522 bytes) */
+#define LMAX_RESERVED	0x0000ffff	/* reserved bit 0 */
+
+/*---------------------------------------------------------------------------*/
+/* LSA2 - Station address register 2 (54H R/W)                               */
+/*---------------------------------------------------------------------------*/
+#define LSA2_MASK	0x0000ffff  	/* Station address SA (47:32) */
+#define LSA2_RESERVED	0x0000ffff	/* reserved bit 0 */
+
+/*---------------------------------------------------------------------------*/
+/* LSA1 - Station address register 1 (58H R/W)                               */
+/*---------------------------------------------------------------------------*/
+#define LSA1_MASK	0xffffffff	/* Station address SA(31:0) */
+
+/*---------------------------------------------------------------------------*/
+/* PTVR - Pause timer read register (5CH Read)                               */
+/*---------------------------------------------------------------------------*/
+#define PTCT_MASK	0x0000ffff	/* Pause timer counter */
+
+/*---------------------------------------------------------------------------*/
+/* VLTP - VLAN type register (64H R/W)                                       */
+/*---------------------------------------------------------------------------*/
+#define VLTP		0x00008100	/* VLAN type ( etpid:0x81 tci:0x00 ) */
+#define VLTP_RESERVED	0x0000ffff	/* reserved bit 0 */
+
+/*---------------------------------------------------------------------------*/
+/* MIIC - MII Configuration register (80H R/W)                               */
+/*---------------------------------------------------------------------------*/
+#define MISRT		0x00008000	/* MII Mgmt Interface Block s/w reset */
+#define CLKS25		0x00000000	/* HCLK <= 25 MHz */
+#define CLKS33		0x00000004	/* HCLK <= 33 MHz */
+#define CLKS50		0x00000008	/* HCLK <= 50 MHz */
+#define CLKS66		0x0000000c	/* HCLK <= 66 MHz */
+#ifdef EMMA3P
+#define CLKS166		0x00000018	/* HCLK <= 166 MHz */
+#define CLKS200		0x0000001c	/* HCLK <= 200 MHz */
+#define MIIC_RESERVED	0x0000801c	/* reserved bit 0 */
+#else
+#define MIIC_RESERVED	0x0000800c	/* reserved bit 0 */
+#endif
+
+/*---------------------------------------------------------------------------*/
+/* MCMD - MII command register (94H Write)                                   */
+/*---------------------------------------------------------------------------*/
+#define SCANC		0x00000002	/* SCAN command */
+#define RSTAT		0x00000001	/* MII management read */
+#define MCMD_RESERVED	0x00000003	/* reserved bit 0 */
+
+/*---------------------------------------------------------------------------*/
+/* MADR - MII address register (98H R/W)                                     */
+/*---------------------------------------------------------------------------*/
+#define FIAD_MASK	0x00001f00	/* MII PHY address */
+#define FIAD_SHIFT  	8
+#define RGAD_MASK   	0x0000001f	/* MII register address */
+#define MADR_RESERVED	0x00001f1f	/* reserved bit 0 */
+
+/*---------------------------------------------------------------------------*/
+/* MIND - MII indicator register (A4H Read)                                  */
+/*---------------------------------------------------------------------------*/
+#define NVALID		0x00000004	/* SCAN command start status */
+#define SCANA		0x00000002	/* SCAN command active */
+#define BUSY		0x00000001	/* BUSY */
+#define MIND_RESERVED	0x00000007	/* reserved bit 0 */
+
+/*---------------------------------------------------------------------------*/
+/* AFR - Address Filter register (C8H R/W)                                   */
+/*---------------------------------------------------------------------------*/
+#define PRO		0x00000008	/* Promiscuous mode */
+#define PRM		0x00000004	/* Accept Multicast */
+#define AMC		0x00000002	/* Accept Multicast ( qualified ) */
+#define ABC		0x00000001	/* Accept Broadcast */
+#define AFR_RESERVED	0x0000000f	/* reserved bit 0 */
+
+/*---------------------------------------------------------------------------*/
+/* CAR1 - CARRY register1 (DCH R/W)                                          */
+/*---------------------------------------------------------------------------*/
+#define C1VT		0x00008000	/* RVBT counter carry bit */
+#define C1UT		0x00004000	/* TUCA counter carry bit */
+#define C1BT		0x00002000	/* TBCA counter carry bit */
+#define C1MT		0x00001000	/* TMCA counter carry bit */
+#define C1PT		0x00000800	/* TPCT counter carry bit */
+#define C1TB		0x00000400	/* TBYT counter carry bit */
+#define C1MX		0x00000200	/* RMAX counter carry bit */
+#define C11K		0x00000100	/* R1K counter carry bit */
+#define C1FE		0x00000080	/* R511 counter carry bit */
+#define C1TF		0x00000040	/* R255 counter carry bit */
+#define C1OT		0x00000020	/* R127 counter carry bit */
+#define C1SF		0x00000010	/* R64 counter carry bit */
+#define C1BR		0x00000008	/* RBCA counter carry bit */
+#define C1MR		0x00000004	/* RBCA counter carry bit */
+#define C1PR		0x00000002	/* RPKT counter carry bit */
+#define C1RB		0x00000001	/* RBYT counter carry bit */
+#define CAR1_RESERVED	0x0000ffff	/* reserved bit 0  */
+
+/*---------------------------------------------------------------------------*/
+/* CAR2 - CARRY register2 (E0H R/W)                                          */
+/*---------------------------------------------------------------------------*/
+#define C2SV		0x80000000	/* Status vector overrun bit */
+#define C2IM		0x00400000	/* TIME counter carry bit */
+#define C2CS		0x00200000	/* TCSE counter carry bit */
+#define C2BC		0x00100000	/* TNCL counter carry bit */
+#define C2XC		0x00080000	/* TXCL counter carry bit */
+#define C2LC		0x00040000	/* TLCL counter carry bit */
+#define C2MC		0x00020000	/* TMCL counter carry bit */
+#define C2SC		0x00010000	/* TSCL counter carry bit */
+#define C2XD		0x00008000	/* TXDF counter carry bit */
+#define C2DF		0x00004000	/* TDFR counter carry bit */
+#define C2XF		0x00002000	/* TXPF counter carry bit */
+#define C2TE		0x00001000	/* TFCS counter carry bit */
+#define C2JB		0x00000800	/* RBJR counter carry bit */
+#define C2FG		0x00000400	/* RFRG counter carry bit */
+#define C2OV		0x00000200	/* ROVR counter carry bit */
+#define C2UN		0x00000100	/* RUND counter carry bit */
+#define C2FC		0x00000080	/* RFCR counter carry bit */
+#define C2CD		0x00000040	/* RCDE counter carry bit */
+#define C2FO		0x00000020	/* RFLR counter carry bit */
+#define C2AL		0x00000010	/* RALN counter carry bit */
+#define C2UO		0x00000008	/* RXUO counter carry bit */
+#define C2PF		0x00000004	/* RXPF counter carry bit */
+#define C2CF		0x00000002	/* RXCF counter carry bit */
+#define C2RE		0x00000001	/* RFCS counter carry bit */
+#define CAR2_RESERVED   0x807fffff	/* reserved bit 0 */
+
+/*---------------------------------------------------------------------------*/
+/* TXCFG - Transmit Configuration (200H R/W)                                 */
+/*---------------------------------------------------------------------------*/
+#ifdef VR4133A
+#define AFCE1		0x00000001	/* Automatic Flow Control 1 Enable */
+#define AFCE2		0x00000002	/* Automatic Flow Control 2 Enable */
+#define AP0TE		0x00000004	/* Automatic PAUSE 0 Transmit Enable */
+#define FLWMON		0x00000080	/* Flow Control Monitor Enable */
+#else
+#define AFCE		0x00000001	/* Automatic Flow Control Enable */
+#endif
+#define DTBS1		0x00000000	/* DMA Transmit Burst Size 1 word */
+#define DTBS2		0x00010000	/* DMA Transmit Burst Size 2 word */
+#define DTBS4		0x00020000	/* DMA Transmit Burst Size 4 word */
+#define DTBS8		0x00030000	/* DMA Transmit Burst Size 8 word */
+#define DTBS16		0x00040000	/* DMA Transmit Burst Size 16 word */
+#define DTBS32		0x00050000	/* DMA Transmit Burst Size 32 word */
+#define DTBS64		0x00060000	/* DMA Transmit Burst Size 64 word */
+#define TXE		0x80000000	/* Transmit Enable */
+#ifdef VR4133A
+#define TXCFG_RESERVED	0x80070087	/* reserved bit 0 */
+#else
+#define TXCFG_RESERVED	0x80070001	/* reserved bit 0 */
+#endif
+
+/*---------------------------------------------------------------------------*/
+/* TXFC - Transmit FIFO Control (204H R/W)                                   */
+/*---------------------------------------------------------------------------*/
+#define TPTV_MASK	0xffff0000	/* Tx Pause Timer Value mask */
+#define TPTV		0xffff0000	/* default 0xFFFF slot time */
+#define TX_DRTH_MASK	0x0000fc00	/* Tx Fill Threshold Level mask */
+#define TX_DRTH		0x00004000	/* default 010000b (16word, 64byte) */
+#define TX_FLTH_MASK	0x000000fc	/* Tx Drain Threshold Level mask */
+#ifdef CONFIG_NEC_CMBVR4133
+/*
+ * We set this to 160 bytes for VR4133 because of the hardware restriction:
+ * the sum of TX_FLTH and DTBS should be <= 192 bytes. DTBS is set to 32 bytes
+ * for VR4133.
+ */
+#define TX_FLTH		0x000000a0	/* 101000b (160byte) */
+#else
+#ifdef EMMA3P
+#define TX_FLTH		0x00000080	/* default 100000b (32word, 128byte) */
+#else
+#define TX_FLTH		0x000000c0	/* default 110000b (48word, 192byte) */
+#endif
+#endif
+#define TXFC_RESERVED	0xfffffcfc	/* reserved bit 0 */
+
+/*---------------------------------------------------------------------------*/
+/* RXCFG - Receive Configuration (218H R/W)                                  */
+/*---------------------------------------------------------------------------*/
+#define DRBS1		0x00000000	/* DMA Receive Burst Size 1 word */
+#define DRBS2		0x00010000	/* DMA Receive Burst Size 2 word */
+#define DRBS4		0x00020000	/* DMA Receive Burst Size 4 word */
+#define DRBS8		0x00030000	/* DMA Receive Burst Size 8 word */
+#define DRBS16		0x00040000	/* DMA Receive Burst Size 16 word */
+#define DRBS32		0x00050000	/* DMA Receive Burst Size 32 word */
+#define DRBS64		0x00060000	/* DMA Receive Burst Size 64 word */
+#define RXE		0x80000000	/* Receive Enable */
+#define RXCFG_RESERVED	0x80070000	/* reserved bit 0 */
+
+/*---------------------------------------------------------------------------*/
+/* RXFC - Receive FIFO Control (21CH R/W)                                    */
+/*---------------------------------------------------------------------------*/
+#define UWM_MASK	0xfc000000	/* Upper Water Mark mask */
+#define UWM		0xc0000000	/* default 110000b (48word, 192byte) */
+#define LWM_MASK	0x00fc0000	/* Lower Water Mark mask */
+#define LWM		0x00400000	/* default 010000b (16word, 64byte) */
+#define RX_DRTH_MASK	0x000000fc	/* Receive Drain Threshold Level */
+#define RX_DRTH16W	0x00000040	/* default 010000b (16word, 64byte) */
+#define RX_DRTH28W	0x00000070	/* default 011100b (28word, 112byte) */
+#define RXFC_RESERVED	0xfcfc00fc	/* reserved bit 0 */
+
+/*---------------------------------------------------------------------------*/
+/* RXPD - Receive Pool Descriptor (230H R/W)                                 */
+/*---------------------------------------------------------------------------*/
+#define AL		0xf0000000	/* Alert Level default value */
+#define AL_MASK		0xf0000000
+#define RNOD_MASK	0x0000ffff	/* Remaining Number of Descriptor */
+#define DUWM		0x00f00000	/* 60 */
+#define DLWM		0x000f0000	/* 60 */
+#define RXPD_RESERVED	0xf0ffffff	/* reserved bit */
+
+/*---------------------------------------------------------------------------*/
+/* CCR - Candy Configuration Register (234H R / 240H W)                      */
+/*---------------------------------------------------------------------------*/
+#define SRT		0x00000001	/* Candy Software Reset */
+#define MII_PIN_SELECT	0x20000000	/* MII pin selection */
+#define RMII_MODE	0x40000000	/* RMII mode */
+#define SPD100		0x80000000	/* Operation speed in RMII mode */
+
+/*---------------------------------------------------------------------------*/
+/* ISR - Interrupt Status Register (238H R with clear)                       */
+/* MSR - Mask Interrupt Register   (23cH R/W)                                */
+/*---------------------------------------------------------------------------*/
+#define BUSERR		0x80000000	/* IBUS Error */
+#define XMTDN		0x00008000	/* Transmit Done */
+#define TBDR		0x00004000	/* Transmit BD Request at Null */
+#define TFLE		0x00002000	/* Transmit Frame Length Exceed */
+#define UR		0x00001000	/* Underrun */
+#define TABR		0x00000800	/* Transmit Aborted */
+#define TCF		0x00000400	/* Transmit Control Frame */
+#define RCVDN		0x00000080	/* Receive Done */
+#define RBDRS		0x00000040	/* Receive BD Request at alert level */
+#define RBDRU		0x00000020	/* Rx Buffer Desc Request at zero */
+#define OF		0x00000010	/* Overflow */
+#define LFAL		0x00000008	/* Link Failed */
+#define CARRY		0x00000001	/* statistics counters carry flag */
+#define ISR_RESERVED	0x8000fcf9	/* reserved bit */
+
+#define INT_ISR_TX_MASK	0x0000FC00	/* ISR TX bits mask */
+#define INT_ISR_RX_MASK	0x000000F0	/* ISR RX bits mask */
+
+/*---------------------------------------------------------------------------*/
+/* Transmit/Receive Status bit definition in Transmit/Receive Descriptor     */
+/*---------------------------------------------------------------------------*/
+#define LAST		0x8000		/* Last Descriptor */
+#define DB_LP		0x4000		/* Data Buffer / Link Pointer */
+#define OWN		0x2000		/* Owner 1:used by candy, 0:host set */
+
+/*---------------------------------------------------------------------------*/
+/* Transmit Status bit definition in Transmit Descriptor                     */
+/*---------------------------------------------------------------------------*/
+#define DBRE		0x1000		/* Data Buffer Read Error */
+#define TUDR		0x0800		/* Transmit Underrun Error */
+#define CSE		0x0400		/* Carrier Sense Lost Error */
+#define LCOL		0x0200		/* Late Collision */
+#define ECOL		0x0100		/* Excessive Collision */
+#define EDFR		0x0080		/* Excessive Deferral */
+#define TGNT		0x0004		/* Transmit Giant Frame */
+#define TOK		0x0001		/* Transmit OK */
+
+/*---------------------------------------------------------------------------*/
+/* Receive Status bit definition in Receive Descriptor                       */
+/*---------------------------------------------------------------------------*/
+#define DBWE		0x1000		/* Data Buffer Write Error */
+#define FTYP_MASK	0x0e00		/* Frame Type */
+#define BCASTF		0x0000		/* Broadcast Frame */
+#define MCASTF		0x0200		/* Multicast Frame */
+#define UCASTF		0x0400		/* Unicast Frame */
+#define VLANF		0x0600		/* VLAN Frame */
+#define PAUSEF		0x0800		/* PAUSE control Frame */
+#define CTLF		0x0a00		/* Control Frame */
+#define OVRN		0x0100		/* Overrun Error */
+#define RUNT		0x0080		/* Runt packet */
+#define FRGE		0x0040		/* Fragment Error */
+#define RCV		0x0020		/* Detects RXER */
+#define FC		0x0010		/* False Carrier */
+#define CRCE		0x0008		/* CRC Error */
+#define FAE		0x0004		/* Frame Alignment Error */
+#define RFLE		0x0002		/* Receive Frame Length Error */
+#define RXOK		0x0001		/* Receive OK */
+
+#if defined(CONFIG_NEC_CMBVR4133) || defined(EMMA3P)
+#define CANDY_REGS_VER	2		/* version 2 */
+#else
+#define CANDY_REGS_VER	1		/* version 1 */
+#endif
+
+#define CANDY_REGS_SIZE	(0x3ff + 1)
+
+/***********************************************************************
+ * data structure
+ ***********************************************************************/
+typedef volatile struct {
+	ulong macc1;		/* 0x00  MAC configuration register 1 */
+	ulong macc2;		/* 0x04  MAC configuration register 2 */
+	ulong ipgt;		/* 0x08  Back-to-Back IPG register */
+	ulong ipgr;		/* 0x0c  Non Back-to-Back IPG register */
+	ulong clrt;		/* 0x10  Collision register */
+	ulong lmax;		/* 0x14  Max packet length register */
+	ulong reserved0[15];
+	ulong lsa2;		/* 0x54  Station Address register 2 */
+	ulong lsa1;		/* 0x58  Station Address register 1 */
+	ulong ptvr;		/* 0x5c  Pause timer value read register */
+	ulong reserved2[1];
+	ulong vltp;		/* 0x64  VLAN type register */
+	ulong reserved3[6];
+	ulong miic;		/* 0x80  MII configuration register */
+	ulong reserved4[4];
+	ulong mcmd;		/* 0x94  MII command register */
+	ulong madr;		/* 0x98  MII address register */
+	ulong mwtd;		/* 0x9c  MII write data register */
+	ulong mrdd;		/* 0xa0  MII read data register */
+	ulong mind;		/* 0xa4  MII indicator register */
+	ulong reserved5[8];
+	ulong afr;		/* 0xc8  Address filter register */
+	ulong ht1;		/* 0xcc  Hash table register 1 */
+	ulong ht2;		/* 0xd0  Hash table register 2 */
+	ulong reserved7[2];
+	ulong car1;		/* 0xdc  Carry register 1 */
+	ulong car2;		/* 0xe0  Carry register 2 */
+	ulong reserved8[19];
+	ulong cam1;		/* 0x130 Carry mask register 1 */
+	ulong cam2;		/* 0x134 Carry mask register 2 */
+	ulong reserved9[2];
+
+	/* RX Statistics Counters */
+	ulong rbyt;		/* 0x140 Rx Byte Counter */
+	ulong rpkt;		/* 0x144 Rx Pkt Counter */
+	ulong rfcs;		/* 0x148 Rx FCS Error Counter */
+	ulong rmca;		/* 0x14c Rx Multicast Pkt Counter */
+	ulong rbca;		/* 0x150 Rx Broadcast Pkt Counter */
+	ulong rxcf;		/* 0x154 Rx Control Frame Pkt Counter */
+	ulong rxpf;		/* 0x158 Rx PAUSE Frame Pkt Counter */
+	ulong rxuo;		/* 0x15c Rx Unknown OP code Counter */
+	ulong raln;		/* 0x160 Rx Alignment Error Counter */
+	ulong rflr;		/* 0x164 Rx Frame Length Out of Range Counter */
+	ulong rcde;		/* 0x168 Rx Code Error Counter */
+	ulong rfcr;		/* 0x16c Rx False Carrier Counter */
+	ulong rund;		/* 0x170 Rx Undersize Pkt Counter */
+	ulong rovr;		/* 0x174 Rx Oversize Pkt Counter */
+	ulong rfrg;		/* 0x178 Rx Error Undersize Pkt Counter */
+	ulong rjbr;		/* 0x17c Rx Error Oversize Pkt Counter */
+	ulong r64;		/* 0x180 Rx 64 Byte Frame Counter */
+	ulong r127;		/* 0x184 Rx 65 to 127 Byte Frame Counter */
+	ulong r255;		/* 0x188 Rx 128 to 255 Byte Frame Counter */
+	ulong r511;		/* 0x18c Rx 256 to 511 Byte Frame Counter */
+	ulong r1k;		/* 0x190 Rx 512 to 1023 Byte Frame Counter */
+	ulong rmax;		/* 0x194 Rx Over 1023 Byte Frame Counter */
+	ulong rvbt;		/* 0x198 Rx Valid Byte Counter */
+	ulong reserved10[9];
+
+	/* Tx Statistics Counter */
+	ulong tbyt;		/* 0x1c0 Tx Byte Counter */
+	ulong tpct;		/* 0x1c4 Tx Pkt Counter */
+	ulong tfcs;		/* 0x1c8 Tx CRC Error Pkt Counter */
+	ulong tmca;		/* 0x1cc Tx Multicast Pkt Counter */
+	ulong tbca;		/* 0x1d0 Tx Broadcast Pkt Counter */
+	ulong tuca;		/* 0x1d4 Tx Unicast Pkt Counter */
+	ulong txpf;		/* 0x1d8 Tx PAUSE control Frame Counter */
+	ulong tdfr;		/* 0x1dc Tx Single Deferral Pkt Counter */
+	ulong txdf;		/* 0x1e0 Tx Excessive Deferral Pkt Counter */
+	ulong tscl;		/* 0x1e4 Tx Single Collision Pkt Counter */
+	ulong tmcl;		/* 0x1e8 Tx Multiple Collision Pkt Counter */
+	ulong tlcl;		/* 0x1ec Tx Late Collision Pkt Counter */
+	ulong txcl;		/* 0x1f0 Tx Excessive Collision Pkt Counter */
+	ulong tncl;		/* 0x1f4 Tx Total Collision Counter */
+	ulong tcse;		/* 0x1f8 Tx Carrier Sense Error Counter */
+	ulong time;		/* 0x1fc Tx Internal MAC Error Counter */
+
+	/*-------------------------------------------------------------------*/
+	/* Candy DMA and FIFO Management registers                           */
+	/*-------------------------------------------------------------------*/
+	ulong txcfg;		/* 0x200 Transmit Configuration */
+	ulong txfc;		/* 0x204 Transmit FIFO Control  */
+	ulong reserved11[3];
+	ulong txdp;		/* 0x214 Transmit Descriptor Pointer */
+	ulong rxcfg;		/* 0x218 Receive Configuration */
+	ulong rxfc;		/* 0x21c Receive FIFO Control  */
+	ulong reserved12[3];
+	ulong rxdp;		/* 0x22c Receive Descriptor Pointer */
+	ulong rxpd;		/* 0x230 Receive Pool Descriptor */
+
+	/*-------------------------------------------------------------------*/
+	/* Candy Interrupt and Configuration registers                       */
+	/*-------------------------------------------------------------------*/
+	ulong ccr;		/* 0x234 CANDY Config Read/Write register */
+	ulong isr;		/* 0x238 Interrupt Status register */
+	ulong msr;		/* 0x23c Mask Interuupt register */
+#ifdef VR4133A
+	/* These regs are valid for VR4133A or later */
+	ulong reserved13[8];
+	ulong mode;		/* 0x260 Mode register */
+	ulong reserved14[6];
+	ulong rersel;		/* 0x278 Receive Error Select */
+	ulong rercnt;		/* 0x27c Receive Error Counter */
+	ulong reserved15[8];
+	ulong erev;		/* 0x29c Ethernet Block Revision */
+#endif
+} candy_regs;
+
+/*
+ * descriptor structure
+ */
+struct candy_desc {
+#if defined(__LITTLE_ENDIAN)
+	ushort size;
+	ushort status;
+#elif defined(__BIG_ENDIAN)
+	ushort status;
+	ushort size;
+#else
+#error "No endian format defined!"
+#endif
+	ulong pointer;
+};
+
+/*
+ * private data structure for candy driver.
+ */
+struct candy_private {
+	struct candy_desc *tx_ring;
+	struct sk_buff *tx_skb[TX_RING_SIZE];
+
+	struct candy_desc *rx_ring;
+	struct sk_buff *rx_skb[RX_RING_SIZE];
+	int rx_disable;
+
+	uint rx_head;
+	uint tx_head, tx_stop, tx_tail;
+	int tx_count;
+
+	struct net_device_stats stats;
+
+	u32 msg_enable;
+
+	spinlock_t lock;
+	spinlock_t rxlock;
+
+	struct mii_if_info mii_if;
+
+	/* MII status */
+	struct link_status {
+		uint fullduplex:1;
+		uint speed100:1;
+		uint linkOK:1;
+	} link_status;
+
+	struct timer_list phy_timer;
+
+	/* hardware related */
+	candy_regs *regs;
+
+	/* house keeping */
+	struct net_device *ndev;
+#ifdef CONFIG_CANDY_NAPI
+	struct napi_struct napi;
+#endif
+	struct device *dev;
+	struct candy_private *next;
+};
+
+#endif
diff --git a/include/linux/nec_candy_pd.h b/include/linux/nec_candy_pd.h
new file mode 100644
index 0000000..22e23d9
--- /dev/null
+++ b/include/linux/nec_candy_pd.h
@@ -0,0 +1,23 @@
+/*
+ * include/linux/nec_candy_pd.h
+ *
+ * Platform data for the NEC Candy Ethernet device.
+ *
+ * Author: Wade Farnsworth <wfarnsworth@mvista.com>
+ *
+ * 2006 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#ifndef NEC_CANDY_PD_H
+#define NEC_CANDY_PD_H
+
+struct nec_candy_platform_data {
+	unsigned char mac_addr[6];
+	unsigned long pmd_addr;
+	int rmii;	/* 0:MII, 1:RMII */
+};
+
+#endif
-- 
1.5.5.1

