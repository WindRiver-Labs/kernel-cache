From 9ab9c27bfd15c9f83e38afbafb64c015252b622d Mon Sep 17 00:00:00 2001
From: Chunbo Luo <chunbo.luo@windriver.com>
Date: Thu, 11 Sep 2008 15:35:01 +0800
Subject: [PATCH] nec_emma3p: serial 8250 fixup

Add iotype UPIO_EMMA3P to fix serial8250_interrupt()
for nec_emma3p.

Signed-off-by: Chunbo Luo <chunbo.luo@windriver.com>
---
 arch/mips/emma3p/et10068/setup.c |    2 +-
 drivers/serial/8250.c            |   13 +++++++++++++
 drivers/serial/8250_kgdb.c       |    7 +++++--
 drivers/serial/serial_core.c     |    2 ++
 include/linux/serial_core.h      |    1 +
 5 files changed, 22 insertions(+), 3 deletions(-)

diff --git a/arch/mips/emma3p/et10068/setup.c b/arch/mips/emma3p/et10068/setup.c
index bffbc5c..60aed37 100644
--- a/arch/mips/emma3p/et10068/setup.c
+++ b/arch/mips/emma3p/et10068/setup.c
@@ -121,7 +121,7 @@ static void inline __init et10068_sio_setup(void)
 	memset(&emma_port, 0, sizeof(emma_port));
 
 	emma_port.flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST;
-	emma_port.iotype = UPIO_MEM;
+	emma_port.iotype = UPIO_EMMA3P;
 	emma_port.regshift = 2;	/* I/O addresses are every 8 bytes */
 	emma_port.uartclk = 24000000;	/* Clock rate of the chip */
 
diff --git a/drivers/serial/8250.c b/drivers/serial/8250.c
index ddb6bcd..23da54e 100644
--- a/drivers/serial/8250.c
+++ b/drivers/serial/8250.c
@@ -360,6 +360,7 @@ static unsigned int serial_in(struct uart_8250_port *up, int offset)
 
 	case UPIO_MEM:
 	case UPIO_DWAPB:
+	case UPIO_EMMA3P:
 		return readb(up->port.membase + offset);
 
 	case UPIO_RM9000:
@@ -397,6 +398,7 @@ serial_out(struct uart_8250_port *up, int offset, int value)
 		break;
 
 	case UPIO_MEM:
+	case UPIO_EMMA3P:
 		writeb(value, up->port.membase + offset);
 		break;
 
@@ -442,6 +444,7 @@ serial_out_sync(struct uart_8250_port *up, int offset, int value)
 	case UPIO_AU:
 #endif
 	case UPIO_DWAPB:
+	case UPIO_EMMA3P:
 		serial_out(up, offset, value);
 		serial_in(up, UART_LCR);	/* safe, no side-effects */
 		break;
@@ -1496,6 +1499,14 @@ static irqreturn_t serial8250_interrupt(int irq, void *dev_id)
 			handled = 1;
 
 			end = NULL;
+		} else if (up->port.iotype == UPIO_EMMA3P &&
+			  (iir & UART_IIR_BUSY) == UART_IIR_BUSY) {
+			/* Dummy Read for EMMA UART BUSY */
+			serial_in(up,31);
+
+			handled = 1;
+
+			end = NULL;
 		} else if (end == NULL)
 			end = l;
 
@@ -2304,6 +2315,7 @@ static int serial8250_request_std_resource(struct uart_8250_port *up)
 	case UPIO_MEM32:
 	case UPIO_MEM:
 	case UPIO_DWAPB:
+	case UPIO_EMMA3P:
 		if (!up->port.mapbase)
 			break;
 
@@ -2343,6 +2355,7 @@ static void serial8250_release_std_resource(struct uart_8250_port *up)
 	case UPIO_MEM32:
 	case UPIO_MEM:
 	case UPIO_DWAPB:
+	case UPIO_EMMA3P:
 		if (!up->port.mapbase)
 			break;
 
diff --git a/drivers/serial/8250_kgdb.c b/drivers/serial/8250_kgdb.c
index 84d8d33..b9399af 100644
--- a/drivers/serial/8250_kgdb.c
+++ b/drivers/serial/8250_kgdb.c
@@ -331,6 +331,7 @@ static int kgdb8250_early_init(void)
 	/* Internal driver setup. */
 	switch (kgdb8250_port.iotype) {
 	case UPIO_MEM:
+	case UPIO_EMMA3P:
 		kgdb8250_needs_request_mem_region = 0;
 		if (kgdb8250_port.mapbase)
 			kgdb8250_needs_request_mem_region = 1;
@@ -383,7 +384,8 @@ static int kgdb8250_late_init(void)
 	kgdb8250_uart_init();
 
 	/* Request memory/io regions that we use. */
-	if (kgdb8250_port.iotype == UPIO_MEM) {
+	if (kgdb8250_port.iotype == UPIO_MEM || 
+	    kgdb8250_port.iotype == UPIO_EMMA3P) {
 		if (kgdb8250_needs_request_mem_region &&
 			!request_mem_region(kgdb8250_port.mapbase,
 					8 << kgdb8250_port.regshift, "kgdb"))
@@ -445,7 +447,8 @@ static void kgdb8250_cleanup(void)
 
 	fully_initialized = 0;
 
-	if (kgdb8250_port.iotype == UPIO_MEM) {
+	if (kgdb8250_port.iotype == UPIO_MEM ||
+	    kgdb8250_port.iotype == UPIO_EMMA3P) {
 		if (kgdb8250_port.flags & UPF_IOREMAP)
 			iounmap(kgdb8250_port.membase);
 		if (kgdb8250_needs_request_mem_region)
diff --git a/drivers/serial/serial_core.c b/drivers/serial/serial_core.c
index 73e9b8f..2355dd9 100644
--- a/drivers/serial/serial_core.c
+++ b/drivers/serial/serial_core.c
@@ -2166,6 +2166,7 @@ uart_report_port(struct uart_driver *drv, struct uart_port *port)
 	case UPIO_AU:
 	case UPIO_TSI:
 	case UPIO_DWAPB:
+	case UPIO_EMMA3P:
 		if (port->mapbase == 0)
 			snprintf(address, sizeof(address),
 			 "MMIO 0x%llx membase %p",
@@ -2586,6 +2587,7 @@ int uart_match_port(struct uart_port *port1, struct uart_port *port2)
 	case UPIO_AU:
 	case UPIO_TSI:
 	case UPIO_DWAPB:
+	case UPIO_EMMA3P:
 		if (port1->mapbase == 0 && port2->mapbase == 0)
 			return (port1->membase == port2->membase);
 		return (port1->mapbase == port2->mapbase);
diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 3b2f6c0..3b2b100 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -259,6 +259,7 @@ struct uart_port {
 #define UPIO_TSI		(5)			/* Tsi108/109 type IO */
 #define UPIO_DWAPB		(6)			/* DesignWare APB UART */
 #define UPIO_RM9000		(7)			/* RM9000 type IO */
+#define UPIO_EMMA3P		(8)			/* NEC EMMA3P UART */
 
 	unsigned int		read_status_mask;	/* driver specific */
 	unsigned int		ignore_status_mask;	/* driver specific */
-- 
1.5.5.1

