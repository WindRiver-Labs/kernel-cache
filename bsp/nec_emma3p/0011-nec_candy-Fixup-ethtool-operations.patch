From 51cc9f951d0b51bfcd4720e4d239b57037908fd3 Mon Sep 17 00:00:00 2001
From: Lans Zhang <jia.zhang@windriver.com>
Date: Fri, 9 Oct 2009 10:19:54 +0800
Subject: [PATCH] nec_candy: Fixup ethtool operations

Ethtool now requires its own ->ethtool_ops to be set up properly.
Also, this patch converts an obsolete ioctl-based ethtool hook
into the recent ethtool_ops based one. Some operations are simply
converted, and some are replaced with generic ethtool_op_* routines
provided by net/core/ethtool.c. Resulting operations available are
as well or better than before.

Signed-off-by: Shinya Kuribayashi <shinya.kuribayashi@necel.com>
[Lans: make mirror changes fitting for 3.0 kernel]
Signed-off-by: Lans Zhang <jia.zhang@windriver.com>
---
 drivers/net/nec_candy.c |  232 ++++++++++++++---------------------------------
 1 files changed, 68 insertions(+), 164 deletions(-)

diff --git a/drivers/net/nec_candy.c b/drivers/net/nec_candy.c
index 797ac4f..6708e43 100644
--- a/drivers/net/nec_candy.c
+++ b/drivers/net/nec_candy.c
@@ -248,178 +248,84 @@ candy_set_media_speed(struct net_device *dev)
 }
 
 static int
-candy_ethtool_ioctl(struct candy_private *pp, void *useraddr)
+candy_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 {
-	u32 ethcmd;
-
-	/* dev_ioctl() in ../../net/core/dev.c has already checked
-	   capable(CAP_NET_ADMIN), so don't bother with that here.  */
-
-	if (get_user(ethcmd, (u32 *) useraddr))
-		return -EFAULT;
-
-	switch (ethcmd) {
-
-	case ETHTOOL_GDRVINFO:{
-			struct ethtool_drvinfo info = { ETHTOOL_GDRVINFO };
-			strcpy(info.driver, DRV_NAME);
-			strcpy(info.version, DRV_VERSION);
-			strcpy(info.bus_info, "");
-			info.regdump_len = CANDY_REGS_SIZE;
-			info.n_stats = 0;
-			if (copy_to_user(useraddr, &info, sizeof(info)))
-				return -EFAULT;
-			return 0;
-		}
-		/* get settings */
-	case ETHTOOL_GSET:{
-			struct ethtool_cmd ecmd = { ETHTOOL_GSET };
-			spin_lock_irq(&pp->lock);
-			mii_ethtool_gset(&pp->mii_if, &ecmd);
-			spin_unlock_irq(&pp->lock);
-			if (copy_to_user(useraddr, &ecmd, sizeof(ecmd)))
-				return -EFAULT;
-			return 0;
-		}
-		/* set settings */
-	case ETHTOOL_SSET:{
-			int r;
-			struct ethtool_cmd ecmd;
-			if (copy_from_user(&ecmd, useraddr, sizeof(ecmd)))
-				return -EFAULT;
-			spin_lock_irq(&pp->lock);
-			r = mii_ethtool_sset(&pp->mii_if, &ecmd);
-			spin_unlock_irq(&pp->lock);
-			return r;
-		}
-		/* restart autonegotiation */
-	case ETHTOOL_NWAY_RST:{
-			return mii_nway_restart(&pp->mii_if);
-		}
-		/* get link status */
-	case ETHTOOL_GLINK:{
-			struct ethtool_value edata = { ETHTOOL_GLINK };
-			edata.data = mii_link_ok(&pp->mii_if);
-			if (copy_to_user(useraddr, &edata, sizeof(edata)))
-				return -EFAULT;
-			return 0;
-		}
-
-		/* get message-level */
-	case ETHTOOL_GMSGLVL:{
-			struct ethtool_value edata = { ETHTOOL_GMSGLVL };
-			edata.data = pp->msg_enable;
-			if (copy_to_user(useraddr, &edata, sizeof(edata)))
-				return -EFAULT;
-			return 0;
-		}
-		/* set message-level */
-	case ETHTOOL_SMSGLVL:{
-			struct ethtool_value edata;
-			if (copy_from_user(&edata, useraddr, sizeof(edata)))
-				return -EFAULT;
-			pp->msg_enable = edata.data;
-			return 0;
-		}
-
-		/* register's dump */
-	case ETHTOOL_GREGS:{
-			struct ethtool_regs regs;
-			u8 *regbuf = kmalloc(CANDY_REGS_SIZE, GFP_KERNEL);
-			int rc;
-
-			if (!regbuf)
-				return -ENOMEM;
-			memset(regbuf, 0, CANDY_REGS_SIZE);
-
-			rc = copy_from_user(&regs, useraddr, sizeof(regs));
-			if (rc) {
-				rc = -EFAULT;
-				goto err_out_gregs;
-			}
-
-			if (regs.len > CANDY_REGS_SIZE)
-				regs.len = CANDY_REGS_SIZE;
-			if (regs.len < CANDY_REGS_SIZE) {
-				rc = -EINVAL;
-				goto err_out_gregs;
-			}
-
-			regs.version = CANDY_REGS_VER;
-			rc = copy_to_user(useraddr, &regs, sizeof(regs));
-			if (rc) {
-				rc = -EFAULT;
-				goto err_out_gregs;
-			}
-
-			useraddr += offsetof(struct ethtool_regs, data);
-
-			spin_lock_irq(&pp->lock);
-			memcpy_fromio(regbuf, pp->regs, CANDY_REGS_SIZE);
-			spin_unlock_irq(&pp->lock);
-
-			if (copy_to_user(useraddr, regbuf, regs.len))
-				rc = -EFAULT;
-
-		      err_out_gregs:
-			kfree(regbuf);
-			return rc;
-		}
-
-		/* get/set TX checksumming */
-	case ETHTOOL_GTXCSUM:{
-			struct ethtool_value edata = { ETHTOOL_GTXCSUM };
-
-			edata.data = (pp->ndev->features &
-				      NETIF_F_IP_CSUM) != 0;
-			if (copy_to_user(useraddr, &edata, sizeof(edata)))
-				return -EFAULT;
-			return 0;
-		}
-	case ETHTOOL_STXCSUM:{
-			struct ethtool_value edata;
-
-			if (copy_from_user(&edata, useraddr, sizeof(edata)))
-				return -EFAULT;
-
-			if (edata.data)
-				pp->ndev->features |= NETIF_F_IP_CSUM;
-			else
-				pp->ndev->features &= ~NETIF_F_IP_CSUM;
+	struct candy_private *pp = netdev_priv(dev);
+	spin_lock_irq(&pp->lock);
+	mii_ethtool_gset(&pp->mii_if, cmd);
+	spin_unlock_irq(&pp->lock);
+	return 0;
+}
 
-			return 0;
-		}
+static int
+candy_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct candy_private *pp = netdev_priv(dev);
+	int r;
+	spin_lock_irq(&pp->lock);
+	r = mii_ethtool_sset(&pp->mii_if, cmd);
+	spin_unlock_irq(&pp->lock);
+	return r;
+}
 
-		/* get/set scatter-gather */
-	case ETHTOOL_GSG:{
-			struct ethtool_value edata = { ETHTOOL_GSG };
+static void
+candy_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
+{
+	strcpy(info->driver, DRV_NAME);
+	strcpy(info->version, DRV_VERSION);
+	strcpy(info->fw_version, "N/A");
+	strcpy(info->bus_info, dev_name(&dev->dev));
+}
 
-			edata.data = (pp->ndev->features & NETIF_F_SG) != 0;
-			if (copy_to_user(useraddr, &edata, sizeof(edata)))
-				return -EFAULT;
-			return 0;
-		}
-	case ETHTOOL_SSG:{
-			struct ethtool_value edata;
+static int
+candy_get_regs_len(struct net_device *dev)
+{
+	return CANDY_REGS_SIZE;
+}
 
-			if (copy_from_user(&edata, useraddr, sizeof(edata)))
-				return -EFAULT;
+static void
+candy_get_regs(struct net_device *dev, struct ethtool_regs *regs, void *buf)
+{
+	struct candy_private *pp = netdev_priv(dev);
 
-			if (edata.data)
-				pp->ndev->features |= NETIF_F_SG;
-			else
-				pp->ndev->features &= ~NETIF_F_SG;
+	spin_lock_irq(&pp->lock);
+	memcpy_fromio(buf, pp->regs, regs->len);
+	spin_unlock_irq(&pp->lock);
+}
 
-			return 0;
-		}
+static u32
+candy_get_msglevel(struct net_device *dev)
+{
+	struct candy_private *pp = netdev_priv(dev);
+	return pp->msg_enable;
+}
 
-	default:
-		break;
-	}
+static void
+candy_set_msglevel(struct net_device *dev, u32 level)
+{
+	struct candy_private *pp = netdev_priv(dev);
+	pp->msg_enable = level;
+}
 
-	return -EOPNOTSUPP;
+static int
+candy_nway_reset(struct net_device *dev)
+{
+	struct candy_private *pp = netdev_priv(dev);
+	return mii_nway_restart(&pp->mii_if);
 }
 
+static const struct ethtool_ops candy_ethtool_ops = {
+	.get_settings		= candy_get_settings,
+	.set_settings		= candy_set_settings,
+	.get_drvinfo		= candy_get_drvinfo,
+	.get_regs_len		= candy_get_regs_len,
+	.get_regs		= candy_get_regs,
+	.get_msglevel		= candy_get_msglevel,
+	.set_msglevel		= candy_set_msglevel,
+	.nway_reset		= candy_nway_reset,
+	.get_link		= ethtool_op_get_link,
+};
+
 static int
 candy_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 {
@@ -427,9 +333,6 @@ candy_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 	struct mii_ioctl_data *mii = (struct mii_ioctl_data *) &rq->ifr_data;
 	int rc;
 
-	if (cmd == SIOCETHTOOL)
-		return candy_ethtool_ioctl(pp, (void *) rq->ifr_data);
-
 	spin_lock_irq(&pp->lock);
 	rc = generic_mii_ioctl(&pp->mii_if, mii, cmd, NULL);
 	spin_unlock_irq(&pp->lock);
@@ -1748,6 +1651,7 @@ static int nec_candy_probe(struct device *dev)
 	ndev->open = candy_open;
 	ndev->stop = candy_close;
 	ndev->do_ioctl = candy_ioctl;
+	ndev->ethtool_ops = &candy_ethtool_ops;
 	ndev->hard_start_xmit = candy_xmit;
 	ndev->get_stats = candy_get_stats;
 	ndev->set_multicast_list = candy_set_rx_mode;
-- 
1.6.3.3

