From 4e4f75a22e61db3746261a68c39bf0c390f9a2b6 Mon Sep 17 00:00:00 2001
From: Chunbo Luo <chunbo.luo@windriver.com>
Date: Thu, 11 Sep 2008 15:35:03 +0800
Subject: [PATCH] nec_emma3p: nand driver

Add nand driver for nec_emma3p

Signed-off-by: Jack Tan <jack.tan@windriver.com>
Signed-off-by: Chunbo Luo <chunbo.luo@windriver.com>
---
 drivers/mtd/nand/Kconfig        |    7 +
 drivers/mtd/nand/Makefile       |    1 +
 drivers/mtd/nand/nand_et10068.c | 1223 +++++++++++++++++++++++++++++++++++++++
 3 files changed, 1231 insertions(+), 0 deletions(-)
 create mode 100644 drivers/mtd/nand/nand_et10068.c

diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
index ed1a331..fa62ab4 100644
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -425,4 +425,11 @@ config MTD_NAND_FSL_UPM
 	  Enables support for NAND Flash chips wired onto Freescale PowerPC
 	  processor localbus with User-Programmable Machine support.
 
+config MTD_NAND_ET10068
+	tristate "NAND Flash device on NEC Electronics ET10068 board"
+	depends on ET10068 && MTD_NAND
+	help
+	   This enables the driver for the NAND flash controller on the
+	   NEC Electronics ET10068 board.
+
 endif # MTD_NAND
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index ba42584..2fe117a 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -37,5 +37,6 @@ obj-$(CONFIG_MTD_NAND_PASEMI)		+= pasemi_nand.o
 obj-$(CONFIG_MTD_NAND_ORION)		+= orion_nand.o
 obj-$(CONFIG_MTD_NAND_FSL_ELBC)		+= fsl_elbc_nand.o
 obj-$(CONFIG_MTD_NAND_FSL_UPM)		+= fsl_upm.o
+obj-$(CONFIG_MTD_NAND_ET10068)		+= nand_et10068.o
 
 nand-objs := nand_base.o nand_bbt.o
diff --git a/drivers/mtd/nand/nand_et10068.c b/drivers/mtd/nand/nand_et10068.c
new file mode 100644
index 0000000..0d13dcf
--- /dev/null
+++ b/drivers/mtd/nand/nand_et10068.c
@@ -0,0 +1,1223 @@
+/*
+ *  drivers/mtd/nand/nand_et10068.c
+ *
+ *  Copyright (C) 2006-2007 NEC Electronics Corporation
+ *  Copyright (C) 2004 NEC Micro Systems, Ltd.
+ *
+ *  Derived from drivers/mtd/nand/edb7312.c
+ *       Copyright (C) 2002 Marius Groeger (mag@sysgo.de)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Overview:
+ *   This is a device driver for the NAND flash device "TC58DVM92A1FT00"
+ *   found on the ET10068 board which utilizes the NEC EMMA3P part.
+ *
+ *  Changes:
+ *		Wind River Systems, Inc.
+ *		- Ported to Linux 2.6.21 by Jack Tan <jack.tan@windriver.com>
+ *
+ */
+
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <linux/proc_fs.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/emma3p/emma3p.h>
+#include <asm/emma3p/et10068.h>
+
+#include <asm/cacheflush.h>
+
+#ifndef _NAND_H_
+#define _NAND_H_
+
+#define NAND_LSP
+#define NAND_PAGE_OOB_SIZE      (16)
+#define NAND_PAGE_DATA_SIZE     (512)
+#define NAND_PAGE_SIZE          (NAND_PAGE_DATA_SIZE + NAND_PAGE_OOB_SIZE)
+
+/*
+ * Values specific to the ET10068 board
+ */
+#define SZ_1K				(1024)
+#define SZ_1M				(SZ_1K * SZ_1K)
+#define DEFAULT_NAND_SIZE		(64 * SZ_1M)
+#define BROI_MAX_SIZE			(64 * SZ_1M)
+
+#define BROI_BASE			(0xb0000400)
+#define NAND_ROM_MODE			(BROI_BASE + 0x000)
+#define NAND_ROM_ACCESS_TIME		(BROI_BASE + 0x004)
+#define NAND_ROMIF_MODE			(BROI_BASE + 0x008)
+#define NAND_ROM_COMMAND		(BROI_BASE + 0x010)
+#define NAND_ROM_ADDR			(BROI_BASE + 0x014)
+#define NAND_ROM_STATUS			(BROI_BASE + 0x020)
+
+#ifndef NAND_LSP
+#define NAND_ROM_SEQ_STATUS		(BROI_BASE + 0x024)
+#define NAND_ROM_INTERRUPT		(BROI_BASE + 0x028)
+#define NAND_ROM_INTERRUPT_ENABLE	(BROI_BASE + 0x02c)
+#define NAND_ROM_CONTROL3		(BROI_BASE + 0x030)
+#define NAND_ROM_CONTROL6		(BROI_BASE + 0x03c)
+#define NAND_ROM_ECC_RESULT		(BROI_BASE + 0x070)
+#define NAND_ROM_SPARE_DATA		(BROI_BASE + 0x170)
+#define NAND_ROM_PROGRAM_STATUS		(BROI_BASE + 0x1B0)
+
+#define XDMA_BASE			(0xb0009000)
+#define DMAC_LIST_ENABLE		(XDMA_BASE + 0x088)
+#define DMAC_MEM_0_LIST0		(XDMA_BASE + 0x100)
+#define DMAC_MEM_0_LIST1		(XDMA_BASE + 0x104)
+#define DMAC_MEM_0_LIST2		(XDMA_BASE + 0x108)
+#define DMAC_MEM_0_LIST3		(XDMA_BASE + 0x10c)
+#define DMAC_MEM_0_LIST4		(XDMA_BASE + 0x110)
+#define DMAC_MAIN_INT2			(XDMA_BASE + 0x508)
+
+#define	DMAINTRST			0x00000000
+#define	DMANOLST			0x00000000
+#define	DMALSTDONE0			0x00000001
+#define	DMA_MM_ENABLE0			0x1
+#define	PHYSICALMEMMSK			0x1fffffff
+#endif /* ifndef NAND_LSP */
+
+#define NAND_ET10068_BUSY		(0x00000001)
+
+#define NAND_CMD0_SHIFT			(16)
+#define NAND_CMD1_SHIFT			(24)
+
+
+#endif
+
+static unsigned long cache_buf[NAND_PAGE_SIZE / sizeof(long)];
+
+static void *et10068_fio_base;
+
+/*
+ * MTD structure for ET10068 board
+ */
+static struct mtd_info *et10068_mtd = NULL;
+
+/*
+ * Debug print
+ */
+#define ENTER() DPRINTK( 4, "%s: entered\n", __FUNCTION__ )
+#define LEAVE() DPRINTK( 4, "%s: leaving Line:%d\n", __FUNCTION__, __LINE__ )
+
+#undef DEBUG
+#define DEBUG
+#ifdef DEBUG
+
+#define DPRINTK( level, args... ) if( (level) <= nand_debug) printk(KERN_INFO  args)
+#else
+#define DPRINTK( level, args... )
+#endif				/* DEBUG */
+
+static int nand_debug = 0;
+
+/*
+ * Module stuff
+ */
+static int last_command;
+static int last_page_addr;
+static int read_pos;
+static int write_pos;
+static unsigned long next_write_page = 0;
+u32 fio_vbase;
+
+#ifdef CONFIG_MTD_PARTITIONS
+/*
+ * Define static partitions for flash device
+ */
+static struct mtd_partition partition_info[] = {
+	{
+	 .name = "ET10068 Nand Flash",
+	 .offset = 0,
+	 .size = DEFAULT_NAND_SIZE,
+	 }
+};
+
+#define NUM_PARTITIONS 1
+
+#endif
+
+static struct nand_ecclayout et10068_ecclayout = {
+	.eccbytes = 6,
+	.eccpos = {1, 0, 2, 5, 4, 6},
+	.oobfree = {{8, 8}}
+};
+
+#define SET_NAND_ROM( dat ) (*(volatile unsigned long  *)fio_vbase = dat )
+#define GET_NAND_ROM() (*(volatile unsigned long  *)fio_vbase)
+#define NOTALIGNED(x) (x & (mtd->writesize -1)) != 0
+
+static void setcmd(unsigned long x)
+{
+	writel(x, (void *)NAND_ROM_COMMAND);
+}
+
+static void setpage(struct mtd_info *mtd, int page)
+{
+	writel((((page) & 0x00FFFFFF) << 8) | (((page) & 0xFF000000) >> 24),
+		(void *)NAND_ROM_ADDR);
+}
+
+static void wait_ready_busy_bit_on(void)
+{
+	/* ROM Status Register: READY/BUSY bit */
+	while ((readl((void *)NAND_ROM_STATUS) & 0x00000001) == 0) ;
+}
+
+static void wait_command_enable_bit_off(void)
+{
+	/* Nand ROM control Register: COMMAND_ENABLE bit */
+	while ((readl((void *)NAND_ROM_COMMAND) & 0x00000001) == 1) ;
+}
+
+static void wait_status_ok(struct mtd_info *mtd)
+{
+	do {
+		wait_command_enable_bit_off();
+		wait_ready_busy_bit_on();
+		/* status command */
+		writel(0x00700207, (void *)NAND_ROM_COMMAND);
+		DPRINTK(4,
+			"readl((void *)ROM_ADDR)==%#x\n",
+			readl((void *)fio_vbase));
+
+	} while ((readl((void *)fio_vbase) & 0xFF) != 0xe0);
+}
+
+static void et10068_nand_select_chip(struct mtd_info *mtd, int chip)
+{
+	ENTER();
+	LEAVE();
+}
+
+static int et10068_dev_ready(struct mtd_info *mtd)
+{
+	ENTER();
+	wait_ready_busy_bit_on();
+	LEAVE();
+	return readl((void *)NAND_ROM_STATUS) & NAND_ET10068_BUSY ? 1 : 0;
+}
+
+static void et10068_read_cache(struct mtd_info *mtd, unsigned command,
+			       int column, int read_page)
+{
+	int i;
+	struct nand_chip *this = mtd->priv;
+
+	ENTER();
+
+	last_page_addr = read_page;
+
+	wait_status_ok(mtd);
+
+	setpage(mtd, read_page);
+	if (this->chipsize < 0x04000000)
+		/* NAND FLASH ROM SIZE < 64MB */
+		setcmd(0x2057 | (NAND_CMD_READ0 << NAND_CMD0_SHIFT));
+	else
+		/* NAND FLASH ROM SIZE >= 64MB */
+		setcmd(0x3057 | (NAND_CMD_READ0 << NAND_CMD0_SHIFT));
+
+	wait_ready_busy_bit_on();
+
+	switch (command) {
+	case NAND_CMD_READ0:
+		read_pos = 0 + column;
+		break;
+	case NAND_CMD_READ1:
+		read_pos = 256 + column;
+		break;
+	case NAND_CMD_READOOB:
+		read_pos = 512 + column;
+		break;
+	}
+
+	for (i = 0; i < NAND_PAGE_SIZE / sizeof(long); i++) {
+		cache_buf[i] = GET_NAND_ROM();
+	}
+	wait_status_ok(mtd);
+
+	LEAVE();
+}
+
+static u_char et10068_read_byte(struct mtd_info *mtd)
+{
+	struct nand_chip *this = mtd->priv;
+	u_char *buf_c;
+
+	ENTER();
+
+	if ((last_command == NAND_CMD_READ0) || (last_command == NAND_CMD_READ1)
+	    || (last_command == NAND_CMD_READOOB)
+	    || (last_command == NAND_CMD_READID)) {
+		buf_c = (u_char *) cache_buf;
+		LEAVE();
+		return buf_c[read_pos++];
+	} else {
+		unsigned long lng_wk =
+		    *(volatile unsigned long *)this->IO_ADDR_R;
+		LEAVE();
+		return (u_char) (lng_wk >> 24);
+	}
+}
+
+static void et10068_write_byte(struct mtd_info *mtd, u_char byte)
+{
+	struct nand_chip *this = mtd->priv;
+
+	ENTER();
+
+	if (last_command == NAND_CMD_SEQIN) {
+		if (write_pos < 528)
+			memcpy(((u_char *) cache_buf) + write_pos++, &byte, 1);
+	} else
+		*(volatile unsigned long *)(this->IO_ADDR_W) =
+		    (unsigned long)byte;
+
+	LEAVE();
+}
+
+static int get_block_num(struct mtd_info *mtd)
+{
+	int block;
+
+	ENTER();
+
+	switch (mtd->size) {
+	case 2 * SZ_1M:
+		block = (4 * SZ_1K) / 512;
+		break;
+	case 4 * SZ_1M:
+		block = (8 * SZ_1K) / 512;
+		break;
+	case 8 * SZ_1M:
+		block = (16 * SZ_1K) / 512;
+		break;
+	default:
+		block = (16 * SZ_1K) / 512;
+	}
+
+	LEAVE();
+	return block;
+}
+
+/*
+ * Send command to NAND device
+ */
+static void et10068_cmdfunc(struct mtd_info *mtd, unsigned command, int column,
+			    int page_addr)
+{
+	struct nand_chip *this = mtd->priv;
+	int i;
+	
+	ENTER();
+	/*
+	 * Write out the command to the device.
+	 */
+	switch (command) {
+	case NAND_CMD_READ0:
+		DPRINTK(3,
+			"### NAND Command Func :command=%s, column=%d, page_addr=%d\n",
+			"NAND_CMD_READ0   ", column, page_addr);
+		break;
+	case NAND_CMD_READ1:
+		DPRINTK(3,
+			"### NAND Command Func :command=%s, column=%d, page_addr=%d\n",
+			"NAND_CMD_READ1   ", column, page_addr);
+		break;
+	case NAND_CMD_PAGEPROG:
+		DPRINTK(3,
+			"### NAND Command Func :command=%s, column=%d, page_addr=%d\n",
+			"NAND_CMD_PAGEPROG", column, page_addr);
+		break;
+	case NAND_CMD_READOOB:
+		DPRINTK(3,
+			"### NAND Command Func :command=%s, column=%d, page_addr=%d\n",
+			"NAND_CMD_READOOB ", column, page_addr);
+		break;
+	case NAND_CMD_ERASE1:
+		DPRINTK(3,
+			"### NAND Command Func :command=%s, column=%d, page_addr=%d\n",
+			"NAND_CMD_ERASE1  ", column, page_addr);
+		break;
+	case NAND_CMD_STATUS:
+		DPRINTK(3,
+			"### NAND Command Func :command=%s, column=%d, page_addr=%d\n",
+			"NAND_CMD_STATUS  ", column, page_addr);
+		break;
+	case NAND_CMD_SEQIN:
+		DPRINTK(3,
+			"### NAND Command Func :command=%s, column=%d, page_addr=%d\n",
+			"NAND_CMD_SEQIN   ", column, page_addr);
+		break;
+	case NAND_CMD_READID:
+		DPRINTK(3,
+			"### NAND Command Func :command=%s, column=%d, page_addr=%d\n",
+			"NAND_CMD_READID  ", column, page_addr);
+		break;
+	case NAND_CMD_RESET:
+		DPRINTK(3,
+			"### NAND Command Func :command=%s, column=%d, page_addr=%d\n",
+			"NAND_CMD_RESET   ", column, page_addr);
+		break;
+	}
+
+	last_command = command;
+
+	switch (command) {
+	case NAND_CMD_SEQIN:
+		/* 0x80 Col Row1 Row2 Row3 Din0 Din1 ... Din527 0x10  [RY/BY_B] 0x70 */
+		next_write_page = page_addr;
+		if ((column >= 0) && (column < 528))
+			write_pos = column;
+		break;
+	case NAND_CMD_PAGEPROG:
+		wait_status_ok(mtd);
+		wait_command_enable_bit_off();
+		wait_ready_busy_bit_on();
+		setpage(mtd, next_write_page);
+		if (this->chipsize < 0x04000000) {
+			/* NAND FLASH ROM SIZE < 64MB */
+			setcmd(0x2017 |
+			       (NAND_CMD_SEQIN << NAND_CMD0_SHIFT));
+		} else
+			/* NAND FLASH ROM SIZE >= 64MB */
+			setcmd(0x3017 |
+			       (NAND_CMD_SEQIN << NAND_CMD0_SHIFT));
+		for (i = 0; i < (NAND_PAGE_SIZE / sizeof(long)); i++)
+			SET_NAND_ROM(cache_buf[i]);
+
+		wait_command_enable_bit_off();
+		setcmd(0x0205 | (NAND_CMD_PAGEPROG << NAND_CMD0_SHIFT));
+		wait_status_ok(mtd);
+		wait_command_enable_bit_off();
+		wait_ready_busy_bit_on();
+		break;
+	case NAND_CMD_READ0:
+	case NAND_CMD_READ1:
+	case NAND_CMD_READOOB:
+		/* 0x00 Col Row1 Row2 Row3 [RY/BY_B] Dout0 Dout1 ... Dout527 */
+		read_pos = 0;
+		et10068_read_cache(mtd, command, column, page_addr);
+		break;
+	case NAND_CMD_ERASE1:
+		/* 0x60 Row1 Row2 Row3 0xD0 [RY/BY_B] 0x70 */
+		wait_status_ok(mtd);
+		writel(page_addr, (void *)NAND_ROM_ADDR);
+		if (this->chipsize < 0x04000000)
+			/* NAND FLASH ROM SIZE < 64MB */
+			setcmd(0x221D | (NAND_CMD_ERASE1 << NAND_CMD0_SHIFT) |
+		 	      (NAND_CMD_ERASE2 << NAND_CMD1_SHIFT));
+		else
+			/* NAND FLASH ROM SIZE >= 64MB */
+			writel(0xd060221d, (void *)NAND_ROM_COMMAND);
+		wait_status_ok(mtd);
+		wait_command_enable_bit_off();
+		wait_ready_busy_bit_on();
+		setcmd(0x00000000);	/* NAND ROM COMMAND clear */
+		break;
+	case NAND_CMD_ERASE2:
+		/* marge "NAND_CMD_ERASE1:" */
+		break;
+	case NAND_CMD_STATUS:
+		writel(0x00700207, (void *)NAND_ROM_COMMAND);
+		break;
+	case NAND_CMD_READID:
+		read_pos = 0;
+		wait_status_ok(mtd);
+		writel(0x00000000, (void *)NAND_ROM_ADDR);
+		writel(0x00900217, (void *)NAND_ROM_COMMAND);
+		cache_buf[0] = GET_NAND_ROM();
+		setcmd(0x00000000);	/* NAND ROM COMMAND clear */
+		break;
+	case NAND_CMD_RESET:
+		writel(0x0205 | NAND_CMD_RESET << 16, (void *)NAND_ROM_COMMAND);
+		wait_ready_busy_bit_on();
+		writel((readl((void *)NAND_ROM_COMMAND) & 0x0000), (void *)NAND_ROM_COMMAND);
+		break;
+	}
+	LEAVE();
+}
+
+/*
+ *	Get chip for selected access
+ */
+static inline void et10068_nand_get_chip(struct nand_chip *this,
+					 struct mtd_info *mtd, int new_state,
+					 int *erase_state)
+{
+
+	DECLARE_WAITQUEUE(wait, current);
+
+	ENTER();
+	/*
+	 * Grab the lock and see if the device is available
+	 * For erasing, we keep the spinlock until the
+	 * erase command is written.
+	 */
+	while (1) {
+		spin_lock_bh(&this->controller->lock);
+
+		if (this->state == FL_READY) {
+			this->state = new_state;
+			if (new_state != FL_ERASING)
+				spin_unlock_bh(&this->controller->lock);
+
+			LEAVE();
+			break;
+		}
+
+		if (this->state == FL_ERASING) {
+			if (new_state != FL_ERASING) {
+				this->state = new_state;
+				spin_unlock_bh(&this->controller->lock);
+				this->select_chip(mtd, 0);	/* select in any case */
+				this->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
+				LEAVE();
+				break;
+			}
+		}
+
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		add_wait_queue(&this->controller->wq, &wait);
+		spin_unlock_bh(&this->controller->lock);
+		schedule();
+		remove_wait_queue(&this->controller->wq, &wait);
+	}
+}
+
+static void et10068_nand_write_buf(struct mtd_info *mtd, const u_char * buf,
+				   int len)
+{
+	int i;
+
+	ENTER();
+
+	if (write_pos >= 528)
+		write_pos = 0;
+
+	for (i = 0; i < len; i++)
+		et10068_write_byte(mtd, buf[i]);
+	LEAVE();
+}
+
+static void et10068_nand_read_buf(struct mtd_info *mtd, u_char * buf_c, int len)
+{
+	ENTER();
+
+	if (read_pos >= 528) {
+		last_page_addr++;
+		et10068_read_cache(mtd, NAND_CMD_READ0, 0, last_page_addr);
+		read_pos = 0;
+	}
+
+	memcpy(buf_c, (u_char *) cache_buf + read_pos, len);
+	read_pos += len;
+
+	LEAVE();
+}
+
+/*
+ * NAND read with ECC
+ */
+static int et10068_nand_read_ecc(struct mtd_info *mtd, loff_t from, size_t len,
+				 size_t * retlen, u_char * buf,
+				 u_char * oob_buf, struct nand_ecclayout *oobsel)
+{
+	int j, col, page, end;
+	int erase_state = 0;
+	int read = 0, oob = 0, ecc_status = 0, ecc_failed = 0;
+	struct nand_chip *this = mtd->priv;
+	u_char *data_poi, *oob_data = oob_buf;
+	u_char ecc_calc[6];
+	u_char ecc_code[6];
+	int eccmode;
+	int *oob_config;
+	static unsigned long lastwhinge = 0;
+
+	ENTER();
+
+	/* use chip default if zero */
+	if (oobsel == NULL)
+		oobsel = mtd->ecclayout;
+
+	eccmode = NAND_ECC_SOFT;
+	oob_config = oobsel->eccpos;
+
+	/* Do not allow reads past end of device */
+	if ((from + len) > mtd->size) {
+		DPRINTK(2,
+			"nand_read_ecc: Attempt read beyond end of device\n");
+		*retlen = 0;
+		return -EINVAL;
+	}
+
+	/* Grab the lock and see if the device is available */
+	et10068_nand_get_chip(this, mtd, FL_READING, &erase_state);
+
+	/* Select the NAND device */
+	this->select_chip(mtd, 0);
+
+	/* First we calculate the starting page */
+	page = (int)from >> this->page_shift;
+
+	/* Get raw starting column */
+	col = from & (mtd->writesize - 1);
+
+	end = mtd->writesize;
+
+	/* Send the read command */
+	this->cmdfunc(mtd, NAND_CMD_READ0, 0x00, page);
+
+	/* Loop until all data read */
+	while (read < len) {
+
+		/* If we have consequent page reads, apply delay or wait for ready/busy pin */
+		if (read) {
+			if (!this->dev_ready)
+				udelay(this->chip_delay);
+			else
+				while (!this->dev_ready(mtd)) ;
+		}
+
+		/*
+		 * If the read is not page aligned, we have to read into data buffer
+		 * due to ecc, else we read into return buffer direct
+		 */
+		if (!col && (len - read) >= end) {
+			data_poi = &buf[read];
+		} else
+			data_poi = this->buffers->databuf;
+
+		/* get oob area, if we have no oob buffer from fs-driver */
+		if (!oob_buf) {
+			oob_data = &this->buffers->databuf[end];
+			oob = 0;
+		}
+
+		switch (eccmode) {
+		case NAND_ECC_NONE:
+			/* No ECC, Read in a page */
+			if (lastwhinge != jiffies) {
+				printk(KERN_WARNING
+				       "Reading data from NAND FLASH without ECC is not recommended\n");
+				lastwhinge = jiffies;
+			}
+			this->read_buf(mtd, data_poi, end);
+			break;
+
+		case NAND_ECC_SOFT:	/* Software ECC 3/256: Read in a page + oob data */
+			this->read_buf(mtd, data_poi, end);
+			this->ecc.calculate(mtd, &data_poi[0], &ecc_calc[0]);
+			if (mtd->writesize == 512)
+				this->ecc.calculate(mtd, &data_poi[256],
+						    &ecc_calc[3]);
+			break;
+
+		default:
+			printk(KERN_WARNING "Invalid NAND_ECC_MODE %d\n",
+			       this->ecc.mode);
+			BUG();
+		}
+
+		/* read oobdata */
+		for (j = 0; j < mtd->oobsize; j++)
+			oob_data[oob + j] = this->read_byte(mtd);
+
+		/* Skip ECC, if not active */
+		if (eccmode == NAND_ECC_NONE)
+			goto readdata;
+
+		/* Pick the ECC bytes out of the oob data */
+		for (j = 0; j < 6; j++)
+			ecc_code[j] = oob_data[oob + oob_config[j]];
+
+		/* correct data, if neccecary */
+		ecc_status = this->ecc.correct(mtd, &data_poi[0], &ecc_code[0],
+						&ecc_calc[0]);
+
+		/* check, if we have a fs supplied oob-buffer */
+		if (oob_buf) {
+			oob += mtd->oobsize;
+			*((int *)&oob_data[oob]) = ecc_status;
+			oob += sizeof(int);
+		}
+		if (ecc_status == -1) {
+			DPRINTK(2,
+				"nand_read_ecc: Failed ECC read, page 0x%08x\n",
+				page);
+			ecc_failed++;
+		}
+
+		if (mtd->writesize == 512 && eccmode != NAND_ECC_HW) {
+			ecc_status = this->ecc.correct(mtd, &data_poi[256],
+							&ecc_code[3],
+							&ecc_calc[3]);
+			if (oob_buf) {
+				*((int *)&oob_data[oob]) = ecc_status;
+				oob += sizeof(int);
+			}
+			if (ecc_status == -1) {
+				DPRINTK(2, "nand_read_ecc: "
+					"Failed ECC read, page 0x%08x\n", page);
+				ecc_failed++;
+			}
+		}
+
+	readdata:
+		if (col || (len - read) < end)
+			for (j = col; j < end && read < len; j++) {
+				buf[read++] = data_poi[j];
+		} else
+			read += mtd->writesize;
+		/* For subsequent reads align to page boundary. */
+		col = 0;
+		/* Increment page address */
+		page++;
+	}
+
+	setcmd(0x00000000);	/* NAND ROM COMMAND clear */
+
+	/* De-select the NAND device */
+	this->select_chip(mtd, -1);
+
+	/* Wake up anyone waiting on the device */
+	spin_lock_bh(&this->controller->lock);
+	this->state = FL_READY;
+	wake_up(&this->controller->wq);
+	spin_unlock_bh(&this->controller->lock);
+
+	/*
+	 * Return success, if no ECC failures, else -EIO
+	 * fs driver will take care of that, because
+	 * retlen == desired len and result == -EIO
+	 */
+	*retlen = read;
+	LEAVE();
+	return ecc_failed ? -EIO : 0;
+}
+
+/*
+ *	Use NAND read ECC
+ */
+static int et10068_nand_read(struct mtd_info *mtd, loff_t from, size_t len,
+			     size_t * retlen, u_char * buf)
+{
+	ENTER();
+	LEAVE();
+
+	return et10068_nand_read_ecc(mtd, from, len, retlen, buf, NULL, NULL);
+}
+
+static int et10068_nand_verify_buf(struct mtd_info *mtd, const u_char * buf,
+				   int len)
+{
+	int i;
+	u_char wk;
+
+	ENTER();
+	for (i = 0; i < len; i++) {
+		wk = et10068_read_byte(mtd);
+
+		if (buf[i] != wk) {
+			printk(KERN_INFO
+			       "VERIFY ERROR!!! i = %d(W:%02x, R:%02x) page=%d\n",
+			       i, buf[i], wk, last_page_addr);
+			return i;
+		}
+	}
+
+	LEAVE();
+	return 0;
+}
+
+/*
+ *	Nand_page_program function is used for write and writev !
+ *	This function will always program a full page of data
+ *	If you call it with a non page aligned buffer, you're lost :)
+ */
+static int et10068_nand_write_page(struct mtd_info *mtd,
+				   struct nand_chip *this, int page,
+				   u_char * oob_buf,
+				   struct nand_ecclayout *oobsel)
+{
+	int i, status;
+	u_char ecc_code[6], *oob_data;
+	int eccmode = NAND_ECC_SOFT;
+	int *oob_config = oobsel->eccpos;
+
+	ENTER();
+
+	/* pad oob area, if we have no oob buffer from fs-driver */
+	if (!oob_buf) {
+		oob_data = &this->buffers->databuf[mtd->writesize];
+		for (i = 0; i < mtd->oobsize; i++)
+			oob_data[i] = 0xff;
+
+		{
+			u_char my_ecc_code[6];
+			u_char my_oob_config[6] = { 1, 0, 2, 5, 4, 6 };
+			/*
+			 * oob_config is defined in fs/jffs2/wbuf.c as
+			 * struct nand_ecclayout jffs2_ecclayout_swecc
+			 * but this routine will be executed before wbuf is initialised!
+			 */
+			int block_size = get_block_num(mtd);
+			/* JFFS2_MAGIC_BITMASK + JFFS2_NODETYPE_CLEANMARKER */
+			u_char jffs2_cleanmarker[8] =
+			    { 0x19, 0x85, 0x20, 0x03, 0x00, 0x00, 0x00, 0x08 };
+			this->ecc.calculate(mtd, this->oob_poi,
+					    &my_ecc_code[0]);
+			this->ecc.calculate(mtd, this->oob_poi + 256,
+					    &my_ecc_code[3]);
+			for (i = 0; i < 6; i++) {
+				oob_data[my_oob_config[i]] = my_ecc_code[i];
+			}
+			if ((page % block_size) == 0)
+				for (i = 0; i < 8; i++)
+					oob_data[i + 8] = jffs2_cleanmarker[i];
+		}
+	} else
+		oob_data = oob_buf;
+
+	/* Send command to begin auto page programming */
+	this->cmdfunc(mtd, NAND_CMD_SEQIN, 0x00, page);
+
+	/* Write out complete page of data, take care of eccmode */
+	switch (eccmode) {
+		/* No ecc and software ecc 3/256, write all */
+	case NAND_ECC_NONE:
+		printk(KERN_WARNING
+		       "Writing data without ECC to NAND-FLASH is not recommended\n");
+		this->write_buf(mtd, this->oob_poi, mtd->writesize);
+		break;
+	case NAND_ECC_SOFT:
+		this->ecc.calculate(mtd, &this->oob_poi[0], &(ecc_code[0]));
+		for (i = 0; i < 3; i++)
+			oob_data[oob_config[i]] = ecc_code[i];
+		/* Calculate and write the second ECC for 512 Byte page size */
+		if (mtd->writesize == 512) {
+			this->ecc.calculate(mtd, &this->oob_poi[256],
+					    &(ecc_code[3]));
+			for (i = 3; i < 6; i++)
+				oob_data[oob_config[i]] = ecc_code[i];
+		}
+		this->write_buf(mtd, this->oob_poi, mtd->writesize);
+		break;
+
+	default:
+		printk(KERN_WARNING "Invalid NAND_ECC_MODE %d\n",
+		       this->ecc.mode);
+		BUG();
+	}
+
+	/* Write out OOB data */
+	this->write_buf(mtd, oob_data, mtd->oobsize);
+
+	/* Send command to actually program the data */
+	this->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
+
+	/* call wait ready function */
+	status = this->waitfunc(mtd, this);
+
+	/* See if device thinks it succeeded */
+	if (status & 0x01) {
+		printk(KERN_WARNING "%s: " "Failed write, page 0x%08x, ",
+		       __FUNCTION__, page);
+		return -EIO;
+	}
+#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
+	/*
+	 * The NAND device assumes that it is always writing to
+	 * a cleanly erased page. Hence, it performs its internal
+	 * write verification only on bits that transitioned from
+	 * 1 to 0. The device does NOT verify the whole page on a
+	 * byte by byte basis. It is possible that the page was
+	 * not completely erased or the page is becoming unusable
+	 * due to wear. The read with ECC would catch the error
+	 * later when the ECC page check fails, but we would rather
+	 * catch it early in the page write stage. Better to write
+	 * no data than invalid data.
+	 */
+
+	/* Send command to read back the page */
+	this->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
+	/* Loop through and verify the data */
+
+	if (this->verify_buf(mtd, this->oob_poi, mtd->writesize)) {
+		printk(KERN_WARNING "%s: " "Failed write verify, page 0x%08x ",
+		       __FUNCTION__, page);
+		return -EIO;
+	}
+
+	/* check, if we have a fs-supplied oob-buffer */
+	if (oob_buf) {
+		if (this->verify_buf(mtd, oob_data, mtd->oobsize)) {
+			printk(KERN_WARNING "%s: "
+			       "Failed write verify, page 0x%08x ",
+			       __FUNCTION__, page);
+			return -EIO;
+		}
+	} else {
+		if (eccmode != NAND_ECC_NONE) {
+			int ecc_bytes = 0;
+
+			if(this->ecc.mode == NAND_ECC_SOFT) 
+				ecc_bytes = (mtd->writesize == 512) ? 6 : 3;
+
+			this->read_buf(mtd, oob_data, mtd->oobsize);
+
+			for (i = 0; i < ecc_bytes; i++) {
+				if (oob_data[oob_config[i]] != ecc_code[i]) {
+					DPRINTK(0,
+						"%s: Failed ECC write "
+						"verify, page 0x%08x, "
+						"%6i bytes were succesful\n",
+						__FUNCTION__, page, i);
+					return -EIO;
+				}
+			}
+		}
+	}
+	/*
+	 * Terminate the read command. This is faster than sending a reset command or
+	 * applying a 20us delay before issuing the next programm sequence.
+	 * This is not a problem for all chips, but I have found a bunch of them.
+	 */
+	this->select_chip(mtd, -1);
+	this->select_chip(mtd, 0);
+#endif
+	LEAVE();
+	return 0;
+}
+
+
+/*
+ * NAND write with ECC
+ */
+static int et10068_nand_write_ecc(struct mtd_info *mtd, loff_t to, size_t len,
+				  size_t * retlen, const u_char * buf,
+				  u_char * oob_buf, struct nand_ecclayout *oobsel)
+{
+	int page, ret = 0, oob = 0, written = 0;
+	struct nand_chip *this = mtd->priv;
+
+	ENTER();
+
+	/* Do not allow write past end of device */
+	if ((to + len) > mtd->size) {
+		DPRINTK(2,
+			"nand_write_ecc: Attempt to write past end of page\n");
+		return -EINVAL;
+	}
+
+	/* reject writes, which are not page aligned */
+	if (NOTALIGNED(to) || NOTALIGNED(len)) {
+		printk(KERN_NOTICE
+		       "nand_write_ecc: Attempt to write not page aligned data\n");
+		return -EINVAL;
+	}
+	/* if oobsel is NULL, use chip defaults */
+	if (oobsel == NULL)
+		oobsel = mtd->ecclayout;
+
+	/* Shift to get page */
+	page = ((int)to) >> this->page_shift;
+
+	/* Grab the lock and see if the device is available */
+	et10068_nand_get_chip(this, mtd, FL_WRITING, NULL);
+
+	/* Select the NAND device */
+	this->select_chip(mtd, 0);
+
+	/* Check the WP bit */
+	this->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);
+	if (!(this->read_byte(mtd) & 0x80)) {
+		DPRINTK(2, "nand_write_ecc: Device is write protected!!!\n");
+		ret = -EIO;
+		goto out;
+	}
+
+	/* Loop until all data is written */
+	while (written < len) {
+		int cnt = mtd->writesize;
+		this->oob_poi = (u_char *) &buf[written];
+
+		/* We use the same function for write and writev */
+		if (oob_buf) {
+			ret =
+			    et10068_nand_write_page(mtd, this, page,
+						    &oob_buf[oob], oobsel);
+			oob += mtd->oobsize;
+		} else
+			ret =
+			    et10068_nand_write_page(mtd, this, page, NULL,
+						    oobsel);
+
+		if (ret)
+			goto out;
+
+		/* Update written bytes count */
+		written += cnt;
+		/* Increment page address */
+		page++;
+	}
+
+      out:
+
+	setcmd(0x00000000);	/* NAND ROM COMMAND clear */
+
+	/* De-select the NAND device */
+	this->select_chip(mtd, -1);
+
+	/* Wake up anyone waiting on the device */
+	spin_lock_bh(&this->controller->lock);
+	this->state = FL_READY;
+	wake_up(&this->controller->wq);
+	spin_unlock_bh(&this->controller->lock);
+
+	*retlen = written;
+	LEAVE();
+	return ret;
+}
+
+/*
+ *	Use NAND write ECC
+ */
+static int et10068_nand_write(struct mtd_info *mtd, loff_t to, size_t len,
+			      size_t * retlen, const u_char * buf)
+{
+	ENTER();
+	LEAVE();
+
+	return (et10068_nand_write_ecc(mtd, to, len, retlen, buf, NULL, NULL));
+
+}
+
+#ifdef CONFIG_MTD_PARTITIONS
+static const char *partition_probes[] = { "cmdlinepart", NULL };
+#endif
+
+static uint8_t scan_ff_pattern[] = { 0xff };
+static uint8_t bbt_pattern[] = { 'b' };
+static uint8_t mirror_pattern[] = { 'm' };
+
+static struct nand_bbt_descr smallpage_memorybased = {
+	.options = NAND_BBT_SCANALLPAGES, 
+	.offs = 5,
+	.len = 1,
+	.pattern = scan_ff_pattern
+};
+
+static struct nand_bbt_descr bbt_main_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+	    | NAND_BBT_2BIT | NAND_BBT_VERSION,
+	.offs = 3,
+	.len = 1,
+	.veroffs = 7,
+	.maxblocks = 4,
+	.pattern = bbt_pattern
+};
+
+static struct nand_bbt_descr bbt_mirror_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+	    | NAND_BBT_2BIT | NAND_BBT_VERSION,
+	.offs = 3,
+	.len = 1,
+	.veroffs = 7,
+	.maxblocks = 4,
+	.pattern = mirror_pattern
+};
+
+int nand_et10068_bbt(struct mtd_info *mtd)
+{
+	struct nand_chip *this = mtd->priv;
+
+	this->bbt_td = &bbt_main_descr;
+	this->bbt_md = &bbt_mirror_descr;
+
+	this->badblock_pattern = &smallpage_memorybased;
+
+	return nand_scan_bbt(mtd, this->badblock_pattern);
+}
+
+/*
+ * Main initialization routine
+ */
+static int __devinit et10068_nand_probe(struct device *dev)
+{
+	struct nand_chip *this;
+	const char *part_type = 0;
+	static int mtd_parts_nb = 0;
+	struct mtd_partition *mtd_parts = 0;
+	struct resource *r;
+	u32 fio_pbase;
+	u32 reg;
+	struct platform_device *pdev = to_platform_device(dev);
+
+	ENTER();
+	printk(KERN_INFO "NAND Flash ROM driver for ET10068\n");
+
+	r = platform_get_resource(pdev, 0, 0);
+	fio_pbase = r->start;
+	fio_vbase = KSEG1ADDR(r->start);
+
+	/* NAND Mode set */
+	reg = readl((void *)NAND_ROMIF_MODE);
+	writel(reg | (0x1 << 16 | 0x1 << 17 | 0x1 << 18), (void *)NAND_ROMIF_MODE);
+
+
+	/* Allocate memory for MTD device structure and private data */
+	et10068_mtd =
+	    kmalloc(sizeof(struct mtd_info) + sizeof(struct nand_chip), GFP_KERNEL);
+
+	if (!et10068_mtd) {
+		printk(KERN_ERR "Unable to allocate ET10068 NAND MTD device structure.\n");
+		return -ENOMEM;
+	}
+
+	/* map physical adress */
+	et10068_fio_base = ioremap(fio_pbase, SZ_1K);
+	if (!et10068_fio_base) {
+		printk(KERN_ERR "ioremap ET10068 NAND flash failed\n");
+		kfree(et10068_mtd);
+		return -EIO;
+	}
+
+	/* Get pointer to private data */
+	this = (struct nand_chip *)(&et10068_mtd[1]);
+
+	/* Initialize structures */
+	memset((char *)et10068_mtd, 0, sizeof(struct mtd_info));
+	memset((char *)this, 0, sizeof(struct nand_chip));
+
+	/* Link the private data with the MTD structure */
+	et10068_mtd->priv = this;
+	et10068_mtd->owner = THIS_MODULE;
+
+	/* insert callbacks */
+	this->IO_ADDR_R = et10068_fio_base;
+	this->IO_ADDR_W = et10068_fio_base;
+	this->dev_ready = et10068_dev_ready;
+	this->cmdfunc = et10068_cmdfunc;
+	this->read_byte = et10068_read_byte;
+
+	this->write_buf = et10068_nand_write_buf;
+	this->read_buf = et10068_nand_read_buf;
+	this->verify_buf = et10068_nand_verify_buf;
+
+	this->select_chip = et10068_nand_select_chip;
+
+	this->ecc.mode = NAND_ECC_SOFT;
+	this->ecc.layout = &et10068_ecclayout;
+
+	/* 15 us command delay time */
+	this->chip_delay = 15;
+
+	this->scan_bbt = nand_et10068_bbt;
+
+	/* Scan to find existence of the device */
+	printk (KERN_ERR "before nand_scan \n");
+	if (nand_scan(et10068_mtd, 1)) {
+		iounmap((void *)et10068_fio_base);
+		kfree(et10068_mtd);
+		return -ENXIO;
+	}
+
+	if (et10068_mtd->size > BROI_MAX_SIZE)
+		et10068_mtd->size = BROI_MAX_SIZE;
+
+	partition_info[0].size = et10068_mtd->size;
+
+	et10068_mtd->read = et10068_nand_read;
+	et10068_mtd->write = et10068_nand_write;
+
+	et10068_mtd->name = "et10068-nand";
+	mtd_parts_nb =
+	    parse_mtd_partitions(et10068_mtd, partition_probes, &mtd_parts, 0);
+
+	if (mtd_parts_nb > 0)
+		part_type = "command line";
+	else {
+		mtd_parts_nb = 0;
+		mtd_parts = partition_info;
+		mtd_parts_nb = NUM_PARTITIONS;
+		part_type = "static";
+	}
+
+	/* Register the partitions */
+	printk(KERN_NOTICE "Using %s partition definition\n", part_type);
+
+	/* Creating 1 MTD partitions on "et10068-nand" */
+	add_mtd_partitions(et10068_mtd, mtd_parts, mtd_parts_nb);
+
+	LEAVE();
+	return 0;
+}
+
+static int __devinit et10068_nand_remove(struct device *dev)
+{
+	ENTER();
+
+	del_mtd_partitions(et10068_mtd);
+
+	/* Free the MTD device structure */
+	kfree(et10068_mtd);
+
+	iounmap((void *)et10068_fio_base);
+
+	setcmd(0x00000000);	/* NAND ROM COMMAND clear */
+
+	LEAVE();
+	return 0;
+}
+
+static struct device_driver et10068_nand_driver = {
+	.name		= "et10068-nand",
+	.bus		= &platform_bus_type,
+	.probe		= et10068_nand_probe,
+	.remove		= et10068_nand_remove,
+};
+
+/*
+ * Main initialization routine
+ */
+static int __init et10068_init(void)
+{
+	return driver_register(&et10068_nand_driver);
+}
+
+/*
+ * Clean up routine
+ */
+static void __exit et10068_cleanup(void)
+{
+	driver_unregister(&et10068_nand_driver);
+}
+
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("NEC Electronics Corporation");
+MODULE_DESCRIPTION("NAND flash driver for ET10068 board");
+
+module_init(et10068_init);
+module_exit(et10068_cleanup);
+
+module_param(nand_debug, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(nand_debug,
+		 "debug level - 0 off; 1 normal; 2,3 more verbose; 9 i2c-protocol");
+
+
-- 
1.5.5.1

