From b5e22f22c159f04bfb067034522e6fe103d4b6e8 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Sat, 14 May 2011 12:26:30 +0800
Subject: [PATCH 3/9] imx25pdk: add mx25 platforms common files

Add freescale mx25 platforms common files, include device, dma, clock,
cpu, pm, and usb etc.

[Original code taken from L2.6.31_09.12.01_SDK.tar.gz BSP package:
http://www.freescale.com/webapp/sps/site/prod_summary.jsp?code=
IMX25PDK&fpsp=1&tab=Design_Tools_Tab]

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-mx25/board-mx25_3stack.h             |  172 --
 arch/arm/mach-mx25/bus_freq.c                      |  102 ++
 arch/arm/mach-mx25/clock.c                         | 1739 +++++++++++++++++++-
 arch/arm/mach-mx25/cpu.c                           |   60 +
 arch/arm/mach-mx25/devices.c                       |  815 ++++++----
 arch/arm/mach-mx25/devices.h                       |   23 -
 arch/arm/mach-mx25/dma.c                           |  662 ++++++++
 .../arm/mach-mx25/include/mach/board-mx25_3stack.h |  172 ++
 arch/arm/mach-mx25/include/mach/crm_regs.h         |  215 +++
 arch/arm/mach-mx25/include/mach/devices.h          |   24 +
 arch/arm/mach-mx25/include/mach/sdma_script_code.h |  158 ++
 arch/arm/mach-mx25/include/mach/serial.h           |  148 ++
 arch/arm/mach-mx25/iomux.c                         |  199 +++
 arch/arm/mach-mx25/mm.c                            |   69 +-
 arch/arm/mach-mx25/pm.c                            |  103 ++
 arch/arm/mach-mx25/system.c                        |  140 ++
 arch/arm/mach-mx25/usb_dr.c                        |  138 ++
 arch/arm/mach-mx25/usb_h2.c                        |   87 +
 18 files changed, 4390 insertions(+), 636 deletions(-)
 delete mode 100644 arch/arm/mach-mx25/board-mx25_3stack.h
 create mode 100644 arch/arm/mach-mx25/bus_freq.c
 create mode 100644 arch/arm/mach-mx25/cpu.c
 delete mode 100644 arch/arm/mach-mx25/devices.h
 create mode 100644 arch/arm/mach-mx25/dma.c
 create mode 100644 arch/arm/mach-mx25/include/mach/board-mx25_3stack.h
 create mode 100644 arch/arm/mach-mx25/include/mach/crm_regs.h
 create mode 100644 arch/arm/mach-mx25/include/mach/devices.h
 create mode 100644 arch/arm/mach-mx25/include/mach/sdma_script_code.h
 create mode 100644 arch/arm/mach-mx25/include/mach/serial.h
 create mode 100644 arch/arm/mach-mx25/iomux.c
 create mode 100644 arch/arm/mach-mx25/pm.c
 create mode 100644 arch/arm/mach-mx25/system.c
 create mode 100644 arch/arm/mach-mx25/usb_dr.c
 create mode 100644 arch/arm/mach-mx25/usb_h2.c

diff --git a/arch/arm/mach-mx25/board-mx25_3stack.h b/arch/arm/mach-mx25/board-mx25_3stack.h
deleted file mode 100644
index 6c5e3f7..0000000
--- a/arch/arm/mach-mx25/board-mx25_3stack.h
+++ /dev/null
@@ -1,172 +0,0 @@
-/*
- * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
- */
-
-/*
- * The code contained herein is licensed under the GNU General Public
- * License. You may obtain a copy of the GNU General Public License
- * Version 2 or later at the following locations:
- *
- * http://www.opensource.org/licenses/gpl-license.html
- * http://www.gnu.org/copyleft/gpl.html
- */
-
-#ifndef __ASM_ARCH_MXC_BOARD_MX25_3STACK_H__
-#define __ASM_ARCH_MXC_BOARD_MX25_3STACK_H__
-
-#ifdef CONFIG_MACH_MX25_3DS
-
-/*!
- * @defgroup BRDCFG_MX25 Board Configuration Options
- * @ingroup MSL_MX25
- */
-
-/*!
- * @file mach-mx25/board-mx25_3stack.h
- *
- * @brief This file contains all the board level configuration options.
- *
- * It currently hold the options defined for MX25 3STACK Platform.
- *
- * @ingroup BRDCFG_MX25
- */
-
-/*
- * Include Files
- */
-#include <mach/mxc_uart.h>
-#include <linux/fsl_devices.h>
-/*!
- * @name MXC UART board-level configurations
- */
-/*! @{ */
-/* UART 1 configuration */
-/*!
- * This define specifies if the UART port is configured to be in DTE or
- * DCE mode. There exists a define like this for each UART port. Valid
- * values that can be used are \b MODE_DTE or \b MODE_DCE.
- */
-#define UART1_MODE              MODE_DCE
-/*!
- * This define specifies if the UART is to be used for IRDA. There exists a
- * define like this for each UART port. Valid values that can be used are
- * \b IRDA or \b NO_IRDA.
- */
-#define UART1_IR                NO_IRDA
-/*!
- * This define is used to enable or disable a particular UART port. If
- * disabled, the UART will not be registered in the file system and the user
- * will not be able to access it. There exists a define like this for each UART
- * port. Specify a value of 1 to enable the UART and 0 to disable it.
- */
-#define UART1_ENABLED           1
-/*! @} */
-/* UART 2 configuration */
-#define UART2_MODE              MODE_DCE
-#define UART2_IR                NO_IRDA
-#define UART2_ENABLED           1
-
-/* UART 3 configuration */
-#define UART3_MODE              MODE_DTE
-#define UART3_IR                NO_IRDA
-#define UART3_ENABLED           0
-
-/* UART 4 configuration */
-#define UART4_MODE              MODE_DTE
-#define UART4_IR                NO_IRDA
-#define UART4_ENABLED           0
-
-/* UART 5 configuration */
-#define UART5_MODE              MODE_DTE
-#define UART5_IR                NO_IRDA
-#define UART5_ENABLED           0
-
-#define MXC_LL_UART_PADDR	UART1_BASE_ADDR
-#define MXC_LL_UART_VADDR	AIPS1_IO_ADDRESS(UART1_BASE_ADDR)
-
-/*!
- * @name debug board parameters
- */
-/*! @{ */
-/*!
- * Base address of debug board
- */
-#define DEBUG_BASE_ADDRESS      0x78000000	/* Use a dummy base address */
-
-/* External ethernet LAN9217 base address */
-#define LAN9217_BASE_ADDR       DEBUG_BASE_ADDRESS
-
-/* External UART */
-#define UARTA_BASE_ADDR		(DEBUG_BASE_ADDRESS + 0x08000)
-#define UARTB_BASE_ADDR		(DEBUG_BASE_ADDRESS + 0x10000)
-
-#define BOARD_IO_ADDR		0x20000
-
-/* LED switchs */
-#define LED_SWITCH_REG		(BOARD_IO_ADDR + 0x00)
-/* buttons */
-#define SWITCH_BUTTON_REG	(BOARD_IO_ADDR + 0x08)
-/* status, interrupt */
-#define INTR_STATUS_REG		(BOARD_IO_ADDR + 0x10)
-#define INTR_RESET_REG		(BOARD_IO_ADDR + 0x20)
-/*CPLD configuration*/
-#define CONFIG1_REG		(BOARD_IO_ADDR + 0x28)
-#define CONFIG2_REG		(BOARD_IO_ADDR + 0x30)
-/*interrupt mask */
-#define INTR_MASK_REG		(BOARD_IO_ADDR + 0x38)
-
-/* magic word for debug CPLD */
-#define MAGIC_NUMBER1_REG	(BOARD_IO_ADDR + 0x40)
-#define	MAGIC_NUMBER2_REG	(BOARD_IO_ADDR + 0x48)
-/* CPLD code version */
-#define CPLD_CODE_VER_REG       (BOARD_IO_ADDR + 0x50)
-/* magic word for debug CPLD */
-#define MAGIC3_NUMBER3_REG	(BOARD_IO_ADDR + 0x58)
-/* module reset register*/
-#define CONTROL_REG		(BOARD_IO_ADDR + 0x60)
-/* CPU ID and Personality ID*/
-#define IDENT_REG		(BOARD_IO_ADDR + 0x68)
-
-/* For interrupts like xuart, enet etc */
-#define EXPIO_PARENT_INT        MX25_PIN_GPIO1_1
-
-#define EXPIO_INT_ENET_INT          (MXC_BOARD_IRQ_START + 0)
-#define EXPIO_INT_XUARTA_INT        (MXC_BOARD_IRQ_START + 1)
-#define EXPIO_INT_XUARTB_INT        (MXC_BOARD_IRQ_START + 2)
-
-/*! This is System IRQ used by LAN9217 for interrupt generation taken
- * from platform.h
- */
-#define LAN9217_IRQ              EXPIO_INT_ENET_INT
-
-/*! This is base virtual address of debug board*/
-extern unsigned int mx25_3stack_board_io;
-
-#define MXC_BD_LED1             (1 << 0)
-#define MXC_BD_LED2             (1 << 1)
-#define MXC_BD_LED3             (1 << 2)
-#define MXC_BD_LED4             (1 << 3)
-#define MXC_BD_LED5             (1 << 4)
-#define MXC_BD_LED6             (1 << 5)
-#define MXC_BD_LED7             (1 << 6)
-#define MXC_BD_LED8             (1 << 7)
-#define MXC_BD_LED_ON(led)
-#define MXC_BD_LED_OFF(led)
-
-#define MXC_DEFAULT_INTENSITY	127
-#define MXC_INTENSITY_OFF	0
-
-extern void mx25_3stack_gpio_init(void) __init;
-extern int headphone_det_status(void);
-extern void sgtl5000_enable_amp(void);
-extern unsigned int sdhc_get_card_det_status(struct device *dev);
-extern int sdhc_write_protect(struct device *dev);
-extern void gpio_can_active(int id);
-extern void gpio_can_inactive(int id);
-extern struct flexcan_platform_data flexcan_data[];
-extern void mx2fb_set_brightness(uint8_t);
-extern int __init mx25_3stack_init_mc34704(void);
-extern void imx_adc_set_hsync(int on);
-
-#endif				/* CONFIG_MACH_MX25_3DS */
-#endif				/* __ASM_ARCH_MXC_BOARD_MX25_3STACK_H__ */
diff --git a/arch/arm/mach-mx25/bus_freq.c b/arch/arm/mach-mx25/bus_freq.c
new file mode 100644
index 0000000..61bed55
--- /dev/null
+++ b/arch/arm/mach-mx25/bus_freq.c
@@ -0,0 +1,102 @@
+/*
+ * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file bus_freq.c
+ *
+ * @brief A common API for the Freescale Semiconductor i.MXC CPUfreq module
+ * and DVFS CORE module.
+ *
+ * The APIs are for setting bus frequency to low or high.
+ *
+ * @ingroup PM
+ */
+
+#include <linux/proc_fs.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <mach/clock.h>
+#include <mach/hardware.h>
+
+int low_bus_freq_mode;
+int high_bus_freq_mode;
+char *gp_reg_id = "REG3_CORE";
+
+int set_low_bus_freq(void)
+{
+	return 0;
+}
+
+int set_high_bus_freq(int high_bus_freq)
+{
+	return 0;
+}
+
+int low_freq_bus_used(void)
+{
+	return 0;
+}
+
+/*!
+ * This is the probe routine for the bus frequency driver.
+ *
+ * @param   pdev   The platform device structure
+ *
+ * @return         The function returns 0 on success
+ *
+ */
+static int __devinit busfreq_probe(struct platform_device *pdev)
+{
+	low_bus_freq_mode = 0;
+	high_bus_freq_mode = 0;
+
+	return 0;
+}
+
+static struct platform_driver busfreq_driver = {
+	.driver = {
+		   .name = "busfreq",
+		   },
+	.probe = busfreq_probe,
+};
+
+/*!
+ * Initialise the busfreq_driver.
+ *
+ * @return  The function always returns 0.
+ */
+
+static int __init busfreq_init(void)
+{
+	if (platform_driver_register(&busfreq_driver) != 0) {
+		printk(KERN_ERR "busfreq_driver register failed\n");
+		return -ENODEV;
+	}
+
+	printk(KERN_INFO "Bus freq driver module loaded\n");
+	return 0;
+}
+
+static void __exit busfreq_cleanup(void)
+{
+	/* Unregister the device structure */
+	platform_driver_unregister(&busfreq_driver);
+}
+
+module_init(busfreq_init);
+module_exit(busfreq_cleanup);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("BusFreq driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/mach-mx25/clock.c b/arch/arm/mach-mx25/clock.c
index 1550149..d01f3cc 100644
--- a/arch/arm/mach-mx25/clock.c
+++ b/arch/arm/mach-mx25/clock.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2009 by Sascha Hauer, Pengutronix
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -16,6 +17,8 @@
  * MA 02110-1301, USA.
  */
 
+#include <linux/module.h>
+#include <linux/spinlock.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/list.h>
@@ -28,6 +31,7 @@
 #include <mach/hardware.h>
 #include <mach/common.h>
 #include <mach/mx25.h>
+#include <mach/crm_regs.h>
 
 #define CRM_BASE	MX25_IO_ADDRESS(MX25_CRM_BASE_ADDR)
 
@@ -52,88 +56,1561 @@
 #define CCM_LTR2	0x48
 #define CCM_LTR3	0x4c
 
-static unsigned long get_rate_mpll(void)
+#define OSC24M_CLK_FREQ     24000000	/* 24M reference clk */
+#define OSC32K_CLK_FREQ     32768	/* 32.768k oscillator in */
+
+#if defined CONFIG_CPU_FREQ_IMX
+#define AHB_CLK_DEFAULT 133000000
+#define ARM_SRC_DEFAULT 532000000
+#endif
+
+static struct clk mpll_clk;
+static struct clk upll_clk;
+static struct clk ahb_clk;
+static struct clk upll_24610k_clk;
+int cpu_wp_nr;
+
+static int clk_cgcr_enable(struct clk *clk);
+static void clk_cgcr_disable(struct clk *clk);
+static unsigned long get_rate_ipg(struct clk *clk);
+
+static int _clk_upll_enable(struct clk *clk)
 {
-	ulong mpctl = __raw_readl(CRM_BASE + CCM_MPCTL);
+	unsigned long reg;
 
-	return mxc_decode_pll(mpctl, 24000000);
+	reg = __raw_readl(MXC_CCM_CCTL);
+	reg &= ~MXC_CCM_CCTL_UPLL_DISABLE;
+	__raw_writel(reg, MXC_CCM_CCTL);
+
+	while ((__raw_readl(MXC_CCM_UPCTL) & MXC_CCM_UPCTL_LF) == 0)
+		;
+
+	return 0;
 }
 
-static unsigned long get_rate_upll(void)
+static void _clk_upll_disable(struct clk *clk)
 {
-	ulong mpctl = __raw_readl(CRM_BASE + CCM_UPCTL);
+	unsigned long reg;
 
-	return mxc_decode_pll(mpctl, 24000000);
+	reg = __raw_readl(MXC_CCM_CCTL);
+	reg |= MXC_CCM_CCTL_UPLL_DISABLE;
+	__raw_writel(reg, MXC_CCM_CCTL);
 }
 
-unsigned long get_rate_arm(struct clk *clk)
+static int _perclk_enable(struct clk *clk)
 {
-	unsigned long cctl = readl(CRM_BASE + CCM_CCTL);
-	unsigned long rate = get_rate_mpll();
+	unsigned long reg;
 
-	if (cctl & (1 << 14))
-		rate = (rate * 3) >> 1;
+	reg = __raw_readl(MXC_CCM_CGCR0);
+	reg |= 1 << clk->id;
+	__raw_writel(reg, MXC_CCM_CGCR0);
 
-	return rate / ((cctl >> 30) + 1);
+	return 0;
 }
 
-static unsigned long get_rate_ahb(struct clk *clk)
+static void _perclk_disable(struct clk *clk)
 {
-	unsigned long cctl = readl(CRM_BASE + CCM_CCTL);
+	unsigned long reg;
 
-	return get_rate_arm(NULL) / (((cctl >> 28) & 0x3) + 1);
+	reg = __raw_readl(MXC_CCM_CGCR0);
+	reg &= ~(1 << clk->id);
+	__raw_writel(reg, MXC_CCM_CGCR0);
 }
 
-static unsigned long get_rate_ipg(struct clk *clk)
+static unsigned long _clk_osc24m_get_rate(struct clk *clk)
 {
-	return get_rate_ahb(NULL) >> 1;
+	return OSC24M_CLK_FREQ;
+}
+
+static unsigned long _clk_osc32k_get_rate(struct clk *clk)
+{
+	return OSC32K_CLK_FREQ;
+}
+
+static unsigned long _clk_pll_get_rate(struct clk *clk)
+{
+	unsigned long mfi = 0, mfn = 0, mfd = 0, pdf = 0;
+	unsigned long ref_clk;
+	unsigned long reg;
+	unsigned long long temp;
+
+	ref_clk = clk_get_rate(clk->parent);
+
+	if (clk == &mpll_clk) {
+		reg = __raw_readl(MXC_CCM_MPCTL);
+		pdf = (reg & MXC_CCM_MPCTL_PD_MASK) >> MXC_CCM_MPCTL_PD_OFFSET;
+		mfd =
+		    (reg & MXC_CCM_MPCTL_MFD_MASK) >> MXC_CCM_MPCTL_MFD_OFFSET;
+		mfi =
+		    (reg & MXC_CCM_MPCTL_MFI_MASK) >> MXC_CCM_MPCTL_MFI_OFFSET;
+		mfn =
+		    (reg & MXC_CCM_MPCTL_MFN_MASK) >> MXC_CCM_MPCTL_MFN_OFFSET;
+	} else if (clk == &upll_clk) {
+		reg = __raw_readl(MXC_CCM_UPCTL);
+		pdf = (reg & MXC_CCM_UPCTL_PD_MASK) >> MXC_CCM_UPCTL_PD_OFFSET;
+		mfd =
+		    (reg & MXC_CCM_UPCTL_MFD_MASK) >> MXC_CCM_UPCTL_MFD_OFFSET;
+		mfi =
+		    (reg & MXC_CCM_UPCTL_MFI_MASK) >> MXC_CCM_UPCTL_MFI_OFFSET;
+		mfn =
+		    (reg & MXC_CCM_UPCTL_MFN_MASK) >> MXC_CCM_UPCTL_MFN_OFFSET;
+	} else {
+		BUG();		/* oops */
+	}
+
+	mfi = (mfi <= 5) ? 5 : mfi;
+	temp = 2LL * ref_clk * mfn;
+	do_div(temp, mfd + 1);
+	temp = 2LL * ref_clk * mfi + temp;
+	do_div(temp, pdf + 1);
+
+	return temp;
+}
+
+static unsigned long _clk_cpu_round_rate(struct clk *clk, unsigned long rate)
+{
+	int div = clk_get_rate(clk->parent) / rate;
+
+	if (clk_get_rate(clk->parent) % rate)
+		div++;
+
+	if (div > 4)
+		div = 4;
+
+	return clk_get_rate(clk->parent) / div;
+}
+
+static int _clk_cpu_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long div = 0x0, reg = 0x0;
+	unsigned long cctl = __raw_readl(MXC_CCM_CCTL);
+
+#if defined CONFIG_CPU_FREQ_IMX
+	struct cpu_wp *cpu_wp;
+	unsigned long ahb_clk_div = 0;
+	unsigned long arm_src = 0;
+	int i;
+
+	cpu_wp = get_cpu_wp(&cpu_wp_nr);
+	for (i = 0; i < cpu_wp_nr; i++) {
+		if (cpu_wp[i].cpu_rate == rate) {
+			div = cpu_wp[i].cpu_podf;
+			ahb_clk_div = cpu_wp[i].cpu_rate / AHB_CLK_DEFAULT - 1;
+			arm_src =
+			    (cpu_wp[i].pll_rate == ARM_SRC_DEFAULT) ? 0 : 1;
+			break;
+		}
+	}
+	if (i == cpu_wp_nr)
+		return -EINVAL;
+	reg = (cctl & ~MXC_CCM_CCTL_ARM_MASK) |
+	    (div << MXC_CCM_CCTL_ARM_OFFSET);
+	reg = (reg & ~MXC_CCM_CCTL_AHB_MASK) |
+	    (ahb_clk_div << MXC_CCM_CCTL_AHB_OFFSET);
+	reg = (reg & ~MXC_CCM_CCTL_ARM_SRC) |
+	    (arm_src << MXC_CCM_CCTL_ARM_SRC_OFFSET);
+	__raw_writel(reg, MXC_CCM_CCTL);
+#else
+	div = clk_get_rate(clk->parent) / rate;
+
+	if (div > 4 || div < 1 || ((clk_get_rate(clk->parent) / div) != rate))
+		return -EINVAL;
+	div--;
+
+	reg =
+	    (cctl & ~MXC_CCM_CCTL_ARM_MASK) | (div << MXC_CCM_CCTL_ARM_OFFSET);
+	__raw_writel(reg, MXC_CCM_CCTL);
+#endif
+
+	return 0;
+}
+
+static unsigned long _clk_cpu_get_rate(struct clk *clk)
+{
+	unsigned long div;
+	unsigned long cctl = __raw_readl(MXC_CCM_CCTL);
+	unsigned long rate;
+
+	div = (cctl & MXC_CCM_CCTL_ARM_MASK) >> MXC_CCM_CCTL_ARM_OFFSET;
+
+	rate = clk_get_rate(clk->parent) / (div + 1);
+
+	if (cctl & MXC_CCM_CCTL_ARM_SRC) {
+		rate *= 3;
+		rate /= 4;
+	}
+
+	return rate;
+}
+
+static unsigned long _clk_ahb_get_rate(struct clk *clk)
+{
+	unsigned long div;
+	unsigned long cctl = __raw_readl(MXC_CCM_CCTL);
+
+	div = (cctl & MXC_CCM_CCTL_AHB_MASK) >> MXC_CCM_CCTL_AHB_OFFSET;
+
+	return clk_get_rate(clk->parent) / (div + 1);
+}
+
+static void *pcdr_a[4] = {
+	MXC_CCM_PCDR0, MXC_CCM_PCDR1, MXC_CCM_PCDR2, MXC_CCM_PCDR3
+};
+static unsigned long _clk_perclkx_get_rate(struct clk *clk)
+{
+	unsigned long perclk_pdf;
+	unsigned long pcdr;
+
+	pcdr = __raw_readl(pcdr_a[clk->id >> 2]);
+
+	perclk_pdf =
+	    (pcdr >> ((clk->id & 3) << 3)) & MXC_CCM_PCDR1_PERDIV1_MASK;
+
+	return clk_get_rate(clk->parent) / (perclk_pdf + 1);
+}
+
+static unsigned long _clk_perclkx_round_rate(struct clk *clk,
+					     unsigned long rate)
+{
+	unsigned long div;
+	unsigned long parent_rate;
+
+	parent_rate = clk_get_rate(clk->parent);
+	div = parent_rate / rate;
+	if (parent_rate % rate)
+		div++;
+
+	if (div > 64)
+		div = 64;
+
+	return parent_rate / div;
+}
+
+static int _clk_perclkx_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long reg;
+	unsigned long div;
+	unsigned long parent_rate;
+
+	if (clk->id < 0 || clk->id > 15)
+		return -EINVAL;
+
+	parent_rate = clk_get_rate(clk->parent);
+	div = parent_rate / rate;
+	if (div > 64 || div < 1 || ((parent_rate / div) != rate))
+		return -EINVAL;
+	div--;
+
+	reg =
+	    __raw_readl(pcdr_a[clk->id >> 2]) & ~(MXC_CCM_PCDR1_PERDIV1_MASK <<
+						  ((clk->id & 3) << 3));
+	reg |= div << ((clk->id & 3) << 3);
+	__raw_writel(reg, pcdr_a[clk->id >> 2]);
+
+	return 0;
+}
+
+static int _clk_perclkx_set_parent(struct clk *clk, struct clk *parent)
+{
+	unsigned long mcr;
+
+	if (parent != &upll_clk && parent != &ahb_clk)
+		return -EINVAL;
+
+	clk->parent = parent;
+	mcr = __raw_readl(MXC_CCM_MCR);
+	if (parent == &upll_clk)
+		mcr |= (1 << clk->id);
+	else
+		mcr &= ~(1 << clk->id);
+
+	__raw_writel(mcr, MXC_CCM_MCR);
+
+	return 0;
+}
+
+static int _clk_perclkx_set_parent3(struct clk *clk, struct clk *parent)
+{
+	unsigned long mcr = __raw_readl(MXC_CCM_MCR);
+	int bit;
+
+	if (parent != &upll_clk && parent != &ahb_clk &&
+	    parent != &upll_24610k_clk)
+		return -EINVAL;
+
+	switch (clk->id) {
+	case 2:
+		bit = MXC_CCM_MCR_ESAI_CLK_MUX_OFFSET;
+		break;
+	case 13:
+		bit = MXC_CCM_MCR_SSI1_CLK_MUX_OFFSET;
+		break;
+	case 14:
+		bit = MXC_CCM_MCR_SSI2_CLK_MUX_OFFSET;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (parent == &upll_24610k_clk) {
+		mcr |= 1 << bit;
+		__raw_writel(mcr, MXC_CCM_MCR);
+		clk->parent = parent;
+	} else {
+		mcr &= ~(1 << bit);
+		__raw_writel(mcr, MXC_CCM_MCR);
+		return _clk_perclkx_set_parent(clk, parent);
+	}
+
+	return 0;
+}
+
+static unsigned long _clk_ipg_get_rate(struct clk *clk)
+{
+	return clk_get_rate(clk->parent) / 2;	/* Always AHB / 2 */
+}
+
+static unsigned long _clk_parent_round_rate(struct clk *clk, unsigned long rate)
+{
+	return clk->parent->round_rate(clk->parent, rate);
+}
+
+static int _clk_parent_set_rate(struct clk *clk, unsigned long rate)
+{
+	return clk->parent->set_rate(clk->parent, rate);
+}
+
+/* Top-level clocks */
+
+static struct clk osc24m_clk = {
+	.get_rate = _clk_osc24m_get_rate,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk osc32k_clk = {
+	.get_rate = _clk_osc32k_get_rate,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk mpll_clk = {
+	.parent = &osc24m_clk,
+	.get_rate = _clk_pll_get_rate,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk upll_clk = {
+	.parent = &osc24m_clk,
+	.get_rate = _clk_pll_get_rate,
+	.enable = _clk_upll_enable,
+	.disable = _clk_upll_disable,
+	.flags = RATE_PROPAGATES,
+};
+
+static unsigned long _clk_24610k_get_rate(struct clk *clk)
+{
+	long long temp = clk_get_rate(clk->parent) * 2461LL;
+
+	do_div(temp, 24000);
+
+	return temp;	/* Always (UPLL * 24.61 / 240) */
+}
+
+static struct clk upll_24610k_clk = {
+	.parent = &upll_clk,
+	.get_rate = _clk_24610k_get_rate,
+	.flags = RATE_PROPAGATES,
+};
+
+/* Mid-level clocks */
+
+static struct clk cpu_clk = {	/* ARM clock */
+	.parent = &mpll_clk,
+	.set_rate = _clk_cpu_set_rate,
+	.get_rate = _clk_cpu_get_rate,
+	.round_rate = _clk_cpu_round_rate,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk ahb_clk = {	/* a.k.a. HCLK */
+	.parent = &cpu_clk,
+	.get_rate = _clk_ahb_get_rate,
+	.flags = RATE_PROPAGATES,
+};
+
+static struct clk ipg_clk = {
+	.parent = &ahb_clk,
+	.get_rate = _clk_ipg_get_rate,
+	.flags = RATE_PROPAGATES,
+};
+
+
+/* Bottom-level clocks */
+
+struct clk usb_ahb_clk = {
+	.id = 0,
+	.parent = &ahb_clk,
+	.enable = clk_cgcr_enable,
+	.enable_reg = MXC_CCM_CGCR0,
+	.enable_shift = MXC_CCM_CGCR0_HCLK_USBOTG_OFFSET,
+	.disable = clk_cgcr_disable,
+};
+
+struct clk rtic_clk = {
+	.id = 0,
+	.parent = &ahb_clk,
+	.enable = clk_cgcr_enable,
+	.enable_reg = MXC_CCM_CGCR0,
+	.enable_shift = MXC_CCM_CGCR0_HCLK_RTIC_OFFSET,
+	.disable = clk_cgcr_disable,
+};
+
+struct clk emi_clk = {
+	.id = 0,
+	.parent = &ahb_clk,
+	.enable = clk_cgcr_enable,
+	.enable_reg = MXC_CCM_CGCR0,
+	.enable_shift = MXC_CCM_CGCR0_HCLK_EMI_OFFSET,
+	.disable = clk_cgcr_disable,
+};
+
+struct clk brom_clk = {
+	.id = 0,
+	.parent = &ahb_clk,
+	.enable = clk_cgcr_enable,
+	.enable_reg = MXC_CCM_CGCR0,
+	.enable_shift = MXC_CCM_CGCR0_HCLK_BROM_OFFSET,
+	.disable = clk_cgcr_disable,
+};
+
+static struct clk per_clk[] = {
+	/* per_csi_clk */
+	{
+	 .id = 0,
+	 .parent = &upll_clk,	/* can be AHB or UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .get_rate = _clk_perclkx_get_rate,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,
+	},
+	/* per_epit_clk */
+	{
+	 .id = 1,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .get_rate = _clk_perclkx_get_rate,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,
+	},
+	/* per_esai_clk */
+	{
+	 .id = 2,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL or 24.61MHz */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent3,
+	 .get_rate = _clk_perclkx_get_rate,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,
+	},
+	/* per_esdhc1_clk */
+	{
+	 .id = 3,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .get_rate = _clk_perclkx_get_rate,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,
+	},
+	/* per_esdhc2_clk */
+	{
+	 .id = 4,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .get_rate = _clk_perclkx_get_rate,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,
+	},
+	/* per_gpt_clk */
+	{
+	 .id = 5,
+	 .parent = &ahb_clk,	/* Must be AHB */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .get_rate = _clk_perclkx_get_rate,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,
+	},
+	/* per_i2c_clk */
+	{
+	 .id = 6,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .get_rate = _clk_perclkx_get_rate,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,
+	},
+	/* per_lcdc_clk */
+	{
+	 .id = 7,
+	 .parent = &upll_clk,	/* Must be UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .get_rate = _clk_perclkx_get_rate,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,
+	},
+	/* per_nfc_clk */
+	{
+	 .id = 8,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .get_rate = _clk_perclkx_get_rate,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,
+	},
+	/* per_owire_clk */
+	{
+	 .id = 9,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .get_rate = _clk_perclkx_get_rate,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,
+	},
+	/* per_pwm_clk */
+	{
+	 .id = 10,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .get_rate = _clk_perclkx_get_rate,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,
+	},
+	/* per_sim1_clk */
+	{
+	 .id = 11,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .get_rate = _clk_perclkx_get_rate,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,
+	},
+	/* per_sim2_clk */
+	{
+	 .id = 12,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .get_rate = _clk_perclkx_get_rate,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,
+	},
+	/* per_ssi1_clk */
+	{
+	 .id = 13,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL or 24.61MHz */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent3,
+	 .get_rate = _clk_perclkx_get_rate,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,
+	},
+	/* per_ssi2_clk */
+	{
+	 .id = 14,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL or 24.61MHz */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent3,
+	 .get_rate = _clk_perclkx_get_rate,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,
+	},
+	/* per_uart_clk */
+	{
+	 .id = 15,
+	 .parent = &ahb_clk,	/* can be AHB or UPLL */
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclkx_set_rate,
+	 .set_parent = _clk_perclkx_set_parent,
+	 .get_rate = _clk_perclkx_get_rate,
+	 .enable = _perclk_enable,
+	 .disable = _perclk_disable,
+	 .flags = RATE_PROPAGATES,},
+};
+
+struct clk nfc_clk = {
+	.id = 0,
+	.parent = &per_clk[8],
+};
+
+struct clk audmux_clk = {
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable = clk_cgcr_enable,
+	.enable_reg = MXC_CCM_CGCR1,
+	.enable_shift = MXC_CCM_CGCR1_AUDMUX_OFFSET,
+	.disable = clk_cgcr_disable,
+};
+
+struct clk ata_clk[] = {
+	{
+	/* ata_clk */
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_ATA_OFFSET,
+	 .disable = clk_cgcr_disable,
+	 .secondary = &ata_clk[1],},
+	{
+	/* ata_ahb_clk */
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR0,
+	 .enable_shift = MXC_CCM_CGCR0_HCLK_ATA_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk can_clk[] = {
+	{
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_CAN1_OFFSET,
+	 .disable = clk_cgcr_disable,},
+	{
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_CAN2_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk csi_clk[] = {
+	{
+	/* csi_clk */
+	 .id = 0,
+	 .parent = &per_clk[0],
+	 .secondary = &csi_clk[1],},
+	{
+	/* csi_ipg_clk */
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_CSI_OFFSET,
+	 .disable = clk_cgcr_disable,
+	 .secondary = &csi_clk[2],},
+	{
+	/* csi_ahb_clk */
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR0,
+	 .enable_shift = MXC_CCM_CGCR0_HCLK_CSI_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk cspi_clk[] = {
+	{
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_CSPI1_OFFSET,
+	 .get_rate = get_rate_ipg,
+	 .disable = clk_cgcr_disable,},
+	{
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_CSPI2_OFFSET,
+	 .get_rate = get_rate_ipg,
+	 .disable = clk_cgcr_disable,},
+	{
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_CSPI3_OFFSET,
+	 .get_rate = get_rate_ipg,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk dryice_clk = {
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable = clk_cgcr_enable,
+	.enable_reg = MXC_CCM_CGCR1,
+	.enable_shift = MXC_CCM_CGCR1_DRYICE_OFFSET,
+	.disable = clk_cgcr_disable,
+};
+
+struct clk ect_clk = {
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable = clk_cgcr_enable,
+	.enable_reg = MXC_CCM_CGCR1,
+	.enable_shift = MXC_CCM_CGCR1_ECT_OFFSET,
+	.disable = clk_cgcr_disable,
+};
+
+struct clk epit1_clk[] = {
+	{
+	/* epit_clk */
+	 .id = 0,
+	 .parent = &per_clk[1],
+	 .secondary = &epit1_clk[1],},
+	{
+	/* epit_ipg_clk */
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_EPIT1_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk epit2_clk[] = {
+	{
+	/* epit_clk */
+	 .id = 1,
+	 .parent = &per_clk[1],
+	 .secondary = &epit2_clk[1],},
+	{
+	/* epit_ipg_clk */
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_EPIT2_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk esai_clk[] = {
+	{
+	/* esai_clk */
+	 .id = 0,
+	 .parent = &per_clk[2],
+	 .secondary = &esai_clk[1],},
+	{
+	/* esai_ipg_clk */
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_ESAI_OFFSET,
+	 .disable = clk_cgcr_disable,
+	 .secondary = &esai_clk[2],},
+	{
+	/* esai_ahb_clk */
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR0,
+	 .enable_shift = MXC_CCM_CGCR0_HCLK_ESAI_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk esdhc1_clk[] = {
+	{
+	/* esdhc_clk */
+	 .id = 0,
+	 .parent = &per_clk[3],
+	 .secondary = &esdhc1_clk[1],},
+	{
+	/* esdhc_ipg_clk */
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_ESDHC1_OFFSET,
+	 .disable = clk_cgcr_disable,
+	 .secondary = &esdhc1_clk[2],},
+	{
+	/* esdhc_ahb_clk */
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR0,
+	 .enable_shift = MXC_CCM_CGCR0_HCLK_ESDHC1_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk esdhc2_clk[] = {
+	{
+	/* esdhc_clk */
+	 .id = 1,
+	 .parent = &per_clk[4],
+	 .secondary = &esdhc2_clk[1],},
+	{
+	/* esdhc_ipg_clk */
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_ESDHC2_OFFSET,
+	 .disable = clk_cgcr_disable,
+	 .secondary = &esdhc2_clk[2],},
+	{
+	/* esdhc_ahb_clk */
+	 .id = 1,
+	 .parent = &ahb_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR0,
+	 .enable_shift = MXC_CCM_CGCR0_HCLK_ESDHC2_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk fec_clk[] = {
+	{
+	/* fec_clk */
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_FEC_OFFSET,
+	 .disable = clk_cgcr_disable,
+	 .secondary = &fec_clk[1],},
+	{
+	/* fec_ahb_clk */
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR0,
+	 .enable_shift = MXC_CCM_CGCR0_HCLK_FEC_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk gpio_clk[] = {
+	{
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_GPIO1_OFFSET,
+	 .disable = clk_cgcr_disable,},
+	{
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_GPIO2_OFFSET,
+	 .disable = clk_cgcr_disable,},
+	{
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_GPIO3_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+static struct clk gpt1_clk[] = {
+	{
+	/* gpt_clk */
+	 .id = 0,
+	 .parent = &per_clk[5],
+	 .secondary = &gpt1_clk[1],},
+	{
+	/* gpt_ipg_clk */
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_GPT1_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+static struct clk gpt2_clk[] = {
+	{
+	/* gpt_clk */
+	 .id = 1,
+	 .parent = &per_clk[5],
+	 .secondary = &gpt1_clk[1],},
+	{
+	/* gpt_ipg_clk */
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_GPT2_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+static struct clk gpt3_clk[] = {
+	{
+	/* gpt_clk */
+	 .id = 2,
+	 .parent = &per_clk[5],
+	 .secondary = &gpt1_clk[1],},
+	{
+	/* gpt_ipg_clk */
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_GPT3_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+static struct clk gpt4_clk[] = {
+	{
+	/* gpt_clk */
+	 .id = 3,
+	 .parent = &per_clk[5],
+	 .secondary = &gpt1_clk[1],},
+	{
+	/* gpt_ipg_clk */
+	 .id = 3,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_GPT4_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk i2c_clk[] = {
+	{
+	 .id = 0,
+	 .parent = &per_clk[6],},
+	{
+	 .id = 1,
+	 .parent = &per_clk[6],},
+	{
+	 .id = 2,
+	 .parent = &per_clk[6],},
+};
+
+struct clk iim_clk = {
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable = clk_cgcr_enable,
+	.enable_reg = MXC_CCM_CGCR1,
+	.enable_shift = MXC_CCM_CGCR1_IIM_OFFSET,
+	.disable = clk_cgcr_disable,
+};
+
+struct clk iomuxc_clk = {
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable = clk_cgcr_enable,
+	.enable_reg = MXC_CCM_CGCR1,
+	.enable_shift = MXC_CCM_CGCR1_IOMUXC_OFFSET,
+	.disable = clk_cgcr_disable,
+};
+
+struct clk kpp_clk = {
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable = clk_cgcr_enable,
+	.enable_reg = MXC_CCM_CGCR1,
+	.enable_shift = MXC_CCM_CGCR1_KPP_OFFSET,
+	.disable = clk_cgcr_disable,
+};
+
+struct clk lcdc_clk[] = {
+	{
+	/* lcdc_clk */
+	 .id = 0,
+	 .parent = &per_clk[7],
+	 .secondary = &lcdc_clk[1],
+	 .round_rate = _clk_parent_round_rate,
+	 .set_rate = _clk_parent_set_rate,},
+	{
+	/* lcdc_ipg_clk */
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_LCDC_OFFSET,
+	 .disable = clk_cgcr_disable,
+	 .secondary = &lcdc_clk[2],},
+	{
+	/* lcdc_ahb_clk */
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR0,
+	 .enable_shift = MXC_CCM_CGCR0_HCLK_LCDC_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk owire_clk[] = {
+	{
+	/* owire_clk */
+	 .id = 0,
+	 .parent = &per_clk[9],
+	 .secondary = &owire_clk[1],},
+	{
+	/* owire_ipg_clk */
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_OWIRE_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk pwm1_clk[] = {
+	{
+	/* pwm_clk */
+	 .id = 0,
+	 .parent = &per_clk[10],
+	 .secondary = &pwm1_clk[1],},
+	{
+	/* pwm_ipg_clk */
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR1,
+	 .enable_shift = MXC_CCM_CGCR1_PWM1_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk pwm2_clk[] = {
+	{
+	/* pwm_clk */
+	 .id = 1,
+	 .parent = &per_clk[10],
+	 .secondary = &pwm2_clk[1],},
+	{
+	/* pwm_ipg_clk */
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_PWM2_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk pwm3_clk[] = {
+	{
+	/* pwm_clk */
+	 .id = 2,
+	 .parent = &per_clk[10],
+	 .secondary = &pwm3_clk[1],},
+	{
+	/* pwm_ipg_clk */
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_PWM3_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk pwm4_clk[] = {
+	{
+	/* pwm_clk */
+	 .id = 3,
+	 .parent = &per_clk[10],
+	 .secondary = &pwm4_clk[1],},
+	{
+	/* pwm_ipg_clk */
+	 .id = 3,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_PWM3_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk rng_clk = {
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable = clk_cgcr_enable,
+	.enable_reg = MXC_CCM_CGCR2,
+	.enable_shift = MXC_CCM_CGCR2_RNGB_OFFSET,
+	.disable = clk_cgcr_disable,
+};
+
+struct clk scc_clk = {
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable = clk_cgcr_enable,
+	.enable_reg = MXC_CCM_CGCR2,
+	.enable_shift = MXC_CCM_CGCR2_SCC_OFFSET,
+	.disable = clk_cgcr_disable,
+};
+
+struct clk sdma_clk[] = {
+	{
+	/* sdma_ipg_clk */
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_SDMA_OFFSET,
+	 .disable = clk_cgcr_disable,
+	 .secondary = &sdma_clk[1],},
+	{
+	/* sdma_ahb_clk */
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR0,
+	 .enable_shift = MXC_CCM_CGCR0_HCLK_SDMA_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk sim1_clk[] = {
+	{
+	/* sim1_clk */
+	 .id = 0,
+	 .parent = &per_clk[11],
+	 .secondary = &sim1_clk[1],},
+	{
+	/* sim_ipg_clk */
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_SIM1_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk sim2_clk[] = {
+	{
+	/* sim2_clk */
+	 .id = 1,
+	 .parent = &per_clk[12],
+	 .secondary = &sim2_clk[1],},
+	{
+	/* sim_ipg_clk */
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_SIM2_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk slcdc_clk[] = {
+	{
+	/* slcdc_clk */
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_SLCDC_OFFSET,
+	 .disable = clk_cgcr_disable,
+	 .secondary = &slcdc_clk[1],},
+	{
+	/* slcdc_ahb_clk */
+	 .id = 0,
+	 .parent = &ahb_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR0,
+	 .enable_shift = MXC_CCM_CGCR0_HCLK_SLCDC_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk spba_clk = {
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable = clk_cgcr_enable,
+	.enable_reg = MXC_CCM_CGCR2,
+	.enable_shift = MXC_CCM_CGCR2_SPBA_OFFSET,
+	.disable = clk_cgcr_disable,
+};
+
+struct clk ssi1_clk[] = {
+	{
+	/* ssi_clk */
+	 .id = 0,
+	 .parent = &per_clk[13],
+	 .secondary = &ssi1_clk[1],},
+	{
+	/* ssi_ipg_clk */
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_SSI1_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk ssi2_clk[] = {
+	{
+	/* ssi_clk */
+	 .id = 1,
+	 .parent = &per_clk[14],
+	 .secondary = &ssi2_clk[1],},
+	{
+	/* ssi_ipg_clk */
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_SSI2_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk tsc_clk = {
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable = clk_cgcr_enable,
+	.enable_reg = MXC_CCM_CGCR2,
+	.enable_shift = MXC_CCM_CGCR2_TCHSCRN_OFFSET,
+	.disable = clk_cgcr_disable,
+};
+
+struct clk uart1_clk[] = {
+	{
+	/* uart_clk */
+	 .id = 0,
+	 .parent = &per_clk[15],
+	 .secondary = &uart1_clk[1],},
+	{
+	/* uart_ipg_clk */
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_UART1_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk uart2_clk[] = {
+	{
+	/* uart_clk */
+	 .id = 1,
+	 .parent = &per_clk[15],
+	 .secondary = &uart2_clk[1],},
+	{
+	/* uart_ipg_clk */
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_UART2_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk uart3_clk[] = {
+	{
+	/* uart_clk */
+	 .id = 2,
+	 .parent = &per_clk[15],
+	 .secondary = &uart3_clk[1],},
+	{
+	/* uart_ipg_clk */
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_UART3_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk uart4_clk[] = {
+	{
+	/* uart_clk */
+	 .id = 3,
+	 .parent = &per_clk[15],
+	 .secondary = &uart4_clk[1],},
+	{
+	/* uart_ipg_clk */
+	 .id = 3,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_UART4_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk uart5_clk[] = {
+	{
+	/* uart_clk */
+	 .id = 4,
+	 .parent = &per_clk[15],
+	 .secondary = &uart5_clk[1],},
+	{
+	/* uart_ipg_clk */
+	 .id = 4,
+	 .parent = &ipg_clk,
+	 .enable = clk_cgcr_enable,
+	 .enable_reg = MXC_CCM_CGCR2,
+	 .enable_shift = MXC_CCM_CGCR2_UART5_OFFSET,
+	 .disable = clk_cgcr_disable,},
+};
+
+struct clk wdog_clk = {
+	.id = 0,
+	.parent = &ipg_clk,
+	.enable = clk_cgcr_enable,
+	.enable_reg = MXC_CCM_CGCR2,
+	.enable_shift = MXC_CCM_CGCR2_WDOG_OFFSET,
+	.disable = clk_cgcr_disable,
+};
+
+static unsigned long _clk_usb_round_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long div;
+	unsigned long parent_rate;
+
+	parent_rate = clk_get_rate(clk->parent);
+	div = parent_rate / rate;
+	if (parent_rate % rate)
+		div++;
+
+	if (div > 64)
+		return -EINVAL;
+
+	return parent_rate / div;
 }
 
-static unsigned long get_rate_per(int per)
+static int _clk_usb_set_rate(struct clk *clk, unsigned long rate)
 {
-	unsigned long ofs = (per & 0x3) * 8;
-	unsigned long reg = per & ~0x3;
-	unsigned long val = (readl(CRM_BASE + CCM_PCDR0 + reg) >> ofs) & 0x3f;
-	unsigned long fref;
+	unsigned long reg;
+	unsigned long div;
+	unsigned long parent_rate;
+
+	parent_rate = clk_get_rate(clk->parent);
+	div = parent_rate / rate;
+
+	if (parent_rate / div != rate)
+		return -EINVAL;
+	if (div > 64)
+		return -EINVAL;
 
-	if (readl(CRM_BASE + 0x64) & (1 << per))
-		fref = get_rate_upll();
+	reg = __raw_readl(MXC_CCM_CCTL) & ~MXC_CCM_CCTL_USB_DIV_MASK;
+	reg |= (div - 1) << MXC_CCM_CCTL_USB_DIV_OFFSET;
+	__raw_writel(reg, MXC_CCM_CCTL);
+
+	return 0;
+}
+
+static unsigned long _clk_usb_get_rate(struct clk *clk)
+{
+	unsigned long div =
+	    __raw_readl(MXC_CCM_CCTL) & MXC_CCM_CCTL_USB_DIV_MASK;
+
+	div >>= MXC_CCM_CCTL_USB_DIV_OFFSET;
+
+	return clk_get_rate(clk->parent) / (div + 1);
+}
+
+static int _clk_usb_set_parent(struct clk *clk, struct clk *parent)
+{
+	unsigned long mcr;
+
+	if (parent != &upll_clk && parent != &ahb_clk)
+		return -EINVAL;
+
+	clk->parent = parent;
+	mcr = __raw_readl(MXC_CCM_MCR);
+	if (parent == &ahb_clk)
+		mcr |= (1 << MXC_CCM_MCR_USB_CLK_MUX_OFFSET);
 	else
-		fref = get_rate_ipg(NULL);
+		mcr &= ~(1 << MXC_CCM_MCR_USB_CLK_MUX_OFFSET);
+
+	__raw_writel(mcr, MXC_CCM_MCR);
+
+	return 0;
+}
+
+static struct clk usb_clk = {
+	.parent = &upll_clk,
+	.get_rate = _clk_usb_get_rate,
+	.set_rate = _clk_usb_set_rate,
+	.round_rate = _clk_usb_round_rate,
+	.set_parent = _clk_usb_set_parent,
+};
+
+/* CLKO */
+
+static unsigned long _clk_clko_round_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long div;
+	unsigned long parent_rate;
+
+	parent_rate = clk_get_rate(clk->parent);
+	div = parent_rate / rate;
+	if (parent_rate % rate)
+		div++;
+
+	if (div > 64)
+		return -EINVAL;
+
+	return parent_rate / div;
+}
+
+static int _clk_clko_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long reg;
+	unsigned long div;
+	unsigned long parent_rate;
 
-	return fref / (val + 1);
+	parent_rate = clk_get_rate(clk->parent);
+	div = parent_rate / rate;
+
+	if ((parent_rate / div) != rate)
+		return -EINVAL;
+	if (div > 64)
+		return -EINVAL;
+
+	reg = __raw_readl(MXC_CCM_MCR) & ~MXC_CCM_MCR_CLKO_DIV_MASK;
+	reg |= (div - 1) << MXC_CCM_MCR_CLKO_DIV_OFFSET;
+	__raw_writel(reg, MXC_CCM_MCR);
+
+	return 0;
+}
+
+static unsigned long _clk_clko_get_rate(struct clk *clk)
+{
+	unsigned long div =
+	    __raw_readl(MXC_CCM_MCR) & MXC_CCM_MCR_CLKO_DIV_MASK;
+
+	div >>= MXC_CCM_MCR_CLKO_DIV_OFFSET;
+
+	return clk_get_rate(clk->parent) / (div + 1);
+}
+
+static struct clk *clko_sources[] = {
+	&osc32k_clk,		/* 0x0 */
+	&osc24m_clk,		/* 0x1 */
+	&cpu_clk,		/* 0x2 */
+	&ahb_clk,		/* 0x3 */
+	&ipg_clk,		/* 0x4 */
+	NULL,			/* 0x5 */
+	NULL,			/* 0x6 */
+	NULL,			/* 0x7 */
+	NULL,			/* 0x8 */
+	NULL,			/* 0x9 */
+	&per_clk[0],		/* 0xA */
+	&per_clk[2],		/* 0xB */
+	&per_clk[13],		/* 0xC */
+	&per_clk[14],		/* 0xD */
+	&usb_clk,		/* 0xE */
+	NULL,			/* 0xF */
+};
+
+#define NR_CLKO_SOURCES (sizeof(clko_sources) / sizeof(struct clk *))
+
+static int _clk_clko_set_parent(struct clk *clk, struct clk *parent)
+{
+	unsigned long reg =
+	    __raw_readl(MXC_CCM_MCR) & ~MXC_CCM_MCR_CLKO_SEL_MASK;
+	struct clk **src;
+	int i;
+
+	for (i = 0, src = clko_sources; i < NR_CLKO_SOURCES; i++, src++)
+		if (*src == parent)
+			break;
+
+	if (i == NR_CLKO_SOURCES)
+		return -EINVAL;
+
+	clk->parent = parent;
+
+	reg |= i << MXC_CCM_MCR_CLKO_SEL_OFFSET;
+
+	__raw_writel(reg, MXC_CCM_MCR);
+
+	return 0;
 }
 
-static unsigned long get_rate_uart(struct clk *clk)
+static struct clk clko_clk = {
+	.get_rate = _clk_clko_get_rate,
+	.set_rate = _clk_clko_set_rate,
+	.round_rate = _clk_clko_round_rate,
+	.set_parent = _clk_clko_set_parent,
+	.enable = clk_cgcr_enable,
+	.enable_reg = MXC_CCM_MCR,
+	.enable_shift = MXC_CCM_MCR_CLKO_EN_OFFSET,
+	.disable = clk_cgcr_disable,
+};
+
+static unsigned long get_rate_mpll(void)
 {
-	return get_rate_per(15);
+	ulong mpctl = __raw_readl(CRM_BASE + CCM_MPCTL);
+
+	return mxc_decode_pll(mpctl, 24000000);
 }
 
-static unsigned long get_rate_i2c(struct clk *clk)
+static unsigned long get_rate_upll(void)
 {
-	return get_rate_per(6);
+	ulong mpctl = __raw_readl(CRM_BASE + CCM_UPCTL);
+
+	return mxc_decode_pll(mpctl, 24000000);
 }
 
-static unsigned long get_rate_nfc(struct clk *clk)
+unsigned long get_rate_arm(struct clk *clk)
 {
-	return get_rate_per(8);
+	unsigned long cctl = readl(CRM_BASE + CCM_CCTL);
+	unsigned long rate = get_rate_mpll();
+
+	if (cctl & (1 << 14))
+		rate = (rate * 3) >> 2;
+
+	return rate / ((cctl >> 30) + 1);
 }
 
-static unsigned long get_rate_gpt(struct clk *clk)
+static unsigned long get_rate_ahb(struct clk *clk)
 {
-	return get_rate_per(5);
+	unsigned long cctl = readl(CRM_BASE + CCM_CCTL);
+
+	return get_rate_arm(NULL) / (((cctl >> 28) & 0x3) + 1);
 }
 
-static unsigned long get_rate_lcdc(struct clk *clk)
+static unsigned long get_rate_ipg(struct clk *clk)
 {
-	return get_rate_per(7);
+	return get_rate_ahb(NULL) >> 1;
 }
 
 static unsigned long get_rate_otg(struct clk *clk)
 {
-	return 48000000; /* FIXME */
+	unsigned long cctl = readl(CRM_BASE + CCM_CCTL);
+	unsigned long rate = get_rate_upll();
+
+	return (cctl & (1 << 23)) ? 0 : rate / ((0x3F & (cctl >> 16)) + 1);
 }
 
+
 static int clk_cgcr_enable(struct clk *clk)
 {
 	u32 reg;
@@ -166,31 +1643,8 @@ static void clk_cgcr_disable(struct clk *clk)
 		.secondary	= s,			\
 	}
 
-DEFINE_CLOCK(gpt_clk,    0, CCM_CGCR0,  5, get_rate_gpt, NULL, NULL);
-DEFINE_CLOCK(uart_per_clk, 0, CCM_CGCR0, 15, get_rate_uart, NULL, NULL);
-DEFINE_CLOCK(cspi1_clk,  0, CCM_CGCR1,  5, get_rate_ipg, NULL, NULL);
-DEFINE_CLOCK(cspi2_clk,  0, CCM_CGCR1,  6, get_rate_ipg, NULL, NULL);
-DEFINE_CLOCK(cspi3_clk,  0, CCM_CGCR1,  7, get_rate_ipg, NULL, NULL);
-DEFINE_CLOCK(fec_ahb_clk, 0, CCM_CGCR0, 23, NULL,	 NULL, NULL);
-DEFINE_CLOCK(lcdc_ahb_clk, 0, CCM_CGCR0, 24, NULL,	 NULL, NULL);
-DEFINE_CLOCK(lcdc_per_clk, 0, CCM_CGCR0,  7, NULL,	 NULL, &lcdc_ahb_clk);
-DEFINE_CLOCK(uart1_clk,  0, CCM_CGCR2, 14, get_rate_uart, NULL, &uart_per_clk);
-DEFINE_CLOCK(uart2_clk,  0, CCM_CGCR2, 15, get_rate_uart, NULL, &uart_per_clk);
-DEFINE_CLOCK(uart3_clk,  0, CCM_CGCR2, 16, get_rate_uart, NULL, &uart_per_clk);
-DEFINE_CLOCK(uart4_clk,  0, CCM_CGCR2, 17, get_rate_uart, NULL, &uart_per_clk);
-DEFINE_CLOCK(uart5_clk,  0, CCM_CGCR2, 18, get_rate_uart, NULL, &uart_per_clk);
-DEFINE_CLOCK(nfc_clk,    0, CCM_CGCR0,  8, get_rate_nfc, NULL, NULL);
 DEFINE_CLOCK(usbotg_clk, 0, CCM_CGCR0, 28, get_rate_otg, NULL, NULL);
-DEFINE_CLOCK(pwm1_clk,	 0, CCM_CGCR1, 31, get_rate_ipg, NULL, NULL);
-DEFINE_CLOCK(pwm2_clk,	 0, CCM_CGCR2,  0, get_rate_ipg, NULL, NULL);
-DEFINE_CLOCK(pwm3_clk,	 0, CCM_CGCR2,  1, get_rate_ipg, NULL, NULL);
-DEFINE_CLOCK(pwm4_clk,	 0, CCM_CGCR2,  2, get_rate_ipg, NULL, NULL);
-DEFINE_CLOCK(kpp_clk,	 0, CCM_CGCR1, 28, get_rate_ipg, NULL, NULL);
-DEFINE_CLOCK(tsc_clk,	 0, CCM_CGCR2, 13, get_rate_ipg, NULL, NULL);
-DEFINE_CLOCK(i2c_clk,	 0, CCM_CGCR0,  6, get_rate_i2c, NULL, NULL);
-DEFINE_CLOCK(fec_clk,	 0, CCM_CGCR1, 15, get_rate_ipg, NULL, &fec_ahb_clk);
-DEFINE_CLOCK(dryice_clk, 0, CCM_CGCR1,  8, get_rate_ipg, NULL, NULL);
-DEFINE_CLOCK(lcdc_clk,	 0, CCM_CGCR1, 29, get_rate_lcdc, NULL, &lcdc_per_clk);
+
 
 #define _REGISTER_CLOCK(d, n, c)	\
 	{				\
@@ -200,35 +1654,111 @@ DEFINE_CLOCK(lcdc_clk,	 0, CCM_CGCR1, 29, get_rate_lcdc, NULL, &lcdc_per_clk);
 	},
 
 static struct clk_lookup lookups[] = {
-	_REGISTER_CLOCK("imx-uart.0", NULL, uart1_clk)
-	_REGISTER_CLOCK("imx-uart.1", NULL, uart2_clk)
-	_REGISTER_CLOCK("imx-uart.2", NULL, uart3_clk)
-	_REGISTER_CLOCK("imx-uart.3", NULL, uart4_clk)
-	_REGISTER_CLOCK("imx-uart.4", NULL, uart5_clk)
+	_REGISTER_CLOCK(NULL, "osc24m_clk", osc24m_clk)
+	_REGISTER_CLOCK(NULL, "osc32k_clk", osc32k_clk)
+	_REGISTER_CLOCK(NULL, "mpll_clk", mpll_clk)
+	_REGISTER_CLOCK(NULL, "upll_clk", upll_clk)
+	_REGISTER_CLOCK(NULL, "cpu_clk", cpu_clk)
+	_REGISTER_CLOCK(NULL, "ahb_clk", ahb_clk)
+	_REGISTER_CLOCK(NULL, "ipg_clk", ipg_clk)
+	_REGISTER_CLOCK(NULL, "usb_ahb_clk", usb_ahb_clk)
+	_REGISTER_CLOCK(NULL, "usb_clk", usb_clk)
 	_REGISTER_CLOCK("mxc-ehci.0", "usb", usbotg_clk)
 	_REGISTER_CLOCK("mxc-ehci.1", "usb", usbotg_clk)
 	_REGISTER_CLOCK("mxc-ehci.2", "usb", usbotg_clk)
 	_REGISTER_CLOCK("fsl-usb2-udc", "usb", usbotg_clk)
-	_REGISTER_CLOCK("mxc_nand.0", NULL, nfc_clk)
-	_REGISTER_CLOCK("spi_imx.0", NULL, cspi1_clk)
-	_REGISTER_CLOCK("spi_imx.1", NULL, cspi2_clk)
-	_REGISTER_CLOCK("spi_imx.2", NULL, cspi3_clk)
-	_REGISTER_CLOCK("mxc_pwm.0", NULL, pwm1_clk)
-	_REGISTER_CLOCK("mxc_pwm.1", NULL, pwm2_clk)
-	_REGISTER_CLOCK("mxc_pwm.2", NULL, pwm3_clk)
-	_REGISTER_CLOCK("mxc_pwm.3", NULL, pwm4_clk)
-	_REGISTER_CLOCK("mxc-keypad", NULL, kpp_clk)
-	_REGISTER_CLOCK("mx25-adc", NULL, tsc_clk)
-	_REGISTER_CLOCK("imx-i2c.0", NULL, i2c_clk)
-	_REGISTER_CLOCK("imx-i2c.1", NULL, i2c_clk)
-	_REGISTER_CLOCK("imx-i2c.2", NULL, i2c_clk)
-	_REGISTER_CLOCK("fec.0", NULL, fec_clk)
-	_REGISTER_CLOCK("imxdi_rtc.0", NULL, dryice_clk)
-	_REGISTER_CLOCK("imx-fb.0", NULL, lcdc_clk)
+	_REGISTER_CLOCK("imx-uart.0", NULL, uart1_clk[0])
+	_REGISTER_CLOCK("imx-uart.1", NULL, uart2_clk[0])
+	_REGISTER_CLOCK("imx-uart.2", NULL, uart3_clk[0])
+	_REGISTER_CLOCK("imx-uart.3", NULL, uart4_clk[0])
+	_REGISTER_CLOCK("imx-uart.4", NULL, uart5_clk[0])
+	_REGISTER_CLOCK(NULL, "nfc_clk", nfc_clk)
+	_REGISTER_CLOCK("spi_imx.0", NULL, cspi_clk[0])
+	_REGISTER_CLOCK("spi_imx.1", NULL, cspi_clk[1])
+	_REGISTER_CLOCK("spi_imx.2", NULL, cspi_clk[2])
+	_REGISTER_CLOCK("mxc_pwm.0", NULL, pwm1_clk[0])
+	_REGISTER_CLOCK("mxc_pwm.1", NULL, pwm2_clk[0])
+	_REGISTER_CLOCK("mxc_pwm.2", NULL, pwm3_clk[0])
+	_REGISTER_CLOCK("mxc_pwm.3", NULL, pwm4_clk[0])
+	_REGISTER_CLOCK("mxc_keypad.0", NULL, kpp_clk)
+	_REGISTER_CLOCK("imx_adc.0", NULL, tsc_clk)
+	_REGISTER_CLOCK("imx-i2c.0", NULL, i2c_clk[0])
+	_REGISTER_CLOCK("imx-i2c.1", NULL, i2c_clk[1])
+	_REGISTER_CLOCK("imx-i2c.2", NULL, i2c_clk[2])
+	_REGISTER_CLOCK("fec.0", NULL, fec_clk[0])
+	_REGISTER_CLOCK(NULL, "dryice_clk", dryice_clk)
+	_REGISTER_CLOCK("imxdi_rtc.0", "NULL", dryice_clk)
+	_REGISTER_CLOCK("mxc_sdc_fb.0", NULL, lcdc_clk[0])
+	_REGISTER_CLOCK(NULL, "sdma_ipg_clk", sdma_clk[0])
+	_REGISTER_CLOCK(NULL, "sdma_ahb_clk", sdma_clk[1])
+	_REGISTER_CLOCK("mxsdhci.0", NULL, esdhc1_clk[0])
+	_REGISTER_CLOCK("mxsdhci.1", NULL, esdhc2_clk[0])
+	_REGISTER_CLOCK(NULL, "gpt", gpt1_clk[0])
+	_REGISTER_CLOCK(NULL, "gpt", gpt2_clk[0])
+	_REGISTER_CLOCK(NULL, "gpt", gpt3_clk[0])
+	_REGISTER_CLOCK(NULL, "gpt", gpt4_clk[0])
+	_REGISTER_CLOCK(NULL, "clko_clk", clko_clk)
+	_REGISTER_CLOCK("pata_fsl", NULL, ata_clk[0])
+	_REGISTER_CLOCK("FlexCAN.0", NULL, can_clk[0])
+	_REGISTER_CLOCK("FlexCAN.1", NULL, can_clk[1])
+	_REGISTER_CLOCK("mxc_esai.0", NULL, esai_clk[0])
+	_REGISTER_CLOCK("mxc_iim.0", NULL, iim_clk)
+	_REGISTER_CLOCK("mxc_w1.0", NULL, owire_clk[0])
+	_REGISTER_CLOCK(NULL, "scc_clk", scc_clk)
+	_REGISTER_CLOCK("mxc_sim.0", NULL, sim1_clk[0])
+	_REGISTER_CLOCK("mxc_sim.1", NULL, sim2_clk[0])
+	_REGISTER_CLOCK(NULL, "ssi_clk.0", ssi1_clk[0])
+	_REGISTER_CLOCK(NULL, "ssi_clk.1", ssi2_clk[0])
+	_REGISTER_CLOCK(NULL, "csi_clk", csi_clk[0])
+	_REGISTER_CLOCK(NULL, "slcdc_clk", lcdc_clk[0])
+	_REGISTER_CLOCK(NULL, "rng_clk", rng_clk)
+	_REGISTER_CLOCK(NULL, "audmux_clk", audmux_clk)
+	_REGISTER_CLOCK(NULL, "ect_clk", ect_clk)
+	_REGISTER_CLOCK(NULL, "epit1_clk", epit1_clk[0])
+	_REGISTER_CLOCK(NULL, "epit2_clk", epit2_clk[0])
+	_REGISTER_CLOCK(NULL, "gpio_clk", gpio_clk[0])
+	_REGISTER_CLOCK(NULL, "iomuxc_clk", iomuxc_clk)
+	_REGISTER_CLOCK(NULL, "spba_clk", spba_clk)
+	_REGISTER_CLOCK(NULL, "wdog_clk", wdog_clk)
+	_REGISTER_CLOCK(NULL, "per_csi_clk", per_clk[0])
+	_REGISTER_CLOCK(NULL, "per_epit_clk", per_clk[1])
+	_REGISTER_CLOCK(NULL, "per_esai_clk", per_clk[2])
+	_REGISTER_CLOCK(NULL, "per_esdhc1_clk", per_clk[3])
+	_REGISTER_CLOCK(NULL, "per_esdhc2_clk", per_clk[4])
+	_REGISTER_CLOCK(NULL, "per_gpt_clk", per_clk[5])
+	_REGISTER_CLOCK(NULL, "per_i2c_clk", per_clk[6])
+	_REGISTER_CLOCK(NULL, "per_lcdc_clk", per_clk[7])
+	_REGISTER_CLOCK(NULL, "per_nfc_clk", per_clk[8])
+	_REGISTER_CLOCK(NULL, "per_owire_clk", per_clk[9])
+	_REGISTER_CLOCK(NULL, "per_pwm_clk", per_clk[10])
+	_REGISTER_CLOCK(NULL, "per_sim1_clk", per_clk[11])
+	_REGISTER_CLOCK(NULL, "per_sim2_clk", per_clk[12])
+	_REGISTER_CLOCK(NULL, "per_ssi1_clk", per_clk[13])
+	_REGISTER_CLOCK(NULL, "per_ssi2_clk", per_clk[14])
+	_REGISTER_CLOCK(NULL, "per_uart_clk", per_clk[15])
 };
 
+/*!
+ * Function to get timer clock rate early in boot process before clock tree is
+ * initialized.
+ *
+ * @return	Clock rate for timer
+ */
+unsigned long __init clk_early_get_timer_rate(void)
+{
+	upll_clk.get_rate(&upll_clk);
+	per_clk[5].get_rate(&per_clk[5]);
+	per_clk[5].enable(&per_clk[5]);
+
+	return clk_get_rate(&per_clk[5]);
+}
+
 int __init mx25_clocks_init(void)
 {
+	int i;
+	unsigned long upll_rate;
+	unsigned long ahb_rate;
+
 	clkdev_add_table(lookups, ARRAY_SIZE(lookups));
 
 	/* Turn off all clocks except the ones we need to survive, namely:
@@ -236,13 +1766,54 @@ int __init mx25_clocks_init(void)
 	 * SCC
 	 */
 	__raw_writel((1 << 19), CRM_BASE + CCM_CGCR0);
-	__raw_writel((0xf << 16) | (3 << 26), CRM_BASE + CCM_CGCR1);
+
+	__raw_writel((1 << MXC_CCM_CGCR1_GPT1_OFFSET) |
+		     (1 << MXC_CCM_CGCR1_IIM_OFFSET),
+		     CRM_BASE + CCM_CGCR1);
+
 	__raw_writel((1 << 5), CRM_BASE + CCM_CGCR2);
 
 	/* Clock source for lcdc is upll */
 	__raw_writel(__raw_readl(CRM_BASE+0x64) | (1 << 7), CRM_BASE + 0x64);
 
-	mxc_timer_init(&gpt_clk, MX25_IO_ADDRESS(MX25_GPT1_BASE_ADDR), 54);
+	/* Init all perclk sources to ahb clock*/
+	for (i = 0; i < (sizeof(per_clk) / sizeof(struct clk)); i++)
+		per_clk[i].set_parent(&per_clk[i], &ahb_clk);
+
+	/* GPT clock must be derived from AHB clock */
+	ahb_rate = clk_get_rate(&ahb_clk);
+	clk_set_rate(&per_clk[5], ahb_rate / 10);
+
+	/* LCDC clock must be derived from UPLL clock */
+	upll_rate = clk_get_rate(&upll_clk);
+	clk_set_parent(&per_clk[7], &upll_clk);
+	clk_set_rate(&per_clk[7], upll_rate);
+
+	/* the NFC clock must be derived from AHB clock */
+	clk_set_parent(&per_clk[8], &ahb_clk);
+	clk_set_rate(&per_clk[8], ahb_rate / 6);
+
+	/* sim clock */
+	clk_set_rate(&per_clk[11], ahb_rate / 2);
+
+	/* the csi clock must be derived from UPLL clock */
+	clk_set_parent(&per_clk[0], &upll_clk);
+	clk_set_rate(&per_clk[0], upll_rate / 5);
+
+	pr_info("Clock input source is %ld\n", clk_get_rate(&osc24m_clk));
+
+	clk_enable(&uart1_clk[0]);
+	clk_enable(&emi_clk);
+	clk_enable(&gpio_clk[0]);
+	clk_enable(&gpio_clk[1]);
+	clk_enable(&gpio_clk[2]);
+	clk_enable(&iim_clk);
+	clk_enable(&gpt1_clk[0]);
+	clk_enable(&iomuxc_clk);
+	clk_enable(&scc_clk);
+
+	mxc_timer_init(&gpt1_clk[0], IO_ADDRESS(MX25_GPT1_BASE_ADDR),
+		       MX25_INT_GPT1);
 
 	return 0;
 }
diff --git a/arch/arm/mach-mx25/cpu.c b/arch/arm/mach-mx25/cpu.c
new file mode 100644
index 0000000..3dc8360
--- /dev/null
+++ b/arch/arm/mach-mx25/cpu.c
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mach-mx25/cpu.c
+ *
+ * @brief This file contains the CPU initialization code.
+ *
+ * @ingroup MSL_MX25
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <mach/hardware.h>
+#include <asm/io.h>
+
+/*!
+ * CPU initialization. It is called by fixup_mxc_board()
+ */
+void __init mxc_cpu_init(void)
+{
+	if (!system_rev)
+		mxc_set_system_rev(0x25, CHIP_REV_1_0);
+}
+
+static int __init post_cpu_init(void)
+{
+	void __iomem *base;
+	unsigned int reg;
+
+	base = IO_ADDRESS(MX25_AIPS1_BASE_ADDR);
+	__raw_writel(0x0, base + 0x40);
+	__raw_writel(0x0, base + 0x44);
+	__raw_writel(0x0, base + 0x48);
+	__raw_writel(0x0, base + 0x4C);
+	reg = __raw_readl(base + 0x50) & 0x00FFFFFF;
+	__raw_writel(reg, base + 0x50);
+
+	base = IO_ADDRESS(MX25_AIPS2_BASE_ADDR);
+	__raw_writel(0x0, base + 0x40);
+	__raw_writel(0x0, base + 0x44);
+	__raw_writel(0x0, base + 0x48);
+	__raw_writel(0x0, base + 0x4C);
+	reg = __raw_readl(base + 0x50) & 0x00FFFFFF;
+	__raw_writel(reg, base + 0x50);
+
+	return 0;
+}
+postcore_initcall(post_cpu_init);
diff --git a/arch/arm/mach-mx25/devices.c b/arch/arm/mach-mx25/devices.c
index 3f4b8a0..757cf62 100644
--- a/arch/arm/mach-mx25/devices.c
+++ b/arch/arm/mach-mx25/devices.c
@@ -1,5 +1,6 @@
 /*
  * Copyright 2009 Sascha Hauer, <kernel@pengutronix.de>
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -16,487 +17,623 @@
  * Boston, MA  02110-1301, USA.
  */
 
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/io.h>
 #include <linux/platform_device.h>
-#include <linux/dma-mapping.h>
-#include <linux/gpio.h>
-#include <mach/mx25.h>
-#include <mach/irqs.h>
+#include <linux/clk.h>
+#include <linux/spi/spi.h>
+
+#include <mach/hardware.h>
+#include <mach/mmc.h>
+#include <mach/spba.h>
+#include <mach/sdma.h>
+#include <mach/common.h>
+#include <mach/board-mx25_3stack.h>
+#include <mach/sdma_script_code.h>
+#include <mach/iomux-mx25.h>
+
+int dvfs_core_is_active;
+
+void mxc_sdma_get_script_info(sdma_script_start_addrs *sdma_script_addr)
+{
+	sdma_script_addr->mxc_sdma_ap_2_ap_addr = ap_2_ap_ADDR;
+	sdma_script_addr->mxc_sdma_ap_2_bp_addr = -1;
+	sdma_script_addr->mxc_sdma_bp_2_ap_addr = -1;
+	sdma_script_addr->mxc_sdma_loopback_on_dsp_side_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_interrupt_only_addr = -1;
+
+	sdma_script_addr->mxc_sdma_firi_2_per_addr = -1;
+	sdma_script_addr->mxc_sdma_firi_2_mcu_addr = -1;
+	sdma_script_addr->mxc_sdma_per_2_firi_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_2_firi_addr = -1;
+
+	sdma_script_addr->mxc_sdma_uart_2_per_addr = uart_2_per_ADDR;
+	sdma_script_addr->mxc_sdma_uart_2_mcu_addr = uart_2_mcu_ADDR;
+	sdma_script_addr->mxc_sdma_per_2_app_addr = per_2_app_ADDR;
+	sdma_script_addr->mxc_sdma_mcu_2_app_addr = mcu_2_app_ADDR;
+
+	sdma_script_addr->mxc_sdma_per_2_per_addr = -1;
+
+	sdma_script_addr->mxc_sdma_uartsh_2_per_addr = uartsh_2_per_ADDR;
+	sdma_script_addr->mxc_sdma_uartsh_2_mcu_addr = uartsh_2_mcu_ADDR;
+	sdma_script_addr->mxc_sdma_per_2_shp_addr = per_2_shp_ADDR;
+	sdma_script_addr->mxc_sdma_mcu_2_shp_addr = mcu_2_shp_ADDR;
+
+	sdma_script_addr->mxc_sdma_ata_2_mcu_addr = ata_2_mcu_ADDR;
+	sdma_script_addr->mxc_sdma_mcu_2_ata_addr = mcu_2_ata_ADDR;
+
+	sdma_script_addr->mxc_sdma_app_2_per_addr = app_2_per_ADDR;
+	sdma_script_addr->mxc_sdma_app_2_mcu_addr = app_2_mcu_ADDR;
+	sdma_script_addr->mxc_sdma_shp_2_per_addr = shp_2_per_ADDR;
+	sdma_script_addr->mxc_sdma_shp_2_mcu_addr = shp_2_mcu_ADDR;
+
+	sdma_script_addr->mxc_sdma_mshc_2_mcu_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_2_mshc_addr = -1;
+
+	sdma_script_addr->mxc_sdma_spdif_2_mcu_addr = -1;
+	sdma_script_addr->mxc_sdma_mcu_2_spdif_addr = -1;
+
+	sdma_script_addr->mxc_sdma_asrc_2_mcu_addr = -1;
+
+	sdma_script_addr->mxc_sdma_dptc_dvfs_addr = -1;
+	sdma_script_addr->mxc_sdma_ext_mem_2_ipu_addr = ext_mem__ipu_ram_ADDR;
+	sdma_script_addr->mxc_sdma_descrambler_addr = -1;
+
+	sdma_script_addr->mxc_sdma_start_addr = (unsigned short *)sdma_code;
+	sdma_script_addr->mxc_sdma_ram_code_size = RAM_CODE_SIZE;
+	sdma_script_addr->mxc_sdma_ram_code_start_addr = RAM_CODE_START_ADDR;
+}
 
 static struct resource uart0[] = {
 	{
-		.start = 0x43f90000,
-		.end = 0x43f93fff,
-		.flags = IORESOURCE_MEM,
+		.start	= MX25_UART1_BASE_ADDR,
+		.end	= MX25_UART1_BASE_ADDR + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
 	}, {
-		.start = 45,
-		.end = 45,
-		.flags = IORESOURCE_IRQ,
+		.start	= MX25_INT_UART1,
+		.end	= MX25_INT_UART1,
+		.flags	= IORESOURCE_IRQ,
 	},
 };
 
 struct platform_device mxc_uart_device0 = {
-	.name = "imx-uart",
-	.id = 0,
-	.resource = uart0,
-	.num_resources = ARRAY_SIZE(uart0),
+	.name	= "imx-uart",
+	.id	= 0,
+	.resource	= uart0,
+	.num_resources	= ARRAY_SIZE(uart0),
 };
 
 static struct resource uart1[] = {
 	{
-		.start = 0x43f94000,
-		.end = 0x43f97fff,
-		.flags = IORESOURCE_MEM,
+		.start	= MX25_UART2_BASE_ADDR,
+		.end	= MX25_UART2_BASE_ADDR + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
 	}, {
-		.start = 32,
-		.end = 32,
-		.flags = IORESOURCE_IRQ,
+		.start	= MX25_INT_UART2,
+		.end	= MX25_INT_UART2,
+		.flags	= IORESOURCE_IRQ,
 	},
 };
 
 struct platform_device mxc_uart_device1 = {
-	.name = "imx-uart",
-	.id = 1,
-	.resource = uart1,
-	.num_resources = ARRAY_SIZE(uart1),
+	.name	= "imx-uart",
+	.id	= 1,
+	.resource	= uart1,
+	.num_resources	= ARRAY_SIZE(uart1),
 };
 
 static struct resource uart2[] = {
 	{
-		.start = 0x5000c000,
-		.end = 0x5000ffff,
-		.flags = IORESOURCE_MEM,
+		.start	= MX25_UART3_BASE_ADDR,
+		.end	= MX25_UART3_BASE_ADDR + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
 	}, {
-		.start = 18,
-		.end = 18,
-		.flags = IORESOURCE_IRQ,
-	},
+		.start	= MX25_INT_UART3,
+		.end	= MX25_INT_UART3,
+		.flags	= IORESOURCE_IRQ,
+       },
 };
 
 struct platform_device mxc_uart_device2 = {
-	.name = "imx-uart",
-	.id = 2,
-	.resource = uart2,
-	.num_resources = ARRAY_SIZE(uart2),
+	.name	= "imx-uart",
+	.id	= 2,
+	.resource	= uart2,
+	.num_resources	= ARRAY_SIZE(uart2),
 };
 
-static struct resource uart3[] = {
+#if defined(CONFIG_RTC_DRV_IMXDI) || defined(CONFIG_RTC_DRV_IMXDI_MODULE)
+static struct resource rtc_resources[] = {
 	{
-		.start = 0x50008000,
-		.end = 0x5000bfff,
-		.flags = IORESOURCE_MEM,
+		.start	= MX25_SRTC_BASE_ADDR,
+		.end	= MX25_SRTC_BASE_ADDR + 0x40,
+		.flags	= IORESOURCE_MEM,
 	}, {
-		.start = 5,
-		.end = 5,
-		.flags = IORESOURCE_IRQ,
+		.start	= MX25_INT_DRYICE,
+		.end	= MX25_INT_DRYICE,
+		.flags	= IORESOURCE_IRQ,
 	},
 };
 
-struct platform_device mxc_uart_device3 = {
-	.name = "imx-uart",
-	.id = 3,
-	.resource = uart3,
-	.num_resources = ARRAY_SIZE(uart3),
+static struct platform_device imxdi_rtc_device = {
+	.name	= "imxdi_rtc",
+	.id	= 0,
+	.resource	= rtc_resources,
+	.num_resources	= ARRAY_SIZE(rtc_resources),
 };
 
-static struct resource uart4[] = {
+static void mxc_init_rtc(void)
+{
+	(void)platform_device_register(&imxdi_rtc_device);
+}
+#else
+static inline void mxc_init_rtc(void)
+{
+}
+#endif
+
+#if defined(CONFIG_MXC_WATCHDOG) || defined(CONFIG_MXC_WATCHDOG_MODULE)
+static struct resource wdt_resources[] = {
 	{
-		.start = 0x5002c000,
-		.end = 0x5002ffff,
-		.flags = IORESOURCE_MEM,
-	}, {
-		.start = 40,
-		.end = 40,
-		.flags = IORESOURCE_IRQ,
+		.start	= MX25_WDOG_BASE_ADDR,
+		.end	= MX25_WDOG_BASE_ADDR + 0x30,
+		.flags	= IORESOURCE_MEM,
 	},
 };
 
-struct platform_device mxc_uart_device4 = {
-	.name = "imx-uart",
-	.id = 4,
-	.resource = uart4,
-	.num_resources = ARRAY_SIZE(uart4),
+static struct platform_device mxc_wdt_device = {
+	.name	= "mxc_wdt",
+	.id	= 0,
+	.resource	= wdt_resources,
+	.num_resources	= ARRAY_SIZE(wdt_resources),
 };
 
-#define MX25_OTG_BASE_ADDR 0x53FF4000
+static void mxc_init_wdt(void)
+{
+	(void)platform_device_register(&mxc_wdt_device);
+}
+#else
+static inline void mxc_init_wdt(void)
+{
+}
+#endif
 
-static u64 otg_dmamask = DMA_BIT_MASK(32);
+/* SPI controller and device data */
+#if defined(CONFIG_SPI_MXC) || defined(CONFIG_SPI_MXC_MODULE)
 
-static struct resource mxc_otg_resources[] = {
+#ifdef CONFIG_SPI_MXC_SELECT1
+/*!
+ * Resource definition for the CSPI1
+ */
+static struct resource mxcspi1_resources[] = {
 	{
-		.start = MX25_OTG_BASE_ADDR,
-		.end = MX25_OTG_BASE_ADDR + 0x1ff,
+		.start = MX25_CSPI1_BASE_ADDR,
+		.end = MX25_CSPI1_BASE_ADDR + SZ_4K - 1,
 		.flags = IORESOURCE_MEM,
 	}, {
-		.start = 37,
-		.end = 37,
+		.start = MX25_INT_CSPI1,
+		.end = MX25_INT_CSPI1,
 		.flags = IORESOURCE_IRQ,
 	},
 };
 
-struct platform_device mxc_otg = {
-	.name = "mxc-ehci",
-	.id = 0,
-	.dev = {
-		.coherent_dma_mask = 0xffffffff,
-		.dma_mask = &otg_dmamask,
-	},
-	.resource = mxc_otg_resources,
-	.num_resources = ARRAY_SIZE(mxc_otg_resources),
+/*! Platform Data for MXC CSPI1 */
+static struct mxc_spi_master mxcspi1_data = {
+	.maxchipselect	= 4,
+	.spi_version	= 7,
 };
 
-/* OTG gadget device */
-struct platform_device otg_udc_device = {
-	.name = "fsl-usb2-udc",
-	.id   = -1,
-	.dev  = {
-		.dma_mask          = &otg_dmamask,
-		.coherent_dma_mask = 0xffffffff,
-	},
-	.resource = mxc_otg_resources,
-	.num_resources = ARRAY_SIZE(mxc_otg_resources),
+/*! Device Definition for MXC CSPI1 */
+static struct platform_device mxcspi1_device = {
+	.name	= "spi_imx",
+	.id	= 0,
+	.dev	= {
+			.platform_data = &mxcspi1_data,
+		},
+	.resource	= mxcspi1_resources,
+	.num_resources	= ARRAY_SIZE(mxcspi1_resources),
 };
 
-static u64 usbh2_dmamask = DMA_BIT_MASK(32);
+#endif				/* CONFIG_SPI_MXC_SELECT1 */
 
-static struct resource mxc_usbh2_resources[] = {
+#ifdef CONFIG_SPI_MXC_SELECT2
+/*!
+ * Resource definition for the CSPI2
+ */
+static struct resource mxcspi2_resources[] = {
 	{
-		.start = MX25_OTG_BASE_ADDR + 0x400,
-		.end = MX25_OTG_BASE_ADDR + 0x5ff,
-		.flags = IORESOURCE_MEM,
+		.start	= MX25_CSPI2_BASE_ADDR,
+		.end	= MX25_CSPI2_BASE_ADDR + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
 	}, {
-		.start = 35,
-		.end = 35,
-		.flags = IORESOURCE_IRQ,
-	},
-};
-
-struct platform_device mxc_usbh2 = {
-	.name = "mxc-ehci",
-	.id = 1,
-	.dev = {
-		.coherent_dma_mask = 0xffffffff,
-		.dma_mask = &usbh2_dmamask,
+		.start	= MX25_INT_CSPI2,
+		.end	= MX25_INT_CSPI2,
+		.flags	= IORESOURCE_IRQ,
 	},
-	.resource = mxc_usbh2_resources,
-	.num_resources = ARRAY_SIZE(mxc_usbh2_resources),
 };
 
-static struct resource mxc_spi_resources0[] = {
-	{
-	       .start = 0x43fa4000,
-	       .end = 0x43fa7fff,
-	       .flags = IORESOURCE_MEM,
-	}, {
-	       .start = 14,
-	       .end = 14,
-	       .flags = IORESOURCE_IRQ,
-	},
+/*! Platform Data for MXC CSPI2 */
+static struct mxc_spi_master mxcspi2_data = {
+	.maxchipselect	= 4,
+	.spi_version	= 7,
 };
 
-struct platform_device mxc_spi_device0 = {
-	.name = "spi_imx",
-	.id = 0,
-	.num_resources = ARRAY_SIZE(mxc_spi_resources0),
-	.resource = mxc_spi_resources0,
+/*! Device Definition for MXC CSPI2 */
+static struct platform_device mxcspi2_device = {
+	.name	= "spi_imx",
+	.id	= 1,
+	.dev	= {
+			.platform_data = &mxcspi2_data,
+		},
+	.num_resources	= ARRAY_SIZE(mxcspi2_resources),
+	.resource	= mxcspi2_resources,
 };
+#endif				/* CONFIG_SPI_MXC_SELECT2 */
 
-static struct resource mxc_spi_resources1[] = {
+#ifdef CONFIG_SPI_MXC_SELECT3
+/*!
+ * Resource definition for the CSPI3
+ */
+static struct resource mxcspi3_resources[] = {
 	{
-	       .start = 0x50010000,
-	       .end = 0x50013fff,
-	       .flags = IORESOURCE_MEM,
+		.start	= MX25_CSPI3_BASE_ADDR,
+		.end	= MX25_CSPI3_BASE_ADDR + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
 	}, {
-	       .start = 13,
-	       .end = 13,
-	       .flags = IORESOURCE_IRQ,
+		.start	= MX25_INT_CSPI3,
+		.end	= MX25_INT_CSPI3,
+		.flags	= IORESOURCE_IRQ,
 	},
 };
 
-struct platform_device mxc_spi_device1 = {
-	.name = "spi_imx",
-	.id = 1,
-	.num_resources = ARRAY_SIZE(mxc_spi_resources1),
-	.resource = mxc_spi_resources1,
+/*! Platform Data for MXC CSPI3 */
+static struct mxc_spi_master mxcspi3_data = {
+	.maxchipselect	= 4,
+	.spi_version	= 7,
 };
 
-static struct resource mxc_spi_resources2[] = {
-	{
-	       .start = 0x50004000,
-	       .end = 0x50007fff,
-	       .flags = IORESOURCE_MEM,
-	}, {
-	       .start = 0,
-	       .end = 0,
-	       .flags = IORESOURCE_IRQ,
-	},
+/*! Device Definition for MXC CSPI3 */
+static struct platform_device mxcspi3_device = {
+	.name	= "spi_imx",
+	.id	= 2,
+	.dev	= {
+			.platform_data = &mxcspi3_data,
+		},
+	.resource	= mxcspi3_resources,
+	.num_resources	= ARRAY_SIZE(mxcspi3_resources),
 };
+#endif				/* CONFIG_SPI_MXC_SELECT3 */
 
-struct platform_device mxc_spi_device2 = {
-	.name = "spi_imx",
-	.id = 2,
-	.num_resources = ARRAY_SIZE(mxc_spi_resources2),
-	.resource = mxc_spi_resources2,
-};
+static inline void mxc_init_spi(void)
+{
+#ifdef CONFIG_SPI_MXC_SELECT1
+	if (platform_device_register(&mxcspi1_device) < 0)
+		printk(KERN_ERR "Error: Registering the SPI Controller_1\n");
+#endif				/* CONFIG_SPI_MXC_SELECT1 */
+#ifdef CONFIG_SPI_MXC_SELECT2
+	if (platform_device_register(&mxcspi2_device) < 0)
+		printk(KERN_ERR "Error: Registering the SPI Controller_2\n");
+#endif				/* CONFIG_SPI_MXC_SELECT2 */
+#ifdef CONFIG_SPI_MXC_SELECT3
+	if (platform_device_register(&mxcspi3_device) < 0)
+		printk(KERN_ERR "Error: Registering the SPI Controller_3\n");
+#endif				/* CONFIG_SPI_MXC_SELECT3 */
+}
+#else
+static inline void mxc_init_spi(void)
+{
+}
+#endif
 
-static struct resource mxc_pwm_resources0[] = {
+/* I2C controller and device data */
+#if defined(CONFIG_I2C_MXC) || defined(CONFIG_I2C_MXC_MODULE)
+
+#ifdef CONFIG_I2C_MXC_SELECT1
+/*!
+ * Resource definition for the I2C1
+ */
+static struct resource mxci2c1_resources[] = {
 	{
-		.start	= 0x53fe0000,
-		.end	= 0x53fe3fff,
-		.flags	= IORESOURCE_MEM,
+	       .start	= MX25_I2C_BASE_ADDR,
+	       .end	= MX25_I2C_BASE_ADDR + SZ_4K - 1,
+	       .flags	= IORESOURCE_MEM,
 	}, {
-		.start   = 26,
-		.end     = 26,
-		.flags   = IORESOURCE_IRQ,
-	}
-};
-
-struct platform_device mxc_pwm_device0 = {
-	.name = "mxc_pwm",
-	.id = 0,
-	.num_resources = ARRAY_SIZE(mxc_pwm_resources0),
-	.resource = mxc_pwm_resources0,
+	       .start	= MX25_INT_I2C,
+	       .end	= MX25_INT_I2C,
+	       .flags	= IORESOURCE_IRQ,
+	},
 };
 
-static struct resource mxc_pwm_resources1[] = {
-	{
-		.start	= 0x53fa0000,
-		.end	= 0x53fa3fff,
-		.flags	= IORESOURCE_MEM,
-	}, {
-		.start   = 36,
-		.end     = 36,
-		.flags   = IORESOURCE_IRQ,
-	}
+/*! Platform Data for MXC I2C */
+static struct mxc_i2c_platform_data mxci2c1_data = {
+	.i2c_clk = 400000,
 };
 
-struct platform_device mxc_pwm_device1 = {
-	.name = "mxc_pwm",
-	.id = 1,
-	.num_resources = ARRAY_SIZE(mxc_pwm_resources1),
-	.resource = mxc_pwm_resources1,
+struct platform_device mxc_i2c_device0 = {
+	.name	= "imx-i2c",
+	.id	= 0,
+	.dev	= {
+			.platform_data = &mxci2c1_data,
+		},
+	.resource       = mxci2c1_resources,
+	.num_resources  = ARRAY_SIZE(mxci2c1_resources),
 };
+#endif
 
-static struct resource mxc_pwm_resources2[] = {
+#ifdef CONFIG_I2C_MXC_SELECT2
+/*!
+ * Resource definition for the I2C2
+ */
+static struct resource mxci2c2_resources[] = {
 	{
-		.start	= 0x53fa8000,
-		.end	= 0x53fabfff,
-		.flags	= IORESOURCE_MEM,
+	       .start	= MX25_I2C2_BASE_ADDR,
+	       .end	= MX25_I2C2_BASE_ADDR + SZ_4K - 1,
+	       .flags	= IORESOURCE_MEM,
 	}, {
-		.start   = 41,
-		.end     = 41,
-		.flags   = IORESOURCE_IRQ,
-	}
+	       .start	= MX25_INT_I2C2,
+	       .end	= MX25_INT_I2C2,
+	       .flags	= IORESOURCE_IRQ,
+	},
 };
 
-struct platform_device mxc_pwm_device2 = {
-	.name = "mxc_pwm",
-	.id = 2,
-	.num_resources = ARRAY_SIZE(mxc_pwm_resources2),
-	.resource = mxc_pwm_resources2,
+/*! Platform Data for MXC I2C */
+static struct mxc_i2c_platform_data mxci2c2_data = {
+	.i2c_clk = 400000,
 };
 
-static struct resource mxc_keypad_resources[] = {
+struct platform_device mxc_i2c_device1 = {
+	.name	= "imx-i2c",
+	.id	= 1,
+	.dev	= {
+			.platform_data = &mxci2c2_data,
+		},
+	.resource = mxci2c2_resources,
+	.num_resources = ARRAY_SIZE(mxci2c2_resources),
+}
+#endif
+
+#ifdef CONFIG_I2C_MXC_SELECT3
+/*!
+ * Resource definition for the I2C3
+ */
+static struct resource mxci2c3_resources[] = {
 	{
-		.start	= 0x43fa8000,
-		.end	= 0x43fabfff,
-		.flags	= IORESOURCE_MEM,
+	       .start	= MX25_I2C3_BASE_ADDR,
+	       .end	= MX25_I2C3_BASE_ADDR + SZ_4K - 1,
+	       .flags	= IORESOURCE_MEM,
 	}, {
-		.start   = 24,
-		.end     = 24,
-		.flags   = IORESOURCE_IRQ,
-	}
+	       .start	= MX25_INT_I2C3,
+	       .end	= MX25_INT_I2C3,
+	       .flags	= IORESOURCE_IRQ,
+	},
 };
 
-struct platform_device mxc_keypad_device = {
-	.name = "mxc-keypad",
-	.id = -1,
-	.num_resources = ARRAY_SIZE(mxc_keypad_resources),
-	.resource = mxc_keypad_resources,
+/*! Platform Data for MXC I2C */
+static struct mxc_i2c_platform_data mxci2c3_data = {
+	.i2c_clk = 400000,
 };
 
-static struct resource mxc_pwm_resources3[] = {
-	{
-		.start	= 0x53fc8000,
-		.end	= 0x53fcbfff,
-		.flags	= IORESOURCE_MEM,
-	}, {
-		.start   = 42,
-		.end     = 42,
-		.flags   = IORESOURCE_IRQ,
-	}
-};
+struct platform_device mxc_i2c_device2 = {
+	.name	= "imx-i2c",
+	.id	= 2,
+	.dev	= {
+			.platform_data = &mxci2c3_data,
+		},
+	.resource	= mxci2c3_resources,
+	.num_resources	= ARRAY_SIZE(mxci2c3_resources),
+}
+#endif
 
-struct platform_device mxc_pwm_device3 = {
-	.name = "mxc_pwm",
-	.id = 3,
-	.num_resources = ARRAY_SIZE(mxc_pwm_resources3),
-	.resource = mxc_pwm_resources3,
-};
+static inline void mxc_init_i2c(void)
+{
+#ifdef CONFIG_I2C_MXC_SELECT1
+	if (platform_device_register(&mxc_i2c_device0) < 0)
+		printk(KERN_ERR "Error: Unable to register I2C0 device\n");
+#endif
+#ifdef CONFIG_I2C_MXC_SELECT2
+	if (platform_device_register(&mxc_i2c_device1) < 0)
+		printk(KERN_ERR "Error: Unable to register I2C1 device\n");
+#endif
+#ifdef CONFIG_I2C_MXC_SELECT3
+	if (platform_device_register(&mxc_i2c_device2) < 0)
+		printk(KERN_ERR "Error: Unable to register I2C2 device\n");
+#endif
+}
+#else
+static inline void mxc_init_i2c(void)
+{
+}
+#endif
 
-static struct resource mxc_i2c_1_resources[] = {
+struct mxc_gpio_port mxc_gpio_ports[] = {
 	{
-		.start	= 0x43f80000,
-		.end	= 0x43f83fff,
-		.flags	= IORESOURCE_MEM,
-	}, {
-		.start	= 3,
-		.end	= 3,
-		.flags	= IORESOURCE_IRQ,
+		.chip.label	= "gpio-0",
+		.base		= IO_ADDRESS(MX25_GPIO1_BASE_ADDR),
+		.irq		= MX25_INT_GPIO1,
+		.irq_high	= 0,
+		.virtual_irq_start = MXC_GPIO_IRQ_START
+	 }, {
+		.chip.label	= "gpio-1",
+		.base		= IO_ADDRESS(MX25_GPIO2_BASE_ADDR),
+		.irq		= MX25_INT_GPIO2,
+		.irq_high	= 0,
+		.virtual_irq_start = MXC_GPIO_IRQ_START + 32
+	 }, {
+		.chip.label	= "gpio-2",
+		.base		= IO_ADDRESS(MX25_GPIO3_BASE_ADDR),
+		.irq		= MX25_INT_GPIO3,
+		.irq_high	= 0,
+		.virtual_irq_start = MXC_GPIO_IRQ_START + 32 * 2
+	 }, {
+		.chip.label	= "gpio-3",
+		.base		= IO_ADDRESS(MX25_GPIO4_BASE_ADDR),
+		.irq		= MX25_INT_GPIO4,
+		.irq_high	= 0,
+		.virtual_irq_start = MXC_GPIO_IRQ_START + 32 * 3
 	}
 };
 
-struct platform_device mxc_i2c_device0 = {
-	.name = "imx-i2c",
+int __init mxc_register_gpios(void)
+{
+	return mxc_gpio_init(mxc_gpio_ports, ARRAY_SIZE(mxc_gpio_ports));
+}
+
+static struct platform_device mxc_dma_device = {
+	.name = "mxc_dma",
 	.id = 0,
-	.num_resources = ARRAY_SIZE(mxc_i2c_1_resources),
-	.resource = mxc_i2c_1_resources,
 };
 
-static struct resource mxc_i2c_2_resources[] = {
-	{
-		.start	= 0x43f98000,
-		.end	= 0x43f9bfff,
-		.flags	= IORESOURCE_MEM,
-	}, {
-		.start	= 4,
-		.end	= 4,
-		.flags	= IORESOURCE_IRQ,
-	}
-};
+static inline void mxc_init_dma(void)
+{
+	(void)platform_device_register(&mxc_dma_device);
+}
 
-struct platform_device mxc_i2c_device1 = {
-	.name = "imx-i2c",
-	.id = 1,
-	.num_resources = ARRAY_SIZE(mxc_i2c_2_resources),
-	.resource = mxc_i2c_2_resources,
-};
+/* imx adc driver */
+#if defined(CONFIG_IMX_ADC) || defined(CONFIG_IMX_ADC_MODULE)
 
-static struct resource mxc_i2c_3_resources[] = {
+static struct resource imx_adc_resources[] = {
 	{
-		.start	= 0x43f84000,
-		.end	= 0x43f87fff,
+		.start	= MX25_TSC_BASE_ADDR,
+		.end	= MX25_TSC_BASE_ADDR + SZ_4K - 1,
 		.flags	= IORESOURCE_MEM,
 	}, {
-		.start	= 10,
-		.end	= 10,
+		.start	= MX25_INT_TSC,
+		.end	= MX25_INT_TSC,
 		.flags	= IORESOURCE_IRQ,
 	}
 };
 
-struct platform_device mxc_i2c_device2 = {
-	.name = "imx-i2c",
-	.id = 2,
-	.num_resources = ARRAY_SIZE(mxc_i2c_3_resources),
-	.resource = mxc_i2c_3_resources,
+static struct platform_device imx_adc_device = {
+	.name		= "imx_adc",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(imx_adc_resources),
+	.resource	= imx_adc_resources,
 };
 
-static struct mxc_gpio_port imx_gpio_ports[] = {
-	{
-		.chip.label = "gpio-0",
-		.base = (void __iomem *)MX25_GPIO1_BASE_ADDR_VIRT,
-		.irq = 52,
-		.virtual_irq_start = MXC_GPIO_IRQ_START,
-	}, {
-		.chip.label = "gpio-1",
-		.base = (void __iomem *)MX25_GPIO2_BASE_ADDR_VIRT,
-		.irq = 51,
-		.virtual_irq_start = MXC_GPIO_IRQ_START + 32,
-	}, {
-		.chip.label = "gpio-2",
-		.base = (void __iomem *)MX25_GPIO3_BASE_ADDR_VIRT,
-		.irq = 16,
-		.virtual_irq_start = MXC_GPIO_IRQ_START + 64,
-	}, {
-		.chip.label = "gpio-3",
-		.base = (void __iomem *)MX25_GPIO4_BASE_ADDR_VIRT,
-		.irq = 23,
-		.virtual_irq_start = MXC_GPIO_IRQ_START + 96,
-	}
+static void imx_init_adc(void)
+{
+	(void)platform_device_register(&imx_adc_device);
+}
+#else
+static void imx_init_adc(void)
+{
+}
+#endif
+
+static struct platform_device mxc_alsa_surround_device = {
+	.name = "imx-3stack-wm8580",
+	.id = 0,
 };
 
-int __init mxc_register_gpios(void)
+static void mxc_init_surround_audio(void)
 {
-	return mxc_gpio_init(imx_gpio_ports, ARRAY_SIZE(imx_gpio_ports));
+	platform_device_register(&mxc_alsa_surround_device);
 }
 
-static struct resource mx25_fec_resources[] = {
+
+#if defined(CONFIG_SND_MXC_SOC_SSI) || defined(CONFIG_SND_MXC_SOC_SSI_MODULE)
+
+static struct resource ssi1_resources[] = {
 	{
-		.start	= MX25_FEC_BASE_ADDR,
-		.end	= MX25_FEC_BASE_ADDR + 0xfff,
+		.start	= MX25_SSI1_BASE_ADDR,
+		.end	= MX25_SSI1_BASE_ADDR + 0x5C,
 		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.start	= MX25_INT_FEC,
-		.end	= MX25_INT_FEC,
+	}, {
+		.start	= MX25_INT_SSI1,
+		.end	= MX25_INT_SSI1,
 		.flags	= IORESOURCE_IRQ,
 	},
 };
 
-struct platform_device mx25_fec_device = {
-	.name	= "fec",
+static struct platform_device mxc_alsa_ssi1_device = {
+	.name	= "mxc_ssi",
 	.id	= 0,
-	.num_resources	= ARRAY_SIZE(mx25_fec_resources),
-	.resource	= mx25_fec_resources,
+	.resource	= ssi1_resources,
+	.num_resources	= ARRAY_SIZE(ssi1_resources),
 };
 
-static struct resource mxc_nand_resources[] = {
+static struct resource ssi2_resources[] = {
 	{
-		.start	= MX25_NFC_BASE_ADDR,
-		.end	= MX25_NFC_BASE_ADDR + 0x1fff,
+		.start	= MX25_SSI2_BASE_ADDR,
+		.end	= MX25_SSI2_BASE_ADDR + 0x5C,
 		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.start	= MX25_INT_NANDFC,
-		.end	= MX25_INT_NANDFC,
+	}, {
+		.start	= MX25_INT_SSI2,
+		.end	= MX25_INT_SSI2,
 		.flags	= IORESOURCE_IRQ,
 	},
 };
 
-struct platform_device mxc_nand_device = {
-	.name		= "mxc_nand",
-	.id		= 0,
-	.num_resources	= ARRAY_SIZE(mxc_nand_resources),
-	.resource	= mxc_nand_resources,
+static struct platform_device mxc_alsa_ssi2_device = {
+	.name	= "mxc_ssi",
+	.id	= 1,
+	.resource	= ssi2_resources,
+	.num_resources	= ARRAY_SIZE(ssi2_resources),
 };
 
-static struct resource mx25_rtc_resources[] = {
-	{
-		.start	= MX25_DRYICE_BASE_ADDR,
-		.end	= MX25_DRYICE_BASE_ADDR + 0x40,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.start	= MX25_INT_DRYICE,
-		.flags	= IORESOURCE_IRQ
-	},
-};
+static inline void mxc_init_ssi(void)
+{
+	platform_device_register(&mxc_alsa_ssi1_device);
+	platform_device_register(&mxc_alsa_ssi2_device);
+}
+#else
+static inline void mxc_init_ssi(void)
+{
+}
+#endif /* CONFIG_SND_MXC_SOC_SSI */
 
-struct platform_device mx25_rtc_device = {
-	.name	= "imxdi_rtc",
-	.id	= 0,
-	.num_resources	= ARRAY_SIZE(mx25_rtc_resources),
-	.resource	= mx25_rtc_resources,
+#if defined(CONFIG_SND_MXC_SOC_ESAI) || defined(CONFIG_SND_MXC_SOC_ESAI_MODULE)
+
+static struct mxc_esai_platform_data esai_data = {
+	.activate_esai_ports = gpio_activate_esai_ports,
+	.deactivate_esai_ports = gpio_deactivate_esai_ports,
 };
 
-static struct resource mx25_fb_resources[] = {
-	{
-		.start	= MX25_LCDC_BASE_ADDR,
-		.end	= MX25_LCDC_BASE_ADDR + 0xfff,
-		.flags	= IORESOURCE_MEM,
-	},
+static struct resource esai_resources[] = {
 	{
-		.start	= MX25_INT_LCDC,
-		.end	= MX25_INT_LCDC,
-		.flags	= IORESOURCE_IRQ,
+		.start = MX25_ESAI_BASE_ADDR,
+		.end = MX25_ESAI_BASE_ADDR + 0x100,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = MX25_INT_ESAI,
+		.end = MX25_INT_ESAI,
+		.flags = IORESOURCE_IRQ,
 	},
 };
 
-struct platform_device mx25_fb_device = {
-	.name		= "imx-fb",
-	.id		= 0,
-	.resource	= mx25_fb_resources,
-	.num_resources	= ARRAY_SIZE(mx25_fb_resources),
-	.dev		= {
-		.coherent_dma_mask = 0xFFFFFFFF,
+struct platform_device mxc_esai_device = {
+	.name = "mxc_esai",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(esai_resources),
+	.resource = esai_resources,
+	.dev = {
+		.platform_data = &esai_data,
 	},
 };
+
+static void mxc_init_esai(void)
+{
+	platform_device_register(&mxc_esai_device);
+}
+#else
+static void mxc_init_esai(void)
+{
+
+}
+#endif
+
+int __init mxc_init_devices(void)
+{
+	mxc_init_wdt();
+	mxc_init_spi();
+	mxc_init_i2c();
+	mxc_init_dma();
+	mxc_init_ssi();
+	mxc_init_surround_audio();
+	mxc_init_esai();
+	mxc_init_rtc();
+	imx_init_adc();
+
+	return 0;
+}
diff --git a/arch/arm/mach-mx25/devices.h b/arch/arm/mach-mx25/devices.h
deleted file mode 100644
index 39560e1..0000000
--- a/arch/arm/mach-mx25/devices.h
+++ /dev/null
@@ -1,23 +0,0 @@
-extern struct platform_device mxc_uart_device0;
-extern struct platform_device mxc_uart_device1;
-extern struct platform_device mxc_uart_device2;
-extern struct platform_device mxc_uart_device3;
-extern struct platform_device mxc_uart_device4;
-extern struct platform_device mxc_otg;
-extern struct platform_device otg_udc_device;
-extern struct platform_device mxc_usbh2;
-extern struct platform_device mxc_spi_device0;
-extern struct platform_device mxc_spi_device1;
-extern struct platform_device mxc_spi_device2;
-extern struct platform_device mxc_pwm_device0;
-extern struct platform_device mxc_pwm_device1;
-extern struct platform_device mxc_pwm_device2;
-extern struct platform_device mxc_pwm_device3;
-extern struct platform_device mxc_keypad_device;
-extern struct platform_device mxc_i2c_device0;
-extern struct platform_device mxc_i2c_device1;
-extern struct platform_device mxc_i2c_device2;
-extern struct platform_device mx25_fec_device;
-extern struct platform_device mxc_nand_device;
-extern struct platform_device mx25_rtc_device;
-extern struct platform_device mx25_fb_device;
diff --git a/arch/arm/mach-mx25/dma.c b/arch/arm/mach-mx25/dma.c
new file mode 100644
index 0000000..6818c5b
--- /dev/null
+++ b/arch/arm/mach-mx25/dma.c
@@ -0,0 +1,662 @@
+/*
+ *  Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/init.h>
+#include <linux/device.h>
+#include <asm/dma.h>
+#include <mach/hardware.h>
+#include <mach/serial.h>
+
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+#define soc_trans_type	int_2_per
+#else
+#define soc_trans_type	emi_2_per
+#endif
+
+#define MXC_SSI_TX0_REG           0x0
+#define MXC_SSI_TX1_REG           0x4
+#define MXC_SSI_RX0_REG           0x8
+#define MXC_SSI_RX1_REG           0xC
+#define MXC_SSI_TXFIFO_WML        0x4
+#define MXC_SSI_RXFIFO_WML        0x6
+
+#define MXC_ESAI_TX_REG	0x00
+#define MXC_ESAI_RX_REG	0x04
+#define MXC_ESAI_FIFO_WML 0x40
+
+struct mxc_sdma_info_entry_s {
+	mxc_dma_device_t device;
+	mxc_sdma_channel_params_t *chnl_info;
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart1_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART1_UFCR_RXTL,
+			.per_address = MX25_UART1_BASE_ADDR,
+			.peripheral_type = UART,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART1_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART1_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart1_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART1_UFCR_TXTL,
+			.per_address = MX25_UART1_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART1_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART1_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart2_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART2_UFCR_RXTL,
+			.per_address = MX25_UART2_BASE_ADDR,
+			.peripheral_type = UART,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART2_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART2_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart2_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART2_UFCR_TXTL,
+			.per_address = MX25_UART2_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART2_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART2_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart3_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART3_UFCR_RXTL,
+			.per_address = MX25_UART3_BASE_ADDR,
+			.peripheral_type = UART_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART3_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART3_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart3_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART3_UFCR_TXTL,
+			.per_address = MX25_UART3_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART3_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART3_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart4_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART4_UFCR_RXTL,
+			.per_address = MX25_UART4_BASE_ADDR,
+			.peripheral_type = UART_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART4_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART4_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart4_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART4_UFCR_TXTL,
+			.per_address = MX25_UART4_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART4_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART4_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart5_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART5_UFCR_RXTL,
+			.per_address = MX25_UART5_BASE_ADDR,
+			.peripheral_type = UART_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART5_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART5_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart5_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART5_UFCR_TXTL,
+			.per_address = MX25_UART5_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART5_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART5_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX25_SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX0,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX25_SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = soc_trans_type,
+			.event_id = DMA_REQ_SSI1_TX0,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX25_SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX0,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX25_SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = soc_trans_type,
+			.event_id = DMA_REQ_SSI1_TX0,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX25_SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX0,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX25_SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = soc_trans_type,
+			.event_id = DMA_REQ_SSI1_TX0,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX25_SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX25_SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = soc_trans_type,
+			.event_id = DMA_REQ_SSI1_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX25_SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX25_SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = soc_trans_type,
+			.event_id = DMA_REQ_SSI1_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX25_SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX25_SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = soc_trans_type,
+			.event_id = DMA_REQ_SSI1_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX25_SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX0,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX25_SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX0,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX25_SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX0,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX25_SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX0,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX25_SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX0,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX25_SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX0,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX25_SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX25_SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX25_SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX25_SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = MX25_SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = MX25_SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+	.chnl_priority = 2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_memory_params = {
+	.chnl_params = {
+			.peripheral_type = MEMORY,
+			.transfer_type = emi_2_emi,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_MEMORY,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_esai_16bit_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ESAI_FIFO_WML,
+			.per_address = MX25_ESAI_BASE_ADDR + MXC_ESAI_RX_REG,
+			.peripheral_type = ESAI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_ESAI_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ESAI_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_esai_16bit_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ESAI_FIFO_WML,
+			.per_address = MX25_ESAI_BASE_ADDR + MXC_ESAI_TX_REG,
+			.peripheral_type = ESAI,
+			.transfer_type = soc_trans_type,
+			.event_id = DMA_REQ_ESAI_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ESAI_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_esai_24bit_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ESAI_FIFO_WML,
+			.per_address = MX25_ESAI_BASE_ADDR + MXC_ESAI_RX_REG,
+			.peripheral_type = ESAI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_ESAI_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ESAI_RX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_esai_24bit_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_ESAI_FIFO_WML,
+			.per_address = MX25_ESAI_BASE_ADDR + MXC_ESAI_TX_REG,
+			.peripheral_type = ESAI,
+			.transfer_type = soc_trans_type,
+			.event_id = DMA_REQ_ESAI_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ESAI_TX,
+	.chnl_priority = MXC_SDMA_DEFAULT_PRIORITY,
+};
+
+static struct mxc_sdma_info_entry_s mxc_sdma_active_dma_info[] = {
+	{MXC_DMA_UART1_RX, &mxc_sdma_uart1_rx_params},
+	{MXC_DMA_UART1_TX, &mxc_sdma_uart1_tx_params},
+	{MXC_DMA_UART2_RX, &mxc_sdma_uart2_rx_params},
+	{MXC_DMA_UART2_TX, &mxc_sdma_uart2_tx_params},
+	{MXC_DMA_UART3_RX, &mxc_sdma_uart3_rx_params},
+	{MXC_DMA_UART3_TX, &mxc_sdma_uart3_tx_params},
+	{MXC_DMA_UART4_RX, &mxc_sdma_uart4_rx_params},
+	{MXC_DMA_UART4_TX, &mxc_sdma_uart4_tx_params},
+	{MXC_DMA_UART5_RX, &mxc_sdma_uart5_rx_params},
+	{MXC_DMA_UART5_TX, &mxc_sdma_uart5_tx_params},
+	{MXC_DMA_SSI1_8BIT_RX0, &mxc_sdma_ssi1_8bit_rx0_params},
+	{MXC_DMA_SSI1_8BIT_TX0, &mxc_sdma_ssi1_8bit_tx0_params},
+	{MXC_DMA_SSI1_16BIT_RX0, &mxc_sdma_ssi1_16bit_rx0_params},
+	{MXC_DMA_SSI1_16BIT_TX0, &mxc_sdma_ssi1_16bit_tx0_params},
+	{MXC_DMA_SSI1_24BIT_RX0, &mxc_sdma_ssi1_24bit_rx0_params},
+	{MXC_DMA_SSI1_24BIT_TX0, &mxc_sdma_ssi1_24bit_tx0_params},
+	{MXC_DMA_SSI1_8BIT_RX1, &mxc_sdma_ssi1_8bit_rx1_params},
+	{MXC_DMA_SSI1_8BIT_TX1, &mxc_sdma_ssi1_8bit_tx1_params},
+	{MXC_DMA_SSI1_16BIT_RX1, &mxc_sdma_ssi1_16bit_rx1_params},
+	{MXC_DMA_SSI1_16BIT_TX1, &mxc_sdma_ssi1_16bit_tx1_params},
+	{MXC_DMA_SSI1_24BIT_RX1, &mxc_sdma_ssi1_24bit_rx1_params},
+	{MXC_DMA_SSI1_24BIT_TX1, &mxc_sdma_ssi1_24bit_tx1_params},
+	{MXC_DMA_SSI2_8BIT_RX0, &mxc_sdma_ssi2_8bit_rx0_params},
+	{MXC_DMA_SSI2_8BIT_TX0, &mxc_sdma_ssi2_8bit_tx0_params},
+	{MXC_DMA_SSI2_16BIT_RX0, &mxc_sdma_ssi2_16bit_rx0_params},
+	{MXC_DMA_SSI2_16BIT_TX0, &mxc_sdma_ssi2_16bit_tx0_params},
+	{MXC_DMA_SSI2_24BIT_RX0, &mxc_sdma_ssi2_24bit_rx0_params},
+	{MXC_DMA_SSI2_24BIT_TX0, &mxc_sdma_ssi2_24bit_tx0_params},
+	{MXC_DMA_SSI2_8BIT_RX1, &mxc_sdma_ssi2_8bit_rx1_params},
+	{MXC_DMA_SSI2_8BIT_TX1, &mxc_sdma_ssi2_8bit_tx1_params},
+	{MXC_DMA_SSI2_16BIT_RX1, &mxc_sdma_ssi2_16bit_rx1_params},
+	{MXC_DMA_SSI2_16BIT_TX1, &mxc_sdma_ssi2_16bit_tx1_params},
+	{MXC_DMA_SSI2_24BIT_RX1, &mxc_sdma_ssi2_24bit_rx1_params},
+	{MXC_DMA_SSI2_24BIT_TX1, &mxc_sdma_ssi2_24bit_tx1_params},
+	{MXC_DMA_ESAI_16BIT_RX, &mxc_sdma_esai_16bit_rx_params},
+	{MXC_DMA_ESAI_16BIT_TX, &mxc_sdma_esai_16bit_tx_params},
+	{MXC_DMA_ESAI_24BIT_RX, &mxc_sdma_esai_24bit_rx_params},
+	{MXC_DMA_ESAI_24BIT_TX, &mxc_sdma_esai_24bit_tx_params},
+	{MXC_DMA_MEMORY, &mxc_sdma_memory_params},
+};
+
+static int mxc_sdma_info_entrys =
+    sizeof(mxc_sdma_active_dma_info) / sizeof(mxc_sdma_active_dma_info[0]);
+/*!
+ * This functions Returns the SDMA paramaters associated for a module
+ *
+ * @param channel_id the ID of the module requesting DMA
+ * @return returns the sdma parameters structure for the device
+ */
+mxc_sdma_channel_params_t *mxc_sdma_get_channel_params(mxc_dma_device_t
+						       channel_id)
+{
+	struct mxc_sdma_info_entry_s *p = mxc_sdma_active_dma_info;
+	int i;
+
+	for (i = 0; i < mxc_sdma_info_entrys; i++, p++) {
+		if (p->device == channel_id)
+			return p->chnl_info;
+	}
+	return NULL;
+}
+EXPORT_SYMBOL(mxc_sdma_get_channel_params);
+
+/*!
+ * This functions marks the SDMA channels that are statically allocated
+ *
+ * @param chnl the channel array used to store channel information
+ */
+void mxc_get_static_channels(mxc_dma_channel_t *chnl)
+{
+#ifdef CONFIG_SDMA_IRAM
+	int i;
+	for (i = MXC_DMA_CHANNEL_IRAM; i < MAX_DMA_CHANNELS; i++)
+		chnl[i].dynamic = 0;
+#endif
+}
+EXPORT_SYMBOL(mxc_get_static_channels);
diff --git a/arch/arm/mach-mx25/include/mach/board-mx25_3stack.h b/arch/arm/mach-mx25/include/mach/board-mx25_3stack.h
new file mode 100644
index 0000000..6c5e3f7
--- /dev/null
+++ b/arch/arm/mach-mx25/include/mach/board-mx25_3stack.h
@@ -0,0 +1,172 @@
+/*
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_BOARD_MX25_3STACK_H__
+#define __ASM_ARCH_MXC_BOARD_MX25_3STACK_H__
+
+#ifdef CONFIG_MACH_MX25_3DS
+
+/*!
+ * @defgroup BRDCFG_MX25 Board Configuration Options
+ * @ingroup MSL_MX25
+ */
+
+/*!
+ * @file mach-mx25/board-mx25_3stack.h
+ *
+ * @brief This file contains all the board level configuration options.
+ *
+ * It currently hold the options defined for MX25 3STACK Platform.
+ *
+ * @ingroup BRDCFG_MX25
+ */
+
+/*
+ * Include Files
+ */
+#include <mach/mxc_uart.h>
+#include <linux/fsl_devices.h>
+/*!
+ * @name MXC UART board-level configurations
+ */
+/*! @{ */
+/* UART 1 configuration */
+/*!
+ * This define specifies if the UART port is configured to be in DTE or
+ * DCE mode. There exists a define like this for each UART port. Valid
+ * values that can be used are \b MODE_DTE or \b MODE_DCE.
+ */
+#define UART1_MODE              MODE_DCE
+/*!
+ * This define specifies if the UART is to be used for IRDA. There exists a
+ * define like this for each UART port. Valid values that can be used are
+ * \b IRDA or \b NO_IRDA.
+ */
+#define UART1_IR                NO_IRDA
+/*!
+ * This define is used to enable or disable a particular UART port. If
+ * disabled, the UART will not be registered in the file system and the user
+ * will not be able to access it. There exists a define like this for each UART
+ * port. Specify a value of 1 to enable the UART and 0 to disable it.
+ */
+#define UART1_ENABLED           1
+/*! @} */
+/* UART 2 configuration */
+#define UART2_MODE              MODE_DCE
+#define UART2_IR                NO_IRDA
+#define UART2_ENABLED           1
+
+/* UART 3 configuration */
+#define UART3_MODE              MODE_DTE
+#define UART3_IR                NO_IRDA
+#define UART3_ENABLED           0
+
+/* UART 4 configuration */
+#define UART4_MODE              MODE_DTE
+#define UART4_IR                NO_IRDA
+#define UART4_ENABLED           0
+
+/* UART 5 configuration */
+#define UART5_MODE              MODE_DTE
+#define UART5_IR                NO_IRDA
+#define UART5_ENABLED           0
+
+#define MXC_LL_UART_PADDR	UART1_BASE_ADDR
+#define MXC_LL_UART_VADDR	AIPS1_IO_ADDRESS(UART1_BASE_ADDR)
+
+/*!
+ * @name debug board parameters
+ */
+/*! @{ */
+/*!
+ * Base address of debug board
+ */
+#define DEBUG_BASE_ADDRESS      0x78000000	/* Use a dummy base address */
+
+/* External ethernet LAN9217 base address */
+#define LAN9217_BASE_ADDR       DEBUG_BASE_ADDRESS
+
+/* External UART */
+#define UARTA_BASE_ADDR		(DEBUG_BASE_ADDRESS + 0x08000)
+#define UARTB_BASE_ADDR		(DEBUG_BASE_ADDRESS + 0x10000)
+
+#define BOARD_IO_ADDR		0x20000
+
+/* LED switchs */
+#define LED_SWITCH_REG		(BOARD_IO_ADDR + 0x00)
+/* buttons */
+#define SWITCH_BUTTON_REG	(BOARD_IO_ADDR + 0x08)
+/* status, interrupt */
+#define INTR_STATUS_REG		(BOARD_IO_ADDR + 0x10)
+#define INTR_RESET_REG		(BOARD_IO_ADDR + 0x20)
+/*CPLD configuration*/
+#define CONFIG1_REG		(BOARD_IO_ADDR + 0x28)
+#define CONFIG2_REG		(BOARD_IO_ADDR + 0x30)
+/*interrupt mask */
+#define INTR_MASK_REG		(BOARD_IO_ADDR + 0x38)
+
+/* magic word for debug CPLD */
+#define MAGIC_NUMBER1_REG	(BOARD_IO_ADDR + 0x40)
+#define	MAGIC_NUMBER2_REG	(BOARD_IO_ADDR + 0x48)
+/* CPLD code version */
+#define CPLD_CODE_VER_REG       (BOARD_IO_ADDR + 0x50)
+/* magic word for debug CPLD */
+#define MAGIC3_NUMBER3_REG	(BOARD_IO_ADDR + 0x58)
+/* module reset register*/
+#define CONTROL_REG		(BOARD_IO_ADDR + 0x60)
+/* CPU ID and Personality ID*/
+#define IDENT_REG		(BOARD_IO_ADDR + 0x68)
+
+/* For interrupts like xuart, enet etc */
+#define EXPIO_PARENT_INT        MX25_PIN_GPIO1_1
+
+#define EXPIO_INT_ENET_INT          (MXC_BOARD_IRQ_START + 0)
+#define EXPIO_INT_XUARTA_INT        (MXC_BOARD_IRQ_START + 1)
+#define EXPIO_INT_XUARTB_INT        (MXC_BOARD_IRQ_START + 2)
+
+/*! This is System IRQ used by LAN9217 for interrupt generation taken
+ * from platform.h
+ */
+#define LAN9217_IRQ              EXPIO_INT_ENET_INT
+
+/*! This is base virtual address of debug board*/
+extern unsigned int mx25_3stack_board_io;
+
+#define MXC_BD_LED1             (1 << 0)
+#define MXC_BD_LED2             (1 << 1)
+#define MXC_BD_LED3             (1 << 2)
+#define MXC_BD_LED4             (1 << 3)
+#define MXC_BD_LED5             (1 << 4)
+#define MXC_BD_LED6             (1 << 5)
+#define MXC_BD_LED7             (1 << 6)
+#define MXC_BD_LED8             (1 << 7)
+#define MXC_BD_LED_ON(led)
+#define MXC_BD_LED_OFF(led)
+
+#define MXC_DEFAULT_INTENSITY	127
+#define MXC_INTENSITY_OFF	0
+
+extern void mx25_3stack_gpio_init(void) __init;
+extern int headphone_det_status(void);
+extern void sgtl5000_enable_amp(void);
+extern unsigned int sdhc_get_card_det_status(struct device *dev);
+extern int sdhc_write_protect(struct device *dev);
+extern void gpio_can_active(int id);
+extern void gpio_can_inactive(int id);
+extern struct flexcan_platform_data flexcan_data[];
+extern void mx2fb_set_brightness(uint8_t);
+extern int __init mx25_3stack_init_mc34704(void);
+extern void imx_adc_set_hsync(int on);
+
+#endif				/* CONFIG_MACH_MX25_3DS */
+#endif				/* __ASM_ARCH_MXC_BOARD_MX25_3STACK_H__ */
diff --git a/arch/arm/mach-mx25/include/mach/crm_regs.h b/arch/arm/mach-mx25/include/mach/crm_regs.h
new file mode 100644
index 0000000..1a82bb9
--- /dev/null
+++ b/arch/arm/mach-mx25/include/mach/crm_regs.h
@@ -0,0 +1,215 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ARCH_ARM_MACH_MX25_CRM_REGS_H__
+#define __ARCH_ARM_MACH_MX25_CRM_REGS_H__
+
+#include <mach/hardware.h>
+
+#define MXC_CCM_BASE			((char *)IO_ADDRESS(MX25_CRM_BASE_ADDR))
+
+/* Register offsets */
+#define MXC_CCM_MPCTL               (MXC_CCM_BASE + 0x00)
+#define MXC_CCM_UPCTL               (MXC_CCM_BASE + 0x04)
+#define MXC_CCM_CCTL                (MXC_CCM_BASE + 0x08)
+#define MXC_CCM_CGCR0               (MXC_CCM_BASE + 0x0C)
+#define MXC_CCM_CGCR1               (MXC_CCM_BASE + 0x10)
+#define MXC_CCM_CGCR2               (MXC_CCM_BASE + 0x14)
+#define MXC_CCM_PCDR0               (MXC_CCM_BASE + 0x18)
+#define MXC_CCM_PCDR1               (MXC_CCM_BASE + 0x1C)
+#define MXC_CCM_PCDR2               (MXC_CCM_BASE + 0x20)
+#define MXC_CCM_PCDR3               (MXC_CCM_BASE + 0x24)
+#define MXC_CCM_RCSR                (MXC_CCM_BASE + 0x28)
+#define MXC_CCM_CRDR                (MXC_CCM_BASE + 0x2C)
+#define MXC_CCM_DCVR0               (MXC_CCM_BASE + 0x30)
+#define MXC_CCM_DCVR1               (MXC_CCM_BASE + 0x34)
+#define MXC_CCM_DCVR2               (MXC_CCM_BASE + 0x38)
+#define MXC_CCM_DCVR3               (MXC_CCM_BASE + 0x3C)
+#define MXC_CCM_LTR0                (MXC_CCM_BASE + 0x40)
+#define MXC_CCM_LTR1                (MXC_CCM_BASE + 0x44)
+#define MXC_CCM_LTR2                (MXC_CCM_BASE + 0x48)
+#define MXC_CCM_LTR3                (MXC_CCM_BASE + 0x4C)
+#define MXC_CCM_LTBR0               (MXC_CCM_BASE + 0x50)
+#define MXC_CCM_LTBR1               (MXC_CCM_BASE + 0x54)
+#define MXC_CCM_PMCR0               (MXC_CCM_BASE + 0x58)
+#define MXC_CCM_PMCR1               (MXC_CCM_BASE + 0x5C)
+#define MXC_CCM_PMCR2               (MXC_CCM_BASE + 0x60)
+#define MXC_CCM_MCR                 (MXC_CCM_BASE + 0x64)
+#define MXC_CCM_LPIMR0              (MXC_CCM_BASE + 0x68)
+#define MXC_CCM_LPIMR1              (MXC_CCM_BASE + 0x6C)
+
+#define MXC_CCM_MPCTL_BRMO          (1 << 31)
+#define MXC_CCM_MPCTL_PD_OFFSET     26
+#define MXC_CCM_MPCTL_PD_MASK       (0xf << 26)
+#define MXC_CCM_MPCTL_MFD_OFFSET    16
+#define MXC_CCM_MPCTL_MFD_MASK      (0x3ff << 16)
+#define MXC_CCM_MPCTL_MFI_OFFSET    10
+#define MXC_CCM_MPCTL_MFI_MASK      (0xf << 10)
+#define MXC_CCM_MPCTL_MFN_OFFSET    0
+#define MXC_CCM_MPCTL_MFN_MASK      0x3ff
+#define MXC_CCM_MPCTL_LF            (1 << 15)
+
+#define MXC_CCM_UPCTL_BRMO          (1 << 31)
+#define MXC_CCM_UPCTL_PD_OFFSET     26
+#define MXC_CCM_UPCTL_PD_MASK       (0xf << 26)
+#define MXC_CCM_UPCTL_MFD_OFFSET    16
+#define MXC_CCM_UPCTL_MFD_MASK      (0x3ff << 16)
+#define MXC_CCM_UPCTL_MFI_OFFSET    10
+#define MXC_CCM_UPCTL_MFI_MASK      (0xf << 10)
+#define MXC_CCM_UPCTL_MFN_OFFSET    0
+#define MXC_CCM_UPCTL_MFN_MASK      0x3ff
+#define MXC_CCM_UPCTL_LF            (1 << 15)
+
+#define MXC_CCM_CCTL_ARM_OFFSET     30
+#define MXC_CCM_CCTL_ARM_MASK       (0x3 << 30)
+#define MXC_CCM_CCTL_AHB_OFFSET     28
+#define MXC_CCM_CCTL_AHB_MASK       (0x3 << 28)
+#define MXC_CCM_CCTL_MPLL_RST       (1 << 27)
+#define MXC_CCM_CCTL_UPLL_RST       (1 << 26)
+#define MXC_CCM_CCTL_LP_CTL_OFFSET  24
+#define MXC_CCM_CCTL_LP_CTL_MASK    (0x3 << 24)
+#define MXC_CCM_CCTL_LP_MODE_RUN    (0x0 << 24)
+#define MXC_CCM_CCTL_LP_MODE_WAIT   (0x1 << 24)
+#define MXC_CCM_CCTL_LP_MODE_DOZE   (0x2 << 24)
+#define MXC_CCM_CCTL_LP_MODE_STOP   (0x3 << 24)
+#define MXC_CCM_CCTL_UPLL_DISABLE   (1 << 23)
+#define MXC_CCM_CCTL_MPLL_BYPASS    (1 << 22)
+#define MXC_CCM_CCTL_USB_DIV_OFFSET 16
+#define MXC_CCM_CCTL_USB_DIV_MASK   (0x3 << 16)
+#define MXC_CCM_CCTL_CG_CTRL        (1 << 15)
+#define MXC_CCM_CCTL_ARM_SRC        (1 << 14)
+#define MXC_CCM_CCTL_ARM_SRC_OFFSET	14
+
+#define MXC_CCM_CGCR0_HCLK_ATA_OFFSET    16
+#define MXC_CCM_CGCR0_HCLK_BROM_OFFSET   17
+#define MXC_CCM_CGCR0_HCLK_CSI_OFFSET    18
+#define MXC_CCM_CGCR0_HCLK_EMI_OFFSET    19
+#define MXC_CCM_CGCR0_HCLK_ESAI_OFFSET   20
+#define MXC_CCM_CGCR0_HCLK_ESDHC1_OFFSET 21
+#define MXC_CCM_CGCR0_HCLK_ESDHC2_OFFSET 22
+#define MXC_CCM_CGCR0_HCLK_FEC_OFFSET    23
+#define MXC_CCM_CGCR0_HCLK_LCDC_OFFSET   24
+#define MXC_CCM_CGCR0_HCLK_RTIC_OFFSET   25
+#define MXC_CCM_CGCR0_HCLK_SDMA_OFFSET   26
+#define MXC_CCM_CGCR0_HCLK_SLCDC_OFFSET  27
+#define MXC_CCM_CGCR0_HCLK_USBOTG_OFFSET 28
+
+#define MXC_CCM_CGCR0_PER_CSI_OFFSET     0
+#define MXC_CCM_CGCR0_PER_EPIT_OFFSET    1
+#define MXC_CCM_CGCR0_PER_ESAI_OFFSET    2
+#define MXC_CCM_CGCR0_PER_ESDHC1_OFFSET  3
+#define MXC_CCM_CGCR0_PER_ESDHC2_OFFSET  4
+#define MXC_CCM_CGCR0_PER_GPT_OFFSET     5
+#define MXC_CCM_CGCR0_PER_I2C_OFFSET     6
+#define MXC_CCM_CGCR0_PER_LCDC_OFFSET    7
+#define MXC_CCM_CGCR0_PER_NFC_OFFSET     8
+#define MXC_CCM_CGCR0_PER_OWIRE_OFFSET   9
+#define MXC_CCM_CGCR0_PER_PWM_OFFSET     10
+#define MXC_CCM_CGCR0_PER_SIM1_OFFSET    11
+#define MXC_CCM_CGCR0_PER_SIM2_OFFSET    12
+#define MXC_CCM_CGCR0_PER_SSI1_OFFSET    13
+#define MXC_CCM_CGCR0_PER_SSI2_OFFSET    14
+#define MXC_CCM_CGCR0_PER_UART_OFFSET    15
+
+#define MXC_CCM_CGCR1_AUDMUX_OFFSET      0
+#define MXC_CCM_CGCR1_ATA_OFFSET         1
+#define MXC_CCM_CGCR1_CAN1_OFFSET        2
+#define MXC_CCM_CGCR1_CAN2_OFFSET        3
+#define MXC_CCM_CGCR1_CSI_OFFSET         4
+#define MXC_CCM_CGCR1_CSPI1_OFFSET       5
+#define MXC_CCM_CGCR1_CSPI2_OFFSET       6
+#define MXC_CCM_CGCR1_CSPI3_OFFSET       7
+#define MXC_CCM_CGCR1_DRYICE_OFFSET      8
+#define MXC_CCM_CGCR1_ECT_OFFSET         9
+#define MXC_CCM_CGCR1_EPIT1_OFFSET       10
+#define MXC_CCM_CGCR1_EPIT2_OFFSET       11
+#define MXC_CCM_CGCR1_ESAI_OFFSET        12
+#define MXC_CCM_CGCR1_ESDHC1_OFFSET      13
+#define MXC_CCM_CGCR1_ESDHC2_OFFSET      14
+#define MXC_CCM_CGCR1_FEC_OFFSET         15
+#define MXC_CCM_CGCR1_GPIO1_OFFSET       16
+#define MXC_CCM_CGCR1_GPIO2_OFFSET       17
+#define MXC_CCM_CGCR1_GPIO3_OFFSET       18
+#define MXC_CCM_CGCR1_GPT1_OFFSET        19
+#define MXC_CCM_CGCR1_GPT2_OFFSET        20
+#define MXC_CCM_CGCR1_GPT3_OFFSET        21
+#define MXC_CCM_CGCR1_GPT4_OFFSET        22
+#define MXC_CCM_CGCR1_I2C1_OFFSET        23
+#define MXC_CCM_CGCR1_I2C2_OFFSET        24
+#define MXC_CCM_CGCR1_I2C3_OFFSET        25
+#define MXC_CCM_CGCR1_IIM_OFFSET         26
+#define MXC_CCM_CGCR1_IOMUXC_OFFSET      27
+#define MXC_CCM_CGCR1_KPP_OFFSET         28
+#define MXC_CCM_CGCR1_LCDC_OFFSET        29
+#define MXC_CCM_CGCR1_OWIRE_OFFSET       30
+#define MXC_CCM_CGCR1_PWM1_OFFSET        31
+
+#define MXC_CCM_CGCR2_PWM2_OFFSET        (32-32)
+#define MXC_CCM_CGCR2_PWM3_OFFSET        (33-32)
+#define MXC_CCM_CGCR2_PWM4_OFFSET        (34-32)
+#define MXC_CCM_CGCR2_RNGB_OFFSET        (35-32)
+#define MXC_CCM_CGCR2_RTIC_OFFSET        (36-32)
+#define MXC_CCM_CGCR2_SCC_OFFSET         (37-32)
+#define MXC_CCM_CGCR2_SDMA_OFFSET        (38-32)
+#define MXC_CCM_CGCR2_SIM1_OFFSET        (39-32)
+#define MXC_CCM_CGCR2_SIM2_OFFSET        (40-32)
+#define MXC_CCM_CGCR2_SLCDC_OFFSET       (41-32)
+#define MXC_CCM_CGCR2_SPBA_OFFSET        (42-32)
+#define MXC_CCM_CGCR2_SSI1_OFFSET        (43-32)
+#define MXC_CCM_CGCR2_SSI2_OFFSET        (44-32)
+#define MXC_CCM_CGCR2_TCHSCRN_OFFSET     (45-32)
+#define MXC_CCM_CGCR2_UART1_OFFSET       (46-32)
+#define MXC_CCM_CGCR2_UART2_OFFSET       (47-32)
+#define MXC_CCM_CGCR2_UART3_OFFSET       (48-32)
+#define MXC_CCM_CGCR2_UART4_OFFSET       (49-32)
+#define MXC_CCM_CGCR2_UART5_OFFSET       (50-32)
+#define MXC_CCM_CGCR2_WDOG_OFFSET        (51-32)
+
+#define MXC_CCM_CGCR0_STOP_MODE_MASK	\
+			((1 << MXC_CCM_CGCR0_HCLK_SLCDC_OFFSET) | \
+			 (1 << MXC_CCM_CGCR0_HCLK_RTIC_OFFSET) | \
+			 (1 << MXC_CCM_CGCR0_HCLK_EMI_OFFSET) | \
+			 (1 << MXC_CCM_CGCR0_HCLK_BROM_OFFSET))
+
+#define MXC_CCM_CGCR1_STOP_MODE_MASK	((1 << MXC_CCM_CGCR1_IIM_OFFSET) | \
+					 (1 << MXC_CCM_CGCR1_CAN2_OFFSET) | \
+					 (1 << MXC_CCM_CGCR1_CAN1_OFFSET))
+
+#define MXC_CCM_CGCR2_STOP_MODE_MASK	((1 << MXC_CCM_CGCR2_SPBA_OFFSET) | \
+					 (1 << MXC_CCM_CGCR2_SDMA_OFFSET) | \
+					 (1 << MXC_CCM_CGCR2_RTIC_OFFSET))
+
+#define MXC_CCM_PCDR1_PERDIV1_MASK       0x3f
+
+#define MXC_CCM_RCSR_NF16B               (1 << 14)
+
+#define MXC_CCM_PMCR2_VSTBY		(1 << 17)
+#define MXC_CCM_PMCR2_OSC24M_DOWN	(1 << 16)
+
+#define MXC_CCM_MCR_USB_XTAL_MUX_OFFSET  31
+#define MXC_CCM_MCR_CLKO_EN_OFFSET       30
+#define MXC_CCM_MCR_CLKO_DIV_OFFSET      24
+#define MXC_CCM_MCR_CLKO_DIV_MASK        (0x3F << 24)
+#define MXC_CCM_MCR_CLKO_SEL_OFFSET      20
+#define MXC_CCM_MCR_CLKO_SEL_MASK        (0xF << 20)
+#define MXC_CCM_MCR_ESAI_CLK_MUX_OFFSET  19
+#define MXC_CCM_MCR_SSI2_CLK_MUX_OFFSET  18
+#define MXC_CCM_MCR_SSI1_CLK_MUX_OFFSET  17
+#define MXC_CCM_MCR_USB_CLK_MUX_OFFSET   16
+
+#define MXC_CCM_MCR_PER_CLK_MUX_MASK     (0xFFFF << 0)
+
+#define MXC_CCM_LPIMR0_MASK		0xFFFFFFFF
+#define MXC_CCM_LPIMR1_MASK		0xFFFFFFFF
+
+#endif				/* __ARCH_ARM_MACH_MX25_CRM_REGS_H__ */
diff --git a/arch/arm/mach-mx25/include/mach/devices.h b/arch/arm/mach-mx25/include/mach/devices.h
new file mode 100644
index 0000000..cee12c0
--- /dev/null
+++ b/arch/arm/mach-mx25/include/mach/devices.h
@@ -0,0 +1,24 @@
+extern struct platform_device mxc_uart_device0;
+extern struct platform_device mxc_uart_device1;
+extern struct platform_device mxc_uart_device2;
+extern struct platform_device mxc_uart_device3;
+extern struct platform_device mxc_uart_device4;
+extern struct platform_device mxc_otg;
+extern struct platform_device otg_udc_device;
+extern struct platform_device mxc_usbh2;
+extern struct platform_device mxc_spi_device0;
+extern struct platform_device mxc_spi_device1;
+extern struct platform_device mxc_spi_device2;
+extern struct platform_device mxc_pwm_device0;
+extern struct platform_device mxc_pwm_device1;
+extern struct platform_device mxc_pwm_device2;
+extern struct platform_device mxc_pwm_device3;
+extern struct platform_device mxc_keypad_device;
+extern struct platform_device mxc_i2c_device0;
+extern struct platform_device mxc_i2c_device1;
+extern struct platform_device mxc_i2c_device2;
+extern struct platform_device mx25_fec_device;
+extern struct platform_device mxc_nand_device;
+extern struct platform_device mx25_rtc_device;
+extern struct platform_device mx25_fb_device;
+extern struct platform_device mxc_wdt;
diff --git a/arch/arm/mach-mx25/include/mach/sdma_script_code.h b/arch/arm/mach-mx25/include/mach/sdma_script_code.h
new file mode 100644
index 0000000..6adacb0
--- /dev/null
+++ b/arch/arm/mach-mx25/include/mach/sdma_script_code.h
@@ -0,0 +1,158 @@
+/*
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*!
+ * @file sdma_script_code.h
+ * @brief This file contains functions of SDMA scripts code initialization
+ *
+ * The file was generated automatically. Based on sdma scripts library.
+ *
+ * @ingroup SDMA
+ */
+/************************************************************************
+
+			SDMA RELEASE LABEL:	"SS15_SENNA"
+
+************************************************************************/
+
+#ifndef SDMA_SCRIPT_CODE_H
+#define SDMA_SCRIPT_CODE_H
+
+/*!
+ * SDMA ROM scripts start addresses and sizes
+ */
+#define start_ADDR	0
+#define start_SIZE	22
+
+#define core_ADDR	80
+#define core_SIZE	233
+
+#define common_ADDR	313
+#define common_SIZE	416
+
+#define ap_2_ap_ADDR	729
+#define ap_2_ap_SIZE	41
+
+#define app_2_mcu_ADDR	770
+#define app_2_mcu_SIZE	64
+
+#define mcu_2_app_ADDR	834
+#define mcu_2_app_SIZE	70
+
+#define uart_2_mcu_ADDR	904
+#define uart_2_mcu_SIZE	75
+
+#define shp_2_mcu_ADDR	979
+#define shp_2_mcu_SIZE	69
+
+#define mcu_2_shp_ADDR	1048
+#define mcu_2_shp_SIZE	72
+
+#define uartsh_2_mcu_ADDR	1120
+#define uartsh_2_mcu_SIZE	69
+
+#define app_2_per_ADDR	1189
+#define app_2_per_SIZE	66
+
+#define per_2_app_ADDR	1255
+#define per_2_app_SIZE	74
+
+#define per_2_shp_ADDR	1329
+#define per_2_shp_SIZE	78
+
+#define shp_2_per_ADDR	1407
+#define shp_2_per_SIZE	72
+
+#define mcu_2_ata_ADDR	1479
+#define mcu_2_ata_SIZE	81
+
+#define ata_2_mcu_ADDR	1560
+#define ata_2_mcu_SIZE	96
+
+#define loop_DMAs_routines_ADDR	1656
+#define loop_DMAs_routines_SIZE	227
+
+#define test_ADDR	1883
+#define test_SIZE	63
+
+#define signature_ADDR	1022
+#define signature_SIZE	1
+
+/*!
+ * SDMA RAM scripts start addresses and sizes
+ */
+#define ext_mem__ipu_ram_ADDR	6144
+#define ext_mem__ipu_ram_SIZE	123
+
+#define uart_2_per_ADDR	6267
+#define uart_2_per_SIZE	73
+
+#define uartsh_2_per_ADDR	6340
+#define uartsh_2_per_SIZE	67
+
+/*!
+ * SDMA RAM image start address and size
+ */
+#define RAM_CODE_START_ADDR		6144
+#define RAM_CODE_SIZE			263
+
+/*!
+ * Buffer that holds the SDMA RAM image
+ */
+__attribute__ ((__aligned__(4)))
+#ifndef CONFIG_XIP_KERNEL
+const
+#endif
+static const short sdma_code[] = {
+	0x0e70, 0x0611, 0x5616, 0xc18a, 0x7d2a, 0x5ade, 0x008e, 0xc19c,
+	0x7c26, 0x5be0, 0x5ef0, 0x5ce8, 0x0688, 0x08ff, 0x0011, 0x28ff,
+	0x00bc, 0x53f6, 0x05df, 0x7d0b, 0x6dc5, 0x03df, 0x7d03, 0x6bd5,
+	0xd84f, 0x982b, 0x6b05, 0xc6d8, 0x7e27, 0x7f29, 0x982b, 0x6d01,
+	0x03df, 0x7d05, 0x6bd5, 0xc702, 0x7e18, 0x7f1a, 0x982b, 0x6b05,
+	0xc678, 0x7e07, 0x7f06, 0x52de, 0x53e6, 0xc1a8, 0x7dd7, 0x0200,
+	0x9803, 0x0007, 0x6004, 0x680c, 0x53f6, 0x028e, 0x00a3, 0xc2ad,
+	0x048b, 0x0498, 0x0454, 0x068a, 0x982b, 0x0207, 0x680c, 0x6ddf,
+	0x0107, 0x68ff, 0x60d0, 0x9834, 0x0207, 0x68ff, 0x6d28, 0x0107,
+	0x6004, 0x680c, 0x9834, 0x0007, 0x68ff, 0x60d0, 0x9834, 0x0288,
+	0x03a5, 0x3b03, 0x3d03, 0x4d00, 0x7d0a, 0x0804, 0x00a5, 0x00da,
+	0x7d1a, 0x02a0, 0x7b01, 0x65d8, 0x7eee, 0x65ff, 0x7eec, 0x0804,
+	0x02d0, 0x7d11, 0x4b00, 0x7c0f, 0x008a, 0x3003, 0x6dcf, 0x6bdf,
+	0x0015, 0x0015, 0x7b02, 0x65d8, 0x0000, 0x7edd, 0x63ff, 0x7edb,
+	0x3a03, 0x6dcd, 0x6bdd, 0x008a, 0x7b02, 0x65d8, 0x0000, 0x7ed3,
+	0x65ff, 0x7ed1, 0x0006, 0xc23a, 0x57db, 0x52f3, 0x6ad5, 0x56fb,
+	0x028e, 0x1a94, 0x6ac3, 0x62c8, 0x0269, 0x7d1e, 0x1e94, 0x6ee3,
+	0x62d0, 0x5aeb, 0x62c8, 0x0248, 0x6ed3, 0x6ac8, 0x2694, 0x52eb,
+	0x6ad5, 0x6ee3, 0x62c8, 0x026e, 0x7d27, 0x6ac8, 0x7f23, 0x2501,
+	0x4d00, 0x7d26, 0x028e, 0x1a98, 0x6ac3, 0x62c8, 0x6ec3, 0x0260,
+	0x7df1, 0x62d0, 0xc2d1, 0x98c0, 0x6ee3, 0x008f, 0x2001, 0x00d5,
+	0x7d01, 0x008d, 0x05a0, 0x62c8, 0x026e, 0x7d0e, 0x6ac8, 0x7f0a,
+	0x2001, 0x7cf9, 0x6add, 0x7f06, 0x0000, 0x4d00, 0x7d09, 0xc251,
+	0x57db, 0x987f, 0x0007, 0x6aff, 0x62d0, 0xc2d1, 0x0458, 0x0454,
+	0x6add, 0x7ff8, 0xc261, 0x987c, 0xc230, 0xc23a, 0x57db, 0x52f3,
+	0x6ad5, 0x56fb, 0x028e, 0x1a94, 0x5202, 0x0269, 0x7d17, 0x1e94,
+	0x5206, 0x0248, 0x5a06, 0x2694, 0x5206, 0x026e, 0x7d26, 0x6ac8,
+	0x7f22, 0x2501, 0x4d00, 0x7d27, 0x028e, 0x1a98, 0x5202, 0x0260,
+	0x7df3, 0x6add, 0x7f18, 0x62d0, 0xc2d1, 0x9903, 0x008f, 0x2001,
+	0x00d5, 0x7d01, 0x008d, 0x05a0, 0x5206, 0x026e, 0x7d0e, 0x6ac8,
+	0x7f0a, 0x2001, 0x7cf9, 0x6add, 0x7f06, 0x0000, 0x4d00, 0x7d0b,
+	0xc251, 0x57db, 0x98c9, 0x0007, 0x6aff, 0x6add, 0x7ffc, 0x62d0,
+	0xc2d1, 0x0458, 0x0454, 0x6add, 0x7ff6, 0xc261, 0x98c6
+};
+#endif
diff --git a/arch/arm/mach-mx25/include/mach/serial.h b/arch/arm/mach-mx25/include/mach/serial.h
new file mode 100644
index 0000000..c6e77f9
--- /dev/null
+++ b/arch/arm/mach-mx25/include/mach/serial.h
@@ -0,0 +1,148 @@
+/*
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ARCH_ARM_MACH_MX25_SERIAL_H__
+#define __ARCH_ARM_MACH_MX25_SERIAL_H__
+
+/*!
+ * @file mach-mx25/serial.h
+ *
+ * @ingroup MSL_MX25
+ */
+#include <mach/mxc_uart.h>
+
+/* UART 1 configuration */
+/*!
+ * This option allows to choose either an interrupt-driven software controlled
+ * hardware flow control (set this option to 0) or hardware-driven hardware
+ * flow control (set this option to 1).
+ */
+#define UART1_HW_FLOW           1
+/*!
+ * This specifies the threshold at which the CTS pin is deasserted by the
+ * RXFIFO. Set this value in Decimal to anything from 0 to 32 for
+ * hardware-driven hardware flow control. Read the HW spec while specifying
+ * this value. When using interrupt-driven software controlled hardware
+ * flow control set this option to -1.
+ */
+#define UART1_UCR4_CTSTL        16
+/*!
+ * This is option to enable (set this option to 1) or disable DMA data transfer
+ */
+#define UART1_DMA_ENABLE        0
+/*!
+ * Specify the size of the DMA receive buffer. The minimum buffer size is 512
+ * bytes. The buffer size should be a multiple of 256.
+ */
+#define UART1_DMA_RXBUFSIZE     1024
+/*!
+ * Specify the MXC UART's Receive Trigger Level. This controls the threshold at
+ * which a maskable interrupt is generated by the RxFIFO. Set this value in
+ * Decimal to anything from 0 to 32. Read the HW spec while specifying this
+ * value.
+ */
+#define UART1_UFCR_RXTL         16
+/*!
+ * Specify the MXC UART's Transmit Trigger Level. This controls the threshold at
+ * which a maskable interrupt is generated by the TxFIFO. Set this value in
+ * Decimal to anything from 0 to 32. Read the HW spec while specifying this
+ * value.
+ */
+#define UART1_UFCR_TXTL         16
+/* UART 2 configuration */
+#define UART2_HW_FLOW           0
+#define UART2_UCR4_CTSTL        (-1)
+#define UART2_DMA_ENABLE        0
+#define UART2_DMA_RXBUFSIZE     512
+#define UART2_UFCR_RXTL         16
+#define UART2_UFCR_TXTL         16
+/* UART 3 configuration */
+#define UART3_HW_FLOW           1
+#define UART3_UCR4_CTSTL        16
+#define UART3_DMA_ENABLE        1
+#define UART3_DMA_RXBUFSIZE     1024
+#define UART3_UFCR_RXTL         16
+#define UART3_UFCR_TXTL         16
+/* UART 4 configuration */
+#define UART4_HW_FLOW           1
+#define UART4_UCR4_CTSTL        16
+#define UART4_DMA_ENABLE        1
+#define UART4_DMA_RXBUFSIZE     1024
+#define UART4_UFCR_RXTL         16
+#define UART4_UFCR_TXTL         16
+/* UART 5 configuration */
+#define UART5_HW_FLOW           1
+#define UART5_UCR4_CTSTL        16
+#define UART5_DMA_ENABLE        1
+#define UART5_DMA_RXBUFSIZE     1024
+#define UART5_UFCR_RXTL         16
+#define UART5_UFCR_TXTL         16
+
+/*
+ * UART Chip level Configuration that a user may not have to edit. These
+ * configuration vary depending on how the UART module is integrated with
+ * the ARM core
+ */
+/*
+ * Is the MUXED interrupt output sent to the ARM core
+ */
+#define INTS_NOTMUXED           0
+#define INTS_MUXED              1
+/* UART 1 configuration */
+/*!
+ * This define specifies whether the muxed ANDed interrupt line or the
+ * individual interrupts from the UART port is integrated with the ARM core.
+ * There exists a define like this for each UART port. Valid values that can
+ * be used are \b INTS_NOTMUXED or \b INTS_MUXED.
+ */
+#define UART1_MUX_INTS          INTS_MUXED
+/*!
+ * This define specifies the transmitter interrupt number or the interrupt
+ * number of the ANDed interrupt in case the interrupts are muxed. There exists
+ * a define like this for each UART port.
+ */
+#define UART1_INT1              MX25_INT_UART1
+/*!
+ * This define specifies the receiver interrupt number. If the interrupts of
+ * the UART are muxed, then we specify here a dummy value -1. There exists a
+ * define like this for each UART port.
+ */
+#define UART1_INT2              (-1)
+/*!
+ * This specifies the master interrupt number. If the interrupts of the UART
+ * are muxed, then we specify here a dummy value of -1. There exists a define
+ * like this for each UART port.
+ */
+#define UART1_INT3              (-1)
+/* UART 2 configuration */
+#define UART2_MUX_INTS          INTS_MUXED
+#define UART2_INT1              MX25_INT_UART2
+#define UART2_INT2              (-1)
+#define UART2_INT3              (-1)
+/* UART 3 configuration */
+#define UART3_MUX_INTS          INTS_MUXED
+#define UART3_INT1              MX25_INT_UART3
+#define UART3_INT2              (-1)
+#define UART3_INT3              (-1)
+/* UART 4 configuration */
+#define UART4_MUX_INTS          INTS_MUXED
+#define UART4_INT1              MX25_INT_UART4
+#define UART4_INT2              (-1)
+#define UART4_INT3              (-1)
+/* UART 5 configuration */
+#define UART5_MUX_INTS          INTS_MUXED
+#define UART5_INT1              MX25_INT_UART5
+#define UART5_INT2              (-1)
+#define UART5_INT3              (-1)
+
+#endif				/* __ARCH_ARM_MACH_MX25_SERIAL_H__ */
diff --git a/arch/arm/mach-mx25/iomux.c b/arch/arm/mach-mx25/iomux.c
new file mode 100644
index 0000000..730e85b
--- /dev/null
+++ b/arch/arm/mach-mx25/iomux.c
@@ -0,0 +1,199 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup GPIO_MX25 Board GPIO and Muxing Setup
+ * @ingroup MSL_MX25
+ */
+/*!
+ * @file mach-mx25/iomux.c
+ *
+ * @brief I/O Muxing control functions
+ *
+ * @ingroup GPIO_MX25
+ */
+
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/gpio.h>
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+#include <mach/iomux-mx25.h>
+
+/*!
+ * IOMUX register (base) addresses
+ */
+#define IOMUXGPR		(IO_ADDRESS(MX25_IOMUXC_BASE_ADDR))
+#define IOMUXSW_MUX_CTL		(IO_ADDRESS(MX25_IOMUXC_BASE_ADDR) + 0x008)
+#define IOMUXSW_MUX_END		(IO_ADDRESS(MX25_IOMUXC_BASE_ADDR) + 0x228)
+#define IOMUXSW_PAD_CTL		(IO_ADDRESS(MX25_IOMUXC_BASE_ADDR) + 0x22C)
+#define IOMUXSW_PAD_END		(IO_ADDRESS(MX25_IOMUXC_BASE_ADDR) + 0x414)
+#define IOMUXSW_INPUT_CTL	(IO_ADDRESS(MX25_IOMUXC_BASE_ADDR) + 0x460)
+#define IOMUXSW_INPUT_END	(IO_ADDRESS(MX25_IOMUXC_BASE_ADDR) + 0x580)
+
+#define MUX_PIN_NUM_MAX		\
+		(((IOMUXSW_MUX_END - IOMUXSW_MUX_CTL) >> 2) + 1)
+#define MUX_INPUT_NUM_MUX	\
+		(((IOMUXSW_INPUT_END - IOMUXSW_INPUT_CTL) >> 2) + 1)
+
+#define PIN_TO_IOMUX_INDEX(pin) (PIN_TO_IOMUX_MUX(pin) >> 2)
+
+static DEFINE_SPINLOCK(gpio_mux_lock);
+static u8 iomux_pin_res_table[MUX_PIN_NUM_MAX];
+#define MUX_USED 0x80
+
+/*!
+ * This function is used to configure a pin through the IOMUX module.
+ * FIXED ME: for backward compatible. Will be static function!
+ * @param  pin		a pin number as defined in \b #iomux_pin_name_t
+ * @param  cfg		an output function as defined in \b #iomux_pin_cfg_t
+ *
+ * @return		0 if successful; Non-zero otherwise
+ */
+static int iomux_config_mux(iomux_pin_name_t pin, iomux_pin_cfg_t cfg)
+{
+	u32 ret = 0;
+	u32 pin_index = PIN_TO_IOMUX_INDEX(pin);
+	void *mux_reg = IOMUXGPR + PIN_TO_IOMUX_MUX(pin);
+	u8 *rp;
+
+	BUG_ON(pin_index > MUX_PIN_NUM_MAX);
+	BUG_ON((mux_reg > IOMUXSW_MUX_END) || (mux_reg < IOMUXSW_MUX_CTL));
+	spin_lock(&gpio_mux_lock);
+	__raw_writel(cfg, mux_reg);
+	/*
+	 * Log a warning if a pin changes ownership
+	 */
+	rp = iomux_pin_res_table + pin_index;
+	if (*rp && *rp != (cfg | MUX_USED)) {
+		/*Console: how to do */
+		printk(KERN_ERR "iomux_config_mux: Warning: iomux pin"
+		       " config changed, index=%d register=%p, "
+		       " prev=0x%x new=0x%x\n", pin_index, mux_reg,
+		       *rp, cfg);
+		ret = -EINVAL;
+	}
+	*rp = cfg | MUX_USED;
+	spin_unlock(&gpio_mux_lock);
+
+	return ret;
+}
+
+/*!
+ * Request ownership for an IO pin. This function has to be the first one
+ * being called before that pin is used. The caller has to check the
+ * return value to make sure it returns 0.
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  cfg		an input function as defined in \b #iomux_pin_cfg_t
+ *
+ * @return		0 if successful; Non-zero otherwise
+ */
+int mxc_request_iomux(iomux_pin_name_t pin, iomux_pin_cfg_t cfg)
+{
+	int ret = iomux_config_mux(pin, cfg);
+	if (IOMUX_TO_GPIO(pin) < MXC_GPIO_IRQS) {
+		if (((cfg & (~MUX_CONFIG_SION)) == MUX_CONFIG_GPIO) ||
+		    (((cfg & (~MUX_CONFIG_SION)) == MUX_CONFIG_FUNC) &&
+		     ((pin == MX25_PIN_GPIO_A) || (pin == MX25_PIN_GPIO_B) ||
+		      (pin == MX25_PIN_GPIO_C) || (pin == MX25_PIN_GPIO_D) ||
+		      (pin == MX25_PIN_GPIO_E) || (pin == MX25_PIN_GPIO_F))))
+			ret |= gpio_request(IOMUX_TO_GPIO(pin), NULL);
+	}
+	return ret;
+}
+EXPORT_SYMBOL(mxc_request_iomux);
+
+/*!
+ * Release ownership for an IO pin
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  cfg		an input function as defined in \b #iomux_pin_cfg_t
+ */
+void mxc_free_iomux(iomux_pin_name_t pin, iomux_pin_cfg_t cfg)
+{
+	u32 pin_index = PIN_TO_IOMUX_INDEX(pin);
+	u8 *rp = iomux_pin_res_table + pin_index;
+
+	BUG_ON((pin_index > MUX_PIN_NUM_MAX));
+
+	*rp = 0;
+	if (IOMUX_TO_GPIO(pin) < MXC_GPIO_IRQS) {
+		if (((cfg & (~MUX_CONFIG_SION)) == MUX_CONFIG_GPIO) ||
+		    (((cfg & (~MUX_CONFIG_SION)) == MUX_CONFIG_FUNC) &&
+		     ((pin == MX25_PIN_GPIO_A) || (pin == MX25_PIN_GPIO_B) ||
+		      (pin == MX25_PIN_GPIO_C) || (pin == MX25_PIN_GPIO_D) ||
+		      (pin == MX25_PIN_GPIO_E) || (pin == MX25_PIN_GPIO_F))))
+			gpio_free(IOMUX_TO_GPIO(pin));
+	}
+}
+EXPORT_SYMBOL(mxc_free_iomux);
+
+/*!
+ * This function configures the pad value for a IOMUX pin.
+ *
+ * @param  pin     a pin number as defined in \b #iomux_pin_name_t
+ * @param  config  the ORed value of elements defined in \b #iomux_pad_config_t
+ */
+void mxc_iomux_set_pad(iomux_pin_name_t pin, u32 config)
+{
+	void *pad_reg = IOMUXGPR + PIN_TO_IOMUX_PAD(pin);
+
+	BUG_ON((pad_reg > IOMUXSW_PAD_END) || (pad_reg < IOMUXSW_PAD_CTL));
+
+	__raw_writel(config, pad_reg);
+}
+EXPORT_SYMBOL(mxc_iomux_set_pad);
+
+/*!
+ * This function enables/disables the general purpose function for a particular
+ * signal.
+ *
+ * @param  gp   one signal as defined in \b #iomux_gp_func_t
+ * @param  en   \b #true to enable; \b #false to disable
+ */
+void mxc_iomux_set_gpr(iomux_gp_func_t gp, bool en)
+{
+	u32 l;
+
+	spin_lock(&gpio_mux_lock);
+	l = __raw_readl(IOMUXGPR);
+
+	if (en)
+		l |= gp;
+	else
+		l &= ~gp;
+
+	__raw_writel(l, IOMUXGPR);
+	spin_unlock(&gpio_mux_lock);
+}
+EXPORT_SYMBOL(mxc_iomux_set_gpr);
+
+/*!
+ * This function configures input path.
+ *
+ * @param input index of input select register as defined in \b
+ *			#iomux_input_select_t
+ * @param config the binary value of elements defined in \b
+ *			#iomux_input_config_t
+ */
+void mxc_iomux_set_input(iomux_input_select_t input, u32 config)
+{
+	void *reg = IOMUXSW_INPUT_CTL + (input << 2);
+
+	BUG_ON(input >= MUX_INPUT_NUM_MUX);
+
+	__raw_writel(config, reg);
+}
+EXPORT_SYMBOL(mxc_iomux_set_input);
diff --git a/arch/arm/mach-mx25/mm.c b/arch/arm/mach-mx25/mm.c
index a7e587f..6a060c2 100644
--- a/arch/arm/mach-mx25/mm.c
+++ b/arch/arm/mach-mx25/mm.c
@@ -4,6 +4,7 @@
  *  Copyright (C) 2002 Shane Nay (shane@minirl.com)
  *  Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  *    - add MX31 specific definitions
+ *  Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -22,8 +23,7 @@
 
 #include <linux/mm.h>
 #include <linux/init.h>
-#include <linux/err.h>
-
+#include <mach/hardware.h>
 #include <asm/pgtable.h>
 #include <asm/mach/map.h>
 
@@ -31,34 +31,65 @@
 #include <mach/hardware.h>
 #include <mach/mx25.h>
 #include <mach/iomux-v3.h>
+/*!
+ * @file mach-mx25/mm.c
+ *
+ * @brief This file creates static mapping between physical to virtual memory.
+ *
+ * @ingroup Memory_MX25
+ */
 
-/*
- * This table defines static virtual address mappings for I/O regions.
- * These are the mappings common across all MX3 boards.
+/*!
+ * This structure defines the MX25 memory map.
  */
-static struct map_desc mxc_io_desc[] __initdata = {
+static struct map_desc mx25_io_desc[] __initdata = {
 	{
-		.virtual	= MX25_AVIC_BASE_ADDR_VIRT,
-		.pfn		= __phys_to_pfn(MX25_AVIC_BASE_ADDR),
-		.length		= MX25_AVIC_SIZE,
-		.type		= MT_DEVICE_NONSHARED
+		.virtual	= MX25_IRAM_BASE_ADDR_VIRT,
+		.pfn		= __phys_to_pfn(MX25_IRAM_BASE_ADDR),
+		.length		= MX25_IRAM_SIZE,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= MX25_X_MEMC_BASE_ADDR_VIRT,
+		.pfn		= __phys_to_pfn(MX25_X_MEMC_BASE_ADDR),
+		.length		= MX25_X_MEMC_SIZE,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= MX25_NFC_BASE_ADDR_VIRT,
+		.pfn		= __phys_to_pfn(MX25_NFC_BASE_ADDR),
+		.length		= MX25_NFC_SIZE,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= MX25_ROMP_BASE_ADDR_VIRT,
+		.pfn		= __phys_to_pfn(MX25_ROMP_BASE_ADDR),
+		.length		= MX25_ROMP_SIZE,
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= MX25_ASIC_BASE_ADDR_VIRT,
+		.pfn		= __phys_to_pfn(MX25_ASIC_BASE_ADDR),
+		.length		= MX25_ASIC_SIZE,
+		.type		= MT_DEVICE
 	}, {
 		.virtual	= MX25_AIPS1_BASE_ADDR_VIRT,
 		.pfn		= __phys_to_pfn(MX25_AIPS1_BASE_ADDR),
 		.length		= MX25_AIPS1_SIZE,
-		.type		= MT_DEVICE_NONSHARED
+		.type		= MT_DEVICE
+	}, {
+		.virtual	= MX25_SPBA0_BASE_ADDR_VIRT,
+		.pfn		= __phys_to_pfn(MX25_SPBA0_BASE_ADDR),
+		.length		= MX25_SPBA0_SIZE,
+		.type		= MT_DEVICE
 	}, {
 		.virtual	= MX25_AIPS2_BASE_ADDR_VIRT,
 		.pfn		= __phys_to_pfn(MX25_AIPS2_BASE_ADDR),
 		.length		= MX25_AIPS2_SIZE,
-		.type		= MT_DEVICE_NONSHARED
+		.type		= MT_DEVICE
 	},
 };
 
-/*
+/*!
  * This function initializes the memory map. It is called during the
- * system startup to create static physical to virtual memory mappings
- * for the IO modules.
+ * system startup to create static physical to virtual memory map for
+ * the IO modules.
  */
 void __init mx25_map_io(void)
 {
@@ -66,11 +97,13 @@ void __init mx25_map_io(void)
 	mxc_iomux_v3_init(MX25_IO_ADDRESS(MX25_IOMUXC_BASE_ADDR));
 	mxc_arch_reset_init(MX25_IO_ADDRESS(MX25_WDOG_BASE_ADDR));
 
-	iotable_init(mxc_io_desc, ARRAY_SIZE(mxc_io_desc));
+	iotable_init(mx25_io_desc, ARRAY_SIZE(mx25_io_desc));
 }
 
+/*
+ * irq init
+ */
 void __init mx25_init_irq(void)
 {
-	mxc_init_irq((void __iomem *)MX25_AVIC_BASE_ADDR_VIRT);
+	mxc_init_irq(MX25_IO_ADDRESS(MX25_AVIC_BASE_ADDR));
 }
-
diff --git a/arch/arm/mach-mx25/pm.c b/arch/arm/mach-mx25/pm.c
new file mode 100644
index 0000000..e8c0fb8
--- /dev/null
+++ b/arch/arm/mach-mx25/pm.c
@@ -0,0 +1,103 @@
+/*
+ *  Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/suspend.h>
+#include <linux/io.h>
+#include <mach/hardware.h>
+#include <mach/crm_regs.h>
+
+/*!
+ * @defgroup MSL_MX25 i.MX25 Machine Specific Layer (MSL)
+ */
+
+/*!
+ * @file mach-mx25/pm.c
+ * @brief This file contains suspend operations
+ *
+ * @ingroup MSL_MX25
+ */
+static unsigned int cgcr0, cgcr1, cgcr2;
+
+static int mx25_suspend_enter(suspend_state_t state)
+{
+	unsigned int reg;
+
+	switch (state) {
+	case PM_SUSPEND_MEM:
+		mxc_cpu_lp_set(STOP_POWER_OFF);
+		break;
+	case PM_SUSPEND_STANDBY:
+		mxc_cpu_lp_set(WAIT_UNCLOCKED_POWER_OFF);
+		break;
+	default:
+		return -EINVAL;
+	}
+	/* Executing CP15 (Wait-for-Interrupt) Instruction */
+	cpu_do_idle();
+
+	reg = (__raw_readl(MXC_CCM_CGCR0) & ~MXC_CCM_CGCR0_STOP_MODE_MASK) |
+	    cgcr0;
+	__raw_writel(reg, MXC_CCM_CGCR0);
+
+	reg = (__raw_readl(MXC_CCM_CGCR1) & ~MXC_CCM_CGCR1_STOP_MODE_MASK) |
+	    cgcr1;
+	__raw_writel(reg, MXC_CCM_CGCR1);
+
+	reg = (__raw_readl(MXC_CCM_CGCR2) & ~MXC_CCM_CGCR2_STOP_MODE_MASK) |
+	    cgcr2;
+	__raw_writel(reg, MXC_CCM_CGCR2);
+
+	return 0;
+}
+
+/*
+ * Called after processes are frozen, but before we shut down devices.
+ */
+static int mx25_suspend_prepare(void)
+{
+	cgcr0 = __raw_readl(MXC_CCM_CGCR0) & MXC_CCM_CGCR0_STOP_MODE_MASK;
+	cgcr1 = __raw_readl(MXC_CCM_CGCR1) & MXC_CCM_CGCR1_STOP_MODE_MASK;
+	cgcr2 = __raw_readl(MXC_CCM_CGCR2) & MXC_CCM_CGCR2_STOP_MODE_MASK;
+
+	return 0;
+}
+
+/*
+ * Called after devices are re-setup, but before processes are thawed.
+ */
+static void mx25_suspend_finish(void)
+{
+}
+
+static int mx25_pm_valid(suspend_state_t state)
+{
+	return state > PM_SUSPEND_ON && state <= PM_SUSPEND_MAX;
+}
+
+struct platform_suspend_ops mx25_suspend_ops = {
+	.valid = mx25_pm_valid,
+	.prepare = mx25_suspend_prepare,
+	.enter = mx25_suspend_enter,
+	.finish = mx25_suspend_finish,
+};
+
+static int __init mx25_pm_init(void)
+{
+	pr_info("Static Power Management for Freescale i.MX25\n");
+	suspend_set_ops(&mx25_suspend_ops);
+
+	return 0;
+}
+
+late_initcall(mx25_pm_init);
diff --git a/arch/arm/mach-mx25/system.c b/arch/arm/mach-mx25/system.c
new file mode 100644
index 0000000..46ce240
--- /dev/null
+++ b/arch/arm/mach-mx25/system.c
@@ -0,0 +1,140 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <mach/hardware.h>
+#include <asm/proc-fns.h>
+#include <asm/system.h>
+#include <mach/clock.h>
+#include <mach/crm_regs.h>
+
+/*!
+ * @defgroup MSL_MX25 i.MX25 Machine Specific Layer (MSL)
+ */
+
+/*!
+ * @file mach-mx25/system.c
+ * @brief This file contains idle and reset functions.
+ *
+ * @ingroup MSL_MX25
+ */
+
+/*!
+ * MX25 low-power mode
+ */
+enum mx25_low_pwr_mode {
+	MX25_RUN_MODE,
+	MX25_WAIT_MODE,
+	MX25_DOZE_MODE,
+	MX25_STOP_MODE
+};
+
+extern int mxc_jtag_enabled;
+
+/*!
+ * This function is used to set cpu low power mode before WFI instruction
+ *
+ * @param  mode         indicates different kinds of power modes
+ */
+void mxc_cpu_lp_set(enum mxc_cpu_pwr_mode mode)
+{
+	unsigned int lpm;
+	unsigned long reg;
+	unsigned int pmcr2, lpimr;
+	unsigned int cgcr0, cgcr1, cgcr2;
+	struct irq_desc *desc;
+	int i;
+
+	/*read CCTL value */
+	reg = __raw_readl(MXC_CCM_CCTL);
+
+	switch (mode) {
+	case WAIT_UNCLOCKED_POWER_OFF:
+		lpm = MX25_DOZE_MODE;
+		break;
+
+	case STOP_POWER_ON:
+	case STOP_POWER_OFF:
+		lpm = MX25_STOP_MODE;
+		/* The clock of LCDC/SLCDC, SDMA, RTIC, RNGC, MAX, CAN
+		   and EMI needs to be gated on when entering Stop mode.
+		 */
+		cgcr0 = __raw_readl(MXC_CCM_CGCR0);
+		cgcr1 = __raw_readl(MXC_CCM_CGCR1);
+		cgcr2 = __raw_readl(MXC_CCM_CGCR2);
+		__raw_writel(cgcr0 | MXC_CCM_CGCR0_STOP_MODE_MASK,
+			     MXC_CCM_CGCR0);
+		__raw_writel(cgcr1 | MXC_CCM_CGCR1_STOP_MODE_MASK,
+			     MXC_CCM_CGCR1);
+		__raw_writel(cgcr2 | MXC_CCM_CGCR2_STOP_MODE_MASK,
+			     MXC_CCM_CGCR2);
+		/* The interrupts which are not wake-up sources need
+		   be mask when entering Stop mode.
+		 */
+		lpimr = MXC_CCM_LPIMR0_MASK;
+		for (i = 0; i < 32; i++) {
+			desc = irq_desc + i;
+			if ((desc->status & IRQ_WAKEUP) != 0)
+				lpimr &= ~(1 << i);
+		}
+		__raw_writel(lpimr, MXC_CCM_LPIMR0);
+		lpimr = MXC_CCM_LPIMR1_MASK;
+		for (i = 32; i < 64; i++) {
+			desc = irq_desc + i;
+			if ((desc->status & IRQ_WAKEUP) != 0)
+				lpimr &= ~(1 << (i - 32));
+		}
+		__raw_writel(lpimr, MXC_CCM_LPIMR1);
+
+		if (mode == STOP_POWER_OFF) {
+			pmcr2 = __raw_readl(MXC_CCM_PMCR2);
+			pmcr2 |= (MXC_CCM_PMCR2_OSC24M_DOWN |
+				  MXC_CCM_PMCR2_VSTBY);
+			__raw_writel(pmcr2, MXC_CCM_PMCR2);
+		}
+		break;
+
+	case WAIT_CLOCKED:
+	case WAIT_UNCLOCKED:
+	default:
+		/* Wait is the default mode used when idle. */
+		lpm = MX25_WAIT_MODE;
+		break;
+	}
+
+	/* program LP CTL bit */
+	reg = ((reg & (~MXC_CCM_CCTL_LP_CTL_MASK)) |
+	       lpm << MXC_CCM_CCTL_LP_CTL_OFFSET);
+
+	__raw_writel(reg, MXC_CCM_CCTL);
+}
+
+/*!
+ * This function puts the CPU into idle mode. It is called by default_idle()
+ * in process.c file.
+ */
+void mx25_arch_idle(void)
+{
+	/*
+	 * This should do all the clock switching
+	 * and wait for interrupt tricks.
+	 */
+	if (!mxc_jtag_enabled) {
+		/* set as Wait mode */
+		mxc_cpu_lp_set(WAIT_UNCLOCKED);
+		cpu_do_idle();
+	}
+}
diff --git a/arch/arm/mach-mx25/usb_dr.c b/arch/arm/mach-mx25/usb_dr.c
new file mode 100644
index 0000000..172dbf1
--- /dev/null
+++ b/arch/arm/mach-mx25/usb_dr.c
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2005-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <mach/hardware.h>
+#include <mach/arc_otg.h>
+#include <mach/usb.h>
+
+static void _wake_up_enable(struct fsl_usb2_platform_data *pdata, bool enable);
+
+/*
+ * platform data structs
+ *	- Which one to use is determined by CONFIG options in usb.h
+ *	- operating_mode plugged at run time
+ */
+static struct fsl_usb2_platform_data __maybe_unused dr_utmi_config = {
+	.name              = "DR",
+	.platform_init     = usbotg_init,
+	.platform_uninit   = usbotg_uninit,
+	.phy_mode          = FSL_USB2_PHY_UTMI_WIDE,
+	.power_budget      = 500,		/* via RT9706 */
+	.gpio_usb_active   = gpio_usbotg_utmi_active,
+	.gpio_usb_inactive = gpio_usbotg_utmi_inactive,
+	.transceiver       = "utmi",
+	.wake_up_enable = _wake_up_enable,
+};
+
+/*
+ * OTG resources
+ */
+static struct resource otg_resources[] = {
+	[0] = {
+	       .start = (u32)(USB_OTGREGS_BASE),
+	       .end   = (u32)(USB_OTGREGS_BASE + 0x1ff),
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MX25_INT_USB_OTG,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*
+ * UDC resources (same as OTG resource)
+ */
+static struct resource udc_resources[] = {
+	[0] = {
+	       .start = (u32)(USB_OTGREGS_BASE),
+	       .end   = (u32)(USB_OTGREGS_BASE + 0x1ff),
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MXC_INT_USB_OTG,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+
+static u64 dr_udc_dmamask = ~(u32) 0;
+static void dr_udc_release(struct device *dev)
+{
+}
+
+static u64 dr_otg_dmamask = ~(u32) 0;
+static void dr_otg_release(struct device *dev)
+{
+}
+
+/*
+ * platform device structs
+ *	dev.platform_data field plugged at run time
+ */
+static struct platform_device __maybe_unused dr_udc_device = {
+	.name = "fsl-usb2-udc",
+	.id   = -1,
+	.dev  = {
+		.release           = dr_udc_release,
+		.dma_mask          = &dr_udc_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+	},
+	.resource      = udc_resources,
+	.num_resources = ARRAY_SIZE(udc_resources),
+};
+
+static struct platform_device __maybe_unused dr_otg_device = {
+	.name = "fsl-usb2-otg",
+	.id = -1,
+	.dev = {
+		.release           = dr_otg_release,
+		.dma_mask          = &dr_otg_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+	},
+	.resource      = otg_resources,
+	.num_resources = ARRAY_SIZE(otg_resources),
+};
+
+static void _wake_up_enable(struct fsl_usb2_platform_data *pdata, bool enable)
+{
+	if (get_usb_mode(pdata) == FSL_USB_DR_DEVICE) {
+		if (enable)
+			USBCTRL |= (UCTRL_OWIE | UCTRL_VBUS_WKUP_EN);
+		else {
+			USBCTRL &= ~UCTRL_OWIE;
+			USBCTRL &= ~UCTRL_VBUS_WKUP_EN;
+		}
+	} else {
+		if (enable)
+			USBCTRL |= UCTRL_OWIE;
+		else
+			USBCTRL &= ~UCTRL_OWIE;
+	}
+}
+
+static int __init usb_dr_init(void)
+{
+	pr_debug("%s: \n", __func__);
+
+	dr_register_otg();
+	dr_register_host(otg_resources, ARRAY_SIZE(otg_resources));
+	dr_register_udc();
+
+	return 0;
+}
+
+module_init(usb_dr_init);
diff --git a/arch/arm/mach-mx25/usb_h2.c b/arch/arm/mach-mx25/usb_h2.c
new file mode 100644
index 0000000..8bae23c
--- /dev/null
+++ b/arch/arm/mach-mx25/usb_h2.c
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2005-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/usb/fsl_xcvr.h>
+#include <linux/regulator/consumer.h>
+#include <mach/hardware.h>
+#include <mach/arc_otg.h>
+#include <mach/usb.h>
+
+static struct fsl_usb2_platform_data usbh2_config = {
+	.name              = "Host 2",
+	.platform_init     = fsl_usb_host_init,
+	.platform_uninit   = fsl_usb_host_uninit,
+	.operating_mode    = FSL_USB2_MPH_HOST,
+	.phy_mode          = FSL_USB2_PHY_SERIAL,
+	.power_budget      = 500,		/* via RT9702 */
+	.gpio_usb_active   = gpio_usbh2_active,
+	.gpio_usb_inactive = gpio_usbh2_inactive,
+	.transceiver       = "serial",		/* on-chip */
+};
+
+static struct resource usbh2_resources[] = {
+	[0] = {
+	       .start = (u32) (USB_H2REGS_BASE),
+	       .end   = (u32) (USB_H2REGS_BASE + 0x1ff),
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MX25_INT_USB_HTG,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+void usbh2_get_xcvr_power(struct device *dev)
+{
+	struct regulator *usbh2_regux;
+
+	usbh2_regux = regulator_get(dev, "GPO1");
+	regulator_enable(usbh2_regux);
+	((struct fsl_usb2_platform_data *)dev->platform_data)->
+	    xcvr_pwr->regu1 = usbh2_regux;
+
+	usbh2_regux = regulator_get(dev, "GPO3");
+	regulator_enable(usbh2_regux);
+	((struct fsl_usb2_platform_data *)dev->platform_data)->
+	    xcvr_pwr->regu2 = usbh2_regux;
+}
+EXPORT_SYMBOL(usbh2_get_xcvr_power);
+
+void usbh2_put_xcvr_power(struct device *dev)
+{
+	struct regulator *usbh2_regux;
+
+	usbh2_regux = ((struct fsl_usb2_platform_data *)dev->
+		       platform_data)->xcvr_pwr->regu2;
+	regulator_disable(usbh2_regux);
+	regulator_put(usbh2_regux);
+
+	usbh2_regux = ((struct fsl_usb2_platform_data *)dev->
+		       platform_data)->xcvr_pwr->regu1;
+	regulator_disable(usbh2_regux);
+	regulator_put(usbh2_regux);
+}
+EXPORT_SYMBOL(usbh2_put_xcvr_power);
+
+static int __init usbh2_init(void)
+{
+	pr_debug("%s: \n", __func__);
+	host_pdev_register(usbh2_resources, ARRAY_SIZE(usbh2_resources),
+			   &usbh2_config);
+	return 0;
+}
+module_init(usbh2_init);
-- 
1.7.0.4

