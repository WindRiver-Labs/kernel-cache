From b289664624e4bcc796059eaca34decaf9a5be1d1 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Sun, 15 May 2011 03:18:18 +0800
Subject: [PATCH 2/9] imx25pdk: add mx25 machine files

Add imx25pdk machine files, these specific files include support
for board, cpld, gpio, and pmic.

[Original code taken from L2.6.31_09.12.00_SDK_source.tar.gz BSP package:
http://www.freescale.com/webapp/sps/site/prod_summary.jsp?code=
IMX25PDK&fpsp=1&tab=Design_Tools_Tab]

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-mx25/Kconfig                    |   96 ++-
 arch/arm/mach-mx25/Makefile                   |   21 +-
 arch/arm/mach-mx25/board-mx25_3stack.h        |  172 ++++
 arch/arm/mach-mx25/mach-mx25pdk.c             |  174 ----
 arch/arm/mach-mx25/mx25_3stack.c              |  817 +++++++++++++++
 arch/arm/mach-mx25/mx25_3stack_cpld.c         |  246 +++++
 arch/arm/mach-mx25/mx25_3stack_gpio.c         | 1356 +++++++++++++++++++++++++
 arch/arm/mach-mx25/mx25_3stack_pmic_mc34704.c |  171 ++++
 8 files changed, 2872 insertions(+), 181 deletions(-)
 create mode 100644 arch/arm/mach-mx25/board-mx25_3stack.h
 delete mode 100644 arch/arm/mach-mx25/mach-mx25pdk.c
 create mode 100644 arch/arm/mach-mx25/mx25_3stack.c
 create mode 100644 arch/arm/mach-mx25/mx25_3stack_cpld.c
 create mode 100644 arch/arm/mach-mx25/mx25_3stack_gpio.c
 create mode 100644 arch/arm/mach-mx25/mx25_3stack_pmic_mc34704.c

diff --git a/arch/arm/mach-mx25/Kconfig b/arch/arm/mach-mx25/Kconfig
index 54d2173..3f404ee 100644
--- a/arch/arm/mach-mx25/Kconfig
+++ b/arch/arm/mach-mx25/Kconfig
@@ -1,8 +1,96 @@
-if ARCH_MX25
+menu "MX25 Options"
+	depends on ARCH_MX25
 
-comment "MX25 platforms:"
+config MX25_OPTIONS
+	bool
+	default y
+	select CPU_ARM926T
+	select USB_ARCH_HAS_EHCI
 
 config MACH_MX25_3DS
-	bool "Support MX25PDK (3DS) Platform"
+	bool "Support MX25 3STACK platforms"
+	default y
+	help
+	  Include support for MX25 3STACK platform. This includes specific
+	  configurations for the board and its peripherals.
 
-endif
+config MX25_DOZE_DURING_IDLE
+	bool "Enter Doze mode during idle"
+	help
+	  Turning on this option will put the CPU into Doze mode during idle.
+	  The default is to enter Wait mode during idle. Doze mode during
+	  idle will save additional power over Wait mode.
+
+config MXC_SDMA_API
+        bool "Use SDMA API"
+        default y
+        help
+           This selects the Freescale MXC SDMA API.
+           If unsure, say N.
+
+menu "SDMA options"
+        depends on MXC_SDMA_API
+
+config SDMA_IRAM
+        bool "Use Internal RAM for SDMA transfer"
+        default n
+        help
+           Support Internal RAM as SDMA buffer or control structures
+
+config SDMA_IRAM_SIZE
+        hex "Reserved bytes of IRAM for SDMA (0x800-0x1000)"
+        range 0x800 0x1000
+        depends on SDMA_IRAM
+        default "0x1000"
+        help
+           Set the size of IRAM for SDMA. It must be a multiple of 512bytes.
+endmenu
+
+config ARCH_MXC_HAS_NFC_V2
+        bool "MXC NFC Hardware Version 2"
+        depends on ARCH_MX25
+        default y
+        help
+           This selects the Freescale MXC Nand Flash Controller Hardware Version 2
+           If unsure, say N.
+
+config ARCH_MXC_HAS_NFC_V2_1
+        bool "MXC NFC Hardware Version 2.1"
+        depends on ARCH_MXC_HAS_NFC_V2
+        default y
+        help
+           This selects the Freescale MXC Nand Flash Controller Hardware Version 2.1
+           If unsure, say N.
+
+menu "Device options"
+
+config I2C_MXC_SELECT1
+	bool "Enable I2C1 module"
+	default y
+	depends on I2C_MXC
+	help
+	  Enable MX25 I2C1 module.
+
+config I2C_MXC_SELECT2
+	bool "Enable I2C2 module"
+	default n
+	depends on I2C_MXC
+	help
+	  Enable MX25 I2C2 module.
+
+config I2C_MXC_SELECT3
+	bool "Enable I2C3 module"
+	default n
+	depends on I2C_MXC
+	help
+	  Enable MX25 I2C3 module.
+
+config FLEXCAN_MXC_SELECT1
+	bool "Enable FlexCAN1 module"
+	depends on CAN_FLEXCAN
+	help
+	  Enable MX25 FlexCAN1 module.
+
+endmenu
+
+endmenu
diff --git a/arch/arm/mach-mx25/Makefile b/arch/arm/mach-mx25/Makefile
index 10cebc5..767cd74 100644
--- a/arch/arm/mach-mx25/Makefile
+++ b/arch/arm/mach-mx25/Makefile
@@ -1,3 +1,18 @@
-obj-y				:= mm.o devices.o
-obj-$(CONFIG_ARCH_MX25)		+= clock.o
-obj-$(CONFIG_MACH_MX25_3DS)	+= mach-mx25pdk.o
+#
+# Makefile for the linux kernel.
+#
+
+# Object file lists.
+
+obj-y		:= system.o iomux.o cpu.o mm.o clock.o bus_freq.o devices.o
+obj-$(CONFIG_MXC_SDMA_API) 	+= dma.o
+obj-$(CONFIG_SPI_MXC)		+= mx25_3stack_cpld.o
+obj-$(CONFIG_MACH_MX25_3DS)	+= mx25_3stack.o mx25_3stack_gpio.o mx25_3stack_pmic_mc34704.o
+
+obj-$(CONFIG_USB_EHCI_ARC_H2)	+= usb_h2.o
+
+obj-$(CONFIG_PM)		+= pm.o
+
+ifneq ($(strip $(CONFIG_USB_GADGET_ARC) $(CONFIG_USB_EHCI_ARC_OTG)),)
+	obj-y	+= usb_dr.o
+endif
diff --git a/arch/arm/mach-mx25/board-mx25_3stack.h b/arch/arm/mach-mx25/board-mx25_3stack.h
new file mode 100644
index 0000000..6c5e3f7
--- /dev/null
+++ b/arch/arm/mach-mx25/board-mx25_3stack.h
@@ -0,0 +1,172 @@
+/*
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_BOARD_MX25_3STACK_H__
+#define __ASM_ARCH_MXC_BOARD_MX25_3STACK_H__
+
+#ifdef CONFIG_MACH_MX25_3DS
+
+/*!
+ * @defgroup BRDCFG_MX25 Board Configuration Options
+ * @ingroup MSL_MX25
+ */
+
+/*!
+ * @file mach-mx25/board-mx25_3stack.h
+ *
+ * @brief This file contains all the board level configuration options.
+ *
+ * It currently hold the options defined for MX25 3STACK Platform.
+ *
+ * @ingroup BRDCFG_MX25
+ */
+
+/*
+ * Include Files
+ */
+#include <mach/mxc_uart.h>
+#include <linux/fsl_devices.h>
+/*!
+ * @name MXC UART board-level configurations
+ */
+/*! @{ */
+/* UART 1 configuration */
+/*!
+ * This define specifies if the UART port is configured to be in DTE or
+ * DCE mode. There exists a define like this for each UART port. Valid
+ * values that can be used are \b MODE_DTE or \b MODE_DCE.
+ */
+#define UART1_MODE              MODE_DCE
+/*!
+ * This define specifies if the UART is to be used for IRDA. There exists a
+ * define like this for each UART port. Valid values that can be used are
+ * \b IRDA or \b NO_IRDA.
+ */
+#define UART1_IR                NO_IRDA
+/*!
+ * This define is used to enable or disable a particular UART port. If
+ * disabled, the UART will not be registered in the file system and the user
+ * will not be able to access it. There exists a define like this for each UART
+ * port. Specify a value of 1 to enable the UART and 0 to disable it.
+ */
+#define UART1_ENABLED           1
+/*! @} */
+/* UART 2 configuration */
+#define UART2_MODE              MODE_DCE
+#define UART2_IR                NO_IRDA
+#define UART2_ENABLED           1
+
+/* UART 3 configuration */
+#define UART3_MODE              MODE_DTE
+#define UART3_IR                NO_IRDA
+#define UART3_ENABLED           0
+
+/* UART 4 configuration */
+#define UART4_MODE              MODE_DTE
+#define UART4_IR                NO_IRDA
+#define UART4_ENABLED           0
+
+/* UART 5 configuration */
+#define UART5_MODE              MODE_DTE
+#define UART5_IR                NO_IRDA
+#define UART5_ENABLED           0
+
+#define MXC_LL_UART_PADDR	UART1_BASE_ADDR
+#define MXC_LL_UART_VADDR	AIPS1_IO_ADDRESS(UART1_BASE_ADDR)
+
+/*!
+ * @name debug board parameters
+ */
+/*! @{ */
+/*!
+ * Base address of debug board
+ */
+#define DEBUG_BASE_ADDRESS      0x78000000	/* Use a dummy base address */
+
+/* External ethernet LAN9217 base address */
+#define LAN9217_BASE_ADDR       DEBUG_BASE_ADDRESS
+
+/* External UART */
+#define UARTA_BASE_ADDR		(DEBUG_BASE_ADDRESS + 0x08000)
+#define UARTB_BASE_ADDR		(DEBUG_BASE_ADDRESS + 0x10000)
+
+#define BOARD_IO_ADDR		0x20000
+
+/* LED switchs */
+#define LED_SWITCH_REG		(BOARD_IO_ADDR + 0x00)
+/* buttons */
+#define SWITCH_BUTTON_REG	(BOARD_IO_ADDR + 0x08)
+/* status, interrupt */
+#define INTR_STATUS_REG		(BOARD_IO_ADDR + 0x10)
+#define INTR_RESET_REG		(BOARD_IO_ADDR + 0x20)
+/*CPLD configuration*/
+#define CONFIG1_REG		(BOARD_IO_ADDR + 0x28)
+#define CONFIG2_REG		(BOARD_IO_ADDR + 0x30)
+/*interrupt mask */
+#define INTR_MASK_REG		(BOARD_IO_ADDR + 0x38)
+
+/* magic word for debug CPLD */
+#define MAGIC_NUMBER1_REG	(BOARD_IO_ADDR + 0x40)
+#define	MAGIC_NUMBER2_REG	(BOARD_IO_ADDR + 0x48)
+/* CPLD code version */
+#define CPLD_CODE_VER_REG       (BOARD_IO_ADDR + 0x50)
+/* magic word for debug CPLD */
+#define MAGIC3_NUMBER3_REG	(BOARD_IO_ADDR + 0x58)
+/* module reset register*/
+#define CONTROL_REG		(BOARD_IO_ADDR + 0x60)
+/* CPU ID and Personality ID*/
+#define IDENT_REG		(BOARD_IO_ADDR + 0x68)
+
+/* For interrupts like xuart, enet etc */
+#define EXPIO_PARENT_INT        MX25_PIN_GPIO1_1
+
+#define EXPIO_INT_ENET_INT          (MXC_BOARD_IRQ_START + 0)
+#define EXPIO_INT_XUARTA_INT        (MXC_BOARD_IRQ_START + 1)
+#define EXPIO_INT_XUARTB_INT        (MXC_BOARD_IRQ_START + 2)
+
+/*! This is System IRQ used by LAN9217 for interrupt generation taken
+ * from platform.h
+ */
+#define LAN9217_IRQ              EXPIO_INT_ENET_INT
+
+/*! This is base virtual address of debug board*/
+extern unsigned int mx25_3stack_board_io;
+
+#define MXC_BD_LED1             (1 << 0)
+#define MXC_BD_LED2             (1 << 1)
+#define MXC_BD_LED3             (1 << 2)
+#define MXC_BD_LED4             (1 << 3)
+#define MXC_BD_LED5             (1 << 4)
+#define MXC_BD_LED6             (1 << 5)
+#define MXC_BD_LED7             (1 << 6)
+#define MXC_BD_LED8             (1 << 7)
+#define MXC_BD_LED_ON(led)
+#define MXC_BD_LED_OFF(led)
+
+#define MXC_DEFAULT_INTENSITY	127
+#define MXC_INTENSITY_OFF	0
+
+extern void mx25_3stack_gpio_init(void) __init;
+extern int headphone_det_status(void);
+extern void sgtl5000_enable_amp(void);
+extern unsigned int sdhc_get_card_det_status(struct device *dev);
+extern int sdhc_write_protect(struct device *dev);
+extern void gpio_can_active(int id);
+extern void gpio_can_inactive(int id);
+extern struct flexcan_platform_data flexcan_data[];
+extern void mx2fb_set_brightness(uint8_t);
+extern int __init mx25_3stack_init_mc34704(void);
+extern void imx_adc_set_hsync(int on);
+
+#endif				/* CONFIG_MACH_MX25_3DS */
+#endif				/* __ASM_ARCH_MXC_BOARD_MX25_3STACK_H__ */
diff --git a/arch/arm/mach-mx25/mach-mx25pdk.c b/arch/arm/mach-mx25/mach-mx25pdk.c
deleted file mode 100644
index 83d7410..0000000
--- a/arch/arm/mach-mx25/mach-mx25pdk.c
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- * Copyright 2009 Sascha Hauer, <kernel@pengutronix.de>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA  02110-1301, USA.
- */
-
-#include <linux/types.h>
-#include <linux/init.h>
-#include <linux/delay.h>
-#include <linux/clk.h>
-#include <linux/irq.h>
-#include <linux/gpio.h>
-#include <linux/fec.h>
-#include <linux/platform_device.h>
-
-#include <mach/hardware.h>
-#include <asm/mach-types.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/time.h>
-#include <asm/memory.h>
-#include <asm/mach/map.h>
-#include <mach/common.h>
-#include <mach/imx-uart.h>
-#include <mach/mx25.h>
-#include <mach/mxc_nand.h>
-#include <mach/imxfb.h>
-#include "devices.h"
-#include <mach/iomux-mx25.h>
-
-static struct imxuart_platform_data uart_pdata = {
-	.flags = IMXUART_HAVE_RTSCTS,
-};
-
-static struct pad_desc mx25pdk_pads[] = {
-	MX25_PAD_FEC_MDC__FEC_MDC,
-	MX25_PAD_FEC_MDIO__FEC_MDIO,
-	MX25_PAD_FEC_TDATA0__FEC_TDATA0,
-	MX25_PAD_FEC_TDATA1__FEC_TDATA1,
-	MX25_PAD_FEC_TX_EN__FEC_TX_EN,
-	MX25_PAD_FEC_RDATA0__FEC_RDATA0,
-	MX25_PAD_FEC_RDATA1__FEC_RDATA1,
-	MX25_PAD_FEC_RX_DV__FEC_RX_DV,
-	MX25_PAD_FEC_TX_CLK__FEC_TX_CLK,
-	MX25_PAD_A17__GPIO_2_3, /* FEC_EN, GPIO 35 */
-	MX25_PAD_D12__GPIO_4_8, /* FEC_RESET_B, GPIO 104 */
-
-	/* LCD */
-	MX25_PAD_LD0__LD0,
-	MX25_PAD_LD1__LD1,
-	MX25_PAD_LD2__LD2,
-	MX25_PAD_LD3__LD3,
-	MX25_PAD_LD4__LD4,
-	MX25_PAD_LD5__LD5,
-	MX25_PAD_LD6__LD6,
-	MX25_PAD_LD7__LD7,
-	MX25_PAD_LD8__LD8,
-	MX25_PAD_LD9__LD9,
-	MX25_PAD_LD10__LD10,
-	MX25_PAD_LD11__LD11,
-	MX25_PAD_LD12__LD12,
-	MX25_PAD_LD13__LD13,
-	MX25_PAD_LD14__LD14,
-	MX25_PAD_LD15__LD15,
-	MX25_PAD_GPIO_E__LD16,
-	MX25_PAD_GPIO_F__LD17,
-	MX25_PAD_HSYNC__HSYNC,
-	MX25_PAD_VSYNC__VSYNC,
-	MX25_PAD_LSCLK__LSCLK,
-	MX25_PAD_OE_ACD__OE_ACD,
-	MX25_PAD_CONTRAST__CONTRAST,
-};
-
-static struct fec_platform_data mx25_fec_pdata = {
-        .phy    = PHY_INTERFACE_MODE_RMII,
-};
-
-#define FEC_ENABLE_GPIO		35
-#define FEC_RESET_B_GPIO	104
-
-static void __init mx25pdk_fec_reset(void)
-{
-	gpio_request(FEC_ENABLE_GPIO, "FEC PHY enable");
-	gpio_request(FEC_RESET_B_GPIO, "FEC PHY reset");
-
-	gpio_direction_output(FEC_ENABLE_GPIO, 0);  /* drop PHY power */
-	gpio_direction_output(FEC_RESET_B_GPIO, 0); /* assert reset */
-	udelay(2);
-
-	/* turn on PHY power and lift reset */
-	gpio_set_value(FEC_ENABLE_GPIO, 1);
-	gpio_set_value(FEC_RESET_B_GPIO, 1);
-}
-
-static struct mxc_nand_platform_data mx25pdk_nand_board_info = {
-	.width		= 1,
-	.hw_ecc		= 1,
-	.flash_bbt	= 1,
-};
-
-static struct imx_fb_videomode mx25pdk_modes[] = {
-	{
-		.mode	= {
-			.name		= "CRT-VGA",
-			.refresh	= 60,
-			.xres		= 640,
-			.yres		= 480,
-			.pixclock	= 39683,
-			.left_margin	= 45,
-			.right_margin	= 114,
-			.upper_margin	= 33,
-			.lower_margin	= 11,
-			.hsync_len	= 1,
-			.vsync_len	= 1,
-		},
-		.bpp	= 16,
-		.pcr	= 0xFA208B80,
-	},
-};
-
-static struct imx_fb_platform_data mx25pdk_fb_pdata = {
-	.mode		= mx25pdk_modes,
-	.num_modes	= ARRAY_SIZE(mx25pdk_modes),
-	.pwmr		= 0x00A903FF,
-	.lscr1		= 0x00120300,
-	.dmacr		= 0x00020010,
-};
-
-static void __init mx25pdk_init(void)
-{
-	mxc_iomux_v3_setup_multiple_pads(mx25pdk_pads,
-			ARRAY_SIZE(mx25pdk_pads));
-
-	mxc_register_device(&mxc_uart_device0, &uart_pdata);
-	mxc_register_device(&mxc_usbh2, NULL);
-	mxc_register_device(&mxc_nand_device, &mx25pdk_nand_board_info);
-	mxc_register_device(&mx25_rtc_device, NULL);
-	mxc_register_device(&mx25_fb_device, &mx25pdk_fb_pdata);
-
-	mx25pdk_fec_reset();
-	mxc_register_device(&mx25_fec_device, &mx25_fec_pdata);
-}
-
-static void __init mx25pdk_timer_init(void)
-{
-	mx25_clocks_init();
-}
-
-static struct sys_timer mx25pdk_timer = {
-	.init   = mx25pdk_timer_init,
-};
-
-MACHINE_START(MX25_3DS, "Freescale MX25PDK (3DS)")
-	/* Maintainer: Freescale Semiconductor, Inc. */
-	.phys_io	= MX25_AIPS1_BASE_ADDR,
-	.io_pg_offst	= ((MX25_AIPS1_BASE_ADDR_VIRT) >> 18) & 0xfffc,
-	.boot_params    = MX25_PHYS_OFFSET + 0x100,
-	.map_io         = mx25_map_io,
-	.init_irq       = mx25_init_irq,
-	.init_machine   = mx25pdk_init,
-	.timer          = &mx25pdk_timer,
-MACHINE_END
-
diff --git a/arch/arm/mach-mx25/mx25_3stack.c b/arch/arm/mach-mx25/mx25_3stack.c
new file mode 100644
index 0000000..38a2452
--- /dev/null
+++ b/arch/arm/mach-mx25/mx25_3stack.c
@@ -0,0 +1,817 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/nodemask.h>
+#include <linux/clk.h>
+#include <linux/spi/spi.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/smsc911x.h>
+#include <linux/fec.h>
+#if defined(CONFIG_MTD) || defined(CONFIG_MTD_MODULE)
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach/flash.h>
+#endif
+
+#include <mach/common.h>
+#include <mach/hardware.h>
+#include <asm/irq.h>
+#include <asm/mach/keypad.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/time.h>
+#include <mach/memory.h>
+#include <mach/gpio.h>
+#include <mach/mmc.h>
+#include <mach/imx-uart.h>
+
+#include <mach/board-mx25_3stack.h>
+#include <mach/crm_regs.h>
+#include <mach/devices.h>
+#include <mach/iomux-mx25.h>
+
+/*!
+ * @file mach-mx25/mx25_3stack.c
+ *
+ * @brief This file contains the board specific initialization routines.
+ *
+ * @ingroup MSL_MX25
+ */
+
+unsigned int mx25_3stack_board_io;
+
+/* working point(wp): 0 - 399MHz; 1 - 266MHz; 2 - 133MHz; */
+/* 24MHz input clock table */
+static struct cpu_wp cpu_wp_mx25[] = {
+	{
+		.pll_rate = 399000000,
+		.cpu_rate = 399000000,
+		.cpu_podf = 0x0,
+		.cpu_voltage = 1450000
+	}, {
+		.pll_rate = 532000000,
+		.cpu_rate = 266000000,
+		.cpu_podf = 0x1,
+		.cpu_voltage = 1340000
+	}, {
+		.pll_rate = 532000000,
+		.cpu_rate = 133000000,
+		.cpu_podf = 0x3,
+		.cpu_voltage = 1340000
+	},
+};
+struct cpu_wp *get_cpu_wp(int *wp)
+{
+	*wp = 3;
+	return cpu_wp_mx25;
+}
+
+#if defined(CONFIG_KEYBOARD_MXC) || defined(CONFIG_KEYBOARD_MXC_MODULE)
+static u16 keymapping[16] = {
+	KEY_UP, KEY_DOWN, KEY_VOLUMEDOWN, KEY_HOME,
+	KEY_RIGHT, KEY_LEFT, KEY_ENTER, KEY_VOLUMEUP,
+	KEY_F6, KEY_F8, KEY_F9, KEY_F10,
+	KEY_F1, KEY_F2, KEY_F3, KEY_POWER,
+};
+
+static struct resource mxc_kpp_resources[] = {
+	[0] = {
+	       .start	= MX25_INT_KPP,
+	       .end	= MX25_INT_KPP,
+	       .flags	= IORESOURCE_IRQ,
+	       }
+};
+
+static struct keypad_data keypad_plat_data = {
+	.rowmax = 4,
+	.colmax = 4,
+	.irq = MX25_INT_KPP,
+	.learning = 0,
+	.delay = 2,
+	.matrix = keymapping,
+};
+
+/* mxc keypad driver */
+struct platform_device mxc_keypad_device = {
+	.name = "mxc_keypad",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(mxc_kpp_resources),
+	.resource = mxc_kpp_resources,
+	.dev = {
+		.platform_data = &keypad_plat_data,
+		},
+};
+
+static void mxc_init_keypad(void)
+{
+	(void)platform_device_register(&mxc_keypad_device);
+}
+#else
+static inline void mxc_init_keypad(void)
+{
+}
+#endif
+
+/* MTD NAND flash */
+
+#if defined(CONFIG_MTD_NAND_MXC_V2) || defined(CONFIG_MTD_NAND_MXC_V2_MODULE)
+
+static struct mtd_partition mxc_nand_partitions[] = {
+	{
+		.name	= "nand.bootloader",
+		.offset	= 0,
+		.size	= 3 * 1024 * 1024
+	}, {
+		.name	= "nand.kernel",
+		.offset	= MTDPART_OFS_APPEND,
+		.size	= 5 * 1024 * 1024
+	}, {
+		.name	= "nand.rootfs",
+		.offset	= MTDPART_OFS_APPEND,
+		.size	= 256 * 1024 * 1024
+	}, {
+		.name	= "nand.configure",
+		.offset	= MTDPART_OFS_APPEND,
+		.size	= 8 * 1024 * 1024
+	}, {
+		.name	= "nand.userfs",
+		.offset	= MTDPART_OFS_APPEND,
+		.size	= MTDPART_SIZ_FULL
+	},
+};
+
+static struct flash_platform_data mxc_nand_data = {
+	.parts = mxc_nand_partitions,
+	.nr_parts = ARRAY_SIZE(mxc_nand_partitions),
+	.width = 1,
+};
+
+static struct platform_device mxc_nand_mtd_device = {
+	.name = "mxc_nandv2_flash",
+	.id = 0,
+	.dev = {
+		.platform_data = &mxc_nand_data,
+		},
+};
+
+static void mxc_init_nand_mtd(void)
+{
+	if (__raw_readl(MXC_CCM_RCSR) & MXC_CCM_RCSR_NF16B)
+		mxc_nand_data.width = 2;
+
+	platform_device_register(&mxc_nand_mtd_device);
+}
+#else
+static inline void mxc_init_nand_mtd(void)
+{
+}
+#endif
+
+#if defined(CONFIG_FB_MXC_SYNC_PANEL) || \
+    defined(CONFIG_FB_MXC_SYNC_PANEL_MODULE)
+static const char fb_default_mode[] = "CPT-VGA";
+
+/* mxc lcd driver */
+static struct platform_device mxc_fb_device = {
+	.name = "mxc_sdc_fb",
+	.id = 0,
+	.dev = {
+		.platform_data = &fb_default_mode,
+		.coherent_dma_mask = 0xFFFFFFFF,
+	},
+};
+
+/*
+ * Power on/off CPT VGA panel.
+ */
+void board_power_lcd(int on)
+{
+	if (on)
+		mx2fb_set_brightness(MXC_DEFAULT_INTENSITY);
+	else
+		mx2fb_set_brightness(MXC_INTENSITY_OFF);
+}
+EXPORT_SYMBOL_GPL(board_power_lcd);
+
+static void mxc_init_fb(void)
+{
+	(void)platform_device_register(&mxc_fb_device);
+}
+#else
+static inline void mxc_init_fb(void)
+{
+}
+#endif
+
+#if defined(CONFIG_BACKLIGHT_MXC)
+static struct platform_device mxcbl_devices[] = {
+	{
+	 .name = "mxc_lcdc_bl",
+	 .id = 0,
+	 },
+};
+
+static inline void mxc_init_bl(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(mxcbl_devices); i++)
+		platform_device_register(&mxcbl_devices[i]);
+}
+#else
+static inline void mxc_init_bl(void)
+{
+}
+#endif
+
+/*!
+ * Power Key interrupt handler.
+ */
+static irqreturn_t power_key_int(int irq, void *dev_id)
+{
+	pr_info("on-off key pressed\n");
+	return 0;
+}
+
+/*!
+ * Power Key initialization.
+ */
+static int __init mxc_init_power_key(void)
+{
+	/*Set power key as wakeup resource */
+	int irq, ret;
+
+	mxc_request_iomux(MX25_PIN_A25, MUX_CONFIG_ALT5);
+	mxc_iomux_set_pad(MX25_PIN_A25, PAD_CTL_DRV_NORMAL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_A25), NULL);
+	gpio_direction_input(IOMUX_TO_GPIO(MX25_PIN_A25));
+
+	irq = IOMUX_TO_IRQ(MX25_PIN_A25);
+	set_irq_type(irq, IRQF_TRIGGER_RISING);
+	ret = request_irq(irq, power_key_int, 0, "power_key", 0);
+	if (ret)
+		pr_info("register on-off key interrupt failed\n");
+	else
+		enable_irq_wake(irq);
+
+	return ret;
+}
+
+late_initcall(mxc_init_power_key);
+
+static struct spi_board_info mxc_spi_board_info[] __initdata = {
+	{
+		.modalias	= "cpld_spi",
+		.max_speed_hz	= 18000000,
+		.bus_num	= 1,
+		.chip_select	= 0,
+		.mode		= SPI_MODE_2,
+	}, {
+		.modalias	= "wm8580_spi",
+		.max_speed_hz	= 8000000,
+		.bus_num	= 1,
+		.chip_select	= 1,
+	},
+};
+
+static struct mxc_camera_platform_data camera_data = {
+	.core_regulator		= NULL,
+	.io_regulator		= NULL,
+	.analog_regulator	= NULL,
+	.gpo_regulator		= NULL,
+	.mclk			= 24000000,
+};
+
+static struct i2c_board_info mxc_i2c_board_info[] __initdata = {
+	{
+		.type = "sgtl5000-i2c",
+		.addr = 0x0a,
+	}, {
+		.type = "ak5702-i2c",
+		.addr = 0x13,
+	}, {
+		.type = "ov2640",
+		.addr = 0x30,
+		.platform_data = (void *)&camera_data,
+	},
+};
+
+#if defined(CONFIG_SND_SOC_IMX_3STACK_SGTL5000) \
+    || defined(CONFIG_SND_SOC_IMX_3STACK_SGTL5000_MODULE)
+static struct mxc_audio_platform_data sgtl5000_data = {
+	.ssi_num	= 2,
+	.src_port	= 1,
+	.ext_port	= 4,
+	.hp_irq		= IOMUX_TO_IRQ(MX25_PIN_A10),
+	.hp_status	= headphone_det_status,
+	.sysclk		= 8300000,
+};
+
+static struct platform_device mxc_sgtl5000_device = {
+	.name = "imx-3stack-sgtl5000",
+	.dev = {
+		.platform_data = &sgtl5000_data,
+	},
+};
+
+static void mxc_init_sgtl5000(void)
+{
+	struct clk *cko1, *parent;
+	unsigned long rate;
+
+	/* cko1 clock */
+	mxc_request_iomux(MX25_PIN_CLKO, MUX_CONFIG_FUNC);
+
+	cko1 = clk_get(NULL, "clko_clk");
+	if (IS_ERR(cko1))
+		return;
+	parent = clk_get(NULL, "ipg_clk");
+	if (IS_ERR(parent))
+		return;
+	clk_set_parent(cko1, parent);
+	rate = clk_round_rate(cko1, 13000000);
+	if (rate < 8000000 || rate > 27000000) {
+		pr_err("Error: SGTL5000 mclk freq %ld out of range!\n", rate);
+		clk_put(parent);
+		clk_put(cko1);
+		return;
+	}
+	clk_set_rate(cko1, rate);
+	clk_enable(cko1);
+	sgtl5000_data.sysclk = rate;
+	sgtl5000_enable_amp();
+	platform_device_register(&mxc_sgtl5000_device);
+}
+#else
+static inline void mxc_init_sgtl5000(void)
+{
+}
+#endif
+
+#if defined(CONFIG_SND_SOC_IMX_3STACK_AK5702) \
+    || defined(CONFIG_SND_SOC_IMX_3STACK_AK5702_MODULE)
+static struct platform_device mxc_ak5702_device = {
+	.name = "imx-3stack-ak5702",
+};
+
+static void mxc_init_ak5702(void)
+{
+	platform_device_register(&mxc_ak5702_device);
+}
+#else
+static inline void mxc_init_ak5702(void)
+{
+}
+#endif
+
+#if  defined(CONFIG_SMSC911X) || defined(CONFIG_SMSC911X_MODULE)
+static struct resource smsc911x_resources[] = {
+	{
+		.start	= LAN9217_BASE_ADDR,
+		.end	= LAN9217_BASE_ADDR + 255,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= MXC_BOARD_IRQ_START,
+		.end	= MXC_BOARD_IRQ_START,
+		.flags	= IORESOURCE_IRQ,
+	}
+};
+
+struct smsc911x_platform_config smsc911x_config = {
+	.irq_polarity = SMSC911X_IRQ_POLARITY_ACTIVE_LOW,
+	.flags = 0x8000 | SMSC911X_USE_16BIT | SMSC911X_FORCE_INTERNAL_PHY,
+};
+
+static struct platform_device smsc_lan9217_device = {
+	.name = "smsc911x",
+	.id = 0,
+	.dev = {
+		.platform_data = &smsc911x_config,
+		},
+	.num_resources = ARRAY_SIZE(smsc911x_resources),
+	.resource = smsc911x_resources,
+};
+
+static int __init mxc_init_enet(void)
+{
+	(void)platform_device_register(&smsc_lan9217_device);
+	return 0;
+}
+#else
+static int __init mxc_init_enet(void)
+{
+	return 0;
+}
+#endif
+
+late_initcall(mxc_init_enet);
+
+#if defined(CONFIG_FEC) || defined(CONFIG_FEC_MODULE)
+static struct resource mxc_fec_resources[] = {
+	{
+		.start	= MX25_FEC_BASE_ADDR,
+		.end	= MX25_FEC_BASE_ADDR + 0xfff,
+		.flags	= IORESOURCE_MEM
+	}, {
+		.start	= MX25_INT_FEC,
+		.end	= MX25_INT_FEC,
+		.flags	= IORESOURCE_IRQ
+	},
+};
+
+static struct fec_platform_data fec_data = {
+	.phy = PHY_INTERFACE_MODE_RMII,
+};
+
+struct platform_device mxc_fec_device = {
+	.name = "fec",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(mxc_fec_resources),
+	.resource = mxc_fec_resources,
+	.dev = {
+		.platform_data = &fec_data,
+	},
+};
+
+static __init int mxc_init_fec(void)
+{
+	return platform_device_register(&mxc_fec_device);
+}
+#else
+static inline int mxc_init_fec(void)
+{
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_IMX_SIM) || defined(CONFIG_IMX_SIM_MODULE)
+/* Used to configure the SIM bus */
+static struct mxc_sim_platform_data sim1_data = {
+	.clk_rate	= 5000000,
+	.clock_sim	= "sim1_clk",
+	.power_sim	= NULL,
+	.init		= NULL,
+	.exit		= NULL,
+	.detect		= 1,
+};
+
+/*!
+ * Resource definition for the SIM
+ */
+static struct resource mxc_sim1_resources[] = {
+	{
+	       .start	= SIM1_BASE_ADDR,
+	       .end	= SIM1_BASE_ADDR + SZ_4K - 1,
+	       .flags	= IORESOURCE_MEM,
+	}, {
+	       .start	= MXC_INT_SIM1,
+	       .end	= MXC_INT_SIM1,
+	       .flags	= IORESOURCE_IRQ,
+	}, {
+	       .start	= 0,
+	       .end	= 0,
+	       .flags	= IORESOURCE_IRQ,
+	},
+};
+
+/*! Device Definition for IMX SIM */
+static struct platform_device mxc_sim1_device = {
+	.name = "mxc_sim",
+	.id = 0,
+	.dev = {
+		.platform_data = &sim1_data,
+		},
+	.num_resources = ARRAY_SIZE(mxc_sim1_resources),
+	.resource = mxc_sim1_resources,
+};
+
+static inline void mxc_init_sim(void)
+{
+	(void)platform_device_register(&mxc_sim1_device);
+}
+#else
+static inline void mxc_init_sim(void)
+{
+}
+#endif
+
+#if defined(CONFIG_MMC_IMX_ESDHCI) || defined(CONFIG_MMC_IMX_ESDHCI_MODULE)
+static struct mxc_mmc_platform_data mmc1_data = {
+	.ocr_mask = MMC_VDD_29_30 | MMC_VDD_32_33,
+	.caps = MMC_CAP_4_BIT_DATA,
+	.min_clk = 400000,
+	.max_clk = 52000000,
+	.card_inserted_state = 1,
+	.status = sdhc_get_card_det_status,
+	.wp_status = sdhc_write_protect,
+	.clock_mmc = "esdhc_clk",
+};
+
+/*!
+ * Resource definition for the SDHC1
+ */
+static struct resource mxcsdhc1_resources[] = {
+	{
+		.start	= MX25_MMC_SDHC1_BASE_ADDR,
+		.end	= MX25_MMC_SDHC1_BASE_ADDR + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= MX25_INT_SDHC1,
+		.end	= MX25_INT_SDHC1,
+		.flags	= IORESOURCE_IRQ,
+	}, {
+		.start	= IOMUX_TO_IRQ(MX25_PIN_A15),
+		.end	= IOMUX_TO_IRQ(MX25_PIN_A15),
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+/*! Device Definition for MXC SDHC1 */
+static struct platform_device mxcsdhc1_device = {
+	.name	= "mxsdhci",
+	.id	= 0,
+	.dev	= {
+			.platform_data = &mmc1_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcsdhc1_resources),
+	.resource = mxcsdhc1_resources,
+};
+
+#ifdef CONFIG_MMC_IMX_ESDHCI_SELECT2
+static struct mxc_mmc_platform_data mmc2_data = {
+	.ocr_mask	= MMC_VDD_29_30 | MMC_VDD_32_33,
+	.caps		= MMC_CAP_4_BIT_DATA,
+	.min_clk	= 400000,
+	.max_clk	= 52000000,
+	.card_fixed	= 1,
+	.card_inserted_state	= 1,
+	.status		= sdhc_get_card_det_status,
+	.clock_mmc	= "esdhc2_clk",
+};
+
+/*!
+ * Resource definition for the SDHC2
+ */
+static struct resource mxcsdhc2_resources[] = {
+	{
+		.start	= MX25_MMC_SDHC2_BASE_ADDR,
+		.end	= MX25_MMC_SDHC2_BASE_ADDR + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= MX25_INT_SDHC2,
+		.end	= MX25_INT_SDHC2,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+/*! Device Definition for MXC SDHC2 */
+static struct platform_device mxcsdhc2_device = {
+	.name	= "mxsdhci",
+	.id	= 1,
+	.dev	= {
+			.platform_data = &mmc2_data,
+		},
+	.num_resources	= ARRAY_SIZE(mxcsdhc2_resources),
+	.resource	= mxcsdhc2_resources,
+};
+#endif
+
+static inline void mxc_init_mmc(void)
+{
+	(void)platform_device_register(&mxcsdhc1_device);
+#ifdef CONFIG_MMC_IMX_ESDHCI_SELECT2
+	(void)platform_device_register(&mxcsdhc2_device);
+#endif
+}
+#else
+static inline void mxc_init_mmc(void)
+{
+}
+#endif
+
+static void __init mx25_3stack_timer_init(void)
+{
+	mx25_clocks_init();
+}
+
+static struct sys_timer mxc_timer = {
+	.init = mx25_3stack_timer_init,
+};
+
+#if defined(CONFIG_CAN_FLEXCAN) || defined(CONFIG_CAN_FLEXCAN_MODULE)
+static void flexcan_xcvr_enable(int id, int en)
+{
+	static int pwdn;
+
+	if (id != 1)		/* MX25 3-stack uses only CAN2 */
+		return;
+
+	if (en) {
+		if (!pwdn++)
+			gpio_set_value(IOMUX_TO_GPIO(MX25_PIN_D14), 0);
+	} else {
+		if (!--pwdn)
+			gpio_set_value(IOMUX_TO_GPIO(MX25_PIN_D14), 1);
+	}
+}
+
+struct flexcan_platform_data flexcan_data[] = {
+	{
+		.core_reg	= NULL,
+		.io_reg		= NULL,
+		.xcvr_enable	= flexcan_xcvr_enable,
+		.active		= gpio_can_active,
+		.inactive	= gpio_can_inactive,
+		.br_clksrc	= 1,
+		.br_rjw		= 2,
+		.br_presdiv	= 6,
+		.br_propseg	= 4,
+		.br_pseg1	= 4,
+		.br_pseg2	= 7,
+		.bcc		= 1,
+		.srx_dis	= 1,
+		.smp		= 1,
+		.boff_rec	= 1,
+		.ext_msg	= 1,
+		.std_msg	= 1,
+	}, {
+		.core_reg	= NULL,
+		.io_reg		= NULL,
+		.xcvr_enable	= flexcan_xcvr_enable,
+		.active		= gpio_can_active,
+		.inactive	= gpio_can_inactive,
+		.br_clksrc	= 1,
+		.br_rjw		= 2,
+		.br_presdiv	= 6,
+		.br_propseg	= 4,
+		.br_pseg1	= 4,
+		.br_pseg2	= 7,
+		.bcc		= 1,
+		.srx_dis	= 1,
+		.smp		= 1,
+		.boff_rec	= 1,
+		.ext_msg	= 1,
+		.std_msg	= 1,
+	},
+};
+
+static struct resource flexcan1_resources[] = {
+	{
+		.start	= MX25_CAN1_BASE_ADDR,
+		.end	= MX25_CAN1_BASE_ADDR + 0x97F,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= MX25_INT_CAN1,
+		.end	= MX25_INT_CAN1,
+		.flags	= IORESOURCE_IRQ,
+	}
+};
+static struct resource flexcan2_resources[] = {
+	{
+		.start	= MX25_CAN3_BASE_ADDR,
+		.end	= MX25_CAN3_BASE_ADDR + 0x97F,
+		.flags	= IORESOURCE_MEM,
+	}, {
+		.start	= MX25_INT_CAN2,
+		.end	= MX25_INT_CAN2,
+		.flags	= IORESOURCE_IRQ,
+	}
+};
+
+static struct platform_device flexcan_devices[] = {
+	{
+		.name	= "FlexCAN",
+		.id	= 0,
+		.num_resources	= ARRAY_SIZE(flexcan1_resources),
+		.resource	= flexcan1_resources,
+	}, {
+		.name	= "FlexCAN",
+		.id	= 1,
+		.num_resources	= ARRAY_SIZE(flexcan2_resources),
+		.resource	= flexcan2_resources,
+	},
+};
+
+static inline void mxc_init_flexcan(void)
+{
+#ifdef CONFIG_FLEXCAN_MXC_SELECT1
+	/* MX25 3stack doesn't use CAN1 */
+	mxc_register_device(&flexcan_devices[0], &flexcan_data[0]);
+#endif
+	mxc_register_device(&flexcan_devices[1], &flexcan_data[1]);
+}
+#else
+static inline void mxc_init_flexcan(void)
+{
+}
+#endif
+
+/*!
+ * Board specific fixup function. It is called by \b setup_arch() in
+ * setup.c file very early on during kernel starts. It allows the user to
+ * statically fill in the proper values for the passed-in parameters. None of
+ * the parameters is used currently.
+ *
+ * @param  desc         pointer to \b struct \b machine_desc
+ * @param  tags         pointer to \b struct \b tag
+ * @param  cmdline      pointer to the command line
+ * @param  mi           pointer to \b struct \b meminfo
+ */
+static void __init fixup_mxc_board(struct machine_desc *desc, struct tag *tags,
+				   char **cmdline, struct meminfo *mi)
+{
+	mxc_cpu_init();
+
+#ifdef CONFIG_DISCONTIGMEM
+	do {
+		int nid;
+		mi->nr_banks = MXC_NUMNODES;
+		for (nid = 0; nid < mi->nr_banks; nid++)
+			SET_NODE(mi, nid);
+	} while (0);
+#endif
+}
+
+#if defined(CONFIG_SERIAL_IMX) || defined(CONFIG_SERIAL_IMX_MODULE)
+static struct imxuart_platform_data uart_pdata = {
+	.flags = IMXUART_HAVE_RTSCTS,
+};
+
+static inline void mxc_init_imx_uart(void)
+{
+	mxc_register_device(&mxc_uart_device0, &uart_pdata);
+	mxc_register_device(&mxc_uart_device1, &uart_pdata);
+}
+#else /* !SERIAL_IMX */
+static inline void mxc_init_imx_uart(void)
+{
+}
+#endif
+
+/*!
+ * Board specific initialization.
+ */
+static void __init mxc_board_init(void)
+{
+	pr_info("AIPS1 VA base: 0x%p\n", IO_ADDRESS(MX25_AIPS1_BASE_ADDR));
+	mxc_init_imx_uart();
+	mxc_cpu_common_init();
+	mx25_3stack_gpio_init();
+	early_console_setup(saved_command_line);
+	mxc_init_devices();
+
+	mxc_init_keypad();
+#ifdef CONFIG_I2C
+	i2c_register_board_info(0, mxc_i2c_board_info,
+				ARRAY_SIZE(mxc_i2c_board_info));
+#endif
+	spi_register_board_info(mxc_spi_board_info,
+				ARRAY_SIZE(mxc_spi_board_info));
+	mx25_3stack_init_mc34704();
+	mxc_init_fb();
+	mxc_init_bl();
+	mxc_init_nand_mtd();
+	mxc_init_sgtl5000();
+	mxc_init_ak5702();
+	mxc_init_mmc();
+	mxc_init_sim();
+	mxc_init_fec();
+	mxc_init_flexcan();
+}
+
+/*
+ * The following uses standard kernel macros define in arch.h in order to
+ * initialize __mach_desc_MX25_3DS data structure.
+ */
+/* *INDENT-OFF* */
+MACHINE_START(MX25_3DS, "Freescale MX25 3-Stack Board")
+	/* Maintainer: Freescale Semiconductor, Inc. */
+	.phys_io = MX25_AIPS1_BASE_ADDR,
+	.io_pg_offst = ((MX25_AIPS1_BASE_ADDR_VIRT) >> 18) & 0xfffc,
+	.boot_params = PHYS_OFFSET + 0x100,
+	.fixup = fixup_mxc_board,
+	.map_io = mx25_map_io,
+	.init_irq = mx25_init_irq,
+	.init_machine = mxc_board_init,
+	.timer = &mxc_timer,
+MACHINE_END
diff --git a/arch/arm/mach-mx25/mx25_3stack_cpld.c b/arch/arm/mach-mx25/mx25_3stack_cpld.c
new file mode 100644
index 0000000..03c722b
--- /dev/null
+++ b/arch/arm/mach-mx25/mx25_3stack_cpld.c
@@ -0,0 +1,246 @@
+/*
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <mach/hardware.h>
+#include <asm/mach/irq.h>
+#include <mach/gpio.h>
+#include <mach/board-mx25_3stack.h>
+#include <mach/iomux-mx25.h>
+
+/*!
+ * @file mach-mx25/mx25_3stack_cpld.c
+ *
+ * @brief This file contains the board specific initialization routines.
+ *
+ * @ingroup MSL_MX25
+ */
+
+extern int mxc_spi_poll_transfer(struct spi_device *spi,
+				 struct spi_transfer *t);
+static int __init mxc_expio_init(void);
+
+struct spi_device *cpld_spi;
+
+/*!
+ * This function is used to tranfer data to CPLD regs over CSPI
+ */
+static inline int mx25_3ds_cpld_rw(u8 *buf, size_t len)
+{
+	struct spi_transfer t = {
+		.tx_buf = (const void *)buf,
+		.rx_buf = buf,
+		.len = len,
+		.cs_change = 0,
+		.delay_usecs = 0,
+	};
+
+	if (!cpld_spi)
+		return -1;
+
+	mxc_spi_poll_transfer(cpld_spi, &t);
+	return 0;
+}
+
+/*!
+ * This function is called to read a CPLD register over CSPI.
+ *
+ * @param        offset    number of the cpld register to be read
+ *
+ * @return       Returns 0 on success -1 on failure.
+ */
+unsigned int spi_cpld_read(unsigned int offset)
+{
+	unsigned int frame[2];
+	unsigned int reg_num = offset >> 1;
+	unsigned int data = 0;
+
+	frame[0] = (1 << 13) | ((reg_num & 0x0001FFFF) >> 5) | 0x00001000;
+	frame[1] = (((reg_num & 0x0000001F) << 27) | 0x0200001f);
+	mx25_3ds_cpld_rw((u8 *) frame, 2);
+	data = (frame[1] >> 6) & 0xFFFF;
+
+	reg_num = (offset + 2) >> 1;
+	frame[0] = (1 << 13) | ((reg_num & 0x0001FFFF) >> 5) | 0x00001000;
+	frame[1] = (((reg_num & 0x0000001F) << 27) | 0x0200001f);
+	mx25_3ds_cpld_rw((u8 *) frame, 2);
+
+	data |= (((frame[1] >> 6) & 0xFFFF) << 16);
+	return data;
+}
+EXPORT_SYMBOL(spi_cpld_read);
+
+/*!
+ * This function is called to write to a CPLD register over CSPI.
+ *
+ * @param        offset    number of the cpld register to be written
+ * @param        reg_val   value to be written
+ *
+ * @return       Returns 0 on success -1 on failure.
+ */
+unsigned int spi_cpld_write(unsigned int offset, unsigned int reg_val)
+{
+	unsigned int frame[2] = { 0, 0 };
+	unsigned int reg_num = offset >> 1;
+	unsigned int data = reg_val;
+
+	frame[0] = ((reg_num & 0x0001FFFF) >> 5) | 0x00001000;
+	frame[1] = (((reg_num & 0x0000001F) << 27) |
+		    ((data & 0x0000FFFF) << 6) | 0x03C00027);
+	mx25_3ds_cpld_rw((u8 *) frame, 2);
+
+	reg_num = (offset + 2) >> 1;
+	data = reg_val >> 16;
+	frame[0] = 0;
+	frame[1] = 0;
+	frame[0] = ((reg_num & 0x0001FFFF) >> 5) | 0x00001000;
+	frame[1] = (((reg_num & 0x0000001F) << 27) |
+		    ((data & 0x0000FFFF) << 6) | 0x03C00027);
+
+	mx25_3ds_cpld_rw((u8 *) frame, 2);
+
+	return 0;
+}
+EXPORT_SYMBOL(spi_cpld_write);
+
+static int __init mx25_3ds_cpld_probe(struct spi_device *spi)
+{
+	unsigned int i = 0;
+
+	spi->bits_per_word = 46;
+	cpld_spi = spi;
+
+	spi_setup(spi);
+	i = spi_cpld_read(CPLD_CODE_VER_REG);
+	pr_info("3-Stack Debug board detected, rev = 0x%04X\n", i);
+	spi_cpld_write(LED_SWITCH_REG, 0xFF);
+
+	/* disable the interrupt and clear the status */
+	spi_cpld_write(INTR_MASK_REG, 0);
+	spi_cpld_write(INTR_RESET_REG, 0xFFFF);
+	spi_cpld_write(INTR_RESET_REG, 0);
+	spi_cpld_write(INTR_MASK_REG, 0x1E);
+
+	mxc_expio_init();
+	return 0;
+}
+
+/*!
+ * This structure contains pointers to the CPLD callback functions.
+ */
+static struct spi_driver mx25_3ds_cpld_driver = {
+	.driver = {
+		   .name = "cpld_spi",
+		   .bus = &spi_bus_type,
+		   .owner = THIS_MODULE,
+		   },
+	.probe = mx25_3ds_cpld_probe,
+};
+
+static int __init mx25_3ds_cpld_init(void)
+{
+	pr_info("Registering the CPLD Driver\n");
+	return spi_register_driver(&mx25_3ds_cpld_driver);
+}
+device_initcall(mx25_3ds_cpld_init);
+
+static int __initdata is_dbg_removed = { 0 };
+static int __init remove_dbg_setup(char *__unused)
+{
+	is_dbg_removed = 1;
+	return 0;
+}
+__setup("remove_dbg", remove_dbg_setup);
+
+static void mxc_expio_irq_handler(u32 irq, struct irq_desc *desc)
+{
+	u32 expio_irq;
+	struct irq_desc *d;
+
+	desc->chip->mask(irq);	/* irq = gpio irq number */
+
+	expio_irq = MXC_BOARD_IRQ_START;
+
+	d = irq_desc + expio_irq;
+	if (unlikely(!(d->handle_irq))) {
+		printk(KERN_ERR "\nEXPIO irq: %d unhandled\n", expio_irq);
+		BUG();		/* oops */
+	}
+	d->handle_irq(expio_irq, d);
+
+	desc->chip->ack(irq);
+	desc->chip->unmask(irq);
+}
+
+/*
+ * Disable an expio pin's interrupt by setting the bit in the imr.
+ * @param irq		an expio virtual irq number
+ */
+static void expio_mask_irq(u32 irq)
+{
+}
+
+/*
+ * Acknowledge an expanded io pin's interrupt by clearing the bit in the isr.
+ * @param irq		an expanded io virtual irq number
+ */
+static void expio_ack_irq(u32 irq)
+{
+	/* clear the interrupt status */
+	spi_cpld_write(INTR_RESET_REG, 1);
+	spi_cpld_write(INTR_RESET_REG, 0);
+}
+
+/*
+ * Enable a expio pin's interrupt by clearing the bit in the imr.
+ * @param irq		a expio virtual irq number
+ */
+static void expio_unmask_irq(u32 irq)
+{
+}
+
+static struct irq_chip expio_irq_chip = {
+	.ack = expio_ack_irq,
+	.mask = expio_mask_irq,
+	.unmask = expio_unmask_irq,
+};
+
+static int __init mxc_expio_init(void)
+{
+	int i;
+
+	if (is_dbg_removed)
+		return 0;
+
+	/*
+	 * Configure INT line as GPIO input
+	 */
+	mxc_request_iomux(MX25_PIN_PWM, MUX_CONFIG_GPIO);
+	mxc_iomux_set_pad(MX25_PIN_PWM, PAD_CTL_PUE_PUD);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_PWM), NULL);
+	gpio_direction_input(IOMUX_TO_GPIO(MX25_PIN_PWM));
+
+	for (i = MXC_BOARD_IRQ_START;
+	     i < (MXC_BOARD_IRQ_START + MXC_BOARD_IRQS);
+	     i++) {
+		set_irq_chip(i, &expio_irq_chip);
+		set_irq_handler(i, handle_level_irq);
+		set_irq_flags(i, IRQF_VALID);
+	}
+	set_irq_type(IOMUX_TO_IRQ(MX25_PIN_PWM), IRQF_TRIGGER_LOW);
+	set_irq_chained_handler(IOMUX_TO_IRQ(MX25_PIN_PWM),
+				mxc_expio_irq_handler);
+
+	return 0;
+}
diff --git a/arch/arm/mach-mx25/mx25_3stack_gpio.c b/arch/arm/mach-mx25/mx25_3stack_gpio.c
new file mode 100644
index 0000000..f8c15f7
--- /dev/null
+++ b/arch/arm/mach-mx25/mx25_3stack_gpio.c
@@ -0,0 +1,1356 @@
+/*
+ * Copyright (C) 2008-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <mach/hardware.h>
+#include <mach/gpio.h>
+#include <mach/board-mx25_3stack.h>
+#include <mach/iomux-mx25.h>
+
+/*!
+ * @file mach-mx25/mx25_3stack_gpio.c
+ *
+ * @brief This file contains all the GPIO setup functions for the board.
+ *
+ * @ingroup GPIO_MX25
+ */
+static struct mxc_iomux_pin_cfg __initdata mxc_iomux_pins[] = {
+};
+
+static struct mxc_iomux_pin_cfg __initdata sim_iomux_pins[] = {
+	/* SIM1 */
+	/* SIM1 CLK */
+	{
+	 MX25_PIN_CSI_D2, MUX_CONFIG_ALT4,
+	 PAD_CTL_SRE_FAST |
+	 PAD_CTL_DRV_HIGH | PAD_CTL_DRV_3_3V |
+	 PAD_CTL_HYS_CMOS | PAD_CTL_47K_PU |
+	 PAD_CTL_PUE_PULL | PAD_CTL_ODE_CMOS | PAD_CTL_PKE_ENABLE,
+	 },
+	/* SIM1 RST */
+	{
+	 MX25_PIN_CSI_D3, MUX_CONFIG_ALT4,
+	 PAD_CTL_DRV_HIGH | PAD_CTL_DRV_3_3V |
+	 PAD_CTL_HYS_CMOS | PAD_CTL_47K_PU |
+	 PAD_CTL_PUE_PULL | PAD_CTL_ODE_CMOS | PAD_CTL_PKE_ENABLE,
+	 },
+	/* SIM1 VEN */
+	{
+	 MX25_PIN_CSI_D4, MUX_CONFIG_ALT4,
+	 PAD_CTL_DRV_HIGH | PAD_CTL_DRV_3_3V |
+	 PAD_CTL_HYS_CMOS | PAD_CTL_100K_PU |
+	 PAD_CTL_PUE_PULL | PAD_CTL_ODE_CMOS | PAD_CTL_PKE_ENABLE,
+	 },
+	/* SIM1 TX */
+	{
+	 MX25_PIN_CSI_D5, MUX_CONFIG_ALT4,
+	 PAD_CTL_SRE_FAST |
+	 PAD_CTL_DRV_HIGH | PAD_CTL_DRV_3_3V |
+	 PAD_CTL_HYS_CMOS | PAD_CTL_22K_PU |
+	 PAD_CTL_PUE_PULL | PAD_CTL_ODE_OpenDrain | PAD_CTL_PKE_ENABLE,
+	 },
+	/* SIM1 PD */
+	{
+	 MX25_PIN_CSI_D6, MUX_CONFIG_ALT4,
+	 PAD_CTL_DRV_HIGH | PAD_CTL_DRV_3_3V |
+	 PAD_CTL_HYS_CMOS | PAD_CTL_22K_PU |
+	 PAD_CTL_PUE_PULL | PAD_CTL_ODE_CMOS | PAD_CTL_PKE_ENABLE,
+	 },
+	/* SIM2 */
+	/* SIM2 CLK */
+	{
+	 MX25_PIN_CSI_D8, MUX_CONFIG_ALT4,
+	 PAD_CTL_DRV_NORMAL | PAD_CTL_DRV_3_3V |
+	 PAD_CTL_HYS_SCHMITZ | PAD_CTL_100K_PU |
+	 PAD_CTL_PUE_KEEPER | PAD_CTL_ODE_CMOS | PAD_CTL_PKE_ENABLE,
+	 },
+	/* SIM2 RST */
+	{
+	 MX25_PIN_CSI_D9, MUX_CONFIG_ALT4,
+	 PAD_CTL_DRV_NORMAL | PAD_CTL_DRV_3_3V |
+	 PAD_CTL_HYS_SCHMITZ | PAD_CTL_100K_PU |
+	 PAD_CTL_PUE_KEEPER | PAD_CTL_ODE_CMOS | PAD_CTL_PKE_ENABLE,
+	 },
+	/* SIM2 VEN */
+	{
+	 MX25_PIN_CSI_MCLK, MUX_CONFIG_ALT4,
+	 PAD_CTL_DRV_NORMAL | PAD_CTL_DRV_3_3V |
+	 PAD_CTL_HYS_SCHMITZ | PAD_CTL_100K_PU |
+	 PAD_CTL_PUE_PULL | PAD_CTL_ODE_CMOS | PAD_CTL_PKE_NONE,
+	 },
+	/* SIM2 TX */
+	{
+	 MX25_PIN_CSI_VSYNC, MUX_CONFIG_ALT4,
+	 PAD_CTL_DRV_NORMAL | PAD_CTL_DRV_3_3V |
+	 PAD_CTL_HYS_SCHMITZ | PAD_CTL_100K_PU |
+	 PAD_CTL_PUE_KEEPER | PAD_CTL_ODE_CMOS | PAD_CTL_PKE_ENABLE,
+	 },
+	/* SIM2 PD */
+	{
+	 MX25_PIN_CSI_HSYNC, MUX_CONFIG_ALT4,
+	 PAD_CTL_DRV_NORMAL | PAD_CTL_DRV_3_3V |
+	 PAD_CTL_HYS_SCHMITZ | PAD_CTL_100K_PU |
+	 PAD_CTL_PUE_KEEPER | PAD_CTL_ODE_CMOS | PAD_CTL_PKE_ENABLE,
+	 },
+};
+
+static int __initdata enable_sim = { 0 };
+static int __init sim_setup(char *__unused)
+{
+	enable_sim = 1;
+	return 1;
+}
+
+__setup("sim", sim_setup);
+
+/*!
+ * This system-wide GPIO function initializes the pins during system startup.
+ * All the statically linked device drivers should put the proper GPIO
+ * initialization code inside this function. It is called by
+ * \b fixup_mx25_3stack() during system startup. This function is board
+ * specific.
+ */
+void __init mx25_3stack_gpio_init(void)
+{
+	int i, num = 0;
+	struct mxc_iomux_pin_cfg *pin_ptr;
+
+	for (i = 0; i < ARRAY_SIZE(mxc_iomux_pins); i++) {
+		mxc_request_iomux(mxc_iomux_pins[i].pin,
+				  mxc_iomux_pins[i].mux_mode);
+		if (mxc_iomux_pins[i].pad_cfg)
+			mxc_iomux_set_pad(mxc_iomux_pins[i].pin,
+					  mxc_iomux_pins[i].pad_cfg);
+		if (mxc_iomux_pins[i].in_select)
+			mxc_iomux_set_input(mxc_iomux_pins[i].in_select,
+					    mxc_iomux_pins[i].in_mode);
+	}
+
+	if (enable_sim) {
+		pin_ptr = sim_iomux_pins;
+		num = ARRAY_SIZE(sim_iomux_pins);
+	}
+
+	for (i = 0; i < num; i++) {
+		mxc_request_iomux(pin_ptr[i].pin, pin_ptr[i].mux_mode);
+		if (pin_ptr[i].pad_cfg)
+			mxc_iomux_set_pad(pin_ptr[i].pin, pin_ptr[i].pad_cfg);
+		if (pin_ptr[i].in_select)
+			mxc_iomux_set_input(pin_ptr[i].in_select,
+					pin_ptr[i].in_mode);
+	}
+}
+
+/*!
+ * Activate a UART port
+ *
+ * @param  port         a UART port
+ * @param  no_irda      indicates if the port is used for SIR
+ */
+void gpio_uart_active(int port, int no_irda)
+{
+	/*
+	 * Configure the IOMUX control registers for the UART signals
+	 */
+	switch (port) {
+	case 0:
+		/* UART 1 IOMUX Configs */
+		mxc_request_iomux(MX25_PIN_UART1_RXD, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_UART1_TXD, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_UART1_RTS, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_UART1_CTS, MUX_CONFIG_FUNC);
+		mxc_iomux_set_pad(MX25_PIN_UART1_RXD,
+				  PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE |
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PU);
+		mxc_iomux_set_pad(MX25_PIN_UART1_TXD,
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PD);
+		mxc_iomux_set_pad(MX25_PIN_UART1_RTS,
+				  PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE |
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PU);
+		mxc_iomux_set_pad(MX25_PIN_UART1_CTS,
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PD);
+
+		break;
+	case 1:
+		/* UART 2 IOMUX Configs */
+		mxc_request_iomux(MX25_PIN_UART2_RXD, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_UART2_TXD, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_UART2_RTS, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_UART2_CTS, MUX_CONFIG_FUNC);
+		mxc_iomux_set_pad(MX25_PIN_UART2_RXD,
+				  PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE |
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PU);
+		mxc_iomux_set_pad(MX25_PIN_UART2_TXD, PAD_CTL_PKE_ENABLE |
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PD);
+		mxc_iomux_set_pad(MX25_PIN_UART2_RTS,
+				  PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE |
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PU);
+		mxc_iomux_set_pad(MX25_PIN_UART2_CTS, PAD_CTL_PKE_ENABLE |
+				  PAD_CTL_PUE_PUD | PAD_CTL_100K_PD);
+		break;
+	case 2:
+		/* UART 3 IOMUX Configs */
+		mxc_request_iomux(MX25_PIN_KPP_ROW0, MUX_CONFIG_ALT1); /*RXD*/
+		mxc_request_iomux(MX25_PIN_KPP_ROW1, MUX_CONFIG_ALT1); /*TXD*/
+		mxc_request_iomux(MX25_PIN_KPP_ROW2, MUX_CONFIG_ALT1); /*RTS*/
+		mxc_request_iomux(MX25_PIN_KPP_ROW3, MUX_CONFIG_ALT1); /*CTS*/
+
+		mxc_iomux_set_input(MUX_IN_UART3_IPP_UART_RTS_B,
+				    INPUT_CTL_PATH1);
+		mxc_iomux_set_input(MUX_IN_UART3_IPP_UART_RXD_MUX,
+				    INPUT_CTL_PATH1);
+		break;
+	case 3:
+		/* UART 4 IOMUX Configs */
+		mxc_request_iomux(MX25_PIN_LD8, MUX_CONFIG_ALT2); /*RXD*/
+		mxc_request_iomux(MX25_PIN_LD9, MUX_CONFIG_ALT2); /*TXD*/
+		mxc_request_iomux(MX25_PIN_LD10, MUX_CONFIG_ALT2); /*RTS*/
+		mxc_request_iomux(MX25_PIN_LD11, MUX_CONFIG_ALT2); /*CTS*/
+
+		mxc_iomux_set_input(MUX_IN_UART4_IPP_UART_RTS_B,
+				    INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_UART4_IPP_UART_RXD_MUX,
+				    INPUT_CTL_PATH0);
+		break;
+	case 4:
+		/* UART 5 IOMUX Configs */
+		mxc_request_iomux(MX25_PIN_CSI_D2, MUX_CONFIG_ALT1); /*RXD*/
+		mxc_request_iomux(MX25_PIN_CSI_D3, MUX_CONFIG_ALT1); /*TXD*/
+		mxc_request_iomux(MX25_PIN_CSI_D4, MUX_CONFIG_ALT1); /*RTS*/
+		mxc_request_iomux(MX25_PIN_CSI_D5, MUX_CONFIG_ALT1); /*CTS*/
+
+		mxc_iomux_set_input(MUX_IN_UART5_IPP_UART_RTS_B,
+				    INPUT_CTL_PATH1);
+		mxc_iomux_set_input(MUX_IN_UART5_IPP_UART_RXD_MUX,
+				    INPUT_CTL_PATH1);
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(gpio_uart_active);
+
+/*!
+ * Inactivate a UART port
+ *
+ * @param  port         a UART port
+ * @param  no_irda      indicates if the port is used for SIR
+ */
+void gpio_uart_inactive(int port, int no_irda)
+{
+	switch (port) {
+	case 0:
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_UART1_RXD), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_UART1_TXD), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_UART1_RTS), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_UART1_CTS), NULL);
+
+		mxc_free_iomux(MX25_PIN_UART1_RXD, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_UART1_TXD, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_UART1_RTS, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_UART1_CTS, MUX_CONFIG_GPIO);
+		break;
+	case 1:
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_UART2_RXD), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_UART2_TXD), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_UART2_RTS), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_UART2_CTS), NULL);
+
+		mxc_free_iomux(MX25_PIN_UART2_RXD, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_UART2_TXD, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_UART2_RTS, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_UART2_CTS, MUX_CONFIG_GPIO);
+		break;
+	case 2:
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_KPP_ROW0), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_KPP_ROW1), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_KPP_ROW2), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_KPP_ROW3), NULL);
+
+		mxc_free_iomux(MX25_PIN_KPP_ROW0, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_KPP_ROW1, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_KPP_ROW2, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_KPP_ROW3, MUX_CONFIG_GPIO);
+		break;
+	case 3:
+		mxc_free_iomux(MX25_PIN_LD8, MUX_CONFIG_FUNC);
+		mxc_free_iomux(MX25_PIN_LD9, MUX_CONFIG_FUNC);
+		mxc_free_iomux(MX25_PIN_LD10, MUX_CONFIG_FUNC);
+		mxc_free_iomux(MX25_PIN_LD11, MUX_CONFIG_FUNC);
+		break;
+	case 4:
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_D2), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_D3), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_D4), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_D5), NULL);
+
+		mxc_free_iomux(MX25_PIN_CSI_D2, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSI_D3, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSI_D4, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSI_D5, MUX_CONFIG_GPIO);
+		break;
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(gpio_uart_inactive);
+
+/*!
+ * Configure the IOMUX GPR register to receive shared SDMA UART events
+ *
+ * @param  port         a UART port
+ */
+void config_uartdma_event(int port)
+{
+}
+EXPORT_SYMBOL(config_uartdma_event);
+
+/*!
+ * Activate Keypad
+ */
+void gpio_keypad_active(void)
+{
+	mxc_request_iomux(MX25_PIN_KPP_ROW0, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_KPP_ROW1, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_KPP_ROW2, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_KPP_ROW3, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_KPP_COL0, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_KPP_COL1, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_KPP_COL2, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_KPP_COL3, MUX_CONFIG_FUNC);
+
+#define KPP_PAD_CTL_ROW (PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PUD | \
+			 PAD_CTL_100K_PU)
+#define KPP_PAD_CTL_COL (PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PUD | \
+			 PAD_CTL_100K_PU | PAD_CTL_ODE_OpenDrain)
+
+	mxc_iomux_set_pad(MX25_PIN_KPP_ROW0, KPP_PAD_CTL_ROW);
+	mxc_iomux_set_pad(MX25_PIN_KPP_ROW1, KPP_PAD_CTL_ROW);
+	mxc_iomux_set_pad(MX25_PIN_KPP_ROW2, KPP_PAD_CTL_ROW);
+	mxc_iomux_set_pad(MX25_PIN_KPP_ROW3, KPP_PAD_CTL_ROW);
+	mxc_iomux_set_pad(MX25_PIN_KPP_COL0, KPP_PAD_CTL_COL);
+	mxc_iomux_set_pad(MX25_PIN_KPP_COL1, KPP_PAD_CTL_COL);
+	mxc_iomux_set_pad(MX25_PIN_KPP_COL2, KPP_PAD_CTL_COL);
+	mxc_iomux_set_pad(MX25_PIN_KPP_COL3, KPP_PAD_CTL_COL);
+
+#undef KPP_PAD_CTL_ROW
+#undef KPP_PAD_CTL_COL
+}
+EXPORT_SYMBOL(gpio_keypad_active);
+
+/*!
+ * Inactivate Keypad
+ */
+void gpio_keypad_inactive(void)
+{
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_KPP_ROW0), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_KPP_ROW1), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_KPP_ROW2), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_KPP_ROW3), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_KPP_COL0), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_KPP_COL1), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_KPP_COL2), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_KPP_COL3), NULL);
+
+	mxc_free_iomux(MX25_PIN_KPP_ROW0, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_KPP_ROW1, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_KPP_ROW2, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_KPP_ROW3, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_KPP_COL0, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_KPP_COL1, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_KPP_COL2, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_KPP_COL3, MUX_CONFIG_GPIO);
+}
+EXPORT_SYMBOL(gpio_keypad_inactive);
+
+/*!
+ * Activate FEC
+ */
+void gpio_fec_active(void)
+{
+	mxc_request_iomux(MX25_PIN_FEC_TX_CLK, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_FEC_RX_DV, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_FEC_RDATA0, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_FEC_TDATA0, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_FEC_TX_EN, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_FEC_MDC, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_FEC_MDIO, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_FEC_RDATA1, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_FEC_TDATA1, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_POWER_FAIL, MUX_CONFIG_FUNC); /* PHY INT */
+
+#define FEC_PAD_CTL1 (PAD_CTL_HYS_SCHMITZ | PAD_CTL_PUE_PUD | \
+		      PAD_CTL_PKE_ENABLE)
+#define FEC_PAD_CTL2 (PAD_CTL_PUE_PUD)
+
+	mxc_iomux_set_pad(MX25_PIN_FEC_TX_CLK, FEC_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_FEC_RX_DV, FEC_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_FEC_RDATA0, FEC_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_FEC_TDATA0, FEC_PAD_CTL2);
+	mxc_iomux_set_pad(MX25_PIN_FEC_TX_EN, FEC_PAD_CTL2);
+	mxc_iomux_set_pad(MX25_PIN_FEC_MDC, FEC_PAD_CTL2);
+	mxc_iomux_set_pad(MX25_PIN_FEC_MDIO, FEC_PAD_CTL1 | PAD_CTL_22K_PU);
+	mxc_iomux_set_pad(MX25_PIN_FEC_RDATA1, FEC_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_FEC_TDATA1, FEC_PAD_CTL2);
+	mxc_iomux_set_pad(MX25_PIN_POWER_FAIL, FEC_PAD_CTL1);
+
+	/*
+	 * Set up the FEC_RESET_B and FEC_ENABLE GPIO pins.
+	 * Assert FEC_RESET_B, then power up the PHY by asserting
+	 * FEC_ENABLE, at the same time lifting FEC_RESET_B.
+	 *
+	 * FEC_RESET_B: gpio2[3] is ALT 5 mode of pin D12
+	 * FEC_ENABLE_B: gpio4[8] is ALT 5 mode of pin A17
+	 */
+	mxc_request_iomux(MX25_PIN_A17, MUX_CONFIG_ALT5); /* FEC_EN */
+	mxc_request_iomux(MX25_PIN_D12, MUX_CONFIG_ALT5); /* FEC_RESET_B */
+
+	mxc_iomux_set_pad(MX25_PIN_A17, PAD_CTL_ODE_OpenDrain);
+	mxc_iomux_set_pad(MX25_PIN_D12, 0);
+
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_A17), "a17");
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_D12), "d12");
+
+	gpio_direction_output(IOMUX_TO_GPIO(MX25_PIN_A17), 0); /* FEC_EN */
+	gpio_direction_output(IOMUX_TO_GPIO(MX25_PIN_D12), 0); /* FEC_RESET_B */
+
+	/* drop PHY power */
+	gpio_set_value(IOMUX_TO_GPIO(MX25_PIN_A17), 0);	/* FEC_EN */
+
+	/* assert reset */
+	gpio_set_value(IOMUX_TO_GPIO(MX25_PIN_D12), 0);	/* FEC_RESET_B */
+	udelay(2);		/* spec says 1us min */
+
+	/* turn on PHY power and lift reset */
+	gpio_set_value(IOMUX_TO_GPIO(MX25_PIN_A17), 1);	/* FEC_EN */
+	gpio_set_value(IOMUX_TO_GPIO(MX25_PIN_D12), 1);	/* FEC_RESET_B */
+
+#undef FEC_PAD_CTL_COMMON
+#undef FEC_PAD_CTL1
+#undef FEC_PAD_CTL2
+}
+EXPORT_SYMBOL(gpio_fec_active);
+
+/*!
+ * Inactivate FEC
+ */
+void gpio_fec_inactive(void)
+{
+	/*
+	 * Turn off the PHY.
+	 */
+	gpio_set_value(IOMUX_TO_GPIO(MX25_PIN_A17), 0);
+
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_FEC_TX_CLK), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_FEC_RX_DV), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_FEC_RDATA0), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_FEC_TDATA0), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_FEC_TX_EN), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_FEC_MDC), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_FEC_MDIO), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_FEC_RDATA1), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_FEC_TDATA1), NULL);
+
+	mxc_free_iomux(MX25_PIN_FEC_TX_CLK, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_FEC_RX_DV, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_FEC_RDATA0, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_FEC_TDATA0, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_FEC_TX_EN, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_FEC_MDC, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_FEC_MDIO, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_FEC_RDATA1, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_FEC_TDATA1, MUX_CONFIG_GPIO);
+	mxc_request_iomux(MX25_PIN_POWER_FAIL, MUX_CONFIG_FUNC); /* PHY INT */
+
+	mxc_free_iomux(MX25_PIN_A17, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_D12, MUX_CONFIG_GPIO); /* FEC_RESET_B */
+
+	/* We keep pin A17, so FEC_ENABLE doesn't float */
+}
+EXPORT_SYMBOL(gpio_fec_inactive);
+
+/*!
+ * Activate an I2C device
+ *
+ * @param  i2c_num         an I2C device
+ */
+void gpio_i2c_active(int i2c_num)
+{
+#define I2C_PAD_CTL (PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE | \
+		     PAD_CTL_PUE_PUD | PAD_CTL_100K_PU | PAD_CTL_ODE_OpenDrain)
+
+	switch (i2c_num) {
+	case 0:
+		/*I2C1*/
+		mxc_request_iomux(MX25_PIN_I2C1_CLK, MUX_CONFIG_SION);
+		mxc_request_iomux(MX25_PIN_I2C1_DAT, MUX_CONFIG_SION);
+		mxc_iomux_set_pad(MX25_PIN_I2C1_CLK, I2C_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_I2C1_DAT, I2C_PAD_CTL);
+		break;
+	case 1:
+		/*I2C2*/
+		mxc_request_iomux(MX25_PIN_GPIO_C, MUX_CONFIG_ALT2); /*SCL*/
+		mxc_request_iomux(MX25_PIN_GPIO_D, MUX_CONFIG_ALT2); /*SDA*/
+		mxc_iomux_set_pad(MX25_PIN_GPIO_C, I2C_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_GPIO_D, I2C_PAD_CTL);
+		mxc_iomux_set_input(MUX_IN_I2C2_IPP_SCL_IN, INPUT_CTL_PATH1);
+		mxc_iomux_set_input(MUX_IN_I2C2_IPP_SDA_IN, INPUT_CTL_PATH1);
+		break;
+	case 2:
+		/*I2C3*/
+		mxc_request_iomux(MX25_PIN_HSYNC, MUX_CONFIG_ALT2); /*SCL*/
+		mxc_request_iomux(MX25_PIN_VSYNC, MUX_CONFIG_ALT2); /*SDA*/
+		mxc_iomux_set_pad(MX25_PIN_HSYNC, I2C_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_VSYNC, I2C_PAD_CTL);
+		mxc_iomux_set_input(MUX_IN_I2C3_IPP_SCL_IN, INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_I2C3_IPP_SDA_IN, INPUT_CTL_PATH0);
+		break;
+	default:
+		break;
+	}
+#undef I2C_PAD_CTL
+}
+EXPORT_SYMBOL(gpio_i2c_active);
+
+/*!
+ * Inactivate an I2C device
+ *
+ * @param  i2c_num         an I2C device
+ */
+void gpio_i2c_inactive(int i2c_num)
+{
+	switch (i2c_num) {
+	case 0:
+		/*I2C1*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_I2C1_CLK), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_I2C1_DAT), NULL);
+		mxc_free_iomux(MX25_PIN_I2C1_CLK, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_I2C1_DAT, MUX_CONFIG_GPIO);
+		break;
+	case 1:
+		/*I2C2*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_GPIO_C), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_GPIO_D), NULL);
+		mxc_free_iomux(MX25_PIN_GPIO_C, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_GPIO_D, MUX_CONFIG_GPIO);
+		break;
+	case 2:
+		/*I2C3*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_HSYNC), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_VSYNC), NULL);
+		mxc_free_iomux(MX25_PIN_HSYNC, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_VSYNC, MUX_CONFIG_GPIO);
+		break;
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(gpio_i2c_inactive);
+
+/*!
+ * Activate a CSPI device
+ *
+ * @param  cspi_mod         a CSPI device
+ */
+void gpio_spi_active(int cspi_mod)
+{
+#define SPI_PAD_CTL1 (PAD_CTL_HYS_SCHMITZ|PAD_CTL_PKE_ENABLE| \
+		      PAD_CTL_100K_PU)
+#define SPI_PAD_CTL2 (PAD_CTL_HYS_SCHMITZ|PAD_CTL_PKE_ENABLE| \
+		      PAD_CTL_PUE_PUD|PAD_CTL_100K_PU)
+
+	switch (cspi_mod) {
+	case 0:
+		/* SPI1 */
+		mxc_request_iomux(MX25_PIN_CSPI1_MOSI, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_CSPI1_MISO, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_CSPI1_SS0, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_CSPI1_SS1, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_CSPI1_SCLK, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_CSPI1_RDY, MUX_CONFIG_FUNC);
+#ifndef CONFIG_CAN_FLEXCAN	/* MX25 3-stack uses this pin for CAN2 */
+		mxc_request_iomux(MX25_PIN_GPIO_C, MUX_CONFIG_ALT5); /*SS2*/
+#endif
+		mxc_request_iomux(MX25_PIN_VSTBY_ACK, MUX_CONFIG_ALT2); /*SS3*/
+
+		/* Or if VSTBY_ACK is being used */
+		/*mxc_request_iomux(MX25_PIN_NF_CE0, MUX_CONFIG_ALT1);*/ /*SS3*/
+
+		mxc_iomux_set_pad(MX25_PIN_CSPI1_MOSI, SPI_PAD_CTL1);
+		mxc_iomux_set_pad(MX25_PIN_CSPI1_MISO, SPI_PAD_CTL1);
+		mxc_iomux_set_pad(MX25_PIN_CSPI1_SS0, SPI_PAD_CTL1);
+		mxc_iomux_set_pad(MX25_PIN_CSPI1_SS1, SPI_PAD_CTL1);
+		mxc_iomux_set_pad(MX25_PIN_CSPI1_SCLK, SPI_PAD_CTL1);
+		mxc_iomux_set_pad(MX25_PIN_CSPI1_RDY, SPI_PAD_CTL1);
+#ifndef CONFIG_CAN_FLEXCAN	/* MX25 3-stack uses this pin for CAN2 */
+		mxc_iomux_set_pad(MX25_PIN_GPIO_C, SPI_PAD_CTL2);
+#endif
+		mxc_iomux_set_pad(MX25_PIN_VSTBY_ACK, SPI_PAD_CTL1);
+
+		mxc_iomux_set_input(MUX_IN_CSPI1_IPP_IND_SS3_B,
+				    INPUT_CTL_PATH1);
+		break;
+	case 1:
+		/* SPI2 */
+		mxc_request_iomux(MX25_PIN_LD12, MUX_CONFIG_ALT2); /*MOSI*/
+		mxc_request_iomux(MX25_PIN_LD13, MUX_CONFIG_ALT2); /*MISO*/
+		mxc_request_iomux(MX25_PIN_LD14, MUX_CONFIG_ALT2); /*SCLK*/
+		mxc_request_iomux(MX25_PIN_LD15, MUX_CONFIG_ALT2); /*RDY*/
+		mxc_request_iomux(MX25_PIN_OE_ACD, MUX_CONFIG_ALT2); /*SS0*/
+		mxc_request_iomux(MX25_PIN_CONTRAST, MUX_CONFIG_ALT2); /*SS1*/
+		mxc_request_iomux(MX25_PIN_GPIO_C, MUX_CONFIG_ALT7); /*SS2*/
+		mxc_request_iomux(MX25_PIN_UART2_RTS, MUX_CONFIG_ALT6); /*SS3*/
+
+		mxc_iomux_set_pad(MX25_PIN_LD12, SPI_PAD_CTL2);
+		mxc_iomux_set_pad(MX25_PIN_LD13, SPI_PAD_CTL2);
+		mxc_iomux_set_pad(MX25_PIN_LD14, SPI_PAD_CTL2);
+		mxc_iomux_set_pad(MX25_PIN_LD15, SPI_PAD_CTL2);
+		mxc_iomux_set_pad(MX25_PIN_OE_ACD, SPI_PAD_CTL2);
+		mxc_iomux_set_pad(MX25_PIN_CONTRAST, SPI_PAD_CTL2);
+		mxc_iomux_set_pad(MX25_PIN_GPIO_C, SPI_PAD_CTL2);
+		mxc_iomux_set_pad(MX25_PIN_UART2_RTS, SPI_PAD_CTL2);
+
+		mxc_iomux_set_input(MUX_IN_CSPI2_IPP_CSPI_CLK_IN,
+				    INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_CSPI2_IPP_IND_DATAREADY_B,
+				    INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_CSPI2_IPP_IND_MISO, INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_CSPI2_IPP_IND_MOSI, INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_CSPI2_IPP_IND_SS0_B,
+				    INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_CSPI2_IPP_IND_SS1_B,
+				    INPUT_CTL_PATH0);
+		break;
+	case 2:
+		/* SPI3 */
+		mxc_request_iomux(MX25_PIN_EB0, MUX_CONFIG_ALT6); /*SS0*/
+		mxc_request_iomux(MX25_PIN_EB1, MUX_CONFIG_ALT6); /*SS1*/
+		mxc_request_iomux(MX25_PIN_CS4, MUX_CONFIG_ALT6); /*MOSI*/
+		mxc_request_iomux(MX25_PIN_CS5, MUX_CONFIG_ALT6); /*MISO*/
+		mxc_request_iomux(MX25_PIN_ECB, MUX_CONFIG_ALT6); /*SCLK*/
+		mxc_request_iomux(MX25_PIN_LBA, MUX_CONFIG_ALT6); /*RDY*/
+		mxc_request_iomux(MX25_PIN_GPIO_D, MUX_CONFIG_ALT7); /*SS2*/
+		mxc_request_iomux(MX25_PIN_CSI_D9, MUX_CONFIG_ALT7); /*SS3*/
+
+		mxc_iomux_set_pad(MX25_PIN_EB0, SPI_PAD_CTL1);
+		mxc_iomux_set_pad(MX25_PIN_EB1, SPI_PAD_CTL1);
+		mxc_iomux_set_pad(MX25_PIN_CS4, SPI_PAD_CTL1);
+		mxc_iomux_set_pad(MX25_PIN_CS5, SPI_PAD_CTL1);
+		mxc_iomux_set_pad(MX25_PIN_ECB, SPI_PAD_CTL1);
+		mxc_iomux_set_pad(MX25_PIN_LBA, SPI_PAD_CTL1);
+
+		mxc_iomux_set_input(MUX_IN_CSPI3_IPP_CSPI_CLK_IN,
+				    INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_CSPI3_IPP_IND_DATAREADY_B,
+				    INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_CSPI3_IPP_IND_MISO, INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_CSPI3_IPP_IND_MOSI, INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_CSPI3_IPP_IND_SS0_B,
+				    INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_CSPI3_IPP_IND_SS1_B,
+				    INPUT_CTL_PATH0);
+		mxc_iomux_set_input(MUX_IN_CSPI3_IPP_IND_SS2_B,
+				    INPUT_CTL_PATH1);
+		mxc_iomux_set_input(MUX_IN_CSPI3_IPP_IND_SS3_B,
+				    INPUT_CTL_PATH0);
+		break;
+	default:
+		break;
+	}
+#undef SPI_PAD_CTL1
+#undef SPI_PAD_CTL2
+}
+EXPORT_SYMBOL(gpio_spi_active);
+
+/*!
+ * Inactivate a CSPI device
+ *
+ * @param  cspi_mod         a CSPI device
+ */
+void gpio_spi_inactive(int cspi_mod)
+{
+	switch (cspi_mod) {
+	case 0:
+		/* SPI1 */
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSPI1_MOSI), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSPI1_MISO), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSPI1_SS0), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSPI1_SS1), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSPI1_SCLK), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSPI1_RDY), NULL);
+#ifndef CONFIG_CAN_FLEXCAN	/* MX25 3-stack uses this pin for CAN2 */
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_GPIO_C), NULL); /*SS2*/
+#endif
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_VSTBY_ACK), NULL); /*SS3*/
+
+		mxc_free_iomux(MX25_PIN_CSPI1_MOSI, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSPI1_MISO, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSPI1_SS0, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSPI1_SS1, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSPI1_SCLK, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSPI1_RDY, MUX_CONFIG_GPIO);
+#ifndef CONFIG_CAN_FLEXCAN	/* MX25 3-stack uses this pin for CAN2 */
+		mxc_free_iomux(MX25_PIN_GPIO_C, MUX_CONFIG_GPIO);
+#endif
+		mxc_free_iomux(MX25_PIN_VSTBY_ACK, MUX_CONFIG_GPIO);
+		break;
+	case 1:
+		/* SPI2 */
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_LD12), NULL); /*MOSI*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_LD13), NULL); /*MISO*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_LD14), NULL); /*SCLK*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_LD15), NULL); /*RDY*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_OE_ACD), NULL); /*SS0*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_CONTRAST), NULL); /*SS1*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_GPIO_C), NULL); /*SS2*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_UART2_RTS), NULL); /*SS3*/
+
+		mxc_free_iomux(MX25_PIN_LD12, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_LD13, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_LD14, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_LD15, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_OE_ACD, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CONTRAST, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_GPIO_C, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_UART2_RTS, MUX_CONFIG_GPIO);
+		break;
+	case 2:
+		/* SPI3 */
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_EB0), NULL); /*SS0*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_EB1), NULL); /*SS1*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_CS4), NULL); /*MOSI*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_CS5), NULL); /*MISO*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_ECB), NULL); /*SCLK*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_LBA), NULL); /*RDY*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_GPIO_D), NULL); /*SS2*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_D9), NULL); /*SS3*/
+
+		mxc_free_iomux(MX25_PIN_EB0, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_EB1, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CS4, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CS5, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_ECB, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_LBA, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_GPIO_D, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSI_D9, MUX_CONFIG_GPIO);
+		break;
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(gpio_spi_inactive);
+
+/*!
+ * Activate LCD
+ */
+void gpio_lcdc_active(void)
+{
+	mxc_request_iomux(MX25_PIN_LD0, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD1, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD2, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD3, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD4, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD5, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD6, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD7, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD8, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD9, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD10, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD11, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD12, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD13, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD14, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LD15, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_GPIO_E, MUX_CONFIG_ALT2); /*D16*/
+	mxc_request_iomux(MX25_PIN_GPIO_F, MUX_CONFIG_ALT2); /*D17*/
+	mxc_request_iomux(MX25_PIN_HSYNC, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_VSYNC, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_LSCLK, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_OE_ACD, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_CONTRAST, MUX_CONFIG_FUNC);
+
+#define LCD_PAD_CTL (PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PUD | PAD_CTL_100K_PU)
+	mxc_iomux_set_pad(MX25_PIN_LD0, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD1, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD2, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD3, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD4, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD5, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD6, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD7, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD8, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD9, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD10, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD11, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD12, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD13, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD14, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LD15, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_GPIO_E, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_GPIO_F, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_HSYNC, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_VSYNC, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_LSCLK, LCD_PAD_CTL | PAD_CTL_SRE_FAST);
+	mxc_iomux_set_pad(MX25_PIN_OE_ACD, LCD_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_CONTRAST, LCD_PAD_CTL);
+}
+EXPORT_SYMBOL(gpio_lcdc_active);
+
+/*!
+ * Inactivate LCD
+ */
+void gpio_lcdc_inactive(void)
+{
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_LD0), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_LD1), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_LD2), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_LD3), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_LD4), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_LD5), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_LD6), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_LD7), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_GPIO_E), NULL); /*D16*/
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_GPIO_F), NULL); /*D17*/
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_HSYNC), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_VSYNC), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_LSCLK), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_OE_ACD), NULL);
+
+	mxc_free_iomux(MX25_PIN_LD0, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD1, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD2, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD3, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD4, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD5, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD6, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD7, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LD8, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_LD9, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_LD10, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_LD11, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_LD12, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_LD13, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_LD14, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_LD15, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_GPIO_E, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_GPIO_F, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_HSYNC, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_VSYNC, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_LSCLK, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_OE_ACD, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CONTRAST, MUX_CONFIG_FUNC);
+}
+EXPORT_SYMBOL(gpio_lcdc_inactive);
+
+/*!
+ * Activate SDHC
+ *
+ * @param module SDHC module number
+ */
+void gpio_sdhc_active(int module)
+{
+#define SDHC_PAD_CTL (PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PUD | \
+		      PAD_CTL_47K_PU | PAD_CTL_SRE_FAST)
+
+	switch (module) {
+	case 0:
+		/* SDHC1 */
+		mxc_request_iomux(MX25_PIN_SD1_CMD,
+				  MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+		mxc_request_iomux(MX25_PIN_SD1_CLK,
+				  MUX_CONFIG_FUNC | MUX_CONFIG_SION);
+		mxc_request_iomux(MX25_PIN_SD1_DATA0, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_SD1_DATA1, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_SD1_DATA2, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_SD1_DATA3, MUX_CONFIG_FUNC);
+		mxc_request_iomux(MX25_PIN_A14, MUX_CONFIG_ALT5); /*SD1_WP*/
+		mxc_request_iomux(MX25_PIN_A15, MUX_CONFIG_ALT5); /*SD1_DET*/
+
+		mxc_iomux_set_pad(MX25_PIN_SD1_CMD, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_SD1_CLK, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_SD1_DATA0, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_SD1_DATA1, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_SD1_DATA2, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_SD1_DATA3, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_A14, PAD_CTL_DRV_NORMAL);
+		mxc_iomux_set_pad(MX25_PIN_A15, PAD_CTL_DRV_NORMAL);
+
+		/* Set write protect and card detect gpio as inputs */
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_A14), "a14");
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_A15), "a15");
+		gpio_direction_input(IOMUX_TO_GPIO(MX25_PIN_A14)); /*SD1_WP*/
+		gpio_direction_input(IOMUX_TO_GPIO(MX25_PIN_A15)); /*SD1_DET*/
+
+		break;
+	case 1:
+		/* SDHC2 */
+		mxc_request_iomux(MX25_PIN_LD8,
+				  MUX_CONFIG_ALT6 | MUX_CONFIG_SION); /*CMD*/
+		mxc_request_iomux(MX25_PIN_LD9,
+				  MUX_CONFIG_ALT6 | MUX_CONFIG_SION); /*CLK*/
+		mxc_request_iomux(MX25_PIN_LD10, MUX_CONFIG_ALT6); /*DAT0*/
+		mxc_request_iomux(MX25_PIN_LD11, MUX_CONFIG_ALT6); /*DAT1*/
+		mxc_request_iomux(MX25_PIN_LD12, MUX_CONFIG_ALT6); /*DAT2*/
+		mxc_request_iomux(MX25_PIN_LD13, MUX_CONFIG_ALT6); /*DAT3*/
+
+		mxc_iomux_set_pad(MX25_PIN_LD8, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_LD9, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_LD10, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_LD11, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_LD12, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_LD13, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_CSI_D2, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_CSI_D3, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_CSI_D4, SDHC_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_CSI_D5, SDHC_PAD_CTL);
+		break;
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(gpio_sdhc_active);
+
+/*!
+ * Inactivate SDHC
+ *
+ * @param module SDHC module number
+ */
+void gpio_sdhc_inactive(int module)
+{
+	switch (module) {
+	case 0:
+		/* SDHC1 */
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_SD1_CMD), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_SD1_CLK), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_SD1_DATA0), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_SD1_DATA1), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_SD1_DATA2), NULL);
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_SD1_DATA3), NULL);
+
+		mxc_free_iomux(MX25_PIN_SD1_CMD, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_SD1_CLK, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_SD1_DATA0, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_SD1_DATA1, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_SD1_DATA2, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_SD1_DATA3, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_A14, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_A15, MUX_CONFIG_GPIO);
+		break;
+	case 1:
+		/* SDHC2 */
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_LD8), NULL); /*CMD*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_LD9), NULL); /*CLK*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_LD10), NULL); /*DAT0*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_LD11), NULL); /*DAT1*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_LD12), NULL); /*DAT2*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_LD13), NULL); /*DAT3*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_D2), NULL); /*DAT4*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_D3), NULL); /*DAT5*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_D4), NULL); /*DAT6*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_D5), NULL); /*DAT7*/
+
+		mxc_free_iomux(MX25_PIN_LD8, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_LD9, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_LD10, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_LD11, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_LD12, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_LD13, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSI_D2, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSI_D3, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSI_D4, MUX_CONFIG_GPIO);
+		mxc_free_iomux(MX25_PIN_CSI_D5, MUX_CONFIG_GPIO);
+		break;
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(gpio_sdhc_inactive);
+
+/*
+ * Probe for the card. If present the GPIO data would be set.
+ */
+unsigned int sdhc_get_card_det_status(struct device *dev)
+{
+	unsigned int ret = 0;
+
+	ret = gpio_get_value(IOMUX_TO_GPIO(MX25_PIN_A15));
+	return ret;
+}
+EXPORT_SYMBOL(sdhc_get_card_det_status);
+
+/*!
+ * Get pin value to detect write protection
+ */
+int sdhc_write_protect(struct device *dev)
+{
+	unsigned int rc = 0;
+
+	rc = gpio_get_value(IOMUX_TO_GPIO(MX25_PIN_A14));
+	return rc;
+}
+EXPORT_SYMBOL(sdhc_write_protect);
+
+/*
+ *  USB Host2
+ *
+ *  This configuration uses the on-chip FS/LS serial transceiver.
+ *  USBPHY2_{DP,DM} pins are not muxed.
+ *  We just need to grab USBH2_PWR, USBH2_OC and the Bluetooth/USB
+ *  mux control signal.
+ */
+int gpio_usbh2_active(void)
+{
+	mxc_request_iomux(MX25_PIN_D9, MUX_CONFIG_ALT6);
+	mxc_request_iomux(MX25_PIN_D8, MUX_CONFIG_ALT6);
+	mxc_request_iomux(MX25_PIN_A21, MUX_CONFIG_ALT5);
+
+	mxc_iomux_set_pad(MX25_PIN_D9, PAD_CTL_100K_PU);
+	/*
+	 * This pin controls the mux that switches between
+	 * the J18 connector and the on-board bluetooth module.
+	 *  dir: 0 = out
+	 *  pin: 0 = J18, 1 = BT
+	 */
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_D9), "D9");
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_A21), "A21");
+
+	gpio_direction_output(IOMUX_TO_GPIO(MX25_PIN_D9), 1);
+	gpio_direction_output(IOMUX_TO_GPIO(MX25_PIN_A21), 0);
+
+	mxc_iomux_set_input(MUX_IN_USB_TOP_IPP_IND_UH2_USB_OC, INPUT_CTL_PATH1);
+	gpio_set_value(IOMUX_TO_GPIO(MX25_PIN_A21), 0);
+
+	return 0;
+}
+EXPORT_SYMBOL(gpio_usbh2_active);
+
+void gpio_usbh2_inactive(void)
+{
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_D9), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_D8), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_A21), NULL);
+
+	mxc_free_iomux(MX25_PIN_D9, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_D8, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_A21, MUX_CONFIG_GPIO);
+}
+
+/*
+ *  USB OTG UTMI
+ *
+ *  This configuration uses the on-chip UTMI transceiver.
+ *  USBPHY1_{VBUS,DP,DM,UID,RREF} pins are not muxed.
+ *  We just need to grab the USBOTG_PWR and USBOTG_OC pins.
+ */
+int gpio_usbotg_utmi_active(void)
+{
+	if (mxc_request_iomux(MX25_PIN_GPIO_A, MUX_CONFIG_ALT2)  || /* PWR */
+	    mxc_request_iomux(MX25_PIN_GPIO_B, MUX_CONFIG_ALT2)) {  /* OC */
+		return -EINVAL;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(gpio_usbotg_utmi_active);
+
+void gpio_usbotg_utmi_inactive(void)
+{
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_GPIO_A), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_GPIO_B), NULL);
+
+	mxc_free_iomux(MX25_PIN_GPIO_A, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_GPIO_B, MUX_CONFIG_GPIO);
+}
+EXPORT_SYMBOL(gpio_usbotg_utmi_inactive);
+
+/*!
+ * Activate camera sensor
+ */
+void gpio_sensor_active(unsigned int csi)
+{
+	mxc_request_iomux(MX25_PIN_CSI_D2, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_CSI_D3, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_CSI_D4, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_CSI_D5, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_CSI_D6, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_CSI_D7, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_CSI_D8, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_CSI_D9, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_CSI_HSYNC, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_CSI_MCLK, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_CSI_PIXCLK, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_CSI_VSYNC, MUX_CONFIG_FUNC);
+	mxc_request_iomux(MX25_PIN_A19, MUX_CONFIG_ALT5); /*CSI_PWDN*/
+	mxc_request_iomux(MX25_PIN_A20, MUX_CONFIG_ALT5); /*CMOS_RST*/
+
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_A19), "a19");
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_A20), "a20");
+	gpio_direction_output(IOMUX_TO_GPIO(MX25_PIN_A19), 0); /*CSI_PWDN*/
+	gpio_set_value(IOMUX_TO_GPIO(MX25_PIN_A19), 0);
+	gpio_direction_output(IOMUX_TO_GPIO(MX25_PIN_A20), 0); /*CMOS_RST*/
+	gpio_set_value(IOMUX_TO_GPIO(MX25_PIN_A20), 0);
+	mdelay(20);
+	gpio_set_value(IOMUX_TO_GPIO(MX25_PIN_A20), 1);
+
+#define CSI_PAD_CTL1 (PAD_CTL_PKE_ENABLE | PAD_CTL_100K_PU)
+#define CSI_PAD_CTL2 (PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE | \
+		      PAD_CTL_100K_PU)
+
+	mxc_iomux_set_pad(MX25_PIN_CSI_D2, CSI_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D3, CSI_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D4, CSI_PAD_CTL2);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D5, CSI_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D6, CSI_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D7, CSI_PAD_CTL2);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D8, CSI_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D9, CSI_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_CSI_HSYNC, CSI_PAD_CTL1);
+	mxc_iomux_set_pad(MX25_PIN_CSI_MCLK, PAD_CTL_PKE_ENABLE |
+			  PAD_CTL_PUE_PUD | PAD_CTL_100K_PU | PAD_CTL_SRE_FAST);
+	mxc_iomux_set_pad(MX25_PIN_CSI_PIXCLK, CSI_PAD_CTL2);
+	mxc_iomux_set_pad(MX25_PIN_CSI_VSYNC, CSI_PAD_CTL1);
+}
+EXPORT_SYMBOL(gpio_sensor_active);
+
+/*!
+ * Inactivate camera sensor
+ */
+void gpio_sensor_inactive(unsigned int csi)
+{
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_D2), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_D3), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_D4), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_D5), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_D6), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_D7), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_D8), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_D9), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_HSYNC), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_MCLK), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_PIXCLK), NULL);
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_CSI_VSYNC), NULL);
+
+	mxc_free_iomux(MX25_PIN_A19, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_A20, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_D2, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_D3, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_D4, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_D5, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_D6, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_D7, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_D8, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_D9, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_HSYNC, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_MCLK, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_PIXCLK, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_CSI_VSYNC, MUX_CONFIG_GPIO);
+}
+EXPORT_SYMBOL(gpio_sensor_inactive);
+
+/*!
+ * Activate ESAI ports to enable surround sound I/O
+ */
+void gpio_activate_esai_ports(void)
+{
+	mxc_request_iomux(MX25_PIN_CSI_D2, MUX_CONFIG_ALT3); /*SCKR*/
+	mxc_request_iomux(MX25_PIN_CSI_D3, MUX_CONFIG_ALT3); /*FSR*/
+	mxc_request_iomux(MX25_PIN_CSI_D4, MUX_CONFIG_ALT3); /*HCKR*/
+	mxc_request_iomux(MX25_PIN_CSI_D5, MUX_CONFIG_ALT3); /*SCKT*/
+	mxc_request_iomux(MX25_PIN_CSI_D6, MUX_CONFIG_ALT3); /*FST*/
+	mxc_request_iomux(MX25_PIN_CSI_D7, MUX_CONFIG_ALT3); /*HCKT*/
+	mxc_request_iomux(MX25_PIN_CSI_D8, MUX_CONFIG_ALT3); /*TX5_RX0*/
+	mxc_request_iomux(MX25_PIN_CSI_D9, MUX_CONFIG_ALT3); /*TX4_RX1*/
+	mxc_request_iomux(MX25_PIN_CSI_MCLK, MUX_CONFIG_ALT3); /*TX3_RX2*/
+	mxc_request_iomux(MX25_PIN_CSI_VSYNC, MUX_CONFIG_ALT3); /*TX2_RX3*/
+	mxc_request_iomux(MX25_PIN_CSI_HSYNC, MUX_CONFIG_ALT3); /*TX1*/
+	mxc_request_iomux(MX25_PIN_CSI_PIXCLK, MUX_CONFIG_ALT3); /*TX0*/
+
+#define ESAI_PAD_CTL (PAD_CTL_HYS_SCHMITZ | PAD_CTL_PKE_ENABLE | \
+		      PAD_CTL_100K_PU | PAD_CTL_PUE_PUD)
+	mxc_iomux_set_pad(MX25_PIN_CSI_D2, ESAI_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D3, ESAI_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D4, ESAI_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D5, ESAI_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D6, ESAI_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D7, ESAI_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D8, ESAI_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_CSI_D9, ESAI_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_CSI_MCLK, ESAI_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_CSI_VSYNC, ESAI_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_CSI_HSYNC, ESAI_PAD_CTL);
+	mxc_iomux_set_pad(MX25_PIN_CSI_PIXCLK, ESAI_PAD_CTL);
+
+#undef ESAI_PAD_CTL
+}
+EXPORT_SYMBOL(gpio_activate_esai_ports);
+
+/*!
+ * Inactivate ESAI ports to disable surround sound I/O
+ */
+void gpio_deactivate_esai_ports(void)
+{
+	mxc_free_iomux(MX25_PIN_CSI_D2, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_CSI_D3, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_CSI_D4, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_CSI_D5, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_CSI_D6, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_CSI_D7, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_CSI_D8, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_CSI_D9, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_CSI_MCLK, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_CSI_VSYNC, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_CSI_HSYNC, MUX_CONFIG_FUNC);
+	mxc_free_iomux(MX25_PIN_CSI_PIXCLK, MUX_CONFIG_FUNC);
+}
+EXPORT_SYMBOL(gpio_deactivate_esai_ports);
+
+
+/*!
+ * Activate CAN
+ */
+void gpio_can_active(int id)
+{
+#define CAN_PAD_CTL (PAD_CTL_DRV_3_3V | PAD_CTL_PKE_NONE | PAD_CTL_ODE_CMOS | \
+		     PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW)
+#define CAN_PAD_IN_CTL (PAD_CTL_HYS_CMOS | PAD_CTL_PKE_NONE)
+
+	switch (id) {
+	case 0:
+		/* CAN1 */
+		mxc_request_iomux(MX25_PIN_GPIO_A, MUX_CONFIG_ALT6); /*TXCAN*/
+		mxc_request_iomux(MX25_PIN_GPIO_B, MUX_CONFIG_ALT6); /*RXCAN*/
+
+		mxc_iomux_set_pad(MX25_PIN_GPIO_A, CAN_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_GPIO_B, CAN_PAD_IN_CTL);
+
+		mxc_iomux_set_input(MUX_IN_CAN1_IPP_IND_CANRX, INPUT_CTL_PATH1);
+		break;
+	case 1:
+		/* CAN2 */
+		mxc_request_iomux(MX25_PIN_GPIO_C, MUX_CONFIG_ALT6); /*TXCAN*/
+		mxc_request_iomux(MX25_PIN_GPIO_D, MUX_CONFIG_ALT6); /*RXCAN*/
+		mxc_request_iomux(MX25_PIN_D14, MUX_CONFIG_ALT5); /*PWDN*/
+
+		mxc_iomux_set_pad(MX25_PIN_GPIO_C, CAN_PAD_CTL);
+		mxc_iomux_set_pad(MX25_PIN_GPIO_D, CAN_PAD_IN_CTL);
+		mxc_iomux_set_pad(MX25_PIN_D14, CAN_PAD_CTL);
+
+		mxc_iomux_set_input(MUX_IN_CAN2_IPP_IND_CANRX, INPUT_CTL_PATH1);
+
+		/* Configure CAN_PWDN as output */
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_D14), "d14");
+		gpio_direction_output(IOMUX_TO_GPIO(MX25_PIN_D14), 0);
+
+		/* Enable input by setting PWDN/TLE6250.INH low (gpio4 bit6) */
+		gpio_set_value(IOMUX_TO_GPIO(MX25_PIN_D14), 0);
+		break;
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(gpio_can_active);
+
+/*!
+ * Inactivate CAN
+ */
+void gpio_can_inactive(int id)
+{
+	switch (id) {
+	case 0:
+		/* CAN1 */
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_GPIO_A), NULL); /*TXCAN*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_GPIO_B), NULL); /*RXCAN*/
+
+		mxc_free_iomux(MX25_PIN_GPIO_A, MUX_CONFIG_FUNC);
+		mxc_free_iomux(MX25_PIN_GPIO_B, MUX_CONFIG_FUNC);
+
+		break;
+	case 1:
+		/* CAN2 */
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_GPIO_C), NULL); /*TXCAN*/
+		gpio_request(IOMUX_TO_GPIO(MX25_PIN_GPIO_D), NULL); /*RXCAN*/
+
+		mxc_free_iomux(MX25_PIN_GPIO_C, MUX_CONFIG_FUNC);
+		mxc_free_iomux(MX25_PIN_GPIO_D, MUX_CONFIG_FUNC);
+
+		/* Disable input by setting PWDN/TLE6250.INH high */
+		gpio_set_value(IOMUX_TO_GPIO(MX25_PIN_D14), 1);
+		mxc_free_iomux(MX25_PIN_D14, MUX_CONFIG_ALT5);
+		break;
+	default:
+		break;
+	}
+}
+EXPORT_SYMBOL(gpio_can_inactive);
+
+/*!
+ * This function activates DAM port 4 to enable
+ * audio I/O.
+ */
+void gpio_activate_audio_ports(void)
+{
+	mxc_request_iomux(MX25_PIN_EB0, MUX_CONFIG_ALT4); /*SSI4_STXD*/
+	mxc_request_iomux(MX25_PIN_EB1, MUX_CONFIG_ALT4); /*SSI4_SRXD*/
+	mxc_request_iomux(MX25_PIN_RW, MUX_CONFIG_ALT4); /*SSI4_STXFS*/
+	mxc_request_iomux(MX25_PIN_OE, MUX_CONFIG_ALT4); /*SSI4_SCK*/
+	mxc_request_iomux(MX25_PIN_A10, MUX_CONFIG_ALT5); /*HP_DEC*/
+	mxc_request_iomux(MX25_PIN_D13, MUX_CONFIG_ALT5); /*AMP_SHUTDOWN*/
+
+	mxc_iomux_set_pad(MX25_PIN_EB0, PAD_CTL_SRE_FAST);
+	mxc_iomux_set_pad(MX25_PIN_EB1, PAD_CTL_SRE_FAST);
+	mxc_iomux_set_pad(MX25_PIN_RW, PAD_CTL_SRE_FAST);
+	mxc_iomux_set_pad(MX25_PIN_OE, PAD_CTL_SRE_FAST);
+	mxc_iomux_set_pad(MX25_PIN_D13, PAD_CTL_DRV_3_3V);
+
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_A10), "a10");
+	gpio_direction_input(IOMUX_TO_GPIO(MX25_PIN_A10));
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_D13), "d13");
+	gpio_direction_output(IOMUX_TO_GPIO(MX25_PIN_D13), 0);
+}
+EXPORT_SYMBOL(gpio_activate_audio_ports);
+
+/*!
+ * This function deactivates DAM port 4 for
+ * audio I/O
+ */
+void gpio_deactive_audio_ports(void)
+{
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_EB0), NULL); /*SSI4_STXD*/
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_EB1), NULL); /*SSI4_SRXD*/
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_RW), NULL); /*SSI4_STXFS*/
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_OE), NULL); /*SSI4_SCK*/
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_A10), NULL); /*HP_DEC*/
+	gpio_request(IOMUX_TO_GPIO(MX25_PIN_D13), NULL); /*AMP_SHUTDOWN*/
+
+	mxc_free_iomux(MX25_PIN_EB0, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_EB1, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_RW, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_OE, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_A10, MUX_CONFIG_GPIO);
+	mxc_free_iomux(MX25_PIN_D13, MUX_CONFIG_GPIO);
+}
+EXPORT_SYMBOL(gpio_deactive_audio_ports);
+
+int headphone_det_status(void)
+{
+	return gpio_get_value(IOMUX_TO_GPIO(MX25_PIN_A10));
+}
+EXPORT_SYMBOL(headphone_det_status);
+
+void sgtl5000_enable_amp(void)
+{
+	gpio_set_value(IOMUX_TO_GPIO(MX25_PIN_D13), 1);
+}
+EXPORT_SYMBOL(sgtl5000_enable_amp);
diff --git a/arch/arm/mach-mx25/mx25_3stack_pmic_mc34704.c b/arch/arm/mach-mx25/mx25_3stack_pmic_mc34704.c
new file mode 100644
index 0000000..249f568
--- /dev/null
+++ b/arch/arm/mach-mx25/mx25_3stack_pmic_mc34704.c
@@ -0,0 +1,171 @@
+/*
+ * mx25-3stack-pmic-mc34704.c  --  i.MX25 3STACK Driver for MC34704 PMIC
+ */
+ /*
+  * Copyright (C) 2009-2010 Freescale Semiconductor, Inc. All Rights Reserved.
+  */
+
+ /*
+  * The code contained herein is licensed under the GNU General Public
+  * License. You may obtain a copy of the GNU General Public License
+  * Version 2 or later at the following locations:
+  *
+  * http://www.opensource.org/licenses/gpl-license.html
+  * http://www.gnu.org/copyleft/gpl.html
+  */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/err.h>
+#include <linux/pmic_external.h>
+#include <linux/regulator/machine.h>
+#include <linux/mfd/mc34704/core.h>
+#include <mach/iomux-mx25.h>
+
+/*
+ * Convenience conversion.
+ * Here atm, maybe there is somewhere better for this.
+ */
+#define mV_to_uV(mV) (mV * 1000)
+#define uV_to_mV(uV) (uV / 1000)
+#define V_to_uV(V) (mV_to_uV(V * 1000))
+#define uV_to_V(uV) (uV_to_mV(uV) / 1000)
+
+struct mc34704;
+
+static struct regulator_consumer_supply bklt_consumers[] = {
+	{
+		.supply = "REG1_BKLT",
+	}
+};
+
+static struct regulator_init_data rbklt_init = {
+	.constraints = {
+			.name = "REG1_BKLT",
+			.min_uV =
+			mV_to_uV(REG1_V_MV * (1000 + REG1_DVS_MIN_PCT * 10) /
+				 1000),
+			.max_uV =
+			mV_to_uV(REG1_V_MV * (1000 + REG1_DVS_MAX_PCT * 10) /
+				 1000),
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+			},
+	.num_consumer_supplies = ARRAY_SIZE(bklt_consumers),
+	.consumer_supplies = bklt_consumers,
+};
+
+static struct regulator_consumer_supply rcpu_consumers[] = {
+	{
+		/* sgtl5000 */
+		.supply = "VDDA",
+		.dev_name = "0-000a",
+	},
+};
+
+static struct regulator_init_data rcpu_init = {
+	.constraints = {
+			.name = "REG2_CPU",
+			.min_uV =
+			mV_to_uV(REG2_V_MV * (1000 + REG2_DVS_MIN_PCT * 10) /
+				 1000),
+			.max_uV =
+			mV_to_uV(REG2_V_MV * (1000 + REG2_DVS_MAX_PCT * 10) /
+				 1000),
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+			},
+	.num_consumer_supplies = ARRAY_SIZE(rcpu_consumers),
+	.consumer_supplies = rcpu_consumers,
+};
+
+static struct regulator_consumer_supply core_consumers[] = {
+	{
+		.supply = "REG3_CORE",
+	}
+};
+
+static struct regulator_init_data rcore_init = {
+	.constraints = {
+			.name = "REG3_CORE",
+			.min_uV =
+			mV_to_uV(REG3_V_MV * (1000 + REG3_DVS_MIN_PCT * 10) /
+				 1000),
+			.max_uV =
+			mV_to_uV(REG3_V_MV * (1000 + REG3_DVS_MAX_PCT * 10) /
+				 1000),
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+			},
+	.num_consumer_supplies = ARRAY_SIZE(core_consumers),
+	.consumer_supplies = core_consumers,
+};
+
+static struct regulator_consumer_supply rddr_consumers[] = {
+	{
+		/* sgtl5000 */
+		.supply = "VDDIO",
+		.dev_name = "0-000a",
+	},
+};
+
+static struct regulator_init_data rddr_init = {
+	.constraints = {
+			.name = "REG4_DDR",
+			.min_uV =
+			mV_to_uV(REG4_V_MV * (1000 + REG4_DVS_MIN_PCT * 10) /
+				 1000),
+			.max_uV =
+			mV_to_uV(REG4_V_MV * (1000 + REG4_DVS_MAX_PCT * 10) /
+				 1000),
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+			},
+	.num_consumer_supplies = ARRAY_SIZE(rddr_consumers),
+	.consumer_supplies = rddr_consumers,
+};
+
+static struct regulator_consumer_supply pers_consumers[] = {
+	{
+		.supply = "REG5_PERS",
+	}
+};
+
+static struct regulator_init_data rpers_init = {
+	.constraints = {
+			.name = "REG5_PERS",
+			.min_uV =
+			mV_to_uV(REG5_V_MV * (1000 + REG5_DVS_MIN_PCT * 10) /
+				 1000),
+			.max_uV =
+			mV_to_uV(REG5_V_MV * (1000 + REG5_DVS_MAX_PCT * 10) /
+				 1000),
+			.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE,
+			},
+	.num_consumer_supplies = ARRAY_SIZE(pers_consumers),
+	.consumer_supplies = pers_consumers,
+};
+
+static int mc34704_regulator_init(struct mc34704 *mc34704)
+{
+	mc34704_register_regulator(mc34704, MC34704_BKLT, &rbklt_init);
+	mc34704_register_regulator(mc34704, MC34704_CPU, &rcpu_init);
+	mc34704_register_regulator(mc34704, MC34704_CORE, &rcore_init);
+	mc34704_register_regulator(mc34704, MC34704_DDR, &rddr_init);
+	mc34704_register_regulator(mc34704, MC34704_PERS, &rpers_init);
+
+	return 0;
+}
+
+static struct mc34704_platform_data mc34704_plat = {
+	.init = mc34704_regulator_init,
+};
+
+static struct i2c_board_info __initdata mc34704_i2c_device = {
+	.type = "mc34704",
+	.addr = 0x54,
+	.platform_data = &mc34704_plat,
+};
+
+int __init mx25_3stack_init_mc34704(void)
+{
+	return i2c_register_board_info(0, &mc34704_i2c_device, 1);
+}
-- 
1.7.0.4

