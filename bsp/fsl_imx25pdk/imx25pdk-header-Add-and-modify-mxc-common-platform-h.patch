From fd1e0551b79a3f7c6473c5f991dd1da170342865 Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Thu, 5 May 2011 20:11:17 +0800
Subject: [PATCH 4/9] imx25pdk/header: Add and modify mxc common platform headers

Add and modify mxc common platform headers.

[Original code taken from L2.6.31_09.12.01_SDK.tar.gz BSP package:
http://www.freescale.com/webapp/sps/site/prod_summary.jsp?code=
IMX25PDK&fpsp=1&tab=Design_Tools_Tab]

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/plat-mxc/include/mach/dma.h        |   12 +
 arch/arm/plat-mxc/include/mach/io.h         |   20 +
 arch/arm/plat-mxc/include/mach/iomux-mx25.h |  432 +++++++++++++++++++++++
 arch/arm/plat-mxc/include/mach/memory.h     |    4 +
 arch/arm/plat-mxc/include/mach/mx25.h       |  497 +++++++++++++++++++++++++-
 arch/arm/plat-mxc/include/mach/mxc.h        |   50 +++-
 arch/arm/plat-mxc/include/mach/system.h     |    4 +-
 arch/arm/plat-mxc/include/mach/timex.h      |    2 +-
 arch/arm/plat-mxc/include/mach/usb.h        |   91 +++++
 9 files changed, 1082 insertions(+), 30 deletions(-)

diff --git a/arch/arm/plat-mxc/include/mach/dma.h b/arch/arm/plat-mxc/include/mach/dma.h
index 077119b..28634b9 100644
--- a/arch/arm/plat-mxc/include/mach/dma.h
+++ b/arch/arm/plat-mxc/include/mach/dma.h
@@ -61,6 +61,18 @@ typedef enum mxc_dma_device {
 	MXC_DMA_SSI2_16BIT_TX1,
 	MXC_DMA_SSI2_24BIT_RX1,
 	MXC_DMA_SSI2_24BIT_TX1,
+	MXC_DMA_SSI3_8BIT_RX0,
+	MXC_DMA_SSI3_8BIT_TX0,
+	MXC_DMA_SSI3_16BIT_RX0,
+	MXC_DMA_SSI3_16BIT_TX0,
+	MXC_DMA_SSI3_24BIT_RX0,
+	MXC_DMA_SSI3_24BIT_TX0,
+	MXC_DMA_SSI3_8BIT_RX1,
+	MXC_DMA_SSI3_8BIT_TX1,
+	MXC_DMA_SSI3_16BIT_RX1,
+	MXC_DMA_SSI3_16BIT_TX1,
+	MXC_DMA_SSI3_24BIT_RX1,
+	MXC_DMA_SSI3_24BIT_TX1,
 	MXC_DMA_FIR_RX,
 	MXC_DMA_FIR_TX,
 	MXC_DMA_CSPI1_RX,
diff --git a/arch/arm/plat-mxc/include/mach/io.h b/arch/arm/plat-mxc/include/mach/io.h
index ab4ac68..8056954 100644
--- a/arch/arm/plat-mxc/include/mach/io.h
+++ b/arch/arm/plat-mxc/include/mach/io.h
@@ -45,6 +45,26 @@ __mx5_ioremap(unsigned long phys_addr, size_t size, unsigned int mtype)
 }
 #endif
 
+#ifdef CONFIG_ARCH_MX25
+#define __arch_ioremap(a, s, f) __mx25_ioremap(a, s, f)
+#define __arch_iounmap __iounmap
+
+static inline void *__iomem __mx25_ioremap(unsigned long cookie, size_t size,
+						unsigned int mtype)
+{
+	return __arm_ioremap(cookie, size, mtype);
+}
+/*
+ * This function is called to read a CPLD register over CSPI.
+ */
+unsigned int __weak spi_cpld_read(unsigned int offset);
+
+/*
+ * This function is called to write to a CPLD register over CSPI.
+ */
+unsigned int __weak spi_cpld_write(unsigned int offset, unsigned int reg_val);
+#endif
+
 /* io address mapping macro */
 #define __io(a)		__typesafe_io(a)
 
diff --git a/arch/arm/plat-mxc/include/mach/iomux-mx25.h b/arch/arm/plat-mxc/include/mach/iomux-mx25.h
index f39220d..cf6389d 100644
--- a/arch/arm/plat-mxc/include/mach/iomux-mx25.h
+++ b/arch/arm/plat-mxc/include/mach/iomux-mx25.h
@@ -19,7 +19,9 @@
 #ifndef __MACH_IOMUX_MX25_H__
 #define __MACH_IOMUX_MX25_H__
 
+#include <linux/types.h>
 #include <mach/iomux-v3.h>
+#include <mach/gpio.h>
 
 /*
  * IOMUX/PAD Bit field definitions
@@ -502,4 +504,434 @@
 #define MX25_PAD_CTL_GRP_DVS_SDHC1	IOMUX_PAD(0x458, 0x000, 0, 0, 0, NO_PAD_CTRL)
 #define MX25_PAD_CTL_GRP_DVS_LCD	IOMUX_PAD(0x45c, 0x000, 0, 0, 0, NO_PAD_CTRL)
 
+#ifndef __ASSEMBLY__
+
+/*!
+ * @name IOMUX/PAD Bit field definitions
+ */
+
+
+/*!
+ * In order to identify pins more effectively, each mux-controlled pin's
+ * enumerated value is constructed in the following way:
+ *
+ * -------------------------------------------------------------------
+ * 31-29 | 28 - 24 |23 - 21| 20 - 10| 9 - 0
+ * -------------------------------------------------------------------
+ * IO_P  |  IO_I   | RSVD  | PAD_I | MUX_I
+ * -------------------------------------------------------------------
+ *
+ * Bit 0 to 7 contains MUX_I used to identify the register
+ * offset (base is IOMUX_module_base ) defined in the Section
+ * "sw_pad_ctl & sw_mux_ctl details" of the IC Spec. Similar field
+ * definitions are used for the pad control register.  For example,
+ * MX25_PIN_A14 is defined in the enumeration:
+ * ( 0x10 << MUX_I) | ( 0x230 << PAD_I)
+ * So the absolute address is: IOMUX_module_base + 0x10.
+ * The pad control register offset is: 0x230.
+ */
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * MUX control register offset
+ */
+#define MUX_I		0
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * PAD control register offset
+ */
+#define PAD_I		10
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * reserved filed
+ */
+#define RSVD_I		21
+
+#define NON_GPIO_I	0x7
+#define PIN_TO_MUX_MASK	((1<<(PAD_I - MUX_I)) - 1)
+#define PIN_TO_PAD_MASK	((1<<(RSVD_I - PAD_I)) - 1)
+#define NON_MUX_I	PIN_TO_MUX_MASK
+
+#define _MXC_BUILD_PIN(gp, gi, mi, pi) \
+		(((gp) << MUX_IO_P) | ((gi) << MUX_IO_I) | \
+		((mi) << MUX_I) | ((pi) << PAD_I))
+
+#define _MXC_BUILD_GPIO_PIN(gp, gi, mi, pi) \
+		_MXC_BUILD_PIN(gp, gi, mi, pi)
+
+#define _MXC_BUILD_NON_GPIO_PIN(mi, pi) \
+		_MXC_BUILD_PIN(NON_GPIO_I, 0, mi, pi)
+
+#define PIN_TO_IOMUX_MUX(pin) ((pin >> MUX_I) & PIN_TO_MUX_MASK)
+#define PIN_TO_IOMUX_PAD(pin) ((pin >> PAD_I) & PIN_TO_PAD_MASK)
+
+/*! @} End IOMUX/PAD Bit field definitions */
+
+enum iomux_pins {
+	MX25_PIN_A10 = _MXC_BUILD_GPIO_PIN(3, 0, 0x8, 0x0),
+	MX25_PIN_A13 = _MXC_BUILD_GPIO_PIN(3, 1, 0x0c, 0x22C),
+	MX25_PIN_A14 = _MXC_BUILD_GPIO_PIN(1, 0, 0x10, 0x230),
+	MX25_PIN_A15 = _MXC_BUILD_GPIO_PIN(1, 1, 0x14, 0x234),
+	MX25_PIN_A16 = _MXC_BUILD_GPIO_PIN(1, 2, 0x18, 0x0),
+	MX25_PIN_A17 = _MXC_BUILD_GPIO_PIN(1, 3, 0x1c, 0x238),
+	MX25_PIN_A18 = _MXC_BUILD_GPIO_PIN(1, 4, 0x20, 0x23c),
+	MX25_PIN_A19 = _MXC_BUILD_GPIO_PIN(1, 5, 0x24, 0x240),
+	MX25_PIN_A20 = _MXC_BUILD_GPIO_PIN(1, 6, 0x28, 0x244),
+	MX25_PIN_A21 = _MXC_BUILD_GPIO_PIN(1, 7, 0x2c, 0x248),
+	MX25_PIN_A22 = _MXC_BUILD_GPIO_PIN(1, 8, 0x30, 0x0),
+	MX25_PIN_A23 = _MXC_BUILD_GPIO_PIN(1, 9, 0x34, 0x24c),
+	MX25_PIN_A24 = _MXC_BUILD_GPIO_PIN(1, 10, 0x38, 0x250),
+	MX25_PIN_A25 = _MXC_BUILD_GPIO_PIN(1, 11, 0x3c, 0x254),
+	MX25_PIN_EB0 = _MXC_BUILD_GPIO_PIN(1, 12, 0x40, 0x258),
+	MX25_PIN_EB1 = _MXC_BUILD_GPIO_PIN(1, 13, 0x44, 0x25c),
+	MX25_PIN_OE =  _MXC_BUILD_GPIO_PIN(1, 14, 0x48, 0x260),
+	MX25_PIN_CS0 = _MXC_BUILD_GPIO_PIN(3, 2, 0x4c, 0x0),
+	MX25_PIN_CS1 = _MXC_BUILD_GPIO_PIN(3, 3, 0x50, 0x0),
+	MX25_PIN_CS4 = _MXC_BUILD_GPIO_PIN(2, 20, 0x54, 0x264),
+	MX25_PIN_CS5 = _MXC_BUILD_GPIO_PIN(2, 21, 0x58, 0x268),
+	MX25_PIN_NF_CE0 = _MXC_BUILD_GPIO_PIN(2, 22, 0x5c, 0x26c),
+	MX25_PIN_ECB = _MXC_BUILD_GPIO_PIN(2, 23, 0x60, 0x270),
+	MX25_PIN_LBA = _MXC_BUILD_GPIO_PIN(2, 24, 0x64, 0x274),
+	MX25_PIN_BCLK = _MXC_BUILD_GPIO_PIN(3, 4, 0x68, 0x0),
+	MX25_PIN_RW = _MXC_BUILD_GPIO_PIN(2, 25, 0x6c, 0x278),
+	MX25_PIN_NFWE_B = _MXC_BUILD_GPIO_PIN(2, 26, 0x70, 0x0),
+	MX25_PIN_NFRE_B = _MXC_BUILD_GPIO_PIN(2, 27, 0x74, 0x0),
+	MX25_PIN_NFALE = _MXC_BUILD_GPIO_PIN(2, 28, 0x78, 0x0),
+	MX25_PIN_NFCLE = _MXC_BUILD_GPIO_PIN(2, 29, 0x7c, 0x0),
+	MX25_PIN_NFWP_B = _MXC_BUILD_GPIO_PIN(2, 30, 0x80, 0x0),
+	MX25_PIN_NFRB = _MXC_BUILD_GPIO_PIN(2, 31, 0x84, 0x27c),
+	MX25_PIN_D15 = _MXC_BUILD_GPIO_PIN(3, 5, 0x88, 0x280),
+	MX25_PIN_D14 = _MXC_BUILD_GPIO_PIN(3, 6, 0x8c, 0x284),
+	MX25_PIN_D13 = _MXC_BUILD_GPIO_PIN(3, 7, 0x90, 0x288),
+	MX25_PIN_D12 = _MXC_BUILD_GPIO_PIN(3, 8, 0x94, 0x28c),
+	MX25_PIN_D11 = _MXC_BUILD_GPIO_PIN(3, 9, 0x98, 0x290),
+	MX25_PIN_D10 = _MXC_BUILD_GPIO_PIN(3, 10, 0x9c, 0x294),
+	MX25_PIN_D9 = _MXC_BUILD_GPIO_PIN(3, 11, 0xa0, 0x298),
+	MX25_PIN_D8 = _MXC_BUILD_GPIO_PIN(3, 12, 0xa4, 0x29c),
+	MX25_PIN_D7 = _MXC_BUILD_GPIO_PIN(3, 13, 0xa8, 0x2a0),
+	MX25_PIN_D6 = _MXC_BUILD_GPIO_PIN(3, 14, 0xac, 0x2a4),
+	MX25_PIN_D5 = _MXC_BUILD_GPIO_PIN(3, 15, 0xb0, 0x2a8),
+	MX25_PIN_D4 = _MXC_BUILD_GPIO_PIN(3, 16, 0xb4, 0x2ac),
+	MX25_PIN_D3 = _MXC_BUILD_GPIO_PIN(3, 17, 0xb8, 0x2b0),
+	MX25_PIN_D2 = _MXC_BUILD_GPIO_PIN(3, 18, 0xbc, 0x2b4),
+	MX25_PIN_D1 = _MXC_BUILD_GPIO_PIN(3, 19, 0xc0, 0x2b8),
+	MX25_PIN_D0 = _MXC_BUILD_GPIO_PIN(3, 20, 0xc4, 0x2bc),
+	MX25_PIN_LD0 = _MXC_BUILD_GPIO_PIN(1, 15, 0xc8, 0x2c0),
+	MX25_PIN_LD1 = _MXC_BUILD_GPIO_PIN(1, 16, 0xcc, 0x2c4),
+	MX25_PIN_LD2 = _MXC_BUILD_GPIO_PIN(1, 17, 0xd0, 0x2c8),
+	MX25_PIN_LD3 = _MXC_BUILD_GPIO_PIN(1, 18, 0xd4, 0x2cc),
+	MX25_PIN_LD4 = _MXC_BUILD_GPIO_PIN(1, 19, 0xd8, 0x2d0),
+	MX25_PIN_LD5 = _MXC_BUILD_GPIO_PIN(0, 19, 0xdc, 0x2d4),
+	MX25_PIN_LD6 = _MXC_BUILD_GPIO_PIN(0, 20, 0xe0, 0x2d8),
+	MX25_PIN_LD7 = _MXC_BUILD_GPIO_PIN(0, 21, 0xe4, 0x2dc),
+	MX25_PIN_LD8 = _MXC_BUILD_NON_GPIO_PIN(0xe8, 0x2e0),
+	MX25_PIN_LD9 = _MXC_BUILD_NON_GPIO_PIN(0xec, 0x2e4),
+	MX25_PIN_LD10 = _MXC_BUILD_NON_GPIO_PIN(0xf0, 0x2e8),
+	MX25_PIN_LD11 = _MXC_BUILD_NON_GPIO_PIN(0xf4, 0x2ec),
+	MX25_PIN_LD12 = _MXC_BUILD_NON_GPIO_PIN(0xf8, 0x2f0),
+	MX25_PIN_LD13 = _MXC_BUILD_NON_GPIO_PIN(0xfc, 0x2f4),
+	MX25_PIN_LD14 = _MXC_BUILD_NON_GPIO_PIN(0x100, 0x2f8),
+	MX25_PIN_LD15 = _MXC_BUILD_NON_GPIO_PIN(0x104, 0x2fc),
+	MX25_PIN_HSYNC = _MXC_BUILD_GPIO_PIN(0, 22, 0x108, 0x300),
+	MX25_PIN_VSYNC = _MXC_BUILD_GPIO_PIN(0, 23, 0x10c, 0x304),
+	MX25_PIN_LSCLK = _MXC_BUILD_GPIO_PIN(0, 24, 0x110, 0x308),
+	MX25_PIN_OE_ACD = _MXC_BUILD_GPIO_PIN(0, 25, 0x114, 0x30c),
+	MX25_PIN_CONTRAST = _MXC_BUILD_NON_GPIO_PIN(0x118, 0x310),
+	MX25_PIN_PWM = _MXC_BUILD_GPIO_PIN(0, 26, 0x11c, 0x314),
+	MX25_PIN_CSI_D2 = _MXC_BUILD_GPIO_PIN(0, 27, 0x120, 0x318),
+	MX25_PIN_CSI_D3 = _MXC_BUILD_GPIO_PIN(0, 28, 0x124, 0x31c),
+	MX25_PIN_CSI_D4 = _MXC_BUILD_GPIO_PIN(0, 29, 0x128, 0x320),
+	MX25_PIN_CSI_D5 = _MXC_BUILD_GPIO_PIN(0, 30, 0x12c, 0x324),
+	MX25_PIN_CSI_D6 = _MXC_BUILD_GPIO_PIN(0, 31, 0x130, 0x328),
+	MX25_PIN_CSI_D7 = _MXC_BUILD_GPIO_PIN(0, 6, 0x134, 0x32c),
+	MX25_PIN_CSI_D8 = _MXC_BUILD_GPIO_PIN(0, 7, 0x138, 0x330),
+	MX25_PIN_CSI_D9 = _MXC_BUILD_GPIO_PIN(3, 21, 0x13c, 0x334),
+	MX25_PIN_CSI_MCLK = _MXC_BUILD_GPIO_PIN(0, 8, 0x140, 0x338),
+	MX25_PIN_CSI_VSYNC = _MXC_BUILD_GPIO_PIN(0, 9, 0x144, 0x33c),
+	MX25_PIN_CSI_HSYNC = _MXC_BUILD_GPIO_PIN(0, 10, 0x148, 0x340),
+	MX25_PIN_CSI_PIXCLK = _MXC_BUILD_GPIO_PIN(0, 11, 0x14c, 0x344),
+	MX25_PIN_I2C1_CLK = _MXC_BUILD_GPIO_PIN(0, 12, 0x150, 0x348),
+	MX25_PIN_I2C1_DAT = _MXC_BUILD_GPIO_PIN(0, 13, 0x154, 0x34c),
+	MX25_PIN_CSPI1_MOSI = _MXC_BUILD_GPIO_PIN(0, 14, 0x158, 0x350),
+	MX25_PIN_CSPI1_MISO = _MXC_BUILD_GPIO_PIN(0, 15, 0x15c, 0x354),
+	MX25_PIN_CSPI1_SS0 = _MXC_BUILD_GPIO_PIN(0, 16, 0x160, 0x358),
+	MX25_PIN_CSPI1_SS1 = _MXC_BUILD_GPIO_PIN(0, 17, 0x164, 0x35c),
+	MX25_PIN_CSPI1_SCLK = _MXC_BUILD_GPIO_PIN(0, 18, 0x168, 0x360),
+	MX25_PIN_CSPI1_RDY = _MXC_BUILD_GPIO_PIN(1, 22, 0x16c, 0x364),
+	MX25_PIN_UART1_RXD = _MXC_BUILD_GPIO_PIN(3, 22, 0x170, 0x368),
+	MX25_PIN_UART1_TXD = _MXC_BUILD_GPIO_PIN(3, 23, 0x174, 0x36c),
+	MX25_PIN_UART1_RTS = _MXC_BUILD_GPIO_PIN(3, 24, 0x178, 0x370),
+	MX25_PIN_UART1_CTS = _MXC_BUILD_GPIO_PIN(3, 25, 0x17c, 0x374),
+	MX25_PIN_UART2_RXD = _MXC_BUILD_GPIO_PIN(3, 26, 0x180, 0x378),
+	MX25_PIN_UART2_TXD = _MXC_BUILD_GPIO_PIN(3, 27, 0x184, 0x37c),
+	MX25_PIN_UART2_RTS = _MXC_BUILD_GPIO_PIN(3, 28, 0x188, 0x380),
+	MX25_PIN_UART2_CTS = _MXC_BUILD_GPIO_PIN(3, 29, 0x18c, 0x384),
+	MX25_PIN_SD1_CMD = _MXC_BUILD_GPIO_PIN(1, 23, 0x190, 0x388),
+	MX25_PIN_SD1_CLK = _MXC_BUILD_GPIO_PIN(1, 24, 0x194, 0x38c),
+	MX25_PIN_SD1_DATA0 = _MXC_BUILD_GPIO_PIN(1, 25, 0x198, 0x390),
+	MX25_PIN_SD1_DATA1 = _MXC_BUILD_GPIO_PIN(1, 26, 0x19c, 0x394),
+	MX25_PIN_SD1_DATA2 = _MXC_BUILD_GPIO_PIN(1, 27, 0x1a0, 0x398),
+	MX25_PIN_SD1_DATA3 = _MXC_BUILD_GPIO_PIN(1, 28, 0x1a4, 0x39c),
+	MX25_PIN_KPP_ROW0 = _MXC_BUILD_GPIO_PIN(1, 29, 0x1a8, 0x3a0),
+	MX25_PIN_KPP_ROW1 = _MXC_BUILD_GPIO_PIN(1, 30, 0x1ac, 0x3a4),
+	MX25_PIN_KPP_ROW2 = _MXC_BUILD_GPIO_PIN(1, 31, 0x1b0, 0x3a8),
+	MX25_PIN_KPP_ROW3 = _MXC_BUILD_GPIO_PIN(2, 0, 0x1b4, 0x3ac),
+	MX25_PIN_KPP_COL0 = _MXC_BUILD_GPIO_PIN(2, 1, 0x1b8, 0x3b0),
+	MX25_PIN_KPP_COL1 = _MXC_BUILD_GPIO_PIN(2, 2, 0x1bc, 0x3b4),
+	MX25_PIN_KPP_COL2 = _MXC_BUILD_GPIO_PIN(2, 3, 0x1c0, 0x3b8),
+	MX25_PIN_KPP_COL3 = _MXC_BUILD_GPIO_PIN(2, 4, 0x1c4, 0x3bc),
+	MX25_PIN_FEC_MDC = _MXC_BUILD_GPIO_PIN(2, 5, 0x1c8, 0x3c0),
+	MX25_PIN_FEC_MDIO = _MXC_BUILD_GPIO_PIN(2, 6, 0x1cc, 0x3c4),
+	MX25_PIN_FEC_TDATA0 = _MXC_BUILD_GPIO_PIN(2, 7, 0x1d0, 0x3c8),
+	MX25_PIN_FEC_TDATA1 = _MXC_BUILD_GPIO_PIN(2, 8, 0x1d4, 0x3cc),
+	MX25_PIN_FEC_TX_EN = _MXC_BUILD_GPIO_PIN(2, 9, 0x1d8, 0x3d0),
+	MX25_PIN_FEC_RDATA0 = _MXC_BUILD_GPIO_PIN(2, 10, 0x1dc, 0x3d4),
+	MX25_PIN_FEC_RDATA1 = _MXC_BUILD_GPIO_PIN(2, 11, 0x1e0, 0x3d8),
+	MX25_PIN_FEC_RX_DV = _MXC_BUILD_GPIO_PIN(2, 12, 0x1e4, 0x3dc),
+	MX25_PIN_FEC_TX_CLK = _MXC_BUILD_GPIO_PIN(2, 13, 0x1e8, 0x3e0),
+	MX25_PIN_RTCK = _MXC_BUILD_GPIO_PIN(2, 14, 0x1ec, 0x3e4),
+	MX25_PIN_DE_B = _MXC_BUILD_GPIO_PIN(1, 20, 0x1f0, 0x3ec),
+	MX25_PIN_TDO = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x3e8),
+	MX25_PIN_GPIO_A = _MXC_BUILD_GPIO_PIN(0, 0, 0x1f4, 0x3f0),
+	MX25_PIN_GPIO_B = _MXC_BUILD_GPIO_PIN(0, 1, 0x1f8, 0x3f4),
+	MX25_PIN_GPIO_C = _MXC_BUILD_GPIO_PIN(0, 2, 0x1fc, 0x3f8),
+	MX25_PIN_GPIO_D = _MXC_BUILD_GPIO_PIN(0, 3, 0x200, 0x3fc),
+	MX25_PIN_GPIO_E = _MXC_BUILD_GPIO_PIN(0, 4, 0x204, 0x400),
+	MX25_PIN_GPIO_F = _MXC_BUILD_GPIO_PIN(0, 5, 0x208, 0x404),
+	MX25_PIN_EXT_ARMCLK = _MXC_BUILD_GPIO_PIN(2, 15, 0x20c, 0x0),
+	MX25_PIN_UPLL_BYPCLK = _MXC_BUILD_GPIO_PIN(2, 16, 0x210, 0x0),
+	MX25_PIN_VSTBY_REQ = _MXC_BUILD_GPIO_PIN(2, 17, 0x214, 0x408),
+	MX25_PIN_VSTBY_ACK = _MXC_BUILD_GPIO_PIN(2, 18, 0x218, 0x40c),
+	MX25_PIN_POWER_FAIL = _MXC_BUILD_GPIO_PIN(2, 19, 0x21c, 0x410),
+	MX25_PIN_CLKO = _MXC_BUILD_GPIO_PIN(1, 21, 0x220, 0x414),
+	MX25_PIN_BOOT_MODE0 = _MXC_BUILD_GPIO_PIN(3, 30, 0x224, 0x0),
+	MX25_PIN_BOOT_MODE1 = _MXC_BUILD_GPIO_PIN(3, 31, 0x228, 0x0),
+
+	MX25_PIN_CTL_GRP_DVS_MISC = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x418),
+	MX25_PIN_CTL_GRP_DSE_FEC = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x41c),
+	MX25_PIN_CTL_GRP_DVS_JTAG = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x420),
+	MX25_PIN_CTL_GRP_DSE_NFC = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x424),
+	MX25_PIN_CTL_GRP_DSE_CSI = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x428),
+	MX25_PIN_CTL_GRP_DSE_WEIM = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x42c),
+	MX25_PIN_CTL_GRP_DSE_DDR = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x430),
+	MX25_PIN_CTL_GRP_DVS_CRM = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x434),
+	MX25_PIN_CTL_GRP_DSE_KPP = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x438),
+	MX25_PIN_CTL_GRP_DSE_SDHC1 = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x43c),
+	MX25_PIN_CTL_GRP_DSE_LCD = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x440),
+	MX25_PIN_CTL_GRP_DSE_UART = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x444),
+	MX25_PIN_CTL_GRP_DVS_NFC = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x448),
+	MX25_PIN_CTL_GRP_DVS_CSI = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x44c),
+	MX25_PIN_CTL_GRP_DSE_CSPI1 = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x450),
+	MX25_PIN_CTL_GRP_DDRTYPE = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x454),
+	MX25_PIN_CTL_GRP_DVS_SDHC1 = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x458),
+	MX25_PIN_CTL_GRP_DVS_LCD = _MXC_BUILD_NON_GPIO_PIN(NON_MUX_I, 0x45c)
+};
+
+#endif
+
+typedef unsigned int iomux_pin_name_t;
+
+/*!
+ * IOMUX functions
+ * SW_MUX_CTL
+ */
+typedef enum iomux_pin_config {
+	MUX_CONFIG_FUNC = 0,	/*!< used as function */
+	MUX_CONFIG_ALT1,	/*!< used as alternate function 1 */
+	MUX_CONFIG_ALT2,	/*!< used as alternate function 2 */
+	MUX_CONFIG_ALT3,	/*!< used as alternate function 3 */
+	MUX_CONFIG_ALT4,	/*!< used as alternate function 4 */
+	MUX_CONFIG_ALT5,	/*!< used as alternate function 5 */
+	MUX_CONFIG_ALT6,	/*!< used as alternate function 6 */
+	MUX_CONFIG_ALT7,	/*!< used as alternate function 7 */
+	MUX_CONFIG_SION = 0x1 << 4,	/*!< used as LOOPBACK:MUX SION bit */
+	MUX_CONFIG_GPIO = MUX_CONFIG_ALT5,	/*!< used as GPIO */
+} iomux_pin_cfg_t;
+
+/*!
+ * IOMUX pad functions
+ * SW_PAD_CTL
+ */
+typedef enum iomux_pad_config {
+	PAD_CTL_DRV_3_3V = 0x0 << 13,
+	PAD_CTL_DRV_1_8V = 0x1 << 13,
+	PAD_CTL_HYS_CMOS = 0x0 << 8,
+	PAD_CTL_HYS_SCHMITZ = 0x1 << 8,
+	PAD_CTL_PKE_NONE = 0x0 << 7,
+	PAD_CTL_PKE_ENABLE = 0x1 << 7,
+	PAD_CTL_PUE_KEEPER = 0x0 << 6,
+	PAD_CTL_PUE_PULL = 0x1 << 6,
+	PAD_CTL_PUE_PUD = 0x1 << 6,
+	PAD_CTL_100K_PD = 0x0 << 4,
+	PAD_CTL_47K_PU = 0x1 << 4,
+	PAD_CTL_100K_PU = 0x2 << 4,
+	PAD_CTL_22K_PU = 0x3 << 4,
+	PAD_CTL_ODE_CMOS = 0x0 << 3,
+	PAD_CTL_ODE_OpenDrain = 0x1 << 3,
+	PAD_CTL_DRV_NORMAL = 0x0 << 1,
+	PAD_CTL_DRV_HIGH = 0x1 << 1,
+	PAD_CTL_DRV_MAX = 0x2 << 1,
+} iomux_pad_config_t;
+
+/*!
+ * IOMUX general purpose functions
+ * IOMUXC_GPR1
+ */
+typedef enum iomux_gp_func {
+	MUX_SDCTL_CSD0_SEL = 0x1 << 0,
+	MUX_SDCTL_CSD1_SEL = 0x1 << 1,
+} iomux_gp_func_t;
+
+/*!
+ * IOMUX SELECT_INPUT register index
+ * Base register is IOMUXSW_INPUT_CTL in iomux.c
+ */
+typedef enum iomux_input_select {
+	MUX_IN_AUDMUX_P4_INPUT_DA_AMX = 0,
+	MUX_IN_AUDMUX_P4_INPUT_DB_AMX,
+	MUX_IN_AUDMUX_P4_INPUT_RXCLK_AMX,
+	MUX_IN_AUDMUX_P4_INPUT_RXFS_AMX,
+	MUX_IN_AUDMUX_P4_INPUT_TXCLK_AMX,
+	MUX_IN_AUDMUX_P4_INPUT_TXFS_AMX,
+	MUX_IN_AUDMUX_P7_INPUT_DA_AMX,
+	MUX_IN_AUDMUX_P7_INPUT_TXFS_AMX,
+	MUX_IN_CAN1_IPP_IND_CANRX,
+	MUX_IN_CAN2_IPP_IND_CANRX,
+	MUX_IN_CSI_IPP_CSI_D_0,
+	MUX_IN_CSI_IPP_CSI_D_1,
+	MUX_IN_CSPI1_IPP_IND_SS3_B,
+	MUX_IN_CSPI2_IPP_CSPI_CLK_IN,
+	MUX_IN_CSPI2_IPP_IND_DATAREADY_B,
+	MUX_IN_CSPI2_IPP_IND_MISO,
+	MUX_IN_CSPI2_IPP_IND_MOSI,
+	MUX_IN_CSPI2_IPP_IND_SS0_B,
+	MUX_IN_CSPI2_IPP_IND_SS1_B,
+	MUX_IN_CSPI3_IPP_CSPI_CLK_IN,
+	MUX_IN_CSPI3_IPP_IND_DATAREADY_B,
+	MUX_IN_CSPI3_IPP_IND_MISO,
+	MUX_IN_CSPI3_IPP_IND_MOSI,
+	MUX_IN_CSPI3_IPP_IND_SS0_B,
+	MUX_IN_CSPI3_IPP_IND_SS1_B,
+	MUX_IN_CSPI3_IPP_IND_SS2_B,
+	MUX_IN_CSPI3_IPP_IND_SS3_B,
+	MUX_IN_ESDHC1_IPP_DAT4_IN,
+	MUX_IN_ESDHC1_IPP_DAT5_IN,
+	MUX_IN_ESDHC1_IPP_DAT6_IN,
+	MUX_IN_ESDHC1_IPP_DAT7_IN,
+	MUX_IN_ESDHC2_IPP_CARD_CLK_IN,
+	MUX_IN_ESDHC2_IPP_CMD_IN,
+	MUX_IN_ESDHC2_IPP_DAT0_IN,
+	MUX_IN_ESDHC2_IPP_DAT1_IN,
+	MUX_IN_ESDHC2_IPP_DAT2_IN,
+	MUX_IN_ESDHC2_IPP_DAT3_IN,
+	MUX_IN_ESDHC2_IPP_DAT4_IN,
+	MUX_IN_ESDHC2_IPP_DAT5_IN,
+	MUX_IN_ESDHC2_IPP_DAT6_IN,
+	MUX_IN_ESDHC2_IPP_DAT7_IN,
+	MUX_IN_FEC_FEC_COL,
+	MUX_IN_FEC_FEC_CRS,
+	MUX_IN_FEC_FEC_RDATA_2,
+	MUX_IN_FEC_FEC_RDATA_3,
+	MUX_IN_FEC_FEC_RX_CLK,
+	MUX_IN_FEC_FEC_RX_ER,
+	MUX_IN_I2C2_IPP_SCL_IN,
+	MUX_IN_I2C2_IPP_SDA_IN,
+	MUX_IN_I2C3_IPP_SCL_IN,
+	MUX_IN_I2C3_IPP_SDA_IN,
+	MUX_IN_KPP_IPP_IND_COL_4,
+	MUX_IN_KPP_IPP_IND_COL_5,
+	MUX_IN_KPP_IPP_IND_COL_6,
+	MUX_IN_KPP_IPP_IND_COL_7,
+	MUX_IN_KPP_IPP_IND_ROW_4,
+	MUX_IN_KPP_IPP_IND_ROW_5,
+	MUX_IN_KPP_IPP_IND_ROW_6,
+	MUX_IN_KPP_IPP_IND_ROW_7,
+	MUX_IN_SIM1_PIN_SIM_RCVD1_IN,
+	MUX_IN_SIM1_PIN_SIM_SIMPD1,
+	MUX_IN_SIM1_SIM_RCVD1_IO,
+	MUX_IN_SIM2_PIN_SIM_RCVD1_IN,
+	MUX_IN_SIM2_PIN_SIM_SIMPD1,
+	MUX_IN_SIM2_SIM_RCVD1_IO,
+	MUX_IN_UART3_IPP_UART_RTS_B,
+	MUX_IN_UART3_IPP_UART_RXD_MUX,
+	MUX_IN_UART4_IPP_UART_RTS_B,
+	MUX_IN_UART4_IPP_UART_RXD_MUX,
+	MUX_IN_UART5_IPP_UART_RTS_B,
+	MUX_IN_UART5_IPP_UART_RXD_MUX,
+	MUX_IN_USB_TOP_IPP_IND_OTG_USB_OC,
+	MUX_IN_USB_TOP_IPP_IND_UH2_USB_OC,
+} iomux_input_select_t;
+
+/*!
+ * IOMUX input functions
+ * SW_SELECT_INPUT bits 2-0
+ */
+typedef enum iomux_input_config {
+	INPUT_CTL_PATH0 = 0x0,
+	INPUT_CTL_PATH1,
+	INPUT_CTL_PATH2,
+	INPUT_CTL_PATH3,
+	INPUT_CTL_PATH4,
+	INPUT_CTL_PATH5,
+	INPUT_CTL_PATH6,
+	INPUT_CTL_PATH7,
+} iomux_input_cfg_t;
+
+struct mxc_iomux_pin_cfg {
+	iomux_pin_name_t pin;
+	u8 mux_mode;
+	u16 pad_cfg;
+	u8 in_select;
+	u8 in_mode;
+};
+
+/*!
+ * Request ownership for an IO pin. This function has to be the first one
+ * being called before that pin is used. The caller has to check the
+ * return value to make sure it returns 0.
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  cfg		an input function as defined in \b #iomux_pin_cfg_t
+ *
+ * @return		0 if successful; Non-zero otherwise
+ */
+int mxc_request_iomux(iomux_pin_name_t pin, iomux_pin_cfg_t cfg);
+
+/*!
+ * Release ownership for an IO pin
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  cfg		an input function as defined in \b #iomux_pin_cfg_t
+ */
+void mxc_free_iomux(iomux_pin_name_t pin, iomux_pin_cfg_t cfg);
+
+/*!
+ * This function enables/disables the general purpose function for a particular
+ * signal.
+ *
+ * @param  gp   one signal as defined in \b #iomux_gp_func_t
+ * @param  en   \b #true to enable; \b #false to disable
+ */
+void mxc_iomux_set_gpr(iomux_gp_func_t gp, bool en);
+
+/*!
+ * This function configures the pad value for a IOMUX pin.
+ *
+ * @param  pin          a pin number as defined in \b #iomux_pin_name_t
+ * @param  config       the ORed value of elements defined in \b
+ *				#iomux_pad_config_t
+ */
+void mxc_iomux_set_pad(iomux_pin_name_t pin, u32 config);
+
+/*!
+ * This function configures input path.
+ *
+ * @param  input        index of input select register as defined in \b
+ *				#iomux_input_select_t
+ * @param  config       the binary value of elements defined in \b
+ *				#iomux_input_cfg_t
+ */
+void mxc_iomux_set_input(iomux_input_select_t input, u32 config);
+
 #endif /* __MACH_IOMUX_MX25_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/memory.h b/arch/arm/plat-mxc/include/mach/memory.h
index bfb79eb..c86ad76 100644
--- a/arch/arm/plat-mxc/include/mach/memory.h
+++ b/arch/arm/plat-mxc/include/mach/memory.h
@@ -60,4 +60,8 @@
 #define CONSISTENT_DMA_SIZE (32 * SZ_1M)
 #endif
 
+#ifdef CONFIG_ARCH_MX25
+#define CONSISTENT_DMA_SIZE (32 * SZ_1M)
+#endif
+
 #endif /* __ASM_ARCH_MXC_MEMORY_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/mx25.h b/arch/arm/plat-mxc/include/mach/mx25.h
index 4eb6e33..cf21798 100644
--- a/arch/arm/plat-mxc/include/mach/mx25.h
+++ b/arch/arm/plat-mxc/include/mach/mx25.h
@@ -1,48 +1,505 @@
 #ifndef __MACH_MX25_H__
 #define __MACH_MX25_H__
 
+/*
+ * ---------------------------------------------------------------------------
+ * Processor specific defines
+ * ---------------------------------------------------------------------------
+ */
+#define CHIP_REV_1_0            0x10
+#define CHIP_REV_1_1            0x11
+#define CHIP_REV_1_2            0x12
+#define CHIP_REV_1_3            0x13
+#define CHIP_REV_2_0            0x20
+#define CHIP_REV_2_1            0x21
+#define CHIP_REV_2_2            0x22
+#define CHIP_REV_2_3            0x23
+#define CHIP_REV_3_0            0x30
+#define CHIP_REV_3_1            0x31
+#define CHIP_REV_3_2            0x32
+
+#define BOARD_REV_1             0x000
+#define BOARD_REV_2             0x100
+
+#define MXC_SDMA_V2
+
+/*
+ * MX25 memory map:
+ *
+ * Virt     Phys        Size    What
+ * ---------------------------------------------------------------------------
+ * FC000000 43F00000    1M      AIPS 1
+ * FC100000 50000000    1M      SPBA
+ * FC200000 53F00000    1M      AIPS 2
+ * FC300000 60000000    1M      ROMPATCH (128M)
+ * FC400000 68000000    1M      ASIC (128M)
+ * FC500000 78000000    128K    FBC RAM (IRAM)
+ *          80000000    256M    SDRAM0
+ *          90000000    256M    SDRAM1
+ *          A0000000    128M    CS0 Flash
+ *          A8000000    128M    CS1 Flash
+ *          B0000000    32M     CS2 SRAM
+ *          B2000000    32M     CS3
+ *          B4000000    32M     CS4
+ *          B6000000    32M     CS5
+ * FC520000 B8000000    64K     SDRAM, WEIM, M3IF, EMI controllers
+ * FC530000 BB000000    8K      NFC
+ */
+
+/*!
+ * Define this option to specify we are using the newer SDMA module.
+ */
 #define MX25_AIPS1_BASE_ADDR		0x43f00000
 #define MX25_AIPS1_BASE_ADDR_VIRT	0xfc000000
 #define MX25_AIPS1_SIZE			SZ_1M
+
+#define MX25_MAX_BASE_ADDR		(MX25_AIPS1_BASE_ADDR + 0x04000)
+#define MX25_CLKCTL_BASE_ADDR		(MX25_AIPS1_BASE_ADDR + 0x08000)
+#define MX25_ETB_SLOT4_BASE_ADDR	(MX25_AIPS1_BASE_ADDR + 0x0c000)
+#define MX25_ETB_SLOT5_BASE_ADDR	(MX25_AIPS1_BASE_ADDR + 0x10000)
+#define MX25_AAPE_BASE_ADDR		(MX25_AIPS1_BASE_ADDR + 0x14000)
+#define MX25_I2C_BASE_ADDR		(MX25_AIPS1_BASE_ADDR + 0x80000)
+#define MX25_I2C3_BASE_ADDR		(MX25_AIPS1_BASE_ADDR + 0x84000)
+#define MX25_CAN1_BASE_ADDR		(MX25_AIPS1_BASE_ADDR + 0x88000)
+#define MX25_CAN3_BASE_ADDR		(MX25_AIPS1_BASE_ADDR + 0x8c000)
+#define MX25_UART1_BASE_ADDR		(MX25_AIPS1_BASE_ADDR + 0x90000)
+#define MX25_UART2_BASE_ADDR		(MX25_AIPS1_BASE_ADDR + 0x94000)
+#define MX25_I2C2_BASE_ADDR		(MX25_AIPS1_BASE_ADDR + 0x98000)
+#define MX25_OWIRE_BASE_ADDR		(MX25_AIPS1_BASE_ADDR + 0x9c000)
+#define MX25_ATA_BASE_ADDR		(MX25_AIPS1_BASE_ADDR + 0xa0000)
+#define MX25_CSPI1_BASE_ADDR		(MX25_AIPS1_BASE_ADDR + 0xa4000)
+#define MX25_KPP_BASE_ADDR		(MX25_AIPS1_BASE_ADDR + 0xa8000)
+#define MX25_IOMUXC_BASE_ADDR		(MX25_AIPS1_BASE_ADDR + 0xac000)
+#define MX25_AUDMUX_BASE_ADDR		(MX25_AIPS1_BASE_ADDR + 0xb0000)
+#define MX25_ECT_A_BASE_ADDR		(MX25_AIPS1_BASE_ADDR + 0xb8000)
+#define MX25_ECT_B_BASE_ADDR		(MX25_AIPS1_BASE_ADDR + 0xbc000)
+
+#define MX25_SPBA0_BASE_ADDR		0x50000000
+#define MX25_SPBA0_BASE_ADDR_VIRT	0xfc100000
+#define MX25_SPBA0_SIZE			SZ_1M
+#define SPBA_CTRL_BASE_ADDR		MX25_SPBA0_BASE_ADDR
+
+#define MX25_CSPI3_BASE_ADDR		(MX25_SPBA0_BASE_ADDR + 0x04000)
+#define MX25_UART4_BASE_ADDR		(MX25_SPBA0_BASE_ADDR + 0x08000)
+#define MX25_UART3_BASE_ADDR		(MX25_SPBA0_BASE_ADDR + 0x0c000)
+#define MX25_CSPI2_BASE_ADDR		(MX25_SPBA0_BASE_ADDR + 0x10000)
+#define MX25_SSI2_BASE_ADDR		(MX25_SPBA0_BASE_ADDR + 0x14000)
+#define MX25_ESAI_BASE_ADDR		(MX25_SPBA0_BASE_ADDR + 0x18000)
+#define MX25_ATA_DMA_BASE_ADDR		(MX25_SPBA0_BASE_ADDR + 0x20000)
+#define MX25_SIM1_BASE_ADDR		(MX25_SPBA0_BASE_ADDR + 0x24000)
+#define MX25_SIM2_BASE_ADDR		(MX25_SPBA0_BASE_ADDR + 0x28000)
+#define MX25_UART5_BASE_ADDR		(MX25_SPBA0_BASE_ADDR + 0x2c000)
+#define MX25_TSC_BASE_ADDR		(MX25_SPBA0_BASE_ADDR + 0x30000)
+#define MX25_SSI1_BASE_ADDR		(MX25_SPBA0_BASE_ADDR + 0x34000)
+#define MX25_FEC_BASE_ADDR		(MX25_SPBA0_BASE_ADDR + 0x38000)
+#define MX25_SPBA_CTRL_BASE_ADDR	(MX25_SPBA0_BASE_ADDR + 0x3c000)
+
 #define MX25_AIPS2_BASE_ADDR		0x53f00000
 #define MX25_AIPS2_BASE_ADDR_VIRT	0xfc200000
 #define MX25_AIPS2_SIZE			SZ_1M
-#define MX25_AVIC_BASE_ADDR		0x68000000
-#define MX25_AVIC_BASE_ADDR_VIRT	0xfc400000
-#define MX25_AVIC_SIZE			SZ_1M
-
-#define MX25_IOMUXC_BASE_ADDR		(MX25_AIPS1_BASE_ADDR + 0xac000)
 
+#define MX25_CCM_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0x80000)
 #define MX25_CRM_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0x80000)
+#define MX25_GPT4_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0x84000)
+#define MX25_GPT3_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0x88000)
+#define MX25_GPT2_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0x8c000)
 #define MX25_GPT1_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0x90000)
+#define MX25_EPIT1_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0x94000)
+#define MX25_EPIT2_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0x98000)
+#define MX25_GPIO4_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0x9c000)
+#define MX25_PWM2_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0xa0000)
+#define MX25_GPIO3_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0xa4000)
+#define MX25_PWM3_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0xa8000)
+#define MX25_SCC_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0xac000)
+#define MX25_RNGB_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0xb0000)
+#define MX25_MMC_SDHC1_BASE_ADDR	(MX25_AIPS2_BASE_ADDR + 0xb4000)
+#define MX25_MMC_SDHC2_BASE_ADDR	(MX25_AIPS2_BASE_ADDR + 0xb8000)
+#define MX25_LCDC_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0xbc000)
+#define MX25_SLCDC_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0xc0000)
+#define MX25_PWM4_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0xc8000)
+#define MX25_GPIO1_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0xcc000)
+#define MX25_GPIO2_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0xd0000)
+#define MX25_SDMA_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0xd4000)
 #define MX25_WDOG_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0xdc000)
+#define MX25_PWM1_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0xe0000)
+#define MX25_RTIC_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0xec000)
+#define MX25_IIM_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0xf0000)
+#define MX25_USBOTG_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0xf4000)
+#define MX25_CSI_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0xf8000)
+#define MX25_DRYICE_BASE_ADDR		(MX25_AIPS2_BASE_ADDR + 0xfc000)
 
 #define MX25_GPIO1_BASE_ADDR_VIRT	(MX25_AIPS2_BASE_ADDR_VIRT + 0xcc000)
 #define MX25_GPIO2_BASE_ADDR_VIRT	(MX25_AIPS2_BASE_ADDR_VIRT + 0xd0000)
 #define MX25_GPIO3_BASE_ADDR_VIRT	(MX25_AIPS2_BASE_ADDR_VIRT + 0xa4000)
 #define MX25_GPIO4_BASE_ADDR_VIRT	(MX25_AIPS2_BASE_ADDR_VIRT + 0x9c000)
+/*
+ * ROMP
+ */
+#define MX25_ROMP_BASE_ADDR		0x60000000
+#define MX25_ROMP_BASE_ADDR_VIRT	0xfc300000
+#define MX25_ROMP_SIZE			SZ_1M
+
+/*
+ * ASIC
+ */
+#define MX25_ASIC_BASE_ADDR             0x68000000
+#define MX25_ASIC_BASE_ADDR_VIRT        0xfc400000
+#define MX25_ASIC_SIZE			SZ_1M
+#define MX25_AVIC_BASE_ADDR             MX25_ASIC_BASE_ADDR
+#define MX25_AVIC_BASE_ADDR_VIRT        MX25_ASIC_BASE_ADDR_VIRT
+#define MX25_AVIC_SIZE                  MX25_ASIC_SIZE
 
-#define MX25_IO_ADDRESS(x) (					\
-	IMX_IO_ADDRESS(x, MX25_AIPS1) ?:			\
-	IMX_IO_ADDRESS(x, MX25_AIPS2) ?:			\
-	IMX_IO_ADDRESS(x, MX25_AVIC))
+/*
+ * IRAM
+ */
+#define MX25_IRAM_BASE_ADDR		0x78000000	/* internal ram */
+#define MX25_IRAM_BASE_ADDR_VIRT	0xfc500000
+#define MX25_IRAM_SIZE			SZ_128K
+#define IRAM_BASE_ADDR			MX25_IRAM_BASE_ADDR
+#define IRAM_BASE_ADDR_VIRT		MX25_IRAM_BASE_ADDR_VIRT
+#define IRAM_SIZE			MX25_IRAM_SIZE
 
-#define MX25_UART1_BASE_ADDR		0x43f90000
-#define MX25_UART2_BASE_ADDR		0x43f94000
+/*
+ * Memory regions and CS
+ */
+#define MX25_CSD0_BASE_ADDR		0x80000000
+#define MX25_CSD1_BASE_ADDR		0x90000000
 
-#define MX25_FEC_BASE_ADDR		0x50038000
+#define SDRAM_BASE_ADDR			MX25_CSD0_BASE_ADDR
+#define CSD0_BASE_ADDR			MX25_CSD0_BASE_ADDR
+
+#define CS0_BASE_ADDR			0xa0000000
+#define CS1_BASE_ADDR			0xa8000000
+#define CS2_BASE_ADDR			0xb0000000
+#define CS3_BASE_ADDR			0xb2000000
+#define CS4_BASE_ADDR			0xb4000000
+#define CS4_SIZE			SZ_32M
+#define CS5_BASE_ADDR			0xb6000000
+#define CS5_SIZE			SZ_32M
+
+/*
+ * SDRAM, WEIM, M3IF, EMI controllers
+ */
+#define MX25_X_MEMC_BASE_ADDR		0xb8000000
+#define MX25_X_MEMC_BASE_ADDR_VIRT	0xfc520000
+#define MX25_X_MEMC_SIZE		SZ_64K
+
+#define MX25_SDRAMC_BASE_ADDR		(MX25_X_MEMC_BASE_ADDR + 0x1000)
+#define MX25_WEIM_BASE_ADDR		(MX25_X_MEMC_BASE_ADDR + 0x2000)
+#define MX25_M3IF_BASE_ADDR		(MX25_X_MEMC_BASE_ADDR + 0x3000)
+#define MX25_EMI_CTL_BASE_ADDR		(MX25_X_MEMC_BASE_ADDR + 0x4000)
+
+/*
+ * NFC controller
+ */
 #define MX25_NFC_BASE_ADDR		0xbb000000
-#define MX25_DRYICE_BASE_ADDR		0x53ffc000
-#define MX25_LCDC_BASE_ADDR		0x53fbc000
+#define MX25_NFC_BASE_ADDR_VIRT		0xfc530000
+#define MX25_NFC_SIZE			SZ_8K
+
+/*!
+ * This macro defines the physical to virtual address mapping for all the
+ * peripheral modules. It is used by passing in the physical address as x
+ * and returning the virtual address. If the physical address is not mapped,
+ * it returns 0xDEADBEEF
+ */
+#define IO_ADDRESS(x)   \
+	(void __force __iomem *) \
+	(((x >= MX25_AIPS1_BASE_ADDR) && (x < (MX25_AIPS1_BASE_ADDR + \
+		MX25_AIPS1_SIZE))) ? AIPS1_IO_ADDRESS(x) : \
+	((x >= MX25_SPBA0_BASE_ADDR) && (x < (MX25_SPBA0_BASE_ADDR + \
+		MX25_SPBA0_SIZE))) ? SPBA0_IO_ADDRESS(x) : \
+	((x >= MX25_AIPS2_BASE_ADDR) && (x < (MX25_AIPS2_BASE_ADDR + \
+		MX25_AIPS2_SIZE))) ? AIPS2_IO_ADDRESS(x) : \
+	((x >= MX25_ROMP_BASE_ADDR) && (x < (MX25_ROMP_BASE_ADDR + \
+		MX25_ROMP_SIZE))) ? ROMP_IO_ADDRESS(x) : \
+	((x >= MX25_ASIC_BASE_ADDR) && (x < (MX25_ASIC_BASE_ADDR + \
+		MX25_AVIC_SIZE))) ? ASIC_IO_ADDRESS(x) : \
+	((x >= MX25_IRAM_BASE_ADDR) && (x < (MX25_IRAM_BASE_ADDR + \
+		MX25_IRAM_SIZE))) ? IRAM_IO_ADDRESS(x) : \
+	((x >= MX25_X_MEMC_BASE_ADDR) && (x < (MX25_X_MEMC_BASE_ADDR + \
+		MX25_X_MEMC_SIZE))) ? X_MEMC_IO_ADDRESS(x) : \
+	((x >= MX25_NFC_BASE_ADDR) && (x < (MX25_NFC_BASE_ADDR + \
+		MX25_NFC_SIZE))) ? NFC_IO_ADDRESS(x) : \
+	0xDEADBEEF)
+
+#define MX25_IO_ADDRESS(x) IO_ADDRESS(x)
+
+/*
+ * define the address mapping macros: in physical address order
+ */
+
+#define AIPS1_IO_ADDRESS(x)  \
+	(((x) - MX25_AIPS1_BASE_ADDR) + MX25_AIPS1_BASE_ADDR_VIRT)
+
+#define SPBA0_IO_ADDRESS(x)  \
+	(((x) - MX25_SPBA0_BASE_ADDR) + MX25_SPBA0_BASE_ADDR_VIRT)
+
+#define AIPS2_IO_ADDRESS(x)  \
+	(((x) - MX25_AIPS2_BASE_ADDR) + MX25_AIPS2_BASE_ADDR_VIRT)
+
+#define ROMP_IO_ADDRESS(x)  \
+	(((x) - MX25_ROMP_BASE_ADDR) + MX25_ROMP_BASE_ADDR_VIRT)
+
+#define ASIC_IO_ADDRESS(x)  \
+	(((x) - MX25_ASIC_BASE_ADDR) + MX25_ASIC_BASE_ADDR_VIRT)
 
-#define MX25_INT_DRYICE	25
-#define MX25_INT_FEC	57
-#define MX25_INT_NANDFC	33
-#define MX25_INT_LCDC	39
+/* for entry-macro.S */
+#define AVIC_IO_ADDRESS(x)	MX25_ASIC_IO_ADDRESS(x)
+
+#define IRAM_IO_ADDRESS(x)  \
+	(((x) - MX25_IRAM_BASE_ADDR) + MX25_IRAM_BASE_ADDR_VIRT)
+
+#define X_MEMC_IO_ADDRESS(x)  \
+	(((x) - MX25_X_MEMC_BASE_ADDR) + MX25_X_MEMC_BASE_ADDR_VIRT)
+
+#define NFC_IO_ADDRESS(x)  \
+	(((x) - MX25_NFC_BASE_ADDR) + MX25_NFC_BASE_ADDR_VIRT)
+
+/*
+ *  Interrupt numbers
+ */
+
+#define MX25_INT_CSPI3		0
+#define MX25_INT_GPT4		1
+#define MX25_INT_OWIRE		2
+#define MX25_INT_I2C		3
+#define MX25_INT_I2C2		4
+#define MX25_INT_UART4		5
+#define MX25_INT_RTIC		6
+#define MX25_INT_ESAI		7
+#define MX25_INT_SDHC2		8
+#define MX25_INT_SDHC1		9
+#define MX25_INT_I2C3		10
+#define MX25_INT_SSI2		11
+#define MX25_INT_SSI1		12
+#define MX25_INT_CSPI2		13
+#define MX25_INT_CSPI1		14
+#define MX25_INT_ATA		15
+#define MX25_INT_GPIO3		16
+#define MX25_INT_CSI		17
+#define MX25_INT_UART3		18
+#define MX25_INT_IIM		19
+#define MX25_INT_SIM1		20
+#define MX25_INT_SIM2		21
+#define MX25_INT_RNG		22
+#define MX25_INT_GPIO4		23
+#define MX25_INT_KPP		24
+#define MX25_INT_DRYICE		25
+#define MX25_INT_PWM		26
+#define MX25_INT_EPIT2		27
+#define MX25_INT_EPIT1		28
+#define MX25_INT_GPT3		29
+#define MX25_INT_POWER_FAIL	30
+#define MX25_INT_CRM		31
+#define MX25_INT_UART2		32
+#define MX25_INT_NANDFC		33
+#define MX25_INT_SDMA		34
+#define MX25_INT_USB_HTG	35
+#define MX25_INT_PWM2		36
+#define MX25_INT_USB_OTG	37
+#define MX25_INT_SLCDC		38
+#define MX25_INT_LCDC		39
+#define MX25_INT_UART5		40
+#define MX25_INT_PWM3		41
+#define MX25_INT_PWM4		42
+#define MX25_INT_CAN1		43
+#define MX25_INT_CAN2		44
+#define MX25_INT_UART1		45
+#define MX25_INT_TSC		46
+#define MX25_INT_ECT		48
+#define MX25_INT_SCC_SCM	49
+#define MX25_INT_SCC_SMN	50
+#define MX25_INT_GPIO2		51
+#define MX25_INT_GPIO1		52
+#define MX25_INT_GPT2		53
+#define MX25_INT_GPT1		54
+#define MX25_INT_WDOG		55
+#define MX25_INT_DRYICE_SEC	56
+#define MX25_INT_FEC		57
+#define MX25_INT_EXT_INT5	58
+#define MX25_INT_EXT_INT4	59
+#define MX25_INT_EXT_INT3	60
+#define MX25_INT_EXT_INT2	61
+#define MX25_INT_EXT_INT1	62
+#define MX25_INT_EXT_INT0	63
+
+#define MXC_TIMER_GPT1          1
+#define MXC_TIMER_GPT2          2
+#define MXC_TIMER_GPT3          3
+#define MXC_TIMER_GPT4          4
+
+/*!
+ * Defines for modules using static and dynamic DMA channels
+ */
+#define MXC_DMA_CHANNEL_IRAM		30
+#define MXC_DMA_CHANNEL_UART1_RX     MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART1_TX     MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART2_RX     MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART2_TX     MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART3_RX     MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART3_TX     MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART4_RX     MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART4_TX     MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART5_RX     MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART5_TX     MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_MMC1         MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI1_RX      MXC_DMA_DYNAMIC_CHANNEL
+#ifdef CONFIG_SDMA_IRAM
+#define MXC_DMA_CHANNEL_SSI1_TX      (MXC_DMA_CHANNEL_IRAM + 1)
+#else
+#define MXC_DMA_CHANNEL_SSI1_TX      MXC_DMA_DYNAMIC_CHANNEL
+#endif
+#define MXC_DMA_CHANNEL_SSI2_RX      MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI2_TX      MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI1_RX     MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI1_TX     MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI2_RX     MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI2_TX     MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI3_RX     MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI3_TX     MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ATA_RX       MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ATA_TX       MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_MEMORY       MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ESAI_RX      MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ESAI_TX      MXC_DMA_DYNAMIC_CHANNEL
+
+/*
+ * DMA request assignments
+ */
+#define DMA_REQ_EXTREQ0		0
+#define DMA_REQ_CCM		1
+#define DMA_REQ_ATA_TX_END	2
+#define DMA_REQ_ATA_TX		3
+#define DMA_REQ_ATA_RX		4
+#define DMA_REQ_CSPI2_RX	6
+#define DMA_REQ_CSPI2_TX	7
+#define DMA_REQ_CSPI1_RX	8
+#define DMA_REQ_CSPI1_TX	9
+#define DMA_REQ_UART3_RX	10
+#define DMA_REQ_UART3_TX	11
+#define DMA_REQ_UART4_RX	12
+#define DMA_REQ_UART4_TX	13
+#define DMA_REQ_EXTREQ1		14
+#define DMA_REQ_EXTREQ2		15
+#define DMA_REQ_UART2_RX	16
+#define DMA_REQ_UART2_TX	17
+#define DMA_REQ_UART1_RX	18
+#define DMA_REQ_UART1_TX	19
+#define DMA_REQ_SSI2_RX1	22
+#define DMA_REQ_SSI2_TX1	23
+#define DMA_REQ_SSI2_RX0	24
+#define DMA_REQ_SSI2_TX0	25
+#define DMA_REQ_SSI1_RX1	26
+#define DMA_REQ_SSI1_TX1	27
+#define DMA_REQ_SSI1_RX0	28
+#define DMA_REQ_SSI1_TX0	29
+#define DMA_REQ_NFC		30
+#define DMA_REQ_ECT		31
+#define DMA_REQ_ESAI_RX		32
+#define DMA_REQ_ESAI_TX		33
+#define DMA_REQ_CSPI3_RX	34
+#define DMA_REQ_CSPI3_TX	35
+#define DMA_REQ_SIM2_RX		36
+#define DMA_REQ_SIM2_TX		37
+#define DMA_REQ_SIM1_RX		38
+#define DMA_REQ_SIM1_TX		39
+#define DMA_REQ_TSC_GCQ		44
+#define DMA_REQ_TSC_TCQ		45
+#define DMA_REQ_UART5_RX	46
+#define DMA_REQ_UART5_TX	47
+
+#define IS_MEM_DEVICE_NONSHARED(x)	0
+
+/*!
+ * NFMS bit in RCSR register for pagesize of nandflash
+ */
+#define	NFMS	(*((volatile u32 *)IO_ADDRESS(MX25_CCM_BASE_ADDR + 0x28)))
+#define NFMS_NF_DWIDTH		14
+#define NFMS_NF_PG_SZ		8
 
 #if defined(IMX_NEEDS_DEPRECATED_SYMBOLS)
-#define UART1_BASE_ADDR			MX25_UART1_BASE_ADDR
-#define UART2_BASE_ADDR			MX25_UART2_BASE_ADDR
+#define UART1_BASE_ADDR		MX25_UART1_BASE_ADDR
+#define UART2_BASE_ADDR		MX25_UART2_BASE_ADDR
+#endif
+
+
+#define NFC_BASE_ADDR		MX25_NFC_BASE_ADDR
+#define OTG_BASE_ADDR		MX25_USBOTG_BASE_ADDR
+#define MX25_SRTC_BASE_ADDR	MX25_DRYICE_BASE_ADDR
+#define DRYICE_BASE_ADDR	MX25_DRYICE_BASE_ADDR
+#define LCDC_BASE_ADDR		MX25_LCDC_BASE_ADDR
+#define CSI_BASE_ADDR		MX25_CSI_BASE_ADDR
+#define AUDMUX_BASE_ADDR	MX25_AUDMUX_BASE_ADDR
+#define SDMA_BASE_ADDR		MX25_SDMA_BASE_ADDR
+#define SCC_BASE_ADDR		MX25_SCC_BASE_ADDR
+#define RNGB_BASE_ADDR		MX25_RNGB_BASE_ADDR
+#define SSI1_BASE_ADDR		MX25_SSI1_BASE_ADDR
+#define SSI2_BASE_ADDR		MX25_SSI2_BASE_ADDR
+#define ESAI_BASE_ADDR		MX25_ESAI_BASE_ADDR
+#define KPP_BASE_ADDR		MX25_KPP_BASE_ADDR
+
+#define MXC_INT_ESAI		MX25_INT_ESAI
+#define MXC_INT_SCC_SCM		MX25_INT_SCC_SCM
+#define MXC_INT_SCC_SMN		MX25_INT_SCC_SMN
+#define MXC_INT_DRYICE_NORM	MX25_INT_DRYICE
+#define MXC_INT_DRYICE_SEC	MX25_INT_DRYICE_SEC
+#define MXC_INT_RNG		MX25_INT_RNG
+#define MXC_INT_USB_OTG		MX25_INT_USB_OTG
+#define MXC_INT_LCDC		MX25_INT_LCDC
+#define MXC_INT_GPT		MX25_INT_GPT1
+#define MXC_INT_CSI		MX25_INT_CSI
+#define MXC_INT_SDMA		MX25_INT_SDMA
+#define	MXC_INT_NANDFC		MX25_INT_NANDFC
+#define MXC_INT_SSI1		MX25_INT_SSI1
+#define MXC_INT_SSI2		MX25_INT_SSI2
+#define MXC_INT_KPP		MX25_INT_KPP
+
+/*!
+ * IIM Bank info
+ **/
+#define MXC_IIM_BANK_START_ADDR	0x0000
+#define MXC_IIM_BANK_END_ADDR	0x007c
+
+/*
+ * RAM info
+ */
+#ifndef CONFIG_SDMA_IRAM
+#define CONFIG_SDMA_IRAM_SIZE	0
+#endif
+
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+#define SND_RAM_SIZE	0x10000
+#else
+#define SND_RAM_SIZE	0
+#endif
+
+#define SND_RAM_BASE_ADDR	(IRAM_BASE_ADDR + CONFIG_SDMA_IRAM_SIZE)
+#define USB_IRAM_BASE_ADDR	(SND_RAM_BASE_ADDR + SND_RAM_SIZE)
+
+#ifdef CONFIG_USB_STATIC_IRAM_PPH
+#define USB_IRAM_SIZE		(2 * SZ_8K)
+#else
+#define USB_IRAM_SIZE		0
 #endif
 
+/*!
+ * defines for SPBA modules
+ */
+#define SPBA_CSPI3	(0x1 << 2)
+#define SPBA_UART4	(0x2 << 2)
+#define SPBA_UART3	(0x3 << 2)
+#define SPBA_CSPI2	(0x4 << 2)
+#define SPBA_SSI2	(0x5 << 2)
+#define SPBA_ESAI	(0x6 << 2)
+#define SPBA_ATA	(0x8 << 2)
+#define SPBA_SIM1	(0x9 << 2)
+#define SPBA_SIM2	(0xA << 2)
+#define SPBA_UART5	(0xB << 2)
+#define SPBA_ANALOG	(0xC << 2)
+#define SPBA_SSI1	(0xD << 2)
+#define SPBA_FEC	(0xE << 2)
+
+#if !defined(__ASSEMBLY__) && !defined(__MXC_BOOT_UNCOMPRESS)
+extern void mx25_arch_idle(void);
+#endif
 #endif /* ifndef __MACH_MX25_H__ */
diff --git a/arch/arm/plat-mxc/include/mach/mxc.h b/arch/arm/plat-mxc/include/mach/mxc.h
index af840dc..f42f558 100644
--- a/arch/arm/plat-mxc/include/mach/mxc.h
+++ b/arch/arm/plat-mxc/include/mach/mxc.h
@@ -380,6 +380,41 @@ struct mxc_fm_platform_data {
 	u8	seekth;
 };
 
+struct flexcan_platform_data {
+	char *core_reg;
+	char *io_reg;
+	char *root_clk_id;
+	void (*xcvr_enable) (int id, int en);
+	void (*active) (int id);
+	void (*inactive) (int id);
+	/* word 1 */
+	unsigned int br_presdiv:8;
+	unsigned int br_rjw:2;
+	unsigned int br_propseg:3;
+	unsigned int br_pseg1:3;
+	unsigned int br_pseg2:3;
+	unsigned int maxmb:6;
+	unsigned int xmit_maxmb:6;
+	unsigned int wd1_resv:1;
+
+	/* word 2 */
+	unsigned int fifo:1;
+	unsigned int wakeup:1;
+	unsigned int srx_dis:1;
+	unsigned int wak_src:1;
+	unsigned int bcc:1;
+	unsigned int lprio:1;
+	unsigned int abort:1;
+	unsigned int br_clksrc:1;
+	unsigned int loopback:1;
+	unsigned int smp:1;
+	unsigned int boff_rec:1;
+	unsigned int tsyn:1;
+	unsigned int listen:1;
+	unsigned int ext_msg:1;
+	unsigned int std_msg:1;
+};
+
 struct mxc_mma7450_platform_data {
 	char *reg_dvdd_io;
 	char *reg_avdd;
@@ -425,14 +460,6 @@ struct mxc_mlb_platform_data {
 	char *mlb_clk;
 };
 
-struct flexcan_platform_data {
-	char *core_reg;
-	char *io_reg;
-	void (*xcvr_enable) (int id, int en);
-	void (*active) (int id);
-	void (*inactive) (int id);
-};
-
 struct mxc_srtc_platform_data {
 	u32 srtc_sec_mode_addr;
 };
@@ -442,11 +469,18 @@ struct tve_platform_data {
 	char *dig_reg;
 };
 
+#ifndef CONFIG_ARCH_MX25
 struct fec_platform_data {
 	int (*init) (void);
 	int (*uninit) (void);
 	struct regulator *vddio_reg;
 };
+#endif
+
+struct mxc_esai_platform_data {
+	void (*activate_esai_ports) (void);
+	void (*deactivate_esai_ports) (void);
+};
 
 /* The name that links the i.MX NAND Flash Controller driver to its devices. */
 
diff --git a/arch/arm/plat-mxc/include/mach/system.h b/arch/arm/plat-mxc/include/mach/system.h
index bb9ccf8..8bccf8f 100644
--- a/arch/arm/plat-mxc/include/mach/system.h
+++ b/arch/arm/plat-mxc/include/mach/system.h
@@ -34,8 +34,10 @@ static inline void arch_idle(void)
 #endif
 #ifdef CONFIG_ARCH_MX51
 	mx51_arch_idle();
-#elif CONFIG_ARCH_MX31
+#elif defined(CONFIG_ARCH_MX31)
 	mx31_arch_idle();
+#elif defined(CONFIG_ARCH_MX25)
+	mx25_arch_idle();
 #else
 	cpu_do_idle();
 #endif
diff --git a/arch/arm/plat-mxc/include/mach/timex.h b/arch/arm/plat-mxc/include/mach/timex.h
index 024416e..e88fbd0 100644
--- a/arch/arm/plat-mxc/include/mach/timex.h
+++ b/arch/arm/plat-mxc/include/mach/timex.h
@@ -27,7 +27,7 @@
 #elif defined CONFIG_ARCH_MX3
 #define CLOCK_TICK_RATE		16625000
 #elif defined CONFIG_ARCH_MX25
-#define CLOCK_TICK_RATE		16000000
+#define CLOCK_TICK_RATE		13300000
 #elif defined CONFIG_ARCH_MX5
 #define CLOCK_TICK_RATE		8000000
 #elif defined CONFIG_ARCH_MXC91231
diff --git a/arch/arm/plat-mxc/include/mach/usb.h b/arch/arm/plat-mxc/include/mach/usb.h
index be27337..f8f9bfb 100644
--- a/arch/arm/plat-mxc/include/mach/usb.h
+++ b/arch/arm/plat-mxc/include/mach/usb.h
@@ -20,4 +20,95 @@ struct imxusb_platform_data {
 	void (*exit)(struct device *);
 };
 
+extern int usbotg_init(struct platform_device *pdev);
+extern void usbotg_uninit(struct fsl_usb2_platform_data *pdata);
+extern int gpio_usbotg_utmi_active(void);
+extern void gpio_usbotg_utmi_inactive(void);
+extern struct platform_device *host_pdev_register(struct resource *res,
+						  int n_res,
+						  struct fsl_usb2_platform_data
+						  *config);
+
+extern int fsl_usb_host_init(struct platform_device *pdev);
+extern void fsl_usb_host_uninit(struct fsl_usb2_platform_data *pdata);
+extern int gpio_usbh2_active(void);
+extern void gpio_usbh2_inactive(void);
+
+/*
+ * Determine which platform_data struct to use for the DR controller,
+ * based on which transceiver is configured.
+ * PDATA is a pointer to it.
+ */
+#if defined(CONFIG_UTMI_MXC)
+static struct fsl_usb2_platform_data __maybe_unused dr_utmi_config;
+#define PDATA (&dr_utmi_config)
+#endif
+/*
+ * Used to set pdata->operating_mode before registering the platform_device.
+ * If OTG is configured, the controller operates in OTG mode,
+ * otherwise it's either host or device.
+ */
+#ifdef CONFIG_USB_OTG
+#define DR_UDC_MODE	FSL_USB2_DR_OTG
+#define DR_HOST_MODE	FSL_USB2_DR_OTG
+#else
+#define DR_UDC_MODE	FSL_USB2_DR_DEVICE
+#define DR_HOST_MODE	FSL_USB2_DR_HOST
+#endif
+
+#ifdef CONFIG_USB_EHCI_ARC_OTG
+static inline void dr_register_host(struct resource *r, int rs)
+{
+	PDATA->operating_mode = DR_HOST_MODE;
+	host_pdev_register(r, rs, PDATA);
+}
+#else
+static inline void dr_register_host(struct resource *r, int rs)
+{
+}
+#endif
+
+#ifdef CONFIG_USB_GADGET_ARC
+static struct platform_device dr_udc_device;
+
+static inline void dr_register_udc(void)
+{
+	PDATA->operating_mode = DR_UDC_MODE;
+	dr_udc_device.dev.platform_data = PDATA;
+
+	if (platform_device_register(&dr_udc_device))
+		printk(KERN_ERR "usb: can't register DR gadget\n");
+	else
+		printk(KERN_INFO "usb: DR gadget (%s) registered\n",
+		       PDATA->transceiver);
+}
+#else
+static inline void dr_register_udc(void)
+{
+}
+#endif
+
+#ifdef CONFIG_USB_OTG
+static struct platform_device dr_otg_device;
+
+/*
+ * set the proper operating_mode and
+ * platform_data pointer, then register the
+ * device.
+ */
+static inline void dr_register_otg(void)
+{
+	PDATA->operating_mode = FSL_USB2_DR_OTG;
+	dr_otg_device.dev.platform_data = PDATA;
+
+	if (platform_device_register(&dr_otg_device))
+		printk(KERN_ERR "usb: can't register otg device\n");
+	else
+		printk(KERN_INFO "usb: DR OTG registered\n");
+}
+#else
+static inline void dr_register_otg(void)
+{
+}
+#endif
 #endif /* __ASM_ARCH_MXC_USB */
-- 
1.7.0.4

