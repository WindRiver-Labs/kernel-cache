From 95ab34c1e2a7f093a36b2202b714549ed36deff2 Mon Sep 17 00:00:00 2001
From: xianchao Zhang <xianchao.zhang@windriver.com>
Date: Tue, 19 Jan 2010 20:32:01 +0800
Subject: [PATCH 2/2] ipmi: fix a deadlock caused by triggering kernel panic

The kernel panic event trigger an execution path which cause a deadlock
when accessing the critical region. once a deadlock arise the callback
function wdog_reboot_handler() could not be executed.

To avoid deadlock, take the lock and disable interrupt before calling
smi_event_handler() in the panic_event execution path, since the function
should be called with si_lock held.

Signed-off-by: xianchao Zhang <xianchao.zhang@windriver.com>
---
 drivers/char/ipmi/ipmi_si_intf.c |   11 ++++++++++-
 1 files changed, 10 insertions(+), 1 deletions(-)

diff --git a/drivers/char/ipmi/ipmi_si_intf.c b/drivers/char/ipmi/ipmi_si_intf.c
index 7e860da..1c1bb32 100644
--- a/drivers/char/ipmi/ipmi_si_intf.c
+++ b/drivers/char/ipmi/ipmi_si_intf.c
@@ -888,12 +888,16 @@ static void sender(void                *send_info,
 		 * need for locks.
 		 */
 		list_add_tail(&(msg->link), &(smi_info->xmit_msgs));
-
+		spin_lock_irqsave(&smi_info->si_lock, flags);
 		result = smi_event_handler(smi_info, 0);
+		spin_unlock_irqrestore(&smi_info->si_lock, flags);
+
 		while (result != SI_SM_IDLE) {
 			udelay(SI_SHORT_TIMEOUT_USEC);
+			spin_lock_irqsave(&smi_info->si_lock, flags);
 			result = smi_event_handler(smi_info,
 						   SI_SHORT_TIMEOUT_USEC);
+			spin_unlock_irqrestore(&smi_info->si_lock, flags);
 		}
 		return;
 	}
@@ -915,14 +919,19 @@ static void set_run_to_completion(void *send_info, int i_run_to_completion)
 {
 	struct smi_info   *smi_info = send_info;
 	enum si_sm_result result;
+	unsigned long     flags;
 
 	smi_info->run_to_completion = i_run_to_completion;
 	if (i_run_to_completion) {
+		spin_lock_irqsave(&smi_info->si_lock, flags);
 		result = smi_event_handler(smi_info, 0);
+		spin_unlock_irqrestore(&smi_info->si_lock, flags);
 		while (result != SI_SM_IDLE) {
 			udelay(SI_SHORT_TIMEOUT_USEC);
+			spin_lock_irqsave(&smi_info->si_lock, flags);
 			result = smi_event_handler(smi_info,
 						   SI_SHORT_TIMEOUT_USEC);
+			spin_unlock_irqrestore(&smi_info->si_lock, flags);
 		}
 	}
 }
-- 
1.6.5.2

