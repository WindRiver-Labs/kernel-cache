From 21f4de5be7c1293b84d6347569affaadf828bced Mon Sep 17 00:00:00 2001
From: xianchao Zhang <xianchao.zhang@windriver.com>
Date: Thu, 7 Jan 2010 19:54:44 +0800
Subject: [PATCH 1/2] bnx2x: Check loaded driver and reset device

The capture kernel(kdump kernel) loads NIC device driver after bypassing
BOIS. During the driver's initialization, it checks if there is any active
driver, if so then resets the chip, the capture kernel set CID offset for
normal bell to 0x3, which means one driver has been loaded.

Moreover, the capture kernel reserved the state of MCP's to
'FW_MSG_CODE_DRV_LOAD_DONE' before sending command 'DRV_MSG_CODE_LOAD_REQ',
which disturbed the normal procedure. Some initializatios were missed. So
the chip should be reseted.

Signed-off-by: xianchao Zhang <xianchao.zhang@windriver.com>
---
 drivers/net/bnx2x_main.c |   85 ++++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 85 insertions(+), 0 deletions(-)

diff --git a/drivers/net/bnx2x_main.c b/drivers/net/bnx2x_main.c
index 8d44404..803ad5a 100644
--- a/drivers/net/bnx2x_main.c
+++ b/drivers/net/bnx2x_main.c
@@ -6933,6 +6933,86 @@ static void __devinit bnx2x_undi_unload(struct bnx2x *bp)
 	}
 }
 
+static void __devinit bnx2x_fw_reset(struct bnx2x *bp)
+{
+	u32 reset_code = DRV_MSG_CODE_UNLOAD_REQ_WOL_DIS;
+
+	/* save our func */
+	int func = BP_FUNC(bp);
+	u32 swap_en;
+	u32 swap_val;
+
+	BNX2X_DEV_INFO("Other driver is active! reset device\n");
+
+	/* try unload driver on port 0 */
+	bp->func = 0;
+	bp->fw_seq =
+	       (SHMEM_RD(bp, func_mb[bp->func].drv_mb_header) &
+		DRV_MSG_SEQ_NUMBER_MASK);
+	reset_code = bnx2x_fw_command(bp, reset_code);
+
+	/* if the driver is loaded on the other port */
+	if (reset_code != FW_MSG_CODE_DRV_UNLOAD_COMMON) {
+
+		/* send "DONE" for previous unload */
+		bnx2x_fw_command(bp, DRV_MSG_CODE_UNLOAD_DONE);
+
+		/* unload the driver on port 1 */
+		bp->func = 1;
+		bp->fw_seq =
+		       (SHMEM_RD(bp, func_mb[bp->func].drv_mb_header) &
+			DRV_MSG_SEQ_NUMBER_MASK);
+		reset_code = DRV_MSG_CODE_UNLOAD_REQ_WOL_DIS;
+
+		bnx2x_fw_command(bp, reset_code);
+	}
+
+	REG_WR(bp, (BP_PORT(bp) ? HC_REG_CONFIG_1 :
+		    HC_REG_CONFIG_0), 0x1000);
+
+	/* close input traffic and wait for it */
+	/* Do not rcv packets to BRB */
+	REG_WR(bp,
+		(BP_PORT(bp) ? NIG_REG_LLH1_BRB1_DRV_MASK :
+			     NIG_REG_LLH0_BRB1_DRV_MASK), 0x0);
+	/* Do not direct rcv packets that are not for MCP to
+	 * the BRB */
+	REG_WR(bp,
+	      (BP_PORT(bp) ? NIG_REG_LLH1_BRB1_NOT_MCP :
+			  NIG_REG_LLH0_BRB1_NOT_MCP), 0x0);
+	/* clear AEU */
+	REG_WR(bp,
+		(BP_PORT(bp) ? MISC_REG_AEU_MASK_ATTN_FUNC_1 :
+			MISC_REG_AEU_MASK_ATTN_FUNC_0), 0);
+	msleep(10);
+
+	/* save NIG port swap info */
+	swap_val = REG_RD(bp, NIG_REG_PORT_SWAP);
+	swap_en = REG_RD(bp, NIG_REG_STRAP_OVERRIDE);
+	/* reset device */
+	REG_WR(bp,
+	       GRCBASE_MISC + MISC_REGISTERS_RESET_REG_1_CLEAR,
+	       0xd3ffffff);
+	REG_WR(bp,
+	       GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_CLEAR,
+	       0x1403);
+	/* take the NIG out of reset and restore swap values */
+	REG_WR(bp,
+	       GRCBASE_MISC + MISC_REGISTERS_RESET_REG_1_SET,
+	       MISC_REGISTERS_RESET_REG_1_RST_NIG);
+	REG_WR(bp, NIG_REG_PORT_SWAP, swap_val);
+	REG_WR(bp, NIG_REG_STRAP_OVERRIDE, swap_en);
+
+	/* send unload done to the MCP */
+	bnx2x_fw_command(bp, DRV_MSG_CODE_UNLOAD_DONE);
+
+	/* restore our func and fw_seq */
+	bp->func = func;
+	bp->fw_seq =
+	       (SHMEM_RD(bp, func_mb[bp->func].drv_mb_header) &
+		DRV_MSG_SEQ_NUMBER_MASK);
+}
+
 static void __devinit bnx2x_get_common_hwinfo(struct bnx2x *bp)
 {
 	u32 val, val2, val3, val4, id;
@@ -7512,6 +7592,11 @@ static int __devinit bnx2x_init_bp(struct bnx2x *bp)
 	if (!BP_NOMCP(bp))
 		bnx2x_undi_unload(bp);
 
+	/* check if there is any other loaded driver */
+	if (0x1 == REG_RD(bp, MISC_REG_UNPREPARED))
+		if (0x7 != REG_RD(bp, MISC_REG_UNPREPARED))
+			bnx2x_fw_reset(bp);
+
 	if (CHIP_REV_IS_FPGA(bp))
 		printk(KERN_ERR PFX "FPGA detected\n");
 
-- 
1.6.5.2

