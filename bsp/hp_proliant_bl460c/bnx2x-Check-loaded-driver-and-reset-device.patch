From fbfecb916ec4972eae7842211cdf0e48ec8bef7f Mon Sep 17 00:00:00 2001
From: xianchao Zhang <xianchao.zhang@windriver.com>
Date: Tue, 13 Apr 2010 18:06:18 +0800
Subject: [PATCH 1/2] bnx2x-Check-loaded-driver-and-reset-device

The capture kernel(kdump kernel) loads NIC device driver after bypassing
BOIS. During the driver's initialization, it checks if there is any active
driver, if so then resets the chip, the capture kernel set CID offset for
normal bell to 0x3, which means one driver has been loaded.

Moreover, the capture kernel reserved the state of MCP's to
'FW_MSG_CODE_DRV_LOAD_DONE' before sending command 'DRV_MSG_CODE_LOAD_REQ',
which disturbed the normal procedure. Some initializatios were missed. So
the chip should be reseted.
---
 drivers/net/bnx2x_main.c |   85 ++++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 85 insertions(+), 0 deletions(-)

diff --git a/drivers/net/bnx2x_main.c b/drivers/net/bnx2x_main.c
index 6c042a7..0517126 100644
--- a/drivers/net/bnx2x_main.c
+++ b/drivers/net/bnx2x_main.c
@@ -8215,6 +8215,86 @@ static void __devinit bnx2x_undi_unload(struct bnx2x *bp)
 	}
 }
 
+static void __devinit bnx2x_fw_reset(struct bnx2x *bp)
+{
+	u32 reset_code = DRV_MSG_CODE_UNLOAD_REQ_WOL_DIS;
+
+	/* save our func */
+	int func = BP_FUNC(bp);
+	u32 swap_en;
+	u32 swap_val;
+
+	BNX2X_DEV_INFO("Other driver is active! reset device\n");
+
+	/* try unload driver on port 0 */
+	bp->func = 0;
+	bp->fw_seq =
+	       (SHMEM_RD(bp, func_mb[bp->func].drv_mb_header) &
+		DRV_MSG_SEQ_NUMBER_MASK);
+	reset_code = bnx2x_fw_command(bp, reset_code);
+
+	/* if the driver is loaded on the other port */
+	if (reset_code != FW_MSG_CODE_DRV_UNLOAD_COMMON) {
+
+		/* send "DONE" for previous unload */
+		bnx2x_fw_command(bp, DRV_MSG_CODE_UNLOAD_DONE);
+
+		/* unload the driver on port 1 */
+		bp->func = 1;
+		bp->fw_seq =
+		       (SHMEM_RD(bp, func_mb[bp->func].drv_mb_header) &
+			DRV_MSG_SEQ_NUMBER_MASK);
+		reset_code = DRV_MSG_CODE_UNLOAD_REQ_WOL_DIS;
+
+		bnx2x_fw_command(bp, reset_code);
+	}
+
+	REG_WR(bp, (BP_PORT(bp) ? HC_REG_CONFIG_1 :
+		    HC_REG_CONFIG_0), 0x1000);
+
+	/* close input traffic and wait for it */
+	/* Do not rcv packets to BRB */
+	REG_WR(bp,
+		(BP_PORT(bp) ? NIG_REG_LLH1_BRB1_DRV_MASK :
+			     NIG_REG_LLH0_BRB1_DRV_MASK), 0x0);
+	/* Do not direct rcv packets that are not for MCP to
+	 * the BRB */
+	REG_WR(bp,
+	      (BP_PORT(bp) ? NIG_REG_LLH1_BRB1_NOT_MCP :
+			  NIG_REG_LLH0_BRB1_NOT_MCP), 0x0);
+	/* clear AEU */
+	REG_WR(bp,
+		(BP_PORT(bp) ? MISC_REG_AEU_MASK_ATTN_FUNC_1 :
+			MISC_REG_AEU_MASK_ATTN_FUNC_0), 0);
+	msleep(10);
+
+	/* save NIG port swap info */
+	swap_val = REG_RD(bp, NIG_REG_PORT_SWAP);
+	swap_en = REG_RD(bp, NIG_REG_STRAP_OVERRIDE);
+	/* reset device */
+	REG_WR(bp,
+	       GRCBASE_MISC + MISC_REGISTERS_RESET_REG_1_CLEAR,
+	       0xd3ffffff);
+	REG_WR(bp,
+	       GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_CLEAR,
+	       0x1403);
+	/* take the NIG out of reset and restore swap values */
+	REG_WR(bp,
+	       GRCBASE_MISC + MISC_REGISTERS_RESET_REG_1_SET,
+	       MISC_REGISTERS_RESET_REG_1_RST_NIG);
+	REG_WR(bp, NIG_REG_PORT_SWAP, swap_val);
+	REG_WR(bp, NIG_REG_STRAP_OVERRIDE, swap_en);
+
+	/* send unload done to the MCP */
+	bnx2x_fw_command(bp, DRV_MSG_CODE_UNLOAD_DONE);
+
+	/* restore our func and fw_seq */
+	bp->func = func;
+	bp->fw_seq =
+	       (SHMEM_RD(bp, func_mb[bp->func].drv_mb_header) &
+		DRV_MSG_SEQ_NUMBER_MASK);
+}
+
 static void __devinit bnx2x_get_common_hwinfo(struct bnx2x *bp)
 {
 	u32 val, val2, val3, val4, id;
@@ -8920,6 +9000,11 @@ static int __devinit bnx2x_init_bp(struct bnx2x *bp)
 	if (!BP_NOMCP(bp))
 		bnx2x_undi_unload(bp);
 
+	/* check if there is any other loaded driver */
+	if (0x1 == REG_RD(bp, MISC_REG_UNPREPARED))
+		if (0x7 != REG_RD(bp, MISC_REG_UNPREPARED))
+			bnx2x_fw_reset(bp);
+
 	if (CHIP_REV_IS_FPGA(bp))
 		pr_err("FPGA detected\n");
 
-- 
1.6.5.2

