From 45ba4760c3815f5753daf500533d4aab31e1cc34 Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Wed, 26 Jun 2013 14:57:17 +0800
Subject: [PATCH 1/7] 82xx: Add basic support for Wind River SBCPQ2 board

This adds basic support for Wind River SBCPQ2 board, implemented
as powerpc.  The implementation is loosely based off of ep8248e
and pq2fads.

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 arch/powerpc/boot/dts/sbcpq2.dts     |  315 ++++++++++++++++++++++++++++++++
 arch/powerpc/platforms/82xx/Kconfig  |   11 ++
 arch/powerpc/platforms/82xx/Makefile |    1 +
 arch/powerpc/platforms/82xx/sbcpq2.c |  326 ++++++++++++++++++++++++++++++++++
 4 files changed, 653 insertions(+), 0 deletions(-)
 create mode 100644 arch/powerpc/boot/dts/sbcpq2.dts
 create mode 100644 arch/powerpc/platforms/82xx/sbcpq2.c

diff --git a/arch/powerpc/boot/dts/sbcpq2.dts b/arch/powerpc/boot/dts/sbcpq2.dts
new file mode 100644
index 0000000..cebe7aa
--- /dev/null
+++ b/arch/powerpc/boot/dts/sbcpq2.dts
@@ -0,0 +1,315 @@
+/*
+ *
+ * sbcpq2.dts, Wind River SBC PowerQUICCII 82xx Device Tree Source
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * By Jeremy McNicoll <jeremy.mcnicoll@windriver.com>
+ *  Inspired by pq2fads and ep8248e.dts - Copyright Freescale 2007.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+/dts-v1/;
+/ {
+	model = "SBCPQ2";
+	compatible = "wind,sbc82xx";
+	#address-cells = <1>;
+	#size-cells = <1>;
+
+	aliases {
+		ethernet0 = &enet0;
+		ethernet1 = &enet1;
+		ethernet2 = &enet2;
+		/* LXT905 support needed */
+		/* ethernet3 = &enet3; */
+		serial0 = &serial0;
+		serial1 = &serial1;
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		PowerPC,8260@0 {
+			device_type = "cpu";
+			reg = <0x0>;
+			d-cache-line-size = <0x20>;	/* 32 bytes */
+			i-cache-line-size = <0x20>;	/* 32 bytes */
+			d-cache-size = <0x4000>;	/* L1, 16K */
+			i-cache-size = <0x4000>;	/* L1, 16K */
+			timebase-frequency = <0x0>;	/* (bus-frequency / 4)*/
+			bus-frequency = <0x0>;		/* bd->bi_busfreq */
+			clock-frequency = <0x0>; /*bd->bi_intfreq=gd->cpu_clk*/
+			32-bit;
+		};
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x0 0x0>;
+	};
+
+	localbus@f0000000 {
+		#address-cells = <2>;
+		#size-cells = <1>;
+		compatible = "fsl,pq2-localbus","simple-bus";
+		reg = <0xf0000000 0x500>;
+
+		ranges = <0x0  0x0 0xffe00000 0x200000 	/* 2MB Flash */
+			0x1  0x0 0xe4000000 0x4000000   /* 64MB Flash */
+			0x4  0x0 0x20000000 0x1000000	/* 16MB LB SDRAM */
+			0x5  0x0 0x22000000 0xc000	/* EPLD */
+			0x6  0x0 0xe0000000 0x4000000	/* 64MB Flash */
+			0x7  0x0 0x21000000 0x2000	/* Control EPLD */
+			0x11 0x0 0x80000000 0x2000>; 	/* RTC */
+
+		boot-flash@0,0 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "amd,29lv160", "cfi-flash";
+			reg = <0x0 0x0 0x200000>;
+			bank-width = <1>;
+			device-width = <1>;
+			partition@0x0 {
+				label = "space";
+				reg = <0x00000000 0x00100000>;
+				read-only;
+			};
+			partition@0x100000 {
+				label = "bootloader";
+				reg = <0x00100000 0x00100000>;
+				read-only;
+			};
+
+		};
+
+		epld@5,0 {
+			compatible = "wrs,epld-localbus";
+			#address-cells = <2>;
+			#size-cells = <1>;
+			reg = <0x5 0x0 0x0000c0000>;
+			ranges = <
+				0x0 0x0	0x5 0x0000 0x2000	/* EEPROM */
+				0x1 0x0 0x5 0x2000 0x2000	/* visionPORT */
+				0x2 0x0 0x5 0x4000 0x2000	/* Switches */
+				0x3 0x0 0x5 0x6000 0x2000	/* Status */
+				0x4 0x0 0x5 0x8000 0x2000	/* i8259 */
+				0x5 0x0 0x5 0xa000 0x2000	/* 7-Segment */
+			>;
+
+			eeprom@0,0 {
+				compatible = "wrs,sbcpq2-eeprom";
+				reg = <0x0 0x0 0x2000>;
+			};
+
+			switches@2,0 {
+				compatible = "wrs,sbcpq2-switches";
+				reg = <0x2 0x0 0x2000>;
+			};
+
+			status@3,0 {
+				compatible = "wrs,sbcpq2-status";
+				reg = <0x3 0x0 0x2000>;
+			};
+
+			intr-cont@4,0 {
+				compatible = "wrs,sbcpq2-i8259";
+				interrupt-parent = <&PIC>;
+				reg = <0x4 0x0 0x2000>;
+			};
+
+			seven-seg@5,0 {
+				compatible = "wrs,sbcpq2-lights";
+				reg = <0x5 0x0 0x2000>;
+			};
+		};
+
+		cntrl-epld@7,0 {
+			compatible = "wrs,sbcpq2-cntrl-epld";
+			reg = <0x7 0x0 0x2000>;
+		};
+
+		rtc@11,0 {
+			compatible = "m48t59";
+			reg = <0x11 0x0 0x2000>;
+		};
+
+	};
+
+	soc@f0000000 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		#interrupt-cells = <2>;
+		device_type = "soc";
+		compatible = "fsl,mpc8248-immr", "fsl,pq2-soc";
+		ranges = <0x00000000 0xf0000000 0x00053000>;
+		reg = <0xf0000000 0x00053000>;
+
+		cpm@0 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			#interrupt-cells = <2>;
+			compatible = "fsl,cpm2", "fsl,mpc8247-cpm";
+			device_type = "cpm";
+			model = "CPM2";
+			ranges;
+			reg = <0x0 0x30>;
+			command-proc = <0>;	/* from u-boot */
+			brg-frequency = <0>;
+
+			muram@0 {
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0x0 0x0 0x10000>;
+
+				data@0 {
+					compatible = "fsl,cpm-muram-data";
+					device_type = "muram";
+					reg = <0x0 0x2000 0x9800 0x800>;
+				};
+			};
+
+			pit@10240 {
+				device_type = "pit";
+				compatible = "fsl,mpc_pit";
+				reg = <0x10240 0x100>;
+				interrupts = <17 8>;
+				interrupt-parent = <&PIC>;
+			};
+
+			brg@119f0 {
+				compatible = "fsl,cpm2-brg",
+						"fsl,cpm-brg";
+				reg = <0x119f0 0x10 0x115f0 0x10>;
+			};
+
+			serial0: smc@11a80 {
+				device_type = "serial";
+				compatible = "fsl,cpm2-smc-uart";
+				reg = <0x11a80 0x10 0x87fc 0x2>;
+				interrupts = <4 8>;
+				fsl,cpm-brg = <1>;
+				fsl,cpm-command = <0x1d000000>;
+				interrupt-parent = <&PIC>;
+			};
+
+			serial1: smc@11a90 {
+				device_type = "serial";
+				compatible = "fsl,cpm2-smc-uart";
+				reg = <0x11a90 0x10 0x88fc 0x2>;
+				interrupts = <5 8>;
+				fsl,cpm-brg = <2>;
+				fsl,cpm-command = <0x00800000>;
+				interrupt-parent = <&PIC>;
+			};
+
+			/*** FCC1 ***/
+			enet0: ethernet@11300 {
+				device_type = "network";
+				compatible = "fsl,cpm2-fcc-enet";
+				model = "FCC";
+				device-id = <1>;
+				reg = <0x11300 0x20 0x8400 0x100 0x11390 1>;
+				local-mac-address = [ 00 00 00 00 00 00 ];
+				interrupts = <32 8>;
+				interrupt-parent = <&PIC>;
+				phy-handle = <&PHY0>;
+				fsl,cpm-command = <0x12000300>;
+			};
+
+			/*** FCC2 ***/
+			enet1: ethernet@11320 {
+				device_type = "network";
+				compatible = "fsl,cpm2-fcc-enet";
+				model = "FCC";
+				device-id = <2>;
+				reg = <0x11320 0x20 0x8500 0x100 0x113b0 1>;
+				local-mac-address = [ 00 00 00 00 00 00 ];
+				interrupts = <33 8>;
+				interrupt-parent = <&PIC>;
+				phy-handle = <&PHY1>;
+				fsl,cpm-command = <0x16200300>;
+			};
+
+			/*** FCC3 ***/
+			enet2: ethernet@11340 {
+				device_type = "network";
+				compatible = "fsl,cpm2-fcc-enet";
+				model = "FCC";
+				device-id = <3>;
+				reg = <0x11340 0x20 0x8600 0x100 0x113e0 1>;
+				local-mac-address = [ 00 00 00 00 00 00 ];
+				interrupts = <34 8>;
+				interrupt-parent = <&PIC>;
+				phy-handle = <&PHY2>;
+				fsl,cpm-command = <0x1a400300>;
+			};
+
+			/*** SCC1 ***/
+			enet3: ethernet@11A00 {
+				device_type = "network";
+				compatible = "fsl,cpm1-scc-enet";
+				model = "SCC";
+				device-id = <4>;
+				reg = <0x11A00 0x20 0x8000 0x100 0x11A90 1>;
+				local-mac-address = [ 00 00 00 00 00 00 ];
+				interrupts = <35 8>;
+				interrupt-parent = <&PIC>;
+				phy-handle = <&PHY3>;
+				fsl,cpm-command = <0x1a400300>;
+			};
+
+			mdio@10d40 {
+				device_type = "mdio";
+				compatible = "fsl,cpm2-mdio-bitbang";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				reg = <0x10d40 0x14>;
+				fsl,mdio-pin = <9>;
+				fsl,mdc-pin = <10>;
+
+				PHY0: ethernet-phy@0 {
+					reg = <0x0>;
+					device_type = "ethernet-phy";
+				};
+
+				PHY1: ethernet-phy@1 {
+					reg = <0x1>;
+					device_type = "ethernet-phy";
+				};
+
+				PHY2: ethernet-phy@2 {
+					reg = <0x2>;
+					device_type = "ethernet-phy";
+				};
+
+				PHY3: ethernet-phy@3 {
+					reg = <0x3>;
+					device_type = "ethernet-phy";
+				};
+
+			};
+
+		};
+
+		PIC: interrupt-controller@10c00 {
+			#interrupt-cells = <2>;
+			interrupt-controller;
+			reg = <0x10c00 0x80>;
+			interrupts = <20 8>;
+			compatible = "fsl,mpc8248-pic", "fsl,pq2-pic";
+		};
+	};
+};
diff --git a/arch/powerpc/platforms/82xx/Kconfig b/arch/powerpc/platforms/82xx/Kconfig
index 7c7df40..5b80695 100644
--- a/arch/powerpc/platforms/82xx/Kconfig
+++ b/arch/powerpc/platforms/82xx/Kconfig
@@ -46,6 +46,17 @@ config MGCOGE
 	help
 	  This enables support for the Keymile MGCOGE board.
 
+config SBCPQ2
+	bool "Wind River SBC PowerQUICCII 82xx"
+	select DEFAULT_UIMAGE
+	select 8260
+	select CPM2
+	select FSL_SOC
+	help
+	  This option enables support for Wind River SBC PowerQUICCII 82xx,
+	  which is a single-board computer with MPC82xx CPU.
+
+
 endif
 
 config PQ2ADS
diff --git a/arch/powerpc/platforms/82xx/Makefile b/arch/powerpc/platforms/82xx/Makefile
index 455fe21..e1f7815 100644
--- a/arch/powerpc/platforms/82xx/Makefile
+++ b/arch/powerpc/platforms/82xx/Makefile
@@ -7,3 +7,4 @@ obj-$(CONFIG_PQ2_ADS_PCI_PIC) += pq2ads-pci-pic.o
 obj-$(CONFIG_PQ2FADS) += pq2fads.o
 obj-$(CONFIG_EP8248E) += ep8248e.o
 obj-$(CONFIG_MGCOGE) += km82xx.o
+obj-$(CONFIG_SBCPQ2) += sbcpq2.o
diff --git a/arch/powerpc/platforms/82xx/sbcpq2.c b/arch/powerpc/platforms/82xx/sbcpq2.c
new file mode 100644
index 0000000..a295392
--- /dev/null
+++ b/arch/powerpc/platforms/82xx/sbcpq2.c
@@ -0,0 +1,326 @@
+/*
+ * sbcpq2.c: Platform support for Wind River SBC PowerQUICCII 82xx
+ *
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * By Jeremy McNicoll <jeremy.mcnicoll@windriver.com>
+ *
+ * Based largely on the EP8248E and MPC8272ADS - Copyright 2007 Freescale Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+*/
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/reboot.h>
+#include <linux/io.h>
+#include <linux/rtc.h>
+#include <linux/console.h>
+#include <linux/seq_file.h>
+#include <linux/fsl_devices.h>
+#include <linux/fs_enet_pd.h>
+#include <linux/of_platform.h>
+#include <linux/io.h>
+#include <linux/time.h>
+
+#include <asm/udbg.h>
+#include <asm/machdep.h>
+#include <asm/prom.h>
+#include <asm/mpc8260.h>
+#include <asm/cpm2.h>
+#include <asm/fs_pd.h>
+#include <asm/immap_cpm2.h>
+#include <asm/machdep.h>
+#include <asm/io.h>
+
+#include <sysdev/cpm2_pic.h>
+#include <sysdev/fsl_soc.h>
+#include <mm/mmu_decl.h>
+
+#include "pq2.h"
+
+static int __init declare_of_platform_devices(void);
+static int pcmcia_build;
+
+/*
+ * sbcpq2_pdev_init - Register the platform device for sbcpq2 board
+ */
+static int __init sbcpq2_platdev_init(void)
+{
+	declare_of_platform_devices();
+	return 0;
+}
+arch_initcall(sbcpq2_platdev_init);
+
+static void __init sbcpq2_init_IRQ(void)
+{
+	struct device_node *np = of_find_compatible_node(NULL,
+		NULL, "fsl,pq2-pic");
+	struct resource r;
+
+	if (np == NULL) {
+		pr_err("PIC init: can not find cpm-pic node\n");
+		return;
+	}
+	if (of_address_to_resource(np, 0, &r)) {
+		pr_err("PIC init: invalid resource\n");
+		of_node_put(np);
+		return;
+	}
+	cpm2_pic_init(np);
+	of_node_put(np);
+}
+
+static struct of_device_id __initdata of_bus_ids[] = {
+	{ .name = "soc", },
+	{ .name = "cpm", },
+	{ .name = "localbus", },
+	{},
+};
+
+static int __init declare_of_platform_devices(void)
+{
+	of_platform_bus_probe(NULL, of_bus_ids, NULL);
+	return 0;
+}
+machine_device_initcall(sbc8260, declare_of_platform_devices);
+
+
+struct cpm_pin {
+	int port, pin, flags;
+};
+
+static __initdata struct cpm_pin sbcpq2_pins[] = {
+	/* See User Guide - Table 15.1 */
+	/* FCC1 */
+	{0, 14, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{0, 15, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{0, 16, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{0, 17, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{0, 18, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
+	{0, 19, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
+	{0, 20, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
+	{0, 21, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
+	{0, 26, CPM_PIN_INPUT | CPM_PIN_SECONDARY},
+	{0, 27, CPM_PIN_INPUT | CPM_PIN_SECONDARY},
+	{0, 28, CPM_PIN_OUTPUT | CPM_PIN_SECONDARY},
+	{0, 29, CPM_PIN_OUTPUT | CPM_PIN_SECONDARY},
+	{0, 30, CPM_PIN_INPUT | CPM_PIN_SECONDARY},
+	{0, 31, CPM_PIN_INPUT | CPM_PIN_SECONDARY},
+	{2, 22, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{2, 23, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+
+	/*FCC2*/
+	{1, 18, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{1, 19, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{1, 20, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{1, 21, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{1, 22, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
+	{1, 23, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
+	{1, 24, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
+	{1, 25, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
+	{1, 26, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{1, 27, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{1, 28, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{1, 29, CPM_PIN_OUTPUT | CPM_PIN_SECONDARY},
+	{1, 30, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{1, 31, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
+	{2, 18, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{2, 19, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+
+	/* FCC3 */
+	{1, 4, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
+	{1, 5, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
+	{1, 6, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
+	{1, 7, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
+	{1, 8, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{1, 9, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{1, 10, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{1, 11, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{1, 12, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{1, 13, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{1, 14, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
+	{1, 15, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
+	{1, 16, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{1, 17, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{2, 16, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{2, 17, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+
+
+	/* SCC1 */
+	{2, 0, CPM_PIN_OUTPUT | CPM_PIN_GPIO},
+	{2, 1, CPM_PIN_OUTPUT | CPM_PIN_GPIO},
+	{2, 2, CPM_PIN_INPUT | CPM_PIN_GPIO},
+	{2, 14, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{2, 20, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{2, 21, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{2, 29, CPM_PIN_INPUT | CPM_PIN_SECONDARY},
+	{3, 29, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
+	{3, 30, CPM_PIN_OUTPUT | CPM_PIN_SECONDARY},
+	{3, 31, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+};
+
+static void __init init_ioports(void)
+{
+	int i;
+	iop_cpm2_t *iop;
+
+	iop = &cpm2_immr->im_ioport;
+
+	for (i = 0; i < ARRAY_SIZE(sbcpq2_pins); i++) {
+		const struct cpm_pin *pin = &sbcpq2_pins[i];
+		cpm2_set_pin(pin->port, pin->pin, pin->flags);
+	}
+
+	cpm2_clk_setup(CPM_CLK_FCC1, CPM_CLK9, CPM_CLK_RX);
+	cpm2_clk_setup(CPM_CLK_FCC1, CPM_CLK10, CPM_CLK_TX);
+	cpm2_clk_setup(CPM_CLK_FCC2, CPM_CLK13, CPM_CLK_RX);
+	cpm2_clk_setup(CPM_CLK_FCC2, CPM_CLK14, CPM_CLK_TX);
+	cpm2_clk_setup(CPM_CLK_FCC3, CPM_CLK15, CPM_CLK_RX);
+	cpm2_clk_setup(CPM_CLK_FCC3, CPM_CLK16, CPM_CLK_TX);
+	cpm2_clk_setup(CPM_CLK_SCC1, CPM_CLK11, CPM_CLK_RX);
+	cpm2_clk_setup(CPM_CLK_SCC1, CPM_CLK12, CPM_CLK_TX);
+
+}
+
+/* Read board build type */
+static int __init sbcpq2_build_type(void)
+{
+	struct device_node *np;
+	int build_type = 0;
+	struct resource res;
+	void __iomem *addr;
+
+	np = of_find_compatible_node(NULL, NULL, "wrs,sbcpq2-status");
+	if (np == NULL) {
+		pr_info("No status reg. found in DTB.\n");
+		return -ENODEV;
+	}
+
+	of_address_to_resource(np, 0, &res);
+	of_node_put(np);
+
+	addr = of_iomap(np, 0);
+	if (!addr) {
+		pr_err("Cannot map build type\n");
+		of_node_put(np);
+		return -ENODEV;
+	}
+	build_type = in_8(addr);
+
+	return (build_type) && 0x1;
+}
+
+
+/*
+ * sbcpq2_setup_arch - the board-level setup routine
+ */
+static void __init sbcpq2_setup_arch(void)
+{
+	cpm2_reset();
+
+	/* When this is set, snooping CPM DMA from RAM causes
+	 * machine checks.  See erratum SIU18.
+	 */
+	clrbits32(&cpm2_immr->im_siu_conf.siu_82xx.sc_bcr, MPC82XX_BCR_PLDP);
+
+	pr_info(" SBCPQ2 Build type: ");
+	pcmcia_build = sbcpq2_build_type();
+
+	if (pcmcia_build)
+		pr_info("PCMCIA\n");
+	else
+		pr_info("ATM\n");
+
+	init_ioports();
+	if (ppc_md.progress)
+		ppc_md.progress("sbcpq2_setup_arch(), finish", 0);
+}
+
+static void sbcpq2_show_cpuinfo(struct seq_file *m)
+{
+	uint pvid, svid, phid1;
+
+	pvid = mfspr(SPRN_PVR);
+	svid = mfspr(SPRN_SVR);
+
+	seq_puts(m, "Vendor\t\t: Wind River\n");
+	seq_printf(m, "PVR\t\t: 0x%x\n", pvid);
+	seq_printf(m, "SVR\t\t: 0x%x\n", svid);
+	seq_puts(m, "Build Type\t: ");
+	if (pcmcia_build)
+		seq_puts(m, "PCMCIA\n");
+	else
+		seq_puts(m, "ATM\n");
+
+	/* Display cpu PLL setting */
+	phid1 = mfspr(SPRN_HID1);
+	seq_printf(m, "PLL setting\t: 0x%x\n", ((phid1 >> 24) & 0x3f));
+}
+
+
+/*
+ * Called very early, device-tree isn't unflattened
+ */
+static int __init sbcpq2_probe(void)
+{
+	unsigned long root = of_get_flat_dt_root();
+
+	return of_flat_dt_is_compatible(root, "wind,sbc82xx");
+}
+
+#ifdef CONFIG_RTC_DRV_M48T59
+static int __init sbcpq2_rtc_init(void)
+{
+	struct device_node *np;
+	struct resource res;
+	struct platform_device *rtc_dev;
+
+	np = of_find_compatible_node(NULL, NULL, "m48t59");
+	if (np == NULL) {
+		pr_info("No RTC in DTB found\n");
+		return -ENODEV;
+	}
+
+	of_address_to_resource(np, 0, &res);
+	of_node_put(np);
+
+	pr_info("Found RTC (m48t59) at i/o 0x%x\n", res.start);
+
+	rtc_dev = platform_device_register_simple("rtc-m48t59", -1, &res, 1);
+
+	if (IS_ERR(rtc_dev)) {
+		pr_info("Registering sbcpq2 RTC device failed\n");
+		return PTR_ERR(rtc_dev);
+	}
+	return 0;
+}
+arch_initcall(sbcpq2_rtc_init);
+#endif  /* M48T59 */
+
+
+define_machine(sbcpq2)
+{
+	.name		= "SBC PowerQUICCII 82xx",
+	.probe		= sbcpq2_probe,
+	.setup_arch	= sbcpq2_setup_arch,
+	.init_IRQ	= sbcpq2_init_IRQ,
+	.show_cpuinfo	= sbcpq2_show_cpuinfo,
+	.get_irq	= cpm2_get_irq,
+	.calibrate_decr	= generic_calibrate_decr,
+	.restart	= pq2_restart,
+	.progress	= udbg_progress,
+};
-- 
1.7.5.4

