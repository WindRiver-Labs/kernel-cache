From 39e7345a9f2cba922fbaa062e798fe2a76d722ed Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Fri, 19 Mar 2010 16:24:43 +0800
Subject: [PATCH 2/2] add the oprofile support of bcm1250

BCM1250 has two sibyte core (SB1). The SB1 has four performance counter pairs
(control register and counter register). As a different extention the counter
register of SB1 is 64bit and the bit 40 is the overflow bit. It is bit 31 in
standard mips core (mips32r1/mips32r2/mips64r1/mips64r2).

SB1 is compatible with mips64r1. So the Count/Compare interrupt and the
performace counter overflow interrupt use the same interrupt slot (CAUSE_IP7).

The mainline kernel use SB1's internal timer as its clock event not the
Count/Compare. By default the CAUSE_IP7 is masked in cp0_status.

So SB1 need a different overflow interrupt handler and need to unmask the
CAUSE_IP7.

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/oprofile/op_model_mipsxx.c |  101 +++++++++++++++++++++++++++++++++-
 1 files changed, 99 insertions(+), 2 deletions(-)

diff --git a/arch/mips/oprofile/op_model_mipsxx.c b/arch/mips/oprofile/op_model_mipsxx.c
index 54759f1..640ba99 100644
--- a/arch/mips/oprofile/op_model_mipsxx.c
+++ b/arch/mips/oprofile/op_model_mipsxx.c
@@ -11,6 +11,7 @@
 #include <linux/interrupt.h>
 #include <linux/smp.h>
 #include <asm/irq_regs.h>
+#include <asm/sibyte/sb1250_int.h>
 
 #include "op_impl.h"
 
@@ -29,9 +30,15 @@
 #define M_PERFCTL_WIDE			(1UL      << 30)
 #define M_PERFCTL_MORE			(1UL      << 31)
 
+#ifdef CONFIG_CPU_SB1
+#define M_PERFCTL_FE			(1UL      << 30)
+#define M_COUNTER_OVERFLOW		(1ULL     << 40)
+#else
 #define M_COUNTER_OVERFLOW		(1UL      << 31)
 
 static int (*save_perf_irq)(void);
+#endif
+
 
 #ifdef CONFIG_MIPS_MT_SMP
 static int cpu_has_mipsmt_pertccounters;
@@ -110,13 +117,64 @@ static inline void w_c0_ ## r ## n(unsigned int value)			\
 		BUG();							\
 	}								\
 	return;								\
-}									\
+}									
+
+
+#ifdef CONFIG_CPU_SB1
+
+static inline uint64_t r_c0_perfcntr0(void)
+{
+	return __read_64bit_c0_register($25, 1);
+}
+
+static inline void w_c0_perfcntr0(uint64_t value)
+{
+	__write_64bit_c0_register($25, 1, value);
+	return;
+}
+
+static inline uint64_t r_c0_perfcntr1(void)
+{
+	return __read_64bit_c0_register($25, 3);
+}
+
+static inline void w_c0_perfcntr1(uint64_t value)
+{
+	__write_64bit_c0_register($25, 3, value);
+	return;
+}
+
+static inline uint64_t r_c0_perfcntr2(void)
+{
+	return __read_64bit_c0_register($25, 5);
+}
+
+static inline void w_c0_perfcntr2(uint64_t value)
+{
+	__write_64bit_c0_register($25, 5, value);
+	return;
+}
+
+static inline uint64_t r_c0_perfcntr3(void)
+{
+	return __read_64bit_c0_register($25, 7);
+}
+
+static inline void w_c0_perfcntr3(uint64_t value)
+{
+	__write_64bit_c0_register($25, 7, value);
+	return;
+}
+
+#else
 
 __define_perf_accessors(perfcntr, 0, 2)
 __define_perf_accessors(perfcntr, 1, 3)
 __define_perf_accessors(perfcntr, 2, 0)
 __define_perf_accessors(perfcntr, 3, 1)
 
+#endif
+
 __define_perf_accessors(perfctrl, 0, 2)
 __define_perf_accessors(perfctrl, 1, 3)
 __define_perf_accessors(perfctrl, 2, 0)
@@ -126,7 +184,11 @@ struct op_mips_model op_model_mipsxx_ops;
 
 static struct mipsxx_register_config {
 	unsigned int control[4];
+#ifdef CONFIG_CPU_SB1
+	uint64_t counter[4];
+#else
 	unsigned int counter[4];
+#endif
 } reg;
 
 /* Compute all of the registers in preparation for enabling profiling.  */
@@ -152,7 +214,11 @@ static void mipsxx_reg_setup(struct op_counter_config *ctr)
 			reg.control[i] |= M_PERFCTL_USER;
 		if (ctr[i].exl)
 			reg.control[i] |= M_PERFCTL_EXL;
+#ifdef CONFIG_CPU_SB1
+		reg.counter[i] = 0x10000000000ULL - ctr[i].count;
+#else
 		reg.counter[i] = 0x80000000 - ctr[i].count;
+#endif
 	}
 }
 
@@ -216,7 +282,11 @@ static int mipsxx_perfcount_handler(void)
 {
 	unsigned int counters = op_model_mipsxx_ops.num_counters;
 	unsigned int control;
+#ifdef CONFIG_CPU_SB1
+	uint64_t counter;
+#else
 	unsigned int counter;
+#endif
 	int handled = IRQ_NONE;
 
 	if (cpu_has_mips_r2 && !(read_c0_cause() & (1 << 26)))
@@ -242,6 +312,15 @@ static int mipsxx_perfcount_handler(void)
 	return handled;
 }
 
+static irqreturn_t sb1_perfcount_handler(int irq, void *dev_id)
+{
+	if (mipsxx_perfcount_handler() == IRQ_NONE)
+		/* clear count/compare interrupt */
+		write_c0_compare(read_c0_compare()); 
+
+	return IRQ_HANDLED;
+}
+
 #define M_CONFIG1_PC	(1 << 4)
 
 static inline int __n_counters(void)
@@ -300,7 +379,7 @@ static void reset_counters(void *arg)
 
 static int __init mipsxx_init(void)
 {
-	int counters;
+	int counters, rst;
 
 	counters = n_counters();
 	if (counters == 0) {
@@ -371,8 +450,22 @@ static int __init mipsxx_init(void)
 		return -ENODEV;
 	}
 
+#ifdef CONFIG_CPU_SB1
+	set_c0_status(CAUSEF_IP7);
+	rst = request_irq(MIPS_CPU_IRQ_BASE + 7, sb1_perfcount_handler,
+				IRQF_DISABLED, "sb1250-PerfCounter", NULL);
+#ifdef CONFIG_SMP
+	if (rst == 0) {
+		struct irq_desc *desc = irq_desc + (MIPS_CPU_IRQ_BASE + 7);
+		smp_call_function((void (*)(void *)) desc->chip->enable,
+			  (void *) (long)(MIPS_CPU_IRQ_BASE + 7), 1);
+	}
+#endif
+
+#else
 	save_perf_irq = perf_irq;
 	perf_irq = mipsxx_perfcount_handler;
+#endif
 
 	return 0;
 }
@@ -384,7 +477,11 @@ static void mipsxx_exit(void)
 	counters = counters_per_cpu_to_total(counters);
 	on_each_cpu(reset_counters, (void *)(long)counters, 1);
 
+#ifdef CONFIG_CPU_SB1
+	free_irq(MIPS_CPU_IRQ_BASE + 7, NULL);
+#else
 	perf_irq = save_perf_irq;
+#endif
 }
 
 struct op_mips_model op_model_mipsxx_ops = {
-- 
1.6.5.2

