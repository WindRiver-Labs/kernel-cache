From d40991be13893b382766a14800a5221ff703352d Mon Sep 17 00:00:00 2001
From: Junxiao Bi <junxiao.bi@windriver.com>
Date: Sat, 31 Dec 2011 13:23:54 +0800
Subject: [PATCH 1/2] driver: w1: ds2438: fix deadlock when rmmod the driver

There is a deadlock when rmmod the ds2438 driver, see the following trace

[<c04f9d28>] (mutex_lock+0xc/0x20) from [<bf0b3518>] (ds2438_command+0x20/0x6c [w1_ds2438])
[<bf0b3518>] (ds2438_command+0x20/0x6c [w1_ds2438]) from [<bf0b39f4>] (ds2438_battery_read_status+0x360/0x4a8 [w1_ds2438])
[<bf0b39f4>] (ds2438_battery_read_status+0x360/0x4a8 [w1_ds2438]) from [<bf0b3ba4>] (ds2438_battery_get_property+0x28/0x88 [w1_ds2438])
[<bf0b3ba4>] (ds2438_battery_get_property+0x28/0x88 [w1_ds2438]) from [<c03cf010>] (power_supply_show_property+0x38/0x160)
[<c03cf010>] (power_supply_show_property+0x38/0x160) from [<c03cf3b0>] (power_supply_uevent+0xe8/0x198)
[<c03cf3b0>] (power_supply_uevent+0xe8/0x198) from [<c033e2cc>] (dev_uevent+0x124/0x164)
[<c033e2cc>] (dev_uevent+0x124/0x164) from [<c02ed960>] (kobject_uevent_env+0x210/0x4e8)
[<c02ed960>] (kobject_uevent_env+0x210/0x4e8) from [<c033e9f8>] (device_del+0x148/0x170)
[<c033e9f8>] (device_del+0x148/0x170) from [<c033ea2c>] (device_unregister+0xc/0x18)
[<c033ea2c>] (device_unregister+0xc/0x18) from [<bf0b302c>] (ds2438_remove_slave+0x2c/0x3c [w1_ds2438])
[<bf0b302c>] (ds2438_remove_slave+0x2c/0x3c [w1_ds2438]) from [<bf0a2d7c>] (w1_slave_detach+0x4c/0xcc [wire])
[<bf0a2d7c>] (w1_slave_detach+0x4c/0xcc [wire]) from [<bf0a3020>] (w1_reconnect_slaves+0x7c/0xd4 [wire])
[<bf0a3020>] (w1_reconnect_slaves+0x7c/0xd4 [wire]) from [<bf0a3ad8>] (w1_unregister_family+0x94/0xec [wire])
[<bf0a3ad8>] (w1_unregister_family+0x94/0xec [wire]) from [<c0089e3c>] (sys_delete_module+0x1c8/0x234)
[<c0089e3c>] (sys_delete_module+0x1c8/0x234) from [<c00330f4>] (__sys_trace_return+0x0/0x2c)

w1_reconnect_slaves() will acquire a lock "master->mutex" to protect the w1 master
data before it calls w1_slave_detach(). ds2438_command() also needs to acquire the
same lock for w1 master hardware resource access and this makes the deadlock.

ds2438_remove_slave() is called for removing the w1 slave device, before entering it,
the w1 slave device had been detached from the w1 master list in w1_slave_detach(),
so it is safe to unlock "master->mutex" at the beginning of ds2438_remove_slave() and
lock it again at the end of it to cure the deadlock.

Signed-off-by: Junxiao Bi <junxiao.bi@windriver.com>
---
 drivers/w1/slaves/w1_ds2438.c |   14 ++++++++++++++
 1 files changed, 14 insertions(+), 0 deletions(-)

diff --git a/drivers/w1/slaves/w1_ds2438.c b/drivers/w1/slaves/w1_ds2438.c
index 5ff7467..8186cbc 100644
--- a/drivers/w1/slaves/w1_ds2438.c
+++ b/drivers/w1/slaves/w1_ds2438.c
@@ -559,10 +559,24 @@ static void ds2438_remove_slave(struct w1_slave *slave)
 {
 	struct ds2438_device_info *di = dev_get_drvdata(&slave->dev);
 
+	/* 
+	 * This function is called by w1_slave_detach() to remove this slave 
+	 * device, the master->mutex has been got before calling w1_slave_detach().
+	 * The w1_slave has been detached from the master->slist, so it's safe to 
+	 * unlock the mutex here. 
+	 * We must unlock the mutex here for cancel_rearming_delayed_workqueue() and 
+	 * power_supply_unregister() may access the battery state which will get the 
+	 * master->mutex and cause a deadlock.
+	 */
+	mutex_unlock(&slave->master->mutex);
+
 	cancel_rearming_delayed_workqueue(di->monitor_wqueue,
 					  &di->monitor_work);
 	destroy_workqueue(di->monitor_wqueue);
 	power_supply_unregister(&di->bat);
+
+	/* Got the mutex again for the following steps in w1_slave_detach() */
+	mutex_lock(&slave->master->mutex);
 }
 
 static struct w1_family_ops w1_ds2438_fops = {
-- 
1.7.0.4

