From 4b057c0d80bd6fccade33e667a5f7df4ef9fd411 Mon Sep 17 00:00:00 2001
From: Wang Hui <Hui.Wang@windriver.com>
Date: Tue, 18 May 2010 11:13:00 +0800
Subject: [PATCH 08/10] imx51pdk/sound: add sgtl5000 codec based driver for imx51pdk

Add sgtl5000 codec based drivers for imx51pdk platform.

[Original code taken from L2.6.31_09.12.01_SDK.tar.gz BSP package:
http://www.freescale.com/webapp/sps/site/prod_summary.jsp?code=\
IMX35PDK&fpsp=1&tab=Design_Tools_Tab]

Integrated-by: Wang Hui <Hui.Wang@windriver.com>
---
 sound/soc/codecs/Kconfig            |    3 +
 sound/soc/codecs/Makefile           |    2 +
 sound/soc/codecs/sgtl5000.c         | 1291 +++++++++++++++++++++++++++++++++++
 sound/soc/codecs/sgtl5000.h         |  399 +++++++++++
 sound/soc/imx/Kconfig               |   21 +
 sound/soc/imx/Makefile              |    6 +
 sound/soc/imx/imx-3stack-sgtl5000.c |  690 +++++++++++++++++++
 sound/soc/imx/imx-esai.h            |   30 +
 sound/soc/imx/imx-pcm.c             |  706 +++++++++++++++++++
 sound/soc/imx/imx-pcm.h             |   83 +++
 sound/soc/imx/mxc-ssi.c             |  845 +++++++++++++++++++++++
 sound/soc/imx/mxc-ssi.h             |  236 +++++++
 12 files changed, 4312 insertions(+), 0 deletions(-)
 create mode 100644 sound/soc/codecs/sgtl5000.c
 create mode 100644 sound/soc/codecs/sgtl5000.h
 create mode 100644 sound/soc/imx/imx-3stack-sgtl5000.c
 create mode 100644 sound/soc/imx/imx-esai.h
 create mode 100644 sound/soc/imx/imx-pcm.c
 create mode 100644 sound/soc/imx/imx-pcm.h
 create mode 100644 sound/soc/imx/mxc-ssi.c
 create mode 100644 sound/soc/imx/mxc-ssi.h

diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 1743d56..dcf8c13 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -260,6 +260,9 @@ config SND_SOC_WM9712
 config SND_SOC_WM9713
 	tristate
 
+config SND_SOC_SGTL5000
+	tristate
+	depends on I2C
 # Amp
 config SND_SOC_MAX9877
 	tristate
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index dd5ce6d..3f251cd 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -53,6 +53,7 @@ snd-soc-wm9081-objs := wm9081.o
 snd-soc-wm9705-objs := wm9705.o
 snd-soc-wm9712-objs := wm9712.o
 snd-soc-wm9713-objs := wm9713.o
+snd-soc-sgtl5000-objs := sgtl5000.o
 snd-soc-wm-hubs-objs := wm_hubs.o
 
 # Amp
@@ -115,6 +116,7 @@ obj-$(CONFIG_SND_SOC_WM9081)	+= snd-soc-wm9081.o
 obj-$(CONFIG_SND_SOC_WM9705)	+= snd-soc-wm9705.o
 obj-$(CONFIG_SND_SOC_WM9712)	+= snd-soc-wm9712.o
 obj-$(CONFIG_SND_SOC_WM9713)	+= snd-soc-wm9713.o
+obj-$(CONFIG_SND_SOC_SGTL5000)	+= snd-soc-sgtl5000.o
 obj-$(CONFIG_SND_SOC_WM_HUBS)	+= snd-soc-wm-hubs.o
 
 # Amp
diff --git a/sound/soc/codecs/sgtl5000.c b/sound/soc/codecs/sgtl5000.c
new file mode 100644
index 0000000..5c93506
--- /dev/null
+++ b/sound/soc/codecs/sgtl5000.c
@@ -0,0 +1,1291 @@
+/*
+ * sgtl5000.c  --  SGTL5000 ALSA SoC Audio driver
+ *
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+#include <mach/hardware.h>
+
+#include "sgtl5000.h"
+
+struct sgtl5000_priv {
+	int sysclk;
+	int master;
+	int fmt;
+	int rev;
+	int lrclk;
+	int capture_channels;
+	int playback_active;
+	int capture_active;
+	struct regulator *reg_vddio;
+	struct regulator *reg_vdda;
+	struct regulator *reg_vddd;
+	int vddio;		/* voltage of VDDIO (mv) */
+	int vdda;		/* voltage of vdda (mv) */
+	int vddd;		/* voltage of vddd (mv), 0 if not connected */
+	struct snd_pcm_substream *master_substream;
+	struct snd_pcm_substream *slave_substream;
+};
+
+static int sgtl5000_set_bias_level(struct snd_soc_codec *codec,
+				   enum snd_soc_bias_level level);
+
+#define SGTL5000_MAX_CACHED_REG SGTL5000_CHIP_SHORT_CTRL
+static u16 sgtl5000_regs[(SGTL5000_MAX_CACHED_REG >> 1) + 1];
+
+static unsigned int sgtl5000_read_reg_cache(struct snd_soc_codec *codec,
+					    unsigned int reg)
+{
+	u16 *cache = codec->reg_cache;
+	unsigned int offset = reg >> 1;
+	if (offset >= ARRAY_SIZE(sgtl5000_regs))
+		return -EINVAL;
+	pr_debug("r r:%02x,v:%04x\n", reg, cache[offset]);
+	return cache[offset];
+}
+
+static unsigned int sgtl5000_hw_read(struct snd_soc_codec *codec,
+				     unsigned int reg)
+{
+	struct i2c_client *client = codec->control_data;
+	int i2c_ret;
+	u16 value;
+	u8 buf0[2], buf1[2];
+	u16 addr = client->addr;
+	u16 flags = client->flags;
+	struct i2c_msg msg[2] = {
+		{addr, flags, 2, buf0},
+		{addr, flags | I2C_M_RD, 2, buf1},
+	};
+
+	buf0[0] = (reg & 0xff00) >> 8;
+	buf0[1] = reg & 0xff;
+	i2c_ret = i2c_transfer(client->adapter, msg, 2);
+	if (i2c_ret < 0) {
+		pr_err("%s: read reg error : Reg 0x%02x\n", __func__, reg);
+		return 0;
+	}
+
+	value = buf1[0] << 8 | buf1[1];
+
+	pr_debug("r r:%02x,v:%04x\n", reg, value);
+	return value;
+}
+
+static unsigned int sgtl5000_read(struct snd_soc_codec *codec, unsigned int reg)
+{
+	if ((reg == SGTL5000_CHIP_ID) ||
+	    (reg == SGTL5000_CHIP_ADCDAC_CTRL) ||
+	    (reg == SGTL5000_CHIP_ANA_STATUS) ||
+	    (reg > SGTL5000_MAX_CACHED_REG))
+		return sgtl5000_hw_read(codec, reg);
+	else
+		return sgtl5000_read_reg_cache(codec, reg);
+}
+
+static inline void sgtl5000_write_reg_cache(struct snd_soc_codec *codec,
+					    u16 reg, unsigned int value)
+{
+	u16 *cache = codec->reg_cache;
+	unsigned int offset = reg >> 1;
+	if (offset < ARRAY_SIZE(sgtl5000_regs))
+		cache[offset] = value;
+}
+
+static int sgtl5000_write(struct snd_soc_codec *codec, unsigned int reg,
+			  unsigned int value)
+{
+	struct i2c_client *client = codec->control_data;
+	u16 addr = client->addr;
+	u16 flags = client->flags;
+	u8 buf[4];
+	int i2c_ret;
+	struct i2c_msg msg = { addr, flags, 4, buf };
+
+	sgtl5000_write_reg_cache(codec, reg, value);
+	pr_debug("w r:%02x,v:%04x\n", reg, value);
+	buf[0] = (reg & 0xff00) >> 8;
+	buf[1] = reg & 0xff;
+	buf[2] = (value & 0xff00) >> 8;
+	buf[3] = value & 0xff;
+
+	i2c_ret = i2c_transfer(client->adapter, &msg, 1);
+	if (i2c_ret < 0) {
+		pr_err("%s: write reg error : Reg 0x%02x = 0x%04x\n",
+		       __func__, reg, value);
+		return -EIO;
+	}
+
+	return i2c_ret;
+}
+
+static void sgtl5000_sync_reg_cache(struct snd_soc_codec *codec)
+{
+	int reg;
+	for (reg = 0; reg <= SGTL5000_MAX_CACHED_REG; reg += 2)
+		sgtl5000_write_reg_cache(codec, reg,
+					 sgtl5000_hw_read(codec, reg));
+}
+
+static int sgtl5000_restore_reg(struct snd_soc_codec *codec, unsigned int reg)
+{
+	unsigned int cached_val, hw_val;
+
+	cached_val = sgtl5000_read_reg_cache(codec, reg);
+	hw_val = sgtl5000_hw_read(codec, reg);
+
+	if (hw_val != cached_val)
+		return sgtl5000_write(codec, reg, cached_val);
+
+	return 0;
+}
+
+static int all_reg[] = {
+	SGTL5000_CHIP_ID,
+	SGTL5000_CHIP_DIG_POWER,
+	SGTL5000_CHIP_CLK_CTRL,
+	SGTL5000_CHIP_I2S_CTRL,
+	SGTL5000_CHIP_SSS_CTRL,
+	SGTL5000_CHIP_ADCDAC_CTRL,
+	SGTL5000_CHIP_DAC_VOL,
+	SGTL5000_CHIP_PAD_STRENGTH,
+	SGTL5000_CHIP_ANA_ADC_CTRL,
+	SGTL5000_CHIP_ANA_HP_CTRL,
+	SGTL5000_CHIP_ANA_CTRL,
+	SGTL5000_CHIP_LINREG_CTRL,
+	SGTL5000_CHIP_REF_CTRL,
+	SGTL5000_CHIP_MIC_CTRL,
+	SGTL5000_CHIP_LINE_OUT_CTRL,
+	SGTL5000_CHIP_LINE_OUT_VOL,
+	SGTL5000_CHIP_ANA_POWER,
+	SGTL5000_CHIP_PLL_CTRL,
+	SGTL5000_CHIP_CLK_TOP_CTRL,
+	SGTL5000_CHIP_ANA_STATUS,
+	SGTL5000_CHIP_SHORT_CTRL,
+};
+
+#ifdef DEBUG
+static void dump_reg(struct snd_soc_codec *codec)
+{
+	int i, reg;
+	printk(KERN_DEBUG "dump begin\n");
+	for (i = 0; i < 21; i++) {
+		reg = sgtl5000_read(codec, all_reg[i]);
+		printk(KERN_DEBUG "d r %04x, v %04x\n", all_reg[i], reg);
+	}
+	printk(KERN_DEBUG "dump end\n");
+}
+#else
+static void dump_reg(struct snd_soc_codec *codec)
+{
+}
+#endif
+
+static int dac_mux_put(struct snd_kcontrol *kcontrol,
+		       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dapm_widget *widget = snd_kcontrol_chip(kcontrol);
+	struct snd_soc_codec *codec = widget->codec;
+	unsigned int reg;
+
+	if (ucontrol->value.enumerated.item[0]) {
+		reg = sgtl5000_read(codec, SGTL5000_CHIP_CLK_TOP_CTRL);
+		reg |= SGTL5000_INT_OSC_EN;
+		sgtl5000_write(codec, SGTL5000_CHIP_CLK_TOP_CTRL, reg);
+
+		if (codec->bias_level != SND_SOC_BIAS_ON) {
+			sgtl5000_set_bias_level(codec, SND_SOC_BIAS_PREPARE);
+			snd_soc_dapm_put_enum_double(kcontrol, ucontrol);
+			sgtl5000_set_bias_level(codec, SND_SOC_BIAS_ON);
+		} else
+			snd_soc_dapm_put_enum_double(kcontrol, ucontrol);
+
+		reg = sgtl5000_read(codec, SGTL5000_CHIP_ANA_CTRL);
+		reg &= ~(SGTL5000_LINE_OUT_MUTE | SGTL5000_HP_MUTE);
+		sgtl5000_write(codec, SGTL5000_CHIP_ANA_CTRL, reg);
+	} else {
+		reg = sgtl5000_read(codec, SGTL5000_CHIP_CLK_TOP_CTRL);
+		reg &= ~SGTL5000_INT_OSC_EN;
+		sgtl5000_write(codec, SGTL5000_CHIP_CLK_TOP_CTRL, reg);
+
+		snd_soc_dapm_put_enum_double(kcontrol, ucontrol);
+		sgtl5000_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+	}
+	return 0;
+}
+
+static const char *adc_mux_text[] = {
+	"MIC_IN", "LINE_IN"
+};
+
+static const char *dac_mux_text[] = {
+	"DAC", "LINE_IN"
+};
+
+static const struct soc_enum adc_enum =
+SOC_ENUM_SINGLE(SGTL5000_CHIP_ANA_CTRL, 2, 2, adc_mux_text);
+
+static const struct soc_enum dac_enum =
+SOC_ENUM_SINGLE(SGTL5000_CHIP_ANA_CTRL, 6, 2, dac_mux_text);
+
+static const struct snd_kcontrol_new adc_mux =
+SOC_DAPM_ENUM("ADC Mux", adc_enum);
+
+static const struct snd_kcontrol_new dac_mux = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "DAC Mux",
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE
+	    | SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+	.info = snd_soc_info_enum_double,
+	.get = snd_soc_dapm_get_enum_double,
+	.put = dac_mux_put,
+	.private_value = (unsigned long)&dac_enum,
+};
+
+static const struct snd_soc_dapm_widget sgtl5000_dapm_widgets[] = {
+	SND_SOC_DAPM_INPUT("LINE_IN"),
+	SND_SOC_DAPM_INPUT("MIC_IN"),
+
+	SND_SOC_DAPM_OUTPUT("HP_OUT"),
+	SND_SOC_DAPM_OUTPUT("LINE_OUT"),
+
+	SND_SOC_DAPM_PGA("HP", SGTL5000_CHIP_ANA_CTRL, 4, 1, NULL, 0),
+	SND_SOC_DAPM_PGA("LO", SGTL5000_CHIP_ANA_CTRL, 8, 1, NULL, 0),
+
+	SND_SOC_DAPM_MUX("ADC Mux", SND_SOC_NOPM, 0, 0, &adc_mux),
+	SND_SOC_DAPM_MUX("DAC Mux", SND_SOC_NOPM, 0, 0, &dac_mux),
+
+	SND_SOC_DAPM_ADC("ADC", "Capture", SGTL5000_CHIP_DIG_POWER, 6, 0),
+	SND_SOC_DAPM_DAC("DAC", "Playback", SND_SOC_NOPM, 0, 0),
+};
+
+static const struct snd_soc_dapm_route audio_map[] = {
+	{"ADC Mux", "LINE_IN", "LINE_IN"},
+	{"ADC Mux", "MIC_IN", "MIC_IN"},
+	{"ADC", NULL, "ADC Mux"},
+	{"DAC Mux", "DAC", "DAC"},
+	{"DAC Mux", "LINE_IN", "LINE_IN"},
+	{"LO", NULL, "DAC"},
+	{"HP", NULL, "DAC Mux"},
+	{"LINE_OUT", NULL, "LO"},
+	{"HP_OUT", NULL, "HP"},
+};
+
+static int sgtl5000_add_widgets(struct snd_soc_codec *codec)
+{
+	snd_soc_dapm_new_controls(codec, sgtl5000_dapm_widgets,
+				  ARRAY_SIZE(sgtl5000_dapm_widgets));
+
+	snd_soc_dapm_add_routes(codec, audio_map, ARRAY_SIZE(audio_map));
+
+	snd_soc_dapm_new_widgets(codec);
+	return 0;
+}
+
+static int dac_info_volsw(struct snd_kcontrol *kcontrol,
+			  struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 0xfc - 0x3c;
+	return 0;
+}
+
+static int dac_get_volsw(struct snd_kcontrol *kcontrol,
+			 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int reg, l, r;
+
+	reg = sgtl5000_read(codec, SGTL5000_CHIP_DAC_VOL);
+	l = (reg & SGTL5000_DAC_VOL_LEFT_MASK) >> SGTL5000_DAC_VOL_LEFT_SHIFT;
+	r = (reg & SGTL5000_DAC_VOL_RIGHT_MASK) >> SGTL5000_DAC_VOL_RIGHT_SHIFT;
+	l = l < 0x3c ? 0x3c : l;
+	l = l > 0xfc ? 0xfc : l;
+	r = r < 0x3c ? 0x3c : r;
+	r = r > 0xfc ? 0xfc : r;
+	l = 0xfc - l;
+	r = 0xfc - r;
+
+	ucontrol->value.integer.value[0] = l;
+	ucontrol->value.integer.value[1] = r;
+
+	return 0;
+}
+
+static int dac_put_volsw(struct snd_kcontrol *kcontrol,
+			 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int reg, l, r;
+
+	l = ucontrol->value.integer.value[0];
+	r = ucontrol->value.integer.value[1];
+
+	l = l < 0 ? 0 : l;
+	l = l > 0xfc - 0x3c ? 0xfc - 0x3c : l;
+	r = r < 0 ? 0 : r;
+	r = r > 0xfc - 0x3c ? 0xfc - 0x3c : r;
+	l = 0xfc - l;
+	r = 0xfc - r;
+
+	reg = l << SGTL5000_DAC_VOL_LEFT_SHIFT |
+	    r << SGTL5000_DAC_VOL_RIGHT_SHIFT;
+
+	sgtl5000_write(codec, SGTL5000_CHIP_DAC_VOL, reg);
+
+	return 0;
+}
+
+static const char *mic_gain_text[] = {
+	"0dB", "20dB", "30dB", "40dB"
+};
+
+static const char *adc_m6db_text[] = {
+	"No Change", "Reduced by 6dB"
+};
+
+static const struct soc_enum mic_gain =
+SOC_ENUM_SINGLE(SGTL5000_CHIP_MIC_CTRL, 0, 4, mic_gain_text);
+
+static const struct soc_enum adc_m6db =
+SOC_ENUM_SINGLE(SGTL5000_CHIP_ANA_ADC_CTRL, 8, 2, adc_m6db_text);
+
+static const struct snd_kcontrol_new sgtl5000_snd_controls[] = {
+	SOC_ENUM("MIC GAIN", mic_gain),
+	SOC_DOUBLE("Capture Volume", SGTL5000_CHIP_ANA_ADC_CTRL, 0, 4, 0xf, 0),
+	SOC_ENUM("Capture Vol Reduction", adc_m6db),
+	{.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	 .name = "Playback Volume",
+	 .access = SNDRV_CTL_ELEM_ACCESS_READWRITE |
+	 SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+	 .info = dac_info_volsw,
+	 .get = dac_get_volsw,
+	 .put = dac_put_volsw,
+	 },
+	SOC_DOUBLE("Headphone Volume", SGTL5000_CHIP_ANA_HP_CTRL, 0, 8, 0x7f,
+		   1),
+};
+
+static int sgtl5000_digital_mute(struct snd_soc_dai *codec_dai, int mute)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	u16 adcdac_ctrl;
+
+	adcdac_ctrl = sgtl5000_read(codec, SGTL5000_CHIP_ADCDAC_CTRL);
+
+	if (mute) {
+		adcdac_ctrl |= SGTL5000_DAC_MUTE_LEFT;
+		adcdac_ctrl |= SGTL5000_DAC_MUTE_RIGHT;
+	} else {
+		adcdac_ctrl &= ~SGTL5000_DAC_MUTE_LEFT;
+		adcdac_ctrl &= ~SGTL5000_DAC_MUTE_RIGHT;
+	}
+
+	sgtl5000_write(codec, SGTL5000_CHIP_ADCDAC_CTRL, adcdac_ctrl);
+	if (!mute)
+		dump_reg(codec);
+	return 0;
+}
+
+static int sgtl5000_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct sgtl5000_priv *sgtl5000 = codec->private_data;
+	u16 i2sctl = 0;
+	pr_debug("%s:fmt=%08x\n", __func__, fmt);
+	sgtl5000->master = 0;
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		break;
+	case SND_SOC_DAIFMT_CBM_CFM:
+		i2sctl |= SGTL5000_I2S_MASTER;
+		sgtl5000->master = 1;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFS:
+	case SND_SOC_DAIFMT_CBS_CFM:
+		return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_DSP_A:
+		i2sctl |= SGTL5000_I2S_MODE_PCM;
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		i2sctl |= SGTL5000_I2S_MODE_PCM;
+		i2sctl |= SGTL5000_I2S_LRALIGN;
+		break;
+	case SND_SOC_DAIFMT_I2S:
+		i2sctl |= SGTL5000_I2S_MODE_I2S_LJ;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		i2sctl |= SGTL5000_I2S_MODE_RJ;
+		i2sctl |= SGTL5000_I2S_LRPOL;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		i2sctl |= SGTL5000_I2S_MODE_I2S_LJ;
+		i2sctl |= SGTL5000_I2S_LRALIGN;
+		break;
+	default:
+		return -EINVAL;
+	}
+	sgtl5000->fmt = fmt & SND_SOC_DAIFMT_FORMAT_MASK;
+
+	/* Clock inversion */
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+	case SND_SOC_DAIFMT_NB_IF:
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+	case SND_SOC_DAIFMT_IB_NF:
+		i2sctl |= SGTL5000_I2S_SCLK_INV;
+		break;
+	default:
+		return -EINVAL;
+	}
+	sgtl5000_write(codec, SGTL5000_CHIP_I2S_CTRL, i2sctl);
+
+	return 0;
+}
+
+static int sgtl5000_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+				   int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct sgtl5000_priv *sgtl5000 = codec->private_data;
+
+	switch (clk_id) {
+	case SGTL5000_SYSCLK:
+		sgtl5000->sysclk = freq;
+		break;
+	case SGTL5000_LRCLK:
+		sgtl5000->lrclk = freq;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int sgtl5000_pcm_prepare(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->card->codec;
+	struct sgtl5000_priv *sgtl5000 = codec->private_data;
+	int reg;
+
+	reg = sgtl5000_read(codec, SGTL5000_CHIP_DIG_POWER);
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		reg |= SGTL5000_I2S_IN_POWERUP;
+	else
+		reg |= SGTL5000_I2S_OUT_POWERUP;
+	sgtl5000_write(codec, SGTL5000_CHIP_DIG_POWER, reg);
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		reg = sgtl5000_read(codec, SGTL5000_CHIP_ANA_POWER);
+		reg |= SGTL5000_ADC_POWERUP;
+		if (sgtl5000->capture_channels == 1)
+			reg &= ~SGTL5000_ADC_STEREO;
+		else
+			reg |= SGTL5000_ADC_STEREO;
+		sgtl5000_write(codec, SGTL5000_CHIP_ANA_POWER, reg);
+	}
+
+	return 0;
+}
+
+static int sgtl5000_pcm_startup(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->card->codec;
+	struct sgtl5000_priv *sgtl5000 = codec->private_data;
+	struct snd_pcm_runtime *master_runtime;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		sgtl5000->playback_active++;
+	else
+		sgtl5000->capture_active++;
+
+	/* The DAI has shared clocks so if we already have a playback or
+	 * capture going then constrain this substream to match it.
+	 */
+	if (sgtl5000->master_substream) {
+		master_runtime = sgtl5000->master_substream->runtime;
+
+		pr_debug("Constraining to %d bits\n",
+			 master_runtime->sample_bits);
+
+		snd_pcm_hw_constraint_minmax(substream->runtime,
+					     SNDRV_PCM_HW_PARAM_SAMPLE_BITS,
+					     master_runtime->sample_bits,
+					     master_runtime->sample_bits);
+
+		sgtl5000->slave_substream = substream;
+	} else
+		sgtl5000->master_substream = substream;
+
+	return 0;
+}
+
+static void sgtl5000_pcm_shutdown(struct snd_pcm_substream *substream,
+				  struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->card->codec;
+	struct sgtl5000_priv *sgtl5000 = codec->private_data;
+	int reg, dig_pwr, ana_pwr;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		sgtl5000->playback_active--;
+	else
+		sgtl5000->capture_active--;
+
+	if (sgtl5000->master_substream == substream)
+		sgtl5000->master_substream = sgtl5000->slave_substream;
+
+	sgtl5000->slave_substream = NULL;
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
+		ana_pwr = sgtl5000_read(codec, SGTL5000_CHIP_ANA_POWER);
+		ana_pwr &= ~(SGTL5000_ADC_POWERUP | SGTL5000_ADC_STEREO);
+		sgtl5000_write(codec, SGTL5000_CHIP_ANA_POWER, ana_pwr);
+	}
+
+	dig_pwr = sgtl5000_read(codec, SGTL5000_CHIP_DIG_POWER);
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		dig_pwr &= ~SGTL5000_I2S_IN_POWERUP;
+	else
+		dig_pwr &= ~SGTL5000_I2S_OUT_POWERUP;
+	sgtl5000_write(codec, SGTL5000_CHIP_DIG_POWER, dig_pwr);
+
+	if (!sgtl5000->playback_active && !sgtl5000->capture_active) {
+		reg = sgtl5000_read(codec, SGTL5000_CHIP_I2S_CTRL);
+		reg &= ~SGTL5000_I2S_MASTER;
+		sgtl5000_write(codec, SGTL5000_CHIP_I2S_CTRL, reg);
+	}
+}
+
+/*
+ * Set PCM DAI bit size and sample rate.
+ * input: params_rate, params_fmt
+ */
+static int sgtl5000_pcm_hw_params(struct snd_pcm_substream *substream,
+				  struct snd_pcm_hw_params *params,
+				  struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->card->codec;
+	struct sgtl5000_priv *sgtl5000 = codec->private_data;
+	int channels = params_channels(params);
+	int clk_ctl = 0;
+	int pll_ctl = 0;
+	int i2s_ctl;
+	int div2 = 0;
+	int reg;
+
+	pr_debug("%s channels=%d\n", __func__, channels);
+
+	if (!sgtl5000->sysclk) {
+		pr_err("%s: set sysclk first!\n", __func__);
+		return -EFAULT;
+	}
+
+	if (substream == sgtl5000->slave_substream) {
+		pr_debug("Ignoring hw_params for slave substream\n");
+		return 0;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		sgtl5000->capture_channels = channels;
+
+	switch (sgtl5000->lrclk) {
+	case 32000:
+		clk_ctl |= SGTL5000_SYS_FS_32k << SGTL5000_SYS_FS_SHIFT;
+		break;
+	case 44100:
+		clk_ctl |= SGTL5000_SYS_FS_44_1k << SGTL5000_SYS_FS_SHIFT;
+		break;
+	case 48000:
+		clk_ctl |= SGTL5000_SYS_FS_48k << SGTL5000_SYS_FS_SHIFT;
+		break;
+	case 96000:
+		clk_ctl |= SGTL5000_SYS_FS_96k << SGTL5000_SYS_FS_SHIFT;
+		break;
+	default:
+		pr_err("%s: sample rate %d not supported\n", __func__,
+		       sgtl5000->lrclk);
+		return -EFAULT;
+	}
+
+#if 0	/* SGTL5000 rev1 has a IC bug to prevent switching to MCLK from PLL. */
+	if (fs * 256 == sgtl5000->sysclk)
+		clk_ctl |= SGTL5000_MCLK_FREQ_256FS << SGTL5000_MCLK_FREQ_SHIFT;
+	else if (fs * 384 == sgtl5000->sysclk && fs != 96000)
+		clk_ctl |= SGTL5000_MCLK_FREQ_384FS << SGTL5000_MCLK_FREQ_SHIFT;
+	else if (fs * 512 == sgtl5000->sysclk && fs != 96000)
+		clk_ctl |= SGTL5000_MCLK_FREQ_512FS << SGTL5000_MCLK_FREQ_SHIFT;
+	else
+#endif
+	{
+		if (!sgtl5000->master) {
+			pr_err("%s: PLL not supported in slave mode\n",
+			       __func__);
+			return -EINVAL;
+		}
+		clk_ctl |= SGTL5000_MCLK_FREQ_PLL << SGTL5000_MCLK_FREQ_SHIFT;
+	}
+
+	if ((clk_ctl & SGTL5000_MCLK_FREQ_MASK) == SGTL5000_MCLK_FREQ_PLL) {
+		u64 out, t;
+		unsigned int in, int_div, frac_div;
+		if (sgtl5000->sysclk > 17000000) {
+			div2 = 1;
+			in = sgtl5000->sysclk / 2;
+		} else {
+			div2 = 0;
+			in = sgtl5000->sysclk;
+		}
+		if (sgtl5000->lrclk == 44100)
+			out = 180633600;
+		else
+			out = 196608000;
+		t = do_div(out, in);
+		int_div = out;
+		t *= 2048;
+		do_div(t, in);
+		frac_div = t;
+		pll_ctl = int_div << SGTL5000_PLL_INT_DIV_SHIFT |
+		    frac_div << SGTL5000_PLL_FRAC_DIV_SHIFT;
+	}
+
+	i2s_ctl = sgtl5000_read(codec, SGTL5000_CHIP_I2S_CTRL);
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		if (sgtl5000->fmt == SND_SOC_DAIFMT_RIGHT_J)
+			return -EINVAL;
+		i2s_ctl |= SGTL5000_I2S_DLEN_16 << SGTL5000_I2S_DLEN_SHIFT;
+		i2s_ctl |= SGTL5000_I2S_SCLKFREQ_32FS <<
+		    SGTL5000_I2S_SCLKFREQ_SHIFT;
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		i2s_ctl |= SGTL5000_I2S_DLEN_20 << SGTL5000_I2S_DLEN_SHIFT;
+		i2s_ctl |= SGTL5000_I2S_SCLKFREQ_64FS <<
+		    SGTL5000_I2S_SCLKFREQ_SHIFT;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		i2s_ctl |= SGTL5000_I2S_DLEN_24 << SGTL5000_I2S_DLEN_SHIFT;
+		i2s_ctl |= SGTL5000_I2S_SCLKFREQ_64FS <<
+		    SGTL5000_I2S_SCLKFREQ_SHIFT;
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		if (sgtl5000->fmt == SND_SOC_DAIFMT_RIGHT_J)
+			return -EINVAL;
+		i2s_ctl |= SGTL5000_I2S_DLEN_32 << SGTL5000_I2S_DLEN_SHIFT;
+		i2s_ctl |= SGTL5000_I2S_SCLKFREQ_64FS <<
+		    SGTL5000_I2S_SCLKFREQ_SHIFT;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	pr_debug("fs=%d,clk_ctl=%d,pll_ctl=%d,i2s_ctl=%d,div2=%d\n",
+		 sgtl5000->lrclk, clk_ctl, pll_ctl, i2s_ctl, div2);
+
+	if ((clk_ctl & SGTL5000_MCLK_FREQ_MASK) == SGTL5000_MCLK_FREQ_PLL) {
+		sgtl5000_write(codec, SGTL5000_CHIP_PLL_CTRL, pll_ctl);
+		reg = sgtl5000_read(codec, SGTL5000_CHIP_CLK_TOP_CTRL);
+		if (div2)
+			reg |= SGTL5000_INPUT_FREQ_DIV2;
+		else
+			reg &= ~SGTL5000_INPUT_FREQ_DIV2;
+		sgtl5000_write(codec, SGTL5000_CHIP_CLK_TOP_CTRL, reg);
+		reg = sgtl5000_read(codec, SGTL5000_CHIP_ANA_POWER);
+		reg |= SGTL5000_PLL_POWERUP | SGTL5000_VCOAMP_POWERUP;
+		sgtl5000_write(codec, SGTL5000_CHIP_ANA_POWER, reg);
+	}
+	sgtl5000_write(codec, SGTL5000_CHIP_CLK_CTRL, clk_ctl);
+	sgtl5000_write(codec, SGTL5000_CHIP_I2S_CTRL, i2s_ctl);
+
+	return 0;
+}
+
+static void sgtl5000_mic_bias(struct snd_soc_codec *codec, int enable)
+{
+	int reg, bias_r = 0;
+	if (enable)
+		bias_r = SGTL5000_BIAS_R_4k << SGTL5000_BIAS_R_SHIFT;
+	reg = sgtl5000_read(codec, SGTL5000_CHIP_MIC_CTRL);
+	if ((reg & SGTL5000_BIAS_R_MASK) != bias_r) {
+		reg &= ~SGTL5000_BIAS_R_MASK;
+		reg |= bias_r;
+		sgtl5000_write(codec, SGTL5000_CHIP_MIC_CTRL, reg);
+	}
+}
+
+static int sgtl5000_set_bias_level(struct snd_soc_codec *codec,
+				   enum snd_soc_bias_level level)
+{
+	u16 reg, ana_pwr;
+	int delay = 0;
+	pr_debug("dapm level %d\n", level);
+	switch (level) {
+	case SND_SOC_BIAS_ON:		/* full On */
+		if (codec->bias_level == SND_SOC_BIAS_ON)
+			break;
+
+		sgtl5000_mic_bias(codec, 1);
+
+		reg = sgtl5000_read(codec, SGTL5000_CHIP_ANA_POWER);
+		reg |= SGTL5000_VAG_POWERUP;
+		sgtl5000_write(codec, SGTL5000_CHIP_ANA_POWER, reg);
+		msleep(400);
+
+		break;
+
+	case SND_SOC_BIAS_PREPARE:	/* partial On */
+		if (codec->bias_level == SND_SOC_BIAS_PREPARE)
+			break;
+
+		sgtl5000_mic_bias(codec, 0);
+
+		/* must power up hp/line out before vag & dac to
+		   avoid pops. */
+		reg = sgtl5000_read(codec, SGTL5000_CHIP_ANA_POWER);
+		if (reg & SGTL5000_VAG_POWERUP)
+			delay = 400;
+		reg &= ~SGTL5000_VAG_POWERUP;
+		reg |= SGTL5000_DAC_POWERUP;
+		reg |= SGTL5000_HP_POWERUP;
+		reg |= SGTL5000_LINE_OUT_POWERUP;
+		sgtl5000_write(codec, SGTL5000_CHIP_ANA_POWER, reg);
+		if (delay)
+			msleep(delay);
+
+		reg = sgtl5000_read(codec, SGTL5000_CHIP_DIG_POWER);
+		reg |= SGTL5000_DAC_EN;
+		sgtl5000_write(codec, SGTL5000_CHIP_DIG_POWER, reg);
+
+		break;
+
+	case SND_SOC_BIAS_STANDBY:	/* Off, with power */
+		/* soc doesn't do PREPARE state after record so make sure
+		   that anything that needs to be turned OFF gets turned off. */
+		if (codec->bias_level == SND_SOC_BIAS_STANDBY)
+			break;
+
+		/* soc calls digital_mute to unmute before record but doesn't
+		   call digital_mute to mute after record. */
+		sgtl5000_digital_mute(&sgtl5000_dai, 1);
+
+		sgtl5000_mic_bias(codec, 0);
+
+		reg = sgtl5000_read(codec, SGTL5000_CHIP_ANA_POWER);
+		if (reg & SGTL5000_VAG_POWERUP) {
+			reg &= ~SGTL5000_VAG_POWERUP;
+			sgtl5000_write(codec, SGTL5000_CHIP_ANA_POWER, reg);
+			msleep(400);
+		}
+		reg &= ~SGTL5000_DAC_POWERUP;
+		reg &= ~SGTL5000_HP_POWERUP;
+		reg &= ~SGTL5000_LINE_OUT_POWERUP;
+		sgtl5000_write(codec, SGTL5000_CHIP_ANA_POWER, reg);
+
+		reg = sgtl5000_read(codec, SGTL5000_CHIP_DIG_POWER);
+		reg &= ~SGTL5000_DAC_EN;
+		sgtl5000_write(codec, SGTL5000_CHIP_DIG_POWER, reg);
+
+		break;
+
+	case SND_SOC_BIAS_OFF:	/* Off, without power */
+		/* must power down hp/line out after vag & dac to
+		   avoid pops. */
+		reg = sgtl5000_read(codec, SGTL5000_CHIP_ANA_POWER);
+		ana_pwr = reg;
+		reg &= ~SGTL5000_VAG_POWERUP;
+
+		/* Workaround for sgtl5000 rev 0x11 chip audio suspend failure
+		   issue on mx25 */
+		/* reg &= ~SGTL5000_REFTOP_POWERUP; */
+
+		sgtl5000_write(codec, SGTL5000_CHIP_ANA_POWER, reg);
+		msleep(600);
+
+		reg &= ~SGTL5000_HP_POWERUP;
+		reg &= ~SGTL5000_LINE_OUT_POWERUP;
+		reg &= ~SGTL5000_DAC_POWERUP;
+		reg &= ~SGTL5000_ADC_POWERUP;
+		sgtl5000_write(codec, SGTL5000_CHIP_ANA_POWER, reg);
+
+		/* save ANA POWER register value for resume */
+		sgtl5000_write_reg_cache(codec, SGTL5000_CHIP_ANA_POWER,
+					 ana_pwr);
+		break;
+	}
+	codec->bias_level = level;
+	return 0;
+}
+
+#define SGTL5000_RATES (SNDRV_PCM_RATE_32000 |\
+		      SNDRV_PCM_RATE_44100 |\
+		      SNDRV_PCM_RATE_48000 |\
+		      SNDRV_PCM_RATE_96000)
+
+#define SGTL5000_FORMATS (SNDRV_PCM_FMTBIT_S16_LE |\
+			SNDRV_PCM_FMTBIT_S20_3LE |\
+			SNDRV_PCM_FMTBIT_S24_LE)
+
+struct snd_soc_dai_ops sgtl5000_ops = {
+	.prepare = sgtl5000_pcm_prepare,
+	.startup = sgtl5000_pcm_startup,
+	.shutdown = sgtl5000_pcm_shutdown,
+	.hw_params = sgtl5000_pcm_hw_params,
+	.digital_mute = sgtl5000_digital_mute,
+	.set_fmt = sgtl5000_set_dai_fmt,
+	.set_sysclk = sgtl5000_set_dai_sysclk
+};
+
+struct snd_soc_dai sgtl5000_dai = {
+	.name = "SGTL5000",
+	.playback = {
+		     .stream_name = "Playback",
+		     .channels_min = 2,
+		     .channels_max = 2,
+		     .rates = SGTL5000_RATES,
+		     .formats = SGTL5000_FORMATS,
+		     },
+	.capture = {
+		    .stream_name = "Capture",
+		    .channels_min = 1,
+		    .channels_max = 2,
+		    .rates = SGTL5000_RATES,
+		    .formats = SGTL5000_FORMATS,
+		    },
+	.ops = &sgtl5000_ops,
+	.symmetric_rates = 1,
+};
+EXPORT_SYMBOL_GPL(sgtl5000_dai);
+
+static int sgtl5000_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->card->codec;
+
+	sgtl5000_set_bias_level(codec, SND_SOC_BIAS_OFF);
+
+	return 0;
+}
+
+static int sgtl5000_resume(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->card->codec;
+	unsigned int i;
+
+	/* Restore refs first in same order as in sgtl5000_init */
+	sgtl5000_restore_reg(codec, SGTL5000_CHIP_LINREG_CTRL);
+	sgtl5000_restore_reg(codec, SGTL5000_CHIP_ANA_POWER);
+	msleep(10);
+	sgtl5000_restore_reg(codec, SGTL5000_CHIP_REF_CTRL);
+	sgtl5000_restore_reg(codec, SGTL5000_CHIP_LINE_OUT_CTRL);
+
+	/* Restore everythine else */
+	for (i = 1; i < sizeof(all_reg) / sizeof(int); i++)
+		sgtl5000_restore_reg(codec, all_reg[i]);
+
+	sgtl5000_write(codec, SGTL5000_DAP_CTRL, 0);
+
+	/* Bring the codec back up to standby first to minimise pop/clicks */
+	sgtl5000_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+	if (codec->suspend_bias_level == SND_SOC_BIAS_ON)
+		sgtl5000_set_bias_level(codec, SND_SOC_BIAS_PREPARE);
+	sgtl5000_set_bias_level(codec, codec->suspend_bias_level);
+
+	return 0;
+}
+
+static struct snd_soc_codec *sgtl5000_codec;
+
+/*
+ * initialise the SGTL5000 driver
+ * register the mixer and dsp interfaces with the kernel
+ */
+static int sgtl5000_probe(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = sgtl5000_codec;
+	struct sgtl5000_priv *sgtl5000 = codec->private_data;
+	u16 reg, ana_pwr, lreg_ctrl, ref_ctrl, lo_ctrl, short_ctrl, sss;
+	int vag;
+	int ret = 0;
+
+	socdev->card->codec = sgtl5000_codec;
+
+	/* register pcms */
+	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
+	if (ret < 0) {
+		dev_err(codec->dev, "failed to create pcms\n");
+		return ret;
+	}
+
+	/* reset value */
+	ana_pwr = SGTL5000_DAC_STEREO |
+	    SGTL5000_LINREG_SIMPLE_POWERUP |
+	    SGTL5000_STARTUP_POWERUP |
+	    SGTL5000_ADC_STEREO | SGTL5000_REFTOP_POWERUP;
+	lreg_ctrl = 0;
+	ref_ctrl = 0;
+	lo_ctrl = 0;
+	short_ctrl = 0;
+	sss = SGTL5000_DAC_SEL_I2S_IN << SGTL5000_DAC_SEL_SHIFT;
+
+	/* workaround for rev 0x11: use vddd linear regulator */
+	if (!sgtl5000->vddd || (sgtl5000->rev >= 0x11)) {
+		/* set VDDD to 1.2v */
+		lreg_ctrl |= 0x8 << SGTL5000_LINREG_VDDD_SHIFT;
+		/* power internal linear regulator */
+		ana_pwr |= SGTL5000_LINEREG_D_POWERUP;
+	} else {
+		/* turn of startup power */
+		ana_pwr &= ~SGTL5000_STARTUP_POWERUP;
+		ana_pwr &= ~SGTL5000_LINREG_SIMPLE_POWERUP;
+	}
+	if (sgtl5000->vddio < 3100 && sgtl5000->vdda < 3100) {
+		/* Enable VDDC charge pump */
+		ana_pwr |= SGTL5000_VDDC_CHRGPMP_POWERUP;
+	}
+	if (sgtl5000->vddio >= 3100 && sgtl5000->vdda >= 3100) {
+		/* VDDC use VDDIO rail */
+		lreg_ctrl |= SGTL5000_VDDC_ASSN_OVRD;
+		if (sgtl5000->vddio >= 3100)
+			lreg_ctrl |= SGTL5000_VDDC_MAN_ASSN_VDDIO <<
+			    SGTL5000_VDDC_MAN_ASSN_SHIFT;
+	}
+	/* If PLL is powered up (such as on power cycle) leave it on. */
+	reg = sgtl5000_read(codec, SGTL5000_CHIP_ANA_POWER);
+	ana_pwr |= reg & (SGTL5000_PLL_POWERUP | SGTL5000_VCOAMP_POWERUP);
+
+	/* set ADC/DAC ref voltage to vdda/2 */
+	vag = sgtl5000->vdda / 2;
+	if (vag <= SGTL5000_ANA_GND_BASE)
+		vag = 0;
+	else if (vag >= SGTL5000_ANA_GND_BASE + SGTL5000_ANA_GND_STP *
+		 (SGTL5000_ANA_GND_MASK >> SGTL5000_ANA_GND_SHIFT))
+		vag = SGTL5000_ANA_GND_MASK >> SGTL5000_ANA_GND_SHIFT;
+	else
+		vag = (vag - SGTL5000_ANA_GND_BASE) / SGTL5000_ANA_GND_STP;
+	ref_ctrl |= vag << SGTL5000_ANA_GND_SHIFT;
+
+	/* set line out ref voltage to vddio/2 */
+	vag = sgtl5000->vddio / 2;
+	if (vag <= SGTL5000_LINE_OUT_GND_BASE)
+		vag = 0;
+	else if (vag >= SGTL5000_LINE_OUT_GND_BASE + SGTL5000_LINE_OUT_GND_STP *
+		 SGTL5000_LINE_OUT_GND_MAX)
+		vag = SGTL5000_LINE_OUT_GND_MAX;
+	else
+		vag = (vag - SGTL5000_LINE_OUT_GND_BASE) /
+		    SGTL5000_LINE_OUT_GND_STP;
+	lo_ctrl |= vag << SGTL5000_LINE_OUT_GND_SHIFT;
+
+	/* enable small pop */
+	ref_ctrl |= SGTL5000_SMALL_POP;
+
+	/* Controls the output bias current for the lineout */
+	lo_ctrl |=
+	    (SGTL5000_LINE_OUT_CURRENT_360u << SGTL5000_LINE_OUT_CURRENT_SHIFT);
+
+	/* set short detect */
+	/* keep default */
+
+	/* set routing */
+	/* keep default, bypass DAP */
+
+	sgtl5000_write(codec, SGTL5000_CHIP_LINREG_CTRL, lreg_ctrl);
+	sgtl5000_write(codec, SGTL5000_CHIP_ANA_POWER, ana_pwr);
+	msleep(10);
+
+	/* For rev 0x11, if vddd linear reg has been enabled, we have
+	   to disable simple reg to get proper VDDD voltage.  */
+	if ((ana_pwr & SGTL5000_LINEREG_D_POWERUP) && (sgtl5000->rev >= 0x11)) {
+		ana_pwr &= ~SGTL5000_LINREG_SIMPLE_POWERUP;
+		sgtl5000_write(codec, SGTL5000_CHIP_ANA_POWER, ana_pwr);
+		msleep(10);
+	}
+
+	sgtl5000_write(codec, SGTL5000_CHIP_REF_CTRL, ref_ctrl);
+	sgtl5000_write(codec, SGTL5000_CHIP_LINE_OUT_CTRL, lo_ctrl);
+	sgtl5000_write(codec, SGTL5000_CHIP_SHORT_CTRL, short_ctrl);
+	sgtl5000_write(codec, SGTL5000_CHIP_SSS_CTRL, sss);
+	sgtl5000_write(codec, SGTL5000_CHIP_DIG_POWER, 0);
+
+	reg = SGTL5000_DAC_VOL_RAMP_EN |
+	    SGTL5000_DAC_MUTE_RIGHT | SGTL5000_DAC_MUTE_LEFT;
+	sgtl5000_write(codec, SGTL5000_CHIP_ADCDAC_CTRL, reg);
+
+	if (cpu_is_mx25())
+		sgtl5000_write(codec, SGTL5000_CHIP_PAD_STRENGTH, 0x01df);
+	else
+		sgtl5000_write(codec, SGTL5000_CHIP_PAD_STRENGTH, 0x015f);
+
+	reg = sgtl5000_read(codec, SGTL5000_CHIP_ANA_ADC_CTRL);
+	reg &= ~SGTL5000_ADC_VOL_M6DB;
+	reg &= ~(SGTL5000_ADC_VOL_LEFT_MASK | SGTL5000_ADC_VOL_RIGHT_MASK);
+	reg |= (0xf << SGTL5000_ADC_VOL_LEFT_SHIFT)
+	    | (0xf << SGTL5000_ADC_VOL_RIGHT_SHIFT);
+	sgtl5000_write(codec, SGTL5000_CHIP_ANA_ADC_CTRL, reg);
+
+	reg = SGTL5000_LINE_OUT_MUTE | SGTL5000_HP_MUTE |
+	    SGTL5000_HP_ZCD_EN | SGTL5000_ADC_ZCD_EN;
+	sgtl5000_write(codec, SGTL5000_CHIP_ANA_CTRL, reg);
+
+	sgtl5000_write(codec, SGTL5000_CHIP_MIC_CTRL, 0);
+	sgtl5000_write(codec, SGTL5000_CHIP_CLK_TOP_CTRL, 0);
+	/* disable DAP */
+	sgtl5000_write(codec, SGTL5000_DAP_CTRL, 0);
+	/* TODO: initialize DAP */
+
+	snd_soc_add_controls(codec, sgtl5000_snd_controls,
+			     ARRAY_SIZE(sgtl5000_snd_controls));
+	sgtl5000_add_widgets(codec);
+
+	sgtl5000_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+
+	return 0;
+}
+
+/* power down chip */
+static int sgtl5000_remove(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->card->codec;
+
+	if (codec->control_data)
+		sgtl5000_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	snd_soc_free_pcms(socdev);
+	snd_soc_dapm_free(socdev);
+
+	return 0;
+}
+
+struct snd_soc_codec_device soc_codec_dev_sgtl5000 = {
+	.probe = sgtl5000_probe,
+	.remove = sgtl5000_remove,
+	.suspend = sgtl5000_suspend,
+	.resume = sgtl5000_resume,
+};
+EXPORT_SYMBOL_GPL(soc_codec_dev_sgtl5000);
+
+static __devinit int sgtl5000_i2c_probe(struct i2c_client *client,
+					const struct i2c_device_id *id)
+{
+	struct sgtl5000_priv *sgtl5000;
+	struct snd_soc_codec *codec;
+	struct regulator *reg;
+	int ret = 0;
+	u32 val;
+
+	if (sgtl5000_codec) {
+		dev_err(&client->dev,
+			"Multiple SGTL5000 devices not supported\n");
+		return -ENOMEM;
+	}
+
+	codec = kzalloc(sizeof(struct snd_soc_codec), GFP_KERNEL);
+	if (codec == NULL)
+		return -ENOMEM;
+
+	sgtl5000 = kzalloc(sizeof(struct sgtl5000_priv), GFP_KERNEL);
+	if (sgtl5000 == NULL) {
+		kfree(codec);
+		return -ENOMEM;
+	}
+
+	codec->private_data = sgtl5000;
+	mutex_init(&codec->mutex);
+	INIT_LIST_HEAD(&codec->dapm_widgets);
+	INIT_LIST_HEAD(&codec->dapm_paths);
+
+	i2c_set_clientdata(client, codec);
+	codec->control_data = client;
+
+	reg = regulator_get(&client->dev, "VDDIO");
+	if (!IS_ERR(reg))
+		sgtl5000->reg_vddio = reg;
+
+	reg = regulator_get(&client->dev, "VDDA");
+	if (!IS_ERR(reg))
+		sgtl5000->reg_vdda = reg;
+
+	reg = regulator_get(&client->dev, "VDDD");
+	if (!IS_ERR(reg))
+		sgtl5000->reg_vddd = reg;
+
+	if (sgtl5000->reg_vdda) {
+		sgtl5000->vdda =
+		    regulator_get_voltage(sgtl5000->reg_vdda) / 1000;
+		regulator_enable(sgtl5000->reg_vdda);
+	}
+	if (sgtl5000->reg_vddio) {
+		sgtl5000->vddio =
+		    regulator_get_voltage(sgtl5000->reg_vddio) / 1000;
+		regulator_enable(sgtl5000->reg_vddio);
+	}
+	if (sgtl5000->reg_vddd) {
+		sgtl5000->vddd =
+		    regulator_get_voltage(sgtl5000->reg_vddd) / 1000;
+		regulator_enable(sgtl5000->reg_vddd);
+	} else {
+		sgtl5000->vddd = 0; /* use internal regulator */
+	}
+
+	msleep(1);
+
+	val = sgtl5000_read(codec, SGTL5000_CHIP_ID);
+	if (((val & SGTL5000_PARTID_MASK) >> SGTL5000_PARTID_SHIFT) !=
+	    SGTL5000_PARTID_PART_ID) {
+		pr_err("Device with ID register %x is not a SGTL5000\n", val);
+		ret = -ENODEV;
+		goto err_codec_reg;
+	}
+
+	sgtl5000->rev = (val & SGTL5000_REVID_MASK) >> SGTL5000_REVID_SHIFT;
+	dev_info(&client->dev, "SGTL5000 revision %d\n", sgtl5000->rev);
+
+	codec->dev = &client->dev;
+	codec->name = "SGTL5000";
+	codec->owner = THIS_MODULE;
+	codec->read = sgtl5000_read_reg_cache;
+	codec->write = sgtl5000_write;
+	codec->bias_level = SND_SOC_BIAS_OFF;
+	codec->set_bias_level = sgtl5000_set_bias_level;
+	codec->dai = &sgtl5000_dai;
+	codec->num_dai = 1;
+	codec->reg_cache_size = sizeof(sgtl5000_regs);
+	codec->reg_cache_step = 2;
+	codec->reg_cache = (void *)&sgtl5000_regs;
+
+	sgtl5000_sync_reg_cache(codec);
+
+	sgtl5000_codec = codec;
+	sgtl5000_dai.dev = &client->dev;
+
+	ret = snd_soc_register_codec(codec);
+	if (ret != 0) {
+		dev_err(codec->dev, "Failed to register codec: %d\n", ret);
+		goto err_codec_reg;
+	}
+
+	ret = snd_soc_register_dai(&sgtl5000_dai);
+	if (ret != 0) {
+		dev_err(codec->dev, "Failed to register DAIs: %d\n", ret);
+		goto err_codec_reg;
+	}
+
+	return 0;
+
+err_codec_reg:
+	if (sgtl5000->reg_vddd)
+		regulator_disable(sgtl5000->reg_vddd);
+	if (sgtl5000->reg_vdda)
+		regulator_disable(sgtl5000->reg_vdda);
+	if (sgtl5000->reg_vddio)
+		regulator_disable(sgtl5000->reg_vddio);
+	if (sgtl5000->reg_vddd)
+		regulator_put(sgtl5000->reg_vddd);
+	if (sgtl5000->reg_vdda)
+		regulator_put(sgtl5000->reg_vdda);
+	if (sgtl5000->reg_vddio)
+		regulator_put(sgtl5000->reg_vddio);
+	kfree(sgtl5000);
+	kfree(codec);
+	return ret;
+}
+
+static __devexit int sgtl5000_i2c_remove(struct i2c_client *client)
+{
+	struct snd_soc_codec *codec = i2c_get_clientdata(client);
+	struct sgtl5000_priv *sgtl5000 = codec->private_data;
+
+	snd_soc_unregister_dai(&sgtl5000_dai);
+	snd_soc_unregister_codec(codec);
+
+	if (sgtl5000->reg_vddio) {
+		regulator_disable(sgtl5000->reg_vddio);
+		regulator_put(sgtl5000->reg_vddio);
+	}
+	if (sgtl5000->reg_vddd) {
+		regulator_disable(sgtl5000->reg_vddd);
+		regulator_put(sgtl5000->reg_vddd);
+	}
+	if (sgtl5000->reg_vdda) {
+		regulator_disable(sgtl5000->reg_vdda);
+		regulator_put(sgtl5000->reg_vdda);
+	}
+
+	kfree(codec);
+	kfree(sgtl5000);
+	sgtl5000_codec = NULL;
+	return 0;
+}
+
+static const struct i2c_device_id sgtl5000_id[] = {
+	{"sgtl5000-i2c", 0},
+	{},
+};
+
+MODULE_DEVICE_TABLE(i2c, sgtl5000_id);
+
+static struct i2c_driver sgtl5000_i2c_driver = {
+	.driver = {
+		   .name = "sgtl5000-i2c",
+		   .owner = THIS_MODULE,
+		   },
+	.probe = sgtl5000_i2c_probe,
+	.remove = __devexit_p(sgtl5000_i2c_remove),
+	.id_table = sgtl5000_id,
+};
+
+static int __init sgtl5000_modinit(void)
+{
+	return i2c_add_driver(&sgtl5000_i2c_driver);
+}
+module_init(sgtl5000_modinit);
+
+static void __exit sgtl5000_exit(void)
+{
+	i2c_del_driver(&sgtl5000_i2c_driver);
+}
+module_exit(sgtl5000_exit);
+
+MODULE_DESCRIPTION("ASoC SGTL5000 driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/sgtl5000.h b/sound/soc/codecs/sgtl5000.h
new file mode 100644
index 0000000..e37b124
--- /dev/null
+++ b/sound/soc/codecs/sgtl5000.h
@@ -0,0 +1,399 @@
+/*
+ * sgtl5000.h - SGTL5000 audio codec interface
+ *
+ * Copyright 2008-2009 Freescale Semiconductor, Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ */
+
+#ifndef _SGTL5000_H
+#define _SGTL5000_H
+
+#include <linux/i2c.h>
+
+extern struct snd_soc_dai sgtl5000_dai;
+extern struct snd_soc_codec_device soc_codec_dev_sgtl5000;
+
+/*
+ * Register values.
+ */
+#define SGTL5000_CHIP_ID			0x0000
+#define SGTL5000_CHIP_DIG_POWER			0x0002
+#define SGTL5000_CHIP_CLK_CTRL			0x0004
+#define SGTL5000_CHIP_I2S_CTRL			0x0006
+#define SGTL5000_CHIP_SSS_CTRL			0x000a
+#define SGTL5000_CHIP_ADCDAC_CTRL		0x000e
+#define SGTL5000_CHIP_DAC_VOL			0x0010
+#define SGTL5000_CHIP_PAD_STRENGTH		0x0014
+#define SGTL5000_CHIP_ANA_ADC_CTRL		0x0020
+#define SGTL5000_CHIP_ANA_HP_CTRL		0x0022
+#define SGTL5000_CHIP_ANA_CTRL			0x0024
+#define SGTL5000_CHIP_LINREG_CTRL		0x0026
+#define SGTL5000_CHIP_REF_CTRL			0x0028
+#define SGTL5000_CHIP_MIC_CTRL			0x002a
+#define SGTL5000_CHIP_LINE_OUT_CTRL		0x002c
+#define SGTL5000_CHIP_LINE_OUT_VOL		0x002e
+#define SGTL5000_CHIP_ANA_POWER			0x0030
+#define SGTL5000_CHIP_PLL_CTRL			0x0032
+#define SGTL5000_CHIP_CLK_TOP_CTRL		0x0034
+#define SGTL5000_CHIP_ANA_STATUS		0x0036
+#define SGTL5000_CHIP_SHORT_CTRL		0x003c
+#define SGTL5000_CHIP_ANA_TEST2			0x003a
+#define SGTL5000_DAP_CTRL			0x0100
+#define SGTL5000_DAP_PEQ			0x0102
+#define SGTL5000_DAP_BASS_ENHANCE		0x0104
+#define SGTL5000_DAP_BASS_ENHANCE_CTRL		0x0106
+#define SGTL5000_DAP_AUDIO_EQ			0x0108
+#define SGTL5000_DAP_SURROUND			0x010a
+#define SGTL5000_DAP_FLT_COEF_ACCESS		0x010c
+#define SGTL5000_DAP_COEF_WR_B0_MSB		0x010e
+#define SGTL5000_DAP_COEF_WR_B0_LSB		0x0110
+#define SGTL5000_DAP_EQ_BASS_BAND0		0x0116
+#define SGTL5000_DAP_EQ_BASS_BAND1		0x0118
+#define SGTL5000_DAP_EQ_BASS_BAND2		0x011a
+#define SGTL5000_DAP_EQ_BASS_BAND3		0x011c
+#define SGTL5000_DAP_EQ_BASS_BAND4		0x011e
+#define SGTL5000_DAP_MAIN_CHAN			0x0120
+#define SGTL5000_DAP_MIX_CHAN			0x0122
+#define SGTL5000_DAP_AVC_CTRL			0x0124
+#define SGTL5000_DAP_AVC_THRESHOLD		0x0126
+#define SGTL5000_DAP_AVC_ATTACK			0x0128
+#define SGTL5000_DAP_AVC_DECAY			0x012a
+#define SGTL5000_DAP_COEF_WR_B1_MSB		0x012c
+#define SGTL5000_DAP_COEF_WR_B1_LSB		0x012e
+#define SGTL5000_DAP_COEF_WR_B2_MSB		0x0130
+#define SGTL5000_DAP_COEF_WR_B2_LSB		0x0132
+#define SGTL5000_DAP_COEF_WR_A1_MSB		0x0134
+#define SGTL5000_DAP_COEF_WR_A1_LSB		0x0136
+#define SGTL5000_DAP_COEF_WR_A2_MSB		0x0138
+#define SGTL5000_DAP_COEF_WR_A2_LSB		0x013a
+
+/*
+ * Field Definitions.
+ */
+
+/*
+ * SGTL5000_CHIP_ID
+ */
+#define SGTL5000_PARTID_MASK			0xff00
+#define SGTL5000_PARTID_SHIFT			8
+#define SGTL5000_PARTID_WIDTH			8
+#define SGTL5000_PARTID_PART_ID		0xa0
+#define SGTL5000_REVID_MASK			0x00ff
+#define SGTL5000_REVID_SHIFT			0
+#define SGTL5000_REVID_WIDTH			8
+
+/*
+ * SGTL5000_CHIP_DIG_POWER
+ */
+#define SGTL5000_ADC_EN				0x0040
+#define SGTL5000_DAC_EN				0x0020
+#define SGTL5000_DAP_POWERUP			0x0010
+#define SGTL5000_I2S_OUT_POWERUP		0x0002
+#define SGTL5000_I2S_IN_POWERUP			0x0001
+
+/*
+ * SGTL5000_CHIP_CLK_CTRL
+ */
+#define SGTL5000_SYS_FS_MASK			0x00c0
+#define SGTL5000_SYS_FS_SHIFT			2
+#define SGTL5000_SYS_FS_WIDTH			2
+#define SGTL5000_SYS_FS_32k			0x0
+#define SGTL5000_SYS_FS_44_1k			0x1
+#define SGTL5000_SYS_FS_48k			0x2
+#define SGTL5000_SYS_FS_96k			0x3
+#define SGTL5000_MCLK_FREQ_MASK			0x0003
+#define SGTL5000_MCLK_FREQ_SHIFT		0
+#define SGTL5000_MCLK_FREQ_WIDTH		2
+#define SGTL5000_MCLK_FREQ_256FS		0x0
+#define SGTL5000_MCLK_FREQ_384FS		0x1
+#define SGTL5000_MCLK_FREQ_512FS		0x2
+#define SGTL5000_MCLK_FREQ_PLL			0x3
+
+/*
+ * SGTL5000_CHIP_I2S_CTRL
+ */
+#define SGTL5000_I2S_SCLKFREQ_MASK		0x0100
+#define SGTL5000_I2S_SCLKFREQ_SHIFT		8
+#define SGTL5000_I2S_SCLKFREQ_WIDTH		1
+#define SGTL5000_I2S_SCLKFREQ_64FS		0x0
+#define SGTL5000_I2S_SCLKFREQ_32FS		0x1	/* Not for RJ mode */
+#define SGTL5000_I2S_MASTER			0x0080
+#define SGTL5000_I2S_SCLK_INV			0x0040
+#define SGTL5000_I2S_DLEN_MASK			0x0030
+#define SGTL5000_I2S_DLEN_SHIFT			4
+#define SGTL5000_I2S_DLEN_WIDTH			2
+#define SGTL5000_I2S_DLEN_32			0x0
+#define SGTL5000_I2S_DLEN_24			0x1
+#define SGTL5000_I2S_DLEN_20			0x2
+#define SGTL5000_I2S_DLEN_16			0x3
+#define SGTL5000_I2S_MODE_MASK			0x000c
+#define SGTL5000_I2S_MODE_SHIFT			2
+#define SGTL5000_I2S_MODE_WIDTH			2
+#define SGTL5000_I2S_MODE_I2S_LJ		0x0
+#define SGTL5000_I2S_MODE_RJ			0x1
+#define SGTL5000_I2S_MODE_PCM			0x2
+#define SGTL5000_I2S_LRALIGN			0x0002
+#define SGTL5000_I2S_LRPOL			0x0001	/* set for which mode */
+
+/*
+ * SGTL5000_CHIP_SSS_CTRL
+ */
+#define SGTL5000_DAP_MIX_LRSWAP			0x4000
+#define SGTL5000_DAP_LRSWAP			0x2000
+#define SGTL5000_DAC_LRSWAP			0x1000
+#define SGTL5000_I2S_OUT_LRSWAP			0x0400
+#define SGTL5000_DAP_MIX_SEL_MASK		0x0300
+#define SGTL5000_DAP_MIX_SEL_SHIFT		8
+#define SGTL5000_DAP_MIX_SEL_WIDTH		2
+#define SGTL5000_DAP_MIX_SEL_ADC		0x0
+#define SGTL5000_DAP_MIX_SEL_I2S_IN		0x1
+#define SGTL5000_DAP_SEL_MASK			0x00c0
+#define SGTL5000_DAP_SEL_SHIFT			6
+#define SGTL5000_DAP_SEL_WIDTH			2
+#define SGTL5000_DAP_SEL_ADC			0x0
+#define SGTL5000_DAP_SEL_I2S_IN			0x1
+#define SGTL5000_DAC_SEL_MASK			0x0030
+#define SGTL5000_DAC_SEL_SHIFT			4
+#define SGTL5000_DAC_SEL_WIDTH			2
+#define SGTL5000_DAC_SEL_ADC			0x0
+#define SGTL5000_DAC_SEL_I2S_IN			0x1
+#define SGTL5000_DAC_SEL_DAP			0x3
+#define SGTL5000_I2S_OUT_SEL_MASK		0x0003
+#define SGTL5000_I2S_OUT_SEL_SHIFT		0
+#define SGTL5000_I2S_OUT_SEL_WIDTH		2
+#define SGTL5000_I2S_OUT_SEL_ADC		0x0
+#define SGTL5000_I2S_OUT_SEL_I2S_IN		0x1
+#define SGTL5000_I2S_OUT_SEL_DAP		0x3
+
+/*
+ * SGTL5000_CHIP_ADCDAC_CTRL
+ */
+#define SGTL5000_VOL_BUSY_DAC_RIGHT		0x2000
+#define SGTL5000_VOL_BUSY_DAC_LEFT		0x1000
+#define SGTL5000_DAC_VOL_RAMP_EN		0x0200
+#define SGTL5000_DAC_VOL_RAMP_EXPO		0x0100
+#define SGTL5000_DAC_MUTE_RIGHT			0x0008
+#define SGTL5000_DAC_MUTE_LEFT			0x0004
+#define SGTL5000_ADC_HPF_FREEZE			0x0002
+#define SGTL5000_ADC_HPF_BYPASS			0x0001
+
+/*
+ * SGTL5000_CHIP_DAC_VOL
+ */
+#define SGTL5000_DAC_VOL_RIGHT_MASK		0xff00
+#define SGTL5000_DAC_VOL_RIGHT_SHIFT		8
+#define SGTL5000_DAC_VOL_RIGHT_WIDTH		8
+#define SGTL5000_DAC_VOL_LEFT_MASK		0x00ff
+#define SGTL5000_DAC_VOL_LEFT_SHIFT		0
+#define SGTL5000_DAC_VOL_LEFT_WIDTH		8
+
+/*
+ * SGTL5000_CHIP_PAD_STRENGTH
+ */
+#define SGTL5000_PAD_I2S_LRCLK_MASK		0x0300
+#define SGTL5000_PAD_I2S_LRCLK_SHIFT		8
+#define SGTL5000_PAD_I2S_LRCLK_WIDTH		2
+#define SGTL5000_PAD_I2S_SCLK_MASK		0x00c0
+#define SGTL5000_PAD_I2S_SCLK_SHIFT		6
+#define SGTL5000_PAD_I2S_SCLK_WIDTH		2
+#define SGTL5000_PAD_I2S_DOUT_MASK		0x0030
+#define SGTL5000_PAD_I2S_DOUT_SHIFT		4
+#define SGTL5000_PAD_I2S_DOUT_WIDTH		2
+#define SGTL5000_PAD_I2C_SDA_MASK		0x000c
+#define SGTL5000_PAD_I2C_SDA_SHIFT		2
+#define SGTL5000_PAD_I2C_SDA_WIDTH		2
+#define SGTL5000_PAD_I2C_SCL_MASK		0x0003
+#define SGTL5000_PAD_I2C_SCL_SHIFT		0
+#define SGTL5000_PAD_I2C_SCL_WIDTH		2
+
+/*
+ * SGTL5000_CHIP_ANA_ADC_CTRL
+ */
+#define SGTL5000_ADC_VOL_M6DB			0x0100
+#define SGTL5000_ADC_VOL_RIGHT_MASK		0x00f0
+#define SGTL5000_ADC_VOL_RIGHT_SHIFT		4
+#define SGTL5000_ADC_VOL_RIGHT_WIDTH		4
+#define SGTL5000_ADC_VOL_LEFT_MASK		0x000f
+#define SGTL5000_ADC_VOL_LEFT_SHIFT		0
+#define SGTL5000_ADC_VOL_LEFT_WIDTH		4
+
+/*
+ * SGTL5000_CHIP_ANA_HP_CTRL
+ */
+#define SGTL5000_HP_VOL_RIGHT_MASK		0x7f00
+#define SGTL5000_HP_VOL_RIGHT_SHIFT		8
+#define SGTL5000_HP_VOL_RIGHT_WIDTH		7
+#define SGTL5000_HP_VOL_LEFT_MASK		0x007f
+#define SGTL5000_HP_VOL_LEFT_SHIFT		0
+#define SGTL5000_HP_VOL_LEFT_WIDTH		7
+
+/*
+ * SGTL5000_CHIP_ANA_CTRL
+ */
+#define SGTL5000_LINE_OUT_MUTE		0x0100
+#define SGTL5000_HP_SEL_MASK			0x0040
+#define SGTL5000_HP_SEL_SHIFT			6
+#define SGTL5000_HP_SEL_WIDTH			1
+#define SGTL5000_HP_SEL_DAC			0x0
+#define SGTL5000_HP_SEL_LINE_IN			0x1
+#define SGTL5000_HP_ZCD_EN			0x0020
+#define SGTL5000_HP_MUTE			0x0010
+#define SGTL5000_ADC_SEL_MASK			0x0004
+#define SGTL5000_ADC_SEL_SHIFT			2
+#define SGTL5000_ADC_SEL_WIDTH			1
+#define SGTL5000_ADC_SEL_MIC			0x0
+#define SGTL5000_ADC_SEL_LINE_IN		0x1
+#define SGTL5000_ADC_ZCD_EN			0x0002
+#define SGTL5000_ADC_MUTE			0x0001
+
+/*
+ * SGTL5000_CHIP_LINREG_CTRL
+ */
+#define SGTL5000_VDDC_MAN_ASSN_MASK		0x0040
+#define SGTL5000_VDDC_MAN_ASSN_SHIFT		6
+#define SGTL5000_VDDC_MAN_ASSN_WIDTH		1
+#define SGTL5000_VDDC_MAN_ASSN_VDDA		0x0
+#define SGTL5000_VDDC_MAN_ASSN_VDDIO		0x1
+#define SGTL5000_VDDC_ASSN_OVRD			0x0020
+#define SGTL5000_LINREG_VDDD_MASK		0x000f
+#define SGTL5000_LINREG_VDDD_SHIFT		0
+#define SGTL5000_LINREG_VDDD_WIDTH		4
+
+/*
+ * SGTL5000_CHIP_REF_CTRL
+ */
+#define SGTL5000_ANA_GND_MASK			0x01f0
+#define SGTL5000_ANA_GND_SHIFT			4
+#define SGTL5000_ANA_GND_WIDTH			5
+#define SGTL5000_ANA_GND_BASE			800	/* mv */
+#define SGTL5000_ANA_GND_STP			25	/*mv */
+#define SGTL5000_BIAS_CTRL_MASK			0x000e
+#define SGTL5000_BIAS_CTRL_SHIFT		1
+#define SGTL5000_BIAS_CTRL_WIDTH		3
+#define SGTL5000_SMALL_POP			0x0001
+
+/*
+ * SGTL5000_CHIP_MIC_CTRL
+ */
+#define SGTL5000_BIAS_R_MASK			0x0200
+#define SGTL5000_BIAS_R_SHIFT			8
+#define SGTL5000_BIAS_R_WIDTH			2
+#define SGTL5000_BIAS_R_off			0x0
+#define SGTL5000_BIAS_R_2K			0x1
+#define SGTL5000_BIAS_R_4k			0x2
+#define SGTL5000_BIAS_R_8k			0x3
+#define SGTL5000_BIAS_VOLT_MASK			0x0070
+#define SGTL5000_BIAS_VOLT_SHIFT		4
+#define SGTL5000_BIAS_VOLT_WIDTH		3
+#define SGTL5000_MIC_GAIN_MASK			0x0003
+#define SGTL5000_MIC_GAIN_SHIFT			0
+#define SGTL5000_MIC_GAIN_WIDTH			2
+
+/*
+ * SGTL5000_CHIP_LINE_OUT_CTRL
+ */
+#define SGTL5000_LINE_OUT_CURRENT_MASK		0x0f00
+#define SGTL5000_LINE_OUT_CURRENT_SHIFT		8
+#define SGTL5000_LINE_OUT_CURRENT_WIDTH		4
+#define SGTL5000_LINE_OUT_CURRENT_180u		0x0
+#define SGTL5000_LINE_OUT_CURRENT_270u		0x1
+#define SGTL5000_LINE_OUT_CURRENT_360u		0x3
+#define SGTL5000_LINE_OUT_CURRENT_450u		0x7
+#define SGTL5000_LINE_OUT_CURRENT_540u		0xf
+#define SGTL5000_LINE_OUT_GND_MASK		0x003f
+#define SGTL5000_LINE_OUT_GND_SHIFT		0
+#define SGTL5000_LINE_OUT_GND_WIDTH		6
+#define SGTL5000_LINE_OUT_GND_BASE		800	/* mv */
+#define SGTL5000_LINE_OUT_GND_STP		25
+#define SGTL5000_LINE_OUT_GND_MAX		0x23
+
+/*
+ * SGTL5000_CHIP_LINE_OUT_VOL
+ */
+#define SGTL5000_LINE_OUT_VOL_RIGHT_MASK	0x1f00
+#define SGTL5000_LINE_OUT_VOL_RIGHT_SHIFT	8
+#define SGTL5000_LINE_OUT_VOL_RIGHT_WIDTH	5
+#define SGTL5000_LINE_OUT_VOL_LEFT_MASK		0x001f
+#define SGTL5000_LINE_OUT_VOL_LEFT_SHIFT	0
+#define SGTL5000_LINE_OUT_VOL_LEFT_WIDTH	5
+
+/*
+ * SGTL5000_CHIP_ANA_POWER
+ */
+#define SGTL5000_DAC_STEREO			0x4000
+#define SGTL5000_LINREG_SIMPLE_POWERUP		0x2000
+#define SGTL5000_STARTUP_POWERUP		0x1000
+#define SGTL5000_VDDC_CHRGPMP_POWERUP		0x0800
+#define SGTL5000_PLL_POWERUP			0x0400
+#define SGTL5000_LINEREG_D_POWERUP		0x0200
+#define SGTL5000_VCOAMP_POWERUP			0x0100
+#define SGTL5000_VAG_POWERUP			0x0080
+#define SGTL5000_ADC_STEREO			0x0040
+#define SGTL5000_REFTOP_POWERUP			0x0020
+#define SGTL5000_HP_POWERUP			0x0010
+#define SGTL5000_DAC_POWERUP			0x0008
+#define SGTL5000_CAPLESS_HP_POWERUP		0x0004
+#define SGTL5000_ADC_POWERUP			0x0002
+#define SGTL5000_LINE_OUT_POWERUP		0x0001
+
+/*
+ * SGTL5000_CHIP_PLL_CTRL
+ */
+#define SGTL5000_PLL_INT_DIV_MASK		0xf800
+#define SGTL5000_PLL_INT_DIV_SHIFT		11
+#define SGTL5000_PLL_INT_DIV_WIDTH		5
+#define SGTL5000_PLL_FRAC_DIV_MASK		0x0700
+#define SGTL5000_PLL_FRAC_DIV_SHIFT		0
+#define SGTL5000_PLL_FRAC_DIV_WIDTH		11
+
+/*
+ * SGTL5000_CHIP_CLK_TOP_CTRL
+ */
+#define SGTL5000_INT_OSC_EN			0x0800
+#define SGTL5000_INPUT_FREQ_DIV2		0x0008
+
+/*
+ * SGTL5000_CHIP_ANA_STATUS
+ */
+#define SGTL5000_HP_LRSHORT			0x0200
+#define SGTL5000_CAPLESS_SHORT			0x0100
+#define SGTL5000_PLL_LOCKED			0x0010
+
+/*
+ * SGTL5000_CHIP_SHORT_CTRL
+ */
+#define SGTL5000_LVLADJR_MASK			0x7000
+#define SGTL5000_LVLADJR_SHIFT			12
+#define SGTL5000_LVLADJR_WIDTH			3
+#define SGTL5000_LVLADJL_MASK			0x0700
+#define SGTL5000_LVLADJL_SHIFT			8
+#define SGTL5000_LVLADJL_WIDTH			3
+#define SGTL5000_LVLADJC_MASK			0x0070
+#define SGTL5000_LVLADJC_SHIFT			4
+#define SGTL5000_LVLADJC_WIDTH			3
+#define SGTL5000_LR_SHORT_MOD_MASK		0x000c
+#define SGTL5000_LR_SHORT_MOD_SHIFT		2
+#define SGTL5000_LR_SHORT_MOD_WIDTH		2
+#define SGTL5000_CM_SHORT_MOD_MASK		0x0003
+#define SGTL5000_CM_SHORT_MOD_SHIFT		0
+#define SGTL5000_CM_SHORT_MOD_WIDTH		2
+
+/*
+ *SGTL5000_CHIP_ANA_TEST2
+ */
+#define SGTL5000_MONO_DAC			0x1000
+
+/*
+ * SGTL5000_DAP_CTRL
+ */
+#define SGTL5000_DAP_MIX_EN			0x0010
+#define SGTL5000_DAP_EN				0x0001
+
+#define SGTL5000_SYSCLK		0x00
+#define SGTL5000_LRCLK		0x01
+
+#endif
diff --git a/sound/soc/imx/Kconfig b/sound/soc/imx/Kconfig
index 7174b4c..14c247e 100644
--- a/sound/soc/imx/Kconfig
+++ b/sound/soc/imx/Kconfig
@@ -11,3 +11,24 @@ config SND_IMX_SOC
 config SND_MXC_SOC_SSI
 	tristate
 
+config SND_MXC_SOC
+	tristate "SoC Audio for the Freescale MXC CPU"
+	depends on ARCH_MXC && SND
+	select SND_PCM
+	help
+	  Say Y or M if you want to add support for codecs attached to
+	  the MXC I2S or SSP interface. You will also need
+	  to select the audio interfaces to support below.
+
+config SND_MXC_SOC_IRAM
+	bool "Locate Audio DMA playback buffers in IRAM"
+	help
+	  Say Y if you don't want Audio playback buffers in external ram
+
+config SND_SOC_IMX_3STACK_SGTL5000
+	tristate "SoC Audio support for IMX - SGTL5000"
+	select SND_MXC_SOC_SSI
+	select SND_SOC_SGTL5000
+	help
+	  Say Y if you want to add support for SoC audio on IMX 3STACK
+	  with the SGTL5000.
diff --git a/sound/soc/imx/Makefile b/sound/soc/imx/Makefile
index 9f8bb92..828b918 100644
--- a/sound/soc/imx/Makefile
+++ b/sound/soc/imx/Makefile
@@ -1,12 +1,18 @@
 # i.MX Platform Support
 snd-soc-imx-objs := imx-ssi.o imx-pcm-fiq.o
+snd-soc-mxc-objs := imx-pcm.o
+snd-soc-mxc-ssi-objs := mxc-ssi.o
 
 ifdef CONFIG_MACH_MX27
 snd-soc-imx-objs += imx-pcm-dma-mx2.o
 endif
 
 obj-$(CONFIG_SND_IMX_SOC) += snd-soc-imx.o
+obj-$(CONFIG_SND_MXC_SOC) += snd-soc-mxc.o
+obj-$(CONFIG_SND_MXC_SOC_SSI) += snd-soc-mxc-ssi.o
 
 # i.MX Machine Support
 snd-soc-phycore-ac97-objs := phycore-ac97.o
 obj-$(CONFIG_SND_SOC_PHYCORE_AC97) += snd-soc-phycore-ac97.o
+snd-soc-imx-3stack-sgtl5000-objs := imx-3stack-sgtl5000.o
+obj-$(CONFIG_SND_SOC_IMX_3STACK_SGTL5000) += snd-soc-imx-3stack-sgtl5000.o
diff --git a/sound/soc/imx/imx-3stack-sgtl5000.c b/sound/soc/imx/imx-3stack-sgtl5000.c
new file mode 100644
index 0000000..b703d83
--- /dev/null
+++ b/sound/soc/imx/imx-3stack-sgtl5000.c
@@ -0,0 +1,690 @@
+/*
+ * imx-3stack-sgtl5000.c  --  i.MX 3Stack Driver for Freescale SGTL5000 Codec
+ *
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    21th Oct 2008   Initial version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/bitops.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/err.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+
+#include <mach/dma.h>
+#include <mach/spba.h>
+#include <mach/clock.h>
+
+#include "../codecs/sgtl5000.h"
+#include "mxc-ssi.h"
+#include "imx-pcm.h"
+
+#if defined(CONFIG_MXC_ASRC) || defined(CONFIG_MXC_ASRC_MODULE)
+#include <linux/mxc_asrc.h>
+
+static unsigned int sgtl5000_rates[] = {
+	0,
+	32000,
+	44100,
+	48000,
+	96000,
+};
+
+struct asrc_esai {
+	unsigned int cpu_dai_rates;
+	unsigned int codec_dai_rates;
+	enum asrc_pair_index asrc_index;
+	unsigned int output_sample_rate;
+};
+
+static struct asrc_esai asrc_ssi_data;
+#endif
+
+/* SSI BCLK and LRC master */
+#define SGTL5000_SSI_MASTER	1
+
+struct imx_3stack_priv {
+	int sysclk;
+	int hw;
+	struct platform_device *pdev;
+};
+
+static struct imx_3stack_priv card_priv;
+
+static int imx_3stack_audio_hw_params(struct snd_pcm_substream *substream,
+				      struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai_link *machine = rtd->dai;
+	struct snd_soc_dai *cpu_dai = machine->cpu_dai;
+	struct snd_soc_dai *codec_dai = machine->codec_dai;
+	struct imx_3stack_priv *priv = &card_priv;
+	unsigned int rate = params_rate(params);
+	struct imx_ssi *ssi_mode = (struct imx_ssi *)cpu_dai->private_data;
+	int ret = 0;
+
+	unsigned int channels = params_channels(params);
+	u32 dai_format;
+
+	/* only need to do this once as capture and playback are sync */
+	if (priv->hw)
+		return 0;
+	priv->hw = 1;
+
+#if defined(CONFIG_MXC_ASRC) || defined(CONFIG_MXC_ASRC_MODULE)
+	if ((asrc_ssi_data.output_sample_rate != 0)
+	    && (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)) {
+		unsigned int asrc_input_rate = rate;
+		unsigned int channel = params_channels(params);
+		struct mxc_runtime_data *pcm_data =
+		    substream->runtime->private_data;
+		struct asrc_config config;
+		struct mxc_audio_platform_data *plat;
+		struct imx_3stack_priv *priv = &card_priv;
+		int retVal = 0;
+		retVal = asrc_req_pair(channel, &asrc_ssi_data.asrc_index);
+		if (retVal < 0) {
+			pr_err("asrc_req_pair fail\n");
+			return -1;
+		}
+		config.pair = asrc_ssi_data.asrc_index;
+		config.channel_num = channel;
+		config.input_sample_rate = asrc_input_rate;
+		config.output_sample_rate = asrc_ssi_data.output_sample_rate;
+		config.inclk = INCLK_NONE;
+		config.word_width = 32;
+		plat = priv->pdev->dev.platform_data;
+		if (plat->src_port == 1)
+			config.outclk = OUTCLK_SSI1_TX;
+		else
+			config.outclk = OUTCLK_SSI2_TX;
+		retVal = asrc_config_pair(&config);
+		if (retVal < 0) {
+			pr_err("Fail to config asrc\n");
+			asrc_release_pair(asrc_ssi_data.asrc_index);
+			return retVal;
+		}
+		rate = asrc_ssi_data.output_sample_rate;
+		pcm_data->asrc_index = asrc_ssi_data.asrc_index;
+		pcm_data->asrc_enable = 1;
+	}
+#endif
+
+	snd_soc_dai_set_sysclk(codec_dai, SGTL5000_SYSCLK, priv->sysclk, 0);
+	snd_soc_dai_set_sysclk(codec_dai, SGTL5000_LRCLK, rate, 0);
+
+#if SGTL5000_SSI_MASTER
+	dai_format = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+	    SND_SOC_DAIFMT_CBM_CFM;
+#else
+	dai_format = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+	    SND_SOC_DAIFMT_CBS_CFS;
+#endif
+
+	ssi_mode->sync_mode = 1;
+	if (channels == 1)
+		ssi_mode->network_mode = 0;
+	else
+		ssi_mode->network_mode = 1;
+
+	/* set codec DAI configuration */
+	ret = snd_soc_dai_set_fmt(codec_dai, dai_format);
+	if (ret < 0)
+		return ret;
+
+	/* set i.MX active slot mask */
+	snd_soc_dai_set_tdm_slot(cpu_dai,
+				 channels == 1 ? 0xfffffffe : 0xfffffffc,
+				 channels == 1 ? 0xfffffffe : 0xfffffffc,
+				 2, 16);
+	/* set cpu DAI configuration */
+	ret = snd_soc_dai_set_fmt(cpu_dai, dai_format);
+	if (ret < 0)
+		return ret;
+
+	/* set the SSI system clock as input (unused) */
+	snd_soc_dai_set_sysclk(cpu_dai, IMX_SSP_SYS_CLK, 0, SND_SOC_CLOCK_IN);
+
+	return 0;
+}
+
+static int imx_3stack_startup(struct snd_pcm_substream *substream)
+{
+#if defined(CONFIG_MXC_ASRC) || defined(CONFIG_MXC_ASRC_MODULE)
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		if (asrc_ssi_data.output_sample_rate != 0) {
+			struct snd_soc_pcm_runtime *rtd =
+			    substream->private_data;
+			struct snd_soc_dai_link *pcm_link = rtd->dai;
+			struct snd_soc_dai *cpu_dai = pcm_link->cpu_dai;
+			struct snd_soc_dai *codec_dai = pcm_link->codec_dai;
+			asrc_ssi_data.cpu_dai_rates = cpu_dai->playback.rates;
+			asrc_ssi_data.codec_dai_rates =
+			    codec_dai->playback.rates;
+			cpu_dai->playback.rates =
+			    SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT;
+			codec_dai->playback.rates =
+			    SNDRV_PCM_RATE_8000_192000 | SNDRV_PCM_RATE_KNOT;
+		}
+	}
+#endif
+	return 0;
+}
+
+static void imx_3stack_shutdown(struct snd_pcm_substream *substream)
+{
+	struct imx_3stack_priv *priv = &card_priv;
+
+#if defined(CONFIG_MXC_ASRC) || defined(CONFIG_MXC_ASRC_MODULE)
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		if (asrc_ssi_data.output_sample_rate != 0) {
+			struct snd_soc_pcm_runtime *rtd =
+			    substream->private_data;
+			struct snd_soc_dai_link *pcm_link = rtd->dai;
+			struct snd_soc_dai *cpu_dai = pcm_link->cpu_dai;
+			struct snd_soc_dai *codec_dai = pcm_link->codec_dai;
+			codec_dai->playback.rates =
+			    asrc_ssi_data.codec_dai_rates;
+			cpu_dai->playback.rates = asrc_ssi_data.cpu_dai_rates;
+			asrc_release_pair(asrc_ssi_data.asrc_index);
+		}
+	}
+#endif
+
+	priv->hw = 0;
+}
+
+/*
+ * imx_3stack SGTL5000 audio DAI opserations.
+ */
+static struct snd_soc_ops imx_3stack_ops = {
+	.startup = imx_3stack_startup,
+	.shutdown = imx_3stack_shutdown,
+	.hw_params = imx_3stack_audio_hw_params,
+};
+
+static void imx_3stack_init_dam(int ssi_port, int dai_port)
+{
+	unsigned int ssi_ptcr = 0;
+	unsigned int dai_ptcr = 0;
+	unsigned int ssi_pdcr = 0;
+	unsigned int dai_pdcr = 0;
+	/* SGTL5000 uses SSI1 or SSI2 via AUDMUX port dai_port for audio */
+
+	/* reset port ssi_port & dai_port */
+	__raw_writel(0, DAM_PTCR(ssi_port));
+	__raw_writel(0, DAM_PTCR(dai_port));
+	__raw_writel(0, DAM_PDCR(ssi_port));
+	__raw_writel(0, DAM_PDCR(dai_port));
+
+	/* set to synchronous */
+	ssi_ptcr |= AUDMUX_PTCR_SYN;
+	dai_ptcr |= AUDMUX_PTCR_SYN;
+
+#if SGTL5000_SSI_MASTER
+	/* set Rx sources ssi_port <--> dai_port */
+	ssi_pdcr |= AUDMUX_PDCR_RXDSEL(dai_port);
+	dai_pdcr |= AUDMUX_PDCR_RXDSEL(ssi_port);
+
+	/* set Tx frame direction and source  dai_port--> ssi_port output */
+	ssi_ptcr |= AUDMUX_PTCR_TFSDIR;
+	ssi_ptcr |= AUDMUX_PTCR_TFSSEL(AUDMUX_FROM_TXFS, dai_port);
+
+	/* set Tx Clock direction and source dai_port--> ssi_port output */
+	ssi_ptcr |= AUDMUX_PTCR_TCLKDIR;
+	ssi_ptcr |= AUDMUX_PTCR_TCSEL(AUDMUX_FROM_TXFS, dai_port);
+#else
+	/* set Rx sources ssi_port <--> dai_port */
+	ssi_pdcr |= AUDMUX_PDCR_RXDSEL(dai_port);
+	dai_pdcr |= AUDMUX_PDCR_RXDSEL(ssi_port);
+
+	/* set Tx frame direction and source  ssi_port --> dai_port output */
+	dai_ptcr |= AUDMUX_PTCR_TFSDIR;
+	dai_ptcr |= AUDMUX_PTCR_TFSSEL(AUDMUX_FROM_TXFS, ssi_port);
+
+	/* set Tx Clock direction and source ssi_port--> dai_port output */
+	dai_ptcr |= AUDMUX_PTCR_TCLKDIR;
+	dai_ptcr |= AUDMUX_PTCR_TCSEL(AUDMUX_FROM_TXFS, ssi_port);
+#endif
+
+	__raw_writel(ssi_ptcr, DAM_PTCR(ssi_port));
+	__raw_writel(dai_ptcr, DAM_PTCR(dai_port));
+	__raw_writel(ssi_pdcr, DAM_PDCR(ssi_port));
+	__raw_writel(dai_pdcr, DAM_PDCR(dai_port));
+}
+
+/* imx_3stack machine connections to the codec pins */
+static const struct snd_soc_dapm_route audio_map[] = {
+
+	/* Mic Jack --> MIC_IN (with automatic bias) */
+	{"MIC_IN", NULL, "Mic Jack"},
+
+	/* Line in Jack --> LINE_IN */
+	{"LINE_IN", NULL, "Line In Jack"},
+
+	/* HP_OUT --> Headphone Jack */
+	{"Headphone Jack", NULL, "HP_OUT"},
+
+	/* LINE_OUT --> Ext Speaker */
+	{"Ext Spk", NULL, "LINE_OUT"},
+};
+
+static int sgtl5000_jack_func;
+static int sgtl5000_spk_func;
+static int sgtl5000_line_in_func;
+
+static void headphone_detect_handler(struct work_struct *work)
+{
+	struct imx_3stack_priv *priv = &card_priv;
+	struct platform_device *pdev = priv->pdev;
+	struct mxc_audio_platform_data *plat = pdev->dev.platform_data;
+	int hp_status;
+
+	sysfs_notify(&pdev->dev.kobj, NULL, "headphone");
+	hp_status = plat->hp_status();
+	if (hp_status)
+		set_irq_type(plat->hp_irq, IRQ_TYPE_EDGE_FALLING);
+	else
+		set_irq_type(plat->hp_irq, IRQ_TYPE_EDGE_RISING);
+	enable_irq(plat->hp_irq);
+}
+
+static DECLARE_DELAYED_WORK(hp_event, headphone_detect_handler);
+
+static irqreturn_t imx_headphone_detect_handler(int irq, void *data)
+{
+	disable_irq_nosync(irq);
+	schedule_delayed_work(&hp_event, msecs_to_jiffies(200));
+	return IRQ_HANDLED;
+}
+
+static ssize_t show_headphone(struct device_driver *dev, char *buf)
+{
+	struct imx_3stack_priv *priv = &card_priv;
+	struct platform_device *pdev = priv->pdev;
+	struct mxc_audio_platform_data *plat = pdev->dev.platform_data;
+	u16 hp_status;
+
+	/* determine whether hp is plugged in */
+	hp_status = plat->hp_status();
+
+	if (hp_status == 0)
+		strcpy(buf, "speaker\n");
+	else
+		strcpy(buf, "headphone\n");
+
+	return strlen(buf);
+}
+
+static DRIVER_ATTR(headphone, S_IRUGO | S_IWUSR, show_headphone, NULL);
+
+static const char *jack_function[] = { "off", "on"};
+
+static const char *spk_function[] = { "off", "on" };
+
+static const char *line_in_function[] = { "off", "on" };
+
+static const struct soc_enum sgtl5000_enum[] = {
+	SOC_ENUM_SINGLE_EXT(2, jack_function),
+	SOC_ENUM_SINGLE_EXT(2, spk_function),
+	SOC_ENUM_SINGLE_EXT(2, line_in_function),
+};
+
+static int sgtl5000_get_jack(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.enumerated.item[0] = sgtl5000_jack_func;
+	return 0;
+}
+
+static int sgtl5000_set_jack(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+
+	if (sgtl5000_jack_func == ucontrol->value.enumerated.item[0])
+		return 0;
+
+	sgtl5000_jack_func = ucontrol->value.enumerated.item[0];
+	if (sgtl5000_jack_func)
+		snd_soc_dapm_enable_pin(codec, "Headphone Jack");
+	else
+		snd_soc_dapm_disable_pin(codec, "Headphone Jack");
+
+	snd_soc_dapm_sync(codec);
+	return 1;
+}
+
+static int sgtl5000_get_spk(struct snd_kcontrol *kcontrol,
+			    struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.enumerated.item[0] = sgtl5000_spk_func;
+	return 0;
+}
+
+static int sgtl5000_set_spk(struct snd_kcontrol *kcontrol,
+			    struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+
+	if (sgtl5000_spk_func == ucontrol->value.enumerated.item[0])
+		return 0;
+
+	sgtl5000_spk_func = ucontrol->value.enumerated.item[0];
+	if (sgtl5000_spk_func)
+		snd_soc_dapm_enable_pin(codec, "Ext Spk");
+	else
+		snd_soc_dapm_disable_pin(codec, "Ext Spk");
+
+	snd_soc_dapm_sync(codec);
+	return 1;
+}
+
+static int sgtl5000_get_line_in(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.enumerated.item[0] = sgtl5000_line_in_func;
+	return 0;
+}
+
+static int sgtl5000_set_line_in(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+
+	if (sgtl5000_line_in_func == ucontrol->value.enumerated.item[0])
+		return 0;
+
+	sgtl5000_line_in_func = ucontrol->value.enumerated.item[0];
+	if (sgtl5000_line_in_func)
+		snd_soc_dapm_enable_pin(codec, "Line In Jack");
+	else
+		snd_soc_dapm_disable_pin(codec, "Line In Jack");
+
+	snd_soc_dapm_sync(codec);
+	return 1;
+}
+
+static int spk_amp_event(struct snd_soc_dapm_widget *w,
+			 struct snd_kcontrol *kcontrol, int event)
+{
+	struct imx_3stack_priv *priv = &card_priv;
+	struct platform_device *pdev = priv->pdev;
+	struct mxc_audio_platform_data *plat = pdev->dev.platform_data;
+
+	if (plat->amp_enable == NULL)
+		return 0;
+
+	if (SND_SOC_DAPM_EVENT_ON(event))
+		plat->amp_enable(1);
+	else
+		plat->amp_enable(0);
+
+	return 0;
+}
+
+/* imx_3stack card dapm widgets */
+static const struct snd_soc_dapm_widget imx_3stack_dapm_widgets[] = {
+	SND_SOC_DAPM_MIC("Mic Jack", NULL),
+	SND_SOC_DAPM_LINE("Line In Jack", NULL),
+	SND_SOC_DAPM_SPK("Ext Spk", spk_amp_event),
+	SND_SOC_DAPM_HP("Headphone Jack", NULL),
+};
+
+static const struct snd_kcontrol_new sgtl5000_machine_controls[] = {
+	SOC_ENUM_EXT("Jack Function", sgtl5000_enum[0], sgtl5000_get_jack,
+		     sgtl5000_set_jack),
+	SOC_ENUM_EXT("Speaker Function", sgtl5000_enum[1], sgtl5000_get_spk,
+		     sgtl5000_set_spk),
+	SOC_ENUM_EXT("Line In Function", sgtl5000_enum[1], sgtl5000_get_line_in,
+		     sgtl5000_set_line_in),
+};
+
+#if defined(CONFIG_MXC_ASRC) || defined(CONFIG_MXC_ASRC_MODULE)
+static int asrc_func;
+
+static const char *asrc_function[] = {"disable", "32KHz", "44.1KHz",
+				      "48KHz", "96KHz" };
+
+static const struct soc_enum asrc_enum[] = {
+	SOC_ENUM_SINGLE_EXT(5, asrc_function),
+};
+
+static int asrc_get_rate(struct snd_kcontrol *kcontrol,
+			 struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.enumerated.item[0] = asrc_func;
+	return 0;
+}
+
+static int asrc_set_rate(struct snd_kcontrol *kcontrol,
+			 struct snd_ctl_elem_value *ucontrol)
+{
+	if (asrc_func == ucontrol->value.enumerated.item[0])
+		return 0;
+
+	asrc_func = ucontrol->value.enumerated.item[0];
+	asrc_ssi_data.output_sample_rate = sgtl5000_rates[asrc_func];
+
+	return 1;
+}
+
+static const struct snd_kcontrol_new asrc_controls[] = {
+	SOC_ENUM_EXT("ASRC", asrc_enum[0], asrc_get_rate,
+		     asrc_set_rate),
+};
+#endif
+
+static int imx_3stack_sgtl5000_init(struct snd_soc_codec *codec)
+{
+	int i, ret;
+
+#if defined(CONFIG_MXC_ASRC) || defined(CONFIG_MXC_ASRC_MODULE)
+	for (i = 0; i < ARRAY_SIZE(asrc_controls); i++) {
+		ret = snd_ctl_add(codec->card,
+				  snd_soc_cnew(&asrc_controls[i], codec, NULL));
+		if (ret < 0)
+			return ret;
+	}
+	asrc_ssi_data.output_sample_rate = sgtl5000_rates[asrc_func];
+#endif
+
+	/* Add imx_3stack specific controls */
+	for (i = 0; i < ARRAY_SIZE(sgtl5000_machine_controls); i++) {
+		ret = snd_ctl_add(codec->card,
+				  snd_soc_cnew(&sgtl5000_machine_controls[i],
+					       codec, NULL));
+		if (ret < 0)
+			return ret;
+	}
+
+	/* Add imx_3stack specific widgets */
+	snd_soc_dapm_new_controls(codec, imx_3stack_dapm_widgets,
+				  ARRAY_SIZE(imx_3stack_dapm_widgets));
+
+	/* Set up imx_3stack specific audio path audio_map */
+	snd_soc_dapm_add_routes(codec, audio_map, ARRAY_SIZE(audio_map));
+
+	snd_soc_dapm_disable_pin(codec, "Line In Jack");
+
+	snd_soc_dapm_sync(codec);
+
+	return 0;
+}
+
+/* imx_3stack digital audio interface glue - connects codec <--> CPU */
+static struct snd_soc_dai_link imx_3stack_dai = {
+	.name = "SGTL5000",
+	.stream_name = "SGTL5000",
+	.codec_dai = &sgtl5000_dai,
+	.init = imx_3stack_sgtl5000_init,
+	.ops = &imx_3stack_ops,
+};
+
+static int imx_3stack_card_remove(struct platform_device *pdev)
+{
+	struct imx_3stack_priv *priv = &card_priv;
+	struct mxc_audio_platform_data *plat;
+	if (priv->pdev) {
+		plat = priv->pdev->dev.platform_data;
+		if (plat->finit)
+			plat->finit();
+	}
+
+	return 0;
+}
+
+static struct snd_soc_card snd_soc_card_imx_3stack = {
+	.name = "imx-3stack",
+	.platform = &imx_soc_platform,
+	.dai_link = &imx_3stack_dai,
+	.num_links = 1,
+	.remove = imx_3stack_card_remove,
+};
+
+static struct snd_soc_device imx_3stack_snd_devdata = {
+	.card = &snd_soc_card_imx_3stack,
+	.codec_dev = &soc_codec_dev_sgtl5000,
+};
+
+static int __devinit imx_3stack_sgtl5000_probe(struct platform_device *pdev)
+{
+	struct mxc_audio_platform_data *plat = pdev->dev.platform_data;
+	struct imx_3stack_priv *priv = &card_priv;
+	struct snd_soc_dai *sgtl5000_cpu_dai;
+	int ret = 0;
+
+	priv->sysclk = plat->sysclk;
+	priv->pdev = pdev;
+
+	gpio_activate_audio_ports();
+	imx_3stack_init_dam(plat->src_port, plat->ext_port);
+
+	if (plat->src_port == 2)
+		sgtl5000_cpu_dai = &imx_ssi_dai[2];
+	else
+		sgtl5000_cpu_dai = &imx_ssi_dai[0];
+
+	imx_3stack_dai.cpu_dai = sgtl5000_cpu_dai;
+
+	ret = driver_create_file(pdev->dev.driver, &driver_attr_headphone);
+	if (ret < 0) {
+		pr_err("%s:failed to create driver_attr_headphone\n", __func__);
+		goto sysfs_err;
+	}
+
+	ret = -EINVAL;
+	if (plat->init && plat->init())
+		goto err_plat_init;
+
+	/* The SGTL5000 has an internal reset that is deasserted 8 SYS_MCLK
+	   cycles after all power rails have been brought up. After this time
+	   communication can start */
+
+	if (plat->hp_status())
+		ret = request_irq(plat->hp_irq,
+				  imx_headphone_detect_handler,
+				  IRQ_TYPE_EDGE_FALLING, pdev->name, priv);
+	else
+		ret = request_irq(plat->hp_irq,
+				  imx_headphone_detect_handler,
+				  IRQ_TYPE_EDGE_RISING, pdev->name, priv);
+	if (ret < 0) {
+		pr_err("%s: request irq failed\n", __func__);
+		goto err_card_reg;
+	}
+
+	sgtl5000_jack_func = 1;
+	sgtl5000_spk_func = 1;
+	sgtl5000_line_in_func = 0;
+
+	return 0;
+
+err_card_reg:
+	if (plat->finit)
+		plat->finit();
+err_plat_init:
+	driver_remove_file(pdev->dev.driver, &driver_attr_headphone);
+sysfs_err:
+	return ret;
+}
+
+static int imx_3stack_sgtl5000_remove(struct platform_device *pdev)
+{
+	struct mxc_audio_platform_data *plat = pdev->dev.platform_data;
+	struct imx_3stack_priv *priv = &card_priv;
+
+	free_irq(plat->hp_irq, priv);
+
+	if (plat->finit)
+		plat->finit();
+
+	driver_remove_file(pdev->dev.driver, &driver_attr_headphone);
+
+	return 0;
+}
+
+static struct platform_driver imx_3stack_sgtl5000_audio_driver = {
+	.probe = imx_3stack_sgtl5000_probe,
+	.remove = imx_3stack_sgtl5000_remove,
+	.driver = {
+		   .name = "imx-3stack-sgtl5000",
+		   },
+};
+
+static struct platform_device *imx_3stack_snd_device;
+
+static int __init imx_3stack_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&imx_3stack_sgtl5000_audio_driver);
+	if (ret)
+		return -ENOMEM;
+
+	imx_3stack_snd_device = platform_device_alloc("soc-audio", 2);
+	if (!imx_3stack_snd_device)
+		return -ENOMEM;
+
+	platform_set_drvdata(imx_3stack_snd_device, &imx_3stack_snd_devdata);
+	imx_3stack_snd_devdata.dev = &imx_3stack_snd_device->dev;
+	ret = platform_device_add(imx_3stack_snd_device);
+
+	if (ret)
+		platform_device_put(imx_3stack_snd_device);
+
+	return ret;
+}
+
+static void __exit imx_3stack_exit(void)
+{
+	platform_driver_unregister(&imx_3stack_sgtl5000_audio_driver);
+	platform_device_unregister(imx_3stack_snd_device);
+}
+
+module_init(imx_3stack_init);
+module_exit(imx_3stack_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("SGTL5000 Driver for i.MX 3STACK");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/imx/imx-esai.h b/sound/soc/imx/imx-esai.h
new file mode 100644
index 0000000..58ad601
--- /dev/null
+++ b/sound/soc/imx/imx-esai.h
@@ -0,0 +1,30 @@
+/*
+ * imx-esai.h  --  ESAI driver header file for Freescale IMX
+ *
+ * Copyright 2008-2009 Freescale  Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef _MXC_ESAI_H
+#define _MXC_ESAI_H
+
+#define IMX_DAI_ESAI_TX 0x04
+#define IMX_DAI_ESAI_RX 0x08
+#define IMX_DAI_ESAI_TXRX (IMX_DAI_ESAI_TX | IMX_DAI_ESAI_RX)
+
+struct imx_esai {
+	bool network_mode;
+	bool sync_mode;
+};
+
+extern struct snd_soc_dai imx_esai_dai[];
+
+#endif
diff --git a/sound/soc/imx/imx-pcm.c b/sound/soc/imx/imx-pcm.c
new file mode 100644
index 0000000..a4e9c24
--- /dev/null
+++ b/sound/soc/imx/imx-pcm.c
@@ -0,0 +1,706 @@
+/*
+ * imx-pcm.c -- ALSA SoC interface for the Freescale i.MX3 CPU's
+ *
+ * Copyright 2006 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ * Based on imx31-pcm.c by Nicolas Pitre, (C) 2004 MontaVista Software, Inc.
+ * and on mxc-alsa-mc13783 (C) 2006-2009 Freescale.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <mach/dma.h>
+#include <mach/spba.h>
+#include <mach/clock.h>
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+
+#include "imx-pcm.h"
+#include "mxc-ssi.h"
+#include "imx-esai.h"
+
+#if defined(CONFIG_MXC_ASRC) || defined(CONFIG_MXC_ASRC_MODULE)
+#include <linux/delay.h>
+#include <linux/mxc_asrc.h>
+#endif
+
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+static bool UseIram = 1;
+#else
+static bool UseIram;
+#endif
+
+/* debug */
+#define IMX_PCM_DEBUG 0
+#if IMX_PCM_DEBUG
+#define dbg(format, arg...) printk(format, ## arg)
+#else
+#define dbg(format, arg...)
+#endif
+
+static const struct snd_pcm_hardware imx_pcm_hardware = {
+	.info = (SNDRV_PCM_INFO_INTERLEAVED |
+		 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+		 SNDRV_PCM_INFO_MMAP |
+		 SNDRV_PCM_INFO_MMAP_VALID |
+		 SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME),
+	.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+	.buffer_bytes_max = SND_RAM_SIZE,
+	.period_bytes_max = SND_RAM_SIZE / 4,
+#else
+	.buffer_bytes_max = 64 * 1024,
+	.period_bytes_max = 16 * 1024,
+#endif
+	.period_bytes_min = 2 * SZ_1K,
+	.periods_min = 2,
+	.periods_max = 255,
+	.fifo_size = 0,
+};
+
+static uint32_t audio_iram_phys_base_addr;
+static void *audio_iram_virt_base_addr;
+
+static struct vm_operations_struct snd_mxc_audio_playback_vm_ops = {
+	.open = snd_pcm_mmap_data_open,
+	.close = snd_pcm_mmap_data_close,
+};
+
+/*
+	enable user space access to iram buffer
+*/
+static int imx_iram_audio_playback_mmap(struct snd_pcm_substream *substream,
+					struct vm_area_struct *area)
+{
+	unsigned long off;
+	unsigned long phys;
+	unsigned long size;
+	int ret = 0;
+
+	area->vm_ops = &snd_mxc_audio_playback_vm_ops;
+	area->vm_private_data = substream;
+
+	off = area->vm_pgoff << PAGE_SHIFT;
+	phys = audio_iram_phys_base_addr + off;
+	size = area->vm_end - area->vm_start;
+
+	if (off + size > SND_RAM_SIZE)
+		return -EINVAL;
+
+	area->vm_page_prot = pgprot_writecombine(area->vm_page_prot);
+	area->vm_flags |= VM_IO;
+	ret =
+	    remap_pfn_range(area, area->vm_start, phys >> PAGE_SHIFT,
+			    size, area->vm_page_prot);
+	if (ret == 0)
+		area->vm_ops->open(area);
+
+	return ret;
+}
+
+/*
+     Map nbytes in virtual space
+     bytes -audio iram iram partition size
+     phys_addr - physical address of iram buffer
+     returns - virtual address of the iram buffer or NULL if fail
+*/
+static void *imx_iram_init(dma_addr_t *phys_addr, size_t bytes)
+{
+	void *iram_base;
+
+	iram_base = (void *)ioremap((uint32_t) SND_RAM_BASE_ADDR, bytes);
+
+	audio_iram_virt_base_addr = iram_base;
+	audio_iram_phys_base_addr = (uint32_t) SND_RAM_BASE_ADDR;
+	*phys_addr = (dma_addr_t) SND_RAM_BASE_ADDR;
+
+	return audio_iram_virt_base_addr;
+
+}
+
+/*
+     destroy the virtual mapping of the iram buffer
+*/
+
+static void imx_iram_free(void)
+{
+	iounmap(audio_iram_virt_base_addr);
+}
+
+static int imx_get_sdma_transfer(int format, int dai_port,
+				 struct snd_pcm_substream *substream)
+{
+	int transfer = -1;
+
+#if defined(CONFIG_MXC_ASRC) || defined(CONFIG_MXC_ASRC_MODULE)
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct mxc_runtime_data *prtd = runtime->private_data;
+	if (prtd->asrc_enable == 1) {
+		if (dai_port == IMX_DAI_SSI0) {
+			if (prtd->asrc_index == 0)
+				transfer = MXC_DMA_ASRCA_SSI1_TX0;
+			else if (prtd->asrc_index == 1)
+				transfer = MXC_DMA_ASRCB_SSI1_TX0;
+		} else if (dai_port == IMX_DAI_SSI1) {
+			if (prtd->asrc_index == 0)
+				transfer = MXC_DMA_ASRCA_SSI1_TX1;
+			else if (prtd->asrc_index == 1)
+				transfer = MXC_DMA_ASRCB_SSI1_TX1;
+		} else if (dai_port == IMX_DAI_SSI2) {
+			if (prtd->asrc_index == 0)
+				transfer = MXC_DMA_ASRCA_SSI2_TX0;
+			else if (prtd->asrc_index == 1)
+				transfer = MXC_DMA_ASRCB_SSI2_TX0;
+		} else if (dai_port == IMX_DAI_SSI3) {
+			if (prtd->asrc_index == 0)
+				transfer = MXC_DMA_ASRCA_SSI2_TX1;
+			else if (prtd->asrc_index == 1)
+				transfer = MXC_DMA_ASRCB_SSI2_TX1;
+		} else if (dai_port & IMX_DAI_ESAI_TX) {
+			if (prtd->asrc_index == 0)
+				transfer = MXC_DMA_ASRCA_ESAI;
+			else if (prtd->asrc_index == 1)
+				transfer = MXC_DMA_ASRCB_ESAI;
+			else
+				transfer = MXC_DMA_ASRCC_ESAI;
+		}
+	} else {
+#endif
+
+		if (dai_port == IMX_DAI_SSI0) {
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+				if (format == SNDRV_PCM_FORMAT_S16_LE)
+					transfer = MXC_DMA_SSI1_16BIT_TX0;
+				else if (format == SNDRV_PCM_FORMAT_S24_LE)
+					transfer = MXC_DMA_SSI1_24BIT_TX0;
+				else if (format == SNDRV_PCM_FORMAT_S20_3LE)
+					transfer = MXC_DMA_SSI1_24BIT_TX0;
+			} else {
+				if (format == SNDRV_PCM_FORMAT_S16_LE)
+					transfer = MXC_DMA_SSI1_16BIT_RX0;
+				else if (format == SNDRV_PCM_FORMAT_S24_LE)
+					transfer = MXC_DMA_SSI1_24BIT_RX0;
+				else if (format == SNDRV_PCM_FORMAT_S20_3LE)
+					transfer = MXC_DMA_SSI1_24BIT_RX0;
+			}
+		} else if (dai_port == IMX_DAI_SSI1) {
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+				if (format == SNDRV_PCM_FORMAT_S16_LE)
+					transfer = MXC_DMA_SSI1_16BIT_TX1;
+				else if (format == SNDRV_PCM_FORMAT_S24_LE)
+					transfer = MXC_DMA_SSI1_24BIT_TX1;
+				else if (format == SNDRV_PCM_FORMAT_S20_3LE)
+					transfer = MXC_DMA_SSI1_24BIT_TX1;
+			} else {
+				if (format == SNDRV_PCM_FORMAT_S16_LE)
+					transfer = MXC_DMA_SSI1_16BIT_RX1;
+				else if (format == SNDRV_PCM_FORMAT_S24_LE)
+					transfer = MXC_DMA_SSI1_24BIT_RX1;
+				else if (format == SNDRV_PCM_FORMAT_S20_3LE)
+					transfer = MXC_DMA_SSI1_24BIT_RX1;
+			}
+		} else if (dai_port == IMX_DAI_SSI2) {
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+				if (format == SNDRV_PCM_FORMAT_S16_LE)
+					transfer = MXC_DMA_SSI2_16BIT_TX0;
+				else if (format == SNDRV_PCM_FORMAT_S24_LE)
+					transfer = MXC_DMA_SSI2_24BIT_TX0;
+				else if (format == SNDRV_PCM_FORMAT_S20_3LE)
+					transfer = MXC_DMA_SSI2_24BIT_TX0;
+			} else {
+				if (format == SNDRV_PCM_FORMAT_S16_LE)
+					transfer = MXC_DMA_SSI2_16BIT_RX0;
+				else if (format == SNDRV_PCM_FORMAT_S24_LE)
+					transfer = MXC_DMA_SSI2_24BIT_RX0;
+				else if (format == SNDRV_PCM_FORMAT_S20_3LE)
+					transfer = MXC_DMA_SSI2_24BIT_RX0;
+			}
+		} else if (dai_port == IMX_DAI_SSI3) {
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+				if (format == SNDRV_PCM_FORMAT_S16_LE)
+					transfer = MXC_DMA_SSI2_16BIT_TX1;
+				else if (format == SNDRV_PCM_FORMAT_S24_LE)
+					transfer = MXC_DMA_SSI2_24BIT_TX1;
+				else if (format == SNDRV_PCM_FORMAT_S20_3LE)
+					transfer = MXC_DMA_SSI2_24BIT_TX1;
+			} else {
+				if (format == SNDRV_PCM_FORMAT_S16_LE)
+					transfer = MXC_DMA_SSI2_16BIT_RX1;
+				else if (format == SNDRV_PCM_FORMAT_S24_LE)
+					transfer = MXC_DMA_SSI2_24BIT_RX1;
+				else if (format == SNDRV_PCM_FORMAT_S20_3LE)
+					transfer = MXC_DMA_SSI2_24BIT_RX1;
+			}
+		} else if ((dai_port & IMX_DAI_ESAI_TX)
+			   || (dai_port & IMX_DAI_ESAI_RX)) {
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+				if (format == SNDRV_PCM_FORMAT_S16_LE)
+					transfer = MXC_DMA_ESAI_16BIT_TX;
+				else if (format == SNDRV_PCM_FORMAT_S24_LE)
+					transfer = MXC_DMA_ESAI_24BIT_TX;
+				else if (format == SNDRV_PCM_FORMAT_S20_3LE)
+					transfer = MXC_DMA_ESAI_24BIT_TX;
+			} else {
+				if (format == SNDRV_PCM_FORMAT_S16_LE)
+					transfer = MXC_DMA_ESAI_16BIT_RX;
+				else if (format == SNDRV_PCM_FORMAT_S24_LE)
+					transfer = MXC_DMA_ESAI_24BIT_RX;
+				else if (format == SNDRV_PCM_FORMAT_S20_3LE)
+					transfer = MXC_DMA_ESAI_24BIT_RX;
+			}
+		}
+#if defined(CONFIG_MXC_ASRC) || defined(CONFIG_MXC_ASRC_MODULE)
+	}
+#endif
+	return transfer;
+}
+
+static int dma_new_period(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct mxc_runtime_data *prtd = runtime->private_data;
+	unsigned int dma_size = frames_to_bytes(runtime, runtime->period_size);
+	unsigned int offset = dma_size * prtd->period;
+	int ret = 0;
+	mxc_dma_requestbuf_t sdma_request;
+
+	if (!prtd->active)
+		return 0;
+
+	memset(&sdma_request, 0, sizeof(mxc_dma_requestbuf_t));
+
+	dbg("period pos  ALSA %x DMA %x\n", runtime->periods, prtd->period);
+	dbg("period size ALSA %x DMA %x Offset %x dmasize %x\n",
+	    (unsigned int)runtime->period_size,
+	    runtime->dma_bytes, offset, dma_size);
+	dbg("DMA addr %x\n", runtime->dma_addr + offset);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		sdma_request.src_addr =
+		    (dma_addr_t) (runtime->dma_addr + offset);
+	else
+		sdma_request.dst_addr =
+		    (dma_addr_t) (runtime->dma_addr + offset);
+
+	sdma_request.num_of_bytes = dma_size;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		mxc_dma_config(prtd->dma_wchannel,
+			       &sdma_request, 1, MXC_DMA_MODE_WRITE);
+		ret = mxc_dma_enable(prtd->dma_wchannel);
+	} else {
+
+		mxc_dma_config(prtd->dma_wchannel,
+			       &sdma_request, 1, MXC_DMA_MODE_READ);
+		ret = mxc_dma_enable(prtd->dma_wchannel);
+	}
+	prtd->dma_active = 1;
+	prtd->period++;
+	prtd->period %= runtime->periods;
+
+	return ret;
+}
+
+static void audio_dma_irq(void *data)
+{
+	struct snd_pcm_substream *substream = (struct snd_pcm_substream *)data;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct mxc_runtime_data *prtd = runtime->private_data;
+
+	prtd->dma_active = 0;
+	prtd->periods++;
+	prtd->periods %= runtime->periods;
+
+	dbg("irq per %d offset %x\n", prtd->periods,
+	    frames_to_bytes(runtime, runtime->period_size) * prtd->periods);
+
+	if (prtd->active)
+		snd_pcm_period_elapsed(substream);
+	dma_new_period(substream);
+}
+
+static int imx_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct mxc_runtime_data *prtd = runtime->private_data;
+	int ret = 0, channel = 0;
+
+	if (prtd->dma_alloc) {
+		mxc_dma_free(prtd->dma_wchannel);
+		prtd->dma_alloc = 0;
+	}
+
+	/* only allocate the DMA chn once */
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+#if defined(CONFIG_MXC_ASRC) || defined(CONFIG_MXC_ASRC_MODULE)
+		if (prtd->asrc_enable == 1) {
+			struct dma_channel_info info;
+			mxc_dma_requestbuf_t sdma_request;
+			info.asrc.channs = runtime->channels;
+			if (prtd->dma_asrc) {
+				mxc_dma_free(prtd->dma_asrc);
+				prtd->dma_asrc = 0;
+			}
+			memset(&sdma_request, 0, sizeof(mxc_dma_requestbuf_t));
+			/* num_of_bytes can be set any value except for zero */
+			sdma_request.num_of_bytes = 0x40;
+			channel =
+			    mxc_dma_request_ext(prtd->dma_ch,
+						"ALSA TX SDMA", &info);
+
+			mxc_dma_config(channel, &sdma_request,
+				       1, MXC_DMA_MODE_WRITE);
+			prtd->dma_asrc = channel;
+			if (prtd->asrc_index == 0)
+				prtd->dma_ch = MXC_DMA_ASRC_A_RX;
+			else if (prtd->asrc_index == 1)
+				prtd->dma_ch = MXC_DMA_ASRC_B_RX;
+			else
+				prtd->dma_ch = MXC_DMA_ASRC_C_RX;
+
+			channel =
+			    mxc_dma_request(MXC_DMA_ASRC_A_RX, "ALSA ASRC RX");
+		} else
+			channel = mxc_dma_request(prtd->dma_ch, "ALSA TX SDMA");
+#else
+		channel = mxc_dma_request(prtd->dma_ch, "ALSA TX SDMA");
+#endif
+		if (channel < 0) {
+			pr_err("imx-pcm: error requesting \
+					a write dma channel\n");
+			return channel;
+		}
+		ret = mxc_dma_callback_set(channel, (mxc_dma_callback_t)
+					   audio_dma_irq, (void *)substream);
+
+	} else {
+		channel = mxc_dma_request(prtd->dma_ch, "ALSA RX SDMA");
+		if (channel < 0) {
+			pr_err("imx-pcm: error requesting \
+				a read dma channel\n");
+			return channel;
+		}
+		ret = mxc_dma_callback_set(channel, (mxc_dma_callback_t)
+					   audio_dma_irq, (void *)substream);
+	}
+	prtd->dma_wchannel = channel;
+	prtd->dma_alloc = 1;
+
+	prtd->period = 0;
+	prtd->periods = 0;
+	return 0;
+}
+
+static int imx_pcm_hw_params(struct snd_pcm_substream
+			     *substream, struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct mxc_runtime_data *prtd = runtime->private_data;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+
+	prtd->dma_ch =
+	    imx_get_sdma_transfer(params_format(params),
+				  rtd->dai->cpu_dai->id, substream);
+
+	if (prtd->dma_ch < 0) {
+		printk(KERN_ERR "imx-pcm: invaild sdma transfer type");
+		return -1;
+	}
+
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+
+	return 0;
+}
+
+static int imx_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct mxc_runtime_data *prtd = runtime->private_data;
+
+	if (prtd->dma_wchannel) {
+		mxc_dma_free(prtd->dma_wchannel);
+		prtd->dma_wchannel = 0;
+		prtd->dma_alloc = 0;
+	}
+#if defined(CONFIG_MXC_ASRC) || defined(CONFIG_MXC_ASRC_MODULE)
+	if ((prtd->asrc_enable == 1) && prtd->dma_asrc) {
+		mxc_dma_free(prtd->dma_asrc);
+		prtd->dma_asrc = 0;
+	}
+#endif
+
+	return 0;
+}
+
+static int imx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct mxc_runtime_data *prtd = substream->runtime->private_data;
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		prtd->dma_active = 0;
+		prtd->active = 1;
+		ret = dma_new_period(substream);
+		ret = dma_new_period(substream);
+#if defined(CONFIG_MXC_ASRC) || defined(CONFIG_MXC_ASRC_MODULE)
+		if (prtd->asrc_enable == 1) {
+			ret = mxc_dma_enable(prtd->dma_asrc);
+			asrc_start_conv(prtd->asrc_index);
+			/* There is underrun, if immediately enable SSI after
+			   start ASRC */
+			mdelay(1);
+		}
+#endif
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		prtd->active = 0;
+#if defined(CONFIG_MXC_ASRC) || defined(CONFIG_MXC_ASRC_MODULE)
+		if (prtd->asrc_enable == 1) {
+			mxc_dma_disable(prtd->dma_asrc);
+			asrc_stop_conv(prtd->asrc_index);
+		}
+#endif
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static snd_pcm_uframes_t imx_pcm_pointer(struct
+					 snd_pcm_substream
+					 *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct mxc_runtime_data *prtd = runtime->private_data;
+	unsigned int offset = 0;
+
+	offset = (runtime->period_size * (prtd->periods));
+	if (offset >= runtime->buffer_size)
+		offset = 0;
+	dbg("pointer offset %x\n", offset);
+
+	return offset;
+}
+
+static int imx_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct mxc_runtime_data *prtd;
+	int ret;
+
+	snd_soc_set_runtime_hwparams(substream, &imx_pcm_hardware);
+
+	ret = snd_pcm_hw_constraint_integer(runtime,
+					    SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0)
+		return ret;
+
+	prtd = kzalloc(sizeof(struct mxc_runtime_data), GFP_KERNEL);
+	if (prtd == NULL)
+		return -ENOMEM;
+
+	runtime->private_data = prtd;
+	return 0;
+}
+
+static int imx_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct mxc_runtime_data *prtd = runtime->private_data;
+
+	kfree(prtd);
+	return 0;
+}
+
+static int
+imx_pcm_mmap(struct snd_pcm_substream *substream, struct vm_area_struct *vma)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_dai *cpu_dai = socdev->card->dai_link->cpu_dai;
+	struct mxc_audio_platform_data *dev_data;
+	int ext_ram = 0;
+	int ret = 0;
+
+	dbg("+imx_pcm_mmap:"
+	    "UseIram=%d dma_addr=%x dma_area=%x dma_bytes=%d\n",
+	    UseIram, (unsigned int)runtime->dma_addr,
+	    runtime->dma_area, runtime->dma_bytes);
+
+	if (cpu_dai->dev && cpu_dai->dev->platform_data) {
+		dev_data = cpu_dai->dev->platform_data;
+		ext_ram = dev_data->ext_ram;
+	}
+
+	if ((substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+	    || ext_ram || !UseIram) {
+		ret =
+		    dma_mmap_writecombine(substream->pcm->card->
+					  dev, vma,
+					  runtime->dma_area,
+					  runtime->dma_addr,
+					  runtime->dma_bytes);
+		return ret;
+	} else
+		return imx_iram_audio_playback_mmap(substream, vma);
+}
+
+struct snd_pcm_ops imx_pcm_ops = {
+	.open = imx_pcm_open,
+	.close = imx_pcm_close,
+	.ioctl = snd_pcm_lib_ioctl,
+	.hw_params = imx_pcm_hw_params,
+	.hw_free = imx_pcm_hw_free,
+	.prepare = imx_pcm_prepare,
+	.trigger = imx_pcm_trigger,
+	.pointer = imx_pcm_pointer,
+	.mmap = imx_pcm_mmap,
+};
+
+static int imx_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	struct snd_soc_pcm_runtime *rtd = pcm->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_dai *cpu_dai = socdev->card->dai_link->cpu_dai;
+	struct mxc_audio_platform_data *dev_data;
+	int ext_ram = 0;
+	size_t size = imx_pcm_hardware.buffer_bytes_max;
+
+	if (cpu_dai->dev && cpu_dai->dev->platform_data) {
+		dev_data = cpu_dai->dev->platform_data;
+		ext_ram = dev_data->ext_ram;
+	}
+
+	buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	buf->dev.dev = pcm->card->dev;
+	buf->private_data = NULL;
+
+	if ((stream == SNDRV_PCM_STREAM_CAPTURE) || ext_ram || !UseIram)
+		buf->area =
+		    dma_alloc_writecombine(pcm->card->dev, size,
+					   &buf->addr, GFP_KERNEL);
+	else
+		buf->area = imx_iram_init(&buf->addr, size);
+
+	if (!buf->area)
+		return -ENOMEM;
+	buf->bytes = size;
+	printk(KERN_INFO "DMA Sound Buffers Allocated:"
+	       "UseIram=%d buf->addr=%x buf->area=%p size=%d\n",
+	       UseIram, buf->addr, buf->area, size);
+	return 0;
+}
+
+static void imx_pcm_free_dma_buffers(struct snd_pcm *pcm)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *buf;
+	struct snd_soc_pcm_runtime *rtd = pcm->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_dai *cpu_dai = socdev->card->dai_link->cpu_dai;
+	struct mxc_audio_platform_data *dev_data;
+	int ext_ram = 0;
+	int stream;
+
+	if (cpu_dai->dev && cpu_dai->dev->platform_data) {
+		dev_data = cpu_dai->dev->platform_data;
+		ext_ram = dev_data->ext_ram;
+	}
+
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (!substream)
+			continue;
+
+		buf = &substream->dma_buffer;
+		if (!buf->area)
+			continue;
+
+		if ((stream == SNDRV_PCM_STREAM_CAPTURE)
+		    || ext_ram || !UseIram)
+			dma_free_writecombine(pcm->card->dev,
+					      buf->bytes, buf->area, buf->addr);
+		else
+			imx_iram_free();
+		buf->area = NULL;
+	}
+}
+
+static u64 imx_pcm_dmamask = 0xffffffff;
+
+static int imx_pcm_new(struct snd_card *card,
+		       struct snd_soc_dai *dai, struct snd_pcm *pcm)
+{
+	int ret = 0;
+
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &imx_pcm_dmamask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = 0xffffffff;
+
+	if (dai->playback.channels_min) {
+		ret = imx_pcm_preallocate_dma_buffer(pcm,
+						     SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			goto out;
+	}
+
+	if (dai->capture.channels_min) {
+		ret = imx_pcm_preallocate_dma_buffer(pcm,
+						     SNDRV_PCM_STREAM_CAPTURE);
+		if (ret)
+			goto out;
+	}
+out:
+	return ret;
+}
+
+struct snd_soc_platform imx_soc_platform = {
+	.name = "imx-audio",
+	.pcm_ops = &imx_pcm_ops,
+	.pcm_new = imx_pcm_new,
+	.pcm_free = imx_pcm_free_dma_buffers,
+};
+EXPORT_SYMBOL_GPL(imx_soc_platform);
+
+static int __init imx_pcm_init(void)
+{
+	return snd_soc_register_platform(&imx_soc_platform);
+}
+module_init(imx_pcm_init);
+
+static void __exit imx_pcm_exit(void)
+{
+	snd_soc_unregister_platform(&imx_soc_platform);
+}
+module_exit(imx_pcm_exit);
+
+MODULE_AUTHOR("Liam Girdwood");
+MODULE_DESCRIPTION("Freescale i.MX3x PCM DMA module");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/imx/imx-pcm.h b/sound/soc/imx/imx-pcm.h
new file mode 100644
index 0000000..c22a42b
--- /dev/null
+++ b/sound/soc/imx/imx-pcm.h
@@ -0,0 +1,83 @@
+/*
+ * imx-pcm.h :- ASoC platform header for Freescale i.MX
+ *
+ * Copyright 2006 Wolfson Microelectronics PLC.
+ * Copyright 2006, 2009 Freescale  Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _MXC_PCM_H
+#define _MXC_PCM_H
+
+#include <mach/dma.h>
+
+/* AUDMUX regs definition  */
+#define AUDMUX_IO_BASE_ADDR	IO_ADDRESS(AUDMUX_BASE_ADDR)
+
+#define DAM_PTCR1	((AUDMUX_IO_BASE_ADDR) + 0x00)
+#define DAM_PDCR1	((AUDMUX_IO_BASE_ADDR) + 0x04)
+#define DAM_PTCR2	((AUDMUX_IO_BASE_ADDR) + 0x08)
+#define DAM_PDCR2	((AUDMUX_IO_BASE_ADDR) + 0x0C)
+#define DAM_PTCR3	((AUDMUX_IO_BASE_ADDR) + 0x10)
+#define DAM_PDCR3	((AUDMUX_IO_BASE_ADDR) + 0x14)
+#define DAM_PTCR4	((AUDMUX_IO_BASE_ADDR) + 0x18)
+#define DAM_PDCR4	((AUDMUX_IO_BASE_ADDR) + 0x1C)
+#define DAM_PTCR5	((AUDMUX_IO_BASE_ADDR) + 0x20)
+#define DAM_PDCR5	((AUDMUX_IO_BASE_ADDR) + 0x24)
+#define DAM_PTCR6	((AUDMUX_IO_BASE_ADDR) + 0x28)
+#define DAM_PDCR6	((AUDMUX_IO_BASE_ADDR) + 0x2C)
+#define DAM_PTCR7	((AUDMUX_IO_BASE_ADDR) + 0x30)
+#define DAM_PDCR7	((AUDMUX_IO_BASE_ADDR) + 0x34)
+#define DAM_CNMCR	((AUDMUX_IO_BASE_ADDR) + 0x38)
+#define DAM_PTCR(a)	((AUDMUX_IO_BASE_ADDR) + (a-1)*8)
+#define DAM_PDCR(a)	((AUDMUX_IO_BASE_ADDR) + 4 + (a-1)*8)
+
+#define AUDMUX_PTCR_TFSDIR		(1 << 31)
+#define AUDMUX_PTCR_TFSSEL(x, y) \
+	((x << 30) | (((y - 1) & 0x7) << 27))
+#define AUDMUX_PTCR_TCLKDIR		(1 << 26)
+#define AUDMUX_PTCR_TCSEL(x, y)	\
+	((x << 25) | (((y - 1) & 0x7) << 22))
+#define AUDMUX_PTCR_RFSDIR		(1 << 21)
+#define AUDMUX_PTCR_RFSSEL(x, y) \
+	((x << 20) | (((y - 1) & 0x7) << 17))
+#define AUDMUX_PTCR_RCLKDIR		(1 << 16)
+#define AUDMUX_PTCR_RCSEL(x, y)	\
+	((x << 15) | (((y - 1) & 0x7) << 12))
+#define AUDMUX_PTCR_SYN		(1 << 11)
+
+#define AUDMUX_FROM_TXFS	0
+#define AUDMUX_FROM_RXFS	1
+
+#define AUDMUX_PDCR_RXDSEL(x)	(((x - 1) & 0x7) << 13)
+#define AUDMUX_PDCR_TXDXEN		(1 << 12)
+#define AUDMUX_PDCR_MODE(x)		(((x) & 0x3) << 8)
+#define AUDMUX_PDCR_INNMASK(x)	(((x) & 0xff) << 0)
+
+#define AUDMUX_CNMCR_CEN		(1 << 18)
+#define AUDMUX_CNMCR_FSPOL		(1 << 17)
+#define AUDMUX_CNMCR_CLKPOL		(1 << 16)
+#define AUDMUX_CNMCR_CNTHI(x)	(((x) & 0xff) << 8)
+#define AUDMUX_CNMCR_CNTLOW(x)	(((x) & 0xff) << 0)
+
+
+struct mxc_runtime_data {
+	int dma_ch;
+	spinlock_t dma_lock;
+	int active, period, periods;
+	int dma_wchannel;
+	int dma_active;
+	int dma_alloc;
+#if defined(CONFIG_MXC_ASRC) || defined(CONFIG_MXC_ASRC_MODULE)
+	int dma_asrc;
+	int asrc_index;
+	int asrc_enable;
+#endif
+};
+
+extern struct snd_soc_platform imx_soc_platform;
+
+#endif
diff --git a/sound/soc/imx/mxc-ssi.c b/sound/soc/imx/mxc-ssi.c
new file mode 100644
index 0000000..014264a
--- /dev/null
+++ b/sound/soc/imx/mxc-ssi.c
@@ -0,0 +1,845 @@
+/*
+ * imx-ssi.c  --  SSI driver for Freescale IMX
+ *
+ * Copyright 2006 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ * Based on mxc-alsa-mc13783 (C) 2006-2009 Freescale Semiconductor, Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    29th Aug 2006   Initial version.
+ *
+ * TODO:
+ *   Need to rework SSI register defs when new defs go into mainline.
+ *   Add support for TDM and FIFO 1.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <mach/dma.h>
+#include <mach/clock.h>
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+
+#include "mxc-ssi.h"
+#include "imx-pcm.h"
+
+static struct imx_ssi imx_ssi_data[4];
+
+/* debug */
+#define IMX_SSI_DEBUG 0
+#if IMX_SSI_DEBUG
+#define dbg(format, arg...) printk(format, ## arg)
+#else
+#define dbg(format, arg...)
+#endif
+
+#define IMX_SSI_DUMP 0
+#if IMX_SSI_DUMP
+#define SSI_DUMP() \
+	do { \
+		printk(KERN_INFO "dump @ %s\n", __func__); \
+		printk(KERN_INFO "scr %x\t, %x\n", \
+		       __raw_readl(SSI1_SCR), __raw_readl(SSI2_SCR));	\
+		printk(KERN_INFO "sisr %x\t, %x\n", \
+		       __raw_readl(SSI1_SISR), __raw_readl(SSI2_SISR));	\
+		printk(KERN_INFO "stcr %x\t, %x\n", \
+		       __raw_readl(SSI1_STCR), __raw_readl(SSI2_STCR)); \
+		printk(KERN_INFO "srcr %x\t, %x\n", \
+		       __raw_readl(SSI1_SRCR), __raw_readl(SSI2_SRCR)); \
+		printk(KERN_INFO "stccr %x\t, %x\n", \
+		       __raw_readl(SSI1_STCCR), __raw_readl(SSI2_STCCR)); \
+		printk(KERN_INFO "srccr %x\t, %x\n", \
+		       __raw_readl(SSI1_SRCCR), __raw_readl(SSI2_SRCCR)); \
+		printk(KERN_INFO "sfcsr %x\t, %x\n", \
+		       __raw_readl(SSI1_SFCSR), __raw_readl(SSI2_SFCSR)); \
+		printk(KERN_INFO "stmsk %x\t, %x\n", \
+		       __raw_readl(SSI1_STMSK), __raw_readl(SSI2_STMSK)); \
+		printk(KERN_INFO "srmsk %x\t, %x\n", \
+		       __raw_readl(SSI1_SRMSK), __raw_readl(SSI2_SRMSK)); \
+		printk(KERN_INFO "sier %x\t, %x\n", \
+		       __raw_readl(SSI1_SIER), __raw_readl(SSI2_SIER)); \
+	} while (0);
+#else
+#define SSI_DUMP()
+#endif
+
+#define SSI1_PORT	0
+#define SSI2_PORT	1
+
+static int ssi_active[2] = { 0, 0 };
+
+/*
+ * SSI system clock configuration.
+ * Should only be called when port is inactive (i.e. SSIEN = 0).
+ */
+static int imx_ssi_set_dai_sysclk(struct snd_soc_dai *cpu_dai,
+				  int clk_id, unsigned int freq, int dir)
+{
+	u32 scr;
+
+	if (cpu_dai->id == IMX_DAI_SSI0 || cpu_dai->id == IMX_DAI_SSI1)
+		scr = __raw_readl(SSI1_SCR);
+	else
+		scr = __raw_readl(SSI2_SCR);
+
+	if (scr & SSI_SCR_SSIEN)
+		return 0;
+
+	switch (clk_id) {
+	case IMX_SSP_SYS_CLK:
+		if (dir == SND_SOC_CLOCK_OUT)
+			scr |= SSI_SCR_SYS_CLK_EN;
+		else
+			scr &= ~SSI_SCR_SYS_CLK_EN;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (cpu_dai->id == IMX_DAI_SSI0 || cpu_dai->id == IMX_DAI_SSI1)
+		__raw_writel(scr, SSI1_SCR);
+	else
+		__raw_writel(scr, SSI2_SCR);
+
+	return 0;
+}
+
+/*
+ * SSI Clock dividers
+ * Should only be called when port is inactive (i.e. SSIEN = 0).
+ */
+static int imx_ssi_set_dai_clkdiv(struct snd_soc_dai *cpu_dai,
+				  int div_id, int div)
+{
+	u32 stccr, srccr;
+
+	if (cpu_dai->id == IMX_DAI_SSI0 || cpu_dai->id == IMX_DAI_SSI1) {
+		if (__raw_readl(SSI1_SCR) & SSI_SCR_SSIEN)
+			return 0;
+
+		srccr = __raw_readl(SSI1_SRCCR);
+		stccr = __raw_readl(SSI1_STCCR);
+	} else {
+		if (__raw_readl(SSI2_SCR) & SSI_SCR_SSIEN)
+			return 0;
+
+		srccr = __raw_readl(SSI2_SRCCR);
+		stccr = __raw_readl(SSI2_STCCR);
+	}
+
+	switch (div_id) {
+	case IMX_SSI_TX_DIV_2:
+		stccr &= ~SSI_STCCR_DIV2;
+		stccr |= div;
+		break;
+	case IMX_SSI_TX_DIV_PSR:
+		stccr &= ~SSI_STCCR_PSR;
+		stccr |= div;
+		break;
+	case IMX_SSI_TX_DIV_PM:
+		stccr &= ~0xff;
+		stccr |= SSI_STCCR_PM(div);
+		break;
+	case IMX_SSI_RX_DIV_2:
+		stccr &= ~SSI_STCCR_DIV2;
+		stccr |= div;
+		break;
+	case IMX_SSI_RX_DIV_PSR:
+		stccr &= ~SSI_STCCR_PSR;
+		stccr |= div;
+		break;
+	case IMX_SSI_RX_DIV_PM:
+		stccr &= ~0xff;
+		stccr |= SSI_STCCR_PM(div);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (cpu_dai->id == IMX_DAI_SSI0 || cpu_dai->id == IMX_DAI_SSI1) {
+		__raw_writel(stccr, SSI1_STCCR);
+		__raw_writel(srccr, SSI1_SRCCR);
+	} else {
+		__raw_writel(stccr, SSI2_STCCR);
+		__raw_writel(srccr, SSI2_SRCCR);
+	}
+	return 0;
+}
+
+/*
+ * SSI Network Mode or TDM slots configuration.
+ * Should only be called when port is inactive (i.e. SSIEN = 0).
+ */
+static int imx_ssi_set_dai_tdm_slot(struct snd_soc_dai *cpu_dai,
+				    unsigned int mask, unsigned int rx_mask,
+				    int slots, int slot_width)
+{
+	u32 stmsk, srmsk, stccr;
+
+	if (cpu_dai->id == IMX_DAI_SSI0 || cpu_dai->id == IMX_DAI_SSI1) {
+		if (__raw_readl(SSI1_SCR) & SSI_SCR_SSIEN)
+			return 0;
+		stccr = __raw_readl(SSI1_STCCR);
+	} else {
+		if (__raw_readl(SSI2_SCR) & SSI_SCR_SSIEN)
+			return 0;
+		stccr = __raw_readl(SSI2_STCCR);
+	}
+
+	stmsk = srmsk = mask;
+	stccr &= ~SSI_STCCR_DC_MASK;
+	stccr |= SSI_STCCR_DC(slots - 1);
+
+	if (cpu_dai->id == IMX_DAI_SSI0 || cpu_dai->id == IMX_DAI_SSI1) {
+		__raw_writel(stmsk, SSI1_STMSK);
+		__raw_writel(srmsk, SSI1_SRMSK);
+		__raw_writel(stccr, SSI1_STCCR);
+		__raw_writel(stccr, SSI1_SRCCR);
+	} else {
+		__raw_writel(stmsk, SSI2_STMSK);
+		__raw_writel(srmsk, SSI2_SRMSK);
+		__raw_writel(stccr, SSI2_STCCR);
+		__raw_writel(stccr, SSI2_SRCCR);
+	}
+
+	return 0;
+}
+
+/*
+ * SSI DAI format configuration.
+ * Should only be called when port is inactive (i.e. SSIEN = 0).
+ * Note: We don't use the I2S modes but instead manually configure the
+ * SSI for I2S.
+ */
+static int imx_ssi_set_dai_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)
+{
+	struct imx_ssi *ssi_mode = (struct imx_ssi *)cpu_dai->private_data;
+	u32 stcr = 0, srcr = 0, scr;
+
+	if (cpu_dai->id == IMX_DAI_SSI0 || cpu_dai->id == IMX_DAI_SSI1)
+		scr = __raw_readl(SSI1_SCR) & ~(SSI_SCR_SYN | SSI_SCR_NET);
+	else
+		scr = __raw_readl(SSI2_SCR) & ~(SSI_SCR_SYN | SSI_SCR_NET);
+
+	if (scr & SSI_SCR_SSIEN)
+		return 0;
+
+	/* DAI mode */
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		/* data on rising edge of bclk, frame low 1clk before data */
+		stcr |= SSI_STCR_TFSI | SSI_STCR_TEFS | SSI_STCR_TXBIT0;
+		srcr |= SSI_SRCR_RFSI | SSI_SRCR_REFS | SSI_SRCR_RXBIT0;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		/* data on rising edge of bclk, frame high with data */
+		stcr |= SSI_STCR_TXBIT0;
+		srcr |= SSI_SRCR_RXBIT0;
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		/* data on rising edge of bclk, frame high with data */
+		stcr |= SSI_STCR_TFSL;
+		srcr |= SSI_SRCR_RFSL;
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		/* data on rising edge of bclk, frame high 1clk before data */
+		stcr |= SSI_STCR_TFSL | SSI_STCR_TEFS;
+		srcr |= SSI_SRCR_RFSL | SSI_SRCR_REFS;
+		break;
+	}
+
+	/* DAI clock inversion */
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_IB_IF:
+		stcr &= ~(SSI_STCR_TSCKP | SSI_STCR_TFSI);
+		srcr &= ~(SSI_SRCR_RSCKP | SSI_SRCR_RFSI);
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		stcr |= SSI_STCR_TFSI;
+		stcr &= ~SSI_STCR_TSCKP;
+		srcr |= SSI_SRCR_RFSI;
+		srcr &= ~SSI_SRCR_RSCKP;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		stcr &= ~SSI_STCR_TFSI;
+		stcr |= SSI_STCR_TSCKP;
+		srcr &= ~SSI_SRCR_RFSI;
+		srcr |= SSI_SRCR_RSCKP;
+		break;
+	case SND_SOC_DAIFMT_NB_NF:
+		stcr |= SSI_STCR_TFSI | SSI_STCR_TSCKP;
+		srcr |= SSI_SRCR_RFSI | SSI_SRCR_RSCKP;
+		break;
+	}
+
+	/* DAI clock master masks */
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		stcr |= SSI_STCR_TFDIR | SSI_STCR_TXDIR;
+		if (((fmt & SND_SOC_DAIFMT_FORMAT_MASK) == SND_SOC_DAIFMT_I2S)
+		    && ssi_mode->network_mode) {
+			scr &= ~SSI_SCR_I2S_MODE_MASK;
+			scr |= SSI_SCR_I2S_MODE_MSTR;
+		}
+		break;
+	case SND_SOC_DAIFMT_CBM_CFS:
+		stcr |= SSI_STCR_TFDIR;
+		srcr |= SSI_SRCR_RFDIR;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFM:
+		stcr |= SSI_STCR_TXDIR;
+		srcr |= SSI_SRCR_RXDIR;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFM:
+		if (((fmt & SND_SOC_DAIFMT_FORMAT_MASK) == SND_SOC_DAIFMT_I2S)
+		    && ssi_mode->network_mode) {
+			scr &= ~SSI_SCR_I2S_MODE_MASK;
+			scr |= SSI_SCR_I2S_MODE_SLAVE;
+		}
+		break;
+	}
+
+	/* sync */
+	if (ssi_mode->sync_mode)
+		scr |= SSI_SCR_SYN;
+
+	/* tdm - only for stereo atm */
+	if (ssi_mode->network_mode)
+		scr |= SSI_SCR_NET;
+
+	if (cpu_dai->id == IMX_DAI_SSI0 || cpu_dai->id == IMX_DAI_SSI1) {
+		__raw_writel(stcr, SSI1_STCR);
+		__raw_writel(srcr, SSI1_SRCR);
+		__raw_writel(scr, SSI1_SCR);
+	} else {
+		__raw_writel(stcr, SSI2_STCR);
+		__raw_writel(srcr, SSI2_SRCR);
+		__raw_writel(scr, SSI2_SCR);
+	}
+	SSI_DUMP();
+	return 0;
+}
+
+static struct clk *ssi1_clk;
+static struct clk *ssi2_clk;
+
+static int imx_ssi_startup(struct snd_pcm_substream *substream,
+			   struct snd_soc_dai *cpu_dai)
+{
+	/* we cant really change any SSI values after SSI is enabled
+	 * need to fix in software for max flexibility - lrg */
+	if (cpu_dai->playback.active || cpu_dai->capture.active)
+		return 0;
+
+	/* reset the SSI port - Sect 45.4.4 */
+	if (cpu_dai->id == IMX_DAI_SSI0 || cpu_dai->id == IMX_DAI_SSI1) {
+
+		if (ssi_active[SSI1_PORT]++)
+			return 0;
+
+		__raw_writel(0, SSI1_SCR);
+		ssi1_clk = clk_get(NULL, "ssi_clk.0");
+		clk_enable(ssi1_clk);
+
+		/* BIG FAT WARNING
+		 * SDMA FIFO watermark must == SSI FIFO watermark for
+		 * best results.
+		 */
+		__raw_writel((SSI_SFCSR_RFWM1(SSI_RXFIFO_WATERMARK) |
+			      SSI_SFCSR_RFWM0(SSI_RXFIFO_WATERMARK) |
+			      SSI_SFCSR_TFWM1(SSI_TXFIFO_WATERMARK) |
+			      SSI_SFCSR_TFWM0(SSI_TXFIFO_WATERMARK)),
+			     SSI1_SFCSR);
+		__raw_writel(0, SSI1_SIER);
+	} else {
+
+		if (ssi_active[SSI2_PORT]++)
+			return 0;
+
+		__raw_writel(0, SSI2_SCR);
+		ssi2_clk = clk_get(NULL, "ssi_clk.1");
+		clk_enable(ssi2_clk);
+		/* above warning applies here too */
+		__raw_writel((SSI_SFCSR_RFWM1(SSI_RXFIFO_WATERMARK) |
+			      SSI_SFCSR_RFWM0(SSI_RXFIFO_WATERMARK) |
+			      SSI_SFCSR_TFWM1(SSI_TXFIFO_WATERMARK) |
+			      SSI_SFCSR_TFWM0(SSI_TXFIFO_WATERMARK)),
+			     SSI2_SFCSR);
+		__raw_writel(0, SSI2_SIER);
+	}
+
+	SSI_DUMP();
+	return 0;
+}
+
+static int imx_ssi_hw_tx_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params,
+				struct snd_soc_dai *cpu_dai)
+{
+	u32 stccr, stcr, sier;
+
+	if (cpu_dai->id == IMX_DAI_SSI0 || cpu_dai->id == IMX_DAI_SSI1) {
+		stccr = __raw_readl(SSI1_STCCR) & ~SSI_STCCR_WL_MASK;
+		stcr = __raw_readl(SSI1_STCR);
+		sier = __raw_readl(SSI1_SIER);
+	} else {
+		stccr = __raw_readl(SSI2_STCCR) & ~SSI_STCCR_WL_MASK;
+		stcr = __raw_readl(SSI2_STCR);
+		sier = __raw_readl(SSI2_SIER);
+	}
+
+	/* DAI data (word) size */
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		stccr |= SSI_STCCR_WL(16);
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		stccr |= SSI_STCCR_WL(20);
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		stccr |= SSI_STCCR_WL(24);
+		break;
+	}
+
+	/* enable interrupts */
+	if (cpu_dai->id == IMX_DAI_SSI0 || cpu_dai->id == IMX_DAI_SSI2)
+		stcr |= SSI_STCR_TFEN0;
+	else
+		stcr |= SSI_STCR_TFEN1;
+	sier |= SSI_SIER_TDMAE | SSI_SIER_TIE | SSI_SIER_TUE0_EN;
+
+	if (cpu_dai->id == IMX_DAI_SSI0 || cpu_dai->id == IMX_DAI_SSI1) {
+		__raw_writel(stcr, SSI1_STCR);
+		__raw_writel(stccr, SSI1_STCCR);
+		__raw_writel(sier, SSI1_SIER);
+	} else {
+		__raw_writel(stcr, SSI2_STCR);
+		__raw_writel(stccr, SSI2_STCCR);
+		__raw_writel(sier, SSI2_SIER);
+	}
+
+	return 0;
+}
+
+static int imx_ssi_hw_rx_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params,
+				struct snd_soc_dai *cpu_dai)
+{
+	u32 srccr, srcr, sier;
+	struct imx_ssi *ssi_mode = (struct imx_ssi *)cpu_dai->private_data;
+	bool sync_mode = ssi_mode->sync_mode;
+
+	if (cpu_dai->id == IMX_DAI_SSI0 || cpu_dai->id == IMX_DAI_SSI1) {
+		srccr =
+		    sync_mode ? __raw_readl(SSI1_STCCR) :
+		    __raw_readl(SSI1_SRCCR);
+		srcr = __raw_readl(SSI1_SRCR);
+		sier = __raw_readl(SSI1_SIER);
+	} else {
+		srccr =
+		    sync_mode ? __raw_readl(SSI2_STCCR) :
+		    __raw_readl(SSI2_SRCCR);
+		srcr = __raw_readl(SSI2_SRCR);
+		sier = __raw_readl(SSI2_SIER);
+	}
+	srccr &= ~SSI_SRCCR_WL_MASK;
+
+	/* DAI data (word) size */
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		srccr |= SSI_SRCCR_WL(16);
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		srccr |= SSI_SRCCR_WL(20);
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		srccr |= SSI_SRCCR_WL(24);
+		break;
+	}
+
+	/* enable interrupts */
+	if (cpu_dai->id == IMX_DAI_SSI0 || cpu_dai->id == IMX_DAI_SSI2)
+		srcr |= SSI_SRCR_RFEN0;
+	else
+		srcr |= SSI_SRCR_RFEN1;
+	sier |= SSI_SIER_RDMAE | SSI_SIER_RIE | SSI_SIER_ROE0_EN;
+
+	if (cpu_dai->id == IMX_DAI_SSI0 || cpu_dai->id == IMX_DAI_SSI1) {
+		__raw_writel(srcr, SSI1_SRCR);
+		if (sync_mode)
+			__raw_writel(srccr, SSI1_STCCR);
+		else
+			__raw_writel(srccr, SSI1_SRCCR);
+		__raw_writel(sier, SSI1_SIER);
+	} else {
+		__raw_writel(srcr, SSI2_SRCR);
+		if (sync_mode)
+			__raw_writel(srccr, SSI2_STCCR);
+		else
+			__raw_writel(srccr, SSI2_SRCCR);
+		__raw_writel(sier, SSI2_SIER);
+	}
+	return 0;
+}
+
+/*
+ * Should only be called when port is inactive (i.e. SSIEN = 0),
+ * although can be called multiple times by upper layers.
+ */
+static int imx_ssi_hw_params(struct snd_pcm_substream *substream,
+			     struct snd_pcm_hw_params *params,
+			     struct snd_soc_dai *cpu_dai)
+{
+	int id;
+
+	id = cpu_dai->id;
+
+	/* Tx/Rx config */
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		/* cant change any parameters when SSI is running */
+		if (id == IMX_DAI_SSI0 || id == IMX_DAI_SSI1) {
+			if ((__raw_readl(SSI1_SCR) & SSI_SCR_SSIEN) &&
+			    (__raw_readl(SSI1_SCR) & SSI_SCR_TE))
+				return 0;
+		} else {
+			if ((__raw_readl(SSI2_SCR) & SSI_SCR_SSIEN) &&
+			    (__raw_readl(SSI2_SCR) & SSI_SCR_TE))
+				return 0;
+		}
+		return imx_ssi_hw_tx_params(substream, params, cpu_dai);
+	} else {
+		/* cant change any parameters when SSI is running */
+		if (id == IMX_DAI_SSI0 || id == IMX_DAI_SSI1) {
+			if ((__raw_readl(SSI1_SCR) & SSI_SCR_SSIEN) &&
+			    (__raw_readl(SSI1_SCR) & SSI_SCR_RE))
+				return 0;
+		} else {
+			if ((__raw_readl(SSI2_SCR) & SSI_SCR_SSIEN) &&
+			    (__raw_readl(SSI2_SCR) & SSI_SCR_RE))
+				return 0;
+		}
+		return imx_ssi_hw_rx_params(substream, params, cpu_dai);
+	}
+}
+
+static int imx_ssi_prepare(struct snd_pcm_substream *substream,
+			   struct snd_soc_dai *cpu_dai)
+{
+	u32 scr;
+
+	/* enable the SSI port, note that no other port config
+	 * should happen after SSIEN is set */
+	if (cpu_dai->id == IMX_DAI_SSI0 || cpu_dai->id == IMX_DAI_SSI1) {
+		scr = __raw_readl(SSI1_SCR);
+		__raw_writel((scr | SSI_SCR_SSIEN), SSI1_SCR);
+	} else {
+		scr = __raw_readl(SSI2_SCR);
+		__raw_writel((scr | SSI_SCR_SSIEN), SSI2_SCR);
+	}
+	SSI_DUMP();
+	return 0;
+}
+
+static int imx_ssi_trigger(struct snd_pcm_substream *substream, int cmd,
+			   struct snd_soc_dai *cpu_dai)
+{
+	u32 scr;
+
+	if (cpu_dai->id == IMX_DAI_SSI0 || cpu_dai->id == IMX_DAI_SSI1)
+		scr = __raw_readl(SSI1_SCR);
+	else
+		scr = __raw_readl(SSI2_SCR);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			if (scr & SSI_SCR_RE) {
+				if (cpu_dai->id == IMX_DAI_SSI0
+				    || cpu_dai->id == IMX_DAI_SSI1)
+					__raw_writel(0, SSI1_SCR);
+				else
+					__raw_writel(0, SSI2_SCR);
+			}
+			scr |= SSI_SCR_TE;
+		} else
+			scr |= SSI_SCR_RE;
+		break;
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			scr &= ~SSI_SCR_TE;
+		else
+			scr &= ~SSI_SCR_RE;
+		break;
+	default:
+		return -EINVAL;
+	}
+	if (cpu_dai->id == IMX_DAI_SSI0 || cpu_dai->id == IMX_DAI_SSI1)
+		__raw_writel(scr, SSI1_SCR);
+	else
+		__raw_writel(scr, SSI2_SCR);
+
+	SSI_DUMP();
+	return 0;
+}
+
+static void imx_ssi_shutdown(struct snd_pcm_substream *substream,
+			     struct snd_soc_dai *cpu_dai)
+{
+	int id;
+
+	id = cpu_dai->id;
+
+	/* shutdown SSI if neither Tx or Rx is active */
+	if (cpu_dai->playback.active || cpu_dai->capture.active)
+		return;
+
+	if (id == IMX_DAI_SSI0 || id == IMX_DAI_SSI1) {
+
+		if (--ssi_active[SSI1_PORT] > 1)
+			return;
+
+		__raw_writel(0, SSI1_SCR);
+
+		clk_disable(ssi1_clk);
+		clk_put(ssi1_clk);
+
+	} else {
+		if (--ssi_active[SSI2_PORT])
+			return;
+		__raw_writel(0, SSI2_SCR);
+		clk_disable(ssi2_clk);
+		clk_put(ssi2_clk);
+	}
+}
+
+#ifdef CONFIG_PM
+static int imx_ssi_suspend(struct snd_soc_dai *dai)
+{
+	if (!dai->active)
+		return 0;
+
+	/* do we need to disable any clocks? */
+
+	return 0;
+}
+
+static int imx_ssi_resume(struct snd_soc_dai *dai)
+{
+	if (!dai->active)
+		return 0;
+
+	/* do we need to enable any clocks? */
+
+	return 0;
+}
+#else
+#define imx_ssi_suspend	NULL
+#define imx_ssi_resume	NULL
+#endif
+
+static int fifo_err_counter;
+
+static irqreturn_t ssi1_irq(int irq, void *dev_id)
+{
+	if (fifo_err_counter++ % 1000 == 0)
+		printk(KERN_ERR "ssi1_irq SISR %x SIER %x fifo_errs=%d\n",
+		       __raw_readl(SSI1_SISR), __raw_readl(SSI1_SIER),
+		       fifo_err_counter);
+	__raw_writel((SSI_SIER_TUE0_EN | SSI_SIER_ROE0_EN), SSI1_SISR);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t ssi2_irq(int irq, void *dev_id)
+{
+	if (fifo_err_counter++ % 1000 == 0)
+		printk(KERN_ERR "ssi2_irq SISR %x SIER %x fifo_errs=%d\n",
+		       __raw_readl(SSI2_SISR), __raw_readl(SSI2_SIER),
+		       fifo_err_counter);
+	__raw_writel((SSI_SIER_TUE0_EN | SSI_SIER_ROE0_EN), SSI2_SISR);
+	return IRQ_HANDLED;
+}
+
+static int imx_ssi_probe(struct platform_device *pdev, struct snd_soc_dai *dai)
+{
+	if ((!strcmp(dai->name, "imx-ssi-1-0")) ||
+	    (!strcmp(dai->name, "imx-ssi-1-1")))
+		if (request_irq(MXC_INT_SSI1, ssi1_irq, 0, "ssi1", dai)) {
+			printk(KERN_ERR "%s: failure requesting irq %s\n",
+			       __func__, "ssi1");
+			return -EBUSY;
+		}
+
+	if ((!strcmp(dai->name, "imx-ssi-2-0")) ||
+	    (!strcmp(dai->name, "imx-ssi-2-1")))
+		if (request_irq(MXC_INT_SSI2, ssi2_irq, 0, "ssi2", dai)) {
+			printk(KERN_ERR "%s: failure requesting irq %s\n",
+			       __func__, "ssi2");
+			return -EBUSY;
+		}
+
+	return 0;
+}
+
+static void imx_ssi_remove(struct platform_device *pdev,
+			   struct snd_soc_dai *dai)
+{
+	if ((!strcmp(dai->name, "imx-ssi-1-0")) ||
+	    (!strcmp(dai->name, "imx-ssi-1-1")))
+		free_irq(MXC_INT_SSI1, dai);
+
+	if ((!strcmp(dai->name, "imx-ssi-2-0")) ||
+	    (!strcmp(dai->name, "imx-ssi-2-1")))
+		free_irq(MXC_INT_SSI2, dai);
+}
+
+#define IMX_SSI_RATES \
+	(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | \
+	SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 | \
+	SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+	SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | \
+	SNDRV_PCM_RATE_96000)
+
+#define IMX_SSI_FORMATS \
+	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
+	SNDRV_PCM_FMTBIT_S24_LE)
+
+static struct snd_soc_dai_ops imx_ssi_dai_ops = {
+	.startup = imx_ssi_startup,
+	.shutdown = imx_ssi_shutdown,
+	.trigger = imx_ssi_trigger,
+	.prepare = imx_ssi_prepare,
+	.hw_params = imx_ssi_hw_params,
+	.set_sysclk = imx_ssi_set_dai_sysclk,
+	.set_clkdiv = imx_ssi_set_dai_clkdiv,
+	.set_fmt = imx_ssi_set_dai_fmt,
+	.set_tdm_slot = imx_ssi_set_dai_tdm_slot,
+};
+
+struct snd_soc_dai imx_ssi_dai[] = {
+	{
+	 .name = "imx-ssi-1-0",
+	 .id = IMX_DAI_SSI0,
+	 .probe = imx_ssi_probe,
+	 .suspend = imx_ssi_suspend,
+	 .remove = imx_ssi_remove,
+	 .resume = imx_ssi_resume,
+	 .playback = {
+		      .channels_min = 1,
+		      .channels_max = 2,
+		      .rates = IMX_SSI_RATES,
+		      .formats = IMX_SSI_FORMATS,
+		      },
+	 .capture = {
+		     .channels_min = 1,
+		     .channels_max = 2,
+		     .rates = IMX_SSI_RATES,
+		     .formats = IMX_SSI_FORMATS,
+		     },
+	 .ops = &imx_ssi_dai_ops,
+	 .private_data = &imx_ssi_data[IMX_DAI_SSI0],
+	 },
+	{
+	 .name = "imx-ssi-1-1",
+	 .id = IMX_DAI_SSI1,
+	 .probe = imx_ssi_probe,
+	 .suspend = imx_ssi_suspend,
+	 .remove = imx_ssi_remove,
+	 .resume = imx_ssi_resume,
+	 .playback = {
+		      .channels_min = 1,
+		      .channels_max = 2,
+		      .rates = IMX_SSI_RATES,
+		      .formats = IMX_SSI_FORMATS,
+		      },
+	 .capture = {
+		     .channels_min = 1,
+		     .channels_max = 2,
+		     .rates = IMX_SSI_RATES,
+		     .formats = IMX_SSI_FORMATS,
+		     },
+	 .ops = &imx_ssi_dai_ops,
+	 .private_data = &imx_ssi_data[IMX_DAI_SSI1],
+	 },
+	{
+	 .name = "imx-ssi-2-0",
+	 .id = IMX_DAI_SSI2,
+	 .probe = imx_ssi_probe,
+	 .suspend = imx_ssi_suspend,
+	 .remove = imx_ssi_remove,
+	 .resume = imx_ssi_resume,
+	 .playback = {
+		      .channels_min = 1,
+		      .channels_max = 2,
+		      .rates = IMX_SSI_RATES,
+		      .formats = IMX_SSI_FORMATS,
+		      },
+	 .capture = {
+		     .channels_min = 1,
+		     .channels_max = 2,
+		     .rates = IMX_SSI_RATES,
+		     .formats = IMX_SSI_FORMATS,
+		     },
+	 .ops = &imx_ssi_dai_ops,
+	 .private_data = &imx_ssi_data[IMX_DAI_SSI2],
+	 },
+	{
+	 .name = "imx-ssi-2-1",
+	 .id = IMX_DAI_SSI3,
+	 .probe = imx_ssi_probe,
+	 .suspend = imx_ssi_suspend,
+	 .remove = imx_ssi_remove,
+	 .resume = imx_ssi_resume,
+	 .playback = {
+		      .channels_min = 1,
+		      .channels_max = 2,
+		      .rates = IMX_SSI_RATES,
+		      .formats = IMX_SSI_FORMATS,
+		      },
+	 .capture = {
+		     .channels_min = 1,
+		     .channels_max = 2,
+		     .rates = IMX_SSI_RATES,
+		     .formats = IMX_SSI_FORMATS,
+		     },
+	 .ops = &imx_ssi_dai_ops,
+	 .private_data = &imx_ssi_data[IMX_DAI_SSI3],
+	 },
+};
+EXPORT_SYMBOL_GPL(imx_ssi_dai);
+
+static int __init imx_ssi_init(void)
+{
+	return snd_soc_register_dais(imx_ssi_dai, ARRAY_SIZE(imx_ssi_dai));
+}
+
+static void __exit imx_ssi_exit(void)
+{
+	snd_soc_unregister_dais(imx_ssi_dai, ARRAY_SIZE(imx_ssi_dai));
+}
+
+module_init(imx_ssi_init);
+module_exit(imx_ssi_exit);
+MODULE_AUTHOR
+    ("Liam Girdwood, liam.girdwood@wolfsonmicro.com, www.wolfsonmicro.com");
+MODULE_DESCRIPTION("i.MX ASoC I2S driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/imx/mxc-ssi.h b/sound/soc/imx/mxc-ssi.h
new file mode 100644
index 0000000..826386e
--- /dev/null
+++ b/sound/soc/imx/mxc-ssi.h
@@ -0,0 +1,236 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _IMX_SSI_H
+#define _IMX_SSI_H
+
+#include <mach/hardware.h>
+
+/* SSI regs definition */
+#define SSI1_IO_BASE_ADDR	IO_ADDRESS(SSI1_BASE_ADDR)
+#define SSI2_IO_BASE_ADDR	IO_ADDRESS(SSI2_BASE_ADDR)
+
+#define SSI1_STX0   ((SSI1_IO_BASE_ADDR) + 0x00)
+#define SSI1_STX1   ((SSI1_IO_BASE_ADDR) + 0x04)
+#define SSI1_SRX0   ((SSI1_IO_BASE_ADDR) + 0x08)
+#define SSI1_SRX1   ((SSI1_IO_BASE_ADDR) + 0x0c)
+#define SSI1_SCR    ((SSI1_IO_BASE_ADDR) + 0x10)
+#define SSI1_SISR   ((SSI1_IO_BASE_ADDR) + 0x14)
+#define SSI1_SIER   ((SSI1_IO_BASE_ADDR) + 0x18)
+#define SSI1_STCR   ((SSI1_IO_BASE_ADDR) + 0x1c)
+#define SSI1_SRCR   ((SSI1_IO_BASE_ADDR) + 0x20)
+#define SSI1_STCCR  ((SSI1_IO_BASE_ADDR) + 0x24)
+#define SSI1_SRCCR  ((SSI1_IO_BASE_ADDR) + 0x28)
+#define SSI1_SFCSR  ((SSI1_IO_BASE_ADDR) + 0x2c)
+#define SSI1_STR    ((SSI1_IO_BASE_ADDR) + 0x30)
+#define SSI1_SOR    ((SSI1_IO_BASE_ADDR) + 0x34)
+#define SSI1_SACNT  ((SSI1_IO_BASE_ADDR) + 0x38)
+#define SSI1_SACADD ((SSI1_IO_BASE_ADDR) + 0x3c)
+#define SSI1_SACDAT ((SSI1_IO_BASE_ADDR) + 0x40)
+#define SSI1_SATAG  ((SSI1_IO_BASE_ADDR) + 0x44)
+#define SSI1_STMSK  ((SSI1_IO_BASE_ADDR) + 0x48)
+#define SSI1_SRMSK  ((SSI1_IO_BASE_ADDR) + 0x4c)
+#define SSI1_SACCST ((SSI1_IO_BASE_ADDR) + 0x50)
+#define SSI1_SACCEN ((SSI1_IO_BASE_ADDR) + 0x54)
+#define SSI1_SACCDIS ((SSI1_IO_BASE_ADDR) + 0x58)
+
+#define SSI2_STX0   ((SSI2_IO_BASE_ADDR) + 0x00)
+#define SSI2_STX1   ((SSI2_IO_BASE_ADDR) + 0x04)
+#define SSI2_SRX0   ((SSI2_IO_BASE_ADDR) + 0x08)
+#define SSI2_SRX1   ((SSI2_IO_BASE_ADDR) + 0x0c)
+#define SSI2_SCR    ((SSI2_IO_BASE_ADDR) + 0x10)
+#define SSI2_SISR   ((SSI2_IO_BASE_ADDR) + 0x14)
+#define SSI2_SIER   ((SSI2_IO_BASE_ADDR) + 0x18)
+#define SSI2_STCR   ((SSI2_IO_BASE_ADDR) + 0x1c)
+#define SSI2_SRCR   ((SSI2_IO_BASE_ADDR) + 0x20)
+#define SSI2_STCCR  ((SSI2_IO_BASE_ADDR) + 0x24)
+#define SSI2_SRCCR  ((SSI2_IO_BASE_ADDR) + 0x28)
+#define SSI2_SFCSR  ((SSI2_IO_BASE_ADDR) + 0x2c)
+#define SSI2_STR    ((SSI2_IO_BASE_ADDR) + 0x30)
+#define SSI2_SOR    ((SSI2_IO_BASE_ADDR) + 0x34)
+#define SSI2_SACNT  ((SSI2_IO_BASE_ADDR) + 0x38)
+#define SSI2_SACADD ((SSI2_IO_BASE_ADDR) + 0x3c)
+#define SSI2_SACDAT ((SSI2_IO_BASE_ADDR) + 0x40)
+#define SSI2_SATAG  ((SSI2_IO_BASE_ADDR) + 0x44)
+#define SSI2_STMSK  ((SSI2_IO_BASE_ADDR) + 0x48)
+#define SSI2_SRMSK  ((SSI2_IO_BASE_ADDR) + 0x4c)
+#define SSI2_SACCST ((SSI2_IO_BASE_ADDR) + 0x50)
+#define SSI2_SACCEN ((SSI2_IO_BASE_ADDR) + 0x54)
+#define SSI2_SACCDIS ((SSI2_IO_BASE_ADDR) + 0x58)
+
+#define SSI_SCR_CLK_IST        (1 << 9)
+#define SSI_SCR_TCH_EN         (1 << 8)
+#define SSI_SCR_SYS_CLK_EN     (1 << 7)
+#define SSI_SCR_I2S_MODE_NORM  (0 << 5)
+#define SSI_SCR_I2S_MODE_MSTR  (1 << 5)
+#define SSI_SCR_I2S_MODE_SLAVE (2 << 5)
+#define SSI_SCR_SYN            (1 << 4)
+#define SSI_SCR_NET            (1 << 3)
+#define SSI_SCR_RE             (1 << 2)
+#define SSI_SCR_TE             (1 << 1)
+#define SSI_SCR_SSIEN          (1 << 0)
+#define SSI_SCR_I2S_MODE_MASK  (3 << 5)
+
+#define SSI_SISR_CMDAU         (1 << 18)
+#define SSI_SISR_CMDDU         (1 << 17)
+#define SSI_SISR_RXT           (1 << 16)
+#define SSI_SISR_RDR1          (1 << 15)
+#define SSI_SISR_RDR0          (1 << 14)
+#define SSI_SISR_TDE1          (1 << 13)
+#define SSI_SISR_TDE0          (1 << 12)
+#define SSI_SISR_ROE1          (1 << 11)
+#define SSI_SISR_ROE0          (1 << 10)
+#define SSI_SISR_TUE1          (1 << 9)
+#define SSI_SISR_TUE0          (1 << 8)
+#define SSI_SISR_TFS           (1 << 7)
+#define SSI_SISR_RFS           (1 << 6)
+#define SSI_SISR_TLS           (1 << 5)
+#define SSI_SISR_RLS           (1 << 4)
+#define SSI_SISR_RFF1          (1 << 3)
+#define SSI_SISR_RFF0          (1 << 2)
+#define SSI_SISR_TFE1          (1 << 1)
+#define SSI_SISR_TFE0          (1 << 0)
+
+#define SSI_SIER_RDMAE         (1 << 22)
+#define SSI_SIER_RIE           (1 << 21)
+#define SSI_SIER_TDMAE         (1 << 20)
+#define SSI_SIER_TIE           (1 << 19)
+#define SSI_SIER_CMDAU_EN      (1 << 18)
+#define SSI_SIER_CMDDU_EN      (1 << 17)
+#define SSI_SIER_RXT_EN        (1 << 16)
+#define SSI_SIER_RDR1_EN       (1 << 15)
+#define SSI_SIER_RDR0_EN       (1 << 14)
+#define SSI_SIER_TDE1_EN       (1 << 13)
+#define SSI_SIER_TDE0_EN       (1 << 12)
+#define SSI_SIER_ROE1_EN       (1 << 11)
+#define SSI_SIER_ROE0_EN       (1 << 10)
+#define SSI_SIER_TUE1_EN       (1 << 9)
+#define SSI_SIER_TUE0_EN       (1 << 8)
+#define SSI_SIER_TFS_EN        (1 << 7)
+#define SSI_SIER_RFS_EN        (1 << 6)
+#define SSI_SIER_TLS_EN        (1 << 5)
+#define SSI_SIER_RLS_EN        (1 << 4)
+#define SSI_SIER_RFF1_EN       (1 << 3)
+#define SSI_SIER_RFF0_EN       (1 << 2)
+#define SSI_SIER_TFE1_EN       (1 << 1)
+#define SSI_SIER_TFE0_EN       (1 << 0)
+
+#define SSI_STCR_TXBIT0        (1 << 9)
+#define SSI_STCR_TFEN1         (1 << 8)
+#define SSI_STCR_TFEN0         (1 << 7)
+#define SSI_STCR_TFDIR         (1 << 6)
+#define SSI_STCR_TXDIR         (1 << 5)
+#define SSI_STCR_TSHFD         (1 << 4)
+#define SSI_STCR_TSCKP         (1 << 3)
+#define SSI_STCR_TFSI          (1 << 2)
+#define SSI_STCR_TFSL          (1 << 1)
+#define SSI_STCR_TEFS          (1 << 0)
+
+#define SSI_SRCR_RXBIT0        (1 << 9)
+#define SSI_SRCR_RFEN1         (1 << 8)
+#define SSI_SRCR_RFEN0         (1 << 7)
+#define SSI_SRCR_RFDIR         (1 << 6)
+#define SSI_SRCR_RXDIR         (1 << 5)
+#define SSI_SRCR_RSHFD         (1 << 4)
+#define SSI_SRCR_RSCKP         (1 << 3)
+#define SSI_SRCR_RFSI          (1 << 2)
+#define SSI_SRCR_RFSL          (1 << 1)
+#define SSI_SRCR_REFS          (1 << 0)
+
+#define SSI_STCCR_DIV2         (1 << 18)
+#define SSI_STCCR_PSR          (1 << 15)
+#define SSI_STCCR_WL(x)        ((((x) - 2) >> 1) << 13)
+#define SSI_STCCR_DC(x)        (((x) & 0x1f) << 8)
+#define SSI_STCCR_PM(x)        (((x) & 0xff) << 0)
+#define SSI_STCCR_WL_MASK        (0xf << 13)
+#define SSI_STCCR_DC_MASK        (0x1f << 8)
+#define SSI_STCCR_PM_MASK        (0xff << 0)
+
+#define SSI_SRCCR_DIV2         (1 << 18)
+#define SSI_SRCCR_PSR          (1 << 15)
+#define SSI_SRCCR_WL(x)        ((((x) - 2) >> 1) << 13)
+#define SSI_SRCCR_DC(x)        (((x) & 0x1f) << 8)
+#define SSI_SRCCR_PM(x)        (((x) & 0xff) << 0)
+#define SSI_SRCCR_WL_MASK        (0xf << 13)
+#define SSI_SRCCR_DC_MASK        (0x1f << 8)
+#define SSI_SRCCR_PM_MASK        (0xff << 0)
+
+
+#define SSI_SFCSR_RFCNT1(x)   (((x) & 0xf) << 28)
+#define SSI_SFCSR_TFCNT1(x)   (((x) & 0xf) << 24)
+#define SSI_SFCSR_RFWM1(x)    (((x) & 0xf) << 20)
+#define SSI_SFCSR_TFWM1(x)    (((x) & 0xf) << 16)
+#define SSI_SFCSR_RFCNT0(x)   (((x) & 0xf) << 12)
+#define SSI_SFCSR_TFCNT0(x)   (((x) & 0xf) <<  8)
+#define SSI_SFCSR_RFWM0(x)    (((x) & 0xf) <<  4)
+#define SSI_SFCSR_TFWM0(x)    (((x) & 0xf) <<  0)
+
+#define SSI_STR_TEST          (1 << 15)
+#define SSI_STR_RCK2TCK       (1 << 14)
+#define SSI_STR_RFS2TFS       (1 << 13)
+#define SSI_STR_RXSTATE(x)    (((x) & 0xf) << 8)
+#define SSI_STR_TXD2RXD       (1 <<  7)
+#define SSI_STR_TCK2RCK       (1 <<  6)
+#define SSI_STR_TFS2RFS       (1 <<  5)
+#define SSI_STR_TXSTATE(x)    (((x) & 0xf) << 0)
+
+#define SSI_SOR_CLKOFF        (1 << 6)
+#define SSI_SOR_RX_CLR        (1 << 5)
+#define SSI_SOR_TX_CLR        (1 << 4)
+#define SSI_SOR_INIT          (1 << 3)
+#define SSI_SOR_WAIT(x)       (((x) & 0x3) << 1)
+#define SSI_SOR_SYNRST        (1 << 0)
+
+#define SSI_SACNT_FRDIV(x)    (((x) & 0x3f) << 5)
+#define SSI_SACNT_WR          (1 << 4)
+#define SSI_SACNT_RD          (1 << 3)
+#define SSI_SACNT_TIF         (1 << 2)
+#define SSI_SACNT_FV          (1 << 1)
+#define SSI_SACNT_AC97EN      (1 << 0)
+
+/* SDMA & SSI watermarks for FIFO's */
+#define SDMA_TXFIFO_WATERMARK		0x4
+#define SDMA_RXFIFO_WATERMARK		0x6
+#define SSI_TXFIFO_WATERMARK		0x4
+#define SSI_RXFIFO_WATERMARK		0x6
+
+/* i.MX DAI SSP ID's */
+#define IMX_DAI_SSI0			0 /* SSI1 FIFO 0 */
+#define IMX_DAI_SSI1			1 /* SSI1 FIFO 1 */
+#define IMX_DAI_SSI2			2 /* SSI2 FIFO 0 */
+#define IMX_DAI_SSI3			3 /* SSI2 FIFO 1 */
+
+/* SSI clock sources */
+#define IMX_SSP_SYS_CLK			0
+
+/* SSI audio dividers */
+#define IMX_SSI_TX_DIV_2		0
+#define IMX_SSI_TX_DIV_PSR		1
+#define IMX_SSI_TX_DIV_PM		2
+#define IMX_SSI_RX_DIV_2		3
+#define IMX_SSI_RX_DIV_PSR		4
+#define IMX_SSI_RX_DIV_PM		5
+
+
+/* SSI Div 2 */
+#define IMX_SSI_DIV_2_OFF		(~SSI_STCCR_DIV2)
+#define IMX_SSI_DIV_2_ON		SSI_STCCR_DIV2
+
+#define IMX_DAI_AC97_1 0
+#define IMX_DAI_AC97_2 1
+
+/* private info */
+struct imx_ssi {
+	bool network_mode;
+	bool sync_mode;
+	unsigned int ac97_tx_slots;
+	unsigned int ac97_rx_slots;
+};
+
+extern struct snd_soc_dai imx_ssi_dai[];
+extern struct snd_soc_dai imx_ac97_dai[];
+
+#endif
-- 
1.6.5.2

