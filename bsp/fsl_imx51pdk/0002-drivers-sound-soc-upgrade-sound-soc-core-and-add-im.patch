From 0eb613d3cc340e8e854223de37083da40eea83d8 Mon Sep 17 00:00:00 2001
From: Wang Hui <Hui.Wang@windriver.com>
Date: Wed, 2 Sep 2009 15:35:26 +0800
Subject: [PATCH] drivers/sound/soc: upgrade sound soc core and add imx sound driver

Original reference source code taken from Freescale internal use
version:Linux2.6.28_4.1.0_MX51TO2_FC_ER8.tar.gz and mainline version
linux-2.6.27

The sound soc core code and header files are old, but the existing
drivers under the sound soc framework are all based on the new sound
soc version. So this patch upgrade the sound soc core and related
header files from the mainline linux-2.6.27. Then based on the
upgraded sound soc interface, adding the imx sound driver.

Signed-off-by: Wang Hui <Hui.Wang@windriver.com>
---
 include/sound/soc-dapm.h            |    3 +-
 include/sound/soc.h                 |  246 +++++++--
 sound/soc/Kconfig                   |    1 +
 sound/soc/Makefile                  |    3 +-
 sound/soc/codecs/Kconfig            |    4 +
 sound/soc/codecs/Makefile           |    2 +
 sound/soc/codecs/sgtl5000.c         | 1076 +++++++++++++++++++++++++++++++++++
 sound/soc/codecs/sgtl5000.h         |  402 +++++++++++++
 sound/soc/imx/Kconfig               |   30 +
 sound/soc/imx/Makefile              |   11 +
 sound/soc/imx/imx-3stack-sgtl5000.c |  594 +++++++++++++++++++
 sound/soc/imx/imx-esai.h            |   25 +
 sound/soc/imx/imx-pcm.c             |  595 +++++++++++++++++++
 sound/soc/imx/imx-pcm.h             |   70 +++
 sound/soc/imx/imx-ssi.c             |  780 +++++++++++++++++++++++++
 sound/soc/imx/imx-ssi.h             |  218 +++++++
 sound/soc/soc-core.c                |  557 +++++++-----------
 sound/soc/soc-dapm.c                |  192 ++++---
 18 files changed, 4329 insertions(+), 480 deletions(-)
 create mode 100644 sound/soc/codecs/sgtl5000.c
 create mode 100644 sound/soc/codecs/sgtl5000.h
 create mode 100644 sound/soc/imx/Kconfig
 create mode 100644 sound/soc/imx/Makefile
 create mode 100644 sound/soc/imx/imx-3stack-sgtl5000.c
 create mode 100644 sound/soc/imx/imx-esai.h
 create mode 100644 sound/soc/imx/imx-pcm.c
 create mode 100644 sound/soc/imx/imx-pcm.h
 create mode 100644 sound/soc/imx/imx-ssi.c
 create mode 100644 sound/soc/imx/imx-ssi.h

diff --git a/include/sound/soc-dapm.h b/include/sound/soc-dapm.h
index 7ee2f70..c1b26fc 100644
--- a/include/sound/soc-dapm.h
+++ b/include/sound/soc-dapm.h
@@ -221,6 +221,8 @@ int snd_soc_dapm_new_controls(struct snd_soc_codec *codec,
 	int num);
 
 /* dapm path setup */
+int  __deprecated snd_soc_dapm_connect_input(struct snd_soc_codec *codec,
+	const char *sink_name, const char *control_name, const char *src_name);
 int snd_soc_dapm_new_widgets(struct snd_soc_codec *codec);
 void snd_soc_dapm_free(struct snd_soc_device *socdev);
 int snd_soc_dapm_add_routes(struct snd_soc_codec *codec,
@@ -238,7 +240,6 @@ int snd_soc_dapm_sys_add(struct device *dev);
 /* dapm audio pin control and status */
 int snd_soc_dapm_enable_pin(struct snd_soc_codec *codec, char *pin);
 int snd_soc_dapm_disable_pin(struct snd_soc_codec *codec, char *pin);
-int snd_soc_dapm_nc_pin(struct snd_soc_codec *codec, char *pin);
 int snd_soc_dapm_get_pin_status(struct snd_soc_codec *codec, char *pin);
 int snd_soc_dapm_sync(struct snd_soc_codec *codec);
 
diff --git a/include/sound/soc.h b/include/sound/soc.h
index 444f9c2..1890d87 100644
--- a/include/sound/soc.h
+++ b/include/sound/soc.h
@@ -21,16 +21,15 @@
 #include <sound/control.h>
 #include <sound/ac97_codec.h>
 
+#define SND_SOC_VERSION "0.13.2"
+
 /*
  * Convenience kcontrol builders
  */
-#define SOC_SINGLE_VALUE(xreg, xshift, xmax, xinvert) \
-	((unsigned long)&(struct soc_mixer_control) \
-	{.reg = xreg, .shift = xshift, .rshift = xshift, .max = xmax, \
-	.invert = xinvert})
-#define SOC_SINGLE_VALUE_EXT(xreg, xmax, xinvert) \
-	((unsigned long)&(struct soc_mixer_control) \
-	{.reg = xreg, .max = xmax, .invert = xinvert})
+#define SOC_SINGLE_VALUE(reg, shift, max, invert) ((reg) | ((shift) << 8) |\
+	((shift) << 12) | ((max) << 16) | ((invert) << 24))
+#define SOC_SINGLE_VALUE_EXT(reg, max, invert) ((reg) | ((max) << 16) |\
+	((invert) << 31))
 #define SOC_SINGLE(xname, reg, shift, max, invert) \
 {	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
 	.info = snd_soc_info_volsw, .get = snd_soc_get_volsw,\
@@ -44,68 +43,64 @@
 	.info = snd_soc_info_volsw, .get = snd_soc_get_volsw,\
 	.put = snd_soc_put_volsw, \
 	.private_value =  SOC_SINGLE_VALUE(reg, shift, max, invert) }
-#define SOC_DOUBLE(xname, xreg, shift_left, shift_right, xmax, xinvert) \
+#define SOC_DOUBLE(xname, reg, shift_left, shift_right, max, invert) \
 {	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname),\
 	.info = snd_soc_info_volsw, .get = snd_soc_get_volsw, \
 	.put = snd_soc_put_volsw, \
-	.private_value = (unsigned long)&(struct soc_mixer_control) \
-		{.reg = xreg, .shift = shift_left, .rshift = shift_right, \
-		 .max = xmax, .invert = xinvert} }
-#define SOC_DOUBLE_R(xname, reg_left, reg_right, xshift, xmax, xinvert) \
+	.private_value = (reg) | ((shift_left) << 8) | \
+		((shift_right) << 12) | ((max) << 16) | ((invert) << 24) }
+#define SOC_DOUBLE_R(xname, reg_left, reg_right, shift, max, invert) \
 {	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \
 	.info = snd_soc_info_volsw_2r, \
 	.get = snd_soc_get_volsw_2r, .put = snd_soc_put_volsw_2r, \
-	.private_value = (unsigned long)&(struct soc_mixer_control) \
-		{.reg = reg_left, .rreg = reg_right, .shift = xshift, \
-		.max = xmax, .invert = xinvert} }
-#define SOC_DOUBLE_TLV(xname, xreg, shift_left, shift_right, xmax, xinvert, tlv_array) \
+	.private_value = (reg_left) | ((shift) << 8)  | \
+		((max) << 12) | ((invert) << 20) | ((reg_right) << 24) }
+#define SOC_DOUBLE_TLV(xname, reg, shift_left, shift_right, max, invert, tlv_array) \
 {	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname),\
 	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\
 		 SNDRV_CTL_ELEM_ACCESS_READWRITE,\
 	.tlv.p = (tlv_array), \
 	.info = snd_soc_info_volsw, .get = snd_soc_get_volsw, \
 	.put = snd_soc_put_volsw, \
-	.private_value = (unsigned long)&(struct soc_mixer_control) \
-		{.reg = xreg, .shift = shift_left, .rshift = shift_right,\
-		 .max = xmax, .invert = xinvert} }
-#define SOC_DOUBLE_R_TLV(xname, reg_left, reg_right, xshift, xmax, xinvert, tlv_array) \
+	.private_value = (reg) | ((shift_left) << 8) | \
+		((shift_right) << 12) | ((max) << 16) | ((invert) << 24) }
+#define SOC_DOUBLE_R_TLV(xname, reg_left, reg_right, shift, max, invert, tlv_array) \
 {	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname),\
 	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\
 		 SNDRV_CTL_ELEM_ACCESS_READWRITE,\
 	.tlv.p = (tlv_array), \
 	.info = snd_soc_info_volsw_2r, \
 	.get = snd_soc_get_volsw_2r, .put = snd_soc_put_volsw_2r, \
-	.private_value = (unsigned long)&(struct soc_mixer_control) \
-		{.reg = reg_left, .rreg = reg_right, .shift = xshift, \
-		.max = xmax, .invert = xinvert} }
-#define SOC_DOUBLE_S8_TLV(xname, xreg, xmin, xmax, tlv_array) \
+	.private_value = (reg_left) | ((shift) << 8)  | \
+		((max) << 12) | ((invert) << 20) | ((reg_right) << 24) }
+#define SOC_DOUBLE_S8_TLV(xname, reg, min, max, tlv_array) \
 {	.iface  = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname), \
 	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | \
 		  SNDRV_CTL_ELEM_ACCESS_READWRITE, \
 	.tlv.p  = (tlv_array), \
 	.info   = snd_soc_info_volsw_s8, .get = snd_soc_get_volsw_s8, \
 	.put    = snd_soc_put_volsw_s8, \
-	.private_value = (unsigned long)&(struct soc_mixer_control) \
-		{.reg = xreg, .min = xmin, .max = xmax} }
-#define SOC_ENUM_DOUBLE(xreg, xshift_l, xshift_r, xmax, xtexts) \
+	.private_value = (reg) | (((signed char)max) << 16) | \
+			 (((signed char)min) << 24) }
+#define SOC_ENUM_DOUBLE(xreg, xshift_l, xshift_r, xmask, xtexts) \
 {	.reg = xreg, .shift_l = xshift_l, .shift_r = xshift_r, \
-	.max = xmax, .texts = xtexts }
-#define SOC_ENUM_SINGLE(xreg, xshift, xmax, xtexts) \
-	SOC_ENUM_DOUBLE(xreg, xshift, xshift, xmax, xtexts)
-#define SOC_ENUM_SINGLE_EXT(xmax, xtexts) \
-{	.max = xmax, .texts = xtexts }
+	.mask = xmask, .texts = xtexts }
+#define SOC_ENUM_SINGLE(xreg, xshift, xmask, xtexts) \
+	SOC_ENUM_DOUBLE(xreg, xshift, xshift, xmask, xtexts)
+#define SOC_ENUM_SINGLE_EXT(xmask, xtexts) \
+{	.mask = xmask, .texts = xtexts }
 #define SOC_ENUM(xname, xenum) \
 {	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname,\
 	.info = snd_soc_info_enum_double, \
 	.get = snd_soc_get_enum_double, .put = snd_soc_put_enum_double, \
 	.private_value = (unsigned long)&xenum }
-#define SOC_SINGLE_EXT(xname, xreg, xshift, xmax, xinvert,\
+#define SOC_SINGLE_EXT(xname, xreg, xshift, xmask, xinvert,\
 	 xhandler_get, xhandler_put) \
 {	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
 	.info = snd_soc_info_volsw, \
 	.get = xhandler_get, .put = xhandler_put, \
-	.private_value = SOC_SINGLE_VALUE(xreg, xshift, xmax, xinvert) }
-#define SOC_SINGLE_EXT_TLV(xname, xreg, xshift, xmax, xinvert,\
+	.private_value = SOC_SINGLE_VALUE(xreg, xshift, xmask, xinvert) }
+#define SOC_SINGLE_EXT_TLV(xname, xreg, xshift, xmask, xinvert,\
 	 xhandler_get, xhandler_put, tlv_array) \
 {	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
 	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\
@@ -113,7 +108,7 @@
 	.tlv.p = (tlv_array), \
 	.info = snd_soc_info_volsw, \
 	.get = xhandler_get, .put = xhandler_put, \
-	.private_value = SOC_SINGLE_VALUE(xreg, xshift, xmax, xinvert) }
+	.private_value = SOC_SINGLE_VALUE(xreg, xshift, xmask, xinvert) }
 #define SOC_SINGLE_BOOL_EXT(xname, xdata, xhandler_get, xhandler_put) \
 {	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
 	.info = snd_soc_info_bool_ext, \
@@ -143,6 +138,84 @@ enum snd_soc_bias_level {
 	SND_SOC_BIAS_OFF,
 };
 
+/*
+ * Digital Audio Interface (DAI) types
+ */
+#define SND_SOC_DAI_AC97	0x1
+#define SND_SOC_DAI_I2S		0x2
+#define SND_SOC_DAI_PCM		0x4
+#define SND_SOC_DAI_AC97_BUS	0x8	/* for custom i.e. non ac97_codec.c */
+
+/*
+ * DAI hardware audio formats
+ */
+#define SND_SOC_DAIFMT_I2S		0	/* I2S mode */
+#define SND_SOC_DAIFMT_RIGHT_J	1	/* Right justified mode */
+#define SND_SOC_DAIFMT_LEFT_J	2	/* Left Justified mode */
+#define SND_SOC_DAIFMT_DSP_A	3	/* L data msb after FRM or LRC */
+#define SND_SOC_DAIFMT_DSP_B	4	/* L data msb during FRM or LRC */
+#define SND_SOC_DAIFMT_AC97		5	/* AC97 */
+
+#define SND_SOC_DAIFMT_MSB 	SND_SOC_DAIFMT_LEFT_J
+#define SND_SOC_DAIFMT_LSB	SND_SOC_DAIFMT_RIGHT_J
+
+/*
+ * DAI Gating
+ */
+#define SND_SOC_DAIFMT_CONT			(0 << 4)	/* continuous clock */
+#define SND_SOC_DAIFMT_GATED		(1 << 4)	/* clock is gated when not Tx/Rx */
+
+/*
+ * DAI Sync
+ * Synchronous LR (Left Right) clocks and Frame signals.
+ */
+#define SND_SOC_DAIFMT_SYNC		(0 << 5)	/* Tx FRM = Rx FRM */
+#define SND_SOC_DAIFMT_ASYNC		(1 << 5)	/* Tx FRM ~ Rx FRM */
+
+/*
+ * TDM
+ */
+#define SND_SOC_DAIFMT_TDM		(1 << 6)
+
+/*
+ * DAI hardware signal inversions
+ */
+#define SND_SOC_DAIFMT_NB_NF		(0 << 8)	/* normal bclk + frm */
+#define SND_SOC_DAIFMT_NB_IF		(1 << 8)	/* normal bclk + inv frm */
+#define SND_SOC_DAIFMT_IB_NF		(2 << 8)	/* invert bclk + nor frm */
+#define SND_SOC_DAIFMT_IB_IF		(3 << 8)	/* invert bclk + frm */
+
+/*
+ * DAI hardware clock masters
+ * This is wrt the codec, the inverse is true for the interface
+ * i.e. if the codec is clk and frm master then the interface is
+ * clk and frame slave.
+ */
+#define SND_SOC_DAIFMT_CBM_CFM	(0 << 12) /* codec clk & frm master */
+#define SND_SOC_DAIFMT_CBS_CFM	(1 << 12) /* codec clk slave & frm master */
+#define SND_SOC_DAIFMT_CBM_CFS	(2 << 12) /* codec clk master & frame slave */
+#define SND_SOC_DAIFMT_CBS_CFS	(3 << 12) /* codec clk & frm slave */
+
+#define SND_SOC_DAIFMT_FORMAT_MASK		0x000f
+#define SND_SOC_DAIFMT_CLOCK_MASK		0x00f0
+#define SND_SOC_DAIFMT_INV_MASK			0x0f00
+#define SND_SOC_DAIFMT_MASTER_MASK		0xf000
+
+
+/*
+ * Master Clock Directions
+ */
+#define SND_SOC_CLOCK_IN	0
+#define SND_SOC_CLOCK_OUT	1
+
+/*
+ * AC97 codec ID's bitmask
+ */
+#define SND_SOC_DAI_AC97_ID0	(1 << 0)
+#define SND_SOC_DAI_AC97_ID1	(1 << 1)
+#define SND_SOC_DAI_AC97_ID2	(1 << 2)
+#define SND_SOC_DAI_AC97_ID3	(1 << 3)
+
 struct snd_soc_device;
 struct snd_soc_pcm_stream;
 struct snd_soc_ops;
@@ -150,6 +223,7 @@ struct snd_soc_dai_mode;
 struct snd_soc_pcm_runtime;
 struct snd_soc_dai;
 struct snd_soc_codec;
+struct snd_soc_machine_config;
 struct soc_enum;
 struct snd_soc_ac97_ops;
 struct snd_soc_clock_info;
@@ -182,6 +256,27 @@ int snd_soc_new_ac97_codec(struct snd_soc_codec *codec,
 	struct snd_ac97_bus_ops *ops, int num);
 void snd_soc_free_ac97_codec(struct snd_soc_codec *codec);
 
+/* Digital Audio Interface clocking API.*/
+int snd_soc_dai_set_sysclk(struct snd_soc_dai *dai, int clk_id,
+	unsigned int freq, int dir);
+
+int snd_soc_dai_set_clkdiv(struct snd_soc_dai *dai,
+	int div_id, int div);
+
+int snd_soc_dai_set_pll(struct snd_soc_dai *dai,
+	int pll_id, unsigned int freq_in, unsigned int freq_out);
+
+/* Digital Audio interface formatting */
+int snd_soc_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt);
+
+int snd_soc_dai_set_tdm_slot(struct snd_soc_dai *dai,
+	unsigned int mask, int slots);
+
+int snd_soc_dai_set_tristate(struct snd_soc_dai *dai, int tristate);
+
+/* Digital Audio Interface mute */
+int snd_soc_dai_digital_mute(struct snd_soc_dai *dai, int mute);
+
 /*
  *Controls
  */
@@ -239,6 +334,61 @@ struct snd_soc_ops {
 	int (*trigger)(struct snd_pcm_substream *, int);
 };
 
+/* ASoC DAI ops */
+struct snd_soc_dai_ops {
+	/* DAI clocking configuration */
+	int (*set_sysclk)(struct snd_soc_dai *dai,
+		int clk_id, unsigned int freq, int dir);
+	int (*set_pll)(struct snd_soc_dai *dai,
+		int pll_id, unsigned int freq_in, unsigned int freq_out);
+	int (*set_clkdiv)(struct snd_soc_dai *dai, int div_id, int div);
+
+	/* DAI format configuration */
+	int (*set_fmt)(struct snd_soc_dai *dai, unsigned int fmt);
+	int (*set_tdm_slot)(struct snd_soc_dai *dai,
+		unsigned int mask, int slots);
+	int (*set_tristate)(struct snd_soc_dai *dai, int tristate);
+
+	/* digital mute */
+	int (*digital_mute)(struct snd_soc_dai *dai, int mute);
+};
+
+/* SoC  DAI (Digital Audio Interface) */
+struct snd_soc_dai {
+	/* DAI description */
+	char *name;
+	unsigned int id;
+	unsigned char type;
+
+	/* DAI callbacks */
+	int (*probe)(struct platform_device *pdev,
+		     struct snd_soc_dai *dai);
+	void (*remove)(struct platform_device *pdev,
+		       struct snd_soc_dai *dai);
+	int (*suspend)(struct platform_device *pdev,
+		struct snd_soc_dai *dai);
+	int (*resume)(struct platform_device *pdev,
+		struct snd_soc_dai *dai);
+
+	/* ops */
+	struct snd_soc_ops ops;
+	struct snd_soc_dai_ops dai_ops;
+
+	/* DAI capabilities */
+	struct snd_soc_pcm_stream capture;
+	struct snd_soc_pcm_stream playback;
+
+	/* DAI runtime info */
+	struct snd_pcm_runtime *runtime;
+	struct snd_soc_codec *codec;
+	unsigned int active;
+	unsigned char pop_wait:1;
+	void *dma_data;
+
+	/* DAI private data */
+	void *private_data;
+};
+
 /* SoC Audio Codec */
 struct snd_soc_codec {
 	char *name;
@@ -260,8 +410,6 @@ struct snd_soc_codec {
 	void *control_data; /* codec control (i2c/3wire) data */
 	unsigned int (*read)(struct snd_soc_codec *, unsigned int);
 	int (*write)(struct snd_soc_codec *, unsigned int, unsigned int);
-	int (*display_register)(struct snd_soc_codec *, char *,
-				size_t, unsigned int);
 	hw_write_t hw_write;
 	hw_read_t hw_read;
 	void *reg_cache;
@@ -269,7 +417,6 @@ struct snd_soc_codec {
 	short reg_cache_step;
 
 	/* dapm */
-	u32 pop_time;
 	struct list_head dapm_widgets;
 	struct list_head dapm_paths;
 	enum snd_soc_bias_level bias_level;
@@ -328,8 +475,8 @@ struct snd_soc_dai_link  {
 	struct snd_pcm *pcm;
 };
 
-/* SoC card */
-struct snd_soc_card {
+/* SoC machine */
+struct snd_soc_machine {
 	char *name;
 
 	int (*probe)(struct platform_device *pdev);
@@ -343,7 +490,7 @@ struct snd_soc_card {
 	int (*resume_post)(struct platform_device *pdev);
 
 	/* callbacks */
-	int (*set_bias_level)(struct snd_soc_card *,
+	int (*set_bias_level)(struct snd_soc_machine *,
 			      enum snd_soc_bias_level level);
 
 	/* CPU <--> Codec DAI links  */
@@ -354,16 +501,13 @@ struct snd_soc_card {
 /* SoC Device - the audio subsystem */
 struct snd_soc_device {
 	struct device *dev;
-	struct snd_soc_card *card;
+	struct snd_soc_machine *machine;
 	struct snd_soc_platform *platform;
 	struct snd_soc_codec *codec;
 	struct snd_soc_codec_device *codec_dev;
 	struct delayed_work delayed_work;
 	struct work_struct deferred_resume_work;
 	void *codec_data;
-#ifdef CONFIG_DEBUG_FS
-	struct dentry	*debugfs_root;
-#endif
 };
 
 /* runtime channel data */
@@ -372,23 +516,15 @@ struct snd_soc_pcm_runtime {
 	struct snd_soc_device *socdev;
 };
 
-/* mixer control */
-struct soc_mixer_control {
-	int min, max;
-	unsigned int reg, rreg, shift, rshift, invert;
-};
-
 /* enumerated kcontrol */
 struct soc_enum {
 	unsigned short reg;
 	unsigned short reg2;
 	unsigned char shift_l;
 	unsigned char shift_r;
-	unsigned int max;
+	unsigned int mask;
 	const char **texts;
 	void *dapm;
 };
 
-#include <sound/soc-dai.h>
-
 #endif
diff --git a/sound/soc/Kconfig b/sound/soc/Kconfig
index f743530..feeefdd 100644
--- a/sound/soc/Kconfig
+++ b/sound/soc/Kconfig
@@ -28,6 +28,7 @@ source "sound/soc/au1x/Kconfig"
 source "sound/soc/pxa/Kconfig"
 source "sound/soc/s3c24xx/Kconfig"
 source "sound/soc/sh/Kconfig"
+source "sound/soc/imx/Kconfig"
 source "sound/soc/fsl/Kconfig"
 source "sound/soc/davinci/Kconfig"
 source "sound/soc/omap/Kconfig"
diff --git a/sound/soc/Makefile b/sound/soc/Makefile
index 933a66d..673387e 100644
--- a/sound/soc/Makefile
+++ b/sound/soc/Makefile
@@ -1,5 +1,6 @@
 snd-soc-core-objs := soc-core.o soc-dapm.o
 
 obj-$(CONFIG_SND_SOC)	+= snd-soc-core.o
-obj-$(CONFIG_SND_SOC)	+= codecs/ at32/ at91/ pxa/ s3c24xx/ sh/ fsl/ davinci/
+obj-$(CONFIG_SND_SOC)	+= codecs/ at32/ at91/ pxa/ s3c24xx/ sh/ fsl/ davinci/ \
+			   imx/
 obj-$(CONFIG_SND_SOC)	+= omap/ au1x/
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index b1a5eed..f98b90a 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -29,6 +29,10 @@ config SND_SOC_WM9712
 config SND_SOC_WM9713
 	tristate
 
+config SND_SOC_SGTL5000
+	tristate
+	depends on I2C
+
 # Cirrus Logic CS4270 Codec
 config SND_SOC_CS4270
 	tristate
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index a519ced..056c2ca 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -8,6 +8,7 @@ snd-soc-wm8753-objs := wm8753.o
 snd-soc-wm8990-objs := wm8990.o
 snd-soc-wm9712-objs := wm9712.o
 snd-soc-wm9713-objs := wm9713.o
+snd-soc-sgtl5000-objs := sgtl5000.o
 snd-soc-cs4270-objs := cs4270.o
 snd-soc-tlv320aic3x-objs := tlv320aic3x.o
 snd-soc-twl4030-objs := twl4030.o
@@ -22,6 +23,7 @@ obj-$(CONFIG_SND_SOC_WM8753)	+= snd-soc-wm8753.o
 obj-$(CONFIG_SND_SOC_WM8990)	+= snd-soc-wm8990.o
 obj-$(CONFIG_SND_SOC_WM9712)	+= snd-soc-wm9712.o
 obj-$(CONFIG_SND_SOC_WM9713)	+= snd-soc-wm9713.o
+obj-$(CONFIG_SND_SOC_SGTL5000)	+= snd-soc-sgtl5000.o
 obj-$(CONFIG_SND_SOC_CS4270)	+= snd-soc-cs4270.o
 obj-$(CONFIG_SND_SOC_TLV320AIC3X)	+= snd-soc-tlv320aic3x.o
 obj-$(CONFIG_SND_SOC_TWL4030)	+= snd-soc-twl4030.o
diff --git a/sound/soc/codecs/sgtl5000.c b/sound/soc/codecs/sgtl5000.c
new file mode 100644
index 0000000..2d6108d
--- /dev/null
+++ b/sound/soc/codecs/sgtl5000.c
@@ -0,0 +1,1076 @@
+/*
+ * sgtl5000.c  --  SGTL5000 ALSA SoC Audio driver
+ *
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+
+#include "sgtl5000.h"
+
+struct sgtl5000_priv {
+	int sysclk;
+	int master;
+	int fmt;
+	int rev;
+};
+
+static int sgtl5000_set_bias_level(struct snd_soc_codec *codec,
+				   enum snd_soc_bias_level level);
+
+#define SGTL5000_MAX_CACHED_REG SGTL5000_CHIP_SHORT_CTRL
+static u16 sgtl5000_regs[(SGTL5000_MAX_CACHED_REG >> 1) + 1];
+
+static unsigned int sgtl5000_read_reg_cache(struct snd_soc_codec *codec,
+					    unsigned int reg)
+{
+	u16 *cache = codec->reg_cache;
+	unsigned int offset = reg >> 1;
+	if (offset >= ARRAY_SIZE(sgtl5000_regs))
+		return -EINVAL;
+	return cache[offset];
+}
+
+static unsigned int sgtl5000_hw_read(struct snd_soc_codec *codec,
+				     unsigned int reg)
+{
+	struct i2c_client *client = codec->control_data;
+	int i2c_ret;
+	u16 value;
+	u8 buf0[2], buf1[2];
+	u16 addr = client->addr;
+	u16 flags = client->flags;
+	struct i2c_msg msg[2] = {
+		{addr, flags, 2, buf0},
+		{addr, flags | I2C_M_RD, 2, buf1},
+	};
+
+	buf0[0] = (reg & 0xff00) >> 8;
+	buf0[1] = reg & 0xff;
+	i2c_ret = i2c_transfer(client->adapter, msg, 2);
+	if (i2c_ret < 0) {
+		pr_err("%s: read reg error : reg=%x\n", __func__, reg);
+		return 0;
+	}
+
+	value = buf1[0] << 8 | buf1[1];
+
+	pr_debug("r r:%02x,v:%04x\n", reg, value);
+	return value;
+}
+
+static unsigned int sgtl5000_read(struct snd_soc_codec *codec, unsigned int reg)
+{
+	if ((reg == SGTL5000_CHIP_ID) ||
+	    (reg == SGTL5000_CHIP_ADCDAC_CTRL) ||
+	    (reg == SGTL5000_CHIP_ANA_STATUS) ||
+	    (reg > SGTL5000_MAX_CACHED_REG))
+		return sgtl5000_hw_read(codec, reg);
+	else
+		return sgtl5000_read_reg_cache(codec, reg);
+}
+
+static inline void sgtl5000_write_reg_cache(struct snd_soc_codec *codec,
+					    u16 reg, unsigned int value)
+{
+	u16 *cache = codec->reg_cache;
+	unsigned int offset = reg >> 1;
+	if (offset < ARRAY_SIZE(sgtl5000_regs))
+		cache[offset] = value;
+}
+
+static int sgtl5000_write(struct snd_soc_codec *codec, unsigned int reg,
+			  unsigned int value)
+{
+	struct i2c_client *client = codec->control_data;
+	u16 addr = client->addr;
+	u16 flags = client->flags;
+	u8 buf[4];
+	int i2c_ret;
+	struct i2c_msg msg = { addr, flags, 4, buf };
+
+	sgtl5000_write_reg_cache(codec, reg, value);
+	pr_debug("w r:%02x,v:%04x\n", reg, value);
+	buf[0] = (reg & 0xff00) >> 8;
+	buf[1] = reg & 0xff;
+	buf[2] = (value & 0xff00) >> 8;
+	buf[3] = value & 0xff;
+
+	i2c_ret = i2c_transfer(client->adapter, &msg, 1);
+	if (i2c_ret < 0) {
+		pr_err("%s: write reg error : R%02d = 0x%04x\n",
+		       __func__, reg, value);
+		return -EIO;
+	}
+
+	return i2c_ret;
+}
+
+static void sgtl5000_sync_reg_cache(struct snd_soc_codec *codec)
+{
+	int reg;
+	for (reg = 0; reg <= SGTL5000_MAX_CACHED_REG; reg += 2)
+		sgtl5000_write_reg_cache(codec, reg,
+					 sgtl5000_hw_read(codec, reg));
+}
+
+static int sgtl5000_restore_reg(struct snd_soc_codec *codec, unsigned int reg)
+{
+	unsigned int cached_val, hw_val;
+
+	cached_val = sgtl5000_read_reg_cache(codec, reg);
+	hw_val = sgtl5000_hw_read(codec, reg);
+
+	if (hw_val != cached_val)
+		return sgtl5000_write(codec, reg, cached_val);
+
+	return 0;
+}
+
+static int all_reg[] = {
+	SGTL5000_CHIP_ID,
+	SGTL5000_CHIP_DIG_POWER,
+	SGTL5000_CHIP_CLK_CTRL,
+	SGTL5000_CHIP_I2S_CTRL,
+	SGTL5000_CHIP_SSS_CTRL,
+	SGTL5000_CHIP_ADCDAC_CTRL,
+	SGTL5000_CHIP_DAC_VOL,
+	SGTL5000_CHIP_PAD_STRENGTH,
+	SGTL5000_CHIP_ANA_ADC_CTRL,
+	SGTL5000_CHIP_ANA_HP_CTRL,
+	SGTL5000_CHIP_ANA_CTRL,
+	SGTL5000_CHIP_LINREG_CTRL,
+	SGTL5000_CHIP_REF_CTRL,
+	SGTL5000_CHIP_MIC_CTRL,
+	SGTL5000_CHIP_LINE_OUT_CTRL,
+	SGTL5000_CHIP_LINE_OUT_VOL,
+	SGTL5000_CHIP_ANA_POWER,
+	SGTL5000_CHIP_PLL_CTRL,
+	SGTL5000_CHIP_CLK_TOP_CTRL,
+	SGTL5000_CHIP_ANA_STATUS,
+	SGTL5000_CHIP_SHORT_CTRL,
+};
+
+#ifdef DEBUG
+static void dump_reg(struct snd_soc_codec *codec)
+{
+	int i, reg;
+	printk(KERN_DEBUG "dump begin\n");
+	for (i = 0; i < 21; i++) {
+		reg = sgtl5000_read(codec, all_reg[i]);
+		printk(KERN_DEBUG "d r %04x, v %04x\n", all_reg[i], reg);
+	}
+	printk(KERN_DEBUG "dump end\n");
+}
+#else
+static void dump_reg(struct snd_soc_codec *codec)
+{
+}
+#endif
+
+static int dac_mux_put(struct snd_kcontrol *kcontrol,
+		       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dapm_widget *widget = snd_kcontrol_chip(kcontrol);
+	struct snd_soc_codec *codec = widget->codec;
+	unsigned int reg;
+
+	if (ucontrol->value.enumerated.item[0]) {
+		reg = sgtl5000_read(codec, SGTL5000_CHIP_CLK_TOP_CTRL);
+		reg |= SGTL5000_INT_OSC_EN;
+		sgtl5000_write(codec, SGTL5000_CHIP_CLK_TOP_CTRL, reg);
+
+		if (codec->bias_level != SND_SOC_BIAS_ON) {
+			sgtl5000_set_bias_level(codec, SND_SOC_BIAS_PREPARE);
+			snd_soc_dapm_put_enum_double(kcontrol, ucontrol);
+			sgtl5000_set_bias_level(codec, SND_SOC_BIAS_ON);
+		} else
+			snd_soc_dapm_put_enum_double(kcontrol, ucontrol);
+
+		reg = sgtl5000_read(codec, SGTL5000_CHIP_ANA_CTRL);
+		reg &= ~(SGTL5000_LINE_OUT_MUTE | SGTL5000_HP_MUTE);
+		sgtl5000_write(codec, SGTL5000_CHIP_ANA_CTRL, reg);
+	} else {
+		reg = sgtl5000_read(codec, SGTL5000_CHIP_CLK_TOP_CTRL);
+		reg &= ~SGTL5000_INT_OSC_EN;
+		sgtl5000_write(codec, SGTL5000_CHIP_CLK_TOP_CTRL, reg);
+
+		snd_soc_dapm_put_enum_double(kcontrol, ucontrol);
+		sgtl5000_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+	}
+	return 0;
+}
+
+static const char *adc_mux_text[] = {
+	"MIC_IN", "LINE_IN"
+};
+
+static const char *dac_mux_text[] = {
+	"DAC", "LINE_IN"
+};
+
+static const struct soc_enum adc_enum =
+SOC_ENUM_SINGLE(SGTL5000_CHIP_ANA_CTRL, 2, 2, adc_mux_text);
+
+static const struct soc_enum dac_enum =
+SOC_ENUM_SINGLE(SGTL5000_CHIP_ANA_CTRL, 6, 2, dac_mux_text);
+
+static const struct snd_kcontrol_new adc_mux =
+SOC_DAPM_ENUM("ADC Mux", adc_enum);
+
+static const struct snd_kcontrol_new dac_mux = {
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name = "DAC Mux",
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE
+	    | SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+	.info = snd_soc_info_enum_double,
+	.get = snd_soc_dapm_get_enum_double,
+	.put = dac_mux_put,
+	.private_value = (unsigned long)&dac_enum,
+};
+
+static const struct snd_soc_dapm_widget sgtl5000_dapm_widgets[] = {
+	SND_SOC_DAPM_INPUT("LINE_IN"),
+	SND_SOC_DAPM_INPUT("MIC_IN"),
+
+	SND_SOC_DAPM_OUTPUT("HP_OUT"),
+	SND_SOC_DAPM_OUTPUT("LINE_OUT"),
+
+	SND_SOC_DAPM_PGA("HP", SGTL5000_CHIP_ANA_POWER, 4, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("LO", SGTL5000_CHIP_ANA_POWER, 0, 0, NULL, 0),
+
+	SND_SOC_DAPM_MUX("ADC Mux", SND_SOC_NOPM, 0, 0, &adc_mux),
+	SND_SOC_DAPM_MUX("DAC Mux", SND_SOC_NOPM, 0, 0, &dac_mux),
+
+	SND_SOC_DAPM_ADC("ADC", "Capture", SGTL5000_CHIP_DIG_POWER, 6, 0),
+	SND_SOC_DAPM_DAC("DAC", "Playback", SGTL5000_CHIP_DIG_POWER, 5, 0),
+};
+
+static const struct snd_soc_dapm_route audio_map[] = {
+	{"ADC Mux", "LINE_IN", "LINE_IN"},
+	{"ADC Mux", "MIC_IN", "MIC_IN"},
+	{"ADC", NULL, "ADC Mux"},
+	{"DAC Mux", "DAC", "DAC"},
+	{"DAC Mux", "LINE_IN", "LINE_IN"},
+	{"LO", NULL, "DAC"},
+	{"HP", NULL, "DAC Mux"},
+	{"LINE_OUT", NULL, "LO"},
+	{"HP_OUT", NULL, "HP"},
+};
+
+static int sgtl5000_add_widgets(struct snd_soc_codec *codec)
+{
+	snd_soc_dapm_new_controls(codec, sgtl5000_dapm_widgets,
+				  ARRAY_SIZE(sgtl5000_dapm_widgets));
+
+	snd_soc_dapm_add_routes(codec, audio_map, ARRAY_SIZE(audio_map));
+
+	snd_soc_dapm_new_widgets(codec);
+	return 0;
+}
+
+static int dac_info_volsw(struct snd_kcontrol *kcontrol,
+			  struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 0xfc - 0x3c;
+	return 0;
+}
+
+static int dac_get_volsw(struct snd_kcontrol *kcontrol,
+			 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int reg, l, r;
+
+	reg = sgtl5000_read(codec, SGTL5000_CHIP_DAC_VOL);
+	l = (reg & SGTL5000_DAC_VOL_LEFT_MASK) << SGTL5000_DAC_VOL_LEFT_SHIFT;
+	r = (reg & SGTL5000_DAC_VOL_RIGHT_MASK) << SGTL5000_DAC_VOL_RIGHT_SHIFT;
+	l = l < 0x3c ? 0x3c : l;
+	l = l > 0xfc ? 0xfc : l;
+	r = r < 0x3c ? 0x3c : r;
+	r = r > 0xfc ? 0xfc : r;
+	l = 0xfc - l;
+	r = 0xfc - r;
+
+	ucontrol->value.integer.value[0] = l;
+	ucontrol->value.integer.value[1] = l;
+
+	return 0;
+}
+
+static int dac_put_volsw(struct snd_kcontrol *kcontrol,
+			 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	int reg, l, r;
+
+	l = ucontrol->value.integer.value[0];
+	r = ucontrol->value.integer.value[1];
+
+	l = l < 0 ? 0 : l;
+	l = l > 0xfc - 0x3c ? 0xfc - 0x3c : l;
+	r = r < 0 ? 0 : r;
+	r = r > 0xfc - 0x3c ? 0xfc - 0x3c : r;
+	l = 0xfc - l;
+	r = 0xfc - r;
+
+	reg = l << SGTL5000_DAC_VOL_LEFT_SHIFT |
+	    r << SGTL5000_DAC_VOL_RIGHT_SHIFT;
+
+	sgtl5000_write(codec, SGTL5000_CHIP_DAC_VOL, reg);
+
+	return 0;
+}
+
+static const char *mic_gain_text[] = {
+	"0dB", "20dB", "30dB", "40dB"
+};
+
+static const char *adc_m6db_text[] = {
+	"No Change", "Reduced by 6dB"
+};
+
+static const struct soc_enum mic_gain =
+SOC_ENUM_SINGLE(SGTL5000_CHIP_MIC_CTRL, 0, 4, mic_gain_text);
+
+static const struct soc_enum adc_m6db =
+SOC_ENUM_SINGLE(SGTL5000_CHIP_ANA_ADC_CTRL, 8, 2, adc_m6db_text);
+
+static const struct snd_kcontrol_new sgtl5000_snd_controls[] = {
+	SOC_ENUM("MIC GAIN", mic_gain),
+	SOC_DOUBLE("Capture Volume", SGTL5000_CHIP_ANA_ADC_CTRL, 0, 4, 0xf, 0),
+	SOC_ENUM("Capture Vol Reduction", adc_m6db),
+	{.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+	 .name = "Playback Volume",
+	 .access = SNDRV_CTL_ELEM_ACCESS_READWRITE |
+	 SNDRV_CTL_ELEM_ACCESS_VOLATILE,
+	 .info = dac_info_volsw,
+	 .get = dac_get_volsw,
+	 .put = dac_put_volsw,
+	 },
+	SOC_DOUBLE("Headphone Volume", SGTL5000_CHIP_ANA_HP_CTRL, 0, 8, 0x7f,
+		   1),
+};
+
+static int sgtl5000_add_controls(struct snd_soc_codec *codec)
+{
+	int err, i;
+
+	for (i = 0; i < ARRAY_SIZE(sgtl5000_snd_controls); i++) {
+		err = snd_ctl_add(codec->card,
+				  snd_soc_cnew(&sgtl5000_snd_controls[i],
+					       codec, NULL));
+		if (err < 0)
+			return err;
+	}
+
+	return 0;
+}
+
+static int sgtl5000_digital_mute(struct snd_soc_dai *codec_dai, int mute)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	u16 reg1, reg2;
+
+	reg1 = sgtl5000_read(codec, SGTL5000_CHIP_ANA_CTRL);
+	reg2 = sgtl5000_read(codec, SGTL5000_CHIP_ADCDAC_CTRL);
+
+	if (mute) {
+		reg1 |= SGTL5000_LINE_OUT_MUTE;
+		reg1 |= SGTL5000_HP_MUTE;
+		reg1 |= SGTL5000_ADC_MUTE;
+		reg2 |= SGTL5000_DAC_MUTE_LEFT;
+		reg2 |= SGTL5000_DAC_MUTE_RIGHT;
+	} else {
+		reg1 &= ~SGTL5000_LINE_OUT_MUTE;
+		reg1 &= ~SGTL5000_HP_MUTE;
+		reg1 &= ~SGTL5000_ADC_MUTE;
+		reg2 &= ~SGTL5000_DAC_MUTE_LEFT;
+		reg2 &= ~SGTL5000_DAC_MUTE_RIGHT;
+	}
+
+	sgtl5000_write(codec, SGTL5000_CHIP_ANA_CTRL, reg1);
+	sgtl5000_write(codec, SGTL5000_CHIP_ADCDAC_CTRL, reg2);
+	if (!mute)
+		dump_reg(codec);
+	return 0;
+}
+
+static int sgtl5000_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct sgtl5000_priv *sgtl5000 = codec->private_data;
+	u16 i2sctl = 0;
+	pr_debug("%s:fmt=%08x\n", __func__, fmt);
+	sgtl5000->master = 0;
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		break;
+	case SND_SOC_DAIFMT_CBM_CFM:
+		i2sctl |= SGTL5000_I2S_MASTER;
+		sgtl5000->master = 1;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFS:
+	case SND_SOC_DAIFMT_CBS_CFM:
+		return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_DSP_A:
+		i2sctl |= SGTL5000_I2S_MODE_PCM;
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		i2sctl |= SGTL5000_I2S_MODE_PCM;
+		i2sctl |= SGTL5000_I2S_LRALIGN;
+		break;
+	case SND_SOC_DAIFMT_I2S:
+		i2sctl |= SGTL5000_I2S_MODE_I2S_LJ;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		i2sctl |= SGTL5000_I2S_MODE_RJ;
+		i2sctl |= SGTL5000_I2S_LRPOL;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		i2sctl |= SGTL5000_I2S_MODE_I2S_LJ;
+		i2sctl |= SGTL5000_I2S_LRALIGN;
+		break;
+	default:
+		return -EINVAL;
+	}
+	sgtl5000->fmt = fmt & SND_SOC_DAIFMT_FORMAT_MASK;
+
+	/* Clock inversion */
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+	case SND_SOC_DAIFMT_NB_IF:
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+	case SND_SOC_DAIFMT_IB_NF:
+		i2sctl |= SGTL5000_I2S_SCLK_INV;
+		break;
+	default:
+		return -EINVAL;
+	}
+	sgtl5000_write(codec, SGTL5000_CHIP_I2S_CTRL, i2sctl);
+
+	return 0;
+}
+
+static int sgtl5000_set_dai_sysclk(struct snd_soc_dai *codec_dai,
+				   int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct sgtl5000_priv *sgtl5000 = codec->private_data;
+
+	sgtl5000->sysclk = freq;
+
+	return 0;
+}
+
+static void sgtl5000_pcm_shutdown(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	int reg;
+
+	reg = sgtl5000_read(codec, SGTL5000_CHIP_DIG_POWER);
+	reg &= ~(SGTL5000_I2S_IN_POWERUP | SGTL5000_I2S_OUT_POWERUP);
+	sgtl5000_write(codec, SGTL5000_CHIP_DIG_POWER, reg);
+
+	reg = sgtl5000_read(codec, SGTL5000_CHIP_I2S_CTRL);
+	reg &= ~SGTL5000_I2S_MASTER;
+	sgtl5000_write(codec, SGTL5000_CHIP_I2S_CTRL, reg);
+}
+
+/*
+ * Set PCM DAI bit size and sample rate.
+ * input: params_rate, params_fmt
+ */
+static int sgtl5000_pcm_hw_params(struct snd_pcm_substream *substream,
+				  struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	struct sgtl5000_priv *sgtl5000 = codec->private_data;
+	int fs = params_rate(params);
+	int channels = params_channels(params);
+	int clk_ctl = 0;
+	int pll_ctl = 0;
+	int i2s_ctl;
+	int div2 = 0;
+	int reg;
+
+	if (!sgtl5000->sysclk) {
+		pr_err("%s: set sysclk first!\n", __func__);
+		return -EFAULT;
+	}
+
+	/* rev 1 does not support mono playback */
+	if (sgtl5000->rev != 0x00) {
+		reg = sgtl5000_read(codec, SGTL5000_CHIP_ANA_TEST2);
+		if (channels == 1)
+			reg |= SGTL5000_MONO_DAC;
+		else
+			reg &= ~SGTL5000_MONO_DAC;
+		sgtl5000_write(codec, SGTL5000_CHIP_ANA_TEST2, reg);
+	}
+
+	switch (fs) {
+	case 32000:
+		clk_ctl |= SGTL5000_SYS_FS_32k << SGTL5000_SYS_FS_SHIFT;
+		break;
+	case 44100:
+		clk_ctl |= SGTL5000_SYS_FS_44_1k << SGTL5000_SYS_FS_SHIFT;
+		break;
+	case 48000:
+		clk_ctl |= SGTL5000_SYS_FS_48k << SGTL5000_SYS_FS_SHIFT;
+		break;
+	case 96000:
+		clk_ctl |= SGTL5000_SYS_FS_96k << SGTL5000_SYS_FS_SHIFT;
+		break;
+	default:
+		pr_err("%s: sample rate %d not supported\n", __func__, fs);
+		return -EFAULT;
+	}
+
+#if 0	/* SGTL5000 rev1 has a IC bug to prevent switching to MCLK from PLL. */
+	if (fs * 256 == sgtl5000->sysclk)
+		clk_ctl |= SGTL5000_MCLK_FREQ_256FS << SGTL5000_MCLK_FREQ_SHIFT;
+	else if (fs * 384 == sgtl5000->sysclk && fs != 96000)
+		clk_ctl |= SGTL5000_MCLK_FREQ_384FS << SGTL5000_MCLK_FREQ_SHIFT;
+	else if (fs * 512 == sgtl5000->sysclk && fs != 96000)
+		clk_ctl |= SGTL5000_MCLK_FREQ_512FS << SGTL5000_MCLK_FREQ_SHIFT;
+	else
+#endif
+	{
+		if (!sgtl5000->master) {
+			pr_err("%s: PLL not supported in slave mode\n",
+			       __func__);
+			return -EINVAL;
+		}
+		clk_ctl |= SGTL5000_MCLK_FREQ_PLL << SGTL5000_MCLK_FREQ_SHIFT;
+	}
+
+	if ((clk_ctl & SGTL5000_MCLK_FREQ_MASK) == SGTL5000_MCLK_FREQ_PLL) {
+		u64 out, t;
+		unsigned int in, int_div, frac_div;
+		if (sgtl5000->sysclk > 17000000) {
+			div2 = 1;
+			in = sgtl5000->sysclk / 2;
+		} else {
+			div2 = 0;
+			in = sgtl5000->sysclk;
+		}
+		if (fs == 44100)
+			out = 180633600;
+		else
+			out = 196608000;
+		t = do_div(out, in);
+		int_div = out;
+		t *= 2048;
+		do_div(t, in);
+		frac_div = t;
+		pll_ctl = int_div << SGTL5000_PLL_INT_DIV_SHIFT |
+		    frac_div << SGTL5000_PLL_FRAC_DIV_SHIFT;
+	}
+
+	i2s_ctl = sgtl5000_read(codec, SGTL5000_CHIP_I2S_CTRL);
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		if (sgtl5000->fmt == SND_SOC_DAIFMT_RIGHT_J)
+			return -EINVAL;
+		i2s_ctl |= SGTL5000_I2S_DLEN_16 << SGTL5000_I2S_DLEN_SHIFT;
+		i2s_ctl |= SGTL5000_I2S_SCLKFREQ_32FS <<
+		    SGTL5000_I2S_SCLKFREQ_SHIFT;
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		i2s_ctl |= SGTL5000_I2S_DLEN_20 << SGTL5000_I2S_DLEN_SHIFT;
+		i2s_ctl |= SGTL5000_I2S_SCLKFREQ_64FS <<
+		    SGTL5000_I2S_SCLKFREQ_SHIFT;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		i2s_ctl |= SGTL5000_I2S_DLEN_24 << SGTL5000_I2S_DLEN_SHIFT;
+		i2s_ctl |= SGTL5000_I2S_SCLKFREQ_64FS <<
+		    SGTL5000_I2S_SCLKFREQ_SHIFT;
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		if (sgtl5000->fmt == SND_SOC_DAIFMT_RIGHT_J)
+			return -EINVAL;
+		i2s_ctl |= SGTL5000_I2S_DLEN_32 << SGTL5000_I2S_DLEN_SHIFT;
+		i2s_ctl |= SGTL5000_I2S_SCLKFREQ_64FS <<
+		    SGTL5000_I2S_SCLKFREQ_SHIFT;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	pr_debug("fs=%d,clk_ctl=%d,pll_ctl=%d,i2s_ctl=%d,div2=%d\n",
+		 fs, clk_ctl, pll_ctl, i2s_ctl, div2);
+
+	if ((clk_ctl & SGTL5000_MCLK_FREQ_MASK) == SGTL5000_MCLK_FREQ_PLL) {
+		sgtl5000_write(codec, SGTL5000_CHIP_PLL_CTRL, pll_ctl);
+		reg = sgtl5000_read(codec, SGTL5000_CHIP_CLK_TOP_CTRL);
+		if (div2)
+			reg |= SGTL5000_INPUT_FREQ_DIV2;
+		else
+			reg &= ~SGTL5000_INPUT_FREQ_DIV2;
+		sgtl5000_write(codec, SGTL5000_CHIP_CLK_TOP_CTRL, reg);
+		reg = sgtl5000_read(codec, SGTL5000_CHIP_ANA_POWER);
+		reg |= SGTL5000_PLL_POWERUP | SGTL5000_VCOAMP_POWERUP;
+		sgtl5000_write(codec, SGTL5000_CHIP_ANA_POWER, reg);
+	}
+	sgtl5000_write(codec, SGTL5000_CHIP_CLK_CTRL, clk_ctl);
+	sgtl5000_write(codec, SGTL5000_CHIP_I2S_CTRL, i2s_ctl);
+	reg = sgtl5000_read(codec, SGTL5000_CHIP_DIG_POWER);
+	reg |= SGTL5000_I2S_IN_POWERUP | SGTL5000_I2S_OUT_POWERUP;
+	sgtl5000_write(codec, SGTL5000_CHIP_DIG_POWER, reg);
+	return 0;
+}
+
+static int sgtl5000_set_bias_level(struct snd_soc_codec *codec,
+				   enum snd_soc_bias_level level)
+{
+	u16 reg, ana_pwr;
+	pr_debug("dapm level %d\n", level);
+	switch (level) {
+	case SND_SOC_BIAS_ON:		/* full On */
+	case SND_SOC_BIAS_PREPARE:	/* partial On */
+		if ((codec->bias_level == SND_SOC_BIAS_ON) ||
+		    (codec->bias_level == SND_SOC_BIAS_PREPARE))
+			break;
+
+		/* must power up hp/line out before vag & dac to
+		   avoid pops. */
+		reg = sgtl5000_read(codec, SGTL5000_CHIP_ANA_POWER);
+		if ((reg & SGTL5000_HP_POWERUP) == 0) {
+			reg |= SGTL5000_VAG_POWERUP;
+			reg |= SGTL5000_REFTOP_POWERUP;
+			reg |= SGTL5000_DAC_POWERUP;
+			reg |= SGTL5000_ADC_POWERUP;
+			sgtl5000_write(codec, SGTL5000_CHIP_ANA_POWER, reg);
+			msleep(400);
+		}
+
+		reg = sgtl5000_read(codec, SGTL5000_CHIP_MIC_CTRL);
+		reg &= ~SGTL5000_BIAS_R_MASK;
+		reg |= SGTL5000_BIAS_R_4k << SGTL5000_BIAS_R_SHIFT;
+		sgtl5000_write(codec, SGTL5000_CHIP_MIC_CTRL, reg);
+
+		reg = sgtl5000_read(codec, SGTL5000_CHIP_ANA_CTRL);
+		reg |= SGTL5000_HP_ZCD_EN;
+		reg |= SGTL5000_ADC_ZCD_EN;
+		sgtl5000_write(codec, SGTL5000_CHIP_ANA_CTRL, reg);
+		break;
+
+	case SND_SOC_BIAS_STANDBY:	/* Off, with power */
+		reg = sgtl5000_read(codec, SGTL5000_CHIP_MIC_CTRL);
+		reg &= ~SGTL5000_BIAS_R_MASK;
+		reg |= SGTL5000_BIAS_R_off;
+		sgtl5000_write(codec, SGTL5000_CHIP_MIC_CTRL, reg);
+
+		reg = sgtl5000_read(codec, SGTL5000_CHIP_ANA_CTRL);
+		reg &= ~SGTL5000_HP_ZCD_EN;
+		reg &= ~SGTL5000_ADC_ZCD_EN;
+		sgtl5000_write(codec, SGTL5000_CHIP_ANA_CTRL, reg);
+		break;
+
+	case SND_SOC_BIAS_OFF:	/* Off, without power */
+		/* must power down hp/line out after vag & dac to
+		   avoid pops. */
+		reg = sgtl5000_read(codec, SGTL5000_CHIP_ANA_POWER);
+		ana_pwr = reg;
+		reg &= ~SGTL5000_VAG_POWERUP;
+		reg &= ~SGTL5000_REFTOP_POWERUP;
+		sgtl5000_write(codec, SGTL5000_CHIP_ANA_POWER, reg);
+		msleep(600);
+
+		reg &= ~SGTL5000_HP_POWERUP;
+		reg &= ~SGTL5000_LINE_OUT_POWERUP;
+		reg &= ~SGTL5000_DAC_POWERUP;
+		reg &= ~SGTL5000_ADC_POWERUP;
+		sgtl5000_write(codec, SGTL5000_CHIP_ANA_POWER, reg);
+
+		/* save ANA POWER register value for resume */
+		sgtl5000_write_reg_cache(codec, SGTL5000_CHIP_ANA_POWER,
+					 ana_pwr);
+		break;
+	}
+	codec->bias_level = level;
+	return 0;
+}
+
+#define SGTL5000_RATES (SNDRV_PCM_RATE_32000 |\
+		      SNDRV_PCM_RATE_44100 |\
+		      SNDRV_PCM_RATE_48000 |\
+		      SNDRV_PCM_RATE_96000)
+
+#define SGTL5000_FORMATS (SNDRV_PCM_FMTBIT_S16_LE |\
+			SNDRV_PCM_FMTBIT_S20_3LE |\
+			SNDRV_PCM_FMTBIT_S24_LE)
+
+struct snd_soc_dai sgtl5000_dai = {
+	.name = "SGTL5000",
+	.playback = {
+		     .stream_name = "Playback",
+		     .channels_min = 1,
+		     .channels_max = 2,
+		     .rates = SGTL5000_RATES,
+		     .formats = SGTL5000_FORMATS,
+		     },
+	.capture = {
+		    .stream_name = "Capture",
+		    .channels_min = 1,
+		    .channels_max = 1,
+		    .rates = SGTL5000_RATES,
+		    .formats = SGTL5000_FORMATS,
+		    },
+
+	.ops = {
+		.shutdown = sgtl5000_pcm_shutdown,
+		.hw_params = sgtl5000_pcm_hw_params,
+		},
+
+	.dai_ops = {
+		    .digital_mute = sgtl5000_digital_mute,
+		    .set_fmt = sgtl5000_set_dai_fmt,
+		    .set_sysclk = sgtl5000_set_dai_sysclk}
+};
+EXPORT_SYMBOL_GPL(sgtl5000_dai);
+
+static int sgtl5000_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	sgtl5000_set_bias_level(codec, SND_SOC_BIAS_OFF);
+
+	return 0;
+}
+
+static int sgtl5000_resume(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+	unsigned int i;
+
+	/* Restore refs first in same order as in sgtl5000_init */
+	sgtl5000_restore_reg(codec, SGTL5000_CHIP_LINREG_CTRL);
+	sgtl5000_restore_reg(codec, SGTL5000_CHIP_ANA_POWER);
+	msleep(10);
+	sgtl5000_restore_reg(codec, SGTL5000_CHIP_REF_CTRL);
+	sgtl5000_restore_reg(codec, SGTL5000_CHIP_LINE_OUT_CTRL);
+
+	/* Restore everythine else */
+	for (i = 1; i < sizeof(all_reg) / sizeof(int); i++)
+		sgtl5000_restore_reg(codec, all_reg[i]);
+
+	sgtl5000_write(codec, SGTL5000_DAP_CTRL, 0);
+
+	/* Bring the codec back up to standby first to minimise pop/clicks */
+	sgtl5000_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+	sgtl5000_set_bias_level(codec, codec->suspend_bias_level);
+
+	return 0;
+}
+
+/*
+ * initialise the SGTL5000 driver
+ * register the mixer and dsp interfaces with the kernel
+ */
+static int sgtl5000_init(struct snd_soc_device *socdev)
+{
+	struct sgtl5000_platform_data *plat = socdev->codec_data;
+	struct snd_soc_codec *codec = socdev->codec;
+	struct i2c_client *client = codec->control_data;
+	struct sgtl5000_priv *sgtl5000 = codec->private_data;
+	u16 reg, ana_pwr, lreg_ctrl, ref_ctrl, lo_ctrl, short_ctrl, sss;
+	int vag;
+	unsigned int val;
+	int ret = 0;
+
+	val = sgtl5000_read(codec, SGTL5000_CHIP_ID);
+	if (((val & SGTL5000_PARTID_MASK) >> SGTL5000_PARTID_SHIFT) !=
+	    SGTL5000_PARTID_PART_ID) {
+		pr_err("Device with ID register %x is not a SGTL5000\n", val);
+		return -ENODEV;
+	}
+
+	sgtl5000->rev = (val & SGTL5000_REVID_MASK) >> SGTL5000_REVID_SHIFT;
+	dev_info(&client->dev, "SGTL5000 revision %d\n", sgtl5000->rev);
+
+	/* For Rev2 or higher, CODEC will copy left channel data to right.
+	   For Rev1, set playback channels_min to 2. */
+	if (sgtl5000->rev == 0x00)	/* if chip is rev 1 */
+		sgtl5000_dai.playback.channels_min = 2;
+
+	codec->name = "SGTL5000";
+	codec->owner = THIS_MODULE;
+	codec->read = sgtl5000_read_reg_cache;
+	codec->write = sgtl5000_write;
+	codec->bias_level = SND_SOC_BIAS_OFF;
+	codec->set_bias_level = sgtl5000_set_bias_level;
+	codec->dai = &sgtl5000_dai;
+	codec->num_dai = 1;
+	codec->reg_cache_size = sizeof(sgtl5000_regs);
+	codec->reg_cache_step = 2;
+	codec->reg_cache = (void *)&sgtl5000_regs;
+	if (codec->reg_cache == NULL) {
+		dev_err(&client->dev, "Failed to allocate register cache\n");
+		return -ENOMEM;
+	}
+
+	/* register pcms */
+	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
+	if (ret < 0) {
+		dev_err(&client->dev, "failed to create pcms\n");
+		return ret;
+	}
+
+	sgtl5000_sync_reg_cache(codec);
+
+	/* reset value */
+	ana_pwr = SGTL5000_DAC_STERO |
+	    SGTL5000_LINREG_SIMPLE_POWERUP |
+	    SGTL5000_STARTUP_POWERUP |
+	    SGTL5000_ADC_STERO | SGTL5000_REFTOP_POWERUP;
+	lreg_ctrl = 0;
+	ref_ctrl = 0;
+	lo_ctrl = 0;
+	short_ctrl = 0;
+	sss = SGTL5000_DAC_SEL_I2S_IN << SGTL5000_DAC_SEL_SHIFT;
+
+	/* workaround for rev 0x11: use vddd linear regulator */
+	if (!plat->vddd || (sgtl5000->rev >= 0x11)) {
+		/* set VDDD to 1.2v */
+		lreg_ctrl |= 0x8 << SGTL5000_LINREG_VDDD_SHIFT;
+		/* power internal linear regulator */
+		ana_pwr |= SGTL5000_LINEREG_D_POWERUP;
+	} else {
+		/* turn of startup power */
+		ana_pwr &= ~SGTL5000_STARTUP_POWERUP;
+		ana_pwr &= ~SGTL5000_LINREG_SIMPLE_POWERUP;
+	}
+	if (plat->vddio < 3100 && plat->vdda < 3100) {
+		/* Enable VDDC charge pump */
+		ana_pwr |= SGTL5000_VDDC_CHRGPMP_POWERUP;
+	}
+	if (plat->vddio >= 3100 && plat->vdda >= 3100) {
+		/* VDDC use VDDIO rail */
+		lreg_ctrl |= SGTL5000_VDDC_ASSN_OVRD;
+		if (plat->vddio >= 3100)
+			lreg_ctrl |= SGTL5000_VDDC_MAN_ASSN_VDDIO <<
+			    SGTL5000_VDDC_MAN_ASSN_SHIFT;
+	}
+	/* If PLL is powered up (such as on power cycle) leave it on. */
+	reg = sgtl5000_read(codec, SGTL5000_CHIP_ANA_POWER);
+	ana_pwr |= reg & (SGTL5000_PLL_POWERUP | SGTL5000_VCOAMP_POWERUP);
+
+	/* set ADC/DAC ref voltage to vdda/2 */
+	vag = plat->vdda / 2;
+	if (vag <= SGTL5000_ANA_GND_BASE)
+		vag = 0;
+	else if (vag >= SGTL5000_ANA_GND_BASE + SGTL5000_ANA_GND_STP *
+		 (SGTL5000_ANA_GND_MASK >> SGTL5000_ANA_GND_SHIFT))
+		vag = SGTL5000_ANA_GND_MASK >> SGTL5000_ANA_GND_SHIFT;
+	else
+		vag = (vag - SGTL5000_ANA_GND_BASE) / SGTL5000_ANA_GND_STP;
+	ref_ctrl |= vag << SGTL5000_ANA_GND_SHIFT;
+
+	/* set line out ref voltage to vddio/2 */
+	vag = plat->vddio / 2;
+	if (vag <= SGTL5000_LINE_OUT_GND_BASE)
+		vag = 0;
+	else if (vag >= SGTL5000_LINE_OUT_GND_BASE + SGTL5000_LINE_OUT_GND_STP *
+		 SGTL5000_LINE_OUT_GND_MAX)
+		vag = SGTL5000_LINE_OUT_GND_MAX;
+	else
+		vag = (vag - SGTL5000_LINE_OUT_GND_BASE) /
+		    SGTL5000_LINE_OUT_GND_STP;
+	lo_ctrl |= vag << SGTL5000_LINE_OUT_GND_SHIFT;
+
+	/* enable small pop */
+	ref_ctrl |= SGTL5000_SMALL_POP;
+
+	/* set short detect */
+	/* keep default */
+
+	/* set routing */
+	/* keep default, bypass DAP */
+
+	sgtl5000_write(codec, SGTL5000_CHIP_LINREG_CTRL, lreg_ctrl);
+	sgtl5000_write(codec, SGTL5000_CHIP_ANA_POWER, ana_pwr);
+	msleep(10);
+
+	/* For rev 0x11, if vddd linear reg has been enabled, we have
+	   to disable simple reg to get proper VDDD voltage.  */
+	if ((ana_pwr & SGTL5000_LINEREG_D_POWERUP) && (sgtl5000->rev >= 0x11)) {
+		ana_pwr &= ~SGTL5000_LINREG_SIMPLE_POWERUP;
+		sgtl5000_write(codec, SGTL5000_CHIP_ANA_POWER, ana_pwr);
+		msleep(10);
+	}
+
+	sgtl5000_write(codec, SGTL5000_CHIP_REF_CTRL, ref_ctrl);
+	sgtl5000_write(codec, SGTL5000_CHIP_LINE_OUT_CTRL, lo_ctrl);
+	sgtl5000_write(codec, SGTL5000_CHIP_SHORT_CTRL, short_ctrl);
+	sgtl5000_write(codec, SGTL5000_CHIP_SSS_CTRL, sss);
+	sgtl5000_write(codec, SGTL5000_CHIP_DIG_POWER, 0);
+
+	reg = SGTL5000_DAC_VOL_RAMP_EN |
+	    SGTL5000_DAC_MUTE_RIGHT | SGTL5000_DAC_MUTE_LEFT;
+	sgtl5000_write(codec, SGTL5000_CHIP_ADCDAC_CTRL, reg);
+
+	sgtl5000_write(codec, SGTL5000_CHIP_PAD_STRENGTH, 0x015f);
+
+	reg = sgtl5000_read(codec, SGTL5000_CHIP_ANA_ADC_CTRL);
+	reg &= ~SGTL5000_ADC_VOL_M6DB;
+	reg &= ~(SGTL5000_ADC_VOL_LEFT_MASK | SGTL5000_ADC_VOL_RIGHT_MASK);
+	reg |= (0xf << SGTL5000_ADC_VOL_LEFT_SHIFT)
+	    | (0xf << SGTL5000_ADC_VOL_RIGHT_SHIFT);
+	sgtl5000_write(codec, SGTL5000_CHIP_ANA_ADC_CTRL, reg);
+
+	reg = SGTL5000_LINE_OUT_MUTE | SGTL5000_HP_MUTE | SGTL5000_ADC_MUTE;
+	sgtl5000_write(codec, SGTL5000_CHIP_ANA_CTRL, reg);
+
+	sgtl5000_write(codec, SGTL5000_CHIP_MIC_CTRL, 0);
+	sgtl5000_write(codec, SGTL5000_CHIP_CLK_TOP_CTRL, 0);
+	/* disable DAP */
+	sgtl5000_write(codec, SGTL5000_DAP_CTRL, 0);
+	/* TODO: initialize DAP */
+
+	sgtl5000_add_controls(codec);
+	sgtl5000_add_widgets(codec);
+
+	sgtl5000_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+
+	ret = snd_soc_register_card(socdev);
+	if (ret < 0) {
+		printk(KERN_ERR "sgtl5000: failed to register card\n");
+		snd_soc_free_pcms(socdev);
+		snd_soc_dapm_free(socdev);
+		return ret;
+	}
+
+	return 0;
+}
+
+static struct snd_soc_device *sgtl5000_socdev;
+
+static int sgtl5000_i2c_probe(struct i2c_client *i2c,
+			      const struct i2c_device_id *id)
+{
+	struct snd_soc_device *socdev = sgtl5000_socdev;
+	struct snd_soc_codec *codec = socdev->codec;
+	int ret;
+
+	i2c_set_clientdata(i2c, codec);
+	codec->control_data = i2c;
+
+	ret = sgtl5000_init(socdev);
+	if (ret < 0)
+		dev_err(&i2c->dev, "Device initialisation failed\n");
+
+	return ret;
+}
+
+static const struct i2c_device_id sgtl5000_id[] = {
+	{"sgtl5000-i2c", 0},
+	{},
+};
+
+MODULE_DEVICE_TABLE(i2c, sgtl5000_id);
+
+static struct i2c_driver sgtl5000_i2c_driver = {
+	.driver = {
+		   .name = "sgtl5000-i2c",
+		   .owner = THIS_MODULE,
+		   },
+	.probe = sgtl5000_i2c_probe,
+	.id_table = sgtl5000_id,
+};
+
+static int sgtl5000_probe(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+	struct sgtl5000_priv *sgtl5000;
+	int ret = 0;
+
+	codec = kzalloc(sizeof(struct snd_soc_codec), GFP_KERNEL);
+	if (codec == NULL)
+		return -ENOMEM;
+
+	sgtl5000 = kzalloc(sizeof(struct sgtl5000_priv), GFP_KERNEL);
+	if (sgtl5000 == NULL) {
+		kfree(codec);
+		return -ENOMEM;
+	}
+
+	codec->private_data = sgtl5000;
+	socdev->codec = codec;
+	mutex_init(&codec->mutex);
+	INIT_LIST_HEAD(&codec->dapm_widgets);
+	INIT_LIST_HEAD(&codec->dapm_paths);
+	sgtl5000_socdev = socdev;
+
+	ret = i2c_add_driver(&sgtl5000_i2c_driver);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "can't add i2c driver\n");
+		kfree(codec->private_data);
+		kfree(codec);
+	}
+
+	return ret;
+}
+
+/* power down chip */
+static int sgtl5000_remove(struct platform_device *pdev)
+{
+	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
+	struct snd_soc_codec *codec = socdev->codec;
+
+	if (codec->control_data)
+		sgtl5000_set_bias_level(codec, SND_SOC_BIAS_OFF);
+	snd_soc_free_pcms(socdev);
+	snd_soc_dapm_free(socdev);
+	i2c_del_driver(&sgtl5000_i2c_driver);
+	kfree(codec->private_data);
+	kfree(codec);
+
+	return 0;
+}
+
+struct snd_soc_codec_device soc_codec_dev_sgtl5000 = {
+	.probe = sgtl5000_probe,
+	.remove = sgtl5000_remove,
+	.suspend = sgtl5000_suspend,
+	.resume = sgtl5000_resume,
+};
+EXPORT_SYMBOL_GPL(soc_codec_dev_sgtl5000);
+
+MODULE_DESCRIPTION("ASoC SGTL5000 driver");
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/sgtl5000.h b/sound/soc/codecs/sgtl5000.h
new file mode 100644
index 0000000..6921474
--- /dev/null
+++ b/sound/soc/codecs/sgtl5000.h
@@ -0,0 +1,402 @@
+/*
+ * sgtl5000.h - SGTL5000 audio codec interface
+ *
+ * Copyright 2008-2009 Freescale Semiconductor, Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ */
+
+#ifndef _SGTL5000_H
+#define _SGTL5000_H
+
+#include <linux/i2c.h>
+
+extern struct snd_soc_dai sgtl5000_dai;
+extern struct snd_soc_codec_device soc_codec_dev_sgtl5000;
+
+/*
+ * Register values.
+ */
+#define SGTL5000_CHIP_ID			0x0000
+#define SGTL5000_CHIP_DIG_POWER			0x0002
+#define SGTL5000_CHIP_CLK_CTRL			0x0004
+#define SGTL5000_CHIP_I2S_CTRL			0x0006
+#define SGTL5000_CHIP_SSS_CTRL			0x000a
+#define SGTL5000_CHIP_ADCDAC_CTRL		0x000e
+#define SGTL5000_CHIP_DAC_VOL			0x0010
+#define SGTL5000_CHIP_PAD_STRENGTH		0x0014
+#define SGTL5000_CHIP_ANA_ADC_CTRL		0x0020
+#define SGTL5000_CHIP_ANA_HP_CTRL		0x0022
+#define SGTL5000_CHIP_ANA_CTRL			0x0024
+#define SGTL5000_CHIP_LINREG_CTRL		0x0026
+#define SGTL5000_CHIP_REF_CTRL			0x0028
+#define SGTL5000_CHIP_MIC_CTRL			0x002a
+#define SGTL5000_CHIP_LINE_OUT_CTRL		0x002c
+#define SGTL5000_CHIP_LINE_OUT_VOL		0x002e
+#define SGTL5000_CHIP_ANA_POWER			0x0030
+#define SGTL5000_CHIP_PLL_CTRL			0x0032
+#define SGTL5000_CHIP_CLK_TOP_CTRL		0x0034
+#define SGTL5000_CHIP_ANA_STATUS		0x0036
+#define SGTL5000_CHIP_SHORT_CTRL		0x003c
+#define SGTL5000_CHIP_ANA_TEST2			0x003a
+#define SGTL5000_DAP_CTRL			0x0100
+#define SGTL5000_DAP_PEQ			0x0102
+#define SGTL5000_DAP_BASS_ENHANCE		0x0104
+#define SGTL5000_DAP_BASS_ENHANCE_CTRL		0x0106
+#define SGTL5000_DAP_AUDIO_EQ			0x0108
+#define SGTL5000_DAP_SURROUND			0x010a
+#define SGTL5000_DAP_FLT_COEF_ACCESS		0x010c
+#define SGTL5000_DAP_COEF_WR_B0_MSB		0x010e
+#define SGTL5000_DAP_COEF_WR_B0_LSB		0x0110
+#define SGTL5000_DAP_EQ_BASS_BAND0		0x0116
+#define SGTL5000_DAP_EQ_BASS_BAND1		0x0118
+#define SGTL5000_DAP_EQ_BASS_BAND2		0x011a
+#define SGTL5000_DAP_EQ_BASS_BAND3		0x011c
+#define SGTL5000_DAP_EQ_BASS_BAND4		0x011e
+#define SGTL5000_DAP_MAIN_CHAN			0x0120
+#define SGTL5000_DAP_MIX_CHAN			0x0122
+#define SGTL5000_DAP_AVC_CTRL			0x0124
+#define SGTL5000_DAP_AVC_THRESHOLD		0x0126
+#define SGTL5000_DAP_AVC_ATTACK			0x0128
+#define SGTL5000_DAP_AVC_DECAY			0x012a
+#define SGTL5000_DAP_COEF_WR_B1_MSB		0x012c
+#define SGTL5000_DAP_COEF_WR_B1_LSB		0x012e
+#define SGTL5000_DAP_COEF_WR_B2_MSB		0x0130
+#define SGTL5000_DAP_COEF_WR_B2_LSB		0x0132
+#define SGTL5000_DAP_COEF_WR_A1_MSB		0x0134
+#define SGTL5000_DAP_COEF_WR_A1_LSB		0x0136
+#define SGTL5000_DAP_COEF_WR_A2_MSB		0x0138
+#define SGTL5000_DAP_COEF_WR_A2_LSB		0x013a
+
+/*
+ * Field Definitions.
+ */
+
+/*
+ * SGTL5000_CHIP_ID
+ */
+#define SGTL5000_PARTID_MASK			0xff00
+#define SGTL5000_PARTID_SHIFT			8
+#define SGTL5000_PARTID_WIDTH			8
+#define SGTL5000_PARTID_PART_ID		0xa0
+#define SGTL5000_REVID_MASK			0x00ff
+#define SGTL5000_REVID_SHIFT			0
+#define SGTL5000_REVID_WIDTH			8
+
+/*
+ * SGTL5000_CHIP_DIG_POWER
+ */
+#define SGTL5000_ADC_EN				0x0040
+#define SGTL5000_DAC_EN				0x0020
+#define SGTL5000_DAP_POWERUP			0x0010
+#define SGTL5000_I2S_OUT_POWERUP		0x0002
+#define SGTL5000_I2S_IN_POWERUP			0x0001
+
+/*
+ * SGTL5000_CHIP_CLK_CTRL
+ */
+#define SGTL5000_SYS_FS_MASK			0x00c0
+#define SGTL5000_SYS_FS_SHIFT			2
+#define SGTL5000_SYS_FS_WIDTH			2
+#define SGTL5000_SYS_FS_32k			0x0
+#define SGTL5000_SYS_FS_44_1k			0x1
+#define SGTL5000_SYS_FS_48k			0x2
+#define SGTL5000_SYS_FS_96k			0x3
+#define SGTL5000_MCLK_FREQ_MASK			0x0003
+#define SGTL5000_MCLK_FREQ_SHIFT		0
+#define SGTL5000_MCLK_FREQ_WIDTH		2
+#define SGTL5000_MCLK_FREQ_256FS		0x0
+#define SGTL5000_MCLK_FREQ_384FS		0x1
+#define SGTL5000_MCLK_FREQ_512FS		0x2
+#define SGTL5000_MCLK_FREQ_PLL			0x3
+
+/*
+ * SGTL5000_CHIP_I2S_CTRL
+ */
+#define SGTL5000_I2S_SCLKFREQ_MASK		0x0100
+#define SGTL5000_I2S_SCLKFREQ_SHIFT		8
+#define SGTL5000_I2S_SCLKFREQ_WIDTH		1
+#define SGTL5000_I2S_SCLKFREQ_64FS		0x0
+#define SGTL5000_I2S_SCLKFREQ_32FS		0x1	/* Not for RJ mode */
+#define SGTL5000_I2S_MASTER			0x0080
+#define SGTL5000_I2S_SCLK_INV			0x0040
+#define SGTL5000_I2S_DLEN_MASK			0x0030
+#define SGTL5000_I2S_DLEN_SHIFT			4
+#define SGTL5000_I2S_DLEN_WIDTH			2
+#define SGTL5000_I2S_DLEN_32			0x0
+#define SGTL5000_I2S_DLEN_24			0x1
+#define SGTL5000_I2S_DLEN_20			0x2
+#define SGTL5000_I2S_DLEN_16			0x3
+#define SGTL5000_I2S_MODE_MASK			0x000c
+#define SGTL5000_I2S_MODE_SHIFT			2
+#define SGTL5000_I2S_MODE_WIDTH			2
+#define SGTL5000_I2S_MODE_I2S_LJ		0x0
+#define SGTL5000_I2S_MODE_RJ			0x1
+#define SGTL5000_I2S_MODE_PCM			0x2
+#define SGTL5000_I2S_LRALIGN			0x0002
+#define SGTL5000_I2S_LRPOL			0x0001	/* set for which mode */
+
+/*
+ * SGTL5000_CHIP_SSS_CTRL
+ */
+#define SGTL5000_DAP_MIX_LRSWAP			0x4000
+#define SGTL5000_DAP_LRSWAP			0x2000
+#define SGTL5000_DAC_LRSWAP			0x1000
+#define SGTL5000_I2S_OUT_LRSWAP			0x0400
+#define SGTL5000_DAP_MIX_SEL_MASK		0x0300
+#define SGTL5000_DAP_MIX_SEL_SHIFT		8
+#define SGTL5000_DAP_MIX_SEL_WIDTH		2
+#define SGTL5000_DAP_MIX_SEL_ADC		0x0
+#define SGTL5000_DAP_MIX_SEL_I2S_IN		0x1
+#define SGTL5000_DAP_SEL_MASK			0x00c0
+#define SGTL5000_DAP_SEL_SHIFT			6
+#define SGTL5000_DAP_SEL_WIDTH			2
+#define SGTL5000_DAP_SEL_ADC			0x0
+#define SGTL5000_DAP_SEL_I2S_IN			0x1
+#define SGTL5000_DAC_SEL_MASK			0x0030
+#define SGTL5000_DAC_SEL_SHIFT			4
+#define SGTL5000_DAC_SEL_WIDTH			2
+#define SGTL5000_DAC_SEL_ADC			0x0
+#define SGTL5000_DAC_SEL_I2S_IN			0x1
+#define SGTL5000_DAC_SEL_DAP			0x3
+#define SGTL5000_I2S_OUT_SEL_MASK		0x0003
+#define SGTL5000_I2S_OUT_SEL_SHIFT		0
+#define SGTL5000_I2S_OUT_SEL_WIDTH		2
+#define SGTL5000_I2S_OUT_SEL_ADC		0x0
+#define SGTL5000_I2S_OUT_SEL_I2S_IN		0x1
+#define SGTL5000_I2S_OUT_SEL_DAP		0x3
+
+/*
+ * SGTL5000_CHIP_ADCDAC_CTRL
+ */
+#define SGTL5000_VOL_BUSY_DAC_RIGHT		0x2000
+#define SGTL5000_VOL_BUSY_DAC_LEFT		0x1000
+#define SGTL5000_DAC_VOL_RAMP_EN		0x0200
+#define SGTL5000_DAC_VOL_RAMP_EXPO		0x0100
+#define SGTL5000_DAC_MUTE_RIGHT			0x0008
+#define SGTL5000_DAC_MUTE_LEFT			0x0004
+#define SGTL5000_ADC_HPF_FREEZE			0x0002
+#define SGTL5000_ADC_HPF_BYPASS			0x0001
+
+/*
+ * SGTL5000_CHIP_DAC_VOL
+ */
+#define SGTL5000_DAC_VOL_RIGHT_MASK		0xff00
+#define SGTL5000_DAC_VOL_RIGHT_SHIFT		8
+#define SGTL5000_DAC_VOL_RIGHT_WIDTH		8
+#define SGTL5000_DAC_VOL_LEFT_MASK		0x00ff
+#define SGTL5000_DAC_VOL_LEFT_SHIFT		0
+#define SGTL5000_DAC_VOL_LEFT_WIDTH		8
+
+/*
+ * SGTL5000_CHIP_PAD_STRENGTH
+ */
+#define SGTL5000_PAD_I2S_LRCLK_MASK		0x0300
+#define SGTL5000_PAD_I2S_LRCLK_SHIFT		8
+#define SGTL5000_PAD_I2S_LRCLK_WIDTH		2
+#define SGTL5000_PAD_I2S_SCLK_MASK		0x00c0
+#define SGTL5000_PAD_I2S_SCLK_SHIFT		6
+#define SGTL5000_PAD_I2S_SCLK_WIDTH		2
+#define SGTL5000_PAD_I2S_DOUT_MASK		0x0030
+#define SGTL5000_PAD_I2S_DOUT_SHIFT		4
+#define SGTL5000_PAD_I2S_DOUT_WIDTH		2
+#define SGTL5000_PAD_I2C_SDA_MASK		0x000c
+#define SGTL5000_PAD_I2C_SDA_SHIFT		2
+#define SGTL5000_PAD_I2C_SDA_WIDTH		2
+#define SGTL5000_PAD_I2C_SCL_MASK		0x0003
+#define SGTL5000_PAD_I2C_SCL_SHIFT		0
+#define SGTL5000_PAD_I2C_SCL_WIDTH		2
+
+/*
+ * SGTL5000_CHIP_ANA_ADC_CTRL
+ */
+#define SGTL5000_ADC_VOL_M6DB			0x0100
+#define SGTL5000_ADC_VOL_RIGHT_MASK		0x00f0
+#define SGTL5000_ADC_VOL_RIGHT_SHIFT		4
+#define SGTL5000_ADC_VOL_RIGHT_WIDTH		4
+#define SGTL5000_ADC_VOL_LEFT_MASK		0x000f
+#define SGTL5000_ADC_VOL_LEFT_SHIFT		0
+#define SGTL5000_ADC_VOL_LEFT_WIDTH		4
+
+/*
+ * SGTL5000_CHIP_ANA_HP_CTRL
+ */
+#define SGTL5000_HP_VOL_RIGHT_MASK		0x7f00
+#define SGTL5000_HP_VOL_RIGHT_SHIFT		8
+#define SGTL5000_HP_VOL_RIGHT_WIDTH		7
+#define SGTL5000_HP_VOL_LEFT_MASK		0x007f
+#define SGTL5000_HP_VOL_LEFT_SHIFT		0
+#define SGTL5000_HP_VOL_LEFT_WIDTH		7
+
+/*
+ * SGTL5000_CHIP_ANA_CTRL
+ */
+#define SGTL5000_LINE_OUT_MUTE		0x0100
+#define SGTL5000_HP_SEL_MASK			0x0040
+#define SGTL5000_HP_SEL_SHIFT			6
+#define SGTL5000_HP_SEL_WIDTH			1
+#define SGTL5000_HP_SEL_DAC			0x0
+#define SGTL5000_HP_SEL_LINE_IN			0x1
+#define SGTL5000_HP_ZCD_EN			0x0020
+#define SGTL5000_HP_MUTE			0x0010
+#define SGTL5000_ADC_SEL_MASK			0x0004
+#define SGTL5000_ADC_SEL_SHIFT			2
+#define SGTL5000_ADC_SEL_WIDTH			1
+#define SGTL5000_ADC_SEL_MIC			0x0
+#define SGTL5000_ADC_SEL_LINE_IN		0x1
+#define SGTL5000_ADC_ZCD_EN			0x0002
+#define SGTL5000_ADC_MUTE			0x0001
+
+/*
+ * SGTL5000_CHIP_LINREG_CTRL
+ */
+#define SGTL5000_VDDC_MAN_ASSN_MASK		0x0040
+#define SGTL5000_VDDC_MAN_ASSN_SHIFT		6
+#define SGTL5000_VDDC_MAN_ASSN_WIDTH		1
+#define SGTL5000_VDDC_MAN_ASSN_VDDA		0x0
+#define SGTL5000_VDDC_MAN_ASSN_VDDIO		0x1
+#define SGTL5000_VDDC_ASSN_OVRD			0x0020
+#define SGTL5000_LINREG_VDDD_MASK		0x000f
+#define SGTL5000_LINREG_VDDD_SHIFT		0
+#define SGTL5000_LINREG_VDDD_WIDTH		4
+
+/*
+ * SGTL5000_CHIP_REF_CTRL
+ */
+#define SGTL5000_ANA_GND_MASK			0x01f0
+#define SGTL5000_ANA_GND_SHIFT			4
+#define SGTL5000_ANA_GND_WIDTH			5
+#define SGTL5000_ANA_GND_BASE			800	/* mv */
+#define SGTL5000_ANA_GND_STP			25	/*mv */
+#define SGTL5000_BIAS_CTRL_MASK			0x000e
+#define SGTL5000_BIAS_CTRL_SHIFT		1
+#define SGTL5000_BIAS_CTRL_WIDTH		3
+#define SGTL5000_SMALL_POP			0x0001
+
+/*
+ * SGTL5000_CHIP_MIC_CTRL
+ */
+#define SGTL5000_BIAS_R_MASK			0x0200
+#define SGTL5000_BIAS_R_SHIFT			8
+#define SGTL5000_BIAS_R_WIDTH			2
+#define SGTL5000_BIAS_R_off			0x0
+#define SGTL5000_BIAS_R_2K			0x1
+#define SGTL5000_BIAS_R_4k			0x2
+#define SGTL5000_BIAS_R_8k			0x3
+#define SGTL5000_BIAS_VOLT_MASK			0x0070
+#define SGTL5000_BIAS_VOLT_SHIFT		4
+#define SGTL5000_BIAS_VOLT_WIDTH		3
+#define SGTL5000_MIC_GAIN_MASK			0x0003
+#define SGTL5000_MIC_GAIN_SHIFT			0
+#define SGTL5000_MIC_GAIN_WIDTH			2
+
+/*
+ * SGTL5000_CHIP_LINE_OUT_CTRL
+ */
+#define SGTL5000_LINE_OUT_CURRENT_MASK		0x0f00
+#define SGTL5000_LINE_OUT_CURRENT_SHIFT		8
+#define SGTL5000_LINE_OUT_CURRENT_WIDTH		4
+#define SGTL5000_LINE_OUT_CURRENT_180u		0x0
+#define SGTL5000_LINE_OUT_CURRENT_270u		0x1
+#define SGTL5000_LINE_OUT_CURRENT_360u		0x3
+#define SGTL5000_LINE_OUT_CURRENT_450u		0x7
+#define SGTL5000_LINE_OUT_CURRENT_540u		0xf
+#define SGTL5000_LINE_OUT_GND_MASK		0x003f
+#define SGTL5000_LINE_OUT_GND_SHIFT		0
+#define SGTL5000_LINE_OUT_GND_WIDTH		6
+#define SGTL5000_LINE_OUT_GND_BASE		800	/* mv */
+#define SGTL5000_LINE_OUT_GND_STP		25
+#define SGTL5000_LINE_OUT_GND_MAX		0x23
+
+/*
+ * SGTL5000_CHIP_LINE_OUT_VOL
+ */
+#define SGTL5000_LINE_OUT_VOL_RIGHT_MASK	0x1f00
+#define SGTL5000_LINE_OUT_VOL_RIGHT_SHIFT	8
+#define SGTL5000_LINE_OUT_VOL_RIGHT_WIDTH	5
+#define SGTL5000_LINE_OUT_VOL_LEFT_MASK		0x001f
+#define SGTL5000_LINE_OUT_VOL_LEFT_SHIFT	0
+#define SGTL5000_LINE_OUT_VOL_LEFT_WIDTH	5
+
+/*
+ * SGTL5000_CHIP_ANA_POWER
+ */
+#define SGTL5000_DAC_STERO			0x4000
+#define SGTL5000_LINREG_SIMPLE_POWERUP		0x2000
+#define SGTL5000_STARTUP_POWERUP		0x1000
+#define SGTL5000_VDDC_CHRGPMP_POWERUP		0x0800
+#define SGTL5000_PLL_POWERUP			0x0400
+#define SGTL5000_LINEREG_D_POWERUP		0x0200
+#define SGTL5000_VCOAMP_POWERUP			0x0100
+#define SGTL5000_VAG_POWERUP			0x0080
+#define SGTL5000_ADC_STERO			0x0040
+#define SGTL5000_REFTOP_POWERUP			0x0020
+#define SGTL5000_HP_POWERUP			0x0010
+#define SGTL5000_DAC_POWERUP			0x0008
+#define SGTL5000_CAPLESS_HP_POWERUP		0x0004
+#define SGTL5000_ADC_POWERUP			0x0002
+#define SGTL5000_LINE_OUT_POWERUP		0x0001
+
+/*
+ * SGTL5000_CHIP_PLL_CTRL
+ */
+#define SGTL5000_PLL_INT_DIV_MASK		0xf800
+#define SGTL5000_PLL_INT_DIV_SHIFT		11
+#define SGTL5000_PLL_INT_DIV_WIDTH		5
+#define SGTL5000_PLL_FRAC_DIV_MASK		0x0700
+#define SGTL5000_PLL_FRAC_DIV_SHIFT		0
+#define SGTL5000_PLL_FRAC_DIV_WIDTH		11
+
+/*
+ * SGTL5000_CHIP_CLK_TOP_CTRL
+ */
+#define SGTL5000_INT_OSC_EN			0x0800
+#define SGTL5000_INPUT_FREQ_DIV2		0x0008
+
+/*
+ * SGTL5000_CHIP_ANA_STATUS
+ */
+#define SGTL5000_HP_LRSHORT			0x0200
+#define SGTL5000_CAPLESS_SHORT			0x0100
+#define SGTL5000_PLL_LOCKED			0x0010
+
+/*
+ * SGTL5000_CHIP_SHORT_CTRL
+ */
+#define SGTL5000_LVLADJR_MASK			0x7000
+#define SGTL5000_LVLADJR_SHIFT			12
+#define SGTL5000_LVLADJR_WIDTH			3
+#define SGTL5000_LVLADJL_MASK			0x0700
+#define SGTL5000_LVLADJL_SHIFT			8
+#define SGTL5000_LVLADJL_WIDTH			3
+#define SGTL5000_LVLADJC_MASK			0x0070
+#define SGTL5000_LVLADJC_SHIFT			4
+#define SGTL5000_LVLADJC_WIDTH			3
+#define SGTL5000_LR_SHORT_MOD_MASK		0x000c
+#define SGTL5000_LR_SHORT_MOD_SHIFT		2
+#define SGTL5000_LR_SHORT_MOD_WIDTH		2
+#define SGTL5000_CM_SHORT_MOD_MASK		0x0003
+#define SGTL5000_CM_SHORT_MOD_SHIFT		0
+#define SGTL5000_CM_SHORT_MOD_WIDTH		2
+
+/*
+ *SGTL5000_CHIP_ANA_TEST2
+ */
+#define SGTL5000_MONO_DAC			0x1000
+
+/*
+ * SGTL5000_DAP_CTRL
+ */
+#define SGTL5000_DAP_MIX_EN			0x0010
+#define SGTL5000_DAP_EN				0x0001
+
+struct sgtl5000_platform_data {
+	int vddio;		/* voltage of VDDIO (mv) */
+	int vdda;		/* voltage of vdda (mv) */
+	int vddd;		/* voltage of vddd (mv), 0 if not connected */
+};
+
+#endif
diff --git a/sound/soc/imx/Kconfig b/sound/soc/imx/Kconfig
new file mode 100644
index 0000000..1727bc8
--- /dev/null
+++ b/sound/soc/imx/Kconfig
@@ -0,0 +1,30 @@
+config SND_MXC_SOC
+ tristate "SoC Audio for the Freescale i.MX CPU"
+ depends on ARCH_MXC && SND && MXC_SDMA_API
+ select SND_PCM
+ help
+   Say Y or M if you want to add support for codecs attached to
+   the MXC I2S or SSP interface. You will also need
+   to select the audio interfaces to support below.
+
+if SND_MXC_SOC
+
+config SND_MXC_SOC_SSI
+ tristate
+
+config SND_MXC_SOC_IRAM
+ bool "Locate Audio DMA playback buffers in IRAM"
+ depends on SDMA_IRAM
+ help
+   Say Y if you don't want Audio playback buffers in external ram
+
+config SND_SOC_IMX_3STACK_SGTL5000
+ tristate "SoC Audio support for IMX - SGTL5000"
+ select SND_MXC_SOC_SSI
+ select SND_SOC_SGTL5000
+ help
+   Say Y if you want to add support for SoC audio on IMX 3STACK
+   with the SGTL5000.
+
+endif
+
diff --git a/sound/soc/imx/Makefile b/sound/soc/imx/Makefile
new file mode 100644
index 0000000..a9d959e
--- /dev/null
+++ b/sound/soc/imx/Makefile
@@ -0,0 +1,11 @@
+# i.MX Platform Support
+snd-soc-imx-objs := imx-pcm.o
+snd-soc-imx-ssi-objs := imx-ssi.o
+
+obj-$(CONFIG_SND_MXC_SOC) += snd-soc-imx.o
+obj-$(CONFIG_SND_MXC_SOC_SSI) += snd-soc-imx-ssi.o
+
+# i.MX Machine Support
+snd-soc-imx-3stack-sgtl5000-objs := imx-3stack-sgtl5000.o
+obj-$(CONFIG_SND_SOC_IMX_3STACK_SGTL5000) += snd-soc-imx-3stack-sgtl5000.o
+
diff --git a/sound/soc/imx/imx-3stack-sgtl5000.c b/sound/soc/imx/imx-3stack-sgtl5000.c
new file mode 100644
index 0000000..27bab2f
--- /dev/null
+++ b/sound/soc/imx/imx-3stack-sgtl5000.c
@@ -0,0 +1,594 @@
+/*
+ * imx-3stack-sgtl5000.c  --  i.MX 3Stack Driver for Freescale SGTL5000 Codec
+ *
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    21th Oct 2008   Initial version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/bitops.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/i2c.h>
+#include <linux/err.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/initval.h>
+
+#include <mach/dma.h>
+#include <mach/spba.h>
+#include <mach/clock.h>
+#include <mach/mxc.h>
+
+#include "../codecs/sgtl5000.h"
+#include "imx-ssi.h"
+#include "imx-pcm.h"
+
+/* SSI BCLK and LRC master */
+#define SGTL5000_SSI_MASTER	1
+
+struct imx_3stack_priv {
+	int sysclk;
+	int hw;
+	struct platform_device *pdev;
+	struct regulator *reg_vddio;
+	struct regulator *reg_vdda;
+	struct regulator *reg_vddd;
+};
+
+static struct imx_3stack_priv machine_priv;
+
+static int imx_3stack_audio_hw_params(struct snd_pcm_substream *substream,
+				      struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai_link *machine = rtd->dai;
+	struct snd_soc_dai *cpu_dai = machine->cpu_dai;
+	struct snd_soc_dai *codec_dai = machine->codec_dai;
+	struct imx_3stack_priv *priv = &machine_priv;
+	int ret = 0;
+
+	unsigned int channels = params_channels(params);
+	u32 dai_format;
+
+	/* only need to do this once as capture and playback are sync */
+	if (priv->hw)
+		return 0;
+	priv->hw = 1;
+
+	snd_soc_dai_set_sysclk(codec_dai, 0, priv->sysclk, 0);
+
+#if SGTL5000_SSI_MASTER
+	dai_format = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+	    SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_SYNC;
+	if (channels == 2)
+		dai_format |= SND_SOC_DAIFMT_TDM;
+
+	/* set codec DAI configuration */
+	ret = snd_soc_dai_set_fmt(codec_dai, dai_format);
+	if (ret < 0)
+		return ret;
+
+	/* set cpu DAI configuration */
+	ret = snd_soc_dai_set_fmt(cpu_dai, dai_format);
+	if (ret < 0)
+		return ret;
+#else
+	dai_format = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+	    SND_SOC_DAIFMT_CBS_CFS | SND_SOC_DAIFMT_SYNC;
+	if (channels == 2)
+		dai_format |= SND_SOC_DAIFMT_TDM;
+
+	/* set codec DAI configuration */
+	ret = snd_soc_dai_set_fmt(codec_dai, dai_format);
+	if (ret < 0)
+		return ret;
+
+	/* set cpu DAI configuration */
+	ret = snd_soc_dai_set_fmt(cpu_dai, dai_format);
+	if (ret < 0)
+		return ret;
+#endif
+
+	/* set i.MX active slot mask */
+	snd_soc_dai_set_tdm_slot(cpu_dai,
+				 channels == 1 ? 0xfffffffe : 0xfffffffc,
+				 2);
+
+	/* set the SSI system clock as input (unused) */
+	snd_soc_dai_set_sysclk(cpu_dai, IMX_SSP_SYS_CLK, 0, SND_SOC_CLOCK_IN);
+
+	return 0;
+}
+
+static void imx_3stack_shutdown(struct snd_pcm_substream *substream)
+{
+	struct imx_3stack_priv *priv = &machine_priv;
+
+	priv->hw = 0;
+}
+
+/*
+ * imx_3stack SGTL5000 audio DAI opserations.
+ */
+static struct snd_soc_ops imx_3stack_ops = {
+	.shutdown = imx_3stack_shutdown,
+	.hw_params = imx_3stack_audio_hw_params,
+};
+
+static void imx_3stack_init_dam(int ssi_port, int dai_port)
+{
+	unsigned int ssi_ptcr = 0;
+	unsigned int dai_ptcr = 0;
+	unsigned int ssi_pdcr = 0;
+	unsigned int dai_pdcr = 0;
+	/* SGTL5000 uses SSI1 or SSI2 via AUDMUX port dai_port for audio */
+
+	/* reset port ssi_port & dai_port */
+	__raw_writel(0, DAM_PTCR(ssi_port));
+	__raw_writel(0, DAM_PTCR(dai_port));
+	__raw_writel(0, DAM_PDCR(ssi_port));
+	__raw_writel(0, DAM_PDCR(dai_port));
+
+	/* set to synchronous */
+	ssi_ptcr |= AUDMUX_PTCR_SYN;
+	dai_ptcr |= AUDMUX_PTCR_SYN;
+
+#if SGTL5000_SSI_MASTER
+	/* set Rx sources ssi_port <--> dai_port */
+	ssi_pdcr |= AUDMUX_PDCR_RXDSEL(dai_port);
+	dai_pdcr |= AUDMUX_PDCR_RXDSEL(ssi_port);
+
+	/* set Tx frame direction and source  dai_port--> ssi_port output */
+	ssi_ptcr |= AUDMUX_PTCR_TFSDIR;
+	ssi_ptcr |= AUDMUX_PTCR_TFSSEL(AUDMUX_FROM_TXFS, dai_port);
+
+	/* set Tx Clock direction and source dai_port--> ssi_port output */
+	ssi_ptcr |= AUDMUX_PTCR_TCLKDIR;
+	ssi_ptcr |= AUDMUX_PTCR_TCSEL(AUDMUX_FROM_TXFS, dai_port);
+#else
+	/* set Rx sources ssi_port <--> dai_port */
+	ssi_pdcr |= AUDMUX_PDCR_RXDSEL(dai_port);
+	dai_pdcr |= AUDMUX_PDCR_RXDSEL(ssi_port);
+
+	/* set Tx frame direction and source  ssi_port --> dai_port output */
+	dai_ptcr |= AUDMUX_PTCR_TFSDIR;
+	dai_ptcr |= AUDMUX_PTCR_TFSSEL(AUDMUX_FROM_TXFS, ssi_port);
+
+	/* set Tx Clock direction and source ssi_port--> dai_port output */
+	dai_ptcr |= AUDMUX_PTCR_TCLKDIR;
+	dai_ptcr |= AUDMUX_PTCR_TCSEL(AUDMUX_FROM_TXFS, ssi_port);
+#endif
+
+	__raw_writel(ssi_ptcr, DAM_PTCR(ssi_port));
+	__raw_writel(dai_ptcr, DAM_PTCR(dai_port));
+	__raw_writel(ssi_pdcr, DAM_PDCR(ssi_port));
+	__raw_writel(dai_pdcr, DAM_PDCR(dai_port));
+}
+
+/* imx_3stack machine connections to the codec pins */
+static const struct snd_soc_dapm_route audio_map[] = {
+
+	/* Mic Jack --> MIC_IN (with automatic bias) */
+	{"MIC_IN", NULL, "Mic Jack"},
+
+	/* Line in Jack --> LINE_IN */
+	{"LINE_IN", NULL, "Line In Jack"},
+
+	/* HP_OUT --> Headphone Jack */
+	{"Headphone Jack", NULL, "HP_OUT"},
+
+	/* LINE_OUT --> Ext Speaker */
+	{"Ext Spk", NULL, "LINE_OUT"},
+};
+
+static int sgtl5000_jack_func;
+static int sgtl5000_spk_func;
+
+static void headphone_detect_handler(struct work_struct *work)
+{
+	struct imx_3stack_priv *priv = &machine_priv;
+	struct platform_device *pdev = priv->pdev;
+	struct mxc_audio_platform_data *plat = pdev->dev.platform_data;
+	int hp_status;
+
+	sysfs_notify(&pdev->dev.kobj, NULL, "headphone");
+	hp_status = plat->hp_status();
+	if (hp_status)
+		set_irq_type(plat->hp_irq, IRQ_TYPE_EDGE_FALLING);
+	else
+		set_irq_type(plat->hp_irq, IRQ_TYPE_EDGE_RISING);
+	enable_irq(plat->hp_irq);
+}
+
+static DECLARE_DELAYED_WORK(hp_event, headphone_detect_handler);
+
+static irqreturn_t imx_headphone_detect_handler(int irq, void *data)
+{
+	disable_irq(irq);
+	schedule_delayed_work(&hp_event, msecs_to_jiffies(200));
+	return IRQ_HANDLED;
+}
+
+static ssize_t show_headphone(struct device_driver *dev, char *buf)
+{
+	struct imx_3stack_priv *priv = &machine_priv;
+	struct platform_device *pdev = priv->pdev;
+	struct mxc_audio_platform_data *plat = pdev->dev.platform_data;
+	u16 hp_status;
+
+	/* determine whether hp is plugged in */
+	hp_status = plat->hp_status();
+
+	if (hp_status == 0)
+		strcpy(buf, "speaker\n");
+	else
+		strcpy(buf, "headphone\n");
+
+	return strlen(buf);
+}
+
+static DRIVER_ATTR(headphone, S_IRUGO | S_IWUSR, show_headphone, NULL);
+
+static const char *jack_function[] = { "off", "on"
+};
+
+static const char *spk_function[] = { "off", "on" };
+
+static const struct soc_enum sgtl5000_enum[] = {
+	SOC_ENUM_SINGLE_EXT(2, jack_function),
+	SOC_ENUM_SINGLE_EXT(2, spk_function),
+};
+
+static int sgtl5000_get_jack(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.enumerated.item[0] = sgtl5000_jack_func;
+	return 0;
+}
+
+static int sgtl5000_set_jack(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+
+	if (sgtl5000_jack_func == ucontrol->value.enumerated.item[0])
+		return 0;
+
+	sgtl5000_jack_func = ucontrol->value.enumerated.item[0];
+	if (sgtl5000_jack_func)
+		snd_soc_dapm_enable_pin(codec, "Headphone Jack");
+	else
+		snd_soc_dapm_disable_pin(codec, "Headphone Jack");
+
+	snd_soc_dapm_sync(codec);
+	return 1;
+}
+
+static int sgtl5000_get_spk(struct snd_kcontrol *kcontrol,
+			    struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.enumerated.item[0] = sgtl5000_spk_func;
+	return 0;
+}
+
+static int sgtl5000_set_spk(struct snd_kcontrol *kcontrol,
+			    struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+
+	if (sgtl5000_spk_func == ucontrol->value.enumerated.item[0])
+		return 0;
+
+	sgtl5000_spk_func = ucontrol->value.enumerated.item[0];
+	if (sgtl5000_spk_func) {
+		snd_soc_dapm_enable_pin(codec, "Ext Spk");
+	} else {
+		snd_soc_dapm_disable_pin(codec, "Ext Spk");
+	}
+
+	snd_soc_dapm_sync(codec);
+	return 1;
+}
+
+static int spk_amp_event(struct snd_soc_dapm_widget *w,
+			 struct snd_kcontrol *kcontrol, int event)
+{
+	struct imx_3stack_priv *priv = &machine_priv;
+	struct platform_device *pdev = priv->pdev;
+	struct mxc_audio_platform_data *plat = pdev->dev.platform_data;
+
+	if (plat->amp_enable == NULL)
+		return 0;
+
+	if (SND_SOC_DAPM_EVENT_ON(event))
+		plat->amp_enable(1);
+	else
+		plat->amp_enable(0);
+
+	return 0;
+}
+
+/* imx_3stack machine dapm widgets */
+static const struct snd_soc_dapm_widget imx_3stack_dapm_widgets[] = {
+	SND_SOC_DAPM_MIC("Mic Jack", NULL),
+	SND_SOC_DAPM_LINE("Line In Jack", NULL),
+	SND_SOC_DAPM_SPK("Ext Spk", spk_amp_event),
+	SND_SOC_DAPM_HP("Headphone Jack", NULL),
+};
+
+static const struct snd_kcontrol_new sgtl5000_machine_controls[] = {
+	SOC_ENUM_EXT("Jack Function", sgtl5000_enum[0], sgtl5000_get_jack,
+		     sgtl5000_set_jack),
+	SOC_ENUM_EXT("Speaker Function", sgtl5000_enum[1], sgtl5000_get_spk,
+		     sgtl5000_set_spk),
+};
+
+static int imx_3stack_sgtl5000_init(struct snd_soc_codec *codec)
+{
+	int i, ret;
+
+	/* Add imx_3stack specific controls */
+	for (i = 0; i < ARRAY_SIZE(sgtl5000_machine_controls); i++) {
+		ret = snd_ctl_add(codec->card,
+				  snd_soc_cnew(&sgtl5000_machine_controls[i],
+					       codec, NULL));
+		if (ret < 0)
+			return ret;
+	}
+
+	/* Add imx_3stack specific widgets */
+	snd_soc_dapm_new_controls(codec, imx_3stack_dapm_widgets,
+				  ARRAY_SIZE(imx_3stack_dapm_widgets));
+
+	/* Set up imx_3stack specific audio path audio_map */
+	snd_soc_dapm_add_routes(codec, audio_map, ARRAY_SIZE(audio_map));
+
+	snd_soc_dapm_sync(codec);
+
+	return 0;
+}
+
+/* imx_3stack digital audio interface glue - connects codec <--> CPU */
+static struct snd_soc_dai_link imx_3stack_dai = {
+	.name = "SGTL5000",
+	.stream_name = "SGTL5000",
+	.cpu_dai = &imx_ssi_dai,
+	.codec_dai = &sgtl5000_dai,
+	.init = imx_3stack_sgtl5000_init,
+	.ops = &imx_3stack_ops,
+};
+
+static int imx_3stack_machine_remove(struct platform_device *pdev)
+{
+	struct imx_3stack_priv *priv = &machine_priv;
+	struct mxc_audio_platform_data *plat;
+	if (priv->reg_vddio)
+		regulator_disable(priv->reg_vddio);
+	if (priv->reg_vddd)
+		regulator_disable(priv->reg_vddd);
+	if (priv->reg_vdda)
+		regulator_disable(priv->reg_vdda);
+	if (priv->reg_vdda)
+		regulator_put(priv->reg_vdda);
+	if (priv->reg_vddio)
+		regulator_put(priv->reg_vddio);
+	if (priv->reg_vddd)
+		regulator_put(priv->reg_vddd);
+	if (priv->pdev) {
+		plat = priv->pdev->dev.platform_data;
+		if (plat->finit)
+			plat->finit();
+	}
+
+	return 0;
+}
+#if 1
+/* imx_3stack audio machine driver */
+static struct snd_soc_machine snd_soc_machine_imx_3stack = {
+	.name = "imx-3stack",
+	.dai_link = &imx_3stack_dai,
+	.num_links = 1,
+	.remove = imx_3stack_machine_remove,
+};
+#endif
+
+static struct snd_soc_device imx_3stack_snd_devdata = {
+#if 1
+	.machine = &snd_soc_machine_imx_3stack,
+#endif
+	.platform = &imx_soc_platform,
+	.codec_dev = &soc_codec_dev_sgtl5000,
+};
+
+static int __devinit imx_3stack_sgtl5000_probe(struct platform_device *pdev)
+{
+	struct mxc_audio_platform_data *plat = pdev->dev.platform_data;
+	struct regulator *reg;
+	struct imx_3stack_priv *priv = &machine_priv;
+	struct sgtl5000_platform_data *codec_data;
+	int ret = 0;
+
+	priv->sysclk = plat->sysclk;
+	priv->pdev = pdev;
+	imx_ssi_dai.private_data = plat;
+
+	codec_data = kzalloc(sizeof(struct sgtl5000_platform_data), GFP_KERNEL);
+	if (!codec_data) {
+		ret = -ENOMEM;
+		goto err_codec_data;
+	}
+	codec_data->vddio = plat->vddio / 1000;	/* uV to mV */
+	codec_data->vdda = plat->vdda / 1000;
+	codec_data->vddd = plat->vddd / 1000;
+	imx_3stack_snd_devdata.codec_data = codec_data;
+
+	gpio_activate_audio_ports();
+	imx_3stack_init_dam(plat->src_port, plat->ext_port);
+
+	if (plat->src_port == 2)
+		imx_ssi_dai.name = "imx-ssi-3";
+	else
+		imx_ssi_dai.name = "imx-ssi-1";
+
+	ret = driver_create_file(pdev->dev.driver, &driver_attr_headphone);
+	if (ret < 0) {
+		pr_err("%s:failed to create driver_attr_headphone\n", __func__);
+		goto sysfs_err;
+	}
+
+	ret = -EINVAL;
+	if (plat->init && plat->init())
+		goto err_plat_init;
+	if (plat->vddio_reg) {
+		reg = regulator_get(&pdev->dev, plat->vddio_reg);
+		if (IS_ERR(reg))
+			goto err_reg_vddio;
+		priv->reg_vddio = reg;
+	}
+	if (plat->vdda_reg) {
+		reg = regulator_get(&pdev->dev, plat->vdda_reg);
+		if (IS_ERR(reg))
+			goto err_reg_vdda;
+		priv->reg_vdda = reg;
+	}
+	if (plat->vddd_reg) {
+		reg = regulator_get(&pdev->dev, plat->vddd_reg);
+		if (IS_ERR(reg))
+			goto err_reg_vddd;
+		priv->reg_vddd = reg;
+	}
+
+	if (priv->reg_vdda) {
+		ret = regulator_set_voltage(priv->reg_vdda,
+					    plat->vdda, plat->vdda);
+		regulator_enable(priv->reg_vdda);
+	}
+	if (priv->reg_vddio) {
+		regulator_set_voltage(priv->reg_vddio,
+				      plat->vddio, plat->vddio);
+		regulator_enable(priv->reg_vddio);
+	}
+	if (priv->reg_vddd) {
+		regulator_set_voltage(priv->reg_vddd, plat->vddd, plat->vddd);
+		regulator_enable(priv->reg_vddd);
+	}
+
+	/* The SGTL5000 has an internal reset that is deasserted 8 SYS_MCLK
+	   cycles after all power rails have been brought up. After this time
+	   communication can start */
+	msleep(1);
+
+	if (plat->hp_status())
+		ret = request_irq(plat->hp_irq,
+				  imx_headphone_detect_handler,
+				  IRQ_TYPE_EDGE_FALLING, pdev->name, priv);
+	else
+		ret = request_irq(plat->hp_irq,
+				  imx_headphone_detect_handler,
+				  IRQ_TYPE_EDGE_RISING, pdev->name, priv);
+	if (ret < 0) {
+		pr_err("%s: request irq failed\n", __func__);
+		goto err_card_reg;
+	}
+
+	sgtl5000_jack_func = 1;
+	sgtl5000_spk_func = 1;
+
+	return 0;
+
+err_card_reg:
+	if (priv->reg_vddd)
+		regulator_put(priv->reg_vddd);
+err_reg_vddd:
+	if (priv->reg_vdda)
+		regulator_put(priv->reg_vdda);
+err_reg_vdda:
+	if (priv->reg_vddio)
+		regulator_put(priv->reg_vddio);
+err_reg_vddio:
+	if (plat->finit)
+		plat->finit();
+err_plat_init:
+	driver_remove_file(pdev->dev.driver, &driver_attr_headphone);
+sysfs_err:
+	kfree(codec_data);
+err_codec_data:
+	return ret;
+}
+
+static int imx_3stack_sgtl5000_remove(struct platform_device *pdev)
+{
+	struct mxc_audio_platform_data *plat = pdev->dev.platform_data;
+	struct imx_3stack_priv *priv = &machine_priv;
+
+	free_irq(plat->hp_irq, priv);
+
+	driver_remove_file(pdev->dev.driver, &driver_attr_headphone);
+
+	kfree(imx_3stack_snd_devdata.codec_data);
+
+	return 0;
+}
+
+static struct platform_driver imx_3stack_sgtl5000_audio_driver = {
+	.probe = imx_3stack_sgtl5000_probe,
+	.remove = imx_3stack_sgtl5000_remove,
+	.driver = {
+		   .name = "imx-3stack-sgtl5000",
+		   },
+};
+
+static struct platform_device *imx_3stack_snd_device;
+
+static int __init imx_3stack_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&imx_3stack_sgtl5000_audio_driver);
+	if (ret)
+		return -ENOMEM;
+
+	imx_3stack_snd_device = platform_device_alloc("soc-audio", 2);
+	if (!imx_3stack_snd_device)
+		return -ENOMEM;
+
+	platform_set_drvdata(imx_3stack_snd_device, &imx_3stack_snd_devdata);
+	imx_3stack_snd_devdata.dev = &imx_3stack_snd_device->dev;
+	ret = platform_device_add(imx_3stack_snd_device);
+
+	if (ret)
+		platform_device_put(imx_3stack_snd_device);
+
+	return ret;
+}
+
+static void __exit imx_3stack_exit(void)
+{
+	platform_driver_unregister(&imx_3stack_sgtl5000_audio_driver);
+	platform_device_unregister(imx_3stack_snd_device);
+}
+
+module_init(imx_3stack_init);
+module_exit(imx_3stack_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("SGTL5000 Driver for i.MX 3STACK");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/imx/imx-esai.h b/sound/soc/imx/imx-esai.h
new file mode 100644
index 0000000..8ac2e3f
--- /dev/null
+++ b/sound/soc/imx/imx-esai.h
@@ -0,0 +1,25 @@
+/*
+ * imx-esai.h  --  ESAI driver header file for Freescale IMX
+ *
+ * Copyright 2008-2009 Freescale  Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef _MXC_ESAI_H
+#define _MXC_ESAI_H
+
+#define IMX_DAI_ESAI_TX 0x04
+#define IMX_DAI_ESAI_RX 0x08
+#define IMX_DAI_ESAI_TXRX (IMX_DAI_ESAI_TX | IMX_DAI_ESAI_RX)
+
+extern struct snd_soc_dai imx_esai_dai;
+
+#endif
diff --git a/sound/soc/imx/imx-pcm.c b/sound/soc/imx/imx-pcm.c
new file mode 100644
index 0000000..6a93ff1
--- /dev/null
+++ b/sound/soc/imx/imx-pcm.c
@@ -0,0 +1,595 @@
+/*
+ * imx-pcm.c -- ALSA SoC interface for the Freescale i.MX3 CPU's
+ *
+ * Copyright 2006 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ * Based on imx31-pcm.c by Nicolas Pitre, (C) 2004 MontaVista Software, Inc.
+ * and on mxc-alsa-mc13783 (C) 2006-2009 Freescale.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <mach/dma.h>
+#include <mach/spba.h>
+#include <mach/clock.h>
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+
+#include "imx-pcm.h"
+#include "imx-ssi.h"
+#include "imx-esai.h"
+
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+static bool UseIram = 1;
+#else
+static bool UseIram;
+#endif
+
+/* debug */
+#define IMX_PCM_DEBUG 0
+#if IMX_PCM_DEBUG
+#define dbg(format, arg...) printk(format, ## arg)
+#else
+#define dbg(format, arg...)
+#endif
+
+static const struct snd_pcm_hardware imx_pcm_hardware = {
+	.info = (SNDRV_PCM_INFO_INTERLEAVED |
+		 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+		 SNDRV_PCM_INFO_MMAP |
+		 SNDRV_PCM_INFO_MMAP_VALID |
+		 SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME),
+	.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,
+#ifdef CONFIG_SND_MXC_SOC_IRAM
+	.buffer_bytes_max = SND_RAM_SIZE,
+	.period_bytes_max = SND_RAM_SIZE / 4,
+#else
+	.buffer_bytes_max = 64 * 1024,
+	.period_bytes_max = 16 * 1024,
+#endif
+	.period_bytes_min = 64,
+	.periods_min = 2,
+	.periods_max = 255,
+	.fifo_size = 0,
+};
+
+struct mxc_runtime_data {
+	int dma_ch;
+	spinlock_t dma_lock;
+	int active, period, periods;
+	int dma_wchannel;
+	int dma_active;
+	int dma_alloc;
+};
+
+static uint32_t audio_iram_phys_base_addr;
+static void *audio_iram_virt_base_addr;
+
+static struct vm_operations_struct snd_mxc_audio_playback_vm_ops = {
+	.open = snd_pcm_mmap_data_open,
+	.close = snd_pcm_mmap_data_close,
+};
+
+/*
+	enable user space access to iram buffer
+*/
+static int imx_iram_audio_playback_mmap(struct snd_pcm_substream *substream,
+					struct vm_area_struct *area)
+{
+	unsigned long off;
+	unsigned long phys;
+	unsigned long size;
+	int ret = 0;
+
+	area->vm_ops = &snd_mxc_audio_playback_vm_ops;
+	area->vm_private_data = substream;
+
+	off = area->vm_pgoff << PAGE_SHIFT;
+	phys = audio_iram_phys_base_addr + off;
+	size = area->vm_end - area->vm_start;
+
+	if (off + size > SND_RAM_SIZE)
+		return -EINVAL;
+
+	area->vm_flags |= VM_IO;
+	ret =
+	    remap_pfn_range(area, area->vm_start, phys >> PAGE_SHIFT,
+			    size, area->vm_page_prot);
+	if (ret == 0)
+		area->vm_ops->open(area);
+
+	return ret;
+}
+
+/*
+     Map nbytes in virtual space
+     bytes -audio iram iram partition size
+     phys_addr - physical address of iram buffer
+     returns - virtual address of the iram buffer or NULL if fail
+*/
+static void *imx_iram_init(dma_addr_t *phys_addr, size_t bytes)
+{
+	void *iram_base;
+
+	iram_base = (void *)ioremap((uint32_t) SND_RAM_BASE_ADDR, bytes);
+
+	audio_iram_virt_base_addr = iram_base;
+	audio_iram_phys_base_addr = (uint32_t) SND_RAM_BASE_ADDR;
+	*phys_addr = (dma_addr_t) SND_RAM_BASE_ADDR;
+
+	return audio_iram_virt_base_addr;
+
+}
+
+/*
+     destroy the virtual mapping of the iram buffer
+*/
+
+static void imx_iram_free(void)
+{
+	iounmap(audio_iram_virt_base_addr);
+}
+
+static int imx_get_sdma_transfer(int format, int dai_port, int stream_type)
+{
+	int transfer = -1;
+
+	if (dai_port == IMX_DAI_SSI0) {
+		if (stream_type == SNDRV_PCM_STREAM_PLAYBACK) {
+			if (format == SNDRV_PCM_FORMAT_S16_LE)
+				transfer = MXC_DMA_SSI1_16BIT_TX0;
+			else if (format == SNDRV_PCM_FORMAT_S24_LE)
+				transfer = MXC_DMA_SSI1_24BIT_TX0;
+			else if (format == SNDRV_PCM_FORMAT_S20_3LE)
+				transfer = MXC_DMA_SSI1_24BIT_TX0;
+		} else {
+			if (format == SNDRV_PCM_FORMAT_S16_LE)
+				transfer = MXC_DMA_SSI1_16BIT_RX0;
+			else if (format == SNDRV_PCM_FORMAT_S24_LE)
+				transfer = MXC_DMA_SSI1_24BIT_RX0;
+			else if (format == SNDRV_PCM_FORMAT_S20_3LE)
+				transfer = MXC_DMA_SSI1_24BIT_RX0;
+		}
+	} else if (dai_port == IMX_DAI_SSI1) {
+		if (stream_type == SNDRV_PCM_STREAM_PLAYBACK) {
+			if (format == SNDRV_PCM_FORMAT_S16_LE)
+				transfer = MXC_DMA_SSI1_16BIT_TX1;
+			else if (format == SNDRV_PCM_FORMAT_S24_LE)
+				transfer = MXC_DMA_SSI1_24BIT_TX1;
+			else if (format == SNDRV_PCM_FORMAT_S20_3LE)
+				transfer = MXC_DMA_SSI1_24BIT_TX1;
+		} else {
+			if (format == SNDRV_PCM_FORMAT_S16_LE)
+				transfer = MXC_DMA_SSI1_16BIT_RX1;
+			else if (format == SNDRV_PCM_FORMAT_S24_LE)
+				transfer = MXC_DMA_SSI1_24BIT_RX1;
+			else if (format == SNDRV_PCM_FORMAT_S20_3LE)
+				transfer = MXC_DMA_SSI1_24BIT_RX1;
+		}
+	} else if (dai_port == IMX_DAI_SSI2) {
+		if (stream_type == SNDRV_PCM_STREAM_PLAYBACK) {
+			if (format == SNDRV_PCM_FORMAT_S16_LE)
+				transfer = MXC_DMA_SSI2_16BIT_TX0;
+			else if (format == SNDRV_PCM_FORMAT_S24_LE)
+				transfer = MXC_DMA_SSI2_24BIT_TX0;
+			else if (format == SNDRV_PCM_FORMAT_S20_3LE)
+				transfer = MXC_DMA_SSI2_24BIT_TX0;
+		} else {
+			if (format == SNDRV_PCM_FORMAT_S16_LE)
+				transfer = MXC_DMA_SSI2_16BIT_RX0;
+			else if (format == SNDRV_PCM_FORMAT_S24_LE)
+				transfer = MXC_DMA_SSI2_24BIT_RX0;
+			else if (format == SNDRV_PCM_FORMAT_S20_3LE)
+				transfer = MXC_DMA_SSI2_24BIT_RX0;
+		}
+	} else if (dai_port == IMX_DAI_SSI3) {
+		if (stream_type == SNDRV_PCM_STREAM_PLAYBACK) {
+			if (format == SNDRV_PCM_FORMAT_S16_LE)
+				transfer = MXC_DMA_SSI2_16BIT_TX1;
+			else if (format == SNDRV_PCM_FORMAT_S24_LE)
+				transfer = MXC_DMA_SSI2_24BIT_TX1;
+			else if (format == SNDRV_PCM_FORMAT_S20_3LE)
+				transfer = MXC_DMA_SSI2_24BIT_TX1;
+		} else {
+			if (format == SNDRV_PCM_FORMAT_S16_LE)
+				transfer = MXC_DMA_SSI2_16BIT_RX1;
+			else if (format == SNDRV_PCM_FORMAT_S24_LE)
+				transfer = MXC_DMA_SSI2_24BIT_RX1;
+			else if (format == SNDRV_PCM_FORMAT_S20_3LE)
+				transfer = MXC_DMA_SSI2_24BIT_RX1;
+		}
+	} else if ((dai_port & IMX_DAI_ESAI_TX)
+		   || (dai_port & IMX_DAI_ESAI_RX)) {
+		if (stream_type == SNDRV_PCM_STREAM_PLAYBACK) {
+			if (format == SNDRV_PCM_FORMAT_S16_LE)
+				transfer = MXC_DMA_ESAI_16BIT_TX;
+			else if (format == SNDRV_PCM_FORMAT_S24_LE)
+				transfer = MXC_DMA_ESAI_24BIT_TX;
+			else if (format == SNDRV_PCM_FORMAT_S20_3LE)
+				transfer = MXC_DMA_ESAI_24BIT_TX;
+		} else {
+			if (format == SNDRV_PCM_FORMAT_S16_LE)
+				transfer = MXC_DMA_ESAI_16BIT_RX;
+			else if (format == SNDRV_PCM_FORMAT_S24_LE)
+				transfer = MXC_DMA_ESAI_24BIT_RX;
+			else if (format == SNDRV_PCM_FORMAT_S20_3LE)
+				transfer = MXC_DMA_ESAI_24BIT_RX;
+		}
+	}
+
+	return transfer;
+}
+
+static int dma_new_period(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct mxc_runtime_data *prtd = runtime->private_data;
+	unsigned int dma_size = frames_to_bytes(runtime, runtime->period_size);
+	unsigned int offset = dma_size * prtd->period;
+	int ret = 0;
+	mxc_dma_requestbuf_t sdma_request;
+
+	if (!prtd->active)
+		return 0;
+
+	memset(&sdma_request, 0, sizeof(mxc_dma_requestbuf_t));
+
+	dbg("period pos  ALSA %x DMA %x\n", runtime->periods, prtd->period);
+	dbg("period size ALSA %x DMA %x Offset %x dmasize %x\n",
+	    (unsigned int)runtime->period_size, runtime->dma_bytes,
+	    offset, dma_size);
+	dbg("DMA addr %x\n", runtime->dma_addr + offset);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		sdma_request.src_addr =
+		    (dma_addr_t) (runtime->dma_addr + offset);
+	else
+		sdma_request.dst_addr =
+		    (dma_addr_t) (runtime->dma_addr + offset);
+
+	sdma_request.num_of_bytes = dma_size;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		mxc_dma_config(prtd->dma_wchannel, &sdma_request, 1,
+			       MXC_DMA_MODE_WRITE);
+		ret = mxc_dma_enable(prtd->dma_wchannel);
+	} else {
+
+		mxc_dma_config(prtd->dma_wchannel, &sdma_request, 1,
+			       MXC_DMA_MODE_READ);
+		ret = mxc_dma_enable(prtd->dma_wchannel);
+	}
+	prtd->dma_active = 1;
+	prtd->period++;
+	prtd->period %= runtime->periods;
+
+	return ret;
+}
+
+static void audio_dma_irq(void *data)
+{
+	struct snd_pcm_substream *substream = (struct snd_pcm_substream *)data;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct mxc_runtime_data *prtd = runtime->private_data;
+
+	prtd->dma_active = 0;
+	prtd->periods++;
+	prtd->periods %= runtime->periods;
+
+	dbg("irq per %d offset %x\n", prtd->periods,
+	    frames_to_bytes(runtime, runtime->period_size) * prtd->periods);
+
+	if (prtd->active)
+		snd_pcm_period_elapsed(substream);
+	dma_new_period(substream);
+}
+
+static int imx_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct mxc_runtime_data *prtd = runtime->private_data;
+	int ret = 0, channel = 0;
+
+	if (prtd->dma_alloc) {
+		mxc_dma_free(prtd->dma_wchannel);
+		prtd->dma_alloc = 0;
+	}
+
+	/* only allocate the DMA chn once */
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+
+		channel = mxc_dma_request(prtd->dma_ch, "ALSA TX SDMA");
+		if (channel < 0) {
+			pr_err("imx-pcm: error requesting \
+					a write dma channel\n");
+			return channel;
+		}
+		ret = mxc_dma_callback_set(channel, (mxc_dma_callback_t)
+					   audio_dma_irq, (void *)substream);
+
+	} else {
+		channel = mxc_dma_request(prtd->dma_ch, "ALSA RX SDMA");
+		if (channel < 0) {
+			pr_err("imx-pcm: error requesting \
+				a read dma channel\n");
+			return channel;
+		}
+		ret = mxc_dma_callback_set(channel, (mxc_dma_callback_t)
+					   audio_dma_irq, (void *)substream);
+	}
+	prtd->dma_wchannel = channel;
+	prtd->dma_alloc = 1;
+
+	prtd->period = 0;
+	prtd->periods = 0;
+	return 0;
+}
+
+static int imx_pcm_hw_params(struct snd_pcm_substream *substream,
+			     struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct mxc_runtime_data *prtd = runtime->private_data;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+
+	prtd->dma_ch = imx_get_sdma_transfer(params_format(params),
+					     rtd->dai->cpu_dai->id,
+					     substream->stream);
+
+	if (prtd->dma_ch < 0) {
+		printk(KERN_ERR "imx-pcm: invaild sdma transfer type");
+		return -1;
+	}
+
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+
+	return 0;
+}
+
+static int imx_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct mxc_runtime_data *prtd = runtime->private_data;
+
+	if (prtd->dma_wchannel) {
+		mxc_dma_free(prtd->dma_wchannel);
+		prtd->dma_wchannel = 0;
+		prtd->dma_alloc = 0;
+	}
+
+	return 0;
+}
+
+static int imx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct mxc_runtime_data *prtd = substream->runtime->private_data;
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		prtd->dma_active = 0;
+		prtd->active = 1;
+		ret = dma_new_period(substream);
+		ret = dma_new_period(substream);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		prtd->active = 0;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static snd_pcm_uframes_t imx_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct mxc_runtime_data *prtd = runtime->private_data;
+	unsigned int offset = 0;
+
+	offset = (runtime->period_size * (prtd->periods));
+	if (offset >= runtime->buffer_size)
+		offset = 0;
+	dbg("pointer offset %x\n", offset);
+
+	return offset;
+}
+
+static int imx_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct mxc_runtime_data *prtd;
+	int ret;
+
+	snd_soc_set_runtime_hwparams(substream, &imx_pcm_hardware);
+
+	ret = snd_pcm_hw_constraint_integer(runtime,
+					    SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0)
+		return ret;
+
+	prtd = kzalloc(sizeof(struct mxc_runtime_data), GFP_KERNEL);
+	if (prtd == NULL)
+		return -ENOMEM;
+
+	runtime->private_data = prtd;
+	return 0;
+}
+
+static int imx_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct mxc_runtime_data *prtd = runtime->private_data;
+
+	kfree(prtd);
+	return 0;
+}
+
+static int
+imx_pcm_mmap(struct snd_pcm_substream *substream, struct vm_area_struct *vma)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_dai *cpu_dai = socdev->machine->dai_link->cpu_dai;
+	struct mxc_audio_platform_data *dev_data = cpu_dai->private_data;
+	int ext_ram = 0;
+	int ret = 0;
+
+	dbg("+imx_pcm_mmap:"
+	    "UseIram=%d dma_addr=%x dma_area=%x dma_bytes=%d\n",
+	    UseIram, (unsigned int)runtime->dma_addr,
+	    runtime->dma_area, runtime->dma_bytes);
+
+	if (dev_data)
+		ext_ram = dev_data->ext_ram;
+
+	if ((substream->stream == SNDRV_PCM_STREAM_CAPTURE) || ext_ram
+	    || !UseIram) {
+		ret = dma_mmap_writecombine(substream->pcm->card->dev, vma,
+					    runtime->dma_area,
+					    runtime->dma_addr,
+					    runtime->dma_bytes);
+		return ret;
+	} else
+		return imx_iram_audio_playback_mmap(substream, vma);
+}
+
+struct snd_pcm_ops imx_pcm_ops = {
+	.open = imx_pcm_open,
+	.close = imx_pcm_close,
+	.ioctl = snd_pcm_lib_ioctl,
+	.hw_params = imx_pcm_hw_params,
+	.hw_free = imx_pcm_hw_free,
+	.prepare = imx_pcm_prepare,
+	.trigger = imx_pcm_trigger,
+	.pointer = imx_pcm_pointer,
+	.mmap = imx_pcm_mmap,
+};
+
+static int imx_pcm_preallocate_dma_buffer(struct snd_pcm *pcm, int stream)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *buf = &substream->dma_buffer;
+	struct snd_soc_pcm_runtime *rtd = pcm->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_dai *cpu_dai = socdev->machine->dai_link->cpu_dai;
+	struct mxc_audio_platform_data *dev_data = cpu_dai->private_data;
+	int ext_ram = 0;
+	size_t size = imx_pcm_hardware.buffer_bytes_max;
+
+	if (dev_data)
+		ext_ram = dev_data->ext_ram;
+
+	buf->dev.type = SNDRV_DMA_TYPE_DEV;
+	buf->dev.dev = pcm->card->dev;
+	buf->private_data = NULL;
+
+	if ((stream == SNDRV_PCM_STREAM_CAPTURE) || ext_ram || !UseIram)
+		buf->area = dma_alloc_writecombine(pcm->card->dev, size,
+						   &buf->addr, GFP_KERNEL);
+	else
+		buf->area = imx_iram_init(&buf->addr, size);
+
+	if (!buf->area)
+		return -ENOMEM;
+	buf->bytes = size;
+	printk(KERN_INFO "DMA Sound Buffers Allocated:"
+	       "UseIram=%d buf->addr=%x buf->area=%p size=%d\n",
+	       UseIram, buf->addr, buf->area, size);
+	return 0;
+}
+
+static void imx_pcm_free_dma_buffers(struct snd_pcm *pcm)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *buf;
+	struct snd_soc_pcm_runtime *rtd = pcm->private_data;
+	struct snd_soc_device *socdev = rtd->socdev;
+	struct snd_soc_dai *cpu_dai = socdev->machine->dai_link->cpu_dai;
+	struct mxc_audio_platform_data *dev_data = cpu_dai->private_data;
+	int ext_ram = 0;
+	int stream;
+
+	if (dev_data)
+		ext_ram = dev_data->ext_ram;
+
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (!substream)
+			continue;
+
+		buf = &substream->dma_buffer;
+		if (!buf->area)
+			continue;
+
+		if ((stream == SNDRV_PCM_STREAM_CAPTURE) || ext_ram || !UseIram)
+			dma_free_writecombine(pcm->card->dev, buf->bytes,
+					      buf->area, buf->addr);
+		else
+			imx_iram_free();
+		buf->area = NULL;
+	}
+}
+
+static u64 imx_pcm_dmamask = 0xffffffff;
+
+static int imx_pcm_new(struct snd_card *card, struct snd_soc_dai *dai,
+		       struct snd_pcm *pcm)
+{
+	int ret = 0;
+
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &imx_pcm_dmamask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = 0xffffffff;
+
+	if (dai->playback.channels_min) {
+		ret = imx_pcm_preallocate_dma_buffer(pcm,
+						     SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			goto out;
+	}
+
+	if (dai->capture.channels_min) {
+		ret = imx_pcm_preallocate_dma_buffer(pcm,
+						     SNDRV_PCM_STREAM_CAPTURE);
+		if (ret)
+			goto out;
+	}
+out:
+	return ret;
+}
+
+struct snd_soc_platform imx_soc_platform = {
+	.name = "imx-audio",
+	.pcm_ops = &imx_pcm_ops,
+	.pcm_new = imx_pcm_new,
+	.pcm_free = imx_pcm_free_dma_buffers,
+};
+EXPORT_SYMBOL_GPL(imx_soc_platform);
+
+MODULE_AUTHOR("Liam Girdwood");
+MODULE_DESCRIPTION("Freescale i.MX3x PCM DMA module");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/imx/imx-pcm.h b/sound/soc/imx/imx-pcm.h
new file mode 100644
index 0000000..3c33344
--- /dev/null
+++ b/sound/soc/imx/imx-pcm.h
@@ -0,0 +1,70 @@
+/*
+ * imx-pcm.h :- ASoC platform header for Freescale i.MX
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _MXC_PCM_H
+#define _MXC_PCM_H
+
+#include <mach/dma.h>
+
+/* AUDMUX regs definition  */
+#define AUDMUX_IO_BASE_ADDR	IO_ADDRESS(AUDMUX_BASE_ADDR)
+
+#define DAM_PTCR1	((AUDMUX_IO_BASE_ADDR) + 0x00)
+#define DAM_PDCR1	((AUDMUX_IO_BASE_ADDR) + 0x04)
+#define DAM_PTCR2	((AUDMUX_IO_BASE_ADDR) + 0x08)
+#define DAM_PDCR2	((AUDMUX_IO_BASE_ADDR) + 0x0C)
+#define DAM_PTCR3	((AUDMUX_IO_BASE_ADDR) + 0x10)
+#define DAM_PDCR3	((AUDMUX_IO_BASE_ADDR) + 0x14)
+#define DAM_PTCR4	((AUDMUX_IO_BASE_ADDR) + 0x18)
+#define DAM_PDCR4	((AUDMUX_IO_BASE_ADDR) + 0x1C)
+#define DAM_PTCR5	((AUDMUX_IO_BASE_ADDR) + 0x20)
+#define DAM_PDCR5	((AUDMUX_IO_BASE_ADDR) + 0x24)
+#define DAM_PTCR6	((AUDMUX_IO_BASE_ADDR) + 0x28)
+#define DAM_PDCR6	((AUDMUX_IO_BASE_ADDR) + 0x2C)
+#define DAM_PTCR7	((AUDMUX_IO_BASE_ADDR) + 0x30)
+#define DAM_PDCR7	((AUDMUX_IO_BASE_ADDR) + 0x34)
+#define DAM_CNMCR	((AUDMUX_IO_BASE_ADDR) + 0x38)
+#define DAM_PTCR(a)	((AUDMUX_IO_BASE_ADDR) + (a-1)*8)
+#define DAM_PDCR(a)	((AUDMUX_IO_BASE_ADDR) + 4 + (a-1)*8)
+
+#define AUDMUX_PTCR_TFSDIR		(1 << 31)
+#define AUDMUX_PTCR_TFSSEL(x, y) \
+	((x << 30) | (((y - 1) & 0x7) << 27))
+#define AUDMUX_PTCR_TCLKDIR		(1 << 26)
+#define AUDMUX_PTCR_TCSEL(x, y)	\
+	((x << 25) | (((y - 1) & 0x7) << 22))
+#define AUDMUX_PTCR_RFSDIR		(1 << 21)
+#define AUDMUX_PTCR_RFSSEL(x, y) \
+	((x << 20) | (((y - 1) & 0x7) << 17))
+#define AUDMUX_PTCR_RCLKDIR		(1 << 16)
+#define AUDMUX_PTCR_RCSEL(x, y)	\
+	((x << 15) | (((y - 1) & 0x7) << 12))
+#define AUDMUX_PTCR_SYN		(1 << 11)
+
+#define AUDMUX_FROM_TXFS	0
+#define AUDMUX_FROM_RXFS	1
+
+#define AUDMUX_PDCR_RXDSEL(x)	(((x - 1) & 0x7) << 13)
+#define AUDMUX_PDCR_TXDXEN		(1 << 12)
+#define AUDMUX_PDCR_MODE(x)		(((x) & 0x3) << 8)
+#define AUDMUX_PDCR_INNMASK(x)	(((x) & 0xff) << 0)
+
+#define AUDMUX_CNMCR_CEN		(1 << 18)
+#define AUDMUX_CNMCR_FSPOL		(1 << 17)
+#define AUDMUX_CNMCR_CLKPOL		(1 << 16)
+#define AUDMUX_CNMCR_CNTHI(x)	(((x) & 0xff) << 8)
+#define AUDMUX_CNMCR_CNTLOW(x)	(((x) & 0xff) << 0)
+
+struct mxc_pcm_dma_params {
+	char *name;		/* stream identifier */
+	dma_channel_params params;
+};
+
+extern struct snd_soc_platform imx_soc_platform;
+
+#endif
diff --git a/sound/soc/imx/imx-ssi.c b/sound/soc/imx/imx-ssi.c
new file mode 100644
index 0000000..14f5b8f
--- /dev/null
+++ b/sound/soc/imx/imx-ssi.c
@@ -0,0 +1,780 @@
+/*
+ * imx-ssi.c  --  SSI driver for Freescale IMX
+ *
+ * Copyright 2006 Wolfson Microelectronics PLC.
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
+ *
+ * Based on mxc-alsa-mc13783 (C) 2006-2008 Freescale Semiconductor, Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  Revision history
+ *    29th Aug 2006   Initial version.
+ *
+ * TODO:
+ *   Need to rework SSI register defs when new defs go into mainline.
+ *   Add support for TDM and FIFO 1.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <mach/dma.h>
+#include <mach/clock.h>
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+
+#include "imx-ssi.h"
+#include "imx-pcm.h"
+
+/* debug */
+#define IMX_SSI_DEBUG 0
+#if IMX_SSI_DEBUG
+#define dbg(format, arg...) printk(format, ## arg)
+#else
+#define dbg(format, arg...)
+#endif
+
+#define IMX_SSI_DUMP 0
+#if IMX_SSI_DUMP
+#define SSI_DUMP() \
+	do { \
+		printk(KERN_INFO "dump @ %s\n", __func__); \
+		printk(KERN_INFO "scr %x\t, %x\n", \
+		       __raw_readl(SSI1_SCR), __raw_readl(SSI2_SCR));	\
+		printk(KERN_INFO "sisr %x\t, %x\n", \
+		       __raw_readl(SSI1_SISR), __raw_readl(SSI2_SISR));	\
+		printk(KERN_INFO "stcr %x\t, %x\n", \
+		       __raw_readl(SSI1_STCR), __raw_readl(SSI2_STCR)); \
+		printk(KERN_INFO "srcr %x\t, %x\n", \
+		       __raw_readl(SSI1_SRCR), __raw_readl(SSI2_SRCR)); \
+		printk(KERN_INFO "stccr %x\t, %x\n", \
+		       __raw_readl(SSI1_STCCR), __raw_readl(SSI2_STCCR)); \
+		printk(KERN_INFO "srccr %x\t, %x\n", \
+		       __raw_readl(SSI1_SRCCR), __raw_readl(SSI2_SRCCR)); \
+		printk(KERN_INFO "sfcsr %x\t, %x\n", \
+		       __raw_readl(SSI1_SFCSR), __raw_readl(SSI2_SFCSR)); \
+		printk(KERN_INFO "stmsk %x\t, %x\n", \
+		       __raw_readl(SSI1_STMSK), __raw_readl(SSI2_STMSK)); \
+		printk(KERN_INFO "srmsk %x\t, %x\n", \
+		       __raw_readl(SSI1_SRMSK), __raw_readl(SSI2_SRMSK)); \
+		printk(KERN_INFO "sier %x\t, %x\n", \
+		       __raw_readl(SSI1_SIER), __raw_readl(SSI2_SIER)); \
+	} while (0);
+#else
+#define SSI_DUMP()
+#endif
+
+#define SSI1_PORT	0
+#define SSI2_PORT	1
+
+static int ssi_active[2] = { 0, 0 };
+
+/*
+ * SSI system clock configuration.
+ * Should only be called when port is inactive (i.e. SSIEN = 0).
+ */
+static int imx_ssi_set_dai_sysclk(struct snd_soc_dai *cpu_dai,
+				  int clk_id, unsigned int freq, int dir)
+{
+	u32 scr;
+
+	if (cpu_dai->id == IMX_DAI_SSI0 || cpu_dai->id == IMX_DAI_SSI1)
+		scr = __raw_readl(SSI1_SCR);
+	else
+		scr = __raw_readl(SSI2_SCR);
+
+	if (scr & SSI_SCR_SSIEN)
+		return 0;
+
+	switch (clk_id) {
+	case IMX_SSP_SYS_CLK:
+		if (dir == SND_SOC_CLOCK_OUT)
+			scr |= SSI_SCR_SYS_CLK_EN;
+		else
+			scr &= ~SSI_SCR_SYS_CLK_EN;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (cpu_dai->id == IMX_DAI_SSI0 || cpu_dai->id == IMX_DAI_SSI1)
+		__raw_writel(scr, SSI1_SCR);
+	else
+		__raw_writel(scr, SSI2_SCR);
+
+	return 0;
+}
+
+/*
+ * SSI Clock dividers
+ * Should only be called when port is inactive (i.e. SSIEN = 0).
+ */
+static int imx_ssi_set_dai_clkdiv(struct snd_soc_dai *cpu_dai,
+				  int div_id, int div)
+{
+	u32 stccr, srccr;
+
+	if (cpu_dai->id == IMX_DAI_SSI0 || cpu_dai->id == IMX_DAI_SSI1) {
+		if (__raw_readl(SSI1_SCR) & SSI_SCR_SSIEN)
+			return 0;
+
+		srccr = __raw_readl(SSI1_SRCCR);
+		stccr = __raw_readl(SSI1_STCCR);
+	} else {
+		if (__raw_readl(SSI2_SCR) & SSI_SCR_SSIEN)
+			return 0;
+
+		srccr = __raw_readl(SSI2_SRCCR);
+		stccr = __raw_readl(SSI2_STCCR);
+	}
+
+	switch (div_id) {
+	case IMX_SSI_TX_DIV_2:
+		stccr &= ~SSI_STCCR_DIV2;
+		stccr |= div;
+		break;
+	case IMX_SSI_TX_DIV_PSR:
+		stccr &= ~SSI_STCCR_PSR;
+		stccr |= div;
+		break;
+	case IMX_SSI_TX_DIV_PM:
+		stccr &= ~0xff;
+		stccr |= SSI_STCCR_PM(div);
+		break;
+	case IMX_SSI_RX_DIV_2:
+		stccr &= ~SSI_STCCR_DIV2;
+		stccr |= div;
+		break;
+	case IMX_SSI_RX_DIV_PSR:
+		stccr &= ~SSI_STCCR_PSR;
+		stccr |= div;
+		break;
+	case IMX_SSI_RX_DIV_PM:
+		stccr &= ~0xff;
+		stccr |= SSI_STCCR_PM(div);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (cpu_dai->id == IMX_DAI_SSI0 || cpu_dai->id == IMX_DAI_SSI1) {
+		__raw_writel(stccr, SSI1_STCCR);
+		__raw_writel(srccr, SSI1_SRCCR);
+	} else {
+		__raw_writel(stccr, SSI2_STCCR);
+		__raw_writel(srccr, SSI2_SRCCR);
+	}
+	return 0;
+}
+
+/*
+ * SSI Network Mode or TDM slots configuration.
+ * Should only be called when port is inactive (i.e. SSIEN = 0).
+ */
+static int imx_ssi_set_dai_tdm_slot(struct snd_soc_dai *cpu_dai,
+				    unsigned int mask, int slots)
+{
+	u32 stmsk, srmsk, stccr;
+
+	if (cpu_dai->id == IMX_DAI_SSI0 || cpu_dai->id == IMX_DAI_SSI1) {
+		if (__raw_readl(SSI1_SCR) & SSI_SCR_SSIEN)
+			return 0;
+		stccr = __raw_readl(SSI1_STCCR);
+	} else {
+		if (__raw_readl(SSI2_SCR) & SSI_SCR_SSIEN)
+			return 0;
+		stccr = __raw_readl(SSI2_STCCR);
+	}
+
+	stmsk = srmsk = mask;
+	stccr &= ~SSI_STCCR_DC_MASK;
+	stccr |= SSI_STCCR_DC(slots - 1);
+
+	if (cpu_dai->id == IMX_DAI_SSI0 || cpu_dai->id == IMX_DAI_SSI1) {
+		__raw_writel(stmsk, SSI1_STMSK);
+		__raw_writel(srmsk, SSI1_SRMSK);
+		__raw_writel(stccr, SSI1_STCCR);
+		__raw_writel(stccr, SSI1_SRCCR);
+	} else {
+		__raw_writel(stmsk, SSI2_STMSK);
+		__raw_writel(srmsk, SSI2_SRMSK);
+		__raw_writel(stccr, SSI2_STCCR);
+		__raw_writel(stccr, SSI2_SRCCR);
+	}
+
+	return 0;
+}
+
+/*
+ * SSI DAI format configuration.
+ * Should only be called when port is inactive (i.e. SSIEN = 0).
+ * Note: We don't use the I2S modes but instead manually configure the
+ * SSI for I2S.
+ */
+static int imx_ssi_set_dai_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)
+{
+	u32 stcr = 0, srcr = 0, scr;
+
+	if (cpu_dai->id == IMX_DAI_SSI0 || cpu_dai->id == IMX_DAI_SSI1)
+		scr = __raw_readl(SSI1_SCR) & ~(SSI_SCR_SYN | SSI_SCR_NET);
+	else
+		scr = __raw_readl(SSI2_SCR) & ~(SSI_SCR_SYN | SSI_SCR_NET);
+
+	if (scr & SSI_SCR_SSIEN)
+		return 0;
+
+	/* DAI mode */
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		/* data on rising edge of bclk, frame low 1clk before data */
+		stcr |= SSI_STCR_TFSI | SSI_STCR_TEFS | SSI_STCR_TXBIT0;
+		srcr |= SSI_SRCR_RFSI | SSI_SRCR_REFS | SSI_SRCR_RXBIT0;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		/* data on rising edge of bclk, frame high with data */
+		stcr |= SSI_STCR_TXBIT0;
+		srcr |= SSI_SRCR_RXBIT0;
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		/* data on rising edge of bclk, frame high with data */
+		stcr |= SSI_STCR_TFSL;
+		srcr |= SSI_SRCR_RFSL;
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		/* data on rising edge of bclk, frame high 1clk before data */
+		stcr |= SSI_STCR_TFSL | SSI_STCR_TEFS;
+		srcr |= SSI_SRCR_RFSL | SSI_SRCR_REFS;
+		break;
+	}
+
+	/* DAI clock inversion */
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_IB_IF:
+		stcr &= ~(SSI_STCR_TSCKP | SSI_STCR_TFSI);
+		srcr &= ~(SSI_SRCR_RSCKP | SSI_SRCR_RFSI);
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		stcr |= SSI_STCR_TFSI;
+		stcr &= ~SSI_STCR_TSCKP;
+		srcr |= SSI_SRCR_RFSI;
+		srcr &= ~SSI_SRCR_RSCKP;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		stcr &= ~SSI_STCR_TFSI;
+		stcr |= SSI_STCR_TSCKP;
+		srcr &= ~SSI_SRCR_RFSI;
+		srcr |= SSI_SRCR_RSCKP;
+		break;
+	case SND_SOC_DAIFMT_NB_NF:
+		stcr |= SSI_STCR_TFSI | SSI_STCR_TSCKP;
+		srcr |= SSI_SRCR_RFSI | SSI_SRCR_RSCKP;
+		break;
+	}
+
+	/* DAI clock master masks */
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		stcr |= SSI_STCR_TFDIR | SSI_STCR_TXDIR;
+		if (((fmt & SND_SOC_DAIFMT_FORMAT_MASK) == SND_SOC_DAIFMT_I2S)
+		    && (fmt & SND_SOC_DAIFMT_TDM)) {
+			scr &= ~SSI_SCR_I2S_MODE_MASK;
+			scr |= SSI_SCR_I2S_MODE_MSTR;
+		}
+		break;
+	case SND_SOC_DAIFMT_CBM_CFS:
+		stcr |= SSI_STCR_TFDIR;
+		srcr |= SSI_SRCR_RFDIR;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFM:
+		stcr |= SSI_STCR_TXDIR;
+		srcr |= SSI_SRCR_RXDIR;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFM:
+		if (((fmt & SND_SOC_DAIFMT_FORMAT_MASK) == SND_SOC_DAIFMT_I2S)
+		    && (fmt & SND_SOC_DAIFMT_TDM)) {
+			scr &= ~SSI_SCR_I2S_MODE_MASK;
+			scr |= SSI_SCR_I2S_MODE_SLAVE;
+		}
+		break;
+	}
+
+	/* sync */
+	if (!(fmt & SND_SOC_DAIFMT_ASYNC))
+		scr |= SSI_SCR_SYN;
+
+	/* tdm - only for stereo atm */
+	if (fmt & SND_SOC_DAIFMT_TDM)
+		scr |= SSI_SCR_NET;
+
+	if (cpu_dai->id == IMX_DAI_SSI0 || cpu_dai->id == IMX_DAI_SSI1) {
+		__raw_writel(stcr, SSI1_STCR);
+		__raw_writel(srcr, SSI1_SRCR);
+		__raw_writel(scr, SSI1_SCR);
+	} else {
+		__raw_writel(stcr, SSI2_STCR);
+		__raw_writel(srcr, SSI2_SRCR);
+		__raw_writel(scr, SSI2_SCR);
+	}
+	SSI_DUMP();
+	return 0;
+}
+
+static struct clk *ssi1_clk;
+static struct clk *ssi2_clk;
+
+static int imx_ssi_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
+
+	/* we cant really change any SSI values after SSI is enabled
+	 * need to fix in software for max flexibility - lrg */
+	if (cpu_dai->playback.active || cpu_dai->capture.active)
+		return 0;
+
+	/* reset the SSI port - Sect 45.4.4 */
+	if (cpu_dai->id == IMX_DAI_SSI0 || cpu_dai->id == IMX_DAI_SSI1) {
+
+		if (ssi_active[SSI1_PORT]++)
+			return 0;
+
+		__raw_writel(0, SSI1_SCR);
+		ssi1_clk = clk_get(NULL, "ssi_clk.0");
+		clk_enable(ssi1_clk);
+
+		/* BIG FAT WARNING
+		 * SDMA FIFO watermark must == SSI FIFO watermark for
+		 * best results.
+		 */
+		__raw_writel((SSI_SFCSR_RFWM1(SSI_RXFIFO_WATERMARK) |
+			      SSI_SFCSR_RFWM0(SSI_RXFIFO_WATERMARK) |
+			      SSI_SFCSR_TFWM1(SSI_TXFIFO_WATERMARK) |
+			      SSI_SFCSR_TFWM0(SSI_TXFIFO_WATERMARK)),
+			     SSI1_SFCSR);
+		__raw_writel(0, SSI1_SIER);
+	} else {
+
+		if (ssi_active[SSI2_PORT]++)
+			return 0;
+
+		__raw_writel(0, SSI2_SCR);
+		ssi2_clk = clk_get(NULL, "ssi_clk.1");
+		clk_enable(ssi2_clk);
+		/* above warning applies here too */
+		__raw_writel((SSI_SFCSR_RFWM1(SSI_RXFIFO_WATERMARK) |
+			      SSI_SFCSR_RFWM0(SSI_RXFIFO_WATERMARK) |
+			      SSI_SFCSR_TFWM1(SSI_TXFIFO_WATERMARK) |
+			      SSI_SFCSR_TFWM0(SSI_TXFIFO_WATERMARK)),
+			     SSI2_SFCSR);
+		__raw_writel(0, SSI2_SIER);
+	}
+
+	SSI_DUMP();
+	return 0;
+}
+
+static int imx_ssi_hw_tx_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
+	u32 stccr, stcr, sier;
+
+	if (cpu_dai->id == IMX_DAI_SSI0 || cpu_dai->id == IMX_DAI_SSI1) {
+		stccr = __raw_readl(SSI1_STCCR) & ~SSI_STCCR_WL_MASK;
+		stcr = __raw_readl(SSI1_STCR);
+		sier = __raw_readl(SSI1_SIER);
+	} else {
+		stccr = __raw_readl(SSI2_STCCR) & ~SSI_STCCR_WL_MASK;
+		stcr = __raw_readl(SSI2_STCR);
+		sier = __raw_readl(SSI2_SIER);
+	}
+
+	/* DAI data (word) size */
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		stccr |= SSI_STCCR_WL(16);
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		stccr |= SSI_STCCR_WL(20);
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		stccr |= SSI_STCCR_WL(24);
+		break;
+	}
+
+	/* enable interrupts */
+	if (cpu_dai->id == IMX_DAI_SSI0 || cpu_dai->id == IMX_DAI_SSI2)
+		stcr |= SSI_STCR_TFEN0;
+	else
+		stcr |= SSI_STCR_TFEN1;
+	sier |= SSI_SIER_TDMAE | SSI_SIER_TIE | SSI_SIER_TUE0_EN;
+
+	if (cpu_dai->id == IMX_DAI_SSI0 || cpu_dai->id == IMX_DAI_SSI1) {
+		__raw_writel(stcr, SSI1_STCR);
+		__raw_writel(stccr, SSI1_STCCR);
+		__raw_writel(sier, SSI1_SIER);
+	} else {
+		__raw_writel(stcr, SSI2_STCR);
+		__raw_writel(stccr, SSI2_STCCR);
+		__raw_writel(sier, SSI2_SIER);
+	}
+
+	return 0;
+}
+
+static int imx_ssi_hw_rx_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
+	u32 srccr, srcr, sier;
+	bool sync_mode;
+
+	if (cpu_dai->id == IMX_DAI_SSI0 || cpu_dai->id == IMX_DAI_SSI1) {
+		sync_mode =
+		    (__raw_readl(SSI1_SCR) & SSI_SCR_SYN) ? true : false;
+		srccr =
+		    sync_mode ? __raw_readl(SSI1_STCCR) :
+		    __raw_readl(SSI1_SRCCR);
+		srcr = __raw_readl(SSI1_SRCR);
+		sier = __raw_readl(SSI1_SIER);
+	} else {
+		sync_mode =
+		    (__raw_readl(SSI2_SCR) & SSI_SCR_SYN) ? true : false;
+		srccr =
+		    sync_mode ? __raw_readl(SSI2_STCCR) :
+		    __raw_readl(SSI2_SRCCR);
+		srcr = __raw_readl(SSI2_SRCR);
+		sier = __raw_readl(SSI2_SIER);
+	}
+	srccr &= ~SSI_SRCCR_WL_MASK;
+
+	/* DAI data (word) size */
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		srccr |= SSI_SRCCR_WL(16);
+		break;
+	case SNDRV_PCM_FORMAT_S20_3LE:
+		srccr |= SSI_SRCCR_WL(20);
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		srccr |= SSI_SRCCR_WL(24);
+		break;
+	}
+
+	/* enable interrupts */
+	if (cpu_dai->id == IMX_DAI_SSI0 || cpu_dai->id == IMX_DAI_SSI2)
+		srcr |= SSI_SRCR_RFEN0;
+	else
+		srcr |= SSI_SRCR_RFEN1;
+	sier |= SSI_SIER_RDMAE | SSI_SIER_RIE | SSI_SIER_ROE0_EN;
+
+	if (cpu_dai->id == IMX_DAI_SSI0 || cpu_dai->id == IMX_DAI_SSI1) {
+		__raw_writel(srcr, SSI1_SRCR);
+		if (sync_mode)
+			__raw_writel(srccr, SSI1_STCCR);
+		else
+			__raw_writel(srccr, SSI1_SRCCR);
+		__raw_writel(sier, SSI1_SIER);
+	} else {
+		__raw_writel(srcr, SSI2_SRCR);
+		if (sync_mode)
+			__raw_writel(srccr, SSI2_STCCR);
+		else
+			__raw_writel(srccr, SSI2_SRCCR);
+		__raw_writel(sier, SSI2_SIER);
+	}
+	return 0;
+}
+
+/*
+ * Should only be called when port is inactive (i.e. SSIEN = 0),
+ * although can be called multiple times by upper layers.
+ */
+static int imx_ssi_hw_params(struct snd_pcm_substream *substream,
+			     struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
+	int id;
+
+	id = cpu_dai->id;
+
+	/* Tx/Rx config */
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		/* cant change any parameters when SSI is running */
+		if (id == IMX_DAI_SSI0 || id == IMX_DAI_SSI1) {
+			if ((__raw_readl(SSI1_SCR) & SSI_SCR_SSIEN) &&
+			    (__raw_readl(SSI1_SCR) & SSI_SCR_TE))
+				return 0;
+		} else {
+			if ((__raw_readl(SSI2_SCR) & SSI_SCR_SSIEN) &&
+			    (__raw_readl(SSI2_SCR) & SSI_SCR_TE))
+				return 0;
+		}
+		return imx_ssi_hw_tx_params(substream, params);
+	} else {
+		/* cant change any parameters when SSI is running */
+		if (id == IMX_DAI_SSI0 || id == IMX_DAI_SSI1) {
+			if ((__raw_readl(SSI1_SCR) & SSI_SCR_SSIEN) &&
+			    (__raw_readl(SSI1_SCR) & SSI_SCR_RE))
+				return 0;
+		} else {
+			if ((__raw_readl(SSI2_SCR) & SSI_SCR_SSIEN) &&
+			    (__raw_readl(SSI2_SCR) & SSI_SCR_RE))
+				return 0;
+		}
+		return imx_ssi_hw_rx_params(substream, params);
+	}
+}
+
+static int imx_ssi_prepare(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
+	u32 scr;
+
+	/* enable the SSI port, note that no other port config
+	 * should happen after SSIEN is set */
+	if (cpu_dai->id == IMX_DAI_SSI0 || cpu_dai->id == IMX_DAI_SSI1) {
+		scr = __raw_readl(SSI1_SCR);
+		__raw_writel((scr | SSI_SCR_SSIEN), SSI1_SCR);
+	} else {
+		scr = __raw_readl(SSI2_SCR);
+		__raw_writel((scr | SSI_SCR_SSIEN), SSI2_SCR);
+	}
+	SSI_DUMP();
+	return 0;
+}
+
+static int imx_ssi_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
+	u32 scr;
+
+	if (cpu_dai->id == IMX_DAI_SSI0 || cpu_dai->id == IMX_DAI_SSI1)
+		scr = __raw_readl(SSI1_SCR);
+	else
+		scr = __raw_readl(SSI2_SCR);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			scr |= SSI_SCR_TE;
+		else
+			scr |= SSI_SCR_RE;
+		break;
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			scr &= ~SSI_SCR_TE;
+		else
+			scr &= ~SSI_SCR_RE;
+		break;
+	default:
+		return -EINVAL;
+	}
+	if (cpu_dai->id == IMX_DAI_SSI0 || cpu_dai->id == IMX_DAI_SSI1)
+		__raw_writel(scr, SSI1_SCR);
+	else
+		__raw_writel(scr, SSI2_SCR);
+
+	SSI_DUMP();
+	return 0;
+}
+
+static void imx_ssi_shutdown(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
+	int id;
+
+	id = cpu_dai->id;
+
+	/* shutdown SSI if neither Tx or Rx is active */
+	if (cpu_dai->playback.active || cpu_dai->capture.active)
+		return;
+
+	if (id == IMX_DAI_SSI0 || id == IMX_DAI_SSI1) {
+
+		if (--ssi_active[SSI1_PORT] > 1)
+			return;
+
+		__raw_writel(0, SSI1_SCR);
+
+		clk_disable(ssi1_clk);
+		clk_put(ssi1_clk);
+
+	} else {
+		if (--ssi_active[SSI2_PORT])
+			return;
+		__raw_writel(0, SSI2_SCR);
+		clk_disable(ssi2_clk);
+		clk_put(ssi2_clk);
+	}
+}
+
+#ifdef CONFIG_PM
+static int imx_ssi_suspend(struct platform_device *dev, struct snd_soc_dai *dai)
+{
+	if (!dai->active)
+		return 0;
+
+	/* do we need to disable any clocks? */
+
+	return 0;
+}
+
+static int imx_ssi_resume(struct platform_device *dev, struct snd_soc_dai *dai)
+{
+	if (!dai->active)
+		return 0;
+
+	/* do we need to enable any clocks? */
+
+	return 0;
+}
+#else
+#define imx_ssi_suspend	NULL
+#define imx_ssi_resume	NULL
+#endif
+
+static int fifo_err_counter;
+
+static irqreturn_t ssi1_irq(int irq, void *dev_id)
+{
+	if (fifo_err_counter++ % 1000 == 0)
+		printk(KERN_ERR "ssi1_irq SISR %x SIER %x fifo_errs=%d\n",
+		       __raw_readl(SSI1_SISR), __raw_readl(SSI1_SIER),
+		       fifo_err_counter);
+	__raw_writel((SSI_SIER_TUE0_EN | SSI_SIER_ROE0_EN), SSI1_SISR);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t ssi2_irq(int irq, void *dev_id)
+{
+	if (fifo_err_counter++ % 1000 == 0)
+		printk(KERN_ERR "ssi2_irq SISR %x SIER %x fifo_errs=%d\n",
+		       __raw_readl(SSI2_SISR), __raw_readl(SSI2_SIER),
+		       fifo_err_counter);
+	__raw_writel((SSI_SIER_TUE0_EN | SSI_SIER_ROE0_EN), SSI2_SISR);
+	return IRQ_HANDLED;
+}
+
+static int imx_ssi_probe(struct platform_device *pdev, struct snd_soc_dai *dai)
+{
+	if (!strcmp(dai->name, "imx-ssi-1"))
+		dai->id = IMX_DAI_SSI0;
+	else if (!strcmp(dai->name, "imx-ssi-2"))
+		dai->id = IMX_DAI_SSI1;
+	else if (!strcmp(dai->name, "imx-ssi-3"))
+		dai->id = IMX_DAI_SSI2;
+	else if (!strcmp(dai->name, "imx-ssi-4"))
+		dai->id = IMX_DAI_SSI3;
+	else {
+		printk(KERN_ERR "%s: invalid device %s\n", __func__, dai->name);
+		return -ENODEV;
+	}
+
+	if ((!strcmp(dai->name, "imx-ssi-1")) ||
+	    (!strcmp(dai->name, "imx-ssi-2")))
+		if (request_irq(MXC_INT_SSI1, ssi1_irq, 0, "ssi1", dai)) {
+			printk(KERN_ERR "%s: failure requesting irq %s\n",
+			       __func__, "ssi1");
+			return -EBUSY;
+		}
+
+	if ((!strcmp(dai->name, "imx-ssi-3")) ||
+	    (!strcmp(dai->name, "imx-ssi-4")))
+		if (request_irq(MXC_INT_SSI2, ssi2_irq, 0, "ssi2", dai)) {
+			printk(KERN_ERR "%s: failure requesting irq %s\n",
+			       __func__, "ssi2");
+			return -EBUSY;
+		}
+
+	return 0;
+}
+
+static void imx_ssi_remove(struct platform_device *pdev,
+			   struct snd_soc_dai *dai)
+{
+	if ((!strcmp(dai->name, "imx-ssi-1")) ||
+	    (!strcmp(dai->name, "imx-ssi-2")))
+		free_irq(MXC_INT_SSI1, dai);
+
+	if ((!strcmp(dai->name, "imx-ssi-3")) ||
+	    (!strcmp(dai->name, "imx-ssi-4")))
+		free_irq(MXC_INT_SSI2, dai);
+}
+
+#define IMX_SSI_RATES \
+	(SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | \
+	SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 | \
+	SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+	SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200 | \
+	SNDRV_PCM_RATE_96000)
+
+#define IMX_SSI_FORMATS \
+	(SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
+	SNDRV_PCM_FMTBIT_S24_LE)
+
+struct snd_soc_dai imx_ssi_dai = {
+	.name = "imx-ssi",
+	.id = 0,
+	.type = SND_SOC_DAI_PCM,
+	.probe = imx_ssi_probe,
+	.suspend = imx_ssi_suspend,
+	.remove = imx_ssi_remove,
+	.resume = imx_ssi_resume,
+	.playback = {
+		     .channels_min = 1,
+		     .channels_max = 2,
+		     .rates = IMX_SSI_RATES,
+		     .formats = IMX_SSI_FORMATS,
+		     },
+	.capture = {
+		    .channels_min = 1,
+		    .channels_max = 2,
+		    .rates = IMX_SSI_RATES,
+		    .formats = IMX_SSI_FORMATS,
+		    },
+
+	.ops = {
+		.startup = imx_ssi_startup,
+		.shutdown = imx_ssi_shutdown,
+		.trigger = imx_ssi_trigger,
+		.prepare = imx_ssi_prepare,
+		.hw_params = imx_ssi_hw_params,
+		},
+
+	.dai_ops = {
+		    .set_sysclk = imx_ssi_set_dai_sysclk,
+		    .set_clkdiv = imx_ssi_set_dai_clkdiv,
+		    .set_fmt = imx_ssi_set_dai_fmt,
+		    .set_tdm_slot = imx_ssi_set_dai_tdm_slot,
+		    },
+};
+EXPORT_SYMBOL_GPL(imx_ssi_dai);
+
+MODULE_AUTHOR
+    ("Liam Girdwood, liam.girdwood@wolfsonmicro.com, www.wolfsonmicro.com");
+MODULE_DESCRIPTION("i.MX ASoC I2S driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/imx/imx-ssi.h b/sound/soc/imx/imx-ssi.h
new file mode 100644
index 0000000..ffb27e9
--- /dev/null
+++ b/sound/soc/imx/imx-ssi.h
@@ -0,0 +1,218 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _IMX_SSI_H
+#define _IMX_SSI_H
+
+#include <mach/hardware.h>
+
+/* SSI regs definition */
+#define SSI1_IO_BASE_ADDR	IO_ADDRESS(SSI1_BASE_ADDR)
+#define SSI2_IO_BASE_ADDR	IO_ADDRESS(SSI2_BASE_ADDR)
+
+#define SSI1_STX0   ((SSI1_IO_BASE_ADDR) + 0x00)
+#define SSI1_STX1   ((SSI1_IO_BASE_ADDR) + 0x04)
+#define SSI1_SRX0   ((SSI1_IO_BASE_ADDR) + 0x08)
+#define SSI1_SRX1   ((SSI1_IO_BASE_ADDR) + 0x0c)
+#define SSI1_SCR    ((SSI1_IO_BASE_ADDR) + 0x10)
+#define SSI1_SISR   ((SSI1_IO_BASE_ADDR) + 0x14)
+#define SSI1_SIER   ((SSI1_IO_BASE_ADDR) + 0x18)
+#define SSI1_STCR   ((SSI1_IO_BASE_ADDR) + 0x1c)
+#define SSI1_SRCR   ((SSI1_IO_BASE_ADDR) + 0x20)
+#define SSI1_STCCR  ((SSI1_IO_BASE_ADDR) + 0x24)
+#define SSI1_SRCCR  ((SSI1_IO_BASE_ADDR) + 0x28)
+#define SSI1_SFCSR  ((SSI1_IO_BASE_ADDR) + 0x2c)
+#define SSI1_STR    ((SSI1_IO_BASE_ADDR) + 0x30)
+#define SSI1_SOR    ((SSI1_IO_BASE_ADDR) + 0x34)
+#define SSI1_SACNT  ((SSI1_IO_BASE_ADDR) + 0x38)
+#define SSI1_SACADD ((SSI1_IO_BASE_ADDR) + 0x3c)
+#define SSI1_SACDAT ((SSI1_IO_BASE_ADDR) + 0x40)
+#define SSI1_SATAG  ((SSI1_IO_BASE_ADDR) + 0x44)
+#define SSI1_STMSK  ((SSI1_IO_BASE_ADDR) + 0x48)
+#define SSI1_SRMSK  ((SSI1_IO_BASE_ADDR) + 0x4c)
+
+#define SSI2_STX0   ((SSI2_IO_BASE_ADDR) + 0x00)
+#define SSI2_STX1   ((SSI2_IO_BASE_ADDR) + 0x04)
+#define SSI2_SRX0   ((SSI2_IO_BASE_ADDR) + 0x08)
+#define SSI2_SRX1   ((SSI2_IO_BASE_ADDR) + 0x0c)
+#define SSI2_SCR    ((SSI2_IO_BASE_ADDR) + 0x10)
+#define SSI2_SISR   ((SSI2_IO_BASE_ADDR) + 0x14)
+#define SSI2_SIER   ((SSI2_IO_BASE_ADDR) + 0x18)
+#define SSI2_STCR   ((SSI2_IO_BASE_ADDR) + 0x1c)
+#define SSI2_SRCR   ((SSI2_IO_BASE_ADDR) + 0x20)
+#define SSI2_STCCR  ((SSI2_IO_BASE_ADDR) + 0x24)
+#define SSI2_SRCCR  ((SSI2_IO_BASE_ADDR) + 0x28)
+#define SSI2_SFCSR  ((SSI2_IO_BASE_ADDR) + 0x2c)
+#define SSI2_STR    ((SSI2_IO_BASE_ADDR) + 0x30)
+#define SSI2_SOR    ((SSI2_IO_BASE_ADDR) + 0x34)
+#define SSI2_SACNT  ((SSI2_IO_BASE_ADDR) + 0x38)
+#define SSI2_SACADD ((SSI2_IO_BASE_ADDR) + 0x3c)
+#define SSI2_SACDAT ((SSI2_IO_BASE_ADDR) + 0x40)
+#define SSI2_SATAG  ((SSI2_IO_BASE_ADDR) + 0x44)
+#define SSI2_STMSK  ((SSI2_IO_BASE_ADDR) + 0x48)
+#define SSI2_SRMSK  ((SSI2_IO_BASE_ADDR) + 0x4c)
+
+#define SSI_SCR_CLK_IST        (1 << 9)
+#define SSI_SCR_TCH_EN         (1 << 8)
+#define SSI_SCR_SYS_CLK_EN     (1 << 7)
+#define SSI_SCR_I2S_MODE_NORM  (0 << 5)
+#define SSI_SCR_I2S_MODE_MSTR  (1 << 5)
+#define SSI_SCR_I2S_MODE_SLAVE (2 << 5)
+#define SSI_SCR_SYN            (1 << 4)
+#define SSI_SCR_NET            (1 << 3)
+#define SSI_SCR_RE             (1 << 2)
+#define SSI_SCR_TE             (1 << 1)
+#define SSI_SCR_SSIEN          (1 << 0)
+#define SSI_SCR_I2S_MODE_MASK  (3 << 5)
+
+#define SSI_SISR_CMDAU         (1 << 18)
+#define SSI_SISR_CMDDU         (1 << 17)
+#define SSI_SISR_RXT           (1 << 16)
+#define SSI_SISR_RDR1          (1 << 15)
+#define SSI_SISR_RDR0          (1 << 14)
+#define SSI_SISR_TDE1          (1 << 13)
+#define SSI_SISR_TDE0          (1 << 12)
+#define SSI_SISR_ROE1          (1 << 11)
+#define SSI_SISR_ROE0          (1 << 10)
+#define SSI_SISR_TUE1          (1 << 9)
+#define SSI_SISR_TUE0          (1 << 8)
+#define SSI_SISR_TFS           (1 << 7)
+#define SSI_SISR_RFS           (1 << 6)
+#define SSI_SISR_TLS           (1 << 5)
+#define SSI_SISR_RLS           (1 << 4)
+#define SSI_SISR_RFF1          (1 << 3)
+#define SSI_SISR_RFF0          (1 << 2)
+#define SSI_SISR_TFE1          (1 << 1)
+#define SSI_SISR_TFE0          (1 << 0)
+
+#define SSI_SIER_RDMAE         (1 << 22)
+#define SSI_SIER_RIE           (1 << 21)
+#define SSI_SIER_TDMAE         (1 << 20)
+#define SSI_SIER_TIE           (1 << 19)
+#define SSI_SIER_CMDAU_EN      (1 << 18)
+#define SSI_SIER_CMDDU_EN      (1 << 17)
+#define SSI_SIER_RXT_EN        (1 << 16)
+#define SSI_SIER_RDR1_EN       (1 << 15)
+#define SSI_SIER_RDR0_EN       (1 << 14)
+#define SSI_SIER_TDE1_EN       (1 << 13)
+#define SSI_SIER_TDE0_EN       (1 << 12)
+#define SSI_SIER_ROE1_EN       (1 << 11)
+#define SSI_SIER_ROE0_EN       (1 << 10)
+#define SSI_SIER_TUE1_EN       (1 << 9)
+#define SSI_SIER_TUE0_EN       (1 << 8)
+#define SSI_SIER_TFS_EN        (1 << 7)
+#define SSI_SIER_RFS_EN        (1 << 6)
+#define SSI_SIER_TLS_EN        (1 << 5)
+#define SSI_SIER_RLS_EN        (1 << 4)
+#define SSI_SIER_RFF1_EN       (1 << 3)
+#define SSI_SIER_RFF0_EN       (1 << 2)
+#define SSI_SIER_TFE1_EN       (1 << 1)
+#define SSI_SIER_TFE0_EN       (1 << 0)
+
+#define SSI_STCR_TXBIT0        (1 << 9)
+#define SSI_STCR_TFEN1         (1 << 8)
+#define SSI_STCR_TFEN0         (1 << 7)
+#define SSI_STCR_TFDIR         (1 << 6)
+#define SSI_STCR_TXDIR         (1 << 5)
+#define SSI_STCR_TSHFD         (1 << 4)
+#define SSI_STCR_TSCKP         (1 << 3)
+#define SSI_STCR_TFSI          (1 << 2)
+#define SSI_STCR_TFSL          (1 << 1)
+#define SSI_STCR_TEFS          (1 << 0)
+
+#define SSI_SRCR_RXBIT0        (1 << 9)
+#define SSI_SRCR_RFEN1         (1 << 8)
+#define SSI_SRCR_RFEN0         (1 << 7)
+#define SSI_SRCR_RFDIR         (1 << 6)
+#define SSI_SRCR_RXDIR         (1 << 5)
+#define SSI_SRCR_RSHFD         (1 << 4)
+#define SSI_SRCR_RSCKP         (1 << 3)
+#define SSI_SRCR_RFSI          (1 << 2)
+#define SSI_SRCR_RFSL          (1 << 1)
+#define SSI_SRCR_REFS          (1 << 0)
+
+#define SSI_STCCR_DIV2         (1 << 18)
+#define SSI_STCCR_PSR          (1 << 15)
+#define SSI_STCCR_WL(x)        ((((x) - 2) >> 1) << 13)
+#define SSI_STCCR_DC(x)        (((x) & 0x1f) << 8)
+#define SSI_STCCR_PM(x)        (((x) & 0xff) << 0)
+#define SSI_STCCR_WL_MASK        (0xf << 13)
+#define SSI_STCCR_DC_MASK        (0x1f << 8)
+#define SSI_STCCR_PM_MASK        (0xff << 0)
+
+#define SSI_SRCCR_DIV2         (1 << 18)
+#define SSI_SRCCR_PSR          (1 << 15)
+#define SSI_SRCCR_WL(x)        ((((x) - 2) >> 1) << 13)
+#define SSI_SRCCR_DC(x)        (((x) & 0x1f) << 8)
+#define SSI_SRCCR_PM(x)        (((x) & 0xff) << 0)
+#define SSI_SRCCR_WL_MASK        (0xf << 13)
+#define SSI_SRCCR_DC_MASK        (0x1f << 8)
+#define SSI_SRCCR_PM_MASK        (0xff << 0)
+
+
+#define SSI_SFCSR_RFCNT1(x)   (((x) & 0xf) << 28)
+#define SSI_SFCSR_TFCNT1(x)   (((x) & 0xf) << 24)
+#define SSI_SFCSR_RFWM1(x)    (((x) & 0xf) << 20)
+#define SSI_SFCSR_TFWM1(x)    (((x) & 0xf) << 16)
+#define SSI_SFCSR_RFCNT0(x)   (((x) & 0xf) << 12)
+#define SSI_SFCSR_TFCNT0(x)   (((x) & 0xf) <<  8)
+#define SSI_SFCSR_RFWM0(x)    (((x) & 0xf) <<  4)
+#define SSI_SFCSR_TFWM0(x)    (((x) & 0xf) <<  0)
+
+#define SSI_STR_TEST          (1 << 15)
+#define SSI_STR_RCK2TCK       (1 << 14)
+#define SSI_STR_RFS2TFS       (1 << 13)
+#define SSI_STR_RXSTATE(x)    (((x) & 0xf) << 8)
+#define SSI_STR_TXD2RXD       (1 <<  7)
+#define SSI_STR_TCK2RCK       (1 <<  6)
+#define SSI_STR_TFS2RFS       (1 <<  5)
+#define SSI_STR_TXSTATE(x)    (((x) & 0xf) << 0)
+
+#define SSI_SOR_CLKOFF        (1 << 6)
+#define SSI_SOR_RX_CLR        (1 << 5)
+#define SSI_SOR_TX_CLR        (1 << 4)
+#define SSI_SOR_INIT          (1 << 3)
+#define SSI_SOR_WAIT(x)       (((x) & 0x3) << 1)
+#define SSI_SOR_SYNRST        (1 << 0)
+
+#define SSI_SACNT_FRDIV(x)    (((x) & 0x3f) << 5)
+#define SSI_SACNT_WR          (x << 4)
+#define SSI_SACNT_RD          (x << 3)
+#define SSI_SACNT_TIF         (x << 2)
+#define SSI_SACNT_FV          (x << 1)
+#define SSI_SACNT_AC97EN      (x << 0)
+
+/* SDMA & SSI watermarks for FIFO's */
+#define SDMA_TXFIFO_WATERMARK		0x4
+#define SDMA_RXFIFO_WATERMARK		0x6
+#define SSI_TXFIFO_WATERMARK		0x4
+#define SSI_RXFIFO_WATERMARK		0x6
+
+/* i.MX DAI SSP ID's */
+#define IMX_DAI_SSI0			0 /* SSI1 FIFO 0 */
+#define IMX_DAI_SSI1			1 /* SSI1 FIFO 1 */
+#define IMX_DAI_SSI2			2 /* SSI2 FIFO 0 */
+#define IMX_DAI_SSI3			3 /* SSI2 FIFO 1 */
+
+/* SSI clock sources */
+#define IMX_SSP_SYS_CLK			0
+
+/* SSI audio dividers */
+#define IMX_SSI_TX_DIV_2		0
+#define IMX_SSI_TX_DIV_PSR		1
+#define IMX_SSI_TX_DIV_PM		2
+#define IMX_SSI_RX_DIV_2		3
+#define IMX_SSI_RX_DIV_PSR		4
+#define IMX_SSI_RX_DIV_PM		5
+
+
+/* SSI Div 2 */
+#define IMX_SSI_DIV_2_OFF		(~SSI_STCCR_DIV2)
+#define IMX_SSI_DIV_2_ON		SSI_STCCR_DIV2
+
+extern struct snd_soc_dai imx_ssi_dai;
+
+#endif
diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index 13b4aaf..83f1190 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -4,7 +4,8 @@
  * Copyright 2005 Wolfson Microelectronics PLC.
  * Copyright 2005 Openedhand Ltd.
  *
- * Author: Liam Girdwood <lrg@slimlogic.co.uk>
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
  *         with code, comments and ideas from :-
  *         Richard Purdie <richard@openedhand.com>
  *
@@ -26,7 +27,6 @@
 #include <linux/delay.h>
 #include <linux/pm.h>
 #include <linux/bitops.h>
-#include <linux/debugfs.h>
 #include <linux/platform_device.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
@@ -35,6 +35,14 @@
 #include <sound/soc-dapm.h>
 #include <sound/initval.h>
 
+/* debug */
+#define SOC_DEBUG 0
+#if SOC_DEBUG
+#define dbg(format, arg...) printk(format, ## arg)
+#else
+#define dbg(format, arg...)
+#endif
+
 static DEFINE_MUTEX(pcm_mutex);
 static DEFINE_MUTEX(io_mutex);
 static DECLARE_WAIT_QUEUE_HEAD(soc_pm_waitq);
@@ -88,8 +96,8 @@ static int soc_ac97_dev_register(struct snd_soc_codec *codec)
 	codec->ac97->dev.parent = NULL;
 	codec->ac97->dev.release = soc_ac97_device_release;
 
-	dev_set_name(&codec->ac97->dev, "%d-%d:%s",
-		     codec->card->number, 0, codec->name);
+	snprintf(codec->ac97->dev.bus_id, BUS_ID_SIZE, "%d-%d:%s",
+		 codec->card->number, 0, codec->name);
 	err = device_register(&codec->ac97->dev);
 	if (err < 0) {
 		snd_printk(KERN_ERR "Can't register ac97 bus\n");
@@ -100,6 +108,20 @@ static int soc_ac97_dev_register(struct snd_soc_codec *codec)
 }
 #endif
 
+static inline const char *get_dai_name(int type)
+{
+	switch (type) {
+	case SND_SOC_DAI_AC97_BUS:
+	case SND_SOC_DAI_AC97:
+		return "AC97";
+	case SND_SOC_DAI_I2S:
+		return "I2S";
+	case SND_SOC_DAI_PCM:
+		return "PCM";
+	}
+	return NULL;
+}
+
 /*
  * Called by ALSA when a PCM substream is opened, the runtime->hw record is
  * then initialized and any private data can be allocated. This also calls
@@ -120,7 +142,7 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 
 	/* startup the audio subsystem */
 	if (cpu_dai->ops.startup) {
-		ret = cpu_dai->ops.startup(substream, cpu_dai);
+		ret = cpu_dai->ops.startup(substream);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: can't open interface %s\n",
 				cpu_dai->name);
@@ -137,7 +159,7 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 	}
 
 	if (codec_dai->ops.startup) {
-		ret = codec_dai->ops.startup(substream, codec_dai);
+		ret = codec_dai->ops.startup(substream);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: can't open codec %s\n",
 				codec_dai->name);
@@ -207,12 +229,12 @@ static int soc_pcm_open(struct snd_pcm_substream *substream)
 		goto machine_err;
 	}
 
-	pr_debug("asoc: %s <-> %s info:\n", codec_dai->name, cpu_dai->name);
-	pr_debug("asoc: rate mask 0x%x\n", runtime->hw.rates);
-	pr_debug("asoc: min ch %d max ch %d\n", runtime->hw.channels_min,
-		 runtime->hw.channels_max);
-	pr_debug("asoc: min rate %d max rate %d\n", runtime->hw.rate_min,
-		 runtime->hw.rate_max);
+	dbg("asoc: %s <-> %s info:\n", codec_dai->name, cpu_dai->name);
+	dbg("asoc: rate mask 0x%x\n", runtime->hw.rates);
+	dbg("asoc: min ch %d max ch %d\n", runtime->hw.channels_min,
+		runtime->hw.channels_max);
+	dbg("asoc: min rate %d max rate %d\n", runtime->hw.rate_min,
+		runtime->hw.rate_max);
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
 		cpu_dai->playback.active = codec_dai->playback.active = 1;
@@ -234,7 +256,7 @@ codec_dai_err:
 
 platform_err:
 	if (cpu_dai->ops.shutdown)
-		cpu_dai->ops.shutdown(substream, cpu_dai);
+		cpu_dai->ops.shutdown(substream);
 out:
 	mutex_unlock(&pcm_mutex);
 	return ret;
@@ -257,18 +279,18 @@ static void close_delayed_work(struct work_struct *work)
 	for (i = 0; i < codec->num_dai; i++) {
 		codec_dai = &codec->dai[i];
 
-		pr_debug("pop wq checking: %s status: %s waiting: %s\n",
-			 codec_dai->playback.stream_name,
-			 codec_dai->playback.active ? "active" : "inactive",
-			 codec_dai->pop_wait ? "yes" : "no");
+		dbg("pop wq checking: %s status: %s waiting: %s\n",
+			codec_dai->playback.stream_name,
+			codec_dai->playback.active ? "active" : "inactive",
+			codec_dai->pop_wait ? "yes" : "no");
 
 		/* are we waiting on this codec DAI stream */
 		if (codec_dai->pop_wait == 1) {
 
 			/* Reduce power if no longer active */
 			if (codec->active == 0) {
-				pr_debug("pop wq D1 %s %s\n", codec->name,
-					 codec_dai->playback.stream_name);
+				dbg("pop wq D1 %s %s\n", codec->name,
+					codec_dai->playback.stream_name);
 				snd_soc_dapm_set_bias_level(socdev,
 					SND_SOC_BIAS_PREPARE);
 			}
@@ -280,8 +302,8 @@ static void close_delayed_work(struct work_struct *work)
 
 			/* Fall into standby if no longer active */
 			if (codec->active == 0) {
-				pr_debug("pop wq D3 %s %s\n", codec->name,
-					 codec_dai->playback.stream_name);
+				dbg("pop wq D3 %s %s\n", codec->name,
+					codec_dai->playback.stream_name);
 				snd_soc_dapm_set_bias_level(socdev,
 					SND_SOC_BIAS_STANDBY);
 			}
@@ -318,17 +340,11 @@ static int soc_codec_close(struct snd_pcm_substream *substream)
 	}
 	codec->active--;
 
-	/* Muting the DAC suppresses artifacts caused during digital
-	 * shutdown, for example from stopping clocks.
-	 */
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		snd_soc_dai_digital_mute(codec_dai, 1);
-
 	if (cpu_dai->ops.shutdown)
-		cpu_dai->ops.shutdown(substream, cpu_dai);
+		cpu_dai->ops.shutdown(substream);
 
 	if (codec_dai->ops.shutdown)
-		codec_dai->ops.shutdown(substream, codec_dai);
+		codec_dai->ops.shutdown(substream);
 
 	if (machine->ops && machine->ops->shutdown)
 		machine->ops->shutdown(substream);
@@ -392,7 +408,7 @@ static int soc_pcm_prepare(struct snd_pcm_substream *substream)
 	}
 
 	if (codec_dai->ops.prepare) {
-		ret = codec_dai->ops.prepare(substream, codec_dai);
+		ret = codec_dai->ops.prepare(substream);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: codec DAI prepare error\n");
 			goto out;
@@ -400,49 +416,58 @@ static int soc_pcm_prepare(struct snd_pcm_substream *substream)
 	}
 
 	if (cpu_dai->ops.prepare) {
-		ret = cpu_dai->ops.prepare(substream, cpu_dai);
+		ret = cpu_dai->ops.prepare(substream);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: cpu DAI prepare error\n");
 			goto out;
 		}
 	}
 
-	/* cancel any delayed stream shutdown that is pending */
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK &&
-	    codec_dai->pop_wait) {
-		codec_dai->pop_wait = 0;
-		cancel_delayed_work(&socdev->delayed_work);
-	}
+	/* we only want to start a DAPM playback stream if we are not waiting
+	 * on an existing one stopping */
+	if (codec_dai->pop_wait) {
+		/* we are waiting for the delayed work to start */
+		if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+				snd_soc_dapm_stream_event(socdev->codec,
+					codec_dai->capture.stream_name,
+					SND_SOC_DAPM_STREAM_START);
+		else {
+			codec_dai->pop_wait = 0;
+			cancel_delayed_work(&socdev->delayed_work);
+			snd_soc_dai_digital_mute(codec_dai, 0);
+		}
+	} else {
+		/* no delayed work - do we need to power up codec */
+		if (codec->bias_level != SND_SOC_BIAS_ON) {
 
-	/* do we need to power up codec */
-	if (codec->bias_level != SND_SOC_BIAS_ON) {
-		snd_soc_dapm_set_bias_level(socdev,
-					    SND_SOC_BIAS_PREPARE);
+			snd_soc_dapm_set_bias_level(socdev,
+						    SND_SOC_BIAS_PREPARE);
 
-		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-			snd_soc_dapm_stream_event(codec,
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+				snd_soc_dapm_stream_event(codec,
 					codec_dai->playback.stream_name,
 					SND_SOC_DAPM_STREAM_START);
-		else
-			snd_soc_dapm_stream_event(codec,
+			else
+				snd_soc_dapm_stream_event(codec,
 					codec_dai->capture.stream_name,
 					SND_SOC_DAPM_STREAM_START);
 
-		snd_soc_dapm_set_bias_level(socdev, SND_SOC_BIAS_ON);
-		snd_soc_dai_digital_mute(codec_dai, 0);
+			snd_soc_dapm_set_bias_level(socdev, SND_SOC_BIAS_ON);
+			snd_soc_dai_digital_mute(codec_dai, 0);
 
-	} else {
-		/* codec already powered - power on widgets */
-		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-			snd_soc_dapm_stream_event(codec,
+		} else {
+			/* codec already powered - power on widgets */
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+				snd_soc_dapm_stream_event(codec,
 					codec_dai->playback.stream_name,
 					SND_SOC_DAPM_STREAM_START);
-		else
-			snd_soc_dapm_stream_event(codec,
+			else
+				snd_soc_dapm_stream_event(codec,
 					codec_dai->capture.stream_name,
 					SND_SOC_DAPM_STREAM_START);
 
-		snd_soc_dai_digital_mute(codec_dai, 0);
+			snd_soc_dai_digital_mute(codec_dai, 0);
+		}
 	}
 
 out:
@@ -477,7 +502,7 @@ static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
 	}
 
 	if (codec_dai->ops.hw_params) {
-		ret = codec_dai->ops.hw_params(substream, params, codec_dai);
+		ret = codec_dai->ops.hw_params(substream, params);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: can't set codec %s hw params\n",
 				codec_dai->name);
@@ -486,7 +511,7 @@ static int soc_pcm_hw_params(struct snd_pcm_substream *substream,
 	}
 
 	if (cpu_dai->ops.hw_params) {
-		ret = cpu_dai->ops.hw_params(substream, params, cpu_dai);
+		ret = cpu_dai->ops.hw_params(substream, params);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: interface %s hw params failed\n",
 				cpu_dai->name);
@@ -509,11 +534,11 @@ out:
 
 platform_err:
 	if (cpu_dai->ops.hw_free)
-		cpu_dai->ops.hw_free(substream, cpu_dai);
+		cpu_dai->ops.hw_free(substream);
 
 interface_err:
 	if (codec_dai->ops.hw_free)
-		codec_dai->ops.hw_free(substream, codec_dai);
+		codec_dai->ops.hw_free(substream);
 
 codec_err:
 	if (machine->ops && machine->ops->hw_free)
@@ -552,10 +577,10 @@ static int soc_pcm_hw_free(struct snd_pcm_substream *substream)
 
 	/* now free hw params for the DAI's  */
 	if (codec_dai->ops.hw_free)
-		codec_dai->ops.hw_free(substream, codec_dai);
+		codec_dai->ops.hw_free(substream);
 
 	if (cpu_dai->ops.hw_free)
-		cpu_dai->ops.hw_free(substream, cpu_dai);
+		cpu_dai->ops.hw_free(substream);
 
 	mutex_unlock(&pcm_mutex);
 	return 0;
@@ -572,7 +597,7 @@ static int soc_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 	int ret;
 
 	if (codec_dai->ops.trigger) {
-		ret = codec_dai->ops.trigger(substream, cmd, codec_dai);
+		ret = codec_dai->ops.trigger(substream, cmd);
 		if (ret < 0)
 			return ret;
 	}
@@ -584,7 +609,7 @@ static int soc_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 	}
 
 	if (cpu_dai->ops.trigger) {
-		ret = cpu_dai->ops.trigger(substream, cmd, cpu_dai);
+		ret = cpu_dai->ops.trigger(substream, cmd);
 		if (ret < 0)
 			return ret;
 	}
@@ -606,7 +631,7 @@ static struct snd_pcm_ops soc_pcm_ops = {
 static int soc_suspend(struct platform_device *pdev, pm_message_t state)
 {
 	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
-	struct snd_soc_card *card = socdev->card;
+	struct snd_soc_machine *machine = socdev->machine;
 	struct snd_soc_platform *platform = socdev->platform;
 	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
 	struct snd_soc_codec *codec = socdev->codec;
@@ -623,22 +648,22 @@ static int soc_suspend(struct platform_device *pdev, pm_message_t state)
 	snd_power_change_state(codec->card, SNDRV_CTL_POWER_D3hot);
 
 	/* mute any active DAC's */
-	for (i = 0; i < card->num_links; i++) {
-		struct snd_soc_dai *dai = card->dai_link[i].codec_dai;
-		if (dai->ops.digital_mute && dai->playback.active)
-			dai->ops.digital_mute(dai, 1);
+	for (i = 0; i < machine->num_links; i++) {
+		struct snd_soc_dai *dai = machine->dai_link[i].codec_dai;
+		if (dai->dai_ops.digital_mute && dai->playback.active)
+			dai->dai_ops.digital_mute(dai, 1);
 	}
 
 	/* suspend all pcms */
-	for (i = 0; i < card->num_links; i++)
-		snd_pcm_suspend_all(card->dai_link[i].pcm);
+	for (i = 0; i < machine->num_links; i++)
+		snd_pcm_suspend_all(machine->dai_link[i].pcm);
 
-	if (card->suspend_pre)
-		card->suspend_pre(pdev, state);
+	if (machine->suspend_pre)
+		machine->suspend_pre(pdev, state);
 
-	for (i = 0; i < card->num_links; i++) {
-		struct snd_soc_dai  *cpu_dai = card->dai_link[i].cpu_dai;
-		if (cpu_dai->suspend && !cpu_dai->ac97_control)
+	for (i = 0; i < machine->num_links; i++) {
+		struct snd_soc_dai  *cpu_dai = machine->dai_link[i].cpu_dai;
+		if (cpu_dai->suspend && cpu_dai->type != SND_SOC_DAI_AC97)
 			cpu_dai->suspend(pdev, cpu_dai);
 		if (platform->suspend)
 			platform->suspend(pdev, cpu_dai);
@@ -662,14 +687,14 @@ static int soc_suspend(struct platform_device *pdev, pm_message_t state)
 	if (codec_dev->suspend)
 		codec_dev->suspend(pdev, state);
 
-	for (i = 0; i < card->num_links; i++) {
-		struct snd_soc_dai *cpu_dai = card->dai_link[i].cpu_dai;
-		if (cpu_dai->suspend && cpu_dai->ac97_control)
+	for (i = 0; i < machine->num_links; i++) {
+		struct snd_soc_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+		if (cpu_dai->suspend && cpu_dai->type == SND_SOC_DAI_AC97)
 			cpu_dai->suspend(pdev, cpu_dai);
 	}
 
-	if (card->suspend_post)
-		card->suspend_post(pdev, state);
+	if (machine->suspend_post)
+		machine->suspend_post(pdev, state);
 
 	return 0;
 }
@@ -682,7 +707,7 @@ static void soc_resume_deferred(struct work_struct *work)
 	struct snd_soc_device *socdev = container_of(work,
 						     struct snd_soc_device,
 						     deferred_resume_work);
-	struct snd_soc_card *card = socdev->card;
+	struct snd_soc_machine *machine = socdev->machine;
 	struct snd_soc_platform *platform = socdev->platform;
 	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
 	struct snd_soc_codec *codec = socdev->codec;
@@ -693,14 +718,14 @@ static void soc_resume_deferred(struct work_struct *work)
 	 * so userspace apps are blocked from touching us
 	 */
 
-	dev_dbg(socdev->dev, "starting resume work\n");
+	dev_info(socdev->dev, "starting resume work\n");
 
-	if (card->resume_pre)
-		card->resume_pre(pdev);
+	if (machine->resume_pre)
+		machine->resume_pre(pdev);
 
-	for (i = 0; i < card->num_links; i++) {
-		struct snd_soc_dai *cpu_dai = card->dai_link[i].cpu_dai;
-		if (cpu_dai->resume && cpu_dai->ac97_control)
+	for (i = 0; i < machine->num_links; i++) {
+		struct snd_soc_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+		if (cpu_dai->resume && cpu_dai->type == SND_SOC_DAI_AC97)
 			cpu_dai->resume(pdev, cpu_dai);
 	}
 
@@ -719,24 +744,24 @@ static void soc_resume_deferred(struct work_struct *work)
 	}
 
 	/* unmute any active DACs */
-	for (i = 0; i < card->num_links; i++) {
-		struct snd_soc_dai *dai = card->dai_link[i].codec_dai;
-		if (dai->ops.digital_mute && dai->playback.active)
-			dai->ops.digital_mute(dai, 0);
+	for (i = 0; i < machine->num_links; i++) {
+		struct snd_soc_dai *dai = machine->dai_link[i].codec_dai;
+		if (dai->dai_ops.digital_mute && dai->playback.active)
+			dai->dai_ops.digital_mute(dai, 0);
 	}
 
-	for (i = 0; i < card->num_links; i++) {
-		struct snd_soc_dai *cpu_dai = card->dai_link[i].cpu_dai;
-		if (cpu_dai->resume && !cpu_dai->ac97_control)
+	for (i = 0; i < machine->num_links; i++) {
+		struct snd_soc_dai *cpu_dai = machine->dai_link[i].cpu_dai;
+		if (cpu_dai->resume && cpu_dai->type != SND_SOC_DAI_AC97)
 			cpu_dai->resume(pdev, cpu_dai);
 		if (platform->resume)
 			platform->resume(pdev, cpu_dai);
 	}
 
-	if (card->resume_post)
-		card->resume_post(pdev);
+	if (machine->resume_post)
+		machine->resume_post(pdev);
 
-	dev_dbg(socdev->dev, "resume work completed\n");
+	dev_info(socdev->dev, "resume work completed\n");
 
 	/* userspace can access us now we are back as we were before */
 	snd_power_change_state(codec->card, SNDRV_CTL_POWER_D0);
@@ -747,10 +772,10 @@ static int soc_resume(struct platform_device *pdev)
 {
 	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
 
-	dev_dbg(socdev->dev, "scheduling resume work\n");
+	dev_info(socdev->dev, "scheduling resume work\n");
 
 	if (!schedule_work(&socdev->deferred_resume_work))
-		dev_err(socdev->dev, "resume work item may be lost\n");
+		dev_err(socdev->dev, "work item may be lost\n");
 
 	return 0;
 }
@@ -765,18 +790,18 @@ static int soc_probe(struct platform_device *pdev)
 {
 	int ret = 0, i;
 	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
-	struct snd_soc_card *card = socdev->card;
+	struct snd_soc_machine *machine = socdev->machine;
 	struct snd_soc_platform *platform = socdev->platform;
 	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
 
-	if (card->probe) {
-		ret = card->probe(pdev);
+	if (machine->probe) {
+		ret = machine->probe(pdev);
 		if (ret < 0)
 			return ret;
 	}
 
-	for (i = 0; i < card->num_links; i++) {
-		struct snd_soc_dai *cpu_dai = card->dai_link[i].cpu_dai;
+	for (i = 0; i < machine->num_links; i++) {
+		struct snd_soc_dai *cpu_dai = machine->dai_link[i].cpu_dai;
 		if (cpu_dai->probe) {
 			ret = cpu_dai->probe(pdev, cpu_dai);
 			if (ret < 0)
@@ -811,13 +836,13 @@ platform_err:
 
 cpu_dai_err:
 	for (i--; i >= 0; i--) {
-		struct snd_soc_dai *cpu_dai = card->dai_link[i].cpu_dai;
+		struct snd_soc_dai *cpu_dai = machine->dai_link[i].cpu_dai;
 		if (cpu_dai->remove)
 			cpu_dai->remove(pdev, cpu_dai);
 	}
 
-	if (card->remove)
-		card->remove(pdev);
+	if (machine->remove)
+		machine->remove(pdev);
 
 	return ret;
 }
@@ -827,7 +852,7 @@ static int soc_remove(struct platform_device *pdev)
 {
 	int i;
 	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
-	struct snd_soc_card *card = socdev->card;
+	struct snd_soc_machine *machine = socdev->machine;
 	struct snd_soc_platform *platform = socdev->platform;
 	struct snd_soc_codec_device *codec_dev = socdev->codec_dev;
 
@@ -839,14 +864,14 @@ static int soc_remove(struct platform_device *pdev)
 	if (codec_dev->remove)
 		codec_dev->remove(pdev);
 
-	for (i = 0; i < card->num_links; i++) {
-		struct snd_soc_dai *cpu_dai = card->dai_link[i].cpu_dai;
+	for (i = 0; i < machine->num_links; i++) {
+		struct snd_soc_dai *cpu_dai = machine->dai_link[i].cpu_dai;
 		if (cpu_dai->remove)
 			cpu_dai->remove(pdev, cpu_dai);
 	}
 
-	if (card->remove)
-		card->remove(pdev);
+	if (machine->remove)
+		machine->remove(pdev);
 
 	return 0;
 }
@@ -884,8 +909,8 @@ static int soc_new_pcm(struct snd_soc_device *socdev,
 	codec_dai->codec = socdev->codec;
 
 	/* check client and interface hw capabilities */
-	sprintf(new_name, "%s %s-%d", dai_link->stream_name, codec_dai->name,
-		num);
+	sprintf(new_name, "%s %s-%s-%d", dai_link->stream_name, codec_dai->name,
+		get_dai_name(cpu_dai->type), num);
 
 	if (codec_dai->playback.channels_min)
 		playback = 1;
@@ -931,8 +956,10 @@ static int soc_new_pcm(struct snd_soc_device *socdev,
 }
 
 /* codec register dump */
-static ssize_t soc_codec_reg_show(struct snd_soc_device *devdata, char *buf)
+static ssize_t codec_reg_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
 {
+	struct snd_soc_device *devdata = dev_get_drvdata(dev);
 	struct snd_soc_codec *codec = devdata->codec;
 	int i, step = 1, count = 0;
 
@@ -943,143 +970,14 @@ static ssize_t soc_codec_reg_show(struct snd_soc_device *devdata, char *buf)
 		step = codec->reg_cache_step;
 
 	count += sprintf(buf, "%s registers\n", codec->name);
-	for (i = 0; i < codec->reg_cache_size; i += step) {
-		count += sprintf(buf + count, "%2x: ", i);
-		if (count >= PAGE_SIZE - 1)
-			break;
-
-		if (codec->display_register)
-			count += codec->display_register(codec, buf + count,
-							 PAGE_SIZE - count, i);
-		else
-			count += snprintf(buf + count, PAGE_SIZE - count,
-					  "%4x", codec->read(codec, i));
-
-		if (count >= PAGE_SIZE - 1)
-			break;
-
-		count += snprintf(buf + count, PAGE_SIZE - count, "\n");
-		if (count >= PAGE_SIZE - 1)
-			break;
-	}
-
-	/* Truncate count; min() would cause a warning */
-	if (count >= PAGE_SIZE)
-		count = PAGE_SIZE - 1;
+	for (i = 0; i < codec->reg_cache_size; i += step)
+		count += sprintf(buf + count, "%2x: %4x\n", i,
+			codec->read(codec, i));
 
 	return count;
 }
-static ssize_t codec_reg_show(struct device *dev,
-	struct device_attribute *attr, char *buf)
-{
-	struct snd_soc_device *devdata = dev_get_drvdata(dev);
-	return soc_codec_reg_show(devdata, buf);
-}
-
 static DEVICE_ATTR(codec_reg, 0444, codec_reg_show, NULL);
 
-#ifdef CONFIG_DEBUG_FS
-static int codec_reg_open_file(struct inode *inode, struct file *file)
-{
-	file->private_data = inode->i_private;
-	return 0;
-}
-
-static ssize_t codec_reg_read_file(struct file *file, char __user *user_buf,
-			       size_t count, loff_t *ppos)
-{
-	ssize_t ret;
-	struct snd_soc_device *devdata = file->private_data;
-	char *buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
-	if (!buf)
-		return -ENOMEM;
-	ret = soc_codec_reg_show(devdata, buf);
-	if (ret >= 0)
-		ret = simple_read_from_buffer(user_buf, count, ppos, buf, ret);
-	kfree(buf);
-	return ret;
-}
-
-static ssize_t codec_reg_write_file(struct file *file,
-		const char __user *user_buf, size_t count, loff_t *ppos)
-{
-	char buf[32];
-	int buf_size;
-	char *start = buf;
-	unsigned long reg, value;
-	int step = 1;
-	struct snd_soc_device *devdata = file->private_data;
-	struct snd_soc_codec *codec = devdata->codec;
-
-	buf_size = min(count, (sizeof(buf)-1));
-	if (copy_from_user(buf, user_buf, buf_size))
-		return -EFAULT;
-	buf[buf_size] = 0;
-
-	if (codec->reg_cache_step)
-		step = codec->reg_cache_step;
-
-	while (*start == ' ')
-		start++;
-	reg = simple_strtoul(start, &start, 16);
-	if ((reg >= codec->reg_cache_size) || (reg % step))
-		return -EINVAL;
-	while (*start == ' ')
-		start++;
-	if (strict_strtoul(start, 16, &value))
-		return -EINVAL;
-	codec->write(codec, reg, value);
-	return buf_size;
-}
-
-static const struct file_operations codec_reg_fops = {
-	.open = codec_reg_open_file,
-	.read = codec_reg_read_file,
-	.write = codec_reg_write_file,
-};
-
-static void soc_init_debugfs(struct snd_soc_device *socdev)
-{
-	struct dentry *root, *file;
-	struct snd_soc_codec *codec = socdev->codec;
-	root = debugfs_create_dir(dev_name(socdev->dev), NULL);
-	if (IS_ERR(root) || !root)
-		goto exit1;
-
-	file = debugfs_create_file("codec_reg", 0644,
-			root, socdev, &codec_reg_fops);
-	if (!file)
-		goto exit2;
-
-	file = debugfs_create_u32("dapm_pop_time", 0744,
-			root, &codec->pop_time);
-	if (!file)
-		goto exit2;
-	socdev->debugfs_root = root;
-	return;
-exit2:
-	debugfs_remove_recursive(root);
-exit1:
-	dev_err(socdev->dev, "debugfs is not available\n");
-}
-
-static void soc_cleanup_debugfs(struct snd_soc_device *socdev)
-{
-	debugfs_remove_recursive(socdev->debugfs_root);
-	socdev->debugfs_root = NULL;
-}
-
-#else
-
-static inline void soc_init_debugfs(struct snd_soc_device *socdev)
-{
-}
-
-static inline void soc_cleanup_debugfs(struct snd_soc_device *socdev)
-{
-}
-#endif
-
 /**
  * snd_soc_new_ac97_codec - initailise AC97 device
  * @codec: audio codec
@@ -1198,7 +1096,7 @@ EXPORT_SYMBOL_GPL(snd_soc_test_bits);
 int snd_soc_new_pcms(struct snd_soc_device *socdev, int idx, const char *xid)
 {
 	struct snd_soc_codec *codec = socdev->codec;
-	struct snd_soc_card *card = socdev->card;
+	struct snd_soc_machine *machine = socdev->machine;
 	int ret = 0, i;
 
 	mutex_lock(&codec->mutex);
@@ -1217,11 +1115,11 @@ int snd_soc_new_pcms(struct snd_soc_device *socdev, int idx, const char *xid)
 	strncpy(codec->card->driver, codec->name, sizeof(codec->card->driver));
 
 	/* create the pcms */
-	for (i = 0; i < card->num_links; i++) {
-		ret = soc_new_pcm(socdev, &card->dai_link[i], i);
+	for (i = 0; i < machine->num_links; i++) {
+		ret = soc_new_pcm(socdev, &machine->dai_link[i], i);
 		if (ret < 0) {
 			printk(KERN_ERR "asoc: can't create pcm %s\n",
-				card->dai_link[i].stream_name);
+				machine->dai_link[i].stream_name);
 			mutex_unlock(&codec->mutex);
 			return ret;
 		}
@@ -1244,25 +1142,26 @@ EXPORT_SYMBOL_GPL(snd_soc_new_pcms);
 int snd_soc_register_card(struct snd_soc_device *socdev)
 {
 	struct snd_soc_codec *codec = socdev->codec;
-	struct snd_soc_card *card = socdev->card;
+	struct snd_soc_machine *machine = socdev->machine;
 	int ret = 0, i, ac97 = 0, err = 0;
 
-	for (i = 0; i < card->num_links; i++) {
-		if (card->dai_link[i].init) {
-			err = card->dai_link[i].init(codec);
+	for (i = 0; i < machine->num_links; i++) {
+		if (socdev->machine->dai_link[i].init) {
+			err = socdev->machine->dai_link[i].init(codec);
 			if (err < 0) {
 				printk(KERN_ERR "asoc: failed to init %s\n",
-					card->dai_link[i].stream_name);
+					socdev->machine->dai_link[i].stream_name);
 				continue;
 			}
 		}
-		if (card->dai_link[i].codec_dai->ac97_control)
+		if (socdev->machine->dai_link[i].codec_dai->type ==
+			SND_SOC_DAI_AC97_BUS)
 			ac97 = 1;
 	}
 	snprintf(codec->card->shortname, sizeof(codec->card->shortname),
-		 "%s",  card->name);
+		 "%s", machine->name);
 	snprintf(codec->card->longname, sizeof(codec->card->longname),
-		 "%s (%s)", card->name, codec->name);
+		 "%s (%s)", machine->name, codec->name);
 
 	ret = snd_card_register(codec->card);
 	if (ret < 0) {
@@ -1292,7 +1191,6 @@ int snd_soc_register_card(struct snd_soc_device *socdev)
 	if (err < 0)
 		printk(KERN_WARNING "asoc: failed to add codec sysfs files\n");
 
-	soc_init_debugfs(socdev);
 	mutex_unlock(&codec->mutex);
 
 out:
@@ -1316,11 +1214,10 @@ void snd_soc_free_pcms(struct snd_soc_device *socdev)
 #endif
 
 	mutex_lock(&codec->mutex);
-	soc_cleanup_debugfs(socdev);
 #ifdef CONFIG_SND_SOC_AC97_BUS
 	for (i = 0; i < codec->num_dai; i++) {
 		codec_dai = &codec->dai[i];
-		if (codec_dai->ac97_control && codec->ac97) {
+		if (codec_dai->type == SND_SOC_DAI_AC97_BUS && codec->ac97) {
 			soc_ac97_dev_unregister(codec);
 			goto free_card;
 		}
@@ -1399,10 +1296,10 @@ int snd_soc_info_enum_double(struct snd_kcontrol *kcontrol,
 
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
 	uinfo->count = e->shift_l == e->shift_r ? 1 : 2;
-	uinfo->value.enumerated.items = e->max;
+	uinfo->value.enumerated.items = e->mask;
 
-	if (uinfo->value.enumerated.item > e->max - 1)
-		uinfo->value.enumerated.item = e->max - 1;
+	if (uinfo->value.enumerated.item > e->mask - 1)
+		uinfo->value.enumerated.item = e->mask - 1;
 	strcpy(uinfo->value.enumerated.name,
 		e->texts[uinfo->value.enumerated.item]);
 	return 0;
@@ -1425,7 +1322,7 @@ int snd_soc_get_enum_double(struct snd_kcontrol *kcontrol,
 	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
 	unsigned short val, bitmask;
 
-	for (bitmask = 1; bitmask < e->max; bitmask <<= 1)
+	for (bitmask = 1; bitmask < e->mask; bitmask <<= 1)
 		;
 	val = snd_soc_read(codec, e->reg);
 	ucontrol->value.enumerated.item[0]
@@ -1455,14 +1352,14 @@ int snd_soc_put_enum_double(struct snd_kcontrol *kcontrol,
 	unsigned short val;
 	unsigned short mask, bitmask;
 
-	for (bitmask = 1; bitmask < e->max; bitmask <<= 1)
+	for (bitmask = 1; bitmask < e->mask; bitmask <<= 1)
 		;
-	if (ucontrol->value.enumerated.item[0] > e->max - 1)
+	if (ucontrol->value.enumerated.item[0] > e->mask - 1)
 		return -EINVAL;
 	val = ucontrol->value.enumerated.item[0] << e->shift_l;
 	mask = (bitmask - 1) << e->shift_l;
 	if (e->shift_l != e->shift_r) {
-		if (ucontrol->value.enumerated.item[1] > e->max - 1)
+		if (ucontrol->value.enumerated.item[1] > e->mask - 1)
 			return -EINVAL;
 		val |= ucontrol->value.enumerated.item[1] << e->shift_r;
 		mask |= (bitmask - 1) << e->shift_r;
@@ -1489,10 +1386,10 @@ int snd_soc_info_enum_ext(struct snd_kcontrol *kcontrol,
 
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
 	uinfo->count = 1;
-	uinfo->value.enumerated.items = e->max;
+	uinfo->value.enumerated.items = e->mask;
 
-	if (uinfo->value.enumerated.item > e->max - 1)
-		uinfo->value.enumerated.item = e->max - 1;
+	if (uinfo->value.enumerated.item > e->mask - 1)
+		uinfo->value.enumerated.item = e->mask - 1;
 	strcpy(uinfo->value.enumerated.name,
 		e->texts[uinfo->value.enumerated.item]);
 	return 0;
@@ -1537,11 +1434,9 @@ EXPORT_SYMBOL_GPL(snd_soc_info_volsw_ext);
 int snd_soc_info_volsw(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_info *uinfo)
 {
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	int max = mc->max;
-	unsigned int shift = mc->shift;
-	unsigned int rshift = mc->rshift;
+	int max = (kcontrol->private_value >> 16) & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int rshift = (kcontrol->private_value >> 12) & 0x0f;
 
 	if (max == 1)
 		uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
@@ -1567,15 +1462,13 @@ EXPORT_SYMBOL_GPL(snd_soc_info_volsw);
 int snd_soc_get_volsw(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	unsigned int reg = mc->reg;
-	unsigned int shift = mc->shift;
-	unsigned int rshift = mc->rshift;
-	int max = mc->max;
-	unsigned int mask = (1 << fls(max)) - 1;
-	unsigned int invert = mc->invert;
+	int reg = kcontrol->private_value & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int rshift = (kcontrol->private_value >> 12) & 0x0f;
+	int max = (kcontrol->private_value >> 16) & 0xff;
+	int mask = (1 << fls(max)) - 1;
+	int invert = (kcontrol->private_value >> 24) & 0x01;
 
 	ucontrol->value.integer.value[0] =
 		(snd_soc_read(codec, reg) >> shift) & mask;
@@ -1606,15 +1499,13 @@ EXPORT_SYMBOL_GPL(snd_soc_get_volsw);
 int snd_soc_put_volsw(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	unsigned int reg = mc->reg;
-	unsigned int shift = mc->shift;
-	unsigned int rshift = mc->rshift;
-	int max = mc->max;
-	unsigned int mask = (1 << fls(max)) - 1;
-	unsigned int invert = mc->invert;
+	int reg = kcontrol->private_value & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int rshift = (kcontrol->private_value >> 12) & 0x0f;
+	int max = (kcontrol->private_value >> 16) & 0xff;
+	int mask = (1 << fls(max)) - 1;
+	int invert = (kcontrol->private_value >> 24) & 0x01;
 	unsigned short val, val2, val_mask;
 
 	val = (ucontrol->value.integer.value[0] & mask);
@@ -1646,9 +1537,7 @@ EXPORT_SYMBOL_GPL(snd_soc_put_volsw);
 int snd_soc_info_volsw_2r(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_info *uinfo)
 {
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	int max = mc->max;
+	int max = (kcontrol->private_value >> 12) & 0xff;
 
 	if (max == 1)
 		uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
@@ -1674,15 +1563,13 @@ EXPORT_SYMBOL_GPL(snd_soc_info_volsw_2r);
 int snd_soc_get_volsw_2r(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	unsigned int reg = mc->reg;
-	unsigned int reg2 = mc->rreg;
-	unsigned int shift = mc->shift;
-	int max = mc->max;
-	unsigned int mask = (1<<fls(max))-1;
-	unsigned int invert = mc->invert;
+	int reg = kcontrol->private_value & 0xff;
+	int reg2 = (kcontrol->private_value >> 24) & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int max = (kcontrol->private_value >> 12) & 0xff;
+	int mask = (1<<fls(max))-1;
+	int invert = (kcontrol->private_value >> 20) & 0x01;
 
 	ucontrol->value.integer.value[0] =
 		(snd_soc_read(codec, reg) >> shift) & mask;
@@ -1711,15 +1598,13 @@ EXPORT_SYMBOL_GPL(snd_soc_get_volsw_2r);
 int snd_soc_put_volsw_2r(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	unsigned int reg = mc->reg;
-	unsigned int reg2 = mc->rreg;
-	unsigned int shift = mc->shift;
-	int max = mc->max;
-	unsigned int mask = (1 << fls(max)) - 1;
-	unsigned int invert = mc->invert;
+	int reg = kcontrol->private_value & 0xff;
+	int reg2 = (kcontrol->private_value >> 24) & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int max = (kcontrol->private_value >> 12) & 0xff;
+	int mask = (1 << fls(max)) - 1;
+	int invert = (kcontrol->private_value >> 20) & 0x01;
 	int err;
 	unsigned short val, val2, val_mask;
 
@@ -1756,10 +1641,8 @@ EXPORT_SYMBOL_GPL(snd_soc_put_volsw_2r);
 int snd_soc_info_volsw_s8(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_info *uinfo)
 {
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	int max = mc->max;
-	int min = mc->min;
+	int max = (signed char)((kcontrol->private_value >> 16) & 0xff);
+	int min = (signed char)((kcontrol->private_value >> 24) & 0xff);
 
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = 2;
@@ -1781,11 +1664,9 @@ EXPORT_SYMBOL_GPL(snd_soc_info_volsw_s8);
 int snd_soc_get_volsw_s8(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	unsigned int reg = mc->reg;
-	int min = mc->min;
+	int reg = kcontrol->private_value & 0xff;
+	int min = (signed char)((kcontrol->private_value >> 24) & 0xff);
 	int val = snd_soc_read(codec, reg);
 
 	ucontrol->value.integer.value[0] =
@@ -1808,11 +1689,9 @@ EXPORT_SYMBOL_GPL(snd_soc_get_volsw_s8);
 int snd_soc_put_volsw_s8(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
-	unsigned int reg = mc->reg;
-	int min = mc->min;
+	int reg = kcontrol->private_value & 0xff;
+	int min = (signed char)((kcontrol->private_value >> 24) & 0xff);
 	unsigned short val;
 
 	val = (ucontrol->value.integer.value[0]+min) & 0xff;
@@ -1834,8 +1713,8 @@ EXPORT_SYMBOL_GPL(snd_soc_put_volsw_s8);
 int snd_soc_dai_set_sysclk(struct snd_soc_dai *dai, int clk_id,
 	unsigned int freq, int dir)
 {
-	if (dai->ops.set_sysclk)
-		return dai->ops.set_sysclk(dai, clk_id, freq, dir);
+	if (dai->dai_ops.set_sysclk)
+		return dai->dai_ops.set_sysclk(dai, clk_id, freq, dir);
 	else
 		return -EINVAL;
 }
@@ -1854,8 +1733,8 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_sysclk);
 int snd_soc_dai_set_clkdiv(struct snd_soc_dai *dai,
 	int div_id, int div)
 {
-	if (dai->ops.set_clkdiv)
-		return dai->ops.set_clkdiv(dai, div_id, div);
+	if (dai->dai_ops.set_clkdiv)
+		return dai->dai_ops.set_clkdiv(dai, div_id, div);
 	else
 		return -EINVAL;
 }
@@ -1873,8 +1752,8 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_clkdiv);
 int snd_soc_dai_set_pll(struct snd_soc_dai *dai,
 	int pll_id, unsigned int freq_in, unsigned int freq_out)
 {
-	if (dai->ops.set_pll)
-		return dai->ops.set_pll(dai, pll_id, freq_in, freq_out);
+	if (dai->dai_ops.set_pll)
+		return dai->dai_ops.set_pll(dai, pll_id, freq_in, freq_out);
 	else
 		return -EINVAL;
 }
@@ -1883,14 +1762,15 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_pll);
 /**
  * snd_soc_dai_set_fmt - configure DAI hardware audio format.
  * @dai: DAI
+ * @clk_id: DAI specific clock ID
  * @fmt: SND_SOC_DAIFMT_ format value.
  *
  * Configures the DAI hardware format and clocking.
  */
 int snd_soc_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)
 {
-	if (dai->ops.set_fmt)
-		return dai->ops.set_fmt(dai, fmt);
+	if (dai->dai_ops.set_fmt)
+		return dai->dai_ops.set_fmt(dai, fmt);
 	else
 		return -EINVAL;
 }
@@ -1908,8 +1788,8 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_fmt);
 int snd_soc_dai_set_tdm_slot(struct snd_soc_dai *dai,
 	unsigned int mask, int slots)
 {
-	if (dai->ops.set_sysclk)
-		return dai->ops.set_tdm_slot(dai, mask, slots);
+	if (dai->dai_ops.set_sysclk)
+		return dai->dai_ops.set_tdm_slot(dai, mask, slots);
 	else
 		return -EINVAL;
 }
@@ -1924,8 +1804,8 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_tdm_slot);
  */
 int snd_soc_dai_set_tristate(struct snd_soc_dai *dai, int tristate)
 {
-	if (dai->ops.set_sysclk)
-		return dai->ops.set_tristate(dai, tristate);
+	if (dai->dai_ops.set_sysclk)
+		return dai->dai_ops.set_tristate(dai, tristate);
 	else
 		return -EINVAL;
 }
@@ -1940,8 +1820,8 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_set_tristate);
  */
 int snd_soc_dai_digital_mute(struct snd_soc_dai *dai, int mute)
 {
-	if (dai->ops.digital_mute)
-		return dai->ops.digital_mute(dai, mute);
+	if (dai->dai_ops.digital_mute)
+		return dai->dai_ops.digital_mute(dai, mute);
 	else
 		return -EINVAL;
 }
@@ -1949,6 +1829,7 @@ EXPORT_SYMBOL_GPL(snd_soc_dai_digital_mute);
 
 static int __devinit snd_soc_init(void)
 {
+	printk(KERN_INFO "ASoC version %s\n", SND_SOC_VERSION);
 	return platform_driver_register(&soc_driver);
 }
 
@@ -1961,7 +1842,7 @@ module_init(snd_soc_init);
 module_exit(snd_soc_exit);
 
 /* Module information */
-MODULE_AUTHOR("Liam Girdwood, lrg@slimlogic.co.uk");
+MODULE_AUTHOR("Liam Girdwood, liam.girdwood@wolfsonmicro.com, www.wolfsonmicro.com");
 MODULE_DESCRIPTION("ALSA SoC Core");
 MODULE_LICENSE("GPL");
 MODULE_ALIAS("platform:soc-audio");
diff --git a/sound/soc/soc-dapm.c b/sound/soc/soc-dapm.c
index 61d7d85..f9d100b 100644
--- a/sound/soc/soc-dapm.c
+++ b/sound/soc/soc-dapm.c
@@ -2,7 +2,8 @@
  * soc-dapm.c  --  ALSA SoC Dynamic Audio Power Management
  *
  * Copyright 2005 Wolfson Microelectronics PLC.
- * Author: Liam Girdwood <lrg@slimlogic.co.uk>
+ * Author: Liam Girdwood
+ *         liam.girdwood@wolfsonmicro.com or linux@wolfsonmicro.com
  *
  *  This program is free software; you can redistribute  it and/or modify it
  *  under  the terms of  the GNU General  Public License as published by the
@@ -66,13 +67,15 @@ static int dapm_status = 1;
 module_param(dapm_status, int, 0);
 MODULE_PARM_DESC(dapm_status, "enable DPM sysfs entries");
 
-static void pop_wait(u32 pop_time)
+static unsigned int pop_time;
+
+static void pop_wait(void)
 {
 	if (pop_time)
 		schedule_timeout_uninterruptible(msecs_to_jiffies(pop_time));
 }
 
-static void pop_dbg(u32 pop_time, const char *fmt, ...)
+static void pop_dbg(const char *fmt, ...)
 {
 	va_list args;
 
@@ -80,7 +83,7 @@ static void pop_dbg(u32 pop_time, const char *fmt, ...)
 
 	if (pop_time) {
 		vprintk(fmt, args);
-		pop_wait(pop_time);
+		pop_wait();
 	}
 
 	va_end(args);
@@ -101,13 +104,10 @@ static void dapm_set_path_status(struct snd_soc_dapm_widget *w,
 	case snd_soc_dapm_switch:
 	case snd_soc_dapm_mixer: {
 		int val;
-		struct soc_mixer_control *mc = (struct soc_mixer_control *)
-			w->kcontrols[i].private_value;
-		unsigned int reg = mc->reg;
-		unsigned int shift = mc->shift;
-		int max = mc->max;
-		unsigned int mask = (1 << fls(max)) - 1;
-		unsigned int invert = mc->invert;
+		int reg = w->kcontrols[i].private_value & 0xff;
+		int shift = (w->kcontrols[i].private_value >> 8) & 0x0f;
+		int mask = (w->kcontrols[i].private_value >> 16) & 0xff;
+		int invert = (w->kcontrols[i].private_value >> 24) & 0x01;
 
 		val = snd_soc_read(w->codec, reg);
 		val = (val >> shift) & mask;
@@ -122,13 +122,13 @@ static void dapm_set_path_status(struct snd_soc_dapm_widget *w,
 		struct soc_enum *e = (struct soc_enum *)w->kcontrols[i].private_value;
 		int val, item, bitmask;
 
-		for (bitmask = 1; bitmask < e->max; bitmask <<= 1)
+		for (bitmask = 1; bitmask < e->mask; bitmask <<= 1)
 		;
 		val = snd_soc_read(w->codec, e->reg);
 		item = (val >> e->shift_l) & (bitmask - 1);
 
 		p->connect = 0;
-		for (i = 0; i < e->max; i++) {
+		for (i = 0; i < e->mask; i++) {
 			if (!(strcmp(p->name, e->texts[i])) && item == i)
 				p->connect = 1;
 		}
@@ -165,7 +165,7 @@ static int dapm_connect_mux(struct snd_soc_codec *codec,
 	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
 	int i;
 
-	for (i = 0; i < e->max; i++) {
+	for (i = 0; i < e->mask; i++) {
 		if (!(strcmp(control_name, e->texts[i]))) {
 			list_add(&path->list, &codec->dapm_paths);
 			list_add(&path->list_sink, &dest->sources);
@@ -225,11 +225,10 @@ static int dapm_update_bits(struct snd_soc_dapm_widget *widget)
 
 	change = old != new;
 	if (change) {
-		pop_dbg(codec->pop_time, "pop test %s : %s in %d ms\n",
-			widget->name, widget->power ? "on" : "off",
-			codec->pop_time);
+		pop_dbg("pop test %s : %s in %d ms\n", widget->name,
+			widget->power ? "on" : "off", pop_time);
 		snd_soc_write(codec, widget->reg, new);
-		pop_wait(codec->pop_time);
+		pop_wait();
 	}
 	pr_debug("reg %x old %x new %x change %d\n", widget->reg,
 		 old, new, change);
@@ -248,19 +247,16 @@ static int dapm_set_pga(struct snd_soc_dapm_widget *widget, int power)
 		return 0;
 
 	if (widget->num_kcontrols && k) {
-		struct soc_mixer_control *mc =
-			(struct soc_mixer_control *)k->private_value;
-		unsigned int reg = mc->reg;
-		unsigned int shift = mc->shift;
-		int max = mc->max;
-		unsigned int mask = (1 << fls(max)) - 1;
-		unsigned int invert = mc->invert;
+		int reg = k->private_value & 0xff;
+		int shift = (k->private_value >> 8) & 0x0f;
+		int mask = (k->private_value >> 16) & 0xff;
+		int invert = (k->private_value >> 24) & 0x01;
 
 		if (power) {
 			int i;
 			/* power up has happended, increase volume to last level */
 			if (invert) {
-				for (i = max; i > widget->saved_value; i--)
+				for (i = mask; i > widget->saved_value; i--)
 					snd_soc_update_bits(widget->codec, reg, mask, i);
 			} else {
 				for (i = 0; i < widget->saved_value; i++)
@@ -289,7 +285,7 @@ static int dapm_new_mixer(struct snd_soc_codec *codec,
 	struct snd_soc_dapm_widget *w)
 {
 	int i, ret = 0;
-	size_t name_len;
+	char name[32];
 	struct snd_soc_dapm_path *path;
 
 	/* add kcontrol */
@@ -303,16 +299,11 @@ static int dapm_new_mixer(struct snd_soc_codec *codec,
 				continue;
 
 			/* add dapm control with long name */
-			name_len = 2 + strlen(w->name)
-				+ strlen(w->kcontrols[i].name);
-			path->long_name = kmalloc(name_len, GFP_KERNEL);
+			snprintf(name, 32, "%s %s", w->name, w->kcontrols[i].name);
+			path->long_name = kstrdup (name, GFP_KERNEL);
 			if (path->long_name == NULL)
 				return -ENOMEM;
 
-			snprintf(path->long_name, name_len, "%s %s",
-				 w->name, w->kcontrols[i].name);
-			path->long_name[name_len - 1] = '\0';
-
 			path->kcontrol = snd_soc_cnew(&w->kcontrols[i], w,
 				path->long_name);
 			ret = snd_ctl_add(codec->card, path->kcontrol);
@@ -693,7 +684,7 @@ static void dbg_dump_dapm(struct snd_soc_codec* codec, const char *action)
 /* test and update the power status of a mux widget */
 static int dapm_mux_update_power(struct snd_soc_dapm_widget *widget,
 				 struct snd_kcontrol *kcontrol, int mask,
-				 int mux, int val, struct soc_enum *e)
+				 int val, struct soc_enum* e)
 {
 	struct snd_soc_dapm_path *path;
 	int found = 0;
@@ -709,12 +700,12 @@ static int dapm_mux_update_power(struct snd_soc_dapm_widget *widget,
 		if (path->kcontrol != kcontrol)
 			continue;
 
-		if (!path->name || !e->texts[mux])
+		if (!path->name || ! e->texts[val])
 			continue;
 
 		found = 1;
 		/* we now need to match the string in the enum to the path */
-		if (!(strcmp(path->name, e->texts[mux])))
+		if (!(strcmp(path->name, e->texts[val])))
 			path->connect = 1; /* new connection */
 		else
 			path->connect = 0; /* old connection must be powered down */
@@ -820,16 +811,49 @@ static ssize_t dapm_widget_show(struct device *dev,
 
 static DEVICE_ATTR(dapm_widget, 0444, dapm_widget_show, NULL);
 
+/* pop/click delay times */
+static ssize_t dapm_pop_time_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", pop_time);
+}
+
+static ssize_t dapm_pop_time_store(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t count)
+
+{
+	unsigned long val;
+
+	if (strict_strtoul(buf, 10, &val) >= 0)
+		pop_time = val;
+	else
+		printk(KERN_ERR "Unable to parse pop_time setting\n");
+
+	return count;
+}
+
+static DEVICE_ATTR(dapm_pop_time, 0744, dapm_pop_time_show,
+		   dapm_pop_time_store);
+
 int snd_soc_dapm_sys_add(struct device *dev)
 {
-	if (!dapm_status)
-		return 0;
-	return device_create_file(dev, &dev_attr_dapm_widget);
+	int ret = 0;
+
+	if (dapm_status) {
+		ret = device_create_file(dev, &dev_attr_dapm_widget);
+
+		if (ret == 0)
+			ret = device_create_file(dev, &dev_attr_dapm_pop_time);
+	}
+
+	return ret;
 }
 
 static void snd_soc_dapm_sys_remove(struct device *dev)
 {
 	if (dapm_status) {
+		device_remove_file(dev, &dev_attr_dapm_pop_time);
 		device_remove_file(dev, &dev_attr_dapm_widget);
 	}
 }
@@ -991,6 +1015,28 @@ err:
 }
 
 /**
+ * snd_soc_dapm_connect_input - connect dapm widgets
+ * @codec: audio codec
+ * @sink: name of target widget
+ * @control: mixer control name
+ * @source: name of source name
+ *
+ * Connects 2 dapm widgets together via a named audio path. The sink is
+ * the widget receiving the audio signal, whilst the source is the sender
+ * of the audio signal.
+ *
+ * This function has been deprecated in favour of snd_soc_dapm_add_routes().
+ *
+ * Returns 0 for success else error.
+ */
+int snd_soc_dapm_connect_input(struct snd_soc_codec *codec, const char *sink,
+	const char *control, const char *source)
+{
+	return snd_soc_dapm_add_route(codec, sink, control, source);
+}
+EXPORT_SYMBOL_GPL(snd_soc_dapm_connect_input);
+
+/**
  * snd_soc_dapm_add_routes - Add routes between DAPM widgets
  * @codec: codec
  * @route: audio routes
@@ -1087,14 +1133,12 @@ int snd_soc_dapm_get_volsw(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
 	struct snd_soc_dapm_widget *widget = snd_kcontrol_chip(kcontrol);
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	unsigned int reg = mc->reg;
-	unsigned int shift = mc->shift;
-	unsigned int rshift = mc->rshift;
-	int max = mc->max;
-	unsigned int invert = mc->invert;
-	unsigned int mask = (1 << fls(max)) - 1;
+	int reg = kcontrol->private_value & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int rshift = (kcontrol->private_value >> 12) & 0x0f;
+	int max = (kcontrol->private_value >> 16) & 0xff;
+	int invert = (kcontrol->private_value >> 24) & 0x01;
+	int mask = (1 << fls(max)) - 1;
 
 	/* return the saved value if we are powered down */
 	if (widget->id == snd_soc_dapm_pga && !widget->power) {
@@ -1132,14 +1176,12 @@ int snd_soc_dapm_put_volsw(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol)
 {
 	struct snd_soc_dapm_widget *widget = snd_kcontrol_chip(kcontrol);
-	struct soc_mixer_control *mc =
-		(struct soc_mixer_control *)kcontrol->private_value;
-	unsigned int reg = mc->reg;
-	unsigned int shift = mc->shift;
-	unsigned int rshift = mc->rshift;
-	int max = mc->max;
-	unsigned int mask = (1 << fls(max)) - 1;
-	unsigned int invert = mc->invert;
+	int reg = kcontrol->private_value & 0xff;
+	int shift = (kcontrol->private_value >> 8) & 0x0f;
+	int rshift = (kcontrol->private_value >> 12) & 0x0f;
+	int max = (kcontrol->private_value >> 16) & 0xff;
+	int mask = (1 << fls(max)) - 1;
+	int invert = (kcontrol->private_value >> 24) & 0x01;
 	unsigned short val, val2, val_mask;
 	int ret;
 
@@ -1206,7 +1248,7 @@ int snd_soc_dapm_get_enum_double(struct snd_kcontrol *kcontrol,
 	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
 	unsigned short val, bitmask;
 
-	for (bitmask = 1; bitmask < e->max; bitmask <<= 1)
+	for (bitmask = 1; bitmask < e->mask; bitmask <<= 1)
 		;
 	val = snd_soc_read(widget->codec, e->reg);
 	ucontrol->value.enumerated.item[0] = (val >> e->shift_l) & (bitmask - 1);
@@ -1236,15 +1278,15 @@ int snd_soc_dapm_put_enum_double(struct snd_kcontrol *kcontrol,
 	unsigned short mask, bitmask;
 	int ret = 0;
 
-	for (bitmask = 1; bitmask < e->max; bitmask <<= 1)
+	for (bitmask = 1; bitmask < e->mask; bitmask <<= 1)
 		;
-	if (ucontrol->value.enumerated.item[0] > e->max - 1)
+	if (ucontrol->value.enumerated.item[0] > e->mask - 1)
 		return -EINVAL;
 	mux = ucontrol->value.enumerated.item[0];
 	val = mux << e->shift_l;
 	mask = (bitmask - 1) << e->shift_l;
 	if (e->shift_l != e->shift_r) {
-		if (ucontrol->value.enumerated.item[1] > e->max - 1)
+		if (ucontrol->value.enumerated.item[1] > e->mask - 1)
 			return -EINVAL;
 		val |= ucontrol->value.enumerated.item[1] << e->shift_r;
 		mask |= (bitmask - 1) << e->shift_r;
@@ -1252,7 +1294,7 @@ int snd_soc_dapm_put_enum_double(struct snd_kcontrol *kcontrol,
 
 	mutex_lock(&widget->codec->mutex);
 	widget->value = val;
-	dapm_mux_update_power(widget, kcontrol, mask, mux, val, e);
+	dapm_mux_update_power(widget, kcontrol, mask, mux, e);
 	if (widget->event) {
 		if (widget->event_flags & SND_SOC_DAPM_PRE_REG) {
 			ret = widget->event(widget,
@@ -1402,11 +1444,11 @@ int snd_soc_dapm_set_bias_level(struct snd_soc_device *socdev,
 				enum snd_soc_bias_level level)
 {
 	struct snd_soc_codec *codec = socdev->codec;
-	struct snd_soc_card *card = socdev->card;
+	struct snd_soc_machine *machine = socdev->machine;
 	int ret = 0;
 
-	if (card->set_bias_level)
-		ret = card->set_bias_level(card, level);
+	if (machine->set_bias_level)
+		ret = machine->set_bias_level(machine, level);
 	if (ret == 0 && codec->set_bias_level)
 		ret = codec->set_bias_level(codec, level);
 
@@ -1445,26 +1487,6 @@ int snd_soc_dapm_disable_pin(struct snd_soc_codec *codec, char *pin)
 EXPORT_SYMBOL_GPL(snd_soc_dapm_disable_pin);
 
 /**
- * snd_soc_dapm_nc_pin - permanently disable pin.
- * @codec: SoC codec
- * @pin: pin name
- *
- * Marks the specified pin as being not connected, disabling it along
- * any parent or child widgets.  At present this is identical to
- * snd_soc_dapm_disable_pin() but in future it will be extended to do
- * additional things such as disabling controls which only affect
- * paths through the pin.
- *
- * NOTE: snd_soc_dapm_sync() needs to be called after this for DAPM to
- * do any widget power switching.
- */
-int snd_soc_dapm_nc_pin(struct snd_soc_codec *codec, char *pin)
-{
-	return snd_soc_dapm_set_pin(codec, pin, 0);
-}
-EXPORT_SYMBOL_GPL(snd_soc_dapm_nc_pin);
-
-/**
  * snd_soc_dapm_get_pin_status - get audio pin status
  * @codec: audio codec
  * @pin: audio signal pin endpoint (or start point)
@@ -1502,6 +1524,6 @@ void snd_soc_dapm_free(struct snd_soc_device *socdev)
 EXPORT_SYMBOL_GPL(snd_soc_dapm_free);
 
 /* Module information */
-MODULE_AUTHOR("Liam Girdwood, lrg@slimlogic.co.uk");
+MODULE_AUTHOR("Liam Girdwood, liam.girdwood@wolfsonmicro.com, www.wolfsonmicro.com");
 MODULE_DESCRIPTION("Dynamic Audio Power Management core for ALSA SoC");
 MODULE_LICENSE("GPL");
-- 
1.5.5.1

