From bd97cdfeedb72976a32370b785a10c8b10f8488d Mon Sep 17 00:00:00 2001
From: Wang Hui <Hui.Wang@windriver.com>
Date: Tue, 18 May 2010 19:01:55 +0800
Subject: [PATCH 01/10] imx51pdk/mach: add imx51pdk machine files

Add imx51pdk machine files. it includes platform device registration,
gpio mux definition and PMIC regulator definition.

[Original code taken from L2.6.31_09.12.01_SDK.tar.gz BSP package:
http://www.freescale.com/webapp/sps/site/prod_summary.jsp?code=\
IMX35PDK&fpsp=1&tab=Design_Tools_Tab]

Integrated-by: Wang Hui <Hui.Wang@windriver.com>
---
 arch/arm/mach-mx5/Kconfig                    |    7 +
 arch/arm/mach-mx5/Makefile                   |    1 +
 arch/arm/mach-mx5/board-mx51_3stack.c        | 1277 ++++++++++++++++++++++++++
 arch/arm/mach-mx5/mx51_3stack_gpio.c         |  878 ++++++++++++++++++
 arch/arm/mach-mx5/mx51_3stack_pmic_mc13892.c |  426 +++++++++
 5 files changed, 2589 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-mx5/board-mx51_3stack.c
 create mode 100644 arch/arm/mach-mx5/mx51_3stack_gpio.c
 create mode 100644 arch/arm/mach-mx5/mx51_3stack_pmic_mc13892.c

diff --git a/arch/arm/mach-mx5/Kconfig b/arch/arm/mach-mx5/Kconfig
index ef18f8d..4e291a7 100644
--- a/arch/arm/mach-mx5/Kconfig
+++ b/arch/arm/mach-mx5/Kconfig
@@ -15,6 +15,13 @@ config MACH_MX51_BABBAGE
 	  u-boot. This includes specific configurations for the board and its
 	  peripherals.
 
+config MACH_MX51_3DS
+	bool "Support MX51 3-Stack platforms"
+	default y
+	help
+	  Include support for MX51 3-Stack platform. This includes specific
+	  configurations for the board and its peripherals.
+
 menu "Device options"
 
 config I2C_MXC_SELECT1
diff --git a/arch/arm/mach-mx5/Makefile b/arch/arm/mach-mx5/Makefile
index 26570cd..47e919b 100644
--- a/arch/arm/mach-mx5/Makefile
+++ b/arch/arm/mach-mx5/Makefile
@@ -8,6 +8,7 @@ obj-y   := cpu.o mm.o clock-mx51.o devices.o iomux.o dma.o sdram_autogating.o bu
 obj-y += dummy_gpio.o
 
 obj-$(CONFIG_MACH_MX51_BABBAGE) += board-mx51_babbage.o
+obj-$(CONFIG_MACH_MX51_3DS) += board-mx51_3stack.o mx51_3stack_gpio.o mx51_3stack_pmic_mc13892.o
 
 obj-$(CONFIG_CPU_V7)        += wfi.o suspend.o
 
diff --git a/arch/arm/mach-mx5/board-mx51_3stack.c b/arch/arm/mach-mx5/board-mx51_3stack.c
new file mode 100644
index 0000000..6eae2cb
--- /dev/null
+++ b/arch/arm/mach-mx5/board-mx51_3stack.c
@@ -0,0 +1,1277 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/nodemask.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/smsc911x.h>
+#include <linux/spi/spi.h>
+#include <linux/i2c.h>
+#include <linux/ata.h>
+#include <linux/pmic_external.h>
+#include <linux/input/matrix_keypad.h>
+#include <linux/ipu.h>
+#if defined(CONFIG_MTD) || defined(CONFIG_MTD_MODULE)
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach/flash.h>
+#endif
+
+#include <linux/regulator/consumer.h>
+#include <mach/hardware.h>
+#include <mach/spba.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/time.h>
+#include <mach/common.h>
+#include <mach/memory.h>
+#include <mach/gpio.h>
+#include <mach/mmc.h>
+#include <mach/imx-uart.h>
+#include <mach/board-mx51_3stack.h>
+
+#include "iomux.h"
+#include "crm_regs.h"
+
+#include "devices.h"
+
+/*!
+ * @file mach-mx51/mx51_3stack.c
+ *
+ * @brief This file contains the board specific initialization routines.
+ *
+ * @ingroup MSL_MX51
+ */
+static int num_cpu_wp = 3;
+
+/* working point(wp): 0 - 800MHz; 1 - 166.25MHz; */
+static struct cpu_wp cpu_wp_auto[] = {
+	{
+	 .pll_rate = 1000000000,
+	 .cpu_rate = 1000000000,
+	 .pdf = 0,
+	 .mfi = 10,
+	 .mfd = 11,
+	 .mfn = 5,
+	 .cpu_podf = 0,
+	 .cpu_voltage = 1175000,},
+	{
+	 .pll_rate = 800000000,
+	 .cpu_rate = 800000000,
+	 .pdf = 0,
+	 .mfi = 8,
+	 .mfd = 2,
+	 .mfn = 1,
+	 .cpu_podf = 0,
+	 .cpu_voltage = 1100000,},
+	{
+	 .pll_rate = 800000000,
+	 .cpu_rate = 166250000,
+	 .pdf = 4,
+	 .mfi = 8,
+	 .mfd = 2,
+	 .mfn = 1,
+	 .cpu_podf = 4,
+	 .cpu_voltage = 850000,},
+};
+
+struct cpu_wp *mx51_3stack_get_cpu_wp(int *wp)
+{
+	*wp = num_cpu_wp;
+	return cpu_wp_auto;
+}
+
+void mx51_3stack_set_num_cpu_wp(int num)
+{
+	num_cpu_wp = num;
+	return;
+}
+
+static void mxc_nop_release(struct device *dev)
+{
+	/* Nothing */
+}
+
+#if defined(CONFIG_KEYBOARD_IMX) || defined(CONFIG_KEYBOARD_IMX_MODULE)
+static int board_keymap[] = {
+	KEY(0, 0, KEY_1),
+	KEY(0, 1, KEY_2),
+	KEY(0, 2, KEY_3),
+	KEY(0, 3, KEY_F1),
+	KEY(0, 4, KEY_UP),
+	KEY(0, 5, KEY_F2),
+
+	KEY(1, 0, KEY_4),
+	KEY(1, 1, KEY_5),
+	KEY(1, 2, KEY_6),
+	KEY(1, 3, KEY_LEFT),
+	KEY(1, 4, KEY_SELECT),
+	KEY(1, 5, KEY_RIGHT),
+
+	KEY(2, 0, KEY_7),
+	KEY(2, 1, KEY_8),
+	KEY(2, 2, KEY_9),
+	KEY(2, 3, KEY_F3),
+	KEY(2, 4, KEY_DOWN),
+	KEY(2, 5, KEY_F4),
+
+	KEY(3, 0, KEY_0),
+	KEY(3, 1, KEY_OK),
+	KEY(3, 2, KEY_ESC),
+	KEY(3, 3, KEY_ENTER),
+	KEY(3, 4, KEY_MENU),
+	KEY(3, 5, KEY_BACK)
+};
+
+static struct resource mxc_kpp_resources[] = {
+	{
+		.start = MX51_MXC_INT_KPP,
+		.end = MX51_MXC_INT_KPP,
+		.flags = IORESOURCE_IRQ,
+	},
+	{
+		.start = MX51_KPP_BASE_ADDR,
+		.end = MX51_KPP_BASE_ADDR + 0x100 - 1,
+		.flags = IORESOURCE_MEM,
+	},
+};
+
+static struct matrix_keymap_data board_map_data = {
+	.keymap			= board_keymap,
+	.keymap_size		= ARRAY_SIZE(board_keymap),
+};
+
+
+/* mxc keypad driver */
+static struct platform_device mxc_keypad_device = {
+	.name = "imx-keypad",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(mxc_kpp_resources),
+	.resource = mxc_kpp_resources,
+	.dev = {
+		.platform_data = &board_map_data,
+		},
+};
+
+static void mxc_init_keypad(void)
+{
+	(void)platform_device_register(&mxc_keypad_device);
+}
+#else
+static inline void mxc_init_keypad(void)
+{
+}
+#endif
+
+/* NAND Flash Partitions */
+#ifdef CONFIG_MTD_PARTITIONS
+
+static struct mtd_partition nand_flash_partitions[] = {
+	{
+	 .name = "bootloader",
+	 .offset = 0,
+	 .size = 3 * 1024 * 1024},
+	{
+	 .name = "nand.kernel",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = 5 * 1024 * 1024},
+	{
+	 .name = "nand.rootfs",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = 256 * 1024 * 1024},
+	{
+	 .name = "nand.userfs1",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = 256 * 1024 * 1024},
+	{
+	 .name = "nand.userfs2",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = MTDPART_SIZ_FULL},
+};
+
+#endif
+
+/* MTD NAND flash */
+#if defined(CONFIG_MTD_NAND_MXC) \
+	|| defined(CONFIG_MTD_NAND_MXC_MODULE) \
+	|| defined(CONFIG_MTD_NAND_MXC_V2) \
+	|| defined(CONFIG_MTD_NAND_MXC_V2_MODULE) \
+	|| defined(CONFIG_MTD_NAND_MXC_V3) \
+	|| defined(CONFIG_MTD_NAND_MXC_V3_MODULE)
+
+static int nand_init(void)
+{
+	/* Configure the pins */
+	gpio_nand_active();
+	return 0;
+}
+
+static void nand_exit(void)
+{
+	/* Free the pins */
+	gpio_nand_inactive();
+}
+
+static struct flash_platform_data mxc_nand_data = {
+	#ifdef CONFIG_MTD_PARTITIONS
+		.parts = nand_flash_partitions,
+		.nr_parts = ARRAY_SIZE(nand_flash_partitions),
+	#endif
+	.width = 1,
+	.init = nand_init,
+	.exit = nand_exit,
+};
+
+static struct platform_device mxc_nandv2_mtd_device = {
+	.name = "mxc_nandv2_flash",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxc_nand_data,
+		},
+};
+
+static void mxc_init_nand_mtd(void)
+{
+	(void)platform_device_register(&mxc_nandv2_mtd_device);
+}
+#else
+static inline void mxc_init_nand_mtd(void)
+{
+}
+#endif
+
+
+#if defined(CONFIG_FB_MXC_SYNC_PANEL) || \
+	defined(CONFIG_FB_MXC_SYNC_PANEL_MODULE)
+
+static struct mxc_fb_platform_data fb_data[] = {
+	{
+	 .interface_pix_fmt = IPU_PIX_FMT_RGB666,
+	 },
+	{
+	 .interface_pix_fmt = IPU_PIX_FMT_YUV444,
+	 },
+};
+
+static struct platform_device mxc_fb_device[] = {
+	{
+	 .name = "mxc_sdc_fb",
+	 .id = 0,
+	 .dev = {
+		 .release = mxc_nop_release,
+		 .coherent_dma_mask = 0xFFFFFFFF,
+		 .platform_data = &fb_data[0],
+		 },
+	 },
+	{
+	 .name = "mxc_sdc_fb",
+	 .id = 1,
+	 .dev = {
+		 .release = mxc_nop_release,
+		 .coherent_dma_mask = 0xFFFFFFFF,
+		 .platform_data = &fb_data[1],
+		 },
+	 },
+	{
+	 .name = "mxc_sdc_fb",
+	 .id = 2,
+	 .dev = {
+		 .release = mxc_nop_release,
+		 .coherent_dma_mask = 0xFFFFFFFF,
+		 },
+	 },
+};
+
+static void lcd_reset_to2(void)
+{
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_DI1_D1_CS), 0);
+	ipu_reset_disp_panel();
+
+	return;
+}
+
+static void lcd_reset(void)
+{
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_DISPB2_SER_RS), 0);
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_DISPB2_SER_RS), "ser_rs");
+	gpio_direction_output(IOMUX_TO_GPIO(MX51_PIN_DISPB2_SER_RS), 0);
+	/* do reset */
+	msleep(10);		/* tRES >= 100us */
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_DISPB2_SER_RS), 1);
+	msleep(60);
+}
+
+static struct mxc_lcd_platform_data lcd_data = {
+	.core_reg = "VIOHI",
+	.io_reg = "SW4-LCD",
+	.reset = lcd_reset,
+};
+
+static struct platform_device mxc_lcd_device = {
+	.name = "lcd_spi",
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &lcd_data,
+		},
+};
+
+static void wvga_reset(void)
+{
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_DI1_D1_CS), 1);
+}
+
+static struct mxc_lcd_platform_data lcd_wvga_data = {
+	.reset = wvga_reset,
+};
+
+static struct platform_device lcd_wvga_device = {
+	.name = "lcd_claa",
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &lcd_wvga_data,
+		},
+};
+
+static void mxc_init_fb(void)
+{
+	g_di1_tvout = 1;
+	if (cpu_is_mx51_rev(CHIP_REV_2_0) > 0)
+		lcd_data.reset = lcd_reset_to2;
+
+	(void)platform_device_register(&mxc_lcd_device);
+	(void)platform_device_register(&lcd_wvga_device);
+
+	(void)platform_device_register(&mxc_fb_device[0]);
+	(void)platform_device_register(&mxc_fb_device[1]);
+	(void)platform_device_register(&mxc_fb_device[2]);
+}
+#else
+static inline void mxc_init_fb(void)
+{
+}
+#endif
+
+static struct spi_board_info mxc_spi_nor_device[] __initdata = {
+#if defined(CONFIG_MTD) || defined(CONFIG_MTD_MODULE)
+	{
+	 .modalias = "m25p80",
+	 .max_speed_hz = 25000000,	/* max spi clock (SCK) speed in HZ */
+	 .bus_num = 1,
+	 .chip_select = 1,
+	 .mode = SPI_MODE_0,
+	 .platform_data = NULL,},
+#endif
+};
+
+static struct platform_device mxcbl_device = {
+	.name = "mxc_mc13892_bl",
+};
+
+static inline void mxc_init_bl(void)
+{
+	platform_device_register(&mxcbl_device);
+}
+
+void si4702_reset(void)
+{
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_EIM_DTACK), 0);
+	msleep(100);
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_EIM_DTACK), 1);
+	msleep(100);
+}
+
+void si4702_clock_ctl(int flag)
+{
+}
+
+static void si4702_gpio_get(void)
+{
+	/* reset pin */
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_EIM_DTACK), "eim_dtack");
+	gpio_direction_output(IOMUX_TO_GPIO(MX51_PIN_EIM_DTACK), 0);
+}
+
+static void si4702_gpio_put(void)
+{
+}
+
+static struct mxc_fm_platform_data si4702_data = {
+	.reg_vio = "SW4",
+	.reg_vdd = "VIOHI",
+	.gpio_get = si4702_gpio_get,
+	.gpio_put = si4702_gpio_put,
+	.reset = si4702_reset,
+	.clock_ctl = si4702_clock_ctl,
+	.sksnr = 0,
+	.skcnt = 0,
+	.band = 0,
+	.space = 100,
+	.seekth = 0xa,
+};
+
+#if defined(CONFIG_I2C_IMX) || defined(CONFIG_I2C_IMX_MODULE)
+
+#ifdef CONFIG_I2C_MXC_SELECT1
+static struct i2c_board_info mxc_i2c0_board_info[] __initdata = {
+};
+#endif
+#ifdef CONFIG_I2C_MXC_SELECT2
+static struct i2c_board_info mxc_i2c1_board_info[] __initdata = {
+	{
+	 .type = "wm8903-i2c",
+	 .addr = 0x1a,
+	 },
+	{
+	 .type = "sgtl5000-i2c",
+	 .addr = 0x0a,
+	 },
+	{
+	 .type = "tsc2007",
+	 .addr = 0x48,
+	 .irq  = IOMUX_TO_IRQ(MX51_PIN_GPIO1_5),
+	},
+	{
+	 .type = "si4702",
+	 .addr = 0x10,
+	 .platform_data = (void *)&si4702_data,
+	 },
+};
+#endif
+#if defined(CONFIG_I2C_MXC_HS) || defined(CONFIG_I2C_MXC_HS_MODULE)
+static struct mxc_camera_platform_data camera_data = {
+	.io_regulator = "SW4-CAM",
+	.analog_regulator = "VIOHI-CAM",
+	.mclk = 24000000,
+	.csi = 0,
+};
+static struct mxc_lightsensor_platform_data ls_data = {
+	.vdd_reg = NULL,
+	.rext = 100,
+};
+
+static struct i2c_board_info mxc_i2c_hs_board_info[] __initdata = {
+	{
+		.type = "ov3640",
+		.addr = 0x3C,
+		.platform_data = (void *)&camera_data,
+	},
+	{
+	 .type = "isl29003",
+	 .addr = 0x44,
+	 .platform_data = &ls_data,
+	 },
+};
+#endif
+
+#endif
+
+static u32 cpld_base_addr;
+
+/*lan9217 device*/
+#if defined(CONFIG_SMSC911X) || defined(CONFIG_SMSC911X_MODULE)
+static struct resource smsc911x_resources[] = {
+	{
+	 .flags = IORESOURCE_MEM,
+	 },
+	{
+	 .start = LAN9217_IRQ,
+	 .end = LAN9217_IRQ,
+	 .flags = IORESOURCE_IRQ,
+	 },
+};
+
+struct smsc911x_platform_config smsc911x_config = {
+	.irq_polarity = SMSC911X_IRQ_POLARITY_ACTIVE_LOW,
+	.flags = SMSC911X_USE_32BIT | SMSC911X_FORCE_INTERNAL_PHY,
+};
+
+static struct platform_device smsc_lan9217_device = {
+	.name = "smsc911x",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &smsc911x_config,
+		},
+	.num_resources = ARRAY_SIZE(smsc911x_resources),
+	.resource = smsc911x_resources,
+};
+static void mxc_init_enet(void)
+{
+	if (cpld_base_addr) {
+		smsc_lan9217_device.resource[0].start =
+		    LAN9217_BASE_ADDR(cpld_base_addr);
+		smsc_lan9217_device.resource[0].end =
+		    LAN9217_BASE_ADDR(cpld_base_addr) + 0x100;
+		(void)platform_device_register(&smsc_lan9217_device);
+	}
+}
+#else
+static inline void mxc_init_enet(void)
+{
+}
+#endif
+
+#if defined(CONFIG_IMX_SIM) || defined(CONFIG_IMX_SIM_MODULE)
+/* Used to configure the SIM bus */
+static struct mxc_sim_platform_data sim_data = {
+	.clk_rate = 4000000,
+	.clock_sim = "sim_clk",
+	.power_sim = NULL,
+	.init = NULL,
+	.exit = NULL,
+	.detect = 0,
+};
+
+/*!
+ * Resource definition for the SIM
+ */
+static struct resource mxc_sim_resources[] = {
+	[0] = {
+	       .start = SIM_BASE_ADDR,
+	       .end = SIM_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MXC_INT_SIM_IPB,
+	       .end = MXC_INT_SIM_IPB,
+	       .flags = IORESOURCE_IRQ,
+	       },
+	[2] = {
+	       .start = MXC_INT_SIM_DAT,
+	       .end = MXC_INT_SIM_DAT,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Device Definition for IMX SIM */
+static struct platform_device mxc_sim_device = {
+	.name = "mxc_sim",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &sim_data,
+		},
+	.num_resources = ARRAY_SIZE(mxc_sim_resources),
+	.resource = mxc_sim_resources,
+};
+
+static inline void mxc_init_sim(void)
+{
+	(void)platform_device_register(&mxc_sim_device);
+}
+#else
+static inline void mxc_init_sim(void)
+{
+}
+#endif
+
+#if defined(CONFIG_MMC_IMX_ESDHCI) || defined(CONFIG_MMC_IMX_ESDHCI_MODULE)
+/*!
+ * Get WP pin value to detect write protection
+ */
+int sdhc_write_protect(struct device *dev)
+{
+	unsigned short rc = 0;
+
+	if (to_platform_device(dev)->id == 0)
+		rc = gpio_get_value(IOMUX_TO_GPIO(MX51_PIN_GPIO1_1));
+	else
+		rc = 0;
+	return rc;
+}
+
+/*
+ * Probe for the card. If present the GPIO data would be set.
+ */
+unsigned int sdhc_get_card_det_status(struct device *dev)
+{
+	int ret;
+
+	if (to_platform_device(dev)->id == 0) {
+		ret = gpio_get_value(IOMUX_TO_GPIO(MX51_PIN_GPIO1_0));
+		return ret;
+	} else {		/* config the det pin for SDHC2 */
+		return 0;
+	}
+}
+
+static struct mxc_mmc_platform_data mmc1_data = {
+	.ocr_mask = MMC_VDD_32_33,
+	.caps = MMC_CAP_4_BIT_DATA,
+	.min_clk = 150000,
+	.max_clk = 52000000,
+	.card_inserted_state = 0,
+	.status = sdhc_get_card_det_status,
+	.wp_status = sdhc_write_protect,
+	.clock_mmc = "esdhc_clk",
+	.power_mmc = NULL,
+};
+static struct mxc_mmc_platform_data mmc2_data = {
+	.ocr_mask = MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30 |
+	    MMC_VDD_31_32,
+	.caps = MMC_CAP_4_BIT_DATA,
+	.min_clk = 150000,
+	.max_clk = 50000000,
+	.card_inserted_state = 0,
+	.status = sdhc_get_card_det_status,
+	.wp_status = sdhc_write_protect,
+	.clock_mmc = "esdhc_clk",
+};
+
+/*!
+ * Resource definition for the SDHC1
+ */
+static struct resource mxcsdhc1_resources[] = {
+	[0] = {
+	       .start = MX51_MMC_SDHC1_BASE_ADDR,
+	       .end = MX51_MMC_SDHC1_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MX51_MXC_INT_MMC_SDHC1,
+	       .end = MX51_MXC_INT_MMC_SDHC1,
+	       .flags = IORESOURCE_IRQ,
+	       },
+	[2] = {
+	       .start = IOMUX_TO_IRQ(MX51_PIN_GPIO1_0),
+	       .end = IOMUX_TO_IRQ(MX51_PIN_GPIO1_0),
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*!
+ * Resource definition for the SDHC2
+ */
+static struct resource mxcsdhc2_resources[] = {
+	[0] = {
+	       .start = MX51_MMC_SDHC2_BASE_ADDR,
+	       .end = MX51_MMC_SDHC2_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = MX51_MXC_INT_MMC_SDHC2,
+	       .end = MX51_MXC_INT_MMC_SDHC2,
+	       .flags = IORESOURCE_IRQ,
+	       },
+	[2] = {
+	       .start = 0,
+	       .end = 0,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Device Definition for MXC SDHC1 */
+static struct platform_device mxcsdhc1_device = {
+	.name = "mxsdhci",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mmc1_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcsdhc1_resources),
+	.resource = mxcsdhc1_resources,
+};
+
+/*! Device Definition for MXC SDHC2 */
+static struct platform_device mxcsdhc2_device = {
+	.name = "mxsdhci",
+	.id = 1,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mmc2_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcsdhc2_resources),
+	.resource = mxcsdhc2_resources,
+};
+
+static inline void mxc_init_mmc(void)
+{
+	(void)platform_device_register(&mxcsdhc1_device);
+	(void)platform_device_register(&mxcsdhc2_device);
+}
+#else
+static inline void mxc_init_mmc(void)
+{
+}
+#endif
+
+static u32 brd_io;
+static void expio_ack_irq(u32 irq);
+
+static void mxc_expio_irq_handler(u32 irq, struct irq_desc *desc)
+{
+	u32 imr_val;
+	u32 int_valid;
+	u32 expio_irq;
+
+	desc->chip->mask(irq);	/* irq = gpio irq number */
+
+	imr_val = __raw_readw(brd_io + INTR_MASK_REG);
+	int_valid = __raw_readw(brd_io + INTR_STATUS_REG) & ~imr_val;
+
+	if (unlikely(!int_valid))
+		goto out;
+
+	expio_irq = MXC_BOARD_IRQ_START;
+	for (; int_valid != 0; int_valid >>= 1, expio_irq++) {
+		struct irq_desc *d;
+		if ((int_valid & 1) == 0)
+			continue;
+		d = irq_desc + expio_irq;
+		if (unlikely(!(d->handle_irq))) {
+			printk(KERN_ERR "\nEXPIO irq: %d unhandled\n",
+			       expio_irq);
+			BUG();	/* oops */
+		}
+		d->handle_irq(expio_irq, d);
+	}
+
+out:
+	desc->chip->ack(irq);
+	desc->chip->unmask(irq);
+}
+
+/*
+ * Disable an expio pin's interrupt by setting the bit in the imr.
+ * @param irq		an expio virtual irq number
+ */
+static void expio_mask_irq(u32 irq)
+{
+	u16 reg;
+	u32 expio = MXC_IRQ_TO_EXPIO(irq);
+	/* mask the interrupt */
+	reg = __raw_readw(brd_io + INTR_MASK_REG);
+	reg |= (1 << expio);
+	__raw_writew(reg, brd_io + INTR_MASK_REG);
+}
+
+/*
+ * Acknowledge an expanded io pin's interrupt by clearing the bit in the isr.
+ * @param irq		an expanded io virtual irq number
+ */
+static void expio_ack_irq(u32 irq)
+{
+	u32 expio = MXC_IRQ_TO_EXPIO(irq);
+	/* clear the interrupt status */
+	__raw_writew(1 << expio, brd_io + INTR_RESET_REG);
+	__raw_writew(0, brd_io + INTR_RESET_REG);
+	/* mask the interrupt */
+	expio_mask_irq(irq);
+}
+
+/*
+ * Enable a expio pin's interrupt by clearing the bit in the imr.
+ * @param irq		a expio virtual irq number
+ */
+static void expio_unmask_irq(u32 irq)
+{
+	u16 reg;
+	u32 expio = MXC_IRQ_TO_EXPIO(irq);
+	/* unmask the interrupt */
+	reg = __raw_readw(brd_io + INTR_MASK_REG);
+	reg &= ~(1 << expio);
+	__raw_writew(reg, brd_io + INTR_MASK_REG);
+}
+
+static struct irq_chip expio_irq_chip = {
+	.ack = expio_ack_irq,
+	.mask = expio_mask_irq,
+	.unmask = expio_unmask_irq,
+};
+
+static int __init mxc_expio_init(void)
+{
+	int i;
+
+	brd_io = (u32) ioremap(BOARD_IO_ADDR(MX51_CS5_BASE_ADDR), SZ_4K);
+	if (brd_io == 0)
+		return -ENOMEM;
+
+	if ((__raw_readw(brd_io + MAGIC_NUMBER1_REG) != 0xAAAA) ||
+	    (__raw_readw(brd_io + MAGIC_NUMBER2_REG) != 0x5555) ||
+	    (__raw_readw(brd_io + MAGIC_NUMBER3_REG) != 0xCAFE)) {
+		pr_info("3-Stack Debug board not detected\n");
+		cpld_base_addr = 0;
+		return -ENODEV;
+	} else {
+		cpld_base_addr = MX51_CS5_BASE_ADDR;
+	}
+
+	pr_info("3-Stack Debug board detected, rev = 0x%04X\n",
+		readw(brd_io + CPLD_CODE_VER_REG));
+
+	/*
+	 * Configure INT line as GPIO input
+	 */
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_GPIO1_6), "gpio1_6");
+	gpio_direction_input(IOMUX_TO_GPIO(MX51_PIN_GPIO1_6));
+
+	/* disable the interrupt and clear the status */
+	__raw_writew(0, brd_io + INTR_MASK_REG);
+	__raw_writew(0xFFFF, brd_io + INTR_RESET_REG);
+	__raw_writew(0, brd_io + INTR_RESET_REG);
+	__raw_writew(0x1F, brd_io + INTR_MASK_REG);
+	for (i = MXC_BOARD_IRQ_START;
+	     i < (MXC_BOARD_IRQ_START + MXC_BOARD_IRQS); i++) {
+		set_irq_chip(i, &expio_irq_chip);
+		set_irq_handler(i, handle_level_irq);
+		set_irq_flags(i, IRQF_VALID);
+	}
+	set_irq_type(EXPIO_PARENT_INT, IRQF_TRIGGER_LOW);
+	set_irq_chained_handler(EXPIO_PARENT_INT, mxc_expio_irq_handler);
+
+	return 0;
+}
+
+#if defined(CONFIG_PATA_FSL) || defined(CONFIG_PATA_FSL_MODULE)
+static int ata_init(struct platform_device *pdev)
+{
+	/* Configure the pins */
+	gpio_ata_active();
+	return 0;
+}
+
+static void ata_exit(void)
+{
+	/* Free the pins */
+	gpio_ata_inactive();
+}
+
+static struct fsl_ata_platform_data ata_data = {
+	.udma_mask = ATA_UDMA3,
+	.mwdma_mask = ATA_MWDMA2,
+	.pio_mask = ATA_PIO4,
+	.fifo_alarm = MXC_IDE_DMA_WATERMARK / 2,
+	.max_sg = MXC_IDE_DMA_BD_NR,
+	.init = ata_init,
+	.exit = ata_exit,
+	.core_reg = NULL,
+	.io_reg = NULL,
+};
+
+static struct resource pata_fsl_resources[] = {
+	[0] = {
+	       .start = ATA_BASE_ADDR,
+	       .end = ATA_BASE_ADDR + 0x000000C8,
+	       .flags = IORESOURCE_MEM,},
+	[2] = {
+	       .start = MXC_INT_ATA,
+	       .end = MXC_INT_ATA,
+	       .flags = IORESOURCE_IRQ,},
+};
+
+static struct platform_device pata_fsl_device = {
+	.name = "pata_fsl",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(pata_fsl_resources),
+	.resource = pata_fsl_resources,
+	.dev = {
+		.platform_data = &ata_data,
+		.coherent_dma_mask = ~0,},
+};
+
+static void __init mxc_init_pata(void)
+{
+	(void)platform_device_register(&pata_fsl_device);
+}
+#else				/* CONFIG_PATA_FSL */
+static void __init mxc_init_pata(void)
+{
+}
+#endif				/* CONFIG_PATA_FSL */
+
+#if defined(CONFIG_TOUCHSCREEN_TSC2007) \
+	|| defined(CONFIG_TOUCHSCREEN_TSC2007_MODULE)
+
+static int __init mxc_init_touchscreen(void)
+{
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_GPIO1_5), "gpio1_5");
+	gpio_direction_input(IOMUX_TO_GPIO(MX51_PIN_GPIO1_5));
+
+	return 0;
+}
+#else
+static int __init mxc_init_touchscreen(void)
+{
+	return 0;
+}
+#endif
+
+static int __init mxc_init_srpgconfig(void)
+{
+	struct clk *gpcclk = clk_get(NULL, "gpc_dvfs_clk");
+	clk_enable(gpcclk);
+
+	/* Setup the number of clock cycles to wait for SRPG
+	 * power up and power down requests.
+	 */
+	__raw_writel(0x010F0201, MXC_SRPG_ARM_PUPSCR);
+	__raw_writel(0x010F0201, MXC_SRPG_NEON_PUPSCR);
+	__raw_writel(0x00000008, MXC_SRPG_EMPGC0_PUPSCR);
+	__raw_writel(0x00000008, MXC_SRPG_EMPGC1_PUPSCR);
+
+	__raw_writel(0x01010101, MXC_SRPG_ARM_PDNSCR);
+	__raw_writel(0x01010101, MXC_SRPG_NEON_PDNSCR);
+	__raw_writel(0x00000018, MXC_SRPG_EMPGC0_PDNSCR);
+	__raw_writel(0x00000018, MXC_SRPG_EMPGC1_PDNSCR);
+
+	clk_disable(gpcclk);
+	clk_put(gpcclk);
+
+	return 0;
+}
+
+#if defined(CONFIG_SND_SOC_IMX_3STACK_WM8903) \
+    || defined(CONFIG_SND_SOC_IMX_3STACK_WM8903_MODULE)
+static struct mxc_audio_platform_data wm8903_data;
+
+static struct platform_device mxc_wm8903_device = {
+	.name = "imx-3stack-wm8903",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &wm8903_data,
+		},
+};
+
+static void __init mxc_init_wm8903(void)
+{
+	wm8903_data.ssi_clk[0] = clk_get(NULL, "ssi_clk.0");
+	clk_put(wm8903_data.ssi_clk[0]);
+
+	wm8903_data.ssi_clk[1] = clk_get(NULL, "ssi_clk.1");
+	clk_put(wm8903_data.ssi_clk[1]);
+
+	wm8903_data.ssi_num = 1;
+	wm8903_data.src_port = 2;
+	wm8903_data.ext_port = 3;
+
+	(void)platform_device_register(&mxc_wm8903_device);
+}
+#else
+static void __init mxc_init_wm8903(void)
+{
+}
+#endif
+
+#if defined(CONFIG_SND_SOC_IMX_3STACK_SGTL5000) \
+    || defined(CONFIG_SND_SOC_IMX_3STACK_SGTL5000_MODULE)
+static int mxc_sgtl5000_plat_init(void);
+static int mxc_sgtl5000_plat_finit(void);
+static int mxc_sgtl5000_amp_enable(int enable);
+
+int headphone_det_status(void)
+{
+	return gpio_get_value(IOMUX_TO_GPIO(MX51_PIN_EIM_A26));
+}
+
+static struct mxc_audio_platform_data sgtl5000_data = {
+	.ssi_num = 1,
+	.src_port = 2,
+	.ext_port = 3,
+	.hp_irq = IOMUX_TO_IRQ(MX51_PIN_EIM_A26),
+	.hp_status = headphone_det_status,
+	.amp_enable = mxc_sgtl5000_amp_enable,
+	.sysclk = 12000000,
+	.init = mxc_sgtl5000_plat_init,
+	.finit = mxc_sgtl5000_plat_finit,
+};
+
+static struct platform_device mxc_sgtl5000_device = {
+	.name = "imx-3stack-sgtl5000",
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &sgtl5000_data,
+		},
+};
+
+static int mxc_sgtl5000_plat_init(void)
+{
+	struct regulator *reg;
+	reg = regulator_get(&mxc_sgtl5000_device.dev, "GPO2");
+	if (IS_ERR(reg))
+		return -EINVAL;
+	sgtl5000_data.priv = reg;
+	return 0;
+}
+
+static int mxc_sgtl5000_plat_finit(void)
+{
+	struct regulator *reg;
+	reg = sgtl5000_data.priv;
+	if (reg) {
+		regulator_put(reg);
+		sgtl5000_data.priv = NULL;
+	}
+	return 0;
+}
+
+static int mxc_sgtl5000_amp_enable(int enable)
+{
+	struct regulator *reg;
+	reg = sgtl5000_data.priv;
+
+	if (!reg)
+		return -EINVAL;
+	if (enable)
+		regulator_enable(reg);
+	else
+		regulator_disable(reg);
+	return 0;
+}
+
+static void mxc_init_sgtl5000(void)
+{
+	platform_device_register(&mxc_sgtl5000_device);
+}
+#else
+static inline void mxc_init_sgtl5000(void)
+{
+}
+#endif
+
+static void bt_reset(void)
+{
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_EIM_D19), 1);
+}
+
+static struct mxc_bt_platform_data mxc_bt_data = {
+	.bt_vdd = NULL,
+	.bt_vdd_parent = NULL,
+	.bt_vusb = "SW4",
+	.bt_vusb_parent = NULL,
+	.bt_reset = bt_reset,
+};
+
+static struct platform_device mxc_bt_device = {
+	.name = "mxc_bt",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxc_bt_data,
+		},
+};
+
+static void mxc_init_bluetooth(void)
+{
+	(void)platform_device_register(&mxc_bt_device);
+}
+
+static void mxc_unifi_hardreset(int pin_level)
+{
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_EIM_D19), pin_level & 0x01);
+}
+
+static struct mxc_unifi_platform_data unifi_data = {
+	.hardreset = mxc_unifi_hardreset,
+	.reg_vdd_vpa = "VSD",
+	.reg_1v5_dd = "VGEN1",
+	.host_id = 1,
+};
+
+struct mxc_unifi_platform_data *get_unifi_plat_data(void)
+{
+	return &unifi_data;
+}
+EXPORT_SYMBOL(get_unifi_plat_data);
+
+/*!
+ * Board specific fixup function. It is called by \b setup_arch() in
+ * setup.c file very early on during kernel starts. It allows the user to
+ * statically fill in the proper values for the passed-in parameters. None of
+ * the parameters is used currently.
+ *
+ * @param  desc         pointer to \b struct \b machine_desc
+ * @param  tags         pointer to \b struct \b tag
+ * @param  cmdline      pointer to the command line
+ * @param  mi           pointer to \b struct \b meminfo
+ */
+static void __init fixup_mxc_board(struct machine_desc *desc, struct tag *tags,
+				   char **cmdline, struct meminfo *mi)
+{
+	mxc_cpu_init();
+
+	get_cpu_wp = mx51_3stack_get_cpu_wp;
+	set_num_cpu_wp = mx51_3stack_set_num_cpu_wp;
+#ifdef CONFIG_DISCONTIGMEM
+	do {
+		int nid;
+		mi->nr_banks = MXC_NUMNODES;
+		for (nid = 0; nid < mi->nr_banks; nid++)
+			SET_NODE(mi, nid);
+
+	} while (0);
+#endif
+}
+
+#if defined(CONFIG_GPS_IOCTRL) || defined(CONFIG_GPS_IOCTRL_MODULE)
+static struct mxc_gps_platform_data gps_data = {
+	.core_reg = "VIOHI",
+	.analog_reg = "SW4",
+};
+
+static struct platform_device mxc_gps_device = {
+	.name = "gps_ioctrl",
+	.id = -1,
+	.dev = {
+		.platform_data = &gps_data,
+	},
+};
+
+static void __init mxc_init_gps(void)
+{
+	(void)platform_device_register(&mxc_gps_device);
+}
+
+int gpio_gps_access(int para)
+{
+	iomux_pin_name_t pin;
+	pin = (para & 0x1) ? MX51_PIN_EIM_CS2 : MX51_PIN_EIM_CRE;
+
+	if (para & 0x4) /* Read GPIO */
+		return gpio_get_value(IOMUX_TO_GPIO(pin));
+	else if (para & 0x2) /* Write GPIO */
+		gpio_set_value(IOMUX_TO_GPIO(pin), 1);
+	else
+		gpio_set_value(IOMUX_TO_GPIO(pin), 0);
+	return 0;
+}
+EXPORT_SYMBOL(gpio_gps_access);
+#else
+static void __init mxc_init_gps(void)
+{
+}
+#endif
+
+/* Serial ports */
+#if defined(CONFIG_SERIAL_IMX) || defined(CONFIG_SERIAL_IMX_MODULE)
+static struct imxuart_platform_data uart_pdata = {
+	.flags = IMXUART_HAVE_RTSCTS,
+};
+
+static inline void mxc_init_imx_uart(void)
+{
+	mxc_register_device(&mxc_uart_device0, &uart_pdata);
+	mxc_register_device(&mxc_uart_device1, &uart_pdata);
+	mxc_register_device(&mxc_uart_device2, &uart_pdata);
+}
+#else /* !SERIAL_IMX */
+static inline void mxc_init_imx_uart(void)
+{
+}
+#endif /* SERIAL_IMX */
+
+/*!
+ * Board specific initialization.
+ */
+static void __init mxc_board_init(void)
+{
+	int err;
+	mxc_init_imx_uart();
+	mxc_cpu_common_init();
+	mxc_register_gpios();
+	mx51_3stack_io_init();
+	early_console_setup(saved_command_line);
+	mxc_init_devices();
+
+	mxc_expio_init();
+	mxc_init_enet();
+	mxc_init_pata();
+	mxc_init_fb();
+	mxc_init_bl();
+	mxc_init_keypad();
+	mxc_init_nand_mtd();
+	mxc_init_mmc();
+	mxc_init_sim();
+	mxc_init_srpgconfig();
+	mx51_3stack_init_mc13892();
+
+	spi_register_board_info(mxc_spi_nor_device,
+					ARRAY_SIZE(mxc_spi_nor_device));
+
+#if defined(CONFIG_I2C_IMX) || defined(CONFIG_I2C_IMX_MODULE)
+
+#ifdef CONFIG_I2C_MXC_SELECT1
+	i2c_register_board_info(0, mxc_i2c0_board_info,
+				ARRAY_SIZE(mxc_i2c0_board_info));
+#endif
+#ifdef CONFIG_I2C_MXC_SELECT2
+	i2c_register_board_info(1, mxc_i2c1_board_info,
+				ARRAY_SIZE(mxc_i2c1_board_info));
+#endif
+#if defined(CONFIG_I2C_MXC_HS) || defined(CONFIG_I2C_MXC_HS_MODULE)
+	i2c_register_board_info(3, mxc_i2c_hs_board_info,
+				ARRAY_SIZE(mxc_i2c_hs_board_info));
+#endif
+
+#endif
+	mxc_init_touchscreen();
+	mxc_init_wm8903();
+	mxc_init_sgtl5000();
+	mxc_init_bluetooth();
+	mxc_init_gps();
+
+	err = mxc_request_iomux(MX51_PIN_EIM_D19, IOMUX_CONFIG_GPIO);
+	if (err)
+		printk(KERN_ERR "Error: bt reset request gpio failed!\n");
+	else {
+		gpio_request(IOMUX_TO_GPIO(MX51_PIN_EIM_D19), "eim_d19");
+		gpio_direction_output(IOMUX_TO_GPIO(MX51_PIN_EIM_D19), 0);
+	}
+}
+
+static void __init mx51_3stack_timer_init(void)
+{
+	/* Change the CPU voltages for TO2*/
+	if (cpu_is_mx51_rev(CHIP_REV_2_0) <= 1) {
+		cpu_wp_auto[0].cpu_voltage = 1175000;
+		cpu_wp_auto[1].cpu_voltage = 1100000;
+		cpu_wp_auto[2].cpu_voltage = 1000000;
+	}
+
+	mx51_clocks_init(32768, 24000000, 22579200, 24576000);
+}
+
+static struct sys_timer mxc_timer = {
+	.init	= mx51_3stack_timer_init,
+};
+
+/*
+ * The following uses standard kernel macros define in arch.h in order to
+ * initialize __mach_desc_MX51_3STACK data structure.
+ */
+/* *INDENT-OFF* */
+MACHINE_START(MX51_3DS, "Freescale MX51 3-Stack Board")
+	/* Maintainer: Freescale Semiconductor, Inc. */
+	.phys_io = MX51_AIPS1_BASE_ADDR,
+	.io_pg_offst = ((MX51_AIPS1_BASE_ADDR_VIRT) >> 18) & 0xfffc,
+	.boot_params = PHYS_OFFSET + 0x100,
+	.fixup = fixup_mxc_board,
+	.map_io = mx51_map_io,
+	.init_irq = mx51_init_irq,
+	.init_machine = mxc_board_init,
+	.timer = &mxc_timer,
+MACHINE_END
diff --git a/arch/arm/mach-mx5/mx51_3stack_gpio.c b/arch/arm/mach-mx5/mx51_3stack_gpio.c
new file mode 100644
index 0000000..0f19322
--- /dev/null
+++ b/arch/arm/mach-mx5/mx51_3stack_gpio.c
@@ -0,0 +1,878 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <mach/hardware.h>
+#include <mach/clock.h>
+#include <mach/gpio.h>
+
+#include "iomux.h"
+
+/*!
+ * @file mach-mx51/mx51_3stack_gpio.c
+ *
+ * @brief This file contains all the GPIO setup functions for the board.
+ *
+ * @ingroup GPIO
+ */
+#define ATA_PAD_CONFIG (PAD_CTL_DRV_HIGH | PAD_CTL_DRV_VOT_HIGH)
+
+static struct mxc_iomux_pin_cfg __initdata mxc_iomux_pins[] = {
+	/* CSI0 */
+	{
+	MX51_PIN_CSI1_D8, IOMUX_CONFIG_ALT3,
+	PAD_CTL_PKE_ENABLE,
+	MUX_IN_GPIO3_IPP_IND_G_IN_12_SELECT_INPUT,
+	INPUT_CTL_PATH1,
+	},
+	{
+	MX51_PIN_CSI1_D9, IOMUX_CONFIG_ALT3,
+	PAD_CTL_PKE_ENABLE,
+	},
+	{
+	 MX51_PIN_CSI1_D10, IOMUX_CONFIG_ALT0, PAD_CTL_HYS_NONE,
+	 },
+	{
+	 MX51_PIN_CSI1_D11, IOMUX_CONFIG_ALT0, PAD_CTL_HYS_NONE,
+	 },
+	{
+	 MX51_PIN_CSI1_D12, IOMUX_CONFIG_ALT0, PAD_CTL_HYS_NONE,
+	 },
+	{
+	 MX51_PIN_CSI1_D13, IOMUX_CONFIG_ALT0, PAD_CTL_HYS_NONE,
+	 },
+	{
+	 MX51_PIN_CSI1_D14, IOMUX_CONFIG_ALT0, PAD_CTL_HYS_NONE,
+	 },
+	{
+	 MX51_PIN_CSI1_D15, IOMUX_CONFIG_ALT0, PAD_CTL_HYS_NONE,
+	 },
+	{
+	 MX51_PIN_CSI1_D16, IOMUX_CONFIG_ALT0, PAD_CTL_HYS_NONE,
+	 },
+	{
+	 MX51_PIN_CSI1_D17, IOMUX_CONFIG_ALT0, PAD_CTL_HYS_NONE,
+	 },
+	{
+	 MX51_PIN_CSI1_D18, IOMUX_CONFIG_ALT0, PAD_CTL_HYS_NONE,
+	 },
+	{
+	 MX51_PIN_CSI1_D19, IOMUX_CONFIG_ALT0, PAD_CTL_HYS_NONE,
+	 },
+	{
+	 MX51_PIN_CSI1_VSYNC, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_SRE_SLOW),
+	 },
+	{
+	 MX51_PIN_CSI1_HSYNC, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_SRE_SLOW),
+	 },
+	{
+	 MX51_PIN_EIM_A26, IOMUX_CONFIG_ALT5 | IOMUX_CONFIG_SION,
+	 (PAD_CTL_SRE_SLOW | PAD_CTL_DRV_MEDIUM | PAD_CTL_100K_PU |
+	 PAD_CTL_HYS_ENABLE | PAD_CTL_DRV_VOT_HIGH),
+	 MUX_IN_HSC_MIPI_MIX_IPP_IND_SENS2_DATA_EN_SELECT_INPUT,
+	 INPUT_CTL_PATH0,
+	 },
+	{			/* SPI1 */
+	 MX51_PIN_CSPI1_MISO, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_ENABLE | PAD_CTL_PKE_ENABLE | PAD_CTL_DRV_HIGH |
+				  PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_CSPI1_MOSI, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_ENABLE | PAD_CTL_PKE_ENABLE | PAD_CTL_DRV_HIGH |
+				  PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_CSPI1_RDY, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_ENABLE | PAD_CTL_PKE_ENABLE | PAD_CTL_DRV_HIGH |
+				  PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_CSPI1_SCLK, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_ENABLE | PAD_CTL_PKE_ENABLE | PAD_CTL_DRV_HIGH |
+				  PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_OWIRE_LINE, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_ENABLE | PAD_CTL_PKE_ENABLE |
+		 PAD_CTL_ODE_OPENDRAIN_ENABLE | PAD_CTL_DRV_HIGH |
+		 PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP2_DAT15, IOMUX_CONFIG_ALT5,
+	 },
+	{
+	 MX51_PIN_DI_GP2, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX51_PIN_DI_GP3, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX51_PIN_KEY_COL0, IOMUX_CONFIG_ALT0,
+	},
+	{
+	 MX51_PIN_KEY_COL1, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX51_PIN_KEY_COL2, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX51_PIN_KEY_COL3, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX51_PIN_KEY_COL4, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX51_PIN_KEY_COL5, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX51_PIN_KEY_ROW0, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX51_PIN_KEY_ROW1, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX51_PIN_KEY_ROW2, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX51_PIN_KEY_ROW3, IOMUX_CONFIG_ALT0,
+	 },
+	{			/* AUD3_TXD */
+	 MX51_PIN_AUD3_BB_TXD, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH |
+	    PAD_CTL_ODE_OPENDRAIN_NONE | PAD_CTL_100K_PU |
+	    PAD_CTL_HYS_NONE | PAD_CTL_DDR_INPUT_CMOS | PAD_CTL_DRV_VOT_LOW),
+	 },
+	{			/* AUD3_RXD */
+	 MX51_PIN_AUD3_BB_RXD, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH |
+	    PAD_CTL_ODE_OPENDRAIN_NONE | PAD_CTL_100K_PU |
+	    PAD_CTL_HYS_NONE | PAD_CTL_DDR_INPUT_CMOS | PAD_CTL_DRV_VOT_LOW),
+	 },
+	{			/* AUD3_CLK */
+	 MX51_PIN_AUD3_BB_CK, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH |
+	    PAD_CTL_ODE_OPENDRAIN_NONE | PAD_CTL_100K_PU |
+	    PAD_CTL_HYS_NONE | PAD_CTL_DDR_INPUT_CMOS | PAD_CTL_DRV_VOT_LOW),
+	 },
+	{			/* AUD3_FS */
+	 MX51_PIN_AUD3_BB_FS, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH |
+	    PAD_CTL_ODE_OPENDRAIN_NONE | PAD_CTL_100K_PU |
+	    PAD_CTL_HYS_NONE | PAD_CTL_DDR_INPUT_CMOS | PAD_CTL_DRV_VOT_LOW),
+	 },
+	{
+	 MX51_PIN_EIM_D16, IOMUX_CONFIG_ALT1,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+			  PAD_CTL_PKE_ENABLE | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_EIM_A27, IOMUX_CONFIG_ALT2,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+	  PAD_CTL_PUE_KEEPER | PAD_CTL_PKE_ENABLE | PAD_CTL_HYS_ENABLE),
+	 },
+	{
+	MX51_PIN_EIM_EB2, IOMUX_CONFIG_ALT1,
+	PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PULL | PAD_CTL_100K_PD,
+	},
+	{
+	 MX51_PIN_EIM_DTACK, IOMUX_CONFIG_GPIO,
+	 (PAD_CTL_PKE_ENABLE | PAD_CTL_100K_PU),
+	 },
+	{
+	 MX51_PIN_EIM_CS2, IOMUX_CONFIG_GPIO,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_HYS_NONE | PAD_CTL_PUE_KEEPER |
+	  PAD_CTL_100K_PU | PAD_CTL_PKE_ENABLE | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_EIM_CRE, IOMUX_CONFIG_GPIO,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_HYS_NONE | PAD_CTL_PUE_KEEPER |
+	  PAD_CTL_100K_PU | PAD_CTL_PKE_ENABLE | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DI_GP4, IOMUX_CONFIG_ALT2,
+	 },
+	{
+	 MX51_PIN_DISPB2_SER_DIN, IOMUX_CONFIG_GPIO,
+	 0,
+	 MUX_IN_GPIO3_IPP_IND_G_IN_5_SELECT_INPUT,
+	 INPUT_CTL_PATH1,
+	 },
+	{
+	 MX51_PIN_DISPB2_SER_RS, IOMUX_CONFIG_GPIO,
+	 },
+	{
+	 MX51_PIN_DISPB2_SER_DIO, IOMUX_CONFIG_GPIO,
+	 },
+	{ /* TO2 */
+	MX51_PIN_DI1_D1_CS, IOMUX_CONFIG_ALT4,
+	},
+	{ /* TO2 */
+	MX51_PIN_DI1_D0_CS, IOMUX_CONFIG_ALT1,
+	},
+	{ /* TO2 */
+	MX51_PIN_DI1_PIN11, IOMUX_CONFIG_ALT1,
+	},
+	{ /* TO2 */
+	MX51_PIN_DI1_PIN12, IOMUX_CONFIG_ALT1,
+	},
+	{ /* TO2 */
+	MX51_PIN_DI1_PIN13, IOMUX_CONFIG_ALT1,
+	},
+#ifdef CONFIG_FB_MXC_CLAA_WVGA_SYNC_PANEL
+	{
+	 MX51_PIN_DISP1_DAT0, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT1, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT2, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT3, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT4, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT5, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT6, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT7, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT8, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT9, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT10, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT11, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT12, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT13, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT14, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT15, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT16, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT17, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT18, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT19, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT20, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT21, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT22, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_DISP1_DAT23, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_DRV_LOW | PAD_CTL_SRE_FAST),
+	 },
+#endif
+	{
+	 MX51_PIN_I2C1_CLK, IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION,
+	 0x1E4,
+	 },
+	{
+	 MX51_PIN_I2C1_DAT, IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION,
+	 0x1E4,
+	 },
+	{
+	 MX51_PIN_GPIO1_6, IOMUX_CONFIG_GPIO,
+	 },
+	{
+	 MX51_PIN_GPIO1_7, IOMUX_CONFIG_ALT2,
+	 (PAD_CTL_DRV_HIGH | PAD_CTL_PUE_PULL |
+			 PAD_CTL_100K_PU | PAD_CTL_PKE_ENABLE |
+			 PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_GPIO1_2, IOMUX_CONFIG_ALT2 | IOMUX_CONFIG_SION,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_ODE_OPENDRAIN_ENABLE | PAD_CTL_DRV_HIGH |
+	  PAD_CTL_100K_PU | PAD_CTL_HYS_ENABLE),
+	 MUX_IN_I2C2_IPP_SCL_IN_SELECT_INPUT, INPUT_CTL_PATH3,
+	 },
+	{
+	 MX51_PIN_GPIO1_3, IOMUX_CONFIG_ALT2 | IOMUX_CONFIG_SION,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_ODE_OPENDRAIN_ENABLE | PAD_CTL_DRV_HIGH |
+	  PAD_CTL_100K_PU | PAD_CTL_HYS_ENABLE),
+	 MUX_IN_I2C2_IPP_SDA_IN_SELECT_INPUT, INPUT_CTL_PATH3,
+	 },
+	{
+	 MX51_PIN_USBH1_STP, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH | PAD_CTL_PUE_KEEPER |
+	  PAD_CTL_PKE_ENABLE | PAD_CTL_HYS_ENABLE),
+	 },
+	{			/* USBH1_CLK */
+	 MX51_PIN_USBH1_CLK, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH | PAD_CTL_PUE_KEEPER |
+	  PAD_CTL_PKE_ENABLE | PAD_CTL_HYS_ENABLE | PAD_CTL_DDR_INPUT_CMOS),
+	 },
+	{			/* USBH1_DIR */
+	 MX51_PIN_USBH1_DIR, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH | PAD_CTL_PUE_KEEPER |
+	  PAD_CTL_PKE_ENABLE | PAD_CTL_HYS_ENABLE | PAD_CTL_DDR_INPUT_CMOS),
+	 },
+	{			/* USBH1_NXT */
+	 MX51_PIN_USBH1_NXT, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH | PAD_CTL_PUE_KEEPER |
+	  PAD_CTL_PKE_ENABLE | PAD_CTL_HYS_ENABLE | PAD_CTL_DDR_INPUT_CMOS),
+	 },
+	{			/* USBH1_DATA0 */
+	 MX51_PIN_USBH1_DATA0, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+	  PAD_CTL_PUE_KEEPER | PAD_CTL_PKE_ENABLE | PAD_CTL_HYS_ENABLE),
+	 },
+	{			/* USBH1_DATA1 */
+	 MX51_PIN_USBH1_DATA1, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+	  PAD_CTL_PUE_KEEPER | PAD_CTL_PKE_ENABLE | PAD_CTL_HYS_ENABLE),
+	 },
+	{			/* USBH1_DATA2 */
+	 MX51_PIN_USBH1_DATA2, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+	  PAD_CTL_PUE_KEEPER | PAD_CTL_PKE_ENABLE | PAD_CTL_HYS_ENABLE),
+	 },
+	{			/* USBH1_DATA3 */
+	 MX51_PIN_USBH1_DATA3, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+	  PAD_CTL_PUE_KEEPER | PAD_CTL_PKE_ENABLE | PAD_CTL_HYS_ENABLE),
+	 },
+	{			/* USBH1_DATA4 */
+	 MX51_PIN_USBH1_DATA4, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+	  PAD_CTL_PUE_KEEPER | PAD_CTL_PKE_ENABLE | PAD_CTL_HYS_ENABLE),
+	 },
+	{			/* USBH1_DATA5 */
+	 MX51_PIN_USBH1_DATA5, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+	  PAD_CTL_PUE_KEEPER | PAD_CTL_PKE_ENABLE | PAD_CTL_HYS_ENABLE),
+	 },
+	{			/* USBH1_DATA6 */
+	 MX51_PIN_USBH1_DATA6, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+	  PAD_CTL_PUE_KEEPER | PAD_CTL_PKE_ENABLE | PAD_CTL_HYS_ENABLE),
+	 },
+	{			/* USBH1_DATA7 */
+	 MX51_PIN_USBH1_DATA7, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH | PAD_CTL_100K_PU |
+	  PAD_CTL_PUE_KEEPER | PAD_CTL_PKE_ENABLE | PAD_CTL_HYS_ENABLE),
+	 },
+	 {			/* USB1_OC */
+	 MX51_PIN_GPIO1_9, IOMUX_CONFIG_ALT1,
+	 (PAD_CTL_SRE_SLOW | PAD_CTL_DRV_LOW | PAD_CTL_ODE_OPENDRAIN_NONE |
+			  PAD_CTL_PUE_KEEPER | PAD_CTL_PKE_ENABLE |
+			  PAD_CTL_HYS_ENABLE),
+	 },
+	{			/* USB1_PWR */
+	 MX51_PIN_GPIO1_8, IOMUX_CONFIG_ALT1,
+	 (PAD_CTL_SRE_FAST | PAD_CTL_DRV_HIGH | PAD_CTL_ODE_OPENDRAIN_NONE |
+			  PAD_CTL_PKE_NONE | PAD_CTL_HYS_ENABLE),
+	 },
+	{
+	 MX51_PIN_SD1_CMD, IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION,
+	 (PAD_CTL_DRV_MAX | PAD_CTL_22K_PU | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_SD1_CLK, IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION,
+	 (PAD_CTL_DRV_MAX | PAD_CTL_22K_PU | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_SD1_DATA0, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_MAX | PAD_CTL_22K_PU | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_SD1_DATA1, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_MAX | PAD_CTL_22K_PU | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_SD1_DATA2, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_MAX | PAD_CTL_22K_PU | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_SD1_DATA3, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_MAX | PAD_CTL_22K_PU | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_GPIO1_0, IOMUX_CONFIG_GPIO | IOMUX_CONFIG_SION,
+	 (PAD_CTL_HYS_ENABLE | PAD_CTL_100K_PU),
+	 },
+	{
+	 MX51_PIN_GPIO1_1, IOMUX_CONFIG_GPIO | IOMUX_CONFIG_SION,
+	 (PAD_CTL_HYS_ENABLE | PAD_CTL_100K_PU),
+	 },
+	{
+	 MX51_PIN_SD2_CMD, IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION,
+	 (PAD_CTL_DRV_MAX | PAD_CTL_22K_PU | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_SD2_CLK, IOMUX_CONFIG_ALT0 | IOMUX_CONFIG_SION,
+	 (PAD_CTL_DRV_MAX | PAD_CTL_22K_PU | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_SD2_DATA0, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_MAX | PAD_CTL_22K_PU | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_SD2_DATA1, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_MAX | PAD_CTL_22K_PU | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_SD2_DATA2, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_MAX | PAD_CTL_22K_PU | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_SD2_DATA3, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_DRV_MAX | PAD_CTL_22K_PU | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_UART1_RXD, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_ENABLE | PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PULL |
+	  PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST),
+	 MUX_IN_UART1_IPP_UART_RXD_MUX_SELECT_INPUT,
+	 INPUT_CTL_PATH0,
+	 },
+	{
+	 MX51_PIN_UART1_TXD, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_ENABLE | PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PULL |
+	  PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_UART1_RTS, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_ENABLE | PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PULL |
+	  PAD_CTL_DRV_HIGH),
+	 MUX_IN_UART1_IPP_UART_RTS_B_SELECT_INPUT,
+	 INPUT_CTL_PATH0,
+	 },
+	{
+	 MX51_PIN_UART1_CTS, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_ENABLE | PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PULL |
+	  PAD_CTL_DRV_HIGH),
+	 },
+	{
+	 MX51_PIN_UART2_RXD, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PULL |
+	  PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST),
+	 MUX_IN_UART2_IPP_UART_RXD_MUX_SELECT_INPUT,
+	 INPUT_CTL_PATH2,
+	 },
+	{
+	 MX51_PIN_UART2_TXD, IOMUX_CONFIG_ALT0,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_PULL |
+	  PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_EIM_D26, IOMUX_CONFIG_ALT4,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_KEEPER |
+	  PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST),
+	 MUX_IN_UART2_IPP_UART_RTS_B_SELECT_INPUT,
+	 INPUT_CTL_PATH3,
+	 },
+	{
+	 MX51_PIN_EIM_D25, IOMUX_CONFIG_ALT4,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_KEEPER |
+	  PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_UART3_RXD, IOMUX_CONFIG_ALT1,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_KEEPER |
+	  PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST),
+	 MUX_IN_UART3_IPP_UART_RXD_MUX_SELECT_INPUT,
+	 INPUT_CTL_PATH4,
+	 },
+	{
+	 MX51_PIN_UART3_TXD, IOMUX_CONFIG_ALT1,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_KEEPER |
+	  PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_EIM_D27, IOMUX_CONFIG_ALT3,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_KEEPER |
+	  PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST),
+	 MUX_IN_UART3_IPP_UART_RTS_B_SELECT_INPUT,
+	 INPUT_CTL_PATH3,
+	 },
+	{
+	 MX51_PIN_EIM_D24, IOMUX_CONFIG_ALT3,
+	 (PAD_CTL_HYS_NONE | PAD_CTL_PKE_ENABLE | PAD_CTL_PUE_KEEPER |
+	  PAD_CTL_DRV_HIGH | PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_NANDF_RB3, IOMUX_CONFIG_ALT2,
+	 (PAD_CTL_HYS_ENABLE | PAD_CTL_PKE_ENABLE | PAD_CTL_DRV_HIGH |
+				  PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_NANDF_D15, IOMUX_CONFIG_ALT2,
+	 (PAD_CTL_HYS_ENABLE | PAD_CTL_PKE_ENABLE | PAD_CTL_DRV_HIGH |
+				  PAD_CTL_SRE_FAST),
+	 },
+
+	{
+	 MX51_PIN_NANDF_RB2, IOMUX_CONFIG_ALT2,
+	 (PAD_CTL_HYS_ENABLE | PAD_CTL_PKE_ENABLE | PAD_CTL_DRV_HIGH |
+				  PAD_CTL_SRE_FAST),
+	 },
+	{
+	 MX51_PIN_NANDF_D12, IOMUX_CONFIG_ALT3,
+	 (PAD_CTL_HYS_ENABLE | PAD_CTL_PKE_ENABLE | PAD_CTL_DRV_HIGH |
+				  PAD_CTL_SRE_FAST),
+	 },
+};
+
+static struct mxc_iomux_pin_cfg __initdata ata_iomux_pins[] = {
+	{
+	 MX51_PIN_NANDF_ALE, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_CS2, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_CS3, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_CS4, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_CS5, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_CS6, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_RE_B, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_WE_B, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_CLE, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_RB0, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_WP_B, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	/* TO 2.0 */
+	{
+	 MX51_PIN_GPIO_NAND, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	/* TO 1.0 */
+	{
+	 MX51_PIN_NANDF_RB5, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_RB1, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_D0, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_D1, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_D2, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_D3, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_D4, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_D5, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_D6, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_D7, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_D8, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_D9, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_D10, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_D11, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_D12, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_D13, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_D14, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+	{
+	 MX51_PIN_NANDF_D15, IOMUX_CONFIG_ALT1,
+	 ATA_PAD_CONFIG,
+	 },
+};
+
+static struct mxc_iomux_pin_cfg __initdata nand_iomux_pins[] = {
+	{
+	 MX51_PIN_NANDF_CS0, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX51_PIN_NANDF_CS1, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX51_PIN_NANDF_CS2, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX51_PIN_NANDF_CS3, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX51_PIN_NANDF_CS4, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX51_PIN_NANDF_CS5, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX51_PIN_NANDF_CS6, IOMUX_CONFIG_ALT0,
+	 },
+	{
+	 MX51_PIN_NANDF_CS7, IOMUX_CONFIG_ALT0,
+	 },
+	/* TO2 */
+	{
+	 MX51_PIN_GPIO_NAND, IOMUX_CONFIG_ALT0,
+	 },
+	/* TO1 */
+	{
+	 MX51_PIN_NANDF_RB5, IOMUX_CONFIG_ALT0,
+	 },
+};
+
+static struct mxc_iomux_pin_cfg __initdata sim_iomux_pins[] = {
+	{
+	 MX51_PIN_NANDF_CS4, IOMUX_CONFIG_ALT6,
+	 PAD_CTL_DRV_HIGH | PAD_CTL_DRV_VOT_HIGH |
+	 PAD_CTL_HYS_NONE | PAD_CTL_47K_PU |
+	 PAD_CTL_PUE_KEEPER | PAD_CTL_ODE_OPENDRAIN_NONE | PAD_CTL_PKE_ENABLE,
+	 },
+	{
+	 MX51_PIN_NANDF_CS5, IOMUX_CONFIG_ALT6,
+	 PAD_CTL_DRV_HIGH | PAD_CTL_DRV_VOT_HIGH |
+	 PAD_CTL_HYS_NONE | PAD_CTL_47K_PU |
+	 PAD_CTL_PUE_KEEPER | PAD_CTL_ODE_OPENDRAIN_NONE | PAD_CTL_PKE_ENABLE,
+	 },
+	{
+	 MX51_PIN_NANDF_CS6, IOMUX_CONFIG_ALT6,
+	 PAD_CTL_DRV_HIGH | PAD_CTL_DRV_VOT_HIGH |
+	 PAD_CTL_HYS_NONE | PAD_CTL_100K_PD |
+	 PAD_CTL_PUE_PULL | PAD_CTL_ODE_OPENDRAIN_NONE | PAD_CTL_PKE_ENABLE,
+	 },
+	{
+	 MX51_PIN_NANDF_CS7, IOMUX_CONFIG_ALT6,
+	 PAD_CTL_DRV_HIGH | PAD_CTL_DRV_VOT_HIGH |
+	 PAD_CTL_HYS_NONE | PAD_CTL_22K_PU |
+	 PAD_CTL_PUE_PULL | PAD_CTL_ODE_OPENDRAIN_NONE | PAD_CTL_PKE_ENABLE,
+	 },
+};
+
+static int __initdata enable_ata = { 0 };
+static int __init ata_setup(char *__unused)
+{
+	enable_ata = 1;
+	return 1;
+}
+
+__setup("ata", ata_setup);
+
+static int __initdata enable_sim = { 0 };
+static int __init sim_setup(char *__unused)
+{
+	enable_sim = 1;
+	return 1;
+}
+
+__setup("sim", sim_setup);
+
+void __init mx51_3stack_io_init(void)
+{
+	int i, num;
+	struct mxc_iomux_pin_cfg *pin_ptr;
+
+	for (i = 0; i < ARRAY_SIZE(mxc_iomux_pins); i++) {
+		mxc_request_iomux(mxc_iomux_pins[i].pin,
+				  mxc_iomux_pins[i].mux_mode);
+		if (mxc_iomux_pins[i].pad_cfg)
+			mxc_iomux_set_pad(mxc_iomux_pins[i].pin,
+					  mxc_iomux_pins[i].pad_cfg);
+		if (mxc_iomux_pins[i].in_select)
+			mxc_iomux_set_input(mxc_iomux_pins[i].in_select,
+					  mxc_iomux_pins[i].in_mode);
+	}
+
+	if (enable_ata) {
+		pin_ptr = ata_iomux_pins;
+		num = ARRAY_SIZE(ata_iomux_pins);
+	} else if (enable_sim) {
+		pin_ptr = sim_iomux_pins;
+		num = ARRAY_SIZE(sim_iomux_pins);
+	} else {
+		pin_ptr = nand_iomux_pins;
+		num = ARRAY_SIZE(nand_iomux_pins);
+	}
+
+	for (i = 0; i < num; i++) {
+		mxc_request_iomux(pin_ptr[i].pin, pin_ptr[i].mux_mode);
+		if (pin_ptr[i].pad_cfg)
+			mxc_iomux_set_pad(pin_ptr[i].pin, pin_ptr[i].pad_cfg);
+		if (pin_ptr[i].in_select)
+			mxc_iomux_set_input(pin_ptr[i].in_select,
+					pin_ptr[i].in_mode);
+	}
+
+	/* TO3 doesn't need pad to drive CSI_DATA_EN[0] high */
+	if (cpu_is_mx51_rev(CHIP_REV_3_0) > 0)
+		mxc_request_iomux(MX51_PIN_EIM_A26, IOMUX_CONFIG_ALT0);
+
+	/* Camera low power */
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_CSI1_D8), "csi1_d8");
+	gpio_direction_output(IOMUX_TO_GPIO(MX51_PIN_CSI1_D8), 0);
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_CSI1_D8), 0);
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_EIM_EB2), "eim_eb2");
+	gpio_direction_output(IOMUX_TO_GPIO(MX51_PIN_EIM_EB2), 0);    /* TO1 */
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_EIM_EB2), 0);      /* TO1 */
+
+	/* Camera reset */
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_CSI1_D9), "csi1_d9");
+	gpio_direction_output(IOMUX_TO_GPIO(MX51_PIN_CSI1_D9), 0);
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_CSI1_D9), 1);
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_DI1_D1_CS), "di1_d1_cs");
+	gpio_direction_output(IOMUX_TO_GPIO(MX51_PIN_DI1_D1_CS), 0);
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_GPIO1_0), "gpio1_0");
+	gpio_direction_input(IOMUX_TO_GPIO(MX51_PIN_GPIO1_0));	/* SD1 CD */
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_GPIO1_1), "gpio1_1");
+	gpio_direction_input(IOMUX_TO_GPIO(MX51_PIN_GPIO1_1));	/* SD1 WP */
+
+	/* EIM_D16 */
+	/* osc_en is shared by SPDIF */
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_EIM_D16), "eim_d16");
+	gpio_direction_output(IOMUX_TO_GPIO(MX51_PIN_EIM_D16), 0);
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_EIM_D16), 1);
+
+	/* LCD related gpio */
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_DI1_D1_CS), "di1_d1_cs");
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_DISPB2_SER_DIO), "dispb2_ser_di0");
+	gpio_direction_output(IOMUX_TO_GPIO(MX51_PIN_DI1_D1_CS), 0);
+	gpio_direction_output(IOMUX_TO_GPIO(MX51_PIN_DISPB2_SER_DIO), 0);
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_DISPB2_SER_DIO), 0);
+
+	/* GPS related gpio */
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_EIM_CS2), "eim_cs2");
+	gpio_direction_output(IOMUX_TO_GPIO(MX51_PIN_EIM_CS2), 0);
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_EIM_CS2), 0);
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_EIM_CRE), "eim_cre");
+	gpio_direction_output(IOMUX_TO_GPIO(MX51_PIN_EIM_CRE), 0);
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_EIM_CRE), 0);
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_EIM_CRE), 1);
+
+	/* ecspi2 */
+	gpio_request(IOMUX_TO_GPIO(MX51_PIN_NANDF_D12), "cspi2_cs1");
+	gpio_direction_output(IOMUX_TO_GPIO(MX51_PIN_NANDF_D12), 0);
+	gpio_set_value(IOMUX_TO_GPIO(MX51_PIN_NANDF_D12), 0);
+	gpio_free(IOMUX_TO_GPIO(MX51_PIN_NANDF_D12));
+}
diff --git a/arch/arm/mach-mx5/mx51_3stack_pmic_mc13892.c b/arch/arm/mach-mx5/mx51_3stack_pmic_mc13892.c
new file mode 100644
index 0000000..ec7f931
--- /dev/null
+++ b/arch/arm/mach-mx5/mx51_3stack_pmic_mc13892.c
@@ -0,0 +1,426 @@
+/*
+ * mx51-3stack-pmic-mc13892.c  --  i.MX51 3STACK Driver for Atlas MC13892 PMIC
+ */
+ /*
+  * Copyright 2009 Freescale Semiconductor, Inc. All Rights Reserved.
+  */
+
+ /*
+  * The code contained herein is licensed under the GNU General Public
+  * License. You may obtain a copy of the GNU General Public License
+  * Version 2 or later at the following locations:
+  *
+  * http://www.opensource.org/licenses/gpl-license.html
+  * http://www.gnu.org/copyleft/gpl.html
+  */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/err.h>
+#include <linux/pmic_external.h>
+#include <linux/regulator/machine.h>
+#include <linux/mfd/mc13892/core.h>
+#include <mach/irqs.h>
+#include "iomux.h"
+
+/*
+ * Convenience conversion.
+ * Here atm, maybe there is somewhere better for this.
+ */
+#define mV_to_uV(mV) (mV * 1000)
+#define uV_to_mV(uV) (uV / 1000)
+#define V_to_uV(V) (mV_to_uV(V * 1000))
+#define uV_to_V(uV) (uV_to_mV(uV) / 1000)
+
+#define STANDBYSECINV_LSH 11
+#define STANDBYSECINV_WID 1
+
+/* Coin cell charger enable */
+#define CIONCHEN_LSH	23
+#define CIONCHEN_WID	1
+/* Coin cell charger voltage setting */
+#define VCOIN_LSH	20
+#define VCOIN_WID	3
+
+/* Coin Charger voltage */
+#define VCOIN_2_5V	0x0
+#define VCOIN_2_7V	0x1
+#define VCOIN_2_8V	0x2
+#define VCOIN_2_9V	0x3
+#define VCOIN_3_0V	0x4
+#define VCOIN_3_1V	0x5
+#define VCOIN_3_2V	0x6
+#define VCOIN_3_3V	0x7
+
+/* Keeps VSRTC and CLK32KMCU on for all states */
+#define DRM_LSH 4
+#define DRM_WID 1
+
+/* CPU */
+static struct regulator_consumer_supply sw1_consumers[] = {
+	{
+		.supply = "SW1",
+	}
+};
+
+struct mc13892;
+
+static struct regulator_init_data sw1_init = {
+	.constraints = {
+		.name = "SW1",
+		.min_uV = mV_to_uV(600),
+		.max_uV = mV_to_uV(1375),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE |
+			REGULATOR_CHANGE_STATUS,
+		.valid_modes_mask = 0,
+		.always_on = 1,
+		.boot_on = 1,
+		.initial_state = PM_SUSPEND_MEM,
+		.state_mem = {
+			.uV = 850000,
+			.mode = REGULATOR_MODE_NORMAL,
+			.enabled = 1,
+		},
+	},
+	.num_consumer_supplies = ARRAY_SIZE(sw1_consumers),
+	.consumer_supplies = sw1_consumers,
+};
+
+/* DVFS_PER */
+static struct regulator_consumer_supply sw2_consumers[] = {
+	{
+		.supply = "SW2",
+	}
+};
+static struct regulator_init_data sw2_init = {
+	.constraints = {
+		.name = "SW2",
+		.min_uV = mV_to_uV(900),
+		.max_uV = mV_to_uV(1850),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE |
+			REGULATOR_CHANGE_STATUS,
+		.always_on = 1,
+		.boot_on = 1,
+		.initial_state = PM_SUSPEND_MEM,
+		.state_mem = {
+			.uV = 950000,
+			.mode = REGULATOR_MODE_NORMAL,
+			.enabled = 1,
+		},
+	},
+	.num_consumer_supplies = ARRAY_SIZE(sw2_consumers),
+	.consumer_supplies = sw2_consumers,
+};
+
+static struct regulator_init_data sw3_init = {
+	.constraints = {
+		.name = "SW3",
+		.min_uV = mV_to_uV(1100),
+		.max_uV = mV_to_uV(1850),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE |
+			REGULATOR_CHANGE_STATUS,
+		.always_on = 1,
+		.boot_on = 1,
+	}
+};
+
+/* BT */
+static struct regulator_consumer_supply sw4_consumers[] = {
+	{
+		.supply = "SW4",
+	},
+	{
+		.supply = "SW4-LCD",
+	},
+	{
+		.supply = "SW4-CAM",
+	}
+};
+static struct regulator_init_data sw4_init = {
+	.constraints = {
+		.name = "SW4",
+		.min_uV = mV_to_uV(1100),
+		.max_uV = mV_to_uV(1850),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE |
+			REGULATOR_CHANGE_STATUS,
+		.always_on = 1,
+		.boot_on = 1,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(sw4_consumers),
+	.consumer_supplies = sw4_consumers,
+};
+
+/* LCD */
+static struct regulator_consumer_supply viohi_consumers[] = {
+	{
+		.supply = "VIOHI",
+	},
+	{
+		.supply = "VIOHI-CAM",
+	}
+};
+static struct regulator_init_data viohi_init = {
+	.constraints = {
+		.name = "VIOHI",
+		.boot_on = 1,
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE |
+			REGULATOR_CHANGE_STATUS,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(viohi_consumers),
+	.consumer_supplies = viohi_consumers,
+};
+
+static struct regulator_init_data vusb_init = {
+	.constraints = {
+		.name = "VUSB",
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data swbst_init = {
+	.constraints = {
+		.name = "SWBST",
+	}
+};
+
+/* TVE */
+static struct regulator_consumer_supply vdig_consumers[] = {
+	{
+		.supply = "VDIG",
+	}
+};
+static struct regulator_init_data vdig_init = {
+	.constraints = {
+		.name = "VDIG",
+		.min_uV = mV_to_uV(1050),
+		.max_uV = mV_to_uV(1800),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE |
+			REGULATOR_CHANGE_STATUS,
+		.boot_on = 1,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(vdig_consumers),
+	.consumer_supplies = vdig_consumers,
+};
+
+static struct regulator_init_data vpll_init = {
+	.constraints = {
+		.name = "VPLL",
+		.min_uV = mV_to_uV(1050),
+		.max_uV = mV_to_uV(1800),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE |
+			REGULATOR_CHANGE_STATUS,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vusb2_init = {
+	.constraints = {
+		.name = "VUSB2",
+		.min_uV = mV_to_uV(2400),
+		.max_uV = mV_to_uV(2775),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE |
+			REGULATOR_CHANGE_STATUS,
+		.boot_on = 1,
+	}
+};
+
+/* TVE */
+static struct regulator_consumer_supply vvideo_consumers[] = {
+	{
+		.supply = "VVIDEO",
+	}
+};
+static struct regulator_init_data vvideo_init = {
+	.constraints = {
+		.name = "VVIDEO",
+		.min_uV = mV_to_uV(2500),
+		.max_uV = mV_to_uV(2775),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE |
+			REGULATOR_CHANGE_STATUS,
+	},
+	.num_consumer_supplies = ARRAY_SIZE(vvideo_consumers),
+	.consumer_supplies = vvideo_consumers,
+};
+
+static struct regulator_init_data vaudio_init = {
+	.constraints = {
+		.name = "VAUDIO",
+		.min_uV = mV_to_uV(2300),
+		.max_uV = mV_to_uV(3000),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE |
+			REGULATOR_CHANGE_STATUS,
+	}
+};
+
+static struct regulator_init_data vsd_init = {
+	.constraints = {
+		.name = "VSD",
+		.min_uV = mV_to_uV(1800),
+		.max_uV = mV_to_uV(3150),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE |
+			REGULATOR_CHANGE_STATUS,
+	}
+};
+
+static struct regulator_init_data vcam_init = {
+	.constraints = {
+		.name = "VCAM",
+		.min_uV = mV_to_uV(2500),
+		.max_uV = mV_to_uV(3000),
+		.valid_ops_mask =
+			REGULATOR_CHANGE_VOLTAGE | REGULATOR_CHANGE_MODE |
+			REGULATOR_CHANGE_STATUS,
+		.valid_modes_mask = REGULATOR_MODE_FAST |
+			REGULATOR_MODE_NORMAL,
+	}
+};
+
+static struct regulator_init_data vgen1_init = {
+	.constraints = {
+		.name = "VGEN1",
+		.min_uV = mV_to_uV(1200),
+		.max_uV = mV_to_uV(3150),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE |
+			REGULATOR_CHANGE_STATUS,
+	}
+};
+
+static struct regulator_init_data vgen2_init = {
+	.constraints = {
+		.name = "VGEN2",
+		.min_uV = mV_to_uV(1200),
+		.max_uV = mV_to_uV(3150),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE |
+			REGULATOR_CHANGE_STATUS,
+		.boot_on = 1,
+	}
+};
+
+static struct regulator_init_data vgen3_init = {
+	.constraints = {
+		.name = "VGEN3",
+		.min_uV = mV_to_uV(1800),
+		.max_uV = mV_to_uV(2900),
+		.valid_ops_mask = REGULATOR_CHANGE_VOLTAGE |
+			REGULATOR_CHANGE_STATUS,
+	}
+};
+
+static struct regulator_init_data gpo1_init = {
+	.constraints = {
+		.name = "GPO1",
+	}
+};
+
+/* SGTL5000 */
+static struct regulator_consumer_supply gpo2_consumers[] = {
+	{
+		.supply = "GPO2",
+	}
+};
+static struct regulator_init_data gpo2_init = {
+	.constraints = {
+		.name = "GPO2",
+	},
+	.num_consumer_supplies = ARRAY_SIZE(gpo2_consumers),
+	.consumer_supplies = gpo2_consumers,
+};
+
+static struct regulator_init_data gpo3_init = {
+	.constraints = {
+		.name = "GPO3",
+	}
+};
+
+static struct regulator_init_data gpo4_init = {
+	.constraints = {
+		.name = "GPO4",
+	}
+};
+
+/*!
+ * the event handler for power on event
+ */
+static void power_on_evt_handler(void)
+{
+	pr_info("pwr on event1 is received\n");
+}
+
+static int mc13892_regulator_init(struct mc13892 *mc13892)
+{
+	unsigned int value;
+	pmic_event_callback_t power_key_event;
+	int register_mask;
+
+	pr_info("Initializing regulators for 3-stack.\n");
+	if (mxc_cpu_is_rev(CHIP_REV_2_0) < 0)
+		sw2_init.constraints.state_mem.uV = 1100000;
+	else if (mxc_cpu_is_rev(CHIP_REV_2_0) == 1) {
+		sw2_init.constraints.state_mem.uV = 1250000;
+		sw1_init.constraints.state_mem.uV = 1000000;
+	}
+
+	/* subscribe PWRON1 event to enable ON_OFF key */
+	power_key_event.param = NULL;
+	power_key_event.func = (void *)power_on_evt_handler;
+	pmic_event_subscribe(EVENT_PWRONI, power_key_event);
+
+	/* Bit 4 DRM: keep VSRTC and CLK32KMCU on for all states */
+#if defined(CONFIG_RTC_DRV_MXC_V2) || defined(CONFIG_RTC_DRV_MXC_V2_MODULE)
+	value = BITFVAL(DRM, 1);
+	register_mask = BITFMASK(DRM);
+	pmic_write_reg(REG_POWER_CTL0, value, register_mask);
+#endif
+	/* Set the STANDBYSECINV bit, so that STANDBY pin is
+	 * interpreted as active low.
+	 */
+	value = BITFVAL(STANDBYSECINV, 1);
+	register_mask = BITFMASK(STANDBYSECINV);
+	pmic_write_reg(REG_POWER_CTL2, value, register_mask);
+
+	/* Enable coin cell charger */
+	value = BITFVAL(CIONCHEN, 1) | BITFVAL(VCOIN, VCOIN_3_0V);
+	register_mask = BITFMASK(CIONCHEN) | BITFMASK(VCOIN);
+	pmic_write_reg(REG_POWER_CTL0, value, register_mask);
+
+	mc13892_register_regulator(mc13892, MC13892_SW1, &sw1_init);
+	mc13892_register_regulator(mc13892, MC13892_SW2, &sw2_init);
+	mc13892_register_regulator(mc13892, MC13892_SW3, &sw3_init);
+	mc13892_register_regulator(mc13892, MC13892_SW4, &sw4_init);
+	mc13892_register_regulator(mc13892, MC13892_SWBST, &swbst_init);
+	mc13892_register_regulator(mc13892, MC13892_VIOHI, &viohi_init);
+	mc13892_register_regulator(mc13892, MC13892_VPLL, &vpll_init);
+	mc13892_register_regulator(mc13892, MC13892_VDIG, &vdig_init);
+	mc13892_register_regulator(mc13892, MC13892_VSD, &vsd_init);
+	mc13892_register_regulator(mc13892, MC13892_VUSB2, &vusb2_init);
+	mc13892_register_regulator(mc13892, MC13892_VVIDEO, &vvideo_init);
+	mc13892_register_regulator(mc13892, MC13892_VAUDIO, &vaudio_init);
+	mc13892_register_regulator(mc13892, MC13892_VCAM, &vcam_init);
+	mc13892_register_regulator(mc13892, MC13892_VGEN1, &vgen1_init);
+	mc13892_register_regulator(mc13892, MC13892_VGEN2, &vgen2_init);
+	mc13892_register_regulator(mc13892, MC13892_VGEN3, &vgen3_init);
+	mc13892_register_regulator(mc13892, MC13892_VUSB, &vusb_init);
+	mc13892_register_regulator(mc13892, MC13892_GPO1, &gpo1_init);
+	mc13892_register_regulator(mc13892, MC13892_GPO2, &gpo2_init);
+	mc13892_register_regulator(mc13892, MC13892_GPO3, &gpo3_init);
+	mc13892_register_regulator(mc13892, MC13892_GPO4, &gpo4_init);
+
+	return 0;
+}
+
+static struct mc13892_platform_data mc13892_plat = {
+	.init = mc13892_regulator_init,
+};
+
+static struct i2c_board_info __initdata mc13892_i2c_device = {
+	I2C_BOARD_INFO("mc13892", 0x08),
+	.irq = IOMUX_TO_IRQ(MX51_PIN_GPIO1_5),
+	.platform_data = &mc13892_plat,
+};
+
+int __init mx51_3stack_init_mc13892(void)
+{
+	return i2c_register_board_info(1, &mc13892_i2c_device, 1);
+}
-- 
1.6.5.2

