From 32277a5272ffcc81633672308ba4c4cce6dc823e Mon Sep 17 00:00:00 2001
From: Li Yang <leoli@freescale.com>
Date: Thu, 4 Feb 2010 20:58:24 +0800
Subject: [PATCH 04/12] powerpc/85xx: talitos: make SEC controller shareable through CAMP OSes

Extracted from the P1020RDB_20100507-ltib.iso vendor drop

Make use of the channel remapping mechanism to enable OSes on CAMP system to
use the Security Engine block at the same time.

Signed-off-by: Li Yang <leoli@freescale.com>

Fixed the build failure of undefined smp_processor_id and the following bug:

BUG: using smp_processor_id() in preemptible [00000000] code: portmap/411
caller is talitos_submit+0x204/0x208
Call Trace:
[df391690] [c0007e94] show_stack+0x44/0x160 (unreliable)
[df3916c0] [c026b154] debug_smp_processor_id+0xdc/0xec
[df3916e0] [c03a3048] talitos_submit+0x204/0x208
[df391710] [c03a54a8] ipsec_esp+0x2e8/0x3a4
[df391750] [e2428390] esp_output+0x294/0x308 [esp4]
[df3917b0] [c044d24c] xfrm_output_resume+0x220/0x3bc
[df3917f0] [c0441434] xfrm4_output_finish+0x38/0x78
[df391800] [c03ff50c] ip_local_out+0x34/0x48
[df391810] [c03ff7a0] ip_push_pending_frames+0x280/0x3b0
[df391840] [c0420f7c] udp_push_pending_frames+0x108/0x494
[df391870] [c0423360] udp_sendmsg+0x3ec/0x6a8
[df391930] [c042a984] inet_sendmsg+0x38/0x7c
[df391950] [c03b907c] sock_sendmsg+0xc0/0x160
[df391a30] [c03b9148] kernel_sendmsg+0x2c/0x44
[df391a40] [c045d500] xs_send_kvec+0x98/0xa8
[df391a80] [c045d590] xs_sendpages+0x80/0x270
[df391ab0] [c045da64] xs_udp_send_request+0x60/0x168
[df391ad0] [c045b310] xprt_transmit+0x70/0x2b0
[df391af0] [c045839c] call_transmit+0x1b8/0x290
[df391b10] [c0460770] __rpc_execute+0xc4/0x2fc
[df391b60] [c0458ec0] rpc_run_task+0x44/0x90
[df391b70] [c0459038] rpc_call_sync+0x50/0x80
[df391ba0] [c01d0a3c] T.1021+0x40/0x7c
[df391bb0] [c01d18b0] nfs_proc_getattr+0x54/0xa8
[df391be0] [c01c77d0] __nfs_revalidate_inode+0xe4/0x204
[df391ca0] [c01c0be0] nfs_lookup_revalidate+0x28c/0x470
[df391de0] [c012562c] do_lookup+0x84/0x228
[df391e10] [c012740c] do_last+0x360/0x74c
[df391e40] [c0129dbc] do_filp_open+0x1dc/0x628
[df391f20] [c01187e4] do_sys_open+0x64/0x198
[df391f40] [c001145c] ret_from_syscall+0x0/0x4

Integrated-by: Wu Zhangjin <zhangjin.wu@windriver.com>
---
 drivers/crypto/talitos.c |  172 ++++++++++++++++++++++++++++++----------------
 1 files changed, 113 insertions(+), 59 deletions(-)

diff --git a/drivers/crypto/talitos.c b/drivers/crypto/talitos.c
index 273cc07..45e05d1 100644
--- a/drivers/crypto/talitos.c
+++ b/drivers/crypto/talitos.c
@@ -112,8 +112,9 @@ struct talitos_private {
 	struct device *dev;
 	struct of_device *ofdev;
 	void __iomem *reg;
-	int irq_0;
-	int irq_1;
+	int irq[MAX_GROUPS];
+	int dual;
+	int secondary;
 
 	/* SEC version geometry (from device tree node) */
 	unsigned int num_channels;
@@ -187,6 +188,27 @@ static inline unsigned int get_chan_remap(struct talitos_private *priv)
 	return priv->chan_remap;
 }
 
+static inline int is_channel_alt(int ch, struct talitos_private *priv)
+{
+	return (1 << (priv->num_channels - ch - 1)) & get_chan_remap(priv);
+}
+
+static inline int is_channel_used(int ch, struct talitos_private *priv)
+{
+	if (priv->dual)
+		return 1;
+
+	if (priv->secondary)
+		return is_channel_alt(ch, priv);
+	else
+		return !is_channel_alt(ch, priv);
+}
+
+static inline int get_grp_id(struct talitos_private *priv)
+{
+	return priv->dual ? raw_smp_processor_id() : priv->secondary;
+}
+
 static void to_talitos_ptr(struct talitos_ptr *talitos_ptr, dma_addr_t dma_addr)
 {
 	talitos_ptr->ptr = cpu_to_be32(lower_32_bits(dma_addr));
@@ -334,20 +356,21 @@ static int talitos_submit(struct device *dev, struct talitos_desc *desc,
 	struct talitos_private *priv = dev_get_drvdata(dev);
 	struct talitos_request *request;
 	u8 ch;
-	u8 smp_processor_id = smp_processor_id();
+	int grp_id = get_grp_id(priv);
+
 	u8 head, last_chan, total_chan;
-	if (priv->core_num_chan[smp_processor_id] > 0) {
-		total_chan = priv->core_num_chan[smp_processor_id];
-		last_chan = priv->last_chan[smp_processor_id];
+	if (priv->core_num_chan[grp_id] > 0) {
+		total_chan = priv->core_num_chan[grp_id];
+		last_chan = priv->last_chan[grp_id];
 		/* select done notification */
 		desc->hdr |= DESC_HDR_DONE_NOTIFY;
 
 		if (last_chan <  total_chan) {
-			ch = priv->core_chan_no[smp_processor_id][last_chan];
-			priv->last_chan[smp_processor_id]++;
+			ch = priv->core_chan_no[grp_id][last_chan];
+			priv->last_chan[grp_id]++;
 		} else {
-			ch = priv->core_chan_no[smp_processor_id][0];
-			priv->last_chan[smp_processor_id] = 1;
+			ch = priv->core_chan_no[grp_id][0];
+			priv->last_chan[grp_id] = 1;
 		}
 		if (priv->chan[ch].submit_count != 0)
 			++priv->chan[ch].submit_count;
@@ -438,15 +461,15 @@ static void flush_channel(struct talitos_channel *chan, int error, int reset_ch)
  */
 static void talitos_done(unsigned long data)
 {
-	u8 smp_processor_id = smp_processor_id();
 	struct device *dev = (struct device *)data;
 	struct talitos_private *priv = dev_get_drvdata(dev);
+	int grp_id = get_grp_id(priv);
 	u8 ch;
 
-	if (priv->core_num_chan[smp_processor_id] > 0)
-		for (ch = 0; ch < priv->core_num_chan[smp_processor_id]; ch++)
+	if (priv->core_num_chan[grp_id] > 0)
+		for (ch = 0; ch < priv->core_num_chan[grp_id]; ch++)
 			flush_channel(priv->chan +
-				priv->core_chan_no[smp_processor_id][ch], 0, 0);
+				priv->core_chan_no[grp_id][ch], 0, 0);
 	/* At this point, all completed channels have been processed.
 	 * Unmask done interrupts for channels completed later on.
 	 */
@@ -632,14 +655,15 @@ static void talitos_error(void *data, u32 isr, u32 isr_lo)
 {
 	struct talitos_private *priv = data;
 	u8 i = 0;
-	u8 smp_processor_id = smp_processor_id();
-	if (priv->core_num_chan[smp_processor_id] > 0)
-		for (i = 0; i < priv->core_num_chan[smp_processor_id]; i++) {
+	int grp_id = get_grp_id(priv);
+
+	if (priv->core_num_chan[grp_id] > 0)
+		for (i = 0; i < priv->core_num_chan[grp_id]; i++) {
 			if (isr & (1 <<
-				((priv->core_chan_no[smp_processor_id][i] << 1)
+				((priv->core_chan_no[grp_id][i] << 1)
 				+ 1)))
 				handle_error(priv->chan +
-					priv->core_chan_no[smp_processor_id][i],
+					priv->core_chan_no[grp_id][i],
 					isr, isr_lo);
 		}
 }
@@ -649,13 +673,13 @@ static irqreturn_t talitos_interrupt(int irq, void *data)
 	struct talitos_private *priv = data;
 	u32 isr, isr_lo, isr_ack = 0;
 	u32 intr_mask = 0, isr_ack1 = 0;
-	u16 smp_processor_id = smp_processor_id();
+	int grp_id = get_grp_id(priv);
 	isr = in_be32(priv->reg + TALITOS_ISR);
 	isr_lo = in_be32(priv->reg + TALITOS_ISR_LO);
 
-	if (priv->core_num_chan[smp_processor_id] > 0) {
-		intr_mask = priv->chan_imr[smp_processor_id];
-		isr_ack = 0xffffff00 | priv->chan_isr[smp_processor_id];
+	if (priv->core_num_chan[grp_id] > 0) {
+		intr_mask = priv->chan_imr[grp_id];
+		isr_ack = 0xffffff00 | priv->chan_isr[grp_id];
 		isr = isr & isr_ack;
 		/* Acknowledge interrupt */
 		out_be32(priv->reg + TALITOS_ICR, isr);
@@ -670,7 +694,7 @@ static irqreturn_t talitos_interrupt(int irq, void *data)
 				clrbits32(priv->reg + TALITOS_IMR, intr_mask);
 				/* Schdeule  respective tasklet */
 				tasklet_schedule(per_cpu_ptr(priv->done_task,
-					smp_processor_id));
+					grp_id));
 			}
 		}
 	} else {
@@ -1807,14 +1831,14 @@ static int talitos_remove(struct of_device *ofdev)
 
 	kfree(priv->chan);
 
-	if (priv->irq_1 != NO_IRQ) {
-		free_irq(priv->irq_1, dev);
-		irq_dispose_mapping(priv->irq_1);
+	if (priv->irq[1] != NO_IRQ) {
+		free_irq(priv->irq[1], dev);
+		irq_dispose_mapping(priv->irq[1]);
 	}
 
-	if (priv->irq_0 != NO_IRQ) {
-		free_irq(priv->irq_0, dev);
-		irq_dispose_mapping(priv->irq_0);
+	if (priv->irq[0] != NO_IRQ) {
+		free_irq(priv->irq[0], dev);
+		irq_dispose_mapping(priv->irq[0]);
 	}
 
 	for_each_possible_cpu(i)
@@ -1878,8 +1902,9 @@ static int talitos_probe(struct of_device *ofdev,
 	struct device_node *np = ofdev->node;
 	struct talitos_private *priv;
 	const unsigned int *prop;
+	const char *name;
 	int i, err;
-	u8 smp_processor_id;
+	int grp_id;
 
 	priv = kzalloc(sizeof(struct talitos_private), GFP_KERNEL);
 	if (!priv)
@@ -1898,21 +1923,46 @@ static int talitos_probe(struct of_device *ofdev,
 
 	INIT_LIST_HEAD(&priv->alg_list);
 
-	priv->irq_0 = irq_of_parse_and_map(np, 0);
+	name = of_get_property(np, "fsl,multi-host-mode", NULL);
+	if (!name || !strcmp(name, "primary")) {
+		priv->dual = 0;
+		priv->secondary = 0;
+	} else if (!strcmp(name, "secondary")) {
+		priv->dual = 0;
+		priv->secondary = 1;
+	} else if (!strcmp(name, "dual")) {
+		if (nr_cpu_ids != 2) {
+			dev_err(dev, "can't work in dual host mode with CPU "
+					"number not equal to 2\n");
+			err = -EINVAL;
+			goto err_out;
+		}
+		priv->dual = 1;
+		priv->secondary = 0;
+	} else {
+		dev_err(dev, "invalid multi-host-mode in device tree node\n");
+		err = -EINVAL;
+		goto err_out;
+	}
 
-	if (priv->irq_0 == NO_IRQ) {
-		dev_err(dev, "failed to map irq_0\n");
+	if (priv->secondary)
+		priv->irq[0] = irq_of_parse_and_map(np, 1);
+	else
+		priv->irq[0] = irq_of_parse_and_map(np, 0);
+
+	if (priv->irq[0] == NO_IRQ) {
+		dev_err(dev, "failed to map irq[0]\n");
 		err = -EINVAL;
 		goto err_out;
 	}
 
 	/* get the irq line */
-	err = request_irq(priv->irq_0, talitos_interrupt, 0,
+	err = request_irq(priv->irq[0], talitos_interrupt, 0,
 			  dev_driver_string(dev), priv);
 	if (err) {
-		dev_err(dev, "failed to request irq_0 %d\n", priv->irq_0);
-		irq_dispose_mapping(priv->irq_0);
-		priv->irq_0 = NO_IRQ;
+		dev_err(dev, "failed to request irq[0] %d\n", priv->irq[0]);
+		irq_dispose_mapping(priv->irq[0]);
+		priv->irq[0] = NO_IRQ;
 		goto err_out;
 	}
 
@@ -1953,33 +2003,32 @@ static int talitos_probe(struct of_device *ofdev,
 		if (prop)
 			priv->chan_remap = *prop;
 		update_chanmap(priv, priv->chan_remap);
-		if (priv->chan_remap) {
-			priv->irq_1 = irq_of_parse_and_map(np, 1);
+		if (priv->chan_remap && priv->dual) {
+			priv->irq[1] = irq_of_parse_and_map(np, 1);
 
-			if (priv->irq_1 == NO_IRQ) {
-				dev_err(dev, "failed to map irq_1\n");
+			if (priv->irq[1] == NO_IRQ) {
+				dev_err(dev, "failed to map irq[1]\n");
 				err = -EINVAL;
 				goto err_out;
 			}
-			/* get the irq_1 line */
-			err = request_irq(priv->irq_1, talitos_interrupt, 0,
+			/* get the irq[1] line */
+			err = request_irq(priv->irq[1], talitos_interrupt, 0,
 					dev_driver_string(dev), priv);
 			if (err) {
-				dev_err(dev, "failed to request irq_1 %d\n",
-					priv->irq_1);
-				irq_dispose_mapping(priv->irq_1);
-				priv->irq_1 = NO_IRQ;
+				dev_err(dev, "failed to request irq[1] %d\n",
+					priv->irq[1]);
+				irq_dispose_mapping(priv->irq[1]);
+				priv->irq[1] = NO_IRQ;
 				goto err_out;
 			}
 		}
 	}
-	for (smp_processor_id = 0; smp_processor_id < NR_CPUS;
-				smp_processor_id++) {
-		for (i = 0; i < priv->core_num_chan[smp_processor_id]; i++) {
-			priv->chan_isr[smp_processor_id] +=
-			MAP_ARRAY(priv->core_chan_no[smp_processor_id][i]);
-			priv->chan_imr[smp_processor_id] +=
-			MAP_ARRAY_DONE(priv->core_chan_no[smp_processor_id][i]);
+	for (grp_id = 0; grp_id < MAX_GROUPS; grp_id++) {
+		for (i = 0; i < priv->core_num_chan[grp_id]; i++) {
+			priv->chan_isr[grp_id] +=
+			MAP_ARRAY(priv->core_chan_no[grp_id][i]);
+			priv->chan_imr[grp_id] +=
+			MAP_ARRAY_DONE(priv->core_chan_no[grp_id][i]);
 		}
 	}
 	if (of_device_is_compatible(np, "fsl,sec2.1"))
@@ -2003,6 +2052,9 @@ static int talitos_probe(struct of_device *ofdev,
 	priv->fifo_len = roundup_pow_of_two(priv->chfifo_len);
 
 	for (i = 0; i < priv->num_channels; i++) {
+		/* save memory, remove if dynamic channel map is used */
+		if (!is_channel_used(i, priv))
+			continue;
 		priv->chan[i].fifo = kzalloc(sizeof(struct talitos_request) *
 					     priv->fifo_len, GFP_KERNEL);
 		if (!priv->chan[i].fifo) {
@@ -2019,10 +2071,12 @@ static int talitos_probe(struct of_device *ofdev,
 	dma_set_mask(dev, DMA_BIT_MASK(36));
 
 	/* reset and initialize the h/w */
-	err = init_device(dev);
-	if (err) {
-		dev_err(dev, "failed to initialize device\n");
-		goto err_out;
+	if (!priv->secondary) {
+		err = init_device(dev);
+		if (err) {
+			dev_err(dev, "failed to initialize device\n");
+			goto err_out;
+		}
 	}
 
 	/* register the RNG, if available */
-- 
1.6.5.2

