From 707bba2912ef0b4ae440e2109fb46b212022d7a6 Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Sun, 15 Jul 2012 11:55:12 +0800
Subject: [PATCH] nlm_xlp_64_be: add XLP316 B0 support

Add XLP316 B0 support. Based on Broadcom SDK 2.2.4.

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/netlogic/hal/nlm_hal.h       |    1 +
 .../include/asm/netlogic/hal/nlm_hal_xlp_dev.h     |   19 ++-
 arch/mips/netlogic/common/nlm_hal_cpu_info.c       |  164 ++++++++++++++++++--
 3 files changed, 169 insertions(+), 15 deletions(-)

diff --git a/arch/mips/include/asm/netlogic/hal/nlm_hal.h b/arch/mips/include/asm/netlogic/hal/nlm_hal.h
index 3548e7e..c8866c8 100644
--- a/arch/mips/include/asm/netlogic/hal/nlm_hal.h
+++ b/arch/mips/include/asm/netlogic/hal/nlm_hal.h
@@ -33,6 +33,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 
 struct nlm_netl_proc_info{
 	unsigned int proc_id;
+	unsigned int chipid;/*example: 832, 316 etc*/
 	int revision;
 	char cpu_info_str[32];
 };
diff --git a/arch/mips/include/asm/netlogic/hal/nlm_hal_xlp_dev.h b/arch/mips/include/asm/netlogic/hal/nlm_hal_xlp_dev.h
index 78108ab..9525ee4 100644
--- a/arch/mips/include/asm/netlogic/hal/nlm_hal_xlp_dev.h
+++ b/arch/mips/include/asm/netlogic/hal/nlm_hal_xlp_dev.h
@@ -86,8 +86,25 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define XLP_REVISION_A2 	0x02
 #define XLP_REVISION_B0	 	0x03
 #define XLP_REVISION_B1		0x04
+#define XLP_REVISION_AX		0xAF
 #define XLP_REVISION_BX		0xBF
+#ifndef XLP_REVISION_ANY
+#define XLP_REVISION_ANY	0xFF
+#endif
 
+#define XLP3XX_REVISION_A0	0x00
+#define XLP3XX_REVISION_A1	0x01
+#define XLP3XX_REVISION_B0	0x02
+#define XLP3XX_REVISION_B1	0x03
+/*XLP 3XX EXTPID type */
+#define CPU_EXTPID_XLP_3XX_NONE		0x00 /* Default */
+#define CPU_EXTPID_XLP_3XX_L		0x01 /* Lite */
+#define CPU_EXTPID_XLP_3XX_LP		0x02 /* Lite Plus */
+#define CPU_EXTPID_XLP_3XX_LP2		0x03 /* Lite Plus2 */
+#define CPU_EXTPID_XLP_3XX_MAX		0x04
+
+#define CPU_EXTPID_XLP_3XX_INV		0xFE /* invalid */
+#define CPU_EXTPID_XLP_3XX_ANY		0xFF /* Any 3XX */
 /*
  *    FMN
  */
diff --git a/arch/mips/netlogic/common/nlm_hal_cpu_info.c b/arch/mips/netlogic/common/nlm_hal_cpu_info.c
index 559679a..fe41dd0 100644
--- a/arch/mips/netlogic/common/nlm_hal_cpu_info.c
+++ b/arch/mips/netlogic/common/nlm_hal_cpu_info.c
@@ -93,6 +93,74 @@ static  void get_cpu_rev(int *revid, char *rev)
 	return;
 }
 
+inline int get_nlm_xlp3xx_rev(void)
+{
+	int hw_rev = nlm_read_prid() & 0xff;
+	int sw_rev;
+	if (hw_rev >= XLP3XX_REVISION_B0)
+		sw_rev = hw_rev + 1;
+	else
+		sw_rev = hw_rev;
+	return sw_rev;
+}
+
+/************************************************
+* match the chip revision with 'rev'
+ * rev:  revision number
+		single match: XLP_REVISION_A0 etc
+		multi-match:  XLP_REVISION_AX/_BX/_XX
+*************************************************/
+inline int is_nlm_xlp3xx_rev_xx(uint32_t rev)
+{
+	int sw_rev = get_nlm_xlp3xx_rev();
+	uint32_t rev_b0 = XLP_REVISION_B0;
+	if (rev == sw_rev)
+		return 1;
+	if (rev == XLP_REVISION_AX && sw_rev < rev_b0)
+		return 1;
+	if (rev == XLP_REVISION_BX && (rev_b0 <= sw_rev))
+		return 1;
+	if (rev == XLP_REVISION_ANY)
+		return 1;
+
+	return 0;
+}
+
+/******************************************************
+match storm
+num_cpu: 16-xlp316,  8-xlp308, 4-xlp304;  0xff any cpu number is valid match
+rev:  chip revision,
+type: CPU_EXTPID_XLP_3XX_NONE, CPU_EXTPID_XLP_3XX_L,
+	CPU_EXTPID_XLP_3XX_LP, CPU_EXTPID_XLP_3XX_LP2
+*******************************************************/
+#define CPU_NUM_ANY  0	/*any cpu number will be matched*/
+inline int is_xlp3xx(uint8_t num_cpu, uint32_t rev, uint32_t exttype)
+{
+	uint32_t pid, cfg0, mask;
+	uint8_t storm;
+	int ret, cpuNum;
+
+	ret = is_nlm_xlp3xx_rev_xx(rev);
+	if (ret != 1)
+		return 0;
+
+	pid = get_proc_id();
+
+	if (pid == CHIP_PROCESSOR_ID_XLP_3XX) {
+		cfg0 = efuse_cfg0();
+		mask = cfg0 & 0xf;
+		storm = (uint8_t)((cfg0 >> 4) & 0xf);
+
+		cpuNum = (4-bitcount(mask)) << 2;
+		if ((cpuNum == num_cpu || num_cpu == CPU_NUM_ANY) &&
+			(exttype == CPU_EXTPID_XLP_3XX_ANY
+			|| storm == exttype))
+			return 1;
+	}
+
+    return 0;
+}
+
 static __inline__ int is_nlm_xlp_8_4_x(void)
 {
 	return (get_proc_id() == CHIP_PROCESSOR_ID_XLP_8_4_XX);
@@ -399,6 +467,66 @@ __inline__ int is_nlm_xlpxxx(void)
 	return (is_nlm_xlp8xx()||is_nlm_xlp3xx());
 }
 
+int  nlm_hal_get_chipid(void)
+{
+	int chipid = -1, cpuNum;
+	unsigned int cfg0, cfg1;
+	uint32_t pid = get_proc_id();
+
+	cfg0 = efuse_cfg0() ;
+	cfg1 = efuse_cfg1() ;
+
+	/*eagle 4xx 8xx BX, unfused chip treat as 8xx*/
+	if (pid == 0 || pid == CHIP_PROCESSOR_ID_XLP_8_4_XX) {
+		cpuNum = (8-bitcount(cfg0&0xFF))*4;
+
+		chipid = (cfg1&7) == 7 ? 400 : 800;
+		chipid += cpuNum;
+		return chipid;
+	}
+	if (pid == CHIP_PROCESSOR_ID_XLP_3XX) {
+		cpuNum = (4-bitcount(cfg0&0xF))*4;
+
+		chipid = 300 +  cpuNum;
+		return chipid;
+	}
+	if (pid == CHIP_PROCESSOR_ID_XLP_2XX) {
+		chipid = 200;
+		return chipid;
+	}
+	/*eagle 8xx AX*/
+	switch (pid) {
+	case CHIP_PROCESSOR_ID_XLP_832:
+		chipid = 832;
+		break;
+	case CHIP_PROCESSOR_ID_XLP_816:
+		chipid = 816;
+		break;
+	case CHIP_PROCESSOR_ID_XLP_432:
+		chipid = 432;
+		break;
+	case CHIP_PROCESSOR_ID_XLP_416:
+		chipid = 416;
+		break;
+	case CHIP_PROCESSOR_ID_XLP_408:
+		chipid = 408;
+		break;
+	case CHIP_PROCESSOR_ID_XLP_208:
+		chipid = 208;
+		break;
+	case CHIP_PROCESSOR_ID_XLP_204:
+		chipid = 204;
+		break;
+	case CHIP_PROCESSOR_ID_XLP_104:
+		chipid = 104;
+		break;
+	default:
+		break;
+	}
+
+	return chipid;
+}
+
 /**
  * Fill the nlm_netl_proc_info using nlm cpu apis.
  *
@@ -411,6 +539,11 @@ __inline__ int is_nlm_xlpxxx(void)
  */
 int  nlm_hal_get_cpuinfo(struct nlm_netl_proc_info* cpu_info)
 {
+	const static char c_typename[][8] = {"\0", "Lite", "Lite+",
+					"Lite+2", "Unknown"};
+	unsigned int sw_rev, chipid, type;
+	uint32_t cfg0, pid;
+
 	if(is_nlm_xlp8xx()){
 		strcpy(cpu_info->cpu_info_str, "XLP");
 		if(is_nlm_xlp8xx_b1()){
@@ -503,20 +636,23 @@ int  nlm_hal_get_cpuinfo(struct nlm_netl_proc_info* cpu_info)
 			return 1;
 		}
 	}
-	if(is_nlm_xlp3xx()){
-		cpu_info->proc_id = CHIP_PROCESSOR_ID_XLP_3XX;
-		strcpy(cpu_info->cpu_info_str, "XLP");
-		if(is_nlm_xlp316()){
-			strcat(cpu_info->cpu_info_str, "316");
-		}	
-		if(is_nlm_xlp308()){
-			strcat(cpu_info->cpu_info_str, "308");
-		}	
-		if(is_nlm_xlp304()){
-			strcat(cpu_info->cpu_info_str, "304");
-		}	
-		get_xlp3xx_extpid(cpu_info->cpu_info_str);
-		get_cpu_rev(&cpu_info->revision, cpu_info->cpu_info_str);
+	if (is_nlm_xlp3xx()) {
+		pid = get_proc_id();
+		chipid = nlm_hal_get_chipid();
+
+		memset(cpu_info, 0, sizeof(struct nlm_netl_proc_info));
+		cpu_info->proc_id = pid;
+		cpu_info->chipid = chipid;
+
+		sw_rev = get_nlm_xlp3xx_rev();
+		cpu_info->revision = sw_rev;
+		cfg0 =  efuse_cfg0();
+		type = (cfg0>>4) & 0xF;
+		if (CPU_EXTPID_XLP_3XX_LP2 < type)
+			type = CPU_EXTPID_XLP_3XX_LP2+1;
+		sprintf(cpu_info->cpu_info_str, "XLP%3d%s Rev %c%1d", chipid,
+			c_typename[type], (char)('A'+sw_rev/XLP_REVISION_B0),
+			sw_rev%XLP_REVISION_B0);
 		return 1;
 	}
 
-- 
1.7.0.4

