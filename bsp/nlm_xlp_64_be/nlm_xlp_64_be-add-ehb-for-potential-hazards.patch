From 56dd7e112e6527697b6842e62e681726156400fa Mon Sep 17 00:00:00 2001
From: Wu Zhangjin <zhangjin.wu@windriver.com>
Date: Thu, 7 Apr 2011 14:06:19 +0800
Subject: [PATCH 28/37] nlm_xlp_64_be: add ehb for potential hazards

According to section 3.2.3 of "XLP programming reference manual", add
ehb to make the interrupt state changes visible after the corresponding
registers are written.

At the same time, the functions defined by __BUILD_SET_C0() are
protected from the interrupts to ensure atomic operations.

Signed-off-by: Wu Zhangjin <zhangjin.wu@windriver.com>
---
 arch/mips/include/asm/mipsregs.h |   77 +++++++++++++++++++++++++++++++++++++-
 1 files changed, 76 insertions(+), 1 deletions(-)

diff --git a/arch/mips/include/asm/mipsregs.h b/arch/mips/include/asm/mipsregs.h
index 3e19ee4..c3ce069 100644
--- a/arch/mips/include/asm/mipsregs.h
+++ b/arch/mips/include/asm/mipsregs.h
@@ -888,7 +888,7 @@ do {									\
 #define write_c0_compare3(val)	__write_32bit_c0_register($11, 7, val)
 
 #define read_c0_status()	__read_32bit_c0_register($12, 0)
-#ifdef CONFIG_MIPS_MT_SMTC
+#if defined(CONFIG_MIPS_MT_SMTC) || defined(CONFIG_CPU_XLP)
 #define write_c0_status(val)						\
 do {									\
 	__write_32bit_c0_register($12, 0, val);				\
@@ -903,7 +903,14 @@ do {									\
 #endif /* CONFIG_MIPS_MT_SMTC */
 
 #define read_c0_cause()		__read_32bit_c0_register($13, 0)
+#ifdef CONFIG_CPU_XLP
+#define write_c0_cause(val) do {		\
+	__write_32bit_c0_register($13, 0, val);	\
+	__ehb();				\
+} while (0)
+#else
 #define write_c0_cause(val)	__write_32bit_c0_register($13, 0, val)
+#endif
 
 #define read_c0_epc()		__read_ulong_c0_register($14, 0)
 #define write_c0_epc(val)	__write_ulong_c0_register($14, 0, val)
@@ -1451,6 +1458,19 @@ static inline void tlb_write_random(void)
  * Manipulate bits in a c0 register.
  */
 #ifndef CONFIG_MIPS_MT_SMTC
+
+#ifdef CONFIG_CPU_XLP
+
+#include <linux/irqflags.h>
+
+static inline void __ehb(void)
+{
+	__asm__ __volatile__(
+	"	.set	mips32r2				\n"
+	"	ehb						\n"
+	"	.set	mips0					\n");
+}
+
 /*
  * SMTC Linux requires shutting-down microthread scheduling
  * during CP0 register read-modify-write sequences.
@@ -1460,10 +1480,13 @@ static inline unsigned int					\
 set_c0_##name(unsigned int set)					\
 {								\
 	unsigned int res, new;					\
+	unsigned long flags;					\
 								\
+	local_irq_save(flags);					\
 	res = read_c0_##name();					\
 	new = res | set;					\
 	write_c0_##name(new);					\
+	local_irq_restore(flags);				\
 								\
 	return res;						\
 }								\
@@ -1472,10 +1495,13 @@ static inline unsigned int					\
 clear_c0_##name(unsigned int clear)				\
 {								\
 	unsigned int res, new;					\
+	unsigned long flags;					\
 								\
+	local_irq_save(flags);					\
 	res = read_c0_##name();					\
 	new = res & ~clear;					\
 	write_c0_##name(new);					\
+	local_irq_restore(flags);				\
 								\
 	return res;						\
 }								\
@@ -1484,15 +1510,64 @@ static inline unsigned int					\
 change_c0_##name(unsigned int change, unsigned int val)		\
 {								\
 	unsigned int res, new;					\
+	unsigned long flags;					\
 								\
+	local_irq_save(flags);					\
 	res = read_c0_##name();					\
 	new = res & ~change;					\
 	new |= (val & change);					\
 	write_c0_##name(new);					\
+	local_irq_restore(flags);				\
 								\
 	return res;						\
 }
 
+#else /* !CONFIG_CPU_XLP */
+
+/*
+ * SMTC Linux requires shutting-down microthread scheduling
+ * during CP0 register read-modify-write sequences.
+ */
+#define __BUILD_SET_C0(name)					\
+static inline unsigned int					\
+set_c0_##name(unsigned int set)					\
+{								\
+	unsigned int res, new;					\
+								\
+	res = read_c0_##name();					\
+	new = res | set;					\
+	write_c0_##name(new);					\
+								\
+	return res;						\
+}								\
+								\
+static inline unsigned int					\
+clear_c0_##name(unsigned int clear)				\
+{								\
+	unsigned int res, new;					\
+								\
+	res = read_c0_##name();					\
+	new = res & ~clear;					\
+	write_c0_##name(new);					\
+								\
+	return res;						\
+}								\
+								\
+static inline unsigned int					\
+change_c0_##name(unsigned int change, unsigned int val)		\
+{								\
+	unsigned int res, new;					\
+								\
+	res = read_c0_##name();					\
+	new = res & ~change;					\
+	new |= (val & change);					\
+	write_c0_##name(new);					\
+								\
+	return res;						\
+}
+
+#endif	/* CONFIG_CPU_XLP */
+
 #else /* SMTC versions that manage MT scheduling */
 
 #include <linux/irqflags.h>
-- 
1.7.0.2

