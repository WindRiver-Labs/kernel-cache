From a0402085c8bf24cecf6dcd38d27886f33c5fb296 Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Mon, 27 Aug 2012 14:34:43 +0800
Subject: [PATCH 3/3] nlm_xlp_64_be: adjust PCI mem bar handling in LE

errata: Shadow BARs Are Always Big Endian

Adjust PCI mem bar special handling for A0, A1 and A2 chip revisions
in LittleEndian.

This works in tandem with bootloader configuration of PCI mem bar.
This workaround is only applied for xlp8xx.

Signed-off-by: Om Narasimhan <onarasimhan@netlogicmicro.com>
Integrated-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/pci/probe.c | 53 ++++++++++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 52 insertions(+), 1 deletion(-)

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index f4adba2..4958a0f 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -150,6 +150,56 @@ static inline enum pci_bar_type decode_bar(struct resource *res, u32 bar)
 	return pci_bar_mem32;
 }
 
+#if defined CONFIG_NLM_XLP && defined __LITTLE_ENDIAN
+#define NLM_HAL_LINUX_KERNEL
+#include <asm/netlogic/hal/nlm_hal.h>
+#include <asm/netlogic/xlp.h>
+#define XLP_PCI_DEV_BASE 0x1000
+
+static u32 nlm_xlp_membar_fixup(u32 l, struct pci_dev *dev,
+	unsigned int pos, enum pci_bar_type type)
+{
+	unsigned char b;
+	u32 fixup;
+	int rev;
+
+	if (!is_nlm_xlp8xx())
+		return l;
+
+	if (!l)
+		return l;
+	if (pci_calc_resource_flags(l) != IORESOURCE_MEM)
+		return l;
+	rev = read_c0_prid() & 0xff;
+	if (!((rev == XLP_REVISION_A0) || (rev == XLP_REVISION_A1) ||
+			(rev == XLP_REVISION_A2))) {
+		return l;
+	}
+	if ((dev->vendor != PCI_VENDOR_ID_NETLOGIC) &&
+			(dev->device < XLP_PCI_DEV_BASE))
+		return l;
+	if (type == pci_bar_unknown) {
+		if ((l & PCI_BASE_ADDRESS_SPACE) ==
+			PCI_BASE_ADDRESS_SPACE_MEMORY) {
+			if ((l & ~PCI_BASE_ADDRESS_MEM_MASK)
+				& PCI_BASE_ADDRESS_MEM_TYPE_64)
+				type = pci_bar_mem64;
+			else
+				type = pci_bar_mem32;
+		}
+	}
+	if ((type != pci_bar_mem32) && (type != pci_bar_mem64))
+		return l;
+
+	b = (l >> 24) & 0xff;
+	fixup = ((b << 24) | (b << 16) | (b << 8) | (b));
+	return fixup;
+}
+
+#else /* CONFIG_NLM_XLP && defined __LITTLE_ENDIAN */
+#define nlm_xlp_membar_fixup(x, u1, u2, u3)(x)
+#endif /* CONFIG_NLM_XLP && defined __LITTLE_ENDIAN */
+
 /**
  * pci_read_base - read a PCI BAR
  * @dev: the PCI device
@@ -171,7 +221,8 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 	pci_read_config_dword(dev, pos, &l);
 	pci_write_config_dword(dev, pos, l | mask);
 	pci_read_config_dword(dev, pos, &sz);
-	pci_write_config_dword(dev, pos, l);
+	pci_write_config_dword(dev, pos,
+		nlm_xlp_membar_fixup(l, dev, pos, type));
 
 	/*
 	 * All bits set in sz means the device isn't working properly.
-- 
1.7.11

