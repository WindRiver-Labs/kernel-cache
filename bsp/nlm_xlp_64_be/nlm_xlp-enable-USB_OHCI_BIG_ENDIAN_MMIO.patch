From 153c9aec5920f9441797f459885740a1fccd37c2 Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Tue, 14 May 2013 22:22:34 +0800
Subject: [PATCH] nlm_xlp: enable USB_OHCI_BIG_ENDIAN_MMIO

Enable USB_OHCI_BIG_ENDIAN_MMIO.

Based on commit 5799ff7090 from SDK 20130319-2.2.7.
Author: Prabhath P Raman <prabhath@broadcom.com>

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/usb/host/Kconfig    |    2 +-
 drivers/usb/host/ohci-pci.c |  108 ++++++++++++++++++++++---------------------
 2 files changed, 56 insertions(+), 54 deletions(-)

diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index f46c14f..196cfa9 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -275,7 +275,7 @@ config USB_OHCI_BIG_ENDIAN_DESC
 config USB_OHCI_BIG_ENDIAN_MMIO
 	bool
 	depends on USB_OHCI_HCD
-	default n
+	default y if NLM_XLP && CPU_BIG_ENDIAN
 
 config USB_OHCI_LITTLE_ENDIAN
 	bool
diff --git a/drivers/usb/host/ohci-pci.c b/drivers/usb/host/ohci-pci.c
index f774256..bf29f47 100644
--- a/drivers/usb/host/ohci-pci.c
+++ b/drivers/usb/host/ohci-pci.c
@@ -1,9 +1,17 @@
+/*-
+ * Copyright 2003-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
+
 /*
  * OHCI HCD (Host Controller Driver) for USB.
  *
  * (C) Copyright 1999 Roman Weissgaerber <weissg@vienna.at>
  * (C) Copyright 2000-2002 David Brownell <dbrownell@users.sourceforge.net>
- * (C) Copyright 2003-2010 Netlogic Microsystems Inc.
  *
  * [ Initialisation is based on Linus'  ]
  * [ uhci code and gregs ohci fragments ]
@@ -41,21 +49,18 @@ static struct pci_dev *amd_smbus_dev;
 static struct pci_dev *amd_hb_dev;
 static int amd_ohci_iso_count;
 
-#ifdef CONFIG_NLM_XLP
+#if defined(CONFIG_NLM_XLP) && defined(CONFIG_USB)
 
 #include <asm/netlogic/hal/nlm_hal.h>
 #include <asm/netlogic/xlp.h>
 #include <asm/netlogic/xlp_usb.h>
 
-extern int nlm_xlp_request_irq(int irq);
-
 static void xlp_usb_start_ohc(int ctrl_no)
 {
 	/* enable interrupts
 	 */
 	usb_reg_write(0, ctrl_no, XLP_USB_INT_EN,
 			USB_CTRL_INTERRUPT_EN
-			| USB_OHCI_INTERRUPT_EN
 			| USB_OHCI_INTERRUPT12_EN
 			| USB_OHCI_INTERRUPT1_EN);
 	return;
@@ -65,9 +70,10 @@ static void xlp_usb_stop_ohc(int ctrl_no)
 {
 	int val;
 
+	/* disable interrupts
+	 */
 	val = usb_reg_read(0, ctrl_no, XLP_USB_INT_EN);
 	val &= ~(USB_CTRL_INTERRUPT_EN
-			| USB_OHCI_INTERRUPT_EN
 			| USB_OHCI_INTERRUPT12_EN
 			| USB_OHCI_INTERRUPT1_EN);
 	usb_reg_write(0, ctrl_no, XLP_USB_INT_EN, val);
@@ -78,30 +84,25 @@ static void xlp_usb_stop_ohc(int ctrl_no)
 int xlp_ohci_hcd_pci_probe(struct pci_dev *dev,
 		const struct pci_device_id *id)
 {
-	int irq, irt, ctrl_no, ret;
+	int irq, irt, ctrl_no, val;
 
 	ctrl_no = dev->devfn & 0xF;
 
 	irt = usb_reg_read(0, ctrl_no, 0x3D) & 0xFFFF;
-	irq = nlm_xlp_request_irq(irt);
+	irq = nlm_xlp_request_irq(xlp_soc_pcidev_to_node(dev), irt);
 
 	if (!irq) {
-		pr_err("Found HC with no IRQ.  Check BIOS/PCI %s setup!\n",
-				pci_name(dev));
+		printk(KERN_ERR "Found HC with no IRQ. Check BIOS/PCI %s setup!\n",
+			pci_name(dev));
 		return -ENODEV;
 	}
 
 	dev->irq = irq;
-	pr_info("%s: ohci irq = %d\n", __func__, dev->irq);
-	/* Stop it before probing */
-	xlp_usb_stop_ohc(ctrl_no);
-	ret = usb_hcd_pci_probe(dev, id);
-	if (ret)
-		pr_err("%s: Fail to probe xlp ohci\n", __func__);
-	else
-		xlp_usb_start_ohc(ctrl_no);
+	val = usb_hcd_pci_probe(dev, id);
 
-	return ret;
+	if (is_nlm_xlp8xx() || is_nlm_xlp3xx())
+		xlp_usb_start_ohc(ctrl_no);
+	return val;
 }
 
 void xlp_ohci_hcd_pci_remove(struct pci_dev *dev)
@@ -109,11 +110,22 @@ void xlp_ohci_hcd_pci_remove(struct pci_dev *dev)
 	int ctrl_no;
 
 	ctrl_no = dev->devfn & 0xF;
-
 	xlp_usb_stop_ohc(ctrl_no);
+
 	usb_hcd_pci_remove(dev);
+	return;
 }
 
+void xlp_ohci_hcd_pci_shutdown(struct pci_dev *dev)
+{
+	int ctrl_no;
+
+	ctrl_no = dev->devfn & 0xF;
+	xlp_usb_stop_ohc(ctrl_no);
+
+	usb_hcd_pci_shutdown(dev);
+	return;
+}
 #endif
 
 /*-------------------------------------------------------------------------*/
@@ -457,19 +469,7 @@ static int ohci_pci_reset (struct usb_hcd *hcd)
 			quirk = (void *)quirk_id->driver_data;
 			ret = quirk(hcd);
 		}
-		switch (pdev->vendor) {
-		case PCI_VENDOR_ID_NETLOGIC:
-			/* XLP USB controller doesn't work with >2GB RAM */
-			if (pci_set_consistent_dma_mask(pdev,
-						DMA_BIT_MASK(31)) < 0)
-				ohci_warn(ohci, "can't enable XLP "
-						"workaround for >2GB RAM\n");
-			else
-				ohci_info(ohci, "Enable XLP workaround for >2GB RAM\n");
-			break;
-		}
 	}
-
 	if (ret == 0) {
 		ohci_hcd_init (ohci);
 		return ohci_init (ohci);
@@ -603,40 +603,42 @@ static const struct hc_driver ohci_pci_hc_driver = {
 
 /*-------------------------------------------------------------------------*/
 
-#ifndef CONFIG_NLM_XLP
-static const struct pci_device_id pci_ids [] = { {
-	/* handle any USB OHCI controller */
-	PCI_DEVICE_CLASS(PCI_CLASS_SERIAL_USB_OHCI, ~0),
-	.driver_data =	(unsigned long) &ohci_pci_hc_driver,
-	}, { /* end: all zeroes */ }
-};
+
+static const struct pci_device_id pci_ids[] = {
+#if defined(CONFIG_NLM_XLP) && defined(CONFIG_USB)
+	{
+		.vendor         = PCI_VENDOR_ID_NETLOGIC,
+		.device         = XLP_DEVID_OHCI,
+		.subvendor      = 0,
+		.subdevice      = 0,
+		.class          = PCI_CLASS_SERIAL_USB_OHCI,
+		.class_mask     = ~0,
+		.driver_data =  (unsigned long) &ohci_pci_hc_driver,
+	},
 #else
-static const struct pci_device_id pci_ids[] = { {
-		.vendor		= PCI_VENDOR_ID_NETLOGIC,
-		.device		= XLP_DEVID_OHCI,
-		.subvendor	= 0,
-		.subdevice	= 0,
-		.class		= PCI_CLASS_SERIAL_USB_OHCI,
-		.class_mask	= ~0,
-		.driver_data	= (unsigned long) &ohci_pci_hc_driver,
+	{
+		/* handle any USB OHCI controller */
+		PCI_DEVICE_CLASS(PCI_CLASS_SERIAL_USB_OHCI, ~0),
+		.driver_data =	(unsigned long) &ohci_pci_hc_driver,
 	},
+#endif
 	{ /* end: all zeroes */ }
 };
-#endif
 MODULE_DEVICE_TABLE (pci, pci_ids);
 
 /* pci driver glue; this is a "new style" PCI driver module */
 static struct pci_driver ohci_pci_driver = {
 	.name =		(char *) hcd_name,
 	.id_table =	pci_ids,
-#ifndef CONFIG_NLM_XLP
-	.probe =	usb_hcd_pci_probe,
-	.remove =	usb_hcd_pci_remove,
-#else
+#if defined(CONFIG_NLM_XLP) && defined(CONFIG_USB)
 	.probe =	xlp_ohci_hcd_pci_probe,
 	.remove =	xlp_ohci_hcd_pci_remove,
-#endif
+	.shutdown =	xlp_ohci_hcd_pci_shutdown,
+#else
+	.probe =	usb_hcd_pci_probe,
+	.remove =	usb_hcd_pci_remove,
 	.shutdown =	usb_hcd_pci_shutdown,
+#endif
 
 #ifdef CONFIG_PM_SLEEP
 	.driver =	{
-- 
1.7.0

