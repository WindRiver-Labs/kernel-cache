From 53432f22605c083f1863c141534eda4b6e524f27 Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Thu, 2 Aug 2012 11:07:59 +0800
Subject: [PATCH 45/46] nlm_xlp_64_be: split the proc entry nae_mac_stats

The problem:
When user accessed the proc entry /proc/netlogic/mac_stats, the kernel
always returned the error: "proc_file_read: Apparent buffer overflow!".

The reason:
Once this entry was accessed , the function xlp_mac_proc_read() would
traverse the NAE data in the 18 ports per node. In a previous commit,
we added the multi-node feature, system supports up to 4 nodes now,
and NR_CPUS increased from 32 to 128 accordingly.
So the total string size would exceed the PAGE_SIZE limitation, 4K in
WindRiver Linux by default.

Now we split the NAE statistics data into multi-entries, each port in
one node owns a independent entry.

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/net/nae/xlp_nae.c |  111 ++++++++++++++++++++++++++++-----------------
 1 files changed, 69 insertions(+), 42 deletions(-)

diff --git a/drivers/net/nae/xlp_nae.c b/drivers/net/nae/xlp_nae.c
index c273cc6..7b01911 100644
--- a/drivers/net/nae/xlp_nae.c
+++ b/drivers/net/nae/xlp_nae.c
@@ -139,6 +139,11 @@
 #define PHOENIX_MAX_MACS 18
 #define MAX_TSO_SKB_PEND_REQS 50
 
+struct macstat_proc_data {
+	int node;
+	int port;
+};
+
 static uint32_t maxnae;
 /* THIS MUST be multiple of cache line size */
 static int jumbo_buffer_size = DEFAULT_JUMBO_BUFFER_SIZE; /*or set in set_mtu */
@@ -880,11 +885,13 @@ static void nlm_xlp_nae_init(void)
 {
 	struct net_device *dev = NULL;
 	struct dev_data *priv = NULL;
-	int i, node = 0, cpu;
+	int i, node = 0, cpu, port;
 	struct proc_dir_entry *entry;
+	char entry_name[32];
 	nlm_nae_config_ptr nae_cfg;
 	uint32_t cpu_mask[NLM_MAX_NODES];
 	char buf[CPUMASK_BUF];
+	struct macstat_proc_data *mpd;
 	
 	for(i=0; i < NLM_MAX_NODES; i++)
 		cpu_mask[i] = 0;
@@ -993,14 +1000,31 @@ static void nlm_xlp_nae_init(void)
 		nlm_initialize_vfbid(node, nae_cfg->fb_vc);
 	}
 
-	entry = create_proc_read_entry("mac_stats", 0 /* def mode */,
-					nlm_root_proc /* parent */,
-					xlp_mac_proc_read /* proc read function */,
-					0	/* no client data */
+	for (node = 0; node < NLM_MAX_NODES; node++) {
+		for (port = 0; port < MAX_GMAC_PORT; port++) {
+			sprintf(entry_name, "mac_stats_node%d_port%d",
+				node, port);
+			mpd = kmalloc(sizeof(*mpd), GFP_KERNEL);
+			if (!mpd) {
+				printk(KERN_ERR "[%s]: Not enough memory for"
+					" creating proc entry %s\n",
+					__func__, entry_name);
+				return;
+			}
+			mpd->node = node;
+			mpd->port = port;
+			entry = create_proc_read_entry(
+					entry_name, 0, /* def mode */
+					nlm_root_proc, /* parent */
+					xlp_mac_proc_read, /* read function */
+					(void *)mpd/* client data */
 				);
-	if (!entry) {
-		pr_info("[%s]: Unable to create proc read entry for xlp_mac!\n",
-			__func__);
+			if (!entry) {
+				pr_info("[%s]: Unable to create proc read"
+					" entry for node%d:port%d xlp_mac!\n",
+					__func__, node, port);
+			}
+		}
 	}
 }
 
@@ -1662,50 +1686,51 @@ static int xlp_mac_proc_read(char *page, char * *start, off_t off,
 {
 	int len = 0;
 	off_t begin = 0;
-	int i = 0, cpu = 0, node;
+	int i = 0, cpu = 0, node, port;
 	struct net_device *dev = 0;
 	struct dev_data *priv = 0;
+	struct macstat_proc_data *mpd = (struct macstat_proc_data *)data;
 
 	len += sprintf(page + len, "uboot_pkts = %ld\n", stats_uboot_pkts);
 
-	for(node = 0; node < NLM_MAX_NODES; node++) {
-		for (i = 0; i < MAX_GMAC_PORT; i++) {
+	node = mpd->node;
+	port = mpd->port;
 
-			dev = dev_mac[node][i];
+	dev = dev_mac[node][port];
 
-			if (dev == 0)
-				continue;
-
-			priv = netdev_priv(dev);
-
-			len += sprintf(page + len, "=============== port@%d ==================\n", i);
-
-			len += sprintf(page + len, "per port@%d: frin_to_be_sent = %ld num_replenishes = %ld frin_sent = %ld\n",
-					i, atomic64_read(&priv->frin_to_be_sent),
-					atomic64_read(&priv->num_replenishes),
-					atomic64_read(&priv->total_frin_sent));
-
-			len += sprintf(page + len,
-					"per port@%d: %lu(rxp) %lu(rxb) %lu(txp) %lu(txb)\n",
-					i,
-					STATS_READ(priv->stats.rx_packets),
-					STATS_READ(priv->stats.rx_bytes),
-					STATS_READ(priv->stats.tx_packets),
-					STATS_READ(priv->stats.tx_bytes));
+	if (dev == 0) {
+		len += sprintf(page + len, "no packets on node%d:port%d\n",
+				node, port);
+		return len;
+	}
 
-			for (cpu = 0; cpu < NR_CPUS; cpu++) {
-				unsigned long tx = priv->cpu_stats[cpu].tx_packets;
-				unsigned long txc = priv->cpu_stats[cpu].txc_packets;
-				unsigned long rx = priv->cpu_stats[cpu].rx_packets;
-				unsigned long ints = priv->cpu_stats[cpu].interrupts;
+	priv = netdev_priv(dev);
 
-				if (!tx && !txc && !rx && !ints)
-					continue;
+	len += sprintf(page + len, "frin_to_be_sent = %ld "
+			"num_replenishes = %ld frin_sent = %ld\n",
+			atomic64_read(&priv->frin_to_be_sent),
+			atomic64_read(&priv->num_replenishes),
+			atomic64_read(&priv->total_frin_sent));
+
+	len += sprintf(page + len,
+			"%lu(rxp) %lu(rxb) %lu(txp) %lu(txb)\n",
+			STATS_READ(priv->stats.rx_packets),
+			STATS_READ(priv->stats.rx_bytes),
+			STATS_READ(priv->stats.tx_packets),
+			STATS_READ(priv->stats.tx_bytes));
+
+	for (cpu = 0; cpu < num_possible_cpus(); cpu++) {
+		unsigned long tx = priv->cpu_stats[cpu].tx_packets;
+		unsigned long txc = priv->cpu_stats[cpu].txc_packets;
+		unsigned long rx = priv->cpu_stats[cpu].rx_packets;
+		unsigned long ints = priv->cpu_stats[cpu].interrupts;
+
+		if (!tx && !txc && !rx && !ints)
+			continue;
 
-				len += sprintf(page + len, "per cpu@%d: %lu(txp) %lu(txcp) %lu(rxp) %lu(int)\n",
-						cpu, tx, txc, rx, ints);
-			}
-		}
+		len += sprintf(page + len,
+			"cpu%d: %lu(txp) %lu(txcp) %lu(rxp) %lu(int)\n",
+			cpu, tx, txc, rx, ints);
 	}
 
 	*eof = 1;
@@ -1714,6 +1739,8 @@ static int xlp_mac_proc_read(char *page, char * *start, off_t off,
 	len -= (off - begin);
 	if (len > count)
 		len = count;
+	if (len > PAGE_SIZE)
+		len = PAGE_SIZE;
 	if (len < 0)
 		len = 0;
 
-- 
1.7.0

