From a04a2dafcb4bc8fd13f7b7ba27de71469f6c6f12 Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Fri, 23 Mar 2012 11:34:58 +0800
Subject: [PATCH 07/47] nlm_xlp_64_be: add SPI support.

Add SPI support, based on NetLogic SDK 20120215_2.2.3 tag.

Signed-off-by: henry shao <hshao@netlogicmicro.com>
Integrated-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/mtd/devices/Kconfig     |    7 +
 drivers/mtd/devices/Makefile    |    1 +
 drivers/mtd/devices/m25p80.c    |   17 +-
 drivers/mtd/devices/mt29f_spi.c |  788 +++++++++++++++++++++++++++++++++++++++
 drivers/spi/Kconfig             |    7 +
 drivers/spi/Makefile            |    4 +
 drivers/spi/spi_xlp.c           |  453 ++++++++++++++++++++++
 7 files changed, 1276 insertions(+), 1 deletions(-)
 create mode 100644 drivers/mtd/devices/mt29f_spi.c
 create mode 100644 drivers/spi/spi_xlp.c

diff --git a/drivers/mtd/devices/Kconfig b/drivers/mtd/devices/Kconfig
index 83daf23..578b267 100644
--- a/drivers/mtd/devices/Kconfig
+++ b/drivers/mtd/devices/Kconfig
@@ -119,6 +119,13 @@ config MTD_SST25L
 	  Set up your spi devices with the right board-specific platform data,
 	  if you want to specify device partitioning.
 
+config MTD_MT29F
+	tristate "Support Micron MT29F SPI Nand chips"
+	depends on SPI_MASTER
+	help
+	  This enables access to Micron MT29F family SPI flash chips, used
+	  for program and data storage.
+
 config MTD_SLRAM
 	tristate "Uncached system RAM"
 	help
diff --git a/drivers/mtd/devices/Makefile b/drivers/mtd/devices/Makefile
index 7c8c306..b0641ff 100644
--- a/drivers/mtd/devices/Makefile
+++ b/drivers/mtd/devices/Makefile
@@ -16,5 +16,6 @@ obj-$(CONFIG_MTD_LART)		+= lart.o
 obj-$(CONFIG_MTD_BLOCK2MTD)	+= block2mtd.o
 obj-$(CONFIG_MTD_DATAFLASH)	+= mtd_dataflash.o
 obj-$(CONFIG_MTD_M25P80)	+= m25p80.o
+obj-$(CONFIG_MTD_MT29F)		+= mt29f_spi.o
 obj-$(CONFIG_MTD_SPEAR_SMI)	+= spear_smi.o
 obj-$(CONFIG_MTD_SST25L)	+= sst25l.o
diff --git a/drivers/mtd/devices/m25p80.c b/drivers/mtd/devices/m25p80.c
index 289f330..fe9ac65 100644
--- a/drivers/mtd/devices/m25p80.c
+++ b/drivers/mtd/devices/m25p80.c
@@ -856,6 +856,16 @@ void parse_flash_partition(struct spi_device *spi)
 }
 #endif
 
+#ifdef CONFIG_NLM_XLP
+static struct mtd_partition xlp_spi_parti[] = {
+        {
+                .name = "SPI NOR FLASH",
+                .offset = 0x00000000,
+                .size = MTDPART_SIZ_FULL,
+        }
+};
+#endif
+
 /*
  * board specific setup should have ensured the SPI clock used here
  * matches what the READ command supports, at least until this driver
@@ -1024,7 +1034,12 @@ static int __devinit m25p_probe(struct spi_device *spi)
 			parts = data->parts;
 			nr_parts = data->nr_parts;
 		}
-
+#ifdef CONFIG_NLM_XLP
+		if((nr_parts == 0) && (data == 0)) {
+			parts	 = xlp_spi_parti;
+			nr_parts = ARRAY_SIZE(xlp_spi_parti);
+		}
+#endif
 		if (nr_parts > 0) {
 			for (i = 0; i < nr_parts; i++) {
 				DEBUG(MTD_DEBUG_LEVEL2, "partitions[%d] = "
diff --git a/drivers/mtd/devices/mt29f_spi.c b/drivers/mtd/devices/mt29f_spi.c
new file mode 100644
index 0000000..7de0684
--- /dev/null
+++ b/drivers/mtd/devices/mt29f_spi.c
@@ -0,0 +1,788 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems (â€œNetlogicâ€?. All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/mutex.h>
+#include <linux/sched.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+
+
+#define SPI_NAND_MT29F_BLOCK_ERASE	0xD8    /* Block Erase */
+#define SPI_NAND_MT29F_GET_FEATURE	0x0F    /* Get Feature */
+#define SPI_NAND_MT29F_PAGE_READ	0x13    /* Array Read */
+#define SPI_NAND_MT29F_PROG_EXE		0x10    /* Page Execute */
+#define SPI_NAND_MT29F_PROG_LOAD	0x02    /* Program Load*/
+#define SPI_NAND_MT29F_PROG_RAND_LOAD	0x84    /* Program load random data */
+#define SPI_NAND_MT29F_RD_ARRAY		0x0B    /* Read from cache Data Bytes */
+#define SPI_NAND_MT29F_RD_CACHE		0x03	/* Read From Cache*/
+#define SPI_NAND_MT29F_READID		0x9F	/* Read ID */
+#define SPI_NAND_MT29F_RESET       	0xFF    /* Reset */
+#define SPI_NAND_MT29F_SET_FEATURE	0x1F    /* Get Feature */
+
+#define SPI_NAND_MT29F_WREN        	0x06    /* Write Enable */
+#define SPI_NAND_MT29F_WRDI        	0x04    /* Write Disable */
+#define SPI_NAND_MT29F_BLOCK_LOCK	0xA0
+
+#define SPI_NAND_MT29F_OTP      	0xB0
+#define SPI_NAND_MT29F_OTP_EN      	0x40
+#define SPI_NAND_MT29F_OTP_PROT      	0x80
+#define SPI_NAND_MT29F_OTP_ECC      	0x10
+
+#define SPI_NAND_MT29F_STATUS      	0xC0
+#define SPI_NAND_MT29F_OIP      	0x01
+#define SPI_NAND_MT29F_WEL      	0x02
+#define SPI_NAND_MT29F_ST_EFAIL      	0x04
+#define SPI_NAND_MT29F_ST_PFAIL      	0x08
+#define SPI_NAND_MT29F_ST_ECC_S0      	0x10
+#define SPI_NAND_MT29F_ST_ECC_S1      	0x20
+
+#define MT29F_REG_BLOCK_LOCK		0xA0
+#define MT29F_REG_OTP			0xB0
+#define MT29F_REG_STATUS		0xC0
+
+#define MICRON_ID_MT29F1G01ZAC		0x12
+#define MICRON_ID_MT29F1G01ZAC1		0x11
+#define MICRON_SR_WIP         		(1 << 0)  /* Write-in-Progress */
+#define SPINAND_TIMEOUT			0x7fffffff
+
+#define ROW_SHIFT			12
+#define COL_MASK			0x0F
+/* Define max times to check status register before we give up. */
+#define	MAX_WAIT_TIME			40000
+
+struct mt29f_snand_params {
+        uint8_t      idcode1;
+        uint16_t page_size;
+        uint16_t pages_per_block;
+        uint16_t nr_blocks;
+        const char *name;
+};
+
+static const struct mt29f_snand_params mt29f_snand_table[] = {
+        {
+                .idcode1                 = MICRON_ID_MT29F1G01ZAC,
+                .page_size               = 2048,
+                .pages_per_block	 = 64,
+                .nr_blocks               = 1024,
+                .name                    = "MT29F1G01ZAC",
+        },
+        {
+                .idcode1                 = MICRON_ID_MT29F1G01ZAC1,
+                .page_size               = 2048,
+                .pages_per_block	 = 64,
+                .nr_blocks               = 1024,
+                .name                    = "MT29F1G01ZAC",
+        },
+};
+/****************************************************************************/
+
+struct mt29f {
+	struct spi_device	*spi;
+	struct mutex		lock;
+	struct mtd_info		mtd;
+	unsigned		partitioned:1;
+	uint8_t			erase_opcode;
+	uint8_t			command[4];
+	struct mt29f_snand_params  params;
+};
+
+static struct mtd_partition xlp_mt29f_part[] = {
+        {
+                .name = "SPI NAND FLASH",
+                .offset = 0x00000000,
+                .size = MTDPART_SIZ_FULL,
+        }
+};
+
+static inline struct mt29f *mtd_to_mt29f(struct mtd_info *mtd)
+{
+	return container_of(mtd, struct mt29f, mtd);
+}
+
+static int8_t get_feature(struct mt29f *snand, uint8_t reg)
+{
+	uint8_t cmd[4];
+	int8_t val, retval;
+
+	if(!snand)
+		return -1;
+
+	cmd[0] = SPI_NAND_MT29F_GET_FEATURE;
+	cmd[1] = reg;
+
+	retval = spi_write_then_read(snand->spi, cmd, 2, &val, 1);
+	if (retval < 0) {
+		printk("[%s] error %d reading status\n", __func__, (int)retval);
+		return retval;
+	}
+	return val;
+}
+
+static int set_feature(struct mt29f *snand, uint8_t reg, uint8_t val)
+{
+	uint8_t cmd[4];
+	if(!snand)
+		return -1;
+
+	cmd[0] = SPI_NAND_MT29F_SET_FEATURE;
+	cmd[1] = reg;
+	cmd[2] = val;
+
+	return spi_write(snand->spi, cmd, 3);
+}
+
+static inline int write_enable(struct mt29f *snand)
+{
+	uint8_t cmd[4];
+	if(!snand)
+		return -1;
+
+	cmd[0]= SPI_NAND_MT29F_WREN;
+	return spi_write(snand->spi, cmd, 1);
+}
+
+static inline int write_disable(struct mt29f *snand)
+{
+	uint8_t cmd[4];
+	if(!snand)
+		return -1;
+
+	cmd[0]= SPI_NAND_MT29F_WRDI;
+	return spi_write(snand->spi, cmd, 1);
+}
+
+static void mt29f_blk_unlock(struct mt29f *snand, uint8_t lockbits)
+{
+	uint8_t val;
+
+	mutex_lock(&snand->lock);
+	val = get_feature(snand, MT29F_REG_BLOCK_LOCK);
+	val &= ~( 0x7 << 3);
+	val = val | lockbits;
+	set_feature(snand, MT29F_REG_BLOCK_LOCK, val);
+	mutex_unlock(&snand->lock);
+}
+
+static int wait_oip_clear(struct mt29f *snand, unsigned long t)
+{
+	int i, ret;
+
+        i = 0;
+        do {
+                ret = get_feature(snand, MT29F_REG_STATUS);
+                if( i++ == t) {
+                        printk("mt29f_page_read timeout\n");
+                        return ret;
+                }
+        } while((ret & SPI_NAND_MT29F_OIP) != 0x0);
+
+	return 0;
+
+}
+
+static int wait_write_latch(struct mt29f *snand, unsigned long t)
+{
+	int i, ret;
+
+	i = 0;
+	do {
+		ret = get_feature(snand, MT29F_REG_STATUS);
+		if( i++ == t) {
+			printk("mt29f_page_read timeout\n");
+			return ret;
+		}
+	} while((ret & SPI_NAND_MT29F_WEL) != 0x2);
+
+        return 0;
+
+}
+
+void mt29f_reset(struct mt29f *snand)
+{
+	int ret;
+	uint8_t cmd = SPI_NAND_MT29F_RESET;
+
+	mutex_lock(&snand->lock);
+	ret = spi_write_then_read(snand->spi, &cmd, 1, NULL, 0);
+	if (ret < 0) {
+		mutex_unlock(&snand->lock);
+		printk("SF: Reset failed\n");
+	}
+
+	ret = wait_oip_clear(snand, MAX_WAIT_TIME);
+	if (ret) {
+            printk("MT29F: Timeout\n");
+		mutex_unlock(&snand->lock);
+            return;
+	}
+
+	mutex_unlock(&snand->lock);
+	return;
+}
+
+static uint16_t mt29f_read_id(struct mt29f *snand) 
+{
+	uint8_t cmd;
+	uint16_t read_id;
+	uint8_t id[5];
+	int ret;
+
+	mutex_lock(&snand->lock);
+	cmd = SPI_NAND_MT29F_READID;
+	ret = spi_write_then_read(snand->spi, &cmd, 1, id, 5);
+	if (ret < 0) {
+            printk("[%s]: read_id failed\n", __func__);
+		mutex_unlock(&snand->lock);
+		return -1;
+	}
+	read_id = id[1] << 8 |id[2];
+	mutex_unlock(&snand->lock);
+
+	return read_id;
+}
+
+
+static int mt29f_page_read(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, uint8_t* buf) 
+{
+	struct mt29f *snand = mtd_to_mt29f(mtd);
+	uint16_t col_addr = (uint16_t)(from & 0x7FF);
+	uint8_t cmd[4];
+	int ret;
+
+	DEBUG(MTD_DEBUG_LEVEL2,"[%s] READ from: row: 0x%x col: 0x%x len: %d \n", 
+		__func__,(unsigned int)(((from >> (ROW_SHIFT + 8)) << 8)|(from >> ROW_SHIFT)), 
+		(unsigned int)col_addr, (int)len);
+
+	if(!snand)
+		return -1;
+
+	if (!len)
+		return -1;
+
+	if (from + len > snand->mtd.size)
+		return -EINVAL;
+
+	mutex_lock(&snand->lock);
+
+	cmd[0] = SPI_NAND_MT29F_PAGE_READ;
+	cmd[1] = 0x0;
+	cmd[2] = (from >> (ROW_SHIFT + 8)) & 0xFF;
+	cmd[3] = (from >> ROW_SHIFT) & 0xFF;
+
+
+	ret = spi_write(snand->spi, cmd, 4);
+	if(ret < 0) {
+		printk("mt29f_page_read failed\n");
+		mutex_unlock(&snand->lock);
+		return ret;
+	}
+	
+	ret = wait_oip_clear(snand, MAX_WAIT_TIME);
+	if (ret) {
+		printk("[%s] from 0x%x timeout. ret: 0x%x\n",  __func__, (unsigned int)from, ret);
+		*retlen = 0;
+		mutex_unlock(&snand->lock);
+		return -1;
+	}
+
+	cmd[0] = SPI_NAND_MT29F_RD_CACHE;
+	cmd[1] = (col_addr >> 8) & 0x0F;
+	cmd[2] = (col_addr & 0xFF);
+	cmd[3] = 0x0;   
+
+    	spi_write(snand->spi, cmd, 4);
+	ret = spi_read(snand->spi, buf, len);
+		
+	*retlen = len;
+	mutex_unlock(&snand->lock);
+
+	return ret;
+}
+
+static int mt29f_page_program(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char* buf) 
+{
+	struct mt29f *snand = mtd_to_mt29f(mtd);
+	uint8_t ret;
+	uint8_t cmd[4];
+	uint8_t prog_cmd[4];
+	uint16_t col_addr = (uint16_t) (to & 0x7FF);
+
+	DEBUG(MTD_DEBUG_LEVEL2,"[%s] to: 0x%x  len: %d \n", __func__, (unsigned int)to, (int)len);
+
+	if (!len) {
+		*retlen = 0;
+		return 0;
+	}
+
+        write_enable(snand);
+
+	prog_cmd[0] = SPI_NAND_MT29F_PROG_LOAD;
+	prog_cmd[1] = ( col_addr >> 8) & COL_MASK;
+	prog_cmd[2] = (col_addr & 0xFF);
+
+	ret = wait_write_latch(snand, MAX_WAIT_TIME);
+	if(ret) {
+		printk("[%s] write enable failed\n", __func__);
+		*retlen = 0;
+		return -1;	
+	}
+
+	spi_write(snand->spi, prog_cmd, 3);
+	spi_write(snand->spi, buf, len);
+
+	cmd[0] = SPI_NAND_MT29F_PROG_EXE;
+	cmd[1] = 0x0;
+	cmd[2] = to >> (ROW_SHIFT + 8);
+	cmd[3] = to >> ROW_SHIFT;
+	
+	spi_write(snand->spi, cmd, 4);
+
+	ret = wait_oip_clear(snand, MAX_WAIT_TIME);
+	if (ret) {
+		printk("[%s] Page Program operation failed: ret: %x\n", __func__, ret);
+		*retlen = 0;
+		return -1;
+	}
+
+	*retlen = len;
+	return 0;
+}
+
+static int mt29f_random_program(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char* buf) 
+{
+	struct mt29f *snand = mtd_to_mt29f(mtd);
+	uint8_t ret;
+	uint8_t cmd[4];
+	uint8_t prog_cmd[4];
+	uint16_t col_addr = (uint16_t) (to & 0x7FF);
+
+	DEBUG(MTD_DEBUG_LEVEL2, "[%s] to: 0x%x  len: %d \n", __func__, (unsigned int)to, (int)len);
+
+	if (!len) {
+		*retlen = 0;
+		return 0;
+	}
+
+        write_enable(snand);
+
+	prog_cmd[0] = SPI_NAND_MT29F_PROG_RAND_LOAD;
+	prog_cmd[1] = ( col_addr >> 8) & COL_MASK;
+	prog_cmd[2] = (col_addr & 0xFF);
+
+	ret = wait_write_latch(snand, MAX_WAIT_TIME);
+	if(ret) {
+		printk("[%s] write enable failed\n", __func__);
+		*retlen = 0;
+		return -1;	
+	}
+
+	spi_write(snand->spi, prog_cmd, 3);
+	spi_write(snand->spi, buf, len);
+
+	cmd[0] = SPI_NAND_MT29F_PROG_EXE;
+	cmd[1] = 0x0;
+	cmd[2] = to >> (ROW_SHIFT + 8);
+	cmd[3] = to >> ROW_SHIFT;
+	
+	spi_write(snand->spi, cmd, 4);
+
+	ret = wait_oip_clear(snand, MAX_WAIT_TIME);
+	if (ret) {
+		printk("[%s] Page Program operation failed: ret: %x\n", __func__, ret);
+		*retlen = 0;
+		return -1;
+	}
+	*retlen = len;
+	return 0;
+}
+
+static int mt29f_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char* buf) 
+{
+	struct mt29f *snand = mtd_to_mt29f(mtd);
+	int i;
+	uint16_t col_addr, page_size;
+	size_t ret;
+
+	if(!snand)
+		return -1;
+	*retlen = 0;
+	ret = 0;
+
+	page_size= snand->params.page_size;
+	col_addr = to % page_size;
+
+	DEBUG(MTD_DEBUG_LEVEL2,"[%s] to:0x%x len:%d row:0x%x col_addr:0x%x\n", 
+			__func__, (unsigned int)to, (int)len, (unsigned int)(to >> ROW_SHIFT)&0xFFFF, col_addr);
+
+	mutex_lock(&snand->lock);
+
+	ret = wait_oip_clear(snand, MAX_WAIT_TIME);
+	if (ret) {
+		printk("[%s] snand is not ready!%x\n", __func__, (unsigned int)ret);
+		*retlen = 0;
+		mutex_unlock(&snand->lock);
+		return -1;
+	}
+
+	if(col_addr + len <= page_size) {
+		mt29f_page_program(mtd, to, len, retlen, buf);
+		/*mt29f_random_program(mtd, to, len, retlen, buf);*/
+	} else {
+	
+        	page_size = snand->params.page_size - col_addr;
+		mt29f_page_program(mtd, to, page_size, &ret, buf);
+		/*mt29f_random_program(mtd, to, page_size, &ret, buf);*/
+		*retlen = *retlen + ret;
+		for( i = page_size; i < len; i += page_size) {
+			page_size = len - i;
+			if(page_size > snand->params.page_size)
+				page_size = snand->params.page_size;
+			mt29f_page_program(mtd, to + i, page_size, &ret, buf + i);
+			/*mt29f_random_program(mtd, to + i, page_size, &ret, buf + i);*/
+			*retlen = *retlen + ret;
+		}
+	}	
+	mutex_unlock(&snand->lock);
+
+	return 0;
+}
+
+static int mt29f_erase_block(struct mtd_info *mtd, uint32_t addr)
+{
+        struct mt29f *snand = mtd_to_mt29f(mtd);
+	uint8_t cmd[4];
+	int ret;
+
+        DEBUG(MTD_DEBUG_LEVEL3, "%s: %s %dKiB at 0x%08x\n",
+                        dev_name(&snand->spi->dev), __func__,
+                        snand->mtd.erasesize / 1024, addr);
+	if(!snand)
+		return 1;
+
+        /* Send write enable, then erase commands. */
+        write_enable(snand);
+
+        /* Wait until finished previous write command. */
+        if (wait_oip_clear(snand, MAX_WAIT_TIME))
+                return 1;
+
+        /* Set up command buffer. */
+        cmd[0] = SPI_NAND_MT29F_BLOCK_ERASE;
+        cmd[1] = 0;
+        cmd[2] = addr >> (ROW_SHIFT + 8);
+        cmd[3] = addr >> ROW_SHIFT;
+
+        spi_write(snand->spi, cmd, 4);
+
+	ret = wait_oip_clear(snand, MAX_WAIT_TIME);
+	if (ret) {
+		printk("[%s] erase block 0x%x failed: ret: %x\n", __func__, addr, ret);
+		return -1;
+	}
+
+        return 0;
+}
+
+static int mt29f_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	struct mt29f *snand = mtd_to_mt29f(mtd);
+	uint32_t addr,len;
+	uint32_t rem;
+
+	if(!snand || !instr)
+		return -EINVAL;
+
+	DEBUG(MTD_DEBUG_LEVEL2, "%s: %s %s 0x%llx, len %lld\n",
+	      dev_name(&snand->spi->dev), __func__, "at",
+	      (long long)instr->addr, (long long)instr->len);
+
+	if (instr->addr + instr->len > snand->mtd.size)
+		return -EINVAL;
+	div_u64_rem(instr->len, mtd->erasesize, &rem);
+	if (rem)
+		return -EINVAL;
+
+	addr = instr->addr;
+	len = instr->len;
+
+	mutex_lock(&snand->lock);
+
+	while (len) {
+		if (mt29f_erase_block(&snand->mtd, addr)) {
+			instr->state = MTD_ERASE_FAILED;
+			mutex_unlock(&snand->lock);
+			return -EIO;
+		}
+		addr += mtd->erasesize;
+		len -= mtd->erasesize;
+	}
+	
+	mutex_unlock(&snand->lock);
+
+        instr->state = MTD_ERASE_DONE;
+        mtd_erase_callback(instr);
+
+	return 0;
+}
+
+
+#if CONFIG_NLM_XLP
+unsigned char buf[4096];
+unsigned char wrbuf[4096];
+static void mt29f_test(struct mt29f * snand)
+{
+	int i, j, rw_err, offset, seg, xfer_len;
+	size_t retlen;
+	memset(buf, 0, 4096);
+	retlen 		= 0;
+	xfer_len 	= 370;
+
+	j = snand->mtd.size / snand->mtd.erasesize;
+	for( i = 0; i < j; i++)
+	{
+		mt29f_erase_block(&snand->mtd, i);
+		printk("\n######################### erase_block: %d\n", i);
+	}
+	printk("\n######################### read\n");
+	printk("\nFlash read back %d\n",xfer_len);
+
+	for(j = 0; j < 1; j++)
+	{
+		mt29f_page_read(&snand->mtd, j * 2048, xfer_len, &retlen, buf);
+		printk("\n **********************read :%d\n", (int)retlen);
+		for( i = 0; i < xfer_len; i++)
+        	{
+                	printk("%02x",buf[i]);
+                	if((i % 16) == 0xf)
+                        	printk("\n");
+        	}
+	}
+
+	rw_err = 0;
+	for(i = 0; i < 2048; i++){
+		wrbuf[i] = i % 0x100;
+	}
+	offset = 0;
+	seg = 2048;
+	/* write buf with number */
+	for(j = 0; j < 1; j++)
+	{
+		retlen = xfer_len;
+
+		printk("\n######################### write\n");
+		printk("\nFlash write %d to 0x%x\n",xfer_len, (j + offset)*seg);
+
+		mt29f_write(&snand->mtd, (j + offset)*seg, xfer_len, &retlen, wrbuf);
+
+		printk("\n######################### read\n");
+		printk("\n\nFlash read back %d\n",xfer_len);
+
+		mt29f_page_read(&snand->mtd, (j+offset) * seg, xfer_len, &retlen, buf);
+
+		printk("\nread from: 0x%x xfer_len:%d retlen: %d\n",
+			(j + offset) * seg,  xfer_len, (unsigned int)retlen);
+		for( i = 0; i < xfer_len; i++)
+        	{
+                	printk("%02x",buf[i]);
+               		if((i % 16) == 0xf)
+                        	printk("\n");
+        	}
+		if(memcmp(wrbuf, buf, xfer_len) != 0) {
+			rw_err++;
+		}
+	}
+	printk("\nread write: %d times for xfer_len: %d, rw_err: %d\n", j, xfer_len, rw_err);
+}
+#endif
+
+
+static int __devinit mt29f_probe(struct spi_device *spi)
+{
+	struct flash_platform_data *pdata;
+	struct mt29f_snand_params *params;
+	struct mt29f	*snand;
+	uint16_t snand_id;
+	int	i;
+
+	pdata = spi->dev.platform_data;
+	snand = kzalloc(sizeof(struct mt29f), GFP_KERNEL);
+	if (!snand)
+		return -ENOMEM;
+
+	
+	snand->spi = spi;
+	mutex_init(&snand->lock);
+	dev_set_drvdata(&spi->dev, snand);
+
+	snand_id = mt29f_read_id(snand);
+	printk("[%s] Micro vendorID:%x Chip ID:%x\n",
+		__func__, (0xff00 & snand_id) >> 8, (0xff & snand_id));
+
+        for (i = 0; i < ARRAY_SIZE(mt29f_snand_table); i++) {
+                params = (struct mt29f_snand_params *)&mt29f_snand_table[i];
+                if (params && params->idcode1 == (0xff & snand_id) ) {
+                                break;
+                }
+		params++;
+        }
+	
+	if (!params || i == ARRAY_SIZE(mt29f_snand_table)) {
+		printk("The Chip ID does not match device in driver device table\n");
+		return -ENODEV;
+	}
+	memcpy(&snand->params, params, sizeof(struct mt29f_snand_params));
+
+	snand->mtd.name = dev_name(&spi->dev);
+	printk("%s (%lld Kbytes) pagesize %u \n", params->name,
+			(long long)snand->mtd.size >> 10, params->page_size);
+
+	snand->mtd.type = MTD_NORFLASH;
+	snand->mtd.writesize = 1;
+	snand->mtd.flags = MTD_CAP_NORFLASH;
+	snand->mtd.size = (params->page_size * params->pages_per_block * params->nr_blocks); 
+	snand->mtd.erase = mt29f_erase;
+	snand->mtd.read  = mt29f_page_read;
+	snand->mtd.write = mt29f_write;
+
+	snand->erase_opcode = SPI_NAND_MT29F_BLOCK_ERASE;
+	snand->mtd.erasesize = params->page_size * params->pages_per_block;
+
+	snand->mtd.dev.parent = &spi->dev;
+
+	dev_info(&spi->dev, "%s (%lld Kbytes) pagesize %u \n", params->name,
+			(long long)snand->mtd.size >> 10, params->page_size);
+
+	DEBUG(MTD_DEBUG_LEVEL2,
+		"mtd .name = %s, .size = 0x%llx (%lldMiB) "
+			".erasesize = 0x%.8x (%uKiB) .numeraseregions = %d\n",
+		snand->mtd.name,
+		(long long)snand->mtd.size, (long long)(snand->mtd.size >> 20),
+		snand->mtd.erasesize, snand->mtd.erasesize / 1024,
+		snand->mtd.numeraseregions);
+
+	if (snand->mtd.numeraseregions)
+		for (i = 0; i < snand->mtd.numeraseregions; i++)
+			DEBUG(MTD_DEBUG_LEVEL2,
+				"mtd.eraseregions[%d] = { .offset = 0x%llx, "
+				".erasesize = 0x%.8x (%uKiB), "
+				".numblocks = %d }\n",
+				i, (long long)snand->mtd.eraseregions[i].offset,
+				snand->mtd.eraseregions[i].erasesize,
+				snand->mtd.eraseregions[i].erasesize / 1024,
+				snand->mtd.eraseregions[i].numblocks);
+
+
+	if (mtd_has_partitions()) {
+		struct mtd_partition	*parts = NULL;
+		int			nr_parts = 0;
+
+		if (mtd_has_cmdlinepart()) {
+			static const char *part_probes[]
+					= { "cmdlinepart", NULL, };
+
+			nr_parts = parse_mtd_partitions(&snand->mtd,
+					part_probes, &parts, 0);
+		}
+
+                if((nr_parts == 0) && (pdata == 0)) {
+                        parts    = xlp_mt29f_part;
+                        nr_parts = ARRAY_SIZE(xlp_mt29f_part);
+                }
+
+		if (nr_parts > 0) {
+			for (i = 0; i < nr_parts; i++) {
+				DEBUG(MTD_DEBUG_LEVEL2, "partitions[%d] = "
+					"{.name = %s, .offset = 0x%llx, "
+						".size = 0x%llx (%lldKiB) }\n",
+					i, parts[i].name,
+					(long long)parts[i].offset,
+					(long long)parts[i].size,
+					(long long)(parts[i].size >> 10));
+			}
+			snand->partitioned = 1;
+			return add_mtd_partitions(&snand->mtd, parts, nr_parts);
+		}
+	} else if (pdata && pdata->nr_parts) {
+		dev_warn(&spi->dev, "ignoring %d default partitions on %s\n",
+				pdata->nr_parts, pdata->name);
+	}
+	return add_mtd_device(&snand->mtd) == 1 ? -ENODEV : 0;
+}
+
+
+static int __devexit mt29f_remove(struct spi_device *spi)
+{
+	struct mt29f	*snand = dev_get_drvdata(&spi->dev);
+	int		status;
+
+	if (mtd_has_partitions() && snand->partitioned)
+		status = del_mtd_partitions(&snand->mtd);
+	else
+		status = del_mtd_device(&snand->mtd);
+	if (status == 0)
+		kfree(snand);
+	return 0;
+}
+
+
+static struct spi_driver mt29f_driver = {
+	.driver = {
+		.name	= "mt29f",
+		.bus	= &spi_bus_type,
+		.owner	= THIS_MODULE,
+	},
+	.probe	= mt29f_probe,
+	.remove	= __devexit_p(mt29f_remove),
+
+};
+
+
+static int __init mt29f_init(void)
+{
+	return spi_register_driver(&mt29f_driver);
+}
+
+
+static void __exit mt29f_exit(void)
+{
+	spi_unregister_driver(&mt29f_driver);
+}
+
+
+module_init(mt29f_init);
+module_exit(mt29f_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Netlogicmicro System Inc.");
+MODULE_DESCRIPTION("MTD SPI driver for Micron MT29f nand chips");
+MODULE_ALIAS("platform:mt29f-spi");
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 04a34e4..48303ea 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -323,6 +323,13 @@ config SPI_XILINX
 
 	  Or for the DS570, see "XPS Serial Peripheral Interface (SPI) (v2.00b)"
 
+config SPI_XLP
+	tristate "Netlogic XLP SPI controller"
+	depends on NLM_XLP
+	select SPI_BITBANG
+	help
+	  SPI driver for Netlogic XLP MIPS SoCs
+
 config SPI_XILINX_OF
 	tristate "Xilinx SPI controller OF device"
 	depends on SPI_XILINX && (XILINX_VIRTEX || MICROBLAZE)
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 33322d3..f96f7c5 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -1,6 +1,9 @@
 #
 # Makefile for kernel SPI drivers.
 #
+ifeq ($(CONFIG_NLM_XLP),y)
+EXTRA_CFLAGS := $(CFLAGS) -DNLM_HAL_LINUX_KERNEL
+endif
 
 ifeq ($(CONFIG_SPI_DEBUG),y)
 EXTRA_CFLAGS += -DDEBUG
@@ -47,6 +50,7 @@ obj-$(CONFIG_SPI_SH_SCI)		+= spi_sh_sci.o
 obj-$(CONFIG_SPI_SH_MSIOF)		+= spi_sh_msiof.o
 obj-$(CONFIG_SPI_STMP3XXX)		+= spi_stmp.o
 obj-$(CONFIG_SPI_NUC900)		+= spi_nuc900.o
+obj-$(CONFIG_SPI_XLP)			+= spi_xlp.o
 
 # special build for s3c24xx spi driver with fiq support
 spi_s3c24xx_hw-y			:= spi_s3c24xx.o
diff --git a/drivers/spi/spi_xlp.c b/drivers/spi/spi_xlp.c
new file mode 100644
index 0000000..683cd33
--- /dev/null
+++ b/drivers/spi/spi_xlp.c
@@ -0,0 +1,453 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_bitbang.h>
+#include <linux/io.h>
+
+#include <asm/netlogic/hal/nlm_hal.h>
+#include <asm/netlogic/xlp.h>
+
+#undef XLP_SPI_DEBUG
+
+#define CONFIG_SPI_REFCLK		133333334
+#define SPI_CHAN_OFFSET			0x10
+#define CMD_RDID			0x9f
+#define CMD_RDSR			0x05
+#define CMD_WREN			0x06
+#define CMD_WRDI			0x04
+#define CMD_BE_4K			0x20
+#define CMD_BE_32K			0x52
+#define CMD_CHIP_ERASE			0xc7
+#define CMD_SE				0xd8
+#define CMD_GET_FEATURE			0x0f
+#define CMD_SET_FEATURE			0x1f
+#define CMD_RESET			0xff
+#define CMD_PR				0x13
+#define CMD_PL				0x02
+#define CMD_PROGEXE			0x10
+
+#define DEFAULT_CS_FDIV			0x10
+#define XLP_SPI_MAX_XFER_SIZE		0x2000
+#define XLP_SPI_FIFO_SIZE		8
+#define NOR_SPI_CMD_SIZE		5
+#define XLP_SPI_MAX_CS			4
+
+struct spi_xlp {
+	struct spi_bitbang bitbang;
+	struct completion done;
+	uint8_t 	cs;
+	uint8_t 	cs_active;
+	void __iomem	*regs;
+	uint32_t	irq;
+	uint32_t	speed_hz;
+	unsigned char	*rx_buf;
+	unsigned char	*tx_buf;
+	int32_t 	rcounter;
+};
+
+static __inline__ int32_t spi_reg_read(int node, int cs, int regidx)
+{
+        volatile uint64_t mmio;
+        mmio = nlm_hal_get_dev_base(node, 0, XLP_PCIE_SPI_NOR_FLASH_DEV, XLP_PCIE_SPI_CTRL);
+	regidx +=  cs * SPI_CHAN_OFFSET;
+        return nlm_hal_read_32bit_reg(mmio, regidx);
+}
+
+static __inline__ void spi_reg_write(int node, int cs, int regidx, int32_t val)
+{
+        volatile uint64_t mmio;
+        mmio = nlm_hal_get_dev_base(node, 0, XLP_PCIE_SPI_NOR_FLASH_DEV, XLP_PCIE_SPI_CTRL);
+	regidx +=  cs * SPI_CHAN_OFFSET;
+        nlm_hal_write_32bit_reg(mmio, regidx, val);
+}
+
+#ifdef XLP_SPI_DEBUG
+static void spi_dump_reg()
+{
+        int i, j = 0;
+	for(i = 0; i < 8; i++) {
+		printk("0x%0x = 0x%8x\n", i, spi_reg_read( 0, j, i));
+	}
+        for(j = 0; j < XLP_SPI_MAX_CS; j++)
+        {
+                printk("dump spi_%d register\n", j);
+                for(i = 0x40; i < 0x47; i++) {
+                        printk("0x%0x = 0x%8x\n", i, spi_reg_read( 0, j, i));
+                }
+        }
+        printk("0x%0x = 0x%8x\n", 0x80, spi_reg_read( 0, 0, 0x80));
+}
+#endif
+
+static void xlp_spi_init(struct spi_xlp *pspi)
+{
+	uint32_t i, val;
+
+	val = spi_reg_read(0, 0, XLP_SPI_SYSCTRL);
+	val |= XLP_SPI_SYS_PMEN;
+        spi_reg_write(0, 0, XLP_SPI_SYSCTRL, (XLP_SPI_SYS_RESET << pspi->cs));
+
+	pspi->cs_active = 0;
+	for(i = 0; i < XLP_SPI_MAX_CS; i++)
+	{
+		val = spi_reg_read(0, i, XLP_SPI_CONFIG);
+		val |= XLP_SPI_TXMOSI_EN |XLP_SPI_RXMISO_EN;
+		spi_reg_write(0, i, XLP_SPI_CONFIG, val);
+	}
+}
+
+static void spi_xlp_chipselect(struct spi_device *spi, int is_on)
+{
+	struct spi_xlp *pspi = spi_master_get_devdata(spi->master);
+
+        if(pspi)
+                pspi->cs =  spi->chip_select;
+
+	if (is_on == BITBANG_CS_INACTIVE) {
+		pspi->cs_active = 0;
+	} else if (is_on == BITBANG_CS_ACTIVE) {
+		pspi->cs_active = 1;
+	}
+}
+
+static int spi_xlp_setup_transfer(struct spi_device *spi,
+		struct spi_transfer *t)
+{
+	uint8_t bits_per_word;
+	uint32_t hz;
+	struct spi_xlp *pspi = spi_master_get_devdata(spi->master);
+
+	bits_per_word = (t) ? t->bits_per_word : spi->bits_per_word;
+	hz = (t) ? t->speed_hz : spi->max_speed_hz;
+
+	if (hz && pspi->speed_hz > hz) {
+		printk("%s, unsupported clk rate %uHz\n", __func__, hz);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int spi_xlp_setup(struct spi_device *spi)
+{
+	struct spi_bitbang *bitbang;
+	struct spi_xlp *pspi;
+	int32_t val;
+	pspi = spi_master_get_devdata(spi->master);
+	bitbang = &pspi->bitbang;
+
+	spi_reg_write(0, 0, XLP_SPI_SYSCTRL, XLP_SPI_SYS_PMEN);
+
+       if ((1000000 < CONFIG_SPI_REFCLK/4) &&
+                (1000000 > CONFIG_SPI_REFCLK/(64*1024))) {
+                spi_reg_write(0, pspi->cs, XLP_SPI_FDIV, DEFAULT_CS_FDIV);
+        } else {
+                printk("Unsupported SPI frequency %d\n",1000000);
+                goto out;
+        }
+	val = spi_xlp_setup_transfer(spi, NULL);
+	if (val < 0)
+		return val;
+
+	return 0;
+out:
+	return -1;
+
+}
+
+static void spi_xlp_fill_txfifo(struct spi_xlp *pspi, uint32_t* len, unsigned char** data)
+{
+        uint32_t txfifo_cnt;
+        uint32_t tx_data;
+        txfifo_cnt = spi_reg_read(0, pspi->cs, XLP_SPI_FIFO_WCNT);
+	txfifo_cnt >>= XLP_SPI_TXFIFO_WCNT_POS;
+
+        while ((*len) && (txfifo_cnt < XLP_SPI_FIFO_SIZE))
+        {
+                if (*len <= 1) {
+                        tx_data = (*data)[0];
+                        *len = 0;
+                } else if (*len <= 2) {
+                        tx_data = (((*data)[0] << 8) |
+                                   ((*data)[1] << 0));
+                        *len = 0;
+                } else if (*len <= 3) {
+                        tx_data = (((*data)[0] << 16) |
+                                    ((*data)[1] << 8) |
+                                    ((*data)[2] << 0));
+                        *len = 0;
+                } else {
+                        tx_data = (((*data)[0] << 24) |
+                                   ((*data)[1] << 16) |
+                                   ((*data)[2] << 8)  |
+                                   ((*data)[3] << 0));
+                        *len = *len - 4;
+                }
+
+		spi_reg_write(0, pspi->cs, XLP_SPI_TXDATA_FIFO, tx_data);
+                (*data) += 4;
+                txfifo_cnt++;
+        }
+}
+
+static int spi_disable_cont_cmd(unsigned char* opcode)
+{
+	if(opcode == NULL)
+		return 0;
+
+	if(opcode[0] == CMD_WREN 	||
+	   opcode[0] == CMD_BE_4K	||
+	   opcode[0] == CMD_BE_32K	||
+	   opcode[0] == CMD_CHIP_ERASE	||
+	   opcode[0] == CMD_SE		||
+	   opcode[0] == CMD_RESET	||
+	   opcode[0] == CMD_PROGEXE	||
+	   opcode[0] == CMD_SET_FEATURE	||
+	   opcode[0] == CMD_WRDI )
+		return 1;
+	else
+		return 0;
+}
+
+static int spi_xlp_xfer_block(struct spi_device *spi, struct spi_transfer *t, uint32_t xfer_len)
+{
+	uint32_t val;
+	uint32_t rx_data, tx_len, rx_len, rxfifo_cnt, sent_bytes;
+	struct spi_xlp *pspi = spi_master_get_devdata(spi->master);
+	unsigned char* rx_buf = NULL;
+	unsigned char* tx_buf = NULL;
+
+	tx_buf = (unsigned char*)t->tx_buf;
+	rx_buf = (unsigned char*)t->rx_buf;
+
+	if (!tx_buf && !rx_buf)
+                return -1;
+
+	tx_len = (tx_buf == NULL) ? 0 : xfer_len;
+	rx_len = (rx_buf == NULL) ? 0 : xfer_len;
+	sent_bytes = 0;
+
+	val = XLP_SPI_CMD_IDLE;
+	if (tx_len) {
+		spi_xlp_fill_txfifo(pspi, &tx_len, &tx_buf);
+		sent_bytes = xfer_len - tx_len;
+		if(xfer_len <= NOR_SPI_CMD_SIZE){
+			val |= XLP_SPI_CMD_CONT;
+		}
+		if(spi_disable_cont_cmd((unsigned char*)t->tx_buf))
+		{
+			val &= ~XLP_SPI_CMD_CONT;
+		}
+        }
+
+	if(t->tx_buf)
+		val |= XLP_SPI_CMD_TX;
+	if(t->rx_buf)
+		val |= XLP_SPI_CMD_RX;
+        if(xfer_len)
+		val |= ((xfer_len * 8 - 1) << XLP_SPI_XFR_BITCNT_POS);
+
+	spi_reg_write(0, pspi->cs, XLP_SPI_CMD, val);
+
+        while ((tx_len) || (rx_len)) {
+
+                if (rx_len) {
+
+			rxfifo_cnt = spi_reg_read(0, pspi->cs, XLP_SPI_FIFO_WCNT);
+			rxfifo_cnt = (0xF & rxfifo_cnt);
+
+                        while (rxfifo_cnt) {
+
+				rx_data = spi_reg_read(0, pspi->cs, XLP_SPI_RXDATA_FIFO);
+				rxfifo_cnt--;
+
+                                if (rx_len <= 1) {
+                                        rx_buf[0] = (uint8_t) (rx_data & 0xff);
+                                        rx_len = 0;
+                                } else if (rx_len <= 2) {
+                                        rx_buf[0] = (uint8_t) ((rx_data >> 8) & 0xff);
+                                        rx_buf[1] = (uint8_t) ((rx_data >> 0) & 0xff);
+                                        rx_len = 0;
+                                } else if (rx_len <= 3) {
+                                        rx_buf[0] = (uint8_t) ((rx_data >> 16) & 0xff);
+                                        rx_buf[1] = (uint8_t) ((rx_data >> 8) & 0xff);
+                                        rx_buf[2] = (uint8_t) ((rx_data >> 0) & 0xff);
+                                        rx_len = 0;
+                                } else {
+                                        rx_buf[0] = (uint8_t) ((rx_data >> 24) & 0xff);
+                                        rx_buf[1] = (uint8_t) ((rx_data >> 16) & 0xff);
+                                        rx_buf[2] = (uint8_t) ((rx_data >> 8) & 0xff);
+                                        rx_buf[3] = (uint8_t) ((rx_data >> 0) & 0xff);
+                                        rx_len -= 4;
+                                }
+                                rx_buf += 4;
+                        }
+			sent_bytes = xfer_len - rx_len;
+                }
+                if (tx_len) {
+			spi_xlp_fill_txfifo(pspi, &tx_len, &tx_buf);
+			sent_bytes = xfer_len - tx_len;	
+                }
+        }
+
+	do {
+		val = spi_reg_read(0, pspi->cs, XLP_SPI_STATUS);
+		if(val & XLP_SPI_TX_OV_TH)
+		{
+			printk("[%s] tx over threshold, stop sendinging\n",__func__);
+		}
+        } while((val & XLP_SPI_XFR_DONE) == 0);
+
+        return sent_bytes;
+}
+
+static int spi_xlp_txrx_bufs(struct spi_device *spi, struct spi_transfer *t)
+{
+        int ret;
+	uint32_t len;
+
+	ret = 0;
+	len = t->len;
+	while (len > XLP_SPI_MAX_XFER_SIZE) {
+		ret += spi_xlp_xfer_block(spi, t, XLP_SPI_MAX_XFER_SIZE);
+		len = len - XLP_SPI_MAX_XFER_SIZE;
+		if (t->tx_buf)
+			t->tx_buf = t->tx_buf + XLP_SPI_MAX_XFER_SIZE;
+		if (t->rx_buf)
+			t->rx_buf = t->rx_buf + XLP_SPI_MAX_XFER_SIZE;
+	}
+        ret += spi_xlp_xfer_block(spi, t, len);
+
+        return ret;
+}
+
+static int __init spi_xlp_probe(struct platform_device *dev)
+{
+	int ret = 0;
+	struct spi_master *master;
+	struct spi_xlp *pspi;
+	struct resource *r;
+
+	master = spi_alloc_master(&dev->dev, sizeof(struct spi_xlp));
+
+	if (master == NULL) {
+		return -ENOMEM;
+	}
+
+	dev_set_drvdata(&dev->dev, master);
+
+	r = platform_get_resource(dev, IORESOURCE_MEM, 0);
+	if (r == NULL) {
+		ret = -ENODEV;
+		goto put_master;
+	}
+
+	pspi = spi_master_get_devdata(master);
+	pspi->bitbang.master 		= spi_master_get(master);
+	pspi->bitbang.chipselect	= spi_xlp_chipselect;
+	pspi->bitbang.setup_transfer	= spi_xlp_setup_transfer;
+	pspi->bitbang.txrx_bufs		= spi_xlp_txrx_bufs;
+	pspi->bitbang.master->setup	= spi_xlp_setup;
+	init_completion(&pspi->done);
+
+	if (!request_mem_region(r->start,
+			r->end - r->start + 1, "spi-xlp")) {
+		ret = -ENXIO;
+		goto put_master;
+	}
+
+	pspi->regs = ioremap(r->start, r->end - r->start + 1);
+	if (pspi->regs == NULL) {
+		ret = -ENOMEM;
+		goto put_master;
+	}
+
+	master->bus_num = 0;
+	master->num_chipselect = XLP_SPI_MAX_CS;
+
+	xlp_spi_init(pspi);
+	ret = spi_bitbang_start(&pspi->bitbang);
+	if (ret != 0) {
+		dev_err(&dev->dev, "spi_bitbang_start FAILED\n");
+		goto unmap_io;
+	}
+
+	return ret;
+
+unmap_io:
+	iounmap(pspi->regs);
+put_master:
+	spi_master_put(master);
+	return ret;
+}
+
+static int __devexit spi_xlp_remove(struct platform_device *dev)
+{
+	struct spi_xlp *pspi;
+	struct spi_master *master;
+
+	master = platform_get_drvdata(dev);
+	pspi = spi_master_get_devdata(master);
+
+	spi_bitbang_stop(&pspi->bitbang);
+	iounmap(pspi->regs);
+	platform_set_drvdata(dev, 0);
+	spi_master_put(pspi->bitbang.master);
+
+	return 0;
+}
+
+static struct platform_driver spi_xlp_driver = {
+	.probe	= spi_xlp_probe,
+	.remove	= __devexit_p(spi_xlp_remove),
+	.driver = {
+		.name = "spi-xlp",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init spi_xlp_init(void)
+{
+	return platform_driver_register(&spi_xlp_driver);
+}
+module_init(spi_xlp_init);
+
+static void __exit spi_xlp_exit(void)
+{
+	platform_driver_unregister(&spi_xlp_driver);
+}
+module_exit(spi_xlp_exit);
+
+MODULE_AUTHOR("Netlogic Microsystem Inc.");
+MODULE_DESCRIPTION("Netlogic XLP SPI master controller driver");
+MODULE_LICENSE("GPL");
-- 
1.7.0

