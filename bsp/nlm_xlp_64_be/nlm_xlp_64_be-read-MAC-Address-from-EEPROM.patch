From 6a54a853a32efe872a36984ae6e4c206b922e8c3 Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Sat, 14 Apr 2012 11:50:14 +0800
Subject: [PATCH 18/46] nlm_xlp_64_be: read MAC Address from EEPROM

Read NAE devices' MAC Address from EEPROM.

The problem: The NAE driver used the hard code to specify
the MAC address, and this may lead to the collision.

Based on NetLogic SDK 20120331_2.2.4_alpha.

Signed-off-by: Kopal <kopal@broadcom.com>
Integrated-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/netlogic/hal/nlm_eeprom.h |   44 +++
 arch/mips/netlogic/common/Makefile              |    1 +
 arch/mips/netlogic/common/nlm_eeprom.c          |   73 +++++
 arch/mips/netlogic/xlp/Makefile                 |    2 +-
 arch/mips/netlogic/xlp/board.c                  |   24 ++
 arch/mips/netlogic/xlp/i2c.c                    |  367 +++++++++++++++++++++++
 drivers/net/nae/xlp_nae.c                       |   73 ++++--
 7 files changed, 562 insertions(+), 22 deletions(-)
 create mode 100644 arch/mips/include/asm/netlogic/hal/nlm_eeprom.h
 create mode 100644 arch/mips/netlogic/common/nlm_eeprom.c
 create mode 100644 arch/mips/netlogic/xlp/i2c.c

diff --git a/arch/mips/include/asm/netlogic/hal/nlm_eeprom.h b/arch/mips/include/asm/netlogic/hal/nlm_eeprom.h
new file mode 100644
index 0000000..8460e45
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/hal/nlm_eeprom.h
@@ -0,0 +1,44 @@
+#ifndef _NLM_EEPROM_H
+#define _NLH_EEPROM_H
+
+#include "nlm_hal.h"
+/* MACID i2c memory definitions
+ */
+#define MAGIC_OFF   		0x00
+#define MAGIC_LEN   		0x02
+#define MAC_MAGIC_BYTE0 	0xAA
+#define MAC_MAGIC_BYTE1 	0x55
+#define MAC_OFF     		0x02
+#define MAC_LEN     		0x06
+
+#define NAME_OFF     		0x10
+#define NAME_LEN     		0x08
+#define REV_OFF     		0x18
+#define REV_LEN     		0x03
+#define SN_OFF      		0x1B
+#define SN_LEN      		0x04
+#define UPD_OFF     		0x1F
+#define UPD_LEN     		0x02
+
+
+struct eeprom_data{
+	unsigned char magic_bytes0[MAGIC_LEN];
+	unsigned char mac_addr0[MAC_LEN];
+	unsigned char magic_bytes1[MAGIC_LEN];
+	unsigned char mac_addr1[MAC_LEN];
+	unsigned char name[NAME_LEN];
+	unsigned char revision[REV_LEN];
+	unsigned char srnum[SN_LEN];
+	unsigned char upd[UPD_LEN];
+
+	unsigned char i2c_dev_addr;
+	void *priv;
+
+	void(*eeprom_i2c_read_bytes)(unsigned char dev_addr, unsigned int addr, int alen, unsigned char * buf, int len);
+	void(*eeprom_i2c_write_bytes)(unsigned char dev_addr, unsigned int addr, int alen, unsigned char * buf, int len);
+};
+
+extern int  eeprom_get_mac_addr(struct eeprom_data *nlm_eeprom, unsigned char *mac, int interface);
+extern int  eeprom_set_mac_addr(struct eeprom_data *nlm_eeprom, unsigned char *mac, int interface);
+extern int  eeprom_get_magic_bytes(struct eeprom_data *nlm_eeprom, unsigned char *mac, int interface);
+#endif
diff --git a/arch/mips/netlogic/common/Makefile b/arch/mips/netlogic/common/Makefile
index d65ff9e..7906f40 100644
--- a/arch/mips/netlogic/common/Makefile
+++ b/arch/mips/netlogic/common/Makefile
@@ -5,6 +5,7 @@ obj-y :=   cpu_proc.o memory.o bootinfo.o
 obj-$(CONFIG_NLM_XLP)			+= nlm_hal_fmn_config.o
 obj-$(CONFIG_NLM_XLP)			+= nlm_hal_cpu_info.o nlm_hal_sys.o nlm_evp_cpld.o
 obj-$(CONFIG_NLM_XLP)			+= nlm_hal.o nlm_hal_nae.o fdt_helper.o
+obj-$(CONFIG_NLM_XLP)			+= nlm_eeprom.o
 obj-$(CONFIG_KEXEC)			+= nlm_kexec.o
 
 EXTRA_AFLAGS := $(CFLAGS)
diff --git a/arch/mips/netlogic/common/nlm_eeprom.c b/arch/mips/netlogic/common/nlm_eeprom.c
new file mode 100644
index 0000000..ab93d13
--- /dev/null
+++ b/arch/mips/netlogic/common/nlm_eeprom.c
@@ -0,0 +1,73 @@
+#ifdef NLM_HAL_LINUX_KERNEL
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <asm/netlogic/hal/nlm_eeprom.h>
+#else
+#include "nlm_eeprom.h"
+#endif
+
+
+int  eeprom_get_mac_addr(struct eeprom_data *nlm_eeprom, unsigned char *mac, int interface)
+{
+	unsigned char *eeprom_mac;
+	int offset;
+	unsigned char dev_addr;
+
+	if(nlm_eeprom==NULL){
+		return -1;
+	}
+
+	dev_addr = nlm_eeprom->i2c_dev_addr;
+	eeprom_mac = interface?(nlm_eeprom->mac_addr1):(nlm_eeprom->mac_addr0);
+
+	offset= interface?(((struct eeprom_data*)0)->mac_addr1):(((struct eeprom_data*)0)->mac_addr0);
+	nlm_eeprom->eeprom_i2c_read_bytes(dev_addr, offset,0, eeprom_mac, MAC_LEN);
+	memcpy(mac, eeprom_mac, MAC_LEN);
+	return 0;
+}
+
+int  eeprom_set_mac_addr(struct eeprom_data *nlm_eeprom, unsigned char *mac, int interface)
+{
+	unsigned char *eeprom_mac;
+	unsigned char dev_addr;
+	int offset;
+	if(nlm_eeprom==NULL){
+		return -1;
+	}
+
+	dev_addr = nlm_eeprom->i2c_dev_addr;
+
+	eeprom_mac = interface?(nlm_eeprom->mac_addr1):(nlm_eeprom->mac_addr0);
+	offset= interface?(((struct eeprom_data*)0)->mac_addr1):(((struct eeprom_data*)0)->mac_addr0);
+	nlm_eeprom->eeprom_i2c_write_bytes(dev_addr, offset,0, mac, MAC_LEN);
+	return 0;
+}
+int  eeprom_get_magic_bytes(struct eeprom_data *nlm_eeprom, unsigned char *mac, int interface)
+{
+        unsigned char *eeprom_mac;
+        int offset;
+        unsigned char dev_addr;
+
+        if(nlm_eeprom==NULL){
+                return -1;
+        }
+
+        dev_addr = nlm_eeprom->i2c_dev_addr;
+        eeprom_mac = interface?(nlm_eeprom->magic_bytes1):(nlm_eeprom->magic_bytes0);
+
+        offset= interface?(((struct eeprom_data*)0)->magic_bytes1):(((struct eeprom_data*)0)->magic_bytes0);
+        nlm_eeprom->eeprom_i2c_read_bytes(dev_addr, offset,0, eeprom_mac, MAGIC_LEN);
+        memcpy(mac, eeprom_mac, MAGIC_LEN);
+        return 0;
+}
+
+
+#ifdef NLM_HAL_LINUX_KERNEL
+/*Add  API here if any API  from above is needed*/
+EXPORT_SYMBOL(eeprom_get_mac_addr);
+EXPORT_SYMBOL(eeprom_set_mac_addr);
+EXPORT_SYMBOL(eeprom_get_magic_bytes);
+
+#endif
+
diff --git a/arch/mips/netlogic/xlp/Makefile b/arch/mips/netlogic/xlp/Makefile
index 7172857..3b1eb51 100644
--- a/arch/mips/netlogic/xlp/Makefile
+++ b/arch/mips/netlogic/xlp/Makefile
@@ -4,7 +4,7 @@ EXTRA_CFLAGS := $(CFLAGS) -DNLM_HAL_LINUX_KERNEL -Iarch/mips/include/asm/netlogi
 obj-y                    	= setup.o mmu.o
 obj-y 				+= irq.o time.o on_chip.o
 obj-$(CONFIG_NLM_XLP) 		+= platform.o board.o
-obj-$(CONFIG_NLM_XLP) 		+= xlp_hal_pic.o xlp_gpio.o
+obj-$(CONFIG_NLM_XLP) 		+= xlp_hal_pic.o xlp_gpio.o i2c.o
 obj-$(CONFIG_SMP)       	+= smp.o
 
 obj-$(CONFIG_NLM_XLP) += cpu_control.o cpu_control_asm.o
diff --git a/arch/mips/netlogic/xlp/board.c b/arch/mips/netlogic/xlp/board.c
index 31564c4..ca5df44 100644
--- a/arch/mips/netlogic/xlp/board.c
+++ b/arch/mips/netlogic/xlp/board.c
@@ -28,6 +28,14 @@
 #include <linux/platform_device.h>
 #include <linux/i2c.h>
 #include <linux/spi/spi.h>
+#include <asm/netlogic/hal/nlm_eeprom.h>
+
+struct eeprom_data nlm_eeprom;
+
+extern int eeprom_read (u8 devaddr, uint addr, int alen, u8 * buf, int len);
+extern int eeprom_write (u8 devaddr, uint addr, int alen, u8 * buf, int len);
+extern int eeprom_init (int speed);
+
 
 static struct i2c_board_info xlp_i2c_device_info[] __initdata = {
 #ifdef CONFIG_N511
@@ -77,3 +85,19 @@ static int __init xlp_spi_device_init(void)
 }
 
 arch_initcall(xlp_spi_device_init);
+
+static int __init eeprom_device_init(void)
+{
+	nlm_eeprom.i2c_dev_addr=0x57;
+	nlm_eeprom.eeprom_i2c_read_bytes = (void *)eeprom_read;
+        nlm_eeprom.eeprom_i2c_write_bytes = (void *)eeprom_write;
+        eeprom_init(45000);
+
+	return 0;
+}
+arch_initcall(eeprom_device_init);
+struct eeprom_data *get_nlm_eeprom(void)
+{
+        return &nlm_eeprom;
+}
+EXPORT_SYMBOL(get_nlm_eeprom);
diff --git a/arch/mips/netlogic/xlp/i2c.c b/arch/mips/netlogic/xlp/i2c.c
new file mode 100644
index 0000000..b6142e8
--- /dev/null
+++ b/arch/mips/netlogic/xlp/i2c.c
@@ -0,0 +1,367 @@
+/*
+ * Copyright 2003-2011 Netlogic Microsystems (“Netlogic”). All rights
+ * reserved. Redistribution and use in source and binary forms, with
+ * or without modification, are permitted provided that the following
+ * conditions are met:
+ *
+ *	1. 	Redistributions of source code must retain the above copyright
+ *		notice, this list of conditions and the following disclaimer.
+ *
+ *	2. 	Redistributions in binary form must reproduce the above copyright
+ *		notice, this list of conditions and the following disclaimer in
+ *		the documentation and/or other materials provided with the
+ *		distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * --------------------------------#NETL_2#--------------------------------
+ */
+
+#include <asm/netlogic/hal/nlm_eeprom.h>
+#include <asm/netlogic/hal/nlm_hal.h>
+#include <asm/netlogic/hal/nlm_hal.h>
+#include <asm/netlogic/xlp.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/i2c.h>
+
+
+#define I2C_CLKFREQ_KHZ                 1
+#define I2C_TIMEOUT                             500000
+
+
+#define XLP_I2C_DEFAULT_SPEED           1000
+#define I2C_PRESCALER_LO                 0
+#define I2C_PRESCALER_HI                 1
+#define I2C_CONTROL                      2
+        #define I2C_CONTROL_EN           0x80
+        #define I2C_CONTROL_IEN          0x40
+#define I2C_DATA                         3               /* Data TX & RX Reg */
+#define I2C_COMMAND                      4
+        #define I2C_COMMAND_START        0x90
+        #define I2C_COMMAND_STOP         0x40
+        #define I2C_COMMAND_READ         0x20
+        #define I2C_COMMAND_WRITE        0x10
+        #define I2C_COMMAND_RDACK        0x20
+        #define I2C_COMMAND_RDNACK       0x28
+        #define I2C_COMMAND_IACK         0x01    /* Not used */
+#define I2C_STATUS                       4               /* Same as 'command' */
+        #define I2C_STATUS_NACK          0x80    /* Did not get an ACK */
+        #define I2C_STATUS_BUSY          0x40
+        #define I2C_STATUS_AL            0x20    /* Arbitration Lost */
+        #define I2C_STATUS_TIP           0x02    /* Transfer in Progress  */
+        #define I2C_STATUS_IF            0x01    /* Intr. Pending Flag, not used */
+#define I2C_WRITE_BIT                   0x00
+#define I2C_READ_BIT                    0x01
+#define I2C_DEFAULT_PRESCALER           0x3F
+
+
+
+/* Low-level routines
+ */
+int my_read (u8 devaddr, uint addr, int alen, u8 * buf, int len);
+int my_write (u8 devaddr, uint addr, int alen, u8 * buf, int len);
+static inline u8 xlp_i2c_read_reg(int offset)
+{
+	volatile u32 *i2c_mmio = ioremap_nocache((nlm_hal_get_dev_base(0, 0, XLP_PCIE_GIO_DEV, XLP_GIO_I2C1_FUNC) +0x100),1000);
+	return ((u8)i2c_mmio[offset]);
+
+}
+
+static inline void xlp_i2c_write_reg(int offset, u8 value) {
+
+	volatile u32 *i2c_mmio =  ioremap_nocache((nlm_hal_get_dev_base(0, 0, XLP_PCIE_GIO_DEV, XLP_GIO_I2C1_FUNC) +0x100),1000);
+	i2c_mmio[offset] = value;
+}
+
+static inline int xaction_complete(void) {
+
+	volatile int timeout = I2C_TIMEOUT;
+	int retval = 0;
+
+	while ((xlp_i2c_read_reg(I2C_STATUS) & I2C_STATUS_TIP) && timeout) {
+		timeout--;
+	}
+	if (timeout == 0) {
+		printk("Timed Out Waiting for TIP to Clear.\n");
+		retval = -1;
+	}
+	return retval;
+}
+
+static inline int bus_idle(void) {
+
+	volatile int timeout = I2C_TIMEOUT;
+	int retval = 0;
+
+	while ((xlp_i2c_read_reg(I2C_STATUS) & I2C_STATUS_BUSY) && timeout) {
+		timeout--;
+	}
+	if (timeout == 0) {
+		printk("Timed Out Waiting for Bus Busy to Clear.\n");
+		retval = -1;
+	}
+	return retval;
+}
+
+static inline int check_for_ack(void) {
+
+	if (xlp_i2c_read_reg(I2C_STATUS) & I2C_STATUS_NACK) {
+		//printk("ACK not received from Slave Device.\n");
+		return -1;
+	}
+	return 0;
+}
+
+/* ------------------------------------------
+ * Sequence to Read byte(s) from an
+ * offset within the Slave Device: -
+ * ------------------------------------------
+ * -- Set up 'DATA' with 'Slave Address + W'
+ * -- Trigger the START Condition
+ * 	-> Wait for Xfer complete & Slave Ack
+ * -- Set up 'DATA' with 'Slave Offset + W'
+ * -- Set the 'WRITE' bit in COMMAND Reg
+ * 	-> Wait for Xfer complete & Slave Ack
+ * -- Set up 'DATA' with 'Slave Address + R'
+ * -- Trigger the (Re-)START Condition
+ * 	-> Wait for Xfer complete & Slave Ack
+ * -- For 'n-1' out of 'n' bytes,
+ * 	-> Set 'READ' bit in COMMAND
+ *	-> Keep Reading 'DATA' Register
+ * -- For the last (or only) byte
+ * 	-> Set 'READ/STOP/NACK' bits in COMMAND
+ *	-> Read 'DATA' Register
+ * ------------------------------------------
+ */
+
+int xlp_i2c_rx(u8 slave_addr, u32 slave_offset,
+	      u8 alen, int len, u8 *data) {
+	int i ;
+
+//	printk("slave_addr=0x%x offset=0x%x alen=%d buff=0x%x len=%d\n", slave_addr, slave_offset, alen, data, len);
+
+	/* Verify the bus is idle */
+	if (xlp_i2c_read_reg(I2C_STATUS) & I2C_STATUS_BUSY) {
+		printk("I2C Bus BUSY (Not Available), Aborting.\n");
+		goto i2c_rx_error;
+	}
+
+	xlp_i2c_write_reg(I2C_DATA, (slave_addr << 1) | I2C_WRITE_BIT);
+	xlp_i2c_write_reg(I2C_COMMAND, I2C_COMMAND_START);
+	if (xaction_complete() < 0) {
+		goto i2c_rx_error;
+	}
+	if (check_for_ack() < 0) {
+		goto i2c_rx_error;
+	}
+
+	/* Verify Arbitration is not Lost */
+	if (xlp_i2c_read_reg(I2C_STATUS) & I2C_STATUS_AL) {
+		printk("I2C Bus Arbitration Lost, Aborting.\n");
+		goto i2c_rx_error;
+	}
+	for (i = 0; i<=alen; i++) {
+		xlp_i2c_write_reg(I2C_DATA, ( (slave_offset >> (i*8) ) & 0xff) | I2C_WRITE_BIT);
+		xlp_i2c_write_reg(I2C_COMMAND, I2C_COMMAND_WRITE);
+		if (xaction_complete() < 0) {
+			goto i2c_rx_error;
+		}
+		if (check_for_ack() < 0) {
+			goto i2c_rx_error;
+		}
+	}
+
+	/* Address Phase Done, Data Phase begins
+	 */
+	xlp_i2c_write_reg(I2C_DATA, (slave_addr << 1) | I2C_READ_BIT);
+	xlp_i2c_write_reg(I2C_COMMAND, I2C_COMMAND_START);
+	if (xaction_complete() < 0) {
+		goto i2c_rx_error;
+	}
+	if (check_for_ack() < 0) {
+		goto i2c_rx_error;
+	}
+
+	if (len > 1) {
+
+		int bytenr = 0;
+
+		for (bytenr = 0; bytenr < len; bytenr++) {
+			xlp_i2c_write_reg(I2C_COMMAND, I2C_COMMAND_READ);
+			if (xaction_complete() < 0) {
+				goto i2c_rx_error;
+			}
+			if (data != NULL) {
+				*data = xlp_i2c_read_reg(I2C_DATA);
+				//printk("data=0x%x\n", *data);
+				data++;
+			}
+		}
+	}
+
+	/* Last (or only) Byte: -
+	 * 	Set RD, NACK, STOP Bits
+	 */
+	xlp_i2c_write_reg(I2C_COMMAND, I2C_COMMAND_STOP | I2C_COMMAND_RDNACK);
+	if (xaction_complete() < 0) {
+		goto i2c_rx_error;
+	}
+
+	if (data != NULL) {
+		*data = xlp_i2c_read_reg(I2C_DATA);
+	}
+	return bus_idle();
+
+i2c_rx_error:
+	/* Release Bus */
+	xlp_i2c_write_reg(I2C_COMMAND, I2C_COMMAND_STOP);
+	bus_idle();
+	return -1;
+}
+
+/* Write byte(s) to the I2C Slave Device
+ */
+int xlp_i2c_tx(u8 slave_addr, u16 slave_offset, u8 alen,
+		int len, u8 *data) {
+	int i ;
+
+	// printk("slave_addr=0x%x offset=0x%x alen=%d buff=0x%x len=%d\n", slave_addr, slave_offset, alen, data, len);
+
+	/* Verify the bus is idle */
+	if (xlp_i2c_read_reg(I2C_STATUS) & I2C_STATUS_BUSY) {
+		printk("I2C Bus BUSY (Not Available), Aborting.\n");
+		goto i2c_tx_error;
+	}
+
+	xlp_i2c_write_reg(I2C_DATA, (slave_addr << 1) | I2C_WRITE_BIT);
+	xlp_i2c_write_reg(I2C_COMMAND, I2C_COMMAND_START);
+	if (xaction_complete() < 0) {
+		goto i2c_tx_error;
+	}
+	if (check_for_ack() < 0) {
+		goto i2c_tx_error;
+	}
+
+	/* Verify Arbitration is not Lost */
+	if (xlp_i2c_read_reg(I2C_STATUS) & I2C_STATUS_AL) {
+		printk("I2C Bus Arbitration Lost, Aborting.\n");
+		goto i2c_tx_error;
+	}
+
+	for (i = 0; i<=alen; i++) {
+		xlp_i2c_write_reg(I2C_DATA, ( (slave_offset >> (i*8) ) & 0xff) | I2C_WRITE_BIT);
+		xlp_i2c_write_reg(I2C_COMMAND, I2C_COMMAND_WRITE);
+		if (xaction_complete() < 0) {
+			goto i2c_tx_error;
+		}
+		if (check_for_ack() < 0) {
+			goto i2c_tx_error;
+		}
+	}
+
+	if (len > 1) {
+
+		int bytenr = 0;
+
+		for (bytenr = 0; bytenr < len; bytenr++) {
+			xlp_i2c_write_reg(I2C_DATA, *data);
+			xlp_i2c_write_reg(I2C_COMMAND, I2C_COMMAND_WRITE);
+			if (xaction_complete() < 0) {
+				goto i2c_tx_error;
+			}
+			data++;
+		}
+	}
+	/* Last (or only) Byte: -
+	 * 	Set WR, STOP Bits
+	 */
+	xlp_i2c_write_reg(I2C_DATA, *data);
+	xlp_i2c_write_reg(I2C_COMMAND, I2C_COMMAND_STOP | I2C_COMMAND_WRITE);
+	if (xaction_complete() < 0) {
+		goto i2c_tx_error;
+	}
+	if (check_for_ack() < 0) {
+		goto i2c_tx_error;
+	}
+
+	return bus_idle();
+
+i2c_tx_error:
+	/* Release Bus */
+	xlp_i2c_write_reg(I2C_COMMAND, I2C_COMMAND_STOP);
+	bus_idle();
+	return -1;
+}
+
+/* Initialization for the Controller: -
+ * -- Disable Controller/Interrupts
+ * -- Program PreScaler
+ * -- Enable Controller (Keep Intrs disabled)
+ */
+int eeprom_init (int speed)
+{
+	int i, prescaler;
+
+	for (i=0; i<1; i++) {
+
+		u8 ctrl_reg;
+
+		prescaler = (I2C_CLKFREQ_KHZ/(5 * speed)) - 1;
+		ctrl_reg = xlp_i2c_read_reg(I2C_CONTROL);
+
+		xlp_i2c_write_reg(I2C_CONTROL,
+			     ctrl_reg & ~(I2C_CONTROL_EN | I2C_CONTROL_IEN));
+
+		xlp_i2c_write_reg(I2C_PRESCALER_LO, prescaler & 0xff);
+		xlp_i2c_write_reg(I2C_PRESCALER_HI, prescaler >> 8);
+
+		xlp_i2c_write_reg(I2C_CONTROL,
+			     xlp_i2c_read_reg(I2C_CONTROL) | I2C_CONTROL_EN);
+
+		if (xlp_i2c_read_reg(I2C_CONTROL) & I2C_CONTROL_EN) {
+			printk("Initialized I2C%d Controller.\n", i);
+		} else {
+			return -1;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(eeprom_init);
+
+int eeprom_read (u8 devaddr, uint addr, int alen, u8 * buf, int len)
+{
+	return xlp_i2c_rx(devaddr,
+			 addr,
+			 alen,
+			 len,
+			 buf);
+}
+EXPORT_SYMBOL(eeprom_read);
+
+int eeprom_write (u8 devaddr, uint addr, int alen, u8 * buf, int len)
+{
+	return xlp_i2c_tx(devaddr,
+			 addr,
+			 alen,
+			 len,
+			 buf) ;
+}
+EXPORT_SYMBOL(eeprom_write);
+
+int xlp_i2c_probe (u8 devaddr)
+{
+	return eeprom_read(devaddr,0,0,NULL,0) ;
+}
+
diff --git a/drivers/net/nae/xlp_nae.c b/drivers/net/nae/xlp_nae.c
index 899c754..8a585f2 100644
--- a/drivers/net/nae/xlp_nae.c
+++ b/drivers/net/nae/xlp_nae.c
@@ -60,6 +60,7 @@
 #include <asm/netlogic/mips-exts.h>
 
 #include "net_common.h"
+#include <asm/netlogic/hal/nlm_eeprom.h>
 #include "xlp_nae.h"
 
 #if 1
@@ -314,26 +315,9 @@ extern uint32_t nae_rx_vc;
 extern uint32_t nae_fb_vc;
 /***************************************************************/
 
-unsigned char eth_hw_addr[18][6] = {
-	{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05},
-	{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x06},
-	{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x07},
-	{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x08},
-	{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x09},
-	{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x0A},
-	{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x0B},
-	{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x0C},
-	{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x0D},
-	{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x0E},
-	{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x0F},
-	{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x10},
-	{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x11},
-	{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x12},
-	{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x13},
-	{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x14},
-	{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x15},
-	{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x16}
-};
+extern struct eeprom_data * get_nlm_eeprom(void);
+
+unsigned char eth_hw_addr[NLM_MAX_NODES][18][6];
 
 #define ETHER_FRAME_MIN_LEN	64
 static struct pci_device_id soc_pci_table[] __devinitdata = {
@@ -573,6 +557,51 @@ static int mac_refill_frin_desc(unsigned long dev)
 	return ret;
 }
 
+static int gen_mac_address(void)
+{
+	struct eeprom_data *nlm_eeprom=NULL;
+	unsigned char mac_base[6],temp,buf_write[2],buf0_read[2],buf1_read[2];
+	int if_mac_set=0,mac0_set=0, mac1_set=0;
+	int i,j;
+	buf_write[0]= MAC_MAGIC_BYTE0;
+	buf_write[1]= MAC_MAGIC_BYTE1;
+
+	memset(mac_base, '0', 6);
+	nlm_eeprom = get_nlm_eeprom();
+
+	eeprom_get_magic_bytes(nlm_eeprom,buf0_read,0);/* signature*/
+	eeprom_get_magic_bytes(nlm_eeprom,buf1_read,1);
+
+	if((buf0_read[0]==buf_write[0]) && (buf0_read[1]==buf_write[1]))/*match the signature*/
+        {
+                mac0_set=1;
+                eeprom_get_mac_addr(nlm_eeprom, mac_base,0);/* get the mac address*/
+        }
+	else if((buf1_read[0]==buf_write[0]) && (buf1_read[1]==buf_write[1]))
+	{
+		 mac1_set=1;
+		 eeprom_get_mac_addr(nlm_eeprom, mac_base,1);/* get the mac address*/
+	}
+
+	for(temp=0;temp<6;temp++)
+	{
+		if(mac_base[temp]!=0)
+		{
+			if_mac_set=1;
+		}
+	}
+
+	if( ((mac0_set | mac1_set) && if_mac_set) == 0){
+		 random_ether_addr(mac_base);
+	}
+	for(i=0 ; i<NLM_MAX_NODES; i++){ /*poppulate the eth_hw_add array according to the get mac address*/
+		 for(j=0;j<18;j++){
+			  memcpy(eth_hw_addr[i][j], mac_base, 6);
+			  mac_base[5] += 1;
+		 }
+	}
+}
+
 /*
  * nlm_xlp_nae_init - xlp_nae device driver init function
  * @dev - this is per device based function
@@ -612,6 +641,8 @@ static void nlm_xlp_nae_init(void)
 	if (initialize_nae(cpumask_to_uint32(&cpu_online_map), 0, 0, 0))
 		return;
 
+	gen_mac_address();
+
 	maxnae = nlm_node_cfg.num_nodes;	
 	for(node = 0; node < maxnae; node++) {
 		nae_cfg = nlm_node_cfg.nae_cfg[node];
@@ -646,7 +677,7 @@ static void nlm_xlp_nae_init(void)
 
 		/*netif_napi_add(dev, &priv->napi, nlm_xlp_napi_poll, 16); */
 
-		dev->dev_addr = eth_hw_addr[i];
+		dev->dev_addr = eth_hw_addr[0][i];
 		priv->port = i;
 
 		atomic64_set(&priv->frin_to_be_sent, nae_cfg->ports[i].num_free_desc);
-- 
1.7.0

