From 1b245536597216152612eeba037c65cd0f8521f7 Mon Sep 17 00:00:00 2001
From: Wu Zhangjin <zhangjin.wu@windriver.com>
Date: Wed, 6 Jul 2011 15:20:21 +0800
Subject: [PATCH 34/37] nlm_xlp_64_be: Add kexec/kdump support

Basic Kexec/kdump support is added for XLP832 A2 board with the
following limitations:

  o NAE ethernet driver cann't survive(make the system hang) in the
  second kernel(the kernel booted by kexec/kdump). It is disabled
  currently.

  o Only UP is supported by the second kernel, so "nosmp" argument
  needs to be passed by kexec-tools.

  o USB doesn't work in the second kernel.

  o Only the low memory segmentation(0 ~ 320M) is available in the
  second kernel.

More details:

  o Simplify the kernel specific support for kexec booting

    kexec booting differs from traditional booting and needs specific
    support, a is_kexec_boot() is added to determine whether the kernel
    is booted by kexec and hence simply the whole soure code.

  o Reserving memory of DTB needed by the 2nd kernel

    XLP need DTB to describe some of the devices, currently, we don't
    support loading a new DTB for the 2nd kernel but simply reserve the
    memory of DTB in the 1st kernel. A kexeck_res struct is added for
    this support.

  o Ignore original wakeup of the secondary cpus

    The secondary cpus are not initialized before entering into the 1st
    kernel and hence are needed to be waken up in hardware methods, but
    for the 2nd kernel, those cpus are put into loops, which are only
    needed to be waken up by setting a flag. But setting a flag is not
    enough, the waking up order of the secondary cpus may be not the
    same as the order in the 1st kernel, therefore, the related
    operations in prom_boot_cpus_secondary() and nlm_boot_secondary()
    should be changed. Of course, the waking up operation:
    wakeup_secondary_cpus() should be changed too. This will be done in
    the future, we only support UP for the 2nd kernel currently, so,
    "nosmp" argument should be passed to the 2nd kernel.

  o Skip the NAE ethernet driver

    NAE ethernet driver simply make the whole system hang in the 2nd
    kernel, the issue is not easy to be tracked, just skip it in this
    version.

  o Kdump specific memory map

    The memory map of dump-capture kernel(the 2nd kernel) is set by
    kexec-tools automatically, we can not re-config it with the
    description in DTS.

  o Limit the second kernel with the low memory segmentation(0 ~ 320M)

    System may crash when using all of the memory, but only using the
    low memory segmentation(0 ~ 320M) works without any problem. so,
    only use this segmentation in this version.

  o More

    + Fix and Enhance nlm_local_flush_tlb_all(), nlm_common_flush_l1_caches_ipi()
    + Add kexec_flush_icache_page() for MIPS, based on powerpc.
    + prom_init() is moved after setup_early_printk() to make debugging
      available in fdt_process()
    + Reduce the load adderss to original kernel to 2M to avoid the
    conflict between it and the load address(0xffffffff84000000) of the
    dump-caputure kernel.

These changes are derived from the kexec support for the XLR732-based
boards completed in the previous release.

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>
Signed-off-by: Wu Zhangjin <zhangjin.wu@windriver.com>
---
 arch/mips/boot/dts/xlp832.dts                   |    7 +
 arch/mips/include/asm/kexec.h                   |    7 +
 arch/mips/include/asm/mach-netlogic/nlm_kexec.h |   48 +++++
 arch/mips/kernel/machine_kexec.c                |    8 +
 arch/mips/kernel/relocate_kernel.S              |  161 +++++++++++++---
 arch/mips/kernel/setup.c                        |   15 ++-
 arch/mips/mm/c-phoenix.c                        |   15 +-
 arch/mips/netlogic/Kconfig                      |    2 +-
 arch/mips/netlogic/common/Makefile              |    1 +
 arch/mips/netlogic/common/nlm_kexec.c           |  234 +++++++++++++++++++++++
 arch/mips/netlogic/xlp/irq.c                    |   11 +-
 arch/mips/netlogic/xlp/platform.c               |    1 +
 arch/mips/netlogic/xlp/setup.c                  |  104 ++++++++---
 drivers/net/nae/xlp_nae.c                       |    6 +
 14 files changed, 552 insertions(+), 68 deletions(-)
 create mode 100644 arch/mips/include/asm/mach-netlogic/nlm_kexec.h
 create mode 100644 arch/mips/netlogic/common/nlm_kexec.c

diff --git a/arch/mips/boot/dts/xlp832.dts b/arch/mips/boot/dts/xlp832.dts
index 4f501b3..f922e7f 100644
--- a/arch/mips/boot/dts/xlp832.dts
+++ b/arch/mips/boot/dts/xlp832.dts
@@ -59,7 +59,14 @@
 		bootargs = "root=/dev/nfs rw nfsroot=192.168.0.1:/opt/rootfs/xlp832-n32 ip=192.168.0.2:192.168.0.1:192.168.0.1:255.255.254.0:xlp:eth4:off console=ttyS0,115200";
 		*/
 		/* For NOR root filesystem */
+		/*
 		bootargs = "root=/dev/mtdblock4 rw rootfstype=jffs2 ip=192.168.0.2:192.168.0.1:192.168.0.1:255.255.254.0:xlp:eth4:off console=ttyS0,115200";
+		*/
+		/* For kdump,CONFIG_PHYSICAL_START=0xffffffff84000000
+		 * Only PCIe ethernet driver(eth0) survive after booting
+		 * by kexec.
+		 */
+		bootargs = "crashkernel=128M@63M root=/dev/nfs rw nfsroot=192.168.0.1:/opt/rootfs/xlp832-n32,nfsvers=3 ip=192.168.0.2:192.168.0.1:192.168.0.1:255.255.254.0:xlp:eth0:off console=ttyS0,115200";
 	};
 
 	/* These binaries are downloaded at the resp physical memory locations
diff --git a/arch/mips/include/asm/kexec.h b/arch/mips/include/asm/kexec.h
index 54302d4..b282f83 100644
--- a/arch/mips/include/asm/kexec.h
+++ b/arch/mips/include/asm/kexec.h
@@ -33,7 +33,14 @@ static inline void crash_setup_regs(struct pt_regs *newregs,
 }
 
 #ifdef CONFIG_KEXEC
+
+#define kexec_flush_icache_page(page) do {			\
+	unsigned long addr = (unsigned long)page_address(page);	\
+	flush_icache_range(addr, addr + PAGE_SIZE);		\
+} while (0)
+
 struct kimage;
+extern struct resource kexeck_res;
 extern unsigned long kexec_args[4];
 extern int (*_machine_kexec_prepare)(struct kimage *);
 extern void (*_machine_kexec_shutdown)(void);
diff --git a/arch/mips/include/asm/mach-netlogic/nlm_kexec.h b/arch/mips/include/asm/mach-netlogic/nlm_kexec.h
new file mode 100644
index 0000000..035a131
--- /dev/null
+++ b/arch/mips/include/asm/mach-netlogic/nlm_kexec.h
@@ -0,0 +1,48 @@
+/* Copyright (c) 2011 Windriver Systems, Inc.
+ * Author: Wu Zhangjin <zhangjin.wu@windriver.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _NLM_KEXEC
+#define _NLM_KEXEC
+
+#ifndef NLM_HAL_LINUX_KERNEL
+#define NLM_HAL_LINUX_KERNEL
+#endif
+
+#include <linux/kexec.h>
+#include <asm/kexec.h>
+#include <asm/bootinfo.h>
+#include <asm/uaccess.h>
+#include <linux/mm.h>
+#include <asm/page.h>
+#include <asm/netlogic/mips-exts.h>
+#include <linux/delay.h>
+#include <linux/ctype.h>
+
+#include <asm/netlogic/hal/nlm_hal_nae.h>
+#include <asm/mach-netlogic/nlm_kexec.h>
+#include <linux/bootmem.h>
+#include <asm/setup.h>
+
+/* DTB is about 9kb */
+#define DTB_SIZE	(1 << 14)	/* 16kb */
+#define DTB_ORDER	((DTB_SIZE >> PAGE_SHIFT) - 1)
+
+#ifndef MAX_PROP_LEN
+#define MAX_PROP_LEN 256
+#endif
+
+#define KEXEC_CMDLINE_OFFSET (DTB_SIZE - MAX_PROP_LEN - 1)
+#define kexec_cmdline_addr(base) (base + KEXEC_CMDLINE_OFFSET)
+
+#define KEXEC_BOOT_FLAG	0xebebebeb
+
+static inline bool is_kexec_boot(void)
+{
+	return fw_arg3 == KEXEC_BOOT_FLAG;
+}
+
+#endif /* _NLM_KEXEC */
diff --git a/arch/mips/kernel/machine_kexec.c b/arch/mips/kernel/machine_kexec.c
index cbdb9be..96fe604 100644
--- a/arch/mips/kernel/machine_kexec.c
+++ b/arch/mips/kernel/machine_kexec.c
@@ -25,6 +25,14 @@ void (*_machine_crash_shutdown)(struct pt_regs *regs);
 void (*_machine_cache_flush)(void) = NULL;
 void (*_machine_smp_handle_restart)(unsigned long reloc) = NULL;
 
+/* Location of the reserved area for the kexec kernel */
+struct resource kexeck_res = {
+	.name  = "Kexec Kernel",
+	.start = 0,
+	.end   = 0,
+	.flags = IORESOURCE_BUSY | IORESOURCE_MEM
+};
+
 int
 machine_kexec_prepare(struct kimage *kimage)
 {
diff --git a/arch/mips/kernel/relocate_kernel.S b/arch/mips/kernel/relocate_kernel.S
index 4324671..28950e6 100644
--- a/arch/mips/kernel/relocate_kernel.S
+++ b/arch/mips/kernel/relocate_kernel.S
@@ -14,12 +14,25 @@
 #include <asm/stackframe.h>
 #include <asm/addrspace.h>
 
+/* These are taken from linux/kexec.h and should always be in sync */
+#ifndef IND_DESTINATION
+#define IND_DESTINATION  0x1
+#endif
+#ifndef IND_INDIRECTION
+#define IND_INDIRECTION  0x2
+#endif
+#ifndef IND_DONE
+#define IND_DONE         0x4
+#endif
+#ifndef IND_SOURCE
+#define IND_SOURCE       0x8
+#endif
 
 LEAF(relocate_new_kernel)
-     PTR_L a0,    arg0
-     PTR_L a1,    arg1
-     PTR_L a2,    arg2
-     PTR_L a3,    arg3
+	PTR_L		a0, arg0
+	PTR_L		a1, arg1
+	PTR_L		a2, arg2
+	PTR_L		a3, arg3
 
 	PTR_LA		s0, kexec_indirection_page
 	PTR_L		s1, kexec_start_address
@@ -28,44 +41,37 @@ process_entry:
 	PTR_L		s2, (s0)
 	PTR_ADD		s0, s0, SZREG
 
-	/* destination page */
-	and		s3, s2, 0x1
+	/* destination page, store it in s4 */
+	and		s3, s2, IND_DESTINATION
 	beq		s3, zero, 1f
 	nop
-	and		s4, s2, ~0x1	/* store destination addr in s4 */
-
-	nop
+	and		s4, s2, ~IND_DESTINATION
 	b		process_entry
 	nop
 
 1:
 	/* indirection page, update s0  */
-	and		s3, s2, 0x2
+	and		s3, s2, IND_INDIRECTION
 	beq		s3, zero, 1f
 	nop
-	and		s0, s2, ~0x2
-
-	nop
-
+	and		s0, s2, ~IND_INDIRECTION
 	b		process_entry
 	nop
 
 1:
-	/* done page */
-	and		s3, s2, 0x4
+	/* done page, stop */
+	and		s3, s2, IND_DONE
 	beq		s3, zero, 1f
 	nop
-
-	nop
 	b		done
 	nop
 
 1:
-	/* source page */
-	and		s3, s2, 0x8
+	/* source page?: copy; if not, skip it (we somehow got crap) */
+	and		s3, s2, IND_SOURCE
 	beq		s3, zero, process_entry
 	nop
-	and		s2, s2, ~0x8
+	and		s2, s2, ~IND_SOURCE
 	li		s6, (1 << PAGE_SHIFT) / SZREG
 
 copy_word:
@@ -81,7 +87,6 @@ copy_word:
 	nop
 
 1:
-	nop
 	b 		process_entry
 	nop
 
@@ -92,7 +97,7 @@ done:
         of kexec_flag.  */
 
 	.align	3
-	bal	1f
+	bal	1f	/* MUST be first instruction in done: */
 	nop
 1:
 	.align	3
@@ -100,8 +105,8 @@ done:
 	move		t1, ra;
 	PTR_LA		t2, done
 	PTR_LA		t0, kexec_flag
-	PTR_SUB		t0, t0, t2;
-	PTR_ADD		t0, t1, t0;
+	PTR_SUBU	t0, t0, t2;
+	PTR_ADDU	t0, t1, t0;
 	LONG_S		zero, (t0)
 #endif
 
@@ -111,13 +116,43 @@ done:
 #ifdef CONFIG_CPU_CAVIUM_OCTEON
 	cache	0, 0($0)
 #endif
+#ifdef CONFIG_CPU_XLP
+	bal     kexec_nlm_flush_cache
+	nop
+#endif
 
 	/* jump to kexec_start_address */
 	j		s1
 	nop
-	nop
-	nop
-	END(relocate_new_kernel)
+END(relocate_new_kernel)
+
+#ifdef CONFIG_CPU_XLP
+LEAF(kexec_nlm_flush_cache)
+	/* From RMI's boot1/cache.S, but implemented with only 2 regs. */
+	/* FIXME: Obtain size and num cache lines from CP0 config1 reg.
+	 *        (Try to do the following with 2 regs in that case!)
+	 */
+	li		t9,0
+1:
+	li		t8,0x80000000
+	sll		t9,t9,5
+	add		t8,t8,t9
+	sra		t9,t9,5
+	cache		0,0(t8)
+	cache		1,0(t8)
+	addiu		t9,1
+	slti		t8,t9,1024
+	bnez		t8,1b
+	 nop
+	/* pipeline flush */
+	dla		t8, 2f
+	jr.hb 		t8
+	 nop
+	2: nop
+	jr		ra
+	 nop
+END(kexec_nlm_flush_cache)
+#endif /* CONFIG_CPU_XLP */
 
 #ifdef CONFIG_SMP
 /*
@@ -161,8 +196,76 @@ wait:
 	j        s1
 	nop
 	END(kexec_smp_wait)
-#endif
 
+#ifdef CONFIG_CPU_XLP
+/* OK, RMI is interesting. The secondary CPUs do NOT start at the kernel entry,
+ * but rather are signalled to jump to an address in the second kernel, which
+ * is part of the RMI-specific init sequence called within setup_arch().
+ *
+ * The boot CPU calls a routine installed by the boot loader in boot loader
+ * memory. We have to mimic this by installing a routine in the control page.
+ * This routine will simply set a variable to 1, signalling the secondary CPUs
+ * that they can get out of their spin. The routine also installs a function
+ * pointer that tells the secondary CPUs to jump to a routine (namely
+ * prom_pre_boot_secondary_cpus()) in the second kernel.
+ *
+ * When computing addresses of relocated symbols here, we need the functions
+ * to be double-word aligned, since the pointers are 64-bit, to avoid taking
+ * non-aligned exceptions (the exception handlers are invalid at this point).
+ * The computations are done relative to the start of the functions so that
+ * the start point is aligned. We can't perform computation based on return
+ * addresses and forward symbols since the assembler might add NOPs after
+ * branches and thus throw the computation off, possibly giving a 4-byte
+ * aligned address instead of an 8-byte aligned one.
+ */
+
+LEAF(kexec_nlm_secondary_cpu_spin)
+	.align	3
+	bal	1f      /* MUST be first instruction */
+	nop
+1:
+	.align	3
+	PTR_ADDIU	ra,ra,-8 /* -8 *if* bal is first instruction */
+	PTR_LA		t0,kexec_nlm_secondary_cpu_spin
+	PTR_LA		v0,kexec_secondary_cpu_spin_var
+	PTR_SUBU	t1,v0,t0 /* t1 <= offset to relocated spin_var */
+	PTR_ADDU	v0,ra,t1 /* v0 now contains the relocated variable addr */
+2:
+	LONG_L		t1,(v0)
+	beq		t1,zero,2b
+	nop
+
+	/* out of the spin loop, kexec_secondary_cpu_next_kernel_entry_point
+	 * now contains the address where to jump to in the second kernel
+	 *
+	 * t0 still contains address of non-relocated
+	 * kexec_nlm_secondary_cpu_spin()
+	 */
+	PTR_LA		v0,kexec_secondary_cpu_next_kernel_entry_point
+	PTR_SUBU	t1,v0,t0 /* t1 <= offset to relocated entry_pt */
+	PTR_ADDU	v0,ra,t1 /* v0 now contains the relocated variable addr */
+	PTR_L		t1,(v0)
+	bal		kexec_nlm_flush_cache
+	nop
+	jr		t1
+	nop
+END(kexec_nlm_secondary_cpu_spin)
+
+	.align	3
+kexec_secondary_cpu_spin_var:
+EXPORT(kexec_secondary_cpu_spin_var)
+	LONG	0x0
+	.size	kexec_secondary_cpu_spin_var, PTRSIZE
+
+	.align	3
+kexec_secondary_cpu_next_kernel_entry_point:
+EXPORT(kexec_secondary_cpu_next_kernel_entry_point)
+	PTR	0x0
+	.size	kexec_secondary_cpu_next_kernel_entry_point, PTRSIZE
+
+#endif /* CONFIG_CPU_XLP */
+
+#endif /* CONFIG_SMP */
 
 #ifdef __mips64
        /* all PTR's must be aligned to 8 byte in 64-bit mode */
diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index e2f87c3..4ab5377 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -520,6 +520,12 @@ static void __init arch_mem_init(char **cmdline_p)
 
 	bootmem_init();
 #ifdef CONFIG_KEXEC
+	pr_info("Kexeckernel info: start = %llu end = %llu\n",
+		kexeck_res.start, kexeck_res.end);
+	if (kexeck_res.start != kexeck_res.end)
+		reserve_bootmem(kexeck_res.start,
+			kexeck_res.end - kexeck_res.start + 1, 0);
+
 	pr_info("Crashkernel info:\n");
 	pr_info("\tstart=%llu end=%llu\n", crashk_res.start, crashk_res.end);
 	if (crashk_res.start != crashk_res.end)
@@ -581,7 +587,10 @@ static void __init resource_init(void)
 		request_resource(res, &code_resource);
 		request_resource(res, &data_resource);
 #ifdef CONFIG_KEXEC
-		request_resource(res, &crashk_res);
+		if (kexeck_res.end != 0)
+			request_resource(res, &kexeck_res);
+		if (crashk_res.end != 0)
+			request_resource(res, &crashk_res);
 #endif
 	}
 }
@@ -589,11 +598,13 @@ static void __init resource_init(void)
 void __init setup_arch(char **cmdline_p)
 {
 	cpu_probe();
-	prom_init();
 
 #ifdef CONFIG_EARLY_PRINTK
 	setup_early_printk();
 #endif
+
+	prom_init();
+
 	cpu_report();
 	check_bugs_early();
 
diff --git a/arch/mips/mm/c-phoenix.c b/arch/mips/mm/c-phoenix.c
index c18576b..3700ef4 100644
--- a/arch/mips/mm/c-phoenix.c
+++ b/arch/mips/mm/c-phoenix.c
@@ -34,6 +34,8 @@
 
 static unsigned int icache_linesz;
 static unsigned int icache_lines;
+static unsigned int dcache_linesz;
+static unsigned int dcache_lines;
 
 #define cacheop(op, base) \
 	__asm__ __volatile__ (".set push\n.set mips4\ncache %0, 0(%1)\n.set pop\n" : : "i"(op), "r"(base))
@@ -163,14 +165,11 @@ static void nlm_common_local_flush_dcache(void)
 {
 	int i;
 	unsigned long base = CKSEG0;
-	unsigned int lines;
-
-	lines = current_cpu_data.dcache.ways * current_cpu_data.dcache.sets;
 
 	/* Index Invalidate all the lines and the ways */
-	for (i = 0; i < lines; i++) {
+	for (i = 0; i < dcache_lines; i++) {
 		cacheop(Index_Writeback_Inv_D, base);
-		base += current_cpu_data.dcache.linesz;
+		base += dcache_linesz;
 	}
 
 	cacheop_hazard();
@@ -183,11 +182,7 @@ void nlm_common_flush_l1_icache_ipi(void *info)
 }
 #endif
 
-#ifdef CONFIG_KGDB
 void nlm_common_flush_l1_caches_ipi(void *info)
-#else
-static void nlm_common_flush_l1_caches_ipi(void *info)
-#endif
 {
 	optimize_thread_flush();
 
@@ -278,6 +273,8 @@ void nlm_cache_init(void)
 	/* These values are assumed to be the same for all cores */
 	icache_lines = current_cpu_data.icache.ways * current_cpu_data.icache.sets;
 	icache_linesz = current_cpu_data.icache.linesz;
+	dcache_lines = current_cpu_data.dcache.ways * current_cpu_data.dcache.sets;
+	dcache_linesz = current_cpu_data.dcache.linesz;
 
 	/* When does this function get called? Looks like MIPS has some syscalls
 	 * to flush the caches.
diff --git a/arch/mips/netlogic/Kconfig b/arch/mips/netlogic/Kconfig
index 7ad474c..4530fd1 100644
--- a/arch/mips/netlogic/Kconfig
+++ b/arch/mips/netlogic/Kconfig
@@ -33,7 +33,7 @@ config NLM_TLB_STAT
 config NLM_COMMON_LOAD_ADDRESS
 	hex "Netlogic Linux kernel start address"
 	depends on NLM_COMMON
-	default "0xffffffff84000000"
+	default "0xffffffff80200000"
 	help
 	  This is start address for the linux kernel. Default value
           should be good for most of the applications unless specified
diff --git a/arch/mips/netlogic/common/Makefile b/arch/mips/netlogic/common/Makefile
index 22511e6..9d5d197 100644
--- a/arch/mips/netlogic/common/Makefile
+++ b/arch/mips/netlogic/common/Makefile
@@ -4,5 +4,6 @@ obj-y :=   cpu_proc.o memory.o bootinfo.o
 
 obj-$(CONFIG_NLM_XLP)			+= nlm_hal_fmn_config.o
 obj-$(CONFIG_NLM_XLP)			+= nlm_hal.o nlm_hal_nae.o fdt_helper.o
+obj-$(CONFIG_KEXEC)			+= nlm_kexec.o
 
 EXTRA_AFLAGS := $(CFLAGS)
diff --git a/arch/mips/netlogic/common/nlm_kexec.c b/arch/mips/netlogic/common/nlm_kexec.c
new file mode 100644
index 0000000..9efa05f
--- /dev/null
+++ b/arch/mips/netlogic/common/nlm_kexec.c
@@ -0,0 +1,234 @@
+/*
+ * nlm_kexec.c, kexec support for NLM XLR832-based boards
+ *
+ * Copyright (c) 20011 Wind River Systems, Inc.
+ * Author:     Wu Zhangjin <zhangjin.wu@windriver.com>
+ *
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ * Author:     Benjamin Walsh <benjamin.walsh@windriver.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/kexec.h>
+#include <asm/kexec.h>
+#include <asm/bootinfo.h>
+#include <asm/uaccess.h>
+#include <linux/mm.h>
+#include <asm/page.h>
+#include <asm/netlogic/mips-exts.h>
+#include <linux/delay.h>
+#include <linux/ctype.h>
+#include <linux/ioport.h>
+
+#include <asm/netlogic/hal/nlm_hal_nae.h>
+#include <asm/mach-netlogic/nlm_kexec.h>
+#include <linux/bootmem.h>
+
+#define WAIT_TIME_FOR_OTHER_CPUS_IN_MSECS 10000
+
+static int nlm_kexec_prepare(struct kimage *);
+static void nlm_kexec_shutdown(void);
+static void nlm_smp_handle_restart(unsigned long reloc);
+static void nlm_crash_shutdown(struct pt_regs *regs);
+static void nlm_do_cache_flush(void);
+extern void nlm_local_flush_tlb_all(void);
+
+static int rebooting_cpu = -1;
+static cpumask_t cpus_in_reboot = CPU_MASK_NONE;
+
+#ifdef CONFIG_SMP
+void (*relocated_kexec_nlm_secondary_cpu_spin) (void);
+atomic_t kexec_relocate_kernel_ready = ATOMIC_INIT(0);
+extern void kexec_nlm_secondary_cpu_spin(void);
+#endif
+
+extern const unsigned char relocate_new_kernel[];
+extern const size_t relocate_new_kernel_size;
+
+extern int (*_machine_kexec_prepare) (struct kimage *);
+extern void (*_machine_kexec_shutdown) (void);
+extern void (*_machine_crash_shutdown) (struct pt_regs *regs);
+extern void (*_machine_cache_flush) (void);
+extern void (*_machine_smp_handle_restart) (unsigned long reloc);
+
+void nlm_local_flush_tlb_all(void)
+{
+	unsigned long old_ctx;
+	int entry;
+	int tlbsize;
+
+	/* Refer to arch/mips/netlogic/xlp/mmu.c */
+	tlbsize = ((read_c0_config6() >> 16) & 0xffff) + 1;
+
+	/* Save old context and create impossible VPN2 value */
+	old_ctx = (read_c0_entryhi() & 0xff);
+	write_c0_entrylo0(0);
+	write_c0_entrylo1(0);
+	for (entry = 0; entry < tlbsize; entry++) {
+		write_c0_entryhi(((unsigned long)CKSEG0 +
+				  (PAGE_SIZE << 1) * entry));
+		write_c0_index(entry);
+		mtc0_tlbw_hazard();
+		tlb_write_indexed();
+	}
+	tlbw_use_hazard();
+	write_c0_entryhi(old_ctx);
+}
+
+void nlm_kexec_init(void)
+{
+	_machine_kexec_prepare = nlm_kexec_prepare;
+	_machine_kexec_shutdown = nlm_kexec_shutdown;
+	_machine_crash_shutdown = nlm_crash_shutdown;
+	_machine_cache_flush = nlm_do_cache_flush;
+	_machine_smp_handle_restart = nlm_smp_handle_restart;
+
+	/* Resource need to be reserved: DTB, command line */
+	kexeck_res.start = __pa(fw_arg0);
+	kexeck_res.end = kexeck_res.start + DTB_SIZE - 1;
+}
+
+extern void nlm_common_flush_l1_caches_ipi(void *info);
+
+static void nlm_do_cache_flush(void)
+{
+	nlm_common_flush_l1_caches_ipi(NULL);
+}
+
+static void shutdown_secondary_cpus(void *crash)
+{
+	struct pt_regs *regs = NULL;
+	int cpu;
+
+	if ((unsigned long)crash)
+		regs = task_pt_regs(current);
+
+	local_irq_disable();
+	cpu = smp_processor_id();
+
+	if (!cpu_online(cpu))
+		return;
+
+	if (!cpu_isset(cpu, cpus_in_reboot)) {
+		if (regs)
+			crash_save_cpu(regs, cpu);
+		cpu_set(cpu, cpus_in_reboot);
+	}
+
+	while (!atomic_read(&kexec_relocate_kernel_ready))
+		cpu_relax();
+
+	nlm_local_flush_tlb_all();
+	relocated_kexec_nlm_secondary_cpu_spin();
+	/* NOTREACHED */
+}
+
+extern void fixup_irqs(unsigned int cpu, int flag);
+
+static void prepare_cpus(const unsigned long crash)
+{
+	int cpu;
+
+	smp_call_function(shutdown_secondary_cpus, (void *)crash, 0);
+	smp_wmb();
+	local_irq_disable();
+	/* Reset some devices for rebooting */
+	for_each_online_cpu(cpu)
+		fixup_irqs(cpu, 0);
+}
+
+static void wait_for_cpus(void)
+{
+	unsigned int msecs;
+	unsigned int ncpus = num_online_cpus();
+	unsigned int rebooting_cpus;
+
+	rebooting_cpu = smp_processor_id();
+	cpu_set(rebooting_cpu, cpus_in_reboot);
+
+	msecs = WAIT_TIME_FOR_OTHER_CPUS_IN_MSECS;
+	while ((rebooting_cpus = cpus_weight(cpus_in_reboot)) < ncpus) {
+		if (--msecs <= 0)
+			break;
+		cpu_relax();
+		mdelay(1);
+	}
+}
+
+static int nlm_kexec_prepare(struct kimage *kimage)
+{
+	void *kexec_cmdline;
+	struct kexec_segment *s;
+	char buffer[32];
+	int len, i;
+
+	/* handle the arguments passed by kexec-tools */
+	for (i = 0; i < kimage->nr_segments; i++) {
+		s = &kimage->segment[i];
+		len = min(32, (int)s->bufsz);
+		copy_from_user((void *)buffer, s->buf, len);
+		buffer[len] = 0; /* just in case... */
+		if (strncmp(buffer, "kexec ", 6) == 0)
+			break;
+	}
+	kexec_cmdline = kexec_cmdline_addr(fw_arg0);
+	if (i != kimage->nr_segments) {
+		copy_from_user(kexec_cmdline,
+			(char *)kimage->segment[i].buf,
+			kimage->segment[i].bufsz);
+		pr_debug("%s: cmdline from kexec-tools:\n%s\n", __func__, (char *)(kexec_cmdline));
+	}
+
+	kexec_args[0] = fw_arg0;
+	kexec_args[1] = fw_arg1;
+	kexec_args[2] = fw_arg2;
+	/* Use this flag to check whether boot from kexec */
+	kexec_args[3] = KEXEC_BOOT_FLAG;
+
+	return 0;
+}
+
+static void nlm_kexec_shutdown(void)
+{
+	prepare_cpus(0);
+	wait_for_cpus();
+	nlm_local_flush_tlb_all();
+}
+
+static void nlm_crash_shutdown(struct pt_regs *regs)
+{
+	crash_save_cpu(regs, smp_processor_id());
+	prepare_cpus(1);
+	wait_for_cpus();
+	nlm_local_flush_tlb_all();
+}
+
+#ifdef CONFIG_SMP
+static void nlm_smp_handle_restart(unsigned long reloc)
+{
+	/* All secondary cpus now may jump to kexec_wait cycle */
+	relocated_kexec_smp_wait =
+	    (void *)(reloc + (kexec_smp_wait - relocate_new_kernel));
+	relocated_kexec_nlm_secondary_cpu_spin =
+	    (void *)(reloc + ((ulong) kexec_nlm_secondary_cpu_spin -
+			      (ulong) relocate_new_kernel));
+	smp_wmb();
+	atomic_set(&kexec_relocate_kernel_ready, 1);
+}
+#else
+static void nlm_smp_handle_restart(unsigned long reloc)
+{
+}
+#endif	/* CONFIG_SMP */
diff --git a/arch/mips/netlogic/xlp/irq.c b/arch/mips/netlogic/xlp/irq.c
index c24ee52..72da893 100644
--- a/arch/mips/netlogic/xlp/irq.c
+++ b/arch/mips/netlogic/xlp/irq.c
@@ -357,6 +357,10 @@ void __cpuinit nlm_smp_irq_init(void)
 	/* Set up kseg0 to be cachable coherent */
 	change_c0_config(CONF_CM_CMASK, CONF_CM_DEFAULT);
 #endif
+	/* clear all pending interrupts (don't touch timer and soft,
+	 * they're special) */
+	write_64bit_cp0_eirr(0xffffffffffffff7c);
+
 	/* set interrupt mask for non-zero cpus */
 	write_64bit_cp0_eimr(nlm_xlp_irq_mask | (1 << IRQ_TIMER));
 }
@@ -368,6 +372,11 @@ void __init arch_init_irq(void)
 		return;
 #endif
 
+	/* clear all pending interrupts */
+	write_64bit_cp0_eirr(0xffffffffffffffff);
+	/* Mask out all interrupts */
+	write_64bit_cp0_eimr(0);
+
 	/* Initialize the irq descriptors */
 	init_nlm_common_irqs();
 
@@ -414,7 +423,7 @@ asmlinkage void plat_irq_dispatch(void)
 	do_IRQ(irq);
 }
 
-#ifdef CONFIG_HOTPLUG_CPU
+#if defined(CONFIG_HOTPLUG_CPU) || defined(CONFIG_KEXEC)
 
 extern void on_chip_shutoff_msgring(void);
 extern void nlm_disable_vc_intr(void);
diff --git a/arch/mips/netlogic/xlp/platform.c b/arch/mips/netlogic/xlp/platform.c
index 842fee9..28ecd01 100644
--- a/arch/mips/netlogic/xlp/platform.c
+++ b/arch/mips/netlogic/xlp/platform.c
@@ -34,6 +34,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <linux/serial_reg.h>
 #include <linux/spinlock.h>
 
+#include <asm/bootinfo.h>
 #include <asm/time.h>
 #include <asm/netlogic/hal/nlm_hal_macros.h>
 #include <asm/netlogic/hal/nlm_hal_pic.h>
diff --git a/arch/mips/netlogic/xlp/setup.c b/arch/mips/netlogic/xlp/setup.c
index 12f13d4..baed5f7 100644
--- a/arch/mips/netlogic/xlp/setup.c
+++ b/arch/mips/netlogic/xlp/setup.c
@@ -59,7 +59,9 @@
 #include <asm/netlogic/cpumask.h>
 #include <asm/netlogic/hal/nlm_hal_macros.h>
 #include <asm/netlogic/hal/nlm_hal_pic.h>
+#include <asm/netlogic/hal/nlm_hal_nae.h>
 
+#include <asm/mach-netlogic/nlm_kexec.h>
 #include "../boot/ops.h"
 
 /* Certain macros for this file
@@ -347,9 +349,11 @@ static int fdt_process(void)
 	int  i, na, ns, regs[6], entries, cpu_cells;
 	uint32_t node_vc_mask[4] = {0};
 	extern uint32_t nlm_cpu_vc_mask[NLM_MAX_CPU_NODE*NLM_MAX_CPU_PER_NODE];
-	unsigned char buf[30];	
+	unsigned char buf[30];
 	int j, id=0, k, tmp;
 	uint32_t onlinemask[MAX_CPUMASK_CELLS];
+	int have_kexec_cmdline = 0;
+	int boot_for_kdump = 0;
 
 	/* If booted using FDT and U-Boot, all
 	 * we get is a pointer to an FDT Blob
@@ -357,6 +361,24 @@ static int fdt_process(void)
 	void *blob = (void *)fw_arg0;
 	void *node;
 
+	if (is_kexec_boot()) {
+		/* Copy out the cmdline from the kexec control page reserved by parent kernel */
+		memset(prop_buf, '\0', MAX_PROP_LEN);
+		pr_debug("%s: copy cmdline from %p\n", __func__, kexec_cmdline_addr(blob));
+		memcpy(prop_buf, kexec_cmdline_addr(blob), MAX_PROP_LEN);
+		pr_debug("%s: cmdline = \n%s\n", __func__, prop_buf);
+		if (strncmp(prop_buf, "kexec ", 6) == 0) {
+			have_kexec_cmdline = 1;
+			/* elfcorehdr= is passed by kexec-tools when
+			 * booting from kernel panic.
+			 */
+			if ((strstr(prop_buf, "elfcorehdr=")) != NULL) {
+				pr_debug("%s: Boot from kernel panic\n", __func__);
+				boot_for_kdump = 1;
+			}
+		}
+	}
+
 	cpumask_clear(&fdt_cpumask);
 
 	if(!blob)
@@ -378,11 +400,18 @@ static int fdt_process(void)
 
 	/* extract cmdline params
 	 */
-	node = finddevice("/chosen");
-	if (node) {
-		if (getprop(node, "bootargs", prop_buf, MAX_PROP_LEN) < 0)
-			return -1;
+	if (have_kexec_cmdline) {
+		/* If kexec-tools passes kernel arguments, we ignore the
+		 * ones passed from DTS to avoid duplication.
+		 */
 		strcat(arcs_cmdline, prop_buf);
+	} else {
+		node = finddevice("/chosen");
+		if (node) {
+			if (getprop(node, "bootargs", prop_buf, MAX_PROP_LEN) < 0)
+				return -1;
+			strcat(arcs_cmdline, prop_buf);
+		}
 	}
 
 	/* extract memory ranges,
@@ -413,31 +442,46 @@ static int fdt_process(void)
 			printk("Can't cope with #cpumask-cells == %d\n\r", cpu_cells);
 	}
 
-	node = finddevice("/doms/dom@0/memory");
-	if (node) {
-		entries = (getprop(node, "reg", regs, sizeof(regs))) / sizeof(regs[0]);
-		if (!entries || (entries % (na+ns)))
-			printk("Invalid Memory Map Specified!\n");
-
-		for (i=0; i<entries; i+=2) {
-			unsigned long long addr, size;
-
-			addr = fdt32_to_cpu(regs[i]);
-			size = fdt32_to_cpu(regs[i + 1]);
-
-			if (size == 0)
-				continue;
+	if (!boot_for_kdump) {
+		/* Memory map for kdump is assigned by kexec-tools,
+		 * We can not indicate our own memory map with "mem"
+		 * kernel argument or read the memory map from DTS.
+		 * The root cause is dump-capture kernel can only
+		 * Use the memory reserved by crashkernel.
+		 */
+		node = finddevice("/doms/dom@0/memory");
+		if (node) {
+			entries = (getprop(node, "reg", regs, sizeof(regs))) / sizeof(regs[0]);
+			if (!entries || (entries % (na+ns)))
+				printk("Invalid Memory Map Specified!\n");
+
+			/* FIXME: Kexec kernel currently only works with
+			 * the low memory segmentation(0 ~ 320M), it
+			 * crashes if using the other 2 segmentations.
+			 */
+			if (is_kexec_boot())
+				entries = 1;
+
+			for (i = 0; i < entries; i += 2) {
+				unsigned long long addr, size;
+
+				addr = fdt32_to_cpu(regs[i]);
+				size = fdt32_to_cpu(regs[i + 1]);
+
+				if (size == 0)
+					continue;
 
-			sprintf(domstr, " mem=%lldm@%lldm ", size, addr);
-			strcat(arcs_cmdline, domstr);
-			memset((void *)&domstr, '\0', sizeof(domstr));
+				sprintf(domstr, " mem=%lldm@%lldm ", size, addr);
+				strcat(arcs_cmdline, domstr);
+				memset((void *)&domstr, '\0', sizeof(domstr));
+			}
 		}
 	}
 
 	printk("FDT Cmdline: %s\n", arcs_cmdline);
 
 
-	/* 
+	/*
 	 * extract CPU online mask for domain 0 (linux)
 	 */
 	for (i = 0; i < MAX_CPUMASK_CELLS; i++)
@@ -473,7 +517,7 @@ static int fdt_process(void)
 			int j = 0;
 
 			for (j = 0; j < 32; j++) {
-				if ((onlinemask[i] & (1 << j)) == 0) 
+				if ((onlinemask[i] & (1 << j)) == 0)
 					continue;
 				cpumask_set_cpu((i * 32 + j), &fdt_cpumask);
 			}
@@ -607,12 +651,15 @@ char* get_cpu_info(void)
 
 static void xen_init(void) {}
 
+#ifdef CONFIG_KEXEC
+extern void nlm_kexec_init(void);
+#endif
+
 void __init prom_init(void)
 {
 	setup_mapped_kernel_tlbs(TRUE, TRUE);
 
 	fdt_process();
-
 	xen_init();
 
 	nlm_common_ebase = read_c0_ebase() & (~((1 << 12) - 1));
@@ -629,7 +676,12 @@ void __init prom_init(void)
 
 	register_smp_ops(&nlm_smp_ops);
 
-	wakeup_secondary_cpus();
+	if (!is_kexec_boot())
+		wakeup_secondary_cpus();
+
+#ifdef CONFIG_KEXEC
+	nlm_kexec_init();
+#endif
 }
 
 void prom_free_prom_memory(void)
diff --git a/drivers/net/nae/xlp_nae.c b/drivers/net/nae/xlp_nae.c
index a52947d..d002ed0 100644
--- a/drivers/net/nae/xlp_nae.c
+++ b/drivers/net/nae/xlp_nae.c
@@ -54,6 +54,7 @@
 #include <asm/netlogic/hal/nlm_hal_pic.h>
 
 #include <asm/netlogic/hal/nlm_hal_macros.h>
+#include <asm/mach-netlogic/nlm_kexec.h>
 
 #include <asm/netlogic/mips-exts.h>
 
@@ -1107,6 +1108,11 @@ static struct pci_driver soc_driver = {
 
 static int __init nlm_xlp_mac_init(void)
 {
+	if (is_kexec_boot()) {
+		pr_err("%s: NAE driver doesn't work when booting from kexec\n", __func__);
+		return -ENODEV;
+	}
+
 	nlm_xlp_nae_init();
 
 	return pci_register_driver(&soc_driver);
-- 
1.7.0.2

