From ce6e180c8e22e7015efc8196e60e22ddc4c17f04 Mon Sep 17 00:00:00 2001
From: Wu Zhangjin <zhangjin.wu@windriver.com>
Date: Fri, 6 May 2011 17:02:03 +0800
Subject: [PATCH 27/37] nlm_xlp_64_be: Fix prefetch problem

Avoid pref walking beyond end of memory to fix the potential bus error.

Signed-off-by: Wu Zhangjin <zhangjin.wu@windriver.com>
---
 arch/mips/kernel/setup.c           |   20 ++++++++++++++++++++
 arch/mips/netlogic/common/memory.c |   17 +++++++++++++++++
 2 files changed, 37 insertions(+), 0 deletions(-)

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 9ddb844..e2f87c3 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -75,11 +75,31 @@ EXPORT_SYMBOL(mips_io_port_base);
 static struct resource code_resource = { .name = "Kernel code", };
 static struct resource data_resource = { .name = "Kernel data", };
 
+#ifdef CONFIG_CPU_HAS_PREFETCH
+/*
+ * Override it in your own MIPS variant to fix the potential prefetch
+ * problem, if no such problem, don't touch it.
+ */
+phys_t __weak fix_prefetch_mem(phys_t size)
+{
+	return size;
+}
+#endif
+
 void __init add_memory_region(phys_t start, phys_t size, long type)
 {
 	int x = boot_mem_map.nr_map;
 	struct boot_mem_map_entry *prev = boot_mem_map.map + x - 1;
 
+#ifdef CONFIG_CPU_HAS_PREFETCH
+	/*
+	 * Allow MIPS variants to reserve some mem to fix the potential
+	 * prefetch problem, especially when the memory range can only
+	 * be passed by the "mem" kernel arguments.
+	 */
+	size = fix_prefetch_mem(size);
+#endif
+
 	/* Sanity check */
 	if (start + size < start) {
 		pr_warning("Trying to add an invalid memory region, skipped\n");
diff --git a/arch/mips/netlogic/common/memory.c b/arch/mips/netlogic/common/memory.c
index f3d1b53..c69cf03 100644
--- a/arch/mips/netlogic/common/memory.c
+++ b/arch/mips/netlogic/common/memory.c
@@ -80,6 +80,23 @@ static uint32_t tlb_mask(uint32_t size)
 	((((paddr & 0xffffffffffULL) >> 12) << 6) | (attr))
 
 
+#ifdef CONFIG_CPU_HAS_PREFETCH
+
+#define PREF_BACKUP_MEM	512
+
+phys_t fix_prefetch_mem(phys_t size)
+{
+	/*
+	 * memcpy/__copy_user prefetch, which
+	 * will cause a bus error for
+	 * KSEG/KUSEG addrs not backed by RAM.
+	 * Hence, reserve some padding for the
+	 * prefetch distance.
+	 */
+	return size - ((size > PREF_BACKUP_MEM) ? PREF_BACKUP_MEM : 0);
+}
+#endif
+
 /*
  * External Function / APIs
  */
-- 
1.7.0.2

