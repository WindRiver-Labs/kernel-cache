From 5cff5dcfeba68ffe9fe07b2f653975362a4333ad Mon Sep 17 00:00:00 2001
From: Wu Zhangjin <zhangjin.wu@windriver.com>
Date: Thu, 28 Apr 2011 16:36:54 +0800
Subject: [PATCH 25/37] nlm_xlp_64_be: add cpu hotplug support

It mainly implements or enhances the necessary interfaces proposed in
Documentation/cpu-hotplug.txt, such interfaces include:

cpu offline:

    o cpu_disable

	Called by _cpu_down() to clear cpu_online_map & cpu_callin_map,
	disable all interrupts, and flush cache & tlb.

    o cpu_die

	Called by _cpu_down() to Wait for cpu die(ready to be 0)

    o play_dead

	Called by cpu_idle() to make cpu die(set ready to 0): Enter into
	a loop till it is waked up by user-space /sys interface
	(till ready is set to 1).

cpu online:

    o boot_secondary

	Called by __cpu_up to re-activate the cpu and make it exit from the
	loop of play_dead() and re-init the cpu via calling the following
	functions orderly: ptr_smp_boot -> smp_bootstrap -> start_secondary
	-> init_secondary -> smp_finish. The interrupts will be re-enabled
	in init_secondary and smp_finish.

The top-level functions for offline and online is cpu_down() and
cpu_up() respectively, they are called in drivers/base/cpu.c when 0 or 1
is written to the /sys interface: /sys/devices/system/cpu/cpuX/online

Signed-off-by: Wu Zhangjin <zhangjin.wu@windriver.com>
---
 arch/mips/Kconfig            |    1 +
 arch/mips/netlogic/xlp/irq.c |   26 +++++++++++
 arch/mips/netlogic/xlp/smp.c |  100 ++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 127 insertions(+), 0 deletions(-)

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 6ea9439..55d23b1 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -674,6 +674,7 @@ config NLM_XLP_SIM
 	select SYS_SUPPORTS_BIG_ENDIAN
 	select SYS_SUPPORTS_LITTLE_ENDIAN
 	select SYS_SUPPORTS_HIGHMEM
+	select SYS_SUPPORTS_HOTPLUG_CPU
 	select DMA_COHERENT
 	select CEVT_R4K
 	select CSRC_R4K
diff --git a/arch/mips/netlogic/xlp/irq.c b/arch/mips/netlogic/xlp/irq.c
index 42b2295..c24ee52 100644
--- a/arch/mips/netlogic/xlp/irq.c
+++ b/arch/mips/netlogic/xlp/irq.c
@@ -413,3 +413,29 @@ asmlinkage void plat_irq_dispatch(void)
 
 	do_IRQ(irq);
 }
+
+#ifdef CONFIG_HOTPLUG_CPU
+
+extern void on_chip_shutoff_msgring(void);
+extern void nlm_disable_vc_intr(void);
+extern void cpu_hotplug_fixup_poe(int cpu, int flag);
+
+void fixup_irqs(unsigned int cpu, int flag)
+{
+	/* Fix the POE configuration */
+#ifdef CONFIG_XLP_NAE
+	cpu_hotplug_fixup_poe(cpu, flag);
+#endif
+
+	if (!flag) {
+		pr_debug("%s: turn off msgring\n", __func__);
+		on_chip_shutoff_msgring();
+		pr_debug("%s: disable vc interrupt\n", __func__);
+		nlm_disable_vc_intr();
+		/* clear all pending interrupts */
+		write_64bit_cp0_eirr(0xffffffffffffffff);
+		/* Mask out all interrupts */
+		write_64bit_cp0_eimr(0);
+	}
+}
+#endif
diff --git a/arch/mips/netlogic/xlp/smp.c b/arch/mips/netlogic/xlp/smp.c
index 2092a6e..0576a61 100644
--- a/arch/mips/netlogic/xlp/smp.c
+++ b/arch/mips/netlogic/xlp/smp.c
@@ -119,8 +119,53 @@ static void __cpuinit nlm_init_secondary(void)
     nlm_enable_vc_intr();
 }
 
+#ifdef CONFIG_HOTPLUG_CPU
+extern void fixup_irqs(unsigned int cpu, int flag);
+static DEFINE_SPINLOCK(smp_reserve_lock);
+static atomic_t __cpuinitdata cpu_hotplug_flag = ATOMIC_INIT(0);
+
+static int __cpuinit nlm_cpu_callback(struct notifier_block *nfb,
+	unsigned long action, void *hcpu)
+{
+	unsigned int cpu = (unsigned long)hcpu;
+
+	switch (action) {
+	case CPU_ONLINE:
+		pr_info("Cpu %d online\n", cpu);
+		break;
+	case CPU_DEAD:
+		pr_info("Cpu %d offline\n", cpu);
+		break;
+	}
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block __cpuinitdata nlm_cpu_notifier = {
+	.notifier_call = nlm_cpu_callback,
+};
+
+static int __cpuinit register_nlm_notifier(void)
+{
+	register_hotcpu_notifier(&nlm_cpu_notifier);
+
+	return 0;
+}
+
+late_initcall(register_nlm_notifier);
+
+#endif	/* CONFIG_HOTPLUG_CPU */
+
 void nlm_smp_finish(void)
 {
+#ifdef CONFIG_HOTPLUG_CPU
+	if (atomic_read(&cpu_hotplug_flag)) {
+		spin_lock(&smp_reserve_lock);
+		/* Enable IRQs on the cpu */
+		fixup_irqs(smp_processor_id(), 1);
+		spin_unlock(&smp_reserve_lock);
+	}
+#endif
 }
 
 void nlm_cpus_done(void)
@@ -244,6 +289,57 @@ void nlm_prepare_cpus(unsigned int max_cpus)
 {
 }
 
+#ifdef CONFIG_HOTPLUG_CPU
+
+static int nlm_cpu_disable(void)
+{
+	unsigned int cpu = smp_processor_id();
+	atomic_set(&cpu_hotplug_flag, 1);
+
+	if (cpu == 0)
+		return -EBUSY;
+
+	spin_lock(&smp_reserve_lock);
+
+	cpu_clear(cpu, cpu_online_map);
+	cpu_clear(cpu, cpu_callin_map);
+
+	local_irq_disable();
+	fixup_irqs(cpu, 0);
+
+	flush_cache_all();
+	local_flush_tlb_all();
+
+	spin_unlock(&smp_reserve_lock);
+
+	return 0;
+}
+
+static void nlm_cpu_die(unsigned int logical_cpu)
+{
+	int cpu = cpu_logical_map(logical_cpu);
+
+	while (smp_boot.boot_info[cpu].ready)
+		cpu_relax();
+}
+
+void play_dead(void)
+{
+	unsigned int cpu = smp_processor_id();
+	struct smp_boot_info_percpu *bic;
+
+	bic = smp_boot.boot_info + cpu;
+	idle_task_exit();
+	bic->ready = 0;
+
+	local_irq_disable();
+	while (!bic->ready)
+		cpu_relax();
+
+	ptr_smp_boot(bic->fn, bic->sp, bic->gp);
+}
+#endif /* CONFIG_HOTPLUG_CPU */
+
 struct plat_smp_ops nlm_smp_ops = {
     .send_ipi_single    = nlm_send_ipi_single,
     .send_ipi_mask      = nlm_send_ipi_mask,
@@ -253,6 +349,10 @@ struct plat_smp_ops nlm_smp_ops = {
     .boot_secondary     = nlm_boot_secondary,
     .smp_setup      	= nlm_smp_setup,
     .prepare_cpus       = nlm_prepare_cpus,
+#ifdef CONFIG_HOTPLUG_CPU
+    .cpu_disable        = nlm_cpu_disable,
+    .cpu_die            = nlm_cpu_die,
+#endif
 };
 
 void prom_boot_cpus_secondary(void *args)
-- 
1.7.0.2

