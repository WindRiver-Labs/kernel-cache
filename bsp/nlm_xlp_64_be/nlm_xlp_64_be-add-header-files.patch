From 309944eec10948cf3ff91021e1cee05a18744dcb Mon Sep 17 00:00:00 2001
From: Wu Zhangjin <zhangjin.wu@windriver.com>
Date: Thu, 7 Apr 2011 14:52:35 +0800
Subject: [PATCH 17/37] nlm_xlp_64_be: add header files

[ Based on netlogic SDK 20110329 ]

Add the common header files for XLP.

Signed-off-by: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Signed-off-by: Mehul <vmehul@netlogicmicro.com>
Signed-off-by: Nebu Philips <nphilips@netlogicmicro.com>
Signed-off-by: henry shao <hshao@netlogicmicro.com>
Signed-off-by: Zi Shen Lim <zlim@netlogicmicro.com>
[ Clean up a lot and remove lots of insane files ]
Integrated-by: Wu Zhangjin <zhangjin.wu@windriver.com>
---
 .../asm/mach-netlogic/cpu-feature-overrides.h      |   19 +
 .../mips/include/asm/mach-netlogic/dma-coherence.h |   70 ++
 arch/mips/include/asm/mach-netlogic/ioremap.h      |   41 +
 arch/mips/include/asm/mach-netlogic/mmu.h          |   69 ++
 arch/mips/include/asm/mach-netlogic/pgtable-xlp.h  |   59 ++
 arch/mips/include/asm/mach-netlogic/pgwalker.h     |   35 +
 arch/mips/include/asm/mach-netlogic/spaces.h       |    6 +
 arch/mips/include/asm/mach-netlogic/war.h          |   25 +
 arch/mips/include/asm/mach-netlogic/xlp-mmu.h      |   60 ++
 arch/mips/include/asm/netlogic/bootinfo.h          |   37 +
 arch/mips/include/asm/netlogic/cpumask.h           |   56 ++
 arch/mips/include/asm/netlogic/debug.h             |  112 +++
 arch/mips/include/asm/netlogic/hal/fdt_helper.h    |   86 ++
 arch/mips/include/asm/netlogic/hal/nlm_hal.h       |   62 ++
 arch/mips/include/asm/netlogic/hal/nlm_hal_fmn.h   |  542 +++++++++++
 .../mips/include/asm/netlogic/hal/nlm_hal_macros.h |  868 +++++++++++++++++
 arch/mips/include/asm/netlogic/hal/nlm_hal_nae.h   |  150 +++
 arch/mips/include/asm/netlogic/hal/nlm_hal_pic.h   |  379 ++++++++
 arch/mips/include/asm/netlogic/hal/nlm_hal_sae.h   |  133 +++
 .../include/asm/netlogic/hal/nlm_hal_xlp_dev.h     |  966 ++++++++++++++++++
 arch/mips/include/asm/netlogic/interrupt.h         |   48 +
 arch/mips/include/asm/netlogic/io.h                |   48 +
 arch/mips/include/asm/netlogic/iomap.h             |  297 ++++++
 arch/mips/include/asm/netlogic/memory-exclusion.h  |   38 +
 arch/mips/include/asm/netlogic/mips-exts.h         |  324 +++++++
 arch/mips/include/asm/netlogic/nlm_fs.h            |   59 ++
 arch/mips/include/asm/netlogic/nlm_rw_lock.h       |  216 ++++
 arch/mips/include/asm/netlogic/pci.h               |   33 +
 arch/mips/include/asm/netlogic/perf_ctr.h          |   67 ++
 arch/mips/include/asm/netlogic/pic.h               |   48 +
 arch/mips/include/asm/netlogic/proc.h              |   46 +
 arch/mips/include/asm/netlogic/xlp.h               |   97 ++
 arch/mips/include/asm/netlogic/xlp_mac.h           | 1023 ++++++++++++++++++++
 arch/mips/include/asm/netlogic/xlp_usb.h           |   42 +
 34 files changed, 6161 insertions(+), 0 deletions(-)
 create mode 100644 arch/mips/include/asm/mach-netlogic/cpu-feature-overrides.h
 create mode 100644 arch/mips/include/asm/mach-netlogic/dma-coherence.h
 create mode 100644 arch/mips/include/asm/mach-netlogic/ioremap.h
 create mode 100644 arch/mips/include/asm/mach-netlogic/mmu.h
 create mode 100644 arch/mips/include/asm/mach-netlogic/pgtable-xlp.h
 create mode 100644 arch/mips/include/asm/mach-netlogic/pgwalker.h
 create mode 100644 arch/mips/include/asm/mach-netlogic/spaces.h
 create mode 100644 arch/mips/include/asm/mach-netlogic/war.h
 create mode 100644 arch/mips/include/asm/mach-netlogic/xlp-mmu.h
 create mode 100644 arch/mips/include/asm/netlogic/bootinfo.h
 create mode 100644 arch/mips/include/asm/netlogic/cpumask.h
 create mode 100644 arch/mips/include/asm/netlogic/debug.h
 create mode 100644 arch/mips/include/asm/netlogic/hal/fdt_helper.h
 create mode 100644 arch/mips/include/asm/netlogic/hal/nlm_hal.h
 create mode 100644 arch/mips/include/asm/netlogic/hal/nlm_hal_fmn.h
 create mode 100644 arch/mips/include/asm/netlogic/hal/nlm_hal_macros.h
 create mode 100644 arch/mips/include/asm/netlogic/hal/nlm_hal_nae.h
 create mode 100644 arch/mips/include/asm/netlogic/hal/nlm_hal_pic.h
 create mode 100644 arch/mips/include/asm/netlogic/hal/nlm_hal_sae.h
 create mode 100644 arch/mips/include/asm/netlogic/hal/nlm_hal_xlp_dev.h
 create mode 100644 arch/mips/include/asm/netlogic/interrupt.h
 create mode 100644 arch/mips/include/asm/netlogic/io.h
 create mode 100644 arch/mips/include/asm/netlogic/iomap.h
 create mode 100644 arch/mips/include/asm/netlogic/memory-exclusion.h
 create mode 100644 arch/mips/include/asm/netlogic/mips-exts.h
 create mode 100644 arch/mips/include/asm/netlogic/nlm_fs.h
 create mode 100644 arch/mips/include/asm/netlogic/nlm_rw_lock.h
 create mode 100644 arch/mips/include/asm/netlogic/pci.h
 create mode 100644 arch/mips/include/asm/netlogic/perf_ctr.h
 create mode 100644 arch/mips/include/asm/netlogic/pic.h
 create mode 100644 arch/mips/include/asm/netlogic/proc.h
 create mode 100644 arch/mips/include/asm/netlogic/xlp.h
 create mode 100644 arch/mips/include/asm/netlogic/xlp_mac.h
 create mode 100644 arch/mips/include/asm/netlogic/xlp_usb.h

diff --git a/arch/mips/include/asm/mach-netlogic/cpu-feature-overrides.h b/arch/mips/include/asm/mach-netlogic/cpu-feature-overrides.h
new file mode 100644
index 0000000..51ee4bc
--- /dev/null
+++ b/arch/mips/include/asm/mach-netlogic/cpu-feature-overrides.h
@@ -0,0 +1,19 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+
+#ifndef __ASM_MACH_NLM_CPU_FEATURE_OVERRIDES_H
+#define __ASM_MACH_NLM_CPU_FEATURE_OVERRIDES_H
+
+/*
+ * The current_cpu_type() defined in
+ * arch/mips/include/asm/cpu-features.h called smp_processor_id(), which
+ * may introduce warning about calling smp_processor_id() in preemptible
+ * context, we don't care this for we have this unique cpu type in XLP,
+ * so, define it as CPU_XLP directly will avoid this warning.
+ */
+#define current_cpu_type() CPU_XLP
+
+#endif /* __ASM_MACH_NLM_CPU_FEATURE_OVERRIDES_H */
diff --git a/arch/mips/include/asm/mach-netlogic/dma-coherence.h b/arch/mips/include/asm/mach-netlogic/dma-coherence.h
new file mode 100644
index 0000000..288ce40
--- /dev/null
+++ b/arch/mips/include/asm/mach-netlogic/dma-coherence.h
@@ -0,0 +1,70 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2006  Ralf Baechle <ralf@linux-mips.org>
+ *
+ */
+#ifndef __ASM_MACH_NLM_DMA_COHERENCE_H
+#define __ASM_MACH_NLM_DMA_COHERENCE_H
+
+struct device;
+
+static inline dma_addr_t plat_map_dma_mem(struct device *dev, void *addr,
+	size_t size)
+{
+	return virt_to_phys(addr);
+}
+
+static inline dma_addr_t plat_map_dma_mem_page(struct device *dev,
+	struct page *page)
+{
+	return page_to_phys(page);
+}
+
+static inline unsigned long plat_dma_addr_to_phys(struct device *dev,
+		dma_addr_t dma_addr)
+{
+	return dma_addr;
+}
+
+static inline void plat_unmap_dma_mem(struct device *dev, dma_addr_t dma_addr,
+	size_t size, enum dma_data_direction direction)
+{
+}
+
+static inline int plat_device_is_coherent(struct device *dev)
+{
+#ifdef CONFIG_DMA_COHERENT
+	return 1;
+#else /* CONFIG_DMA_NONCOHERENT */
+	return 0;
+#endif
+}
+
+static inline int plat_dma_supported(struct device *dev, u64 mask)
+{
+	/*
+	 * we fall back to GFP_DMA when the mask isn't all 1s,
+	 * so we can't guarantee allocations that must be
+	 * within a tighter range than GFP_DMA..
+	 */
+	if (mask < DMA_BIT_MASK(24))
+		return 0;
+
+	return 1;
+}
+
+static inline void plat_extra_sync_for_device(struct device *dev)
+{
+	return;
+}
+
+static inline int plat_dma_mapping_error(struct device *dev,
+					 dma_addr_t dma_addr)
+{
+	return 0;
+}
+
+#endif /* __ASM_MACH_GENERIC_DMA_COHERENCE_H */
diff --git a/arch/mips/include/asm/mach-netlogic/ioremap.h b/arch/mips/include/asm/mach-netlogic/ioremap.h
new file mode 100644
index 0000000..d98eb20
--- /dev/null
+++ b/arch/mips/include/asm/mach-netlogic/ioremap.h
@@ -0,0 +1,41 @@
+/*
+ *	include/asm-mips/mach-generic/ioremap.h
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+#ifndef __ASM_MACH_GENERIC_IOREMAP_H
+#define __ASM_MACH_GENERIC_IOREMAP_H
+
+#include <linux/types.h>
+
+#define ARCH_HAS_VALID_PHYS_ADDR_RANGE
+
+#define NETLOGIC_UNCACHED_START 0x10000000UL
+#define NETLOGIC_UNCACHED_END 0x20000000UL
+
+extern inline int valid_phys_addr_range(unsigned long addr, size_t count);
+extern inline int valid_mmap_phys_addr_range(unsigned long pfn, size_t size);
+/*
+ * Allow physical addresses to be fixed up to help peripherals located
+ * outside the low 32-bit range -- generic pass-through version.
+ */
+static inline phys_t fixup_bigphys_addr(phys_t phys_addr, phys_t size)
+{
+	return phys_addr;
+}
+
+static inline void __iomem *plat_ioremap(phys_t offset, unsigned long size,
+	unsigned long flags)
+{
+	return NULL;
+}
+
+static inline int plat_iounmap(const volatile void __iomem *addr)
+{
+	return 0;
+}
+
+#endif /* __ASM_MACH_GENERIC_IOREMAP_H */
diff --git a/arch/mips/include/asm/mach-netlogic/mmu.h b/arch/mips/include/asm/mach-netlogic/mmu.h
new file mode 100644
index 0000000..3478715
--- /dev/null
+++ b/arch/mips/include/asm/mach-netlogic/mmu.h
@@ -0,0 +1,69 @@
+#ifndef _ASM_MACH_NLM_MMU_H
+#define _ASM_MACH_NLM_MMU_H
+
+#include <linux/smp.h>
+#include <asm/netlogic/mips-exts.h>
+#include <asm/page.h>
+#include <asm/pgtable-bits.h>
+
+#ifdef CONFIG_NLM_XLP
+#include <asm/mach-netlogic/xlp-mmu.h>
+#endif
+
+#define ENTRYLO_PFN_SHIFT _PAGE_GLOBAL_SHIFT
+
+#ifndef __ASSEMBLY__
+
+#define SMALLEST_TLBPAGE_SZ (4UL << 10)
+#define LARGEST_TLBPAGE_SZ  (256UL << 20)
+
+#define TRUE 1
+#define FALSE 0
+
+typedef struct
+{
+	unsigned long vaddr;
+	uint64_t paddr0;
+	uint64_t paddr1;
+	uint32_t pagesize;
+	uint32_t attr0;
+	uint32_t attr1;
+	int wired;
+} tlb_info_t;
+
+#ifdef CONFIG_MAPPED_KERNEL
+extern unsigned long __vmalloc_start;
+#endif
+extern unsigned long long nlm_common_tlb_stats[];
+
+extern void mmu_init(void);
+extern void setup_tlb(tlb_info_t *tlb);
+
+/*
+ * the following needs an used argument to confirm to the 
+ * prototype of functions passed to on_each_cpu()
+ */
+static inline void nlm_update_tlb_stats(void *arg)
+{
+	nlm_common_tlb_stats[smp_processor_id()] = nlm_read_os_scratch_2();
+}
+
+#define tlbstats_init() nlm_write_os_scratch_2(0ULL)
+
+#ifdef CONFIG_HUGETLBFS
+#define entrylo0_mask_init() \
+nlm_write_os_scratch_3(~(((1ULL << HUGETLB_PAGE_ORDER) - 1) << ENTRYLO_PFN_SHIFT))
+#else
+#define entrylo0_mask_init()
+#endif
+
+extern void setup_mapped_kernel_tlbs(int index, int secondary_cpu);
+extern unsigned long recalculate_max_low_pfn(unsigned long max_low_pfn);
+
+#ifndef CONFIG_NLM_XLP
+#define disable_pgwalker(flags) (void)flags
+#define enable_pgwalker(flags) (void) flags
+#endif
+
+#endif /* __ASSEMBLY__ */
+#endif
diff --git a/arch/mips/include/asm/mach-netlogic/pgtable-xlp.h b/arch/mips/include/asm/mach-netlogic/pgtable-xlp.h
new file mode 100644
index 0000000..4ab8fec
--- /dev/null
+++ b/arch/mips/include/asm/mach-netlogic/pgtable-xlp.h
@@ -0,0 +1,59 @@
+#ifndef _ASM_MACH_NLM_PGTABLE_BITS_XLP_H
+#define _ASM_MACH_NLM_PGTABLE_BITS_XLP_H
+
+#define PAGE_NONE        __pgprot(_PAGE_PRESENT | \
+                                  _PAGE_RI | _PAGE_XI | \
+                                  _CACHE_CACHABLE_NONCOHERENT)
+#define PAGE_READONLY    __pgprot(_PAGE_PRESENT | _PAGE_READ | \
+                                  _PAGE_XI | \
+                                   PAGE_CACHABLE_DEFAULT)
+#define PAGE_WRITEONLY   __pgprot(_PAGE_PRESENT | _PAGE_READ | _PAGE_WRITE | \
+                                  _PAGE_RI | _PAGE_XI | \
+                                  PAGE_CACHABLE_DEFAULT)
+#define PAGE_WRITE_READ  __pgprot(_PAGE_PRESENT | _PAGE_READ | _PAGE_WRITE | \
+                                  _PAGE_XI | \
+                                  PAGE_CACHABLE_DEFAULT)
+#define PAGE_EXECONLY    __pgprot(_PAGE_PRESENT | _PAGE_READ | \
+                                  _PAGE_RI | \
+                                  PAGE_CACHABLE_DEFAULT)
+#define PAGE_EXEC_READ   __pgprot(_PAGE_PRESENT | _PAGE_READ | \
+                                  PAGE_CACHABLE_DEFAULT)
+#define PAGE_EXEC_WRITE  __pgprot(_PAGE_PRESENT | _PAGE_READ | _PAGE_WRITE | \
+                                  _PAGE_RI | \
+                                  PAGE_CACHABLE_DEFAULT)
+#define PAGE_ALL         __pgprot(_PAGE_PRESENT | _PAGE_READ | _PAGE_WRITE | \
+                                  PAGE_CACHABLE_DEFAULT)
+#define PAGE_COPY        __pgprot(_PAGE_PRESENT | _PAGE_READ | \
+                                  _PAGE_RI | _PAGE_XI | \
+                                   PAGE_CACHABLE_DEFAULT)
+
+#define PAGE_COPY_READ      PAGE_READONLY
+#define PAGE_EXEC_COPY      PAGE_EXECONLY
+#define PAGE_EXEC_COPY_READ PAGE_EXEC_READ
+
+/*
+ * FIXME: What do we do with kernel pages ? These are primarily 
+ *        used for modules.
+ */
+#define PAGE_KERNEL	__pgprot(_PAGE_PRESENT | __READABLE | __WRITEABLE | \
+			_PAGE_GLOBAL | PAGE_CACHABLE_DEFAULT)
+
+#define __P000	PAGE_NONE
+#define __P001	PAGE_READONLY
+#define __P010	PAGE_COPY
+#define __P011	PAGE_COPY_READ
+#define __P100	PAGE_EXECONLY
+#define __P101	PAGE_EXEC_READ
+#define __P110	PAGE_EXEC_COPY
+#define __P111	PAGE_EXEC_COPY_READ
+
+#define __S000	PAGE_NONE
+#define __S001	PAGE_READONLY
+#define __S010	PAGE_WRITEONLY
+#define __S011	PAGE_WRITE_READ
+#define __S100	PAGE_EXECONLY
+#define __S101	PAGE_EXEC_READ
+#define __S110	PAGE_EXEC_WRITE
+#define __S111	PAGE_ALL
+
+#endif
diff --git a/arch/mips/include/asm/mach-netlogic/pgwalker.h b/arch/mips/include/asm/mach-netlogic/pgwalker.h
new file mode 100644
index 0000000..855f900
--- /dev/null
+++ b/arch/mips/include/asm/mach-netlogic/pgwalker.h
@@ -0,0 +1,35 @@
+#ifndef _ASM_MACH_NLM_PGWALKER_H
+#define _ASM_MACH_NLM_PGWALKER_H
+
+#include <linux/percpu.h>
+
+#define PGW_REGS_BLOCK 4
+
+enum {
+	PGW_MMU_INFO = 0x10,
+	PGW_PGD_BASES,
+	PGW_PGD_SHIFT,
+	PGW_PGD_MASK,
+	PGW_PUD_SHIFT,
+	PGW_PUD_MASK,
+	PGW_PMD_SHIFT,
+	PGW_PMD_MASK,
+	PGW_PTE_SHIFT,
+	PGW_PTE_MASK
+};
+
+#define PGD 0x8
+#define PUD 0x4
+#define PMD 0x2
+#define PTE 0x1
+
+#define pgw_register_write_w(reg, value) write_32bit_nlm_ctrl_reg(PGW_REGS_BLOCK, reg, value)
+#define pgw_register_write_d(reg, value) write_64bit_nlm_ctrl_reg(PGW_REGS_BLOCK, reg, value)
+#define pgw_register_read_w(reg) read_32bit_nlm_ctrl_reg(PGW_REGS_BLOCK, reg)
+#define pgw_register_read_d(reg) read_64bit_nlm_ctrl_reg(PGW_REGS_BLOCK, reg)
+
+#define pgw_print_w(reg) printk(KERN_INFO #reg " = 0x%x\n", pgw_register_read_w(reg))
+
+extern void dump_pgwalker_config(void);
+
+#endif
diff --git a/arch/mips/include/asm/mach-netlogic/spaces.h b/arch/mips/include/asm/mach-netlogic/spaces.h
new file mode 100644
index 0000000..049d346
--- /dev/null
+++ b/arch/mips/include/asm/mach-netlogic/spaces.h
@@ -0,0 +1,6 @@
+#ifndef __NLM_SPACES_H__
+#define __NLM_SPACES_H__
+
+#include <asm/mach-generic/spaces.h>
+
+#endif
diff --git a/arch/mips/include/asm/mach-netlogic/war.h b/arch/mips/include/asm/mach-netlogic/war.h
new file mode 100644
index 0000000..02d2db3
--- /dev/null
+++ b/arch/mips/include/asm/mach-netlogic/war.h
@@ -0,0 +1,25 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2002, 2004, 2007 by Ralf Baechle <ralf@linux-mips.org>
+ */
+#ifndef __ASM_MIPS_MACH_NLM_WAR_H
+#define __ASM_MIPS_MACH_NLM_WAR_H
+
+#define R4600_V1_INDEX_ICACHEOP_WAR	0
+#define R4600_V1_HIT_CACHEOP_WAR	0
+#define R4600_V2_HIT_CACHEOP_WAR	0
+#define R5432_CP0_INTERRUPT_WAR		0
+#define BCM1250_M3_WAR			0
+#define SIBYTE_1956_WAR			0
+#define MIPS4K_ICACHE_REFILL_WAR	0
+#define MIPS_CACHE_SYNC_WAR		0
+#define TX49XX_ICACHE_INDEX_INV_WAR	0
+#define RM9000_CDEX_SMP_WAR		0
+#define ICACHE_REFILLS_WORKAROUND_WAR	0
+#define R10000_LLSC_WAR			0
+#define MIPS34K_MISSED_ITLB_WAR		0
+
+#endif /* __ASM_MIPS_MACH_NLM_WAR_H */
diff --git a/arch/mips/include/asm/mach-netlogic/xlp-mmu.h b/arch/mips/include/asm/mach-netlogic/xlp-mmu.h
new file mode 100644
index 0000000..28ca984
--- /dev/null
+++ b/arch/mips/include/asm/mach-netlogic/xlp-mmu.h
@@ -0,0 +1,60 @@
+#ifndef _ASM_MACH_NLM_XLP_MMU_H
+#define _ASM_MACH_NLM_XLP_MMU_H
+
+#include <linux/percpu.h>
+#include <asm/mipsregs.h>
+
+/* 
+ * These numbers correspond to Cop0 Config6 reg 
+ * bit positions 
+ */
+#define ENABLE_ETLB        0x4
+#define ENABLE_128_TLB     0x20
+#define ENABLE_PGWALKER    0x8
+
+#define USER_SEG 0
+
+#ifdef CONFIG_64BIT
+#define NR_ADDR_SEGMENTS 8  /* MUST be a power of 2 */
+#define MODULE_SEG 7
+#define VMALLOC_SEG 6
+#else /* CONFIG_32BIT */
+#define NR_ADDR_SEGMENTS 2 /* MUST be a power of 2 */
+#define VMALLOC_SEG 1
+#endif /* CONFIG_64BIT */
+
+extern DEFINE_PER_CPU(unsigned long [NR_ADDR_SEGMENTS], pgd_bases);
+
+static inline void setup_user_pgd(pgd_t *pgd)
+{
+	if (read_c0_config6() & ENABLE_PGWALKER) {
+		get_cpu_var(pgd_bases)[USER_SEG] = (unsigned long) pgd;
+		put_cpu_var(pgd_bases);
+	}
+};
+
+static __inline__ void pipeline_flush(void)
+{
+	__asm__ __volatile__ (
+		".set push         \n"
+		".set arch=xlp     \n"
+		"dla      $8, 1f    \n"
+		"jr.hb   $8        \n"
+		"nop               \n"
+		"1: nop            \n"
+		".set pop          \n"
+		:
+		:
+		: "$8"
+		);
+}
+
+#define disable_pgwalker(flags)						\
+	({ flags = read_c0_config6();					\
+		pipeline_flush(); write_c0_config6(read_c0_config6() & ~ENABLE_PGWALKER); pipeline_flush();})
+
+#define enable_pgwalker(flags)						\
+	({ write_c0_config6(read_c0_config6() | (flags & ENABLE_PGWALKER)); })
+
+
+#endif
diff --git a/arch/mips/include/asm/netlogic/bootinfo.h b/arch/mips/include/asm/netlogic/bootinfo.h
new file mode 100644
index 0000000..d504cc4
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/bootinfo.h
@@ -0,0 +1,37 @@
+#ifndef _ASM_NETLOGIC_BOOTINFO_H
+#define _ASM_NETLOGIC_BOOTINFO_H
+
+#define LOADER_UBOOT   1
+#define LOADER_OTHER   2
+
+/* This is what netlboot passes and linux boot_mem_map is subtly different */
+struct nlm_boot_mem_map {
+	int nr_map;
+	struct nlm_boot_mem_map_entry {
+		uint64_t addr;  /* start of memory segment */
+		uint64_t size;  /* size of memory segment */
+		uint32_t type;          /* type of memory segment */
+	} map[BOOT_MEM_MAP_MAX];
+};
+
+#define MAX_EXCLUDE 16
+struct boot_mem_map_exclude_region {
+	uint64_t start;
+	uint64_t end;
+};
+extern void copy_mem_map(struct boot_mem_map *, struct nlm_boot_mem_map *);
+
+
+#ifdef CONFIG_NLM_XLP
+extern struct psb_info *prom_info;
+extern struct psb_info prom_info_copy;
+extern struct boot_mem_map boot_physaddr_info;
+
+extern int read_prominfo(void);
+extern int read_dram_info(void);
+extern int read_physaddr_map(void);
+
+extern int wakeup_secondary_cpus(void);
+#endif
+
+#endif
diff --git a/arch/mips/include/asm/netlogic/cpumask.h b/arch/mips/include/asm/netlogic/cpumask.h
new file mode 100644
index 0000000..b72ae27
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/cpumask.h
@@ -0,0 +1,56 @@
+#ifndef _ASM_NETLOGIC_CPUMASK_H
+#define _ASM_NETLOGIC_CPUMASK_H
+
+#include <linux/cpumask.h>
+#include <linux/sched.h>
+
+#define CPUMASK_BUF 256
+
+static __inline__ unsigned int cpumask_to_uint32(cpumask_t *cpumask)
+{
+	unsigned int mask = 0;
+	int i;
+
+	for (i = 0; i < 32; i++) {
+		if (cpumask_test_cpu(i, cpumask)) {
+			mask |= (1 << i);
+		}
+	}
+	return mask;
+}
+
+static __inline__ void uint32_to_cpumask(cpumask_t *cpumask, unsigned int mask)
+{
+	int i;
+
+	for (i = 0; i < 32; i++) {
+		if (mask & (1 << i)) {
+			cpumask_set_cpu(i, cpumask);
+		}
+		else {
+			cpumask_clear_cpu(i, cpumask);
+		}
+	}
+}
+
+static __inline__ void sched_bindto_save_affinity(int cpu, struct cpumask *mask)
+{
+	struct cpumask node0cpu0mask;
+
+	/* Save the current affinity mask */
+	sched_getaffinity(0, mask);
+
+	/* Force the process to run on the specified cpu */
+	cpumask_clear(&node0cpu0mask);
+	cpumask_set_cpu(cpu, &node0cpu0mask);
+
+	sched_setaffinity(0, &node0cpu0mask);
+}
+
+static __inline__ void sched_bindto_restore_affinity(struct cpumask *mask)
+{
+	sched_setaffinity(0, mask);
+}
+
+
+#endif /* _ASM_NETLOGIC_CPUMASK_H */
diff --git a/arch/mips/include/asm/netlogic/debug.h b/arch/mips/include/asm/netlogic/debug.h
new file mode 100644
index 0000000..578dbf4
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/debug.h
@@ -0,0 +1,112 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+
+#ifndef _ASM_NLM_DEBUG_H
+#define _ASM_NLM_DEBUG_H
+
+/*Enable below macro to enable net stats. */
+//#define CONFIG_NLM_STATS
+extern void prom_printf(char *fmt, ...);
+#include <linux/threads.h>
+#include <asm/atomic.h>
+
+enum {
+  //cacheline 0
+  MSGRNG_INT,
+  MSGRNG_PIC_INT,
+  MSGRNG_MSG,
+  MSGRNG_EXIT_STATUS,
+  MSGRNG_MSG_CYCLES,
+  //cacheline 1
+  NETIF_TX = 8,
+  NETIF_RX,
+  NETIF_TX_COMPLETE,
+  NETIF_TX_COMPLETE_TX,
+  NETIF_RX_CYCLES,
+  NETIF_TX_COMPLETE_CYCLES,
+  NETIF_TX_CYCLES,
+  NETIF_TIMER_START_Q,
+  //NETIF_REG_FRIN,
+  //NETIF_INT_REG,
+  //cacheline 2
+  REPLENISH_ENTER = 16,
+  REPLENISH_ENTER_COUNT,
+  REPLENISH_CPU,
+  REPLENISH_FRIN,
+  REPLENISH_CYCLES,
+  NETIF_STACK_TX,
+  NETIF_START_Q,
+  NETIF_STOP_Q,
+  //cacheline 3
+  USER_MAC_START = 24,
+  USER_MAC_INT   = 24,
+  USER_MAC_TX_COMPLETE,
+  USER_MAC_RX,
+  USER_MAC_POLL,
+  USER_MAC_TX,
+  USER_MAC_TX_FAIL,
+  USER_MAC_TX_COUNT,
+  USER_MAC_FRIN,
+  //cacheline 4
+  USER_MAC_TX_FAIL_GMAC_CREDITS = 32,
+  USER_MAC_DO_PAGE_FAULT,
+  USER_MAC_UPDATE_TLB,
+  USER_MAC_UPDATE_TLB_PFN0,
+  USER_MAC_UPDATE_TLB_PFN1,
+  
+  NLM_MAX_COUNTERS = 40
+};
+extern atomic_t nlm_common_counters[NR_CPUS][NLM_MAX_COUNTERS];
+extern __u32 msgrng_msg_cycles;
+
+#ifdef CONFIG_NLM_STATS 
+#define xlr_inc_counter(x) atomic_inc(&nlm_common_counters[0][(x)])
+#define nlm_common_dec_counter(x) atomic_dec(&nlm_common_counters[0][(x)])
+#define xlr_set_counter(x, value) atomic_set(&nlm_common_counters[0][(x)], (value))
+#define nlm_common_get_counter(x) atomic_read(&nlm_common_counters[0][(x)])
+#else
+#define xlr_inc_counter(x) //atomic_inc(&nlm_common_counters[0][(x)])
+#define nlm_common_dec_counter(x) //atomic_dec(&nlm_common_counters[0][(x)])
+#define xlr_set_counter(x, value) //atomic_set(&nlm_common_counters[0][(x)], (value))
+#define nlm_common_get_counter(x) //atomic_read(&nlm_common_counters[0][(x)])
+#endif
+#if 0
+#define dbg_msg(fmt, args...) printk("[%s@%d|%s]: cpu_%d: " fmt, \
+                               __FILE__, __LINE__, __FUNCTION__,  smp_processor_id(), ##args)
+
+#define dbg_panic(fmt, args...) panic("[%s@%d|:%s]: cpu_%d: " fmt, \
+                               __FILE__, __LINE__, __FUNCTION__, smp_processor_id(), ##args)
+
+#define prom_dbg_msg(fmt, args...) prom_printf("[%s@%d|%s]: cpu_%d: " fmt, \
+                               __FILE__, __LINE__, __FUNCTION__,  smp_processor_id(), ##args)
+#else
+#define dbg_msg(fmt, args...)
+
+#define dbg_panic(fmt, args...) panic(fmt, ##args)
+
+#define prom_dbg_msg(fmt, args...) printk(fmt, ##args)
+#endif
+
+#endif
diff --git a/arch/mips/include/asm/netlogic/hal/fdt_helper.h b/arch/mips/include/asm/netlogic/hal/fdt_helper.h
new file mode 100644
index 0000000..f465c14
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/hal/fdt_helper.h
@@ -0,0 +1,86 @@
+/*************************************************************************
+ Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+ reserved.
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions are
+ met:
+ 1. Redistributions of source code must retain the above copyright
+    notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+    notice, this list of conditions and the following disclaimer in
+    the documentation and/or other materials provided with the
+    distribution.
+ THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE
+ LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ THE POSSIBILITY OF SUCH DAMAGE.
+*******************************#NETL_2#**********************************/
+#if !defined(__KERNEL__) && !defined(NLM_HAL_NETLBOOT)
+#include <stdint.h>
+#endif
+
+/**
+ * open_fdt - get pointer to fdt blob for given file descriptor
+ * @fd: file descriptor for dtb
+ *
+ * returns:
+ * 	pointer to fdt blob, on success
+ * 	NULL, on error
+ */
+extern void *open_fdt(int fd);
+
+
+enum prop_type {
+	PROP_STR = 0,
+	PROP_CELL
+};
+
+/**
+ * copy_fdt_prop - copies value of given path and property
+ * @fdt: pointer to fdt blob
+ * @path: path of node to find
+ * @prop: property to find
+ * @type: type of property
+ * @buf: pointer to buffer (copy destination)
+ * @len: size of buffer (copy destination)
+ *
+ * returns:
+ * 	bytes copied to buffer, on success
+ * 	-FDT_ERR_BADPATH, given path does not begin with '/' or is invalid
+ * 	-FDT_ERR_NOTFOUND, node does not exist or does not have named property
+ * 	-FDT_ERR_BADMAGIC,
+ * 	-FDT_ERR_BADVERSION,
+ * 	-FDT_ERR_BADSTATE,
+ * 	-FDT_ERR_BADSTRUCTURE,
+ * 	-FDT_ERR_TRUNCATED, standard meanings
+ */
+extern int copy_fdt_prop(void *fdt, const char *path, const char *prop,
+	enum prop_type type, void *buf, int len);
+
+static inline int copy_fprop_str(void *fdt,
+	const char *path, const char *prop, char *buf, int buflen) {
+	return copy_fdt_prop(fdt, path, prop, PROP_STR, (void *)buf, buflen);
+}
+
+static inline int copy_fprop_cell(void *fdt,
+	const char *path, const char *prop, uint32_t *cells, int numcells) {
+	int len = copy_fdt_prop(fdt, path, prop, PROP_CELL,
+	                        (void *)cells, numcells * sizeof(uint32_t));
+	return len / sizeof(uint32_t);
+}
+
+/**
+ * set_fdt_helper_print - switch for print output from helper functions
+ * @val: zero = off, non-zero = on
+ *
+ * returns:
+ * 	previous setting
+ */
+extern int set_fdt_helper_print(int val);
diff --git a/arch/mips/include/asm/netlogic/hal/nlm_hal.h b/arch/mips/include/asm/netlogic/hal/nlm_hal.h
new file mode 100644
index 0000000..ac3b00e
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/hal/nlm_hal.h
@@ -0,0 +1,62 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+
+#ifndef _NLM_HAL_H_
+#define _NLM_HAL_H_
+
+#include "nlm_hal_macros.h"
+#include "nlm_hal_xlp_dev.h"
+
+#ifndef __ASSEMBLY__
+extern void nlm_hal_init(void);
+extern unsigned long long nlm_hal_cpu_freq(void);
+extern int naecfg_hack;
+
+extern int nlm_hal_is_xlp_a0(void);
+extern int nlm_hal_is_xlp_le(void);
+extern void nlm_hal_xlp_pcie_rc_init(void);
+
+#ifndef NLM_HAL_LINUX_KERNEL
+extern void enable_cpus(unsigned long thread_bitmask, unsigned long park_func); 
+#endif /* #ifndef NLM_HAL_LINUX_KERNEL */
+
+extern uint32_t nlm_hal_read_32bit_reg(uint64_t base, int index);
+extern void nlm_hal_write_32bit_reg(uint64_t base, int index, uint32_t val);
+extern uint64_t nlm_hal_read_64bit_reg(uint64_t base, int index);
+extern void nlm_hal_write_64bit_reg(uint64_t base, int index, uint64_t val);
+
+#define nlh_read_dev_reg(dev, index) nlm_hal_read_32bit_reg(nlm_hal_get_dev_base(dev), index)
+#define nlh_write_dev_reg(dev, index, val) nlm_hal_write_32bit_reg(nlm_hal_get_dev_base(dev), index, val)
+
+extern uint64_t nlm_hal_get_dev_base(int node, int bus, int dev, int func);
+
+/* 
+TODO :
+  1. support Debug flags
+  2. XLP support ?
+ */
+#endif /* __ASSEMBLY__ */
+
+#endif /* #ifndef _NLM_HAL_H_ */
diff --git a/arch/mips/include/asm/netlogic/hal/nlm_hal_fmn.h b/arch/mips/include/asm/netlogic/hal/nlm_hal_fmn.h
new file mode 100644
index 0000000..0aa41ee
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/hal/nlm_hal_fmn.h
@@ -0,0 +1,542 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+
+#ifndef _NLH_FMN_H
+#define _NLH_FMN_H
+
+#include "nlm_hal.h"
+#include "nlm_hal_xlp_dev.h"
+
+#ifndef __ASSEMBLY__
+
+#define FMN_INT_BIT_MASK 0x800000000000000ULL // Bit 59
+
+#define xlp_read_tx_status() _read_32bit_cp2_register(XLP_MSG_TXSTATUS_REG)
+#define xlp_read_rx_status() _read_32bit_cp2_register(XLP_MSG_RXSTATUS_REG)
+
+#define xlp_read_status1()   _read_32bit_cp2_register(XLP_MSG_STATUS1_REG)
+#define xlp_write_status1(value)   _write_32bit_cp2_register(XLP_MSG_STATUS1_REG, value)
+
+#define xlp_read_config()       _read_32bit_cp2_register(XLP_MSG_CONFIG_REG)
+#define xlp_write_config(value) _write_32bit_cp2_register(XLP_MSG_CONFIG_REG, value)
+
+#define xlp_load_rx_msg0() _read_64bit_cp2_register_sel(XLP_RX_BUF_REG, 0)
+#define xlp_load_rx_msg1() _read_64bit_cp2_register_sel(XLP_RX_BUF_REG, 1)
+#define xlp_load_rx_msg2() _read_64bit_cp2_register_sel(XLP_RX_BUF_REG, 2)
+#define xlp_load_rx_msg3() _read_64bit_cp2_register_sel(XLP_RX_BUF_REG, 3)
+
+#define xlp_load_tx_msg0(value) _write_64bit_cp2_register_sel(XLP_TX_BUF_REG, value, 0)
+#define xlp_load_tx_msg1(value) _write_64bit_cp2_register_sel(XLP_TX_BUF_REG, value, 1)
+#define xlp_load_tx_msg2(value) _write_64bit_cp2_register_sel(XLP_TX_BUF_REG, value, 2)
+#define xlp_load_tx_msg3(value) _write_64bit_cp2_register_sel(XLP_TX_BUF_REG, value, 3)
+
+enum LVL_INT_TYPES {
+	LVL_INT_DISABLE,
+	LVL_INT_LOW_WM,
+	LVL_INT_HIGH_WM,
+	LV_INT_RESERVED
+};
+
+enum LWM_INT_VALUES {
+	LWM_EMPTY,
+	LWM_1_4_FULL,
+	LWM_1_2_FULL,
+	LWM_3_4_FULL,
+	LWM_NON_FULL,
+	LWM_NUM_VALUES
+};
+enum HWM_INT_VALUES {
+	HWM_NON_EMPTY,
+	HWM_1_4_FULL,
+	HWM_1_2_FULL,
+	HWM_3_4_FULL,
+	HWM_FULL,
+	HWM_NUM_VALUES
+};
+
+/*
+ *  FMN Reg access macros
+ */
+enum XLP_REGS{
+  XLP_OUTQ_CONFIG_REG,
+  XLP_CREDIT_CONFIG_REG,
+  XLP_INTERCHIP_LINK_CONFIG_REG,
+  XLP_ERROR_REG
+};
+typedef volatile unsigned long long msg_reg_t;
+
+static inline unsigned long long nlh_qid_to_virt_addr(int reg, int sel)
+{
+  unsigned long long base = xlp_fmn_base & 0xffffffc000ULL;
+
+#if 0 //defined(NLM_HAL_LINUX_USER)
+  base |= NLH_XKPHYS_UNCACHED;
+#endif
+
+  if (reg == XLP_OUTQ_CONFIG_REG) {
+    return ((sel * 8) | base); // 'sel' is the qid
+
+  } else if (reg == XLP_CREDIT_CONFIG_REG) {
+    return (0x2000 | base);
+
+  } else if (reg == XLP_ERROR_REG) {
+    return (0x2020 | base);
+
+  } else {
+    //    nlm_print("FMN Error: Unknown register ID %d\n", reg);
+  }
+  return 0;
+}
+//
+#define nlm_hal_read_outq_config(qid) \
+  nlh_read_cfg_reg64(nlh_qid_to_virt_addr(XLP_OUTQ_CONFIG_REG, qid))
+
+#define nlm_hal_write_outq_config(qid, val) \
+  nlh_write_cfg_reg64( nlh_qid_to_virt_addr(XLP_OUTQ_CONFIG_REG, qid), val)
+
+#define nlm_hal_read_credit(qid, src, dst) \
+    nlh_read_cfg_reg64(nlh_qid_to_virt_addr(XLP_CREDIT_CONFIG_REG, 0))
+
+/*
+ *  Messaging Operations 
+ */
+static inline int xlp_send(unsigned int dest)
+{
+        unsigned int success = 0;
+
+        __asm__ volatile (".set push\n"
+                          ".set noreorder\n"
+                          ".set arch=xlp\n"
+                          "msgsnds %0, %1\n"
+                          ".set pop\n"
+                          : "=&r" (success)
+                          : "r" (dest));
+
+        return success;
+}
+//
+#if 0
+static inline void xlp_receive(unsigned int pri)
+{
+	__asm__ volatile (".set push\n"
+			  ".set noreorder\n"
+                          ".set arch=xlp\n"
+			  "msglds $0, %0\n" ".set pop\n"::"r" (pri)
+	    );
+}
+#endif
+//
+static inline void xlp_message_wait(unsigned int mask)
+{
+    __asm__ volatile(".set push\n"
+            ".set noreorder\n"
+            " msgwait %0\n"
+            ".set pop\n"::"r" (mask)
+            );
+}
+//
+#define xlp_enable(flags)                        \
+do {                                                \
+  __asm__ volatile (                                \
+		    ".set push\n\t"                 \
+		    ".set reorder\n\t"              \
+		    ".set noat\n\t"                 \
+		    "mfc0 %0, $12\n\t"              \
+		    "li  $8, 0x40000001\n\t"        \
+		    "or  $1, %0, $8\n\t"            \
+		    "xori $1, 1\n\t"                \
+		    ".set noreorder\n\t"            \
+		    "mtc0 $1, $12\n\t"              \
+		    ".set\tpop\n\t"                 \
+		    : "=r" (flags)                  \
+		    :                               \
+		    : "$8"                          \
+		    );                              \
+} while (0)
+//
+#define xlp_disable(flags) __asm__ volatile (    \
+                 "mtc0 %0, $12" : : "r" (flags))
+
+//
+static __inline__ unsigned long long xlp_cpu_to_bucket_mask(unsigned int
+							       cpumask)
+{
+  return 0;
+}
+//
+static __inline__ unsigned int xlp_cpu_to_bucket(int pid)
+{
+  return 0;
+}
+//
+/*
+   XLP API
+   RT[63 : 32] - Reserved
+   RT[31 : 24] - Software Code
+   RT[23 : 21] - Reserved
+   RT[20 : 19] - Pop Message Source VC no.
+   RT[18 : 18] - Reserved
+   RT[17 : 16] - Message Size-1
+   RT[15 : 12] - Reserved
+   RT[11 : 0]  - Message Destination ID
+ */
+/* message send API NON blocking for single entry message*/
+static inline int xlp_message_send_1(uint32_t dst, 
+				     uint32_t  code, uint64_t data)
+{
+  unsigned int dest = 0;
+
+  xlp_load_tx_msg0(data);
+
+  dest = ((code << 24) | dst);
+
+#ifdef MSGRING_DUMP_MESSAGES
+  nlm_hal_dbg_msg("Sending msg<%llx> to dest = %x\n", 
+	  data, dest);
+#endif
+	
+  if (!xlp_send(dest) ) {
+	  /* Check the status */
+	  return xlp_read_tx_status() ;
+  }
+
+  return 0;
+}
+/* message send API NON blocking for double entry message*/
+static inline int xlp_message_send_2(uint32_t dst, 
+				     uint32_t  code,
+				     uint64_t data0, uint64_t data1)
+{
+  unsigned int dest = 0;
+
+
+  xlp_load_tx_msg0(data0);
+  xlp_load_tx_msg1(data1);
+
+  dest = ((code << 24) | (1 << 16) | dst);
+
+#ifdef MSGRING_DUMP_MESSAGES
+  nlm_hal_dbg_msg("Sending msg<%llx, %llx> to dest = %x\n", 
+	  data0, data1, dest);
+#endif
+	
+  if (!xlp_send(dest) ) {
+	  /* Check the status */
+	  return xlp_read_tx_status();
+  }
+
+  return 0;
+}
+
+/* message send API NON blocking for double entry message*/
+static inline int xlp_message_send_3(uint32_t dst, 
+				     uint32_t  code,
+				     uint64_t data0, uint64_t data1,
+				     uint64_t data2)
+{
+  unsigned int dest = 0;
+
+
+  xlp_load_tx_msg0(data0);
+  xlp_load_tx_msg1(data1);
+  xlp_load_tx_msg2(data2);
+
+  dest = ((code << 24) | (2 << 16) | dst);
+
+#ifdef MSGRING_DUMP_MESSAGES
+  nlm_hal_dbg_msg("Sending msg<%llx, %llx, %llx> to dest = %x\n", 
+	  data0, data1, data2, dest);
+#endif
+	
+  if (!xlp_send(dest) ) {
+	  /* Check the status */
+	  return xlp_read_tx_status();
+  }
+
+
+  return 0;
+}
+
+/* Generic message send API NON blocking */
+static inline int xlp_message_send(uint32_t dst, 
+				   uint32_t size,  uint32_t  code,
+				   uint64_t *data)
+{
+  unsigned int dest = 0;
+
+    switch (size)
+    {
+      case 4:
+		  xlp_load_tx_msg3(data[3]);
+
+      case 3:
+		  xlp_load_tx_msg2(data[2]);
+
+      case 2:
+		  xlp_load_tx_msg1(data[1]);
+          
+      default:
+		  xlp_load_tx_msg0(data[0]);
+    }
+
+  dest = ((code << 24) | ((size - 1) << 16) | dst);
+ 
+  if (!xlp_send(dest) ) {
+	  /* Check the status */
+	  return xlp_read_tx_status();
+  }
+
+  return 0;
+}
+/* API to send a 1 entry message to "stid" with given "code" */
+static inline void xlp_message_send_block_fast_1(unsigned int code, 
+						 unsigned int dest_vc,
+						 unsigned long long msg0)
+{
+  __asm__ __volatile__ (".set push\n"
+			".set noreorder\n"
+			".set arch=xlp\n"
+			"dmtc2 %1, "STR(XLP_TX_BUF_REG)", 0\n"
+			"sync\n"
+			"1: \n"
+			"msgsnds  $8, %0\n"    /* msgsnds rD, rt */
+			"andi $8, $8, 0x1\n"
+			"beqz $8, 1b\n"
+			"move $8, %0\n"
+			".set mips64\n"
+			".set pop\n"
+			:
+			: "r"((code << 24) |  dest_vc), /* %0 */
+			  "r"(msg0) 
+			: "$8"
+			);
+}
+//
+/* API to send a 2 entry message to "stid" with given "code" */
+static inline void xlp_message_send_block_fast_2(unsigned int code, 
+						 unsigned int dest_vc,
+						 unsigned long long msg0,
+						 unsigned long long msg1)
+{
+  __asm__ __volatile__ (".set push\n"
+			".set noreorder\n"
+			".set arch=xlp\n"
+			"dmtc2 %1, "STR(XLP_TX_BUF_REG)", 0\n"
+			"dmtc2 %2, "STR(XLP_TX_BUF_REG)", 1\n"
+			"sync\n"
+			"1: \n"
+			"msgsnds  $8, %0\n"    /* msgsnds rD, rt */
+			"andi $8, $8, 0x1\n"
+			"beqz $8, 1b\n"
+			"move $8, %0\n"
+			".set mips64\n"
+			".set pop\n"
+			:
+			: "r"((code << 24) | (1 << 16) | dest_vc), /* %0 */
+			  "r"(msg0), "r" (msg1) 
+			: "$8"
+			);
+}
+/* API to send a 3 entry message to "stid" with given "code" */
+static inline void xlp_message_send_block_fast_3(unsigned int code, 
+						 unsigned int dest_vc,
+						 unsigned long long msg0,
+						 unsigned long long msg1,
+						 unsigned long long msg2)
+{
+  __asm__ __volatile__ (".set push\n"
+			".set noreorder\n"
+			".set arch=xlp\n"
+			"dmtc2 %1, "STR(XLP_TX_BUF_REG)", 0\n"
+			"dmtc2 %2, "STR(XLP_TX_BUF_REG)", 1\n"
+			"dmtc2 %3, "STR(XLP_TX_BUF_REG)", 2\n"
+			"sync\n"
+			"1: \n"
+			"msgsnds  $8, %0\n"    /* msgsnds rD, rt */
+			"andi $8, $8, 0x1\n"
+			"beqz $8, 1b\n"
+			"move $8, %0\n"
+			".set mips64\n"
+			".set pop\n"
+			:
+			: "r"((code << 24) | (2 << 16) | dest_vc), /* %0 */
+			  "r"(msg0), "r" (msg1), "r" (msg2)
+			: "$8"
+			);
+}
+//
+static inline void xlp_message_send_block_fast(int size, unsigned int code,
+					       unsigned int dest_vc,
+					       unsigned long long msg0,
+					       unsigned long long msg1,
+					       unsigned long long msg2,
+					       unsigned long long msg3)
+{
+  __asm__ __volatile__ (".set push\n"
+			".set noreorder\n"
+			".set arch=xlp\n"
+			"dmtc2 %1, " STR(XLP_TX_BUF_REG) ", 0\n"
+			"dmtc2 %2, " STR(XLP_TX_BUF_REG) ", 1\n"
+			"dmtc2 %3, " STR(XLP_TX_BUF_REG) ", 2\n"
+			"dmtc2 %4, " STR(XLP_TX_BUF_REG) ", 3\n"
+			"sync\n"
+			"1: \n"
+			"msgsnds  $8, %0\n"    /* msgsnds rD, rt */
+			"andi $8, $8, 0x1\n"
+			"beqz $8, 1b\n"
+			"move $8, %0\n"
+			".set mips64\n"
+			".set pop\n"::
+			"r"((code << 24) | ((size-1) << 16) | dest_vc), /* %0 */
+			"r"(msg0), "r"(msg1),
+			"r"(msg2), "r"(msg3)
+			:"$8");
+}
+//
+static inline int xlp_receive(unsigned int vc)
+{
+	unsigned int success = 0;
+
+	__asm__ volatile (".set push\n"
+	                  ".set noreorder\n"
+	                  ".set arch=xlp\n"
+	                  "msglds %0, %1\n"
+	                  ".set pop\n"
+	                  : "=&r" (success)
+	                  : "r" (vc));
+
+	return success;
+}
+//
+static inline int xlp_message_receive_1(uint32_t vc, uint32_t *src_id,
+	uint32_t *size, uint32_t *code,	uint64_t *msg0)
+{
+	unsigned int status;
+
+	if (!xlp_receive(vc))
+		return -1;
+
+	status = xlp_read_rx_status();
+	*size = ((status >> 26) & 0x3) + 1;
+	*code = (status >> 18) & 0xff;
+	*src_id = (status >> 4) & 0xfff;
+	*msg0 = xlp_load_rx_msg0();
+	return 0;
+}
+static inline int xlp_message_receive_2(uint32_t vc, uint32_t *src_id,
+	uint32_t *size, uint32_t *code, uint64_t *msg0, uint64_t *msg1)
+{
+	unsigned int status;
+
+	if (!xlp_receive(vc))
+		return -1;
+
+	status = xlp_read_rx_status();
+	*size = ((status >> 26) & 0x3) + 1;
+	*code = (status >> 18) & 0xff;
+	*src_id = (status >> 4) & 0xfff;
+	*msg0 = xlp_load_rx_msg0();
+	*msg1 = xlp_load_rx_msg1();
+	return 0;
+}
+//
+static inline int xlp_message_receive(uint32_t vc, uint32_t *src_id,
+	uint32_t *size, uint32_t *code, uint64_t *msg0, uint64_t *msg1,
+	uint64_t *msg2, uint64_t *msg3)
+{
+	unsigned int status;
+
+	if (!xlp_receive(vc))
+		return -1;
+
+	status = xlp_read_rx_status();
+	*size = ((status >> 26) & 0x3) + 1;
+	*code = (status >> 18) & 0xff;
+	*src_id = (status >> 4) & 0xfff;
+	*msg0 = xlp_load_rx_msg0();
+	*msg1 = xlp_load_rx_msg1();
+	*msg2 = xlp_load_rx_msg2();
+	*msg3 = xlp_load_rx_msg3();
+	return 0;
+}
+//
+static inline int xlp_message_pop_2(uint32_t vc, uint32_t src_id,
+				    uint32_t code, 
+				    uint64_t data0, uint64_t data1)
+{
+  return 0; // TODO: implement
+}
+
+static inline int xlp_message_pop_1(uint32_t vc, uint32_t src_id,
+				    uint32_t code, 
+				    uint64_t data0)
+{
+  return 0; // TODO: implement
+}
+
+//
+// Generic Messaging API
+//
+static inline int xlp_message_send_block(unsigned int size, unsigned int code,
+					 unsigned int stid, uint64_t data0, uint64_t data1,
+					 uint64_t data2, uint64_t data3)
+{
+    xlp_message_send_block_fast(size, code, stid, data0, data1, data2, data3);
+    return 0;
+}
+//
+
+#endif				/* __ASSEMBLY__ */
+
+/* Returns the TxStatus reg */
+extern uint32_t nlm_hal_send_msg3(uint32_t dst, uint32_t code, uint64_t data0, uint64_t data1, uint64_t data2);
+extern uint32_t nlm_hal_send_msg2(uint32_t dst, uint32_t code, uint64_t data0, uint64_t data1);
+extern uint32_t nlm_hal_send_msg1(uint32_t dst, uint32_t code, uint64_t data0);
+/* Returns the RxStatus reg */
+extern uint32_t nlm_hal_recv_msg2(uint32_t dst, uint32_t *src, uint32_t *size, uint32_t *code, uint64_t *data0, uint64_t *data1);
+extern uint32_t nlm_hal_recv_msg1(uint32_t dst, uint32_t *src, uint32_t *size, uint32_t *code, uint64_t *data0);
+
+extern uint32_t nlm_hal_pop_msg2(uint32_t dst, uint32_t src, uint32_t code, uint64_t data0, uint64_t data1);
+extern uint32_t nlm_hal_pop_msg1(uint32_t dst, uint32_t src, uint32_t code, uint64_t data0);
+
+
+static __inline__ int fmn_level_int_type(uint64_t outq_config)
+{
+	return xlp_get_field_dw(outq_config, 54, 2);
+}
+
+static __inline__ int fmn_level_int_val(uint64_t outq_config)
+{
+	return xlp_get_field_dw(outq_config, 56, 3);
+}
+
+extern void nlm_hal_fmn_init(uint64_t spill_base, uint32_t size, uint32_t credit);
+extern void nlm_hal_set_fmn_interrupt(int irq);
+
+extern void nlm_hal_disable_vc_intr(int vc);
+extern void nlm_hal_enable_vc_intr(int vc);
+
+#endif /* #ifndef _NLH_FMN_H */
+
diff --git a/arch/mips/include/asm/netlogic/hal/nlm_hal_macros.h b/arch/mips/include/asm/netlogic/hal/nlm_hal_macros.h
new file mode 100644
index 0000000..45aa58a
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/hal/nlm_hal_macros.h
@@ -0,0 +1,868 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+
+#ifndef _NLM_HAL_MACROS_H
+#define _NLM_HAL_MACROS_H
+
+#ifndef __ASSEMBLY__
+extern unsigned long long xlp_io_base;
+extern unsigned long long xlp_fmn_base;
+extern unsigned long long xlp_nae_base;
+extern unsigned long long xlp_mac_base;
+extern unsigned long long xlp_poe_base_pcie;
+extern unsigned long long xlp_poe_base_pcim;
+extern unsigned long long xlp_sys_base;
+#endif /* #ifndef __ASSEMBLY__ */
+
+#ifndef NLM_HAL_LINUX_KERNEL
+#define preempt_enable()
+#define preempt_disable()
+#endif
+
+#define msgrng_enable(flags)                \
+do {                                        \
+  preempt_disable(); \
+  __asm__ volatile (                        \
+		    ".set push\n\t"                 \
+		    ".set reorder\n\t"              \
+		    ".set noat\n\t"                 \
+		    "mfc0 %0, $12\n\t"              \
+		    "li  $8, 0x40000001\n\t"        \
+		    "or  $1, %0, $8\n\t"            \
+		    "xori $1, 1\n\t"                \
+		    ".set noreorder\n\t"            \
+		    "mtc0 $1, $12\n\t"              \
+		    ".set\tpop\n\t"                 \
+		    : "=r" (flags)                  \
+		    :                               \
+		    : "$8"                          \
+		    );                              \
+  preempt_enable(); \
+} while (0)
+
+#define msgrng_disable(flags) __asm__ volatile (    \
+                 "mtc0 %0, $12" : : "r" (flags))
+
+#define msgrng_access_enable(mflags) do {   \
+  preempt_disable();                        \
+  msgrng_enable(mflags);                \
+} while(0)
+
+#define msgrng_access_disable(mflags) do {   \
+  msgrng_disable(mflags);              \
+  preempt_enable();                          \
+} while(0)
+
+#if defined(NLM_HAL_LINUX_USER) /* Linux User mode */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <inttypes.h>
+
+#define nlm_print printf
+#define nlm_malloc malloc
+#define nlm_free  free
+#define nlm_delay(x) usleep((x) * 1000)
+
+#elif defined(NLM_HAL_LINUX_KERNEL) /* Linux Kenrel mode */
+
+#include <asm/mipsregs.h>
+#ifndef __ASSEMBLY__
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+
+#define nlm_print printk
+#define nlm_malloc(size) kzalloc((size), GFP_KERNEL)
+#define nlm_free  kfree
+#define nlm_delay  mdelay
+
+extern int register_xlp_msgring_handler(int major,
+                             void (*action) (uint32_t, uint32_t, uint32_t, uint32_t,
+                                             uint64_t, uint64_t, uint64_t, uint64_t, void *),
+                             void *dev_id);
+
+#endif /* __ASSEMBLY__ */
+
+#elif defined(NLM_HAL_NETOS) /* Netos */
+
+#ifndef __ASSEMBLY__
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <inttypes.h>
+
+#define nlm_print printf
+#define nlm_malloc malloc
+#define nlm_free  free
+#define nlm_delay(x)  _netos_delay(x) /* Temporary implementation for netos-hyperex */
+static __inline__ void _netos_delay(x)
+{
+        unsigned long int i;
+
+        /* compilers beyond gcc 4.0 will remove off tight loops
+         * when optimization is enabled. This asm call is
+         * supposedly the standard way to work around this.
+         */
+        for (i = 0; i<(1000 * x) ; i++)
+                __asm__ __volatile__ ("");
+}
+
+#endif /* __ASSEMBLY__ */
+
+#elif defined(NLM_HAL_UBOOT) /* u-boot */
+
+#include <common.h>
+#include <command.h>
+#include <malloc.h>
+
+#define nlm_print printf
+#define nlm_malloc malloc
+#define nlm_free  free
+#define nlm_delay  udelay
+
+#elif defined(NLM_HAL_NETLBOOT) /* netlboot */
+#include <printk.h>
+
+#define nlm_print printk
+#define nlm_malloc malloc
+#define nlm_free  free
+#define nlm_delay  mdelay
+
+#else
+#error "Unsupported platform for NL HAL"
+#endif	/* NLM_HAL_LINUX_USER */
+
+#define CCA_UNCACHED  2
+#define CCA_CACHED    3
+
+#define CRC_POLY_REG_0_SEL 0
+#define CRC_POLY_REG_1_SEL 1
+#define CRC_POLY_REG_2_SEL 2
+#define CRC_POLY_REG_3_SEL 3
+
+#define CRC_ENDIAN_BIT 5
+#define CRC_FLIPBITS_BIT 4
+#define CRC_DESTINATION_BIT 6
+
+#define CRC_32_INIT_VALUE 0xffffffff
+#define CRC_16_INIT_VALUE 0
+
+/*
+ * Memory segments (64bit kernel mode addresses)
+ */
+/* XLP_MERGE_TODO */
+#define NLH_XKUSEG			0x0000000000000000
+#define NLH_XKSSEG			0x4000000000000000
+#define NLH_XKPHYS			0x8000000000000000
+#define NLH_XKPHYS_UNCACHED             0x9000000000000000ULL
+#define NLH_XKSEG			0xc000000000000000
+#define NLH_CKSEG0			0xffffffff80000000
+#define NLH_CKSEG1			0xffffffffa0000000
+#define NLH_CKSSEG			0xffffffffc0000000
+#define NLH_CKSEG3			0xffffffffe0000000
+
+#define SET_MIPS64 .set mips64r2
+#define NLM_HAL_THREAD_SIZE (8 << 10)
+
+/* For hal internal debug */
+#define nlm_hal_dbg_msg(fmt, args...) {} /*printk(fmt, ##args)*/
+
+#ifndef __STR
+#define __STR(x) #x
+#endif
+#ifndef STR
+#define STR(x) __STR(x)
+#endif
+
+#ifndef __ASSEMBLY__
+#define XLP_BIT_MASK_W(size) ((1 << (size)) - 1)
+#define XLP_BIT_MASK_DW(size) (((unsigned long long) 1 << size) - 1)
+
+static __inline__ uint8_t lb_40bit_phys(uint64_t phys, int cca)
+{
+        uint8_t value = 0;
+
+        __asm__ __volatile__(".set push\n"
+                             ".set noreorder\n"
+                             ".set mips64\n"
+                             "dli   $8, " STR(NLH_XKPHYS) "\n"
+                             "or    $8, $8, %2\n"
+                             "daddu $8, $8, %1\n"
+                             "lb    %0, 0($8) \n" ".set pop\n":"=r"(value)
+                             :"r"(phys & 0xffffffffffULL),
+                             "r"((uint64_t) cca << 59)
+                             :"$8");
+
+        return value;
+}
+
+static __inline__ uint16_t lh_40bit_phys(uint64_t phys, int cca)
+{
+	uint16_t value = 0;
+
+	__asm__ __volatile__(".set push\n"
+			     ".set noreorder\n"
+			     ".set mips64\n"
+			     "dli   $8, " STR(NLH_XKPHYS) "\n"
+			     "or    $8, $8, %2\n"
+			     "daddu $8, $8, %1\n"
+			     "lhu    %0, 0($8) \n"
+			     ".set pop\n"
+			     :"=r"(value)
+			     :"r"(phys & 0xfffffffffeULL),"r"((uint64_t) cca << 59)
+			     :"$8");
+
+	return value;
+}
+
+static __inline__ uint64_t lw_40bit_phys(uint64_t phys, int cca)
+{
+	uint64_t value = 0;
+
+	__asm__ __volatile__(".set push\n"
+			     ".set noreorder\n"
+			     ".set mips64\n"
+			     "dli   $8, " STR(NLH_XKPHYS) "\n"
+			     "or    $8, $8, %2\n"
+			     "daddu $8, $8, %1\n"
+			     "lw    %0, 0($8) \n"
+			     ".set pop\n"
+			     :"=r"(value)
+			     :"r"(phys & 0xfffffffffcULL),"r"((uint64_t) cca << 59)
+			     :"$8");
+
+	return value;
+}
+static __inline__ uint64_t ld_40bit_phys(uint64_t phys, int cca)
+{
+	uint64_t value = 0;
+
+	__asm__ __volatile__(".set push\n"
+			     ".set noreorder\n"
+			     ".set mips64\n"
+			     "dli   $8, " STR(NLH_XKPHYS) "\n"
+			     "or    $8, $8, %2\n"
+			     "daddu $8, $8, %1\n"
+			     "ld    %0, 0($8) \n"
+			     ".set pop\n"
+			     :"=r"(value)
+			     :"r"(phys & 0xfffffffff8ULL),"r"((uint64_t) cca << 59)
+			     :"$8");
+
+	return value;
+}
+static __inline__ uint8_t lb_40bit_phys_uncached(uint64_t phys)
+{
+        return lb_40bit_phys(phys, CCA_UNCACHED);
+}
+
+static __inline__  uint8_t lb_40bit_phys_cached(uint64_t phys)
+{
+        return lb_40bit_phys(phys, CCA_CACHED);
+}
+static __inline__ uint32_t lw_40bit_phys_uncached(uint64_t phys)
+{
+	return lw_40bit_phys(phys, CCA_UNCACHED);
+}
+static __inline__ uint32_t lw_40bit_phys_cached(uint64_t phys)
+{
+	return lw_40bit_phys(phys, CCA_CACHED);
+}
+static __inline__ uint64_t ld_40bit_phys_uncached(uint64_t phys)
+{
+	return ld_40bit_phys(phys, CCA_UNCACHED);
+}
+static __inline__ uint64_t ld_40bit_phys_cached(uint64_t phys)
+{
+	return ld_40bit_phys(phys, CCA_CACHED);
+}
+
+static __inline__ void sb_40bit_phys(uint64_t phys, int cca, uint8_t value)
+{
+  __asm__ __volatile__(".set push\n"
+                       ".set noreorder\n"
+                       ".set mips64\n"
+                       "dli   $8, "STR(NLH_XKPHYS)"\n"
+                       "or    $8, $8, %2\n"
+                       "daddu $8, $8, %1\n"
+                       "sb    %0, 0($8) \n"
+                       ".set pop\n"
+                       :
+                       : "r"(value), "r"(phys & 0xffffffffffULL), "r"((uint64_t)cca << 59)
+                       : "$8"
+          );
+}
+static __inline__ void sh_40bit_phys(uint64_t phys, int cca, uint32_t value)
+{
+  __asm__ __volatile__(".set push\n"
+                       ".set noreorder\n"
+                       ".set mips64\n"
+                       "dli   $8, "STR(NLH_XKPHYS)"\n"
+                       "or    $8, $8, %2\n"
+                       "daddu $8, $8, %1\n"
+                       "sh    %0, 0($8) \n"
+                       ".set pop\n"
+                       :
+                       : "r"(value), "r"(phys & 0xfffffffffeULL), "r"((uint64_t)cca << 59)
+                       : "$8"
+	  );
+}
+static __inline__ void sw_40bit_phys(uint64_t phys, int cca, uint32_t value)
+{
+	__asm__ __volatile__(".set push\n"
+			     ".set noreorder\n"
+			     ".set mips64\n"
+			     "dli   $8, " STR(NLH_XKPHYS) "\n"
+			     "or    $8, $8, %2\n"
+			     "daddu $8, $8, %1\n"
+			     "sw    %0, 0($8) \n"
+			     ".set pop\n"
+			     :
+			     :"r"(value), "r"(phys & 0xfffffffffcULL), "r"((uint64_t) cca << 59)
+			     :"$8"
+		);
+}
+static __inline__ void sd_40bit_phys(uint64_t phys, int cca, uint64_t value)
+{
+	__asm__ __volatile__(".set push\n"
+			     ".set noreorder\n"
+			     ".set mips64\n"
+			     "dli   $8, " STR(NLH_XKPHYS) "\n"
+			     "or    $8, $8, %2\n"
+			     "daddu $8, $8, %1\n"
+			     "sd    %0, 0($8) \n"
+			     ".set pop\n"
+			     :
+			     :"r"(value), "r"(phys & 0xfffffffff8ULL), "r"((uint64_t) cca << 59)
+			     :"$8"
+		);
+}
+static __inline__ void sb_40bit_phys_uncached(uint64_t phys, uint8_t value)
+{
+      sb_40bit_phys(phys, CCA_UNCACHED, value);
+}
+static __inline__ void sb_40bit_phys_cached(uint64_t phys, uint8_t value)
+{
+      sb_40bit_phys(phys, CCA_CACHED, value);
+}
+static __inline__ void sw_40bit_phys_uncached(uint64_t phys, uint32_t value)
+{
+	sw_40bit_phys(phys, CCA_UNCACHED, value);
+}
+static __inline__ void sw_40bit_phys_cached(uint64_t phys, uint32_t value)
+{
+	sw_40bit_phys(phys, CCA_CACHED, value);
+}
+static __inline__ void sd_40bit_phys_uncached(uint64_t phys, uint64_t value)
+{
+	sd_40bit_phys(phys, CCA_UNCACHED, value);
+}
+static __inline__ void sd_40bit_phys_cached(uint64_t phys, uint64_t value)
+{
+	sd_40bit_phys(phys, CCA_CACHED, value);
+}
+
+#define enable_KX(flags)       \
+ __asm__ __volatile__ (        \
+        ".set push\n"          \
+        ".set noat\n"          \
+        ".set noreorder\n"     \
+        "mfc0 %0, $12\n\t"     \
+        "ori $1, %0, 0x81\n\t" \
+        "xori $1, 1\n\t"       \
+        "mtc0 $1, $12\n"       \
+        ".set pop\n"           \
+        : "=r"(flags) ); 
+        
+#define disable_KX(flags)   \
+ __asm__ __volatile__ (     \
+        ".set push\n"       \
+        "mtc0 %0, $12\n"    \
+        ".set pop\n"        \
+        : : "r"(flags) )
+        
+
+/*
+ *  COP2 Reg access macros
+ */
+#define _read_32bit_cp2_register(source)                        \
+({ int __res;                                                   \
+        __asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+	".set\treorder\n\t"					\
+        "mfc2\t%0,"STR(source)"\n\t"                            \
+	".set\tpop"						\
+        : "=r" (__res));                                        \
+        __res;})
+
+#define _write_32bit_cp2_register(register,value)               \
+        __asm__ __volatile__(                                   \
+        "mtc2\t%0,"STR(register)"\n\t"				\
+	"nop"							\
+        : : "r" (value));
+
+#define _read_32bit_cp2_register_sel(source, sel)               \
+({ int __res;                                                   \
+        __asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+        ".set mips32\n\t"                                       \
+        "mfc2\t%0,"STR(source)", %1\n\t"                        \
+	".set\tpop"						\
+        : "=r" (__res) : "i" (sel) );                           \
+        __res;})
+
+#define _write_32bit_cp2_register_sel(reg, value, sel)          \
+        __asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+        ".set mips32\n\t"                                       \
+        "mtc2\t%0,"STR(reg)", %1\n\t"                           \
+	".set\tpop"						\
+        : : "r" (value), "i" (sel) );
+
+#ifndef _ABI64
+
+#define _read_64bit_cp2_register_sel(source, sel)                        \
+({                                                                      \
+        unsigned int high, low;                                         \
+                                                                        \
+                __asm__ __volatile__(                                   \
+                        ".set\tmips64\n\t"                              \
+                        "dmfc2\t$8, "STR(source)","STR(sel)"\n\t"       \
+                        "dsrl32\t%0, $8, 0\n\t"                         \
+                        "dsll32\t$8, $8, 0\n\t"                         \
+                        "dsrl32\t%1, $8, 0\n\t"                         \
+                        ".set\tmips0"                                   \
+                        : "=r" (high), "=r"(low): "i"(sel) : "$8");     \
+        ( (((unsigned long long)high)<<32) | low);                      \
+})
+
+#define _write_64bit_cp2_register_sel(source, val, sel)                 \
+do {                                                                    \
+     unsigned int high = val>>32;                                       \
+     unsigned int low  = val & 0xffffffff;                              \
+                __asm__ __volatile__(                                   \
+                        ".set\tmips64\n\t"                              \
+                        "dsll32 $8, %1, 0\n"                            \
+                        "dsll32 $9, %0, 0\n"                            \
+                        "dsrl32 $8, $8, 0\n"                            \
+                        "or     $8, $8, $9\n"                           \
+                        "dmtc2\t$8, "STR(source)", %2\n\t"              \
+                        ".set\tmips0"                                   \
+                        : : "r" (high), "r" (low), "i"(sel): "$8", "$9");               \
+} while (0)
+
+#define _read_64bit_cp2_register(source) \
+	_read_64bit_cp2_register_sel(source, 0)
+#define _write_64bit_cp2_register(source, val) \
+	_write_64bit_cp2_register_sel(source, val, 0)
+
+#else /* _ABI64 */
+
+#define _read_64bit_cp2_register(source)                        \
+({ unsigned long long __res;                                    \
+        __asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+	".set\treorder\n\t"					\
+        ".set\tmips64\n\t"                                      \
+        "dmfc2\t%0,"STR(source)"\n\t"                           \
+	".set\tpop"						\
+        : "=r" (__res));                                        \
+        __res;})
+
+#define _write_64bit_cp2_register(register,value)               \
+        __asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+	".set\treorder\n\t"					\
+        "dmtc2\t%0,"STR(register)"\n\t"				\
+	"nop"							\
+	".set\tpop"						\
+        : : "r" (value));
+
+#define _read_64bit_cp2_register_sel(source, sel)               \
+({ unsigned long long __res;                                    \
+        __asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+        ".set mips64\n\t"                                       \
+        "dmfc2\t%0,"STR(source)", %1\n\t"                       \
+	".set\tpop"						\
+        : "=r" (__res) : "i" (sel) );                           \
+        __res;})
+
+#define _write_64bit_cp2_register_sel(reg, value, sel)          \
+        __asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+        ".set mips64\n\t"                                       \
+        "dmtc2\t%0,"STR(reg)", %1\n\t"                          \
+	".set\tpop"						\
+        : : "r" (value), "i" (sel) );
+
+#endif /* _ABI64 */
+
+typedef enum crc_type {
+	NLM_CRC_32 = 0,
+	NLM_CRC_16 = 16,
+	NLM_CRC_7 = 25
+} crc_type_t;
+
+#define REG_STR(x) "$" #x
+
+#undef USE_64BIT_CRC
+#if defined(NLM_HAL_LINUX_KERNEL)
+#define USE_64BIT_CRC
+#else
+#if _MIPS_SIM != _MIPS_SIM_ABI32 && !defined(ABI_32)
+#define USE_64BIT_CRC
+#endif
+#endif /* NLM_HAL_LINUX_KERNEL */
+
+#ifdef USE_64BIT_CRC
+typedef uint64_t u_data;
+#else
+typedef uint32_t u_data;
+#endif
+
+#define INIT_CRC_POLY(poly_reg, poly_type, crc_poly) \
+({                                                            \
+    asm volatile (                                            \
+        ".set push\n"                                         \
+        ".set noat\n"                                         \
+	"dmtur %0, " REG_STR(poly_reg) "\n"                   \
+        ".set pop\n"                                          \
+	: : [poly] "r"((crc_poly << poly_type) & 0x00000000ffffffff)  \
+    );                                                        \
+})
+
+#ifdef USE_64BIT_CRC
+static __inline__ unsigned int
+nlm_crc32_generic(uint64_t data, unsigned int flags_len, unsigned int crc)
+{
+	unsigned int ret;
+	asm volatile (
+		".set push\n"
+		".set noreorder\n"
+		"addiu $9, %[flags_len], 0\n"
+		"dcrc   %[result], %[input], $9\n"
+		".set pop\n"
+		: [result] "=r"(ret)
+		: [input] "r"(data), [flags_len] "r"(flags_len), "0"(crc)
+		: "$9"
+	);
+	return ret;
+}
+#else
+static __inline__ unsigned int
+nlm_crc32_generic(unsigned int data, unsigned int flags_len, unsigned int crc)
+{
+	unsigned int ret;
+	asm volatile (
+		".set push\n"
+		".set noreorder\n"
+		"addiu $9, %[flags_len], 0\n"
+		"crc   %[result], %[input], $9\n"
+		".set pop\n"
+		: [result] "=r"(ret)
+		: [input] "r"(data), [flags_len] "r"(flags_len), "0"(crc)
+		: "$9"
+	);
+	return ret;
+}
+#endif
+
+static __inline__ uint32_t
+bit_flip(uint32_t t)
+{
+	unsigned int ret = 0, x = t;
+
+    asm volatile (
+	    ".set push\n"
+	    ".set mips32\n"
+	    ".set noreorder\n"
+	    "addiu   %[ret], $0, 0\n"
+	 "1: addiu   $9, $0, 32\n"
+	    "clz     $8, %[val]\n"
+	    "beq     $8, $9, 3f\n"
+
+	    // set the bit in the correct location of result
+	    "addiu   $9, $0, 1\n"
+	    "sllv    $9, $9, $8\n"
+	    "or      %[ret], %[ret], $9\n"
+
+	    // reset the bit in the data
+	    "addiu   $9, $0, 31\n"
+	    "subu    $9, $9, $8\n"
+	    "addiu   $8, $0, 1\n"
+	    "sllv    $9, $8, $9\n"
+	    "xor     %[val], %[val], $9\n"
+	    "b       1b\n"
+	    ".set pop\n"
+	    "3: nop\n"
+	    : [ret] "=&r"(ret) : [val] "r"(x)
+	    :"$8", "$9"
+	    );
+    return ret;
+}
+
+static __inline__ unsigned int
+nlm_crc32_word(int crc_reg, u_data data, unsigned int len,
+	   unsigned int crc_init)
+{
+	/* flip bit */
+	unsigned int flags_len = (1 << CRC_FLIPBITS_BIT) | (1 << CRC_DESTINATION_BIT);
+
+	/* set length and CRC poly reg */
+	flags_len |= ((len & 0x7) |
+		      ((crc_reg & 0x3) << 8));
+
+	return nlm_crc32_generic(data, flags_len, crc_init);
+}
+
+static __inline__ uint32_t
+nlm_crc16_ibm(int crc_reg, u_data data, unsigned int len,
+	  unsigned short crc_init)
+{
+	/* flip bit */
+	unsigned int flags_len = (1 << CRC_FLIPBITS_BIT) | (1 << CRC_DESTINATION_BIT);
+
+	/* set length and CRC poly reg */
+	flags_len |= ((len & 0x7) |
+		      ((crc_reg & 0x3) << 8));
+
+	return  nlm_crc32_generic(data, flags_len, crc_init);
+}
+
+static __inline__ uint32_t
+nlm_crc7_word(int crc_reg, u_data data, unsigned int len, unsigned short crc_init)
+{
+	/* flip bit */
+	unsigned int flags_len = (1 << CRC_FLIPBITS_BIT) | (1 << CRC_DESTINATION_BIT);
+
+	/* set length and CRC poly reg */
+	flags_len |= ((len & 0x7) |
+		      ((crc_reg & 0x3) << 8));
+
+	return  nlm_crc32_generic(data, flags_len, crc_init);
+}
+
+/**
+ * This macro loops on a string of data.  It is kept this way to
+ * adjust to endianess and use of 64bit instruction, so that each
+ * CRC function does not require ifdef.
+ */
+#ifdef USE_64BIT_CRC
+#define LOOP_ON_DATA(c, init, b, len, f) \
+({                                                                           \
+        uint64_t data;                                                       \
+	uint32_t i, rem = len, __ret = init, l;                              \
+	for(i = 0; rem > 0;) {                                               \
+                data = ((uint64_t *)buf)[i];                                 \
+      	        i += 8;                                                      \
+	        if(rem >= 8) {                                               \
+		        rem -= 8;                                            \
+		        l = 7;                                               \
+		} else if (rem == 7) {                                       \
+			rem -= 7;                                            \
+			l = 6;                                               \
+		} else if (rem == 6) {                                       \
+			rem -= 6;                                            \
+			l = 5;                                               \
+		} else if (rem == 5) {                                       \
+			rem -= 5;                                            \
+			l = 4;                                               \
+		} else if (rem == 4) {                                       \
+			rem -= 4;                                            \
+			l = 3;                                               \
+		} else if (rem == 3) {                                       \
+			rem -= 3;                                            \
+			l = 2;                                               \
+		} else if (rem == 2) {                                       \
+			rem -= 2;                                            \
+			l = 1;                                               \
+		} else if (rem == 1) {                                       \
+			rem -= 1;                                            \
+			l = 0;                                               \
+		}                                                            \
+		__ret = f(crc_reg, data, l, __ret);                          \
+	}                                                                    \
+        __ret;                                                               \
+})
+#else
+#define LOOP_ON_DATA(c, init, b, len, f) \
+({                                                                           \
+        uint32_t data;                                                       \
+	uint32_t i, rem = len, __ret = init, l;                              \
+	for(i = 0; rem > 0;) {                                               \
+		data = ((uint32_t *)buf)[i];                                 \
+                i += 4;                                                      \
+		if(rem >= 4) {                                               \
+			rem -= 4;                                            \
+			l = 3;                                               \
+		} else if (rem == 3) {                                       \
+			rem -= 3;                                            \
+			l = 2;                                               \
+		} else if (rem == 2) {                                       \
+			rem -= 2;                                            \
+			l = 1;                                               \
+		} else if (rem == 1) {                                       \
+			rem -= 1;                                            \
+			l = 0;                                               \
+		}                                                            \
+		__ret = f(crc_reg, data, l, __ret);                          \
+	}                                                                    \
+        __ret;                                                               \
+})
+#endif
+
+static __inline__ uint32_t
+nlm_crc32(int crc_reg, const unsigned char *buf, unsigned int len, unsigned int crc)
+{
+	return LOOP_ON_DATA(crc_reg, crc,
+			    buf, len, nlm_crc32_word) ^ 0xffffffff;
+}
+
+static __inline__ uint16_t
+nlm_crc16(int crc_reg, const unsigned char *buf, unsigned int len, unsigned short crc)
+{
+	return (uint16_t)(LOOP_ON_DATA(crc_reg, crc,
+				       buf, len, nlm_crc16_ibm) & 0xffff);
+}
+
+static __inline__ unsigned char
+nlm_crc7(int crc_reg, const unsigned char *buf, unsigned int len, unsigned char crc)
+{
+	return (unsigned char)(LOOP_ON_DATA(crc_reg, crc, buf,
+					    len, nlm_crc7_word) & 0x3f);
+}
+#if 0
+static __inline__ int num_ones(unsigned long mask)
+{
+	int  nones;
+
+	for (nones = 0; mask; mask >>= 1) {
+		if (mask & 0x1)
+			++nones;
+	}
+
+	return nones;
+}
+#endif
+static __inline__ void write_32bit_cfg_reg(uint32_t *base, unsigned int offset, uint32_t value)
+{
+  base[offset] = value;
+}
+static __inline__ uint32_t read_32bit_cfg_reg(uint32_t *base, unsigned int offset)
+{
+  return ((base)[offset]);
+}
+static __inline__ void write_64bit_cfg_reg(uint64_t *base, unsigned int offset, uint64_t value)
+{
+  base[offset] = value;
+}
+static __inline__ uint64_t read_64bit_cfg_reg(uint64_t *base, unsigned int offset)
+{
+  return ((base)[offset]);
+}
+
+static __inline__ uint32_t xlp_get_field_w(uint32_t word, int lsb, int size)
+{
+	return ((word >> lsb) & XLP_BIT_MASK_W(size));
+}
+static __inline__ uint64_t xlp_get_field_dw(uint64_t dword, int lsb, int size)
+{
+	return ((dword >> lsb) & XLP_BIT_MASK_DW(size));
+}
+
+/* Linux User Mode */
+#if defined(NLM_HAL_LINUX_USER)
+#include <nlm_uaccess.h>
+#define nlh_read_cfg_reg32(addr)       nlm_uaccess_mem_read32((NLH_XKPHYS_UNCACHED | (addr)))
+#define nlh_write_cfg_reg32(addr, val) nlm_uaccess_mem_write32((NLH_XKPHYS_UNCACHED | (addr)), (val))
+#define nlh_read_cfg_reg64(addr)       nlm_uaccess_mem_read64((NLH_XKPHYS_UNCACHED | (addr)))
+#define nlh_write_cfg_reg64(addr, val) nlm_uaccess_mem_write64((NLH_XKPHYS_UNCACHED | (addr)), (val))
+
+
+#define nlh_send_msg2(dst, code, data0, data1) \
+  nlm_uaccess_msgsnd_2(code, dst, data0, data1)
+
+#define nlh_send_msg1(dst, code, data0) \
+  nlm_uaccess_msgsnd_1(code, dst, data0)
+
+/* Returns 1 on failure and 0 on success */
+#define nlh_recv_msg2(dst, src, size, code, data0, data1)	\
+  nlm_uaccess_msgrcv_2(dst, src, size, code, data0, data1)
+
+#define nlh_recv_msg1(dst, src, size, code, data0)	\
+  nlm_uaccess_msgrcv_1(dst, src, size, code, data0)
+
+#define nlh_pop_msg2(dst, src, code, data0, data1)	\
+  nlm_pop_msg_2(dst, src, code, data0, data1);
+
+#define nlh_pop_msg1(dst, src, code, data0)\
+  nlm_pop_msg_1(dst, src, code, data0);
+
+/* NETOS and Linux Kernel Mdoe */
+#elif defined(NLM_HAL_NETOS) || defined(NLM_HAL_LINUX_KERNEL) \
+	|| defined(NLM_HAL_UBOOT) || defined(NLM_HAL_NETLBOOT)
+
+#define nlh_read_cfg_reg32(addr)       lw_40bit_phys_uncached(addr)
+#define nlh_write_cfg_reg32(addr, val) sw_40bit_phys_uncached(addr, val)
+#define nlh_read_cfg_reg64(addr)       ld_40bit_phys_uncached(addr)
+#define nlh_write_cfg_reg64(addr, val) sd_40bit_phys_uncached(addr, val)
+
+#define nlh_send_msg3(dst, code, data0, data1, data2) \
+  xlp_message_send_3(dst, code, data0, data1, data2)
+
+#define nlh_send_msg2(dst, code, data0, data1) \
+  xlp_message_send_2(dst, code, data0, data1)
+
+#define nlh_send_msg1(dst, code, data0) \
+  xlp_message_send_1(dst, code, data0)
+
+#define nlh_recv_msg2(dst, src, size, code, data0, data1) \
+  xlp_message_receive_2(dst, src, size, code, data0, data1)
+
+#define nlh_recv_msg1(dst, src, size, code, data0) \
+  xlp_message_receive_1(dst, src, size, code, data0)
+
+#define nlh_pop_msg2(dst, src, code, data0, data1) \
+  xlp_message_pop_2(dst, src, code, data0, data1)
+
+#define nlh_pop_msg1(dst, src, code, data0) \
+  xlp_message_pop_1(dst, src, code, data0)
+
+#else
+#error "Unsupported platform for NL HAL"
+
+#endif
+
+#endif /* __ASSEMBLY__ */
+
+
+#endif /* #ifndef _NLM_HAL_MACROS_H */
+
diff --git a/arch/mips/include/asm/netlogic/hal/nlm_hal_nae.h b/arch/mips/include/asm/netlogic/hal/nlm_hal_nae.h
new file mode 100644
index 0000000..8ee6c79
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/hal/nlm_hal_nae.h
@@ -0,0 +1,150 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+
+#ifndef _NLM_HAL_NAE_H_
+#define _NLM_HAL_NAE_H_
+
+#include "nlm_hal.h"
+
+#define NAE_RECV_NONE          0x00000000
+#define NAE_RECV_RX            0x00000001
+#define NAE_RECV_TXC           0x00000002
+#define NAE_RECV_UNKNOWN       0x80000000
+#define NULL_VFBID             127
+#define MAX_NAE_CONTEXTS       524
+
+struct nlm_hal_nae_port {
+	uint32_t  valid;
+	uint32_t  mgmt;
+        uint32_t  num_free_desc;
+        uint32_t  txq_range[2];
+        uint32_t  rxq;
+        uint32_t  hw_port_id;
+};
+
+struct nlm_hal_nae_config {
+	uint32_t fb_vc;
+        uint32_t rx_vc;
+	uint32_t num_ports;
+	struct nlm_hal_nae_port ports[18];
+};
+
+extern struct nlm_hal_nae_config nae_cfg;
+extern int cntx2port[];
+
+/* To access Interface specific regs in NAE block */
+#define XLP_NAE_OFFSET(iface) (xlp_nae_base | (((iface) & 0xf) << 9))
+
+/* To access individual gmac regs */
+#define XLP_MAC_OFFSET(blk, iface) \
+  (xlp_mac_base + (((blk) * XLP_NA_REG_BLOCK_SIZE)) + ((iface) * XLP_NA_REG_IFACE_SIZE))
+
+#ifndef __ASSEMBLY__
+/* To access POE regs based in PCI Memory */
+#define nlm_hal_write_poe_pcim_reg(reg, val) nlm_hal_write_32bit_reg(xlp_poe_base_pcim, (reg), (val))
+#define nlm_hal_read_poe_pcim_reg(reg)   nlm_hal_read_32bit_reg(xlp_poe_base_pcim, (reg))
+
+/* To access POE regs based in PCIE config space */
+#define nlm_hal_write_poe_pcie_reg(reg, val) nlm_hal_write_32bit_reg(xlp_poe_base_pcie, (reg), (val))
+#define nlm_hal_read_poe_pcie_reg(reg)   nlm_hal_read_32bit_reg(xlp_poe_base_pcie, (reg))
+
+#define nlm_hal_write_nae_reg(reg, val) nlm_hal_write_32bit_reg(xlp_nae_base, (reg), (val))
+#define nlm_hal_read_nae_reg(reg) nlm_hal_read_32bit_reg(xlp_nae_base, (reg))
+
+#define nlm_hal_write_nae_iface_reg(iface, reg, val) nlm_hal_write_32bit_reg(XLP_NAE_OFFSET(iface), (reg), (val))
+#define nlm_hal_read_nae_iface_reg(iface, reg) nlm_hal_read_32bit_reg(XLP_NAE_OFFSET(iface), (reg))
+
+#define nlm_hal_write_ucode(ucore, offset, val) \
+  nlh_write_cfg_reg32((xlp_mac_base + 0x10000 + (ucore * CODE_SIZE_PER_UCORE) + offset), (val))
+
+#define nlm_hal_write_mac_reg(blk, iface, reg, val) nlm_hal_write_32bit_reg(XLP_MAC_OFFSET(blk, iface), (reg), (val))
+#define nlm_hal_read_mac_reg(blk, iface, reg) nlm_hal_read_32bit_reg(XLP_MAC_OFFSET(blk, iface), (reg))
+
+#define read_gmac_reg(idx, reg) nlm_hal_read_mac_reg( (((idx) & 0xff)>>2), ((idx) & 0x3), reg)
+#define write_gmac_reg(idx, reg, val) nlm_hal_write_mac_reg( (((idx) & 0xff)>>2), ((idx) & 0x3), (reg), (val))
+
+static __inline__ uint32_t vfbid_to_dest_map(unsigned int vfbid, unsigned int dest, int cmd) {
+	return ((dest & 0x3fff) << 16) | ((vfbid & 0x7f) << 4) | (cmd & 0x1);
+}
+
+static __inline__ uint32_t ucore_spray_config(unsigned int interface, unsigned int ucore_mask, int cmd) {
+	return ((cmd & 0x1) << 31) | ((ucore_mask & 0xffff) << 8) | (interface & 0x1f);
+}
+
+static __inline__ uint32_t poe_class_config(unsigned int table_index, unsigned int poe_class, int cmd) {
+	return ((poe_class & 0xffffff) << 8) | ((cmd & 0x1) << 7) | (table_index & 0x7f);
+}
+
+static __inline__ uint32_t flow_base_mask_config(unsigned int interface, unsigned int base, unsigned int mask, int cmd) {
+	return ((base & 0xffff) << 16) | ((cmd & 0x1) << 15) | ((mask & 0x1f) << 8) | (interface & 0x1f);
+}
+
+extern int nlm_hal_init_poe_distvec(int vec, uint32_t cm0, uint32_t cm1, uint32_t cm2, uint32_t cm3, uint32_t vcmask);
+
+extern int nlm_hal_load_ucore(int ucore_mask, unsigned int *opcodes, int num_opcodes);
+
+extern int nlm_hal_init_if(int type, int  inf, uint32_t *regs, int num_regs);
+extern int nlm_hal_open_if(int type, int  inf);
+extern int nlm_hal_close_if(int type, int  inf);
+
+/* Here regs are pairs of <index, val> of interface regs */
+extern int nlm_hal_init_if_regs(int type, int  inf, uint32_t *regs, uint32_t num_regs);
+
+/* Here regs are pairs of <index, val> of NAE regs */
+extern int nlm_hal_init_nae_regs(int type, uint32_t *regs, uint32_t num_regs);
+
+/* Here regs are pairs of <index, val> of POE regs */
+extern int nlm_hal_init_poe_regs(uint32_t *regs, uint32_t num_regs);
+
+extern int nlm_hal_nae_send(int dest, int fbid, unsigned long long phys_addr, int len, unsigned int flags);
+extern int nlm_hal_nae_recv(int rx_vc, unsigned long long *phys_addr, unsigned int *flags);
+
+extern int nlm_hal_soc_recv(int dst_vc, unsigned int *intf, unsigned long long *phys_addr, unsigned int *flags);
+
+/* PHY Access routines
+ */
+enum {
+	NLM_HAL_INT_MDIO,
+	NLM_HAL_EXT_MDIO,
+};
+extern int nlm_hal_mdio_read(int type, int bus,int block, int intf_type,
+			     int phyaddr, int regidx);
+extern int nlm_hal_mdio_write(int type, int bus, int block, int intf_type, int phyaddr,
+			      int regidx, uint16_t val);
+extern int nlm_hal_mdio_reset(int type, int bus, int block, int intf_type);
+
+extern void nae_lane_reset_txpll(int block, int lane_ctrl);
+
+/*  PCS initialization
+ */
+extern void nlm_hal_sgmii_pcs_init(uint32_t sgmii_cplx_mask);
+extern void nlm_hal_xaui_pcs_init(uint32_t xaui_cplx_mask);
+
+extern void nlm_hal_sgmii_phy_init(void);
+
+extern int nlm_hal_init_nae(void *fdt, int dom_id);
+
+#endif //__ASSEMBLY__
+#endif //#ifndef _NLM_HAL_NAE_H_
diff --git a/arch/mips/include/asm/netlogic/hal/nlm_hal_pic.h b/arch/mips/include/asm/netlogic/hal/nlm_hal_pic.h
new file mode 100644
index 0000000..1da3697
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/hal/nlm_hal_pic.h
@@ -0,0 +1,379 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+
+#ifndef _NLM_HAL_PIC_H
+#define _NLM_HAL_PIC_H
+
+#include "nlm_hal.h"
+
+#define TIMER_CYCLES_MAXVAL        0xffffffffffffffffULL
+
+/*
+ *    IRT Map
+ */
+#define PIC_NUM_IRTS               160
+
+#define PIC_IRT_WD_0_INDEX         0
+#define PIC_IRT_WD_1_INDEX         1
+#define PIC_IRT_WD_NMI_0_INDEX     2
+#define PIC_IRT_WD_NMI_1_INDEX     3
+#define PIC_IRT_TIMER_0_INDEX      4
+#define PIC_IRT_TIMER_1_INDEX      5
+#define PIC_IRT_TIMER_2_INDEX      6
+#define PIC_IRT_TIMER_3_INDEX      7
+#define PIC_IRT_TIMER_4_INDEX      8
+#define PIC_IRT_TIMER_5_INDEX      9
+#define PIC_IRT_TIMER_6_INDEX      10
+#define PIC_IRT_TIMER_7_INDEX      11
+#define PIC_IRT_CLOCK_INDEX        PIC_IRT_TIMER_7_INDEX
+
+#define PIC_NUM_MSG_Q_IRTS         32
+#define PIC_IRT_MSG_Q0_INDEX       12
+#define PIC_IRT_MSG_Q_INDEX(qid)   ((qid) + PIC_IRT_MSG_Q0_INDEX) // 12 - 43
+
+#define PIC_IRT_MSG_0_INDEX        44
+#define PIC_IRT_MSG_1_INDEX        45
+
+#define PIC_NUM_PCIE_MSIX_IRTS     32
+#define PIC_IRT_PCIE_MSIX_0_INDEX  46
+#define PIC_IRT_PCIE_MSIX_INDEX(num) ((num) + PIC_IRT_PCIE_MSIX_0_INDEX) // 46 - 77
+
+#define PIC_NUM_PCIE_LINK_IRTS     4
+#define PIC_IRT_PCIE_LINK_0_INDEX  78
+#define PIC_IRT_PCIE_LINK_INDEX(num) ((num) + PIC_IRT_PCIE_LINK_0_INDEX) // 78 - 81
+
+#define PIC_NUM_NA_IRTS            32
+#define PIC_IRT_NA_0_INDEX         82
+#define PIC_IRT_NA_INDEX(num)      ((num) + PIC_IRT_NA_0_INDEX) // 82 - 113
+
+#define PIC_IRT_POE_INDEX          114
+
+#define PIC_NUM_USB_IRTS           6
+#define PIC_IRT_USB_0_INDEX        115
+#define PIC_IRT_USB_INDEX(num) ((num) + PIC_IRT_USB_0_INDEX) // 115 - 120
+
+#define PIC_IRT_GDX_INDEX          121
+#define PIC_IRT_SEC_INDEX          122
+#define PIC_IRT_RSA_INDEX          123
+
+#define PIC_NUM_COMP_IRTS          4
+#define PIC_IRT_COMP_0_INDEX       124
+#define PIC_IRT_COMP_INDEX(num)    ((num) + PIC_IRT_COMP_0_INDEX) // 124 - 127
+
+#define PIC_IRT_GBU_INDEX          128
+#define PIC_IRT_ICC_0_INDEX        129 // ICC - Inter Chip Coherency
+#define PIC_IRT_ICC_1_INDEX        130
+#define PIC_IRT_ICC_2_INDEX        131
+#define PIC_IRT_CAM_INDEX          132
+#define PIC_IRT_UART_0_INDEX       133
+#define PIC_IRT_UART_1_INDEX       134
+#define PIC_IRT_I2C_0_INDEX        135
+#define PIC_IRT_I2C_1_INDEX        136
+#define PIC_IRT_SYS_0              137
+#define PIC_IRT_SYS_1              138
+#define PIC_IRT_JTAG_INDEX         139
+#define PIC_IRT_PIC                140
+#define PIC_IRT_NBU                141
+#define PIC_IRT_TCU                142
+#define PIC_IRT_GCU                143 // GBC - Global Coherency
+#define PIC_IRT_DMC_0_INDEX        144
+#define PIC_IRT_DMC_1_INDEX        145
+
+#define PIC_NUM_GPIO_IRTS          4
+#define PIC_IRT_GPIO_0_INDEX       146
+#define PIC_IRT_GPIO_INDEX(num)    ((num) + PIC_IRT_GPIO_0_INDEX) // 146 - 149
+
+#define PIC_IRT_NOR                150
+#define PIC_IRT_NAND               151
+#define PIC_IRT_SPI                152
+#define PIC_IRT_MMC                153
+
+/*
+ *     Register Offsets
+ */
+#define PIC_CTRL             0x00
+#define PIC_BYTESWAP         0x01
+#define PIC_STATUS           0x02
+#define PIC_INT_TIMEOUT      0x03
+#define PIC_ICI0_INT_TIMEOUT 0x04
+#define PIC_ICI1_INT_TIMEOUT 0x05
+#define PIC_ICI2_INT_TIMEOUT 0x06
+#define PIC_IPI_CTL          0x07
+#define PIC_INT_ACK          0x08
+#define PIC_INT_PENDING0     0x09
+#define PIC_INT_PENDING1     0x0a
+#define PIC_INT_PENDING2     0x0b
+
+#define PIC_WD0_MAX_VAL      0x0c
+#define PIC_WD0_COUNT        0x0d
+#define PIC_WD0_MASK_0       0x0e
+#define PIC_WD0_MASK_1       0x0f
+#define PIC_WD0_HEARBEATCMD  0x10
+#define PIC_WD0_HEARBEAT_0   0x11
+#define PIC_WD0_HEARBEAT_1   0x12
+
+#define PIC_WD_MAX_VAL(id)    (PIC_WD0_MAX_VAL + ((id) ? 7 : 0))
+#define PIC_WD_COUNT(id)      (PIC_WD0_COUNT + ((id) ? 7 : 0))
+#define PIC_WD_MASK_0(id)     (PIC_WD0_MASK_0 + ((id) ? 7 : 0))
+#define PIC_WD_MASK_1(id)     (PIC_WD0_MASK_1 + ((id) ? 7 : 0))
+#define PIC_WD_HEARBEAT_0(id) (PIC_WD0_HEARTBEAT_0 + ((id) ? 7 : 0))
+#define PIC_WD_HEARBEAT_1(id) (PIC_WD0_HEARTBEAT_1 + ((id) ? 7 : 0))
+
+#define PIC_SYS_TIMER_0_MAX_VAL   0x1a
+#define PIC_SYS_TIMER_MAX_VAL(id) (PIC_SYS_TIMER_0_MAX_VAL + (id))
+
+#define PIC_SYS_TIMER_0_COUNTER   0x22
+#define PIC_SYS_TIMER_COUNTER(id) (PIC_SYS_TIMER_0_COUNTER + (id))
+
+#define PIC_TIMER_0_MAXVAL   PIC_SYS_TIMER_0_MAX_VAL
+#define PIC_TIMER_0_COUNTER  PIC_SYS_TIMER_0_COUNTER
+#define PIC_TIMER_7_MAXVAL   PIC_SYS_TIMER_MAX_VAL(7)
+#define PIC_TIMER_7_COUNTER  PIC_SYS_TIMER_COUNTER(7)
+#define PIC_TIMER_6_MAXVAL   PIC_SYS_TIMER_MAX_VAL(6)
+#define PIC_TIMER_6_COUNTER  PIC_SYS_TIMER_COUNTER(6)
+
+#define PIC_INT_THR_ENABLE_0_N01   0x2a
+#define PIC_INT_THR_ENABLE_0_N23   0x2b
+#define PIC_INT_THR_ENABLE_N01(id) (PIC_INT_THR_ENABLE_0_N01 + ((id) * 2))
+#define PIC_INT_THR_ENABLE_N23(id) (PIC_INT_THR_ENABLE_0_N23 + ((id) * 2))
+
+#define PIC_IRT_0   0x3a
+#define PIC_IRT(id) (PIC_IRT_0 + (id))
+
+#define PIC_IRT_WD_0        PIC_IRT(PIC_IRT_WD0_INDEX)
+#define PIC_IRT_WD_1        PIC_IRT(PIC_IRT_WD1_INDEX)
+#define PIC_IRT_TIMER_0     PIC_IRT(PIC_IRT_TIMER_0_INDEX)
+#define PIC_IRT_TIMER_1     PIC_IRT(PIC_IRT_TIMER_1_INDEX)
+#define PIC_IRT_TIMER_2     PIC_IRT(PIC_IRT_TIMER_2_INDEX)
+#define PIC_IRT_TIMER_3     PIC_IRT(PIC_IRT_TIMER_3_INDEX)
+#define PIC_IRT_TIMER_4     PIC_IRT(PIC_IRT_TIMER_4_INDEX)
+#define PIC_IRT_TIMER_5     PIC_IRT(PIC_IRT_TIMER_5_INDEX)
+#define PIC_IRT_TIMER_6     PIC_IRT(PIC_IRT_TIMER_6_INDEX)
+#define PIC_IRT_TIMER_7     PIC_IRT(PIC_IRT_TIMER_7_INDEX)
+#define PIC_IRT_CLOCK       PIC_IRT_TIMER_7
+#define PIC_IRT_UART_0      PIC_IRT(PIC_IRT_UART_0_INDEX)
+#define PIC_IRT_UART_1      PIC_IRT(PIC_IRT_UART_1_INDEX)
+#define PIC_IRT_I2C_0       PIC_IRT(PIC_IRT_I2C_0_INDEX)
+#define PIC_IRT_I2C_1       PIC_IRT(PIC_IRT_I2C_1_INDEX)
+
+#define PIC_CLOCK_TIMER     7
+#define PIC_IRQ_BASE        8
+
+#define ASM_XLP_IO_PIC_OFFSET        0xffffffffb8004100 /* TODO: This will change in to function */
+#define C_XLP_IO_PIC_OFFSET        0xffffffffb8004100ULL /* TODO: This will change in to function */
+
+#ifndef __ASSEMBLY__
+enum {
+	WD0 = 0,
+	WD1 = 1
+};
+extern int irt_irq_table[PIC_NUM_IRTS][4];
+extern int find_irt_from_irq(int irq_num);
+extern int nlm_hal_request_shared_irq(int irt);
+extern void nlm_hal_unrequest_shared_irq(int irt);
+extern void nlm_hal_set_irt_to_cpu(int irt,int cpu);
+extern void nlm_hal_set_irq_to_cpu(int irq,int cpu);
+
+static __inline__ int nlm_hal_irt_to_irq(int irt_num)
+{
+	if(irt_num < 0 || irt_num > PIC_NUM_IRTS)
+		return -1;
+
+	return irt_irq_table[irt_num][0];
+}
+
+static __inline__ int nlm_hal_irq_to_irt(int irq_num)
+{
+	int irt = find_irt_from_irq(irq_num);
+	return irt;
+}
+
+static __inline__ int nlm_hal_is_shared_irt(int irt_num)
+{
+	return irt_irq_table[irt_num][1];
+}
+
+#define PIC_IRT_FIRST_IRQ        (PIC_IRQ_BASE)
+#define PIC_WD_0_IRQ             nlm_hal_irt_to_irq(PIC_IRT_WD_0_INDEX)
+#define PIC_WD_1_IRQ             nlm_hal_irt_to_irq(PIC_IRT_WD_1_INDEX)
+#define PIC_TIMER_0_IRQ          nlm_hal_irt_to_irq(PIC_IRT_TIMER_0_INDEX)
+#define PIC_TIMER_1_IRQ          nlm_hal_irt_to_irq(PIC_IRT_TIMER_1_INDEX)
+#define PIC_TIMER_2_IRQ          nlm_hal_irt_to_irq(PIC_IRT_TIMER_2_INDEX)
+#define PIC_TIMER_3_IRQ          nlm_hal_irt_to_irq(PIC_IRT_TIMER_3_INDEX)
+#define PIC_TIMER_4_IRQ          nlm_hal_irt_to_irq(PIC_IRT_TIMER_4_INDEX)
+#define PIC_TIMER_5_IRQ          nlm_hal_irt_to_irq(PIC_IRT_TIMER_5_INDEX)
+#define PIC_TIMER_6_IRQ          nlm_hal_irt_to_irq(PIC_IRT_TIMER_6_INDEX)
+#define PIC_TIMER_7_IRQ          nlm_hal_irt_to_irq(PIC_IRT_TIMER_7_INDEX)
+#define PIC_CLOCK_IRQ            (PIC_TIMER_7_IRQ)
+#define PIC_UART_0_IRQ           17
+#define PIC_UART_1_IRQ           18
+#define PIC_I2C_0_IRQ            nlm_hal_irt_to_irq(PIC_IRT_I2C_0_INDEX)
+#define PIC_I2C_1_IRQ            nlm_hal_irt_to_irq(PIC_IRT_I2C_1_INDEX)
+#define PIC_GPIO_IRQ             nlm_hal_irt_to_irq(PIC_IRT_GPIO_INDEX)
+#define PIC_IRT_LAST_IRQ_        (PIC_IRQ_BASE + PIC_NUM_IRTS - 1)
+#define PIC_IRT_LAST_IRQ()       PIC_IRT_LAST_IRQ_
+
+/*
+ *   Misc
+ */
+#define IRT_VALID       	1
+#define LOCAL_SCHEDULING    1
+#define GLOBAL_SCHEDULING   0
+#define PIC_IRQ_IS_IRT(irq) ((irq >= PIC_IRT_FIRST_IRQ) && (irq <= PIC_IRT_LAST_IRQ_))
+#define PIC_IRQ_IS_EDGE_TRIGGERED(irq) 0 // XLP interrupts are level triggered
+
+/*
+ *
+ */
+
+#define NODE_OFFSET(node) ((node) << 18)
+#define CPU_TO_NODE(cpu) ((cpu) >> 5)
+
+static __inline__ int nlm_hal_cpu_id(void)
+{
+	int cpu;
+
+	__asm__ __volatile__ (
+		".set push\n"
+		".set noreorder\n"
+		".set mips32\n"
+		"mfc0 %0, $15, 1\n"
+		"andi %0, %0, 0x3ff\n"
+		".set pop\n"
+		: "=r"(cpu)
+		);
+
+	return cpu;
+}
+
+#define XLP_IO_PIC_OFFSET        C_XLP_IO_PIC_OFFSET
+
+typedef volatile unsigned long long pic_reg_t;
+
+static __inline__ pic_reg_t* nlm_hal_pic_offset(void)
+{
+	uint32_t cpu = nlm_hal_cpu_id();
+
+	return ( (pic_reg_t *) (unsigned long) (XLP_IO_PIC_OFFSET + NODE_OFFSET( CPU_TO_NODE(cpu) )) );
+}
+
+static __inline__ void nlm_hal_write_pic_reg(pic_reg_t *base, unsigned int offset, unsigned long long value)
+{
+	base[offset] = value;
+}
+static __inline__ unsigned long long nlm_hal_read_pic_reg(pic_reg_t *base, unsigned int offset)
+{
+	return ((base)[offset]);
+}
+
+static __inline__ void nlm_hal_pic_send_ipi(int nmi, int vec, int node, int cpu)
+{
+	pic_reg_t *mmio = nlm_hal_pic_offset();
+
+	unsigned long long ipi = (nmi << 31) | (vec << 20) | (node << 17) | (1 << (cpu & 0xf));
+	if (cpu > 15) {
+		ipi |= 0x10000; // Setting bit 16 to select cpus 16-31
+	}
+
+	nlm_hal_write_pic_reg(mmio, PIC_IPI_CTL, ipi);
+}
+
+static __inline__ unsigned long long nlm_hal_pic_read_control(void)
+{
+	pic_reg_t *mmio = nlm_hal_pic_offset();
+
+	return nlm_hal_read_pic_reg(mmio, PIC_CTRL);
+}
+
+static __inline__ void nlm_hal_pic_write_control(unsigned long long control)
+{
+	pic_reg_t *mmio = nlm_hal_pic_offset();
+
+	nlm_hal_write_pic_reg(mmio, PIC_CTRL, control);
+}
+
+static __inline__ void nlm_hal_pic_update_control(unsigned long long control)
+{
+	pic_reg_t *mmio = nlm_hal_pic_offset();
+
+	nlm_hal_write_pic_reg(mmio, PIC_CTRL, (control | nlm_hal_read_pic_reg(mmio, PIC_CTRL)));
+}
+
+static __inline__ void nlm_hal_ack_pic(int irt_num)
+{
+	pic_reg_t *mmio = nlm_hal_pic_offset();
+
+	nlm_hal_write_pic_reg(mmio, PIC_INT_ACK, irt_num);
+
+	/* Ack the Status register for Watchdog & System timers */
+	if (irt_num < 12) {
+		nlm_hal_write_pic_reg(mmio, PIC_STATUS, (1 << irt_num));
+	}
+}
+
+static __inline__ unsigned long long nlm_hal_pic_read_irt(int irt_num)
+{
+	pic_reg_t *mmio = nlm_hal_pic_offset();
+
+	return nlm_hal_read_pic_reg(mmio, PIC_IRT(irt_num));
+}
+
+static __inline__ void nlm_hal_pic_write_irt(int irt_num, int en, int nmi, int sch, int vec, int dt, int db, int dte)
+{
+	pic_reg_t *mmio = nlm_hal_pic_offset();
+
+	unsigned long long val = (((en & 0x1) << 31) | ((nmi & 0x1) << 29) | ((sch & 0x1) << 28) |
+				  ((vec & 0x3f) << 20) | ((dt & 0x1 ) << 19) | ((db & 0x7) << 16) |
+				  (dte & 0xffff));
+
+	nlm_hal_write_pic_reg(mmio, PIC_IRT(irt_num), val);
+}
+
+#define CPUIDBITS01(X) ((X) & 0x3)
+#define CPUIDBIT2(X) ((X >> 2) & 0x1)
+
+static __inline__ void nlm_hal_pic_write_irt_direct(int irt_num, int en, int nmi, int sch, int vec, int cpu)
+{
+	nlm_hal_pic_write_irt(irt_num, en, nmi, sch, vec, 1, CPUIDBIT2(cpu), CPUIDBITS01(cpu));
+	/* Does not support multi node support yet */
+}
+
+static __inline__ unsigned long long nlm_hal_pic_read_timer(int timer)
+{
+	pic_reg_t *mmio = nlm_hal_pic_offset();
+
+	return nlm_hal_read_pic_reg(mmio, PIC_SYS_TIMER_COUNTER(timer));
+}
+
+static __inline__ void nlm_hal_pic_write_timer(int timer, pic_reg_t value)
+{
+	pic_reg_t *mmio = nlm_hal_pic_offset();
+
+	nlm_hal_write_pic_reg(mmio, PIC_SYS_TIMER_COUNTER(timer), value);
+}
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* _NLM_HAL_PIC_H */
diff --git a/arch/mips/include/asm/netlogic/hal/nlm_hal_sae.h b/arch/mips/include/asm/netlogic/hal/nlm_hal_sae.h
new file mode 100644
index 0000000..998fbcf
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/hal/nlm_hal_sae.h
@@ -0,0 +1,133 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+
+#ifndef _NLM_HAL_SAE_H_
+#define _NLM_HAL_SAE_H_
+
+#include "nlm_hal.h"
+
+#define MAX_CIPHER_KEY_LEN		32	//1 + cipher_key 4 + auth key 16 + arsc4 state 33
+#define MAX_AUTH_KEY_LEN		128
+#define MAX_ARC4_STATE_SIZE		264
+#define NLM_CRYPTO_SIZEOF_CNTRL_DESC	(8 + MAX_CIPHER_KEY_LEN + MAX_AUTH_KEY_LEN + MAX_ARC4_STATE_SIZE)
+
+#define NLM_CRYPTO_SIZEOF_PKT_DESC(nr_frags)	(32 + (nr_frags * 2)*8 + 4 /* Designed freeback*/)
+
+struct nlm_iovec {
+	unsigned char *buf;
+	uint32_t iov_len;
+};
+
+struct nlm_crypto_cipher_init_param {
+	uint32_t cipher_alg;
+	uint32_t cipher_mode;
+	struct nlm_iovec *cipher_key;
+	uint8_t arc4_cipher_key_len;
+	uint8_t arc4_key_init;
+	unsigned char cfb_mask;
+};
+
+struct nlm_crypto_auth_init_param {
+	uint32_t auth_alg;
+	uint32_t auth_mode;
+	struct nlm_iovec *auth_key;
+	uint8_t hmac;
+};
+
+struct nlm_crypto_param {
+	uint32_t enc;
+	/*uint64_t src_phy;
+	   uint64_t dst_phy; */
+	struct nlm_iovec *src_phy;	/* 1 or more fragments of the source data */
+	struct nlm_iovec *dst_phy;
+	uint32_t src_len;
+	uint32_t cipher_len;
+	uint32_t iv_len;
+	unsigned char *iv;
+
+	uint32_t iv_offset;
+	uint32_t cipher_offset;
+	uint8_t cipher_bit_count:3;
+
+	uint8_t hash_bit_count:3;
+	uint8_t tls_proto:1;
+	uint8_t arc4_save_l3_alloc:1;
+	uint8_t arc4_save_state:1;
+	uint8_t arc4_load_state:1;
+	uint8_t hmac_external_pad_key:1;
+	uint8_t hash_clobber:1;
+	uint8_t cipher_clobber:1;
+	uint8_t hash_output_l3_alloc:1;
+	uint8_t cipher_output_l3_alloc:1;
+	uint8_t hash_source:1;
+	uint8_t send_designer_fb:1;
+
+	uint32_t auth_len;
+	uint32_t auth_offset;
+	uint32_t tag_len;
+
+	uint32_t cipher_key_len;
+	uint32_t auth_key_len;
+	uint64_t hash_dst_address_phy;
+	uint32_t nr_frags;
+
+	uint32_t designer_freeback_id;
+	uint32_t designer_freeback_len;
+	uint64_t designer_fb[4];
+};
+
+#define nlm_hal_write_sae_reg(reg, val) nlm_hal_write_32bit_reg \
+					(nlm_hal_get_dev_base \
+					(XLP_CRYPTO_NODE, XLP_CRYPTO_BUS, XLP_CRYPTO_DEVICE, XLP_CRYPTO_FUNC), \
+					 (reg), (val))
+#define nlm_hal_read_nsae_reg(reg) nlm_hal_read_32bit_reg( \
+					nlm_hal_get_dev_base \
+					(XLP_CRYPTO_NODE, XLP_CRYPTO_BUS, XLP_CRYPTO_DEVICE, XLP_CRYPTO_FUNC), \
+					 (reg))
+
+/* Should return error of Alo - Mode combo is not supported*/
+extern int nlm_hal_crypto_preprocess_request(void *cntrl_desc_mem,
+					     struct nlm_crypto_cipher_init_param
+					     *cip,
+					     struct nlm_crypto_auth_init_param
+					     *aip);
+
+/* Return error when parameter are invalid */
+extern int nlm_hal_crypto_send_request(uint32_t dst_vc, uint32_t fb_id,
+				       void *cntrl_desc_virt,
+				       uint64_t cntrl_desc_phy,
+				       void *pkt_desc_virt, uint64_t pkt_phy,
+				       struct nlm_crypto_param *cprm,
+				       uint64_t tx_id);
+
+/* Returns 64 bit transaction ID */
+uint64_t
+nlm_hal_crypto_process_response(uint32_t rx_vc, uint32_t code,
+				uint32_t src, uint64_t entry0,
+				uint64_t entry1, uint64_t * err_msg);
+
+uint64_t nlm_hal_crypto_receive_response(uint32_t rx_vc, uint64_t * err_msg);
+
+#endif				//#ifndef _NLM_HAL_SAE_H_
diff --git a/arch/mips/include/asm/netlogic/hal/nlm_hal_xlp_dev.h b/arch/mips/include/asm/netlogic/hal/nlm_hal_xlp_dev.h
new file mode 100644
index 0000000..2439e9d
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/hal/nlm_hal_xlp_dev.h
@@ -0,0 +1,966 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+
+#ifndef NLM_HAL_XLP_DEV_H
+#define NLM_HAL_XLP_DEV_H
+/*
+ * This File has all the XLP Device specific Defines
+ */
+#define XLP_PCIE_CFG_SIZE 0x1000 // 4K
+#define XLP_PCIE_DEV_BLK_SIZE 0x8000 // 4k per function  and 8 function in a dev block
+#define XLP_PCIE_BUS_BLK_SIZE (256 * XLP_PCIE_DEV_BLK_SIZE)
+
+/*
+ *    FMN
+ */
+#define XLP_STN_RX_QSIZE 256
+
+#define XLP_STNID_CPU0          0x00
+#define XLP_STNID_CPU1          0x10
+#define XLP_STNID_CPU2          0x20
+#define XLP_STNID_CPU3          0x30
+#define XLP_STNID_CPU4          0x40
+#define XLP_STNID_CPU5          0x50
+#define XLP_STNID_CPU6          0x60
+#define XLP_STNID_CPU7          0x70
+#define XLP_STNID_PCIE0         0x100
+#define XLP_STNID_PCIE1         0x102
+#define XLP_STNID_PCIE2         0x104
+#define XLP_STNID_PCIE3         0x106
+#define XLP_STNID_GDX           0x108
+#define XLP_STNID_RSA_ECC       0x110
+#define XLP_STNID_CRYPTO        0x119
+#define XLP_STNID_CMP           0x129
+#define XLP_STNID_POE           0x180
+#define XLP_STNID_NAE_TX        0x1DC
+#define XLP_STNID_NAE_RX        0x3E8
+#define XLP_STNID_INVALID       0x400
+#define XLP_MAX_TX_STNS         20
+
+#define XLP_PCIE0_VC_BASE       256 
+#define XLP_PCIE0_VC_LIMIT      257
+#define XLP_PCIE1_VC_BASE       258 
+#define XLP_PCIE1_VC_LIMIT      259
+#define XLP_PCIE2_VC_BASE       260 
+#define XLP_PCIE2_VC_LIMIT      261
+#define XLP_PCIE3_VC_BASE       262 
+#define XLP_PCIE3_VC_LIMIT      263
+#define XLP_GDX_VC_BASE         264 
+#define XLP_GDX_VC_LIMIT        267
+#define XLP_RSA_ECC_VC_BASE     272 
+#define XLP_RSA_ECC_VC_LIMIT    280
+#define XLP_CRYPTO_VC_BASE      281
+#define XLP_CRYPTO_VC_LIMIT     296
+#define XLP_CMP_VC_BASE         297
+#define XLP_CMP_VC_LIMIT        304
+#define XLP_POE_VC_BASE         384 
+#define XLP_POE_VC_LIMIT        391
+#define XLP_NET_TX_VC_BASE      476 
+#define XLP_NET_TX_VC_LIMIT     999 
+#define XLP_NET_RX_VC_BASE      1000
+#define XLP_NET_RX_VC_LIMIT     1019
+#define XLP_NET_VC_BASE         XLP_NET_TX_VC_BASE
+#define XLP_NET_VC_LIMIT        1023
+
+/*Sw Code */
+#define XLP_CODE_MAC		0
+#define XLP_CODE_SEC		1	
+#define XLP_CODE_BOOT_WAKEUP	200
+
+/*Cop2 Regs */
+#define XLP_TX_BUF_REG		$0
+#define XLP_RX_BUF_REG		$1
+#define XLP_MSG_TXSTATUS_REG	$2
+#define XLP_MSG_RXSTATUS_REG	$3
+#define XLP_MSG_STATUS1_REG	$4
+#define XLP_MSG_CONFIG_REG	$5
+#define XLP_MSG_CONFIG1_REG	$6
+
+/*sys register offset in pcie config space*/
+#define XLP_PCIE_NODE0_SYSOFFSET        0x35000
+#define XLP_PCIE_NODE1_SYSOFFSET        0x75000
+#define XLP_PCIE_NODE2_SYSOFFSET        0xB5000
+#define XLP_PCIE_NODE3_SYSOFFSET        0xF5000
+
+/* DTR related */
+#define XLP_DTR_NODE                    0x0
+#define XLP_DTR_BUS                     0x0
+#define XLP_DTR_DEVICE                  0x5
+#define XLP_DTR_FUNC                    0x0
+#define XLP_DTR_MASTER_CONTROL_REG      0x40
+#define XLP_DTR_CHANNEL_CONTROL_REG_0   0x48
+#define XLP_DTR_CHANNEL_CONTROL_REG_1   0x49
+#define XLP_DTR_CHANNEL_CONTROL_REG_2   0x4A
+#define XLP_DTR_CHANNEL_CONTROL_REG_3   0x4B
+
+/* Crypto related */
+#define XLP_CRYPTO_NODE                    0x0
+#define XLP_CRYPTO_BUS                     0x0
+#define XLP_CRYPTO_DEVICE                  0x5
+#define XLP_CRYPTO_FUNC                    0x1
+
+#ifndef __ASSEMBLY__
+/* Device Id: Bus[8:6], Dev[5:3], func[2:0] */
+enum NLH_DEV_ID {
+  NLH_BRIDGE = 0, 
+  NLH_PIC    = 4,
+  NLH_NAE    = 0x18,
+  NLH_POE    = 0x19,
+  NLH_FMN    = 0x20,
+  NLH_GDX    = 0x28,
+  NLH_SEC    = 0x29,
+  NLH_RSA    = 0x2a,
+  NLH_COMP   = 0x2b,
+  NLH_UART0  = 0x30,
+  NLH_UART1  = 0x31,
+  NLH_SYS    = 0x35,
+};
+
+enum XLP_MSG_HANDLES  {
+        XLP_MSG_HANDLE_CPU0,
+        XLP_MSG_HANDLE_CPU1,
+        XLP_MSG_HANDLE_CPU2,
+        XLP_MSG_HANDLE_CPU3,
+        XLP_MSG_HANDLE_CPU4,
+        XLP_MSG_HANDLE_CPU5,
+        XLP_MSG_HANDLE_CPU6,
+        XLP_MSG_HANDLE_CPU7,
+        XLP_MSG_HANDLE_PCIE0,
+        XLP_MSG_HANDLE_PCIE1,
+        XLP_MSG_HANDLE_PCIE2,
+        XLP_MSG_HANDLE_PCIE3,
+        XLP_MSG_HANDLE_GDX,
+        XLP_MSG_HANDLE_RSA_ECC,
+        XLP_MSG_HANDLE_CRYPTO,
+        XLP_MSG_HANDLE_CMP,
+        XLP_MSG_HANDLE_POE,
+        XLP_MSG_HANDLE_NAE_0,
+        XLP_MSG_HANDLE_INVALID,
+        XLP_MSG_HANDLE_MAX,
+};
+
+/*
+ *  NET Accelerator 
+ */
+#define XLP_NA_REG_BLOCK_SIZE 0x2000 /* 8KB */
+#define XLP_NA_REG_IFACE_SIZE 0x200 /* 512B */
+
+enum if_type {
+	UNKNOWN_IF,
+	SGMII_IF,
+	XAUI_IF,
+	INTERLAKEN_IF
+};
+
+enum net_cfg_regs {
+ RX_CONFIG                          = 0x10,
+ TX_CONFIG                          = 0x11,
+ RX_IF_BASE_CONFIG_0                = 0x12,
+ RX_IF_BASE_CONFIG_1                = 0x13,
+ RX_IF_BASE_CONFIG_2                = 0x14,
+ RX_IF_BASE_CONFIG_3                = 0x15,
+ RX_IF_BASE_CONFIG_4                = 0x16,
+ RX_IF_BASE_CONFIG_5                = 0x17,
+ RX_IF_BASE_CONFIG_6                = 0x18,
+ RX_IF_BASE_CONFIG_7                = 0x19,
+ RX_IF_BASE_CONFIG_8                = 0x1a,
+ RX_IF_BASE_CONFIG_9                = 0x1b,
+ RX_IFACE_VEC_VALID                 = 0x1c,
+ RX_IFACE_SLOT_CAL                  = 0x1d,
+ XLP_PARSER_CONFIG                  = 0x1e,
+ PARSER_SEQ_FIFO_CFG                = 0x1f,
+ FREE_IN_FIFO_CFG                   = 0x20,
+ RX_BUFFER_BASE_DEPTH_ADDR_REG      = 0x21,
+ RX_BUFFER_BASE_DEPTH_REG           = 0x22,
+ RX_UCORE_CFG                       = 0x23,
+ RX_UCORE_CAM_MASK0_CFG             = 0x24,
+ RX_UCORE_CAM_MASK1_CFG             = 0x25,
+ RX_UCORE_CAM_MASK2_CFG             = 0x26,
+ RX_UCORE_CAM_MASK3_CFG             = 0x27,
+ FREE_IN_FIFO_UNIQ_SZ_CFG           = 0x28,
+ CRC_POLY0_CFG                      = 0x2a,
+ CRC_POLY1_CFG                      = 0x2b,
+ FREE_SPILL0_MEM_CFG                = 0x2c,
+ FREE_SPILL1_MEM_CFG                = 0x2d,
+ FREE_FIFO_THRESHOLDS_CFG           = 0x87,
+ FLOW_CRC16_POLY_CFG                = 0x2f,
+ DMA_TX_CREDIT_TH                   = 0x29,
+ STG1_STG2CRDT_CMD                  = 0x30,
+ STG1_STG2CRDT_STATUS               = 0x31,
+ STG2_EHCRDT_CMD                    = 0x32,
+ STG2_EHCRDT_STATUS                 = 0x33,
+ STG2_FREECRDT_CMD                  = 0x34,
+ STG2_FREECRDT_STATUS               = 0x35,
+ STG2_STRCRDT_CMD                   = 0x36,
+ STG2_STRCRDT_STATUS                = 0x37,
+ TXFIFO_IFACE_MAP_CMD               = 0x38,
+ TXFIFO_IFACE_MAP_STATUS            = 0x39,
+ VFBID_TO_DEST_MAP_CMD              = 0x3a,
+ STG1_PMEM_PROG                     = 0x3c,
+ STG1_PMEM_STATUS                   = 0x3d,
+ STG2_PMEM_PROG                     = 0x3e,
+ STG2_PMEM_STATUS                   = 0x3f,
+ EH_PMEM_PROG                       = 0x40,
+ EH_PMEM_STATUS                     = 0x41,
+ FREE_PMEM_PROG                     = 0x42,
+ FREE_PMEM_STATUS                   = 0x43,
+ TX_DRR_ACTVLIST_CMD                = 0x44,
+ TX_DRR_ACTVLIST_STATUS             = 0x45,
+ TX_IFACE_BURSTMAX_CMD              = 0x46,
+ TX_IFACE_BURSTMAX_STATUS           = 0x47,
+ TX_IFACE_ENBL_CMD                  = 0x48,
+ TX_IFACE_ENBL_STATUS               = 0x49,
+ TX_PKTLEN_PMEM_CMD                 = 0x4a,
+ TX_PKTLEN_PMEM_STATUS              = 0x4b,
+ TX_SCHED_CTXTMAP_CMD0              = 0x4c,
+ TX_SCHED_CTXTMAP_CMD1              = 0x4d,
+ TX_SCHED_CTXTMAP_STATUS0           = 0x4e,
+ TX_SCHED_CTXTMAP_STATUS1           = 0x4f,
+ TX_PKT_PMEM_CMD0                   = 0x50,
+ TX_PKT_PMEM_CMD1                   = 0x51,
+ TX_PKT_PMEM_STATUS                 = 0x52,
+ TX_SCHED_CTRL                      = 0x53,
+ STR_PMEM_CMD                       = 0x58,
+ TX_IORCRDT_INIT                    = 0x59,
+ RX_FREE_FIFO_POP                   = 0x62,
+ FLOW_BASE_MASK_CFG                 = 0x80,
+ POE_CLASS_SETUP_CFG                = 0x81,
+ UCORE_IFACE_MASK_CFG               = 0x82,
+ FLOW_TABLE1_CFG                    = 0x84,
+ L2_TYPE_0                          = 0x210,
+ L3_CTABLE_MASK_0                   = 0x22c,
+ L3_CTABLE_0_0                      = 0x230,
+ L3_CTABLE_0_1                      = 0x231,
+ L4_CTABLE_0_0                      = 0x250,
+ L4_CTABLE_0_1                      = 0x251,
+ VFBID_TO_DEST_MAP_STATUS           = 0x380,
+};
+//
+enum if_cfg_regs {
+  MAC_CONF1 = 0,
+  MAC_CONF2 = 1,
+  NETWK_INF_CTRL_REG = 0x7f
+};
+//
+enum xaui_cfg_regs {
+	XGMAC_CTL_REG1 = 0x7f,
+	XGMAC_CTL_REG2 = 0x7e,
+	XGMAC_CTL_REG3 = 0x7d,
+	XGMAC_STATUS_REG = 0x7c,
+};
+//
+enum netior_regs {
+	NETIOR_SOFTRESET = 3,
+	NETIOR_MISC_REG1_ADDR = 0x39,
+	NETIOR_MISC_REG2_ADDR = 0x3a,
+	NETIOR_MISC_REG3_ADDR = 0x3d,
+
+};
+enum NAE_TX_TYPE {
+	P2D_NEOP = 0,
+	P2P,
+	P2D_EOP,
+	MSC
+};
+
+/* NAE Interface Definitions
+ */
+enum NAE_INTF_TYPE {    
+	GMAC_0 = 0,      
+	GMAC_1,  
+	GMAC_2,  
+	GMAC_3,  
+	XGMAC, 
+	INTERLAKEN,    
+	PHY = 0xE,      
+	LANE_CFG = 0xF, 
+};      
+
+enum NAE_BLOCK_NR {    
+	BLOCK_0 = 0,
+	BLOCK_1,
+	BLOCK_2,
+	BLOCK_3,
+	BLOCK_4,
+	BLOCK_5,
+	BLOCK_6,
+	BLOCK_7,
+};      
+
+typedef enum PHY_LANE_INTF_TYPE {
+	LANE_DISCONNECTED,      
+	LANE_GMAC,      
+	LANE_XGMAC,     
+	LANE_8ILAKEN,   
+} phy_lane_intf_t;      
+
+/*
+ *  POE
+ */
+
+enum poe_reg_type {
+	PCIE_CFG_POE_REG = 0,
+	PCIE_MEM_POE_REG = 1,
+};
+
+enum poe_cfg_reg {
+  MAX_FLOW_MSGS0 = 64, // TBI
+  MAX_MSGS_CLASS0 = 72, // TBI
+  CLASS0_SIZE = 88, // TBI
+  ERROR_MESG0 = 96, // TBI
+  LO_CNT_OOO_MSG = 104, // TBI
+  LO_CNT_INORDER_MSG = 105, // TBI 
+  LO_CNT_LOCBUF_ST = 106, // TBI
+  LO_CNT_EXTBUF_ST = 107, // TBI
+  LO_CNT_LOCBUF_ALLOC = 108, // TBI
+  LO_CNT_EXTBUF_ALLOC = 109, // TBI
+  HI_CNT_OOO_MSG = 110, // TBI
+  HI_CNT_INORDE_RMSG = 111, // TBI
+  HI_CNT_LOCBUF_ST = 112, // TBI
+  HI_CNT_EXTBUF_ST = 113, // TBI
+  HI_CNT_LOCBUF_ALLOC = 114, // TBI
+  HI_CNT_EXTBUF_ALLOC = 115, // TBI
+  MODE_ERR_FLOW_ID = 116, // TBI
+  STATS_ENABLE = 117, // TBI
+  MAX_SIZE_FLOW = 118, // TBI 
+  MAX_SIZE = 119, // TBI
+  DROP_CNT_DIST0 = 192, // TBI
+  DROP_CNT_CLASS0 = 208, // TBI
+  DROP_CNT_DIST_CLASS0 = 216, // TBI
+  DROP_CNT_CPU = 224, // TBI
+  DROP_CNT_MAX_FLOW =  225, // TBI
+  INT_VECTOR = 320, // TBI
+  POE_INT_MASK = 321, // TBI
+  FATAL_ERR_MASK = 322, // TBI
+  BIU_CONFIG = 323, // TBI
+  BIU_TIMEOUT = 324, // TBI
+  ENQUED_MSG_SENT = 336, 
+  ENQUED_MSG_CNT = 337, 
+  DIST_THRESHOLD0 = 448, // TBI
+  DIST_CLASS_DROP_ENABLE = 459, // TBI
+  DIST_VEC_DROP_ENABLE = 460, // TBI
+  DIST_DROP_TIMER = 461, // TBI
+  ERROR_LOG_WORD0 = 462, // TBI
+  ERROR_INJ_CTL = 465, // TBI
+  DIST_VEC_0_15 = 466, // TBI
+};
+
+enum POE_SW_CODE {
+	DROP_IN_NAE = 0,
+	FWD_DEST,
+	RENQ_DVEC,
+	RENQ_DEST,
+	FWD_DVEC,
+	DROP_IN_POE,
+	RENQ_DVEC_SERIAL,
+	RENQ_DEST_SERIAL
+};
+
+
+enum NLM_SAE_REG_CODE
+{
+  NLM_SAE_DEVICE_INFO_REG_0 = 0x30,
+  NLM_SAE_DEVICE_INFO_REG_1 = 0x31,
+  NLM_SAE_DEVICE_INFO_REG_2 = 0x32,
+  NLM_SAE_DEVICE_INFO_REG_3 = 0x33,
+
+  NLM_SAE_ENGINE_SELECT_REG_0 = 0x41,
+  NLM_SAE_ENGINE_SELECT_REG_1 = 0x42,
+  NLM_SAE_ENGINE_SELECT_REG_2 = 0x43,
+  NLM_SAE_ENGINE_SELECT_REG_3 = 0x44,
+  NLM_SAE_ENGINE_SELECT_REG_4 = 0x45,
+  NLM_SAE_ENGINE_SELECT_REG_5 = 0x46,
+  NLM_SAE_ENGINE_SELECT_REG_6 = 0x47,
+  NLM_SAE_ENGINE_SELECT_REG_7 = 0x48,
+
+  NLM_SAE_INGRESS_MSG_CNTR_LOW = 0x87,
+  NLM_SAE_INGRESS_MSG_CNTR_HIGH = 0x88,
+  NLM_SAE_EGRESS_MSG_CNTR_LOW = 0x89,
+  NLM_SAE_EGRESS_MSG_CNTR_HIGH = 0x8A,
+
+  NLM_SAE_NUM_CIPHER_BYTE_BASE = 0x91,
+  NLM_SAE_NUM_HASH_BYTE_BASE = 0x93,
+  NLM_SAE_NUM_VC = 0x10,
+};
+/*
+ *  UCORE
+ */
+#define MAX_NAE_UCORES 16
+#define NAE_UCORE_MASK 0xffff
+#define CODE_SIZE_PER_UCORE (4 << 10)
+#define UC_MAGIC_REG_OFFSET_TO_INDEX(offset) (((offset) - 0x8000)/4)
+#define UCORE_OUTBUF_DONE  0x8000
+#define UCORE_RX_PKT_RDY  0x8004
+#define UCORE_RX_PKT_INFO  0x8008
+#define UCORE_CAM0  0x800c
+#define UCORE_CAM1  0x8010
+#define UCORE_CAM2  0x8014
+#define UCORE_CAM3  0x8018
+#define UCORE_CAM_RES  0x801c
+#define UCORE_CSUM_INFO  0x8020
+#define UCORE_CRC_INFO  0x8024
+#define UCORE_CRC_POS  0x8028
+#define UCORE_FREE_FIFO_EMPTY  0x802c
+#define UCORE_PKT_DISTR  0x8030
+#define UCORE_MAGIC_REG_BASE UCORE_OUTBUF_DONE
+#define UCORE_MAGIC_REG_LIMIT UCORE_PKT_DISTR
+#define UCORE_MAX_MAGIC_REGS (1 + (UCORE_MAGIC_REG_LIMIT - UCORE_MAGIC_REG_BASE) / 4)
+
+#define UCORE_PKT_DISCARD 0x2
+
+/* Ucore Memory Map. To be used in Microcode based apps only */
+#define UCORE_SHARED_CAM_START 0x17000
+#define UCORE_SHARE_CAM_END    0x17bff
+#define UCORE_SHARED_MEM_START 0x18000
+#define UCORE_SHARE_MEM_END    0x1ffff
+
+/* Ucore Shared memory Map for cpu. To be used in cpu only, to access ucore shared mem */
+#define UCORE_CPU_SHARED_CAM_START 0x18000
+#define UCORE_CPU_SHARED_CAM_END   0x18bff
+#define UCORE_CPU_SHARED_MEM_START 0x10000
+#define UCORE_CPU_SHARED_MEM_END   0x17fff
+
+/* System Management PCIe config registers */
+enum sys_cfg_regs {
+    CHIP_RESET              = 0,
+    POWER_ON_RESET_CFG      = 1,
+    EFUSE_DEVICE_CFG0       = 2,
+    EFUSE_DEVICE_CFG1       = 3,
+    EFUSE_DEVICE_CFG2       = 4,
+    EFUSE_DEVICE_CFG3       = 5,
+    EFUSE_DEVICE_CFG4       = 6,
+    EFUSE_DEVICE_CFG5       = 7,
+    EFUSE_DEVICE_CFG6       = 8,
+    EFUSE_DEVICE_CFG7       = 9,
+    PLL_CTRL                = 10,
+    CPU_RESET               = 11,
+    CPU_THREAD_EN           = 12,
+    CPU_NONCOHERENT_MODE    = 13,
+    CORE_DFS_DIS_CTRL       = 14,
+    CORE_DFS_RST_CTRL       = 15,
+    CORE_DFS_BYP_CTRL       = 16,
+    CORE_DFS_PHA_CTRL       = 17,
+    CORE_DFS_DIV_INC_CTRL   = 18,
+    CORE_DFS_DIV_DEC_CTRL   = 19,
+    CORE_DFS_DIV_VALUE      = 20,
+    SYS_RESET               = 21,
+    SYS_DFS_DIS_CTRL        = 22,
+    SYS_DFS_RST_CTRL        = 23,
+    SYS_DFS_BYP_CTRL        = 24,
+    SYS_DFS_DIV_INC_CTRL    = 25,
+    SYS_DFS_DIV_DEC_CTRL    = 26,
+    SYS_DFS_DIV_VALUE0      = 27,
+    SYS_DFS_DIV_VALUE1      = 28,
+    CPU_SENSE_AMP_DLY       = 29,
+    SOC_SENSE_AMP_DLY       = 30,
+    SYS_CTRL0               = 31,
+    SYS_CTRL1               = 32,
+    TIMEOUT_BSI             = 33,
+    BYTE_SWAP               = 34,
+    VRM_VID                 = 35,
+    SYS_PWR_RAM_CMD         = 36,
+    SYS_PWR_RAM_ADDR        = 37,
+    SYS_PWR_RAM_DATA0       = 38,
+    SYS_PWR_RAM_DATA1       = 39,
+    SYS_PWR_RAM_DATA2       = 40,
+    SYS_PWR_UCODE           = 41,
+    CPU0_PWR_STATUS         = 42,
+    CPU1_PWR_STATUS         = 43,
+    CPU2_PWR_STATUS         = 44,
+    CPU3_PWR_STATUS         = 45,
+    CPU4_PWR_STATUS         = 46,
+    CPU5_PWR_STATUS         = 47,
+    CPU6_PWR_STATUS         = 48,
+    CPU7_PWR_STATUS         = 49,
+    SYS_STATUS              = 50,
+    SYS_INT_POL             = 51,
+    SYS_INT_TYPE            = 52,
+    SYS_INT_STATUS          = 53,
+    SYS_INT_EN0             = 54,
+    SYS_INT_EN1             = 55,
+    SYS_UCO_S_ECC           = 56,
+    SYS_UCO_M_ECC           = 57,
+    SYS_UCO_ADDR            = 58,
+    SYS_UCO_INST            = 59,
+    MEM_BIST0               = 60,
+    MEM_BIST1               = 61,
+    MEM_BIST2               = 62,
+    MEM_BIST3               = 63,
+    MEM_BIST4               = 64,
+    MEM_BIST5               = 65,
+    MEM_BIST6               = 66,
+    MEM_BIST7               = 67,
+    MEM_BIST8               = 68,
+    MEM_BIST9               = 69,
+    MEM_BIST10              = 70,
+    MEM_BIST11              = 71,
+    MEM_BIST12              = 72,
+    SCRATCH0                = 73,
+    SCRATCH1                = 74,
+    SCRATCH2                = 75,
+    SCRATCH3                = 76,
+};
+
+#define nlm_hal_read_sys_reg(index) \
+	nlm_hal_read_32bit_reg(xlp_sys_base + 0x100, (index))
+
+#define nlm_hal_write_sys_reg(index, val) \
+	nlm_hal_write_32bit_reg(xlp_sys_base + 0x100, (index), (val))
+
+enum {
+	PHYMODE_NONE = 0,
+	PHYMODE_HS_SGMII = 1,
+	PHYMODE_XAUI = 1,
+	PHYMODE_SGMII = 2,
+	PHYMODE_IL = 3,
+};
+
+enum {
+	LM_UNCONNECTED = 0,
+	LM_SGMII = 1,
+	LM_XAUI = 2,
+	LM_IL = 3,
+};	
+
+#define MAX_CPLX_BLOCK                  5
+#define MAX_LANE_PER_CPLX               4
+
+#define LANE_RX_CLK                     (1 << 0)
+#define LANE_TX_CLK                     (1 << 6)
+
+#define PHY_LANE_0_STATUS               0
+#define PHY_LANE_1_STATUS               1
+#define PHY_LANE_2_STATUS               2
+#define PHY_LANE_3_STATUS               3
+    #define PHY_LANE_STAT_SRCS          0x00000001
+    #define PHY_LANE_STAT_STD           0x00000010
+    #define PHY_LANE_STAT_SFEA          0x00000020
+    #define PHY_LANE_STAT_STCS          0x00000040
+    #define PHY_LANE_STAT_SPC           0x00000200
+    #define PHY_LANE_STAT_XLF           0x00000400
+    #define PHY_LANE_STAT_PCR           0x00000800
+#define PHY_LANE_0_CTRL                 4
+#define PHY_LANE_1_CTRL                 5
+#define PHY_LANE_2_CTRL                 6
+#define PHY_LANE_3_CTRL                 7
+    #define PHY_LANE_CTRL_DATA_POS      0
+    #define PHY_LANE_CTRL_ADDR_POS      8
+    #define PHY_LANE_CTRL_CMD_READ      0x00010000
+    #define PHY_LANE_CTRL_CMD_WRITE     0x00000000
+    #define PHY_LANE_CTRL_CMD_START     0x00020000
+    #define PHY_LANE_CTRL_CMD_PENDING   0x00040000
+    #define PHY_LANE_CTRL_ALL           0x00200000
+    #define PHY_LANE_CTRL_FAST_INIT     0x00400000
+    #define PHY_LANE_CTRL_REXSEL_POS    23
+    #define PHY_LANE_CTRL_PHYMODE_POS   25
+    #define PHY_LANE_CTRL_PWRDOWN       0x20000000
+    #define PHY_LANE_CTRL_RST           0x40000000
+    #define PHY_LANE_CTRL_RST_XAUI      0xc0000000
+    #define PHY_LANE_CTRL_BPC_XAUI      0x80000000
+#define LANE_CFG_CPLX_0_1               0x0
+#define LANE_CFG_CPLX_2_3               0x1
+#define LANE_CFG_CPLX_4                 0x2
+    #define LANE_CFG_DISCONNECT         0
+    #define LANE_CFG_GMAC               1
+    #define LANE_CFG_XGMAC              2
+    #define LANE_CFG_8ILAKEN            3
+#define NET_INTF_SOFT_RST               0x3
+
+#define INT_MDIO_CTRL                   0x19
+    #define INT_MDIO_CTRL_ST_POS        0
+    #define INT_MDIO_CTRL_OP_POS        2
+    #define INT_MDIO_CTRL_PHYADDR_POS   4
+    #define INT_MDIO_CTRL_DEVTYPE_POS   9
+    #define INT_MDIO_CTRL_TA_POS        14
+    #define INT_MDIO_CTRL_MIIM_POS      16
+    #define INT_MDIO_CTRL_LOAD_POS      19
+    #define INT_MDIO_CTRL_XDIV_POS      21
+    #define INT_MDIO_CTRL_MCDIV_POS     28
+    #define INT_MDIO_CTRL_RST           0x40000000
+    #define INT_MDIO_CTRL_SMP           0x00100000
+    #define INT_MDIO_CTRL_CMD_LOAD      0x00080000
+#define INT_MDIO_CTRL_DATA              0x1A
+#define INT_MDIO_RD_STAT                0x1B
+    #define INT_MDIO_RD_STAT_MASK       0x0000FFFF
+    #define INT_MDIO_STAT_LFV           0x00010000
+    #define INT_MDIO_STAT_SC            0x00020000
+    #define INT_MDIO_STAT_SM            0x00040000
+    #define INT_MDIO_STAT_MIILFS        0x00080000
+    #define INT_MDIO_STAT_MBSY          0x00100000
+#define INT_MDIO_LINK_STAT              0x1C
+
+#define EXT_XG0_MDIO_CTRL               0x25
+#define EXT_XG1_MDIO_CTRL               0x29
+    #define EXT_XG_MDIO_CTRL_ST		0
+    #define EXT_XG_MDIO_CTRL_OP_POS     2
+#define MDIO_CTRL_OP_INDIRECT_ADDR      0x00
+#define MDIO_CTRL_OP_WRITE_10G_MMD      0x01
+#define MDIO_CTRL_OP_READ_10G_MMD       0x02
+#define MDIO_CTRL_OP_POST_RDINC_ADDR    0x03
+
+    #define EXT_XG_MDIO_CTRL_PHYADDR_POS	4
+    #define EXT_XG_MDIO_CTRL_REG_POS		9
+    #define EXT_XG_MDIO_CTRL_TA    	0x02 
+    #define EXT_XG_MDIO_CTRL_TA_POS     14
+    #define EXT_XG_MDIO_CTRL_MIIM_POS   16
+    #define EXT_XG_MDIO_CTRL_LOAD_POS   19
+    #define EXT_XG_MDIO_CTRL_XDIV_POS   21
+    #define EXT_XG_MDIO_CTRL_MCDIV_POS  28
+    #define EXT_XG_MDIO_CTRL_RST        0x40000000
+    #define EXT_XG_MDIO_CTRL_SMP        0x00100000
+    #define EXT_XG_MDIO_CTRL_CMD_LOAD   0x00080000
+    #define MDIO_MIIM_CMD_IDLE		0x000
+    #define MDIO_MIIM_CMD_WRITE		0x001
+    #define MDIO_MIIM_CMD_READ		0x002
+    #define MDIO_MIIM_CMD_SM		0x003
+    #define MDIO_MIIM_CMD_MM		0x004
+    #define MDIO_MIIM_CMD_10G_MMD	0x005
+    #define MDIO_MIIM_CMD_CLEAR_LINK	0x006
+
+#define EXT_G0_MDIO_CTRL                0x1D
+#define EXT_G1_MDIO_CTRL                0x21
+    #define EXT_G_MDIO_CLOCK_DIV_4      0
+    #define EXT_G_MDIO_CLOCK_DIV_2      1
+    #define EXT_G_MDIO_CLOCK_DIV_1      2
+    #define EXT_G_MDIO_REGADDR_POS      5
+    #define EXT_G_MDIO_PHYADDR_POS      10
+    #define EXT_G_MDIO_CMD_SP           0x00008000
+    #define EXT_G_MDIO_CMD_PSIA 		0x00010000
+    #define EXT_G_MDIO_CMD_LCD          0x00020000
+    #define EXT_G_MDIO_CMD_RDS          0x00040000
+    #define EXT_G_MDIO_CMD_SC           0x00080000
+    #define EXT_G_MDIO_MMRST            0x00100000
+
+#define EXT_G0_MDIO_CTRL_DATA           0x1E
+#define EXT_G1_MDIO_CTRL_DATA           0x22
+
+#define EXT_G0_MDIO_LINK_STAT           0x20
+#define EXT_G1_MDIO_LINK_STAT           0x24
+
+#define EXT_G0_MDIO_RD_STAT             0x1F
+#define EXT_G1_MDIO_RD_STAT             0x23
+    #define EXT_G_MDIO_RD_STAT_MASK     0x0000FFFF
+    #define EXT_G_MDIO_STAT_LFV         0x00010000
+    #define EXT_G_MDIO_STAT_SC          0x00020000
+    #define EXT_G_MDIO_STAT_SM          0x00040000
+    #define EXT_G_MDIO_STAT_MIILFS      0x00080000
+    #define EXT_G_MDIO_STAT_MBSY        0x80000000
+    #define MDIO_OP_CMD_READ            0x10
+    #define MDIO_OP_CMD_WRITE           0x01
+
+#define EXT_XG0_MDIO_CTRL               0x25
+#define EXT_XG1_MDIO_CTRL               0x29
+    #define EXT_XG_MDIO_CTRL_ST_POS     0
+    #define EXT_XG_MDIO_CTRL_OP_POS     2
+    #define EXT_XG_MDIO_CTRL_PHYADDR_POS        4
+    #define EXT_XG_MDIO_CTRL_DEVTYPE_POS        9
+    #define EXT_XG_MDIO_CTRL_TA_POS     14
+    #define EXT_XG_MDIO_CTRL_MIIM_POS   16
+    #define EXT_XG_MDIO_CTRL_LOAD_POS   19
+    #define EXT_XG_MDIO_CTRL_XDIV_POS   21
+    #define EXT_XG_MDIO_CTRL_MCDIV_POS  28
+    #define EXT_XG_MDIO_CTRL_RST        0x40000000
+    #define EXT_XG_MDIO_CTRL_SMP        0x00100000
+    #define EXT_XG_MDIO_CTRL_CMD_LOAD   0x00080000
+
+#define EXT_XG0_MDIO_CTRL_DATA          0x26
+#define EXT_XG1_MDIO_CTRL_DATA          0x2A
+
+#define EXT_XG0_MDIO_LINK_STAT          0x28
+#define EXT_XG1_MDIO_LINK_STAT          0x2C
+
+#define EXT_XG0_MDIO_RD_STAT            0x27
+#define EXT_XG1_MDIO_RD_STAT            0x2B
+    #define EXT_XG_MDIO_RD_STAT_MASK    0x0000FFFF
+    #define EXT_XG_MDIO_STAT_LFV        0x00010000
+    #define EXT_XG_MDIO_STAT_SC         0x00020000
+    #define EXT_XG_MDIO_STAT_SM         0x00040000
+    #define EXT_XG_MDIO_STAT_MIILFS     0x00080000
+    #define EXT_XG_MDIO_STAT_MBSY       0x00100000
+
+#define GMAC_FC_SLOT0                   0x2D
+#define GMAC_FC_SLOT1                   0x2E
+#define GMAC_FC_SLOT2                   0x2F
+#define GMAC_FC_SLOT3                   0x30
+
+#define XAUI_LANE_FAULT                 0x400
+#define XAUI_CONFIG_0                   0
+    #define XAUI_CONFIG_MACRST          0x80000000
+    #define XAUI_CONFIG_RSTRCTL         0x00400000
+    #define XAUI_CONFIG_RSTRFN          0x00200000
+    #define XAUI_CONFIG_RSTTCTL         0x00040000
+    #define XAUI_CONFIG_RSTTFN          0x00020000
+    #define XAUI_CONFIG_RSTMIIM         0x00010000
+
+#define XAUI_CONFIG_1                   1
+    #define XAUI_CONFIG_TCTLEN          0x80000000
+    #define XAUI_CONFIG_TFEN            0x40000000
+    #define XAUI_CONFIG_RCTLEN          0x20000000
+    #define XAUI_CONFIG_RFEN            0x10000000
+    #define XAUI_CONFIG_DRPLT64         0x00000020
+    #define XAUI_CONFIG_LENCHK          0x00000008
+    #define XAUI_CONFIG_GENFCS          0x00000004
+    #define XAUI_CONFIG_PAD_0           0x00000000
+    #define XAUI_CONFIG_PAD_64          0x00000001
+    #define XAUI_CONFIG_PAD_COND        0x00000002
+    #define XAUI_CONFIG_PAD_68          0x00000003
+
+#define XAUI_CONFIG_2                   2
+
+#define XAUI_CONFIG_3                   3
+
+#define XAUI_MAX_FRAME_LEN              8
+#define XAUI_PHY_CTRL_1                 0x00
+    #define XAUI_PHY_RST                0x8000
+    #define XAUI_PHY_LOOPBACK           0x4000
+    #define XAUI_PHY_SPSEL1             0x2000
+    #define XAUI_PHY_LOW_POWER          0x0800
+    #define XAUI_PHY_SPSEL0             0x0040
+    #define XAUI_PHY_10G                0x0000
+
+#define XAUI_PHY_STAT_1                 0x01
+    #define XAUI_PHY_FAULT_DP           0x0008
+    #define XAUI_PHY_LINK_UP            0x0004
+    #define XAUI_PHY_LOWPOWER           0x0002
+
+#define XAUI_PHY_SPEED_CAP              0x04
+    #define XAUI_PHY_10G_CAP            0x0001
+
+#define XAUI_PHY_DEV_PRESENT            0x05
+    #define XAUI_PHY_DTE_XS_DP          0x0020
+    #define XAUI_PHY_XS_DP              0x0010
+    #define XAUI_PHY_PCS_DP             0x0008
+    #define XAUI_PHY_WIS_DP             0x0004
+    #define XAUI_PHY_PMD_PMA_DP         0x0002
+    #define XAUI_PHY_CL22_DP            0x0001
+
+#define XAUI_PHY_STAT_2                 0x08
+    #define XAUI_PHY_STAT2_DP           0x2000
+    #define XAUI_PHY_TXF                0x0800
+    #define XAUI_PHY_RXF                0x0400
+#define XAUI_LANE_STAT                  0x18
+    #define XAUI_LANE_ALIGNED           0x1000
+    #define XAUI_LANE_PTE_EN            0x0800
+    #define XAUI_LANE_LOOPBACK_EN       0x0400
+    #define XAUI_LANE_PTE_EN            0x0800
+    #define XAUI_LANE_PTE_EN            0x0800
+    #define XAUI_LANE_PTE_EN            0x0800
+    #define XAUI_LANE_L3S               0x0008
+    #define XAUI_LANE_L2S               0x0004
+    #define XAUI_LANE_L1S               0x0002
+    #define XAUI_LANE_L0S               0x0001
+
+#define XAUI_PHY_TEST_CTRL              0x19
+    #define XAUI_PHY_TEST_PATTERN_EN    0x04
+    #define XAUI_PHY_TEST_HI_FREQ       0x00
+    #define XAUI_PHY_TEST_LOW_FREQ      0x01
+    #define XAUI_PHY_TEST_MIXED_FREQ    0x02
+
+
+#define NETIOR_XGMAC_CTRL1              0x7F
+    #define NETIOR_XGMAC_VLAN_DC_POS    28
+    #define NETIOR_XGMAC_PHYADDR_POS    23
+    #define NETIOR_XGMAC_DEVID_POS      18
+    #define NETIOR_XGMAC_STATS_EN_POS   17
+    #define NETIOR_XGMAC_TX_PFC_EN_POS  14
+    #define NETIOR_XGMAC_SOFT_RST_POS   11
+    #define NETIOR_XGMAC_TX_PAUSE_POS   10
+
+#define NETIOR_XGMAC_CTRL3		0x7D
+
+#define XLP_SPI_CONFIG			0x40
+    #define XLP_SPI_CPHA		0x01
+    #define XLP_SPI_CPOL		0x02
+    #define XLP_SPI_MODE_MASK		0x03
+    #define XLP_SPI_CS_POL_HI		0x04
+    #define XLP_SPI_TXMISO_EN		0x08
+    #define XLP_SPI_TXMOSI_EN		0x10
+    #define XLP_SPI_RXMISO_EN		0x20
+    #define XLP_SPI_SB_EN		0x40
+    #define XLP_SPI_SBPOL		0x80
+    #define XLP_SPI_LSBF_EN		0x0400
+    #define XLP_SPI_RXCAP_EV		0x0800
+#define XLP_SPI_FDIV			0x41
+#define XLP_SPI_CMD			0x42
+    #define XLP_SPI_CMD_MASK		0xF
+    #define XLP_SPI_CMD_IDLE            0x0000
+    #define XLP_SPI_CMD_TX              0x0001
+    #define XLP_SPI_CMD_RX              0x0002
+    #define XLP_SPI_CMD_TXRX            0x0003
+    #define XLP_SPI_CMD_CONT		0x10
+    #define XLP_SPI_XFR_BITCNT_POS	16
+
+#define XLP_SPI_STATUS			0x43
+    #define XLP_SPI_XFR_PENDING		0x01
+    #define XLP_SPI_XFR_DONE		0x02
+    #define XLP_SPI_TX_OV_TH		0x04
+    #define XLP_SPI_RX_OV_TH		0x08
+    #define XLP_SPI_TX_UF		0x10
+    #define XLP_SPI_TX_OF		0x20
+#define XLP_SPI_INTEN			0x44
+    #define XLP_SPI_INT_XFR_DONE	0x01
+    #define XLP_SPI_INT_TX_THRESH	0x02
+    #define XLP_SPI_INT_RX_THRESH	0x04
+    #define XLP_SPI_INT_TX_UF		0x08
+    #define XLP_SPI_INT_RX_OF		0x10
+
+#define XLP_SPI_FIFO_THRESH		0x45
+    #define XLP_SPI_TXFIFO_THRESH_POS	4
+    #define XLP_SPI_RXFIFO_THRESH_POS	0
+
+#define XLP_SPI_FIFO_WCNT		0x46
+    #define XLP_SPI_TXFIFO_WCNT_POS	4
+    #define XLP_SPI_RXFIFO_WCNT_POS	0
+#define XLP_SPI_TXDATA_FIFO		0x47
+#define XLP_SPI_RXDATA_FIFO		0x48
+
+#define XLP_SPI_SYSCTRL			0x80
+    #define XLP_SPI_SYS_RESET		0x01
+    #define XLP_SPI_SYS_CLKDIS		0x0010
+    #define XLP_SPI_SYS_PMEN		0x0100
+
+
+#define XLP_I2C_CFG0			0x40
+    #define XLP_I2C_EN			0x00800000
+    #define XLP_I2C_INT_EN		0x00400000
+    #define XLP_I2C_DATA_POS 		24
+    #define XLP_I2C_XFER_POS		24
+    #define XLP_I2C_CLK_HI		8
+    #define XLP_I2C_CLK_LW		0
+
+#define XLP_I2C_STAT			0x41
+    #define XLP_I2C_STAT_IF 		0x01
+    #define XLP_I2C_RX_TIP		0x02
+    #define XLP_I2C_RX_TIP_BSY		(1 << 1)
+    #define XLP_I2C_RX_TIP_DONE		(0 << 1)
+    #define XLP_I2C_RX_NACK		(1 << 3)
+    #define XLP_I2C_RX_ACK		(0 << 3)
+    #define XLP_I2C_TX_SLVWR		0x10
+    #define XLP_I2C_TX_SLVRD		0x20
+    #define XLP_I2C_RX_BUS_STAT 	0x40
+    #define XLP_I2C_RX_BUS_BSY		(1 << 6)
+    #define XLP_I2C_RX_BUS_DONE		(0 << 6)
+    #define XLP_I2C_TX_STO		0x40
+    #define XLP_I2C_TX_STA		0x80
+
+#define XLP_USB_PCIE_MBAR		0x4
+#define XLP_USB_PCIE_MBAR1		0x5
+
+#define XLP_USB_PCI0			0x40
+#define XLP_USB_CTL0            	0x41
+    #define USBCONTROLLERRESET  	0x01
+    #define USBEHCI64BITEN		0x02
+    #define USBOHCISTARTCLK		0x04
+
+#define XLP_USB_CTL1            	0x42
+#define XLP_USB_CTL2            	0x43
+#define XLP_USB_CTL3            	0x44
+#define XLP_USB_CTL4            	0x45
+#define XLP_USB_CTL5            	0x46
+#define XLP_USB_CTL6            	0x47
+#define XLP_USB_CTL7            	0x48
+
+#define XLP_USB_BYTESWAP    		0x49
+
+#define XLP_USB_PHY0            	0x4A
+#define XLP_USB_PHY1            	0x4B
+#define XLP_USB_PHY2            	0x4C
+    #define USBPHYRESET         	0x01
+    #define USBVBUSDETECT		0x02
+    #define USBREFCLK_12MHZ		0x00
+    #define USBREFCLK_24MHZ     	0x04
+    #define USBREFCLK_48MHZ     	0x08
+    #define USBPHYPORTRESET0    	0x10
+    #define USBPHYPORTRESET1    	0x20
+
+#define XLP_USB_STATUS0         	0x4D
+#define XLP_USB_INT_STATUS0     	0x4E
+#define XLP_USB_INT_EN          	0x4F
+    #define USB_PHY_INTERRUPT_EN    	0x01
+    #define USB_OHCI_INTERRUPT_EN   	0x02
+    #define USB_OHCI_INTERRUPT1_EN  	0x04
+    #define USB_OHCI_INTERRUPT12_EN 	0x08
+    #define USB_CTRL_INTERRUPT_EN   	0x10
+
+#define XLP_NOR_IRQ			20
+#define XLP_NAND_IRQ			21
+#define XLP_SPI_IRQ			22
+#define XLP_MMC_IRQ	                23
+#define XLP_USB_EHCI_IRQ                24
+#define XLP_USB_OHCI_IRQ                25
+#define XLP_USB_IRT0			115
+#define XLP_NOR_IRT			150
+#define XLP_NAND_IRT			151
+#define XLP_SPI_IRT			152
+#define XLP_MMC_IRT			153
+
+#define XLP_PCIE_SPI_NOR_FLASH_DEV	7
+#define XLP_PCIE_SPI_NOR		0
+#define XLP_PCIE_SPI_NAND		1
+#define XLP_PCIE_SPI_CTRL		2
+#define XLP_PCIE_SPI_SD			3
+
+#define XLP_PCIE_GIO_DEV		6
+#define XLP_PCIE_USB_DEV		2
+#define XLP_PCIE_USB_FUNC_0		0
+#define XLP_PCIE_USB_FUNC_1		1
+#define XLP_PCIE_USB_FUNC_2		2
+#define XLP_PCIE_USB_FUNC_3		3
+#define XLP_PCIE_USB_FUNC_4		4
+#define XLP_PCIE_USB_FUNC_5		5
+
+
+#define XLP_GIO_UART0_FUNC		0
+#define XLP_GIO_UART1_FUNC		1
+#define XLP_GIO_I2C0_FUNC		2
+#define XLP_GIO_I2C1_FUNC		3
+#define XLP_GIO_GPIO_FUNC		4
+
+#define XLP_GPIO_OUTPUT_EN0		0x40	/* GPIO 31:0    */
+#define XLP_GPIO_OUTPUT_EN1		0x41	/* GPIO 40:32   */
+#define XLP_GPIO_OUTPUT0		0x42	/* outpin 31:0  */
+#define XLP_GPIO_OUTPUT1		0x43	/* outpin 40:32 */
+#define XLP_GPIO_INPUT0			0x44	/* input 31:0   */
+#define XLP_GPIO_INPUT1			0x45	/* input 40:32  */
+#define XLP_GPIO_INTEN00		0x46	/* irt 146 31:0  */
+#define XLP_GPIO_INTEN01		0x47	/* irt 146 40:32  */
+#define XLP_GPIO_INTEN10		0x48	/* irt 147 31:0  */
+#define XLP_GPIO_INTEN11		0x49	/* irt 147 40:32  */
+#define XLP_GPIO_INTEN20		0x4A	/* irt 148 31:0  */
+#define XLP_GPIO_INTEN21		0x4B	/* irt 148 40:32  */
+#define XLP_GPIO_INTEN30		0x4C	/* irt 149 31:0  */
+#define XLP_GPIO_INTEN31		0x4D	/* irt 149 40:32  */
+#define XLP_GPIO_INT_POLAR0		0x4E	/* int polarity	31:0   */
+#define XLP_GPIO_INT_POLAR1		0x4F	/* int polarity	40:32  */
+#define XLP_GPIO_INT_TYPE0		0x50	/* int level type 31:0   */
+#define XLP_GPIO_INT_TYPE1		0x51	/* int level type 40:32  */
+#define XLP_GPIO_INT_STAT0		0x52	/* int status 31:0   */
+#define XLP_GPIO_INT_STAT1		0x53	/* int status 40:32  */
+#define XLP_GPIO_INT0_IRT       	146
+#define XLP_GPIO_INT1_IRT       	147
+#define XLP_GPIO_INT2_IRT       	148
+#define XLP_GPIO_INT3_IRT       	149
+#endif /*__ASSEMBLY__*/
+#endif /* #ifndef NLM_HAL_XLP_DEV_H */
diff --git a/arch/mips/include/asm/netlogic/interrupt.h b/arch/mips/include/asm/netlogic/interrupt.h
new file mode 100644
index 0000000..2647c16
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/interrupt.h
@@ -0,0 +1,48 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+
+#ifndef _ASM_NLM_INTERRUPT_H
+#define _ASM_NLM_INTERRUPT_H
+
+#include <asm/netlogic/pic.h>
+
+/* Defines for the IRQ numbers */
+
+#define IRQ_MSGRING              6
+#define IRQ_IPI_SMP_FUNCTION     3
+#define IRQ_IPI_SMP_RESCHEDULE   4
+#define IRQ_REMOTE_DEBUG         5
+//#define IRQ_OPROFILE             6
+#define IRQ_TIMER                7
+#define IRQ_IPI_SMP_KGDB   		50
+#define IRQ_IPI_OPROFILE        51
+
+#define IRQ_IPI_CRF_MGMT_IPI	NLM_MANAGEMENT_IPI /* */
+#define IRQ_IPI_CRF_EVENTQ_IPI  NLM_EVENTQ_IPI
+
+#define SMP_CALL_KGDB_HOOK 	8
+#define SMP_OPROFILE_IPI        16
+
+#endif
diff --git a/arch/mips/include/asm/netlogic/io.h b/arch/mips/include/asm/netlogic/io.h
new file mode 100644
index 0000000..e1d5005
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/io.h
@@ -0,0 +1,48 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+
+#ifndef _ASM_NLM_IO_H
+#define _ASM_NLM_IO_H
+
+extern void __iomem *pci_iomap(struct pci_dev *dev, int bar, unsigned long max);
+extern void pci_iounmap(struct pci_dev *dev, void __iomem *);
+
+#define __raw_writeb(v,a)       (*(volatile unsigned char  *)(a) = (v))
+#define __raw_writew(v,a)       (*(volatile unsigned short *)(a) = (v))
+#define __raw_writel(v,a)       (*(volatile unsigned int   *)(a) = (v))
+
+#define __raw_readb(a)          (*(volatile unsigned char  *)(a))
+#define __raw_readw(a)          (*(volatile unsigned short *)(a))
+#define __raw_readl(a)          (*(volatile unsigned int   *)(a))
+
+#define ioread8(p)  ({ unsigned int __v = __raw_readb(p); __v; })
+#define ioread16(p) ({ unsigned int __v = le16_to_cpu(__raw_readw(p)); __v; })
+#define ioread32(p) ({ unsigned int __v = le32_to_cpu(__raw_readl(p)); __v; })
+
+#define iowrite8(v,p)   __raw_writeb(v, p)
+#define iowrite16(v,p)  __raw_writew(cpu_to_le16(v), p)
+#define iowrite32(v,p)  __raw_writel(cpu_to_le32(v), p)
+
+#endif
diff --git a/arch/mips/include/asm/netlogic/iomap.h b/arch/mips/include/asm/netlogic/iomap.h
new file mode 100644
index 0000000..e67019f
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/iomap.h
@@ -0,0 +1,297 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+
+#ifndef _ASM_RFI_IO_H
+#define _ASM_RFI_IO_H
+
+#define DEFAULT_NETLOGIC_IO_BASE 0xffffffffb8000000ULL
+#define NETLOGIC_IO_DDR2_CHN0_OFFSET       0x14000
+#define NETLOGIC_IO_DDR2_CHN1_OFFSET       0x15000
+#define NETLOGIC_IO_DDR2_CHN2_OFFSET       0x16000
+#define NETLOGIC_IO_DDR2_CHN3_OFFSET       0x17000
+#define NETLOGIC_IO_PIC_OFFSET             0x04000
+#define NETLOGIC_IO_UART_0_OFFSET          0x30100
+#define NETLOGIC_IO_UART_1_OFFSET          0x31100
+#define NETLOGIC_IO_SYS_OFFSET             0x35100
+
+#define NETLOGIC_IO_SIZE                   0x1000
+
+#define NETLOGIC_IO_BRIDGE_OFFSET          0x00000
+
+#define NETLOGIC_IO_RLD2_CHN0_OFFSET       0x05000
+#define NETLOGIC_IO_RLD2_CHN1_OFFSET       0x06000
+
+#define NETLOGIC_IO_SRAM_OFFSET            0x07000
+
+#define NETLOGIC_IO_PCIX_OFFSET            0x09000
+#define NETLOGIC_IO_HT_OFFSET              0x0A000
+
+#define NETLOGIC_IO_SECURITY_OFFSET        0x0B000
+
+#define NETLOGIC_IO_GMAC_0_OFFSET          0x0C000
+#define NETLOGIC_IO_GMAC_1_OFFSET          0x0D000
+#define NETLOGIC_IO_GMAC_2_OFFSET          0x0E000
+#define NETLOGIC_IO_GMAC_3_OFFSET          0x0F000
+
+#define NETLOGIC_IO_GMAC_4_OFFSET          0x20000
+#define NETLOGIC_IO_GMAC_5_OFFSET          0x21000
+#define NETLOGIC_IO_GMAC_6_OFFSET          0x22000
+#define NETLOGIC_IO_GMAC_7_OFFSET          0x23000
+
+#define NETLOGIC_IO_PCIE_0_OFFSET          0x1E000
+#define NETLOGIC_IO_PCIE_1_OFFSET          0x1F000
+#define NETLOGIC_IO_SRIO_0_OFFSET          0x1E000
+#define NETLOGIC_IO_SRIO_1_OFFSET          0x1F000
+
+#define NETLOGIC_IO_USB_0_OFFSET           0x24000
+#define NETLOGIC_IO_USB_1_OFFSET           0x25000
+
+#define NETLOGIC_IO_COMP_OFFSET            0x1D000
+
+#define NETLOGIC_IO_SPI4_0_OFFSET          0x10000
+#define NETLOGIC_IO_XGMAC_0_OFFSET         0x11000
+#define NETLOGIC_IO_SPI4_1_OFFSET          0x12000
+#define NETLOGIC_IO_XGMAC_1_OFFSET         0x13000
+
+#define NETLOGIC_IO_I2C_0_OFFSET           0x16000
+#define NETLOGIC_IO_I2C_1_OFFSET           0x17000
+
+#define NETLOGIC_IO_GPIO_OFFSET            0x18000
+
+#define NETLOGIC_IO_FLASH_OFFSET           0x19000
+
+#define NETLOGIC_IO_TB_OFFSET           	  0x1C000
+
+#define NETLOGIC_CPLD_OFFSET               0xffffffffbd840000ULL
+
+/* Base Address (Virtual) of the PCI Config address space
+ * For now, choose 256M phys in kseg1 = 0xA0000000 + (1<<28)
+ * Config space spans 256 (num of buses) * 256 (num functions) * 256 bytes
+ * ie 1<<24 = 16M
+ */ 
+#define DEFAULT_PCI_CONFIG_BASE         0x18000000
+#define DEFAULT_HT_TYPE0_CFG_BASE       0x16000000
+#define DEFAULT_HT_TYPE1_CFG_BASE       0x17000000
+
+#ifndef __ASSEMBLY__
+
+#include <linux/types.h>
+#include <asm/byteorder.h>
+
+typedef volatile __u32 nlm_reg_t;
+extern unsigned long netlogic_io_base;
+
+#define netlogic_io_mmio(offset) ((nlm_reg_t *)(netlogic_io_base+(offset)))
+
+/* XLP_MERGE_TODO */
+#if defined(NLM_BRIDGE_WKAROUND)
+#include "nlm_rw_lock.h"
+extern nlm_rwlock_t *nlm_bridge_lock;
+extern int nlm_enable_br_wrkaround;
+
+static inline void nlm_preempt_enable(void)
+{
+    uint32_t status=0;
+    __asm__ volatile(
+#ifdef CONFIG_64BIT
+            "lw %0, 36($28)\n"
+#else
+            "lw %0, 20($28)\n"
+#endif
+            "addiu %0, %0, -1 \n"
+#ifdef CONFIG_64BIT
+            "sw %0, 36($28) \n"
+#else
+            "sw %0, 20($28) \n"
+#endif
+            :"=r"(status)
+            );    
+}
+
+static inline void nlm_preempt_disable(void)
+{
+    uint32_t status=0;
+    __asm__ volatile(
+#ifdef CONFIG_64BIT
+            "lw %0, 36($28)\n"
+#else
+            "lw %0, 20($28)\n"
+#endif
+            "addiu %0, %0, 1 \n"
+#ifdef CONFIG_64BIT
+            "sw %0, 36($28) \n"
+#else
+            "sw %0, 20($28) \n"
+#endif
+            :"=r"(status)
+            );    
+}
+
+static inline uint32_t nlm_br_read_lock(void)
+{
+    uint32_t ret = 0;
+	if(nlm_enable_br_wrkaround){
+         nlm_preempt_disable();
+		 ret = nlm_read_lock_irq_save(nlm_bridge_lock);
+         nlm_preempt_enable();
+    }
+	return ret;
+}
+static inline void nlm_br_read_unlock(unsigned int flags)
+{
+	if(nlm_enable_br_wrkaround){
+        nlm_preempt_disable();
+		nlm_read_unlock_irq_restore(nlm_bridge_lock, flags);
+        nlm_preempt_enable();
+    }
+}
+
+static inline uint32_t nlm_br_write_lock(void)
+{
+    uint32_t ret = 0;
+	if(nlm_enable_br_wrkaround){
+        nlm_preempt_disable();
+		ret = nlm_write_lock_irq_save(nlm_bridge_lock);
+        nlm_preempt_enable();
+    }
+	return ret;
+}
+
+static inline void nlm_br_write_unlock(unsigned int flags)
+{
+	if(nlm_enable_br_wrkaround){
+        nlm_preempt_disable();
+		nlm_write_unlock_irq_restore(nlm_bridge_lock, flags);
+        nlm_preempt_enable();
+    }
+}
+
+static inline uint32_t nlm_read_reg_locked(nlm_reg_t *base, 
+		unsigned int offset) 	
+{
+	unsigned int flags, val;
+
+	flags = nlm_br_read_lock();
+	val = (be32_to_cpu((base)[(offset)])); 
+	nlm_br_read_unlock(flags);
+
+	return val;
+}
+static inline uint32_t nlm_read_reg_le_locked(nlm_reg_t *base, 
+		unsigned int offset) 	
+{
+	unsigned int flags, val;
+	flags = nlm_br_read_lock();
+	val = (le32_to_cpu((base)[(offset)])); 
+	nlm_br_read_unlock(flags);
+
+	return val;
+}
+static inline void nlm_write_reg_locked(nlm_reg_t *base, 
+		 unsigned int offset,  unsigned int value)
+{
+	unsigned int flags;
+	flags = nlm_br_write_lock();
+	((base)[(offset)] = cpu_to_be32((value)));
+	nlm_br_write_unlock(flags);
+}
+
+static inline void nlm_write_reg_le_locked(nlm_reg_t *base, 
+		 unsigned int offset,  unsigned int value)
+{
+	unsigned int flags;
+	flags = nlm_br_write_lock();
+	((base)[(offset)] = cpu_to_le32((value)));
+	nlm_br_write_unlock(flags);
+}
+
+#define netlogic_read_reg(base, offset) nlm_read_reg_locked(base, offset)
+#define netlogic_write_reg(base, offset, value) \
+	nlm_write_reg_locked(base, offset, value)
+
+#define netlogic_read_reg_le32(base, offset) \
+	nlm_read_reg_le_locked(base, offset)
+#define netlogic_write_reg_le32(base, offset, value) \
+	nlm_write_reg_le_locked(base, offset, value)
+
+#else /* NLM_BRIDGE_WORKAROUND */
+
+static inline uint32_t nlm_br_read_lock(void) 
+{
+	return 0;
+}
+
+static inline void nlm_br_read_unlock(unsigned int flags)
+{
+}
+
+static inline uint32_t nlm_br_write_lock(void)
+{
+	return 0;
+}
+
+static inline void nlm_br_write_unlock(unsigned int flags)
+{
+}
+#ifdef CONFIG_CPU_LITTLE_ENDIAN
+
+#define netlogic_read_reg(base, offset) ((base)[(offset)])
+#define netlogic_write_reg(base, offset, value) ((base)[(offset)] = (value))
+
+#else
+
+#define netlogic_read_reg(base, offset) (be32_to_cpu((base)[(offset)]))
+#define netlogic_write_reg(base, offset, value) ((base)[(offset)] = cpu_to_be32((value)))
+
+#endif
+
+#define netlogic_read_reg_le32(base, offset) (le32_to_cpu((base)[(offset)]))
+#define netlogic_write_reg_le32(base, offset, value) \
+	((base)[(offset)] = cpu_to_le32((value)))
+
+#endif /* NLM_BRIDGE_WORKAROUND */
+
+extern void on_chip_init(void);
+
+extern unsigned int xlp_uart_portid;
+static inline void xlp_prom_putchar(char c)
+{
+	nlm_reg_t *mmio;
+	switch(xlp_uart_portid){
+		default:
+		case 0:
+			mmio = netlogic_io_mmio(NETLOGIC_IO_UART_0_OFFSET);
+			break;
+		case 1:
+			mmio = netlogic_io_mmio(NETLOGIC_IO_UART_1_OFFSET);
+			break;
+	}
+	while (netlogic_read_reg( mmio, 0x5) == 0);
+		netlogic_write_reg( mmio, 0x0, c);
+}
+
+#endif /* __ASSEMBLY__ */
+
+#endif
diff --git a/arch/mips/include/asm/netlogic/memory-exclusion.h b/arch/mips/include/asm/netlogic/memory-exclusion.h
new file mode 100644
index 0000000..ae872a6
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/memory-exclusion.h
@@ -0,0 +1,38 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+
+#ifndef NLM_MEMORY_EXCLUSION
+#define NLM_MEMORY_EXCLUSION
+
+#define NLM_RMIOS_TCPIP_START  (8<<20)
+#define NLM_RMIOS_TCPIP_END    (96<<20)
+
+#define NLM_RMIOS_IPSEC_START  (1<<20)
+#define NLM_RMIOS_IPSEC_END    (51<<20)
+
+#define NLM_RMIOS_LIB_START    (16<<20)
+#define NLM_RMIOS_LIB_END	(51<<20)
+
+#endif
diff --git a/arch/mips/include/asm/netlogic/mips-exts.h b/arch/mips/include/asm/netlogic/mips-exts.h
new file mode 100644
index 0000000..c62acac
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/mips-exts.h
@@ -0,0 +1,324 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+
+#ifndef _ASM_NLM_MIPS_EXTS_H
+#define _ASM_NLM_MIPS_EXTS_H
+
+#define NETLOGIC_OSS_SEL_TLB_STATS 0
+#define NETLOGIC_OSS_SEL_UNUSED 1
+#define NETLOGIC_OSS_SEL_PAGEMASK 2
+#define NETLOGIC_OSS_SEL_VADDR 3
+#define NETLOGIC_OSS_SEL_PFN0 4
+#define NETLOGIC_OSS_SEL_PFN1 5
+#define NETLOGIC_OSS_SEL_K0 6
+#define NETLOGIC_OSS_SEL_K1 7
+
+#define OS_SCRATCH_REG0	22, 0
+#define OS_SCRATCH_REG1	22, 1
+#define OS_SCRATCH_REG2	22, 2
+#define OS_SCRATCH_REG3	22, 3
+#define OS_SCRATCH_REG4	22, 4
+#define OS_SCRATCH_REG5	22, 5
+#define OS_SCRATCH_REG6	22, 6
+#define OS_SCRATCH_REG7	22, 7
+
+#define OS_KGDB_SCRATCH_REG6	$22, 6
+#define OS_KGDB_SCRATCH_REG7	$22, 7
+
+#ifndef __ASSEMBLY__
+
+#include <linux/types.h>
+#include <asm/netlogic/interrupt.h>
+#include <asm/netlogic/iomap.h>
+
+/* Scratch registers used */
+#define NLM_TLB_STATS_SCRATCH_REG_SEL  2
+#define NLM_HTLB_PMASK_SCRATCH_REG_SEL 3
+#define NLM_CRF_PERF0_SCRATCH_REG_SEL  NLM_PERF0_SCRATCH
+#define NLM_CRF_PERF1_SCRATCH_REG_SEL  NLM_PERF1_SCRATCH
+
+
+#define DMFC0_AT_EIRR 0x40214806
+#define DMFC0_AT_EIMR 0x40214807
+#define DMTC0_AT_EIRR 0x40a14806
+#define DMTC0_AT_EIMR 0x40a14807
+
+/* functions to write to and read from the extended
+ * cp0 registers.
+ * EIRR : Extended Interrupt Request Register
+ *        cp0 register 9 sel 6
+ *        bits 0...7 are same as cause register 8...15
+ * EIMR : Extended Interrupt Mask Register
+ *        cp0 register 9 sel 7
+ *        bits 0...7 are same as status register 8...15
+ */
+
+static inline __u64 read_64bit_cp0_eirr(void)
+{
+  __u32 high, low;
+
+  __asm__ __volatile__ (
+			".set push\n"
+			".set noreorder\n"
+			".set noat\n"
+			".set mips4\n"
+
+			".word 0x40214806  \n\t"
+			"nop               \n\t"
+			"dsra32 %0, $1, 0  \n\t"
+			"sll    %1, $1, 0  \n\t"
+
+			".set pop\n"
+
+			: "=r" (high), "=r" (low)
+			);
+
+  return ( ((__u64)high) << 32) | low;
+}
+
+static inline __u64 read_64bit_cp0_eimr(void)
+{
+  __u32 high, low;
+
+  __asm__ __volatile__ (
+			".set push\n"
+			".set noreorder\n"
+			".set noat\n"
+			".set mips4\n"
+
+			".word 0x40214807  \n\t"
+			"nop               \n\t"
+			"dsra32 %0, $1, 0  \n\t"
+			"sll    %1, $1, 0  \n\t"
+
+			".set pop\n"
+
+			: "=r" (high), "=r" (low)
+			);
+
+  return ( ((__u64)high) << 32) | low;
+}
+
+static inline void write_64bit_cp0_eirr(__u64 value)
+{
+  __u32 low, high;
+
+  high = value >> 32;
+  low  = value & 0xffffffff;
+
+	__asm__ __volatile__ (
+	".set push\n"
+	".set noreorder\n"
+	".set noat\n"
+	".set mips4\n\t"
+
+	"dsll32 $2, %1, 0  \n\t"
+	"dsll32 $1, %0, 0  \n\t"
+	"dsrl32 $2, $2, 0  \n\t"
+	"or     $1, $1, $2 \n\t"
+	".word  0x40a14806 \n\t"
+	"nop               \n\t"
+
+	".set pop\n"
+
+	:
+	: "r" (high), "r" (low)
+	: "$1", "$2");
+}
+
+static inline void write_64bit_cp0_eimr(__u64 value)
+{
+  __u32 low, high;
+
+  high = value >> 32;
+  low  = value & 0xffffffff;
+
+	__asm__ __volatile__ (
+	".set push\n"
+	".set noreorder\n"
+	".set noat\n"
+	".set mips4\n\t"
+
+	"dsll32 $2, %1, 0  \n\t"
+	"dsll32 $1, %0, 0  \n\t"
+	"dsrl32 $2, $2, 0  \n\t"
+	"or     $1, $1, $2 \n\t"
+	".word  0x40a14807 \n\t"
+	"nop               \n\t"
+
+	".set pop\n"
+
+	:
+	: "r" (high), "r" (low)
+	: "$1", "$2");
+}
+
+static __inline__ int hard_smp_processor_id(void)
+{
+	int cpu;
+
+	__asm__ __volatile__ (
+		".set push\n"
+		".set noreorder\n"
+                ".set mips32\n"
+                "mfc0 %0, $15, 1\n"
+		"andi %0, %0, 0x3ff\n"
+		".set pop\n"
+		: "=&r"(cpu)
+		);
+
+	return cpu;
+}
+
+static __inline__ int netlogic_cpu_id(void)
+{
+	return hard_smp_processor_id() >> 2;
+}
+
+static __inline__ int netlogic_thr_id(void)
+{
+	return hard_smp_processor_id() & 0x03;
+}
+
+#define CPU_BLOCKID_IFU      0
+#define CPU_BLOCKID_ICU      1
+#define CPU_BLOCKID_IEU      2
+#define CPU_BLOCKID_LSU      3
+#define CPU_BLOCKID_MMU      4
+#define CPU_BLOCKID_PRF      5
+
+#define CPU_BLOCKID_SCU      8
+
+#define ICU_CERRLOG0_REGID   0x10
+#define ICU_CERRLOG1_REGID   0x11
+#define ICU_CERRLOG2_REGID   0x12
+
+#define LSU_CERRLOG0_REGID   0x08
+#define LSU_CERRLOG1_REGID   0x09
+
+#define SCU_CERRLOG0_REGID   0x10
+#define SCU_CERRLOG1_REGID   0x11
+#define SCU_CERRLOG2_REGID   0x12
+
+static __inline__ unsigned int read_32bit_nlm_ctrl_reg(int block, int reg)
+{
+  unsigned int __res;
+
+  __asm__ __volatile__(
+		       ".set\tpush\n\t"
+		       ".set\tnoreorder\n\t"
+		       "move $9, %1\n"
+/* 		       "mfcr\t$8, $9\n\t"          */
+		       ".word 0x71280018\n"
+		       "move %0, $8\n"
+		       ".set\tpop"
+		       : "=r" (__res) : "r"((block<<8)|reg)
+		       : "$8", "$9"
+		       );
+  return __res;
+}
+
+static __inline__ void write_32bit_nlm_ctrl_reg(int block, int reg, unsigned int value)
+{
+  __asm__ __volatile__(
+		       ".set\tpush\n\t"
+		       ".set\tnoreorder\n\t"
+		       "move $8, %0\n"
+		       "move $9, %1\n"
+/* 		       "mtcr\t$8, $9\n\t"  */
+		       ".word 0x71280019\n"
+		       ".set\tpop"
+		       :
+		       : "r" (value), "r"((block<<8)|reg)
+		       : "$8", "$9"
+		       );
+}
+
+static __inline__ unsigned long long read_64bit_nlm_ctrl_reg(int block, int reg)
+{
+	unsigned int high, low;
+
+	__asm__ __volatile__(
+		".set\tmips64\n\t"
+		"move    $9, %2\n"
+		/* "mfcr    $8, $9\n" */
+		".word   0x71280018\n"
+		"dsrl32  %0, $8, 0\n\t"
+		"dsll32  $8, $8, 0\n\t"
+		"dsrl32  %1, $8, 0\n\t"
+		".set mips0"
+		: "=r" (high), "=r"(low)
+		: "r"((block<<8)|reg)
+		: "$8", "$9"
+		);
+
+	return ( (((unsigned long long)high)<<32) | low);
+}
+
+static __inline__ void write_64bit_nlm_ctrl_reg(int block, int reg,unsigned long long value)
+{
+	__u32 low, high;
+	high = value >> 32;
+	low = value & 0xffffffff;
+
+	__asm__ __volatile__(
+		".set push\n"
+		".set noreorder\n"
+		".set mips4\n\t"
+		/* Set up "rs" */
+		"move $9, %0\n"
+
+		/* Store 64 bit value in "rt" */
+		"dsll32 $10, %1, 0  \n\t"
+		"dsll32 $8, %2, 0  \n\t"
+		"dsrl32 $8, $8, 0  \n\t"
+		"or     $8, $10, $8 \n\t"
+
+		".word 0x71280019\n" /* mtcr $8, $9 */
+
+		".set pop\n"
+
+		:  /* No outputs */
+		: "r"((block<<8)|reg), "r" (high), "r" (low)
+		: "$8", "$9", "$10"
+		);
+}
+
+typedef struct { volatile int value; } nlm_common_atomic_t;
+
+#define nlm_write_os_scratch_2(val)	__write_64bit_c0_register($22, 2, val)
+#define nlm_read_os_scratch_2()	__read_64bit_c0_register($22, 2)
+
+#define nlm_write_os_scratch_3(val)	__write_64bit_c0_register($22, 3, val)
+#define nlm_read_os_scratch_3()	__read_64bit_c0_register($22, 3)
+#endif
+
+#ifdef CONFIG_CPU_XLP
+#define SET_MIPS64 .set mips64r2
+#else
+#define SET_MIPS64 .set mips64
+#endif
+
+#endif /* _ASM_NLM_MIPS_EXTS_H */
diff --git a/arch/mips/include/asm/netlogic/nlm_fs.h b/arch/mips/include/asm/netlogic/nlm_fs.h
new file mode 100644
index 0000000..c973e24
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/nlm_fs.h
@@ -0,0 +1,59 @@
+#ifndef _ASM_NLM_FS_H
+#define _ASM_NLM_FS_H
+
+#define NLM_FS_UNUSED             0
+#define NLM_FS_MSGSND             1
+#define NLM_FS_MSGRCV             2
+#define NLM_FS_C0_COUNT           3
+#define NLM_FS_MEM_READ           4
+#define NLM_FS_MEM_WRITE          5
+#define NLM_FS_MSGINT             6
+#define NLM_FS_READ_COP           7
+#define NLM_FS_PERFCTR_START      8
+#define NLM_FS_PERFCTR_STOP       9
+#define NLM_FS_READ_CPUMASKS      10
+#define NLM_FS_READ_PROCID        11
+#define NLM_FS_PROMINFO           12
+#define NLM_FS_READ_TIMER         13
+#define NLM_FS_HARD_CPUID         14
+#define NLM_FS_ENDIANESS          15
+#define NLM_FS_REVERSE_ENDIANESS  16
+#define NLM_FS_USPACE_64BIT_INS   17
+#define NLM_FS_CPU_MAX_FREQ       18
+#define NLM_FS_MEM_READ64         19
+#define NLM_FS_MEM_WRITE64        20
+#define NLM_FS_MEM_READ32         21
+#define NLM_FS_MEM_WRITE32        22
+#define NLM_FS_MSGSND3            23
+#define NLM_FS_MSGRCV1            24
+
+#ifndef __ASSEMBLY__
+
+extern void nlm_fs_mem_read32(void);
+extern void nlm_fs_mem_write32(void);
+extern void nlm_fs_mem_read64(void);
+extern void nlm_fs_mem_write64(void);
+extern void nlm_fs_msgsnd(void);
+extern void nlm_fs_msgrcv(void);
+extern void nlm_fs_c0_count(void);
+extern void nlm_fs_processorId(void);
+extern void nlm_fs_iomem_read(void);
+extern void nlm_fs_iomem_write(void);
+extern void nlm_fs_msg_read(void);
+extern void nlm_fs_perf_ctr_start(void);
+extern void nlm_fs_perf_ctr_stop(void);
+extern void nlm_fs_get_cpumasks(void);
+extern void nlm_fs_read_timer(void);
+extern void nlm_fs_read_timer(void);
+extern void nlm_fs_hard_cpuid(void);
+extern void nlm_fs_is_big_endian(void);
+extern void nlm_fs_is_endian_reversed(void);
+extern void nlm_fs_uspace_64bit_ins_enabled(void);
+extern void nlm_fs_cpu_max_freq(void);
+
+extern void nlm_fs_msgsnd3(void);
+extern void nlm_fs_msgrcv1(void);
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* _ASM_NLM_FS_H */
diff --git a/arch/mips/include/asm/netlogic/nlm_rw_lock.h b/arch/mips/include/asm/netlogic/nlm_rw_lock.h
new file mode 100644
index 0000000..fcbda8a
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/nlm_rw_lock.h
@@ -0,0 +1,216 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+#ifndef __NLM_RW_LOCK_H_
+#define __NLM_RW_LOCK_H_
+
+#define NLM_MAX_CPUS 32
+typedef struct {
+	volatile unsigned int lock;
+	unsigned int read_cpus[NLM_MAX_CPUS]; /* cpus that hold rd lock */
+	int write_cpu; /* CPU that is currently holding wr lock */
+} nlm_rwlock_t;
+
+#define nlm_sync() __asm__ __volatile__("sync": : :"memory")
+__asm__ (
+		".macro\tnlm_local_irq_save result\n\t"
+		".set\tpush\n\t"
+		".set\treorder\n\t"
+		".set\tnoat\n\t"
+		"mfc0\t\\result, $12\n\t"
+		"ori\t$1, \\result, 1\n\t"
+		"xori\t$1, 1\n\t"
+		".set\tnoreorder\n\t"
+		"mtc0\t$1, $12\n\t"
+		"sll\t$0, $0, 1\t\t\t# nop\n\t"
+		"sll\t$0, $0, 1\t\t\t# nop\n\t"
+		"sll\t$0, $0, 1\t\t\t# nop\n\t"
+		".set\tpop\n\t"
+		".endm");
+
+__asm__(".macro\tnlm_local_irq_restore flags\n\t"
+		".set\tnoreorder\n\t"
+		".set\tnoat\n\t"
+		"mfc0\t$1, $12\n\t"
+		"andi\t\\flags, 1\n\t"
+		"ori\t$1, 1\n\t"
+		"xori\t$1, 1\n\t"
+		"or\t\\flags, $1\n\t"
+		"mtc0\t\\flags, $12\n\t"
+		"sll\t$0, $0, 1\t\t\t# nop\n\t"
+		"sll\t$0, $0, 1\t\t\t# nop\n\t"
+		"sll\t$0, $0, 1\t\t\t# nop\n\t"
+		".set\tat\n\t"
+		".set\treorder\n\t"
+		".endm");
+
+
+#define nlm_local_irq_save(x)		\
+	__asm__ __volatile__(           \
+		"nlm_local_irq_save\t%0"                                    \
+		: "=r" (x)		\
+		: /* no inputs */	\
+		: "memory")
+
+
+#define nlm_local_irq_restore(flags)		\
+	do {                           		\
+		unsigned long __tmp1;  		\
+		__asm__ __volatile__(  		\
+		"nlm_local_irq_restore\t%0"        	\
+		: "=r" (__tmp1)                 \
+		: "0" (flags)                   \
+		: "memory");                    \
+	} while(0)
+
+
+#define nlm_processor_id() 				\
+	({ int __res;                                   \
+	 __asm__ __volatile__(                          \
+		 ".set\tmips32\n\t"                     \
+		 "mfc0\t%0, $15, 1\n\t"           	\
+		 "andi\t%0, 0x1f\n\t"			\
+		 ".set\tmips0\n\t"                      \
+		 : "=r" (__res));                       \
+	 __res;                                         \
+	 })
+
+
+static inline unsigned int nlm_read_lock_irq_save(nlm_rwlock_t *rw)
+{
+	unsigned int temp;
+	unsigned int cpu;
+	unsigned int flags;
+
+	nlm_local_irq_save(flags);
+	cpu = nlm_processor_id();
+
+		__asm__ __volatile__(
+		"	.set	noreorder	\n"
+		"1:	ll	%1, %2		\n"
+		"	bltz	%1, 2f		\n"
+		"	 addu	%1, 1		\n"
+		"	sc	%1, %0		\n"
+		"	beqz	%1, 1b		\n"
+		"	 nop			\n"
+		"	.subsection 2		\n"
+		"2:	ll	%1, %2		\n"
+		"	bltz	%1, 2b		\n"
+		"	 addu	%1, 1		\n"
+		"	b	1b		\n"
+		"	 nop			\n"
+		"	.previous		\n"
+		"	.set	reorder		\n"
+		: "=m" (rw->lock), "=&r" (temp)
+		: "m" (rw->lock)
+		: "memory");
+
+		rw->read_cpus[cpu] = 1;
+		nlm_sync();
+
+		return flags;
+}
+
+static inline void nlm_read_unlock_irq_restore(nlm_rwlock_t *rw, 
+			unsigned int flags)
+{
+	unsigned int temp;
+	unsigned int cpu;
+
+	cpu = nlm_processor_id();
+
+	nlm_sync();
+	__asm__ __volatile__(
+		"       .set    noreorder       			\n"
+		"1:     ll      %1, %2                                  \n"
+		"       sub     %1, 1                                   \n"
+		"       sc      %1, %0                                  \n"
+		"       beqz    %1, 2f                                  \n"
+		"        nop                                            \n"
+		"       .subsection 2                                   \n"
+		"2:     b       1b                                      \n"
+		"        nop                                            \n"
+		"       .previous                                       \n"
+		"       .set    reorder                                 \n"
+		: "=m" (rw->lock), "=&r" (temp)
+		: "m" (rw->lock)
+		: "memory");
+	rw->read_cpus[cpu] = 0;
+	nlm_local_irq_restore(flags);
+
+}
+
+static inline unsigned int nlm_write_lock_irq_save(nlm_rwlock_t *rw)
+{
+	unsigned int temp;
+	unsigned int cpu;
+	unsigned int flags;
+
+	nlm_local_irq_save(flags);
+	cpu = nlm_processor_id();
+
+	__asm__ __volatile__(
+		"       .set    noreorder       			\n"
+		"1:     ll      %1, %2                                  \n"
+		"       bnez    %1, 2f                                  \n"
+		"        lui    %1, 0x8000                              \n"
+		"       sc      %1, %0                                  \n"
+		"       beqz    %1, 2f                                  \n"
+		"        nop                                            \n"
+		"       .subsection 2                                   \n"
+		"2:     ll      %1, %2                                  \n"
+		"       bnez    %1, 2b                                  \n"
+		"        lui    %1, 0x8000                              \n"
+		"       b       1b                                      \n"
+		"        nop                                            \n"
+		"       .previous                                       \n"
+		"       .set    reorder                                 \n"
+		: "=m" (rw->lock), "=&r" (temp)
+		: "m" (rw->lock)
+		: "memory");
+
+	rw->write_cpu = cpu;
+	nlm_sync();
+	
+	return flags;
+
+}
+
+
+static inline void nlm_write_unlock_irq_restore(nlm_rwlock_t *rw, 
+						unsigned int flags)
+{
+	nlm_sync();
+
+	__asm__ __volatile__(
+		"       sw      $0, %0                                  \n"
+		: "=m" (rw->lock)
+		: "m" (rw->lock)
+		: "memory");
+	rw->write_cpu = -1;
+	nlm_local_irq_restore(flags);
+}
+
+
+#endif
diff --git a/arch/mips/include/asm/netlogic/pci.h b/arch/mips/include/asm/netlogic/pci.h
new file mode 100644
index 0000000..b918ec3
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/pci.h
@@ -0,0 +1,33 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+
+#ifndef _ASM_NLM_PCI_H
+#define _ASM_NLM_PCI_H
+
+#define NLM_PCI_VENDOR_ID            0xfecc
+#define NLM_PCI_UART_DEV_ID          2
+#define NLM_PCI_DUMMY_MAC_DEV_ID     16
+
+#endif
diff --git a/arch/mips/include/asm/netlogic/perf_ctr.h b/arch/mips/include/asm/netlogic/perf_ctr.h
new file mode 100644
index 0000000..6a992a4
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/perf_ctr.h
@@ -0,0 +1,67 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+
+#ifndef __ASM_NLM_PERF_CTR_H
+#define __ASM_NLM_PERF_CTR_H
+
+#include <asm/mipsregs.h>
+
+#define CP0_PERF_CTR  $25
+
+/* Subset of perf ctr events */
+
+#define PERF_CTR_INSTR_FETCHED           0
+#define PERF_CTR_ICACHE_MISSES           1
+#define PERF_CTR_SLEEP_CYCLES           12
+#define PERF_CTR_INSTR_RETIRED          17
+#define PERF_CTR_BRJMP_INSTR            20
+#define PERF_CTR_BRJMP_FLUSH            21
+#define PERF_CTR_REPLAYFLUSH            27
+#define PERF_CTR_REPLAYFLUSH_LDUSE      28
+#define PERF_CTR_L1_HIT                 38
+#define PERF_CTR_L1_REF                 39
+#define PERF_CTR_SNOOP_UPGRADE_FAIL     47
+#define PERF_CTR_SNOOP_TRANSFERS        48
+#define PERF_CTR_SNOOP_HITS             49
+#define PERF_CTR_SNOOP_OPS              50
+#define PERF_CTR_CYCLES                 63
+
+/* 2 sets of counters are supported across all threads of a core */
+#define PERF_CTR_EVENT0        0
+#define PERF_CTR_EVENT0_VALUE  1
+#define PERF_CTR_EVENT1        2
+#define PERF_CTR_EVENT1_VALUE  3
+
+#define PERF_CTR_DEFAULT 0x0f /* disable int, enable counting in all modes */
+
+#define perf_ctr_start(ctr, event, global, thr) __write_32bit_c0_register($25, ctr, ((PERF_CTR_DEFAULT)|((global)<<13)|((thr)<<11)|((event)<<5)) ) 
+
+#define perf_ctr_stop(ctr) __write_32bit_c0_register($25, ctr, 0)
+
+#define perf_ctr_reset(ctr) __write_32bit_c0_register($25, ctr, 0)
+
+#define perf_ctr_read(ctr) __read_32bit_c0_register($25, ctr)
+
+#endif /* __ASM_NLM_PERF_CTR_H */
diff --git a/arch/mips/include/asm/netlogic/pic.h b/arch/mips/include/asm/netlogic/pic.h
new file mode 100644
index 0000000..711e71f
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/pic.h
@@ -0,0 +1,48 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+
+#ifndef _ASM_NLM_PIC_H
+#define _ASM_NLM_PIC_H
+
+#include <asm/netlogic/iomap.h>
+
+#if defined(CONFIG_NLM_XLP)
+
+// can't do floating in the kernel, so use 64 as an approximation 
+#define PIC_CLKS_PER_SEC 133333333ULL
+#define PIC_CLKS_PER_USEC 133	//(PIC_CLKS_PER_SEC / 1000000)
+#define PIC_CLKS_PER_TIMER_TICK (PIC_CLKS_PER_SEC / HZ)
+
+#else
+// can't do floating in the kernel, so use 64 as an approximation 
+#define PIC_CLKS_PER_SEC 66666666ULL
+#define PIC_CLKS_PER_USEC 66	//(PIC_CLKS_PER_SEC / 1000000)
+#define PIC_CLKS_PER_TIMER_TICK (PIC_CLKS_PER_SEC / HZ)
+
+//#include <asm/netlogic/xl_pic.h>
+#endif /* CONFIG_NLM_XLP */
+
+#endif /* #ifndef _ASM_NLM_PIC_H */
+	
diff --git a/arch/mips/include/asm/netlogic/proc.h b/arch/mips/include/asm/netlogic/proc.h
new file mode 100644
index 0000000..7769136
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/proc.h
@@ -0,0 +1,46 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+
+#ifndef _ASM_NLM_PROC_H
+#define _ASM_NLM_PROC_H
+
+#include <linux/types.h>
+
+static __inline__ int proc_pos_check(off_t * begin, int *len, off_t off,
+				     int count)
+{
+	off_t pos = *begin + *len;
+
+	if (pos < off) {
+		*len = 0;
+		*begin = pos;
+	}
+	if (pos > off + count)
+		return 0;
+
+	return 1;
+}
+
+#endif
diff --git a/arch/mips/include/asm/netlogic/xlp.h b/arch/mips/include/asm/netlogic/xlp.h
new file mode 100644
index 0000000..991a086
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/xlp.h
@@ -0,0 +1,97 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+
+#ifndef _ASM_XLP_H
+#define _ASM_XLP_H
+
+#include <linux/types.h>
+#include <asm/cpu.h>
+#include <asm/mipsregs.h>
+
+#define CHIP_PROCESSOR_ID_XLP_8XX   0x00
+#define CHIP_PROCESSOR_ID_XLP_832   0x10
+#define CHIP_PROCESSOR_ID_XLP_816   0x14
+#define CHIP_PROCESSOR_ID_XLP_432   0x90
+#define CHIP_PROCESSOR_ID_XLP_416   0x94
+#define CHIP_PROCESSOR_ID_XLP_408   0x95
+#define CHIP_PROCESSOR_ID_XLP_316   0xD4
+#define CHIP_PROCESSOR_ID_XLP_308   0xD5
+#define CHIP_PROCESSOR_ID_XLP_304   0xD7
+#define CHIP_PROCESSOR_ID_XLP_208   0xB5
+#define CHIP_PROCESSOR_ID_XLP_204   0xB7
+#define CHIP_PROCESSOR_ID_XLP_104   0xF7
+
+#define XLP_REVISION_A0 	0x00
+#define XLP_REVISION_A1 	0x01
+#define XLP_REVISION_A2 	0x02
+
+#define MAX_CPU_REV_LEN		100
+#define NLM_MAX_CPU_NODE		1
+#define NLM_MAX_CPU_PER_NODE	32
+#define NLM_MAX_THREADS_PER_CPU	4
+#define NLM_MAX_VC_PER_THREAD	4
+
+#define PCI_NETL_VENDOR         0x184E
+#define XLP_DEVID_DRAM          0x1001
+#define XLP_DEVID_PIC           0x1003
+#define XLP_DEVID_INTLA         0x1005
+#define XLP_DEVID_USBDEV        0x1006
+#define XLP_DEVID_EHCI          0x1007  
+#define XLP_DEVID_OHCI          0x1008
+#define XLP_DEVID_NAE           0x1009
+#define XLP_DEVID_POE           0x100A
+#define XLP_DEVID_CMS           0x100B
+#define XLP_DEVID_DTRE_RAID     0x100C
+#define XLP_DEVID_SAE           0x100D
+#define XLP_DEVID_RSAECC        0x100E
+#define XLP_DEVID_CPM           0x100F
+#define XLP_DEVID_UART          0x1010
+#define XLP_DEVID_I2C           0x1011
+#define XLP_DEVID_GPIO          0x1012
+#define XLP_DEVID_SYS           0x1013
+#define XLP_DEVID_JTAG          0x1014
+#define XLP_DEVID_NOR           0x1015
+#define XLP_DEVID_NAND          0x1016
+#define XLP_DEVID_SPI           0x1017
+#define XLP_DEVID_MMC           0x1018
+
+struct smp_boot_info_percpu {
+  volatile unsigned long ready;
+  volatile unsigned long sp;
+  volatile unsigned long gp;
+  volatile unsigned long fn;
+};
+
+struct smp_boot_info {
+  struct smp_boot_info_percpu boot_info[NR_CPUS];
+  cpumask_t online_map;
+};
+
+extern struct smp_boot_info smp_boot;
+extern void prom_boot_cpus_secondary(void *);
+
+extern char cpu_model_info[MAX_CPU_REV_LEN];
+extern char* get_cpu_info(void);
+#endif /*_ASM_XLP_H */ 
diff --git a/arch/mips/include/asm/netlogic/xlp_mac.h b/arch/mips/include/asm/netlogic/xlp_mac.h
new file mode 100644
index 0000000..23fe782
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/xlp_mac.h
@@ -0,0 +1,1023 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+
+#ifndef _ASM_NLM_MAC_H
+#define _ASM_NLM_MAC_H
+
+#include <linux/types.h>
+#include <asm/netlogic/iomap.h>
+#include <linux/skbuff.h>
+
+#define IPSEC_PACKET_PAYLOAD_SIZE 1696
+#define PHXSEC_HMAC_LENGTH 64
+#define SKBUF_HEAD (32 * 2)    // 2 cachelines reserved before payload
+
+//#define MAC_SPLIT_MODE
+
+#define MAC_SPACING                 0x400
+#define XGMAC_SPACING               0x400
+
+/* PE-MCXMAC register and bit field definitions */
+#define R_MAC_CONFIG_1                                              0x00
+#define   O_MAC_CONFIG_1__srst                                      31
+#define   O_MAC_CONFIG_1__simr                                      30
+#define   O_MAC_CONFIG_1__hrrmc                                     18
+#define   W_MAC_CONFIG_1__hrtmc                                      2
+#define   O_MAC_CONFIG_1__hrrfn                                     16
+#define   W_MAC_CONFIG_1__hrtfn                                      2
+#define   O_MAC_CONFIG_1__intlb                                      8
+#define   O_MAC_CONFIG_1__rxfc                                       5
+#define   O_MAC_CONFIG_1__txfc                                       4
+#define   O_MAC_CONFIG_1__srxen                                      3
+#define   O_MAC_CONFIG_1__rxen                                       2
+#define   O_MAC_CONFIG_1__stxen                                      1
+#define   O_MAC_CONFIG_1__txen                                       0
+#define R_MAC_CONFIG_2                                              0x01
+#define   O_MAC_CONFIG_2__prlen                                     12
+#define   W_MAC_CONFIG_2__prlen                                      4
+#define   O_MAC_CONFIG_2__speed                                      8
+#define   W_MAC_CONFIG_2__speed                                      2
+#define   O_MAC_CONFIG_2__hugen                                      5
+#define   O_MAC_CONFIG_2__flchk                                      4
+#define   O_MAC_CONFIG_2__crce                                       1
+#define   O_MAC_CONFIG_2__fulld                                      0
+#define R_IPG_IFG                                                   0x02
+#define   O_IPG_IFG__ipgr1                                          24
+#define   W_IPG_IFG__ipgr1                                           7
+#define   O_IPG_IFG__ipgr2                                          16
+#define   W_IPG_IFG__ipgr2                                           7
+#define   O_IPG_IFG__mifg                                            8
+#define   W_IPG_IFG__mifg                                            8
+#define   O_IPG_IFG__ipgt                                            0
+#define   W_IPG_IFG__ipgt                                            7
+#define R_HALF_DUPLEX                                               0x03
+#define   O_HALF_DUPLEX__abebt                                      24
+#define   W_HALF_DUPLEX__abebt                                       4
+#define   O_HALF_DUPLEX__abebe                                      19
+#define   O_HALF_DUPLEX__bpnb                                       18
+#define   O_HALF_DUPLEX__nobo                                       17
+#define   O_HALF_DUPLEX__edxsdfr                                    16
+#define   O_HALF_DUPLEX__retry                                      12
+#define   W_HALF_DUPLEX__retry                                       4
+#define   O_HALF_DUPLEX__lcol                                        0
+#define   W_HALF_DUPLEX__lcol                                       10
+#define R_MAXIMUM_FRAME_LENGTH                                      0x04
+#define   O_MAXIMUM_FRAME_LENGTH__maxf                               0
+#define   W_MAXIMUM_FRAME_LENGTH__maxf                              16
+#define R_TEST                                                      0x07
+#define   O_TEST__mbof                                               3
+#define   O_TEST__rthdf                                              2
+#define   O_TEST__tpause                                             1
+#define   O_TEST__sstct                                              0
+#define R_MII_MGMT_CONFIG                                           0x08
+#define   O_MII_MGMT_CONFIG__scinc                                   5
+#define   O_MII_MGMT_CONFIG__spre                                    4
+#define   O_MII_MGMT_CONFIG__clks                                    3
+#define   W_MII_MGMT_CONFIG__clks                                    3
+#define R_MII_MGMT_COMMAND                                          0x09
+#define   O_MII_MGMT_COMMAND__scan                                   1
+#define   O_MII_MGMT_COMMAND__rstat                                  0
+#define R_MII_MGMT_ADDRESS                                          0x0A
+#define   O_MII_MGMT_ADDRESS__fiad                                   8
+#define   W_MII_MGMT_ADDRESS__fiad                                   5
+#define   O_MII_MGMT_ADDRESS__fgad                                   5
+#define   W_MII_MGMT_ADDRESS__fgad                                   0
+#define R_MII_MGMT_WRITE_DATA                                       0x0B
+#define   O_MII_MGMT_WRITE_DATA__ctld                                0
+#define   W_MII_MGMT_WRITE_DATA__ctld                               16
+#define R_MII_MGMT_STATUS                                           0x0C
+#define R_MII_MGMT_INDICATORS                                       0x0D
+#define   O_MII_MGMT_INDICATORS__nvalid                              2
+#define   O_MII_MGMT_INDICATORS__scan                                1
+#define   O_MII_MGMT_INDICATORS__busy                                0
+#define R_INTERFACE_CONTROL                                         0x0E
+#define   O_INTERFACE_CONTROL__hrstint                              31
+#define   O_INTERFACE_CONTROL__tbimode                              27
+#define   O_INTERFACE_CONTROL__ghdmode                              26
+#define   O_INTERFACE_CONTROL__lhdmode                              25
+#define   O_INTERFACE_CONTROL__phymod                               24
+#define   O_INTERFACE_CONTROL__hrrmi                                23
+#define   O_INTERFACE_CONTROL__rspd                                 16
+#define   O_INTERFACE_CONTROL__hr100                                15
+#define   O_INTERFACE_CONTROL__frcq                                 10
+#define   O_INTERFACE_CONTROL__nocfr                                 9
+#define   O_INTERFACE_CONTROL__dlfct                                 8
+#define   O_INTERFACE_CONTROL__enjab                                 0
+#define R_INTERFACE_STATUS                                         0x0F
+#define   O_INTERFACE_STATUS__xsdfr                                  9
+#define   O_INTERFACE_STATUS__ssrr                                   8
+#define   W_INTERFACE_STATUS__ssrr                                   5
+#define   O_INTERFACE_STATUS__miilf                                  3
+#define   O_INTERFACE_STATUS__locar                                  2
+#define   O_INTERFACE_STATUS__sqerr                                  1
+#define   O_INTERFACE_STATUS__jabber                                 0
+#define R_STATION_ADDRESS_LS                                       0x10
+#define R_STATION_ADDRESS_MS                                       0x11
+
+/* A-XGMAC register and bit field definitions */
+#define R_XGMAC_CONFIG_0    0x00
+#define   O_XGMAC_CONFIG_0__hstmacrst               31
+#define   O_XGMAC_CONFIG_0__hstrstrctl              23
+#define   O_XGMAC_CONFIG_0__hstrstrfn               22
+#define   O_XGMAC_CONFIG_0__hstrsttctl              18
+#define   O_XGMAC_CONFIG_0__hstrsttfn               17
+#define   O_XGMAC_CONFIG_0__hstrstmiim              16
+#define   O_XGMAC_CONFIG_0__hstloopback             8
+#define R_XGMAC_CONFIG_1    0x01
+#define   O_XGMAC_CONFIG_1__hsttctlen               31
+#define   O_XGMAC_CONFIG_1__hsttfen                 30
+#define   O_XGMAC_CONFIG_1__hstrctlen               29
+#define   O_XGMAC_CONFIG_1__hstrfen                 28
+#define   O_XGMAC_CONFIG_1__tfen                    26
+#define   O_XGMAC_CONFIG_1__rfen                    24
+#define   O_XGMAC_CONFIG_1__hstrctlshrtp            12
+#define   O_XGMAC_CONFIG_1__hstdlyfcstx             10
+#define   W_XGMAC_CONFIG_1__hstdlyfcstx              2
+#define   O_XGMAC_CONFIG_1__hstdlyfcsrx              8
+#define   W_XGMAC_CONFIG_1__hstdlyfcsrx              2
+#define   O_XGMAC_CONFIG_1__hstppen                  7
+#define   O_XGMAC_CONFIG_1__hstbytswp                6
+#define   O_XGMAC_CONFIG_1__hstdrplt64               5
+#define   O_XGMAC_CONFIG_1__hstprmscrx               4
+#define   O_XGMAC_CONFIG_1__hstlenchk                3
+#define   O_XGMAC_CONFIG_1__hstgenfcs                2
+#define   O_XGMAC_CONFIG_1__hstpadmode               0
+#define   W_XGMAC_CONFIG_1__hstpadmode               2
+#define R_XGMAC_CONFIG_2    0x02
+#define   O_XGMAC_CONFIG_2__hsttctlfrcp             31
+#define   O_XGMAC_CONFIG_2__hstmlnkflth             27
+#define   O_XGMAC_CONFIG_2__hstalnkflth             26
+#define   O_XGMAC_CONFIG_2__rflnkflt                24
+#define   W_XGMAC_CONFIG_2__rflnkflt                 2
+#define   O_XGMAC_CONFIG_2__hstipgextmod            16
+#define   W_XGMAC_CONFIG_2__hstipgextmod             5
+#define   O_XGMAC_CONFIG_2__hstrctlfrcp             15
+#define   O_XGMAC_CONFIG_2__hstipgexten              5
+#define   O_XGMAC_CONFIG_2__hstmipgext               0
+#define   W_XGMAC_CONFIG_2__hstmipgext               5
+#define R_XGMAC_CONFIG_3    0x03
+#define   O_XGMAC_CONFIG_3__hstfltrfrm              31
+#define   W_XGMAC_CONFIG_3__hstfltrfrm              16
+#define   O_XGMAC_CONFIG_3__hstfltrfrmdc            15
+#define   W_XGMAC_CONFIG_3__hstfltrfrmdc            16
+#define R_XGMAC_STATION_ADDRESS_LS      0x04
+#define   O_XGMAC_STATION_ADDRESS_LS__hstmacadr0    0
+#define   W_XGMAC_STATION_ADDRESS_LS__hstmacadr0    32
+#define R_XGMAC_STATION_ADDRESS_MS      0x05
+#define R_XGMAC_MAX_FRAME_LEN           0x08
+#define   O_XGMAC_MAX_FRAME_LEN__hstmxfrmwctx       16
+#define   W_XGMAC_MAX_FRAME_LEN__hstmxfrmwctx       14
+#define   O_XGMAC_MAX_FRAME_LEN__hstmxfrmbcrx        0
+#define   W_XGMAC_MAX_FRAME_LEN__hstmxfrmbcrx       16
+#define R_XGMAC_REV_LEVEL               0x0B
+#define   O_XGMAC_REV_LEVEL__revlvl                  0
+#define   W_XGMAC_REV_LEVEL__revlvl                 15
+#define R_XGMAC_MIIM_COMMAND            0x10
+#define   O_XGMAC_MIIM_COMMAND__hstldcmd             3
+#define   O_XGMAC_MIIM_COMMAND__hstmiimcmd           0
+#define   W_XGMAC_MIIM_COMMAND__hstmiimcmd           3
+#define R_XGMAC_MIIM_FILED              0x11
+#define   O_XGMAC_MIIM_FILED__hststfield            30
+#define   W_XGMAC_MIIM_FILED__hststfield             2
+#define   O_XGMAC_MIIM_FILED__hstopfield            28
+#define   W_XGMAC_MIIM_FILED__hstopfield             2
+#define   O_XGMAC_MIIM_FILED__hstphyadx             23
+#define   W_XGMAC_MIIM_FILED__hstphyadx              5
+#define   O_XGMAC_MIIM_FILED__hstregadx             18
+#define   W_XGMAC_MIIM_FILED__hstregadx              5
+#define   O_XGMAC_MIIM_FILED__hsttafield            16
+#define   W_XGMAC_MIIM_FILED__hsttafield             2
+#define   O_XGMAC_MIIM_FILED__miimrddat              0
+#define   W_XGMAC_MIIM_FILED__miimrddat             16
+#define R_XGMAC_MIIM_CONFIG             0x12
+#define   O_XGMAC_MIIM_CONFIG__hstnopram             7
+#define   O_XGMAC_MIIM_CONFIG__hstclkdiv             0
+#define   W_XGMAC_MIIM_CONFIG__hstclkdiv             7
+#define R_XGMAC_MIIM_LINK_FAIL_VECTOR   0x13
+#define   O_XGMAC_MIIM_LINK_FAIL_VECTOR__miimlfvec   0
+#define   W_XGMAC_MIIM_LINK_FAIL_VECTOR__miimlfvec  32
+#define R_XGMAC_MIIM_INDICATOR          0x14
+#define   O_XGMAC_MIIM_INDICATOR__miimphylf          4
+#define   O_XGMAC_MIIM_INDICATOR__miimmoncplt        3
+#define   O_XGMAC_MIIM_INDICATOR__miimmonvld         2
+#define   O_XGMAC_MIIM_INDICATOR__miimmon            1
+#define   O_XGMAC_MIIM_INDICATOR__miimbusy           0
+
+/* Glue logic register and bit field definitions */
+#define R_MAC_ADDR0                                                 0x50
+#define R_MAC_ADDR1                                                 0x52
+#define R_MAC_ADDR2                                                 0x54
+#define R_MAC_ADDR3                                                 0x56
+#define R_MAC_ADDR_MASK2                                            0x58
+#define R_MAC_ADDR_MASK3                                            0x5A
+#define R_MAC_FILTER_CONFIG                                         0x5C
+#define   O_MAC_FILTER_CONFIG__BROADCAST_EN                         10
+#define   O_MAC_FILTER_CONFIG__PAUSE_FRAME_EN                       9
+#define   O_MAC_FILTER_CONFIG__ALL_MCAST_EN                         8
+#define   O_MAC_FILTER_CONFIG__ALL_UCAST_EN                         7
+#define   O_MAC_FILTER_CONFIG__HASH_MCAST_EN                        6
+#define   O_MAC_FILTER_CONFIG__HASH_UCAST_EN                        5
+#define   O_MAC_FILTER_CONFIG__ADDR_MATCH_DISC                      4
+#define   O_MAC_FILTER_CONFIG__MAC_ADDR3_VALID                      3
+#define   O_MAC_FILTER_CONFIG__MAC_ADDR2_VALID                      2
+#define   O_MAC_FILTER_CONFIG__MAC_ADDR1_VALID                      1
+#define   O_MAC_FILTER_CONFIG__MAC_ADDR0_VALID                      0
+#define R_HASH_TABLE_VECTOR                                         0x30
+#define R_TX_CONTROL                                                 0x0A0
+#define   O_TX_CONTROL__Tx15Halt                                     31
+#define   O_TX_CONTROL__Tx14Halt                                     30
+#define   O_TX_CONTROL__Tx13Halt                                     29
+#define   O_TX_CONTROL__Tx12Halt                                     28
+#define   O_TX_CONTROL__Tx11Halt                                     27
+#define   O_TX_CONTROL__Tx10Halt                                     26
+#define   O_TX_CONTROL__Tx9Halt                                      25
+#define   O_TX_CONTROL__Tx8Halt                                      24
+#define   O_TX_CONTROL__Tx7Halt                                      23
+#define   O_TX_CONTROL__Tx6Halt                                      22
+#define   O_TX_CONTROL__Tx5Halt                                      21
+#define   O_TX_CONTROL__Tx4Halt                                      20
+#define   O_TX_CONTROL__Tx3Halt                                      19
+#define   O_TX_CONTROL__Tx2Halt                                      18
+#define   O_TX_CONTROL__Tx1Halt                                      17
+#define   O_TX_CONTROL__Tx0Halt                                      16
+#define   O_TX_CONTROL__TxIdle                                       15
+#define   O_TX_CONTROL__TxEnable                                     14
+#define   O_TX_CONTROL__TxThreshold                                  0
+#define   W_TX_CONTROL__TxThreshold                                  14
+#define R_RX_CONTROL                                                 0x0A1
+#define   O_RX_1588_TS                                               11
+#define   O_RX_CONTROL__RGMII                                        10
+#define   O_RX_CONTROL__RxHalt                                       1
+#define   O_RX_CONTROL__RxEnable                                     0
+#define R_DESC_PACK_CTRL                                            0x0A2
+#define   O_DESC_PACK_CTRL__ByteOffset                              17
+#define   W_DESC_PACK_CTRL__ByteOffset                              3
+#define   O_DESC_PACK_CTRL__PrePadEnable                            16
+#define   O_DESC_PACK_CTRL__MaxEntry                                14
+#define   W_DESC_PACK_CTRL__MaxEntry                                2
+#define   O_DESC_PACK_CTRL__RegularSize                             0
+#define   W_DESC_PACK_CTRL__RegularSize                             14
+#define R_STATCTRL                                                  0x0A3
+#define   O_STATCTRL__OverFlowEn                                    4
+#define   O_STATCTRL__GIG                                           3
+#define   O_STATCTRL__Sten                                          2
+#define   O_STATCTRL__ClrCnt                                        1
+#define   O_STATCTRL__AutoZ                                         0
+#define R_L2ALLOCCTRL                                               0x0A4
+#define   O_L2ALLOCCTRL__TxL2Allocate                               9
+#define   W_L2ALLOCCTRL__TxL2Allocate                               9
+#define   O_L2ALLOCCTRL__RxL2Allocate                               0
+#define   W_L2ALLOCCTRL__RxL2Allocate                               9
+#define R_INTMASK                                                   0x0A5
+#define   O_INTMASK__Spi4TxError                                     28
+#define   O_INTMASK__Spi4RxError                                     27
+#define   O_INTMASK__RGMIIHalfDupCollision                           27
+#define   O_INTMASK__Abort                                           26
+#define   O_INTMASK__Underrun                                        25
+#define   O_INTMASK__DiscardPacket                                   24
+#define   O_INTMASK__AsyncFifoFull                                   23
+#define   O_INTMASK__TagFull                                         22
+#define   O_INTMASK__Class3Full                                      21
+#define   O_INTMASK__C3EarlyFull                                     20
+#define   O_INTMASK__Class2Full                                      19
+#define   O_INTMASK__C2EarlyFull                                     18
+#define   O_INTMASK__Class1Full                                      17
+#define   O_INTMASK__C1EarlyFull                                     16
+#define   O_INTMASK__Class0Full                                      15
+#define   O_INTMASK__C0EarlyFull                                     14
+#define   O_INTMASK__RxDataFull                                      13
+#define   O_INTMASK__RxEarlyFull                                     12
+#define   O_INTMASK__RFreeEmpty                                      9
+#define   O_INTMASK__RFEarlyEmpty                                    8
+#define   O_INTMASK__P2PSpillEcc                                     7
+#define   O_INTMASK__FreeDescFull                                    5
+#define   O_INTMASK__FreeEarlyFull                                   4
+#define   O_INTMASK__TxFetchError                                    3
+#define   O_INTMASK__StatCarry                                       2
+#define   O_INTMASK__MDInt                                           1
+#define   O_INTMASK__TxIllegal                                       0
+#define R_INTREG                                                    0x0A6
+#define   O_INTREG__Spi4TxError                                     28
+#define   O_INTREG__Spi4RxError                                     27
+#define   O_INTREG__RGMIIHalfDupCollision                           27
+#define   O_INTREG__Abort                                           26
+#define   O_INTREG__Underrun                                        25
+#define   O_INTREG__DiscardPacket                                   24
+#define   O_INTREG__AsyncFifoFull                                   23
+#define   O_INTREG__TagFull                                         22
+#define   O_INTREG__Class3Full                                      21
+#define   O_INTREG__C3EarlyFull                                     20
+#define   O_INTREG__Class2Full                                      19
+#define   O_INTREG__C2EarlyFull                                     18
+#define   O_INTREG__Class1Full                                      17
+#define   O_INTREG__C1EarlyFull                                     16
+#define   O_INTREG__Class0Full                                      15
+#define   O_INTREG__C0EarlyFull                                     14
+#define   O_INTREG__RxDataFull                                      13
+#define   O_INTREG__RxEarlyFull                                     12
+#define   O_INTREG__RFreeEmpty                                      9
+#define   O_INTREG__RFEarlyEmpty                                    8
+#define   O_INTREG__P2PSpillEcc                                     7
+#define   O_INTREG__FreeDescFull                                    5
+#define   O_INTREG__FreeEarlyFull                                   4
+#define   O_INTREG__TxFetchError                                    3
+#define   O_INTREG__StatCarry                                       2
+#define   O_INTREG__MDInt                                           1
+#define   O_INTREG__TxIllegal                                       0
+#define R_TXRETRY                                                   0x0A7
+#define   O_TXRETRY__CollisionRetry                                 6
+#define   O_TXRETRY__BusErrorRetry                                  5
+#define   O_TXRETRY__UnderRunRetry                                  4
+#define   O_TXRETRY__Retries                                        0
+#define   W_TXRETRY__Retries                                        4
+#define R_CORECONTROL                                               0x0A8
+#define   O_CORECONTROL__ErrorThread                                4
+#define   W_CORECONTROL__ErrorThread                                7
+#define   O_CORECONTROL__Shutdown                                   2
+#define   O_CORECONTROL__Speed                                      0
+#define   W_CORECONTROL__Speed                                      2
+#define R_BYTEOFFSET0                                               0x0A9
+#define R_BYTEOFFSET1                                               0x0AA
+#define R_L2TYPE_0                                                  0x0F0
+#define   O_L2TYPE__ExtraHdrProtoSize                               26
+#define   W_L2TYPE__ExtraHdrProtoSize                               5
+#define   O_L2TYPE__ExtraHdrProtoOffset                             20
+#define   W_L2TYPE__ExtraHdrProtoOffset                             6
+#define   O_L2TYPE__ExtraHeaderSize                                 14
+#define   W_L2TYPE__ExtraHeaderSize                                 6
+#define   O_L2TYPE__ProtoOffset                                     8
+#define   W_L2TYPE__ProtoOffset                                     6
+#define   O_L2TYPE__L2HdrOffset                                     2
+#define   W_L2TYPE__L2HdrOffset                                     6
+#define   O_L2TYPE__L2Proto                                         0
+#define   W_L2TYPE__L2Proto                                         2
+#define R_L2TYPE_1                                                  0xF0
+#define R_L2TYPE_2                                                  0xF0
+#define R_L2TYPE_3                                                  0xF0
+#define R_PARSERCONFIGREG                                           0x100
+#define   O_PARSERCONFIGREG__CRCHashPoly                            8
+#define   W_PARSERCONFIGREG__CRCHashPoly                            7
+#define   O_PARSERCONFIGREG__PrePadOffset                           4
+#define   W_PARSERCONFIGREG__PrePadOffset                           4
+#define   O_PARSERCONFIGREG__UseCAM                                 2
+#define   O_PARSERCONFIGREG__UseHASH                                1
+#define   O_PARSERCONFIGREG__UseProto                               0
+#define R_L3CTABLE                                                  0x140
+#define   O_L3CTABLE__Offset0                                       25
+#define   W_L3CTABLE__Offset0                                       7
+#define   O_L3CTABLE__Len0                                          21
+#define   W_L3CTABLE__Len0                                          4
+#define   O_L3CTABLE__Offset1                                       14
+#define   W_L3CTABLE__Offset1                                       7
+#define   O_L3CTABLE__Len1                                          10
+#define   W_L3CTABLE__Len1                                          4
+#define   O_L3CTABLE__Offset2                                       4
+#define   W_L3CTABLE__Offset2                                       6
+#define   O_L3CTABLE__Len2                                          0
+#define   W_L3CTABLE__Len2                                          4
+#define   O_L3CTABLE__L3HdrOffset                                   26
+#define   W_L3CTABLE__L3HdrOffset                                   6
+#define   O_L3CTABLE__L4ProtoOffset                                 20
+#define   W_L3CTABLE__L4ProtoOffset                                 6
+#define   O_L3CTABLE__IPChksumCompute                               19
+#define   O_L3CTABLE__L4Classify                                    18
+#define   O_L3CTABLE__L2Proto                                       16
+#define   W_L3CTABLE__L2Proto                                       2
+#define   O_L3CTABLE__L3ProtoKey                                    0
+#define   W_L3CTABLE__L3ProtoKey                                    16
+#define R_L4CTABLE                                                  0x160
+#define   O_L4CTABLE__Offset0                                       21
+#define   W_L4CTABLE__Offset0                                       6
+#define   O_L4CTABLE__Len0                                          17
+#define   W_L4CTABLE__Len0                                          4
+#define   O_L4CTABLE__Offset1                                       11
+#define   W_L4CTABLE__Offset1                                       6
+#define   O_L4CTABLE__Len1                                          7
+#define   W_L4CTABLE__Len1                                          4
+#define   O_L4CTABLE__TCPChksumEnable                               0
+#define R_CAM4X128TABLE                                             0x172
+#define   O_CAM4X128TABLE__ClassId                                  7
+#define   W_CAM4X128TABLE__ClassId                                  2
+#define   O_CAM4X128TABLE__BucketId                                 1
+#define   W_CAM4X128TABLE__BucketId                                 6
+#define   O_CAM4X128TABLE__UseBucket                                0
+#define R_CAM4X128KEY                                               0x180
+#define R_TRANSLATETABLE                                            0x1A0
+#define R_DMACR0                                                    0x200
+#define   O_DMACR0__Data0WrMaxCr                                    27
+#define   W_DMACR0__Data0WrMaxCr                                    3
+#define   O_DMACR0__Data0RdMaxCr                                    24
+#define   W_DMACR0__Data0RdMaxCr                                    3
+#define   O_DMACR0__Data1WrMaxCr                                    21
+#define   W_DMACR0__Data1WrMaxCr                                    3
+#define   O_DMACR0__Data1RdMaxCr                                    18
+#define   W_DMACR0__Data1RdMaxCr                                    3
+#define   O_DMACR0__Data2WrMaxCr                                    15
+#define   W_DMACR0__Data2WrMaxCr                                    3
+#define   O_DMACR0__Data2RdMaxCr                                    12
+#define   W_DMACR0__Data2RdMaxCr                                    3
+#define   O_DMACR0__Data3WrMaxCr                                    9
+#define   W_DMACR0__Data3WrMaxCr                                    3
+#define   O_DMACR0__Data3RdMaxCr                                    6
+#define   W_DMACR0__Data3RdMaxCr                                    3
+#define   O_DMACR0__Data4WrMaxCr                                    3
+#define   W_DMACR0__Data4WrMaxCr                                    3
+#define   O_DMACR0__Data4RdMaxCr                                    0
+#define   W_DMACR0__Data4RdMaxCr                                    3
+#define R_DMACR1                                                    0x201
+#define   O_DMACR1__Data5WrMaxCr                                    27
+#define   W_DMACR1__Data5WrMaxCr                                    3
+#define   O_DMACR1__Data5RdMaxCr                                    24
+#define   W_DMACR1__Data5RdMaxCr                                    3
+#define   O_DMACR1__Data6WrMaxCr                                    21
+#define   W_DMACR1__Data6WrMaxCr                                    3
+#define   O_DMACR1__Data6RdMaxCr                                    18
+#define   W_DMACR1__Data6RdMaxCr                                    3
+#define   O_DMACR1__Data7WrMaxCr                                    15
+#define   W_DMACR1__Data7WrMaxCr                                    3
+#define   O_DMACR1__Data7RdMaxCr                                    12
+#define   W_DMACR1__Data7RdMaxCr                                    3
+#define   O_DMACR1__Data8WrMaxCr                                    9
+#define   W_DMACR1__Data8WrMaxCr                                    3
+#define   O_DMACR1__Data8RdMaxCr                                    6
+#define   W_DMACR1__Data8RdMaxCr                                    3
+#define   O_DMACR1__Data9WrMaxCr                                    3
+#define   W_DMACR1__Data9WrMaxCr                                    3
+#define   O_DMACR1__Data9RdMaxCr                                    0
+#define   W_DMACR1__Data9RdMaxCr                                    3
+#define R_DMACR2                                                    0x202
+#define   O_DMACR2__Data10WrMaxCr                                   27
+#define   W_DMACR2__Data10WrMaxCr                                   3
+#define   O_DMACR2__Data10RdMaxCr                                   24
+#define   W_DMACR2__Data10RdMaxCr                                   3
+#define   O_DMACR2__Data11WrMaxCr                                   21
+#define   W_DMACR2__Data11WrMaxCr                                   3
+#define   O_DMACR2__Data11RdMaxCr                                   18
+#define   W_DMACR2__Data11RdMaxCr                                   3
+#define   O_DMACR2__Data12WrMaxCr                                   15
+#define   W_DMACR2__Data12WrMaxCr                                   3
+#define   O_DMACR2__Data12RdMaxCr                                   12
+#define   W_DMACR2__Data12RdMaxCr                                   3
+#define   O_DMACR2__Data13WrMaxCr                                   9
+#define   W_DMACR2__Data13WrMaxCr                                   3
+#define   O_DMACR2__Data13RdMaxCr                                   6
+#define   W_DMACR2__Data13RdMaxCr                                   3
+#define   O_DMACR2__Data14WrMaxCr                                   3
+#define   W_DMACR2__Data14WrMaxCr                                   3
+#define   O_DMACR2__Data14RdMaxCr                                   0
+#define   W_DMACR2__Data14RdMaxCr                                   3
+#define R_DMACR3                                                    0x203
+#define   O_DMACR3__Data15WrMaxCr                                   27
+#define   W_DMACR3__Data15WrMaxCr                                   3
+#define   O_DMACR3__Data15RdMaxCr                                   24
+#define   W_DMACR3__Data15RdMaxCr                                   3
+#define   O_DMACR3__SpClassWrMaxCr                                  21
+#define   W_DMACR3__SpClassWrMaxCr                                  3
+#define   O_DMACR3__SpClassRdMaxCr                                  18
+#define   W_DMACR3__SpClassRdMaxCr                                  3
+#define   O_DMACR3__JumFrInWrMaxCr                                  15
+#define   W_DMACR3__JumFrInWrMaxCr                                  3
+#define   O_DMACR3__JumFrInRdMaxCr                                  12
+#define   W_DMACR3__JumFrInRdMaxCr                                  3
+#define   O_DMACR3__RegFrInWrMaxCr                                  9
+#define   W_DMACR3__RegFrInWrMaxCr                                  3
+#define   O_DMACR3__RegFrInRdMaxCr                                  6
+#define   W_DMACR3__RegFrInRdMaxCr                                  3
+#define   O_DMACR3__FrOutWrMaxCr                                    3
+#define   W_DMACR3__FrOutWrMaxCr                                    3
+#define   O_DMACR3__FrOutRdMaxCr                                    0
+#define   W_DMACR3__FrOutRdMaxCr                                    3
+#define R_REG_FRIN_SPILL_MEM_START_0                                0x204
+#define   O_REG_FRIN_SPILL_MEM_START_0__RegFrInSpillMemStart0        0
+#define   W_REG_FRIN_SPILL_MEM_START_0__RegFrInSpillMemStart0       32
+#define R_REG_FRIN_SPILL_MEM_START_1                                0x205
+#define   O_REG_FRIN_SPILL_MEM_START_1__RegFrInSpillMemStart1        0
+#define   W_REG_FRIN_SPILL_MEM_START_1__RegFrInSpillMemStart1        3
+#define R_REG_FRIN_SPILL_MEM_SIZE                                   0x206
+#define   O_REG_FRIN_SPILL_MEM_SIZE__RegFrInSpillMemSize             0
+#define   W_REG_FRIN_SPILL_MEM_SIZE__RegFrInSpillMemSize            32
+#define R_FROUT_SPILL_MEM_START_0                                   0x207
+#define   O_FROUT_SPILL_MEM_START_0__FrOutSpillMemStart0             0
+#define   W_FROUT_SPILL_MEM_START_0__FrOutSpillMemStart0            32
+#define R_FROUT_SPILL_MEM_START_1                                   0x208
+#define   O_FROUT_SPILL_MEM_START_1__FrOutSpillMemStart1             0
+#define   W_FROUT_SPILL_MEM_START_1__FrOutSpillMemStart1             3
+#define R_FROUT_SPILL_MEM_SIZE                                      0x209
+#define   O_FROUT_SPILL_MEM_SIZE__FrOutSpillMemSize                  0
+#define   W_FROUT_SPILL_MEM_SIZE__FrOutSpillMemSize                 32
+#define R_CLASS0_SPILL_MEM_START_0                                  0x20A
+#define   O_CLASS0_SPILL_MEM_START_0__Class0SpillMemStart0           0
+#define   W_CLASS0_SPILL_MEM_START_0__Class0SpillMemStart0          32
+#define R_CLASS0_SPILL_MEM_START_1                                  0x20B
+#define   O_CLASS0_SPILL_MEM_START_1__Class0SpillMemStart1           0
+#define   W_CLASS0_SPILL_MEM_START_1__Class0SpillMemStart1           3
+#define R_CLASS0_SPILL_MEM_SIZE                                     0x20C
+#define   O_CLASS0_SPILL_MEM_SIZE__Class0SpillMemSize                0
+#define   W_CLASS0_SPILL_MEM_SIZE__Class0SpillMemSize               32
+#define R_JUMFRIN_SPILL_MEM_START_0                                 0x20D
+#define   O_JUMFRIN_SPILL_MEM_START_0__JumFrInSpillMemStar0          0
+#define   W_JUMFRIN_SPILL_MEM_START_0__JumFrInSpillMemStar0         32
+#define R_JUMFRIN_SPILL_MEM_START_1                                 0x20E
+#define   O_JUMFRIN_SPILL_MEM_START_1__JumFrInSpillMemStart1         0
+#define   W_JUMFRIN_SPILL_MEM_START_1__JumFrInSpillMemStart1         3
+#define R_JUMFRIN_SPILL_MEM_SIZE                                    0x20F
+#define   O_JUMFRIN_SPILL_MEM_SIZE__JumFrInSpillMemSize              0
+#define   W_JUMFRIN_SPILL_MEM_SIZE__JumFrInSpillMemSize             32
+#define R_CLASS1_SPILL_MEM_START_0                                  0x210
+#define   O_CLASS1_SPILL_MEM_START_0__Class1SpillMemStart0           0
+#define   W_CLASS1_SPILL_MEM_START_0__Class1SpillMemStart0          32
+#define R_CLASS1_SPILL_MEM_START_1                                  0x211
+#define   O_CLASS1_SPILL_MEM_START_1__Class1SpillMemStart1           0
+#define   W_CLASS1_SPILL_MEM_START_1__Class1SpillMemStart1           3
+#define R_CLASS1_SPILL_MEM_SIZE                                     0x212
+#define   O_CLASS1_SPILL_MEM_SIZE__Class1SpillMemSize                0
+#define   W_CLASS1_SPILL_MEM_SIZE__Class1SpillMemSize               32
+#define R_CLASS2_SPILL_MEM_START_0                                  0x213
+#define   O_CLASS2_SPILL_MEM_START_0__Class2SpillMemStart0           0
+#define   W_CLASS2_SPILL_MEM_START_0__Class2SpillMemStart0          32
+#define R_CLASS2_SPILL_MEM_START_1                                  0x214
+#define   O_CLASS2_SPILL_MEM_START_1__Class2SpillMemStart1           0
+#define   W_CLASS2_SPILL_MEM_START_1__Class2SpillMemStart1           3
+#define R_CLASS2_SPILL_MEM_SIZE                                     0x215
+#define   O_CLASS2_SPILL_MEM_SIZE__Class2SpillMemSize                0
+#define   W_CLASS2_SPILL_MEM_SIZE__Class2SpillMemSize               32
+#define R_CLASS3_SPILL_MEM_START_0                                  0x216
+#define   O_CLASS3_SPILL_MEM_START_0__Class3SpillMemStart0           0
+#define   W_CLASS3_SPILL_MEM_START_0__Class3SpillMemStart0          32
+#define R_CLASS3_SPILL_MEM_START_1                                  0x217
+#define   O_CLASS3_SPILL_MEM_START_1__Class3SpillMemStart1           0
+#define   W_CLASS3_SPILL_MEM_START_1__Class3SpillMemStart1           3
+#define R_CLASS3_SPILL_MEM_SIZE                                     0x218
+#define   O_CLASS3_SPILL_MEM_SIZE__Class3SpillMemSize                0
+#define   W_CLASS3_SPILL_MEM_SIZE__Class3SpillMemSize               32
+#define R_REG_FRIN1_SPILL_MEM_START_0                               0x219
+#define R_REG_FRIN1_SPILL_MEM_START_1                               0x21a
+#define R_REG_FRIN1_SPILL_MEM_SIZE                                  0x21b
+#define R_SPIHNGY0                                                  0x219
+#define   O_SPIHNGY0__EG_HNGY_THRESH_0                              24
+#define   W_SPIHNGY0__EG_HNGY_THRESH_0                              7
+#define   O_SPIHNGY0__EG_HNGY_THRESH_1                              16
+#define   W_SPIHNGY0__EG_HNGY_THRESH_1                              7
+#define   O_SPIHNGY0__EG_HNGY_THRESH_2                              8
+#define   W_SPIHNGY0__EG_HNGY_THRESH_2                              7
+#define   O_SPIHNGY0__EG_HNGY_THRESH_3                              0
+#define   W_SPIHNGY0__EG_HNGY_THRESH_3                              7
+#define R_SPIHNGY1                                                  0x21A
+#define   O_SPIHNGY1__EG_HNGY_THRESH_4                              24
+#define   W_SPIHNGY1__EG_HNGY_THRESH_4                              7
+#define   O_SPIHNGY1__EG_HNGY_THRESH_5                              16
+#define   W_SPIHNGY1__EG_HNGY_THRESH_5                              7
+#define   O_SPIHNGY1__EG_HNGY_THRESH_6                              8
+#define   W_SPIHNGY1__EG_HNGY_THRESH_6                              7
+#define   O_SPIHNGY1__EG_HNGY_THRESH_7                              0
+#define   W_SPIHNGY1__EG_HNGY_THRESH_7                              7
+#define R_SPIHNGY2                                                  0x21B
+#define   O_SPIHNGY2__EG_HNGY_THRESH_8                              24
+#define   W_SPIHNGY2__EG_HNGY_THRESH_8                              7
+#define   O_SPIHNGY2__EG_HNGY_THRESH_9                              16
+#define   W_SPIHNGY2__EG_HNGY_THRESH_9                              7
+#define   O_SPIHNGY2__EG_HNGY_THRESH_10                             8
+#define   W_SPIHNGY2__EG_HNGY_THRESH_10                             7
+#define   O_SPIHNGY2__EG_HNGY_THRESH_11                             0
+#define   W_SPIHNGY2__EG_HNGY_THRESH_11                             7
+#define R_SPIHNGY3                                                  0x21C
+#define   O_SPIHNGY3__EG_HNGY_THRESH_12                             24
+#define   W_SPIHNGY3__EG_HNGY_THRESH_12                             7
+#define   O_SPIHNGY3__EG_HNGY_THRESH_13                             16
+#define   W_SPIHNGY3__EG_HNGY_THRESH_13                             7
+#define   O_SPIHNGY3__EG_HNGY_THRESH_14                             8
+#define   W_SPIHNGY3__EG_HNGY_THRESH_14                             7
+#define   O_SPIHNGY3__EG_HNGY_THRESH_15                             0
+#define   W_SPIHNGY3__EG_HNGY_THRESH_15                             7
+#define R_SPISTRV0                                                  0x21D
+#define   O_SPISTRV0__EG_STRV_THRESH_0                              24
+#define   W_SPISTRV0__EG_STRV_THRESH_0                              7
+#define   O_SPISTRV0__EG_STRV_THRESH_1                              16
+#define   W_SPISTRV0__EG_STRV_THRESH_1                              7
+#define   O_SPISTRV0__EG_STRV_THRESH_2                              8
+#define   W_SPISTRV0__EG_STRV_THRESH_2                              7
+#define   O_SPISTRV0__EG_STRV_THRESH_3                              0
+#define   W_SPISTRV0__EG_STRV_THRESH_3                              7
+#define R_SPISTRV1                                                  0x21E
+#define   O_SPISTRV1__EG_STRV_THRESH_4                              24
+#define   W_SPISTRV1__EG_STRV_THRESH_4                              7
+#define   O_SPISTRV1__EG_STRV_THRESH_5                              16
+#define   W_SPISTRV1__EG_STRV_THRESH_5                              7
+#define   O_SPISTRV1__EG_STRV_THRESH_6                              8
+#define   W_SPISTRV1__EG_STRV_THRESH_6                              7
+#define   O_SPISTRV1__EG_STRV_THRESH_7                              0
+#define   W_SPISTRV1__EG_STRV_THRESH_7                              7
+#define R_SPISTRV2                                                  0x21F
+#define   O_SPISTRV2__EG_STRV_THRESH_8                              24
+#define   W_SPISTRV2__EG_STRV_THRESH_8                              7
+#define   O_SPISTRV2__EG_STRV_THRESH_9                              16
+#define   W_SPISTRV2__EG_STRV_THRESH_9                              7
+#define   O_SPISTRV2__EG_STRV_THRESH_10                             8
+#define   W_SPISTRV2__EG_STRV_THRESH_10                             7
+#define   O_SPISTRV2__EG_STRV_THRESH_11                             0
+#define   W_SPISTRV2__EG_STRV_THRESH_11                             7
+#define R_SPISTRV3                                                  0x220
+#define   O_SPISTRV3__EG_STRV_THRESH_12                             24
+#define   W_SPISTRV3__EG_STRV_THRESH_12                             7
+#define   O_SPISTRV3__EG_STRV_THRESH_13                             16
+#define   W_SPISTRV3__EG_STRV_THRESH_13                             7
+#define   O_SPISTRV3__EG_STRV_THRESH_14                             8
+#define   W_SPISTRV3__EG_STRV_THRESH_14                             7
+#define   O_SPISTRV3__EG_STRV_THRESH_15                             0
+#define   W_SPISTRV3__EG_STRV_THRESH_15                             7
+#define R_TXDATAFIFO0                                               0x221
+#define   O_TXDATAFIFO0__Tx0DataFifoStart                           24
+#define   W_TXDATAFIFO0__Tx0DataFifoStart                           7
+#define   O_TXDATAFIFO0__Tx0DataFifoSize                            16
+#define   W_TXDATAFIFO0__Tx0DataFifoSize                            7
+#define   O_TXDATAFIFO0__Tx1DataFifoStart                           8
+#define   W_TXDATAFIFO0__Tx1DataFifoStart                           7
+#define   O_TXDATAFIFO0__Tx1DataFifoSize                            0
+#define   W_TXDATAFIFO0__Tx1DataFifoSize                            7
+#define R_TXDATAFIFO1                                               0x222
+#define   O_TXDATAFIFO1__Tx2DataFifoStart                           24
+#define   W_TXDATAFIFO1__Tx2DataFifoStart                           7
+#define   O_TXDATAFIFO1__Tx2DataFifoSize                            16
+#define   W_TXDATAFIFO1__Tx2DataFifoSize                            7
+#define   O_TXDATAFIFO1__Tx3DataFifoStart                           8
+#define   W_TXDATAFIFO1__Tx3DataFifoStart                           7
+#define   O_TXDATAFIFO1__Tx3DataFifoSize                            0
+#define   W_TXDATAFIFO1__Tx3DataFifoSize                            7
+#define R_TXDATAFIFO2                                               0x223
+#define   O_TXDATAFIFO2__Tx4DataFifoStart                           24
+#define   W_TXDATAFIFO2__Tx4DataFifoStart                           7
+#define   O_TXDATAFIFO2__Tx4DataFifoSize                            16
+#define   W_TXDATAFIFO2__Tx4DataFifoSize                            7
+#define   O_TXDATAFIFO2__Tx5DataFifoStart                           8
+#define   W_TXDATAFIFO2__Tx5DataFifoStart                           7
+#define   O_TXDATAFIFO2__Tx5DataFifoSize                            0
+#define   W_TXDATAFIFO2__Tx5DataFifoSize                            7
+#define R_TXDATAFIFO3                                               0x224
+#define   O_TXDATAFIFO3__Tx6DataFifoStart                           24
+#define   W_TXDATAFIFO3__Tx6DataFifoStart                           7
+#define   O_TXDATAFIFO3__Tx6DataFifoSize                            16
+#define   W_TXDATAFIFO3__Tx6DataFifoSize                            7
+#define   O_TXDATAFIFO3__Tx7DataFifoStart                           8
+#define   W_TXDATAFIFO3__Tx7DataFifoStart                           7
+#define   O_TXDATAFIFO3__Tx7DataFifoSize                            0
+#define   W_TXDATAFIFO3__Tx7DataFifoSize                            7
+#define R_TXDATAFIFO4                                               0x225
+#define   O_TXDATAFIFO4__Tx8DataFifoStart                           24
+#define   W_TXDATAFIFO4__Tx8DataFifoStart                           7
+#define   O_TXDATAFIFO4__Tx8DataFifoSize                            16
+#define   W_TXDATAFIFO4__Tx8DataFifoSize                            7
+#define   O_TXDATAFIFO4__Tx9DataFifoStart                           8
+#define   W_TXDATAFIFO4__Tx9DataFifoStart                           7
+#define   O_TXDATAFIFO4__Tx9DataFifoSize                            0
+#define   W_TXDATAFIFO4__Tx9DataFifoSize                            7
+#define R_TXDATAFIFO5                                               0x226
+#define   O_TXDATAFIFO5__Tx10DataFifoStart                          24
+#define   W_TXDATAFIFO5__Tx10DataFifoStart                          7
+#define   O_TXDATAFIFO5__Tx10DataFifoSize                           16
+#define   W_TXDATAFIFO5__Tx10DataFifoSize                           7
+#define   O_TXDATAFIFO5__Tx11DataFifoStart                          8
+#define   W_TXDATAFIFO5__Tx11DataFifoStart                          7
+#define   O_TXDATAFIFO5__Tx11DataFifoSize                           0
+#define   W_TXDATAFIFO5__Tx11DataFifoSize                           7
+#define R_TXDATAFIFO6                                               0x227
+#define   O_TXDATAFIFO6__Tx12DataFifoStart                          24
+#define   W_TXDATAFIFO6__Tx12DataFifoStart                          7
+#define   O_TXDATAFIFO6__Tx12DataFifoSize                           16
+#define   W_TXDATAFIFO6__Tx12DataFifoSize                           7
+#define   O_TXDATAFIFO6__Tx13DataFifoStart                          8
+#define   W_TXDATAFIFO6__Tx13DataFifoStart                          7
+#define   O_TXDATAFIFO6__Tx13DataFifoSize                           0
+#define   W_TXDATAFIFO6__Tx13DataFifoSize                           7
+#define R_TXDATAFIFO7                                               0x228
+#define   O_TXDATAFIFO7__Tx14DataFifoStart                          24
+#define   W_TXDATAFIFO7__Tx14DataFifoStart                          7
+#define   O_TXDATAFIFO7__Tx14DataFifoSize                           16
+#define   W_TXDATAFIFO7__Tx14DataFifoSize                           7
+#define   O_TXDATAFIFO7__Tx15DataFifoStart                          8
+#define   W_TXDATAFIFO7__Tx15DataFifoStart                          7
+#define   O_TXDATAFIFO7__Tx15DataFifoSize                           0
+#define   W_TXDATAFIFO7__Tx15DataFifoSize                           7
+#define R_RXDATAFIFO0                                               0x229
+#define   O_RXDATAFIFO0__Rx0DataFifoStart                           24
+#define   W_RXDATAFIFO0__Rx0DataFifoStart                           7
+#define   O_RXDATAFIFO0__Rx0DataFifoSize                            16
+#define   W_RXDATAFIFO0__Rx0DataFifoSize                            7
+#define   O_RXDATAFIFO0__Rx1DataFifoStart                           8
+#define   W_RXDATAFIFO0__Rx1DataFifoStart                           7
+#define   O_RXDATAFIFO0__Rx1DataFifoSize                            0
+#define   W_RXDATAFIFO0__Rx1DataFifoSize                            7
+#define R_RXDATAFIFO1                                               0x22A
+#define   O_RXDATAFIFO1__Rx2DataFifoStart                           24
+#define   W_RXDATAFIFO1__Rx2DataFifoStart                           7
+#define   O_RXDATAFIFO1__Rx2DataFifoSize                            16
+#define   W_RXDATAFIFO1__Rx2DataFifoSize                            7
+#define   O_RXDATAFIFO1__Rx3DataFifoStart                           8
+#define   W_RXDATAFIFO1__Rx3DataFifoStart                           7
+#define   O_RXDATAFIFO1__Rx3DataFifoSize                            0
+#define   W_RXDATAFIFO1__Rx3DataFifoSize                            7
+#define R_RXDATAFIFO2                                               0x22B
+#define   O_RXDATAFIFO2__Rx4DataFifoStart                           24
+#define   W_RXDATAFIFO2__Rx4DataFifoStart                           7
+#define   O_RXDATAFIFO2__Rx4DataFifoSize                            16
+#define   W_RXDATAFIFO2__Rx4DataFifoSize                            7
+#define   O_RXDATAFIFO2__Rx5DataFifoStart                           8
+#define   W_RXDATAFIFO2__Rx5DataFifoStart                           7
+#define   O_RXDATAFIFO2__Rx5DataFifoSize                            0
+#define   W_RXDATAFIFO2__Rx5DataFifoSize                            7
+#define R_RXDATAFIFO3                                               0x22C
+#define   O_RXDATAFIFO3__Rx6DataFifoStart                           24
+#define   W_RXDATAFIFO3__Rx6DataFifoStart                           7
+#define   O_RXDATAFIFO3__Rx6DataFifoSize                            16
+#define   W_RXDATAFIFO3__Rx6DataFifoSize                            7
+#define   O_RXDATAFIFO3__Rx7DataFifoStart                           8
+#define   W_RXDATAFIFO3__Rx7DataFifoStart                           7
+#define   O_RXDATAFIFO3__Rx7DataFifoSize                            0
+#define   W_RXDATAFIFO3__Rx7DataFifoSize                            7
+#define R_RXDATAFIFO4                                               0x22D
+#define   O_RXDATAFIFO4__Rx8DataFifoStart                           24
+#define   W_RXDATAFIFO4__Rx8DataFifoStart                           7
+#define   O_RXDATAFIFO4__Rx8DataFifoSize                            16
+#define   W_RXDATAFIFO4__Rx8DataFifoSize                            7
+#define   O_RXDATAFIFO4__Rx9DataFifoStart                           8
+#define   W_RXDATAFIFO4__Rx9DataFifoStart                           7
+#define   O_RXDATAFIFO4__Rx9DataFifoSize                            0
+#define   W_RXDATAFIFO4__Rx9DataFifoSize                            7
+#define R_RXDATAFIFO5                                               0x22E
+#define   O_RXDATAFIFO5__Rx10DataFifoStart                          24
+#define   W_RXDATAFIFO5__Rx10DataFifoStart                          7
+#define   O_RXDATAFIFO5__Rx10DataFifoSize                           16
+#define   W_RXDATAFIFO5__Rx10DataFifoSize                           7
+#define   O_RXDATAFIFO5__Rx11DataFifoStart                          8
+#define   W_RXDATAFIFO5__Rx11DataFifoStart                          7
+#define   O_RXDATAFIFO5__Rx11DataFifoSize                           0
+#define   W_RXDATAFIFO5__Rx11DataFifoSize                           7
+#define R_RXDATAFIFO6                                               0x22F
+#define   O_RXDATAFIFO6__Rx12DataFifoStart                          24
+#define   W_RXDATAFIFO6__Rx12DataFifoStart                          7
+#define   O_RXDATAFIFO6__Rx12DataFifoSize                           16
+#define   W_RXDATAFIFO6__Rx12DataFifoSize                           7
+#define   O_RXDATAFIFO6__Rx13DataFifoStart                          8
+#define   W_RXDATAFIFO6__Rx13DataFifoStart                          7
+#define   O_RXDATAFIFO6__Rx13DataFifoSize                           0
+#define   W_RXDATAFIFO6__Rx13DataFifoSize                           7
+#define R_RXDATAFIFO7                                               0x230
+#define   O_RXDATAFIFO7__Rx14DataFifoStart                          24
+#define   W_RXDATAFIFO7__Rx14DataFifoStart                          7
+#define   O_RXDATAFIFO7__Rx14DataFifoSize                           16
+#define   W_RXDATAFIFO7__Rx14DataFifoSize                           7
+#define   O_RXDATAFIFO7__Rx15DataFifoStart                          8
+#define   W_RXDATAFIFO7__Rx15DataFifoStart                          7
+#define   O_RXDATAFIFO7__Rx15DataFifoSize                           0
+#define   W_RXDATAFIFO7__Rx15DataFifoSize                           7
+#define R_XGMACPADCALIBRATION                                       0x231
+#define R_FREEQCARVE                                                0x233
+#define R_SPI4STATICDELAY0                                          0x240
+#define   O_SPI4STATICDELAY0__DataLine7                             28
+#define   W_SPI4STATICDELAY0__DataLine7                             4
+#define   O_SPI4STATICDELAY0__DataLine6                             24
+#define   W_SPI4STATICDELAY0__DataLine6                             4
+#define   O_SPI4STATICDELAY0__DataLine5                             20
+#define   W_SPI4STATICDELAY0__DataLine5                             4
+#define   O_SPI4STATICDELAY0__DataLine4                             16
+#define   W_SPI4STATICDELAY0__DataLine4                             4
+#define   O_SPI4STATICDELAY0__DataLine3                             12
+#define   W_SPI4STATICDELAY0__DataLine3                             4
+#define   O_SPI4STATICDELAY0__DataLine2                             8
+#define   W_SPI4STATICDELAY0__DataLine2                             4
+#define   O_SPI4STATICDELAY0__DataLine1                             4
+#define   W_SPI4STATICDELAY0__DataLine1                             4
+#define   O_SPI4STATICDELAY0__DataLine0                             0
+#define   W_SPI4STATICDELAY0__DataLine0                             4
+#define R_SPI4STATICDELAY1                                          0x241
+#define   O_SPI4STATICDELAY1__DataLine15                            28
+#define   W_SPI4STATICDELAY1__DataLine15                            4
+#define   O_SPI4STATICDELAY1__DataLine14                            24
+#define   W_SPI4STATICDELAY1__DataLine14                            4
+#define   O_SPI4STATICDELAY1__DataLine13                            20
+#define   W_SPI4STATICDELAY1__DataLine13                            4
+#define   O_SPI4STATICDELAY1__DataLine12                            16
+#define   W_SPI4STATICDELAY1__DataLine12                            4
+#define   O_SPI4STATICDELAY1__DataLine11                            12
+#define   W_SPI4STATICDELAY1__DataLine11                            4
+#define   O_SPI4STATICDELAY1__DataLine10                            8
+#define   W_SPI4STATICDELAY1__DataLine10                            4
+#define   O_SPI4STATICDELAY1__DataLine9                             4
+#define   W_SPI4STATICDELAY1__DataLine9                             4
+#define   O_SPI4STATICDELAY1__DataLine8                             0
+#define   W_SPI4STATICDELAY1__DataLine8                             4
+#define R_SPI4STATICDELAY2                                          0x242
+#define   O_SPI4STATICDELAY0__TxStat1                               8
+#define   W_SPI4STATICDELAY0__TxStat1                               4
+#define   O_SPI4STATICDELAY0__TxStat0                               4
+#define   W_SPI4STATICDELAY0__TxStat0                               4
+#define   O_SPI4STATICDELAY0__RxControl                             0
+#define   W_SPI4STATICDELAY0__RxControl                             4
+#define R_SPI4CONTROL                                               0x243
+#define   O_SPI4CONTROL__StaticDelay                                2
+#define   O_SPI4CONTROL__LVDS_LVTTL                                 1
+#define   O_SPI4CONTROL__SPI4Enable                                 0
+#define R_CLASSWATERMARKS                                           0x244
+#define   O_CLASSWATERMARKS__Class0Watermark                        24
+#define   W_CLASSWATERMARKS__Class0Watermark                        5
+#define   O_CLASSWATERMARKS__Class1Watermark                        16
+#define   W_CLASSWATERMARKS__Class1Watermark                        5
+#define   O_CLASSWATERMARKS__Class3Watermark                        0
+#define   W_CLASSWATERMARKS__Class3Watermark                        5
+#define R_RXWATERMARKS1                                              0x245
+#define   O_RXWATERMARKS__Rx0DataWatermark                          24
+#define   W_RXWATERMARKS__Rx0DataWatermark                          7
+#define   O_RXWATERMARKS__Rx1DataWatermark                          16
+#define   W_RXWATERMARKS__Rx1DataWatermark                          7
+#define   O_RXWATERMARKS__Rx3DataWatermark                          0
+#define   W_RXWATERMARKS__Rx3DataWatermark                          7
+#define R_RXWATERMARKS2                                              0x246
+#define   O_RXWATERMARKS__Rx4DataWatermark                          24
+#define   W_RXWATERMARKS__Rx4DataWatermark                          7
+#define   O_RXWATERMARKS__Rx5DataWatermark                          16
+#define   W_RXWATERMARKS__Rx5DataWatermark                          7
+#define   O_RXWATERMARKS__Rx6DataWatermark                          8
+#define   W_RXWATERMARKS__Rx6DataWatermark                          7
+#define   O_RXWATERMARKS__Rx7DataWatermark                          0
+#define   W_RXWATERMARKS__Rx7DataWatermark                          7
+#define R_RXWATERMARKS3                                              0x247
+#define   O_RXWATERMARKS__Rx8DataWatermark                          24
+#define   W_RXWATERMARKS__Rx8DataWatermark                          7
+#define   O_RXWATERMARKS__Rx9DataWatermark                          16
+#define   W_RXWATERMARKS__Rx9DataWatermark                          7
+#define   O_RXWATERMARKS__Rx10DataWatermark                         8
+#define   W_RXWATERMARKS__Rx10DataWatermark                         7
+#define   O_RXWATERMARKS__Rx11DataWatermark                         0
+#define   W_RXWATERMARKS__Rx11DataWatermark                         7
+#define R_RXWATERMARKS4                                              0x248
+#define   O_RXWATERMARKS__Rx12DataWatermark                         24
+#define   W_RXWATERMARKS__Rx12DataWatermark                         7
+#define   O_RXWATERMARKS__Rx13DataWatermark                         16
+#define   W_RXWATERMARKS__Rx13DataWatermark                         7
+#define   O_RXWATERMARKS__Rx14DataWatermark                         8
+#define   W_RXWATERMARKS__Rx14DataWatermark                         7
+#define   O_RXWATERMARKS__Rx15DataWatermark                         0
+#define   W_RXWATERMARKS__Rx15DataWatermark                         7
+#define R_FREEWATERMARKS                                            0x249
+#define   O_FREEWATERMARKS__FreeOutWatermark                        16
+#define   W_FREEWATERMARKS__FreeOutWatermark                        16
+#define   O_FREEWATERMARKS__JumFrWatermark                          8
+#define   W_FREEWATERMARKS__JumFrWatermark                          7
+#define   O_FREEWATERMARKS__RegFrWatermark                          0
+#define   W_FREEWATERMARKS__RegFrWatermark                          7
+#define R_EGRESSFIFOCARVINGSLOTS                                    0x24a
+
+
+#define CTRL_RES0           0
+#define CTRL_RES1           1
+#define CTRL_REG_FREE       2
+#define CTRL_CONT           4
+#define CTRL_EOP            5
+#define CTRL_START          6
+#define CTRL_SNGL           7
+
+#define CTRL_B0_NOT_EOP     0
+#define CTRL_B0_EOP         1
+
+#define R_ROUND_ROBIN_TABLE                 0
+#define R_PDE_CLASS_0                       0x300
+#define R_PDE_CLASS_1                       0x302
+#define R_PDE_CLASS_2                       0x304
+#define R_PDE_CLASS_3                       0x306
+
+#define R_MSG_TX_THRESHOLD                  0x308
+
+#define R_GMAC_RFR0_BUCKET_SIZE              0x321
+#define R_GMAC_TX0_BUCKET_SIZE              0x322
+#define R_GMAC_TX1_BUCKET_SIZE              0x323
+#define R_GMAC_TX2_BUCKET_SIZE              0x324
+#define R_GMAC_TX3_BUCKET_SIZE              0x325
+#define R_GMAC_RFR1_BUCKET_SIZE              0x327
+
+#define R_XGS_TX0_BUCKET_SIZE               0x320
+#define R_XGS_TX1_BUCKET_SIZE               0x321
+#define R_XGS_TX2_BUCKET_SIZE               0x322
+#define R_XGS_TX3_BUCKET_SIZE               0x323
+#define R_XGS_TX4_BUCKET_SIZE               0x324
+#define R_XGS_TX5_BUCKET_SIZE               0x325
+#define R_XGS_TX6_BUCKET_SIZE               0x326
+#define R_XGS_TX7_BUCKET_SIZE               0x327
+#define R_XGS_TX8_BUCKET_SIZE               0x328
+#define R_XGS_TX9_BUCKET_SIZE               0x329
+#define R_XGS_TX10_BUCKET_SIZE              0x32A
+#define R_XGS_TX11_BUCKET_SIZE              0x32B
+#define R_XGS_TX12_BUCKET_SIZE              0x32C
+#define R_XGS_TX13_BUCKET_SIZE              0x32D
+#define R_XGS_TX14_BUCKET_SIZE              0x32E
+#define R_XGS_TX15_BUCKET_SIZE              0x32F
+#define R_XGS_RFR_BUCKET_SIZE               0x331
+
+#define R_CC_CPU0_0                         0x380
+#define R_CC_CPU1_0                         0x388
+#define R_CC_CPU2_0                         0x390
+#define R_CC_CPU3_0                         0x398
+#define R_CC_CPU4_0                         0x3a0
+#define R_CC_CPU5_0                         0x3a8
+#define R_CC_CPU6_0                         0x3b0
+#define R_CC_CPU7_0                         0x3b8
+
+/* frame sizes need to be cacheline aligned */
+#define MAC_MAX_FRAME_SIZE          1600
+#define MAC_SKB_BACK_PTR_SIZE   SMP_CACHE_BYTES
+
+
+#ifdef CONFIG_NLMCOMMON_PTP_SUPPORT
+#define MAC_PREPAD             32
+#else
+#define MAC_PREPAD             0
+#endif
+
+#define BYTE_OFFSET             2
+#define NLM_RX_BUF_SIZE (MAC_MAX_FRAME_SIZE+BYTE_OFFSET+MAC_PREPAD+MAC_SKB_BACK_PTR_SIZE+SMP_CACHE_BYTES)
+#define MAC_CRC_LEN             4
+
+enum {
+        SGMII_SPEED_10   = 0x00000000,
+        SGMII_SPEED_100  = 0x02000000,
+        SGMII_SPEED_1000 = 0x04000000,
+};
+
+enum tsv_rsv_reg{
+	TX_RX_64_BYTE_FRAME = 0x20,
+	TX_RX_64_127_BYTE_FRAME,
+	TX_RX_128_255_BYTE_FRAME,
+	TX_RX_256_511_BYTE_FRAME,
+	TX_RX_512_1023_BYTE_FRAME,
+	TX_RX_1024_1518_BYTE_FRAME,
+	TX_RX_1519_1522_VLAN_BYTE_FRAME,
+
+	RX_BYTE_COUNTER = 0x27,
+	RX_PACKET_COUNTER,
+	RX_FCS_ERROR_COUNTER,
+	RX_MULTICAST_PACKET_COUNTER,
+	RX_BROADCAST_PACKET_COUNTER,
+	RX_CONTROL_FRAME_PACKET_COUNTER,
+	RX_PAUSE_FRAME_PACKET_COUNTER,
+	RX_UNKNOWN_OP_CODE_COUNTER,
+	RX_ALIGNMENT_ERROR_COUNTER,
+	RX_FRAME_LENGTH_ERROR_COUNTER,
+	RX_CODE_ERROR_COUNTER,
+	RX_CARRIER_SENSE_ERROR_COUNTER,
+	RX_UNDERSIZE_PACKET_COUNTER,
+	RX_OVERSIZE_PACKET_COUNTER,
+	RX_FRAGMENTS_COUNTER,
+	RX_JABBER_COUNTER,
+	RX_DROP_PACKET_COUNTER,
+
+	TX_BYTE_COUNTER   = 0x38,
+	TX_PACKET_COUNTER,
+	TX_MULTICAST_PACKET_COUNTER,
+	TX_BROADCAST_PACKET_COUNTER,
+	TX_PAUSE_CONTROL_FRAME_COUNTER,
+	TX_DEFERRAL_PACKET_COUNTER,
+	TX_EXCESSIVE_DEFERRAL_PACKET_COUNTER,
+	TX_SINGLE_COLLISION_PACKET_COUNTER,
+	TX_MULTI_COLLISION_PACKET_COUNTER,
+	TX_LATE_COLLISION_PACKET_COUNTER,
+	TX_EXCESSIVE_COLLISION_PACKET_COUNTER,
+	TX_TOTAL_COLLISION_COUNTER,
+	TX_PAUSE_FRAME_HONERED_COUNTER,
+	TX_DROP_FRAME_COUNTER,
+	TX_JABBER_FRAME_COUNTER,
+	TX_FCS_ERROR_COUNTER,
+	TX_CONTROL_FRAME_COUNTER,
+	TX_OVERSIZE_FRAME_COUNTER,
+	TX_UNDERSIZE_FRAME_COUNTER,
+	TX_FRAGMENT_FRAME_COUNTER,
+
+	CARRY_REG_1 = 0x4c,
+	CARRY_REG_2 = 0x4d,
+};
+
+enum net_types { TYPE_GMAC = 0, TYPE_XGMAC, TYPE_SPI4, MAX_NET_TYPES };
+
+enum phy_modes { PHY_MODE_SGMII	= 1, PHY_MODE_RGMII = 2, 
+    PHY_MODE_SELECTABLE = 4, PHY_MODE_XAUI=8};
+
+#endif
diff --git a/arch/mips/include/asm/netlogic/xlp_usb.h b/arch/mips/include/asm/netlogic/xlp_usb.h
new file mode 100644
index 0000000..513147f
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/xlp_usb.h
@@ -0,0 +1,42 @@
+/***********************************************************************
+ * Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+ * reserved.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in
+ * the documentation and/or other materials provided with the
+ * distribution.
+ * THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * *****************************#NETL_2#********************************/
+#ifndef __XLP_USB_H
+#define __XLP_USB_H
+
+static __inline__ int32_t usb_reg_read(int node, int func, int regidx)
+{
+	volatile uint64_t mmio;
+	mmio = nlm_hal_get_dev_base(node, 0, XLP_PCIE_USB_DEV, func);
+	return nlm_hal_read_32bit_reg(mmio, regidx);
+}
+
+static __inline__ void usb_reg_write(int node, int func, int regidx, int32_t val)
+{
+	volatile uint64_t mmio;
+	mmio = nlm_hal_get_dev_base(node, 0, XLP_PCIE_USB_DEV, func);
+	nlm_hal_write_32bit_reg(mmio, regidx, val);
+}
+
+#endif //__XLP_USB_H
-- 
1.7.0.2

