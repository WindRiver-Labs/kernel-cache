From 43591aff6910f839a238f46776c1cbd03b12df77 Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Wed, 16 May 2012 11:26:23 +0800
Subject: [PATCH 1/3] nlm_xlp_64_be: Enable pcie timeout to avoid system hanging

The problem: When executed "lspci -xxxx" or "lspci -xxxx -s 00:01.#"
(where # is a PCIe channel without PCIe device), will hang the system,
regardless the link is configured as RC or EP.

This is due to accessing PCIe control register 0x255, Zero Byte Read
register.

To workaround this issue, setting the BmiTO (BMI Timeout Enable) bit
of PCIe Control Register 0, times out the request on the bus and
recovers the system. Once we set this, system will not hang after
reading register 0x255, and get a response of all F.

The BMI_TIMEOUT of PCIe PHY Bus Master Interface (BMI) Timeout
Register default value is 0xFFFF_FFFF, which corresponds to 17.18
seconds (250MHz PCIe clock). This should be shortened to timeout faster.

BSI Timeout enable and timer should likely be set as well, though less
important as this should be relevant only if XLP already hangs, which
means something is wrong already.

Signed-off-by: Wei Zhang <wezhang@broadcom.com>
Integrated-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/pci/pci-xlp.c |   28 +++++++++++++++++++++++++++-
 1 files changed, 27 insertions(+), 1 deletions(-)

diff --git a/arch/mips/pci/pci-xlp.c b/arch/mips/pci/pci-xlp.c
index a4bf246..6054956 100644
--- a/arch/mips/pci/pci-xlp.c
+++ b/arch/mips/pci/pci-xlp.c
@@ -291,11 +291,22 @@ static void xlp_msi_controller_init(int fn)
  */
 void xlp_pcie_controller_setup(int fn)
 {
+	u32 reg;
+	u64 xlp_pci_base;
+
 	xlp_msi_controller_init(fn);
 	//xlp_msix_disable(fn);
 	//xlp_msi_disable(fn, 0xf);
 	/* By default, leave INTX enabled */
 	xlp_intx_enable(fn);
+	/*enable timeout to avoid system to hang,
+	when there is no device on slot*/
+	xlp_pci_base = XLP_BDF_BASE(0, 1, fn);
+	reg = nlm_hal_read_32bit_reg(xlp_pci_base, 0x240);
+	nlm_hal_write_32bit_reg(xlp_pci_base, 0x240, reg | (3<<23));
+	/*0.1 second delay, 250MHz clock*/
+	nlm_hal_write_32bit_reg(xlp_pci_base, 0x244, 25*1000*1000);
+	nlm_hal_write_32bit_reg(xlp_pci_base, 0x245, 25*1000*1000);
 }
 
 /*
@@ -445,7 +456,15 @@ static int xlp_pcibios_read(struct pci_bus *bus, unsigned int devfn,
 		return PCIBIOS_BAD_REGISTER_NUMBER;
 
 	if (pci_bus_status)
-		data = pci_cfg_read_32bit(pci_cfg_offset((bus->number), devfn, where));
+		/*Workaround: We can't access the offset over 2K
+		* bytes in the configuration space of the Host bridge,
+		* else system will hang on XLP316.*/
+		if (is_nlm_xlp3xx() && bus->number == 0
+			&& devfn == 0 && where >= 2048)
+			data = 0xFFFFFFFF;
+		else
+			data = pci_cfg_read_32bit(
+				pci_cfg_offset(bus->number, devfn, where));
 	else
 		data = 0xFFFFFFFF;
 
@@ -473,6 +492,13 @@ static int xlp_pcibios_write(struct pci_bus *bus, unsigned int devfn,
 	if (!pci_bus_status)
 		return PCIBIOS_BAD_REGISTER_NUMBER;
 
+	/*Workaround: We can't access the offset over 2K
+	* bytes in the configuration space of the Host bridge,
+	* else system will hang on XLP316.*/
+	if (is_nlm_xlp3xx() && bus->number == 0
+		&& devfn == 0 && where >= 2048)
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
 	data = pci_cfg_read_32bit(cfgaddr);
 
 	if (size == 1)
-- 
1.7.0.4

