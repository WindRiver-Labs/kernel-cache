From 75328985b73890afef211900c4ca6a6443f82e70 Mon Sep 17 00:00:00 2001
From: yanjun.zhu <yanjun.zhu@windriver.com>
Date: Tue, 8 Jan 2013 17:31:36 +0800
Subject: [PATCH] netlogic/nae: bonding detection of XAUI link down status

Reference: XAUI patch of Broadcom

Adding the feature to detect the XAUI link down and re-initialize.
Re-initialization can be controled by /proc/netlogic/reset_lane.
Bonding driver can detect XAUI link down status after XAUI link
is shutdown.

Signed-off-by: yanjun.zhu <yanjun.zhu@windriver.com>
---
 arch/mips/include/asm/netlogic/hal/nlm_nae.h |    2 +
 arch/mips/netlogic/common/nlm_hal_nae.c      |   45 +++++
 drivers/net/nae/xlp_hw.c                     |   23 +++-
 drivers/net/nae/xlp_nae.c                    |  243 +++++++++++++++++++++++++-
 drivers/net/nae/xlp_nae.h                    |   10 +
 5 files changed, 315 insertions(+), 8 deletions(-)

diff --git a/arch/mips/include/asm/netlogic/hal/nlm_nae.h b/arch/mips/include/asm/netlogic/hal/nlm_nae.h
index 4df021b..d62c296 100644
--- a/arch/mips/include/asm/netlogic/hal/nlm_nae.h
+++ b/arch/mips/include/asm/netlogic/hal/nlm_nae.h
@@ -111,6 +111,8 @@ struct nlm_hal_nae_port {
         int  loopback;
 	int higig_mode;
 	int xgmii_speed;
+	int alloc_rx_buf;
+	int  macval[2];
 };
 
 struct nlm_hal_nae_config {
diff --git a/arch/mips/netlogic/common/nlm_hal_nae.c b/arch/mips/netlogic/common/nlm_hal_nae.c
index d898a94..8c914fa 100644
--- a/arch/mips/netlogic/common/nlm_hal_nae.c
+++ b/arch/mips/netlogic/common/nlm_hal_nae.c
@@ -3470,6 +3470,49 @@ static int parse_port_config(void *fdt, int node, nlm_nae_config_ptr nae_cfg)
 	return nae_cfg->num_ports;
 }
 
+void rsys_hal_write_mac_addr(void *fdt, int node, int type, int hw_port, 
+	nlm_nae_config_ptr nae_cfg){
+
+	int port;
+	uint32_t macval[2], machi, maclo;
+	char rsys_root[20] = "/rsys-cfg/node0";
+	char mac_prop_str[12] = "eth0addr";
+	char *p = NULL;
+	int port_node;
+	rsys_root[14] = '0' + node;
+
+	port = hw_port/4 + hw_port%4;
+	macval[0] = 0xDEAD;
+	macval[1] = 0xBEEF;
+	nae_cfg->ports[port].macval[0] = 0xDEAD;
+	nae_cfg->ports[port].macval[1] = 0xBEEF;
+
+	/* nlm_print("%s: %d node %d \n",__func__,hw_port, node); */
+	port_node = fdt_path_offset(fdt, rsys_root); 
+	if (!port_node) {
+		nlm_print("rsys mac address info domain is not found\n");
+		return;
+	}
+	mac_prop_str[3] = port + '0';
+	if (copy_fdt_prop(fdt, rsys_root, mac_prop_str, PROP_CELL, 
+		&macval[0], sizeof(uint32_t) * 2) < 0) {
+		nlm_print("fdt missing macaddr\n");
+		return;
+	}
+
+	nlm_print("Read dtb and get node %d MAC addr %04x%08x\n", 
+			node, macval[0], macval[1]);
+	nae_cfg->ports[port].macval[0] = macval[0];
+	nae_cfg->ports[port].macval[1] = macval[1];
+	machi = macval[0];
+	maclo = macval[1];
+	p = &macval[0];
+	machi = (*(p+3) << 24) | (*(p+2) << 16) | (*(p+1) << 8) | (*(p+0));
+	p = &macval[1];
+	maclo = (*(p+3) << 24) | (*(p+2) << 16) | (*(p+1) << 8) | (*(p+0));
+    
+	return;
+}
 
 /**
 * @brief parse_fdt_nae_config function is used to initailize and program the NAE and all interfaces, based on the configuration in FDT.
@@ -3613,6 +3656,8 @@ static void parse_fdt_nae_config(void *fdt, int node, nlm_nae_config_ptr nae_cfg
 			} 
 		}
 
+		rsys_hal_write_mac_addr(fdt, node, nae_cfg->ports[port].iftype, hw_port, nae_cfg);
+
 		NAE_DEBUG("Initialized port@%d\n", port);
 	}
 }
diff --git a/drivers/net/nae/xlp_hw.c b/drivers/net/nae/xlp_hw.c
index 2883b97..14a71c4 100644
--- a/drivers/net/nae/xlp_hw.c
+++ b/drivers/net/nae/xlp_hw.c
@@ -307,8 +307,27 @@ static u32 xlp_get_link(struct net_device *dev)
 	struct dev_data *priv = netdev_priv(dev);
 	int mii_status;
 	unsigned long flags;
-	if (priv->type != SGMII_IF)
-		return -EIO;
+	if (priv->type != SGMII_IF){
+		/*for XAUI_IF type*/
+		if (priv->type == XAUI_IF){
+			int register_val        = 0;
+			int xlf_bit[4]          = {0,0,0,0};
+			int i;
+			for(i=0;i<4;i++) {
+				spin_lock_irqsave(&priv->lock, flags);
+				register_val = nlm_hal_read_mac_reg(
+						priv->node, 
+						priv->block, 0xE, i);
+				spin_unlock_irqrestore(&priv->lock, flags);
+				xlf_bit[i] = check_bit(register_val,10);
+			}
+			return (xlf_bit[0]+xlf_bit[1]+xlf_bit[2]+xlf_bit[3]) ? 
+					0 : 1;
+		}else{
+			/*for other types except XAUI_IF and SGMII_IF*/
+			return -EIO;
+		}
+	}
 
 	spin_lock_irqsave(&priv->lock, flags);
 	mii_status = nlm_xlp_mac_mii_read(priv, MII_BMSR);
diff --git a/drivers/net/nae/xlp_nae.c b/drivers/net/nae/xlp_nae.c
index 861e976..91e8b4e 100644
--- a/drivers/net/nae/xlp_nae.c
+++ b/drivers/net/nae/xlp_nae.c
@@ -34,6 +34,7 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
+#include <linux/workqueue.h>
 
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
@@ -201,6 +202,204 @@ static uint32_t *ucore_shared_data = NULL;
 #define PROTOCOL_TYPE_IP 	0x0800
 #define MAC_SEC_PADDING		(12+16+16+16) /* !2 byte DA and SA, 16 byte preamble len, 16 byte sectag hear, 16 byte ICV len*/
 
+#define START_COMPLEX   0
+#define END_COMPLEX     4 
+
+volatile int lane_rst_status = 1;
+spinlock_t rst_status_lock;
+volatile int nodenum = 1;
+static void detect_lane_handler(struct work_struct *w);
+static struct workqueue_struct *detec_lane_wq = 0;
+static DECLARE_DELAYED_WORK(detect_lane, detect_lane_handler);
+static unsigned long onesec;
+
+void xlp8xxb0_nae_lane_reset_txpll(int node, int block, int lane_ctrl, int mode)
+{
+	uint32_t val = 0;
+	int rext_sel = 0;
+
+	if(mode == PHYMODE_RXAUI && (lane_ctrl%2) )
+		return;
+
+	if(lane_ctrl != 4)
+		rext_sel = (1 << 23);
+
+	val = nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl);
+
+	val |= (1<< 29);
+	val &= ~((1<< 30) & 0xFFFFFFFF);
+	val &= ~((1<< 20) & 0xFFFFFFFF);
+	val |= (mode << PHY_LANE_CTRL_PHYMODE_POS);
+
+	nlm_hal_write_mac_reg(node, block, PHY, lane_ctrl,val);
+
+	if(mode != PHYMODE_SGMII){
+		val |= PHY_LANE_CTRL_BPC_XAUI; /*Set comma bypass for XAUI*/
+	}
+	val |= 0x100000;  /* Bit20: serdes reg reset Storm & Eagle B0 */
+	val &= ~(0x20000);
+	nlm_hal_write_mac_reg(node, block, PHY, lane_ctrl,val);
+
+	val = nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl);
+	val &= ~( (1 << 29) | (0x7ffff));
+	nlm_hal_write_mac_reg(node, block, PHY, lane_ctrl, (rext_sel | val));
+
+	val = nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl);
+	val |= 0x40000000; /* Unset the reset (inverse logic) : Bit30: epcs reset */
+	nlm_hal_write_mac_reg(node, block, PHY, lane_ctrl,val);
+
+	msleep(500);
+
+	printk("Reset PLL done COMPLEX: %d and lane %d\n",block,lane_ctrl);
+}
+
+static int safe_get_rst_status(){
+
+	int local_use_lane_status;
+	unsigned long flags;
+	
+	spin_lock_irqsave(&rst_status_lock, flags);
+	local_use_lane_status = lane_rst_status;
+	spin_unlock_irqrestore(&rst_status_lock, flags);
+	
+	return local_use_lane_status;
+}
+
+static void safe_set_rst_status(int status){
+
+        unsigned long flags;
+
+        spin_lock_irqsave(&rst_status_lock, flags);
+        lane_rst_status = status;
+        spin_unlock_irqrestore(&rst_status_lock, flags);
+}
+
+static void
+detect_lane_handler(struct work_struct *w)
+{
+	int i,j,done=0;
+	int check_xlf[4]        = {0,0,0,0};
+	int register_val        = 0;
+	int complex_val         = 0;
+	int xlf_bit[4]          = {0,0,0,0};
+	int node=0;
+
+	printk("Detect Xaui Status %d XLPs\n",nodenum);
+
+	while ( safe_get_rst_status() ) {
+	        /*Check if any XLF bit is set*/
+		for(node=0;node<nodenum;node++){
+			for(complex_val=START_COMPLEX;complex_val<END_COMPLEX;
+				complex_val++) {
+				for(i=0;i<4;i++) {
+					register_val = nlm_hal_read_mac_reg(
+							node,complex_val,
+							0xE,i);
+					xlf_bit[i] = check_bit(register_val,
+							10);
+				}
+				check_xlf[complex_val] = 
+					xlf_bit[0] + xlf_bit[1] + xlf_bit[2] 
+					+ xlf_bit[3];
+			}
+
+			while (check_xlf[0] + check_xlf[1] + check_xlf[2] 
+				+ check_xlf[3] != 0) {
+				if(!safe_get_rst_status())
+					break;
+				for(complex_val=START_COMPLEX;
+					complex_val<END_COMPLEX;complex_val++){
+					if(check_xlf[complex_val] !=0){
+						for(i=4;i<=7;i++) {
+							xlp8xxb0_nae_lane_reset_txpll(
+								node,
+								complex_val,
+								i,1);
+						}
+						printk("XAUI reset done for all lanes \
+							for COMPLEX: %d \n", 
+							complex_val);
+					}
+				}
+	
+				for(complex_val=START_COMPLEX;
+					complex_val<END_COMPLEX;complex_val++) {
+					for(i=0;i<4;i++) {
+						register_val =
+							nlm_hal_read_mac_reg(
+								node,
+								complex_val,
+								0xE,i);
+						xlf_bit[i] = check_bit(
+								register_val,
+								10);
+					}
+					check_xlf[complex_val] = 
+						xlf_bit[0] + xlf_bit[1] 
+						+ xlf_bit[2] + xlf_bit[3];
+				}
+			}
+		}
+		msleep(1000);
+	}
+}
+
+void open_lane_detect(void){
+	onesec = msecs_to_jiffies(1000);
+	if (!detec_lane_wq){
+		detec_lane_wq = create_singlethread_workqueue("mykmod");
+	}
+	if (detec_lane_wq){
+		queue_delayed_work(detec_lane_wq, &detect_lane, onesec);
+	}
+}
+
+void close_lane_detect(void){
+	
+	if(!cancel_delayed_work(&detect_lane)){
+		flush_workqueue(detec_lane_wq);
+	}
+	printk("Close Xaui Detect\n");
+
+}
+
+static int proc_lane_reset(struct file *file, const char __user *buf,
+                           unsigned long count, void *data){
+	char cmd[12];
+	int lan,i;
+
+	if(count < 1 ){
+		printk("argv Error: argv(on|off)\n");
+		return count;
+	}
+	copy_from_user(cmd,buf,count);
+	if(strncmp(cmd,"on",2)==0){
+		if(!safe_get_rst_status()){
+			safe_set_rst_status( 1 );
+			open_lane_detect();
+		}
+	}else if (strncmp(cmd,"off",3)==0){
+		if(safe_get_rst_status()){
+			safe_set_rst_status( 0 );
+			close_lane_detect();
+		}
+	}else{
+		 printk("argv Error\n");
+	}
+	return count;
+} 
+
+static int lane_status_read(char *page, char **start, off_t off,
+		int count, int *eof, void *data){
+	int len=0;
+	if(safe_get_rst_status())
+		len += sprintf(page + len, "Detect XAUI Status: On \n");
+	else		
+		len += sprintf(page + len, "Detect XAUI Status: Off \n");
+
+	return len;
+}
+
 void dump_buffer(unsigned char *buf, unsigned int len, unsigned char *msg)
 {
     int k = 0;
@@ -308,8 +507,6 @@ static void gen_mac_address(void)
 	}
 }
 
-
-
 static __inline__ struct sk_buff *mac_get_skb_back_ptr(uint64_t addr)
 {
         uint64_t *back_ptr = (uint64_t *)(unsigned long)(addr - SKB_BACK_PTR_SIZE);
@@ -319,7 +516,6 @@ static __inline__ struct sk_buff *mac_get_skb_back_ptr(uint64_t addr)
         return (struct sk_buff *)(unsigned long)(*back_ptr);
 }
 
-
 #define CACHELINE_ALIGNED_ADDR(addr) (((unsigned long)(addr)) & ~(CACHELINE_SIZE-1))
 
 /**********************************************************************
@@ -1690,10 +1886,32 @@ static void nlm_xlp_nae_init(void)
 	if(perf_mode == NLM_TCP_MODE)
 		p2p_desc_mem_init();
 
-	gen_mac_address();
-
-	if (initialize_nae(phys_cpu_map, perf_mode, &enable_jumbo))
+	if (initialize_nae(cpumask_to_uint32(&cpu_online_map), perf_mode, &enable_jumbo))
 		return;
+	maxnae = nlm_node_cfg.num_nodes;
+	nodenum=maxnae;	
+
+	for(node = 0; node < maxnae; node++) {
+		nae_cfg = nlm_node_cfg.nae_cfg[node];
+		if (nae_cfg == NULL)
+			continue;
+		for(i = 0; i < nae_cfg->num_ports; i++) {
+			/* rsys add start, kent 20110820, pass MAC addr to Linux driver module */
+			if (nae_cfg->ports[i].macval[0] != 0 && nae_cfg->ports[i].macval[1] != 0) {
+				unsigned int  tmp;
+				unsigned char *p = (char*)&tmp;
+				tmp = nae_cfg->ports[i].macval[0];
+				eth_hw_addr[node][i][0] = *(p+2);
+				eth_hw_addr[node][i][1] = *(p+3);
+				tmp = nae_cfg->ports[i].macval[1];
+				eth_hw_addr[node][i][2] = *(p+0);
+				eth_hw_addr[node][i][3] = *(p+1);
+				eth_hw_addr[node][i][4] = *(p+2);
+				eth_hw_addr[node][i][5] = *(p+3);
+			}
+			/* rsys add end, kent 20110820, pass MAC addr to Linux driver module */
+		}
+	}
 
 	maxnae = nlm_node_cfg.num_nodes;
 	for(node = 0; node < maxnae; node++) {
@@ -1842,6 +2060,16 @@ static void nlm_xlp_nae_init(void)
 		       __FUNCTION__);
 	}
 
+	spin_lock_init(&rst_status_lock);
+	entry = create_proc_read_entry("reset_lane", 0 /* def mode */ ,
+					nlm_root_proc /* parent */ ,
+					lane_status_read /* proc read function */ ,
+					0        /* no client data */);
+	if (!entry) {
+		printk("[%s]: Unable to create proc read entry for xlp_mac!\n",__FUNCTION__);
+	}
+	entry->write_proc=proc_lane_reset;
+
 	if(!enable_napi) {
 		nlm_xlp_disable_napi();
 		exclusive_vc = 1;
@@ -2720,6 +2948,8 @@ static int __init nlm_xlp_mac_init(void)
 	if(enable_napi)
 		nlm_xlp_enable_napi();
 
+	open_lane_detect();
+
 	return pci_register_driver(&soc_driver);
 }
 
@@ -2727,6 +2957,7 @@ static void __exit nlm_xlp_mac_exit(void)
 {
 	/* unregister mac driver */
 
+	close_lane_detect();
 
 	nlm_xlp_nae_remove();
 
diff --git a/drivers/net/nae/xlp_nae.h b/drivers/net/nae/xlp_nae.h
index 234cd48..bd9ae63 100644
--- a/drivers/net/nae/xlp_nae.h
+++ b/drivers/net/nae/xlp_nae.h
@@ -144,6 +144,16 @@ struct dev_data
 	struct timecompare compare;
 };
 
+static inline int check_bit(int reg_val, int bit_position) {
+
+	int mask = 1,bit_val = 0;
+	mask = mask << bit_position;
+	reg_val = (reg_val & mask);
+	bit_val = reg_val >> bit_position;
+
+	return bit_val;
+}
+ 
 static inline void prefetch_local(const void *addr)
 {
         __asm__ __volatile__(
-- 
1.7.0

