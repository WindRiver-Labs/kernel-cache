From 9dc6deb49d554e4a73c58240ba1a299118595511 Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Fri, 23 Mar 2012 11:46:36 +0800
Subject: [PATCH 11/46] nlm_xlp_64_be: add PageWalker support on XLP316.

Add PageWalker support on XLP316, based on NetLogic
SDK 20120215_2.2.3 tag.
This is only valid on XLP832Bx silicon.

Signed-off-by: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Integrated-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/include/asm/mach-netlogic/pgwalker.h |   23 +++
 arch/mips/include/asm/mipsregs.h               |   17 +++
 arch/mips/netlogic/xlp/mmu.c                   |  170 ++++++++++++++++++++++--
 3 files changed, 201 insertions(+), 9 deletions(-)

diff --git a/arch/mips/include/asm/mach-netlogic/pgwalker.h b/arch/mips/include/asm/mach-netlogic/pgwalker.h
index 855f900..29c5659 100644
--- a/arch/mips/include/asm/mach-netlogic/pgwalker.h
+++ b/arch/mips/include/asm/mach-netlogic/pgwalker.h
@@ -32,4 +32,27 @@ enum {
 
 extern void dump_pgwalker_config(void);
 
+/* pagewalker control register field offset and width */
+enum {
+  //offset, width pair
+  PWFIELD_BD_O  = 32, PWFIELD_BD_W  = 6,
+  PWFIELD_GD_O  = 24, PWFIELD_GD_W  = 6,
+  PWFIELD_UD_O  = 18, PWFIELD_UD_W  = 6,
+  PWFIELD_MD_O  = 12, PWFIELD_MD_W  = 6,
+  PWFIELD_PT_O  =  6, PWFIELD_PT_W  = 6,
+  PWFIELD_PTE_O =  0, PWFIELD_PTE_W = 6,
+
+  PWSIZE_BD_O  = 32, PWSIZE_BD_W  = 6,
+  PWSIZE_PS_O  = 30, PWSIZE_PS_W  = 1,
+  PWSIZE_GD_O  = 24, PWSIZE_GD_W  = 6,
+  PWSIZE_UD_O  = 18, PWSIZE_UD_W  = 6,
+  PWSIZE_MD_O  = 12, PWSIZE_MD_W  = 6,
+  PWSIZE_PT_O  =  6, PWSIZE_PT_W  = 6,
+  PWSIZE_PTE_O =  0, PWSIZE_PTE_W = 6,
+
+  PWCTL_PW_EN_O = 31, PWCTL_PW_EN_W = 1,
+
+  CFG4_FTLBPAGESIZE_O = 8, CFG4_FTLBPAGESIZE_W = 5
+};
+
 #endif
diff --git a/arch/mips/include/asm/mipsregs.h b/arch/mips/include/asm/mipsregs.h
index 1a1422e..2077fa4 100644
--- a/arch/mips/include/asm/mipsregs.h
+++ b/arch/mips/include/asm/mipsregs.h
@@ -1095,6 +1095,23 @@ do {									\
 #define read_octeon_c0_dcacheerr()	__read_64bit_c0_register($27, 1)
 #define write_octeon_c0_dcacheerr(val)	__write_64bit_c0_register($27, 1, val)
 
+#ifdef CONFIG_PGWALKER
+/*
+ * xlp2xx pagewalker PW registers
+ */
+#define read_c0_pwbase()	__read_64bit_c0_register($5, 5)
+#define write_c0_pwbase(val)	__write_64bit_c0_register($5, 5, val)
+
+#define read_c0_pwfield()	__read_64bit_c0_register($5, 6)
+#define write_c0_pwfield(val)	__write_64bit_c0_register($5, 6, val)
+
+#define read_c0_pwsize()	__read_64bit_c0_register($5, 7)
+#define write_c0_pwsize(val)	__write_64bit_c0_register($5, 7, val)
+
+#define read_c0_pwctl()	__read_32bit_c0_register($6, 6)
+#define write_c0_pwctl(val)	__write_32bit_c0_register($6, 6, val)
+#endif
+
 /*
  * Macros to access the floating point coprocessor control registers
  */
diff --git a/arch/mips/netlogic/xlp/mmu.c b/arch/mips/netlogic/xlp/mmu.c
index aef53b6..9ab0d7b 100644
--- a/arch/mips/netlogic/xlp/mmu.c
+++ b/arch/mips/netlogic/xlp/mmu.c
@@ -29,6 +29,11 @@
 #include <asm/asm-offsets.h>
 #include <asm/page.h>
 #include <asm/pgtable.h>
+#include <asm/netlogic/xlp.h>
+#include <asm/netlogic/hal/nlm_hal.h>
+
+#define READ_INHIBIT (1 << 31)
+#define EXEC_INHIBIT (1 << 30)
 
 #ifdef CONFIG_PGWALKER
 static int __initdata tlb_config = (ENABLE_ETLB | ENABLE_128_TLB | ENABLE_PGWALKER);
@@ -68,6 +73,14 @@ static int pgtable_levels = PGD | PMD | PTE;
 static int pgtable_levels = PGD | PTE;
 #endif
 
+static int is_hwpw_mips_compliant(uint32_t proc_id)
+{
+	return (proc_id == CHIP_PROCESSOR_ID_XLP_3XX) ||
+		(proc_id == CHIP_PROCESSOR_ID_XLP_2XX) ||
+		(proc_id == CHIP_PROCESSOR_ID_XLP_1XX) ||
+		(proc_id == CHIP_PROCESSOR_ID_XLP_9XX);
+}
+
 static void pgwalker_init(void)
 {
 	unsigned int value;
@@ -140,10 +153,85 @@ static void pgwalker_init(void)
 	pr_info("Initialized Page Walker on cpu@%d\n", hard_smp_processor_id());
 }
 
+static void pgwalker_init_mips_compliant(void)
+{
+	int i = 0;
+	uint64_t pwbase_val = 0, pwfield_val = 0, pwsize_val = 0, bd_shift = 0;
+	uint32_t pwctl_val = 0;
+
+	if (!(tlb_config & ENABLE_PGWALKER)) {
+		/* disable pagewalker (PWCTL_PW_EN field was initialized to 0) */
+		write_c0_pwctl(pwctl_val);
+		return;
+	}
+
+	/* Initialize pgd_bases to default values */
+	for(i = 0; i < NR_ADDR_SEGMENTS; i++) {
+		get_cpu_var(pgd_bases)[i] = (unsigned long)swapper_pg_dir;
+		put_cpu_var(pgd_bases);
+	}
+	pwbase_val = (uint64_t)&(__get_cpu_var(pgd_bases)[0]);
+
+	/* enable page walker */
+	pwctl_val |= ((uint32_t)1) << PWCTL_PW_EN_O;
+
+	/* page table selector */
+	bd_shift = _PGDIR_SHIFT + ffs(_PTRS_PER_PGD) - 1;
+	pwfield_val |= bd_shift << PWFIELD_BD_O; /* corresponds to old HPW_NUM_PAGE_LVL[15:8] */
+	pwsize_val |= ((uint64_t)(ffs(NR_ADDR_SEGMENTS) - 1)) << PWSIZE_BD_O;
+
+	/* global directory */
+	pwfield_val |= ((uint64_t)(_PGDIR_SHIFT)) << PWFIELD_GD_O;
+	pwsize_val |= ((uint64_t)(ffs(_PTRS_PER_PGD) - 1)) << PWSIZE_GD_O;
+
+	/* upper directory (was initialized to 0) */
+
+#ifdef CONFIG_64BIT
+	/* middle directory */
+	pwfield_val |= ((uint64_t)_PMD_SHIFT) << PWFIELD_MD_O;
+	pwsize_val |= ((uint64_t)(ffs(_PTRS_PER_PMD) - 1)) << PWSIZE_MD_O;
+
+#endif
+	/* page table index */
+	pwfield_val |= ((uint64_t)PAGE_SHIFT) << PWFIELD_PT_O;
+	pwsize_val |= ((uint64_t)(ffs(_PTRS_PER_PTE) - 1)) << PWSIZE_PT_O;
+
+#ifdef CONFIG_64BIT
+	pwsize_val |= ((uint64_t)1) << PWSIZE_PS_O;
+#else
+	/* PWSIZE_PS field was initialized to 0 */
+#endif
+
+	/* logical right rotate of PTE loaded from memory */
+	pwfield_val |= ((uint64_t)ENTRYLO_PFN_SHIFT) << PWFIELD_PTE_O;
+
+	/* PWSIZE_PTE field was initialized to 0 (page table entry spacing) */
+
+	/* write registers*/
+	write_c0_pwbase(pwbase_val);
+	write_c0_pwfield(pwfield_val);
+	write_c0_pwsize(pwsize_val);
+	write_c0_pwctl(pwctl_val);
+
+	get_cpu_var(pgd_bases)[VMALLOC_SEG] = (unsigned long)swapper_pg_dir;
+
+#ifdef MODULE_START
+	__get_cpu_var(pgd_bases)[MODULE_SEG] = (unsigned long)swapper_pg_dir;
+#endif
+
+	put_cpu_var(pgd_bases);
+
+	dump_pgwalker_config();
+	printk("Initialized Page Walker on cpu@%d\n", hard_smp_processor_id());
+}
+
 void dump_pgwalker_config(void)
 {
 #ifdef DEBUG
 	int i = 0;
+	uint64_t pwbase_val = 0, pwfield_val = 0, pwsize_val = 0;
+	uint32_t pwctl_val = 0;
+	int hwpw_mips_compliant = is_hwpw_mips_compliant(get_proc_id());
 
 	pgw_print_w(PGW_MMU_INFO);
 	pgw_print_w(PGW_PGD_SHIFT);
@@ -158,34 +246,98 @@ void dump_pgwalker_config(void)
 	pr_info("swapper_pg_dir = %lx\n", (unsigned long)swapper_pg_dir);
 	for (i = 0; i < NR_ADDR_SEGMENTS; i++)
 		pr_info("pgd_bases[%d] = 0x%lx\n", i, __get_cpu_var(pgd_bases)[i]);
+
+	if (hwpw_mips_compliant) {
+		pwbase_val = read_c0_pwbase();
+		pwfield_val = read_c0_pwfield();
+		pwsize_val = read_c0_pwsize();
+		pwctl_val = read_c0_pwctl();
+		printk("read pwbase: = %llx\n", pwbase_val);
+		printk("read pwfield: = %llx\n", pwfield_val);
+		printk("read pwsize: = %llx\n", pwsize_val);
+		printk("read pwctl: = %x\n", pwctl_val);
+	}
 #endif
 }
 
+#ifdef CONFIG_NLM_XLP
+static void pgwalker_workaround_setup(void)
+{
+	uint32_t prid, chip_id, rev_id;
+
+	prid = read_c0_prid();
+	chip_id = (prid >> 8) & 0xff;
+	rev_id  = prid & 0xff;
+
+	/* Disable hardware page walker for XLP A0/1/2 chips (832-408),
+	 * Revision A0/A1/A2 chips.
+	 */
+	if (chip_id == CHIP_PROCESSOR_ID_XLP_8XX || chip_id == CHIP_PROCESSOR_ID_XLP_832
+	|| chip_id == CHIP_PROCESSOR_ID_XLP_816 || chip_id == CHIP_PROCESSOR_ID_XLP_432
+	|| chip_id == CHIP_PROCESSOR_ID_XLP_416 || chip_id == CHIP_PROCESSOR_ID_XLP_408) {
+		if (rev_id == XLP_REVISION_A0 || rev_id == XLP_REVISION_A1
+			|| rev_id == XLP_REVISION_A2)
+			tlb_config &= ~ENABLE_PGWALKER;
+	}
+}
+#else
+static void pgwalker_workaround_setup(void) {}
+#endif
+
 void mmu_init(void)
 {
+	uint32_t config4_val = 0;
+	uint32_t proc_id = get_proc_id();
+	int hwpw_mips_compliant = is_hwpw_mips_compliant(proc_id);
+
+	/* For XLP832 A0-A2 chips, the page walker needs to be shutdown to
+	 * prevent potential errors.
+	 */
+	pgwalker_workaround_setup();
+
+	/*
+	 * Read back TLB entries after configuration
+	 */
+	current_cpu_data.tlbsize = (read_c0_config6() >> 16 ) & 0xffff;
+
 	/*
 	 * shift right half the number of 1s in
 	 * the pagemask and populate that value
 	 */
 	write_c0_config7(PM_DEFAULT_MASK >> (13 + (ffz(PM_DEFAULT_MASK >> 13) / 2)));
+
 #ifdef DEBUG
-	pr_info("( %s ): write_c0_config7 = %d\n", __func__, read_c0_config7());
+	printk(KERN_INFO "( %s ): write_c0_config7 = %d\n", __FUNCTION__,
+		   read_c0_config7());
+#endif
+
+	if (hwpw_mips_compliant) {
+		/* set config4 to use 64KB page */
+		config4_val = read_c0_config4();
+		config4_val &= ~(((uint32_t)0x1f) << CFG4_FTLBPAGESIZE_O); /*clear 5-bit width field*/
+		config4_val |= ((uint32_t)0x3) << CFG4_FTLBPAGESIZE_O; /* 64KB page */
+		write_c0_config4(config4_val);
+	}
+
+#ifdef CONFIG_EXEC_INHIBIT
+	pagegrain_write(pagegrain_read() | EXEC_INHIBIT);
+#endif
+
+#ifdef CONFIG_READ_INHIBIT
+	pagegrain_write(pagegrain_read() | READ_INHIBIT);
 #endif
 
-	pgwalker_init();
+	if (hwpw_mips_compliant) {
+		pgwalker_init_mips_compliant();
+	} else {
+		pgwalker_init();
+	}
 	tlbstats_init();
 	entrylo0_mask_init();
 
 	/* Intialize after pgwalker and others are configured! */
 	write_c0_config6(read_c0_config6() | tlb_config);
-
-	/*
-	 * Read back TLB entries after configuration
-	 */
-	current_cpu_data.tlbsize = ((read_c0_config6() >> 16) & 0xffff) + 1;
-	pr_info("%s: cpu = %d, tlbsize = %d\n", __func__, smp_processor_id(), current_cpu_data.tlbsize);
 }
-
 #else	/* !CONFIG_PGWALKER */
 
 static int __initdata tlb_config = (ENABLE_ETLB | ENABLE_128_TLB);
-- 
1.7.0

