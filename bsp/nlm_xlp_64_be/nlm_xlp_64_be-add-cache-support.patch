From cb363d5607a06e52aecd18c4ee59824ee99909f6 Mon Sep 17 00:00:00 2001
From: Wu Zhangjin <zhangjin.wu@windriver.com>
Date: Thu, 7 Apr 2011 13:29:14 +0800
Subject: [PATCH 08/37] nlm_xlp_64_be: add cache support

[ Based on netlogic SDK 20110720 ]

Add XLP specific cache support

Signed-off-by: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Signed-off-by: Zi Shen Lim <zlim@netlogicmicro.com>
Integrated-by: Wu Zhangjin <zhangjin.wu@windriver.com>
---
 arch/mips/Kconfig                    |    2 +-
 arch/mips/include/asm/cache.h        |    4 +
 arch/mips/include/asm/cacheflush.h   |    1 +
 arch/mips/include/asm/cpu-features.h |    3 +
 arch/mips/include/asm/page.h         |   13 ++
 arch/mips/include/asm/pgtable-bits.h |    6 +
 arch/mips/mm/Makefile                |    4 +
 arch/mips/mm/c-phoenix.c             |  336 ++++++++++++++++++++++++++++++++++
 arch/mips/mm/cache.c                 |    6 +
 arch/mips/mm/cerr-nlm.c              |  145 +++++++++++++++
 arch/mips/mm/cex-gen.S               |   20 ++
 11 files changed, 539 insertions(+), 1 deletions(-)
 create mode 100644 arch/mips/mm/c-phoenix.c
 create mode 100644 arch/mips/mm/cerr-nlm.c

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index b612f3e..5b3cd29 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -1059,7 +1059,7 @@ config BOOT_ELF32
 config MIPS_L1_CACHE_SHIFT
 	int
 	default "4" if MACH_DECSTATION || MIKROTIK_RB532 || PMC_MSP4200_EVAL
-	default "6" if MIPS_CPU_SCACHE
+	default "6" if MIPS_CPU_SCACHE || CPU_XLP
 	default "7" if SGI_IP22 || SGI_IP27 || SGI_IP28 || SNI_RM || CPU_CAVIUM_OCTEON
 	default "5"
 
diff --git a/arch/mips/include/asm/cache.h b/arch/mips/include/asm/cache.h
index 37f175c..e006be8 100644
--- a/arch/mips/include/asm/cache.h
+++ b/arch/mips/include/asm/cache.h
@@ -17,4 +17,8 @@
 #define SMP_CACHE_SHIFT		L1_CACHE_SHIFT
 #define SMP_CACHE_BYTES		L1_CACHE_BYTES
 
+#ifdef CONFIG_NLM_COMMON
+#define ARCH_KMALLOC_MINALIGN   8
+#endif
+
 #endif /* _ASM_CACHE_H */
diff --git a/arch/mips/include/asm/cacheflush.h b/arch/mips/include/asm/cacheflush.h
index 40bb9fd..fd87738 100644
--- a/arch/mips/include/asm/cacheflush.h
+++ b/arch/mips/include/asm/cacheflush.h
@@ -5,6 +5,7 @@
  *
  * Copyright (C) 1994, 95, 96, 97, 98, 99, 2000, 01, 02, 03 by Ralf Baechle
  * Copyright (C) 1999, 2000, 2001 Silicon Graphics, Inc.
+ * Copyright (C) 2003-2010 Netlogic Microsystems Inc.
  */
 #ifndef _ASM_CACHEFLUSH_H
 #define _ASM_CACHEFLUSH_H
diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h
index ac73ced..1106f1b 100644
--- a/arch/mips/include/asm/cpu-features.h
+++ b/arch/mips/include/asm/cpu-features.h
@@ -41,6 +41,9 @@
 #ifndef cpu_has_octeon_cache
 #define cpu_has_octeon_cache	0
 #endif
+#ifndef cpu_has_nlm_cache
+#define cpu_has_nlm_cache  (cpu_data[0].options & MIPS_CPU_NLM_CACHE)
+#endif
 #ifndef cpu_has_fpu
 #define cpu_has_fpu		(current_cpu_data.options & MIPS_CPU_FPU)
 #define raw_cpu_has_fpu		(raw_current_cpu_data.options & MIPS_CPU_FPU)
diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index a16beaf..fc6476b 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -5,6 +5,7 @@
  *
  * Copyright (C) 1994 - 1999, 2000, 03 Ralf Baechle
  * Copyright (C) 1999, 2000 Silicon Graphics, Inc.
+ * Copyright (C) 2003-2010 Netlogic Microsystems Inc.
  */
 #ifndef _ASM_PAGE_H
 #define _ASM_PAGE_H
@@ -78,8 +79,20 @@ static inline void clear_user_page(void *addr, unsigned long vaddr,
 		flush_data_cache_page((unsigned long)addr);
 }
 
+#ifdef CONFIG_NLM_COMMON
+static inline void copy_user_page(void *vto, void *vfrom, unsigned long vaddr,
+		    struct page *to)
+{
+	extern void nlm_common_flush_dcache_page(struct page *page);
+
+	copy_page(vto, vfrom);
+	nlm_common_flush_dcache_page(to);
+}
+#else
 extern void copy_user_page(void *vto, void *vfrom, unsigned long vaddr,
 	struct page *to);
+#endif
+
 struct vm_area_struct;
 extern void copy_user_highpage(struct page *to, struct page *from,
 	unsigned long vaddr, struct vm_area_struct *vma);
diff --git a/arch/mips/include/asm/pgtable-bits.h b/arch/mips/include/asm/pgtable-bits.h
index e9fe7e9..fe881b0 100644
--- a/arch/mips/include/asm/pgtable-bits.h
+++ b/arch/mips/include/asm/pgtable-bits.h
@@ -192,6 +192,12 @@ static inline uint64_t pte_to_entrylo(unsigned long pte_val)
 #define _CACHE_CACHABLE_NONCOHERENT (5<<_CACHE_SHIFT)
 #define _CACHE_UNCACHED_ACCELERATED (7<<_CACHE_SHIFT)
 
+#elif defined(CONFIG_CPU_XLP)
+
+#define _CACHE_UNCACHED             (2<<_CACHE_SHIFT)
+#define _CACHE_CACHABLE_COW         (3<<_CACHE_SHIFT)
+#define _CACHE_CACHABLE_NONCOHERENT (3<<_CACHE_SHIFT)
+
 #elif defined(CONFIG_CPU_RM9000)
 
 #define _CACHE_WT		    (0<<_CACHE_SHIFT)
diff --git a/arch/mips/mm/Makefile b/arch/mips/mm/Makefile
index f0e4355..185b043 100644
--- a/arch/mips/mm/Makefile
+++ b/arch/mips/mm/Makefile
@@ -32,6 +32,10 @@ obj-$(CONFIG_CPU_CAVIUM_OCTEON)	+= c-octeon.o cex-oct.o tlb-r4k.o
 
 obj-$(CONFIG_IP22_CPU_SCACHE)	+= sc-ip22.o
 obj-$(CONFIG_R5000_CPU_SCACHE)  += sc-r5k.o
+
+obj-$(CONFIG_CPU_XLP)		+= c-phoenix.o tlb-r4k.o \
+				   cex-gen.o cerr-nlm.o
+
 obj-$(CONFIG_RM7000_CPU_SCACHE)	+= sc-rm7k.o
 obj-$(CONFIG_MIPS_CPU_SCACHE)	+= sc-mips.o
 
diff --git a/arch/mips/mm/c-phoenix.c b/arch/mips/mm/c-phoenix.c
new file mode 100644
index 0000000..c18576b
--- /dev/null
+++ b/arch/mips/mm/c-phoenix.c
@@ -0,0 +1,336 @@
+/*
+ * Copyright (C) 1996 David S. Miller (dm@engr.sgi.com)
+ * Copyright (C) 1997, 2001 Ralf Baechle (ralf@gnu.org)
+ * Copyright (C) 2003-2010 Netlogic Microsystems Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+#include <linux/init.h>
+#include <asm/asm.h>
+#include <asm/mmu_context.h>
+#include <asm/bootinfo.h>
+#include <asm/cacheops.h>
+#include <asm/cpu.h>
+#include <asm/uaccess.h>
+#include <linux/smp.h>
+#include <linux/kallsyms.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+
+#include <asm/mach-netlogic/xlp-mmu.h>
+#include <asm/netlogic/debug.h>
+
+static unsigned int icache_linesz;
+static unsigned int icache_lines;
+
+#define cacheop(op, base) \
+	__asm__ __volatile__ (".set push\n.set mips4\ncache %0, 0(%1)\n.set pop\n" : : "i"(op), "r"(base))
+
+#define cacheop_extable(op, base) do {                    \
+  __asm__ __volatile__(                                    \
+		"    .set push                \n"   \
+		"    .set noreorder           \n"   \
+		"    .set mips4               \n"   \
+		"1:  cache %0, 0(%1)           \n"  \
+		"2:  .set pop                 \n"   \
+		"    .section __ex_table,\"a\"\n"   \
+		    STR(PTR)"\t1b, 2b\n\t"        \
+		"     .previous               \n"   \
+		: : "i" (op), "r" (base));          \
+	} while (0)
+
+static inline void sync_istream(void)
+{
+	pipeline_flush();
+}
+
+static inline void cacheop_hazard(void)
+{
+	pipeline_flush();
+}
+
+static inline void cacheop_sync_istream(void)
+{
+	pipeline_flush();
+}
+
+#define optimize_thread_flush()
+
+extern unsigned long nlm_common_ebase;
+/*
+ * These routines support Generic Kernel cache flush requirements
+ */
+void nlm_common_flush_dcache_page(struct page *page)
+{
+	ClearPageDcacheDirty(page);
+}
+EXPORT_SYMBOL(nlm_common_flush_dcache_page);
+
+static void nlm_common_local_flush_icache_range(unsigned long start, unsigned long end)
+{
+	unsigned long addr;
+
+	for (addr = (start & ~((unsigned long)(icache_linesz - 1))); addr < end;
+		addr += icache_linesz) {
+			cacheop_extable(Hit_Invalidate_I, addr);
+	}
+
+	cacheop_sync_istream();
+}
+
+struct flush_icache_range_args {
+	unsigned long start;
+	unsigned long end;
+};
+struct flush_icache_range_args_paddr {
+	phys_t start;
+	phys_t end;
+};
+
+static void nlm_common_flush_icache_range_ipi(void *info)
+{
+	struct flush_icache_range_args *args = info;
+
+	optimize_thread_flush();
+
+	nlm_common_local_flush_icache_range(args->start, args->end);
+}
+
+void nlm_common_flush_icache_range(unsigned long start, unsigned long end)
+{
+	struct flush_icache_range_args args;
+
+	if ((end - start) > PAGE_SIZE)
+		dbg_msg("flushing more than page size of icache addresses starting @ %lx\n", start);
+
+	args.start = start;
+	args.end = end;
+	/* TODO: don't even send ipi to non-zero thread ids
+	 * This may require some changes to smp_call_function interface, for now just avoid
+	 * redundant cache ops
+	 */
+	on_each_cpu(nlm_common_flush_icache_range_ipi, &args, 1);
+}
+
+static void nlm_common_flush_cache_sigtramp_ipi(void *info)
+{
+	unsigned long addr = (unsigned long)info;
+
+	optimize_thread_flush();
+
+	addr = addr & ~((unsigned long)(icache_linesz - 1));
+	cacheop_extable(Hit_Invalidate_I, addr);
+	cacheop_sync_istream();
+}
+
+static void nlm_common_flush_cache_sigtramp(unsigned long addr)
+{
+	on_each_cpu(nlm_common_flush_cache_sigtramp_ipi, (void *) addr, 1);
+}
+
+/*
+ * These routines support MIPS specific cache flush requirements.
+ * These are called only during bootup or special system calls
+ */
+
+static void nlm_common_local_flush_icache(void)
+{
+	int i;
+	unsigned long base = CKSEG0;
+
+	/* Index Invalidate all the lines and the ways */
+	for (i = 0; i < icache_lines; i++) {
+		cacheop(Index_Invalidate_I, base);
+		base += icache_linesz;
+	}
+
+	cacheop_sync_istream();
+}
+
+static void nlm_common_local_flush_dcache(void)
+{
+	int i;
+	unsigned long base = CKSEG0;
+	unsigned int lines;
+
+	lines = current_cpu_data.dcache.ways * current_cpu_data.dcache.sets;
+
+	/* Index Invalidate all the lines and the ways */
+	for (i = 0; i < lines; i++) {
+		cacheop(Index_Writeback_Inv_D, base);
+		base += current_cpu_data.dcache.linesz;
+	}
+
+	cacheop_hazard();
+}
+
+#ifdef CONFIG_KGDB
+void nlm_common_flush_l1_icache_ipi(void *info)
+{
+	nlm_common_local_flush_icache();
+}
+#endif
+
+#ifdef CONFIG_KGDB
+void nlm_common_flush_l1_caches_ipi(void *info)
+#else
+static void nlm_common_flush_l1_caches_ipi(void *info)
+#endif
+{
+	optimize_thread_flush();
+
+	nlm_common_local_flush_dcache();
+	nlm_common_local_flush_icache();
+}
+
+static void nlm_common_flush_l1_caches(void)
+{
+	on_each_cpu(nlm_common_flush_l1_caches_ipi, (void *)NULL, 1);
+}
+
+static void nlm_common_noflush(void) { /* do nothing */ }
+
+static __init void probe_l1_cache(void)
+{
+	struct cpuinfo_mips *c = &current_cpu_data;
+	unsigned int config1 = read_c0_config1();
+	int lsize = 0;
+	int icache_size = 0, dcache_size = 0;
+
+	lsize = (config1 >> 19) & 7;
+	if (lsize)
+		c->icache.linesz = 2 << lsize;
+	else
+		c->icache.linesz = lsize;
+	c->icache.sets = 64 << ((config1 >> 22) & 7);
+	c->icache.ways = 1 + ((config1 >> 16) & 7);
+
+	icache_size = c->icache.sets * c->icache.ways * c->icache.linesz;
+	c->icache.waybit = ffs(icache_size/c->icache.ways) - 1;
+
+	c->dcache.flags = 0;
+
+	lsize = (config1 >> 10) & 7;
+	if (lsize)
+		c->dcache.linesz = 2 << lsize;
+	else
+		c->dcache.linesz = lsize;
+	c->dcache.sets = 64 << ((config1 >> 13) & 7);
+	c->dcache.ways = 1 + ((config1 >> 7) & 7);
+
+	dcache_size = c->dcache.sets * c->dcache.ways * c->dcache.linesz;
+	c->dcache.waybit = ffs(dcache_size/c->dcache.ways) - 1;
+
+	if (smp_processor_id() == 0) {
+		printk("Primary instruction cache %dkB, %d-way, linesize %d bytes.\n",
+			icache_size >> 10, c->icache.ways, c->icache.linesz);
+		printk("Primary data cache %dkB %d-way, linesize %d bytes.\n",
+			dcache_size >> 10, c->dcache.ways, c->dcache.linesz);
+	}
+}
+
+static inline void install_cerr_handler(void)
+{
+	extern char except_vec2_generic;
+
+	memcpy((void *)(nlm_common_ebase + 0x100), &except_vec2_generic, 0x80);
+}
+
+static void update_kseg0_coherency(void)
+{
+	int attr = read_c0_config() & CONF_CM_CMASK;
+
+	if (attr != 0x3) {
+		nlm_common_local_flush_dcache();
+		nlm_common_local_flush_icache();
+		change_c0_config(CONF_CM_CMASK, 0x3);
+		sync_istream();
+	}
+	_page_cachable_default = (0x3 << _CACHE_SHIFT);
+}
+
+void nlm_cache_init(void)
+{
+	extern void build_clear_page(void);
+	extern void build_copy_page(void);
+
+	/* update cpu_data */
+	probe_l1_cache();
+
+	if (smp_processor_id()) {
+		nlm_common_local_flush_icache();
+		update_kseg0_coherency();
+		return;
+	}
+
+	/* These values are assumed to be the same for all cores */
+	icache_lines = current_cpu_data.icache.ways * current_cpu_data.icache.sets;
+	icache_linesz = current_cpu_data.icache.linesz;
+
+	/* When does this function get called? Looks like MIPS has some syscalls
+	 * to flush the caches.
+	 */
+	__flush_cache_all = nlm_common_flush_l1_caches;
+
+	/* flush_cache_all: makes all kernel data coherent.
+	 * This gets called just before changing or removing
+	 * a mapping in the page-table-mapped kernel segment (kmap).
+	 * Physical Cache -> do nothing
+	 */
+	flush_cache_all = nlm_common_noflush;
+
+	/* flush_icache_range: makes the range of addresses coherent w.r.t I-cache and D-cache
+	 * This gets called after the instructions are written to memory
+	 * All addresses are valid kernel or mapped user-space virtual addresses
+	 */
+	flush_icache_range = nlm_common_flush_icache_range;
+
+	/* flush_cache_{mm, range, page}: make these memory locations, that may have been written
+	 *                                by a user process, coherent
+	 * These get called when virtual->physical translation of a user address space is about
+	 * to be changed. These are closely related to TLB coherency (flush_tlb_{mm, range, page})
+	 */
+	flush_cache_mm = (void (*)(struct mm_struct *))nlm_common_noflush;
+	flush_cache_range = (void *) nlm_common_noflush;
+	flush_cache_page = (void *) nlm_common_flush_l1_caches;
+
+	/* flush_icache_page: flush_dcache_page + update_mmu_cache takes care of this
+	 *
+	 */
+	flush_data_cache_page = (void *) nlm_common_noflush;
+
+	/* flush_cache_sigtramp: flush the single I-cache line with the proper fixup code
+	 */
+	flush_cache_sigtramp = nlm_common_flush_cache_sigtramp;
+
+	/* flush_icache_all: This should get called only for Virtuall Tagged I-Caches
+	 */
+	flush_icache_all = (void *)nlm_common_noflush;
+
+	local_flush_icache_range = nlm_common_local_flush_icache_range;
+	local_flush_data_cache_page	= (void *)nlm_common_noflush;
+
+	__flush_cache_vmap = (void *)nlm_common_noflush;
+	__flush_cache_vunmap = (void *)nlm_common_noflush;
+
+	install_cerr_handler();
+
+	build_clear_page();
+	build_copy_page();
+
+	nlm_common_local_flush_icache();
+
+	update_kseg0_coherency();
+}
diff --git a/arch/mips/mm/cache.c b/arch/mips/mm/cache.c
index 12af739..d02bcc7 100644
--- a/arch/mips/mm/cache.c
+++ b/arch/mips/mm/cache.c
@@ -5,6 +5,7 @@
  *
  * Copyright (C) 1994 - 2003, 06, 07 by Ralf Baechle (ralf@linux-mips.org)
  * Copyright (C) 2007 MIPS Technologies, Inc.
+ * Copyright (C) 2003-2010 Netlogic Microsystems Inc.
  */
 #include <linux/fs.h>
 #include <linux/fcntl.h>
@@ -203,6 +204,11 @@ void __cpuinit cpu_cache_init(void)
 
 		tx39_cache_init();
 	}
+	if (cpu_has_nlm_cache) {
+		extern void __weak nlm_cache_init(void);
+
+		nlm_cache_init();
+	}
 
 	if (cpu_has_octeon_cache) {
 		extern void __weak octeon_cache_init(void);
diff --git a/arch/mips/mm/cerr-nlm.c b/arch/mips/mm/cerr-nlm.c
new file mode 100644
index 0000000..699b994
--- /dev/null
+++ b/arch/mips/mm/cerr-nlm.c
@@ -0,0 +1,145 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+
+#include <linux/smp.h>
+#include <asm/system.h>
+
+#include <asm/netlogic/iomap.h>
+
+unsigned char nlm_cerr_stack[8192];
+volatile int nlm_cerr_lock;
+
+static inline void cerr_cpu_halt(void)
+{
+	for (;;) {
+		__asm__ __volatile__(".set mips64\n"
+				     "1: wait \n"
+				     "   b 1b\n"
+				     "   nop\n"
+			);
+	}
+}
+
+#define UART_RHR 0
+#define UART_THR 0
+#define UART_IER 1
+#define UART_IIR 2
+#define UART_FCR 2
+#define UART_LCR 3
+#define UART_MCR 4
+#define UART_LSR 5
+#define UART_MSR 6
+static void cerr_outbyte(char ch)
+{
+	volatile uint32_t *mmio = netlogic_io_mmio(NETLOGIC_IO_UART_0_OFFSET);
+	int lsr;
+	for (;;) {
+
+		lsr = be32_to_cpu(mmio[UART_LSR]);
+
+		/* Tx Fifo empty */
+		if (lsr & 0x20) {
+			mmio[UART_THR] = cpu_to_be32((int)ch);
+			break;
+		}
+	}
+}
+
+static char cerr_printk_buf[2048];
+static void cerr_printk(const char *fmt, ...)
+{
+	va_list args;
+	int len;
+	int i = 0;
+
+	va_start(args, fmt);
+	len = vsnprintf(cerr_printk_buf, sizeof(cerr_printk_buf), fmt, args);
+	va_end(args);
+
+	for (i = 0; i <= len; i++) {
+
+		if (cerr_printk_buf[i] == 0)
+			continue;
+
+		if (cerr_printk_buf[i] == '\n')
+			cerr_outbyte('\r');
+
+		cerr_outbyte(cerr_printk_buf[i]);
+	}
+
+}
+
+static void print_cerr_info(void)
+{
+	nlm_reg_t *nbu_mmio = netlogic_io_mmio(NETLOGIC_IO_BRIDGE_OFFSET);
+
+	uint64_t icu_log0 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_ICU, ICU_CERRLOG0_REGID);
+	uint64_t icu_log1 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_ICU, ICU_CERRLOG1_REGID);
+	uint64_t icu_log2 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_ICU, ICU_CERRLOG2_REGID);
+	uint64_t lsu_log0 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERRLOG0_REGID);
+	uint64_t lsu_log1 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERRLOG1_REGID);
+	uint64_t scu_log0 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_SCU, SCU_CERRLOG0_REGID);
+	uint64_t scu_log1 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_SCU, SCU_CERRLOG1_REGID);
+	uint64_t scu_log2 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_SCU, SCU_CERRLOG2_REGID);
+
+	cerr_printk("CPU: (XLP specific) ICU log0 = 0x%016llx, log1 = 0x%016llx, log2 = 0x%016llx\n"
+		    "                    LSU log0 = 0x%016llx, log1 = 0x%016llx\n"
+		    "                    SCU log0 = 0x%016llx, log1 = 0x%016llx, log2 = 0x%016llx\n",
+		    icu_log0, icu_log1, icu_log2,
+		    lsu_log0, lsu_log1,
+		    scu_log0, scu_log1, scu_log2);
+
+	cerr_printk("NBU: Bar Aerr reg0 = 0x%08x, reg1 = 0x%08x, reg2 = 0x%08x\n",
+		    netlogic_read_reg(nbu_mmio, 162), netlogic_read_reg(nbu_mmio, 163),
+		    netlogic_read_reg(nbu_mmio, 164));
+}
+
+/* On XLR/XLP, errors reported by bridge (like misconfigured BARS etc) are also
+ * reported as cache errors. Need to check if it is really a cache error or a "bus error"
+ * and take action appropriately.
+ * For now, treat it as a cache error
+ */
+asmlinkage void nlm_cache_error(void)
+{
+	local_irq_disable();
+
+	/* let the first cpu in */
+	while (nlm_cerr_lock)
+		;
+	nlm_cerr_lock = 1;
+
+	cerr_printk("*********************************************\n");
+	cerr_printk("cpu_%d received a bus/cache error\n", hard_smp_processor_id());
+	cerr_printk("*********************************************\n");
+
+	print_cerr_info();
+
+	cerr_printk("CPU: epc = 0x%lx, errorepc = 0x%lx, cacheerr = 0x%08x\n",
+			read_c0_epc(), read_c0_errorepc(), read_c0_cacheerr());
+
+	cerr_printk("Can not handle bus/cache error - Halting cpu\n");
+
+	cerr_cpu_halt();
+}
diff --git a/arch/mips/mm/cex-gen.S b/arch/mips/mm/cex-gen.S
index e743622..5dc41a4 100644
--- a/arch/mips/mm/cex-gen.S
+++ b/arch/mips/mm/cex-gen.S
@@ -5,6 +5,7 @@
  *
  * Copyright (C) 1995 - 1999 Ralf Baechle
  * Copyright (C) 1999 Silicon Graphics, Inc.
+ * Copyright (C) 2003-2010 Netlogic Microsystems Inc.
  *
  * Cache error handler
  */
@@ -36,7 +37,26 @@
 	nop
 	nop
 	nop
+#ifdef CONFIG_NLM_COMMON
 
+	/* If some other cpu is already in the handler
+	 * just wait... */
+	PTR_LA	k0, nlm_cerr_lock
+1:	lw	k1, 0(k0)
+	bnez	k1, 1b
+	nop
+
+	/* switch stack to a new one */
+	PTR_LA		sp, nlm_cerr_stack
+	li		k1, 8192 - 64
+	PTR_ADDU	sp, sp, k1
+
+	jal	nlm_cache_error
+	nop
+	/* should never get here */
+
+#else
 	j	cache_parity_error
 	nop
+#endif
 	END(except_vec2_generic)
-- 
1.7.0.2

