From 0f92e55a422001889275955d2ec09f2b5ca2db0e Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Thu, 27 Dec 2012 12:37:52 +0800
Subject: [PATCH 5/5] nlm_xlp_64_be-cgl: update to SDK2.2.5

Update this BSP to SDK2.2.5.

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/Kconfig                                  |    2 +-
 arch/mips/include/asm/atomic.h                     |   76 ++-
 arch/mips/include/asm/barrier.h                    |    7 +-
 arch/mips/include/asm/cacheflush.h                 |   20 +-
 arch/mips/include/asm/irq.h                        |    3 +
 arch/mips/include/asm/irq_regs.h                   |   18 +
 arch/mips/include/asm/irqflags.h                   |   42 +
 arch/mips/include/asm/mach-generic/irq.h           |    2 +-
 arch/mips/include/asm/mach-generic/spaces.h        |   15 +-
 .../asm/mach-netlogic/cpu-feature-overrides.h      |   68 +--
 .../mips/include/asm/mach-netlogic/dma-coherence.h |   70 --
 arch/mips/include/asm/mach-netlogic/spaces.h       |   22 +
 arch/mips/include/asm/mach-netlogic/xlp-mmu.h      |   37 +-
 arch/mips/include/asm/mipsregs.h                   |   91 +--
 arch/mips/include/asm/mmu_context.h                |   50 +-
 arch/mips/include/asm/msi.h                        |   25 +
 arch/mips/include/asm/netlogic/64bit.h             |   85 ++
 arch/mips/include/asm/netlogic/hal/nlm_hal_fmn.h   |    8 +-
 arch/mips/include/asm/netlogic/hal/nlm_hal_nae.h   |    4 +
 .../include/asm/netlogic/hal/nlm_hal_xlp_dev.h     |   18 +-
 arch/mips/include/asm/netlogic/interrupt.h         |   82 +--
 arch/mips/include/asm/netlogic/iomap.h             |   85 +-
 arch/mips/include/asm/netlogic/mips-exts.h         |  231 +++---
 arch/mips/include/asm/netlogic/sim.h               |   65 +-
 arch/mips/include/asm/netlogic/xlp.h               |   57 +-
 arch/mips/include/asm/netlogic/xlp8xx/cpu.h        |   47 +-
 arch/mips/include/asm/netlogic/xlp8xx/xlp_sys.h    |   47 +-
 arch/mips/include/asm/netlogic/xlp_irq.h           |   68 +-
 arch/mips/include/asm/page.h                       |   10 +-
 arch/mips/include/asm/perfctr.h                    |  238 ++++++
 arch/mips/include/asm/pgtable-64.h                 |   32 +-
 arch/mips/include/asm/pgtable-bits.h               |   26 +-
 arch/mips/include/asm/processor.h                  |   33 +-
 arch/mips/include/asm/spinlock.h                   |  118 ++-
 arch/mips/include/asm/stackframe.h                 |   70 +-
 arch/mips/include/asm/system.h                     |    5 +-
 arch/mips/include/asm/time.h                       |   25 +-
 arch/mips/include/asm/timex.h                      |   11 +-
 arch/mips/kernel/Makefile                          |    1 +
 arch/mips/kernel/asm-offsets.c                     |   33 +-
 arch/mips/kernel/binfmt_elfo32.c                   |   48 +-
 arch/mips/kernel/cevt-r4k.c                        |   26 +-
 arch/mips/kernel/cpu-probe.c                       |   56 +-
 arch/mips/kernel/entry.S                           |    2 +-
 arch/mips/kernel/genex.S                           |   34 +
 arch/mips/kernel/head.S                            |   55 +-
 arch/mips/kernel/kgdb.c                            |   57 ++
 arch/mips/kernel/r4k_switch.S                      |    2 +-
 arch/mips/kernel/setup.c                           |    1 +
 arch/mips/kernel/time.c                            |   48 +-
 arch/mips/kernel/traps.c                           |  187 ++++-
 arch/mips/kernel/unaligned.c                       |   14 +
 arch/mips/lib/delay.c                              |  105 +++-
 arch/mips/lib/dump_tlb.c                           |   29 +-
 arch/mips/mm/Makefile                              |    3 +-
 arch/mips/mm/c-phoenix.c                           |   34 +-
 arch/mips/mm/c-r4k.c                               |    8 +-
 arch/mips/mm/cache.c                               |   16 +-
 arch/mips/mm/cerr-nlm.c                            |  887 ++++++++++++++++++--
 arch/mips/mm/cex-gen.S                             |  212 ++++-
 arch/mips/mm/dma-default.c                         |   44 +-
 arch/mips/mm/fault.c                               |   85 +--
 arch/mips/mm/page.c                                |    2 +-
 arch/mips/mm/pgtable-64.c                          |   72 +-
 arch/mips/mm/tlb-r4k.c                             |  174 +++-
 arch/mips/mm/tlbex.c                               |  167 ++--
 arch/mips/mm/uasm.c                                |   11 +-
 arch/mips/mm/uasm.h                                |  222 +++++
 arch/mips/netlogic/Kconfig                         |    4 +-
 arch/mips/netlogic/boot/string.h                   |   14 +-
 arch/mips/netlogic/common/cpu_proc.c               |   75 ++-
 arch/mips/netlogic/common/fdt_helper.c             |   68 +-
 arch/mips/netlogic/common/memory.c                 |   59 +-
 arch/mips/netlogic/common/nlm_hal.c                |  325 +++++++-
 arch/mips/netlogic/common/nlm_hal_cpu_info.c       |    6 +-
 arch/mips/netlogic/common/nlm_hal_fmn_config.c     |   20 +-
 arch/mips/netlogic/common/nlm_hal_nae.c            |  114 ++--
 arch/mips/netlogic/common/platform.c               |  110 +++
 arch/mips/netlogic/common/smp.c                    |   54 +-
 arch/mips/netlogic/xlp/Makefile                    |   10 +-
 arch/mips/netlogic/xlp/cop2.S                      |  128 +++
 arch/mips/netlogic/xlp/cpu_control.c               |  125 +--
 arch/mips/netlogic/xlp/cpu_control_asm.S           |  106 +++-
 arch/mips/netlogic/xlp/cpu_control_macros.h        |   32 -
 arch/mips/netlogic/xlp/nmi.S                       |  115 ++-
 arch/mips/netlogic/xlp/on_chip.c                   |  338 +++------
 arch/mips/netlogic/xlp/platform-xlp.c              |  322 +++++++
 arch/mips/netlogic/xlp/platform.c                  |  148 +++-
 arch/mips/netlogic/xlp/setup.c                     |   89 ++-
 arch/mips/netlogic/xlp/smp.c                       |  103 ++-
 drivers/dma/nlm_adma.c                             |   55 +-
 drivers/dma/nlm_adma.h                             |   53 +-
 include/linux/perfctr.h                            |  199 +++++
 kernel/sched.c                                     |    1 +
 94 files changed, 5340 insertions(+), 1881 deletions(-)
 delete mode 100644 arch/mips/include/asm/mach-netlogic/dma-coherence.h
 create mode 100644 arch/mips/include/asm/msi.h
 create mode 100644 arch/mips/include/asm/netlogic/64bit.h
 create mode 100644 arch/mips/include/asm/perfctr.h
 create mode 100644 arch/mips/mm/uasm.h
 create mode 100644 arch/mips/netlogic/common/platform.c
 create mode 100644 arch/mips/netlogic/xlp/cop2.S
 delete mode 100644 arch/mips/netlogic/xlp/cpu_control_macros.h
 create mode 100644 arch/mips/netlogic/xlp/platform-xlp.c
 create mode 100644 include/linux/perfctr.h

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 3c441dc..95d243c 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -1973,7 +1973,7 @@ config CPU_R4400_WORKAROUNDS
 
 config HAVE_GET_CYCLES_32
 	def_bool y
-	depends on !CPU_R4400_WORKAROUNDS
+	depends on !CPU_R4400_WORKAROUNDS && !NLM_XLP
 	select HAVE_TRACE_CLOCK
 	select HAVE_TRACE_CLOCK_32_TO_64 if (!CPU_CAVIUM_OCTEON)
 	select HAVE_UNSYNCHRONIZED_TSC if (!CPU_CAVIUM_OCTEON)
diff --git a/arch/mips/include/asm/atomic.h b/arch/mips/include/asm/atomic.h
index 9a4c44f..eb7c120 100644
--- a/arch/mips/include/asm/atomic.h
+++ b/arch/mips/include/asm/atomic.h
@@ -1,3 +1,11 @@
+/*-
+ * Copyright 2006-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
 /*
  * Atomic operations that C can't guarantee us.  Useful for
  * resource counting etc..
@@ -76,7 +84,10 @@ static __inline__ void atomic_add(int i, atomic_t * v)
 		"1:	ll	%0, %1		# atomic_add		\n"
 		"	addu	%0, %2					\n"
 		"	sc	%0, %1					\n"
-		"	beqz	%0, 1b					\n"
+		"	beqz	%0, 2f					\n"
+		"	.subsection 2					\n"
+		"2:	b	1b					\n"
+		"	.previous					\n"
 		"	.set	mips0					\n"
 		: "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter));
@@ -122,7 +133,10 @@ static __inline__ void atomic_sub(int i, atomic_t * v)
 		"1:	ll	%0, %1		# atomic_sub		\n"
 		"	subu	%0, %2					\n"
 		"	sc	%0, %1					\n"
-		"	beqz	%0, 1b					\n"
+		"	beqz	%0, 2f					\n"
+		"	.subsection 2					\n"
+		"2:	b	1b					\n"
+		"	.previous					\n"
 		"	.set	mips0					\n"
 		: "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter));
@@ -146,7 +160,8 @@ static __inline__ int atomic_add_return(int i, atomic_t * v)
 	smp_mb__before_llsc();
 
 #ifdef CONFIG_NLM_ATOMICS
-	result = ldadd_w_ret(i, &v->counter);
+	result = ldadd_w(i, &v->counter);
+	result += i;
 #else
 	if (kernel_uses_llsc && R10000_LLSC_WAR) {
 		int temp;
@@ -170,8 +185,11 @@ static __inline__ int atomic_add_return(int i, atomic_t * v)
 		"1:	ll	%1, %2		# atomic_add_return	\n"
 		"	addu	%0, %1, %3				\n"
 		"	sc	%0, %2					\n"
-		"	beqz	%0, 1b					\n"
-		"	 addu	%0, %1, %3				\n"
+		"	beqz	%0, 2f					\n"
+		"	addu	%0, %1, %3				\n"
+		"	.subsection 2					\n"
+		"2:	b	1b					\n"
+		"	.previous					\n"
 		"	.set	mips0					\n"
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter)
@@ -199,7 +217,8 @@ static __inline__ int atomic_sub_return(int i, atomic_t * v)
 	smp_mb__before_llsc();
 
 #ifdef CONFIG_NLM_ATOMICS
-	result = ldadd_w_ret(-i, &v->counter);
+	result = ldadd_w(-i, &v->counter);
+	result -= i;
 #else
 	if (kernel_uses_llsc && R10000_LLSC_WAR) {
 		int temp;
@@ -223,8 +242,11 @@ static __inline__ int atomic_sub_return(int i, atomic_t * v)
 		"1:	ll	%1, %2		# atomic_sub_return	\n"
 		"	subu	%0, %1, %3				\n"
 		"	sc	%0, %2					\n"
-		"	beqz	%0, 1b					\n"
-		"	 subu	%0, %1, %3				\n"
+		"	beqz	%0, 2f					\n"
+		"	subu	%0, %1, %3				\n"
+		"	.subsection 2					\n"
+		"2:	b	1b					\n"
+		"	.previous					\n"
 		"	.set	mips0					\n"
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter)
@@ -287,9 +309,12 @@ static __inline__ int atomic_sub_if_positive(int i, atomic_t * v)
 		"	bltz	%0, 1f					\n"
 		"	sc	%0, %2					\n"
 		"	.set	noreorder				\n"
-		"	beqz	%0, 1b					\n"
+		"	beqz	%0, 2f					\n"
 		"	 subu	%0, %1, %3				\n"
 		"	.set	reorder					\n"
+		"	.subsection 2					\n"
+		"2:	b	1b					\n"
+		"	.previous					\n"
 		"1:							\n"
 		"	.set	mips0					\n"
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
@@ -453,7 +478,10 @@ static __inline__ void atomic64_add(long i, atomic64_t * v)
 		"1:	lld	%0, %1		# atomic64_add		\n"
 		"	daddu	%0, %2					\n"
 		"	scd	%0, %1					\n"
-		"	beqz	%0, 1b					\n"
+		"	beqz	%0, 2f					\n"
+		"	.subsection 2					\n"
+		"2:	b	1b					\n"
+		"	.previous					\n"
 		"	.set	mips0					\n"
 		: "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter));
@@ -495,7 +523,10 @@ static __inline__ void atomic64_sub(long i, atomic64_t * v)
 		"1:	lld	%0, %1		# atomic64_sub		\n"
 		"	dsubu	%0, %2					\n"
 		"	scd	%0, %1					\n"
-		"	beqz	%0, 1b					\n"
+		"	beqz	%0, 2f					\n"
+		"	.subsection 2					\n"
+		"2:	b	1b					\n"
+		"	.previous					\n"
 		"	.set	mips0					\n"
 		: "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter));
@@ -539,8 +570,11 @@ static __inline__ long atomic64_add_return(long i, atomic64_t * v)
 		"1:	lld	%1, %2		# atomic64_add_return	\n"
 		"	daddu	%0, %1, %3				\n"
 		"	scd	%0, %2					\n"
-		"	beqz	%0, 1b					\n"
-		"	 daddu	%0, %1, %3				\n"
+		"	beqz	%0, 2f					\n"
+		"	daddu	%0, %1, %3				\n"
+		"	.subsection 2					\n"
+		"2:	b	1b					\n"
+		"	.previous					\n"
 		"	.set	mips0					\n"
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter)
@@ -588,8 +622,11 @@ static __inline__ long atomic64_sub_return(long i, atomic64_t * v)
 		"1:	lld	%1, %2		# atomic64_sub_return	\n"
 		"	dsubu	%0, %1, %3				\n"
 		"	scd	%0, %2					\n"
-		"	beqz	%0, 1b					\n"
-		"	 dsubu	%0, %1, %3				\n"
+		"	beqz	%0, 2f					\n"
+		"	dsubu	%0, %1, %3				\n"
+		"	.subsection 2					\n"
+		"2:	b	1b					\n"
+		"	.previous					\n"
 		"	.set	mips0					\n"
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter)
@@ -651,9 +688,12 @@ static __inline__ long atomic64_sub_if_positive(long i, atomic64_t * v)
 		"	bltz	%0, 1f					\n"
 		"	scd	%0, %2					\n"
 		"	.set	noreorder				\n"
-		"	beqz	%0, 1b					\n"
+		"	beqz	%0, 2f					\n"
 		"	 dsubu	%0, %1, %3				\n"
 		"	.set	reorder					\n"
+		"	.subsection 2					\n"
+		"2:	b	1b					\n"
+		"	.previous					\n"
 		"1:							\n"
 		"	.set	mips0					\n"
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
@@ -772,10 +812,6 @@ static __inline__ int atomic64_add_unless(atomic64_t *v, long a, long u)
  */
 #define atomic64_add_negative(i, v) (atomic64_add_return(i, (v)) < 0)
 
-#else /* !CONFIG_64BIT */
-
-#include <asm-generic/atomic64.h>
-
 #endif /* CONFIG_64BIT */
 
 /*
diff --git a/arch/mips/include/asm/barrier.h b/arch/mips/include/asm/barrier.h
index 4873be0..4876a5e 100644
--- a/arch/mips/include/asm/barrier.h
+++ b/arch/mips/include/asm/barrier.h
@@ -84,6 +84,9 @@
 		".set	noreorder\n\t"		\
 		".set	mips2\n\t"		\
 		"sync\n\t"			\
+#ifdef CONFIG_NLM_XLP
+		"ehb\n\t"			\
+#endif
 		".set	pop"			\
 		: /* no output */		\
 		: /* no input */		\
@@ -157,7 +160,7 @@
 
 #if defined(CONFIG_WEAK_ORDERING) && defined(CONFIG_SMP)
 #ifdef CONFIG_NLM_XLP
-#define __WEAK_ORDERING_MB	".set push\n .set mips64r2\n sync\n ehb\n .set pop\n"
+#define __WEAK_ORDERING_MB	"sync\n ehb\n\n"
 #define smp_mb()	__asm__ __volatile__(__WEAK_ORDERING_MB : : : "memory")
 #define smp_rmb()	__asm__ __volatile__(__WEAK_ORDERING_MB : : : "memory")
 #define smp_wmb()	__asm__ __volatile__(__WEAK_ORDERING_MB : : : "memory")
@@ -180,7 +183,7 @@
 
 #if defined(CONFIG_WEAK_REORDERING_BEYOND_LLSC) && defined(CONFIG_SMP)
 #ifdef CONFIG_NLM_XLP
-#define __WEAK_LLSC_MB	".set push\n .set mips64r2\n sync\n ehb\n .set pop\n"
+#define __WEAK_LLSC_MB	"sync\n ehb\n"
 #else
 #define __WEAK_LLSC_MB		"       sync	\n"
 #endif
diff --git a/arch/mips/include/asm/cacheflush.h b/arch/mips/include/asm/cacheflush.h
index fd87738..bde1e47 100644
--- a/arch/mips/include/asm/cacheflush.h
+++ b/arch/mips/include/asm/cacheflush.h
@@ -1,3 +1,12 @@
+/*-
+ * Copyright 2003-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
+
 /*
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
@@ -5,7 +14,6 @@
  *
  * Copyright (C) 1994, 95, 96, 97, 98, 99, 2000, 01, 02, 03 by Ralf Baechle
  * Copyright (C) 1999, 2000, 2001 Silicon Graphics, Inc.
- * Copyright (C) 2003-2010 Netlogic Microsystems Inc.
  */
 #ifndef _ASM_CACHEFLUSH_H
 #define _ASM_CACHEFLUSH_H
@@ -42,9 +50,13 @@ extern void __flush_dcache_page(struct page *page);
 #define ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE 1
 static inline void flush_dcache_page(struct page *page)
 {
+#ifdef CONFIG_NLM_COMMON
+	extern void nlm_common_flush_dcache_page(struct page *page);
+	nlm_common_flush_dcache_page(page);  
+#else
 	if (cpu_has_dc_aliases || !cpu_has_ic_fills_f_dc)
 		__flush_dcache_page(page);
-
+#endif
 }
 
 #define flush_dcache_mmap_lock(mapping)		do { } while (0)
@@ -108,6 +120,10 @@ extern void (*flush_data_cache_page)(unsigned long addr);
 	set_bit(PG_dcache_dirty, &(page)->flags)
 #define ClearPageDcacheDirty(page)	\
 	clear_bit(PG_dcache_dirty, &(page)->flags)
+#ifdef CONFIG_NLM_COMMON
+#define TestPageDcacheDirty(page)	\
+	test_bit(PG_dcache_dirty, &(page)->flags)
+#endif
 
 /* Run kernel code uncached, useful for cache probing functions. */
 unsigned long run_uncached(void *func);
diff --git a/arch/mips/include/asm/irq.h b/arch/mips/include/asm/irq.h
index dea4aed..1f5c1e2 100644
--- a/arch/mips/include/asm/irq.h
+++ b/arch/mips/include/asm/irq.h
@@ -14,6 +14,9 @@
 
 #include <asm/mipsmtregs.h>
 
+#if CONFIG_NLM_XLP
+#include <asm/netlogic/xlp_irq.h>
+#endif
 #include <irq.h>
 
 #ifdef CONFIG_I8259
diff --git a/arch/mips/include/asm/irq_regs.h b/arch/mips/include/asm/irq_regs.h
index 33bd2a0..e51e91a 100644
--- a/arch/mips/include/asm/irq_regs.h
+++ b/arch/mips/include/asm/irq_regs.h
@@ -1,3 +1,11 @@
+/*-
+ * Copyright 2006-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
 /*
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -18,4 +26,14 @@ static inline struct pt_regs *get_irq_regs(void)
 	return current_thread_info()->regs;
 }
 
+static inline struct pt_regs *set_irq_regs(struct pt_regs *new_regs)
+{
+        struct pt_regs *old_regs;
+
+        old_regs = get_irq_regs();
+	current_thread_info()->regs = new_regs;
+
+        return old_regs;
+}
+
 #endif /* __ASM_IRQ_REGS_H */
diff --git a/arch/mips/include/asm/irqflags.h b/arch/mips/include/asm/irqflags.h
index 701ec0b..a0432be 100644
--- a/arch/mips/include/asm/irqflags.h
+++ b/arch/mips/include/asm/irqflags.h
@@ -1,3 +1,11 @@
+/*-
+ * Copyright 2003-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
 /*
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
@@ -15,6 +23,32 @@
 
 #include <linux/compiler.h>
 #include <asm/hazards.h>
+#include <asm/mipsregs.h>
+
+#ifdef CONFIG_64BIT
+#define TI_PREEMPT_COUNT 36
+#else
+#define TI_PREEMPT_COUNT 20
+#endif
+
+#ifdef CONFIG_PREEMPT
+
+#define __preempt_disable \
+	"lw  $1, "STR(TI_PREEMPT_COUNT)"($28) \n" \
+	"addiu $1, 1 \n" \
+	"sw $1, "STR(TI_PREEMPT_COUNT)"($28) \n"
+
+#define __preempt_enable \
+	"lw  $1, "STR(TI_PREEMPT_COUNT)"($28) \n" \
+	"subu $1, 1 \n" \
+	"sw $1, "STR(TI_PREEMPT_COUNT)"($28) \n"
+
+#else
+
+#define __preempt_disable
+#define __preempt_enable
+
+#endif
 
 __asm__(
 	"	.macro	raw_local_irq_enable				\n"
@@ -29,10 +63,12 @@ __asm__(
 #elif defined(CONFIG_CPU_MIPSR2)
 	"	ei							\n"
 #else
+	__preempt_disable
 	"	mfc0	$1,$12						\n"
 	"	ori	$1,0x1f						\n"
 	"	xori	$1,0x1e						\n"
 	"	mtc0	$1,$12						\n"
+	__preempt_enable
 #endif
 	"	irq_enable_hazard					\n"
 	"	.set	pop						\n"
@@ -87,11 +123,13 @@ __asm__(
 #elif defined(CONFIG_CPU_MIPSR2)
 	"	di							\n"
 #else
+	__preempt_disable
 	"	mfc0	$1,$12						\n"
 	"	ori	$1,0x1f						\n"
 	"	xori	$1,0x1f						\n"
 	"	.set	noreorder					\n"
 	"	mtc0	$1,$12						\n"
+	__preempt_enable
 #endif
 	"	irq_disable_hazard					\n"
 	"	.set	pop						\n"
@@ -138,11 +176,13 @@ __asm__(
 	"	di	\\result					\n"
 	"	andi	\\result, 1					\n"
 #else
+	__preempt_disable
 	"	mfc0	\\result, $12					\n"
 	"	ori	$1, \\result, 0x1f				\n"
 	"	xori	$1, 0x1f					\n"
 	"	.set	noreorder					\n"
 	"	mtc0	$1, $12						\n"
+	__preempt_enable
 #endif
 	"	irq_disable_hazard					\n"
 	"	.set	pop						\n"
@@ -184,12 +224,14 @@ __asm__(
 	"	ins	$1, \\flags, 0, 1				\n"
 	"	mtc0	$1, $12						\n"
 #else
+	__preempt_disable
 	"	mfc0	$1, $12						\n"
 	"	andi	\\flags, 1					\n"
 	"	ori	$1, 0x1f					\n"
 	"	xori	$1, 0x1f					\n"
 	"	or	\\flags, $1					\n"
 	"	mtc0	\\flags, $12					\n"
+	__preempt_enable
 #endif
 	"	irq_disable_hazard					\n"
 	"	.set	pop						\n"
diff --git a/arch/mips/include/asm/mach-generic/irq.h b/arch/mips/include/asm/mach-generic/irq.h
index 70d9a25..c2ae219 100644
--- a/arch/mips/include/asm/mach-generic/irq.h
+++ b/arch/mips/include/asm/mach-generic/irq.h
@@ -9,7 +9,7 @@
 #define __ASM_MACH_GENERIC_IRQ_H
 
 #ifndef NR_IRQS
-#define NR_IRQS	128
+#define NR_IRQS	384*4
 #endif
 
 #ifdef CONFIG_I8259
diff --git a/arch/mips/include/asm/mach-generic/spaces.h b/arch/mips/include/asm/mach-generic/spaces.h
index f161f24..e012ba5 100644
--- a/arch/mips/include/asm/mach-generic/spaces.h
+++ b/arch/mips/include/asm/mach-generic/spaces.h
@@ -1,3 +1,11 @@
+/*-
+ * Copyright 2004-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
 /*
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
@@ -51,7 +59,6 @@
 
 #if defined(CONFIG_MAPPED_KERNEL) && defined(CONFIG_KSEG2_LOWMEM)
 #define CAC_BASE                XKSEG
-#define PAGE_OFFSET	XKSEG
 #else /* !CONFIG_MAPPED_KERNEL */
 #define CAC_BASE		_AC(0xa800000000000000, UL)
 #endif /* CONFIG_MAPPED_KERNEL */
@@ -60,6 +67,12 @@
 
 #endif /* CAC_BASE */
 
+#if defined(CONFIG_MAPPED_KERNEL)  && defined(CONFIG_KSEG2_LOWMEM)
+#define PAGE_OFFSET	XKSEG
+#else
+#define PAGE_OFFSET	_AC(0xa800000000000000, UL)
+#endif
+
 #ifndef IO_BASE
 #define IO_BASE			_AC(0x9000000000000000, UL)
 #endif
diff --git a/arch/mips/include/asm/mach-netlogic/cpu-feature-overrides.h b/arch/mips/include/asm/mach-netlogic/cpu-feature-overrides.h
index 0ee47df..b4bca8f 100644
--- a/arch/mips/include/asm/mach-netlogic/cpu-feature-overrides.h
+++ b/arch/mips/include/asm/mach-netlogic/cpu-feature-overrides.h
@@ -1,63 +1,23 @@
-/*
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- */
+/*-
+ * Copyright 2003-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
 
 #ifndef __ASM_MACH_NLM_CPU_FEATURE_OVERRIDES_H
 #define __ASM_MACH_NLM_CPU_FEATURE_OVERRIDES_H
 
-/*
- * The current_cpu_type() defined in
- * arch/mips/include/asm/cpu-features.h called smp_processor_id(), which
- * may introduce warning about calling smp_processor_id() in preemptible
- * context, we don't care this for we have this unique cpu type in XLP,
- * so, define it as CPU_XLP directly will avoid this warning.
- */
-#define current_cpu_type() CPU_XLP
-
-#define cpu_icache_snoops_remote_store  0
-#define cpu_vmbits      62
-
-#define cpu_has_32fpr   0
-#define cpu_has_3k_cache        0
-#define cpu_has_4k_cache        0
-#define cpu_has_4kex    1
-#define cpu_has_64bits  1
-#define cpu_has_64bit_zero_reg  1
-#define cpu_has_cache_cdex_p    0
-#define cpu_has_cache_cdex_s    0
-#define cpu_has_counter 1
-#define cpu_has_divec   1
-#define cpu_has_dsp     0
-#define cpu_has_ejtag   1
-#define cpu_has_fpu     1
-#define cpu_has_ic_fills_f_dc   0
-#define cpu_has_inclusive_pcaches       0
-#define cpu_has_llsc    1
-#define cpu_has_mcheck  1
-#define cpu_has_mdmx    0
-#define cpu_has_mips16  0
-#define cpu_has_mips32r1        0
-#define cpu_has_mips32r2        0
-#define cpu_has_mips3d  0
-#define cpu_has_mips64r1        0
-#define cpu_has_mips64r2        1
-#define cpu_has_mipsmt  0
-#define cpu_has_nofpuex 0
-#define cpu_has_pindexed_dcache 0
-#define cpu_has_smartmips       0
-#define cpu_has_tlb     1
-#define cpu_has_tx39_cache      0
-#define cpu_has_userlocal       1
-#define cpu_has_vce     0
-#define cpu_has_veic    0
-#define cpu_has_vint    0
-#define cpu_has_vtag_icache     0
-#define cpu_has_watch   1
+#ifdef CONFIG_NLM_RIXI
+#define kernel_uses_smartmips_rixi (cpu_data[0].cputype == CPU_XLP)
+#else 
+#define kernel_uses_smartmips_rixi  0
+#endif
 
 #ifdef CONFIG_NLM_XLP
 #define cpu_has_dc_aliases     (PAGE_SIZE < (cpu_data[0].dcache.sets * cpu_data[0].dcache.linesz))
 #endif
 
-#endif /* __ASM_MACH_NLM_CPU_FEATURE_OVERRIDES_H */
+#endif  /* __ASM_MACH_NLM_CPU_FEATURE_OVERRIDES_H */
diff --git a/arch/mips/include/asm/mach-netlogic/dma-coherence.h b/arch/mips/include/asm/mach-netlogic/dma-coherence.h
deleted file mode 100644
index 288ce40..0000000
--- a/arch/mips/include/asm/mach-netlogic/dma-coherence.h
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- *
- * Copyright (C) 2006  Ralf Baechle <ralf@linux-mips.org>
- *
- */
-#ifndef __ASM_MACH_NLM_DMA_COHERENCE_H
-#define __ASM_MACH_NLM_DMA_COHERENCE_H
-
-struct device;
-
-static inline dma_addr_t plat_map_dma_mem(struct device *dev, void *addr,
-	size_t size)
-{
-	return virt_to_phys(addr);
-}
-
-static inline dma_addr_t plat_map_dma_mem_page(struct device *dev,
-	struct page *page)
-{
-	return page_to_phys(page);
-}
-
-static inline unsigned long plat_dma_addr_to_phys(struct device *dev,
-		dma_addr_t dma_addr)
-{
-	return dma_addr;
-}
-
-static inline void plat_unmap_dma_mem(struct device *dev, dma_addr_t dma_addr,
-	size_t size, enum dma_data_direction direction)
-{
-}
-
-static inline int plat_device_is_coherent(struct device *dev)
-{
-#ifdef CONFIG_DMA_COHERENT
-	return 1;
-#else /* CONFIG_DMA_NONCOHERENT */
-	return 0;
-#endif
-}
-
-static inline int plat_dma_supported(struct device *dev, u64 mask)
-{
-	/*
-	 * we fall back to GFP_DMA when the mask isn't all 1s,
-	 * so we can't guarantee allocations that must be
-	 * within a tighter range than GFP_DMA..
-	 */
-	if (mask < DMA_BIT_MASK(24))
-		return 0;
-
-	return 1;
-}
-
-static inline void plat_extra_sync_for_device(struct device *dev)
-{
-	return;
-}
-
-static inline int plat_dma_mapping_error(struct device *dev,
-					 dma_addr_t dma_addr)
-{
-	return 0;
-}
-
-#endif /* __ASM_MACH_GENERIC_DMA_COHERENCE_H */
diff --git a/arch/mips/include/asm/mach-netlogic/spaces.h b/arch/mips/include/asm/mach-netlogic/spaces.h
index 049d346..7d127fb 100644
--- a/arch/mips/include/asm/mach-netlogic/spaces.h
+++ b/arch/mips/include/asm/mach-netlogic/spaces.h
@@ -1,6 +1,28 @@
+/*-
+ * Copyright 2003-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
+
 #ifndef __NLM_SPACES_H__
 #define __NLM_SPACES_H__
 
+#ifndef __ASSEMBLY__
+#ifdef CONFIG_NLM_VMIPS
+extern unsigned long nlm_vmips_phys_offset;
+#define PHYS_OFFSET nlm_vmips_phys_offset
+
+extern unsigned long long nlm_vmips_highmem_start;
+#define        HIGHMEM_START   (nlm_vmips_highmem_start)
+
+#define PAGE_OFFSET (CAC_BASE)
+
+#endif
+#endif
+
 #include <asm/mach-generic/spaces.h>
 
 #endif
diff --git a/arch/mips/include/asm/mach-netlogic/xlp-mmu.h b/arch/mips/include/asm/mach-netlogic/xlp-mmu.h
index 85ac684..e159c0a 100644
--- a/arch/mips/include/asm/mach-netlogic/xlp-mmu.h
+++ b/arch/mips/include/asm/mach-netlogic/xlp-mmu.h
@@ -1,3 +1,32 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
 #ifndef _ASM_MACH_NLM_XLP_MMU_H
 #define _ASM_MACH_NLM_XLP_MMU_H
 
@@ -33,12 +62,8 @@ extern int is_nlm_xlp2xx_compat;
 
 static inline void setup_user_pgd(pgd_t *pgd)
 {
-#ifdef CONFIG_PGWALKER
-	if (read_c0_config6() & ENABLE_PGWALKER) {
-		get_cpu_var(pgd_bases)[USER_SEG] = (unsigned long) pgd;
-		put_cpu_var(pgd_bases);
-	}
-#endif
+	get_cpu_var(pgd_bases)[USER_SEG] = (unsigned long) pgd;
+	put_cpu_var(pgd_bases);
 };
 
 
diff --git a/arch/mips/include/asm/mipsregs.h b/arch/mips/include/asm/mipsregs.h
index e2c88b7..eec3c77 100644
--- a/arch/mips/include/asm/mipsregs.h
+++ b/arch/mips/include/asm/mipsregs.h
@@ -16,6 +16,7 @@
 #include <linux/linkage.h>
 #include <asm/hazards.h>
 #include <asm/war.h>
+#include <asm/netlogic/mips-exts.h>
 
 /*
  * The following macros are especially useful for __asm__
@@ -880,7 +881,18 @@ do {									\
 #define write_c0_count3(val)	__write_32bit_c0_register($9, 7, val)
 
 #define read_c0_entryhi()	__read_ulong_c0_register($10, 0)
+#if defined(CONFIG_NLMCOMMON_GLOBAL_TLB_SPLIT_ASID)
+extern unsigned int nlm_shtlb;
+#define write_c0_entryhi(val)   \
+	if(nlm_shtlb) \
+		__write_ulong_c0_register($10, 0, (((val) & ~0xc0)|(netlogic_thr_id()<<6))); \
+	else \
+		__write_ulong_c0_register($10, 0, val);
+#elif defined(CONFIG_NLMCOMMON_GLOBAL_TLB_GLOBAL_ASID)
+#define write_c0_entryhi(val)   __write_ulong_c0_register($10, 0, (((val) & ~0xc0)|(netlogic_thr_id()<<6)))
+#else
 #define write_c0_entryhi(val)	__write_ulong_c0_register($10, 0, val)
+#endif
 
 #define read_c0_compare()	__read_32bit_c0_register($11, 0)
 #define write_c0_compare(val)	__write_32bit_c0_register($11, 0, val)
@@ -892,7 +904,7 @@ do {									\
 #define write_c0_compare3(val)	__write_32bit_c0_register($11, 7, val)
 
 #define read_c0_status()	__read_32bit_c0_register($12, 0)
-#if defined(CONFIG_MIPS_MT_SMTC) || defined(CONFIG_CPU_XLP)
+#ifdef CONFIG_MIPS_MT_SMTC
 #define write_c0_status(val)						\
 do {									\
 	__write_32bit_c0_register($12, 0, val);				\
@@ -907,14 +919,7 @@ do {									\
 #endif /* CONFIG_MIPS_MT_SMTC */
 
 #define read_c0_cause()		__read_32bit_c0_register($13, 0)
-#ifdef CONFIG_CPU_XLP
-#define write_c0_cause(val) do {		\
-	__write_32bit_c0_register($13, 0, val);	\
-	__ehb();				\
-} while (0)
-#else
 #define write_c0_cause(val)	__write_32bit_c0_register($13, 0, val)
-#endif
 
 #define read_c0_epc()		__read_ulong_c0_register($14, 0)
 #define write_c0_epc(val)	__write_ulong_c0_register($14, 0, val)
@@ -1477,21 +1482,6 @@ static inline void tlb_write_random(void)
  * Manipulate bits in a c0 register.
  */
 #ifndef CONFIG_MIPS_MT_SMTC
-
-#ifdef CONFIG_CPU_XLP
-
-#include <linux/irqflags.h>
-
-static inline void __ehb(void)
-{
-	__asm__ __volatile__(
-	"	.set	mips32r2				\n"
-	"	nop						\n"
-	"	nop						\n"
-	"	ehb						\n"
-	"	.set	mips0					\n");
-}
-
 /*
  * SMTC Linux requires shutting-down microthread scheduling
  * during CP0 register read-modify-write sequences.
@@ -1501,13 +1491,10 @@ static inline unsigned int					\
 set_c0_##name(unsigned int set)					\
 {								\
 	unsigned int res, new;					\
-	unsigned long flags;					\
 								\
-	local_irq_save(flags);					\
 	res = read_c0_##name();					\
 	new = res | set;					\
 	write_c0_##name(new);					\
-	local_irq_restore(flags);				\
 								\
 	return res;						\
 }								\
@@ -1516,13 +1503,10 @@ static inline unsigned int					\
 clear_c0_##name(unsigned int clear)				\
 {								\
 	unsigned int res, new;					\
-	unsigned long flags;					\
 								\
-	local_irq_save(flags);					\
 	res = read_c0_##name();					\
 	new = res & ~clear;					\
 	write_c0_##name(new);					\
-	local_irq_restore(flags);				\
 								\
 	return res;						\
 }								\
@@ -1531,64 +1515,15 @@ static inline unsigned int					\
 change_c0_##name(unsigned int change, unsigned int val)		\
 {								\
 	unsigned int res, new;					\
-	unsigned long flags;					\
 								\
-	local_irq_save(flags);					\
 	res = read_c0_##name();					\
 	new = res & ~change;					\
 	new |= (val & change);					\
 	write_c0_##name(new);					\
-	local_irq_restore(flags);				\
 								\
 	return res;						\
 }
 
-#else /* !CONFIG_CPU_XLP */
-
-/*
- * SMTC Linux requires shutting-down microthread scheduling
- * during CP0 register read-modify-write sequences.
- */
-#define __BUILD_SET_C0(name)					\
-static inline unsigned int					\
-set_c0_##name(unsigned int set)					\
-{								\
-	unsigned int res, new;					\
-								\
-	res = read_c0_##name();					\
-	new = res | set;					\
-	write_c0_##name(new);					\
-								\
-	return res;						\
-}								\
-								\
-static inline unsigned int					\
-clear_c0_##name(unsigned int clear)				\
-{								\
-	unsigned int res, new;					\
-								\
-	res = read_c0_##name();					\
-	new = res & ~clear;					\
-	write_c0_##name(new);					\
-								\
-	return res;						\
-}								\
-								\
-static inline unsigned int					\
-change_c0_##name(unsigned int change, unsigned int val)		\
-{								\
-	unsigned int res, new;					\
-								\
-	res = read_c0_##name();					\
-	new = res & ~change;					\
-	new |= (val & change);					\
-	write_c0_##name(new);					\
-								\
-	return res;						\
-}
-
-#endif	/* CONFIG_CPU_XLP */
-
 #else /* SMTC versions that manage MT scheduling */
 
 #include <linux/irqflags.h>
diff --git a/arch/mips/include/asm/mmu_context.h b/arch/mips/include/asm/mmu_context.h
index f385039..727d362 100644
--- a/arch/mips/include/asm/mmu_context.h
+++ b/arch/mips/include/asm/mmu_context.h
@@ -1,3 +1,12 @@
+/*-
+ * Copyright 2003-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
+
 /*
  * Switch a MMU context.
  *
@@ -7,7 +16,6 @@
  *
  * Copyright (C) 1996, 1997, 1998, 1999 by Ralf Baechle
  * Copyright (C) 1999 Silicon Graphics, Inc.
- * Copyright (C) 2003-2010 Netlogic Microsystems Inc.
  */
 #ifndef _ASM_MMU_CONTEXT_H
 #define _ASM_MMU_CONTEXT_H
@@ -35,34 +43,6 @@
 static inline void setup_user_pgd(pgd_t *pgd) { }
 #endif
 
-
-#ifdef CONFIG_MIPS_PGD_C0_CONTEXT
-
-#define TLBMISS_HANDLER_SETUP_PGD(pgd)				\
-	tlbmiss_handler_setup_pgd((unsigned long)(pgd))
-
-static inline void tlbmiss_handler_setup_pgd(unsigned long pgd)
-{
-	/* Check for swapper_pg_dir and convert to physical address. */
-	if ((pgd & CKSEG3) == CKSEG0)
-		pgd = CPHYSADDR(pgd);
-	write_c0_context(pgd << 11);
-}
-
-#define TLBMISS_HANDLER_SETUP()						\
-	do {								\
-		TLBMISS_HANDLER_SETUP_PGD(swapper_pg_dir);		\
-		write_c0_xcontext((unsigned long) smp_processor_id() << 51); \
-	} while (0)
-
-
-static inline unsigned long get_current_pgd(void)
-{
-	return PHYS_TO_XKSEG_CACHED((read_c0_context() >> 11) & ~0xfffUL);
-}
-
-#else /* CONFIG_MIPS_PGD_C0_CONTEXT: using  pgd_current*/
-
 /*
  * For the fast tlb miss handlers, we keep a per cpu array of pointers
  * to the current pgd for each processor. Also, the proc. id is stuffed
@@ -85,7 +65,7 @@ extern unsigned long pgd_current[];
 	back_to_back_c0_hazard();					\
 	TLBMISS_HANDLER_SETUP_PGD(swapper_pg_dir)
 #endif
-#endif /* CONFIG_MIPS_PGD_C0_CONTEXT*/
+
 #if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
 
 #define ASID_INC	0x40
@@ -111,8 +91,15 @@ extern unsigned long smtc_asid_mask;
 /* End SMTC/34K debug hack */
 #else /* FIXME: not correct for R6000 */
 
+#ifdef CONFIG_NLMCOMMON_GLOBAL_TLB_SPLIT_ASID
+#define ASID_INC    0x1
+extern unsigned long nlm_asid_mask;
+#define ASID_MASK   nlm_asid_mask
+#else
+
 #define ASID_INC	0x1
 #define ASID_MASK	0xff
+#endif
 
 #endif
 
@@ -280,6 +267,7 @@ activate_mm(struct mm_struct *prev, struct mm_struct *next)
 	disable_pgwalker(pflags);
 	write_c0_entryhi(cpu_asid(cpu, next));
 #endif /* CONFIG_MIPS_MT_SMTC */
+
 	TLBMISS_HANDLER_SETUP_PGD(next->pgd);
 	setup_user_pgd(next->pgd);
 	enable_pgwalker(pflags);
@@ -332,6 +320,7 @@ drop_mmu_context(struct mm_struct *mm, unsigned cpu)
 #endif /* CONFIG_MIPS_MT_SMTC */
 	} else {
 		/* will get a new context next time */
+
 #ifndef CONFIG_MIPS_MT_SMTC
 		cpu_context(cpu, mm) = 0;
 #else /* SMTC */
@@ -344,6 +333,7 @@ drop_mmu_context(struct mm_struct *mm, unsigned cpu)
 			cpu_context(i, mm) = 0;
 		}
 #endif /* CONFIG_MIPS_MT_SMTC */
+
 	}
 	local_irq_restore(flags);
 }
diff --git a/arch/mips/include/asm/msi.h b/arch/mips/include/asm/msi.h
new file mode 100644
index 0000000..307715e
--- /dev/null
+++ b/arch/mips/include/asm/msi.h
@@ -0,0 +1,25 @@
+/*-
+ * Copyright 2004-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
+
+/*
+ * Copyright (C) 2003-2004 Intel
+ * Copyright (C) Tom Long Nguyen (tom.l.nguyen@intel.com)
+ */
+
+#ifndef ASM_MSI_H
+#define ASM_MSI_H
+
+#define NR_VECTORS              128
+#define NR_IRQ_VECTORS          NR_IRQS
+#define FIRST_DEVICE_VECTOR     0x00
+
+#define LAST_DEVICE_VECTOR		232
+#define MSI_TARGET_CPU_SHIFT	12
+
+#endif /* ASM_MSI_H */
diff --git a/arch/mips/include/asm/netlogic/64bit.h b/arch/mips/include/asm/netlogic/64bit.h
new file mode 100644
index 0000000..31bfbb1
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/64bit.h
@@ -0,0 +1,85 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+
+#ifndef _ASM_NLM_64BIT_H
+#define _ASM_NLM_64BIT_H
+
+#include <linux/types.h>
+#include <asm/system.h>
+
+/* Implement 64bit read and write operations */
+
+static inline void out64(u64 val, unsigned long addr)
+{
+  u32 low, high, tmp;
+  unsigned long flags=0;
+
+  high = val >> 32;
+  low = val & 0xffffffff;
+  local_irq_save(flags);
+  __asm__ __volatile__ (
+			".set push\t\t\t# out64n"
+			".set noreorder\n"
+			".set noat\n"
+			".set mips4\n"
+			"   dsll32 %0, %2, 0   \n"
+			"   dsll32 $1, %1, 0   \n"
+			"   dsrl32 %0, %0, 0   \n"
+			"   or     $1, $1, %0  \n"
+			"   sd $1, (%3)\n"
+			".set pop\n"
+			: "=&r" (tmp)
+			: "r" (high), "r" (low), "r" (addr));
+  local_irq_restore(flags);
+}
+
+static inline u64 in64(unsigned long addr)
+{
+  unsigned long flags;
+  u32 low, high;
+
+  local_irq_save(flags);
+  __asm__ __volatile__ (
+			".set push\t\t\t# in64\n"
+			".set noreorder\n"
+			".set noat     \n"
+			".set mips4    \n"
+			"  ld     %1, (%2)\n"
+			"  dsra32 %0, %1, 0\n"
+			"  sll    %1, %1, 0\n"
+			".set pop\n"
+			: "=r" (high), "=r" (low)
+			: "r" (addr));
+  local_irq_restore(flags);
+
+  return (((u64)high) << 32) | low;
+}
+
+#endif 
diff --git a/arch/mips/include/asm/netlogic/hal/nlm_hal_fmn.h b/arch/mips/include/asm/netlogic/hal/nlm_hal_fmn.h
index 49ecdba..cc45f83 100644
--- a/arch/mips/include/asm/netlogic/hal/nlm_hal_fmn.h
+++ b/arch/mips/include/asm/netlogic/hal/nlm_hal_fmn.h
@@ -202,7 +202,9 @@ static inline int xlp_send(unsigned int dest)
                           ".set noreorder\n"
                           ".set arch=xlp\n"
                           "sync\n"
+#ifdef CONFIG_NLM_XLP
                           "ehb\n"
+#endif
                           "msgsnds %0, %1\n"
                           ".set pop\n"
                           : "=&r" (success)
@@ -520,7 +522,9 @@ static inline void xlp_message_send_block_fast_1(unsigned int code,
 			".set arch=xlp\n"
 			"dmtc2 %1, "STR(XLP_TX_BUF_REG)", 0\n"
 			"sync\n"
+#ifdef CONFIG_NLM_XLP
 			"ehb\n"
+#endif
 			"1: \n"
 			"msgsnds  $8, %0\n"    /* msgsnds rD, rt */
 			"andi $8, $8, 0x1\n"
@@ -603,7 +607,9 @@ static inline void xlp_message_send_block_fast_3(unsigned int code,
 			"dmtc2 %2, "STR(XLP_TX_BUF_REG)", 1\n"
 			"dmtc2 %3, "STR(XLP_TX_BUF_REG)", 2\n"
 			"sync\n"
+#ifdef CONFIG_NLM_XLP
 			"ehb\n"
+#endif
 			"1: \n"
 			"msgsnds  $8, %0\n"    /* msgsnds rD, rt */
 			"andi $8, $8, 0x1\n"
@@ -882,7 +888,7 @@ static __inline__ int fmn_level_int_val(uint64_t outq_config)
 }
 
 extern int get_dom_fmn_node_ownership(void *fdt, int dom_id);
-extern void nlm_hal_fmn_init(void *fdt);
+extern void nlm_hal_fmn_init(void *fdt, int node);
 extern void nlm_hal_set_fmn_interrupt(int irq);
 
 extern void nlm_hal_disable_vc_intr(int node, int vc);
diff --git a/arch/mips/include/asm/netlogic/hal/nlm_hal_nae.h b/arch/mips/include/asm/netlogic/hal/nlm_hal_nae.h
index a4acf3d..5734f93 100644
--- a/arch/mips/include/asm/netlogic/hal/nlm_hal_nae.h
+++ b/arch/mips/include/asm/netlogic/hal/nlm_hal_nae.h
@@ -355,6 +355,10 @@ extern int nlm_hal_open_if(int node, int intf_type, int  block);
 extern int nlm_hal_close_if(int node, int intf_type, int  block);
 extern void nlm_hal_init_ingress(int node, int desc_size);
 
+extern void nlm_hal_init_ext_phy(int node, int inf);
+extern void nlm_hal_ext_phy_an(int node, int inf);
+extern void nlm_hal_restart_an(int node, int inf);
+
 extern int nlm_enable_poe_statistics(int node);
 extern int nlm_disable_poe_statistics(int node);
 extern int nlm_read_poe_statistics(int node, struct poe_statistics *stats);
diff --git a/arch/mips/include/asm/netlogic/hal/nlm_hal_xlp_dev.h b/arch/mips/include/asm/netlogic/hal/nlm_hal_xlp_dev.h
index 9875c46..a120311 100644
--- a/arch/mips/include/asm/netlogic/hal/nlm_hal_xlp_dev.h
+++ b/arch/mips/include/asm/netlogic/hal/nlm_hal_xlp_dev.h
@@ -1395,14 +1395,20 @@ enum {
 	#define VSEMI_CTL_SYNTH_RST		(1<<10)
 	#define VSEMI_CTL_RTHR			(0xf<<12)	
 #define VSEMI_CTL1			0xB
-	#define VSEMI_CTL_XAUI_12G_DR	(0x3)		
-	#define VSEMI_CTL_XAUI_12G_DW	(1<<4)
-	#define VSEMI_CTL_XAUI_16G_DR	(0x3)	
-	#define VSEMI_CTL_XAUI_16G_DW	(0x1<<4)
+
+	#define VSEMI_CTL_MASK_DR	(0x7)
+	#define VSEMI_CTL_RXAUI_10G_DR	(0x3)
+	#define VSEMI_CTL_XAUI_16G_DR	(0x3)
+	#define VSEMI_CTL_XAUI_12G_DR	(0x3)
 	#define VSEMI_CTL_XAUI_DR	(0x2)
-	#define VSEMI_CTL_XAUI_DW	(1<<4)
 	#define VSEMI_CTL_SGMII_DR	(0x1)
-	#define VSEMI_CTL_SGMII_DW	(0x1<<4)
+
+	#define VSEMI_CTL_MASK_DW	(0x70)
+	#define VSEMI_CTL_RXAUI_10G_DW	(0x30)
+	#define VSEMI_CTL_XAUI_16G_DW	(0x10)
+	#define VSEMI_CTL_XAUI_12G_DW	(0x10)
+	#define VSEMI_CTL_XAUI_DW	(0x10)
+	#define VSEMI_CTL_SGMII_DW	(0x10)
 	
 #define VSEMI_STATUS			0xC
 #define VSEMI_PINCTRL			0xD
diff --git a/arch/mips/include/asm/netlogic/interrupt.h b/arch/mips/include/asm/netlogic/interrupt.h
index 5fa0d53..a051f30 100644
--- a/arch/mips/include/asm/netlogic/interrupt.h
+++ b/arch/mips/include/asm/netlogic/interrupt.h
@@ -1,60 +1,42 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
 
 #ifndef _ASM_NLM_INTERRUPT_H
 #define _ASM_NLM_INTERRUPT_H
 
 #ifdef CONFIG_NLM_XLP
 #include <asm/netlogic/xlp_irq.h>
-#else
-#include <asm/netlogic/pic.h>
-
-/* Defines for the IRQ numbers */
-#define NR_IRQS			256
-#define IRQ_DUMMY_UART           2
-#define IRQ_IPI_SMP_FUNCTION     3
-#define IRQ_IPI_SMP_RESCHEDULE   4
-#define IRQ_REMOTE_DEBUG         5
-#define IRQ_MSGRING              6
-#define IRQ_TIMER                7
-#define IRQ_IPI_SMP_KGDB   		50
-#define IRQ_IPI_OPROFILE        51
-
-#define IRQ_IPI_CRF_MGMT_IPI	NLM_MANAGEMENT_IPI /* */
-#define IRQ_IPI_CRF_EVENTQ_IPI  NLM_EVENTQ_IPI
-
-#ifdef CONFIG_NLMCOMMON_IP_FLOW_AFFINITY
-
-#define IRQ_IPI_NETRX           49
-#define SMP_NETRX_IPI           32
-
-#endif /* CONFIG_NLMCOMMON_IP_FLOW_AFFINITY */
-
+#endif
 
-#define SMP_CALL_KGDB_HOOK 	8
-#define SMP_OPROFILE_IPI        16
+#if defined CONFIG_NLM_XLR
+#include <asm/netlogic/pic.h>
 #endif		// CONFIG_NLM_XLP
 
 #endif
diff --git a/arch/mips/include/asm/netlogic/iomap.h b/arch/mips/include/asm/netlogic/iomap.h
index e67019f..4eb11d1 100644
--- a/arch/mips/include/asm/netlogic/iomap.h
+++ b/arch/mips/include/asm/netlogic/iomap.h
@@ -1,31 +1,47 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
 
 #ifndef _ASM_RFI_IO_H
 #define _ASM_RFI_IO_H
 
+#if defined(CONFIG_NLM_XLR)
+#define DEFAULT_NETLOGIC_IO_BASE 0xffffffffbef00000ULL
+#define NETLOGIC_IO_DDR2_CHN0_OFFSET       0x01000
+#define NETLOGIC_IO_DDR2_CHN1_OFFSET       0x02000
+#define NETLOGIC_IO_DDR2_CHN2_OFFSET       0x03000
+#define NETLOGIC_IO_DDR2_CHN3_OFFSET       0x04000
+#define NETLOGIC_IO_PIC_OFFSET             0x08000
+#define NETLOGIC_IO_UART_0_OFFSET          0x14000
+#define NETLOGIC_IO_UART_1_OFFSET          0x15100
+
+#else
 #define DEFAULT_NETLOGIC_IO_BASE 0xffffffffb8000000ULL
 #define NETLOGIC_IO_DDR2_CHN0_OFFSET       0x14000
 #define NETLOGIC_IO_DDR2_CHN1_OFFSET       0x15000
@@ -35,6 +51,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define NETLOGIC_IO_UART_0_OFFSET          0x30100
 #define NETLOGIC_IO_UART_1_OFFSET          0x31100
 #define NETLOGIC_IO_SYS_OFFSET             0x35100
+#endif /* CONFIG_NLM_XLP */
 
 #define NETLOGIC_IO_SIZE                   0x1000
 
@@ -55,6 +72,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define NETLOGIC_IO_GMAC_2_OFFSET          0x0E000
 #define NETLOGIC_IO_GMAC_3_OFFSET          0x0F000
 
+#ifdef XLS
 #define NETLOGIC_IO_GMAC_4_OFFSET          0x20000
 #define NETLOGIC_IO_GMAC_5_OFFSET          0x21000
 #define NETLOGIC_IO_GMAC_6_OFFSET          0x22000
@@ -70,6 +88,8 @@ THE POSSIBILITY OF SUCH DAMAGE.
 
 #define NETLOGIC_IO_COMP_OFFSET            0x1D000
 
+#endif /* XLS */
+
 #define NETLOGIC_IO_SPI4_0_OFFSET          0x10000
 #define NETLOGIC_IO_XGMAC_0_OFFSET         0x11000
 #define NETLOGIC_IO_SPI4_1_OFFSET          0x12000
@@ -275,23 +295,6 @@ static inline void nlm_br_write_unlock(unsigned int flags)
 
 extern void on_chip_init(void);
 
-extern unsigned int xlp_uart_portid;
-static inline void xlp_prom_putchar(char c)
-{
-	nlm_reg_t *mmio;
-	switch(xlp_uart_portid){
-		default:
-		case 0:
-			mmio = netlogic_io_mmio(NETLOGIC_IO_UART_0_OFFSET);
-			break;
-		case 1:
-			mmio = netlogic_io_mmio(NETLOGIC_IO_UART_1_OFFSET);
-			break;
-	}
-	while (netlogic_read_reg( mmio, 0x5) == 0);
-		netlogic_write_reg( mmio, 0x0, c);
-}
-
 #endif /* __ASSEMBLY__ */
 
 #endif
diff --git a/arch/mips/include/asm/netlogic/mips-exts.h b/arch/mips/include/asm/netlogic/mips-exts.h
index bfef082..51c78e1 100644
--- a/arch/mips/include/asm/netlogic/mips-exts.h
+++ b/arch/mips/include/asm/netlogic/mips-exts.h
@@ -1,27 +1,32 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
 
 #ifndef _ASM_NLM_MIPS_EXTS_H
 #define _ASM_NLM_MIPS_EXTS_H
@@ -50,9 +55,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #ifndef __ASSEMBLY__
 
 #include <linux/types.h>
-#include <asm/netlogic/interrupt.h>
-#include <asm/netlogic/iomap.h>
-#include <asm/asm.h>
+//#include <asm/netlogic/interrupt.h>
 
 /* Scratch registers used */
 #define NLM_TLB_STATS_SCRATCH_REG_SEL  2
@@ -177,109 +180,79 @@ static inline void write_64bit_cp0_eimr(__u64 value)
 }
 
 #ifdef CONFIG_NLM_ATOMICS
-
-/* LDADD* instructions are documented in page 155~156 in "XLP Processor
- * Family Programming Reference Manual"
- *
- * ldaddw rt, base:
- *     v <- rt; rt <- memory[base]; memory[base] <- memory[base] + v;
- *
- * "ldaddw rt, base" overrides the register rt and put *base to it, so,
- * a temp register should be used for it.
- */
-
-static inline int ldadd_w(unsigned int value, volatile int *addr)
+static __inline__ int ldadd_w(unsigned int value, volatile int *addr)
 {
 	unsigned long res;
-
-	asm volatile (
-			".set push\n"
-			".set noreorder\n"
-			"move $8, %2\n"
-			"ldaddw $8, %3\n"
-#ifdef CONFIG_NLM_XLP
-			"ehb\n"
-#endif
-			"move %0, $8\n"
-			".set pop\n"
-			: "=r"(res), "+m"(*addr)
-			: "r" (value), "r"((unsigned long)addr)
-			: "$8"
-			);
-	return res;
+  __asm__ __volatile__(
+		       ".set push\n"
+		       ".set noreorder\n"
+		       "move $8, %2\n"
+		       "move $9, %3\n"
+		       //"ldaddw %2, %3\n"
+                       ".word 0x71280010\n"
+		       "move %0, $8\n"
+		       ".set pop\n"
+		       :"=r"(res), "+m"(*addr)
+		       : "r" (value), "r"((unsigned long)addr)
+		       : "$8", "$9"
+		       );
+  return res;
 }
 
-static inline int ldadd_w_ret(unsigned int value, volatile int *addr)
+static __inline__ void ldadd_w_no_read(int value, volatile int *addr)
 {
 	unsigned long res;
-	asm volatile (
-			".set push\n"
-			".set noreorder\n"
-			"move $8, %2\n"
-			"ldaddw $8, %3\n"
-#ifdef CONFIG_NLM_XLP
-			"ehb\n"
-#endif
-			STR(PTR_ADDU) " %0, $8, %2\n"
-			".set pop\n"
-			: "=r"(res), "+m"(*addr)
-			: "r" (value), "r"((unsigned long)addr)
-			: "$8"
-			);
-	return res;
-}
-
-static inline void ldadd_w_no_read(int value, volatile int *addr)
-{
-	asm volatile (
-			".set push\n"
-			".set noreorder\n"
-			"move $8, %1\n"
-			"ldaddw $8, %2\n"
-#ifdef CONFIG_NLM_XLP
-			"ehb\n"
-#endif
-			".set pop\n"
-			: "+m"(*addr)
-			: "r" (value), "r"((unsigned long)addr)
-			: "$8"
-			);
+  __asm__ __volatile__(
+                       ".set push\n"
+                       ".set noreorder\n"
+                       "move $8, %2\n"
+                       "move $9, %3\n"
+                       //"ldaddw $8, $9\n"
+                       ".word 0x71280010\n"
+                       //"move %0, $8\n"
+                       ".set pop\n"
+                       :"=r"(res), "+m"(*addr)
+                       : "r" (value), "r"((unsigned long)addr)
+                       : "$8", "$9"
+                       );
 }
 
-static inline unsigned int ldadd_wu(unsigned int value, volatile unsigned int *addr)
+static __inline__ unsigned int ldadd_wu(unsigned int value, volatile unsigned int *addr)
 {
 	unsigned long res;
-	asm volatile (
-			".set push\n"
-			".set noreorder\n"
-			"move $8, %2\n"
-			"ldaddwu $8, %3\n"
-#ifdef CONFIG_NLM_XLP
-			"ehb\n"
-#endif
-			"move %0, $8\n"
-			".set pop\n"
-			: "=r"(res), "+m"(*addr)
-			: "r"(value), "r"((unsigned long)addr)
-			: "$8"
-			);
-	return res;
+  __asm__ __volatile__(
+		       ".set push\n"
+		       ".set noreorder\n"
+		       "move $8, %2\n"
+		       "move $9, %3\n"
+		       //"ldaddwu $8, $9\n"
+                       ".word 0x71280011\n"
+		       "move %0, $8\n"
+		       ".set pop\n"
+		       :"=r"(res), "+m"(*addr)
+		       : "r"(value), "r"((unsigned long)addr)
+		       : "$8", "$9"
+		       );
+  return res;
 }
 
-static inline void ldadd_wu_no_read(unsigned int value,
+static __inline__ void ldadd_wu_no_read(unsigned int value,
 					volatile unsigned int *addr)
 {
-	asm volatile (
-			".set push\n"
-			".set noreorder\n"
-			"ldaddwu %1, %2\n"
-#ifdef CONFIG_NLM_XLP
-			"ehb\n"
-#endif
-			".set pop\n"
-			: "+m"(*addr)
-			: "r"(value), "r"((unsigned long)addr)
-			);
+	unsigned long res;
+  __asm__ __volatile__(
+                       ".set push\n"
+                       ".set noreorder\n"
+                       "move $8, %2\n"
+                       "move $9, %3\n"
+                       //"ldaddwu $8, $9\n"
+                       ".word 0x71280011\n"
+                       //"move %0, $8\n"
+                       ".set pop\n"
+                       :"=r"(res), "+m"(*addr)
+                       : "r"(value), "r"((unsigned long)addr)
+                       : "$8", "$9"
+                       );
 }
 #endif /* CONFIG_NLM_ATOMICS */
 
@@ -322,6 +295,9 @@ static __inline__ int netlogic_thr_id(void)
 #define CPU_BLOCKID_MMU      4
 #define CPU_BLOCKID_PRF      5
 
+#ifdef CONFIG_NLM_XLR
+#define LSU_CERRLOG_REGID    9
+#else
 #define CPU_BLOCKID_SCU      8
 
 #define ICU_CERRLOG0_REGID   0x10
@@ -335,6 +311,8 @@ static __inline__ int netlogic_thr_id(void)
 #define SCU_CERRLOG1_REGID   0x11
 #define SCU_CERRLOG2_REGID   0x12
 
+#endif
+
 static __inline__ unsigned int read_32bit_nlm_ctrl_reg(int block, int reg)
 {
   unsigned int __res;
@@ -421,6 +399,27 @@ static __inline__ void write_64bit_nlm_ctrl_reg(int block, int reg,unsigned long
 
 typedef struct { volatile int value; } nlm_common_atomic_t;
 
+#ifdef CONFIG_NLM_XLR
+static __inline__ int nlm_common_test_and_set(nlm_common_atomic_t *lock)
+{
+  int oldval = 0;
+
+  __asm__ __volatile__ (".set push\n"
+			".set noreorder\n"
+			"move $9, %2\n"
+			"li $8, 1\n"
+			//"swapw $8, $9\n"
+			".word 0x71280014\n"
+			"move %1, $8\n"
+			".set pop\n"
+			: "+m" (lock->value), "=r" (oldval)
+			: "r" ((unsigned long)&lock->value)
+			: "$8", "$9"
+			);
+  return (oldval == 0 ? 1/*success*/ : 0/*failure*/);
+}
+#endif /* CONFIG_NLM_XLR */
+
 #define nlm_write_os_scratch_2(val)	__write_64bit_c0_register($22, 2, val)
 #define nlm_read_os_scratch_2()	__read_64bit_c0_register($22, 2)
 
diff --git a/arch/mips/include/asm/netlogic/sim.h b/arch/mips/include/asm/netlogic/sim.h
index 6c56db9..b360a94 100644
--- a/arch/mips/include/asm/netlogic/sim.h
+++ b/arch/mips/include/asm/netlogic/sim.h
@@ -1,27 +1,32 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
 
 #ifndef _ASM_SIM_H
 #define _ASM_SIM_H
@@ -107,18 +112,6 @@ struct environment
 #define NLM_XLR_BOARD_ARIZONA_XI 11
 #define NLM_XLR_BOARD_ARIZONA_XII  12
 
-struct smp_boot_info_percpu {
-  volatile unsigned long ready;
-  volatile unsigned long sp;
-  volatile unsigned long gp;
-  volatile unsigned long fn;
-};
-
-struct smp_boot_info {
-  struct smp_boot_info_percpu boot_info[NR_CPUS];
-  __u32 online_map;
-};
-
 extern struct smp_boot_info smp_boot;
 extern void prom_boot_cpus_secondary(void *);
 
diff --git a/arch/mips/include/asm/netlogic/xlp.h b/arch/mips/include/asm/netlogic/xlp.h
index 227c694..49f6697 100644
--- a/arch/mips/include/asm/netlogic/xlp.h
+++ b/arch/mips/include/asm/netlogic/xlp.h
@@ -1,27 +1,32 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
 
 #ifndef _ASM_XLP_H
 #define _ASM_XLP_H
@@ -62,6 +67,9 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define XLP_DEVID_NAND          0x1016
 #define XLP_DEVID_SPI           0x1017
 #define XLP_DEVID_MMC           0x1018
+#define XLP_DEVID_XHCI0         0x101D
+#define XLP_DEVID_XHCI1         0x101E
+#define XLP_DEVID_XHCI2         0x101F
 
 struct smp_boot_info_percpu {
   volatile unsigned long ready;
@@ -78,6 +86,7 @@ struct smp_boot_info {
 extern struct smp_boot_info smp_boot;
 extern void prom_boot_cpus_secondary(void *);
 extern cpumask_t phys_cpu_present_map;
+extern int is_nlm_xlp2xx_compat;
 
 extern char cpu_model_info[MAX_CPU_REV_LEN];
 extern char* get_cpu_info(void);
diff --git a/arch/mips/include/asm/netlogic/xlp8xx/cpu.h b/arch/mips/include/asm/netlogic/xlp8xx/cpu.h
index ab1a881..56cae16 100644
--- a/arch/mips/include/asm/netlogic/xlp8xx/cpu.h
+++ b/arch/mips/include/asm/netlogic/xlp8xx/cpu.h
@@ -1,30 +1,33 @@
-/*
- * Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
- * reserved. Redistribution and use in source and binary forms, with 
- * or without modification, are permitted provided that the following 
- * conditions are met:
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
  *
- *	1. 	Redistributions of source code must retain the above copyright
- *		notice, this list of conditions and the following disclaimer.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
  *
- *	2. 	Redistributions in binary form must reproduce the above copyright
- *		notice, this list of conditions and the following disclaimer in
- *		the documentation and/or other materials provided with the
- *		distribution.
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
  *
- * THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- * --------------------------------#NETL_2#--------------------------------
- */
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+ 
 /* XLP CPU specific */
 
 #ifndef __XLP_CPU_H_
diff --git a/arch/mips/include/asm/netlogic/xlp8xx/xlp_sys.h b/arch/mips/include/asm/netlogic/xlp8xx/xlp_sys.h
index a6453de..5d50142 100644
--- a/arch/mips/include/asm/netlogic/xlp8xx/xlp_sys.h
+++ b/arch/mips/include/asm/netlogic/xlp8xx/xlp_sys.h
@@ -1,30 +1,33 @@
-/*
- * Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
- * reserved. Redistribution and use in source and binary forms, with 
- * or without modification, are permitted provided that the following 
- * conditions are met:
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
  *
- *	1. 	Redistributions of source code must retain the above copyright
- *		notice, this list of conditions and the following disclaimer.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
  *
- *	2. 	Redistributions in binary form must reproduce the above copyright
- *		notice, this list of conditions and the following disclaimer in
- *		the documentation and/or other materials provided with the
- *		distribution.
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
  *
- * THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- * --------------------------------#NETL_2#--------------------------------
- */
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+ 
 #ifndef __XLP_SYS_H__
 #define __XLP_SYS_H__
 
diff --git a/arch/mips/include/asm/netlogic/xlp_irq.h b/arch/mips/include/asm/netlogic/xlp_irq.h
index 2064147..4dcae8a 100644
--- a/arch/mips/include/asm/netlogic/xlp_irq.h
+++ b/arch/mips/include/asm/netlogic/xlp_irq.h
@@ -1,27 +1,32 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
 
 #ifndef _ASM_NLM_XLP_IRQ_H
 #define _ASM_NLM_XLP_IRQ_H
@@ -43,7 +48,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define XLP_IRQ_MSGRING_RVEC              5
 
 #define XLP_IRQ_IPI_SMP_KGDB_RVEC	     50
-#define XLP_IRQ_OPROFILE    	  6
+#define XLP_IRQ_OPROFILE    	  6 
 #define PIC_IRQ_IS_EDGE_TRIGGERED(x)	0
 
 #ifdef CONFIG_NLMCOMMON_IP_FLOW_AFFINITY
@@ -66,6 +71,9 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define SMP_CALL_KGDB_HOOK_RVEC	8
 #define SMP_OPROFILE_IPI_RVEC        16
 
+#define ASM_XLP_IO_PIC_OFFSET        0xffffffffb8004100 /* TODO: This will change in to function */
+#define C_XLP_IO_PIC_OFFSET        0xffffffffb8004100ULL /* TODO: This will change in to function */
+#define XLP_IO_PIC_OFFSET        C_XLP_IO_PIC_OFFSET
 #if defined __ASSEMBLY__
 #define ASM_XLP_IO_PIC_OFFSET        0xffffffffb8004100 /* TODO: This will change in to function */
 #define C_XLP_IO_PIC_OFFSET        0xffffffffb8004100ULL /* TODO: This will change in to function */
@@ -73,6 +81,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 
 #else
 #include <asm/netlogic/pic.h>
+#include <asm/netlogic/xlp.h>
 /*
  *     Register Offsets
  */
@@ -105,7 +114,6 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define XLP_IRQ_RESERVED_MAX		8
 
 #define XLP_ITE_ENTRIES		8
-#define NLM_MAX_CPU_NODE	4
 #define XLP_8XX_MAX_CPUS	(NLM_MAX_CPU_NODE * NLM_MAX_CPU_PER_NODE)
 
 #define XLP_IRTENT_ENABLE	(1ULL << 31)
@@ -128,6 +136,8 @@ struct xlp_nodefn_struct {
 	u8 fn;
 };
 
+extern int nlm_hal_is_ref_clk_133MHz(void);
+#define XLP_PIT_TICK_RATE	(nlm_hal_is_ref_clk_133MHz()?  133333333 : 66666666)
 #define XLP_PIT_TIMER_MAX	(u64)(~0ULL)
 
 extern u64 __nlh_pic_r64o(u8, u64);
@@ -155,7 +165,11 @@ int xlp_rvec_from_irq(int irq);
 
 /* We define NR_IRQs to be 254, but IRT entries are 160 in size
  * Effectively, we cannot use anything more than 159 */
+#define NLM_MAX_CPU_NODE	4
 #define XLP_IRQS_PER_NODE	384
+#ifdef NR_IRQS
+#undef NR_IRQS
+#endif
 #define NR_IRQS			(XLP_IRQS_PER_NODE * NLM_MAX_CPU_NODE)
 /* Maximum IRQ vector numbers supported by MIPS */
 #define XLP_EIRR_SIZE		64
@@ -268,8 +282,6 @@ int xlp_rvec_from_irq(int irq);
 
 /* The following are the values supported per slot. A slot can have a device or
  * a bridge, but only this much MSI/MSI-X can be alloted on that slot
- * This is a kludge to keep NR_IRQS == 256 and can be expanded later
- * We are using IRQ 192 - 255 for MSI/MSI-X
  * */
 
 #define XLP_INTX_TO_CTRL_FN(irq)\
diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h
index 1c38ccb..12de01a 100644
--- a/arch/mips/include/asm/page.h
+++ b/arch/mips/include/asm/page.h
@@ -1,3 +1,12 @@
+/*-
+ * Copyright 2003-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
+
 /*
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
@@ -5,7 +14,6 @@
  *
  * Copyright (C) 1994 - 1999, 2000, 03 Ralf Baechle
  * Copyright (C) 1999, 2000 Silicon Graphics, Inc.
- * Copyright (C) 2003-2010 Netlogic Microsystems Inc.
  */
 #ifndef _ASM_PAGE_H
 #define _ASM_PAGE_H
diff --git a/arch/mips/include/asm/perfctr.h b/arch/mips/include/asm/perfctr.h
new file mode 100644
index 0000000..c2bfac7
--- /dev/null
+++ b/arch/mips/include/asm/perfctr.h
@@ -0,0 +1,238 @@
+/*-
+ * Copyright 2005-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
+
+/* $Id: perfctr.h,v 1.1.2.5 2006-09-28 01:24:19 nphilips Exp $
+ * MIPS_XLR Performance-Monitoring Counters driver
+ *
+ * Copyright (C) 2005  Prasad Boddupalli
+ */
+#ifndef _ASM_MIPS_PERFCTR_H
+#define _ASM_MIPS_PERFCTR_H
+
+#define PERFCTR_PAGE_SIZE 4096
+
+/* perfctr_info.cpu_type values */
+#define MIPS_GENERIC	0
+#define MIPS_XLR        1
+
+// Architecture-specific container for counter values.
+// Used in the kernel/user API, but not by low-level drivers.
+struct perfctr_sum_ctrs {
+	unsigned long long tsc;
+	unsigned long long pmc[2];	// just two perf registers
+};
+
+// architecture-specific container for control data.
+// used in both kernel/user API and by low-level drivers
+struct perfctr_cpu_control {
+	unsigned int tsc_on;		// initialize on perfctr_cpu_init()?
+	unsigned int nractrs;		/* # of a-mode counters (max(0,2)?) */
+	unsigned int nrictrs;		/* # of i-mode counters */
+
+    // We already have the control registers in the eventsel field
+	// of the struct {} pmc[]. We might not need the following
+	// registers 
+
+	/* struct {
+		unsigned int perfctrl0;
+		unsigned int perfctrl1;
+	} mips; */
+
+	unsigned int _reserved1;
+	unsigned int _reserved2;
+	unsigned int _reserved3;
+	unsigned int _reserved4;
+
+	struct {
+		unsigned int map;	/* physical counter to use */
+		unsigned int ctrl_reg;
+		int ireset;		/* [0,0x7fffffff], for i-mode counters */
+	} pmc[2];
+};
+
+struct perfctr_cpu_state {
+	unsigned int cstatus;
+
+	// k1 is opaque in the user ABI
+	struct {
+		unsigned int id;
+		int isuspend_cpu;
+	} k1;
+
+	// tsc fields must be inlined. Placing them in a sub-struct might 
+	// cause unwanted internal padding
+	unsigned int tsc_start;
+	unsigned long long tsc_sum;
+
+	struct {
+		unsigned int map;
+		unsigned int start;
+		unsigned long long sum;
+	} pmc[2];
+
+#ifdef __KERNEL__
+	struct perfctr_cpu_control control;
+#endif
+};
+
+/* cstatus is a re-encoding of control.tsc_on/nractrs/nrictrs
+   which should have less overhead in most cases */
+/* XXX: mips driver internally also uses cstatus&(1<<30) */
+
+// construct a cstatus value. 
+static inline
+unsigned int perfctr_mk_cstatus(unsigned int tsc_on, unsigned int nractrs,
+				unsigned int nrictrs)
+{
+	return ((tsc_on<<31) | (nrictrs<<16) | ((nractrs+nrictrs)<<8) | nractrs);
+}
+
+// check if any part (tsc_on, nractrs, nrictrs) of the cstatus is non-zero
+static inline unsigned int perfctr_cstatus_enabled(unsigned int cstatus)
+{
+	return cstatus;
+}
+
+// check if the tsc_on part of the cstatus is non-zero
+static inline int perfctr_cstatus_has_tsc(unsigned int cstatus)
+{
+	return ((int)cstatus < 0);	/* test and jump on sign */
+}
+
+// retrieve nractrs field
+static inline unsigned int perfctr_cstatus_nractrs(unsigned int cstatus)
+{
+	return (cstatus & 0x7F);		/* and with imm8 */
+}
+
+// retrieve nractrs+nrictrs from the cstatus
+static inline unsigned int perfctr_cstatus_nrctrs(unsigned int cstatus)
+{
+	return ((cstatus >> 8) & 0x7F);
+}
+
+// check if the nrictrs part of cstatus is non-zero
+static inline unsigned int perfctr_cstatus_has_ictrs(unsigned int cstatus)
+{
+	return (cstatus & (0x7F << 16));
+}
+
+/*
+ * 'struct siginfo' support for perfctr overflow signals.
+ * In unbuffered mode, si_code is set to SI_PMC_OVF and a bitmask
+ * describing which perfctrs overflowed is put in si_pmc_ovf_mask.
+ * A bitmask is used since more than one perfctr can have overflowed
+ * by the time the interrupt handler runs.
+ *
+ * glibc's <signal.h> doesn't seem to define __SI_FAULT or __SI_CODE(),
+ * and including <asm/siginfo.h> as well may cause redefinition errors,
+ * so the user and kernel values are different #defines here.
+ */
+#ifdef __KERNEL__
+#define SI_PMC_OVF	(__SI_FAULT|'P')
+#else
+#define SI_PMC_OVF	('P')
+#endif
+#define si_pmc_ovf_mask	_sifields._pad[0] /* XXX: use an unsigned field later */
+
+/* version number for user-visible CPU-specific data */
+#define PERFCTR_CPU_VERSION	0	/* XXX: not yet cast in stone */
+
+#ifdef __KERNEL__
+
+#ifdef CONFIG_PERFCTR
+
+/* Driver init/exit. */
+extern int perfctr_cpu_init(void);
+extern void perfctr_cpu_exit(void);
+
+/* CPU type name. */
+extern char *perfctr_cpu_name;
+
+/* Hardware reservation. */
+extern const char *perfctr_cpu_reserve(const char *service);
+extern void perfctr_cpu_release(const char *service);
+
+/* PRE: state has no running interrupt-mode counters.
+   Check that the new control data is valid.
+   Update the driver's private control data.
+   Returns a negative error code if the control data is invalid.
+*/
+extern int perfctr_cpu_update_control(struct perfctr_cpu_state *state, int is_global);
+
+
+/* Read a-mode counters. Subtract from start and accumulate into sums.
+   Must be called with preemption disabled. */
+extern void perfctr_cpu_suspend(struct perfctr_cpu_state *state);
+
+/* Write control registers. Read a-mode counters into start.
+   Must be called with preemption disabled. */
+extern void perfctr_cpu_resume(struct perfctr_cpu_state *state);
+
+/* Perform an efficient combined suspend/resume operation.
+   Must be called with preemption disabled. */
+extern void perfctr_cpu_sample(struct perfctr_cpu_state *state);
+
+/* The type of a perfctr overflow interrupt handler.
+   It will be called in IRQ context, with preemption disabled. */
+typedef void (*perfctr_ihandler_t)(unsigned long pc);
+
+unsigned int read_pmc (unsigned int);
+void write_pmc (unsigned int, unsigned int);
+void write_pmctrl (unsigned int, unsigned int);
+
+/* Operations related to overflow interrupt handling. */
+
+#ifdef CONFIG_PERFCTR_INTERRUPT_SUPPORT
+extern void perfctr_cpu_set_ihandler(perfctr_ihandler_t);
+extern void perfctr_cpu_ireload(struct perfctr_cpu_state*);
+extern unsigned int perfctr_cpu_identify_overflow(struct perfctr_cpu_state*);
+#else
+static inline void perfctr_cpu_set_ihandler(perfctr_ihandler_t x) { }
+#endif
+
+static inline int perfctr_cpu_has_pending_interrupt(const struct perfctr_cpu_state *state)
+{
+	return 0;
+}
+
+extern perfctr_ihandler_t perfctr_ihandler;
+
+#endif	/* CONFIG_PERFCTR */
+
+#endif	/* __KERNEL__ */
+
+#define MIPS_XLR_DOM_KERNEL		0x2
+#define MIPS_XLR_DOM_SUP		0x4
+#define MIPS_XLR_DOM_USR		0x8
+
+#define MIPS_XLR_SET_EVNTCNT_MODE(x, mode)		x |= mode
+#define MIPS_XLR_UNSET_EVNTCNT_MODE(x, mode)	x &= ~mode
+
+#define MIPS_XLR_OVF_BIT                0x10
+#define MIPS_XLR_OVF_PMI_EABLE(x)		x |= MIPS_XLR_OVF_BIT
+#define MIPS_XLR_OVF_PMI_DABLE(x)		x &= ~MIPS_XLR_OVF_BIT
+#define MIPS_XLR_IS_OVF_PMI(x)			(x & MIPS_XLR_OVF_BIT)
+
+#define MIPS_XLR_EVNTSEL_MASK			0x3f
+#define MIPS_XLR_EVNTSEL_SHIFT			5
+#define MIPS_XLR_SET_EVNT(x, event)		\
+		x |= ((event & MIPS_XLR_EVNTSEL_MASK) << MIPS_XLR_EVNTSEL_SHIFT)
+#define MIPS_XLR_GET_EVNT(x)	\
+		((x >> MIPS_XLR_EVNTSEL_SHIFT) & MIPS_XLR_EVNTSEL_MASK)
+
+#define MIPS_XLR_THREADID_MASK				0x03
+#define MIPS_XLR_THREADID_SHIFT				11
+#define MIPS_XLR_SET_THREADID(x, tid)		\
+		x |= ((tid & MIPS_XLR_THREADID_MASK) << MIPS_XLR_THREADID_SHIFT)
+
+#define MIPS_XLR_SET_CNT_ALL_THREADS(x)		x |= 0x2000
+#define MIPS_XLR_UNSET_CNT_ALL_THREADS(x)	x &= ~0x2000
+
+#endif	/* _ASM_MIPS_PERFCTR_H */
diff --git a/arch/mips/include/asm/pgtable-64.h b/arch/mips/include/asm/pgtable-64.h
index 60d35c6..45fcf17 100644
--- a/arch/mips/include/asm/pgtable-64.h
+++ b/arch/mips/include/asm/pgtable-64.h
@@ -1,3 +1,11 @@
+/*-
+ * Copyright 2003-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
 /*
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
@@ -114,11 +122,6 @@ extern unsigned long __vmalloc_start;
 #define VMALLOC_START		MAP_BASE
 #endif
 
-#define VMALLOC_END	\
-	(VMALLOC_START + \
-	 min(PTRS_PER_PGD * PTRS_PER_PMD * PTRS_PER_PTE * PAGE_SIZE, \
-	     (1UL << cpu_vmbits)) - (1UL << 32))
-
 #ifndef CONFIG_MAPPED_KERNEL
 
 #if defined(CONFIG_MODULES) && defined(KBUILD_64BIT_SYM32) && \
@@ -127,10 +130,27 @@ extern unsigned long __vmalloc_start;
 #define MODULE_START	CKSSEG
 #define MODULE_END	(FIXADDR_START-2*PAGE_SIZE)
 #endif
-#else
+
+#define VMALLOC_END	\
+	(VMALLOC_START + \
+	 min(PTRS_PER_PGD * PTRS_PER_PMD * PTRS_PER_PTE * PAGE_SIZE, \
+	     (1UL << cpu_vmbits)) - (1UL << 32))
+
+#else /* CONFIG_MAPPED_KERNEL */
+
 #define MODULE_START    0xffffffffe0000000
 #define MODULE_END      (FIXADDR_START-2*PAGE_SIZE)
 
+	/* Since module and vmalloc shares the same page table, make sure their
+	 * pgd index does not overlap.
+	 */
+#define VMALLOC_END	\
+	(VMALLOC_START + \
+	 min( min(PTRS_PER_PGD * PTRS_PER_PMD * PTRS_PER_PTE * PAGE_SIZE, \
+	         (1UL << cpu_vmbits)), \
+	      (((MODULE_START >> PGDIR_SHIFT) & (PTRS_PER_PGD - 1)) - 1) << PGDIR_SHIFT) \
+	 - (1UL << 32))
+
 #endif /* CONFIG_MAPPED_KERNEL */
 
 #define pte_ERROR(e) \
diff --git a/arch/mips/include/asm/pgtable-bits.h b/arch/mips/include/asm/pgtable-bits.h
index fe881b0..97b9e8c 100644
--- a/arch/mips/include/asm/pgtable-bits.h
+++ b/arch/mips/include/asm/pgtable-bits.h
@@ -103,6 +103,20 @@
 #define _PAGE_HUGE		({BUG(); 1; })  /* Dummy value */
 #endif
 
+#ifdef CONFIG_NLM_XLP
+/*XLP has bit 57,56 in entrylo0/1 as RI:XI. We will use pte bits 63:62 to store 
+ *ri:xi, after right shift by 6, these bits will come to proper position.
+*/
+/* Page cannot be executed */
+#define _PAGE_NO_EXEC_SHIFT    (kernel_uses_smartmips_rixi ? 62: _PAGE_HUGE_SHIFT)
+#define _PAGE_NO_EXEC      ({if (!kernel_uses_smartmips_rixi) BUG(); 1ULL << _PAGE_NO_EXEC_SHIFT; })
+/* Page cannot be read */
+#define _PAGE_NO_READ_SHIFT    (kernel_uses_smartmips_rixi ? 63: _PAGE_NO_EXEC_SHIFT)
+#define _PAGE_NO_READ      ({if (!kernel_uses_smartmips_rixi) BUG(); 1ULL << _PAGE_NO_READ_SHIFT; })
+
+#define _PAGE_GLOBAL_SHIFT 6
+
+#else
 /* Page cannot be executed */
 #define _PAGE_NO_EXEC_SHIFT	(kernel_uses_smartmips_rixi ? _PAGE_HUGE_SHIFT + 1 : _PAGE_HUGE_SHIFT)
 #define _PAGE_NO_EXEC		({if (!kernel_uses_smartmips_rixi) BUG(); 1 << _PAGE_NO_EXEC_SHIFT; })
@@ -112,6 +126,8 @@
 #define _PAGE_NO_READ		({if (!kernel_uses_smartmips_rixi) BUG(); 1 << _PAGE_NO_READ_SHIFT; })
 
 #define _PAGE_GLOBAL_SHIFT	(_PAGE_NO_READ_SHIFT + 1)
+#endif
+
 #define _PAGE_GLOBAL		(1 << _PAGE_GLOBAL_SHIFT)
 
 #define _PAGE_VALID_SHIFT	(_PAGE_GLOBAL_SHIFT + 1)
@@ -156,6 +172,9 @@
 static inline uint64_t pte_to_entrylo(unsigned long pte_val)
 {
 	if (kernel_uses_smartmips_rixi) {
+#ifdef CONFIG_NLM_XLP
+       return (pte_val >> _PAGE_GLOBAL_SHIFT);
+#else
 		int sa;
 #ifdef CONFIG_32BIT
 		sa = 31 - _PAGE_NO_READ_SHIFT;
@@ -169,6 +188,7 @@ static inline uint64_t pte_to_entrylo(unsigned long pte_val)
 		 */
 		return (pte_val >> _PAGE_GLOBAL_SHIFT) |
 			((pte_val & (_PAGE_NO_EXEC | _PAGE_NO_READ)) << sa);
+#endif
 	}
 
 	return pte_val >> _PAGE_GLOBAL_SHIFT;
@@ -194,9 +214,9 @@ static inline uint64_t pte_to_entrylo(unsigned long pte_val)
 
 #elif defined(CONFIG_CPU_XLP)
 
-#define _CACHE_UNCACHED             (2<<_CACHE_SHIFT)
-#define _CACHE_CACHABLE_COW         (3<<_CACHE_SHIFT)
-#define _CACHE_CACHABLE_NONCOHERENT (3<<_CACHE_SHIFT)
+#define _CACHE_UNCACHED             (2<<9)
+#define _CACHE_CACHABLE_COW         (3<<9)
+#define _CACHE_CACHABLE_NONCOHERENT (3<<9)
 
 #elif defined(CONFIG_CPU_RM9000)
 
diff --git a/arch/mips/include/asm/processor.h b/arch/mips/include/asm/processor.h
index ab38791..fe6fa48 100644
--- a/arch/mips/include/asm/processor.h
+++ b/arch/mips/include/asm/processor.h
@@ -1,3 +1,12 @@
+/*-
+ * Copyright 2003-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
+
 /*
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
@@ -33,19 +42,16 @@ extern void (*cpu_wait)(void);
 
 extern unsigned int vced_count, vcei_count;
 
-/*
- * A special page (the vdso) is mapped into all processes at the very
- * top of the virtual memory space.
- */
-#define SPECIAL_PAGES_SIZE PAGE_SIZE
-
 #ifdef CONFIG_32BIT
 /*
  * User space process size: 2GB. This is hardcoded into a few places,
  * so don't change it unless you know what you are doing.
+ *
+ * XLP_MERGE_TODO: changed TASK_SIZE from 0x7fff8000UL to 0x7fff8000UL
+ * to fix page alignment of initial stack (vm_start) for 64KB pages
  */
-#define TASK_SIZE	0x7fff8000UL
-#define STACK_TOP	((TASK_SIZE & PAGE_MASK) - SPECIAL_PAGES_SIZE)
+#define TASK_SIZE	0x7fff0000UL
+#define STACK_TOP	TASK_SIZE
 
 /*
  * This decides where the kernel will search for a free chunk of vm
@@ -61,12 +67,14 @@ extern unsigned int vced_count, vcei_count;
  * is limited to 1TB by the R4000 architecture; R10000 and better can
  * support 16TB; the architectural reserve for future expansion is
  * 8192EB ...
+ *
+ * XLP_MERGE_TODO: changed TASK_SIZE32 from 0x7fff8000UL to 0x7fff8000UL
+ * to fix page alignment of initial stack (vm_start) for 64KB pages
  */
-#define TASK_SIZE32	0x7fff8000UL
+#define TASK_SIZE32	0x7fff0000UL
 #define TASK_SIZE	0x10000000000UL
 #define STACK_TOP	\
-	(((test_thread_flag(TIF_32BIT_ADDR) ?				\
-	   TASK_SIZE32 : TASK_SIZE) & PAGE_MASK) - SPECIAL_PAGES_SIZE)
+      (test_thread_flag(TIF_32BIT_ADDR) ? TASK_SIZE32 : TASK_SIZE)
 
 /*
  * This decides where the kernel will search for a free chunk of vm
@@ -221,6 +229,9 @@ struct thread_struct {
 	unsigned long trap_no;
 	unsigned long irix_trampoline;  /* Wheee... */
 	unsigned long irix_oldctx;
+#ifdef CONFIG_PERFCTR_VIRTUAL
+	struct vperfctr *perfctr;
+#endif
 #ifdef CONFIG_CPU_CAVIUM_OCTEON
     struct octeon_cop2_state cp2 __attribute__ ((__aligned__(128)));
     struct octeon_cvmseg_state cvmseg __attribute__ ((__aligned__(128)));
diff --git a/arch/mips/include/asm/spinlock.h b/arch/mips/include/asm/spinlock.h
index 910383b..3ffa436 100644
--- a/arch/mips/include/asm/spinlock.h
+++ b/arch/mips/include/asm/spinlock.h
@@ -38,7 +38,7 @@ static inline int arch_spin_is_locked(arch_spinlock_t *lock)
 {
 	u32 counters = ACCESS_ONCE(lock->lock);
 
-	return ((counters >> 16) ^ counters) & 0xffff;
+	return ((counters >> 14) ^ counters) & 0x1fff;
 }
 
 #define arch_spin_lock_flags(lock, flags) arch_spin_lock(lock)
@@ -49,7 +49,7 @@ static inline int arch_spin_is_contended(arch_spinlock_t *lock)
 {
 	u32 counters = ACCESS_ONCE(lock->lock);
 
-	return (((counters >> 16) - counters) & 0xffff) > 1;
+	return (((counters >> 14) - counters) & 0x1fff) > 1;
 }
 #define arch_spin_is_contended	arch_spin_is_contended
 
@@ -57,7 +57,6 @@ static inline void arch_spin_lock(arch_spinlock_t *lock)
 {
 	int my_ticket;
 	int tmp;
-	int inc = 0x10000;
 
 	if (R10000_LLSC_WAR) {
 		__asm__ __volatile__ (
@@ -65,27 +64,25 @@ static inline void arch_spin_lock(arch_spinlock_t *lock)
 		"	.set noreorder					\n"
 		"							\n"
 		"1:	ll	%[ticket], %[ticket_ptr]		\n"
-		"	addu	%[my_ticket], %[ticket], %[inc]		\n"
+		"	addiu	%[my_ticket], %[ticket], 0x4000		\n"
 		"	sc	%[my_ticket], %[ticket_ptr]		\n"
-#ifdef CONFIG_NLM_XLP
-		"       ehb                                             \n"
-#endif
 		"	beqzl	%[my_ticket], 1b			\n"
 		"	 nop						\n"
-		"	srl	%[my_ticket], %[ticket], 16		\n"
-		"	andi	%[ticket], %[ticket], 0xffff		\n"
-		"	andi	%[my_ticket], %[my_ticket], 0xffff	\n"
+		"	srl	%[my_ticket], %[ticket], 14		\n"
+		"	andi	%[my_ticket], %[my_ticket], 0x1fff	\n"
+		"	andi	%[ticket], %[ticket], 0x1fff		\n"
 		"	bne	%[ticket], %[my_ticket], 4f		\n"
 		"	 subu	%[ticket], %[my_ticket], %[ticket]	\n"
 		"2:							\n"
 		"	.subsection 2					\n"
-		"4:	andi	%[ticket], %[ticket], 0xffff		\n"
+		"4:	andi	%[ticket], %[ticket], 0x1fff		\n"
 		"	sll	%[ticket], 5				\n"
 		"							\n"
 		"6:	bnez	%[ticket], 6b				\n"
 		"	 subu	%[ticket], 1				\n"
 		"							\n"
-		"	lhu	%[ticket], %[serving_now_ptr]		\n"
+		"	lw	%[ticket], %[ticket_ptr]		\n"
+		"	andi	%[ticket], %[ticket], 0x1fff		\n"
 		"	beq	%[ticket], %[my_ticket], 2b		\n"
 		"	 subu	%[ticket], %[my_ticket], %[ticket]	\n"
 		"	b	4b					\n"
@@ -93,36 +90,39 @@ static inline void arch_spin_lock(arch_spinlock_t *lock)
 		"	.previous					\n"
 		"	.set pop					\n"
 		: [ticket_ptr] "+m" (lock->lock),
-		  [serving_now_ptr] "+m" (lock->h.serving_now),
 		  [ticket] "=&r" (tmp),
-		  [my_ticket] "=&r" (my_ticket)
-		: [inc] "r" (inc));
+		  [my_ticket] "=&r" (my_ticket));
 	} else {
 		__asm__ __volatile__ (
 		"	.set push		# arch_spin_lock	\n"
 		"	.set noreorder					\n"
 		"							\n"
-		"1:	ll	%[ticket], %[ticket_ptr]		\n"
-		"	addu	%[my_ticket], %[ticket], %[inc]		\n"
+		"	ll	%[ticket], %[ticket_ptr]		\n"
+		"1:	addiu	%[my_ticket], %[ticket], 0x4000		\n"
 		"	sc	%[my_ticket], %[ticket_ptr]		\n"
 #ifdef CONFIG_NLM_XLP
 		"       ehb                                             \n"
 #endif
-		"	beqz	%[my_ticket], 1b			\n"
-		"	 srl	%[my_ticket], %[ticket], 16		\n"
-		"	andi	%[ticket], %[ticket], 0xffff		\n"
-		"	andi	%[my_ticket], %[my_ticket], 0xffff	\n"
+		"	beqz	%[my_ticket], 3f			\n"
+		"	 nop						\n"
+		"	srl	%[my_ticket], %[ticket], 14		\n"
+		"	andi	%[my_ticket], %[my_ticket], 0x1fff	\n"
+		"	andi	%[ticket], %[ticket], 0x1fff		\n"
 		"	bne	%[ticket], %[my_ticket], 4f		\n"
 		"	 subu	%[ticket], %[my_ticket], %[ticket]	\n"
 		"2:							\n"
 		"	.subsection 2					\n"
+		"3:	b	1b					\n"
+		"	 ll	%[ticket], %[ticket_ptr]		\n"
+		"							\n"
 		"4:	andi	%[ticket], %[ticket], 0x1fff		\n"
 		"	sll	%[ticket], 5				\n"
 		"							\n"
 		"6:	bnez	%[ticket], 6b				\n"
 		"	 subu	%[ticket], 1				\n"
 		"							\n"
-		"	lhu	%[ticket], %[serving_now_ptr]		\n"
+		"	lw	%[ticket], %[ticket_ptr]		\n"
+		"	andi	%[ticket], %[ticket], 0x1fff		\n"
 		"	beq	%[ticket], %[my_ticket], 2b		\n"
 		"	 subu	%[ticket], %[my_ticket], %[ticket]	\n"
 		"	b	4b					\n"
@@ -130,10 +130,8 @@ static inline void arch_spin_lock(arch_spinlock_t *lock)
 		"	.previous					\n"
 		"	.set pop					\n"
 		: [ticket_ptr] "+m" (lock->lock),
-		  [serving_now_ptr] "+m" (lock->h.serving_now),
 		  [ticket] "=&r" (tmp),
-		  [my_ticket] "=&r" (my_ticket)
-		: [inc] "r" (inc));
+		  [my_ticket] "=&r" (my_ticket));
 	}
 
 	smp_llsc_mb();
@@ -141,16 +139,50 @@ static inline void arch_spin_lock(arch_spinlock_t *lock)
 
 static inline void arch_spin_unlock(arch_spinlock_t *lock)
 {
-	unsigned int serving_now = lock->h.serving_now + 1;
-	wmb();
-	lock->h.serving_now = (u16)serving_now;
-	nudge_writes();
+	int tmp;
+
+	smp_llsc_mb();
+
+	if (R10000_LLSC_WAR) {
+		__asm__ __volatile__ (
+		"				# __raw_spin_unlock	\n"
+		"1:	ll	%[ticket], %[ticket_ptr]		\n"
+		"	addiu	%[ticket], %[ticket], 1			\n"
+		"	ori	%[ticket], %[ticket], 0x2000		\n"
+		"	xori	%[ticket], %[ticket], 0x2000		\n"
+		"	sc	%[ticket], %[ticket_ptr]		\n"
+		"	beqzl	%[ticket], 1b				\n"
+		: [ticket_ptr] "+m" (lock->lock),
+		  [ticket] "=&r" (tmp));
+	} else {
+		__asm__ __volatile__ (
+		"	.set push		# __raw_spin_unlock	\n"
+		"	.set noreorder					\n"
+		"							\n"
+		"	ll	%[ticket], %[ticket_ptr]		\n"
+		"1:	addiu	%[ticket], %[ticket], 1			\n"
+		"	ori	%[ticket], %[ticket], 0x2000		\n"
+		"	xori	%[ticket], %[ticket], 0x2000		\n"
+		"	sc	%[ticket], %[ticket_ptr]		\n"
+#ifdef CONFIG_NLM_XLP
+		"       ehb                                             \n"
+#endif
+		"	beqz	%[ticket], 2f				\n"
+		"	 nop						\n"
+		"							\n"
+		"	.subsection 2					\n"
+		"2:	b	1b					\n"
+		"	 ll	%[ticket], %[ticket_ptr]		\n"
+		"	.previous					\n"
+		"	.set pop					\n"
+		: [ticket_ptr] "+m" (lock->lock),
+		  [ticket] "=&r" (tmp));
+	}
 }
 
 static inline unsigned int arch_spin_trylock(arch_spinlock_t *lock)
 {
 	int tmp, tmp2, tmp3;
-	int inc = 0x10000;
 
 	if (R10000_LLSC_WAR) {
 		__asm__ __volatile__ (
@@ -158,11 +190,11 @@ static inline unsigned int arch_spin_trylock(arch_spinlock_t *lock)
 		"	.set noreorder					\n"
 		"							\n"
 		"1:	ll	%[ticket], %[ticket_ptr]		\n"
-		"	srl	%[my_ticket], %[ticket], 16		\n"
-		"	andi	%[my_ticket], %[my_ticket], 0xffff	\n"
-		"	andi	%[now_serving], %[ticket], 0xffff	\n"
+		"	srl	%[my_ticket], %[ticket], 14		\n"
+		"	andi	%[my_ticket], %[my_ticket], 0x1fff	\n"
+		"	andi	%[now_serving], %[ticket], 0x1fff	\n"
 		"	bne	%[my_ticket], %[now_serving], 3f	\n"
-		"	 addu	%[ticket], %[ticket], %[inc]		\n"
+		"	 addiu	%[ticket], %[ticket], 0x4000		\n"
 		"	sc	%[ticket], %[ticket_ptr]		\n"
 #ifdef CONFIG_NLM_XLP
 		"       ehb                                             \n"
@@ -178,19 +210,18 @@ static inline unsigned int arch_spin_trylock(arch_spinlock_t *lock)
 		: [ticket_ptr] "+m" (lock->lock),
 		  [ticket] "=&r" (tmp),
 		  [my_ticket] "=&r" (tmp2),
-		  [now_serving] "=&r" (tmp3)
-		: [inc] "r" (inc));
+		  [now_serving] "=&r" (tmp3));
 	} else {
 		__asm__ __volatile__ (
 		"	.set push		# arch_spin_trylock	\n"
 		"	.set noreorder					\n"
 		"							\n"
-		"1:	ll	%[ticket], %[ticket_ptr]		\n"
-		"	srl	%[my_ticket], %[ticket], 16		\n"
-		"	andi	%[my_ticket], %[my_ticket], 0xffff	\n"
-		"	andi	%[now_serving], %[ticket], 0xffff	\n"
+		"	ll	%[ticket], %[ticket_ptr]		\n"
+		"1:	srl	%[my_ticket], %[ticket], 14		\n"
+		"	andi	%[my_ticket], %[my_ticket], 0x1fff	\n"
+		"	andi	%[now_serving], %[ticket], 0x1fff	\n"
 		"	bne	%[my_ticket], %[now_serving], 3f	\n"
-		"	 addu	%[ticket], %[ticket], %[inc]		\n"
+		"	 addiu	%[ticket], %[ticket], 0x4000		\n"
 		"	sc	%[ticket], %[ticket_ptr]		\n"
 #ifdef CONFIG_NLM_XLP
 		"       ehb                                             \n"
@@ -201,13 +232,14 @@ static inline unsigned int arch_spin_trylock(arch_spinlock_t *lock)
 		"	.subsection 2					\n"
 		"3:	b	2b					\n"
 		"	 li	%[ticket], 0				\n"
+		"4:	b	1b					\n"
+		"	 ll	%[ticket], %[ticket_ptr]		\n"
 		"	.previous					\n"
 		"	.set pop					\n"
 		: [ticket_ptr] "+m" (lock->lock),
 		  [ticket] "=&r" (tmp),
 		  [my_ticket] "=&r" (tmp2),
-		  [now_serving] "=&r" (tmp3)
-		: [inc] "r" (inc));
+		  [now_serving] "=&r" (tmp3));
 	}
 
 	smp_llsc_mb();
diff --git a/arch/mips/include/asm/stackframe.h b/arch/mips/include/asm/stackframe.h
index 12c9736..dc5292f 100644
--- a/arch/mips/include/asm/stackframe.h
+++ b/arch/mips/include/asm/stackframe.h
@@ -51,6 +51,9 @@
 		LONG_S	v1, PT_ACX(sp)
 #else
 		mfhi	v1
+		LONG_S	v1, PT_HI(sp)
+		mflo	v1
+		LONG_S	v1, PT_LO(sp)
 #endif
 #ifdef CONFIG_32BIT
 		LONG_S	$8, PT_R8(sp)
@@ -59,17 +62,10 @@
 		LONG_S	$10, PT_R10(sp)
 		LONG_S	$11, PT_R11(sp)
 		LONG_S	$12, PT_R12(sp)
-#ifndef CONFIG_CPU_HAS_SMARTMIPS
-		LONG_S	v1, PT_HI(sp)
-		mflo	v1
-#endif
 		LONG_S	$13, PT_R13(sp)
 		LONG_S	$14, PT_R14(sp)
 		LONG_S	$15, PT_R15(sp)
 		LONG_S	$24, PT_R24(sp)
-#ifndef CONFIG_CPU_HAS_SMARTMIPS
-		LONG_S	v1, PT_LO(sp)
-#endif
 		.endm
 
 		.macro	SAVE_STATIC
@@ -99,7 +95,11 @@
 #define CPU_ID_MFC0 MFC0
 #endif
 		.macro	get_saved_sp	/* SMP variation */
-		CPU_ID_MFC0	k0, CPU_ID_REG
+#ifdef CONFIG_MIPS_MT_SMTC
+		mfc0	k0, CP0_TCBIND
+#else
+		MFC0	k0, CP0_CONTEXT
+#endif
 #if defined(CONFIG_32BIT) || defined(KBUILD_64BIT_SYM32)
 		lui	k1, %hi(kernelsp)
 #else
@@ -115,31 +115,16 @@
 		.endm
 
 		.macro	set_saved_sp stackp temp temp2
-		CPU_ID_MFC0	\temp, CPU_ID_REG
+#ifdef CONFIG_MIPS_MT_SMTC
+		mfc0	\temp, CP0_TCBIND
+#else
+		MFC0	\temp, CP0_CONTEXT
+#endif
 		LONG_SRL	\temp, PTEBASE_SHIFT
 		LONG_S	\stackp, kernelsp(\temp)
 		.endm
 #else
 		.macro	get_saved_sp	/* Uniprocessor variation */
-#ifdef CONFIG_CPU_JUMP_WORKAROUNDS
-		/*
-		 * Clear BTB (branch target buffer), forbid RAS (return address
-		 * stack) to workaround the Out-of-order Issue in Loongson2F
-		 * via its diagnostic register.
-		 */
-		move	k0, ra
-		jal	1f
-		 nop
-1:		jal	1f
-		 nop
-1:		jal	1f
-		 nop
-1:		jal	1f
-		 nop
-1:		move	ra, k0
-		li	k0, 3
-		mtc0	k0, $22
-#endif /* CONFIG_CPU_LOONGSON2F */
 #if defined(CONFIG_32BIT) || defined(KBUILD_64BIT_SYM32)
 		lui	k1, %hi(kernelsp)
 #else
@@ -189,6 +174,7 @@
 		LONG_S	$0, PT_R0(sp)
 		mfc0	v1, CP0_STATUS
 		LONG_S	$2, PT_R2(sp)
+		LONG_S	v1, PT_STATUS(sp)
 #ifdef CONFIG_MIPS_MT_SMTC
 		/*
 		 * Ideally, these instructions would be shuffled in
@@ -200,23 +186,32 @@
 		LONG_S	v1, PT_TCSTATUS(sp)
 #endif /* CONFIG_MIPS_MT_SMTC */
 		LONG_S	$4, PT_R4(sp)
-		LONG_S	$5, PT_R5(sp)
-		LONG_S	v1, PT_STATUS(sp)
 		mfc0	v1, CP0_CAUSE
-		LONG_S	$6, PT_R6(sp)
-		LONG_S	$7, PT_R7(sp)
+		LONG_S	$5, PT_R5(sp)
 		LONG_S	v1, PT_CAUSE(sp)
+		LONG_S	$6, PT_R6(sp)
 		MFC0	v1, CP0_EPC
+		LONG_S	$7, PT_R7(sp)
 #ifdef CONFIG_64BIT
 		LONG_S	$8, PT_R8(sp)
 		LONG_S	$9, PT_R9(sp)
 #endif
+		LONG_S	v1, PT_EPC(sp)
 		LONG_S	$25, PT_R25(sp)
 		LONG_S	$28, PT_R28(sp)
 		LONG_S	$31, PT_R31(sp)
-		LONG_S	v1, PT_EPC(sp)
 		ori	$28, sp, _THREAD_MASK
 		xori	$28, _THREAD_MASK
+
+#ifdef CONFIG_NLM_ENABLE_COP2
+		.set    mips64
+		dla k0, nlm_cop2_save
+		jalr k0
+		nop
+		LONG_L  ra, PT_R31(sp)
+		LONG_L	k0, PT_R29(sp)
+#endif
+
 #ifdef CONFIG_CPU_CAVIUM_OCTEON
 		.set    mips64
 		pref    0, 0($28)       /* Prefetch the current pointer */
@@ -368,7 +363,14 @@
 		ori	a0, STATMASK
 		xori	a0, STATMASK
 		mtc0	a0, CP0_STATUS
-		li	v1, (0xff00 | ST0_CU2_IM)
+
+#ifdef CONFIG_NLM_ENABLE_COP2
+		dla v1, nlm_cop2_restore
+		jalr v1
+		nop
+#endif
+
+		li	v1, 0x4000ff00
 		and	a0, v1
 		LONG_L	v0, PT_STATUS(sp)
 		nor	v1, $0, v1
diff --git a/arch/mips/include/asm/system.h b/arch/mips/include/asm/system.h
index 4347909..fa94c93 100644
--- a/arch/mips/include/asm/system.h
+++ b/arch/mips/include/asm/system.h
@@ -80,7 +80,9 @@ do {									\
 	if (cpu_has_dsp)						\
 		__save_dsp(prev);					\
 	__clear_software_ll_bit();					\
+	perfctr_suspend_thread(&(prev)->thread);                        \
 	(last) = resume(prev, next, task_thread_info(next));		\
+	perfctr_suspend_thread(&(prev)->thread);                        \
 } while (0)
 
 #define finish_arch_switch(prev)					\
@@ -96,8 +98,6 @@ static inline unsigned long __xchg_u32(volatile int * m, unsigned int val)
 {
 	__u32 retval;
 
-	smp_mb__before_llsc();
-
 	if (kernel_uses_llsc && R10000_LLSC_WAR) {
 		unsigned long dummy;
 
@@ -150,7 +150,6 @@ static inline __u64 __xchg_u64(volatile __u64 * m, __u64 val)
 {
 	__u64 retval;
 
-	smp_mb__before_llsc();
 
 	if (kernel_uses_llsc && R10000_LLSC_WAR) {
 		unsigned long dummy;
diff --git a/arch/mips/include/asm/time.h b/arch/mips/include/asm/time.h
index c7f1bfe..b9fea34 100644
--- a/arch/mips/include/asm/time.h
+++ b/arch/mips/include/asm/time.h
@@ -55,6 +55,10 @@ extern unsigned int __weak get_c0_compare_int(void);
 extern int r4k_clockevent_init(void);
 #endif
 
+#if defined CONFIG_XLP_REPLACE_R4K_TIMER
+extern int xlp_pic_ced_timer_init(int);
+extern void xlp_pic_cs_timer_init(int);
+#endif
 static inline int mips_clockevent_init(void)
 {
 #ifdef CONFIG_MIPS_MT_SMTC
@@ -63,6 +67,8 @@ static inline int mips_clockevent_init(void)
 	return smtc_clockevent_init();
 #elif defined(CONFIG_CEVT_R4K)
 	return r4k_clockevent_init();
+#elif defined CONFIG_XLP_REPLACE_R4K_TIMER
+	return xlp_pic_ced_timer_init(1);
 #else
 	return -ENXIO;
 #endif
@@ -79,21 +85,14 @@ static inline int init_mips_clocksource(void)
 {
 #ifdef CONFIG_CSRC_R4K
 	return init_r4k_clocksource();
-#else
-	return 0;
+#elif defined CONFIG_XLP_REPLACE_R4K_TIMER
+	xlp_pic_cs_timer_init(0);
 #endif
+	return 0;
 }
 
-static inline void clocksource_set_clock(struct clocksource *cs,
-					 unsigned int clock)
-{
-	clocksource_calc_mult_shift(cs, clock, 4);
-}
-
-static inline void clockevent_set_clock(struct clock_event_device *cd,
-					unsigned int clock)
-{
-	clockevents_calc_mult_shift(cd, clock, 4);
-}
+extern void clocksource_set_clock(struct clocksource *cs, unsigned int clock);
+extern void clockevent_set_clock(struct clock_event_device *cd,
+		unsigned int clock);
 
 #endif /* _ASM_TIME_H */
diff --git a/arch/mips/include/asm/timex.h b/arch/mips/include/asm/timex.h
index 10c8dd8..6e25a23 100644
--- a/arch/mips/include/asm/timex.h
+++ b/arch/mips/include/asm/timex.h
@@ -20,8 +20,6 @@
  */
 #define CLOCK_TICK_RATE 1193182
 
-extern unsigned int mips_hpt_frequency;
-
 /*
  * Standard way to access the cycle counter.
  * Currently only used on SMP for scheduling.
@@ -42,7 +40,11 @@ extern unsigned int mips_hpt_frequency;
  * will result in the timer interrupt getting lost.
  */
 
+#if defined CONFIG_NLM_XLP
+typedef unsigned long cycles_t;
+#else
 typedef unsigned int cycles_t;
+#endif
 
 #ifdef CONFIG_HAVE_GET_CYCLES_32
 static inline cycles_t get_cycles(void)
@@ -106,6 +108,11 @@ static inline int unsynchronized_tsc(void)
 	return !tsc_is_sync();
 }
 
+#ifdef CONFIG_NLM_COMMON
+#define ARCH_HAS_READ_CURRENT_TIMER	1
+extern int read_current_timer(unsigned long *timer_val);
+#endif /* CONFIG_NLM_COMMON */
+
 #endif /* __KERNEL__ */
 
 #endif /*  _ASM_TIMEX_H */
diff --git a/arch/mips/kernel/Makefile b/arch/mips/kernel/Makefile
index fc593f8..768c608 100644
--- a/arch/mips/kernel/Makefile
+++ b/arch/mips/kernel/Makefile
@@ -1,6 +1,7 @@
 #
 # Makefile for the Linux/MIPS kernel.
 #
+EXTRA_AFLAGS := $(AFLAGS) -DNLM_HAL_LINUX_KERNEL 
 
 extra-y		:= head.o init_task.o vmlinux.lds
 
diff --git a/arch/mips/kernel/asm-offsets.c b/arch/mips/kernel/asm-offsets.c
index d1d3236..3f6dc4a 100644
--- a/arch/mips/kernel/asm-offsets.c
+++ b/arch/mips/kernel/asm-offsets.c
@@ -1,3 +1,11 @@
+/*-
+ * Copyright 2003-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
 /*
  * offset.c: Calculate pt_regs and task_struct offsets.
  *
@@ -78,6 +86,14 @@ void output_ptreg_defines(void)
 	OFFSET(NLM_COP2_MSG_CONFIG, pt_regs, msg_config);
 	OFFSET(NLM_COP2_MSG_ERR, pt_regs, msg_err);
 #endif
+
+#ifdef XLP_MERGE_TODO /*CONFIG_NLM_XLP_SIM*/
+	OFFSET("#define PT_CRC_POLY_0 ", pt_regs, crc_poly_0);
+	OFFSET("#define PT_CRC_POLY_1 ", pt_regs, crc_poly_1);
+	OFFSET("#define PT_CRC_POLY_2 ", pt_regs, crc_poly_2);
+	OFFSET("#define PT_CRC_POLY_3 ", pt_regs, crc_poly_3);
+#endif /* CONFIG_NLM_XLP_SIM */
+
 	DEFINE(PT_SIZE, sizeof(struct pt_regs));
 	BLANK();
 }
@@ -197,15 +213,11 @@ void output_mm_defines(void)
 	DEFINE(_PTE_T_SIZE, sizeof(pte_t));
 	BLANK();
 	DEFINE(_PGD_T_LOG2, PGD_T_LOG2);
-#ifndef __PAGETABLE_PMD_FOLDED
 	DEFINE(_PMD_T_LOG2, PMD_T_LOG2);
-#endif
 	DEFINE(_PTE_T_LOG2, PTE_T_LOG2);
 	BLANK();
 	DEFINE(_PGD_ORDER, PGD_ORDER);
-#ifndef __PAGETABLE_PMD_FOLDED
 	DEFINE(_PMD_ORDER, PMD_ORDER);
-#endif
 	DEFINE(_PTE_ORDER, PTE_ORDER);
 	BLANK();
 	DEFINE(_PMD_SHIFT, PMD_SHIFT);
@@ -215,6 +227,9 @@ void output_mm_defines(void)
 	DEFINE(_PTRS_PER_PMD, PTRS_PER_PMD);
 	DEFINE(_PTRS_PER_PTE, PTRS_PER_PTE);
 	BLANK();
+	DEFINE(PAGE_SIZE_asm, PAGE_SIZE);
+	DEFINE(PAGE_SHIFT_asm, PAGE_SHIFT);
+	BLANK();
 }
 
 #ifdef CONFIG_32BIT
@@ -338,6 +353,16 @@ void output_octeon_cop2_state_defines(void)
 }
 #endif
 
+#ifdef CONFIG_NLM_COMMON
+#include <asm/netlogic/sim.h>
+void output_psb_info_defines(void)
+{
+        COMMENT("RMI struct psb_info structure offsets");
+        OFFSET(PSB_CPU_FREQUENCY, psb_info, cpu_frequency);
+	BLANK();
+}
+#endif /* CONFIG_NLM_COMMON */
+
 #ifdef CONFIG_HIBERNATION
 void output_pbe_defines(void)
 {
diff --git a/arch/mips/kernel/binfmt_elfo32.c b/arch/mips/kernel/binfmt_elfo32.c
index cf0b48a..9695ae0 100644
--- a/arch/mips/kernel/binfmt_elfo32.c
+++ b/arch/mips/kernel/binfmt_elfo32.c
@@ -1,3 +1,11 @@
+/*-
+ * Copyright 2003-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
 /*
  * Support for o32 Linux/MIPS ELF binaries.
  *
@@ -48,7 +56,11 @@ typedef elf_fpreg_t elf_fpregset_t[ELF_NFPREG];
 	__res;								\
 })
 
-#define TASK32_SIZE		0x7fff8000UL
+/*
+ * XLP_MERGE_TODO: changed TASK_SIZE from 0x7fff8000UL to 0x7fff8000UL
+ * to fix page alignment of initial stack (vm_start) for 64KB pages
+ */
+#define TASK32_SIZE		0x7fff0000UL
 #undef ELF_ET_DYN_BASE
 #define ELF_ET_DYN_BASE         (TASK32_SIZE / 3 * 2)
 
@@ -77,6 +89,11 @@ extern void elf32_core_copy_regs(elf_gregset_t grp, struct pt_regs *regs);
 	__res;								\
 })
 
+#include <asm/elf.h>
+#undef ELF_CORE_COPY_REGS
+void elf32_core_copy_regs(elf_gregset_t grp, struct pt_regs *regs);
+#define ELF_CORE_COPY_REGS(_dest,_regs) elf32_core_copy_regs(_dest,_regs);
+
 #include <linux/module.h>
 #include <linux/elfcore.h>
 #include <linux/compat.h>
@@ -134,23 +151,30 @@ jiffies_to_compat_timeval(unsigned long jiffies, struct compat_timeval *value)
 	value->tv_usec = rem / NSEC_PER_USEC;
 }
 
+int elf32_dump_task_regs (struct task_struct *tsk, elf_gregset_t *regs)
+{
+	elf32_core_copy_regs(*regs, task_pt_regs(tsk));
+	return 1;
+}
+
+#define COMPAT_REG_BASE 6
 void elf32_core_copy_regs(elf_gregset_t grp, struct pt_regs *regs)
 {
 	int i;
 
-	for (i = 0; i < EF_R0; i++)
+	for (i = 0; i < COMPAT_REG_BASE; i++)
 		grp[i] = 0;
-	grp[EF_R0] = 0;
+	grp[COMPAT_REG_BASE] = 0;
 	for (i = 1; i <= 31; i++)
-		grp[EF_R0 + i] = (elf_greg_t) regs->regs[i];
-	grp[EF_R26] = 0;
-	grp[EF_R27] = 0;
-	grp[EF_LO] = (elf_greg_t) regs->lo;
-	grp[EF_HI] = (elf_greg_t) regs->hi;
-	grp[EF_CP0_EPC] = (elf_greg_t) regs->cp0_epc;
-	grp[EF_CP0_BADVADDR] = (elf_greg_t) regs->cp0_badvaddr;
-	grp[EF_CP0_STATUS] = (elf_greg_t) regs->cp0_status;
-	grp[EF_CP0_CAUSE] = (elf_greg_t) regs->cp0_cause;
+		grp[COMPAT_REG_BASE + i] = (elf_greg_t) regs->regs[i];
+	grp[EF_R26 + COMPAT_REG_BASE] = 0;
+	grp[EF_R27 + COMPAT_REG_BASE] = 0;
+	grp[EF_LO + COMPAT_REG_BASE] = (elf_greg_t) regs->lo;
+	grp[EF_HI + COMPAT_REG_BASE] = (elf_greg_t) regs->hi;
+	grp[EF_CP0_EPC + COMPAT_REG_BASE] = (elf_greg_t) regs->cp0_epc;
+	grp[EF_CP0_BADVADDR + COMPAT_REG_BASE] = (elf_greg_t) regs->cp0_badvaddr;
+	grp[EF_CP0_STATUS + COMPAT_REG_BASE] = (elf_greg_t) regs->cp0_status;
+	grp[EF_CP0_CAUSE + COMPAT_REG_BASE] = (elf_greg_t) regs->cp0_cause;
 #ifdef EF_UNUSED0
 	grp[EF_UNUSED0] = 0;
 #endif
diff --git a/arch/mips/kernel/cevt-r4k.c b/arch/mips/kernel/cevt-r4k.c
index 2a4d50f..5128b21 100644
--- a/arch/mips/kernel/cevt-r4k.c
+++ b/arch/mips/kernel/cevt-r4k.c
@@ -1,3 +1,11 @@
+/*-
+ * Copyright 2007-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
 /*
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
@@ -90,6 +98,7 @@ struct irqaction c0_compare_irqaction = {
 
 void mips_event_handler(struct clock_event_device *dev)
 {
+	printk("[%s]: nothing to do\n", __FUNCTION__);
 }
 
 /*
@@ -97,7 +106,7 @@ void mips_event_handler(struct clock_event_device *dev)
  */
 static int c0_compare_int_pending(void)
 {
-	return (read_c0_cause() >> cp0_compare_irq_shift) & (1ul << CAUSEB_IP);
+	return (read_c0_cause() >> cp0_compare_irq) & 0x100;
 }
 
 /*
@@ -163,6 +172,7 @@ int c0_compare_int_usable(void)
 
 int __cpuinit r4k_clockevent_init(void)
 {
+	uint64_t mips_freq = mips_hpt_frequency;
 	unsigned int cpu = smp_processor_id();
 	struct clock_event_device *cd;
 	unsigned int irq;
@@ -170,9 +180,11 @@ int __cpuinit r4k_clockevent_init(void)
 	if (!cpu_has_counter || !mips_hpt_frequency)
 		return -ENXIO;
 
+	/* XLP_MERGE_TODO */
+#if !defined(CONFIG_NLM_XLP_SIM)
 	if (!c0_compare_int_usable())
 		return -ENXIO;
-
+#endif
 	/*
 	 * With vectored interrupts things are getting platform specific.
 	 * get_c0_compare_int is a hook to allow a platform to return the
@@ -187,9 +199,15 @@ int __cpuinit r4k_clockevent_init(void)
 	cd->name		= "MIPS";
 	cd->features		= CLOCK_EVT_FEAT_ONESHOT;
 
-	clockevent_set_clock(cd, mips_hpt_frequency);
-
 	/* Calculate the min / max delta */
+#ifdef CONFIG_NLM_COMMON
+	/* for 1GHz (and lesser), div_sc returns zero if shift = 32 */
+	cd->mult	= div_sc((unsigned long) mips_freq, NSEC_PER_SEC, 30);
+	cd->shift		= 30;
+#else
+	cd->mult	= div_sc((unsigned long) mips_freq, NSEC_PER_SEC, 32);
+	cd->shift		= 32;
+#endif
 	cd->max_delta_ns	= clockevent_delta2ns(0x7fffffff, cd);
 	cd->min_delta_ns	= clockevent_delta2ns(0x300, cd);
 
diff --git a/arch/mips/kernel/cpu-probe.c b/arch/mips/kernel/cpu-probe.c
index 3be15cf..9975159 100644
--- a/arch/mips/kernel/cpu-probe.c
+++ b/arch/mips/kernel/cpu-probe.c
@@ -1,3 +1,11 @@
+/*-
+ * Copyright 2006-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
 /*
  * Processor capabilities determination functions.
  *
@@ -25,7 +33,10 @@
 #include <asm/system.h>
 #include <asm/watch.h>
 #include <asm/spram.h>
-#ifdef CONFIG_NLM_XLP
+#if defined(CONFIG_NLM_XLR)
+#include <asm/netlogic/sim.h>
+#endif
+#if defined(CONFIG_NLM_XLP)
 #include <asm/netlogic/xlp.h>
 #endif
 
@@ -67,15 +78,13 @@ void r4k_wait_irqoff(void)
 {
 	local_irq_disable();
 	if (!need_resched())
-		__asm__(" 	.globl __startwait	\n"
-			"__startwait:			\n"
-			"	.set	push		\n"
+		__asm__("	.set	push		\n"
 			"	.set	mips3		\n"
 			"	wait			\n"
-			"	.set	pop		\n"
-			" 	.globl __pastwait	\n"
-			"__pastwait:			\n");
+			"	.set	pop		\n");
 	local_irq_enable();
+	__asm__(" 	.globl __pastwait	\n"
+		"__pastwait:			\n");
 	return;
 }
 
@@ -943,7 +952,7 @@ platform:
 const char *__cpu_name[NR_CPUS];
 const char *__elf_platform;
 
-static inline void cpu_probe_netlogic(struct cpuinfo_mips *c, int cpu)
+static __inline__ void cpu_probe_netlogic(struct cpuinfo_mips *c, int cpu)
 {
 	decode_configs(c);
 
@@ -956,17 +965,7 @@ static inline void cpu_probe_netlogic(struct cpuinfo_mips *c, int cpu)
 		      MIPS_CPU_NLM_CACHE |
 		      MIPS_CPU_LLSC);
 
-	switch ((c->processor_id & 0xff00) >> 8) {
-	case CHIP_PROCESSOR_ID_XLP_8XX:
-	case CHIP_PROCESSOR_ID_XLP_832:
-	case CHIP_PROCESSOR_ID_XLP_816:
-	case CHIP_PROCESSOR_ID_XLP_432:
-	case CHIP_PROCESSOR_ID_XLP_416:
-	case CHIP_PROCESSOR_ID_XLP_408:
-	case CHIP_PROCESSOR_ID_XLP_3XX:
-	case CHIP_PROCESSOR_ID_XLP_208:
-	case CHIP_PROCESSOR_ID_XLP_204:
-	case CHIP_PROCESSOR_ID_XLP_104:
+#if defined(CONFIG_NLM_XLP)
 	{
 		/* XLP */
 
@@ -975,18 +974,27 @@ static inline void cpu_probe_netlogic(struct cpuinfo_mips *c, int cpu)
 		c->isa_level = MIPS_CPU_ISA_M64R2;
 		c->options |= (MIPS_CPU_FPU | MIPS_CPU_ULRI | MIPS_CPU_MCHECK);
 
-		c->tlbsize = ((read_c0_config6() >> 16) & 0xffff) + 1;
+		c->tlbsize = ((read_c0_config6() >> 16 ) & 0xffff) + 1;
 		__cpu_name[cpu] = (const char *)get_cpu_info();
 
 		printk("Enabling XLP CPU (%s): pr id 0x%x  smp id %d\n",
 		       cpu_name_string(), c->processor_id, cpu);
 	}
-	break;
-	default:
-		panic("Don't support this CPU\n");
-	break;
+#else
+	{
+	
+		/* XLR/XLS */
 
+		c->cputype = CPU_XLR;
+		c->isa_level = MIPS_CPU_ISA_M64R1;
+		c->tlbsize = ((read_c0_config1() >> 25) & 0x3f) + 1;
+
+		__cpu_name[cpu] = (const char *)get_cpu_info();
+
+		printk("Enabling XLR/XLS CPU (%s)\n", cpu_name_string());
 	}
+#endif
+
 }
 
 __cpuinit void cpu_probe(void)
diff --git a/arch/mips/kernel/entry.S b/arch/mips/kernel/entry.S
index 8c5410f..ffa3310 100644
--- a/arch/mips/kernel/entry.S
+++ b/arch/mips/kernel/entry.S
@@ -167,7 +167,7 @@ work_notifysig:				# deal with pending signals and
 FEXPORT(syscall_exit_work_partial)
 	SAVE_STATIC
 syscall_exit_work:
-	li	t0, _TIF_SYSCALL_TRACE | _TIF_SYSCALL_AUDIT | _TIF_KERNEL_TRACE
+	li	t0, _TIF_SYSCALL_TRACE | _TIF_SYSCALL_AUDIT
 	and	t0, a2			# a2 is preloaded with TI_FLAGS
 	beqz	t0, work_pending	# trace bit set?
 	local_irq_enable		# could let do_syscall_trace()
diff --git a/arch/mips/kernel/genex.S b/arch/mips/kernel/genex.S
index 8882e57..5f2d7f3 100644
--- a/arch/mips/kernel/genex.S
+++ b/arch/mips/kernel/genex.S
@@ -1,3 +1,11 @@
+/*-
+ * Copyright 2007-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
 /*
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
@@ -403,6 +411,12 @@ NESTED(nmi_handler, PT_SIZE, sp)
 	KMODE
 	.endm
 
+	.macro	__build_clear_rixi
+	MFC0	t0, CP0_BADVADDR
+	PTR_S	t0, PT_BVADDR(sp)
+	STI
+	.endm
+		
 	.macro	__BUILD_silent exception
 	.endm
 
@@ -446,16 +460,30 @@ NESTED(nmi_handler, PT_SIZE, sp)
 	__BUILD_HANDLER	\exception \handler \clear \verbose _int
 	.endm
 
+#if defined(CONFIG_NLM_XLP) && !defined(CONFIG_HUGETLB_PAGE)
+	.macro	BUILD_HANDLER_mcheck exception handler clear verbose
+	.align	5
+	NESTED(handle_\exception, PT_SIZE, sp)
+	eret
+	END(handle_\exception)
+	.endm
+#endif
+
 	BUILD_HANDLER adel ade ade silent		/* #4  */
 	BUILD_HANDLER ades ade ade silent		/* #5  */
 	BUILD_HANDLER ibe be cli silent			/* #6  */
 	BUILD_HANDLER dbe be cli silent			/* #7  */
+#if defined(CONFIG_NLM_COMMON) && defined (CONFIG_KGDB)
+	BUILD_HANDLER bp bp cli silent			/* #9  */
+#else
 	BUILD_HANDLER bp bp sti silent			/* #9  */
+#endif
 	BUILD_HANDLER ri ri sti silent			/* #10 */
 	BUILD_HANDLER cpu cpu sti silent		/* #11 */
 	BUILD_HANDLER ov ov sti silent			/* #12 */
 	BUILD_HANDLER tr tr sti silent			/* #13 */
 	BUILD_HANDLER fpe fpe fpe silent		/* #15 */
+	BUILD_HANDLER rixi rixi rixi silent		/* #16 */
 	BUILD_HANDLER mdmx mdmx sti silent		/* #22 */
 #ifdef 	CONFIG_HARDWARE_WATCHPOINTS
 	/*
@@ -466,7 +494,13 @@ NESTED(nmi_handler, PT_SIZE, sp)
 #else
 	BUILD_HANDLER watch watch sti verbose		/* #23 */
 #endif
+
+#if defined(CONFIG_NLM_XLP) && !defined(CONFIG_HUGETLB_PAGE)
+	BUILD_HANDLER_mcheck mcheck mcheck cli silent	/* #24 */
+#else
 	BUILD_HANDLER mcheck mcheck cli verbose		/* #24 */
+#endif
+
 	BUILD_HANDLER mt mt sti silent			/* #25 */
 	BUILD_HANDLER dsp dsp sti silent		/* #26 */
 	BUILD_HANDLER reserved reserved sti verbose	/* others */
diff --git a/arch/mips/kernel/head.S b/arch/mips/kernel/head.S
index b22a058..61c6d36 100644
--- a/arch/mips/kernel/head.S
+++ b/arch/mips/kernel/head.S
@@ -1,3 +1,11 @@
+/*-
+ * Copyright 2006-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
 /*
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
@@ -26,50 +34,8 @@
 #include <asm/mipsregs.h>
 #include <asm/stackframe.h>
 
-#include <asm/mach-generic/kernel-entry-init.h>
-#if defined(CONFIG_NLM_XLP) && defined(CONFIG_MAPPED_KERNEL)
 #include <asm/mach-netlogic/kernel-entry-init.h>
-#else
-
-	/*
-	 * inputs are the text nasid in t1, data nasid in t2.
-	 */
-	.macro MAPPED_KERNEL_SETUP_TLB
-#ifdef CONFIG_MAPPED_KERNEL
-	/*
-	 * This needs to read the nasid - assume 0 for now.
-	 * Drop in 0xffffffffc0000000 in tlbhi, 0+VG in tlblo_0,
-	 * 0+DVG in tlblo_1.
-	 */
-	dli	t0, 0xffffffffc0000000
-	dmtc0	t0, CP0_ENTRYHI
-	li	t0, 0x1c000		# Offset of text into node memory
-	dsll	t1, NASID_SHFT		# Shift text nasid into place
-	dsll	t2, NASID_SHFT		# Same for data nasid
-	or	t1, t1, t0		# Physical load address of kernel text
-	or	t2, t2, t0		# Physical load address of kernel data
-	dsrl	t1, 12			# 4K pfn
-	dsrl	t2, 12			# 4K pfn
-	dsll	t1, 6			# Get pfn into place
-	dsll	t2, 6			# Get pfn into place
-	li	t0, ((_PAGE_GLOBAL|_PAGE_VALID| _CACHE_CACHABLE_COW) >> 6)
-	or	t0, t0, t1
-	mtc0	t0, CP0_ENTRYLO0	# physaddr, VG, cach exlwr
-	li	t0, ((_PAGE_GLOBAL|_PAGE_VALID| _PAGE_DIRTY|_CACHE_CACHABLE_COW) >> 6)
-	or	t0, t0, t2
-	mtc0	t0, CP0_ENTRYLO1	# physaddr, DVG, cach exlwr
-	li	t0, 0x1ffe000		# MAPPED_KERN_TLBMASK, TLBPGMASK_16M
-	mtc0	t0, CP0_PAGEMASK
-	li	t0, 0			# KMAP_INX
-	mtc0	t0, CP0_INDEX
-	li	t0, 1
-	mtc0	t0, CP0_WIRED
-	tlbwi
-#else
-	mtc0	zero, CP0_WIRED
-#endif
-	.endm
-#endif
+#include <asm/mach-generic/kernel-entry-init.h>
 
 	/*
 	 * For the moment disable interrupts, mark the kernel mode and
@@ -149,9 +115,8 @@ FEXPORT(__kernel_entry)
 
 NESTED(kernel_entry, 16, sp)			# kernel entry point
 
-#if defined(CONFIG_NLM_XLP) && defined(CONFIG_MAPPED_KERNEL)
 	MAPPED_KERNEL_SETUP_TLB
-#endif
+
 	kernel_entry_setup			# cpu specific setup
 
 	setup_c0_status_pri
diff --git a/arch/mips/kernel/kgdb.c b/arch/mips/kernel/kgdb.c
index ce26994..a908acb 100644
--- a/arch/mips/kernel/kgdb.c
+++ b/arch/mips/kernel/kgdb.c
@@ -226,11 +226,46 @@ static void kgdb_call_nmi_hook(void *ignored)
 	kgdb_nmicallback(raw_smp_processor_id(), NULL);
 }
 
+#ifdef CONFIG_NLM_COMMON
+#include <asm/netlogic/interrupt.h>
+spinlock_t nlm_kgdb_lock = SPIN_LOCK_UNLOCKED;
+
+void nlm_kgdb_smp_hook(void)
+{
+	int i;
+	int cpu = smp_processor_id();
+	int cpus = num_online_cpus() - 1;
+	unsigned long flags;
+	extern struct plat_smp_ops *mp_ops;
+
+	BUG_ON(!cpu_online(cpu));
+
+	if (!cpus)
+		return;
+
+	spin_lock_irqsave(&nlm_kgdb_lock, flags);
+	for (i = 0; i < NR_CPUS; i++)
+		if (cpu_online(i) && i != cpu)
+			mp_ops->send_ipi_single(i, SMP_CALL_KGDB_HOOK_RVEC);
+	spin_unlock_irqrestore(&nlm_kgdb_lock, flags);
+}
+
+void nlm_kgdb_call_nmi_hook(void)
+{
+	kgdb_nmicallback(raw_smp_processor_id(), NULL);
+}
+#endif
+
 void kgdb_roundup_cpus(unsigned long flags)
 {
+#ifdef CONFIG_NLM_COMMON
+	nlm_kgdb_smp_hook();
+	return;
+#else
 	local_irq_enable();
 	smp_call_function(kgdb_call_nmi_hook, NULL, 0);
 	local_irq_disable();
+#endif
 }
 
 static int compute_signal(int tt)
@@ -282,6 +317,28 @@ void sleeping_thread_to_gdb_regs(unsigned long *gdb_regs, struct task_struct *p)
 	*(ptr++) = regs->cp0_epc;
 }
 
+#ifdef CONFIG_NLM_COMMON
+extern void nlm_common_flush_l1_icache_ipi(void *);
+extern void nlm_common_flush_l1_caches_ipi(void *);
+#endif
+
+#ifdef CONFIG_NLM_COMMON
+irqreturn_t xlr_kgdb_ipi_handler(int irq, struct pt_regs *regs)
+{
+	//int cpu = smp_processor_id();
+	kgdb_call_nmi_hook(NULL);
+
+	nlm_common_flush_l1_caches_ipi(NULL);
+#if 0
+	if(g_xlr_kgdb[cpu]) {
+		g_xlr_kgdb[cpu] = 0;
+		kgdb_call_nmi_hook(NULL);
+	}
+#endif
+
+	return IRQ_HANDLED;
+}
+#endif
 void kgdb_arch_set_pc(struct pt_regs *regs, unsigned long pc)
 {
 	regs->cp0_epc = pc;
diff --git a/arch/mips/kernel/r4k_switch.S b/arch/mips/kernel/r4k_switch.S
index f11dc1e..9fd4b91 100644
--- a/arch/mips/kernel/r4k_switch.S
+++ b/arch/mips/kernel/r4k_switch.S
@@ -97,7 +97,7 @@
 	move	ra,t1
 #endif /* CONFIG_MIPS_MT_SMTC */
 	mfc0	t1, CP0_STATUS		/* Do we really need this? */
-	li	a3, (0xff01 | ST0_CU2_IM)
+	li	a3, 0x4000ff01
 	and	t1, a3
 	LONG_L	a2, THREAD_STATUS(a1)
 	nor	a3, $0, a3
diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 82141c2..d77ca08 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -33,6 +33,7 @@
 #include <asm/system.h>
 
 #include <asm/mach-netlogic/mmu.h>
+#include <asm/netlogic/hal/nlm_hal_xlp_dev.h>
 
 struct cpuinfo_mips cpu_data[NR_CPUS] __read_mostly;
 
diff --git a/arch/mips/kernel/time.c b/arch/mips/kernel/time.c
index 51561a7..64b9bdb 100644
--- a/arch/mips/kernel/time.c
+++ b/arch/mips/kernel/time.c
@@ -1,3 +1,11 @@
+/*-
+ * Copyright 2004-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
 /*
  * Copyright 2001 MontaVista Software Inc.
  * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
@@ -70,7 +78,45 @@ EXPORT_SYMBOL(perf_irq);
  */
 
 unsigned int mips_hpt_frequency;
-EXPORT_SYMBOL(mips_hpt_frequency);
+
+void __init clocksource_set_clock(struct clocksource *cs, unsigned int clock)
+{
+	u64 temp;
+	u32 shift;
+ 	int shift_val;
+#ifdef CONFIG_NLM_COMMON
+ 	shift_val=30;
+ #else
+ 	shift_val=32;
+#endif
+
+	/* Find a shift value */
+	for (shift = shift_val; shift > 0; shift--) {
+		temp = (u64) NSEC_PER_SEC << shift;
+		do_div(temp, clock);
+		if ((temp >> 32) == 0)
+			break;
+	}
+	cs->shift = shift;
+	cs->mult = (u32) temp;
+}
+
+void __cpuinit clockevent_set_clock(struct clock_event_device *cd,
+	unsigned int clock)
+{
+	u64 temp;
+	u32 shift;
+
+	/* Find a shift value */
+	for (shift = 32; shift > 0; shift--) {
+		temp = (u64) clock << shift;
+		do_div(temp, NSEC_PER_SEC);
+		if ((temp >> 32) == 0)
+			break;
+	}
+	cd->shift = shift;
+	cd->mult = (u32) temp;
+}
 
 /*
  * This function exists in order to cause an error due to a duplicate
diff --git a/arch/mips/kernel/traps.c b/arch/mips/kernel/traps.c
index 6297163..72b667b 100644
--- a/arch/mips/kernel/traps.c
+++ b/arch/mips/kernel/traps.c
@@ -61,10 +61,10 @@
 DEFINE_TRACE(trap_entry);
 DEFINE_TRACE(trap_exit);
 
-#ifdef CONFIG_NLM_COMMON
-extern unsigned long nlm_common_ebase;
+#ifndef CONFIG_NLM_COMMON
+static void mmu_init(void) { }
 #else
-#define mmu_init()	do { } while (0)
+#include <asm/mach-netlogic/mmu.h>
 #endif
 
 extern void check_wait(void);
@@ -87,6 +87,7 @@ extern asmlinkage void handle_cpu(void);
 extern asmlinkage void handle_ov(void);
 extern asmlinkage void handle_tr(void);
 extern asmlinkage void handle_fpe(void);
+extern asmlinkage void handle_rixi(void);
 extern asmlinkage void handle_mdmx(void);
 extern asmlinkage void handle_watch(void);
 extern asmlinkage void handle_mt(void);
@@ -103,6 +104,9 @@ void (*board_nmi_handler_setup)(void);
 void (*board_ejtag_handler_setup)(void);
 void (*board_bind_eic_interrupt)(int irq, int regset);
 
+#ifdef CONFIG_NLM_COMMON
+extern unsigned long nlm_common_ebase;
+#endif
 
 static void show_raw_backtrace(unsigned long reg29)
 {
@@ -612,6 +616,9 @@ static int simulate_llsc(struct pt_regs *regs, unsigned int opcode)
 	return -1;			/* Must be something else ... */
 }
 
+extern void nlm_cpu_stat_update_rdhwr(void);
+extern void nlm_cpu_stat_update_fp(void);
+
 /*
  * Simulate trapping 'rdhwr' instructions to provide user accessible
  * registers not implemented in hardware.
@@ -648,6 +655,9 @@ static int simulate_rdhwr(struct pt_regs *regs, unsigned int opcode)
 			return 0;
 		case 29:
 			regs->regs[rt] = ti->tp_value;
+#if defined(CONFIG_NLM_COMMON)
+			nlm_cpu_stat_update_rdhwr();
+#endif
 			return 0;
 		default:
 			return -1;
@@ -714,6 +724,9 @@ asmlinkage void do_fpe(struct pt_regs *regs, unsigned long fcr31)
 		/* Run the emulator */
 		sig = fpu_emulator_cop1Handler(regs, &current->thread.fpu, 1);
 
+#if defined(CONFIG_NLM_COMMON)
+		nlm_cpu_stat_update_fp();
+#endif
 		/*
 		 * We can't allow the emulated instruction to leave any of
 		 * the cause bit set in $fcr31.
@@ -747,6 +760,37 @@ asmlinkage void do_fpe(struct pt_regs *regs, unsigned long fcr31)
 	trace_trap_exit();
 }
 
+asmlinkage void do_rixi(struct pt_regs *regs)
+{
+	struct task_struct *tsk = current;
+	siginfo_t info;
+
+	/*
+	 * TODO: need notify_die() intimation ?
+	 */
+	die_if_kernel("rixi exception in kernel code", regs);
+
+	/*
+	 * TODO: is there a possibility of permissions (RX)
+	 *       changing along with the receipt of a RIXI
+	 *       exception ? If so, we will have to check
+	 *       the vm_flags of the vma correponding to the
+	 *       faulting address
+	 */
+
+	tsk->thread.cp0_badvaddr = regs->cp0_badvaddr;
+	/*
+	 * TODO: need to set appropriate code
+	 * 
+	 * tsk->thread.error_code = ;
+	 */
+
+	info.si_signo = SIGSEGV;
+	info.si_errno = 0;
+	info.si_addr = (void __user *) regs->cp0_epc;
+	force_sig_info(SIGSEGV, &info, tsk);
+}
+
 static void do_trap_or_bp(struct pt_regs *regs, unsigned int code,
 	const char *str)
 {
@@ -1343,18 +1387,10 @@ void __init *set_except_vector(int n, void *addr)
 
 	exception_handlers[n] = handler;
 	if (n == 0 && cpu_has_divec) {
-		unsigned long jump_mask = ~((1 << 28) - 1);
-		u32 *buf = (u32 *)(ebase + 0x200);
-		unsigned int k0 = 26;
-		if ((handler & jump_mask) == ((ebase + 0x200) & jump_mask)) {
-			uasm_i_j(&buf, handler & ~jump_mask);
-			uasm_i_nop(&buf);
-		} else {
-			UASM_i_LA(&buf, k0, handler);
-			uasm_i_jr(&buf, k0);
-			uasm_i_nop(&buf);
-		}
-		local_flush_icache_range(ebase + 0x200, (unsigned long)buf);
+		*(u32 *)(ebase + 0x200) = 0x000000c0;  /* ehb */
+		*(u32 *)(ebase + 0x204) = 0x08000000 |
+					  (0x03ffffff & (handler >> 2)); /* j handler */
+		local_flush_icache_range(ebase + 0x200, ebase + 0x208);
 	}
 	return (void *)old_handler;
 }
@@ -1464,6 +1500,77 @@ void *set_vi_handler(int n, vi_handler_t addr)
 	return set_vi_srs_handler(n, addr, 0);
 }
 
+/*
+ * This is used by native signal handling
+ */
+asmlinkage int (*save_fp_context)(struct sigcontext __user *sc);
+asmlinkage int (*restore_fp_context)(struct sigcontext __user *sc);
+
+extern asmlinkage int _save_fp_context(struct sigcontext __user *sc);
+extern asmlinkage int _restore_fp_context(struct sigcontext __user *sc);
+
+extern asmlinkage int fpu_emulator_save_context(struct sigcontext __user *sc);
+extern asmlinkage int fpu_emulator_restore_context(struct sigcontext __user *sc);
+
+#ifdef CONFIG_SMP
+static int smp_save_fp_context(struct sigcontext __user *sc)
+{
+	return raw_cpu_has_fpu
+	       ? _save_fp_context(sc)
+	       : fpu_emulator_save_context(sc);
+}
+
+static int smp_restore_fp_context(struct sigcontext __user *sc)
+{
+	return raw_cpu_has_fpu
+	       ? _restore_fp_context(sc)
+	       : fpu_emulator_restore_context(sc);
+}
+#endif
+
+static inline void signal_init(void)
+{
+#ifdef CONFIG_SMP
+	/* For now just do the cpu_has_fpu check when the functions are invoked */
+	save_fp_context = smp_save_fp_context;
+	restore_fp_context = smp_restore_fp_context;
+#else
+	if (cpu_has_fpu) {
+		save_fp_context = _save_fp_context;
+		restore_fp_context = _restore_fp_context;
+	} else {
+		save_fp_context = fpu_emulator_save_context;
+		restore_fp_context = fpu_emulator_restore_context;
+	}
+#endif
+}
+
+#ifdef CONFIG_MIPS32_COMPAT
+
+/*
+ * This is used by 32-bit signal stuff on the 64-bit kernel
+ */
+asmlinkage int (*save_fp_context32)(struct sigcontext32 __user *sc);
+asmlinkage int (*restore_fp_context32)(struct sigcontext32 __user *sc);
+
+extern asmlinkage int _save_fp_context32(struct sigcontext32 __user *sc);
+extern asmlinkage int _restore_fp_context32(struct sigcontext32 __user *sc);
+
+extern asmlinkage int fpu_emulator_save_context32(struct sigcontext32 __user *sc);
+extern asmlinkage int fpu_emulator_restore_context32(struct sigcontext32 __user *sc);
+
+static inline void signal32_init(void)
+{
+	if (cpu_has_fpu) {
+		save_fp_context32 = _save_fp_context32;
+		restore_fp_context32 = _restore_fp_context32;
+	} else {
+		save_fp_context32 = fpu_emulator_save_context32;
+		restore_fp_context32 = fpu_emulator_restore_context32;
+	}
+}
+#endif
+
 extern void cpu_cache_init(void);
 extern void tlb_init(void);
 extern void flush_tlb_handlers(void);
@@ -1495,6 +1602,9 @@ void __cpuinit per_cpu_trap_init(void)
 {
 	unsigned int cpu = smp_processor_id();
 	unsigned int status_set = ST0_CU0;
+#if defined(CONFIG_NLM_XLP) && (defined(CONFIG_64BIT) || defined(CONFIG_RAPIDIO))
+        unsigned int pagegrain;
+#endif
 #ifdef CONFIG_MIPS_MT_SMTC
 	int secondaryTC = 0;
 	int bootTC = (cpu == 0);
@@ -1510,6 +1620,12 @@ void __cpuinit per_cpu_trap_init(void)
 		secondaryTC = 1;
 #endif /* CONFIG_MIPS_MT_SMTC */
 
+#ifdef CONFIG_32BIT
+	/* Some firmware leaves the BEV flag set, clear it. */
+	clear_c0_status(ST0_CU1|ST0_CU2|ST0_CU3|ST0_BEV|ST0_KX);
+#else
+	clear_c0_status(ST0_CU1|ST0_CU2|ST0_CU3|ST0_BEV);
+#endif
 	/*
 	 * Disable coprocessors and select 32-bit or 64-bit addressing
 	 * and the 16/32 or 32/32 FPR register model.  Reset the BEV
@@ -1517,19 +1633,26 @@ void __cpuinit per_cpu_trap_init(void)
 	 * IP27).  Set XX for ISA IV code to work.
 	 */
 #ifdef CONFIG_64BIT
-	status_set |= ST0_FR|ST0_KX|ST0_SX|ST0_UX;
+	status_set |= ST0_CU0|ST0_FR|ST0_KX|ST0_SX|ST0_UX;
 #endif
 	if (current_cpu_data.isa_level == MIPS_CPU_ISA_IV)
 		status_set |= ST0_XX;
 	if (cpu_has_dsp)
 		status_set |= ST0_MX;
 
-	/* Allow to enable cop2 access with CONFIG_NLM_ENABLE_COP2 */
-	status_set |= ST0_CU2_IM;
+#ifdef CONFIG_NLM_ENABLE_COP2
+    /*Enable Cop2 Access*/
+    status_set |= ST0_CU2;
+#endif
 
 	change_c0_status(ST0_CU|ST0_MX|ST0_RE|ST0_FR|ST0_BEV|ST0_TS|ST0_KX|ST0_SX|ST0_UX,
 			 status_set);
 
+#if defined(CONFIG_NLM_XLP) && (defined(CONFIG_64BIT) || defined(CONFIG_RAPIDIO))
+	pagegrain = read_c0_pagegrain();
+	pagegrain |= PG_ELPA;
+	write_c0_pagegrain(pagegrain);
+#endif
 	if (cpu_has_mips_r2) {
 		unsigned int enable = 0x0000000f | cpu_hwrena_impl_bits;
 
@@ -1558,6 +1681,9 @@ void __cpuinit per_cpu_trap_init(void)
 		} else
 			set_c0_cause(CAUSEF_IV);
 	}
+	else {
+		clear_c0_cause(CAUSEF_IV);
+	}
 
 	/*
 	 * Before R2 both interrupt numbers were fixed to 7, so on R2 only:
@@ -1566,14 +1692,12 @@ void __cpuinit per_cpu_trap_init(void)
 	 *  o read IntCtl.IPPCI to determine the performance counter interrupt
 	 */
 	if (cpu_has_mips_r2) {
-		cp0_compare_irq_shift = CAUSEB_TI - CAUSEB_IP;
-		cp0_compare_irq = (read_c0_intctl() >> INTCTLB_IPTI) & 7;
-		cp0_perfcount_irq = (read_c0_intctl() >> INTCTLB_IPPCI) & 7;
+		cp0_compare_irq = (read_c0_intctl() >> 29) & 7;
+		cp0_perfcount_irq = (read_c0_intctl() >> 26) & 7;
 		if (cp0_perfcount_irq == cp0_compare_irq)
 			cp0_perfcount_irq = -1;
 	} else {
 		cp0_compare_irq = CP0_LEGACY_COMPARE_IRQ;
-		cp0_compare_irq_shift = cp0_compare_irq;
 		cp0_perfcount_irq = -1;
 	}
 
@@ -1592,9 +1716,10 @@ void __cpuinit per_cpu_trap_init(void)
 #ifdef CONFIG_MIPS_MT_SMTC
 	if (bootTC) {
 #endif /* CONFIG_MIPS_MT_SMTC */
-		cpu_cache_init();
-		mmu_init();
-		tlb_init();
+
+	cpu_cache_init();
+	mmu_init();
+	tlb_init();
 #ifdef CONFIG_MIPS_MT_SMTC
 	} else if (!secondaryTC) {
 		/*
@@ -1625,7 +1750,12 @@ static char panic_null_cerr[] __cpuinitdata =
 void __cpuinit set_uncached_handler(unsigned long offset, void *addr,
 	unsigned long size)
 {
-	unsigned long uncached_ebase = CKSEG1ADDR(ebase);
+#ifdef CONFIG_32BIT
+	unsigned long uncached_ebase = KSEG1ADDR(ebase);
+#endif
+#ifdef CONFIG_64BIT
+	unsigned long uncached_ebase = TO_UNCAC(ebase);
+#endif
 
 	if (!addr)
 		panic(panic_null_cerr);
@@ -1665,7 +1795,7 @@ void __init trap_init(void)
 		ebase = (unsigned long)
 			__alloc_bootmem(size, 1 << fls(size), 0);
 	} else {
-		ebase = CKSEG0;
+		ebase = CAC_BASE;
 		if (cpu_has_mips_r2)
 			ebase += (read_c0_ebase() & 0x3ffff000);
 	}
@@ -1768,6 +1898,9 @@ void __init trap_init(void)
 	if (cpu_has_fpu && !cpu_has_nofpuex)
 		set_except_vector(15, handle_fpe);
 
+	if (kernel_uses_smartmips_rixi)
+		set_except_vector(16, handle_rixi);
+
 	set_except_vector(22, handle_mdmx);
 
 	if (cpu_has_mcheck)
diff --git a/arch/mips/kernel/unaligned.c b/arch/mips/kernel/unaligned.c
index be80d6d..f81a569 100644
--- a/arch/mips/kernel/unaligned.c
+++ b/arch/mips/kernel/unaligned.c
@@ -1,3 +1,11 @@
+/*-
+ * Copyright 2003-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
 /*
  * Handle unaligned accesses by emulation.
  *
@@ -100,8 +108,14 @@ enum {
 static u32 unaligned_instructions;
 static u32 unaligned_action;
 #else
+
+#ifdef CONFIG_NLM_COMMON
+#define unaligned_action UNALIGNED_ACTION_SHOW
+#else
 #define unaligned_action UNALIGNED_ACTION_QUIET
 #endif
+
+#endif
 extern void show_registers(struct pt_regs *regs);
 
 static void emulate_load_store_insn(struct pt_regs *regs,
diff --git a/arch/mips/lib/delay.c b/arch/mips/lib/delay.c
index 5995969..27ceba0 100644
--- a/arch/mips/lib/delay.c
+++ b/arch/mips/lib/delay.c
@@ -1,3 +1,11 @@
+/*-
+ * Copyright 2007-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
 /*
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
@@ -15,6 +23,94 @@
 #include <asm/compiler.h>
 #include <asm/war.h>
 
+#if defined CONFIG_NLM_XLP /* For XLP with PIC timer */
+#include <asm/netlogic/xlp_irq.h>
+#include <linux/clockchips.h>
+extern int read_current_timer(unsigned long *cyc);
+
+static inline void __pic_delay(u64 ns, u32 m)
+{
+	u64 delta;
+	unsigned long cc, ic;
+
+	delta = (((div_sc(XLP_PIT_TICK_RATE, NSEC_PER_SEC, 20) * ns * m) >> 20) + 1);
+	read_current_timer(&ic);
+	while(1){
+		read_current_timer(&cc);
+		if (((u64)(cc - ic)) > delta) {
+			return;
+		}
+	}
+}
+
+void __ndelay(unsigned int ns)
+{
+	return __pic_delay((u64)ns, 1);
+}
+
+void __udelay(unsigned int us)
+{
+	return __pic_delay((u64)us, 1000);
+}
+
+void __delay(unsigned int s)
+{
+	return __pic_delay((u64)s, 1000000);
+}
+
+#elif defined CONFIG_NLM_COMMON		/* for XLR and xlp without pic timer */
+
+extern u64 xlr_hpt_read(void);
+inline void __delay(unsigned int loops)
+{
+	uint32_t initial_count,curr_count;
+	uint32_t delta;
+
+	delta = loops;
+
+	initial_count = xlr_hpt_read();
+        while (1) {
+		curr_count = xlr_hpt_read();
+		if ((uint32_t)(curr_count - initial_count) > delta)
+			return;
+	}
+}
+
+inline void __udelay(unsigned long us)
+{
+	uint32_t initial_count,curr_count;
+	uint32_t delta;
+
+	delta = us * 66; /* clock runs at 66.6MHz speed */
+			    /* cant do floating point ops here */
+
+	initial_count = xlr_hpt_read();
+        while (1) {
+		curr_count = xlr_hpt_read();
+		if ((uint32_t)(curr_count - initial_count) > delta)
+			return;
+	}
+}
+
+inline void __ndelay(unsigned long ns)
+{
+	uint32_t initial_count,curr_count;
+	uint32_t delta;
+
+	/* clock runs at 66.6MHz speed
+	the minimum delay we have have is 1/66.67 = ~15 nsec */
+	delta = (ns >> 4) +1;
+
+	initial_count = xlr_hpt_read();
+        while (1) {
+		curr_count = xlr_hpt_read();
+		if ((uint32_t)(curr_count - initial_count) > delta)
+			return;
+	}
+}
+
+#else
+
 inline void __delay(unsigned int loops)
 {
 	__asm__ __volatile__ (
@@ -26,7 +122,6 @@ inline void __delay(unsigned int loops)
 	: "=r" (loops)
 	: "0" (loops));
 }
-EXPORT_SYMBOL(__delay);
 
 /*
  * Division by multiplication: you don't have to worry about
@@ -41,16 +136,18 @@ EXPORT_SYMBOL(__delay);
 
 void __udelay(unsigned long us)
 {
-	unsigned int lpj = raw_current_cpu_data.udelay_val;
+	unsigned int lpj = current_cpu_data.udelay_val;
 
 	__delay((us * 0x000010c7ull * HZ * lpj) >> 32);
 }
-EXPORT_SYMBOL(__udelay);
 
 void __ndelay(unsigned long ns)
 {
-	unsigned int lpj = raw_current_cpu_data.udelay_val;
+	unsigned int lpj = current_cpu_data.udelay_val;
 
 	__delay((ns * 0x00000005ull * HZ * lpj) >> 32);
 }
+#endif
+EXPORT_SYMBOL(__delay);
+EXPORT_SYMBOL(__udelay);
 EXPORT_SYMBOL(__ndelay);
diff --git a/arch/mips/lib/dump_tlb.c b/arch/mips/lib/dump_tlb.c
index 6d24322..5cbf206 100644
--- a/arch/mips/lib/dump_tlb.c
+++ b/arch/mips/lib/dump_tlb.c
@@ -1,3 +1,11 @@
+/*-
+ * Copyright 2003-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
 /*
  * Dump R4x00 TLB for debugging purposes.
  *
@@ -46,18 +54,16 @@ static inline const char *msk2str(unsigned int mask)
 		"nop;nop;nop;nop;nop;nop;nop\n\t"	\
 		".set\treorder");
 
-#ifdef CONFIG_NLM_XLP
-#define DEFAULT_ASID_MASK 0x3ff
-#else
-#define DEFAULT_ASID_MASK 0xff
-#endif
-
 static void dump_tlb(int first, int last)
 {
 	unsigned long s_entryhi, entryhi, asid;
 	unsigned long long entrylo0, entrylo1;
 	unsigned int s_index, pagemask, c0, c1, i;
-	unsigned int asid_mask = DEFAULT_ASID_MASK;
+#ifdef CONFIG_NLM_XLP
+	unsigned int asid_mask = 0x3ff;
+#else
+	unsigned int asid_mask = 0xff;
+#endif
 	int wired = read_c0_wired();
 	int print_tlb = 0;
 
@@ -76,11 +82,10 @@ static void dump_tlb(int first, int last)
 		entrylo1 = read_c0_entrylo1();
 
 		print_tlb = 0;
-		if ((i >= 0) && (i < wired))
-			print_tlb = 1;
+		if ( (i >= 0) && (i < wired) ) print_tlb = 1;
 		else {
-			if (((entryhi & ~0x1ffffUL) != CKSEG0)
-			     && ((entryhi & asid_mask) == asid))
+			if ( ((entryhi & ~0x1ffffUL) != CKSEG0)
+			     && ((entryhi & asid_mask) == asid) )
 				print_tlb = 1;
 		}
 
@@ -126,6 +131,6 @@ void dump_tlb_all(void)
 {
 	int ntlbs = current_cpu_data.tlbsize - 1;
 
-	pr_info("Dumping TLBS (0 --> %d): nwired = %d\n", ntlbs, read_c0_wired());
+	printk("Dumping TLBS (0 --> %d): nwired = %d\n", ntlbs, read_c0_wired());
 	dump_tlb(0, ntlbs);
 }
diff --git a/arch/mips/mm/Makefile b/arch/mips/mm/Makefile
index 185b043..2484406 100644
--- a/arch/mips/mm/Makefile
+++ b/arch/mips/mm/Makefile
@@ -39,4 +39,5 @@ obj-$(CONFIG_CPU_XLP)		+= c-phoenix.o tlb-r4k.o \
 obj-$(CONFIG_RM7000_CPU_SCACHE)	+= sc-rm7k.o
 obj-$(CONFIG_MIPS_CPU_SCACHE)	+= sc-mips.o
 
-EXTRA_CFLAGS += -Werror
+#EXTRA_CFLAGS += -Werror
+EXTRA_CFLAGS += -DNLM_HAL_LINUX_KERNEL
diff --git a/arch/mips/mm/c-phoenix.c b/arch/mips/mm/c-phoenix.c
index 8120eba..90a9831 100644
--- a/arch/mips/mm/c-phoenix.c
+++ b/arch/mips/mm/c-phoenix.c
@@ -1,7 +1,14 @@
+/*-
+ * Copyright 2003-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
 /*
  * Copyright (C) 1996 David S. Miller (dm@engr.sgi.com)
  * Copyright (C) 1997, 2001 Ralf Baechle (ralf@gnu.org)
- * Copyright (C) 2003-2010 Netlogic Microsystems Inc.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -29,13 +36,18 @@
 #include <linux/mm.h>
 #include <linux/module.h>
 
+#ifdef CONFIG_NLM_XLP
 #include <asm/mach-netlogic/xlp-mmu.h>
+#endif
 #include <asm/netlogic/debug.h>
 
 static unsigned int icache_linesz;
 static unsigned int icache_lines;
-static unsigned int dcache_linesz;
-static unsigned int dcache_lines;
+
+#ifdef CONFIG_NLM_VMIPS
+extern void nlm_vmips_temp_xkphys_tlb_add(phys_t start, phys_t end, int *tlbs, int *tlbe);
+extern void nlm_vmips_wired_entry_remove(int index);
+#endif
 
 #define cacheop(op, base) \
 	__asm__ __volatile__ (".set push\n.set mips4\ncache %0, 0(%1)\n.set pop\n" : : "i"(op), "r"(base))
@@ -53,17 +65,17 @@ static unsigned int dcache_lines;
 		: : "i" (op), "r" (base));          \
 	} while (0)
 
-static inline void sync_istream(void)
+static __inline__ void sync_istream(void)
 {
 	pipeline_flush();
 }
 
-static inline void cacheop_hazard(void)
+static __inline__ void cacheop_hazard(void)
 {
 	pipeline_flush();
 }
 
-static inline void cacheop_sync_istream(void)
+static __inline__ void cacheop_sync_istream(void)
 {
 	pipeline_flush();
 }
@@ -192,7 +204,11 @@ void nlm_common_flush_l1_icache_ipi(void *info)
 }
 #endif
 
+#ifdef CONFIG_KGDB
 void nlm_common_flush_l1_caches_ipi(void *info)
+#else
+static void nlm_common_flush_l1_caches_ipi(void *info)
+#endif
 {
 	optimize_thread_flush();
 
@@ -321,7 +337,7 @@ static __init void probe_l1_cache(void)
 	}
 }
 
-static inline void install_cerr_handler(void)
+static __inline__ void install_cerr_handler(void)
 {
 	extern char except_vec2_generic;
 
@@ -341,7 +357,7 @@ static void update_kseg0_coherency(void)
 	_page_cachable_default = (0x3 << _CACHE_SHIFT);
 }
 
-void nlm_cache_init(void)
+void ld_mmu_xlr(void)
 {
 	extern void build_clear_page(void);
 	extern void build_copy_page(void);
@@ -358,8 +374,6 @@ void nlm_cache_init(void)
 	/* These values are assumed to be the same for all cores */
 	icache_lines = current_cpu_data.icache.ways * current_cpu_data.icache.sets;
 	icache_linesz = current_cpu_data.icache.linesz;
-	dcache_lines = current_cpu_data.dcache.ways * current_cpu_data.dcache.sets;
-	dcache_linesz = current_cpu_data.dcache.linesz;
 
 	/* When does this function get called? Looks like MIPS has some syscalls
 	 * to flush the caches.
diff --git a/arch/mips/mm/c-r4k.c b/arch/mips/mm/c-r4k.c
index 898f8ec..6721ee2 100644
--- a/arch/mips/mm/c-r4k.c
+++ b/arch/mips/mm/c-r4k.c
@@ -383,12 +383,12 @@ static inline int has_valid_asid(const struct mm_struct *mm)
 
 static void r4k__flush_cache_vmap(void)
 {
-	r4k_on_each_cpu((void *)r4k_blast_dcache, NULL, 1);
+	r4k_blast_dcache();
 }
 
 static void r4k__flush_cache_vunmap(void)
 {
-	r4k_on_each_cpu((void *)r4k_blast_dcache, NULL, 1);
+	r4k_blast_dcache();
 }
 
 static inline void local_r4k_flush_cache_range(void * args)
@@ -614,7 +614,7 @@ static void r4k_dma_cache_wback_inv(unsigned long addr, unsigned long size)
 	 * explicitly
 	 */
 	if (cpu_has_safe_index_cacheops && size >= dcache_size) {
-		r4k_on_each_cpu((void *)r4k_blast_dcache, NULL, 1);
+		r4k_blast_dcache();
 	} else {
 		R4600_HIT_CACHEOP_WAR_IMPL;
 		blast_dcache_range(addr, addr + size);
@@ -652,7 +652,7 @@ static void r4k_dma_cache_inv(unsigned long addr, unsigned long size)
 	}
 
 	if (cpu_has_safe_index_cacheops && size >= dcache_size) {
-		r4k_on_each_cpu((void *)r4k_blast_dcache, NULL, 1);
+		r4k_blast_dcache();
 	} else {
 		unsigned long lsize = cpu_dcache_line_size();
 		unsigned long almask = ~(lsize - 1);
diff --git a/arch/mips/mm/cache.c b/arch/mips/mm/cache.c
index d02bcc78..a6e15d9 100644
--- a/arch/mips/mm/cache.c
+++ b/arch/mips/mm/cache.c
@@ -1,3 +1,12 @@
+/*-
+ * Copyright 2007-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
+
 /*
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
@@ -5,7 +14,6 @@
  *
  * Copyright (C) 1994 - 2003, 06, 07 by Ralf Baechle (ralf@linux-mips.org)
  * Copyright (C) 2007 MIPS Technologies, Inc.
- * Copyright (C) 2003-2010 Netlogic Microsystems Inc.
  */
 #include <linux/fs.h>
 #include <linux/fcntl.h>
@@ -205,9 +213,9 @@ void __cpuinit cpu_cache_init(void)
 		tx39_cache_init();
 	}
 	if (cpu_has_nlm_cache) {
-		extern void __weak nlm_cache_init(void);
+		extern void __weak ld_mmu_xlr(void);
 
-		nlm_cache_init();
+		ld_mmu_xlr();
 	}
 
 	if (cpu_has_octeon_cache) {
@@ -221,7 +229,7 @@ void __cpuinit cpu_cache_init(void)
 
 int __weak __uncached_access(struct file *file, unsigned long addr)
 {
-	if (file->f_flags & O_DSYNC)
+	if (file->f_flags & O_SYNC)
 		return 1;
 
 	return addr >= __pa(high_memory);
diff --git a/arch/mips/mm/cerr-nlm.c b/arch/mips/mm/cerr-nlm.c
index 0f7526a..249fe40 100644
--- a/arch/mips/mm/cerr-nlm.c
+++ b/arch/mips/mm/cerr-nlm.c
@@ -1,45 +1,67 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
 
 #include <linux/smp.h>
 #include <asm/system.h>
 
 #include <asm/netlogic/iomap.h>
-#include <asm/netlogic/mips-exts.h>
+#include <asm/netlogic/hal/nlm_hal.h>
+#include <asm/netlogic/hal/nlm_hal_macros.h>
+#include <asm/netlogic/xlp.h>
+#include <asm/netlogic/xlp_irq.h>
+#include <asm/netlogic/hal/nlm_hal_xlp_dev.h>
+#include <asm/inst.h>
+#include <asm/ptrace.h>
+#include <asm/fpu.h>
+#include <asm/asm.h>
+#include <asm/mipsregs.h>
+#include <hal/nlm_hal_macros.h>
 
 unsigned char nlm_cerr_stack[8192];
 volatile int nlm_cerr_lock;
 
-static inline void cerr_cpu_halt(void)
+static void load_registers(struct pt_regs *regs, unsigned long *pErrepc);
+static void restore_registers(struct pt_regs *regs, unsigned long errepc);
+static int  compute_return_registers(struct pt_regs *regs, unsigned long *pErrepc);
+static int  update_registers(void);
+
+static __inline__ void cerr_cpu_halt(void)
 {
-	for (;;) {
-		__asm__ __volatile__(".set mips64\n"
-				     "1: wait \n"
-				     "   b 1b\n"
-				     "   nop\n"
-			);
+	for(;;) {
+		__asm__ __volatile__(
+			".set push      \n"
+			".set mips64    \n"
+			"1: wait        \n"
+			"   b 1b        \n"
+			"   nop         \n"
+			".set pop       \n"
+		);
 	}
 }
 
@@ -92,31 +114,494 @@ static void cerr_printk(const char *fmt, ...)
 
 }
 
-static void print_cerr_info(void)
+static void print_error_header(void)
+{
+	cerr_printk("*******************************************************************************************\n");
+	cerr_printk("cpu_%d received a bus/cache error(warning)\n", hard_smp_processor_id());
+	cerr_printk("*******************************************************************************************\n");
+}
+
+#ifdef CONFIG_NLM_XLR
+
+static char *bridge_aerr_intr_devstat[] = {
+	[0] = "cpu 0",
+	[1] = "cpu 1",
+	[2] = "cpu 2",
+	[3] = "cpu 3",
+	[4] = "cpu 4",
+	[5] = "cpu 5",
+	[6] = "cpu 6",
+	[7] = "cpu 7",
+
+	[8] = "L2",
+	[9] = "XGS 0",
+	[10] = "XGS 1",
+	[11] = "GMAC",
+	[12] = "SEC",
+	[13] = "PCIX",
+	[14] = "HT",
+	[15] = "DMA",
+};
+
+static int print_cerr_info(void)
+{
+	__u64 cerr_cpu_log = 0;
+	int i = 0;
+	nlm_reg_t *mmio = netlogic_io_mmio(NETLOGIC_IO_BRIDGE_OFFSET);
+	__u32 tmp = 0;
+
+	print_error_header();
+
+	cerr_printk("Bridge: Phys Addr = 0x%010llx, Device_AERR = 0x%08x\n",
+			( ((__u64)netlogic_read_reg(mmio, 39)<<5) | ((__u64)netlogic_read_reg(mmio, 40)<<37) ),
+			netlogic_read_reg(mmio, 41));
+
+	cerr_printk("Bridge: The devices reporting AERR are:\n");
+	tmp = netlogic_read_reg(mmio, 41);
+	for(i = 0; i < 16; i++) {
+		if (tmp & (1<<i)) cerr_printk("\t%s\n", bridge_aerr_intr_devstat[i]);
+	}
+
+	cerr_cpu_log = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERRLOG_REGID);
+	cerr_printk("CPU: (XLR specific) Cache Error log = 0x%016llx, Phy Addr = 0x%010llx\n",
+			cerr_cpu_log, ((cerr_cpu_log >> 10) & 0xffffffffffULL) << 3);
+
+	return 1;
+}
+
+#else
+
+static void dump_cerr_info(void)
 {
-	nlm_reg_t *nbu_mmio = netlogic_io_mmio(NETLOGIC_IO_BRIDGE_OFFSET);
+	int n, num_controllers, ret;
+	uint32_t dram_log1, dram_log2;
+	int node = hard_smp_processor_id() / NLM_MAX_CPU_PER_NODE;
+	uint64_t mmio = nlm_hal_get_dev_base(node, 0, NLH_BRIDGE, 0);
+
+	uint32_t nbu_reg0 = nlm_hal_read_32bit_reg(mmio, 0xA2);
+	uint32_t nbu_reg1 = nlm_hal_read_32bit_reg(mmio, 0xA3);
+	uint32_t nbu_reg2 = nlm_hal_read_32bit_reg(mmio, 0xA4);
 
-	uint64_t icu_log0 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_ICU, ICU_CERRLOG0_REGID);
-	uint64_t icu_log1 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_ICU, ICU_CERRLOG1_REGID);
-	uint64_t icu_log2 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_ICU, ICU_CERRLOG2_REGID);
-	uint64_t lsu_log0 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERRLOG0_REGID);
+	uint32_t icu_log0 = read_32bit_nlm_ctrl_reg(CPU_BLOCKID_ICU, ICU_CERRLOG0_REGID);
+	uint32_t icu_log1 = read_32bit_nlm_ctrl_reg(CPU_BLOCKID_ICU, ICU_CERRLOG1_REGID);
+	uint32_t icu_log2 = read_32bit_nlm_ctrl_reg(CPU_BLOCKID_ICU, ICU_CERRLOG2_REGID);
+
+	uint32_t lsu_log0 = read_32bit_nlm_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERRLOG0_REGID);
 	uint64_t lsu_log1 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERRLOG1_REGID);
-	uint64_t scu_log0 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_SCU, SCU_CERRLOG0_REGID);
-	uint64_t scu_log1 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_SCU, SCU_CERRLOG1_REGID);
-	uint64_t scu_log2 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_SCU, SCU_CERRLOG2_REGID);
 
-	cerr_printk("CPU: (XLP specific) ICU log0 = 0x%016llx, log1 = 0x%016llx, log2 = 0x%016llx\n"
-		    "                    LSU log0 = 0x%016llx, log1 = 0x%016llx\n"
-		    "                    SCU log0 = 0x%016llx, log1 = 0x%016llx, log2 = 0x%016llx\n",
-		    icu_log0, icu_log1, icu_log2,
-		    lsu_log0, lsu_log1,
-		    scu_log0, scu_log1, scu_log2);
+	uint32_t scu_log0 = read_32bit_nlm_ctrl_reg(CPU_BLOCKID_SCU, SCU_CERRLOG0_REGID);
+	uint32_t scu_log1 = read_32bit_nlm_ctrl_reg(CPU_BLOCKID_SCU, SCU_CERRLOG1_REGID);
+	uint32_t scu_log2 = read_32bit_nlm_ctrl_reg(CPU_BLOCKID_SCU, SCU_CERRLOG2_REGID);
+
+	uint32_t l3_reg0 = nlm_hal_read_32bit_reg(mmio, 0xD9);
+	uint32_t l3_reg1 = nlm_hal_read_32bit_reg(mmio, 0xDA);
+	uint32_t l3_reg2 = nlm_hal_read_32bit_reg(mmio, 0xDB);
+
+	uint32_t cop2_txmsgstatus, cop2_msgstatus1;
+
+	cop2_txmsgstatus = (uint32_t) _read_32bit_cp2_register($2);
+	cop2_msgstatus1  = (uint32_t) _read_32bit_cp2_register($4);
+
+	cerr_printk("CPU (XLP specific) registers dump: Node=%d \n", node);
+	cerr_printk("    COP2: TxMsgStatus = 0x%08x, MsgStatus1 = 0x%08x\n",
+				cop2_txmsgstatus, cop2_msgstatus1 );
+
+	cerr_printk("     ICU: log0 = 0x%08x, log1 = 0x%08x, log2 = 0x%08x\n",
+				icu_log0, icu_log1, icu_log2);
+
+	cerr_printk("     LSU: log0 = 0x%08x, log1 = 0x%016llx\n", lsu_log0, lsu_log1);
+
+	cerr_printk("     SCU: log0 = 0x%08x, log1 = 0x%08x, log2 = 0x%08x\n",
+				scu_log0, scu_log1, scu_log2);
+
+	cerr_printk("     TCU: reg0 = 0x%08x, reg1 = 0x%08x, reg2 = 0x%08x\n",
+				l3_reg0, l3_reg1, l3_reg2);
+
+	cerr_printk("     NBU: reg0 = 0x%08x, reg1 = 0x%08x, reg2 = 0x%08x\n",
+				nbu_reg0, nbu_reg1, nbu_reg2);
+
+	num_controllers = 4;	//8xx has 4 controller 
+	ret=is_nlm_xlp(300, XLP_REVISION_ANY, CPU_EXTPID_XLP_3XX_ANY);
+	if( ret ) num_controllers = 2;
+	else
+	{
+		ret=is_nlm_xlp(200, XLP_REVISION_ANY, 0 );
+		if( ret ) num_controllers = 1;
+	}
+
+	for(n=0; n<num_controllers; n++)
+	{
+		dram_log1 = nlm_hal_read_32bit_reg(mmio, n*0x80+0x11D);
+		dram_log2 = nlm_hal_read_32bit_reg(mmio, n*0x80+0x11E);
+		cerr_printk("  DRAM_%c: reg1 = 0x%08x, reg2 = 0x%08x\n",
+                (char)(n+'A'), dram_log1, dram_log2);
+	}
+
+	cerr_printk("\n     CPU: epc = 0x%lx, errorepc = 0x%016llx, cacheerr = 0x%08x\n",
+			read_c0_epc(), read_c0_errorepc(), read_c0_cacheerr());
+	cerr_printk("*******************************************************************************************\n");
+}
+
+static int check_COP2_error(void)
+{
+	uint32_t cop2_txmsgstatus, cop2_msgstatus1;
+	cop2_txmsgstatus = (uint32_t)_read_32bit_cp2_register( $2 );
+	cop2_msgstatus1  = (uint32_t)_read_32bit_cp2_register( $4 );
+
+	if( ((cop2_txmsgstatus >> 3) & 1) == 0 && ((cop2_msgstatus1 >> 12) & 1) == 0 ) return 0;
+
+	cerr_printk("COP2 Cache error: \n");
+	if( (cop2_txmsgstatus >> 3) & 1 )
+	{
+		cerr_printk("  TQF: %s\n", (cop2_txmsgstatus >> 24) ? "Queue full" : "Queue not full");
+		cerr_printk("  DFC: 0x%04x\n", (cop2_txmsgstatus >> 4) & 0xFFFF);
+		cerr_printk(" DFCF: ECC error during OQ credit RAM read from COP2 RAM\n");
+		cerr_printk("   PS: %s\n", (cop2_txmsgstatus >> 2) & 1 ? "failed due to pending synchronization" : "Status good");
+		cerr_printk("  IQC: %s\n", (cop2_txmsgstatus >> 1) & 1 ? "error insufficient input credit" : "Status good" );
+		cerr_printk("  OQC: %s\n", (cop2_txmsgstatus >> 0) & 1 ? "error insufficient output credit": "Status good" );
+	}
+
+	if( (cop2_msgstatus1 >> 12) & 1 )
+	{
+		cerr_printk("      VCE: 0x%x\n", (cop2_msgstatus1 >> 24 ) & 0xF );
+		cerr_printk("      RWF: %d\n",   (cop2_msgstatus1 >> 23 ) & 1 );
+		cerr_printk("      ICO: %d\n",   (cop2_msgstatus1 >> 22 ) & 1 );
+		cerr_printk("      OCO: %d\n",   (cop2_msgstatus1 >> 21 ) & 1 );
+		cerr_printk("       ME: %d\n",   (cop2_msgstatus1 >> 20 ) & 1 );
+		cerr_printk("  VC_Pend: %d\n",   (cop2_msgstatus1 >> 16 ) & 0xF );
+		cerr_printk("   MSGSTA: ECC error in COP2 RAM\n");
+		cerr_printk("     OQID: 0x%03x\n", cop2_msgstatus1 & 0xFFF );
+	}
 
-	cerr_printk("NBU: Bar Aerr reg0 = 0x%08x, reg1 = 0x%08x, reg2 = 0x%08x\n",
-		    netlogic_read_reg(nbu_mmio, 162), netlogic_read_reg(nbu_mmio, 163),
-		    netlogic_read_reg(nbu_mmio, 164));
+	return -1;
 }
 
+static char * c_icu_errinfo[]={
+	[0] = "L1 tag RAM",
+	[1] = "L1 data RAM",
+	[2] = "Not defined"
+};
+
+static int check_ICU_error(void)
+{
+	uint32_t icu_log0 = read_32bit_nlm_ctrl_reg(CPU_BLOCKID_ICU, ICU_CERRLOG0_REGID);
+	uint32_t icu_log1 = read_32bit_nlm_ctrl_reg(CPU_BLOCKID_ICU, ICU_CERRLOG1_REGID);
+	uint32_t icu_log2 = read_32bit_nlm_ctrl_reg(CPU_BLOCKID_ICU, ICU_CERRLOG2_REGID);
+	uint64_t phyaddr = ( (uint64_t)icu_log2 << 32) | icu_log1;
+	uint32_t errinfo = (icu_log0 >> 12) & 0xF;
+	uint32_t errtype = (icu_log0 >> 9) & 7;
+	uint32_t oprtype = (icu_log0 >> 6) & 7;
+
+	if( (icu_log0&0xF) == 0 && icu_log1 == 0 && icu_log2 == 0 ) return 0;
+
+	cerr_printk("ICU Cache %s:\n", (icu_log0&0xF) ? "Error" : "Warning" );
+	cerr_printk("   log0=0x%08x, phyaddr=0x%016llx\n", icu_log0, phyaddr);
+	if( (icu_log0 & 0xF) == 0 )
+	{
+		write_32bit_nlm_ctrl_reg(CPU_BLOCKID_ICU,ICU_CERRLOG1_REGID, 0);
+		write_32bit_nlm_ctrl_reg(CPU_BLOCKID_ICU,ICU_CERRLOG2_REGID, 0);
+		return 1;
+	}
+	else
+	{
+		cerr_printk("          errinfo: %s\n", errinfo < 2  ? c_icu_errinfo[errinfo] : c_icu_errinfo[2] );
+		cerr_printk("          errtype: %s\n", errtype == 0 ? "Single‐bit error" : "Not defined");
+		cerr_printk("          oprtype: %s\n", oprtype == 0 ? "Read access" : "Not defined");
+		cerr_printk("    Uncorrectable: %d\n", ( icu_log0 >> 5) & 1);
+		cerr_printk("         Overflow: %d\n", ( icu_log0 >> 4 ) & 1);
+		cerr_printk("     Threads Mask: %x\n", icu_log0 & 0xF );
+		return -1;
+	}
+}
+
+static int check_LSU_error(void)
+{
+	uint32_t lsu_log0 = read_32bit_nlm_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERRLOG0_REGID);
+	uint64_t lsu_log1 = read_64bit_nlm_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERRLOG1_REGID);
+	if( (lsu_log0 & 0xF) == 0 && lsu_log1 == 0 ) return 0;
+
+	cerr_printk("LSU Cache %s:\n", (lsu_log0&0xF) ? "Error" : "Warning" );
+	cerr_printk("   log0=0x%016llx, phyaddr=0x%010llx\n", lsu_log0, lsu_log1);
+	if( (lsu_log0 & 0xF ) == 0 )
+	{
+		write_64bit_nlm_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERRLOG1_REGID, 0);
+		return 1;
+	}
+	else
+	{
+		cerr_printk("                 Info: %s\n", ((lsu_log0>>11)&1)==0 ? "TAG" : "DATA" );
+		cerr_printk("              ErrType: %s\n", ((lsu_log0>>10)&1)==0 ? "Parity Error" :  "Reserved");
+		cerr_printk("               OpType: %s\n", ((lsu_log0>> 6)&1)==0 ? "Read" :  "Reserved" );
+		cerr_printk("   Ucorrectable Error: %d\n", (lsu_log0>>5)&1);
+		cerr_printk("       Error Overflow: %d\n", (lsu_log0>>4)&1);
+		cerr_printk("   Error threads mask: %x\n", lsu_log0&0xF);
+		return -1;
+	}
+}
+
+static char *c_l2_errtype[] = {
+	[0] = "Single‐bit Tag RAM error",
+	[1] = "Double‐bit Tag RAM Error",
+	[2] = "Valid Array Parity Error",
+	[3] = "Single‐bit Data RAM Error",
+	[4] = "Double‐bit Data RAM Error",
+	[5] = "External Error from Data or Completion for Fill",
+	[6] = "Evict Completion Error. Registers do not hold the correct address/way",
+	[7] = "Reserved"
+};
+
+static char *c_l2_erroptype[] = {
+	[0] = "Load",
+	[1] = "Probe",
+	[2] = "Store",
+	[3] = "Load Fill",
+	[4] = "Store Fill",
+	[5] = "Evict Completion",
+	[6] = "Reserved"
+};
+
+static int check_SCU_error(void)
+{
+	uint32_t scu_log0 = read_32bit_nlm_ctrl_reg(CPU_BLOCKID_SCU, SCU_CERRLOG0_REGID);
+	uint32_t scu_log1 = read_32bit_nlm_ctrl_reg(CPU_BLOCKID_SCU, SCU_CERRLOG1_REGID);
+	uint32_t scu_log2 = read_32bit_nlm_ctrl_reg(CPU_BLOCKID_SCU, SCU_CERRLOG2_REGID);
+
+	uint64_t phyaddr = ((uint64_t)scu_log2 << 32) | scu_log1;
+	int errtype  = ( scu_log0 >> 8 ) & 0xF;
+	int erroptyp = ( scu_log0 >> 4 ) & 7;
+
+	if( ( scu_log0 & 1) == 0 && phyaddr == 0 )	return 0;
+
+	cerr_printk("SCU Cache %s:\n", (scu_log0&1) ? "Error" : "Warning" );
+	cerr_printk("   log0=0x%08x, phyaddr=0x%016llx\n", scu_log0, phyaddr);
+	if( ( scu_log0 & 1 ) == 0 )
+	{
+		write_32bit_nlm_ctrl_reg(CPU_BLOCKID_SCU, SCU_CERRLOG1_REGID, 0);
+		write_32bit_nlm_ctrl_reg(CPU_BLOCKID_SCU, SCU_CERRLOG2_REGID, 0);
+		return 1;
+	}
+	else
+	{
+		cerr_printk("          Way Info: %s\n", (scu_log0>>12)&0xF );
+		cerr_printk("          ErrType: %s\n", errtype<7 ? c_l2_errtype[errtype] : c_l2_errtype[7] );
+		cerr_printk("        ErrOpType: %s\n", erroptyp<6 ? c_l2_erroptype[erroptyp] : c_l2_erroptype[6] );
+		cerr_printk("    Uncorrectable: %d\n", (scu_log0>>2)&1);
+		cerr_printk("         Overflow: %d\n", (scu_log0>>1)&1);
+		cerr_printk("      Error Valid: %d\n", scu_log0&1);
+		return -1;
+	}
+}
+
+static char *c_l3_inf[] = {
+	[0] = "TAG",
+	[1] = "STATE",
+	[2] = "DATA",
+	[3] = "Not defined"
+};
+
+static char *c_l3_ErTy[] = {
+	[0] = "Single‐bit ECC",
+	[1] = "Multi‐bit ECC",
+	[2] = "Not defined"
+};
+
+static char *c_l3_ErOpTy[] = {
+	[0] = "Read",
+	[1] = "Write",
+	[2] = "Msg",
+	[3] = "Reserved"
+};
+
+static int check_L3_error(void)
+{
+	int node = hard_smp_processor_id() / NLM_MAX_CPU_PER_NODE;
+	uint64_t mmio = nlm_hal_get_dev_base(node, 0, NLH_BRIDGE, 0);
+
+	uint32_t reg0 = nlm_hal_read_32bit_reg(mmio, 0xD9);
+	uint32_t reg1 = nlm_hal_read_32bit_reg(mmio, 0xDA);
+	uint32_t reg2 = nlm_hal_read_32bit_reg(mmio, 0xDB);
+
+	uint64_t phyaddr = ( (uint64_t)reg2 << 32 ) | reg1;
+	uint8_t  erinf = (reg0 >> 11) & 0x1F;
+	uint8_t  erty  = (reg0 >> 8 ) & 7;
+	uint8_t  opty  = (reg0 >> 4 ) & 7;
+
+	if( ( reg0 & 1) == 0 && phyaddr == 0 ) return 0;
+
+	cerr_printk("L3 Cache %s:\n", (reg0&1) ? "Error" : "Warning" );
+	cerr_printk("   log0=0x%08x, phyaddr=0x%016llx\n", reg0, phyaddr);
+	if( ( reg0 & 1) == 0)
+	{
+		nlm_hal_write_32bit_reg(mmio, 0xDA, 0);
+		nlm_hal_write_32bit_reg(mmio, 0xDB, 0);
+		return 1;
+	}
+	else
+	{
+		cerr_printk("      Error Info: %s\n", erinf < 3 ? c_l3_inf[erinf]   : c_l3_inf[3]   );
+		cerr_printk("      Error Type: %s\n", erty  < 2 ? c_l3_ErTy[erty]   : c_l3_ErTy[2]  );
+		cerr_printk("     Option Type: %s\n", opty  < 4 ? c_l3_ErOpTy[opty] : c_l3_ErOpTy[3]);
+		cerr_printk("   Uncorrectable: %d\n", ( reg0 >> 2 ) & 1);
+		cerr_printk("        Overflow: %d\n", ( reg0 >> 1 ) & 1);
+		cerr_printk("           Valid: %d\n", reg0 & 1 );
+		return -1;
+	}
+}
+
+static int check_DRAM_error(void)
+{
+	int n, error=0;
+	uint32_t log1, log2;
+	int node = hard_smp_processor_id() / NLM_MAX_CPU_PER_NODE;
+	uint64_t mmio = nlm_hal_get_dev_base(node, 0, NLH_BRIDGE, 0);
+
+	int num_controllers = 4;	//8xx has 4 controller 
+	int ret=is_nlm_xlp(300, XLP_REVISION_ANY, CPU_EXTPID_XLP_3XX_ANY);
+	if( ret ) num_controllers = 2;
+	else
+	{
+		ret=is_nlm_xlp(200, XLP_REVISION_ANY, 0 );
+		if( ret ) num_controllers = 1;
+	}
+
+	for(n=0; n<num_controllers; n++)
+	{
+		log1 = nlm_hal_read_32bit_reg(mmio, n*0x80+0x11D);
+		log2 = nlm_hal_read_32bit_reg(mmio, n*0x80+0x11E);
+		if( ( log1 & 1 ) == 0 ) continue;
+
+		if(error==0)	cerr_printk("DRAM exception: \n");
+		cerr_printk("  Bank (%c): log1=0x%08x, log1=0x%08x\n", (char)(n+'A'),log1, log2);
+		cerr_printk("       Syndrome: %x\n",  (log1>>16) );
+		cerr_printk("     Error Type: %x\n",  (log1>>8) & 0xF );
+		cerr_printk("       Opt Type: %x\n",  (log1>>4) & 0xF );
+		cerr_printk("  Uncorrectable: %d\n",  (log1>>2) & 1 );
+		cerr_printk("       Overflow: %d\n",  (log1>>1) & 1 );
+		cerr_printk("    Error Valid: %d\n",  log1&1 );
+
+		cerr_printk("    Error Rank: %x\n", (log2>>12)&3 );
+		cerr_printk("       ChunkID: %d 16-byte chunk\n", (log2>>8)&3 );
+		cerr_printk(" Error Bit pos: %d\n",  log1&0x3F );
+
+		error++;
+	}
+
+	return 0 < error ? -1 : 0;
+}
+
+static char *c_nbu_reqsrc[] = {
+	[0] = "Core 0",
+	[1] = "Core 1",
+	[2] = "Core 2",
+	[3] = "Core 3",
+	[4] = "Core 4",
+	[5] = "Core 5",
+	[6] = "Core 6",
+	[7] = "Core 7",
+	[8] = "L3",
+	[9] = "DRAM",
+	[10] = "IO",
+	[11] = "GCU",
+	[12] = "NBU",
+	[13] = "Invalid",
+	[14] = "Invalid",
+	[15] = "Invalid",
+};
+
+static char *c_nbu_reqtype[] = {
+	[0] = "Invalidate",
+	[1] = "Read",
+	[2] = "Read Exclusive",
+	[3] = "Read Upgrade",
+	[4] = "Writeback",
+	[5] = "IO Read",
+	[6] = "IO Write",
+	[7] = "IO Read Exclusive",
+};
+
+static int check_NBU_error(void)
+{
+	int node = hard_smp_processor_id() / NLM_MAX_CPU_PER_NODE;
+	uint64_t nbu_mmio = nlm_hal_get_dev_base(node, 0, NLH_BRIDGE, 0);
+
+	uint32_t nbu_reg0 = nlm_hal_read_32bit_reg(nbu_mmio, 0xA2);
+	uint32_t nbu_reg1 = nlm_hal_read_32bit_reg(nbu_mmio, 0xA3);
+	uint32_t nbu_reg2 = nlm_hal_read_32bit_reg(nbu_mmio, 0xA4);
+
+	uint8_t src  = (nbu_reg0 >> 7) & 0xF;
+	uint8_t type = (nbu_reg0 >> 4) & 0x7;
+	uint8_t overflow = (nbu_reg0 >> 3) & 0x1;
+	uint8_t valid = (nbu_reg0 >> 2) & 0x1;
+	uint64_t phyaddr = ( (uint64_t)nbu_reg2 << 32) | nbu_reg1;
+
+	if( valid == 0 && phyaddr == 0)	return 0;
+
+	cerr_printk("NBU Cache %s:\n", valid ? "Error" : "Warning" );
+	cerr_printk("   log0=0x%08x, phyaddr=0x%016llx\n", nbu_reg0, phyaddr);
+
+	if( valid == 0 )
+	{
+		nlm_hal_write_32bit_reg(nbu_mmio, 0xA3, 0);
+		nlm_hal_write_32bit_reg(nbu_mmio, 0xA4, 0);
+		return 1;
+	}
+	else
+	{
+		cerr_printk("          ReqSrc: %s\n", c_nbu_reqsrc[src] );
+		cerr_printk("         ReqType: %s\n", c_nbu_reqtype[type] );
+		cerr_printk("        Overflow: %d\n", overflow);
+		cerr_printk("  	  Error Valid: %d\n", valid);
+		return -1;
+	}
+}
+
+static int  print_cerr_info(void)
+{
+	int ret = 0, error=0, warning=0 ;
+
+	print_error_header();
+	dump_cerr_info();
+
+	ret = check_COP2_error();
+	if(ret < 0) error++;
+	else if(ret > 0) warning++;
+
+	ret = check_ICU_error();
+	if(ret < 0) error++;
+	else if(ret > 0) warning++;
+
+	ret = check_LSU_error();
+	if(ret < 0) error++;
+	else if(ret > 0) warning++;
+
+	ret = check_SCU_error();
+	if(ret < 0) error++;
+	else if(ret > 0) warning++;
+
+	ret = check_L3_error();
+	if(ret < 0) error++;
+	else if(ret > 0) warning++;
+
+	ret = check_NBU_error();
+	if(ret < 0) error++;
+	else if(ret > 0) warning++;
+
+	ret = check_DRAM_error();
+	if(ret < 0) error++;
+	else if(ret > 0) warning++;
+
+	ret = 0;
+	if( 0 < error ) ret = -1;
+	else if( warning <= 0 )
+	{
+		cerr_printk(" Unknown Cache error in exception handler!\n");
+		ret = -1;
+	}
+
+	return ret;
+}
+#endif
+
 /* On XLR/XLP, errors reported by bridge (like misconfigured BARS etc) are also
  * reported as cache errors. Need to check if it is really a cache error or a "bus error"
  * and take action appropriately.
@@ -124,23 +609,299 @@ static void print_cerr_info(void)
  */
 asmlinkage void nlm_cache_error(void)
 {
-	local_irq_disable();
+	int ret = 0 ;
 
-	/* let the first cpu in */
-	while (nlm_cerr_lock)
-		;
-	nlm_cerr_lock = 1;
+	ret = print_cerr_info();
 
-	cerr_printk("*********************************************\n");
-	cerr_printk("cpu_%d received a bus/cache error\n", hard_smp_processor_id());
-	cerr_printk("*********************************************\n");
+	if( ret == 0 )	ret=update_registers();
 
-	print_cerr_info();
+	if( ret == 0 )	cerr_printk("\n ------- CPU return to normal execution! ------------\n\n");
+	else
+	{
+		cerr_printk("Can not handle bus/cache error - Halting cpu\n\n");
+		cerr_cpu_halt();
+	}
+}
 
-	cerr_printk("CPU: epc = 0x%lx, errorepc = 0x%lx, cacheerr = 0x%08x\n",
-			read_c0_epc(), read_c0_errorepc(), read_c0_cacheerr());
+static int update_registers(void)
+{
+	unsigned long errepc;
+	struct pt_regs regs;
+	int ret=0;
+
+	load_registers(&regs, &errepc);
+
+	ret=compute_return_registers(&regs, &errepc);
+	if(ret!=0)
+	{
+		cerr_printk("  Update registers fail! CPU could not return to normal execution!\n");
+		return -1;
+	}
+
+	restore_registers(&regs, errepc);
+	return 0;
+}
+
+static void load_registers(struct pt_regs *regs, unsigned long *pErrepc)
+{
+	int iRegPos, n;
+	uint64_t *pReg;
+	unsigned long k0, k1;
+
+	if(regs==NULL || pErrepc==NULL)	return;
+	memset(regs, 0, sizeof(*regs));
 
-	cerr_printk("Can not handle bus/cache error - Halting cpu\n");
+	//copy original registers value from stack
+	iRegPos=0x2000-40*8;
+	pReg = (uint64_t*)( nlm_cerr_stack + iRegPos );
+	for( n=0; n<32; n++) regs->regs[n] = (unsigned long)pReg[n] ;
+
+	//copy original register: sp, ra, errepc
+	pReg=(uint64_t*)(nlm_cerr_stack + 0x2000);	//top of the stack
+	regs->regs[29] = *(pReg - 1);	//sp
+	regs->regs[31] = *(pReg - 2);	//ra
+	*pErrepc = *( pReg -3 );		//ErrEpc
+
+	//copy k0, k1 from scratch register
+	#ifdef CONFIG_64BIT
+	__asm__ volatile(
+		".set push         \n"
+		".set mips64r2     \n"
+		"dmfc0 %0, $22, 3  \n"
+		"dmfc0 %1, $22, 4  \n"
+		".set pop          \n"
+		:"=r" (k0), "=r" (k1)
+	);
+	#else	//32 bits
+	__asm__ volatile(
+		".set push         \n"
+		".set mips64r2     \n"
+		"mfc0 %0, $22, 3   \n"
+		"mfc0 %1, $22, 4   \n"
+		".set pop          \n"
+		:"=r" (k0), "=r" (k1)
+	);
+	#endif //CONFIG_64BIT
+
+	regs->regs[26] = k0 ;
+	regs->regs[27] = k1 ;
+}
+
+static void restore_registers(struct pt_regs *regs, unsigned long errepc)
+{
+	int iRegPos, n;
+	uint64_t *pReg;
+	unsigned long  k0, k1;
+
+	if(regs == NULL )	return;
+
+	//copy original registers value from stack
+	iRegPos=0x2000-40*8;
+	pReg=(uint64_t*)(nlm_cerr_stack + iRegPos );
+	for(n=0; n<32; n++) pReg[n] = regs->regs[n];
+
+	//copy original register: sp, ra, errepc
+	pReg=(uint64_t*)(nlm_cerr_stack + 0x2000);	//top of the stack
+	*(pReg - 1) = regs->regs[29] ;  //sp
+	*(pReg - 2) = regs->regs[31] ;  //ra
+	*(pReg - 3) = errepc;           //ErrEpc
+
+	//copy k0, k1 from scratch register
+	k0 = regs->regs[26] ;
+	k1 = regs->regs[27] ;
+
+	#ifdef CONFIG_64BIT
+	__asm__ volatile(
+		".set push         \n"
+		".set noreorder    \n"
+		".set mips64r2     \n"
+		"dmtc0 %0, $22, 3  \n"
+		"dmtc0 %1, $22, 4  \n"
+		".set pop          \n"
+		::"r" (k0), "r" (k1)
+	);
+	#else  //32bits
+	__asm__ volatile(
+		".set push         \n"
+		".set noreorder    \n"
+		".set mips64r2     \n"
+		"mtc0 %0, $22, 3   \n"
+		"mtc0 %1, $22, 4   \n"
+		".set pop          \n"
+		::"r" (k0), "r" (k1)
+	);
+	#endif //CONFIG_64BIT
+}
+
+static int compute_return_registers(struct pt_regs *regs, unsigned long *pErrepc)
+{
+	unsigned int  *addr;
+	unsigned int bit, fcr31, dspcontrol;
+	unsigned long errepc;
+	union mips_instruction insn;
+
+	if(pErrepc==NULL)	return -1;
+
+	/*	it has slight chance that prev_errepc may not in the tlb and tlb handling of prev_errepc may trigger
+		some issues, or prev_errepc may point to non insn. Since we do not have enough informaiton, have to 
+		access as normal.
+ 	*/
+	errepc = *pErrepc;
+	addr = (uint32_t*) errepc;
+	insn.word = *addr;
+
+	regs->regs[0] = 0;
+	switch (insn.i_format.opcode) {
+	// jr and jalr are in r_format format.
+	case spec_op:
+		switch (insn.r_format.func) {
+		case jalr_op:
+			regs->regs[insn.r_format.rd] = errepc + 8;
+			// Fall through
+		case jr_op:
+			errepc = regs->regs[insn.r_format.rs];
+			break;
+		}
+		break;
+
+	/*
+	 * This group contains:
+	 * bltz_op, bgez_op, bltzl_op, bgezl_op,
+	 * bltzal_op, bgezal_op, bltzall_op, bgezall_op.
+	 */
+	case bcond_op:
+		switch (insn.i_format.rt) {
+		case bltz_op:
+		case bltzl_op:
+			if ((long)regs->regs[insn.i_format.rs] < 0)
+				errepc = errepc + 4 + (insn.i_format.simmediate << 2);
+			else
+				errepc += 8;
+			break;
+
+		case bgez_op:
+		case bgezl_op:
+			if ((long)regs->regs[insn.i_format.rs] >= 0)
+				errepc = errepc + 4 + (insn.i_format.simmediate << 2);
+			else
+				errepc += 8;
+			break;
+
+		case bltzal_op:
+		case bltzall_op:
+			regs->regs[31] = errepc + 8;
+			if ((long)regs->regs[insn.i_format.rs] < 0)
+				errepc = errepc + 4 + (insn.i_format.simmediate << 2);
+			else
+				errepc += 8;
+			break;
+
+		case bgezal_op:
+		case bgezall_op:
+			regs->regs[31] = errepc + 8;
+			if ((long)regs->regs[insn.i_format.rs] >= 0)
+				errepc = errepc + 4 + (insn.i_format.simmediate << 2);
+			else
+				errepc += 8;
+			break;
+		case bposge32_op:
+			if (!cpu_has_dsp)  return -10;
+
+			dspcontrol = rddsp(0x01);
+
+			if (dspcontrol >= 32) {
+				errepc = errepc + 4 + (insn.i_format.simmediate << 2);
+			} else
+				errepc += 8;
+			break;
+		}
+		break;
+
+	/*
+	 * These are unconditional and in j_format.
+	 */
+	case jal_op:
+		regs->regs[31] = errepc + 8;
+	case j_op:
+		errepc += 4;
+		errepc >>= 28;
+		errepc <<= 28;
+		errepc |= (insn.j_format.target << 2);
+		break;
+
+	/*
+	 * These are conditional and in i_format.
+	 */
+	case beq_op:
+	case beql_op:
+		if (regs->regs[insn.i_format.rs] ==
+		    regs->regs[insn.i_format.rt])
+			errepc = errepc + 4 + (insn.i_format.simmediate << 2);
+		else
+			errepc += 8;
+		break;
+
+	case bne_op:
+	case bnel_op:
+		if (regs->regs[insn.i_format.rs] !=
+		    regs->regs[insn.i_format.rt])
+			errepc = errepc + 4 + (insn.i_format.simmediate << 2);
+		else
+			errepc += 8;
+		break;
+
+	case blez_op: /* not really i_format */
+	case blezl_op:
+		/* rt field assumed to be zero */
+		if ((long)regs->regs[insn.i_format.rs] <= 0)
+			errepc = errepc + 4 + (insn.i_format.simmediate << 2);
+		else
+			errepc += 8;
+		break;
+
+	case bgtz_op:
+	case bgtzl_op:
+		/* rt field assumed to be zero */
+		if ((long)regs->regs[insn.i_format.rs] > 0)
+			errepc = errepc + 4 + (insn.i_format.simmediate << 2);
+		else
+			errepc += 8;
+		break;
+
+	/*
+	 * And now the FPA/cp1 branch instructions.
+	 */
+	case cop1_op:
+		if (is_fpu_owner())
+			asm volatile("cfc1\t%0,$31" : "=r" (fcr31));
+		else
+			fcr31 = current->thread.fpu.fcr31;
+
+		bit = (insn.i_format.rt >> 2);
+		bit += (bit != 0);
+		bit += 23;
+		switch (insn.i_format.rt & 3) {
+		case 0:	/* bc1f */
+		case 2:	/* bc1fl */
+			if (~fcr31 & (1 << bit))
+				errepc = errepc + 4 + (insn.i_format.simmediate << 2);
+			else
+				errepc += 8;
+			break;
+
+		case 1:	/* bc1t */
+		case 3:	/* bc1tl */
+			if (fcr31 & (1 << bit))
+				errepc = errepc + 4 + (insn.i_format.simmediate << 2);
+			else
+				errepc += 8;
+			break;
+		}
+		break;
+	default:
+		errepc += 4;
+	}
 
-	cerr_cpu_halt();
+	*pErrepc = errepc;
+	return 0;
 }
diff --git a/arch/mips/mm/cex-gen.S b/arch/mips/mm/cex-gen.S
index 5dc41a4..71695b1 100644
--- a/arch/mips/mm/cex-gen.S
+++ b/arch/mips/mm/cex-gen.S
@@ -1,3 +1,12 @@
+/*-
+ * Copyright 2003-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
+
 /*
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
@@ -5,7 +14,6 @@
  *
  * Copyright (C) 1995 - 1999 Ralf Baechle
  * Copyright (C) 1999 Silicon Graphics, Inc.
- * Copyright (C) 2003-2010 Netlogic Microsystems Inc.
  *
  * Cache error handler
  */
@@ -13,50 +21,198 @@
 #include <asm/regdef.h>
 #include <asm/mipsregs.h>
 #include <asm/stackframe.h>
+#include <asm/asm-offsets.h>
+#include <asm/netlogic/mips-exts.h>
 
 /*
  * Game over.  Go to the button.  Press gently.  Swear where allowed by
  * legislation.
  */
-	LEAF(except_vec2_generic)
-	.set	noreorder
-	.set	noat
-	.set    mips0
+LEAF( cache_save_regs )
+	.set push
+	.set mips64
+	.set noat
+	.set noreorder
+
+	LONG_S  $1 , PT_R1 (sp)
+	LONG_S  $2 , PT_R2 (sp)
+	LONG_S  $3 , PT_R3 (sp)
+	LONG_S  $4 , PT_R4 (sp)
+	LONG_S  $5 , PT_R5 (sp)
+	LONG_S  $6 , PT_R6 (sp)
+	LONG_S  $7 , PT_R7 (sp)
+	LONG_S  $8 , PT_R8 (sp)
+	LONG_S  $9 , PT_R9 (sp)
+	LONG_S  $10, PT_R10(sp)
+	LONG_S  $11, PT_R11(sp)
+	LONG_S  $12, PT_R12(sp)
+	LONG_S  $13, PT_R13(sp)
+	LONG_S  $14, PT_R14(sp)
+	LONG_S  $15, PT_R15(sp)
+	LONG_S  $16, PT_R16(sp)
+	LONG_S  $17, PT_R17(sp)
+	LONG_S  $18, PT_R18(sp)
+	LONG_S  $19, PT_R19(sp)
+	LONG_S  $20, PT_R20(sp)
+	LONG_S  $21, PT_R21(sp)
+	LONG_S  $22, PT_R22(sp)
+	LONG_S  $23, PT_R23(sp)
+	LONG_S  $24, PT_R24(sp)
+	LONG_S  $25, PT_R25(sp)
+	LONG_S  $26, PT_R26(sp)
+	LONG_S  $27, PT_R27(sp)
+	LONG_S  $28, PT_R28(sp)
+	LONG_S  $29, PT_R29(sp)
+	LONG_S  $30, PT_R30(sp)
+
+	j   ra
+	nop
+	.set pop
+END(cache_save_regs)
+
+LEAF(cache_restore_regs)
+	.set push
+	.set mips64
+	.set noat
+	.set noreorder
+
+	LONG_L  $1 , PT_R1 (sp)
+	LONG_L  $2 , PT_R2 (sp)
+	LONG_L  $3 , PT_R3 (sp)
+	LONG_L  $4 , PT_R4 (sp)
+	LONG_L  $5 , PT_R5 (sp)
+	LONG_L  $6 , PT_R6 (sp)
+	LONG_L  $7 , PT_R7 (sp)
+	LONG_L  $8 , PT_R8 (sp)
+	LONG_L  $9 , PT_R9 (sp)
+	LONG_L  $10, PT_R10(sp)
+	LONG_L  $11, PT_R11(sp)
+	LONG_L  $12, PT_R12(sp)
+	LONG_L  $13, PT_R13(sp)
+	LONG_L  $14, PT_R14(sp)
+	LONG_L  $15, PT_R15(sp)
+	LONG_L  $16, PT_R16(sp)
+	LONG_L  $17, PT_R17(sp)
+	LONG_L  $18, PT_R18(sp)
+	LONG_L  $19, PT_R19(sp)
+	LONG_L  $20, PT_R20(sp)
+	LONG_L  $21, PT_R21(sp)
+	LONG_L  $22, PT_R22(sp)
+	LONG_L  $23, PT_R23(sp)
+	LONG_L  $24, PT_R24(sp)
+	LONG_L  $25, PT_R25(sp)
+	LONG_L  $26, PT_R26(sp)
+	LONG_L  $27, PT_R27(sp)
+	LONG_L  $28, PT_R28(sp)
+	LONG_L  $29, PT_R29(sp)
+	LONG_L  $30, PT_R30(sp)
+
+	j ra
+	nop
+	.set pop
+END(cache_restore_regs)
+
+LEAF(except_vec2_generic)
+	.set push
+	.set noreorder
+	.set noat
+	.set mips64r2
+
+	ehb
+
+	MTC0      k0, CP0_DIAGNOSTIC, 3
+	MTC0      k1, CP0_DIAGNOSTIC, 4
+
+	/*If some other cpu is already in the handler just wait... */
+	PTR_LA    k0, nlm_cerr_lock
+1:	lw        k1, 0(k0)
+	bnez      k1, 1b
+	nop
+	li        k1, 1
+	sw        k1, 0(k0)
+
+	/*save: sp, ra */
+	PTR_LA    k0, nlm_cerr_stack
+	PTR_ADDU  k0, k0, 0x2000
+	LONG_S    sp, -1*8(k0)
+	LONG_S    ra, -2*8(k0)
+
+	PTR_LA    k1, except_vec2_generic_body
+	jal       k1
+	nop
+
+	/*recover: sp,ra*/
+	PTR_LA    k0, nlm_cerr_stack
+	PTR_ADDU  k0, k0, 0x2000
+	LONG_L    sp, -1*8(k0)
+	LONG_L    ra, -2*8(k0)
+
+	PTR_LA    k0, nlm_cerr_lock
+	li        k1, 0
+	sw        k1, 0(k0)
+
+	MFC0      k0, CP0_DIAGNOSTIC, 3
+	MFC0      k1, CP0_DIAGNOSTIC, 4
+	eret
+	nop
+	.set pop
+END(except_vec2_generic)
+
+LEAF(except_vec2_generic_body)
+	.set push
+	.set noreorder
+	.set noat
+	.set mips64r2
 	/*
 	 * This is a very bad place to be.  Our cache error
 	 * detection has triggered.  If we have write-back data
 	 * in the cache, we may not be able to recover.  As a
 	 * first-order desperate measure, turn off KSEG0 cacheing.
 	 */
-	mfc0	k0,CP0_CONFIG
-	li	k1,~CONF_CM_CMASK
-	and	k0,k0,k1
-	ori	k0,k0,CONF_CM_UNCACHED
-	mtc0	k0,CP0_CONFIG
-	/* Give it a few cycles to sink in... */
-	nop
-	nop
+
+	mfc0    k0, CP0_CONFIG
+	move    sp, k0
+	li      k1,~CONF_CM_CMASK
+	and     k0,k0,k1
+	ori     k0,k0,CONF_CM_UNCACHED
+	mtc0    k0,CP0_CONFIG
+	ehb
+
+#ifndef CONFIG_NLM_COMMON
+
+	/* cache_parity_error will not return */
+	j     cache_parity_error
 	nop
-#ifdef CONFIG_NLM_COMMON
+#else
+	PTR_LA    k0, nlm_cerr_stack
+	PTR_ADDU  k0, k0, 0x2000
+	MFC0      k1, CP0_ERROREPC
+	LONG_S    k1, -3*8(k0)
+	LONG_S    ra, -4*8(k0)
+	LONG_S    sp, -5*8(k0) /*save CP0_CONFIG*/
+	PTR_ADDU  sp, k0, -40*8
 
-	/* If some other cpu is already in the handler
-	 * just wait... */
-	PTR_LA	k0, nlm_cerr_lock
-1:	lw	k1, 0(k0)
-	bnez	k1, 1b
+	jal   cache_save_regs
 	nop
 
-	/* switch stack to a new one */
-	PTR_LA		sp, nlm_cerr_stack
-	li		k1, 8192 - 64
-	PTR_ADDU	sp, sp, k1
+	jal   nlm_cache_error
+	nop
 
-	jal	nlm_cache_error
+	jal   cache_restore_regs
 	nop
-	/* should never get here */
 
-#else
-	j	cache_parity_error
+	PTR_LA    k0, nlm_cerr_stack
+	PTR_ADDU  k0, k0, 0x2000
+	LONG_L    ra, -4*8(k0)
+	LONG_L    k1, -5*8(k0) /*save CP0_CONFIG*/
+	mtc0      k1, CP0_CONFIG
+	LONG_L    k1, -3*8(k0)
+	MTC0      k1, CP0_ERROREPC
+	ehb
+
+	j     ra
 	nop
 #endif
-	END(except_vec2_generic)
+
+	.set pop
+END(except_vec2_generic_body)
diff --git a/arch/mips/mm/dma-default.c b/arch/mips/mm/dma-default.c
index 0d46ae9..5971227 100644
--- a/arch/mips/mm/dma-default.c
+++ b/arch/mips/mm/dma-default.c
@@ -1,3 +1,11 @@
+/*-
+ * Copyright 2006-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
 /*
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
@@ -14,7 +22,6 @@
 #include <linux/module.h>
 #include <linux/scatterlist.h>
 #include <linux/string.h>
-#include <linux/gfp.h>
 
 #include <asm/cache.h>
 #include <asm/io.h>
@@ -52,14 +59,6 @@ static gfp_t massage_gfp_flags(const struct device *dev, gfp_t gfp)
 		gfp |= __GFP_DMA;
 	else if (dev->coherent_dma_mask < DMA_BIT_MASK(24))
 		gfp |= __GFP_DMA;
-#ifdef CONFIG_NLM_XLP
-	/*
-	 * Enable XLP workaround for >2GB RAM, force buffer to be allocated in
-	 * DMA Zone(0 ~ 2GB defined in arch/mips/include/asm/dma.h)
-	 */
-	else if (dev->coherent_dma_mask < DMA_BIT_MASK(32))
-		gfp |= __GFP_DMA;
-#endif
 	else
 #endif
 #ifdef CONFIG_ZONE_DMA32
@@ -82,6 +81,11 @@ void *dma_alloc_noncoherent(struct device *dev, size_t size,
 
 	gfp = massage_gfp_flags(dev, gfp);
 
+
+#if defined (CONFIG_NLM_COMMON) && defined (CONFIG_64BIT)
+	/* force allocations to happen in DMA zone */
+	gfp |= __GFP_DMA;
+#endif
 	ret = (void *) __get_free_pages(gfp, get_order(size));
 
 	if (ret != NULL) {
@@ -104,6 +108,10 @@ void *dma_alloc_coherent(struct device *dev, size_t size,
 
 	gfp = massage_gfp_flags(dev, gfp);
 
+#if defined (CONFIG_NLM_COMMON) && defined (CONFIG_64BIT)
+	/* force allocations to happen in DMA zone */
+	gfp |= __GFP_DMA;
+#endif
 	ret = (void *) __get_free_pages(gfp, get_order(size));
 
 	if (ret) {
@@ -195,6 +203,7 @@ void dma_unmap_single(struct device *dev, dma_addr_t dma_addr, size_t size,
 
 EXPORT_SYMBOL(dma_unmap_single);
 
+#ifndef CONFIG_NLM_COMMON
 int dma_map_sg(struct device *dev, struct scatterlist *sg, int nents,
 	enum dma_data_direction direction)
 {
@@ -214,6 +223,23 @@ int dma_map_sg(struct device *dev, struct scatterlist *sg, int nents,
 
 	return nents;
 }
+#else
+int dma_map_sg(struct device *dev, struct scatterlist *sg, int nents,
+	enum dma_data_direction direction)
+{
+	int i;
+
+	BUG_ON(direction == DMA_NONE);
+
+	for (i = 0; i < nents; i++, sg++) {
+		sg->dma_address = dma_map_page(dev, sg_page(sg), sg->offset, 
+						sg->length, direction); 
+	}
+
+	return nents;
+}
+
+#endif
 
 EXPORT_SYMBOL(dma_map_sg);
 
diff --git a/arch/mips/mm/fault.c b/arch/mips/mm/fault.c
index 5a11bb6..aee1bc6 100644
--- a/arch/mips/mm/fault.c
+++ b/arch/mips/mm/fault.c
@@ -1,3 +1,12 @@
+/*-
+ * Copyright 2003-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
+
 /*
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
@@ -31,6 +40,10 @@
 #include <asm/netlogic/sim.h>
 #include <asm/mach-netlogic/xlp-mmu.h>
 #include <asm/mach-netlogic/mmu.h>
+#ifdef CONFIG_NLM_16G_MEM_SUPPORT
+#define ENTER_CRITICAL(flags) local_irq_save(flags)
+#define EXIT_CRITICAL(flags) local_irq_restore(flags)
+#endif
 
 DEFINE_TRACE(page_fault_entry);
 DEFINE_TRACE(page_fault_exit);
@@ -58,9 +71,26 @@ void pax_report_insns(void *pc, void *sp)
  * and the problem, and then passes it off to one of the appropriate
  * routines.
  */
+
+static inline char *access_violation(int code)
+{
+	switch (code) {
+	case 0: return "read access from";
+		break;
+	case 1: return "write access to";
+		break;
+	case 2: return "read-exec";
+		break;
+	default: return "unknown";
+		break;
+	}
+}
+
 #ifdef CONFIG_NLM_16G_MEM_SUPPORT
-#define ENTER_CRITICAL(flags) local_irq_save(flags)
-#define EXIT_CRITICAL(flags) local_irq_restore(flags)
+extern void dump_pgtable(pgd_t *pgd);
+extern void print_pgtable(unsigned long, unsigned long);
+
+extern unsigned long NONWIRED_START, NONWIRED_END;
 
 static void update_kernel_tlb(unsigned long address)
 {
@@ -106,12 +136,6 @@ asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long write,
 	siginfo_t info;
 	int fault;
 
-#if 0
-	printk("Cpu%d[%s:%d:%0*lx:%ld:%0*lx]\n", raw_smp_processor_id(),
-	       current->comm, current->pid, field, address, write,
-	       field, regs->cp0_epc);
-#endif
-
 	info.si_code = SEGV_MAPERR;
 
 	/*
@@ -169,31 +193,8 @@ good_area:
 		if (!(vma->vm_flags & VM_WRITE))
 			goto bad_area;
 	} else {
-		if (kernel_uses_smartmips_rixi) {
-			if (address == regs->cp0_epc && !(vma->vm_flags & VM_EXEC)) {
-#if 0
-				pr_notice("Cpu%d[%s:%d:%0*lx:%ld:%0*lx] XI violation\n",
-					  raw_smp_processor_id(),
-					  current->comm, current->pid,
-					  field, address, write,
-					  field, regs->cp0_epc);
-#endif
-				goto bad_area;
-			}
-			if (!(vma->vm_flags & VM_READ)) {
-#if 0
-				pr_notice("Cpu%d[%s:%d:%0*lx:%ld:%0*lx] RI violation\n",
-					  raw_smp_processor_id(),
-					  current->comm, current->pid,
-					  field, address, write,
-					  field, regs->cp0_epc);
-#endif
-				goto bad_area;
-			}
-		} else {
-			if (!(vma->vm_flags & (VM_READ | VM_WRITE | VM_EXEC)))
-				goto bad_area;
-		}
+		if (!(vma->vm_flags & (VM_READ | VM_WRITE | VM_EXEC)))
+			goto bad_area;
 	}
 
 	/*
@@ -238,15 +239,6 @@ bad_area_nosemaphore:
 	if (user_mode(regs)) {
 		tsk->thread.cp0_badvaddr = address;
 		tsk->thread.error_code = write;
-#if 0
-		printk("do_page_fault() #2: sending SIGSEGV to %s for "
-		       "invalid %s\n%0*lx (epc == %0*lx, ra == %0*lx)\n",
-		       tsk->comm,
-		       write ? "write access to" : "read access from",
-		       field, address,
-		       field, (unsigned long) regs->cp0_epc,
-		       field, (unsigned long) regs->regs[31]);
-#endif
 		info.si_signo = SIGSEGV;
 		info.si_errno = 0;
 		/* info.si_code has been set above */
@@ -294,15 +286,6 @@ do_sigbus:
 	 * Send a sigbus, regardless of whether we were in kernel
 	 * or user mode.
 	 */
-#if 0
-		printk("do_page_fault() #3: sending SIGBUS to %s for "
-		       "invalid %s\n%0*lx (epc == %0*lx, ra == %0*lx)\n",
-		       tsk->comm,
-		       write ? "write access to" : "read access from",
-		       field, address,
-		       field, (unsigned long) regs->cp0_epc,
-		       field, (unsigned long) regs->regs[31]);
-#endif
 	tsk->thread.cp0_badvaddr = address;
 	info.si_signo = SIGBUS;
 	info.si_errno = 0;
diff --git a/arch/mips/mm/page.c b/arch/mips/mm/page.c
index 36272f7..f5c7375 100644
--- a/arch/mips/mm/page.c
+++ b/arch/mips/mm/page.c
@@ -35,7 +35,7 @@
 #include <asm/sibyte/sb1250_dma.h>
 #endif
 
-#include <asm/uasm.h>
+#include "uasm.h"
 
 /* Registers used in the assembled routines. */
 #define ZERO 0
diff --git a/arch/mips/mm/pgtable-64.c b/arch/mips/mm/pgtable-64.c
index 78eaa4f..4883154 100644
--- a/arch/mips/mm/pgtable-64.c
+++ b/arch/mips/mm/pgtable-64.c
@@ -1,3 +1,11 @@
+/*-
+ * Copyright 2003-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
 /*
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
@@ -15,31 +23,23 @@
 void pgd_init(unsigned long page)
 {
 	unsigned long *p, *end;
-	unsigned long entry;
-
-#ifdef __PAGETABLE_PMD_FOLDED
-	entry = (unsigned long)invalid_pte_table;
-#else
-	entry = (unsigned long)invalid_pmd_table;
-#endif
 
  	p = (unsigned long *) page;
 	end = p + PTRS_PER_PGD;
 
 	while (p < end) {
-		p[0] = entry;
-		p[1] = entry;
-		p[2] = entry;
-		p[3] = entry;
-		p[4] = entry;
-		p[5] = entry;
-		p[6] = entry;
-		p[7] = entry;
+		p[0] = (unsigned long) invalid_pmd_table;
+		p[1] = (unsigned long) invalid_pmd_table;
+		p[2] = (unsigned long) invalid_pmd_table;
+		p[3] = (unsigned long) invalid_pmd_table;
+		p[4] = (unsigned long) invalid_pmd_table;
+		p[5] = (unsigned long) invalid_pmd_table;
+		p[6] = (unsigned long) invalid_pmd_table;
+		p[7] = (unsigned long) invalid_pmd_table;
 		p += 8;
 	}
 }
 
-#ifndef __PAGETABLE_PMD_FOLDED
 void pmd_init(unsigned long addr, unsigned long pagetable)
 {
 	unsigned long *p, *end;
@@ -48,33 +48,51 @@ void pmd_init(unsigned long addr, unsigned long pagetable)
 	end = p + PTRS_PER_PMD;
 
 	while (p < end) {
-		p[0] = pagetable;
-		p[1] = pagetable;
-		p[2] = pagetable;
-		p[3] = pagetable;
-		p[4] = pagetable;
-		p[5] = pagetable;
-		p[6] = pagetable;
-		p[7] = pagetable;
+		p[0] = (unsigned long)pagetable;
+		p[1] = (unsigned long)pagetable;
+		p[2] = (unsigned long)pagetable;
+		p[3] = (unsigned long)pagetable;
+		p[4] = (unsigned long)pagetable;
+		p[5] = (unsigned long)pagetable;
+		p[6] = (unsigned long)pagetable;
+		p[7] = (unsigned long)pagetable;
 		p += 8;
 	}
 }
-#endif
 
 void __init pagetable_init(void)
 {
 	unsigned long vaddr;
 	pgd_t *pgd_base;
+#ifdef CONFIG_HIGHMEM
+        pgd_t *pgd;
+        pud_t *pud;
+        pmd_t *pmd;
+        pte_t *pte;
+#endif
 
 	/* Initialize the entire pgd.  */
 	pgd_init((unsigned long)swapper_pg_dir);
-#ifndef __PAGETABLE_PMD_FOLDED
 	pmd_init((unsigned long)invalid_pmd_table, (unsigned long)invalid_pte_table);
-#endif
+
 	pgd_base = swapper_pg_dir;
 	/*
 	 * Fixed mappings:
 	 */
 	vaddr = __fix_to_virt(__end_of_fixed_addresses - 1) & PMD_MASK;
 	fixrange_init(vaddr, 0, pgd_base);
+
+#ifdef CONFIG_HIGHMEM
+        /*
+         * Permanent kmaps:
+         */
+        vaddr = PKMAP_BASE;
+        fixrange_init(vaddr, vaddr + PAGE_SIZE*LAST_PKMAP, pgd_base);
+
+        pgd = swapper_pg_dir + __pgd_offset(vaddr);
+        pud = pud_offset(pgd, vaddr);
+        pmd = pmd_offset(pud, vaddr);
+        pte = pte_offset_kernel(pmd, vaddr);
+        pkmap_page_table = pte;
+#endif
 }
diff --git a/arch/mips/mm/tlb-r4k.c b/arch/mips/mm/tlb-r4k.c
index 4fbeaa5..b63df27 100644
--- a/arch/mips/mm/tlb-r4k.c
+++ b/arch/mips/mm/tlb-r4k.c
@@ -1,3 +1,12 @@
+/*-
+ * Copyright 2003-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
+
 /*
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
@@ -7,7 +16,6 @@
  * Copyright (C) 1997, 1998, 1999, 2000 Ralf Baechle ralf@gnu.org
  * Carsten Langgaard, carstenl@mips.com
  * Copyright (C) 2002 MIPS Technologies, Inc.  All rights reserved.
- * Copyright (C) 2003-2010 Netlogic Microsystems Inc.
  */
 #include <linux/init.h>
 #include <linux/sched.h>
@@ -77,15 +85,19 @@ extern void build_tlb_refill_handler(void);
 
 #endif
 
+#ifdef CONFIG_NLM_VMIPS
+#define UNIQUE_VMIPS_ENTRYHI(idx)  ((1ULL << 63) + (1ULL << 40) + ((idx) << (PAGE_SHIFT + 1)) + ( 1 << 8))
+extern int nlm_vmips_max_wired_entries;
+#endif
+
 void local_flush_tlb_all(void)
 {
-	unsigned long flags;
-	unsigned long __maybe_unused pflags;
+	unsigned long flags, config6_flags;
 	unsigned long old_ctx;
 	int entry;
 
 	ENTER_CRITICAL(flags);
-	disable_pgwalker(pflags);
+	disable_pgwalker(config6_flags);
 	/* Save old context and create impossible VPN2 value */
 	old_ctx = read_c0_entryhi();
 	write_c0_entrylo0(0);
@@ -93,10 +105,18 @@ void local_flush_tlb_all(void)
 
 	entry = read_c0_wired();
 
+#if defined(CONFIG_MAPPED_KERNEL)
+	if (!entry) printk("[%s] flushing entry=%d in MAPPED_KERNEL mode!\n",
+			   __FUNCTION__, entry);
+#endif
 	/* Blast 'em all away. */
 	while (entry < current_cpu_data.tlbsize) {
 		/* Make sure all entries differ. */
+#ifndef CONFIG_NLM_VMIPS
 		write_c0_entryhi(UNIQUE_ENTRYHI(entry));
+#else
+        __write_64bit_c0_register($10, 0, (UNIQUE_VMIPS_ENTRYHI(entry)));
+#endif
 		write_c0_index(entry);
 		mtc0_tlbw_hazard();
 		tlb_write_indexed();
@@ -105,7 +125,7 @@ void local_flush_tlb_all(void)
 	tlbw_use_hazard();
 	write_c0_entryhi(old_ctx);
 	FLUSH_ITLB;
-	enable_pgwalker(pflags);
+	enable_pgwalker(config6_flags);
 	EXIT_CRITICAL(flags);
 }
 
@@ -114,17 +134,17 @@ void local_flush_tlb_all(void)
 void local_flush_tlb_mm(struct mm_struct *mm)
 {
 	int cpu;
-	unsigned long __maybe_unused pflags;
+	unsigned long config6_flags;
 
 	preempt_disable();
 
 	cpu = smp_processor_id();
 
-	disable_pgwalker(pflags);
+	disable_pgwalker(config6_flags);
 	if (cpu_context(cpu, mm) != 0) {
 		drop_mmu_context(mm, cpu);
 	}
-	enable_pgwalker(pflags);
+	enable_pgwalker(config6_flags);
 	preempt_enable();
 }
 
@@ -136,10 +156,10 @@ void local_flush_tlb_range(struct vm_area_struct *vma, unsigned long start,
 
 	if (cpu_context(cpu, mm) != 0) {
 		unsigned long size, flags;
-		unsigned long __maybe_unused pflags;
+		unsigned long config6_flags;
 
 		ENTER_CRITICAL(flags);
-		disable_pgwalker(pflags);
+		disable_pgwalker(config6_flags);
 		size = (end - start + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
 		size = (size + 1) >> 1;
 		if (size <= current_cpu_data.tlbsize/2) {
@@ -163,7 +183,11 @@ void local_flush_tlb_range(struct vm_area_struct *vma, unsigned long start,
 				if (idx < 0)
 					continue;
 				/* Make sure all entries differ. */
+#ifndef CONFIG_NLM_VMIPS
 				write_c0_entryhi(UNIQUE_ENTRYHI(idx));
+#else
+				__write_64bit_c0_register($10, 0, (UNIQUE_VMIPS_ENTRYHI(idx)));
+#endif
 				mtc0_tlbw_hazard();
 				tlb_write_indexed();
 			}
@@ -173,7 +197,7 @@ void local_flush_tlb_range(struct vm_area_struct *vma, unsigned long start,
 			drop_mmu_context(mm, cpu);
 		}
 		FLUSH_ITLB;
-		enable_pgwalker(pflags);
+		enable_pgwalker(config6_flags);
 		EXIT_CRITICAL(flags);
 	}
 }
@@ -181,10 +205,10 @@ void local_flush_tlb_range(struct vm_area_struct *vma, unsigned long start,
 void local_flush_tlb_kernel_range(unsigned long start, unsigned long end)
 {
 	unsigned long size, flags;
-	unsigned long __maybe_unused pflags;
+	unsigned long config6_flags;
 
 	ENTER_CRITICAL(flags);
-	disable_pgwalker(pflags);
+	disable_pgwalker(config6_flags);
 	size = (end - start + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
 	size = (size + 1) >> 1;
 	if (size <= current_cpu_data.tlbsize / 2) {
@@ -208,7 +232,11 @@ void local_flush_tlb_kernel_range(unsigned long start, unsigned long end)
 			if (idx < 0)
 				continue;
 			/* Make sure all entries differ. */
+#ifndef CONFIG_NLM_VMIPS
 			write_c0_entryhi(UNIQUE_ENTRYHI(idx));
+#else
+			__write_64bit_c0_register($10, 0, (UNIQUE_VMIPS_ENTRYHI(idx)));
+#endif
 			mtc0_tlbw_hazard();
 			tlb_write_indexed();
 		}
@@ -218,7 +246,7 @@ void local_flush_tlb_kernel_range(unsigned long start, unsigned long end)
 		local_flush_tlb_all();
 	}
 	FLUSH_ITLB;
-	enable_pgwalker(pflags);
+	enable_pgwalker(config6_flags);
 	EXIT_CRITICAL(flags);
 }
 
@@ -227,14 +255,13 @@ void local_flush_tlb_page(struct vm_area_struct *vma, unsigned long page)
 	int cpu = smp_processor_id();
 
 	if (cpu_context(cpu, vma->vm_mm) != 0) {
-		unsigned long flags;
-		unsigned long __maybe_unused pflags;
+		unsigned long flags, config6_flags;
 		int oldpid, newpid, idx;
 
 		newpid = cpu_asid(cpu, vma->vm_mm);
 		page &= (PAGE_MASK << 1);
 		ENTER_CRITICAL(flags);
-		disable_pgwalker(pflags);
+		disable_pgwalker(config6_flags);
 		oldpid = read_c0_entryhi();
 		write_c0_entryhi(page | newpid);
 		mtc0_tlbw_hazard();
@@ -246,7 +273,11 @@ void local_flush_tlb_page(struct vm_area_struct *vma, unsigned long page)
 		if (idx < 0)
 			goto finish;
 		/* Make sure all entries differ. */
+#ifndef CONFIG_NLM_VMIPS
 		write_c0_entryhi(UNIQUE_ENTRYHI(idx));
+#else
+		__write_64bit_c0_register($10, 0, (UNIQUE_VMIPS_ENTRYHI(idx)));
+#endif
 		mtc0_tlbw_hazard();
 		tlb_write_indexed();
 		tlbw_use_hazard();
@@ -254,7 +285,7 @@ void local_flush_tlb_page(struct vm_area_struct *vma, unsigned long page)
 	finish:
 		write_c0_entryhi(oldpid);
 		FLUSH_ITLB_VM(vma);
-		enable_pgwalker(pflags);
+		enable_pgwalker(config6_flags);
 		EXIT_CRITICAL(flags);
 	}
 }
@@ -291,12 +322,11 @@ asmlinkage void do_hugetlb_invalidate(void)
  */
 void local_flush_tlb_one(unsigned long page)
 {
-	unsigned long flags;
-	unsigned long __maybe_unused pflags;
+	unsigned long flags, config6_flags;
 	int oldpid, idx;
 
 	ENTER_CRITICAL(flags);
-	disable_pgwalker(pflags);
+	disable_pgwalker(config6_flags);
 	oldpid = read_c0_entryhi();
 	page &= (PAGE_MASK << 1);
 	write_c0_entryhi(page);
@@ -308,14 +338,18 @@ void local_flush_tlb_one(unsigned long page)
 	write_c0_entrylo1(0);
 	if (idx >= 0) {
 		/* Make sure all entries differ. */
+#ifndef CONFIG_NLM_VMIPS
 		write_c0_entryhi(UNIQUE_ENTRYHI(idx));
+#else
+		__write_64bit_c0_register($10, 0, (UNIQUE_VMIPS_ENTRYHI(idx)));
+#endif
 		mtc0_tlbw_hazard();
 		tlb_write_indexed();
 		tlbw_use_hazard();
 	}
 	write_c0_entryhi(oldpid);
 	FLUSH_ITLB;
-	enable_pgwalker(pflags);
+	enable_pgwalker(config6_flags);
 	EXIT_CRITICAL(flags);
 }
 
@@ -332,7 +366,7 @@ void __update_tlb(struct vm_area_struct * vma, unsigned long address, pte_t pte)
 	pmd_t *pmdp;
 	pte_t *ptep;
 	int idx, pid;
-	unsigned long __maybe_unused pflags;
+	unsigned long config6_flags;
 
 	/*
 	 * Handle debugger faulting in for debugee.
@@ -341,7 +375,7 @@ void __update_tlb(struct vm_area_struct * vma, unsigned long address, pte_t pte)
 		return;
 
 	ENTER_CRITICAL(flags);
-	disable_pgwalker(pflags);
+	disable_pgwalker(config6_flags);
 
 	pid = read_c0_entryhi() & ASID_MASK;
 	address &= (PAGE_MASK << 1);
@@ -398,10 +432,44 @@ void __update_tlb(struct vm_area_struct * vma, unsigned long address, pte_t pte)
 	}
 	tlbw_use_hazard();
 	FLUSH_ITLB_VM(vma);
-	enable_pgwalker(pflags);
+	enable_pgwalker(config6_flags);
 	EXIT_CRITICAL(flags);
 }
 
+#if 0
+static void r4k_update_mmu_cache_hwbug(struct vm_area_struct * vma,
+				       unsigned long address, pte_t pte)
+{
+	unsigned long flags;
+	unsigned int asid;
+	pgd_t *pgdp;
+	pmd_t *pmdp;
+	pte_t *ptep;
+	int idx;
+
+	ENTER_CRITICAL(flags);
+	address &= (PAGE_MASK << 1);
+	asid = read_c0_entryhi() & ASID_MASK;
+	write_c0_entryhi(address | asid);
+	pgdp = pgd_offset(vma->vm_mm, address);
+	mtc0_tlbw_hazard();
+	tlb_probe();
+	tlb_probe_hazard();
+	pmdp = pmd_offset(pgdp, address);
+	idx = read_c0_index();
+	ptep = pte_offset_map(pmdp, address);
+	write_c0_entrylo0(pte_val(*ptep++) >> 6);
+	write_c0_entrylo1(pte_val(*ptep) >> 6);
+	mtc0_tlbw_hazard();
+	if (idx < 0)
+		tlb_write_random();
+	else
+		tlb_write_indexed();
+	tlbw_use_hazard();
+	EXIT_CRITICAL(flags);
+}
+#endif
+
 void __init add_wired_entry(unsigned long entrylo0, unsigned long entrylo1,
 	unsigned long entryhi, unsigned long pagemask)
 {
@@ -409,10 +477,10 @@ void __init add_wired_entry(unsigned long entrylo0, unsigned long entrylo1,
 	unsigned long wired;
 	unsigned long old_pagemask;
 	unsigned long old_ctx;
-	unsigned long __maybe_unused pflags;
+	unsigned long config6_flags;
 
 	ENTER_CRITICAL(flags);
-	disable_pgwalker(pflags);
+	disable_pgwalker(config6_flags);
 	/* Save old context and create impossible VPN2 value */
 	old_ctx = read_c0_entryhi();
 	old_pagemask = read_c0_pagemask();
@@ -432,7 +500,7 @@ void __init add_wired_entry(unsigned long entrylo0, unsigned long entrylo1,
 	tlbw_use_hazard();	/* What is the hazard here? */
 	write_c0_pagemask(old_pagemask);
 	local_flush_tlb_all();
-	enable_pgwalker(pflags);
+	enable_pgwalker(config6_flags);
 	EXIT_CRITICAL(flags);
 }
 
@@ -452,10 +520,10 @@ __init int add_temporary_entry(unsigned long entrylo0, unsigned long entrylo1,
 	unsigned long wired;
 	unsigned long old_pagemask;
 	unsigned long old_ctx;
-	unsigned long __maybe_unused pflags;
+	unsigned long config6_flags;
 
 	ENTER_CRITICAL(flags);
-	disable_pgwalker(pflags);
+	disable_pgwalker(config6_flags);
 	/* Save old context and create impossible VPN2 value */
 	old_ctx = read_c0_entryhi();
 	old_pagemask = read_c0_pagemask();
@@ -479,7 +547,7 @@ __init int add_temporary_entry(unsigned long entrylo0, unsigned long entrylo1,
 	write_c0_entryhi(old_ctx);
 	write_c0_pagemask(old_pagemask);
 out:
-	enable_pgwalker(pflags);
+	enable_pgwalker(config6_flags);
 	EXIT_CRITICAL(flags);
 	return ret;
 }
@@ -506,7 +574,7 @@ static void __cpuinit probe_tlb(unsigned long config)
 #endif /* CONFIG_MIPS_MT_SMTC */
 
 	reg = read_c0_config1();
-	if (!((config >> 7) & 3))
+	if (!((config >> 7) & 7))
 		panic("No TLB present");
 
 #if defined(CONFIG_NLM_XLP)
@@ -526,12 +594,14 @@ static int __init set_ntlb(char *str)
 
 __setup("ntlb=", set_ntlb);
 
-static inline void nlm_tlb_stats_init(void)
+#ifdef CONFIG_NLM_COMMON
+extern void nlm_common_tlb_init(void);
+
+void nlm_tlb_stats_init(void)
 {
-#ifdef CONFIG_NLM_TLB_STAT
 	nlm_write_os_scratch_2(0ULL);
-#endif
 }
+#endif
 
 void __cpuinit tlb_init(void)
 {
@@ -546,25 +616,33 @@ void __cpuinit tlb_init(void)
 	 */
 	probe_tlb(config);
 	write_c0_pagemask(PM_DEFAULT_MASK);
-#if !defined(CONFIG_MAPPED_KERNEL)
-	write_c0_wired(0);
+
+#if defined(CONFIG_NLM_VMIPS)
+	if(ntlb && ((current_cpu_data.tlbsize-ntlb) < nlm_vmips_max_wired_entries))
+		ntlb = current_cpu_data.tlbsize - nlm_vmips_max_wired_entries;
 #endif
+
 	if (current_cpu_type() == CPU_R10000 ||
 	    current_cpu_type() == CPU_R12000 ||
 	    current_cpu_type() == CPU_R14000)
 		write_c0_framemask(0);
 
-	if (kernel_uses_smartmips_rixi) {
-		/*
-		 * Enable the no read, no exec bits, and enable large virtual
-		 * address.
-		 */
-		u32 pg = PG_RIE | PG_XIE;
+#if !defined(CONFIG_MAPPED_KERNEL)
+	write_c0_wired(0);
+	write_c0_framemask(0);
+#endif
+
+   if (kernel_uses_smartmips_rixi) {
+       /*
+        * Enable the no read, no exec bits, and enable large virtual
+        * address.
+        */
+       u32 pg = PG_RIE | PG_XIE;
 #ifdef CONFIG_64BIT
-		pg |= PG_ELPA;
+       pg |= PG_ELPA;
 #endif
-		write_c0_pagegrain(pg);
-	}
+       write_c0_pagegrain(pg);
+   }
 
 	temp_tlb_entry = current_cpu_data.tlbsize - 1;
 
@@ -583,7 +661,9 @@ void __cpuinit tlb_init(void)
 			printk("Ignoring invalid argument ntlb=%d\n", ntlb);
 	}
 
+#ifdef CONFIG_NLM_COMMON
 	nlm_tlb_stats_init();
+#endif
 
-	build_tlb_refill_handler();
+    build_tlb_refill_handler();
 }
diff --git a/arch/mips/mm/tlbex.c b/arch/mips/mm/tlbex.c
index 0d7ee93..27b1ea7 100644
--- a/arch/mips/mm/tlbex.c
+++ b/arch/mips/mm/tlbex.c
@@ -1,3 +1,11 @@
+/*-
+ * Copyright 2009-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
 /*
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
@@ -29,16 +37,8 @@
 
 #include <asm/mmu_context.h>
 #include <asm/war.h>
-#include <asm/uasm.h>
 
-/*
- * TLB load/store/modify handlers.
- *
- * Only the fastpath gets synthesized at runtime, the slowpath for
- * do_page_fault remains normal asm.
- */
-extern void tlb_do_page_fault_0(void);
-extern void tlb_do_page_fault_1(void);
+#include "uasm.h"
 
 #ifdef CONFIG_NLM_COMMON
 #include <asm/netlogic/mips-exts.h>
@@ -168,7 +168,6 @@ static inline void dump_handler(const u32 *handler, int count)
 }
 
 /* The only general purpose registers allowed in TLB handlers. */
-#define ZERO 0
 #define K0		26
 #define K1		27
 
@@ -186,6 +185,7 @@ static inline void dump_handler(const u32 *handler, int count)
 #define C0_CONFIG6     16, 6
 #define C0_WIRED	6, 0
 
+
 #ifdef CONFIG_64BIT
 # define GET_CONTEXT(buf, reg) UASM_i_MFC0(buf, reg, C0_XCONTEXT)
 #else
@@ -210,12 +210,6 @@ static u32 tlb_handler[128] __cpuinitdata ;
 static struct uasm_label labels[128] __cpuinitdata;
 static struct uasm_reloc relocs[128] __cpuinitdata;
 
-#ifndef CONFIG_MIPS_PGD_C0_CONTEXT
-/*
- * CONFIG_MIPS_PGD_C0_CONTEXT implies 64 bit and lack of pgd_current,
- * we cannot do r3000 under these circumstances.
- */
-
 /*
  * The R3000 TLB handler is simple.
  */
@@ -255,7 +249,6 @@ static void __cpuinit build_r3000_tlb_refill_handler(void)
 
 	dump_handler((u32 *)ebase, 32);
 }
-#endif /* CONFIG_MIPS_PGD_C0_CONTEXT */
 
 /*
  * The R4000 TLB handler is much more complicated. We have two
@@ -458,7 +451,7 @@ static void __cpuinit build_tlb_write_entry(u32 **p, struct uasm_label **l,
 }
 
 static __cpuinit __maybe_unused void build_convert_pte_to_entrylo(u32 **p,
-								  unsigned int reg)
+                                 unsigned int reg)
 {
 	if (kernel_uses_smartmips_rixi) {
 #ifdef CONFIG_NLM_XLP
@@ -473,7 +466,7 @@ static __cpuinit __maybe_unused void build_convert_pte_to_entrylo(u32 **p,
 #endif
 	} else {
 #ifdef CONFIG_64BIT_PHYS_ADDR
-		uasm_i_dsrl_safe(p, reg, reg, ilog2(_PAGE_GLOBAL));
+		uasm_i_dsrl(p, reg, reg, ilog2(_PAGE_GLOBAL));
 #else
 		UASM_i_SRL(p, reg, reg, ilog2(_PAGE_GLOBAL));
 #endif
@@ -483,9 +476,9 @@ static __cpuinit __maybe_unused void build_convert_pte_to_entrylo(u32 **p,
 #ifdef CONFIG_HUGETLB_PAGE
 
 static __cpuinit void build_restore_pagemask(u32 **p,
-					     struct uasm_reloc **r,
-					     unsigned int tmp,
-					     enum label_id lid)
+                        struct uasm_reloc **r,
+                        unsigned int tmp,
+                        enum label_id lid)
 {
 	/* Reset default page size */
 	if (PM_DEFAULT_MASK >> 16) {
@@ -517,6 +510,7 @@ static __cpuinit void build_huge_tlb_write_entry(u32 **p,
 	build_tlb_write_entry(p, l, r, wmode);
 
 	build_restore_pagemask(p, r, tmp, label_leave);
+
 }
 
 /*
@@ -609,9 +603,8 @@ static void __cpuinit
 build_get_pmde64(u32 **p, struct uasm_label **l, struct uasm_reloc **r,
 		 unsigned int tmp, unsigned int ptr)
 {
-#ifndef CONFIG_MIPS_PGD_C0_CONTEXT
 	long pgdc = (long)pgd_current;
-#endif
+
 	/*
 	 * The vmalloc handling is not in the hotpath.
 	 */
@@ -625,15 +618,15 @@ build_get_pmde64(u32 **p, struct uasm_label **l, struct uasm_reloc **r,
 	 * SMTC uses TCBind value as "CPU" index
 	 */
 	uasm_i_mfc0(p, ptr, C0_TCBIND);
-	uasm_i_dsrl_safe(p, ptr, ptr, 19);
+	uasm_i_dsrl(p, ptr, ptr, 19);
 # else
 	/*
 	 * 64 bit SMP running in XKPHYS has smp_processor_id() << 3
 	 * stored in CONTEXT.
 	 */
 	uasm_i_dmfc0(p, ptr, C0_CONTEXT);
-	uasm_i_dsrl_safe(p, ptr, ptr, 23);
-# endif
+	uasm_i_dsrl(p, ptr, ptr, 23);
+#endif
 	UASM_i_LA_mostly(p, tmp, pgdc);
 	uasm_i_daddu(p, ptr, ptr, tmp);
 	uasm_i_dmfc0(p, tmp, C0_BADVADDR);
@@ -652,16 +645,13 @@ build_get_pmde64(u32 **p, struct uasm_label **l, struct uasm_reloc **r,
 
 	uasm_i_andi(p, tmp, tmp, (PTRS_PER_PGD - 1)<<3);
 	uasm_i_daddu(p, ptr, ptr, tmp); /* add in pgd offset */
-#ifndef __PAGETABLE_PMD_FOLDED
 	uasm_i_dmfc0(p, tmp, C0_BADVADDR); /* get faulting address */
 	uasm_i_ld(p, ptr, 0, ptr); /* get pmd pointer */
-	uasm_i_dsrl_safe(p, tmp, tmp, PMD_SHIFT-3); /* get pmd offset in bytes */
+	uasm_i_dsrl(p, tmp, tmp, PMD_SHIFT-3); /* get pmd offset in bytes */
 	uasm_i_andi(p, tmp, tmp, (PTRS_PER_PMD - 1)<<3);
 	uasm_i_daddu(p, ptr, ptr, tmp); /* add in pmd offset */
-#endif
 }
 
-enum vmalloc64_mode {not_refill, refill};
 /*
  * BVADDR is the faulting address, PTR is scratch.
  * PTR will hold the pgd for vmalloc.
@@ -803,9 +793,9 @@ static void __cpuinit build_update_entries(u32 **p, unsigned int tmp,
 			UASM_i_ROTR(p, ptep, ptep, ilog2(_PAGE_GLOBAL) - ilog2(_PAGE_NO_EXEC));
 #endif
 		} else {
-			uasm_i_dsrl_safe(p, tmp, tmp, ilog2(_PAGE_GLOBAL)); /* convert to entrylo0 */
+			uasm_i_dsrl(p, tmp, tmp, ilog2(_PAGE_GLOBAL)); /* convert to entrylo0 */
 			UASM_i_MTC0(p, tmp, C0_ENTRYLO0); /* load it */
-			uasm_i_dsrl_safe(p, ptep, ptep, ilog2(_PAGE_GLOBAL)); /* convert to entrylo1 */
+			uasm_i_dsrl(p, ptep, ptep, ilog2(_PAGE_GLOBAL)); /* convert to entrylo1 */
 		}
 		UASM_i_MTC0(p, ptep, C0_ENTRYLO1); /* load it */
 	} else {
@@ -818,7 +808,7 @@ static void __cpuinit build_update_entries(u32 **p, unsigned int tmp,
 		uasm_i_lw(p, ptep, pte_off_odd, ptep); /* get odd pte */
 		UASM_i_MTC0(p, ptep, C0_ENTRYLO1); /* load it */
 	}
-#else
+#else /* CONFIG_64BIT_PHYS_ADDR */
 	UASM_i_LW(p, tmp, 0, ptep); /* get even pte */
 	UASM_i_LW(p, ptep, sizeof(pte_t), ptep); /* get odd pte */
 	if (r45k_bvahwbug())
@@ -841,7 +831,7 @@ static void __cpuinit build_update_entries(u32 **p, unsigned int tmp,
 		UASM_i_MTC0(p, tmp, C0_ENTRYLO0); /* load it */
 		UASM_i_ROTR(p, ptep, ptep, ilog2(_PAGE_GLOBAL) - ilog2(_PAGE_NO_EXEC));
 #endif
-	} else {
+	}else {
 		UASM_i_SRL(p, tmp, tmp, ilog2(_PAGE_GLOBAL)); /* convert to entrylo0 */
 		if (r4k_250MHZhwbug())
 			UASM_i_MTC0(p, 0, C0_ENTRYLO0);
@@ -869,10 +859,11 @@ static void __cpuinit build_r4000_tlb_refill_handler(void)
 	u32 *p = tlb_handler;
 	struct uasm_label *l = labels;
 	struct uasm_reloc *r = relocs;
-	u32 __maybe_unused *f;
 	unsigned int final_len;
 
 #if !defined(CONFIG_MAPPED_KERNEL)
+	u32 *f;
+
 	memset(final_handler, 0, sizeof(final_handler));
 #endif
 
@@ -884,23 +875,18 @@ static void __cpuinit build_r4000_tlb_refill_handler(void)
 	 * create the plain linear handler
 	 */
 	if (bcm1250_m3_war()) {
-		unsigned int segbits = 44;
-
-		uasm_i_dmfc0(&p, K0, C0_BADVADDR);
-		uasm_i_dmfc0(&p, K1, C0_ENTRYHI);
+		UASM_i_MFC0(&p, K0, C0_BADVADDR);
+		UASM_i_MFC0(&p, K1, C0_ENTRYHI);
 		uasm_i_xor(&p, K0, K0, K1);
-		uasm_i_dsrl_safe(&p, K1, K0, 62);
-		uasm_i_dsrl_safe(&p, K0, K0, 12 + 1);
-		uasm_i_dsll_safe(&p, K0, K0, 64 + 12 + 1 - segbits);
-		uasm_i_or(&p, K0, K0, K1);
+		UASM_i_SRL(&p, K0, K0, PAGE_SHIFT + 1);
 		uasm_il_bnez(&p, &r, K0, label_leave);
 		/* No need for uasm_i_nop */
 	}
 
 #ifdef CONFIG_NLM_COMMON
-	uasm_i_dmfc0(&p, K0, OS_SCRATCH_REG2);
-	uasm_i_daddiu(&p, K0, K0, 1);
-	uasm_i_dmtc0(&p, K0, OS_SCRATCH_REG2);
+        uasm_i_dmfc0(&p, K0, OS_SCRATCH_REG2);
+        uasm_i_daddiu(&p, K0, K0, 1);
+        uasm_i_dmtc0(&p, K0, OS_SCRATCH_REG2);
 #endif
 
 #ifdef CONFIG_64BIT
@@ -916,16 +902,18 @@ static void __cpuinit build_r4000_tlb_refill_handler(void)
 
 	build_update_entries(&p, K0, K1);
 	build_tlb_write_entry(&p, &l, &r, tlb_random);
+
 	uasm_l_leave(&l, p);
 	/*
 	 * FIXME: Do we need the following ifdef functionality
 	 */
 #ifdef CONFIG_NLM_COMMON
-	/* this is to avoid split of the table at eret instruction
-	 * The code below does a split at 30th instruction.
+	/* this is to avoid split of the table at eret instruction 
+	   The code below does a split at 30th instruction.
 	 */
-	if ((p - tlb_handler) == 30)
+	if((p - tlb_handler) == 30) {
 		uasm_i_nop(&p);
+	}
 #endif
 	uasm_i_eret(&p); /* return from trap */
 
@@ -933,6 +921,7 @@ static void __cpuinit build_r4000_tlb_refill_handler(void)
 	uasm_l_tlb_huge_update(&l, p);
 	UASM_i_LW(&p, K0, 0, K1);
 	build_huge_update_entries(&p, K0, K1);
+
 	build_huge_tlb_write_entry(&p, &l, &r, K0, tlb_random);
 #endif
 
@@ -1081,6 +1070,16 @@ static void __cpuinit __attribute__((unused)) build_r4000_tlb_refill_handler_stu
 #endif /* defined(CONFIG_MAPPED_KERNEL) */
 
 /*
+ * TLB load/store/modify handlers.
+ *
+ * Only the fastpath gets synthesized at runtime, the slowpath for
+ * do_page_fault remains normal asm.
+ */
+extern void tlb_do_page_fault_0(void);
+extern void tlb_do_page_fault_1(void);
+extern void tlb_do_page_fault_2(void);
+
+/*
  * 128 instructions for the fastpath handler is generous and should
  * never be exceeded.
  */
@@ -1235,7 +1234,6 @@ build_pte_modifiable(u32 **p, struct uasm_reloc **r,
 	iPTE_LW(p, pte, ptr);
 }
 
-#ifndef CONFIG_MIPS_PGD_C0_CONTEXT
 /*
  * R3000 style TLB load/store/modify handlers.
  */
@@ -1387,7 +1385,6 @@ static void __cpuinit build_r3000_tlb_modify_handler(void)
 
 	dump_handler(handle_tlbm, ARRAY_SIZE(handle_tlbm));
 }
-#endif /* CONFIG_MIPS_PGD_C0_CONTEXT */
 
 /*
  * R4000 style TLB load/store/modify handlers.
@@ -1437,6 +1434,7 @@ build_r4000_tlbchange_handler_tail(u32 **p, struct uasm_label **l,
 
 	build_tlb_write_entry(p, l, r, tlb_indexed);
 	uasm_i_eret(p);
+
 	uasm_l_r4000_write_probe_fail(l, *p);
 	build_tlb_write_entry(p, l, r, tlb_random);
 	uasm_l_leave(l, *p);
@@ -1458,15 +1456,10 @@ static void __cpuinit build_r4000_tlb_load_handler(void)
 	memset(relocs, 0, sizeof(relocs));
 
 	if (bcm1250_m3_war()) {
-		unsigned int segbits = 44;
-
-		uasm_i_dmfc0(&p, K0, C0_BADVADDR);
-		uasm_i_dmfc0(&p, K1, C0_ENTRYHI);
+		UASM_i_MFC0(&p, K0, C0_BADVADDR);
+		UASM_i_MFC0(&p, K1, C0_ENTRYHI);
 		uasm_i_xor(&p, K0, K0, K1);
-		uasm_i_dsrl_safe(&p, K1, K0, 62);
-		uasm_i_dsrl_safe(&p, K0, K0, 12 + 1);
-		uasm_i_dsll_safe(&p, K0, K0, 64 + 12 + 1 - segbits);
-		uasm_i_or(&p, K0, K0, K1);
+		UASM_i_SRL(&p, K0, K0, PAGE_SHIFT + 1);
 		uasm_il_bnez(&p, &r, K0, label_leave);
 		/* No need for uasm_i_nop */
 	}
@@ -1478,9 +1471,9 @@ static void __cpuinit build_r4000_tlb_load_handler(void)
 
 	if (kernel_uses_smartmips_rixi) {
 		/*
-		 * If the page is not _PAGE_VALID, RI or XI could not
-		 * have triggered it.  Skip the expensive test..
-		 */
+		* If the page is not _PAGE_VALID, RI or XI could not
+        * have triggered it.  Skip the expensive test..
+        */
 		uasm_i_andi(&p, K0, K0, _PAGE_VALID);
 		uasm_il_beqz(&p, &r, K0, label_tlbl_goaround1);
 		uasm_i_nop(&p);
@@ -1501,9 +1494,9 @@ static void __cpuinit build_r4000_tlb_load_handler(void)
 		UASM_i_MFC0(&p, K0, C0_ENTRYLO0); /* load it in the delay slot*/
 		UASM_i_MFC0(&p, K0, C0_ENTRYLO1); /* load it if ptr is odd */
 		/*
-		 * If the entryLo (now in K0) is valid (bit 1), RI or
-		 * XI must have triggered it.
-		 */
+		* If the entryLo (now in K0) is valid (bit 1), RI or
+		* XI must have triggered it.
+		*/
 		uasm_i_andi(&p, K0, K0, 2);
 		uasm_il_bnez(&p, &r, K0, label_nopage_tlbl);
 
@@ -1511,6 +1504,7 @@ static void __cpuinit build_r4000_tlb_load_handler(void)
 		/* Reload the PTE value */
 		iPTE_LW(&p, K0, K1);
 	}
+
 	build_make_valid(&p, &r, K0, K1);
 	build_r4000_tlbchange_handler_tail(&p, &l, &r, K0, K1);
 
@@ -1526,9 +1520,9 @@ static void __cpuinit build_r4000_tlb_load_handler(void)
 
 	if (kernel_uses_smartmips_rixi) {
 		/*
-		 * If the page is not _PAGE_VALID, RI or XI could not
-		 * have triggered it.  Skip the expensive test..
-		 */
+		* If the page is not _PAGE_VALID, RI or XI could not
+        * have triggered it.  Skip the expensive test..
+        */
 		uasm_i_andi(&p, K0, K0, _PAGE_VALID);
 		uasm_il_beqz(&p, &r, K0, label_tlbl_goaround2);
 		uasm_i_nop(&p);
@@ -1541,22 +1535,23 @@ static void __cpuinit build_r4000_tlb_load_handler(void)
 		UASM_i_MFC0(&p, K0, C0_ENTRYLO0); /* load it in the delay slot*/
 		UASM_i_MFC0(&p, K0, C0_ENTRYLO1); /* load it if ptr is odd */
 		/*
-		 * If the entryLo (now in K0) is valid (bit 1), RI or
-		 * XI must have triggered it.
-		 */
+		* If the entryLo (now in K0) is valid (bit 1), RI or
+		* XI must have triggered it.
+		*/
 		uasm_i_andi(&p, K0, K0, 2);
 		uasm_il_beqz(&p, &r, K0, label_tlbl_goaround2);
 		/* Reload the PTE value */
 		iPTE_LW(&p, K0, K1);
 
 		/*
-		 * We clobbered C0_PAGEMASK, restore it.  On the other branch
-		 * it is restored in build_huge_tlb_write_entry.
-		 */
+		* We clobbered C0_PAGEMASK, restore it.  On the other branch
+		* it is restored in build_huge_tlb_write_entry.
+		*/
 		build_restore_pagemask(&p, &r, K0, label_nopage_tlbl);
 
 		uasm_l_tlbl_goaround2(&l, p);
 	}
+
 	uasm_i_ori(&p, K0, K0, (_PAGE_ACCESSED | _PAGE_VALID));
 	build_huge_handler_tail(&p, &r, &l, K0, K1);
 #endif
@@ -1683,7 +1678,6 @@ void __cpuinit build_tlb_refill_handler(void)
 	case CPU_TX3912:
 	case CPU_TX3922:
 	case CPU_TX3927:
-#ifndef CONFIG_MIPS_PGD_C0_CONTEXT
 		build_r3000_tlb_refill_handler();
 		if (!run_once) {
 			build_r3000_tlb_load_handler();
@@ -1691,9 +1685,6 @@ void __cpuinit build_tlb_refill_handler(void)
 			build_r3000_tlb_modify_handler();
 			run_once++;
 		}
-#else
-		panic("No R3000 TLB refill handler");
-#endif
 		break;
 
 	case CPU_R6000:
@@ -1705,15 +1696,15 @@ void __cpuinit build_tlb_refill_handler(void)
 		panic("No R8000 TLB refill handler yet");
 		break;
 
-	default:
-		build_r4000_tlb_refill_handler();
-		build_r4000_tlb_refill_handler_stub();
-		if (!run_once) {
-			build_r4000_tlb_load_handler();
-			build_r4000_tlb_store_handler();
-			build_r4000_tlb_modify_handler();
-			run_once++;
-		}
+		default:
+			build_r4000_tlb_refill_handler();
+			build_r4000_tlb_refill_handler_stub();
+			if (!run_once) {
+				build_r4000_tlb_load_handler();
+				build_r4000_tlb_store_handler();
+				build_r4000_tlb_modify_handler();
+				run_once++;
+			}
 	}
 }
 
diff --git a/arch/mips/mm/uasm.c b/arch/mips/mm/uasm.c
index 611d564..8b575fc 100644
--- a/arch/mips/mm/uasm.c
+++ b/arch/mips/mm/uasm.c
@@ -1,3 +1,11 @@
+/*-
+ * Copyright 2008-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
 /*
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file "COPYING" in the main directory of this archive
@@ -19,7 +27,8 @@
 #include <asm/inst.h>
 #include <asm/elf.h>
 #include <asm/bugs.h>
-#include <asm/uasm.h>
+
+#include "uasm.h"
 
 enum fields {
 	RS = 0x001,
diff --git a/arch/mips/mm/uasm.h b/arch/mips/mm/uasm.h
new file mode 100644
index 0000000..a28e17f
--- /dev/null
+++ b/arch/mips/mm/uasm.h
@@ -0,0 +1,222 @@
+/*-
+ * Copyright 2008-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2004, 2005, 2006, 2008  Thiemo Seufer
+ * Copyright (C) 2005  Maciej W. Rozycki
+ * Copyright (C) 2006  Ralf Baechle (ralf@linux-mips.org)
+ */
+
+#include <linux/types.h>
+
+#define Ip_u1u2u3(op)							\
+void __cpuinit								\
+uasm_i##op(u32 **buf, unsigned int a, unsigned int b, unsigned int c)
+
+#define Ip_u2u1u3(op)							\
+void __cpuinit								\
+uasm_i##op(u32 **buf, unsigned int a, unsigned int b, unsigned int c)
+
+#define Ip_u3u1u2(op)							\
+void __cpuinit								\
+uasm_i##op(u32 **buf, unsigned int a, unsigned int b, unsigned int c)
+
+#define Ip_u1u2s3(op)							\
+void __cpuinit								\
+uasm_i##op(u32 **buf, unsigned int a, unsigned int b, signed int c)
+
+#define Ip_u2s3u1(op)							\
+void __cpuinit								\
+uasm_i##op(u32 **buf, unsigned int a, signed int b, unsigned int c)
+
+#define Ip_u2u1s3(op)							\
+void __cpuinit								\
+uasm_i##op(u32 **buf, unsigned int a, unsigned int b, signed int c)
+
+#define Ip_u2u1msbu3(op)						\
+void __cpuinit								\
+uasm_i##op(u32 **buf, unsigned int a, unsigned int b, unsigned int c,	\
+	   unsigned int d)
+
+#define Ip_u1u2(op)							\
+void __cpuinit uasm_i##op(u32 **buf, unsigned int a, unsigned int b)
+
+#define Ip_u1s2(op)							\
+void __cpuinit uasm_i##op(u32 **buf, unsigned int a, signed int b)
+
+#define Ip_u1(op) void __cpuinit uasm_i##op(u32 **buf, unsigned int a)
+
+#define Ip_0(op) void __cpuinit uasm_i##op(u32 **buf)
+
+Ip_u2u1s3(_addiu);
+Ip_u3u1u2(_addu);
+Ip_u2u1u3(_andi);
+Ip_u3u1u2(_and);
+Ip_u1u2s3(_beq);
+Ip_u1u2s3(_beql);
+Ip_u1s2(_bgez);
+Ip_u1s2(_bgezl);
+Ip_u1s2(_bltz);
+Ip_u1s2(_bltzl);
+Ip_u1u2s3(_bne);
+Ip_u2s3u1(_cache);
+Ip_u1u2u3(_dmfc0);
+Ip_u1u2u3(_dmtc0);
+Ip_u2u1s3(_daddiu);
+Ip_u3u1u2(_daddu);
+Ip_u2u1u3(_dsll);
+Ip_u2u1u3(_dsll32);
+Ip_u2u1u3(_dsra);
+Ip_u2u1u3(_dsrl);
+Ip_u2u1u3(_dsrl32);
+Ip_u2u1u3(_drotr);
+Ip_u3u1u2(_dsubu);
+Ip_0(_eret);
+Ip_u1(_j);
+Ip_u1(_jal);
+Ip_u1(_jr);
+Ip_u2s3u1(_ld);
+Ip_u2s3u1(_ll);
+Ip_u2s3u1(_lld);
+Ip_u1s2(_lui);
+Ip_u2s3u1(_lw);
+Ip_u1u2u3(_mfc0);
+Ip_u1u2u3(_mtc0);
+Ip_u2u1u3(_ori);
+Ip_u3u1u2(_or);
+Ip_u2s3u1(_pref);
+Ip_0(_rfe);
+Ip_u2s3u1(_sc);
+Ip_u2s3u1(_scd);
+Ip_u2s3u1(_sd);
+Ip_u2u1u3(_sll);
+Ip_u2u1u3(_sra);
+Ip_u2u1u3(_srl);
+Ip_u2u1u3(_rotr);
+Ip_u3u1u2(_subu);
+Ip_u2s3u1(_sw);
+Ip_0(_tlbp);
+Ip_0(_tlbr);
+Ip_0(_tlbwi);
+Ip_0(_tlbwr);
+Ip_u3u1u2(_xor);
+Ip_u2u1u3(_xori);
+Ip_u1(_syscall);
+
+/* Handle labels. */
+struct uasm_label {
+	u32 *addr;
+	int lab;
+};
+
+void __cpuinit uasm_build_label(struct uasm_label **lab, u32 *addr, int lid);
+#ifdef CONFIG_64BIT
+int uasm_in_compat_space_p(long addr);
+#endif
+int uasm_rel_hi(long val);
+int uasm_rel_lo(long val);
+void UASM_i_LA_mostly(u32 **buf, unsigned int rs, long addr);
+void UASM_i_LA(u32 **buf, unsigned int rs, long addr);
+
+#define UASM_L_LA(lb)							\
+static inline void __cpuinit uasm_l##lb(struct uasm_label **lab, u32 *addr) \
+{									\
+	uasm_build_label(lab, addr, label##lb);				\
+}
+
+/* convenience macros for instructions */
+#ifdef CONFIG_64BIT
+# define UASM_i_LW(buf, rs, rt, off) uasm_i_ld(buf, rs, rt, off)
+# define UASM_i_SW(buf, rs, rt, off) uasm_i_sd(buf, rs, rt, off)
+# define UASM_i_SLL(buf, rs, rt, sh) uasm_i_dsll(buf, rs, rt, sh)
+# define UASM_i_SRA(buf, rs, rt, sh) uasm_i_dsra(buf, rs, rt, sh)
+# define UASM_i_SRL(buf, rs, rt, sh) uasm_i_dsrl(buf, rs, rt, sh)
+# define UASM_i_ROTR(buf, rs, rt, sh) uasm_i_drotr(buf, rs, rt, sh)
+# define UASM_i_MFC0(buf, rt, rd...) uasm_i_dmfc0(buf, rt, rd)
+# define UASM_i_MTC0(buf, rt, rd...) uasm_i_dmtc0(buf, rt, rd)
+# define UASM_i_ADDIU(buf, rs, rt, val) uasm_i_daddiu(buf, rs, rt, val)
+# define UASM_i_ADDU(buf, rs, rt, rd) uasm_i_daddu(buf, rs, rt, rd)
+# define UASM_i_SUBU(buf, rs, rt, rd) uasm_i_dsubu(buf, rs, rt, rd)
+# define UASM_i_LL(buf, rs, rt, off) uasm_i_lld(buf, rs, rt, off)
+# define UASM_i_SC(buf, rs, rt, off) uasm_i_scd(buf, rs, rt, off)
+#else
+# define UASM_i_LW(buf, rs, rt, off) uasm_i_lw(buf, rs, rt, off)
+# define UASM_i_SW(buf, rs, rt, off) uasm_i_sw(buf, rs, rt, off)
+# define UASM_i_SLL(buf, rs, rt, sh) uasm_i_sll(buf, rs, rt, sh)
+# define UASM_i_SRA(buf, rs, rt, sh) uasm_i_sra(buf, rs, rt, sh)
+# define UASM_i_SRL(buf, rs, rt, sh) uasm_i_srl(buf, rs, rt, sh)
+# define UASM_i_ROTR(buf, rs, rt, sh) uasm_i_rotr(buf, rs, rt, sh)
+# define UASM_i_MFC0(buf, rt, rd...) uasm_i_mfc0(buf, rt, rd)
+# define UASM_i_MTC0(buf, rt, rd...) uasm_i_mtc0(buf, rt, rd)
+# define UASM_i_ADDIU(buf, rs, rt, val) uasm_i_addiu(buf, rs, rt, val)
+# define UASM_i_ADDU(buf, rs, rt, rd) uasm_i_addu(buf, rs, rt, rd)
+# define UASM_i_SUBU(buf, rs, rt, rd) uasm_i_subu(buf, rs, rt, rd)
+# define UASM_i_LL(buf, rs, rt, off) uasm_i_ll(buf, rs, rt, off)
+# define UASM_i_SC(buf, rs, rt, off) uasm_i_sc(buf, rs, rt, off)
+#endif
+
+#define uasm_i_b(buf, off) uasm_i_beq(buf, 0, 0, off)
+#define uasm_i_beqz(buf, rs, off) uasm_i_beq(buf, rs, 0, off)
+#define uasm_i_beqzl(buf, rs, off) uasm_i_beql(buf, rs, 0, off)
+#define uasm_i_bnez(buf, rs, off) uasm_i_bne(buf, rs, 0, off)
+#define uasm_i_bnezl(buf, rs, off) uasm_i_bnel(buf, rs, 0, off)
+#define uasm_i_move(buf, a, b) UASM_i_ADDU(buf, a, 0, b)
+#define uasm_i_nop(buf) uasm_i_sll(buf, 0, 0, 0)
+#define uasm_i_ssnop(buf) uasm_i_sll(buf, 0, 0, 1)
+#define uasm_i_ehb(buf) uasm_i_sll(buf, 0, 0, 3)
+
+static inline void uasm_i_dsrl_safe(u32 **p, unsigned int a1,
+				    unsigned int a2, unsigned int a3)
+{
+	if (a3 < 32)
+		uasm_i_dsrl(p, a1, a2, a3);
+	else
+		uasm_i_dsrl32(p, a1, a2, a3 - 32);
+}
+
+static inline void uasm_i_dsll_safe(u32 **p, unsigned int a1,
+				    unsigned int a2, unsigned int a3)
+{
+	if (a3 < 32)
+		uasm_i_dsll(p, a1, a2, a3);
+	else
+		uasm_i_dsll32(p, a1, a2, a3 - 32);
+}
+
+/* Handle relocations. */
+struct uasm_reloc {
+	u32 *addr;
+	unsigned int type;
+	int lab;
+};
+
+/* This is zero so we can use zeroed label arrays. */
+#define UASM_LABEL_INVALID 0
+
+void uasm_r_mips_pc16(struct uasm_reloc **rel, u32 *addr, int lid);
+void uasm_resolve_relocs(struct uasm_reloc *rel, struct uasm_label *lab);
+void uasm_move_relocs(struct uasm_reloc *rel, u32 *first, u32 *end, long off);
+void uasm_move_labels(struct uasm_label *lab, u32 *first, u32 *end, long off);
+void uasm_copy_handler(struct uasm_reloc *rel, struct uasm_label *lab,
+	u32 *first, u32 *end, u32 *target);
+int uasm_insn_has_bdelay(struct uasm_reloc *rel, u32 *addr);
+
+/* Convenience functions for labeled branches. */
+void uasm_il_bltz(u32 **p, struct uasm_reloc **r, unsigned int reg, int lid);
+void uasm_il_b(u32 **p, struct uasm_reloc **r, int lid);
+void uasm_il_beqz(u32 **p, struct uasm_reloc **r, unsigned int reg, int lid);
+void uasm_il_beqzl(u32 **p, struct uasm_reloc **r, unsigned int reg, int lid);
+void uasm_il_bne(u32 **p, struct uasm_reloc **r, unsigned int reg1,
+		 unsigned int reg2, int lid);
+void uasm_il_bnez(u32 **p, struct uasm_reloc **r, unsigned int reg, int lid);
+void uasm_il_bgezl(u32 **p, struct uasm_reloc **r, unsigned int reg, int lid);
+void uasm_il_bgez(u32 **p, struct uasm_reloc **r, unsigned int reg, int lid);
diff --git a/arch/mips/netlogic/Kconfig b/arch/mips/netlogic/Kconfig
index 5d8acb4..f833233 100644
--- a/arch/mips/netlogic/Kconfig
+++ b/arch/mips/netlogic/Kconfig
@@ -56,7 +56,7 @@ config MAPPED_KERNEL
 config PHYS_LOAD_ADDRESS
        hex "Physical load address"
        depends on MAPPED_KERNEL
-       default 0xffffffff81000000
+       default 0xffffffff84000000
        help
          The physical load address reflected as the program header
          physical address in the kernel ELF image.
@@ -64,7 +64,7 @@ config PHYS_LOAD_ADDRESS
 config NLM_COMMON_LOAD_ADDRESS
 	hex "Netlogic Linux kernel start address"
 	depends on NLM_COMMON
-	default "0xffffffffc1000000"
+	default "0xffffffffc4000000"
 	help
 	  This is start address for the linux kernel. Default value
           should be good for most of the applications unless specified
diff --git a/arch/mips/netlogic/boot/string.h b/arch/mips/netlogic/boot/string.h
index 50091cc..3a31422 100644
--- a/arch/mips/netlogic/boot/string.h
+++ b/arch/mips/netlogic/boot/string.h
@@ -1,6 +1,16 @@
+/*-
+ * Copyright 2003-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
+
 #ifndef _PPC_BOOT_STRING_H_
 #define _PPC_BOOT_STRING_H_
 #include <stddef.h>
+#include <asm/string.h>
 
 extern char *strcpy(char *dest, const char *src);
 extern char *strncpy(char *dest, const char *src, size_t n);
@@ -12,8 +22,8 @@ extern size_t strlen(const char *s);
 extern size_t strnlen(const char *s, size_t count);
 
 extern void *memset(void *s, int c, size_t n);
-extern void *memmove(void *dest, const void *src, unsigned long n);
-extern void *memcpy(void *dest, const void *src, unsigned long n);
+extern void *memmove(void *dest, const void *src, size_t n);
+extern void *memcpy(void *dest, const void *src, size_t n);
 extern void *memchr(const void *s, int c, size_t n);
 extern int memcmp(const void *s1, const void *s2, size_t n);
 
diff --git a/arch/mips/netlogic/common/cpu_proc.c b/arch/mips/netlogic/common/cpu_proc.c
index 60957b6..18c51c8 100644
--- a/arch/mips/netlogic/common/cpu_proc.c
+++ b/arch/mips/netlogic/common/cpu_proc.c
@@ -1,27 +1,32 @@
-/***********************************************************************
- * Copyright 2003-2010 Netlogic Microsystems (Netlogic). All rights
- * reserved.
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
  * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
  * 1. Redistributions of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer.
  * 2. Redistributions in binary form must reproduce the above copyright
- * notice, this list of conditions and the following disclaimer in
- * the documentation and/or other materials provided with the
- * distribution.
- * THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- * *****************************#NETL_2#********************************/
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
 
 #include <linux/kernel.h>
 #include <linux/interrupt.h>
@@ -133,6 +138,30 @@ static int nlm_cpu_proc_read(char *page, char **start, off_t off,
 	if (!proc_pos_check(&begin, &len, off, count))
 		goto out;
 
+#ifdef CONFIG_32BIT
+        len += sprintf(page + len, "32 Bit ");
+#else
+        len += sprintf(page + len, "64 Bit ");
+#endif
+        if (!proc_pos_check(&begin, &len, off, count))
+               goto out;
+
+#ifdef CONFIG_CPU_BIG_ENDIAN
+        len += sprintf(page + len, "Big Endian ");
+#else
+        len += sprintf(page + len, "Little Endian ");
+#endif
+        if (!proc_pos_check(&begin, &len, off, count))
+               goto out;
+
+#ifdef CONFIG_MAPPED_KERNEL
+        len += sprintf(page + len, "Mapped Kernel.\n");
+#else
+        len += sprintf(page + len, "Un-Mapped Kernel.\n");
+#endif
+        if (!proc_pos_check(&begin, &len, off, count))
+               goto out;
+
 	for(i=0;i<32;i++) {
 
 		if (!nlm_cp2_exceptions[i]) continue;
@@ -199,6 +228,14 @@ static int nlm_cpu_proc_read(char *page, char **start, off_t off,
 static int nlm_cpu_proc_init(void)
 {
 	struct proc_dir_entry *entry;
+#ifdef CONFIG_NLM_XLR
+	entry = create_proc_read_entry("xlr_cpu", 0 /* def mode */ ,
+				       nlm_root_proc/* parent */ ,
+				       nlm_cpu_proc_read
+				       /* proc read function */ ,
+				       0	/* no client data */
+		);
+#endif
 #ifdef CONFIG_NLM_XLP
 	entry = create_proc_read_entry("xlp_cpu", 0 /* def mode */ ,
 				       nlm_root_proc/* parent */ ,
diff --git a/arch/mips/netlogic/common/fdt_helper.c b/arch/mips/netlogic/common/fdt_helper.c
index bb16f51..310ca7f 100644
--- a/arch/mips/netlogic/common/fdt_helper.c
+++ b/arch/mips/netlogic/common/fdt_helper.c
@@ -1,30 +1,36 @@
-/*************************************************************************
- Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
- reserved.
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions are
- met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in
-    the documentation and/or other materials provided with the
-    distribution.
- THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
- ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE
- LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- THE POSSIBILITY OF SUCH DAMAGE.
-*******************************#NETL_2#**********************************/
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
 #if defined(__KERNEL__)
+#if !defined(NLM_HAL_UBOOT)
 #include <linux/kernel.h>
-
+#endif
 #else
 #include <stdio.h>
 #include <sys/types.h>
@@ -40,11 +46,17 @@
 
 static int fdt_helper_print  = 1;
 
+extern int printf(const char *format, ...);
 #if !defined(__KERNEL__)
 #define fdtprint(x...) do {   \
 	if (fdt_helper_print) \
 		printf(x);    \
 } while (0)
+#elif defined(NLM_HAL_UBOOT)
+#define fdtprint(x...) do {   \
+	if (fdt_helper_print) \
+		printf(x);    \
+} while (0)
 #else
 #define fdtprint(x...) do {   \
 	if (fdt_helper_print) \
@@ -83,7 +95,7 @@ void *open_fdt(int fd) { return NULL; }
 static void print_fdt_prop(const char *path, const char *prop,
 	enum prop_type type, const void *buf, int len)
 {
-#ifdef FDT_DEBUG
+#if 0
 	fdtprint("FDT: parsed %s.%s: ", path, prop);
 	if (type == PROP_CELL) {
 		const uint32_t *dst = (const uint32_t *)buf;
@@ -117,7 +129,7 @@ int copy_fdt_prop(void *fdt, const char *path, const char *prop,
 
 	nodeoffset = fdt_path_offset(fdt, path);
 	if (nodeoffset < 0) {
-#ifdef FDT_DEBUG
+#if 0
 		fdtprint("%s: Failed to parse path %s\n",
 		         fdt_strerror(nodeoffset), path);
 #endif
@@ -126,7 +138,7 @@ int copy_fdt_prop(void *fdt, const char *path, const char *prop,
 
 	pval = fdt_getprop(fdt, nodeoffset, prop, &plen);
 	if (pval == NULL) {
-#ifdef FDT_DEBUG
+#if 0
 		fdtprint("%s: Failed to parse property %s\n",
 		         fdt_strerror(plen), prop);
 #endif
diff --git a/arch/mips/netlogic/common/memory.c b/arch/mips/netlogic/common/memory.c
index 868e9be..db1017c 100644
--- a/arch/mips/netlogic/common/memory.c
+++ b/arch/mips/netlogic/common/memory.c
@@ -1,27 +1,32 @@
-/***********************************************************************
- * Copyright 2003-2010 Netlogic Microsystems (Netlogic). All rights
- * reserved.
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
  * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
  * 1. Redistributions of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
+ *    notice, this list of conditions and the following disclaimer.
  * 2. Redistributions in binary form must reproduce the above copyright
- * notice, this list of conditions and the following disclaimer in
- * the documentation and/or other materials provided with the
- * distribution.
- * THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
- * THE POSSIBILITY OF SUCH DAMAGE.
- * *****************************#NETL_2#********************************/
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
 
 #include <linux/fs.h>
 #include <linux/fcntl.h>
@@ -244,12 +249,26 @@ void setup_mapped_kernel_tlbs(int firstpage, int primary_cpu)
 #ifdef CONFIG_NUMA
 		/* For NUMA, for each node, we have to wire the minimum physical page for that node.
 		 * NUMA uses that piece of memory immediately to keep its internal data structure.
+		 *
+		 * For node 0: the first chunk of memory above the MAX_DMA_ADDRESS needs to be wired
+		 * as the kernel will allocate space in that area before the exception handlers etc.
+		 * are setup.
+		 *
+		 * For other nodes, the first chunk of memory available on that node needs to be wired.
 		 */
-		for (node = 1; node < NLM_MAX_CPU_NODE; node ++) {
+		for (node = 0; node < NLM_MAX_CPU_NODE; node ++) {
 			paddr = PFN_PHYS(node_mem_info[node].min_start_pfn);
 			if (paddr == 0)
 				continue;
 
+			/* for node 0, wire extra lines only if it is not wired yet */
+			if (node == 0 && node_mem_info[0].min_start_pfn < MAX_WIRED_PFN)
+				continue;
+
+			/* make sure the paddr is aligned also */
+			if (paddr % ( 2 * LARGEST_TLBPAGE_SZ))
+				paddr -= (paddr % (2 * LARGEST_TLBPAGE_SZ));
+
 			vaddr = KERNEL_SEG_START + paddr;
 			tlb.entryHi = vaddr;
 			tlb.entrylo0 = page_entrylo(paddr, attr);
diff --git a/arch/mips/netlogic/common/nlm_hal.c b/arch/mips/netlogic/common/nlm_hal.c
index fc3d07d..bac6340 100644
--- a/arch/mips/netlogic/common/nlm_hal.c
+++ b/arch/mips/netlogic/common/nlm_hal.c
@@ -97,6 +97,9 @@ static int  bcm_get_phy_status(struct nlm_hal_ext_phy *phy, uint32_t *speed, uin
 static void bcm_start_an(struct nlm_hal_ext_phy *phy, int node);
 static void bcm_init_phy(struct nlm_hal_ext_phy *phy, int node);
 
+static int  xmc_get_phy_status(struct nlm_hal_ext_phy *phy, uint32_t *speed, uint32_t *duplex, int node);
+static void xmc_start_an(struct nlm_hal_ext_phy *phy, int node);
+static void xmc_init_phy(struct nlm_hal_ext_phy *phy, int node);
 
 void nlm_hal_init_ext_phy(int node, int inf);
 void nlm_hal_config_sgmii_if(int node, int inf);
@@ -107,6 +110,7 @@ struct nlm_hal_ext_phy * get_phy_info(int inf);
 static struct nlm_hal_ext_phy  known_ext_phys[] = {
 		{"mvs103656", 0xc97, 0, 0, 0, mvl_get_phy_status, mvl_start_an, mvl_init_phy},
 		{"bcm5461s", 0x60c1, 0, 0, 0, bcm_get_phy_status, bcm_start_an, bcm_init_phy},
+		{"bcm5482", 0xbcb2, 0, 0, 0, xmc_get_phy_status, xmc_start_an, xmc_init_phy},
 		{"", 0, 0, 0, 0, NULL, NULL, NULL}
 };
 static struct nlm_hal_ext_phy regs_ext_phys[MAX_PHYS];
@@ -1001,6 +1005,108 @@ void nlm_hal_init_ext_phy(int node, int inf)
 	return;
 }
 
+#if 0
+/* print various phy status registers */
+static void xmc_phy_status(struct nlm_hal_ext_phy *phy, int node)
+{
+	int status;
+	int bus = phy->ext_mdio_bus;
+	int phyaddr = phy->phy_addr;
+	int int_inf = phy->inf;
+
+	//operating mode status reg
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x17, 0xf42);
+	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x15);
+	nlm_print("%s: operating mode status for phy %d = 0x%x \n", __func__, phyaddr, status);
+
+	status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x1);
+	nlm_print("%s: nae %d  register 1= 0x%x \n", __func__, int_inf, status);
+
+
+}
+#else
+static void xmc_phy_status(struct nlm_hal_ext_phy *phy, int node) {;}
+#endif
+
+/**
+* @brief xmc_init_phy function initializes an external BROADCOM 5482 PHY on the XMC board.
+*
+* @param[in] phy	:nlm_hal_ext_phy struct pointing to the BROADCOM PHY
+* @param [in] node Node number
+*
+* @return
+* 	- none
+*
+* @ingroup hal_nae
+*
+*/
+static void xmc_init_phy(struct nlm_hal_ext_phy *phy, int node)
+{
+	int i, aux_status;
+	int bus = phy->ext_mdio_bus;
+	int phyaddr = phy->phy_addr;
+	int int_inf = phy->inf;
+	int status=0;
+
+	nlm_print("XMC_INIT_PHY \n ");
+
+	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x04, 0x01); // selector field
+	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, 0); // disable XLP AN
+	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, 0x8000); // soft reset
+
+	/* XMC board has INTFSEL[1:0] = 01 which selects fiber and power down modes*/
+
+	/* setup for SGMII-Copper mode */
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x1c, 0x7c00);
+	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C);
+	status = 0x7c00 | (2 << 1); // SGMII mode, copper registers
+	//nlm_print("writing phyaddr %d reg 0x1c =0x%x \n", phyaddr, status);
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x1c, (status | (1<<15)));
+
+	/* Turn off Signal Detect Enable on 1000BASE-X side */
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x1c, (0x5c00 | (1<<15)));
+
+	/* power up copper side*/
+	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x0);
+	status &= ~(1<<11);
+	//nlm_print("writing phyaddr %d reg 0 =0x%x \n", phyaddr, status);
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x00, status); // Normal Operation
+	nlm_mdelay(100);
+
+	/* setup LED control */
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x1c, 0x8801); // spare control 1, enable link led mode
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x1c, 0xB4E5); // LED Selector 1, LED3 off, LED1 SLAVE (LINK)
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x1c, 0xB83E); // LED Selector 2, LED2 ACTIVITY, LED4 off
+
+	/*switch to 1000Base-X registers mode*/
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x1c, 0x7c00);
+	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C);
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x1c, (status | (1<<15)| (0x1)));
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x0, 0x100 ); /*Disable AN and power up SGMII side*/
+	nlm_mdelay(100);
+
+	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x0);
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x0, status | (1<<12) ); /*Enable AN on SGMMII side of PHY*/
+
+#if 1
+	/* wait up to 5 seconds for AN to complete on copper side */
+	i=0;
+	do {
+		nlm_mdelay(100);
+		aux_status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x19);
+		if (aux_status & 0x8000)
+			break;
+
+		i++;
+	}while(i<50);
+	xmc_phy_status(phy, node);
+#endif
+
+	status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf,  0x0);
+	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, status|(1<<12)); // Enable XLP AN
+	return;
+}
+
 /**
 * @brief bcm_init_phy function initializes an external BROADCOM PHY.
 *
@@ -1025,6 +1131,14 @@ static void bcm_init_phy(struct nlm_hal_ext_phy *phy, int node)
 	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, 0); // disable XLP AN
 	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, 0x8000); // soft reset
 
+#if 0
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, int_inf,  0x1c, 0x7800);
+	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, int_inf, 0x1C);
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, int_inf,  0x1c, (status | (1<<15)| (0x1)));
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, int_inf,  0x1c, 0x7800);
+	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, int_inf, 0x1C);
+#endif
+
 	/*switch to 1000Base-X registers mode*/
 	/*refer mode control register in broadcom datasheet*/
 	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x1c, 0x7c00);
@@ -1098,6 +1212,89 @@ void nlm_hal_ext_phy_an(int node, int inf)
 	return;
 }
 
+void nlm_hal_restart_an(int node, int inf)
+{
+	static int link_status[XLP_MAX_PORTS];
+	struct nlm_hal_ext_phy *phy=NULL;
+	int i = 0, int_inf, status, phyaddr, bus;
+
+	while(regs_ext_phys[i].inf != -1)
+	{
+		phy = get_phy_info(regs_ext_phys[i].inf);
+		if(!phy)
+	               	return;
+		if((phy->phy_idfer == 0x60c1 || phy->phy_idfer == 0xbcb2))/* only for broadcom phys*/
+		{
+			int_inf = phy->inf;
+			phyaddr = phy->phy_addr;
+			bus = phy->ext_mdio_bus;
+
+			status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x1);
+			if(!(status & (1<<2)))
+			{
+				link_status[int_inf] = 1;
+
+				nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, int_inf, 0x1C, 0x7800);
+				status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, int_inf, 0x1C);
+
+				status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x1);
+				status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf,  0x0);
+				nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, status|(1<<9)); // Restart XLP AN
+
+			} 
+			else if(link_status[int_inf])
+			{
+				link_status[int_inf] = 0;
+				nlm_hal_ext_phy_an(0, i);
+			}
+		}
+		i++;
+	}	
+}
+/**
+* @brief xmc_start_an function enables auto-negotiation on XMC board external BROADCOM PHY.
+*
+* @param[in] phy	:nlm_hal_ext_phy struct pointing to the BROADCOM PHY
+* @param [in] node Node number
+*
+* @return
+* 	- none
+*
+* @ingroup hal_nae
+*
+*/
+static void xmc_start_an(struct nlm_hal_ext_phy *phy, int node)
+{
+	int status, count;
+	int phyaddr = phy->phy_addr;
+	int bus = phy->ext_mdio_bus;
+	int int_inf = phy->inf;
+
+	nlm_print("Starting auto-negotiation on port %d, external mdio bus %d, phy address %d\n", phy->inf,  bus, phyaddr);
+
+	status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf,  0x0);
+	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, status|(1<<9)); // Restart XLP AN
+	/*Wait for XLP<->SGMII-PHY AN to be OK*/
+	count=0;
+        do {
+		nlm_mdelay(100);
+		count++;
+		status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x1);
+		if(status & (1<<5)){ /* check for autonegotiation to be completed */
+			nlm_print("Autonegotiation is OK with PHY-SGMII =0x%x \n", int_inf);
+			xmc_phy_status(phy, node);
+			//nlm_print("%s: exit\n", __func__);
+			return;
+		}
+		status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf,  0x0);
+		nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, status|(1<<9)); // Restart XLP AN
+        }while(count<100);
+
+	nlm_print("Autonegotiation is NOT OK for PHY-SGMII inf=0x%x int_inf =0x%x\n", phyaddr, int_inf);
+	xmc_phy_status(phy, node);
+	return;
+}
+
 /**
 * @brief bcm_start_an function enables auto-negotiation on an external BROADCOM PHY.
 *
@@ -1113,13 +1310,15 @@ void nlm_hal_ext_phy_an(int node, int inf)
 static void bcm_start_an(struct nlm_hal_ext_phy *phy, int node)
 {
 	int status, count;
-	int phyaddr = phy->phy_addr;
-	int bus = phy->ext_mdio_bus;
+	int phyaddr;
+	int bus;
 	int int_inf = phy->inf;
 
+	phyaddr = phy->phy_addr;
+        bus = phy->ext_mdio_bus;
 	/*switch to Copper registers mode*/
 	/*refer mode control register in broadcom datasheet*/
-	nlm_print("Starting auto-negotiation on port %d, external mdio bus %d, phy address %d\n", phy->inf,  bus, phyaddr);
+	//nlm_print("Starting auto-negotiation on port %d, external mdio bus %d, phy address %d\n", phy->inf,  bus, phyaddr);
 #if 0
 	nlm_hal_mdio_write(NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C, 0x7c00);
 	status = nlm_hal_mdio_read(NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C);
@@ -1161,14 +1360,14 @@ static void bcm_start_an(struct nlm_hal_ext_phy *phy, int node)
 		count++;
 		status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x1);
 		if(status & (1<<5)){ /* check for autonegotiation to be completed */
-			nlm_print("Autonegotiation is OK with PHY-SGMII =0x%x \n", int_inf);
+	//		nlm_print("Autonegotiation is OK with PHY-SGMII =0x%x \n", int_inf);
 			return;
 		}
 		status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf,  0x0);
 		nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, status|(1<<9)); // Restart XLP AN
         }while(count<100);
 
-	nlm_print("Autonegotiation is NOT OK for PHY-SGMII inf=0x%x int_inf =0x%x\n", phyaddr, int_inf);
+	//nlm_print("Autonegotiation is NOT OK for PHY-SGMII inf=0x%x int_inf =0x%x\n", phyaddr, int_inf);
 	return;
 }
 
@@ -1235,6 +1434,117 @@ static void mvl_start_an(struct nlm_hal_ext_phy *phy, int node)
 }
 
 /**
+* @brief xmc_get_phy_status function returns the status of an interface from the XMC external BROADCOM PHY.
+*
+* @param[in] phy		:nlm_hal_ext_phy struct pointing to the BROADCOM PHY
+* @param[out] speed		:Link speed
+* @param[out] duplex	:Link duplex status
+* @param [in] node Node number
+*
+* @return
+* 	- 1 - Link up, 0 - Link Down
+*
+* @ingroup hal_nae
+*
+*/
+static int xmc_get_phy_status(struct nlm_hal_ext_phy *phy, uint32_t *speed, uint32_t *duplex, int node)
+{
+	int aux_status=0;
+	int status=0;
+	int phyaddr = phy->phy_addr;
+	int bus = phy->ext_mdio_bus;
+	//int int_inf = phy->inf;
+
+
+	/*switch to Copper registers mode*/
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C, 0x7c00);
+	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C);
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C, ((status | (1<<15)) & ~1) );
+
+#if 0
+	/* start auto-negotiation on copper side */
+	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x0);
+	status |= (1 << 9);
+	nlm_print("writing phyaddr %d reg 0 =0x%x \n", phyaddr, status);
+	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x00, status );
+#endif
+
+#if 0
+	/* wait up to 5 seconds for AN to complete on copper side*/
+	i=0;
+	do {
+		nlm_mdelay(100);
+		aux_status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x19);
+		if (aux_status & 0x8000)
+			break;
+
+		i++;
+	}while(i<50);
+#endif
+	/* check the status */
+	aux_status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x19);
+	switch ((aux_status>>8) & 0x7){
+		case 0x7:
+			*speed = SPEED_1000M;
+			*duplex = 1;
+		break;
+
+		case 0x6:
+			*speed = SPEED_1000M;
+			*duplex = 0;
+		break;
+
+		case 0x5:
+			*speed = SPEED_100M;
+			*duplex = 1;
+		break;
+
+		case 0x3:
+			*speed = SPEED_100M;
+			*duplex = 0;
+		break;
+
+		case 0x2:
+			*speed = SPEED_10M;
+			*duplex = 1;
+		break;
+
+		case 0x1:
+			*speed = SPEED_10M;
+			*duplex = 0;
+		break;
+
+		default:
+			nlm_print("Unknown operating speed, auxstatus = 0x%04x\n", aux_status);
+		break;
+	}
+
+//#ifdef PHY_DEBUG
+	if(*speed==SPEED_1000M)
+		nlm_print("Configured with Speed  1000M");
+	if(*speed==SPEED_100M)
+		nlm_print("Configured with Speed 100M");
+	if(*speed==SPEED_10M)
+		nlm_print("Configured with Speed 10M");
+
+	((*duplex == 1) ? nlm_print("Full duplex\n"):nlm_print("Half duplex\n"));
+//#endif
+	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1);
+	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1);
+	if(status & (1<<2)){
+		nlm_print("Link is up : %x\n", status);
+		xmc_phy_status(phy, node);
+		//nlm_print("%s: exit\n", __func__);
+		return 1;
+	}else{
+		nlm_print("Link is down : %x\n", status);
+		xmc_phy_status(phy, node);
+		//nlm_print("%s: exit\n", __func__);
+		return 0;
+	}
+}
+
+/**
 * @brief bcm_get_phy_status function returns the status of an interface from the external BROADCOM PHY.
 *
 * @param [in] phy nlm_hal_ext_phy struct pointing to the BROADCOM PHY
@@ -1377,7 +1687,7 @@ struct nlm_hal_ext_phy* get_phy_info(int inf)
 			return phy_info;
 		}
 	}
-	nlm_print("Interface could not be initialised for inf=0x%x\n", inf);
+	//nlm_print("Interface could not be initialised for inf=0x%x\n", inf);
 	return NULL;
 }
 
@@ -1480,6 +1790,7 @@ void sgmii_scan_phys(int node)
 					regs_ext_phys[reg_idx].ext_phy_init =  known_ext_phys[j].ext_phy_init;
 					regs_ext_phys[reg_idx].phy_addr = inf;
 					regs_ext_phys[reg_idx].inf = -1;
+					regs_ext_phys[reg_idx].phy_idfer = known_ext_phys[j].phy_idfer;
 					//nlm_print("Found port with 1st bus and phy_addr =0x%x phy-idfer =0x%x\n ", regs_ext_phys[reg_idx].phy_addr, phyid);
 					reg_idx++;
 				}
@@ -1500,6 +1811,7 @@ void sgmii_scan_phys(int node)
 				regs_ext_phys[reg_idx].ext_phy_init =  known_ext_phys[j].ext_phy_init;
 				regs_ext_phys[reg_idx].phy_addr = inf;
 				regs_ext_phys[reg_idx].inf = -1;
+				regs_ext_phys[reg_idx].phy_idfer = known_ext_phys[j].phy_idfer;
 				//nlm_print("Found port with 0th bus and phy_addr =0x%x phy-idfer=0x%x\n ", regs_ext_phys[reg_idx].phy_addr, phyid);
 				reg_idx++;
 			}
@@ -1797,6 +2109,7 @@ EXPORT_SYMBOL(nlm_node_cfg);
 
 EXPORT_SYMBOL(nlm_hal_init_ext_phy);
 EXPORT_SYMBOL(nlm_hal_ext_phy_an);
+EXPORT_SYMBOL(nlm_hal_restart_an);
 EXPORT_SYMBOL(register_phy);
 EXPORT_SYMBOL(get_dom_owner_mask);
 EXPORT_SYMBOL(nlm_hal_sata_init);
diff --git a/arch/mips/netlogic/common/nlm_hal_cpu_info.c b/arch/mips/netlogic/common/nlm_hal_cpu_info.c
index 361576d..1d7c439 100644
--- a/arch/mips/netlogic/common/nlm_hal_cpu_info.c
+++ b/arch/mips/netlogic/common/nlm_hal_cpu_info.c
@@ -246,7 +246,8 @@ inline int is_xlp3xx(uint8_t num_cpu, uint32_t rev, uint32_t exttype)
 inline int is_xlp2xx(uint8_t num_cpu, uint32_t rev)
 {
 	uint32_t pid, cfg0, mask;
-	int ret, cpuNum;
+	int ret, cpuNum, threadEnable;
+	int tbl[4] = { 4, 2, 2, 1 };
 
 	ret=is_nlm_xlp2xx_rev_xx(rev);
 	if(ret!=1)  return 0;
@@ -256,7 +257,8 @@ inline int is_xlp2xx(uint8_t num_cpu, uint32_t rev)
 	{
 		cfg0=efuse_cfg0();
 		mask = cfg0  & 0x3;
-		cpuNum=(2-bitcount(mask))<<2;
+		threadEnable = tbl[(cfg0 >> 28) & 0x3];
+		cpuNum=(2-bitcount(mask))*threadEnable;
 		if( (cpuNum==num_cpu) || (num_cpu==CPU_NUM_ANY )) return 1;
 	}
 	return 0;
diff --git a/arch/mips/netlogic/common/nlm_hal_fmn_config.c b/arch/mips/netlogic/common/nlm_hal_fmn_config.c
index f908ec2..d146b50 100644
--- a/arch/mips/netlogic/common/nlm_hal_fmn_config.c
+++ b/arch/mips/netlogic/common/nlm_hal_fmn_config.c
@@ -1041,9 +1041,8 @@ int get_dom_fmn_node_ownership(void *fdt, int dom_id)
 * @ingroup hal_fmn
 *
 */
-void nlm_hal_fmn_init(void *fdt)
+void nlm_hal_fmn_init(void *fdt, int node)
 {
-	int node = 0; 
 	int max_nodes;
 
 	nlm_print("*** Firmware Configuration of FMN ***\n");
@@ -1055,23 +1054,16 @@ void nlm_hal_fmn_init(void *fdt)
 		while(1);
 	}
 
-	for (node = 0; node < max_nodes; node++) {
-		if(!is_nlm_xlp2xx()) {
-			nlm_hal_soc_clock_enable(node, DFS_DEVICE_RSA);
-		} else {
-		}
+	if(!is_nlm_xlp2xx()) {
+		nlm_hal_soc_clock_enable(node, DFS_DEVICE_RSA);
 	}
 
 	//fmn_qsize_credit_cfg_extract(fdt);
 	/* verify out_q config 
 	 */
-	for (node = 0; node < max_nodes; node++) {
-		if(nlm_hal_setup_outq(node, max_nodes) < 0)
-			while(1);
-	}
-	for (node = 0; node < max_nodes; node++) {
-		nlm_hal_write_fmn_credit(node, max_nodes);
-	}
+	if(nlm_hal_setup_outq(node, max_nodes) < 0)
+		while(1);
+	nlm_hal_write_fmn_credit(node, max_nodes);
 }
 
 #ifdef NLM_HAL_LINUX_KERNEL 
diff --git a/arch/mips/netlogic/common/nlm_hal_nae.c b/arch/mips/netlogic/common/nlm_hal_nae.c
index a514c1e..d898a94 100644
--- a/arch/mips/netlogic/common/nlm_hal_nae.c
+++ b/arch/mips/netlogic/common/nlm_hal_nae.c
@@ -767,7 +767,7 @@ void nlm_hal_xlp2xx_nae_program_vsemi(int node, int block, int xaui_speed, int p
 			if(xaui_speed==12){
 				vsemi_cmd |= vsemi_mem_12G_4page[reg_addr];		
 			}
-			if((xaui_speed==10) || (phy_mode==PHYMODE_XAUI)){
+			if((xaui_speed==10)) {
 				vsemi_cmd |= vsemi_mem_xaui_4page[reg_addr];		
 			}
 			if(phy_mode==PHYMODE_SGMII){
@@ -786,7 +786,7 @@ void nlm_hal_xlp2xx_nae_program_vsemi(int node, int block, int xaui_speed, int p
 		if(xaui_speed==12){
 			vsemi_cmd |= vsemi_mem_12G[reg_addr];		
 		}
-		if((xaui_speed==10) || (phy_mode==PHYMODE_XAUI)){
+		if(xaui_speed==10) {
 			vsemi_cmd |= vsemi_mem_xaui[reg_addr];		
 		}
 		if(phy_mode==PHYMODE_SGMII){
@@ -954,47 +954,26 @@ int xlp3xx_8xxb0_nae_lane_reset_txpll(int node, int block, int lane_ctrl, int mo
 
 	val = nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl);
 
-
-	val |= (1<< 29);
-	val &= ~((1<< 30)&0xFFFFFFFF);
-	val &= ~((1<< 20) & 0xFFFFFFFF);
-	val |= (mode << PHY_LANE_CTRL_PHYMODE_POS);
-	val |= rext_sel;
-	val &= ~(1 << 17); //setting indirect register request access to 0
-
-	NAE_DEBUG("PHY LANE CTRL REG to be written with value: %x\n",val);
-	nlm_hal_write_mac_reg(node, block, PHY, lane_ctrl,val);
-	val_temp=nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl);
-	NAE_DEBUG("PHY LANE CTRL REG that was just written is :  %x\n", val_temp);
-	nlm_mdelay(1);
-
-
 	if(mode != PHYMODE_SGMII){
-		val |= PHY_LANE_CTRL_BPC_XAUI; /*Set comma bypass for XAUI*/
-		NAE_DEBUG("Just set comma bypass for XAUI\n");
+		val |= PHY_LANE_CTRL_BPC_XAUI; /*Set comma bypass for XAUII*/
 	}
-	NAE_DEBUG("Setting the PMA Register Bit(Bit 20)\n");
-	val |= 0x100000;  /* Bit20: serdes reg reset Storm & Eagle B0 */
-	nlm_hal_write_mac_reg(node, block, PHY, lane_ctrl,val);
-	val_temp=nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl);
-	NAE_DEBUG("PHY LANE CTRL REG that was just written is :  %x\n", val_temp);
+	val |= 0x100000 | (mode << PHY_LANE_CTRL_PHYMODE_POS);  /* Bit20: serdes reg reset Storm & Eagle B0 */
+	val &= ~(0x20000);
+        nlm_hal_write_mac_reg(node, block, PHY, lane_ctrl,val);
+	nlm_mdelay(1);
+		
+	val = nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl);
+	val |= 0x40000000; /* Unset the reset (inverse logic) : Bit30: epcs reset */
+        nlm_hal_write_mac_reg(node, block, PHY, lane_ctrl,val);
+	nlm_mdelay(1);
+	NAE_DEBUG(" After serdes  de-assertion PMA value=0x%x\n", nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl));
 
 
 	/* Clear the Power Down bit */
-	NAE_DEBUG("Clearing the Power Down Bit(Bit 29)\n");
 	val = nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl);
-	NAE_DEBUG("Just read the value in register as %x\n", val);
 	val &= ~( (1 << 29) | (0x7ffff));
-	nlm_hal_write_mac_reg(node, block, PHY, lane_ctrl, val);
-	val_temp=nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl);
-	NAE_DEBUG("PHY LANE CTRL REG that was just written is :  %x\n", val_temp);
-
-	NAE_DEBUG("Setting PMA Controller reset bit(Bit 30)\n");
-	val = nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl);
-	val |= 0x40000000; /* Unset the reset (inverse logic) : Bit30: epcs reset */
-	nlm_hal_write_mac_reg(node, block, PHY, lane_ctrl,val);
-	val_temp=nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl);
-	NAE_DEBUG("PHY LANE CTRL REG that was just written is :  %x\n", val_temp);
+	nlm_hal_write_mac_reg(node, block, PHY, lane_ctrl, (rext_sel | val));
+	nlm_mdelay(1);
 
 	while ((nlm_hal_read_mac_reg(node, block, PHY, (lane_ctrl - 4)) & (PHY_LANE_STAT_PCR)) != (PHY_LANE_STAT_PCR) && count!=count_max) 
 	{
@@ -3020,7 +2999,7 @@ static int nae_freein_fifo_cfg(void *fdt, int node, nlm_nae_config_ptr nae_cfg)
 		reg = (2 << 24) | th_lo | (th_hi << 12);
 		nlm_hal_write_nae_reg(node, FREE_FIFO_THRESHOLD_CFG, reg); 
 
-		if(spill_addr > (spill_mem_addr + spill_mem_size)) {
+		if((spill_addr << 6) > (spill_mem_addr + spill_mem_size)) {
 			nlm_print("ERROR : Spill address range overflow\n");
 			return -1;
 		}
@@ -3117,15 +3096,17 @@ static int get_interface_type(void *fdt, char *nae_port_str, int block, int port
 {
 	int intf_type, offset;
 	nlm_nae_config_ptr nae_cfg = nlm_node_cfg.nae_cfg[node];
-#ifndef NLM_HAL_UBOOT
 	char port_type_str[MAX_PROP_LEN];
-#endif
 
-#ifdef SKIP_INTERFACE_TYPE_FROMCPLD
-	intf_type = DC_NOT_PRSNT;
-#else
-	intf_type = nlm_get_interface_type(node, block);
-#endif
+	if (GET_PORT_STR_PROP("cpld", port_type_str, MAX_PROP_LEN) < 0) {
+			nlm_print("FDT missing cpld param for complex. port detection could be supported %d\n", block);
+	}
+	if (!strcmp(port_type_str, "no")) {
+		nlm_print("Detection from CPLD not supported. Reading configuration from sysconf for block %d\n", block);
+		intf_type = DC_NOT_PRSNT;
+        }else{
+		intf_type = nlm_get_interface_type(node, block);
+	}
 
 #ifdef CONFIG_N511
 	if (block == 4) {
@@ -3135,7 +3116,6 @@ static int get_interface_type(void *fdt, char *nae_port_str, int block, int port
 		intf_type = DC_XAUI;
 	}
 #endif
-#ifndef NLM_HAL_UBOOT
 	if (intf_type == DC_NOT_PRSNT) {
 		if (GET_PORT_STR_PROP("mode", port_type_str, MAX_PROP_LEN) < 0) {
 			nlm_print("FDT missing mode param for complex %d\n", block);
@@ -3170,7 +3150,6 @@ static int get_interface_type(void *fdt, char *nae_port_str, int block, int port
 			intf_type = DC_RXAUI;
 		}
 	}
-#endif
 
         switch(intf_type) {
                 case DC_SGMII:
@@ -4408,7 +4387,7 @@ void nlm_hal_xaui_pcs_init(int node, nlm_nae_config_ptr nae_cfg)
 	int lane_enable = 0;
 	int phy_mode = (nae_cfg->rxaui_complex_map) ?  PHYMODE_RXAUI : PHYMODE_XAUI;
 	static int vsemi_por=0;
-	int xaui_cplx_mask = nae_cfg->xaui_complex_map;
+	int xaui_cplx_mask = nae_cfg->xaui_complex_map | nae_cfg->rxaui_complex_map;
 	
 
 	if (xaui_cplx_mask == 0) {
@@ -4457,8 +4436,16 @@ void nlm_hal_xaui_pcs_init(int node, nlm_nae_config_ptr nae_cfg)
 		
 		if(is_nlm_xlp2xx()){
 			int delay;
-			struct nlm_hal_nae_port *portcfg = &nae_cfg->ports[block];
-			int xaui_speed = portcfg->xgmii_speed;
+			int port;
+			struct nlm_hal_nae_port *portcfg;
+			int xaui_speed;	 	
+			if(nae_cfg->num_ports>2)
+				port = block<<2;
+			else 
+				port = block;	
+			
+			portcfg = &nae_cfg->ports[port];
+			xaui_speed = portcfg->xgmii_speed;
 			if(xaui_speed==16){
 				nlm_print("VSEMI: config data for 16G XAUI \n");
 				nlm_hal_config_vsemi_mem_16G_4page_125();
@@ -4470,7 +4457,7 @@ void nlm_hal_xaui_pcs_init(int node, nlm_nae_config_ptr nae_cfg)
 				nlm_hal_config_vsemi_mem_12G_125();
 			}	
 			else {
-				nlm_print("VSEMI: config data for 10G XAUI \n");
+				nlm_print("VSEMI: config data for 10G XAUI/RXAUI \n");
 				nlm_hal_config_vsemi_mem_xaui_4page_125();
 				nlm_hal_config_vsemi_mem_xaui_125();	
 			}
@@ -4503,18 +4490,17 @@ void nlm_hal_xaui_pcs_init(int node, nlm_nae_config_ptr nae_cfg)
 				 vsemi_config = VSEMI_CTL_XAUI_16G_DR | VSEMI_CTL_XAUI_16G_DW;
 			else if(xaui_speed==12)
 				 vsemi_config = VSEMI_CTL_XAUI_12G_DR | VSEMI_CTL_XAUI_12G_DW;
+			else if((PHYMODE_RXAUI==phy_mode) && (xaui_speed==10)) {
+				 vsemi_config = VSEMI_CTL_RXAUI_10G_DR | VSEMI_CTL_RXAUI_10G_DW;
+			}
 			else //XAUII/10G
 				 vsemi_config = VSEMI_CTL_XAUI_DR | VSEMI_CTL_XAUI_DW;
 			
 			for(delay=0; delay<1000000; delay++);
 			nlm_hal_write_mac_reg(node, block, PHY, VSEMI_CTL1, vsemi_config);
 				
-			if(xaui_speed){
-				nlm_hal_xlp2xx_nae_program_vsemi(node, block, xaui_speed, 0);
-			}else{
-				/*Only XAUII*/
-				nlm_hal_xlp2xx_nae_program_vsemi(node, block, 0, PHYMODE_XAUI);
-			}
+			nlm_hal_xlp2xx_nae_program_vsemi(node, block, xaui_speed, 0);
+			
 #ifdef VSEMI_DEBUG
 			display_vsemi_indirect_reg(node, block);
 #endif
@@ -6193,15 +6179,19 @@ static void dump_buffer(unsigned char *buf, unsigned int len, unsigned char *msg
 
 void nlm_hal_msec_set_tx_key(int node, int index, unsigned char *key)
 {
-	unsigned int cntrl_reg_val = (1 << 22 | (index & 0x7ff));
+	unsigned int cntrl_reg_val = (1 << 22 | (index & 0x7ff)), local_key;
 	
-	nlm_hal_write_nae_reg(node, TX_MSEC_MEM_DATAREG_3, *(unsigned int*)key);
+	local_key = (key[0] << 24) | (key[1] << 16) | (key[2] << 8) | key[3];
+	nlm_hal_write_nae_reg(node, TX_MSEC_MEM_DATAREG_3, local_key);
 	key = key+4;
-	nlm_hal_write_nae_reg(node, TX_MSEC_MEM_DATAREG_2, *(unsigned int*)key);
+	local_key = (key[0] << 24) | (key[1] << 16) | (key[2] << 8) | key[3];
+	nlm_hal_write_nae_reg(node, TX_MSEC_MEM_DATAREG_2, local_key);
 	key = key+4;
-	nlm_hal_write_nae_reg(node, TX_MSEC_MEM_DATAREG_1, *(unsigned int*)key);
+	local_key = (key[0] << 24) | (key[1] << 16) | (key[2] << 8) | key[3];
+	nlm_hal_write_nae_reg(node, TX_MSEC_MEM_DATAREG_1, local_key);
 	key = key+4;
-	nlm_hal_write_nae_reg(node, TX_MSEC_MEM_DATAREG_0, *(unsigned int*)key);
+	local_key = (key[0] << 24) | (key[1] << 16) | (key[2] << 8) | key[3];
+	nlm_hal_write_nae_reg(node, TX_MSEC_MEM_DATAREG_0, local_key);
 
 	nlm_hal_write_nae_reg(node, TX_MSEC_MEM_CTRL_REG, cntrl_reg_val);
 }
@@ -6312,6 +6302,8 @@ void nlm_hal_msec_tx_config(int node, unsigned int port_enable, unsigned int pre
 #ifdef MACSEC_DEBUG
         nlm_print(" %s sec_tag_offset = %x %x sec_tag_preamble = %llx\n", __FUNCTION__, sec_tag_offset[0], sec_tag_offset[1], sec_tag_preamble);
 #endif
+	nae_cfg->msec_port_enable = port_enable;
+
 	/* ci offset = sectag_preamble + 16 (sectag header length)*/
 	while(port_enable)
 	{
diff --git a/arch/mips/netlogic/common/platform.c b/arch/mips/netlogic/common/platform.c
new file mode 100644
index 0000000..d94676a
--- /dev/null
+++ b/arch/mips/netlogic/common/platform.c
@@ -0,0 +1,110 @@
+/*-
+ * Copyright 2004-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
+
+/*
+ * Copyright 2004, Matt Porter <mporter@kernel.crashing.org>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/resource.h>
+#include <asm/netlogic/nlm_srio.h>
+
+static u64 xls_usb_dmamask = ~(u32) 0;
+
+static struct platform_device xls_usb_ehci_device = {
+	.name = "ehci-xls",
+	.id = 0,
+	.num_resources = 2,
+	.dev = {
+		.dma_mask = &xls_usb_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+		},
+	.resource = (struct resource[]){
+					{
+					 .start = 0x1EF24000,
+					 .end = (0x1EF24000 + 0x400 - 0x01),
+					 .flags = IORESOURCE_MEM,
+					 },
+					{
+					 .start = 39,
+					 .end = 39,
+					 .flags = IORESOURCE_IRQ,
+					 },
+					},
+};
+
+static struct platform_device xls_usb_ohci_device_0 = {
+	.name = "ohci-xls-0",
+	.id = 1,
+	.num_resources = 2,
+	.dev = {
+		.dma_mask = &xls_usb_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+		},
+	.resource = (struct resource[]){
+					{
+					 .start = 0x1EF24400,
+					 .end = (0x1EF24400 + 0x400 - 0x01),
+					 .flags = IORESOURCE_MEM,
+					 },
+					{
+					 .start = 39,
+					 .end = 39,
+					 .flags = IORESOURCE_IRQ,
+					 },
+					},
+};
+
+static struct platform_device xls_usb_ohci_device_1 = {
+	.name = "ohci-xls-1",
+	.id = 2,
+	.num_resources = 2,
+	.dev = {
+		.dma_mask = &xls_usb_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+		},
+	.resource = (struct resource[]){
+					{
+					 .start = 0x1EF24800,
+					 .end = (0x1EF24800 + 0x400 - 0x01),
+					 .flags = IORESOURCE_MEM,
+					 },
+					{
+					 .start = 39,
+					 .end = 39,
+					 .flags = IORESOURCE_IRQ,
+					 },
+					},
+};
+
+static struct platform_device *xls_platform_devices[] __initdata = {
+	&xls_usb_ehci_device,
+	&xls_usb_ohci_device_0,
+	&xls_usb_ohci_device_1,
+};
+
+int xls_platform_init(void)
+{
+    return platform_add_devices(xls_platform_devices, ARRAY_SIZE(xls_platform_devices));
+}
+
+arch_initcall(xls_platform_init);
+
+#ifdef CONFIG_RAPIDIO
+void platform_rio_init(void)
+{
+	nlm_rio_setup();
+}
+#endif				/* CONFIG_RAPIDIO */
diff --git a/arch/mips/netlogic/common/smp.c b/arch/mips/netlogic/common/smp.c
index 6a1c325..1a629a2 100644
--- a/arch/mips/netlogic/common/smp.c
+++ b/arch/mips/netlogic/common/smp.c
@@ -1,28 +1,34 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
-
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+
+#include <asm/netlogic/64bit.h>
 #include <asm/addrspace.h>
 #include <asm/smp.h>
 #include <linux/sched.h>
diff --git a/arch/mips/netlogic/xlp/Makefile b/arch/mips/netlogic/xlp/Makefile
index 123c14f..6905659 100644
--- a/arch/mips/netlogic/xlp/Makefile
+++ b/arch/mips/netlogic/xlp/Makefile
@@ -1,12 +1,14 @@
 EXTRA_CFLAGS := -Werror
 EXTRA_CFLAGS := $(CFLAGS) -DNLM_HAL_LINUX_KERNEL -Iarch/mips/include/asm/netlogic/hal
 
-obj-y                    	= setup.o mmu.o
-obj-y 				+= irq.o time.o on_chip.o
-obj-$(CONFIG_NLM_XLP) 		+= platform.o board.o
-obj-$(CONFIG_NLM_XLP) 		+= xlp_hal_pic.o xlp_gpio.o i2c.o
+obj-y                    	= setup.o
+obj-y 				+= irq.o time.o on_chip.o mmu.o
+obj-$(CONFIG_NLM_XLP) 		+= platform.o board.o  xlp_gpio.o xlp_hal_pic.o i2c.o
 obj-$(CONFIG_SMP)       	+= smp.o
 obj-y				+= pic/
 
+obj-$(CONFIG_KGDB)      += nmi.o
+obj-$(CONFIG_NLM_XLP) += cop2.o
+
 obj-$(CONFIG_NLM_XLP) += cpu_control.o cpu_control_asm.o nmi.o
 obj-$(CONFIG_NUMA) += numa.o
diff --git a/arch/mips/netlogic/xlp/cop2.S b/arch/mips/netlogic/xlp/cop2.S
new file mode 100644
index 0000000..a4e3f99
--- /dev/null
+++ b/arch/mips/netlogic/xlp/cop2.S
@@ -0,0 +1,128 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+
+
+#include <asm/addrspace.h>
+#include <asm/asm.h>
+#include <asm/mipsregs.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+#include <asm/netlogic/interrupt.h>
+#include <asm/asm-offsets.h>
+
+#ifdef CONFIG_NLM_ENABLE_COP2
+/*
+ * void nlm_cop2_save()
+ * sp is assumed to point to a struct pt_regs
+ *
+ * NOTE: This is called in SAVE_SOME in stackframe.h. It can only
+ *       safely modify k0 and k1.
+ */
+	.align	7
+	.set push
+	.set noreorder
+	LEAF(nlm_cop2_save)
+	/*msgring tx buf reg*/
+	dmfc2 k0, $0, 0
+	LONG_S  k0, NLM_COP2_TX_BUF(sp)
+	dmfc2 k0, $0, 1
+	LONG_S  k0, (NLM_COP2_TX_BUF+8)(sp)
+	dmfc2 k0, $0, 2
+	LONG_S k0, (NLM_COP2_TX_BUF+16)(sp)
+	dmfc2 k0, $0, 3
+	LONG_S k0, (NLM_COP2_TX_BUF+24)(sp)
+	
+	/*msgring rx buf reg*/
+	dmfc2 k0, $1, 0
+	LONG_S  k0, NLM_COP2_RX_BUF(sp)
+	dmfc2 k0, $1, 1
+	LONG_S  k0, (NLM_COP2_RX_BUF+8)(sp)
+	dmfc2 k0, $1, 2
+	LONG_S  k0, (NLM_COP2_RX_BUF+16)(sp)
+	dmfc2 k0, $1, 3
+	LONG_S  k0, (NLM_COP2_RX_BUF+24)(sp)
+
+	mfc2 k0, $2, 0
+	sw  k0, NLM_COP2_TX_MSG_STATUS(sp)
+	
+	mfc2 k0, $3, 0
+	jr	ra
+	sw k0, NLM_COP2_RX_MSG_STATUS(sp)
+
+	END(nlm_cop2_save)
+	.set pop
+
+/*
+ * void nlm_cop2_restore()
+ * sp is assumed to point to a struct pt_regs
+ *
+ * NOTE: This is called in RESTORE_SOME in stackframe.h.
+ */
+	.align	7
+	.set push
+	.set noreorder
+	LEAF(nlm_cop2_restore)
+	/*msgring tx buf reg*/
+	LONG_L  v1, NLM_COP2_TX_BUF(sp)
+	dmtc2 v1, $0, 0
+	LONG_L  v1, (NLM_COP2_TX_BUF+8)(sp)
+	dmtc2 v1, $0, 1
+	LONG_L  v1, (NLM_COP2_TX_BUF+16)(sp)
+	dmtc2 v1, $0, 2
+	LONG_L  v1, (NLM_COP2_TX_BUF+24)(sp)
+	dmtc2 v1, $0, 3
+
+	/*msgring rx buf reg*/
+	LONG_L  v1, NLM_COP2_RX_BUF(sp)
+	dmtc2 v1, $1, 0
+	LONG_L  v1, (NLM_COP2_RX_BUF+8)(sp)
+	dmtc2 v1, $1, 1
+	LONG_L  v1, (NLM_COP2_RX_BUF+16)(sp)
+	dmtc2 v1, $1, 2
+	LONG_L  v1, (NLM_COP2_RX_BUF+24)(sp)
+	dmtc2 v1, $1, 3
+	lw  v1, NLM_COP2_TX_MSG_STATUS(sp)
+	mtc2 v1, $2, 0
+
+	/*leave bits 28-31 up to date*/
+	li k0, 0xf0000000
+	lw v1, NLM_COP2_RX_MSG_STATUS(sp)
+	or v1, k0, v1
+	xor v1, k0, v1
+	mfc2 k0, $3, 0
+	srl k0, k0, 28
+	sll k0, k0, 28
+	or v1, k0, v1
+	jr	ra
+	mtc2 v1, $3, 0
+	END(nlm_cop2_restore)
+	.set pop
+#endif
+
diff --git a/arch/mips/netlogic/xlp/cpu_control.c b/arch/mips/netlogic/xlp/cpu_control.c
index 4ec469f..55c95ee 100644
--- a/arch/mips/netlogic/xlp/cpu_control.c
+++ b/arch/mips/netlogic/xlp/cpu_control.c
@@ -1,27 +1,32 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (Netlogic). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
 
 #include <linux/spinlock.h>
 #include <linux/mm.h>
@@ -39,15 +44,14 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <linux/interrupt.h>
 #include <asm/atomic.h>
 #include <asm/cacheflush.h>
-
+#include <asm/netlogic/xlp8xx/cpu_control_macros.h>
 #include <asm/netlogic/xlp.h>
 #include <asm/netlogic/hal/nlm_hal.h>
 
-#include "cpu_control_macros.h"
-
 #define XLP_ECFG_BASE           0x18000000
 #define XLP_SYS_DEV_BASE        0x35000
-#define PLL_REF_CLK_PS		7500
+#define PLL_REF_CLK_PS_133MHz	7500
+#define PLL_REF_CLK_PS_66MHz	15000
 
 /* temporary storage space for
  * stack pointers
@@ -59,6 +63,7 @@ unsigned long linuxsp[NR_CPUS];
 extern unsigned char __stack[];
 extern char boot_siblings_start[], boot_siblings_end[];
 extern char reset_entry[], reset_entry_end[];
+extern int  is_nlm_xlp2xx_compat;
 
 static inline void jump_address(unsigned long entry)
 {
@@ -129,10 +134,11 @@ static void enable_cores(unsigned int node, unsigned int cores_bitmap)
 
 		if ( (cbitmap & core) == 0) continue;
 
-		/* Enable CPU clock
-		 */
-		value = nlm_hal_read_32bit_reg(sys_mmio,0x4E) & ~core;
-		nlm_hal_write_32bit_reg(sys_mmio, 0x4E, value);
+		if (!is_nlm_xlp2xx_compat) {
+			/* Enable CPU clock: only needed for xlp8xx/xlp3xx */
+			value = nlm_hal_read_32bit_reg(sys_mmio,0x4E) & ~core;
+			nlm_hal_write_32bit_reg(sys_mmio, 0x4E, value);
+		}
 
 		/* Remove CPU Reset */
 		value = nlm_hal_read_32bit_reg(sys_mmio, 0x4B) & ~core;
@@ -229,6 +235,7 @@ static u32 get_pll_period(int divf,int divr) {
 
 	u32 vco_fs;		/* vco in femto-seconds */
 	u32 pll_period_fs;	/* pll output in femto-seconds */
+	u32 pll_ref_clk_ps;
 
 	if (divr == 2) {
 		printk (KERN_ERR "Error! Illegal divr value %d!\n", divr);
@@ -239,7 +246,12 @@ static u32 get_pll_period(int divf,int divr) {
 		return 0;
 	}
 
-	vco_fs = (((PLL_REF_CLK_PS * 1000) * (divr+1))/(4 * (divf+1)));
+	if(nlm_hal_is_ref_clk_133MHz())
+		pll_ref_clk_ps = PLL_REF_CLK_PS_133MHz;
+	else
+		pll_ref_clk_ps = PLL_REF_CLK_PS_66MHz;
+
+	vco_fs = (((pll_ref_clk_ps * 1000) * (divr+1))/(4 * (divf+1)));
 	pll_period_fs  = vco_fs * 2; /* pll output is divided by 2 */
 
 	return pll_period_fs;
@@ -257,32 +269,6 @@ static uint64_t get_pll_freq(int divf,int divr)
 	return hz_freq;
 }
 
-/* Return frequency in Hz
- */
-u32 get_cpu_freq(int cpu_num)
-{
-	volatile u32* mmio;
-	uint64_t pll_freq;
-	u32 pwron_rst_reg;
-	u32 core_dfs, divf, divr, dfs, core, ext_div;
-	mmio = (volatile u32 *) cpu_io_mmio(cpu_num/32,SYS);
-
-	pwron_rst_reg = nlm_hal_read_32bit_reg((uint64_t)mmio, SYS_POWERONRESETCFG);
-	core_dfs      = nlm_hal_read_32bit_reg((uint64_t)mmio, SYS_COREDFSDIVCTRL);
-	core          = cpu_num >> 2;
-
-	divf = SYS_PWRON_DIVF(pwron_rst_reg);
-	divr = SYS_PWRON_DIVR(pwron_rst_reg);
-	ext_div = SYS_PWRON_EXTDIV(pwron_rst_reg) + 1;
-	dfs  = SYS_CORE_DFS(core_dfs,core) + 1;
-
-	pll_freq = get_pll_freq(divf,divr);
-	do_div( pll_freq, ((uint64_t)(ext_div * dfs)));
-	return ((u32) pll_freq);
-}
-
-EXPORT_SYMBOL(get_cpu_freq);
-
 u32 get_core_dfs(int cpu_num)
 {
 	u32 core_dfs, dfs;
@@ -296,24 +282,3 @@ u32 get_core_dfs(int cpu_num)
 
 EXPORT_SYMBOL(get_core_dfs);
 
-/*
- * @cpu_num : # of the cpu
- * @dec	: whether to decrement frequency
- * NOTE: If frequency to be decremented, multiplier should be incremented
- */
-u32 change_cpu_freq(int cpu_num, int dec)
-{
-	volatile u32 *mmio;
-	u32 val;
-	/* INC freq --> DEC multiplier */
-	u32 reg = (dec == 1) ? SYS_COREDFSDIVINCCTRL: SYS_COREDFSDIVDECCTRL;
-
-	mmio = (volatile u32 *) cpu_io_mmio(cpu_num/32,SYS);
-	val = (0x1 << (cpu_num >> 2));
-	nlm_hal_write_32bit_reg((uint64_t)mmio, reg, val);
-	//printk("NLM: %#x\n", nlm_hal_read_32bit_reg((uint64_t)mmio, SYS_COREDFSDIVCTRL));
-	return 0;
-}
-
-EXPORT_SYMBOL(change_cpu_freq);
-
diff --git a/arch/mips/netlogic/xlp/cpu_control_asm.S b/arch/mips/netlogic/xlp/cpu_control_asm.S
index d9e5a28..9271ac9 100644
--- a/arch/mips/netlogic/xlp/cpu_control_asm.S
+++ b/arch/mips/netlogic/xlp/cpu_control_asm.S
@@ -1,3 +1,32 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
 #include <asm/asm.h>
 #include <asm/asm-offsets.h>
 #include <asm/regdef.h>
@@ -5,9 +34,8 @@
 #include <asm/stackframe.h>
 #include <asm/asmmacro.h>
 
-#include <asm/netlogic/mips-exts.h>
 #include <asm/mach-netlogic/kernel-entry-init.h>
-#include "cpu_control_macros.h"
+#include <asm/netlogic/xlp8xx/cpu_control_macros.h>
 
 	.macro  prog_c0_status set clr
 	.set 	push
@@ -89,7 +117,6 @@
 	li      t0, LSU_DEFEATURE
 
 	mfcr    t1, t0
-
 	lui     t2, 0x4080  # Enable Unaligned Access, L2HPE
 	or      t1, t1, t2
 	mtcr    t1, t0
@@ -108,6 +135,75 @@
 	.set pop
 .endm
 
+.macro	if_xlp2xx_a0_then_disable_2way_l1_dcache
+	.set push
+	.set noreorder
+
+        mfc0    t0,$15,0
+        andi    t0,t0,0xffff
+        addiu   t0,t0,-0x1200
+        bne     t0,$0,12f
+        nop
+
+	li    t0, 0x80000000
+	li    t1, 0x80010000
+11:    cache 1 ,0(t0)
+	addiu t0, t0, 32
+	sub   t2, t1, t0
+	bnez  t2, 11b
+	nop
+
+/* LSU Defature 0x304: 0x7a406038
+ *------7
+ * 31:0 SEU Speculative Unmap Enable
+ * 30:1 EUL Enable Unaligned load/Store Operation
+ * 29:1 HLFR Hold LMQ Full Retry
+ * 28:1 HTR  Hold TLB Retry
+ *------A
+ * 27:1 HLR Hold LMQ Retry
+ * 26:0 HPP Hardware Prefretch hard Partition
+ * 25:1 L2HPT1 L2 Hardware Prefetch Threshold.
+ * 24:0 L2HPT0 00:no limit; 01:>=5; 10:>=9; 11:>=12
+ *------4
+ * 23:0 L2 Hardware Prefetch Enable
+ * 22:1 L1HPT1 L1 Hardware Prefetch Enable
+ * 21:0 L1HPT0 00:no limit; 01:>=5; 10:>=9; 11:>=12
+ * 20:0 L1HPE L1 Hardware Prefetch Enable
+ *------0
+ * 19:0 LIPD load instruction prefect disable
+ * 18:0 RZ_18 Always read as zero; writes have no effect.
+ * 17:0 RZ_17 Always read as zero; writes have no effect.
+ * 16:0 Way3 disable
+ *------6
+ * 15:0 Way2 disable
+ * 14:1 Way1 disable
+ * 13:1 Way0 disable
+ * 12:0 RZ_12
+ *------0
+ * 11:0 RZ_11
+ * 10:0 RZ_10
+ *  9:0 RZ_9
+ *  8:0 RZ_8
+ *------3
+ *  7:0 RZ_7
+ *  6:0 RZ_6
+ *  5:1 S1RCM Stage-1 Retry Count Mask
+ *  4:1 S1RCM
+ *------8
+ *  3:1 S1RCM
+ *  2:0 S1RCM
+ *  1:0 S1RCM
+ *  0:0 RZ_0
+ */
+	li      t0, 0x304
+	li      t1, 0x7a406038
+	mtcr    t1, t0
+	ehb
+12:
+	nop
+	.set pop
+.endm
+
 .macro	flush_l1_dcache
 	.set push
 	.set noreorder
@@ -236,6 +332,8 @@ EXPORT(__boot_siblings)				/* T0 of every core in every node starts from here */
 
 	flush_l1_dcache
 
+	if_xlp2xx_a0_then_disable_2way_l1_dcache
+
 	mfc0    t3, CP0_EBASE, 1
 	srl     t3, t3 , 2
 	and     t3, t3 , 0x7  			/* t3 contains the core number */
@@ -305,9 +403,7 @@ END(ptr_smp_boot)
  */
 NESTED(prom_pre_boot_secondary_cpus, 16, sp)
         SET_MIPS64
-#if defined(CONFIG_NLM_XLP) && defined(CONFIG_MAPPED_KERNEL)
         MAPPED_KERNEL_SETUP_TLB
-#endif
 
 	/* Don't trust the bootstrapper to set cp0_status to what you want */
 #ifdef CONFIG_64BIT
diff --git a/arch/mips/netlogic/xlp/cpu_control_macros.h b/arch/mips/netlogic/xlp/cpu_control_macros.h
deleted file mode 100644
index 673775e..0000000
--- a/arch/mips/netlogic/xlp/cpu_control_macros.h
+++ /dev/null
@@ -1,32 +0,0 @@
-#ifndef __CPUCONTROL_MACROS_H__
-#define __CPUCONTROL_MACROS_H__
-#include <asm/netlogic/xlp8xx/cpu.h>
-#include <asm/netlogic/xlp8xx/xlp_sys.h>
-#define CP0_EBASE	$15
-#ifdef CONFIG_64BIT
-#define NMI_BASE    	0xffffffffbfc00000UL
-#else
-#define NMI_BASE        0xbfc00000UL	
-#endif
-#define NMI_BASE_ASM   	0xbfc00000
-
-#define LSU_DEFEATURE 0x304
-#define LSU_DEBUG_ADDR  0x305
-#define LSU_DEBUG_DATA0	0x306
-#define MMU_SETUP 0x400
-#define SCHED_DEFEATURE 0x700
-
-#ifndef __ASSEMBLY__
-#define	 XLP_THREADS_PER_CORE	4
-#define  XLP_CORES_PER_NODE	7
-u32 get_cpu_freq(int);
-void enable_cpus(unsigned int, unsigned int);
-u32 get_core_dfs(int);
-u32 change_cpu_freq(int, int);
-extern int xlp8xx_a01_workaround_needed;
-#define get_cpu_freq_masked(cpu_num, mask)\
-	((get_cpu_freq(cpu_num)/1000ULL) & (mask))
-#define XLP_FREQ_MASK	(0xfffffff0)
-#define XLP_CPU0	0
-#endif	// __ASSEMBLY__
-#endif /* __CPUCONTROL_MACROS_H__ */
diff --git a/arch/mips/netlogic/xlp/nmi.S b/arch/mips/netlogic/xlp/nmi.S
index 9d41cc5..515c89b 100644
--- a/arch/mips/netlogic/xlp/nmi.S
+++ b/arch/mips/netlogic/xlp/nmi.S
@@ -1,27 +1,32 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems ("Netlogic")�~l rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
 
 #include <linux/init.h>
 
@@ -44,10 +49,70 @@ NESTED(nlm_except_vec_nmi, 0, sp)
 	.set noat
 	.set mips64
 	.set noreorder
-	sll 	zero, 3		# ehb
+	sll 	zero, 3              # ehb
+#ifdef CONFIG_KGDB
+	MTC0	k0, OS_KGDB_SCRATCH_REG6
+	nop
+	nop
+	PTR_LA	k0, nlm_nmi_kgdb_handler
+	jr       k0
+	nop
+#else
 1:	wait
 	b	1b
 	nop
+#endif
 	.set pop
 END(nlm_except_vec_nmi)
 
+#ifdef CONFIG_KGDB
+	/* This nmi handler is currently only for taking oprofile samples
+	   on non-zero cpus
+	   */
+NESTED(nlm_nmi_kgdb_handler, PT_SIZE,  sp)
+	.set	push
+	.set	noat
+	.set noreorder
+	.set 	mips64
+
+	/* Save K0 and K1 first */
+	/* K0 is already saved in nlm_except_vec_nmi */
+	MTC0	k1, OS_KGDB_SCRATCH_REG7
+
+	/* Clear the  NMI and BEV bits */
+	MFC0	k0, CP0_STATUS
+	li 	k1, 0xffb7ffff
+	and	k0, k0, k1
+	MTC0	k0, CP0_STATUS
+
+	SAVE_ALL
+	CLI
+	TRACE_IRQS_OFF
+
+	li	a0, NLM_IRQ_IPI_SMP_KGDB
+	move	a1, sp
+	/* jal	do_nlm_common_IRQ */
+	/* nop */
+	jal	nlm_kgdb_call_nmi_hook
+	nop
+
+	RESTORE_ALL
+
+	/*
+	MFC0 	k0, $15, 1
+	andi	k0, 0x1f
+	sll	k0, 2
+	la	k1, nlm_cpus_in_nmi
+ 	PTR_ADDU	k1, k0
+	sw	zero, 0(k1)
+	*/
+
+	MFC0	k0, OS_KGDB_SCRATCH_REG6
+	MFC0	k1, OS_KGDB_SCRATCH_REG7
+
+	.set mips3
+	eret
+
+	.set pop
+END(nlm_nmi_kgdb_handler)
+#endif
diff --git a/arch/mips/netlogic/xlp/on_chip.c b/arch/mips/netlogic/xlp/on_chip.c
index 534ed5c..11696f4 100644
--- a/arch/mips/netlogic/xlp/on_chip.c
+++ b/arch/mips/netlogic/xlp/on_chip.c
@@ -1,27 +1,32 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
 
 #include <linux/types.h>
 #include <linux/init.h>
@@ -229,6 +234,31 @@ static uint16_t xlp3xx_vc_to_handle_map[MAX_VC] = {
 	[512 ... 4095]= XLP_MSG_HANDLE_INVALID
 };
 
+static uint16_t xlp2xx_vc_to_handle_map[MAX_VC] = {
+	[0 ... 15] = XLP_MSG_HANDLE_CPU0,
+	[16 ... 31] = XLP_MSG_HANDLE_CPU1,
+	[32 ... 127] = XLP_MSG_HANDLE_INVALID,
+	[128 ... 143] = XLP_MSG_HANDLE_CPU0,
+	[144 ... 159] = XLP_MSG_HANDLE_CPU1,
+	[160 ... 255] = XLP_MSG_HANDLE_INVALID,
+	[256 ... 257] = XLP_MSG_HANDLE_PCIE0,
+	[258 ... 259] = XLP_MSG_HANDLE_PCIE1,
+	[260 ... 261] = XLP_MSG_HANDLE_PCIE2,
+	[262 ... 263] = XLP_MSG_HANDLE_PCIE3,
+	[264 ... 265] = XLP_MSG_HANDLE_DTRE,
+	[266 ... 267] = XLP_MSG_HANDLE_CMP,
+	[268 ... 271] = XLP_MSG_HANDLE_REGX,
+	[272 ... 272] = XLP_MSG_HANDLE_RSA_ECC,
+	[273 ... 275] = XLP_MSG_HANDLE_INVALID,
+	[276 ... 276] = XLP_MSG_HANDLE_CRYPTO,
+	[277 ... 383] = XLP_MSG_HANDLE_INVALID,
+	[384 ... 391] = XLP_MSG_HANDLE_NAE_0,
+	[392 ... 431] = XLP_MSG_HANDLE_INVALID,
+	[432 ... 503] = XLP_MSG_HANDLE_NAE_0,
+	[504 ... 4095]= XLP_MSG_HANDLE_INVALID
+
+};
+
 /******************************************************************************************
  *  dummy_handler 
  *
@@ -285,6 +315,7 @@ int nlm_xlp_register_napi_vc_handler(int vc, int (*handler)(int vc, int budget))
 }
 EXPORT_SYMBOL(nlm_xlp_register_napi_vc_handler);
 
+
 int nlm_xlp_unregister_napi_vc_handler(int vc)
 {
 	if(vc < 0 || vc >= NLM_MAX_VC_PER_THREAD) {
@@ -353,18 +384,16 @@ EXPORT_SYMBOL(nlm_xlp_unregister_intr_vc);
  ********************************************************************/
 void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 {
-	unsigned long mflags;
 	int vc = 0;
 	uint32_t size = 0, code = 0, src_id = 0, cycles = 0;
 	struct msgstn_handler *handler = 0;
 	unsigned int status = 0;
-	uint64_t msg0, msg1, msg2, msg3;
+	uint64_t msg0 = 0, msg1 = 0, msg2 = 0, msg3 = 0;
 	unsigned int msg_status1 = 0, vc_empty_status = 0;
-	int loop = 0;
 	int cpu = hard_smp_processor_id();
 	int pop_vc_mask = nlm_cpu_vc_mask[cpu];
-	msg0 = msg1 = msg2 = msg3 = 0;
 	uint32_t napi_vc_mask = xlp_napi_vc_mask & pop_vc_mask;
+	unsigned long mflags; /* Currently unused */
 	unsigned int vcmask;
 
 	if (irq == XLP_IRQ_MSGRING_RVEC) {
@@ -415,7 +444,10 @@ void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 			if(status != 0)
 				continue;
 
-			if (is_nlm_xlp3xx()) {
+			if (is_nlm_xlp2xx()) {
+				handler = &msg_handler_map[xlp2xx_vc_to_handle_map[src_id]];
+			}
+			else if (is_nlm_xlp3xx()) {
 				handler = &msg_handler_map[xlp3xx_vc_to_handle_map[src_id]];
 			}
 			else {
@@ -434,7 +466,11 @@ void nlm_xlp_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
 	nlm_cpu_stat_update_msgring_cycles(read_c0_count() - cycles);
 
 	/* Clear VC interrupt status by writing 1s */
-	xlp_write_status1( (msg_status1 | (pop_vc_mask << 16)) );
+	if (is_nlm_xlp2xx()) {
+		xlp_write_msg_int((pop_vc_mask));
+	} else {
+		xlp_write_status1( (msg_status1 | (pop_vc_mask << 16)) );
+	}
 
         msgrng_access_disable(mflags);
 
@@ -447,15 +483,14 @@ static DEFINE_PER_CPU(struct timer_list, msg_int_bkup_timer);
 static int msg_handler_timer_enabled=0;
 static void msg_timer_handler(unsigned long data)
 {
-/*
 	int cpu = smp_processor_id();
 	struct timer_list *timer = &per_cpu(msg_int_bkup_timer, cpu);
-*/
+
+
 	nlm_xlp_msgring_int_handler(XLP_IRQ_MSGRING_RVEC, NULL);
-/*
+
 	timer->expires = jiffies + (HZ/100);
 	add_timer(timer);
-*/
 }
 void init_msg_bkp_timer(void *data)
 {
@@ -463,7 +498,7 @@ void init_msg_bkp_timer(void *data)
 	struct timer_list *timer = &per_cpu(msg_int_bkup_timer, cpu);
 
 	init_timer(timer);
-	timer->expires = jiffies + (HZ/100);
+	timer->expires = jiffies + 10;
 	timer->data = 0;
 	timer->function = msg_timer_handler;
 	add_timer(timer);
@@ -479,7 +514,10 @@ void xlp_poll_vc0_messages(void)
         unsigned int msg_status1 = 0, vc_empty_status = 0;
         int loop = 0;
         int pop_vc_mask = 0x1;
+#ifdef CONFIG_32BIT
 	unsigned long mflags;
+#endif
+
 #if 0
 	if (hard_smp_processor_id() != 0)
 		printk("Called handler on cpu %d from %s msgstatus: 0x%x\n",
@@ -538,6 +576,7 @@ int register_xlp_msgring_handler(int major,
 		if(msg_handler_timer_enabled == 0) {
 			msg_handler_timer_enabled = 1;
 			spin_unlock_irqrestore(&msgrng_lock, flags);
+			// init_msg_bkp_timer(0);	Not required, taken care by on_each_cpu()
 			on_each_cpu(init_msg_bkp_timer, 0, 1);
 			spin_lock_irqsave(&msgrng_lock, flags);
 		}
@@ -614,46 +653,6 @@ void nlm_nmi_cpus(unsigned int mask)
 		nlh_pic_w64r(0, XLP_PIC_IPI_CTL, (nmi << 31) | (1 << 16) | (cpumask_hi));
 }
 
-/* need COP2 to be accessible */
-static void on_chip_msgring_drain_msgs(void)
-{
-	unsigned long mflags;
-	int vc = 0;
-	uint32_t size = 0, code = 0, src_id = 0;
-	uint64_t msg0, msg1, msg2, msg3;
-	unsigned int msg_status1 = 0, vc_empty_status = 0;
-	int cpu = hard_smp_processor_id();
-	int pop_vc_mask = nlm_cpu_vc_mask[cpu];
-
-	msg0 = msg1 = msg2 = msg3 = 0;
-
-	/* loop is just to be safe, but should only hit once in theory */
-	for ( ; ; ) {
-		/* Read latest VC empty mask */
-		msg_status1 = xlp_read_status1();
-
-		vc_empty_status = (msg_status1 >> 24) & pop_vc_mask;
-		if (vc_empty_status == pop_vc_mask)
-			break;
-
-		for (vc = 0; vc < 4; vc++) {
-			if (!(pop_vc_mask & (1<<vc)))
-				continue;
-			(void) xlp_message_receive(vc, &src_id, &size, &code, &msg0, &msg1, &msg2, &msg3);
-		}
-	}
-}
-
-void on_chip_shutoff_msgring(void)
-{
-	uint32_t flags;
-
-	/* Need write interrupt vector to cp2 msgconfig register */
-	msgrng_access_enable(flags);
-	on_chip_msgring_drain_msgs();
-	xlp_write_config(0);
-	msgrng_access_disable(flags);
-}
 
 /*********************************************************************
  * enable_msgconfig_int 
@@ -661,157 +660,19 @@ void on_chip_shutoff_msgring(void)
  ********************************************************************/
 void enable_msgconfig_int(void)
 {
-	unsigned long flags  = 0;
+	unsigned long flags;
+	flags = 0; 		/* suppress compiler warning */
 	/* Need write interrupt vector to cp2 msgconfig register */
 	msgrng_access_enable(flags);
 	nlm_hal_set_fmn_interrupt(XLP_IRQ_MSGRING_RVEC);
 	msgrng_access_disable(flags);
 }
 
-/*
- * Initializes PIC ITE entries PRM 9.5.6.26
- * XLP restricts CPU affinity to 8 groups. They are,
- * 0 =>	Only cpu0/thread0; mask = 1
- * 1 => All CPUs/threads and nodes; mask = (~0 & online_cpu_mask) on all nodes
- * 2 => cpu0-1 on all nodes. mask = 0x000000ff& online_cpu_mask  on all nodes
- * 3 => cpu2-3 on all nodes; mask = 0x0000ff00 & online_cpu_mask on all nodes
- * 4 => cpu4-5 on all nodes; mask = 0x00ff0000 & online_cpu_mask on all nodes
- * 5 => cpu6-7 on all nodes; mask = 0xff000000 & online_cpu_mask on all nodes
- * 6 => cpu0-15 on all nodes; mask = 0x0000ffff & online_cpu_mask on all nodes
- * 7 => cpu15-31 on all nodes; mask = 0xffff0000 & online_cpu_mask on all nodes
- *
- * These are programmer defined groups and can be changed as warranted.
- *
- * FIXME: for NUMA, we assume all nodes will have identical intra-node cpu
- * online masks.
- */
-static struct cpumask xlp_ite_cpumask[XLP_ITE_ENTRIES];
-void xlp_pic_ite_init(const struct cpumask *tgt_mask)
-{
-	int i;
-	struct cpumask m;
-	u64 xlp_pic_base = XLP_BDF_BASE(0,0,4);
-	char buf[140];
-	u64 bitmask = 0;
-#ifdef CONFIG_NUMA
-	struct cpumask m1, m2;
-#endif
-
-#ifndef CONFIG_NUMA
-	printk(KERN_WARNING "Setting ITE entries only for 0-31 (Node 0) CPUs!\n");
-#endif
-	cpumask_clear(&m);
-	/* We manipulate only NODE0 ITE entries here */
-	for (i = 0; i < XLP_ITE_ENTRIES; i++) {
-		cpumask_clear(&xlp_ite_cpumask[i]);
-	}
-	cpumask_set_cpu(cpumask_first(tgt_mask), &xlp_ite_cpumask[0]);
-
-	/* Set 0-31 cpus, if present in cpu_online mask */
-	for (i = cpumask_first(tgt_mask); i < 32; ) {
-		bitmask |= (1ULL << i);
-		i = cpumask_next(i, tgt_mask);
-	}
-
-	/* Set 0-7 cpus */
-	for (i = 0; i < 8; i++) {
-		cpumask_set_cpu(i, &m);
-	}
-
-	cpumask_scnprintf(buf, 140, tgt_mask); fdebug("Target cpumask -> %s\n", buf);
-#ifndef CONFIG_NUMA
-	cpumask_copy(&xlp_ite_cpumask[1], tgt_mask);
-#else
-	cpumask_shift_left(&m1, &m, 8);
-	cpumask_or(&m1, &m1, &m);
-	cpumask_shift_left(&m2, &m1, 16);
-	cpumask_or(&m2, &m2, &m1);
-	cpumask_and(&m2, &m2, tgt_mask);
-	cpumask_copy(&xlp_ite_cpumask[1], &m2);
-#endif
-
-	/* logical and with cpuonline mask to get the actual mask */
-	cpumask_and(&xlp_ite_cpumask[2], &m, tgt_mask);
-	cpumask_shift_left(&xlp_ite_cpumask[3], &m, 8);
-	cpumask_and(&xlp_ite_cpumask[3], &xlp_ite_cpumask[3], tgt_mask);
-	cpumask_shift_left(&xlp_ite_cpumask[4], &m, 16);
-	cpumask_and(&xlp_ite_cpumask[4], &xlp_ite_cpumask[4], tgt_mask);
-	cpumask_shift_left(&xlp_ite_cpumask[5], &m, 24);
-	cpumask_and(&xlp_ite_cpumask[5], &xlp_ite_cpumask[5], tgt_mask);
-
-	cpumask_shift_left(&xlp_ite_cpumask[6], &m, 8);
-	cpumask_or(&xlp_ite_cpumask[6], &xlp_ite_cpumask[6], &m);
-	cpumask_shift_left(&xlp_ite_cpumask[7], &xlp_ite_cpumask[6], 16);
-	cpumask_and(&xlp_ite_cpumask[6], &xlp_ite_cpumask[6], tgt_mask);
-	cpumask_and(&xlp_ite_cpumask[7], &xlp_ite_cpumask[7], tgt_mask);
-
-
-	for (i = 0; i < XLP_ITE_ENTRIES; i++) {
-		cpumask_scnprintf(buf, 140, &xlp_ite_cpumask[i]);
-		printk(KERN_DEBUG "Supported CPUMASK (%d) -> %s\n", i, buf);
-	}
-
-#ifndef CONFIG_NUMA
-	/* Right shift by 1 is required by HAL, _DO_NOT_REMOVE_ */
-	nlm_hal_write_64bit_reg(xlp_pic_base, 0x94 >> 1, (0x00000001 & bitmask));
-	nlm_hal_write_64bit_reg(xlp_pic_base, 0x98 >> 1, (0xffffffff & bitmask));
-	nlm_hal_write_64bit_reg(xlp_pic_base, 0x9C >> 1, (0x000000ff & bitmask));
-	nlm_hal_write_64bit_reg(xlp_pic_base, 0xA0 >> 1, (0x0000ff00 & bitmask));
-	nlm_hal_write_64bit_reg(xlp_pic_base, 0xA4 >> 1, (0x00ff0000 & bitmask));
-	nlm_hal_write_64bit_reg(xlp_pic_base, 0xA8 >> 1, (0xff000000 & bitmask));
-	nlm_hal_write_64bit_reg(xlp_pic_base, 0xAC >> 1, (0x0000ffff & bitmask));
-	nlm_hal_write_64bit_reg(xlp_pic_base, 0xB0 >> 1, (0xffff0000 & bitmask));
-	/* We don't populate redirection to other nodes now */
-#else
-	for_each_online_node (i) {
-		/* Interrupt delivered only to local node */
-		int node_offset = (i >= 2) * 2;
-		int mask_shift = ((i == 1) || (i == 3)) * 32;
-
-		fdebug("Programming ITEs for Node %d\n", i);
-
-		xlp_pic_base = XLP_BDF_BASE(0, 0 + 8 * i, 4);
-
-		nlm_hal_write_64bit_reg(
-			xlp_pic_base,
-			(0x94 + node_offset) >> 1,
-			((uint64_t)(0x00000001 & bitmask)) << mask_shift);
-		nlm_hal_write_64bit_reg(
-			xlp_pic_base,
-			(0x98 + node_offset) >> 1,
-			((uint64_t)(0xffffffff & bitmask)) << mask_shift);
-		nlm_hal_write_64bit_reg(
-			xlp_pic_base,
-			(0x9C + node_offset) >> 1,
-			((uint64_t)(0x000000ff & bitmask)) << mask_shift);
-		nlm_hal_write_64bit_reg(
-			xlp_pic_base,
-			(0xA0 + node_offset) >> 1,
-			((uint64_t)(0x0000ff00 & bitmask)) << mask_shift);
-		nlm_hal_write_64bit_reg(
-			xlp_pic_base,
-			(0xA4 + node_offset) >> 1,
-			((uint64_t)(0x00ff0000 & bitmask)) << mask_shift);
-		nlm_hal_write_64bit_reg(
-			xlp_pic_base,
-			(0xA8 + node_offset) >> 1,
-			((uint64_t)(0xff000000 & bitmask)) << mask_shift);
-		nlm_hal_write_64bit_reg(
-			xlp_pic_base,
-			(0xAC + node_offset) >> 1,
-			((uint64_t)(0x0000ffff & bitmask)) << mask_shift);
-		nlm_hal_write_64bit_reg(
-			xlp_pic_base,
-			(0xB0 + node_offset) >> 1,
-			((uint64_t)(0xffff0000 & bitmask)) << mask_shift);
-	}
-#endif
-}
-
 atomic_t nlm_common_counters[NR_CPUS][NLM_MAX_COUNTERS] __cacheline_aligned;
 
+#if 0
 /*********************************************************************
- *  nlm_usb_init 
+ *  nlm_usb_init
  *
  ********************************************************************/
 static void nlm_usb_init (void) __attribute__((unused));
@@ -837,6 +698,7 @@ static void nlm_usb_init (void)
 		netlogic_write_reg(usb_mmio,  0, 0x01000000);
 	}
 }
+#endif
 
 
 /*********************************************************************
@@ -865,29 +727,11 @@ void nlm_enable_vc_intr(void)
 	}
 }
 
-/*********************************************************************
- * nlm_disable_vc_intr
- *********************************************************************/
-void nlm_disable_vc_intr(void)
-{
-	int cpu = hard_smp_processor_id();
-	int vc_index = 0;
-	int i = 0;
-
-	for(i=0; i<NLM_MAX_VC_PER_THREAD; i++)
-	{
-		if(nlm_cpu_vc_mask[cpu] & (1<<i)){
-			vc_index = (i + cpu*NLM_MAX_VC_PER_THREAD) & 0x7f;
-			/*enable interrupts*/
-			nlm_hal_disable_vc_intr(0,vc_index);
-		}
-	}
-}
 
 int xlp_fmn_poll(struct napi_struct *napi, int budget)
 {
 	int vc = 0;
-	uint32_t size = 0, code = 0, src_id = 0, cycles = 0;
+	uint32_t size = 0, code = 0, src_id = 0;
 	struct msgstn_handler *handler = 0;
 	unsigned int status = 0;
 	uint64_t msg0, msg1, msg2, msg3;
@@ -904,6 +748,7 @@ int xlp_fmn_poll(struct napi_struct *napi, int budget)
 	while(count < budget){
 		for( no_msg = 0, vc = 0; vc < 4; vc++)
 		{
+			
 			if(!(napi_vc_mask & (1<<vc)))
 				continue;
 	
@@ -932,6 +777,9 @@ int xlp_fmn_poll(struct napi_struct *napi, int budget)
 			if (is_nlm_xlp3xx()) {
 				hndlr_id = xlp3xx_vc_to_handle_map[src_id];
 			}
+			else if (is_nlm_xlp2xx()) {
+				hndlr_id = xlp2xx_vc_to_handle_map[src_id];
+			}
 			else {
 				hndlr_id = vc_to_handle_map[src_id];
 			}
@@ -959,6 +807,7 @@ int xlp_fmn_poll(struct napi_struct *napi, int budget)
 		napi_final_needed[cpu][hndlr_id] = 0;
 	}
 	
+
 	/*Ack fmn interrupts.*/
 	if(count < budget) {
 		uint32_t val;
@@ -969,10 +818,15 @@ int xlp_fmn_poll(struct napi_struct *napi, int budget)
 #endif
                 napi_complete(napi);
 		/* Need write vc into the register */
-		val =  _read_32bit_cp2_register(XLP_MSG_STATUS1_REG);
-		//val |= ((1 << vc) << 16);
-		val |= (napi_vc_mask << 16);
-		_write_32bit_cp2_register(XLP_MSG_STATUS1_REG, val);
+                if (is_nlm_xlp2xx()) {
+                        xlp_write_msg_int(napi_vc_mask);
+                }
+                else {
+			val =  _read_32bit_cp2_register(XLP_MSG_STATUS1_REG);
+			//val |= ((1 << vc) << 16);
+			val |= (napi_vc_mask << 16);
+			_write_32bit_cp2_register(XLP_MSG_STATUS1_REG, val);
+		}
 #ifdef CONFIG_32BIT
 		msgrng_access_disable(mflags);
 #endif
@@ -1024,6 +878,7 @@ static int xlp_napi_fmn_setup(void)
  *  
  ********************************************************************/
 extern void xlp_pic_init(u8);
+extern void xlp_ites_init(void);
 void on_chip_init(void)
 {
 	int i = 0, j = 0, node;
@@ -1042,6 +897,7 @@ void on_chip_init(void)
 			atomic_set(&nlm_common_counters[i][j], 0);
 		}
 	}
-	if(xlp_napi_vc_mask)
+	if(xlp_napi_vc_mask) {
 		xlp_napi_fmn_setup();
+	}
 }
diff --git a/arch/mips/netlogic/xlp/platform-xlp.c b/arch/mips/netlogic/xlp/platform-xlp.c
new file mode 100644
index 0000000..c27f7e2
--- /dev/null
+++ b/arch/mips/netlogic/xlp/platform-xlp.c
@@ -0,0 +1,322 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+
+#include <linux/dma-mapping.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/serial.h>
+#include <linux/serial_8250.h>
+#include <linux/pci.h>
+#include <linux/serial_reg.h>
+
+#include <asm/time.h>
+#include <asm/netlogic/hal/nlm_hal_macros.h>
+#include <asm/netlogic/hal/nlm_hal_pic.h>
+
+#define XLP_SOC_PCI_DRIVER "XLP SoC Driver"
+
+#define PCI_NETL_VENDOR             0x184E
+
+#define PCI_DEVID_DEFAULT           0x1000
+#define PCI_DEVID_BASE              (PCI_DEVID_DEFAULT + 0x00)
+
+#define PCI_DEVID_OFF_SBU           0x01
+#define PCI_DEVID_OFF_ICI           0x02
+#define PCI_DEVID_OFF_PIC           0x03
+#define PCI_DEVID_OFF_PCIE          0x04
+#define PCI_DEVID_OFF_CAM           0x05
+#define PCI_DEVID_OFF_USB           0x06
+#define PCI_DEVID_OFF_EHCI          0x07
+#define PCI_DEVID_OFF_OHCI          0x08
+#define PCI_DEVID_OFF_NET           0x09
+
+#define PCI_DEVID_OFF_POE           0x0A
+#define PCI_DEVID_OFF_MSG           0x0B
+#define PCI_DEVID_OFF_GDX           0x0C
+#define PCI_DEVID_OFF_SEC           0x0D
+#define PCI_DEVID_OFF_RSA           0x0E
+#define PCI_DEVID_OFF_CMP           0x0F
+
+#define PCI_DEVID_OFF_UART          0x10
+#define PCI_DEVID_OFF_I2C           0x11
+#define PCI_DEVID_OFF_GPIO          0x12
+#define PCI_DEVID_OFF_SYS           0x13
+#define PCI_DEVID_OFF_JTAG          0x14
+#define PCI_DEVID_OFF_NOR           0x15
+#define PCI_DEVID_OFF_NAND          0x16
+#define PCI_DEVID_OFF_SPI           0x17
+#define PCI_DEVID_OFF_MMC           0x18
+#define PCI_DEVID_OFF_LAST          0x19
+
+#define PCI_MAX_DEVICES             (PCI_DEVID_OFF_LAST + 1)
+
+#define UART_CLK 133333333
+
+#define MAX_NUM_UARTS 3
+
+struct soc_dev {
+	const char *name;
+	void (*probe)(struct pci_dev *pdev, unsigned long pci_cfg_dev_base);
+};
+
+const char *pci_cfg_dev_regs[16] = {
+	[0] = "Dev Info 0",
+	[1] = "Dev Info 1",
+	[2] = "Dev Info 2",
+	[3] = "Dev Info 3",
+	[4] = "Dev Info 4",
+	[5] = "Dev Info 5",
+	[6] = "Dev Info 6",
+	[7] = "Dev Info 7",
+	[8] = "Dev Scratch 0",
+	[9] = "Dev Scratch 1",
+	[10] = "Dev Scratch 2",
+	[11] = "Dev Scratch 3",
+	[12] = "Dev Msg Stn Info",
+	[13] = "Dev IRT Info",
+	[14] = "uCode Engine Info",
+	[15] = "SBB BW Weight Entry Info"
+};
+
+static struct pci_device_id soc_pci_table[PCI_MAX_DEVICES] __devinitdata;
+
+static struct plat_serial8250_port uart_ports[MAX_NUM_UARTS] = {
+	[MAX_NUM_UARTS - 1] = { .flags = 0 } /* tenetlogicnating condition */
+};
+
+static void nlmc_hal_pci_cfg(int devfn, unsigned long pci_cfg_dev_base)
+{
+	int i = 0;
+	unsigned int *cfg_base = (unsigned int *)pci_cfg_dev_base;
+
+	cfg_base += (0xC0 >> 2);
+	for (i = 0; i < 16; i++) {
+		unsigned int value = cfg_base[i];
+
+		if (!value) continue;
+/* 		printk("[%s]: reg[%s] = %08x\n", __FUNCTION__, pci_cfg_dev_regs[i], value); */
+	}
+}
+
+static void xlp_sbu_probe(struct pci_dev *pdev, unsigned long pci_cfg_dev_base)
+{
+}
+
+static void xlp_pic_probe(struct pci_dev *pdev, unsigned long pci_cfg_dev_base)
+{
+}
+
+static void xlp_cms_probe(struct pci_dev *pdev, unsigned long pci_cfg_dev_base)
+{
+}
+
+static void xlp_sys_probe(struct pci_dev *pdev, unsigned long pci_cfg_dev_base)
+{
+}
+
+static void xlp_default_probe(struct pci_dev *pdev, unsigned long pci_cfg_dev_base)
+{
+}
+
+unsigned int xlp_uart_in(struct uart_port *p, int offset)
+{
+	nlm_reg_t *mmio;
+	unsigned int value;
+
+	/* XLP uart does not need any mapping of regs */
+	offset = offset << p->regshift;
+	mmio = (nlm_reg_t *)(p->membase + offset);
+	value = netlogic_read_reg(mmio, 0);
+
+	return value;
+
+}
+
+void xlp_uart_out(struct uart_port *p, int offset, int value)
+{
+	nlm_reg_t *mmio;
+
+	/* XLP uart does not need any mapping of regs */
+	offset = offset << p->regshift;
+	mmio = (nlm_reg_t *)(p->membase + offset);
+	netlogic_write_reg(mmio, 0, value);
+}
+
+static void xlp_uart_probe(struct pci_dev *pdev, unsigned long pci_cfg_dev_base)
+{
+	static atomic_t num_uarts = ATOMIC_INIT(0);
+	int instance = atomic_inc_return(&num_uarts) - 1;
+
+	if (instance < 0 || instance >= (MAX_NUM_UARTS - 1)) {
+		printk("Request for Invalid uart port_%d\n", instance);
+		return ;
+	}
+
+ 	if (!instance) {
+		struct platform_device *uart = 0;
+
+		/* If this is the first instance of registration, create the platform device */
+
+		uart = platform_device_alloc("serial8250", PLAT8250_DEV_PLATFORM);
+		if (!uart) {
+			printk("Unable to allocate memory for UART platform device!\n");
+			return;
+		}
+
+		uart->dev.platform_data = &uart_ports[0];
+
+		if (platform_device_add(uart)) {
+			printk("Unable to register uart plaform device!\n");
+			return;
+		}
+		printk("Platform registered UART device\n");
+	}
+
+	uart_ports[instance].mapbase       = pci_cfg_dev_base + 0x100; /* skip PCI CFG header */
+	uart_ports[instance].membase       = (void __iomem *)uart_ports[instance].mapbase;
+	uart_ports[instance].irq           = PIC_UART_0_IRQ + instance;
+
+	uart_ports[instance].uartclk       = UART_CLK;
+	uart_ports[instance].iotype        = UPIO_NLM;
+	uart_ports[instance].flags         = UPF_SKIP_TEST|UPF_FIXED_TYPE|UPF_BOOT_AUTOCONF;
+	uart_ports[instance].type          = PORT_16550A;
+	uart_ports[instance].regshift      = 2;
+	uart_ports[instance].serial_in      = xlp_uart_in;
+	uart_ports[instance].serial_out      = xlp_uart_out;
+
+	printk("Platform added UART port_%d (irq=%d, @%lx)\n", instance,
+	       uart_ports[instance].irq, (unsigned long)uart_ports[instance].mapbase);
+
+	nlmc_hal_pci_cfg(pdev->devfn, pci_cfg_dev_base);
+}
+
+static struct soc_dev soc_devices[PCI_MAX_DEVICES] = {
+	[PCI_DEVID_OFF_SBU]  = {.name = "South Bridge",                      .probe = xlp_sbu_probe},
+	[PCI_DEVID_OFF_PIC]  = {.name = "Programmable Interrupt Controller", .probe = xlp_pic_probe},
+	[PCI_DEVID_OFF_MSG]  = {.name = "Central Messaging Station",         .probe = xlp_cms_probe},
+	[PCI_DEVID_OFF_UART] = {.name = "UART",                              .probe = xlp_uart_probe},
+	[PCI_DEVID_OFF_SYS]  = {.name = "Sys",                               .probe = xlp_sys_probe},
+};
+
+static int __devinit soc_device_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	unsigned long mmio_paddr = 0, mmio_size = 0;
+	void *mmio_vaddr = 0;
+	int irq;
+	int result;
+	int base_class, sub_class, prog_int;
+	int dev = (pdev->devfn >> 3) & 0x1f;
+
+	int dev_off = pdev->device - PCI_DEVID_BASE;
+	void (*probe)(struct pci_dev *, unsigned long);
+
+	int fn = (pdev->devfn & 0x7);
+	const int num_fns = 8;
+	const int pci_cfg_size = 0x1000;
+	unsigned long pci_cfg_dev_base = (unsigned long)(xlp_io_base + (dev * num_fns * pci_cfg_size)
+							 + (fn * pci_cfg_size));
+
+	base_class = (pdev->class >> 16) & 0xff;
+	sub_class = (pdev->class >> 8) & 0xff;
+	prog_int = (pdev->class >> 0) & 0xff;
+
+	result = pci_enable_device(pdev);
+	if (result) return result;
+
+	mmio_paddr = pci_resource_start(pdev, 0);
+	mmio_size = pci_resource_len(pdev, 0);
+	irq = pdev->irq;
+
+	if (mmio_paddr) {
+		result = pci_request_regions(pdev, XLP_SOC_PCI_DRIVER);
+		if (result) {
+			printk("[%s]: unable to pci_request_regions\n", __FUNCTION__);
+			return result;
+		}
+
+		mmio_vaddr = ioremap(mmio_paddr, mmio_size);
+		if (!mmio_vaddr) {
+			printk("[%s]: unable to ioremap\n", __FUNCTION__);
+			pci_release_regions(pdev);
+			return 1;
+		}
+	}
+
+	probe = soc_devices[dev_off].probe;
+	if (!probe) {
+		printk("No probe handler found for XLP device \"%s\"\n", soc_devices[dev_off].name);
+	}
+	else {
+		printk("Invoking probe handler for XLP device \"%s\"\n", soc_devices[dev_off].name);
+		probe(pdev, pci_cfg_dev_base);
+	}
+
+	return 0;
+}
+
+static struct pci_driver soc_driver = {
+	.name             = XLP_SOC_PCI_DRIVER,
+	.id_table         = soc_pci_table,
+	.probe            = soc_device_probe,
+};
+
+static int __init soc_device_init(void)
+{
+	int i = 0;
+
+	for (i = 0; i < PCI_MAX_DEVICES; i++) {
+		soc_pci_table[i].vendor        = PCI_NETL_VENDOR;
+		soc_pci_table[i].device        = PCI_DEVID_BASE + i;
+		soc_pci_table[i].subvendor     = PCI_ANY_ID;
+		soc_pci_table[i].subdevice        = PCI_ANY_ID;
+		soc_pci_table[i].driver_data   = 0;
+
+		if (soc_devices[i].name) continue;
+		soc_devices[i].name = "unrecognized";
+		soc_devices[i].probe = xlp_default_probe;
+	}
+	soc_pci_table[PCI_DEVID_OFF_LAST].vendor        = 0;
+	soc_pci_table[PCI_DEVID_OFF_LAST].device        = 0;
+	soc_pci_table[PCI_DEVID_OFF_LAST].subvendor     = 0;
+	soc_pci_table[PCI_DEVID_OFF_LAST].subdevice     = 0;
+	soc_pci_table[PCI_DEVID_OFF_LAST].driver_data   = 0;
+
+	return pci_register_driver(&soc_driver);
+}
+
+static void __init soc_device_exit(void)
+{
+	pci_unregister_driver(&soc_driver);
+}
+
+module_init(soc_device_init);
+module_exit(soc_device_exit);
+
+MODULE_DEVICE_TABLE(pci, soc_pci_table);
diff --git a/arch/mips/netlogic/xlp/platform.c b/arch/mips/netlogic/xlp/platform.c
index 1d78573..3c3b948 100644
--- a/arch/mips/netlogic/xlp/platform.c
+++ b/arch/mips/netlogic/xlp/platform.c
@@ -1,27 +1,32 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (Netlogic). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
 
 #include <linux/dma-mapping.h>
 #include <linux/kernel.h>
@@ -35,7 +40,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <linux/spinlock.h>
 
 #include <asm/time.h>
-#include <asm/netlogic/hal/nlm_hal_macros.h>
+#include <asm/netlogic/hal/nlm_hal.h>
 #include <asm/netlogic/xlp_irq.h>
 #include <asm/netlogic/xlp.h>
 #include <asm/netlogic/xlp_usb.h>
@@ -47,13 +52,16 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define XLP_MAX_FUNC		8
 #define MAX_DEV2DRV		10
 #define MAX_NUM_UARTS		4
-#define UART_CLK 		133333333
+#define UART_CLK_133MHz 133333333
+#define UART_CLK_66MHz   66666666
 #define XLP_UART_PORTIO_OFFSET	0x1000
 
 static struct plat_serial8250_port xlp_uart_port[MAX_NUM_UARTS];
 
 static u64 xlp_dev_dmamask = DMA_BIT_MASK(32);
 
+int xlp_usb_dev;
+
 enum driverType{
 	PLAT_DRV = 0,
 	PCI_DRV	 = 1
@@ -97,7 +105,11 @@ static void xlp_init_uart(int port_id)
         xlp_uart_port[port_id].membase       = (void __iomem *)xlp_uart_port[port_id].mapbase;
         xlp_uart_port[port_id].irq           = XLP_UART_IRQ(0, port_id);
 
-        xlp_uart_port[port_id].uartclk       = UART_CLK;
+	if(nlm_hal_is_ref_clk_133MHz())
+		xlp_uart_port[port_id].uartclk       = UART_CLK_133MHz;
+	else
+		xlp_uart_port[port_id].uartclk       = UART_CLK_66MHz;
+
         xlp_uart_port[port_id].iotype        = UPIO_NLM;
         xlp_uart_port[port_id].flags         = UPF_SKIP_TEST|UPF_FIXED_TYPE|UPF_BOOT_AUTOCONF;
         xlp_uart_port[port_id].type          = PORT_16550A;
@@ -129,17 +141,61 @@ static void xlp_usb_hw_start_controller(int node, int ctrl_no)
 	return;
 }
 
+static void xlp_usb3_hw_start_controller(int node, int ctrl_no)
+{
+	int val;
+	
+
+        val = usb_reg_read(node, ctrl_no, XLP2XX_USB_PHY_LOS_LEV);
+        val &= 0xfc0fffff;
+        val |= (0x27 << 20);
+        usb_reg_write(node, ctrl_no, XLP2XX_USB_PHY_LOS_LEV, val);
+
+        val = usb_reg_read(node, ctrl_no, XLP2XX_USB_REF_CLK);
+        val |= (1<<30);
+        usb_reg_write(node, ctrl_no, XLP2XX_USB_REF_CLK, val);
+
+        val = usb_reg_read(node, ctrl_no, XLP2XX_USB_PHY_TEST);
+        val &= 0xfffffffe;
+        usb_reg_write(node, ctrl_no, XLP2XX_USB_PHY_TEST, val);
+
+        val = usb_reg_read(node, ctrl_no, XLP_USB3_CTL);
+        usb_reg_write(node, ctrl_no, XLP_USB3_CTL, 0x2e02203);
+
+	/* mask bits [7:0] -- these are core interrupts */
+	usb_reg_write(node, ctrl_no, XLP_USB3_INT_MASK, 0x000fff01);
+
+	/* clear all interrupts */
+	usb_reg_write(node, ctrl_no, XLP_USB3_INT, 0xffffffff);
+
+	udelay(2000);
+
+	return;
+}
+
 static void xlp_usb_hw_start(void)
 {
 	int n, online;
 	int total=num_possible_nodes();
 
-	for(n=0; n<total; n++) {
-		online=node_online(n);
-		if(!online)	continue;
-
-		xlp_usb_hw_start_controller(n, 0);
-		xlp_usb_hw_start_controller(n, 3);
+	if (is_nlm_xlp2xx())
+		xlp_usb_dev = XLP_PCIE_USB3_DEV;
+	else
+		xlp_usb_dev = XLP_PCIE_USB_DEV;
+
+	for (n = 0; n < total; n++) {
+		online = node_online(n);
+		if(!online)
+			continue;
+
+		if (is_nlm_xlp2xx()) {
+			xlp_usb3_hw_start_controller(n, 1);
+			xlp_usb3_hw_start_controller(n, 2);
+			xlp_usb3_hw_start_controller(n, 3);
+		} else {
+			xlp_usb_hw_start_controller(n, 0);
+			xlp_usb_hw_start_controller(n, 3);
+		}
 	}
 }
 
@@ -166,11 +222,19 @@ static int get_dev2drv(uint32_t x)
 
 static int xlp_find_pci_dev(void)
 {
-	uint16_t i, j, id, idx = 0;
+	uint16_t i, j, id, idx = 0, maxdevice=0;
 	volatile uint64_t mmio;
 	uint32_t val, devid, vid, irt, irq;
 	struct platform_device* pplatdev;
 	struct resource* pres;
+	int total=num_possible_nodes();
+
+	for(i=0; i<total; i++) {
+		j=node_online(i);
+		if(!j)     continue; 
+		maxdevice += XLP_MAX_DEVICE;
+	}	
+	
 
 	pres = (struct resource*) kzalloc(sizeof(struct resource) * 2, GFP_KERNEL);
 
@@ -179,7 +243,7 @@ static int xlp_find_pci_dev(void)
 		return -ENOMEM;
 	}
 
-	for (i=0; i<XLP_MAX_DEVICE; i++) {
+	for (i=0; i<maxdevice; i++) {
 
 		for (j=0; j<XLP_MAX_FUNC; j++) {
 
@@ -192,6 +256,12 @@ static int xlp_find_pci_dev(void)
 				vid 	= (val & 0xFFFF);
 				idx 	= get_dev2drv(devid);
 
+				/* Register NAND only for other nodes.
+				 * Remove if condition when other devices are supported on other nodes as well.
+				 * */
+				if(!((i>8 && (devid ==XLP_DEVID_NAND) ) || (i<8)))
+					continue;
+
 				if(idx >= 0 && idx < MAX_DEV2DRV) {
 
 					if(dev2drv_table[idx].drivetype == PLAT_DRV) {
@@ -259,6 +329,14 @@ static int __init platform_devinit(void)
 	return 0;
 }
 
+#ifdef CONFIG_RAPIDIO
+void platform_rio_init(void)
+{
+	extern int bcm_rio_module_init();
+        bcm_rio_module_init();
+}
+#endif
+
 static void __init platform_devexit(void)
 {
 	return;
diff --git a/arch/mips/netlogic/xlp/setup.c b/arch/mips/netlogic/xlp/setup.c
index c979f4d..0feae14 100644
--- a/arch/mips/netlogic/xlp/setup.c
+++ b/arch/mips/netlogic/xlp/setup.c
@@ -68,7 +68,8 @@
 #include <asm/mach-netlogic/nlm_kexec.h>
 #include <asm/netlogic/phnx_loader.h>
 #include "../boot/ops.h"
-#include "cpu_control_macros.h"
+#include <asm/netlogic/xlp8xx/cpu_control_macros.h>
+void parse_cmdline(void);
 /* Certain macros for this file
  */
 
@@ -115,7 +116,7 @@ unsigned long nlm_common_ebase = 0x0;
 
 char cpu_model_info[MAX_CPU_REV_LEN] = {'X','L','P'};
 
-unsigned int xlp_uart_portid = 0;
+static unsigned int xlp_uart_portid = 0;
 
 static char prop_buf[MAX_PROP_LEN];
 
@@ -1322,4 +1323,88 @@ static int __init nlm_proc_setup(void)
 
 	return 0;
 }
+
+extern unsigned long initrd_start, initrd_end;
+
+static int __init initrd_setup(char *str)
+{
+	char rdarg[64];
+	int idx;
+	char *tmp, *endptr;
+	unsigned long initrd_size;
+
+	/* Make a copy of the initrd argument so we can smash it up here */
+	for (idx = 0; idx < sizeof(rdarg)-1; idx++) {
+		if (!str[idx] || (str[idx] == ' ')) break;
+		rdarg[idx] = str[idx];
+	}
+
+	rdarg[idx] = 0;
+	str = rdarg;
+
+	/*
+	*Initrd location comes in the form "<hex size of ramdisk in bytes>@<location in memory>"
+	*  e.g. initrd=size@physaddr.
+	*/
+	for (tmp = str; *tmp != '@'; tmp++) {
+	       if (!*tmp) {
+			goto fail;
+		}
+	}
+	*tmp = 0;
+	tmp++;
+	if (!*tmp) {
+		goto fail;
+	}
+	initrd_size = simple_strtoul(str, &endptr, 16);
+	if (*endptr) {
+		 *(tmp-1) = '@';
+		 goto fail;
+	}
+	*(tmp-1) = '@';
+	initrd_start = simple_strtoul(tmp, &endptr, 16);
+
+#if defined(CONFIG_32BIT) && defined (CONFIG_MAPPED_KERNEL)
+	initrd_start = CKSEG2ADDR(initrd_start);
+#else
+	initrd_start = CKSEG1ADDR(initrd_start);
+#endif
+	
+	if (*endptr) {
+		goto fail;
+	}
+	initrd_end = initrd_start + initrd_size;
+	printk("Found initrd of %lx@%lx\n", initrd_size, initrd_start);
+	return 1;
+	fail:
+	printk("Bad initrd argument.  Disabling initrd\n");
+	initrd_start = 0;
+	initrd_end = 0;
+	return 1;
+}
+
+
+/*
+ * Init routine which accepts the variables from u-boot
+ */
+void parse_cmdline(void)
+{
+	char *ptr;
+	/* Need to find out early whether we've got an initrd.  So scan
+	the list looking now */
+	for (ptr = arcs_cmdline; *ptr; ptr++) {
+		while (*ptr == ' ') {
+			ptr++;
+		}
+		if (!strncmp(ptr, "initrd=", 7)) {
+			initrd_setup(ptr+7);
+			break;
+		} else {
+			while (*ptr && (*ptr != ' ')) {
+				ptr++;
+			}
+		}
+	}
+}
+
 rootfs_initcall(nlm_proc_setup);
diff --git a/arch/mips/netlogic/xlp/smp.c b/arch/mips/netlogic/xlp/smp.c
index 64b2bfc..0510f2c 100644
--- a/arch/mips/netlogic/xlp/smp.c
+++ b/arch/mips/netlogic/xlp/smp.c
@@ -1,27 +1,32 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems ( "Netlogic" ). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
 
 #include <linux/kernel.h>
 #include <linux/module.h>
@@ -52,7 +57,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 
 #include <asm/mach-netlogic/mmu.h>
 
-#include "cpu_control_macros.h"
+#include <asm/netlogic/xlp8xx/cpu_control_macros.h>
 #include "pic/timer-base.h"
 
 struct smp_boot_info smp_boot;
@@ -70,7 +75,9 @@ extern void enable_cpus(unsigned int node, unsigned online_mask);
 extern void nlm_smp_irq_init(void);
 extern void asmlinkage smp_bootstrap(void);
 extern void enable_msgconfig_int(void);
+extern void xlp_pic_ite_init(const struct cpumask *);
 
+static int node_exist[NLM_MAX_NODES];
 /*
  * Input parameter is logical cpu number.
  * Should convert to physical cpu before using it
@@ -214,17 +221,18 @@ int irq_select_affinity_usr(unsigned int);
 void xlp_prog_all_node_ites(void );
 void xlp_reprogram_timer_masks(void);
 
-void nlm_cpus_done(void)
+static long fmn_config(void *arg)
 {
-	unsigned long flags;
 	extern void *fdt;
-	u8 nid;
-	struct irq_desc *desc;
-	struct cpumask m;
+	printk("Doing fmn init from cpu %d for node %d\n", hard_smp_processor_id(), (int)(long)arg);
+	nlm_hal_fmn_init(fdt, (int)(long)arg);
+	return 0;
+}
+
+
+void nlm_cpus_done(void)
+{
 
-	nlm_hal_fmn_init(fdt);
-	/* Enable vc interupts for the online cpus */
-	nlm_enable_vc_intr();
 	xlp_prog_all_node_ites();
 #if defined CONFIG_XLP_REPLACE_R4K_TIMER
 	/* irq_select_affinity_usr(XLP_TIMER_IRQ(0, 0)); */
@@ -280,6 +288,7 @@ void __init nlm_smp_setup(void)
 	cpu_set(0, cpu_possible_map);
 	cpu_set(boot_cpu, phys_cpu_present_map);
 
+	node_exist[boot_cpu / NLM_NCPUS_PER_NODE] = (boot_cpu << 16) | 1;
 	/* Setup map for other cpus */
 	for (i = 0; i < NR_CPUS; i++) {
 
@@ -292,6 +301,8 @@ void __init nlm_smp_setup(void)
 			cpu_set(num_cpus, cpu_possible_map);
 			cpu_set(i, phys_cpu_present_map);
 			num_cpus++;
+			if(node_exist[i / NLM_NCPUS_PER_NODE] == 0) 
+				node_exist[i/ NLM_NCPUS_PER_NODE] = (i << 16) | 1;
 		}
 	}
 	cpumask_scnprintf(buf, CPUMASK_BUF, &cpu_online_mask);
@@ -302,7 +313,6 @@ void __init nlm_smp_setup(void)
 	cpumask_scnprintf(buf, CPUMASK_BUF, &cpu_possible_map);
 	printk("Possible CPU map %s\n", buf);
 	printk("Detected %d Slave CPU(s)\n", num_cpus);
-	/* Setup PIC with cpu_present_mask */
 }
 
 #define hw_enable_cpus enable_cpus
@@ -486,3 +496,28 @@ void prom_boot_cpus_secondary(void *args)
 	ptr_smp_boot(smp_boot.boot_info[cpu].fn, smp_boot.boot_info[cpu].sp,
 		     smp_boot.boot_info[cpu].gp);
 }
+
+static int __init nlm_fmn_init(void)
+{
+	extern void *fdt;
+	int node, rv;
+
+	/* Better to do node level fmn initialization */
+	if(get_dom_fmn_node_ownership(fdt, 0)) {
+		for(node = 0; node < NLM_MAX_NODES; node++) {
+			if(!node_exist[node])
+				continue;
+			rv = work_on_cpu(node_exist[node] >> 16, fmn_config, (void *)(long)node);
+			if(rv < 0) 
+				panic("Fmn init failed\n");
+		}
+	} else
+		printk("Skipping FMN initialization due to lack of ownership\n");
+
+	/* Enable vc interupts for the online cpus */
+	nlm_enable_vc_intr();
+
+	return 0;
+
+}
+core_initcall(nlm_fmn_init);
diff --git a/drivers/dma/nlm_adma.c b/drivers/dma/nlm_adma.c
index abd698d..97bcf23 100644
--- a/drivers/dma/nlm_adma.c
+++ b/drivers/dma/nlm_adma.c
@@ -1,27 +1,32 @@
-/***********************************************************************
-Copyright 2003-2011 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
 
 #include <linux/init.h>
 #include <linux/module.h>
@@ -48,7 +53,7 @@ uint64_t nlm_dtre_debug = 0;
 #define shift_lower_bits(x, bitshift, numofbits) \
 	(((unsigned long long)(x) & ((1ULL << (numofbits)) - 1)) << (bitshift))
 
-extern void nlm_hal_dtr_init();
+extern void nlm_hal_dtr_init(void);
 
 struct nlm_adma_device nlm_adma_raid_device;
 struct page * nlm_dtre_null_page;
diff --git a/drivers/dma/nlm_adma.h b/drivers/dma/nlm_adma.h
index 67f8bdb..d321da7 100644
--- a/drivers/dma/nlm_adma.h
+++ b/drivers/dma/nlm_adma.h
@@ -1,27 +1,32 @@
-/***********************************************************************
-Copyright 2003-2011 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
 
 #ifndef __NLM_ADMA_H__
 
diff --git a/include/linux/perfctr.h b/include/linux/perfctr.h
new file mode 100644
index 0000000..585e842
--- /dev/null
+++ b/include/linux/perfctr.h
@@ -0,0 +1,199 @@
+/*-
+ * Copyright 2004-2012 Broadcom Corporation
+ *
+ * This is a derived work from software originally provided by the entity or
+ * entities identified below. The licensing terms, warranty terms and other
+ * terms specified in the header of the original work apply to this derived work
+ *
+ * #BRCM_1# */
+
+/* $Id: perfctr.h,v 1.1.2.4 2006-09-28 01:24:22 nphilips Exp $
+ * Performance-Monitoring Counters driver
+ *
+ * Copyright (C) 1999-2004  Mikael Pettersson
+ */
+#ifndef _LINUX_PERFCTR_H
+#define _LINUX_PERFCTR_H
+
+#ifdef CONFIG_PERFCTR	/* don't break archs without <asm/perfctr.h> */
+
+#include <asm/perfctr.h>
+
+// Ensure that the following constant doesn't conflict constants specified
+// for other entries in "/proc/sys"
+
+#define CTL_PERFCTR	171
+
+// Extend the following enum type if more entries have to be created under
+// "/proc/sys/perfctr"
+
+enum {
+	PERFCTR_CNTMODE = 1
+};
+
+struct perfctr_info {
+	unsigned int abi_version;
+	char driver_version[32];
+	unsigned int cpu_type;
+	unsigned int cpu_features;
+	unsigned int cpu_khz;
+	unsigned int tsc_to_cpu_mult;
+	unsigned int _reserved2;
+	unsigned int _reserved3;
+	unsigned int _reserved4;
+};
+
+struct perfctr_cpu_mask {
+	unsigned int nrwords;
+	unsigned int mask[1];	/* actually 'nrwords' */
+};
+
+/* abi_version values: Lower 16 bits contain the CPU data version, upper
+   16 bits contain the API version. Each half has a major version in its
+   upper 8 bits, and a minor version in its lower 8 bits. */
+#define PERFCTR_API_VERSION	0x0600	/* 6.0 */
+#define PERFCTR_ABI_VERSION	((PERFCTR_API_VERSION<<16)|PERFCTR_CPU_VERSION)
+
+/* cpu_features flag bits */
+#define PERFCTR_FEATURE_RDPMC	0x01
+#define PERFCTR_FEATURE_RDTSC	0x02
+#define PERFCTR_FEATURE_PCINT	0x04
+
+/* user's view of mmap:ed virtual perfctr */
+struct vperfctr_state {
+	struct perfctr_cpu_state cpu_state;
+};
+
+/* virtual perfctr control object */
+struct vperfctr_control {
+	int si_signo;
+	unsigned int preserve;
+	unsigned int _reserved1;
+	unsigned int _reserved2;
+	unsigned int _reserved3;
+	unsigned int _reserved4;
+	struct perfctr_cpu_control cpu_control;
+};
+
+/* commands for sys_vperfctr_read() */
+#define VPERFCTR_READ_SUM	0x01
+#define VPERFCTR_READ_CONTROL	0x02
+#define VPERFCTR_READ_CHILDREN	0x03
+
+#else
+struct perfctr_info;
+struct perfctr_cpu_mask;
+struct perfctr_sum_ctrs;
+struct vperfctr_control;
+#endif	/* CONFIG_PERFCTR */
+
+#ifdef __KERNEL__
+
+/*
+ * The perfctr system calls.
+ */
+asmlinkage long sys_vperfctr_open(int tid, int creat);
+asmlinkage long sys_vperfctr_control(int fd,
+				     const struct vperfctr_control __user *argp,
+				     unsigned int argbytes);
+asmlinkage long sys_vperfctr_unlink(int fd);
+asmlinkage long sys_vperfctr_iresume(int fd);
+asmlinkage long sys_vperfctr_read(int fd, unsigned int cmd, void __user *argp, unsigned int argbytes);
+
+extern struct perfctr_info perfctr_info;
+
+#ifdef CONFIG_PERFCTR_VIRTUAL
+
+/*
+ * Virtual per-process performance-monitoring counters.
+ */
+struct vperfctr;	/* opaque */
+
+/* process management operations */
+extern void __vperfctr_copy(struct task_struct*, struct pt_regs*);
+extern void __vperfctr_release(struct task_struct*);
+extern void __vperfctr_exit(struct vperfctr*);
+extern void __vperfctr_suspend(struct vperfctr*);
+extern void __vperfctr_resume(struct vperfctr*);
+extern void __vperfctr_sample(struct vperfctr*);
+extern void __vperfctr_set_cpus_allowed(struct task_struct*, struct vperfctr*, cpumask_t);
+
+static inline void perfctr_copy_task(struct task_struct *tsk, struct pt_regs *regs)
+{
+	if (tsk->thread.perfctr) {
+		__vperfctr_copy(tsk, regs);
+	}
+}
+
+static inline void perfctr_release_task(struct task_struct *tsk)
+{
+	if (tsk->thread.perfctr) {
+		__vperfctr_release(tsk);
+	}
+}
+
+static inline void perfctr_exit_thread(struct thread_struct *thread)
+{
+	struct vperfctr *perfctr;
+	perfctr = thread->perfctr;
+	if (perfctr) {
+		__vperfctr_exit(perfctr);
+	}
+}
+
+static inline void perfctr_suspend_thread(struct thread_struct *prev)
+{
+	struct vperfctr *perfctr;
+	perfctr = prev->perfctr;
+	if (perfctr) {
+		__vperfctr_suspend(perfctr);
+	}
+}
+
+static inline void perfctr_resume_thread(struct thread_struct *next)
+{
+	struct vperfctr *perfctr;
+	perfctr = next->perfctr;
+	if (perfctr) {
+		__vperfctr_resume(perfctr);
+	}
+}
+
+static inline void perfctr_sample_thread(struct thread_struct *thread)
+{
+	struct vperfctr *perfctr;
+	perfctr = thread->perfctr;
+	if (perfctr) {
+		__vperfctr_sample(perfctr);
+	}
+}
+
+static inline void perfctr_set_cpus_allowed(struct task_struct *p, cpumask_t new_mask)
+{
+#ifdef CONFIG_PERFCTR_CPUS_FORBIDDEN_MASK
+	struct vperfctr *perfctr;
+
+	task_lock(p);
+	perfctr = p->thread.perfctr;
+	if (perfctr) {
+		__vperfctr_set_cpus_allowed(p, perfctr, new_mask);
+	}
+	task_unlock(p);
+#endif
+}
+
+#else	/* !CONFIG_PERFCTR_VIRTUAL */
+
+static inline void perfctr_copy_task(struct task_struct *p, struct pt_regs *r) { }
+static inline void perfctr_release_task(struct task_struct *p) { }
+static inline void perfctr_exit_thread(struct thread_struct *t) { }
+static inline void perfctr_suspend_thread(struct thread_struct *t) { }
+static inline void perfctr_resume_thread(struct thread_struct *t) { }
+static inline void perfctr_sample_thread(struct thread_struct *t) { }
+static inline void perfctr_set_cpus_allowed(struct task_struct *p, cpumask_t m) { }
+
+#endif	/* CONFIG_PERFCTR_VIRTUAL */
+
+#endif	/* __KERNEL__ */
+
+#endif	/* _LINUX_PERFCTR_H */
diff --git a/kernel/sched.c b/kernel/sched.c
index f4aaa0a..e1cb4b3 100644
--- a/kernel/sched.c
+++ b/kernel/sched.c
@@ -55,6 +55,7 @@
 #include <linux/cpu.h>
 #include <linux/cpuset.h>
 #include <linux/percpu.h>
+#include <linux/perfctr.h>
 #include <linux/kthread.h>
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
-- 
1.7.4

