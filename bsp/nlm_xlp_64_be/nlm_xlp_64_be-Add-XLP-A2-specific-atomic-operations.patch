From c76b5712454f83b736f0e056e93954c946ca740f Mon Sep 17 00:00:00 2001
From: Wu Zhangjin <zhangjin.wu@windriver.com>
Date: Wed, 20 Jul 2011 16:21:21 +0800
Subject: [PATCH 37/37] nlm_xlp_64_be: Add XLP A2 specific atomic operations

[ Based on netlogic SDK 20110720, but add following optimizations:
  o Use ldadd* instructions instead of hard-coded binaries
  o Remove unnecessary temp register for the 'base' of ldadd*
instructions
  o Add ldadd_w_ret() and use it instead of ldadd_w() for
atomic_add_return() and atomic_sub_return(). ]

The LDADD* instructions based atomic operations are added for XLP A2
processor.

Signed-off-by: Wu Zhangjin <zhangjin.wu@windriver.com>
---
 arch/mips/include/asm/atomic.h             |   20 ++++++
 arch/mips/include/asm/netlogic/mips-exts.h |   93 ++++++++++++++++++++++++++++
 arch/mips/netlogic/Kconfig                 |    9 +++
 3 files changed, 122 insertions(+), 0 deletions(-)

diff --git a/arch/mips/include/asm/atomic.h b/arch/mips/include/asm/atomic.h
index e1570b4..9a4c44f 100644
--- a/arch/mips/include/asm/atomic.h
+++ b/arch/mips/include/asm/atomic.h
@@ -21,6 +21,10 @@
 #include <asm/war.h>
 #include <asm/system.h>
 
+#ifdef CONFIG_NLM_COMMON
+#include <asm/netlogic/mips-exts.h>
+#endif
+
 #define ATOMIC_INIT(i)    { (i) }
 
 /*
@@ -49,6 +53,9 @@
  */
 static __inline__ void atomic_add(int i, atomic_t * v)
 {
+#ifdef CONFIG_NLM_ATOMICS
+	ldadd_w_no_read(i, &v->counter);
+#else
 	if (kernel_uses_llsc && R10000_LLSC_WAR) {
 		int temp;
 
@@ -80,6 +87,7 @@ static __inline__ void atomic_add(int i, atomic_t * v)
 		v->counter += i;
 		raw_local_irq_restore(flags);
 	}
+#endif
 }
 
 /*
@@ -91,6 +99,9 @@ static __inline__ void atomic_add(int i, atomic_t * v)
  */
 static __inline__ void atomic_sub(int i, atomic_t * v)
 {
+#ifdef CONFIG_NLM_ATOMICS
+	ldadd_w_no_read(-i, &v->counter);
+#else
 	if (kernel_uses_llsc && R10000_LLSC_WAR) {
 		int temp;
 
@@ -122,6 +133,7 @@ static __inline__ void atomic_sub(int i, atomic_t * v)
 		v->counter -= i;
 		raw_local_irq_restore(flags);
 	}
+#endif
 }
 
 /*
@@ -133,6 +145,9 @@ static __inline__ int atomic_add_return(int i, atomic_t * v)
 
 	smp_mb__before_llsc();
 
+#ifdef CONFIG_NLM_ATOMICS
+	result = ldadd_w_ret(i, &v->counter);
+#else
 	if (kernel_uses_llsc && R10000_LLSC_WAR) {
 		int temp;
 
@@ -170,6 +185,7 @@ static __inline__ int atomic_add_return(int i, atomic_t * v)
 		v->counter = result;
 		raw_local_irq_restore(flags);
 	}
+#endif
 
 	smp_llsc_mb();
 
@@ -182,6 +198,9 @@ static __inline__ int atomic_sub_return(int i, atomic_t * v)
 
 	smp_mb__before_llsc();
 
+#ifdef CONFIG_NLM_ATOMICS
+	result = ldadd_w_ret(-i, &v->counter);
+#else
 	if (kernel_uses_llsc && R10000_LLSC_WAR) {
 		int temp;
 
@@ -219,6 +238,7 @@ static __inline__ int atomic_sub_return(int i, atomic_t * v)
 		v->counter = result;
 		raw_local_irq_restore(flags);
 	}
+#endif
 
 	smp_llsc_mb();
 
diff --git a/arch/mips/include/asm/netlogic/mips-exts.h b/arch/mips/include/asm/netlogic/mips-exts.h
index c62acac..c8f7164 100644
--- a/arch/mips/include/asm/netlogic/mips-exts.h
+++ b/arch/mips/include/asm/netlogic/mips-exts.h
@@ -52,6 +52,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <linux/types.h>
 #include <asm/netlogic/interrupt.h>
 #include <asm/netlogic/iomap.h>
+#include <asm/asm.h>
 
 /* Scratch registers used */
 #define NLM_TLB_STATS_SCRATCH_REG_SEL  2
@@ -175,6 +176,98 @@ static inline void write_64bit_cp0_eimr(__u64 value)
 	: "$1", "$2");
 }
 
+#ifdef CONFIG_NLM_ATOMICS
+
+/* LDADD* instructions are documented in page 155~156 in "XLP Processor
+ * Family Programming Reference Manual"
+ *
+ * ldaddw rt, base:
+ *     v <- rt; rt <- memory[base]; memory[base] <- memory[base] + v;
+ *
+ * "ldaddw rt, base" overrides the register rt and put *base to it, so,
+ * a temp register should be used for it.
+ */
+
+static inline int ldadd_w(unsigned int value, volatile int *addr)
+{
+	unsigned long res;
+
+	asm volatile (
+			".set push\n"
+			".set noreorder\n"
+			"move $8, %2\n"
+			"ldaddw $8, %3\n"
+			"move %0, $8\n"
+			".set pop\n"
+			: "=r"(res), "+m"(*addr)
+			: "r" (value), "r"((unsigned long)addr)
+			: "$8"
+			);
+	return res;
+}
+
+static inline int ldadd_w_ret(unsigned int value, volatile int *addr)
+{
+	unsigned long res;
+	asm volatile (
+			".set push\n"
+			".set noreorder\n"
+			"move $8, %2\n"
+			"ldaddw $8, %3\n"
+			STR(PTR_ADDU) " %0, $8, %2\n"
+			".set pop\n"
+			: "=r"(res), "+m"(*addr)
+			: "r" (value), "r"((unsigned long)addr)
+			: "$8"
+			);
+	return res;
+}
+
+static inline void ldadd_w_no_read(int value, volatile int *addr)
+{
+	asm volatile (
+			".set push\n"
+			".set noreorder\n"
+			"move $8, %1\n"
+			"ldaddw $8, %2\n"
+			".set pop\n"
+			: "+m"(*addr)
+			: "r" (value), "r"((unsigned long)addr)
+			: "$8"
+			);
+}
+
+static inline unsigned int ldadd_wu(unsigned int value, volatile unsigned int *addr)
+{
+	unsigned long res;
+	asm volatile (
+			".set push\n"
+			".set noreorder\n"
+			"move $8, %2\n"
+			"ldaddwu $8, %3\n"
+			"move %0, $8\n"
+			".set pop\n"
+			: "=r"(res), "+m"(*addr)
+			: "r"(value), "r"((unsigned long)addr)
+			: "$8"
+			);
+	return res;
+}
+
+static inline void ldadd_wu_no_read(unsigned int value,
+					volatile unsigned int *addr)
+{
+	asm volatile (
+			".set push\n"
+			".set noreorder\n"
+			"ldaddwu %1, %2\n"
+			".set pop\n"
+			: "+m"(*addr)
+			: "r"(value), "r"((unsigned long)addr)
+			);
+}
+#endif /* CONFIG_NLM_ATOMICS */
+
 static __inline__ int hard_smp_processor_id(void)
 {
 	int cpu;
diff --git a/arch/mips/netlogic/Kconfig b/arch/mips/netlogic/Kconfig
index 4530fd1..b798638 100644
--- a/arch/mips/netlogic/Kconfig
+++ b/arch/mips/netlogic/Kconfig
@@ -2,8 +2,17 @@ config NLM_COMMON
 	bool
 
 config NLM_XLP
+	select NLM_ATOMICS if !NLM_XLP_A0_WORKAROUNDS
 	bool
 
+config NLM_ATOMICS
+	bool
+
+config NLM_XLP_A0_WORKAROUNDS
+	bool "Enable A0 workarounds"
+	depends on NLM_XLP
+	default n
+
 config PGWALKER
 	bool "PGWalker (experimental)"
 	depends on EXPERIMENTAL
-- 
1.7.0.2

