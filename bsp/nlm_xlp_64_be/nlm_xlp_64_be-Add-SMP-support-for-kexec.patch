From 9aaf843580a227299d0b85be1e70e5d1c7ea2206 Mon Sep 17 00:00:00 2001
From: Wu Zhangjin <zhangjin.wu@windriver.com>
Date: Wed, 13 Jul 2011 17:58:56 +0800
Subject: [PATCH 35/37] nlm_xlp_64_be: Add SMP support for kexec

Before, all slave cpus are pushed into 'dead' loop after run "kexec
-e" but are not waken up after booting from kexec.

This allows them to be pulled out of the loop in order to enable SMP
support for kexec.

But a limitation is, the second kernel must boot on CPU thread0@core0,
therefore, "kexec -e" must run on thread0@core0:

$ taskset -c 0 kexec -e

And with "taskset -c 0", all of the memory are available in the second
kernel and the USB devices also survive.

If don't boot the second kernel on CPU thread0@core0, the kernel will
hang when boot with SMP, only the low 320M memory(the first memory
segmentation) is available and the USB devcies don't work. These should
be fixed in the future.

This change is derived from the kexec support for the XLR732-based
boards completed in the previous release.

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>
Signed-off-by: Wu Zhangjin <zhangjin.wu@windriver.com>
---
 arch/mips/kernel/relocate_kernel.S       |   38 ++++++++++++++++++++++++++++++
 arch/mips/netlogic/common/nlm_kexec.c    |   19 ++++++++++++++-
 arch/mips/netlogic/xlp/cpu_control_asm.S |   33 +++++++++++++------------
 arch/mips/netlogic/xlp/on_chip.c         |    1 +
 arch/mips/netlogic/xlp/setup.c           |   23 +++++++++++------
 5 files changed, 89 insertions(+), 25 deletions(-)

diff --git a/arch/mips/kernel/relocate_kernel.S b/arch/mips/kernel/relocate_kernel.S
index 28950e6..df3e5a0 100644
--- a/arch/mips/kernel/relocate_kernel.S
+++ b/arch/mips/kernel/relocate_kernel.S
@@ -251,6 +251,44 @@ LEAF(kexec_nlm_secondary_cpu_spin)
 	nop
 END(kexec_nlm_secondary_cpu_spin)
 
+LEAF(kexec_nlm_boot_cpu_wakeup_secondary_cpus)
+	/* a0 contains the address the secondary CPUs will jump to in the
+	 * second kernel
+	 */
+	.align	3
+	move		t3,ra   /* save ra from the second kernel */
+
+	bal		1f      /* MUST be second instruction */
+	nop
+1:
+	.align	3
+	PTR_ADDIU	ra,ra,-12 /* -12 *if* bal is second instruction */
+	PTR_LA		t0,kexec_nlm_boot_cpu_wakeup_secondary_cpus
+	PTR_LA		v0,kexec_secondary_cpu_next_kernel_entry_point
+	PTR_SUBU	t1,v0,t0 /* t1 <= offset to relocated _wakeup_ */
+	PTR_ADDU	v0,ra,t1 /* v0 now contains the relocated var addr */
+	PTR_S		a0,(v0) /* store addr in 2nd kernel where to jump */
+
+	sync
+	nop
+	nop
+	nop
+	nop
+	nop
+
+	/* t0 still contains address of non-relocated
+	 * kexec_nlm_secondary_cpu_spin()
+	 */
+	PTR_LA		v0,kexec_secondary_cpu_spin_var
+	PTR_SUBU	t1,v0,t0 /* t1 <= offset to relocated spin_var */
+	PTR_ADDU	v0,ra,t1 /* v0 now contains the relocated variable addr */
+	dli		t1,0x1
+	PTR_S		t1,(v0)
+
+	jr		t3
+	nop
+END(kexec_nlm_boot_cpu_wakeup_secondary_cpus)
+
 	.align	3
 kexec_secondary_cpu_spin_var:
 EXPORT(kexec_secondary_cpu_spin_var)
diff --git a/arch/mips/netlogic/common/nlm_kexec.c b/arch/mips/netlogic/common/nlm_kexec.c
index 9efa05f..0cd580e 100644
--- a/arch/mips/netlogic/common/nlm_kexec.c
+++ b/arch/mips/netlogic/common/nlm_kexec.c
@@ -193,7 +193,10 @@ static int nlm_kexec_prepare(struct kimage *kimage)
 
 	kexec_args[0] = fw_arg0;
 	kexec_args[1] = fw_arg1;
-	kexec_args[2] = fw_arg2;
+	/* kexec_args[2] saves the wakeup callback in
+	 * nlm_patch_bootloader_wakeup_fn(), Init it to NULL here.
+	 */
+	kexec_args[2] = (unsigned long)NULL;
 	/* Use this flag to check whether boot from kexec */
 	kexec_args[3] = KEXEC_BOOT_FLAG;
 
@@ -216,11 +219,25 @@ static void nlm_crash_shutdown(struct pt_regs *regs)
 }
 
 #ifdef CONFIG_SMP
+extern void kexec_nlm_boot_cpu_wakeup_secondary_cpus(void *callback);
+
+void nlm_patch_bootloader_wakeup_fn(unsigned long reloc)
+{
+	void (*relocated_wakeup_callback)(void *);
+
+	relocated_wakeup_callback = (void *)(reloc +
+		((ulong)kexec_nlm_boot_cpu_wakeup_secondary_cpus -
+			(ulong)relocate_new_kernel));
+	/* Use fw_arg2 to save the wakeup callback */
+	kexec_args[2] = (uint64_t)relocated_wakeup_callback;
+}
+
 static void nlm_smp_handle_restart(unsigned long reloc)
 {
 	/* All secondary cpus now may jump to kexec_wait cycle */
 	relocated_kexec_smp_wait =
 	    (void *)(reloc + (kexec_smp_wait - relocate_new_kernel));
+	nlm_patch_bootloader_wakeup_fn(reloc);
 	relocated_kexec_nlm_secondary_cpu_spin =
 	    (void *)(reloc + ((ulong) kexec_nlm_secondary_cpu_spin -
 			      (ulong) relocate_new_kernel));
diff --git a/arch/mips/netlogic/xlp/cpu_control_asm.S b/arch/mips/netlogic/xlp/cpu_control_asm.S
index f6d63f5..ebd9ce4 100644
--- a/arch/mips/netlogic/xlp/cpu_control_asm.S
+++ b/arch/mips/netlogic/xlp/cpu_control_asm.S
@@ -181,24 +181,25 @@ END(ptr_smp_boot)
  */
 NESTED(prom_pre_boot_secondary_cpus, 16, sp)
         SET_MIPS64
-	mtc0    zero, CP0_WIRED
 
-	/* Don't trust the bootstrapper to set cp0_status to what you want */
+	mtc0		zero, CP0_WIRED
+	/* Don't trust the bootstrapper to set cp0_status to
+	 * what you want */
 #ifdef CONFIG_64BIT
-	setup_c0_status ST0_KX ST0_BEV
+	prog_c0_status ST0_KX ST0_BEV
 #else
-	setup_c0_status 0 ST0_BEV
+	prog_c0_status 0 ST0_BEV
 #endif
-	mfc0 t0, CP0_EBASE, 1 #read ebase
-        andi t0, 0x7f #t0 has the processor_id()
-        PTR_LA  t1, xlp_stack_pages_temp
-        li   t2, _THREAD_SIZE
-        srl  t2, 2
-        mul  t3, t2, t0
-        PTR_ADDU  gp, t1, t3
-        PTR_ADDU       sp, gp, t2
-        PTR_ADDI       sp, sp, -32
-        PTR_LA t0, prom_boot_cpus_secondary
-        jr t0
-        nop
+	mfc0 		t0, CP0_EBASE, 1
+	andi 		t0, 0x7f	# t0 has the hard processor id
+	PTR_LA		t1, xlp_stack_pages_temp
+	li   		t2, _THREAD_SIZE
+	srl  		t2, 2
+	mul  		t3, t2, t0
+	PTR_ADDU  	gp, t1, t3
+	PTR_ADDU  	sp, gp, t2
+	PTR_ADDI  	sp, sp, -64
+	PTR_LA t0, 	prom_boot_cpus_secondary
+	jr 		t0
+	 nop
 END(prom_pre_boot_secondary_cpus)
diff --git a/arch/mips/netlogic/xlp/on_chip.c b/arch/mips/netlogic/xlp/on_chip.c
index 58a9587..7a8280a 100644
--- a/arch/mips/netlogic/xlp/on_chip.c
+++ b/arch/mips/netlogic/xlp/on_chip.c
@@ -373,6 +373,7 @@ static void pic_init(void)
 
 	thread_mask = (1 << vcpu);
 
+	pr_info("%s: Master cpu is %d\n", __func__, vcpu);
 	for (i = 0; i < PIC_NUM_IRTS; i++) {
 		/* Use local scheduling and high polarity for all IRTs
 		 * Invalidate all IRTs, by default
diff --git a/arch/mips/netlogic/xlp/setup.c b/arch/mips/netlogic/xlp/setup.c
index baed5f7..30c69eb 100644
--- a/arch/mips/netlogic/xlp/setup.c
+++ b/arch/mips/netlogic/xlp/setup.c
@@ -455,13 +455,6 @@ static int fdt_process(void)
 			if (!entries || (entries % (na+ns)))
 				printk("Invalid Memory Map Specified!\n");
 
-			/* FIXME: Kexec kernel currently only works with
-			 * the low memory segmentation(0 ~ 320M), it
-			 * crashes if using the other 2 segmentations.
-			 */
-			if (is_kexec_boot())
-				entries = 1;
-
 			for (i = 0; i < entries; i += 2) {
 				unsigned long long addr, size;
 
@@ -655,8 +648,12 @@ static void xen_init(void) {}
 extern void nlm_kexec_init(void);
 #endif
 
+extern void prom_pre_boot_secondary_cpus(void *);
+
 void __init prom_init(void)
 {
+	void (*wakeup)(void *);
+
 	setup_mapped_kernel_tlbs(TRUE, TRUE);
 
 	fdt_process();
@@ -676,8 +673,18 @@ void __init prom_init(void)
 
 	register_smp_ops(&nlm_smp_ops);
 
-	if (!is_kexec_boot())
+	if (!is_kexec_boot()) {
+		/* Wake up the slaves in 'hardware method' */
 		wakeup_secondary_cpus();
+	} else {
+		/* Simply pull the slaves out of 'dead' loop */
+		/* fw_arg2 saves the wakeup callback, please see
+		 * nlm_patch_bootloader_wakeup_fn()
+		 */
+		wakeup = ((void (*)(void *))fw_arg2);
+		if (wakeup)
+			wakeup(prom_pre_boot_secondary_cpus);
+	}
 
 #ifdef CONFIG_KEXEC
 	nlm_kexec_init();
-- 
1.7.0.2

