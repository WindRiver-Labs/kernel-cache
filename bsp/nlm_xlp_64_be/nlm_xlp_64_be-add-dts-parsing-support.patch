From 579f5a1a176bea855e233831b9705ccdb5c2415d Mon Sep 17 00:00:00 2001
From: Wu Zhangjin <zhangjin.wu@windriver.com>
Date: Wed, 6 Apr 2011 16:19:56 +0800
Subject: [PATCH 04/37] nlm_xlp_64_be: add dts parsing support

[ Based on netlogic SDK 20110329 ]

The basic dts parsing support is added with the help of
scripts/dtc/libfdt/ and some new arch specific codes.

Signed-off-by: Zi Shen Lim <zlim@netlogicmicro.com>
Signed-off-by: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Signed-off-by: Siva Pochiraju <sivap@netlogicmicro.com>
[ based on the powerpc implementation, cleaned up a lot for the
original support from SDK, including optimize the Makefile, add
.gitignore and drop lots of duplications ]
Signed-off-by: Wu Zhangjin <zhangjin.wu@windriver.com>
---
 arch/mips/Makefile                       |    1 +
 arch/mips/netlogic/boot/.gitignore       |    9 +
 arch/mips/netlogic/boot/Makefile         |   38 +++++
 arch/mips/netlogic/boot/libfdt-wrapper.c |  212 +++++++++++++++++++++++++
 arch/mips/netlogic/boot/libfdt_env.h     |   22 +++
 arch/mips/netlogic/boot/ops.h            |  246 ++++++++++++++++++++++++++++++
 arch/mips/netlogic/boot/page.h           |   34 ++++
 arch/mips/netlogic/boot/simple_alloc.c   |  153 ++++++++++++++++++
 arch/mips/netlogic/boot/stdio.h          |   19 +++
 arch/mips/netlogic/boot/string.h         |   20 +++
 arch/mips/netlogic/boot/types.h          |    4 +
 scripts/dtc/libfdt/fdt.c                 |    2 +-
 scripts/dtc/libfdt/fdt_rw.c              |   13 ++
 13 files changed, 772 insertions(+), 1 deletions(-)
 create mode 100644 arch/mips/netlogic/boot/.gitignore
 create mode 100644 arch/mips/netlogic/boot/Makefile
 create mode 100644 arch/mips/netlogic/boot/libfdt-wrapper.c
 create mode 100644 arch/mips/netlogic/boot/libfdt_env.h
 create mode 100644 arch/mips/netlogic/boot/ops.h
 create mode 100644 arch/mips/netlogic/boot/page.h
 create mode 100644 arch/mips/netlogic/boot/simple_alloc.c
 create mode 100644 arch/mips/netlogic/boot/stdio.h
 create mode 100644 arch/mips/netlogic/boot/string.h
 create mode 100644 arch/mips/netlogic/boot/types.h

diff --git a/arch/mips/Makefile b/arch/mips/Makefile
index 8ef0af4..c5267b6 100644
--- a/arch/mips/Makefile
+++ b/arch/mips/Makefile
@@ -810,6 +810,7 @@ archclean:
 	@$(MAKE) $(clean)=arch/mips/boot
 	@$(MAKE) $(clean)=arch/mips/boot/compressed
 	@$(MAKE) $(clean)=arch/mips/lasat
+	@$(MAKE) $(clean)=arch/mips/netlogic/boot
 
 define archhelp
 	echo '  install              - install kernel into $(INSTALL_PATH)'
diff --git a/arch/mips/netlogic/boot/.gitignore b/arch/mips/netlogic/boot/.gitignore
new file mode 100644
index 0000000..4e6faf1
--- /dev/null
+++ b/arch/mips/netlogic/boot/.gitignore
@@ -0,0 +1,9 @@
+fdt.c
+fdt.h
+fdt_ro.c
+fdt_rw.c
+fdt_strerror.c
+fdt_sw.c
+fdt_wip.c
+libfdt.h
+libfdt_internal.h
diff --git a/arch/mips/netlogic/boot/Makefile b/arch/mips/netlogic/boot/Makefile
new file mode 100644
index 0000000..b9977ad
--- /dev/null
+++ b/arch/mips/netlogic/boot/Makefile
@@ -0,0 +1,38 @@
+#
+# Makefile for the Flattened Device Tree for Netlogic XLP Kernels
+#
+
+obj-y	+= simple_alloc.o libfdt-wrapper.o
+libfdt	:= fdt.c fdt_ro.c fdt_wip.c fdt_sw.c fdt_rw.c fdt_strerror.c
+
+obj-y	+= $(addsuffix .o, $(basename $(libfdt)))
+libfdtheader := fdt.h libfdt.h libfdt_internal.h
+
+$(addprefix $(obj)/,$(libfdt) libfdt-wrapper.o): \
+	$(addprefix $(obj)/,$(libfdtheader))
+
+quiet_cmd_copy_libfdt = COPY    $@
+      cmd_copy_libfdt = cp $< $@
+
+$(addprefix $(obj)/,$(libfdt) $(libfdtheader)): $(obj)/%: $(srctree)/scripts/dtc/libfdt/%
+	$(call cmd,copy_libfdt)
+
+quiet_cmd_bootcc = BOOTCC  $@
+      cmd_bootcc = $(CROSS32CC) -Wp,-MD,$(depfile) $(BOOTCFLAGS) -c -o $@ $<
+
+quiet_cmd_bootas = BOOTAS  $@
+      cmd_bootas = $(CROSS32CC) -Wp,-MD,$(depfile) $(BOOTAFLAGS) -c -o $@ $<
+
+quiet_cmd_bootar = BOOTAR  $@
+      cmd_bootar = $(CROSS32AR) -cr $@.$$$$ $(filter-out FORCE,$^); mv $@.$$$$ $@
+
+$(obj-libfdt): $(obj)/%.o: $(srctree)/scripts/dtc/libfdt/%.c FORCE
+	$(call if_changed_dep,bootcc)
+$(patsubst %.c,%.o, $(filter %.c, $(src-boot))): %.o: %.c FORCE
+	$(Q)mkdir -p $(dir $@)
+	$(call if_changed_dep,bootcc)
+$(patsubst %.S,%.o, $(filter %.S, $(src-boot))): %.o: %.S FORCE
+	$(Q)mkdir -p $(dir $@)
+	$(call if_changed_dep,bootas)
+
+clean-files += $(libfdt) $(libfdtheader)
diff --git a/arch/mips/netlogic/boot/libfdt-wrapper.c b/arch/mips/netlogic/boot/libfdt-wrapper.c
new file mode 100644
index 0000000..3720879
--- /dev/null
+++ b/arch/mips/netlogic/boot/libfdt-wrapper.c
@@ -0,0 +1,212 @@
+/*
+ * This file does the necessary interface mapping between the bootwrapper
+ * device tree operations and the interface provided by shared source
+ * files flatdevicetree.[ch].
+ *
+ * Copyright 2007 David Gibson, IBM Corporation.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+#include <stddef.h>
+#include <stdio.h>
+#include <page.h>
+#include <libfdt.h>
+#include "ops.h"
+
+#define min(x, y) ({ \
+		typeof(x) _x = (x); \
+		typeof(y) _y = (y); \
+		(void) (&_x == &_y);    \
+		_x < _y ? _x : _y; })
+
+
+#define DEBUG	0
+#define BAD_ERROR(err)	(((err) < 0) \
+			 && ((err) != -FDT_ERR_NOTFOUND) \
+			 && ((err) != -FDT_ERR_EXISTS))
+
+#define check_err(err) \
+	({ \
+		if (BAD_ERROR(err)) \
+			exit(); \
+		(err < 0) ? -1 : 0; \
+	})
+
+#define offset_devp(off)	\
+	({ \
+		int _offset = (off); \
+		check_err(_offset) ? NULL : (void *)(unsigned long)(_offset+1); \
+	})
+
+#define devp_offset_find(devp)	(((int)(unsigned long)(devp))-1)
+#define devp_offset(devp)	(devp ? ((int)(unsigned long)(devp))-1 : 0)
+
+void *fdt;
+static void *buf; /* = NULL */
+
+#define EXPAND_GRANULARITY	1024
+
+struct platform_ops platform_ops;
+struct dt_ops dt_ops;
+
+
+static void expand_buf(int minexpand)
+{
+	int size = fdt_totalsize(fdt);
+	int rc;
+
+	size = _ALIGN(size + minexpand, EXPAND_GRANULARITY);
+	buf = platform_ops.realloc(buf, size);
+	rc = fdt_open_into(fdt, buf, size);
+	fdt = buf;
+}
+
+static void *fdt_wrapper_finddevice(const char *path)
+{
+	return offset_devp(fdt_path_offset(fdt, path));
+}
+
+static int fdt_wrapper_getprop(const void *devp, const char *name,
+			       void *buf, const int buflen)
+{
+	const void *p;
+	int len;
+
+	p = fdt_getprop(fdt, devp_offset(devp), name, &len);
+	if (!p)
+		return check_err(len);
+	memcpy(buf, p, min(len, buflen));
+	return len;
+}
+
+static int fdt_wrapper_setprop(const void *devp, const char *name,
+			       const void *buf, const int len)
+{
+	int rc;
+
+	rc = fdt_setprop(fdt, devp_offset(devp), name, buf, len);
+	if (rc == -FDT_ERR_NOSPACE) {
+		expand_buf(len + 16);
+		rc = fdt_setprop(fdt, devp_offset(devp), name, buf, len);
+	}
+
+	return check_err(rc);
+}
+
+static int fdt_wrapper_del_node(const void *devp)
+{
+	return fdt_del_node(fdt, devp_offset(devp));
+}
+
+static void *fdt_wrapper_get_parent(const void *devp)
+{
+	return offset_devp(fdt_parent_offset(fdt, devp_offset(devp)));
+}
+
+static void *fdt_wrapper_create_node(const void *devp, const char *name)
+{
+	int offset;
+
+	offset = fdt_add_subnode(fdt, devp_offset(devp), name);
+	if (offset == -FDT_ERR_NOSPACE) {
+		expand_buf(strlen(name) + 16);
+		offset = fdt_add_subnode(fdt, devp_offset(devp), name);
+	}
+
+	return offset_devp(offset);
+}
+
+static void *fdt_wrapper_find_node_by_prop_value(const void *prev,
+						 const char *name,
+						 const char *val,
+						 int len)
+{
+	int offset = fdt_node_offset_by_prop_value(fdt, devp_offset_find(prev),
+						name, val, len);
+	return offset_devp(offset);
+}
+
+static void *fdt_wrapper_find_node_by_compatible(const void *prev,
+						 const char *val)
+{
+	int offset = fdt_node_offset_by_compatible(fdt, devp_offset_find(prev),
+							val);
+	return offset_devp(offset);
+}
+
+static char *fdt_wrapper_get_path(const void *devp, char *buf, int len)
+{
+	int rc;
+
+	rc = fdt_get_path(fdt, devp_offset(devp), buf, len);
+	if (check_err(rc))
+		return NULL;
+	return buf;
+}
+
+static unsigned long fdt_wrapper_finalize(void)
+{
+	int rc;
+
+	rc = fdt_pack(fdt);
+	return (unsigned long)fdt;
+}
+
+static int fdt_wrapper_check_header(void)
+{
+	int err = 0;
+
+	err = fdt_check_header(fdt);
+
+	return err;
+}
+
+void *fdt_init(void *blob)
+{
+	dt_ops.finddevice = fdt_wrapper_finddevice;
+	dt_ops.getprop = fdt_wrapper_getprop;
+	dt_ops.setprop = fdt_wrapper_setprop;
+	dt_ops.get_parent = fdt_wrapper_get_parent;
+	dt_ops.create_node = fdt_wrapper_create_node;
+	dt_ops.find_node_by_prop_value = fdt_wrapper_find_node_by_prop_value;
+	dt_ops.find_node_by_compatible = fdt_wrapper_find_node_by_compatible;
+	dt_ops.del_node = fdt_wrapper_del_node;
+	dt_ops.get_path = fdt_wrapper_get_path;
+	dt_ops.finalize = fdt_wrapper_finalize;
+	dt_ops.check_header = fdt_wrapper_check_header;
+
+	/* Make sure the dt blob is the right version and so forth */
+	fdt = blob;
+
+	/* Don't use local copy as Kernel claims this memory after mem init
+	 * As a result, FDT can not be parsed in kernel modules
+	 */
+#ifdef USE_LOCAL_FDT_COPY
+	{
+		int err;
+		int bufsize;
+
+		bufsize = fdt_totalsize(fdt) + EXPAND_GRANULARITY;
+		buf = malloc(bufsize);
+
+		err = fdt_open_into(fdt, buf, bufsize);
+
+		fdt = buf;
+	}
+#endif
+	return fdt;
+}
diff --git a/arch/mips/netlogic/boot/libfdt_env.h b/arch/mips/netlogic/boot/libfdt_env.h
new file mode 100644
index 0000000..a8b29f6
--- /dev/null
+++ b/arch/mips/netlogic/boot/libfdt_env.h
@@ -0,0 +1,22 @@
+#ifndef _ARCH_MIPS_BOOT_LIBFDT_ENV_H
+#define _ARCH_MIPS_BOOT_LIBFDT_ENV_H
+
+#include <linux/types.h>
+#include <string.h>
+
+#define _B(n)	((unsigned long long)((uint8_t *)&x)[n])
+static inline uint32_t fdt32_to_cpu(uint32_t x)
+{
+	return (_B(0) << 24) | (_B(1) << 16) | (_B(2) << 8) | _B(3);
+}
+#define cpu_to_fdt32(x) fdt32_to_cpu(x)
+
+static inline uint64_t fdt64_to_cpu(uint64_t x)
+{
+	return (_B(0) << 56) | (_B(1) << 48) | (_B(2) << 40) | (_B(3) << 32)
+		| (_B(4) << 24) | (_B(5) << 16) | (_B(6) << 8) | _B(7);
+}
+#define cpu_to_fdt64(x) fdt64_to_cpu(x)
+#undef _B
+
+#endif /* _ARCH_MIPS_BOOT_LIBFDT_ENV_H */
diff --git a/arch/mips/netlogic/boot/ops.h b/arch/mips/netlogic/boot/ops.h
new file mode 100644
index 0000000..d2c4ce1
--- /dev/null
+++ b/arch/mips/netlogic/boot/ops.h
@@ -0,0 +1,246 @@
+/*
+ * Global definition of all the bootwrapper operations.
+ *
+ * Author: Mark A. Greer <mgreer@mvista.com>
+ *
+ * 2006 (c) MontaVista Software, Inc.  This file is licensed under
+ * the terms of the GNU General Public License version 2.  This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#ifndef _PPC_BOOT_OPS_H_
+#define _PPC_BOOT_OPS_H_
+
+#include <stddef.h>
+#include "string.h"
+
+#define	MAX_PATH_LEN		256
+#define	MAX_PROP_LEN		256 /* What should this be? */
+
+typedef void (*kernel_entry_t)(unsigned long r3, unsigned long r4, void *r5);
+
+/* Platform specific operations */
+struct platform_ops {
+	void	(*fixups)(void);
+	void	(*image_hdr)(const void *);
+	void *	(*malloc)(unsigned long size);
+	void	(*free)(void *ptr);
+	void *	(*realloc)(void *ptr, unsigned long size);
+	void	(*exit)(void);
+	void *	(*vmlinux_alloc)(unsigned long size);
+};
+extern struct platform_ops platform_ops;
+
+/* Device Tree operations */
+struct dt_ops {
+	void *	(*finddevice)(const char *name);
+	int	(*getprop)(const void *phandle, const char *name, void *buf,
+			const int buflen);
+	int	(*setprop)(const void *phandle, const char *name,
+			const void *buf, const int buflen);
+	int (*del_node)(const void *phandle);
+	void *(*get_parent)(const void *phandle);
+	/* The node must not already exist. */
+	void *(*create_node)(const void *parent, const char *name);
+	void *(*find_node_by_prop_value)(const void *prev,
+					const char *propname,
+					const char *propval, int proplen);
+	void *(*find_node_by_compatible)(const void *prev,
+					const char *compat);
+	unsigned long (*finalize)(void);
+	char *(*get_path)(const void *phandle, char *buf, int len);
+	int (*check_header)(void);
+};
+extern struct dt_ops dt_ops;
+
+/* Console operations */
+struct console_ops {
+	int		(*open)(void);
+	void	(*write)(const char *buf, int len);
+	void	(*edit_cmdline)(char *buf, int len);
+	void	(*close)(void);
+	void	*data;
+};
+extern struct console_ops console_ops;
+
+/* Serial console operations */
+struct serial_console_data {
+	int		(*open)(void);
+	void	(*putc)(unsigned char c);
+	unsigned char	(*getc)(void);
+	unsigned char		(*tstc)(void);
+	void	(*close)(void);
+};
+
+struct loader_info {
+	void *promptr;
+	unsigned long initrd_addr, initrd_size;
+	char *cmdline;
+	int cmdline_len;
+};
+extern struct loader_info loader_info;
+
+void start(void);
+void *fdt_init(void *blob);
+int ns16550_console_init(void *devp, struct serial_console_data *scdp);
+void *simple_alloc_init(char *base, unsigned long heap_size,
+			unsigned long granularity, unsigned long max_allocs);
+extern void flush_cache(void *, unsigned long);
+int dt_xlate_reg(void *node, int res, unsigned long *addr, unsigned long *size);
+int dt_xlate_addr(void *node, unsigned int *buf, int buflen, unsigned long *xlated_addr);
+int dt_is_compatible(void *node, const char *compat);
+void dt_get_reg_format(void *node, unsigned int *naddr, unsigned int *nsize);
+int dt_get_virtual_reg(void *node, void **addr, int nres);
+
+
+static inline void *finddevice(const char *name)
+{
+	return (dt_ops.finddevice) ? dt_ops.finddevice(name) : NULL;
+}
+
+static inline int getprop(void *devp, const char *name, void *buf, int buflen)
+{
+	return (dt_ops.getprop) ? dt_ops.getprop(devp, name, buf, buflen) : -1;
+}
+
+static inline int setprop(void *devp, const char *name,
+			const void *buf, int buflen)
+{
+	return (dt_ops.setprop) ? dt_ops.setprop(devp, name, buf, buflen) : -1;
+}
+#define setprop_val(devp, name, val) \
+	do { \
+		typeof(val) x = (val); \
+		setprop((devp), (name), &x, sizeof(x)); \
+	} while (0)
+
+static inline int setprop_str(void *devp, const char *name, const char *buf)
+{
+	if (dt_ops.setprop)
+		return dt_ops.setprop(devp, name, buf, strlen(buf) + 1);
+
+	return -1;
+}
+
+static inline int del_node(const void *devp)
+{
+	return dt_ops.del_node ? dt_ops.del_node(devp) : -1;
+}
+
+static inline void *get_parent(const char *devp)
+{
+	return dt_ops.get_parent ? dt_ops.get_parent(devp) : NULL;
+}
+
+static inline void *create_node(const void *parent, const char *name)
+{
+	return dt_ops.create_node ? dt_ops.create_node(parent, name) : NULL;
+}
+
+
+static inline void *find_node_by_prop_value(const void *prev,
+					const char *propname,
+					const char *propval, int proplen)
+{
+	if (dt_ops.find_node_by_prop_value)
+		return dt_ops.find_node_by_prop_value(prev, propname,
+							propval, proplen);
+
+	return NULL;
+}
+
+static inline void *find_node_by_prop_value_str(const void *prev,
+					const char *propname,
+					const char *propval)
+{
+	return find_node_by_prop_value(prev, propname, propval,
+					strlen(propval) + 1);
+}
+
+static inline void *find_node_by_devtype(const void *prev,
+					const char *type)
+{
+	return find_node_by_prop_value_str(prev, "device_type", type);
+}
+
+static inline void *find_node_by_alias(const char *alias)
+{
+	void *devp = finddevice("/aliases");
+
+	if (devp) {
+		char path[MAX_PATH_LEN];
+		if (getprop(devp, alias, path, MAX_PATH_LEN) > 0)
+			return finddevice(path);
+	}
+
+	return NULL;
+}
+
+static inline void *find_node_by_compatible(const void *prev,
+					const char *compat)
+{
+	if (dt_ops.find_node_by_compatible)
+		return dt_ops.find_node_by_compatible(prev, compat);
+
+	return NULL;
+}
+
+static inline int check_header(void)
+{
+	if (dt_ops.check_header)
+		return dt_ops.check_header();
+	return -1;
+}
+
+void dt_fixup_memory(unsigned long long start, unsigned long long size);
+void dt_fixup_cpu_clocks(unsigned int cpufreq, unsigned int tbfreq, unsigned int busfreq);
+void dt_fixup_clock(const char *path, unsigned int freq);
+void dt_fixup_mac_address_by_alias(const char *alias, const unsigned char *addr);
+void dt_fixup_mac_address(unsigned int index, const unsigned char *addr);
+void __dt_fixup_mac_addresses(unsigned int startindex, ...);
+#define dt_fixup_mac_addresses(...) \
+	__dt_fixup_mac_addresses(0, __VA_ARGS__, NULL)
+
+
+static inline void *find_node_by_linuxphandle(const unsigned int linuxphandle)
+{
+	return find_node_by_prop_value(NULL, "linux,phandle",
+			(char *)&linuxphandle, sizeof(unsigned int));
+}
+
+static inline char *get_path(const void *phandle, char *buf, int len)
+{
+	if (dt_ops.get_path)
+		return dt_ops.get_path(phandle, buf, len);
+
+	return NULL;
+}
+
+static inline void *malloc(unsigned long size)
+{
+	return (platform_ops.malloc) ? platform_ops.malloc(size) : NULL;
+}
+
+static inline void free(void *ptr)
+{
+	if (platform_ops.free)
+		platform_ops.free(ptr);
+}
+
+static inline void exit(void)
+{
+	if (platform_ops.exit)
+		platform_ops.exit();
+	for ( ; ; )
+		;
+}
+#define fatal(args...) { printf(args); exit(); }
+
+
+#define BSS_STACK(size) \
+	static char _bss_stack[size]; \
+	void *_platform_stack_top = _bss_stack + sizeof(_bss_stack);
+
+extern unsigned long timebase_period_ns;
+
+#endif /* _PPC_BOOT_OPS_H_ */
diff --git a/arch/mips/netlogic/boot/page.h b/arch/mips/netlogic/boot/page.h
new file mode 100644
index 0000000..161945c
--- /dev/null
+++ b/arch/mips/netlogic/boot/page.h
@@ -0,0 +1,34 @@
+#ifndef _MIPS_BOOT_PAGE_H
+#define _MIPS_BOOT_PAGE_H
+/*
+ * Copyright (C) 2001 PPC64 Team, IBM Corp
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#ifdef __ASSEMBLY__
+#define ASM_CONST(x) x
+#else
+#define __ASM_CONST(x) x##UL
+#define ASM_CONST(x) __ASM_CONST(x)
+#endif
+
+/* PAGE_SHIFT determines the page size */
+#define PAGE_SHIFT	12
+#define PAGE_SIZE	(ASM_CONST(1) << PAGE_SHIFT)
+#define PAGE_MASK	(~(PAGE_SIZE-1))
+
+/* align addr on a size boundary - adjust address up/down if needed */
+#define _ALIGN_UP(addr, size)	(((addr)+((size)-1))&(~((size)-1)))
+#define _ALIGN_DOWN(addr, size)	((addr)&(~((size)-1)))
+
+/* align addr on a size boundary - adjust address up if needed */
+#define _ALIGN(addr, size)     _ALIGN_UP(addr, size)
+
+/* to align the pointer to the (next) page boundary */
+#define PAGE_ALIGN(addr)	_ALIGN(addr, PAGE_SIZE)
+
+#endif				/* _MIPS_BOOT_PAGE_H */
diff --git a/arch/mips/netlogic/boot/simple_alloc.c b/arch/mips/netlogic/boot/simple_alloc.c
new file mode 100644
index 0000000..c0f9902
--- /dev/null
+++ b/arch/mips/netlogic/boot/simple_alloc.c
@@ -0,0 +1,153 @@
+/*
+ * Implement primitive realloc(3) functionality.
+ *
+ * Author: Mark A. Greer <mgreer@mvista.com>
+ *
+ * 2006 (c) MontaVista, Software, Inc.  This file is licensed under
+ * the terms of the GNU General Public License version 2.  This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#include <stddef.h>
+#include "types.h"
+#include "page.h"
+#include "string.h"
+#include "ops.h"
+
+#define	ENTRY_BEEN_USED	0x01
+#define	ENTRY_IN_USE	0x02
+
+static struct alloc_info {
+	unsigned long	flags;
+	unsigned long	base;
+	unsigned long	size;
+} *alloc_tbl;
+
+static unsigned long tbl_entries;
+static unsigned long alloc_min;
+static unsigned long next_base;
+static unsigned long space_left;
+
+extern struct platform_ops platform_ops;
+
+/*
+ * First time an entry is used, its base and size are set.
+ * An entry can be freed and re-malloc'd but its base & size don't change.
+ * Should be smart enough for needs of bootwrapper.
+ */
+static void *simple_malloc(unsigned long size)
+{
+	unsigned long i;
+	struct alloc_info *p = alloc_tbl;
+
+	if (size == 0)
+		goto err_out;
+
+	size = _ALIGN_UP(size, alloc_min);
+
+	for (i = 0; i < tbl_entries; i++, p++)
+		if (!(p->flags & ENTRY_BEEN_USED)) { /* never been used */
+			if (size <= space_left) {
+				p->base = next_base;
+				p->size = size;
+				p->flags = ENTRY_BEEN_USED | ENTRY_IN_USE;
+				next_base += size;
+				space_left -= size;
+				return (void *)p->base;
+			}
+			goto err_out; /* not enough space left */
+		}
+		/* reuse an entry keeping same base & size */
+		else if (!(p->flags & ENTRY_IN_USE) && (size <= p->size)) {
+			p->flags |= ENTRY_IN_USE;
+			return (void *)p->base;
+		}
+err_out:
+	return NULL;
+}
+
+static struct alloc_info *simple_find_entry(void *ptr)
+{
+	unsigned long i;
+	struct alloc_info *p = alloc_tbl;
+
+	for (i = 0; i < tbl_entries; i++, p++) {
+		if (!(p->flags & ENTRY_BEEN_USED))
+			break;
+		if ((p->flags & ENTRY_IN_USE) &&
+		    (p->base == (unsigned long)ptr))
+			return p;
+	}
+	return NULL;
+}
+
+static void simple_free(void *ptr)
+{
+	struct alloc_info *p = simple_find_entry(ptr);
+
+	if (p != NULL)
+		p->flags &= ~ENTRY_IN_USE;
+}
+
+/*
+ * Change size of area pointed to by 'ptr' to 'size'.
+ * If 'ptr' is NULL, then its a malloc().  If 'size' is 0, then its a free().
+ * 'ptr' must be NULL or a pointer to a non-freed area previously returned by
+ * simple_realloc() or simple_malloc().
+ */
+static void *simple_realloc(void *ptr, unsigned long size)
+{
+	struct alloc_info *p;
+	void *new;
+
+	if (size == 0) {
+		simple_free(ptr);
+		return NULL;
+	}
+
+	if (ptr == NULL)
+		return simple_malloc(size);
+
+	p = simple_find_entry(ptr);
+	if (p == NULL) /* ptr not from simple_malloc/simple_realloc */
+		return NULL;
+	if (size <= p->size) /* fits in current block */
+		return ptr;
+
+	new = simple_malloc(size);
+	memcpy(new, ptr, p->size);
+	simple_free(ptr);
+	return new;
+}
+
+/*
+ * Returns addr of first byte after heap so caller can see if it took
+ * too much space.  If so, change args & try again.
+ */
+void *simple_alloc_init(char *base, unsigned long heap_size,
+			unsigned long granularity, unsigned long max_allocs)
+{
+	unsigned long heap_base, tbl_size;
+
+	heap_size = _ALIGN_UP(heap_size, granularity);
+	alloc_min = granularity;
+	tbl_entries = max_allocs;
+
+	tbl_size = tbl_entries * sizeof(struct alloc_info);
+
+	alloc_tbl = (struct alloc_info *)_ALIGN_UP((unsigned long)base, 8);
+	memset(alloc_tbl, 0, tbl_size);
+
+	heap_base = _ALIGN_UP((unsigned long)alloc_tbl + tbl_size, alloc_min);
+	memset((void *)heap_base, 0, heap_size);
+
+	next_base = heap_base;
+	space_left = heap_size;
+
+	platform_ops.malloc = simple_malloc;
+	platform_ops.free = simple_free;
+	platform_ops.realloc = simple_realloc;
+
+	return (void *)(heap_base + heap_size);
+}
diff --git a/arch/mips/netlogic/boot/stdio.h b/arch/mips/netlogic/boot/stdio.h
new file mode 100644
index 0000000..adffc58
--- /dev/null
+++ b/arch/mips/netlogic/boot/stdio.h
@@ -0,0 +1,19 @@
+#ifndef _PPC_BOOT_STDIO_H_
+#define _PPC_BOOT_STDIO_H_
+
+#include <stdarg.h>
+
+#define	ENOMEM		12	/* Out of Memory */
+#define	EINVAL		22	/* Invalid argument */
+#define ENOSPC		28	/* No space left on device */
+
+extern int printf(const char *fmt, ...) __attribute__((format(printf, 1, 2)));
+
+#define fprintf(fmt, args...)	printf(args)
+
+extern int sprintf(char *buf, const char *fmt, ...)
+	__attribute__((format(printf, 2, 3)));
+
+extern int vsprintf(char *buf, const char *fmt, va_list args);
+
+#endif				/* _PPC_BOOT_STDIO_H_ */
diff --git a/arch/mips/netlogic/boot/string.h b/arch/mips/netlogic/boot/string.h
new file mode 100644
index 0000000..50091cc
--- /dev/null
+++ b/arch/mips/netlogic/boot/string.h
@@ -0,0 +1,20 @@
+#ifndef _PPC_BOOT_STRING_H_
+#define _PPC_BOOT_STRING_H_
+#include <stddef.h>
+
+extern char *strcpy(char *dest, const char *src);
+extern char *strncpy(char *dest, const char *src, size_t n);
+extern char *strcat(char *dest, const char *src);
+extern char *strchr(const char *s, int c);
+extern int strcmp(const char *s1, const char *s2);
+extern int strncmp(const char *s1, const char *s2, size_t n);
+extern size_t strlen(const char *s);
+extern size_t strnlen(const char *s, size_t count);
+
+extern void *memset(void *s, int c, size_t n);
+extern void *memmove(void *dest, const void *src, unsigned long n);
+extern void *memcpy(void *dest, const void *src, unsigned long n);
+extern void *memchr(const void *s, int c, size_t n);
+extern int memcmp(const void *s1, const void *s2, size_t n);
+
+#endif	/* _PPC_BOOT_STRING_H_ */
diff --git a/arch/mips/netlogic/boot/types.h b/arch/mips/netlogic/boot/types.h
new file mode 100644
index 0000000..aaa1213
--- /dev/null
+++ b/arch/mips/netlogic/boot/types.h
@@ -0,0 +1,4 @@
+#ifndef _TYPES_H_
+#define _TYPES_H_
+
+#endif /* _TYPES_H_ */
diff --git a/scripts/dtc/libfdt/fdt.c b/scripts/dtc/libfdt/fdt.c
index 2acaec5..bbbda5c 100644
--- a/scripts/dtc/libfdt/fdt.c
+++ b/scripts/dtc/libfdt/fdt.c
@@ -79,7 +79,7 @@ const void *fdt_offset_ptr(const void *fdt, int offset, int len)
 	const char *p;
 
 	if (fdt_version(fdt) >= 0x11)
-		if (((offset + len) < offset)
+		if ((((unsigned int) offset + (unsigned int) len) < (unsigned int) offset)
 		    || ((offset + len) > fdt_size_dt_struct(fdt)))
 			return NULL;
 
diff --git a/scripts/dtc/libfdt/fdt_rw.c b/scripts/dtc/libfdt/fdt_rw.c
index 8e7ec4c..c41e774 100644
--- a/scripts/dtc/libfdt/fdt_rw.c
+++ b/scripts/dtc/libfdt/fdt_rw.c
@@ -400,6 +400,19 @@ int fdt_open_into(const void *fdt, void *buf, int bufsize)
 	mem_rsv_size = (fdt_num_mem_rsv(fdt)+1)
 		* sizeof(struct fdt_reserve_entry);
 
+#ifdef CONFIG_NLM_COMMON
+	__asm__ __volatile__ (
+			"sync\n"
+			"nop\n"
+			"nop\n"
+			"nop\n"
+			"nop\n"
+			"nop\n"
+			"nop\n"
+			"nop\n"
+			"sync\n");
+#endif
+
 	if (fdt_version(fdt) >= 17) {
 		struct_size = fdt_size_dt_struct(fdt);
 	} else {
-- 
1.7.0.2

