From ba3fc3d1e88ccfe4f5d302de2d1cd83c0656ad07 Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Wed, 16 May 2012 11:37:10 +0800
Subject: [PATCH 2/3] nlm_xlp_64_be: update PCI_MSI driver

Workaround:
When PORTBUS(which is required for AER, PME ..etc) is enabled, slots
other than 0 cannot do MSI. This commit enables all ports to do MSI
(while restricting the intmode  _solely_ to MSI: i.e, INTX and MSI-X
devices trying MSI-X or INTX will get failures)

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/Kconfig            |    2 +
 arch/mips/netlogic/xlp/irq.c |   47 +++++++++++++++++++++++------------------
 arch/mips/pci/pci-xlp.c      |   45 +++++++++++++++++++++++++++++++++++++--
 3 files changed, 70 insertions(+), 24 deletions(-)

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 2689746..c9f62a9 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -812,6 +812,8 @@ config SCHED_OMIT_FRAME_POINTER
 	default y
 
 config GENERIC_HARDIRQS_NO__DO_IRQ
+# XLP_MERGE_TODO
+	default  n if NLM_XLP_SIM || NLM_XLP_EVP_BOARD || NLM_XLP_EVP_N511_BOARD
 	def_bool y
 
 #
diff --git a/arch/mips/netlogic/xlp/irq.c b/arch/mips/netlogic/xlp/irq.c
index a3e147e..4b21ca9 100644
--- a/arch/mips/netlogic/xlp/irq.c
+++ b/arch/mips/netlogic/xlp/irq.c
@@ -551,12 +551,6 @@ static int __nlm_irq_unmask(int irq)
 	if (rvec < 0)
 		return ret;
 
-	ret = __nlm_hal_request_irq(xlp_irq_to_irt(irq) , rvec);
-	if (ret != 0) {
-		printk(KERN_WARNING "Failed to setup IRQ %d\n", irq);
-		return ret;
-	}
-
 	if (((1ULL << rvec) & read_64bit_cp0_eimr()) == 0) {
 		/* This is only for those interrupts which are not statically
 		 * set in EIMR. Could dump stack if spin lock held */
@@ -592,7 +586,17 @@ static void nlm_intx_unmask(unsigned int irq)
 static void nlm_irq_ack(unsigned int irq)
 {
 	unsigned long flags;
+	spin_lock_irqsave(&xlp_pic_lock, flags);
+#ifndef CONFIG_NUMA
+	nlm_hal_ack_pic(xlp_irq_to_irt(irq));
+#else
+	xlp_numa_ack_pic(xlp_irq_to_irt(irq));
+#endif
+	spin_unlock_irqrestore(&xlp_pic_lock, flags);
+}
 
+static void nlm_intx_ack(unsigned int irq)
+{
 	if((irq < XLP_IRQ_RESERVED_MAX) && (irq >= 0)) {
 		return;
 	} else if(irq >= XLP_IRQ_MAX) {
@@ -601,20 +605,16 @@ static void nlm_irq_ack(unsigned int irq)
 	}
 	/* If edge triggered, ack it ASAP. Handle the interrupt later */
 	if (PIC_IRQ_IS_EDGE_TRIGGERED(xlp_irq_to_irt(irq))) {
-		spin_lock_irqsave(&xlp_pic_lock, flags);
 #ifndef CONFIG_NUMA
-		nlm_hal_ack_pic(xlp_irq_to_irt(irq));
+		nlm_irq_ack(irq);
 #else
 		xlp_numa_ack_pic(xlp_irq_to_irt(irq));
 #endif
-		spin_unlock_irqrestore(&xlp_pic_lock, flags);
 	}
 }
 
 static void nlm_irq_end(unsigned int irq)
 {
-	unsigned long flags;
-
 	if((irq < XLP_IRQ_RESERVED_MAX) && (irq >= 0)) {
 		return;
 	} else if(irq >= XLP_IRQ_MAX) {
@@ -623,13 +623,11 @@ static void nlm_irq_end(unsigned int irq)
 	}
 	/* If level triggered, ack it after the device condition is cleared */
 	if (!PIC_IRQ_IS_EDGE_TRIGGERED(xlp_irq_to_irt(irq))) {
-		spin_lock_irqsave(&xlp_pic_lock, flags);
 #ifndef CONFIG_NUMA
-		nlm_hal_ack_pic(xlp_irq_to_irt(irq));
+		nlm_irq_ack(irq);
 #else
 		xlp_numa_ack_pic(xlp_irq_to_irt(irq));
 #endif
-		spin_unlock_irqrestore(&xlp_pic_lock, flags);
 	}
 	return;
 }
@@ -659,12 +657,18 @@ static unsigned int nlm_irq_startup(unsigned int irq)
 	} else if(irq >= XLP_IRQ_MAX) {
 		return 0;
 	}
+	if ((rvec = xlp_rvec_from_irq(irq)) < 0)
+		return -EINVAL;
 	n = xlp_closest_match_cpumask(&m);
 	spin_lock_irqsave(&xlp_pic_lock, flags);
-	rvec = xlp_rvec_from_irq(irq);
 	if (irq_map[irq].usage == 0) {
 		/* Currently unused => not enabled. So, setup and enable */
 		xlp_set_cpumask(n, xlp_irq_to_irt(irq));
+		ret = __nlm_hal_request_irq(xlp_irq_to_irt(irq), rvec);
+		if (ret != 0) {
+			printk(KERN_WARNING "Failed to setup IRQ %d\n", irq);
+			goto __failure;
+		}
 		idx = irq - __irqbase_from_rvec(rvec);
 		set_bit(idx, &(rvec_map[rvec].bitmap));
 		irq_map[irq].usage++;
@@ -729,6 +733,8 @@ static void nlm_irq_shutdown(unsigned int irq)
 		pr_err("irq = %d. Invalid irq requested\n", irq);
 		return;
 	}
+	if ((rvec = xlp_rvec_from_irq(irq)) < 0)
+		return;
 	spin_lock_irqsave(&xlp_pic_lock, flags);
 	if (irq_map[irq].usage == 0) {
 		//fdebug("irq = %d, usage = %d\n", irq, irq_map[irq].usage);
@@ -741,7 +747,6 @@ static void nlm_irq_shutdown(unsigned int irq)
 	 * free up the rvec */
 	if (irq_map[irq].usage == 0) {
 		//fdebug("irq = %d, usage = %d\n", irq, irq_map[irq].usage);
-		rvec = xlp_rvec_from_irq(irq);
 		idx = irq - __irqbase_from_rvec(rvec);
 		clear_bit(idx, &(rvec_map[rvec].bitmap));
 		spin_unlock_irqrestore(&xlp_pic_lock, flags);
@@ -837,7 +842,7 @@ static struct irq_chip nlm_irq_pic = {
 	.unmask = nlm_intx_unmask,
 	.startup = nlm_intx_startup,
 	.shutdown = nlm_intx_shutdown,
-	.ack = nlm_irq_ack,
+	.ack = nlm_intx_ack,
 	.end = nlm_irq_end,
 	.set_affinity = nlm_irq_set_affinity
 };
@@ -1193,7 +1198,7 @@ static void nlm_msix_unmask(unsigned int msix)
 		return ;
 	}
 	spin_lock_irqsave(&xlp_pic_lock, flags);
-	__nlm_irq_mask(XLP_PCIE_MSIX_IRQ(msix - XLP_MSIX_INDEX_START));
+	__nlm_irq_unmask(XLP_PCIE_MSIX_IRQ(msix - XLP_MSIX_INDEX_START));
 	unmask_msi_irq(msix); /* Enable MSI-X -- please note */
 	spin_unlock_irqrestore(&xlp_pic_lock, flags);
 	return;
@@ -1631,14 +1636,14 @@ void __init init_nlm_common_irqs(void)
 	u64	mask = 0;
 
 	for (i = 0; i < XLP_IRQ_MAX; i++) {	// IRQ : 0 - 167
-		set_irq_chip_and_handler(i, &nlm_irq_pic, handle_level_irq);
+		set_irq_chip(i, &nlm_irq_pic);
 	}
 #ifdef CONFIG_PCI_MSI
 	for (i = XLP_MSI_INDEX_START; i <= XLP_MSI_INDEX_END; i++) {
-		set_irq_chip_and_handler(i, &nlm_msi_pic, handle_level_irq);
+		set_irq_chip(i, &nlm_msi_pic);
 	}
 	for (i = XLP_MSIX_INDEX_START; i <= XLP_MSIX_INDEX_END; i++) {
-		set_irq_chip_and_handler(i, &nlm_msix_pic, handle_level_irq);
+		set_irq_chip(i, &nlm_msix_pic);
 	}
 #endif
 
diff --git a/arch/mips/pci/pci-xlp.c b/arch/mips/pci/pci-xlp.c
index 6054956..21e5d26 100644
--- a/arch/mips/pci/pci-xlp.c
+++ b/arch/mips/pci/pci-xlp.c
@@ -35,6 +35,10 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <linux/console.h>
 #include <linux/ide.h>
 
+#if defined CONFIG_PCIEPORTBUS
+#include <linux/pcieport_if.h>
+#endif
+
 #include <asm/io.h>
 
 #include <asm/netlogic/xlp_irq.h>
@@ -44,6 +48,12 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <asm/netlogic/sim.h>
 #include <asm/netlogic/xlp_hal_pic.h>
 
+#if defined CONFIG_PCIEPORTBUS
+#define PORT_TYPE_MASK			0xf
+#define PCIE_CAPABILITIES_REG		0x2
+#define PCIE_RC_PORT			4
+#endif
+
 extern int pci_probe_only;
 static void *pci_config_base;
 static const volatile void *pci_io_base;
@@ -201,14 +211,43 @@ static int xlp_map_helper(int row, int fn)
 	return 0;
 }
 
+#if defined CONFIG_PCIEPORTBUS
+int xlp_is_dev_rc(struct pci_dev *dev)
+{
+	u16 reg16 = 0;
+	int pos, port_type = 0;
+
+	if (!(pos = pci_find_capability(dev, PCI_CAP_ID_EXP)))
+		return -EINVAL;
+
+	pci_read_config_word(dev, pos + PCIE_CAPABILITIES_REG, &reg16);
+
+	port_type = (reg16 >> 4) & PORT_TYPE_MASK;
+
+	if (port_type == PCIE_RC_PORT) {
+		return 0;
+	}
+
+	return -EINVAL;
+}
+#endif
+
 /*
  * Iterates over buses to find out the slot (thus pci controller fn)
  */
-int xlp_ctrl_fn_from_dev(const struct pci_dev *dev)
+#define DISABLE_MSIX 0x3
+int xlp_ctrl_fn_from_dev(struct pci_dev *dev)
 {
 	__label__ out;
 	int row = 0, fn = 0;
 
+#if defined CONFIG_PCIEPORTBUS
+	if (xlp_is_dev_rc(dev) == 0) {
+		fn = dev->devfn & DISABLE_MSIX;
+		return fn;
+	}
+#endif
+
 	while (row < 4) {
 		fn = 0;
 		while (fn < 4) {
@@ -261,7 +300,7 @@ static void xlp_msi_controller_init(int fn)
 	u8 mmc;
 	u32 msi;
 
-	xlp_pci_base = XLP_BDF_BASE(0,1,fn);
+	xlp_pci_base = XLP_BDF_BASE(0, 1, fn);
 	if (XLP_MSI_ADDR == 0) {
 		printk(KERN_ERR "MSI/MSI-X CANNOT be programmed\n");
 		return;
@@ -566,7 +605,7 @@ int __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
 		break;
 	}
 	row = (xlp_get_power_on_reset_cfg(0) >> 23) & 0x3;
-	fn = xlp_ctrl_fn_from_dev(dev);
+	fn = xlp_ctrl_fn_from_dev((struct pci_dev *)dev);
 	dev_printk(KERN_DEBUG, &dev->dev, "Assigning interrupt %#x\n", xlp_irqmap[row].farray[fn].intno);
 	return xlp_irqmap[row].farray[fn].intno;
 }
-- 
1.7.0.4

