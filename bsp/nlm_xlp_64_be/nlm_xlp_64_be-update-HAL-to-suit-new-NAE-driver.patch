From 547da44d364a5dc1156c9aebe9835d4b4afd9379 Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Wed, 14 Nov 2012 16:16:52 +0800
Subject: [PATCH 3/3] nlm_xlp_64_be: update HAL to suit new NAE driver

Update HAL code to suit new NAE driver, based on SDK2.2.5.

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 .../asm/netlogic/hal/nlm_10ge_phy_nlp1042.h        |  736 +++++++
 arch/mips/include/asm/netlogic/hal/nlm_eeprom.h    |    1 +
 arch/mips/include/asm/netlogic/hal/nlm_evp_cpld.h  |    1 +
 arch/mips/include/asm/netlogic/hal/nlm_hal.h       |   95 +-
 arch/mips/include/asm/netlogic/hal/nlm_hal_cde.h   |   59 +-
 .../mips/include/asm/netlogic/hal/nlm_hal_crypto.h |   53 +-
 arch/mips/include/asm/netlogic/hal/nlm_hal_fmn.h   |  161 +-
 arch/mips/include/asm/netlogic/hal/nlm_hal_kbp.h   | 1033 +++++++++
 .../mips/include/asm/netlogic/hal/nlm_hal_macros.h |   85 +-
 arch/mips/include/asm/netlogic/hal/nlm_hal_nae.h   |  140 +-
 arch/mips/include/asm/netlogic/hal/nlm_hal_pic.h   |  458 ++++
 arch/mips/include/asm/netlogic/hal/nlm_hal_rsa.h   |  955 +++++++++
 arch/mips/include/asm/netlogic/hal/nlm_hal_sys.h   |  160 ++-
 .../include/asm/netlogic/hal/nlm_hal_vsemi_data.h  |   22 +
 .../include/asm/netlogic/hal/nlm_hal_xlp_dev.h     | 1130 ++++++++--
 arch/mips/include/asm/netlogic/hal/nlm_nae.h       |   79 +-
 arch/mips/include/asm/netlogic/xlp_irq.h           |    1 -
 arch/mips/netlogic/common/Makefile                 |    6 +-
 arch/mips/netlogic/common/nlm_eeprom.c             |   36 +-
 arch/mips/netlogic/common/nlm_evp_cpld.c           |   85 +-
 arch/mips/netlogic/common/nlm_hal.c                |  593 +++---
 arch/mips/netlogic/common/nlm_hal_cpu_info.c       |  738 ++-----
 arch/mips/netlogic/common/nlm_hal_fmn_config.c     |  187 ++-
 arch/mips/netlogic/common/nlm_hal_nae.c            | 2254 ++++++++++++++++----
 arch/mips/netlogic/common/nlm_hal_sys.c            |  706 ++++++-
 arch/mips/netlogic/common/nlm_hal_vsemi_config.c   |  695 ++++++
 drivers/ata/xlp-ahci.c                             |    1 -
 27 files changed, 8510 insertions(+), 1960 deletions(-)
 create mode 100644 arch/mips/include/asm/netlogic/hal/nlm_10ge_phy_nlp1042.h
 create mode 100644 arch/mips/include/asm/netlogic/hal/nlm_hal_kbp.h
 create mode 100644 arch/mips/include/asm/netlogic/hal/nlm_hal_pic.h
 create mode 100644 arch/mips/include/asm/netlogic/hal/nlm_hal_rsa.h
 create mode 100644 arch/mips/include/asm/netlogic/hal/nlm_hal_vsemi_data.h
 create mode 100644 arch/mips/netlogic/common/nlm_hal_vsemi_config.c

diff --git a/arch/mips/include/asm/netlogic/hal/nlm_10ge_phy_nlp1042.h b/arch/mips/include/asm/netlogic/hal/nlm_10ge_phy_nlp1042.h
new file mode 100644
index 0000000..a346b78
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/hal/nlm_10ge_phy_nlp1042.h
@@ -0,0 +1,736 @@
+//
+// v1p7 mwj 2011-05-12
+//  add transpose (1.c20c.9) when RX_LOS asserted for LED link status
+// v1p8 pc  2011-05-24 update using margaret ocal_tx_losXposee_tgt_v1p8.uc
+//  add LC PLL lookup table to reliably run a wider temperature range
+// v1p9 mwj 2011-05-31
+//  add lrcv/lrxmit reset and xaui squelch during RXLOS to ensure no LED
+//     when RXLOS = 1 and no incoming signal
+//  changed wait time after SRAM load to 300ms to ensure contvideal values
+//     are udpated
+// v1p9B mwj 2011-06-30
+//  store temp to 1.eff0
+//  increased wait time to 400ms in case customer MDIO is faster and
+//     reaches RCON faster
+// v1p10 mwj 2011-07-02
+//  store temp to 1.ef2c to stay consistent with other firmware
+//  temp sense / contvideal LUT increased to 10 steps from 3
+// v1p10B mwj 2011-07-05
+//  optimized LUT values
+
+// MPS - Pete Moore, convert to .c functions for XLP SDK HAL
+
+
+// calico_C2 settings...
+// --------------------------------------------------
+// NOTE, no reset (h/  nlm_nlp_phy_mod(pa,or x.0000.15) here
+
+// PART 1, nlp_init ----------------------------------
+uint16_t nlm_xaui_phy_read(int phyaddr, int devaddr, int regidx);
+void nlm_xaui_phy_write(int phyaddr, int devaddr, int regidx, uint16_t val);
+
+static inline void nlm_nlp_phy_mod(int pa, int da, uint16_t ra, int bh, int bl,
+	uint16_t val)
+{
+  uint16_t mask = 0xffff;
+  uint16_t tval;
+  int i;
+
+  for (i=bl; i<(bh+1); i++) {
+    mask &= ~(1 << i);
+  }
+
+  tval = nlm_xaui_phy_read(pa, da, ra);
+  //nlm_print("Phymod read %x:%x:%x: 0x%02x\n", pa, da, ra, tval);
+  tval &= mask;
+  tval |= (val << bl);
+  nlm_xaui_phy_write(pa, da, ra, tval);
+  //nlm_print("Phymod Write %x:%x:%x: 0x%02x\n", pa, da, ra, tval);
+}
+
+static inline void nlm_nlp1042_init(int pa)
+{
+  nlm_nlp_phy_mod(pa,1,0xca42,10,8, 0x1); 	//  cmu_e2o_tx,vcocaplrsel
+  nlm_nlp_phy_mod(pa,1,0xca44,15,12, 0x8); 	//  cmu_e2o_tx,reg_vcotailsel
+  nlm_nlp_phy_mod(pa,1,0xca44,9,5, 0x10); 	//  cmu_e2o_tx,reg_contvideal
+  nlm_nlp_phy_mod(pa,1,0xca46,8,8, 0x1); 	//  cmu_e2o_tx,reg_cp_highv_en
+  nlm_nlp_phy_mod(pa,1,0xca46,11,9 , 0x4); 	//  cmu_e2o_tx,reg_cp_highvctl
+  nlm_nlp_phy_mod(pa,1,0xcb0e,13,12, 0x1); 	//  bt_237_236_ir25txcmu1
+  nlm_nlp_phy_mod(pa,1,0xca4c,5,0  , 0x2); 	//  cmu_e2o_tx,antesten
+  nlm_nlp_phy_mod(pa,1,0xca12,10,8 , 0x1); 	//  cmu_o2e_lim,vcocaplrsel
+  nlm_nlp_phy_mod(pa,1,0xca14,15,12, 0x8); 	//  cmu_o2e_lim,reg_vcotailsel
+  nlm_nlp_phy_mod(pa,1,0xca14,9,5  , 0x10); 	//  cmu_o2e_lim,reg_contvideal
+  nlm_nlp_phy_mod(pa,1,0xca16,8,8, 0x1); 	//  cmu_o2e_lim,reg_cp_highv_en
+  nlm_nlp_phy_mod(pa,1,0xca16,11,9 , 0x4); 	//  cmu_o2e_lim,reg_cp_highvctl
+  nlm_nlp_phy_mod(pa,1,0xcb06,13,12, 0x1); 	//  bt_109_108_ir25rxfcmu1
+  nlm_nlp_phy_mod(pa,1,0xca1c,5,0  , 0x2); 	//  cmu_o2e_lim,antesten
+  nlm_nlp_phy_mod(pa,1,0xca42,13,11, 0x1); 	//  cmu_e2o_tx,reg_bufcaplrsel
+  nlm_nlp_phy_mod(pa,1,0xca43,14,12, 0x2); 	//  cmu_e2o_tx,bufcmc
+  nlm_nlp_phy_mod(pa,1,0xc246,9,7  , 0x3); 	//  csbiasmuxsel
+  nlm_nlp_phy_mod(pa,1,0xc242,2,0  , 0x0); 	//  lkbiassel
+  nlm_nlp_phy_mod(pa,1,0xc240,7,4  , 0x0); 	//  ldbiassel
+  nlm_nlp_phy_mod(pa,1,0xc240,13,11, 0x7); 	//  cmbiassel
+  nlm_nlp_phy_mod(pa,1,0xc242,15,13, 0x0); 	//  cspredrvsel
+  nlm_nlp_phy_mod(pa,1,0xc246,0,0, 0x0); 	//  sfpmodeen
+  nlm_nlp_phy_mod(pa,1,0xc246,1,1, 0x1); 	//  krmodeen
+  nlm_nlp_phy_mod(pa,1,0xc243,4,0, 0x1); 	//  drvpre
+  nlm_nlp_phy_mod(pa,1,0xc243,10,5, 0x3f); 	//  drvmain
+  nlm_nlp_phy_mod(pa,1,0xc243,15,11, 0x2); 	//  drvpost
+  nlm_nlp_phy_mod(pa,1,0xcb0b,1,0, 0x1); 	//  bt_177_176_ic25drvbias0
+  nlm_nlp_phy_mod(pa,1,0xcb0b,5,4, 0x1); 	//  bt_181_180_ir25drvbias0
+  nlm_nlp_phy_mod(pa,1,0xcb0b,9,8, 0x3); 	//  bt_185_184_ir25drvbias2
+  nlm_nlp_phy_mod(pa,1,0xcb0b,11,10, 0x3); 	//  bt_187_186_ir25drvbias3
+  nlm_nlp_phy_mod(pa,1,0xcb0b,13,12, 0x3); 	//  bt_189_188_ir25drvbias4
+  nlm_nlp_phy_mod(pa,1,0xcb0b,15,14, 0x3); 	//  bt_191_190_ir25drvbias5
+  nlm_nlp_phy_mod(pa,1,0xcc00,7,0, 0x0); 	//  lsatxfi_o2e_rxrxfcdrqoffs
+  nlm_nlp_phy_mod(pa,1,0xcc02,7,7, 0x1); 	//  lsatxfi_o2e_rxrxfcdrwrpmltgl
+  nlm_nlp_phy_mod(pa,1,0xcc02,7,7, 0x0); 	//  lsatxfi_o2e_rxrxfcdrwrpmltgl
+  nlm_nlp_phy_mod(pa,1,0xcc07,4,0, 0x17); 	//  lsatxfi_o2e_rxrxfeqklp
+  nlm_nlp_phy_mod(pa,1,0xcc08,5,0, 0x1f); 	//  lsatxfi_o2e_rxrxfdfetap1
+  nlm_nlp_phy_mod(pa,1,0xcc08,11,6, 0x1f); 	//  lsatxfi_o2e_rxrxfdfetap2
+  nlm_nlp_phy_mod(pa,1,0xcc09,5,0, 0x1f); 	//  lsatxfi_o2e_rxrxfdfetap3
+  nlm_nlp_phy_mod(pa,1,0xcc09,11,6, 0x1f); 	//  lsatxfi_o2e_rxrxfdfetap4
+  nlm_nlp_phy_mod(pa,1,0xcc07,8,5, 0x0); 	//  lsatxfi_o2e_rxrxfeqmres
+  nlm_nlp_phy_mod(pa,1,0xcc0e,0,0, 0x1); 	//  lsatxfi_o2e_rxrxfdfetapstrobe
+  nlm_nlp_phy_mod(pa,1,0xcc0e,1,1, 0x1); 	//  lsatxfi_o2e_rxrxfdfeosdacstrobe
+  nlm_nlp_phy_mod(pa,1,0xcc0e,2,2, 0x1); 	//  lsatxfi_o2e_rxrxfeqosdacstrobe
+  nlm_nlp_phy_mod(pa,1,0xcc0e,0,0, 0x0); 	//  lsatxfi_o2e_rxrxfdfetapstrobe
+  nlm_nlp_phy_mod(pa,1,0xcc0e,1,1, 0x0); 	//  lsatxfi_o2e_rxrxfdfeosdacstrobe
+  nlm_nlp_phy_mod(pa,1,0xcc0e,2,2, 0x0); 	//  lsatxfi_o2e_rxrxfeqosdacstrobe
+  nlm_nlp_phy_mod(pa,1,0xcc02,5,5, 0x1); 	//  lsatxfi_o2e_rxrxfclk16inv
+  nlm_nlp_phy_mod(pa,1,0xcc04,0,0, 0x1); 	//  lsatxfi_o2e_rxrxfvgaovrden
+  nlm_nlp_phy_mod(pa,1,0xcc04,8,1, 0x5a); 	//  lsatxfi_o2e_rxrxfvgaovrd
+  nlm_nlp_phy_mod(pa,1,0xcc11,5,3, 0x0); 	//  lsatxfi_o2e_rxrxfdfetap1adj
+  nlm_nlp_phy_mod(pa,1,0xcc11,8,6, 0x0); 	//  lsatxfi_o2e_rxrxfdfetap2adj
+  nlm_nlp_phy_mod(pa,1,0xcc11,11,9, 0x0); 	//  lsatxfi_o2e_rxrxfdfetap3adj
+  nlm_nlp_phy_mod(pa,1,0xcc11,14,12, 0x0); 	//  lsatxfi_o2e_rxrxfdfetap4adj
+  nlm_nlp_phy_mod(pa,1,0xcc11,2,0, 0x0); 	//  lsatxfi_o2e_rxrxfdfemainadj
+  nlm_nlp_phy_mod(pa,1,0xcb02,7,4, 0xf); 	//  bt_039_036_ir50rxfeq1
+  nlm_nlp_phy_mod(pa,1,0xcb02,3,0, 0xf); 	//  bt_035_032_ir50rxfeq0
+  nlm_nlp_phy_mod(pa,1,0xcb21,15,12, 0x1); 	//  bt_543_540_ir50xtpll3
+  nlm_nlp_phy_mod(pa,1,0xca01,0,0, 0x1); 	//  cmu_o2e_tx,cpdac_ovrd
+  nlm_nlp_phy_mod(pa,1,0xca01,7,1, 0x8); 	//  cmu_o2e_tx,ov_cpdac
+  nlm_nlp_phy_mod(pa,1,0xcb1b,15,12, 0x1); 	//  bt_447_444_ir50xrpll3
+  nlm_nlp_phy_mod(pa,1,0xca51,0,0, 0x1); 	//  cmu_e2o_rx,cpdac_ovrd
+  nlm_nlp_phy_mod(pa,1,0xca51,7,1, 0x8); 	//  cmu_e2o_rx,ov_cpdac
+  nlm_nlp_phy_mod(pa,1,0xc2c3,3,0, 0xf); 	//  pwdpostb
+  nlm_nlp_phy_mod(pa,1,0xc2ca,15,11, 0x8); 	//  drvpost0
+  nlm_nlp_phy_mod(pa,1,0xc2d0,15,11, 0x8); 	//  drvpost1
+  nlm_nlp_phy_mod(pa,1,0xc2d6,15,11, 0x8); 	//  drvpost2
+  nlm_nlp_phy_mod(pa,1,0xc2dc,15,11, 0x8); 	//  drvpost3
+  nlm_nlp_phy_mod(pa,1,0xc2f1,5,1, 0xa); 	//  xreqklp0
+  nlm_nlp_phy_mod(pa,1,0xc2f1,8,6, 0x0); 	//  xreqmlpf0
+  nlm_nlp_phy_mod(pa,1,0xc2f5,5,1, 0xa); 	//  xreqklp1
+  nlm_nlp_phy_mod(pa,1,0xc2f5,8,6, 0x0); 	//  xreqmlpf1
+  nlm_nlp_phy_mod(pa,1,0xc2f9,5,1, 0xa); 	//  xreqklp2
+  nlm_nlp_phy_mod(pa,1,0xc2f9,8,6, 0x0); 	//  xreqmlpf2
+  nlm_nlp_phy_mod(pa,1,0xc2fd,5,1, 0xa); 	//  xreqklp3
+  nlm_nlp_phy_mod(pa,1,0xc2fd,8,6, 0x0); 	//  xreqmlpf3
+  nlm_nlp_phy_mod(pa,1,0xc2e8,8,0, 0x100); 	//  xrcdrqoffs0
+  nlm_nlp_phy_mod(pa,1,0xc2e9,8,0, 0x100); 	//  xrcdrqoffs1
+  nlm_nlp_phy_mod(pa,1,0xc2ea,8,0, 0x100); 	//  xrcdrqoffs2
+  nlm_nlp_phy_mod(pa,1,0xc2eb,8,0, 0x100); 	//  xrcdrqoffs3
+  nlm_nlp_phy_mod(pa,1,0xc2e6,11,11, 0x1); 	//  xrcdrwrpmltgl
+  nlm_nlp_phy_mod(pa,1,0xc2e6,11,11, 0x0); 	//  xrcdrwrpmltgl
+  nlm_nlp_phy_mod(pa,1,0xc010,14,14, 0x1); 	//  ber_los_mask
+  nlm_nlp_phy_mod(pa,1,0xc017,13,13, 0x0);   //  rx_pmainpcsfault_mask
+  nlm_nlp_phy_mod(pa,1,0xc010,13,13, 0x1);   //  los_opt_intlos_mask
+  nlm_nlp_phy_mod(pa,1,0xcd40,3,0, 0x1);   //  pdtrgmsk_10gbrx
+  nlm_nlp_phy_mod(pa,1,0xc019,10,10, 0x1);   //  sd_intlos_mask
+  nlm_nlp_phy_mod(pa,1,0xff2a,15,0, 0x4a);
+
+// PART 2, uc code  ----------------------------------
+
+// cmdUC processing binary and source file...
+// cmdUC Writing binary into memory...
+  nlm_nlp_phy_mod(pa,1,0xd008,0,0, 0x1);
+// config uC
+  nlm_udelay(100000); // 100ms
+  nlm_nlp_phy_mod(pa,1,0xd000,15,0, 0x5200);
+  nlm_udelay(100000); // 100ms
+// writing binary into uC SRAM...
+  nlm_nlp_phy_mod(pa,1,0xd800,15,0, 0x2fff);
+  nlm_nlp_phy_mod(pa,1,0xd801,15,0, 0x300f);
+  nlm_nlp_phy_mod(pa,1,0xd802,15,0, 0x2ff4);
+  nlm_nlp_phy_mod(pa,1,0xd803,15,0, 0x3ef4);
+  nlm_nlp_phy_mod(pa,1,0xd804,15,0, 0x20ae);
+  nlm_nlp_phy_mod(pa,1,0xd805,15,0, 0x301e);
+  nlm_nlp_phy_mod(pa,1,0xd806,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd807,15,0, 0x22c4);
+  nlm_nlp_phy_mod(pa,1,0xd808,15,0, 0x3ef4);
+  nlm_nlp_phy_mod(pa,1,0xd809,15,0, 0x400e);
+  nlm_nlp_phy_mod(pa,1,0xd80a,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd80b,15,0, 0x220e);
+  nlm_nlp_phy_mod(pa,1,0xd80c,15,0, 0x300e);
+  nlm_nlp_phy_mod(pa,1,0xd80d,15,0, 0x2124);
+  nlm_nlp_phy_mod(pa,1,0xd80e,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd80f,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd810,15,0, 0x23fe);
+  nlm_nlp_phy_mod(pa,1,0xd811,15,0, 0x3c1e);
+  nlm_nlp_phy_mod(pa,1,0xd812,15,0, 0x2214);
+  nlm_nlp_phy_mod(pa,1,0xd813,15,0, 0x3ca4);
+  nlm_nlp_phy_mod(pa,1,0xd814,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd815,15,0, 0x20a4);
+  nlm_nlp_phy_mod(pa,1,0xd816,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd817,15,0, 0x2dfe);
+  nlm_nlp_phy_mod(pa,1,0xd818,15,0, 0x307e);
+  nlm_nlp_phy_mod(pa,1,0xd819,15,0, 0x6e24);
+  nlm_nlp_phy_mod(pa,1,0xd81a,15,0, 0x6e24);
+  nlm_nlp_phy_mod(pa,1,0xd81b,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd81c,15,0, 0x20e4);
+  nlm_nlp_phy_mod(pa,1,0xd81d,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd81e,15,0, 0x402e);
+  nlm_nlp_phy_mod(pa,1,0xd81f,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd820,15,0, 0x400e);
+  nlm_nlp_phy_mod(pa,1,0xd821,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd822,15,0, 0x2014);
+  nlm_nlp_phy_mod(pa,1,0xd823,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd824,15,0, 0x64de);
+  nlm_nlp_phy_mod(pa,1,0xd825,15,0, 0x6e8f);
+  nlm_nlp_phy_mod(pa,1,0xd826,15,0, 0x400e);
+  nlm_nlp_phy_mod(pa,1,0xd827,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd828,15,0, 0x2044);
+  nlm_nlp_phy_mod(pa,1,0xd829,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd82a,15,0, 0x64de);
+  nlm_nlp_phy_mod(pa,1,0xd82b,15,0, 0x6e8f);
+  nlm_nlp_phy_mod(pa,1,0xd82c,15,0, 0x201e);
+  nlm_nlp_phy_mod(pa,1,0xd82d,15,0, 0x300e);
+  nlm_nlp_phy_mod(pa,1,0xd82e,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd82f,15,0, 0x20d4);
+  nlm_nlp_phy_mod(pa,1,0xd830,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd831,15,0, 0x64de);
+  nlm_nlp_phy_mod(pa,1,0xd832,15,0, 0x6e8f);
+  nlm_nlp_phy_mod(pa,1,0xd833,15,0, 0x21fe);
+  nlm_nlp_phy_mod(pa,1,0xd834,15,0, 0x300e);
+  nlm_nlp_phy_mod(pa,1,0xd835,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd836,15,0, 0x20e4);
+  nlm_nlp_phy_mod(pa,1,0xd837,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd838,15,0, 0x404e);
+  nlm_nlp_phy_mod(pa,1,0xd839,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd83a,15,0, 0x400e);
+  nlm_nlp_phy_mod(pa,1,0xd83b,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd83c,15,0, 0x21f5);
+  nlm_nlp_phy_mod(pa,1,0xd83d,15,0, 0x3005);
+  nlm_nlp_phy_mod(pa,1,0xd83e,15,0, 0xb805);
+  nlm_nlp_phy_mod(pa,1,0xd83f,15,0, 0x8556);
+  nlm_nlp_phy_mod(pa,1,0xd840,15,0, 0x8557);
+  nlm_nlp_phy_mod(pa,1,0xd841,15,0, 0x8558);
+  nlm_nlp_phy_mod(pa,1,0xd842,15,0, 0x8559);
+  nlm_nlp_phy_mod(pa,1,0xd843,15,0, 0x855a);
+  nlm_nlp_phy_mod(pa,1,0xd844,15,0, 0x400d);
+  nlm_nlp_phy_mod(pa,1,0xd845,15,0, 0x6d8f);
+  nlm_nlp_phy_mod(pa,1,0xd846,15,0, 0x2032);
+  nlm_nlp_phy_mod(pa,1,0xd847,15,0, 0x3022);
+  nlm_nlp_phy_mod(pa,1,0xd848,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd849,15,0, 0x2132);
+  nlm_nlp_phy_mod(pa,1,0xd84a,15,0, 0x3022);
+  nlm_nlp_phy_mod(pa,1,0xd84b,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd84c,15,0, 0x21c2);
+  nlm_nlp_phy_mod(pa,1,0xd84d,15,0, 0x3022);
+  nlm_nlp_phy_mod(pa,1,0xd84e,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd84f,15,0, 0x2302);
+  nlm_nlp_phy_mod(pa,1,0xd850,15,0, 0x3022);
+  nlm_nlp_phy_mod(pa,1,0xd851,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd852,15,0, 0x23a2);
+  nlm_nlp_phy_mod(pa,1,0xd853,15,0, 0x3022);
+  nlm_nlp_phy_mod(pa,1,0xd854,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd855,15,0, 0x24c2);
+  nlm_nlp_phy_mod(pa,1,0xd856,15,0, 0x3022);
+  nlm_nlp_phy_mod(pa,1,0xd857,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd858,15,0, 0x2562);
+  nlm_nlp_phy_mod(pa,1,0xd859,15,0, 0x3022);
+  nlm_nlp_phy_mod(pa,1,0xd85a,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd85b,15,0, 0x6f7e);
+  nlm_nlp_phy_mod(pa,1,0xd85c,15,0, 0x4004);
+  nlm_nlp_phy_mod(pa,1,0xd85d,15,0, 0xb814);
+  nlm_nlp_phy_mod(pa,1,0xd85e,15,0, 0x5e43);
+  nlm_nlp_phy_mod(pa,1,0xd85f,15,0, 0x3d7);
+  nlm_nlp_phy_mod(pa,1,0xd860,15,0, 0x2032);
+  nlm_nlp_phy_mod(pa,1,0xd861,15,0, 0x3022);
+  nlm_nlp_phy_mod(pa,1,0xd862,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd863,15,0, 0x200e);
+  nlm_nlp_phy_mod(pa,1,0xd864,15,0, 0x300e);
+  nlm_nlp_phy_mod(pa,1,0xd865,15,0, 0x2);
+  nlm_nlp_phy_mod(pa,1,0xd866,15,0, 0xd01e);
+  nlm_nlp_phy_mod(pa,1,0xd867,15,0, 0x6e8f);
+  nlm_nlp_phy_mod(pa,1,0xd868,15,0, 0x20fe);
+  nlm_nlp_phy_mod(pa,1,0xd869,15,0, 0x300e);
+  nlm_nlp_phy_mod(pa,1,0xd86a,15,0, 0xb80e);
+  nlm_nlp_phy_mod(pa,1,0xd86b,15,0, 0xd01d);
+  nlm_nlp_phy_mod(pa,1,0xd86c,15,0, 0x5de3);
+  nlm_nlp_phy_mod(pa,1,0xd86d,15,0, 0x249e);
+  nlm_nlp_phy_mod(pa,1,0xd86e,15,0, 0x301e);
+  nlm_nlp_phy_mod(pa,1,0xd86f,15,0, 0x135e);
+  nlm_nlp_phy_mod(pa,1,0xd870,15,0, 0x6f7e);
+  nlm_nlp_phy_mod(pa,1,0xd871,15,0, 0x6f7e);
+  nlm_nlp_phy_mod(pa,1,0xd872,15,0, 0x20d4);
+  nlm_nlp_phy_mod(pa,1,0xd873,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd874,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd875,15,0, 0x20e4);
+  nlm_nlp_phy_mod(pa,1,0xd876,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd877,15,0, 0x404e);
+  nlm_nlp_phy_mod(pa,1,0xd878,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd879,15,0, 0x400e);
+  nlm_nlp_phy_mod(pa,1,0xd87a,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd87b,15,0, 0x6f7e);
+  nlm_nlp_phy_mod(pa,1,0xd87c,15,0, 0x2044);
+  nlm_nlp_phy_mod(pa,1,0xd87d,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd87e,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd87f,15,0, 0x6f7e);
+  nlm_nlp_phy_mod(pa,1,0xd880,15,0, 0x2014);
+  nlm_nlp_phy_mod(pa,1,0xd881,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd882,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd883,15,0, 0x200e);
+  nlm_nlp_phy_mod(pa,1,0xd884,15,0, 0x300e);
+  nlm_nlp_phy_mod(pa,1,0xd885,15,0, 0x2124);
+  nlm_nlp_phy_mod(pa,1,0xd886,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd887,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd888,15,0, 0x2504);
+  nlm_nlp_phy_mod(pa,1,0xd889,15,0, 0x3cd4);
+  nlm_nlp_phy_mod(pa,1,0xd88a,15,0, 0x4015);
+  nlm_nlp_phy_mod(pa,1,0xd88b,15,0, 0x65c4);
+  nlm_nlp_phy_mod(pa,1,0xd88c,15,0, 0x2514);
+  nlm_nlp_phy_mod(pa,1,0xd88d,15,0, 0x3cd4);
+  nlm_nlp_phy_mod(pa,1,0xd88e,15,0, 0x64d5);
+  nlm_nlp_phy_mod(pa,1,0xd88f,15,0, 0xb145);
+  nlm_nlp_phy_mod(pa,1,0xd890,15,0, 0xb115);
+  nlm_nlp_phy_mod(pa,1,0xd891,15,0, 0x65c4);
+  nlm_nlp_phy_mod(pa,1,0xd892,15,0, 0x2bd2);
+  nlm_nlp_phy_mod(pa,1,0xd893,15,0, 0x3012);
+  nlm_nlp_phy_mod(pa,1,0xd894,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd895,15,0, 0x678f);
+  nlm_nlp_phy_mod(pa,1,0xd896,15,0, 0x2514);
+  nlm_nlp_phy_mod(pa,1,0xd897,15,0, 0x3cd4);
+  nlm_nlp_phy_mod(pa,1,0xd898,15,0, 0x64d5);
+  nlm_nlp_phy_mod(pa,1,0xd899,15,0, 0xb145);
+  nlm_nlp_phy_mod(pa,1,0xd89a,15,0, 0xb105);
+  nlm_nlp_phy_mod(pa,1,0xd89b,15,0, 0x65c4);
+  nlm_nlp_phy_mod(pa,1,0xd89c,15,0, 0x2bd2);
+  nlm_nlp_phy_mod(pa,1,0xd89d,15,0, 0x3012);
+  nlm_nlp_phy_mod(pa,1,0xd89e,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd89f,15,0, 0x6f78);
+  nlm_nlp_phy_mod(pa,1,0xd8a0,15,0, 0xe78e);
+  nlm_nlp_phy_mod(pa,1,0xd8a1,15,0, 0x22c5);
+  nlm_nlp_phy_mod(pa,1,0xd8a2,15,0, 0x3ef5);
+  nlm_nlp_phy_mod(pa,1,0xd8a3,15,0, 0x6ec5);
+  nlm_nlp_phy_mod(pa,1,0xd8a4,15,0, 0x2084);
+  nlm_nlp_phy_mod(pa,1,0xd8a5,15,0, 0x3034);
+  nlm_nlp_phy_mod(pa,1,0xd8a6,15,0, 0x2005);
+  nlm_nlp_phy_mod(pa,1,0xd8a7,15,0, 0x3d75);
+  nlm_nlp_phy_mod(pa,1,0xd8a8,15,0, 0xc451);
+  nlm_nlp_phy_mod(pa,1,0xd8a9,15,0, 0x2f62);
+  nlm_nlp_phy_mod(pa,1,0xd8aa,15,0, 0x3022);
+  nlm_nlp_phy_mod(pa,1,0xd8ab,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd8ac,15,0, 0x2444);
+  nlm_nlp_phy_mod(pa,1,0xd8ad,15,0, 0x3ca4);
+  nlm_nlp_phy_mod(pa,1,0xd8ae,15,0, 0x2ed2);
+  nlm_nlp_phy_mod(pa,1,0xd8af,15,0, 0x3022);
+  nlm_nlp_phy_mod(pa,1,0xd8b0,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd8b1,15,0, 0x2144);
+  nlm_nlp_phy_mod(pa,1,0xd8b2,15,0, 0x3ca4);
+  nlm_nlp_phy_mod(pa,1,0xd8b3,15,0, 0x2ed2);
+  nlm_nlp_phy_mod(pa,1,0xd8b4,15,0, 0x3022);
+  nlm_nlp_phy_mod(pa,1,0xd8b5,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd8b6,15,0, 0x2f02);
+  nlm_nlp_phy_mod(pa,1,0xd8b7,15,0, 0x3012);
+  nlm_nlp_phy_mod(pa,1,0xd8b8,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd8b9,15,0, 0x28c2);
+  nlm_nlp_phy_mod(pa,1,0xd8ba,15,0, 0x3012);
+  nlm_nlp_phy_mod(pa,1,0xd8bb,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd8bc,15,0, 0x0);
+  nlm_nlp_phy_mod(pa,1,0xd8bd,15,0, 0x628f);
+  nlm_nlp_phy_mod(pa,1,0xd8be,15,0, 0x4007);
+  nlm_nlp_phy_mod(pa,1,0xd8bf,15,0, 0x2524);
+  nlm_nlp_phy_mod(pa,1,0xd8c0,15,0, 0x3cd4);
+  nlm_nlp_phy_mod(pa,1,0xd8c1,15,0, 0x64d5);
+  nlm_nlp_phy_mod(pa,1,0xd8c2,15,0, 0x2005);
+  nlm_nlp_phy_mod(pa,1,0xd8c3,15,0, 0x9575);
+  nlm_nlp_phy_mod(pa,1,0xd8c4,15,0, 0x65c4);
+  nlm_nlp_phy_mod(pa,1,0xd8c5,15,0, 0x678f);
+  nlm_nlp_phy_mod(pa,1,0xd8c6,15,0, 0x2dd2);
+  nlm_nlp_phy_mod(pa,1,0xd8c7,15,0, 0x3012);
+  nlm_nlp_phy_mod(pa,1,0xd8c8,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd8c9,15,0, 0x6f77);
+  nlm_nlp_phy_mod(pa,1,0xd8ca,15,0, 0x2514);
+  nlm_nlp_phy_mod(pa,1,0xd8cb,15,0, 0x3cd4);
+  nlm_nlp_phy_mod(pa,1,0xd8cc,15,0, 0x64d5);
+  nlm_nlp_phy_mod(pa,1,0xd8cd,15,0, 0xbd05);
+  nlm_nlp_phy_mod(pa,1,0xd8ce,15,0, 0xbf45);
+  nlm_nlp_phy_mod(pa,1,0xd8cf,15,0, 0x2db2);
+  nlm_nlp_phy_mod(pa,1,0xd8d0,15,0, 0x3012);
+  nlm_nlp_phy_mod(pa,1,0xd8d1,15,0, 0x5553);
+  nlm_nlp_phy_mod(pa,1,0xd8d2,15,0, 0x1302);
+  nlm_nlp_phy_mod(pa,1,0xd8d3,15,0, 0x2006);
+  nlm_nlp_phy_mod(pa,1,0xd8d4,15,0, 0x3016);
+  nlm_nlp_phy_mod(pa,1,0xd8d5,15,0, 0x5763);
+  nlm_nlp_phy_mod(pa,1,0xd8d6,15,0, 0x13c2);
+  nlm_nlp_phy_mod(pa,1,0xd8d7,15,0, 0xd017);
+  nlm_nlp_phy_mod(pa,1,0xd8d8,15,0, 0x2bf2);
+  nlm_nlp_phy_mod(pa,1,0xd8d9,15,0, 0x3012);
+  nlm_nlp_phy_mod(pa,1,0xd8da,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd8db,15,0, 0x6f72);
+  nlm_nlp_phy_mod(pa,1,0xd8dc,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd8dd,15,0, 0x628f);
+  nlm_nlp_phy_mod(pa,1,0xd8de,15,0, 0x2514);
+  nlm_nlp_phy_mod(pa,1,0xd8df,15,0, 0x3cd4);
+  nlm_nlp_phy_mod(pa,1,0xd8e0,15,0, 0x64d5);
+  nlm_nlp_phy_mod(pa,1,0xd8e1,15,0, 0x4026);
+  nlm_nlp_phy_mod(pa,1,0xd8e2,15,0, 0x9655);
+  nlm_nlp_phy_mod(pa,1,0xd8e3,15,0, 0x65c4);
+  nlm_nlp_phy_mod(pa,1,0xd8e4,15,0, 0x648f);
+  nlm_nlp_phy_mod(pa,1,0xd8e5,15,0, 0x401d);
+  nlm_nlp_phy_mod(pa,1,0xd8e6,15,0, 0x2f22);
+  nlm_nlp_phy_mod(pa,1,0xd8e7,15,0, 0x3012);
+  nlm_nlp_phy_mod(pa,1,0xd8e8,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd8e9,15,0, 0x6f74);
+  nlm_nlp_phy_mod(pa,1,0xd8ea,15,0, 0x2fd6);
+  nlm_nlp_phy_mod(pa,1,0xd8eb,15,0, 0x3ff6);
+  nlm_nlp_phy_mod(pa,1,0xd8ec,15,0, 0x8655);
+  nlm_nlp_phy_mod(pa,1,0xd8ed,15,0, 0x65c4);
+  nlm_nlp_phy_mod(pa,1,0xd8ee,15,0, 0x6f72);
+  nlm_nlp_phy_mod(pa,1,0xd8ef,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd8f0,15,0, 0x22cd);
+  nlm_nlp_phy_mod(pa,1,0xd8f1,15,0, 0x301d);
+  nlm_nlp_phy_mod(pa,1,0xd8f2,15,0, 0x2108);
+  nlm_nlp_phy_mod(pa,1,0xd8f3,15,0, 0x3808);
+  nlm_nlp_phy_mod(pa,1,0xd8f4,15,0, 0x628f);
+  nlm_nlp_phy_mod(pa,1,0xd8f5,15,0, 0x5dd3);
+  nlm_nlp_phy_mod(pa,1,0xd8f6,15,0, 0x2012);
+  nlm_nlp_phy_mod(pa,1,0xd8f7,15,0, 0x3022);
+  nlm_nlp_phy_mod(pa,1,0xd8f8,15,0, 0x1302);
+  nlm_nlp_phy_mod(pa,1,0xd8f9,15,0, 0x63a8);
+  nlm_nlp_phy_mod(pa,1,0xd8fa,15,0, 0x2b72);
+  nlm_nlp_phy_mod(pa,1,0xd8fb,15,0, 0x3022);
+  nlm_nlp_phy_mod(pa,1,0xd8fc,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd8fd,15,0, 0xdffd);
+  nlm_nlp_phy_mod(pa,1,0xd8fe,15,0, 0x2f52);
+  nlm_nlp_phy_mod(pa,1,0xd8ff,15,0, 0x3012);
+  nlm_nlp_phy_mod(pa,1,0xd900,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd901,15,0, 0x6f72);
+  nlm_nlp_phy_mod(pa,1,0xd902,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd903,15,0, 0x2214);
+  nlm_nlp_phy_mod(pa,1,0xd904,15,0, 0x3ca4);
+  nlm_nlp_phy_mod(pa,1,0xd905,15,0, 0x64de);
+  nlm_nlp_phy_mod(pa,1,0xd906,15,0, 0x2ef4);
+  nlm_nlp_phy_mod(pa,1,0xd907,15,0, 0x3ff4);
+  nlm_nlp_phy_mod(pa,1,0xd908,15,0, 0x8e4e);
+  nlm_nlp_phy_mod(pa,1,0xd909,15,0, 0x2214);
+  nlm_nlp_phy_mod(pa,1,0xd90a,15,0, 0x3ca4);
+  nlm_nlp_phy_mod(pa,1,0xd90b,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd90c,15,0, 0x2104);
+  nlm_nlp_phy_mod(pa,1,0xd90d,15,0, 0x3004);
+  nlm_nlp_phy_mod(pa,1,0xd90e,15,0, 0x9e4e);
+  nlm_nlp_phy_mod(pa,1,0xd90f,15,0, 0x2214);
+  nlm_nlp_phy_mod(pa,1,0xd910,15,0, 0x3ca4);
+  nlm_nlp_phy_mod(pa,1,0xd911,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd912,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd913,15,0, 0x2294);
+  nlm_nlp_phy_mod(pa,1,0xd914,15,0, 0x3ca4);
+  nlm_nlp_phy_mod(pa,1,0xd915,15,0, 0x64db);
+  nlm_nlp_phy_mod(pa,1,0xd916,15,0, 0x8bbc);
+  nlm_nlp_phy_mod(pa,1,0xd917,15,0, 0xb84b);
+  nlm_nlp_phy_mod(pa,1,0xd918,15,0, 0x300c);
+  nlm_nlp_phy_mod(pa,1,0xd919,15,0, 0xdf0b);
+  nlm_nlp_phy_mod(pa,1,0xd91a,15,0, 0xdf0c);
+  nlm_nlp_phy_mod(pa,1,0xd91b,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd91c,15,0, 0xc5b5);
+  nlm_nlp_phy_mod(pa,1,0xd91d,15,0, 0xc6c6);
+  nlm_nlp_phy_mod(pa,1,0xd91e,15,0, 0x855e);
+  nlm_nlp_phy_mod(pa,1,0xd91f,15,0, 0xb84e);
+  nlm_nlp_phy_mod(pa,1,0xd920,15,0, 0x866c);
+  nlm_nlp_phy_mod(pa,1,0xd921,15,0, 0xb84c);
+  nlm_nlp_phy_mod(pa,1,0xd922,15,0, 0xb60c);
+  nlm_nlp_phy_mod(pa,1,0xd923,15,0, 0x9cee);
+  nlm_nlp_phy_mod(pa,1,0xd924,15,0, 0x20a4);
+  nlm_nlp_phy_mod(pa,1,0xd925,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd926,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd927,15,0, 0x20e4);
+  nlm_nlp_phy_mod(pa,1,0xd928,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd929,15,0, 0x202e);
+  nlm_nlp_phy_mod(pa,1,0xd92a,15,0, 0x300e);
+  nlm_nlp_phy_mod(pa,1,0xd92b,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd92c,15,0, 0x200e);
+  nlm_nlp_phy_mod(pa,1,0xd92d,15,0, 0x300e);
+  nlm_nlp_phy_mod(pa,1,0xd92e,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd92f,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd930,15,0, 0x22b4);
+  nlm_nlp_phy_mod(pa,1,0xd931,15,0, 0x3ca4);
+  nlm_nlp_phy_mod(pa,1,0xd932,15,0, 0x64db);
+  nlm_nlp_phy_mod(pa,1,0xd933,15,0, 0x8bbc);
+  nlm_nlp_phy_mod(pa,1,0xd934,15,0, 0xb84b);
+  nlm_nlp_phy_mod(pa,1,0xd935,15,0, 0xb80c);
+  nlm_nlp_phy_mod(pa,1,0xd936,15,0, 0xb84c);
+  nlm_nlp_phy_mod(pa,1,0xd937,15,0, 0xdf0b);
+  nlm_nlp_phy_mod(pa,1,0xd938,15,0, 0xdf0c);
+  nlm_nlp_phy_mod(pa,1,0xd939,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd93a,15,0, 0xc7b7);
+  nlm_nlp_phy_mod(pa,1,0xd93b,15,0, 0xc8c8);
+  nlm_nlp_phy_mod(pa,1,0xd93c,15,0, 0x877e);
+  nlm_nlp_phy_mod(pa,1,0xd93d,15,0, 0xb84e);
+  nlm_nlp_phy_mod(pa,1,0xd93e,15,0, 0x888c);
+  nlm_nlp_phy_mod(pa,1,0xd93f,15,0, 0xb84c);
+  nlm_nlp_phy_mod(pa,1,0xd940,15,0, 0xb60c);
+  nlm_nlp_phy_mod(pa,1,0xd941,15,0, 0x9cee);
+  nlm_nlp_phy_mod(pa,1,0xd942,15,0, 0x20b4);
+  nlm_nlp_phy_mod(pa,1,0xd943,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd944,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd945,15,0, 0x20e4);
+  nlm_nlp_phy_mod(pa,1,0xd946,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd947,15,0, 0x402e);
+  nlm_nlp_phy_mod(pa,1,0xd948,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd949,15,0, 0x400e);
+  nlm_nlp_phy_mod(pa,1,0xd94a,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd94b,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd94c,15,0, 0x22a4);
+  nlm_nlp_phy_mod(pa,1,0xd94d,15,0, 0x3ca4);
+  nlm_nlp_phy_mod(pa,1,0xd94e,15,0, 0x64db);
+  nlm_nlp_phy_mod(pa,1,0xd94f,15,0, 0x8bbc);
+  nlm_nlp_phy_mod(pa,1,0xd950,15,0, 0xb84b);
+  nlm_nlp_phy_mod(pa,1,0xd951,15,0, 0xb80c);
+  nlm_nlp_phy_mod(pa,1,0xd952,15,0, 0xb84c);
+  nlm_nlp_phy_mod(pa,1,0xd953,15,0, 0xdf0b);
+  nlm_nlp_phy_mod(pa,1,0xd954,15,0, 0xdf0c);
+  nlm_nlp_phy_mod(pa,1,0xd955,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd956,15,0, 0xc9b9);
+  nlm_nlp_phy_mod(pa,1,0xd957,15,0, 0xcaca);
+  nlm_nlp_phy_mod(pa,1,0xd958,15,0, 0x899e);
+  nlm_nlp_phy_mod(pa,1,0xd959,15,0, 0xb84e);
+  nlm_nlp_phy_mod(pa,1,0xd95a,15,0, 0x8aac);
+  nlm_nlp_phy_mod(pa,1,0xd95b,15,0, 0xb84c);
+  nlm_nlp_phy_mod(pa,1,0xd95c,15,0, 0xb60c);
+  nlm_nlp_phy_mod(pa,1,0xd95d,15,0, 0x9cee);
+  nlm_nlp_phy_mod(pa,1,0xd95e,15,0, 0x20c4);
+  nlm_nlp_phy_mod(pa,1,0xd95f,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd960,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd961,15,0, 0x20e4);
+  nlm_nlp_phy_mod(pa,1,0xd962,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd963,15,0, 0x402e);
+  nlm_nlp_phy_mod(pa,1,0xd964,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd965,15,0, 0x400e);
+  nlm_nlp_phy_mod(pa,1,0xd966,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd967,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd968,15,0, 0x628f);
+  nlm_nlp_phy_mod(pa,1,0xd969,15,0, 0x20a4);
+  nlm_nlp_phy_mod(pa,1,0xd96a,15,0, 0x3004);
+  nlm_nlp_phy_mod(pa,1,0xd96b,15,0, 0x64d9);
+  nlm_nlp_phy_mod(pa,1,0xd96c,15,0, 0x899e);
+  nlm_nlp_phy_mod(pa,1,0xd96d,15,0, 0xbf0e);
+  nlm_nlp_phy_mod(pa,1,0xd96e,15,0, 0xbf4e);
+  nlm_nlp_phy_mod(pa,1,0xd96f,15,0, 0x4012);
+  nlm_nlp_phy_mod(pa,1,0xd970,15,0, 0x2f0e);
+  nlm_nlp_phy_mod(pa,1,0xd971,15,0, 0x300e);
+  nlm_nlp_phy_mod(pa,1,0xd972,15,0, 0x2054);
+  nlm_nlp_phy_mod(pa,1,0xd973,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd974,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd975,15,0, 0x2064);
+  nlm_nlp_phy_mod(pa,1,0xd976,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd977,15,0, 0x64de);
+  nlm_nlp_phy_mod(pa,1,0xd978,15,0, 0x8ee9);
+  nlm_nlp_phy_mod(pa,1,0xd979,15,0, 0xbe0e);
+  nlm_nlp_phy_mod(pa,1,0xd97a,15,0, 0xbf4e);
+  nlm_nlp_phy_mod(pa,1,0xd97b,15,0, 0x5e23);
+  nlm_nlp_phy_mod(pa,1,0xd97c,15,0, 0x382);
+  nlm_nlp_phy_mod(pa,1,0xd97d,15,0, 0x8);
+  nlm_nlp_phy_mod(pa,1,0xd97e,15,0, 0x401e);
+  nlm_nlp_phy_mod(pa,1,0xd97f,15,0, 0x99e9);
+  nlm_nlp_phy_mod(pa,1,0xd980,15,0, 0x69c4);
+  nlm_nlp_phy_mod(pa,1,0xd981,15,0, 0x280e);
+  nlm_nlp_phy_mod(pa,1,0xd982,15,0, 0x300e);
+  nlm_nlp_phy_mod(pa,1,0xd983,15,0, 0x63ae);
+  nlm_nlp_phy_mod(pa,1,0xd984,15,0, 0x8);
+  nlm_nlp_phy_mod(pa,1,0xd985,15,0, 0x2fee);
+  nlm_nlp_phy_mod(pa,1,0xd986,15,0, 0x3ffe);
+  nlm_nlp_phy_mod(pa,1,0xd987,15,0, 0x89e9);
+  nlm_nlp_phy_mod(pa,1,0xd988,15,0, 0x69c4);
+  nlm_nlp_phy_mod(pa,1,0xd989,15,0, 0x280e);
+  nlm_nlp_phy_mod(pa,1,0xd98a,15,0, 0x300e);
+  nlm_nlp_phy_mod(pa,1,0xd98b,15,0, 0x63ae);
+  nlm_nlp_phy_mod(pa,1,0xd98c,15,0, 0x6f72);
+  nlm_nlp_phy_mod(pa,1,0xd98d,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd98e,15,0, 0x628f);
+  nlm_nlp_phy_mod(pa,1,0xd98f,15,0, 0x20a4);
+  nlm_nlp_phy_mod(pa,1,0xd990,15,0, 0x3004);
+  nlm_nlp_phy_mod(pa,1,0xd991,15,0, 0x64d9);
+  nlm_nlp_phy_mod(pa,1,0xd992,15,0, 0x899e);
+  nlm_nlp_phy_mod(pa,1,0xd993,15,0, 0xbf0e);
+  nlm_nlp_phy_mod(pa,1,0xd994,15,0, 0xbf4e);
+  nlm_nlp_phy_mod(pa,1,0xd995,15,0, 0x4012);
+  nlm_nlp_phy_mod(pa,1,0xd996,15,0, 0x5e23);
+  nlm_nlp_phy_mod(pa,1,0xd997,15,0, 0x3d2);
+  nlm_nlp_phy_mod(pa,1,0xd998,15,0, 0x1d);
+  nlm_nlp_phy_mod(pa,1,0xd999,15,0, 0x2f0e);
+  nlm_nlp_phy_mod(pa,1,0xd99a,15,0, 0x300e);
+  nlm_nlp_phy_mod(pa,1,0xd99b,15,0, 0x2054);
+  nlm_nlp_phy_mod(pa,1,0xd99c,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd99d,15,0, 0x6ec4);
+  nlm_nlp_phy_mod(pa,1,0xd99e,15,0, 0x2064);
+  nlm_nlp_phy_mod(pa,1,0xd99f,15,0, 0x3cc4);
+  nlm_nlp_phy_mod(pa,1,0xd9a0,15,0, 0x64de);
+  nlm_nlp_phy_mod(pa,1,0xd9a1,15,0, 0x8ee9);
+  nlm_nlp_phy_mod(pa,1,0xd9a2,15,0, 0xbe0e);
+  nlm_nlp_phy_mod(pa,1,0xd9a3,15,0, 0xbf4e);
+  nlm_nlp_phy_mod(pa,1,0xd9a4,15,0, 0x5e23);
+  nlm_nlp_phy_mod(pa,1,0xd9a5,15,0, 0x382);
+  nlm_nlp_phy_mod(pa,1,0xd9a6,15,0, 0x9);
+  nlm_nlp_phy_mod(pa,1,0xd9a7,15,0, 0x2fee);
+  nlm_nlp_phy_mod(pa,1,0xd9a8,15,0, 0x3ffe);
+  nlm_nlp_phy_mod(pa,1,0xd9a9,15,0, 0x89e9);
+  nlm_nlp_phy_mod(pa,1,0xd9aa,15,0, 0x69c4);
+  nlm_nlp_phy_mod(pa,1,0xd9ab,15,0, 0x280e);
+  nlm_nlp_phy_mod(pa,1,0xd9ac,15,0, 0x300e);
+  nlm_nlp_phy_mod(pa,1,0xd9ad,15,0, 0x63ae);
+  nlm_nlp_phy_mod(pa,1,0xd9ae,15,0, 0x7);
+  nlm_nlp_phy_mod(pa,1,0xd9af,15,0, 0x401e);
+  nlm_nlp_phy_mod(pa,1,0xd9b0,15,0, 0x99e9);
+  nlm_nlp_phy_mod(pa,1,0xd9b1,15,0, 0x69c4);
+  nlm_nlp_phy_mod(pa,1,0xd9b2,15,0, 0x280e);
+  nlm_nlp_phy_mod(pa,1,0xd9b3,15,0, 0x300e);
+  nlm_nlp_phy_mod(pa,1,0xd9b4,15,0, 0x63ae);
+  nlm_nlp_phy_mod(pa,1,0xd9b5,15,0, 0x6f72);
+  nlm_nlp_phy_mod(pa,1,0xd9b6,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd9b7,15,0, 0x628f);
+  nlm_nlp_phy_mod(pa,1,0xd9b8,15,0, 0x2844);
+  nlm_nlp_phy_mod(pa,1,0xd9b9,15,0, 0x3c04);
+  nlm_nlp_phy_mod(pa,1,0xd9ba,15,0, 0x64de);
+  nlm_nlp_phy_mod(pa,1,0xd9bb,15,0, 0x2d62);
+  nlm_nlp_phy_mod(pa,1,0xd9bc,15,0, 0x3022);
+  nlm_nlp_phy_mod(pa,1,0xd9bd,15,0, 0x1e52);
+  nlm_nlp_phy_mod(pa,1,0xd9be,15,0, 0x20c4);
+  nlm_nlp_phy_mod(pa,1,0xd9bf,15,0, 0x3c24);
+  nlm_nlp_phy_mod(pa,1,0xd9c0,15,0, 0x64de);
+  nlm_nlp_phy_mod(pa,1,0xd9c1,15,0, 0x2ff9);
+  nlm_nlp_phy_mod(pa,1,0xd9c2,15,0, 0x3fd9);
+  nlm_nlp_phy_mod(pa,1,0xd9c3,15,0, 0x89e9);
+  nlm_nlp_phy_mod(pa,1,0xd9c4,15,0, 0x69c4);
+  nlm_nlp_phy_mod(pa,1,0xd9c5,15,0, 0x26c4);
+  nlm_nlp_phy_mod(pa,1,0xd9c6,15,0, 0x3c04);
+  nlm_nlp_phy_mod(pa,1,0xd9c7,15,0, 0x64de);
+  nlm_nlp_phy_mod(pa,1,0xd9c8,15,0, 0x2ff9);
+  nlm_nlp_phy_mod(pa,1,0xd9c9,15,0, 0x3fa9);
+  nlm_nlp_phy_mod(pa,1,0xd9ca,15,0, 0x89e9);
+  nlm_nlp_phy_mod(pa,1,0xd9cb,15,0, 0x69c4);
+  nlm_nlp_phy_mod(pa,1,0xd9cc,15,0, 0x2894);
+  nlm_nlp_phy_mod(pa,1,0xd9cd,15,0, 0x3c04);
+  nlm_nlp_phy_mod(pa,1,0xd9ce,15,0, 0x64de);
+  nlm_nlp_phy_mod(pa,1,0xd9cf,15,0, 0x2f79);
+  nlm_nlp_phy_mod(pa,1,0xd9d0,15,0, 0x3ff9);
+  nlm_nlp_phy_mod(pa,1,0xd9d1,15,0, 0x89e9);
+  nlm_nlp_phy_mod(pa,1,0xd9d2,15,0, 0x69c4);
+  nlm_nlp_phy_mod(pa,1,0xd9d3,15,0, 0x2eb2);
+  nlm_nlp_phy_mod(pa,1,0xd9d4,15,0, 0x3022);
+  nlm_nlp_phy_mod(pa,1,0xd9d5,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd9d6,15,0, 0x2894);
+  nlm_nlp_phy_mod(pa,1,0xd9d7,15,0, 0x3c04);
+  nlm_nlp_phy_mod(pa,1,0xd9d8,15,0, 0x64de);
+  nlm_nlp_phy_mod(pa,1,0xd9d9,15,0, 0x2089);
+  nlm_nlp_phy_mod(pa,1,0xd9da,15,0, 0x3009);
+  nlm_nlp_phy_mod(pa,1,0xd9db,15,0, 0x99e9);
+  nlm_nlp_phy_mod(pa,1,0xd9dc,15,0, 0x69c4);
+  nlm_nlp_phy_mod(pa,1,0xd9dd,15,0, 0x26c4);
+  nlm_nlp_phy_mod(pa,1,0xd9de,15,0, 0x3c04);
+  nlm_nlp_phy_mod(pa,1,0xd9df,15,0, 0x64de);
+  nlm_nlp_phy_mod(pa,1,0xd9e0,15,0, 0x2009);
+  nlm_nlp_phy_mod(pa,1,0xd9e1,15,0, 0x3059);
+  nlm_nlp_phy_mod(pa,1,0xd9e2,15,0, 0x99e9);
+  nlm_nlp_phy_mod(pa,1,0xd9e3,15,0, 0x69c4);
+  nlm_nlp_phy_mod(pa,1,0xd9e4,15,0, 0x20c4);
+  nlm_nlp_phy_mod(pa,1,0xd9e5,15,0, 0x3c24);
+  nlm_nlp_phy_mod(pa,1,0xd9e6,15,0, 0x64de);
+  nlm_nlp_phy_mod(pa,1,0xd9e7,15,0, 0x2009);
+  nlm_nlp_phy_mod(pa,1,0xd9e8,15,0, 0x3029);
+  nlm_nlp_phy_mod(pa,1,0xd9e9,15,0, 0x99e9);
+  nlm_nlp_phy_mod(pa,1,0xd9ea,15,0, 0x69c4);
+  nlm_nlp_phy_mod(pa,1,0xd9eb,15,0, 0x6f72);
+  nlm_nlp_phy_mod(pa,1,0xd9ec,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd9ed,15,0, 0x64d6);
+  nlm_nlp_phy_mod(pa,1,0xd9ee,15,0, 0x21f7);
+  nlm_nlp_phy_mod(pa,1,0xd9ef,15,0, 0x3fc7);
+  nlm_nlp_phy_mod(pa,1,0xd9f0,15,0, 0x8676);
+  nlm_nlp_phy_mod(pa,1,0xd9f1,15,0, 0xb505);
+  nlm_nlp_phy_mod(pa,1,0xd9f2,15,0, 0x9566);
+  nlm_nlp_phy_mod(pa,1,0xd9f3,15,0, 0x66c4);
+  nlm_nlp_phy_mod(pa,1,0xd9f4,15,0, 0xb545);
+  nlm_nlp_phy_mod(pa,1,0xd9f5,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xd9f6,15,0, 0x628f);
+  nlm_nlp_phy_mod(pa,1,0xd9f7,15,0, 0x6138);
+  nlm_nlp_phy_mod(pa,1,0xd9f8,15,0, 0x5883);
+  nlm_nlp_phy_mod(pa,1,0xd9f9,15,0, 0x2062);
+  nlm_nlp_phy_mod(pa,1,0xd9fa,15,0, 0x3032);
+  nlm_nlp_phy_mod(pa,1,0xd9fb,15,0, 0x1302);
+  nlm_nlp_phy_mod(pa,1,0xd9fc,15,0, 0x2ff7);
+  nlm_nlp_phy_mod(pa,1,0xd9fd,15,0, 0x3007);
+  nlm_nlp_phy_mod(pa,1,0xd9fe,15,0, 0x8786);
+  nlm_nlp_phy_mod(pa,1,0xd9ff,15,0, 0xb887);
+  nlm_nlp_phy_mod(pa,1,0xda00,15,0, 0x8785);
+  nlm_nlp_phy_mod(pa,1,0xda01,15,0, 0xb8c5);
+  nlm_nlp_phy_mod(pa,1,0xda02,15,0, 0x5e63);
+  nlm_nlp_phy_mod(pa,1,0xda03,15,0, 0x2f72);
+  nlm_nlp_phy_mod(pa,1,0xda04,15,0, 0x3022);
+  nlm_nlp_phy_mod(pa,1,0xda05,15,0, 0x13c2);
+  nlm_nlp_phy_mod(pa,1,0xda06,15,0, 0x6f72);
+  nlm_nlp_phy_mod(pa,1,0xda07,15,0, 0x1002);
+  nlm_nlp_phy_mod(pa,1,0xda08,15,0, 0xc82);
+  nlm_nlp_phy_mod(pa,1,0xda09,15,0, 0xd87);
+  nlm_nlp_phy_mod(pa,1,0xda0a,15,0, 0xe8d);
+  nlm_nlp_phy_mod(pa,1,0xda0b,15,0, 0x1092);
+  nlm_nlp_phy_mod(pa,1,0xda0c,15,0, 0x1198);
+  nlm_nlp_phy_mod(pa,1,0xda0d,15,0, 0x129d);
+  nlm_nlp_phy_mod(pa,1,0xda0e,15,0, 0x14a3);
+  nlm_nlp_phy_mod(pa,1,0xda0f,15,0, 0x16a8);
+  nlm_nlp_phy_mod(pa,1,0xda10,15,0, 0x17ae);
+  nlm_nlp_phy_mod(pa,1,0xda11,15,0, 0x18b4);
+  nlm_nlp_phy_mod(pa,1,0xda12,15,0, 0x0);
+  nlm_nlp_phy_mod(pa,1,0xda13,15,0, 0x0);
+
+// done with uC binary
+// cmdUC verifying binary...
+  nlm_nlp_phy_mod(pa,1,0xd080,15,0, 0x100);
+  nlm_nlp_phy_mod(pa,1,0xd092,15,0, 0x0);
+  nlm_udelay(400000);  // wait for uC to settle offset calibration
+
+#if 0 // Sequence from SDK
+  nlm_nlp_phy_mod(pa,1,0xc088,3,0  , 0x0);
+  nlm_nlp_phy_mod(pa,1,0xc012,3,0  , 0x0);
+  nlm_nlp_phy_mod(pa,1,0xc012,7,4  , 0x0);
+  nlm_nlp_phy_mod(pa,1,0xc017,13,13  , 0x0);
+  nlm_nlp_phy_mod(pa,1,0xcd40,3,0  , 0x1);
+  nlm_nlp_phy_mod(pa,1,0xc0f0,15,0  , 0x0102);
+  nlm_nlp_phy_mod(pa,1,0xc0f1,15,0  , 0x0056);
+  nlm_nlp_phy_mod(pa,1,0xc20d,1,1  , 0x1);
+  nlm_udelay(200000);  // sleep 200ms
+
+#else // Sequence from Support
+  nlm_nlp_phy_mod(pa,1,0xcc08,5,0  , 0x6); 	//  lsatxfi_o2e_rxrxfdfetap1
+  nlm_nlp_phy_mod(pa,1,0xcc08,11,6 , 0x23); 	//  lsatxfi_o2e_rxrxfdfetap2
+  nlm_nlp_phy_mod(pa,1,0xcc09,5,0  , 0x28); 	//  lsatxfi_o2e_rxrxfdfetap3
+  nlm_nlp_phy_mod(pa,1,0xcc09,11,6 , 0x2d); 	//  lsatxfi_o2e_rxrxfdfetap4
+  nlm_nlp_phy_mod(pa,1,0xcc0e,0,0, 0x1); 	//  lsatxfi_o2e_rxrxfdfetapstrobe
+  nlm_nlp_phy_mod(pa,1,0xcc0e,0,0, 0x0); 	//  lsatxfi_o2e_rxrxfdfetapstrobe
+// end of s_eepromLoad
+
+// PART 3, speed mode --------------------------------
+
+// Evaluating, 'xaui_init '
+  nlm_nlp_phy_mod(pa,1,0xc2e1,3,0, 0xf);   //  mci_lpbk_glue
+  nlm_nlp_phy_mod(pa,1,0xc088,3,0, 0x0);   //  espeed_mode
+  nlm_nlp_phy_mod(pa,1,0xc012,3,0, 0x0);   //  cfg_pwrdnxr
+  nlm_nlp_phy_mod(pa,1,0xc012,7,4, 0x0);   //  cfg_pwrdnxt
+  nlm_nlp_phy_mod(pa,1,0xc0f0,15,0, 0x010a);//  revision
+  nlm_nlp_phy_mod(pa,1,0xc0f1,15,0, 0x0056);//  clk mode
+  nlm_nlp_phy_mod(pa,1,0xc20d,1,1, 0x1);   //  rConStart
+  nlm_udelay(200000);  // sleep 200ms
+#endif
+
+  // Add setting the GPIO config for our LEDs
+
+  // GPIO port2 gpioobcfg
+  nlm_nlp_phy_mod(pa,1,0xc112,15,0, 0x33ff);
+
+  // GPIO port2 gpioobcfg
+  nlm_nlp_phy_mod(pa,1,0xc113,15,0, 0xb3ff);
+
+  // GPIO Ctrl port2 and port3 to probe mode
+  //nlm_nlp_phy_mod(pa,1,0xc108,15,0, 0x8800);
+  // GPIO Ctrl port2 and port3 to traffic indication mode
+  nlm_nlp_phy_mod(pa,1,0xc108,15,0, 0xdd00);
+}
diff --git a/arch/mips/include/asm/netlogic/hal/nlm_eeprom.h b/arch/mips/include/asm/netlogic/hal/nlm_eeprom.h
index 8460e45..33f9ed6 100644
--- a/arch/mips/include/asm/netlogic/hal/nlm_eeprom.h
+++ b/arch/mips/include/asm/netlogic/hal/nlm_eeprom.h
@@ -41,4 +41,5 @@ struct eeprom_data{
 extern int  eeprom_get_mac_addr(struct eeprom_data *nlm_eeprom, unsigned char *mac, int interface);
 extern int  eeprom_set_mac_addr(struct eeprom_data *nlm_eeprom, unsigned char *mac, int interface);
 extern int  eeprom_get_magic_bytes(struct eeprom_data *nlm_eeprom, unsigned char *mac, int interface);
+extern int  eeprom_dump(struct eeprom_data *nlm_eeprom, unsigned char *mac, int offset, int len);
 #endif
diff --git a/arch/mips/include/asm/netlogic/hal/nlm_evp_cpld.h b/arch/mips/include/asm/netlogic/hal/nlm_evp_cpld.h
index 454bcee..bde6440 100644
--- a/arch/mips/include/asm/netlogic/hal/nlm_evp_cpld.h
+++ b/arch/mips/include/asm/netlogic/hal/nlm_evp_cpld.h
@@ -29,6 +29,7 @@ typedef struct {
 #define SIZE_1MB        (0x100000)
 
 #define DC_ILK          0
+#define DC_HIGIG        0
 #define DC_SGMII        1
 #define DC_XAUI         2
 #define DC_NOT_PRSNT    3
diff --git a/arch/mips/include/asm/netlogic/hal/nlm_hal.h b/arch/mips/include/asm/netlogic/hal/nlm_hal.h
index 7ce3b6b..fa18e55 100644
--- a/arch/mips/include/asm/netlogic/hal/nlm_hal.h
+++ b/arch/mips/include/asm/netlogic/hal/nlm_hal.h
@@ -1,27 +1,32 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
 
 #ifndef _NLM_HAL_H_
 #define _NLM_HAL_H_
@@ -31,15 +36,17 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include "nlm_nae.h"
 #ifndef __ASSEMBLY__
 
+#include "nlm_hal_sys.h"
+
 struct nlm_netl_proc_info{
 	unsigned int proc_id;
-	unsigned int chipid;/*example: 832, 316 etc*/
-	int revision;
+	unsigned int chipid;		//example: 832, 316 etc
+	unsigned int revision;
 	char cpu_info_str[32];
 };
 
 /**
-* @brief Used by function ::get_phy_info and various internal PHY manufacturer-specific functions. 
+* @brief Used by function ::get_phy_info and various internal PHY manufacturer-specific functions.
 * @ingroup hal
 */
 struct nlm_hal_ext_phy{
@@ -53,20 +60,7 @@ struct nlm_hal_ext_phy{
         void (*ext_phy_init)(struct nlm_hal_ext_phy* ext_phy, int node);
         //(void) (*dump_regs)(void);
 };
-
 extern void nlm_hal_init(void);
-extern int is_nlm_xlpxxx(void);
-extern int is_nlm_xlp8xx(void);
-extern int is_nlm_xlp8xx_b0(void);
-extern int is_nlm_xlp8xx_b1(void);
-extern int is_nlm_xlp8xx_bx(void);
-extern int is_nlm_xlp3xx(void);
-extern int is_nlm_xlp316(void);
-extern int is_nlm_xlp308(void);
-extern int is_nlm_xlp304(void);
-extern int is_nlm_xlp8xx_b0(void);
-extern int is_nlm_xlp832_ax(void);
-extern int is_nlm_xlp8xx_ax(void);
 
 extern unsigned long long nlm_hal_cpu_freq(void);
 extern int naecfg_hack;
@@ -76,6 +70,7 @@ extern int nlm_hal_is_xlp_le(void);
 extern void nlm_hal_xlp_pcie_rc_init(void);
 
 extern void nlm_hal_cpld_init(int node);
+/* #define SKIP_INTERFACE_TYPE_FROMCPLD 1 */
 extern int nlm_get_interface_type(int node, int slot);
 extern int is_ilk_card_onslot(int);
 extern int is_xlp_evp1(void);
@@ -85,7 +80,7 @@ extern int nlm_xlp_cpldver(void);
 extern void sgmii_scan_phys(int node);
 
 #ifndef NLM_HAL_LINUX_KERNEL
-extern void enable_cpus(unsigned int node, unsigned long thread_bitmask, unsigned long park_func); 
+extern void enable_cpus(unsigned int node, unsigned long thread_bitmask, unsigned long park_func);
 #endif /* #ifndef NLM_HAL_LINUX_KERNEL */
 
 #ifdef NLM_HAL_XLOADER
@@ -130,7 +125,23 @@ extern uint64_t nlm_hal_get_dev_base(int node, int bus, int dev, int func);
 
 extern int nlm_hal_get_cpuinfo(struct nlm_netl_proc_info *);
 
-/* 
+extern uint32_t get_dom_owner_mask(void *fdt, int dom_id, char *module);
+
+struct nlm_sae_init_param {
+	int node;
+	int freq;
+};
+
+struct nlm_rsa_init_param {
+	int node;
+	int freq;
+};
+
+extern int nlm_hal_is_ref_clk_133MHz(void);
+#define XLP_PIT_TICK_RATE       (nlm_hal_is_ref_clk_133MHz()?  133333333 : 66666666)
+
+extern int nlm_hal_get_fdt_freq(void *fdt, int type);
+/*
 TODO :
   1. support Debug flags
   2. XLP support ?
diff --git a/arch/mips/include/asm/netlogic/hal/nlm_hal_cde.h b/arch/mips/include/asm/netlogic/hal/nlm_hal_cde.h
index f61e917..f6d23d4 100644
--- a/arch/mips/include/asm/netlogic/hal/nlm_hal_cde.h
+++ b/arch/mips/include/asm/netlogic/hal/nlm_hal_cde.h
@@ -1,27 +1,32 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
 
 #ifndef _NLM_HAL_CDE_H_
 #define _NLM_HAL_CDE_H_
@@ -37,7 +42,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 					(XLP_CDE_NODE, XLP_CDE_BUS, XLP_CDE_DEVICE, XLP_CDE_FUNC), \
 					 (reg))
 
-static __inline__ int nlm_hal_cde_make_fd_msg(uint64_t *msg0, unsigned long free_addr)
+static __inline__ int nlm_hal_cde_make_fd_msg(uint64_t *msg0, uint64_t free_addr)
 {
   int stid = XLP_STNID_CMP;
 
@@ -47,7 +52,7 @@ static __inline__ int nlm_hal_cde_make_fd_msg(uint64_t *msg0, unsigned long free
 }
 
 static __inline__ int nlm_hal_cde_make_cmp_msg(uint64_t *msg0, int readp, int op, int rtn_bkt,
-				   int length, unsigned long src_addr)
+				   int length, uint64_t src_addr)
 {
   int stid = XLP_STNID_CMP;
   
@@ -62,7 +67,7 @@ static __inline__ int nlm_hal_cde_make_cmp_msg(uint64_t *msg0, int readp, int op
 
 
 static __inline__ uint64_t nlm_hal_cde_make_data_desc(int eof, int type, int sod, int sob, int save,
-					 int restore, int eob, int length, unsigned long src_addr)
+					 int restore, int eob, int length, uint64_t src_addr)
 {
   uint64_t src_desc = 0;
   src_desc = (  ((uint64_t) eof << 63) | 
diff --git a/arch/mips/include/asm/netlogic/hal/nlm_hal_crypto.h b/arch/mips/include/asm/netlogic/hal/nlm_hal_crypto.h
index 319b4f3..2ae8717 100644
--- a/arch/mips/include/asm/netlogic/hal/nlm_hal_crypto.h
+++ b/arch/mips/include/asm/netlogic/hal/nlm_hal_crypto.h
@@ -1,27 +1,32 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
 
 #ifndef _NLM_HAL_CRYPTO_H_
 #define _NLM_HAL_CRYPTO_H_
diff --git a/arch/mips/include/asm/netlogic/hal/nlm_hal_fmn.h b/arch/mips/include/asm/netlogic/hal/nlm_hal_fmn.h
index 25d1a0b..49ecdba 100644
--- a/arch/mips/include/asm/netlogic/hal/nlm_hal_fmn.h
+++ b/arch/mips/include/asm/netlogic/hal/nlm_hal_fmn.h
@@ -1,27 +1,32 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
 
 #ifndef _NLH_FMN_H
 #define _NLH_FMN_H
@@ -42,6 +47,9 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define xlp_read_config()       _read_32bit_cp2_register(XLP_MSG_CONFIG_REG)
 #define xlp_write_config(value) _write_32bit_cp2_register(XLP_MSG_CONFIG_REG, value)
 
+#define xlp_read_msg_int()	_read_32bit_cp2_register(XLP_MSG_INT_REG)
+#define xlp_write_msg_int(value)	_write_32bit_cp2_register(XLP_MSG_INT_REG, value)
+
 #define xlp_load_rx_msg0() _read_64bit_cp2_register_sel(XLP_RX_BUF_REG, 0)
 #define xlp_load_rx_msg1() _read_64bit_cp2_register_sel(XLP_RX_BUF_REG, 1)
 #define xlp_load_rx_msg2() _read_64bit_cp2_register_sel(XLP_RX_BUF_REG, 2)
@@ -172,9 +180,6 @@ static inline unsigned long long nlh_qid_to_virt_addr(int node, int reg, int sel
 #define nlm_hal_write_outq_config(node, qid, val) \
 	nlh_write_cfg_reg64(nlh_qid_to_virt_addr(node, XLP_OUTQ_CONFIG_REG, qid), val)
 
-#define nlm_hal_read_credit(node, qid, src, dst) \
-	nlh_read_cfg_reg64(nlh_qid_to_virt_addr(node, XLP_CREDIT_CONFIG_REG, 0))
-
 /*
  *  Messaging Operations 
  */
@@ -401,6 +406,52 @@ static inline int xlp_message_send_3(uint32_t dst,
 }
 
 
+/* message send API NON blocking for double entry message*/
+/**
+* @brief xlp_message_send_4 function is a non-blocking API used to send a three entry message to a mailbox. Does not retry the send message. Performs a sync before sending.
+*
+* @param [in]  dst		:Destination Message Queue number
+* @param [in]  code		:8b SW code to send with the message
+* @param [in]  data0 		:64b data value for the first message
+* @param [in]  data1 		:64b data value for the second message
+* @param [in]  data2 		:64b data value for the third message
+* @param [in]  data3 		:64b data value for the fourth message
+*
+* @return
+*  - 0 on success, TxMsgStatus register on failure
+* 
+* @ingroup hal_fmn
+*
+*/
+static inline int xlp_message_send_4(uint32_t dst, 
+				     uint32_t  code,
+				     uint64_t data0, uint64_t data1,
+				     uint64_t data2, uint64_t data3)
+{
+  unsigned int dest = 0;
+
+
+  xlp_load_tx_msg0(data0);
+  xlp_load_tx_msg1(data1);
+  xlp_load_tx_msg2(data2);
+  xlp_load_tx_msg2(data3);
+
+  dest = ((code << 24) | (2 << 16) | dst);
+
+#ifdef MSGRING_DUMP_MESSAGES
+  nlm_hal_dbg_msg("Sending msg<%llx, %llx, %llx, %llx> to dest = %x\n", 
+	  data0, data1, data2, data3, dest);
+#endif
+	
+  if (!xlp_send(dest) ) {
+	  /* Check the status */
+	  return xlp_read_tx_status();
+  }
+
+
+  return 0;
+}
+
 /* Generic message send API NON blocking */
 /**
 * @brief xlp_message_send function is a non-blocking API for sending a one to four entry message to a mailbox.  Does not retry the send message. Performs a sync before sending.
@@ -636,6 +687,7 @@ static inline int xlp_receive(unsigned int vc)
 
 	return success;
 }
+
 //
 /**
 * @brief xlp_message_receive_1 function is used to receive a single entry message from a VC of the CPU. Size should be used to determine how other 64b messages were available with data.
@@ -678,7 +730,7 @@ static inline int xlp_message_receive_1(uint32_t vc, uint32_t *src_id,
 * @param [out]  msg1 		:64b data value for the second received message
 *
 * @return
-*  - "0" on receive success, "-1" on failure
+*  - "0" on receive success, "-1" on failure, "1" on load failure, "2" on pop failure
 * 
 * @ingroup hal_fmn
 *
@@ -697,7 +749,7 @@ static inline int xlp_message_receive_2(uint32_t vc, uint32_t *src_id,
 	*src_id = (status >> 4) & 0xfff;
 	*msg0 = xlp_load_rx_msg0();
 	*msg1 = xlp_load_rx_msg1();
-	return 0;
+	return (status & 0x3);
 }
 //
 /**
@@ -737,19 +789,46 @@ static inline int xlp_message_receive(uint32_t vc, uint32_t *src_id,
 	*msg3 = xlp_load_rx_msg3();
 	return 0;
 }
-//
-static inline int xlp_message_pop_2(uint32_t vc, uint32_t src_id,
-				    uint32_t code, 
-				    uint64_t data0, uint64_t data1)
+
+/* 
+   *
+   * This API can be used for both enabling and disabling the POP operation 
+   * in the msgconfig register.  
+   * 
+   * In vc_mask:
+   * '0' means disable  and 
+   * '1' means enable.
+   *
+   * bit0 = vc0, bit1 = vc1, bit2 = vc2, bit3 = vc3
+   *
+   */
+static inline int nlm_hal_pop_cfg_update (uint32_t vc_mask)
 {
-  return 0; // TODO: implement
+	uint32_t vc, config; 
+
+	/* mask out the other bits in vc_mask, just to be safe */
+	vc_mask &= 0x0f;
+	vc = (vc_mask << 1);
+
+	config = xlp_read_config();
+	config &= ~(0x1e);
+	config |= vc;
+	xlp_write_config(config);
+
+	return 0;
 }
 
-static inline int xlp_message_pop_1(uint32_t vc, uint32_t src_id,
-				    uint32_t code, 
-				    uint64_t data0)
+static inline int nlm_hal_pop_send (uint32_t popq)
 {
-  return 0; // TODO: implement
+	int rc = 0;
+
+	if (!xlp_send(popq) )
+	{
+		/* Check the status */
+		rc = xlp_read_tx_status();
+	}
+
+	return rc;
 }
 
 //
@@ -784,6 +863,7 @@ static inline int xlp_message_send_block(unsigned int size, unsigned int code,
 #endif				/* __ASSEMBLY__ */
 
 /* Returns the TxStatus reg, if unsuccessful, 0 if success */
+extern uint32_t nlm_hal_send_msg4(uint32_t dst, uint32_t code, uint64_t data0, uint64_t data1, uint64_t data2, uint64_t data3);
 extern uint32_t nlm_hal_send_msg3(uint32_t dst, uint32_t code, uint64_t data0, uint64_t data1, uint64_t data2);
 extern uint32_t nlm_hal_send_msg2(uint32_t dst, uint32_t code, uint64_t data0, uint64_t data1);
 extern uint32_t nlm_hal_send_msg1(uint32_t dst, uint32_t code, uint64_t data0);
@@ -791,10 +871,6 @@ extern uint32_t nlm_hal_send_msg1(uint32_t dst, uint32_t code, uint64_t data0);
 extern uint32_t nlm_hal_recv_msg2(uint32_t dst, uint32_t *src, uint32_t *size, uint32_t *code, uint64_t *data0, uint64_t *data1);
 extern uint32_t nlm_hal_recv_msg1(uint32_t dst, uint32_t *src, uint32_t *size, uint32_t *code, uint64_t *data0);
 
-extern uint32_t nlm_hal_pop_msg2(uint32_t dst, uint32_t src, uint32_t code, uint64_t data0, uint64_t data1);
-extern uint32_t nlm_hal_pop_msg1(uint32_t dst, uint32_t src, uint32_t code, uint64_t data0);
-
-
 static __inline__ int fmn_level_int_type(uint64_t outq_config)
 {
 	return xlp_get_field_dw(outq_config, 54, 2);
@@ -805,6 +881,7 @@ static __inline__ int fmn_level_int_val(uint64_t outq_config)
 	return xlp_get_field_dw(outq_config, 56, 3);
 }
 
+extern int get_dom_fmn_node_ownership(void *fdt, int dom_id);
 extern void nlm_hal_fmn_init(void *fdt);
 extern void nlm_hal_set_fmn_interrupt(int irq);
 
diff --git a/arch/mips/include/asm/netlogic/hal/nlm_hal_kbp.h b/arch/mips/include/asm/netlogic/hal/nlm_hal_kbp.h
new file mode 100644
index 0000000..f6ba4fb
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/hal/nlm_hal_kbp.h
@@ -0,0 +1,1033 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+
+#ifndef _NLM_HAL_KBP_H_
+#define _NLM_HAL_KBP_H_
+#include "nlm_hal_nae.h"
+#include "nlm_hal_xlp_dev.h"
+
+#define KBP_CTL                   0x40
+#define KBP_INT                   0x41
+#define KBP_ERR_CNT               0x42
+#define LA_MEM_USAGE              0x43
+#define KBP_INT_MASK              0x44
+#define KBP_REQ_ID                0x45
+#define KBP_REQ_INDEX             0x46
+#define TO_LEV2_LOW               0x47
+#define TO_LEV2_HIGH              0x48
+#define TO_HDR                    0x49
+#define TO_DR0_LOW                0x4A
+#define TO_DR0_HIGH               0x4B
+#define TO_DR1_LOW                0x4C
+#define TO_DR1_HIGH               0x4D
+#define IODI_TIMEOUT              0x4E
+#define KBP_PKT_CNT_CTL           0x4F
+#define KBP_PKT_TX_CNT            0x50
+#define KBP_PKT_RX_CNT            0x51
+#define KBP_RSP_ERROR_PAR         0x52
+#define KBP_REQ_TEST_HEAD         0x53
+#define KBP_RSP_TEST_HEAD         0x54
+#define LA_INT                    0x55
+#define LA_INT_MASK               0x56
+#define LA_RX_DIAGWORD            0x57
+#define LA_RX_SYNC                0x58
+#define LA_ERROR1                 0x59
+#define LA_ERROR2                 0x5A
+#define LA_TX_ENABLE              0x5B
+#define LA_TX_EN                  0x01
+#define LA_BAD_LANE               0x5C
+#define LA_TX_STAT                0x5D
+#define LA_TX_RLIM                0x5E
+#define LA_SETUP                  0x5F
+#define LA_LEN                    0x60
+#define SER_CTL                   0x61
+#define SER_REG0                  0x62
+#define SER_REGALL                0x63
+#define IO_CONFIG_SWAP_DIS        0x64
+#define STATE_RST                 0x65
+#define PKT_ERR_LO                0x66
+#define PKT_ERR_HI                0x67
+#define RD_EX_BASE                0x68
+#define RD_EX_LIMIT               0x69
+#define TX_SERR_MSG_0             0x6A
+#define TX_SERR_MSG_1             0x6B
+#define TX_SERR_MSG_2             0x6C
+#define TX_SERR_MSG_3             0x6D
+#define TX_MERR_MSG_0             0x6E
+#define TX_MERR_MSG_1             0x6F
+#define TX_MERR_MSG_2             0x70
+#define TX_MERR_MSG_3             0x71
+#define RX_ERR_MSG_0              0x72
+#define RX_ERR_MSG_1              0x73
+#define RX_ERR_MSG_2              0x74
+#define RX_ERR_MSG_3              0x75
+#define IODI_SLAVE_RD_ERR_MSG_0   0x76
+#define IODI_SLAVE_RD_ERR_MSG_1   0x77
+#define IODI_SLAVE_RD_ERR_MSG_2   0x78
+#define IODI_SLAVE_RD_ERR_MSG_3   0x79
+#define IODI_SLAVE_RD_ERR_MSG_4   0x7A
+#define IODI_SLAVE_RD_ERR_MSG_5   0x7B
+#define IODI_SLAVE_RD_ERR_MSG_6   0x7C
+#define IODI_SLAVE_RD_ERR_MSG_7   0x7D
+
+#define XLP_PCIE_KBP_DEV   1 /* pcie device number */
+#define KBP_START_LANE     2 /* func number     */
+
+#define DEFAULT_CPLD_MEM_BAR   0x170000
+
+/*KBP PCS common config (CSM) register */
+
+#define KBP_RX_LANE_0_15_EN             0x8100
+#define KBP_RX_LANE_16_23_EN            0x8101
+#define KBP_TX_LANE_0_11_EN             0x8102
+#define KBP_CRX_LANE_0_11_EN            0x8103
+#define KBP_CTX_LANE_0_15_EN            0x8104
+#define KBP_CTX_LANE_16_23_EN           0x8105
+#define KBP_RX_FRM_LEN                  0x8106
+#define KBP_TX_FRM_LEN                  0x8107
+#define KBP_LANE_SWAP                   0x8108
+#define KBP_RX_FIFO_THRD                0x8109
+#define KBP_TX_FIFO_THRD                0x810A
+#define KBP_TX_BUR_SHORT                0x810B
+#define KBP_RX_TX_EN                    0x810C
+#define KBP_TX_SER_0_11_SQCH            0x8117
+#define KBP_CTX_SER_0_15_SQCH           0x8118
+#define KBP_CTX_SER_16_23_SQCH          0x8119
+#define KBP_RXTX_CLK_SEL                0x811A
+#define KBP_SER_SW_RST                  0x811B
+#define KBP_GL_SW_RST                   0x811C
+#define KBP_SPEED_SEL                   0x811D
+#define KBP_COM_STATUS                  0x8180
+#define KBP_GEN_STATUS0                 0x8181
+#define KBP_GEN_STATUS1                 0x8182
+#define KBP_GEN_STATUS2                 0x8183
+#define KBP_GEN_STATUS3                 0x8184
+
+#define KBP_PCS_RX_STAT                 0x8300
+#define KBP_PCS_RX_WD_ALGN_STAT         0x8301
+#define KBP_PCS_RX_WD_ERR               0x8302
+#define KBP_PCS_RX_BLK_ERR              0x8303
+#define KBP_PCS_RX_FRM_ERR              0x8304
+#define KBP_PCS_RX_DSC_SYNC_ERR         0x8305
+#define KBP_PCS_RX_DSC_SGL_ERR          0x8306
+#define KBP_PCS_RX_FIFO_ERR             0x8307
+#define KBP_PCS_RX_CRC32_ERR            0x8308
+
+#ifndef __ASSEMBLY_
+#define MDIO_STATUS_RETRIES             20000
+
+#define EXT_XG_MDIO_CTRL_RST_POS        30
+#define EXT_XG_MDIO_CTRL_SMP_POS        20
+
+#define MAKE_MDIO_CTRL(x1, x2, x3, x4, x5, x6, x7, x8, x9)     (\
+          (x1 << EXT_XG_MDIO_CTRL_OP_POS)        \
+        | (x2 << EXT_XG_MDIO_CTRL_PHYADDR_POS)   \
+        | (x3 << EXT_XG_MDIO_CTRL_DEVTYPE_POS)   \
+        | (x4 << EXT_XG_MDIO_CTRL_TA_POS)        \
+        | (x5 << EXT_XG_MDIO_CTRL_MIIM_POS)      \
+        | (x6 << EXT_XG_MDIO_CTRL_LOAD_POS)      \
+        | (x7 << EXT_XG_MDIO_CTRL_SMP_POS)       \
+        | (x8 << EXT_XG_MDIO_CTRL_XDIV_POS)      \
+        | (x9 << EXT_XG_MDIO_CTRL_RST_POS)       )
+
+enum KBP_MDIO_DEV {
+    MDIO_DEV_CSM = 1,
+    MDIO_DEV_RX_0_3 = 2,
+    MDIO_DEV_RX_4_7 = 3,
+    MDIO_DEV_RX_8_11 = 4,
+    MDIO_DEV_RX_12_15 = 5,
+    MDIO_DEV_RX_16_19 = 6,
+    MDIO_DEV_RX_20_23 = 7,
+    MDIO_DEV_CRX_0_3 = 8,
+    MDIO_DEV_CRX_4_7 = 9,
+    MDIO_DEV_CRX_8_11 = 10,
+    MDIO_DEV_TX_0_3 = 11,
+    MDIO_DEV_TX_4_7 = 12,
+    MDIO_DEV_TX_8_11 = 13,
+    MDIO_DEV_CTX_0_3 = 14,
+    MDIO_DEV_CTX_4_7 = 15,
+    MDIO_DEV_CTX_8_11 = 16,
+    MDIO_DEV_CTX_12_15 = 17,
+    MDIO_DEV_CTX_16_19 = 18,
+    MDIO_DEV_CTX_20_23 = 19,
+    MDIO_DEV_RX_BCAST = 30,
+    MDIO_DEV_TX_BCAST = 31,
+};
+
+#define XLP_NA_REG_BLOCK_SIZE       0x2000 /* 8KB */
+#define PCI_MEM_BAR_0               0x0004
+#define MAX_NUMBER_OF_SERDES_LANE   0x8
+
+/**waste cpu clock cycle to achieve delay in time
+ @param x - number of 64-bit add operation to perform
+ @return None
+ */
+__inline__ void KBP_DELAY( uint64_t x ){
+    volatile uint64_t i = 0;
+    volatile uint64_t j = 0;
+    for( i = 0; i < x ; i++ ){
+        j++;
+    } // end for
+} // end KBP_DELAY
+
+__inline__ void WAIT_MDIO_BSY_CLEAR( uint32_t node ){
+    volatile uint64_t i = 0;
+    for( i = 0; i < MDIO_STATUS_RETRIES ; i++ ){
+        if( ( nlm_hal_read_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_RD_STAT ) & EXT_XG_MDIO_STAT_MBSY ) == 0 )
+            break;
+        // end if
+    } // end for
+} // end WAIT_MDIO_BSY_CLEAR;
+
+/**read from ILA register on XLP
+ @param node - ICI node. single node system should use 0. node other than 0 is not supported yet
+ @param func - function number of register in PCIe space. usually 0x2
+ @param reg_addr - register address
+ @return 32-bit register data
+ */
+__inline__ uint32_t nlm_hal_ila_reg_read( uint32_t node, uint32_t func, uint32_t reg_addr ){
+    volatile uint64_t mmio = nlm_hal_get_dev_base( node, 0, XLP_PCIE_KBP_DEV, func );
+    return nlm_hal_read_32bit_reg( mmio, reg_addr );
+} // end nlm_hal_ila_reg_read
+
+/**write to ILA register on XLP
+ @param node - ICI node. single node system should use 0. node other than 0 is not supported yet
+ @param func - function number of register in PCIe space. usually 0x2
+ @param reg_addr - register address
+ @param reg_data - register data
+ @return None
+ */
+__inline__ void nlm_hal_ila_reg_write( uint32_t node, uint32_t func, uint32_t reg_addr, uint32_t reg_data ){
+    volatile uint64_t mmio = nlm_hal_get_dev_base( node, 0, XLP_PCIE_KBP_DEV, func );
+    nlm_hal_write_32bit_reg( mmio, reg_addr, reg_data );
+} // end nlm_hal_ila_reg_write
+
+/**read from 8-bit SerDes register for ILA
+ @param node - ICI node. single node system should use 0. node other than 0 is not supported yet
+ @param lane - SerDes lane index
+ @param reg_addr - register address
+ @return 8-bit register data
+ */
+static __inline__ uint8_t nlm_hal_ila_serdes_reg_read( uint32_t node, uint32_t lane, uint8_t reg_addr ){
+    uint32_t serdes_select = 0x1 << lane;
+    uint32_t serdes_reg_data_wr = 0x00;
+
+    serdes_reg_data_wr = ( serdes_select << 16 ) | ( (uint32_t)reg_addr << 8 ) | 0x00;
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, SER_REG0, serdes_reg_data_wr );
+    return nlm_hal_ila_reg_read( node, KBP_START_LANE, SER_REGALL );
+
+} // end nlm_hal_ila_serdes_reg_read
+
+/**write to 8-bit SerDes register for ILA
+ @param node - ICI node. single node system should use 0. node other than 0 is not supported yet
+ @param lane - SerDes lane index
+ @param reg_addr - register address
+ @param reg_data - register data
+ @return None
+ */
+static __inline__ void nlm_hal_ila_serdes_reg_write( uint32_t node, uint32_t lane, uint8_t reg_addr, uint8_t reg_data ){
+    uint32_t serdes_select = 0x1 << lane;
+    uint32_t serdes_reg_data_wr = 0x00;
+
+    serdes_reg_data_wr = ( serdes_select << 16 ) | ( (uint32_t)reg_addr << 8 ) | (uint32_t)reg_data;
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, SER_REG0, serdes_reg_data_wr );
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, SER_REGALL, serdes_reg_data_wr );
+
+} // end nlm_hal_ila_serdes_reg_write
+
+/**perform read on list of address-data pair of 8-bit SerDes registers for given number of SerDes lanes starting from lane 0 for ILA
+ @param node - ICI node. single node system should use 0. node other than 0 is not supported yet
+ @param number_of_lanes - number of lanes to write register
+ @param number_of_addr - number of register address per SerDes lane
+ @param reg_addr - array of list of register address
+ @param reg_data - array to store read data
+ @return None
+ * e.x. nlm_hal_ila_serdes_lanes_reg_read( 0, 4, 2, [0x64, 0x65], [0, 0, 0, 0, 0, 0, 0, 0] );
+ *      read SerDes register 0x64 and 0x65 for SerDes lane 0, 1, 2 and 3
+ *      reg_data = [ 0x64 data of lane 0, 0x64 data of lane 1, 0x64 data of lane 2, 0x64 data of lane 3,
+ *                   0x65 data of lane 0, 0x65 data of lane 1, 0x65 data of lane 2, 0x65 data of lane 3 ]
+ */
+static __inline__ void nlm_hal_ila_serdes_lanes_reg_read( uint32_t node, uint32_t number_of_lanes, uint32_t number_of_addr, uint8_t* reg_addr, uint8_t* reg_data ){
+    uint32_t serdes_counter = 0x00;
+    uint32_t reg_counter = 0x00;
+
+    for( reg_counter = 0x0; reg_counter < number_of_addr ; reg_counter++ ){
+        for( serdes_counter = 0; serdes_counter < number_of_lanes ; serdes_counter++ ){
+            reg_data[reg_counter * number_of_lanes + serdes_counter] = nlm_hal_ila_serdes_reg_read( node, serdes_counter, reg_addr[reg_counter] );
+        } // end for
+    } // end for
+
+} // end nlm_hal_ila_serdes_lanes_reg_read
+
+/**perform write on list of address-data pair of 8-bit SerDes registers for given number of SerDes lanes starting from lane 0 for ILA
+ @param node - ICI node. single node system should use 0. node other than 0 is not supported yet
+ @param number_of_lanes - number of lanes to write register
+ @param number_of_addr - number of register address per SerDes lane
+ @param reg_addr - array of list of register address
+ @param reg_data - array of list of register data
+ @return None
+ * e.x. nlm_hal_ila_serdes_lanes_reg_write( 0, 4, 2, [0x23,0x64], [0xBE,0xEF] )
+ *      SerDes lane 0 register 0x23 data becomes 0xBE
+ *      SerDes lane 0 register 0x64 data becomes 0xEF
+ *      SerDes lane 1 register 0x23 data becomes 0xBE
+ *      SerDes lane 1 register 0x64 data becomes 0xEF
+ *      SerDes lane 2 register 0x23 data becomes 0xBE
+ *      SerDes lane 2 register 0x64 data becomes 0xEF
+ *      SerDes lane 3 register 0x23 data becomes 0xBE
+ *      SerDes lane 3 register 0x64 data becomes 0xEF
+ */
+static __inline__ void nlm_hal_ila_serdes_lanes_reg_write( uint32_t node, uint32_t number_of_lanes, uint32_t number_of_addr, uint8_t* reg_addr, uint8_t* reg_data ){
+    uint32_t serdes_counter = 0x00;
+    uint32_t reg_counter = 0x00;
+
+    for( reg_counter = 0x0; reg_counter < number_of_addr ; reg_counter++ ){
+        for( serdes_counter = 0; serdes_counter < number_of_lanes ; serdes_counter++ ){
+            nlm_hal_ila_serdes_reg_write( node, serdes_counter, reg_addr[reg_counter], reg_data[reg_counter * number_of_lanes + serdes_counter] );
+        } // end for
+    } // end for
+
+} // end nlm_hal_ila_serdes_lanes_reg_write
+
+#ifndef CONFIG_N511
+/**read from 16-bit cpld chip-select 0x2 registers on EVP board for KBP
+ @param node - ICI node. single node system should use 0. node other than 0 is not supported yet
+ @param reg_addr - register address
+ @return 16-bit register data
+ */
+uint16_t nlm_hal_kbp_cpld_reg_read( uint32_t node, uint16_t addr ){
+    volatile uint64_t mmio = nlm_hal_get_dev_base( node, 0, XLP_PCIE_SPI_NOR_FLASH_DEV, XLP_PCIE_SPI_NOR );
+    volatile uint64_t cpld_base = nlm_hal_read_32bit_reg( mmio, 0x42 );
+    volatile uint16_t data = 0;
+
+    if( cpld_base != DEFAULT_CPLD_MEM_BAR )
+        nlm_hal_write_32bit_reg( mmio, 0x42, DEFAULT_CPLD_MEM_BAR );
+    // end if
+
+    data = nlm_hal_read_16bit_reg( ( cpld_base << 8 ), ( addr >> 1 ) );
+
+    // NetOS and HELinux needs byte swap
+#if defined(NLM_HAL_NETOS) | defined(NLM_HAL_LINUX_USER)
+    data = ( data << 8 ) | ( data >> 8 );
+#endif
+
+    return data;
+
+} // end nlm_hal_kbp_cpld_reg_read
+
+/**write to 16-bit cpld chip-select 0x2 registers on EVP board for KBP
+ @param node - ICI node. single node system should use 0. node other than 0 is not supported yet
+ @param reg_addr - register address
+ @param data - register data
+ @return None
+ */
+void nlm_hal_kbp_cpld_reg_write( uint32_t node, uint16_t addr, uint16_t data ){
+    volatile uint64_t mmio = nlm_hal_get_dev_base( node, 0, XLP_PCIE_SPI_NOR_FLASH_DEV, XLP_PCIE_SPI_NOR );
+    volatile uint64_t cpld_base = nlm_hal_read_32bit_reg( mmio, 0x42 );
+
+    if( cpld_base != DEFAULT_CPLD_MEM_BAR )
+        nlm_hal_write_32bit_reg( mmio, 0x42, DEFAULT_CPLD_MEM_BAR );
+    // end if
+
+    // NetOS and HELinux needs byte swap
+#if defined(NLM_HAL_NETOS) | defined(NLM_HAL_LINUX_USER)
+    data = ( data << 8 ) | ( data >> 8 );
+#endif
+
+    nlm_hal_write_16bit_reg( ( cpld_base << 8 ), ( addr >> 1 ), data );
+} // end nlm_hal_kbp_cpld_reg_write
+
+/**reset KBP MDIO interface
+ @param node - ICI node. single node system should use 0. node other than 0 is not supported yet
+ @return None
+ */
+static __inline__ void nlm_hal_kbp_mdio_reset( uint32_t node ){
+    uint32_t reg_data;
+
+    reg_data = nlm_hal_read_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL ); /*0x25*/
+    reg_data = 0x04000000;
+    nlm_hal_write_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL, reg_data );
+    reg_data = nlm_hal_read_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL );
+
+} // end nlm_hal_kbp_mdio_reset
+
+/**read from KBP MDIO register
+ @param node - ICI node. single node system should use 0. node other than 0 is not supported yet
+ @param regaddr - register address
+ @param dev_id - MDIO device id
+ @return register data
+ */
+static __inline__ uint32_t nlm_hal_kbp_mdio_read( uint32_t node, uint32_t regaddr, uint32_t dev_id ){
+
+    uint32_t data = 0;
+    volatile uint32_t status;
+
+    nlm_hal_write_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL_DATA, regaddr );
+
+    data = MAKE_MDIO_CTRL(0, 0x08, dev_id, 2, 5, 0, 0, 0x7F, 0);
+
+    nlm_hal_write_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL, data );
+
+    WAIT_MDIO_BSY_CLEAR( node );
+
+    data = MAKE_MDIO_CTRL(0, 0x08, dev_id, 2, 5, 1, 0, 0x7F, 0);
+
+    nlm_hal_write_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL, data );
+
+    WAIT_MDIO_BSY_CLEAR( node );
+
+    /* now the address has been written in indirectly*/
+    /* Now get the load bit to be 0 ( bit 19) */
+    data = MAKE_MDIO_CTRL(0, 0x08, dev_id, 2, 5, 0, 0, 0x7F, 0);
+
+    nlm_hal_write_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL, data );
+
+    WAIT_MDIO_BSY_CLEAR( node );
+
+    data = MAKE_MDIO_CTRL(3, 0x08, dev_id, 2, 5, 0, 0, 0x7F, 0);
+
+    nlm_hal_write_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL, data );
+
+    WAIT_MDIO_BSY_CLEAR( node );
+
+    data = MAKE_MDIO_CTRL(3, 0x08, dev_id, 2, 5, 1, 0, 0x7F, 0);
+
+    nlm_hal_write_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL, data );
+
+    WAIT_MDIO_BSY_CLEAR( node );
+
+    /* get the load bit to be 0 ( bit 19) */
+    data = MAKE_MDIO_CTRL(0, 0x08, dev_id, 2, 5, 1, 0, 0x7F, 0);
+
+    nlm_hal_write_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL, data );
+
+    WAIT_MDIO_BSY_CLEAR( node );
+
+    data = MAKE_MDIO_CTRL(0, 0x08, dev_id, 2, 5, 0, 0, 0x7F, 0);
+
+    nlm_hal_write_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL, data );
+
+    WAIT_MDIO_BSY_CLEAR( node );
+
+    status = nlm_hal_read_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_RD_STAT ); /* 0x27*/
+    return ( status & 0xFFFF );
+} // end nlm_hal_kbp_mdio_read
+
+/**write to KBP MDIO register
+ @param node - ICI node. single node system should use 0. node other than 0 is not supported yet
+ @param regaddr - register address
+ @param indirect_data - register data
+ @param dev_id - MDIO device id
+ @return None
+ */
+static __inline__ void nlm_hal_kbp_mdio_write( uint32_t node, uint32_t regaddr, uint32_t indirect_data, uint32_t dev_id ){
+    uint32_t data = 0;
+
+    nlm_hal_write_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL_DATA, regaddr );
+    /*0x26*/
+
+    data = MAKE_MDIO_CTRL(0, 0x08, dev_id, 2, 5, 0, 0, 0x7F, 0);
+
+    nlm_hal_write_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL, data );
+    /*0x25*/
+
+    WAIT_MDIO_BSY_CLEAR( node );
+
+    data = MAKE_MDIO_CTRL(0, 0x08, dev_id, 2, 5, 1, 0, 0x7F, 0);
+
+    nlm_hal_write_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL, data );
+
+    WAIT_MDIO_BSY_CLEAR( node );
+
+    /* now the address has been written in indirectly */
+    /* next write in the data , but before that get the load bit to be 0 ( bit 19)*/
+    data = MAKE_MDIO_CTRL(0, 0x08, dev_id, 2, 5, 0, 0, 0x7F, 0);
+    nlm_hal_write_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL, data );
+
+    WAIT_MDIO_BSY_CLEAR( node );
+
+    nlm_hal_write_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL_DATA, indirect_data );
+
+    /* for write bits[3:2] is 01 */
+    data = MAKE_MDIO_CTRL(1, 0x08, dev_id, 2, 5, 0, 0, 0x7F, 0);
+
+    nlm_hal_write_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL, data );
+
+    WAIT_MDIO_BSY_CLEAR( node );
+
+    data = MAKE_MDIO_CTRL(1, 0x08, dev_id, 2, 5, 1, 0, 0x7F, 0);
+
+    nlm_hal_write_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL, data );
+
+    WAIT_MDIO_BSY_CLEAR( node );
+
+    /* next write in the data , but before that get the load bit to be 0 ( bit 19) */
+    data = MAKE_MDIO_CTRL(0, 0x08, dev_id, 2, 5, 0, 0, 0x7F, 0);
+
+    nlm_hal_write_mac_reg( node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_CTRL, data );
+
+    WAIT_MDIO_BSY_CLEAR( node );
+
+} // end nlm_hal_kbp_mdio_write
+
+#else
+#define RST_CTL_0       0x8
+
+#define MI_BSL          0x1d
+#define MI_CSR          0x20
+#define MI_MCTL         0x21
+#define MI_AD0          0x22
+#define MI_AD1          0x23
+#define MI_DEVREG_AD    0x24
+#define MI_PRTPHY_AD    0x25
+
+static void n511_cpld_wr(int offset, char data)
+{
+  volatile static char *n511_cpld_base;
+  n511_cpld_base = (char *)0xffffffffb7000000ULL;
+  n511_cpld_base[offset] = data;
+}
+
+static char n511_cpld_rd(int offset)
+{
+  volatile static char *n511_cpld_base;
+  n511_cpld_base = (char *)0xffffffffb7000000ULL;
+  return n511_cpld_base[offset];
+}
+
+// N511 CPLD MDIO operations
+// #define MI_BSL          0x1d
+//      7       6       5       4       3       2       1       0
+//      res     res     res     res     Sel3    Sel2    Sel1    Sel0
+// Select Map
+//  000 = NL11000
+//  001 = NLP1042 XPHY 0 / 1
+//  010 = NLP1042 XPHY 2 / 3
+//  011 = Mgmt Phy0
+//  100 = Mgmt Phy1
+//  101-111 Reserved
+inline void n511_cpld_mdio_bus_sel(char bus)
+{
+  n511_cpld_wr(MI_BSL, bus);
+}
+
+// #define MI_MCTL         0x21
+//      7       6       5       4       3       2       1       0
+//      C22     res     Clk1    Clk0    obe     mdc     mdio_0  mdio_1
+// Clk Map
+//  00 = Manual (bit bang)
+//  01 = 50 Mhz / 32
+//  10 = 50 Mhz / 16
+//  11 = 50 Mhz / 8
+inline void n511_cpld_mdio_set_clk(char clock)
+{
+  n511_cpld_wr(MI_MCTL, (clock<<4));
+}
+
+
+static __inline__ void mdio_reset(void)
+{
+  return;
+}
+
+// #define MI_AD0          0x22
+// #define MI_AD1          0x23
+// #define MI_DEVREG_AD    0x24
+// #define MI_PRTPHY_AD    0x25
+static __inline__ void mdio_write(int regidx, int val, int devaddr)
+{
+  int i;
+  uint8_t clock = 2;
+  char bus = 0;
+  char phyaddr = 1;
+
+  n511_cpld_mdio_set_clk(clock);
+  n511_cpld_mdio_bus_sel(bus);
+
+  // Address Cycle
+  n511_cpld_wr(MI_AD1, (uint8_t)(regidx>>8));
+  n511_cpld_wr(MI_AD0, (uint8_t)(regidx & 0xff));
+  n511_cpld_wr(MI_DEVREG_AD, devaddr);
+  n511_cpld_wr(MI_PRTPHY_AD, phyaddr);
+  // 00 Mgmt Interface Address
+  // Write start bit only
+  n511_cpld_wr(MI_CSR, 1);
+  // Wait for start bit to auto-clear
+  i = 0;
+  while (n511_cpld_rd(MI_CSR) & 0x1) {
+    nlm_udelay(100);
+    if (i++ > 10000) {
+      printf("N511 CPLD MDIO timeout on Address cycle\n");
+      return;
+    }
+  }
+
+  // Data Cycle
+  // Write data regs
+  n511_cpld_wr(MI_AD1, (uint8_t)(val>>8));
+  n511_cpld_wr(MI_AD0, (uint8_t)(val & 0xff));
+
+  // 01 Mgmt Interface Write
+  // Write op 1 and start bit
+  n511_cpld_wr(MI_CSR, (1 << 4) | 0x1);
+  // Wait for start bit to auto-clear
+  i = 0;
+  while (n511_cpld_rd(MI_CSR) & 0x1) {
+    nlm_udelay(100);
+    if (i++ > 10000) {
+      printf("N511 CPLD MDIO timeout on Write cycle\n");
+      return;
+    }
+  }
+  return;
+}
+
+static __inline__ int mdio_read(int regidx, int devaddr)
+{
+  int i;
+  uint8_t clock = 2;
+  uint16_t rdval;
+  char bus = 0;
+  char phyaddr = 1;
+
+  n511_cpld_mdio_set_clk(clock);
+  n511_cpld_mdio_bus_sel(bus);
+
+  // Address Cycle
+  n511_cpld_wr(MI_AD1, (uint8_t)(regidx>>8));
+  n511_cpld_wr(MI_AD0, (uint8_t)(regidx & 0xff));
+  n511_cpld_wr(MI_DEVREG_AD, devaddr);
+  n511_cpld_wr(MI_PRTPHY_AD, phyaddr);
+  // 00 Mgmt Interface Address
+  // Write start bit only
+  n511_cpld_wr(MI_CSR, 1);
+  // Wait for start bit to auto-clear
+  i = 0;
+  while (n511_cpld_rd(MI_CSR) & 0x1) {
+    nlm_udelay(100);
+    if (i++ > 10000) {
+      printf("N511 CPLD MDIO timeout on Address cycle\n");
+      return 0xffff;
+    }
+  }
+
+  // Data Cycle
+  // 11 Mgmt Interface Read
+  // Write op 3 and start bit
+  n511_cpld_wr(MI_CSR, (3 << 4) | 0x1);
+  // Wait for start bit to auto-clear
+  i = 0;
+  while (n511_cpld_rd(MI_CSR) & 0x1) {
+    nlm_udelay(100);
+    if (i++ > 10000) {
+      printf("N511 CPLD MDIO timeout on Read cycle\n");
+      return 0xffff;
+    }
+  }
+  rdval = (n511_cpld_rd(MI_AD1) << 8) | (n511_cpld_rd(MI_AD0));
+  return rdval;
+}
+#endif
+/**perform KBP System-ON Reset Sequence
+ @param node - ICI node. single node system should use 0. node other than 0 is not supported yet
+ @param number_of_lane - number of SerDes lane to use
+ @param serdes_speed_in_gbps - SerDes lane speed
+ @param tx_metaframe_length - tx meta frame
+ @param rx_metaframe_length - rx meta frame
+ @return None
+ * meta frame is for synchronization
+ */
+static __inline__ void nlm_hal_kbp_system_on_reset( uint32_t node, uint32_t number_of_lane, uint32_t serdes_speed_in_gbps, uint16_t tx_metaframe_length, uint16_t rx_metaframe_length ){
+    volatile uint16_t cpld_data = 0;
+
+    nlm_print( "Perform KBP System-ON Reset Sequence...\n" );
+#ifdef CONFIG_N511
+    uint8_t t8;
+
+    nlm_print( "N511 CPLD reading RST_CTL_0\n");
+    t8 = n511_cpld_rd(RST_CTL_0);
+    nlm_print( "N511 CPLD read RST_CTL_0 0x%x\n", t8);
+    t8 |= 0x08;
+    n511_cpld_wr(RST_CTL_0, t8);
+
+    KBP_DELAY(50000);
+
+    t8 &= ~0x08;
+    n511_cpld_wr(RST_CTL_0, t8);
+
+    KBP_DELAY(50000);
+
+    nlm_print( "N511 CPLD KBP Reset complete\n" );
+#else // CONFIG_N511
+    /* 1. Ensure SRST_L & CRST_L are de-asserted (held high) before assert (pull low) SRST_L & CRST_L */
+    cpld_data = nlm_hal_kbp_cpld_reg_read( node, 0x02 );
+    // de-assert SRST and CRST
+    cpld_data |= 0x0104;
+    nlm_hal_kbp_cpld_reg_write( node, 0x02, cpld_data );
+    // wait for a while
+    KBP_DELAY( 50000 );
+
+    cpld_data = nlm_hal_kbp_cpld_reg_read( node, 0x02 );
+    // assert low SRST and CRST
+    cpld_data &= 0xFEFB;
+    nlm_hal_kbp_cpld_reg_write( node, 0x02, cpld_data );
+
+    /* 2. Wait for 3.0us and de-assert SRST_L */
+    // wait for some long time to ensure sufficient wait time even when CPU runs at 1.6 GHz
+    KBP_DELAY( 50000 );
+
+    cpld_data = nlm_hal_kbp_cpld_reg_read( node, 0x02 );
+    // de-assert SRST
+    cpld_data |= 0x0004;
+    nlm_hal_kbp_cpld_reg_write( node, 0x02, cpld_data );
+#endif
+    /* 3. If MDIO-based device configuration is required, follow the steps as outlined in Section 6.7 */
+    uint16_t reg_data = 0;
+
+    /*    Device Configuration using MDIO */
+    nlm_hal_kbp_mdio_reset( node );
+
+    /*    1. Squelch the Transmit SerDes using "TX_SerDes_11_0_squelch", "CTX_SerDes_15_0_squelch", and "CTX_SerDes_23_16_squelch" registers. See Table 18 on page 39 */
+    KBP_DELAY( 100 );
+    nlm_hal_kbp_mdio_write( node, KBP_TX_SER_0_11_SQCH, 0x0FFF, MDIO_DEV_CSM );
+
+    KBP_DELAY( 100 );
+    nlm_hal_kbp_mdio_write( node, KBP_CTX_SER_0_15_SQCH, 0xFFFF, MDIO_DEV_CSM );
+
+    KBP_DELAY( 100 );
+    nlm_hal_kbp_mdio_write( node, KBP_CTX_SER_16_23_SQCH, 0x00FF, MDIO_DEV_CSM );
+
+    /*    2. Disable RX and TX PCS using "Global RX / TX Enable" register. See Table 18 on page 39 */
+    KBP_DELAY( 100 );
+    nlm_hal_kbp_mdio_write( node, KBP_RX_TX_EN, 0x0000, MDIO_DEV_CSM );
+
+    /*    3. Reset SerDes-Initialization state machine, Core PLL and Core Logic by writing 16'h7 to "Global SW Reset" register. See Table 18 on page 39 */
+    KBP_DELAY( 100 );
+    nlm_hal_kbp_mdio_write( node, KBP_GL_SW_RST, 0x0007, MDIO_DEV_CSM );
+
+    /*    4. Configure MDIO registers */
+    KBP_DELAY( 100 );
+
+    if( serdes_speed_in_gbps == 6 ){
+        reg_data = nlm_hal_kbp_mdio_read( node, KBP_SPEED_SEL, MDIO_DEV_CSM );
+        reg_data = ( reg_data & 0xFF88 ) | 0x44;
+        nlm_hal_kbp_mdio_write( node, KBP_SPEED_SEL, reg_data, MDIO_DEV_CSM );
+    }else{
+        reg_data = nlm_hal_kbp_mdio_read( node, KBP_SPEED_SEL, MDIO_DEV_CSM );
+        reg_data = ( reg_data & 0xFF88 ) | 0x00;
+        nlm_hal_kbp_mdio_write( node, KBP_SPEED_SEL, reg_data, MDIO_DEV_CSM );
+        // workaround for NL11000 RA01 KBP running 3.125 Gbps
+        uint16_t counter = 0;
+        for( counter = 0; counter < 4 ; counter++ ){
+            nlm_hal_kbp_mdio_write( node, 0x120, 0x0043, MDIO_DEV_RX_BCAST );
+            nlm_hal_kbp_mdio_write( node, 0x130, 0x0043, MDIO_DEV_RX_BCAST );
+            nlm_hal_kbp_mdio_write( node, 0x140, 0x0043, MDIO_DEV_RX_BCAST );
+            nlm_hal_kbp_mdio_write( node, 0x150, 0x0043, MDIO_DEV_RX_BCAST );
+            nlm_hal_kbp_mdio_write( node, 0x120, 0x0041, MDIO_DEV_RX_BCAST );
+            nlm_hal_kbp_mdio_write( node, 0x130, 0x0041, MDIO_DEV_RX_BCAST );
+            nlm_hal_kbp_mdio_write( node, 0x140, 0x0041, MDIO_DEV_RX_BCAST );
+            nlm_hal_kbp_mdio_write( node, 0x150, 0x0041, MDIO_DEV_RX_BCAST );
+        } // end for
+//        // workaround for NL11000 RA12 KBP running 3.125 Gbps
+//        nlm_hal_kbp_mdio_write( node, 0x0100, 0x0100, MDIO_DEV_RX_BCAST );
+//        nlm_hal_kbp_mdio_write( node, 0x0101, 0x0100, MDIO_DEV_RX_BCAST );
+//        nlm_hal_kbp_mdio_write( node, 0x0102, 0x0100, MDIO_DEV_RX_BCAST );
+//        nlm_hal_kbp_mdio_write( node, 0x0103, 0x0100, MDIO_DEV_RX_BCAST );
+//        nlm_hal_kbp_mdio_write( node, 0x0160, 0x0080, MDIO_DEV_RX_BCAST );
+//        nlm_hal_kbp_mdio_write( node, 0x0160, 0x0000, MDIO_DEV_RX_BCAST );
+    } // end if & else
+
+    // workaround for NL11000 RA01 KBP START
+    KBP_DELAY( 100 );
+    nlm_hal_kbp_mdio_write( node, 0x0502, 0x0F68, MDIO_DEV_RX_BCAST );
+    KBP_DELAY( 100 );
+    nlm_hal_kbp_mdio_write( node, 0x0502, 0x0F68, MDIO_DEV_TX_BCAST );
+    KBP_DELAY( 100 );
+    nlm_hal_kbp_mdio_write( node, 0x8121, 0x7C53, MDIO_DEV_CSM );
+    // workaround for NL11000 RA01 KBP END
+
+    KBP_DELAY( 100 );
+    /* TX Metaframe length */
+    nlm_hal_kbp_mdio_write( node, KBP_TX_FRM_LEN, tx_metaframe_length, MDIO_DEV_CSM );
+
+    KBP_DELAY( 100 );
+    /* RX Metaframe length */
+    nlm_hal_kbp_mdio_write( node, KBP_RX_FRM_LEN, rx_metaframe_length, MDIO_DEV_CSM );
+
+    /*    5. Deassert Core PLL and Core Logic reset, and trigger the SerDes-Initialization state machine by writing 16'h0 to "Global SW Reset" register. See Table 18 on page 39 */
+    KBP_DELAY( 100 );
+    nlm_hal_kbp_mdio_write( node, KBP_GL_SW_RST, 0x0000, MDIO_DEV_CSM );
+
+    /*    6. Poll for assertion of bit[3], SerDes Reset Sequence Done, in the "General Purpose Status Register 3". See Table 19 on page 45 */nlm_print( "    Polling for SerDes Reset Sequence Done...\n" );
+    KBP_DELAY( 100 );
+    do{
+        reg_data = nlm_hal_kbp_mdio_read( node, KBP_GEN_STATUS2, MDIO_DEV_CSM );
+        reg_data = ( reg_data >> 3 ) & 0b1;
+    }while( reg_data == 0 ); // end do & while
+    nlm_print( "    SerDes Reset Sequence is Done\n" );
+
+    /*    7. Enable RX and TX PCS using Global RX/TX Enable register. See Table 18 on page 39.*/
+    if( number_of_lane <= 16 ){
+        KBP_DELAY( 100 );
+        nlm_hal_kbp_mdio_write( node, KBP_RX_LANE_0_15_EN, ( 0x1 << number_of_lane ) - 1, MDIO_DEV_CSM );
+        KBP_DELAY( 100 );
+        nlm_hal_kbp_mdio_write( node, KBP_RX_LANE_16_23_EN, 0x0000, MDIO_DEV_CSM );
+    }else if( number_of_lane > 16 && number_of_lane <= 24 ){
+        KBP_DELAY( 100 );
+        nlm_hal_kbp_mdio_write( node, KBP_RX_LANE_0_15_EN, 0xFFFF, MDIO_DEV_CSM );
+        KBP_DELAY( 100 );
+        nlm_hal_kbp_mdio_write( node, KBP_RX_LANE_16_23_EN, ( 0x1 << ( number_of_lane - 16 ) ) - 1, MDIO_DEV_CSM );
+    }else{
+        nlm_print( "    ERROR!!!!!!!!!!!!! KBP Doesn't support %u SerDes lanes for requests!!!!!!!!!!!!!\n", number_of_lane );
+    } // end if & else
+
+    KBP_DELAY( 100 );
+    if( number_of_lane <= 12 ){
+        nlm_hal_kbp_mdio_write( node, KBP_TX_LANE_0_11_EN, ( 0x1 << number_of_lane ) - 1, MDIO_DEV_CSM );
+    }else{
+        nlm_print( "    ERROR!!!!!!!!!!!!! KBP Doesn't support %u SerDes lanes for responses!!!!!!!!!!!!!\n", number_of_lane );
+    } // end if & else
+
+    KBP_DELAY( 100 );
+    nlm_hal_kbp_mdio_write( node, KBP_RX_TX_EN, 0x0003, MDIO_DEV_CSM ); /* Global Enable for Tx & Rx PCS*/
+
+    /*    8. Disable squelch for the Transmit SerDes using TX_SerDes_11_0_squelch CTX_SerDes_15_0_squelch and CTX_SerDes_23_16_squelch registers. See Table 18 on page 39.*/
+    KBP_DELAY( 100 );
+    nlm_hal_kbp_mdio_write( node, KBP_TX_SER_0_11_SQCH, 0x0FFF - ( ( 0x1 << number_of_lane ) - 1 ), MDIO_DEV_CSM );
+
+    KBP_DELAY( 100 );
+    nlm_hal_kbp_mdio_write( node, KBP_CTX_SER_0_15_SQCH, 0xFFFF, MDIO_DEV_CSM );
+
+    KBP_DELAY( 100 );
+    nlm_hal_kbp_mdio_write( node, KBP_CTX_SER_16_23_SQCH, 0x00FF, MDIO_DEV_CSM );
+
+    /*    9. Read the General Purpose Status Register 3, 0x8184 to release assertion of GIO_L that may happen due to errors on the lanes during initialization.*/
+    nlm_hal_kbp_mdio_read( node, KBP_GEN_STATUS3, MDIO_DEV_CSM );
+
+    /* 4. Wait for 2.5ms and de-assert CRST_L */
+    KBP_DELAY( 5000000 );
+
+#ifdef CONFIG_N511
+    t8 = n511_cpld_rd(RST_CTL_0);
+    t8 |= 0x04;
+    n511_cpld_wr(RST_CTL_0, t8);
+
+    KBP_DELAY(40000);
+
+    t8 &= ~0x04;
+    n511_cpld_wr(RST_CTL_0, t8);
+
+    KBP_DELAY(40000);
+#else
+    cpld_data = nlm_hal_kbp_cpld_reg_read( node, 0x02 );
+    // de-assert CRST
+    cpld_data |= 0x0104;
+    nlm_hal_kbp_cpld_reg_write( node, 0x02, cpld_data );
+#endif
+    /* 5. Interlaken Look-Aside framing and synchronization.
+     *       Idle control words will be sent on the response port with XOFF until synchronization is complete.
+     *       It is expected that only idle control words are sent on the RX port until XON is provided on the TX port.*/
+    KBP_DELAY( 5000000 );
+
+    /* 6. Assert then de-assert reset Rx satellete sticky register */
+    KBP_DELAY( 100 );
+    nlm_hal_kbp_mdio_write( node, KBP_SER_SW_RST, 0x0040, MDIO_DEV_CSM );
+
+    KBP_DELAY( 2500000 );
+
+    nlm_hal_kbp_mdio_write( node, KBP_SER_SW_RST, 0x0000, MDIO_DEV_CSM );
+
+    nlm_print( "KBP System-ON Reset Sequence is Done\n" );
+
+} // end nlm_hal_kbp_system_on_reset
+
+/**perform ILA Reset Sequence
+ @param node - ICI node. single node system should use 0. node other than 0 is not supported yet
+ @param number_of_lane - number of SerDes lane to use
+ @param serdes_speed_in_gbps - SerDes lane speed
+ @param tx_metaframe_length - tx meta frame
+ @param rx_metaframe_length - rx meta frame
+ @return None
+ * meta frame is for synchronization
+ */
+static __inline__ void nlm_hal_ila_reset( uint32_t node, uint32_t number_of_lane, uint32_t serdes_speed_in_gbps, uint16_t tx_metaframe_length, uint16_t rx_metaframe_length ){
+    uint32_t reg_data = 0;
+
+    nlm_print( "Perform ILA Reset Sequence...\n" );
+
+    if( serdes_speed_in_gbps == 6 ){
+        // do nothing
+    }else{
+        /* Configure SerDes to run at 3.125 Gbps */
+        uint8_t addr = 0x04;
+        uint8_t data[MAX_NUMBER_OF_SERDES_LANE] = { 0x0 };
+
+        memset( data, 0x30, MAX_NUMBER_OF_SERDES_LANE );
+        nlm_hal_ila_serdes_lanes_reg_write( node, number_of_lane, 1, &addr, data );
+
+        /* Writing to reg05 to change M value to 2 */
+        addr = 0x05;
+        memset( data, 0x33, MAX_NUMBER_OF_SERDES_LANE );
+        nlm_hal_ila_serdes_lanes_reg_write( node, number_of_lane, 1, &addr, data );
+    } // end if
+
+    // Assert active low PLL reset
+    reg_data = nlm_hal_ila_reg_read( node, KBP_START_LANE, KBP_CTL );
+    reg_data &= 0xFFFFF7FF;
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, KBP_CTL, reg_data );
+
+    KBP_DELAY( 1000 );
+
+    // De-assert active low PLL reset
+    reg_data = nlm_hal_ila_reg_read( node, KBP_START_LANE, KBP_CTL );
+    reg_data |= 0x00000800;
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, KBP_CTL, reg_data );
+
+    // Mask all interrupts
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, KBP_INT_MASK, 0x3FF );
+
+    // Configure number of active lanes by writing index of last active lane
+    reg_data = nlm_hal_ila_reg_read( node, KBP_START_LANE, LA_BAD_LANE );
+    reg_data &= 0xFFFFFF0F;
+    reg_data &= 0xFF0FFFFF;
+    if( number_of_lane == 2 ){
+        // TX lane
+        reg_data &= 0xFFFFFFF7;
+        reg_data |= ( 0x1 ) << 7;
+        reg_data |= ( 0x2 ) << 4;
+        reg_data |= ( 0x2 ) << 0;
+        // RX lane
+        reg_data &= 0xFFF7FFFF;
+        reg_data |= ( 0x1 ) << 23;
+        reg_data |= ( 0x2 ) << 20;
+        reg_data |= ( 0x2 ) << 16;
+    }else if( number_of_lane >= 3 && number_of_lane <= 8 ){
+        // TX lane
+        reg_data |= ( 0x0 ) << 7;
+        reg_data |= ( number_of_lane - 1 ) << 4;
+        // RX lane
+        reg_data |= ( 0x0 ) << 24;
+        reg_data |= ( number_of_lane - 1 ) << 20;
+    }else{
+        nlm_print( "    ERROR!!!!!!!!!!!!! ILA Doesn't support %u SerDes lanes!!!!!!!!!!!!!\n", number_of_lane );
+    } // end if & else if & else
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, LA_BAD_LANE, reg_data );
+
+    // set timeout time tick
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, KBP_REQ_ID, 0x00000400 );
+
+    // set metaframe
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, LA_LEN, ( ( rx_metaframe_length - 1 ) << 16 ) | ( tx_metaframe_length - 1 ) );
+
+    // set LSB position of Context Buffer ID to [17], so the valid Context Buffer ID length is 12-bit in an ILA request at descriptor0 bit [28:17]
+    // set Zero Pad Length of Context Buffer ID to [0]
+    // these 12 bits correspond to context buffer address [13:2] at KBP because ILA automatically masks out LSBs to zeros when sending request to KBP
+    reg_data = nlm_hal_ila_reg_read( node, KBP_START_LANE, KBP_CTL );
+    reg_data = ( reg_data & 0xFFFFFFF0 ) | 0x1;
+    reg_data = ( reg_data & 0xFFFE0FFF ) | ( 0x11 << 12 );
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, KBP_CTL, reg_data );
+
+    // Enable packet counter and counter interrupts
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, KBP_PKT_CNT_CTL, 0xC000C000 );
+
+    // wait until PCS lanes are ready
+    nlm_print( "    Polling for PCS Lanes ready...\n" );
+    do{
+        KBP_DELAY( 10000 );
+        reg_data = nlm_hal_ila_reg_read( node, KBP_START_LANE, SER_CTL );
+        reg_data &= 0xFF;
+    }while( reg_data != 0xFF ); // end do & while
+    nlm_print( "    All PCS Lanes are ready\n" );
+
+    // Reset RX SerDes clocks, TX SerDes, RX SerDes and TX
+    KBP_DELAY( 10000 );
+    reg_data = ( 0xFF << 24 ) | ( 0x1 << 22 ) | ( 0x1 << 21 ) | ( 0x1 << 20 );
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, LA_RX_SYNC, reg_data );
+
+    // Wait for all RX lanes to be aligned/de-skewed
+    nlm_print( "    Polling for Word Boundary and Scrambler Lock...\n" );
+    nlm_print( "        If Word Boundary and Scrambler Lock does not come up, check Meta Frame, Enabled Number of Lanes and SerDes Speed setting\n" );
+    do{
+        reg_data = nlm_hal_ila_reg_read( node, KBP_START_LANE, LA_RX_SYNC );
+        reg_data = ( reg_data >> 18 ) & 0b1;
+    }while( reg_data != 1 ); // end do & while
+    nlm_print( "    Word Boundary and Scrambler are Locked\n" );
+
+    // Enable TX
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, LA_TX_ENABLE, 0x1 );
+
+    // Enable capture of 3'bxxx except 3'b000 in pick1 counter and 3'bx1x in pick0 counter on error status bits [31:29] of KBP responses
+    reg_data = ( 0xFE << 16 ) | ( 0xCC << 8 );
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, KBP_RSP_ERROR_PAR, reg_data );
+
+    // Set TX short burst length to 16 bytes
+    reg_data = nlm_hal_ila_reg_read( node, KBP_START_LANE, LA_SETUP );
+    reg_data &= 0xFFFFF8FF;
+    reg_data |= ( 0x1 << 8 );
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, LA_SETUP, reg_data );
+
+    // Change LA MEM Usage Register Threshold
+    reg_data = nlm_hal_ila_reg_read( node, KBP_START_LANE, LA_MEM_USAGE );
+    reg_data &= 0xFFFFFF00;
+    if( is_nlm_xlp8xx_ax() ){
+        reg_data |= 0x3A;
+    }else if( is_nlm_xlp8xx_bx() ){
+        reg_data |= 0xFF;
+    } // end if & else if
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, LA_MEM_USAGE, reg_data );
+
+    // Set up counters to capture errors flagged at bit [31:29] in KBP response packets control word
+    // 0xFE : increase counter when [31:29] = one of {3'b111, 3'b110, 3'b101, 3'b100, 3'b011, 3'b010, 3'b001}
+    // 0xCC : increase counter when [31:29] = one of {3'b111, 3'b110, 3'b011, 3'b010}
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, KBP_RSP_ERROR_PAR, 0x00FECC00 );
+
+    // Set Tick Scale for timeout when waiting for response from KBP
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, KBP_REQ_ID, 0x00000400 );
+
+    // check for KBP link status
+    nlm_print( "    Checking for KBP status on [RX PCS Ready], [Core Init Done], [SerDes Reset Sequence Done] after ILA Reset\n" );
+    reg_data = nlm_hal_kbp_mdio_read( node, KBP_GEN_STATUS2, MDIO_DEV_CSM );
+    if( ( reg_data & 0xE ) == 0xE ){
+        nlm_print( "    KBP is ready after ILA Reset\n" );
+    }else{
+        nlm_print( "    ERROR!!!!!!!!!!!!! KBP is not ready after ILA Reset!!!!!!!!!!!!!\n" );
+        nlm_print( "ILA Reset Sequence is NOT Done\n" );
+        return;
+    } // end if & else
+
+    // clear interrupts after initialization
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, KBP_INT, 0xFFFFFFFF );
+    nlm_hal_ila_reg_write( node, KBP_START_LANE, LA_INT, 0xFFFFFFFF );
+
+    nlm_print( "ILA Reset Sequence is Done\n" );
+
+} // end nlm_hal_ila_reset
+
+#endif /*__ASSEMBLY_*/
+#endif /* _NLM_HAL_KBP_H_ */
diff --git a/arch/mips/include/asm/netlogic/hal/nlm_hal_macros.h b/arch/mips/include/asm/netlogic/hal/nlm_hal_macros.h
index 7f6add6..c4570ae 100644
--- a/arch/mips/include/asm/netlogic/hal/nlm_hal_macros.h
+++ b/arch/mips/include/asm/netlogic/hal/nlm_hal_macros.h
@@ -1,27 +1,32 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
 
 #ifndef _NLM_HAL_MACROS_H
 #define _NLM_HAL_MACROS_H
@@ -36,10 +41,17 @@ extern unsigned long xlp_poe_base_pcim[];
 extern unsigned long xlp_sys_base[];
 
 extern int nlm_chip_is_xlp3xx;
-extern int is_nlm_xlp8xx(void);
 extern unsigned long xlp_regex_base_pcie;
 extern unsigned long xlp_regex_base_pcim;
 
+
+#ifndef is_nlm_xlp8xx
+extern int is_nlm_xlp(unsigned int chipid, unsigned int rev, unsigned int ext);
+
+#define XLP_REVISION_ANY 0xFF
+#define is_nlm_xlp8xx()      (is_nlm_xlp(800, XLP_REVISION_ANY, 0) || is_nlm_xlp(400, XLP_REVISION_ANY, 0))
+#endif //is_nlm_xlp8xx
+
 #endif /* #ifndef __ASSEMBLY__ */
 
 
@@ -78,11 +90,13 @@ extern unsigned long xlp_regex_base_pcim;
 
 #include <asm/mipsregs.h>
 #ifndef __ASSEMBLY__
+#include <linux/version.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/mm.h>
 #include <linux/delay.h>
 #include <linux/slab.h>
+#include <asm/atomic.h>
 
 #define nlm_print printk
 #define nlm_malloc(size) kmalloc((size), GFP_KERNEL)
@@ -254,7 +268,7 @@ static __inline__ void _netos_delay(unsigned int x)
 #define NLM_HAL_THREAD_SIZE (8 << 10)
 
 /* For hal internal debug */
-#define nlm_hal_dbg_msg(fmt, args...) printk(fmt, ##args)
+#define nlm_hal_dbg_msg(fmt, args...) nlm_print(fmt, ##args)
 
 #ifndef __STR
 #define __STR(x) #x
@@ -1215,6 +1229,9 @@ static __inline__ uint32_t nlm_read_ebase(void)
 #define WRITE_REGX_CFG_REG_PCIM(reg, val)       nlh_write_cfg_reg32((xlp_regex_base_pcim + reg), (val))
 #define READ_REGX_CFG_REG_PCIM(reg)             nlh_read_cfg_reg32((xlp_regex_base_pcim + reg))
 
+#define nlh_send_msg4(dst, code, data0, data1, data2, data3) \
+  nlm_uaccess_msgsnd_4(code, dst, data0, data1, data2, data3)
+
 #define nlh_send_msg3(dst, code, data0, data1, data2) \
   nlm_uaccess_msgsnd_3(code, dst, data0, data1, data2)
 
@@ -1231,12 +1248,6 @@ static __inline__ uint32_t nlm_read_ebase(void)
 #define nlh_recv_msg1(dst, src, size, code, data0)	\
   nlm_uaccess_msgrcv_1(dst, src, size, code, data0)
 
-#define nlh_pop_msg2(dst, src, code, data0, data1)	\
-  nlm_pop_msg_2(dst, src, code, data0, data1);
-
-#define nlh_pop_msg1(dst, src, code, data0)\
-  nlm_pop_msg_1(dst, src, code, data0);
-
 /* NETOS and Linux Kernel Mdoe */
 #elif defined(NLM_HAL_NETOS) || defined(NLM_HAL_LINUX_KERNEL) \
 	|| defined(NLM_HAL_UBOOT) || defined(NLM_HAL_NETLBOOT) || defined(NLM_HAL_XLOADER)
@@ -1248,6 +1259,10 @@ static __inline__ uint32_t nlm_read_ebase(void)
 #define nlh_read_cfg_reg64(addr)       ld_40bit_phys_uncached(addr)
 #define nlh_write_cfg_reg64(addr, val) sd_40bit_phys_uncached(addr, val)
 
+
+#define nlh_send_msg4(dst, code, data0, data1, data2, data3) \
+  xlp_message_send_4(dst, code, data0, data1, data2, data3)
+
 #define nlh_send_msg3(dst, code, data0, data1, data2) \
   xlp_message_send_3(dst, code, data0, data1, data2)
 
@@ -1263,12 +1278,6 @@ static __inline__ uint32_t nlm_read_ebase(void)
 #define nlh_recv_msg1(dst, src, size, code, data0) \
   xlp_message_receive_1(dst, src, size, code, data0)
 
-#define nlh_pop_msg2(dst, src, code, data0, data1) \
-  xlp_message_pop_2(dst, src, code, data0, data1)
-
-#define nlh_pop_msg1(dst, src, code, data0) \
-  xlp_message_pop_1(dst, src, code, data0)
-
 #else
 #error "Unsupported platform for NL HAL"
 
diff --git a/arch/mips/include/asm/netlogic/hal/nlm_hal_nae.h b/arch/mips/include/asm/netlogic/hal/nlm_hal_nae.h
index 933b5e9..a4acf3d 100644
--- a/arch/mips/include/asm/netlogic/hal/nlm_hal_nae.h
+++ b/arch/mips/include/asm/netlogic/hal/nlm_hal_nae.h
@@ -1,27 +1,32 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
 
 #ifndef _NLM_HAL_NAE_H_
 #define _NLM_HAL_NAE_H_
@@ -35,6 +40,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define MAX_DV_TBL_ENTRIES (NUM_DIST_VEC * NUM_WORDS_PER_DV)
 
 #define XLP_3XX_MAX_PORTS	8
+#define XLP_2XX_MAX_PORTS	8
 #define XLP_MAX_PORTS		18
 
 #define NAE_RECV_NONE          	0x00000000
@@ -96,7 +102,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define XLP8XX_MAX_STG2_OFFSET           0x7F
 #define XLP8XX_MAX_EH_OFFSET           	 0x7F
 #define XLP8XX_MAX_FREE_OUT_OFFSET       0x7F
-#define XLP8XX_MAX_MS_OFFSET             0x1F
+#define XLP8XX_MAX_MS_OFFSET             0x14
 #define XLP8XX_MAX_PMEM_OFFSET           0x7FE
 
 #define XLP8XX_STG1_2_CREDIT     XLP8XX_STG2_FIFO_SZ
@@ -123,6 +129,10 @@ struct nae_complex_config {
 	uint32_t num_channels[MAX_PORTS_PERBLOCK];
 	uint32_t num_lanes;
 	uint32_t lane_rate;
+	uint32_t higig_mode;
+	uint32_t xgmii_speed;
+	uint32_t vlan_pri_en;
+	uint32_t msec_port_enable;
 };
 
 
@@ -141,7 +151,7 @@ struct poe_statistics {
 
 static inline uint32_t nlm_stg2_fifo_sz(void)
 {
-	if(is_nlm_xlp3xx()){
+	if(is_nlm_xlp3xx()||is_nlm_xlp2xx()){
 		return XLP3XX_STG2_FIFO_SZ;
 	}else{
 		return XLP8XX_STG2_FIFO_SZ;
@@ -150,7 +160,7 @@ static inline uint32_t nlm_stg2_fifo_sz(void)
 
 static inline uint32_t nlm_eh_fifo_sz(void)
 {
-	if(is_nlm_xlp3xx()){
+	if(is_nlm_xlp3xx()||is_nlm_xlp2xx()){
 		return XLP3XX_EH_FIFO_SZ;
 	}else{
 		return XLP8XX_EH_FIFO_SZ;
@@ -159,7 +169,7 @@ static inline uint32_t nlm_eh_fifo_sz(void)
 
 static inline uint32_t nlm_frout_fifo_sz(void)
 {
-	if(is_nlm_xlp3xx()){
+	if(is_nlm_xlp3xx()||is_nlm_xlp2xx()){
 		return XLP3XX_FROUT_FIFO_SZ;
 	}else{
 		return XLP8XX_FROUT_FIFO_SZ;
@@ -168,7 +178,7 @@ static inline uint32_t nlm_frout_fifo_sz(void)
 
 static inline uint32_t nlm_ms_fifo_sz(void)
 {
-	if(is_nlm_xlp3xx()){
+	if(is_nlm_xlp3xx()||is_nlm_xlp2xx()){
 		return XLP3XX_MS_FIFO_SZ;
 	}else{
 		return XLP8XX_MS_FIFO_SZ;
@@ -177,7 +187,7 @@ static inline uint32_t nlm_ms_fifo_sz(void)
 
 static inline uint32_t nlm_pkt_fifo_sz(void)
 {
-	if(is_nlm_xlp3xx()){
+	if(is_nlm_xlp3xx()||is_nlm_xlp2xx()){
 		return XLP3XX_PKT_FIFO_SZ;
 	}else{
 		return XLP8XX_PKT_FIFO_SZ;
@@ -186,7 +196,7 @@ static inline uint32_t nlm_pkt_fifo_sz(void)
 
 static inline uint32_t nlm_pktlen_fifo_sz(void)
 {
-	if(is_nlm_xlp3xx()){
+	if(is_nlm_xlp3xx()||is_nlm_xlp2xx()){
 		return XLP3XX_PKTLEN_FIFO_SZ;
 	}else{
 		return XLP8XX_PKTLEN_FIFO_SZ;
@@ -195,7 +205,7 @@ static inline uint32_t nlm_pktlen_fifo_sz(void)
 
 static inline uint32_t max_stg2_offset(void)
 {
-	if(is_nlm_xlp3xx()){
+	if(is_nlm_xlp3xx()||is_nlm_xlp2xx()){
 		return XLP3XX_MAX_STG2_OFFSET;
 	}else{
 		return XLP8XX_MAX_STG2_OFFSET;
@@ -204,7 +214,7 @@ static inline uint32_t max_stg2_offset(void)
 
 static inline uint32_t max_eh_offset(void)
 {
-	if(is_nlm_xlp3xx()){
+	if(is_nlm_xlp3xx()||is_nlm_xlp2xx()){
 		return XLP3XX_MAX_EH_OFFSET;
 	}else{
 		return XLP8XX_MAX_EH_OFFSET;
@@ -213,7 +223,7 @@ static inline uint32_t max_eh_offset(void)
 
 static inline uint32_t max_free_out_offset(void)
 {
-	if(is_nlm_xlp3xx()){
+	if(is_nlm_xlp3xx()||is_nlm_xlp2xx()){
 		return XLP3XX_MAX_FREE_OUT_OFFSET;
 	}else{
 		return XLP8XX_MAX_FREE_OUT_OFFSET;
@@ -222,7 +232,7 @@ static inline uint32_t max_free_out_offset(void)
 
 static inline uint32_t max_ms_offset(void)
 {
-	if(is_nlm_xlp3xx()){
+	if(is_nlm_xlp3xx()||is_nlm_xlp2xx()){
 		return XLP3XX_MAX_MS_OFFSET;
 	}else{
 		return XLP8XX_MAX_MS_OFFSET;
@@ -231,7 +241,7 @@ static inline uint32_t max_ms_offset(void)
 
 static inline uint32_t max_pmem_offset(void)
 {
-	if(is_nlm_xlp3xx()){
+	if(is_nlm_xlp3xx()||is_nlm_xlp2xx()){
 		return XLP3XX_MAX_PMEM_OFFSET;
 	}else{
 		return XLP8XX_MAX_PMEM_OFFSET;
@@ -240,7 +250,7 @@ static inline uint32_t max_pmem_offset(void)
 
 static inline uint32_t stg1_2_credit(void)
 {
-	if(is_nlm_xlp3xx()){
+	if(is_nlm_xlp3xx()||is_nlm_xlp2xx()){
 		return XLP3XX_STG1_2_CREDIT;
 	}else{
 		return XLP8XX_STG1_2_CREDIT;
@@ -249,7 +259,7 @@ static inline uint32_t stg1_2_credit(void)
 
 static inline uint32_t stg2_eh_credit(void)
 {
-	if(is_nlm_xlp3xx()){
+	if(is_nlm_xlp3xx()||is_nlm_xlp2xx()){
 		return XLP3XX_STG2_EH_CREDIT;
 	}else{
 		return XLP8XX_STG2_EH_CREDIT;
@@ -258,7 +268,7 @@ static inline uint32_t stg2_eh_credit(void)
 
 static inline uint32_t stg2_frout_credit(void)
 {
-	if(is_nlm_xlp3xx()){
+	if(is_nlm_xlp3xx()||is_nlm_xlp2xx()){
 		return XLP3XX_STG2_FROUT_CREDIT;
 	}else{
 		return XLP8XX_STG2_FROUT_CREDIT;
@@ -267,7 +277,7 @@ static inline uint32_t stg2_frout_credit(void)
 
 static inline uint32_t stg2_ms_credit(void)
 {
-	if(is_nlm_xlp3xx()){
+	if(is_nlm_xlp3xx()||is_nlm_xlp2xx()){
 		return XLP3XX_STG2_MS_CREDIT;
 	}else{
 		return XLP8XX_STG2_MS_CREDIT;
@@ -309,6 +319,7 @@ static inline uint32_t stg2_ms_credit(void)
   nlh_read_cfg_reg32((xlp_mac_base[node] + 0x10000 + (ucore * CODE_SIZE_PER_UCORE) + offset))
 
 #define nlm_hal_write_mac_reg(node, blk, iface, reg, val) nlm_hal_write_32bit_reg(XLP_MAC_OFFSET(node, blk, iface), (reg), (val))
+
 #define nlm_hal_read_mac_reg(node, blk, iface, reg) nlm_hal_read_32bit_reg(XLP_MAC_OFFSET(node, blk, iface), (reg))
 
 #define read_gmac_reg(node, idx, reg) nlm_hal_read_mac_reg(node, (((idx) & 0xff)>>2), ((idx) & 0x3), reg)
@@ -339,15 +350,29 @@ extern void nlm_hal_init_poe_ext_storage(int node, uint64_t fbp_base_phys,
 
 extern int nlm_hal_load_ucore(int node, int ucore_mask, unsigned int *opcodes, int num_opcodes);
 
-extern int nlm_hal_init_if(int node, int type, int  inf, uint32_t *regs, int num_regs);
-extern int nlm_hal_open_if(int node, int type, int  inf);
-extern int nlm_hal_close_if(int node, int type, int  inf);
+extern int nlm_hal_init_if(int node, int intf_type, int  block, uint32_t *regs, int num_regs);
+extern int nlm_hal_open_if(int node, int intf_type, int  block);
+extern int nlm_hal_close_if(int node, int intf_type, int  block);
 extern void nlm_hal_init_ingress(int node, int desc_size);
 
 extern int nlm_enable_poe_statistics(int node);
 extern int nlm_disable_poe_statistics(int node);
 extern int nlm_read_poe_statistics(int node, struct poe_statistics *stats);
 
+extern void nlm_hal_prepad_enable(int node, int size);
+extern void nlm_hal_reset_1588_accum(int node);
+extern void nlm_hal_1588_ld_freq_mul(int node, uint32_t ptp_inc_den, uint32_t ptp_inc_num, 
+					uint32_t ptp_inc_intg);
+extern void nlm_hal_1588_ld_offs(int node, uint32_t ptp_off_hi,  uint32_t ptp_off_lo);
+extern void nlm_hal_1588_ld_user_val(int node, uint32_t user_val_hi,  uint32_t user_val_lo);
+extern void nlm_hal_1588_ptp_clk_sel(int node, int clk_type);
+extern uint32_t nlm_hal_get_int_sts(int node);
+extern uint64_t  nlm_hal_1588_ptp_get_counter(int node, int counter);
+extern void nlm_hal_1588_ptp_set_counter(int node, int counter, uint64_t cnt_val);
+extern int nlm_hal_is_intr_1588(int node);
+extern void nlm_hal_enable_1588_intr(int node,int mask);
+extern void nlm_hal_clear_1588_intr(int node, int timer);
+
 enum NAE_REG_CMD {
         CMD_READ = 0,
         CMD_WRITE
@@ -440,14 +465,14 @@ extern int nlm_hal_c45_mdio_indirect_read_external (int node, int bus,
 #define NLM_C45_READ(node, bus, phyaddr, dev_addr, reg_addr)	\
    nlm_hal_c45_mdio_indirect_read_external(node, bus, phyaddr, dev_addr, reg_addr)
 
-extern void xlp3xx_8xxb0_nae_lane_reset_txpll(int node, int block, int lane_ctrl, int phymode);
+extern int xlp3xx_8xxb0_nae_lane_reset_txpll(int node, int block, int lane_ctrl, int phymode);
 extern void xlp8xx_ax_nae_lane_reset_txpll(int node, int block, int lane_ctrl, int phymode);
 
 /*  PCS initialization
  */
 extern void nlm_hal_mdio_init(int node);
 extern void nlm_hal_sgmii_pcs_init(int node, int sgmii_cplx_mask);
-extern void nlm_hal_xaui_pcs_init(int node, int xaui_cplx_mask, int rxaui_en);
+extern void nlm_hal_xaui_pcs_init(int node, nlm_nae_config_ptr nae_cfg);
 extern int nlm_hal_ilk_pcs_init(int node, uint32_t ilk_complex_map);
 extern int nlm_hal_init_cs34x7(int hwport,int num_lanes, int lane_rate);
 extern int cortina_set_max_framesize(int hwport, int port, uint16_t framesize);
@@ -468,15 +493,25 @@ extern int nlm_hal_write_ucore_shared_mem(int node, unsigned int *data, int word
 
 extern int nlm_hal_get_phy_status(int node, int inf, uint32_t *speed, uint32_t *duplex);
 
-extern void nlm_hal_mac_disable(int node, int inf, int type);
+extern void nlm_hal_mac_disable(int node, int block, int intf_type);
 
-extern void nlm_hal_mac_enable(int node, int inf, int type);
+extern void nlm_hal_mac_enable(int node, int block, int intf_type);
 
 extern uint16_t nlm_hal_get_hwport(int node, uint32_t context);
 extern int nlm_hal_set_xaui_framesize(int node, int block, uint32_t tx_size, uint32_t rx_size);
 extern int nlm_hal_set_sgmii_framesize(int node, int block, int index, uint32_t size);
 extern int nlm_hal_set_ilk_framesize(int node, int block, int port, uint32_t size);
 extern int nlm_config_vfbid_table(int node, uint32_t start, uint32_t num_entries, uint32_t *vfbid_tbl);
+extern void nlm_hal_msec_tx_default_config(int node, unsigned int port_enable, unsigned int preamble_len, unsigned int packet_num, unsigned int pn_thrshld);
+extern void nlm_hal_msec_rx_default_config(int node, unsigned int port_enable, unsigned int preamble_len, unsigned int packet_num, unsigned int replay_win_size);
+extern void nlm_hal_msec_rx_mem_config(int node, int port, int index, uint64_t sci, unsigned char *key, uint64_t sci_mask);
+extern void nlm_hal_msec_rx_config(int node, unsigned int port_enable, unsigned int preamble_len, unsigned int packet_num, unsigned int replay_win_size);
+extern void nlm_hal_msec_tx_mem_config(int node, int context, int tci, uint64_t sci, unsigned char *key);
+extern void nlm_hal_msec_tx_config(int node, unsigned int port_enable, unsigned int preamble_len, unsigned int packet_num, unsigned int pn_thrshld);
+extern int nlm_hal_retrieve_shared_freein_fifo_info(void *fdt, 
+		int shared_dom_id, int *owner_replenish, char **paddr_info, int *paddr_info_len,
+		char **desc_info, int *desc_info_len);
+extern unsigned int nlm_hal_retrieve_freein_fifo_mask(void *fdt, int node, int dom_id);
 #endif //__ASSEMBLY__
 
 
@@ -553,7 +588,18 @@ static inline void nlm_write_poe_distr_threshold(int node, uint32_t threshold0,
 	nlm_hal_write_poe_pcie_reg(node, POE_DIST_THRESHOLD_0+3, threshold3);
 }
 
+static inline uint32_t nlm_hal_ptp_timer_hi(int node, int inf_num)
+{
+       return nlm_hal_read_nae_reg(node, IF_1588_TMSMP_HI+(2*inf_num));
+}
+
+static inline uint32_t nlm_hal_ptp_timer_lo(int node, int inf_num)
+{
+       return nlm_hal_read_nae_reg(node, IF_1588_TMSMP_LO+(2*inf_num));
+}
+
 extern void nlm_hal_rxaui_nlp1042c2_init(int port, int rxaui_mode);
 
+extern uint32_t nlm_hal_get_rtc(int node, uint32_t* p_val_hi,  uint32_t* p_val_lo);
 
 #endif //#ifndef _NLM_HAL_NAE_H_
diff --git a/arch/mips/include/asm/netlogic/hal/nlm_hal_pic.h b/arch/mips/include/asm/netlogic/hal/nlm_hal_pic.h
new file mode 100644
index 0000000..cde6a18
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/hal/nlm_hal_pic.h
@@ -0,0 +1,458 @@
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
+
+#ifndef _NLM_HAL_PIC_H
+#define _NLM_HAL_PIC_H
+
+#include "nlm_hal.h"
+
+#define TIMER_CYCLES_MAXVAL        0xffffffffffffffffULL
+
+/*
+ *    IRT Map
+ */
+#define PIC_NUM_IRTS               160
+
+#define PIC_IRT_WD_0_INDEX         0
+#define PIC_IRT_WD_1_INDEX         1
+#define PIC_IRT_WD_NMI_0_INDEX     2
+#define PIC_IRT_WD_NMI_1_INDEX     3
+#define PIC_IRT_TIMER_0_INDEX      4
+#define PIC_IRT_TIMER_1_INDEX      5
+#define PIC_IRT_TIMER_2_INDEX      6
+#define PIC_IRT_TIMER_3_INDEX      7
+#define PIC_IRT_TIMER_4_INDEX      8
+#define PIC_IRT_TIMER_5_INDEX      9
+#define PIC_IRT_TIMER_6_INDEX      10
+#define PIC_IRT_TIMER_7_INDEX      11
+#define PIC_IRT_CLOCK_INDEX        PIC_IRT_TIMER_7_INDEX
+
+#define PIC_NUM_MSG_Q_IRTS         32
+#define PIC_IRT_MSG_Q0_INDEX       12
+#define PIC_IRT_MSG_Q_INDEX(qid)   ((qid) + PIC_IRT_MSG_Q0_INDEX) // 12 - 43
+
+#define PIC_IRT_MSG_0_INDEX        44
+#define PIC_IRT_MSG_1_INDEX        45
+
+#define PIC_NUM_PCIE_MSIX_IRTS     32
+#define PIC_IRT_PCIE_MSIX_0_INDEX  46
+#define PIC_IRT_PCIE_MSIX_INDEX(num) ((num) + PIC_IRT_PCIE_MSIX_0_INDEX) // 46 - 77
+
+#define PIC_NUM_PCIE_LINK_IRTS     4
+#define PIC_IRT_PCIE_LINK_0_INDEX  78
+#define PIC_IRT_PCIE_LINK_INDEX(num) ((num) + PIC_IRT_PCIE_LINK_0_INDEX) // 78 - 81
+
+#define PIC_NUM_NA_IRTS            32
+#define PIC_IRT_NA_0_INDEX         82
+#define PIC_IRT_NA_INDEX(num)      ((num) + PIC_IRT_NA_0_INDEX) // 82 - 113
+
+#define PIC_IRT_POE_INDEX          114
+
+#define PIC_NUM_USB_IRTS           6
+#define PIC_IRT_USB_0_INDEX        115
+#define PIC_IRT_USB_INDEX(num) ((num) + PIC_IRT_USB_0_INDEX) // 115 - 120
+
+#define PIC_IRT_GDX_INDEX          121
+#define PIC_IRT_SEC_INDEX          122
+#define PIC_IRT_RSA_INDEX          123
+
+#define PIC_NUM_COMP_IRTS          4
+#define PIC_IRT_COMP_0_INDEX       124
+#define PIC_IRT_COMP_INDEX(num)    ((num) + PIC_IRT_COMP_0_INDEX) // 124 - 127
+
+#define PIC_IRT_ICC_0_INDEX        129 // ICC - Inter Chip Coherency
+#define PIC_IRT_ICC_1_INDEX        130
+#define PIC_IRT_ICC_2_INDEX        131
+#define PIC_IRT_CAM_INDEX          132
+#define PIC_IRT_UART_0_INDEX       133
+#define PIC_IRT_UART_1_INDEX       134
+#define PIC_IRT_I2C_0_INDEX        135
+#define PIC_IRT_I2C_1_INDEX        136
+#define PIC_IRT_SYS_0              137
+#define PIC_IRT_SYS_1              138
+#define PIC_IRT_JTAG_INDEX         139
+#define PIC_IRT_PIC                140
+
+#define PIC_NUM_GPIO_IRTS          4
+#define PIC_IRT_GPIO_0_INDEX       146
+#define PIC_IRT_GPIO_INDEX(num)    ((num) + PIC_IRT_GPIO_0_INDEX) // 146 - 149
+
+#define PIC_IRT_NOR                150
+#define PIC_IRT_NAND               151
+#define PIC_IRT_SPI                152
+#define PIC_IRT_MMC                153
+#define PIC_IRT_NBU                154
+#define PIC_IRT_TCU                155
+#define PIC_IRT_GCU                156 // GBC - Global Coherency
+#define PIC_IRT_DMC_0_INDEX        157
+#define PIC_IRT_DMC_1_INDEX        158
+#define PIC_IRT_TCB                159
+
+/*
+ *     Register Offsets
+ */
+#define PIC_CTRL             0x00
+#define PIC_BYTESWAP         0x01
+#define PIC_STATUS           0x02
+#define PIC_INT_TIMEOUT      0x03
+#define PIC_ICI0_INT_TIMEOUT 0x04
+#define PIC_ICI1_INT_TIMEOUT 0x05
+#define PIC_ICI2_INT_TIMEOUT 0x06
+#define PIC_IPI_CTL          0x07
+#define PIC_INT_ACK          0x08
+#define PIC_INT_PENDING0     0x09
+#define PIC_INT_PENDING1     0x0a
+#define PIC_INT_PENDING2     0x0b
+
+#define PIC_WD0_MAX_VAL      0x0c
+#define PIC_WD0_COUNT        0x0d
+#define PIC_WD0_MASK_0       0x0e
+#define PIC_WD0_MASK_1       0x0f
+#define PIC_WD0_HEARBEATCMD  0x10
+#define PIC_WD0_HEARBEAT_0   0x11
+#define PIC_WD0_HEARBEAT_1   0x12
+
+#define PIC_WD_MAX_VAL(id)    (PIC_WD0_MAX_VAL + ((id) ? 7 : 0))
+#define PIC_WD_COUNT(id)      (PIC_WD0_COUNT + ((id) ? 7 : 0))
+#define PIC_WD_MASK_0(id)     (PIC_WD0_MASK_0 + ((id) ? 7 : 0))
+#define PIC_WD_MASK_1(id)     (PIC_WD0_MASK_1 + ((id) ? 7 : 0))
+#define PIC_WD_HEARBEAT_0(id) (PIC_WD0_HEARTBEAT_0 + ((id) ? 7 : 0))
+#define PIC_WD_HEARBEAT_1(id) (PIC_WD0_HEARTBEAT_1 + ((id) ? 7 : 0))
+
+#define PIC_SYS_TIMER_0_MAX_VAL   0x1a
+#define PIC_SYS_TIMER_MAX_VAL(id) (PIC_SYS_TIMER_0_MAX_VAL + (id))
+
+#define PIC_SYS_TIMER_0_COUNTER   0x22
+#define PIC_SYS_TIMER_COUNTER(id) (PIC_SYS_TIMER_0_COUNTER + (id))
+
+#define PIC_TIMER_0_MAXVAL   PIC_SYS_TIMER_0_MAX_VAL
+#define PIC_TIMER_0_COUNTER  PIC_SYS_TIMER_0_COUNTER
+#define PIC_TIMER_7_MAXVAL   PIC_SYS_TIMER_MAX_VAL(7)
+#define PIC_TIMER_7_COUNTER  PIC_SYS_TIMER_COUNTER(7)
+#define PIC_TIMER_6_MAXVAL   PIC_SYS_TIMER_MAX_VAL(6)
+#define PIC_TIMER_6_COUNTER  PIC_SYS_TIMER_COUNTER(6)
+
+#define PIC_INT_THR_ENABLE_0_N01   0x2a
+#define PIC_INT_THR_ENABLE_0_N23   0x2b
+#define PIC_INT_THR_ENABLE_N01(id) (PIC_INT_THR_ENABLE_0_N01 + ((id) * 2))
+#define PIC_INT_THR_ENABLE_N23(id) (PIC_INT_THR_ENABLE_0_N23 + ((id) * 2))
+
+#define PIC_IRT_0   0x3a
+#define PIC_IRT(id) (PIC_IRT_0 + (id))
+
+#define PIC_IRT_WD_0        PIC_IRT(PIC_IRT_WD0_INDEX)
+#define PIC_IRT_WD_1        PIC_IRT(PIC_IRT_WD1_INDEX)
+#define PIC_IRT_TIMER_0     PIC_IRT(PIC_IRT_TIMER_0_INDEX)
+#define PIC_IRT_TIMER_1     PIC_IRT(PIC_IRT_TIMER_1_INDEX)
+#define PIC_IRT_TIMER_2     PIC_IRT(PIC_IRT_TIMER_2_INDEX)
+#define PIC_IRT_TIMER_3     PIC_IRT(PIC_IRT_TIMER_3_INDEX)
+#define PIC_IRT_TIMER_4     PIC_IRT(PIC_IRT_TIMER_4_INDEX)
+#define PIC_IRT_TIMER_5     PIC_IRT(PIC_IRT_TIMER_5_INDEX)
+#define PIC_IRT_TIMER_6     PIC_IRT(PIC_IRT_TIMER_6_INDEX)
+#define PIC_IRT_TIMER_7     PIC_IRT(PIC_IRT_TIMER_7_INDEX)
+#define PIC_IRT_CLOCK       PIC_IRT_TIMER_7
+#define PIC_IRT_UART_0      PIC_IRT(PIC_IRT_UART_0_INDEX)
+#define PIC_IRT_UART_1      PIC_IRT(PIC_IRT_UART_1_INDEX)
+#define PIC_IRT_I2C_0       PIC_IRT(PIC_IRT_I2C_0_INDEX)
+#define PIC_IRT_I2C_1       PIC_IRT(PIC_IRT_I2C_1_INDEX)
+
+#define PIC_CLOCK_TIMER     7
+#define PIC_IRQ_BASE        8
+
+#define ASM_XLP_IO_PIC_OFFSET        0xffffffffb8004100 /* TODO: This will change in to function */
+#define C_XLP_IO_PIC_OFFSET        0xffffffffb8004100ULL /* TODO: This will change in to function */
+
+#ifndef __ASSEMBLY__
+enum {
+	WD0 = 0,
+	WD1 = 1
+};
+extern int irt_irq_table[PIC_NUM_IRTS][4];
+extern int find_irt_from_irq(int irq_num);
+extern int nlm_hal_request_shared_irq(int irt);
+extern void nlm_hal_unrequest_shared_irq(int irt);
+
+static __inline__ int nlm_hal_irt_to_irq(int irt_num)
+{
+	if(irt_num < 0 || irt_num > PIC_NUM_IRTS)
+		return -1;
+
+	return irt_irq_table[irt_num][0];
+}
+
+static __inline__ int nlm_hal_irq_to_irt(int irq_num)
+{
+	int irt = find_irt_from_irq(irq_num);
+	return irt;
+}
+
+static __inline__ int nlm_hal_is_shared_irt(int irt_num)
+{
+	return irt_irq_table[irt_num][1];
+}
+
+#define PIC_IRT_FIRST_IRQ        (PIC_IRQ_BASE)
+#define PIC_WD_0_IRQ             nlm_hal_irt_to_irq(PIC_IRT_WD_0_INDEX)
+#define PIC_WD_1_IRQ             nlm_hal_irt_to_irq(PIC_IRT_WD_1_INDEX)
+#define PIC_TIMER_0_IRQ          nlm_hal_irt_to_irq(PIC_IRT_TIMER_0_INDEX)
+#define PIC_TIMER_1_IRQ          nlm_hal_irt_to_irq(PIC_IRT_TIMER_1_INDEX)
+#define PIC_TIMER_2_IRQ          nlm_hal_irt_to_irq(PIC_IRT_TIMER_2_INDEX)
+#define PIC_TIMER_3_IRQ          nlm_hal_irt_to_irq(PIC_IRT_TIMER_3_INDEX)
+#define PIC_TIMER_4_IRQ          nlm_hal_irt_to_irq(PIC_IRT_TIMER_4_INDEX)
+#define PIC_TIMER_5_IRQ          nlm_hal_irt_to_irq(PIC_IRT_TIMER_5_INDEX)
+#define PIC_TIMER_6_IRQ          nlm_hal_irt_to_irq(PIC_IRT_TIMER_6_INDEX)
+#define PIC_TIMER_7_IRQ          nlm_hal_irt_to_irq(PIC_IRT_TIMER_7_INDEX)
+#define PIC_CLOCK_IRQ            (PIC_TIMER_7_IRQ)
+#define PIC_UART_0_IRQ           17
+#define PIC_UART_1_IRQ           18
+#define PIC_I2C_0_IRQ            nlm_hal_irt_to_irq(PIC_IRT_I2C_0_INDEX)
+#define PIC_I2C_1_IRQ            nlm_hal_irt_to_irq(PIC_IRT_I2C_1_INDEX)
+#define PIC_GPIO_IRQ(num)        nlm_hal_irt_to_irq(PIC_IRT_GPIO_INDEX(num))
+#define PIC_IRT_LAST_IRQ_        (PIC_IRQ_BASE + PIC_NUM_IRTS - 1)
+#define PIC_IRT_LAST_IRQ()       PIC_IRT_LAST_IRQ_
+
+/*
+ *   Misc
+ */
+#define IRT_VALID       	1
+#define LOCAL_SCHEDULING    1
+#define GLOBAL_SCHEDULING   0
+#define PIC_IRQ_IS_IRT(irq) ((irq >= PIC_IRT_FIRST_IRQ) && (irq <= PIC_IRT_LAST_IRQ_))
+#define PIC_IRQ_IS_EDGE_TRIGGERED(irq) 0 // XLP interrupts are level triggered
+
+/*
+ *
+ */
+
+#define NODE_OFFSET(node) ((node) << 18)
+#define CPU_TO_NODE(cpu) ((cpu) >> 5)
+
+static __inline__ int nlm_hal_cpu_id(void)
+{
+	int cpu;
+
+	__asm__ __volatile__ (
+		".set push\n"
+		".set noreorder\n"
+		".set mips32\n"
+		"mfc0 %0, $15, 1\n"
+		"andi %0, %0, 0x3ff\n"
+		".set pop\n"
+		: "=r"(cpu)
+		);
+
+	return cpu;
+}
+
+#define XLP_IO_PIC_OFFSET        C_XLP_IO_PIC_OFFSET
+
+typedef volatile unsigned long long pic_reg_t;
+
+static __inline__ pic_reg_t* nlm_hal_pic_offset(void)
+{
+	uint32_t cpu = nlm_hal_cpu_id();
+
+	return ( (pic_reg_t *) (unsigned long) (XLP_IO_PIC_OFFSET + NODE_OFFSET( CPU_TO_NODE(cpu) )) );
+}
+
+#ifdef CONFIG_64BIT
+
+static __inline__ void nlm_hal_write_pic_reg(pic_reg_t *base, unsigned int offset, unsigned long long value)
+{
+	base[offset] = value;
+}
+static __inline__ unsigned long long nlm_hal_read_pic_reg(pic_reg_t *base, unsigned int offset)
+{
+	return ((base)[offset]);
+}
+
+#else
+
+static __inline__ void nlm_hal_write_pic_reg(pic_reg_t *base, unsigned int offset, unsigned long long value)
+{
+        uint32_t lsw, msw;
+        uint64_t val;
+        uint32_t ls, ms;
+        unsigned long flags;
+
+        lsw = (uint32_t)  (unsigned long long) (base+offset);
+        msw = (uint32_t) 0xffffffffUL;
+        val = (uint64_t)value;
+
+        ls = (uint32_t) (val & 0xffffffff);
+        ms = (uint32_t) (val >> 32);
+
+        enable_KX(flags);
+        __asm__ __volatile__(".set push\n"
+                        ".set noreorder\n"
+                        ".set mips64\n"
+                        ".set noat\n"
+                        "dsll32 $1, %2, 0\n"
+                        "dsll32 %1, 0\n"
+                        "dsrl32 %1, 0\n"
+                        "or $1, $1, %1\n"
+                        "dsll32 $8, %4, 0\n"
+                        "dsll32 %3, 0\n"
+                        "dsrl32 %3, 0\n"
+                        "or $8, $8, %3\n"
+                        "sd $8, 0($1) \n"
+                        ".set at\n"
+                        ".set pop\n"
+                        :
+                        :"r"(val), "r"(lsw), "r"(msw), "r"(ls), "r"(ms)
+                        :"$1", "$8");
+        disable_KX(flags);
+}
+
+static __inline__ unsigned long long nlm_hal_read_pic_reg(pic_reg_t *base, unsigned int offset)
+{
+        uint32_t lsw, msw;
+        uint64_t value = 0;
+        uint32_t lo, hi;
+        unsigned long flags;
+
+        lsw = (uint32_t) (unsigned long long) (base+offset);
+        msw = (uint32_t) 0xffffffffUL;
+
+        enable_KX(flags);
+        __asm__ __volatile__(".set push\n"
+                        ".set noreorder\n"
+                        ".set mips64\n"
+                        ".set noat\n"
+                        "dsll32 $1, %3, 0\n"
+                        "dsll32 %2, 0\n"
+                        "dsrl32 %2, 0\n"
+                        "or $1, $1, %2\n"
+                        "ld $8, 0($1) \n"
+                        "dsrl32 %1, $8, 0\n"
+                        "dsll32 $8, $8, 0\n"
+                        "dsrl32 %0, $8, 0\n"
+                        ".set at\n"
+                        ".set pop\n"
+                        :"=r"(lo), "=r"(hi)
+                        :"r"(lsw), "r"(msw)
+                        :"$1", "$8");
+
+        disable_KX(flags);
+        value = hi;
+        value = (uint64_t) ((value<<32) | lo);
+        return (value);
+}
+
+#endif // #ifdef CONFIG_64BIT
+static __inline__ void nlm_hal_pic_send_ipi(int nmi, int vec, int node, int cpu)
+{
+	pic_reg_t *mmio = nlm_hal_pic_offset();
+
+	unsigned long long ipi = (nmi << 31) | (vec << 20) | (node << 17) | (1 << (cpu & 0xf));
+	if (cpu > 15) {
+		ipi |= 0x10000; // Setting bit 16 to select cpus 16-31
+	}
+
+	nlm_hal_write_pic_reg(mmio, PIC_IPI_CTL, ipi);
+}
+
+static __inline__ unsigned long long nlm_hal_pic_read_control(void)
+{
+	pic_reg_t *mmio = nlm_hal_pic_offset();
+
+	return nlm_hal_read_pic_reg(mmio, PIC_CTRL);
+}
+
+static __inline__ void nlm_hal_pic_write_control(unsigned long long control)
+{
+	pic_reg_t *mmio = nlm_hal_pic_offset();
+
+	nlm_hal_write_pic_reg(mmio, PIC_CTRL, control);
+}
+
+static __inline__ void nlm_hal_pic_update_control(unsigned long long control)
+{
+	pic_reg_t *mmio = nlm_hal_pic_offset();
+
+	nlm_hal_write_pic_reg(mmio, PIC_CTRL, (control | nlm_hal_read_pic_reg(mmio, PIC_CTRL)));
+}
+
+static __inline__ void nlm_hal_ack_pic(int irt_num)
+{
+	pic_reg_t *mmio = nlm_hal_pic_offset();
+
+	nlm_hal_write_pic_reg(mmio, PIC_INT_ACK, irt_num);
+
+	/* Ack the Status register for Watchdog & System timers */
+	if (irt_num < 12) {
+		nlm_hal_write_pic_reg(mmio, PIC_STATUS, (1 << irt_num));
+	}
+}
+
+static __inline__ unsigned long long nlm_hal_pic_read_irt(int irt_num)
+{
+	pic_reg_t *mmio = nlm_hal_pic_offset();
+
+	return nlm_hal_read_pic_reg(mmio, PIC_IRT(irt_num));
+}
+
+static __inline__ void nlm_hal_pic_write_irt(int irt_num, int en, int nmi, int sch, int vec, int dt, int db, int dte)
+{
+	pic_reg_t *mmio = nlm_hal_pic_offset();
+
+	unsigned long long val = (((en & 0x1) << 31) | ((nmi & 0x1) << 29) | ((sch & 0x1) << 28) |
+				  ((vec & 0x3f) << 20) | ((dt & 0x1 ) << 19) | ((db & 0x7) << 16) |
+				  (dte & 0xffff));
+
+	nlm_hal_write_pic_reg(mmio, PIC_IRT(irt_num), val);
+}
+
+#define CPUIDBITS01(X) ((X) & 0x3)
+#define CPUIDBIT2(X) ((X >> 2) & 0x1)
+
+static __inline__ void nlm_hal_pic_write_irt_direct(int irt_num, int en, int nmi, int sch, int vec, int cpu)
+{
+	nlm_hal_pic_write_irt(irt_num, en, nmi, sch, vec, 1, CPUIDBIT2(cpu), CPUIDBITS01(cpu));
+	/* Does not support multi node support yet */
+}
+
+static __inline__ unsigned long long nlm_hal_pic_read_timer(int timer)
+{
+	pic_reg_t *mmio = nlm_hal_pic_offset();
+
+	return nlm_hal_read_pic_reg(mmio, PIC_SYS_TIMER_COUNTER(timer));
+}
+
+static __inline__ void nlm_hal_pic_write_timer(int timer, pic_reg_t value)
+{
+	pic_reg_t *mmio = nlm_hal_pic_offset();
+
+	nlm_hal_write_pic_reg(mmio, PIC_SYS_TIMER_COUNTER(timer), value);
+}
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* _NLM_HAL_PIC_H */
diff --git a/arch/mips/include/asm/netlogic/hal/nlm_hal_rsa.h b/arch/mips/include/asm/netlogic/hal/nlm_hal_rsa.h
new file mode 100644
index 0000000..c68e391
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/hal/nlm_hal_rsa.h
@@ -0,0 +1,955 @@
+/*********************************************************************
+
+  Copyright 2003-2010 Netlogic Microsystem, Inc. ("Netlogic"). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#NLM_2#**********************************/
+#ifndef _NLM_HAL_RSA_H
+#define _NLM_HAL_RSA_H
+static uint64_t  nlm_rsa_ucode_data [] = {
+0x0000000000000000ULL,
+0x00000000503840ecULL,
+0x00000001903800ecULL,
+0x00000002c03820ecULL,
+0x0000003760000044ULL,
+0x0000000000000014ULL,
+0x000000071000000cULL,
+0x00000007d000010cULL,
+0x0000001b80000c0cULL,
+0x00000000e03fc0ecULL,
+0x00000001103fc1ecULL,
+0x00000001403f42ecULL,
+0x00000001403fc4ecULL,
+0x0000003760000044ULL,
+0x000000001800003cULL,
+0x0000000d8000030cULL,
+0x0000000630000044ULL,
+0x000000002800003cULL,
+0x0000000ef000030cULL,
+0x0000000630000044ULL,
+0x00000000503fc23cULL,
+0x00000000a03fc33cULL,
+0x00000001403fc43cULL,
+0x00000010c000030cULL,
+0x0000000630000044ULL,
+0x0000000000000014ULL,
+0x000000071000000cULL,
+0x0000001c1000070cULL,
+0x0000002500000d0cULL,
+0x00000027c0000e0cULL,
+0x0000002d60000f0cULL,
+0x00000002603f00ecULL,
+0x00000002603f82ecULL,
+0x00000002803f83ecULL,
+0x00000002803f04ecULL,
+0x00000002a03f06ecULL,
+0x00000002a03f88ecULL,
+0x0000003760000044ULL,
+0x000000086000010cULL,
+0x00000003f0000044ULL,
+0x00000008d000010cULL,
+0x00000004b0000044ULL,
+0x00000008d000010cULL,
+0x0000000570000044ULL,
+0x000000000000001cULL,
+0x000000076000000cULL,
+0x0000001c1000070cULL,
+0x0000002690000d0cULL,
+0x0000002990000e0cULL,
+0x0000002e10000f0cULL,
+0x00000003903f20ecULL,
+0x00000003903fa2ecULL,
+0x00000003b03fa3ecULL,
+0x00000003b03f24ecULL,
+0x00000003d03f26ecULL,
+0x00000003d03fa8ecULL,
+0x0000003760000044ULL,
+0x000000096000010cULL,
+0x00000003f0000044ULL,
+0x0000000a0000010cULL,
+0x00000004b0000044ULL,
+0x0000000a0000010cULL,
+0x0000000570000044ULL,
+0x000000000800003cULL,
+0x0000000af000020cULL,
+0x0000000bc000030cULL,
+0x000000129000040cULL,
+0x000000178000050cULL,
+0x000000191000060cULL,
+0x0000001ff000080cULL,
+0x000000205000090cULL,
+0x00000022c0000a0cULL,
+0x00000020b0000b0cULL,
+0x0000001ac0000c0cULL,
+0x0000000680000044ULL,
+0x000000001000003cULL,
+0x0000000b5000020cULL,
+0x0000000c5000030cULL,
+0x000000137000040cULL,
+0x00000017e000050cULL,
+0x000000197000060cULL,
+0x000000200000080cULL,
+0x000000206000090cULL,
+0x0000002340000a0cULL,
+0x0000002110000b0cULL,
+0x0000001b10000c0cULL,
+0x0000000680000044ULL,
+0x000000001800003cULL,
+0x0000000b5000020cULL,
+0x0000000d8000030cULL,
+0x000000154000040cULL,
+0x000000187000050cULL,
+0x0000001a0000060cULL,
+0x000000202000080cULL,
+0x000000208000090cULL,
+0x0000002410000a0cULL,
+0x00000021c0000b0cULL,
+0x0000001b80000c0cULL,
+0x0000000680000044ULL,
+0x000000000000000aULL,
+0x0000000000000024ULL,
+0x0000002ed01f80e4ULL,
+0x00000030101f81e4ULL,
+0x0000003760000044ULL,
+0x000000000000000aULL,
+0x0000000000000024ULL,
+0x00000030d01f00e4ULL,
+0x00000030d01f82e4ULL,
+0x00000034801f83e4ULL,
+0x00000035401e04e4ULL,
+0x00000037101f88e4ULL,
+0x00000035401f89e4ULL,
+0x0000003760000044ULL,
+0x0000000000000074ULL,
+0x0000000f0000008cULL,
+0x00000008000000a4ULL,
+0x000000080400007bULL,
+0x00000000000000c4ULL,
+0x0000000000000074ULL,
+0x0000000c000000a4ULL,
+0x0000000004004071ULL,
+0x0000000b0000008cULL,
+0x00000008000000a4ULL,
+0x000000080400007bULL,
+0x00000000000000c4ULL,
+0x000000034c0b4091ULL,
+0x0000000b040b0093ULL,
+0x0000000000000000ULL,
+0x0000000004000802ULL,
+0x00000002c88b0021ULL,
+0x0000000a828b0423ULL,
+0x00000010000000a4ULL,
+0x000000081000006cULL,
+0x00000000000000c4ULL,
+0x000000004c0b4091ULL,
+0x00000008000000a4ULL,
+0x0000000002000402ULL,
+0x000000004a8b0021ULL,
+0x00000010000000a4ULL,
+0x000000089000006cULL,
+0x00000000000000c4ULL,
+0x000000034c0b4091ULL,
+0x0000000b040b0093ULL,
+0x00000008000000a4ULL,
+0x0000000002000402ULL,
+0x00000002c88b0021ULL,
+0x0000000a828b0423ULL,
+0x00000010000000a4ULL,
+0x000000091000006cULL,
+0x00000000000000c4ULL,
+0x000000004c0b4091ULL,
+0x00000008000000a4ULL,
+0x0000000002000402ULL,
+0x000000004a8b0021ULL,
+0x00000010000000a4ULL,
+0x0000000990000064ULL,
+0x000000004a8b0021ULL,
+0x0000000000898611ULL,
+0x0000000c000000a4ULL,
+0x00000000000000c4ULL,
+0x000000034c0b4091ULL,
+0x0000000b040b0093ULL,
+0x00000008000000a4ULL,
+0x0000000002000402ULL,
+0x00000002c88b0021ULL,
+0x0000000a828b0423ULL,
+0x00000010000000a4ULL,
+0x0000000a40000064ULL,
+0x0000000088800021ULL,
+0x0000000880800423ULL,
+0x00000000001004a1ULL,
+0x0000000c000000a4ULL,
+0x00000002c88b0061ULL,
+0x0000000a808b0463ULL,
+0x00000000000000c4ULL,
+0x00000000058f0011ULL,
+0x0000000001860002ULL,
+0x00000010000000a4ULL,
+0x00000000000000ccULL,
+0x000000004d8f0021ULL,
+0x0000000b10000044ULL,
+0x00000007058f0013ULL,
+0x0000000001860002ULL,
+0x00000010000000a4ULL,
+0x00000000000000ccULL,
+0x000000034c0f0021ULL,
+0x0000000b058f0423ULL,
+0x0000000b70000044ULL,
+0x0000000000180001ULL,
+0x000000000b600031ULL,
+0x00000008000000a4ULL,
+0x0000000004800041ULL,
+0x00000008000000a4ULL,
+0x0000000007c03f41ULL,
+0x00000000440ac491ULL,
+0x00000004000000a4ULL,
+0x00000000000000c4ULL,
+0x0000000010180001ULL,
+0x0000000088a00031ULL,
+0x00000002c3430431ULL,
+0x00000004000000a4ULL,
+0x0000000204938041ULL,
+0x00000008000000a4ULL,
+0x000000012c002b41ULL,
+0x0000000117982861ULL,
+0x0000000088a03631ULL,
+0x00000002c3430c31ULL,
+0x00000004000000a4ULL,
+0x0000000204938041ULL,
+0x00000008000000a4ULL,
+0x000000012c002b41ULL,
+0x0000000347cb2861ULL,
+0x000000034c09f691ULL,
+0x00000003040a8491ULL,
+0x0000000000000000ULL,
+0x00000000000000c4ULL,
+0x0000000010180001ULL,
+0x0000000088a00031ULL,
+0x00000002c0830431ULL,
+0x0000000283430431ULL,
+0x000000080000009cULL,
+0x0000000204938041ULL,
+0x00000008000000a4ULL,
+0x000000012c002b41ULL,
+0x0000000104202861ULL,
+0x0000000117d82861ULL,
+0x0000000088a02f31ULL,
+0x00000002c0833c31ULL,
+0x0000002283430c3bULL,
+0x0000000000000000ULL,
+0x0000000204938041ULL,
+0x00000008000000a4ULL,
+0x000000012c002b41ULL,
+0x00000003442b2861ULL,
+0x0000000307cb2861ULL,
+0x000000034c09ef91ULL,
+0x000000030409bc91ULL,
+0x00000003040a8491ULL,
+0x00000000000000c4ULL,
+0x0000000010180001ULL,
+0x0000000088a00031ULL,
+0x00000002c0830431ULL,
+0x0000000280830431ULL,
+0x0000000280c30431ULL,
+0x0000000004900041ULL,
+0x0000000283430531ULL,
+0x0000000a00038007ULL,
+0x0000000000000000ULL,
+0x000000012c002b41ULL,
+0x0000000344202861ULL,
+0x0000001304032863ULL,
+0x0000000317db2861ULL,
+0x00000000b8a02b31ULL,
+0x00000002c0832831ULL,
+0x0000000280832831ULL,
+0x0000000280c33c31ULL,
+0x0000000004900041ULL,
+0x0000002e83430d3bULL,
+0x0000000200038000ULL,
+0x0000000000000000ULL,
+0x000000012c002b41ULL,
+0x00000003442b2861ULL,
+0x00000013040b2863ULL,
+0x0000000307cb2861ULL,
+0x000000037c09eb91ULL,
+0x000000130409a893ULL,
+0x000000030409bc91ULL,
+0x00000003040a849dULL,
+0x0000000010180001ULL,
+0x0000000088a00031ULL,
+0x00000002c0830431ULL,
+0x0000000280830431ULL,
+0x0000000280c30431ULL,
+0x0000000004900041ULL,
+0x0000000280830531ULL,
+0x0000001e80830433ULL,
+0x0000000283430431ULL,
+0x0000000b2c03ab67ULL,
+0x0000000344202861ULL,
+0x0000001304032863ULL,
+0x0000000317db2861ULL,
+0x00000002b8a3ab31ULL,
+0x00000002c0832831ULL,
+0x0000000280832831ULL,
+0x0000000280c32831ULL,
+0x0000000004900041ULL,
+0x0000000280832931ULL,
+0x0000001e80832833ULL,
+0x0000002e83430c3bULL,
+0x000000032c03ab61ULL,
+0x00000003442b2861ULL,
+0x00000013040b2863ULL,
+0x0000000307cb2861ULL,
+0x000000037c09eb91ULL,
+0x000000130409a893ULL,
+0x000000030409bc91ULL,
+0x00000003040a849dULL,
+0x0000000000140001ULL,
+0x0000004000140001ULL,
+0x000000000b600061ULL,
+0x000000400b600061ULL,
+0x00000004000000a4ULL,
+0x0000000004800041ULL,
+0x0000004004800041ULL,
+0x00000004000000a4ULL,
+0x0000000007c03f41ULL,
+0x0000004007c03f41ULL,
+0x00000000440ac591ULL,
+0x00000040440ac591ULL,
+0x0000000000000000ULL,
+0x00000000000000c4ULL,
+0x0000000010140001ULL,
+0x0000004010140001ULL,
+0x0000000088e00061ULL,
+0x0000004088e00061ULL,
+0x00000002c3430561ULL,
+0x00000042c3430561ULL,
+0x0000000204938041ULL,
+0x0000004204938041ULL,
+0x00000004000000a4ULL,
+0x000000012c402b41ULL,
+0x000000412c402b41ULL,
+0x0000000117f42961ULL,
+0x0000004117f42961ULL,
+0x0000000088e03f61ULL,
+0x0000004088e03f61ULL,
+0x00000002c3430d61ULL,
+0x00000042c3430d61ULL,
+0x0000000204938041ULL,
+0x0000004204938041ULL,
+0x00000004000000a4ULL,
+0x000000012c402b41ULL,
+0x000000412c402b41ULL,
+0x0000000347eb2961ULL,
+0x0000004347eb2961ULL,
+0x000000034c7dff91ULL,
+0x000000434c7dff91ULL,
+0x00000003040a0591ULL,
+0x00000043040a0591ULL,
+0x00000000000000c4ULL,
+0x0000000010140001ULL,
+0x0000004010140001ULL,
+0x0000000088e00061ULL,
+0x0000004088e00061ULL,
+0x00000002c0c30561ULL,
+0x00000042c0c30561ULL,
+0x0000000004900041ULL,
+0x0000004004900041ULL,
+0x0000000283430561ULL,
+0x0000004283430561ULL,
+0x0000000b2c43ab47ULL,
+0x000000432c43ab41ULL,
+0x0000000344602961ULL,
+0x0000004344602961ULL,
+0x0000000317d72961ULL,
+0x0000004317d72961ULL,
+0x00000002b8e3ab61ULL,
+0x00000042b8e3ab61ULL,
+0x00000002c0c32961ULL,
+0x00000042c0c32961ULL,
+0x0000000004900041ULL,
+0x0000004004900041ULL,
+0x0000000283430d61ULL,
+0x0000007683430d6bULL,
+0x000000032c43ab41ULL,
+0x000000432c43ab41ULL,
+0x00000003446b2961ULL,
+0x00000043446b2961ULL,
+0x0000000307cb2961ULL,
+0x0000004307cb2961ULL,
+0x000000037c7de791ULL,
+0x000000437c7de791ULL,
+0x0000000304499d91ULL,
+0x0000004304499d91ULL,
+0x00000003040a0591ULL,
+0x00000043040a059dULL,
+0x0000000048840011ULL,
+0x00000000028b3691ULL,
+0x000000000e09c691ULL,
+0x000000000c09c691ULL,
+0x0000000000000000ULL,
+0x00000000000000c4ULL,
+0x00000000c8840011ULL,
+0x0000000212ab3691ULL,
+0x0000000080800411ULL,
+0x0000000002cb3691ULL,
+0x000000034c29ef91ULL,
+0x0000000006098491ULL,
+0x000000034c09ef91ULL,
+0x0000000004098491ULL,
+0x00000000000000c4ULL,
+0x00000000e8840011ULL,
+0x0000000210ab3a91ULL,
+0x0000000880800415ULL,
+0x00000006128b3699ULL,
+0x000000034c29eb91ULL,
+0x0000000f0409a893ULL,
+0x0000000026098891ULL,
+0x000000034c09eb91ULL,
+0x0000000f0409a893ULL,
+0x000000000409849dULL,
+0x0000000048841011ULL,
+0x00000000068b7691ULL,
+0x000000000e099611ULL,
+0x000000000c098611ULL,
+0x0000000000000000ULL,
+0x00000000000000c4ULL,
+0x00000000c8840011ULL,
+0x0000000216ab7691ULL,
+0x0000000080801411ULL,
+0x0000000006cb3691ULL,
+0x000000034c29af11ULL,
+0x0000000006099411ULL,
+0x000000034c09af11ULL,
+0x0000000004098411ULL,
+0x00000000000000c4ULL,
+0x00000000e8840011ULL,
+0x0000000214ab7a91ULL,
+0x0000000c80800415ULL,
+0x00000006168b3699ULL,
+0x0000000080801411ULL,
+0x00000002168b3691ULL,
+0x000000034c29ab11ULL,
+0x0000000f0409a813ULL,
+0x0000000026099811ULL,
+0x000000034c09ab11ULL,
+0x0000000f0409a813ULL,
+0x000000000409841dULL,
+0x0000000c000000d4ULL,
+0x0000000000000000ULL,
+0x000000004a801011ULL,
+0x000000000e004691ULL,
+0x000000000009800dULL,
+0x0000000c000000d4ULL,
+0x000000004a801011ULL,
+0x000000018c004691ULL,
+0x0000000000800411ULL,
+0x0000000006003691ULL,
+0x0000000200098001ULL,
+0x000000000009800dULL,
+0x0000000c000000d4ULL,
+0x000000004a801011ULL,
+0x000000018c004691ULL,
+0x0000000c00800415ULL,
+0x0000000584003699ULL,
+0x0000000000800411ULL,
+0x0000000006003691ULL,
+0x0000000a00098003ULL,
+0x000000000009800dULL,
+0x000000200000302aULL,
+0x00000000000e0012ULL,
+0x0000000000100211ULL,
+0x0000000002000002ULL,
+0x00000006000b0003ULL,
+0x0000000000000000ULL,
+0x00000000000000ccULL,
+0x0000000006000302ULL,
+0x00000002810b0011ULL,
+0x0000000a808b0013ULL,
+0x0000000002010002ULL,
+0x00000006108b0093ULL,
+0x0000000002800002ULL,
+0x00000007040b0013ULL,
+0x0000000006800002ULL,
+0x00000007040b0013ULL,
+0x0000000003000002ULL,
+0x0000000000090101ULL,
+0x0000000200098001ULL,
+0x0000000a000b0003ULL,
+0x0000000007000302ULL,
+0x0000000400890015ULL,
+0x0000000784098019ULL,
+0x0000000007800002ULL,
+0x0000000000090001ULL,
+0x0000000000098101ULL,
+0x0000001dd000006cULL,
+0x000000280300060aULL,
+0x0000000000000000ULL,
+0x0000000000000e02ULL,
+0x0000000001000011ULL,
+0x00000010000000a4ULL,
+0x0000001dc0000064ULL,
+0x0000000000000f02ULL,
+0x0000000001000011ULL,
+0x0000000002000602ULL,
+0x0000000680890013ULL,
+0x0000000002806002ULL,
+0x0000000004000011ULL,
+0x000000031489f691ULL,
+0x0000000804000415ULL,
+0x000000071489b699ULL,
+0x0000000006000e02ULL,
+0x0000000680890013ULL,
+0x0000000006800e02ULL,
+0x0000000680898013ULL,
+0x0000002c0300540aULL,
+0x0000000007800012ULL,
+0x00000000000b8000ULL,
+0x000000000700cd42ULL,
+0x0000000000800011ULL,
+0x000000029489f691ULL,
+0x0000000800800415ULL,
+0x000000069489b699ULL,
+0x000000200000e02aULL,
+0x00000000000000fcULL,
+0x0000000c000000a4ULL,
+0x0000001dc0000064ULL,
+0x000000240000c02aULL,
+0x0000000002000012ULL,
+0x0000000600090003ULL,
+0x00000000000000c4ULL,
+0x000000001680409dULL,
+0x0000000014804091ULL,
+0x000000001680049dULL,
+0x0000000014804091ULL,
+0x0000000014800491ULL,
+0x000000001680049dULL,
+0x000000001680419dULL,
+0x0000000014804191ULL,
+0x000000001680049dULL,
+0x0000000014804191ULL,
+0x0000000014800491ULL,
+0x000000001680049dULL,
+0x0000000000800011ULL,
+0x00000000068b5691ULL,
+0x0000000004098611ULL,
+0x000000000700dc22ULL,
+0x0000000000800011ULL,
+0x0000000296cb569dULL,
+0x0000000000800011ULL,
+0x0000000294ab7691ULL,
+0x0000000000801411ULL,
+0x00000000068b3691ULL,
+0x000000034409af11ULL,
+0x0000000004098411ULL,
+0x000000000700dc22ULL,
+0x0000000000800011ULL,
+0x00000002948b7691ULL,
+0x0000000000801411ULL,
+0x0000000296cb369dULL,
+0x0000000000800011ULL,
+0x0000000294ab7691ULL,
+0x0000000000800411ULL,
+0x00000002948b3691ULL,
+0x0000000000801411ULL,
+0x00000000068b3a91ULL,
+0x000000034409ab11ULL,
+0x000000030409a411ULL,
+0x0000000004098411ULL,
+0x000000000700dc22ULL,
+0x0000000000800011ULL,
+0x00000002948b7691ULL,
+0x0000000000800411ULL,
+0x00000002948b3691ULL,
+0x0000000000801411ULL,
+0x0000000296cb369dULL,
+0x0000000001000011ULL,
+0x0000000006098611ULL,
+0x0000000000000000ULL,
+0x0000000007000e02ULL,
+0x0000000000888061ULL,
+0x0000000003000602ULL,
+0x0000000000888061ULL,
+0x00000000000984edULL,
+0x0000000001000011ULL,
+0x0000000b8409b615ULL,
+0x0000000400800419ULL,
+0x000000000609b611ULL,
+0x0000000007000e02ULL,
+0x0000000080800061ULL,
+0x0000000200cb0461ULL,
+0x00000000000b8000ULL,
+0x0000000003000602ULL,
+0x0000000080800061ULL,
+0x0000000200cb0461ULL,
+0x00000000000b8001ULL,
+0x00000000000985edULL,
+0x0000000001000011ULL,
+0x0000000b8409b615ULL,
+0x0000000400800419ULL,
+0x000000000609b611ULL,
+0x0000000007000e02ULL,
+0x0000000080800061ULL,
+0x00000002808b0461ULL,
+0x0000000200cb0461ULL,
+0x00000000000b8000ULL,
+0x0000000003000602ULL,
+0x0000000080800061ULL,
+0x00000002808b0461ULL,
+0x0000000200cb0461ULL,
+0x00000000000b8001ULL,
+0x00000000000985edULL,
+0x0000000002800002ULL,
+0x000000500220220aULL,
+0x000000140606550aULL,
+0x000000140606c50aULL,
+0x0000000002a01202ULL,
+0x000000500680100aULL,
+0x000000140286550aULL,
+0x000000000300d502ULL,
+0x000000500220340aULL,
+0x000000140306660aULL,
+0x000000140686c40aULL,
+0x000000140206660aULL,
+0x000000000600dd02ULL,
+0x000000500720550aULL,
+0x0000001806064c0aULL,
+0x000000180306c60aULL,
+0x0000000002001102ULL,
+0x000000500020c50aULL,
+0x000000000600e402ULL,
+0x000000500220440aULL,
+0x000000140606cc0aULL,
+0x000000000320d602ULL,
+0x000000500100e50aULL,
+0x000000180086c60aULL,
+0x00000000000000c4ULL,
+0x0000000002000002ULL,
+0x0000005002a0210aULL,
+0x000000140280540aULL,
+0x0000000003005502ULL,
+0x000000500620200aULL,
+0x000000140680c50aULL,
+0x0000000002004402ULL,
+0x0000005003a0cc0aULL,
+0x0000000002a03702ULL,
+0x000000500700c50aULL,
+0x000000140280650aULL,
+0x000000140280e50aULL,
+0x000000000000c502ULL,
+0x000000500120c70aULL,
+0x000000000200c402ULL,
+0x0000005000a0d50aULL,
+0x0000000000000000ULL,
+0x000000140080410aULL,
+0x00000000000000c4ULL,
+0x0000000006009202ULL,
+0x000000500220a10aULL,
+0x0000001806064c0aULL,
+0x0000000002808202ULL,
+0x0000005006a0a00aULL,
+0x000000180706d50aULL,
+0x000000000320cc02ULL,
+0x000000500280ee0aULL,
+0x0000000006a0d502ULL,
+0x000000500780a20aULL,
+0x000000140386dd0aULL,
+0x000000000300f602ULL,
+0x0000005002a0e50aULL,
+0x000000180306560aULL,
+0x0000000000000000ULL,
+0x000000180306760aULL,
+0x0000001806866d0aULL,
+0x000000000380f502ULL,
+0x0000005007a0450aULL,
+0x000000300281070aULL,
+0x000000200000502aULL,
+0x00000000000000fcULL,
+0x0000000c000000a4ULL,
+0x0000002bc000006cULL,
+0x000000000600dc02ULL,
+0x000000500020e60aULL,
+0x000000180086fc0aULL,
+0x000000140107170aULL,
+0x00000000000000c4ULL,
+0x000000000200a102ULL,
+0x000000500620920aULL,
+0x000000140600c40aULL,
+0x000000000200a002ULL,
+0x0000005006a0820aULL,
+0x000000140680d40aULL,
+0x000000140200dc0aULL,
+0x000000000700a202ULL,
+0x0000005002a0dd0aULL,
+0x000000000300c402ULL,
+0x0000005003a0350aULL,
+0x0000000000000000ULL,
+0x000000140300670aULL,
+0x000000000380d502ULL,
+0x0000005007a0e60aULL,
+0x0000000000000000ULL,
+0x0000001407807f0aULL,
+0x000000000380d102ULL,
+0x000000500320c00aULL,
+0x0000000000000000ULL,
+0x000000140380760aULL,
+0x0000000003007502ULL,
+0x0000005002a0d50aULL,
+0x000000000200f402ULL,
+0x0000005003a0e50aULL,
+0x000000300281070aULL,
+0x000000200000502aULL,
+0x00000000000000fcULL,
+0x0000000c000000a4ULL,
+0x0000002bc000006cULL,
+0x000000000000df02ULL,
+0x0000005000a0a60aULL,
+0x000000140101170aULL,
+0x000000140080410aULL,
+0x00000000000000c4ULL,
+0x000000300281020aULL,
+0x0000003006810a0aULL,
+0x0000003006010c0aULL,
+0x000000200000202aULL,
+0x00000000000000fcULL,
+0x0000000c000000a4ULL,
+0x0000002d1000006cULL,
+0x000000200000a02aULL,
+0x00000000000000fcULL,
+0x0000000c000000a4ULL,
+0x0000002d5000006cULL,
+0x000000200000c02aULL,
+0x00000000000000fcULL,
+0x0000000c000000a4ULL,
+0x0000002cd0000064ULL,
+0x00000034000000d4ULL,
+0x00000000000000c4ULL,
+0x0000000001000002ULL,
+0x00000006000b0003ULL,
+0x0000000000000000ULL,
+0x00000000000000c4ULL,
+0x000000140001180aULL,
+0x000000140081190aULL,
+0x0000001401011a0aULL,
+0x00000000000000c4ULL,
+0x00000000000000c4ULL,
+0x0000000001810302ULL,
+0x0000005005a10b0aULL,
+0x0000000002000002ULL,
+0x000000500620110aULL,
+0x000000140206340aULL,
+0x000000180606cb0aULL,
+0x0000000002000402ULL,
+0x0000005006210c0aULL,
+0x000000140206c40aULL,
+0x000000300201040aULL,
+0x00000000000000c4ULL,
+0x0000000002801002ULL,
+0x0000005005a10b0aULL,
+0x000000140286b50aULL,
+0x000000140186300aULL,
+0x0000000002000002ULL,
+0x000000500620110aULL,
+0x000000140606c50aULL,
+0x0000000002003402ULL,
+0x0000005006210c0aULL,
+0x000000140206c40aULL,
+0x000000300201040aULL,
+0x00000000000000c4ULL,
+0x000000040400000aULL,
+0x000000000000002cULL,
+0x0000000c0000800eULL,
+0x0000000c0400880aULL,
+0x000000080000007cULL,
+0x0000000004000002ULL,
+0x00000006808b0013ULL,
+0x0000000000000034ULL,
+0x0000000000000002ULL,
+0x0000002ff000005cULL,
+0x0000002f4000004cULL,
+0x00000002000b0101ULL,
+0x0000000a000b0003ULL,
+0x0000003760000044ULL,
+0x0000000000000034ULL,
+0x0000000c0000000aULL,
+0x0000002ff0000054ULL,
+0x0000000c0000800aULL,
+0x0000002fb000004cULL,
+0x0000003640000044ULL,
+0x0000000c0000800aULL,
+0x000000040400000aULL,
+0x000000000000002cULL,
+0x0000000c0000800eULL,
+0x0000000c0400880aULL,
+0x000000080000007cULL,
+0x000000040400000aULL,
+0x000000000000002cULL,
+0x0000000c0000800eULL,
+0x0000000c0400880aULL,
+0x000000080000007cULL,
+0x0000003640000044ULL,
+0x000000080180000aULL,
+0x0000000001820002ULL,
+0x00000007040b0013ULL,
+0x000000040200000aULL,
+0x000000000000002cULL,
+0x0000000c0180430eULL,
+0x0000000c0200440aULL,
+0x000000080000007cULL,
+0x0000000001010002ULL,
+0x00000006108b0093ULL,
+0x0000000005010002ULL,
+0x00000006108b0093ULL,
+0x0000000000000000ULL,
+0x00000032e01f80e4ULL,
+0x00000034401f81e4ULL,
+0x00000034601f82e4ULL,
+0x0000000c0181020aULL,
+0x0000000c0181030aULL,
+0x0000001c000000d4ULL,
+0x0000000000004002ULL,
+0x0000005000a0410aULL,
+0x0000000001004202ULL,
+0x000000500021000aULL,
+0x0000000000810102ULL,
+0x000000500121020aULL,
+0x000000200000202aULL,
+0x00000000000000fcULL,
+0x0000000c000000a4ULL,
+0x0000000000000002ULL,
+0x0000000600098003ULL,
+0x0000000000810002ULL,
+0x0000000610898093ULL,
+0x0000003760000044ULL,
+0x0000000004000002ULL,
+0x00000006808b0013ULL,
+0x0000000004800102ULL,
+0x00000006808b0013ULL,
+0x0000000005000202ULL,
+0x00000006808b0013ULL,
+0x0000000000000034ULL,
+0x0000000000000002ULL,
+0x000000342000005cULL,
+0x000000334000004cULL,
+0x0000001000000084ULL,
+0x00000006000b0009ULL,
+0x00000002000b0101ULL,
+0x0000002000000084ULL,
+0x00000006000b0009ULL,
+0x0000003760000044ULL,
+0x0000000000000034ULL,
+0x00000034000000d4ULL,
+0x0000003420000054ULL,
+0x00000038000000d4ULL,
+0x00000033e000004cULL,
+0x00000031d0000044ULL,
+0x00000038000000d4ULL,
+0x00000031d0000044ULL,
+0x00000034000000d4ULL,
+0x00000031d0000044ULL,
+0x000000080180000aULL,
+0x0000000001820002ULL,
+0x00000007040b0013ULL,
+0x0000000005840002ULL,
+0x00000007040b0013ULL,
+0x0000003c000000d4ULL,
+0x00000004000000a4ULL,
+0x000000200000402aULL,
+0x0000000000000012ULL,
+0x00000000000b0001ULL,
+0x0000000000098101ULL,
+0x0000003760000044ULL,
+0x000000040200000aULL,
+0x000000000000002cULL,
+0x0000000c0000400eULL,
+0x0000000c0200440aULL,
+0x000000080000007cULL,
+0x00000036c01f87e4ULL,
+0x00000036401f89e4ULL,
+0x000000040200000aULL,
+0x000000000000002cULL,
+0x0000000c0400480eULL,
+0x0000000c0200440aULL,
+0x000000080000007cULL,
+0x00000036a01f86e4ULL,
+0x000000080180000aULL,
+0x00000036601f84e4ULL,
+0x00000036801f85e4ULL,
+0x000000300001000aULL,
+0x0000003760000044ULL,
+0x000000140006800aULL,
+0x0000003640000044ULL,
+0x000000180006800aULL,
+0x0000003640000044ULL,
+0x0000000c0000800aULL,
+0x0000003640000044ULL,
+0x0000000c0181080aULL,
+0x0000001c000000d4ULL,
+0x00000004000000a4ULL,
+0x0000000c0000400aULL,
+0x0000003640000044ULL,
+0x0000000c0181000aULL,
+0x0000001c000000d4ULL,
+0x00000004000000a4ULL,
+0x000000140001140aULL,
+0x0000003640000044ULL,
+0x0000000c000000a4ULL,
+0x0000000000000044ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+0x0000000000000000ULL,
+};
+
+#endif				//#ifndef _NLM_HAL_RSA_H_
diff --git a/arch/mips/include/asm/netlogic/hal/nlm_hal_sys.h b/arch/mips/include/asm/netlogic/hal/nlm_hal_sys.h
index aa52a06..8d440c4 100644
--- a/arch/mips/include/asm/netlogic/hal/nlm_hal_sys.h
+++ b/arch/mips/include/asm/netlogic/hal/nlm_hal_sys.h
@@ -1,27 +1,32 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (``Netlogic''). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
 #ifndef _NLH_SYS_H
 #define _NLH_SYS_H
 #if !defined(__KERNEL__) && !defined(NLM_HAL_UBOOT)
@@ -32,8 +37,13 @@ THE POSSIBILITY OF SUCH DAMAGE.
 
 /* TODO: Griffin support for different REFCLKs. */
 /* 133.333 MHz Reference Clock */
-#define REF_CLK_NUM 400000000ULL
-#define REF_CLK_DEN 3ULL
+#define REF_CLK_NUM_400 400000000ULL
+#define REF_CLK_NUM_200 200000000ULL
+#define REF_CLK_NUM_125 125000000ULL
+#define REF_CLK_NUM_100 100000000ULL
+#define REF_CLK_DEN  3
+#define REF_CLK_DEN3 3
+#define REF_CLK_DEN1 1
 
 /* 1 MHz resolution for frequency setting */
 #define FREQ_RESOLUTION 1000000ULL
@@ -56,13 +66,80 @@ typedef enum soc_dfs_device {
 	DFS_DEVICE_NAND   = 7,
 	DFS_DEVICE_MMC    = 8,
 	DFS_DEVICE_NOR    = 9,
-	DFS_DEVICE_CORE   = 10,
-	DFS_DEVICE_REGEX_SLOW    = 11, /*xlp3xx only*/
-	DFS_DEVICE_REGEX_FAST    = 12, /*xlp3xx only*/
-	DFS_DEVICE_SATA          = 13, /*xlp3xx only*/
+	DFS_DEVICE_CORE   = 10, /*0xA*/
+	DFS_DEVICE_REGEX_SLOW    = 11, /*xlp3xx only 0xB*/
+	DFS_DEVICE_REGEX_FAST    = 12, /*xlp3xx only 0xC*/
+	DFS_DEVICE_SATA          = 13, /*xlp3xx only 0xD*/
+
+	XLP2XX_CLKDEVICE_NAE	= 0x10,
+	XLP2XX_CLKDEVICE_SAE	= 0x11,
+	XLP2XX_CLKDEVICE_RSA	= 0x12,
+	XLP2XX_CLKDEVICE_GDX	= 0x13,
+	XLP2XX_CLKDEVICE_CMP	= 0x14,
+	XLP2XX_CLKDEVICE_NAND	= 0x15,
+	XLP2XX_CLKDEVICE_MMC	= 0x16,
+	XLP2XX_CLKDEVICE_GBU	= 0x17,
+	XLP2XX_CLKDEVICE_RGXF	= 0x18,
+	XLP2XX_CLKDEVICE_RGXS	= 0x19,
+	XLP2XX_CLKDEVICE_USB	= 0x1a,
+	XLP2XX_CLKDEVICE_PIC	= 0x1b,
+	XLP2XX_CLKDEVICE_NULL	= 0x1c,
+
 	INVALID_DFS_DEVICE = 0xFF
 } soc_device_id_t;
 
+typedef struct xlp2xx_soc_freq_t {
+        uint32_t nae;
+        uint32_t sae;
+        uint32_t rsa;
+        uint32_t gdx;
+        uint32_t cmp;
+        uint32_t nand;
+        uint32_t mmc;
+        uint32_t gbu;
+        uint32_t rgxf;
+        uint32_t rgxs;
+        uint32_t usb;
+        uint32_t pic;
+} xlp2xx_soc_freq_s;
+
+extern xlp2xx_soc_freq_s xlp2xx_freq_tbl[2];
+extern const char* nlm_hal_xlp2xx_get_dev_name(soc_device_id_t dev);
+
+typedef soc_device_id_t xlp2xx_clkdev_t;
+
+#ifdef NLM_HAL_LINUX_KERNEL 
+#define NLM_HAL_DO_DIV(n, base)   if(base) { do_div((n), (base)); }
+#else
+#define NLM_HAL_DO_DIV(n, base)   if(base) { ((n) /= (base)); }
+#endif 
+
+/*XLP2XX soc dev*/
+typedef enum xlp2xx_pll_type {
+	CORE0_PLL = 0,
+	CORE1_PLL = 1,
+	SYS_PLL   = 2,
+	DMC_PLL   = 3,
+	DEV0_PLL  = 4,
+	DEV1_PLL  = 5,
+	DEV2_PLL  = 6
+} xlp2xx_pll_type_t;
+
+
+typedef enum xlp2xx_clkdev_sel{
+	SEL_REF_CLK	=0x0,
+	SEL_DEV0PLL	=0x1,
+	SEL_DEV1PLL	=0x2,
+	SEL_DEV2PLL	=0x3
+} xlp2xx_clkdev_sel_t;
+
+typedef enum xlp2xx_clkdev_div{
+	DIV_BYPASS	=0x0,
+	DIV_DIV2	=0x1,
+	DIV_DIV4	=0x2,
+	DIV_DIV8	=0x3
+} xlp2xx_clkdev_div_t;
+
 extern uint8_t nlm_hal_get_soc_clock_state(int node, soc_device_id_t device);
 extern void nlm_hal_soc_clock_enable(int node, soc_device_id_t device);
 extern void nlm_hal_soc_clock_disable(int node, soc_device_id_t device);
@@ -73,4 +150,27 @@ extern uint64_t nlm_hal_set_soc_freq(int node, soc_device_id_t device, uint64_t
 extern uint64_t nlm_hal_get_core_freq(int node, uint8_t core);
 extern uint64_t nlm_hal_set_core_freq(int node, uint8_t core, uint64_t freq);
 extern unsigned long long nlm_hal_cpu_freq(void);
+extern int nlm_hal_is_ref_clk_133MHz(void);
+extern uint64_t nlm_hal_get_ref_clk_freq(void);
+
+#define XLP_LOW_FREQ_SEL  0
+#define XLP_HIGH_FREQ_SEL 1
+extern void nlm_hal_adjust_soc_freqs(int node, int freq_sel);
+
+
+/*xlp2xx based APIs*/
+extern uint64_t xlp2xx_get_ref_clk(int node, uint64_t* ref_clk_num, uint32_t* ref_clk_den);
+extern uint64_t nlm_hal_xlp2xx_set_clkdev_frq(int node, soc_device_id_t dev_type, uint64_t frq);
+extern uint64_t nlm_hal_xlp2xx_get_clkdev_frq(int node, soc_device_id_t dev_type);
+
+#define NLM_HALT_IF(cond) while(cond) { \
+                nlm_print("ERROR: %s\n", __FUNCTION__); \
+                nlm_mdelay(10000); \
+        }
+
+#define NLM_HALT_IF_XLPII() NLM_HALT_IF(is_nlm_xlp2xx())
+#define XLP_DISABLE 1
+#define XLP_ENABLE  0
+
+
 #endif
diff --git a/arch/mips/include/asm/netlogic/hal/nlm_hal_vsemi_data.h b/arch/mips/include/asm/netlogic/hal/nlm_hal_vsemi_data.h
new file mode 100644
index 0000000..5030dfa
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/hal/nlm_hal_vsemi_data.h
@@ -0,0 +1,22 @@
+#ifndef _NLM_HAL_VESMI_DATA_H_
+#define _NLM_HAL_VSEMI_DATA_H_
+
+
+/*156 Mhz related functions*/
+extern void nlm_hal_config_vsemi_mem_16G_4page(void);
+extern void nlm_hal_config_vsemi_mem_16G(void);
+extern void nlm_hal_config_vsemi_mem_12G_4page(void);
+extern void nlm_hal_config_vsemi_mem_12G(void);
+extern void nlm_hal_config_vsemi_mem_xaui(void);
+extern void nlm_hal_config_vsemi_mem_xaui_4page(void);
+
+/*125 Mhz related functions*/
+void nlm_hal_config_vsemi_mem_16G_4page_125(void);
+void nlm_hal_config_vsemi_mem_16G_125(void);
+void nlm_hal_config_vsemi_mem_12G_4page_125(void);
+void nlm_hal_config_vsemi_mem_12G_125(void);
+void nlm_hal_config_vsemi_mem_xaui_4page_125(void);
+void nlm_hal_config_vsemi_mem_xaui_125(void);	
+#endif
+
+
diff --git a/arch/mips/include/asm/netlogic/hal/nlm_hal_xlp_dev.h b/arch/mips/include/asm/netlogic/hal/nlm_hal_xlp_dev.h
index 9206f33..9875c46 100644
--- a/arch/mips/include/asm/netlogic/hal/nlm_hal_xlp_dev.h
+++ b/arch/mips/include/asm/netlogic/hal/nlm_hal_xlp_dev.h
@@ -1,27 +1,32 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
 
 #ifndef NLM_HAL_XLP_DEV_H
 #define NLM_HAL_XLP_DEV_H
@@ -42,22 +47,15 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define XLP_PCIE_DEV_BLK_SIZE 0x8000 // 4k per function  and 8 function in a dev block
 #define XLP_PCIE_BUS_BLK_SIZE (256 * XLP_PCIE_DEV_BLK_SIZE)
 
-/*CPU ID information */
-#define EFUSE_CFG6_CPUID_MASK  0xff
-
-
-
-/*Revision no.*/
-#define XLP_REVISION_A0 	0x00
-#define XLP_REVISION_A1 	0x01
-#define XLP_REVISION_A2 	0x02
-#define XLP_REVISION_B0	 	0x03
-
 /*XLP8XX/4XX B0 and A2 supported apis*/
+#define CHIP_PROCESSOR_ID_XLP_8XX    0
 #define CHIP_PROCESSOR_ID_XLP_8_4_XX 0x10
+#define CHIP_PROCESSOR_ID_XLP_3XX    0x11
+#define CHIP_PROCESSOR_ID_XLP_2XX    0x12
+#define CHIP_PROCESSOR_ID_XLP_1XX    0x13
+#define CHIP_PROCESSOR_ID_XLP_9XX    0x15
 
-/*XLP 8XX/4XX  A0,A1,A2 chip support*/
-#define CHIP_PROCESSOR_ID_XLP_8XX   0x00
+/*XLP 8XX  A0,A1,A2 chip support*/
 #define CHIP_PROCESSOR_ID_XLP_832   CHIP_PROCESSOR_ID_XLP_8_4_XX
 #define CHIP_PROCESSOR_ID_XLP_816   0x14
 #define CHIP_PROCESSOR_ID_XLP_432   0x90
@@ -67,47 +65,63 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define CHIP_PROCESSOR_ID_XLP_204   0xB7
 #define CHIP_PROCESSOR_ID_XLP_104   0xF7
 
-/*3XX series*/
-#define CHIP_PROCESSOR_ID_XLP_3XX   0x11
-		#define CPU_EXTPID_XLP_3XX_NONE     0x00    /* Default */
-		#define CPU_EXTPID_XLP_3XX_L        0x01    /* Lite */
-		#define CPU_EXTPID_XLP_3XX_LP       0x02    /* Lite Plus */
-		#define CPU_EXTPID_XLP_3XX_LP2      0x03    /* Lite Plus */
-
-/*2XX series */
-#define CHIP_PROCESSOR_ID_XLP_2XX   0x12
-
-/*1XX series */
-#define CHIP_PROCESSOR_ID_XLP_1XX   0x13
-
-/*9XX series */
-#define CHIP_PROCESSOR_ID_XLP_9XX   0x15
-
-/*Revision no.*/
-#define XLP_REVISION_A0 	0x00
-#define XLP_REVISION_A1 	0x01
-#define XLP_REVISION_A2 	0x02
-#define XLP_REVISION_B0	 	0x03
-#define XLP_REVISION_B1		0x04
-#define XLP_REVISION_AX		0xAF
-#define XLP_REVISION_BX		0xBF
+/*Software Revision Number        XLP8XX  XLP3XX */
+#define XLP_REVISION_A0  0x00 /*    0        0   */
+#define XLP_REVISION_A1  0x01 /*    1        1   */
+#define XLP_REVISION_A2  0x02 /*    2            */
+#define XLP_REVISION_B0  0x03 /*    3        2   */
+#define XLP_REVISION_B1  0x04 /*    4        3   */
+
+#define XLP_REVISION_AX  0xAF
+#define XLP_REVISION_BX  0xBF
+#define XLP_REVISION_INV 0xFE
 #ifndef XLP_REVISION_ANY
-#define XLP_REVISION_ANY	0xFF
+#define XLP_REVISION_ANY 0xFF
 #endif
 
-#define XLP3XX_REVISION_A0	0x00
-#define XLP3XX_REVISION_A1	0x01
-#define XLP3XX_REVISION_B0	0x02
-#define XLP3XX_REVISION_B1	0x03
 /*XLP 3XX EXTPID type */
-#define CPU_EXTPID_XLP_3XX_NONE		0x00 /* Default */
-#define CPU_EXTPID_XLP_3XX_L		0x01 /* Lite */
-#define CPU_EXTPID_XLP_3XX_LP		0x02 /* Lite Plus */
-#define CPU_EXTPID_XLP_3XX_LP2		0x03 /* Lite Plus2 */
-#define CPU_EXTPID_XLP_3XX_MAX		0x04
+#define CPU_EXTPID_XLP_3XX_NONE  0x00    /* Default */
+#define CPU_EXTPID_XLP_3XX_L     0x01    /* Lite */
+#define CPU_EXTPID_XLP_3XX_LP    0x02	 /* Lite Plus */
+#define CPU_EXTPID_XLP_3XX_LP2   0x03    /* Lite Plus2 */
+#define CPU_EXTPID_XLP_3XX_MAX   0x04
 
-#define CPU_EXTPID_XLP_3XX_INV		0xFE /* invalid */
-#define CPU_EXTPID_XLP_3XX_ANY		0xFF /* Any 3XX */
+#define CPU_EXTPID_XLP_3XX_INV   0xFE  	 /* invalid */
+#define CPU_EXTPID_XLP_3XX_ANY   0xFF	 /* Any 3XX */
+
+#ifndef __ASSEMBLY__
+#ifndef __XLP_CHIPID_MACROS__
+#define __XLP_CHIPID_MACROS__
+
+extern int is_nlm_xlp(unsigned int chipid, unsigned int rev,  unsigned int ext);
+
+#ifndef is_nlm_xlp8xx
+#define is_nlm_xlp8xx()      ( is_nlm_xlp(800, XLP_REVISION_ANY, 0) || is_nlm_xlp(400, XLP_REVISION_ANY, 0))
+#endif //is_nlm_xlp8xx
+
+#define is_nlm_xlp8xx_ax()   ( is_nlm_xlp(800, XLP_REVISION_AX,  0) || is_nlm_xlp(400, XLP_REVISION_AX, 0))
+#define is_nlm_xlp8xx_b0()   ( is_nlm_xlp(800, XLP_REVISION_B0,  0) || is_nlm_xlp(400, XLP_REVISION_B0, 0))
+#define is_nlm_xlp8xx_b1()   ( is_nlm_xlp(800, XLP_REVISION_B1,  0) || is_nlm_xlp(400, XLP_REVISION_B1, 0))
+#define is_nlm_xlp8xx_bx()   ( is_nlm_xlp(800, XLP_REVISION_BX,  0) || is_nlm_xlp(400, XLP_REVISION_BX, 0))
+#define is_nlm_xlp832_ax()   ( is_nlm_xlp(832, XLP_REVISION_AX,  0))
+#define is_nlm_xlp3xx_ax()   is_nlm_xlp(300, XLP_REVISION_AX,  CPU_EXTPID_XLP_3XX_ANY)
+#define is_nlm_xlp3xx_bx()   is_nlm_xlp(300, XLP_REVISION_BX,  CPU_EXTPID_XLP_3XX_ANY)
+#define is_nlm_xlp3xx_b0()   is_nlm_xlp(300, XLP_REVISION_B0,  CPU_EXTPID_XLP_3XX_ANY)
+#define is_nlm_xlp3xx()      ( is_nlm_xlp(300, XLP_REVISION_ANY, CPU_EXTPID_XLP_3XX_ANY))
+#define is_nlm_xlp316()      ( is_nlm_xlp(316, XLP_REVISION_ANY, CPU_EXTPID_XLP_3XX_ANY))
+#define is_nlm_xlp312()      ( is_nlm_xlp(312, XLP_REVISION_ANY, CPU_EXTPID_XLP_3XX_ANY))
+#define is_nlm_xlp308()      ( is_nlm_xlp(308, XLP_REVISION_ANY, CPU_EXTPID_XLP_3XX_ANY))
+#define is_nlm_xlp304()      ( is_nlm_xlp(304, XLP_REVISION_ANY, CPU_EXTPID_XLP_3XX_ANY))
+#define is_nlm_xlp3xx_lite() ( is_nlm_xlp(300, XLP_REVISION_ANY, CPU_EXTPID_XLP_3XX_ANY) && (!is_nlm_xlp(300, XLP_REVISION_ANY, CPU_EXTPID_XLP_3XX_NONE)) )
+#define is_nlm_xlp2xx()	    is_nlm_xlp(200, XLP_REVISION_ANY,  0)
+#define is_nlm_xlp204()	    is_nlm_xlp(204, XLP_REVISION_ANY,  0)
+#define is_nlm_xlp208()	    is_nlm_xlp(208, XLP_REVISION_ANY,  0)
+#define is_nlm_xlp1xx()	    is_nlm_xlp(100, XLP_REVISION_ANY,  0)
+#define is_nlm_xlp104()	    is_nlm_xlp(104, XLP_REVISION_ANY,  0)
+
+#endif //__XLP_CHIPID_MACROS__
+
+#endif // __ASSEMBLY__
 
 /*
  *    FMN
@@ -189,6 +203,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 
 #define XLP_3XX_SRIO_VC_BASE        280
 #define XLP_3XX_SRIO_VC_LIMIT       288
+#define XLP_3XX_B0_SRIO_VC_LIMIT    289
 
 
 #define XLP_3XX_POE_VC_BASE         384
@@ -197,11 +212,35 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define XLP_3XX_NET_TX_VC_LIMIT     495
 #define XLP_3XX_NET_RX_VC_BASE      496
 #define XLP_3XX_NET_RX_VC_LIMIT     503 // 511
-#define XLP_3XX_NET_VC_BASE	      XLP_3XX_NET_TX_VC_BASE	
+#define XLP_3XX_NET_VC_BASE	      XLP_3XX_NET_TX_VC_BASE
 #define XLP_3XX_NET_VC_LIMIT        511
 
 #define XLP_3XX_INVALID_STATION		512
 
+// XLP2XX
+#define XLP_2XX_CDE_VC_BASE         266
+#define XLP_2XX_CDE_VC_LIMIT        267
+
+#define XLP_2XX_REGEX_VC_BASE       268
+#define XLP_2XX_REGEX_VC_LIMIT      271
+
+#define XLP_2XX_RSA_ECC_VC_BASE     272
+#define XLP_2XX_RSA_ECC_VC_LIMIT    272
+
+#define XLP_2XX_CRYPTO_VC_BASE      276
+#define XLP_2XX_CRYPTO_VC_LIMIT     276
+
+#define XLP_2XX_POE_VC_BASE         384
+#define XLP_2XX_POE_VC_LIMIT        391
+#define XLP_2XX_NET_TX_VC_BASE      432
+#define XLP_2XX_NET_TX_VC_LIMIT     495
+#define XLP_2XX_NET_RX_VC_BASE      496
+#define XLP_2XX_NET_RX_VC_LIMIT     503 // 511
+#define XLP_2XX_NET_VC_BASE	    XLP_2XX_NET_TX_VC_BASE
+#define XLP_2XX_NET_VC_LIMIT        511
+
+#define XLP_2XX_INVALID_STATION		512
+
 /*Sw Code */
 #define XLP_CODE_MAC		0
 #define XLP_CODE_SEC		1	
@@ -215,6 +254,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define XLP_MSG_STATUS1_REG	$4
 #define XLP_MSG_CONFIG_REG	$5
 #define XLP_MSG_CONFIG1_REG	$6
+#define XLP_MSG_INT_REG		$8
 
 /*sys register offset in pcie config space*/
 #define XLP_PCIE_NODE0_SYSOFFSET        0x35000
@@ -284,9 +324,6 @@ THE POSSIBILITY OF SUCH DAMAGE.
 		
 
 #ifndef __ASSEMBLY__
-
-extern int is_nlm_xlp(unsigned int chipid, unsigned int rev,  unsigned int ext);
-
 /* Device Id: Bus[8:6], Dev[5:3], func[2:0] */
 
 enum sae_cfg_regs {
@@ -427,8 +464,11 @@ enum net_cfg_regs {
  FLOW_BASE_MASK_CFG                 = 0x80,
  POE_CLASS_SETUP_CFG                = 0x81,
  UCORE_IFACE_MASK_CFG               = 0x82,
+ RX_BUFFER_XONOFF_THR    	    = 0x83,
  FLOW_TABLE1_CFG                    = 0x84,
+ FLOW_TABLE3_CFG                    = 0x86,
  IFACE_FIFO_CFG             	    = 0x8a,
+ PARSER_SEQ_FIFOTH_CFG		    = 0x8b,
  L2_TYPE_0                          = 0x210,
  L3_CTABLE_MASK_0                   = 0x22c,
  L3_CTABLE_0_0                      = 0x230,
@@ -436,9 +476,36 @@ enum net_cfg_regs {
  L4_CTABLE_0_0                      = 0x250,
  L4_CTABLE_0_1                      = 0x251,
  VFBID_TO_DEST_MAP_STATUS           = 0x380,
- NET_COMMON0_INTR_STS		    = 0x2A8,
- NET_COMMON0_INTR_MASK		    = 0x2A9,
+ 
+NET_COMMON0_INTR_STS		    = 0x2A8,	
+NET_COMMON0_INTR_MASK		    = 0x2A9,	
+
+ /*1588 PTP timer */
+IF_1588_TMSMP_HI		    = 0x300,
+IF_1588_TMSMP_LO		    = 0x301,   
+
+PTP_OFFSET_HI		    	    = 0x784,
+PTP_OFFSET_LO		            = 0x785,
+PTP_INC_DEN		            = 0x786,
+PTP_INC_NUM		            = 0x787,
+PTP_INC_INTG		            = 0x788,
+PTP_CONTROL		            = 0x789,
+PTP_STATUS			    = 0x78A,
+PTP_USER_VALUE_HI		    = 0x78B,
+PTP_USER_VALUE_LO		    = 0x78C,							  
+PTP_TMR1_HI		            = 0x78D,
+PTP_TMR1_LO		            = 0x78E,
+PTP_TMR2_HI		            = 0x78F,
+PTP_TMR2_LO		            = 0x790,
+PTP_TMR3_HI		            = 0x791,
+PTP_TMR3_LO		            = 0x792,
+
+IOSYS_RTC_CMD      = 0x7C0,
+IOSYS_RTC_RDATA_HI = 0x7C1,
+IOSYS_RTC_RDATA_LO = 0x7C2,
+
 };
+
 //
 enum if_cfg_regs {
   MAC_CONF1 = 0,
@@ -464,22 +531,22 @@ enum netior_regs {
 };
 enum NAE_TX_TYPE {
 	P2D_NEOP = 0,
-	P2P,
-	P2D_EOP,
-	MSC
+	P2P      = 1,
+	P2D_EOP  = 2,
+	MSC      = 3
 };
 
 /* NAE Interface Definitions
  */
 enum NAE_INTF_TYPE {    
-	GMAC_0 = 0,      
-	GMAC_1,  
-	GMAC_2,  
-	GMAC_3,  
-	XGMAC, 
-	INTERLAKEN,    
-	PHY = 0xE,      
-	LANE_CFG = 0xF, 
+	GMAC_0 = 0,
+	GMAC_1 = 1,
+	GMAC_2 = 2,
+	GMAC_3 = 3,
+	XGMAC  = 4,
+	INTERLAKEN = 5,
+	PHY	 = 0xE,
+	LANE_CFG = 0xF,
 };      
 
 enum NAE_BLOCK_NR {    
@@ -505,6 +572,73 @@ typedef enum PHY_LANE_INTF_TYPE {
 	LANE_8ILAKEN,   
 } phy_lane_intf_t;      
 
+
+/* MACSEC
+ */
+enum nae_macsec_cfg_regs {
+TX_MSEC_ETHER_TYPE		= 0x33e,
+TX_MSEC_PORT_EN          	= 0x33f,
+TX_MSEC_BYPASS         		= 0x340,
+TX_MSEC_PROG_STATUS      	= 0x341,
+TX_MSEC_INIT_PN          	= 0x342,
+TX_MSEC_PN_THRESH        	= 0x343,
+TX_MSEC_PREAMBLE_LEN_CODE      	= 0x344,
+TX_MSEC_KEY_IN_USE0		= 0x345,
+TX_MSEC_KEY_IN_USE1		= 0x346,
+TX_MSEC_KEY_IN_USE2		= 0x347,
+TX_MSEC_KEY_IN_USE3		= 0x348,
+TX_MSEC_KEY_XED_THRESH0     	= 0x349,
+TX_MSEC_KEY_XED_THRESH1      	= 0x34a,
+TX_MSEC_KEY_XED_THRESH2      	= 0x34b,
+TX_MSEC_KEY_XED_THRESH3      	= 0x34c,
+TX_MSEC_KEY_STALE0		= 0x34d,
+TX_MSEC_KEY_STALE2		= 0x34f,
+TX_MSEC_KEY_STALE3		= 0x350,
+TX_MSEC_KEY_ERR0            	= 0x351,
+TX_MSEC_KEY_ERR1            	= 0x352,
+TX_MSEC_KEY_ERR2            	= 0x353,
+TX_MSEC_KEY_ERR3            	= 0x354,
+
+TX_MSEC_MEM_DATAREG_0           = 0x38c,
+TX_MSEC_MEM_DATAREG_1           = 0x38d,
+TX_MSEC_MEM_DATAREG_2           = 0x38e,
+TX_MSEC_MEM_DATAREG_3           = 0x38f,
+TX_MSEC_MEM_CTRL_REG            = 0x390,
+
+RX_MSEC_MEM_DATAREG_0        	= 0x400,
+RX_MSEC_MEM_DATAREG_1        	= 0x401,
+RX_MSEC_MEM_DATAREG_2        	= 0x402,
+RX_MSEC_MEM_DATAREG_3        	= 0x403,
+RX_MSEC_MEM_CTRL_REG         	= 0x404,
+
+RX_MSEC_PORT_EN         	= 0x405,
+RX_MSEC_BYPASS         		= 0x406,
+RX_MSEC_SEC_TAG0		= 0x407,
+RX_MSEC_SEC_TAG1      		= 0x408,
+RX_MSEC_INIT_PN             	= 0x409,
+RX_MSEC_REPLAY_WIN_SIZE     	= 0x40a,
+RX_MSEC_SCI_MASK0_LO        	= 0x40b,
+RX_MSEC_SCI_MASK0_HI         	= 0x40c,
+RX_MSEC_SCI_MASK1_LO         	= 0x40d,
+RX_MSEC_SCI_MASK1_HI         	= 0x40e,
+RX_MSEC_SCI_MASK2_LO         	= 0x40f,
+RX_MSEC_SCI_MASK2_HI         	= 0x410,
+RX_MSEC_SCI_MASK3_LO         	= 0x411,
+RX_MSEC_SCI_MASK3_HI         	= 0x412,
+RX_MSEC_SCI_MASK4_LO         	= 0x413,
+RX_MSEC_SCI_MASK4_HI         	= 0x414,
+RX_MSEC_SCI_MASK5_LO         	= 0x415,
+RX_MSEC_SCI_MASK5_HI         	= 0x416,
+RX_MSEC_SCI_MASK6_LO         	= 0x417,
+RX_MSEC_SCI_MASK6_HI         	= 0x418,
+RX_MSEC_SCI_MASK7_LO         	= 0x419,
+RX_MSEC_SCI_MASK7_HI		= 0x41a,
+
+};
+
+#define RX_MSEC_SCI_MASK_LO(i) (0x40b + i *2)
+#define RX_MSEC_SCI_MASK_HI(i) (0x40c + i *2)
+
 /*
  *  POE
  */
@@ -574,6 +708,58 @@ enum poe_stats_reg {
 	POE_MAX_SIZE	
 };
 
+#define POE_CL0_ENQ_SPILL_BASE_L	0x40
+#define POE_CL0_ENQ_SPILL_BASE_H	0x41
+#define POE_CL1_ENQ_SPILL_BASE_L	0x42
+#define POE_CL1_ENQ_SPILL_BASE_H	0x43
+#define POE_CL2_ENQ_SPILL_BASE_L	0x44
+#define POE_CL2_ENQ_SPILL_BASE_H	0x45
+#define POE_CL3_ENQ_SPILL_BASE_L	0x46
+#define POE_CL3_ENQ_SPILL_BASE_H	0x47
+#define POE_CL4_ENQ_SPILL_BASE_L	0x48
+#define POE_CL4_ENQ_SPILL_BASE_H	0x49
+#define POE_CL5_ENQ_SPILL_BASE_L	0x4a
+#define POE_CL5_ENQ_SPILL_BASE_H	0x4b
+#define POE_CL6_ENQ_SPILL_BASE_L	0x4c
+#define POE_CL6_ENQ_SPILL_BASE_H	0x4d
+#define POE_CL7_ENQ_SPILL_BASE_L	0x4e
+#define POE_CL7_ENQ_SPILL_BASE_H	0x4f
+
+#define POE_CL0_DEQ_SPILL_BASE_L	0x50
+#define POE_CL0_DEQ_SPILL_BASE_H	0x51
+#define POE_CL1_DEQ_SPILL_BASE_L	0x52
+#define POE_CL1_DEQ_SPILL_BASE_H	0x53
+#define POE_CL2_DEQ_SPILL_BASE_L	0x54
+#define POE_CL2_DEQ_SPILL_BASE_H	0x55
+#define POE_CL3_DEQ_SPILL_BASE_L	0x56
+#define POE_CL3_DEQ_SPILL_BASE_H	0x57
+#define POE_CL4_DEQ_SPILL_BASE_L	0x58
+#define POE_CL4_DEQ_SPILL_BASE_H	0x59
+#define POE_CL5_DEQ_SPILL_BASE_L	0x5a
+#define POE_CL5_DEQ_SPILL_BASE_H	0x5b
+#define POE_CL6_DEQ_SPILL_BASE_L	0x5c
+#define POE_CL6_DEQ_SPILL_BASE_H	0x5d
+#define POE_CL7_DEQ_SPILL_BASE_L	0x5e
+#define POE_CL7_DEQ_SPILL_BASE_H	0x5f
+
+#define POE_CL0_ENQ_SPILL_MAXLINE	0x64
+#define POE_CL1_ENQ_SPILL_MAXLINE	0x65
+#define POE_CL2_ENQ_SPILL_MAXLINE	0x66
+#define POE_CL3_ENQ_SPILL_MAXLINE	0x67
+#define POE_CL4_ENQ_SPILL_MAXLINE	0x68
+#define POE_CL5_ENQ_SPILL_MAXLINE	0x69
+#define POE_CL6_ENQ_SPILL_MAXLINE	0x6a
+#define POE_CL7_ENQ_SPILL_MAXLINE	0x6b
+
+#define POE_CL0_DEQ_SPILL_MAXLINE	0x6c
+#define POE_CL1_DEQ_SPILL_MAXLINE	0x6d
+#define POE_CL2_DEQ_SPILL_MAXLINE	0x6e
+#define POE_CL3_DEQ_SPILL_MAXLINE	0x6f
+#define POE_CL4_DEQ_SPILL_MAXLINE	0x70
+#define POE_CL5_DEQ_SPILL_MAXLINE	0x71
+#define POE_CL6_DEQ_SPILL_MAXLINE	0x72
+#define POE_CL7_DEQ_SPILL_MAXLINE	0x73
+
 #define POE_DIST_THRESHOLD_0 	0x200
 #define POE_DEST_THRESHOLD	0x204
 #define POE_DIST_ENABLE 0x205
@@ -650,94 +836,512 @@ enum POE_SW_CODE {
 #define UCORE_CPU_SHARED_MEM_START 0x10000
 #define UCORE_CPU_SHARED_MEM_END   0x17fff
 
+#define SYS_REG_BASE	(( KSEG1 + 0x18000000 + XLP_PCIE_NODE0_SYSOFFSET) & 0x1fffffff )
+#define SYS_REG_INDEX(x)   ( 0x40 + (x)) 
+
 /* System Management PCIe config registers */
 enum sys_cfg_regs {
-    CHIP_RESET              = 0,
-    POWER_ON_RESET_CFG      = 1,
-    EFUSE_DEVICE_CFG0       = 2,
-    EFUSE_DEVICE_CFG1       = 3,
-    EFUSE_DEVICE_CFG2       = 4,
-    EFUSE_DEVICE_CFG3       = 5,
-    EFUSE_DEVICE_CFG4       = 6,
-    EFUSE_DEVICE_CFG5       = 7,
-    EFUSE_DEVICE_CFG6       = 8,
-    EFUSE_DEVICE_CFG7       = 9,
-    PLL_CTRL                = 10,
-    CPU_RESET               = 11,
-    CPU_THREAD_EN           = 12,
-    CPU_NONCOHERENT_MODE    = 13,
-    CORE_DFS_DIS_CTRL       = 14,
-    CORE_DFS_RST_CTRL       = 15,
-    CORE_DFS_BYP_CTRL       = 16,
-    CORE_DFS_PHA_CTRL       = 17,
-    CORE_DFS_DIV_INC_CTRL   = 18,
-    CORE_DFS_DIV_DEC_CTRL   = 19,
-    CORE_DFS_DIV_VALUE      = 20,
-    SYS_RESET               = 21,
-    SYS_DFS_DIS_CTRL        = 22,
-    SYS_DFS_RST_CTRL        = 23,
-    SYS_DFS_BYP_CTRL        = 24,
-    SYS_DFS_DIV_INC_CTRL    = 25,
-    SYS_DFS_DIV_DEC_CTRL    = 26,
-    SYS_DFS_DIV_VALUE0      = 27,
-    SYS_DFS_DIV_VALUE1      = 28,
-    CPU_SENSE_AMP_DLY       = 29,
-    SOC_SENSE_AMP_DLY       = 30,
-    SYS_CTRL0               = 31,
-    SYS_CTRL1               = 32,
-    TIMEOUT_BSI             = 33,
-    BYTE_SWAP               = 34,
-    VRM_VID                 = 35,
-    SYS_PWR_RAM_CMD         = 36,
-    SYS_PWR_RAM_ADDR        = 37,
-    SYS_PWR_RAM_DATA0       = 38,
-    SYS_PWR_RAM_DATA1       = 39,
-    SYS_PWR_RAM_DATA2       = 40,
-    SYS_PWR_UCODE           = 41,
-    CPU0_PWR_STATUS         = 42,
-    CPU1_PWR_STATUS         = 43,
-    CPU2_PWR_STATUS         = 44,
-    CPU3_PWR_STATUS         = 45,
-    CPU4_PWR_STATUS         = 46,
-    CPU5_PWR_STATUS         = 47,
-    CPU6_PWR_STATUS         = 48,
-    CPU7_PWR_STATUS         = 49,
-    SYS_STATUS              = 50,
-    SYS_INT_POL             = 51,
-    SYS_INT_TYPE            = 52,
-    SYS_INT_STATUS          = 53,
-    SYS_INT_EN0             = 54,
-    SYS_INT_EN1             = 55,
-    PLL_DFS_DIS_CTRL        = 56,
-    PLL_DFS_RST_CTRL        = 57,
-    PLL_DFS_BYP_CTRL        = 58,
-    PLL_DFS_DIV_INC_CTRL    = 59,
-    PLL_DFS_DIV_DEC_CTRL    = 60,
-    PLL_DFS_DIV_VALUE       = 61,
-    SYS_DISABLE             = 62,
-    SYS_UCO_S_ECC           = 63,
-    SYS_UCO_M_ECC           = 64,
-    SYS_UCO_ADDR            = 65,
-    SYS_UCO_INST            = 66,
-    MEM_BIST0               = 67,
-    MEM_BIST1               = 68,
-    MEM_BIST2               = 69,
-    MEM_BIST3               = 70,
-    MEM_BIST4               = 71,
-    MEM_BIST5               = 72,
-    MEM_BIST6               = 73,
-    MEM_BIST7               = 74,
-    MEM_BIST8               = 75,
-    MEM_BIST9               = 76,
-    MEM_BIST10              ,
-    MEM_BIST11              ,
-    MEM_BIST12              ,
-    SCRATCH0                ,
-    SCRATCH1                ,
-    SCRATCH2                ,
-    SCRATCH3
+    CHIP_RESET              = 0x00,
+    POWER_ON_RESET_CFG      = 0x01,
+    EFUSE_DEVICE_CFG0       = 0x02,
+    EFUSE_DEVICE_CFG1       = 0x03,
+    EFUSE_DEVICE_CFG2       = 0x04,
+    EFUSE_DEVICE_CFG3       = 0x05,
+    EFUSE_DEVICE_CFG4       = 0x06,
+    EFUSE_DEVICE_CFG5       = 0x07,
+    EFUSE_DEVICE_CFG6       = 0x08,
+    EFUSE_DEVICE_CFG7       = 0x09,
+    PLL_CTRL                = 0x0a,
+    CPU_RESET               = 0x0b,
+    CPU_THREAD_EN           = 0x0c,
+    CPU_NONCOHERENT_MODE    = 0x0d,
+    CORE_DFS_DIS_CTRL       = 0x0e,
+    CORE_DFS_RST_CTRL       = 0x0f,
+    CORE_DFS_BYP_CTRL       = 0x10,
+    CORE_DFS_PHA_CTRL       = 0x11,
+    CORE_DFS_DIV_INC_CTRL   = 0x12,
+    CORE_DFS_DIV_DEC_CTRL   = 0x13,
+    CORE_DFS_DIV_VALUE      = 0x14,
+    SYS_RESET               = 0x15,
+    SYS_DFS_DIS_CTRL        = 0x16,
+    SYS_DFS_RST_CTRL        = 0x17,
+    SYS_DFS_BYP_CTRL        = 0x18,
+    SYS_DFS_DIV_INC_CTRL    = 0x19,
+    SYS_DFS_DIV_DEC_CTRL    = 0x1a,
+    SYS_DFS_DIV_VALUE0      = 0x1b,
+    SYS_DFS_DIV_VALUE1      = 0x1c,
+    CPU_SENSE_AMP_DLY       = 0x1d,
+    SOC_SENSE_AMP_DLY       = 0x1e,
+    SYS_CTRL0               = 0x1f,
+    SYS_CTRL1               = 0x20,
+    TIMEOUT_BSI             = 0x21,
+    BYTE_SWAP               = 0x22,
+    VRM_VID                 = 0x23,
+    SYS_PWR_RAM_CMD         = 0x24,
+    SYS_PWR_RAM_ADDR        = 0x25,
+    SYS_PWR_RAM_DATA0       = 0x26,
+    SYS_PWR_RAM_DATA1       = 0x27,
+    SYS_PWR_RAM_DATA2       = 0x28,
+    SYS_PWR_UCODE           = 0x29,
+    CPU0_PWR_STATUS         = 0x2a,
+    CPU1_PWR_STATUS         = 0x2b,
+    CPU2_PWR_STATUS         = 0x2c,
+    CPU3_PWR_STATUS         = 0x2d,
+    CPU4_PWR_STATUS         = 0x2e,
+    CPU5_PWR_STATUS         = 0x2f,
+    CPU6_PWR_STATUS         = 0x30,
+    CPU7_PWR_STATUS         = 0x31,
+    SYS_STATUS              = 0x32,
+    SYS_INT_POL             = 0x33,
+    SYS_INT_TYPE            = 0x34,
+    SYS_INT_STATUS          = 0x35,
+    SYS_INT_EN0             = 0x36,
+    SYS_INT_EN1             = 0x37,
+
+    /* Added XLP3XX or XLP8XX.Bx Registers: from 0x38 to 0x8a*/
+    PLL_DFS_DIS_CTRL        = 0x38,
+    PLL_DFS_RST_CTRL        = 0x39,
+    PLL_DFS_BYP_CTRL        = 0x3a,
+    PLL_DFS_DIV_INC_CTRL    = 0x3b,
+    PLL_DFS_DIV_DEC_CTRL    = 0x3c,
+    PLL_DFS_DIV_VALUE       = 0x3d,
+    SYS_DISABLE             = 0x3e,
+    SYS_UCO_S_ECC           = 0x3f,
+    SYS_UCO_M_ECC           = 0x40,
+    SYS_UCO_ADDR            = 0x41,
+    SYS_UCO_INST            = 0x42,
+
+    MEM_BIST0               = 0x43,
+    MEM_BIST1               = 0x44,
+    MEM_BIST2               = 0x45,
+    MEM_BIST3               = 0x46,
+    MEM_BIST4               = 0x47,
+    MEM_BIST5               = 0x48,
+    MEM_BIST6               = 0x49,
+    MEM_BIST7               = 0x4a,
+    MEM_BIST8               = 0x4b,
+    MEM_BIST9               = 0x4c,
+    MEM_BIST10              = 0x4d,
+    MEM_BIST11              = 0x4e,
+    MEM_BIST12              = 0x4f,
+    MEM_STAT0               = 0x50,
+    MEM_STAT1               = 0x51,
+
+    SYS_SCRATCH0            = 0x52,
+    SYS_SCRATCH1            = 0x53,
+    SYS_SCRATCH2            = 0x54,
+    SYS_SCRATCH3	    = 0x55,
+
+    SYS_COUNTER             = 0x56,
+    SYS_CTRLSECUREBOOT      = 0x57,
+    SYS_SECUREKEY           = 0x60,
+    SYS_EFUSECTRL           = 0x80,
+    SYS_EFUSECMD            = 0x81,
+    SYS_EFUSECMDKEY         = 0x82,
+    SYS_EFUSESTAT           = 0x8a
 };
 
+
+#define XLP2XX_CHIPRESET_REG                           0x0
+#define XLP2XX_POWERONRESETCFG_REG                     0x1
+#define XLP2XX_EFUSEDEVICECFG0_REG                     0x2
+#define XLP2XX_EFUSEDEVICECFG1_REG                     0x3
+#define XLP2XX_EFUSEDEVICECFG2_REG                     0x4
+#define XLP2XX_EFUSEDEVICECFG3_REG                     0x5
+#define XLP2XX_EFUSEDEVICECFG4_REG                     0x6
+#define XLP2XX_EFUSEDEVICECFG5_REG                     0x7
+#define XLP2XX_EFUSEDEVICECFG6_REG                     0x8
+#define XLP2XX_EFUSEDEVICECFG7_REG                     0x9
+#define XLP2XX_PLLCTRL_REG                             0xa
+#define XLP2XX_CPURESET_REG                            0xb
+#define XLP2XX_CPUTHREADEN_REG                         0xc
+#define XLP2XX_CPUNONCOHERENTMODE_REG                  0xd
+#define XLP2XX_TCUDISABLE_REG                          0xe
+#define XLP2XX_CPUSTOP_REG                             0xf
+#define XLP2XX_CPUPSWCTRL_REG                          0x10
+#define XLP2XX_CPUPWRDOWN_REG                          0x11
+#define XLP2XX_CPUMEMCLR_REG                           0x12
+#define XLP2XX_SYSDISABLE_REG                          0x14
+#define XLP2XX_SYSRESET_REG                            0x15
+#define XLP2XX_CPUPSWISO_REG                           0x16
+#define XLP2XX_CPUPSWSET_REG                           0x17
+#define XLP2XX_CPUPSWRESET_REG                         0x18
+#define XLP2XX_CPUPSWCLKEN_REG                         0x19
+#define XLP2XX_CPUPSWIN_REG                            0x1a
+#define XLP2XX_CPUPSWSRAMOFF_REG                       0x1b
+#define XLP2XX_CPUPSWSRAMCLKEN_REG                     0x1c
+#define XLP2XX_CPUSENSEAMPDLY_REG                      0x1d
+#define XLP2XX_SOCSENSEAMPDLY_REG                      0x1e
+#define XLP2XX_SYSCTRL0_REG                            0x1f
+#define XLP2XX_SYSCTRL1_REG                            0x20
+#define XLP2XX_TIMEOUTBSI_REG                          0x21
+#define XLP2XX_BYTESWAP_REG                            0x22
+#define XLP2XX_SYSVRMVID_REG                           0x23
+#define XLP2XX_SYSPWRRAMCMD_REG                        0x24
+#define XLP2XX_SYSPWRRAMADDR_REG                       0x25
+#define XLP2XX_SYSPWRRAMDATA0_REG                      0x26
+#define XLP2XX_SYSPWRRAMDATA1_REG                      0x27
+#define XLP2XX_SYSPWRRAMDATA2_REG                      0x28
+#define XLP2XX_SYSPWRUCODE_REG                         0x29
+#define XLP2XX_SYSPWRSTATUS0_REG                       0x2a
+#define XLP2XX_SYSPWRSTATUS1_REG                       0x2b
+#define XLP2XX_SYSSTATUS_REG                           0x32
+#define XLP2XX_SYSINTPOL_REG                           0x33
+#define XLP2XX_SYSINTTYPE_REG                          0x34
+#define XLP2XX_SYSINTSTATUS_REG                        0x35
+#define XLP2XX_SYSINTENABLE0_REG                       0x36
+#define XLP2XX_SYSINTENABLE1_REG                       0x37
+#define XLP2XX_CPUSTOPPIC_REG                          0x38
+#define XLP2XX_CPUSTOPNBU_REG                          0x39
+#define XLP2XX_CPUSTOPMSG_REG                          0x3a
+#define XLP2XX_CPUPSWDATAOUT_REG                       0x3b
+#define XLP2XX_CPUPWRSTATUS_REG                        0x3c
+#define XLP2XX_CPUMEMCLRDONE_REG                       0x3d
+#define XLP2XX_SYSUCOSECC_REG                          0x3f
+#define XLP2XX_SYSUCOMECC_REG                          0x40
+#define XLP2XX_SYSUCOADDR_REG                          0x41
+#define XLP2XX_SYSUCOINST_REG                          0x42
+#define XLP2XX_SYSMEMBISTGO0_REG                       0x43
+#define XLP2XX_SYSMEMBISTGO1_REG                       0x44
+#define XLP2XX_SYSMEMBISTGO2_REG                       0x45
+#define XLP2XX_SYSMEMBISTGO3_REG                       0x46
+#define XLP2XX_SYSMEMBISTGO4_REG                       0x47
+#define XLP2XX_SYSMEMBISTGO5_REG                       0x48
+#define XLP2XX_SYSMEMBISTGO6_REG                       0x49
+#define XLP2XX_SYSMEMBISTGO7_REG                       0x4a
+#define XLP2XX_SYSMEMBISTGO8_REG                       0x4b
+#define XLP2XX_SYSMEMBISTGO9_REG                       0x4c
+#define XLP2XX_SYSMEMBISTGO10_REG                      0x4d
+#define XLP2XX_SYSMEMBISTGO11_REG                      0x4e
+#define XLP2XX_SYSMEMBISTGO12_REG                      0x4f
+#define XLP2XX_SYSMEMSTAT0_REG                         0x54
+#define XLP2XX_SYSMEMSTAT1_REG                         0x55
+#define XLP2XX_SYSSCRATCH0_REG                         0x58
+#define XLP2XX_SYSSCRATCH1_REG                         0x59
+#define XLP2XX_SYSSCRATCH2_REG                         0x5a
+#define XLP2XX_SYSSCRATCH3_REG                         0x5b
+#define XLP2XX_SYSCOUNTER_REG                          0x5c
+#define XLP2XX_SYSCTRLSECUREBOOT_REG                   0x5d
+#define XLP2XX_SYSSECUREKEY_REG                        0xc0
+#define XLP2XX_SYSEFUSECTRL_REG                        0x140
+#define XLP2XX_SYSEFUSECMD_REG                         0x141
+#define XLP2XX_SYSEFUSECMDDATA_REG                     0x142
+#define XLP2XX_SYSEFUSESTAT_REG                        0x14a
+#define XLP2XX_SYSTHERMCTRL_REG                        0x14b
+#define XLP2XX_CPUTHERMPWRDOWN_REG                     0x14c
+#define XLP2XX_SYSTHERMPWRDOWN_REG                     0x14d
+#define XLP2XX_CPUTHERMEN_REG                          0x14e
+#define XLP2XX_SYSTHERMEN_REG                          0x14f
+#define XLP2XX_THERMTHRESH0_REG                        0x150
+#define XLP2XX_THERMTHRESH1_REG                        0x151
+#define XLP2XX_THERMTHRESH2_REG                        0x152
+#define XLP2XX_THERMTHRESH3_REG                        0x153
+#define XLP2XX_CPUTHERMINTSTATUSHIGH0_REG              0x154
+#define XLP2XX_CPUTHERMINTSTATUSLOW0_REG               0x155
+#define XLP2XX_SYSTHERMINTSTATUSHIGH0_REG              0x156
+#define XLP2XX_SYSTHERMINTSTATUSLOW0_REG               0x157
+#define XLP2XX_CPUTHERMINTSTATUSHIGH1_REG              0x158
+#define XLP2XX_CPUTHERMINTSTATUSLOW1_REG               0x159
+#define XLP2XX_SYSTHERMINTSTATUSHIGH1_REG              0x15a
+#define XLP2XX_SYSTHERMINTSTATUSLOW1_REG               0x15b
+#define XLP2XX_CPUTHERMINTSTATUSHIGH2_REG              0x15c
+#define XLP2XX_CPUTHERMINTSTATUSLOW2_REG               0x15d
+#define XLP2XX_SYSTHERMINTSTATUSHIGH2_REG              0x15e
+#define XLP2XX_SYSTHERMINTSTATUSLOW2_REG               0x15f
+#define XLP2XX_CPUTHERMINTSTATUSHIGH3_REG              0x160
+#define XLP2XX_CPUTHERMINTSTATUSLOW3_REG               0x161
+#define XLP2XX_SYSTHERMINTSTATUSHIGH3_REG              0x162
+#define XLP2XX_SYSTHERMINTSTATUSLOW3_REG               0x163
+#define XLP2XX_CPUTHERMINTENHIGH0_REG                  0x164
+#define XLP2XX_CPUTHERMINTENLOW0_REG                   0x165
+#define XLP2XX_SYSTHERMINTENHIGH0_REG                  0x166
+#define XLP2XX_SYSTHERMINTENLOW0_REG                   0x167
+#define XLP2XX_CPUTHERMINTENHIGH1_REG                  0x168
+#define XLP2XX_CPUTHERMINTENLOW1_REG                   0x169
+#define XLP2XX_SYSTHERMINTENHIGH1_REG                  0x16a
+#define XLP2XX_SYSTHERMINTENLOW1_REG                   0x16b
+#define XLP2XX_CPUTHERMINTENHIGH2_REG                  0x16c
+#define XLP2XX_CPUTHERMINTENLOW2_REG                   0x16d
+#define XLP2XX_SYSTHERMINTENHIGH2_REG                  0x16e
+#define XLP2XX_SYSTHERMINTENLOW2_REG                   0x16f
+#define XLP2XX_CPUTHERMINTENHIGH3_REG                  0x170
+#define XLP2XX_CPUTHERMINTENLOW3_REG                   0x171
+#define XLP2XX_SYSTHERMINTENHIGH3_REG                  0x172
+#define XLP2XX_SYSTHERMINTENLOW3_REG                   0x173
+#define XLP2XX_CPUTHERMCOUNT_REG                       0x174
+#define XLP2XX_SYSTHERMCOUNT_REG                       0x194
+#define XLP2XX_THERMCOUNT_REG                          0x19c
+
+#define XLP2XX_SYSCPUPLLCTRL0_REG                      0x1c0
+#define XLP2XX_SYSCPUPLLCTRL1_REG                      0x1c1
+#define XLP2XX_SYSCPUPLLCTRL2_REG                      0x1c2
+#define XLP2XX_SYSCPUPLLCTRL3_REG                      0x1c3
+
+#define XLP2XX_SYSCPU1PLLCTRL0_REG                      0x1c4
+#define XLP2XX_SYSCPU1PLLCTRL1_REG                      0x1c5
+#define XLP2XX_SYSCPU1PLLCTRL2_REG                      0x1c6
+#define XLP2XX_SYSCPU1PLLCTRL3_REG                      0x1c7
+
+#define XLP2XX_SYSSYSPLLCTRL0_REG                      0x240
+#define XLP2XX_SYSSYSPLLCTRL1_REG                      0x241
+#define XLP2XX_SYSSYSPLLCTRL2_REG                      0x242
+#define XLP2XX_SYSSYSPLLCTRL3_REG                      0x243
+#define XLP2XX_SYSDMCPLLCTRL0_REG                      0x244
+#define XLP2XX_SYSDMCPLLCTRL1_REG                      0x245
+#define XLP2XX_SYSDMCPLLCTRL2_REG                      0x246
+#define XLP2XX_SYSDMCPLLCTRL3_REG                      0x247
+
+#define XLP2XX_SYSDEVPLLCTRL0_REG                      0x248
+#define XLP2XX_SYSDEVPLLCTRL1_REG                      0x249
+#define XLP2XX_SYSDEVPLLCTRL2_REG                      0x24a
+#define XLP2XX_SYSDEVPLLCTRL3_REG                      0x24b
+
+#define XLP2XX_SYSDEV1PLLCTRL0_REG                      0x24c
+#define XLP2XX_SYSDEV1PLLCTRL1_REG                      0x24d
+#define XLP2XX_SYSDEV1PLLCTRL2_REG                      0x24e
+#define XLP2XX_SYSDEV1PLLCTRL3_REG                      0x24f
+
+#define XLP2XX_SYSDEV2PLLCTRL0_REG                      0x250
+#define XLP2XX_SYSDEV2PLLCTRL1_REG                      0x251
+#define XLP2XX_SYSDEV2PLLCTRL2_REG                      0x252
+#define XLP2XX_SYSDEV2PLLCTRL3_REG                      0x253
+
+#define XLP2XX_SYSCPUPLLCHGCTRL_REG                    0x288
+#define XLP2XX_SYSSYSPLLCHGCTRL_REG                    0x289
+#define XLP2XX_SYSCLKDEVDIS_REG                        0x28a
+#define XLP2XX_SYSCLKDEVSEL_REG                        0x28b
+#define XLP2XX_SYSCLKDEVDIV_REG                        0x28c
+#define XLP2XX_SYSCLKDEVCHG_REG                        0x28d
+#define XLP2XX_SYSCLKDEVSELREG_REG                     0x28e
+#define XLP2XX_SYSCLKDEVDIVREG_REG                     0x28f
+#define XLP2XX_SYSCPUPLLLOCK_REG                       0x29f
+#define XLP2XX_SYSSYSPLLLOCK_REG                       0x2a0
+#define XLP2XX_SYSPLLMEMCMD_REG                        0x2a1
+#define XLP2XX_SYSCPUPLLMEMREQ_REG                     0x2a2
+#define XLP2XX_SYSSYSPLLMEMREQ_REG                     0x2a3
+#define XLP2XX_SYSPLLMEMSTAT_REG                       0x2a4
+
+#define XLP2XX_RTC_REG_SECONDS_REG                         0x300
+#define XLP2XX_RTC_REG_MINUTES_REG                         0x301
+#define XLP2XX_RTC_REG_CENTURY_HOURS_REG                   0x302
+#define XLP2XX_RTC_REG_DAY_REG                             0x303
+#define XLP2XX_RTC_REG_DATE_REG                            0x304
+#define XLP2XX_RTC_REG_MONTH_REG                           0x305
+#define XLP2XX_RTC_REG_YEAR_REG                            0x306
+#define XLP2XX_RTC_REG_CONTROL_REG                         0x307
+#define XLP2XX_RTC_REG_STATUS_REG                          0x308
+#define XLP2XX_RTC_REG_FLAG_REG                            0x309
+#define XLP2XX_RTC_REG_CLOCK_PERIOD_REG                    0x30a
+#define XLP2XX_RTC_REG_LOCK_REG                            0x30b
+#define XLP2XX_RTC_REG_VOLT_REG                            0x30c
+#define XLP2XX_RTC_REG_TEST_REG                            0x30f
+
+/*  Reference Clock Select 00:66; 01:100; 10:125; 11:133 */
+#define XLP2XX_SYS_PWRON_RCS(x) (((x)>>18) & 0x3)
+#define XLP2XX_SYS_NAND_BOOT(x) ( ((x) & 0x1f) == 6)
+
+enum xlp2xx_sys_cfg_regs {
+	XLP2XX_RESET			= 0,
+	XLP2XX_POWER_ON_RESET_CFG	= 1,
+    	XLP2XX_EFUSE_DEVICE_CFG0	= 2,
+    	XLP2XX_EFUSE_DEVICE_CFG1        = 3,
+	XLP2XX_EFUSE_DEVICE_CFG2       	= 4,
+	XLP2XX_EFUSE_DEVICE_CFG3       	= 5,
+	XLP2XX_EFUSE_DEVICE_CFG4       	= 6,
+	XLP2XX_EFUSE_DEVICE_CFG5       	= 7,
+	XLP2XX_EFUSE_DEVICE_CFG6       	= 8,
+	XLP2XX_EFUSE_DEVICE_CFG7       	= 9,
+	XLP2XX_SYS_PLL_CTRL             = 10,
+
+	XLP2XX_CPU_RESET                            = 0xb,
+	XLP2XX_CPU_THREAD_EN                        = 0xc,
+	XLP2XX_CPUNONCOHERENTMODE                 = 0xd,
+	XLP2XX_TCU_DISABLE                         = 0xe,
+	XLP2XX_CPU_STOP                            = 0xf,
+	XLP2XX_CPU_PSWCTRL                         = 0x10,
+	XLP2XX_CPU_PWRDOWN                         = 0x11,
+	XLP2XX_CPU_MEMCLR                          = 0x12,
+
+	XLP2XX_SYSDISABLE                         = 0x14,
+	XLP2XX_SYSRESET                           = 0x15,
+	XLP2XX_CPUPSWISO                          = 0x16,
+	XLP2XX_CPUPSWSET                          = 0x17,
+	XLP2XX_CPUPSWRESET                        = 0x18,
+	XLP2XX_CPUPSWCLKEN                        = 0x19,
+	XLP2XX_CPUPSWIN                           = 0x1a,
+	XLP2XX_CPUPSWSRAMOFF                      = 0x1b,
+	XLP2XX_CPUPSWSRAMCLKEN                    = 0x1c,
+	XLP2XX_CPUSENSEAMPDLY                     = 0x1d,
+	XLP2XX_SOCSENSEAMPDLY                     = 0x1e,
+	XLP2XX_SYSCTRL0                           = 0x1f,
+	XLP2XX_SYSCTRL1                           = 0x20,
+	XLP2XX_TIMEOUTBSI                         = 0x21,
+	XLP2XX_BYTESWAP                           = 0x22,
+	XLP2XX_SYSVRMVID                          = 0x23,
+	XLP2XX_SYSPWRRAMCMD                       = 0x24,
+	XLP2XX_SYSPWRRAMADDR                      = 0x25,
+	XLP2XX_SYSPWRRAMDATA0                     = 0x26,
+	XLP2XX_SYSPWRRAMDATA1                     = 0x27,
+	XLP2XX_SYSPWRRAMDATA2                     = 0x28,
+	XLP2XX_SYSPWRUCODE                        = 0x29,
+	XLP2XX_SYSPWRSTATUS0                      = 0x2a,
+	XLP2XX_SYSPWRSTATUS1                      = 0x2b,
+	XLP2XX_SYSSTATUS                          = 0x32,
+	XLP2XX_SYSINTPOL                          = 0x33,
+	XLP2XX_SYSINTTYPE                         = 0x34,
+	XLP2XX_SYSINTSTATUS                       = 0x35,
+	XLP2XX_SYSINTENABLE0                      = 0x36,
+	XLP2XX_SYSINTENABLE1                      = 0x37,
+	XLP2XX_CPUSTOPPIC                         = 0x38,
+	XLP2XX_CPUSTOPNBU                         = 0x39,
+	XLP2XX_CPUSTOPMSG                         = 0x3a,
+	XLP2XX_CPUPSWDATAOUT                      = 0x3b,
+	XLP2XX_CPUPWRSTATUS                       = 0x3c,
+	XLP2XX_CPUMEMCLRDONE                      = 0x3d,
+	XLP2XX_SYSUCOSECC                         = 0x3f,
+	XLP2XX_SYSUCOMECC                         = 0x40,
+	XLP2XX_SYSUCOADDR                         = 0x41,
+	XLP2XX_SYSUCOINST                         = 0x42,
+	XLP2XX_SYSMEMBISTGO0                      = 0x43,
+	XLP2XX_SYSMEMBISTGO1                      = 0x44,
+	XLP2XX_SYSMEMBISTGO2                      = 0x45,
+	XLP2XX_SYSMEMBISTGO3                      = 0x46,
+	XLP2XX_SYSMEMBISTGO4                      = 0x47,
+	XLP2XX_SYSMEMBISTGO5                      = 0x48,
+	XLP2XX_SYSMEMBISTGO6                      = 0x49,
+	XLP2XX_SYSMEMBISTGO7                      = 0x4a,
+	XLP2XX_SYSMEMBISTGO8                      = 0x4b,
+	XLP2XX_SYSMEMBISTGO9                      = 0x4c,
+	XLP2XX_SYSMEMBISTGO10                     = 0x4d,
+	XLP2XX_SYSMEMBISTGO11                     = 0x4e,
+	XLP2XX_SYSMEMBISTGO12                     = 0x4f,
+	XLP2XX_SYSMEMSTAT0                        = 0x54,
+	XLP2XX_SYSMEMSTAT1                        = 0x55,
+	XLP2XX_SYSSCRATCH0                        = 0x58,
+	XLP2XX_SYSSCRATCH1                        = 0x59,
+	XLP2XX_SYSSCRATCH2                        = 0x5a,
+	XLP2XX_SYSSCRATCH3                        = 0x5b,
+	XLP2XX_SYSCOUNTER                         = 0x5c,
+	XLP2XX_SYSCTRLSECUREBOOT                  = 0x5d,
+	XLP2XX_SYSSECUREKEY                       = 0xc0,
+	XLP2XX_SYSEFUSECTRL                       = 0x140,
+	XLP2XX_SYSEFUSECMD                        = 0x141,
+	XLP2XX_SYSEFUSECMDDATA                    = 0x142,
+	XLP2XX_SYSEFUSESTAT                       = 0x14a,
+	XLP2XX_SYSTHERMCTRL                       = 0x14b,
+	XLP2XX_CPUTHERMPWRDOWN                    = 0x14c,
+	XLP2XX_SYSTHERMPWRDOWN                    = 0x14d,
+	XLP2XX_CPUTHERMEN                         = 0x14e,
+	XLP2XX_SYSTHERMEN                         = 0x14f,
+	XLP2XX_THERMTHRESH0                       = 0x150,
+	XLP2XX_THERMTHRESH1                       = 0x151,
+	XLP2XX_THERMTHRESH2                       = 0x152,
+	XLP2XX_THERMTHRESH3                       = 0x153,
+	XLP2XX_CPUTHERMINTSTATUSHIGH0             = 0x154,
+	XLP2XX_CPUTHERMINTSTATUSLOW0              = 0x155,
+	XLP2XX_SYSTHERMINTSTATUSHIGH0             = 0x156,
+	XLP2XX_SYSTHERMINTSTATUSLOW0              = 0x157,
+	XLP2XX_CPUTHERMINTSTATUSHIGH1             = 0x158,
+	XLP2XX_CPUTHERMINTSTATUSLOW1              = 0x159,
+	XLP2XX_SYSTHERMINTSTATUSHIGH1             = 0x15a,
+	XLP2XX_SYSTHERMINTSTATUSLOW1              = 0x15b,
+	XLP2XX_CPUTHERMINTSTATUSHIGH2             = 0x15c,
+	XLP2XX_CPUTHERMINTSTATUSLOW2              = 0x15d,
+	XLP2XX_SYSTHERMINTSTATUSHIGH2             = 0x15e,
+	XLP2XX_SYSTHERMINTSTATUSLOW2              = 0x15f,
+	XLP2XX_CPUTHERMINTSTATUSHIGH3             = 0x160,
+	XLP2XX_CPUTHERMINTSTATUSLOW3              = 0x161,
+	XLP2XX_SYSTHERMINTSTATUSHIGH3             = 0x162,
+	XLP2XX_SYSTHERMINTSTATUSLOW3              = 0x163,
+	XLP2XX_CPUTHERMINTENHIGH0                 = 0x164,
+	XLP2XX_CPUTHERMINTENLOW0                  = 0x165,
+	XLP2XX_SYSTHERMINTENHIGH0                 = 0x166,
+	XLP2XX_SYSTHERMINTENLOW0                  = 0x167,
+	XLP2XX_CPUTHERMINTENHIGH1                 = 0x168,
+	XLP2XX_CPUTHERMINTENLOW1                  = 0x169,
+	XLP2XX_SYSTHERMINTENHIGH1                 = 0x16a,
+	XLP2XX_SYSTHERMINTENLOW1                  = 0x16b,
+	XLP2XX_CPUTHERMINTENHIGH2                 = 0x16c,
+	XLP2XX_CPUTHERMINTENLOW2                  = 0x16d,
+	XLP2XX_SYSTHERMINTENHIGH2                 = 0x16e,
+	XLP2XX_SYSTHERMINTENLOW2                  = 0x16f,
+	XLP2XX_CPUTHERMINTENHIGH3                 = 0x170,
+	XLP2XX_CPUTHERMINTENLOW3                  = 0x171,
+	XLP2XX_SYSTHERMINTENHIGH3                 = 0x172,
+	XLP2XX_SYSTHERMINTENLOW3                  = 0x173,
+	XLP2XX_CPUTHERMCOUNT                      = 0x174,
+	XLP2XX_SYSTHERMCOUNT                      = 0x194,
+	XLP2XX_THERMCOUNT                         = 0x19c,
+
+	XLP2XX_CORE0_PLL_CTRL0		= 0x1c0,
+	XLP2XX_CORE0_PLL_CTRL1		= 0x1c1,
+	XLP2XX_CORE0_PLL_CTRL2		= 0x1c2,
+	XLP2XX_CORE0_PLL_CTRL3		= 0x1c3,
+
+	XLP2XX_CORE1_PLL_CTRL0		= 0x1c4,
+	XLP2XX_CORE1_PLL_CTRL1		= 0x1c5,
+	XLP2XX_CORE1_PLL_CTRL2		= 0x1c6,
+	XLP2XX_CORE1_PLL_CTRL3		= 0x1c7,
+
+	XLP2XX_SYS_PLL_CTRL0		= 0x240,
+	XLP2XX_SYS_PLL_CTRL1		= 0x241,
+	XLP2XX_SYS_PLL_CTRL2		= 0x242,
+	XLP2XX_SYS_PLL_CTRL3		= 0x243,
+	XLP2XX_DMC_PLL_CTRL0		= 0x244,
+	XLP2XX_DMC_PLL_CTRL1		= 0x245,
+	XLP2XX_DMC_PLL_CTRL2		= 0x246,
+	XLP2XX_DMC_PLL_CTRL3		= 0x247,
+
+	XLP2XX_DEV0_PLL_CTRL0		= 0x248,
+	XLP2XX_DEV0_PLL_CTRL1		= 0x249,
+	XLP2XX_DEV0_PLL_CTRL2		= 0x24a,
+	XLP2XX_DEV0_PLL_CTRL3		= 0x24b,
+	XLP2XX_DEV1_PLL_CTRL0		= 0x24c,
+	XLP2XX_DEV1_PLL_CTRL1		= 0x24d,
+	XLP2XX_DEV1_PLL_CTRL2		= 0x24e,
+	XLP2XX_DEV1_PLL_CTRL3		= 0x24f,
+	XLP2XX_DEV2_PLL_CTRL0		= 0x250,
+	XLP2XX_DEV2_PLL_CTRL1		= 0x251,
+	XLP2XX_DEV2_PLL_CTRL2		= 0x252,
+	XLP2XX_DEV2_PLL_CTRL3		= 0x253,
+
+	XLP2XX_CPU_PLL_CHG_CTRL		= 0x288,
+	XLP2XX_SYS_PLL_CHG_CTRL		= 0x289,
+	XLP2XX_SYS_CLK_DEV_DIS		= 0x28a,
+	XLP2XX_SYS_CLK_DEV_SEL		= 0x28b,
+	XLP2XX_SYS_CLK_DEV_DIV		= 0x28c,
+	XLP2XX_SYS_CLK_DEV_CHG		= 0x28d,
+	XLP2XX_SYS_CLK_DEV_SEL_REG	= 0x28e,
+	XLP2XX_SYS_CLK_DEV_DIV_REG	= 0x28f,
+	XLP2XX_SYS_CPU_PLL_LOCK   	= 0x29f,
+	XLP2XX_SYS_SYS_PLL_LOCK 	= 0x2a0,
+	XLP2XX_SYS_PLL_MEM_CMD    	= 0x2a1,
+	XLP2XX_SYS_CPU_PLL_MEM_REQ	= 0x2a2,
+	XLP2XX_SYS_SYS_PLL_MEM_REQ	= 0x2a3,
+	XLP2XX_SYS_PLL_MEM_STAT		= 0x2a4,
+
+	XLP2XX_RTC_REG_SECONDS          = 0x300,
+	XLP2XX_RTC_REG_MINUTES          = 0x301,
+	XLP2XX_RTC_REG_CENTURY_HOURS    = 0x302,
+	XLP2XX_RTC_REG_DAY              = 0x303,
+	XLP2XX_RTC_REG_DATE             = 0x304,
+	XLP2XX_RTC_REG_MONTH            = 0x305,
+	XLP2XX_RTC_REG_YEAR             = 0x306,
+	XLP2XX_RTC_REG_CONTROL          = 0x307,
+	XLP2XX_RTC_REG_STATUS           = 0x308,
+	XLP2XX_RTC_REG_FLAG             = 0x309,
+	XLP2XX_RTC_REG_CLOCK_PERIOD     = 0x30a,
+	XLP2XX_RTC_REG_LOCK             = 0x30b,
+	XLP2XX_RTC_REG_VOLT             = 0x30c,
+	XLP2XX_RTC_REG_TEST             = 0x30f,
+};
+
+/*1588-PTP CLOCK selection*/
+#define NET_SYS_CLK 		0
+#define INT_SYNCE_CLK		1
+#define GPIO_1588_CLK		2
+#define SGMII_REF_CLK		3
+
 #define nlm_hal_read_sys_reg(node, index) \
         nlm_hal_read_32bit_reg((xlp_sys_base[node] + 0x100), (index))
 
@@ -784,20 +1388,45 @@ enum {
 #define MAX_CPLX_BLOCK                  5
 #define MAX_LANE_PER_CPLX               4
 
-#define LANE_RX_CLK                     (1 << 0)
-#define LANE_TX_CLK                     (1 << 6)
+/*PRM: VSEMI  CONFIG REGISTERS*/
+#define VSEMI_CMD 			0x9
+#define VSEMI_CTL0			0xA
+	#define VSEMI_CTL_POR			(1<<9)
+	#define VSEMI_CTL_SYNTH_RST		(1<<10)
+	#define VSEMI_CTL_RTHR			(0xf<<12)	
+#define VSEMI_CTL1			0xB
+	#define VSEMI_CTL_XAUI_12G_DR	(0x3)		
+	#define VSEMI_CTL_XAUI_12G_DW	(1<<4)
+	#define VSEMI_CTL_XAUI_16G_DR	(0x3)	
+	#define VSEMI_CTL_XAUI_16G_DW	(0x1<<4)
+	#define VSEMI_CTL_XAUI_DR	(0x2)
+	#define VSEMI_CTL_XAUI_DW	(1<<4)
+	#define VSEMI_CTL_SGMII_DR	(0x1)
+	#define VSEMI_CTL_SGMII_DW	(0x1<<4)
+	
+#define VSEMI_STATUS			0xC
+#define VSEMI_PINCTRL			0xD
+#define VSEMI_PIN_STS			0XE
+		
+ 
 
+/*
+ * PRM: 11.10.2 PHY and PMA Controller Registers
+ */
 #define PHY_LANE_0_STATUS               0
 #define PHY_LANE_1_STATUS               1
 #define PHY_LANE_2_STATUS               2
 #define PHY_LANE_3_STATUS               3
-    #define PHY_LANE_STAT_SRCS          0x00000001
-    #define PHY_LANE_STAT_STD           0x00000010
-    #define PHY_LANE_STAT_SFEA          0x00000020
-    #define PHY_LANE_STAT_STCS          0x00000040
-    #define PHY_LANE_STAT_SPC           0x00000200
-    #define PHY_LANE_STAT_XLF           0x00000400
-    #define PHY_LANE_STAT_PCR           0x00000800
+    #define PHY_LANE_STAT_SRCS          0x00000001 /* bit 1: Rx clock stable if 1 */
+    #define PHY_LANE_STAT_STD           0x00000010 /* bit 4: Transmit Detect if 1 */
+    #define PHY_LANE_STAT_SFEA          0x00000020 /* bit 5: Far end absent if 1 */
+    #define PHY_LANE_STAT_STCS          0x00000040 /* bit 6: Tx clock stable if 1 */
+    #define PHY_LANE_STAT_SPC           0x00000200 /* bit  9: SGMII PCS Sync bit; 1:synced 0:fault*/
+    #define PHY_LANE_STAT_XLF           0x00000400 /* bit 10: XAUI lane sync bit; 0:synced 1:fault*/
+    #define PHY_LANE_STAT_PCR           0x00000800 /* bit 11: PMA Controller Ready; 1:ready */
+    //#define XAUI_LANE_FAULT                 0x400
+    #define LANE_RX_CLK                     (1 << 0)
+    #define LANE_TX_CLK                     (1 << 6)
 #define PHY_LANE_0_CTRL                 4
 #define PHY_LANE_1_CTRL                 5
 #define PHY_LANE_2_CTRL                 6
@@ -871,7 +1500,7 @@ enum {
 
     #define EXT_XG_MDIO_CTRL_PHYADDR_POS	4
     #define EXT_XG_MDIO_CTRL_REG_POS		9
-    #define EXT_XG_MDIO_CTRL_TA    	0x02 
+    #define EXT_XG_MDIO_CTRL_TA    	0x02
     #define EXT_XG_MDIO_CTRL_TA_POS     14
     #define EXT_XG_MDIO_CTRL_MIIM_POS   16
     #define EXT_XG_MDIO_CTRL_LOAD_POS   19
@@ -903,6 +1532,7 @@ enum {
     #define EXT_G_MDIO_MMRST            0x00100000
     #define EXT_G_MDIO_DIV              0x0000001E	
     #define EXT_G_MDIO_DIV_WITH_HW_DIV64 0x00000010
+    #define EXT_G_MDIO_DIV_WITH_HW_DIV64_11 0x00000011
 
 #define EXT_G0_MDIO_CTRL_DATA           0x1E
 #define EXT_G1_MDIO_CTRL_DATA           0x22
@@ -956,7 +1586,6 @@ enum {
 #define GMAC_FC_SLOT2                   0x2F
 #define GMAC_FC_SLOT3                   0x30
 
-#define XAUI_LANE_FAULT                 0x400
 #define XAUI_CONFIG_0                   0
     #define XAUI_CONFIG_MACRST          0x80000000
     #define XAUI_CONFIG_RSTRCTL         0x00400000
@@ -1030,6 +1659,15 @@ enum {
     #define XAUI_PHY_TEST_MIXED_FREQ    0x02
 
 
+#define NETIOR_HIGIG2_CTRL0		0x70
+#define NETIOR_HIGIG2_CTRL1		0x71
+#define NETIOR_HIGIG2_CTRL2		0x72
+#define NETIOR_HIGIG2_PAUSE_CTRL1	0x73
+#define NETIOR_HIGIG2_MACSA		0x74
+#define NETIOR_HIGIG2_STATUS		0x75
+#define NETIOR_HIGIG2_MISC		0x76
+
+
 #define NETIOR_XGMAC_CTRL1              0x7F
     #define NETIOR_XGMAC_RXAUI_DC_POS        30 /* Rxaui Disparity calculation */
     #define NETIOR_XGMAC_RXAUI_EN_POS        29 /* Enable RXAUI Mode */
@@ -1189,6 +1827,9 @@ enum {
 #define ILK_LARGE_COUNT_H1              0x1D
 
 // Serdes Register
+#define SER_GEN1_PWR_DOWN		0x0E
+    #define SERDES_PMFF_ALL_SET		0x04
+
 #define SERDES_PRBS_CTRL		0x64
     #define SERDES_LOOPBACK_EN		0x02
 
@@ -1319,6 +1960,17 @@ enum {
     #define USB_OHCI_INTERRUPT1_EN  	0x04
     #define USB_OHCI_INTERRUPT12_EN 	0x08
     #define USB_CTRL_INTERRUPT_EN   	0x10
+
+
+#define XLP_USB3_CTL			0x100
+#define XLP_USB3_INT			0x102
+#define XLP_USB3_INT_MASK		0x103
+#define XLP2XX_USB_PHY_TEST		0x106
+#define XLP2XX_USB_PHY_LOS_LEV		0x109
+#define XLP2XX_USB_PHY_PLL_MULT		0x10a
+#define XLP2XX_USB_REF_CLK		0x10c
+
+
 #ifndef NLM_HAL_LINUX_KERNEL		// This is not applicable in Linux
 #define XLP_NOR_IRQ			20
 #define XLP_NAND_IRQ			21
@@ -1341,6 +1993,7 @@ enum {
 
 #define XLP_PCIE_GIO_DEV		6
 #define XLP_PCIE_USB_DEV		2
+#define XLP_PCIE_USB3_DEV		4
 #define XLP_PCIE_USB_FUNC_0		0
 #define XLP_PCIE_USB_FUNC_1		1
 #define XLP_PCIE_USB_FUNC_2		2
@@ -1450,25 +2103,25 @@ enum {
 #define set_sata_glue_reg(offset, bit)          wr_sata_glue_reg(offset, (rd_sata_glue_reg(offset) | bit))
 #define clear_sata_glue_reg(offset, bit)        wr_sata_glue_reg(offset, (rd_sata_glue_reg(offset) & ~bit))
 
-#define SATA_CTL                0x00    // 
-#define SATA_STATUS             0x04    // SATA Status register
-#define SATA_INT                0x08    // SATA Interrupt Register
-#define SATA_INT_MASK           0x0c    // SATA Interrupt Mask Register
-#define SATA_CR_REG_TIMER       0x10    // PHY Conrol Timer Register
-#define SATA_CORE_ID            0x14    // SATA Core ID Register
-#define SATA_AXI_SLAVE_OPT1     0x18    // SATA AXI Slave Options Register
-#define SATA_PHY_LOS_LEV        0x1c    // SATA PHY LOS Level Register 
-#define SATA_PHY_MULTI          0x20    // SATA PHY Multiplier Register         
-#define SATA_PHY_CLK_SEL        0x24    // SATA PHY Clock Select Register
-#define SATA_PHY_AMP1_GEN1      0x28    // SATA PHY Transmit Amplitude Register 1   
-#define SATA_PHY_AMP1_GEN2      0x2c    // SATA PHY Transmit Amplitude Register 2   
-#define SATA_PHY_AMP1_GEN3      0x30    // SATA PHY Transmit Amplitude Register 3   
-#define SATA_PHY_PRE1           0x34    // SATA PHY Transmit Preemphasis Register 1
-#define SATA_PHY_PRE2           0x38    // SATA PHY Transmit Preemphasis Register 2
-#define SATA_PHY_PRE3           0x3c    // SATA PHY Transmit Preemphasis Register 3
-#define SATA_SPDMODE            0x40    // SATA Speed Mode Register
-#define SATA_REFCLK             0x44    // SATA Reference Clock Control Register
-#define SATA_BYTE_SWAP_DIS	0x74    // SATA byte swap disable
+#define XLP_HAL_SATA_CTL                0x00    // 
+#define XLP_HAL_SATA_STATUS             0x04    // SATA Status register
+#define XLP_HAL_SATA_INT                0x08    // SATA Interrupt Register
+#define XLP_HAL_SATA_INT_MASK           0x0c    // SATA Interrupt Mask Register
+#define XLP_HAL_SATA_CR_REG_TIMER       0x10    // PHY Conrol Timer Register
+#define XLP_HAL_SATA_CORE_ID            0x14    // SATA Core ID Register
+#define XLP_HAL_SATA_AXI_SLAVE_OPT1     0x18    // SATA AXI Slave Options Register
+#define XLP_HAL_SATA_PHY_LOS_LEV        0x1c    // SATA PHY LOS Level Register 
+#define XLP_HAL_SATA_PHY_MULTI          0x20    // SATA PHY Multiplier Register         
+#define XLP_HAL_SATA_PHY_CLK_SEL        0x24    // SATA PHY Clock Select Register
+#define XLP_HAL_SATA_PHY_AMP1_GEN1      0x28    // SATA PHY Transmit Amplitude Register 1   
+#define XLP_HAL_SATA_PHY_AMP1_GEN2      0x2c    // SATA PHY Transmit Amplitude Register 2   
+#define XLP_HAL_SATA_PHY_AMP1_GEN3      0x30    // SATA PHY Transmit Amplitude Register 3   
+#define XLP_HAL_SATA_PHY_PRE1           0x34    // SATA PHY Transmit Preemphasis Register 1
+#define XLP_HAL_SATA_PHY_PRE2           0x38    // SATA PHY Transmit Preemphasis Register 2
+#define XLP_HAL_SATA_PHY_PRE3           0x3c    // SATA PHY Transmit Preemphasis Register 3
+#define XLP_HAL_SATA_SPDMODE            0x40    // SATA Speed Mode Register
+#define XLP_HAL_SATA_REFCLK             0x44    // SATA Reference Clock Control Register
+#define XLP_HAL_SATA_BYTE_SWAP_DIS	0x74    // SATA byte swap disable
 
 //SATA_CTL Bits
 #define SATA_RST_N      (1 << 0)
@@ -1510,4 +2163,73 @@ enum {
 
 #define HBAReset (1 << 0)
 
+
+/* XLP BIU_NUMBER
+ * Used by 6.5.0x54.SYSDISABLE & 6.5.0x55.SYS_RESET
+ */
+#define XLP2XX_IO_NUM_OF_BIUS                16
+//sbb0
+#define XLP2XX_IO_PIC_BIU_NUMBER             0
+#define XLP2XX_IO_PCIE0_BIU_NUMBER           1
+#define XLP2XX_IO_PCIE1_BIU_NUMBER           2
+#define XLP2XX_IO_PCIE2_BIU_NUMBER           3
+#define XLP2XX_IO_PCIE3_BIU_NUMBER           4
+#define XLP2XX_IO_USB_BIU_NUMBER             5
+#define XLP2XX_IO_GDX_BIU_NUMBER             6
+#define XLP2XX_IO_CMP_BIU_NUMBER             7
+#define XLP2XX_IO_SEC_BIU_NUMBER             8
+#define XLP2XX_IO_RSA_BIU_NUMBER             9
+//sbb1
+#define XLP2XX_IO_GIO_BIU_NUMBER             10
+#define XLP2XX_IO_GBU_BIU_NUMBER             11
+#define XLP2XX_IO_NET_BIU_NUMBER             12
+#define XLP2XX_IO_MSG_BIU_NUMBER             13
+#define XLP2XX_IO_POE_BIU_NUMBER             14
+#define XLP2XX_IO_REGX_BIU_NUMBER            15
+
+
+#define XLP3XX_IO_NUM_OF_BIUS                17
+//sbb0
+#define XLP3XX_IO_PIC_BIU_NUMBER             0
+#define XLP3XX_IO_PCIE0_BIU_NUMBER           1
+#define XLP3XX_IO_PCIE1_BIU_NUMBER           2
+#define XLP3XX_IO_PCIE2_BIU_NUMBER           3
+#define XLP3XX_IO_PCIE3_BIU_NUMBER           4
+#define XLP3XX_IO_USB_BIU_NUMBER             5
+#define XLP3XX_IO_POE_BIU_NUMBER             7
+#define XLP3XX_IO_SATA_BIU_NUMBER            10
+#define XLP3XX_IO_SRIO_BIU_NUMBER            15
+#define XLP3XX_IO_REGX_BIU_NUMBER            16
+//sbb1
+#define XLP3XX_IO_GIO_BIU_NUMBER             8
+#define XLP3XX_IO_GBU_BIU_NUMBER             9
+#define XLP3XX_IO_NET_BIU_NUMBER             6
+#define XLP3XX_IO_MSG_BIU_NUMBER             11
+#define XLP3XX_IO_GDX_BIU_NUMBER             12
+#define XLP3XX_IO_SEC_BIU_NUMBER             13
+#define XLP3XX_IO_RSA_BIU_NUMBER             14
+
+
+#define XLP8XX_IO_NUM_OF_BIUS                18
+//sbb0
+#define XLP8XX_IO_ICI0_BIU_NUMBER            0
+#define XLP8XX_IO_ICI1_BIU_NUMBER            1
+#define XLP8XX_IO_ICI2_BIU_NUMBER            2
+#define XLP8XX_IO_PIC_BIU_NUMBER             3
+#define XLP8XX_IO_PCIE0_BIU_NUMBER           4
+#define XLP8XX_IO_PCIE1_BIU_NUMBER           5
+#define XLP8XX_IO_PCIE2_BIU_NUMBER           6
+#define XLP8XX_IO_PCIE3_BIU_NUMBER           7
+#define XLP8XX_IO_USB_BIU_NUMBER             8
+#define XLP8XX_IO_NET_BIU_NUMBER             9
+#define XLP8XX_IO_POE_BIU_NUMBER             10
+#define XLP8XX_IO_GIO_BIU_NUMBER             16
+#define XLP8XX_IO_GBU_BIU_NUMBER             17
+//sbb1
+#define XLP8XX_IO_MSG_BIU_NUMBER             11
+#define XLP8XX_IO_GDX_BIU_NUMBER             12
+#define XLP8XX_IO_SEC_BIU_NUMBER             13
+#define XLP8XX_IO_RSA_BIU_NUMBER             14
+#define XLP8XX_IO_CMP_BIU_NUMBER             15
+
 #endif /* #ifndef NLM_HAL_XLP_DEV_H */
diff --git a/arch/mips/include/asm/netlogic/hal/nlm_nae.h b/arch/mips/include/asm/netlogic/hal/nlm_nae.h
index 28a85c1..4df021b 100644
--- a/arch/mips/include/asm/netlogic/hal/nlm_nae.h
+++ b/arch/mips/include/asm/netlogic/hal/nlm_nae.h
@@ -1,27 +1,32 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
 
 #ifndef __NLM_NAE_H__
 #define __NLM_NAE_H__
@@ -42,7 +47,6 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define NAE_RESET_DONE		0x20
 #define NAE_INIT_VALID		0x40
 
-#define INVALID_PHY_STATUS	0xffff
 #ifndef NLM_NCPUS_PER_NODE
 #define NLM_NCPUS_PER_NODE	32
 #endif
@@ -60,6 +64,13 @@ struct nlm_nae_shinfo {
 	/* cpu to freein fifo map */
 	unsigned int cpu_2_freeinfifo_map[NLM_NAE_SH_LCPU_TO_MAP_SZ];
 };
+
+enum higig_mode{
+	NO_HIGIG,
+	HIGIG,
+	HIGIG2
+};
+
 #ifndef NLM_NUM_THREADS_PER_CORE
 #define NLM_NUM_THREADS_PER_CORE	4
 #endif
@@ -97,6 +108,9 @@ struct nlm_hal_nae_port {
         int  ext_phy_bus;
 	uint32_t  rxaui_scrambler; /* 0: disable scrambler ; 1: enable scrambler */
 	uint32_t  rxaui_mode;      /* 0: broadcom mode; 1: marvell */
+        int  loopback;
+	int higig_mode;
+	int xgmii_speed;
 };
 
 struct nlm_hal_nae_config {
@@ -149,6 +163,10 @@ struct nlm_hal_nae_config {
 	unsigned long long dummy_pktdata_addr;
 	
 	struct nlm_nae_shinfo shinfo[NLM_NAE_MAX_SHARED_DOMS  + 1]; /* 1 extra for the owner */
+	uint32_t msec_port_enable;
+	unsigned char sectag_offset[MAX_NAE_PORTS_PERNODE];
+	unsigned char sectag_len[MAX_NAE_PORTS_PERNODE];
+	unsigned char icv_len[MAX_NAE_PORTS_PERNODE];
 };
 
 typedef struct nlm_hal_nae_config * nlm_nae_config_ptr;
@@ -161,6 +179,15 @@ struct nlm_node_config
         struct fmn_cfg *fmn_cfg[NLM_MAX_NODES];
 };
 
+enum freq_config {
+	NLM_DEFAULT	= 0,
+	NLM_NAE,
+	NLM_RSA,
+	NLM_SAE,
+	NLM_DTRE,
+	NLM_CDE,
+};
+
 extern struct nlm_node_config nlm_node_cfg;
 
 enum if_type {
@@ -183,7 +210,7 @@ extern void nlm_hal_modify_nae_ucore_sram_mem(int node, int ucoreid, unsigned in
 extern void nlm_hal_read_nae_ucore_sram_mem(int node, int ucoreid, unsigned int *data, 
 		int off, int words);
 
-extern void nlm_hal_disable_xaui_flow_control(int node, int interface);
+extern void nlm_hal_disable_xaui_flow_control(int node, int block);
 
 #endif
 #endif
diff --git a/arch/mips/include/asm/netlogic/xlp_irq.h b/arch/mips/include/asm/netlogic/xlp_irq.h
index 3c29059..2064147 100644
--- a/arch/mips/include/asm/netlogic/xlp_irq.h
+++ b/arch/mips/include/asm/netlogic/xlp_irq.h
@@ -128,7 +128,6 @@ struct xlp_nodefn_struct {
 	u8 fn;
 };
 
-#define XLP_PIT_TICK_RATE	133333333
 #define XLP_PIT_TIMER_MAX	(u64)(~0ULL)
 
 extern u64 __nlh_pic_r64o(u8, u64);
diff --git a/arch/mips/netlogic/common/Makefile b/arch/mips/netlogic/common/Makefile
index f8d26ed..62c23f9 100644
--- a/arch/mips/netlogic/common/Makefile
+++ b/arch/mips/netlogic/common/Makefile
@@ -2,7 +2,7 @@
 EXTRA_CFLAGS := $(CFLAGS) -DNLM_HAL_LINUX_KERNEL -Iarch/mips/include/asm/netlogic/hal
 obj-y :=   cpu_proc.o memory.o bootinfo.o
 
-obj-$(CONFIG_NLM_XLP)			+= nlm_hal_fmn_config.o
+obj-$(CONFIG_NLM_XLP)			+= nlm_hal_fmn_config.o nlm_hal_vsemi_config.o
 obj-$(CONFIG_NLM_XLP)			+= nlm_hal_cpu_info.o nlm_hal_sys.o nlm_evp_cpld.o
 obj-$(CONFIG_NLM_XLP)			+= nlm_hal.o nlm_hal_nae.o fdt_helper.o
 obj-$(CONFIG_NLM_XLP)			+= nlm_eeprom.o
@@ -18,7 +18,7 @@ obj-$(CONFIG_SMP)                 	+= smp.o
 EXTRA_AFLAGS := $(CFLAGS)
 
 clean-files += msgring.o msgring_xls.o msgring_shared.o nlm_hal_fmn_config.o nlm_hal_cpu_info.o
-clean-files += nlm_hal_sys.o nlm_hal.o
+clean-files += nlm_hal_sys.o nlm_hal.o nlm_hal_vsemi_config.o
 clean-files += srio.o dma.o smp.o cpu_proc.o
-clean-files += msgring.c msgring_xls.c msgring_shared.c nlm_hal.c
+clean-files += msgring.c msgring_xls.c msgring_shared.c
 
diff --git a/arch/mips/netlogic/common/nlm_eeprom.c b/arch/mips/netlogic/common/nlm_eeprom.c
index ab93d13..9d23eb0 100644
--- a/arch/mips/netlogic/common/nlm_eeprom.c
+++ b/arch/mips/netlogic/common/nlm_eeprom.c
@@ -11,7 +11,7 @@
 int  eeprom_get_mac_addr(struct eeprom_data *nlm_eeprom, unsigned char *mac, int interface)
 {
 	unsigned char *eeprom_mac;
-	int offset;
+	unsigned int offset;
 	unsigned char dev_addr;
 
 	if(nlm_eeprom==NULL){
@@ -21,7 +21,7 @@ int  eeprom_get_mac_addr(struct eeprom_data *nlm_eeprom, unsigned char *mac, int
 	dev_addr = nlm_eeprom->i2c_dev_addr;
 	eeprom_mac = interface?(nlm_eeprom->mac_addr1):(nlm_eeprom->mac_addr0);
 
-	offset= interface?(((struct eeprom_data*)0)->mac_addr1):(((struct eeprom_data*)0)->mac_addr0);
+	offset= (unsigned int) (interface?(unsigned long)(((struct eeprom_data*)0)->mac_addr1):(unsigned long)(((struct eeprom_data*)0)->mac_addr0));
 	nlm_eeprom->eeprom_i2c_read_bytes(dev_addr, offset,0, eeprom_mac, MAC_LEN);
 	memcpy(mac, eeprom_mac, MAC_LEN);
 	return 0;
@@ -30,23 +30,25 @@ int  eeprom_get_mac_addr(struct eeprom_data *nlm_eeprom, unsigned char *mac, int
 int  eeprom_set_mac_addr(struct eeprom_data *nlm_eeprom, unsigned char *mac, int interface)
 {
 	unsigned char *eeprom_mac;
-	unsigned char dev_addr;
-	int offset;
+	unsigned char dev_addr,i;
+	unsigned int offset;
 	if(nlm_eeprom==NULL){
 		return -1;
 	}
-
 	dev_addr = nlm_eeprom->i2c_dev_addr;
 
 	eeprom_mac = interface?(nlm_eeprom->mac_addr1):(nlm_eeprom->mac_addr0);
-	offset= interface?(((struct eeprom_data*)0)->mac_addr1):(((struct eeprom_data*)0)->mac_addr0);
-	nlm_eeprom->eeprom_i2c_write_bytes(dev_addr, offset,0, mac, MAC_LEN);
+	for(i=0;i<6;i++){
+                eeprom_mac[i]= mac[i];
+        }
+	offset= (unsigned int)(interface?(unsigned long)(((struct eeprom_data*)0)->mac_addr1):(unsigned long)(((struct eeprom_data*)0)->mac_addr0));
+	nlm_eeprom->eeprom_i2c_write_bytes(dev_addr, offset,0, eeprom_mac, MAC_LEN);
 	return 0;
 }
 int  eeprom_get_magic_bytes(struct eeprom_data *nlm_eeprom, unsigned char *mac, int interface)
 {
         unsigned char *eeprom_mac;
-        int offset;
+        unsigned int offset;
         unsigned char dev_addr;
 
         if(nlm_eeprom==NULL){
@@ -56,11 +58,25 @@ int  eeprom_get_magic_bytes(struct eeprom_data *nlm_eeprom, unsigned char *mac,
         dev_addr = nlm_eeprom->i2c_dev_addr;
         eeprom_mac = interface?(nlm_eeprom->magic_bytes1):(nlm_eeprom->magic_bytes0);
 
-        offset= interface?(((struct eeprom_data*)0)->magic_bytes1):(((struct eeprom_data*)0)->magic_bytes0);
+        offset= (unsigned int)(interface?(unsigned long)(((struct eeprom_data*)0)->magic_bytes1):(unsigned long)(((struct eeprom_data*)0)->magic_bytes0));
         nlm_eeprom->eeprom_i2c_read_bytes(dev_addr, offset,0, eeprom_mac, MAGIC_LEN);
         memcpy(mac, eeprom_mac, MAGIC_LEN);
         return 0;
 }
+int  eeprom_dump(struct eeprom_data *nlm_eeprom, unsigned char *mac, int offset, int len)
+{
+
+        unsigned char dev_addr;
+
+        if(nlm_eeprom==NULL){
+                return -1;
+        }
+
+        dev_addr   = nlm_eeprom->i2c_dev_addr;
+
+        nlm_eeprom->eeprom_i2c_read_bytes(dev_addr, offset,0,mac,len);
+        return 0;
+}
 
 
 #ifdef NLM_HAL_LINUX_KERNEL
@@ -68,6 +84,6 @@ int  eeprom_get_magic_bytes(struct eeprom_data *nlm_eeprom, unsigned char *mac,
 EXPORT_SYMBOL(eeprom_get_mac_addr);
 EXPORT_SYMBOL(eeprom_set_mac_addr);
 EXPORT_SYMBOL(eeprom_get_magic_bytes);
-
+EXPORT_SYMBOL(eeprom_dump);
 #endif
 
diff --git a/arch/mips/netlogic/common/nlm_evp_cpld.c b/arch/mips/netlogic/common/nlm_evp_cpld.c
index ae3f32a..6483e56 100644
--- a/arch/mips/netlogic/common/nlm_evp_cpld.c
+++ b/arch/mips/netlogic/common/nlm_evp_cpld.c
@@ -1,27 +1,32 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (Netlogic). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-****************************#NETL_2#********************************/
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
 
 #ifdef NLM_HAL_LINUX_KERNEL
 #include <linux/types.h>
@@ -59,22 +64,28 @@ static inline void nlm_hal_nor_write(uint32_t reg, uint32_t val)
 
 uint16_t nlm_hal_cpld_read_16(int cs, uint16_t reg)
 {
+#ifndef CONFIG_N511
         uint16_t val;
 	if ((cs == 3) || (cs ==4))
 	        nlm_hal_nor_write(XLP_NOR_DEVPARAM + cs , 0x2f84);
 	
 	val = nlm_hal_read_16bit_reg(xlp_nor_dev[cs].base, reg);
         return (xlp_nor_dev[cs].swap ? le16_to_cpu(val): be16_to_cpu(val));
+#else
+	return 0;
+#endif
 }
 
 void nlm_hal_cpld_write_16(int cs, uint16_t val, uint16_t reg)
 {
+#ifndef CONFIG_N511
         uint16_t data = xlp_nor_dev[cs].swap ? cpu_to_le16(val): cpu_to_be16(val);
-	
 	if ((cs == 3) || (cs ==4))
 	        nlm_hal_nor_write(XLP_NOR_DEVPARAM + cs , 0x2d84);
 
         nlm_hal_write_16bit_reg(xlp_nor_dev[cs].base, reg, data);
+#else
+#endif
 }
 
 int nlm_xlp_boardver(void)
@@ -90,21 +101,25 @@ int nlm_xlp_cpldver(void)
 
 int is_xlp_evp1(void)
 {
+#ifndef CONFIG_N511
         uint16_t data = nlm_hal_cpld_read_16(2, 5);
 
         if (EVP_VER(data) == 0)
                 return 1;
         else
+#endif
                 return 0;
 }
 
 int is_xlp_evp2(void)
 {
+#ifndef CONFIG_N511
         uint16_t data = nlm_hal_cpld_read_16(2, 5);
 
         if (EVP_VER(data))
                 return 1;
         else
+#endif
                 return 0;
 }
 
@@ -189,23 +204,23 @@ int xlp_cpld_init(uint32_t cs)
 void set_gbu_frequency(int node, int frequency)
 {
 	const uint64_t mhz = 1000000;
-	uint64_t set_freq = nlm_hal_set_soc_freq(node, DFS_DEVICE_NOR, frequency * mhz);
-
-#ifdef NLM_HAL_LINUX_KERNEL
-    do_div(set_freq, mhz);
-#else
-    set_freq /= mhz;
-#endif
-	nlm_print("GBU Frequency set to %lluMHz\n", set_freq);
+	nlm_print("GBU Frequency set to %d\n", frequency);
+	if(is_nlm_xlp2xx()) {
+		nlm_hal_xlp2xx_set_clkdev_frq(node, XLP2XX_CLKDEVICE_GBU, frequency * mhz);
+	}
+	else {
+		uint64_t set_freq;
+		set_freq = nlm_hal_set_soc_freq(node, DFS_DEVICE_NOR, frequency * mhz);
+		NLM_HAL_DO_DIV(set_freq,mhz);
+		nlm_print("GBU Frequency set to %lluMHz\n", set_freq);
+	}
 }
 
 void nlm_hal_cpld_init(int node)
 {
 #if !defined(XLP_SIM) || defined(NLM_BOARD)
 	int i;
-
 	set_gbu_frequency(node, 16);
-	
 	for(i=2; i<5; i++)
         	xlp_cpld_init(i);
 #endif
diff --git a/arch/mips/netlogic/common/nlm_hal.c b/arch/mips/netlogic/common/nlm_hal.c
index 9350df0..fc3d07d 100644
--- a/arch/mips/netlogic/common/nlm_hal.c
+++ b/arch/mips/netlogic/common/nlm_hal.c
@@ -1,27 +1,32 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (Netlogic). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
 
 
 /**
@@ -51,16 +56,18 @@ THE POSSIBILITY OF SUCH DAMAGE.
 /**
 * @defgroup hal_fmn FMN Hardware Abstraction Layer APIs
 * @brief This section describes the FMN(Fast Messaging Network) HAL APIs <br>
-* 
+*
 * <b>Source:</b> libraries/hal/nlm_hal.c <br>
 * <b>Header:</b> hyperexec/srcs/drivers/hal/nlm_hal_fmn.h
 */
-#include <asm/netlogic/msgring.h>
 #include "nlm_hal.h"
 #include "nlm_hal_fmn.h"
 #include "nlm_hal_nae.h"
+#include "nlm_hal_crypto.h"
 #include "nlm_hal_xlp_dev.h"
 #include "nlm_hal_sys.h"
+#include "libfdt.h"
+#include "fdt_helper.h"
 
 /* These addresses are computed by the nlm_hal_init() */
 unsigned long xlp_io_base;
@@ -99,7 +106,7 @@ struct nlm_hal_ext_phy * get_phy_info(int inf);
 /*PHYs */
 static struct nlm_hal_ext_phy  known_ext_phys[] = {
 		{"mvs103656", 0xc97, 0, 0, 0, mvl_get_phy_status, mvl_start_an, mvl_init_phy},
-		{"bcm5461s", 0x60c1, 0, 0, 0, bcm_get_phy_status, bcm_start_an, bcm_init_phy}, 
+		{"bcm5461s", 0x60c1, 0, 0, 0, bcm_get_phy_status, bcm_start_an, bcm_init_phy},
 		{"", 0, 0, 0, 0, NULL, NULL, NULL}
 };
 static struct nlm_hal_ext_phy regs_ext_phys[MAX_PHYS];
@@ -171,7 +178,7 @@ __inline__ void nlm_hal_enumerate_pci(void)
 */
 __inline__ uint16_t nlm_hal_read_16bit_reg(uint64_t base, uint32_t index){
     return nlh_read_cfg_reg16(base + (index << 1));
-} 
+}
 /**
 * @brief nlm_hal_write_16bit_reg function is used to write 16-bit registers (e.g. CPLD)
 *
@@ -188,7 +195,7 @@ __inline__ uint16_t nlm_hal_read_16bit_reg(uint64_t base, uint32_t index){
 */
 __inline__ void nlm_hal_write_16bit_reg(uint64_t base, uint32_t index, uint16_t val){
     nlh_write_cfg_reg16(base +  (index << 1) , val);
-} 
+}
 
 /**
 * @brief nlm_hal_read_32bit_reg function is used to read 32bit registers
@@ -198,7 +205,7 @@ __inline__ void nlm_hal_write_16bit_reg(uint64_t base, uint32_t index, uint16_t
 *
 * @return
 *  - 32bit register value
-* 
+*
 * @sa nlm_hal_write_32bit_reg, nlm_hal_read_64bit_reg, nlm_hal_write_64bit_reg
 * @ingroup hal
 *
@@ -217,7 +224,7 @@ __inline__ uint32_t nlm_hal_read_32bit_reg(uint64_t base, int index)
 *
 * @return
 *  - none
-* 
+*
 * @sa nlm_hal_read_32bit_reg, nlm_hal_read_64bit_reg, nlm_hal_write_64bit_reg
 * @ingroup hal
 *
@@ -235,7 +242,7 @@ __inline__ void nlm_hal_write_32bit_reg(uint64_t base, int index, uint32_t val)
 *
 * @return
 *  - 64bit register value
-* 
+*
 * @sa nlm_hal_write_32bit_reg, nlm_hal_read_32bit_reg, nlm_hal_write_64bit_reg
 * @ingroup hal
 *
@@ -253,7 +260,7 @@ __inline__ uint64_t nlm_hal_read_64bit_reg(uint64_t base, int index)
 *
 * @return
 *  - none
-* 
+*
 * @sa nlm_hal_write_32bit_reg, nlm_hal_read_32bit_reg, nlm_hal_read_64bit_reg
 * @ingroup hal
 *
@@ -267,7 +274,7 @@ __inline__ void nlm_hal_write_64bit_reg(uint64_t base, int index, uint64_t val)
  *    Generic Devices
  */
 /**
-* @brief nlm_hal_get_dev_base function is used to get device base address 
+* @brief nlm_hal_get_dev_base function is used to get device base address
 *
 * @param [in] node Node ID
 * @param [in] bus Bus ID
@@ -276,7 +283,7 @@ __inline__ void nlm_hal_write_64bit_reg(uint64_t base, int index, uint64_t val)
 *
 * @return
 *  - Physical address of the base address for a given (node, bus, device, function) combination
-* 
+*
 * @ingroup hal
 *
 */
@@ -285,9 +292,9 @@ __inline__ uint64_t nlm_hal_get_dev_base(int node, int bus, int dev, int func)
 	uint64_t base = xlp_io_base & 0x1fffffff;
 
 	return (uint64_t)  (base +
-			    (bus << 20) +    
-			    (dev << 15) +    
-			    (node*8 << 15) + 
+			    (bus << 20) +
+			    (dev << 15) +
+			    (node*8 << 15) +
 			    (func << 12));
 }
 
@@ -295,6 +302,27 @@ __inline__ uint64_t nlm_hal_get_dev_base(int node, int bus, int dev, int func)
  *     FMN
  */
 /**
+* @brief nlm_hal_send_msg4 function is a non-blocking API used to send a three entry message to a mailbox. Does not retry the send message. Performs a sync before sending.
+*
+* @param [in] dst Destination Message Queue number
+* @param [in] code 8b SW code to send with the message
+* @param [in] data0 64b data value for the first message
+* @param [in] data1 64b data value for the second message
+* @param [in] data2 64b data value for the third message
+* @param [in] data3 64b data value for the fourth message
+*
+* @return
+*  - 0 on success, TxMsgStatus register on failure
+*
+* @ingroup hal_fmn
+*
+*/
+__inline__ uint32_t nlm_hal_send_msg4(uint32_t dst, uint32_t code, uint64_t data0, uint64_t data1, uint64_t data2, uint64_t data3)
+{
+	return nlh_send_msg4(dst, code, data0, data1, data2, data3);
+}
+
+/**
 * @brief nlm_hal_send_msg3 function is a non-blocking API used to send a three entry message to a mailbox. Does not retry the send message. Performs a sync before sending.
 *
 * @param [in] dst Destination Message Queue number
@@ -305,7 +333,7 @@ __inline__ uint64_t nlm_hal_get_dev_base(int node, int bus, int dev, int func)
 *
 * @return
 *  - 0 on success, TxMsgStatus register on failure
-* 
+*
 * @ingroup hal_fmn
 *
 */
@@ -324,7 +352,7 @@ __inline__ uint32_t nlm_hal_send_msg3(uint32_t dst, uint32_t code, uint64_t data
 *
 * @return
 *  - 0 on success, TxMsgStatus register on failure
-* 
+*
 * @ingroup hal_fmn
 *
 */
@@ -341,7 +369,7 @@ __inline__ uint32_t nlm_hal_send_msg2(uint32_t dst, uint32_t code, uint64_t data
 *
 * @return
 *  - 0 on success, TxMsgStatus register on failure
-* 
+*
 * @ingroup hal_fmn
 *
 */
@@ -361,7 +389,7 @@ __inline__ uint32_t nlm_hal_send_msg1(uint32_t dst, uint32_t code, uint64_t data
 *
 * @return
 *  - "0" on receive success, "-1" on failure
-* 
+*
 * @ingroup hal_fmn
 *
 */
@@ -380,7 +408,7 @@ __inline__ uint32_t nlm_hal_recv_msg2(uint32_t dst, uint32_t *src, uint32_t *siz
 *
 * @return
 *  - "0" on receive success, "-1" on failure
-* 
+*
 * @ingroup hal_fmn
 *
 */
@@ -389,15 +417,6 @@ __inline__ uint32_t nlm_hal_recv_msg1(uint32_t dst, uint32_t *src, uint32_t *siz
 	return nlh_recv_msg1(dst, src, size, code, data0);
 }
 
-__inline__ uint32_t nlm_hal_pop_msg2(uint32_t dst, uint32_t src, uint32_t code, uint64_t data0, uint64_t data1)
-{
-	return nlh_pop_msg2(dst, src, code, data0, data1);
-}
-__inline__ uint32_t nlm_hal_pop_msg1(uint32_t dst, uint32_t src, uint32_t code, uint64_t data0)
-{
-	return nlh_pop_msg1(dst, src, code, data0);
-}
-
 __inline__ int nlm_hal_is_xlp_a0(void)
 {
 	/* XXX: read register to determine stepping */
@@ -411,6 +430,87 @@ __inline__ int nlm_hal_is_xlp_le(void)
 	return little_endian;
 }
 
+/*
+ * @brief nlm_hal_get_fdt_freq function is used to read the frequency specified in the fdt file.
+ *
+ * @param [in]  pointer to the fdt file
+ * @param [in]  block for whych we need the frequency.
+ *
+ * @return
+ * actual frequency on success & "-1" if the frency is not specified in fdt file.
+ *
+ * @ingroup hal
+ *
+ **/
+int nlm_hal_get_fdt_freq(void *fdt, int type)
+{
+	int freq;
+	int ret = 250;  /* Set the default frequency to 250 */
+	char path_str[50];
+
+	sprintf(path_str,"/frequency-config");
+
+	switch(type)
+	{
+	case NLM_NAE:
+		if(copy_fdt_prop(fdt, path_str, "nae", PROP_CELL, &freq, sizeof(uint32_t)) < 0)
+			nlm_print("Unable to find the frequency in the FDT file for type:%d, \
+					using the default value\n", type);
+		else
+			ret = freq;
+#ifdef FREQ_DEBUG
+		nlm_print("nae frequency is %d\n", ret);
+#endif
+		break;
+	case NLM_RSA:
+		if(copy_fdt_prop(fdt, path_str, "rsa", PROP_CELL, &freq, sizeof(uint32_t)) < 0)
+			nlm_print("Unable to find the frequency in the FDT file for type:%d, \
+					using the default value\n", type);
+		else
+			ret = freq;
+#ifdef FREQ_DEBUG
+		nlm_print("rsa frequency is %d\n", ret);
+#endif
+		break;
+	case NLM_SAE:
+		if(copy_fdt_prop(fdt, path_str, "sae", PROP_CELL, &freq, sizeof(uint32_t)) < 0)
+			nlm_print("Unable to find the frequency in the FDT file for type:%d, \
+					using the default value\n", type);
+		else
+			ret = freq;
+#ifdef FREQ_DEBUG
+		nlm_print("sae frequency is %d\n", ret);
+#endif
+		break;
+	case NLM_DTRE:
+		if(copy_fdt_prop(fdt, path_str, "dtre", PROP_CELL, &freq, sizeof(uint32_t)) < 0)
+			nlm_print("Unable to find the frequency in the FDT file for type:%d, \
+					using the default value\n", type);
+		else
+			ret = freq;
+#ifdef FREQ_DEBUG
+		nlm_print("sae frequency is %d\n", ret);
+#endif
+		break;
+	case NLM_CDE:
+		if(copy_fdt_prop(fdt, path_str, "cde", PROP_CELL, &freq, sizeof(uint32_t)) < 0)
+			nlm_print("Unable to find the frequency in the FDT file for type:%d, \
+					using the default value\n", type);
+		else
+			ret = freq;
+#ifdef FREQ_DEBUG
+		nlm_print("sae frequency is %d\n", ret);
+#endif
+		break;
+	default:
+		{
+			nlm_print("Frequency not specified in the FDT file for type:%d", type);
+			ret = -1;
+		}
+	}
+	return ret;
+}
+
 /* Main initialization */
 /**
 * @brief nlm_hal_init function is used to Initialize HAL
@@ -420,7 +520,7 @@ __inline__ int nlm_hal_is_xlp_le(void)
 *
 * @note
 *    This function must be the first to be called before any other HAL API's
-* 
+*
 * @ingroup hal
 *
 */
@@ -450,6 +550,7 @@ __inline__ void nlm_hal_init(void)
 		xlp_fmn_base[node] = mask & nlm_hal_read_32bit_reg((0x18000000 + XLP_CFG_BASE(node, XLP_FMN)), PCI_MEM_BAR_0);
 
 		xlp_mac_base[node] = mask & nlm_hal_read_32bit_reg((0x18000000 + XLP_CFG_BASE(node, XLP_NAE)), PCI_MEM_BAR_0); //0x18018000
+		//printf("Node:%d NAE_MAC_Base:%lX\n", node, xlp_mac_base[node]);
 		xlp_nae_base[node] = xlp_mac_base[node] + 0xe000;
 
 		xlp_poe_base_pcim[node] = mask & nlm_hal_read_32bit_reg((0x18000000 + XLP_CFG_BASE(node, XLP_POE)), PCI_MEM_BAR_0);	//0x18019000
@@ -461,16 +562,19 @@ __inline__ void nlm_hal_init(void)
 
         xlp_rsa_base = (xlp_io_base | XLP_CFG_BASE(0, XLP_RSA)) & 0x1fffffff; /* For now . Will be fixed soon.*/
 
-       	if (is_nlm_xlp3xx()) {
+	if ( is_nlm_xlp3xx() || is_nlm_xlp2xx() ) {
 		xlp_regex_base_pcie = (xlp_io_base | (XLP_CFG_BASE(0, XLP_3XX_REGEX))) & 0x1fffffff;
 	        xlp_regex_base_pcim = mask & nlm_hal_read_32bit_reg((0x18000000 + XLP_CFG_BASE(0, XLP_3XX_REGEX)), PCI_MEM_BAR_0);
-                nlm_print("Regex (netl7) vendor_device id: %#x xlp_regex_base_pcim %#lx xlp_regex_base_pcie %#lx\n",
-                               nlm_hal_read_32bit_reg(xlp_regex_base_pcie, 0), xlp_regex_base_pcim, xlp_regex_base_pcie);
+		nlm_print("xlp3xx/2xx Regex (netl7) vendor_device id:%#x\n"
+			"xlp_regex_base_pcim:%#lx\n"
+			"xlp_regex_base_pcie:%#lx\n",
+			nlm_hal_read_32bit_reg(xlp_regex_base_pcie, 0),
+			xlp_regex_base_pcim, xlp_regex_base_pcie);
        	}
 
 #if !defined(NLM_HAL_UBOOT)
 #ifndef CONFIG_N511
-        	nlm_hal_cpld_init(0);	
+        	nlm_hal_cpld_init(0);
 #endif
 #endif
 
@@ -506,6 +610,7 @@ EXPORT_SYMBOL(nlm_hal_recv_msg1);
 EXPORT_SYMBOL(nlm_hal_send_msg2);
 EXPORT_SYMBOL(nlm_hal_recv_msg2);
 EXPORT_SYMBOL(nlm_hal_send_msg3);
+EXPORT_SYMBOL(nlm_hal_send_msg4);
 #else
 #include "nlm_hal_pic.h"
 /*
@@ -664,7 +769,7 @@ int irt_irq_table[160][4]= {
         {50,    0,      0,      0},     /*PICIRT_PIC                140	*/
         {0,     0,      0,      0},     /*Reserved                  141	*/
         {0,     0,      0,      0},     /*Reserved                  142	*/
-        {31,    0,      0,      0},     /*XLP_SATA		    143	*/
+        {0,     0,      0,      0},     /*Reserved                  143 */
         {0,     0,      0,      0},     /*Reserved        	    144	*/
         {0,     0,      0,      0},     /*Reserved        	    145	*/
         {13,    0,      0,      0},     /*PICIRT_GPIO_INDEX(0)      146	*/
@@ -816,50 +921,6 @@ void nlm_hal_unrequest_shared_irq(int irt)
         return;
 }
 
-void nlm_hal_set_irt_to_cpu(int irt, int cpu)
-{
-        int val;
-
-        val = nlm_hal_read_pic_reg(nlm_hal_pic_offset(), PIC_IRT(irt));
-        /* clear DB and DTE field */
-        val &= ~( 0x7<<16 | 0xf);
-        val |= (1 << 19 |((cpu-1)/16)<<16 | cpu && 0xf );
-        nlm_hal_write_pic_reg(nlm_hal_pic_offset(), PIC_IRT(irt),val);
-}
-
-void nlm_hal_set_irq_to_cpu(int irq, int cpu)
-{
-        int val, irt, i, num_shared = 0, base_irt = 0;
-
-        irt = find_irt_from_irq(irq);
-
-        if(irt < 0 || irt > PIC_NUM_IRTS)
-                return;
-
-        if(irt_irq_table[irt][1] == NOT_SHARED)
-        {
-                val = nlm_hal_read_pic_reg(nlm_hal_pic_offset(), PIC_IRT(irt));
-                val |= ( ((cpu-1)/16)<<16 | cpu && 0xf );
-                nlm_hal_write_pic_reg(nlm_hal_pic_offset(), PIC_IRT(irt),val);
-        }
-        else
-        {
-                for(i = 0; i < PIC_NUM_IRTS; i++)
-                {
-                        if( irq == irt_irq_table[i][0])
-                        {
-                                base_irt = i;
-                                num_shared = irt_irq_table[i][2];
-                                break;
-                        }
-                }
-                for(i = base_irt; i < base_irt+num_shared; i++)
-                {
-                        nlm_hal_set_irt_to_cpu( i, cpu);
-                }
-        }
-        return;
-}
 
 unsigned long tlb_size_to_page_size(unsigned long size)
 {
@@ -913,7 +974,7 @@ static void dump_phy_regs(int node, int inf)
         nlm_print("Page2 media Reg %x\n",nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, nae_cfg->ports[j].phy_bus, BLOCK_7, LANE_CFG, nae_cfg->ports[j].phy_addr, 10));
 	nlm_print("Page2 Reg26 (Bypass) %x\n",nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, nae_cfg->ports[j].phy_bus, BLOCK_7, LANE_CFG, nae_cfg->ports[j].phy_addr, 26));
 	nlm_print("Page2 SGMII sync %x\n",nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, nae_cfg->ports[j].phy_bus, BLOCK_7, LANE_CFG, nae_cfg->ports[j].phy_addr, 17));
-	
+
 	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, nae_cfg->ports[j].phy_bus, BLOCK_7, LANE_CFG, nae_cfg->ports[j].phy_addr, 22, 0x0);
 }
 #endif
@@ -926,7 +987,7 @@ static void dump_phy_regs(int node, int inf)
 *
 * @return
 * 	- none
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -948,7 +1009,7 @@ void nlm_hal_init_ext_phy(int node, int inf)
 *
 * @return
 * 	- none
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -959,7 +1020,7 @@ static void bcm_init_phy(struct nlm_hal_ext_phy *phy, int node)
 	int int_inf = phy->inf;
 	int status=0;
 	nlm_print("BCM_INIT_PHY \n ");
-	
+
 	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x04, 0x01); // selector field
 	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, 0); // disable XLP AN
 	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, 0x8000); // soft reset
@@ -970,10 +1031,10 @@ static void bcm_init_phy(struct nlm_hal_ext_phy *phy, int node)
 	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C);
 	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x1c, (status | (1<<15)| (0x1)));
 	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x0, 0x100 ); /*Disable AN*/
-	
-	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x0);	
+
+	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x0);
 	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x0, status | (1<<12) ); /*Enable AN on SGMMII side of PHY*/
-	status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf,  0x0);	
+	status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf,  0x0);
 	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, status|(1<<12)); // Enable XLP AN
 	return;
 }
@@ -986,7 +1047,7 @@ static void bcm_init_phy(struct nlm_hal_ext_phy *phy, int node)
 *
 * @return
 * 	- none
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -1023,7 +1084,7 @@ static void mvl_init_phy(struct nlm_hal_ext_phy *phy, int node)
 *
 * @return
 * 	- none
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -1034,7 +1095,7 @@ void nlm_hal_ext_phy_an(int node, int inf)
 	if(!this_phy)
 		return;
 	this_phy->start_phy_an(this_phy, node);
-	return;	
+	return;
 }
 
 /**
@@ -1045,7 +1106,7 @@ void nlm_hal_ext_phy_an(int node, int inf)
 *
 * @return
 * 	- none
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -1072,11 +1133,11 @@ static void bcm_start_an(struct nlm_hal_ext_phy *phy, int node)
 		status = nlm_hal_mdio_read(NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1);
 		if(status & (1<<5)){ /* check for autonegotiation to be completed */
 			nlm_print("Autonegotiation is OK for phyaddr=0x%x \n", phyaddr);
-			break;	
+			break;
 		}
 		status = -1;
         }while(count<50);
-	
+
 	if(status<0){
 		nlm_print("Autonegotiation is NOT OK for phyaddr=0x%x \n", phyaddr);
 		return;
@@ -1088,10 +1149,10 @@ static void bcm_start_an(struct nlm_hal_ext_phy *phy, int node)
 	//nlm_hal_mdio_write(NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x1c, 0x7c00);
 	//status = nlm_hal_mdio_read(NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C);
 	//nlm_hal_mdio_write(NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x1c, (status | (1<<15)| (0x1)));
-	//status = nlm_hal_mdio_read(NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x0);	
+	//status = nlm_hal_mdio_read(NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x0);
 	//nlm_hal_mdio_write(NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr,  0x0, status|(1<<9)); /*Restart AN on SGMMII side of PHY*/
 	//nlm_mdelay(1000);
-	status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf,  0x0);	
+	status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf,  0x0);
 	nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, status|(1<<9)); // Restart XLP AN
 	/*Wait for XLP<->SGMII-PHY AN to be OK*/
 	count=0;
@@ -1100,10 +1161,10 @@ static void bcm_start_an(struct nlm_hal_ext_phy *phy, int node)
 		count++;
 		status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x1);
 		if(status & (1<<5)){ /* check for autonegotiation to be completed */
-			nlm_print("Autonegotiation is OK with PHY-SGMII =0x%x \n", int_inf);	
+			nlm_print("Autonegotiation is OK with PHY-SGMII =0x%x \n", int_inf);
 			return;
 		}
-		status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf,  0x0);	
+		status = nlm_hal_mdio_read(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf,  0x0);
 		nlm_hal_mdio_write(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG, int_inf, 0x00, status|(1<<9)); // Restart XLP AN
         }while(count<100);
 
@@ -1119,7 +1180,7 @@ static void bcm_start_an(struct nlm_hal_ext_phy *phy, int node)
 *
 * @return
 * 	- none
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -1128,7 +1189,7 @@ static void mvl_start_an(struct nlm_hal_ext_phy *phy, int node)
         uint32_t i=0;
         volatile uint16_t val, status, extstatus;
 #ifdef PHY_DEBUG
-        uint16_t speed, duplex = 0; 
+        uint16_t speed, duplex = 0;
 #endif
 	int phyaddr = phy->phy_addr;
 	int bus = phy->ext_mdio_bus;
@@ -1143,15 +1204,16 @@ static void mvl_start_an(struct nlm_hal_ext_phy *phy, int node)
 #endif
 	i=0;
         do {
-		nlm_mdelay(100);
                 status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 1);
                 extstatus = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 17);
-		if (((status & 0x0024) == 0x0024) && (extstatus & 0x0400))
+		if (((status & 0x0024) == 0x0024) && (extstatus & 0x0400)) {
+			nlm_print("bus:%d phy:%d Autonegotiation ok:%X %X i:%d\n", bus, phyaddr, status, extstatus, i);
 			break;
+		}
+		nlm_mdelay(1);
 		i++;
-        }while(i<50);
-		nlm_mdelay(1000);
-
+        }while(i<5000);
+        if(i==5000) nlm_print(" bus:%d phy:%d auto negotiation timeout!\n", bus, phyaddr);
 
 #ifdef PHY_DEBUG
         switch(speed) {
@@ -1182,7 +1244,7 @@ static void mvl_start_an(struct nlm_hal_ext_phy *phy, int node)
 *
 * @return
 * 	- 1 - Link up, 0 - Link Down
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -1195,7 +1257,7 @@ static int bcm_get_phy_status(struct nlm_hal_ext_phy *phy, uint32_t *speed, uint
 	//int int_inf = phy->inf;
 
 	bcm_start_an(phy, node);
-	
+
 	/*switch to Copper registers mode*/
 	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C, 0x7c00);
 	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1C);
@@ -1206,53 +1268,53 @@ static int bcm_get_phy_status(struct nlm_hal_ext_phy *phy, uint32_t *speed, uint
 			*speed = SPEED_1000M;
 			*duplex = 1;
 		break;
-		
-		case 0x6: 		 
+
+		case 0x6:
 			*speed = SPEED_1000M;
 			*duplex = 0;
 		break;
-		
-		case 0x5: 		 
+
+		case 0x5:
 			*speed = SPEED_100M;
 			*duplex = 1;
 		break;
-		
-		case 0x3: 		 
+
+		case 0x3:
 			*speed = SPEED_100M;
 			*duplex = 0;
 		break;
-		
-		case 0x2: 		 
+
+		case 0x2:
 			*speed = SPEED_10M;
 			*duplex = 1;
 		break;
-		
-		case 0x1: 		 
+
+		case 0x1:
 			*speed = SPEED_10M;
 			*duplex = 0;
 		break;
-		
+
 		default:
-			nlm_print("Unknown operating speed\n");	
+			nlm_print("Unknown operating speed\n");
 		break;
-	}	
+	}
 
 //#ifdef PHY_DEBUG
-	if(*speed==SPEED_1000M)	
+	if(*speed==SPEED_1000M)
 		nlm_print("Configured with Speed  1000M");
-	if(*speed==SPEED_100M)	
+	if(*speed==SPEED_100M)
 		nlm_print("Configured with Speed 100M");
-	if(*speed==SPEED_10M)	
+	if(*speed==SPEED_10M)
 		nlm_print("Configured with Speed 10M");
-        
+
 	((*duplex == 1) ? nlm_print("Full duplex\n"):nlm_print("Half duplex\n"));
 //#endif
 	status = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 0x1);
 	if(status & (1<<2)){
-		//nlm_print("Link is up : %x\n", status);
+		nlm_print("bus:%d phy:%d Link is up : %x\n", bus, phyaddr, status);
 		return 1;
 	}else{
-		//nlm_print("Link is down : %x\n", status);
+		nlm_print("bus:%d phy:%d Link is down : %x\n", bus, phyaddr, status);
 		return 0;
 	}
 }
@@ -1267,7 +1329,7 @@ static int bcm_get_phy_status(struct nlm_hal_ext_phy *phy, uint32_t *speed, uint
 *
 * @return
 * 	- 1 - Link up, 0 - Link Down
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -1276,20 +1338,20 @@ static int mvl_get_phy_status(struct nlm_hal_ext_phy *phy, uint32_t *speed, uint
 	uint16_t extstatus;
 	int phyaddr = phy->phy_addr;
 	int bus = phy->ext_mdio_bus;
-	
+
 	nlm_hal_mdio_write(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 22, 0);
         extstatus = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, bus, BLOCK_7, LANE_CFG, phyaddr, 17);
         *speed = (extstatus >> 14) & 0x3;
         *duplex =  (extstatus >> 13) & 0x1;
 	if (extstatus & 0x0400) {
-		nlm_print("Link is up : %x\n",extstatus);
+		nlm_print("bus:%d phy:%d Link is up : %x\n", bus, phyaddr, extstatus);
 		return 1;
 	}
 	else {
-		nlm_print("Link is down : %x\n",extstatus);
+		nlm_print("bus:%d phy:%d Link is down : %x\n",bus, phyaddr, extstatus);
 		return 0;
 	}
-	
+
 }
 
 /**
@@ -1300,7 +1362,7 @@ static int mvl_get_phy_status(struct nlm_hal_ext_phy *phy, uint32_t *speed, uint
 * @return
 * 	- Pointer to external phy information structure
 * 	- NULL if no registered external phy exists for inf
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -1328,7 +1390,7 @@ struct nlm_hal_ext_phy* get_phy_info(int inf)
 *
 * @return
 * 	- none
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -1356,7 +1418,7 @@ void register_phy(int node, int inf, int* hw_portid)
 #endif
 	phy_addr = nae_cfg->ports[i].ext_phy_addr;
 	ext_mdio_bus = nae_cfg->ports[i].ext_phy_bus;
-	nlm_print("register_phy with inf=0x%x phy_addr=0%x ext_mdio_bus=0x%x\n", inf, phy_addr, ext_mdio_bus);
+	//nlm_print("register_phy with inf=0x%x phy_addr=0%x ext_mdio_bus=0x%x\n", inf, phy_addr, ext_mdio_bus);
 
 	*hw_portid = phy_addr;
 	/* make a inf and hw_port id pair*/
@@ -1371,7 +1433,7 @@ void register_phy(int node, int inf, int* hw_portid)
 			regs_ext_phys[i].inf = inf;
 			return;
 #endif
-		}	
+		}
 	}
 	*hw_portid = -1;
 	nlm_print("Could not find the given interface\n");
@@ -1384,7 +1446,7 @@ void register_phy(int node, int inf, int* hw_portid)
 *
 * @return
 * 	- none
-* 
+*
 * @ingroup hal_nae
 *
 */
@@ -1393,20 +1455,20 @@ void sgmii_scan_phys(int node)
 	int phyid, inf;
 	int j;
 	int reg_idx=0;
-	
+
 	/*init regs_ext_phys data*/
 	for (j=0; j<MAX_PHYS; j++){
 		regs_ext_phys[j].phy_get_status =  NULL;
 		regs_ext_phys[j].start_phy_an =  NULL;
 		regs_ext_phys[j].ext_phy_init =  NULL;
-		regs_ext_phys[j].phy_addr = 0xff;	
+		regs_ext_phys[j].phy_addr = 0xff;
 		regs_ext_phys[j].inf = -1;
 	}
 	/* scan all PHYs available on both ext MDIOs */
 	/* check with phys IDs against registered phys */
 
 	/*BUS1*/
-	if(!is_nlm_xlp3xx()){ /*Only one mdio controller on Storm*/
+	if(!(is_nlm_xlp3xx() || is_nlm_xlp2xx())){ /*Only one mdio controller*/
 		nlm_print("Scanning MDIO external BUS1----\n");
 		for(inf=0; inf<31; inf++){
 			phyid = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, 1, BLOCK_7, LANE_CFG, inf, 3);
@@ -1416,13 +1478,13 @@ void sgmii_scan_phys(int node)
 					regs_ext_phys[reg_idx].phy_get_status =  known_ext_phys[j].phy_get_status;
 					regs_ext_phys[reg_idx].start_phy_an =  known_ext_phys[j].start_phy_an;
 					regs_ext_phys[reg_idx].ext_phy_init =  known_ext_phys[j].ext_phy_init;
-					regs_ext_phys[reg_idx].phy_addr = inf;	
-					regs_ext_phys[reg_idx].inf = -1;	
-					nlm_print("Found port with 1st bus and phy_addr =0x%x phy-idfer =0x%x\n ", regs_ext_phys[reg_idx].phy_addr, phyid);
+					regs_ext_phys[reg_idx].phy_addr = inf;
+					regs_ext_phys[reg_idx].inf = -1;
+					//nlm_print("Found port with 1st bus and phy_addr =0x%x phy-idfer =0x%x\n ", regs_ext_phys[reg_idx].phy_addr, phyid);
 					reg_idx++;
 				}
 			}
-		
+
 		}
 	}
 	nlm_print("Scanning MDIO external BUS0----\n");
@@ -1431,20 +1493,20 @@ void sgmii_scan_phys(int node)
 		phyid = nlm_hal_mdio_read(node, NLM_HAL_EXT_MDIO, 0, BLOCK_7, LANE_CFG, inf, 3);
 		for(j=0; j < sizeof(known_ext_phys)/ sizeof(struct nlm_hal_ext_phy); j++){
 			if(phyid == known_ext_phys[j].phy_idfer){
-				
+
 				regs_ext_phys[reg_idx].ext_mdio_bus = 0;
 				regs_ext_phys[reg_idx].phy_get_status =  known_ext_phys[j].phy_get_status;
 				regs_ext_phys[reg_idx].start_phy_an =  known_ext_phys[j].start_phy_an;
 				regs_ext_phys[reg_idx].ext_phy_init =  known_ext_phys[j].ext_phy_init;
-				regs_ext_phys[reg_idx].phy_addr = inf;	
-				regs_ext_phys[reg_idx].inf = -1;	
-				nlm_print("Found port with 0th bus and phy_addr =0x%x phy-idfer=0x%x\n ", regs_ext_phys[reg_idx].phy_addr, phyid);
+				regs_ext_phys[reg_idx].phy_addr = inf;
+				regs_ext_phys[reg_idx].inf = -1;
+				//nlm_print("Found port with 0th bus and phy_addr =0x%x phy-idfer=0x%x\n ", regs_ext_phys[reg_idx].phy_addr, phyid);
 				reg_idx++;
 			}
 		}
-		
+
 	}
-	
+
 	reg_num_phys =  reg_idx;
 	nlm_print("Total PHYs found = %d\n", reg_idx);
 }
@@ -1488,35 +1550,36 @@ void nlm_hal_dtr_init(void)
 *
 * @return
 * 	- none
-* 
+*
 * @ingroup hal_sae
 *
 */
 void nlm_hal_set_sae_freq(int node, int freq)
 {
 	const uint64_t mhz = 1000000;
-	uint64_t set_freq = nlm_hal_set_soc_freq(0, DFS_DEVICE_SAE, freq * mhz);
-
-#ifdef NLM_HAL_LINUX_KERNEL
-    do_div(set_freq, mhz);
-#else
-    set_freq /= mhz;
-#endif
-	nlm_print("SAE Frequency set to %lluMHz\n", set_freq);
+	nlm_print("-- SAE Frequency set to %d\n", freq);
+	if(is_nlm_xlp2xx()) {
+		nlm_hal_xlp2xx_set_clkdev_frq(node, XLP2XX_CLKDEVICE_SAE, freq * mhz);
+	}
+	else {
+		uint64_t set_freq = nlm_hal_set_soc_freq(node, DFS_DEVICE_SAE, freq * mhz);
+		NLM_HAL_DO_DIV(set_freq, mhz);
+		nlm_print("SAE Frequency set to %lluMHz\n", (unsigned long long)set_freq);
+	}
 }
 
 void nlm_hal_set_rsa_freq(int node, int freq)
 {
 	const uint64_t mhz = 1000000;
-	uint64_t set_freq = nlm_hal_set_soc_freq(0, DFS_DEVICE_RSA, freq * mhz);
-
-#ifdef NLM_HAL_LINUX_KERNEL
-    do_div(set_freq, mhz);
-#else
-    set_freq /= mhz;
-#endif
-
-	nlm_print("RSA Frequency set to %lluMHz\n", set_freq);
+	nlm_print("--RSA Frequency set to %d\n", freq);
+	if(is_nlm_xlp2xx()) {
+		nlm_hal_xlp2xx_set_clkdev_frq(node, XLP2XX_CLKDEVICE_RSA, freq * mhz);
+	}
+	else {
+		uint64_t set_freq = nlm_hal_set_soc_freq(0, DFS_DEVICE_RSA, freq * mhz);
+		NLM_HAL_DO_DIV(set_freq, mhz);
+		nlm_print("RSA Frequency set to %lluMHz\n", (unsigned long long)set_freq);
+	}
 }
 
 
@@ -1531,24 +1594,31 @@ void nlm_hal_set_rsa_cge(int node, int enable)
 	nlm_hal_write_rsa_reg(NLM_RSA_CFG_REG, d32);
 }
 
+#define NLM_SAE_ENGINE_SELECT_REG_0 0x41
 void nlm_hal_set_sae_engine_sel(int node)
 {
 	int i, n;
-#define NLM_SAE_ENGINE_SELECT_REG_0 0x41
+	if(is_nlm_xlp2xx()) {
+		return;
+	}
 	if(is_nlm_xlp3xx())
 		n = 1;
 	else
 		n = 8;
-    for (i = 0; i < n; i++) {
-        nlm_hal_write_sae_reg(node, NLM_SAE_ENGINE_SELECT_REG_0 + i, 0x00FFFFFF);
-    }
+
+	for (i = 0; i < n; i++) {
+		nlm_hal_write_sae_reg(node, NLM_SAE_ENGINE_SELECT_REG_0 + i, 0x00FFFFFF);
+	}
 }
 
-void nlm_hal_set_rsa_engine_sel(void) 
+#define NLM_RSA_ENGINE_SELECT_REG_0 0x41
+void nlm_hal_set_rsa_engine_sel(void)
 {
 	int i, n;
 	unsigned int val;
-#define NLM_RSA_ENGINE_SELECT_REG_0 0x41
+	if(is_nlm_xlp2xx()) {
+		return;
+	}
 	if(is_nlm_xlp3xx()) {
 		n = 1;
 		val = 0xffff;
@@ -1556,9 +1626,9 @@ void nlm_hal_set_rsa_engine_sel(void)
 		n = 3;
 		val = 0x7ffffff;
 	}
-    for (i = 0; i < n; i++) {
-        nlm_hal_write_rsa_reg(NLM_RSA_ENGINE_SELECT_REG_0 + i, val);	
-    }
+	for (i = 0; i < n; i++) {
+		nlm_hal_write_rsa_reg(NLM_RSA_ENGINE_SELECT_REG_0 + i, val);
+	}
 }
 
 void nlm_hal_get_crypto_vc_nums(int *vcbase, int *vclimit)
@@ -1567,6 +1637,9 @@ void nlm_hal_get_crypto_vc_nums(int *vcbase, int *vclimit)
 	if(is_nlm_xlp3xx()) {
 		*vcbase = XLP_3XX_CRYPTO_VC_BASE;
 		*vclimit = XLP_3XX_CRYPTO_VC_LIMIT;
+	} else if(is_nlm_xlp2xx()) {
+		*vcbase = XLP_2XX_CRYPTO_VC_BASE;
+		*vclimit = XLP_2XX_CRYPTO_VC_LIMIT;
 	} else {
 		*vcbase = XLP_CRYPTO_VC_BASE;
 		*vclimit = XLP_CRYPTO_VC_LIMIT;
@@ -1578,6 +1651,9 @@ void nlm_hal_get_rsa_vc_nums(int *vcbase, int *vclimit)
 	if(is_nlm_xlp3xx()) {
 		*vcbase  = XLP_3XX_RSA_ECC_VC_BASE;
 		*vclimit = XLP_3XX_RSA_ECC_VC_LIMIT;
+	} else if(is_nlm_xlp2xx()) {
+		*vcbase  = XLP_2XX_RSA_ECC_VC_BASE;
+		*vclimit = XLP_2XX_RSA_ECC_VC_LIMIT;
 	} else {
 		*vcbase = XLP_RSA_ECC_VC_BASE;
 		*vclimit = XLP_RSA_ECC_VC_LIMIT;
@@ -1585,7 +1661,7 @@ void nlm_hal_get_rsa_vc_nums(int *vcbase, int *vclimit)
 	}
 }
 
-void  nlm_hal_sata_firmware_init(void) 
+void  nlm_hal_sata_firmware_init(void)
 {
 	volatile uint32_t readdata, i;
 
@@ -1593,34 +1669,34 @@ void  nlm_hal_sata_firmware_init(void)
 
 	nlm_mdelay(1000);
 
-	readdata = rd_sata_glue_reg(SATA_CTL);
+	readdata = rd_sata_glue_reg(XLP_HAL_SATA_CTL);
 
 	nlm_print ("Reseting PHYs.\n");
-	clear_sata_glue_reg(SATA_CTL, SATA_RST_N);
-	clear_sata_glue_reg(SATA_CTL, PHY3_RESET_N);
-	clear_sata_glue_reg(SATA_CTL, PHY2_RESET_N);
-	clear_sata_glue_reg(SATA_CTL, PHY1_RESET_N);
-	clear_sata_glue_reg(SATA_CTL, PHY0_RESET_N);
-	readdata = rd_sata_glue_reg(SATA_CTL);
+	clear_sata_glue_reg(XLP_HAL_SATA_CTL, SATA_RST_N);
+	clear_sata_glue_reg(XLP_HAL_SATA_CTL, PHY3_RESET_N);
+	clear_sata_glue_reg(XLP_HAL_SATA_CTL, PHY2_RESET_N);
+	clear_sata_glue_reg(XLP_HAL_SATA_CTL, PHY1_RESET_N);
+	clear_sata_glue_reg(XLP_HAL_SATA_CTL, PHY0_RESET_N);
+	readdata = rd_sata_glue_reg(XLP_HAL_SATA_CTL);
 	nlm_mdelay(10);
 
-	set_sata_glue_reg(SATA_CTL, SATA_RST_N);
-	set_sata_glue_reg(SATA_CTL, PHY3_RESET_N);
-	set_sata_glue_reg(SATA_CTL, PHY2_RESET_N);
-	set_sata_glue_reg(SATA_CTL, PHY1_RESET_N);
-	set_sata_glue_reg(SATA_CTL, PHY0_RESET_N);
+	set_sata_glue_reg(XLP_HAL_SATA_CTL, SATA_RST_N);
+	set_sata_glue_reg(XLP_HAL_SATA_CTL, PHY3_RESET_N);
+	set_sata_glue_reg(XLP_HAL_SATA_CTL, PHY2_RESET_N);
+	set_sata_glue_reg(XLP_HAL_SATA_CTL, PHY1_RESET_N);
+	set_sata_glue_reg(XLP_HAL_SATA_CTL, PHY0_RESET_N);
 
-	readdata = rd_sata_glue_reg(SATA_CTL);
-	wr_sata_glue_reg(SATA_CTL, readdata);
-	readdata = rd_sata_glue_reg(SATA_CTL);
+	readdata = rd_sata_glue_reg(XLP_HAL_SATA_CTL);
+	wr_sata_glue_reg(XLP_HAL_SATA_CTL, readdata);
+	readdata = rd_sata_glue_reg(XLP_HAL_SATA_CTL);
 
 	nlm_print ("Waiting for PHYs to come up.\n");
 
 	i=0;
-	readdata = rd_sata_glue_reg(SATA_STATUS);
+	readdata = rd_sata_glue_reg(XLP_HAL_SATA_STATUS);
 	while ( ((readdata & 0x00F0) != 0x00F0) && (i < 30))
 	{
-		readdata = rd_sata_glue_reg(SATA_STATUS);
+		readdata = rd_sata_glue_reg(XLP_HAL_SATA_STATUS);
 		nlm_mdelay(10);
 		i++;
 	}
@@ -1635,7 +1711,6 @@ void  nlm_hal_sata_firmware_init(void)
 	else nlm_print(" PHY3 is down.\n");
 
 	nlm_print(" AHCI Firmware Init  Done.\n");
-
 }
 
 void nlm_hal_sata_intr_setup(void)
@@ -1643,23 +1718,26 @@ void nlm_hal_sata_intr_setup(void)
 	uint32_t val;
 
 	/* clear pending interrupts and then enable them */
-	val = rd_sata_glue_reg(SATA_INT);
+	val = rd_sata_glue_reg(XLP_HAL_SATA_INT);
 	nlm_mdelay(10);
-	wr_sata_glue_reg(SATA_INT, val);
+	wr_sata_glue_reg(XLP_HAL_SATA_INT, val);
 	nlm_mdelay(10);
 
-	val = rd_sata_glue_reg(SATA_INT_MASK);
+	val = rd_sata_glue_reg(XLP_HAL_SATA_INT_MASK);
 	nlm_mdelay(10);
-	wr_sata_glue_reg(SATA_INT_MASK, (val | 0xffffffff ));
+#if 1
+	wr_sata_glue_reg(XLP_HAL_SATA_INT_MASK, 0x1);
+#else
+	wr_sata_glue_reg(XLP_HAL_SATA_INT_MASK, val & 0x1BFF3);
+#endif
 }
 
 void nlm_hal_sata_intr_ack(void)
 {
 	uint32_t val = 0;
 
-	val = rd_sata_glue_reg(SATA_INT);
-	nlm_mdelay(10);
-	wr_sata_glue_reg(SATA_INT, val);
+	val = rd_sata_glue_reg(XLP_HAL_SATA_INT);
+	wr_sata_glue_reg(XLP_HAL_SATA_INT, val & 0x1BFF3);
 }
 
 void nlm_hal_sata_init(void)
@@ -1667,48 +1745,40 @@ void nlm_hal_sata_init(void)
 	nlm_hal_sata_firmware_init();
 }
 
-#define NUM_VCS_PER_CPU 4
-
-#define NUM_DISTVEC_CELLS 	16
-#define MIN_DIST_VEC 0
-#define MAX_DIST_VEC 16
-
-#define NUM_DISTVEC_CPUMASKS 4
-
-#define POE_DIST_VEC0 0x100
-
-void cpu_hotplug_fixup_poe(int cpu, int flag)
+uint32_t get_dom_owner_mask(void *fdt, int dom_id, char *module)
 {
-	unsigned long mflags = 0;
-	int reg_index;
-	uint32_t value, vcmask;
-	int cell, offset, vc = 0;
-	uint32_t distvec[NUM_DISTVEC_CELLS];
-	int node = cpu/32;
-	nlm_nae_config_ptr nae_cfg = nlm_node_cfg.nae_cfg[node];
-
-	vcmask =  (1 << nae_cfg->rx_vc);
-	vc = (cpu * NUM_VCS_PER_CPU) % (NUM_DISTVEC_CELLS * 32);
-	cell = vc / 32;
-
-	reg_index = POE_DIST_VEC0 + (NUM_DISTVEC_CELLS - 1 - cell);
+	char dom_node_str[32];
+	unsigned int *pval;
+	int nodeoffset;
+	int plen;
+	uint32_t flag;
 
-	/* do we need to ensure nobody is operating on msgrng? */
-	msgrng_access_enable(mflags);
-	if (flag) {
-		/* online */
-		offset = vc % 32;
-		value = vcmask << offset;
+	sprintf(dom_node_str, "/doms/dom@%d/owner-config", dom_id);
+	nodeoffset = fdt_path_offset(fdt, dom_node_str);
 
-		distvec[cell] |= value;
-		nlm_hal_write_poe_pcim_reg(node,reg_index, value);
-	} else {
-		/* offline */
-		nlm_hal_write_poe_pcim_reg(node,reg_index, 0);
+	if (nodeoffset >= 0)
+	{
+		pval = ((unsigned int *)fdt_getprop(fdt, nodeoffset, module, &plen));
+		if (pval != NULL) {
+			flag = fdt32_to_cpu(*(unsigned int *)pval);
+			//nlm_print("owner flag for %s is %#x.\n", module, flag);
+		}
+		else {
+			flag = 0;
+			// nlm_print("ERROR: pval is NULL.\n");
+		}
+	}
+	else
+	{
+		flag = 0;
+		// nlm_print("ERROR: unable to find nodeoffset.\n");
 	}
-	msgrng_access_disable(mflags);
+
+	return flag;
 }
 
+
+
 #ifdef NLM_HAL_LINUX_KERNEL
 #include <linux/types.h>
 #include <linux/module.h>
@@ -1728,4 +1798,9 @@ EXPORT_SYMBOL(nlm_node_cfg);
 EXPORT_SYMBOL(nlm_hal_init_ext_phy);
 EXPORT_SYMBOL(nlm_hal_ext_phy_an);
 EXPORT_SYMBOL(register_phy);
+EXPORT_SYMBOL(get_dom_owner_mask);
+EXPORT_SYMBOL(nlm_hal_sata_init);
+EXPORT_SYMBOL(nlm_hal_sata_intr_setup);
+EXPORT_SYMBOL(nlm_hal_sata_intr_ack);
+EXPORT_SYMBOL(nlm_hal_get_fdt_freq);
 #endif
diff --git a/arch/mips/netlogic/common/nlm_hal_cpu_info.c b/arch/mips/netlogic/common/nlm_hal_cpu_info.c
index 790a125..361576d 100644
--- a/arch/mips/netlogic/common/nlm_hal_cpu_info.c
+++ b/arch/mips/netlogic/common/nlm_hal_cpu_info.c
@@ -2,7 +2,19 @@
 #include "nlm_hal_macros.h"
 #include "nlm_hal_xlp_dev.h"
 
-
+/* local defines */
+#define XLP8XX_REVISION_A0  0x00
+#define XLP8XX_REVISION_A1  0x01
+#define XLP8XX_REVISION_A2  0x02
+#define XLP8XX_REVISION_B0  0x03
+#define XLP8XX_REVISION_B1  0x04
+
+#define XLP3XX_REVISION_A0  0x00
+#define XLP3XX_REVISION_A1  0x01
+#define XLP3XX_REVISION_B0  0x02
+#define XLP3XX_REVISION_B1  0x03
+
+extern void *memset(void *s, int c, size_t n);
 static inline int bitcount(unsigned int n)                          
 {
   register unsigned int tmp;
@@ -15,26 +27,35 @@ static inline int bitcount(unsigned int n)
 
 __inline__ uint32_t efuse_cfg0(void)
 {
-	return  nlm_hal_read_32bit_reg((((KSEG1 + 0x18000000 + 0x35000) & 0x1fffffff) + 0x100), (EFUSE_DEVICE_CFG0));
+        return  nlm_hal_read_32bit_reg(SYS_REG_BASE , (SYS_REG_INDEX(EFUSE_DEVICE_CFG0)));
+
 }
 
  __inline__ uint32_t efuse_cfg1(void)
 {
-	return nlm_hal_read_32bit_reg((((KSEG1 + 0x18000000 + 0x35000) & 0x1fffffff) + 0x100), (EFUSE_DEVICE_CFG1));
+        return  nlm_hal_read_32bit_reg(SYS_REG_BASE , (SYS_REG_INDEX(EFUSE_DEVICE_CFG1)));
 }
 
 __inline__ uint32_t efuse_cfg6(void)
 {
-	return nlm_hal_read_32bit_reg((((KSEG1 + 0x18000000 + 0x35000) & 0x1fffffff) + 0x100), (EFUSE_DEVICE_CFG6));
+        return  nlm_hal_read_32bit_reg(SYS_REG_BASE , (SYS_REG_INDEX(EFUSE_DEVICE_CFG6)));
 }
 
-__inline__ uint32_t get_proc_id(void)
+
+__inline uint32_t get_proc_id(void)
 {
-	uint32_t cpuid= efuse_cfg6() & EFUSE_CFG6_CPUID_MASK;
-	if(!cpuid){ /*May be its Non fused part.*/
-		return CHIP_PROCESSOR_ID_XLP_8_4_XX; /*Default to CHIP_PROCESSOR_ID_XLP_8_4_XX */
+	unsigned int prid = nlm_read_prid();
+	prid = (prid >> 8) & 0xff;
+	if (!prid) { /*May be its Non fused part.*/
+#ifdef  CONFIG_NETL3XX
+		prid = CHIP_PROCESSOR_ID_XLP_3XX;
+#elif  defined (CONFIG_NETL2XX)
+		prid = CHIP_PROCESSOR_ID_XLP_2XX;
+#else
+		prid = CHIP_PROCESSOR_ID_XLP_8_4_XX;
+#endif
 	}
-	return cpuid;
+	return prid;
 }
 
 __inline__ int get_nlm_xlp8xx_rev(void)
@@ -42,80 +63,29 @@ __inline__ int get_nlm_xlp8xx_rev(void)
 	return nlm_read_prid() & 0xff;
 }
 
-__inline__ int is_nlm_rev_a0(void)
-{
-	return ((nlm_read_prid() & 0xff) == XLP_REVISION_A0);
-}
-
- __inline__ int is_nlm_rev_a1(void)
-{
-	return ((nlm_read_prid() & 0xff) == XLP_REVISION_A1);
-}
-
-__inline__ int is_nlm_rev_a2(void)
-{
-	return ((nlm_read_prid() & 0xff) == XLP_REVISION_A2);
-}
-
-__inline__ int is_nlm_rev_b0(void)
-{
-	return ((nlm_read_prid() & 0xff) == XLP_REVISION_B0);
-}
-
-__inline__ int is_nlm_rev_b1(void)
-{
-	return ((nlm_read_prid() & 0xff) == XLP_REVISION_B1);
-}
-
-__inline__ int is_nlm_rev_bx(void)
-{
-	return ((nlm_read_prid() & 0xff) == XLP_REVISION_BX);
-}
-
-extern char *strcat(char *dest, const char *src);
-static  void get_cpu_rev(int *revid, char *rev)
-{
-	if(is_nlm_rev_a0()){
-		*revid = XLP_REVISION_A0;
-		strcat(rev, " Rev A0");
-	} 
-	if(is_nlm_rev_a1()){
-		*revid = XLP_REVISION_A1;
-		strcat(rev, " Rev A1"); 
-	} 
-	if(is_nlm_rev_a2()){
-		*revid = XLP_REVISION_A2;
-		strcat(rev, " Rev A2"); 
-	} 
-	if(is_nlm_rev_b0()){
-		*revid = XLP_REVISION_B0;
-		strcat(rev, " Rev B0"); 
-	} 
-	if(is_nlm_rev_b1()){
-		*revid = XLP_REVISION_B1;
-		strcat(rev, " Rev B1");
-	}
-	return;
-}
-
-inline int get_nlm_xlp3xx_rev(void)
+__inline__ int get_nlm_xlp3xx_rev(void)
 {
 	int hw_rev = nlm_read_prid() & 0xff;
 	int sw_rev;
-	if (hw_rev >= XLP3XX_REVISION_B0)
+	if(hw_rev>=XLP3XX_REVISION_B0)
 		sw_rev = hw_rev + 1;
 	else
 		sw_rev = hw_rev;
 	return sw_rev;
 }
 
+__inline__ int get_nlm_xlp2xx_rev(void)
+{
+	return nlm_read_prid() & 0xff;
+}
+
 /***************************************************************************************
 * match the chip revision with 'rev'
  * rev:  revision number
 		single match: XLP_REVISION_A0 etc
 		multi-match:  XLP_REVISION_AX/_BX/_XX
 ****************************************************************************************/
-inline int is_nlm_xlp8xx_rev_xx(uint32_t rev)
+__inline__ int is_nlm_xlp8xx_rev_xx(uint32_t rev)
 {
 	int sw_rev=get_nlm_xlp8xx_rev();
 	uint32_t rev_b0 = XLP_REVISION_B0;
@@ -126,24 +96,33 @@ inline int is_nlm_xlp8xx_rev_xx(uint32_t rev)
 	return 0;
 }
 
-/************************************************
+/***************************************************************************************
 * match the chip revision with 'rev'
  * rev:  revision number
 		single match: XLP_REVISION_A0 etc
 		multi-match:  XLP_REVISION_AX/_BX/_XX
-*************************************************/
-inline int is_nlm_xlp3xx_rev_xx(uint32_t rev)
+****************************************************************************************/
+__inline__ int is_nlm_xlp3xx_rev_xx(uint32_t rev)
 {
-	int sw_rev = get_nlm_xlp3xx_rev();
+	int sw_rev=get_nlm_xlp3xx_rev();
 	uint32_t rev_b0 = XLP_REVISION_B0;
-	if (rev == sw_rev)
-		return 1;
-	if (rev == XLP_REVISION_AX && sw_rev < rev_b0)
-		return 1;
-	if (rev == XLP_REVISION_BX && (rev_b0 <= sw_rev))
-		return 1;
-	if (rev == XLP_REVISION_ANY)
-		return 1;
+	if( rev==sw_rev)	return 1;
+	if( rev==XLP_REVISION_AX && sw_rev<rev_b0)	return 1;
+	if( rev==XLP_REVISION_BX && (rev_b0<=sw_rev))  	return 1;
+	if( rev==XLP_REVISION_ANY)			return 1;
+
+	return 0;
+}
+
+
+__inline__ int is_nlm_xlp2xx_rev_xx(uint32_t rev)
+{
+	int sw_rev=get_nlm_xlp2xx_rev();
+	uint32_t rev_b0 = XLP_REVISION_B0;
+	if( rev==sw_rev)	return 1;
+	if( rev==XLP_REVISION_AX && sw_rev<rev_b0)	return 1;
+	if( rev==XLP_REVISION_BX && (rev_b0<=sw_rev))  	return 1;
+	if( rev==XLP_REVISION_ANY)			return 1;
 
 	return 0;
 }
@@ -174,11 +153,11 @@ inline int is_xlp8xx_legacy(int chipid, uint32_t rev)
     return 0;
 }
 
-/***************************************************************************************
-match eagle 8xxBx
-num_cpu: 32-xlp832, 24-xlp824, 16-xlp816, 0 any cpu number is valid match
-rev:  chip revision,
-***************************************************************************************/
+/*
+ * match xlp8xx
+ * num_cpu: 32-xlp832, 24-xlp824, 16-xlp816, 0 any cpu number is valid match
+ * rev:  chip revision,
+ */
 #define CPU_NUM_ANY  0	//any cpu number will be matched
 inline int is_xlp8xx(uint8_t num_cpu, uint32_t rev)
 {
@@ -202,11 +181,11 @@ inline int is_xlp8xx(uint8_t num_cpu, uint32_t rev)
 	return 0;
 }
 
-/***************************************************************************************
-match eagle 4xxBx
-num_cpu: 32-xlp832, 24-xlp824, 16-xlp816, 0xff any cpu number is valid match
-rev:  chip revision,
-***************************************************************************************/
+/*
+ * match xlp4xx
+ * num_cpu: 32-xlp832, 24-xlp824, 16-xlp816, 0xff any cpu number is valid match
+ * rev:  chip revision,
+ */
 inline int is_xlp4xx(uint8_t num_cpu, uint32_t rev)
 {
 	uint32_t pid, mask, cfg1;
@@ -229,12 +208,12 @@ inline int is_xlp4xx(uint8_t num_cpu, uint32_t rev)
     return 0;
 }
 
-/*****************************************************************************************************
-match storm
-num_cpu: 16-xlp316,  8-xlp308, 4-xlp304;  0xff any cpu number is valid match
-rev:  chip revision,
-type: CPU_EXTPID_XLP_3XX_NONE, CPU_EXTPID_XLP_3XX_L, CPU_EXTPID_XLP_3XX_LP, CPU_EXTPID_XLP_3XX_LP2
-********************************************************************************************************/
+/*
+ * match xlp3xx
+ * num_cpu: 16-xlp316,  8-xlp308, 4-xlp304;  0xff any cpu number is valid match
+ * rev:  chip revision,
+ * type: CPU_EXTPID_XLP_3XX_NONE, CPU_EXTPID_XLP_3XX_L, CPU_EXTPID_XLP_3XX_LP, CPU_EXTPID_XLP_3XX_LP2
+ */
 inline int is_xlp3xx(uint8_t num_cpu, uint32_t rev, uint32_t exttype)
 {
 	uint32_t pid, cfg0, mask;
@@ -245,7 +224,6 @@ inline int is_xlp3xx(uint8_t num_cpu, uint32_t rev, uint32_t exttype)
 	if(ret!=1)  return 0;
 
 	pid=get_proc_id();
-
 	if( pid == CHIP_PROCESSOR_ID_XLP_3XX )
 	{
 		cfg0=efuse_cfg0();
@@ -260,201 +238,36 @@ inline int is_xlp3xx(uint8_t num_cpu, uint32_t rev, uint32_t exttype)
     return 0;
 }
 
-/* match xlp2xx */
-inline int is_xlp2xx(uint8_t num_cpu, uint32_t rev, uint32_t exttype)
+/*
+ * match xlp2xx
+ * num_cpu: 8-xlp208, 4-xlp204;  0xff any cpu number is valid match
+ * rev:  chip revision,
+ */
+inline int is_xlp2xx(uint8_t num_cpu, uint32_t rev)
 {
-	uint32_t pid;
+	uint32_t pid, cfg0, mask;
+	int ret, cpuNum;
+
+	ret=is_nlm_xlp2xx_rev_xx(rev);
+	if(ret!=1)  return 0;
 
 	pid=get_proc_id();
 	if(pid == CHIP_PROCESSOR_ID_XLP_2XX)
-		return 1;
-	return 0;
-}
-
-static __inline__ int is_nlm_xlp_8_4_x(void)
-{
-	return (get_proc_id() == CHIP_PROCESSOR_ID_XLP_8_4_XX);
-}
-
-__inline__ int is_nlm_xlp832_b0(void)
-{
-	if(is_nlm_xlp_8_4_x() && is_nlm_rev_b0()){
-		unsigned int cfg0 =  efuse_cfg0() & 0xff; /*last 8 bits*/
-		unsigned int cfg1 =  efuse_cfg1() & 0x7; /*last 3 bits*/
-		
-		if( (bitcount(cfg0)==0) && (cfg1!=0x7) ){
-			return 1;
-		}
-	}
-	return 0;
-}
-
-__inline__ int is_nlm_xlp432_b0(void)
-{
-	if(is_nlm_xlp_8_4_x() && is_nlm_rev_b0()){
-		unsigned int cfg0 =  efuse_cfg0() & 0xff; /*last 8 bits*/
-		unsigned int cfg1 =  efuse_cfg1() & 0x7; /*last 3 bits*/
-		
-		if( (bitcount(cfg0)==0) && (cfg1==0x7) ){
-			return 1;
-		}
-	}
-	return 0;
-}
-
-__inline__ int is_nlm_xlp824_b0(void)
-{
-	if(is_nlm_xlp_8_4_x() && is_nlm_rev_b0()){
-		unsigned int cfg0 =  efuse_cfg0() & 0xff; /*last 8 bits*/
-		unsigned int cfg1 =  efuse_cfg1() & 0x7; /*last 3 bits*/
-		
-		if( (bitcount(cfg0)==2) && (cfg1!=0x7) ){
-			return 1;
-		}
-	}
-	return 0;
-}
-
-__inline__ int is_nlm_xlp424_b0(void)
-{
-	if(is_nlm_xlp_8_4_x() && is_nlm_rev_b0()){
-		unsigned int cfg0 =  efuse_cfg0() & 0xff; /*last 8 bits*/
-		unsigned int cfg1 =  efuse_cfg1() & 0x7; /*last 3 bits*/
-		
-		if( (bitcount(cfg0)==2) && (cfg1==0x7) ){
-			return 1;
-		}
-	}
-	return 0;
-}
-
-__inline__ int is_nlm_xlp816_b0(void)
-{
-	if(is_nlm_xlp_8_4_x() && is_nlm_rev_b0()){
-		unsigned int cfg0 =  efuse_cfg0() & 0xff; /*last 8 bits*/
-		unsigned int cfg1 =  efuse_cfg1() & 0x7; /*last 3 bits*/
-		
-		if( (bitcount(cfg0)==4) && (cfg1!=0x7) ){
-			return 1;
-		}
-	}
-	return 0;
-}
-
-__inline__ int is_nlm_xlp416_b0(void)
-{
-	if(is_nlm_xlp_8_4_x() && is_nlm_rev_b0()){
-		unsigned int cfg0 =  efuse_cfg0() & 0xff; /*last 8 bits*/
-		unsigned int cfg1 =  efuse_cfg1() & 0x7; /*last 3 bits*/
-		
-		if( (bitcount(cfg0)==4) && (cfg1==0x7) ){
-			return 1;
-		}
+	{
+		cfg0=efuse_cfg0();
+		mask = cfg0  & 0x3;
+		cpuNum=(2-bitcount(mask))<<2;
+		if( (cpuNum==num_cpu) || (num_cpu==CPU_NUM_ANY )) return 1;
 	}
 	return 0;
 }
 
-__inline__ int is_nlm_xlp832_ax(void)
-{
-	return ( ((get_proc_id() == CHIP_PROCESSOR_ID_XLP_8XX) || is_nlm_xlp_8_4_x()) 
-		); //XLP832 A2 has same cpu id as B0 /
-}
-
-
-__inline__ int is_nlm_xlp432_ax(void)
-{
-	return (get_proc_id() == CHIP_PROCESSOR_ID_XLP_432);
-}
-
-__inline__ int is_nlm_xlp816_ax(void)
-{
-	return (get_proc_id() == CHIP_PROCESSOR_ID_XLP_816);
-}
-
-__inline__ int is_nlm_xlp416_ax(void)
-{
-	return (get_proc_id() == CHIP_PROCESSOR_ID_XLP_416);
-}
-
-__inline__ int is_nlm_xlp408_ax(void)
-{
-	return (get_proc_id() == CHIP_PROCESSOR_ID_XLP_408);
-}
-
-__inline__ int is_nlm_xlp208_ax(void)
-{
-	return (get_proc_id() == CHIP_PROCESSOR_ID_XLP_208);
-}
-
-__inline__ int is_nlm_xlp204_ax(void)
-{
-	return (get_proc_id() == CHIP_PROCESSOR_ID_XLP_204);
-}
-
-__inline__ int is_nlm_xlp104_ax(void)
-{
-	return (get_proc_id() == CHIP_PROCESSOR_ID_XLP_104);
-}
-
-/*high level APIs*/
-__inline__ int is_nlm_xlp8xx(void)
-{
-	if(is_nlm_xlp_8_4_x()
-	        || is_nlm_xlp832_ax()
-		|| is_nlm_xlp432_ax()
-		|| is_nlm_xlp816_ax()
-		|| is_nlm_xlp416_ax()
-		|| is_nlm_xlp408_ax()
-		|| is_nlm_xlp208_ax()
-		|| is_nlm_xlp204_ax()
-		|| is_nlm_xlp104_ax() ){
-			return 1;
-		}
-	return 0;
-}
-
-__inline__ int is_nlm_xlp8xx_ax(void)
-{
-	if(is_nlm_xlp832_ax()
-		|| is_nlm_xlp432_ax()
-		|| is_nlm_xlp816_ax()
-		|| is_nlm_xlp416_ax()
-		|| is_nlm_xlp408_ax()
-		|| is_nlm_xlp208_ax()
-		|| is_nlm_xlp204_ax()
-		|| is_nlm_xlp104_ax() ){
-			return 1;
-		}
-	return 0;
-}
-
-__inline__ int is_nlm_xlp8xx_b0(void)
-{
-	return (is_nlm_xlp_8_4_x() && is_nlm_rev_b0());
-}
-
-__inline__ int is_nlm_xlp8xx_b1(void)
-{
-	return (is_nlm_xlp_8_4_x() && is_nlm_rev_b1());
-}
-
-__inline__ int is_nlm_xlp8xx_bx(void)
-{
-	return (is_nlm_xlp8xx_b1() || is_nlm_xlp8xx_b0()
-		|| (is_nlm_xlp_8_4_x() && is_nlm_rev_bx()));
-}
-
-__inline__ int is_nlm_xlp3xx(void)
-{
-	return (get_proc_id() == CHIP_PROCESSOR_ID_XLP_3XX);
-}
-
-/*****************************************************************************************************
- * match storm
- * chipid: 832, 316,  308, etc, 800: any in 8xx group, 0 for all xlp group
+/*
+ * match xlpxx
+ * chipid: 832, 316, 308, 208, etc, 800: any in 8xx group, 0 for all xlp group
  * rev:    XLP_REVISION_A0, XLP_REVISION_A0 etc, or XLP_REVISION_AX (a0,a1,a2) XLP_REVISION_ANY(both: ax,bx)
  * type: current only for 3xx: CPU_EXTPID_XLP_3XX_NONE, CPU_EXTPID_XLP_3XX_L, CPU_EXTPID_XLP_3XX_LP, CPU_EXTPID_XLP_3XX_LP2
- * ********************************************************************************************************/
+ */
 int is_nlm_xlp(unsigned int chipid, unsigned int rev, unsigned int ext)
 {
 	uint32_t group=chipid/100;
@@ -481,7 +294,7 @@ int is_nlm_xlp(unsigned int chipid, unsigned int rev, unsigned int ext)
 
 	if ( group==2 )
 	{
-		b_rc=is_xlp2xx(num_cpu, rev, ext);
+		b_rc=is_xlp2xx(num_cpu, rev);
 		return b_rc;
 	}
 
@@ -492,324 +305,93 @@ int is_nlm_xlp(unsigned int chipid, unsigned int rev, unsigned int ext)
 	return b_rc;
 }
 
-__inline__ int is_nlm_xlp3xx_a1(void)
-{
-	return (is_nlm_xlp3xx() && is_nlm_rev_a1());
-}
-
-__inline__ int is_nlm_xlp3xx_a0(void)
-{
-	return (is_nlm_xlp3xx() && is_nlm_rev_a0());
-}
-
-__inline__ void get_xlp3xx_extpid(char *extpid)
-{
-	unsigned int cfg0_extpid= (efuse_cfg0()>> 4) & 0xf; /*4-7 bits*/
-	if(cfg0_extpid==CPU_EXTPID_XLP_3XX_NONE){
-		strcat(extpid, "");
-		return;
-	}
-	if(cfg0_extpid==CPU_EXTPID_XLP_3XX_L){
-		strcat(extpid, " Lite");
-		return;
-	}
-	if(cfg0_extpid==CPU_EXTPID_XLP_3XX_LP){
-		strcat(extpid, " Lite+");
-		return;
-	}
-	if(cfg0_extpid==CPU_EXTPID_XLP_3XX_LP2){
-		strcat(extpid, " Lite+2");
-		return;
-	}
-	strcat(extpid, " Unknown");
-	return;
-}
-
-__inline__ int is_nlm_xlp3xx_lite(void)
-{
-	unsigned int cfg0_extpid = (efuse_cfg0()>> 4) & 0xf; /*4-7 bits*/
-
-	return (is_nlm_xlp3xx() && (cfg0_extpid != 0));
-}
-
-__inline__ int is_nlm_xlp316_a0(void)
-{
-	if(is_nlm_xlp3xx_a0()){
-		unsigned int cfg0 =  efuse_cfg0() & 0xf; /*last 4 bits*/
-		if( (bitcount(cfg0)==0)){
-			return 1;
-		}
-	}
-	return 0;
-}
-
-__inline__ int is_nlm_xlp316_a1(void)
-{
-	if(is_nlm_xlp3xx_a1()){
-		unsigned int cfg0 =  efuse_cfg0() & 0xf; /*last 4 bits*/
-		if( (bitcount(cfg0)==0)){
-			return 1;
-		}
-	}
-	return 0;
-	return (is_nlm_xlp316_a0());
-}
-
-__inline__ int is_nlm_xlp316(void)
-{
-	return(is_nlm_xlp316_a0() | is_nlm_xlp316_a1());
-}
-
-__inline__ int is_nlm_xlp308_a0(void)
-{
-	if(is_nlm_xlp3xx_a0()){
-		unsigned int cfg0 =  efuse_cfg0() & 0xf; /*last 4 bits*/
-		if( (bitcount(cfg0)==2)){
-			return 1;
-		}
-	}
-	return 0;
-}
-
-__inline__ int is_nlm_xlp308_a1(void)
-{
-	if(is_nlm_xlp3xx_a1()){
-		unsigned int cfg0 =  efuse_cfg0() & 0xf; /*last 4 bits*/
-		if( (bitcount(cfg0)==2)){
-			return 1;
-		}
-	}
-	return 0;
-}
-
-__inline__ int is_nlm_xlp308(void)
-{
-	return(is_nlm_xlp308_a0() | is_nlm_xlp308_a1());
-}
-
-__inline__ int is_nlm_xlp304_a0(void)
-{
-	if(is_nlm_xlp3xx_a0()){
-		unsigned int cfg0 =  efuse_cfg0() & 0xf; /*last 4 bits*/
-		if( (bitcount(cfg0)==3)){
-			return 1;
-		}
-	}
-	return 0;
-}
-
-__inline__ int is_nlm_xlp304_a1(void)
-{
-	if(is_nlm_xlp3xx_a1()){
-		unsigned int cfg0 =  efuse_cfg0() & 0xf; /*last 4 bits*/
-		if( (bitcount(cfg0)==3)){
-			return 1;
-		}
-	}
-	return 0;
-}
-
-__inline__ int is_nlm_xlp304(void)
-{
-	return(is_nlm_xlp304_a0() | is_nlm_xlp304_a1());
-}
-
-/*Check for XLP-CPU */
-__inline__ int is_nlm_xlpxxx(void)
-{
-	return (is_nlm_xlp8xx()||is_nlm_xlp3xx());
-}
-
 int  nlm_hal_get_chipid(void)
 {
-	int chipid = -1, cpuNum;
+	int chipid=-1, cpuNum;
 	unsigned int cfg0, cfg1;
-	uint32_t pid = get_proc_id();
+	uint32_t pid=get_proc_id();
 
-	cfg0 = efuse_cfg0() ;
-	cfg1 = efuse_cfg1() ;
+	cfg0 =  efuse_cfg0() ;
+	cfg1 =  efuse_cfg1() ;
 
-	/*eagle 4xx 8xx BX, unfused chip treat as 8xx*/
-	if (pid == 0 || pid == CHIP_PROCESSOR_ID_XLP_8_4_XX) {
-		cpuNum = (8-bitcount(cfg0&0xFF))*4;
+	//eagle 4xx 8xx BX, unfused chip treat as 8xx
+	if(pid==0 || pid==CHIP_PROCESSOR_ID_XLP_8_4_XX)
+	{
+		cpuNum=(8-bitcount(cfg0&0xFF))*4;
 
-		chipid = (cfg1&7) == 7 ? 400 : 800;
-		chipid += cpuNum;
+		chipid = (cfg1&7)==7 ? 400 : 800;
+		chipid+= cpuNum;
 		return chipid;
 	}
-	if (pid == CHIP_PROCESSOR_ID_XLP_3XX) {
-		cpuNum = (4-bitcount(cfg0&0xF))*4;
+	if(pid==CHIP_PROCESSOR_ID_XLP_3XX)
+	{
+		cpuNum=(4-bitcount(cfg0&0xF))*4;
 
-		chipid = 300 +  cpuNum;
+		chipid= 300 +  cpuNum;
 		return chipid;
 	}
-	if (pid == CHIP_PROCESSOR_ID_XLP_2XX) {
-		chipid = 200;
+	if (pid == CHIP_PROCESSOR_ID_XLP_2XX)
+	{
+		cpuNum=(2-bitcount(cfg0&0x3))*4;
+		chipid = 200 + cpuNum;
 		return chipid;
 	}
-	/*eagle 8xx AX*/
-	switch (pid) {
-	case CHIP_PROCESSOR_ID_XLP_832:
-		chipid = 832;
-		break;
-	case CHIP_PROCESSOR_ID_XLP_816:
-		chipid = 816;
-		break;
-	case CHIP_PROCESSOR_ID_XLP_432:
-		chipid = 432;
-		break;
-	case CHIP_PROCESSOR_ID_XLP_416:
-		chipid = 416;
-		break;
-	case CHIP_PROCESSOR_ID_XLP_408:
-		chipid = 408;
-		break;
-	case CHIP_PROCESSOR_ID_XLP_208:
-		chipid = 208;
-		break;
-	case CHIP_PROCESSOR_ID_XLP_204:
-		chipid = 204;
-		break;
-	case CHIP_PROCESSOR_ID_XLP_104:
-		chipid = 104;
-		break;
-	default:
-		break;
+	//eagle 8xx AX
+	switch(pid)
+	{
+	case CHIP_PROCESSOR_ID_XLP_832 :    chipid=832;   break;
+	case CHIP_PROCESSOR_ID_XLP_816 :    chipid=816;   break;
+	case CHIP_PROCESSOR_ID_XLP_432 :    chipid=432;   break;
+	case CHIP_PROCESSOR_ID_XLP_416 :    chipid=416;   break;
+	case CHIP_PROCESSOR_ID_XLP_408 :    chipid=408;   break;
+	case CHIP_PROCESSOR_ID_XLP_208 :    chipid=208;   break;
+	case CHIP_PROCESSOR_ID_XLP_204 :    chipid=204;   break;
+	case CHIP_PROCESSOR_ID_XLP_104 :    chipid=104;   break;
+	default: break;
 	}
 
 	return chipid;
 }
 
-/**
- * Fill the nlm_netl_proc_info using nlm cpu apis.
- *
- * @param[in,out] prid		: ptr to nlm_netl_proc_info
- * Do not call this function if just cpu type has to be validated use
- * cpu id apis instead.
- * @return
- * 1 on success, 0 on failure
- * @ingroup	hal
- */
 int  nlm_hal_get_cpuinfo(struct nlm_netl_proc_info* cpu_info)
 {
-	const static char c_typename[][8] = {"\0", "Lite", "Lite+",
-					"Lite+2", "Unknown"};
+	const static char c_typename[][8]={"\0", "Lite", "Lite+", "Lite+2", "Unknown"};
 	unsigned int sw_rev, chipid, type;
 	uint32_t cfg0, pid;
 
-	if(is_nlm_xlp8xx()){
-		strcpy(cpu_info->cpu_info_str, "XLP");
-		if(is_nlm_xlp8xx_b1()){
-			strcat(cpu_info->cpu_info_str, "832 Rev B1");
-			cpu_info->proc_id = CHIP_PROCESSOR_ID_XLP_8_4_XX;
-			cpu_info->revision= XLP_REVISION_B1;
-			return 1;
-		}
-		if(is_nlm_xlp832_b0()){
-			strcat(cpu_info->cpu_info_str, "832 Rev B0");
-			cpu_info->proc_id = CHIP_PROCESSOR_ID_XLP_8_4_XX;
-			cpu_info->revision= XLP_REVISION_B0;
-			return 1;
-		}
-		if(is_nlm_xlp824_b0()){
-			strcat(cpu_info->cpu_info_str, "824 Rev B0");
-			cpu_info->proc_id = CHIP_PROCESSOR_ID_XLP_8_4_XX;
-			cpu_info->revision= XLP_REVISION_B0;
-			return 1;
-		}
-		if(is_nlm_xlp816_b0()){
-			strcat(cpu_info->cpu_info_str, "816 Rev B0");
-			cpu_info->proc_id = CHIP_PROCESSOR_ID_XLP_8_4_XX;
-			cpu_info->revision= XLP_REVISION_B0;
-			return 1;
-		}
-		if(is_nlm_xlp432_b0()){
-			strcat(cpu_info->cpu_info_str, "432 Rev B0");
-			cpu_info->proc_id = CHIP_PROCESSOR_ID_XLP_8_4_XX;
-			cpu_info->revision= XLP_REVISION_B0;
-			return 1;
-		}
-		if(is_nlm_xlp424_b0()){
-			strcat(cpu_info->cpu_info_str, "424 Rev B0");
-			cpu_info->proc_id = CHIP_PROCESSOR_ID_XLP_8_4_XX;
-			cpu_info->revision= XLP_REVISION_B0;
-			return 1;
-		}
-		if(is_nlm_xlp416_b0()){
-			strcat(cpu_info->cpu_info_str, "416 Rev B0");
-			cpu_info->proc_id = CHIP_PROCESSOR_ID_XLP_8_4_XX;
-			cpu_info->revision= XLP_REVISION_B0;
-			return 1;
-		}
-		if(is_nlm_xlp832_ax()){
-			strcat(cpu_info->cpu_info_str, "832");
-			get_cpu_rev(&cpu_info->revision, cpu_info->cpu_info_str);
-			return 1;
-		}
-		if(is_nlm_xlp816_ax()){
-			strcat(cpu_info->cpu_info_str, "816");
-			cpu_info->proc_id = CHIP_PROCESSOR_ID_XLP_816;
-			get_cpu_rev(&cpu_info->revision, cpu_info->cpu_info_str);
-			return 1;
-		}
-		if(is_nlm_xlp432_ax()){
-			strcat(cpu_info->cpu_info_str, "432");
-			cpu_info->proc_id = CHIP_PROCESSOR_ID_XLP_432;
-			get_cpu_rev(&cpu_info->revision, cpu_info->cpu_info_str);
-			return 1;
-		}
-		if(is_nlm_xlp416_ax()){
-			strcat(cpu_info->cpu_info_str, "416");
-			cpu_info->proc_id = CHIP_PROCESSOR_ID_XLP_416;
-			get_cpu_rev(&cpu_info->revision, cpu_info->cpu_info_str);
-			return 1;
-		}
-		if(is_nlm_xlp408_ax()){
-			strcat(cpu_info->cpu_info_str, "408");
-			cpu_info->proc_id = CHIP_PROCESSOR_ID_XLP_408;
-			get_cpu_rev(&cpu_info->revision, cpu_info->cpu_info_str);
-			return 1;
-		}
-		if(is_nlm_xlp208_ax()){
-			strcat(cpu_info->cpu_info_str, "208");
-			cpu_info->proc_id = CHIP_PROCESSOR_ID_XLP_208;
-			get_cpu_rev(&cpu_info->revision, cpu_info->cpu_info_str);
-			return 1;
-		}
-		if(is_nlm_xlp204_ax()){
-			strcat(cpu_info->cpu_info_str, "204");
-			cpu_info->proc_id = CHIP_PROCESSOR_ID_XLP_204;
-			get_cpu_rev(&cpu_info->revision, cpu_info->cpu_info_str);
-			return 1;
-		}
-		if(is_nlm_xlp104_ax()){
-			strcat(cpu_info->cpu_info_str, "104");
-			cpu_info->proc_id = CHIP_PROCESSOR_ID_XLP_104;
-			get_cpu_rev(&cpu_info->revision, cpu_info->cpu_info_str);
-			return 1;
-		}
-	}
-	if (is_nlm_xlp3xx()) {
-		pid = get_proc_id();
-		chipid = nlm_hal_get_chipid();
+	pid=get_proc_id();
+	chipid=nlm_hal_get_chipid();
 
-		memset(cpu_info, 0, sizeof(struct nlm_netl_proc_info));
-		cpu_info->proc_id = pid;
-		cpu_info->chipid = chipid;
+	memset(cpu_info, 0, sizeof(struct nlm_netl_proc_info));
+	cpu_info->proc_id=pid;
+	cpu_info->chipid=chipid;
 
+	if( pid == CHIP_PROCESSOR_ID_XLP_2XX )
+	{
+		sw_rev = get_nlm_xlp2xx_rev();
+		cpu_info->revision= sw_rev;
+		sprintf(cpu_info->cpu_info_str, "XLP%3d Rev %c%1d",
+			chipid,(char)('A'+sw_rev/XLP_REVISION_B0), sw_rev%XLP_REVISION_B0);
+	}
+	else if( pid != CHIP_PROCESSOR_ID_XLP_3XX )
+	{
+		sw_rev = get_nlm_xlp8xx_rev();
+		cpu_info->revision= sw_rev;
+		sprintf(cpu_info->cpu_info_str, "XLP%3d Rev %c%1d",
+			chipid,(char)('A'+sw_rev/XLP_REVISION_B0), sw_rev%XLP_REVISION_B0);
+	}
+	else
+	{
 		sw_rev = get_nlm_xlp3xx_rev();
 		cpu_info->revision = sw_rev;
 		cfg0 =  efuse_cfg0();
-		type = (cfg0>>4) & 0xF;
-		if (CPU_EXTPID_XLP_3XX_LP2 < type)
-			type = CPU_EXTPID_XLP_3XX_LP2+1;
-		sprintf(cpu_info->cpu_info_str, "XLP%3d%s Rev %c%1d", chipid,
-			c_typename[type], (char)('A'+sw_rev/XLP_REVISION_B0),
-			sw_rev%XLP_REVISION_B0);
-		return 1;
+		type= (cfg0>>4) & 0xF;
+		if(CPU_EXTPID_XLP_3XX_LP2<type) type=CPU_EXTPID_XLP_3XX_LP2+1;
+		sprintf(cpu_info->cpu_info_str, "XLP%3d%s Rev %c%1d", chipid, c_typename[type],
+			(char)('A'+sw_rev/XLP_REVISION_B0), sw_rev%XLP_REVISION_B0);
 	}
 
-	return 0; //NO success in CPU ID
+	return 0;
 }
 
 
@@ -821,18 +403,8 @@ EXPORT_SYMBOL(efuse_cfg0);
 EXPORT_SYMBOL(efuse_cfg1);
 EXPORT_SYMBOL(efuse_cfg6);
 EXPORT_SYMBOL(get_proc_id);
-EXPORT_SYMBOL(is_nlm_xlp8xx);
-EXPORT_SYMBOL(is_nlm_xlp8xx_b0);
-EXPORT_SYMBOL(is_nlm_xlp8xx_b1);
-EXPORT_SYMBOL(is_nlm_xlp8xx_bx);
-EXPORT_SYMBOL(is_nlm_xlp832_ax);
-EXPORT_SYMBOL(is_nlm_xlp8xx_ax);
-EXPORT_SYMBOL(is_nlm_xlp3xx);
-EXPORT_SYMBOL(is_nlm_xlpxxx);
-EXPORT_SYMBOL(is_nlm_xlp316);
-EXPORT_SYMBOL(is_nlm_xlp308);
-EXPORT_SYMBOL(is_nlm_xlp304);
+EXPORT_SYMBOL(is_nlm_xlp);
 EXPORT_SYMBOL(nlm_hal_get_cpuinfo);
-EXPORT_SYMBOL(is_nlm_xlp3xx_lite);
 #endif
 
+
diff --git a/arch/mips/netlogic/common/nlm_hal_fmn_config.c b/arch/mips/netlogic/common/nlm_hal_fmn_config.c
index c0e0c3e..f908ec2 100644
--- a/arch/mips/netlogic/common/nlm_hal_fmn_config.c
+++ b/arch/mips/netlogic/common/nlm_hal_fmn_config.c
@@ -100,6 +100,40 @@ nlm_fmn_config_t xlp3xx_fmn_config[] = {
 [XLP_MSG_HANDLE_MAX] = {XLP_3XX_INVALID_STATION, 0},
 };
 
+nlm_fmn_config_t xlp2xx_fmn_config[] = {
+[XLP_MSG_HANDLE_CPU0] = {XLP_STNID_CPU0, XLP_CPU0_VC_LIMIT},
+[XLP_MSG_HANDLE_CPU1] = {XLP_STNID_CPU1, XLP_CPU1_VC_LIMIT},
+
+[XLP_MSG_HANDLE_CPU2] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU3] = {XLP_2XX_INVALID_STATION, 0},
+
+[XLP_MSG_HANDLE_CPU4] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU5] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU6] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_CPU7] = {XLP_2XX_INVALID_STATION, 0},
+
+[XLP_MSG_HANDLE_PCIE0] = {XLP_PCIE0_VC_BASE, XLP_PCIE0_VC_LIMIT},
+[XLP_MSG_HANDLE_PCIE1] = {XLP_PCIE1_VC_BASE, XLP_PCIE1_VC_LIMIT},
+[XLP_MSG_HANDLE_PCIE2] = {XLP_PCIE2_VC_BASE, XLP_PCIE2_VC_LIMIT},
+[XLP_MSG_HANDLE_PCIE3] = {XLP_PCIE3_VC_BASE, XLP_PCIE3_VC_LIMIT},
+
+[XLP_MSG_HANDLE_DTRE] = {XLP_GDX_VC_BASE, XLP_GDX_VC_LIMIT},
+
+[XLP_MSG_HANDLE_GDX]  = {XLP_GDX_VC_BASE, XLP_GDX_VC_LIMIT},
+[XLP_MSG_HANDLE_REGX] = {XLP_2XX_REGEX_VC_BASE, XLP_2XX_REGEX_VC_LIMIT},
+[XLP_MSG_HANDLE_RSA_ECC] = {XLP_2XX_RSA_ECC_VC_BASE, XLP_2XX_RSA_ECC_VC_LIMIT},
+[XLP_MSG_HANDLE_CRYPTO] = {XLP_2XX_CRYPTO_VC_BASE, XLP_2XX_CRYPTO_VC_LIMIT},
+
+[XLP_MSG_HANDLE_SRIO] = {XLP_2XX_INVALID_STATION,0},
+
+[XLP_MSG_HANDLE_CMP] = {XLP_2XX_CDE_VC_BASE, XLP_2XX_CDE_VC_BASE},
+
+[XLP_MSG_HANDLE_POE] = {XLP_2XX_POE_VC_BASE, XLP_2XX_POE_VC_LIMIT},
+[XLP_MSG_HANDLE_NAE_0] = {XLP_2XX_NET_TX_VC_BASE, XLP_2XX_NET_VC_LIMIT},
+
+[XLP_MSG_HANDLE_INVALID] = {XLP_2XX_INVALID_STATION, 0},
+[XLP_MSG_HANDLE_MAX] = {XLP_2XX_INVALID_STATION, 0},
+};
 extern struct nlm_node_config nlm_node_cfg;
 
 //#define FMN_DEBUG 1
@@ -128,6 +162,23 @@ static struct fmn_qsize_credit_config fmn_qsize_credit_cfg[XLP_MSG_BLK_MAX] = {
 	[XLP_MSG_BLK_SRIO] =    { "srio",   XLP_3XX_SRIO_VC_BASE,  XLP_3XX_SRIO_VC_LIMIT,  1, 1 },
 };
 
+int station_exist_in_2xx(int qid)
+{
+	int hndl;
+	nlm_fmn_config_t *fmn_config = &xlp2xx_fmn_config[0];
+	for(hndl = 0; hndl < XLP_MSG_HANDLE_MAX; hndl++) {
+		if((qid >= fmn_config[hndl].base_vc) && (qid <= fmn_config[hndl].vc_limit))
+			return 1;
+
+	}
+	/* check for popq. 
+	TODO : We should add this also in to the array 
+	 */
+	if(qid >= 128 && qid <= 159)
+		return 1;
+
+	return 0;
+}
 
 /* called based on the chip type */
 static void fmn_modify_qsize_credit_config(int node, int blk, int ntxstns, int b_stid, int e_stid)
@@ -377,7 +428,7 @@ void nlm_hal_enable_vc_intr(int node, int vc)
 void nlm_hal_disable_vc_intr(int node, int vc)
 {
 	uint64_t val = 0;
-	val = nlm_hal_read_outq_config(0, vc);
+	val = nlm_hal_read_outq_config(node, vc);
 	val = val & ~((0x3ULL<<54) | (0x3ULL<<49));
 	nlm_hal_write_outq_config(node, vc, val);
 }
@@ -485,6 +536,11 @@ void stids_toskip(int node) {
 
 	int i;
 
+        if(is_nlm_xlp2xx()) {
+		nlm_print("xlp2xx: please update %s\n", __FUNCTION__);
+		return;
+	}
+
 	for (i=0; i<16; i++)
 		stids[i] = ~0ULL;	/* init to all disabled */
 	
@@ -503,17 +559,28 @@ static void nlm_hal_write_fmn_credit(int node, int max_nodes)
 	int src, qid, hndl = 0, dst_node;
 	nlm_fmn_config_t *fmn_config = NULL;
 	volatile int index;
-	uint32_t credits;
+	uint32_t credits, cfgrd;
 
-        if (is_nlm_xlp3xx()) {
-		nlm_print(" XLP3XX FMN configuration \n");
+        if (is_nlm_xlp3xx() || is_nlm_xlp2xx()) {
+		nlm_print(" XLP3XX/XLP2XX FMN configuration \n");
 		if(is_nlm_xlp316()){
 			nlm_print(" XLP316 FMN configuration \n");
 			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_CPU, 4, XLP_CPU0_VC_BASE, XLP_CPU3_VC_LIMIT);
 		}
-		else if(is_nlm_xlp308()){
-			nlm_print(" XLP308 FMN configuration \n");
-                	fmn_config = &xlp3xx_fmn_config[0];
+		else if(is_nlm_xlp312()){
+			nlm_print(" XLP312 FMN configuration \n");
+			fmn_config = &xlp3xx_fmn_config[0];
+			fmn_config += XLP_MSG_HANDLE_CPU3;
+			for(hndl = 0; hndl<1; hndl++){
+				fmn_config->base_vc = XLP_3XX_INVALID_STATION,
+				fmn_config->vc_limit =0;
+				fmn_config++;
+			}
+			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_CPU, 3, XLP_CPU0_VC_BASE, XLP_CPU2_VC_LIMIT);
+		}
+		else if(is_nlm_xlp308() || is_nlm_xlp208()){
+			nlm_print(" XLP308/208 FMN configuration \n");
+			fmn_config = (is_nlm_xlp308())? &xlp3xx_fmn_config[0] : &xlp2xx_fmn_config[0];
 			fmn_config += XLP_MSG_HANDLE_CPU2;
 			for(hndl = 0; hndl<2; hndl++){
 				fmn_config->base_vc = XLP_3XX_INVALID_STATION,
@@ -523,8 +590,9 @@ static void nlm_hal_write_fmn_credit(int node, int max_nodes)
 			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_CPU, 2, XLP_CPU0_VC_BASE, XLP_CPU1_VC_LIMIT);
 
 		}
-		if(is_nlm_xlp304()){
-                	fmn_config = &xlp3xx_fmn_config[0];
+		else if(is_nlm_xlp304() || is_nlm_xlp204()){
+			nlm_print(" XLP304/204 FMN configuration \n");
+			fmn_config = (is_nlm_xlp304())? &xlp3xx_fmn_config[0] : &xlp2xx_fmn_config[0];
 			fmn_config += XLP_MSG_HANDLE_CPU1;
 			for(hndl = 0; hndl<3; hndl++){
 				fmn_config->base_vc = XLP_3XX_INVALID_STATION,
@@ -534,16 +602,32 @@ static void nlm_hal_write_fmn_credit(int node, int max_nodes)
 
 			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_CPU, 1, XLP_CPU0_VC_BASE, XLP_CPU0_VC_LIMIT);
 		}
+		else {
+		}
 
-		/* 3xx has diffrent vcs for rsa, crypto and nae */
-		fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_RSA_ECC, 1, XLP_3XX_RSA_ECC_VC_BASE, XLP_3XX_RSA_ECC_VC_LIMIT);
-		fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_CRYPTO, 1, XLP_3XX_CRYPTO_VC_BASE, XLP_3XX_CRYPTO_VC_LIMIT);
-		fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_NAE, 1, XLP_3XX_NET_VC_BASE, XLP_3XX_NET_VC_LIMIT);
+		if (is_nlm_xlp3xx()) {
+			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_RSA_ECC, 1, XLP_3XX_RSA_ECC_VC_BASE, XLP_3XX_RSA_ECC_VC_LIMIT);
+			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_CRYPTO, 1, XLP_3XX_CRYPTO_VC_BASE, XLP_3XX_CRYPTO_VC_LIMIT);
+			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_NAE, 1, XLP_3XX_NET_VC_BASE, XLP_3XX_NET_VC_LIMIT);
+		}
+		else if (is_nlm_xlp2xx()) {
+			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_RSA_ECC, 1, XLP_2XX_RSA_ECC_VC_BASE, XLP_2XX_RSA_ECC_VC_LIMIT);
+			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_CRYPTO, 1, XLP_2XX_CRYPTO_VC_BASE, XLP_2XX_CRYPTO_VC_LIMIT);
+			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_NAE, 1, XLP_2XX_NET_VC_BASE, XLP_2XX_NET_VC_LIMIT);
+		}
 			
+		if (is_nlm_xlp3xx_ax() == 0)
+			fmn_modify_qsize_credit_config(node, XLP_MSG_BLK_SRIO, 1, XLP_3XX_SRIO_VC_BASE, XLP_3XX_B0_SRIO_VC_LIMIT);
+
 		/* 3xx does not have compression engine */
-		fmn_invalidate_blocks(node, XLP_MSG_BLK_CMP);
+		if(is_nlm_xlp3xx())
+			fmn_invalidate_blocks(node, XLP_MSG_BLK_CMP);
 
-                fmn_config = &xlp3xx_fmn_config[0];
+		/* 2xx does not have SRIO engine */
+		if(is_nlm_xlp2xx())
+			fmn_invalidate_blocks(node, XLP_MSG_BLK_SRIO);
+
+		fmn_config = (is_nlm_xlp3xx())? &xlp3xx_fmn_config[0] : &xlp2xx_fmn_config[0];
                 for(hndl = 0; hndl < XLP_MSG_HANDLE_MAX; hndl++) {
                         if (fmn_config->base_vc != XLP_3XX_INVALID_STATION) {
 				fmn_update_credit(node, fmn_config->base_vc, node);		
@@ -555,8 +639,11 @@ static void nlm_hal_write_fmn_credit(int node, int max_nodes)
 							fmn_config->base_vc, qid, fmn_cfg_value[qid]);
 					}
 #endif
-					credits = fmn_cfg_value[qid];
-	                                nlm_hal_write_credit(node, fmn_config->base_vc, qid, credits);	
+					cfgrd = credits = fmn_cfg_value[qid];
+					if ((fmn_config->base_vc >= XLP_STNID_CPU0) && (fmn_config->base_vc <= XLP_STNID_CPU7))
+						cfgrd = credits - 1;
+
+	                                nlm_hal_write_credit(node, fmn_config->base_vc, qid, cfgrd);	
                                 }
                         }
                         fmn_config++;
@@ -596,8 +683,11 @@ static void nlm_hal_write_fmn_credit(int node, int max_nodes)
 							src, node, dst_node, qid, fmn_cfg_value[qid]);
 					}
 #endif
-					credits = fmn_cfg_value[qid];
-					nlm_hal_write_credit(node, src, ((dst_node << 10) | qid), credits);	
+					cfgrd = credits = fmn_cfg_value[qid];
+					if ((src >= XLP_STNID_CPU0) && (src <= XLP_STNID_CPU7))
+						cfgrd = credits - 1;
+
+					nlm_hal_write_credit(node, src, ((dst_node << 10) | qid), cfgrd);	
 				}
 			}
 		}
@@ -648,8 +738,9 @@ int nlm_hal_setup_outq(int node, int max_nodes)
 	uint32_t q_ram_start_page = 0;
 	const int q_ram_pages = 1;
 	const uint32_t q_ram_page_entries = 32; /* entries, not bytes */
+	int cnt =0;
 
-	if (is_nlm_xlp3xx()) {
+	if (is_nlm_xlp3xx() || is_nlm_xlp2xx()) {
 		max_qs = XLP_3XX_NET_VC_LIMIT;
 	}
 	else {
@@ -686,7 +777,14 @@ int nlm_hal_setup_outq(int node, int max_nodes)
 		 * Configuration of on-chip RAM area
 		 **************************************************************
 		 */
-		q_ram_base = ram_base + (qid * q_ram_pages * q_ram_page_entries);
+		/* As 2xx has only 8k onchip memory skip all the invalid stations */
+		if(is_nlm_xlp2xx()) {
+			if(!station_exist_in_2xx(qid))
+				continue;
+			q_ram_base = ram_base + (cnt * q_ram_pages * q_ram_page_entries);
+			cnt++;
+		} else 
+			q_ram_base = ram_base + (qid * q_ram_pages * q_ram_page_entries);
 
 		val |= ( ((q_ram_base >> 10) & 0x1f) << 10); /* [14:10] of q_ram_base */
 
@@ -694,30 +792,33 @@ int nlm_hal_setup_outq(int node, int max_nodes)
 		val |= (q_ram_start_page << 0);
 		val |= ( (q_ram_start_page + q_ram_pages - 1) << 5) ;
 
-		/***************************************************************
-		 * Configuration of spill area
-		 **************************************************************
-		 */
-		/* pages in 4K units */
-		q_spill_pages = fmn_cfg_value[qid] / (FMN_Q_PAGE_SIZE);
+		if (nlm_node_cfg.fmn_cfg[node]->fmn_spill_base != 0ULL) {
+
+			/***************************************************************
+			 * Configuration of spill area
+			 **************************************************************
+			 */
+			/* pages in 4K units */
+			q_spill_pages = fmn_cfg_value[qid] / (FMN_Q_PAGE_SIZE);
 		
-		/* if spill_start + qsize crosses 256MB boundary, configuration will be wrong as 
-		 only 17-12 bits only considered for spill last */
-		if(((spill_base & (FMN_MAX_Q_SIZE - 1)) +  fmn_cfg_value[qid]) > FMN_MAX_Q_SIZE)
-			spill_base = (spill_base + FMN_MAX_Q_SIZE - 1) & (~(FMN_MAX_Q_SIZE - 1));
+			/* if spill_start + qsize crosses 256MB boundary, configuration will be wrong as 
+			 only 17-12 bits only considered for spill last */
+			if(((spill_base & (FMN_MAX_Q_SIZE - 1)) +  fmn_cfg_value[qid]) > FMN_MAX_Q_SIZE)
+				spill_base = (spill_base + FMN_MAX_Q_SIZE - 1) & (~(FMN_MAX_Q_SIZE - 1));
 		
-		val |= ( ((spill_base >> 18) & 0x3fffff) << 27); /* [39:18] of q_spill_base */
+			val |= ( ((spill_base >> 18) & 0x3fffff) << 27); /* [39:18] of q_spill_base */
 
-		q_spill_start_page = (spill_base >> 12) & 0x3f; /* [17:12] of q_spill_base */
-		val |= (q_spill_start_page << 15);
-		val |= ( (q_spill_start_page + q_spill_pages - 1) << 21);
+			q_spill_start_page = (spill_base >> 12) & 0x3f; /* [17:12] of q_spill_base */
+			val |= (q_spill_start_page << 15);
+			val |= ( (q_spill_start_page + q_spill_pages - 1) << 21);
 
 #ifdef FMN_DEBUG
 		nlm_print("Fmn q config %d sqbase %lx sqsize %d sqpages %d\n", 
 				qid, (long)spill_base, fmn_cfg_value[qid], (int)q_spill_pages);
 #endif
 		
-		spill_base +=  fmn_cfg_value[qid];
+			spill_base +=  fmn_cfg_value[qid];
+		}
 		
 		/* Write to the configuration register */
 		nlm_hal_write_outq_config(node, qid, val);
@@ -908,6 +1009,15 @@ int parse_fdt_fmn_config(void *fdt)
 	return max_nodes;
 }
 
+int get_dom_fmn_node_ownership(void *fdt, int dom_id)
+{
+	uint32_t owner_mask;
+
+	owner_mask = get_dom_owner_mask(fdt, dom_id, "fmn");
+
+	return owner_mask;
+}
+
 /**
 * @brief nlm_hal_fmn_init function Initializes FMN (outpu Queues and Credit registers)
 *
@@ -946,7 +1056,10 @@ void nlm_hal_fmn_init(void *fdt)
 	}
 
 	for (node = 0; node < max_nodes; node++) {
-		nlm_hal_soc_clock_enable(node, DFS_DEVICE_RSA);
+		if(!is_nlm_xlp2xx()) {
+			nlm_hal_soc_clock_enable(node, DFS_DEVICE_RSA);
+		} else {
+		}
 	}
 
 	//fmn_qsize_credit_cfg_extract(fdt);
diff --git a/arch/mips/netlogic/common/nlm_hal_nae.c b/arch/mips/netlogic/common/nlm_hal_nae.c
index 4a94a00..a514c1e 100644
--- a/arch/mips/netlogic/common/nlm_hal_nae.c
+++ b/arch/mips/netlogic/common/nlm_hal_nae.c
@@ -1,27 +1,32 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (Netlogic). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
 
 #ifdef NLM_HAL_LINUX_KERNEL
 #include <linux/netdevice.h>
@@ -33,6 +38,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include "libfdt.h"
 #include "fdt_helper.h"
 #include "nlm_evp_cpld.h"
+#include "nlm_hal_vsemi_data.h"
 
 #define VAL_UCORE_RESET(x) ( ( (x) &0xffff) << 8)
 
@@ -42,41 +48,79 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define GET_PORT_STR_PROP(prop, buf, len)                                       \
         copy_fdt_prop(fdt, nae_port_str, prop, PROP_STR, buf, len)
 
+#define NLM_NAE_MAX_XONOFF_THR_GRPS 8
+
 extern struct nlm_hal_ext_phy* get_phy_info(int inf);
 extern void nlm_hal_ext_phy_an(int node, int inf);
 extern void register_phy(int node, int inf, int* hw_portid);
 extern void nlm_hal_init_ext_phy(int node, int inf);
+extern uint32_t get_dom_owner_mask(void *fdt, int dom_id, char *module);
+extern int nlm_hal_get_fdt_freq(void *fdt, int type);
 
 static int nae_reset_done[NLM_MAX_NODES] = { 0 };
 static void xlp_nae_config_interlaken(int node, int blk,int port, int num_lanes);
 static void xlp_nae_config_xaui(int node, int block, int port, int vlan_pri_en,
-                              int rxaui_scrambler, int mode);
+                              int rxaui_scrambler, int mode, int higig_type);
 static unsigned int ucore_shared_scratch[NLM_MAX_NODES][128];
 static unsigned int ucore_shared_scratch_words[NLM_MAX_NODES];
 static void xlp_nae_config_lane_gmac(int node, int cplx_mask);
+static void xlp_nae_ilk_loopback(int node, int blk, int num_lanes);
+static inline void nlm_hal_PMFF_ALL_workaround(int node, int block, int lane_ctrl);
 
 uint32_t *cntx2port[NLM_MAX_NODES];
 
+extern unsigned char vsemi_mem_sgmii_4page [256];
+extern unsigned char vsemi_mem_sgmii [256];
+
+extern unsigned char vsemi_mem_xaui_4page [256];
+extern unsigned char vsemi_mem_xaui [256];
+
+extern unsigned char vsemi_mem_12G_4page [256];
+extern unsigned char vsemi_mem_12G [256];
+
+extern unsigned char vsemi_mem_16G_4page [256];
+extern unsigned char vsemi_mem_16G [256];
+extern void vsemi_mem_init_sgmii_125Mhzrefclk(void);
+extern void nlm_hal_config_vsemi_mem_sgmii_4page_125Mhz(void);
+
+//#define MACSEC_DEBUG 1
+// #define INCLUDE_NAE_DEBUG 1
 #ifdef INCLUDE_NAE_DEBUG
 #define NAE_DEBUG	nlm_print
 #else
 #define NAE_DEBUG(...)
 #endif
-
+#undef VSEMI_DEBUG
 static uint32_t nae_vfbid_tbl[NLM_MAX_NODES][MAX_VFBID_ENTRIES];
 
+//#define NAE_SH_INFO_DBG 1
 #ifdef NAE_SH_INFO_DBG
 #define nlm_dbg_print nlm_print
 #else
 #define nlm_dbg_print(x, args...) { }
 #endif
 
+static uint32_t nlm_get_max_ports(void)
+{
+	uint32_t max_ports;
+	if (is_nlm_xlp3xx()) {
+		max_ports = XLP_3XX_MAX_PORTS;
+	}
+	else if (is_nlm_xlp2xx()) {
+		max_ports = XLP_2XX_MAX_PORTS;
+	}
+	else {
+		max_ports = XLP_MAX_PORTS;
+	}
+	return max_ports;
+}
+
 void nae_ext_mdio_wait(int n)
 {
 	volatile int s=0, i,j;
 	unsigned long long freq = nlm_hal_cpu_freq();
 	freq >>= 17;
-	if ( is_nlm_xlp8xx_b0() )
+	if ( is_nlm_xlp3xx_ax() || is_nlm_xlp8xx_ax() || is_nlm_xlp8xx_b0() )
 	   return;
 	for(j=0; j<n; j++)
 	for(i=0; i<freq; i++) s++;
@@ -105,6 +149,9 @@ void nae_ext_mdio_wait(int n)
  * 3 8
  *------------------------------
  */
+//0x1E: 0001 11,10  addDiv=7, div=2 ==> 18.75KHz if nae.ref=250Mhz
+//0x10: 0001 00,00  addDiv=4, div=0 ==> 0.5Mhz if nae.ref=250MHz
+//0x11: 0001 00,01  addDiv=4, div=1 ==> 0.5Mhz if nae.ref=500MHz
 static uint32_t nae_get_EXT_G_MDIO_DIV(void)
 {
 	/*
@@ -113,19 +160,25 @@ static uint32_t nae_get_EXT_G_MDIO_DIV(void)
 	 * XLP8XX_B1_EXT_G_MDIO_DIV:= b100,00 = 0x10
 	 */
 	return (
-	       is_nlm_xlp8xx_b0() ) ?  EXT_G_MDIO_DIV : EXT_G_MDIO_DIV_WITH_HW_DIV64;
+	       is_nlm_xlp3xx_ax() ||
+	       is_nlm_xlp8xx_ax() ||
+	       is_nlm_xlp8xx_b0() ) ?  EXT_G_MDIO_DIV : EXT_G_MDIO_DIV_WITH_HW_DIV64_11;
 }
 
 /* INT_MDIO_CTRL, block7, 0x799
  * EXT_XG_MDIO_CTRL, block7, 0x7A5,0x7A9
  * 29:28: MCDiv Master Clock Divider
- *     0: 50
- *     1: 5
- *     2: 1
+ * 0 1
+ * 1 2
+ * 2 4
+ * 3 8
  * 27:21: XDiv Clock Divisor
  *   M(mdc) = F(mstclk)/(2*(XDiv+1))
- *    500MHz/50 = 10MHz
- *    10MHz/(2*(9+1)) = 0.5MHz
+ *    500MHz/4 = 125MHz
+ *    125MHz/(2*(0x7F+1)) = 0.5MHz
+ *
+ *    250MHz/4 = 62.5MHz
+ *    62.5MHz/(2*(0x7F+1)) = 0.24MHz
  */
 static uint32_t nae_get_INT_MDIO_DIV(void)
 {
@@ -619,8 +672,6 @@ int nlm_hal_mdio_write(int node, int type, int bus, int block, int intf_type,
 * @param [in] node Node number
 * @param [in] type NLM_HAL_INT_MDIO or NLM_HAL_EXT_MDIO
 * @param [in] bus MDIO bus number
-* @param [in] [To be deleted] block NAE Register Memory Map Block
-* @param [in] [To be deleted] LANE_CFG (only valid for block 7)
 *
 * @return
 *	- 0 on success
@@ -643,19 +694,184 @@ int nlm_hal_mdio_reset(int node, int type, int bus)
 	}
 }
 
+static int nlm_hal_vsemi_cmd_poll_pend(int node, int block)
+{
+	uint32_t vsemi_cmd=0; 
+	uint32_t  retries=0;
+	/*wait for command to clear*/	
+	while(retries<100){
+		vsemi_cmd = nlm_hal_read_mac_reg(node, block, PHY, VSEMI_CMD);
+		if( vsemi_cmd & (1<<31)){
+			retries++;
+			nlm_mdelay(100);	
+			continue;
+		}else{
+			//nlm_print("VSEMI cmd pend clear\n");	
+			break;
+		}
+	}
+	
+	if(retries==100){
+		nlm_print("VSEMI cmd  clear NOT OK: VSEMI Configuration may not work\n");
+		return 0;
+	}
+
+	return (vsemi_cmd&0xff);
+}
+
+void write_vsemi_reg(int node, int block, uint32_t lane_no, uint32_t addr, uint32_t data) {
+    uint32_t tmp_data;
+    tmp_data = (0x2 << 29) | (lane_no << 21) | ((addr & 0x1fff) << 8) | (data & 0xff);
+    nlm_hal_write_mac_reg(node, block, PHY, VSEMI_CMD, tmp_data);
+    nlm_hal_vsemi_cmd_poll_pend(node, block);	
+} 
+
+static uint32_t read_vsemi_reg(int node, int block, uint32_t lane_no, uint32_t addr)
+{
+    uint32_t tmp_data, rd_data;
+    tmp_data = (0x3 << 29) | (lane_no << 21) | ((addr & 0x1fff) << 8);
+    nlm_hal_write_mac_reg(node, block, PHY, VSEMI_CMD, tmp_data);
+    rd_data = nlm_hal_vsemi_cmd_poll_pend(node, block);
+    return (rd_data & 0xFF);
+}
+
+#ifdef VSEMI_DEBUG
+static void display_vsemi_indirect_reg(int node, int block) 
+{
+     uint32_t rd_data, reg_addr, lane_no;
+    for (reg_addr=101; reg_addr <111; reg_addr++) {
+        for (lane_no=0; lane_no < 4; lane_no++) {
+            rd_data = read_vsemi_reg(node, block, lane_no, reg_addr);
+            nlm_print("VSEMI::  lane:%0d addr: 0x%x rd_data: 0x%02x\n",lane_no, reg_addr, rd_data);
+        }
+    }
+    for (reg_addr=101; reg_addr <165; reg_addr++) {
+        rd_data = read_vsemi_reg(node, block, 4, reg_addr);
+        nlm_print("VSEMI:: common lane addr: 0x%x rd_data: 0x%02x\n", reg_addr, rd_data);
+    }
+
+	
+}
+#endif //VSEMI_DEBUG
+
+void nlm_hal_xlp2xx_nae_program_vsemi(int node, int block, int xaui_speed, int phy_mode)
+{
+	uint32_t reg_addr, lane_no;
+	uint32_t vsemi_cmd=0; 
+	for (reg_addr=101; reg_addr <111; reg_addr++){
+		for (lane_no=0; lane_no<4; lane_no++) { 
+			vsemi_cmd=0; 
+			if(xaui_speed==16){
+				vsemi_cmd |= vsemi_mem_16G_4page[reg_addr];		
+			}
+			if(xaui_speed==12){
+				vsemi_cmd |= vsemi_mem_12G_4page[reg_addr];		
+			}
+			if((xaui_speed==10) || (phy_mode==PHYMODE_XAUI)){
+				vsemi_cmd |= vsemi_mem_xaui_4page[reg_addr];		
+			}
+			if(phy_mode==PHYMODE_SGMII){
+				vsemi_cmd |= vsemi_mem_sgmii_4page[reg_addr]; 
+			}
+			write_vsemi_reg(node, block, lane_no, reg_addr, vsemi_cmd);
+		}
+	}
+	
+	/*configure only page 4*/
+	for (reg_addr=101; reg_addr <165; reg_addr++){
+		vsemi_cmd=0; 
+		if(xaui_speed==16){
+			vsemi_cmd |= vsemi_mem_16G[reg_addr];		
+		}
+		if(xaui_speed==12){
+			vsemi_cmd |= vsemi_mem_12G[reg_addr];		
+		}
+		if((xaui_speed==10) || (phy_mode==PHYMODE_XAUI)){
+			vsemi_cmd |= vsemi_mem_xaui[reg_addr];		
+		}
+		if(phy_mode==PHYMODE_SGMII){
+			vsemi_cmd |= vsemi_mem_sgmii[reg_addr]; 
+		}
+		write_vsemi_reg(node, block, 4, reg_addr, vsemi_cmd);
+	}
+
+	for (lane_no=0; lane_no<4; lane_no++) {
+		write_vsemi_reg(node, block, lane_no, 21, 0xd9);
+		write_vsemi_reg(node, block, lane_no, 22, 0x0);
+		write_vsemi_reg(node, block, lane_no, 23, 0x0);
+		write_vsemi_reg(node, block, lane_no, 87, 0x1f);
+	}
+
+	for (lane_no=0; lane_no<4; lane_no++) {
+		write_vsemi_reg(node, block, lane_no, 24, 0x2);
+		write_vsemi_reg(node, block, lane_no, 25, 0x0);
+		write_vsemi_reg(node, block, lane_no, 26, 0x08);
+		write_vsemi_reg(node, block, lane_no, 27, 0x78);
+		write_vsemi_reg(node, block, lane_no, 28, 0x0);
+		vsemi_cmd = read_vsemi_reg(node, block, lane_no, 86);
+		vsemi_cmd &= ~(1<<3);
+		write_vsemi_reg(node, block, lane_no, 86, vsemi_cmd);
+	}
+
+	nlm_print("VSEMI configuration is OK \n");
+}
+
+static uint32_t indirect_pma_register_read(int node, int block, int lane_ctrl, int pma_reg_addr)
+{
+	uint32_t val = 0; 
+	val = nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl);
+	val |= (1<<30) | (1<<17) | (1<<16);
+	val = val | (pma_reg_addr<<8);
+	nlm_hal_write_mac_reg(node, block, PHY, lane_ctrl, val);
+	while(1){
+		val = nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl); 
+		if(val & (1<<18))
+			break;
+	}
+	return (val&0xff);
+}
+
+
+static void indirect_pma_register_wite(int node, int block, int lane_ctrl, int pma_reg_addr, int reg_val)
+{
+	uint32_t val = 0,i; 
+	val = nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl);
+	val |= (1<<30) | (1<<17);
+	val &= ~(1<<16);
+	val = (val & 0xffff0000) | ((pma_reg_addr & 0xff) << 8) | (reg_val & 0xff); 
+  
+	for (i=0; i<2; i++) {
+		nlm_hal_write_mac_reg(node, block, PHY, lane_ctrl, val);
+		while(1) {
+			val = nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl); 
+			if(val & (1<<18))
+			break;
+		}
+	}
+}
+
+void set_bit2_pm_fifo (int node, int block, int lane_ctrl)
+{
+	uint32_t val = 0;
+	val = indirect_pma_register_read(node,  block, lane_ctrl, 0xE);
+	val |= (1<<2);
+	indirect_pma_register_wite(node,  block, lane_ctrl, 0xE, val);		
+	val = indirect_pma_register_read(node,  block, lane_ctrl, 0xE);
+}
+
+
 // PLL 
 /**********************************************************************
  *  nae_lane_reset_txpll
  * * serdes lane progaming 
  ********************************************************************* */
-
 /**
-* @brief xlp3xx_8xxb0_nae_lane_reset_txpll function is used to reset the Tx PLL for XLP3XX and XLP8XX-B0 products.
+* @brief xlp2xx_nae_lane_reset_txpll function is used to reset the Tx PLL for XLP2XX products.
 *
 * @param [in] node Node number
 * @param [in] block NAE Register Memory Map Block
 * @param [in] lane_ctrl Lane to reset (0-3)
-* @param [in] mode 0-unused, 1-XAUI, 2-SGMII, 3-INTERLAKEN
+* @param [in] mode 0-unused, 1-XAUI/HS-SGMII, 2-SGMII, 3-INTERLAKEN, 6-PHYMODE_RXAUI
 *
 * @return
 * 	- none
@@ -663,10 +879,10 @@ int nlm_hal_mdio_reset(int node, int type, int bus)
 * @ingroup hal_nae
 *
 */
-void xlp3xx_8xxb0_nae_lane_reset_txpll(int node, int block, int lane_ctrl, int mode)
+
+void xlp2xx_nae_lane_reset_txpll(int node, int block, int lane_ctrl, int mode)
 {
 	uint32_t val = 0;
-	int rext_sel = 0;
 	NAE_DEBUG("%s: block %d lane_ctrl %x \n",__func__,block,lane_ctrl);
 
 	/* rxaui mode only lanes 0 and 2 are used in each complex, 1/3 not used
@@ -674,35 +890,148 @@ void xlp3xx_8xxb0_nae_lane_reset_txpll(int node, int block, int lane_ctrl, int m
 	 */
 	if(mode == PHYMODE_RXAUI && (lane_ctrl%2) )
 		return;
+	
+	val = (1<<20) | (1<<29);
+	val = (mode << PHY_LANE_CTRL_PHYMODE_POS) | (val&0xe1ffffff);
+        nlm_hal_write_mac_reg(node, block, PHY, lane_ctrl, val);
+	nlm_mdelay(1);
+	
+	val = nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl);
+	NAE_DEBUG("xlp2xx_nae_lane_reset_txpll value before power down =0x%x\n", val);
+	
+	val &= ~(1<<29);
+	val = val & 0xfff80000;
+        nlm_hal_write_mac_reg(node, block, PHY, lane_ctrl, val);
+	nlm_mdelay(1);
+	
+	val = nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl);
+	NAE_DEBUG("xlp2xx_nae_lane_reset_txpll value after power up =0x%x\n", val);
+	val |=(1<<30);
+        nlm_hal_write_mac_reg(node, block, PHY, lane_ctrl, val);
+	nlm_mdelay(1);
+	while(!((val = nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl-PHY_LANE_0_CTRL)) & PHY_LANE_STAT_PCR));
+
+
+	NAE_DEBUG("Before register reset de-assertion PMA value=0x%x\n", nlm_hal_read_mac_reg( node, block, PHY, lane_ctrl));
+}
+
+/**
+* @brief xlp3xx_8xxb0_nae_lane_reset_txpll function is used to reset the Tx PLL for XLP3XX and XLP8XX-B0 products.
+*
+* @param [in] node Node number
+* @param [in] block NAE Register Memory Map Block
+* @param [in] lane_ctrl Lane to reset (0-3)
+* @param [in] mode 0-unused, 1-XAUI/HS-SGMII, 2-SGMII, 3-INTERLAKEN, 6-PHYMODE_RXAUI
+*
+* @return
+* 	- 0 on success, non-zero on failure
+* 
+* @ingroup hal_nae
+*
+*/
+int xlp3xx_8xxb0_nae_lane_reset_txpll(int node, int block, int lane_ctrl, int mode)
+{
+	uint32_t val = 0;
+	int rext_sel = 0;
+	int count=0;
+	int count_max=1000;
+	uint32_t val_temp=0;
+	NAE_DEBUG("%s: node %d block %d lane_ctrl %x \n", __func__, node, block, lane_ctrl);
+
+	/* rxaui mode only lanes 0 and 2 are used in each complex, 1/3 not used
+	 * skip lane 1 & 3 by setting lane_inc = 2
+	 */
+	if(mode == PHYMODE_RXAUI && (lane_ctrl%2))
+	{
+		NAE_DEBUG("mode is %x so function is returning\n", mode);
+		return 0;
+	}
 
 	if(lane_ctrl != 4)
 		rext_sel = (1 << 23);
-		
+
 	NAE_DEBUG("Before register reset de-assertion PMA value=0x%x\n", nlm_hal_read_mac_reg( node, block, PHY, lane_ctrl));
 
 	val = nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl);
+
+
+	val |= (1<< 29);
+	val &= ~((1<< 30)&0xFFFFFFFF);
+	val &= ~((1<< 20) & 0xFFFFFFFF);
+	val |= (mode << PHY_LANE_CTRL_PHYMODE_POS);
+	val |= rext_sel;
+	val &= ~(1 << 17); //setting indirect register request access to 0
+
+	NAE_DEBUG("PHY LANE CTRL REG to be written with value: %x\n",val);
+	nlm_hal_write_mac_reg(node, block, PHY, lane_ctrl,val);
+	val_temp=nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl);
+	NAE_DEBUG("PHY LANE CTRL REG that was just written is :  %x\n", val_temp);
+	nlm_mdelay(1);
+
+
 	if(mode != PHYMODE_SGMII){
-		val |= PHY_LANE_CTRL_BPC_XAUI; /*Set comma bypass for XAUII*/
+		val |= PHY_LANE_CTRL_BPC_XAUI; /*Set comma bypass for XAUI*/
+		NAE_DEBUG("Just set comma bypass for XAUI\n");
 	}
-	val |= 0x100000 | (mode << PHY_LANE_CTRL_PHYMODE_POS);  /* Bit20: serdes reg reset Storm & Eagle B0 */
-	val &= ~(0x20000);
-        nlm_hal_write_mac_reg(node, block, PHY, lane_ctrl,val);
-	nlm_mdelay(1);
-		
-	val = nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl);
-	val |= 0x40000000; /* Unset the reset (inverse logic) : Bit30: epcs reset */
-        nlm_hal_write_mac_reg(node, block, PHY, lane_ctrl,val);
-	nlm_mdelay(1);
-	NAE_DEBUG(" After serdes  de-assertion PMA value=0x%x\n", nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl));
+	NAE_DEBUG("Setting the PMA Register Bit(Bit 20)\n");
+	val |= 0x100000;  /* Bit20: serdes reg reset Storm & Eagle B0 */
+	nlm_hal_write_mac_reg(node, block, PHY, lane_ctrl,val);
+	val_temp=nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl);
+	NAE_DEBUG("PHY LANE CTRL REG that was just written is :  %x\n", val_temp);
 
 
 	/* Clear the Power Down bit */
+	NAE_DEBUG("Clearing the Power Down Bit(Bit 29)\n");
 	val = nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl);
+	NAE_DEBUG("Just read the value in register as %x\n", val);
 	val &= ~( (1 << 29) | (0x7ffff));
-	nlm_hal_write_mac_reg(node, block, PHY, lane_ctrl, (rext_sel | val));
-	nlm_mdelay(1);
+	nlm_hal_write_mac_reg(node, block, PHY, lane_ctrl, val);
+	val_temp=nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl);
+	NAE_DEBUG("PHY LANE CTRL REG that was just written is :  %x\n", val_temp);
+
+	NAE_DEBUG("Setting PMA Controller reset bit(Bit 30)\n");
+	val = nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl);
+	val |= 0x40000000; /* Unset the reset (inverse logic) : Bit30: epcs reset */
+	nlm_hal_write_mac_reg(node, block, PHY, lane_ctrl,val);
+	val_temp=nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl);
+	NAE_DEBUG("PHY LANE CTRL REG that was just written is :  %x\n", val_temp);
+
+	while ((nlm_hal_read_mac_reg(node, block, PHY, (lane_ctrl - 4)) & (PHY_LANE_STAT_PCR)) != (PHY_LANE_STAT_PCR) && count!=count_max) 
+	{
+		NAE_DEBUG("Wait for PMA Ready ..........%d\n", count);
+		count++;
+	}
+	if(count==count_max)
+	{
+		nlm_print("PMA controller of node %d complex %d and lane %d did not come out of reset!!\n", node, block, (lane_ctrl-4));
+		return -1;
+	}
+	count=0;
+	while ((nlm_hal_read_mac_reg(node, block, PHY, (lane_ctrl - 4)) & (LANE_TX_CLK)) != LANE_TX_CLK && count!=count_max) 
+	{
+		NAE_DEBUG("Wait for TX clock to become stable ..........%d\n", count);
+		count++;
+	}
+	if(count==count_max)
+	{
+		nlm_print(" TX clock stable bit of node %d complex %d and lane %d not set!!\n", node, block, (lane_ctrl-4));
+		return -2;
+	}
+	count=0;
+	while ((nlm_hal_read_mac_reg(node, block, PHY, (lane_ctrl - 4)) & (LANE_RX_CLK)) != LANE_RX_CLK && count!=count_max) 
+	{
+		NAE_DEBUG("Wait for RX clock to become stable ..........%d\n", count);
+		count++;
+	}
+	if(count==count_max)
+	{
+		nlm_print("RX clock stable bit of node %d complex %d and lane %d not set!!\n", node, block, (lane_ctrl-4));
+		return -3;
+	}
+	NAE_DEBUG("Reset PMA for node %d complex %d and lane %d was successful!! \n", node, block, (lane_ctrl-4));
 
-	NAE_DEBUG("Reset PLL done \n");
+	nlm_print("Reset PLL done @node:%d block:%d lane:%d mode:%d\n", node, block, lane_ctrl, mode);
+    return 0;
 }
 
 
@@ -778,6 +1107,7 @@ void xlp8xx_ax_nae_lane_reset_txpll(int node, int block, int lane_ctrl, int mode
 			       | rext_sel
 			       | val );
 	while (((val = nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl)) & PHY_LANE_CTRL_CMD_PENDING));
+
 	val &= 0xFF;
 
 	/* set bit[4] to 0
@@ -840,7 +1170,8 @@ static void xlp_nae_config_lane_gmac(int node, int cplx_mask)
 {
 	int block, lane_ctrl;
 	int cplx_lane_enable = LM_SGMII | (LM_SGMII << 4) | (LM_SGMII << 8) | (LM_SGMII << 12);
-	int lane_enable = 0;
+	int lane_enable = 0, vsemi_config=0;
+	static int vsemi_por=0;
 
 	/*  Lane mode progamming
 	 */
@@ -875,6 +1206,7 @@ static void xlp_nae_config_lane_gmac(int node, int cplx_mask)
 		{
 			if (is_nlm_xlp8xx_bx()) {
 				xlp3xx_8xxb0_nae_lane_reset_txpll(node, block, lane_ctrl, PHYMODE_SGMII);
+				nlm_hal_PMFF_ALL_workaround(node, block, lane_ctrl);
 			} else {
 				xlp8xx_ax_nae_lane_reset_txpll(node, block, lane_ctrl, PHYMODE_SGMII);
 			}
@@ -886,24 +1218,66 @@ static void xlp_nae_config_lane_gmac(int node, int cplx_mask)
 		if ((cplx_mask & (1 << block)) == 0) {
 			continue;
 		}
+		
+		if(is_nlm_xlp2xx()){
+			int delay;
+//#if 0
+			if(!vsemi_por){			
+				vsemi_config = nlm_hal_read_mac_reg(node, block+1, PHY, VSEMI_CTL0);
+				vsemi_config &= ~VSEMI_CTL_POR;
+				nlm_hal_write_mac_reg(node, block+1, PHY, VSEMI_CTL0, vsemi_config);
+				vsemi_por++;
+			}
+//#endif
+			vsemi_config = nlm_hal_read_mac_reg(node, block, PHY, VSEMI_CTL0);
+			vsemi_config &= 0xFFFF01FF;
+			vsemi_config |= VSEMI_CTL_POR | VSEMI_CTL_SYNTH_RST | VSEMI_CTL_RTHR;
+			nlm_hal_write_mac_reg(node, block, PHY, VSEMI_CTL0, vsemi_config);
+    			
+			for(delay=0; delay<1000000; delay++);
+			
+			vsemi_config = nlm_hal_read_mac_reg(node, block, PHY, VSEMI_CTL0);
+			vsemi_config &= ~VSEMI_CTL_POR;
+			vsemi_config &= 0xFFFFFE00;
+			nlm_hal_write_mac_reg(node, block, PHY, VSEMI_CTL0, vsemi_config);
+    			
+			for(delay=0; delay<1000000; delay++);
+			vsemi_config = nlm_hal_read_mac_reg(node, block, PHY, VSEMI_CTL1);
+			vsemi_config &= ~((0x7<<4) | 0x7);
+			vsemi_config |= VSEMI_CTL_SGMII_DR | VSEMI_CTL_SGMII_DW;
+			nlm_hal_write_mac_reg(node, block, PHY, VSEMI_CTL1, vsemi_config);
+
+			nlm_hal_xlp2xx_nae_program_vsemi(node, block, 0, PHYMODE_SGMII);
+#ifdef VSEMI_DEBUG
+			display_vsemi_indirect_reg(node, block);
+#endif
+			
+			vsemi_config = nlm_hal_read_mac_reg(node, block, PHY, VSEMI_CTL0);
+			vsemi_config &= ~(VSEMI_CTL_POR | VSEMI_CTL_SYNTH_RST | VSEMI_CTL_RTHR);
+			nlm_hal_write_mac_reg(node, block, PHY, VSEMI_CTL0, vsemi_config);
+		}
 
 		for( lane_ctrl = PHY_LANE_0_CTRL; lane_ctrl <= PHY_LANE_3_CTRL; lane_ctrl++){
 			if ((is_nlm_xlp3xx()) || (is_nlm_xlp8xx_bx())) {
 				xlp3xx_8xxb0_nae_lane_reset_txpll(node, block, lane_ctrl, PHYMODE_SGMII);
+				nlm_hal_PMFF_ALL_workaround(node, block, lane_ctrl);
+			}else if(is_nlm_xlp2xx()){
+				xlp2xx_nae_lane_reset_txpll(node, block, lane_ctrl, PHYMODE_SGMII);
 			}else{
 				xlp8xx_ax_nae_lane_reset_txpll(node, block, lane_ctrl, PHYMODE_SGMII);
-		}	}
+			}	
+		}
 	}
 	return;
 }
 
 void nlm_hal_mdio_init(int node)
 {
-	nlm_hal_mdio_reset(node, NLM_HAL_INT_MDIO, 0);
-	nlm_hal_mdio_reset(node, NLM_HAL_EXT_MDIO, 0);
-	nlm_hal_mdio_reset(node, NLM_HAL_EXT_MDIO, 1);
-	nlm_hal_mdio_reset(node, NLM_HAL_EXT_MDIO_C45, 0);
-	nlm_hal_mdio_reset(node, NLM_HAL_EXT_MDIO_C45, 1);
+        nlm_hal_mdio_reset(node, NLM_HAL_INT_MDIO, 0);
+        nlm_hal_mdio_reset(node, NLM_HAL_EXT_MDIO, 0);
+        nlm_hal_mdio_reset(node, NLM_HAL_EXT_MDIO, 1);
+        nlm_hal_mdio_reset(node, NLM_HAL_EXT_MDIO_C45, 0);
+        nlm_hal_mdio_reset(node, NLM_HAL_EXT_MDIO_C45, 1);
 	nlm_mdelay(3);
 }
 
@@ -921,6 +1295,12 @@ void nlm_hal_mdio_init(int node)
 */
 void nlm_hal_sgmii_pcs_init(int node, int sgmii_cplx_mask)
 {
+	if( is_nlm_xlp2xx() )
+	{
+		vsemi_mem_init_sgmii_125Mhzrefclk();
+		nlm_hal_config_vsemi_mem_sgmii_4page_125Mhz();
+	}
+
 #if !defined(XLP_SIM) || defined(NLM_BOARD)
         sgmii_scan_phys(node);
 #endif
@@ -1112,7 +1492,7 @@ static int local_load_ucore(int node, int ucore_mask, unsigned int *opcodes, int
 
 	nlm_print("Loading ucores (mask = 0x%04x)\n", mask);
 
-	if (is_nlm_xlp3xx()) {
+	if (is_nlm_xlp3xx() || is_nlm_xlp2xx()) {
                 max_ucore = XLP_3XX_MAX_NAE_UCORES;
         }
         else {
@@ -1257,7 +1637,7 @@ void nlm_hal_init_poe_ext_storage(int node, uint64_t fbp_base_phys,
 	/* Free Buffer Pool config */
 	nlm_print (" POE Free Buffer Pool config ...\n");
 
-	if (is_nlm_xlp3xx()) {
+	if (is_nlm_xlp3xx() || is_nlm_xlp2xx()) {
 		a = (uint64_t)XLP3XX_EXT_FBP_START_ADDR;
 		num_messages = XLP3XX_MAX_POE_EXT_MSG_STORAGE;
 	}
@@ -1368,6 +1748,8 @@ int nlm_hal_init_poe_distvec(int node,int vec, uint32_t cm0, uint32_t cm1,
 		}
 	}
 
+	nlm_disable_distribution(node);
+
 	/* Write distribution vector cells */
 	for (i = 0; i < NUM_DISTVEC_CELLS; i++) {
 		int reg_index;
@@ -1382,9 +1764,52 @@ int nlm_hal_init_poe_distvec(int node,int vec, uint32_t cm0, uint32_t cm1,
 		nlm_hal_write_poe_pcim_reg(node, reg_index, value);
 	}
 
+	nlm_enable_distribution(node);
+
 	return 0;
 }
 
+static void init_poe_enq_deq_spill(int node, uint64_t val, int len)
+{
+	uint64_t enq_val, deq_val;
+	uint32_t enq_low, enq_high, deq_low, deq_high, each_reg_len;
+	uint32_t enq_reg_high, enq_reg_low, enq_reg_len, deq_reg_low, deq_reg_high, deq_reg_len;
+	int i;
+
+	each_reg_len = len/16;
+	enq_val = val;
+	deq_val = val + each_reg_len;
+
+	enq_reg_low = POE_CL0_ENQ_SPILL_BASE_L;
+	enq_reg_high = POE_CL0_ENQ_SPILL_BASE_H;
+	enq_reg_len = POE_CL0_ENQ_SPILL_MAXLINE;
+
+	deq_reg_low = POE_CL0_DEQ_SPILL_BASE_L;
+	deq_reg_high = POE_CL0_DEQ_SPILL_BASE_H;
+	deq_reg_len = POE_CL0_DEQ_SPILL_MAXLINE;
+
+	for(i = 0 ;i < 8; i++) {
+		enq_low = (enq_val & 0xffffffff);
+		enq_high = ((enq_val >> 32) & 0xff);
+		deq_low = (deq_val & 0xffffffff);
+		deq_high = ((deq_val >> 32) & 0xff);
+
+		nlm_hal_write_poe_pcie_reg(node, enq_reg_low, enq_low);
+		nlm_hal_write_poe_pcie_reg(node, enq_reg_high, enq_high);	
+		nlm_hal_write_poe_pcie_reg(node, enq_reg_len, each_reg_len);
+
+		nlm_hal_write_poe_pcie_reg(node, deq_reg_low, enq_low);	
+		nlm_hal_write_poe_pcie_reg(node, deq_reg_high, enq_high);	
+		nlm_hal_write_poe_pcie_reg(node, deq_reg_len, each_reg_len);
+
+		enq_reg_low++;
+		enq_reg_high++;
+		deq_reg_low++;
+		deq_reg_high++;
+		enq_val += (2 * each_reg_len);
+		deq_val += (2 * each_reg_len);
+	}
+}
 /**
 * @brief init_poe_loc_msg_storage function is used to initailize the POE local message storage.
 *
@@ -1488,6 +1913,9 @@ static void parse_poe_config(void *fdt,int node)
 	uint32_t drop_timer = 0, dist_drop_enable = 0, class_drop_enable = 0, dest_threshold = POE_DIST_THRESHOLD_VAL;
 	uint32_t dist_threshold[4] = {POE_DIST_THRESHOLD_VAL , POE_DIST_THRESHOLD_VAL, 
 					POE_DIST_THRESHOLD_VAL , POE_DIST_THRESHOLD_VAL};
+	uint64_t  poe_address_map;
+	uint32_t *p_addr_map, *p_addr_len, poe_address_len;
+	int addr_map_len;
 
 	size = sizeof(uint32_t) * MAX_DV_TBL_ENTRIES;
 
@@ -1536,6 +1964,17 @@ static void parse_poe_config(void *fdt,int node)
                 else {
                         stats_en = 0;
                 }
+
+		p_addr_map = (uint32_t *)fdt_getprop(fdt, nodeoffset, "poe-spill-address", &addr_map_len);
+		p_addr_len = (uint32_t *)fdt_getprop(fdt, nodeoffset, "poe-spill-length", &plen);
+
+		if ((p_addr_map != NULL) && (p_addr_len != NULL)) {
+			poe_address_map = fdt64_to_cpu(*(uint32_t *)(p_addr_map));
+			poe_address_len = fdt64_to_cpu(*(uint32_t *)(p_addr_len));
+
+			if (poe_address_map > 0 && poe_address_len > 0)
+				init_poe_enq_deq_spill(node, poe_address_map, poe_address_len);
+		}
 	
 		nlm_print("distribution %d dest_threshold 0x%x drop_timer 0x%x\n", dist_en, dest_threshold, drop_timer);	
 		copy_fdt_prop(fdt, path_str, "mode", PROP_STR, mode_str, 20);
@@ -1642,21 +2081,18 @@ static void parse_poe_config(void *fdt,int node)
 static void parse_fdt_cpu_config(void *fdt, int dom_id, nlm_nae_config_ptr nae_cfg)
 {
 	char node_str[32];
+	sprintf(node_str, "/doms/dom@%d/cpu", dom_id);
 
-	 sprintf(node_str, "/doms/dom@%d/cpu", dom_id);
-
-	if (GET_CPU_PROP(node_str, "nae-rx-vc", &nae_cfg->rx_vc, sizeof(uint32_t)) < 0) {
+	if (GET_CPU_PROP(node_str, "nae-rx-vc", &(nae_cfg->rx_vc), sizeof(uint32_t)) < 0) {
 		nlm_print("Unable to parse nae_rx_vc, using defaults\n");
 		goto out;
 	}
 
-	if (GET_CPU_PROP(node_str, "nae-fb-vc", &nae_cfg->fb_vc, sizeof(uint32_t)) < 0) {
+	if (GET_CPU_PROP(node_str, "nae-fb-vc", &(nae_cfg->fb_vc), sizeof(uint32_t)) < 0) {
 		nlm_print("Unable to parse nae_rx_vc, using defaults\n");
 		goto out;
 	}
-
  out:
-
 	return;
 }
 
@@ -1674,7 +2110,7 @@ int rely_on_firmware_config = 0;
 #define GET_NAE_GLOBAL_PROP(path_str, prop, buf, len)					\
 	copy_fdt_prop(fdt, NAE_GLOBAL_NODE, prop, PROP_CELL, buf, len)
 
-#define NAE_MAX_PROP_LEN 30
+#define MAX_PROP_LEN 30
 
 /**
 * @brief config_egress_fifo_carvings function is used to carve the various egress FIFOs for the active contexts.
@@ -1895,6 +2331,9 @@ static uint32_t context_to_port_channel(int node, uint32_t context)
 	if (is_nlm_xlp3xx()) {
 		ctxt  = context - XLP_3XX_NET_TX_VC_BASE;
 	}
+	else if (is_nlm_xlp2xx()) {
+		ctxt  = context - XLP_2XX_NET_TX_VC_BASE;
+	}
 	else {
 		ctxt  = context - XLP_NET_TX_VC_BASE;
 	}
@@ -2047,7 +2486,6 @@ static int get_flow_mask(int num_ports)
         return max_bits;
 }
 
-
 /* Flow Config */
 static void nlm_config_flow_base(int node, nlm_nae_config_ptr nae_cfg)
 {
@@ -2056,13 +2494,7 @@ static void nlm_config_flow_base(int node, nlm_nae_config_ptr nae_cfg)
         uint32_t reg, cur_flow_base = 0, max_ports;
 	uint32_t per_port_num_flows = XLP_MAX_FLOWS / nae_cfg->num_ports;
 
-        if (is_nlm_xlp3xx()) {
-                max_ports = XLP_3XX_MAX_PORTS;
-        }
-        else {
-                max_ports = XLP_MAX_PORTS;
-        }
-
+	max_ports = nlm_get_max_ports();
 	for (port = 0, hw_port = 0 ; port < nae_cfg->num_ports; hw_port++) { 
             if (hw_port == nae_cfg->ports[port].hw_port_id) {
 		reg = (cur_flow_base << 16) | hw_port;
@@ -2080,13 +2512,7 @@ static void nlm_config_rx_calendar(int node, nlm_nae_config_ptr nae_cfg)
         int cal = 0, cal_len = 0, last_free = 0, port = 0;
         uint32_t val = 0, max_ports;
 
-        if (is_nlm_xlp3xx()) {
-                max_ports = XLP_3XX_MAX_PORTS;
-        }
-        else {
-                max_ports = XLP_MAX_PORTS;
-        }
-
+	max_ports = nlm_get_max_ports();
         cal_len = nae_cfg->rx_cal_slots - 1;
 
         NAE_DEBUG("Rx calendar length %d \n", cal_len);
@@ -2113,13 +2539,7 @@ static void nlm_config_tx_calendar(int node, nlm_nae_config_ptr nae_cfg)
         int cal = 0, cal_len = 0, last_free = 0, port = 0;
         uint32_t val = 0, max_ports;
 
-        if (is_nlm_xlp3xx()) {
-                max_ports = XLP_3XX_MAX_PORTS;
-        }
-        else {
-                max_ports = XLP_MAX_PORTS;
-        }
-
+	max_ports = nlm_get_max_ports();
 	cal_len = nae_cfg->tx_cal_slots - 1;
 	
 	nlm_hal_write_nae_reg(node, EGR_NIOR_CAL_LEN_REG, cal_len);
@@ -2181,7 +2601,7 @@ static void nlm_config_poe_class(int node)
                                            0xdb6db6, 0xffffff};
         int max_poe_tbl_sz;
 
-	if (is_nlm_xlp3xx()) {
+	if (is_nlm_xlp3xx() || is_nlm_xlp2xx()) {
         	max_poe_tbl_sz = XLP3XX_MAX_POE_CLASS_CTXT_TBL_SZ;
         }
         else {
@@ -2217,7 +2637,7 @@ static inline void nlm_write_interface_fifo(int node, int hw_port_id, uint32_t s
                                        ((start & 0xff) << 8) | hw_port_id);
         nlm_hal_write_nae_reg(node, IFACE_FIFO_CFG, val);
 
-	NAE_DEBUG("iface_start %d port %d size %d\n",start, hw_port_id, size);
+	NAE_DEBUG("iface fifo config port %d addr %d size %d\n",hw_port_id, start, size);
 	NAE_DEBUG("reg %x 0x%x\n",IFACE_FIFO_CFG, val);
 }
  
@@ -2239,7 +2659,30 @@ static inline void nlm_write_rxbase(int node, int hw_port_id, uint32_t base)
         }
 }
 
-static inline void nlm_configure_rxbuffer(int node, int context_base, int num_channels, uint32_t base, uint32_t size)
+static inline void config_context_xoff_thr(int node, int thgrp, int maxbuf)
+{
+	/* xon & xoff threshold is based on the number of entries used 
+	 send xon when rx_data_buffer_used <= xon threshold
+	 send xoff when rx_data_buffer_used >= xoff threshold */
+	int xoff = maxbuf / 2;
+	int xon = maxbuf / 4 ;
+	int val = (xoff << 3) | (xon << 17) | thgrp;
+	static int done[NLM_MAX_NODES][NLM_NAE_MAX_XONOFF_THR_GRPS];
+	if(thgrp >= NLM_NAE_MAX_XONOFF_THR_GRPS)
+		return;
+	if(done[node][thgrp])
+		return;
+	done[node][thgrp] = 1;
+	nlm_hal_write_nae_reg(node, RX_BUFFER_XONOFF_THR, thgrp);
+	nlm_hal_write_nae_reg(node, RX_BUFFER_XONOFF_THR, val);
+
+	nlm_hal_write_nae_reg(node, RX_BUFFER_XONOFF_THR, (1 << 31) | thgrp);
+	val = nlm_hal_read_nae_reg(node, RX_BUFFER_XONOFF_THR);
+	NAE_DEBUG("thgrp %d xoff %d xon %d maxbuf %d\n", 
+			thgrp, (val >> 3) & 0x3fff, (val >> 17) & 0x3fff, maxbuf);
+}
+
+static inline void nlm_configure_rxbuffer(int node, int context_base, int num_channels, uint32_t base, uint32_t size,int thrgrp)
 {
 	int offset;
 	volatile uint32_t val;
@@ -2247,9 +2690,12 @@ static inline void nlm_configure_rxbuffer(int node, int context_base, int num_ch
 	size /= num_channels;
 
 	for(offset = 0; offset < num_channels; offset++) {
-		nlm_hal_write_nae_reg(node, RX_BUFFER_BASE_DEPTH_ADDR_REG, context_base + offset);
+		nlm_hal_write_nae_reg(node, RX_BUFFER_BASE_DEPTH_ADDR_REG, (context_base + offset) | (thrgrp << 10));
                 NAE_DEBUG("context %d base %x size %d \n",context_base + offset, base, size);
          	NAE_DEBUG("reg %x 0x%x\n",RX_BUFFER_BASE_DEPTH_ADDR_REG, context_base + offset);       
+
+                NAE_DEBUG("rxbuffer context %d base %d size %d thrgrp %d\n",
+				context_base + offset, base, size, thrgrp);
 		val = 0x80000000 | ((base << 2) & 0x3fff); /* base */
                 val |= (((size << 2)  & 0x3fff) << 16); /* size */
                 nlm_hal_write_nae_reg(node, RX_BUFFER_BASE_DEPTH_REG, val);
@@ -2263,10 +2709,25 @@ static inline void nlm_configure_rxbuffer(int node, int context_base, int num_ch
 static inline void nlm_configure_parserfifo(int node, int hw_port_id, uint32_t start, uint32_t size)
 {
 	volatile uint32_t val;
+	uint32_t xon, xoff;
 
 	val = ((size & 0x1fff) << 17) | ((start & 0xfff) << 5) | (hw_port_id & 0x1f);
         nlm_hal_write_nae_reg(node, PARSER_SEQ_FIFO_CFG, val);
 	NAE_DEBUG("reg %x 0x%x\n",PARSER_SEQ_FIFO_CFG, val);
+
+	/*
+	   FIFO xoff threshold: high. When #entries used rises to this specified number.
+	   FIFO xon threshold: low.  When #entries used fall to this specified number.
+	   */
+	if (size != 0)
+	{
+		xoff = size/2;
+		xon = size/4;
+		val = (xoff<<12) | (xon);
+		nlm_hal_write_nae_reg(node, PARSER_SEQ_FIFOTH_CFG, val);
+
+		NAE_DEBUG("reg %x 0x%x\n",PARSER_SEQ_FIFOTH_CFG, val);
+	}
 }
 
 static void nlm_config_ingress_fifo(int node, nlm_nae_config_ptr nae_cfg)
@@ -2275,27 +2736,17 @@ static void nlm_config_ingress_fifo(int node, nlm_nae_config_ptr nae_cfg)
         int port, lane = 0, hw_port = 0, max_lanes, offset = 0;
 	int cur_iface_start = 0, max_ports;
 	uint32_t cur_parser_base = 0, context_base = 0, rx_buf_base = 0, size = 0;
+	int thrgrp, rx_buf_size;
 
-        if (is_nlm_xlp3xx()) {
-                max_ports = XLP_3XX_MAX_PORTS;
-        }
-        else {
-                max_ports = XLP_MAX_PORTS;
-        }
-
+	max_ports = nlm_get_max_ports();
         NAE_DEBUG("Interface FIFO carving max_ports:%d \n", max_ports);
         for (port = 0, hw_port = 0 ; hw_port < max_ports; ) { 
 	    if (hw_port == nae_cfg->ports[port].hw_port_id) {
 
-		NAE_DEBUG("cfg rxbuffer n:%d port:%d ctx_base:%d ch:%d rx_buf_base:%X buf_sz:%d\n",
-			node, hw_port, context_base, nae_cfg->ports[port].num_channels,
-                                        rx_buf_base, nae_cfg->ports[port].rx_buf_size);
-
-		nlm_configure_rxbuffer(node, context_base,nae_cfg->ports[port].num_channels,
-                                        rx_buf_base, nae_cfg->ports[port].rx_buf_size);  
-                rx_buf_base += nae_cfg->ports[port].rx_buf_size;
 
 		NAE_DEBUG("port:%d iftype:%d\n", port, nae_cfg->ports[port].iftype);
+		thrgrp = 0;
+		rx_buf_size = 0;
 		switch(nae_cfg->ports[port].iftype) {
 		   case RXAUI_IF:
 			fifo_xoff_thresh = 12;
@@ -2306,6 +2757,8 @@ static void nlm_config_ingress_fifo(int node, nlm_nae_config_ptr nae_cfg)
 			fifo_xoff_thresh = 12;
 			max_lanes = 4;
 			offset = 4;
+			thrgrp = 1;
+			rx_buf_size = nae_cfg->ports[port].rx_buf_size;
 			break;
 		   case SGMII_IF:
 			fifo_xoff_thresh = 6;
@@ -2324,6 +2777,20 @@ static void nlm_config_ingress_fifo(int node, nlm_nae_config_ptr nae_cfg)
 			break;
                 }
 
+		NAE_DEBUG("cfg rxbuffer n:%d port:%d ctx_base:%d ch:%d rx_buf_base:%X buf_sz:%d\n",
+			node, hw_port, context_base, nae_cfg->ports[port].num_channels,
+                                        rx_buf_base, nae_cfg->ports[port].rx_buf_size);
+
+		if(nae_cfg->ports[port].vlan_pri_en && rx_buf_size)
+			config_context_xoff_thr(node, thrgrp,  rx_buf_size / nae_cfg->ports[port].num_channels);
+		else
+			thrgrp = 0;
+
+		nlm_configure_rxbuffer(node, context_base,nae_cfg->ports[port].num_channels,
+                                        rx_buf_base, nae_cfg->ports[port].rx_buf_size, thrgrp);  
+                rx_buf_base += nae_cfg->ports[port].rx_buf_size;
+
+
 		for (lane = 0 ; lane < max_lanes; lane++) {
 			// carving interface fifo
 			NAE_DEBUG("carving intf fifo: lane:%d n:%d hw_port:%d\n", lane, node, hw_port);
@@ -2395,12 +2862,13 @@ static void nlm_config_nae_global(int node, nlm_nae_config_ptr nae_cfg)
 		return; /* if no interface ports, Uboot skip nae cfg */
 	else
 #endif
-		nlm_config_flow_base(node, nae_cfg);
 	nlm_hal_write_nae_reg(node, FLOW_CRC16_POLY_CFG, 0xFFFF);
 	nlm_config_ingress_fifo(node, nae_cfg);
 	nlm_config_rx_calendar(node, nae_cfg);
 	if (!is_nlm_xlp8xx_ax())
 		nlm_config_tx_calendar(node, nae_cfg);
+
+	nlm_config_flow_base(node, nae_cfg); // must be after one of the above functions.
 }
 
 /**
@@ -2418,21 +2886,25 @@ static void nlm_config_nae_global(int node, nlm_nae_config_ptr nae_cfg)
 static void set_nae_frequency(int node, int frequency)
 {
         const uint64_t mhz = 1000000;
-        /* Note that the DFS sets the NAE 2X frequency.
-         * To set the NAE frequency, multiply by 2
-         */
-        uint64_t set_freq, set_freq_d = nlm_hal_set_soc_freq(node, DFS_DEVICE_NAE_2X, frequency * 2 * mhz);
-
-#ifdef NLM_HAL_LINUX_KERNEL
-        do_div(set_freq_d, mhz);
-        set_freq = set_freq_d;
-        do_div(set_freq, 2);
-#else
-        set_freq_d /= mhz;
-        set_freq = set_freq_d / 2;
-#endif
-        nlm_print("NAE 2X Frequency set to %lluMHz (NAE frequency %llu MHz)\n", 
+        uint64_t set_freq, set_freq_d; 
+	if(is_nlm_xlp2xx()){
+		set_freq_d = nlm_hal_xlp2xx_set_clkdev_frq(node, XLP2XX_CLKDEVICE_NAE, frequency * mhz);
+		NLM_HAL_DO_DIV(set_freq_d, mhz);
+		nlm_print("NAE frequncy set to = %lluMhz", (unsigned long long)set_freq_d);
+		return;
+	}else{
+        	/* Note that the DFS sets the NAE 2X frequency.
+	         * To set the NAE frequency, multiply by 2
+        	 */
+		set_freq_d = nlm_hal_set_soc_freq(node, DFS_DEVICE_NAE_2X, frequency * 2 * mhz);
+		NLM_HAL_DO_DIV(set_freq_d, mhz);
+	        set_freq = set_freq_d;
+		NLM_HAL_DO_DIV(set_freq, 2);
+	        nlm_print("NAE 2X Frequency set to %lluMHz (NAE frequency %llu MHz)\n", 
 					(unsigned long long)set_freq_d, (unsigned long long)set_freq);
+	}
+	return;
+
 }
 
 static int nae_freein_fifo_cfg(void *fdt, int node, nlm_nae_config_ptr nae_cfg)
@@ -2529,9 +3001,6 @@ static int nae_freein_fifo_cfg(void *fdt, int node, nlm_nae_config_ptr nae_cfg)
 			/* Onchip configuraton is based on locations. 1 location can store 2 descs */
 			if(i < MAX_NAE_FREEIN_DESCS_QUEUE) {
 				size = nae_cfg->freein_fifo_onchip_num_descs[i] / 2;
-				/* take num free desc for the mgmt ports from the complex config only */
-				if(size == 0) 
-					size = 8;
 
 				reg = ((size  & 0x3ff ) << 20) | /* fcSize */
 					((start & 0x1ff)  << 8) | /* fcStart */
@@ -2573,7 +3042,7 @@ static int parse_vfbid_config(void *fdt, int node)
 	sprintf(vfbid_path, "/soc/nae@node-%d/vfbid-config",node);
 
 	if(GET_NAE_PROP(vfbid_path, "hw-replenish", &hw_replenish, sizeof(uint32_t)) < 0){
-                /*nlm_print("fdt missing hw-replenish\n");*/
+                //nlm_print("fdt missing hw-replenish\n");
 	}
 	else {
 		if (hw_replenish != 0)
@@ -2632,7 +3101,7 @@ static inline int valid_context_number(uint32_t context)
 {
 	int max_context;
 
-	if (is_nlm_xlp3xx())
+	if (is_nlm_xlp3xx() || is_nlm_xlp2xx())
 		max_context = XLP3XX_MAX_NAE_CONTEXTS;
 	else
 		max_context = MAX_NAE_CONTEXTS;
@@ -2649,7 +3118,7 @@ static int get_interface_type(void *fdt, char *nae_port_str, int block, int port
 	int intf_type, offset;
 	nlm_nae_config_ptr nae_cfg = nlm_node_cfg.nae_cfg[node];
 #ifndef NLM_HAL_UBOOT
-	char port_type_str[NAE_MAX_PROP_LEN];
+	char port_type_str[MAX_PROP_LEN];
 #endif
 
 #ifdef SKIP_INTERFACE_TYPE_FROMCPLD
@@ -2658,9 +3127,17 @@ static int get_interface_type(void *fdt, char *nae_port_str, int block, int port
 	intf_type = nlm_get_interface_type(node, block);
 #endif
 
+#ifdef CONFIG_N511
+	if (block == 4) {
+		intf_type = DC_SGMII;
+	}
+	else {
+		intf_type = DC_XAUI;
+	}
+#endif
 #ifndef NLM_HAL_UBOOT
 	if (intf_type == DC_NOT_PRSNT) {
-		if (GET_PORT_STR_PROP("mode", port_type_str, NAE_MAX_PROP_LEN) < 0) {
+		if (GET_PORT_STR_PROP("mode", port_type_str, MAX_PROP_LEN) < 0) {
 			nlm_print("FDT missing mode param for complex %d\n", block);
 			intf_type = UNKNOWN_IF;
 		}
@@ -2684,12 +3161,11 @@ static int get_interface_type(void *fdt, char *nae_port_str, int block, int port
         }
 	else if (intf_type == DC_XAUI) {
 		/* RXAUI & XAUI have the same intf_type value from the board CPLD */
-		if (GET_PORT_STR_PROP("mode", port_type_str, NAE_MAX_PROP_LEN) < 0) {
+		if (GET_PORT_STR_PROP("mode", port_type_str, MAX_PROP_LEN) < 0) {
 			nlm_print("FDT missing mode param for complex %d\n", block);
 			intf_type = UNKNOWN_IF;
 			return -1;
 		}
-		nlm_print("%s", port_type_str);
 		if (!strcmp(port_type_str, "rxaui")) {
 			intf_type = DC_RXAUI;
 		}
@@ -2704,8 +3180,14 @@ static int get_interface_type(void *fdt, char *nae_port_str, int block, int port
 			}
                         break;
 #ifndef NLM_HAL_UBOOT /* Uboot only support SGMII interface only for management port */
-        	case DC_ILK:
-			if ((is_nlm_xlp3xx()) || (node != 0)) { // FIXME interlaken supported only on node-0 nae
+        	case DC_ILK:// DC_HIGIG
+			if (is_nlm_xlp2xx()) {
+				nlm_print("Complex %d in XAUI_HIGIG mode\n", block);
+                        	nae_cfg->ports[port].iftype = XAUI_IF;
+                        	break;
+			}	
+			// FIXME interlaken supported only on node-0 nae
+			if ((is_nlm_xlp3xx()) || (node != 0)) {
 				nlm_print("Interlaken not supported \n");
 				return -1;
 			}
@@ -2745,8 +3227,11 @@ static void extract_complex_params(void *fdt, int intf_type, char *nae_port_str,
         GET_PORT_PROP("parser-sequence-fifo-size", &cmplx->prsr_seq_fifo_size, sizeof(cmplx->prsr_seq_fifo_size));
         GET_PORT_PROP("rx-buffer-size", &cmplx->rx_buf_size, sizeof(cmplx->rx_buf_size));
         GET_PORT_PROP("ucore-mask",&cmplx->ucore_mask, sizeof(cmplx->ucore_mask));
+	GET_PORT_PROP("higig-mode",&cmplx->higig_mode, sizeof(cmplx->higig_mode));
+	GET_PORT_PROP("xgmii-speed",&cmplx->xgmii_speed, sizeof(cmplx->xgmii_speed));
+	GET_PORT_PROP("msec-port-enable",&cmplx->msec_port_enable, sizeof(cmplx->msec_port_enable));
 	if (intf_type == SGMII_IF) {
-		if (is_nlm_xlp3xx()) {
+		if (is_nlm_xlp3xx() || is_nlm_xlp2xx()) {
 		     for (i = 0 ; i < 4; i++) {
 			if (cmplx->prsr_seq_fifo_size[i] > XLP3XX_SGMII_PARSERSEQ_FIFO_MAX)
 				cmplx->prsr_seq_fifo_size[i] = XLP3XX_SGMII_PARSERSEQ_FIFO_MAX;
@@ -2767,13 +3252,15 @@ static void extract_complex_params(void *fdt, int intf_type, char *nae_port_str,
 	}
 	GET_PORT_PROP("mgmt-port", &cmplx->mgmt, sizeof(cmplx->mgmt)); 
         GET_PORT_PROP("loopback", &cmplx->loopback, sizeof(cmplx->loopback));
+        GET_PORT_PROP("vlan-pri-en", &cmplx->vlan_pri_en, sizeof(cmplx->vlan_pri_en));
+	
 }
 
 uint32_t nlm_hal_get_frin_total_queue(int node)
 {
 	uint32_t frin_total_queue = 0;
 
-	if (is_nlm_xlp3xx()) {
+	if (is_nlm_xlp3xx() || is_nlm_xlp2xx()) {
 		frin_total_queue = XLP_3XX_NET_RX_VC_LIMIT - XLP_3XX_NET_RX_VC_BASE + 1;
 	}else{
 		frin_total_queue = XLP_NET_RX_VC_LIMIT - XLP_NET_RX_VC_BASE - 1; //skip gdx port
@@ -2784,7 +3271,7 @@ uint32_t nlm_hal_get_frin_total_queue(int node)
 uint32_t nlm_hal_get_frin_queue_base(int node)
 {
 	uint32_t frin_queue_base = 0;
-	if (is_nlm_xlp3xx()) {
+	if (is_nlm_xlp3xx() || is_nlm_xlp2xx()) {
 		frin_queue_base = (node <<10) | XLP_3XX_NET_RX_VC_BASE;
 	}else{
 		frin_queue_base = (node << 10) | XLP_NET_RX_VC_BASE;
@@ -2820,10 +3307,10 @@ void dump_nae_cfg_info(int node, nlm_nae_config_ptr nae_cfg)
 	}
 	nlm_print("\n");
 
-	nlm_print(" frfifo-dom-mask %x vfbid-shared(sw %d:%d hw %d:%d) daddr %llx\n",
+	nlm_print(" frfifo-dom-mask %x vfbid-shared(sw %d:%d hw %d:%d) \n",
 			nae_cfg->freein_fifo_dom_mask, nae_cfg->vfbtbl_sw_offset,
-			nae_cfg->vfbtbl_sw_nentries, nae_cfg->vfbtbl_hw_offset, nae_cfg->vfbtbl_hw_nentries, 
-			nae_cfg->dummy_pktdata_addr);
+			nae_cfg->vfbtbl_sw_nentries, nae_cfg->vfbtbl_hw_offset, nae_cfg->vfbtbl_hw_nentries 
+			);
 	nlm_print("\n");
 }
 
@@ -2836,8 +3323,10 @@ static int parse_port_config(void *fdt, int node, nlm_nae_config_ptr nae_cfg)
 	int offset, port, num_ports;
 	struct nlm_hal_nae_port *nae_port;
 	uint32_t txq, max_context = 0, tx_slots = 0, rx_slots = 0;
+	int submode = 0;
+	int rxaui_en = 0;
 
-	if (is_nlm_xlp3xx()) {
+	if (is_nlm_xlp3xx() || is_nlm_xlp2xx()) {
 		max_complex = XLP3XX_MAX_NAE_COMPLEX;
 		nae_cfg->frin_queue_base = (node <<10) | XLP_3XX_NET_RX_VC_BASE;
 		nae_cfg->frin_total_queue = XLP_3XX_NET_RX_VC_LIMIT - XLP_3XX_NET_RX_VC_BASE + 1;
@@ -2855,12 +3344,14 @@ static int parse_port_config(void *fdt, int node, nlm_nae_config_ptr nae_cfg)
 		if (is_nlm_xlp8xx_ax() && is_xlp_evp1() && (block % 2))
 			continue;
 #else
+#ifndef CONFIG_N511
 	if (is_nlm_xlp8xx()) {
 		if(block != 4) {
 			nlm_print("Uboot Skip complex:%d\n", block);
 			continue;
 		}
 	}
+#endif
 		nlm_print("Config complex:%d\n", block);
 #endif
 		sprintf(nae_port_str, "/soc/nae@node-%d/complex@%d",node, block);
@@ -2873,6 +3364,7 @@ static int parse_port_config(void *fdt, int node, nlm_nae_config_ptr nae_cfg)
 		intf_type = get_interface_type(fdt, nae_port_str, block, port, node);
                 nlm_print("Complex %d intf:%d\n", block, intf_type);
 #ifdef NLM_HAL_UBOOT
+
 		if (intf_type != SGMII_IF) {
 			nlm_print("Uboot Skip Complex %d intf:%d\n", block, intf_type);
 			continue;
@@ -2904,17 +3396,23 @@ static int parse_port_config(void *fdt, int node, nlm_nae_config_ptr nae_cfg)
                                 nlm_print("Complex %d RXAUI configuration missing in FDT \n", block);
                                 continue;
                         }
-			nae_cfg->rxaui_complex_map |= (1 << block);
-
-			GET_PORT_PROP("submode", &nae_cfg->ports[port].rxaui_mode,
-				sizeof(nae_cfg->ports[port].rxaui_mode));
-			GET_PORT_PROP("scrambler", &nae_cfg->ports[port].rxaui_scrambler,
+			GET_PORT_PROP("scrambler", &(nae_cfg->ports[port].rxaui_scrambler),
 				sizeof(nae_cfg->ports[port].rxaui_scrambler));
-			nlm_print("Complex%d: map:0x%X submode:%d scrambler:%d\n", block,
+			GET_PORT_PROP("submode", &submode, sizeof(submode));
+			nae_cfg->ports[port].rxaui_mode = submode;
+
+			rxaui_en = ((submode == NLM_NAE_RXAUI_MODE_MARVELL) ||
+				    (submode == NLM_NAE_RXAUI_MODE_BROADCOM)) ? 1 : 0;
+			if(rxaui_en)
+				nae_cfg->rxaui_complex_map |= (1 << block);
+			else
+				nae_cfg->xaui_complex_map  |= (1 << block);
+
+			nlm_print("Complex:%d: rmap:0x%X map:0x%X submode:%d scrambler:%d\n", block,
 				nae_cfg->rxaui_complex_map,
+				nae_cfg->xaui_complex_map,
 				nae_cfg->ports[port].rxaui_mode,
 				nae_cfg->ports[port].rxaui_scrambler);
-
 		}
 		else if (intf_type == INTERLAKEN_IF) {
 			sprintf(nae_port_str, "/soc/nae@node-%d/complex@%d/interlaken",node, block);
@@ -2926,16 +3424,28 @@ static int parse_port_config(void *fdt, int node, nlm_nae_config_ptr nae_cfg)
 			nae_cfg->ilk_complex_map |= (1 << block);
 		}
 		else {
-			nlm_print("Complex %d interface type is unknown\n", block);
+			nlm_print("Complex %d interface type is unknown \n", block);
 			continue;
 		}
 
 		num_ports = get_num_ports(block, intf_type);
 		extract_complex_params(fdt, intf_type, nae_port_str, &cmplx_cfg);
 
+		if(intf_type == XAUI_IF || intf_type == RXAUI_IF)
+		{
+			if(cmplx_cfg.msec_port_enable)
+				nae_cfg->msec_port_enable |=  0xf << (4 * block);
+		}
+		else
+			nae_cfg->msec_port_enable |= cmplx_cfg.msec_port_enable << (4 * block);
+#ifdef MACSEC_DEBUG
+		nlm_print(" nae_cfg->msec_port_enable = %x block = %d cmplx_cfg.msec_port_enable = %x\n", 
+		nae_cfg->msec_port_enable, block, cmplx_cfg.msec_port_enable);
+#endif
 		for(offset = 0; offset < num_ports; offset++, port++) {
 			nae_port = &nae_cfg->ports[port];
 			nae_port->hw_port_id = (block * MAX_PORTS_PERBLOCK) + offset;
+			nlm_print(" Printing off:%d hw_port:%d\n", offset, nae_port->hw_port_id);
 			nae_port->txq = txq;
 			nae_port->rxq = nae_cfg->frin_queue_base + nae_port->hw_port_id;
 			nae_port->num_free_desc = cmplx_cfg.num_free_desc[offset];
@@ -2947,7 +3457,12 @@ static int parse_port_config(void *fdt, int node, nlm_nae_config_ptr nae_cfg)
 			nae_port->ucore_mask = cmplx_cfg.ucore_mask[offset];
 			nae_port->ext_phy_addr = cmplx_cfg.ext_phy_addr[offset];
 			nae_port->ext_phy_bus = cmplx_cfg.ext_phy_bus[offset];
-			if (is_nlm_xlp3xx()) {
+			nae_port->loopback = cmplx_cfg.loopback[offset];
+			nae_port->higig_mode = cmplx_cfg.higig_mode;
+			nae_port->xgmii_speed = cmplx_cfg.xgmii_speed;
+			nae_port->vlan_pri_en = cmplx_cfg.vlan_pri_en;
+
+			if (is_nlm_xlp3xx() || is_nlm_xlp2xx()) {
 				nae_port->ucore_mask &= 0xFF;
 				nae_port->ext_phy_bus = 0;
 			}
@@ -2995,25 +3510,16 @@ static void parse_fdt_nae_config(void *fdt, int node, nlm_nae_config_ptr nae_cfg
 	int hw_port;
 	int num_ports = 0, port = 0;
 	uint32_t start_port, num_nae_regs, num_intf_regs;
-	char path_str[50];
 	uint32_t rx_config = 0, tx_config = 0;
 	int frequency, context = 0;
 
 	/* Parse Nae Config */
 	start_port = num_nae_regs = num_intf_regs = 0;
 
-	sprintf(path_str,"/soc/nae@node-%d",node);
-
-	if(GET_NAE_PROP(path_str, "frequency", &frequency, sizeof(uint32_t)) < 0)
-		nlm_print("fdt missing frequency\n");
-
-	if ((is_nlm_xlp3xx()) && (frequency > XLP3XX_MAX_NAE_FREQUENCY))
-		frequency = XLP3XX_MAX_NAE_FREQUENCY;
-
+	frequency = nlm_hal_get_fdt_freq(fdt, NLM_NAE);
 	if (!is_kexec_boot())
 		set_nae_frequency(node, frequency);
 
-
 	parse_vfbid_config(fdt, node);
 
 	num_ports = parse_port_config(fdt, node, nae_cfg);  
@@ -3033,22 +3539,26 @@ static void parse_fdt_nae_config(void *fdt, int node, nlm_nae_config_ptr nae_cfg
 	nlm_hal_mdio_init(node);
 
 	if (nae_cfg->sgmii_complex_map) {
-		NAE_DEBUG("node %d SGMII PCS init 0x%x\n", node, nae_cfg->sgmii_complex_map);
+		nlm_print("node %d SGMII PCS init 0x%x\n", node, nae_cfg->sgmii_complex_map);
 	       	nlm_hal_sgmii_pcs_init(node, nae_cfg->sgmii_complex_map);
 	}
 
 	if (nae_cfg->xaui_complex_map) {
-		NAE_DEBUG("node %d XAUI PCS init 0x%x\n", node, nae_cfg->xaui_complex_map);
-		nlm_hal_xaui_pcs_init(node, nae_cfg->xaui_complex_map, 0 /* rxaui_en */);
+		nlm_print("node %d XAUI PCS init 0x%x \n", node, nae_cfg->xaui_complex_map);
+		nlm_hal_xaui_pcs_init(node, nae_cfg);
 	}
 
 	if (nae_cfg->rxaui_complex_map) {
-		NAE_DEBUG("node %d XAUI PCS init 0x%x\n", node, nae_cfg->rxaui_complex_map);
-		nlm_hal_xaui_pcs_init(node, nae_cfg->rxaui_complex_map, 1 /* rxaui_en */);
+		nlm_print("node %d RXAUI PCS init 0x%x\n", node, nae_cfg->rxaui_complex_map);
+		nlm_hal_xaui_pcs_init(node, nae_cfg);
+		for(port = 0; port < num_ports; port++) {
+			if(nae_cfg->ports[port].rxaui_mode)
+				nlm_hal_rxaui_nlp1042c2_init(port, nae_cfg->ports[port].rxaui_mode);
+		}
 	}
 
 	if (nae_cfg->ilk_complex_map) {
-		NAE_DEBUG("node %d interlaken PCS init 0x%x\n", node, nae_cfg->ilk_complex_map);
+		nlm_print("node %d interlaken PCS init 0x%x\n", node, nae_cfg->ilk_complex_map);
 		nlm_hal_ilk_pcs_init(node, nae_cfg->ilk_complex_map);
 	}
 
@@ -3081,19 +3591,20 @@ static void parse_fdt_nae_config(void *fdt, int node, nlm_nae_config_ptr nae_cfg
 	{
 		hw_port = nae_cfg->ports[port].hw_port_id;
                 if (nae_cfg->ports[port].iftype == XAUI_IF) {
-			NAE_DEBUG("Cfg XAUI mode\n");
-			xlp_nae_config_xaui(node, (hw_port / 4), port,
-			nae_cfg->ports[port].vlan_pri_en,
-			nae_cfg->ports[port].rxaui_scrambler, NLM_NAE_XAUI_MODE_XAUI);
+			//NAE_DEBUG("Cfg XAUI mode with higig type = %d \n", nae_cfg->ports[port].higig_type);
+			nlm_print("Cfg XAUI mode for port %d with higig type = %d \n", port, nae_cfg->ports[port].higig_mode);
+                        xlp_nae_config_xaui(node, (hw_port / 4), port, nae_cfg->ports[port].vlan_pri_en,
+				nae_cfg->ports[port].rxaui_scrambler, NLM_NAE_XAUI_MODE_XAUI, nae_cfg->ports[port].higig_mode);
                 }
                 else if (nae_cfg->ports[port].iftype == RXAUI_IF) {
 			NAE_DEBUG("Cfg RXAUI mode:%d scrambler:%d\n",
 				nae_cfg->ports[port].rxaui_mode, nae_cfg->ports[port].rxaui_scrambler);
                         xlp_nae_config_xaui(node, (hw_port / 4), port, nae_cfg->ports[port].vlan_pri_en,
-				nae_cfg->ports[port].rxaui_scrambler, nae_cfg->ports[port].rxaui_mode);
-			nlm_hal_rxaui_nlp1042c2_init(port, nae_cfg->ports[port].rxaui_mode);
+				nae_cfg->ports[port].rxaui_scrambler, nae_cfg->ports[port].rxaui_mode,  nae_cfg->ports[port].higig_mode);
                 }
                 else if (nae_cfg->ports[port].iftype == INTERLAKEN_IF) {
+                    if(nae_cfg->ports[port].loopback)
+                        xlp_nae_ilk_loopback(node, (hw_port / 4), nae_cfg->num_lanes[hw_port / XLP_ILK_MAX_LANES]);
                         xlp_nae_config_interlaken(node, (hw_port / 4), port, nae_cfg->num_lanes[hw_port / XLP_ILK_MAX_LANES]);
                 }
 
@@ -3106,9 +3617,9 @@ static void parse_fdt_nae_config(void *fdt, int node, nlm_nae_config_ptr nae_cfg
                         if ((nlm_hal_init_cs34x7(hw_port, nae_cfg->num_lanes[hw_port / XLP_ILK_MAX_LANES],
 			 nae_cfg->lane_rate[hw_port / XLP_ILK_MAX_LANES]) == 0) && 
 				(is_xlp_ilk_lanealigned(node, hw_port/4)))
-				NAE_DEBUG("Interlaken lanes on port %d are aligned\n", hw_port);
+				nlm_print("Interlaken lanes on port %d are aligned\n", hw_port);
 			else
-				NAE_DEBUG("Interlaken initialization on port %d failed\n", hw_port);
+				nlm_print("Interlaken initialization on port %d failed\n", hw_port);
                 }
 #endif
 		context += nae_cfg->ports[port].num_channels;
@@ -3123,7 +3634,7 @@ static void parse_fdt_nae_config(void *fdt, int node, nlm_nae_config_ptr nae_cfg
 			} 
 		}
 
-		nlm_print("Initialized port@%d\n", port);
+		NAE_DEBUG("Initialized port@%d\n", port);
 	}
 }
 
@@ -3140,17 +3651,11 @@ static void parse_fdt_nae_config(void *fdt, int node, nlm_nae_config_ptr nae_cfg
 */
 static void drain_nae_frin_fifo_descs(int node)
 {
-        uint32_t value = 0, fifo_mask;
+        uint32_t value, fifo_mask;
 	int timeout = 10;
 
-        if (is_nlm_xlp3xx()) {
-                fifo_mask = XLP_3XX_MAX_PORTS;
-        }
-        else {
-                fifo_mask = XLP_MAX_PORTS;
-        }
+	fifo_mask = nlm_get_max_ports();
 	fifo_mask = ((1 << fifo_mask)-1);
-
 	nlm_hal_write_nae_reg(node, RX_FREE_FIFO_POP, fifo_mask);
 	for (; timeout >= 0; timeout--) {
 		nlm_mdelay(1);
@@ -3206,18 +3711,12 @@ int nlm_hal_nae_drain_frin_fifo_descs(int node, int inf)
 static int debug = 1;
 static void print_frin_desc_carving(int node)
 {
-	int intf, max;
+	int intf, max_ports;
 
 	if (!debug) return;
 
-	if (is_nlm_xlp3xx()) {
-		max = XLP_3XX_MAX_PORTS;
-	}
-	else {
-		max = XLP_MAX_PORTS;
-	}
-		
-	for (intf = 0; intf < max; intf++) {
+	max_ports = nlm_get_max_ports();
+	for (intf = 0; intf < max_ports; intf++) {
 		uint32_t value = 0;
 		int start = 0, size = 0;
 
@@ -3245,19 +3744,13 @@ static void print_frin_desc_carving(int node)
 */
 static void deflate_frin_fifo_carving(int node)
 {
-	int intf = 0, max;
+	int intf = 0, max_ports;
 	const int minimum_size = 8; /* this represents entries, each entry holds 2 descriptors */
 	int start = 0;
 	uint32_t value = 0;
 
-        if (is_nlm_xlp3xx()) {
-                max = XLP_3XX_MAX_PORTS;
-        }
-        else {
-                max = XLP_MAX_PORTS;
-        }
-
-	for (intf = 0; intf < max; intf++) {
+	max_ports = nlm_get_max_ports();
+	for (intf = 0; intf < max_ports; intf++) {
 		start = minimum_size * intf;
 		value = (minimum_size << 20) | (start << 8) | (intf);
 		nlm_hal_write_nae_reg(node, FREE_IN_FIFO_CFG, value);
@@ -3328,6 +3821,117 @@ void drain_nae_stray_packets(int node)
 	nlm_mdelay(1);
 }
 
+/* 1588 timer related APIs */
+uint64_t  nlm_hal_1588_ptp_get_counter(int node, int counter)
+{
+	int reg_hi = PTP_TMR1_HI + ((counter-1)<<1);
+	int reg_lo = PTP_TMR1_LO +  ((counter-1)<<1);
+	return (((uint64_t)nlm_hal_read_nae_reg(node, reg_hi) <<32) |nlm_hal_read_nae_reg(node,reg_lo));
+
+}
+void nlm_hal_1588_ptp_set_counter(int node, int counter, uint64_t cnt_val)
+{
+	int reg_hi = PTP_TMR1_HI + ((counter-1)<<1);
+	int reg_lo = PTP_TMR1_LO +  ((counter-1)<<1);
+	nlm_hal_write_nae_reg(node, reg_hi, cnt_val>>32);
+	nlm_hal_write_nae_reg(node, reg_lo, cnt_val & 0xffffffff);
+}
+
+int  nlm_hal_is_intr_1588(int node)
+{
+	uint32_t val;
+	int ptp_intr = (1<<6|1<<7|1<<8);
+	val = nlm_hal_read_nae_reg(node, NET_COMMON0_INTR_STS);
+	if(val & ptp_intr){
+		return (val & ptp_intr);
+	}
+	return 0;
+}
+
+uint32_t nlm_hal_get_int_sts(int node)
+{
+	return nlm_hal_read_nae_reg(node, PTP_STATUS);
+}
+
+void nlm_hal_clear_1588_intr(int node, int timer)
+{
+	uint32_t val;
+	val = nlm_hal_read_nae_reg(node, 0x7b3);
+	nlm_hal_write_nae_reg(node, 0x7b3, val|(1<<(timer+19)));	
+	val = nlm_hal_read_nae_reg(node, NET_COMMON0_INTR_STS);
+	nlm_hal_write_nae_reg(node, NET_COMMON0_INTR_STS, val|(1<<(timer+5)));
+}
+
+void nlm_hal_enable_1588_intr(int node, int timer)
+{
+	uint32_t val;
+	val = nlm_hal_read_nae_reg(node, 0x7b4);
+	nlm_hal_write_nae_reg(node, 0x7b4, val|(1<<(timer+19)) );
+	val = nlm_hal_read_nae_reg(node, PTP_CONTROL);	
+	nlm_hal_write_nae_reg(node, PTP_CONTROL, val|(1<<(timer+2)));
+} 
+
+void nlm_hal_1588_ptp_clk_sel(int node, int clk_type)
+{
+	uint32_t val;
+	val = nlm_hal_read_nae_reg(node, PTP_CONTROL);
+	nlm_hal_write_nae_reg(node, PTP_CONTROL, val|(clk_type<<8));	
+}
+
+void nlm_hal_1588_ld_user_val(int node, uint32_t user_val_hi,  uint32_t user_val_lo)
+{
+	uint32_t val;
+	nlm_hal_write_nae_reg(node, PTP_USER_VALUE_HI, user_val_hi);
+	nlm_hal_write_nae_reg(node, PTP_USER_VALUE_LO, user_val_lo);
+	val = nlm_hal_read_nae_reg(node, PTP_CONTROL);	
+	nlm_hal_write_nae_reg(node, PTP_CONTROL, val|(1<<6)); 
+}
+
+void nlm_hal_1588_ld_offs(int node, uint32_t ptp_off_hi,  uint32_t ptp_off_lo)
+{
+	uint32_t val;
+	nlm_hal_write_nae_reg(node, PTP_OFFSET_HI, ptp_off_hi);
+	nlm_hal_write_nae_reg(node, PTP_OFFSET_LO, ptp_off_lo);
+	val = nlm_hal_read_nae_reg(node, PTP_CONTROL);	
+	nlm_hal_write_nae_reg(node, PTP_CONTROL, val|(1<<2)); 
+}
+
+void nlm_hal_1588_ld_freq_mul(int node, uint32_t ptp_inc_den, uint32_t ptp_inc_num, 
+					uint32_t ptp_inc_intg)
+{
+	uint32_t val;
+	nlm_hal_write_nae_reg(node, PTP_INC_DEN, ptp_inc_den);
+	nlm_hal_write_nae_reg(node, PTP_INC_NUM, ptp_inc_num);
+	nlm_hal_write_nae_reg(node, PTP_INC_INTG, ptp_inc_intg);
+	val = nlm_hal_read_nae_reg(node, PTP_CONTROL);	
+	nlm_hal_write_nae_reg(node, PTP_CONTROL, val|(1<<1)); 
+}
+
+void nlm_hal_reset_1588_accum(int node)
+{
+	uint32_t val;
+	val = nlm_hal_read_nae_reg(node, PTP_CONTROL);	
+	nlm_hal_write_nae_reg(node, PTP_CONTROL, val|0x1); 
+}
+
+void nlm_hal_prepad_enable(int node, int size)
+{
+	uint32_t val;
+	val = nlm_hal_read_nae_reg(node, RX_CONFIG);
+	val |= (1 << 13); /* prepad enable */
+	val |= ((size & 0x3) << 22); /* prepad size */
+	nlm_hal_write_nae_reg(node, RX_CONFIG, val);
+}
+
+uint32_t nlm_hal_get_rtc(int node, uint32_t* p_val_hi,  uint32_t* p_val_lo)
+{
+	uint32_t cmd = nlm_hal_read_nae_reg(node, IOSYS_RTC_CMD);
+	*p_val_hi = nlm_hal_read_nae_reg(node, IOSYS_RTC_RDATA_HI);
+	*p_val_lo = nlm_hal_read_nae_reg(node, IOSYS_RTC_RDATA_HI);
+	//nlm_print("RTC:%X %X.%X\n", cmd, *p_val_hi, *p_val_lo);
+	return cmd;
+}
+
 /**
 * @brief reset_nae function resets the NAE.
 *
@@ -3345,7 +3949,7 @@ static void reset_nae(int node)
 	int reset_bit = 9;  
 	/* Reset NAE */
 
-	if (is_nlm_xlp3xx())
+	if (is_nlm_xlp3xx() || is_nlm_xlp2xx())
 		reset_bit = 6;
 	else
 		reset_bit = 9;
@@ -3376,7 +3980,7 @@ static void reset_poe(int node)
 {
 	int reset_bit = 10;
 
-	if (is_nlm_xlp3xx())
+	if (is_nlm_xlp3xx() || is_nlm_xlp2xx())
 		reset_bit = 7;
 	else
 		reset_bit = 10;
@@ -3399,7 +4003,7 @@ static uint32_t membar_fixup(uint32_t l)
 	unsigned char b;
 	uint32_t fixup;
 
-	if (is_nlm_xlp8xx_bx() || !is_nlm_xlp8xx_ax())
+	if (!is_nlm_xlp8xx_ax())
 		return l;
 
 	b = (l >> 24) & 0xff;
@@ -3460,143 +4064,42 @@ void  reset_nae_mgmt(int node)
  *                   XAUI Support
  *
  */
-/**
-* @brief nlm_hal_xgmac_mdio_addr writes the external PHY register index for a following indirect read/write.
-*
-* @param [in] node Node number
-* @param [in] bus External MDIO bus number
-* @param [in] phyaddr External PHY's address
-* @param [in] dev_addr dev address
-* @param [in] regidx PHY register index to read
-*
-* @return
-* 	- 0 on success
-*
-* @ingroup hal_nae
-*
-*/
-static int nlm_hal_xgmac_mdio_addr(int node, int bus,
-        int phyaddr, int dev_addr, int regidx)
-{
-	uint32_t block     = BLOCK_7;
-	uint32_t intf_type = LANE_CFG;
-        int32_t i;
-
-        /* load  XGMC_MDIO_CTRL_DATA register with addr */
-        nlm_hal_write_mac_reg( node, block , intf_type,
-                                EXT_XG0_MDIO_CTRL_DATA + (bus * 4), regidx);
-
-        nlm_hal_write_mac_reg( node, block, intf_type, EXT_XG0_MDIO_CTRL+ bus * 4,
-                                 phyaddr << EXT_XG_MDIO_CTRL_PHYADDR_POS
-                                | dev_addr << EXT_XG_MDIO_CTRL_REG_POS
-				| nae_get_EXT_XG_MDIO_DIV()
-                                | EXT_XG_MDIO_CTRL_CMD_LOAD
-                                | MDIO_MIIM_CMD_10G_MMD << EXT_XG_MDIO_CTRL_MIIM_POS
-                                | EXT_XG_MDIO_CTRL_TA << EXT_XG_MDIO_CTRL_TA_POS
-                                | MDIO_CTRL_OP_INDIRECT_ADDR << EXT_XG_MDIO_CTRL_OP_POS
-                                | EXT_XG_MDIO_CTRL_ST);
-
-
-        /* poll master busy bit until it is not busy */
-        WAIT_XGMAC_MDIO_BSY_CLEAR(node)
-
-        nlm_hal_write_mac_reg( node, block, intf_type, EXT_XG0_MDIO_CTRL + (bus * 4),
-                                 phyaddr << EXT_XG_MDIO_CTRL_PHYADDR_POS
-                                | dev_addr << EXT_XG_MDIO_CTRL_REG_POS
-				| nae_get_EXT_XG_MDIO_DIV()
-                                | MDIO_MIIM_CMD_IDLE << EXT_XG_MDIO_CTRL_MIIM_POS
-                                | 0x0 << EXT_XG_MDIO_CTRL_TA_POS
-                                | MDIO_CTRL_OP_INDIRECT_ADDR << EXT_XG_MDIO_CTRL_OP_POS
-                                | EXT_XG_MDIO_CTRL_ST);
-
-
-        /* poll master busy bit until it is not busy */
-        WAIT_XGMAC_MDIO_BSY_CLEAR(node)
-        return 0;
-}
-
 int nlm_hal_xgmac_mdio_write(int node, int bus,
 	int phyaddr, int dev_addr, int regidx, uint16_t val)
 {
 	uint32_t block     = BLOCK_7;
 	uint32_t intf_type = LANE_CFG;
         int32_t  i;
-
-         /* first is indirect address cycle */
-        nlm_hal_xgmac_mdio_addr(node, bus, phyaddr, dev_addr, regidx);
-
-        nlm_hal_write_mac_reg( node, block, intf_type,
-                                EXT_XG0_MDIO_CTRL_DATA + (bus * 4), val);
-
-        nlm_hal_write_mac_reg( node, block, intf_type, EXT_XG0_MDIO_CTRL+ bus * 4,
-                                 phyaddr << EXT_XG_MDIO_CTRL_PHYADDR_POS
-                                | dev_addr << EXT_XG_MDIO_CTRL_REG_POS
-				| nae_get_EXT_XG_MDIO_DIV()
-                                | EXT_XG_MDIO_CTRL_CMD_LOAD
-                                | MDIO_MIIM_CMD_10G_MMD << EXT_XG_MDIO_CTRL_MIIM_POS
-                                | EXT_XG_MDIO_CTRL_TA << EXT_XG_MDIO_CTRL_TA_POS
-                                | MDIO_CTRL_OP_WRITE_10G_MMD << EXT_XG_MDIO_CTRL_OP_POS
-                                | EXT_XG_MDIO_CTRL_ST);
-
-        /* poll master busy bit until it is not busy */
+	uint32_t ctrl =   (phyaddr << EXT_XG_MDIO_CTRL_PHYADDR_POS)
+			| (dev_addr << EXT_XG_MDIO_CTRL_REG_POS)
+			| (regidx << EXT_XG_MDIO_CTRL_OP_POS)
+			/* load = 0 */
+			| nae_get_EXT_XG_MDIO_DIV()
+			| (EXT_XG_MDIO_CTRL_TA << EXT_XG_MDIO_CTRL_TA_POS)
+			| (MDIO_MIIM_CMD_10G_MMD << EXT_XG_MDIO_CTRL_MIIM_POS);
+
+	//nlm_print("xw: bus:%d phy:%d d:%d %x.%x=%x\n", bus, phyaddr, dev_addr, ctrl, regidx, val);
+        nlm_hal_write_mac_reg( node, block, intf_type, EXT_XG0_MDIO_CTRL_DATA + (bus * 4), val);
+
+        nlm_hal_write_mac_reg( node, block, intf_type, EXT_XG0_MDIO_CTRL+ bus * 4, ctrl);
         WAIT_XGMAC_MDIO_BSY_CLEAR(node)
 
-        nlm_hal_write_mac_reg( node, block, intf_type, EXT_XG0_MDIO_CTRL + (bus * 4),
-                                 phyaddr << EXT_XG_MDIO_CTRL_PHYADDR_POS
-                                | dev_addr << EXT_XG_MDIO_CTRL_REG_POS
-				| nae_get_EXT_XG_MDIO_DIV()
-                                | MDIO_MIIM_CMD_IDLE << EXT_XG_MDIO_CTRL_MIIM_POS
-                                | 0x0 << EXT_XG_MDIO_CTRL_TA_POS
-                                | 0 << EXT_XG_MDIO_CTRL_OP_POS
-                                | EXT_XG_MDIO_CTRL_ST);
-
+        nlm_hal_write_mac_reg( node, block, intf_type, EXT_XG0_MDIO_CTRL+ bus * 4, ctrl|EXT_XG_MDIO_CTRL_CMD_LOAD);
+        WAIT_XGMAC_MDIO_BSY_CLEAR(node)
 
-        /* poll master busy bit until it is not busy */
+        nlm_hal_write_mac_reg( node, block, intf_type, EXT_XG0_MDIO_CTRL+ bus * 4, ctrl);
         WAIT_XGMAC_MDIO_BSY_CLEAR(node)
+
         return 0;
 }
 
 int nlm_hal_xgmac_mdio_read(int node, int bus, int phyaddr, int dev_addr, int regidx)
 {
-	uint32_t block     = BLOCK_7;
-	uint32_t intf_type = LANE_CFG;
-        int32_t  i;
-        int rdval;
-
-         /* first is indirect address cycle */
-        nlm_hal_xgmac_mdio_addr( node, bus, phyaddr, dev_addr, regidx);
-
-        nlm_hal_write_mac_reg( node, block, intf_type, EXT_XG0_MDIO_CTRL + (bus * 4),
-                                 phyaddr << EXT_XG_MDIO_CTRL_PHYADDR_POS
-                                | dev_addr << EXT_XG_MDIO_CTRL_REG_POS
-				| nae_get_EXT_XG_MDIO_DIV()
-                                | EXT_XG_MDIO_CTRL_CMD_LOAD
-                                | MDIO_MIIM_CMD_10G_MMD << EXT_XG_MDIO_CTRL_MIIM_POS
-                                | EXT_XG_MDIO_CTRL_TA << EXT_XG_MDIO_CTRL_TA_POS
-                                | MDIO_CTRL_OP_READ_10G_MMD << EXT_XG_MDIO_CTRL_OP_POS
-                                | EXT_XG_MDIO_CTRL_ST);
-
-        /* poll master busy bit until it is not busy */
-        WAIT_XGMAC_MDIO_BSY_CLEAR(node)
-
-        rdval =  nlm_hal_read_mac_reg(node, block, intf_type, EXT_XG0_MDIO_RD_STAT +
-                (bus * 4)) & 0xFFFF;
-
-        nlm_hal_write_mac_reg( node, block, intf_type, EXT_XG0_MDIO_CTRL + (bus * 4),
-                                 phyaddr << EXT_XG_MDIO_CTRL_PHYADDR_POS
-                                | dev_addr << EXT_XG_MDIO_CTRL_REG_POS
-				| nae_get_EXT_XG_MDIO_DIV()
-                                | MDIO_MIIM_CMD_IDLE << EXT_XG_MDIO_CTRL_MIIM_POS
-                                | 0x0 << EXT_XG_MDIO_CTRL_TA_POS
-                                | 0 << EXT_XG_MDIO_CTRL_OP_POS
-                                | EXT_XG_MDIO_CTRL_ST);
-
-
-        /* poll master busy bit until it is not busy */
-        WAIT_XGMAC_MDIO_BSY_CLEAR(node)
-
-        return rdval; /*SSONG: Check Me: read sequence changed */
-
+	int rdval;
+	nlm_hal_xgmac_mdio_write(node, bus, phyaddr, dev_addr, MDIO_CTRL_OP_INDIRECT_ADDR, regidx);
+	nlm_hal_xgmac_mdio_write(node, bus, phyaddr, dev_addr, MDIO_CTRL_OP_READ_10G_MMD, regidx);
+        rdval =  nlm_hal_read_mac_reg(node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_RD_STAT + (bus * 4)) & 0xFFFF;
+        return rdval;
 }
 
 int nlm_hal_c45_mdio_indirect_write_external(int node, int bus,
@@ -3604,26 +4107,16 @@ int nlm_hal_c45_mdio_indirect_write_external(int node, int bus,
 {
 	write_data &= 0xFFFF;
 	nlm_hal_xgmac_mdio_write(node, bus, phyaddr, dev_addr, MDIO_CTRL_OP_INDIRECT_ADDR, reg_addr);
-
 	nlm_hal_xgmac_mdio_write(node, bus, phyaddr, dev_addr, MDIO_CTRL_OP_WRITE_10G_MMD, write_data);
-
-	nlm_print("C45 MDIO w phy:%d dev:%d reg[%04X]=[%04X]\n", phyaddr, dev_addr, reg_addr, write_data);
+	//nlm_print("C45 MDIO w phy:%d dev:%d reg[%04X]=[%04X]\n", phyaddr, dev_addr, reg_addr, write_data);
 	return 0;
 }
 
 int nlm_hal_c45_mdio_indirect_read_external (int node, int bus,
 	int phyaddr, int dev_addr, uint32_t reg_addr)
 {
-	int rdval;
-
-	nlm_hal_xgmac_mdio_write(node, bus, phyaddr, dev_addr, MDIO_CTRL_OP_INDIRECT_ADDR, reg_addr);
-
-	nlm_hal_xgmac_mdio_write(node, bus, phyaddr, dev_addr, MDIO_CTRL_OP_POST_RDINC_ADDR, 0);
-
-        rdval =  nlm_hal_read_mac_reg(node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_RD_STAT + (bus * 4)) & 0xFFFF;
-
-	nlm_print("C45 MDIO r phy:%d dev:%d reg[%04X]=[%04X]\n", phyaddr, dev_addr, reg_addr, rdval);
-
+	int rdval = nlm_hal_xgmac_mdio_read(node, bus, phyaddr, dev_addr, reg_addr);
+	//nlm_print("C45 MDIO r phy:%d dev:%d reg[%04X]=[%04X]\n", phyaddr, dev_addr, reg_addr, rdval);
 	return rdval;
 }
 
@@ -3766,16 +4259,18 @@ void nlm_xaui_phy_write(int phyaddr, int devaddr, int regidx, uint16_t val)
   int bus = 0;
   if ((phyaddr >= 0x13) && (phyaddr <= 0x16)) {
     nlm_hal_xgmac_imdio_write(0, phyaddr, regidx, val);
+    return;
   } else if (phyaddr > 1) {
     bus = 1;
   }
-  nlm_hal_xgmac_mdio_write(0, bus, phyaddr, devaddr, regidx, val);
+  nlm_hal_c45_mdio_indirect_write_external(0, bus, phyaddr, devaddr, regidx, val);
+  return;
 }
 
 uint16_t nlm_xaui_phy_read(int phyaddr, int devaddr, int regidx)
 {
   int bus = 0;
-  uint16_t val;
+  uint16_t val = 0;
 
   if ((phyaddr >= 0x13) && (phyaddr <= 0x16)) {
     val = nlm_hal_xgmac_imdio_read(0, phyaddr, regidx);
@@ -3784,8 +4279,7 @@ uint16_t nlm_xaui_phy_read(int phyaddr, int devaddr, int regidx)
   } else if (phyaddr > 1) {
     bus = 1;
   }
-  val = nlm_hal_xgmac_mdio_read(0, bus, phyaddr, devaddr, regidx);
-
+  val = nlm_hal_c45_mdio_indirect_read_external (0, bus, phyaddr, devaddr, regidx);
   return val;
 }
 
@@ -3814,29 +4308,30 @@ void nlm_xaui_phy_scan(void)
 
 #define CONFIG_RXAUI 1
 #ifdef  CONFIG_RXAUI
-#define NLM_C45_PRINTF nlm_print
+#define NLM_C45_PRINTF(n) while(0) {nlm_print(n);} 
 
 void nlm_hal_rxaui_nlp1042c2_rxaui_broadcom_init(int port)
 {
 	int i;
-	uint32_t data;
 	if(port==0) {
+		nlm_print("Broadcom RXAUI P0\n");
 		#include "NLP1042C2_RXAUI_Dune.h"
 	}
 	else {
+		nlm_print("Broadcom RXAUI P1\n");
 		#include "NLP1042C2_RXAUI_Dune_4.h"
 	}
-	data = NLM_C45_READ(0,0,0,1,0xc241);
-	nlm_print("RXAUI c45 rd 0xc241:%x \n", data);
 }
 
 void nlm_hal_rxaui_nlp1042c2_rxaui_marvell_init(int port)
 {
 	int i;
 	if(port==0) {
+		nlm_print("Marvell RXAUI P0\n");
 		#include "NLP1042C2_RXAUI_Marvell.h"
 	}
 	else {
+		nlm_print("Marvell RXAUI P1\n");
 		#include "NLP1042C2_RXAUI_Marvell_4.h"
 	}
 }
@@ -3845,22 +4340,45 @@ void nlm_hal_rxaui_nlp1042c2_xaui_init(int port)
 {
 	int i;
 	if(port==0) {
+		nlm_print("NLP1042C2 XAUI P0\n");
 		#include "NLP1042C2_XAUI.h"
 	}
 	else {
+		nlm_print("NLP1042C2 XAUI P1\n");
 		#include "NLP1042C2_XAUI_4.h"
 	}
 }
 
 void nlm_hal_rxaui_nlp1042c2_init(int port, int rxaui_mode)
 {
+	uint32_t data;
+	int phyaddr = port*4;
 	nlm_print("NLP port:%d mode:%d\n", port, rxaui_mode);
+
+	data = NLM_C45_READ(0,0,phyaddr,1,0xc205);
+	nlm_print("NLP1042C2 p:%d 0xc205:%x \n", port, data);
+
 	if(rxaui_mode == NLM_NAE_RXAUI_MODE_MARVELL)
 		nlm_hal_rxaui_nlp1042c2_rxaui_marvell_init(port);
 	else if(rxaui_mode == NLM_NAE_RXAUI_MODE_BROADCOM)
 		nlm_hal_rxaui_nlp1042c2_rxaui_broadcom_init(port);
 	else
 		nlm_hal_rxaui_nlp1042c2_xaui_init(port);
+
+	data = NLM_C45_READ(0,0,phyaddr,1,0xc241);
+	nlm_print("NLP1042C2 p:%d 0xc241:%x \n", port, data);
+
+	data = NLM_C45_READ(0,0,phyaddr,1,0xc243);
+	nlm_print("NLP1042C2 p:%d 0xc243:%x \n", port, data);
+
+	data = NLM_C45_READ(0,0,phyaddr,1,0xc246);
+	nlm_print("NLP1042C2 p:%d 0xc246:%x \n", port, data);
+
+	data = NLM_C45_READ(0,0,phyaddr,1,0xc20d);
+	nlm_print("NLP1042C2 p:%d 0xc20d:%x \n", port, data);
+
+	data = NLM_C45_READ(0,0,phyaddr,1,0xc2c3);
+	nlm_print("NLP1042C2 p:%d 0xc2c3:%x \n", port, data);
 }
 
 #endif
@@ -3882,12 +4400,16 @@ void nlm_hal_rxaui_nlp1042c2_init(int port, int rxaui_mode)
 * @ingroup hal_nae
 *
 */
-void nlm_hal_xaui_pcs_init(int node, int xaui_cplx_mask, int rxaui_en)
+void nlm_hal_xaui_pcs_init(int node, nlm_nae_config_ptr nae_cfg)
 {
-	int block, lane_ctrl, lane_status;
+	/*TODO: include vsemi programming here for HIGIG */
+	int block, lane_ctrl, lane_status, vsemi_config=0;
 	int cplx_lane_enable = LM_XAUI | (LM_XAUI << 4) | (LM_XAUI << 8) | (LM_XAUI << 12);
 	int lane_enable = 0;
-	int phy_mode = (rxaui_en) ?  PHYMODE_RXAUI : PHYMODE_XAUI;
+	int phy_mode = (nae_cfg->rxaui_complex_map) ?  PHYMODE_RXAUI : PHYMODE_XAUI;
+	static int vsemi_por=0;
+	int xaui_cplx_mask = nae_cfg->xaui_complex_map;
+	
 
 	if (xaui_cplx_mask == 0) {
 		return;
@@ -3908,6 +4430,7 @@ void nlm_hal_xaui_pcs_init(int node, int xaui_cplx_mask, int rxaui_en)
 			lane_enable |= (cplx_lane_enable << 16);
 		}
 		nlm_hal_write_mac_reg(node, block, LANE_CFG, LANE_CFG_CPLX_0_1,   lane_enable);
+		nlm_mdelay(1);
 	}
 	lane_enable = 0;
 	if (xaui_cplx_mask & 0xc) { /* Complexes 2, 3 */
@@ -3921,6 +4444,7 @@ void nlm_hal_xaui_pcs_init(int node, int xaui_cplx_mask, int rxaui_en)
 			lane_enable |= (cplx_lane_enable << 16);
 		}
 		nlm_hal_write_mac_reg(node, block, LANE_CFG, LANE_CFG_CPLX_2_3,   lane_enable);
+		nlm_mdelay(1);
 	}
 
 
@@ -3929,7 +4453,77 @@ void nlm_hal_xaui_pcs_init(int node, int xaui_cplx_mask, int rxaui_en)
 	{
 		if ((xaui_cplx_mask & (1 << block)) == 0) {
 			continue;
+		}		
+		
+		if(is_nlm_xlp2xx()){
+			int delay;
+			struct nlm_hal_nae_port *portcfg = &nae_cfg->ports[block];
+			int xaui_speed = portcfg->xgmii_speed;
+			if(xaui_speed==16){
+				nlm_print("VSEMI: config data for 16G XAUI \n");
+				nlm_hal_config_vsemi_mem_16G_4page_125();
+				nlm_hal_config_vsemi_mem_16G_125();
+			}	
+			else if(xaui_speed==12){
+				nlm_print("VSEMI: config data for 12G XAUI \n");
+				nlm_hal_config_vsemi_mem_12G_4page_125();
+				nlm_hal_config_vsemi_mem_12G_125();
+			}	
+			else {
+				nlm_print("VSEMI: config data for 10G XAUI \n");
+				nlm_hal_config_vsemi_mem_xaui_4page_125();
+				nlm_hal_config_vsemi_mem_xaui_125();	
+			}
+			
+			
+			if(!vsemi_por){			
+				vsemi_config = nlm_hal_read_mac_reg(node, block+1, PHY, VSEMI_CTL0);
+				vsemi_config &= ~VSEMI_CTL_POR;
+				nlm_hal_write_mac_reg(node, block+1, PHY, VSEMI_CTL0, vsemi_config);
+				vsemi_por++;
+			}
+			
+			vsemi_config = nlm_hal_read_mac_reg(node, block, PHY, VSEMI_CTL0);
+			vsemi_config &= 0xFFFF01FF;
+			vsemi_config |= VSEMI_CTL_POR | VSEMI_CTL_SYNTH_RST | VSEMI_CTL_RTHR;
+			nlm_hal_write_mac_reg(node, block, PHY, VSEMI_CTL0, vsemi_config);
+    			
+			for(delay=0; delay<1000000; delay++);
+			
+			vsemi_config = nlm_hal_read_mac_reg(node, block, PHY, VSEMI_CTL0);
+			vsemi_config &= ~VSEMI_CTL_POR;
+			vsemi_config &= 0xFFFFFE00;
+			nlm_hal_write_mac_reg(node, block, PHY, VSEMI_CTL0, vsemi_config);
+
+			
+			vsemi_config = nlm_hal_read_mac_reg(node, block, PHY, VSEMI_CTL1);
+			vsemi_config &= ~((0x7<<4) | 0x7);
+
+			if(xaui_speed==16)
+				 vsemi_config = VSEMI_CTL_XAUI_16G_DR | VSEMI_CTL_XAUI_16G_DW;
+			else if(xaui_speed==12)
+				 vsemi_config = VSEMI_CTL_XAUI_12G_DR | VSEMI_CTL_XAUI_12G_DW;
+			else //XAUII/10G
+				 vsemi_config = VSEMI_CTL_XAUI_DR | VSEMI_CTL_XAUI_DW;
+			
+			for(delay=0; delay<1000000; delay++);
+			nlm_hal_write_mac_reg(node, block, PHY, VSEMI_CTL1, vsemi_config);
+				
+			if(xaui_speed){
+				nlm_hal_xlp2xx_nae_program_vsemi(node, block, xaui_speed, 0);
+			}else{
+				/*Only XAUII*/
+				nlm_hal_xlp2xx_nae_program_vsemi(node, block, 0, PHYMODE_XAUI);
+			}
+#ifdef VSEMI_DEBUG
+			display_vsemi_indirect_reg(node, block);
+#endif
+			vsemi_config = nlm_hal_read_mac_reg(node, block, PHY, VSEMI_CTL0);
+			vsemi_config &= ~(VSEMI_CTL_POR | VSEMI_CTL_SYNTH_RST | VSEMI_CTL_RTHR);
+			nlm_hal_write_mac_reg(node, block, PHY, VSEMI_CTL0, vsemi_config);
+			
 		}
+
 		for( lane_ctrl = PHY_LANE_0_CTRL; lane_ctrl <= PHY_LANE_3_CTRL; lane_ctrl++) {
 
 			if(phy_mode == PHYMODE_RXAUI && (lane_ctrl%2))
@@ -3937,14 +4531,17 @@ void nlm_hal_xaui_pcs_init(int node, int xaui_cplx_mask, int rxaui_en)
 
 			if((is_nlm_xlp3xx()) || (is_nlm_xlp8xx_bx())){
 				xlp3xx_8xxb0_nae_lane_reset_txpll(node, block, lane_ctrl, phy_mode);
-			}
-			else{
+				nlm_hal_PMFF_ALL_workaround(node, block, lane_ctrl);
+			}else if(is_nlm_xlp2xx()){
+				xlp2xx_nae_lane_reset_txpll(node, block, lane_ctrl, phy_mode);
+			}else{
 				xlp8xx_ax_nae_lane_reset_txpll(node, block, lane_ctrl, phy_mode);
 			}
 		}
 	}
 	NAE_DEBUG("%s all blocks & lanes out of TXPLL\n", __func__);
 
+	nlm_mdelay(10);
 	/* Wait for Rx & TX clock stable */
 	for( block = 0; block < 4; block++)
 	{
@@ -3952,27 +4549,27 @@ void nlm_hal_xaui_pcs_init(int node, int xaui_cplx_mask, int rxaui_en)
 			continue;
 		}
 
+
 		for( lane_status = PHY_LANE_0_STATUS; lane_status <= PHY_LANE_3_STATUS; lane_status++) {
 
 			if(phy_mode == PHYMODE_RXAUI && (lane_status%2))
 				continue;
 
 			/* Wait for TX clock to be set */
+			nlm_print("Blk:%d lane%d wait TX clock stable\n", block, lane_status);
 			while ((nlm_hal_read_mac_reg(node, block, PHY, lane_status) & (PHY_LANE_STAT_STCS)) != PHY_LANE_STAT_STCS) {
 			}
-			NAE_DEBUG("%s Blk%d lane%d got TX clock stable\n", __func__, block, lane_status);
 
 			/* Wait for RX clock to be set */
+			nlm_print("Blk:%d lane%d wait RX clock stable\n", block, lane_status);
 			while ((nlm_hal_read_mac_reg(node, block, PHY, lane_status) & (PHY_LANE_STAT_SRCS)) != PHY_LANE_STAT_SRCS) {
 			}
-			NAE_DEBUG("%s Blk%d lane%d got RX clock stable\n", __func__, block, lane_status);
 
+			nlm_print("Blk:%d lane%d wait lane fault cleared\n", block, lane_status);
 			while ((nlm_hal_read_mac_reg(node, block, PHY, lane_status) & (PHY_LANE_STAT_XLF)) != 0) {
 				/* Wait for XAUI Lane fault to be cleared */
 			}
-			NAE_DEBUG("%s Blk%d lane%d got lane fault cleared\n", __func__, block, lane_status);
 		}
-
 	}
 
 #ifdef CONFIG_N511
@@ -3997,11 +4594,30 @@ void nlm_hal_xaui_pcs_init(int node, int xaui_cplx_mask, int rxaui_en)
 *
 */
 static void xlp_nae_config_xaui(int node, int block, int port, int vlan_pri_en,
-				int rxaui_scrambler, int mode)
+				int rxaui_scrambler, int mode, int higig_type)
 {
 	uint32_t val = 0;
 	int rxaui_en = ((mode == NLM_NAE_RXAUI_MODE_MARVELL) ||
                         (mode == NLM_NAE_RXAUI_MODE_BROADCOM)) ? 1 : 0;
+
+	if(higig_type){
+		/*enable higig */
+		uint32_t higig_cfg = 0;
+		higig_cfg = (1<<0) | (1<<1) | (1<<4) | (1<<6) | (1<<3) | (1<<7)| (1<<12); 
+		if(higig_type==HIGIG2){
+			higig_cfg |= (1<<10);
+		}
+		nlm_hal_write_mac_reg(node, block, XGMAC, NETIOR_HIGIG2_CTRL0, higig_cfg);  
+		
+		higig_cfg =  nlm_hal_read_mac_reg(node, block, XGMAC, NETIOR_HIGIG2_CTRL1);
+		higig_cfg |= (0x20) | (0x80<<8) | (0x10<<16) | (0x20<<24); //RX/TX threshold
+		nlm_hal_write_mac_reg(node, block, XGMAC, NETIOR_HIGIG2_CTRL1, higig_cfg);  
+
+		higig_cfg =  nlm_hal_read_mac_reg(node, block, XGMAC, NETIOR_HIGIG2_CTRL2);
+		higig_cfg |= (0x3fff<<16);  /*set frame len*/
+		nlm_hal_write_mac_reg(node, block, XGMAC, NETIOR_HIGIG2_CTRL2, higig_cfg);
+	}
+
 	val = 	nlm_hal_read_mac_reg(node, block, XGMAC, XGMAC_CTL_REG1);
 	val &= ~(0x1 << 11); /* Reset xgmac soft reset(bit 11) xaui soft reset (bit 12) */
 	nlm_hal_write_mac_reg(node, block, XGMAC, XGMAC_CTL_REG1, val);
@@ -4024,7 +4640,6 @@ static void xlp_nae_config_xaui(int node, int block, int port, int vlan_pri_en,
 
 	/* set stats counter*/
 	val = nlm_hal_read_mac_reg(node, block, XGMAC, NETIOR_XGMAC_CTRL1);
-	val |= 1 << NETIOR_XGMAC_VLAN_DC_POS;
 	val |= 1 << NETIOR_XGMAC_STATS_EN_POS;
 
 	if (rxaui_en)
@@ -4049,9 +4664,12 @@ static void xlp_nae_config_xaui(int node, int block, int port, int vlan_pri_en,
 		val |= 1 << NETIOR_XGMAC_TX_PFC_EN_POS; 
 		val |= 1 << NETIOR_XGMAC_RX_PFC_EN_POS; 
 		val |= 1 << NETIOR_XGMAC_TX_PAUSE_POS; 
+		val |= 1 << NETIOR_XGMAC_VLAN_DC_POS;
 	} else {
 		val &= ~(1 << NETIOR_XGMAC_TX_PFC_EN_POS); 
+		val &= ~(1<<NETIOR_XGMAC_RX_PFC_EN_POS);
 		val |= (1 << NETIOR_XGMAC_TX_PAUSE_POS); 
+		val &= ~(1 << NETIOR_XGMAC_VLAN_DC_POS);
 	}
 	nlm_hal_write_mac_reg(node, block, XGMAC, NETIOR_XGMAC_CTRL1, val);
 
@@ -4166,6 +4784,17 @@ static void nlm_hal_write_pma_reg(int node, int block, int lane_ctrl, uint8_t se
 	while((nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl)) & PHY_LANE_CTRL_CMD_PENDING);
 }
 
+static inline void nlm_hal_PMFF_ALL_workaround(int node, int block, int lane_ctrl)
+{
+	volatile int val = 0;
+
+	if (is_nlm_xlp3xx_ax() || is_nlm_xlp3xx_b0()) {
+		val = nlm_hal_read_pma_reg(node, block, lane_ctrl, SER_GEN1_PWR_DOWN);
+		val = val | SERDES_PMFF_ALL_SET;
+		nlm_hal_write_pma_reg(node, block, lane_ctrl, SER_GEN1_PWR_DOWN, val);
+	}
+}
+
 static void nlm_hal_set_PLL(int node, int block, int lane_ctrl, uint32_t F_val, uint32_t N_val, uint32_t M_val)
 {
         uint32_t data;
@@ -4331,6 +4960,52 @@ static void xlp_debug_interlaken(int node, int blk)
 	nlm_hal_write_mac_reg(node, blk, INTERLAKEN, ILK_GENERAL_CTRL3, debug);
 }
 #endif
+/**
+* @brief xlp_nae_ilk_loopback. Enables serdes loopback
+*
+* @param [in] node Node number
+* @param [in] block NAE Register Memory Map Block
+* @param [in] num_lanes Number of INTERLAKEN lanes enabled
+*
+* @return
+*       - none
+*/
+static void xlp_nae_ilk_loopback(int node, int blk, int num_lanes)
+{
+	int lane, lnsperblk;
+	volatile uint8_t prbsctrl = 0;
+	int i = 0;
+
+	if (!((blk == 0) || (blk == 2)))
+		return;
+
+	lnsperblk = (num_lanes > MAX_LANE_PER_CPLX) ?
+			MAX_LANE_PER_CPLX : num_lanes;
+	NAE_DEBUG("\n%s: Enabling interlaken serdes loopback ",__func__);
+	NAE_DEBUG("\n Loopback: Node:%d Block:%d",node,blk);
+
+	do {
+		for (lane = 0; lane < lnsperblk; lane++) {
+			prbsctrl = nlm_hal_read_pma_reg(node,blk + i, lane + 4,
+					SERDES_PRBS_CTRL);
+			prbsctrl |= SERDES_LOOPBACK_EN;
+			nlm_hal_write_pma_reg(node,blk + i, lane + 4,
+				SERDES_PRBS_CTRL, prbsctrl);
+			NAE_DEBUG(" Lane %d", lane);
+		}
+		lnsperblk = num_lanes - lnsperblk;
+		if (!lnsperblk)
+			break;
+		i++;
+	} while (i < 2);
+
+	nlm_hal_write_mac_reg(node, blk, INTERLAKEN, ILK_RX_STATUS1,
+		0xFFFFFFFF);
+	nlm_hal_write_mac_reg(node, blk, INTERLAKEN, ILK_RX_STATUS2,
+		0xFFFFFFFF);
+	nlm_hal_write_mac_reg(node, blk, INTERLAKEN, ILK_RX_STATUS3,
+		0x0004FFFF);
+}
 
 /**
 * @brief xlp_nae_config_interlaken initializes an INTERLAKEN port at the MAC level.
@@ -4352,27 +5027,6 @@ static void xlp_nae_config_interlaken(int node, int blk,int port, int num_lanes)
         volatile uint32_t txctrl = 0, genctrl = 0;
         volatile uint32_t val = 0;
 
-#ifdef ILK_SERDES_LOOP
-        int lane, lnsperblk = (num_lanes > MAX_LANE_PER_CPLX) ? MAX_LANE_PER_CPLX : num_lanes;
-        volatile uint8_t prbsctrl = 0;
-
-        // Enable loopback here if configured
-        do {
-                for(lane = 0; lane < lnsperblk; lane++) {
-                        prbsctrl = nlm_hal_read_pma_reg(blk+i, lane, SERDES_PRBS_CTRL);
-                        prbsctrl |= SERDES_LOOPBACK_EN;
-                        nlm_hal_write_pma_reg(blk+i, lane, SERDES_PRBS_CTRL, prbsctrl);
-                }
-                lnsperblk = num_lanes - lnsperblk;
-                if (!lnsperblk)
-                        break;
-                i++;
-        }while(i<2);
-
-        nlm_hal_write_mac_reg(node, blk, INTERLAKEN, ILK_RX_STATUS1, 0xFFFFFFFF);
-        nlm_hal_write_mac_reg(node, blk, INTERLAKEN, ILK_RX_STATUS2, 0xFFFFFFFF);
-        nlm_hal_write_mac_reg(node, blk, INTERLAKEN, ILK_RX_STATUS3, 0x0004FFFF);
-#endif
         if (!((blk == 0) || (blk == 2)))
                 return;
 
@@ -4544,18 +5198,18 @@ uint16_t nlm_hal_get_hwport(int node, uint32_t context)
 }
 
 
-int nlm_hal_init_if(int node, int type, int  inf, uint32_t *regs, int num_regs)
+int nlm_hal_init_if(int node, int intf_type, int  block, uint32_t *regs, int num_regs)
 {
 	int i;
 	if (regs == NULL) {
 		return -1;
 	}
-	if (type == INTERLAKEN_IF) {
+	if (intf_type == INTERLAKEN_IF) {
 		return -1;
 	}
 	/* Initialize the regs */
 	for (i = 0; i < num_regs; ++i) {
-		/*		nlm_hal_write_nae_reg(inf, regs[2*i], regs[2*i + 1]); */
+		/*		nlm_hal_write_nae_reg(block, regs[2*i], regs[2*i + 1]); */
 	}
 	return 0;
 }
@@ -4575,7 +5229,7 @@ int nlm_hal_init_if(int node, int type, int  inf, uint32_t *regs, int num_regs)
 static int init_netior(int node, int type)
 {
 	nlm_hal_write_nae_iface_reg(node, 0xf, NETIOR_SOFTRESET, 0);
-	if (is_nlm_xlp3xx()) {
+	if (is_nlm_xlp3xx() || is_nlm_xlp2xx()) {
 		nlm_hal_write_nae_iface_reg(node, 0xf, NETIOR_MISC_REG3_ADDR , 0x0 );
                 nlm_hal_write_nae_iface_reg(node, 0xf, NETIOR_MISC_REG2_ADDR , 0x0707 );
                 nlm_hal_write_nae_iface_reg(node, 0xf, NETIOR_MISC_REG1_ADDR , 0x00ff );
@@ -4671,7 +5325,7 @@ static void init_egress(int node)
 {
 	uint32_t tx_cfg =  nlm_hal_read_nae_reg(node, TX_CONFIG);
 
-	if ((is_nlm_xlp3xx()) || (is_nlm_xlp8xx_bx())) {
+	if ((is_nlm_xlp3xx()) || is_nlm_xlp2xx() || (is_nlm_xlp8xx_bx())) {
 		nlm_hal_write_nae_reg(node, TX_CONFIG, tx_cfg | NAE_TX_ENABLE | NAE_TX_ACE  | NAE_TX_COMPATIBLE | (1 << 3));
 	}
 	else {
@@ -4684,8 +5338,8 @@ static void init_egress(int node)
 * @brief nlm_hal_open_if function onfigures the internal PCS and MAC for an interface.
 *
 * @param [in] node Node number
-* @param [in] type Interface type (SGMII, XAUI, Interlaken..)
-* @param [in] inf Interface number
+* @param [in] intf_type Interface type (SGMII, XAUI, Interlaken..)
+* @param [in] block (Interface number)
 *
 * @return
 * 	- 0 on success
@@ -4693,7 +5347,7 @@ static void init_egress(int node)
 * @ingroup hal_nae
 *
 */
-int nlm_hal_open_if(int node, int type, int inf)
+int nlm_hal_open_if(int node, int intf_type, int block)
 {
 	unsigned int netwk_inf  = 0;
 	unsigned int tx_config = 0;
@@ -4706,19 +5360,19 @@ int nlm_hal_open_if(int node, int type, int inf)
 	int hw_portid ;
 #endif
 
-	NAE_DEBUG("%s: %d node %d ",__func__,inf, node);
+	NAE_DEBUG("%s: %d node %d ",__func__,block, node);
 	// Init Netior ... Need to fixed
-	init_netior(node, type);
+	init_netior(node, intf_type);
 
-	NAE_DEBUG("type:%d\n", type);
-	switch(type) {
+	NAE_DEBUG("intf_type:%d\n", intf_type);
+	switch(intf_type) {
 		case XAUI_IF:
 		case RXAUI_IF:
-			// inf is a complex number
-			netwk_inf = nlm_hal_read_mac_reg(node, inf, XGMAC, NETIOR_XGMAC_CTRL1);
+			// block is a complex number
+			netwk_inf = nlm_hal_read_mac_reg(node, block, XGMAC, NETIOR_XGMAC_CTRL1);
 			netwk_inf |= (1 << NETIOR_XGMAC_STATS_CLR_POS);
-			nlm_hal_write_mac_reg(node, inf, XGMAC, NETIOR_XGMAC_CTRL1, netwk_inf);
-			ifmask = 0xf << (inf);
+			nlm_hal_write_mac_reg(node, block, XGMAC, NETIOR_XGMAC_CTRL1, netwk_inf);
+			ifmask = 0xf << (block);
 			tx_ior_credit = nlm_hal_read_nae_reg(node, TX_IORCRDT_INIT);
 			nlm_hal_write_nae_reg(node, TX_IORCRDT_INIT, tx_ior_credit | ifmask);
 		        tx_config = nlm_hal_read_nae_reg(node, TX_CONFIG);
@@ -4727,8 +5381,8 @@ int nlm_hal_open_if(int node, int type, int inf)
 		        nlm_hal_write_nae_reg(node, TX_CONFIG, tx_config & ~( TXINITIORCR(ifmask)));
 			break;
 		case INTERLAKEN_IF:
-			// inf is a complex number
-			ifmask = 0xff << (inf);   //based on number of lanes
+			// block is a complex number
+			ifmask = 0xff << (block);   //based on number of lanes
 			tx_ior_credit = nlm_hal_read_nae_reg(node, TX_IORCRDT_INIT);
 			nlm_hal_write_nae_reg(node, TX_IORCRDT_INIT, tx_ior_credit | (ifmask));
                         tx_config = nlm_hal_read_nae_reg(node, TX_CONFIG);
@@ -4738,53 +5392,53 @@ int nlm_hal_open_if(int node, int type, int inf)
 			break;
 		case SGMII_IF:
 			tx_ior_credit = nlm_hal_read_nae_reg(node, TX_IORCRDT_INIT);
-			nlm_hal_write_nae_reg(node, TX_IORCRDT_INIT, tx_ior_credit & (~ (1<<inf)));
+			nlm_hal_write_nae_reg(node, TX_IORCRDT_INIT, tx_ior_credit & (~ (1<<block)));
 			tx_config = nlm_hal_read_nae_reg(node, TX_CONFIG);
 			// need to toggle these bits for credits to be loaded
-			nlm_hal_write_nae_reg(node, TX_CONFIG, tx_config | ( TXINITIORCR(1<<inf)));
-			nlm_hal_write_nae_reg(node, TX_CONFIG, tx_config & (~( TXINITIORCR(1<<inf))));
+			nlm_hal_write_nae_reg(node, TX_CONFIG, tx_config | ( TXINITIORCR(1<<block)));
+			nlm_hal_write_nae_reg(node, TX_CONFIG, tx_config & (~( TXINITIORCR(1<<block))));
 	
 			/* init phy id to access internal PCS */
-		        netwk_inf = read_gmac_reg(node, inf, NETWK_INF_CTRL_REG);
+		        netwk_inf = read_gmac_reg(node, block, NETWK_INF_CTRL_REG);
         		netwk_inf &= 0x7ffffff;
-		        netwk_inf |= ((inf) << 27);
-        		write_gmac_reg(node, inf, NETWK_INF_CTRL_REG, netwk_inf);
+		        netwk_inf |= ((block) << 27);
+        		write_gmac_reg(node, block, NETWK_INF_CTRL_REG, netwk_inf);
 
 			/* Sofreset set bit 11 to 0  */
 
-			write_gmac_reg(node, inf , NETWK_INF_CTRL_REG,  netwk_inf & 0xfffff7ff);
+			write_gmac_reg(node, block , NETWK_INF_CTRL_REG,  netwk_inf & 0xfffff7ff);
 
 			// Reset GMAC 
-			mac_cfg1 = read_gmac_reg(node, inf, MAC_CONF1);
-		        write_gmac_reg(node, inf , MAC_CONF1, mac_cfg1 | INF_SOFTRESET(1) |
+			mac_cfg1 = read_gmac_reg(node, block, MAC_CONF1);
+		        write_gmac_reg(node, block , MAC_CONF1, mac_cfg1 | INF_SOFTRESET(1) |
 					           INF_RX_ENABLE(1) |
 						   INF_TX_ENABLE(1));
 
 			// Default 1G
-		        write_gmac_reg(node, inf , MAC_CONF2,  INF_PREMBL_LEN(0x7) |
+		        write_gmac_reg(node, block , MAC_CONF2,  INF_PREMBL_LEN(0x7) |
                         		     	INF_IFMODE(2)  |
                 	               		INF_FULLDUP(1) |
 		  			        INF_PADCRCEN(1));
 
 			// Clear GMAC reset
-			mac_cfg1 = read_gmac_reg(node, inf, MAC_CONF1);
-		        write_gmac_reg(node, inf , MAC_CONF1, mac_cfg1 & ~(INF_SOFTRESET(1)));
+			mac_cfg1 = read_gmac_reg(node, block, MAC_CONF1);
+		        write_gmac_reg(node, block , MAC_CONF1, mac_cfg1 & ~(INF_SOFTRESET(1)));
 
 			// Clear speed debug bit
-		        netior_ctrl3 = read_gmac_reg(node, inf, NETWK_INF_CTRL3_REG);
-		        write_gmac_reg(node, inf, NETWK_INF_CTRL3_REG, netior_ctrl3 & (~(1<<6)));
-			//nlm_print("CLEARING speed bit =0x%x\n", read_gmac_reg(node, inf, NETWK_INF_CTRL3_REG));
+		        netior_ctrl3 = read_gmac_reg(node, block, NETWK_INF_CTRL3_REG);
+		        write_gmac_reg(node, block, NETWK_INF_CTRL3_REG, netior_ctrl3 & (~(1<<6)));
+			//nlm_print("CLEARING speed bit =0x%x\n", read_gmac_reg(node, block, NETWK_INF_CTRL3_REG));
 
 #if !defined(XLP_SIM) || defined(NLM_BOARD)
-			register_phy(node, inf, &hw_portid);
+			register_phy(node, block, &hw_portid);
 			if(hw_portid<0)	
 				goto init_inf;
 			// init external phy, bypass SGMII auto negotiation
-			NAE_DEBUG("init ext phy:%d\n", inf);
-			nlm_hal_init_ext_phy(node, inf);
+			NAE_DEBUG("init ext phy:%d\n", block);
+			nlm_hal_init_ext_phy(node, block);
 #endif
 			// Configure speed and mode
-			nlm_hal_config_sgmii_if(node, inf);
+			nlm_hal_config_sgmii_if(node, block);
 			break;
 		default:
 			nlm_print("Unknown interface type\n");	
@@ -4800,9 +5454,9 @@ init_inf:
 	return 0;
 }
 
-int nlm_hal_close_if(int node, int type, int  inf)
+int nlm_hal_close_if(int node, int intf_type, int  block)
 {
-	if (type != SGMII_IF) {
+	if (intf_type != SGMII_IF) {
 		return -1;
 	}
 	/* Turn off TX, RX enables */
@@ -4814,8 +5468,8 @@ int nlm_hal_close_if(int node, int type, int  inf)
 * @brief nlm_hal_mac_disable function is used to disable an interface at the MAC level.
 *
 * @param [in] node Node number
-* @param [in] inf Interface number
-* @param [in] type SGMII_IF, XAUI_IF, INTERLAKEN_IF
+* @param [in] block (Interface number)
+* @param [in] intf_type SGMII_IF, XAUI_IF, INTERLAKEN_IF
 *
 * @return
 * 	- none
@@ -4823,22 +5477,22 @@ int nlm_hal_close_if(int node, int type, int  inf)
 * @ingroup hal_nae
 *
 */
-void nlm_hal_mac_disable(int node, int inf, int type)
+void nlm_hal_mac_disable(int node, int block, int intf_type)
 {
         unsigned int mac_cfg1 = 0, xaui_cfg = 0;
         unsigned int netwk_inf = 0;
 
-	switch(type) {
+	switch(intf_type) {
 		case SGMII_IF:
-			mac_cfg1 = read_gmac_reg(node, inf, MAC_CONF1);
-		        write_gmac_reg(node, inf , MAC_CONF1, mac_cfg1 & ~(0x5));
-              		netwk_inf = read_gmac_reg(node, inf, NETWK_INF_CTRL_REG);
-              		write_gmac_reg(node, inf ,NETWK_INF_CTRL_REG, netwk_inf &  (~(TX_EN(1))));
+			mac_cfg1 = read_gmac_reg(node, block, MAC_CONF1);
+		        write_gmac_reg(node, block , MAC_CONF1, mac_cfg1 & ~(0x5));
+              		netwk_inf = read_gmac_reg(node, block, NETWK_INF_CTRL_REG);
+              		write_gmac_reg(node, block ,NETWK_INF_CTRL_REG, netwk_inf &  (~(TX_EN(1))));
 			break;
 		case XAUI_IF:
 		case RXAUI_IF:
-			xaui_cfg=nlm_hal_read_mac_reg(node, inf, XGMAC, XAUI_CONFIG_1);
-			nlm_hal_write_mac_reg(node, inf, XGMAC, XAUI_CONFIG_1, xaui_cfg &
+			xaui_cfg=nlm_hal_read_mac_reg(node, block, XGMAC, XAUI_CONFIG_1);
+			nlm_hal_write_mac_reg(node, block, XGMAC, XAUI_CONFIG_1, xaui_cfg &
                                                         (~(XAUI_CONFIG_TFEN | XAUI_CONFIG_RFEN)));
 			break;
 		case INTERLAKEN_IF:
@@ -4849,8 +5503,8 @@ void nlm_hal_mac_disable(int node, int inf, int type)
 /**
 * @brief nlm_hal_mac_enable function is used to enable an interface at the MAC level.
 *
-* @param [in] inf Interface number
-* @param [in] type SGMII_IF, XAUI_IF, INTERLAKEN_IF
+* @param [in] block (Interface number)
+* @param [in] intf_type SGMII_IF, XAUI_IF, INTERLAKEN_IF
 *
 * @return
 * 	- none
@@ -4858,23 +5512,23 @@ void nlm_hal_mac_disable(int node, int inf, int type)
 * @ingroup hal_nae
 *
 */
-void nlm_hal_mac_enable(int node, int inf, int type)
+void nlm_hal_mac_enable(int node, int block, int intf_type)
 {
         unsigned int mac_cfg1 = 0, xaui_cfg = 0;
         unsigned int netwk_inf = 0;
 
-        switch(type) {
+        switch(intf_type) {
                 case SGMII_IF:
-			netwk_inf  = read_gmac_reg(node, inf, NETWK_INF_CTRL_REG);
-		        write_gmac_reg(node, inf , NETWK_INF_CTRL_REG, 
+			netwk_inf  = read_gmac_reg(node, block, NETWK_INF_CTRL_REG);
+		        write_gmac_reg(node, block , NETWK_INF_CTRL_REG, 
 					netwk_inf | TX_EN(1)| STATS_EN(1));
-        		mac_cfg1 = read_gmac_reg(node, inf, MAC_CONF1);
-        		write_gmac_reg(node, inf , MAC_CONF1, mac_cfg1 | (0x5));
+        		mac_cfg1 = read_gmac_reg(node, block, MAC_CONF1);
+        		write_gmac_reg(node, block , MAC_CONF1, mac_cfg1 | (0x5));
                         break;
                 case XAUI_IF:
                 case RXAUI_IF:
-			xaui_cfg=nlm_hal_read_mac_reg(node, inf, XGMAC, XAUI_CONFIG_1);
-	                nlm_hal_write_mac_reg(node, inf, XGMAC, XAUI_CONFIG_1, xaui_cfg |
+			xaui_cfg=nlm_hal_read_mac_reg(node, block, XGMAC, XAUI_CONFIG_1);
+	                nlm_hal_write_mac_reg(node, block, XGMAC, XAUI_CONFIG_1, xaui_cfg |
 							XAUI_CONFIG_TFEN | XAUI_CONFIG_RFEN | XAUI_CONFIG_TCTLEN | XAUI_CONFIG_RCTLEN);                               
 
                         break;
@@ -4933,11 +5587,17 @@ static int get_dom_nae_node_ownership(void *fdt, int dom_id, int node, struct nl
 {
 	unsigned int nae_owner[NLM_MAX_NODES];
 	int i;
+	uint32_t owner_mask;
 
 	for(i = 0; i < NLM_MAX_NODES; i++)
 		nae_owner[i] = 1; /* default is owned */	
 
-	get_dom_nae_property(fdt, dom_id, "owner", nae_owner, sizeof(nae_owner));
+	owner_mask = get_dom_owner_mask(fdt, dom_id, "nae");
+	for (i=0; i<NLM_MAX_NODES; i++)
+	{
+		nae_owner[i] = ((owner_mask &(1<<i)) ? 1:0);
+		//nlm_print("nae owner for node %d, is %d.\n", i, nae_owner[i]);
+	}
 
 	//nlm_print("nae ownder for node %d is %d \n", node, nae_owner[node]);
 	nae_cfg->owned  = nae_owner[node];
@@ -4992,11 +5652,6 @@ static void extract_dom_nae_node_freein_fifo_info(void *fdt, int dom_id, int nod
 	get_dom_nae_property(fdt, dom_id, "vfbtbl-hw-nentries", data, sizeof(data));
 	nae_cfg->vfbtbl_hw_nentries = data[node];
 
-	memset(data, 0, sizeof(data));
-	get_dom_nae_property(fdt, dom_id, "dummy-pktdata-addr", data, sizeof(data));
-
-	nae_cfg->dummy_pktdata_addr = ((unsigned long long)data[0] << 32) | data[1];
-
 }
 
 void nlm_hal_derive_cpu_to_freein_fifo_map(int node, 
@@ -5268,7 +5923,6 @@ int nlm_hal_init_nae(void *fdt, int dom_id)
 		} else
 			nlm_print("Extracting CPU-NAE configuration...\n");
 		
-		
         	parse_fdt_cpu_config(fdt, dom_id, nae_cfg);
 
 		if(owned) {
@@ -5315,6 +5969,9 @@ int nlm_hal_init_nae(void *fdt, int dom_id)
 	                }
         	        else {
 #endif
+				if(nae_cfg->ports[i].iftype == RXAUI_IF)
+                                        nae_cfg->ports[i].iftype = XAUI_IF; /*initialization done for RXAUI. Now it`ll be considered as XAUI.*/
+
 				for(offset=0; offset < ctxsize; offset++)
 				nae_cfg->cntx2port[context + offset] = i; /* logical port */
 				NAE_DEBUG("save ctx:%d port:%d\n", context+offset, i);
@@ -5338,6 +5995,13 @@ int nlm_hal_init_nae(void *fdt, int dom_id)
 			}
 		}
 #endif
+		if(is_nlm_xlp2xx() && nae_cfg->msec_port_enable)
+		{
+			nlm_hal_msec_tx_default_config(node,/* port_enable0xff*/nae_cfg->msec_port_enable, /*unsigned int preamble_len*//*0x5555*/0, /*packet_num*/ 0x1, /*pn_thrshld*/0x7fffffff);
+			nlm_hal_msec_rx_default_config(node, /*port_enable0xff*/nae_cfg->msec_port_enable, /*preamble_len*//*0xaaaa*/0, /*packet_num*/0x1, /*replay_win_size*/0x64);
+		}
+		else
+			nae_cfg->msec_port_enable = 0;
 	}
 	
 	return 0;
@@ -5374,12 +6038,679 @@ void nlm_hal_read_nae_ucore_sram_mem(int node, int ucoreid, unsigned int *data,
 	}
 }
 
-void nlm_hal_disable_xaui_flow_control(int node, int interface)
+void nlm_hal_disable_xaui_flow_control(int node, int block)
 {
 	unsigned int xaui_cfg;
-	xaui_cfg = nlm_hal_read_mac_reg(node, interface, XGMAC, XAUI_CONFIG_1);
+	xaui_cfg = nlm_hal_read_mac_reg(node, block, XGMAC, XAUI_CONFIG_1);
 	xaui_cfg &= (~(XAUI_CONFIG_TCTLEN | XAUI_CONFIG_RCTLEN));
-	nlm_hal_write_mac_reg(node, interface, XGMAC, XAUI_CONFIG_1, xaui_cfg);
+	nlm_hal_write_mac_reg(node, block, XGMAC, XAUI_CONFIG_1, xaui_cfg);
+}
+
+
+
+/* Port enable[7:0] = 0xff default all 8 ports are enables
+   preamble _len[23:8] = 0x0000 all port has zero preamblebe len
+   if AAD(preamble len is 12) 0x5555
+   if AAD(preamble len is 16) 0xaaaa
+   based on preamble len, sectag offset will change
+*/
+
+struct sec_mac{
+	unsigned char mac[6];
+};
+struct secure_assoc{
+	int 	port_num;
+	int 	cntx;
+	int 	tci;
+	uint64_t src;
+	uint64_t dst;
+};
+
+#define MACSEC_NUM_SA	8
+
+struct secure_assoc sa[MACSEC_NUM_SA] = {
+
+			{0, 0, 0x13, 0x1122334455670000, 0x1122334455660000},
+			{1, 1, 0x13, 0x1122334455680000, 0x1122334455670000},
+			{2, 2, 0x13, 0x1122334455690000, 0x1122334455680000},
+			{3, 3, 0x13, 0x11223344556a0000, 0x1122334455690000},
+			{4, 4, 0x13, 0x11223344556b0000, 0x11223344556a0000},
+			{5, 5, 0x13, 0x11223344556c0000, 0x11223344556b0000},
+			{6, 6, 0x13, 0x11223344556d0000, 0x11223344556c0000},
+			{7, 7, 0x13, 0x11223344556e0000, 0x11223344556d0000},
+			/*{0, 0, 0x13, 0x1122334455660000, 0x1122334455670000},
+			{1, 1, 0x13, 0x1122334455670000, 0x1122334455680000},
+			{2, 2, 0x13, 0x1122334455680000, 0x1122334455690000},
+			{3, 3, 0x13, 0x1122334455690000, 0x11223344556b0000},
+			{4, 4, 0x13, 0x11223344556a0000, 0x11223344556c0000},
+			{5, 5, 0x13, 0x11223344556b0000, 0x11223344556d0000},
+			{6, 6, 0x13, 0x11223344556c0000, 0x11223344556e0000},
+			{7, 7, 0x13, 0x11223344556d0000, 0x11223344556d0000},*/
+		/*	{0, 0, 0x13, 0x1122334455660000, 0x1011213141500000},
+			{1, 1, 0x13, 0x1122334455770000, 0x1011213141520000},
+			{2, 2, 0x13, 0x1122334455880000, 0x1011213141540000},
+			{3, 3, 0x13, 0x1122334455990000, 0x1011213141560000},
+			{4, 4, 0x13, 0x1122334455aa0000, 0x1011213141580000},
+			{5, 5, 0x13, 0x1122334455bb0000, 0x10112131415a0000},
+			{6, 6, 0x13, 0x1122334455cc0000, 0x10112131415c0000},
+			{7, 7, 0x13, 0x1122334455dd0000, 0x10112131415e0000},
+			{1, 1, 0x0b, {"\x11\x22\x33\x44\x55\x77"},  {"\x11\x11\x21\x31\x41\x52"}},
+			{2, 2, 0x0b, {"\x11\x22\x33\x44\x55\x88"},  {"\x11\x11\x21\x31\x41\x54"}},
+			{3, 3, 0x0b, {"\x11\x22\x33\x44\x55\x99"},  {"\x11\x11\x21\x31\x41\x56"}},
+			{4, 4, 0x0b, {"\x11\x22\x33\x44\x55\xaa"},  {"\x11\x11\x21\x31\x41\x58"}},
+			{5, 5, 0x0b, {"\x11\x22\x33\x44\x55\xbb"},  {"\x11\x11\x21\x31\x41\x5a"}},
+			{6, 6, 0x0b, {"\x11\x22\x33\x44\x55\xcc"},  {"\x11\x11\x21\x31\x41\x5c"}},
+			{7, 7, 0x0b, {"\x11\x22\x33\x44\x55\xdd"},  {"\x11\x11\x21\x31\x41\x5e"}},*/
+	};
+
+struct cipher_key{
+	unsigned char key[16];
+};
+
+struct cipher_key tx_ci_key[16] = {
+	{"\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11"},
+	{"\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11"},
+	{"\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11"},
+	{"\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11"},
+	{"\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11"},
+	{"\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11"},
+	{"\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11"},
+	{"\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11"},
+	{"\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11"},
+	{"\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11"},
+	{"\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11"},
+	{"\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11"},
+	{"\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11"},
+	{"\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11"},
+	{"\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11"},
+	{"\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11"},
+	/*{"\x22\x22\x22\x22\x22\x22\x22\x22\x22\x22\x22\x22\x22\x22\x22\x22"},
+	{"\x33\x33\x33\x33\x33\x33\x33\x33\x33\x33\x33\x33\x33\x33\x33\x33"},
+	{"\x44\x44\x44\x44\x44\x44\x44\x44\x44\x44\x44\x44\x44\x44\x44\x44"},
+	{"\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55"},
+	{"\x66\x66\x66\x66\x66\x66\x66\x66\x66\x66\x66\x66\x66\x66\x66\x66"},
+	{"\x77\x77\x77\x77\x77\x77\x77\x77\x77\x77\x77\x77\x77\x77\x77\x77"},
+	{"\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88"},
+	{"\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99"},
+	{"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"},
+	{"\xbb\xbb\xbb\xbb\xbb\xbb\xbb\xbb\xbb\xbb\xbb\xbb\xbb\xbb\xbb\xbb"},
+	{"\xcc\xcc\xcc\xcc\xcc\xcc\xcc\xcc\xcc\xcc\xcc\xcc\xcc\xcc\xcc\xcc"},
+	{"\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd"},
+	{"\xee\xee\xee\xee\xee\xee\xee\xee\xee\xee\xee\xee\xee\xee\xee\xee"},
+	{"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"},*/
+};
+
+struct cipher_key rx_ci_key[16] = {
+	{"\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11"},
+	{"\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11"},
+	{"\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11"},
+	{"\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11"},
+	{"\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11"},
+	{"\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11"},
+	{"\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11"},
+	{"\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11"},
+	{"\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11"},
+	{"\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11"},
+	{"\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11"},
+	{"\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11"},
+	{"\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11"},
+	{"\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11"},
+	{"\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11"},
+	{"\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11"},
+/*	{"\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11\x11"},
+	{"\x22\x22\x22\x22\x22\x22\x22\x22\x22\x22\x22\x22\x22\x22\x22\x22"},
+	{"\x33\x33\x33\x33\x33\x33\x33\x33\x33\x33\x33\x33\x33\x33\x33\x33"},
+	{"\x44\x44\x44\x44\x44\x44\x44\x44\x44\x44\x44\x44\x44\x44\x44\x44"},
+	{"\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55\x55"},
+	{"\x66\x66\x66\x66\x66\x66\x66\x66\x66\x66\x66\x66\x66\x66\x66\x66"},
+	{"\x77\x77\x77\x77\x77\x77\x77\x77\x77\x77\x77\x77\x77\x77\x77\x77"},
+	{"\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88\x88"},
+	{"\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99\x99"},
+	{"\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xaa"},
+	{"\xbb\xbb\xbb\xbb\xbb\xbb\xbb\xbb\xbb\xbb\xbb\xbb\xbb\xbb\xbb\xbb"},
+	{"\xcc\xcc\xcc\xcc\xcc\xcc\xcc\xcc\xcc\xcc\xcc\xcc\xcc\xcc\xcc\xcc"},
+	{"\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd\xdd"},
+	{"\xee\xee\xee\xee\xee\xee\xee\xee\xee\xee\xee\xee\xee\xee\xee\xee"},
+	{"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"},*/
+};
+
+#ifdef MACSEC_DEBUG
+
+static void dump_buffer(unsigned char *buf, unsigned int len, unsigned char *msg)
+{
+    int k = 0;
+    nlm_print("\n %s", msg);
+    for(k = 0; k < len; k++)
+    {
+        nlm_print(" %.2x",buf[k]);
+        if((k+1) % 16 == 0)
+            nlm_print("\n");
+    }
+    nlm_print("\n");
+}
+#endif
+/* CHANGE HE ORDER OF THE KEY */
+
+void nlm_hal_msec_set_tx_key(int node, int index, unsigned char *key)
+{
+	unsigned int cntrl_reg_val = (1 << 22 | (index & 0x7ff));
+	
+	nlm_hal_write_nae_reg(node, TX_MSEC_MEM_DATAREG_3, *(unsigned int*)key);
+	key = key+4;
+	nlm_hal_write_nae_reg(node, TX_MSEC_MEM_DATAREG_2, *(unsigned int*)key);
+	key = key+4;
+	nlm_hal_write_nae_reg(node, TX_MSEC_MEM_DATAREG_1, *(unsigned int*)key);
+	key = key+4;
+	nlm_hal_write_nae_reg(node, TX_MSEC_MEM_DATAREG_0, *(unsigned int*)key);
+
+	nlm_hal_write_nae_reg(node, TX_MSEC_MEM_CTRL_REG, cntrl_reg_val);
+}
+/*
+void nlm_hal_msec_set_tx_key(int node, int index, unsigned char *key)
+{
+	unsigned int cntrl_reg_val = (1 << 22 | (index & 0x7ff));
+	
+	nlm_hal_write_nae_reg(node, TX_MSEC_MEM_DATAREG_0, *(unsigned int*)key);
+	key = key+4;
+	nlm_hal_write_nae_reg(node, TX_MSEC_MEM_DATAREG_1, *(unsigned int*)key);
+	key = key+4;
+	nlm_hal_write_nae_reg(node, TX_MSEC_MEM_DATAREG_2, *(unsigned int*)key);
+	key = key+4;
+	nlm_hal_write_nae_reg(node, TX_MSEC_MEM_DATAREG_3, *(unsigned int*)key);
+
+	nlm_hal_write_nae_reg(node, TX_MSEC_MEM_CTRL_REG, cntrl_reg_val);
+}
+*/
+
+void nlm_hal_msec_set_tx_param(int node, int index, unsigned int param)
+{
+	unsigned int cntrl_reg_val = (1 << 22 | 1 << 11 | (index & 0x7ff));
+	
+	nlm_hal_write_nae_reg(node, TX_MSEC_MEM_DATAREG_0, param);
+	nlm_hal_write_nae_reg(node, TX_MSEC_MEM_CTRL_REG, cntrl_reg_val);
+}
+void nlm_hal_msec_set_tx_cntx_to_sa(int node, int cntx, int sa)
+{
+	unsigned int cntrl_reg_val = (1 << 22 | 2 << 11 | (cntx & 0x7ff));
+	
+	nlm_hal_write_nae_reg(node, TX_MSEC_MEM_DATAREG_0, sa);
+	nlm_hal_write_nae_reg(node, TX_MSEC_MEM_CTRL_REG, cntrl_reg_val);
+}
+
+void nlm_hal_msec_set_tx_sci(int node, int index, uint64_t sci)
+{
+	unsigned int cntrl_reg_val = (1 << 22 | 3 << 11 | (index & 0x7ff));
+	
+	nlm_hal_write_nae_reg(node, TX_MSEC_MEM_DATAREG_0, sci);
+	nlm_hal_write_nae_reg(node, TX_MSEC_MEM_CTRL_REG, cntrl_reg_val);
+}
+
+void nlm_hal_msec_set_tx_tci(int node, int index, int tci)
+{
+	unsigned int cntrl_reg_val = (1 << 22 | 4 << 11 | (index & 0x7ff));
+	
+	nlm_hal_write_nae_reg(node, TX_MSEC_MEM_DATAREG_0, tci & 0x3f);
+	nlm_hal_write_nae_reg(node, TX_MSEC_MEM_CTRL_REG, cntrl_reg_val);
+}
+
+void nlm_hal_msec_tx_mem_config(int node, int context, int tci, uint64_t sci, unsigned char *key)
+{
+	int port;
+	port = *(cntx2port[node] + context);
+#ifdef MACSEC_DEBUG
+	nlm_print("%s node = %d, port = %d context = %d, tci = %x, sci = %llx\n",__FUNCTION__, node, port, context, tci, sci);
+	dump_buffer(key, 16, "tx_key:");
+#endif
+	nlm_hal_msec_set_tx_cntx_to_sa(node, context, port);
+	nlm_hal_msec_set_tx_sci(node, port, sci);
+	nlm_hal_msec_set_tx_tci(node, port, tci);
+	nlm_hal_msec_set_tx_key(node, (port << 1)/*index<<1 | AN */, key);/* AN = 0*/
+	nlm_hal_msec_set_tx_key(node, ((port << 1)| 1)/*index<<1 | AN */, key);/* AN = 1 */
+}
+
+
+void nlm_hal_msec_tx_config(int node, unsigned int port_enable, unsigned int preamble_len, unsigned int packet_num, unsigned int pn_thrshld)
+{
+	unsigned int sec_tag_offset[2], i = 0, port = 0, param, icv_len = 16, sectag_len = 0x8;
+	uint64_t sec_tag_preamble;
+	struct nlm_hal_nae_config *nae_cfg;
+
+	nae_cfg = nlm_node_cfg.nae_cfg[node];
+
+	sec_tag_offset[0] = 0x0c0c0c0c;
+	sec_tag_offset[1] = 0x0c0c0c0c;
+#ifdef MACSEC_DEBUG
+	nlm_print("%s node = %d port_enable = %x preamble_len = %x packet_num = %d pn_thrshld = %d\n", __FUNCTION__, node, port_enable, preamble_len, packet_num, pn_thrshld);
+#endif
+	nlm_hal_write_nae_reg(node, TX_MSEC_BYPASS, 0x0);
+	nlm_hal_write_nae_reg(node, TX_MSEC_ETHER_TYPE, 0x88e5);
+	/* Enable port and pramble len for each port */
+	nlm_hal_write_nae_reg(node, TX_MSEC_PORT_EN, port_enable & 0xff);
+
+
+	nlm_hal_write_nae_reg(node, TX_MSEC_INIT_PN, packet_num);
+	nlm_hal_write_nae_reg(node, TX_MSEC_PN_THRESH, pn_thrshld);
+	nlm_hal_write_nae_reg(node, TX_MSEC_PREAMBLE_LEN_CODE, preamble_len);
+
+	while(preamble_len)
+	{	
+		if((preamble_len & 0x3) == 0x1)
+			sec_tag_offset[i/4] += 0xc << ((i%4) * 8);
+		if((preamble_len & 0x3) == 0x2)
+			sec_tag_offset[i/4] += 0x10 << ((i%4) * 8);
+		i++;
+		preamble_len = preamble_len >> 2;
+	}
+	sec_tag_preamble = ((uint64_t)(sec_tag_offset[1]) << 32) | sec_tag_offset[0];
+
+	for(i = 0; i < 8/*Num_ports*/;i++)
+	{
+		nae_cfg->sectag_offset[i] = (sec_tag_offset[i/4] >> (i *8)) &0xff;
+		nae_cfg->icv_len[i] = icv_len;
+		nae_cfg->sectag_len[i] = sectag_len;
+	}
+#ifdef MACSEC_DEBUG
+        nlm_print(" %s sec_tag_offset = %x %x sec_tag_preamble = %llx\n", __FUNCTION__, sec_tag_offset[0], sec_tag_offset[1], sec_tag_preamble);
+#endif
+	/* ci offset = sectag_preamble + 16 (sectag header length)*/
+	while(port_enable)
+	{
+		if(port_enable & 0x1)
+		{
+			param = ((sec_tag_preamble >> (port * 8)) & 0xff) << 16 | (((sec_tag_preamble >>(port * 8)) & 0xff) + sectag_len) << 8 | icv_len;
+			nlm_hal_msec_set_tx_param(node, port, param);
+#ifdef MACSEC_DEBUG
+        		nlm_print("%s param = %x\n", __FUNCTION__, param);
+#endif
+		}
+		port++;
+		port_enable = port_enable >> 1;
+	}
+}
+
+/* Config  ci key, param, cntxtoSAMap, sci adn tci memory */
+/* For simplicity total 8 cntx, 8 sci, 8 tci and 8 param are programmed, one for each port */
+void nlm_hal_msec_tx_default_config(int node, unsigned int port_enable, unsigned int preamble_len, unsigned int packet_num, unsigned int pn_thrshld)
+{
+	unsigned int num_sa, i;
+	uint64_t sci;
+	num_sa = MACSEC_NUM_SA;
+
+	nlm_hal_msec_tx_config(node, port_enable, preamble_len, packet_num, pn_thrshld);
+	for(i = 0; i < num_sa; i++)
+	{
+		//sci = *((uint64_t*)(sa[j].src.mac));
+		sci = sa[i].src;
+		/* sci | port identifier. For each src mac thee are two sa for each dst mac */
+		//sci = sci | (i%2);
+		sci = sci | 1; /* Port identifier 1. 0 will be taken directly from SRC MAC */
+
+#ifdef MACSEC_DEBUG
+        	nlm_print("macsec port_num = %d cntx = %d, tci = %d src_mac = %llx dst_mac = %llx sci = %llx tci = %x \n",sa[i].port_num, sa[i].cntx, sa[i].tci, sa[i].src, sa[i].dst, sci, sa[i].tci); 
+		dump_buffer(tx_ci_key[i].key, 16, "tx_default_key:");
+#endif
+
+		nlm_hal_msec_tx_mem_config(node, sa[i].cntx, sa[i].tci, sci, tx_ci_key[i].key);
+	}
+}
+
+/* //These functions can be opened and used for debug purpose
+int nlm_hal_msec_get_tx_param(int node, int index)
+{
+	unsigned int cntrl_reg_val =  (1 << 11 | index & 0x7ff);
+	unsigned int param;
+
+	nlm_hal_write_nae_reg(node, RX_MSEC_MEM_CTRL_REG, cntrl_reg_val);
+
+	cntrl_reg_val = nlm_hal_read_nae_reg(node, TX_MSEC_MEM_CTRL_REG);
+	if(cntrl_reg_val & (1<< 23))
+	{
+		param = nlm_hal_read_nae_reg(node, TX_MSEC_MEM_DATAREG_0);
+	}
+	return param;
+}
+int nlm_hal_msec_get_tx_cntx_to_sa(int node, int cntx)
+{
+	unsigned int cntrl_reg_val =  (2 << 11 | cntx & 0x7ff);
+	unsigned int sa;
+
+	nlm_hal_write_nae_reg(node, RX_MSEC_MEM_CTRL_REG, cntrl_reg_val);
+
+	cntrl_reg_val = nlm_hal_read_nae_reg(node, TX_MSEC_MEM_CTRL_REG);
+	if(cntrl_reg_val & (1<< 23))
+	{
+		sa = nlm_hal_read_nae_reg(node, TX_MSEC_MEM_DATAREG_0);
+	}
+	return sa;
+}
+
+uint64_t nlm_hal_msec_get_tx_sci(int node, int index)
+{
+	unsigned int data, cntrl_reg_val =  (3 << 11 | cntx & 0x7ff);
+	uint64_t sci;
+
+	nlm_hal_write_nae_reg(node, RX_MSEC_MEM_CTRL_REG, cntrl_reg_val);
+
+	cntrl_reg_val = nlm_hal_read_nae_reg(node, TX_MSEC_MEM_CTRL_REG);
+	if(cntrl_reg_val & (1<< 23))
+	{
+		data = nlm_hal_read_nae_reg(node, TX_MSEC_MEM_DATAREG_0);
+		sci = data;
+		data = nlm_hal_read_nae_reg(node, TX_MSEC_MEM_DATAREG_1);
+		sci = data << 32 | sci;
+	}
+	return sci;
+}
+usigned int nlm_hal_msec_get_tx_tci(int node, int cntx)
+{
+	unsigned int cntrl_reg_val =  (4 << 11 | cntx & 0x7ff);
+	unsigned int tci;
+
+	nlm_hal_write_nae_reg(node, RX_MSEC_MEM_CTRL_REG, cntrl_reg_val);
+
+	cntrl_reg_val = nlm_hal_read_nae_reg(node, TX_MSEC_MEM_CTRL_REG);
+	if(cntrl_reg_val & (1<< 23))
+	{
+		tci = nlm_hal_read_nae_reg(node, TX_MSEC_MEM_DATAREG_0);
+	}
+	return tci;
+}
+*/
+
+
+
+void nlm_hal_msec_set_rx_cam(int node, int index, int port_num, uint64_t sci, uint64_t sci_mask)
+{
+	/* | CTRL_REG_RD_DONE | CTRL_REG_WR_EN | CTRL_REG_MEM_SEL[10:0] | CTRL_REG_ADDRESS[10:0] |*/
+	unsigned int cntrl_reg_val = (1 << 22 | (2 << 11)| (index & 0x7ff));
+	sci = sci & sci_mask;
+	
+	nlm_hal_write_nae_reg(node, RX_MSEC_MEM_DATAREG_0, sci & 0xffffffff);
+	nlm_hal_write_nae_reg(node, RX_MSEC_MEM_DATAREG_1, (sci>>32) & 0xffffffff);
+	nlm_hal_write_nae_reg(node, RX_MSEC_MEM_DATAREG_2, (port_num & 0x7)|0x0000);
+
+	nlm_hal_write_nae_reg(node, RX_MSEC_MEM_CTRL_REG, cntrl_reg_val);
+	nlm_hal_write_nae_reg(node, RX_MSEC_SCI_MASK_LO(port_num), sci_mask & 0xffffffff);
+	nlm_hal_write_nae_reg(node, RX_MSEC_SCI_MASK_HI(port_num), (sci_mask >> 32) & 0xffffffff);
+}
+
+unsigned int nlm_hal_msec_get_rx_cam(int node, int index)
+{
+	unsigned int cntrl_reg_val =  (2 << 11)| (index & 0x7ff);
+	unsigned int data = 0, data1 = 0, data2 = 0;
+
+	nlm_hal_write_nae_reg(node, RX_MSEC_MEM_CTRL_REG, cntrl_reg_val);
+
+	cntrl_reg_val = nlm_hal_read_nae_reg(node, RX_MSEC_MEM_CTRL_REG);
+	if(cntrl_reg_val & (1<< 23))
+	{
+		data = nlm_hal_read_nae_reg(node, RX_MSEC_MEM_DATAREG_0);
+		data1 = nlm_hal_read_nae_reg(node, RX_MSEC_MEM_DATAREG_1);
+		data2 = nlm_hal_read_nae_reg(node, RX_MSEC_MEM_DATAREG_2);
+	}
+#ifdef MACSEC_DEBUG
+	nlm_print("RX CAM index = %d, data0 = %x data_1 = %x data_2 = %x\n", index, data, data1, data2);
+#endif
+	return data;
+}
+/* Changed the order of bytes */
+void nlm_hal_msec_set_rx_key(int node, int index, unsigned char *key)
+{
+	unsigned int cntrl_reg_val = (1 << 22 | (index & 0x7ff)), local_key;
+	
+#ifdef MACSEC_DEBUG
+	nlm_print("Set RX key- index = %d \n", index);
+#endif
+	local_key = (key[0] << 24) | (key[1] << 16) | (key[2] << 8) | key[3];
+	nlm_hal_write_nae_reg(node, RX_MSEC_MEM_DATAREG_3, local_key);
+	key = key+4;
+	local_key = (key[0] << 24) | (key[1] << 16) | (key[2] << 8) | key[3];
+	nlm_hal_write_nae_reg(node, RX_MSEC_MEM_DATAREG_2, local_key);
+	key = key+4;
+	local_key = (key[0] << 24) | (key[1] << 16) | (key[2] << 8) | key[3];
+	nlm_hal_write_nae_reg(node, RX_MSEC_MEM_DATAREG_1, local_key);
+	key = key+4;
+	local_key = (key[0] << 24) | (key[1] << 16) | (key[2] << 8) | key[3];
+	nlm_hal_write_nae_reg(node, RX_MSEC_MEM_DATAREG_0, local_key);
+
+	nlm_hal_write_nae_reg(node, RX_MSEC_MEM_CTRL_REG, cntrl_reg_val);
+}
+/*
+void nlm_hal_msec_set_rx_key(int node, int index, unsigned char *key)
+{
+	unsigned int cntrl_reg_val = (1 << 22 | (index & 0x7ff)), local_key;
+	
+	local_key = (key[3] << 24) | (key[2] << 16) | (key[1] << 8) | key[0];
+	nlm_hal_write_nae_reg(node, RX_MSEC_MEM_DATAREG_0, local_key);
+	key = key+4;
+	local_key = (key[3] << 24) | (key[2] << 16) | (key[1] << 8) | key[0];
+	nlm_hal_write_nae_reg(node, RX_MSEC_MEM_DATAREG_1, local_key);
+	key = key+4;
+	local_key = (key[3] << 24) | (key[2] << 16) | (key[1] << 8) | key[0];
+	nlm_hal_write_nae_reg(node, RX_MSEC_MEM_DATAREG_2, local_key);
+	key = key+4;
+	local_key = (key[3] << 24) | (key[2] << 16) | (key[1] << 8) | key[0];
+	nlm_hal_write_nae_reg(node, RX_MSEC_MEM_DATAREG_3, local_key);
+
+	nlm_hal_write_nae_reg(node, RX_MSEC_MEM_CTRL_REG, cntrl_reg_val);
+}
+*/
+void nlm_hal_msec_get_rx_key(int node, int index, unsigned char *key)
+{
+	unsigned int cntrl_reg_val =  (index & 0x7ff);
+	unsigned int data;
+	unsigned char *temp = key;
+
+	nlm_hal_write_nae_reg(node, RX_MSEC_MEM_CTRL_REG, cntrl_reg_val);
+
+	cntrl_reg_val = nlm_hal_read_nae_reg(node, RX_MSEC_MEM_CTRL_REG);
+	if(cntrl_reg_val & (1<< 23))
+	{
+		data = nlm_hal_read_nae_reg(node, RX_MSEC_MEM_DATAREG_0);
+		*(unsigned int*)key = data;
+		key = key+4;
+		data = nlm_hal_read_nae_reg(node, RX_MSEC_MEM_DATAREG_1);
+		*(unsigned int*)key = data;
+		key = key+4;
+		data = nlm_hal_read_nae_reg(node, RX_MSEC_MEM_DATAREG_2);
+		*(unsigned int*)key = data;
+		key = key+4;
+		data = nlm_hal_read_nae_reg(node, RX_MSEC_MEM_DATAREG_3);
+		*(unsigned int*)key = data;
+	}
+	key = temp;
+}
+
+
+void nlm_hal_msec_set_rx_param(int node, int index, unsigned int param)
+{
+	unsigned int cntrl_reg_val = (1 << 22 | 1 << 11 |(index & 0x7ff));
+	
+	nlm_hal_write_nae_reg(node, RX_MSEC_MEM_DATAREG_0, param);
+	nlm_hal_write_nae_reg(node, RX_MSEC_MEM_CTRL_REG, cntrl_reg_val);
+}
+
+unsigned int nlm_hal_msec_get_rx_param(int node, int index)
+{
+	unsigned int cntrl_reg_val =  ((1 << 11) | (index & 0x7ff));
+	unsigned int data = 0;
+
+	nlm_hal_write_nae_reg(node, RX_MSEC_MEM_CTRL_REG, cntrl_reg_val);
+
+	cntrl_reg_val = nlm_hal_read_nae_reg(node, RX_MSEC_MEM_CTRL_REG);
+	if(cntrl_reg_val & (1<< 23))
+	{
+		data = nlm_hal_read_nae_reg(node, RX_MSEC_MEM_DATAREG_0);
+	}
+#ifdef MACSEC_DEBUG
+	nlm_print("RX- index = %d PARAM= %x\n", index, data);
+#endif
+	return data;
+}
+
+/* Config cam, ci key and param memory */
+void nlm_hal_msec_rx_mem_config(int node, int port, int index, uint64_t sci, unsigned char *key, uint64_t sci_mask)
+{
+#ifdef MACSEC_DEBUG
+        nlm_print("%s node= %d port = %d index = %d sci = %llx sci_mask = %llx\n",__FUNCTION__, node, port, index, sci, sci_mask);
+#endif
+
+	nlm_hal_msec_set_rx_cam(node, index, port, sci, sci_mask);
+
+	index = index << 1; /* Writing at AN = 0. index << 1 | AN*/
+	nlm_hal_msec_set_rx_key(node, index, key);
+
+	index = index | 1; /* Writing at AN = 1. index << 1 | AN*/
+	nlm_hal_msec_set_rx_key(node, index, key);
+}
+
+void dump_rx_mem_config(int node)
+{
+	unsigned int num_sa, i;
+	num_sa = MACSEC_NUM_SA;
+#ifdef MACSEC_DEBUG
+	nlm_print("%s\n",__FUNCTION__);
+#endif
+	for(i = 0; i < num_sa; i++)
+	{
+		 nlm_hal_msec_get_rx_cam(node, i);
+		 nlm_hal_msec_get_rx_param(node, i);
+
+	}
+
+}
+ 
+void nlm_hal_msec_rx_config(int node, unsigned int port_enable, unsigned int preamble_len, unsigned int packet_num, unsigned int replay_win_size)
+{
+	unsigned int sec_tag_offset[2], i = 0, port, param;
+	uint64_t sec_tag_preamble;
+
+	sec_tag_offset[0] = 0x0c0c0c0c;
+	sec_tag_offset[1] = 0x0c0c0c0c;
+#ifdef MACSEC_DEBUG
+        nlm_print("%s node = %d, port_enable = %x, preamble_len = %x, packet_num = %x, replay_win_size = %d\n", __FUNCTION__, node, port_enable, preamble_len, packet_num, replay_win_size);
+#endif
+	/* Anti reply mode is not working. Always bypass anti reply check*/
+	nlm_hal_write_nae_reg(node, RX_MSEC_BYPASS, 0x2);
+	/* Enable port and pramble len for each port */
+	nlm_hal_write_nae_reg(node, RX_MSEC_PORT_EN, (preamble_len | port_enable) & 0xffffff);
+
+	while(preamble_len)
+	{	
+		if((preamble_len & 0x3) == 0x1)
+			sec_tag_offset[i/4] += 0xc << ((i%4) * 8);
+		if((preamble_len & 0x3) == 0x2)
+			sec_tag_offset[i/4] += 0x10 << ((i%4) * 8);
+		i++;
+		preamble_len = preamble_len >> 2;
+	}
+	/* Set setag offset. default is 12, it can be 24 pr 28 also depending on preamble length*/
+	nlm_hal_write_nae_reg(node, RX_MSEC_SEC_TAG0, sec_tag_offset[0]);
+	nlm_hal_write_nae_reg(node, RX_MSEC_SEC_TAG1, sec_tag_offset[1]);
+
+	nlm_hal_write_nae_reg(node, RX_MSEC_INIT_PN, packet_num);
+	nlm_hal_write_nae_reg(node, RX_MSEC_REPLAY_WIN_SIZE, replay_win_size);
+
+	sec_tag_preamble = (((uint64_t)sec_tag_offset[1]) << 32) | sec_tag_offset[0];
+
+	port = 0; 
+	while(port_enable)
+	{
+		if(port_enable & 0x1)
+		{
+			/* ci offset = sectag_preamble + 16 (sectag header length)*/
+			param = (((sec_tag_preamble >> (port * 8)) & 0xff) + 8/*16*/) << 8 | 0x10;
+			
+#ifdef MACSEC_DEBUG
+			nlm_print("%s param = %x\n", __FUNCTION__, param);
+#endif
+			nlm_hal_msec_set_rx_param(node, port, param);
+		}
+		port++;
+		port_enable = port_enable >> 1;
+	}
+}
+
+void nlm_hal_msec_rx_default_config(int node, unsigned int port_enable, unsigned int preamble_len, unsigned int packet_num, unsigned int replay_win_size)
+{
+	unsigned int num_sa, i;
+	uint64_t sci, sci_mask = 0xffffffffffff0000;/* Last 4 nibbles are don't care to handle port indentifier*/
+	num_sa = MACSEC_NUM_SA;
+
+	nlm_hal_msec_rx_config(node, port_enable, preamble_len, packet_num, replay_win_size);
+
+	for(i = 0; i < num_sa; i++)
+	{
+		//sci = *(uint64_t*)sa[i].dst.mac;
+		sci = sa[i].dst;
+		/* sci | port identifier = 0001 as SCB bit is not set*/
+		/*sci = sci | 1;//i%2;*/ /* As sci mask is 0xffffffffffff0000 then port identifier is not required */
+#ifdef MACSEC_DEBUG
+        	nlm_print("macsec port_num = %d src = %llx dst = %llx sci = %llx\n",sa[i].port_num, sa[i].src, sa[i].dst, sci); 
+		dump_buffer(rx_ci_key[i].key, 16, "rx_key:");
+#endif
+		nlm_hal_msec_rx_mem_config(node, sa[i].port_num, i, sci, rx_ci_key[i].key, sci_mask);
+	}
+
+#ifdef MACSEC_DEBUG
+	dump_rx_mem_config(node);
+#endif
+}
+
+/* called only if the shared domain are exists 
+ Extracts the paddr and desc information */
+int nlm_hal_retrieve_shared_freein_fifo_info(void *fdt, 
+		int shared_dom_id, 
+		int *owner_replenish, 
+		char **paddr_info, int *paddr_info_len,
+		char **desc_info, int *desc_info_len)
+{
+	char nae_node_str[64];
+	char *pbuf;
+	const char *paddrname =  "freein-fifo-replenish-addr-info";
+	const char *pinfoname =  "freein-fifo-replenish-desc-info";
+	const char *ownerrepl = "freein-fifo-replenish-by-owner";
+	int plen, pnode;
+	
+	sprintf(nae_node_str, "/doms/dom@%d/nae", shared_dom_id);
+
+	pnode = fdt_path_offset(fdt, nae_node_str);
+	if (pnode < 0) {
+		return -1;
+	}
+
+	pbuf = (char *)fdt_getprop(fdt, pnode, ownerrepl, &plen);
+	if (pbuf == NULL) {
+		return -1;
+	}
+	*owner_replenish = fdt32_to_cpu(*(unsigned int *)pbuf);
+
+	pbuf = (char *)fdt_getprop(fdt, pnode, paddrname, &plen);
+	if (pbuf == NULL) {
+		return -1;
+	}
+	*paddr_info = pbuf;
+	*paddr_info_len = plen;
+
+	pbuf = (char *)fdt_getprop(fdt, pnode, pinfoname, &plen);
+	if (pbuf == NULL) {
+		return -1;
+	}
+	*desc_info = pbuf;
+	*desc_info_len = plen;
+
+	return 0;
+}
+
+unsigned int nlm_hal_retrieve_freein_fifo_mask(void *fdt, int node, int dom_id)
+{
+	unsigned int freein_fifo_mask[NLM_MAX_NODES];
+	memset(freein_fifo_mask, 0, sizeof(freein_fifo_mask));
+
+	get_dom_nae_property(fdt, dom_id, "freein-fifo-mask", 
+			freein_fifo_mask, sizeof(freein_fifo_mask));
+
+	return freein_fifo_mask[node];
 }
 
 #ifdef NLM_HAL_LINUX_KERNEL
@@ -5399,6 +6730,18 @@ EXPORT_SYMBOL(nlm_enable_poe_statistics);
 EXPORT_SYMBOL(nlm_read_poe_statistics);
 EXPORT_SYMBOL(nlm_clear_poe_stats);
 EXPORT_SYMBOL(nlm_disable_poe_statistics);
+EXPORT_SYMBOL(nlm_hal_prepad_enable);
+EXPORT_SYMBOL(nlm_hal_reset_1588_accum);
+EXPORT_SYMBOL(nlm_hal_1588_ld_freq_mul);
+EXPORT_SYMBOL(nlm_hal_1588_ld_offs);
+EXPORT_SYMBOL(nlm_hal_get_int_sts);
+EXPORT_SYMBOL(nlm_hal_1588_ld_user_val);
+EXPORT_SYMBOL(nlm_hal_1588_ptp_clk_sel);
+EXPORT_SYMBOL(nlm_hal_1588_ptp_get_counter);
+EXPORT_SYMBOL(nlm_hal_1588_ptp_set_counter);
+EXPORT_SYMBOL (nlm_hal_clear_1588_intr);
+EXPORT_SYMBOL(nlm_hal_is_intr_1588);
+EXPORT_SYMBOL(nlm_hal_enable_1588_intr);
 EXPORT_SYMBOL(nlm_hal_open_if);
 EXPORT_SYMBOL(nlm_hal_init_ingress);
 EXPORT_SYMBOL(nlm_hal_load_ucore);
@@ -5417,4 +6760,13 @@ EXPORT_SYMBOL(nlm_hal_restart_ucore);
 EXPORT_SYMBOL(nlm_hal_derive_cpu_to_freein_fifo_map);
 EXPORT_SYMBOL(nlm_hal_modify_nae_ucore_sram_mem);
 EXPORT_SYMBOL(nlm_hal_read_nae_ucore_sram_mem);
+EXPORT_SYMBOL(nlm_hal_msec_tx_config);
+EXPORT_SYMBOL(nlm_hal_msec_rx_config);
+EXPORT_SYMBOL(nlm_hal_msec_tx_default_config);
+EXPORT_SYMBOL(nlm_hal_msec_rx_default_config);
+EXPORT_SYMBOL(nlm_hal_msec_tx_mem_config);
+EXPORT_SYMBOL(nlm_hal_msec_rx_mem_config);
+EXPORT_SYMBOL(nlm_hal_get_rtc);
+EXPORT_SYMBOL(nlm_hal_retrieve_shared_freein_fifo_info);
+EXPORT_SYMBOL(nlm_hal_retrieve_freein_fifo_mask);
 #endif /* #ifdef NLM_HAL_LINUX_KERNEL */
diff --git a/arch/mips/netlogic/common/nlm_hal_sys.c b/arch/mips/netlogic/common/nlm_hal_sys.c
index eaa0292..d40f615 100644
--- a/arch/mips/netlogic/common/nlm_hal_sys.c
+++ b/arch/mips/netlogic/common/nlm_hal_sys.c
@@ -1,27 +1,32 @@
-/***********************************************************************
-Copyright 2003-2010 Netlogic Microsystems (``Netlogic''). All rights
-reserved.
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in
-the documentation and/or other materials provided with the
-distribution.
-THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
-THE POSSIBILITY OF SUCH DAMAGE.
-*****************************#NETL_2#********************************/
+/*-
+ * Copyright (c) 2003-2012 Broadcom Corporation
+ * All Rights Reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY BROADCOM ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL BROADCOM OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * #BRCM_2# */
+
 #if !defined(__KERNEL__) && !defined(NLM_HAL_UBOOT)
 #include <stddef.h>
 #endif
@@ -32,6 +37,10 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include "nlm_hal_sys.h"
 #include "nlm_hal_xlp_dev.h"
 
+uint64_t nlm_hal_xlp2xx_get_pllfreq_dyn(int node, uint8_t pll_type);
+uint64_t nlm_hal_xlp2xx_set_pllfreq_dyn(int node, uint8_t pll_type, uint64_t freq);
+uint64_t nlm_hal_xlp2xx_get_pll_out_frq(int node, uint8_t pll_type);
+
 /**
  * Calculate the DFS divider value for the specified reference clock
  * and target output frequency.
@@ -46,29 +55,24 @@ static uint8_t fuzzy_divider(uint64_t reference, uint64_t target)
 {
 	uint64_t divider = reference;
 	uint64_t freq = reference;
-    uint64_t delta;
-    uint8_t result;
-
-#ifdef NLM_HAL_LINUX_KERNEL
-    do_div(divider, target);
-    do_div(freq, divider);
-#else
-    divider /= target;
-    freq /= divider;
-#endif
+	uint64_t delta;
+	uint8_t result;
+	NLM_HAL_DO_DIV(divider, target);
+	NLM_HAL_DO_DIV(freq, divider);
 	delta = freq - target;
-    result = (uint8_t)divider;
-
+	result = (uint8_t)divider;
 	return (delta <= FREQ_RESOLUTION)? result : (result + 1);
 }
 
+
 /**
  * @returns the numerator for the reference clock frequency.
  */
 static inline uint64_t ref_clk_num(void)
 {
-	return REF_CLK_NUM;
+	return  (nlm_hal_is_ref_clk_133MHz()) ? REF_CLK_NUM_400 : REF_CLK_NUM_200;
 }
+
 /**
  * @returns the denominator for the reference clock frequency.
  */
@@ -79,9 +83,18 @@ static inline uint64_t ref_clk_den(void)
 /**
  * @returns the current reference clock frequency, in Hz.
  */
-static inline uint64_t ref_clk_freq(void)
+uint64_t nlm_hal_get_ref_clk_freq(void)
 {
-	return ref_clk_num() / ref_clk_den();
+        uint64_t ref_freq;
+        uint64_t clk_num;
+        uint32_t clk_den;
+
+	if(is_nlm_xlp2xx()) {
+		ref_freq = xlp2xx_get_ref_clk(0, &clk_num, &clk_den);
+	} else {
+		ref_freq = ref_clk_num() / ref_clk_den();
+	}
+	return ref_freq;
 }
 
 /**
@@ -114,26 +127,24 @@ static inline uint8_t min_dfs_val(void)
  */
 static inline uint64_t pll_freq(uint8_t divr, uint8_t divf, uint8_t pll_dfs)
 {
-#ifndef NLM_HAL_LINUX_KERNEL
-	return (ref_clk_num() * (divf + 1) * 4 / 2) / (ref_clk_den() * (divr + 1) * (pll_dfs + 1));
-#else
-    uint64_t num = ref_clk_num() * (divf + 1) * 4 / 2;
-    uint64_t den = ref_clk_den() * (divr + 1) * (pll_dfs + 1);
-    do_div(num, den);
+	uint64_t num = ref_clk_num() * (divf + 1) * 4 / 2;
+	uint64_t den = ref_clk_den() * (divr + 1) * (pll_dfs + 1);
+	NLM_HALT_IF_XLPII();
+	NLM_HAL_DO_DIV(num, den);
 	return num;
-#endif
 }
 
 /**
  * Get the DFS index for the DFS value (to be used with the stepping functions).
  * The DFS value is rounded up (producing the lower output frequency) if
  * the exact DFS value does not exist.
- * @param [in] dfs DFS divider value.
+  @param [in] dfs DFS divider value.
  * @return the DFS index greater than or equal to the specified DFS divider value.
  */
 static inline int8_t closest_dfs_index(uint8_t dfs)
 {
 	int i;
+	NLM_HALT_IF_XLPII();
 	if (dfs > max_dfs_val())
 		return COUNT_OF(DFS)-1;
 
@@ -153,6 +164,7 @@ static inline int8_t closest_dfs_index(uint8_t dfs)
  */
 static inline uint8_t is_core_pll_dfs_bypassed(int node)
 {
+	NLM_HALT_IF_XLPII();
 	/* no Core PLL DFS on XLP8XX/4XX A-stepping */
 	if (is_nlm_xlp8xx_ax())
 		return 1;
@@ -167,6 +179,7 @@ static inline uint8_t is_core_pll_dfs_bypassed(int node)
  */
 static inline uint8_t is_soc_pll_dfs_bypassed(int node)
 {
+	NLM_HALT_IF_XLPII();
 	/* no Core PLL DFS on XLP8XX/4XX A-stepping */
 	if (is_nlm_xlp8xx_ax())
 		return 1;
@@ -179,6 +192,7 @@ static inline uint8_t is_soc_pll_dfs_bypassed(int node)
  */
 static inline uint64_t core_pll_dfs_val(int node)
 {
+	NLM_HALT_IF_XLPII();
 	/* no Core PLL DFS on XLP8XX/4XX A-stepping */
 	if (is_nlm_xlp8xx_ax())
 		return 0;
@@ -193,6 +207,7 @@ static inline uint64_t core_pll_dfs_val(int node)
  */
 static inline uint64_t soc_pll_dfs_val(int node)
 {
+	NLM_HALT_IF_XLPII();
 	/* no SoC PLL DFS on XLP8XX/4XX A-stepping */
 	if (is_nlm_xlp8xx_ax())
 		return 0;
@@ -207,6 +222,7 @@ static inline uint64_t soc_pll_dfs_val(int node)
 static inline uint64_t core_pll_freq(int node)
 {
 	uint32_t reg = nlm_hal_read_sys_reg(node, POWER_ON_RESET_CFG);
+	NLM_HALT_IF_XLPII();
 	uint8_t divr = (reg >> 8)  & 0x3;
 	uint8_t divf = (reg >> 10) & 0x7f;
 	return pll_freq(divr, divf, core_pll_dfs_val(node));
@@ -218,6 +234,7 @@ static inline uint64_t core_pll_freq(int node)
 static inline uint64_t soc_pll_freq(int node)
 {
 	uint32_t reg = nlm_hal_read_sys_reg(node, PLL_CTRL);
+	NLM_HALT_IF_XLPII();
 	uint8_t divf = (reg >> 3) & 0x7F;
 	uint8_t divr = (reg >> 1) & 0x3;
 	return pll_freq(divr, divf, soc_pll_dfs_val(node));
@@ -229,6 +246,7 @@ static inline uint64_t soc_pll_freq(int node)
 static inline uint64_t ddr_pll_freq(int node)
 {
 	uint32_t reg = nlm_hal_read_sys_reg(node, PLL_CTRL);
+	NLM_HALT_IF_XLPII();
 	uint8_t divf = (reg >> 19) & 0x7F;
 	uint8_t divr = (reg >> 17) & 0x3;
 	return pll_freq(divr, divf, 0);
@@ -241,6 +259,7 @@ static inline uint64_t ddr_pll_freq(int node)
 static inline uint64_t soc_dfs_val(int node, soc_device_id_t device)
 {
 	uint8_t device_index = device;
+	NLM_HALT_IF_XLPII();
 	if (device_index >= 8)
 	{
 		device_index -= 8;
@@ -255,6 +274,7 @@ static inline uint64_t soc_dfs_val(int node, soc_device_id_t device)
  */
 static inline uint64_t core_dfs_val(int node, uint8_t core)
 {
+	NLM_HALT_IF_XLPII();
 	return (nlm_hal_read_sys_reg(node, CORE_DFS_DIV_VALUE) >> (core * 4)) & 0xF; 
 }
 
@@ -267,6 +287,7 @@ static inline uint64_t core_dfs_val(int node, uint8_t core)
 static inline uint8_t is_soc_dfs_bypassed(int node, soc_device_id_t device)
 {
 	uint8_t device_index = device;
+	NLM_HALT_IF_XLPII();
 	return (nlm_hal_read_sys_reg(node, SYS_DFS_BYP_CTRL) >> device_index) & 1;
 }
 
@@ -279,6 +300,7 @@ static inline void set_soc_dfs_bypass(int node, soc_device_id_t device, uint8_t
 {
 	uint8_t device_index = device;
 	uint32_t val;
+	NLM_HALT_IF_XLPII();
 	val = nlm_hal_read_sys_reg(node, SYS_DFS_BYP_CTRL) & ~(1 << device_index);
 	nlm_hal_write_sys_reg(node, SYS_DFS_BYP_CTRL, val | ((bypass? 0x1 : 0x0) << device_index));
 }
@@ -291,6 +313,7 @@ static inline void set_soc_dfs_bypass(int node, soc_device_id_t device, uint8_t
  */
 static inline uint8_t is_core_dfs_bypassed(int node, uint8_t core)
 {
+	NLM_HALT_IF_XLPII();
 	return (nlm_hal_read_sys_reg(node, CORE_DFS_BYP_CTRL) >> core) & 1;
 }
 
@@ -301,7 +324,9 @@ static inline uint8_t is_core_dfs_bypassed(int node, uint8_t core)
  */
 static inline void set_core_dfs_bypass(int node, uint8_t core, uint8_t bypass)
 {
-	uint32_t val = nlm_hal_read_sys_reg(node, CORE_DFS_BYP_CTRL) & ~(1 << core);
+	uint32_t val;
+	NLM_HALT_IF_XLPII();
+	val = nlm_hal_read_sys_reg(node, CORE_DFS_BYP_CTRL) & ~(1 << core);
 	nlm_hal_write_sys_reg(node, CORE_DFS_BYP_CTRL, val | ((bypass? 0x1 : 0x0) << core));
 }
 
@@ -312,35 +337,37 @@ static inline void set_core_dfs_bypass(int node, uint8_t core, uint8_t bypass)
  */
 uint64_t nlm_hal_get_soc_freq(int node, soc_device_id_t device)
 {
-	uint64_t reference, den;
+	uint64_t freq, den;
+
+	if(is_nlm_xlp2xx()) {
+		freq = nlm_hal_xlp2xx_get_clkdev_frq(node, device);
+		return freq;
+	}
+
 	switch (device) {
 		case DFS_DEVICE_NAND:
 		case DFS_DEVICE_NOR:
 		case DFS_DEVICE_MMC:
-			/* NOR, NAND and MMC devices are derived from the reference clock. */
-			reference = ref_clk_freq();
+			/* NOR, NAND and MMC devices are derived from the freq clock. */
+			freq = nlm_hal_get_ref_clk_freq();
 			break;
 		case DFS_DEVICE_DMC:
-			reference = ddr_pll_freq(node);
+			freq = ddr_pll_freq(node);
 			break;
 		case DFS_DEVICE_CORE:
 			/* The Core DFS is derived from the Core PLL */
-			reference = core_pll_freq(node);
+			freq = core_pll_freq(node);
 			break;
 		default:
-			reference = soc_pll_freq(node);
+			freq = soc_pll_freq(node);
 			break;
 	}
 
-    den = soc_dfs_val(node, device) + 1;
-	if (!is_soc_dfs_bypassed(node, device))
-#ifdef NLM_HAL_LINUX_KERNEL
-        do_div(reference, den);
-#else
-        reference /= den;
-#endif
-
-	return reference;
+	den = soc_dfs_val(node, device) + 1;
+	if (!is_soc_dfs_bypassed(node, device)) {
+		NLM_HAL_DO_DIV(freq, den);
+	}
+	return freq;
 }
 
 /**
@@ -350,9 +377,14 @@ uint64_t nlm_hal_get_soc_freq(int node, soc_device_id_t device)
  */
 static void step_soc_dfs(int node, soc_device_id_t device, uint8_t dfs_index)
 {
-	uint8_t device_index = device;
-	uint8_t cur = closest_dfs_index(soc_dfs_val(node, device));
-	int8_t delta = cur - dfs_index;
+	uint8_t device_index;
+	uint8_t cur;
+	int8_t delta;
+
+	NLM_HALT_IF_XLPII();
+	device_index = device;
+	cur = closest_dfs_index(soc_dfs_val(node, device));
+	delta = cur - dfs_index;
 	int i;
 
 	if (delta >= 0) {
@@ -377,12 +409,16 @@ uint64_t nlm_hal_set_soc_freq(int node, soc_device_id_t device, uint64_t freq)
 {
 	uint64_t reference;
 	uint8_t  target;
+
+	if(is_nlm_xlp2xx()) {
+		return nlm_hal_xlp2xx_set_clkdev_frq(node, device, freq);
+	}
 	switch (device) {
 		case DFS_DEVICE_NAND:
 		case DFS_DEVICE_NOR:
 		case DFS_DEVICE_MMC:
 			/* NOR, NAND and MMC devices are derived from the reference clock. */
-			reference = ref_clk_freq();
+			reference = nlm_hal_get_ref_clk_freq();
 			break;
 		case DFS_DEVICE_DMC:
 			reference = ddr_pll_freq(node);
@@ -416,17 +452,16 @@ uint64_t nlm_hal_set_soc_freq(int node, soc_device_id_t device, uint64_t freq)
  */
 uint64_t nlm_hal_get_core_freq(int node, uint8_t core)
 {
-	uint64_t den, reference = core_pll_freq(node);
-    
-    den = core_dfs_val(node, core) + 1;
-	if (!is_core_dfs_bypassed(node, core))
-#ifdef NLM_HAL_LINUX_KERNEL
-	    do_div(reference, den);
-#else
-        reference /= den;
-#endif
-
-	return reference;
+	if(is_nlm_xlp2xx()) {
+		return nlm_hal_xlp2xx_get_pllfreq_dyn(node, core);
+	}
+	else {
+		uint64_t den, reference = core_pll_freq(node);
+		den = core_dfs_val(node, core) + 1;
+		if (!is_core_dfs_bypassed(node, core))
+		    NLM_HAL_DO_DIV(reference, den);
+		return reference;
+	}
 }
 
 /**
@@ -436,10 +471,14 @@ uint64_t nlm_hal_get_core_freq(int node, uint8_t core)
  */
 static void step_core_dfs(int node, uint8_t core, uint8_t dfs_index)
 {
-	uint8_t cur = closest_dfs_index(core_dfs_val(node, core));
-	int8_t delta = cur - dfs_index;
-
+	uint8_t cur;
+	int8_t delta;
 	int i;
+
+	NLM_HALT_IF_XLPII();
+	cur = closest_dfs_index(core_dfs_val(node, core));
+	delta = cur - dfs_index;
+
 	if (delta >= 0) {
 		/* positive delta, decrement dfs */
 		for (i=0; i < delta; i++)
@@ -460,19 +499,23 @@ static void step_core_dfs(int node, uint8_t core, uint8_t dfs_index)
  */
 uint64_t nlm_hal_set_core_freq(int node, uint8_t core, uint64_t freq)
 {
-	uint64_t reference = core_pll_freq(node);
-	uint8_t target = closest_dfs_index(fuzzy_divider(reference, freq) - 1);
-
-	if (freq >= (reference - FREQ_RESOLUTION)) {
-		/* bypass DFS if freq is reference freq */
-		set_core_dfs_bypass(node, core, 1);
-	} else {
-		/* otherwise, step dfs and clear bypass */
-		step_core_dfs(node, core, target);
-		set_core_dfs_bypass(node, core, 0);
+	if(is_nlm_xlp2xx()) {
+		return nlm_hal_xlp2xx_set_pllfreq_dyn(node, core, freq);
 	}
+	else {
+		uint64_t reference = core_pll_freq(node);
+		uint8_t target = closest_dfs_index(fuzzy_divider(reference, freq) - 1);
 
-	return nlm_hal_get_core_freq(node, core);
+		if (freq >= (reference - FREQ_RESOLUTION)) {
+			/* bypass DFS if freq is reference freq */
+			set_core_dfs_bypass(node, core, 1);
+		} else {
+			/* otherwise, step dfs and clear bypass */
+			step_core_dfs(node, core, target);
+			set_core_dfs_bypass(node, core, 0);
+		}
+		return nlm_hal_get_core_freq(node, core);
+	}
 }
 
 /**
@@ -485,30 +528,485 @@ unsigned long long nlm_hal_cpu_freq(void)
 	return nlm_hal_get_core_freq(nlm_node_id(), core);
 }
 
+uint32_t nlm_hal_get_biu_mask_by_soc_device_id(soc_device_id_t device)
+{
+	int biu_mask=0;
+	switch(device) {
+        case XLP2XX_CLKDEVICE_NAE    : biu_mask =
+		 (1<<XLP2XX_IO_NET_BIU_NUMBER)|(1<<XLP2XX_IO_MSG_BIU_NUMBER)|(1<<XLP2XX_IO_POE_BIU_NUMBER); break;
+        case XLP2XX_CLKDEVICE_SAE    : biu_mask = (1<<XLP2XX_IO_SEC_BIU_NUMBER); break;
+        case XLP2XX_CLKDEVICE_RSA    : biu_mask = (1<<XLP2XX_IO_RSA_BIU_NUMBER); break;
+        case XLP2XX_CLKDEVICE_GDX    : biu_mask = (1<<XLP2XX_IO_GDX_BIU_NUMBER); break;
+        case XLP2XX_CLKDEVICE_CMP    : biu_mask = (1<<XLP2XX_IO_CMP_BIU_NUMBER); break;
+        case XLP2XX_CLKDEVICE_NAND   : biu_mask = (1<<XLP2XX_IO_GBU_BIU_NUMBER); break;
+        case XLP2XX_CLKDEVICE_MMC    : biu_mask = (1<<XLP2XX_IO_GBU_BIU_NUMBER); break;
+        case XLP2XX_CLKDEVICE_GBU    : biu_mask = (1<<XLP2XX_IO_GBU_BIU_NUMBER); break;
+        case XLP2XX_CLKDEVICE_RGXF   : biu_mask = (1<<XLP2XX_IO_REGX_BIU_NUMBER); break;
+        case XLP2XX_CLKDEVICE_RGXS   : biu_mask = (1<<XLP2XX_IO_REGX_BIU_NUMBER); break;
+        case XLP2XX_CLKDEVICE_USB    : biu_mask = (1<<XLP2XX_IO_USB_BIU_NUMBER); break;
+        case XLP2XX_CLKDEVICE_PIC    : biu_mask = (1<<XLP2XX_IO_PIC_BIU_NUMBER); break;
+		default: break;
+	}
+	return biu_mask;
+}
+
 uint8_t nlm_hal_get_soc_clock_state(int node, soc_device_id_t device)
 {
-	return nlm_hal_read_sys_reg(node, SYS_DFS_DIS_CTRL) >> device;
+	uint32_t biu_mask=0;
+	if(is_nlm_xlp2xx()) {
+		biu_mask = nlm_hal_get_biu_mask_by_soc_device_id(device);
+		return (nlm_hal_read_sys_reg(node, XLP2XX_SYSDISABLE) & biu_mask) ?  XLP_DISABLE : XLP_ENABLE;
+	} else {
+		return (nlm_hal_read_sys_reg(node, SYS_DFS_DIS_CTRL) >> device);
+	}
 }
 
 void nlm_hal_soc_clock_enable(int node, soc_device_id_t device)
 {
-	uint32_t d32 = nlm_hal_read_sys_reg(node, SYS_DFS_DIS_CTRL);
-	d32 &= ~(1<<device);
-	nlm_hal_write_sys_reg(node, SYS_DFS_DIS_CTRL, d32);
+	uint32_t d32;
+	uint32_t biu_mask=0;
+	if(is_nlm_xlp2xx()) {
+		biu_mask = nlm_hal_get_biu_mask_by_soc_device_id(device);
+		biu_mask = (nlm_hal_read_sys_reg(node, XLP2XX_SYSDISABLE) & ~biu_mask);
+		nlm_hal_write_sys_reg(node, XLP2XX_SYSDISABLE, biu_mask);
+	} else {
+		d32 = nlm_hal_read_sys_reg(node, SYS_DFS_DIS_CTRL);
+		d32 &= ~(1<<device);
+		nlm_hal_write_sys_reg(node, SYS_DFS_DIS_CTRL, d32);
+	}
 }
 
 void nlm_hal_soc_clock_disable(int node, soc_device_id_t device)
 {
-	uint32_t d32 = nlm_hal_read_sys_reg(node, SYS_DFS_DIS_CTRL);
-	d32 |= (1<<device);
-	nlm_hal_write_sys_reg(node, SYS_DFS_DIS_CTRL, d32);
+	uint32_t d32;
+	uint32_t biu_mask=0;
+	if(is_nlm_xlp2xx()) {
+		biu_mask = nlm_hal_get_biu_mask_by_soc_device_id(device);
+		biu_mask |= nlm_hal_read_sys_reg(node, XLP2XX_SYSDISABLE);
+		nlm_hal_write_sys_reg(node, XLP2XX_SYSDISABLE, biu_mask);
+	} else {
+		d32 = nlm_hal_read_sys_reg(node, SYS_DFS_DIS_CTRL);
+		d32 |= (1<<device);
+		nlm_hal_write_sys_reg(node, SYS_DFS_DIS_CTRL, d32);
+	}
 }
 
 void nlm_hal_soc_clock_reset(int node, soc_device_id_t device)
 {
-	nlm_hal_write_sys_reg(node, SYS_DFS_RST_CTRL, 1 << device);
+	uint32_t biu_mask=0;
+	if(is_nlm_xlp2xx()) {
+		biu_mask = nlm_hal_get_biu_mask_by_soc_device_id(device);
+		nlm_hal_write_sys_reg(node, XLP2XX_SYSRESET, biu_mask);
+	} else {
+		nlm_hal_write_sys_reg(node, SYS_DFS_RST_CTRL, 1 << device);
+	}
+}
+
+/*
+ * XLP 2XX Clock Management
+ */
+/*  Reference Clock Select 00:66; 01:100; 10:125; 11:133 */
+#define SYS_PWRON_RCS(x) (((x)>>18) & 0x3)
+
+#define SYS_PWRON_PLF(x) (((x)>>17) & 0x1)
+
+static int xlp2xx_get_plf(int node)
+{
+	uint32_t reg = nlm_hal_read_sys_reg(node, XLP2XX_POWER_ON_RESET_CFG);
+	int plf = SYS_PWRON_PLF(reg);
+	return plf;
+}
+
+static int xlp2xx_get_rcs(int node)
+{
+	uint32_t reg = nlm_hal_read_sys_reg(node, XLP2XX_POWER_ON_RESET_CFG);
+	int rcs = SYS_PWRON_RCS(reg);
+	return rcs;
+}
+
+static void nlm_hal_xlp2xx_dev_pll_cfg(int node, soc_device_id_t dev_type, int dev_pll_sel, int div)
+{
+	int dev_idx = dev_type - XLP2XX_CLKDEVICE_NAE;
+	uint32_t rsel, rdiv, rchg;
+	NLM_HALT_IF(dev_idx<0);
+	rsel = nlm_hal_read_sys_reg(node, XLP2XX_SYS_CLK_DEV_SEL_REG) & (~(3<<(dev_idx*2)));
+	rdiv = nlm_hal_read_sys_reg(node, XLP2XX_SYS_CLK_DEV_DIV_REG) & (~(3<<(dev_idx*2)));
+	nlm_hal_write_sys_reg(node, XLP2XX_SYS_CLK_DEV_SEL, rsel | ((dev_pll_sel&3) << (dev_idx*2)));
+	nlm_hal_write_sys_reg(node, XLP2XX_SYS_CLK_DEV_DIV, rdiv | ((div&3)<<(dev_idx*2)));
+	rsel = nlm_hal_read_sys_reg(node, XLP2XX_SYS_CLK_DEV_SEL_REG);
+	rdiv = nlm_hal_read_sys_reg(node, XLP2XX_SYS_CLK_DEV_DIV_REG);
+	rchg = nlm_hal_read_sys_reg(node, XLP2XX_SYS_CLK_DEV_CHG);
+	nlm_hal_write_sys_reg(node, XLP2XX_SYS_CLK_DEV_CHG, rchg|(1<<dev_idx));
+	while((nlm_hal_read_sys_reg(node, XLP2XX_SYS_CLK_DEV_CHG) & (1<<dev_idx)));
+	return;
+}
+
+/*
+ * SYS_CLK_DEV_SEL
+ *  00  400MHz
+ *  01  Dev0 PLL
+ *  10  Dev1 PLL
+ *  11  Dev2 PLL
+ */
+static inline xlp2xx_clkdev_sel_t xlp2xx_get_clk_dev_sel(int node, soc_device_id_t dev_type)
+{
+	int dev_idx = dev_type - XLP2XX_CLKDEVICE_NAE;
+	NLM_HALT_IF(dev_idx<0);
+	return ( nlm_hal_read_sys_reg(node, XLP2XX_SYS_CLK_DEV_SEL_REG) >> (dev_idx*2) ) & 0x3 ;
+}	
+
+/*
+ * SYS_CLK_DEV_DIV
+ * 00  1
+ * 01  2
+ * 10  4
+ * 11  8
+ */
+static inline uint8_t xlp2xx_get_clkdev_div(int node, soc_device_id_t dev_type)
+{
+	int dev_idx = dev_type - XLP2XX_CLKDEVICE_NAE;
+	NLM_HALT_IF(dev_idx<0);
+	return  1<< (( nlm_hal_read_sys_reg(node, XLP2XX_SYS_CLK_DEV_DIV_REG) >> (dev_idx*2) ) & 0x3);
+}	
+
+uint64_t nlm_hal_xlp2xx_get_pllfreq_dyn(int node, uint8_t pll_type)
+{
+        uint32_t pll_mult = 0; // [5:0]
+        uint64_t ref_clk_num;
+	uint32_t ref_clk_den;
+        uint32_t reg_ctrl;
+	int plf = xlp2xx_get_plf(node)+1;
+        switch(pll_type)
+        {
+                case CORE0_PLL:
+                case CORE1_PLL:
+                        reg_ctrl = XLP2XX_CORE0_PLL_CTRL1+pll_type*4;
+                break;
+                case SYS_PLL:
+                case DMC_PLL:
+                case DEV0_PLL:
+                case DEV1_PLL:
+                case DEV2_PLL:
+                        reg_ctrl = XLP2XX_SYS_PLL_CTRL1+(pll_type-SYS_PLL)*4;
+                break;
+                default:
+                        nlm_print("Unknown PLL type:%d\n", pll_type);
+                        return 0;
+        }
+        pll_mult = nlm_hal_read_sys_reg(node, reg_ctrl) & (0x3f);
+        ref_clk_num =  (REF_CLK_NUM_100 * pll_mult);
+        ref_clk_den = REF_CLK_DEN;
+        NLM_HAL_DO_DIV(ref_clk_num, ref_clk_den);
+        ref_clk_num +=  REF_CLK_NUM_400;
+
+        if(pll_type != DMC_PLL) {
+		NLM_HAL_DO_DIV(ref_clk_num, plf);
+	}
+
+        return ref_clk_num;
+}
+
+uint64_t nlm_hal_xlp2xx_set_pllfreq_dyn(int node, uint8_t pll_type, uint64_t freq)
+{
+        /*Target PLL output frequency; 400 MHz + (33.333 MHz x [5:0]).*/
+	uint32_t pll_mult = 0; // [5:0]
+	uint64_t clk_base_freq_num = 100*1000000;
+	uint32_t clk_base_freq_den = 3;
+	uint32_t reg_ctrl,reg_chg,chg_mask;
+	int plf = xlp2xx_get_plf(node)+1;
+
+	if(pll_type!=DMC_PLL)
+		freq*=plf;
+
+	if(freq<400*1000000){
+	        nlm_print("Freq for PLL cant be less than 400 Mhz\n");
+	        return 0;
+	}
+	freq = clk_base_freq_den * (freq - 400*1000000);
+	NLM_HAL_DO_DIV(freq, clk_base_freq_num);
+	pll_mult = freq;
+        switch(pll_type)
+        {
+                case CORE0_PLL:
+                case CORE1_PLL:
+                        reg_ctrl = XLP2XX_CORE0_PLL_CTRL1+pll_type*4;
+                        reg_chg  = XLP2XX_CPU_PLL_CHG_CTRL;
+                        chg_mask = 1<<(pll_type-CORE0_PLL);
+                break;
+                case SYS_PLL:
+                case DMC_PLL:
+                case DEV0_PLL:
+                case DEV1_PLL:
+                case DEV2_PLL:
+                        reg_ctrl = XLP2XX_SYS_PLL_CTRL1+(pll_type-SYS_PLL)*4;
+                        reg_chg  = XLP2XX_SYS_PLL_CHG_CTRL;
+                        chg_mask = 1<<(pll_type-SYS_PLL);
+                break;
+                default:
+                        nlm_print("Unknown PLL type:%d\n", pll_type);
+                        return 0;
+        }
+
+        nlm_hal_write_sys_reg(node, reg_ctrl, pll_mult);
+        nlm_hal_write_sys_reg(node, reg_chg,  chg_mask);
+        while(nlm_hal_read_sys_reg(node, reg_chg) & chg_mask);
+
+	//freq = nlm_hal_xlp2xx_get_pll_out_frq(node, pll_type);
+	//nlm_print("pll out freq:%dMHz\n", (uint32_t)freq/1000000);
+
+	freq = nlm_hal_xlp2xx_get_pllfreq_dyn(node, pll_type);
+	return freq;
+}
+
+uint64_t xlp2xx_get_ref_clk(int node, uint64_t* ref_clk_num, uint32_t* ref_clk_den)
+{
+	uint64_t frq_num;
+	uint32_t frq_den;
+	uint32_t rcs = xlp2xx_get_rcs(node);
+	switch(rcs) {
+		case 0x0:
+			frq_num = REF_CLK_NUM_200;
+			frq_den = REF_CLK_DEN3;
+		break;	
+		case 0x1:
+			frq_num = REF_CLK_NUM_100;
+			frq_den = REF_CLK_DEN1;
+		break;	
+		case 0x2:
+			frq_num = REF_CLK_NUM_125;
+			frq_den = REF_CLK_DEN1;
+		break;	
+		case 0x3:
+		default:
+			frq_num = REF_CLK_NUM_400;
+			frq_den = REF_CLK_DEN3;
+		break;	
+	}
+	*ref_clk_num = frq_num;
+	*ref_clk_den = frq_den;
+	NLM_HAL_DO_DIV(frq_num, frq_den);
+	return frq_num;	
+}
+
+/* freq_out = ( ref_freq/2 * (6 + ctrl2[7:0]) + ctrl2[20:8]/2^13 ) / ((2^ctrl0[7:5]) * Table(ctrl0[26:24]))
+ * Table.ctrl0[26:24]
+ * ------------------
+ *  0: 1
+ *  1: 2
+ *  3: 4
+ *  7: 8
+ *  6: 16
+ */
+uint64_t nlm_hal_xlp2xx_get_pll_out_frq(int node, uint8_t pll_type)
+{
+	uint32_t vco_po_div, pll_post_div, fdiv, mdiv;
+	uint64_t ref_frq_num, pll_out_freq_num, two13;
+	uint32_t ref_frq_den, pll_out_freq_den;
+        uint32_t reg_ctrl0, reg_ctrl2;
+        uint32_t ctrl0, ctrl2;
+	
+        switch(pll_type)
+        {
+                case CORE0_PLL:
+                case CORE1_PLL:
+                        reg_ctrl0 = XLP2XX_CORE0_PLL_CTRL0+pll_type*4;
+                        reg_ctrl2 = XLP2XX_CORE0_PLL_CTRL2+pll_type*4;
+                break;
+                case SYS_PLL:
+                case DMC_PLL:
+                case DEV0_PLL:
+                case DEV1_PLL:
+                case DEV2_PLL:
+                        reg_ctrl0 = XLP2XX_SYS_PLL_CTRL0+(pll_type-SYS_PLL)*4;
+                        reg_ctrl2 = XLP2XX_SYS_PLL_CTRL2+(pll_type-SYS_PLL)*4;
+                break;
+                default:
+                        nlm_print("Unknown PLL type:%d\n", pll_type);
+                        return 0;
+        }
+
+	xlp2xx_get_ref_clk(node, &ref_frq_num, &ref_frq_den);
+	ctrl0 = nlm_hal_read_sys_reg(node, reg_ctrl0);
+	ctrl2 = nlm_hal_read_sys_reg(node, reg_ctrl2);
+
+	vco_po_div = (ctrl0>>5) & 0x7;
+	pll_post_div = (ctrl0>>24) & 0x7;
+	mdiv = ctrl2 & 0xff;
+	fdiv = (ctrl2>>8) & 0xfff;
+
+	switch(pll_post_div) {
+	    case 1: pll_post_div=2; break;
+	    case 3: pll_post_div=4; break;
+	    case 7: pll_post_div=8; break;
+	    case 6: pll_post_div=16; break;
+	    case 0:
+	    default: 
+		    pll_post_div=1;
+		    break;
+	}
+
+	two13 = 1<<13;
+	NLM_HAL_DO_DIV(fdiv, two13);
+	pll_out_freq_num = ((ref_frq_num>>1) * (6 + mdiv) ) + fdiv;
+	pll_out_freq_den = (1<<vco_po_div) * pll_post_div * ref_frq_den;
+
+	if(pll_out_freq_den>0) {
+		NLM_HAL_DO_DIV(pll_out_freq_num, pll_out_freq_den);
+	}
+	return pll_out_freq_num;
+}
+
+uint64_t nlm_hal_xlp2xx_get_clkdev_frq(int node, soc_device_id_t dev_type)
+{
+	uint64_t frq = 0, ref_clk_num;
+	uint32_t ref_clk_den;
+	uint8_t div = xlp2xx_get_clkdev_div(node, dev_type);
+	xlp2xx_clkdev_sel_t pll_sel = xlp2xx_get_clk_dev_sel(node, dev_type);
+
+	switch(pll_sel)
+	{
+		case SEL_REF_CLK:
+			frq = xlp2xx_get_ref_clk(node, &ref_clk_num, &ref_clk_den);
+		break;
+		case SEL_DEV0PLL:
+			frq = nlm_hal_xlp2xx_get_pllfreq_dyn(node, DEV0_PLL);
+		break;
+		case SEL_DEV1PLL:
+			frq = nlm_hal_xlp2xx_get_pllfreq_dyn(node, DEV1_PLL);
+		break;
+		case SEL_DEV2PLL:
+			frq = nlm_hal_xlp2xx_get_pllfreq_dyn(node, DEV2_PLL);
+		break;
+		default:
+		break;
+	}
+	NLM_HAL_DO_DIV(frq, div);
+	return frq;
+}
+
+uint64_t nlm_hal_xlp2xx_set_clkdev_frq(int node, soc_device_id_t dev_type, uint64_t new_frq)
+{
+	uint64_t frq;
+	uint8_t new_div, div;
+	xlp2xx_clkdev_sel_t pll_sel;
+
+	pll_sel = xlp2xx_get_clk_dev_sel(node, dev_type);
+	div = xlp2xx_get_clkdev_div(node, dev_type);
+	frq = nlm_hal_xlp2xx_get_clkdev_frq(node, dev_type);
+
+	/* new_frq*new_div=frq*div
+	 *  new_div = frq*div/new_frq;
+	 */
+	new_div = fuzzy_divider(frq*div, new_frq);
+	switch (new_div)
+	{
+		case 1:
+			nlm_hal_xlp2xx_dev_pll_cfg(node, dev_type, pll_sel, DIV_BYPASS);
+		break;
+		case 2:
+			nlm_hal_xlp2xx_dev_pll_cfg(node, dev_type, pll_sel, DIV_DIV2);
+		break;
+		case 4:
+			nlm_hal_xlp2xx_dev_pll_cfg(node, dev_type, pll_sel, DIV_DIV4);
+		break;
+		case 8:
+			nlm_hal_xlp2xx_dev_pll_cfg(node, dev_type, pll_sel, DIV_DIV8);
+		break;
+		default:
+		break;
+	}
+	frq = nlm_hal_xlp2xx_get_clkdev_frq(node, dev_type);
+	return frq;
+}
+
+/**
+ * @returns true if reference clock is 133MHz
+ */
+int nlm_hal_is_ref_clk_133MHz(void)
+{
+	if(is_nlm_xlp2xx())
+		return 3 == xlp2xx_get_rcs(0);
+	else {
+		uint32_t reg = nlm_hal_read_sys_reg(0, POWER_ON_RESET_CFG);
+		uint8_t divr = (reg >> 8) & 0x3;
+		return  (divr==3);
+	}
+}
+
+const char* nlm_hal_xlp2xx_get_dev_name(soc_device_id_t dev) {
+	static char* name[] = {
+	"NAE",
+	"SAE",
+	"RSA",
+	"GDX",
+	"CMP",
+	"NAND",
+	"MMC",
+	"GBU",
+	"RGXF",
+	"RGXS",
+	"USB",
+	"PIC",
+	"NULL"
+	};
+	if(! ((dev>=XLP2XX_CLKDEVICE_NAE)&&(dev<=XLP2XX_CLKDEVICE_PIC)))
+	{
+		dev = XLP2XX_CLKDEVICE_NULL;
+	}
+	return name[dev-XLP2XX_CLKDEVICE_NAE];
 }
 
+
+xlp2xx_soc_freq_s xlp2xx_tbl_freq[2] = {
+	/* slow freq for low voltage*/
+      { .nae = 250,
+	.sae = 250,
+	.rsa = 250,
+	.gdx = 333,
+	.cmp = 333,
+	.nand = 133,
+	.mmc = 133,
+	.gbu = 133,
+	.rgxf = 250,
+	.rgxs = 200,
+	.usb = 167,
+	.pic = 200 },
+	/* high freq */
+      { .nae = 500,
+	.sae = 500,
+	.rsa = 500,
+	.gdx = 667,
+	.cmp = 667,
+	.nand = 133,
+	.mmc = 133,
+	.gbu = 133,
+	.rgxf = 500,
+	.rgxs = 450,
+	.usb = 167,
+	.pic = 400 },
+};
+
+void nlm_hal_adjust_soc_freqs(int node, int freq_sel)
+{
+	if(is_nlm_xlp2xx()) {
+	xlp2xx_soc_freq_s* freq;
+	freq = &xlp2xx_tbl_freq[freq_sel&0x1];
+        nlm_hal_set_soc_freq(node, XLP2XX_CLKDEVICE_NAE, freq->nae*1000000);
+        nlm_hal_set_soc_freq(node, XLP2XX_CLKDEVICE_SAE, freq->sae*1000000);
+        nlm_hal_set_soc_freq(node, XLP2XX_CLKDEVICE_RSA, freq->rsa*1000000);
+        nlm_hal_set_soc_freq(node, XLP2XX_CLKDEVICE_GDX, freq->gdx*1000000);
+        nlm_hal_set_soc_freq(node, XLP2XX_CLKDEVICE_CMP, freq->cmp*1000000);
+        nlm_hal_set_soc_freq(node, XLP2XX_CLKDEVICE_NAND, freq->nand*1000000);
+        nlm_hal_set_soc_freq(node, XLP2XX_CLKDEVICE_MMC, freq->mmc*1000000);
+        nlm_hal_set_soc_freq(node, XLP2XX_CLKDEVICE_GBU, freq->gbu*1000000);
+        nlm_hal_set_soc_freq(node, XLP2XX_CLKDEVICE_RGXF, freq->rgxf*1000000);
+        nlm_hal_set_soc_freq(node, XLP2XX_CLKDEVICE_RGXS, freq->rgxs*1000000);
+        nlm_hal_set_soc_freq(node, XLP2XX_CLKDEVICE_USB, freq->usb*1000000);
+        nlm_hal_set_soc_freq(node, XLP2XX_CLKDEVICE_PIC, freq->pic*1000000);
+	}
+}
+
+
 #ifdef NLM_HAL_LINUX_KERNEL
 #include <linux/types.h>
 #include <linux/module.h>
@@ -516,9 +1014,17 @@ EXPORT_SYMBOL(nlm_hal_get_soc_clock_state);
 EXPORT_SYMBOL(nlm_hal_soc_clock_enable);
 EXPORT_SYMBOL(nlm_hal_soc_clock_disable);
 EXPORT_SYMBOL(nlm_hal_soc_clock_reset);
+EXPORT_SYMBOL(nlm_hal_xlp2xx_set_clkdev_frq);
+EXPORT_SYMBOL(nlm_hal_xlp2xx_get_clkdev_frq);
+EXPORT_SYMBOL(nlm_hal_xlp2xx_get_pll_out_frq);
+EXPORT_SYMBOL(nlm_hal_xlp2xx_get_dev_name);
 EXPORT_SYMBOL(nlm_hal_get_soc_freq);
 EXPORT_SYMBOL(nlm_hal_set_soc_freq);
 EXPORT_SYMBOL(nlm_hal_get_core_freq);
 EXPORT_SYMBOL(nlm_hal_set_core_freq);
 EXPORT_SYMBOL(nlm_hal_cpu_freq);
+EXPORT_SYMBOL(nlm_hal_is_ref_clk_133MHz);
+EXPORT_SYMBOL(nlm_hal_get_ref_clk_freq);
+EXPORT_SYMBOL(nlm_hal_adjust_soc_freqs);
+
 #endif
diff --git a/arch/mips/netlogic/common/nlm_hal_vsemi_config.c b/arch/mips/netlogic/common/nlm_hal_vsemi_config.c
new file mode 100644
index 0000000..545809e
--- /dev/null
+++ b/arch/mips/netlogic/common/nlm_hal_vsemi_config.c
@@ -0,0 +1,695 @@
+#include "nlm_hal_vsemi_data.h"
+
+unsigned char vsemi_mem_sgmii_4page [256];
+unsigned char vsemi_mem_sgmii [256];
+
+unsigned char vsemi_mem_xaui_4page [256];
+unsigned char vsemi_mem_xaui [256];
+
+unsigned char vsemi_mem_12G_4page [256];
+unsigned char vsemi_mem_12G [256];
+unsigned char vsemi_mem_16G_4page [256];
+unsigned char vsemi_mem_16G [256];
+
+void nlm_hal_config_vsemi_mem_16G_4page(void)
+{
+
+	vsemi_mem_16G_4page[101] = 0xB7;
+	vsemi_mem_16G_4page[102] = 0xB7;
+	vsemi_mem_16G_4page[103] = 0xC;
+	vsemi_mem_16G_4page[104] = 0xC;
+	vsemi_mem_16G_4page[105] = 0x1A;
+	vsemi_mem_16G_4page[106] = 0x1A;
+	vsemi_mem_16G_4page[107] = 0x2;
+	vsemi_mem_16G_4page[108] = 0x2;
+	vsemi_mem_16G_4page[109] = 0x11;
+	vsemi_mem_16G_4page[110] = 0x0;
+	
+	return;
+}
+
+void nlm_hal_config_vsemi_mem_16G_4page_125(void)
+{
+	vsemi_mem_16G_4page[101] = 0xBF;
+	vsemi_mem_16G_4page[102] = 0xBF;
+	vsemi_mem_16G_4page[103] = 0xA;
+	vsemi_mem_16G_4page[104] = 0xA;
+	vsemi_mem_16G_4page[105] = 0xE;
+	vsemi_mem_16G_4page[106] = 0xE;
+	vsemi_mem_16G_4page[107] = 0x1;
+	vsemi_mem_16G_4page[108] = 0x1;
+	vsemi_mem_16G_4page[109] = 0x11;
+	vsemi_mem_16G_4page[110] = 0x0;
+
+	return;
+}
+
+
+void nlm_hal_config_vsemi_mem_16G(void)
+{
+	
+	vsemi_mem_16G[101] = 0x99;
+	vsemi_mem_16G[102] = 0x0;
+	vsemi_mem_16G[103] = 0x76;
+	vsemi_mem_16G[104] = 0xB7;
+	vsemi_mem_16G[105] = 0xB7;
+	vsemi_mem_16G[106] = 0xC;
+	vsemi_mem_16G[107] = 0xC;
+	vsemi_mem_16G[108] = 0x1A;
+	vsemi_mem_16G[109] = 0x1A;
+	vsemi_mem_16G[110] = 0x6;
+	vsemi_mem_16G[111] = 0x16;
+	vsemi_mem_16G[112] = 0x8;
+	vsemi_mem_16G[113] = 0x0;
+	vsemi_mem_16G[114] = 0x8;
+	vsemi_mem_16G[115] = 0x0;
+	vsemi_mem_16G[116] = 0xFF;
+	vsemi_mem_16G[117] = 0xB3;
+	vsemi_mem_16G[118] = 0xF6;
+	vsemi_mem_16G[119] = 0xD0;
+	vsemi_mem_16G[120] = 0xEF;
+	vsemi_mem_16G[121] = 0xFB;
+	vsemi_mem_16G[122] = 0xFF;
+	vsemi_mem_16G[123] = 0xFF;
+	vsemi_mem_16G[124] = 0xFF;
+	vsemi_mem_16G[125] = 0xFF;
+	vsemi_mem_16G[126] = 0xFF;
+	vsemi_mem_16G[127] = 0xD3;
+	vsemi_mem_16G[128] = 0xD3;
+	vsemi_mem_16G[129] = 0xE2;
+	vsemi_mem_16G[130] = 0xEF;
+	vsemi_mem_16G[131] = 0xFB;
+	vsemi_mem_16G[132] = 0xFB;
+	vsemi_mem_16G[133] = 0xFF;
+	vsemi_mem_16G[134] = 0xEF;
+	vsemi_mem_16G[135] = 0xFF;
+	vsemi_mem_16G[136] = 0xFF;
+	vsemi_mem_16G[137] = 0xD3;
+	vsemi_mem_16G[138] = 0xD3;
+	vsemi_mem_16G[139] = 0xE2;
+	vsemi_mem_16G[140] = 0xEF;
+	vsemi_mem_16G[141] = 0xFB;
+	vsemi_mem_16G[142] = 0xFB;
+	vsemi_mem_16G[143] = 0xFF;
+	vsemi_mem_16G[144] = 0xEF;
+	vsemi_mem_16G[145] = 0xFF;
+	vsemi_mem_16G[146] = 0xFF;
+	vsemi_mem_16G[147] = 0xFB;
+	vsemi_mem_16G[148] = 0xFF;
+	vsemi_mem_16G[149] = 0x3F;
+	vsemi_mem_16G[150] = 0x0;
+	vsemi_mem_16G[151] = 0x64;
+	vsemi_mem_16G[152] = 0x0;
+	vsemi_mem_16G[153] = 0x4;
+	vsemi_mem_16G[154] = 0x2;
+	vsemi_mem_16G[155] = 0x5;
+	vsemi_mem_16G[156] = 0x5;
+	vsemi_mem_16G[157] = 0x4;
+	vsemi_mem_16G[158] = 0x0;
+	vsemi_mem_16G[159] = 0x0;
+	vsemi_mem_16G[160] = 0x8;
+	vsemi_mem_16G[161] = 0x4;
+	vsemi_mem_16G[162] = 0x0;
+	vsemi_mem_16G[163] = 0x0;
+	vsemi_mem_16G[164] = 0x4;
+
+	return;
+}
+
+void nlm_hal_config_vsemi_mem_16G_125(void)
+{
+
+	vsemi_mem_16G[101] = 0xAA;
+	vsemi_mem_16G[102] = 0x0;
+	vsemi_mem_16G[103] = 0x57;
+	vsemi_mem_16G[104] = 0xBF;
+	vsemi_mem_16G[105] = 0xBF;
+	vsemi_mem_16G[106] = 0xA;
+	vsemi_mem_16G[107] = 0xA;
+	vsemi_mem_16G[108] = 0xE;
+	vsemi_mem_16G[109] = 0xE;
+	vsemi_mem_16G[110] = 0x4;
+	vsemi_mem_16G[111] = 0x17;
+	vsemi_mem_16G[112] = 0x10;
+	vsemi_mem_16G[113] = 0x0;
+	vsemi_mem_16G[114] = 0x10;
+	vsemi_mem_16G[115] = 0x0;
+	vsemi_mem_16G[116] = 0xFF;
+	vsemi_mem_16G[117] = 0xC3;
+	vsemi_mem_16G[118] = 0xF5;
+	vsemi_mem_16G[119] = 0xD9;
+	vsemi_mem_16G[120] = 0xF2;
+	vsemi_mem_16G[121] = 0xFC;
+	vsemi_mem_16G[122] = 0xFE;
+	vsemi_mem_16G[123] = 0xFF;
+	vsemi_mem_16G[124] = 0xFF;
+	vsemi_mem_16G[125] = 0xFF;
+	vsemi_mem_16G[126] = 0xFF;
+	vsemi_mem_16G[127] = 0xDB;
+	vsemi_mem_16G[128] = 0xE9;
+	vsemi_mem_16G[129] = 0xC2;
+	vsemi_mem_16G[130] = 0xF2;
+	vsemi_mem_16G[131] = 0xFC;
+	vsemi_mem_16G[132] = 0xFE;
+	vsemi_mem_16G[133] = 0xF2;
+	vsemi_mem_16G[134] = 0xF2;
+	vsemi_mem_16G[135] = 0xFF;
+	vsemi_mem_16G[136] = 0xFF;
+	vsemi_mem_16G[137] = 0xDB;
+	vsemi_mem_16G[138] = 0xE9;
+	vsemi_mem_16G[139] = 0xC2;
+	vsemi_mem_16G[140] = 0xF2;
+	vsemi_mem_16G[141] = 0xFC;
+	vsemi_mem_16G[142] = 0xFE;
+	vsemi_mem_16G[143] = 0xF2;
+	vsemi_mem_16G[144] = 0xF2;
+	vsemi_mem_16G[145] = 0xFF;
+	vsemi_mem_16G[146] = 0xFF;
+	vsemi_mem_16G[147] = 0xFF;
+	vsemi_mem_16G[148] = 0xF2;
+	vsemi_mem_16G[149] = 0x3F;
+	vsemi_mem_16G[150] = 0x0;
+	vsemi_mem_16G[151] = 0x64;
+	vsemi_mem_16G[152] = 0x0;
+	vsemi_mem_16G[153] = 0x2;
+	vsemi_mem_16G[154] = 0x1;
+	vsemi_mem_16G[155] = 0x5;
+	vsemi_mem_16G[156] = 0x5;
+	vsemi_mem_16G[157] = 0x4;
+	vsemi_mem_16G[158] = 0x0;
+	vsemi_mem_16G[159] = 0x0;
+	vsemi_mem_16G[160] = 0x8;
+	vsemi_mem_16G[161] = 0x4;
+	vsemi_mem_16G[162] = 0x0;
+	vsemi_mem_16G[163] = 0x0;
+	vsemi_mem_16G[164] = 0x4;
+
+}
+
+void nlm_hal_config_vsemi_mem_12G_4page(void)
+{
+	vsemi_mem_12G_4page[101] = 0xC3;
+	vsemi_mem_12G_4page[102] = 0xC3;
+	vsemi_mem_12G_4page[103] = 0x11;
+	vsemi_mem_12G_4page[104] = 0x11;
+	vsemi_mem_12G_4page[105] = 0x12;
+	vsemi_mem_12G_4page[106] = 0x12;
+	vsemi_mem_12G_4page[107] = 0x2;
+	vsemi_mem_12G_4page[108] = 0x2;
+	vsemi_mem_12G_4page[109] = 0x0;
+	vsemi_mem_12G_4page[110] = 0x0;
+
+	return;
+}
+
+void nlm_hal_config_vsemi_mem_12G_4page_125(void)
+{
+	vsemi_mem_12G_4page[101] = 0xBA;
+	vsemi_mem_12G_4page[102] = 0xBA;
+	vsemi_mem_12G_4page[103] = 0xD;
+	vsemi_mem_12G_4page[104] = 0xD;
+	vsemi_mem_12G_4page[105] = 0x18;
+	vsemi_mem_12G_4page[106] = 0x18;
+	vsemi_mem_12G_4page[107] = 0x2;
+	vsemi_mem_12G_4page[108] = 0x2;
+	vsemi_mem_12G_4page[109] = 0x0;
+	vsemi_mem_12G_4page[110] = 0x0;
+	
+	return;
+}
+
+void nlm_hal_config_vsemi_mem_12G(void)
+{
+	vsemi_mem_12G[101] = 0x99;
+	vsemi_mem_12G[102] = 0x0;
+	vsemi_mem_12G[103] = 0x76;
+	vsemi_mem_12G[104] = 0xC3;
+	vsemi_mem_12G[105] = 0xC3;
+	vsemi_mem_12G[106] = 0x11;
+	vsemi_mem_12G[107] = 0x11;
+	vsemi_mem_12G[108] = 0x12;
+	vsemi_mem_12G[109] = 0x12;
+	vsemi_mem_12G[110] = 0x6;
+	vsemi_mem_12G[111] = 0x16;
+	vsemi_mem_12G[112] = 0x8;
+	vsemi_mem_12G[113] = 0x0;
+	vsemi_mem_12G[114] = 0x8;
+	vsemi_mem_12G[115] = 0x0;
+	vsemi_mem_12G[116] = 0xFF;
+	vsemi_mem_12G[117] = 0xB3;
+	vsemi_mem_12G[118] = 0xF6;
+	vsemi_mem_12G[119] = 0xD0;
+	vsemi_mem_12G[120] = 0xEF;
+	vsemi_mem_12G[121] = 0xFB;
+	vsemi_mem_12G[122] = 0xFF;
+	vsemi_mem_12G[123] = 0xFF;
+	vsemi_mem_12G[124] = 0xFF;
+	vsemi_mem_12G[125] = 0xFF;
+	vsemi_mem_12G[126] = 0xFF;
+	vsemi_mem_12G[127] = 0xD3;
+	vsemi_mem_12G[128] = 0xD3;
+	vsemi_mem_12G[129] = 0xE2;
+	vsemi_mem_12G[130] = 0xEF;
+	vsemi_mem_12G[131] = 0xFB;
+	vsemi_mem_12G[132] = 0xFB;
+	vsemi_mem_12G[133] = 0xFF;
+	vsemi_mem_12G[134] = 0xEF;
+	vsemi_mem_12G[135] = 0xFF;
+	vsemi_mem_12G[136] = 0xFF;
+	vsemi_mem_12G[137] = 0xD3;
+	vsemi_mem_12G[138] = 0xD3;
+	vsemi_mem_12G[139] = 0xE2;
+	vsemi_mem_12G[140] = 0xEF;
+	vsemi_mem_12G[141] = 0xFB;
+	vsemi_mem_12G[142] = 0xFB;
+	vsemi_mem_12G[143] = 0xFF;
+	vsemi_mem_12G[144] = 0xEF;
+	vsemi_mem_12G[145] = 0xFF;
+	vsemi_mem_12G[146] = 0xFF;
+	vsemi_mem_12G[147] = 0xFB;
+	vsemi_mem_12G[148] = 0xFF;
+	vsemi_mem_12G[149] = 0x3F;
+	vsemi_mem_12G[150] = 0x0;
+	vsemi_mem_12G[151] = 0x64;
+	vsemi_mem_12G[152] = 0x0;
+	vsemi_mem_12G[153] = 0x4;
+	vsemi_mem_12G[154] = 0x2;
+	vsemi_mem_12G[155] = 0xA;
+	vsemi_mem_12G[156] = 0x5;
+	vsemi_mem_12G[157] = 0x4;
+	vsemi_mem_12G[158] = 0x0;
+	vsemi_mem_12G[159] = 0x0;
+	vsemi_mem_12G[160] = 0x8;
+	vsemi_mem_12G[161] = 0x4;
+	vsemi_mem_12G[162] = 0x0;
+	vsemi_mem_12G[163] = 0x0;
+	vsemi_mem_12G[164] = 0x4;
+
+	return;
+}
+
+void nlm_hal_config_vsemi_mem_12G_125(void)
+{
+	vsemi_mem_12G[101] = 0x99;
+	vsemi_mem_12G[102] = 0x0;
+	vsemi_mem_12G[103] = 0x57;
+	vsemi_mem_12G[104] = 0xBA;
+	vsemi_mem_12G[105] = 0xBA;
+	vsemi_mem_12G[106] = 0xD;
+	vsemi_mem_12G[107] = 0xD;
+	vsemi_mem_12G[108] = 0x18;
+	vsemi_mem_12G[109] = 0x18;
+	vsemi_mem_12G[110] = 0x4;
+	vsemi_mem_12G[111] = 0x17;
+	vsemi_mem_12G[112] = 0x8;
+	vsemi_mem_12G[113] = 0x0;
+	vsemi_mem_12G[114] = 0x8;
+	vsemi_mem_12G[115] = 0x0;
+	vsemi_mem_12G[116] = 0xFF;
+	vsemi_mem_12G[117] = 0xC3;
+	vsemi_mem_12G[118] = 0xF5;
+	vsemi_mem_12G[119] = 0xD9;
+	vsemi_mem_12G[120] = 0xF2;
+	vsemi_mem_12G[121] = 0xFC;
+	vsemi_mem_12G[122] = 0xFE;
+	vsemi_mem_12G[123] = 0xFF;
+	vsemi_mem_12G[124] = 0xFF;
+	vsemi_mem_12G[125] = 0xFF;
+	vsemi_mem_12G[126] = 0xFF;
+	vsemi_mem_12G[127] = 0xDB;
+	vsemi_mem_12G[128] = 0xE9;
+	vsemi_mem_12G[129] = 0xC2;
+	vsemi_mem_12G[130] = 0xF2;
+	vsemi_mem_12G[131] = 0xFC;
+	vsemi_mem_12G[132] = 0xFE;
+	vsemi_mem_12G[133] = 0xF2;
+	vsemi_mem_12G[134] = 0xF2;
+	vsemi_mem_12G[135] = 0xFF;
+	vsemi_mem_12G[136] = 0xFF;
+	vsemi_mem_12G[137] = 0xDB;
+	vsemi_mem_12G[138] = 0xE9;
+	vsemi_mem_12G[139] = 0xC2;
+	vsemi_mem_12G[140] = 0xF2;
+	vsemi_mem_12G[141] = 0xFC;
+	vsemi_mem_12G[142] = 0xFE;
+	vsemi_mem_12G[143] = 0xF2;
+	vsemi_mem_12G[144] = 0xF2;
+	vsemi_mem_12G[145] = 0xFF;
+	vsemi_mem_12G[146] = 0xFF;
+	vsemi_mem_12G[147] = 0xFF;
+	vsemi_mem_12G[148] = 0xF2;
+	vsemi_mem_12G[149] = 0x3F;
+	vsemi_mem_12G[150] = 0x0;
+	vsemi_mem_12G[151] = 0x64;
+	vsemi_mem_12G[152] = 0x0;
+	vsemi_mem_12G[153] = 0x4;
+	vsemi_mem_12G[154] = 0x2;
+	vsemi_mem_12G[155] = 0xA;
+	vsemi_mem_12G[156] = 0x5;
+	vsemi_mem_12G[157] = 0x4;
+	vsemi_mem_12G[158] = 0x0;
+	vsemi_mem_12G[159] = 0x0;
+	vsemi_mem_12G[160] = 0x8;
+	vsemi_mem_12G[161] = 0x4;
+	vsemi_mem_12G[162] = 0x0;
+	vsemi_mem_12G[163] = 0x0;
+	vsemi_mem_12G[164] = 0x4;
+
+	return;
+}
+
+void nlm_hal_config_vsemi_mem_xaui(void)
+{
+	vsemi_mem_xaui[101] = 0xAA;
+	vsemi_mem_xaui[102] = 0x0;
+	vsemi_mem_xaui[103] = 0x76;
+	vsemi_mem_xaui[104] = 0xBF;
+	vsemi_mem_xaui[105] = 0xBF;
+	vsemi_mem_xaui[106] = 0xA;
+	vsemi_mem_xaui[107] = 0xA;
+	vsemi_mem_xaui[108] = 0xE;
+	vsemi_mem_xaui[109] = 0xE;
+	vsemi_mem_xaui[110] = 0x6;
+	vsemi_mem_xaui[111] = 0x16;
+	vsemi_mem_xaui[112] = 0x10;
+	vsemi_mem_xaui[113] = 0x0;
+	vsemi_mem_xaui[114] = 0x10;
+	vsemi_mem_xaui[115] = 0x0;
+	vsemi_mem_xaui[116] = 0xFF;
+	vsemi_mem_xaui[117] = 0xB3;
+	vsemi_mem_xaui[118] = 0xF6;
+	vsemi_mem_xaui[119] = 0xD0;
+	vsemi_mem_xaui[120] = 0xEF;
+	vsemi_mem_xaui[121] = 0xFB;
+	vsemi_mem_xaui[122] = 0xFF;
+	vsemi_mem_xaui[123] = 0xFF;
+	vsemi_mem_xaui[124] = 0xFF;
+	vsemi_mem_xaui[125] = 0xFF;
+	vsemi_mem_xaui[126] = 0xFF;
+	vsemi_mem_xaui[127] = 0xD3;
+	vsemi_mem_xaui[128] = 0xD3;
+	vsemi_mem_xaui[129] = 0xE2;
+	vsemi_mem_xaui[130] = 0xEF;
+	vsemi_mem_xaui[131] = 0xFB;
+	vsemi_mem_xaui[132] = 0xFB;
+	vsemi_mem_xaui[133] = 0xFF;
+	vsemi_mem_xaui[134] = 0xEF;
+	vsemi_mem_xaui[135] = 0xFF;
+	vsemi_mem_xaui[136] = 0xFF;
+	vsemi_mem_xaui[137] = 0xD3;
+	vsemi_mem_xaui[138] = 0xD3;
+	vsemi_mem_xaui[139] = 0xE2;
+	vsemi_mem_xaui[140] = 0xEF;
+	vsemi_mem_xaui[141] = 0xFB;
+	vsemi_mem_xaui[142] = 0xFB;
+	vsemi_mem_xaui[143] = 0xFF;
+	vsemi_mem_xaui[144] = 0xEF;
+	vsemi_mem_xaui[145] = 0xFF;
+	vsemi_mem_xaui[146] = 0xFF;
+	vsemi_mem_xaui[147] = 0xFB;
+	vsemi_mem_xaui[148] = 0xFF;
+	vsemi_mem_xaui[149] = 0x3F;
+	vsemi_mem_xaui[150] = 0x0;
+	vsemi_mem_xaui[151] = 0x64;
+	vsemi_mem_xaui[152] = 0x0;
+	vsemi_mem_xaui[153] = 0x2;
+	vsemi_mem_xaui[154] = 0x1;
+	vsemi_mem_xaui[155] = 0x5;
+	vsemi_mem_xaui[156] = 0x5;
+	vsemi_mem_xaui[157] = 0x4;
+	vsemi_mem_xaui[158] = 0x0;
+	vsemi_mem_xaui[159] = 0x0;
+	vsemi_mem_xaui[160] = 0x8;
+	vsemi_mem_xaui[161] = 0x4;
+	vsemi_mem_xaui[162] = 0x0;
+	vsemi_mem_xaui[163] = 0x0;
+	vsemi_mem_xaui[164] = 0x4;
+
+	return;
+}
+
+void nlm_hal_config_vsemi_mem_xaui_125(void)
+{
+	vsemi_mem_xaui[101] = 0xAA;
+	vsemi_mem_xaui[102] = 0x0;
+	vsemi_mem_xaui[103] = 0x57;
+	vsemi_mem_xaui[104] = 0xBF;
+	vsemi_mem_xaui[105] = 0xBF;
+	vsemi_mem_xaui[106] = 0x8;
+	vsemi_mem_xaui[107] = 0x8;
+	vsemi_mem_xaui[108] = 0x13;
+	vsemi_mem_xaui[109] = 0x13;
+	vsemi_mem_xaui[110] = 0x4;
+	vsemi_mem_xaui[111] = 0x17;
+	vsemi_mem_xaui[112] = 0x10;
+	vsemi_mem_xaui[113] = 0x0;
+	vsemi_mem_xaui[114] = 0x10;
+	vsemi_mem_xaui[115] = 0x0;
+	vsemi_mem_xaui[116] = 0xFF;
+	vsemi_mem_xaui[117] = 0xC3;
+	vsemi_mem_xaui[118] = 0xF5;
+	vsemi_mem_xaui[119] = 0xD9;
+	vsemi_mem_xaui[120] = 0xF2;
+	vsemi_mem_xaui[121] = 0xFC;
+	vsemi_mem_xaui[122] = 0xFE;
+	vsemi_mem_xaui[123] = 0xFF;
+	vsemi_mem_xaui[124] = 0xFF;
+	vsemi_mem_xaui[125] = 0xFF;
+	vsemi_mem_xaui[126] = 0xFF;
+	vsemi_mem_xaui[127] = 0xDB;
+	vsemi_mem_xaui[128] = 0xE9;
+	vsemi_mem_xaui[129] = 0xC2;
+	vsemi_mem_xaui[130] = 0xF2;
+	vsemi_mem_xaui[131] = 0xFC;
+	vsemi_mem_xaui[132] = 0xFE;
+	vsemi_mem_xaui[133] = 0xF2;
+	vsemi_mem_xaui[134] = 0xF2;
+	vsemi_mem_xaui[135] = 0xFF;
+	vsemi_mem_xaui[136] = 0xFF;
+	vsemi_mem_xaui[137] = 0xDB;
+	vsemi_mem_xaui[138] = 0xE9;
+	vsemi_mem_xaui[139] = 0xC2;
+	vsemi_mem_xaui[140] = 0xF2;
+	vsemi_mem_xaui[141] = 0xFC;
+	vsemi_mem_xaui[142] = 0xFE;
+	vsemi_mem_xaui[143] = 0xF2;
+	vsemi_mem_xaui[144] = 0xF2;
+	vsemi_mem_xaui[145] = 0xFF;
+	vsemi_mem_xaui[146] = 0xFF;
+	vsemi_mem_xaui[147] = 0xFF;
+	vsemi_mem_xaui[148] = 0xF2;
+	vsemi_mem_xaui[149] = 0x3F;
+	vsemi_mem_xaui[150] = 0x0;
+	vsemi_mem_xaui[151] = 0x64;
+	vsemi_mem_xaui[152] = 0x0;
+	vsemi_mem_xaui[153] = 0x2;
+	vsemi_mem_xaui[154] = 0x1;
+	vsemi_mem_xaui[155] = 0x5;
+	vsemi_mem_xaui[156] = 0x5;
+	vsemi_mem_xaui[157] = 0x4;
+	vsemi_mem_xaui[158] = 0x0;
+	vsemi_mem_xaui[159] = 0x0;
+	vsemi_mem_xaui[160] = 0x8;
+	vsemi_mem_xaui[161] = 0x4;
+	vsemi_mem_xaui[162] = 0x0;
+	vsemi_mem_xaui[163] = 0x0;
+	vsemi_mem_xaui[164] = 0x4;
+
+}
+
+
+void nlm_hal_config_vsemi_mem_xaui_4page(void)
+{
+	vsemi_mem_xaui_4page[101] = 0xBF;
+	vsemi_mem_xaui_4page[102] = 0xBF;
+	vsemi_mem_xaui_4page[103] = 0xA;
+	vsemi_mem_xaui_4page[104] = 0xA;
+	vsemi_mem_xaui_4page[105] = 0xE;
+	vsemi_mem_xaui_4page[106] = 0xE;
+	vsemi_mem_xaui_4page[107] = 0x1;
+	vsemi_mem_xaui_4page[108] = 0x1;
+	vsemi_mem_xaui_4page[109] = 0x22;
+	vsemi_mem_xaui_4page[110] = 0xF;
+
+	return;
+}
+
+void nlm_hal_config_vsemi_mem_xaui_4page_125(void)
+{
+	vsemi_mem_xaui_4page[101] = 0xBF;
+	vsemi_mem_xaui_4page[102] = 0xBF;
+	vsemi_mem_xaui_4page[103] = 0x8;
+	vsemi_mem_xaui_4page[104] = 0x8;
+	vsemi_mem_xaui_4page[105] = 0x13;
+	vsemi_mem_xaui_4page[106] = 0x13;
+	vsemi_mem_xaui_4page[107] = 0x1;
+	vsemi_mem_xaui_4page[108] = 0x1;
+	vsemi_mem_xaui_4page[109] = 0x22;
+	vsemi_mem_xaui_4page[110] = 0xF;
+	
+	return;
+}
+
+void nlm_hal_config_vsemi_mem_sgmii(void)
+{
+	vsemi_mem_sgmii[101] = 0x99;
+	vsemi_mem_sgmii[102] = 0x0;
+	vsemi_mem_sgmii[103] = 0x76;
+	vsemi_mem_sgmii[104] = 0xB7;
+	vsemi_mem_sgmii[105] = 0xB7;
+	vsemi_mem_sgmii[106] = 0xC;
+	vsemi_mem_sgmii[107] = 0xC;
+	vsemi_mem_sgmii[108] = 0x1A;
+	vsemi_mem_sgmii[109] = 0x1A;
+	vsemi_mem_sgmii[110] = 0x6;
+	vsemi_mem_sgmii[111] = 0x16;
+	vsemi_mem_sgmii[112] = 0x8;
+	vsemi_mem_sgmii[113] = 0x0;
+	vsemi_mem_sgmii[114] = 0x8;
+	vsemi_mem_sgmii[115] = 0x0;
+	vsemi_mem_sgmii[116] = 0xFF;
+	vsemi_mem_sgmii[117] = 0xB3;
+	vsemi_mem_sgmii[118] = 0xF6;
+	vsemi_mem_sgmii[119] = 0xD0;
+	vsemi_mem_sgmii[120] = 0xEF;
+	vsemi_mem_sgmii[121] = 0xFB;
+	vsemi_mem_sgmii[122] = 0xFF;
+	vsemi_mem_sgmii[123] = 0xFF;
+	vsemi_mem_sgmii[124] = 0xFF;
+	vsemi_mem_sgmii[125] = 0xFF;
+	vsemi_mem_sgmii[126] = 0xFF;
+	vsemi_mem_sgmii[127] = 0xD3;
+	vsemi_mem_sgmii[128] = 0xD3;
+	vsemi_mem_sgmii[129] = 0xE2;
+	vsemi_mem_sgmii[130] = 0xEF;
+	vsemi_mem_sgmii[131] = 0xFB;
+	vsemi_mem_sgmii[132] = 0xFB;
+	vsemi_mem_sgmii[133] = 0xFF;
+	vsemi_mem_sgmii[134] = 0xEF;
+	vsemi_mem_sgmii[135] = 0xFF;
+	vsemi_mem_sgmii[136] = 0xFF;
+	vsemi_mem_sgmii[137] = 0xD3;
+	vsemi_mem_sgmii[138] = 0xD3;
+	vsemi_mem_sgmii[139] = 0xE2;
+	vsemi_mem_sgmii[140] = 0xEF;
+	vsemi_mem_sgmii[141] = 0xFB;
+	vsemi_mem_sgmii[142] = 0xFB;
+	vsemi_mem_sgmii[143] = 0xFF;
+	vsemi_mem_sgmii[144] = 0xEF;
+	vsemi_mem_sgmii[145] = 0xFF;
+	vsemi_mem_sgmii[146] = 0xFF;
+	vsemi_mem_sgmii[147] = 0xFB;
+	vsemi_mem_sgmii[148] = 0xFF;
+	vsemi_mem_sgmii[149] = 0x3F;
+	vsemi_mem_sgmii[150] = 0x0;
+	vsemi_mem_sgmii[151] = 0x64;
+	vsemi_mem_sgmii[152] = 0x0;
+	vsemi_mem_sgmii[153] = 0x4;
+	vsemi_mem_sgmii[154] = 0x2;
+	vsemi_mem_sgmii[155] = 0x5;
+	vsemi_mem_sgmii[156] = 0x5;
+	vsemi_mem_sgmii[157] = 0x4;
+	vsemi_mem_sgmii[158] = 0x0;
+	vsemi_mem_sgmii[159] = 0x0;
+	vsemi_mem_sgmii[160] = 0x8;
+	vsemi_mem_sgmii[161] = 0x4;
+	vsemi_mem_sgmii[162] = 0x0;
+	vsemi_mem_sgmii[163] = 0x0;
+	vsemi_mem_sgmii[164] = 0x4;
+}
+
+void vsemi_mem_init_sgmii_125Mhzrefclk(void)
+{
+	vsemi_mem_sgmii[101] = 0xAA;
+	vsemi_mem_sgmii[102] = 0x0;
+	vsemi_mem_sgmii[103] = 0x57;
+	vsemi_mem_sgmii[104] = 0xBF;
+	vsemi_mem_sgmii[105] = 0xBF;
+	vsemi_mem_sgmii[106] = 0xA;
+	vsemi_mem_sgmii[107] = 0xA;
+	vsemi_mem_sgmii[108] = 0xE;
+	vsemi_mem_sgmii[109] = 0xE;
+	vsemi_mem_sgmii[110] = 0x4;
+	vsemi_mem_sgmii[111] = 0x17;
+	vsemi_mem_sgmii[112] = 0x10;
+	vsemi_mem_sgmii[113] = 0x0;
+	vsemi_mem_sgmii[114] = 0x10;
+	vsemi_mem_sgmii[115] = 0x0;
+	vsemi_mem_sgmii[116] = 0xFF;
+	vsemi_mem_sgmii[117] = 0xC3;
+	vsemi_mem_sgmii[118] = 0xF5;
+	vsemi_mem_sgmii[119] = 0xD9;
+	vsemi_mem_sgmii[120] = 0xF2;
+	vsemi_mem_sgmii[121] = 0xFC;
+	vsemi_mem_sgmii[122] = 0xFE;
+	vsemi_mem_sgmii[123] = 0xFF;
+	vsemi_mem_sgmii[124] = 0xFF;
+	vsemi_mem_sgmii[125] = 0xFF;
+	vsemi_mem_sgmii[126] = 0xFF;
+	vsemi_mem_sgmii[127] = 0xDB;
+	vsemi_mem_sgmii[128] = 0xE9;
+	vsemi_mem_sgmii[129] = 0xC2;
+	vsemi_mem_sgmii[130] = 0xF2;
+	vsemi_mem_sgmii[131] = 0xFC;
+	vsemi_mem_sgmii[132] = 0xFE;
+	vsemi_mem_sgmii[133] = 0xF2;
+	vsemi_mem_sgmii[134] = 0xF2;
+	vsemi_mem_sgmii[135] = 0xFF;
+	vsemi_mem_sgmii[136] = 0xFF;
+	vsemi_mem_sgmii[137] = 0xDB;
+	vsemi_mem_sgmii[138] = 0xE9;
+	vsemi_mem_sgmii[139] = 0xC2;
+	vsemi_mem_sgmii[140] = 0xF2;
+	vsemi_mem_sgmii[141] = 0xFC;
+	vsemi_mem_sgmii[142] = 0xFE;
+	vsemi_mem_sgmii[143] = 0xF2;
+	vsemi_mem_sgmii[144] = 0xF2;
+	vsemi_mem_sgmii[145] = 0xFF;
+	vsemi_mem_sgmii[146] = 0xFF;
+	vsemi_mem_sgmii[147] = 0xFF;
+	vsemi_mem_sgmii[148] = 0xF2;
+	vsemi_mem_sgmii[149] = 0x3F;
+	vsemi_mem_sgmii[150] = 0x0;
+	vsemi_mem_sgmii[151] = 0x64;
+	vsemi_mem_sgmii[152] = 0x0;
+	vsemi_mem_sgmii[153] = 0x2;
+	vsemi_mem_sgmii[154] = 0x1;
+	vsemi_mem_sgmii[155] = 0x5;
+	vsemi_mem_sgmii[156] = 0x5;
+	vsemi_mem_sgmii[157] = 0x4;
+	vsemi_mem_sgmii[158] = 0x0;
+	vsemi_mem_sgmii[159] = 0x0;
+	vsemi_mem_sgmii[160] = 0x8;
+	vsemi_mem_sgmii[161] = 0x4;
+	vsemi_mem_sgmii[162] = 0x0;
+	vsemi_mem_sgmii[163] = 0x0;
+	vsemi_mem_sgmii[164] = 0x4;
+}
+
+void nlm_hal_config_vsemi_mem_sgmii_4page(void)
+{    
+	vsemi_mem_sgmii_4page[101] = 0xB7;
+	vsemi_mem_sgmii_4page[102] = 0xB7;
+	vsemi_mem_sgmii_4page[103] = 0xC;
+	vsemi_mem_sgmii_4page[104] = 0xC;
+	vsemi_mem_sgmii_4page[105] = 0x1A;
+	vsemi_mem_sgmii_4page[106] = 0x1A;
+	vsemi_mem_sgmii_4page[107] = 0x2;
+	vsemi_mem_sgmii_4page[108] = 0x2;
+	vsemi_mem_sgmii_4page[109] = 0x11;
+	vsemi_mem_sgmii_4page[110] = 0xF;
+}
+
+void nlm_hal_config_vsemi_mem_sgmii_4page_125Mhz(void)
+{
+	vsemi_mem_sgmii_4page[101] = 0xBF;
+	vsemi_mem_sgmii_4page[102] = 0xBF;
+	vsemi_mem_sgmii_4page[103] = 0xA;
+	vsemi_mem_sgmii_4page[104] = 0xA;
+	vsemi_mem_sgmii_4page[105] = 0xE;
+	vsemi_mem_sgmii_4page[106] = 0xE;
+	vsemi_mem_sgmii_4page[107] = 0x1;
+	vsemi_mem_sgmii_4page[108] = 0x1;
+	vsemi_mem_sgmii_4page[109] = 0x11;
+	vsemi_mem_sgmii_4page[110] = 0xF;
+}
diff --git a/drivers/ata/xlp-ahci.c b/drivers/ata/xlp-ahci.c
index 2bfb4c6..3cdc46a 100644
--- a/drivers/ata/xlp-ahci.c
+++ b/drivers/ata/xlp-ahci.c
@@ -2106,7 +2106,6 @@ static void ahci_port_intr(struct ata_port *ap)
 extern void nlm_hal_sata_init(void);
 extern void nlm_hal_sata_intr_setup(void);
 extern void nlm_hal_sata_intr_ack(void);
-extern int is_nlm_xlp3xx_lite(void);
 static int nlm_sata_init_done = 0;
 
 static irqreturn_t ahci_interrupt(int irq, void *dev_instance)
-- 
1.7.0

