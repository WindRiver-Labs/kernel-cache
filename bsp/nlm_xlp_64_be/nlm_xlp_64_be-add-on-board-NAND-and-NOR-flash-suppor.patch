From 088617141d5c016a7d5f9a026f7592cf8a0a7a06 Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Fri, 23 Mar 2012 11:38:02 +0800
Subject: [PATCH 08/47] nlm_xlp_64_be: add on-board NAND and NOR flash support

Add XLP on-board NAND and NOR flash support, based on
NetLogic SDK 20120215_2.2.3 tag.

Signed-off-by: henry shao <hshao@netlogicmicro.com>
Integrated-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/mtd/maps/Kconfig         |    6 +
 drivers/mtd/maps/Makefile        |    4 +
 drivers/mtd/maps/xlp-flash.c     |  237 +++++++++++
 drivers/mtd/nand/Kconfig         |    4 +
 drivers/mtd/nand/Makefile        |    4 +
 drivers/mtd/nand/nand_base.c     |  294 ++++++++++++++-
 drivers/mtd/nand/xlp_plat_nand.c |  811 ++++++++++++++++++++++++++++++++++++++
 drivers/mtd/nand/xlp_plat_nand.h |   97 +++++
 include/linux/mtd/nand.h         |   74 ++++
 9 files changed, 1530 insertions(+), 1 deletions(-)
 create mode 100644 drivers/mtd/maps/xlp-flash.c
 create mode 100644 drivers/mtd/nand/xlp_plat_nand.c
 create mode 100644 drivers/mtd/nand/xlp_plat_nand.h

diff --git a/drivers/mtd/maps/Kconfig b/drivers/mtd/maps/Kconfig
index aa2807d..b3d6605 100644
--- a/drivers/mtd/maps/Kconfig
+++ b/drivers/mtd/maps/Kconfig
@@ -251,6 +251,12 @@ config MTD_NETtel
 	help
 	  Support for flash chips on NETtel/SecureEdge/SnapGear boards.
 
+config MTD_XLP
+   	tristate "XLP Flash MTD support"
+	depends on NLM_XLP
+   	help
+     	  Flash memory access on XLP Reference Boards
+
 config MTD_DILNETPC
 	tristate "CFI Flash device mapped on DIL/Net PC"
 	depends on X86 && MTD_CONCAT && MTD_PARTITIONS && MTD_CFI_INTELEXT && BROKEN
diff --git a/drivers/mtd/maps/Makefile b/drivers/mtd/maps/Makefile
index bb035cd..6f7a7af 100644
--- a/drivers/mtd/maps/Makefile
+++ b/drivers/mtd/maps/Makefile
@@ -1,6 +1,9 @@
 #
 # linux/drivers/maps/Makefile
 #
+ifeq ($(CONFIG_NLM_XLP),y)
+        EXTRA_CFLAGS := $(CFLAGS) -DNLM_HAL_LINUX_KERNEL
+endif
 
 ifeq ($(CONFIG_MTD_COMPLEX_MAPPINGS),y)
 obj-$(CONFIG_MTD)		+= map_funcs.o
@@ -59,3 +62,4 @@ obj-$(CONFIG_MTD_BFIN_ASYNC)	+= bfin-async-flash.o
 obj-$(CONFIG_MTD_RBTX4939)	+= rbtx4939-flash.o
 obj-$(CONFIG_MTD_VMU)		+= vmu-flash.o
 obj-$(CONFIG_MTD_GPIO_ADDR)	+= gpio-addr-flash.o
+obj-$(CONFIG_MTD_XLP)           += xlp-flash.o
diff --git a/drivers/mtd/maps/xlp-flash.c b/drivers/mtd/maps/xlp-flash.c
new file mode 100644
index 0000000..4b3dbf0
--- /dev/null
+++ b/drivers/mtd/maps/xlp-flash.c
@@ -0,0 +1,237 @@
+/***********************************************************************
+ * Copyright 2003-2010 Netlogic Microsystems (ï¿½"Netlogic" ). All rights
+ * reserved.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in
+ * the documentation and/or other materials provided with the
+ * distribution.
+ * THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * *****************************#NETL_2#********************************/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+#ifdef CONFIG_NLM_XLP
+#include <asm/netlogic/hal/nlm_hal.h>
+#include <asm/netlogic/xlp.h>
+#endif
+
+#undef NOR_DEBUG
+
+#define XLP_NOR_BASEADDR	0x40
+#define XLP_NOR_SIZE 		0x01000000 /* 16MB */
+#define XLP_NOR_WIDTH		2 /* 16-bits */
+
+struct xlp_nor_info {
+        struct mtd_partition    *parts;
+        struct mtd_info         *mtd;
+        struct map_info         map;
+};
+
+static struct mtd_partition xlp_nor_partitions[] = {
+        {
+                .name   = "X-Loader(RO)",
+                .offset = 0,
+                .size   = 0x100000,     /* 1M */
+                .mask_flags = MTD_WRITEABLE,
+        },
+        {
+                .name   = "U-boot(RW)",
+                .offset = 0x100000,
+                .size   = 0x60000,      /* 384k */
+        },
+        {
+                .name   = "DTB(RW)",
+                .offset = 0x160000,
+                .size   = 0x20000,      /* 128K */
+        },
+        {
+                .name   = "Kernel(RW)",
+                .offset = 0x180000,
+                .size   = 0x580000,     /* 5.5M */
+        },
+        {
+                .name   = "Rootfs(RW)",
+                .offset = 0x700000,
+                .size   = 0x800000,     /* 8M */
+        },
+        {
+                .name   = "Env(RO)",
+                .offset = 0xf00000,     /* 1M */
+                .size   = MTDPART_SIZ_FULL,
+                .mask_flags = MTD_WRITEABLE,
+        },
+};
+
+static __inline__ int32_t nor_reg_read(int node,  int regidx)
+{
+        volatile uint64_t mmio;
+        mmio = nlm_hal_get_dev_base(node, 0, XLP_PCIE_SPI_NOR_FLASH_DEV, XLP_PCIE_SPI_NOR);
+        return nlm_hal_read_32bit_reg(mmio, regidx);
+}
+static __inline__ void nor_reg_write(int node, int regidx, int32_t val)
+{
+        volatile uint64_t mmio;
+        mmio = nlm_hal_get_dev_base(node, 0, XLP_PCIE_SPI_NOR_FLASH_DEV, XLP_PCIE_SPI_NOR);
+        nlm_hal_write_32bit_reg(mmio, regidx, val);
+}
+
+#ifdef NOR_DEBUG
+static void nor_dump_reg(void)
+{
+        int i;
+
+	printk("\nNor Flash memory interface chip select:\n");
+        for(i = 0x0; i < 0x7; i++)
+        {
+                printk("nor flash:  0x%0x = 0x%8x\n", i, nor_reg_read(0, i));
+        }
+
+        for(i = 0x40; i < 0x47; i++)
+        {
+                printk("base addr for cs:%d  0x%0x = 0x%8x\n", i & 0x0f, i, nor_reg_read(0, i));
+        }
+
+        for(i = 0x48; i < 0x4f; i++)
+        {
+                printk("addr limit  cs:%d  0x%0x = 0x%8x\n", i & 0x0f, i, nor_reg_read(0, i));
+        }
+
+        for(i = 0x50; i < 0x57; i++)
+        {
+                printk("device parameter for cs:%d  0x%0x = 0x%8x\n", i & 0x0f, i, nor_reg_read(0, i));
+        }
+
+        printk("Nor flash system control 0x68= 0x%8x\n", nor_reg_read(0, 0x68));
+}
+#endif
+
+
+int __init xlp_nor_probe(struct platform_device *pdev)
+{
+	struct xlp_nor_info *info;
+	int nb_parts, err;
+
+	info = kzalloc(sizeof(struct xlp_nor_info), GFP_KERNEL);
+	if (!info)
+		return -ENOMEM;
+
+	info->map.name		= dev_name(&pdev->dev);
+	info->map.bankwidth	= XLP_NOR_WIDTH;
+	info->map.phys		= nor_reg_read(0, XLP_NOR_BASEADDR) << 8;
+	info->map.size		= XLP_NOR_SIZE;
+	info->map.virt		= ioremap(info->map.phys, XLP_NOR_SIZE);
+	if(!info->map.virt) {
+		err = -ENOMEM;
+		goto out_info;
+	}
+	info->mtd 		= do_map_probe("cfi_probe", &info->map);
+	if (!info->mtd) {
+		err = -ENXIO;
+		goto out_unmap;
+	}
+	info->mtd->owner	= THIS_MODULE;
+	info->mtd->dev.parent	= &pdev->dev;
+	
+	if (mtd_has_partitions()) {
+		if (mtd_has_cmdlinepart()) {
+                        static const char *part_probes[]
+                                        = { "cmdlinepart", NULL, };
+			nb_parts = parse_mtd_partitions(info->mtd, part_probes, &info->parts, 0);
+		}
+		if(nb_parts <= 0)
+		{
+			nb_parts = ARRAY_SIZE(xlp_nor_partitions);
+			if(!info->parts)
+				info->parts = xlp_nor_partitions;
+		}
+		if(nb_parts > 0)
+		{
+			err = add_mtd_partitions(info->mtd, info->parts, nb_parts);
+		}
+	}
+	else {
+		err = add_mtd_device(info->mtd);
+	}
+
+	platform_set_drvdata(pdev, info);
+
+	return 0;
+out_unmap:
+	iounmap(info->map.virt);
+out_info:
+	kfree(info);
+	return err;
+}
+
+static int __exit xlp_nor_remove(struct platform_device *pdev)
+{
+	struct xlp_nor_info* info = platform_get_drvdata(pdev);
+
+	platform_set_drvdata(pdev, NULL);
+
+	if (info) {
+		if(info->parts) {
+			del_mtd_partitions(info->mtd);
+			kfree(info->parts);
+		}
+		else
+			del_mtd_device(info->mtd);
+		map_destroy(info->mtd);
+		iounmap(info->map.virt);
+		kfree(info);
+	}
+	return 0;
+}
+
+static struct platform_driver xlp_nor_driver = {
+        .probe          = xlp_nor_probe,
+        .remove         = xlp_nor_remove,
+        .driver         = {
+                .name   = "nor-xlp",
+                .owner  = THIS_MODULE,
+        },
+};
+
+static int __init xlp_nor_init(void)
+{
+        return platform_driver_register(&xlp_nor_driver);
+}
+
+static void __exit xlp_nor_exit(void)
+{
+        platform_driver_unregister(&xlp_nor_driver);
+}
+
+
+module_init(xlp_nor_init);
+module_exit(xlp_nor_exit);
+
+MODULE_AUTHOR("Netlogic Microsystems");
+MODULE_DESCRIPTION("Netlogic xlp NOR MTD driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("0.1");
+MODULE_ALIAS("platform:xlp-nor");
diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
index 300e5ee..614aa6c 100644
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -482,6 +482,10 @@ config MTD_NAND_SOCRATES
 	help
 	  Enables support for NAND Flash chips wired onto Socrates board.
 
+config MTD_NAND_XLP
+	tristate "Support for NAND Flash on XLP"
+	depends on MTD_NAND && NLM_XLP
+
 config MTD_NAND_W90P910
 	tristate "Support for NAND on w90p910 evaluation board."
 	depends on ARCH_W90X900 && MTD_PARTITIONS
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index 8abc265..161b94f 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -1,6 +1,9 @@
 #
 # linux/drivers/nand/Makefile
 #
+ifeq ($(CONFIG_NLM_XLP),y)
+        EXTRA_CFLAGS := $(CFLAGS) -DNLM_HAL_LINUX_KERNEL
+endif
 
 obj-$(CONFIG_MTD_NAND)			+= nand.o nand_ecc.o
 obj-$(CONFIG_MTD_NAND_IDS)		+= nand_ids.o
@@ -40,6 +43,7 @@ obj-$(CONFIG_MTD_NAND_SH_FLCTL)		+= sh_flctl.o
 obj-$(CONFIG_MTD_NAND_MXC)		+= mxc_nand.o
 obj-$(CONFIG_MTD_NAND_SOCRATES)		+= socrates_nand.o
 obj-$(CONFIG_MTD_NAND_TXX9NDFMC)	+= txx9ndfmc.o
+obj-$(CONFIG_MTD_NAND_XLP)		+= xlp_plat_nand.o
 obj-$(CONFIG_MTD_NAND_W90P910)		+= w90p910_nand.o
 obj-$(CONFIG_MTD_NAND_NOMADIK)		+= nomadik_nand.o
 obj-$(CONFIG_MTD_NAND_BCM_UMI)		+= bcm_umi_nand.o nand_bcm_umi.o
diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c
index 8f2958f..0f9f8b1 100644
--- a/drivers/mtd/nand/nand_base.c
+++ b/drivers/mtd/nand/nand_base.c
@@ -46,6 +46,9 @@
 #include <linux/interrupt.h>
 #include <linux/bitops.h>
 #include <linux/leds.h>
+#ifdef CONFIG_NLM_XLP
+#include <linux/crc16.h>
+#endif
 #include <asm/io.h>
 
 #ifdef CONFIG_MTD_PARTITIONS
@@ -95,6 +98,43 @@ static struct nand_ecclayout nand_oob_128 = {
 		{.offset = 2,
 		 .length = 78}}
 };
+#ifdef CONFIG_NLM_XLP
+static u16 onfi_crc(u16 crc, unsigned char const *p, size_t len)
+{
+        int i;
+        while (len--) {
+                crc ^= *p++ << 8;
+                for (i = 0; i < 8; i++)
+                        crc = (crc << 1) ^ ((crc & 0x8000) ? 0x8005 : 0);
+        }
+        return crc;
+}
+
+/*
+ * sanitize ONFI strings so we can safely print them
+ */
+static void sanitize_string(uint8_t *s, size_t len)
+{
+        ssize_t i;
+
+        /* null terminate */
+        s[len - 1] = 0;
+
+        /* remove non printable chars */
+        for (i = 0; i < len - 1; i++) {
+                if (s[i] < ' ' || s[i] > 127)
+                        s[i] = '?';
+        }
+	/* remove trailing spaces */
+	for (i = len - 1; i >= 0; i--) {
+		if (s[i] && s[i] != ' ')
+			break;
+		s[i] = 0;
+	}
+}
+#endif
+
+static int nand_manufacturer;
 
 static int nand_get_device(struct nand_chip *chip, struct mtd_info *mtd,
 			   int new_state);
@@ -2737,6 +2777,247 @@ static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
 	return type;
 }
 
+#ifdef CONFIG_NLM_XLP
+/*
+ * Get the flash and manufacturer id and lookup if the type is supported
+ */
+static struct nand_flash_dev *xlp_nand_get_flash_type(struct mtd_info *mtd,
+						  struct nand_chip *chip,
+						  int busw, int* dev_id, int *maf_id)
+{
+	struct nand_flash_dev *type = NULL;
+	int maf_idx;
+	int tmp_id, tmp_manf;
+
+	/* Select the device */
+	chip->select_chip(mtd, 0);
+
+	/*
+	 * Reset the chip, required by some chips (e.g. Micron MT29FxGxxxxx)
+	 * after power-up
+	 */
+	chip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
+
+	/* Send the command for reading device ID */
+	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
+
+	/* Read manufacturer and device IDs */
+	*maf_id = chip->read_byte(mtd);
+	*dev_id = chip->read_byte(mtd);
+	if(((*dev_id) == 0) && ((*maf_id) == 0))
+		return ERR_PTR(-ENODEV);
+	/* Try again to make sure, as some systems the bus-hold or other
+	 * interface concerns can cause random data which looks like a
+	 * possibly credible NAND flash to appear. If the two results do
+	 * not match, ignore the device completely.
+	 */
+
+	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
+
+	/* Read manufacturer and device IDs */
+
+	tmp_manf = chip->read_byte(mtd);
+	tmp_id = chip->read_byte(mtd);
+	if (tmp_manf != *maf_id || tmp_id != *dev_id) {
+		printk(KERN_INFO "%s: second ID read did not match "
+		       "%02x,%02x against %02x,%02x\n", __func__,
+		       *maf_id, *dev_id, tmp_manf, tmp_id);
+		return ERR_PTR(-ENODEV);
+	}
+
+	/* Lookup the flash id */
+        type = nand_flash_ids;
+        for (; type->name != NULL; type++) {
+                if (*dev_id == type->id) {
+			break;
+		}
+	}
+        chip->onfi_version = 0;
+        if (!type->name || !type->pagesize) {
+                /* try ONFI for unknow chip or LP */
+                chip->cmdfunc(mtd, NAND_CMD_READID, 0x20, -1);
+                if (chip->read_byte(mtd) == 'O' &&
+                    chip->read_byte(mtd) == 'N' &&
+                    chip->read_byte(mtd) == 'F' &&
+                    chip->read_byte(mtd) == 'I') {
+
+                        struct nand_onfi_params *p = &chip->onfi_params;
+                        int i;
+
+                        printk(KERN_INFO "ONFI flash detected\n");
+                        chip->cmdfunc(mtd, NAND_CMD_PARAM, 0, -1);
+                        for (i = 0; i < 3; i++) {
+                                chip->read_buf(mtd, (uint8_t *)p, sizeof(*p));
+                                if (onfi_crc(ONFI_CRC_BASE, (uint8_t *)p, 254) == le16_to_cpu(p->crc))
+                                {
+                                        printk(KERN_INFO "ONFI param page %d valid\n", i);
+                                        break;
+                                }
+                        }
+
+                        if (i < 3) {
+                                /* check version */
+                                int val = le16_to_cpu(p->revision);
+                                if (val == 1 || val > (1 << 4))
+                                        printk(KERN_INFO "%s: unsupported ONFI version: %d\n",
+                                               __func__, val);
+                                else {
+                                        if (val & (1 << 4))
+                                                chip->onfi_version = 22;
+                                        else if (val & (1 << 3))
+                                                chip->onfi_version = 21;
+                                        else if (val & (1 << 2))
+                                                chip->onfi_version = 20;
+                                        else
+                                                chip->onfi_version = 10;
+                                }
+                        }
+                        if (chip->onfi_version) {
+                                sanitize_string(p->manufacturer, sizeof(p->manufacturer));
+                                sanitize_string(p->model, sizeof(p->model));
+                                if (!mtd->name)
+                                        mtd->name = p->model;
+                                mtd->writesize = le32_to_cpu(p->byte_per_page);
+                                mtd->erasesize = le32_to_cpu(p->pages_per_block)*mtd->writesize;
+                                chip->chipsize = le32_to_cpu(p->blocks_per_lun) * mtd->erasesize;
+                                busw = 0;
+                                if (le16_to_cpu(p->features) & 1)
+                                        busw = NAND_BUSWIDTH_16;
+
+                                chip->options &= ~NAND_CHIPOPTIONS_MSK;
+                                chip->options |= (NAND_NO_READRDY |
+                                                  NAND_NO_AUTOINCR) & NAND_CHIPOPTIONS_MSK;
+
+                                goto ident_done;
+
+                        }
+                }
+        }
+
+	if (!type)
+		return ERR_PTR(-ENODEV);
+
+	if (!mtd->name)
+		mtd->name = type->name;
+
+	chip->chipsize = (uint64_t)type->chipsize << 20;
+
+	/* Newer devices have all the information in additional id bytes */
+	if (!type->pagesize) {
+		int extid;
+		/* The 3rd id byte holds MLC / multichip data */
+		chip->cellinfo = chip->read_byte(mtd);
+		/* The 4th id byte is the important one */
+		extid = chip->read_byte(mtd);
+		/* Calc pagesize */
+		mtd->writesize = 1024 << (extid & 0x3);
+		extid >>= 2;
+		/* Calc oobsize */
+		mtd->oobsize = (8 << (extid & 0x01)) * (mtd->writesize >> 9);
+		extid >>= 2;
+		/* Calc blocksize. Blocksize is multiples of 64KiB */
+		mtd->erasesize = (64 * 1024) << (extid & 0x03);
+		extid >>= 2;
+		/* Get buswidth information */
+		busw = (extid & 0x01) ? NAND_BUSWIDTH_16 : 0;
+
+	} else {
+		/*
+		 * Old devices have chip data hardcoded in the device id table
+		 */
+		mtd->erasesize = type->erasesize;
+		mtd->writesize = type->pagesize;
+		mtd->oobsize = mtd->writesize / 32;
+		busw = type->options & NAND_BUSWIDTH_16;
+	}
+
+        /* Get chip options, preserve non chip based options */
+        chip->options &= ~NAND_CHIPOPTIONS_MSK;
+        chip->options |= type->options & NAND_CHIPOPTIONS_MSK;
+
+        /* Check if chip is a not a samsung device. Do not clear the
+         * options for chips which are not having an extended id.
+         */
+        if (*maf_id != NAND_MFR_SAMSUNG && !type->pagesize)
+                chip->options &= ~NAND_SAMSUNG_LP_OPTIONS;
+ident_done:
+
+        /*
+         * Set chip as a default. Board drivers can override it, if necessary
+         */
+        chip->options |= NAND_NO_AUTOINCR;
+	/* Try to identify manufacturer */
+	for (maf_idx = 0; nand_manuf_ids[maf_idx].id != 0x0; maf_idx++) {
+		if (nand_manuf_ids[maf_idx].id == *maf_id)
+			break;
+	}
+
+	/*
+	 * Check, if buswidth is correct. Hardware drivers should set
+	 * chip correct !
+	 */
+	if (busw != (chip->options & NAND_BUSWIDTH_16)) {
+		printk(KERN_INFO "NAND device: Manufacturer ID:"
+		       " 0x%02x, Chip ID: 0x%02x (%s %s)\n", *maf_id,
+		       dev_id, nand_manuf_ids[maf_idx].name, mtd->name);
+		printk(KERN_WARNING "NAND bus width %d instead %d bit\n",
+		       (chip->options & NAND_BUSWIDTH_16) ? 16 : 8,
+		       busw ? 16 : 8);
+		return ERR_PTR(-EINVAL);
+	}
+
+	/* Calculate the address shift from the page size */
+	chip->page_shift = ffs(mtd->writesize) - 1;
+	/* Convert chipsize to number of pages per chip -1. */
+	chip->pagemask = (chip->chipsize >> chip->page_shift) - 1;
+
+	chip->bbt_erase_shift = chip->phys_erase_shift =
+		ffs(mtd->erasesize) - 1;
+	if (chip->chipsize & 0xffffffff)
+		chip->chip_shift = ffs((unsigned)chip->chipsize) - 1;
+	else
+		chip->chip_shift = ffs((unsigned)(chip->chipsize >> 32)) + 32 - 1;
+
+	/* Set the bad block position */
+	chip->badblockpos = mtd->writesize > 512 ?
+		NAND_LARGE_BADBLOCK_POS : NAND_SMALL_BADBLOCK_POS;
+
+	/* Get chip options, preserve non chip based options */
+	chip->options &= ~NAND_CHIPOPTIONS_MSK;
+	chip->options |= type->options & NAND_CHIPOPTIONS_MSK;
+
+	/*
+	 * Set chip as a default. Board drivers can override it, if necessary
+	 */
+	chip->options |= NAND_NO_AUTOINCR;
+
+	/* Check if chip is a not a samsung device. Do not clear the
+	 * options for chips which are not having an extended id.
+	 */
+	if (*maf_id != NAND_MFR_SAMSUNG && !type->pagesize)
+		chip->options &= ~NAND_SAMSUNG_LP_OPTIONS;
+
+	/* Check for AND chips with 4 page planes */
+	if (chip->options & NAND_4PAGE_ARRAY)
+		chip->erase_cmd = multi_erase_cmd;
+	else
+		chip->erase_cmd = single_erase_cmd;
+
+	/* Do not replace user supplied command function ! */
+	if (mtd->writesize > 512 && chip->cmdfunc == nand_command)
+		chip->cmdfunc = nand_command_lp;
+
+	printk(KERN_INFO "NAND device: Manufacturer ID:"
+		" 0x%02x, Chip ID: 0x%02x (%s %s)\n", *maf_id, *dev_id,
+		nand_manuf_ids[maf_idx].name,
+		chip->onfi_version ? chip->onfi_params.model : type->name);
+
+	nand_manufacturer =  *maf_id;
+
+	return type;
+}
+#endif
+
 /**
  * nand_scan_ident - [NAND Interface] Scan for the NAND device
  * @mtd:	     MTD device structure
@@ -2749,7 +3030,11 @@ static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
  */
 int nand_scan_ident(struct mtd_info *mtd, int maxchips)
 {
+#ifdef CONFIG_NLM_XLP
+	int i, busw, nand_maf_id, nand_dev_id;
+#else
 	int i, busw, nand_maf_id;
+#endif
 	struct nand_chip *chip = mtd->priv;
 	struct nand_flash_dev *type;
 
@@ -2759,8 +3044,11 @@ int nand_scan_ident(struct mtd_info *mtd, int maxchips)
 	nand_set_defaults(chip, busw);
 
 	/* Read the flash type */
+#ifdef CONFIG_NLM_XLP
+	type = xlp_nand_get_flash_type(mtd, chip, busw, &nand_dev_id, &nand_maf_id);
+#else
 	type = nand_get_flash_type(mtd, chip, busw, &nand_maf_id);
-
+#endif
 	if (IS_ERR(type)) {
 		if (!(chip->options & NAND_SCAN_SILENT_NODEV))
 			printk(KERN_WARNING "No NAND device found.\n");
@@ -2777,7 +3065,11 @@ int nand_scan_ident(struct mtd_info *mtd, int maxchips)
 		chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
 		/* Read manufacturer and device IDs */
 		if (nand_maf_id != chip->read_byte(mtd) ||
+#ifdef CONFIG_NLM_XLP
+		    nand_dev_id != chip->read_byte(mtd))
+#else
 		    type->id != chip->read_byte(mtd))
+#endif
 			break;
 	}
 	if (i > 1)
diff --git a/drivers/mtd/nand/xlp_plat_nand.c b/drivers/mtd/nand/xlp_plat_nand.c
new file mode 100644
index 0000000..a8b6944
--- /dev/null
+++ b/drivers/mtd/nand/xlp_plat_nand.c
@@ -0,0 +1,811 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems (âNetlogicâ?. All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+
+#ifdef CONFIG_NLM_XLP
+#include <asm/netlogic/hal/nlm_hal.h>
+#include <asm/netlogic/xlp.h>
+#endif
+#include "xlp_plat_nand.h"
+
+static int debug = 0;
+static int enable_hwecc = 1;
+
+#undef	NAND_DEBUG
+#define BUF_SIZE 		(16*1024)
+#define dbp_print		if(debug) printk
+#ifdef CONFIG_N511
+#define NAND_DEV_CS		0
+#else
+#define NAND_DEV_CS		1
+#endif
+#define DEFAULT_NUM_PARTITIONS	2
+
+static struct mtd_partition xlp_nand_partition_info[] = {
+        {
+        .name = "NAND FS 0",
+        .offset = 0,
+        .size = 8 * 64 * 2048,
+        },
+        {
+        .name = "NAND FS 1",
+        .offset = MTDPART_OFS_APPEND ,
+        .size = MTDPART_SIZ_FULL ,
+        },
+};
+	
+struct xlp_nand_data {
+        struct nand_chip        chip;
+        struct mtd_info         mtd;
+        void __iomem            *io_base;
+#ifdef CONFIG_MTD_PARTITIONS
+        int                     nr_parts;
+        struct mtd_partition    *parts;
+#endif
+};
+
+struct nand_state {
+        int cs ;
+        uint32_t col_cyc;
+        uint32_t row_cyc;
+        uint32_t page_size;
+        uint32_t block_size ;
+        uint32_t pages_per_block;
+        uint32_t spare_size ;
+        uint32_t last_cmd ;
+        int buf_ptr ;
+        u8* buf ;
+} ;
+
+static int column_prog = 0;
+static int page_prog = 0;
+static int waitfunc (struct mtd_info *mtd, struct nand_chip *chip) ;
+
+static __inline__ int32_t nand_reg_read(int node,  int regidx)
+{
+        volatile uint64_t mmio;
+        mmio = nlm_hal_get_dev_base(node, 0, XLP_PCIE_SPI_NOR_FLASH_DEV, XLP_PCIE_SPI_NAND);
+        return nlm_hal_read_32bit_reg(mmio, regidx);
+}
+
+static __inline__ int32_t nor_reg_read(int node,  int regidx)
+{
+        volatile uint64_t mmio;
+        mmio = nlm_hal_get_dev_base(node, 0, XLP_PCIE_SPI_NOR_FLASH_DEV, XLP_PCIE_SPI_NOR);
+        return nlm_hal_read_32bit_reg(mmio, regidx);
+}
+
+static __inline__ void nand_reg_write(int node, int regidx, int32_t val)
+{
+        volatile uint64_t mmio;
+        mmio = nlm_hal_get_dev_base(node, 0, XLP_PCIE_SPI_NOR_FLASH_DEV, XLP_PCIE_SPI_NAND);
+        nlm_hal_write_32bit_reg(mmio, regidx, val);
+}
+
+
+static int dma_wait(int cs)
+{
+        int timeout = 0xfffff ;
+        while ( ( (nand_reg_read(0, NAND_STATUS) & (1 << cs) ) == 0) ||
+                ( (nand_reg_read(0, NAND_DMA_CTRL) & 0x01) == 0) )  {
+
+                timeout--;
+                if (timeout == 0) {
+                        dbp_print("DMA timed out NAND_STATUS:%x\n",nand_reg_read(0,NAND_STATUS)) ;
+                        return -1 ;
+                }
+        }
+        return 0;
+}
+
+#ifdef NAND_DEBUG
+static void print_oob_data(const unsigned char* p)
+{
+	int i;
+
+	if(!p)
+		return;
+
+	for(i = 0; i < 256; i++) {
+		printk("%02x",p[i]);
+		if((i % 16) == 0xf)
+			printk("\n");
+	}
+        printk("\n");
+}
+
+static void print_onfi_params(struct nand_onfi_params * p)
+{
+	printk("OFNI parameter \n"); 
+	printk("rev info and features block\n");
+	printk("revision:%d\n", le16_to_cpu(p->revision));
+	printk("features:%x\n", p->features);
+	printk("opt_cmd::%x\n", p->opt_cmd);
+
+	printk("\n memory organization block \n");
+
+
+	printk("byte_per_page:%d\n",le32_to_cpu(p->byte_per_page));
+	printk("spare_bytes_per_page: %d\n", le16_to_cpu(p->spare_bytes_per_page));
+	printk("data_bytes_per_ppage: %d\n", le32_to_cpu(p->data_bytes_per_ppage));
+	printk("spare_bytes_per_ppage: %d\n", le16_to_cpu(p->spare_bytes_per_ppage));
+	printk("pages_per_block: %d\n", le32_to_cpu(p->pages_per_block));
+	printk("blocks_per_lun: %d\n", le32_to_cpu(p->blocks_per_lun));
+	printk("lun_count: %d\n", p->lun_count);
+	printk("addr_cycles: %d\n", p->addr_cycles);
+	printk("bits_per_cell: %d\n", p->bits_per_cell);
+	printk("bb_per_lun: %d\n",  le16_to_cpu(p->bb_per_lun));
+	printk("block_endurance: %d\n",  le16_to_cpu(p->block_endurance));
+	printk("guaranteed_good_blocks: %d\n", p->guaranteed_good_blocks);
+	printk("guaranteed_block_endurance: %d\n", le16_to_cpu(p->guaranteed_block_endurance));
+	printk("programs_per_page: %d\n", p->programs_per_page);
+	printk("ppage_attr: %d\n", p->ppage_attr);
+	printk("ecc_bits: %d\n", p->ecc_bits);
+	printk("interleaved_bits: %d\n", p->interleaved_bits);
+	printk("interleaved_ops: %d\n", p->interleaved_ops);
+
+	printk("\nelectrical parameter block\n");
+	printk("io_pin_capacitance_max: %d\n", p->io_pin_capacitance_max);
+	printk("async_timing_mode: %d\n", p->async_timing_mode);
+	printk("program_cache_timing_mode: %d\n", p->program_cache_timing_mode);
+	printk("t_prog: %d\n", p->t_prog);
+	printk("t_bers: %d\n", p->t_bers);
+	printk("t_r: %d\n", p->t_r);
+	printk("t_ccs: %d\n", p->t_ccs);
+	printk("src_sync_timing_mode: %d\n", p->src_sync_timing_mode);
+	printk("src_ssync_features: %d\n", p->src_ssync_features);
+	printk("clk_pin_capacitance_typ: %d\n", p->clk_pin_capacitance_typ);
+	printk("io_pin_capacitance_typ: %d\n", p->io_pin_capacitance_typ);
+	printk("input_pin_capacitance_typ: %d\n", p->input_pin_capacitance_typ);
+	printk("input_pin_capacitance_max: %d\n", p->input_pin_capacitance_max);
+	printk("driver_strenght_support: %d\n", p->driver_strenght_support);
+	printk("t_int_r: %d\n", p->t_int_r);
+	printk("t_ald: %d\n", p->t_ald);        
+	printk("crc: %x\n", p->crc);
+
+	printk("\nmanufacturer information block\n");
+	printk("manufacturer: %s\n", p->manufacturer);
+	printk("model: %s\n",  p->model);
+	printk("jedec_id: %x\n",         p->jedec_id);
+	printk("date_code: %x\n", p->date_code);
+
+	return;
+}
+#endif
+
+void onfi_init(struct nand_chip *chip)
+{
+        struct nand_state *state = chip->priv;
+        u8* param_ptr = state->buf ;
+        uint32_t page_val ;
+        uint32_t block_val;
+        uint32_t addr_cyc,addr_val ;
+        uint32_t spare_bytes_per_512 ;
+        uint32_t ecc_bytes ;
+        uint32_t ecc_bits ;
+        uint32_t ecc_val ;
+        uint32_t val ;
+        uint32_t ecc_offset;
+        int i ;
+
+#ifdef NAND_DEBUG
+	print_oob_data(state->buf);
+#endif
+        state->page_size = ( (unsigned int) (param_ptr[80] << 0)  |
+                             (unsigned int) (param_ptr[81] << 8)  |
+                             (unsigned int) (param_ptr[82] << 16) |
+                             (unsigned int) (param_ptr[83] << 24) ) ;
+
+        switch (state->page_size) {
+        case 256:  page_val = 0; break;
+        case 512:  page_val = 1; break;
+        case 1024: page_val = 2; break;
+        case 2048: page_val = 3; break;
+        case 4096: page_val = 4; break;
+        case 8192: page_val = 5; break;
+        case 16384: page_val = 6; break;
+        default: page_val = 7; break;
+        }
+
+        state->pages_per_block  = ( (unsigned int) (param_ptr[92] << 0)  |
+                                    (unsigned int) (param_ptr[93] << 8)  |
+                                    (unsigned int) (param_ptr[94] << 16) |
+                                    (unsigned int) (param_ptr[95] << 24) ) ;
+
+        state->block_size = state->pages_per_block * state->page_size ;
+
+
+        switch (state->pages_per_block) {
+        case 32:  block_val = 0; break;
+        case 64:  block_val = 1; break;
+        case 128: block_val = 2; break;
+        case 256: block_val = 3; break;
+        default: block_val = -1 ; break;
+        }
+
+        addr_cyc = param_ptr[101] ;
+        state->row_cyc = (addr_cyc & 0xf) ;
+        state->col_cyc = ( (addr_cyc >> 4) & 0xf) ;
+        addr_val = state->row_cyc + state->col_cyc ;
+
+        state->spare_size = ( (unsigned int) (param_ptr[84] << 0)  |
+                              (unsigned int) (param_ptr[85] << 8) ) ;
+
+        spare_bytes_per_512 = state->spare_size/(state->page_size/512) ;
+
+        if (spare_bytes_per_512 <= 4) {
+                ecc_bytes = 0 ;
+                ecc_bits  = 0 ;
+                ecc_val   = 0 ;
+        } else if (spare_bytes_per_512 <= 8) {
+                ecc_bytes = 4 ;
+                ecc_bits  = 2 ;
+                ecc_val   = 0 ;
+        } else if (spare_bytes_per_512 <= 16) {
+                ecc_bytes = 13 ;
+                ecc_bits  = 8 ;
+                ecc_val   = 3 ;
+        } else if (spare_bytes_per_512 <= 24) {
+                ecc_bytes = 20 ;
+                ecc_bits  = 12 ;
+                ecc_val   = 5 ;
+        } else {
+                ecc_bytes = 23 ;
+                ecc_bits  = 14 ;
+                ecc_val   = 6 ;
+        }
+        ecc_offset = state->spare_size - ( (state->page_size/512) * ecc_bytes);
+
+
+	if(enable_hwecc)
+	{
+		nand_reg_write(0, NAND_ECC_CTRL, (ecc_val << 5));
+		nand_reg_write(0, NAND_ECC_OFFSET, state->page_size + ecc_offset);
+	
+		val = nand_reg_read(0, NAND_CTRL);
+		val |= (NAND_CTRL_ECC_EN(1)		|
+			NAND_CTRL_PAGE_SIZE(page_val)	|
+			NAND_CTRL_BLOCK_SIZE(block_val)	|
+			NAND_CTRL_ADDR_CYCLE(addr_val))	;
+		nand_reg_write(0, NAND_CTRL, val);
+
+		chip->ecc.size   = 512;
+		chip->ecc.bytes  = ecc_bytes;
+		chip->ecc.steps	 = state->page_size / 512;
+		chip->ecc.total	 = chip->ecc.steps * chip->ecc.bytes;
+		chip->ecc.layout = kmalloc(sizeof(struct nand_ecclayout), GFP_KERNEL);
+		chip->ecc.layout->eccbytes = ecc_bytes;
+
+		for (i=0; i < ecc_bytes; i++) {
+			chip->ecc.layout->eccpos[i] = ecc_offset + i;
+		}
+		chip->ecc.layout->oobfree[0].offset = 2 ;
+		chip->ecc.layout->oobfree[0].length = state->spare_size - chip->ecc.layout->eccbytes*chip->ecc.steps - 2;
+	}
+	else
+	{
+		val = nand_reg_read(0, NAND_CTRL);
+		val |= (NAND_CTRL_ECC_EN(0)		|
+			NAND_CTRL_PAGE_SIZE(page_val)	|
+			NAND_CTRL_BLOCK_SIZE(block_val)	|
+			NAND_CTRL_ADDR_CYCLE(addr_val))	;
+		nand_reg_write(0, NAND_CTRL, val);
+	}
+}
+
+
+
+#ifdef NAND_DEBUG
+static void nand_dump_reg(void)
+{
+	int i;
+
+	for(i = 0; i < 6; i++) {
+		printk("nand 0x%0x = 0x%8x\n", i, nand_reg_read(0,i));
+	}
+
+	for(i = 0x30; i < 0x4A; i++) {
+		printk("nand 0x%0x = 0x%8x\n", i, nand_reg_read(0,i));
+	}
+
+	for(i = 0x50; i < 0x5C; i++) {
+		printk("nand 0x%0x = 0x%8x\n", i, nand_reg_read(0,i));
+	}
+	for(i = 0x60; i < 0x70; i++) {
+		printk("nand 0x%0x = 0x%8x\n", i, nand_reg_read(0,i));
+	}
+
+	for(i = 0x80; i < 0x82; i++) {
+		printk("nand 0x%0x = 0x%8x\n", i, nand_reg_read(0,i));
+	}
+}
+
+static void nand_dump_ioreg( uint32_t * ioaddr)
+{
+	int i;
+	if(!ioaddr)
+		return;
+	for(i = 0; i < 12; i++)
+		printk("nand 0x%0x = 0x%8x\n", i, ioaddr[i]);
+	for(i = 25; i < 39; i++)
+		printk("nand 0x%0x = 0x%8x\n", i, ioaddr[i]);
+
+}
+#endif
+
+static void send_cmd(struct mtd_info *mtd,
+                     unsigned int command,
+                     int column,
+                     int page_addr,
+                     int len)
+{
+        struct nand_chip *chip = mtd->priv;
+        struct nand_state *state = chip->priv;
+	uint64_t val;
+
+        nand_reg_write(0, NAND_DATA_SIZE, len);
+        nand_reg_write(0, NAND_DMA_CNT, len);
+
+	val = (page_addr >> (32 - (state->col_cyc * 8)));
+        nand_reg_write(0, NAND_ADDR1_L, val);
+	val = ( (page_addr << (state->col_cyc * 8) ) | column);
+        nand_reg_write(0, NAND_ADDR0_L, val) ;
+	val = virt_to_phys((void *) state->buf) + state->buf_ptr;
+        nand_reg_write(0, NAND_DMA_ADDR, val);
+	nand_reg_write(0, NAND_DMA_ADDR_H, (val >> 32));
+
+        if ( (command == NAND_READ_PAGE_CMD) ||
+             (command == NAND_READ_ID_CMD)   ||
+             (command == NAND_READ_PARAMETER_CMD) ) {
+                nand_reg_write(0, NAND_DMA_CTRL, (1 << 7) | (1 << 6) | (5 << 2));
+        } else {
+                nand_reg_write(0, NAND_DMA_CTRL, (1 << 7) | (0 << 6) | (5 << 2));
+        }
+
+        if ((column + len) > mtd->writesize) {
+		val = nand_reg_read(0, NAND_CTRL);
+                nand_reg_write(0, NAND_CTRL, (val & ~NAND_CTRL_ECC_EN(1)));
+        }
+
+        nand_reg_write(0, NAND_CMD, command | NAND_CMD_DMA_FLAG);
+        dma_wait(state->cs);
+	val = nand_reg_read(0, NAND_CTRL);
+        nand_reg_write(0, NAND_CTRL, (val | NAND_CTRL_ECC_EN(1)));
+
+        state->last_cmd    = command;
+}
+
+static void cmdfunc(struct mtd_info *mtd,
+                    unsigned int command,
+                    int column,
+                    int page_addr)
+{
+        struct nand_chip *chip = mtd->priv;
+        struct nand_state *state = chip->priv;
+        int len = 0 ;
+        uint32_t val;
+
+        if (state->cs < 0)
+                return;
+
+        switch (command) {
+	/*
+	 * READ0 - read in first  256 bytes
+	 * READ1 - read in second 256 bytes
+	 */
+        case NAND_CMD_READ1:
+                column += 256;
+        case NAND_CMD_READ0:
+                state->buf_ptr = 0;
+                send_cmd(mtd,
+                         NAND_READ_PAGE_CMD,
+                         column,
+                         page_addr,
+                         mtd->writesize);
+                state->buf_ptr += mtd->writesize;
+                send_cmd(mtd,
+                         NAND_READ_PAGE_CMD,
+                         (mtd->writesize + column),
+                         page_addr,
+                         (mtd->oobsize - column));
+                state->buf_ptr = 0;
+		break;
+        /* READOOB reads only the OOB because no ECC is performed. */
+        case NAND_CMD_READOOB:
+               dbp_print("NAND_CMD_READOOB, "
+                    "page_addr: 0x%x, column: 0x%x oobsize: 0x%x.\n",
+                    page_addr, column, mtd->oobsize);
+                state->buf_ptr = 0;
+                send_cmd(mtd,
+                         NAND_READ_PAGE_CMD,
+                         (mtd->writesize + column),
+                         page_addr,
+                         (mtd->oobsize - column));
+                state->buf_ptr = 0;
+		break;
+        /* READID must read all 5 possible bytes while CEB is active */
+        case NAND_CMD_READID:
+                state->buf_ptr = 0;
+                send_cmd(mtd,
+                         NAND_READ_ID_CMD,
+                         column,
+                         0,
+                         8);
+                state->buf_ptr = 0;
+		break;
+        case NAND_CMD_PARAM:
+                state->buf_ptr = 0;
+                send_cmd(mtd,
+                         NAND_READ_PARAMETER_CMD,
+                         0,
+                         0,
+                         1024);
+                onfi_init(chip);
+		break;
+        /* ERASE1 stores the block and page address */
+        case NAND_CMD_ERASE1:
+                dbp_print("NAND_CMD_ERASE1, "
+                    "page_addr: 0x%x, column: 0x%x.\n",
+                    page_addr, column);
+                val = (page_addr >> (32 - (state->col_cyc*8)));
+		nand_reg_write(0, NAND_ADDR1_L, val);
+                val = ((page_addr << (state->col_cyc * 8)));
+		nand_reg_write(0, NAND_ADDR0_L, val);
+		break;
+        /* ERASE2 uses the block and page address from ERASE1 */
+        case NAND_CMD_ERASE2:
+                dbp_print("NAND_CMD_ERASE2, "
+                    "addr 0x%x\n",
+		nand_reg_read(0, NAND_ADDR0_L));
+		nand_reg_write(0, NAND_CMD, NAND_ERASE_BLOCK_CMD);
+		state->last_cmd         = NAND_ERASE_BLOCK_CMD ;
+		waitfunc(mtd,chip) ;
+		break;
+        /* SEQIN sets up the addr buffer and all registers except the length */
+        case NAND_CMD_SEQIN:
+                dbp_print("NAND_CMD_SEQIN/PAGE_PROG, "
+                       "page_addr: 0x%x, column: 0x%x.\n",
+                       page_addr, column);
+                column_prog    = column;
+                page_prog      = page_addr;
+                state->buf_ptr = 0;
+		break;
+        /* PAGEPROG reuses all of the setup from SEQIN and adds the length */
+        case NAND_CMD_PAGEPROG:
+                len = state->buf_ptr;
+                state->buf_ptr = 0;
+                dbp_print("PAGE_PROG: page 0x%x col 0x%x size %d \n",page_prog,column_prog,len);
+                send_cmd(mtd,
+                         NAND_PAGE_PROGRAM_CMD,
+                         column_prog,
+                         page_prog,
+                         len);
+                waitfunc(mtd,chip);
+		break;
+
+        case NAND_CMD_STATUS:
+                nand_reg_write(0, NAND_CMD, NAND_READ_STATUS_CMD);
+                state->last_cmd = NAND_READ_STATUS_CMD;
+                dbp_print("Status read\n");
+		break;
+        /* RESET command */
+        case NAND_CMD_RESET:
+                nand_reg_write(0, NAND_CMD, NAND_RESET_CMD);
+                state->last_cmd = NAND_RESET_CMD;
+                waitfunc(mtd,chip);
+		break;
+
+        default:
+                dbp_print("netl8xx_nand: unsupported command 0x%x\n",command);
+        }
+}
+
+static void select_chip(struct mtd_info *mtd, int dev)
+{
+        struct nand_chip *chip = mtd->priv;
+        struct nand_state *state = chip->priv;
+        if ( (dev >= 0) && (dev < 8) ) {
+                nand_reg_write(0, NAND_MEMCTRL, dev + NAND_DEV_CS);
+		state->cs = dev + NAND_DEV_CS;
+        } else {
+                state->cs = -1;
+        }
+}
+
+static uint8_t read_byte(struct mtd_info *mtd)
+{
+        struct nand_chip *chip = mtd->priv;
+        struct nand_state *state = chip->priv;
+        uint32_t data ;
+
+        if (state->cs < 0)
+                return 0;
+
+        if (state->last_cmd == NAND_READ_STATUS_CMD) {
+                data = nand_reg_read(0, NAND_READ_STATUS);
+                dbp_print("Status: %x\n",data);
+                return nand_reg_read(0, NAND_READ_STATUS);
+        } else {
+                data = state->buf[state->buf_ptr];
+                state->buf_ptr = (state->buf_ptr+1)%BUF_SIZE;
+                return data;
+        }
+}
+
+static void read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
+{
+        struct nand_chip *chip = mtd->priv;
+        struct nand_state *state = chip->priv;
+        int i;
+
+        if (state->cs < 0)
+                return;
+
+        dbp_print("read_buf %p %d %d\n", buf, state->buf_ptr, len);
+        for (i = 0; i < len; i++) {
+                buf[i] = state->buf[state->buf_ptr];
+                state->buf_ptr = (state->buf_ptr + 1) % BUF_SIZE;
+        }
+        return;
+}
+
+static void write_buf(struct mtd_info *mtd, const u8 *buf, int len)
+{
+        int i=0;
+        struct nand_chip *chip = mtd->priv;
+        struct nand_state *state = chip->priv;
+
+        if (state->cs < 0)
+                return;
+
+        dbp_print("write_buf %p %d %d\n",buf,state->buf_ptr,len);
+        while (len > 0) {
+                state->buf[state->buf_ptr] = buf[i++];
+                len--;
+                state->buf_ptr = (state->buf_ptr + 1) % BUF_SIZE;
+        }
+}
+
+static int read_page(struct mtd_info *mtd,
+                     struct nand_chip *chip,
+                     uint8_t *buf, int page)
+{
+        struct nand_state *state = chip->priv;
+
+        if (state->cs < 0)
+                return -1;
+
+        dbp_print ("Read page %s\n",buf);
+        read_buf(mtd, buf, mtd->writesize);
+
+        return 0;
+}
+
+static void write_page(struct mtd_info *mtd,
+                       struct nand_chip *chip,
+                       const uint8_t *buf)
+{
+        struct nand_state *state = chip->priv;
+
+        if (state->cs < 0)
+                return;
+        dbp_print ("Write page %p\n",buf);
+        write_buf(mtd, buf, mtd->writesize);
+}
+
+static int waitfunc(struct mtd_info *mtd, struct nand_chip *chip)
+{
+        struct nand_state *state = chip->priv;
+        int timeout = 0xfffff;
+        uint32_t val;
+
+        if (state->cs < 0)
+                return -1;
+		val = nand_reg_read(0, NAND_STATUS);
+        while ((val & (1 << state->cs)) == 0) {
+                timeout--;
+                if (timeout == 0) {
+                        dbp_print("wait func out\n");
+                        return -1 ;
+                }
+			val = nand_reg_read(0, NAND_STATUS);
+	}
+
+        nand_reg_write(0, NAND_CMD, NAND_READ_STATUS_CMD);
+        return nand_reg_read(0, NAND_READ_STATUS);
+}
+
+/*
+ * Probe for the NAND device.
+ */
+static int __devinit xlp_plat_nand_probe(struct platform_device *pdev)
+{
+        struct xlp_nand_data *data;
+        struct nand_state *state ;
+        int res = 0;
+        uint32_t val;
+
+	/* nand_dump_reg();*/
+		
+        /* Allocate memory for the device structure (and zero it) */
+        data = kzalloc(sizeof(struct xlp_nand_data), GFP_KERNEL);
+        if (!data) {
+                dev_err(&pdev->dev, "failed to allocate device structure.\n");
+                return -ENOMEM;
+        }
+
+	pdev->resource[0].end	= pdev->resource[0].start + 0x1000 -1;
+        data->io_base = ioremap(pdev->resource[0].start + 0x100,
+                                pdev->resource[0].end - pdev->resource[0].start + 1);
+        if (data->io_base == NULL) {
+                dev_err(&pdev->dev, "ioremap failed\n");
+                kfree(data);
+                return -EIO;
+        }
+	/* nand_dump_ioreg((uint32_t*)  data->io_base);*/
+
+        nand_reg_write(0, NAND_CTRL, NAND_CTRL_CUSTOM_XFER_FLAG);
+
+        val = ( NAND_TIME_SEQ0_TWHR(7) |
+		NAND_TIME_SEQ0_TRHW(7) |
+		NAND_TIME_SEQ0_TADL(7) |
+		NAND_TIME_SEQ0_TCCS(7) );
+
+	nand_reg_write(0, NAND_TIME_SEQ0, val);
+
+        val = NAND_TIME_ASYN_TRWH(8) | NAND_TIME_ASYN_TRWP(8);
+	nand_reg_write(0, NAND_TIMINGS_ASYN, val);
+
+        state            = kmalloc(sizeof(struct nand_state), GFP_KERNEL);
+        state->last_cmd  = 0;
+        state->cs        = 0;
+        state->buf_ptr   = 0 ;
+        state->buf       = kmalloc(BUF_SIZE, GFP_KERNEL);
+
+        data->chip.priv = state;
+        data->mtd.priv = &data->chip;
+        data->mtd.owner = THIS_MODULE;
+        data->mtd.name = dev_name(&pdev->dev);
+	data->mtd.oobsize = 64;
+
+        data->chip.IO_ADDR_R = data->io_base;
+        data->chip.IO_ADDR_W = data->io_base;
+
+        data->chip.read_byte   	= read_byte ;
+        data->chip.write_buf 	= write_buf;
+        data->chip.read_buf 	= read_buf;
+        data->chip.verify_buf  	= NULL ;
+        data->chip.select_chip 	= select_chip;
+        data->chip.cmdfunc	= cmdfunc ;
+        data->chip.waitfunc	= waitfunc ;
+        data->chip.chip_delay	= 15;
+
+        data->chip.options      = NAND_NO_READRDY | NAND_NO_AUTOINCR | NAND_USE_FLASH_BBT ;
+	if(enable_hwecc)
+	        data->chip.ecc.mode = NAND_ECC_HW;
+	else
+		data->chip.ecc.mode = NAND_ECC_SOFT;
+
+        data->chip.ecc.read_page  = read_page;
+        data->chip.ecc.write_page = write_page;
+
+        platform_set_drvdata(pdev, data);
+
+        if (nand_scan(&data->mtd, 1)) {
+                res = -ENXIO;
+                goto out;
+        }
+
+#ifdef NAND_DEBUG
+	print_onfi_params(&data->chip.onfi_params);
+#endif
+
+#ifdef CONFIG_MTD_PARTITIONS
+	if (mtd_has_partitions()) {
+                if (mtd_has_cmdlinepart()) {
+                        static const char *part_probes[] = { "cmdlinepart", NULL, };
+                        data->nr_parts = parse_mtd_partitions(&data->mtd, part_probes, &data->parts, 0);
+                }
+                if(data->nr_parts <= 0)
+                {
+                        data->nr_parts = ARRAY_SIZE(xlp_nand_partition_info);
+                        if(!data->parts)
+                                data->parts = xlp_nand_partition_info;
+                }
+                if(data->nr_parts > 0)
+                {
+			/* Register the partitions */
+                        res = add_mtd_partitions(&data->mtd, data->parts, data->nr_parts);
+                }
+        }
+	else
+#endif
+		res = add_mtd_device(&data->mtd);
+
+        if (!res)
+                return res;
+
+        nand_release(&data->mtd);
+out:
+        platform_set_drvdata(pdev, NULL);
+        iounmap(data->io_base);
+        kfree(data);
+        return res;
+}
+
+/*
+ * Remove a NAND device.
+ */
+static int __devexit xlp_plat_nand_remove(struct platform_device *pdev)
+{
+        struct xlp_nand_data *data = platform_get_drvdata(pdev);
+        struct platform_nand_data *pdata = pdev->dev.platform_data;
+
+        nand_release(&data->mtd);
+#ifdef CONFIG_MTD_PARTITIONS
+        if (data->parts && data->parts != pdata->chip.partitions)
+                kfree(data->parts);
+#endif
+        if (pdata->ctrl.remove)
+                pdata->ctrl.remove(pdev);
+        iounmap(data->io_base);
+        kfree(data);
+
+        return 0;
+}
+
+static struct platform_driver xlp_plat_nand_driver = {
+        .probe          = xlp_plat_nand_probe,
+        .remove         = __devexit_p(xlp_plat_nand_remove),
+        .driver         = {
+                .name   = "nand-xlp",
+                .owner  = THIS_MODULE,
+        },
+};
+
+static int __init xlp_plat_nand_init(void)
+{
+        return platform_driver_register(&xlp_plat_nand_driver);
+}
+static void __exit xlp_plat_nand_exit(void)
+{
+        platform_driver_unregister(&xlp_plat_nand_driver);
+}
+
+module_init(xlp_plat_nand_init);
+module_exit(xlp_plat_nand_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Netlogicmicro System");
+MODULE_DESCRIPTION("XLP NAND platform driver");
+MODULE_ALIAS("platform:nand-xlp");
+
diff --git a/drivers/mtd/nand/xlp_plat_nand.h b/drivers/mtd/nand/xlp_plat_nand.h
new file mode 100644
index 0000000..1ad7ae2
--- /dev/null
+++ b/drivers/mtd/nand/xlp_plat_nand.h
@@ -0,0 +1,97 @@
+/***********************************************************************
+ * Copyright 2003-2010 Netlogic Microsystems (â~@~\Netlogicâ~@?. All rights
+ * reserved.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in
+ * the documentation and/or other materials provided with the
+ * distribution.
+ * THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * *****************************#NETL_2#********************************/
+#ifndef _XLP_NAND_H
+#define _XLP_NAND_H
+
+#define NAND_CMD		0x40
+#define NAND_CTRL		0x41
+#define NAND_STATUS		0x42
+#define NAND_INTMASK		0x43
+#define NAND_INT_STATUS		0x44
+#define	NAND_ECC_CTRL		0x45
+#define NAND_ECC_OFFSET		0x46
+#define NAND_ADDR0_L		0x47
+#define NAND_ADDR0_H		0x49
+#define NAND_ADDR1_L		0x48
+#define NAND_ADDR1_H		0x4A
+#define NAND_SPARE_SIZE		0x4B
+#define NAND_DMA_ADDR		0x59
+#define NAND_DMA_CNT		0x5A
+#define NAND_DMA_CTRL		0x5B
+#define NAND_MEMCTRL		0x60
+#define NAND_DATA_SIZE		0x61
+#define NAND_READ_STATUS	0x62
+#define NAND_TIME_SEQ0		0x63
+#define NAND_TIMINGS_ASYN	0x64
+#define NAND_TIMINGS_SYN	0x65
+#define NAND_FIFO_DATA		0x66
+#define NAND_TIME_MODE		0x67
+#define NAND_DMA_ADDR_H		0x68
+#define NAND_FIFO_INIT		0x6C
+#define NAND_GENERIC_SEQ	0x6D
+#define NAND_FIFO_STATE		0x6E
+#define NAND_TIME_SEQ1		0x6F
+
+#define NAND_SYSCTRL		0x80
+#define NAND_RYBYSEL		0x81
+
+/*                                     CMD 3         CMD 2          CMD 1         SEQ */
+#define NAND_RESET_CMD              ( (0x0  << 24) | (0x0  << 16) | (0xFF << 8) | 0x0)
+#define NAND_READ_PARAMETER_CMD     ( (0x0  << 24) | (0x0  << 16) | (0xEC << 8) | 0x22)
+#define NAND_READ_ID_CMD            ( (0x0  << 24) | (0x0  << 16) | (0x90 << 8) | 0x21)
+#define NAND_READ_PAGE_CMD          ( (0x0  << 24) | (0x30 << 16) | (0x00 << 8) | 0x2a)
+#define NAND_ERASE_BLOCK_CMD        ( (0x0  << 24) | (0xD0 << 16) | (0x60 << 8) | 0xe)
+#define NAND_PAGE_PROGRAM_CMD       ( (0x0  << 24) | (0x10 << 16) | (0x80 << 8) | 0xc)
+#define NAND_READ_STATUS_CMD        ( (0x0  << 24) | (0x00 << 16) | (0x70 << 8) | 0x24)
+
+#define NAND_CMD_DMA_FLAG   (1<<6)
+#define NAND_CMD_ADDR1_FLAG (1<<7)
+
+#define NAND_CTRL_X16_FLAG (1<<12)
+#define NAND_CTRL_CUSTOM_XFER_FLAG (1<<11)
+#define NAND_CTRL_PAGE_SIZE(size) (size<<8)
+#define NAND_CTRL_BLOCK_SIZE(size) (size<<6)
+#define NAND_CTRL_ADDR_CYCLE(cyc) (cyc<<0)
+#define NAND_CTRL_ECC_EN(en) (en<<5)
+#define NAND_CTRL_SPARE_EN(en) (en<<3)
+
+/*Sync mode WE High->RE Low*/
+#define NAND_TIME_SEQ0_TWHR(x) (x<<24)
+/*ASync mode RE High->WE Low*/
+#define NAND_TIME_SEQ0_TRHW(x) (x<<16)
+/*Async ALE->Data start*/
+#define NAND_TIME_SEQ0_TADL(x) (x<<8)
+/*Chance column setup*/
+#define NAND_TIME_SEQ0_TCCS(x) (x<<0)
+/*TRR time peroid*/
+#define NAND_TIME_SEQ1_TRR(x) (x<<9)
+/*Busy time peroid for async->sync*/
+#define NAND_TIME_SEQ1_TWB(x) (x<<0)
+/*RE/WE high hold time*/
+#define NAND_TIME_ASYN_TRWH(x) (x<<4)
+/*RE/WE pulse width*/
+#define NAND_TIME_ASYN_TRWP(x) (x<<0)
+
+#endif
diff --git a/include/linux/mtd/nand.h b/include/linux/mtd/nand.h
index ccab9df..feb6eb9 100644
--- a/include/linux/mtd/nand.h
+++ b/include/linux/mtd/nand.h
@@ -82,6 +82,11 @@ extern void nand_wait_ready(struct mtd_info *mtd);
 #define NAND_CMD_ERASE2		0xd0
 #define NAND_CMD_RESET		0xff
 
+#ifdef CONFIG_NLM_XLP
+#define NAND_CMD_PARAM		0xEC
+#define NAND_CMD_LOCK		0x2a
+#endif
+
 /* Extended commands for large page devices */
 #define NAND_CMD_READSTART	0x30
 #define NAND_CMD_RNDOUTSTART	0xE0
@@ -209,6 +214,71 @@ typedef enum {
 /* Keep gcc happy */
 struct nand_chip;
 
+#ifdef CONFIG_NLM_XLP
+struct nand_onfi_params {
+        /* rev info and features block */
+        /* 'O' 'N' 'F' 'I'  */
+        u8 sig[4];
+        __le16 revision;
+        __le16 features;
+        __le16 opt_cmd;
+        u8 reserved[22];
+
+        /* manufacturer information block */
+        char manufacturer[12];
+        char model[20];
+        u8 jedec_id;
+        __le16 date_code;
+        u8 reserved2[13];
+
+        /* memory organization block */
+        __le32 byte_per_page;
+        __le16 spare_bytes_per_page;
+        __le32 data_bytes_per_ppage;
+        __le16 spare_bytes_per_ppage;
+        __le32 pages_per_block;
+        __le32 blocks_per_lun;
+        u8 lun_count;
+        u8 addr_cycles;
+        u8 bits_per_cell;
+        __le16 bb_per_lun;
+        __le16 block_endurance;
+        u8 guaranteed_good_blocks;
+        __le16 guaranteed_block_endurance;
+        u8 programs_per_page;
+        u8 ppage_attr;
+        u8 ecc_bits;
+        u8 interleaved_bits;
+        u8 interleaved_ops;
+        u8 reserved3[13];
+
+        /* electrical parameter block */
+        u8 io_pin_capacitance_max;
+        __le16 async_timing_mode;
+        __le16 program_cache_timing_mode;
+        __le16 t_prog;
+        __le16 t_bers;
+        __le16 t_r;
+        __le16 t_ccs;
+        __le16 src_sync_timing_mode;
+        __le16 src_ssync_features;
+        __le16 clk_pin_capacitance_typ;
+        __le16 io_pin_capacitance_typ;
+        __le16 input_pin_capacitance_typ;
+        u8 input_pin_capacitance_max;
+        u8 driver_strenght_support;
+        __le16 t_int_r;
+        __le16 t_ald;
+        u8 reserved4[7];
+
+        /* vendor */
+        u8 reserved5[90];
+
+        __le16 crc;
+} __attribute__((packed));
+
+#define ONFI_CRC_BASE  0x4F4E
+#endif
 /**
  * struct nand_hw_control - Control structure for hardware controller (e.g ECC generator) shared among independent devices
  * @lock:               protection lock
@@ -392,6 +462,10 @@ struct nand_chip {
 	uint8_t		cellinfo;
 	int		badblockpos;
 
+#ifdef CONFIG_NLM_XLP
+        int             onfi_version;
+        struct nand_onfi_params onfi_params;
+#endif
 	flstate_t	state;
 
 	uint8_t		*oob_poi;
-- 
1.7.0

