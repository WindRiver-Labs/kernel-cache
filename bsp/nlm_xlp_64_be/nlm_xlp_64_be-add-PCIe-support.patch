From 20e12705c6aba7635f67a9238b5c73c893e118f7 Mon Sep 17 00:00:00 2001
From: Wu Zhangjin <zhangjin.wu@windriver.com>
Date: Thu, 7 Apr 2011 14:19:51 +0800
Subject: [PATCH 22/37] nlm_xlp_64_be: add PCIe support

[ Based on netlogic SDK 20110329 ]

Add support for PCIE Controller.

Signed-off-by: Zi Shen Lim <zlim@netlogicmicro.com>
Signed-off-by: Om Narasimhan <onarasimhan@netlogicmicro.com>
[ o Set io_map_base to make standard IO operations can be used directly.
  o Fix up the irqs for PCIe slots
The irqs of PCIe slots are defined in irt_irq_table, which should be
referenced with the real PCIe link index(from 0 to 3) and the slot
number are related to the bus number of PCIe bridges(slot number = bus
number, from 1 to 4), therefore:

	hwslot = dev->bus->number;
	irq = irt_irq_table[PIC_IRT_PCIE_LINK_INDEX(hwslot - 1)][0];

Note: The slot argument passed by pcibios_map_irq() is not the real slot
number of the hardware slot. Herein, to reference the hardware PCIe
slots, use bus number instead for these slots are PCI bridges on the
virtual PCIe root bus. ]
Signed-off-by: Wu Zhangjin <zhangjin.wu@windriver.com>
---
 arch/mips/pci/Makefile  |    1 +
 arch/mips/pci/pci-xlp.c |  252 +++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 253 insertions(+), 0 deletions(-)
 create mode 100644 arch/mips/pci/pci-xlp.c

diff --git a/arch/mips/pci/Makefile b/arch/mips/pci/Makefile
index c9209ca..2380a16 100644
--- a/arch/mips/pci/Makefile
+++ b/arch/mips/pci/Makefile
@@ -52,6 +52,7 @@ obj-$(CONFIG_TOSHIBA_RBTX4927)	+= fixup-rbtx4927.o
 obj-$(CONFIG_TOSHIBA_RBTX4938)	+= fixup-rbtx4938.o
 obj-$(CONFIG_VICTOR_MPC30X)	+= fixup-mpc30x.o
 obj-$(CONFIG_ZAO_CAPCELLA)	+= fixup-capcella.o
+obj-$(CONFIG_NLM_XLP)  	+= pci-xlp.o
 obj-$(CONFIG_WR_PPMC)		+= fixup-wrppmc.o
 obj-$(CONFIG_MIKROTIK_RB532)	+= pci-rc32434.o ops-rc32434.o fixup-rc32434.o
 obj-$(CONFIG_CPU_CAVIUM_OCTEON)	+= pci-octeon.o pcie-octeon.o
diff --git a/arch/mips/pci/pci-xlp.c b/arch/mips/pci/pci-xlp.c
new file mode 100644
index 0000000..495ff69
--- /dev/null
+++ b/arch/mips/pci/pci-xlp.c
@@ -0,0 +1,252 @@
+/***********************************************************************
+Copyright (C) 2011 Wind River Systems, Inc.
+Author: Wu Zhangjin <zhangjin.wu@windriver.com>
+
+Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+
+#define NLM_HAL_LINUX_KERNEL
+
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/console.h>
+#include <linux/ide.h>
+
+#include <asm/io.h>
+
+#include <asm/netlogic/interrupt.h>
+#include <asm/netlogic/pci.h>
+#include <asm/netlogic/io.h>
+#include <asm/netlogic/iomap.h>
+#include <asm/netlogic/hal/nlm_hal.h>
+#include <asm/netlogic/hal/nlm_hal_pic.h>
+
+extern int pci_probe_only;
+
+static void *pci_config_base;
+static void *pci_io_base;
+
+static inline __u32 pci_cfg_read_32bit(__u32 addr)
+{
+	__u32 temp = 0;
+	__u32 *p = (__u32 *) (pci_config_base + (addr & ~3));
+
+	temp = *p;
+
+	return temp;
+}
+
+static inline void pci_cfg_write_32bit(__u32 addr, __u32 data)
+{
+	unsigned int *p = (unsigned int *)(pci_config_base + (addr & ~3));
+
+	*p = data;
+}
+
+static int pci_bus_status;
+#define pci_cfg_offset(bus, devfn, where) \
+	(((bus) << 16) + ((devfn) << 8) + (where))
+#define pci_cfg_addr(bus, devfn, where) \
+	pci_cfg_offset((bus)->number, (devfn), where)
+
+static int xlp_pcibios_read(struct pci_bus *bus, unsigned int devfn,
+				int where, int size, u32 *val)
+{
+	__u32 data = 0;
+
+	if ((size == 2) && (where & 1))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+	else if ((size == 4) && (where & 3))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	if (pci_bus_status)
+		data = pci_cfg_read_32bit(pci_cfg_offset((bus->number), devfn, where));
+	else
+		data = 0xFFFFFFFF;
+
+	if (size == 1)
+		*val = (data >> ((where & 3) << 3)) & 0xff;
+	else if (size == 2)
+		*val = (data >> ((where & 3) << 3)) & 0xffff;
+	else
+		*val = data;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int xlp_pcibios_write(struct pci_bus *bus, unsigned int devfn,
+				int where, int size, u32 val)
+{
+	__u32 cfgaddr = pci_cfg_offset((bus->number), devfn, where);
+	__u32 data = 0;
+
+	if ((size == 2) && (where & 1))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+	else if ((size == 4) && (where & 3))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	if (!pci_bus_status)
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	data = pci_cfg_read_32bit(cfgaddr);
+
+	if (size == 1)
+		data = (data & ~(0xff << ((where & 3) << 3))) |
+			(val << ((where & 3) << 3));
+	else if (size == 2)
+		data = (data & ~(0xffff << ((where & 3) << 3))) |
+			(val << ((where & 3) << 3));
+	else
+		data = val;
+
+	pci_cfg_write_32bit(cfgaddr, data);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static struct pci_ops xlp_pci_ops = {
+	.read  = xlp_pcibios_read,
+	.write = xlp_pcibios_write
+};
+
+/*
+* XLP PCIE Controller
+*/
+#define DEFAULT_XLP_PCI_CONFIG_BASE 0x1c000000UL
+static struct resource xlp_mem_resource = {
+	.name           = "XLP PCI MEM",
+	.start          = 0xd0000000ULL,	/* 256MB PCI mem @ 0xd000_0000 */
+	.end            = 0xdfffffffULL,
+	.flags          = IORESOURCE_MEM,
+};
+
+#define DEFAULT_PCI_IO_BASE	0x14000000UL
+#define DEFAULT_PCI_IO_SIZE	0x2000000UL
+
+static struct resource xlp_io_resource = {
+	.name           = "XLP IO MEM",
+	.start          = 0,			/* 32MB PCI IO @ 0x1400_0000 */
+	.end            = DEFAULT_PCI_IO_SIZE-1,
+	.flags          = IORESOURCE_IO,
+};
+struct pci_controller xlp_controller = {
+	.index          = 0,
+	.pci_ops        = &xlp_pci_ops,
+	.mem_resource   = &xlp_mem_resource,
+	.io_resource    = &xlp_io_resource,
+	.io_offset      = 0x00000000UL,
+	.mem_offset     = 0x00000000UL
+};
+
+int __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+	/* arch/mips/netlogic/common/nlm_hal.c:
+	 * PORT	IRT	IRQ
+	 * 0	78	44
+	 * 1	79	43
+	 * 2	80	42
+	 * 3	81	41
+	 */
+	int irq = 0, hwslot, func;
+
+	if (dev->bus->number == 0) {
+		/* PCI Bridge */
+		func = PCI_FUNC(dev->devfn);
+		irq = irt_irq_table[PIC_IRT_PCIE_LINK_INDEX(func)][0];
+	} else {
+		/* PCI Device */
+		hwslot = dev->bus->number;
+		irq = irt_irq_table[PIC_IRT_PCIE_LINK_INDEX(hwslot - 1)][0];
+	}
+
+	return irq;
+}
+
+/* Do platform specific device initialization at pci_enable_device() time */
+int pcibios_plat_dev_init(struct pci_dev *dev)
+{
+	return 0;
+}
+
+/* Enabled by default */
+static int __initdata xlp_nopci;
+
+static int __init xlp_nopci_setup(char *str)
+{
+	/* Disable PCI/X/E; disables HT also */
+	xlp_nopci = 1;
+
+	return 1;
+}
+__setup("xlp_nopci", xlp_nopci_setup);
+
+static int __init pcibios_init(void)
+{
+	unsigned long phys = 0;
+	unsigned long size = 0;
+
+	/* Bootloader assigns PCI resources */
+	pci_probe_only = 1;
+
+	/* Map the PCIX CFG space */
+	pci_config_base = ioremap(DEFAULT_XLP_PCI_CONFIG_BASE, (32<<20));
+	if (!pci_config_base) {
+		pr_err("Unable to map PCI config space!\n");
+		return 1;
+	}
+
+	phys = DEFAULT_PCI_IO_BASE;
+	size = DEFAULT_PCI_IO_SIZE;
+
+	pci_io_base = ioremap(phys, size);
+	if (!pci_io_base)
+		pr_err("[%s]: Unable to IO-Remap phys=%lx, size=%lx\n",
+		       __func__, phys, size);
+	else
+		pr_err("[%s]: IO-Remapped phys=%lx, size=%lx to vaddr=%p\n",
+		       __func__, phys, size, pci_io_base);
+
+	/* IO Range for 16MB from where the MEM Range Ends */
+	ioport_resource.start =  0;
+	ioport_resource.end   = ~0;
+
+	set_io_port_base((unsigned long)pci_io_base);
+	xlp_controller.io_map_base = mips_io_port_base;
+	pr_info("%s: mips_io_port_base = 0x%lx\n", __func__, mips_io_port_base);
+
+	pr_info("Registering XLP PCIE Controller. \n");
+	register_pci_controller(&xlp_controller);
+
+	pci_bus_status = 1;
+	return 0;
+}
+
+arch_initcall(pcibios_init);
+
+struct pci_fixup pcibios_fixups[] = {
+{0, }
+};
-- 
1.7.0.4

