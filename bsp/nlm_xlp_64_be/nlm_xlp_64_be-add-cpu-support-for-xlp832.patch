From b72fd9630afd9387b552fafdab2614d2abce215f Mon Sep 17 00:00:00 2001
From: Wu Zhangjin <zhangjin.wu@windriver.com>
Date: Thu, 16 Jun 2011 15:12:08 +0800
Subject: [PATCH 05/37] nlm_xlp_64_be: add cpu support for xlp832

[ Based on netlogic SDK 20110329 ]

Add CPU support for NLM XLP familay SoCs which have general MIPS64 R2
cores.

Signed-off-by: Venu Vadapalli <vvadapalli@netlogicmicro.com>
Integrated-by: Wu Zhangjin <zhangjin.wu@windriver.com>
---
 arch/mips/include/asm/cpu.h  |    3 ++
 arch/mips/kernel/cpu-probe.c |   56 ++++++++++++++++++++++++++++++++++++++++++
 arch/mips/kernel/proc.c      |   10 +++++++
 3 files changed, 69 insertions(+), 0 deletions(-)

diff --git a/arch/mips/include/asm/cpu.h b/arch/mips/include/asm/cpu.h
index a5acda4..6a0a3d5 100644
--- a/arch/mips/include/asm/cpu.h
+++ b/arch/mips/include/asm/cpu.h
@@ -34,6 +34,7 @@
 #define PRID_COMP_LSI		0x080000
 #define PRID_COMP_LEXRA		0x0b0000
 #define PRID_COMP_CAVIUM	0x0d0000
+#define PRID_COMP_NLM		0x0c0000
 
 
 /*
@@ -225,6 +226,7 @@ enum cpu_type_enum {
 	 */
 	CPU_5KC, CPU_20KC, CPU_25KF, CPU_SB1, CPU_SB1A, CPU_LOONGSON2,
 	CPU_CAVIUM_OCTEON, CPU_CAVIUM_OCTEON_PLUS,
+	CPU_XLP,
 
 	CPU_LAST
 };
@@ -274,6 +276,7 @@ enum cpu_type_enum {
 #define MIPS_CPU_VINT		0x00080000 /* CPU supports MIPSR2 vectored interrupts */
 #define MIPS_CPU_VEIC		0x00100000 /* CPU supports MIPSR2 external interrupt controller mode */
 #define MIPS_CPU_ULRI		0x00200000 /* CPU has ULRI feature */
+#define MIPS_CPU_NLM_CACHE	0x00400000
 
 /*
  * CPU ASE encodings
diff --git a/arch/mips/kernel/cpu-probe.c b/arch/mips/kernel/cpu-probe.c
index 7e1e51b..08d8c53 100644
--- a/arch/mips/kernel/cpu-probe.c
+++ b/arch/mips/kernel/cpu-probe.c
@@ -25,6 +25,11 @@
 #include <asm/system.h>
 #include <asm/watch.h>
 #include <asm/spram.h>
+#ifdef CONFIG_NLM_XLP
+#include <asm/netlogic/xlp.h>
+#endif
+
+
 /*
  * Not all of the MIPS CPUs have the "wait" instruction available. Moreover,
  * the implementation of the "wait" feature differs between CPU families. This
@@ -144,6 +149,7 @@ void __init check_wait(void)
 	case CPU_TX3927:
 		cpu_wait = r39xx_wait;
 		break;
+	case CPU_XLP:
 	case CPU_R4200:
 /*	case CPU_R4300: */
 	case CPU_R4600:
@@ -937,6 +943,53 @@ platform:
 const char *__cpu_name[NR_CPUS];
 const char *__elf_platform;
 
+static inline void cpu_probe_netlogic(struct cpuinfo_mips *c, int cpu)
+{
+	decode_configs(c);
+
+	c->options = (MIPS_CPU_TLB     |
+		      MIPS_CPU_4KEX    |
+		      MIPS_CPU_COUNTER |
+		      MIPS_CPU_DIVEC   |
+		      MIPS_CPU_WATCH   |
+		      MIPS_CPU_EJTAG   |
+		      MIPS_CPU_NLM_CACHE |
+		      MIPS_CPU_LLSC);
+
+	switch ((c->processor_id & 0xff00) >> 8) {
+	case CHIP_PROCESSOR_ID_XLP_8XX:
+	case CHIP_PROCESSOR_ID_XLP_832:
+	case CHIP_PROCESSOR_ID_XLP_816:
+	case CHIP_PROCESSOR_ID_XLP_432:
+	case CHIP_PROCESSOR_ID_XLP_416:
+	case CHIP_PROCESSOR_ID_XLP_408:
+	case CHIP_PROCESSOR_ID_XLP_316:
+	case CHIP_PROCESSOR_ID_XLP_308:
+	case CHIP_PROCESSOR_ID_XLP_304:
+	case CHIP_PROCESSOR_ID_XLP_208:
+	case CHIP_PROCESSOR_ID_XLP_204:
+	case CHIP_PROCESSOR_ID_XLP_104:
+	{
+		/* XLP */
+
+		c->cputype = CPU_XLP;
+
+		c->isa_level = MIPS_CPU_ISA_M64R2;
+		c->options |= (MIPS_CPU_FPU | MIPS_CPU_ULRI | MIPS_CPU_MCHECK);
+
+		c->tlbsize = ((read_c0_config6() >> 16) & 0xffff) + 1;
+		__cpu_name[cpu] = (const char *)get_cpu_info();
+
+		pr_info("Enabling XLP CPU (%s)\n", cpu_name_string());
+	}
+	break;
+	default:
+		panic("Don't support this CPU\n");
+	break;
+
+	}
+}
+
 __cpuinit void cpu_probe(void)
 {
 	struct cpuinfo_mips *c = &current_cpu_data;
@@ -975,6 +1028,9 @@ __cpuinit void cpu_probe(void)
 	case PRID_COMP_CAVIUM:
 		cpu_probe_cavium(c, cpu);
 		break;
+	case PRID_COMP_NLM:
+		cpu_probe_netlogic(c, cpu);
+		break;
 	}
 
 	BUG_ON(!__cpu_name[cpu]);
diff --git a/arch/mips/kernel/proc.c b/arch/mips/kernel/proc.c
index ed15fa8..fd0c6f2 100644
--- a/arch/mips/kernel/proc.c
+++ b/arch/mips/kernel/proc.c
@@ -35,6 +35,15 @@ static int show_cpuinfo(struct seq_file *m, void *v)
 		seq_printf(m, "system type\t\t: %s\n", get_system_type());
 
 	seq_printf(m, "processor\t\t: %ld\n", n);
+#ifdef CONFIG_NLM_COMMON
+	/* workaround for compiler warning */
+	version = fp_vers = 0;
+
+	cpu = get_cpu();
+	seq_printf(m, "cpu model\t\t: %s %s\n", __cpu_name[n],
+		   (cpu_data[n].options & MIPS_CPU_FPU ? "  FPU " : ""));
+	put_cpu();
+#else
 	sprintf(fmt, "cpu model\t\t: %%s V%%d.%%d%s\n",
 	        cpu_data[n].options & MIPS_CPU_FPU ? "  FPU V%d.%d" : "");
 	cpu = get_cpu();
@@ -42,6 +51,7 @@ static int show_cpuinfo(struct seq_file *m, void *v)
 	                           (version >> 4) & 0x0f, version & 0x0f,
 	                           (fp_vers >> 4) & 0x0f, fp_vers & 0x0f);
 	put_cpu();
+#endif
 	seq_printf(m, "BogoMIPS\t\t: %u.%02u\n",
 	              cpu_data[n].udelay_val / (500000/HZ),
 	              (cpu_data[n].udelay_val / (5000/HZ)) % 100);
-- 
1.7.0.2

