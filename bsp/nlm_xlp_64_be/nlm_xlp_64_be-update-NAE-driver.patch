From 4800c14b4889fe6932198107af3175019769c2c0 Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Fri, 13 Jul 2012 11:51:59 +0800
Subject: [PATCH 37/47] nlm_xlp_64_be: update NAE driver

Update NAE driver, so that NAE can work on XLP832 B1.

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 .../asm/netlogic/hal/NLP1042C2_RXAUI_Dune.h        |  670 ++++++
 .../asm/netlogic/hal/NLP1042C2_RXAUI_Dune_4.h      |  670 ++++++
 .../asm/netlogic/hal/NLP1042C2_RXAUI_Marvell.h     |  670 ++++++
 .../asm/netlogic/hal/NLP1042C2_RXAUI_Marvell_4.h   |  670 ++++++
 .../mips/include/asm/netlogic/hal/NLP1042C2_XAUI.h |  481 ++++
 .../include/asm/netlogic/hal/NLP1042C2_XAUI_4.h    |  480 ++++
 arch/mips/include/asm/netlogic/hal/nlm_evp_cpld.h  |    1 +
 arch/mips/include/asm/netlogic/hal/nlm_hal_nae.h   |   84 +-
 .../include/asm/netlogic/hal/nlm_hal_xlp_dev.h     |   16 +
 arch/mips/include/asm/netlogic/hal/nlm_nae.h       |   83 +-
 arch/mips/netlogic/common/nlm_hal_nae.c            | 2446 ++++++++++----------
 11 files changed, 5061 insertions(+), 1210 deletions(-)
 create mode 100644 arch/mips/include/asm/netlogic/hal/NLP1042C2_RXAUI_Dune.h
 create mode 100644 arch/mips/include/asm/netlogic/hal/NLP1042C2_RXAUI_Dune_4.h
 create mode 100644 arch/mips/include/asm/netlogic/hal/NLP1042C2_RXAUI_Marvell.h
 create mode 100644 arch/mips/include/asm/netlogic/hal/NLP1042C2_RXAUI_Marvell_4.h
 create mode 100644 arch/mips/include/asm/netlogic/hal/NLP1042C2_XAUI.h
 create mode 100644 arch/mips/include/asm/netlogic/hal/NLP1042C2_XAUI_4.h

diff --git a/arch/mips/include/asm/netlogic/hal/NLP1042C2_RXAUI_Dune.h b/arch/mips/include/asm/netlogic/hal/NLP1042C2_RXAUI_Dune.h
new file mode 100644
index 0000000..046e266
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/hal/NLP1042C2_RXAUI_Dune.h
@@ -0,0 +1,670 @@
+//
+// autogenerated by RegUtils.pm on 2011/12/22 12:13 format: mdioFullReg
+//
+NLM_C45_WRITE (0, 0, 0, 1,0xca42, 0x0100); // 10:8 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xca44, 0x81f8); // 15:12= 0x8
+NLM_C45_WRITE (0, 0, 0, 1,0xca44, 0x8218); //  9:5 = 0x10
+NLM_C45_WRITE (0, 0, 0, 1,0xca46, 0x0100); //  8:8 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xca46, 0x0900); // 11:9 = 0x4
+NLM_C45_WRITE (0, 0, 0, 1,0xcb0e, 0x1000); // 13:12= 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xca4c, 0x0002); //  5:0 = 0x2
+NLM_C45_WRITE (0, 0, 0, 1,0xca12, 0x0100); // 10:8 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xca14, 0x81f8); // 15:12= 0x8
+NLM_C45_WRITE (0, 0, 0, 1,0xca14, 0x8218); //  9:5 = 0x10
+NLM_C45_WRITE (0, 0, 0, 1,0xca16, 0x0100); //  8:8 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xca16, 0x0900); // 11:9 = 0x4
+NLM_C45_WRITE (0, 0, 0, 1,0xcb06, 0x1000); // 13:12= 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xca1c, 0x0002); //  5:0 = 0x2
+NLM_C45_WRITE (0, 0, 0, 1,0xca42, 0x0900); // 13:11= 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xca43, 0x2492); // 14:12= 0x2
+NLM_C45_WRITE (0, 0, 0, 1,0xc246, 0x0181); //  9:7 = 0x3
+NLM_C45_WRITE (0, 0, 0, 1,0xc242, 0x8100); //  2:0 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xc240, 0x1000); //  7:4 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xc240, 0x3800); // 13:11= 0x7
+NLM_C45_WRITE (0, 0, 0, 1,0xc242, 0x0100); // 15:13= 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xc246, 0x0180); //  0:0 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xc246, 0x0182); //  1:1 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xc243, 0x07e1); //  4:0 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xc243, 0x07e1); // 10:5 = 0x3f
+NLM_C45_WRITE (0, 0, 0, 1,0xc243, 0x17e1); // 15:11= 0x2
+NLM_C45_WRITE (0, 0, 0, 1,0xcb0b, 0x0001); //  1:0 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xcb0b, 0x0011); //  5:4 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xcb0b, 0x0311); //  9:8 = 0x3
+NLM_C45_WRITE (0, 0, 0, 1,0xcb0b, 0x0f11); // 11:10= 0x3
+NLM_C45_WRITE (0, 0, 0, 1,0xcb0b, 0x3f11); // 13:12= 0x3
+NLM_C45_WRITE (0, 0, 0, 1,0xcb0b, 0xff11); // 15:14= 0x3
+NLM_C45_WRITE (0, 0, 0, 1,0xcc00, 0x00f6); //  7:0 = 0xf6
+NLM_C45_WRITE (0, 0, 0, 1,0xcc02, 0x0081); //  7:7 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xcc02, 0x0001); //  7:7 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xcc07, 0x0117); //  4:0 = 0x17
+NLM_C45_WRITE (0, 0, 0, 1,0xcc08, 0x07df); //  5:0 = 0x1f
+NLM_C45_WRITE (0, 0, 0, 1,0xcc08, 0x07df); // 11:6 = 0x1f
+NLM_C45_WRITE (0, 0, 0, 1,0xcc09, 0x07df); //  5:0 = 0x1f
+NLM_C45_WRITE (0, 0, 0, 1,0xcc09, 0x07df); // 11:6 = 0x1f
+NLM_C45_WRITE (0, 0, 0, 1,0xcc07, 0x0017); //  8:5 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xcc0e, 0x0001); //  0:0 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xcc0e, 0x0003); //  1:1 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xcc0e, 0x0007); //  2:2 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xcc0e, 0x0006); //  0:0 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xcc0e, 0x0004); //  1:1 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xcc0e, 0x0000); //  2:2 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xcc02, 0x0021); //  5:5 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xcc04, 0x0001); //  0:0 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xcc04, 0x00b5); //  8:1 = 0x5a
+NLM_C45_WRITE (0, 0, 0, 1,0xcc11, 0x4904); //  5:3 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xcc11, 0x4804); //  8:6 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xcc11, 0x4004); // 11:9 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xcc11, 0x0004); // 14:12= 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xcc11, 0x0000); //  2:0 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xcb02, 0x00f0); //  7:4 = 0xf
+NLM_C45_WRITE (0, 0, 0, 1,0xcb02, 0x00ff); //  3:0 = 0xf
+NLM_C45_WRITE (0, 0, 0, 1,0xcb21, 0x1000); // 15:12= 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xca01, 0x0001); //  0:0 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xca01, 0x0011); //  7:1 = 0x8
+NLM_C45_WRITE (0, 0, 0, 1,0xcb1b, 0x1000); // 15:12= 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xca51, 0x0001); //  0:0 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xca51, 0x0011); //  7:1 = 0x8
+NLM_C45_WRITE (0, 0, 0, 1,0xc2c3, 0x000f); //  3:0 = 0xf
+NLM_C45_WRITE (0, 0, 0, 1,0xc2ca, 0x43c0); // 15:11= 0x8
+NLM_C45_WRITE (0, 0, 0, 1,0xc2d0, 0x43c0); // 15:11= 0x8
+NLM_C45_WRITE (0, 0, 0, 1,0xc2d6, 0x43c0); // 15:11= 0x8
+NLM_C45_WRITE (0, 0, 0, 1,0xc2dc, 0x43c0); // 15:11= 0x8
+NLM_C45_WRITE (0, 0, 0, 1,0xc2f1, 0x5f15); //  5:1 = 0xa
+NLM_C45_WRITE (0, 0, 0, 1,0xc2f1, 0x5e15); //  8:6 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xc2f5, 0x5f15); //  5:1 = 0xa
+NLM_C45_WRITE (0, 0, 0, 1,0xc2f5, 0x5e15); //  8:6 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xc2f9, 0x5f15); //  5:1 = 0xa
+NLM_C45_WRITE (0, 0, 0, 1,0xc2f9, 0x5e15); //  8:6 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xc2fd, 0x5f15); //  5:1 = 0xa
+NLM_C45_WRITE (0, 0, 0, 1,0xc2fd, 0x5e15); //  8:6 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xc2e8, 0x0100); //  8:0 = 0x100
+NLM_C45_WRITE (0, 0, 0, 1,0xc2e9, 0x0100); //  8:0 = 0x100
+NLM_C45_WRITE (0, 0, 0, 1,0xc2ea, 0x0100); //  8:0 = 0x100
+NLM_C45_WRITE (0, 0, 0, 1,0xc2eb, 0x0100); //  8:0 = 0x100
+NLM_C45_WRITE (0, 0, 0, 1,0xc2e6, 0x0800); // 11:11= 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xc2e6, 0x0000); // 11:11= 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xc017, 0xdf20); // 13:13= 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xc010, 0x4000); // 14:14= 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xcd40, 0x0001); //  3:0 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xc010, 0x6000); // 13:13= 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xcc05, 0x001f); //  2:0 = 0x7
+NLM_C45_WRITE (0, 0, 0, 1,0xcc03, 0x0020); //  9:0 = 0x20
+NLM_C45_WRITE (0, 0, 0, 1,0xc019, 0x1531); // 10:10= 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xff2a, 0x004a); // 
+NLM_C45_WRITE (0, 0, 0, 1,0xd008, 0x0001); //  0:0 = 0x1
+
+//sleep 100000	   # us
+for(i=0;i<100000;i++) NLM_C45_PRINTF(".");
+// WARNING: mdtrace, reg  1.d000 write value (5200) doesn't match read back (5000)
+
+NLM_C45_WRITE (0, 0, 0, 1,0xd000, 0x5200);   
+
+//sleep 100000	   # us
+for(i=0;i<100000;i++) NLM_C45_PRINTF(".");
+
+NLM_C45_WRITE (0, 0, 0, 1,0xd800, 0x2fff);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd801, 0x300f);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd802, 0x2ff4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd803, 0x3ef4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd804, 0x20ae);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd805, 0x301e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd806, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd807, 0x22c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd808, 0x3ef4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd809, 0x400e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd80a, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd80b, 0x220e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd80c, 0x300e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd80d, 0x2124);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd80e, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd80f, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd810, 0x23fe);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd811, 0x3c1e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd812, 0x2214);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd813, 0x3ca4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd814, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd815, 0x20a4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd816, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd817, 0x2dfe);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd818, 0x307e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd819, 0x6e24);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd81a, 0x6e24);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd81b, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd81c, 0x20e4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd81d, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd81e, 0x402e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd81f, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd820, 0x400e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd821, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd822, 0x2014);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd823, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd824, 0x64de);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd825, 0x6e8f);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd826, 0x400e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd827, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd828, 0x2044);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd829, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd82a, 0x64de);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd82b, 0x6e8f);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd82c, 0x201e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd82d, 0x300e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd82e, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd82f, 0x20d4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd830, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd831, 0x64de);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd832, 0x6e8f);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd833, 0x21fe);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd834, 0x300e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd835, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd836, 0x20e4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd837, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd838, 0x404e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd839, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd83a, 0x400e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd83b, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd83c, 0x21f5);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd83d, 0x3005);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd83e, 0xb805);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd83f, 0x8556);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd840, 0x8557);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd841, 0x8558);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd842, 0x8559);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd843, 0x855a);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd844, 0x400d);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd845, 0x6d8f);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd846, 0x2032);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd847, 0x3022);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd848, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd849, 0x2132);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd84a, 0x3022);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd84b, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd84c, 0x21c2);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd84d, 0x3022);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd84e, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd84f, 0x2302);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd850, 0x3022);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd851, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd852, 0x23a2);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd853, 0x3022);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd854, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd855, 0x24c2);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd856, 0x3022);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd857, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd858, 0x2562);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd859, 0x3022);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd85a, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd85b, 0x6f7e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd85c, 0x4004);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd85d, 0xb814);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd85e, 0x5e43);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd85f, 0x03d7);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd860, 0x2032);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd861, 0x3022);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd862, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd863, 0x200e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd864, 0x300e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd865, 0x0002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd866, 0xd01e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd867, 0x6e8f);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd868, 0x20fe);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd869, 0x300e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd86a, 0xb80e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd86b, 0xd01d);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd86c, 0x5de3);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd86d, 0x249e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd86e, 0x301e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd86f, 0x135e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd870, 0x6f7e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd871, 0x6f7e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd872, 0x20d4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd873, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd874, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd875, 0x20e4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd876, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd877, 0x404e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd878, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd879, 0x400e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd87a, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd87b, 0x6f7e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd87c, 0x2044);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd87d, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd87e, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd87f, 0x6f7e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd880, 0x2014);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd881, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd882, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd883, 0x200e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd884, 0x300e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd885, 0x2124);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd886, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd887, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd888, 0x2504);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd889, 0x3cd4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd88a, 0x4015);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd88b, 0x65c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd88c, 0x2514);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd88d, 0x3cd4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd88e, 0x64d5);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd88f, 0xb145);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd890, 0xb115);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd891, 0x65c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd892, 0x2bd2);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd893, 0x3012);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd894, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd895, 0x678f);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd896, 0x2514);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd897, 0x3cd4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd898, 0x64d5);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd899, 0xb145);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd89a, 0xb105);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd89b, 0x65c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd89c, 0x2bd2);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd89d, 0x3012);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd89e, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd89f, 0x6f78);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8a0, 0xe78e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8a1, 0x22c5);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8a2, 0x3ef5);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8a3, 0x6ec5);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8a4, 0x2084);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8a5, 0x3034);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8a6, 0x2005);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8a7, 0x3d75);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8a8, 0xc451);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8a9, 0x2f62);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8aa, 0x3022);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8ab, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8ac, 0x2444);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8ad, 0x3ca4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8ae, 0x2ed2);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8af, 0x3022);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8b0, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8b1, 0x2144);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8b2, 0x3ca4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8b3, 0x2ed2);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8b4, 0x3022);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8b5, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8b6, 0x2f02);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8b7, 0x3012);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8b8, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8b9, 0x28c2);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8ba, 0x3012);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8bb, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8bc, 0x0000);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8bd, 0x628f);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8be, 0x4007);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8bf, 0x2524);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8c0, 0x3cd4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8c1, 0x64d5);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8c2, 0x2005);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8c3, 0x9575);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8c4, 0x65c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8c5, 0x678f);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8c6, 0x2dd2);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8c7, 0x3012);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8c8, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8c9, 0x6f77);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8ca, 0x2514);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8cb, 0x3cd4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8cc, 0x64d5);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8cd, 0xbd05);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8ce, 0xbf45);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8cf, 0x2db2);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8d0, 0x3012);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8d1, 0x5553);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8d2, 0x1302);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8d3, 0x2006);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8d4, 0x3016);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8d5, 0x5763);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8d6, 0x13c2);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8d7, 0xd017);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8d8, 0x2bf2);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8d9, 0x3012);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8da, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8db, 0x6f72);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8dc, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8dd, 0x628f);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8de, 0x2514);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8df, 0x3cd4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8e0, 0x64d5);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8e1, 0x4026);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8e2, 0x9655);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8e3, 0x65c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8e4, 0x648f);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8e5, 0x401d);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8e6, 0x2f22);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8e7, 0x3012);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8e8, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8e9, 0x6f74);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8ea, 0x2fd6);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8eb, 0x3ff6);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8ec, 0x8655);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8ed, 0x65c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8ee, 0x6f72);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8ef, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8f0, 0x22cd);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8f1, 0x301d);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8f2, 0x2108);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8f3, 0x3808);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8f4, 0x628f);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8f5, 0x5dd3);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8f6, 0x2012);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8f7, 0x3022);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8f8, 0x1302);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8f9, 0x63a8);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8fa, 0x2b72);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8fb, 0x3022);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8fc, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8fd, 0xdffd);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8fe, 0x2f52);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8ff, 0x3012);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd900, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd901, 0x6f72);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd902, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd903, 0x2214);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd904, 0x3ca4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd905, 0x64de);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd906, 0x2ef4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd907, 0x3ff4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd908, 0x8e4e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd909, 0x2214);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd90a, 0x3ca4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd90b, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd90c, 0x2104);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd90d, 0x3004);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd90e, 0x9e4e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd90f, 0x2214);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd910, 0x3ca4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd911, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd912, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd913, 0x2294);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd914, 0x3ca4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd915, 0x64db);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd916, 0x8bbc);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd917, 0xb84b);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd918, 0x300c);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd919, 0xdf0b);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd91a, 0xdf0c);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd91b, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd91c, 0xc5b5);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd91d, 0xc6c6);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd91e, 0x855e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd91f, 0xb84e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd920, 0x866c);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd921, 0xb84c);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd922, 0xb60c);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd923, 0x9cee);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd924, 0x20a4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd925, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd926, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd927, 0x20e4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd928, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd929, 0x202e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd92a, 0x300e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd92b, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd92c, 0x200e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd92d, 0x300e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd92e, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd92f, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd930, 0x22b4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd931, 0x3ca4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd932, 0x64db);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd933, 0x8bbc);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd934, 0xb84b);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd935, 0xb80c);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd936, 0xb84c);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd937, 0xdf0b);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd938, 0xdf0c);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd939, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd93a, 0xc7b7);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd93b, 0xc8c8);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd93c, 0x877e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd93d, 0xb84e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd93e, 0x888c);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd93f, 0xb84c);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd940, 0xb60c);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd941, 0x9cee);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd942, 0x20b4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd943, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd944, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd945, 0x20e4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd946, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd947, 0x402e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd948, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd949, 0x400e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd94a, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd94b, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd94c, 0x22a4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd94d, 0x3ca4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd94e, 0x64db);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd94f, 0x8bbc);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd950, 0xb84b);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd951, 0xb80c);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd952, 0xb84c);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd953, 0xdf0b);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd954, 0xdf0c);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd955, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd956, 0xc9b9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd957, 0xcaca);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd958, 0x899e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd959, 0xb84e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd95a, 0x8aac);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd95b, 0xb84c);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd95c, 0xb60c);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd95d, 0x9cee);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd95e, 0x20c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd95f, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd960, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd961, 0x20e4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd962, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd963, 0x402e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd964, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd965, 0x400e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd966, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd967, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd968, 0x628f);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd969, 0x20a4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd96a, 0x3004);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd96b, 0x64d9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd96c, 0x899e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd96d, 0xbf0e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd96e, 0xbf4e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd96f, 0x4012);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd970, 0x2f0e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd971, 0x300e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd972, 0x2054);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd973, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd974, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd975, 0x2064);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd976, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd977, 0x64de);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd978, 0x8ee9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd979, 0xbe0e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd97a, 0xbf4e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd97b, 0x5e23);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd97c, 0x0382);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd97d, 0x0008);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd97e, 0x401e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd97f, 0x99e9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd980, 0x69c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd981, 0x280e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd982, 0x300e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd983, 0x63ae);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd984, 0x0008);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd985, 0x2fee);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd986, 0x3ffe);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd987, 0x89e9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd988, 0x69c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd989, 0x280e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd98a, 0x300e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd98b, 0x63ae);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd98c, 0x6f72);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd98d, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd98e, 0x628f);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd98f, 0x20a4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd990, 0x3004);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd991, 0x64d9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd992, 0x899e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd993, 0xbf0e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd994, 0xbf4e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd995, 0x4012);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd996, 0x5e23);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd997, 0x03d2);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd998, 0x001d);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd999, 0x2f0e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd99a, 0x300e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd99b, 0x2054);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd99c, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd99d, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd99e, 0x2064);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd99f, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9a0, 0x64de);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9a1, 0x8ee9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9a2, 0xbe0e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9a3, 0xbf4e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9a4, 0x5e23);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9a5, 0x0382);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9a6, 0x0009);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9a7, 0x2fee);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9a8, 0x3ffe);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9a9, 0x89e9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9aa, 0x69c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9ab, 0x280e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9ac, 0x300e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9ad, 0x63ae);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9ae, 0x0007);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9af, 0x401e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9b0, 0x99e9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9b1, 0x69c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9b2, 0x280e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9b3, 0x300e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9b4, 0x63ae);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9b5, 0x6f72);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9b6, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9b7, 0x628f);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9b8, 0x2844);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9b9, 0x3c04);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9ba, 0x64de);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9bb, 0x2d62);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9bc, 0x3022);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9bd, 0x1e52);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9be, 0x20c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9bf, 0x3c24);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9c0, 0x64de);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9c1, 0x2ff9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9c2, 0x3fd9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9c3, 0x89e9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9c4, 0x69c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9c5, 0x26c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9c6, 0x3c04);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9c7, 0x64de);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9c8, 0x2ff9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9c9, 0x3fa9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9ca, 0x89e9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9cb, 0x69c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9cc, 0x2894);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9cd, 0x3c04);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9ce, 0x64de);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9cf, 0x2f79);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9d0, 0x3ff9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9d1, 0x89e9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9d2, 0x69c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9d3, 0x2eb2);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9d4, 0x3022);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9d5, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9d6, 0x2894);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9d7, 0x3c04);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9d8, 0x64de);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9d9, 0x2089);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9da, 0x3009);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9db, 0x99e9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9dc, 0x69c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9dd, 0x26c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9de, 0x3c04);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9df, 0x64de);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9e0, 0x2009);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9e1, 0x3059);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9e2, 0x99e9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9e3, 0x69c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9e4, 0x20c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9e5, 0x3c24);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9e6, 0x64de);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9e7, 0x2009);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9e8, 0x3029);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9e9, 0x99e9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9ea, 0x69c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9eb, 0x6f72);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9ec, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9ed, 0x64d6);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9ee, 0x21f7);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9ef, 0x3fc7);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9f0, 0x8676);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9f1, 0xb505);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9f2, 0x9566);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9f3, 0x66c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9f4, 0xb545);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9f5, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9f6, 0x628f);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9f7, 0x6138);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9f8, 0x5883);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9f9, 0x2062);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9fa, 0x3032);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9fb, 0x1302);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9fc, 0x2ff7);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9fd, 0x3007);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9fe, 0x8786);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9ff, 0xb887);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda00, 0x8785);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda01, 0xb8c5);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda02, 0x5e63);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda03, 0x2f72);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda04, 0x3022);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda05, 0x13c2);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda06, 0x6f72);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda07, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda08, 0x0c82);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda09, 0x0d87);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda0a, 0x0e8d);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda0b, 0x1092);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda0c, 0x1198);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda0d, 0x129d);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda0e, 0x14a3);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda0f, 0x16a8);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda10, 0x17ae);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda11, 0x18b4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda12, 0x0000);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda13, 0x0000);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd080, 0x0100);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd092, 0x0000);   
+
+//sleep 400000	   # us
+for(i=0;i<100000;i++) NLM_C45_PRINTF(".");
+
+NLM_C45_WRITE (0, 0, 0, 1,0xcc08, 0x07c6);  // 5:0 = 0x6
+NLM_C45_WRITE (0, 0, 0, 1,0xcc08, 0x08c6);  //11:6 = 0x23
+NLM_C45_WRITE (0, 0, 0, 1,0xcc09, 0x07e8);  // 5:0 = 0x28
+NLM_C45_WRITE (0, 0, 0, 1,0xcc09, 0x0b68);  //11:6 = 0x2d
+NLM_C45_WRITE (0, 0, 0, 1,0xcc0e, 0x0001);  // 0:0 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xcc0e, 0x0000);  // 0:0 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xc2e1, 0x000f);  // 3:0 = 0xf
+NLM_C45_WRITE (0, 0, 0, 1,0xc088, 0x0004);  // 3:0 = 0x4
+NLM_C45_WRITE (0, 0, 0, 1,0xc290, 0x0001);  // 0:0 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xca01, 0x0041);  // 7:1 = 0x20
+NLM_C45_WRITE (0, 0, 0, 1,0xca51, 0x0041);  // 7:1 = 0x20
+NLM_C45_WRITE (0, 0, 0, 1,0xc2e8, 0x0000);  // 8:0 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xc2e9, 0x0000);  // 8:0 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xc2ea, 0x0000);  // 8:0 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xc2eb, 0x0000);  // 8:0 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xc2e6, 0x0800);  //11:11= 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xc2e6, 0x0000);  //11:11= 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xc2e0, 0x00e4);  // 7:0 = 0xe4
+NLM_C45_WRITE (0, 0, 0, 1,0xc2e1, 0x000f);  //13:12= 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xc20d, 0x0000);  // 9:8 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xc012, 0x000a);  // 3:0 = 0xa
+NLM_C45_WRITE (0, 0, 0, 1,0xc012, 0x00aa);  // 7:4 = 0xa
+NLM_C45_WRITE (0, 0, 0, 1,0xc0f0, 0x010a);  //  
+NLM_C45_WRITE (0, 0, 0, 1,0xc0f1, 0x0056);  //  #  7:0 = 0x56
+NLM_C45_WRITE (0, 0, 0, 1,0xc20d, 0x0002);  //  #  1:1 = 0x1
+//sleep 200000	   # us
+for(i=0;i<100000;i++) NLM_C45_PRINTF(".");
+
diff --git a/arch/mips/include/asm/netlogic/hal/NLP1042C2_RXAUI_Dune_4.h b/arch/mips/include/asm/netlogic/hal/NLP1042C2_RXAUI_Dune_4.h
new file mode 100644
index 0000000..5525033
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/hal/NLP1042C2_RXAUI_Dune_4.h
@@ -0,0 +1,670 @@
+//
+// autogenerated by RegUtils.pm on 2011/12/22 12:13 format: mdioFullReg
+//
+NLM_C45_WRITE (0, 0, 4, 1,0xca42, 0x0100); // 10:8 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xca44, 0x81f8); // 15:12= 0x8
+NLM_C45_WRITE (0, 0, 4, 1,0xca44, 0x8218); //  9:5 = 0x10
+NLM_C45_WRITE (0, 0, 4, 1,0xca46, 0x0100); //  8:8 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xca46, 0x0900); // 11:9 = 0x4
+NLM_C45_WRITE (0, 0, 4, 1,0xcb0e, 0x1000); // 13:12= 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xca4c, 0x0002); //  5:0 = 0x2
+NLM_C45_WRITE (0, 0, 4, 1,0xca12, 0x0100); // 10:8 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xca14, 0x81f8); // 15:12= 0x8
+NLM_C45_WRITE (0, 0, 4, 1,0xca14, 0x8218); //  9:5 = 0x10
+NLM_C45_WRITE (0, 0, 4, 1,0xca16, 0x0100); //  8:8 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xca16, 0x0900); // 11:9 = 0x4
+NLM_C45_WRITE (0, 0, 4, 1,0xcb06, 0x1000); // 13:12= 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xca1c, 0x0002); //  5:0 = 0x2
+NLM_C45_WRITE (0, 0, 4, 1,0xca42, 0x0900); // 13:11= 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xca43, 0x2492); // 14:12= 0x2
+NLM_C45_WRITE (0, 0, 4, 1,0xc246, 0x0181); //  9:7 = 0x3
+NLM_C45_WRITE (0, 0, 4, 1,0xc242, 0x8100); //  2:0 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xc240, 0x1000); //  7:4 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xc240, 0x3800); // 13:11= 0x7
+NLM_C45_WRITE (0, 0, 4, 1,0xc242, 0x0100); // 15:13= 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xc246, 0x0180); //  0:0 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xc246, 0x0182); //  1:1 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xc243, 0x07e1); //  4:0 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xc243, 0x07e1); // 10:5 = 0x3f
+NLM_C45_WRITE (0, 0, 4, 1,0xc243, 0x17e1); // 15:11= 0x2
+NLM_C45_WRITE (0, 0, 4, 1,0xcb0b, 0x0001); //  1:0 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xcb0b, 0x0011); //  5:4 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xcb0b, 0x0311); //  9:8 = 0x3
+NLM_C45_WRITE (0, 0, 4, 1,0xcb0b, 0x0f11); // 11:10= 0x3
+NLM_C45_WRITE (0, 0, 4, 1,0xcb0b, 0x3f11); // 13:12= 0x3
+NLM_C45_WRITE (0, 0, 4, 1,0xcb0b, 0xff11); // 15:14= 0x3
+NLM_C45_WRITE (0, 0, 4, 1,0xcc00, 0x00f6); //  7:0 = 0xf6
+NLM_C45_WRITE (0, 0, 4, 1,0xcc02, 0x0081); //  7:7 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xcc02, 0x0001); //  7:7 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xcc07, 0x0117); //  4:0 = 0x17
+NLM_C45_WRITE (0, 0, 4, 1,0xcc08, 0x07df); //  5:0 = 0x1f
+NLM_C45_WRITE (0, 0, 4, 1,0xcc08, 0x07df); // 11:6 = 0x1f
+NLM_C45_WRITE (0, 0, 4, 1,0xcc09, 0x07df); //  5:0 = 0x1f
+NLM_C45_WRITE (0, 0, 4, 1,0xcc09, 0x07df); // 11:6 = 0x1f
+NLM_C45_WRITE (0, 0, 4, 1,0xcc07, 0x0017); //  8:5 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xcc0e, 0x0001); //  0:0 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xcc0e, 0x0003); //  1:1 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xcc0e, 0x0007); //  2:2 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xcc0e, 0x0006); //  0:0 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xcc0e, 0x0004); //  1:1 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xcc0e, 0x0000); //  2:2 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xcc02, 0x0021); //  5:5 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xcc04, 0x0001); //  0:0 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xcc04, 0x00b5); //  8:1 = 0x5a
+NLM_C45_WRITE (0, 0, 4, 1,0xcc11, 0x4904); //  5:3 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xcc11, 0x4804); //  8:6 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xcc11, 0x4004); // 11:9 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xcc11, 0x0004); // 14:12= 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xcc11, 0x0000); //  2:0 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xcb02, 0x00f0); //  7:4 = 0xf
+NLM_C45_WRITE (0, 0, 4, 1,0xcb02, 0x00ff); //  3:0 = 0xf
+NLM_C45_WRITE (0, 0, 4, 1,0xcb21, 0x1000); // 15:12= 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xca01, 0x0001); //  0:0 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xca01, 0x0011); //  7:1 = 0x8
+NLM_C45_WRITE (0, 0, 4, 1,0xcb1b, 0x1000); // 15:12= 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xca51, 0x0001); //  0:0 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xca51, 0x0011); //  7:1 = 0x8
+NLM_C45_WRITE (0, 0, 4, 1,0xc2c3, 0x000f); //  3:0 = 0xf
+NLM_C45_WRITE (0, 0, 4, 1,0xc2ca, 0x43c0); // 15:11= 0x8
+NLM_C45_WRITE (0, 0, 4, 1,0xc2d0, 0x43c0); // 15:11= 0x8
+NLM_C45_WRITE (0, 0, 4, 1,0xc2d6, 0x43c0); // 15:11= 0x8
+NLM_C45_WRITE (0, 0, 4, 1,0xc2dc, 0x43c0); // 15:11= 0x8
+NLM_C45_WRITE (0, 0, 4, 1,0xc2f1, 0x5f15); //  5:1 = 0xa
+NLM_C45_WRITE (0, 0, 4, 1,0xc2f1, 0x5e15); //  8:6 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xc2f5, 0x5f15); //  5:1 = 0xa
+NLM_C45_WRITE (0, 0, 4, 1,0xc2f5, 0x5e15); //  8:6 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xc2f9, 0x5f15); //  5:1 = 0xa
+NLM_C45_WRITE (0, 0, 4, 1,0xc2f9, 0x5e15); //  8:6 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xc2fd, 0x5f15); //  5:1 = 0xa
+NLM_C45_WRITE (0, 0, 4, 1,0xc2fd, 0x5e15); //  8:6 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xc2e8, 0x0100); //  8:0 = 0x100
+NLM_C45_WRITE (0, 0, 4, 1,0xc2e9, 0x0100); //  8:0 = 0x100
+NLM_C45_WRITE (0, 0, 4, 1,0xc2ea, 0x0100); //  8:0 = 0x100
+NLM_C45_WRITE (0, 0, 4, 1,0xc2eb, 0x0100); //  8:0 = 0x100
+NLM_C45_WRITE (0, 0, 4, 1,0xc2e6, 0x0800); // 11:11= 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xc2e6, 0x0000); // 11:11= 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xc017, 0xdf20); // 13:13= 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xc010, 0x4000); // 14:14= 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xcd40, 0x0001); //  3:0 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xc010, 0x6000); // 13:13= 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xcc05, 0x001f); //  2:0 = 0x7
+NLM_C45_WRITE (0, 0, 4, 1,0xcc03, 0x0020); //  9:0 = 0x20
+NLM_C45_WRITE (0, 0, 4, 1,0xc019, 0x1531); // 10:10= 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xff2a, 0x004a); // 
+NLM_C45_WRITE (0, 0, 4, 1,0xd008, 0x0001); //  0:0 = 0x1
+
+//sleep 100000	   # us
+for(i=0;i<100000;i++) NLM_C45_PRINTF(".");
+// WARNING: mdtrace, reg  1.d000 write value (5200) doesn't match read back (5000)
+
+NLM_C45_WRITE (0, 0, 4, 1,0xd000, 0x5200);   
+
+//sleep 100000	   # us
+for(i=0;i<100000;i++) NLM_C45_PRINTF(".");
+
+NLM_C45_WRITE (0, 0, 4, 1,0xd800, 0x2fff);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd801, 0x300f);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd802, 0x2ff4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd803, 0x3ef4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd804, 0x20ae);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd805, 0x301e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd806, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd807, 0x22c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd808, 0x3ef4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd809, 0x400e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd80a, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd80b, 0x220e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd80c, 0x300e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd80d, 0x2124);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd80e, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd80f, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd810, 0x23fe);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd811, 0x3c1e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd812, 0x2214);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd813, 0x3ca4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd814, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd815, 0x20a4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd816, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd817, 0x2dfe);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd818, 0x307e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd819, 0x6e24);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd81a, 0x6e24);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd81b, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd81c, 0x20e4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd81d, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd81e, 0x402e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd81f, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd820, 0x400e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd821, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd822, 0x2014);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd823, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd824, 0x64de);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd825, 0x6e8f);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd826, 0x400e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd827, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd828, 0x2044);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd829, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd82a, 0x64de);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd82b, 0x6e8f);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd82c, 0x201e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd82d, 0x300e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd82e, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd82f, 0x20d4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd830, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd831, 0x64de);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd832, 0x6e8f);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd833, 0x21fe);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd834, 0x300e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd835, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd836, 0x20e4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd837, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd838, 0x404e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd839, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd83a, 0x400e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd83b, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd83c, 0x21f5);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd83d, 0x3005);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd83e, 0xb805);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd83f, 0x8556);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd840, 0x8557);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd841, 0x8558);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd842, 0x8559);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd843, 0x855a);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd844, 0x400d);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd845, 0x6d8f);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd846, 0x2032);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd847, 0x3022);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd848, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd849, 0x2132);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd84a, 0x3022);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd84b, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd84c, 0x21c2);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd84d, 0x3022);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd84e, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd84f, 0x2302);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd850, 0x3022);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd851, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd852, 0x23a2);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd853, 0x3022);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd854, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd855, 0x24c2);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd856, 0x3022);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd857, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd858, 0x2562);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd859, 0x3022);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd85a, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd85b, 0x6f7e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd85c, 0x4004);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd85d, 0xb814);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd85e, 0x5e43);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd85f, 0x03d7);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd860, 0x2032);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd861, 0x3022);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd862, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd863, 0x200e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd864, 0x300e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd865, 0x0002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd866, 0xd01e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd867, 0x6e8f);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd868, 0x20fe);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd869, 0x300e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd86a, 0xb80e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd86b, 0xd01d);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd86c, 0x5de3);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd86d, 0x249e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd86e, 0x301e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd86f, 0x135e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd870, 0x6f7e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd871, 0x6f7e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd872, 0x20d4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd873, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd874, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd875, 0x20e4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd876, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd877, 0x404e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd878, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd879, 0x400e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd87a, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd87b, 0x6f7e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd87c, 0x2044);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd87d, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd87e, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd87f, 0x6f7e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd880, 0x2014);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd881, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd882, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd883, 0x200e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd884, 0x300e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd885, 0x2124);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd886, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd887, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd888, 0x2504);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd889, 0x3cd4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd88a, 0x4015);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd88b, 0x65c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd88c, 0x2514);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd88d, 0x3cd4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd88e, 0x64d5);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd88f, 0xb145);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd890, 0xb115);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd891, 0x65c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd892, 0x2bd2);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd893, 0x3012);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd894, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd895, 0x678f);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd896, 0x2514);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd897, 0x3cd4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd898, 0x64d5);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd899, 0xb145);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd89a, 0xb105);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd89b, 0x65c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd89c, 0x2bd2);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd89d, 0x3012);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd89e, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd89f, 0x6f78);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8a0, 0xe78e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8a1, 0x22c5);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8a2, 0x3ef5);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8a3, 0x6ec5);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8a4, 0x2084);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8a5, 0x3034);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8a6, 0x2005);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8a7, 0x3d75);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8a8, 0xc451);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8a9, 0x2f62);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8aa, 0x3022);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8ab, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8ac, 0x2444);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8ad, 0x3ca4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8ae, 0x2ed2);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8af, 0x3022);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8b0, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8b1, 0x2144);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8b2, 0x3ca4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8b3, 0x2ed2);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8b4, 0x3022);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8b5, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8b6, 0x2f02);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8b7, 0x3012);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8b8, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8b9, 0x28c2);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8ba, 0x3012);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8bb, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8bc, 0x0000);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8bd, 0x628f);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8be, 0x4007);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8bf, 0x2524);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8c0, 0x3cd4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8c1, 0x64d5);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8c2, 0x2005);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8c3, 0x9575);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8c4, 0x65c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8c5, 0x678f);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8c6, 0x2dd2);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8c7, 0x3012);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8c8, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8c9, 0x6f77);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8ca, 0x2514);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8cb, 0x3cd4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8cc, 0x64d5);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8cd, 0xbd05);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8ce, 0xbf45);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8cf, 0x2db2);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8d0, 0x3012);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8d1, 0x5553);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8d2, 0x1302);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8d3, 0x2006);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8d4, 0x3016);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8d5, 0x5763);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8d6, 0x13c2);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8d7, 0xd017);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8d8, 0x2bf2);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8d9, 0x3012);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8da, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8db, 0x6f72);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8dc, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8dd, 0x628f);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8de, 0x2514);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8df, 0x3cd4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8e0, 0x64d5);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8e1, 0x4026);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8e2, 0x9655);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8e3, 0x65c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8e4, 0x648f);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8e5, 0x401d);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8e6, 0x2f22);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8e7, 0x3012);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8e8, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8e9, 0x6f74);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8ea, 0x2fd6);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8eb, 0x3ff6);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8ec, 0x8655);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8ed, 0x65c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8ee, 0x6f72);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8ef, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8f0, 0x22cd);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8f1, 0x301d);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8f2, 0x2108);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8f3, 0x3808);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8f4, 0x628f);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8f5, 0x5dd3);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8f6, 0x2012);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8f7, 0x3022);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8f8, 0x1302);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8f9, 0x63a8);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8fa, 0x2b72);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8fb, 0x3022);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8fc, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8fd, 0xdffd);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8fe, 0x2f52);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8ff, 0x3012);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd900, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd901, 0x6f72);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd902, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd903, 0x2214);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd904, 0x3ca4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd905, 0x64de);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd906, 0x2ef4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd907, 0x3ff4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd908, 0x8e4e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd909, 0x2214);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd90a, 0x3ca4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd90b, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd90c, 0x2104);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd90d, 0x3004);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd90e, 0x9e4e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd90f, 0x2214);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd910, 0x3ca4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd911, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd912, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd913, 0x2294);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd914, 0x3ca4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd915, 0x64db);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd916, 0x8bbc);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd917, 0xb84b);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd918, 0x300c);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd919, 0xdf0b);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd91a, 0xdf0c);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd91b, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd91c, 0xc5b5);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd91d, 0xc6c6);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd91e, 0x855e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd91f, 0xb84e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd920, 0x866c);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd921, 0xb84c);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd922, 0xb60c);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd923, 0x9cee);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd924, 0x20a4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd925, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd926, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd927, 0x20e4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd928, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd929, 0x202e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd92a, 0x300e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd92b, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd92c, 0x200e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd92d, 0x300e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd92e, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd92f, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd930, 0x22b4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd931, 0x3ca4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd932, 0x64db);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd933, 0x8bbc);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd934, 0xb84b);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd935, 0xb80c);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd936, 0xb84c);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd937, 0xdf0b);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd938, 0xdf0c);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd939, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd93a, 0xc7b7);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd93b, 0xc8c8);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd93c, 0x877e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd93d, 0xb84e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd93e, 0x888c);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd93f, 0xb84c);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd940, 0xb60c);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd941, 0x9cee);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd942, 0x20b4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd943, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd944, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd945, 0x20e4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd946, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd947, 0x402e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd948, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd949, 0x400e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd94a, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd94b, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd94c, 0x22a4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd94d, 0x3ca4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd94e, 0x64db);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd94f, 0x8bbc);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd950, 0xb84b);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd951, 0xb80c);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd952, 0xb84c);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd953, 0xdf0b);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd954, 0xdf0c);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd955, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd956, 0xc9b9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd957, 0xcaca);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd958, 0x899e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd959, 0xb84e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd95a, 0x8aac);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd95b, 0xb84c);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd95c, 0xb60c);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd95d, 0x9cee);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd95e, 0x20c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd95f, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd960, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd961, 0x20e4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd962, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd963, 0x402e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd964, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd965, 0x400e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd966, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd967, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd968, 0x628f);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd969, 0x20a4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd96a, 0x3004);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd96b, 0x64d9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd96c, 0x899e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd96d, 0xbf0e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd96e, 0xbf4e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd96f, 0x4012);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd970, 0x2f0e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd971, 0x300e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd972, 0x2054);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd973, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd974, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd975, 0x2064);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd976, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd977, 0x64de);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd978, 0x8ee9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd979, 0xbe0e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd97a, 0xbf4e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd97b, 0x5e23);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd97c, 0x0382);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd97d, 0x0008);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd97e, 0x401e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd97f, 0x99e9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd980, 0x69c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd981, 0x280e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd982, 0x300e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd983, 0x63ae);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd984, 0x0008);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd985, 0x2fee);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd986, 0x3ffe);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd987, 0x89e9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd988, 0x69c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd989, 0x280e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd98a, 0x300e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd98b, 0x63ae);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd98c, 0x6f72);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd98d, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd98e, 0x628f);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd98f, 0x20a4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd990, 0x3004);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd991, 0x64d9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd992, 0x899e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd993, 0xbf0e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd994, 0xbf4e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd995, 0x4012);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd996, 0x5e23);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd997, 0x03d2);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd998, 0x001d);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd999, 0x2f0e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd99a, 0x300e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd99b, 0x2054);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd99c, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd99d, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd99e, 0x2064);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd99f, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9a0, 0x64de);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9a1, 0x8ee9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9a2, 0xbe0e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9a3, 0xbf4e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9a4, 0x5e23);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9a5, 0x0382);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9a6, 0x0009);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9a7, 0x2fee);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9a8, 0x3ffe);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9a9, 0x89e9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9aa, 0x69c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9ab, 0x280e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9ac, 0x300e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9ad, 0x63ae);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9ae, 0x0007);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9af, 0x401e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9b0, 0x99e9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9b1, 0x69c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9b2, 0x280e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9b3, 0x300e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9b4, 0x63ae);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9b5, 0x6f72);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9b6, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9b7, 0x628f);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9b8, 0x2844);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9b9, 0x3c04);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9ba, 0x64de);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9bb, 0x2d62);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9bc, 0x3022);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9bd, 0x1e52);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9be, 0x20c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9bf, 0x3c24);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9c0, 0x64de);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9c1, 0x2ff9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9c2, 0x3fd9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9c3, 0x89e9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9c4, 0x69c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9c5, 0x26c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9c6, 0x3c04);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9c7, 0x64de);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9c8, 0x2ff9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9c9, 0x3fa9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9ca, 0x89e9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9cb, 0x69c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9cc, 0x2894);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9cd, 0x3c04);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9ce, 0x64de);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9cf, 0x2f79);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9d0, 0x3ff9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9d1, 0x89e9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9d2, 0x69c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9d3, 0x2eb2);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9d4, 0x3022);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9d5, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9d6, 0x2894);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9d7, 0x3c04);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9d8, 0x64de);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9d9, 0x2089);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9da, 0x3009);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9db, 0x99e9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9dc, 0x69c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9dd, 0x26c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9de, 0x3c04);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9df, 0x64de);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9e0, 0x2009);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9e1, 0x3059);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9e2, 0x99e9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9e3, 0x69c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9e4, 0x20c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9e5, 0x3c24);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9e6, 0x64de);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9e7, 0x2009);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9e8, 0x3029);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9e9, 0x99e9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9ea, 0x69c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9eb, 0x6f72);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9ec, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9ed, 0x64d6);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9ee, 0x21f7);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9ef, 0x3fc7);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9f0, 0x8676);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9f1, 0xb505);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9f2, 0x9566);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9f3, 0x66c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9f4, 0xb545);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9f5, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9f6, 0x628f);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9f7, 0x6138);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9f8, 0x5883);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9f9, 0x2062);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9fa, 0x3032);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9fb, 0x1302);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9fc, 0x2ff7);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9fd, 0x3007);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9fe, 0x8786);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9ff, 0xb887);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda00, 0x8785);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda01, 0xb8c5);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda02, 0x5e63);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda03, 0x2f72);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda04, 0x3022);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda05, 0x13c2);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda06, 0x6f72);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda07, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda08, 0x0c82);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda09, 0x0d87);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda0a, 0x0e8d);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda0b, 0x1092);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda0c, 0x1198);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda0d, 0x129d);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda0e, 0x14a3);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda0f, 0x16a8);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda10, 0x17ae);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda11, 0x18b4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda12, 0x0000);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda13, 0x0000);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd080, 0x0100);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd092, 0x0000);   
+
+//sleep 400000	   # us
+for(i=0;i<100000;i++) NLM_C45_PRINTF(".");
+
+NLM_C45_WRITE (0, 0, 4, 1,0xcc08, 0x07c6);  // 5:0 = 0x6
+NLM_C45_WRITE (0, 0, 4, 1,0xcc08, 0x08c6);  //11:6 = 0x23
+NLM_C45_WRITE (0, 0, 4, 1,0xcc09, 0x07e8);  // 5:0 = 0x28
+NLM_C45_WRITE (0, 0, 4, 1,0xcc09, 0x0b68);  //11:6 = 0x2d
+NLM_C45_WRITE (0, 0, 4, 1,0xcc0e, 0x0001);  // 0:0 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xcc0e, 0x0000);  // 0:0 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xc2e1, 0x000f);  // 3:0 = 0xf
+NLM_C45_WRITE (0, 0, 4, 1,0xc088, 0x0004);  // 3:0 = 0x4
+NLM_C45_WRITE (0, 0, 4, 1,0xc290, 0x0001);  // 0:0 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xca01, 0x0041);  // 7:1 = 0x20
+NLM_C45_WRITE (0, 0, 4, 1,0xca51, 0x0041);  // 7:1 = 0x20
+NLM_C45_WRITE (0, 0, 4, 1,0xc2e8, 0x0000);  // 8:0 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xc2e9, 0x0000);  // 8:0 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xc2ea, 0x0000);  // 8:0 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xc2eb, 0x0000);  // 8:0 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xc2e6, 0x0800);  //11:11= 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xc2e6, 0x0000);  //11:11= 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xc2e0, 0x00e4);  // 7:0 = 0xe4
+NLM_C45_WRITE (0, 0, 4, 1,0xc2e1, 0x000f);  //13:12= 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xc20d, 0x0000);  // 9:8 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xc012, 0x000a);  // 3:0 = 0xa
+NLM_C45_WRITE (0, 0, 4, 1,0xc012, 0x00aa);  // 7:4 = 0xa
+NLM_C45_WRITE (0, 0, 4, 1,0xc0f0, 0x010a);  //  
+NLM_C45_WRITE (0, 0, 4, 1,0xc0f1, 0x0056);  //  #  7:0 = 0x56
+NLM_C45_WRITE (0, 0, 4, 1,0xc20d, 0x0002);  //  #  1:1 = 0x1
+//sleep 200000	   # us
+for(i=0;i<100000;i++) NLM_C45_PRINTF(".");
+
diff --git a/arch/mips/include/asm/netlogic/hal/NLP1042C2_RXAUI_Marvell.h b/arch/mips/include/asm/netlogic/hal/NLP1042C2_RXAUI_Marvell.h
new file mode 100644
index 0000000..e769a5b
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/hal/NLP1042C2_RXAUI_Marvell.h
@@ -0,0 +1,670 @@
+//
+// autogenerated by RegUtils.pm on 2011/12/22 12:13 format: mdioFullReg
+//
+NLM_C45_WRITE (0, 0, 0, 1,0xca42, 0x0100); // 10:8 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xca44, 0x81f8); // 15:12= 0x8
+NLM_C45_WRITE (0, 0, 0, 1,0xca44, 0x8218); //  9:5 = 0x10
+NLM_C45_WRITE (0, 0, 0, 1,0xca46, 0x0100); //  8:8 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xca46, 0x0900); // 11:9 = 0x4
+NLM_C45_WRITE (0, 0, 0, 1,0xcb0e, 0x1000); // 13:12= 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xca4c, 0x0002); //  5:0 = 0x2
+NLM_C45_WRITE (0, 0, 0, 1,0xca12, 0x0100); // 10:8 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xca14, 0x81f8); // 15:12= 0x8
+NLM_C45_WRITE (0, 0, 0, 1,0xca14, 0x8218); //  9:5 = 0x10
+NLM_C45_WRITE (0, 0, 0, 1,0xca16, 0x0100); //  8:8 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xca16, 0x0900); // 11:9 = 0x4
+NLM_C45_WRITE (0, 0, 0, 1,0xcb06, 0x1000); // 13:12= 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xca1c, 0x0002); //  5:0 = 0x2
+NLM_C45_WRITE (0, 0, 0, 1,0xca42, 0x0900); // 13:11= 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xca43, 0x2492); // 14:12= 0x2
+NLM_C45_WRITE (0, 0, 0, 1,0xc246, 0x0181); //  9:7 = 0x3
+NLM_C45_WRITE (0, 0, 0, 1,0xc242, 0x8100); //  2:0 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xc240, 0x1000); //  7:4 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xc240, 0x3800); // 13:11= 0x7
+NLM_C45_WRITE (0, 0, 0, 1,0xc242, 0x0100); // 15:13= 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xc246, 0x0180); //  0:0 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xc246, 0x0182); //  1:1 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xc243, 0x07e1); //  4:0 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xc243, 0x07e1); // 10:5 = 0x3f
+NLM_C45_WRITE (0, 0, 0, 1,0xc243, 0x17e1); // 15:11= 0x2
+NLM_C45_WRITE (0, 0, 0, 1,0xcb0b, 0x0001); //  1:0 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xcb0b, 0x0011); //  5:4 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xcb0b, 0x0311); //  9:8 = 0x3
+NLM_C45_WRITE (0, 0, 0, 1,0xcb0b, 0x0f11); // 11:10= 0x3
+NLM_C45_WRITE (0, 0, 0, 1,0xcb0b, 0x3f11); // 13:12= 0x3
+NLM_C45_WRITE (0, 0, 0, 1,0xcb0b, 0xff11); // 15:14= 0x3
+NLM_C45_WRITE (0, 0, 0, 1,0xcc00, 0x00f6); //  7:0 = 0xf6
+NLM_C45_WRITE (0, 0, 0, 1,0xcc02, 0x0081); //  7:7 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xcc02, 0x0001); //  7:7 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xcc07, 0x0117); //  4:0 = 0x17
+NLM_C45_WRITE (0, 0, 0, 1,0xcc08, 0x07df); //  5:0 = 0x1f
+NLM_C45_WRITE (0, 0, 0, 1,0xcc08, 0x07df); // 11:6 = 0x1f
+NLM_C45_WRITE (0, 0, 0, 1,0xcc09, 0x07df); //  5:0 = 0x1f
+NLM_C45_WRITE (0, 0, 0, 1,0xcc09, 0x07df); // 11:6 = 0x1f
+NLM_C45_WRITE (0, 0, 0, 1,0xcc07, 0x0017); //  8:5 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xcc0e, 0x0001); //  0:0 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xcc0e, 0x0003); //  1:1 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xcc0e, 0x0007); //  2:2 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xcc0e, 0x0006); //  0:0 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xcc0e, 0x0004); //  1:1 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xcc0e, 0x0000); //  2:2 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xcc02, 0x0021); //  5:5 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xcc04, 0x0001); //  0:0 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xcc04, 0x00b5); //  8:1 = 0x5a
+NLM_C45_WRITE (0, 0, 0, 1,0xcc11, 0x4904); //  5:3 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xcc11, 0x4804); //  8:6 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xcc11, 0x4004); // 11:9 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xcc11, 0x0004); // 14:12= 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xcc11, 0x0000); //  2:0 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xcb02, 0x00f0); //  7:4 = 0xf
+NLM_C45_WRITE (0, 0, 0, 1,0xcb02, 0x00ff); //  3:0 = 0xf
+NLM_C45_WRITE (0, 0, 0, 1,0xcb21, 0x1000); // 15:12= 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xca01, 0x0001); //  0:0 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xca01, 0x0011); //  7:1 = 0x8
+NLM_C45_WRITE (0, 0, 0, 1,0xcb1b, 0x1000); // 15:12= 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xca51, 0x0001); //  0:0 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xca51, 0x0011); //  7:1 = 0x8
+NLM_C45_WRITE (0, 0, 0, 1,0xc2c3, 0x000f); //  3:0 = 0xf
+NLM_C45_WRITE (0, 0, 0, 1,0xc2ca, 0x43c0); // 15:11= 0x8
+NLM_C45_WRITE (0, 0, 0, 1,0xc2d0, 0x43c0); // 15:11= 0x8
+NLM_C45_WRITE (0, 0, 0, 1,0xc2d6, 0x43c0); // 15:11= 0x8
+NLM_C45_WRITE (0, 0, 0, 1,0xc2dc, 0x43c0); // 15:11= 0x8
+NLM_C45_WRITE (0, 0, 0, 1,0xc2f1, 0x5f15); //  5:1 = 0xa
+NLM_C45_WRITE (0, 0, 0, 1,0xc2f1, 0x5e15); //  8:6 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xc2f5, 0x5f15); //  5:1 = 0xa
+NLM_C45_WRITE (0, 0, 0, 1,0xc2f5, 0x5e15); //  8:6 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xc2f9, 0x5f15); //  5:1 = 0xa
+NLM_C45_WRITE (0, 0, 0, 1,0xc2f9, 0x5e15); //  8:6 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xc2fd, 0x5f15); //  5:1 = 0xa
+NLM_C45_WRITE (0, 0, 0, 1,0xc2fd, 0x5e15); //  8:6 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xc2e8, 0x0100); //  8:0 = 0x100
+NLM_C45_WRITE (0, 0, 0, 1,0xc2e9, 0x0100); //  8:0 = 0x100
+NLM_C45_WRITE (0, 0, 0, 1,0xc2ea, 0x0100); //  8:0 = 0x100
+NLM_C45_WRITE (0, 0, 0, 1,0xc2eb, 0x0100); //  8:0 = 0x100
+NLM_C45_WRITE (0, 0, 0, 1,0xc2e6, 0x0800); // 11:11= 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xc2e6, 0x0000); // 11:11= 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xc017, 0xdf20); // 13:13= 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xc010, 0x4000); // 14:14= 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xcd40, 0x0001); //  3:0 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xc010, 0x6000); // 13:13= 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xcc05, 0x001f); //  2:0 = 0x7
+NLM_C45_WRITE (0, 0, 0, 1,0xcc03, 0x0020); //  9:0 = 0x20
+NLM_C45_WRITE (0, 0, 0, 1,0xc019, 0x1531); // 10:10= 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xff2a, 0x004a); // 
+NLM_C45_WRITE (0, 0, 0, 1,0xd008, 0x0001); //  0:0 = 0x1
+
+//sleep 100000	   # us
+for(i=0;i<100000;i++) NLM_C45_PRINTF(".");
+// WARNING: mdtrace, reg  1.d000 write value (5200) doesn't match read back (5000)
+
+NLM_C45_WRITE (0, 0, 0, 1,0xd000, 0x5200);   
+
+//sleep 100000	   # us
+for(i=0;i<100000;i++) NLM_C45_PRINTF(".");
+
+NLM_C45_WRITE (0, 0, 0, 1,0xd800, 0x2fff);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd801, 0x300f);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd802, 0x2ff4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd803, 0x3ef4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd804, 0x20ae);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd805, 0x301e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd806, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd807, 0x22c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd808, 0x3ef4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd809, 0x400e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd80a, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd80b, 0x220e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd80c, 0x300e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd80d, 0x2124);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd80e, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd80f, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd810, 0x23fe);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd811, 0x3c1e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd812, 0x2214);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd813, 0x3ca4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd814, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd815, 0x20a4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd816, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd817, 0x2dfe);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd818, 0x307e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd819, 0x6e24);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd81a, 0x6e24);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd81b, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd81c, 0x20e4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd81d, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd81e, 0x402e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd81f, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd820, 0x400e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd821, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd822, 0x2014);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd823, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd824, 0x64de);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd825, 0x6e8f);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd826, 0x400e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd827, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd828, 0x2044);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd829, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd82a, 0x64de);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd82b, 0x6e8f);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd82c, 0x201e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd82d, 0x300e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd82e, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd82f, 0x20d4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd830, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd831, 0x64de);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd832, 0x6e8f);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd833, 0x21fe);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd834, 0x300e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd835, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd836, 0x20e4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd837, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd838, 0x404e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd839, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd83a, 0x400e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd83b, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd83c, 0x21f5);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd83d, 0x3005);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd83e, 0xb805);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd83f, 0x8556);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd840, 0x8557);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd841, 0x8558);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd842, 0x8559);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd843, 0x855a);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd844, 0x400d);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd845, 0x6d8f);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd846, 0x2032);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd847, 0x3022);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd848, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd849, 0x2132);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd84a, 0x3022);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd84b, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd84c, 0x21c2);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd84d, 0x3022);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd84e, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd84f, 0x2302);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd850, 0x3022);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd851, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd852, 0x23a2);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd853, 0x3022);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd854, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd855, 0x24c2);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd856, 0x3022);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd857, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd858, 0x2562);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd859, 0x3022);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd85a, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd85b, 0x6f7e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd85c, 0x4004);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd85d, 0xb814);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd85e, 0x5e43);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd85f, 0x03d7);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd860, 0x2032);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd861, 0x3022);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd862, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd863, 0x200e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd864, 0x300e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd865, 0x0002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd866, 0xd01e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd867, 0x6e8f);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd868, 0x20fe);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd869, 0x300e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd86a, 0xb80e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd86b, 0xd01d);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd86c, 0x5de3);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd86d, 0x249e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd86e, 0x301e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd86f, 0x135e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd870, 0x6f7e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd871, 0x6f7e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd872, 0x20d4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd873, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd874, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd875, 0x20e4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd876, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd877, 0x404e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd878, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd879, 0x400e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd87a, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd87b, 0x6f7e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd87c, 0x2044);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd87d, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd87e, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd87f, 0x6f7e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd880, 0x2014);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd881, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd882, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd883, 0x200e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd884, 0x300e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd885, 0x2124);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd886, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd887, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd888, 0x2504);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd889, 0x3cd4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd88a, 0x4015);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd88b, 0x65c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd88c, 0x2514);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd88d, 0x3cd4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd88e, 0x64d5);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd88f, 0xb145);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd890, 0xb115);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd891, 0x65c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd892, 0x2bd2);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd893, 0x3012);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd894, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd895, 0x678f);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd896, 0x2514);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd897, 0x3cd4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd898, 0x64d5);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd899, 0xb145);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd89a, 0xb105);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd89b, 0x65c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd89c, 0x2bd2);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd89d, 0x3012);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd89e, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd89f, 0x6f78);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8a0, 0xe78e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8a1, 0x22c5);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8a2, 0x3ef5);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8a3, 0x6ec5);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8a4, 0x2084);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8a5, 0x3034);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8a6, 0x2005);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8a7, 0x3d75);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8a8, 0xc451);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8a9, 0x2f62);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8aa, 0x3022);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8ab, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8ac, 0x2444);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8ad, 0x3ca4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8ae, 0x2ed2);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8af, 0x3022);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8b0, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8b1, 0x2144);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8b2, 0x3ca4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8b3, 0x2ed2);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8b4, 0x3022);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8b5, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8b6, 0x2f02);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8b7, 0x3012);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8b8, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8b9, 0x28c2);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8ba, 0x3012);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8bb, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8bc, 0x0000);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8bd, 0x628f);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8be, 0x4007);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8bf, 0x2524);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8c0, 0x3cd4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8c1, 0x64d5);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8c2, 0x2005);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8c3, 0x9575);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8c4, 0x65c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8c5, 0x678f);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8c6, 0x2dd2);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8c7, 0x3012);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8c8, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8c9, 0x6f77);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8ca, 0x2514);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8cb, 0x3cd4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8cc, 0x64d5);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8cd, 0xbd05);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8ce, 0xbf45);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8cf, 0x2db2);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8d0, 0x3012);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8d1, 0x5553);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8d2, 0x1302);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8d3, 0x2006);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8d4, 0x3016);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8d5, 0x5763);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8d6, 0x13c2);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8d7, 0xd017);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8d8, 0x2bf2);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8d9, 0x3012);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8da, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8db, 0x6f72);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8dc, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8dd, 0x628f);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8de, 0x2514);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8df, 0x3cd4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8e0, 0x64d5);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8e1, 0x4026);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8e2, 0x9655);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8e3, 0x65c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8e4, 0x648f);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8e5, 0x401d);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8e6, 0x2f22);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8e7, 0x3012);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8e8, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8e9, 0x6f74);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8ea, 0x2fd6);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8eb, 0x3ff6);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8ec, 0x8655);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8ed, 0x65c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8ee, 0x6f72);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8ef, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8f0, 0x22cd);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8f1, 0x301d);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8f2, 0x2108);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8f3, 0x3808);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8f4, 0x628f);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8f5, 0x5dd3);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8f6, 0x2012);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8f7, 0x3022);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8f8, 0x1302);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8f9, 0x63a8);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8fa, 0x2b72);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8fb, 0x3022);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8fc, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8fd, 0xdffd);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8fe, 0x2f52);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd8ff, 0x3012);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd900, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd901, 0x6f72);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd902, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd903, 0x2214);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd904, 0x3ca4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd905, 0x64de);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd906, 0x2ef4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd907, 0x3ff4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd908, 0x8e4e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd909, 0x2214);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd90a, 0x3ca4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd90b, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd90c, 0x2104);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd90d, 0x3004);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd90e, 0x9e4e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd90f, 0x2214);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd910, 0x3ca4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd911, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd912, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd913, 0x2294);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd914, 0x3ca4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd915, 0x64db);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd916, 0x8bbc);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd917, 0xb84b);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd918, 0x300c);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd919, 0xdf0b);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd91a, 0xdf0c);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd91b, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd91c, 0xc5b5);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd91d, 0xc6c6);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd91e, 0x855e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd91f, 0xb84e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd920, 0x866c);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd921, 0xb84c);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd922, 0xb60c);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd923, 0x9cee);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd924, 0x20a4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd925, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd926, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd927, 0x20e4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd928, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd929, 0x202e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd92a, 0x300e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd92b, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd92c, 0x200e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd92d, 0x300e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd92e, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd92f, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd930, 0x22b4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd931, 0x3ca4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd932, 0x64db);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd933, 0x8bbc);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd934, 0xb84b);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd935, 0xb80c);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd936, 0xb84c);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd937, 0xdf0b);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd938, 0xdf0c);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd939, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd93a, 0xc7b7);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd93b, 0xc8c8);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd93c, 0x877e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd93d, 0xb84e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd93e, 0x888c);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd93f, 0xb84c);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd940, 0xb60c);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd941, 0x9cee);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd942, 0x20b4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd943, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd944, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd945, 0x20e4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd946, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd947, 0x402e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd948, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd949, 0x400e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd94a, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd94b, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd94c, 0x22a4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd94d, 0x3ca4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd94e, 0x64db);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd94f, 0x8bbc);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd950, 0xb84b);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd951, 0xb80c);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd952, 0xb84c);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd953, 0xdf0b);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd954, 0xdf0c);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd955, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd956, 0xc9b9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd957, 0xcaca);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd958, 0x899e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd959, 0xb84e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd95a, 0x8aac);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd95b, 0xb84c);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd95c, 0xb60c);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd95d, 0x9cee);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd95e, 0x20c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd95f, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd960, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd961, 0x20e4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd962, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd963, 0x402e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd964, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd965, 0x400e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd966, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd967, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd968, 0x628f);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd969, 0x20a4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd96a, 0x3004);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd96b, 0x64d9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd96c, 0x899e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd96d, 0xbf0e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd96e, 0xbf4e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd96f, 0x4012);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd970, 0x2f0e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd971, 0x300e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd972, 0x2054);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd973, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd974, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd975, 0x2064);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd976, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd977, 0x64de);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd978, 0x8ee9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd979, 0xbe0e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd97a, 0xbf4e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd97b, 0x5e23);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd97c, 0x0382);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd97d, 0x0008);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd97e, 0x401e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd97f, 0x99e9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd980, 0x69c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd981, 0x280e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd982, 0x300e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd983, 0x63ae);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd984, 0x0008);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd985, 0x2fee);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd986, 0x3ffe);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd987, 0x89e9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd988, 0x69c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd989, 0x280e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd98a, 0x300e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd98b, 0x63ae);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd98c, 0x6f72);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd98d, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd98e, 0x628f);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd98f, 0x20a4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd990, 0x3004);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd991, 0x64d9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd992, 0x899e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd993, 0xbf0e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd994, 0xbf4e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd995, 0x4012);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd996, 0x5e23);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd997, 0x03d2);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd998, 0x001d);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd999, 0x2f0e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd99a, 0x300e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd99b, 0x2054);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd99c, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd99d, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd99e, 0x2064);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd99f, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9a0, 0x64de);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9a1, 0x8ee9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9a2, 0xbe0e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9a3, 0xbf4e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9a4, 0x5e23);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9a5, 0x0382);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9a6, 0x0009);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9a7, 0x2fee);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9a8, 0x3ffe);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9a9, 0x89e9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9aa, 0x69c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9ab, 0x280e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9ac, 0x300e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9ad, 0x63ae);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9ae, 0x0007);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9af, 0x401e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9b0, 0x99e9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9b1, 0x69c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9b2, 0x280e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9b3, 0x300e);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9b4, 0x63ae);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9b5, 0x6f72);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9b6, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9b7, 0x628f);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9b8, 0x2844);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9b9, 0x3c04);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9ba, 0x64de);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9bb, 0x2d62);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9bc, 0x3022);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9bd, 0x1e52);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9be, 0x20c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9bf, 0x3c24);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9c0, 0x64de);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9c1, 0x2ff9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9c2, 0x3fd9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9c3, 0x89e9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9c4, 0x69c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9c5, 0x26c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9c6, 0x3c04);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9c7, 0x64de);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9c8, 0x2ff9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9c9, 0x3fa9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9ca, 0x89e9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9cb, 0x69c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9cc, 0x2894);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9cd, 0x3c04);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9ce, 0x64de);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9cf, 0x2f79);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9d0, 0x3ff9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9d1, 0x89e9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9d2, 0x69c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9d3, 0x2eb2);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9d4, 0x3022);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9d5, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9d6, 0x2894);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9d7, 0x3c04);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9d8, 0x64de);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9d9, 0x2089);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9da, 0x3009);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9db, 0x99e9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9dc, 0x69c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9dd, 0x26c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9de, 0x3c04);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9df, 0x64de);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9e0, 0x2009);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9e1, 0x3059);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9e2, 0x99e9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9e3, 0x69c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9e4, 0x20c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9e5, 0x3c24);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9e6, 0x64de);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9e7, 0x2009);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9e8, 0x3029);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9e9, 0x99e9);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9ea, 0x69c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9eb, 0x6f72);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9ec, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9ed, 0x64d6);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9ee, 0x21f7);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9ef, 0x3fc7);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9f0, 0x8676);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9f1, 0xb505);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9f2, 0x9566);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9f3, 0x66c4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9f4, 0xb545);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9f5, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9f6, 0x628f);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9f7, 0x6138);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9f8, 0x5883);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9f9, 0x2062);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9fa, 0x3032);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9fb, 0x1302);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9fc, 0x2ff7);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9fd, 0x3007);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9fe, 0x8786);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd9ff, 0xb887);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda00, 0x8785);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda01, 0xb8c5);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda02, 0x5e63);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda03, 0x2f72);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda04, 0x3022);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda05, 0x13c2);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda06, 0x6f72);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda07, 0x1002);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda08, 0x0c82);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda09, 0x0d87);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda0a, 0x0e8d);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda0b, 0x1092);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda0c, 0x1198);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda0d, 0x129d);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda0e, 0x14a3);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda0f, 0x16a8);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda10, 0x17ae);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda11, 0x18b4);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda12, 0x0000);   
+NLM_C45_WRITE (0, 0, 0, 1,0xda13, 0x0000);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd080, 0x0100);   
+NLM_C45_WRITE (0, 0, 0, 1,0xd092, 0x0000);   
+
+//sleep 400000	   # us
+for(i=0;i<100000;i++) NLM_C45_PRINTF(".");
+
+NLM_C45_WRITE (0, 0, 0, 1,0xcc08, 0x07c6);  // 5:0 = 0x6
+NLM_C45_WRITE (0, 0, 0, 1,0xcc08, 0x08c6);  //11:6 = 0x23
+NLM_C45_WRITE (0, 0, 0, 1,0xcc09, 0x07e8);  // 5:0 = 0x28
+NLM_C45_WRITE (0, 0, 0, 1,0xcc09, 0x0b68);  //11:6 = 0x2d
+NLM_C45_WRITE (0, 0, 0, 1,0xcc0e, 0x0001);  // 0:0 = 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xcc0e, 0x0000);  // 0:0 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xc2e1, 0x000f);  // 3:0 = 0xf
+NLM_C45_WRITE (0, 0, 0, 1,0xc088, 0x0004);  // 3:0 = 0x4
+NLM_C45_WRITE (0, 0, 0, 1,0xc290, 0x0000);  // 0:0 = 0x1   // Marvell mode
+NLM_C45_WRITE (0, 0, 0, 1,0xca01, 0x0041);  // 7:1 = 0x20
+NLM_C45_WRITE (0, 0, 0, 1,0xca51, 0x0041);  // 7:1 = 0x20
+NLM_C45_WRITE (0, 0, 0, 1,0xc2e8, 0x0000);  // 8:0 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xc2e9, 0x0000);  // 8:0 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xc2ea, 0x0000);  // 8:0 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xc2eb, 0x0000);  // 8:0 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xc2e6, 0x0800);  //11:11= 0x1
+NLM_C45_WRITE (0, 0, 0, 1,0xc2e6, 0x0000);  //11:11= 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xc2e0, 0x00e4);  // 7:0 = 0xe4
+NLM_C45_WRITE (0, 0, 0, 1,0xc2e1, 0x000f);  //13:12= 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xc20d, 0x0000);  // 9:8 = 0x0
+NLM_C45_WRITE (0, 0, 0, 1,0xc012, 0x000a);  // 3:0 = 0xa
+NLM_C45_WRITE (0, 0, 0, 1,0xc012, 0x00aa);  // 7:4 = 0xa
+NLM_C45_WRITE (0, 0, 0, 1,0xc0f0, 0x010a);  //  
+NLM_C45_WRITE (0, 0, 0, 1,0xc0f1, 0x0056);  //  #  7:0 = 0x56
+NLM_C45_WRITE (0, 0, 0, 1,0xc20d, 0x0002);  //  #  1:1 = 0x1
+//sleep 200000	   # us
+for(i=0;i<100000;i++) NLM_C45_PRINTF(".");
+
diff --git a/arch/mips/include/asm/netlogic/hal/NLP1042C2_RXAUI_Marvell_4.h b/arch/mips/include/asm/netlogic/hal/NLP1042C2_RXAUI_Marvell_4.h
new file mode 100644
index 0000000..917128b
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/hal/NLP1042C2_RXAUI_Marvell_4.h
@@ -0,0 +1,670 @@
+//
+// autogenerated by RegUtils.pm on 2011/12/22 12:13 format: mdioFullReg
+//
+NLM_C45_WRITE (0, 0, 4, 1,0xca42, 0x0100); // 10:8 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xca44, 0x81f8); // 15:12= 0x8
+NLM_C45_WRITE (0, 0, 4, 1,0xca44, 0x8218); //  9:5 = 0x10
+NLM_C45_WRITE (0, 0, 4, 1,0xca46, 0x0100); //  8:8 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xca46, 0x0900); // 11:9 = 0x4
+NLM_C45_WRITE (0, 0, 4, 1,0xcb0e, 0x1000); // 13:12= 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xca4c, 0x0002); //  5:0 = 0x2
+NLM_C45_WRITE (0, 0, 4, 1,0xca12, 0x0100); // 10:8 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xca14, 0x81f8); // 15:12= 0x8
+NLM_C45_WRITE (0, 0, 4, 1,0xca14, 0x8218); //  9:5 = 0x10
+NLM_C45_WRITE (0, 0, 4, 1,0xca16, 0x0100); //  8:8 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xca16, 0x0900); // 11:9 = 0x4
+NLM_C45_WRITE (0, 0, 4, 1,0xcb06, 0x1000); // 13:12= 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xca1c, 0x0002); //  5:0 = 0x2
+NLM_C45_WRITE (0, 0, 4, 1,0xca42, 0x0900); // 13:11= 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xca43, 0x2492); // 14:12= 0x2
+NLM_C45_WRITE (0, 0, 4, 1,0xc246, 0x0181); //  9:7 = 0x3
+NLM_C45_WRITE (0, 0, 4, 1,0xc242, 0x8100); //  2:0 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xc240, 0x1000); //  7:4 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xc240, 0x3800); // 13:11= 0x7
+NLM_C45_WRITE (0, 0, 4, 1,0xc242, 0x0100); // 15:13= 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xc246, 0x0180); //  0:0 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xc246, 0x0182); //  1:1 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xc243, 0x07e1); //  4:0 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xc243, 0x07e1); // 10:5 = 0x3f
+NLM_C45_WRITE (0, 0, 4, 1,0xc243, 0x17e1); // 15:11= 0x2
+NLM_C45_WRITE (0, 0, 4, 1,0xcb0b, 0x0001); //  1:0 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xcb0b, 0x0011); //  5:4 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xcb0b, 0x0311); //  9:8 = 0x3
+NLM_C45_WRITE (0, 0, 4, 1,0xcb0b, 0x0f11); // 11:10= 0x3
+NLM_C45_WRITE (0, 0, 4, 1,0xcb0b, 0x3f11); // 13:12= 0x3
+NLM_C45_WRITE (0, 0, 4, 1,0xcb0b, 0xff11); // 15:14= 0x3
+NLM_C45_WRITE (0, 0, 4, 1,0xcc00, 0x00f6); //  7:0 = 0xf6
+NLM_C45_WRITE (0, 0, 4, 1,0xcc02, 0x0081); //  7:7 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xcc02, 0x0001); //  7:7 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xcc07, 0x0117); //  4:0 = 0x17
+NLM_C45_WRITE (0, 0, 4, 1,0xcc08, 0x07df); //  5:0 = 0x1f
+NLM_C45_WRITE (0, 0, 4, 1,0xcc08, 0x07df); // 11:6 = 0x1f
+NLM_C45_WRITE (0, 0, 4, 1,0xcc09, 0x07df); //  5:0 = 0x1f
+NLM_C45_WRITE (0, 0, 4, 1,0xcc09, 0x07df); // 11:6 = 0x1f
+NLM_C45_WRITE (0, 0, 4, 1,0xcc07, 0x0017); //  8:5 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xcc0e, 0x0001); //  0:0 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xcc0e, 0x0003); //  1:1 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xcc0e, 0x0007); //  2:2 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xcc0e, 0x0006); //  0:0 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xcc0e, 0x0004); //  1:1 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xcc0e, 0x0000); //  2:2 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xcc02, 0x0021); //  5:5 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xcc04, 0x0001); //  0:0 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xcc04, 0x00b5); //  8:1 = 0x5a
+NLM_C45_WRITE (0, 0, 4, 1,0xcc11, 0x4904); //  5:3 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xcc11, 0x4804); //  8:6 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xcc11, 0x4004); // 11:9 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xcc11, 0x0004); // 14:12= 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xcc11, 0x0000); //  2:0 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xcb02, 0x00f0); //  7:4 = 0xf
+NLM_C45_WRITE (0, 0, 4, 1,0xcb02, 0x00ff); //  3:0 = 0xf
+NLM_C45_WRITE (0, 0, 4, 1,0xcb21, 0x1000); // 15:12= 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xca01, 0x0001); //  0:0 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xca01, 0x0011); //  7:1 = 0x8
+NLM_C45_WRITE (0, 0, 4, 1,0xcb1b, 0x1000); // 15:12= 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xca51, 0x0001); //  0:0 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xca51, 0x0011); //  7:1 = 0x8
+NLM_C45_WRITE (0, 0, 4, 1,0xc2c3, 0x000f); //  3:0 = 0xf
+NLM_C45_WRITE (0, 0, 4, 1,0xc2ca, 0x43c0); // 15:11= 0x8
+NLM_C45_WRITE (0, 0, 4, 1,0xc2d0, 0x43c0); // 15:11= 0x8
+NLM_C45_WRITE (0, 0, 4, 1,0xc2d6, 0x43c0); // 15:11= 0x8
+NLM_C45_WRITE (0, 0, 4, 1,0xc2dc, 0x43c0); // 15:11= 0x8
+NLM_C45_WRITE (0, 0, 4, 1,0xc2f1, 0x5f15); //  5:1 = 0xa
+NLM_C45_WRITE (0, 0, 4, 1,0xc2f1, 0x5e15); //  8:6 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xc2f5, 0x5f15); //  5:1 = 0xa
+NLM_C45_WRITE (0, 0, 4, 1,0xc2f5, 0x5e15); //  8:6 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xc2f9, 0x5f15); //  5:1 = 0xa
+NLM_C45_WRITE (0, 0, 4, 1,0xc2f9, 0x5e15); //  8:6 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xc2fd, 0x5f15); //  5:1 = 0xa
+NLM_C45_WRITE (0, 0, 4, 1,0xc2fd, 0x5e15); //  8:6 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xc2e8, 0x0100); //  8:0 = 0x100
+NLM_C45_WRITE (0, 0, 4, 1,0xc2e9, 0x0100); //  8:0 = 0x100
+NLM_C45_WRITE (0, 0, 4, 1,0xc2ea, 0x0100); //  8:0 = 0x100
+NLM_C45_WRITE (0, 0, 4, 1,0xc2eb, 0x0100); //  8:0 = 0x100
+NLM_C45_WRITE (0, 0, 4, 1,0xc2e6, 0x0800); // 11:11= 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xc2e6, 0x0000); // 11:11= 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xc017, 0xdf20); // 13:13= 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xc010, 0x4000); // 14:14= 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xcd40, 0x0001); //  3:0 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xc010, 0x6000); // 13:13= 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xcc05, 0x001f); //  2:0 = 0x7
+NLM_C45_WRITE (0, 0, 4, 1,0xcc03, 0x0020); //  9:0 = 0x20
+NLM_C45_WRITE (0, 0, 4, 1,0xc019, 0x1531); // 10:10= 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xff2a, 0x004a); // 
+NLM_C45_WRITE (0, 0, 4, 1,0xd008, 0x0001); //  0:0 = 0x1
+
+//sleep 100000	   # us
+for(i=0;i<100000;i++) NLM_C45_PRINTF(".");
+// WARNING: mdtrace, reg  1.d000 write value (5200) doesn't match read back (5000)
+
+NLM_C45_WRITE (0, 0, 4, 1,0xd000, 0x5200);   
+
+//sleep 100000	   # us
+for(i=0;i<100000;i++) NLM_C45_PRINTF(".");
+
+NLM_C45_WRITE (0, 0, 4, 1,0xd800, 0x2fff);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd801, 0x300f);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd802, 0x2ff4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd803, 0x3ef4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd804, 0x20ae);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd805, 0x301e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd806, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd807, 0x22c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd808, 0x3ef4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd809, 0x400e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd80a, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd80b, 0x220e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd80c, 0x300e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd80d, 0x2124);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd80e, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd80f, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd810, 0x23fe);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd811, 0x3c1e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd812, 0x2214);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd813, 0x3ca4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd814, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd815, 0x20a4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd816, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd817, 0x2dfe);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd818, 0x307e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd819, 0x6e24);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd81a, 0x6e24);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd81b, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd81c, 0x20e4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd81d, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd81e, 0x402e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd81f, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd820, 0x400e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd821, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd822, 0x2014);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd823, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd824, 0x64de);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd825, 0x6e8f);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd826, 0x400e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd827, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd828, 0x2044);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd829, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd82a, 0x64de);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd82b, 0x6e8f);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd82c, 0x201e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd82d, 0x300e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd82e, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd82f, 0x20d4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd830, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd831, 0x64de);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd832, 0x6e8f);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd833, 0x21fe);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd834, 0x300e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd835, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd836, 0x20e4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd837, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd838, 0x404e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd839, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd83a, 0x400e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd83b, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd83c, 0x21f5);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd83d, 0x3005);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd83e, 0xb805);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd83f, 0x8556);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd840, 0x8557);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd841, 0x8558);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd842, 0x8559);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd843, 0x855a);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd844, 0x400d);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd845, 0x6d8f);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd846, 0x2032);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd847, 0x3022);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd848, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd849, 0x2132);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd84a, 0x3022);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd84b, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd84c, 0x21c2);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd84d, 0x3022);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd84e, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd84f, 0x2302);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd850, 0x3022);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd851, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd852, 0x23a2);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd853, 0x3022);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd854, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd855, 0x24c2);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd856, 0x3022);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd857, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd858, 0x2562);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd859, 0x3022);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd85a, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd85b, 0x6f7e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd85c, 0x4004);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd85d, 0xb814);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd85e, 0x5e43);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd85f, 0x03d7);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd860, 0x2032);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd861, 0x3022);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd862, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd863, 0x200e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd864, 0x300e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd865, 0x0002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd866, 0xd01e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd867, 0x6e8f);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd868, 0x20fe);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd869, 0x300e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd86a, 0xb80e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd86b, 0xd01d);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd86c, 0x5de3);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd86d, 0x249e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd86e, 0x301e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd86f, 0x135e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd870, 0x6f7e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd871, 0x6f7e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd872, 0x20d4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd873, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd874, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd875, 0x20e4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd876, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd877, 0x404e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd878, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd879, 0x400e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd87a, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd87b, 0x6f7e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd87c, 0x2044);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd87d, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd87e, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd87f, 0x6f7e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd880, 0x2014);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd881, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd882, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd883, 0x200e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd884, 0x300e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd885, 0x2124);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd886, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd887, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd888, 0x2504);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd889, 0x3cd4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd88a, 0x4015);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd88b, 0x65c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd88c, 0x2514);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd88d, 0x3cd4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd88e, 0x64d5);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd88f, 0xb145);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd890, 0xb115);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd891, 0x65c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd892, 0x2bd2);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd893, 0x3012);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd894, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd895, 0x678f);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd896, 0x2514);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd897, 0x3cd4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd898, 0x64d5);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd899, 0xb145);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd89a, 0xb105);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd89b, 0x65c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd89c, 0x2bd2);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd89d, 0x3012);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd89e, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd89f, 0x6f78);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8a0, 0xe78e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8a1, 0x22c5);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8a2, 0x3ef5);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8a3, 0x6ec5);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8a4, 0x2084);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8a5, 0x3034);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8a6, 0x2005);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8a7, 0x3d75);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8a8, 0xc451);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8a9, 0x2f62);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8aa, 0x3022);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8ab, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8ac, 0x2444);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8ad, 0x3ca4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8ae, 0x2ed2);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8af, 0x3022);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8b0, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8b1, 0x2144);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8b2, 0x3ca4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8b3, 0x2ed2);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8b4, 0x3022);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8b5, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8b6, 0x2f02);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8b7, 0x3012);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8b8, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8b9, 0x28c2);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8ba, 0x3012);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8bb, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8bc, 0x0000);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8bd, 0x628f);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8be, 0x4007);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8bf, 0x2524);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8c0, 0x3cd4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8c1, 0x64d5);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8c2, 0x2005);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8c3, 0x9575);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8c4, 0x65c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8c5, 0x678f);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8c6, 0x2dd2);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8c7, 0x3012);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8c8, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8c9, 0x6f77);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8ca, 0x2514);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8cb, 0x3cd4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8cc, 0x64d5);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8cd, 0xbd05);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8ce, 0xbf45);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8cf, 0x2db2);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8d0, 0x3012);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8d1, 0x5553);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8d2, 0x1302);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8d3, 0x2006);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8d4, 0x3016);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8d5, 0x5763);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8d6, 0x13c2);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8d7, 0xd017);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8d8, 0x2bf2);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8d9, 0x3012);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8da, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8db, 0x6f72);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8dc, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8dd, 0x628f);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8de, 0x2514);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8df, 0x3cd4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8e0, 0x64d5);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8e1, 0x4026);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8e2, 0x9655);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8e3, 0x65c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8e4, 0x648f);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8e5, 0x401d);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8e6, 0x2f22);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8e7, 0x3012);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8e8, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8e9, 0x6f74);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8ea, 0x2fd6);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8eb, 0x3ff6);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8ec, 0x8655);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8ed, 0x65c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8ee, 0x6f72);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8ef, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8f0, 0x22cd);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8f1, 0x301d);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8f2, 0x2108);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8f3, 0x3808);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8f4, 0x628f);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8f5, 0x5dd3);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8f6, 0x2012);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8f7, 0x3022);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8f8, 0x1302);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8f9, 0x63a8);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8fa, 0x2b72);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8fb, 0x3022);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8fc, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8fd, 0xdffd);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8fe, 0x2f52);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd8ff, 0x3012);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd900, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd901, 0x6f72);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd902, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd903, 0x2214);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd904, 0x3ca4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd905, 0x64de);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd906, 0x2ef4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd907, 0x3ff4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd908, 0x8e4e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd909, 0x2214);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd90a, 0x3ca4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd90b, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd90c, 0x2104);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd90d, 0x3004);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd90e, 0x9e4e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd90f, 0x2214);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd910, 0x3ca4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd911, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd912, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd913, 0x2294);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd914, 0x3ca4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd915, 0x64db);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd916, 0x8bbc);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd917, 0xb84b);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd918, 0x300c);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd919, 0xdf0b);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd91a, 0xdf0c);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd91b, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd91c, 0xc5b5);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd91d, 0xc6c6);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd91e, 0x855e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd91f, 0xb84e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd920, 0x866c);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd921, 0xb84c);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd922, 0xb60c);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd923, 0x9cee);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd924, 0x20a4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd925, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd926, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd927, 0x20e4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd928, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd929, 0x202e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd92a, 0x300e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd92b, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd92c, 0x200e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd92d, 0x300e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd92e, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd92f, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd930, 0x22b4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd931, 0x3ca4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd932, 0x64db);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd933, 0x8bbc);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd934, 0xb84b);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd935, 0xb80c);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd936, 0xb84c);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd937, 0xdf0b);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd938, 0xdf0c);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd939, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd93a, 0xc7b7);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd93b, 0xc8c8);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd93c, 0x877e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd93d, 0xb84e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd93e, 0x888c);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd93f, 0xb84c);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd940, 0xb60c);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd941, 0x9cee);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd942, 0x20b4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd943, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd944, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd945, 0x20e4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd946, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd947, 0x402e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd948, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd949, 0x400e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd94a, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd94b, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd94c, 0x22a4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd94d, 0x3ca4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd94e, 0x64db);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd94f, 0x8bbc);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd950, 0xb84b);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd951, 0xb80c);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd952, 0xb84c);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd953, 0xdf0b);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd954, 0xdf0c);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd955, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd956, 0xc9b9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd957, 0xcaca);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd958, 0x899e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd959, 0xb84e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd95a, 0x8aac);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd95b, 0xb84c);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd95c, 0xb60c);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd95d, 0x9cee);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd95e, 0x20c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd95f, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd960, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd961, 0x20e4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd962, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd963, 0x402e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd964, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd965, 0x400e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd966, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd967, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd968, 0x628f);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd969, 0x20a4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd96a, 0x3004);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd96b, 0x64d9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd96c, 0x899e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd96d, 0xbf0e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd96e, 0xbf4e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd96f, 0x4012);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd970, 0x2f0e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd971, 0x300e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd972, 0x2054);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd973, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd974, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd975, 0x2064);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd976, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd977, 0x64de);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd978, 0x8ee9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd979, 0xbe0e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd97a, 0xbf4e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd97b, 0x5e23);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd97c, 0x0382);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd97d, 0x0008);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd97e, 0x401e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd97f, 0x99e9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd980, 0x69c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd981, 0x280e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd982, 0x300e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd983, 0x63ae);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd984, 0x0008);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd985, 0x2fee);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd986, 0x3ffe);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd987, 0x89e9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd988, 0x69c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd989, 0x280e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd98a, 0x300e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd98b, 0x63ae);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd98c, 0x6f72);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd98d, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd98e, 0x628f);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd98f, 0x20a4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd990, 0x3004);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd991, 0x64d9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd992, 0x899e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd993, 0xbf0e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd994, 0xbf4e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd995, 0x4012);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd996, 0x5e23);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd997, 0x03d2);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd998, 0x001d);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd999, 0x2f0e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd99a, 0x300e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd99b, 0x2054);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd99c, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd99d, 0x6ec4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd99e, 0x2064);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd99f, 0x3cc4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9a0, 0x64de);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9a1, 0x8ee9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9a2, 0xbe0e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9a3, 0xbf4e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9a4, 0x5e23);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9a5, 0x0382);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9a6, 0x0009);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9a7, 0x2fee);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9a8, 0x3ffe);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9a9, 0x89e9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9aa, 0x69c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9ab, 0x280e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9ac, 0x300e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9ad, 0x63ae);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9ae, 0x0007);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9af, 0x401e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9b0, 0x99e9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9b1, 0x69c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9b2, 0x280e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9b3, 0x300e);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9b4, 0x63ae);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9b5, 0x6f72);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9b6, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9b7, 0x628f);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9b8, 0x2844);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9b9, 0x3c04);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9ba, 0x64de);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9bb, 0x2d62);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9bc, 0x3022);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9bd, 0x1e52);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9be, 0x20c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9bf, 0x3c24);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9c0, 0x64de);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9c1, 0x2ff9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9c2, 0x3fd9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9c3, 0x89e9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9c4, 0x69c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9c5, 0x26c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9c6, 0x3c04);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9c7, 0x64de);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9c8, 0x2ff9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9c9, 0x3fa9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9ca, 0x89e9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9cb, 0x69c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9cc, 0x2894);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9cd, 0x3c04);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9ce, 0x64de);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9cf, 0x2f79);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9d0, 0x3ff9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9d1, 0x89e9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9d2, 0x69c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9d3, 0x2eb2);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9d4, 0x3022);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9d5, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9d6, 0x2894);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9d7, 0x3c04);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9d8, 0x64de);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9d9, 0x2089);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9da, 0x3009);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9db, 0x99e9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9dc, 0x69c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9dd, 0x26c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9de, 0x3c04);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9df, 0x64de);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9e0, 0x2009);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9e1, 0x3059);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9e2, 0x99e9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9e3, 0x69c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9e4, 0x20c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9e5, 0x3c24);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9e6, 0x64de);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9e7, 0x2009);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9e8, 0x3029);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9e9, 0x99e9);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9ea, 0x69c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9eb, 0x6f72);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9ec, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9ed, 0x64d6);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9ee, 0x21f7);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9ef, 0x3fc7);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9f0, 0x8676);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9f1, 0xb505);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9f2, 0x9566);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9f3, 0x66c4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9f4, 0xb545);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9f5, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9f6, 0x628f);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9f7, 0x6138);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9f8, 0x5883);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9f9, 0x2062);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9fa, 0x3032);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9fb, 0x1302);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9fc, 0x2ff7);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9fd, 0x3007);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9fe, 0x8786);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd9ff, 0xb887);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda00, 0x8785);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda01, 0xb8c5);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda02, 0x5e63);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda03, 0x2f72);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda04, 0x3022);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda05, 0x13c2);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda06, 0x6f72);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda07, 0x1002);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda08, 0x0c82);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda09, 0x0d87);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda0a, 0x0e8d);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda0b, 0x1092);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda0c, 0x1198);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda0d, 0x129d);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda0e, 0x14a3);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda0f, 0x16a8);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda10, 0x17ae);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda11, 0x18b4);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda12, 0x0000);   
+NLM_C45_WRITE (0, 0, 4, 1,0xda13, 0x0000);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd080, 0x0100);   
+NLM_C45_WRITE (0, 0, 4, 1,0xd092, 0x0000);   
+
+//sleep 400000	   # us
+for(i=0;i<100000;i++) NLM_C45_PRINTF(".");
+
+NLM_C45_WRITE (0, 0, 4, 1,0xcc08, 0x07c6);  // 5:0 = 0x6
+NLM_C45_WRITE (0, 0, 4, 1,0xcc08, 0x08c6);  //11:6 = 0x23
+NLM_C45_WRITE (0, 0, 4, 1,0xcc09, 0x07e8);  // 5:0 = 0x28
+NLM_C45_WRITE (0, 0, 4, 1,0xcc09, 0x0b68);  //11:6 = 0x2d
+NLM_C45_WRITE (0, 0, 4, 1,0xcc0e, 0x0001);  // 0:0 = 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xcc0e, 0x0000);  // 0:0 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xc2e1, 0x000f);  // 3:0 = 0xf
+NLM_C45_WRITE (0, 0, 4, 1,0xc088, 0x0004);  // 3:0 = 0x4
+NLM_C45_WRITE (0, 0, 4, 1,0xc290, 0x0000);  // 0:0 = 0x1 // Marvell mode
+NLM_C45_WRITE (0, 0, 4, 1,0xca01, 0x0041);  // 7:1 = 0x20
+NLM_C45_WRITE (0, 0, 4, 1,0xca51, 0x0041);  // 7:1 = 0x20
+NLM_C45_WRITE (0, 0, 4, 1,0xc2e8, 0x0000);  // 8:0 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xc2e9, 0x0000);  // 8:0 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xc2ea, 0x0000);  // 8:0 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xc2eb, 0x0000);  // 8:0 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xc2e6, 0x0800);  //11:11= 0x1
+NLM_C45_WRITE (0, 0, 4, 1,0xc2e6, 0x0000);  //11:11= 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xc2e0, 0x00e4);  // 7:0 = 0xe4
+NLM_C45_WRITE (0, 0, 4, 1,0xc2e1, 0x000f);  //13:12= 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xc20d, 0x0000);  // 9:8 = 0x0
+NLM_C45_WRITE (0, 0, 4, 1,0xc012, 0x000a);  // 3:0 = 0xa
+NLM_C45_WRITE (0, 0, 4, 1,0xc012, 0x00aa);  // 7:4 = 0xa
+NLM_C45_WRITE (0, 0, 4, 1,0xc0f0, 0x010a);  //  
+NLM_C45_WRITE (0, 0, 4, 1,0xc0f1, 0x0056);  //  #  7:0 = 0x56
+NLM_C45_WRITE (0, 0, 4, 1,0xc20d, 0x0002);  //  #  1:1 = 0x1
+//sleep 200000	   # us
+for(i=0;i<100000;i++) NLM_C45_PRINTF(".");
+
diff --git a/arch/mips/include/asm/netlogic/hal/NLP1042C2_XAUI.h b/arch/mips/include/asm/netlogic/hal/NLP1042C2_XAUI.h
new file mode 100644
index 0000000..b1ac21a
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/hal/NLP1042C2_XAUI.h
@@ -0,0 +1,481 @@
+//#NLM_C45_WRITE (0, 0, 0, 1, 0xc2e1, data);
+
+
+NLM_C45_WRITE (0, 0, 0, 1, 0x0000, 0xA040);
+//s 200000);
+//sleep   300000;  # wait for uC to settle offset calibration
+//for(i=0;i<100000;i++){
+for(i=0;i<10000;i++){
+NLM_C45_PRINTF(".");
+}
+NLM_C45_PRINTF("\nDone");
+NLM_C45_WRITE (0, 0, 0, 1, 0xC019, 0x1531);
+NLM_C45_WRITE (0, 0, 0, 1, 0xC010, 0x4000);
+NLM_C45_WRITE (0, 0, 0, 1, 0xC017, 0xDF20);
+NLM_C45_WRITE (0, 0, 0, 1, 0xC010, 0x6000);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCD40, 0x0001);
+NLM_C45_WRITE (0, 0, 0, 1, 0xC019, 0x1531);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCA42, 0x0100);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCA44, 0x81F8);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCA44, 0x8218);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCA46, 0x0100);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCA46, 0x0900);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCB0E, 0x1000);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCA4C, 0x0002);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCA12, 0x0100);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCA14, 0x81F8);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCA14, 0x8218);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCA16, 0x0100);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCA16, 0x0900);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCB06, 0x1000);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCA1C, 0x0002);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCA42, 0x0900);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCA43, 0x2492);
+NLM_C45_WRITE (0, 0, 0, 1, 0xC246, 0x0181);
+NLM_C45_WRITE (0, 0, 0, 1, 0xC242, 0x8100);
+NLM_C45_WRITE (0, 0, 0, 1, 0xC240, 0x1000);
+NLM_C45_WRITE (0, 0, 0, 1, 0xC240, 0x3800);
+NLM_C45_WRITE (0, 0, 0, 1, 0xC242, 0x0100);
+NLM_C45_WRITE (0, 0, 0, 1, 0xC246, 0x0180);
+NLM_C45_WRITE (0, 0, 0, 1, 0xC246, 0x0182);
+NLM_C45_WRITE (0, 0, 0, 1, 0xC243, 0x07E1);
+NLM_C45_WRITE (0, 0, 0, 1, 0xC243, 0x17E1);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCB0B, 0x0001);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCB0B, 0x0011);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCB0B, 0x0311);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCB0B, 0x0F11);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCB0B, 0x3F11);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCB0B, 0xFF11);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCC00, 0x00F6);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCC02, 0x0081);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCC02, 0x0001);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCC07, 0x0117);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCC07, 0x0017);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCC0E, 0x0001);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCC0E, 0x0003);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCC0E, 0x0007);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCC0E, 0x0006);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCC0E, 0x0004);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCC0E, 0x0000);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCC02, 0x0021);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCC04, 0x0001);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCC04, 0x00B5);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCC11, 0x4904);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCC11, 0x4804);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCC11, 0x4004);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCC11, 0x0004);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCC11, 0x0000);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCB02, 0x00F0);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCB02, 0x00FF);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCB21, 0x1000);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCA01, 0x0001);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCA01, 0x0011);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCB1B, 0x1000);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCA51, 0x0001);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCA51, 0x0011);
+NLM_C45_WRITE (0, 0, 0, 1, 0xC2C3, 0x000F);
+NLM_C45_WRITE (0, 0, 0, 1, 0xC2CA, 0x43C0);
+NLM_C45_WRITE (0, 0, 0, 1, 0xC2D0, 0x43C0);
+NLM_C45_WRITE (0, 0, 0, 1, 0xC2D6, 0x43C0);
+NLM_C45_WRITE (0, 0, 0, 1, 0xC2DC, 0x43C0);
+NLM_C45_WRITE (0, 0, 0, 1, 0xC2F1, 0x5F15);
+NLM_C45_WRITE (0, 0, 0, 1, 0xC2F1, 0x5E15);
+NLM_C45_WRITE (0, 0, 0, 1, 0xC2F5, 0x5F15);
+NLM_C45_WRITE (0, 0, 0, 1, 0xC2F5, 0x5E15);
+NLM_C45_WRITE (0, 0, 0, 1, 0xC2F9, 0x5F15);
+NLM_C45_WRITE (0, 0, 0, 1, 0xC2F9, 0x5E15);
+NLM_C45_WRITE (0, 0, 0, 1, 0xC2FD, 0x5F15);
+NLM_C45_WRITE (0, 0, 0, 1, 0xC2FD, 0x5E15);
+NLM_C45_WRITE (0, 0, 0, 1, 0xC2E8, 0x0100);
+NLM_C45_WRITE (0, 0, 0, 1, 0xC2E9, 0x0100);
+NLM_C45_WRITE (0, 0, 0, 1, 0xC2EA, 0x0100);
+NLM_C45_WRITE (0, 0, 0, 1, 0xC2EB, 0x0100);
+NLM_C45_WRITE (0, 0, 0, 1, 0xC2E6, 0x0800);
+NLM_C45_WRITE (0, 0, 0, 1, 0xC2E6, 0x0000);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCC05, 0x001F);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCC03, 0x0020);
+NLM_C45_WRITE (0, 0, 0, 1, 0xFF2A, 0x004A);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCD40, 0x000F);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCD4A, 0x0400);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCD40, 0x0001);
+NLM_C45_WRITE (0, 0, 0, 1, 0xC0F0, 0x0102);
+NLM_C45_WRITE (0, 0, 0, 1, 0xC0F1, 0x0056);
+NLM_C45_WRITE (0, 0, 0, 1, 0xC20D, 0x0002);
+
+//s 200000);
+//s 100000);
+//sleep   300000;  # wait for uC to settle offset calibration
+//for(i=0;i<100000;i++){
+for(i=0;i<10000;i++){
+NLM_C45_PRINTF(".");
+}
+NLM_C45_PRINTF("\nDone");
+
+NLM_C45_WRITE (0, 0, 0, 1, 0xC0F1, 0x0056);
+//s 200000);
+//sleep   300000;  # wait for uC to settle offset calibration
+//for(i=0;i<100000;i++){
+for(i=0;i<10000;i++){
+NLM_C45_PRINTF(".");
+}
+NLM_C45_PRINTF("\nDone");
+
+
+NLM_C45_WRITE (0, 0, 0, 1, 0xD008, 0x0001);
+//s 200000);
+//sleep   300000;  # wait for uC to settle offset calibration
+//for(i=0;i<100000;i++){
+for(i=0;i<10000;i++){
+NLM_C45_PRINTF(".");
+}
+NLM_C45_PRINTF("\nDone");
+
+NLM_C45_WRITE (0, 0, 0, 1, 0xD000, 0x5200);
+//s 200000);
+//sleep   300000;  # wait for uC to settle offset calibration
+//for(i=0;i<100000;i++){
+for(i=0;i<10000;i++){
+NLM_C45_PRINTF(".");
+}
+NLM_C45_PRINTF("\nDone");
+
+NLM_C45_WRITE (0, 0, 0, 1, 0xD800, 0x2FFF);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD801, 0x300F);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD802, 0x220E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD803, 0x300E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD804, 0x2124);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD805, 0x3CC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD806, 0x6EC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD807, 0x23FE);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD808, 0x3C1E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD809, 0x2214);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD80A, 0x3CA4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD80B, 0x6EC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD80C, 0x20A4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD80D, 0x3CC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD80E, 0x2DFE);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD80F, 0x307E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD810, 0x6E24);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD811, 0x6E24);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD812, 0x6EC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD813, 0x20E4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD814, 0x3CC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD815, 0x402E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD816, 0x6EC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD817, 0x400E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD818, 0x6EC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD819, 0x2014);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD81A, 0x3CC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD81B, 0x64DE);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD81C, 0x6E8F);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD81D, 0x400E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD81E, 0x6EC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD81F, 0x2044);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD820, 0x3CC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD821, 0x64DE);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD822, 0x6E8F);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD823, 0x201E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD824, 0x300E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD825, 0x6EC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD826, 0x20D4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD827, 0x3CC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD828, 0x64DE);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD829, 0x6E8F);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD82A, 0x21FE);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD82B, 0x300E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD82C, 0x6EC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD82D, 0x20E4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD82E, 0x3CC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD82F, 0x404E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD830, 0x6EC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD831, 0x400E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD832, 0x6EC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD833, 0x21F5);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD834, 0x3005);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD835, 0xB805);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD836, 0x8556);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD837, 0x8557);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD838, 0x8558);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD839, 0x8559);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD83A, 0x855A);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD83B, 0x400D);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD83C, 0x6D8F);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD83D, 0x2DD2);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD83E, 0x3012);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD83F, 0x1002);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD840, 0x2ED2);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD841, 0x3012);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD842, 0x1002);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD843, 0x2F62);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD844, 0x3012);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD845, 0x1002);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD846, 0x20A2);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD847, 0x3022);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD848, 0x1002);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD849, 0x2142);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD84A, 0x3022);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD84B, 0x1002);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD84C, 0x2262);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD84D, 0x3022);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD84E, 0x1002);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD84F, 0x2302);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD850, 0x3022);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD851, 0x1002);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD852, 0x6F7E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD853, 0x4004);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD854, 0xB814);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD855, 0x5E43);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD856, 0x03D7);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD857, 0x2DD2);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD858, 0x3012);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD859, 0x1002);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD85A, 0x200E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD85B, 0x300E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD85C, 0x0002);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD85D, 0xD01E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD85E, 0x6E8F);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD85F, 0x20FE);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD860, 0x300E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD861, 0xB80E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD862, 0xD01D);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD863, 0x5DE3);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD864, 0x240E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD865, 0x301E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD866, 0x135E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD867, 0x6F7E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD868, 0x6F7E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD869, 0x20D4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD86A, 0x3CC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD86B, 0x6EC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD86C, 0x20E4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD86D, 0x3CC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD86E, 0x404E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD86F, 0x6EC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD870, 0x400E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD871, 0x6EC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD872, 0x6F7E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD873, 0x2044);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD874, 0x3CC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD875, 0x6EC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD876, 0x6F7E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD877, 0x2014);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD878, 0x3CC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD879, 0x6EC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD87A, 0x200E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD87B, 0x300E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD87C, 0x2124);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD87D, 0x3CC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD87E, 0x6EC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD87F, 0x2504);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD880, 0x3CD4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD881, 0x4015);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD882, 0x65C4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD883, 0x2514);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD884, 0x3CD4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD885, 0x64D5);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD886, 0xB145);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD887, 0xB115);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD888, 0x65C4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD889, 0x29F2);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD88A, 0x3012);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD88B, 0x1002);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD88C, 0x678F);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD88D, 0x2514);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD88E, 0x3CD4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD88F, 0x64D5);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD890, 0xB145);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD891, 0xB105);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD892, 0x65C4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD893, 0x29F2);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD894, 0x3012);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD895, 0x1002);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD896, 0x6F78);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD897, 0xE78E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD898, 0x2D02);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD899, 0x3012);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD89A, 0x1002);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD89B, 0x2832);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD89C, 0x3012);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD89D, 0x1002);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD89E, 0x0000);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD89F, 0x628F);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8A0, 0x4007);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8A1, 0x2524);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8A2, 0x3CD4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8A3, 0x64D5);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8A4, 0x2005);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8A5, 0x9575);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8A6, 0x65C4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8A7, 0x678F);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8A8, 0x2BF2);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8A9, 0x3012);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8AA, 0x1002);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8AB, 0x6F77);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8AC, 0x2514);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8AD, 0x3CD4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8AE, 0x64D5);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8AF, 0xBD05);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8B0, 0xBF45);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8B1, 0x2BD2);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8B2, 0x3012);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8B3, 0x5553);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8B4, 0x1302);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8B5, 0x2006);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8B6, 0x3016);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8B7, 0x5763);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8B8, 0x13C2);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8B9, 0xD017);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8BA, 0x2A12);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8BB, 0x3012);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8BC, 0x1002);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8BD, 0x6F72);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8BE, 0x1002);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8BF, 0x628F);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8C0, 0x2514);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8C1, 0x3CD4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8C2, 0x64D5);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8C3, 0x4026);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8C4, 0x9655);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8C5, 0x65C4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8C6, 0x401D);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8C7, 0x2D22);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8C8, 0x3012);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8C9, 0x1002);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8CA, 0x2FD6);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8CB, 0x3FF6);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8CC, 0x8655);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8CD, 0x65C4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8CE, 0x6F72);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8CF, 0x1002);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8D0, 0x200D);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8D1, 0x302D);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8D2, 0x2408);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8D3, 0x35D8);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8D4, 0x5DD3);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8D5, 0x0307);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8D6, 0x8887);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8D7, 0x63A7);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8D8, 0x8887);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8D9, 0x63A7);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8DA, 0xDFFD);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8DB, 0x00F9);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8DC, 0x1002);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8DD, 0x2214);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8DE, 0x3CA4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8DF, 0x64DE);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8E0, 0x2EF4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8E1, 0x3FF4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8E2, 0x8E4E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8E3, 0x2214);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8E4, 0x3CA4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8E5, 0x6EC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8E6, 0x2104);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8E7, 0x3004);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8E8, 0x9E4E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8E9, 0x2214);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8EA, 0x3CA4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8EB, 0x6EC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8EC, 0x1002);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8ED, 0x2294);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8EE, 0x3CA4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8EF, 0x64DB);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8F0, 0x8BBC);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8F1, 0xB84B);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8F2, 0x300C);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8F3, 0xDF0B);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8F4, 0xDF0C);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8F5, 0x1002);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8F6, 0xC5B5);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8F7, 0xC6C6);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8F8, 0x855E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8F9, 0xB84E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8FA, 0x866C);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8FB, 0xB84C);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8FC, 0xB60C);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8FD, 0x9CEE);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8FE, 0x20A4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD8FF, 0x3CC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD900, 0x6EC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD901, 0x20E4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD902, 0x3CC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD903, 0x202E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD904, 0x300E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD905, 0x6EC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD906, 0x200E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD907, 0x300E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD908, 0x6EC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD909, 0x1002);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD90A, 0x22B4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD90B, 0x3CA4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD90C, 0x64DB);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD90D, 0x8BBC);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD90E, 0xB84B);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD90F, 0xB80C);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD910, 0xB84C);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD911, 0xDF0B);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD912, 0xDF0C);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD913, 0x1002);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD914, 0xC7B7);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD915, 0xC8C8);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD916, 0x877E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD917, 0xB84E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD918, 0x888C);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD919, 0xB84C);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD91A, 0xB60C);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD91B, 0x9CEE);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD91C, 0x20B4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD91D, 0x3CC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD91E, 0x6EC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD91F, 0x20E4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD920, 0x3CC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD921, 0x402E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD922, 0x6EC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD923, 0x400E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD924, 0x6EC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD925, 0x1002);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD926, 0x22A4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD927, 0x3CA4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD928, 0x64DB);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD929, 0x8BBC);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD92A, 0xB84B);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD92B, 0xB80C);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD92C, 0xB84C);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD92D, 0xDF0B);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD92E, 0xDF0C);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD92F, 0x1002);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD930, 0xC9B9);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD931, 0xCACA);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD932, 0x899E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD933, 0xB84E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD934, 0x8AAC);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD935, 0xB84C);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD936, 0xB60C);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD937, 0x9CEE);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD938, 0x20C4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD939, 0x3CC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD93A, 0x6EC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD93B, 0x20E4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD93C, 0x3CC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD93D, 0x402E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD93E, 0x6EC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD93F, 0x400E);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD940, 0x6EC4);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD941, 0x1002);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD942, 0x0000);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD080, 0x0100);
+NLM_C45_WRITE (0, 0, 0, 1, 0xD092, 0x0000);
+//s 300000);
+//sleep   300000;  # wait for uC to settle offset calibration
+//for(i=0;i<100000;i++){
+for(i=0;i<10000;i++){
+NLM_C45_PRINTF(".");
+}
+NLM_C45_PRINTF("\nDone");
+
+NLM_C45_WRITE (0, 0, 0, 1, 0xCC08, 0x07C6);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCC08, 0x08C6);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCC09, 0x07E8);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCC09, 0x0B68);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCC0E, 0x0001);
+NLM_C45_WRITE (0, 0, 0, 1, 0xCC0E, 0x0000);
+//);
diff --git a/arch/mips/include/asm/netlogic/hal/NLP1042C2_XAUI_4.h b/arch/mips/include/asm/netlogic/hal/NLP1042C2_XAUI_4.h
new file mode 100644
index 0000000..db4fe04
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/hal/NLP1042C2_XAUI_4.h
@@ -0,0 +1,480 @@
+//#NLM_C45_WRITE (0, 0, 4, 1, 0xc2e1, data);
+
+NLM_C45_WRITE (0, 0, 4, 1, 0x0000, 0xA040);
+//s 200000);
+//sleep   300000;  # wait for uC to settle offset calibration
+//for(i=0;i<100000;i++){
+for(i=0;i<10000;i++){
+NLM_C45_PRINTF(".");
+}
+NLM_C45_PRINTF("\nDone");
+NLM_C45_WRITE (0, 0, 4, 1, 0xC019, 0x1531);
+NLM_C45_WRITE (0, 0, 4, 1, 0xC010, 0x4000);
+NLM_C45_WRITE (0, 0, 4, 1, 0xC017, 0xDF20);
+NLM_C45_WRITE (0, 0, 4, 1, 0xC010, 0x6000);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCD40, 0x0001);
+NLM_C45_WRITE (0, 0, 4, 1, 0xC019, 0x1531);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCA42, 0x0100);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCA44, 0x81F8);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCA44, 0x8218);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCA46, 0x0100);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCA46, 0x0900);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCB0E, 0x1000);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCA4C, 0x0002);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCA12, 0x0100);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCA14, 0x81F8);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCA14, 0x8218);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCA16, 0x0100);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCA16, 0x0900);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCB06, 0x1000);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCA1C, 0x0002);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCA42, 0x0900);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCA43, 0x2492);
+NLM_C45_WRITE (0, 0, 4, 1, 0xC246, 0x0181);
+NLM_C45_WRITE (0, 0, 4, 1, 0xC242, 0x8100);
+NLM_C45_WRITE (0, 0, 4, 1, 0xC240, 0x1000);
+NLM_C45_WRITE (0, 0, 4, 1, 0xC240, 0x3800);
+NLM_C45_WRITE (0, 0, 4, 1, 0xC242, 0x0100);
+NLM_C45_WRITE (0, 0, 4, 1, 0xC246, 0x0180);
+NLM_C45_WRITE (0, 0, 4, 1, 0xC246, 0x0182);
+NLM_C45_WRITE (0, 0, 4, 1, 0xC243, 0x07E1);
+NLM_C45_WRITE (0, 0, 4, 1, 0xC243, 0x17E1);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCB0B, 0x0001);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCB0B, 0x0011);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCB0B, 0x0311);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCB0B, 0x0F11);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCB0B, 0x3F11);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCB0B, 0xFF11);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCC00, 0x00F6);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCC02, 0x0081);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCC02, 0x0001);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCC07, 0x0117);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCC07, 0x0017);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCC0E, 0x0001);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCC0E, 0x0003);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCC0E, 0x0007);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCC0E, 0x0006);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCC0E, 0x0004);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCC0E, 0x0000);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCC02, 0x0021);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCC04, 0x0001);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCC04, 0x00B5);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCC11, 0x4904);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCC11, 0x4804);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCC11, 0x4004);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCC11, 0x0004);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCC11, 0x0000);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCB02, 0x00F0);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCB02, 0x00FF);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCB21, 0x1000);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCA01, 0x0001);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCA01, 0x0011);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCB1B, 0x1000);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCA51, 0x0001);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCA51, 0x0011);
+NLM_C45_WRITE (0, 0, 4, 1, 0xC2C3, 0x000F);
+NLM_C45_WRITE (0, 0, 4, 1, 0xC2CA, 0x43C0);
+NLM_C45_WRITE (0, 0, 4, 1, 0xC2D0, 0x43C0);
+NLM_C45_WRITE (0, 0, 4, 1, 0xC2D6, 0x43C0);
+NLM_C45_WRITE (0, 0, 4, 1, 0xC2DC, 0x43C0);
+NLM_C45_WRITE (0, 0, 4, 1, 0xC2F1, 0x5F15);
+NLM_C45_WRITE (0, 0, 4, 1, 0xC2F1, 0x5E15);
+NLM_C45_WRITE (0, 0, 4, 1, 0xC2F5, 0x5F15);
+NLM_C45_WRITE (0, 0, 4, 1, 0xC2F5, 0x5E15);
+NLM_C45_WRITE (0, 0, 4, 1, 0xC2F9, 0x5F15);
+NLM_C45_WRITE (0, 0, 4, 1, 0xC2F9, 0x5E15);
+NLM_C45_WRITE (0, 0, 4, 1, 0xC2FD, 0x5F15);
+NLM_C45_WRITE (0, 0, 4, 1, 0xC2FD, 0x5E15);
+NLM_C45_WRITE (0, 0, 4, 1, 0xC2E8, 0x0100);
+NLM_C45_WRITE (0, 0, 4, 1, 0xC2E9, 0x0100);
+NLM_C45_WRITE (0, 0, 4, 1, 0xC2EA, 0x0100);
+NLM_C45_WRITE (0, 0, 4, 1, 0xC2EB, 0x0100);
+NLM_C45_WRITE (0, 0, 4, 1, 0xC2E6, 0x0800);
+NLM_C45_WRITE (0, 0, 4, 1, 0xC2E6, 0x0000);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCC05, 0x001F);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCC03, 0x0020);
+NLM_C45_WRITE (0, 0, 4, 1, 0xFF2A, 0x004A);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCD40, 0x000F);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCD4A, 0x0400);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCD40, 0x0001);
+NLM_C45_WRITE (0, 0, 4, 1, 0xC0F0, 0x0102);
+NLM_C45_WRITE (0, 0, 4, 1, 0xC0F1, 0x0056);
+NLM_C45_WRITE (0, 0, 4, 1, 0xC20D, 0x0002);
+
+//s 200000);
+//s 100000);
+//sleep   300000;  # wait for uC to settle offset calibration
+//for(i=0;i<100000;i++){
+for(i=0;i<10000;i++){
+NLM_C45_PRINTF(".");
+}
+NLM_C45_PRINTF("\nDone");
+
+NLM_C45_WRITE (0, 0, 4, 1, 0xC0F1, 0x0056);
+//s 200000);
+//sleep   300000;  # wait for uC to settle offset calibration
+//for(i=0;i<100000;i++){
+for(i=0;i<10000;i++){
+NLM_C45_PRINTF(".");
+}
+NLM_C45_PRINTF("\nDone");
+
+
+NLM_C45_WRITE (0, 0, 4, 1, 0xD008, 0x0001);
+//s 200000);
+//sleep   300000;  # wait for uC to settle offset calibration
+//for(i=0;i<100000;i++){
+for(i=0;i<10000;i++){
+NLM_C45_PRINTF(".");
+}
+NLM_C45_PRINTF("\nDone");
+
+NLM_C45_WRITE (0, 0, 4, 1, 0xD000, 0x5200);
+//s 200000);
+//sleep   300000;  # wait for uC to settle offset calibration
+//for(i=0;i<100000;i++){
+for(i=0;i<10000;i++){
+NLM_C45_PRINTF(".");
+}
+NLM_C45_PRINTF("\nDone");
+
+NLM_C45_WRITE (0, 0, 4, 1, 0xD800, 0x2FFF);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD801, 0x300F);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD802, 0x220E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD803, 0x300E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD804, 0x2124);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD805, 0x3CC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD806, 0x6EC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD807, 0x23FE);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD808, 0x3C1E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD809, 0x2214);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD80A, 0x3CA4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD80B, 0x6EC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD80C, 0x20A4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD80D, 0x3CC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD80E, 0x2DFE);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD80F, 0x307E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD810, 0x6E24);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD811, 0x6E24);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD812, 0x6EC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD813, 0x20E4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD814, 0x3CC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD815, 0x402E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD816, 0x6EC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD817, 0x400E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD818, 0x6EC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD819, 0x2014);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD81A, 0x3CC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD81B, 0x64DE);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD81C, 0x6E8F);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD81D, 0x400E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD81E, 0x6EC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD81F, 0x2044);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD820, 0x3CC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD821, 0x64DE);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD822, 0x6E8F);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD823, 0x201E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD824, 0x300E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD825, 0x6EC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD826, 0x20D4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD827, 0x3CC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD828, 0x64DE);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD829, 0x6E8F);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD82A, 0x21FE);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD82B, 0x300E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD82C, 0x6EC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD82D, 0x20E4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD82E, 0x3CC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD82F, 0x404E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD830, 0x6EC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD831, 0x400E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD832, 0x6EC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD833, 0x21F5);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD834, 0x3005);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD835, 0xB805);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD836, 0x8556);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD837, 0x8557);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD838, 0x8558);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD839, 0x8559);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD83A, 0x855A);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD83B, 0x400D);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD83C, 0x6D8F);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD83D, 0x2DD2);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD83E, 0x3012);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD83F, 0x1002);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD840, 0x2ED2);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD841, 0x3012);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD842, 0x1002);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD843, 0x2F62);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD844, 0x3012);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD845, 0x1002);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD846, 0x20A2);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD847, 0x3022);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD848, 0x1002);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD849, 0x2142);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD84A, 0x3022);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD84B, 0x1002);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD84C, 0x2262);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD84D, 0x3022);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD84E, 0x1002);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD84F, 0x2302);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD850, 0x3022);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD851, 0x1002);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD852, 0x6F7E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD853, 0x4004);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD854, 0xB814);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD855, 0x5E43);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD856, 0x03D7);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD857, 0x2DD2);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD858, 0x3012);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD859, 0x1002);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD85A, 0x200E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD85B, 0x300E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD85C, 0x0002);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD85D, 0xD01E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD85E, 0x6E8F);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD85F, 0x20FE);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD860, 0x300E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD861, 0xB80E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD862, 0xD01D);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD863, 0x5DE3);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD864, 0x240E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD865, 0x301E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD866, 0x135E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD867, 0x6F7E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD868, 0x6F7E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD869, 0x20D4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD86A, 0x3CC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD86B, 0x6EC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD86C, 0x20E4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD86D, 0x3CC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD86E, 0x404E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD86F, 0x6EC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD870, 0x400E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD871, 0x6EC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD872, 0x6F7E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD873, 0x2044);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD874, 0x3CC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD875, 0x6EC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD876, 0x6F7E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD877, 0x2014);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD878, 0x3CC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD879, 0x6EC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD87A, 0x200E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD87B, 0x300E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD87C, 0x2124);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD87D, 0x3CC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD87E, 0x6EC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD87F, 0x2504);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD880, 0x3CD4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD881, 0x4015);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD882, 0x65C4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD883, 0x2514);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD884, 0x3CD4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD885, 0x64D5);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD886, 0xB145);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD887, 0xB115);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD888, 0x65C4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD889, 0x29F2);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD88A, 0x3012);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD88B, 0x1002);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD88C, 0x678F);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD88D, 0x2514);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD88E, 0x3CD4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD88F, 0x64D5);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD890, 0xB145);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD891, 0xB105);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD892, 0x65C4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD893, 0x29F2);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD894, 0x3012);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD895, 0x1002);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD896, 0x6F78);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD897, 0xE78E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD898, 0x2D02);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD899, 0x3012);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD89A, 0x1002);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD89B, 0x2832);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD89C, 0x3012);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD89D, 0x1002);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD89E, 0x0000);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD89F, 0x628F);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8A0, 0x4007);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8A1, 0x2524);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8A2, 0x3CD4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8A3, 0x64D5);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8A4, 0x2005);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8A5, 0x9575);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8A6, 0x65C4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8A7, 0x678F);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8A8, 0x2BF2);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8A9, 0x3012);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8AA, 0x1002);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8AB, 0x6F77);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8AC, 0x2514);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8AD, 0x3CD4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8AE, 0x64D5);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8AF, 0xBD05);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8B0, 0xBF45);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8B1, 0x2BD2);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8B2, 0x3012);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8B3, 0x5553);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8B4, 0x1302);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8B5, 0x2006);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8B6, 0x3016);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8B7, 0x5763);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8B8, 0x13C2);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8B9, 0xD017);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8BA, 0x2A12);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8BB, 0x3012);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8BC, 0x1002);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8BD, 0x6F72);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8BE, 0x1002);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8BF, 0x628F);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8C0, 0x2514);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8C1, 0x3CD4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8C2, 0x64D5);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8C3, 0x4026);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8C4, 0x9655);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8C5, 0x65C4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8C6, 0x401D);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8C7, 0x2D22);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8C8, 0x3012);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8C9, 0x1002);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8CA, 0x2FD6);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8CB, 0x3FF6);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8CC, 0x8655);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8CD, 0x65C4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8CE, 0x6F72);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8CF, 0x1002);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8D0, 0x200D);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8D1, 0x302D);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8D2, 0x2408);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8D3, 0x35D8);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8D4, 0x5DD3);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8D5, 0x0307);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8D6, 0x8887);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8D7, 0x63A7);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8D8, 0x8887);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8D9, 0x63A7);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8DA, 0xDFFD);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8DB, 0x00F9);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8DC, 0x1002);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8DD, 0x2214);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8DE, 0x3CA4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8DF, 0x64DE);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8E0, 0x2EF4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8E1, 0x3FF4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8E2, 0x8E4E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8E3, 0x2214);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8E4, 0x3CA4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8E5, 0x6EC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8E6, 0x2104);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8E7, 0x3004);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8E8, 0x9E4E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8E9, 0x2214);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8EA, 0x3CA4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8EB, 0x6EC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8EC, 0x1002);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8ED, 0x2294);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8EE, 0x3CA4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8EF, 0x64DB);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8F0, 0x8BBC);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8F1, 0xB84B);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8F2, 0x300C);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8F3, 0xDF0B);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8F4, 0xDF0C);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8F5, 0x1002);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8F6, 0xC5B5);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8F7, 0xC6C6);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8F8, 0x855E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8F9, 0xB84E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8FA, 0x866C);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8FB, 0xB84C);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8FC, 0xB60C);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8FD, 0x9CEE);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8FE, 0x20A4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD8FF, 0x3CC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD900, 0x6EC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD901, 0x20E4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD902, 0x3CC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD903, 0x202E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD904, 0x300E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD905, 0x6EC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD906, 0x200E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD907, 0x300E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD908, 0x6EC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD909, 0x1002);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD90A, 0x22B4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD90B, 0x3CA4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD90C, 0x64DB);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD90D, 0x8BBC);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD90E, 0xB84B);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD90F, 0xB80C);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD910, 0xB84C);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD911, 0xDF0B);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD912, 0xDF0C);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD913, 0x1002);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD914, 0xC7B7);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD915, 0xC8C8);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD916, 0x877E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD917, 0xB84E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD918, 0x888C);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD919, 0xB84C);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD91A, 0xB60C);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD91B, 0x9CEE);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD91C, 0x20B4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD91D, 0x3CC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD91E, 0x6EC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD91F, 0x20E4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD920, 0x3CC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD921, 0x402E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD922, 0x6EC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD923, 0x400E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD924, 0x6EC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD925, 0x1002);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD926, 0x22A4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD927, 0x3CA4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD928, 0x64DB);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD929, 0x8BBC);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD92A, 0xB84B);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD92B, 0xB80C);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD92C, 0xB84C);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD92D, 0xDF0B);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD92E, 0xDF0C);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD92F, 0x1002);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD930, 0xC9B9);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD931, 0xCACA);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD932, 0x899E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD933, 0xB84E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD934, 0x8AAC);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD935, 0xB84C);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD936, 0xB60C);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD937, 0x9CEE);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD938, 0x20C4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD939, 0x3CC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD93A, 0x6EC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD93B, 0x20E4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD93C, 0x3CC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD93D, 0x402E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD93E, 0x6EC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD93F, 0x400E);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD940, 0x6EC4);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD941, 0x1002);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD942, 0x0000);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD080, 0x0100);
+NLM_C45_WRITE (0, 0, 4, 1, 0xD092, 0x0000);
+//s 300000);
+//sleep   300000;  # wait for uC to settle offset calibration
+//for(i=0;i<100000;i++){
+for(i=0;i<10000;i++){
+NLM_C45_PRINTF(".");
+}
+NLM_C45_PRINTF("\nNLP_XAUI_4 Done");
+
+NLM_C45_WRITE (0, 0, 4, 1, 0xCC08, 0x07C6);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCC08, 0x08C6);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCC09, 0x07E8);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCC09, 0x0B68);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCC0E, 0x0001);
+NLM_C45_WRITE (0, 0, 4, 1, 0xCC0E, 0x0000);
+//);
diff --git a/arch/mips/include/asm/netlogic/hal/nlm_evp_cpld.h b/arch/mips/include/asm/netlogic/hal/nlm_evp_cpld.h
index 74953bd..454bcee 100644
--- a/arch/mips/include/asm/netlogic/hal/nlm_evp_cpld.h
+++ b/arch/mips/include/asm/netlogic/hal/nlm_evp_cpld.h
@@ -32,6 +32,7 @@ typedef struct {
 #define DC_SGMII        1
 #define DC_XAUI         2
 #define DC_NOT_PRSNT    3
+#define DC_RXAUI        6 /*not support by CPLD : Defined for software using only */
 
 #define DC_TYPE(val,slot)       ((val >> (slot * 2)) & 0x3)
 #define EVP_VER(val)            (val & 0x8)
diff --git a/arch/mips/include/asm/netlogic/hal/nlm_hal_nae.h b/arch/mips/include/asm/netlogic/hal/nlm_hal_nae.h
index 4619abf..f87323e 100644
--- a/arch/mips/include/asm/netlogic/hal/nlm_hal_nae.h
+++ b/arch/mips/include/asm/netlogic/hal/nlm_hal_nae.h
@@ -25,10 +25,11 @@ THE POSSIBILITY OF SUCH DAMAGE.
 
 #ifndef _NLM_HAL_NAE_H_
 #define _NLM_HAL_NAE_H_
-
+#ifdef NLM_LINUX_KERNEL
+#include <linux/netdevice.h>
+#endif
 #include "nlm_hal.h"
 
-
 #define NUM_DIST_VEC 		16
 #define NUM_WORDS_PER_DV 	16
 #define MAX_DV_TBL_ENTRIES (NUM_DIST_VEC * NUM_WORDS_PER_DV)
@@ -55,6 +56,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define MAX_PORTS_PERBLOCK	4
 #define XLP_MAX_INTERLAKEN_IF	2
 
+#define XLP3XX_MAX_NAE_FREQUENCY	250 /* in MHZ */
 #define XLP3XX_MAX_NAE_COMPLEX	2
 #define XLP3XX_MAX_NAE_CONTEXTS	64
 #define MAX_POE_CLASSES     	8
@@ -303,6 +305,9 @@ static inline uint32_t stg2_ms_credit(void)
 #define nlm_hal_write_ucode(node, ucore, offset, val) \
   nlh_write_cfg_reg32((xlp_mac_base[node] + 0x10000 + (ucore * CODE_SIZE_PER_UCORE) + offset), (val))
 
+#define nlm_hal_read_ucode(node, ucore, offset) \
+  nlh_read_cfg_reg32((xlp_mac_base[node] + 0x10000 + (ucore * CODE_SIZE_PER_UCORE) + offset))
+
 #define nlm_hal_write_mac_reg(node, blk, iface, reg, val) nlm_hal_write_32bit_reg(XLP_MAC_OFFSET(node, blk, iface), (reg), (val))
 #define nlm_hal_read_mac_reg(node, blk, iface, reg) nlm_hal_read_32bit_reg(XLP_MAC_OFFSET(node, blk, iface), (reg))
 
@@ -339,16 +344,10 @@ extern int nlm_hal_open_if(int node, int type, int  inf);
 extern int nlm_hal_close_if(int node, int type, int  inf);
 extern void nlm_hal_init_ingress(int node, int desc_size);
 
-extern int nlm_hal_nae_send(int dest, int fbid, unsigned long long phys_addr, int len, unsigned int flags);
-extern int nlm_hal_nae_recv(int rx_vc, unsigned long long *phys_addr, unsigned int *flags);
-
-extern int nlm_hal_soc_recv(int dst_vc, unsigned int *intf, unsigned long long *phys_addr, unsigned int *flags);
-
 extern int nlm_enable_poe_statistics(int node);
 extern int nlm_disable_poe_statistics(int node);
 extern int nlm_read_poe_statistics(int node, struct poe_statistics *stats);
 
-
 enum NAE_REG_CMD {
         CMD_READ = 0,
         CMD_WRITE
@@ -391,32 +390,81 @@ enum if_speed {
 #define INF_NIBBLE_MODE 0x1
 
 /* PHY Access routines
+ * Internal MDIO: 0x799
+ *    -- support clause 22
+ *    -- support clause 45 with devType=0x5 only
+ * External MDIO: EXT_G0:0x79D EXT_G1:0x7A1
+ *    -- support clause 22 only
+ *    -- used for 1GE interface
+ * External MDIO: EXT_XG0:0x7A5 EXT_XG1:0x7A9
+ *    -- support clause 22
+ *    -- support clause 45 with devType as argument
+ *    -- used for 10GE interface
  */
 enum {
-	NLM_HAL_INT_MDIO,
-	NLM_HAL_EXT_MDIO,
+	NLM_HAL_INT_MDIO      = 0, /* Internal MDIO Clause 22 */
+	NLM_HAL_EXT_MDIO      = 1, /* EXT_G<0,1>: MDIO Clause 22 */
+	NLM_HAL_INT_MDIO_C45  = 2, /* Internal MDIO: Clause 45 */
+	NLM_HAL_EXT_MDIO_C45  = 3  /* EXT_XG<0,1>: External MDIO: Clause 45 */
 };
-extern int nlm_hal_mdio_read(int node, int type, int bus,int block, int intf_type,
-			     int phyaddr, int regidx);
-extern int nlm_hal_mdio_write(int node, int type, int bus, int block, int intf_type, int phyaddr,
-			      int regidx, uint16_t val);
+
+/* MDIO reset/read/write
+ * Note: block, intf_type are going to be removed.
+ * block     = BLOCK_7  (NAE Block)
+ * intf_type = LINE_CFG (0xF)
+ */
 extern int nlm_hal_mdio_reset(int node, int type, int bus, int block, int intf_type);
+extern int nlm_hal_mdio_wr(int node, int type, int bus, int phyaddr, int regidx, uint16_t val);
+extern int nlm_hal_mdio_rd(int node, int type, int bus, int phyaddr, int regidx);
+extern int nlm_hal_mdio_read(int node, int type, int bus, int block, int intf_type, int phyaddr, int regidx);
+extern int nlm_hal_mdio_write(int node, int type, int bus, int block, int intf_type, int phyaddr, int regidx, uint16_t val);
+
+/* Internal MDIO: C45 read/write */
+extern int nlm_hal_xgmac_imdio_write(int node, int phyaddr, int regidx, uint16_t val);
+extern int nlm_hal_xgmac_imdio_read(int node, int phyaddr, int regidx);
+
+/* External MDIO: C45 read/write */
+extern int nlm_hal_xgmac_mdio_read(int node, int bus, int phyaddr,
+        int dev_addr, int regidx);
+extern int nlm_hal_xgmac_mdio_write(int node, int bus, int phyaddr,
+        int dev_addr, int regidx, uint16_t val);
+
+extern int nlm_hal_c45_mdio_indirect_write_external(int node, int bus,
+			int phyaddr, int dev_addr, uint32_t reg_addr, uint32_t write_data);
+extern int nlm_hal_c45_mdio_indirect_read_external (int node, int bus,
+			int phyaddr, int dev_addr, uint32_t reg_addr);
+
+#define NLM_C45_WRITE(node, bus, phyaddr, dev_addr, reg_addr, wdata)	\
+   nlm_hal_c45_mdio_indirect_write_external(node, bus, phyaddr, dev_addr, reg_addr, wdata)
+
+#define NLM_C45_READ(node, bus, phyaddr, dev_addr, reg_addr)	\
+   nlm_hal_c45_mdio_indirect_read_external(node, bus, phyaddr, dev_addr, reg_addr)
 
 extern void xlp3xx_8xxb0_nae_lane_reset_txpll(int node, int block, int lane_ctrl, int phymode);
 extern void xlp8xx_ax_nae_lane_reset_txpll(int node, int block, int lane_ctrl, int phymode);
 
 /*  PCS initialization
  */
+extern void nlm_hal_mdio_init(int node);
 extern void nlm_hal_sgmii_pcs_init(int node, int sgmii_cplx_mask);
-extern void nlm_hal_xaui_pcs_init(int node, int xaui_cplx_mask);
+extern void nlm_hal_xaui_pcs_init(int node, int xaui_cplx_mask, int rxaui_en);
 extern int nlm_hal_ilk_pcs_init(int node, uint32_t ilk_complex_map);
 extern int nlm_hal_init_cs34x7(int hwport,int num_lanes, int lane_rate);
+extern int cortina_set_max_framesize(int hwport, int port, uint16_t framesize);
+#ifdef NLM_HAL_LINUX_KERNEL
+#ifdef NLM_CORTINA_SUPPORT
+extern int cortina_get_mac_stats(int node, int hwport, int port, void *);
+#endif
+extern int nlm_hal_get_ilk_mac_stats(int node, int block, int port, void *);
+#endif
 extern int is_xlp_ilk_lanealigned(int node, int blk);
 extern void nlm_hal_sgmii_phy_init(int node);
 
 extern int nlm_hal_init_nae(void *fdt, int dom_id);
+extern void nlm_hal_reset_nae_ownership(void *fdt, int dom_id);
 extern void reset_nae_mgmt(int node);
-extern int nlm_hal_write_ucore_shared_mem(unsigned int *data, int words);
+extern int nlm_hal_nae_drain_frin_fifo_descs(int node, int inf);
+extern int nlm_hal_write_ucore_shared_mem(int node, unsigned int *data, int words);
 
 extern int nlm_hal_get_phy_status(int node, int inf, uint32_t *speed, uint32_t *duplex);
 
@@ -427,7 +475,6 @@ extern void nlm_hal_mac_enable(int node, int inf, int type);
 extern uint16_t nlm_hal_get_hwport(int node, uint32_t context);
 extern int nlm_hal_set_xaui_framesize(int node, int block, uint32_t tx_size, uint32_t rx_size);
 extern int nlm_hal_set_sgmii_framesize(int node, int block, int index, uint32_t size);
-
 extern int nlm_config_vfbid_table(int node, uint32_t start, uint32_t num_entries, uint32_t *vfbid_tbl);
 #endif //__ASSEMBLY__
 
@@ -505,4 +552,7 @@ static inline void nlm_write_poe_distr_threshold(int node, uint32_t threshold0,
 	nlm_hal_write_poe_pcie_reg(node, POE_DIST_THRESHOLD_0+3, threshold3);
 }
 
+extern void nlm_hal_rxaui_nlp1042c2_init(int port, int rxaui_mode);
+
+
 #endif //#ifndef _NLM_HAL_NAE_H_
diff --git a/arch/mips/include/asm/netlogic/hal/nlm_hal_xlp_dev.h b/arch/mips/include/asm/netlogic/hal/nlm_hal_xlp_dev.h
index 7a4dd66..78108ab 100644
--- a/arch/mips/include/asm/netlogic/hal/nlm_hal_xlp_dev.h
+++ b/arch/mips/include/asm/netlogic/hal/nlm_hal_xlp_dev.h
@@ -412,6 +412,8 @@ enum net_cfg_regs {
  L4_CTABLE_0_0                      = 0x250,
  L4_CTABLE_0_1                      = 0x251,
  VFBID_TO_DEST_MAP_STATUS           = 0x380,
+ NET_COMMON0_INTR_STS		    = 0x2A8,
+ NET_COMMON0_INTR_MASK		    = 0x2A9,
 };
 //
 enum if_cfg_regs {
@@ -750,6 +752,7 @@ enum {
 	PHYMODE_XAUI = 1,
 	PHYMODE_SGMII = 2,
 	PHYMODE_IL = 3,
+	PHYMODE_RXAUI = 6,
 };
 
 enum {
@@ -787,6 +790,7 @@ enum {
     #define PHY_LANE_CTRL_CMD_WRITE     0x00000000
     #define PHY_LANE_CTRL_CMD_START     0x00020000
     #define PHY_LANE_CTRL_CMD_PENDING   0x00040000
+    #define PHY_LANE_CTRL_RESET_PMA	0x00100000	
     #define PHY_LANE_CTRL_ALL           0x00200000
     #define PHY_LANE_CTRL_FAST_INIT     0x00400000
     #define PHY_LANE_CTRL_REXSEL_POS    23
@@ -810,11 +814,13 @@ enum {
 #define NET_INTF_SOFT_RST               0x3
 
 #define INT_MDIO_CTRL                   0x19
+    #define INT_MDIO_CTRL_ST		0
     #define INT_MDIO_CTRL_ST_POS        0
     #define INT_MDIO_CTRL_OP_POS        2
     #define INT_MDIO_CTRL_PHYADDR_POS   4
     #define INT_MDIO_CTRL_DEVTYPE_POS   9
     #define INT_MDIO_CTRL_TA_POS        14
+    #define INT_MDIO_CTRL_TA    	0x02
     #define INT_MDIO_CTRL_MIIM_POS      16
     #define INT_MDIO_CTRL_LOAD_POS      19
     #define INT_MDIO_CTRL_XDIV_POS      21
@@ -822,6 +828,10 @@ enum {
     #define INT_MDIO_CTRL_RST           0x40000000
     #define INT_MDIO_CTRL_SMP           0x00100000
     #define INT_MDIO_CTRL_CMD_LOAD      0x00080000
+
+    #define INT_MDIO_CTRL_XDIV		7
+    #define INT_MDIO_CTRL_MCDIV		1
+		
 #define INT_MDIO_CTRL_DATA              0x1A
 #define INT_MDIO_RD_STAT                0x1B
     #define INT_MDIO_RD_STAT_MASK       0x0000FFFF
@@ -874,6 +884,7 @@ enum {
     #define EXT_G_MDIO_CMD_SC           0x00080000
     #define EXT_G_MDIO_MMRST            0x00100000
     #define EXT_G_MDIO_DIV              0x0000001E	
+    #define EXT_G_MDIO_DIV_WITH_HW_DIV64 0x00000010
 
 #define EXT_G0_MDIO_CTRL_DATA           0x1E
 #define EXT_G1_MDIO_CTRL_DATA           0x22
@@ -1002,6 +1013,9 @@ enum {
 
 
 #define NETIOR_XGMAC_CTRL1              0x7F
+    #define NETIOR_XGMAC_RXAUI_DC_POS        30 /* Rxaui Disparity calculation */
+    #define NETIOR_XGMAC_RXAUI_EN_POS        29 /* Enable RXAUI Mode */
+
     #define NETIOR_XGMAC_VLAN_DC_POS    28
     #define NETIOR_XGMAC_PHYADDR_POS    23
     #define NETIOR_XGMAC_DEVID_POS      18
@@ -1012,6 +1026,8 @@ enum {
     #define NETIOR_XGMAC_SOFT_RST_POS   11
     #define NETIOR_XGMAC_TX_PAUSE_POS   10
 
+    #define NETIOR_XGMAC_RXAUI_SCRAMBLER_POS 4
+
 #define NETIOR_XGMAC_CTRL2		0x7E
 #define NETIOR_XGMAC_CTRL3		0x7D
 
diff --git a/arch/mips/include/asm/netlogic/hal/nlm_nae.h b/arch/mips/include/asm/netlogic/hal/nlm_nae.h
index 4b6c4ee..28a85c1 100644
--- a/arch/mips/include/asm/netlogic/hal/nlm_nae.h
+++ b/arch/mips/include/asm/netlogic/hal/nlm_nae.h
@@ -29,6 +29,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #ifndef __ASSEMBLY__
 #define MAX_NAE_CONTEXTS_PERNODE	524
 #define MAX_NAE_PORTS_PERNODE		18
+#define MAX_NAE_FREEIN_DESCS_QUEUE	18
 #define XLP_MAX_INTERLAKEN_IF		2
 
 #define NLM_MAX_NODES           4
@@ -42,6 +43,38 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define NAE_INIT_VALID		0x40
 
 #define INVALID_PHY_STATUS	0xffff
+#ifndef NLM_NCPUS_PER_NODE
+#define NLM_NCPUS_PER_NODE	32
+#endif
+
+#define NLM_NAE_SH_LCPU_TO_MAP_SZ		6 /* in integers */
+#define NLM_NAE_SH_LCPU_TO_MAP_SNG_VAL_SZ  	5 /* in bits, can cover 6 cpus in single entry */
+#define NLM_NAE_SH_LCPU_TO_MAP_NVALS_PER_ENTRY 	6 /* with 5 bits, can occupy 6  */
+
+struct nlm_nae_shinfo {
+	int valid;
+	int rxvc;
+	int domid;
+	/* logical cpu to physical cpu map */
+	unsigned int lcpu_2_pcpu_map[NLM_NAE_SH_LCPU_TO_MAP_SZ]; 
+	/* cpu to freein fifo map */
+	unsigned int cpu_2_freeinfifo_map[NLM_NAE_SH_LCPU_TO_MAP_SZ];
+};
+#ifndef NLM_NUM_THREADS_PER_CORE
+#define NLM_NUM_THREADS_PER_CORE	4
+#endif
+
+/* Only 3 domains can share one nae node including the owner */
+#define NLM_NAE_MAX_SHARED_DOMS		2
+
+#define NLM_NAE_MAX_FREEIN_FIFOS_PER_NODE 20
+/* XAUI Card only support XAUI mode */
+#define NLM_NAE_XAUI_MODE_XAUI      0
+
+/* RXAUI Card support 3 different modes */
+#define NLM_NAE_RXAUI_MODE_XAUI     1
+#define NLM_NAE_RXAUI_MODE_BROADCOM 2
+#define NLM_NAE_RXAUI_MODE_MARVELL  3
 
 struct nlm_hal_nae_port {
         int  valid;
@@ -62,6 +95,8 @@ struct nlm_hal_nae_port {
 	uint32_t  ucore_mask;
         int  ext_phy_addr;
         int  ext_phy_bus;
+	uint32_t  rxaui_scrambler; /* 0: disable scrambler ; 1: enable scrambler */
+	uint32_t  rxaui_mode;      /* 0: broadcom mode; 1: marvell */
 };
 
 struct nlm_hal_nae_config {
@@ -73,13 +108,9 @@ struct nlm_hal_nae_config {
 	uint32_t flags;
 	int rx_cal_slots;
 	int tx_cal_slots;
-	/* if shared is true, ucore is going to use upto 16 queues
-	 for buffer mgmt. */
-	int freein_fifo_shared;
-	/* onchip descs per queue, valid only if shared = 1 
-	 same value for all queues upto 0-15.  16 and 17 are used by mgmt port 
-	 if shared is false look at the port level num_free_desc for onchip size */
-	int freein_fifo_onchip_num_descs;
+	/* onchip descs per queue: value is taken from array for all 
+	   queues upto 0-17 */
+	int freein_fifo_onchip_num_descs[MAX_NAE_FREEIN_DESCS_QUEUE];
 	/* spill descs per queue, it will be added with the onchip size  */
 	int freein_fifo_spill_num_descs; 
 	uint64_t freein_spill_base;
@@ -98,9 +129,26 @@ struct nlm_hal_nae_config {
 	// NAE complex map
 	uint32_t sgmii_complex_map;
 	uint32_t xaui_complex_map;
+	uint32_t rxaui_complex_map;
 	uint32_t ilk_complex_map;
 	// total queues used = num_contexts
 	uint32_t num_contexts;
+
+	/* I am the owner or not, who initialize the node */
+	int owned;
+	/* Freein fifo mask. Out of the max rx fifos, domain ownership
+	of rx-fifos. */
+	uint32_t freein_fifo_dom_mask;
+
+	/* vfbtable id offset, software freeback and hardware freebaack */
+	uint32_t vfbtbl_sw_offset;
+	uint32_t vfbtbl_sw_nentries;
+	uint32_t vfbtbl_hw_offset;
+	uint32_t vfbtbl_hw_nentries;
+
+	unsigned long long dummy_pktdata_addr;
+	
+	struct nlm_nae_shinfo shinfo[NLM_NAE_MAX_SHARED_DOMS  + 1]; /* 1 extra for the owner */
 };
 
 typedef struct nlm_hal_nae_config * nlm_nae_config_ptr;
@@ -116,13 +164,26 @@ struct nlm_node_config
 extern struct nlm_node_config nlm_node_cfg;
 
 enum if_type {
-        UNKNOWN_IF,
-        SGMII_IF,
-        XAUI_IF,
-        INTERLAKEN_IF
+        UNKNOWN_IF    = 0,
+        SGMII_IF      = 1,
+        XAUI_IF       = 2,
+        INTERLAKEN_IF = 3,
+        RXAUI_IF      = 6,
 };
 
+extern int nlm_hal_write_ucore_shared_mem(int node, unsigned int *data, int words);
 extern int nlm_config_vfbid_table(int node, uint32_t start, uint32_t num_entries, uint32_t *vfbid_tbl);
 extern uint32_t *cntx2port[];
+extern int nlm_hal_restart_ucore(int node, void *fdt);
+extern void nlm_hal_derive_cpu_to_freein_fifo_map(int node,
+                unsigned int phys_cpu_map,
+                unsigned int freein_fifo_mask, unsigned int *cpu_2_freein_fifo_map);
+extern void nlm_hal_modify_nae_ucore_sram_mem(int node, int ucoreid, unsigned int *data, 
+		int off, int words);
+extern void nlm_hal_read_nae_ucore_sram_mem(int node, int ucoreid, unsigned int *data, 
+		int off, int words);
+
+extern void nlm_hal_disable_xaui_flow_control(int node, int interface);
+
 #endif
 #endif
diff --git a/arch/mips/netlogic/common/nlm_hal_nae.c b/arch/mips/netlogic/common/nlm_hal_nae.c
index 4194426..0911474 100644
--- a/arch/mips/netlogic/common/nlm_hal_nae.c
+++ b/arch/mips/netlogic/common/nlm_hal_nae.c
@@ -23,6 +23,9 @@ ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 THE POSSIBILITY OF SUCH DAMAGE.
 *****************************#NETL_2#********************************/
 
+#ifdef NLM_HAL_LINUX_KERNEL
+#include <linux/netdevice.h>
+#endif
 #include <asm/mach-netlogic/nlm_kexec.h>
 #include "nlm_hal_fmn.h"
 #include "nlm_hal_nae.h"
@@ -44,11 +47,12 @@ extern void nlm_hal_ext_phy_an(int node, int inf);
 extern void register_phy(int node, int inf, int* hw_portid);
 extern void nlm_hal_init_ext_phy(int node, int inf);
 
-static int nae_reset_done = 0;
+static int nae_reset_done[NLM_MAX_NODES] = { 0 };
 static void xlp_nae_config_interlaken(int node, int blk,int port, int num_lanes);
-static void xlp_nae_config_xaui(int node, int block, int port, int vlan_pri_en);
-static unsigned int ucore_shared_scratch[128];
-static unsigned int ucore_shared_scratch_words;
+static void xlp_nae_config_xaui(int node, int block, int port, int vlan_pri_en,
+                              int rxaui_scrambler, int mode);
+static unsigned int ucore_shared_scratch[NLM_MAX_NODES][128];
+static unsigned int ucore_shared_scratch_words[NLM_MAX_NODES];
 static void xlp_nae_config_lane_gmac(int node, int cplx_mask);
 
 uint32_t *cntx2port[NLM_MAX_NODES];
@@ -59,6 +63,79 @@ uint32_t *cntx2port[NLM_MAX_NODES];
 #define NAE_DEBUG(...)
 #endif
 
+static uint32_t nae_vfbid_tbl[NLM_MAX_NODES][MAX_VFBID_ENTRIES];
+
+#ifdef NAE_SH_INFO_DBG
+#define nlm_dbg_print nlm_print
+#else
+#define nlm_dbg_print(x, args...) { }
+#endif
+
+void nae_ext_mdio_wait(int n)
+{
+	volatile int s=0, i,j;
+	unsigned long long freq = nlm_hal_cpu_freq();
+	freq >>= 17;
+	if ( is_nlm_xlp8xx_b0() )
+	   return;
+	for(j=0; j<n; j++)
+	for(i=0; i<freq; i++) s++;
+	return;
+}
+
+/*
+ * MDIO CLK = NAE Freq/(26*8*2)/64
+ * MDIO CLK = 250MHz/(26*4*2)/64  when addDiv=7 & div=2 ==> 18.75KHz
+ *------------------------------
+ * EXT_G0_MDIO_CTRL[4:2]
+ *------------------------------
+ *  0 1
+ *  1 1
+ *  2 2
+ *  3 3
+ *  4 4
+ *  5 6
+ *  6 9
+ *  7 26
+ *------------------------------
+ * EXT_G0_MDIO_CTRL[1:0]
+ * 0 1
+ * 1 2
+ * 2 4
+ * 3 8
+ *------------------------------
+ */
+static uint32_t nae_get_EXT_G_MDIO_DIV(void)
+{
+	/*
+	 * MDIO CLK = 250MHz/(4*1*2)/64  when addDiv=4 & div=0 ==> 0.5MHz
+	 * MDIO CLK = 500MHz/(4*1*2)/64  when addDiv=4 & div=0 ==> 1.0MHz
+	 * XLP8XX_B1_EXT_G_MDIO_DIV:= b100,00 = 0x10
+	 */
+	return (
+	       is_nlm_xlp8xx_b0() ) ?  EXT_G_MDIO_DIV : EXT_G_MDIO_DIV_WITH_HW_DIV64;
+}
+
+/* INT_MDIO_CTRL, block7, 0x799
+ * EXT_XG_MDIO_CTRL, block7, 0x7A5,0x7A9
+ * 29:28: MCDiv Master Clock Divider
+ *     0: 50
+ *     1: 5
+ *     2: 1
+ * 27:21: XDiv Clock Divisor
+ *   M(mdc) = F(mstclk)/(2*(XDiv+1))
+ *    500MHz/50 = 10MHz
+ *    10MHz/(2*(9+1)) = 0.5MHz
+ */
+static uint32_t nae_get_INT_MDIO_DIV(void)
+{
+	return ((0x9 << INT_MDIO_CTRL_XDIV_POS) | (0 << INT_MDIO_CTRL_MCDIV_POS));
+}
+
+static uint32_t nae_get_EXT_XG_MDIO_DIV(void)
+{
+	return ((0x9 << EXT_XG_MDIO_CTRL_XDIV_POS) | (0 << EXT_XG_MDIO_CTRL_MCDIV_POS));
+}
 
 /*
  *      MDIO Support
@@ -70,8 +147,6 @@ uint32_t *cntx2port[NLM_MAX_NODES];
 * 
 * @param [in] node Node number
 * @param [in] bus Internal MDIO bus number
-* @param [in] block NAE Register Memory Map Block
-* @param [in] intf_type GMAC_0, GMAC_1, GMAC_2, GMAC_3, XGMAC, INTERLAKEN, PHY, LANE_CFG (only valid for block 7)
 * @param [in] phyaddr Internal PHY's address
 * @param [in] regidx MDIO register index
 *
@@ -81,8 +156,10 @@ uint32_t *cntx2port[NLM_MAX_NODES];
 * @ingroup hal_nae
 *
 */
-static int nae_int_gmac_mdio_read(int node, int bus,int block, int intf_type, int phyaddr, int regidx)
+static int nae_int_gmac_mdio_read(int node, int bus, int phyaddr, int regidx)
 {
+	uint32_t block     = BLOCK_7;
+	uint32_t intf_type = LANE_CFG;
 	uint32_t mdio_ld_cmd = nlm_hal_read_mac_reg(node, block, intf_type, INT_MDIO_CTRL + bus * 4);
 
 	if (mdio_ld_cmd & INT_MDIO_CTRL_CMD_LOAD) {
@@ -96,11 +173,11 @@ static int nae_int_gmac_mdio_read(int node, int bus,int block, int intf_type, in
 			       | (regidx << INT_MDIO_CTRL_DEVTYPE_POS)
 			       | (2 << INT_MDIO_CTRL_OP_POS)
 			       | (1 << INT_MDIO_CTRL_ST_POS)
-			       | (7 << INT_MDIO_CTRL_XDIV_POS)
+			       | (INT_MDIO_CTRL_XDIV << INT_MDIO_CTRL_XDIV_POS)
 			       | (2 << INT_MDIO_CTRL_TA_POS)
 			       | (2 << INT_MDIO_CTRL_MIIM_POS)
 			       | (0 << INT_MDIO_CTRL_LOAD_POS)
-			       | (1 << INT_MDIO_CTRL_MCDIV_POS));
+			       | (INT_MDIO_CTRL_MCDIV << INT_MDIO_CTRL_MCDIV_POS));
 
 	/* Toggle Load Cmd Bit */
 	nlm_hal_write_mac_reg(node, block, intf_type, INT_MDIO_CTRL + bus * 4,
@@ -109,17 +186,16 @@ static int nae_int_gmac_mdio_read(int node, int bus,int block, int intf_type, in
 			       | (regidx << INT_MDIO_CTRL_DEVTYPE_POS)
 			       | (2 << INT_MDIO_CTRL_OP_POS)
 			       | (1 << INT_MDIO_CTRL_ST_POS)
-			       | (7 << INT_MDIO_CTRL_XDIV_POS)
+			       | (INT_MDIO_CTRL_XDIV << INT_MDIO_CTRL_XDIV_POS)
 			       | (2 << INT_MDIO_CTRL_TA_POS)
 			       | (2 << INT_MDIO_CTRL_MIIM_POS)
 			       | (1 << INT_MDIO_CTRL_LOAD_POS) /* */
-			       | (1 << INT_MDIO_CTRL_MCDIV_POS));
+			       | (INT_MDIO_CTRL_MCDIV << INT_MDIO_CTRL_MCDIV_POS));
 
 	/* poll master busy bit until it is not busy
 	 */
 	while(nlm_hal_read_mac_reg(node, block, intf_type,
-				    INT_MDIO_RD_STAT + bus * 4) & INT_MDIO_STAT_MBSY) {
-	}
+				    INT_MDIO_RD_STAT + bus * 4) & INT_MDIO_STAT_MBSY);
 
 	nlm_hal_write_mac_reg(node, block, intf_type, INT_MDIO_CTRL + bus * 4,
 			       INT_MDIO_CTRL_SMP
@@ -127,11 +203,11 @@ static int nae_int_gmac_mdio_read(int node, int bus,int block, int intf_type, in
 			       | (regidx << INT_MDIO_CTRL_DEVTYPE_POS)
 			       | (2 << INT_MDIO_CTRL_OP_POS)
 			       | (1 << INT_MDIO_CTRL_ST_POS)
-			       | (7 << INT_MDIO_CTRL_XDIV_POS)
+			       | (INT_MDIO_CTRL_XDIV << INT_MDIO_CTRL_XDIV_POS)
 			       | (2 << INT_MDIO_CTRL_TA_POS)
 			       | (2 << INT_MDIO_CTRL_MIIM_POS)
 			       | (0 << INT_MDIO_CTRL_LOAD_POS)
-			       | (1 << INT_MDIO_CTRL_MCDIV_POS));
+			       | (INT_MDIO_CTRL_MCDIV << INT_MDIO_CTRL_MCDIV_POS));
 
 	/* Read the data back
 	 */
@@ -145,8 +221,6 @@ static int nae_int_gmac_mdio_read(int node, int bus,int block, int intf_type, in
 *
 * @param [in] node Node number
 * @param [in] bus Internal MDIO bus number
-* @param [in] block NAE Register Memory Map Block
-* @param [in] intf_type GMAC_0, GMAC_1, GMAC_2, GMAC_3, XGMAC, INTERLAKEN, PHY, LANE_CFG (only valid for block 7)
 * @param [in] phyaddr Internal PHY's address
 * @param [in] regidx MDIO register index
 * @param [in] val Value to write
@@ -157,8 +231,10 @@ static int nae_int_gmac_mdio_read(int node, int bus,int block, int intf_type, in
 * @ingroup hal_nae
 *
 */
-static int nae_int_gmac_mdio_write(int node, int bus, int block, int intf_type, int phyaddr, int regidx, uint16_t val)
+static int nae_int_gmac_mdio_write(int node, int bus, int phyaddr, int regidx, uint16_t val)
 {
+	uint32_t block     = BLOCK_7;
+	uint32_t intf_type = LANE_CFG;
 	uint32_t mdio_ld_cmd = nlm_hal_read_mac_reg(node, block, intf_type, INT_MDIO_CTRL + bus * 4);
 
 	if (mdio_ld_cmd & INT_MDIO_CTRL_CMD_LOAD) {
@@ -176,11 +252,11 @@ static int nae_int_gmac_mdio_write(int node, int bus, int block, int intf_type,
 			       | (regidx << INT_MDIO_CTRL_DEVTYPE_POS)
 			       | (1 << INT_MDIO_CTRL_OP_POS)
 			       | (1 << INT_MDIO_CTRL_ST_POS)
-			       | (7 << INT_MDIO_CTRL_XDIV_POS)
+			       | (INT_MDIO_CTRL_XDIV << INT_MDIO_CTRL_XDIV_POS)
 			       | (2 << INT_MDIO_CTRL_TA_POS)
 			       | (1 << INT_MDIO_CTRL_MIIM_POS)
 			       | (0 << INT_MDIO_CTRL_LOAD_POS)
-			       | (1 << INT_MDIO_CTRL_MCDIV_POS));
+			       | (INT_MDIO_CTRL_MCDIV << INT_MDIO_CTRL_MCDIV_POS));
 
 	nlm_hal_write_mac_reg(node, block, intf_type, INT_MDIO_CTRL + bus * 4,
 			       INT_MDIO_CTRL_SMP
@@ -188,17 +264,16 @@ static int nae_int_gmac_mdio_write(int node, int bus, int block, int intf_type,
 			       | (regidx << INT_MDIO_CTRL_DEVTYPE_POS)
 			       | (1 << INT_MDIO_CTRL_OP_POS)
 			       | (1 << INT_MDIO_CTRL_ST_POS)
-			       | (7 << INT_MDIO_CTRL_XDIV_POS)
+			       | (INT_MDIO_CTRL_XDIV << INT_MDIO_CTRL_XDIV_POS)
 			       | (2 << INT_MDIO_CTRL_TA_POS)
 			       | (1 << INT_MDIO_CTRL_MIIM_POS)
 			       | (1 << INT_MDIO_CTRL_LOAD_POS)
-			       | (1 << INT_MDIO_CTRL_MCDIV_POS));
+			       | (INT_MDIO_CTRL_MCDIV << INT_MDIO_CTRL_MCDIV_POS));
 
 	/* poll master busy bit until it is not busy
 	 */
 	while(nlm_hal_read_mac_reg(node, block, intf_type,
-				    INT_MDIO_RD_STAT + bus * 4) & INT_MDIO_STAT_MBSY) {
-	}
+				    INT_MDIO_RD_STAT + bus * 4) & INT_MDIO_STAT_MBSY);
 
 	nlm_hal_write_mac_reg(node, block, intf_type, INT_MDIO_CTRL + bus * 4,
 			       INT_MDIO_CTRL_SMP
@@ -206,22 +281,20 @@ static int nae_int_gmac_mdio_write(int node, int bus, int block, int intf_type,
 			       | (regidx << INT_MDIO_CTRL_DEVTYPE_POS)
 			       | (1 << INT_MDIO_CTRL_OP_POS)
 			       | (1 << INT_MDIO_CTRL_ST_POS)
-			       | (7 << INT_MDIO_CTRL_XDIV_POS)
+			       | (INT_MDIO_CTRL_XDIV << INT_MDIO_CTRL_XDIV_POS)
 			       | (2 << INT_MDIO_CTRL_TA_POS)
 			       | (1 << INT_MDIO_CTRL_MIIM_POS)
 			       | (0 << INT_MDIO_CTRL_LOAD_POS)
-			       | (1 << INT_MDIO_CTRL_MCDIV_POS));
+			       | (INT_MDIO_CTRL_MCDIV << INT_MDIO_CTRL_MCDIV_POS));
 
 	return 0;
 }
 
 /**
-* @brief int_nae_gmac_mdio_reset function is used to reset an internal MDIO controller.
+* @brief internal_nae_gmac_mdio_reset function is used to reset an internal MDIO controller.
 *
 * @param [in] node Node number
 * @param [in] bus Internal MDIO bus number
-* @param [in] block NAE Register Memory Map Block
-* @param [in] intf_type GMAC_0, GMAC_1, GMAC_2, GMAC_3, XGMAC, INTERLAKEN, PHY, LANE_CFG (only valid for block 7)
 *
 * @return
 * 	- 0 on success
@@ -229,16 +302,19 @@ static int nae_int_gmac_mdio_write(int node, int bus, int block, int intf_type,
 * @ingroup hal_nae
 *
 */
-static int int_nae_gmac_mdio_reset(int node, int bus, int block, int intf_type)
+static int internal_nae_gmac_mdio_reset(int node, int bus)
 {
+	uint32_t block     = BLOCK_7;
+	uint32_t intf_type = LANE_CFG;
 	nlm_hal_write_mac_reg(node, block, intf_type, INT_MDIO_CTRL + bus * 4,
-			       INT_MDIO_CTRL_RST |
-			       (7 << INT_MDIO_CTRL_XDIV_POS) 	|
-			       (1 << INT_MDIO_CTRL_MCDIV_POS));
+			       INT_MDIO_CTRL_RST | INT_MDIO_CTRL_SMP |
+			       (INT_MDIO_CTRL_XDIV << INT_MDIO_CTRL_XDIV_POS) 	|
+			       (INT_MDIO_CTRL_MCDIV << INT_MDIO_CTRL_MCDIV_POS));
 
 	nlm_hal_write_mac_reg(node, block, intf_type, INT_MDIO_CTRL + bus * 4,
-			       (7 << INT_MDIO_CTRL_XDIV_POS) 	|
-			       (1 << INT_MDIO_CTRL_MCDIV_POS));
+				INT_MDIO_CTRL_SMP | /* supress pre-amble */
+			       (INT_MDIO_CTRL_XDIV << INT_MDIO_CTRL_XDIV_POS) 	|
+			       (INT_MDIO_CTRL_MCDIV << INT_MDIO_CTRL_MCDIV_POS));
 	return 0;
 }
 
@@ -258,8 +334,6 @@ static int int_nae_gmac_mdio_reset(int node, int bus, int block, int intf_type)
 *
 * @param [in] node Node number
 * @param [in] bus External MDIO bus number
-* @param [in] block NAE Register Memory Map Block
-* @param [in] intf_type GMAC_0, GMAC_1, GMAC_2, GMAC_3, XGMAC, INTERLAKEN, PHY, LANE_CFG (only valid for block 7)
 * @param [in] phyaddr External PHY's address
 * @param [in] regidx PHY register index to read
 *
@@ -269,8 +343,10 @@ static int int_nae_gmac_mdio_reset(int node, int bus, int block, int intf_type)
 * @ingroup hal_nae
 *
 */
-static int nae_gmac_mdio_read(int node, int bus, int block, int intf_type, int phyaddr, int regidx)
+static int nae_gmac_mdio_read(int node, int bus, int phyaddr, int regidx)
 {
+	uint32_t block     = BLOCK_7;
+	uint32_t intf_type = LANE_CFG;
 	uint32_t mdio_ld_cmd = nlm_hal_read_mac_reg(node, block, intf_type, EXT_G0_MDIO_CTRL+ bus * 4);
 
 	if (mdio_ld_cmd & EXT_G_MDIO_CMD_LCD) {
@@ -280,40 +356,28 @@ static int nae_gmac_mdio_read(int node, int bus, int block, int intf_type, int p
 					    EXT_G0_MDIO_RD_STAT + bus * 4) & EXT_G_MDIO_STAT_MBSY);
 	}
 
-	//nlm_print("[%s/%d] SENDING READ COMMAND \n", __func__, __LINE__);
-
 	nlm_hal_write_mac_reg(node, block, intf_type, EXT_G0_MDIO_CTRL + bus * 4,
 			       EXT_G_MDIO_CMD_SP
 			       | (phyaddr << EXT_G_MDIO_PHYADDR_POS)
 			       | (regidx << EXT_G_MDIO_REGADDR_POS)
-			       | (0<<18)
-				   | EXT_G_MDIO_DIV);
+			       | (0<<18) | nae_get_EXT_G_MDIO_DIV());
 
 	nlm_hal_write_mac_reg(node, block, intf_type, EXT_G0_MDIO_CTRL + bus * 4,
 			       EXT_G_MDIO_CMD_SP
 			       | (phyaddr << EXT_G_MDIO_PHYADDR_POS)
 			       | (regidx << EXT_G_MDIO_REGADDR_POS)
-			       | (1<<18)
-				   | EXT_G_MDIO_DIV);
+			       | (1<<18) | nae_get_EXT_G_MDIO_DIV());
+
+	nae_ext_mdio_wait(1);
 
-	/* poll master busy bit until it is not busy */
 	while(nlm_hal_read_mac_reg(node, block, intf_type,
-				    EXT_G0_MDIO_RD_STAT + bus * 4) & EXT_G_MDIO_STAT_MBSY) {
-		//nlm_print("[%d] EXT_G_MDIO_STAT_MBSY is SET!\n", __LINE__);
-	}
+				    EXT_G0_MDIO_RD_STAT + bus * 4) & EXT_G_MDIO_STAT_MBSY);
 
 	nlm_hal_write_mac_reg(node, block, intf_type, EXT_G0_MDIO_CTRL + bus * 4,
 			       EXT_G_MDIO_CMD_SP
 			       | (phyaddr << EXT_G_MDIO_PHYADDR_POS)
 			       | (regidx << EXT_G_MDIO_REGADDR_POS)
-			       | (0<<18)
-				   | EXT_G_MDIO_DIV);
-
-	//nlm_print("[%d] EXT_G_MDIO_STAT_MBSY CLEARED!\n", __LINE__);
-
-	/* Issue the read command */
-	//nlm_hal_write_mac_reg( block, intf_type, EXT_G0_MDIO_CTRL + bus * 4,(1));
-	//nlm_print("[%s/%d] READ RETURNING...\n", __func__, __LINE__);
+			       | (0<<18) | nae_get_EXT_G_MDIO_DIV());
 
 	/* Read the data back */
 	return nlm_hal_read_mac_reg(node, block, intf_type, EXT_G0_MDIO_RD_STAT + bus * 4);
@@ -336,8 +400,6 @@ static int nae_gmac_mdio_read(int node, int bus, int block, int intf_type, int p
 *
 * @param [in] node Node number
 * @param [in] bus External MDIO bus number
-* @param [in] block NAE Register Memory Map Block
-* @param [in] intf_type GMAC_0, GMAC_1, GMAC_2, GMAC_3, XGMAC, INTERLAKEN, PHY, LANE_CFG (only valid for block 7)
 * @param [in] phyaddr External PHY's address
 * @param [in] regidx PHY register index to read
 * @param [in] val Value to write
@@ -348,8 +410,10 @@ static int nae_gmac_mdio_read(int node, int bus, int block, int intf_type, int p
 * @ingroup hal_nae
 *
 */
-static int nae_gmac_mdio_write(int node, int bus, int block, int intf_type, int phyaddr, int regidx, uint16_t val)
+static int nae_gmac_mdio_write(int node, int bus, int phyaddr, int regidx, uint16_t val)
 {
+	uint32_t block     = BLOCK_7;
+	uint32_t intf_type = LANE_CFG;
 	uint32_t mdio_ld_cmd = nlm_hal_read_mac_reg(node, block, intf_type, EXT_G0_MDIO_CTRL+ bus * 4);
 
 	if (mdio_ld_cmd & EXT_G_MDIO_CMD_LCD) {
@@ -363,23 +427,20 @@ static int nae_gmac_mdio_write(int node, int bus, int block, int intf_type, int
 	 */
 	nlm_hal_write_mac_reg(node, block, intf_type, EXT_G0_MDIO_CTRL_DATA + bus * 4, val);
 
-	//nlm_print("[%s/%d] SENDING WRITE COMMAND \n", __func__, __LINE__);
-
 	nlm_hal_write_mac_reg(node, block, intf_type, EXT_G0_MDIO_CTRL+ bus * 4,
 			       EXT_G_MDIO_CMD_SP 	|
 			       (phyaddr << EXT_G_MDIO_PHYADDR_POS) 	|
 			       (regidx << EXT_G_MDIO_REGADDR_POS)	|
-			       (0<<18)								|
-				   EXT_G_MDIO_DIV);
+			       (0<<18) | nae_get_EXT_G_MDIO_DIV());
 
 	nlm_hal_write_mac_reg(node, block, intf_type, EXT_G0_MDIO_CTRL+ bus * 4,
 			       EXT_G_MDIO_CMD_LCD | EXT_G_MDIO_CMD_SP 	|
 			       (phyaddr << EXT_G_MDIO_PHYADDR_POS) 	|
 			       (regidx << EXT_G_MDIO_REGADDR_POS)	|
-			       (0<<18)								|
-				   EXT_G_MDIO_DIV);
+			       (0<<18) | nae_get_EXT_G_MDIO_DIV());
+
+	nae_ext_mdio_wait(1);
 
-	/* poll master busy bit until it is not busy */
 	while(nlm_hal_read_mac_reg(node, block, intf_type,
 				    EXT_G0_MDIO_RD_STAT + bus * 4) & EXT_G_MDIO_STAT_MBSY);
 
@@ -387,15 +448,13 @@ static int nae_gmac_mdio_write(int node, int bus, int block, int intf_type, int
 			       EXT_G_MDIO_CMD_SP 	|
 			       (phyaddr << EXT_G_MDIO_PHYADDR_POS) 	|
 			       (regidx << EXT_G_MDIO_REGADDR_POS)	|
-			       (0<<18)								|
-				   EXT_G_MDIO_DIV);
+			       (0<<18) | nae_get_EXT_G_MDIO_DIV());
 
-	//nlm_print("[%s/%d] WRITE RETURNING...\n", __func__, __LINE__);
 	return 0;
 }
 
 /**********************************************************************
- *  nae_gmac_mdio_reset -Reset sgmii mdio module.
+ *  external_nae_gmac_mdio_reset -Reset sgmii mdio module.
  *
  *  Input parameters:
  *         bus - bus number, nae has two external gmac bus: 0 and 1
@@ -404,12 +463,10 @@ static int nae_gmac_mdio_write(int node, int bus, int block, int intf_type, int
  *        0 - success
  ********************************************************************* */
 /**
-* @brief nae_gmac_mdio_reset function is used to reset an external MDIO controller.
+* @brief external_nae_gmac_mdio_reset function is used to reset an external MDIO controller.
 *
 * @param [in] node Node number
 * @param [in] bus External MDIO bus number
-* @param [in] block NAE Register Memory Map Block
-* @param [in] intf_type GMAC_0, GMAC_1, GMAC_2, GMAC_3, XGMAC, INTERLAKEN, PHY, LANE_CFG (only valid for block 7)
 *
 * @return
 * 	- 0 on success
@@ -417,12 +474,50 @@ static int nae_gmac_mdio_write(int node, int bus, int block, int intf_type, int
 * @ingroup hal_nae
 *
 */
-static int nae_gmac_mdio_reset(int node, int bus, int block, int intf_type)
+static int external_nae_gmac_mdio_reset(int node, int bus)
 {
+	uint32_t block     = BLOCK_7;
+	uint32_t intf_type = LANE_CFG;
+	//printf("INTF:%d EXT Gx MDIO DIV:%d\n", intf_type, nae_get_EXT_G_MDIO_DIV());
 	nlm_hal_write_mac_reg(node, block, intf_type, EXT_G0_MDIO_CTRL + bus * 4,
-			       EXT_G_MDIO_MMRST | EXT_G_MDIO_DIV);
+			       EXT_G_MDIO_MMRST | nae_get_EXT_G_MDIO_DIV());
 	nlm_hal_write_mac_reg(node, block, intf_type, EXT_G0_MDIO_CTRL + bus * 4,
-			       EXT_G_MDIO_DIV);
+			       nae_get_EXT_G_MDIO_DIV());
+	return 0;
+}
+
+/**********************************************************************
+ *  external_nae_xgmac_mdio_reset -Reset sgmii mdio module.
+ *
+ *  Input parameters:
+ *         bus - bus number, nae has two external gmac bus: 0 and 1
+ *
+ *  Return value:
+ *        0 - success
+ ********************************************************************* */
+/**
+* @brief external_nae_xgmac_mdio_reset function is used to reset an external MDIO controller.
+*
+* @param [in] node Node number
+* @param [in] bus External MDIO bus number
+*
+* @return
+* 	- 0 on success
+*
+* @ingroup hal_nae
+*
+*/
+static int external_nae_xgmac_mdio_reset(int node, int bus)
+{
+	uint32_t block     = BLOCK_7;
+	uint32_t intf_type = LANE_CFG;
+        nlm_hal_write_mac_reg( node, block, intf_type, EXT_XG0_MDIO_CTRL + (bus * 4),
+				 nae_get_EXT_XG_MDIO_DIV()
+                                | EXT_XG_MDIO_CTRL_RST );
+
+        nlm_hal_write_mac_reg( node, block, intf_type, EXT_XG0_MDIO_CTRL + (bus * 4),
+				 nae_get_EXT_XG_MDIO_DIV()
+                                );
 	return 0;
 }
 
@@ -432,9 +527,9 @@ static int nae_gmac_mdio_reset(int node, int bus, int block, int intf_type)
 * @param [in] node Node number
 * @param [in] type NLM_HAL_INT_MDIO or NLM_HAL_EXT_MDIO
 * @param [in] bus MDIO bus number
-* @param [in] block NAE Register Memory Map Block
-* @param [in] intf_type GMAC_0, GMAC_1, GMAC_2, GMAC_3, XGMAC, INTERLAKEN, PHY, LANE_CFG (only valid for block 7)
-* @param [in] phyaddr PHY's address
+* @param [in] [To be deleted] block NAE Register Memory Map Block
+* @param [in] [To be deleted] LANE_CFG (only valid for block 7)
+* @param [in] phyaddr PHY's address: devType=Bit[12:8]; phyAddr:=Bit[4:0]
 * @param [in] regidx PHY register index to read
 *
 * @return
@@ -444,20 +539,34 @@ static int nae_gmac_mdio_reset(int node, int bus, int block, int intf_type)
 * @ingroup hal_nae
 *
 */
-int nlm_hal_mdio_read(int node, int type, int bus,int block, int intf_type,
-		      int phyaddr, int regidx)
+int nlm_hal_mdio_wr(int node, int type, int bus, int phyaddr, int regidx, uint16_t val);
+int nlm_hal_mdio_rd(int node, int type, int bus, int phyaddr, int regidx);
+
+int nlm_hal_mdio_rd(int node, int type, int bus, int phyaddr, int regidx)
 {
 	if (type == NLM_HAL_INT_MDIO) {
-		return nae_int_gmac_mdio_read(node, bus, block, intf_type,
-					      phyaddr, regidx);
+		/* INT_MDIO_CTRL: 0x799 */
+		return nae_int_gmac_mdio_read(node, bus, phyaddr&0x1F, regidx);
+	} else if (type == NLM_HAL_INT_MDIO_C45) {
+		/* INT_MDIO_CTRL: 0x799 */
+		return nlm_hal_xgmac_imdio_read(node, phyaddr&0x1F, regidx);
 	} else if (type == NLM_HAL_EXT_MDIO) {
-		return nae_gmac_mdio_read(node, bus, block, intf_type,
-					  phyaddr, regidx);
+	        /* 1GE MDIO EXT_G<0,1> : bus0:0x79D, bus1:0x7A1*/
+		return nae_gmac_mdio_read(node, bus, phyaddr&0x1F, regidx);
+	} else if (type == NLM_HAL_EXT_MDIO_C45) {
+	        /* 10GE MDIO EXT_XG<0,1> : bus0:0x7A5, bus1:0x7A9*/
+		return nlm_hal_xgmac_mdio_read(node, bus,
+						(phyaddr&0x1F), (phyaddr>>8)&0x1F, regidx);
 	} else {
 		nlm_print("NAE_ERROR: Invalid type for MDIO read !!\n");
 		return -1;
 	}
 }
+int nlm_hal_mdio_read(int node, int type, int bus, int block, int intf_type,
+		      int phyaddr, int regidx)
+{
+	return nlm_hal_mdio_rd(node, type, bus, phyaddr, regidx);
+}
 
 /**
 * @brief nlm_hal_mdio_write function is used to write a register through MDIO.
@@ -465,9 +574,9 @@ int nlm_hal_mdio_read(int node, int type, int bus,int block, int intf_type,
 * @param [in] node Node number
 * @param [in] type NLM_HAL_INT_MDIO or NLM_HAL_EXT_MDIO
 * @param [in] bus MDIO bus number
-* @param [in] block NAE Register Memory Map Block
-* @param [in] intf_type GMAC_0, GMAC_1, GMAC_2, GMAC_3, XGMAC, INTERLAKEN, PHY, LANE_CFG (only valid for block 7)
-* @param [in] phyaddr PHY's address
+* @param [in] [To be deleted] block NAE Register Memory Map Block
+* @param [in] [To be deleted] LANE_CFG (only valid for block 7)
+* @param [in] phyaddr PHY's address: devType=Bit[12:8]; phyAddr:=Bit[4:0]
 * @param [in] regidx PHY register index to read
 * @param [in] val Value to write
 *
@@ -478,20 +587,31 @@ int nlm_hal_mdio_read(int node, int type, int bus,int block, int intf_type,
 * @ingroup hal_nae
 *
 */
-int nlm_hal_mdio_write(int node, int type, int bus, int block, int intf_type,
-		       int phyaddr, int regidx, uint16_t val)
+int nlm_hal_mdio_wr(int node, int type, int bus, int phyaddr, int regidx, uint16_t val)
 {
 	if (type == NLM_HAL_INT_MDIO) {
-		return nae_int_gmac_mdio_write(node, bus, block, intf_type,
-					       phyaddr, regidx, val);
+		/* INT_MDIO_CTRL: 0x799 */
+		return nae_int_gmac_mdio_write(node, bus, phyaddr&0x1F, regidx, val);
+	} else if (type == NLM_HAL_INT_MDIO) {
+		/* INT_MDIO_CTRL: 0x799 */
+		return nlm_hal_xgmac_imdio_write(node, phyaddr&0x1F, regidx, val);
 	} else if (type == NLM_HAL_EXT_MDIO) {
-		return nae_gmac_mdio_write(node, bus, block, intf_type,
-					   phyaddr, regidx, val);
+	        /* 1GE MDIO EXT_G<0,1> : bus0:0x79D, bus1:0x7A1*/
+		return nae_gmac_mdio_write(node, bus, phyaddr&0x1F, regidx, val);
+	} else if (type == NLM_HAL_EXT_MDIO_C45) {
+	        /* 10GE MDIO EXT_XG<0,1> : bus0:0x7A5, bus1:0x7A9*/
+		return nlm_hal_xgmac_mdio_write(node, bus,
+						(phyaddr&0x1F), (phyaddr>>8)&0x1F, regidx, val);
 	} else {
 		nlm_print("NAE_ERROR: Invalid type for MDIO write !!\n");
 		return -1;
 	}
 }
+int nlm_hal_mdio_write(int node, int type, int bus, int block, int intf_type,
+		       int phyaddr, int regidx, uint16_t val)
+{
+	return nlm_hal_mdio_wr(node, type, bus, phyaddr, regidx, val);
+}
 
 /**
 * @brief nlm_hal_mdio_reset function is used to reset an MDIO controller.
@@ -499,8 +619,8 @@ int nlm_hal_mdio_write(int node, int type, int bus, int block, int intf_type,
 * @param [in] node Node number
 * @param [in] type NLM_HAL_INT_MDIO or NLM_HAL_EXT_MDIO
 * @param [in] bus MDIO bus number
-* @param [in] block NAE Register Memory Map Block
-* @param [in] intf_type GMAC_0, GMAC_1, GMAC_2, GMAC_3, XGMAC, INTERLAKEN, PHY, LANE_CFG (only valid for block 7)
+* @param [in] [To be deleted] block NAE Register Memory Map Block
+* @param [in] [To be deleted] LANE_CFG (only valid for block 7)
 *
 * @return
 *	- 0 on success
@@ -511,176 +631,19 @@ int nlm_hal_mdio_write(int node, int type, int bus, int block, int intf_type,
 */
 int nlm_hal_mdio_reset(int node, int type, int bus, int block, int intf_type)
 {
-	if (type == NLM_HAL_INT_MDIO) {
-		return int_nae_gmac_mdio_reset(node, bus, block, intf_type);
-
+	if ((type == NLM_HAL_INT_MDIO) || (type == NLM_HAL_INT_MDIO_C45)) {
+		return internal_nae_gmac_mdio_reset(node, bus);
 	} else if (type == NLM_HAL_EXT_MDIO) {
-		return nae_gmac_mdio_reset(node, bus, block, intf_type);
-
+		return external_nae_gmac_mdio_reset(node, bus);
+	} else if (type == NLM_HAL_EXT_MDIO_C45) {
+		return external_nae_xgmac_mdio_reset(node, bus);
 	} else {
 		nlm_print("NAE_ERROR: Invalid type for MDIO reset !!\n");
 		return -1;
 	}
 }
 
-#if 0
-/**********************************************************************
- *  nae_xgmac_mdio_read - Read xgmac phy register
- *
- *  Input parameters:
- *         bus          - bus number, nae has two external xgmac bus: 0 and 1
- *         phyaddr      - PHY's address
- *         regidx       - index of register to read
- *
- *  Return value:
- *         value read (16 bits), or 0xffffffff if an error occurred.
- ********************************************************************* */
-static int nae_xgmac_mdio_read(int bus,int block, int intf_type, int phyaddr, int regidx)
-{
-
-        nlm_hal_write_mac_reg( block, intf_type, EXT_XG0_MDIO_CTRL + bus * 4,
-			       phyaddr<<EXT_XG_MDIO_CTRL_PHYADDR_POS
-			       | 1<<EXT_XG_MDIO_CTRL_MCDIV_POS
-			       | EXT_XG_MDIO_CTRL_CMD_LOAD
-			       | 1<<EXT_XG_MDIO_CTRL_MIIM_POS
-			       | 0x2<<EXT_XG_MDIO_CTRL_TA_POS
-			       | MDIO_OP_CMD_READ<<2);
-
-        /* poll master busy bit until it is not busy */
-        while(nlm_hal_read_mac_reg( block, intf_type,
-				    EXT_XG0_MDIO_RD_STAT + bus * 4) & EXT_XG_MDIO_STAT_MBSY);
-
-        return nlm_hal_read_mac_reg( block, intf_type,
-				     EXT_XG0_MDIO_CTRL_DATA + bus * 4) & 0xFFFF;
-}
-/**********************************************************************
- *  nae_xgmac_mdio_write -Write xgmac mii PHY register.
- *
- *  Input parameters:
- *         bus          - bus number, nae has two external xgmac bus: 0 and 1
- *         phyaddr      - PHY to use
- *         regidx       - register within the PHY
- *         val          - data to write to register
- *
- *  Return value:
- *         0 - success
- ********************************************************************* */
-static int nae_xgmac_mdio_write(int bus, int block, int intf_type, int phyaddr, int regidx, int16_t val)
-{
-        /* load data to INT_MDIO_CTRL_DATA register*/
-        nlm_hal_write_mac_reg( block, intf_type,
-			       EXT_XG0_MDIO_CTRL_DATA+ bus * 4, val);
-
-        nlm_hal_write_mac_reg( block, intf_type, EXT_XG0_MDIO_CTRL+ bus * 4,
-			       phyaddr<<EXT_XG_MDIO_CTRL_PHYADDR_POS
-			       | 1<<EXT_XG_MDIO_CTRL_MCDIV_POS
-			       | EXT_XG_MDIO_CTRL_CMD_LOAD
-			       | 1<<EXT_XG_MDIO_CTRL_MIIM_POS
-			       | 0x2<<EXT_XG_MDIO_CTRL_TA_POS
-			       | MDIO_OP_CMD_WRITE<<2);
-
-        /* poll master busy bit until it is not busy */
-        while(nlm_hal_read_mac_reg( block, intf_type,
-				    EXT_XG0_MDIO_RD_STAT + bus * 4 )& EXT_XG_MDIO_STAT_MBSY);
-
-        return 0;
-}
-
-/**********************************************************************
- *  nae_xgmac_mdio_reset -Reset sgmii PHY.
- *
- *  Input parameters:
- *         bus - bus number, nae has two external xgmac bus: 0 and 1
- *
- *  Return value:
- *        0 - success
- ********************************************************************* */
-static int nae_xgmac_mdio_reset(int bus, int block, int intf_type)
-{
-        nlm_hal_write_mac_reg( block, intf_type,
-			       EXT_XG0_MDIO_CTRL + bus * 4,
-			       EXT_XG_MDIO_CTRL_RST);
-        return 0;
-}
-
-/**********************************************************************
- *  nae_gmac_internal_mdio_read - Read internal mdio phy bus
- *
- *  Input parameters:
- *         phyaddr      - PHY's address
- *         regidx       - index of register to read
- *
- *  Return value:
- *         value read (16 bits), or 0xffffffff if an error occurred.
- ********************************************************************* */
-static int nae_gmac_internal_mdio_read(int block, int intf_type, int phyaddr, int regidx)
-{
-
-        nlm_hal_write_mac_reg( block, intf_type, INT_MDIO_CTRL,
-			       phyaddr<<INT_MDIO_CTRL_PHYADDR_POS
-			       | 1<<INT_MDIO_CTRL_MCDIV_POS
-			       |INT_MDIO_CTRL_CMD_LOAD
-			       | 1<<INT_MDIO_CTRL_MIIM_POS
-			       | 0x2<<INT_MDIO_CTRL_TA_POS
-			       | MDIO_OP_CMD_READ<<2);
-
-        /* poll master busy bit until it is not busy */
-        while(nlm_hal_read_mac_reg( block, intf_type,
-				    INT_MDIO_RD_STAT) & INT_MDIO_STAT_MBSY);
-
-        return nlm_hal_read_mac_reg( block, intf_type,INT_MDIO_CTRL_DATA) & 0xFFFF;
-}
-
-/**********************************************************************
- *  nae_gmac_internal_mdio_write -Write internal gmac mii PHY register.
- *
- *  Input parameters:
- *         phyaddr      - PHY to use
- *         regidx       - register within the PHY
- *         val          - data to write to register
- *
- *  Return value:
- *         0 - success
- ********************************************************************* */
-static int nae_gmac_internal_mdio_write(int block, int intf_type, int phyaddr, int regidx, int16_t val)
-{
-
-        /* load data to INT_MDIO_CTRL_DATA register*/
-        nlm_hal_write_mac_reg( block, intf_type, INT_MDIO_CTRL_DATA, val);
-        nlm_hal_write_mac_reg( block, intf_type, INT_MDIO_CTRL,
-			       phyaddr<<INT_MDIO_CTRL_PHYADDR_POS
-			       | 1<<INT_MDIO_CTRL_MCDIV_POS
-			       |INT_MDIO_CTRL_CMD_LOAD
-			       | 1<<INT_MDIO_CTRL_MIIM_POS
-			       | 0x2<<INT_MDIO_CTRL_TA_POS
-			       | MDIO_OP_CMD_WRITE<<2);
-
-        /* poll master busy bit until it is not busy */
-        while(nlm_hal_read_mac_reg( block, intf_type,
-				    INT_MDIO_RD_STAT) & INT_MDIO_STAT_MBSY);
-
-        return 0;
-}
-
-/**********************************************************************
- *  nae_gmac_internal_mdio_reset -Reset internal gmac PHY register.
- *
- *  Input parameters:
- *
- *  Return value:
- *        0 - success
- ********************************************************************* */
-static int nae_gmac_internal_mdio_reset(int block, int intf_type)
-{
-        nlm_hal_write_mac_reg( block, intf_type, INT_MDIO_CTRL, INT_MDIO_CTRL_RST);
-        return 0;
-}
-#endif
-
-
 // PLL 
-
-
 /**********************************************************************
  *  nae_lane_reset_txpll
  * * serdes lane progaming 
@@ -706,6 +669,12 @@ void xlp3xx_8xxb0_nae_lane_reset_txpll(int node, int block, int lane_ctrl, int m
 	int rext_sel = 0;
 	NAE_DEBUG("%s: block %d lane_ctrl %x \n",__func__,block,lane_ctrl);
 
+	/* rxaui mode only lanes 0 and 2 are used in each complex, 1/3 not used
+	 * skip lane 1 & 3 by setting lane_inc = 2
+	 */
+	if(mode == PHYMODE_RXAUI && (lane_ctrl%2) )
+		return;
+
 	if(lane_ctrl != 4)
 		rext_sel = (1 << 23);
 		
@@ -794,6 +763,13 @@ void xlp8xx_ax_nae_lane_reset_txpll(int node, int block, int lane_ctrl, int mode
 
 	nlm_hal_write_mac_reg(node, block, PHY, lane_ctrl,         (0x66 << PHY_LANE_CTRL_ADDR_POS)
 			       | PHY_LANE_CTRL_CMD_READ
+			       | PHY_LANE_CTRL_RST
+			       | rext_sel
+			       | val );
+	while ((nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl)) & PHY_LANE_CTRL_CMD_PENDING);
+
+	nlm_hal_write_mac_reg(node, block, PHY, lane_ctrl,         (0x66 << PHY_LANE_CTRL_ADDR_POS)
+			       | PHY_LANE_CTRL_CMD_READ
 			       | PHY_LANE_CTRL_CMD_START
 			       | PHY_LANE_CTRL_RST
 			       | rext_sel
@@ -804,22 +780,30 @@ void xlp8xx_ax_nae_lane_reset_txpll(int node, int block, int lane_ctrl, int mode
 	/* set bit[4] to 0
 	 */
 	val &= ~(1 << 4);
-	nlm_hal_write_mac_reg(node, block, PHY, lane_ctrl,   (0x66 << PHY_LANE_CTRL_ADDR_POS)
-			       | PHY_LANE_CTRL_CMD_WRITE
-			       | PHY_LANE_CTRL_CMD_START
-			       | (0x0 << 19) /* (0x4 << 19) */
-			       | rext_sel
-			       | saved_data
-			       | val );
-	/* re-do */
-	nlm_hal_write_mac_reg(node, block, PHY, lane_ctrl,   (0x66 << PHY_LANE_CTRL_ADDR_POS)
-			       | PHY_LANE_CTRL_CMD_WRITE
-			       | PHY_LANE_CTRL_CMD_START
-			       | (0x0 << 19) /* (0x4 << 19) */
-			       | rext_sel
-			       | saved_data
-			       | val );
-
+	nlm_hal_write_mac_reg(node, block, PHY, lane_ctrl,
+			((0x66 << PHY_LANE_CTRL_ADDR_POS)
+			 | (0x0 << 19) /* (0x4 << 19) */
+			 | rext_sel
+			 | saved_data
+			 | val )
+			& ~(PHY_LANE_CTRL_CMD_READ));
+
+	while ((nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl)) & PHY_LANE_CTRL_CMD_PENDING);
+	
+	nlm_hal_write_mac_reg(node, block, PHY, lane_ctrl,   
+			((0x66 << PHY_LANE_CTRL_ADDR_POS)
+			 | PHY_LANE_CTRL_CMD_START
+			 | (0x0 << 19) /* (0x4 << 19) */
+			 | rext_sel
+			 | saved_data
+			 | val )
+			& ~(PHY_LANE_CTRL_CMD_READ));
+
+	while ((nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl)) & PHY_LANE_CTRL_CMD_PENDING);
+
+	/*  Read Phy lane Status to check if PMA controller is ready
+	 *  PHY_LANE_0_STATUS = lane_ctrl-PHY_LANE_0_CTRL
+	 */
 	while(!((val = nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl-PHY_LANE_0_CTRL)) & PHY_LANE_STAT_PCR));
 
 	/* Clear the Power Down bit */
@@ -886,7 +870,7 @@ static void xlp_nae_config_lane_gmac(int node, int cplx_mask)
 		block = 4;
 		for( lane_ctrl = PHY_LANE_0_CTRL; lane_ctrl <= PHY_LANE_1_CTRL; lane_ctrl++)
 		{
-			if (is_nlm_xlp8xx_b0()) {
+			if (is_nlm_xlp8xx_bx()) {
 				xlp3xx_8xxb0_nae_lane_reset_txpll(node, block, lane_ctrl, PHYMODE_SGMII);
 			} else {
 				xlp8xx_ax_nae_lane_reset_txpll(node, block, lane_ctrl, PHYMODE_SGMII);
@@ -901,7 +885,7 @@ static void xlp_nae_config_lane_gmac(int node, int cplx_mask)
 		}
 
 		for( lane_ctrl = PHY_LANE_0_CTRL; lane_ctrl <= PHY_LANE_3_CTRL; lane_ctrl++){
-			if ((is_nlm_xlp3xx()) || (is_nlm_xlp8xx_b0())) {
+			if ((is_nlm_xlp3xx()) || (is_nlm_xlp8xx_bx())) {
 				xlp3xx_8xxb0_nae_lane_reset_txpll(node, block, lane_ctrl, PHYMODE_SGMII);
 			}else{
 				xlp8xx_ax_nae_lane_reset_txpll(node, block, lane_ctrl, PHYMODE_SGMII);
@@ -910,6 +894,15 @@ static void xlp_nae_config_lane_gmac(int node, int cplx_mask)
 	return;
 }
 
+void nlm_hal_mdio_init(int node)
+{
+        nlm_hal_mdio_reset(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG);
+        nlm_hal_mdio_reset(node, NLM_HAL_EXT_MDIO, 0, BLOCK_7, LANE_CFG);
+        nlm_hal_mdio_reset(node, NLM_HAL_EXT_MDIO, 1, BLOCK_7, LANE_CFG);
+        nlm_hal_mdio_reset(node, NLM_HAL_EXT_MDIO_C45, 0, BLOCK_7, LANE_CFG);
+        nlm_hal_mdio_reset(node, NLM_HAL_EXT_MDIO_C45, 1, BLOCK_7, LANE_CFG);
+}
+
 /**
 * @brief nlm_hal_sgmii_pcs_init function resets MDIOs, scans external PHYs, and configures lanes in SGMII mode.
 *
@@ -924,12 +917,6 @@ static void xlp_nae_config_lane_gmac(int node, int cplx_mask)
 */
 void nlm_hal_sgmii_pcs_init(int node, int sgmii_cplx_mask)
 {
-        nlm_hal_mdio_reset(node, NLM_HAL_INT_MDIO, 0, BLOCK_7, LANE_CFG);
-        nlm_print("Net:   Reset Internal MDIO\n");
-        nlm_hal_mdio_reset(node, NLM_HAL_EXT_MDIO, 0, BLOCK_7, LANE_CFG);
-        nlm_hal_mdio_reset(node, NLM_HAL_EXT_MDIO, 1, BLOCK_7, LANE_CFG);
-        nlm_print("Net:   Reset External MDIO\n");
-        nlm_print("Net:   Reset External MDIO\n");
 #if !defined(XLP_SIM) || defined(NLM_BOARD)
         sgmii_scan_phys(node);
 #endif
@@ -937,8 +924,6 @@ void nlm_hal_sgmii_pcs_init(int node, int sgmii_cplx_mask)
         nlm_print("Net:   Completed PCS Configuration\n");
 }
 
-
-
 /**
 * @brief nlm_hal_config_sgmii_if function configures an SGMII interface to the correct speed and mode.
 *
@@ -1047,31 +1032,6 @@ int nlm_hal_load_ucore(int node, int ucore_mask, unsigned int *opcodes, int num_
 }
 
 /**
-* @brief init_egress function is used to initialize the NAE uCore spray mask to the default value.
-*
-* @param [in] node Node number
-* @param [in] if_num Interface number
-*
-* @return
-* 	- none
-* 
-* @ingroup hal_nae
-*
-*/
-static void init_ucore(int node, int if_num)
-{
-
-	if(is_nlm_xlp3xx()){
-		nlm_hal_write_nae_reg(node, UCORE_IFACE_MASK_CFG,
-                              ucore_spray_config(if_num, 0xff, CMD_WRITE));
-	}
-	else {
-		nlm_hal_write_nae_reg(node, UCORE_IFACE_MASK_CFG,
-			      ucore_spray_config(if_num, 0xffff, CMD_WRITE));
-	}
-}
-
-/**
 * @brief nlm_hal_write_ucore_shared_mem function is used to write the shared memory of the NAE uCores.
 *
 * @param [in] data Pointer to the 32-bit data
@@ -1083,15 +1043,16 @@ static void init_ucore(int node, int if_num)
 * @ingroup hal_nae
 *
 */
-int nlm_hal_write_ucore_shared_mem(unsigned int *data, int words)
+int nlm_hal_write_ucore_shared_mem(int node, unsigned int *data, int words)
 {
 	int i = 0;
-	if(words>128)
+	int end =  ucore_shared_scratch_words[node] + words;
+	if(end > 128)
 		return -1;
-	for (i=0; i<words; ++i) {
-		ucore_shared_scratch[i] = data[i];
+	for (i=ucore_shared_scratch_words[node]; i<end; ++i) {
+		ucore_shared_scratch[node][i] = data[i];
 	}
-	ucore_shared_scratch_words = words;
+	ucore_shared_scratch_words[node] += words;
 	return 0;
 }
 
@@ -1123,9 +1084,9 @@ static int local_load_ucore(int node, int ucore_mask, unsigned int *opcodes, int
 	NAE_DEBUG("node %d: ucore_mask 0x%x num_opcodes %d\n",node, ucore_mask, num_opcodes);
 	/* Stop all ucores */
 #ifndef UCORE_POE_BYPASS
-	if (nae_reset_done == 0) { /* Skip the Ucore reset if NAE reset is done */
+	if (nae_reset_done[node] == 0) { /* Skip the Ucore reset if NAE reset is done */
 #else
-	if (is_nlm_xlp8xx_b0()) {
+	if (is_nlm_xlp8xx_bx()) {
 #endif
 		nlm_print("Stopping and Resetting all ucore...\n");
 
@@ -1171,12 +1132,12 @@ static int local_load_ucore(int node, int ucore_mask, unsigned int *opcodes, int
 		id++;
 	}
 	/* Download u-core shared memory data*/
-	if(ucore_shared_scratch_words){
+	if(ucore_shared_scratch_words[node]){
 		ucore_cfg = nlm_hal_read_nae_reg(node, RX_UCORE_CFG);	
 		/*set iram to 0*/
 		nlm_hal_write_nae_reg(node, RX_UCORE_CFG, ucore_cfg & ~(1<<7));
-		for (i=0; i<ucore_shared_scratch_words; ++i) {
-			nlm_hal_write_ucode(node, 0, (i * 4), ucore_shared_scratch[i]);
+		for (i=0; i<ucore_shared_scratch_words[node]; ++i) {
+			nlm_hal_write_ucode(node, 0, (i * 4), ucore_shared_scratch[node][i]);
 		}
 		/*restore ucore_cfg*/
 		nlm_hal_write_nae_reg(node, RX_UCORE_CFG, ucore_cfg);
@@ -1221,25 +1182,32 @@ static void parse_ucore_config(void *fdt, int node)
 	unsigned int *uc_opcodes;
 	uint32_t uc_mask = 0, num_opcodes = 0;
 	char path_str[50];
+	int count = 1;
+	int ret = 0;
+
+	while(count <= 16) {
+		sprintf(path_str, "/soc/nae@node-%d/ucore/src@%d",node, count);
+		/* Domain specific ucore mask */
+		ret = GET_UCORE_PROP(path_str, "mask", &uc_mask, sizeof(uint32_t));
+		if (ret < 0)
+			return;
+		nlm_print("UCORE MASK 0x%x\n",uc_mask);
+		GET_UCORE_PROP(path_str, "num-opcodes", &num_opcodes, sizeof(uint32_t));
+
+		size = sizeof(uint32_t) * num_opcodes;
+		uc_opcodes = nlm_malloc(size);
+		if (!uc_opcodes) {
+			nlm_print("[%s] Unable to allocate temporary memory\n", __func__);
+			return;
+		}
 
-	sprintf(path_str, "/soc/nae@node-%d/ucore/src@%d",node, 1);
-	/* Domain specific ucore mask */
-	GET_UCORE_PROP(path_str, "mask", &uc_mask, sizeof(uint32_t));
-	nlm_print("UCORE MASK 0x%x\n",uc_mask);
-	GET_UCORE_PROP(path_str, "num-opcodes", &num_opcodes, sizeof(uint32_t));
-
-	size = sizeof(uint32_t) * num_opcodes;
-	uc_opcodes = nlm_malloc(size);
-	if (!uc_opcodes) {
-		nlm_print("[%s] Unable to allocate temporary memory\n", __func__);
-		return;
-	}
-
-	GET_UCORE_PROP(path_str, "opcodes", uc_opcodes, size);
+		GET_UCORE_PROP(path_str, "opcodes", uc_opcodes, size);
 
-	local_load_ucore(node, uc_mask, (unsigned int *)uc_opcodes, num_opcodes);
+		local_load_ucore(node, uc_mask, (unsigned int *)uc_opcodes, num_opcodes);
 
-	nlm_free(uc_opcodes);
+		nlm_free(uc_opcodes);
+		count++;
+	}
 }
 
 #define POE_NODE "/soc/nae-cfg/poe/regs"
@@ -2149,8 +2117,8 @@ static void nlm_config_tx_calendar(int node, nlm_nae_config_ptr nae_cfg)
         }
 
 	cal_len = nae_cfg->tx_cal_slots - 1;
-
-	nlm_hal_write_nae_reg(node, EGR_NIOR_CAL_LEN_REG, cal_len - 1);
+	
+	nlm_hal_write_nae_reg(node, EGR_NIOR_CAL_LEN_REG, cal_len);
         do {
                 if (cal >= MAX_CAL_SLOTS)
                         break;
@@ -2195,7 +2163,7 @@ int nlm_config_vfbid_table(int node, uint32_t start, uint32_t num_entries, uint3
 	for(vfbid = start; vfbid < (start + num_entries); vfbid++, vfbid_tbl++) {
 		val = ((*vfbid_tbl) << 16) | (vfbid << 4) | 1;
 		nlm_hal_write_nae_reg(node, VFBID_TO_DEST_MAP_CMD, val);		
-	//	NAE_DEBUG("vfbid %d dest %d \n",vfbid, *vfbid_tbl);
+		NAE_DEBUG("node %d vfbid %d *vfbid %d\n", node, vfbid, *vfbid_tbl);
 	}
 	return 0;	
 }
@@ -2304,7 +2272,6 @@ static void nlm_config_ingress_fifo(int node, nlm_nae_config_ptr nae_cfg)
 	int cur_iface_start = 0, max_ports;
 	uint32_t cur_parser_base = 0, context_base = 0, rx_buf_base = 0, size = 0;
 
-        NAE_DEBUG("Interface FIFO carving \n");
         if (is_nlm_xlp3xx()) {
                 max_ports = XLP_3XX_MAX_PORTS;
         }
@@ -2312,16 +2279,27 @@ static void nlm_config_ingress_fifo(int node, nlm_nae_config_ptr nae_cfg)
                 max_ports = XLP_MAX_PORTS;
         }
 
+        NAE_DEBUG("Interface FIFO carving max_ports:%d \n", max_ports);
         for (port = 0, hw_port = 0 ; hw_port < max_ports; ) { 
 	    if (hw_port == nae_cfg->ports[port].hw_port_id) {
 
+		NAE_DEBUG("cfg rxbuffer n:%d port:%d ctx_base:%d ch:%d rx_buf_base:%X buf_sz:%d\n",
+			node, hw_port, context_base, nae_cfg->ports[port].num_channels,
+                                        rx_buf_base, nae_cfg->ports[port].rx_buf_size);
+
 		nlm_configure_rxbuffer(node, context_base,nae_cfg->ports[port].num_channels,
                                         rx_buf_base, nae_cfg->ports[port].rx_buf_size);  
                 rx_buf_base += nae_cfg->ports[port].rx_buf_size;
 
+		NAE_DEBUG("port:%d iftype:%d\n", port, nae_cfg->ports[port].iftype);
 		switch(nae_cfg->ports[port].iftype) {
+		   case RXAUI_IF:
+			fifo_xoff_thresh = 12;
+			max_lanes = 4;
+			offset = 4;
+			break;
 		   case XAUI_IF:
-			fifo_xoff_thresh = 12;	   	
+			fifo_xoff_thresh = 12;
 			max_lanes = 4;
 			offset = 4;
 			break;
@@ -2344,12 +2322,14 @@ static void nlm_config_ingress_fifo(int node, nlm_nae_config_ptr nae_cfg)
 
 		for (lane = 0 ; lane < max_lanes; lane++) {
 			// carving interface fifo
+			NAE_DEBUG("carving intf fifo: lane:%d n:%d hw_port:%d\n", lane, node, hw_port);
 			size = ((lane == 0) ? nae_cfg->ports[port].intf_fifo_size : 0);
 			nlm_write_interface_fifo(node, nae_cfg->ports[port].hw_port_id + lane,
                                                          cur_iface_start, size, fifo_xoff_thresh );
 			cur_iface_start += size;
 			
 			// carving Rx base
+			NAE_DEBUG("carving rx buffer: lane:%d\n", lane);
 			nlm_write_rxbase(node, nae_cfg->ports[port].hw_port_id + lane, context_base);
 			if (lane == 0)
                         	context_base += nae_cfg->ports[port].num_channels;
@@ -2362,6 +2342,7 @@ static void nlm_config_ingress_fifo(int node, nlm_nae_config_ptr nae_cfg)
 		port++;
 	    }
 	    else {
+		NAE_DEBUG("carving intf fifo;rx buffer: lane:%d n:%d port:%d\n", lane, node, hw_port);
 		nlm_write_interface_fifo(node, hw_port, cur_iface_start, 0, 0 );
 		nlm_write_rxbase(node, hw_port, context_base);
 		nlm_configure_parserfifo(node, hw_port, cur_parser_base, 0);
@@ -2378,7 +2359,7 @@ static void nlm_config_nae_global(int node, nlm_nae_config_ptr nae_cfg)
 
 	nlm_config_poe_class(node);
 
-        if (nae_cfg->flags & FREEBACK_TO_NAE) {
+	if (nae_cfg->flags & FREEBACK_TO_NAE) {
                 dest = nae_cfg->frin_queue_base;
 
                 for (i = 0, vfbid = 32; i < NLM_MAX_NODES; vfbid++) {
@@ -2405,7 +2386,11 @@ static void nlm_config_nae_global(int node, nlm_nae_config_ptr nae_cfg)
 
 	}
 
-	if (nae_cfg->num_ports)
+#if defined(NLM_HAL_UBOOT)
+	if (0==nae_cfg->num_ports)
+		return; /* if no interface ports, Uboot skip nae cfg */
+	else
+#endif
 		nlm_config_flow_base(node, nae_cfg);
 	nlm_hal_write_nae_reg(node, FLOW_CRC16_POLY_CFG, 0xFFFF);
 	nlm_config_ingress_fifo(node, nae_cfg);
@@ -2442,19 +2427,17 @@ static void set_nae_frequency(int node, int frequency)
         set_freq_d /= mhz;
         set_freq = set_freq_d / 2;
 #endif
-        nlm_print("NAE 2X Frequency set to %lluMHz (NAE frequency %llu MHz)\n", set_freq_d, set_freq);
+        nlm_print("NAE 2X Frequency set to %lluMHz (NAE frequency %llu MHz)\n", 
+					(unsigned long long)set_freq_d, (unsigned long long)set_freq);
 }
 
 static int nae_freein_fifo_cfg(void *fdt, int node, nlm_nae_config_ptr nae_cfg)
 {
 	uint64_t tmp[2];
 	uint64_t *pval;
-	uint32_t reg, size, spillsz, port = 0;
+	uint32_t reg, size, spillsz;
 	int start = 0, i,  th_hi, th_lo;
 	uint64_t spill_addr, spill_mem_addr, spill_mem_size; 
-	int freein_fifo_shared = 0;
-	uint32_t freein_fifo_onchip_num_descs = 0;
-	uint32_t freein_fifo_spill_num_descs = 0;
 	int freein_fifo_total_queues = nae_cfg->frin_total_queue;
 	char path_str[50];
 
@@ -2496,16 +2479,15 @@ static int nae_freein_fifo_cfg(void *fdt, int node, nlm_nae_config_ptr nae_cfg)
 		spill_mem_size = nae_cfg->freein_spill_size;
 	}
 
-	copy_fdt_prop(fdt, path_str, "freein-fifo-shared", PROP_CELL, 
-			&freein_fifo_shared, 4);
-	copy_fdt_prop(fdt, path_str, "freein-fifo-onchip-num-descs", PROP_CELL, 
-			&freein_fifo_onchip_num_descs, 4);
-	copy_fdt_prop(fdt, path_str, "freein-fifo-spill-num-descs", PROP_CELL,
-			&freein_fifo_spill_num_descs, 4);
-			
-	nlm_print("NAE Freein-fifo, memaddr %lx memsize %lx shared %d onnchip-descs %d spill-descs %d\n",
-			(long)spill_mem_addr, (long)spill_mem_size, freein_fifo_shared,
-			freein_fifo_onchip_num_descs,freein_fifo_spill_num_descs);
+	nlm_print("NAE Freein-fifo, memaddr %lx memsize %lx onnchip-descs %d spill-descs %d\n",
+			(long)spill_mem_addr, (long)spill_mem_size, 
+			nae_cfg->freein_fifo_onchip_num_descs[0], nae_cfg->freein_fifo_spill_num_descs);
+
+	nlm_print("onchip descs array:\n");
+	for (i=0; i<MAX_NAE_FREEIN_DESCS_QUEUE; i++) {
+		nlm_print(" %d", nae_cfg->freein_fifo_onchip_num_descs[i]);
+	}
+	nlm_print("\n");
 
 	/* in cache addr */
 	spill_addr = spill_mem_addr >> 6; 
@@ -2513,16 +2495,16 @@ static int nae_freein_fifo_cfg(void *fdt, int node, nlm_nae_config_ptr nae_cfg)
 	/* in cachelines, 1 cacheline can store 12 descs  and 
 	get the number of cacheline required */
 	if (spill_mem_size != 0) {
-		spillsz = freein_fifo_spill_num_descs / 12 ; 
-		if((freein_fifo_spill_num_descs % 12) != 0)
+		spillsz = nae_cfg->freein_fifo_spill_num_descs / 12 ; 
+		if((nae_cfg->freein_fifo_spill_num_descs % 12) != 0)
 			spillsz++;
 	}
 	else
 		spillsz = 0;	
 
-	if (freein_fifo_shared) {
+	{
 		for(i = 0; i < freein_fifo_total_queues; i++) {
-			if(i < 16 && (spillsz)) {
+			if(i < MAX_NAE_FREEIN_DESCS_QUEUE && (spillsz)) {
 
 				reg = spill_addr & 0xffffffff;
 				nlm_hal_write_nae_reg(node, FREE_SPILL0_MEM_CFG, reg);
@@ -2541,8 +2523,8 @@ static int nae_freein_fifo_cfg(void *fdt, int node, nlm_nae_config_ptr nae_cfg)
 			}
 		
 			/* Onchip configuraton is based on locations. 1 location can store 2 descs */
-			if(i < 16) {
-				size = freein_fifo_onchip_num_descs / 2;
+			if(i < MAX_NAE_FREEIN_DESCS_QUEUE) {
+				size = nae_cfg->freein_fifo_onchip_num_descs[i] / 2;
 				/* take num free desc for the mgmt ports from the complex config only */
 				if(size == 0) 
 					size = 8;
@@ -2558,49 +2540,6 @@ static int nae_freein_fifo_cfg(void *fdt, int node, nlm_nae_config_ptr nae_cfg)
 		}
 	}
 
-	for(i = 0, port = 0; i < freein_fifo_total_queues;) {
-		if ((freein_fifo_shared) && (nae_cfg->ports[port].hw_port_id < 16)) {
-			port++;
-			if(port >= nae_cfg->num_ports)
-				break;
-			i = nae_cfg->ports[port].hw_port_id;
-			continue;
-		} 
-
-                if(i < 16 && (spillsz)) {
-                        reg = spill_addr & 0xffffffff;
-                        nlm_hal_write_nae_reg(node, FREE_SPILL0_MEM_CFG, reg);
-                        nlm_print("Freein fifo cfg %d spl_addr %lx reg0 %x\n", i, (long)spill_addr, reg);
-
-	                reg = (((spill_addr >> 32) & 0x3) << 30) | spillsz;
-                        nlm_hal_write_nae_reg(node, FREE_SPILL1_MEM_CFG, reg);
-
-                        nlm_print("Freein fifo cfg %d spl_addr %lx reg1 %x\n", i, (long)spill_addr, reg);
-                        spill_addr += spillsz;
-                        /* align to 32k, already >> 6 is done above, so align to 1k */
-                        spill_addr = (spill_addr + 1023) & (~1023);
-                } else {
-                        nlm_hal_write_nae_reg(node, FREE_SPILL0_MEM_CFG, 0);
-                        nlm_hal_write_nae_reg(node, FREE_SPILL1_MEM_CFG, 0);
-                }
-
-		if (i == nae_cfg->ports[port].hw_port_id){
-			size = nae_cfg->ports[port].num_free_desc / 2;
-			port++;	
-		}
-		else
-			size = 8;
-
-		reg = ((size  & 0x3ff ) << 20) | /* fcSize */
-	                 ((start & 0x1ff)  << 8) | /* fcStart */
-                         (i  & 0x1f);
-
-		nlm_hal_write_nae_reg(node, FREE_IN_FIFO_CFG, reg);
-                nlm_print("Freein fifo cfg... %d fcstart %d size %d\n", i, start, size);
-                start += size;		
-		i++;
-	}
-
 	if(spillsz) {
 		th_hi = 6; /* Defualt value */
 		th_lo = 0xe; /* Default value */
@@ -2614,21 +2553,18 @@ static int nae_freein_fifo_cfg(void *fdt, int node, nlm_nae_config_ptr nae_cfg)
 		}
 	}
 	
-	nae_cfg->freein_fifo_shared = freein_fifo_shared;
-	nae_cfg->freein_fifo_onchip_num_descs = freein_fifo_onchip_num_descs;
-	nae_cfg->freein_fifo_spill_num_descs = freein_fifo_spill_num_descs;
-
 	return 0;
 }
 
 
-static int parse_vfbid_config(void *fdt, int node, uint32_t *vfbid_tbl)
+static int parse_vfbid_config(void *fdt, int node)
 {
 	char vfbid_path[50];
 	int offset, dest, index;
 	nlm_nae_config_ptr nae_cfg = nlm_node_cfg.nae_cfg[node];
 	uint32_t *pval;
 	int plen = 0, nodeoffset = 0, hw_replenish;
+	uint32_t *vfbid_tbl = nae_vfbid_tbl[node];
 
 	sprintf(vfbid_path, "/soc/nae@node-%d/vfbid-config",node);
 
@@ -2680,6 +2616,8 @@ static inline int get_slots_required(int intf_type)
 		return SGMII_CAL_SLOTS;
 	else if (intf_type == XAUI_IF)
 		return XAUI_CAL_SLOTS;
+	else if (intf_type == RXAUI_IF)
+		return XAUI_CAL_SLOTS;
 	else if (intf_type == INTERLAKEN_IF)	
 		return ILK_CAL_SLOTS;
 	else
@@ -2705,22 +2643,33 @@ static inline int valid_calendar_slot(uint32_t slot)
 static int get_interface_type(void *fdt, char *nae_port_str, int block, int port, int node)
 {
 	int intf_type, offset;
-	char port_type_str[NAE_MAX_PROP_LEN];
 	nlm_nae_config_ptr nae_cfg = nlm_node_cfg.nae_cfg[node];
+#ifndef NLM_HAL_UBOOT
+	char port_type_str[NAE_MAX_PROP_LEN];
+#endif
 
+#ifdef SKIP_INTERFACE_TYPE_FROMCPLD
+	intf_type = DC_NOT_PRSNT;
+#else
 	intf_type = nlm_get_interface_type(node, block);
+#endif
 
+#ifndef NLM_HAL_UBOOT
 	if (intf_type == DC_NOT_PRSNT) {
-        	if (GET_PORT_STR_PROP("mode", port_type_str, MAX_PROP_LEN) < 0) {
-                	nlm_print("FDT missing mode param for complex %d\n", block);
-                        intf_type = UNKNOWN_IF;
-                }
+		if (GET_PORT_STR_PROP("mode", port_type_str, NAE_MAX_PROP_LEN) < 0) {
+			nlm_print("FDT missing mode param for complex %d\n", block);
+			intf_type = UNKNOWN_IF;
+		}
+		nlm_print("%s", port_type_str);
                 if (!strcmp(port_type_str, "sgmii")) {
                         intf_type = DC_SGMII;
                 }
                 else if (!strcmp(port_type_str, "xaui")) {
                         intf_type = DC_XAUI;
                 }
+                else if (!strcmp(port_type_str, "rxaui")) {
+                        intf_type = DC_RXAUI;
+                }
                 else if (!strcmp(port_type_str, "interlaken")) {
                         intf_type = DC_ILK;
                 }
@@ -2729,8 +2678,28 @@ static int get_interface_type(void *fdt, char *nae_port_str, int block, int port
                         return -1;
                 }
         }
+	else if (intf_type == DC_XAUI) {
+		/* RXAUI & XAUI have the same intf_type value from the board CPLD */
+		if (GET_PORT_STR_PROP("mode", port_type_str, NAE_MAX_PROP_LEN) < 0) {
+			nlm_print("FDT missing mode param for complex %d\n", block);
+			intf_type = UNKNOWN_IF;
+			return -1;
+		}
+		nlm_print("%s", port_type_str);
+		if (!strcmp(port_type_str, "rxaui")) {
+			intf_type = DC_RXAUI;
+		}
+	}
+#endif
 
         switch(intf_type) {
+                case DC_SGMII:
+			nlm_print("Complex %d in SGMII mode\n", block);
+			for(offset = 0; offset < MAX_PORTS_PERBLOCK; offset++) {
+	                        nae_cfg->ports[port+offset].iftype = SGMII_IF;
+			}
+                        break;
+#ifndef NLM_HAL_UBOOT /* Uboot only support SGMII interface only for management port */
         	case DC_ILK:
 			if ((is_nlm_xlp3xx()) || (node != 0)) { // FIXME interlaken supported only on node-0 nae
 				nlm_print("Interlaken not supported \n");
@@ -2739,25 +2708,21 @@ static int get_interface_type(void *fdt, char *nae_port_str, int block, int port
 			nlm_print("Complex %d in interlaken mode\n", block);
                 	if (is_nlm_xlp8xx()) {
                         	nae_cfg->ports[port].iftype = INTERLAKEN_IF;
-			//	nae_cfg->ilk_complex_map |= (1 << block);
 			}
                         else {
                                 nae_cfg->ports[port].iftype = UNKNOWN_IF;
                                 nlm_print("Interlaken is not supported on this board \n");
                         }
 			break;
-                case DC_SGMII:
-			nlm_print("Complex %d in SGMII mode\n", block);
-			// nae_cfg->sgmii_complex_map |= (1 << block);
-			for(offset = 0; offset < MAX_PORTS_PERBLOCK; offset++) {
-	                        nae_cfg->ports[port+offset].iftype = SGMII_IF;
-			}		
-                        break;
                 case DC_XAUI:
 			nlm_print("Complex %d in xaui mode\n", block);
-			// nae_cfg->xaui_complex_map |= (1 << block);
                         nae_cfg->ports[port].iftype = XAUI_IF;
                         break;
+                case DC_RXAUI:
+			nlm_print("Complex %d in rxaui mode\n", block);
+                        nae_cfg->ports[port].iftype = RXAUI_IF;
+                        break;
+#endif
                 default:
                         nae_cfg->ports[port].iftype = UNKNOWN_IF;
 	}
@@ -2823,6 +2788,40 @@ uint32_t nlm_hal_get_frin_queue_base(int node)
 	return frin_queue_base;
 }
 
+void dump_nae_cfg_info(int node, nlm_nae_config_ptr nae_cfg)
+{
+	int i, j;
+
+	nlm_print("Node %d owned %d fb_vc = %d, rx_vc = %d\n", node, nae_cfg->owned, nae_cfg->fb_vc, nae_cfg->rx_vc);
+	nlm_print(" frin_queue_base %d frin_total_queue %d \n", nae_cfg->frin_queue_base, nae_cfg->frin_total_queue);
+	nlm_print(" number of ports %d max_channels %d\n", nae_cfg->num_ports, nae_cfg->num_contexts);
+	for(i = 0; i < nae_cfg->num_ports; i++ ) {
+		if(!nae_cfg->ports[i].valid)
+			continue;
+		nlm_print(" port %d type %d hwport %d num_channel %d num_free_desc %d \n", 
+			i, nae_cfg->ports[i].iftype,
+			nae_cfg->ports[i].hw_port_id, nae_cfg->ports[i].num_channels, nae_cfg->ports[i].num_free_desc);
+
+		nlm_print(" port %d freedesc %d txq %d rxq %d num_channel %d \n",
+			i, nae_cfg->ports[i].num_free_desc, nae_cfg->ports[i].txq, nae_cfg->ports[i].rxq, 
+			nae_cfg->ports[i].num_channels);
+	}
+	nlm_print(" num-onchip-descs %d num-spill-descs %d\n",
+			 nae_cfg->freein_fifo_onchip_num_descs[0],
+			 nae_cfg->freein_fifo_spill_num_descs);
+
+	nlm_print("onchip descs array:\n");
+	for (j=0; j<MAX_NAE_FREEIN_DESCS_QUEUE; j++) {
+		nlm_print(" %d", nae_cfg->freein_fifo_onchip_num_descs[j]);
+	}
+	nlm_print("\n");
+
+	nlm_print(" frfifo-dom-mask %x vfbid-shared(sw %d:%d hw %d:%d) daddr %llx\n",
+			nae_cfg->freein_fifo_dom_mask, nae_cfg->vfbtbl_sw_offset,
+			nae_cfg->vfbtbl_sw_nentries, nae_cfg->vfbtbl_hw_offset, nae_cfg->vfbtbl_hw_nentries, 
+			nae_cfg->dummy_pktdata_addr);
+	nlm_print("\n");
+}
 
 
 static int parse_port_config(void *fdt, int node, nlm_nae_config_ptr nae_cfg)
@@ -2847,21 +2846,34 @@ static int parse_port_config(void *fdt, int node, nlm_nae_config_ptr nae_cfg)
 		txq = (node <<10) | XLP_NET_TX_VC_BASE;
 	}
 	
-	nlm_print("node %d frin_queue_base %d frin_total_queue %d \n", node, nae_cfg->frin_queue_base, nae_cfg->frin_total_queue);
 	for(block=0, port = 0; block < max_complex; block++) {
 #ifndef NLM_HAL_UBOOT
 		if (is_nlm_xlp8xx_ax() && is_xlp_evp1() && (block % 2))
 			continue;
+#else
+	if (is_nlm_xlp8xx()) {
+		if(block != 4) {
+			nlm_print("Uboot Skip complex:%d\n", block);
+			continue;
+		}
+	}
+		nlm_print("Config complex:%d\n", block);
 #endif
 		sprintf(nae_port_str, "/soc/nae@node-%d/complex@%d",node, block);
 		fdt_cmplx_offset = fdt_path_offset(fdt, nae_port_str);
 		if (fdt_cmplx_offset < 0) {
-			nlm_print("complex %d configuration is missing in FDT\n", block);
+			//nlm_print("complex %d configuration is missing in FDT\n", block);
 			continue;
 		}
 
 		intf_type = get_interface_type(fdt, nae_port_str, block, port, node);
-
+                nlm_print("Complex %d intf:%d\n", block, intf_type);
+#ifdef NLM_HAL_UBOOT
+		if (intf_type != SGMII_IF) {
+			nlm_print("Uboot Skip Complex %d intf:%d\n", block, intf_type);
+			continue;
+		}
+#endif
 		if (intf_type == SGMII_IF) {
 			sprintf(nae_port_str, "/soc/nae@node-%d/complex@%d/sgmii", node, block);
 			fdt_cmplx_offset = fdt_path_offset(fdt, nae_port_str); 
@@ -2876,16 +2888,35 @@ static int parse_port_config(void *fdt, int node, nlm_nae_config_ptr nae_cfg)
 			sprintf(nae_port_str, "/soc/nae@node-%d/complex@%d/xaui", node, block);
 			fdt_cmplx_offset = fdt_path_offset(fdt, nae_port_str);
                         if (fdt_cmplx_offset < 0) {
-                                nlm_print("Complex %d XAUI configuration missing in FDT \n", block); 
+                                nlm_print("Complex %d XAUI configuration missing in FDT \n", block);
                                 continue;
                         }
 			nae_cfg->xaui_complex_map |= (1 << block);
 		}
+		else if (intf_type == RXAUI_IF) {
+			sprintf(nae_port_str, "/soc/nae@node-%d/complex@%d/rxaui", node, block);
+			fdt_cmplx_offset = fdt_path_offset(fdt, nae_port_str);
+                        if (fdt_cmplx_offset < 0) {
+                                nlm_print("Complex %d RXAUI configuration missing in FDT \n", block);
+                                continue;
+                        }
+			nae_cfg->rxaui_complex_map |= (1 << block);
+
+			GET_PORT_PROP("submode", &nae_cfg->ports[port].rxaui_mode,
+				sizeof(nae_cfg->ports[port].rxaui_mode));
+			GET_PORT_PROP("scrambler", &nae_cfg->ports[port].rxaui_scrambler,
+				sizeof(nae_cfg->ports[port].rxaui_scrambler));
+			nlm_print("Complex%d: map:0x%X submode:%d scrambler:%d\n", block,
+				nae_cfg->rxaui_complex_map,
+				nae_cfg->ports[port].rxaui_mode,
+				nae_cfg->ports[port].rxaui_scrambler);
+
+		}
 		else if (intf_type == INTERLAKEN_IF) {
 			sprintf(nae_port_str, "/soc/nae@node-%d/complex@%d/interlaken",node, block);
 			fdt_cmplx_offset = fdt_path_offset(fdt, nae_port_str);
                         if (fdt_cmplx_offset < 0) {
-                                nlm_print("Complex %d interlaken configuration missing in FDT \n", block);  
+                                nlm_print("Complex %d interlaken configuration missing in FDT \n", block);
                                 continue;
                         }
 			nae_cfg->ilk_complex_map |= (1 << block);
@@ -2896,7 +2927,6 @@ static int parse_port_config(void *fdt, int node, nlm_nae_config_ptr nae_cfg)
 		}
 
 		num_ports = get_num_ports(block, intf_type);
-		
 		extract_complex_params(fdt, intf_type, nae_port_str, &cmplx_cfg);
 
 		for(offset = 0; offset < num_ports; offset++, port++) {
@@ -2931,7 +2961,6 @@ static int parse_port_config(void *fdt, int node, nlm_nae_config_ptr nae_cfg)
 				return -1;
 			rx_slots += nae_port->rx_slots_reqd;
 			txq += nae_port->num_channels;		
-			nlm_print("port %d hwport %d num_channel %d num_free_desc %d \n", port, nae_port->hw_port_id, nae_port->num_channels, nae_port->num_free_desc);
 		}		
 		if (intf_type == INTERLAKEN_IF)
 			block++;
@@ -2940,7 +2969,6 @@ static int parse_port_config(void *fdt, int node, nlm_nae_config_ptr nae_cfg)
 	nae_cfg->rx_cal_slots = rx_slots;
 	nae_cfg->tx_cal_slots = tx_slots;
 	nae_cfg->num_contexts = max_context;
-	nlm_print("Node %d number of ports %d max_channels %d\n", node, nae_cfg->num_ports, nae_cfg->num_contexts);
 	return nae_cfg->num_ports;
 }
 
@@ -2964,7 +2992,6 @@ static void parse_fdt_nae_config(void *fdt, int node, nlm_nae_config_ptr nae_cfg
 	int num_ports = 0, port = 0;
 	uint32_t start_port, num_nae_regs, num_intf_regs;
 	char path_str[50];
-	uint32_t vfbid_tbl[MAX_VFBID_ENTRIES];
 	uint32_t rx_config = 0, tx_config = 0;
 	int frequency, context = 0;
 
@@ -2976,26 +3003,44 @@ static void parse_fdt_nae_config(void *fdt, int node, nlm_nae_config_ptr nae_cfg
 	if(GET_NAE_PROP(path_str, "frequency", &frequency, sizeof(uint32_t)) < 0)
 		nlm_print("fdt missing frequency\n");
 
+	if ((is_nlm_xlp3xx()) && (frequency > XLP3XX_MAX_NAE_FREQUENCY))
+		frequency = XLP3XX_MAX_NAE_FREQUENCY;
+
 	if (!is_kexec_boot())
 		set_nae_frequency(node, frequency);
 
-	parse_vfbid_config(fdt, node, vfbid_tbl);
+
+	parse_vfbid_config(fdt, node);
 
 	num_ports = parse_port_config(fdt, node, nae_cfg);  
+	NAE_DEBUG("node %d num_ports:%d\n", node, num_ports);
 	if (num_ports < 0) {
 		nlm_print("Node %d NAE configuration failed. Check fdt params !!!", node);
 		while(1);
 	}
 
+#if defined(NLM_HAL_UBOOT)
+	if (num_ports == 0) {
+		return;
+	}
+#endif
+
+	NAE_DEBUG("node %d mdio init\n", node);
+	nlm_hal_mdio_init(node);
 
 	if (nae_cfg->sgmii_complex_map) {
 		NAE_DEBUG("node %d SGMII PCS init 0x%x\n", node, nae_cfg->sgmii_complex_map);
 	       	nlm_hal_sgmii_pcs_init(node, nae_cfg->sgmii_complex_map);
 	}
-	
+
 	if (nae_cfg->xaui_complex_map) {
 		NAE_DEBUG("node %d XAUI PCS init 0x%x\n", node, nae_cfg->xaui_complex_map);
-		nlm_hal_xaui_pcs_init(node, nae_cfg->xaui_complex_map);
+		nlm_hal_xaui_pcs_init(node, nae_cfg->xaui_complex_map, 0 /* rxaui_en */);
+	}
+
+	if (nae_cfg->rxaui_complex_map) {
+		NAE_DEBUG("node %d XAUI PCS init 0x%x\n", node, nae_cfg->rxaui_complex_map);
+		nlm_hal_xaui_pcs_init(node, nae_cfg->rxaui_complex_map, 1 /* rxaui_en */);
 	}
 
 	if (nae_cfg->ilk_complex_map) {
@@ -3022,7 +3067,7 @@ static void parse_fdt_nae_config(void *fdt, int node, nlm_nae_config_ptr nae_cfg
 	nlm_config_nae_global(node, nae_cfg);
 
 	if (nae_cfg->flags & VFBID_FROM_FDT) {
-		nlm_config_vfbid_table(node, 0 , MAX_VFBID_ENTRIES, vfbid_tbl);	
+		nlm_config_vfbid_table(node, 0 , MAX_VFBID_ENTRIES, nae_vfbid_tbl[node]);	
 	}
 
 	if(nae_freein_fifo_cfg(fdt, node, nae_cfg) < 0)
@@ -3032,7 +3077,17 @@ static void parse_fdt_nae_config(void *fdt, int node, nlm_nae_config_ptr nae_cfg
 	{
 		hw_port = nae_cfg->ports[port].hw_port_id;
                 if (nae_cfg->ports[port].iftype == XAUI_IF) {
-                        xlp_nae_config_xaui(node, (hw_port / 4), port, nae_cfg->ports[port].vlan_pri_en);
+			NAE_DEBUG("Cfg XAUI mode\n");
+			xlp_nae_config_xaui(node, (hw_port / 4), port,
+			nae_cfg->ports[port].vlan_pri_en,
+			nae_cfg->ports[port].rxaui_scrambler, NLM_NAE_XAUI_MODE_XAUI);
+                }
+                else if (nae_cfg->ports[port].iftype == RXAUI_IF) {
+			NAE_DEBUG("Cfg RXAUI mode:%d scrambler:%d\n",
+				nae_cfg->ports[port].rxaui_mode, nae_cfg->ports[port].rxaui_scrambler);
+                        xlp_nae_config_xaui(node, (hw_port / 4), port, nae_cfg->ports[port].vlan_pri_en,
+				nae_cfg->ports[port].rxaui_scrambler, nae_cfg->ports[port].rxaui_mode);
+			nlm_hal_rxaui_nlp1042c2_init(port, nae_cfg->ports[port].rxaui_mode);
                 }
                 else if (nae_cfg->ports[port].iftype == INTERLAKEN_IF) {
                         xlp_nae_config_interlaken(node, (hw_port / 4), port, nae_cfg->num_lanes[hw_port / XLP_ILK_MAX_LANES]);
@@ -3081,33 +3136,57 @@ static void parse_fdt_nae_config(void *fdt, int node, nlm_nae_config_ptr nae_cfg
 */
 static void drain_nae_frin_fifo_descs(int node)
 {
-	int i = 0;
         uint32_t value = 0, fifo_mask;
+	int timeout = 10;
 
         if (is_nlm_xlp3xx()) {
-                fifo_mask = 0xff;
+                fifo_mask = XLP_3XX_MAX_PORTS;
         }
         else {
-                fifo_mask = 0xfffff;
+                fifo_mask = XLP_MAX_PORTS;
         }
+	fifo_mask = ((1 << fifo_mask)-1);
 
 	nlm_hal_write_nae_reg(node, RX_FREE_FIFO_POP, fifo_mask);
-	for (i = 0; i < 10; i++) {
+	for (; timeout >= 0; timeout--) {
 		nlm_mdelay(1);
 		value = nlm_hal_read_nae_reg(node, RX_FREE_FIFO_POP);
 		if (value == fifo_mask) break;
 	}
-	if (i == 10) {
+	nlm_hal_write_nae_reg(node, RX_FREE_FIFO_POP, 0);
+
+	if (timeout) {
+		nlm_print("Successfully zapped free in fifo!\n");
+	} else {
 		nlm_print("Unable to zap free in fifo!(value=0x%08x)\n", value);
 	}
-	else {
-		nlm_print("Successfully zapped free in fifo!\n");
+}
+
+/**
+  * @brief nlm_hal_nae_drain_frin_fifo_descs clears a specific Free-in FIFO
+  * in the NAE ingress path.
+  * @param[in] node: Node number
+  * @param[in] inf : Interface number
+  * @return
+  * - 0 Free-in FIFO successfully emptied
+  * - -1 Free-in FIFO failed to drain successfully
+  * @ingroup hal_nae
+  */
+int nlm_hal_nae_drain_frin_fifo_descs(int node, int inf)
+{
+	uint32_t value, fifo_mask = 1 << inf;
+	int timeout = 10;
+
+	nlm_hal_write_nae_reg(node, RX_FREE_FIFO_POP, fifo_mask);
+	for (; timeout >= 0; timeout--) {
+		nlm_mdelay(1);
+		value = nlm_hal_read_nae_reg(node, RX_FREE_FIFO_POP);
+		if (value == fifo_mask) break;
 	}
 	nlm_hal_write_nae_reg(node, RX_FREE_FIFO_POP, 0);
+	return timeout? 0 : -1;
 }
 
-static int debug = 1;
-
 /**
 * @brief print_frin_desc_carving function prints the carving of the FreeIn FIFOs for the available interfaces.
 *
@@ -3119,6 +3198,8 @@ static int debug = 1;
 * @ingroup hal_nae
 *
 */
+#ifdef INCLUDE_NAE_DEBUG
+static int debug = 1;
 static void print_frin_desc_carving(int node)
 {
 	int intf, max;
@@ -3145,6 +3226,7 @@ static void print_frin_desc_carving(int node)
 		nlm_print("intf@%02d=0x%08x, start=%d, size=%d\n", intf, value, start, size);
 	}
 }
+#endif //INCLUDE_NAE_DEBUG
 
 /**
 * @brief deflate_frin_fifo_carving function initializes the FreeIn FIFO carvings with minimum default values.
@@ -3271,8 +3353,41 @@ static void reset_nae(int node)
 	nlm_mdelay(1);
 
 	rx_config = nlm_hal_read_nae_reg(node, RX_CONFIG);
-	nae_reset_done = 1;
+	nae_reset_done[node] = 1;
+}
+
+#if !defined(NLM_HAL_UBOOT)
+/**
+ * @brief reset_poe function resets the POE.
+ *
+ * @param [in] node Node number
+ *
+ * @return
+ *  - none
+ * 
+ * @ingroup hal_nae
+ *
+ */
+static void reset_poe(int node)
+{
+	int reset_bit = 10;
+
+	if (is_nlm_xlp3xx())
+		reset_bit = 7;
+	else
+		reset_bit = 10;
+
+
+	/* POE reset in the SYS_RESET register */
+	nlm_hal_write_sys_reg(node, SYS_RESET, (1 << reset_bit));
+	nlm_mdelay(1);
+
+	nlm_hal_write_sys_reg(node, SYS_RESET, (0 << reset_bit));
+	nlm_mdelay(1);
+
+	return;
 }
+#endif
 
 #if defined(__MIPSEL__)
 static uint32_t membar_fixup(uint32_t l)
@@ -3280,7 +3395,7 @@ static uint32_t membar_fixup(uint32_t l)
 	unsigned char b;
 	uint32_t fixup;
 
-	if (is_nlm_xlp8xx_b0() || !is_nlm_xlp8xx_ax())
+	if (is_nlm_xlp8xx_bx() || !is_nlm_xlp8xx_ax())
 		return l;
 
 	b = (l >> 24) & 0xff;
@@ -3322,249 +3437,55 @@ void  reset_nae_mgmt(int node)
  */
 
 #define PHY_STATUS_RETRIES 20000
-#define WAIT_XGMAC_MDIO_BSY_CLEAR(node)  for (i = 0; i < PHY_STATUS_RETRIES; i++) {	\
-        if((nlm_hal_read_mac_reg(node, 7, intf_type,					\
-        	EXT_XG0_MDIO_RD_STAT + bus * 4 ) & EXT_XG_MDIO_STAT_MBSY) == 0)	\
+
+#define WAIT_XGMAC_MDIO_BSY_CLEAR(node)  \
+	for (i = 0; i < PHY_STATUS_RETRIES; i++) {	\
+		if((nlm_hal_read_mac_reg(node, BLOCK_7, LANE_CFG,	\
+			EXT_XG0_MDIO_RD_STAT + bus * 4 ) & EXT_XG_MDIO_STAT_MBSY) == 0)	\
                         break;							\
         }
 
+#define WAIT_XGMAC_IMDIO_BSY_CLEAR(node)   \
+	for (i = 0; i < PHY_STATUS_RETRIES; i++) { \
+		if((nlm_hal_read_mac_reg(node, BLOCK_7, LANE_CFG, \
+			INT_MDIO_RD_STAT) & INT_MDIO_STAT_MBSY) == 0)        \
+                        break;                                                  \
+        }
 
 /*
  *                   XAUI Support
  *
  */
-
-/**********************************************************************
- *  nlm_hal_xgmac_mdio_indirect_addr -Write reg index for indirect read/write.
- *
- *  Input parameters:
- *         bus          - bus number, nae has two external xgmac bus: 0 and 1
- *         phyaddr      - PHY to use
- *         regidx       - register within the PHY
- *         val          - data to write to register
- *
- *  Return value:
- *         0 - success
- ********************************************************************* */
-/**
-* @brief nlm_hal_xgmac_mdio_indirect_addr writes the external PHY register index for a following indirect read/write.
-*
-* @param [in] node Node number
-* @param [in] bus External MDIO bus number
-* @param [in] block NAE Register Memory Map Block
-* @param [in] intf_type GMAC_0, GMAC_1, GMAC_2, GMAC_3, XGMAC, INTERLAKEN, PHY, LANE_CFG (only valid for block 7)
-* @param [in] phyaddr External PHY's address
-* @param [in] regidx PHY register index to read
-*
-* @return
-* 	- 0 on success
-* 
-* @ingroup hal_nae
-*
-*/
-static int nlm_hal_xgmac_mdio_indirect_addr(int node, int bus,int block, int intf_type, int phyaddr, int regidx)
-{
-        int32_t i;
-        int16_t dev_type;
-
-
-        dev_type = 0x5;
-
-        /* load  XGMC_MDIO_CTRL_DATA register with indirect addr */
-        nlm_hal_write_mac_reg(node, 7 , intf_type,
-                                EXT_XG0_MDIO_CTRL_DATA + bus * 4, regidx);
-
-        nlm_hal_write_mac_reg(node, 7, intf_type, EXT_XG0_MDIO_CTRL+ bus * 4,
-                                 phyaddr << EXT_XG_MDIO_CTRL_PHYADDR_POS
-                                | dev_type << EXT_XG_MDIO_CTRL_REG_POS
-                                | 0x9 << EXT_XG_MDIO_CTRL_XDIV_POS
-                                | 1 << EXT_XG_MDIO_CTRL_MCDIV_POS
-                                | EXT_XG_MDIO_CTRL_CMD_LOAD
-                                | MDIO_MIIM_CMD_10G_MMD << EXT_XG_MDIO_CTRL_MIIM_POS
-                                | EXT_XG_MDIO_CTRL_TA << EXT_XG_MDIO_CTRL_TA_POS
-                                | MDIO_CTRL_OP_INDIRECT_ADDR << EXT_XG_MDIO_CTRL_OP_POS
-                                | EXT_XG_MDIO_CTRL_ST);
-
-
-        /* poll master busy bit until it is not busy */
-	WAIT_XGMAC_MDIO_BSY_CLEAR(node)
-
-        nlm_hal_write_mac_reg(node, 7, intf_type, EXT_XG0_MDIO_CTRL+ bus * 4,
-                                 phyaddr << EXT_XG_MDIO_CTRL_PHYADDR_POS
-                                | dev_type << EXT_XG_MDIO_CTRL_REG_POS
-                                | 0x9 << EXT_XG_MDIO_CTRL_XDIV_POS
-                                | 1 << EXT_XG_MDIO_CTRL_MCDIV_POS
-                                | MDIO_MIIM_CMD_IDLE << EXT_XG_MDIO_CTRL_MIIM_POS
-                                | 0x0 << EXT_XG_MDIO_CTRL_TA_POS
-                                | MDIO_CTRL_OP_INDIRECT_ADDR << EXT_XG_MDIO_CTRL_OP_POS
-                                | EXT_XG_MDIO_CTRL_ST);
-
-
-        /* poll master busy bit until it is not busy */
-	WAIT_XGMAC_MDIO_BSY_CLEAR(node)
-	return 0;
-}
-
-/**********************************************************************
- *  nlm_hal_xgmac_mdio_indirect_write -Write xgmac mii PHY register.
- *
- *  Input parameters:
- *         bus          - bus number, nae has two external xgmac bus: 0 and 1
- *         phyaddr      - PHY to use
- *         regidx       - register within the PHY
- *         val          - data to write to register
- *
- *  Return value:
- *         0 - success
- ********************************************************************* */
 /**
-* @brief nlm_hal_xgmac_mdio_indirect_write writes an external PHY register.
+* @brief nlm_hal_xgmac_mdio_addr writes the external PHY register index for a following indirect read/write.
 *
 * @param [in] node Node number
 * @param [in] bus External MDIO bus number
-* @param [in] block NAE Register Memory Map Block
-* @param [in] intf_type GMAC_0, GMAC_1, GMAC_2, GMAC_3, XGMAC, INTERLAKEN, PHY, LANE_CFG (only valid for block 7)
 * @param [in] phyaddr External PHY's address
+* @param [in] dev_addr dev address
 * @param [in] regidx PHY register index to read
-* @param [in] val Value to write
 *
 * @return
 * 	- 0 on success
-* 
-* @ingroup hal_nae
 *
-*/
-int nlm_hal_xgmac_mdio_indirect_write(int node, int bus, int block, int intf_type, int phyaddr, int regidx, uint16_t val)
-{
-        int32_t  i;
-        int16_t dev_type;
-
-        dev_type = 0x5;
-
-         /* first is indirect address cycle */
-        nlm_hal_xgmac_mdio_indirect_addr(node, bus, block, intf_type, phyaddr, regidx);
-
-        nlm_hal_write_mac_reg(node, 7 , intf_type,
-                                EXT_XG0_MDIO_CTRL_DATA+ bus * 4, val);
-
-        nlm_hal_write_mac_reg(node, 7, intf_type, EXT_XG0_MDIO_CTRL+ bus * 4,
-                                 phyaddr << EXT_XG_MDIO_CTRL_PHYADDR_POS
-                                | dev_type << EXT_XG_MDIO_CTRL_REG_POS
-                                | 0x9 << EXT_XG_MDIO_CTRL_XDIV_POS
-                                | 1 << EXT_XG_MDIO_CTRL_MCDIV_POS
-                                | EXT_XG_MDIO_CTRL_CMD_LOAD
-                                | MDIO_MIIM_CMD_10G_MMD << EXT_XG_MDIO_CTRL_MIIM_POS
-                                | EXT_XG_MDIO_CTRL_TA << EXT_XG_MDIO_CTRL_TA_POS
-                                | MDIO_CTRL_OP_WRITE_10G_MMD << EXT_XG_MDIO_CTRL_OP_POS
-                                | EXT_XG_MDIO_CTRL_ST);
-
-        /* poll master busy bit until it is not busy */
-	WAIT_XGMAC_MDIO_BSY_CLEAR(node)
-
-
-        nlm_hal_write_mac_reg(node, 7, intf_type, EXT_XG0_MDIO_CTRL+ bus * 4,
-                                 phyaddr << EXT_XG_MDIO_CTRL_PHYADDR_POS
-                                | dev_type << EXT_XG_MDIO_CTRL_REG_POS
-                                | 0x9 << EXT_XG_MDIO_CTRL_XDIV_POS
-                                | 1 << EXT_XG_MDIO_CTRL_MCDIV_POS
-                                | MDIO_MIIM_CMD_IDLE << EXT_XG_MDIO_CTRL_MIIM_POS
-                                | 0x0 << EXT_XG_MDIO_CTRL_TA_POS
-                                | 0 << EXT_XG_MDIO_CTRL_OP_POS
-                                | EXT_XG_MDIO_CTRL_ST);
-
-
-        /* poll master busy bit until it is not busy */
-	WAIT_XGMAC_MDIO_BSY_CLEAR(node)
-	return 0;
-}
-
-/**********************************************************************
- *  nlm_hal_xgmac_mdio_indirect_read - Read xgmac phy register
- *
- *  Input parameters:
- *         bus          - bus number, nae has two external xgmac bus: 0 and 1
- *         phyaddr      - PHY's address
- *         regidx       - index of register to read
- *
- *  Return value:
- *         value read (16 bits), or 0xffffffff if an error occurred.
- ********************************************************************* */
-/**
-* @brief nlm_hal_xgmac_mdio_indirect_read reads an external PHY register.
-*
-* @param [in] node Node number
-* @param [in] bus External MDIO bus number
-* @param [in] block NAE Register Memory Map Block
-* @param [in] intf_type GMAC_0, GMAC_1, GMAC_2, GMAC_3, XGMAC, INTERLAKEN, PHY, LANE_CFG (only valid for block 7)
-* @param [in] phyaddr External PHY's address
-* @param [in] regidx PHY register index to read
-*
-* @return
-*	- value read (16 bits), or 0xffffffff if an error occurred.
-* 
 * @ingroup hal_nae
 *
 */
-int nlm_hal_xgmac_mdio_indirect_read(int node, int bus, int block, int intf_type, int phyaddr, int regidx)
-{
-        int32_t  i;
-        int16_t dev_type;
-
-        dev_type = 0x5;
-
-         /* first is indirect address cycle */
-        nlm_hal_xgmac_mdio_indirect_addr(node, bus, block, intf_type, phyaddr, regidx);
-
-        nlm_hal_write_mac_reg(node, 7, intf_type, EXT_XG0_MDIO_CTRL+ bus * 4,
-                                 phyaddr << EXT_XG_MDIO_CTRL_PHYADDR_POS
-                                | dev_type << EXT_XG_MDIO_CTRL_REG_POS
-                                | 0x9 << EXT_XG_MDIO_CTRL_XDIV_POS
-                                | 1 << EXT_XG_MDIO_CTRL_MCDIV_POS
-                                | EXT_XG_MDIO_CTRL_CMD_LOAD
-                                | MDIO_MIIM_CMD_10G_MMD << EXT_XG_MDIO_CTRL_MIIM_POS
-                                | EXT_XG_MDIO_CTRL_TA << EXT_XG_MDIO_CTRL_TA_POS
-                                | MDIO_CTRL_OP_READ_10G_MMD << EXT_XG_MDIO_CTRL_OP_POS
-                                | EXT_XG_MDIO_CTRL_ST);
-
-        /* poll master busy bit until it is not busy */
-	WAIT_XGMAC_MDIO_BSY_CLEAR(node)
-
-
-        nlm_hal_write_mac_reg(node, 7, intf_type, EXT_XG0_MDIO_CTRL+ bus * 4,
-                                 phyaddr << EXT_XG_MDIO_CTRL_PHYADDR_POS
-                                | dev_type << EXT_XG_MDIO_CTRL_REG_POS
-                                | 0x9 << EXT_XG_MDIO_CTRL_XDIV_POS
-                                | 1 << EXT_XG_MDIO_CTRL_MCDIV_POS
-                                | MDIO_MIIM_CMD_IDLE << EXT_XG_MDIO_CTRL_MIIM_POS
-                                | 0x0 << EXT_XG_MDIO_CTRL_TA_POS
-                                | 0 << EXT_XG_MDIO_CTRL_OP_POS
-                                | EXT_XG_MDIO_CTRL_ST);
-
-
-        /* poll master busy bit until it is not busy */
-	WAIT_XGMAC_MDIO_BSY_CLEAR(node)
-
-	return nlm_hal_read_mac_reg(node, 7, intf_type,
-                                EXT_XG0_MDIO_RD_STAT + bus * 4) & 0xFFFF;
-
-}
-
-#ifdef CONFIG_N511
-// MPS - Pete Create adequate 10ge phy utils from the above examples
-static int nlm_hal_xgmac_mdio_addr(int node, int bus,int block, int intf_type,
+static int nlm_hal_xgmac_mdio_addr(int node, int bus,
         int phyaddr, int dev_addr, int regidx)
 {
+	uint32_t block     = BLOCK_7;
+	uint32_t intf_type = LANE_CFG;
         int32_t i;
 
         /* load  XGMC_MDIO_CTRL_DATA register with addr */
-        nlm_hal_write_mac_reg( node, 7 , intf_type,
+        nlm_hal_write_mac_reg( node, block , intf_type,
                                 EXT_XG0_MDIO_CTRL_DATA + (bus * 4), regidx);
 
-        nlm_hal_write_mac_reg( node, 7, intf_type, EXT_XG0_MDIO_CTRL+ bus * 4,
+        nlm_hal_write_mac_reg( node, block, intf_type, EXT_XG0_MDIO_CTRL+ bus * 4,
                                  phyaddr << EXT_XG_MDIO_CTRL_PHYADDR_POS
                                 | dev_addr << EXT_XG_MDIO_CTRL_REG_POS
-                                | 0x9 << EXT_XG_MDIO_CTRL_XDIV_POS
-                                | 1 << EXT_XG_MDIO_CTRL_MCDIV_POS
+				| nae_get_EXT_XG_MDIO_DIV()
                                 | EXT_XG_MDIO_CTRL_CMD_LOAD
                                 | MDIO_MIIM_CMD_10G_MMD << EXT_XG_MDIO_CTRL_MIIM_POS
                                 | EXT_XG_MDIO_CTRL_TA << EXT_XG_MDIO_CTRL_TA_POS
@@ -3575,11 +3496,10 @@ static int nlm_hal_xgmac_mdio_addr(int node, int bus,int block, int intf_type,
         /* poll master busy bit until it is not busy */
         WAIT_XGMAC_MDIO_BSY_CLEAR(node)
 
-        nlm_hal_write_mac_reg( node, 7, intf_type, EXT_XG0_MDIO_CTRL + (bus * 4),
+        nlm_hal_write_mac_reg( node, block, intf_type, EXT_XG0_MDIO_CTRL + (bus * 4),
                                  phyaddr << EXT_XG_MDIO_CTRL_PHYADDR_POS
                                 | dev_addr << EXT_XG_MDIO_CTRL_REG_POS
-                                | 0x9 << EXT_XG_MDIO_CTRL_XDIV_POS
-                                | 1 << EXT_XG_MDIO_CTRL_MCDIV_POS
+				| nae_get_EXT_XG_MDIO_DIV()
                                 | MDIO_MIIM_CMD_IDLE << EXT_XG_MDIO_CTRL_MIIM_POS
                                 | 0x0 << EXT_XG_MDIO_CTRL_TA_POS
                                 | MDIO_CTRL_OP_INDIRECT_ADDR << EXT_XG_MDIO_CTRL_OP_POS
@@ -3591,23 +3511,23 @@ static int nlm_hal_xgmac_mdio_addr(int node, int bus,int block, int intf_type,
         return 0;
 }
 
-int nlm_hal_xgmac_mdio_write(int node, int bus, int block, int intf_type, int phyaddr,
-        int dev_addr, int regidx, uint16_t val)
+int nlm_hal_xgmac_mdio_write(int node, int bus,
+	int phyaddr, int dev_addr, int regidx, uint16_t val)
 {
+	uint32_t block     = BLOCK_7;
+	uint32_t intf_type = LANE_CFG;
         int32_t  i;
 
          /* first is indirect address cycle */
-        nlm_hal_xgmac_mdio_addr(0, bus, block, intf_type, phyaddr, dev_addr,
-                regidx);
+        nlm_hal_xgmac_mdio_addr(node, bus, phyaddr, dev_addr, regidx);
 
-        nlm_hal_write_mac_reg( node, 7 , intf_type,
+        nlm_hal_write_mac_reg( node, block, intf_type,
                                 EXT_XG0_MDIO_CTRL_DATA + (bus * 4), val);
 
-        nlm_hal_write_mac_reg( node, 7, intf_type, EXT_XG0_MDIO_CTRL+ bus * 4,
+        nlm_hal_write_mac_reg( node, block, intf_type, EXT_XG0_MDIO_CTRL+ bus * 4,
                                  phyaddr << EXT_XG_MDIO_CTRL_PHYADDR_POS
                                 | dev_addr << EXT_XG_MDIO_CTRL_REG_POS
-                                | 0x9 << EXT_XG_MDIO_CTRL_XDIV_POS
-                                | 1 << EXT_XG_MDIO_CTRL_MCDIV_POS
+				| nae_get_EXT_XG_MDIO_DIV()
                                 | EXT_XG_MDIO_CTRL_CMD_LOAD
                                 | MDIO_MIIM_CMD_10G_MMD << EXT_XG_MDIO_CTRL_MIIM_POS
                                 | EXT_XG_MDIO_CTRL_TA << EXT_XG_MDIO_CTRL_TA_POS
@@ -3617,11 +3537,10 @@ int nlm_hal_xgmac_mdio_write(int node, int bus, int block, int intf_type, int ph
         /* poll master busy bit until it is not busy */
         WAIT_XGMAC_MDIO_BSY_CLEAR(node)
 
-        nlm_hal_write_mac_reg( node, 7, intf_type, EXT_XG0_MDIO_CTRL + (bus * 4),
+        nlm_hal_write_mac_reg( node, block, intf_type, EXT_XG0_MDIO_CTRL + (bus * 4),
                                  phyaddr << EXT_XG_MDIO_CTRL_PHYADDR_POS
                                 | dev_addr << EXT_XG_MDIO_CTRL_REG_POS
-                                | 0x9 << EXT_XG_MDIO_CTRL_XDIV_POS
-                                | 1 << EXT_XG_MDIO_CTRL_MCDIV_POS
+				| nae_get_EXT_XG_MDIO_DIV()
                                 | MDIO_MIIM_CMD_IDLE << EXT_XG_MDIO_CTRL_MIIM_POS
                                 | 0x0 << EXT_XG_MDIO_CTRL_TA_POS
                                 | 0 << EXT_XG_MDIO_CTRL_OP_POS
@@ -3633,21 +3552,20 @@ int nlm_hal_xgmac_mdio_write(int node, int bus, int block, int intf_type, int ph
         return 0;
 }
 
-int nlm_hal_xgmac_mdio_read(int node, int bus, int block, int intf_type, int phyaddr,
-        int dev_addr, int regidx)
+int nlm_hal_xgmac_mdio_read(int node, int bus, int phyaddr, int dev_addr, int regidx)
 {
+	uint32_t block     = BLOCK_7;
+	uint32_t intf_type = LANE_CFG;
         int32_t  i;
         int rdval;
 
          /* first is indirect address cycle */
-        nlm_hal_xgmac_mdio_addr( node, bus, block, intf_type, phyaddr, dev_addr,
-                regidx);
+        nlm_hal_xgmac_mdio_addr( node, bus, phyaddr, dev_addr, regidx);
 
-        nlm_hal_write_mac_reg( node, 7, intf_type, EXT_XG0_MDIO_CTRL + (bus * 4),
+        nlm_hal_write_mac_reg( node, block, intf_type, EXT_XG0_MDIO_CTRL + (bus * 4),
                                  phyaddr << EXT_XG_MDIO_CTRL_PHYADDR_POS
                                 | dev_addr << EXT_XG_MDIO_CTRL_REG_POS
-                                | 0x9 << EXT_XG_MDIO_CTRL_XDIV_POS
-                                | 1 << EXT_XG_MDIO_CTRL_MCDIV_POS
+				| nae_get_EXT_XG_MDIO_DIV()
                                 | EXT_XG_MDIO_CTRL_CMD_LOAD
                                 | MDIO_MIIM_CMD_10G_MMD << EXT_XG_MDIO_CTRL_MIIM_POS
                                 | EXT_XG_MDIO_CTRL_TA << EXT_XG_MDIO_CTRL_TA_POS
@@ -3657,14 +3575,13 @@ int nlm_hal_xgmac_mdio_read(int node, int bus, int block, int intf_type, int phy
         /* poll master busy bit until it is not busy */
         WAIT_XGMAC_MDIO_BSY_CLEAR(node)
 
-        rdval =  nlm_hal_read_mac_reg(node, 7, intf_type, EXT_XG0_MDIO_RD_STAT +
+        rdval =  nlm_hal_read_mac_reg(node, block, intf_type, EXT_XG0_MDIO_RD_STAT +
                 (bus * 4)) & 0xFFFF;
 
-        nlm_hal_write_mac_reg( node, 7, intf_type, EXT_XG0_MDIO_CTRL + (bus * 4),
+        nlm_hal_write_mac_reg( node, block, intf_type, EXT_XG0_MDIO_CTRL + (bus * 4),
                                  phyaddr << EXT_XG_MDIO_CTRL_PHYADDR_POS
                                 | dev_addr << EXT_XG_MDIO_CTRL_REG_POS
-                                | 0x9 << EXT_XG_MDIO_CTRL_XDIV_POS
-                                | 1 << EXT_XG_MDIO_CTRL_MCDIV_POS
+				| nae_get_EXT_XG_MDIO_DIV()
                                 | MDIO_MIIM_CMD_IDLE << EXT_XG_MDIO_CTRL_MIIM_POS
                                 | 0x0 << EXT_XG_MDIO_CTRL_TA_POS
                                 | 0 << EXT_XG_MDIO_CTRL_OP_POS
@@ -3674,52 +3591,74 @@ int nlm_hal_xgmac_mdio_read(int node, int bus, int block, int intf_type, int phy
         /* poll master busy bit until it is not busy */
         WAIT_XGMAC_MDIO_BSY_CLEAR(node)
 
-        return rdval;
+        return rdval; /*SSONG: Check Me: read sequence changed */
 
 }
 
-#define WAIT_XGMAC_IMDIO_BSY_CLEAR(node)   for (i = 0; i < PHY_STATUS_RETRIES; i++) { \
-        if((nlm_hal_read_mac_reg(node, 7, intf_type,                                 \
-                INT_MDIO_RD_STAT) & EXT_XG_MDIO_STAT_MBSY) == 0)        \
-                        break;                                                  \
-        }
+int nlm_hal_c45_mdio_indirect_write_external(int node, int bus,
+	int phyaddr, int dev_addr, uint32_t reg_addr, uint32_t write_data)
+{
+	write_data &= 0xFFFF;
+	nlm_hal_xgmac_mdio_write(node, bus, phyaddr, dev_addr, MDIO_CTRL_OP_INDIRECT_ADDR, reg_addr);
+
+	nlm_hal_xgmac_mdio_write(node, bus, phyaddr, dev_addr, MDIO_CTRL_OP_WRITE_10G_MMD, write_data);
+
+	nlm_print("C45 MDIO w phy:%d dev:%d reg[%04X]=[%04X]\n", phyaddr, dev_addr, reg_addr, write_data);
+	return 0;
+}
 
-static int nlm_hal_xgmac_imdio_addr(int node, int block, int intf_type,
-        int phyaddr, int regidx)
+int nlm_hal_c45_mdio_indirect_read_external (int node, int bus,
+	int phyaddr, int dev_addr, uint32_t reg_addr)
 {
+	int rdval;
+
+	nlm_hal_xgmac_mdio_write(node, bus, phyaddr, dev_addr, MDIO_CTRL_OP_INDIRECT_ADDR, reg_addr);
+
+	nlm_hal_xgmac_mdio_write(node, bus, phyaddr, dev_addr, MDIO_CTRL_OP_POST_RDINC_ADDR, 0);
+
+        rdval =  nlm_hal_read_mac_reg(node, BLOCK_7, LANE_CFG, EXT_XG0_MDIO_RD_STAT + (bus * 4)) & 0xFFFF;
+
+	nlm_print("C45 MDIO r phy:%d dev:%d reg[%04X]=[%04X]\n", phyaddr, dev_addr, reg_addr, rdval);
+
+	return rdval;
+}
+
+
+static int nlm_hal_xgmac_imdio_addr(int node, int phyaddr, int regidx)
+{
+	uint32_t block     = BLOCK_7;
+	uint32_t intf_type = LANE_CFG;
         int32_t i;
         // internal xgmac pcs is always 5
         // phyadd 0x13,0x14, 0x15, 0x16
         int dev_addr = 5;
 
         /* load  XGMC_MDIO_CTRL_DATA register with addr */
-        nlm_hal_write_mac_reg( node, 7 , intf_type,
+        nlm_hal_write_mac_reg( node, block, intf_type,
                                 INT_MDIO_CTRL_DATA, regidx);
 
-        nlm_hal_write_mac_reg( node, 7, intf_type, INT_MDIO_CTRL,
-                                 phyaddr << EXT_XG_MDIO_CTRL_PHYADDR_POS
-                                | dev_addr << EXT_XG_MDIO_CTRL_REG_POS
-                                | 0x9 << EXT_XG_MDIO_CTRL_XDIV_POS
-                                | 1 << EXT_XG_MDIO_CTRL_MCDIV_POS
-                                | EXT_XG_MDIO_CTRL_CMD_LOAD
-                                | MDIO_MIIM_CMD_10G_MMD << EXT_XG_MDIO_CTRL_MIIM_POS
-                                | EXT_XG_MDIO_CTRL_TA << EXT_XG_MDIO_CTRL_TA_POS
-                                | MDIO_CTRL_OP_INDIRECT_ADDR << EXT_XG_MDIO_CTRL_OP_POS
-                                | EXT_XG_MDIO_CTRL_ST);
+        nlm_hal_write_mac_reg( node, block, intf_type, INT_MDIO_CTRL,
+                                 phyaddr << INT_MDIO_CTRL_PHYADDR_POS
+                                | dev_addr << INT_MDIO_CTRL_DEVTYPE_POS
+				| nae_get_INT_MDIO_DIV()
+                                | INT_MDIO_CTRL_CMD_LOAD
+                                | MDIO_MIIM_CMD_10G_MMD << INT_MDIO_CTRL_MIIM_POS
+                                | INT_MDIO_CTRL_TA << INT_MDIO_CTRL_TA_POS
+                                | MDIO_CTRL_OP_INDIRECT_ADDR << INT_MDIO_CTRL_OP_POS
+                                | INT_MDIO_CTRL_ST);
 
 
         /* poll master busy bit until it is not busy */
         WAIT_XGMAC_IMDIO_BSY_CLEAR(node);
 
-        nlm_hal_write_mac_reg( node, 7, intf_type, INT_MDIO_CTRL,
-                                 phyaddr << EXT_XG_MDIO_CTRL_PHYADDR_POS
-                                | dev_addr << EXT_XG_MDIO_CTRL_REG_POS
-                                | 0x9 << EXT_XG_MDIO_CTRL_XDIV_POS
-                                | 1 << EXT_XG_MDIO_CTRL_MCDIV_POS
-                                | MDIO_MIIM_CMD_IDLE << EXT_XG_MDIO_CTRL_MIIM_POS
-                                | 0x0 << EXT_XG_MDIO_CTRL_TA_POS
-                                | MDIO_CTRL_OP_INDIRECT_ADDR << EXT_XG_MDIO_CTRL_OP_POS
-                                | EXT_XG_MDIO_CTRL_ST);
+        nlm_hal_write_mac_reg( node, block, intf_type, INT_MDIO_CTRL,
+                                 phyaddr << INT_MDIO_CTRL_PHYADDR_POS
+                                | dev_addr << INT_MDIO_CTRL_DEVTYPE_POS
+				| nae_get_INT_MDIO_DIV()
+                                | MDIO_MIIM_CMD_IDLE << INT_MDIO_CTRL_MIIM_POS
+                                | 0x0 << INT_MDIO_CTRL_TA_POS
+                                | MDIO_CTRL_OP_INDIRECT_ADDR << INT_MDIO_CTRL_OP_POS
+                                | INT_MDIO_CTRL_ST);
 
 
         /* poll master busy bit until it is not busy */
@@ -3727,43 +3666,42 @@ static int nlm_hal_xgmac_imdio_addr(int node, int block, int intf_type,
         return 0;
 }
 
-int nlm_hal_xgmac_imdio_write(int node, int block, int intf_type, int phyaddr,
-        int regidx, uint16_t val)
+int nlm_hal_xgmac_imdio_write(int node, int phyaddr, int regidx, uint16_t val)
 {
+	uint32_t block     = BLOCK_7;
+	uint32_t intf_type = LANE_CFG;
         int32_t  i;
         // internal xgmac pcs is always 5
         // phyadd 0x13,0x14, 0x15, 0x16
         int dev_addr = 5;
 
          /* first is indirect address cycle */
-        nlm_hal_xgmac_imdio_addr(node, block, intf_type, phyaddr, regidx);
+        nlm_hal_xgmac_imdio_addr(node, phyaddr, regidx);
 
         nlm_hal_write_mac_reg( node, block , intf_type,
                                 INT_MDIO_CTRL_DATA, val);
 
         nlm_hal_write_mac_reg( node, block, intf_type, INT_MDIO_CTRL,
-                                 phyaddr << EXT_XG_MDIO_CTRL_PHYADDR_POS
-                                | dev_addr << EXT_XG_MDIO_CTRL_REG_POS
-                                | 0x9 << EXT_XG_MDIO_CTRL_XDIV_POS
-                                | 1 << EXT_XG_MDIO_CTRL_MCDIV_POS
-                                | EXT_XG_MDIO_CTRL_CMD_LOAD
-                                | MDIO_MIIM_CMD_10G_MMD << EXT_XG_MDIO_CTRL_MIIM_POS
-                                | EXT_XG_MDIO_CTRL_TA << EXT_XG_MDIO_CTRL_TA_POS
-                                | MDIO_CTRL_OP_WRITE_10G_MMD << EXT_XG_MDIO_CTRL_OP_POS
-                                | EXT_XG_MDIO_CTRL_ST);
+                                 phyaddr << INT_MDIO_CTRL_PHYADDR_POS
+                                | dev_addr << INT_MDIO_CTRL_DEVTYPE_POS
+				| nae_get_INT_MDIO_DIV()
+                                | INT_MDIO_CTRL_CMD_LOAD
+                                | MDIO_MIIM_CMD_10G_MMD << INT_MDIO_CTRL_MIIM_POS
+                                | INT_MDIO_CTRL_TA << INT_MDIO_CTRL_TA_POS
+                                | MDIO_CTRL_OP_WRITE_10G_MMD << INT_MDIO_CTRL_OP_POS
+                                | INT_MDIO_CTRL_ST);
 
         /* poll master busy bit until it is not busy */
         WAIT_XGMAC_IMDIO_BSY_CLEAR(node);
 
         nlm_hal_write_mac_reg( node, block, intf_type, INT_MDIO_CTRL,
-                                 phyaddr << EXT_XG_MDIO_CTRL_PHYADDR_POS
-                                | dev_addr << EXT_XG_MDIO_CTRL_REG_POS
-                                | 0x9 << EXT_XG_MDIO_CTRL_XDIV_POS
-                                | 1 << EXT_XG_MDIO_CTRL_MCDIV_POS
-                                | MDIO_MIIM_CMD_IDLE << EXT_XG_MDIO_CTRL_MIIM_POS
-                                | 0x0 << EXT_XG_MDIO_CTRL_TA_POS
-                                | 0 << EXT_XG_MDIO_CTRL_OP_POS
-                                | EXT_XG_MDIO_CTRL_ST);
+                                 phyaddr << INT_MDIO_CTRL_PHYADDR_POS
+                                | dev_addr << INT_MDIO_CTRL_DEVTYPE_POS
+				| nae_get_INT_MDIO_DIV()
+                                | MDIO_MIIM_CMD_IDLE << INT_MDIO_CTRL_MIIM_POS
+                                | 0x0 << INT_MDIO_CTRL_TA_POS
+                                | 0 << INT_MDIO_CTRL_OP_POS
+                                | INT_MDIO_CTRL_ST);
 
 
         /* poll master busy bit until it is not busy */
@@ -3771,9 +3709,10 @@ int nlm_hal_xgmac_imdio_write(int node, int block, int intf_type, int phyaddr,
         return 0;
 }
 
-int nlm_hal_xgmac_imdio_read(int node, int block, int intf_type, int phyaddr,
-        int regidx)
+int nlm_hal_xgmac_imdio_read(int node, int phyaddr, int regidx)
 {
+	uint32_t block     = BLOCK_7;
+	uint32_t intf_type = LANE_CFG;
         int32_t  i;
         int rdval;
         // internal xgmac pcs is always 5
@@ -3781,18 +3720,17 @@ int nlm_hal_xgmac_imdio_read(int node, int block, int intf_type, int phyaddr,
         int dev_addr = 5;
 
          /* first is indirect address cycle */
-        nlm_hal_xgmac_imdio_addr(node, block, intf_type, phyaddr, regidx);
+        nlm_hal_xgmac_imdio_addr(node, phyaddr, regidx);
 
         nlm_hal_write_mac_reg( node, block, intf_type, INT_MDIO_CTRL,
-                                 phyaddr << EXT_XG_MDIO_CTRL_PHYADDR_POS
-                                | dev_addr << EXT_XG_MDIO_CTRL_REG_POS
-                                | 0x9 << EXT_XG_MDIO_CTRL_XDIV_POS
-                                | 1 << EXT_XG_MDIO_CTRL_MCDIV_POS
-                                | EXT_XG_MDIO_CTRL_CMD_LOAD
-                                | MDIO_MIIM_CMD_10G_MMD << EXT_XG_MDIO_CTRL_MIIM_POS
-                                | EXT_XG_MDIO_CTRL_TA << EXT_XG_MDIO_CTRL_TA_POS
-                                | MDIO_CTRL_OP_READ_10G_MMD << EXT_XG_MDIO_CTRL_OP_POS
-                                | EXT_XG_MDIO_CTRL_ST);
+                                 phyaddr << INT_MDIO_CTRL_PHYADDR_POS
+                                | dev_addr << INT_MDIO_CTRL_DEVTYPE_POS
+				| nae_get_INT_MDIO_DIV()
+                                | INT_MDIO_CTRL_CMD_LOAD
+                                | MDIO_MIIM_CMD_10G_MMD << INT_MDIO_CTRL_MIIM_POS
+                                | INT_MDIO_CTRL_TA << INT_MDIO_CTRL_TA_POS
+                                | MDIO_CTRL_OP_READ_10G_MMD << INT_MDIO_CTRL_OP_POS
+                                | INT_MDIO_CTRL_ST);
 
         /* poll master busy bit until it is not busy */
         WAIT_XGMAC_IMDIO_BSY_CLEAR(node);
@@ -3800,14 +3738,13 @@ int nlm_hal_xgmac_imdio_read(int node, int block, int intf_type, int phyaddr,
         rdval =  nlm_hal_read_mac_reg(node, block, intf_type, INT_MDIO_RD_STAT) & 0xFFFF;
 
         nlm_hal_write_mac_reg( node, block, intf_type, INT_MDIO_CTRL,
-                                 phyaddr << EXT_XG_MDIO_CTRL_PHYADDR_POS
-                                | dev_addr << EXT_XG_MDIO_CTRL_REG_POS
-                                | 0x9 << EXT_XG_MDIO_CTRL_XDIV_POS
-                                | 1 << EXT_XG_MDIO_CTRL_MCDIV_POS
-                                | MDIO_MIIM_CMD_IDLE << EXT_XG_MDIO_CTRL_MIIM_POS
-                                | 0x0 << EXT_XG_MDIO_CTRL_TA_POS
-                                | 0 << EXT_XG_MDIO_CTRL_OP_POS
-                                | EXT_XG_MDIO_CTRL_ST);
+                                 phyaddr << INT_MDIO_CTRL_PHYADDR_POS
+                                | dev_addr << INT_MDIO_CTRL_DEVTYPE_POS
+				| nae_get_INT_MDIO_DIV()
+                                | MDIO_MIIM_CMD_IDLE << INT_MDIO_CTRL_MIIM_POS
+                                | 0x0 << INT_MDIO_CTRL_TA_POS
+                                | 0 << INT_MDIO_CTRL_OP_POS
+                                | INT_MDIO_CTRL_ST);
 
 
         /* poll master busy bit until it is not busy */
@@ -3817,155 +3754,33 @@ int nlm_hal_xgmac_imdio_read(int node, int block, int intf_type, int phyaddr,
 
 }
 
-#endif /*CONFIG_N511*/
-
-
-/**********************************************************************
- *  nlm_hal_xgmac_mdio_indirect_reset- reset xaui block.
- *
- *  Input parameters:
- *         bus - bus number, nae has two external gmac bus: 0 and 1
- *
- *  Return value:
- *       none 
- ********************************************************************* */
-/**
-* @brief nlm_hal_xgmac_mdio_indirect_reset resets the XAUI block.
-*
-* @param [in] node Node number
-* @param [in] bus External MDIO bus number
-* @param [in] block NAE Register Memory Map Block
-* @param [in] intf_type GMAC_0, GMAC_1, GMAC_2, GMAC_3, XGMAC, INTERLAKEN, PHY, LANE_CFG (only valid for block 7)
-*
-* @return
-* 	- none
-* 
-* @ingroup hal_nae
-*
-*/
-void nlm_hal_xgmac_mdio_indirect_reset(int node, int bus, int block, int intf_type)
-{
-        int16_t phyaddr, data;
-
-	phyaddr = 0x14 + block;
-        data = XAUI_PHY_RST;
-        nlm_hal_xgmac_mdio_indirect_write(node, bus, block, intf_type, phyaddr, XAUI_PHY_CTRL_1, data);
-
-	data &= ~XAUI_PHY_RST;
-        nlm_hal_xgmac_mdio_indirect_write(node, bus, block, intf_type, phyaddr, XAUI_PHY_CTRL_1, data);
-}
-
 #ifdef CONFIG_N511
-//PRM PCS MMD reg offsets are impossible and NetLogic can't advise
-// This attempt did not seem to work right - Pete/MPS
-void nlm_xaui_pcs_mmd_init(void)
-{
-  uint32_t wval, rval;
-
-  rval = nlm_hal_read_mac_reg(0, 0, 4, 0x7f);
-  nlm_print("PreRead PCS MDD 0 0x%x\n", rval);
-  wval = (0x5 << 23) | (0x13 << 18);
-  nlm_hal_write_mac_reg(0, 0, 4, 0x7f, wval);
-  nlm_print("Write PCS MDD 0 0x%x\n", wval);
-
-  rval = nlm_hal_read_mac_reg(0, 1, 4, 0x7f);
-  nlm_print("PreRead PCS MDD 1 0x%x\n", rval);
-  wval = (0x5 << 23) | (0x14 << 18);
-  nlm_hal_write_mac_reg(0, 1, 4, 0x7f, wval);
-  nlm_print("Write PCS MDD 1 0x%x\n", wval);
-
-  rval = nlm_hal_read_mac_reg(0, 2, 4, 0x7f);
-  nlm_print("PreRead PCS MDD 2 0x%x\n", rval);
-  wval = (0x5 << 23) | (0x15 << 18);
-  nlm_hal_write_mac_reg(0, 2, 4, 0x7f, wval);
-  nlm_print("Write PCS MDD 2 0x%x\n", wval);
-
-  rval = nlm_hal_read_mac_reg(0, 3, 4, 0x7f);
-  nlm_print("PreRead PCS MDD 3 0x%x\n", rval);
-  wval = (0x5 << 23) | (0x16 << 18);
-  nlm_hal_write_mac_reg(0, 3, 4, 0x7f, wval);
-  nlm_print("Write PCS MDD 3 0x%x\n", wval);
-
-}
 
 // call for phy/ports 0 - 3
 void nlm_xaui_phy_write(int phyaddr, int devaddr, int regidx, uint16_t val)
 {
   int bus = 0;
-  int block = 7;
-  int intf_type = 0xf;
-
   if ((phyaddr >= 0x13) && (phyaddr <= 0x16)) {
-    // Internal phy
-    nlm_hal_xgmac_imdio_write(0, block, intf_type, phyaddr, regidx, val);
+    nlm_hal_xgmac_imdio_write(0, phyaddr, regidx, val);
   } else if (phyaddr > 1) {
     bus = 1;
   }
-  nlm_hal_xgmac_mdio_write(0, bus, block, intf_type, phyaddr, devaddr,
-        regidx, val);
+  nlm_hal_xgmac_mdio_write(0, bus, phyaddr, devaddr, regidx, val);
 }
 
 uint16_t nlm_xaui_phy_read(int phyaddr, int devaddr, int regidx)
 {
   int bus = 0;
-  int block = 7;
-  int intf_type = 0xf;
   uint16_t val;
 
-  if (phyaddr >= 0x13) {
-    // Internal phy
-
-#if 0 //PRM PCS MMD reg offsets are impossible and NetLogic can't advise
-// This attempt did not seem to work right - Pete/MPS
-    // check if PCS MMD regs have been set
-    uint32_t tval, wval;
-
-    tval = nlm_hal_read_mac_reg(0, 4, 0x7f);
-    if (tval != ((0x5 << 23) | (0x13 << 18))) {
-      nlm_print("ERROR: PCS MMD 0 not set for MDIO 0x%x\n", tval);
-      wval = (0x5 << 23) | (0x13 << 18);
-      nlm_hal_write_mac_reg(0, 4, 0x7f, wval);
-      nlm_print("Write PCS MDD 0 0x%x\n", wval);
-      nlm_xaui_pcs_mmd_init();
-    }
-    tval = nlm_hal_read_mac_reg(1, 4, 0x7f);
-    if (tval != ((0x5 << 23) | (0x14 << 18))) {
-      nlm_print("ERROR: PCS MMD 1 not set for MDIO 0x%x\n", tval);
-      wval = (0x5 << 23) | (0x14 << 18);
-      nlm_hal_write_mac_reg(1, 4, 0x7f, wval);
-      nlm_print("Write PCS MDD 1 0x%x\n", wval);
-    }
-    tval = nlm_hal_read_mac_reg(2, 4, 0x7f);
-    if (tval != ((0x5 << 23) | (0x15 << 18))) {
-      nlm_print("ERROR: PCS MMD 2 not set for MDIO 0x%x\n", tval);
-      wval = (0x5 << 23) | (0x15 << 18);
-      nlm_hal_write_mac_reg(2, 4, 0x7f, wval);
-      nlm_print("Write PCS MDD 2 0x%x\n", wval);
-    }
-    tval = nlm_hal_read_mac_reg(3, 4, 0x7f);
-    if (tval != ((0x5 << 23) | (0x16 << 18))) {
-      nlm_print("ERROR: PCS MMD 3 not set for MDIO 0x%x\n", tval);
-      wval = (0x5 << 23) | (0x16 << 18);
-      nlm_hal_write_mac_reg(3, 4, 0x7f, wval);
-      nlm_print("Write PCS MDD 3 0x%x\n", wval);
-    }
-#endif
-
-//#if 0 // Use ext x0 mdio
-    val = nlm_hal_xgmac_mdio_indirect_read(0, bus, block, intf_type, phyaddr,
-        regidx);
-    nlm_print("nlm_xaui_phy_read PCS phy with external mdio = 0x%x\n", val);
-//#else // use int mdio
-    val = nlm_hal_xgmac_imdio_read(0, block, intf_type, phyaddr, regidx);
+  if ((phyaddr >= 0x13) && (phyaddr <= 0x16)) {
+    val = nlm_hal_xgmac_imdio_read(0, phyaddr, regidx);
     nlm_print("nlm_xaui_phy_read PCS phy with internal mdio = 0x%x\n", val);
-//#endif
     return val;
-
   } else if (phyaddr > 1) {
     bus = 1;
   }
-  val = nlm_hal_xgmac_mdio_read(0, bus, block, intf_type, phyaddr, devaddr,
-        regidx);
+  val = nlm_hal_xgmac_mdio_read(0, bus, phyaddr, devaddr, regidx);
 
   return val;
 }
@@ -3975,53 +3790,76 @@ uint16_t nlm_xaui_phy_read(int phyaddr, int devaddr, int regidx)
 // MPS add, scan 10ge Phys
 void nlm_xaui_phy_scan(void)
 {
-  //static int init_done = 0;
   int bus, phyaddr, devid;
-  nlm_print("nlm_xaui_phy_scan, xlp_mac_base = 0x%llux\n", (u64)xlp_mac_base);
-
-  //nlm_xaui_pcs_mmd_init();
-
+  nlm_print("nlm_xaui_phy_scan, xlp_mac_base = 0x%llux\n", (unsigned long long)xlp_mac_base);
   bus=0;
   for (phyaddr=0; phyaddr<2; phyaddr++) {
-    devid = nlm_hal_xgmac_mdio_read(0, bus, 7, 0xf, phyaddr, 1, 0xC205);
+    devid = nlm_hal_xgmac_mdio_read(0, bus, phyaddr, 1, 0xC205);
     nlm_print("\t%d:%x: 0x%02x\n", bus, phyaddr, devid);
-#if 1
     nlm_nlp1042_init(phyaddr);
-#else
-    if (init_done == 0) {
-      nlm_nlp1042_init(phyaddr);
-    } else {
-      int regaddr;
-      for (regaddr=0; regaddr<0x10; regaddr++) {
-        devid = nlm_hal_xgmac_mdio_read(0, bus, 7, 0xf, phyaddr, 1, regaddr);
-        nlm_print("\t%d:%x: 1:%d 0x%02x\n", bus, phyaddr, regaddr, devid);
-      }
-    }
-#endif
   }
   bus=1;
   for (phyaddr=2; phyaddr<4; phyaddr++) {
-    devid = nlm_hal_xgmac_mdio_read(0, bus, 7, 0xf, phyaddr, 1, 0xC205);
+    devid = nlm_hal_xgmac_mdio_read(0, bus, phyaddr, 1, 0xC205);
     nlm_print("\t%d:%x: 0x%02x\n", bus, phyaddr, devid);
-#if 1
     nlm_nlp1042_init(phyaddr);
-#else
-    if (init_done == 0) {
-      nlm_nlp1042_init(phyaddr);
-    } else {
-      int regaddr;
-      for (regaddr=0; regaddr<32; regaddr++) {
-        devid = nlm_hal_xgmac_mdio_read(0, bus, 7, 0xf, phyaddr, 1, regaddr);
-        nlm_print("\t%d:%d: 1:%d 0x%02x\n", bus, phyaddr, regaddr, devid);
-      }
-    }
-#endif
   }
-  //init_done = 1;
 }
 
 #endif // CONFIG_N511
 
+#define CONFIG_RXAUI 1
+#ifdef  CONFIG_RXAUI
+#define NLM_C45_PRINTF nlm_print
+
+void nlm_hal_rxaui_nlp1042c2_rxaui_broadcom_init(int port)
+{
+	int i;
+	uint32_t data;
+	if(port==0) {
+		#include "NLP1042C2_RXAUI_Dune.h"
+	}
+	else {
+		#include "NLP1042C2_RXAUI_Dune_4.h"
+	}
+	data = NLM_C45_READ(0,0,0,1,0xc241);
+	nlm_print("RXAUI c45 rd 0xc241:%x \n", data);
+}
+
+void nlm_hal_rxaui_nlp1042c2_rxaui_marvell_init(int port)
+{
+	int i;
+	if(port==0) {
+		#include "NLP1042C2_RXAUI_Marvell.h"
+	}
+	else {
+		#include "NLP1042C2_RXAUI_Marvell_4.h"
+	}
+}
+
+void nlm_hal_rxaui_nlp1042c2_xaui_init(int port)
+{
+	int i;
+	if(port==0) {
+		#include "NLP1042C2_XAUI.h"
+	}
+	else {
+		#include "NLP1042C2_XAUI_4.h"
+	}
+}
+
+void nlm_hal_rxaui_nlp1042c2_init(int port, int rxaui_mode)
+{
+	nlm_print("NLP port:%d mode:%d\n", port, rxaui_mode);
+	if(rxaui_mode == NLM_NAE_RXAUI_MODE_MARVELL)
+		nlm_hal_rxaui_nlp1042c2_rxaui_marvell_init(port);
+	else if(rxaui_mode == NLM_NAE_RXAUI_MODE_BROADCOM)
+		nlm_hal_rxaui_nlp1042c2_rxaui_broadcom_init(port);
+	else
+		nlm_hal_rxaui_nlp1042c2_xaui_init(port);
+}
+
+#endif
 
 /**********************************************************************
  *  nae_config_lane_gmac 
@@ -4032,6 +3870,7 @@ void nlm_xaui_phy_scan(void)
 *
 * @param [in] node Node number
 * @param [in] xaui_cplx_mask XAUI complex mask (possible in XLP832: 0x0F)
+* @param [in] rxaui_en RXAUI enabled
 *
 * @return
 * 	- none
@@ -4039,11 +3878,12 @@ void nlm_xaui_phy_scan(void)
 * @ingroup hal_nae
 *
 */
-void nlm_hal_xaui_pcs_init(int node, int xaui_cplx_mask)
+void nlm_hal_xaui_pcs_init(int node, int xaui_cplx_mask, int rxaui_en)
 {
-	int block, lane_ctrl;
+	int block, lane_ctrl, lane_status;
 	int cplx_lane_enable = LM_XAUI | (LM_XAUI << 4) | (LM_XAUI << 8) | (LM_XAUI << 12);
 	int lane_enable = 0;
+	int phy_mode = (rxaui_en) ?  PHYMODE_RXAUI : PHYMODE_XAUI;
 
 	if (xaui_cplx_mask == 0) {
 		return;
@@ -4051,7 +3891,7 @@ void nlm_hal_xaui_pcs_init(int node, int xaui_cplx_mask)
 
 	/* write 0x2 to enable SGMII for all lane
 	 */
-	block = 7;
+	block = BLOCK_7;
 
 	if (xaui_cplx_mask & 0x3) { /* Complexes 0, 1 */
 		lane_enable = nlm_hal_read_mac_reg(node, block, LANE_CFG, LANE_CFG_CPLX_0_1);	
@@ -4086,17 +3926,21 @@ void nlm_hal_xaui_pcs_init(int node, int xaui_cplx_mask)
 		if ((xaui_cplx_mask & (1 << block)) == 0) {
 			continue;
 		}
-
 		for( lane_ctrl = PHY_LANE_0_CTRL; lane_ctrl <= PHY_LANE_3_CTRL; lane_ctrl++) {
-			if((is_nlm_xlp3xx()) || (is_nlm_xlp8xx_b0())){
-				xlp3xx_8xxb0_nae_lane_reset_txpll(node, block, lane_ctrl, PHYMODE_XAUI);
+
+			if(phy_mode == PHYMODE_RXAUI && (lane_ctrl%2))
+				continue;
+
+			if((is_nlm_xlp3xx()) || (is_nlm_xlp8xx_bx())){
+				xlp3xx_8xxb0_nae_lane_reset_txpll(node, block, lane_ctrl, phy_mode);
 			}
 			else{
-				xlp8xx_ax_nae_lane_reset_txpll(node, block, lane_ctrl, PHYMODE_XAUI);
+				xlp8xx_ax_nae_lane_reset_txpll(node, block, lane_ctrl, phy_mode);
 			}
 		}
 	}
 	NAE_DEBUG("%s all blocks & lanes out of TXPLL\n", __func__);
+
 	/* Wait for Rx & TX clock stable */
 	for( block = 0; block < 4; block++)
 	{
@@ -4104,21 +3948,25 @@ void nlm_hal_xaui_pcs_init(int node, int xaui_cplx_mask)
 			continue;
 		}
 
-		for( lane_ctrl = PHY_LANE_0_CTRL; lane_ctrl <= PHY_LANE_3_CTRL; lane_ctrl++) {
-			while ((nlm_hal_read_mac_reg(node, block, PHY, (lane_ctrl - 4)) & (LANE_TX_CLK)) != LANE_TX_CLK) {
-				/* Wait for TX and RX clock to be set */
+		for( lane_status = PHY_LANE_0_STATUS; lane_status <= PHY_LANE_3_STATUS; lane_status++) {
+
+			if(phy_mode == PHYMODE_RXAUI && (lane_status%2))
+				continue;
+
+			/* Wait for TX clock to be set */
+			while ((nlm_hal_read_mac_reg(node, block, PHY, lane_status) & (PHY_LANE_STAT_STCS)) != PHY_LANE_STAT_STCS) {
 			}
-			NAE_DEBUG("%s Blk%d lane%d got TX clock stable\n", __func__, block, lane_ctrl);
+			NAE_DEBUG("%s Blk%d lane%d got TX clock stable\n", __func__, block, lane_status);
 
-			while ((nlm_hal_read_mac_reg(node, block, PHY, (lane_ctrl - 4)) & (LANE_RX_CLK)) != LANE_RX_CLK) {
-				/* Wait for TX and RX clock to be set */
+			/* Wait for RX clock to be set */
+			while ((nlm_hal_read_mac_reg(node, block, PHY, lane_status) & (PHY_LANE_STAT_SRCS)) != PHY_LANE_STAT_SRCS) {
 			}
-			NAE_DEBUG("%s Blk%d lane%d got RX clock stable\n", __func__, block, lane_ctrl);
+			NAE_DEBUG("%s Blk%d lane%d got RX clock stable\n", __func__, block, lane_status);
 
-			while ((nlm_hal_read_mac_reg(node, block, PHY, (lane_ctrl - 4)) & (XAUI_LANE_FAULT)) != 0) {
+			while ((nlm_hal_read_mac_reg(node, block, PHY, lane_status) & (PHY_LANE_STAT_XLF)) != 0) {
 				/* Wait for XAUI Lane fault to be cleared */
 			}
-			NAE_DEBUG("%s Blk%d lane%d got lane fault cleared\n", __func__, block, lane_ctrl);
+			NAE_DEBUG("%s Blk%d lane%d got lane fault cleared\n", __func__, block, lane_status);
 		}
 
 	}
@@ -4144,10 +3992,12 @@ void nlm_hal_xaui_pcs_init(int node, int xaui_cplx_mask)
 * @ingroup hal_nae
 *
 */
-static void xlp_nae_config_xaui(int node, int block, int port, int vlan_pri_en)
+static void xlp_nae_config_xaui(int node, int block, int port, int vlan_pri_en,
+				int rxaui_scrambler, int mode)
 {
 	uint32_t val = 0;
-
+	int rxaui_en = ((mode == NLM_NAE_RXAUI_MODE_MARVELL) ||
+                        (mode == NLM_NAE_RXAUI_MODE_BROADCOM)) ? 1 : 0;
 	val = 	nlm_hal_read_mac_reg(node, block, XGMAC, XGMAC_CTL_REG1);
 	val &= ~(0x1 << 11); /* Reset xgmac soft reset(bit 11) xaui soft reset (bit 12) */
 	nlm_hal_write_mac_reg(node, block, XGMAC, XGMAC_CTL_REG1, val);
@@ -4173,6 +4023,24 @@ static void xlp_nae_config_xaui(int node, int block, int port, int vlan_pri_en)
 	val |= 1 << NETIOR_XGMAC_VLAN_DC_POS;
 	val |= 1 << NETIOR_XGMAC_STATS_EN_POS;
 
+	if (rxaui_en)
+		val |= 1 << NETIOR_XGMAC_RXAUI_EN_POS;
+	else
+		val &= ~(1 << NETIOR_XGMAC_RXAUI_EN_POS);
+
+	if (rxaui_en)
+	{
+		if(mode == NLM_NAE_RXAUI_MODE_MARVELL)
+			val &= ~(1 << NETIOR_XGMAC_RXAUI_DC_POS);
+		else if(mode == NLM_NAE_RXAUI_MODE_BROADCOM)
+			val |= 1 << NETIOR_XGMAC_RXAUI_DC_POS;
+
+		if(rxaui_scrambler)
+			val |= 1 << NETIOR_XGMAC_RXAUI_SCRAMBLER_POS;
+		else
+			val &= ~(1 << NETIOR_XGMAC_RXAUI_SCRAMBLER_POS);
+	}
+
 	if (vlan_pri_en) {
 		val |= 1 << NETIOR_XGMAC_TX_PFC_EN_POS; 
 		val |= 1 << NETIOR_XGMAC_RX_PFC_EN_POS; 
@@ -4203,9 +4071,7 @@ static void xlp_nae_config_xaui(int node, int block, int port, int vlan_pri_en)
 	val &= ~(0x1f << 10);  
 	val |= (15 << 10);  
 
-	nlm_hal_write_mac_reg(node, block, XGMAC, NETIOR_XGMAC_CTRL3, val);
-	NAE_DEBUG("%s XAUI Config Complete block %d swport %d \n", __func__,block, port);
-	return;
+	nlm_hal_write_mac_reg(node, block, XGMAC, NETIOR_XGMAC_CTRL3, val); NAE_DEBUG("%s XAUI Config Complete block %d swport %d \n", __func__,block, port); return;
 }
 
 int nlm_hal_set_xaui_framesize(int node, int block, uint32_t tx_size, uint32_t rx_size)
@@ -4223,6 +4089,30 @@ int nlm_hal_set_sgmii_framesize(int node, int block, int index, uint32_t size)
        return 0;
 }
 
+#if !defined(NLM_HAL_UBOOT) && defined(NLM_CORTINA_SUPPORT)
+int nlm_hal_set_ilk_framesize(int node, int block, int port, uint32_t size)
+{
+	return cortina_set_max_framesize(block * 4, port, size);
+}
+#else
+int nlm_hal_set_ilk_framesize(int node, int block, int port, uint32_t size)
+{
+	return 0;
+}
+#endif
+
+#ifdef NLM_HAL_LINUX_KERNEL 
+int nlm_hal_get_ilk_mac_stats(int node, int block, int port, void *data)
+{
+#ifdef NLM_CORTINA_SUPPORT
+	struct net_device_stats *stats = (struct net_device_stats *)data;	
+	return cortina_get_mac_stats(node, block * 4, port,(void *) stats);
+#else
+	return 0;
+#endif
+}	
+#endif
+
 /*
  *                   Interlaken Support
  *
@@ -4232,14 +4122,21 @@ static uint8_t nlm_hal_read_pma_reg(int node, int block, int lane_ctrl, uint8_t
 {
         volatile uint32_t serdes_val, regval;
 
-        regval = nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl);
-        regval &= 0xFFC00000;
-        nlm_hal_write_mac_reg(node, block, PHY, lane_ctrl,  regval
-                               | (serdes_reg << PHY_LANE_CTRL_ADDR_POS)
-                               | PHY_LANE_CTRL_CMD_READ
-                               | PHY_LANE_CTRL_CMD_START
-                               | PHY_LANE_CTRL_RST );
-        while (((serdes_val = nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl)) & PHY_LANE_CTRL_CMD_PENDING));
+	regval = nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl);
+	regval |= PHY_LANE_CTRL_RST;
+	regval |= PHY_LANE_CTRL_CMD_READ;
+	regval = (regval & 0xffff0000);
+	nlm_hal_write_mac_reg(node, block , PHY, lane_ctrl, regval
+			| (serdes_reg << PHY_LANE_CTRL_ADDR_POS));
+
+	while (((serdes_val = nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl)) & PHY_LANE_CTRL_CMD_PENDING));
+
+	regval |= PHY_LANE_CTRL_CMD_START;
+	nlm_hal_write_mac_reg(node, block , PHY, lane_ctrl, regval
+			| (serdes_reg << PHY_LANE_CTRL_ADDR_POS));
+
+	while (((serdes_val = nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl)) & PHY_LANE_CTRL_CMD_PENDING));
+
         return (serdes_val & 0xFF);
 }
 
@@ -4247,20 +4144,22 @@ static void nlm_hal_write_pma_reg(int node, int block, int lane_ctrl, uint8_t se
 {
         volatile uint32_t regval = 0;
 
+	regval = nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl);
+	regval |= PHY_LANE_CTRL_RST;
+	regval &= ~(PHY_LANE_CTRL_CMD_READ); 
+	regval = (regval & 0xffff0000) ;
+	nlm_hal_write_mac_reg(node, block , PHY, lane_ctrl, regval
+			| (serdes_reg << PHY_LANE_CTRL_ADDR_POS)
+			| (serdes_val << PHY_LANE_CTRL_DATA_POS));
 
-        regval = nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl);
-        regval &= 0xFFC00000;
-        nlm_hal_write_mac_reg(node, block , PHY, lane_ctrl, regval
-                                        | PHY_LANE_CTRL_CMD_START | PHY_LANE_CTRL_RST
-                                        | (serdes_reg << PHY_LANE_CTRL_ADDR_POS)
-                                        | (serdes_val << PHY_LANE_CTRL_DATA_POS));
+	while((nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl)) & PHY_LANE_CTRL_CMD_PENDING);
 
-        nlm_hal_write_mac_reg(node, block , PHY, lane_ctrl, regval
-                                        | PHY_LANE_CTRL_CMD_START | PHY_LANE_CTRL_RST
-                                        | (serdes_reg << PHY_LANE_CTRL_ADDR_POS)
-                                        | (serdes_val << PHY_LANE_CTRL_DATA_POS) );
+	regval |= PHY_LANE_CTRL_CMD_START;
+	nlm_hal_write_mac_reg(node, block , PHY, lane_ctrl, regval
+			| (serdes_reg << PHY_LANE_CTRL_ADDR_POS)
+			| (serdes_val << PHY_LANE_CTRL_DATA_POS));
 
-        while((nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl)) & PHY_LANE_CTRL_CMD_PENDING);
+	while((nlm_hal_read_mac_reg(node, block, PHY, lane_ctrl)) & PHY_LANE_CTRL_CMD_PENDING);
 }
 
 static void nlm_hal_set_PLL(int node, int block, int lane_ctrl, uint32_t F_val, uint32_t N_val, uint32_t M_val)
@@ -4299,6 +4198,7 @@ static void xlp8xx_ilk_reset_pll(int node, int ilk_block_base, int ilk_num_lanes
         volatile uint32_t phy_lane = PHY_LANE_CTRL_BPC_XAUI | PHY_LANE_CTRL_RST |
                                 PHY_LANE_CTRL_PWRDOWN | (PHYMODE_IL << PHY_LANE_CTRL_PHYMODE_POS);
         uint32_t block, lane, max_block, rext_sel=0;
+	int i;
 
         if (!((ilk_block_base == 0) || (ilk_block_base == 2)))
                 return;
@@ -4326,30 +4226,35 @@ static void xlp8xx_ilk_reset_pll(int node, int ilk_block_base, int ilk_num_lanes
                 nlm_hal_write_mac_reg(node, BLOCK_7, LANE_CFG, lane_cfg_reg, lane_config | ilk_lane_eable);
         }
  
-        if (is_nlm_xlp8xx_b0()) {
+        if (is_nlm_xlp8xx_bx()) {
                 for(block = ilk_block_base; block < max_block ; block++) {
                         for (lane = PHY_LANE_0_CTRL; lane <= PHY_LANE_3_CTRL; lane++) {
                                 if (lane != 4)
-                                        rext_sel = (1 << 23);
+                                        rext_sel = (1 << PHY_LANE_CTRL_REXSEL_POS);
                                 else
                                         rext_sel = 0;
-                                val = nlm_hal_read_mac_reg(node, block, PHY, lane);
-                                val |= 0x100000 | (PHYMODE_IL << PHY_LANE_CTRL_PHYMODE_POS) | PHY_LANE_CTRL_BPC_XAUI;
-                                val &= ~(0x20000);
+                                val = PHY_LANE_CTRL_RESET_PMA | (PHYMODE_IL << PHY_LANE_CTRL_PHYMODE_POS) | 
+						PHY_LANE_CTRL_BPC_XAUI | PHY_LANE_CTRL_PWRDOWN | rext_sel; 
+                                val &= ~(PHY_LANE_CTRL_RST);
                                 nlm_hal_write_mac_reg(node, block, PHY, lane,val);
+			}
+			
+			for (i=0; i< 0x100000; ++i);
 
+			for (lane = PHY_LANE_0_CTRL; lane <= PHY_LANE_3_CTRL; lane++) {
+				nlm_hal_set_PLL(node, block, lane, 0, 19, 0);
+			}
+
+			for (lane = PHY_LANE_0_CTRL; lane <= PHY_LANE_3_CTRL; lane++) { 
                                 val = nlm_hal_read_mac_reg(node, block, PHY, lane);
-                                val |= 0x40000000; /* Unset the reset (inverse logic) : Bit30: epcs reset */
+                                val |= PHY_LANE_CTRL_RST; /* Bit30: epcs reset */
                                 nlm_hal_write_mac_reg(node, block, PHY, lane,val);
-                                NAE_DEBUG(" After serdes  de-assertion PMA value=0x%x\n", nlm_hal_read_mac_reg(node, block, PHY, lane));
-         //                       nlm_hal_set_PLL(node, block, lane, 0, 19, 0);
-
-                                /* Clear the Power Down bit */
+                                NAE_DEBUG(" After serdes  de-assertion PMA value=0x%x\n", val);
+				/* Clear the Power Down bit */
                                 val = nlm_hal_read_mac_reg(node, block, PHY, lane);
-                                val &= ~( (1 << 29) | (0x7ffff));
-                                nlm_hal_write_mac_reg(node, block, PHY, lane, (rext_sel | val));
-
-                                NAE_DEBUG("Reset PLL done \n");
+                                val &= ~(PHY_LANE_CTRL_PWRDOWN  | (0x7ffff)) ;
+                                nlm_hal_write_mac_reg(node, block, PHY, lane,  val);
+				NAE_DEBUG("Reset PLL done \n");
                         }
                 }
         }
@@ -4406,7 +4311,7 @@ static void dump_interlaken_regs(int node, int blk)
 	nlm_print("Rxstats3 0x%x\n",nlm_hal_read_mac_reg(node, blk, INTERLAKEN, ILK_RX_STATUS3));
 }
 
-static void xlp_debug_interlaken(int blk)
+static void xlp_debug_interlaken(int node, int blk)
 {
 	uint32_t debug;
 	
@@ -4420,7 +4325,6 @@ static void xlp_debug_interlaken(int blk)
 		(1 << ILK_GEN_CTRL3_MCS1_POS) | (0 << ILK_GEN_CTRL3_MCS0_POS) |
 		(13 << ILK_GEN_CTRL3_SCS6_POS) | (11 << ILK_GEN_CTRL3_SCS7_POS);
 	nlm_hal_write_mac_reg(node, blk, INTERLAKEN, ILK_GENERAL_CTRL3, debug);
-	dump_interlaken_regs(node, blk);
 }
 #endif
 
@@ -4468,9 +4372,9 @@ static void xlp_nae_config_interlaken(int node, int blk,int port, int num_lanes)
         if (!((blk == 0) || (blk == 2)))
                 return;
 
-        NAE_DEBUG("interlaken blk %d num_lanes %d \n",blk, num_lanes);
-
-        nlm_hal_write_mac_reg(node, blk, INTERLAKEN, ILK_TX_META_CTRL, 0x00f700f7); //cortina
+        nlm_print("interlaken blk %d num_lanes %d \n",blk, num_lanes);
+        
+	nlm_hal_write_mac_reg(node, blk, INTERLAKEN, ILK_TX_META_CTRL, 0x00f700f7); //cortina
 
         // Configure number of lanes , IL registers
         if (num_lanes == 1) {
@@ -4486,10 +4390,9 @@ static void xlp_nae_config_interlaken(int node, int blk,int port, int num_lanes)
 
         rxctrl |= (ILK_BURST_MAX << ILK_RX_CTRL_BMAX_POS) ;
         txctrl |= (ILK_BURST_MAX << ILK_TX_CTRL_BMAX_POS) | (0x1 << ILK_TX_CTRL_CAL_LEN_POS) | ILK_TX_CTRL_TX_EN ;
-        if (1) {        // cortina
-                rxctrl |= ILK_RX_CTRL_PKT_MODE;
-                txctrl |= ILK_TX_CTRL_RATELIM_EN;
-        }
+        // Enable packet mode and ratelimit for cortina IL card
+        rxctrl |= ILK_RX_CTRL_PKT_MODE;
+        txctrl |= ILK_TX_CTRL_RATELIM_EN;
         nlm_hal_write_mac_reg(node, blk, INTERLAKEN, ILK_RX_CONTROL, rxctrl);
         nlm_hal_write_mac_reg(node, blk, INTERLAKEN, ILK_TX_CONTROL, txctrl);
 
@@ -4507,22 +4410,21 @@ static void xlp_nae_config_interlaken(int node, int blk,int port, int num_lanes)
                                 ILK_RX_CTRL_RST_CORE;
         nlm_hal_write_mac_reg(node, blk, INTERLAKEN, ILK_RX_CONTROL, rxctrl);
 
-        if (1) {                //cortina
-                nlm_hal_write_mac_reg(node, blk, INTERLAKEN, ILK_TX_META_CTRL, 0x07ff07ff);
-
-                genctrl = nlm_hal_read_mac_reg(node, blk, INTERLAKEN, ILK_GENERAL_CTRL1);
-                genctrl &= ~(0xF << 8) | 0x0F;
-                nlm_hal_write_mac_reg(node, blk, INTERLAKEN, ILK_GENERAL_CTRL1, genctrl);
+        nlm_hal_write_mac_reg(node, blk, INTERLAKEN, ILK_TX_META_CTRL, 0x07ff07ff);
 
-                txctrl = nlm_hal_read_mac_reg(node, blk, INTERLAKEN, ILK_TX_CONTROL);
-                txctrl &= ~(0xf << ILK_TX_CTRL_CAL_LEN_POS);
-                nlm_hal_write_mac_reg(node, blk, INTERLAKEN, ILK_TX_CONTROL, txctrl);
+        genctrl = nlm_hal_read_mac_reg(node, blk, INTERLAKEN, ILK_GENERAL_CTRL1);
+        genctrl &= ~(0xF << 8) | 0x0F;
+        nlm_hal_write_mac_reg(node, blk, INTERLAKEN, ILK_GENERAL_CTRL1, genctrl);
 
-                val = nlm_hal_read_mac_reg(node, blk, INTERLAKEN, ILK_TX_RATE_LIMIT);
-                val |= (0xfff << 12);
-                nlm_hal_write_mac_reg(node, blk, INTERLAKEN, ILK_TX_RATE_LIMIT, val);
-        }
+        txctrl = nlm_hal_read_mac_reg(node, blk, INTERLAKEN, ILK_TX_CONTROL);
+        //txctrl &= ~(0xf << ILK_TX_CTRL_CAL_LEN_POS);
+        txctrl |= (0xf << ILK_TX_CTRL_CAL_LEN_POS);
+        nlm_hal_write_mac_reg(node, blk, INTERLAKEN, ILK_TX_CONTROL, txctrl);
 
+        val = nlm_hal_read_mac_reg(node, blk, INTERLAKEN, ILK_TX_RATE_LIMIT);
+        val |= (0xfff << 12);
+        nlm_hal_write_mac_reg(node, blk, INTERLAKEN, ILK_TX_RATE_LIMIT, val);
+	
         val = nlm_hal_read_nae_reg(node, TX_SCHED_CTRL);
         val |= 1;
         nlm_hal_write_nae_reg(node, TX_SCHED_CTRL, val);
@@ -4531,20 +4433,22 @@ static void xlp_nae_config_interlaken(int node, int blk,int port, int num_lanes)
 
 int is_xlp_ilk_lanealigned(int node, int blk)
 {
-        int i = 0;
-        volatile uint32_t status = 0;
+        int i = 0, retval = 1;
+	volatile uint32_t status = 0;
 
         // check lanes are aligned
         do {
                 status = nlm_hal_read_mac_reg(node, blk, INTERLAKEN, ILK_RX_STATUS3);
-                if (++i > 10)
-                        break;
+    	        if (++i > 1000) {
+			retval = 0;
+			break;	
+		}
         }while(!(status & ILK_RX_STAT3_RXL_ALIGN));
 #ifdef INTERLAKEN_DEBUG
-        xlp_debug_interlaken(blk);
-        dump_interlaken_regs(blk);
+        xlp_debug_interlaken(node, blk);
+        dump_interlaken_regs(node, blk);
 #endif
-        return 1;
+        return retval;
 }
 
 /**
@@ -4561,7 +4465,7 @@ int is_xlp_ilk_lanealigned(int node, int blk)
 
 int nlm_hal_ilk_pcs_init(int node, uint32_t ilk_complex_map)
 {
-        int lane_ctrl;
+        int lane_status;
 	int block;
 	nlm_nae_config_ptr nae_cfg = nlm_node_cfg.nae_cfg[node];
 	
@@ -4587,17 +4491,16 @@ int nlm_hal_ilk_pcs_init(int node, uint32_t ilk_complex_map)
 			continue;
 		}
                 /* Wait for Rx & TX clock stable */
-                for( lane_ctrl = PHY_LANE_0_CTRL; lane_ctrl <= PHY_LANE_3_CTRL; lane_ctrl++) {
-                        while ((nlm_hal_read_mac_reg(node, block, PHY, (lane_ctrl - 4)) & (LANE_TX_CLK)) != LANE_TX_CLK) {
-                                /* Wait for TX and RX clock to be set */
+		for( lane_status = PHY_LANE_0_STATUS; lane_status <= PHY_LANE_3_STATUS; lane_status++) {
+			/* Wait for TX clock to be set */
+			while ((nlm_hal_read_mac_reg(node, block, PHY, lane_status) & (PHY_LANE_STAT_STCS)) != PHY_LANE_STAT_STCS) {
                         }
-                        nlm_print("%s Blk%d lane%d got TX clock stable\n", __func__, block, lane_ctrl);
+                        nlm_print("%s Blk%d lane%d got TX clock stable\n", __func__, block, lane_status);
 
-                        while ((nlm_hal_read_mac_reg(node, block, PHY, (lane_ctrl - 4)) & (LANE_RX_CLK)) != LANE_RX_CLK) {
-                                /* Wait for TX and RX clock to be set */
+			/* Wait for RX clock to be set */
+			while ((nlm_hal_read_mac_reg(node, block, PHY, lane_status) & (PHY_LANE_STAT_SRCS)) != PHY_LANE_STAT_SRCS) {
                         }
-                        nlm_print("%s Blk%d lane%d got RX clock stable\n", __func__, block, lane_ctrl);
-
+                        nlm_print("%s Blk%d lane%d got RX clock stable\n", __func__, block, lane_status);
                 }
 		if (nae_cfg->num_lanes[block/2] <= 4)
 			block++;
@@ -4764,7 +4667,7 @@ static void init_egress(int node)
 {
 	uint32_t tx_cfg =  nlm_hal_read_nae_reg(node, TX_CONFIG);
 
-	if ((is_nlm_xlp3xx()) || (is_nlm_xlp8xx_b0())) {
+	if ((is_nlm_xlp3xx()) || (is_nlm_xlp8xx_bx())) {
 		nlm_hal_write_nae_reg(node, TX_CONFIG, tx_cfg | NAE_TX_ENABLE | NAE_TX_ACE  | NAE_TX_COMPATIBLE | (1 << 3));
 	}
 	else {
@@ -4799,12 +4702,14 @@ int nlm_hal_open_if(int node, int type, int inf)
 	int hw_portid ;
 #endif
 
-	nlm_print("%s: %d node %d ",__func__,inf, node);
+	NAE_DEBUG("%s: %d node %d ",__func__,inf, node);
 	// Init Netior ... Need to fixed
 	init_netior(node, type);
 
+	NAE_DEBUG("type:%d\n", type);
 	switch(type) {
 		case XAUI_IF:
+		case RXAUI_IF:
 			// inf is a complex number
 			netwk_inf = nlm_hal_read_mac_reg(node, inf, XGMAC, NETIOR_XGMAC_CTRL1);
 			netwk_inf |= (1 << NETIOR_XGMAC_STATS_CLR_POS);
@@ -4864,13 +4769,14 @@ int nlm_hal_open_if(int node, int type, int inf)
 			// Clear speed debug bit
 		        netior_ctrl3 = read_gmac_reg(node, inf, NETWK_INF_CTRL3_REG);
 		        write_gmac_reg(node, inf, NETWK_INF_CTRL3_REG, netior_ctrl3 & (~(1<<6)));
-			nlm_print("CLEARING speed bit =0x%x\n", read_gmac_reg(node, inf, NETWK_INF_CTRL3_REG));
+			//nlm_print("CLEARING speed bit =0x%x\n", read_gmac_reg(node, inf, NETWK_INF_CTRL3_REG));
 
 #if !defined(XLP_SIM) || defined(NLM_BOARD)
 			register_phy(node, inf, &hw_portid);
 			if(hw_portid<0)	
 				goto init_inf;
 			// init external phy, bypass SGMII auto negotiation
+			NAE_DEBUG("init ext phy:%d\n", inf);
 			nlm_hal_init_ext_phy(node, inf);
 #endif
 			// Configure speed and mode
@@ -4886,7 +4792,6 @@ init_inf:
 
 	nlm_hal_init_ingress (node, 0);
 	init_egress(node);
-	init_ucore(node, inf);
 
 	return 0;
 }
@@ -4927,6 +4832,7 @@ void nlm_hal_mac_disable(int node, int inf, int type)
               		write_gmac_reg(node, inf ,NETWK_INF_CTRL_REG, netwk_inf &  (~(TX_EN(1))));
 			break;
 		case XAUI_IF:
+		case RXAUI_IF:
 			xaui_cfg=nlm_hal_read_mac_reg(node, inf, XGMAC, XAUI_CONFIG_1);
 			nlm_hal_write_mac_reg(node, inf, XGMAC, XAUI_CONFIG_1, xaui_cfg &
                                                         (~(XAUI_CONFIG_TFEN | XAUI_CONFIG_RFEN)));
@@ -4956,11 +4862,13 @@ void nlm_hal_mac_enable(int node, int inf, int type)
         switch(type) {
                 case SGMII_IF:
 			netwk_inf  = read_gmac_reg(node, inf, NETWK_INF_CTRL_REG);
-		        write_gmac_reg(node, inf , NETWK_INF_CTRL_REG, netwk_inf | TX_EN(1));
+		        write_gmac_reg(node, inf , NETWK_INF_CTRL_REG, 
+					netwk_inf | TX_EN(1)| STATS_EN(1));
         		mac_cfg1 = read_gmac_reg(node, inf, MAC_CONF1);
         		write_gmac_reg(node, inf , MAC_CONF1, mac_cfg1 | (0x5));
                         break;
                 case XAUI_IF:
+                case RXAUI_IF:
 			xaui_cfg=nlm_hal_read_mac_reg(node, inf, XGMAC, XAUI_CONFIG_1);
 	                nlm_hal_write_mac_reg(node, inf, XGMAC, XAUI_CONFIG_1, xaui_cfg |
 							XAUI_CONFIG_TFEN | XAUI_CONFIG_RFEN | XAUI_CONFIG_TCTLEN | XAUI_CONFIG_RCTLEN);                               
@@ -4995,160 +4903,272 @@ int nlm_hal_get_phy_status(int node, int inf, uint32_t *speed, uint32_t *duplex)
 }
 
 
-/*
- *  NAE Send
- */
-/**
-* @brief nae_tx_desc function is used to create an NAE Tx FMN message.
-*
-* @param [in] type P2D/P2P, EOP/NEOP
-* @param [in] rdex Read Exclusive
-* @param [in] fbid Virtual FreeBack ID
-* @param [in] len P2D: number of bytes in packet; P2P: number of bytes in descriptor list
-* @param [in] addr Physical address of P2D/P2P
-*
-* @return
-* 	- 64-bit FMN message
-* 
-* @ingroup hal_nae
-*
-*/
-static __inline__ uint64_t nae_tx_desc(unsigned int type,
-				       unsigned int rdex,
-				       unsigned int fbid,
-				       unsigned int len,
-				       uint64_t addr)
+static void get_dom_nae_property(void *fdt, int dom_id, char *ppty, unsigned int *val, int valsz)
 {
-	return ((uint64_t)(type & 0x3) << 62) |
-		((uint64_t)(rdex & 0x1) << 61) |
-		((uint64_t)(fbid & 0x7f) << 54) |
-		((uint64_t)(len & 0x3fff) << 40) |
-		addr;
+	char dom_node_str[32];
+	int nodeoffset;
+	unsigned int *pval;
+	int plen, i;
+
+
+	sprintf(dom_node_str, "/doms/dom@%d/nae", dom_id);
+	nodeoffset = fdt_path_offset(fdt, dom_node_str);
+	if(nodeoffset >= 0) {
+		pval = (unsigned int *)fdt_getprop(fdt, nodeoffset, ppty, &plen);
+		if(pval != NULL) {
+			if(plen > valsz)
+				plen = valsz;
+			for(i = 0; i < plen / sizeof(unsigned int); i++)
+				val[i] = fdt32_to_cpu(pval[i]);
+		}
+	}
 }
-
-/**
-* @brief nlm_hal_nae_send function is used to send a packet.
-*
-* @param [in] dest NAE egress FMN station ID to send to
-* @param [in] fbid Virtual FreeBack ID
-* @param [in] phys_addr Physical address of P2D/P2P
-* @param [in] len P2D: number of bytes in packet; P2P: number of bytes in descriptor list
-* @param [in] flags Flags. Not currently used
-*
-* @return
-* 	- 0 on success
-* 	- non-zero on send fail
-* 
-* @ingroup hal_nae
-*
-*/
-int nlm_hal_nae_send(int dest, int fbid, unsigned long long phys_addr, int len, unsigned int flags)
+/* Returns 1 if the domain is the nae owner, 
+ Returns 0 otherwise */
+static int get_dom_nae_node_ownership(void *fdt, int dom_id, int node, struct nlm_hal_nae_config *nae_cfg)
 {
-	/* TODO: Implement flags */
-	unsigned long long data[4];
+	unsigned int nae_owner[NLM_MAX_NODES];
+	int i;
+
+	for(i = 0; i < NLM_MAX_NODES; i++)
+		nae_owner[i] = 1; /* default is owned */	
 
-	data[0] = nae_tx_desc(P2D_NEOP, 0, fbid, 0, phys_addr);
-	data[1] = nae_tx_desc(P2D_EOP,
-			      0,
-			      NULL_VFBID,
-			      len ,
-			      phys_addr );
+	get_dom_nae_property(fdt, dom_id, "owner", nae_owner, sizeof(nae_owner));
 
-	return nlm_hal_send_msg2(dest,
-				 0,
-				 data[0],
-				 data[1]);
+	//nlm_print("nae ownder for node %d is %d \n", node, nae_owner[node]);
+	nae_cfg->owned  = nae_owner[node];
+	return nae_owner[node];
 }
 
-/*
- * Nae recv
- */
-/**
-* @brief nlm_hal_soc_recv function is used to receive a packet.
-*
-* @param [in] dst_vc Local CPU VC to receive from
-* @param [out] intf Interface number packet was received on
-* @param [out] phys_addr Physical address of P2D/P2P
-* @param [out] flags Rx status flags
-*
-* @return
-* 	- 0 on success
-* 	- -1 no messages available
-* 	- -2 message available but load failed
-* 
-* @ingroup hal
-*
-*/
-int nlm_hal_soc_recv(int dst_vc, unsigned int *intf, unsigned long long *phys_addr, unsigned int *flags)
+
+
+static void extract_dom_nae_node_freein_fifo_info(void *fdt, int dom_id, int node, struct nlm_hal_nae_config *nae_cfg)
 {
-	uint32_t size = 0, code = 0;
-	unsigned int rx_status = 0;
-	uint64_t data[4];
-	int len = 0;
+	char dom_node_str[128];
+	int i;
+	unsigned int freein_fifo_mask[NLM_MAX_NODES]; 
+	unsigned int freein_fifo_onchip_num_descs[MAX_NAE_FREEIN_DESCS_QUEUE];
+	unsigned int freein_fifo_spill_num_descs = 0;
+	unsigned int data[4];
+	int frin_total_queue = nlm_hal_get_frin_total_queue(node);
+
+	for (i=0; i<MAX_NAE_FREEIN_DESCS_QUEUE; i++)
+		freein_fifo_onchip_num_descs[i] = 0;
+
+	for(i = 0; i < NLM_MAX_NODES; i++) 
+		freein_fifo_mask[i] = (1 << frin_total_queue) - 1;/* Ownes all fifos by default*/
+
+	sprintf(dom_node_str, "/soc/nae@node-%d/freein-fifo-config", node);
+	copy_fdt_prop(fdt, dom_node_str, "freein-fifo-onchip-num-descs", PROP_CELL, 
+			freein_fifo_onchip_num_descs, 4*MAX_NAE_FREEIN_DESCS_QUEUE);
+	copy_fdt_prop(fdt, dom_node_str, "freein-fifo-spill-num-descs", PROP_CELL,
+			&freein_fifo_spill_num_descs, 4);
 
-	*flags = NAE_RECV_NONE;
+	nae_cfg->freein_fifo_spill_num_descs = freein_fifo_spill_num_descs;
+	
+	for (i=0; i<MAX_NAE_FREEIN_DESCS_QUEUE; i++) {
+		nae_cfg->freein_fifo_onchip_num_descs[i] = freein_fifo_onchip_num_descs[i];
+	}
 
-	if(nlm_hal_recv_msg2(dst_vc, (uint32_t *) intf, &size, &code, &data[0], &data[1])) {
+		get_dom_nae_property(fdt, dom_id, "freein-fifo-mask", freein_fifo_mask, sizeof(freein_fifo_mask));
+	
+	nae_cfg->freein_fifo_dom_mask = freein_fifo_mask[node];
 
-		rx_status = xlp_read_rx_status();
+	data[node]  = 0;
+	get_dom_nae_property(fdt, dom_id, "vfbtbl-sw-offset", data, sizeof(data));
+	nae_cfg->vfbtbl_sw_offset = data[node];
+	data[node]  = 0;
+	get_dom_nae_property(fdt, dom_id, "vfbtbl-sw-nentries", data, sizeof(data));
+	nae_cfg->vfbtbl_sw_nentries = data[node];
 
+	data[node]  = 0;
+	get_dom_nae_property(fdt, dom_id, "vfbtbl-hw-offset", data, sizeof(data));
+	nae_cfg->vfbtbl_hw_offset = data[node];
+	data[node]  = 0;
+	get_dom_nae_property(fdt, dom_id, "vfbtbl-hw-nentries", data, sizeof(data));
+	nae_cfg->vfbtbl_hw_nentries = data[node];
 
-		if (!((rx_status >> 28) & (1 << dst_vc))) {
-			return -1;
+	memset(data, 0, sizeof(data));
+	get_dom_nae_property(fdt, dom_id, "dummy-pktdata-addr", data, sizeof(data));
+
+	nae_cfg->dummy_pktdata_addr = ((unsigned long long)data[0] << 32) | data[1];
+
+}
+
+void nlm_hal_derive_cpu_to_freein_fifo_map(int node, 
+		unsigned int phys_cpu_map, 
+		unsigned int freein_fifo_mask, unsigned int *cpu_2_freein_fifo_map)
+{
+	int i=0, j =0, filled = 0, index = 0, pcpu, fifo;
+	unsigned char lcpu_2_pcpu[NLM_NCPUS_PER_NODE], pcpu_2_fifo[NLM_NCPUS_PER_NODE];
+	int frin_total_queue = nlm_hal_get_frin_total_queue(node);
+
+	if((phys_cpu_map == 0) || (freein_fifo_mask == 0))
+		return;
+	
+	memset(lcpu_2_pcpu, 0, sizeof(lcpu_2_pcpu));
+	memset(pcpu_2_fifo, 0, sizeof(pcpu_2_fifo));
+
+	while(i < NLM_NCPUS_PER_NODE){
+		for(j=0; j < NLM_NCPUS_PER_NODE && i < NLM_NCPUS_PER_NODE; j++){
+			if(!(phys_cpu_map & (1 << j)))
+				continue;
+			lcpu_2_pcpu[i] = j;
+			i++;
+		}
+	}
+	i = 0;
+	while(filled < NLM_NCPUS_PER_NODE) {
+		for(j = 0; j < frin_total_queue && filled < NLM_NCPUS_PER_NODE;) {
+			if(!(freein_fifo_mask & (1 << j))) {
+				j++;
+				continue;
+			}
+
+			pcpu = lcpu_2_pcpu[i];
+			if(pcpu_2_fifo[pcpu] & 0x80) {
+				fifo = pcpu_2_fifo[pcpu] & 0x1f;
+			} else {
+				fifo = j;
+				pcpu_2_fifo[pcpu] = 0x80 | fifo;
+				j++;
+			}
+			cpu_2_freein_fifo_map[i] = fifo;	
+			i += NLM_NUM_THREADS_PER_CORE;
+			if(i >= NLM_NCPUS_PER_NODE)
+				i = ++index;
+			filled++;
 		}
+	}
+}
 
-		return -2;
+static int prepare_nae_shared_info(void *fdt, int dom_id, int node, 
+		struct nlm_hal_nae_config *nae_cfg)
+{
+	char dom_node_str[128];
+	int nodeoffset;
+	unsigned int *pval;
+	int plen, i, j;
+	int pos, bitoff, max;
+	unsigned int map[NLM_MAX_NODES], fmask[NLM_MAX_NODES];
+	struct nlm_nae_shinfo shinfo;
+	static int shdomains[NLM_NAE_MAX_SHARED_DOMS], shdom_extracted = 0;
+	int domid = dom_id, cnt = 0;
+	int frin_total_queue = nlm_hal_get_frin_total_queue(node);
+	unsigned int lcpu_2_pcpu[NLM_NCPUS_PER_NODE], cpu_2_fifo[NLM_NCPUS_PER_NODE];
+
+	if(!shdom_extracted) {
+		for(i = 0; i < NLM_NAE_MAX_SHARED_DOMS; i++)
+			shdomains[i] = -1;
+		get_dom_nae_property(fdt, dom_id, "sh-domains", (unsigned int *)shdomains, sizeof(shdomains));
+		shdom_extracted = 1;
 	}
 
-	if (size == 2 && dst_vc == 0) {
+		
+start_for_dom:
+	map[node] = 0;
+	for(i = 0; i < NLM_MAX_NODES; i++) 
+		fmask[i] = (1 << frin_total_queue) - 1;/* Ownes all fifos by default*/
 
-		/* Rx Packet
-		 */
-		*flags = NAE_RECV_RX;
-		*phys_addr = (data[1]) & 0xffffffffc0ULL;
-		len = (data[1] >> 40) & 0x3fff;
+	memset((char *)&shinfo, 0, sizeof(shinfo));
+	memset(lcpu_2_pcpu, 0, sizeof(lcpu_2_pcpu));
+	
+	sprintf(dom_node_str, "/doms/dom@%d/cpu", domid);
+	nodeoffset = fdt_path_offset(fdt, dom_node_str);
+	if(nodeoffset >= 0) {
+		pval = (unsigned int *)fdt_getprop(fdt, nodeoffset, "onlinemask", &plen);
+		if(pval != NULL) {
+			if(plen > sizeof(map))
+				plen = sizeof(map);
+			/* cpu mask is from msb to lsb, but we require in lsb to msb */
+			max = (plen / sizeof(unsigned int)) - 1;
+			for(i = 0; i < plen / sizeof(unsigned int); i++, max--)
+				map[i] = fdt32_to_cpu(pval[max]);
+		}
+		pval = (unsigned int *)fdt_getprop(fdt, nodeoffset, "nae-rx-vc", &plen);
+		if(pval)
+			shinfo.rxvc = fdt32_to_cpu(pval[0]);
+		else
+			goto err;
 	}
-	else if (size == 1 && dst_vc == 3) {
 
-		/* TxC Packet
-		 */
+	/* Extract free in fifo mask mask */
+		get_dom_nae_property(fdt, domid, "freein-fifo-mask", fmask, sizeof(fmask));
+
+#ifdef NAE_SH_INFO_DBG
+	nlm_print("%s domid %d node %d cpumask %x fmask %x\n", __FUNCTION__, domid, node,
+			map[node], fmask[node]);
+#endif
+
+	if(!(map[node] && fmask[node]))
+		goto err;
+
+	if(map[node]) {
+		i = 0;
+		while(i < NLM_NCPUS_PER_NODE){
+			for(j=0; j < NLM_NCPUS_PER_NODE && i < NLM_NCPUS_PER_NODE; j++){
+				if(!(map[node] & (1 << j)))
+					continue;
+				pos = i / NLM_NAE_SH_LCPU_TO_MAP_SZ;
+				bitoff = (i % NLM_NAE_SH_LCPU_TO_MAP_NVALS_PER_ENTRY) * 
+					NLM_NAE_SH_LCPU_TO_MAP_SNG_VAL_SZ;
+				shinfo.lcpu_2_pcpu_map[pos] |= (j << bitoff);
+				lcpu_2_pcpu[i] = j;
+				i++;
+			}
+		}
 
-		*flags = NAE_RECV_TXC;
-		*phys_addr = (data[0]);
-		len = 0;
+#ifdef NAE_SH_INFO_DBG
+		for(i = 0; i < NLM_NCPUS_PER_NODE; i++) {
+			pos = i / NLM_NAE_SH_LCPU_TO_MAP_SZ;
+			bitoff = (i % NLM_NAE_SH_LCPU_TO_MAP_NVALS_PER_ENTRY) * 
+				NLM_NAE_SH_LCPU_TO_MAP_SNG_VAL_SZ;
+			nlm_print("domid %d node %d lcpu %d pcpu %d (%d)\n", domid,
+					node, i, (shinfo.lcpu_2_pcpu_map[pos] >> bitoff) & 0x1f, lcpu_2_pcpu[i]);
+		}
+#endif
 	}
-	else {
 
-		*flags = NAE_RECV_UNKNOWN;
-		*phys_addr = 0;
-		len = 0;
+	/* We need to avoid usage same fifo in different cores if possible. Also the filling should 
+	be physical cpu id based, as the application knows only phys cpu id 
+	 */
+	if(fmask[node]) {
+		nlm_hal_derive_cpu_to_freein_fifo_map(node, map[node], fmask[node], cpu_2_fifo);
+		for(i = 0; i < NLM_NCPUS_PER_NODE; i++) {
+			pos = i / NLM_NAE_SH_LCPU_TO_MAP_SZ;
+			bitoff = (i % NLM_NAE_SH_LCPU_TO_MAP_NVALS_PER_ENTRY) * 
+				NLM_NAE_SH_LCPU_TO_MAP_SNG_VAL_SZ;
+			shinfo.cpu_2_freeinfifo_map[pos] |= (cpu_2_fifo[i] << bitoff);
+		}
+#ifdef NAE_SH_INFO_DBG
+		for(i = 0; i < NLM_NCPUS_PER_NODE; i++) {
+			pos = i / NLM_NAE_SH_LCPU_TO_MAP_SZ;
+			bitoff = (i % NLM_NAE_SH_LCPU_TO_MAP_NVALS_PER_ENTRY) * 
+				NLM_NAE_SH_LCPU_TO_MAP_SNG_VAL_SZ;
+			nlm_print("domid %d node %d lcpu %d rxfifo %d\n", domid, 
+					node, i, (shinfo.cpu_2_freeinfifo_map[pos] >> bitoff) & 0x1f);
+		}
+#endif
+
 	}
 
-	return len;
-}
+	shinfo.domid = domid;
+	shinfo.valid = 1;
+	memcpy((char *)&nae_cfg->shinfo[cnt], (char *)&shinfo, sizeof(shinfo));
+err:
 
-/**
-* @brief nlm_hal_nae_recv function is used to receive a packet.
-*
-* @param [in] rx_vc Local CPU VC to receive from
-* @param [out] phys_addr Physical address of P2D/P2P
-* @param [out] flags Rx status flags
-*
-* @return
-* 	- 0 on success
-* 	- -1 no messages available
-* 	- -2 message available but load failed
-* 
-* @ingroup hal_nae
-*
-*/
-int nlm_hal_nae_recv(int rx_vc, unsigned long long *phys_addr, unsigned int *flags)
-{
-	unsigned int intf;
-	return nlm_hal_soc_recv(rx_vc, &intf, phys_addr, flags);
+	while(cnt < NLM_NAE_MAX_SHARED_DOMS) {
+		if((domid = shdomains[cnt]) >= 0) 
+			break;
+		cnt++;
+	}
+	if(cnt < NLM_NAE_MAX_SHARED_DOMS)  {
+		cnt++;
+		goto start_for_dom;
+	}
+	return 0;
 }
 
-
 /**
 * @brief nlm_hal_init_nae function is the main function for initializing and configuring the NAE and POE, based on the configuration in FDT.
 *
@@ -5166,8 +5186,9 @@ int nlm_hal_init_nae(void *fdt, int dom_id)
 	int i = 0, max_ports = 0;
 	int context = 0, ctxsize = 0, offset=0;
 	uint32_t bar0;
-	int node;
+	int node, owned;
 	struct nlm_hal_nae_config *nae_cfg;
+	uint64_t base, size;
 
 	if (check_header(fdt)) {
 		nlm_print("Sanity check on FDT blob failed! Aborting\n");
@@ -5175,7 +5196,6 @@ int nlm_hal_init_nae(void *fdt, int dom_id)
 	}
 
 	nlm_print("number of nodes %d \n", nlm_node_cfg.num_nodes);
-
 	for (node= 0; node<nlm_node_cfg.num_nodes; node++) {
 		if (nlm_node_cfg.nae_cfg[node] == NULL) {
 			nlm_node_cfg.nae_cfg[node] = nlm_malloc(sizeof(struct nlm_hal_nae_config));
@@ -5185,13 +5205,17 @@ int nlm_hal_init_nae(void *fdt, int dom_id)
 				nlm_print("Memory allocation failed for nae_cfg \n");
 				return -1;
 			}
+			memset(nae_cfg, 0, sizeof(struct nlm_hal_nae_config));
 		}
 		else {
 			nae_cfg = nlm_node_cfg.nae_cfg[node];
+			base = nae_cfg->freein_spill_base;
+			size = nae_cfg->freein_spill_size;
+			memset(nae_cfg, 0, sizeof(struct nlm_hal_nae_config));
+			nae_cfg->freein_spill_base = base;
+			nae_cfg->freein_spill_size = size;
 		}
 
-		memset(nae_cfg, 0, sizeof(struct nlm_hal_nae_config));
-
 		cntx2port[node] = &nae_cfg->cntx2port[0];
 
 		bar0 = nlm_hal_read_32bit_reg(nlm_hal_get_dev_base(node, 0, XLP_NAE_DEVICE, XLP_NAE_FUNC), 0x4);
@@ -5209,40 +5233,53 @@ int nlm_hal_init_nae(void *fdt, int dom_id)
 			/* 18 is an invalid port */
 			nae_cfg->cntx2port[i] = 18;
 		}
+
+		owned = get_dom_nae_node_ownership(fdt, dom_id, node, nae_cfg);
+		extract_dom_nae_node_freein_fifo_info(fdt, dom_id, node, nae_cfg);
+		prepare_nae_shared_info(fdt, dom_id, node, nae_cfg);
 	
-		/* frin_fifo represents the 20 pools of free-in descriptor fifos */
-		//drain_nae_stray_packets(node);
-		drain_nae_frin_fifo_descs(node);
-		deflate_frin_fifo_carving(node);
+		if(owned) {
+			/* frin_fifo represents the 20 pools of free-in descriptor fifos */
+			//drain_nae_stray_packets(node);
+			drain_nae_frin_fifo_descs(node);
+			deflate_frin_fifo_carving(node);
 
 #if !defined(NLM_HAL_UBOOT)
 		/* For U-Boot, reset_nae clears all IO BARs
 		 * which messes up Flash/CPLD/GBU BARs etc
 		 */
-		reset_nae(node);
-		nae_cfg->flags |= NAE_RESET_DONE;
+			reset_nae(node);
+			nae_cfg->flags |= NAE_RESET_DONE;
+			reset_poe(node);
 #else
-		nae_reset_done = 1;
+			nae_reset_done[node] = 1;
 #endif
 
-		nlm_hal_write_32bit_reg(nlm_hal_get_dev_base(node, 0, XLP_NAE_DEVICE, XLP_NAE_FUNC), 0x4, bar0);
+			nlm_hal_write_32bit_reg(nlm_hal_get_dev_base(node, 0, XLP_NAE_DEVICE, XLP_NAE_FUNC), 0x4, bar0);
 
-		nlm_print("Configuring ucore...\n");
-		parse_ucore_config(fdt, node);
+			nlm_print("Configuring ucore...\n");
+			parse_ucore_config(fdt, node);
 
-	        nlm_print("Configuring CPU-NAE...\n");
+		        nlm_print("Configuring CPU-NAE...\n");
+		} else
+			nlm_print("Extracting CPU-NAE configuration...\n");
+		
+		
         	parse_fdt_cpu_config(fdt, dom_id, nae_cfg);
 
-		nlm_print("Configuring NAE...\n");
-		parse_fdt_nae_config(fdt, node, nae_cfg);
-
-		nlm_print("Configuring PoE...\n");
-		parse_poe_config(fdt, node);
-
-		nlm_print("NAE configuration done!\n");
+		if(owned) {
+			parse_fdt_nae_config(fdt, node, nae_cfg);
+#if defined(NLM_HAL_UBOOT)
+			if(nae_cfg->num_ports)
+#endif
+			{
+				nlm_print("Configuring PoE...\n");
+				parse_poe_config(fdt, node);
+				nlm_print("NAE configuration done!\n");
+			}
+		} else
+			parse_port_config(fdt, node, nae_cfg);  
 
-		nlm_print("Digest of FDT based NAE config: \n");
-		nlm_print("fb_vc = %d, rx_vc = %d\n", nae_cfg->fb_vc, nae_cfg->rx_vc);
 
 		max_ports = nae_cfg->num_ports;
 
@@ -5255,63 +5292,100 @@ int nlm_hal_init_nae(void *fdt, int dom_id)
 			if (!port->valid) continue;
 
 			ctxsize = nae_cfg->ports[i].num_channels;
-#if 0
-		/* Default NAE configuration uses hw_port_id as the context */
-		context = port->hw_port_id;
-		cntx2port[context] = i; /* logical port */
-#else
 #ifdef NLM_HAL_LINUX_KERNEL
                 	if (nae_cfg->ports[i].iftype == INTERLAKEN_IF) {
                         	nae_cfg->cntx2port[context] = i;
 	                        nae_cfg->ports[i].num_free_desc /= ctxsize;
         	                nae_cfg->ports[i].num_channels = 1;
+				nae_cfg->ports[i].ext_phy_addr = 0;		//cortina logical port id
                 	        txq = nae_cfg->ports[i].txq;
-                        	nlm_print("port %d freedesc %d txq %d rxq %d num_channel %d hw_port %d \n",
-                                        i, nae_cfg->ports[i].num_free_desc, nae_cfg->ports[i].txq, nae_cfg->ports[i].rxq, nae_cfg->ports[i].num_channels,
-                                        nae_cfg->ports[i].hw_port_id);
 
 	                        for(offset=1; offset < ctxsize; offset++) {
         	                        port_num = nae_cfg->num_ports;
                 	                nae_cfg->cntx2port[context + offset] = port_num;
                         	        memcpy(&nae_cfg->ports[port_num], &nae_cfg->ports[i], sizeof(struct nlm_hal_nae_port));
                                 	nae_cfg->ports[port_num].txq = ++txq;
+					nae_cfg->ports[port_num].ext_phy_addr = offset;
 	                                nae_cfg->num_ports++;
-        	                        nlm_print("port %d freedesc %d txq %d rxq %d num_channel %d hw_port %d \n",
-                                        port_num, nae_cfg->ports[port_num].num_free_desc, nae_cfg->ports[port_num].txq, nae_cfg->ports[port_num].rxq,
-                                        nae_cfg->ports[port_num].num_channels, nae_cfg->ports[port_num].hw_port_id);
                 	        }
 	                }
         	        else {
 #endif
 				for(offset=0; offset < ctxsize; offset++)
 				nae_cfg->cntx2port[context + offset] = i; /* logical port */
+				NAE_DEBUG("save ctx:%d port:%d\n", context+offset, i);
 #ifdef NLM_HAL_LINUX_KERNEL
         	        }
 #endif
-#endif
-
-			nlm_print("port@%d: valid = %d, mgmt = %d, num_free_desc = %d ctxt = %d\n"
-			       "\t txq[0] = %d, txq[1] = %d, rxq = %d, hw_port_id = %d\n", i,
-				  port->valid, port->mgmt, port->num_free_desc, context,
-			       port->txq, (port->txq + port->num_channels - 1), port->rxq, port->hw_port_id);
 	
 			context += ctxsize;
 	
 		}
 
-		nlm_print("FRIN desc carving after HAL initialization...\n");
-		print_frin_desc_carving(node);
+#ifdef INCLUDE_NAE_DEBUG
+#if defined(NLM_HAL_UBOOT)
+		if(max_ports)
+#endif
+		{
+			dump_nae_cfg_info(node, nae_cfg);
+			if(owned) {
+				nlm_print("FRIN desc carving after HAL init.\n");
+				print_frin_desc_carving(node);
+			}
+		}
+#endif
 	}
 	
 	return 0;
 }
 
+int nlm_hal_restart_ucore(int node, void *fdt)
+{
+	if (nlm_node_cfg.nae_cfg[node] == NULL)
+		return -1;
+	if(nlm_node_cfg.nae_cfg[node]->owned)
+		parse_ucore_config(fdt, node);
+	return 0;
+}
+
+void nlm_hal_modify_nae_ucore_sram_mem(int node, int ucoreid, unsigned int *data, int off, int words)
+{
+	int i;
+	unsigned int ucore_cfg = nlm_hal_read_nae_reg(node, RX_UCORE_CFG);	
+	/*set iram to 0*/
+	nlm_hal_write_nae_reg(node, RX_UCORE_CFG, ucore_cfg & ~(1<<7));
+	for (i = 0; i < words; ++i, off += 4) {
+		nlm_hal_write_ucode(node, ucoreid, off, data[i]);
+	}
+}
+
+void nlm_hal_read_nae_ucore_sram_mem(int node, int ucoreid, unsigned int *data, int off, int words)
+{
+	int i;
+	unsigned int ucore_cfg = nlm_hal_read_nae_reg(node, RX_UCORE_CFG);	
+	/*set iram to 0*/
+	nlm_hal_write_nae_reg(node, RX_UCORE_CFG, ucore_cfg & ~(1<<7));
+	for (i = 0; i < words; ++i, off += 4) {
+		data[i] = nlm_hal_read_ucode(node, ucoreid, off);
+	}
+}
+
+void nlm_hal_disable_xaui_flow_control(int node, int interface)
+{
+	unsigned int xaui_cfg;
+	xaui_cfg = nlm_hal_read_mac_reg(node, interface, XGMAC, XAUI_CONFIG_1);
+	xaui_cfg &= (~(XAUI_CONFIG_TCTLEN | XAUI_CONFIG_RCTLEN));
+	nlm_hal_write_mac_reg(node, interface, XGMAC, XAUI_CONFIG_1, xaui_cfg);
+}
 
 #ifdef NLM_HAL_LINUX_KERNEL
 #include <linux/types.h>
 #include <linux/module.h>
+EXPORT_SYMBOL(nlm_hal_get_ilk_mac_stats);
+EXPORT_SYMBOL(nlm_hal_set_ilk_framesize);
 EXPORT_SYMBOL(nlm_hal_set_xaui_framesize);
 EXPORT_SYMBOL(nlm_hal_set_sgmii_framesize);
+EXPORT_SYMBOL(nlm_hal_nae_drain_frin_fifo_descs);
 EXPORT_SYMBOL(nlm_hal_write_ucore_shared_mem);
 EXPORT_SYMBOL(nlm_hal_init_nae);
 EXPORT_SYMBOL(rely_on_firmware_config);
@@ -5321,14 +5395,22 @@ EXPORT_SYMBOL(nlm_enable_poe_statistics);
 EXPORT_SYMBOL(nlm_read_poe_statistics);
 EXPORT_SYMBOL(nlm_clear_poe_stats);
 EXPORT_SYMBOL(nlm_disable_poe_statistics);
-
 EXPORT_SYMBOL(nlm_hal_open_if);
 EXPORT_SYMBOL(nlm_hal_init_ingress);
 EXPORT_SYMBOL(nlm_hal_load_ucore);
 EXPORT_SYMBOL(nlm_hal_init_poe_distvec);
 EXPORT_SYMBOL(nlm_hal_get_phy_status);
+EXPORT_SYMBOL(nlm_hal_mdio_reset);
 EXPORT_SYMBOL(nlm_hal_mdio_read);
 EXPORT_SYMBOL(nlm_hal_mdio_write);
+EXPORT_SYMBOL(nlm_hal_mdio_rd);
+EXPORT_SYMBOL(nlm_hal_mdio_wr);
+EXPORT_SYMBOL(nlm_hal_c45_mdio_indirect_read_external);
+EXPORT_SYMBOL(nlm_hal_c45_mdio_indirect_write_external);
 EXPORT_SYMBOL(nlm_hal_mac_enable);
 EXPORT_SYMBOL(nlm_hal_mac_disable);
+EXPORT_SYMBOL(nlm_hal_restart_ucore);
+EXPORT_SYMBOL(nlm_hal_derive_cpu_to_freein_fifo_map);
+EXPORT_SYMBOL(nlm_hal_modify_nae_ucore_sram_mem);
+EXPORT_SYMBOL(nlm_hal_read_nae_ucore_sram_mem);
 #endif /* #ifdef NLM_HAL_LINUX_KERNEL */
-- 
1.7.0

