From aa2e4df0902e2dfa5beb721dc1710fcd68d82368 Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Fri, 16 Nov 2012 11:28:49 +0800
Subject: [PATCH 3/5] nlm_xlp_64_be: update CDE to SDK2.2.5

Update CDE to SDK2.2.5.

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/misc/nlm-cde/Makefile  |    2 +-
 drivers/misc/nlm-cde/cdetest.c |    7 +
 drivers/misc/nlm-cde/nlm_cde.c |  299 +++++++++++++++++++++++++++-------------
 drivers/misc/nlm-cde/nlm_cde.h |   19 ++-
 4 files changed, 222 insertions(+), 105 deletions(-)

diff --git a/drivers/misc/nlm-cde/Makefile b/drivers/misc/nlm-cde/Makefile
index a87152f..0e7793b 100644
--- a/drivers/misc/nlm-cde/Makefile
+++ b/drivers/misc/nlm-cde/Makefile
@@ -9,4 +9,4 @@
 EXTRA_CFLAGS := -DNLM_HAL_LINUX_KERNEL -Iarch/mips/include/asm/netlogic/hal
 EXTRA_CFLAGS += -Iarch/mips/netlogic/boot
 
-obj-m 		+= nlm_cde.o
+obj-$(CONFIG_XLP_CDE) 		+= nlm_cde.o
diff --git a/drivers/misc/nlm-cde/cdetest.c b/drivers/misc/nlm-cde/cdetest.c
index 064fd13..27e5b9b 100644
--- a/drivers/misc/nlm-cde/cdetest.c
+++ b/drivers/misc/nlm-cde/cdetest.c
@@ -29,6 +29,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #include <stdio.h>
 #include <string.h>
 #include <fcntl.h>
+#include <sys/mman.h>
 
 static int sleep_usec = 100;
 static int LEN = 1024 * 16;
@@ -104,6 +105,7 @@ int main(int argc, char *argv[])
         char buf[LEN];
 	char buf1[LEN];
         char buf2[LEN];
+	unsigned char *cde_mmap_mem = NULL;
 
 	int tfd = open(argv[1], O_RDONLY);
         int vfd = open("out.txt",O_WRONLY);
@@ -130,6 +132,11 @@ int main(int argc, char *argv[])
 	}
 //        test();
   //      return 0;
+#if 1
+       cde_mmap_mem = mmap (0, 2048, PROT_READ | PROT_WRITE, MAP_SHARED, dfd, 0);
+       if(cde_mmap_mem)
+               strcpy(cde_mmap_mem, "HelloWorld\n");
+#endif
 
         cde.compression_type = 1;
         cde.sof = 1;
diff --git a/drivers/misc/nlm-cde/nlm_cde.c b/drivers/misc/nlm-cde/nlm_cde.c
index 0ce3cc9..9ea6bee 100644
--- a/drivers/misc/nlm-cde/nlm_cde.c
+++ b/drivers/misc/nlm-cde/nlm_cde.c
@@ -61,8 +61,11 @@ int xlp_cde_ioctl(struct inode *inode, struct file *fptr, unsigned int type, uns
 ssize_t xlp_cde_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos);
 ssize_t xlp_cde_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos);
 static int xlp_cde_mmap(struct file * filp, struct vm_area_struct * vma);
-static unsigned char* cde_mem_start, *cde_input_mem, *cde_output_mem, *cde_inf_input_mem, *cde_inf_output_mem, *cde_inf_mem_start;
-static unsigned int cde_mem_size;
+static unsigned char* cde_mem_start = NULL, *cde_mem_start_1, *cde_mem_start_2, *cde_mem_start_3, *cde_mem_start_4, *cde_mem_start_5, *cde_input_mem, *cde_output_mem, *cde_inf_input_mem, *cde_inf_output_mem, *cde_inf_mem_start;
+static unsigned int cde_mem_size, cde_mem_size_1, cde_mem_size_2, cde_mem_size_3, cde_mem_size_4, cde_mem_size_5;
+//static void test(void);
+
+int num_cde_engine;
 
 struct nlm_cde_op
 {
@@ -79,7 +82,7 @@ volatile fr_page page_array[MAX_NUM_PAGES]    __attribute__((aligned(32)));
 volatile char *(page_array_tmp_data_array[MAX_NUM_PAGES])__attribute__((aligned(32)));
 
 //#define CDE_DEBUG 1
-//#ifdef CDE_DEBUG
+#ifdef CDE_DEBUG
 static void dump_buffer(unsigned char *buf, unsigned int len, unsigned char *msg)
 {
     int k = 0;
@@ -92,13 +95,13 @@ static void dump_buffer(unsigned char *buf, unsigned int len, unsigned char *msg
     }
     printk("\n");
 }
-//#endif
+#endif
 
 static void *
 get_cache_aligned_mem(size_t size)
 {
     void *addr, **tmp;
-    unsigned long loc;
+    uint64_t loc;
     addr = malloc(size + L3_CACHELINE_SIZE * 2);
 
     if (addr == NULL) {
@@ -106,7 +109,7 @@ get_cache_aligned_mem(size_t size)
 		"\n Malloc failed for cache aligned memory allocation");
 	return NULL;    //NLM_ERR_NO_MEM;
     }
-    loc = (unsigned long) addr;
+    loc = (uint64_t) addr;
     loc = (loc + L3_CACHELINE_SIZE - 1) & ~L3_CACHELINE_MASK;
 
     tmp = (void **) loc;
@@ -123,15 +126,15 @@ get_cache_aligned_mem(size_t size)
 static void
 free_cache_aligned_mem(void *addr)
 {
-    unsigned long loc;
+    uint64_t loc;
 
-    loc = (unsigned long) addr;
+    loc = (uint64_t) addr;
 
     loc -= 64;
 
     addr = (void *) loc;
 
-    addr = (void *) *(unsigned long *) addr;
+    addr = (void *) *(uint64_t*) addr;
 
     free(addr);
 }
@@ -165,7 +168,7 @@ static int config_cmp(void)
 #ifdef CDE_DEBUG
 	printk("config_cmp \n");
 #endif
-  for(i = 0; i < NUM_CDE_ENGINE; i++)
+  for(i = 0; i < num_cde_engine; i++)
   {
     unsigned int val = nlm_hal_read_cde_reg(CMP_REG_CTRL_REG(i));
 #ifdef CDE_DEBUG
@@ -175,8 +178,8 @@ static int config_cmp(void)
 #ifdef CDE_DEBUG
 	printk("config_cmp i = %d scratch_reg val = %x\n", i, val);
 #endif
-    nlm_hal_write_cde_reg(CMP_REG_CTRL_REG(i), ((0x0012 << 16) | CMP_PAGE_SIZE)); //16'h{CMP_PAGE_SIZE}
-    nlm_hal_write_cde_reg(CMP_REG_SCRATCH_PAGE(i), 0x801000); //16'h{CMP_PAGE_SIZE}
+    nlm_hal_write_cde_reg(CMP_REG_CTRL_REG(i), ((0x0012 << 16) | FD_CMP_PAGE_SIZE)); //16'h{CMP_PAGE_SIZE}
+    nlm_hal_write_cde_reg(CMP_REG_SCRATCH_PAGE(i), ((SCRATCH_SIZE/64 << 17) | (16 << 9)));
   }
   return 0;
 }
@@ -184,17 +187,15 @@ static int config_cmp(void)
 static int send_message(int stid, struct msgrng_msg *msg)
 {
   int ret = 0;
+  unsigned long __attribute__ ((unused)) mflags;
 
-	//printk("send_message = stid = %x msg = %llx\n",stid, msg->msg0);
 #ifdef CDE_DEBUG
 	printk("send_message = stid = %x msg = %llx\n",stid, msg->msg0);
 #endif
+  msgrng_access_enable(mflags);
   nlm_hal_cde_send_request(stid, msg->msg0);
-#if 0
-  msgrng_flags_save(mflags);
-  ret = message_send_retry(1, 0, stid, msg);
-  msgrng_flags_restore(mflags);
-#endif
+  msgrng_access_disable(mflags);
+
   return ret;
 }
 
@@ -209,18 +210,21 @@ static int send_free_desc(void)
   // send free descriptors to cmp block
   for (i = 0; i < NUM_FREE_DESCRIPTORS; i++) {
     if (!page_array[i].data_array)	  
-	page_array[i].data_array = get_cache_aligned_mem(CMP_PAGE_SIZE);
+	page_array[i].data_array = get_cache_aligned_mem(FD_CMP_PAGE_SIZE);
     if (!page_array[i].data_array)	{
-	    printk("cacheline_aligned_kmalloc returmed error\n");
+	    printk("cacheline_aligned_kmalloc returmed error desc_num = %d\n", i);
 	    return -1;
     }
 
-    stid = nlm_hal_cde_make_fd_msg((uint64_t*)&fd_msg.msg0, (unsigned long)virt_to_phys(page_array[i].data_array));
+    stid = nlm_hal_cde_make_fd_msg((uint64_t*)&fd_msg.msg0, (uint64_t)virt_to_phys(page_array[i].data_array));
 #ifdef CDE_DEBUG
     	printk("Free descriptor message [%0d] = 0x%016llx\n", i, fd_msg.msg0);
 #endif
 
-    status = send_message(MSGRNG_STNID_CMP1, &fd_msg);
+    if(is_nlm_xlp2xx())
+    	status = send_message(MSGRNG_2XX_STNID_CMP1, &fd_msg);
+    else
+      	status = send_message(MSGRNG_STNID_CMP1, &fd_msg);
 
     if (status != 0) {
       printk("[%s@%d]: Free descriptor (%d) didnt not reach cmpm status=%0d\n",
@@ -266,31 +270,29 @@ int create_inf_message(cmp_data_t *cmp_data, int type, int start_of_file, int en
   div = num_blk * num_desc;
 
   rtn_bkt = cde_get_fb_vc();
-  type = 3;
-  if(cmp_data->src_size > MAX_BUFFER_SIZE)
+  type = 1;
+  if(cmp_data->src_size > MAX_INPUT_BUFFER_SIZE)
   {
-	  printk("ERROR:src_size if more than %d. No space to store\n", MAX_BUFFER_SIZE);
+	  printk("ERROR:src_size = %d if more than %d. No space to store\n", (int)cmp_data->src_size, (int)MAX_INPUT_BUFFER_SIZE);
 	  return 0;
   }
-  num_desc = (cmp_data->src_size/PAGE_SIZE) + ((cmp_data->src_size %PAGE_SIZE)?1:0);
-
+  num_desc = (cmp_data->src_size/CMP_PAGE_SIZE) + ((cmp_data->src_size %CMP_PAGE_SIZE)?1:0);
   for (i = 0; i < num_messages; i++) {
     //create scratch page descriptor
     cur_desc = 0;
     restore = (start_of_file == 0);//((num_messages > 1) & (cur_blk != 0));
     length = SCRATCH_SIZE ;
     cmp_data->src_desc[desc_idx] =
-      cpu_to_be64(nlm_hal_cde_make_data_desc(0, 0, 0, 0, 0, restore, 0, length, (unsigned long)virt_to_phys(cmp_data->scratch_inf)));
+      cpu_to_be64(nlm_hal_cde_make_data_desc(0, 0, 0, 0, 0, restore, 0, length, (uint64_t)virt_to_phys(cmp_data->scratch_inf)));
 #ifdef CDE_DEBUG
       printk("scratch=0x%p, v2p=0x%lx, scratch_desc = 0x%016llx &scratch_desc=0x%p\n", 
 	     cmp_data->scratch_inf, virt_to_phys(cmp_data->scratch_inf), cmp_data->src_desc[desc_idx], &(cmp_data->src_desc[0])); 
 #endif
     cur_desc++;
 
-    for (j = 0; j < num_blk/num_messages; j++) {
+    for (j = 0; j < num_blk; j++) {
       for (k = 0; k < num_desc; k++) {
-	eof = 1;//end_of_file;
-//	eof = end_of_file;
+	eof = end_of_file;
 
 	sod = 1;//(start == 0);
 	sob = (k == 0);
@@ -298,10 +300,10 @@ int create_inf_message(cmp_data_t *cmp_data, int type, int start_of_file, int en
 	save = ((eob == 1) & (end_of_file == 0)); //((eof == 0) & (eob == 1));
 	restore = 0; //restore only can be 1 on scratch descriptor
 //save = 0;
-	length = ((cmp_data->src_size - start)> PAGE_SIZE)?PAGE_SIZE:(cmp_data->src_size - start); //dliao: assume div == 1
+	length = ((cmp_data->src_size - start)> CMP_PAGE_SIZE)?CMP_PAGE_SIZE:(cmp_data->src_size - start); //dliao: assume div == 1
 
 	cmp_data->src_desc[cur_desc] =
-	  cpu_to_be64(nlm_hal_cde_make_data_desc(eof, type, sod, sob, save, restore, eob, length, (unsigned long)virt_to_phys(cmp_data->src + start)));
+	  cpu_to_be64(nlm_hal_cde_make_data_desc(eof, type, sod, sob, save, restore, eob, length, (uint64_t)virt_to_phys(cmp_data->src + start)));
 //printk("data_desc_1 = %llx\n",cmp_data->src_desc[cur_desc]);
 
 #ifdef CDE_DEBUG
@@ -321,8 +323,7 @@ int create_inf_message(cmp_data_t *cmp_data, int type, int start_of_file, int en
     }
 
     stid = nlm_hal_cde_make_cmp_msg((uint64_t*)&cmp_msg[i].msg0, 0, cmp_data->op, rtn_bkt,
-			cur_desc, (unsigned long)virt_to_phys(cmp_data->src_desc + desc_idx));
-//printk("cmp_msg = %llx\n", cmp_msg[i].msg0);
+			cur_desc, (uint64_t)virt_to_phys(cmp_data->src_desc + desc_idx));
 #ifdef CDE_DEBUG
       printk("[%s@%d]: desc_idx=%d, &(src_desc[0])=0x%p, v2p=0x%lx, i=%d, cmp_msg.msg0 = 0x%016llx\n", __FUNCTION__, __LINE__, desc_idx, cmp_data->src_desc+0, virt_to_phys(cmp_data->src_desc+0),i, cmp_msg[i].msg0); 
 #endif
@@ -361,22 +362,20 @@ int create_message(cmp_data_t *cmp_data, int type, int start_of_file, int end_of
 
   rtn_bkt = cde_get_fb_vc();
 
-  if(cmp_data->src_size > MAX_BUFFER_SIZE)
+  if(cmp_data->src_size > MAX_INPUT_BUFFER_SIZE)
   {
-	  printk("ERROR:src_size if more than %d. No space to store\n", MAX_BUFFER_SIZE);
+	  printk("ERROR:src_size if more than %d. No space to store\n", MAX_INPUT_BUFFER_SIZE);
 	  return 0;
   }
-  num_desc = (cmp_data->src_size/PAGE_SIZE) + ((cmp_data->src_size %PAGE_SIZE)?1:0);
-
+  num_desc = (cmp_data->src_size/CMP_PAGE_SIZE) + ((cmp_data->src_size %CMP_PAGE_SIZE)?1:0);
   for (i = 0; i < num_messages; i++) {
     //create scratch page descriptor
     cur_desc = 0;
     restore = (start_of_file == 0);//((num_messages > 1) & (cur_blk != 0));
-//restore = 0;
     length = SCRATCH_SIZE ;
 
     cmp_data->src_desc[desc_idx] =
-      cpu_to_be64(nlm_hal_cde_make_data_desc(0, 0, 0, 0, 0, restore, 0, length, (unsigned long)virt_to_phys(cmp_data->scratch)));
+      cpu_to_be64(nlm_hal_cde_make_data_desc(0, 0, 0, 0, 0, restore, 0, length, (uint64_t)virt_to_phys(cmp_data->scratch)));
 
 #ifdef CDE_DEBUG
       printk("scratch=0x%p, v2p=0x%lx, scratch_desc = 0x%016llx &scratch_desc=0x%p\n", 
@@ -389,19 +388,19 @@ int create_message(cmp_data_t *cmp_data, int type, int start_of_file, int end_of
       for (k = 0; k < num_desc; k++) {
 	eof = end_of_file;
 
-	sod = (start == 0);
+	sod = 1;//(start == 0);
 	sob = (k == 0);
 	eob = (k == num_desc-1);
 	save = ((type == CDE_STATIC) & (eof == 0) & (eob == 1));
 	restore = 0; //restore only can be 1 on scratch descriptor
 
-	length = ((cmp_data->src_size - start)> PAGE_SIZE)?PAGE_SIZE:(cmp_data->src_size - start); //dliao: assume div == 1
+	length = ((cmp_data->src_size - start)> CMP_PAGE_SIZE)?CMP_PAGE_SIZE:(cmp_data->src_size - start); //dliao: assume div == 1
 	cmp_data->src_desc[cur_desc] =
-	  cpu_to_be64(nlm_hal_cde_make_data_desc(eof, type, sod, sob, save, restore, eob, length, (unsigned long)virt_to_phys(cmp_data->src + start)));
+	  cpu_to_be64(nlm_hal_cde_make_data_desc(eof, type, sod, sob, save, restore, eob, length, (uint64_t)virt_to_phys(cmp_data->src + start)));
 
 	if (type == CDE_DYNAMIC) {//for dynamic duplicate desc and set type to 3
 		save = ( (eob == 1) & (eof == 0)) ;
-		cmp_data->src_desc[cur_desc+num_desc] = cpu_to_be64(nlm_hal_cde_make_data_desc ( eof, 3, 1/*sod*/, sob, save, 0, eob, length, (unsigned long)virt_to_phys(cmp_data->src + start)));
+		cmp_data->src_desc[cur_desc+num_desc] = cpu_to_be64(nlm_hal_cde_make_data_desc ( eof, 3, 1/*sod*/, sob, save, 0, eob, length, (uint64_t)virt_to_phys(cmp_data->src + start)));
 #ifdef CDE_DEBUG
 	  printf("cur_desc = %0d, i = %0d, j = %0d, k = %0d, src_desc[%0d] = 0x%016llx \n", 
 		cur_desc, i, j, k, cur_desc+num_desc, (long long unsigned int)cmp_data->src_desc[cur_desc+num_desc]);
@@ -428,7 +427,7 @@ int create_message(cmp_data_t *cmp_data, int type, int start_of_file, int end_of
     }
 
     stid = nlm_hal_cde_make_cmp_msg((uint64_t*)&cmp_msg[i].msg0, 0, cmp_data->op, rtn_bkt,
-			cur_desc, (unsigned long)virt_to_phys(cmp_data->src_desc + desc_idx));
+			cur_desc, (uint64_t)virt_to_phys(cmp_data->src_desc + desc_idx));
 #ifdef CDE_DEBUG
     printk("[%s@%d]: desc_idx=%d, &(src_desc[0])=0x%p, v2p=0x%lx, i=%d, cmp_msg.msg0 = 0x%016llx\n",
 	 __FUNCTION__, __LINE__, desc_idx, cmp_data->src_desc+0, virt_to_phys(cmp_data->src_desc+0),i, cmp_msg[i].msg0); 
@@ -442,6 +441,7 @@ int create_message(cmp_data_t *cmp_data, int type, int start_of_file, int end_of
 }
 
 
+volatile uint64_t used_fd[NUM_FREE_DESCRIPTORS] __attribute__((aligned(32)));
 void return_free_descriptors(msg *msg_list, int msg_index)
 {
   int i, j, k, status, num_desc;
@@ -450,7 +450,6 @@ void return_free_descriptors(msg *msg_list, int msg_index)
   uint64_t dest_desc;
   int used_fd_index = 0;
 
-  volatile uint64_t used_fd[NUM_FREE_DESCRIPTORS] __attribute__((aligned(32)));
 
   for (i = 0; i < msg_index; i++) {
 
@@ -470,7 +469,10 @@ void return_free_descriptors(msg *msg_list, int msg_index)
     if (used_fd_index > FD_BURST_SIZE) {
       for (k = 0; k < used_fd_index; k++) {
 	fd_msg.msg0 = ((uint64_t) used_fd[k]);
-	status = send_message(MSGRNG_STNID_CMP1, &fd_msg);
+    	if(is_nlm_xlp2xx())
+    		status = send_message(MSGRNG_2XX_STNID_CMP1, &fd_msg);
+    	else
+		status = send_message(MSGRNG_STNID_CMP1, &fd_msg);
 	if (status != 0)
 	  printk("Return free descriptor didnt not reach cmp! status=%0d\n", status);
 	}
@@ -488,7 +490,6 @@ static int nlm_hal_cde_read_cmp_msg(char *buffer, uint64_t payload)
   uint64_t *desc, dest_addr;
   int num_desc = (payload >> 40) & 0x3fff;
   char * tmp_ptr;
-
   for (i = 0; i < num_desc; i++) {
     desc = phys_to_virt(payload & 0xffffffffffUll) + i*8; //64 byte descriptors //dliao: why i*8??
 
@@ -505,7 +506,8 @@ static int nlm_hal_cde_read_cmp_msg(char *buffer, uint64_t payload)
   return offset;
 }
 
-
+/* Due compiler warning it is declraed globally */
+struct msgrng_msg msg_list_g[MAX_NUM_MESSAGES]; 
 static void
 nlm_xlp_cde_msgring_handler(uint32_t vc, uint32_t src_id,
         uint32_t size, uint32_t code,
@@ -515,7 +517,6 @@ nlm_xlp_cde_msgring_handler(uint32_t vc, uint32_t src_id,
   struct msgrng_msg *msg, temp_msg;
   int last = 0; 
   int msg_index = 0; 
-  struct msgrng_msg msg_list[MAX_NUM_MESSAGES]; 
   int offset = cmp_data->target_size;
 
 #ifdef CDE_DEBUG
@@ -540,9 +541,9 @@ nlm_xlp_cde_msgring_handler(uint32_t vc, uint32_t src_id,
   dump_buffer((char *) (cmp_data->target + offset), cmp_data->target_size, "returned data:");
 #endif
 
-  memcpy((void *)&msg_list[msg_index++],(void *)msg, sizeof(struct msgrng_msg));
+  memcpy((void *)&msg_list_g[msg_index++],(void *)msg, sizeof(struct msgrng_msg));
 
-  return_free_descriptors(msg_list, msg_index); 
+  return_free_descriptors(msg_list_g, msg_index); 
 #ifdef CDE_DEBUG
   printk("[\n%s@%d]:end of phnx_msgring_comp_int_handler\n", __FUNCTION__, __LINE__);
 #endif
@@ -550,13 +551,12 @@ nlm_xlp_cde_msgring_handler(uint32_t vc, uint32_t src_id,
 
 cmp_data_t* nlm_cde_init()
 {
-  unsigned int size;
   cmp_data = (cmp_data_t *) kmalloc(sizeof(cmp_data_t), GFP_KERNEL);
   if (!cmp_data)
     return NULL;
   memset(cmp_data, 0, sizeof(cmp_data_t));
 
-  cmp_data->src = kmalloc(MAX_BUFFER_SIZE, GFP_KERNEL);
+  cmp_data->src = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(MAX_INPUT_BUFFER_SIZE));
   if (! cmp_data->src)	{
 	  printk("kmalloc returns Error : cmp_data->src\n");
 	  kfree(cmp_data);
@@ -564,14 +564,14 @@ cmp_data_t* nlm_cde_init()
 	  return NULL;
   }
 	  
-  cmp_data->target = kmalloc(MAX_BUFFER_SIZE, GFP_KERNEL);
+  cmp_data->target = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(MAX_BUFFER_SIZE));
   if (! cmp_data->target)	{
 	  printk("kmalloc returns Error : cmp_data->target\n");
 	  kfree(cmp_data->src);
 	  kfree(cmp_data);
 	  return NULL;
   }
-  cmp_data->src_desc = kmalloc(sizeof(unsigned long long) * CMP_PAGE_SIZE , GFP_KERNEL);
+  cmp_data->src_desc = kmalloc(CMP_PAGE_SIZE , GFP_KERNEL);
   if (! cmp_data->src_desc)	{
 	  printk("kmalloc returns Error : cmp_data->src_desc\n");
 	  kfree(cmp_data->src);
@@ -579,8 +579,8 @@ cmp_data_t* nlm_cde_init()
 	  kfree(cmp_data);
 	  return NULL;
   }
-  cmp_data->scratch = kmalloc(sizeof(unsigned long long) * SCRATCH_SIZE , GFP_KERNEL);
-  cmp_data->scratch_inf = kmalloc(sizeof(unsigned long long) * SCRATCH_SIZE , GFP_KERNEL);
+  cmp_data->scratch = kmalloc( SCRATCH_SIZE , GFP_KERNEL);
+  cmp_data->scratch_inf = kmalloc( SCRATCH_SIZE , GFP_KERNEL);
   if (! cmp_data->scratch || !cmp_data->scratch_inf)	{
 	  printk("kmalloc returns Error : cmp_data->scratch\n");
 	  kfree(cmp_data->src);
@@ -590,25 +590,51 @@ cmp_data_t* nlm_cde_init()
 	  return NULL;
   }
 
-  size = sizeof(struct nlm_cde_op) + 2 * sizeof(unsigned int) + MAX_BUFFER_SIZE * 2;/*struct cde + input size + output size + input buf + output buf */
-  cde_mem_start = kmalloc(size * 2, GFP_KERNEL);
-  cde_mem_size = size * 2;
-  if (!cde_mem_start)	
-	 printk("kmalloc returns Error : cde_mem_start\n");
- 
-  cde_input_mem = cde_mem_start + sizeof(struct nlm_cde_op) + 2 * sizeof(unsigned int);
-  cde_output_mem = cde_input_mem + MAX_BUFFER_SIZE;
-
-  cde_inf_mem_start = cde_output_mem + MAX_BUFFER_SIZE;
-  cde_inf_input_mem = cde_inf_mem_start + sizeof(struct nlm_cde_op) + 2 * sizeof(unsigned int);
-  cde_inf_output_mem = cde_inf_input_mem + MAX_BUFFER_SIZE;
-
-  memset(cde_mem_start, 0, size); 
-  memset(cmp_data->src, 0, MAX_BUFFER_SIZE);
+  cde_mem_size_1 = cde_mem_size_3 = MAX_INPUT_BUFFER_SIZE;
+  cde_mem_size_2 = cde_mem_size_4 = MAX_BUFFER_SIZE;
+  cde_mem_size_5 = (sizeof(struct nlm_cde_op) + 2 * sizeof(unsigned int)) * 2;
+  cde_mem_size = cde_mem_size_5 + cde_mem_size_1 + cde_mem_size_2 + cde_mem_size_3 + cde_mem_size_4;
+
+  if(cde_mem_size_5 < PAGE_SIZE) cde_mem_size_5 = PAGE_SIZE;
+
+  cde_input_mem = cde_mem_start_1 = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(cde_mem_size_1));
+  if(cde_mem_start_1 == NULL) 
+  {
+    printk("ERROR: __get_free_pages failed for %d\n",cde_mem_size_1);
+    return NULL;
+  }
+  cde_output_mem = cde_mem_start_2 = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(cde_mem_size_2));
+  if(cde_mem_start_2 == NULL) 
+  {
+    printk("ERROR: __get_free_pages failed for %d\n",cde_mem_size_2);
+    return NULL;
+  }
+  cde_inf_input_mem = cde_mem_start_3 = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(cde_mem_size_3));
+  if(cde_mem_start_3 == NULL) 
+  {
+    printk("ERROR: __get_free_pages failed for %d\n",cde_mem_size_3);
+    return NULL;
+  }
+  cde_inf_output_mem = cde_mem_start_4 = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(cde_mem_size_4));
+  if(cde_mem_start_4 == NULL)
+  {
+    printk("ERROR: __get_free_pages failed for %d\n",cde_mem_size_4);
+    return NULL;
+  }
+  cde_mem_start = cde_mem_start_5 = (unsigned char*)__get_free_pages(GFP_KERNEL, get_order(cde_mem_size_5));
+  if(cde_mem_start_5 == NULL) 
+  {
+    printk("ERROR: __get_free_pages failed for %d\n",cde_mem_size_5);
+    return NULL;
+  }
+  cde_inf_mem_start = cde_mem_start + sizeof(struct nlm_cde_op) + 2 * sizeof(unsigned int);
+  
+  memset(cmp_data->src, 0, MAX_INPUT_BUFFER_SIZE);
   memset(cmp_data->target, 0, MAX_BUFFER_SIZE);
-  memset(cmp_data->src_desc, 0, sizeof(unsigned long long) * CMP_PAGE_SIZE);
-  memset(cmp_data->scratch, 0, sizeof(unsigned long long) *SCRATCH_SIZE);
-  memset(cmp_data->scratch_inf, 0, sizeof(unsigned long long) *SCRATCH_SIZE);
+
+  memset(cmp_data->src_desc, 0, CMP_PAGE_SIZE);
+  memset(cmp_data->scratch, 0, SCRATCH_SIZE);
+  memset(cmp_data->scratch_inf, 0, SCRATCH_SIZE);
 
   if (config_cmp() == -1)
 	return NULL;
@@ -632,25 +658,31 @@ int xlp_cde_open(struct inode *inode, struct file *filp)
 void nlm_cde_cleanup(cmp_data_t *cmp_data)
 {
   int i;
-
   if (cmp_data->src)  
-	  kfree(cmp_data->src);
+	free_pages ((ulong)cmp_data->src, get_order (MAX_INPUT_BUFFER_SIZE));
   if (cmp_data->target)  
-	  kfree(cmp_data->target);
+	free_pages ((ulong)cmp_data->target, get_order (MAX_BUFFER_SIZE));
   if (cmp_data->src_desc)  
 	  kfree(cmp_data->src_desc);
   if (cmp_data->scratch)  
 	  kfree(cmp_data->scratch);
   if (cmp_data->scratch_inf)  
 	  kfree(cmp_data->scratch_inf);
+
+  free_pages((ulong)cde_mem_start_1, get_order(cde_mem_size_1));
+  free_pages((ulong)cde_mem_start_2, get_order(cde_mem_size_2));
+  free_pages((ulong)cde_mem_start_3, get_order(cde_mem_size_3));
+  free_pages((ulong)cde_mem_start_4, get_order(cde_mem_size_4));
+  free_pages((ulong)cde_mem_start_5, get_order(cde_mem_size_5));
+
+  cmp_data->src = NULL;
+  cmp_data->target = NULL;
+  cmp_data->src_desc = NULL; 
+  cmp_data->scratch = NULL;
+  cmp_data->scratch_inf = NULL;
+
   if (cmp_data)
     kfree(cmp_data);
-    cmp_data->src = NULL;
-    cmp_data->target = NULL;
-    cmp_data->src_desc = NULL; 
-    cmp_data->scratch = NULL;
-    cmp_data->scratch_inf = NULL;
-    cmp_data = NULL;
 
   for (i = 0; i < NUM_FREE_DESCRIPTORS; i++) {
     if (page_array[i].data_array)	{
@@ -665,8 +697,8 @@ static int xlp_cde_mmap(struct file * filp, struct vm_area_struct * vma)
 {
 	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
 	unsigned long size = 0;
-	int result = 0;
-	unsigned long cde_pfn_addr = 0;
+	int result = 0, result_t = 0;
+	unsigned long cde_pfn_addr = 0, vm_start = vma->vm_start;
 	if (cde_mem_size <= 0) return -ENXIO;
 
 	if (offset >= cde_mem_size) return -ESPIPE;
@@ -677,9 +709,30 @@ static int xlp_cde_mmap(struct file * filp, struct vm_area_struct * vma)
 	pgprot_val (vma->vm_page_prot) &= ~_CACHE_MASK;
 	pgprot_val (vma->vm_page_prot) |= _CACHE_CACHABLE_COW;
 
-	cde_pfn_addr = ((uint64_t)cde_mem_start >> PAGE_SHIFT);
-	result = remap_pfn_range(vma, vma->vm_start, cde_pfn_addr, size, 
+	
+	cde_pfn_addr = ((uint64_t)cde_mem_start_1 >> PAGE_SHIFT);
+	result = remap_pfn_range(vma, vma->vm_start, cde_pfn_addr, cde_mem_size_1, 
+								vma->vm_page_prot);
+	vma->vm_start = (unsigned long)((unsigned char*)(vma->vm_start) + cde_mem_size_1);
+
+	cde_pfn_addr = ((uint64_t)cde_mem_start_2 >> PAGE_SHIFT);
+	result_t = remap_pfn_range(vma, vma->vm_start, cde_pfn_addr, cde_mem_size_2, 
+								vma->vm_page_prot);
+
+	vma->vm_start = (unsigned long)((unsigned char*)(vma->vm_start) + cde_mem_size_2);
+	cde_pfn_addr = ((uint64_t)cde_mem_start_3 >> PAGE_SHIFT);
+	result_t = remap_pfn_range(vma, vma->vm_start, cde_pfn_addr, cde_mem_size_3, 
+								vma->vm_page_prot);
+	vma->vm_start = (unsigned long)((unsigned char*)(vma->vm_start) + cde_mem_size_3);
+	cde_pfn_addr = ((uint64_t)cde_mem_start_4 >> PAGE_SHIFT);
+	result_t = remap_pfn_range(vma, vma->vm_start, cde_pfn_addr, cde_mem_size_4, 
 								vma->vm_page_prot);
+
+	vma->vm_start = (unsigned long)((unsigned char*)(vma->vm_start) + cde_mem_size_4);
+	cde_pfn_addr = ((uint64_t)cde_mem_start_5 >> PAGE_SHIFT);
+	result_t = remap_pfn_range(vma, vma->vm_start, cde_pfn_addr, cde_mem_size_5, 
+								vma->vm_page_prot);
+	vma->vm_start = vm_start;
 	if (result) return -EAGAIN;
 
 	return 0;
@@ -689,8 +742,8 @@ int xlp_cde_release(struct inode *inode, struct file *filp)
 { 
   cmp_data->target_size = 0;
   cmp_data->offset = 0;
-  memset(cmp_data->scratch, 0,  sizeof(unsigned long long) *SCRATCH_SIZE);
-  memset(cmp_data->scratch_inf, 0, sizeof(unsigned long long) *SCRATCH_SIZE);
+  memset(cmp_data->scratch, 0,  SCRATCH_SIZE);
+  memset(cmp_data->scratch_inf, 0, SCRATCH_SIZE);
   return 0;
 }
 
@@ -703,7 +756,7 @@ unsigned int nlm_cde_receive_response(cmp_data_t *cmp_data, unsigned char *buf,
 
 	memcpy(buf, &cmp_data->target[cmp_data->offset], size);
 #ifdef CDE_DEBUG
-	printk("xlp_cde_read cmp_data->target_size = %d size = %d\n",cmp_data->target_size, size);
+	printk("xlp_cde_read cmp_data->target_size = %d size = %d\n",cmp_data->Target_size, size);
 	dump_buffer(cmp_data->target, size, "Output:");
 #endif
 	cmp_data->offset += size;
@@ -763,7 +816,11 @@ unsigned int nlm_cde_send_request(cmp_data_t *cmp_data, unsigned int op,
   // send message
   for (i = 0; i < num_messages; i++) {
 
-    int status = send_message(MSGRNG_STNID_CMP0, (struct msgrng_msg *) (cmp_msg + i));
+    int status;
+    if(is_nlm_xlp2xx())
+	status =  send_message(MSGRNG_2XX_STNID_CMP0, (struct msgrng_msg *) (cmp_msg + i));
+    else
+	status =  send_message(MSGRNG_STNID_CMP0, (struct msgrng_msg *) (cmp_msg + i));
 #ifdef CDE_DEBUG
     printk("write: status = %x\n", status);
 #endif
@@ -814,7 +871,6 @@ int xlp_cde_ioctl(struct inode *inode, struct file *filp,
     output_mem = cde_output_mem;
     mem_start = cde_mem_start;
     break;
-
   default:
 	printk("xlp_cde_ioctl: default\n");
     return -ENOTTY;
@@ -830,7 +886,7 @@ int xlp_cde_ioctl(struct inode *inode, struct file *filp,
   cmp_data->sof = cde->sof;
   cmp_data->eof = cde->eof;
   size = nlm_cde_send_request(cmp_data, cmp_data->op, cmp_data->compression_type, cmp_data->sof, cmp_data->eof, (unsigned char*)input_mem, input_size);
-//printk("written %d byte of data\n", size);
+//printk("#%d written %d byte of data\n", k++, size);
   size = 0;
   do{
     size = nlm_cde_receive_response(cmp_data, (unsigned char*)output_mem, output_size);
@@ -838,11 +894,53 @@ int xlp_cde_ioctl(struct inode *inode, struct file *filp,
   }while(size == 0 && i < 0xffffff); 
   *(unsigned int*)(mem_start + sizeof(struct nlm_cde_op) + sizeof(unsigned int)) = size;
 //printk("Read %d byte of data\n", size);
-
+//dump_buffer(cmp_data->scratch_inf, SCRATCH_SIZE, "Inf Scratch:");
   return err;
 }
 
 
+#if 0
+static unsigned strtonum(char c)
+{
+        if(c >= '0' && c <= '9')
+                return (c - '0');
+
+        if(c >= 'A' && c <= 'F')
+                return (c - 'A' + 10);
+
+        if(c >= 'a' && c <= 'f')
+                return (c - 'a' + 10);
+}
+static void test()
+{
+  int i = 0;
+  unsigned int input_size = 0, output_size = 0, size;
+  unsigned char *input_mem, *output_mem, *mem_start;
+  
+  input_mem = cde_inf_input_mem;
+  output_mem = cde_inf_output_mem;
+  mem_start = cde_inf_mem_start;
+  
+  input_size = sizeof(src_gz_data)/2;//200;
+  output_size = MAX_BUFFER_SIZE;
+  for(i = 0; i < (input_size*2); i=i+2)
+  {
+    input_mem[i/2] = (strtonum(src_gz_data[i]) << 4) | strtonum(src_gz_data[i+1]);
+  }
+//dump_buffer(input_mem, input_size, "input:");
+  size = nlm_cde_send_request(cmp_data, 0, 1, 1, 1, (unsigned char*)input_mem, input_size);
+  printk("written %d byte of data\n", size);
+  size = 0;
+  do{
+    size = nlm_cde_receive_response(cmp_data, (unsigned char*)output_mem, output_size);
+    i++;
+  }while(size == 0 && i < 0xffffff); 
+  printk("Read %d byte of data\n", size);
+//dump_buffer(output_mem, size, "output:");
+
+}
+#endif
+
 static int __init xlp_cde_init(void)
 {
     printk(KERN_ERR ",\n XLP CDE Initialization \n");
@@ -859,10 +957,14 @@ static int __init xlp_cde_init(void)
 	panic("can't register msgring handler for XLP_MSG_HANDLE_CMP");
     }
     printk("xlp_cde_init done\n\n");
+    if(is_nlm_xlp2xx())
+  	num_cde_engine = NUM_CDE_ENGINE_XLP2XX;
+    else
+  	num_cde_engine = NUM_CDE_ENGINE;
 {
   int i =0;
   unsigned int ret;
-  for(i = 0; i < NUM_CDE_ENGINE; i++)
+  for(i = 0; i < num_cde_engine; i++)
   {
     ret = nlm_hal_read_cde_reg(CMP_REG_RESET_REG(i));
 #ifdef CDE_DEBUG
@@ -884,6 +986,7 @@ static int __init xlp_cde_init(void)
   /*TEMP*/
   nlm_cde_init();
 }
+ //test();
 
     return 0;
 }
diff --git a/drivers/misc/nlm-cde/nlm_cde.h b/drivers/misc/nlm-cde/nlm_cde.h
index 3cec0e2..a60d582 100644
--- a/drivers/misc/nlm-cde/nlm_cde.h
+++ b/drivers/misc/nlm-cde/nlm_cde.h
@@ -28,6 +28,7 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define NUM_VC 8
 #define NLM_CDE_VC_BASE 297
 #define NUM_CDE_ENGINE 4
+#define NUM_CDE_ENGINE_XLP2XX 	1
 
 #define CDE_INFLATE 			1
 #define CDE_DEFLATE 			2
@@ -44,15 +45,21 @@ THE POSSIBILITY OF SUCH DAMAGE.
 #define MSGRNG_STNID_CMP0 XLP_STNID_CMP
 #define MSGRNG_STNID_CMP1 (XLP_STNID_CMP + 4)
 
+#define MSGRNG_2XX_STNID_CMP0 XLP_2XX_CDE_VC_BASE
+#define MSGRNG_2XX_STNID_CMP1 (XLP_2XX_CDE_VC_BASE + 1)
+
 #define RTN_BKT 1
 #define FD_BURST_SIZE 1
-#define NUM_FREE_DESCRIPTORS 100 //must be less or equal to MAX_NUM_PAGES
-#define MAX_NUM_PAGES 100
-#define MAX_BUFFER_SIZE 1024*64
-#define CMP_PAGE_SIZE   2048//1024
-#define SCRATCH_SIZE    (1024)
-#define MAX_NUM_MESSAGES 20
+#define NUM_FREE_DESCRIPTORS 256 //must be less or equal to MAX_NUM_PAGES
+#define MAX_NUM_PAGES 256
+#define MAX_BUFFER_SIZE (1024*2048)
+#define MAX_INPUT_BUFFER_SIZE (1024*64)
+#define CMP_PAGE_SIZE   (2*1024)
+#define FD_CMP_PAGE_SIZE   (32*1024)
+#define SCRATCH_SIZE    (8*1024)
+#define MAX_NUM_MESSAGES 100
 
+unsigned char src_gz_data[] = {"edc13101000000c2a0f54f6d085fa000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003e03"};
 
 typedef struct cmp_data_structure {
   char *src;    // source data
-- 
1.7.0

