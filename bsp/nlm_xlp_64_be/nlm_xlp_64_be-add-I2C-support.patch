From 839e9d36329f0ace17234204b8c5c646bb0fd2b4 Mon Sep 17 00:00:00 2001
From: Wu Zhangjin <zhangjin.wu@windriver.com>
Date: Thu, 7 Apr 2011 14:18:30 +0800
Subject: [PATCH 21/37] nlm_xlp_64_be: add I2C support

[ Based on netlogic SDK 20110329 ]

Add on-board I2C support for XLP.

Signed-off-by: henry shao <hshao@netlogicmicro.com>
[ Added the i2c_adapter interface ]
Integrated-by: Wu Zhangjin <zhangjin.wu@windriver.com>
---
 drivers/i2c/busses/Kconfig   |   11 +
 drivers/i2c/busses/Makefile  |    4 +
 drivers/i2c/busses/i2c-xlp.c |  512 ++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 527 insertions(+), 0 deletions(-)
 create mode 100644 drivers/i2c/busses/i2c-xlp.c

diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index 06c80fa..dd388f8 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -802,4 +802,15 @@ config SCx200_ACB
 	  This support is also available as a module.  If so, the module
 	  will be called scx200_acb.
 
+config I2C_NLM_XLP
+	tristate "Netlogic XLP SMBus interface"
+	depends on NLM_XLP
+	help
+	  If you say yes to this option, support will be included for the
+	  Netlogic XLP SMBus interface.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called i2c-xlp.
+
+
 endmenu
diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
index 4e5d36b..991890d 100644
--- a/drivers/i2c/busses/Makefile
+++ b/drivers/i2c/busses/Makefile
@@ -1,6 +1,9 @@
 #
 # Makefile for the i2c bus drivers.
 #
+ifeq ($(CONFIG_NLM_XLP),y)
+EXTRA_CFLAGS := $(CFLAGS) -DNLM_HAL_LINUX_KERNEL
+endif
 
 # ACPI drivers
 obj-$(CONFIG_I2C_SCMI)		+= i2c-scmi.o
@@ -75,6 +78,7 @@ obj-$(CONFIG_I2C_SIBYTE)	+= i2c-sibyte.o
 obj-$(CONFIG_I2C_STUB)		+= i2c-stub.o
 obj-$(CONFIG_SCx200_ACB)	+= scx200_acb.o
 obj-$(CONFIG_SCx200_I2C)	+= scx200_i2c.o
+obj-$(CONFIG_I2C_NLM_XLP)	+= i2c-xlp.o
 
 ifeq ($(CONFIG_I2C_DEBUG_BUS),y)
 EXTRA_CFLAGS += -DDEBUG
diff --git a/drivers/i2c/busses/i2c-xlp.c b/drivers/i2c/busses/i2c-xlp.c
new file mode 100644
index 0000000..3620bd3
--- /dev/null
+++ b/drivers/i2c/busses/i2c-xlp.c
@@ -0,0 +1,512 @@
+/***********************************************************************
+ * Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+ * reserved.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in
+ * the documentation and/or other materials provided with the
+ * distribution.
+ * THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * *****************************#NETL_2#********************************/
+
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+
+#include <asm/netlogic/hal/nlm_hal.h>
+#include <asm/netlogic/xlp.h>
+
+#define DEFAULT_VIRT_BASE               0x9000000000000000ULL
+#define I2C_TIMEOUT                     500000
+#define XLP_I2C_DEFAULT_SPEED           1000
+#define I2C_PRESCALER_LO                 0
+#define I2C_PRESCALER_HI                 1
+#define I2C_CONTROL                      2
+	#define I2C_CONTROL_EN           0x80
+	#define I2C_CONTROL_IEN          0x40
+#define I2C_DATA                         3               /* Data TX & RX Reg */
+#define I2C_COMMAND                      4
+	#define I2C_COMMAND_START        0x90
+	#define I2C_COMMAND_STOP         0x40
+	#define I2C_COMMAND_READ         0x20
+	#define I2C_COMMAND_WRITE        0x10
+	#define I2C_COMMAND_RDACK        0x20
+	#define I2C_COMMAND_RDNACK       0x28
+	#define I2C_COMMAND_IACK         0x01    /* Not used */
+#define I2C_STATUS                       4               /* Same as 'command' */
+	#define I2C_STATUS_NACK          0x80    /* Did not get an ACK */
+	#define I2C_STATUS_BUSY          0x40
+	#define I2C_STATUS_AL            0x20    /* Arbitration Lost */
+	#define I2C_STATUS_TIP           0x02    /* Transfer in Progress  */
+	#define I2C_STATUS_IF            0x01    /* Intr. Pending Flag, not used */
+#define I2C_WRITE_BIT			0x00
+#define I2C_READ_BIT			0x01
+#define I2C_DEFAULT_PRESCALER		0x3F
+
+struct i2c_xlp_data {
+	int	node;
+	int	bus;
+	int	func;
+	int	xfer_timeout;
+	int	ack_timeout;
+	uint64_t *ioreg;
+	struct i2c_adapter adap;
+	struct resource *ioarea;
+};
+
+static inline int32_t i2c_reg_read(int node, int func, int regidx)
+{
+	volatile uint64_t mmio;
+	mmio = nlm_hal_get_dev_base(node, 0, XLP_PCIE_GIO_DEV, func);
+	return nlm_hal_read_32bit_reg(mmio, regidx);
+}
+
+static inline void i2c_reg_write(int node, int func, int regidx, int32_t val)
+{
+	volatile uint64_t mmio;
+	mmio = nlm_hal_get_dev_base(node, 0, XLP_PCIE_GIO_DEV, func);
+	nlm_hal_write_32bit_reg(mmio, regidx, val);
+}
+
+#ifdef XLP_I2C_DEBUG
+static void i2c_dump_reg(void)
+{
+	int i, j = 0;
+	for (j = 0; j < 1; j++) {
+		pr_info("dump i2c_%d register\n", j);
+		for (i = 0; i < 6; i++)
+			pr_info("0x%0x = 0x%8x\n", i, i2c_reg_read(0, XLP_GIO_I2C0_FUNC + j, i));
+		for (i = 0x3C; i < 0x42; i++)
+			pr_info("0x%0x = 0x%8x\n", i, i2c_reg_read(0, XLP_GIO_I2C0_FUNC + j, i));
+	}
+}
+#endif
+
+static inline uint8_t i2c_read_reg8(struct i2c_xlp_data *adap, int offset)
+{
+	volatile uint32_t *i2c_mmio = (u32 *)adap->ioreg;
+	return (uint8_t)i2c_mmio[offset];
+}
+
+static inline void i2c_write_reg8(struct i2c_xlp_data *adap, int offset, uint8_t value)
+{
+	volatile uint32_t *i2c_mmio = (u32 *)adap->ioreg;
+	i2c_mmio[offset] = value;
+}
+
+static int wait_xfer_done(struct i2c_xlp_data *adap)
+{
+	volatile int timeout = I2C_TIMEOUT;
+	int retval = 0;
+
+	while ((i2c_read_reg8(adap, I2C_STATUS) & I2C_STATUS_TIP) && timeout)
+		timeout--;
+	if (timeout == 0) {
+		pr_err("Timed Out Waiting for TIP to Clear.\n");
+		retval = -EBUSY;
+	}
+	return retval;
+}
+
+static int bus_idle(struct i2c_xlp_data *adap)
+{
+	volatile int timeout = I2C_TIMEOUT;
+	int retval = 0;
+
+	while ((i2c_read_reg8(adap, I2C_STATUS) & I2C_STATUS_BUSY) && timeout)
+		timeout--;
+	if (timeout == 0) {
+		pr_err("Timed Out Waiting for Bus Busy to Clear.\n");
+		retval = -EBUSY;
+	}
+	return retval;
+}
+
+static int wait_ack(struct i2c_xlp_data *adap)
+{
+	if (i2c_read_reg8(adap, I2C_STATUS) & I2C_STATUS_NACK)
+		return -EIO;
+	return 0;
+}
+
+int xlp_i2c_read(struct i2c_xlp_data *adap, uint8_t slave_addr, uint32_t slave_offset,
+			int alen, int len, uint8_t *data)
+{
+	int i ;
+
+	/* Verify the bus is idle */
+	if (i2c_read_reg8(adap, I2C_STATUS) & I2C_STATUS_BUSY) {
+		pr_err("I2C Bus BUSY (Not Available), Aborting.\n");
+		goto i2c_rx_error;
+	}
+
+	i2c_write_reg8(adap, I2C_DATA, (slave_addr << 1) | I2C_WRITE_BIT);
+	i2c_write_reg8(adap, I2C_COMMAND, I2C_COMMAND_START);
+	if (wait_xfer_done(adap) < 0)
+		goto i2c_rx_error;
+	if (wait_ack(adap) < 0)
+		goto i2c_rx_error;
+
+	/* Verify Arbitration is not Lost */
+	if (i2c_read_reg8(adap, I2C_STATUS) & I2C_STATUS_AL) {
+		pr_err("I2C Bus Arbitration Lost, Aborting.\n");
+		goto i2c_rx_error;
+	}
+	for (i = 0; i <= alen; i++) {
+		i2c_write_reg8(adap, I2C_DATA, ((slave_offset >> (i*8)) & 0xff) | I2C_WRITE_BIT);
+		i2c_write_reg8(adap, I2C_COMMAND, I2C_COMMAND_WRITE);
+		if (wait_xfer_done(adap) < 0)
+			goto i2c_rx_error;
+		if (wait_ack(adap) < 0)
+			goto i2c_rx_error;
+	}
+
+	/* Address Phase Done, Data Phase begins */
+	i2c_write_reg8(adap, I2C_DATA, (slave_addr << 1) | I2C_READ_BIT);
+	i2c_write_reg8(adap, I2C_COMMAND, I2C_COMMAND_START);
+	if (wait_xfer_done(adap) < 0)
+		goto i2c_rx_error;
+	if (wait_ack(adap) < 0)
+		goto i2c_rx_error;
+	if (len > 1) {
+		int bytenr = 0;
+
+		for (bytenr = 0; bytenr < len-1; bytenr++) {
+			i2c_write_reg8(adap, I2C_COMMAND, I2C_COMMAND_READ);
+			if (wait_xfer_done(adap) < 0)
+				goto i2c_rx_error;
+			if (data != NULL) {
+				*data = i2c_read_reg8(adap, I2C_DATA);
+				data++;
+			}
+		}
+	}
+
+	/* Last (or only) Byte: - Set RD, NACK, STOP Bits */
+	i2c_write_reg8(adap, I2C_COMMAND, I2C_COMMAND_STOP | I2C_COMMAND_RDNACK);
+	if (wait_xfer_done(adap) < 0)
+		goto i2c_rx_error;
+	if (data != NULL)
+		*data = i2c_read_reg8(adap, I2C_DATA);
+	return bus_idle(adap);
+
+i2c_rx_error:
+	/* Release Bus */
+	i2c_write_reg8(adap, I2C_COMMAND, I2C_COMMAND_STOP);
+	bus_idle(adap);
+	return -EIO;
+}
+
+int xlp_i2c_write(struct i2c_xlp_data *adap, uint8_t slave_addr, uint16_t slave_offset, int alen,
+			int len, uint8_t *data)
+{
+	int i ;
+
+	/* Verify the bus is idle */
+	if (i2c_read_reg8(adap, I2C_STATUS) & I2C_STATUS_BUSY) {
+		pr_err("I2C Bus BUSY (Not Available), Aborting.\n");
+		goto i2c_tx_error;
+	}
+
+	i2c_write_reg8(adap, I2C_DATA, (slave_addr << 1) | I2C_WRITE_BIT);
+	i2c_write_reg8(adap, I2C_COMMAND, I2C_COMMAND_START);
+	if (wait_xfer_done(adap) < 0)
+		goto i2c_tx_error;
+	if (wait_ack(adap) < 0)
+		goto i2c_tx_error;
+
+	/* Verify Arbitration is not Lost */
+	if (i2c_read_reg8(adap, I2C_STATUS) & I2C_STATUS_AL) {
+		pr_err("I2C Bus Arbitration Lost, Aborting.\n");
+		goto i2c_tx_error;
+	}
+
+	for (i = 0; i <= alen; i++) {
+		i2c_write_reg8(adap, I2C_DATA, ((slave_offset >> (i*8)) & 0xff) | I2C_WRITE_BIT);
+		i2c_write_reg8(adap, I2C_COMMAND, I2C_COMMAND_WRITE);
+		if (wait_xfer_done(adap) < 0)
+			goto i2c_tx_error;
+		if (wait_ack(adap) < 0)
+			goto i2c_tx_error;
+	}
+
+	if (len > 1) {
+		int bytenr = 0;
+
+		for (bytenr = 0; bytenr < len-1; bytenr++) {
+			i2c_write_reg8(adap, I2C_DATA, *data);
+			i2c_write_reg8(adap, I2C_COMMAND, I2C_COMMAND_WRITE);
+			if (wait_xfer_done(adap) < 0)
+				goto i2c_tx_error;
+			data++;
+		}
+	}
+	i2c_write_reg8(adap, I2C_DATA, *data);
+	i2c_write_reg8(adap, I2C_COMMAND, I2C_COMMAND_STOP | I2C_COMMAND_WRITE);
+	if (wait_xfer_done(adap) < 0)
+		goto i2c_tx_error;
+	if (wait_ack(adap) < 0)
+		goto i2c_tx_error;
+
+	return bus_idle(adap);
+
+i2c_tx_error:
+	/* Release Bus */
+	i2c_write_reg8(adap, I2C_COMMAND, I2C_COMMAND_STOP);
+	bus_idle(adap);
+	return -EIO;
+}
+
+static int xlp_i2c_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg *msgs, int num)
+{
+	struct i2c_xlp_data *adap = i2c_adap->algo_data;
+	struct i2c_msg *p;
+	int err = 0, command, len;
+
+	command = msgs[0].buf[0];
+	if (num == 1) {
+		p = &msgs[0];
+		if (p && p->len == 0)
+			len = 1;
+		else if (p && (p->flags & I2C_M_RD))
+			len = p->len;
+		else
+			len = p->len - 1;
+	} else if (num == 2) {
+		p = &msgs[1];
+		len = p->len;
+	} else {
+		pr_err("%s ERR: msg num =%d large than 2\n", __func__, num);
+		return -EINVAL;
+	}
+	if (p->flags & I2C_M_RD)
+		err = xlp_i2c_read(adap, p->addr, command, 0, len, &p->buf[0]);
+	else
+		err = xlp_i2c_write(adap, p->addr, command, 0, len, &p->buf[1]);
+
+	/* Return the number of messages processed, or the error code. */
+	if (err == 0)
+		err = num;
+
+	return err;
+}
+
+static int xlp_i2c_smbus_xfer(struct i2c_adapter *i2c_adap, u16 addr, unsigned short flags,
+	char read_write, u8 command, int protocol, union i2c_smbus_data *data)
+{
+	struct i2c_xlp_data *adap = i2c_adap->algo_data;
+	int err;
+	int len;
+
+	switch (protocol) {
+	case I2C_SMBUS_BYTE:
+		if (read_write == I2C_SMBUS_READ)
+			err = xlp_i2c_read(adap, addr, command, 0, 1, &data->byte);
+		else
+			err = xlp_i2c_write(adap, addr, command, 0, 1, &command);
+
+		break;
+	case I2C_SMBUS_BYTE_DATA:
+		if (read_write == I2C_SMBUS_READ)
+			err = xlp_i2c_read(adap, addr, command, 0, 1, &data->byte);
+		else
+			err = xlp_i2c_write(adap, addr, command, 0, 1, &data->byte);
+		break;
+
+	case I2C_SMBUS_WORD_DATA:
+	case I2C_SMBUS_PROC_CALL:
+		if (read_write == I2C_SMBUS_READ)
+			err = xlp_i2c_read(adap, addr, command, 0, 2, (u8 *)&data->word);
+		else
+			err = xlp_i2c_write(adap, addr, command, 0, 2, (u8 *)&data->word);
+
+		break;
+	case I2C_FUNC_SMBUS_BLOCK_DATA:
+	case I2C_SMBUS_I2C_BLOCK_DATA:
+		len = (data->block[0] > I2C_SMBUS_BLOCK_MAX) ? I2C_SMBUS_BLOCK_MAX : data->block[0];
+		if (read_write == I2C_SMBUS_READ)
+			err = xlp_i2c_read(adap, addr, command, 0, len, &data->block[1]);
+		else
+			err = xlp_i2c_write(adap, addr, command, 0, len, &data->block[1]);
+
+		break;
+	default:
+		err = -EINVAL;
+	}
+	return err;
+}
+
+static uint32_t xlp_i2c_func(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
+}
+
+static const struct i2c_algorithm xlp_i2c_algo = {
+	.master_xfer	= xlp_i2c_xfer,
+	.smbus_xfer	= xlp_i2c_smbus_xfer,
+	.functionality	= xlp_i2c_func,
+};
+
+static void i2c_xlp_setup(struct i2c_xlp_data *priv)
+{
+	uint32_t val, prescaler;
+
+	val = i2c_reg_read(priv->node, priv->func, XLP_I2C_CFG0);
+	val &= ~(XLP_I2C_EN | XLP_I2C_INT_EN);
+	i2c_reg_write(priv->node, priv->func, XLP_I2C_CFG0, val);
+
+	prescaler = I2C_DEFAULT_PRESCALER;
+	/*set the I2c speed 100 khz*/
+	val &= ~0xFFFF;
+	val |=  (prescaler & 0xFFFF);
+	i2c_reg_write(priv->node, priv->func, XLP_I2C_CFG0, val);
+
+	val |= XLP_I2C_EN;
+	i2c_reg_write(priv->node, priv->func, XLP_I2C_CFG0, val);
+}
+
+static void i2c_xlp_disable(struct i2c_xlp_data *priv)
+{
+	int32_t val;
+
+	val = i2c_reg_read(priv->node, priv->func, XLP_I2C_CFG0);
+	val &= ~XLP_I2C_EN;
+	i2c_reg_write(priv->node, priv->func, XLP_I2C_CFG0, val);
+}
+
+static struct i2c_adapter xlp_i2c_adap = {
+	.owner = THIS_MODULE,
+	.name = "XLP I2C adapter",
+	.algo = &xlp_i2c_algo,
+	.timeout = 200,
+	.retries = 3,
+};
+
+static int __devinit
+i2c_xlp_probe(struct platform_device *pdev)
+{
+	struct i2c_xlp_data *priv;
+	int ret;
+#ifdef XLP_I2C_DEBUG
+	i2c_dump_reg();
+#endif
+	priv = kzalloc(sizeof(struct i2c_xlp_data), GFP_KERNEL);
+	if (!priv) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	priv->node = 0;
+	priv->bus = pdev->id;
+	priv->func = priv->bus + 2;
+	priv->xfer_timeout = 200;
+	priv->ack_timeout = 200;
+	priv->ioreg = (uint64_t *)(DEFAULT_VIRT_BASE +
+		nlm_hal_get_dev_base(0, 0, XLP_PCIE_GIO_DEV, priv->func) + 0x100);
+	priv->adap = xlp_i2c_adap;
+	priv->adap.nr = pdev->id;
+	priv->adap.algo_data = priv;
+	priv->adap.dev.parent = &pdev->dev;
+	strlcpy(priv->adap.name, "i2c-xlp", sizeof(priv->adap.name));
+
+	/* Now, set up the PSC for SMBus PIO mode. */
+	i2c_xlp_setup(priv);
+
+	ret = i2c_add_numbered_adapter(&priv->adap);
+	if (!ret) {
+		i2c_xlp_disable(priv);
+		goto out;
+	}
+
+	platform_set_drvdata(pdev, priv);
+	pr_info("Initializing i2c-xlp host driver for i2c-xlp.%d\n", pdev->id);
+	return 0;
+
+out:
+	return ret;
+}
+
+static int __devexit i2c_xlp_remove(struct platform_device *pdev)
+{
+	struct i2c_xlp_data *priv = platform_get_drvdata(pdev);
+
+	platform_set_drvdata(pdev, NULL);
+	i2c_del_adapter(&priv->adap);
+	i2c_xlp_disable(priv);
+	if (priv->ioarea) {
+		release_resource(priv->ioarea);
+		kfree(priv->ioarea);
+	}
+	kfree(priv);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int i2c_xlp_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct i2c_xlp_data *priv = platform_get_drvdata(pdev);
+
+	i2c_xlp_disable(priv);
+
+	return 0;
+}
+
+static int i2c_xlp_resume(struct platform_device *pdev)
+{
+	struct i2c_xlp_data *priv = platform_get_drvdata(pdev);
+
+	i2c_xlp_setup(priv);
+
+	return 0;
+}
+#else
+#define i2c_xlp_suspend	NULL
+#define i2c_xlp_resume	NULL
+#endif
+
+static struct platform_driver xlp_smbus_driver = {
+.driver = {
+	.name	= "i2c-xlp",
+	.owner	= THIS_MODULE,
+},
+	.probe		= i2c_xlp_probe,
+	.remove		= __devexit_p(i2c_xlp_remove),
+	.suspend	= i2c_xlp_suspend,
+	.resume		= i2c_xlp_resume,
+};
+
+static int __init i2c_xlp_init(void)
+{
+	return platform_driver_register(&xlp_smbus_driver);
+}
+
+static void __exit i2c_xlp_exit(void)
+{
+	platform_driver_unregister(&xlp_smbus_driver);
+}
+
+module_init(i2c_xlp_init);
+module_exit(i2c_xlp_exit);
+
+MODULE_AUTHOR("Netlogic MicroSystems");
+MODULE_DESCRIPTION("I2C adapter for XLP soc");
+MODULE_LICENSE("GPL");
-- 
1.7.0.2

