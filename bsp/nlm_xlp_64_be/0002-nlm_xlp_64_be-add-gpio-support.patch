From 5985e0357a2571650c4dbf737c06c77fceb3d371 Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Fri, 23 Mar 2012 11:32:17 +0800
Subject: [PATCH 02/15] nlm_xlp_64_be: add gpio support.

Add gpio support, based on NetLogic SDK 20120215_2.2.3 tag.

Signed-off-by: henry shao <hshao@netlogicmicro.com>
Integrated-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/mips/Kconfig                     |    3 +
 arch/mips/include/asm/netlogic/gpio.h |   79 +++++++++++
 arch/mips/netlogic/xlp/Makefile       |    2 +-
 arch/mips/netlogic/xlp/xlp_gpio.c     |  239 +++++++++++++++++++++++++++++++++
 4 files changed, 322 insertions(+), 1 deletions(-)
 create mode 100644 arch/mips/include/asm/netlogic/gpio.h
 create mode 100644 arch/mips/netlogic/xlp/xlp_gpio.c

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 1900108..816deb2 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -1363,6 +1363,9 @@ config CPU_XLP
 	select WEAK_ORDERING
 	select WEAK_REORDERING_BEYOND_LLSC
 	select CPU_HAS_PREFETCH if !PGWALKER
+        select GENERIC_GPIO
+        select GPIO_SYSFS
+        select ARCH_REQUIRE_GPIOLIB
 	help
 	  Netlogic Corporation XLP processors.
 
diff --git a/arch/mips/include/asm/netlogic/gpio.h b/arch/mips/include/asm/netlogic/gpio.h
new file mode 100644
index 0000000..33dce08
--- /dev/null
+++ b/arch/mips/include/asm/netlogic/gpio.h
@@ -0,0 +1,79 @@
+/***********************************************************************
+Copyright 2003-2010 Netlogic Microsystems (“Netlogic”). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#NETL_2#********************************/
+
+#ifndef _ASM_NLM_GPIO_H
+#define _ASM_NLM_GPIO_H
+
+#include <asm/netlogic/iomap.h>
+
+#define NETLOGIC_GPIO_INT_EN_REG 0
+#define NETLOGIC_GPIO_INPUT_INVERSION_REG 1
+#define NETLOGIC_GPIO_IO_DIR_REG 2
+#define NETLOGIC_GPIO_IO_DATA_WR_REG 3
+#define NETLOGIC_GPIO_IO_DATA_RD_REG 4
+
+#define NETLOGIC_GPIO_SWRESET_REG 8
+
+#define NETLOGIC_GPIO_DRAM1_CNTRL_REG 9
+#define NETLOGIC_GPIO_DRAM1_RATIO_REG 10
+#define NETLOGIC_GPIO_DRAM1_RESET_REG 11
+#define NETLOGIC_GPIO_DRAM1_STATUS_REG 12
+
+#define NETLOGIC_GPIO_DRAM2_CNTRL_REG 13
+#define NETLOGIC_GPIO_DRAM2_RATIO_REG 14
+#define NETLOGIC_GPIO_DRAM2_RESET_REG 15
+#define NETLOGIC_GPIO_DRAM2_STATUS_REG 16
+
+#define NETLOGIC_GPIO_PWRON_RESET_CFG_REG 21
+
+#define NETLOGIC_GPIO_BIST_ALL_GO_STATUS_REG 24
+#define NETLOGIC_GPIO_BIST_CPU_GO_STATUS_REG 25
+#define NETLOGIC_GPIO_BIST_DEV_GO_STATUS_REG 26
+
+#define NETLOGIC_GPIO_FUSE_BANK_REG 35
+
+#define NETLOGIC_GPIO_CPU_RESET_REG 40
+
+#define NETLOGIC_GPIO_RNG_REG 43
+
+#define NETLOGIC_PWRON_RESET_PCMCIA_BOOT 17
+
+#define NETLOGIC_GPIO_LED_BITMAP 0x1700000
+#define NETLOGIC_GPIO_LED_0_SHIFT 20
+#define NETLOGIC_GPIO_LED_1_SHIFT 24
+
+#define NETLOGIC_GPIO_LED_OUTPUT_CODE_RESET 0x01
+#define NETLOGIC_GPIO_LED_OUTPUT_CODE_HARD_RESET 0x02
+#define NETLOGIC_GPIO_LED_OUTPUT_CODE_SOFT_RESET 0x03
+#define NETLOGIC_GPIO_LED_OUTPUT_CODE_MAIN 0x04
+
+#ifdef CONFIG_NLM_XLP
+#include <asm-generic/gpio.h>
+#define gpio_get_value __gpio_get_value
+#define gpio_set_value __gpio_set_value
+#define gpio_cansleep __gpio_cansleep
+#define gpio_to_irq(gpio) NULL
+#endif
+#endif
diff --git a/arch/mips/netlogic/xlp/Makefile b/arch/mips/netlogic/xlp/Makefile
index be3a061..7172857 100644
--- a/arch/mips/netlogic/xlp/Makefile
+++ b/arch/mips/netlogic/xlp/Makefile
@@ -4,7 +4,7 @@ EXTRA_CFLAGS := $(CFLAGS) -DNLM_HAL_LINUX_KERNEL -Iarch/mips/include/asm/netlogi
 obj-y                    	= setup.o mmu.o
 obj-y 				+= irq.o time.o on_chip.o
 obj-$(CONFIG_NLM_XLP) 		+= platform.o board.o
-obj-$(CONFIG_NLM_XLP) 		+= xlp_hal_pic.o
+obj-$(CONFIG_NLM_XLP) 		+= xlp_hal_pic.o xlp_gpio.o
 obj-$(CONFIG_SMP)       	+= smp.o
 
 obj-$(CONFIG_NLM_XLP) += cpu_control.o cpu_control_asm.o
diff --git a/arch/mips/netlogic/xlp/xlp_gpio.c b/arch/mips/netlogic/xlp/xlp_gpio.c
new file mode 100644
index 0000000..e37b66b
--- /dev/null
+++ b/arch/mips/netlogic/xlp/xlp_gpio.c
@@ -0,0 +1,239 @@
+/***********************************************************************
+ * Copyright 2003-2010 Netlogic Microsystems ("Netlogic"). All rights
+ * reserved.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in
+ * the documentation and/or other materials provided with the
+ * distribution.
+ * THIS SOFTWARE IS PROVIDED BY Netlogic Microsystems ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ * *****************************#NETL_2#********************************/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <asm/netlogic/xlp.h>
+#include <asm/netlogic/hal/nlm_hal.h>
+#include <asm/netlogic/xlp_hal_pic.h>
+#include <asm/netlogic/gpio.h>
+
+#define XLP_GPIO_MAX		41
+#define XLP_GPIO1_BASE		32
+
+spinlock_t xlp_gpio_lock  = SPIN_LOCK_UNLOCKED;
+
+__inline__ int32_t gpio_reg_read(int node, int regidx)
+{
+        volatile uint64_t mmio;
+        mmio = nlm_hal_get_dev_base(node, 0, XLP_PCIE_GIO_DEV, XLP_GIO_GPIO_FUNC);
+        return nlm_hal_read_32bit_reg(mmio, regidx);
+}
+
+static __inline__ void gpio_reg_write(int node, int regidx, int32_t val)
+{
+        volatile uint64_t mmio;
+        mmio = nlm_hal_get_dev_base(node, 0, XLP_PCIE_GIO_DEV, XLP_GIO_GPIO_FUNC);
+        nlm_hal_write_32bit_reg(mmio, regidx, val);
+}
+
+static inline void xlp_gpio_set_value(int gpio, int v)
+{
+	uint32_t val;
+	unsigned long flags;
+
+	if(gpio < XLP_GPIO1_BASE)
+		val = gpio_reg_read(0, XLP_GPIO_OUTPUT0);
+	else
+		val = gpio_reg_read(0, XLP_GPIO_OUTPUT1);
+
+	spin_lock_irqsave(&xlp_gpio_lock, flags);
+
+	if(v) {
+
+		if(gpio < XLP_GPIO1_BASE)
+			val |= (v << gpio);
+		else
+			val |= (v << (gpio - XLP_GPIO1_BASE));
+	} else {
+		if(gpio < XLP_GPIO1_BASE)
+			val &= ~(v << gpio);
+		else
+			val &= ~(v << (gpio - XLP_GPIO1_BASE));
+
+	}
+
+	if(gpio < XLP_GPIO1_BASE)
+		gpio_reg_write(0, XLP_GPIO_OUTPUT0, val);
+	else
+		gpio_reg_write(0, XLP_GPIO_OUTPUT1, val);
+
+	spin_unlock_irqrestore(&xlp_gpio_lock, flags);
+
+	return;
+}
+
+static inline int xlp_gpio_get_value(int gpio)
+{
+        unsigned long mask;
+
+	if(gpio < XLP_GPIO1_BASE){
+		mask = 1 << gpio;
+		return ((gpio_reg_read(0, XLP_GPIO_INPUT0) & mask) >> gpio);
+	} else {
+		mask = 1 << (gpio - XLP_GPIO1_BASE);
+		return ((gpio_reg_read(0, XLP_GPIO_INPUT1) & mask) >> gpio);
+	}
+}
+
+static inline int xlp_gpio_direction_input(int gpio)
+{
+	uint32_t val;
+	unsigned long flags;
+
+	if(gpio < XLP_GPIO1_BASE)
+		val = gpio_reg_read( 0, XLP_GPIO_OUTPUT_EN0);
+	else
+		val = gpio_reg_read( 0, XLP_GPIO_OUTPUT_EN1);
+
+	spin_lock_irqsave(&xlp_gpio_lock, flags);
+	if(gpio < XLP_GPIO1_BASE)
+		val &= ~(1 << gpio);
+	else
+		val &= ~(1 << (gpio-XLP_GPIO1_BASE));
+
+	if(gpio < XLP_GPIO1_BASE)
+		gpio_reg_write(0, XLP_GPIO_OUTPUT_EN0, val);
+	else
+		gpio_reg_write(0, XLP_GPIO_OUTPUT_EN1, val);
+	spin_unlock_irqrestore(&xlp_gpio_lock, flags);
+        return 0;
+}
+
+static inline int xlp_gpio_direction_output(int gpio, int v)
+{
+	uint32_t val;
+	unsigned long flags;
+
+	xlp_gpio_set_value(gpio, v);
+
+	if(gpio < XLP_GPIO1_BASE)
+		val = gpio_reg_read( 0, XLP_GPIO_OUTPUT_EN0);
+	else
+		val = gpio_reg_read( 0, XLP_GPIO_OUTPUT_EN1);
+
+	spin_lock_irqsave(&xlp_gpio_lock, flags);
+	if(gpio < XLP_GPIO1_BASE) {
+			val |= (1 << gpio);
+
+	} else {
+			val |= (1 << (gpio-XLP_GPIO1_BASE));
+
+	}
+	if(gpio < XLP_GPIO1_BASE)
+		gpio_reg_write(0, XLP_GPIO_OUTPUT_EN0, val);
+	else
+		gpio_reg_write(0, XLP_GPIO_OUTPUT_EN1, val);
+	spin_unlock_irqrestore(&xlp_gpio_lock, flags);
+
+        return 0;
+}
+static int gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+        return xlp_gpio_get_value(offset);
+}
+
+static void gpio_set(struct gpio_chip *chip,
+                                unsigned offset, int value)
+{
+        xlp_gpio_set_value(offset, value);
+	return;
+}
+
+static int nlm_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
+{
+        return xlp_gpio_direction_input(offset);
+}
+
+static int nlm_gpio_direction_output(struct gpio_chip *chip,
+                                        unsigned offset, int value)
+{
+        return xlp_gpio_direction_output(offset, value);
+}
+
+#define XLP_GPIO_DEBUG	0
+#if XLP_GPIO_DEBUG
+static void gpio_dump_reg(void)
+{
+        int i;
+        for(i = 0; i < 8; i++) {
+                printk("0x%0x = 0x%8x\n", i, gpio_reg_read( 0, i));
+        }
+        for(i = 0x40; i < 0x54; i++) {
+                printk("0x%0x = 0x%8x\n", i, gpio_reg_read(0, i));
+        }
+}
+
+void gpio_test(void)
+{
+        int i;
+
+	printk("read gpio value\n");
+        for(i = 0; i < 41; i++) {
+                printk("gpio%d = 0x%8x\n", i, gpio_get_value(i));
+        }
+	printk("set gpio value 1\n");
+
+        for(i = 0; i < 41; i++) {
+		gpio_direction_output(i, 1);
+		printk("0x%0x = 0x%8x\n",  i < 32 ? 40 : 41, gpio_reg_read(0, i < 32 ? 40 : 41));
+		gpio_direction_input(i);
+		printk("0x%0x = 0x%8x\n",  i < 32 ? 40 : 41, gpio_reg_read(0, i < 32 ? 40 : 41));
+                printk("gpio%d = 0x%8x\n", i, gpio_get_value(i));
+        }
+
+	printk("set gpio value 0\n");
+        for(i = 0; i < 41; i++) {
+		gpio_direction_output(i, 0);
+		printk("0x%0x = 0x%8x\n",  i < 32 ? 40 : 41, gpio_reg_read(0, i < 32 ? 40 : 41));
+		gpio_direction_input(i);
+		printk("0x%0x = 0x%8x\n",  i < 32 ? 40 : 41, gpio_reg_read(0, i < 32 ? 40 : 41));
+                printk("gpio%d = 0x%8x\n", i, gpio_get_value(i));
+        }
+
+}
+#endif
+
+struct gpio_chip xlp_gpio_chip = {
+	.label                  = "xlp-gpio",
+	.direction_input        = nlm_gpio_direction_input,
+	.direction_output       = nlm_gpio_direction_output,
+	.get                    = gpio_get,
+	.set                    = gpio_set,
+	.base                   = 0,
+	.ngpio                  = XLP_GPIO_MAX,
+};
+
+static int __init xlp_gpiolib_init(void)
+{
+        gpiochip_add(&xlp_gpio_chip);
+        return 0;
+}
+
+arch_initcall(xlp_gpiolib_init);
-- 
1.7.0.4

