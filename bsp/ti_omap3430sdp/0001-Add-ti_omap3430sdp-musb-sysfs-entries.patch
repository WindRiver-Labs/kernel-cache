From b74b57dd5a2cf0edb82a52c5a24d30dd3d3109ad Mon Sep 17 00:00:00 2001
From: Tonyliu <Bo.Liu@windriver.com>
Date: Thu, 12 Mar 2009 09:50:34 +0800
Subject: [PATCH] Add ti_omap3430sdp musb sysfs entries

USB port on ti_omap3430sdp has 3 work modes:
        a) USB Host
        b) USB Peripheral
        c) Both host and peripheral:  USB OTG (On The Go) Device
    In host or OTG mode, for saving power, each time usb
peripheral is disconnected, vbus drops off; but it can't rise up while
reconnect the usb peripheral.
    echo 1 > /sys/bus/platform/devices/musb_hdrc/session
    will setup vbus in host mode and make usb port becoming host
(either b_host or a_host, meaning that hnp would also trigger based on
     that) in OTG mode.

Signed-off-by: Tonyliu <Bo.Liu@windriver.com>
---
 drivers/usb/musb/musb_core.c |   48 +++++++++++++++++++++++++++++++++--------
 1 files changed, 38 insertions(+), 10 deletions(-)

diff --git a/drivers/usb/musb/musb_core.c b/drivers/usb/musb/musb_core.c
index 5c5bc1a..8752682 100644
--- a/drivers/usb/musb/musb_core.c
+++ b/drivers/usb/musb/musb_core.c
@@ -1726,6 +1726,35 @@ musb_vbus_show(struct device *dev, struct device_attribute *attr, char *buf)
 }
 static DEVICE_ATTR(vbus, 0644, musb_vbus_show, musb_vbus_store);
 
+static ssize_t
+musb_session_store(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t n)
+{
+		struct musb     *musb = dev_to_musb(dev);
+		unsigned long   flags;
+		unsigned short  session;
+		u8				devctl;
+
+		if (sscanf(buf, "%hu", &session) != 1
+				|| ((session != 1) && (session != 0))) {
+			dev_err(dev, "value must be 1 or 0\n");
+			return -EINVAL;
+		}
+
+		spin_lock_irqsave(&musb->lock, flags);
+		devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
+		if (session)
+			devctl |= MUSB_DEVCTL_SESSION;
+		else
+			devctl &= ~MUSB_DEVCTL_SESSION;
+
+		musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
+		spin_unlock_irqrestore(&musb->lock, flags);
+
+		return n;
+}
+static DEVICE_ATTR(session, 0644, NULL, musb_session_store);
+
 #ifdef CONFIG_USB_GADGET_MUSB_HDRC
 
 /* Gadget drivers can't know that a host is connected so they might want
@@ -1828,6 +1857,7 @@ static void musb_free(struct musb *musb)
 #ifdef CONFIG_SYSFS
 	device_remove_file(musb->controller, &dev_attr_mode);
 	device_remove_file(musb->controller, &dev_attr_vbus);
+	device_remove_file(musb->controller, &dev_attr_session);
 #ifdef CONFIG_USB_MUSB_OTG
 	device_remove_file(musb->controller, &dev_attr_srp);
 #endif
@@ -2054,24 +2084,22 @@ bad_config:
 
 	}
 
-	return 0;
-
-fail:
-	if (musb->clock)
-		clk_put(musb->clock);
-	device_init_wakeup(dev, 0);
-	musb_free(musb);
-	return status;
-
 #ifdef CONFIG_SYSFS
 	status = device_create_file(dev, &dev_attr_mode);
 	status = device_create_file(dev, &dev_attr_vbus);
+	status = device_create_file(dev, &dev_attr_session);
 #ifdef CONFIG_USB_GADGET_MUSB_HDRC
 	status = device_create_file(dev, &dev_attr_srp);
 #endif /* CONFIG_USB_GADGET_MUSB_HDRC */
-	status = 0;
 #endif
+	if (!status)
+		return 0;
 
+fail:
+	if (musb->clock)
+		clk_put(musb->clock);
+	device_init_wakeup(dev, 0);
+	musb_free(musb);
 	return status;
 
 fail2:
-- 
1.6.0.4

