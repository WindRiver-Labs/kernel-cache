From 73db69905bb5b24a9e8967456721022a69ff827a Mon Sep 17 00:00:00 2001
From: Koji Matsuoka <koji.matsuoka.xm@renesas.com>
Date: Mon, 26 Oct 2015 12:22:49 +0900
Subject: [PATCH 2056/2066] v4l: vsp1: Add underrun hung-up workaround

Signed-off-by: Koji Matsuoka <koji.matsuoka.xm@renesas.com>
[zou:Original patch taken from
git://git.kernel.org/pub/scm/linux/kernel/git/horms/renesas-bsp.git
 v4.9/rcar-3.5.]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 drivers/media/platform/vsp1/vsp1.h      |    5 ++
 drivers/media/platform/vsp1/vsp1_dl.c   |    4 ++
 drivers/media/platform/vsp1/vsp1_drv.c  |   88 ++++++++++++++++++++++++++++++-
 drivers/media/platform/vsp1/vsp1_regs.h |   24 ++++++++
 4 files changed, 120 insertions(+), 1 deletions(-)

diff --git a/drivers/media/platform/vsp1/vsp1.h b/drivers/media/platform/vsp1/vsp1.h
index d965ba5..43e323c 100644
--- a/drivers/media/platform/vsp1/vsp1.h
+++ b/drivers/media/platform/vsp1/vsp1.h
@@ -23,6 +23,7 @@
 
 #include "vsp1_regs.h"
 
+#define VSP1_UNDERRUN_WORKAROUND
 #define VSP1_DL_SUPPORT 1
 
 struct clk;
@@ -86,6 +87,10 @@ struct vsp1_device {
 	struct vsp1_rwpf *wpf[VSP1_MAX_WPF];
 #ifdef VSP1_DL_SUPPORT
 	struct vsp1_dl *dl;
+#ifdef VSP1_UNDERRUN_WORKAROUND
+	dma_addr_t dl_addr;
+	u32 dl_body;
+#endif
 #endif
 
 	struct list_head entities;
diff --git a/drivers/media/platform/vsp1/vsp1_dl.c b/drivers/media/platform/vsp1/vsp1_dl.c
index 8e72d26..1f4b816 100644
--- a/drivers/media/platform/vsp1/vsp1_dl.c
+++ b/drivers/media/platform/vsp1/vsp1_dl.c
@@ -627,6 +627,10 @@ static void dl_set_header_less(struct vsp1_dl *dl)
 	dl_write(dl, VI6_DL_BODY_SIZE,
 			(body->reg_count * 8) | VI6_DL_BODY_SIZE_UPD);
 
+#ifdef VSP1_UNDERRUN_WORKAROUND
+	dl->vsp1->dl_addr = body->paddr;
+	dl->vsp1->dl_body = (body->reg_count * 8) | VI6_DL_BODY_SIZE_UPD;
+#endif
 	spin_lock_irqsave(&dl->lock, flags);
 	dl->setting_body = NULL;
 	dl_free_body(dl->next_body);
diff --git a/drivers/media/platform/vsp1/vsp1_drv.c b/drivers/media/platform/vsp1/vsp1_drv.c
index 5d59460..53eb327 100644
--- a/drivers/media/platform/vsp1/vsp1_drv.c
+++ b/drivers/media/platform/vsp1/vsp1_drv.c
@@ -68,10 +68,85 @@ void vsp1_ut_debug_printk(const char *function_name, const char *format, ...)
 	va_end(args);
 }
 
+#ifdef VSP1_UNDERRUN_WORKAROUND
+#define SRCR7_REG		0xe61501cc
+#define	FCPVD0_REG		0xfea27000
+#define	FCPVD1_REG		0xfea2f000
+#define	FCPVD2_REG		0xfea37000
+#define	FCPVD3_REG		0xfea3f000
+
+#define FCP_RST_REG		0x0010
+#define FCP_RST_SOFTRST		0x00000001
+#define FCP_RST_WORKAROUND	0x00000010
+
+#define FCP_STA_REG		0x0018
+#define FCP_STA_ACT		0x00000001
+
+static void __iomem *fcpv_reg[4];
+static const unsigned int fcpvd_offset[] = {
+	FCPVD0_REG, FCPVD1_REG, FCPVD2_REG, FCPVD3_REG
+};
+
+static void vsp1_underrun_workaround(struct vsp1_device *vsp1)
+{
+	unsigned int timeout = 0;
+
+	/* 1. Disable clock stop of VSP */
+	vsp1_write(vsp1, VI6_CLK_CTRL0, VI6_CLK_CTRL0_WORKAROUND);
+	vsp1_write(vsp1, VI6_CLK_CTRL1, VI6_CLK_CTRL1_WORKAROUND);
+	vsp1_write(vsp1, VI6_CLK_DCSWT, VI6_CLK_DCSWT_WORKAROUND1);
+	vsp1_write(vsp1, VI6_CLK_DCSM0, VI6_CLK_DCSM0_WORKAROUND);
+	vsp1_write(vsp1, VI6_CLK_DCSM1, VI6_CLK_DCSM1_WORKAROUND);
+
+	/* 2. Stop operation of VSP except bus access with module reset */
+	vsp1_write(vsp1, VI6_MRESET_ENB0, VI6_MRESET_ENB0_WORKAROUND1);
+	vsp1_write(vsp1, VI6_MRESET_ENB1, VI6_MRESET_ENB1_WORKAROUND);
+	vsp1_write(vsp1, VI6_MRESET, VI6_MRESET_WORKAROUND);
+
+	/* 3. Stop operation of FCPV with software reset */
+	iowrite32(FCP_RST_SOFTRST, fcpv_reg[vsp1->index] + FCP_RST_REG);
+
+	/* 4. Wait until FCP_STA.ACT become 0. */
+	while (1) {
+		if ((ioread32(fcpv_reg[vsp1->index] + FCP_STA_REG) &
+			FCP_STA_ACT) != FCP_STA_ACT)
+			break;
+
+		if (timeout == 100)
+			break;
+		timeout++;
+		udelay(1);
+	}
+
+	/* 5. Initialize the whole FCPV with module reset */
+	iowrite32(FCP_RST_WORKAROUND, fcpv_reg[vsp1->index] + FCP_RST_REG);
+
+	/* 6. Stop the whole operation of VSP with module reset
+	      (note that register setting is not cleared) */
+	vsp1_write(vsp1, VI6_MRESET_ENB0, VI6_MRESET_ENB0_WORKAROUND2);
+	vsp1_write(vsp1, VI6_MRESET_ENB1, VI6_MRESET_ENB1_WORKAROUND);
+	vsp1_write(vsp1, VI6_MRESET, VI6_MRESET_WORKAROUND);
+
+	/* 7. Enable clock stop of VSP */
+	vsp1_write(vsp1, VI6_CLK_CTRL0, 0);
+	vsp1_write(vsp1, VI6_CLK_CTRL1, 0);
+	vsp1_write(vsp1, VI6_CLK_DCSWT, VI6_CLK_DCSWT_WORKAROUND2);
+	vsp1_write(vsp1, VI6_CLK_DCSM0, 0);
+	vsp1_write(vsp1, VI6_CLK_DCSM1, 0);
+
+	/* 8. Restart VSPD */
+#ifdef VSP1_DL_SUPPORT
+	/* Necessary when headerless display list */
+	vsp1_write(vsp1, VI6_DL_HDR_ADDR(0), vsp1->dl_addr);
+	vsp1_write(vsp1, VI6_DL_BODY_SIZE, vsp1->dl_body);
+#endif
+	vsp1_write(vsp1, VI6_CMD(0), VI6_CMD_STRCMD);
+}
+#endif
+
 /* -----------------------------------------------------------------------------
  * Interrupt Handling
  */
-
 static irqreturn_t vsp1_irq_handler(int irq, void *data)
 {
 	u32 mask = VI6_WFP_IRQ_STA_DFE | VI6_WFP_IRQ_STA_FRE
@@ -102,6 +177,11 @@ static irqreturn_t vsp1_irq_handler(int irq, void *data)
 				vsp_und_cnt, dev_name(vsp1->dev));
 		}
 
+#ifdef VSP1_UNDERRUN_WORKAROUND
+		if (status & VI6_WFP_IRQ_STA_UND)
+			vsp1_underrun_workaround(vsp1);
+#endif
+
 		if (status & VI6_WFP_IRQ_STA_FRE) {
 			vsp1_pipeline_frame_end(pipe);
 			ret = IRQ_HANDLED;
@@ -730,6 +810,9 @@ static int vsp1_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, vsp1);
 
+#ifdef VSP1_UNDERRUN_WORKAROUND
+	fcpv_reg[vsp1->index] = ioremap(fcpvd_offset[vsp1->index], 0x20);
+#endif
 	return 0;
 }
 
@@ -739,6 +822,9 @@ static int vsp1_remove(struct platform_device *pdev)
 
 	vsp1_destroy_entities(vsp1);
 
+#ifdef VSP1_UNDERRUN_WORKAROUND
+	iounmap(fcpv_reg[vsp1->index]);
+#endif
 	return 0;
 }
 
diff --git a/drivers/media/platform/vsp1/vsp1_regs.h b/drivers/media/platform/vsp1/vsp1_regs.h
index 274efe84..4a073af 100644
--- a/drivers/media/platform/vsp1/vsp1_regs.h
+++ b/drivers/media/platform/vsp1/vsp1_regs.h
@@ -20,15 +20,39 @@
 #define VI6_CMD(n)			(0x0000 + (n) * 4)
 #define VI6_CMD_STRCMD			(1 << 0)
 
+#define VI6_CLK_CTRL0			0x0010
+#define VI6_CLK_CTRL0_WORKAROUND	0x10010F1F
+
+#define VI6_CLK_CTRL1			0x0014
+#define VI6_CLK_CTRL1_WORKAROUND	0xFF00FFFF
+
 #define VI6_CLK_DCSWT			0x0018
 #define VI6_CLK_DCSWT_CSTPW_MASK	(0xff << 8)
 #define VI6_CLK_DCSWT_CSTPW_SHIFT	8
 #define VI6_CLK_DCSWT_CSTRW_MASK	(0xff << 0)
 #define VI6_CLK_DCSWT_CSTRW_SHIFT	0
+#define VI6_CLK_DCSWT_WORKAROUND1	0x00130808
+#define VI6_CLK_DCSWT_WORKAROUND2	0x00000808
+
+#define VI6_CLK_DCSM0			0x001C
+#define VI6_CLK_DCSM0_WORKAROUND	0x1FFF0F1F
+
+#define VI6_CLK_DCSM1			0x0020
+#define VI6_CLK_DCSM1_WORKAROUND	0xFF00FFFF
 
 #define VI6_SRESET			0x0028
 #define VI6_SRESET_SRTS(n)		(1 << (n))
 
+#define VI6_MRESET_ENB0			0x002C
+#define VI6_MRESET_ENB0_WORKAROUND1	0x0000001F
+#define VI6_MRESET_ENB0_WORKAROUND2	0x30000F1F
+
+#define VI6_MRESET_ENB1			0x0030
+#define VI6_MRESET_ENB1_WORKAROUND	0xFF00FFFF
+
+#define VI6_MRESET			0x0034
+#define VI6_MRESET_WORKAROUND		0x00000001
+
 #define VI6_STATUS			0x0038
 #define VI6_STATUS_SYS_ACT(n)		(1 << ((n) + 8))
 
-- 
1.7.5.4

