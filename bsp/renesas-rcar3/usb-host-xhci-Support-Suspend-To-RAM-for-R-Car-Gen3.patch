From 8642733d1636c0849508e71db2f6a840f0b70048 Mon Sep 17 00:00:00 2001
From: Dien Pham <dien.pham.ry@rvc.renesas.com>
Date: Tue, 5 Jul 2016 20:01:48 +0700
Subject: [PATCH 1655/2066] usb: host: xhci: Support Suspend To RAM for R-Car
 Gen3

---------------------------------
xhci->quirks |= XHCI_SLOW_SUSPEND;

This config is added to ensure for slow speed device
connect to hub is not timeout in handshake progress.
TODO: This solution will be considered to improve
in the future.
---------------------------------

Signed-off-by: Dien Pham <dien.pham.ry@rvc.renesas.com>
[zou:Original patch taken from
git://git.kernel.org/pub/scm/linux/kernel/git/horms/renesas-bsp.git
 v4.9/rcar-3.5.1]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 drivers/usb/host/xhci-plat.c |   46 +++++++++++++++++++++++++++++++++++++++--
 drivers/usb/host/xhci-rcar.c |    2 +
 2 files changed, 45 insertions(+), 3 deletions(-)

diff --git a/drivers/usb/host/xhci-plat.c b/drivers/usb/host/xhci-plat.c
index bd1d860..15be413 100644
--- a/drivers/usb/host/xhci-plat.c
+++ b/drivers/usb/host/xhci-plat.c
@@ -134,7 +134,9 @@ static int xhci_plat_probe(struct platform_device *pdev)
 	struct xhci_hcd		*xhci;
 	struct resource         *res;
 	struct usb_hcd		*hcd;
+#if (!IS_ENABLED(CONFIG_USB_XHCI_RCAR))
 	struct clk              *clk;
+#endif /* CONFIG_USB_XHCI_RCAR */
 	int			ret;
 	int			irq;
 
@@ -174,12 +176,17 @@ static int xhci_plat_probe(struct platform_device *pdev)
 	 * Not all platforms have a clk so it is not an error if the
 	 * clock does not exists.
 	 */
+#if IS_ENABLED(CONFIG_USB_XHCI_RCAR)
+	pm_runtime_enable(&pdev->dev);
+	pm_runtime_get_sync(&pdev->dev);
+#else
 	clk = devm_clk_get(&pdev->dev, NULL);
 	if (!IS_ERR(clk)) {
 		ret = clk_prepare_enable(clk);
 		if (ret)
 			goto put_hcd;
 	}
+#endif /* CONFIG_USB_XHCI_RCAR */
 
 	xhci = hcd_to_xhci(hcd);
 	match = of_match_node(usb_xhci_of_match, node);
@@ -205,7 +212,10 @@ static int xhci_plat_probe(struct platform_device *pdev)
 
 	/* USB 2.0 roothub is stored in the platform_device now. */
 	hcd = platform_get_drvdata(pdev);
+
+#if (!IS_ENABLED(CONFIG_USB_XHCI_RCAR))
 	xhci->clk = clk;
+#endif /* CONFIG_USB_XHCI_RCAR */
 	xhci->shared_hcd = usb_create_shared_hcd(driver, &pdev->dev,
 			dev_name(&pdev->dev), hcd);
 	if (!xhci->shared_hcd) {
@@ -253,8 +263,13 @@ dealloc_usb2_hcd:
 	usb_remove_hcd(hcd);
 
 disable_clk:
+#if IS_ENABLED(CONFIG_USB_XHCI_RCAR)
+	pm_runtime_put_sync(&pdev->dev);
+	pm_runtime_disable(&pdev->dev);
+#else
 	if (!IS_ERR(clk))
 		clk_disable_unprepare(clk);
+#endif /* CONFIG_USB_XHCI_RCAR */
 
 put_hcd:
 	usb_put_hcd(hcd);
@@ -266,16 +281,26 @@ static int xhci_plat_remove(struct platform_device *dev)
 {
 	struct usb_hcd	*hcd = platform_get_drvdata(dev);
 	struct xhci_hcd	*xhci = hcd_to_xhci(hcd);
+#if (!IS_ENABLED(CONFIG_USB_XHCI_RCAR))
 	struct clk *clk = xhci->clk;
+#endif /* CONFIG_USB_XHCI_RCAR */
 
 	usb_remove_hcd(xhci->shared_hcd);
 	usb_phy_shutdown(hcd->usb_phy);
 	usb_put_hcd(xhci->shared_hcd);
 
 	usb_remove_hcd(hcd);
+
+	usb_put_hcd(hcd);
+
+#if IS_ENABLED(CONFIG_USB_XHCI_RCAR)
+	pm_runtime_put_sync(&dev->dev);
+	pm_runtime_disable(&dev->dev);
+#else
 	if (!IS_ERR(clk))
 		clk_disable_unprepare(clk);
-	usb_put_hcd(hcd);
+#endif /* CONFIG_USB_XHCI_RCAR */
+
 	kfree(xhci);
 
 	return 0;
@@ -286,7 +311,7 @@ static int xhci_plat_suspend(struct device *dev)
 {
 	struct usb_hcd	*hcd = dev_get_drvdata(dev);
 	struct xhci_hcd	*xhci = hcd_to_xhci(hcd);
-
+	int ret = 0;
 	/*
 	 * xhci_suspend() needs `do_wakeup` to know whether host is allowed
 	 * to do wakeup during suspend. Since xhci_plat_suspend is currently
@@ -295,7 +320,15 @@ static int xhci_plat_suspend(struct device *dev)
 	 * reconsider this when xhci_plat_suspend enlarges its scope, e.g.,
 	 * also applies to runtime suspend.
 	 */
-	return xhci_suspend(xhci, device_may_wakeup(dev));
+	ret = xhci_suspend(xhci, device_may_wakeup(dev));
+	if (ret)
+		pr_err("%s: xhci_suspend failed, ret: %d\n", __func__, ret);
+
+#if IS_ENABLED(CONFIG_USB_XHCI_RCAR)
+	pm_runtime_put_sync(dev);
+#endif /* CONFIG_USB_XHCI_RCAR */
+
+	return ret;
 }
 
 static int xhci_plat_resume(struct device *dev)
@@ -303,6 +336,13 @@ static int xhci_plat_resume(struct device *dev)
 	struct usb_hcd	*hcd = dev_get_drvdata(dev);
 	struct xhci_hcd	*xhci = hcd_to_xhci(hcd);
 
+#if IS_ENABLED(CONFIG_USB_XHCI_RCAR)
+	pm_runtime_get_sync(dev);
+
+	hcd->driver->reset(hcd);
+	hcd->driver->start(hcd);
+#endif /* CONFIG_USB_XHCI_RCAR */
+
 	return xhci_resume(xhci, 0);
 }
 
diff --git a/drivers/usb/host/xhci-rcar.c b/drivers/usb/host/xhci-rcar.c
index d97f336..d37773b 100644
--- a/drivers/usb/host/xhci-rcar.c
+++ b/drivers/usb/host/xhci-rcar.c
@@ -220,5 +220,7 @@ int xhci_rcar_init_quirk(struct usb_hcd *hcd)
 			xhci_rcar_is_gen3(hcd->self.controller))
 		xhci->quirks |= XHCI_NO_64BIT_SUPPORT;
 
+	xhci->quirks |= XHCI_SLOW_SUSPEND;
+
 	return xhci_rcar_download_firmware(hcd);
 }
-- 
1.7.5.4

