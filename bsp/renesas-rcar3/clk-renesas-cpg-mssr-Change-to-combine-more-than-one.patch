From 49d20a54059050f8c579f33f4eccbc098fed22d9 Mon Sep 17 00:00:00 2001
From: Dien Pham <dien.pham.ry@rvc.renesas.com>
Date: Thu, 26 May 2016 20:09:01 +0700
Subject: [PATCH 1239/2066] clk: renesas: cpg-mssr: Change to combine more
 than one clocks to device

In current source of clock driver, it intends to bind
one pm clock with a device. So RuntimePM just control
one module stop for one device only.

Driver should implement so that only one module clock
is mapped with one device for aligning with upstream.

In fact, there may be more than one clock are bound with a
device, and driver has not updated to cache up with upstream.

So, this patch is intended for backward adaptability with
current drivers.

Signed-off-by: Dien Pham <dien.pham.ry@rvc.renesas.com>
Signed-off-by: Takeshi Kihara <takeshi.kihara.df@renesas.com>
---
 drivers/clk/renesas/renesas-cpg-mssr.c |   51 +++++++++++++++++---------------
 1 files changed, 27 insertions(+), 24 deletions(-)

diff --git a/drivers/clk/renesas/renesas-cpg-mssr.c b/drivers/clk/renesas/renesas-cpg-mssr.c
index e73248a..1929a51 100644
--- a/drivers/clk/renesas/renesas-cpg-mssr.c
+++ b/drivers/clk/renesas/renesas-cpg-mssr.c
@@ -410,6 +410,8 @@ static bool cpg_mssr_is_pm_clk(const struct of_phandle_args *clkspec,
 
 	switch (clkspec->args[0]) {
 	case CPG_CORE:
+		if (!pd->num_core_pm_clks)
+			return true;
 		for (i = 0; i < pd->num_core_pm_clks; i++)
 			if (clkspec->args[1] == pd->core_pm_clks[i])
 				return true;
@@ -431,6 +433,7 @@ int cpg_mssr_attach_dev(struct generic_pm_domain *unused, struct device *dev)
 	struct clk *clk;
 	int i = 0;
 	int error;
+	bool had_clk = false;
 
 	if (!pd) {
 		dev_dbg(dev, "CPG/MSSR clock domain not yet available\n");
@@ -439,40 +442,40 @@ int cpg_mssr_attach_dev(struct generic_pm_domain *unused, struct device *dev)
 
 	while (!of_parse_phandle_with_args(np, "clocks", "#clock-cells", i,
 					   &clkspec)) {
-		if (cpg_mssr_is_pm_clk(&clkspec, pd))
-			goto found;
-
-		of_node_put(clkspec.np);
 		i++;
-	}
-
-	return 0;
-
-found:
-	clk = of_clk_get_from_provider(&clkspec);
-	of_node_put(clkspec.np);
+		if (!cpg_mssr_is_pm_clk(&clkspec, pd))
+			continue;
+
+		if (!had_clk) {
+			error = pm_clk_create(dev);
+			if (error) {
+				dev_err(dev, "pm_clk_create failed %d\n",
+					error);
+				return error;
+			}
+			had_clk = true;
+		}
 
-	if (IS_ERR(clk))
-		return PTR_ERR(clk);
+		clk = of_clk_get_from_provider(&clkspec);
+		of_node_put(clkspec.np);
 
-	error = pm_clk_create(dev);
-	if (error) {
-		dev_err(dev, "pm_clk_create failed %d\n", error);
-		goto fail_put;
-	}
+		if (IS_ERR(clk))
+			goto fail_destroy;
 
-	error = pm_clk_add_clk(dev, clk);
-	if (error) {
-		dev_err(dev, "pm_clk_add_clk %pC failed %d\n", clk, error);
-		goto fail_destroy;
+		error = pm_clk_add_clk(dev, clk);
+		if (error) {
+			dev_err(dev, "pm_clk_add_clk %pC failed %d\n",
+				clk, error);
+			goto fail_put;
+		}
 	}
 
 	return 0;
 
-fail_destroy:
-	pm_clk_destroy(dev);
 fail_put:
 	clk_put(clk);
+fail_destroy:
+	pm_clk_destroy(dev);
 	return error;
 }
 
-- 
1.7.5.4

