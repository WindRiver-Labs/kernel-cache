From 64f90b9ede747ef09ca0423d83d06a4ef4fda91f Mon Sep 17 00:00:00 2001
From: Koji Matsuoka <koji.matsuoka.xm@renesas.com>
Date: Fri, 23 Oct 2015 19:39:15 +0900
Subject: [PATCH 1891/2066] media: i2c: adv7482: Tidy up code

Signed-off-by: Koji Matsuoka <koji.matsuoka.xm@renesas.com>
[zou:Original patch taken from
git://git.kernel.org/pub/scm/linux/kernel/git/horms/renesas-bsp.git
 v4.9/rcar-3.5.1]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 drivers/media/i2c/adv7482.c |  868 +++++++++++--------------------------------
 1 files changed, 216 insertions(+), 652 deletions(-)

diff --git a/drivers/media/i2c/adv7482.c b/drivers/media/i2c/adv7482.c
index c1c7ec5..7a4e030 100644
--- a/drivers/media/i2c/adv7482.c
+++ b/drivers/media/i2c/adv7482.c
@@ -45,8 +45,8 @@
 #define ADV7482_I2C_CP			0x22	/* CP Map */
 #define ADV7482_I2C_HDMI		0x34	/* HDMI Map */
 #define ADV7482_I2C_EDID		0x36	/* EDID Map */
-#define ADV7482_I2C_REPEATER	0x32	/* HDMI RX Repeater Map */
-#define ADV7482_I2C_INFOFRAME	0x31	/* HDMI RX InfoFrame Map */
+#define ADV7482_I2C_REPEATER		0x32	/* HDMI RX Repeater Map */
+#define ADV7482_I2C_INFOFRAME		0x31	/* HDMI RX InfoFrame Map */
 #define ADV7482_I2C_CEC			0x41	/* CEC Map */
 #define ADV7482_I2C_SDP			0x79	/* SDP Map */
 #define ADV7482_I2C_TXB			0x48	/* CSI-TXB Map */
@@ -54,7 +54,6 @@
 #define ADV7482_I2C_WAIT		0xFE	/* Wait x mesec */
 #define ADV7482_I2C_EOR			0xFF	/* End Mark */
 
-
 /****************************************/
 /* ADV7482 IO register definition       */
 /****************************************/
@@ -63,9 +62,9 @@
 #define ADV7482_IO_RD_INFO1_REG	0xDF	/* chip version register */
 #define ADV7482_IO_RD_INFO2_REG	0xE0	/* chip version register */
 
-#define ADV7482_IO_CP_DATAPATH_REG		0x03	/* datapath cntrl */
+#define ADV7482_IO_CP_DATAPATH_REG	0x03	/* datapath ctrl */
 #define ADV7482_IO_CP_COLORSPACE_REG	0x04
-#define ADV7482_IO_CP_VID_STD_REG		0x05	/* Video Standard */
+#define ADV7482_IO_CP_VID_STD_REG	0x05	/* Video Standard */
 
 /* Power Management */
 #define ADV7482_IO_PWR_MAN_REG	0x0C	/* Power management register */
@@ -76,13 +75,13 @@
 #define ADV7482_HDMI_DDC_PWR_ON		0x00	/* Power on */
 #define ADV7482_HDMI_DDC_PWR_OFF	0x01	/* Power down */
 
-#define ADV7482_IO_CP_VID_STD_480I		0x40
-#define ADV7482_IO_CP_VID_STD_576I		0x41
-#define ADV7482_IO_CP_VID_STD_480P		0x4A
-#define ADV7482_IO_CP_VID_STD_576P		0x4B
-#define ADV7482_IO_CP_VID_STD_720P		0x53
-#define ADV7482_IO_CP_VID_STD_1080I		0x54
-#define ADV7482_IO_CP_VID_STD_1080P		0x5E
+#define ADV7482_IO_CP_VID_STD_480I	0x40
+#define ADV7482_IO_CP_VID_STD_576I	0x41
+#define ADV7482_IO_CP_VID_STD_480P	0x4A
+#define ADV7482_IO_CP_VID_STD_576P	0x4B
+#define ADV7482_IO_CP_VID_STD_720P	0x53
+#define ADV7482_IO_CP_VID_STD_1080I	0x54
+#define ADV7482_IO_CP_VID_STD_1080P	0x5E
 #define ADV7482_IO_CP_VID_STD_SVGA56	0x80
 #define ADV7482_IO_CP_VID_STD_SVGA60	0x81
 #define ADV7482_IO_CP_VID_STD_SVGA72	0x82
@@ -90,14 +89,14 @@
 #define ADV7482_IO_CP_VID_STD_SVGA85	0x84
 #define ADV7482_IO_CP_VID_STD_SXGA60	0x85
 #define ADV7482_IO_CP_VID_STD_SXGA75	0x86
-#define ADV7482_IO_CP_VID_STD_VGA60		0x88
-#define ADV7482_IO_CP_VID_STD_VGA72		0x89
-#define ADV7482_IO_CP_VID_STD_VGA75		0x8A
-#define ADV7482_IO_CP_VID_STD_VGA85		0x8B
-#define ADV7482_IO_CP_VID_STD_XGA60		0x8C
-#define ADV7482_IO_CP_VID_STD_XGA70		0x8D
-#define ADV7482_IO_CP_VID_STD_XGA75		0x8E
-#define ADV7482_IO_CP_VID_STD_XGA85		0x8F
+#define ADV7482_IO_CP_VID_STD_VGA60	0x88
+#define ADV7482_IO_CP_VID_STD_VGA72	0x89
+#define ADV7482_IO_CP_VID_STD_VGA75	0x8A
+#define ADV7482_IO_CP_VID_STD_VGA85	0x8B
+#define ADV7482_IO_CP_VID_STD_XGA60	0x8C
+#define ADV7482_IO_CP_VID_STD_XGA70	0x8D
+#define ADV7482_IO_CP_VID_STD_XGA75	0x8E
+#define ADV7482_IO_CP_VID_STD_XGA85	0x8F
 #define ADV7482_IO_CP_VID_STD_UXGA60	0x96
 
 #define ADV7482_IO_CSI4_EN_ENABLE       0x80
@@ -107,36 +106,32 @@
 #define ADV7482_IO_CSI1_EN_DISABLE      0x00
 
 /****************************************/
-/* ADV7482 DPLL register definition     */
-/****************************************/
-
-/****************************************/
 /* ADV7482 CP register definition       */
 /****************************************/
 
 /* Contrast Control */
 #define ADV7482_CP_CON_REG	0x3a	/* Contrast (unsigned) */
-#define ADV7482_CP_CON_MIN	0		/* Minimum contrast */
-#define ADV7482_CP_CON_DEF	128		/* Default */
-#define ADV7482_CP_CON_MAX	255		/* Maximum contrast */
+#define ADV7482_CP_CON_MIN	0	/* Minimum contrast */
+#define ADV7482_CP_CON_DEF	128	/* Default */
+#define ADV7482_CP_CON_MAX	255	/* Maximum contrast */
 
 /* Saturation Control */
 #define ADV7482_CP_SAT_REG	0x3b	/* Saturation (unsigned) */
-#define ADV7482_CP_SAT_MIN	0		/* Minimum saturation */
-#define ADV7482_CP_SAT_DEF	128		/* Default */
-#define ADV7482_CP_SAT_MAX	255		/* Maximum saturation */
+#define ADV7482_CP_SAT_MIN	0	/* Minimum saturation */
+#define ADV7482_CP_SAT_DEF	128	/* Default */
+#define ADV7482_CP_SAT_MAX	255	/* Maximum saturation */
 
 /* Brightness Control */
 #define ADV7482_CP_BRI_REG	0x3c	/* Brightness (signed) */
 #define ADV7482_CP_BRI_MIN	-128	/* Luma is -512d */
-#define ADV7482_CP_BRI_DEF	0		/* Luma is 0 */
-#define ADV7482_CP_BRI_MAX	127		/* Luma is 508d */
+#define ADV7482_CP_BRI_DEF	0	/* Luma is 0 */
+#define ADV7482_CP_BRI_MAX	127	/* Luma is 508d */
 
 /* Hue Control */
 #define ADV7482_CP_HUE_REG	0x3d	/* Hue (unsigned) */
-#define ADV7482_CP_HUE_MIN	0		/* -90 degree */
-#define ADV7482_CP_HUE_DEF	0		/* -90 degree */
-#define ADV7482_CP_HUE_MAX	255		/* +90 degree */
+#define ADV7482_CP_HUE_MIN	0	/* -90 degree */
+#define ADV7482_CP_HUE_DEF	0	/* -90 degree */
+#define ADV7482_CP_HUE_MAX	255	/* +90 degree */
 
 /* Video adjustment register */
 #define ADV7482_CP_VID_ADJ_REG		0x3e
@@ -145,7 +140,6 @@
 /* Enable color controls */
 #define ADV7482_CP_VID_ADJ_ENABLE	0x80
 
-
 /****************************************/
 /* ADV7482 HDMI register definition     */
 /****************************************/
@@ -155,20 +149,20 @@
 /* VERT_FILTER_LOCKED flag */
 #define ADV7482_HDMI_VF_LOCKED_FLG		0x80
 /* DE_REGEN_FILTER_LOCKED flag */
-#define ADV7482_HDMI_DERF_LOCKED_FLG	0x20
+#define ADV7482_HDMI_DERF_LOCKED_FLG		0x20
 /* LINE_WIDTH[12:8] mask */
-#define ADV7482_HDMI_LWIDTH_MSBS_MASK	0x1F
+#define ADV7482_HDMI_LWIDTH_MSBS_MASK		0x1F
 
 /* LINE_WIDTH[7:0] register */
 #define ADV7482_HDMI_LWIDTH_REG			0x08
 
 /* FIELD0_HEIGHT[12:8] register */
-#define ADV7482_HDMI_F0HEIGHT_MSBS_REG	0x09
+#define ADV7482_HDMI_F0HEIGHT_MSBS_REG		0x09
 /* FIELD0_HEIGHT[12:8] mask */
-#define ADV7482_HDMI_F0HEIGHT_MSBS_MASK	0x1F
+#define ADV7482_HDMI_F0HEIGHT_MSBS_MASK		0x1F
 
 /* FIELD0_HEIGHT[7:0] register */
-#define ADV7482_HDMI_F0HEIGHT_LSBS_REG	0x0A
+#define ADV7482_HDMI_F0HEIGHT_LSBS_REG		0x0A
 
 /* HDMI status register */
 #define ADV7482_HDMI_STATUS2_REG		0x0B
@@ -177,45 +171,27 @@
 /* HDMI_INTERLACED flag */
 #define ADV7482_HDMI_IP_FLAG			0x20
 /* FIELD1_HEIGHT[12:8] mask */
-#define ADV7482_HDMI_F1HEIGHT_MSBS_MASK	0x1F
+#define ADV7482_HDMI_F1HEIGHT_MSBS_MASK		0x1F
 
 /* FIELD1_HEIGHT[7:0] register */
 #define ADV7482_HDMI_F1HEIGHT_REG		0x0C
 
-/****************************************/
-/* ADV7482 EDID register definition     */
-/****************************************/
-
-/****************************************/
-/* ADV7482 Repeater register definition */
-/****************************************/
-
-/****************************************/
-/* ADV7482 InfoFrame register definition*/
-/****************************************/
-
-/****************************************/
-/* ADV7482 CEC register definition      */
-/****************************************/
+struct adv7482_sdp_main_info {
+	u8			status_reg_10;
+};
 
 /****************************************/
 /* ADV7482 SDP register definition      */
 /****************************************/
 
-struct adv7482_sdp_main_info {
-	u8			status1;
-	u8			status2;
-	u8			status3;
-};
-
-#define ADV7482_SDP_MAIN_MAP 0x00
-#define ADV7482_SDP_SUB_MAP1 0x20
-#define ADV7482_SDP_SUB_MAP2 0x40
+#define ADV7482_SDP_MAIN_MAP	0x00
+#define ADV7482_SDP_SUB_MAP1	0x20
+#define ADV7482_SDP_SUB_MAP2	0x40
 
-#define ADV7482_SDP_NO_RO_MAIN_MAP 0x00
-#define ADV7482_SDP_RO_MAIN_MAP    0x01
-#define ADV7482_SDP_RO_SUB_MAP1    0x02
-#define ADV7482_SDP_RO_SUB_MAP2    0x03
+#define ADV7482_SDP_NO_RO_MAIN_MAP	0x00
+#define ADV7482_SDP_RO_MAIN_MAP		0x01
+#define ADV7482_SDP_RO_SUB_MAP1		0x02
+#define ADV7482_SDP_RO_SUB_MAP2		0x03
 
 #define ADV7482_SDP_MAIN_MAP_RW \
 			(ADV7482_SDP_MAIN_MAP | ADV7482_SDP_NO_RO_MAIN_MAP)
@@ -224,23 +200,23 @@ struct adv7482_sdp_main_info {
 #define ADV7482_SDP_STD_AD_PAL_BG_NTSC_J_SECAM_PED	0x1
 #define ADV7482_SDP_STD_AD_PAL_N_NTSC_J_SECAM		0x2
 #define ADV7482_SDP_STD_AD_PAL_N_NTSC_M_SECAM		0x3
-#define ADV7482_SDP_STD_NTSC_J					0x4
-#define ADV7482_SDP_STD_NTSC_M					0x5
-#define ADV7482_SDP_STD_PAL60					0x6
-#define ADV7482_SDP_STD_NTSC_443				0x7
-#define ADV7482_SDP_STD_PAL_BG					0x8
-#define ADV7482_SDP_STD_PAL_N					0x9
-#define ADV7482_SDP_STD_PAL_M					0xa
-#define ADV7482_SDP_STD_PAL_M_PED				0xb
-#define ADV7482_SDP_STD_PAL_COMB_N				0xc
+#define ADV7482_SDP_STD_NTSC_J				0x4
+#define ADV7482_SDP_STD_NTSC_M				0x5
+#define ADV7482_SDP_STD_PAL60				0x6
+#define ADV7482_SDP_STD_NTSC_443			0x7
+#define ADV7482_SDP_STD_PAL_BG				0x8
+#define ADV7482_SDP_STD_PAL_N				0x9
+#define ADV7482_SDP_STD_PAL_M				0xa
+#define ADV7482_SDP_STD_PAL_M_PED			0xb
+#define ADV7482_SDP_STD_PAL_COMB_N			0xc
 #define ADV7482_SDP_STD_PAL_COMB_N_PED			0xd
-#define ADV7482_SDP_STD_PAL_SECAM				0xe
+#define ADV7482_SDP_STD_PAL_SECAM			0xe
 #define ADV7482_SDP_STD_PAL_SECAM_PED			0xf
 
-#define ADV7482_SDP_REG_INPUT_CONTROL			0x00
+#define ADV7482_SDP_REG_INPUT_CONTROL		0x00
 #define ADV7482_SDP_INPUT_CONTROL_INSEL_MASK	0x0f
 
-#define ADV7482_SDP_REG_INPUT_VIDSEL			0x02
+#define ADV7482_SDP_REG_INPUT_VIDSEL		0x02
 
 #define ADV7482_SDP_REG_CTRL			0x0e
 
@@ -272,65 +248,41 @@ struct adv7482_sdp_main_info {
 #define ADV7482_SDP_SAT_DEF		128
 #define ADV7482_SDP_SAT_MAX		255
 
-#define ADV7482_SDP_INPUT_CVBS_AIN1 0x00
-#define ADV7482_SDP_INPUT_CVBS_AIN2 0x01
-#define ADV7482_SDP_INPUT_CVBS_AIN3 0x02
-#define ADV7482_SDP_INPUT_CVBS_AIN4 0x03
-#define ADV7482_SDP_INPUT_CVBS_AIN5 0x04
-#define ADV7482_SDP_INPUT_CVBS_AIN6 0x05
-#define ADV7482_SDP_INPUT_CVBS_AIN7 0x06
-#define ADV7482_SDP_INPUT_CVBS_AIN8 0x07
-#define ADV7482_SDP_INPUT_SVIDEO_AIN1_AIN2 0x08
-#define ADV7482_SDP_INPUT_SVIDEO_AIN3_AIN4 0x09
-#define ADV7482_SDP_INPUT_SVIDEO_AIN5_AIN6 0x0a
-#define ADV7482_SDP_INPUT_SVIDEO_AIN7_AIN8 0x0b
-#define ADV7482_SDP_INPUT_YPRPB_AIN1_AIN2_AIN3 0x0c
-#define ADV7482_SDP_INPUT_YPRPB_AIN4_AIN5_AIN6 0x0d
-#define ADV7482_SDP_INPUT_DIFF_CVBS_AIN1_AIN2 0x0e
-#define ADV7482_SDP_INPUT_DIFF_CVBS_AIN3_AIN4 0x0f
-#define ADV7482_SDP_INPUT_DIFF_CVBS_AIN5_AIN6 0x10
-#define ADV7482_SDP_INPUT_DIFF_CVBS_AIN7_AIN8 0x11
-
-#define ADV7482_SDP_REG_STATUS1			0x10
-#define ADV7482_SDP_STATUS1_IN_LOCK		0x01
-
-#define ADV7482_SDP_STATUS1_AUTOD_MASK		0x70
-#define ADV7482_SDP_STATUS1_AUTOD_NTSM_M_J	0x00
-#define ADV7482_SDP_STATUS1_AUTOD_NTSC_4_43 0x10
-#define ADV7482_SDP_STATUS1_AUTOD_PAL_M		0x20
-#define ADV7482_SDP_STATUS1_AUTOD_PAL_60	0x30
-#define ADV7482_SDP_STATUS1_AUTOD_PAL_B_G	0x40
-#define ADV7482_SDP_STATUS1_AUTOD_SECAM		0x50
-#define ADV7482_SDP_STATUS1_AUTOD_PAL_COMB	0x60
-#define ADV7482_SDP_STATUS1_AUTOD_SECAM_525	0x70
-
-char *adv7482_ad_result[] = {
-	"NTSM-MJ",
-	"NTSC-443",
-	"PAL-M",
-	"PAL-60",
-	"PAL-BGHID",
-	"PAL-Combination N",
-	"SECAM 525"
-};
-/****************************************/
-/* ADV7482 TXA register definition      */
-/****************************************/
-
-/****************************************/
-/* ADV7482 TXB register definition      */
-/****************************************/
-
-
-/****************************************/
-/* ADV7482 other definition             */
-/****************************************/
+#define ADV7482_SDP_INPUT_CVBS_AIN1		0x00
+#define ADV7482_SDP_INPUT_CVBS_AIN2		0x01
+#define ADV7482_SDP_INPUT_CVBS_AIN3		0x02
+#define ADV7482_SDP_INPUT_CVBS_AIN4		0x03
+#define ADV7482_SDP_INPUT_CVBS_AIN5		0x04
+#define ADV7482_SDP_INPUT_CVBS_AIN6		0x05
+#define ADV7482_SDP_INPUT_CVBS_AIN7		0x06
+#define ADV7482_SDP_INPUT_CVBS_AIN8		0x07
+#define ADV7482_SDP_INPUT_SVIDEO_AIN1_AIN2	0x08
+#define ADV7482_SDP_INPUT_SVIDEO_AIN3_AIN4	0x09
+#define ADV7482_SDP_INPUT_SVIDEO_AIN5_AIN6	0x0a
+#define ADV7482_SDP_INPUT_SVIDEO_AIN7_AIN8	0x0b
+#define ADV7482_SDP_INPUT_YPRPB_AIN1_AIN2_AIN3	0x0c
+#define ADV7482_SDP_INPUT_YPRPB_AIN4_AIN5_AIN6	0x0d
+#define ADV7482_SDP_INPUT_DIFF_CVBS_AIN1_AIN2	0x0e
+#define ADV7482_SDP_INPUT_DIFF_CVBS_AIN3_AIN4	0x0f
+#define ADV7482_SDP_INPUT_DIFF_CVBS_AIN5_AIN6	0x10
+#define ADV7482_SDP_INPUT_DIFF_CVBS_AIN7_AIN8	0x11
+
+#define ADV7482_SDP_R_REG_10			0x10
+#define ADV7482_SDP_R_REG_10_IN_LOCK		0x01
+
+#define ADV7482_SDP_R_REG_10_AUTOD_MASK		0x70
+#define ADV7482_SDP_R_REG_10_AUTOD_NTSM_M_J	0x00
+#define ADV7482_SDP_R_REG_10_AUTOD_NTSC_4_43	0x10
+#define ADV7482_SDP_R_REG_10_AUTOD_PAL_M	0x20
+#define ADV7482_SDP_R_REG_10_AUTOD_PAL_60	0x30
+#define ADV7482_SDP_R_REG_10_AUTOD_PAL_B_G	0x40
+#define ADV7482_SDP_R_REG_10_AUTOD_SECAM	0x50
+#define ADV7482_SDP_R_REG_10_AUTOD_PAL_COMB	0x60
+#define ADV7482_SDP_R_REG_10_AUTOD_SECAM_525	0x70
 
 #define ADV7482_MAX_WIDTH		1920
 #define ADV7482_MAX_HEIGHT		1080
 
-
-
 /****************************************/
 /* ADV7482 structure definition         */
 /****************************************/
@@ -355,7 +307,6 @@ static const struct adv7482_reg_value adv7482_sw_reset[] = {
 	{ADV7482_I2C_IO, 0xF2, 0x01},	/* Enable I2C Read Auto-Increment */
 
 	{ADV7482_I2C_EOR, 0xFF, 0xFF}	/* End of register table */
-
 };
 
 /*
@@ -363,18 +314,17 @@ static const struct adv7482_reg_value adv7482_sw_reset[] = {
 */
 #define SET_I2C_SLAVE_ADDRESS() \
 /* I2C Slave Address settings */ \
-{ADV7482_I2C_IO, 0xF3, ADV7482_I2C_DPLL*2},		/* DPLL Map */ \
-{ADV7482_I2C_IO, 0xF4, ADV7482_I2C_CP*2},		/* CP Map */ \
-{ADV7482_I2C_IO, 0xF5, ADV7482_I2C_HDMI*2},		/* HDMI Map */ \
-{ADV7482_I2C_IO, 0xF6, ADV7482_I2C_EDID*2},		/* EDID Map */ \
+{ADV7482_I2C_IO, 0xF3, ADV7482_I2C_DPLL*2},	/* DPLL Map */ \
+{ADV7482_I2C_IO, 0xF4, ADV7482_I2C_CP*2},	/* CP Map */ \
+{ADV7482_I2C_IO, 0xF5, ADV7482_I2C_HDMI*2},	/* HDMI Map */ \
+{ADV7482_I2C_IO, 0xF6, ADV7482_I2C_EDID*2},	/* EDID Map */ \
 {ADV7482_I2C_IO, 0xF7, ADV7482_I2C_REPEATER*2},	/* HDMI RX Repeater Map */ \
 {ADV7482_I2C_IO, 0xF8, ADV7482_I2C_INFOFRAME*2},/* HDMI RX InfoFrame Map */ \
 /* [FIXME] setting CBUSMap Address */ \
-{ADV7482_I2C_IO, 0xFA, ADV7482_I2C_CEC*2},		/* CEC Map */ \
-{ADV7482_I2C_IO, 0xFB, ADV7482_I2C_SDP*2},		/* SDP Map */ \
-{ADV7482_I2C_IO, 0xFC, ADV7482_I2C_TXB*2},		/* CSI-TXB Map */ \
-{ADV7482_I2C_IO, 0xFD, ADV7482_I2C_TXA*2},		/* CSI-TXA Map */
-
+{ADV7482_I2C_IO, 0xFA, ADV7482_I2C_CEC*2},	/* CEC Map */ \
+{ADV7482_I2C_IO, 0xFB, ADV7482_I2C_SDP*2},	/* SDP Map */ \
+{ADV7482_I2C_IO, 0xFC, ADV7482_I2C_TXB*2},	/* CSI-TXB Map */ \
+{ADV7482_I2C_IO, 0xFD, ADV7482_I2C_TXA*2},	/* CSI-TXA Map */
 
 static const struct adv7482_reg_value adv7482_set_slave_address[] = {
 
@@ -384,99 +334,10 @@ static const struct adv7482_reg_value adv7482_set_slave_address[] = {
 };
 
 /*
- Supported Formats For Script Below - 1920x1080p60, 1920x1080p50,
-	1280x1024(SXGA)@60, 1600x1200(UXGA)@60
-	01-30 HDMI to MIPI TxA CSI 4-Lane - RGB888, Over 600Mbps
-*/
-static const struct adv7482_reg_value adv7482_init_txa_4lane_over_600[] = {
-	{ADV7482_I2C_IO, 0x05, 0x5E},	/* Setting Vid_Std to 1080p
-		(1920x1080 active resolution) */
-	{ADV7482_I2C_IO, 0xF2, 0x01},	/* Enable I2C Read Auto-Increment */
-
-	/* I2C Slave Address settings */
-	SET_I2C_SLAVE_ADDRESS()
-
-	{ADV7482_I2C_IO, 0x00, 0x40},	/* Disable chip powerdown
-		& Enable HDMI Rx block */
-
-	{ADV7482_I2C_REPEATER, 0x40, 0x83},	/* Enable HDCP 1.1 */
-
-	{ADV7482_I2C_HDMI, 0x00, 0x08},	/* Foreground Channel = A */
-	{ADV7482_I2C_HDMI, 0x98, 0xFF},	/* ADI Required Write */
-	{ADV7482_I2C_HDMI, 0x99, 0xA3},	/* ADI Required Write */
-	{ADV7482_I2C_HDMI, 0x9A, 0x00},	/* ADI Required Write */
-	{ADV7482_I2C_HDMI, 0x9B, 0x0A},	/* ADI Required Write */
-	{ADV7482_I2C_HDMI, 0x9D, 0x40},	/* ADI Required Write */
-	{ADV7482_I2C_HDMI, 0xCB, 0x09},	/* ADI Required Write */
-	{ADV7482_I2C_HDMI, 0x3D, 0x10},	/* ADI Required Write */
-	{ADV7482_I2C_HDMI, 0x3E, 0x7B},	/* ADI Required Write */
-	{ADV7482_I2C_HDMI, 0x3F, 0x5E},	/* ADI Required Write */
-	{ADV7482_I2C_HDMI, 0x4E, 0xFE},	/* ADI Required Write */
-	{ADV7482_I2C_HDMI, 0x4F, 0x18},	/* ADI Required Write */
-	{ADV7482_I2C_HDMI, 0x57, 0xA3},	/* ADI Required Write */
-	{ADV7482_I2C_HDMI, 0x58, 0x04},	/* ADI Required Write */
-	{ADV7482_I2C_HDMI, 0x85, 0x10},	/* ADI Required Write */
-
-	{ADV7482_I2C_HDMI, 0x83, 0x00},	/* Enable All Terminations */
-	{ADV7482_I2C_HDMI, 0xA3, 0x01},	/* ADI Required Write */
-	{ADV7482_I2C_HDMI, 0xBE, 0x00},	/* ADI Required Write */
-
-	{ADV7482_I2C_HDMI, 0x6C, 0x01},	/* HPA Manual Enable */
-	{ADV7482_I2C_HDMI, 0xF8, 0x01},	/* HPA Asserted */
-	{ADV7482_I2C_HDMI, 0x0F, 0x00},	/* Audio Mute Speed Set to Fastest
-		(Smallest Step Size) */
-
-	{ADV7482_I2C_IO, 0x04, 0x02},	/* RGB Out of CP */
-	{ADV7482_I2C_IO, 0x12, 0xF0},
-		/* CSC Depends on ip Packets - SDR 444 */
-	{ADV7482_I2C_IO, 0x17, 0x80},
-		/* Luma & Chroma Values Can Reach 254d */
-	{ADV7482_I2C_IO, 0x03, 0x86},	/* CP-Insert_AV_Code */
-
-	{ADV7482_I2C_CP, 0x7C, 0x00},	/* ADI Required Write */
-
-	{ADV7482_I2C_IO, 0x0C, 0xE0},	/* Enable LLC_DLL & Double LLC Timing */
-	{ADV7482_I2C_IO, 0x0E, 0xDD},	/* LLC/PIX/SPI PINS TRISTATED AUD
-		Outputs Enabled */
-	{ADV7482_I2C_IO, 0x10, 0xA0},	/* Enable 4-lane CSI Tx & Pixel Port */
-
-	{ADV7482_I2C_TXA, 0x00, 0x84},	/* Enable 4-lane MIPI */
-	{ADV7482_I2C_TXA, 0x00, 0xA4},	/* Set Auto DPHY Timing */
-	{ADV7482_I2C_TXA, 0xDB, 0x13},	/* ADI Required Write */
-	{ADV7482_I2C_TXA, 0xD6, 0x07},	/* ADI Required Write */
-	{ADV7482_I2C_TXA, 0xC4, 0x0A},	/* ADI Required Write */
-	{ADV7482_I2C_TXA, 0x71, 0x33},	/* ADI Required Write */
-	{ADV7482_I2C_TXA, 0x72, 0x11},	/* ADI Required Write */
-	{ADV7482_I2C_TXA, 0xF0, 0x00},	/* i2c_dphy_pwdn - 1'b0 */
-	{ADV7482_I2C_TXA, 0x31, 0x82},	/* ADI Required Write */
-	{ADV7482_I2C_TXA, 0x1E, 0x40},	/* ADI Required Write */
-	{ADV7482_I2C_TXA, 0xDA, 0x01},	/* i2c_mipi_pll_en - 1'b1 */
-	{ADV7482_I2C_WAIT, 0x00, 0x02},	/* delay 2 */
-	{ADV7482_I2C_TXA, 0x00, 0x24 },	/* Power-up CSI-TX */
-	{ADV7482_I2C_WAIT, 0x00, 0x01},	/* delay 1 */
-	{ADV7482_I2C_TXA, 0xC1, 0x2B},	/* ADI Required Write */
-	{ADV7482_I2C_WAIT, 0x00, 0x01},	/* delay 1 */
-	{ADV7482_I2C_TXA, 0x31, 0x80},	/* ADI Required Write */
-
-	/* FIXME for debug */
-#ifdef REL_DGB_FORCE_TO_SEND_COLORBAR
-	{ADV7482_I2C_CP, 0x37, 0x81},	/* Output Colorbars Pattern */
-#endif
-
-	{ADV7482_I2C_EOR, 0xFF, 0xFF}	/* End of register table */
-};
-
-/*
  Supported Formats For Script Below -
-   720x480p60, 1280x720p60, 1920x1080i60, 720(1440)x480i60, 720x576p50,
-   1280x720p50, 1920x1080i50, 720(1440)x576i50, 800x600(SVGA)@60,
-   640x480(VGA)@60, 800x480(WVGA)@60, 1024x768(XGA)@60
- 01-29 HDMI to MIPI TxA CSI 4-Lane - RGB888, Up to 600Mbps:
+ 01-29 HDMI to MIPI TxA CSI 4-Lane - RGB888:
 */
-static const struct adv7482_reg_value adv7482_init_txa_4lane_up_to_600[] = {
-	{ADV7482_I2C_IO, 0x05, ADV7482_IO_CP_VID_STD_480P},
-	   /* Setting Vid_Std to 480p (720x480 active resolution) */
-
+static const struct adv7482_reg_value adv7482_init_txa_4lane[] = {
 	/* I2C Slave Address settings */
 	SET_I2C_SLAVE_ADDRESS()
 
@@ -543,11 +404,10 @@ static const struct adv7482_reg_value adv7482_init_txa_4lane_up_to_600[] = {
 	{ADV7482_I2C_WAIT, 0x00, 0x01},	/* delay 1 */
 	{ADV7482_I2C_TXA, 0x31, 0x80},	/* ADI Required Write */
 
-	/* FIXME for debug */
+	/* for debug */
 #ifdef REL_DGB_FORCE_TO_SEND_COLORBAR
 	{ADV7482_I2C_CP, 0x37, 0x81},	/* Output Colorbars Pattern */
 #endif
-
 	{ADV7482_I2C_EOR, 0xFF, 0xFF}	/* End of register table */
 };
 
@@ -591,18 +451,16 @@ static const struct adv7482_reg_value adv7482_init_txb_1lane[] = {
 	{ADV7482_I2C_SDP, 0x17, 0x41},	/* Select SH1 */
 	{ADV7482_I2C_SDP, 0x31, 0x12},	/* ADI Required Write */
 
-
 #ifdef REL_DGB_FORCE_TO_SEND_COLORBAR
 	{ADV7482_I2C_SDP, 0x0C, 0x01},	/* ColorBar */
 	{ADV7482_I2C_SDP, 0x14, 0x01},	/* ColorBar */
 #endif
-
 	{ADV7482_I2C_IO, 0x10, 0x70},	/* Enable 1-Lane MIPI Tx,
 		enable pixel output and route SD through Pixel port */
 
 	{ADV7482_I2C_TXB, 0x00, 0x81},	/* Enable 1-lane MIPI */
 	{ADV7482_I2C_TXB, 0x00, 0xA1},	/* Set Auto DPHY Timing */
-#if 0 /* FIXME */
+#if 0 /* If CVBS input only is used, please enable this code. */
 	{ADV7482_I2C_TXA, 0xF0, 0x00},	/* ADI Required Write */
 	{ADV7482_I2C_TXA, 0xD6, 0x07},	/* ADI Required Write */
 	{ADV7482_I2C_TXA, 0xC0, 0x3C},	/* ADI Required Write */
@@ -631,81 +489,6 @@ static const struct adv7482_reg_value adv7482_init_txb_1lane[] = {
 	{ADV7482_I2C_EOR, 0xFF, 0xFF}	/* End of register table */
 };
 
-/* 08-15 Free-run MIPI TxB CSI 1-Lane - YUV422 8-Bit, NTSC */
-static const struct adv7482_reg_value adv7482_init_freerun_txb_1lane[] = {
-	{ADV7482_I2C_IO, 0x00, 0x30},
-		/* Disable chip powerdown - powerdown Rx */
-	{ADV7482_I2C_IO, 0xF2, 0x01},	/* Enable I2C Read Auto-Increment */
-
-	/* I2C Slave Address settings */
-	SET_I2C_SLAVE_ADDRESS()
-
-	{ADV7482_I2C_IO, 0x0E, 0xFF},	/* LLC/PIX/AUD/SPI PINS TRISTATED */
-
-	{ADV7482_I2C_SDP, ADV7482_SDP_REG_PWR_MAN, ADV7482_SDP_PWR_MAN_ON},
-		/* Exit Power Down Mode */
-	{ADV7482_I2C_SDP, 0x52, 0xCD},	/* ADI Required Write */
-	{ADV7482_I2C_SDP, ADV7482_SDP_REG_INPUT_CONTROL,
-		ADV7482_SDP_INPUT_CVBS_AIN8},	/* INSEL = CVBS in on Ain 8 */
-	{ADV7482_I2C_SDP, ADV7482_SDP_REG_CTRL, 0x80},	/* ADI Required Write */
-	{ADV7482_I2C_SDP, 0x9C, 0x00},	/* ADI Required Write */
-	{ADV7482_I2C_SDP, 0x9C, 0xFF},	/* ADI Required Write */
-	{ADV7482_I2C_SDP, ADV7482_SDP_REG_CTRL, 0x00},	/* ADI Required Write */
-
-	{ADV7482_I2C_SDP, ADV7482_SDP_REG_INPUT_VIDSEL, 0x54},
-		/* ADI Required Write */
-	{ADV7482_I2C_SDP, 0x0C, 0x37},	/* Force free run */
-	{ADV7482_I2C_SDP, 0x14, 0x11},	/* Output Colorbars */
-
-	/* ADI recommended writes for improved video quality */
-	{ADV7482_I2C_SDP, 0x80, 0x51},	/* ADI Required Write */
-	{ADV7482_I2C_SDP, 0x81, 0x51},	/* ADI Required Write */
-	{ADV7482_I2C_SDP, 0x82, 0x68},	/* ADI Required Write */
-
-	{ADV7482_I2C_SDP, 0x03, 0x42},
-		/* Tri-S Output Drivers, PwrDwn 656 pads */
-	{ADV7482_I2C_SDP, 0x04, 0x07},
-		/* Power-up INTRQ pad, & Enable SFL */
-	{ADV7482_I2C_SDP, 0x13, 0x00},	/* ADI Required Write */
-
-	{ADV7482_I2C_SDP, 0x17, 0x41},	/* Select SH1 */
-	{ADV7482_I2C_SDP, 0x31, 0x12},	/* ADI Required Write */
-
-	{ADV7482_I2C_IO, 0x10, 0x70},	/* Enable 1-Lane MIPI Tx,
-		enable pixel output and route SD through Pixel port */
-
-	{ADV7482_I2C_TXB, 0x00, 0x81},	/* Enable 1-lane MIPI */
-	{ADV7482_I2C_TXB, 0x00, 0xA1},	/* Set Auto DPHY Timing */
-
-	{ADV7482_I2C_TXA, 0xF0, 0x00},	/* ADI Required Write */
-	{ADV7482_I2C_TXA, 0xD6, 0x07},	/* ADI Required Write */
-	{ADV7482_I2C_TXA, 0xC0, 0x3C},	/* ADI Required Write */
-	{ADV7482_I2C_TXA, 0xC3, 0x3C},	/* ADI Required Write */
-	{ADV7482_I2C_TXA, 0xC6, 0x3C},	/* ADI Required Write */
-	{ADV7482_I2C_TXA, 0xC9, 0x3C},	/* ADI Required Write */
-	{ADV7482_I2C_TXA, 0xCC, 0x3C},	/* ADI Required Write */
-	{ADV7482_I2C_TXA, 0xD5, 0x03},	/* ADI Required Write */
-
-
-	{ADV7482_I2C_TXB, 0xD2, 0x40},	/* ADI Required Write */
-	{ADV7482_I2C_TXB, 0xC4, 0x0A},	/* ADI Required Write */
-	{ADV7482_I2C_TXB, 0x71, 0x33},	/* ADI Required Write */
-	{ADV7482_I2C_TXB, 0x72, 0x11},	/* ADI Required Write */
-	{ADV7482_I2C_TXB, 0xF0, 0x00},	/* i2c_dphy_pwdn - 1'b0 */
-	{ADV7482_I2C_TXB, 0x31, 0x82},	/* ADI Required Write */
-	{ADV7482_I2C_TXB, 0x1E, 0x40},	/* ADI Required Write */
-	{ADV7482_I2C_TXB, 0xDA, 0x01},	/* i2c_mipi_pll_en - 1'b1 */
-
-	{ADV7482_I2C_WAIT, 0x00, 0x02},	/* delay 2 */
-	{ADV7482_I2C_TXB, 0x00, 0x21 },	/* Power-up CSI-TX */
-	{ADV7482_I2C_WAIT, 0x00, 0x01},	/* delay 1 */
-	{ADV7482_I2C_TXB, 0xC1, 0x2B},	/* ADI Required Write */
-	{ADV7482_I2C_WAIT, 0x00, 0x01},	/* delay 1 */
-	{ADV7482_I2C_TXB, 0x31, 0x80},	/* ADI Required Write */
-
-	{ADV7482_I2C_EOR, 0xFF, 0xFF}	/* End of register table */
-};
-
 static const struct adv7482_reg_value adv7482_power_up_txa_4lane[] = {
 
 	{ADV7482_I2C_TXA, 0x00, 0x84},	/* Enable 4-lane MIPI */
@@ -722,7 +505,6 @@ static const struct adv7482_reg_value adv7482_power_up_txa_4lane[] = {
 	{ADV7482_I2C_TXA, 0x31, 0x80},	/* ADI Required Write */
 
 	{ADV7482_I2C_EOR, 0xFF, 0xFF}	/* End of register table */
-
 };
 
 static const struct adv7482_reg_value adv7482_power_down_txa_4lane[] = {
@@ -734,7 +516,6 @@ static const struct adv7482_reg_value adv7482_power_down_txa_4lane[] = {
 	{ADV7482_I2C_TXA, 0xC1, 0x3B},	/* ADI Required Write */
 
 	{ADV7482_I2C_EOR, 0xFF, 0xFF}	/* End of register table */
-
 };
 
 static const struct adv7482_reg_value adv7482_power_up_txb_1lane[] = {
@@ -753,7 +534,6 @@ static const struct adv7482_reg_value adv7482_power_up_txb_1lane[] = {
 	{ADV7482_I2C_TXB, 0x31, 0x80},	/* ADI Required Write */
 
 	{ADV7482_I2C_EOR, 0xFF, 0xFF}	/* End of register table */
-
 };
 
 static const struct adv7482_reg_value adv7482_power_down_txb_1lane[] = {
@@ -765,7 +545,6 @@ static const struct adv7482_reg_value adv7482_power_down_txb_1lane[] = {
 	{ADV7482_I2C_TXB, 0xC1, 0x3B},	/* ADI Required Write */
 
 	{ADV7482_I2C_EOR, 0xFF, 0xFF}	/* End of register table */
-
 };
 
 static const struct adv7482_reg_value adv7482_power_up_hdmi_rx[] = {
@@ -790,61 +569,21 @@ static const struct adv7482_reg_value adv7482_enable_csi4_csi1[] = {
 	{ADV7482_I2C_EOR, 0xFF, 0xFF}	/* End of register table */
 };
 
-/* Register parameters for 480p */
-static const struct adv7482_reg_value adv7482_parms_480P[] = {
-	/* FIX ME */
-
-	{ADV7482_I2C_EOR, 0xFF, 0xFF}		/* End of register table */
-};
-
-/* Register parameters for 720p */
-static const struct adv7482_reg_value adv7482_parms_720P60[] = {
-	/* FIX ME */
-
-	{ADV7482_I2C_EOR, 0xFF, 0xFF}		/* End of register table */
-};
-
-/* Register parameters for 1080I60 */
-static const struct adv7482_reg_value adv7482_parms_1080I60[] = {
-	/* FIX ME */
-
-	{ADV7482_I2C_EOR, 0xFF, 0xFF}		/* End of register table */
-};
-
-#if 0
-struct adv7482_color_format {
-	enum v4l2_mbus_pixelcode code;
-	enum v4l2_colorspace colorspace;
-};
-
-/* supported color format list */
-static const struct adv7482_color_format adv7482_cfmts[] = {
-	{
-		.code		= V4L2_MBUS_FMT_RGB888_1X24,
-		.colorspace	= V4L2_COLORSPACE_SRGB,
-	},
-};
-#endif
-
 enum decoder_input_interface {
 	DECODER_INPUT_INTERFACE_RGB888,
 	DECODER_INPUT_INTERFACE_YCBCR422,
 };
 
-char *decoder_input_interface_name[] = {
-	"RGB888",
-	"YCbCr422"
-};
 /**
  * struct adv7482_link_config - Describes adv7482 hardware configuration
  * @input_colorspace:		The input colorspace (RGB, YUV444, YUV422)
  */
 struct adv7482_link_config {
-	enum decoder_input_interface input_interface;
-	struct adv7482_reg_value *regs;
+	enum decoder_input_interface	input_interface;
+	struct adv7482_reg_value	*regs;
 
-	struct adv7482_reg_value *power_up;
-	struct adv7482_reg_value *power_down;
+	struct adv7482_reg_value	*power_up;
+	struct adv7482_reg_value	*power_down;
 
 	int (*init_device)(void *);
 	int (*init_controls)(void *);
@@ -859,62 +598,36 @@ struct adv7482_link_config {
 	int (*s_routing)(void *);
 	int (*g_mbus_config)(void *);
 
-	struct device *dev;
-	bool	sw_reset;
-	bool	hdmi_in;
-	bool	sdp_in;
+	struct device	*dev;
+	bool		sw_reset;
+	bool		hdmi_in;
+	bool		sdp_in;
 
 };
 
 struct adv7482_state {
-	struct v4l2_ctrl_handler ctrl_hdl;
-	struct v4l2_subdev	sd;
-	struct media_pad	pad;
-	struct mutex		mutex; /* mutual excl. when accessing chip */
-	int			irq;
-	v4l2_std_id		curr_norm;
-	bool			autodetect;
-	bool			powered;
+	struct v4l2_ctrl_handler		ctrl_hdl;
+	struct v4l2_subdev			sd;
+	struct media_pad			pad;
+	 /* mutual excl. when accessing chip */
+	struct mutex				mutex;
+	int					irq;
+	v4l2_std_id				curr_norm;
+	bool					autodetect;
+	bool					powered;
 	const struct adv7482_color_format	*cfmt;
-	u32			width;
-	u32			height;
+	u32					width;
+	u32					height;
 
-	struct i2c_client	*client;
-	unsigned int		register_page;
-	struct i2c_client	*csi_client;
-	enum v4l2_field		field;
+	struct i2c_client			*client;
+	unsigned int				register_page;
+	struct i2c_client			*csi_client;
+	enum v4l2_field				field;
 
-	struct device *dev;
-	struct adv7482_link_config mipi_csi2_link[2];
+	struct device				*dev;
+	struct adv7482_link_config		mipi_csi2_link[2];
 };
 
-/*
-   FIXME for TRIAL
-*/
-
-static int dummy_csi2_control_interrupts(
-		struct adv7482_link_config *config, int enable)
-{
-	void __iomem *csi_reg;
-	uint32_t dataL;
-
-	if (config->input_interface == DECODER_INPUT_INTERFACE_YCBCR422)
-		csi_reg = ioremap_nocache(0xFEA80030, 0x10);
-	else
-		csi_reg = ioremap_nocache(0xFEAA0030, 0x10);
-
-	if (enable)
-		dataL = 0x000008000; /* only crc error */
-	else
-		dataL = 0x0;
-
-	writel(dataL, csi_reg + 0x000); /* INTEN */
-
-	iounmap(csi_reg);
-
-	return 0;
-}
-
 /*****************************************************************************/
 /*  Private functions                                                        */
 /*****************************************************************************/
@@ -952,11 +665,7 @@ static int adv7482_write_registers(struct i2c_client *client,
 	while (ADV7482_I2C_EOR != regs->addr) {
 
 		if (ADV7482_I2C_WAIT == regs->addr)
-#if 1 /* FIXME */
-			msleep(regs->value*10);
-#else
 			msleep(regs->value);
-#endif
 		else {
 			msg.addr = regs->addr;
 			data_buf[0] = regs->reg;
@@ -976,7 +685,7 @@ static int adv7482_write_registers(struct i2c_client *client,
  * adv7482_write_register() - Write adv7482 device register
  * @client: pointer to i2c_client structure
  * @addr: i2c slave address of adv7482 device
- * @reg: adv7612 device register address
+ * @reg: adv7482 device register address
  * @value: the value to be written
  *
  * Write the specified adv7482 register's value.
@@ -1003,7 +712,7 @@ static int adv7482_write_register(struct i2c_client *client,
  * adv7482_read_register() - Read adv7482 device register
  * @client: pointer to i2c_client structure
  * @addr: i2c slave address of adv7482 device
- * @reg: adv7612 device register address
+ * @reg: adv7482 device register address
  * @value: pointer to the value
  *
  * Read the specified adv7482 register's value.
@@ -1049,114 +758,48 @@ static int adv7482_read_sdp_main_info(struct i2c_client *client,
 	if (ret < 0)
 		return ret;
 
-	/* status1 */
-	ret = adv7482_read_register(client, ADV7482_I2C_SDP,
-			ADV7482_SDP_REG_STATUS1, &value);
-	if (ret < 0)
-		return ret;
-
-	info->status1 = value;
-
-	/* xxx */
-	ret = adv7482_read_register(client, ADV7482_I2C_SDP,
-			0x12, &value);
-	if (ret < 0)
-		return ret;
-
-	/* xxx */
-	ret = adv7482_read_register(client, ADV7482_I2C_SDP,
-			0x13, &value);
-	if (ret < 0)
-		return ret;
-
-	/* xxx */
-	ret = adv7482_read_register(client, ADV7482_I2C_SDP,
-			0x90, &value);
-	if (ret < 0)
-		return ret;
-
-#if 0 /* FIXME */
-	/* status2 */
-	ret = adv7482_read_register(client, ADV7482_I2C_SDP,
-			ADV7482_SDP_REG_STATUS2, &value);
-	if (ret < 0)
-		return ret;
-
-	info->status2 = value;
-
-	/* status3 */
+	/* status_reg_10 */
 	ret = adv7482_read_register(client, ADV7482_I2C_SDP,
-			ADV7482_SDP_REG_STATUS3, &value);
+			ADV7482_SDP_R_REG_10, &value);
 	if (ret < 0)
 		return ret;
 
-	info->status3 = value;
-#else
-	info->status2 = 0;
-	info->status3 = 0;
-#endif
+	info->status_reg_10 = value;
 
 	return ret;
 }
 
-static v4l2_std_id adv7482_std_to_v4l2(u8 status1)
+static v4l2_std_id adv7482_std_to_v4l2(u8 status_reg_10)
 {
 	/* in case V4L2_IN_ST_NO_SIGNAL */
-	if (!(status1 & ADV7482_SDP_STATUS1_IN_LOCK))
+	if (!(status_reg_10 & ADV7482_SDP_R_REG_10_IN_LOCK))
 		return V4L2_STD_UNKNOWN;
 
-	switch (status1 & ADV7482_SDP_STATUS1_AUTOD_MASK) {
-	case ADV7482_SDP_STATUS1_AUTOD_NTSM_M_J:
+	switch (status_reg_10 & ADV7482_SDP_R_REG_10_AUTOD_MASK) {
+	case ADV7482_SDP_R_REG_10_AUTOD_NTSM_M_J:
 		return V4L2_STD_NTSC;
-	case ADV7482_SDP_STATUS1_AUTOD_NTSC_4_43:
+	case ADV7482_SDP_R_REG_10_AUTOD_NTSC_4_43:
 		return V4L2_STD_NTSC_443;
-	case ADV7482_SDP_STATUS1_AUTOD_PAL_M:
+	case ADV7482_SDP_R_REG_10_AUTOD_PAL_M:
 		return V4L2_STD_PAL_M;
-	case ADV7482_SDP_STATUS1_AUTOD_PAL_60:
+	case ADV7482_SDP_R_REG_10_AUTOD_PAL_60:
 		return V4L2_STD_PAL_60;
-	case ADV7482_SDP_STATUS1_AUTOD_PAL_B_G:
+	case ADV7482_SDP_R_REG_10_AUTOD_PAL_B_G:
 		return V4L2_STD_PAL;
-	case ADV7482_SDP_STATUS1_AUTOD_SECAM:
+	case ADV7482_SDP_R_REG_10_AUTOD_SECAM:
 		return V4L2_STD_SECAM;
-	case ADV7482_SDP_STATUS1_AUTOD_PAL_COMB:
+	case ADV7482_SDP_R_REG_10_AUTOD_PAL_COMB:
 		return V4L2_STD_PAL_Nc | V4L2_STD_PAL_N;
-	case ADV7482_SDP_STATUS1_AUTOD_SECAM_525:
+	case ADV7482_SDP_R_REG_10_AUTOD_SECAM_525:
 		return V4L2_STD_SECAM;
 	default:
 		return V4L2_STD_UNKNOWN;
 	}
 }
 
-#if 0 /* FIXME */
-
-static int v4l2_std_to_adv7482(v4l2_std_id std)
-{
-	if (std == V4L2_STD_PAL_60)
-		return ADV7482_SDP_STD_PAL60;
-	if (std == V4L2_STD_NTSC_443)
-		return ADV7482_SDP_STD_NTSC_443;
-	if (std == V4L2_STD_PAL_N)
-		return ADV7482_SDP_STD_PAL_N;
-	if (std == V4L2_STD_PAL_M)
-		return ADV7482_SDP_STD_PAL_M;
-	if (std == V4L2_STD_PAL_Nc)
-		return ADV7482_SDP_STD_PAL_COMB_N;
-
-	if (std & V4L2_STD_PAL)
-		return ADV7482_SDP_STD_PAL_BG;
-	if (std & V4L2_STD_NTSC)
-		return ADV7482_SDP_STD_NTSC_M;
-	if (std & V4L2_STD_SECAM)
-		return ADV7482_SDP_STD_PAL_SECAM;
-
-	return -EINVAL;
-}
-
-#endif
-
-static u32 adv7482_status_to_v4l2(u8 status1)
+static u32 adv7482_status_to_v4l2(u8 status_reg_10)
 {
-	if (!(status1 & ADV7482_SDP_STATUS1_IN_LOCK))
+	if (!(status_reg_10 & ADV7482_SDP_R_REG_10_IN_LOCK))
 		return V4L2_IN_ST_NO_SIGNAL;
 
 	return 0;
@@ -1166,22 +809,22 @@ static int __adv7482_status(struct adv7482_state *state, u32 *status,
 			    v4l2_std_id *std)
 {
 	int ret;
-	u8 status1;
+	u8 status_reg_10;
 	struct adv7482_sdp_main_info sdp_info;
 
 	ret = adv7482_read_sdp_main_info(state->client, &sdp_info);
 	if (ret < 0)
 		return ret;
 
-	status1 = sdp_info.status1;
+	status_reg_10 = sdp_info.status_reg_10;
 
-	if (status1 < 0)
-		return (int)status1;
+	if (status_reg_10 < 0)
+		return (int)status_reg_10;
 
 	if (status)
-		*status = adv7482_status_to_v4l2(status1);
+		*status = adv7482_status_to_v4l2(status_reg_10);
 	if (std)
-		*std = adv7482_std_to_v4l2(status1);
+		*std = adv7482_std_to_v4l2(status_reg_10);
 
 	return 0;
 }
@@ -1283,27 +926,26 @@ static int adv7482_set_vid_info(struct v4l2_subdev *sd)
 	else
 		if ((width == 720) &&
 			(height == 480) && (progressive == 1))
-			dev_err(state->dev,
+			dev_info(state->dev,
 				 "Changed active resolution to 720x480p\n");
 		else if ((width == 720) &&
 			(height == 480) && (progressive == 0))
-			dev_err(state->dev,
+			dev_info(state->dev,
 				 "Changed active resolution to 720x480i\n");
 		else if ((width == 1920) &&
 			(height == 1080) && (progressive == 1))
-			dev_err(state->dev,
+			dev_info(state->dev,
 				 "Changed active resolution to 1920x1080p\n");
 		else if ((width == 1920) &&
 			(height == 1080) && (progressive == 0))
-			dev_err(state->dev,
+			dev_info(state->dev,
 				 "Changed active resolution to 1920x1080i\n");
 		else if ((width == 1280) &&
 			(height == 720) && (progressive == 1))
-			dev_err(state->dev,
+			dev_info(state->dev,
 				 "Changed active resolution to 1280x720p\n");
 
 	return 0;
-
 }
 
 /*****************************************************************************/
@@ -1328,8 +970,6 @@ static int adv7482_querystd(struct v4l2_subdev *sd, v4l2_std_id *std)
 
 	if (config->input_interface == DECODER_INPUT_INTERFACE_YCBCR422)
 		/* when we are interrupt driven we know the state */
-		/* FIXME */
-/*		if (!state->autodetect || state->irq > 0) */
 		if (!state->autodetect)
 			*std = state->curr_norm;
 		else
@@ -1381,31 +1021,6 @@ out:
 	mutex_unlock(&state->mutex);
 	return ret;
 }
-#if 0 /* FIXME */
-static int adv7482_program_std(struct adv7482_state *state)
-{
-	int ret;
-
-	if (state->autodetect) {
-		ret = adv7482_set_video_standard(state,
-			ADV7482_SDP_STD_AD_PAL_BG_NTSC_J_SECAM);
-		if (ret < 0)
-			return ret;
-
-		__adv7482_status(state, NULL, &state->curr_norm);
-	} else {
-		ret = v4l2_std_to_adv7482(state->curr_norm);
-		if (ret < 0)
-			return ret;
-
-		ret = adv7482_set_video_standard(state, ret);
-		if (ret < 0)
-			return ret;
-	}
-
-	return 0;
-}
-#endif
 
 static int adv7482_enum_mbus_code(struct v4l2_subdev *sd,
 				  struct v4l2_subdev_pad_config *cfg,
@@ -1435,9 +1050,8 @@ static int adv7482_mbus_fmt(struct v4l2_subdev *sd,
 	u32 width;
 	u32 height;
 	int ret;
-
 	struct adv7482_link_config *config = &state->mipi_csi2_link[0];
-	u8 status1;
+	u8 status_reg_10;
 	struct adv7482_sdp_main_info sdp_info;
 	struct i2c_client *client = v4l2_get_subdevdata(sd);
 
@@ -1445,33 +1059,31 @@ static int adv7482_mbus_fmt(struct v4l2_subdev *sd,
 		fmt->code = MEDIA_BUS_FMT_YUYV8_2X8;
 		fmt->colorspace = V4L2_COLORSPACE_SMPTE170M;
 		fmt->width = 720;
-#if 1 /* [TODO] FIXME */
 		fmt->height = 480;
-#else /* original code as below */
-		fmt->height = state->curr_norm & V4L2_STD_525_60 ? 480 : 576;
-#endif
 
 		/* Get video information */
 		ret = adv7482_read_sdp_main_info(client, &sdp_info);
 		if (ret < 0)
 			return ret;
 
-		status1 = sdp_info.status1;
+		status_reg_10 = sdp_info.status_reg_10;
 
-		if (status1 < 0)
-			dev_err(state->dev, "Not detect any video input signal\n");
+		if (status_reg_10 < 0)
+			dev_info(state->dev,
+				"Not detect any video input signal\n");
 		else {
-			if (status1 & ADV7482_SDP_STATUS1_IN_LOCK) {
-				if (((status1 &
-				ADV7482_SDP_STATUS1_AUTOD_NTSC_4_43)
-				 == ADV7482_SDP_STATUS1_AUTOD_NTSC_4_43) ||
-				  ((status1 & ADV7482_SDP_STATUS1_AUTOD_MASK)
-				  == ADV7482_SDP_STATUS1_AUTOD_NTSM_M_J))
-					dev_err(state->dev,
-					"Detected the NTSC video input signal\n");
-			} else
-				dev_err(state->dev,
-					"Not detect any NTCS video input signal\n");
+			if ((status_reg_10 & ADV7482_SDP_R_REG_10_IN_LOCK) &&
+				(((status_reg_10 &
+				ADV7482_SDP_R_REG_10_AUTOD_NTSC_4_43) ==
+				ADV7482_SDP_R_REG_10_AUTOD_NTSC_4_43) ||
+				((status_reg_10 &
+				ADV7482_SDP_R_REG_10_AUTOD_MASK) ==
+				ADV7482_SDP_R_REG_10_AUTOD_NTSM_M_J)))
+				dev_info(state->dev,
+				   "Detected the NTSC video input signal\n");
+			else
+				dev_info(state->dev,
+				   "Not detect any NTSC video input signal\n");
 		}
 
 		state->width = fmt->width;
@@ -1492,17 +1104,17 @@ static int adv7482_mbus_fmt(struct v4l2_subdev *sd,
 		}
 
 		if (signal)
-			dev_err(state->dev,
-			"Detected the HDMI video input signal (%dx%d%c)\n"
-			, width, height, (progressive) ? 'p' : 'i');
+			dev_info(state->dev,
+			 "Detected the HDMI video input signal (%dx%d%c)\n",
+			  width, height, (progressive) ? 'p' : 'i');
 		else
-			dev_err(state->dev,
+			dev_info(state->dev,
 				"Not detect any video input signal\n");
 
 		state->width = width;
 		state->height = height;
 		state->field =
-			(progressive) ? V4L2_FIELD_NONE : V4L2_FIELD_INTERLACED;
+		      (progressive) ? V4L2_FIELD_NONE : V4L2_FIELD_INTERLACED;
 
 		fmt->width = state->width;
 		fmt->height = state->height;
@@ -1513,7 +1125,7 @@ static int adv7482_mbus_fmt(struct v4l2_subdev *sd,
 
 static int adv7482_set_field_mode(struct adv7482_state *state)
 {
-   /* FIXME */
+	/* FIXME */
 
 	return 0;
 }
@@ -1522,7 +1134,6 @@ static int adv7482_set_power(struct adv7482_state *state, bool on)
 {
 	u8 val;
 	int ret;
-
 	struct adv7482_link_config *config = &state->mipi_csi2_link[0];
 
 	if (config->input_interface == DECODER_INPUT_INTERFACE_YCBCR422) {
@@ -1538,7 +1149,6 @@ static int adv7482_set_power(struct adv7482_state *state, bool on)
 			if (ret < 0)
 				goto fail;
 		}
-#if 0 /* FIXME */
 		else {
 			/* Power down */
 			ret = adv7482_write_registers(state->client,
@@ -1546,12 +1156,9 @@ static int adv7482_set_power(struct adv7482_state *state, bool on)
 			if (ret < 0)
 				goto fail;
 		}
-#endif
 	} else {
 		/* set active resolution */
 		ret = adv7482_set_vid_info(&state->sd);
-
-		/* */
 		ret = adv7482_read_register(state->client, ADV7482_I2C_TXA,
 				0x1E, &val);
 		if (ret < 0)
@@ -1564,7 +1171,6 @@ static int adv7482_set_power(struct adv7482_state *state, bool on)
 			if (ret < 0)
 				goto fail;
 		}
-#if 0 /* FIXME */
 		else {
 			/* Power down */
 			ret = adv7482_write_registers(state->client,
@@ -1572,9 +1178,6 @@ static int adv7482_set_power(struct adv7482_state *state, bool on)
 			if (ret < 0)
 				goto fail;
 		}
-#endif
-		dummy_csi2_control_interrupts(config, on);
-
 	}
 
 	return 0;
@@ -1623,16 +1226,6 @@ static int adv7482_set_pad_format(struct v4l2_subdev *sd,
 	struct adv7482_state *state = to_state(sd);
 	struct v4l2_mbus_framefmt *framefmt;
 
-	switch (format->format.field) {
-	case V4L2_FIELD_NONE:
-		/* [TODO] FIXME */
-		format->format.field = V4L2_FIELD_NONE;
-		break;
-	default:
-		format->format.field = V4L2_FIELD_INTERLACED;
-		break;
-	}
-
 	if (format->which == V4L2_SUBDEV_FORMAT_ACTIVE) {
 		framefmt = &format->format;
 		if (state->field != format->format.field) {
@@ -1659,11 +1252,6 @@ static int adv7482_set_pad_format(struct v4l2_subdev *sd,
 static int adv7482_g_mbus_config(struct v4l2_subdev *sd,
 					struct v4l2_mbus_config *cfg)
 {
-#if 0 /* [TODO] FIXME */
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	struct soc_camera_subdev_desc *ssdd = soc_camera_i2c_to_desc(client);
-#endif
-
 	struct adv7482_state *state = to_state(sd);
 	struct adv7482_link_config *config = &state->mipi_csi2_link[0];
 
@@ -1678,10 +1266,6 @@ static int adv7482_g_mbus_config(struct v4l2_subdev *sd,
 
 	cfg->type = V4L2_MBUS_CSI2;
 
-#if 0 /* [TODO] FIXME */
-	cfg->flags = soc_camera_apply_board_flags(ssdd, cfg);
-#endif
-
 	return 0;
 }
 
@@ -1705,7 +1289,6 @@ static int adv7482_cp_s_ctrl(struct v4l2_ctrl *ctrl, struct i2c_client *client)
 	if (ret < 0)
 		return ret;
 
-	val = ctrl->val;
 	switch (ctrl->id) {
 	case V4L2_CID_BRIGHTNESS:
 		if ((ctrl->val < ADV7482_CP_BRI_MIN) ||
@@ -1713,7 +1296,7 @@ static int adv7482_cp_s_ctrl(struct v4l2_ctrl *ctrl, struct i2c_client *client)
 			ret = -ERANGE;
 		else
 			ret = adv7482_write_register(client, ADV7482_I2C_CP,
-					ADV7482_CP_BRI_REG, val);
+					ADV7482_CP_BRI_REG, ctrl->val);
 		break;
 	case V4L2_CID_HUE:
 		if ((ctrl->val < ADV7482_CP_HUE_MIN) ||
@@ -1721,7 +1304,7 @@ static int adv7482_cp_s_ctrl(struct v4l2_ctrl *ctrl, struct i2c_client *client)
 			ret = -ERANGE;
 		else
 			ret = adv7482_write_register(client, ADV7482_I2C_CP,
-					ADV7482_CP_HUE_REG, val);
+					ADV7482_CP_HUE_REG, ctrl->val);
 		break;
 	case V4L2_CID_CONTRAST:
 		if ((ctrl->val < ADV7482_CP_CON_MIN) ||
@@ -1729,7 +1312,7 @@ static int adv7482_cp_s_ctrl(struct v4l2_ctrl *ctrl, struct i2c_client *client)
 			ret = -ERANGE;
 		else
 			ret = adv7482_write_register(client, ADV7482_I2C_CP,
-					ADV7482_CP_CON_REG, val);
+					ADV7482_CP_CON_REG, ctrl->val);
 		break;
 	case V4L2_CID_SATURATION:
 		if ((ctrl->val < ADV7482_CP_SAT_MIN) ||
@@ -1737,34 +1320,44 @@ static int adv7482_cp_s_ctrl(struct v4l2_ctrl *ctrl, struct i2c_client *client)
 			ret = -ERANGE;
 		else
 			ret = adv7482_write_register(client, ADV7482_I2C_CP,
-					ADV7482_CP_SAT_REG, val);
+					ADV7482_CP_SAT_REG, ctrl->val);
 		break;
 	default:
 		ret = -EINVAL;
 	}
-	return ret;
 
+	return ret;
 }
 
 static int adv7482_sdp_s_ctrl(struct v4l2_ctrl *ctrl, struct i2c_client *client)
 {
-	u8 val;
 	int ret;
 
-	val = ctrl->val;
 	switch (ctrl->id) {
 	case V4L2_CID_BRIGHTNESS:
-		ret = adv7482_write_register(client, ADV7482_I2C_SDP,
-				ADV7482_SDP_REG_BRI, val);
+		if ((ctrl->val < ADV7482_SDP_BRI_MIN) ||
+					(ctrl->val > ADV7482_SDP_BRI_MAX))
+			ret = -ERANGE;
+		else
+			ret = adv7482_write_register(client, ADV7482_I2C_SDP,
+					ADV7482_SDP_REG_BRI, ctrl->val);
 		break;
 	case V4L2_CID_HUE:
-		/*Hue is inverted according to HSL chart */
-		ret = adv7482_write_register(client, ADV7482_I2C_SDP,
-				ADV7482_SDP_REG_HUE, -val);
+		if ((ctrl->val < ADV7482_SDP_HUE_MIN) ||
+					(ctrl->val > ADV7482_SDP_HUE_MAX))
+			ret = -ERANGE;
+		else
+			/*Hue is inverted according to HSL chart */
+			ret = adv7482_write_register(client, ADV7482_I2C_SDP,
+					ADV7482_SDP_REG_HUE, -ctrl->val);
 		break;
 	case V4L2_CID_CONTRAST:
-		ret = adv7482_write_register(client, ADV7482_I2C_SDP,
-				ADV7482_SDP_REG_CON, val);
+		if ((ctrl->val < ADV7482_SDP_CON_MIN) ||
+					(ctrl->val > ADV7482_SDP_CON_MAX))
+			ret = -ERANGE;
+		else
+			ret = adv7482_write_register(client, ADV7482_I2C_SDP,
+					ADV7482_SDP_REG_CON, ctrl->val);
 		break;
 #if 0 /* [FIXME] */
 	case V4L2_CID_SATURATION:
@@ -1781,6 +1374,7 @@ static int adv7482_sdp_s_ctrl(struct v4l2_ctrl *ctrl, struct i2c_client *client)
 	default:
 		ret = -EINVAL;
 	}
+
 	return ret;
 }
 
@@ -1807,6 +1401,7 @@ static int adv7482_s_ctrl(struct v4l2_ctrl *ctrl)
 		ret = adv7482_cp_s_ctrl(ctrl, client);
 
 	mutex_unlock(&state->mutex);
+
 	return ret;
 }
 
@@ -1853,23 +1448,6 @@ static const struct v4l2_ctrl_ops adv7482_ctrl_ops = {
 	.s_ctrl = adv7482_s_ctrl,
 };
 
-#if 0 /* [FIXME] if needed */
-static irqreturn_t adv7482_irq(int irq, void *devid)
-{
-	struct adv7482_state *state = devid;
-
-	mutex_lock(&state->mutex);
-
-	/* read status */
-	/* clear */
-	/* check status */
-
-	mutex_unlock(&state->mutex);
-
-	return IRQ_HANDLED;
-}
-#endif
-
 /*
  * adv7482_init_controls() - Init controls
  * @state: pointer to private state structure
@@ -1920,9 +1498,7 @@ static int adv7482_sdp_init_controls(struct adv7482_state *state)
 	v4l2_ctrl_new_std(&state->ctrl_hdl, &adv7482_ctrl_ops,
 			  V4L2_CID_HUE, ADV7482_SDP_HUE_MIN,
 			  ADV7482_SDP_HUE_MAX, 1, ADV7482_SDP_HUE_DEF);
-#if 0 /* [FIXME] */
-	v4l2_ctrl_new_custom(&state->ctrl_hdl, &adv7482_ctrl_fast_switch, NULL);
-#endif
+
 	state->sd.ctrl_handler = &state->ctrl_hdl;
 	if (state->ctrl_hdl.error) {
 		int err = state->ctrl_hdl.error;
@@ -1967,12 +1543,8 @@ static int adv7482_parse_dt(struct device_node *np,
 
 	if (!strcmp(str, "rgb888")) {
 		config->input_interface = DECODER_INPUT_INTERFACE_RGB888;
-/*
-		config->regs =
-		(struct adv7482_reg_value *)adv7482_init_txa_4lane_over_600;
-*/
 		config->regs =
-		(struct adv7482_reg_value *)adv7482_init_txa_4lane_up_to_600;
+		(struct adv7482_reg_value *)adv7482_init_txa_4lane;
 		config->power_up =
 		(struct adv7482_reg_value *)adv7482_power_up_txa_4lane;
 		config->power_down =
@@ -2052,6 +1624,7 @@ static int adv7482_probe(struct i2c_client *client,
 	/* Check if the adapter supports the needed features */
 	if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))
 		return -EIO;
+
 	v4l_info(client, "chip found @ 0x%02x (%s)\n",
 			client->addr << 1, client->adapter->name);
 
@@ -2072,13 +1645,14 @@ static int adv7482_probe(struct i2c_client *client,
 
 	mutex_init(&state->mutex);
 	state->autodetect = true;
-	state->powered = true;      /* FIXME */
+	state->powered = true;
 	sd = &state->sd;
-	state->width		= ADV7482_MAX_WIDTH;
-	state->height		= ADV7482_MAX_HEIGHT;
-	state->field		= V4L2_FIELD_NONE;
+	state->width = ADV7482_MAX_WIDTH;
+	state->height = ADV7482_MAX_HEIGHT;
+	state->field = V4L2_FIELD_NONE;
 
 	v4l2_i2c_subdev_init(sd, client, &adv7482_ops);
+
 	sd->flags = V4L2_SUBDEV_FL_HAS_DEVNODE;
 
 	state->dev		= dev;
@@ -2107,13 +1681,12 @@ static int adv7482_probe(struct i2c_client *client,
 
 			v4l_info(client, "adv7482 revision is %02x%02x\n",
 					lsb, msb);
-
 		}
 	}
 
 	if (link_config.hdmi_in) {
 		ret = adv7482_write_registers(client,
-				adv7482_init_txa_4lane_up_to_600);
+				adv7482_init_txa_4lane);
 		if (ret < 0)
 			goto err_unreg_subdev;
 
@@ -2177,16 +1750,6 @@ static int adv7482_probe(struct i2c_client *client,
 	if (ret)
 		goto err_free_ctrl;
 
-#if 0 /* [FIXME] if needed */
-	if (state->irq) {
-		ret = request_threaded_irq(client->irq, NULL, adv7482_irq,
-					   IRQF_ONESHOT | IRQF_TRIGGER_FALLING,
-					   KBUILD_MODNAME, state);
-		if (ret)
-			goto err_media_entity_cleanup;
-	}
-#endif
-
 	return 0;
 
 err_free_ctrl:
@@ -2269,7 +1832,7 @@ static int adv7482_resume(struct i2c_client *client)
 	if (ret)
 		return ret;
 
-	/* Initializes AVD7612 to its default values */
+	/* Initializes AVD7482 to its default values */
 	ret = adv7482_write_registers(client, link_config.regs);
 
 	return ret;
@@ -2287,7 +1850,6 @@ MODULE_DEVICE_TABLE(of, adv7482_of_ids);
 
 static struct i2c_driver adv7482_driver = {
 	.driver = {
-		.owner	= THIS_MODULE,
 		.name	= DRIVER_NAME,
 		.of_match_table = adv7482_of_ids,
 	},
@@ -2305,4 +1867,6 @@ static struct i2c_driver adv7482_driver = {
 module_i2c_driver(adv7482_driver);
 
 MODULE_DESCRIPTION("HDMI Receiver ADV7482 video decoder driver");
+MODULE_ALIAS("platform:adv7482");
 MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Koji Matsuoka <koji.matsuoka.xm@renesas.com>");
-- 
1.7.5.4

