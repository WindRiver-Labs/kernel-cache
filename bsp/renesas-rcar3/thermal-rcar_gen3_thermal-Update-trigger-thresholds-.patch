From b3262bb69d86b3d6ade9078828bf8a4ba1a8e585 Mon Sep 17 00:00:00 2001
From: Hien Dang <hien.dang.eb@renesas.com>
Date: Wed, 20 Jul 2016 09:59:55 +0700
Subject: [PATCH 1305/2066] thermal: rcar_gen3_thermal: Update trigger
 thresholds only on irq occurrence

Whenever get_temp callback is called, it will adjust rising/falling
threshold temperature code to trigger interrupt. If an application
reads temperature continuously, the thresholds will be kept updated
all over again. This will make irq hard to be triggered especially
for sensor whose temperature is slowly changed.

This patch will fix that issue. Now irq temp thresholds will be updated
only on irq occurrence. To that end, priv->temp is no longer necessary.
Current temperature will be converted directly from HW value.

Signed-off-by: Hien Dang <hien.dang.eb@renesas.com>
Signed-off-by: Tri Vo <tri.vo.xb@rvc.renesas.com>
[zou:Original patch taken from
git://git.kernel.org/pub/scm/linux/kernel/git/horms/renesas-bsp.git
 v4.9/rcar-3.5.1]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 drivers/thermal/rcar_gen3_thermal.c |    9 ++++-----
 1 files changed, 4 insertions(+), 5 deletions(-)

diff --git a/drivers/thermal/rcar_gen3_thermal.c b/drivers/thermal/rcar_gen3_thermal.c
index f705f9e..efd5a81 100644
--- a/drivers/thermal/rcar_gen3_thermal.c
+++ b/drivers/thermal/rcar_gen3_thermal.c
@@ -104,7 +104,6 @@ struct rcar_thermal_priv {
 	spinlock_t lock;
 	int id;
 	int irq;
-	u32 ctemp;
 	const struct rcar_thermal_data *data;
 };
 
@@ -298,7 +297,6 @@ static int rcar_gen3_thermal_update_temp(struct rcar_thermal_priv *priv)
 		rcar_thermal_write(priv, REG_GEN3_IRQTEMP2, temp_code);
 	}
 
-	priv->ctemp = ctemp;
 	spin_unlock_irqrestore(&priv->lock, flags);
 
 	return 0;
@@ -309,11 +307,11 @@ static int rcar_gen3_thermal_get_temp(void *devdata, int *temp)
 	struct rcar_thermal_priv *priv = devdata;
 	int ctemp;
 	unsigned long flags;
-
-	rcar_gen3_thermal_update_temp(priv);
+	u32 ctemp_code;
 
 	spin_lock_irqsave(&priv->lock, flags);
-	ctemp = thermal_temp_converter(priv->coef, priv->ctemp);
+	ctemp_code = rcar_thermal_read(priv, REG_GEN3_TEMP) & CTEMP_MASK;
+	ctemp = thermal_temp_converter(priv->coef, ctemp_code);
 	spin_unlock_irqrestore(&priv->lock, flags);
 
 	if ((ctemp < MCELSIUS(-40)) || (ctemp > MCELSIUS(125))) {
@@ -402,6 +400,7 @@ static void rcar_gen3_thermal_work(struct work_struct *work)
 
 	priv = container_of(work, struct rcar_thermal_priv, work.work);
 
+	rcar_gen3_thermal_update_temp(priv);
 	thermal_zone_device_update(priv->zone);
 
 	rcar_thermal_irq_enable(priv);
-- 
1.7.5.4

