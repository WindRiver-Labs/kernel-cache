From f6eb77dd39d62f2625ad12002b65768758020353 Mon Sep 17 00:00:00 2001
From: Hien Dang <hien.dang.eb@rvc.renesas.com>
Date: Tue, 31 May 2016 20:36:43 +0700
Subject: [PATCH 1314/2066] soc: renesas: rcar_ems_ctrl: Fetch targeted
 shutdown cpu from DT

This patch implements the mechanism to detect the target
shutdown CPUs and target frequency-scaled CPUs base on DT description.

Signed-off-by: Hien Dang <hien.dang.eb@rvc.renesas.com>
[zou:Original patch taken from
git://git.kernel.org/pub/scm/linux/kernel/git/horms/renesas-bsp.git
 v4.9/rcar-3.5.1]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 drivers/soc/renesas/rcar_ems_ctrl.c |   37 +++++++++++++++++++++++-----------
 1 files changed, 25 insertions(+), 12 deletions(-)

diff --git a/drivers/soc/renesas/rcar_ems_ctrl.c b/drivers/soc/renesas/rcar_ems_ctrl.c
index 2699340..8484f1b 100644
--- a/drivers/soc/renesas/rcar_ems_ctrl.c
+++ b/drivers/soc/renesas/rcar_ems_ctrl.c
@@ -177,6 +177,7 @@ module_exit(rcar_ems_ctrl_exit)
 
 /* emergency cpu shutdown function */
 static struct cpumask target_cpus;
+static struct cpumask freq_scaled_cpus;
 
 static int rcar_ems_cpufreq_notifier_call(struct notifier_block *nb,
 	unsigned long event, void *data)
@@ -184,7 +185,7 @@ static int rcar_ems_cpufreq_notifier_call(struct notifier_block *nb,
 	struct cpufreq_policy *policy = data;
 	int mode;
 
-	if (!cpumask_test_cpu(policy->cpu, &target_cpus))
+	if (!cpumask_test_cpu(policy->cpu, &freq_scaled_cpus))
 		return NOTIFY_DONE;
 
 	switch (event) {
@@ -208,7 +209,7 @@ static int rcar_ems_thermal_notifier_call(struct notifier_block *nb,
 	unsigned long state, void *val)
 {
 	long temp = (long)val;
-	int cpu, first = 0;
+	int cpu;
 
 	pr_info("thermal emergency notifier: state=%ld (temp=%ld)\n",
 		state, temp);
@@ -216,12 +217,8 @@ static int rcar_ems_thermal_notifier_call(struct notifier_block *nb,
 	switch (state) {
 	case RCAR_EMS_MODE_ON:
 		for_each_cpu(cpu, &target_cpus) {
-			if (cpu_online(cpu)) {
-				if (first != 0)
-					cpu_down(cpu);
-
-				first = 1;
-			}
+			if (cpu_online(cpu))
+				cpu_down(cpu);
 		}
 		break;
 
@@ -236,7 +233,7 @@ static int rcar_ems_thermal_notifier_call(struct notifier_block *nb,
 		return NOTIFY_DONE;
 	}
 
-	cpufreq_update_policy(cpumask_any(&target_cpus));
+	cpufreq_update_policy(cpumask_any(&freq_scaled_cpus));
 
 	return NOTIFY_OK;
 }
@@ -251,20 +248,34 @@ static struct notifier_block ems_cpufreq_notifier_block = {
 static int __init rcar_ems_cpu_shutdown_init(void)
 {
 	int cpu;
-	struct device_node *cpu_node;
+	struct device_node *cpu_node, *ems_node;
+	int total_target_cpu, i;
 
 	if (!IS_ENABLED(CONFIG_RCAR_THERMAL_EMS_ENABLED))
 		return 0;
 
 	cpumask_clear(&target_cpus);
+	cpumask_clear(&freq_scaled_cpus);
+
+	ems_node = of_find_node_by_name(NULL, "emergency");
 
-	for_each_compatible_node(cpu_node, "cpu", "arm,cortex-a57") {
-		for_each_possible_cpu(cpu) {
+	if (!ems_node)
+		return 0;
+
+	total_target_cpu = of_count_phandle_with_args(ems_node,
+						"target_cpus", 0);
+
+	for_each_online_cpu(cpu) {
+		for (i = 0; i < total_target_cpu; i++) {
+			cpu_node = of_parse_phandle(ems_node, "target_cpus", i);
 			if (of_get_cpu_node(cpu, NULL) == cpu_node) {
 				cpumask_set_cpu(cpu, &target_cpus);
 				break;
 			}
 		}
+
+		if (i == total_target_cpu)
+			cpumask_set_cpu(cpu, &freq_scaled_cpus);
 	}
 
 	if (cpumask_weight(&target_cpus) <= 1) {
@@ -278,6 +289,8 @@ static int __init rcar_ems_cpu_shutdown_init(void)
 
 	pr_info("thermal emergency: shutdown target cpus %*pbl\n",
 		cpumask_pr_args(&target_cpus));
+	pr_info("thermal emergency: freq scaled target cpus %*pbl\n",
+		cpumask_pr_args(&freq_scaled_cpus));
 
 	return 0;
 }
-- 
1.7.5.4

