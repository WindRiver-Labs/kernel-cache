From cc41f29d16d89a22ae642a87b34a6d6f7557ad54 Mon Sep 17 00:00:00 2001
From: Geert Uytterhoeven <geert+renesas@glider.be>
Date: Mon, 16 Nov 2015 15:54:47 +0100
Subject: [PATCH 0462/2066] serial: sh-sci: Improve bit rate error calculation
 for HSCIF

upstream 881a7489f463e59a44417ad89ecb4ea21b2b86cd commit

The algorithm to find the best parameters for the requested bit rate
calculates the relative bit rate error, using "(br * scrate) / 1000".
For small "br * scrate", this has two problems:
  - The quotient may be zero, leading to a division by zero error,
  - This may introduce a large rounding error.
Switch from relative to absolute bit rate error calculation to fix this.

The default baud rate generator values can be removed, as there will
always be one set of values that gives the smallest absolute error.

Print the best set of values when debugging.

Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
---
 drivers/tty/serial/sh-sci.c |   21 ++++++++-------------
 1 files changed, 8 insertions(+), 13 deletions(-)

diff --git a/drivers/tty/serial/sh-sci.c b/drivers/tty/serial/sh-sci.c
index 15408c6..357b69e 100644
--- a/drivers/tty/serial/sh-sci.c
+++ b/drivers/tty/serial/sh-sci.c
@@ -1833,12 +1833,13 @@ static unsigned int sci_scbrr_calc(struct sci_port *s, unsigned int bps,
 }
 
 /* calculate sample rate, BRR, and clock select for HSCIF */
-static void sci_baud_calc_hscif(unsigned int bps, unsigned long freq, int *brr,
+static void sci_baud_calc_hscif(struct sci_port *s, unsigned int bps,
+				unsigned long freq, int *brr,
 				unsigned int *srr, unsigned int *cks)
 {
 	unsigned int sr, br, prediv, scrate, c;
 	int err, recv_margin;
-	int min_err = 1000; /* 100% */
+	int min_err = INT_MAX;
 	int recv_max_margin = 0;
 
 	/* Find the combination of sample rate and clock select with the
@@ -1852,7 +1853,7 @@ static void sci_baud_calc_hscif(unsigned int bps, unsigned long freq, int *brr,
 			 * We need to calculate:
 			 *
 			 *     br = freq / (prediv * bps) clamped to [1..256]
-			 *     err = (freq / (br * prediv * bps / 1000)) - 1000
+			 *     err = freq / (br * prediv) - bps
 			 *
 			 * Watch out for overflow when calculating the desired
 			 * sampling clock rate!
@@ -1863,8 +1864,7 @@ static void sci_baud_calc_hscif(unsigned int bps, unsigned long freq, int *brr,
 			scrate = prediv * bps;
 			br = DIV_ROUND_CLOSEST(freq, scrate);
 			br = clamp(br, 1U, 256U);
-			err = DIV_ROUND_CLOSEST(freq, (br * scrate) / 1000) -
-			      1000;
+			err = DIV_ROUND_CLOSEST(freq, br * prediv) - bps;
 			/* Calc recv margin
 			 * M: Receive margin (%)
 			 * N: Ratio of bit rate to clock (N = sampling rate)
@@ -1894,13 +1894,8 @@ static void sci_baud_calc_hscif(unsigned int bps, unsigned long freq, int *brr,
 		}
 	}
 
-	if (min_err == 1000) {
-		WARN_ON(1);
-		/* use defaults */
-		*brr = 255;
-		*srr = 15;
-		*cks = 0;
-	}
+	dev_dbg(s->port.dev, "BRR: %u%+d bps using N %u SR %u cks %u\n", bps,
+		min_err, *brr, *srr + 1, *cks);
 }
 
 static void sci_reset(struct uart_port *port)
@@ -1950,7 +1945,7 @@ static void sci_set_termios(struct uart_port *port, struct ktermios *termios,
 	baud = uart_get_baud_rate(port, termios, old, 0, max_baud);
 	if (likely(baud && port->uartclk)) {
 		if (s->cfg->type == PORT_HSCIF) {
-			sci_baud_calc_hscif(baud, port->uartclk, &t, &srr,
+			sci_baud_calc_hscif(s, baud, port->uartclk, &t, &srr,
 					    &cks);
 		} else {
 			t = sci_scbrr_calc(s, baud, port->uartclk);
-- 
1.7.5.4

