From 591059456488488adb17e441f4cf25bd0941c82b Mon Sep 17 00:00:00 2001
From: Hien Dang <hien.dang.eb@renesas.com>
Date: Wed, 24 Aug 2016 13:54:59 +0700
Subject: [PATCH 1658/2066] soc: s2ram_ddr_backup: Break down backup/restore
 functions

To improve the readability, break down interface functions from core
register backup/restore functions.

Signed-off-by: Hien Dang <hien.dang.eb@renesas.com>
[zou:Original patch taken from
git://git.kernel.org/pub/scm/linux/kernel/git/horms/renesas-bsp.git
 v4.9/rcar-3.5.1]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 drivers/soc/renesas/s2ram_ddr_backup.c       |  334 ++++++++++++++------------
 include/linux/soc/renesas/s2ram_ddr_backup.h |   10 +-
 2 files changed, 187 insertions(+), 157 deletions(-)

diff --git a/drivers/soc/renesas/s2ram_ddr_backup.c b/drivers/soc/renesas/s2ram_ddr_backup.c
index c06915b..818e78b 100644
--- a/drivers/soc/renesas/s2ram_ddr_backup.c
+++ b/drivers/soc/renesas/s2ram_ddr_backup.c
@@ -61,182 +61,210 @@ static struct rcar_ip *common_ips[] = {
 	NULL,
 };
 
-/*
- * Handle backup/restore of IP register
- *     ip: IP to be processed
- *     handling: Flag of processing
- *         DO_IOREMAP: ioremap
- *         DO_BACKUP: backup
- *         DO_RESTORE: restore
- */
-int rcar_handle_registers(struct rcar_ip *ip, unsigned int handling)
+static unsigned int read_reg(unsigned int size, void __iomem *addr)
 {
+	unsigned int ret = 0;
+
+	switch (size) {
+	case 8:
+		ret = readb_relaxed(addr);
+		break;
+	case 16:
+		ret = readw_relaxed(addr);
+		break;
+	case 32:
+		ret = readl_relaxed(addr);
+		break;
+	default:
+		pr_debug("%s: Wrong access size\n", __func__);
+		break;
+	}
+
+	return ret;
+}
+
+static void write_reg(unsigned int size, unsigned int value,
+			void __iomem *addr)
+{
+	switch (size) {
+	case 8:
+		writeb_relaxed(value, addr);
+		break;
+	case 16:
+		writew_relaxed(value, addr);
+		break;
+	case 32:
+		writel_relaxed(value, addr);
+		break;
+	default:
+		pr_debug("%s: Wrong access size\n", __func__);
+		break;
+	}
+}
+
+static int _do_ioremap(struct rcar_ip *ip)
+{
+	ip->virt_addr = ioremap_nocache(ip->base_addr, ip->size);
+
+	if (ip->virt_addr == NULL) {
+		pr_debug("s2ram ioremap: Could not remap IP register\n");
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+static int _do_backup(struct rcar_ip *ip)
+{
+	struct hw_register *ip_reg;
+	void __iomem *virt_addr = NULL;
 	int reg_count = 0;
 	unsigned int j;
-	void __iomem *virt_addr = NULL;
-	struct hw_register *ip_reg;
 
-	if (handling == DO_IOREMAP) { /* ioremap */
-		/* Called during boot process */
-		virt_addr = ioremap_nocache(ip->base_addr, ip->size);
-		if (virt_addr == NULL) {
-			pr_debug("s2ram: %s: Could not remap IP register\n",
-				__func__);
-			return -ENOMEM;
-		}
+	if (ip->virt_addr == NULL) {
+		pr_debug("s2ram backup: Registers have not been mapped\n");
+		return -EINVAL;
+	}
 
-		ip->virt_addr = virt_addr;
+	ip_reg    = ip->ip_reg;
+	reg_count = ip->reg_count;
+	virt_addr = ip->virt_addr;
 
-		pr_debug("s2ram ioremap: %s: Working with %s, size 0x%x, virt_addr 0x%p\n",
-			__func__, ip->ip_name, ip->size, ip->virt_addr);
+	pr_debug("s2ram backup:  Working with %s, size 0x%x, virt_addr 0x%p\n",
+		  ip->ip_name, ip->size, ip->virt_addr);
 
-	} else if (handling == DO_BACKUP) { /* backup */
-		if (ip->virt_addr == NULL) {
-			pr_debug("s2ram backup: %s: iomem has not been mapped\n",
-				__func__);
-			return -ENOMEM;
-		}
+	for (j = 0; j < reg_count; j++) {
+		pr_debug("%-20s, access_size 0x%-2x, offset 0x%-4x, value 0x%x\n",
+			  ip_reg[j].reg_name, ip_reg[j].access_size,
+			  ip_reg[j].reg_offset, ip_reg[j].reg_value);
 
-		ip_reg    = ip->ip_reg;
-		reg_count = ip->reg_count;
-		virt_addr = ip->virt_addr;
+		ip_reg[j].reg_value = read_reg(ip_reg[j].access_size,
+				virt_addr + ip_reg[j].reg_offset);
 
-		pr_debug("s2ram backup: %s:  Working with %s, size 0x%x, virt_addr 0x%p\n",
-			  __func__, ip->ip_name, ip->size, ip->virt_addr);
+		pr_debug("%-20s, access_size 0x%-2x, offset 0x%-4x, value 0x%x\n",
+			  ip_reg[j].reg_name, ip_reg[j].access_size,
+			  ip_reg[j].reg_offset, ip_reg[j].reg_value);
+	}
 
+	return 0;
+}
+
+static int _do_restore(struct rcar_ip *ip)
+{
+	struct hw_register *ip_reg;
+	void __iomem *virt_addr = NULL;
+	int reg_count = 0;
+	unsigned int j;
+
+	if (ip->virt_addr == NULL) {
+		pr_debug("s2ram restore: Registers have not been mapped\n");
+		return -EINVAL;
+	}
+
+	ip_reg    = ip->ip_reg;
+	reg_count = ip->reg_count;
+	virt_addr = ip->virt_addr;
+
+	pr_debug("s2ram restore: Working with %s, size 0x%x, virt_addr 0x%p\n",
+		  ip->ip_name, ip->size, ip->virt_addr);
+
+	if (strcmp(ip->ip_name, "PFC") && strcmp(ip->ip_name, "RWDT")) {
 		for (j = 0; j < reg_count; j++) {
-			pr_debug("%-20ss, access_size 0x%-2x, offset 0x%-4x, value 0x%x\n",
-				  ip_reg[j].reg_name, ip_reg[j].access_size,
-				  ip_reg[j].reg_offset, ip_reg[j].reg_value);
-
-			switch (ip_reg[j].access_size) {
-			case 8:
-				ip_reg[j].reg_value =
-					readb_relaxed(virt_addr +
-						      ip_reg[j].reg_offset);
-				break;
-			case 16:
-				ip_reg[j].reg_value =
-					readw_relaxed(virt_addr +
-						      ip_reg[j].reg_offset);
-				break;
-			case 32:
-				ip_reg[j].reg_value =
-					readl_relaxed(virt_addr +
-						      ip_reg[j].reg_offset);
-				break;
-			}
+			pr_debug("%-20s, access_size 0x%-2x, offset 0x%-4x, value 0x%x\n",
+				ip_reg[j].reg_name,
+				ip_reg[j].access_size,
+				ip_reg[j].reg_offset,
+				ip_reg[j].reg_value);
+
+			write_reg(ip_reg[j].access_size, ip_reg[j].reg_value,
+				virt_addr + ip_reg[j].reg_offset);
 
 			pr_debug("%-20s, access_size 0x%-2x, offset 0x%-4x, value 0x%x\n",
-				  ip_reg[j].reg_name, ip_reg[j].access_size,
-				  ip_reg[j].reg_offset, ip_reg[j].reg_value);
-		}
-	} else { /* restore */
-		if (ip->virt_addr == NULL) {
-			pr_debug("s2ram backup: %s: iomem has not been mapped\n",
-				__func__);
-			return -ENOMEM;
+				ip_reg[j].reg_name,
+				ip_reg[j].access_size,
+				ip_reg[j].reg_offset,
+				read_reg(ip_reg[j].access_size, virt_addr +
+					ip_reg[j].reg_offset));
 		}
+	} else if (!strcmp(ip->ip_name, "RWDT")) {
+		/* For RWDT registers, need special way to write */
+		for (j = 0; j < reg_count; j++) {
+			pr_debug("%-20s, access_size 0x%-2x, offset 0x%-4x, value 0x%x\n",
+				ip_reg[j].reg_name,
+				ip_reg[j].access_size,
+				ip_reg[j].reg_offset,
+				ip_reg[j].reg_value);
+
+			/* Only two registers are backup/restored.
+			 * If offset is zero, it is RWTCNT register
+			 * and RWTCNT_CODE is used for writing.
+			 * Otherwise, RWTCSRA_CODE is used for RWTCSRA register.
+			 */
+			writel_relaxed(ip_reg[j].reg_value |
+				(!ip_reg[j].reg_offset ? RWTCNT_CODE
+					: RWTCSRA_CODE),
+				virt_addr + ip_reg[j].reg_offset);
 
-		ip_reg    = ip->ip_reg;
-		reg_count = ip->reg_count;
-		virt_addr = ip->virt_addr;
-
-		pr_debug("s2ram restore: %s: Working with %s, size 0x%x, virt_addr 0x%p\n",
-			  __func__, ip->ip_name, ip->size, ip->virt_addr);
-
-		if (strcmp(ip->ip_name, "PFC") && strcmp(ip->ip_name, "RWDT")) {
-			for (j = 0; j < reg_count; j++) {
-				pr_debug("%-20s, access_size 0x%-2x, offset 0x%-4x, value 0x%x\n",
-					ip_reg[j].reg_name,
-					ip_reg[j].access_size,
-					ip_reg[j].reg_offset,
-					ip_reg[j].reg_value);
-
-				switch (ip_reg[j].access_size) {
-				case 8:
-					writeb_relaxed(ip_reg[j].reg_value,
-						virt_addr +
-						ip_reg[j].reg_offset);
-					break;
-				case 16:
-					writew_relaxed(ip_reg[j].reg_value,
-						virt_addr +
-						ip_reg[j].reg_offset);
-					break;
-				case 32:
-					writel_relaxed(ip_reg[j].reg_value,
-						virt_addr +
-						ip_reg[j].reg_offset);
-					break;
-				}
-
-				pr_debug("%-20s, access_size 0x%-2x, offset 0x%-4x, value 0x%x\n",
-					ip_reg[j].reg_name,
-					ip_reg[j].access_size,
-					ip_reg[j].reg_offset,
-					readl_relaxed(virt_addr +
-						ip_reg[j].reg_offset));
-			}
-		} else if (!strcmp(ip->ip_name, "RWDT")) {
-			/* For RWDT registers, need special way to write */
-			for (j = 0; j < reg_count; j++) {
-				pr_debug("%-20s, access_size 0x%-2x, offset 0x%-4x, value 0x%x\n",
-					ip_reg[j].reg_name,
-					ip_reg[j].access_size,
-					ip_reg[j].reg_offset,
-					ip_reg[j].reg_value);
-
-				writel_relaxed(ip_reg[j].reg_value |
-					(!ip_reg[j].reg_offset ? RWTCNT_CODE
-						: RWTCSRA_CODE),
+			pr_debug("%-20s, access_size 0x%-2x, offset 0x%-4x, value 0x%x\n",
+				ip_reg[j].reg_name,
+				ip_reg[j].access_size,
+				ip_reg[j].reg_offset,
+				read_reg(ip_reg[j].access_size, virt_addr +
+					ip_reg[j].reg_offset));
+		}
+	} else {
+		/* For PFC registers, need to unlock before writing */
+		for (j = 0; j < reg_count; j++) {
+			pr_debug("%-20s, access_size 0x%-2x, offset 0x%-4x, value 0x%x\n",
+				ip_reg[j].reg_name,
+				ip_reg[j].access_size,
+				ip_reg[j].reg_offset,
+				ip_reg[j].reg_value);
+
+			writel_relaxed(~ip_reg[j].reg_value,
+				virt_addr + ip_reg[0].reg_offset);
+			writel_relaxed(ip_reg[j].reg_value,
 					virt_addr +
 					ip_reg[j].reg_offset);
-					switch (ip_reg[j].access_size) {
-					case 8:
-					pr_debug("%-20s, access_size 0x%-2x, offset 0x%-4x, value 0x%x\n",
-						ip_reg[j].reg_name,
-						ip_reg[j].access_size,
-						ip_reg[j].reg_offset,
-						readb_relaxed(virt_addr +
-							ip_reg[j].reg_offset));
-					break;
-					case 16:
-					pr_debug("%-20s, access_size 0x%-2x, offset 0x%-4x, value 0x%x\n",
-						ip_reg[j].reg_name,
-						ip_reg[j].access_size,
-						ip_reg[j].reg_offset,
-						readw(virt_addr +
-							ip_reg[j].reg_offset));
-					break;
-					}
-			}
-		} else {
-			/* For PFC registers, need to unlock before writing */
-			for (j = 0; j < reg_count; j++) {
-				pr_debug("%-20s, access_size 0x%-2x, offset 0x%-4x, value 0x%x\n",
-					ip_reg[j].reg_name,
-					ip_reg[j].access_size,
-					ip_reg[j].reg_offset,
-					ip_reg[j].reg_value);
-
-				writel_relaxed(~ip_reg[j].reg_value,
-					virt_addr + ip_reg[0].reg_offset);
-				writel_relaxed(ip_reg[j].reg_value,
-						virt_addr +
-						ip_reg[j].reg_offset);
-				pr_debug("%-20s, access_size 0x%-2x, offset 0x%-4x, value 0x%x\n",
-					ip_reg[j].reg_name,
-					ip_reg[j].access_size,
-					ip_reg[j].reg_offset,
-					readl_relaxed(virt_addr +
-						ip_reg[j].reg_offset));
-			}
+			pr_debug("%-20s, access_size 0x%-2x, offset 0x%-4x, value 0x%x\n",
+				ip_reg[j].reg_name,
+				ip_reg[j].access_size,
+				ip_reg[j].reg_offset,
+				readl_relaxed(virt_addr +
+					ip_reg[j].reg_offset));
 		}
 	}
 
 	return 0;
 }
+
+/*
+ * Handle backup/restore of IP register
+ *     ip: IP to be processed
+ *     handling: Flag of processing
+ *         DO_IOREMAP: ioremap
+ *         DO_BACKUP: backup
+ *         DO_RESTORE: restore
+ */
+int rcar_handle_registers(struct rcar_ip *ip, unsigned int handling)
+{
+	int ret = 0;
+
+	switch (handling) {
+	case DO_IOREMAP:
+		ret = _do_ioremap(ip);
+		break;
+	case DO_BACKUP:
+		ret = _do_backup(ip);
+		break;
+	case DO_RESTORE:
+		ret = _do_restore(ip);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
 EXPORT_SYMBOL(rcar_handle_registers);
 
 /*
diff --git a/include/linux/soc/renesas/s2ram_ddr_backup.h b/include/linux/soc/renesas/s2ram_ddr_backup.h
index 4f2cc96..f6b74df 100644
--- a/include/linux/soc/renesas/s2ram_ddr_backup.h
+++ b/include/linux/soc/renesas/s2ram_ddr_backup.h
@@ -26,15 +26,17 @@ struct rcar_ip {
 };
 
 #ifdef CONFIG_RCAR_DDR_BACKUP
-int handle_registers(struct rcar_ip *ip, unsigned int handling);
-int handle_ips(struct rcar_ip **ip, unsigned int handling);
+int rcar_handle_registers(struct rcar_ip *ip, unsigned int handling);
+int rcar_handle_ips(struct rcar_ip **ip, unsigned int handling);
 #else
-static inline int handle_registers(struct rcar_ip *ip, unsigned int handling)
+static inline int rcar_handle_registers(struct rcar_ip *ip,
+		unsigned int handling)
 {
 	return 0;
 }
 
-static inline int handle_ips(struct rcar_ip **ip, unsigned int handling)
+static inline int rcar_handle_ips(struct rcar_ip **ip,
+		unsigned int handling)
 {
 	return 0;
 }
-- 
1.7.5.4

