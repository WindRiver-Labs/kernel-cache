From b33ec4719f33df7a089871127001a54fcf76ec5d Mon Sep 17 00:00:00 2001
From: Geert Uytterhoeven <geert+renesas@glider.be>
Date: Fri, 21 Aug 2015 20:02:55 +0200
Subject: [PATCH 0244/2066] serial: sh-sci: Don't call sci_rx_interrupt() on
 error when using DMA

upstream e6403c112f8cf573147f621533d2fa2c3fe015de commit

The error handler calls sci_rx_interrupt() to drain the receive FIFO if
an error condition happens.

However, if DMA is enabled on SCIFA or SCIFB, this will call
disable_irq_nosync() twice. Due to this imbalance, the receive interrupt
will never be re-enabled, and reception stops forever.

To fix this, restrict draining the FIFO to PIO mode, and just call
sci_receive_chars() directly.

Inspired by a patch from Yoshihiro Shimoda
<yoshihiro.shimoda.uh@renesas.com>.

Reported-by: Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>
Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
---
 drivers/tty/serial/sh-sci.c |    4 +++-
 1 files changed, 3 insertions(+), 1 deletions(-)

diff --git a/drivers/tty/serial/sh-sci.c b/drivers/tty/serial/sh-sci.c
index c7211d7..a13ed8e 100644
--- a/drivers/tty/serial/sh-sci.c
+++ b/drivers/tty/serial/sh-sci.c
@@ -993,6 +993,7 @@ static irqreturn_t sci_tx_interrupt(int irq, void *ptr)
 static irqreturn_t sci_er_interrupt(int irq, void *ptr)
 {
 	struct uart_port *port = ptr;
+	struct sci_port *s = to_sci_port(port);
 
 	/* Handle errors */
 	if (port->type == PORT_SCI) {
@@ -1003,7 +1004,8 @@ static irqreturn_t sci_er_interrupt(int irq, void *ptr)
 		}
 	} else {
 		sci_handle_fifo_overrun(port);
-		sci_rx_interrupt(irq, ptr);
+		if (!s->chan_rx)
+			sci_receive_chars(ptr);
 	}
 
 	sci_clear_SCxSR(port, SCxSR_ERROR_CLEAR(port));
-- 
1.7.5.4

