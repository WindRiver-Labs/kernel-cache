From cd130c875e0472d68b77b6422fd7a137884ce078 Mon Sep 17 00:00:00 2001
From: Hien Dang <hien.dang.eb@rvc.renesas.com>
Date: Thu, 21 Apr 2016 13:15:42 +0700
Subject: [PATCH 1634/2066] soc: s2ram_ddr_backup: Support S2RAM core
 functions for R-Car SoC

This will enable S2RAM core functions for R-Car SoC.
For common modules, this core will handle.
Each device driver will have to handle its register
backup/restore through suspend/resume handlers by using
functions exported by this core.

This code is based on implementation of
Khiem Nguyen <khiem.nguyen.xt@rvc.renesas.com>

Signed-off-by: Hien Dang <hien.dang.eb@rvc.renesas.com>
[zou:Original patch taken from
git://git.kernel.org/pub/scm/linux/kernel/git/horms/renesas-bsp.git
 v4.9/rcar-3.5.1]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 drivers/soc/renesas/s2ram_ddr_backup.c       |  251 ++++++++++++++++++++++++++
 include/linux/soc/renesas/s2ram_ddr_backup.h |   43 +++++
 2 files changed, 294 insertions(+), 0 deletions(-)
 create mode 100644 drivers/soc/renesas/s2ram_ddr_backup.c
 create mode 100644 include/linux/soc/renesas/s2ram_ddr_backup.h

diff --git a/drivers/soc/renesas/s2ram_ddr_backup.c b/drivers/soc/renesas/s2ram_ddr_backup.c
new file mode 100644
index 0000000..41ba392
--- /dev/null
+++ b/drivers/soc/renesas/s2ram_ddr_backup.c
@@ -0,0 +1,251 @@
+/*
+ * S2RAM supports for DDR Power-Supply Backup/Restore Function
+ *
+ * Copyright (C) 2016 Renesas Electronics Corporation.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/sizes.h>
+#include <linux/soc/renesas/s2ram_ddr_backup.h>
+#include <linux/syscore_ops.h>
+#include <linux/io.h>
+
+/* Special code for RWDT write access*/
+#define RWTCNT_CODE 0x5a5a0000
+#define RWTCSRA_CODE 0xa5a5a500
+
+/*
+ * Handle backup/restore of IP register
+ *     ip: IP to be processed
+ *     handling: Flag of processing
+ *         DO_IOREMAP: ioremap
+ *         DO_BACKUP: backup
+ *         DO_RESTORE: restore
+ */
+int handle_registers(struct rcar_ip *ip, unsigned int handling)
+{
+	int reg_count = 0;
+	unsigned int j;
+	void __iomem *virt_addr = NULL;
+	struct hw_register *ip_reg;
+
+	if (handling == DO_IOREMAP) { /* ioremap */
+		/* Called during boot process */
+		virt_addr = ioremap_nocache(ip->base_addr, ip->size);
+		if (virt_addr == NULL) {
+			pr_debug("s2ram: %s: Could not remap IP register\n",
+				__func__);
+			return -ENOMEM;
+		}
+
+		ip->virt_addr = virt_addr;
+
+		pr_debug("s2ram ioremap: %s: Working with %s, size 0x%x, virt_addr 0x%p\n",
+			__func__, ip->ip_name, ip->size, ip->virt_addr);
+
+	} else if (handling == DO_BACKUP) { /* backup */
+		if (ip->virt_addr == NULL) {
+			pr_debug("s2ram backup: %s: iomem has not been mapped\n",
+				__func__);
+			return -ENOMEM;
+		}
+
+		ip_reg    = ip->ip_reg;
+		reg_count = ip->reg_count;
+		virt_addr = ip->virt_addr;
+
+		pr_debug("s2ram backup: %s:  Working with %s, size 0x%x, virt_addr 0x%p\n",
+			  __func__, ip->ip_name, ip->size, ip->virt_addr);
+
+		for (j = 0; j < reg_count; j++) {
+			pr_debug("%-20ss, access_size 0x%-2x, offset 0x%-4x, value 0x%x\n",
+				  ip_reg[j].reg_name, ip_reg[j].access_size,
+				  ip_reg[j].reg_offset, ip_reg[j].reg_value);
+
+			switch (ip_reg[j].access_size) {
+			case 8:
+				ip_reg[j].reg_value =
+					readb_relaxed(virt_addr +
+						      ip_reg[j].reg_offset);
+				break;
+			case 16:
+				ip_reg[j].reg_value =
+					readw_relaxed(virt_addr +
+						      ip_reg[j].reg_offset);
+				break;
+			case 32:
+				ip_reg[j].reg_value =
+					readl_relaxed(virt_addr +
+						      ip_reg[j].reg_offset);
+				break;
+			}
+
+			pr_debug("%-20s, access_size 0x%-2x, offset 0x%-4x, value 0x%x\n",
+				  ip_reg[j].reg_name, ip_reg[j].access_size,
+				  ip_reg[j].reg_offset, ip_reg[j].reg_value);
+		}
+	} else { /* restore */
+		if (ip->virt_addr == NULL) {
+			pr_debug("s2ram backup: %s: iomem has not been mapped\n",
+				__func__);
+			return -ENOMEM;
+		}
+
+		ip_reg    = ip->ip_reg;
+		reg_count = ip->reg_count;
+		virt_addr = ip->virt_addr;
+
+		pr_debug("s2ram restore: %s: Working with %s, size 0x%x, virt_addr 0x%p\n",
+			  __func__, ip->ip_name, ip->size, ip->virt_addr);
+
+		if (strcmp(ip->ip_name, "PFC") && strcmp(ip->ip_name, "RWDT")) {
+			for (j = 0; j < reg_count; j++) {
+				pr_debug("%-20s, access_size 0x%-2x, offset 0x%-4x, value 0x%x\n",
+					ip_reg[j].reg_name,
+					ip_reg[j].access_size,
+					ip_reg[j].reg_offset,
+					ip_reg[j].reg_value);
+
+				switch (ip_reg[j].access_size) {
+				case 8:
+					writeb_relaxed(ip_reg[j].reg_value,
+						virt_addr +
+						ip_reg[j].reg_offset);
+					break;
+				case 16:
+					writew_relaxed(ip_reg[j].reg_value,
+						virt_addr +
+						ip_reg[j].reg_offset);
+					break;
+				case 32:
+					writel_relaxed(ip_reg[j].reg_value,
+						virt_addr +
+						ip_reg[j].reg_offset);
+					break;
+				}
+
+				pr_debug("%-20s, access_size 0x%-2x, offset 0x%-4x, value 0x%x\n",
+					ip_reg[j].reg_name,
+					ip_reg[j].access_size,
+					ip_reg[j].reg_offset,
+					readl_relaxed(virt_addr +
+						ip_reg[j].reg_offset));
+			}
+		} else if (!strcmp(ip->ip_name, "RWDT")) {
+			/* For RWDT registers, need special way to write */
+			for (j = 0; j < reg_count; j++) {
+				pr_debug("%-20s, access_size 0x%-2x, offset 0x%-4x, value 0x%x\n",
+					ip_reg[j].reg_name,
+					ip_reg[j].access_size,
+					ip_reg[j].reg_offset,
+					ip_reg[j].reg_value);
+
+				writel_relaxed(ip_reg[j].reg_value |
+					(!ip_reg[j].reg_offset ? RWTCNT_CODE
+						: RWTCSRA_CODE),
+					virt_addr +
+					ip_reg[j].reg_offset);
+					switch (ip_reg[j].access_size) {
+					case 8:
+					pr_debug("%-20s, access_size 0x%-2x, offset 0x%-4x, value 0x%x\n",
+						ip_reg[j].reg_name,
+						ip_reg[j].access_size,
+						ip_reg[j].reg_offset,
+						readb_relaxed(virt_addr +
+							ip_reg[j].reg_offset));
+					break;
+					case 16:
+					pr_debug("%-20s, access_size 0x%-2x, offset 0x%-4x, value 0x%x\n",
+						ip_reg[j].reg_name,
+						ip_reg[j].access_size,
+						ip_reg[j].reg_offset,
+						readw(virt_addr +
+							ip_reg[j].reg_offset));
+					break;
+					}
+			}
+		} else {
+			/* For PFC registers, need to unlock before writing */
+			for (j = 0; j < reg_count; j++) {
+				pr_debug("%-20s, access_size 0x%-2x, offset 0x%-4x, value 0x%x\n",
+					ip_reg[j].reg_name,
+					ip_reg[j].access_size,
+					ip_reg[j].reg_offset,
+					ip_reg[j].reg_value);
+
+				writel_relaxed(~ip_reg[j].reg_value,
+					virt_addr + ip_reg[0].reg_offset);
+				writel_relaxed(ip_reg[j].reg_value,
+						virt_addr +
+						ip_reg[j].reg_offset);
+				pr_debug("%-20s, access_size 0x%-2x, offset 0x%-4x, value 0x%x\n",
+					ip_reg[j].reg_name,
+					ip_reg[j].access_size,
+					ip_reg[j].reg_offset,
+					readl_relaxed(virt_addr +
+						ip_reg[j].reg_offset));
+			}
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * Handle backup/restore of IPs
+ *     ip: Point to address of IP list to be processed
+ *     handling: Flag of processing
+ *         DO_IOREMAP: ioremap
+ *         DO_BACKUP: backup
+ *         DO_RESTORE: restore
+ */
+int handle_ips(struct rcar_ip **ip, unsigned int handling)
+{
+	struct rcar_ip *working_ip;
+	unsigned int i = 0;
+	unsigned int ret = 0;
+
+	while (ip[i] != NULL) {
+		working_ip = ip[i];
+		ret = handle_registers(working_ip, handling);
+		i++;
+	}
+
+	return ret;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int ddr_bck_suspend(void)
+{
+	/* Emtpy for now  */
+	return 0;
+}
+
+static void ddr_bck_resume(void)
+{
+	/* Empty for now  */
+}
+
+static struct syscore_ops ddr_bck_syscore_ops = {
+	.suspend = ddr_bck_suspend,
+	.resume = ddr_bck_resume,
+};
+
+static int ddr_bck_init(void)
+{
+	register_syscore_ops(&ddr_bck_syscore_ops);
+
+	return 0;
+}
+core_initcall(ddr_bck_init);
+
+#endif /* CONFIG_PM_SLEEP */
diff --git a/include/linux/soc/renesas/s2ram_ddr_backup.h b/include/linux/soc/renesas/s2ram_ddr_backup.h
new file mode 100644
index 0000000..4f2cc96
--- /dev/null
+++ b/include/linux/soc/renesas/s2ram_ddr_backup.h
@@ -0,0 +1,43 @@
+#ifndef S2RAM_DDR_BACKUP_H
+#define S2RAM_DDR_BACKUP_H
+
+#include <linux/types.h>
+
+enum {
+	DO_IOREMAP,
+	DO_BACKUP,
+	DO_RESTORE,
+};
+
+struct hw_register {
+	char *reg_name;
+	unsigned int reg_offset;
+	unsigned int access_size;
+	unsigned int reg_value;
+};
+
+struct rcar_ip {
+	char *ip_name;
+	void __iomem *virt_addr;
+	phys_addr_t base_addr;
+	unsigned int size;
+	unsigned int reg_count;
+	struct hw_register *ip_reg;
+};
+
+#ifdef CONFIG_RCAR_DDR_BACKUP
+int handle_registers(struct rcar_ip *ip, unsigned int handling);
+int handle_ips(struct rcar_ip **ip, unsigned int handling);
+#else
+static inline int handle_registers(struct rcar_ip *ip, unsigned int handling)
+{
+	return 0;
+}
+
+static inline int handle_ips(struct rcar_ip **ip, unsigned int handling)
+{
+	return 0;
+}
+#endif /* CONFIG_RCAR_DDR_BACKUP */
+
+#endif /* S2RAM_DDR_BACKUP_H */
-- 
1.7.5.4

