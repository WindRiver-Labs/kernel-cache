From 2ef660de6f5fb411c1e13fba877dd6f5bae90350 Mon Sep 17 00:00:00 2001
From: Masaharu Hayakawa <masaharu.hayakawa.ry@renesas.com>
Date: Tue, 6 Dec 2016 10:29:53 +0900
Subject: [PATCH 1391/2066] mmc: sh_mobile_sdhi: Add detecting a change point
 of data to SCC tuning

If all of the TAP are OK by SCC tuning, a data change point is detected
in order to select a more suitable sampling clock position.

Signed-off-by: Masaharu Hayakawa <masaharu.hayakawa.ry@renesas.com>
[zou:Original patch taken from
git://git.kernel.org/pub/scm/linux/kernel/git/horms/renesas-bsp.git
 v4.9/rcar-3.5.1]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 drivers/mmc/host/sh_mobile_sdhi.c |   50 ++++++++++++++++++++++++++++++++++++-
 1 files changed, 49 insertions(+), 1 deletions(-)

diff --git a/drivers/mmc/host/sh_mobile_sdhi.c b/drivers/mmc/host/sh_mobile_sdhi.c
index 5b51598..1df23ea 100644
--- a/drivers/mmc/host/sh_mobile_sdhi.c
+++ b/drivers/mmc/host/sh_mobile_sdhi.c
@@ -299,6 +299,7 @@ static int sh_mobile_sdhi_start_signal_voltage_switch(struct mmc_host *mmc,
 #define SH_MOBILE_SDHI_SCC_CKSEL	0x006
 #define SH_MOBILE_SDHI_SCC_RVSCNTL	0x008
 #define SH_MOBILE_SDHI_SCC_RVSREQ	0x00A
+#define SH_MOBILE_SDHI_SCC_SMPCMP	0x00C
 #define SH_MOBILE_SDHI_SCC_TMPPORT2	0x00E
 
 /* Definitions for values the SH_MOBILE_SDHI_SCC_DTCNTL register */
@@ -383,6 +384,14 @@ static void sh_mobile_sdhi_prepare_tuning(struct tmio_mmc_host *host,
 	sd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_TAPSET, tap);
 }
 
+static unsigned int sh_mobile_sdhi_compare_scc_data(struct tmio_mmc_host *host)
+{
+	struct sh_mobile_sdhi *priv = host_to_priv(host);
+
+	/* Get comparison of sampling data */
+	return sd_scc_read32(host, priv, SH_MOBILE_SDHI_SCC_SMPCMP);
+}
+
 static void sh_mobile_sdhi_prepare_hs400_tuning(struct mmc_host *mmc,
 					struct mmc_ios *ios)
 {
@@ -414,7 +423,9 @@ static int sh_mobile_sdhi_select_tuning(struct tmio_mmc_host *host)
 	unsigned long tap_start;/* start position of tuning success */
 	unsigned long tap_end;  /* end position of tuning success */
 	unsigned long ntap;     /* temporary counter of tuning success */
+	unsigned long match_cnt;/* counter of matching data */
 	unsigned long i;
+	bool select = false;
 
 	/* Clear SCC_RVSREQ */
 	sd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_RVSREQ, 0);
@@ -426,6 +437,11 @@ static int sh_mobile_sdhi_select_tuning(struct tmio_mmc_host *host)
 			clear_bit((i % host->tap_num) + host->tap_num,
 					host->taps);
 		}
+		if (!test_bit(i, host->smpcmp)) {
+			clear_bit(i % host->tap_num, host->smpcmp);
+			clear_bit((i % host->tap_num) + host->tap_num,
+					host->smpcmp);
+		}
 	}
 
 	/*
@@ -456,7 +472,38 @@ static int sh_mobile_sdhi_select_tuning(struct tmio_mmc_host *host)
 		tap_cnt = ntap;
 	}
 
-	if (tap_cnt >= SH_MOBILE_SDHI_MAX_TAP)
+	/*
+	 * If all of the TAP is OK, the sampling clock position is selected by
+	 * identifying the change point of data.
+	 */
+	if (tap_cnt == host->tap_num * 2) {
+		match_cnt = 0;
+		ntap = 0;
+		tap_start = 0;
+		tap_end = 0;
+		for (i = 0; i < host->tap_num * 2; i++) {
+			if (test_bit(i, host->smpcmp))
+				ntap++;
+			else {
+				if (ntap > match_cnt) {
+					tap_start = i - ntap;
+					tap_end = i - 1;
+					match_cnt = ntap;
+				}
+				ntap = 0;
+			}
+		}
+		if (ntap > match_cnt) {
+			tap_start = i - ntap;
+			tap_end = i - 1;
+			match_cnt = ntap;
+		}
+		if (match_cnt)
+			select = true;
+	} else if (tap_cnt >= SH_MOBILE_SDHI_MAX_TAP)
+		select = true;
+
+	if (select)
 		tap_set = (tap_start + tap_end) / 2 % host->tap_num;
 	else
 		return -EIO;
@@ -673,6 +720,7 @@ static int sh_mobile_sdhi_probe(struct platform_device *pdev)
 			sh_mobile_sdhi_start_signal_voltage_switch;
 		host->init_tuning	= sh_mobile_sdhi_init_tuning;
 		host->prepare_tuning	= sh_mobile_sdhi_prepare_tuning;
+		host->compare_scc_data	= sh_mobile_sdhi_compare_scc_data;
 		host->select_tuning	= sh_mobile_sdhi_select_tuning;
 		host->check_scc_error	= sh_mobile_sdhi_check_scc_error;
 		host->hw_reset		= sh_mobile_sdhi_hw_reset;
-- 
1.7.5.4

