From e057b46d5a88618e9924883dfdbd11d59c640bde Mon Sep 17 00:00:00 2001
From: Koji Matsuoka <koji.matsuoka.xm@renesas.com>
Date: Mon, 9 Nov 2015 18:33:35 +0900
Subject: [PATCH 2057/2066] v4l: vsp1: Fix VSP underrun hang-up workaround

Signed-off-by: Koji Matsuoka <koji.matsuoka.xm@renesas.com>
[zou:Original patch taken from
git://git.kernel.org/pub/scm/linux/kernel/git/horms/renesas-bsp.git
 v4.9/rcar-3.5.]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 drivers/media/platform/vsp1/vsp1.h      |    1 +
 drivers/media/platform/vsp1/vsp1_dl.c   |    7 +++++++
 drivers/media/platform/vsp1/vsp1_drv.c  |   26 ++++++++++++++++----------
 drivers/media/platform/vsp1/vsp1_pipe.c |    5 ++++-
 4 files changed, 28 insertions(+), 11 deletions(-)

diff --git a/drivers/media/platform/vsp1/vsp1.h b/drivers/media/platform/vsp1/vsp1.h
index 43e323c..e5e83fd 100644
--- a/drivers/media/platform/vsp1/vsp1.h
+++ b/drivers/media/platform/vsp1/vsp1.h
@@ -105,6 +105,7 @@ struct vsp1_device {
 
 int vsp1_device_get(struct vsp1_device *vsp1);
 void vsp1_device_put(struct vsp1_device *vsp1);
+void vsp1_underrun_workaround(struct vsp1_device *vsp1, bool reset);
 
 static inline u32 vsp1_read(struct vsp1_device *vsp1, u32 reg)
 {
diff --git a/drivers/media/platform/vsp1/vsp1_dl.c b/drivers/media/platform/vsp1/vsp1_dl.c
index 1f4b816..80635a7 100644
--- a/drivers/media/platform/vsp1/vsp1_dl.c
+++ b/drivers/media/platform/vsp1/vsp1_dl.c
@@ -421,6 +421,9 @@ static int dl_irq_dl_frame_end_header_mode(struct vsp1_dl *dl)
 		dl->next_header = NULL;
 		dl_write(dl, VI6_DL_HDR_ADDR(0),
 				dl->active_header->paddr);
+#ifdef VSP1_UNDERRUN_WORKAROUND
+		dl->vsp1->dl_addr = dl->active_header->paddr;
+#endif
 		break;
 
 	case DL_REPEAT_NONE:
@@ -513,6 +516,10 @@ int vsp1_dl_irq_display_start(struct vsp1_device *vsp1)
 		dl_write(dl, VI6_DL_HDR_ADDR(0), next_body->paddr);
 		dl_write(dl, VI6_DL_BODY_SIZE,
 			(next_body->reg_count * 8) | VI6_DL_BODY_SIZE_UPD);
+#ifdef VSP1_UNDERRUN_WORKAROUND
+		dl->vsp1->dl_addr = next_body->paddr;
+		dl->vsp1->dl_body = (next_body->reg_count * 8) | VI6_DL_BODY_SIZE_UPD;
+#endif
 	}
 
 	return 0;
diff --git a/drivers/media/platform/vsp1/vsp1_drv.c b/drivers/media/platform/vsp1/vsp1_drv.c
index 53eb327..666616f 100644
--- a/drivers/media/platform/vsp1/vsp1_drv.c
+++ b/drivers/media/platform/vsp1/vsp1_drv.c
@@ -87,7 +87,7 @@ static const unsigned int fcpvd_offset[] = {
 	FCPVD0_REG, FCPVD1_REG, FCPVD2_REG, FCPVD3_REG
 };
 
-static void vsp1_underrun_workaround(struct vsp1_device *vsp1)
+void vsp1_underrun_workaround(struct vsp1_device *vsp1, bool reset)
 {
 	unsigned int timeout = 0;
 
@@ -114,6 +114,7 @@ static void vsp1_underrun_workaround(struct vsp1_device *vsp1)
 
 		if (timeout == 100)
 			break;
+
 		timeout++;
 		udelay(1);
 	}
@@ -135,12 +136,14 @@ static void vsp1_underrun_workaround(struct vsp1_device *vsp1)
 	vsp1_write(vsp1, VI6_CLK_DCSM1, 0);
 
 	/* 8. Restart VSPD */
+	if (!reset) {
 #ifdef VSP1_DL_SUPPORT
-	/* Necessary when headerless display list */
-	vsp1_write(vsp1, VI6_DL_HDR_ADDR(0), vsp1->dl_addr);
-	vsp1_write(vsp1, VI6_DL_BODY_SIZE, vsp1->dl_body);
+		/* Necessary when headerless display list */
+		vsp1_write(vsp1, VI6_DL_HDR_ADDR(0), vsp1->dl_addr);
+		vsp1_write(vsp1, VI6_DL_BODY_SIZE, vsp1->dl_body);
 #endif
-	vsp1_write(vsp1, VI6_CMD(0), VI6_CMD_STRCMD);
+		vsp1_write(vsp1, VI6_CMD(0), VI6_CMD_STRCMD);
+	}
 }
 #endif
 
@@ -177,11 +180,6 @@ static irqreturn_t vsp1_irq_handler(int irq, void *data)
 				vsp_und_cnt, dev_name(vsp1->dev));
 		}
 
-#ifdef VSP1_UNDERRUN_WORKAROUND
-		if (status & VI6_WFP_IRQ_STA_UND)
-			vsp1_underrun_workaround(vsp1);
-#endif
-
 		if (status & VI6_WFP_IRQ_STA_FRE) {
 			vsp1_pipeline_frame_end(pipe);
 			ret = IRQ_HANDLED;
@@ -200,6 +198,10 @@ static irqreturn_t vsp1_irq_handler(int irq, void *data)
 			ret = IRQ_HANDLED;
 		}
 #endif
+#ifdef VSP1_UNDERRUN_WORKAROUND
+		if (status & VI6_WFP_IRQ_STA_UND)
+			vsp1_underrun_workaround(vsp1, false);
+#endif
 	}
 
 	return ret;
@@ -540,7 +542,11 @@ static int vsp1_device_init(struct vsp1_device *vsp1)
 		if (!(status & VI6_STATUS_SYS_ACT(i)))
 			continue;
 
+#ifdef VSP1_UNDERRUN_WORKAROUND
+		vsp1_underrun_workaround(vsp1, true);
+#else
 		vsp1_write(vsp1, VI6_SRESET, VI6_SRESET_SRTS(i));
+#endif
 		for (timeout = 10; timeout > 0; --timeout) {
 			status = vsp1_read(vsp1, VI6_STATUS);
 			if (!(status & VI6_STATUS_SYS_ACT(i)))
diff --git a/drivers/media/platform/vsp1/vsp1_pipe.c b/drivers/media/platform/vsp1/vsp1_pipe.c
index 88b5dcf..d1a347f 100644
--- a/drivers/media/platform/vsp1/vsp1_pipe.c
+++ b/drivers/media/platform/vsp1/vsp1_pipe.c
@@ -229,9 +229,12 @@ int vsp1_pipeline_stop(struct vsp1_pipeline *pipe)
 			ret = 0;
 			goto done;
 		}
-
+#ifdef VSP1_UNDERRUN_WORKAROUND
+		vsp1_underrun_workaround(pipe->output->entity.vsp1, true);
+#else
 		vsp1_write(pipe->output->entity.vsp1, VI6_SRESET,
 				VI6_SRESET_SRTS(pipe->output->entity.index));
+#endif
 		for (timeout = 10; timeout > 0; --timeout) {
 			status = vsp1_read(pipe->output->entity.vsp1,
 							 VI6_STATUS);
-- 
1.7.5.4

