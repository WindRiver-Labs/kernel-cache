From 73286d6689fba7f0d234a470438af3dea467c061 Mon Sep 17 00:00:00 2001
From: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
Date: Tue, 11 Aug 2015 00:40:21 +0300
Subject: [PATCH 2042/2066] v4l: vsp1: Support disabling and already disabled
 RPF

The DU DRM/KMS driver can disable planes on a disabled CRTC. As
disabling the CRTC disables the LIF, which in turn disables all RPFs,
we need to properly handle disabling an already disabled RPF without
messing up the pipeline inputs count.

Signed-off-by: Laurent Pinchart <laurent.pinchart+renesas@ideasonboard.com>
[zou:Original patch taken from
git://git.kernel.org/pub/scm/linux/kernel/git/horms/renesas-bsp.git
 v4.9/rcar-3.5.]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 drivers/media/platform/vsp1/vsp1_drm.c |   21 ++++++++++++---------
 1 files changed, 12 insertions(+), 9 deletions(-)

diff --git a/drivers/media/platform/vsp1/vsp1_drm.c b/drivers/media/platform/vsp1/vsp1_drm.c
index 541617d..b9cb5b2 100644
--- a/drivers/media/platform/vsp1/vsp1_drm.c
+++ b/drivers/media/platform/vsp1/vsp1_drm.c
@@ -265,7 +265,8 @@ EXPORT_SYMBOL_GPL(vsp1_du_setup_lif);
  *
  * Image format as stored in memory is expressed as a V4L2 @pixelformat value.
  * As a special case, setting the pixel format to 0 will disable the RPF. The
- * @pitch, @mem, @src and @dst parameters are ignored in that case.
+ * @pitch, @mem, @src and @dst parameters are ignored in that case. Calling the
+ * function on a disabled RPF is allowed.
  *
  * The memory pitch is configurable to allow for padding at end of lines, or
  * simple for images that extend beyond the crop rectangle boundaries. The
@@ -296,7 +297,7 @@ int vsp1_du_setup_rpf(struct device *dev, unsigned int rpf_index,
 	struct vsp1_rwpf_memory memory;
 	struct vsp1_rwpf *rpf;
 	unsigned long flags;
-	bool start_stop;
+	bool start_stop = false;
 	int ret;
 
 	if (rpf_index >= vsp1->pdata.rpf_count)
@@ -310,12 +311,16 @@ int vsp1_du_setup_rpf(struct device *dev, unsigned int rpf_index,
 
 		spin_lock_irqsave(&pipe->irqlock, flags);
 
-		/* Remove the RPF from the pipeline. */
-		vsp1->bru->inputs[rpf_index].rpf = NULL;
-		pipe->inputs[rpf_index] = NULL;
+		if (pipe->inputs[rpf_index]) {
+			/* Remove the RPF from the pipeline if it was previously
+			 * enabled.
+			 */
+			vsp1->bru->inputs[rpf_index].rpf = NULL;
+			pipe->inputs[rpf_index] = NULL;
 
-		vsp1->drm->update = true;
-		start_stop = --pipe->num_inputs == 0;
+			vsp1->drm->update = true;
+			start_stop = --pipe->num_inputs == 0;
+		}
 
 		spin_unlock_irqrestore(&pipe->irqlock, flags);
 
@@ -440,8 +445,6 @@ int vsp1_du_setup_rpf(struct device *dev, unsigned int rpf_index,
 		vsp1->bru->inputs[rpf_index].rpf = rpf;
 		pipe->inputs[rpf->entity.index] = rpf;
 		start_stop = pipe->num_inputs++ == 0;
-	} else {
-		start_stop = false;
 	}
 
 	/* Start the pipeline if it's currently stopped. */
-- 
1.7.5.4

