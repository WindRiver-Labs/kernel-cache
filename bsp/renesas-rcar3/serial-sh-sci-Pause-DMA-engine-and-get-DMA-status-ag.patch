From 17bfe8937321593d967ad9e21f8d05b04a6c7b8f Mon Sep 17 00:00:00 2001
From: Muhammad Hamza Farooq <mfarooq@visteon.com>
Date: Fri, 18 Sep 2015 13:08:32 +0200
Subject: [PATCH 0891/2066] serial: sh-sci: Pause DMA engine and get DMA
 status again

upstream e7327c09def48ccfd204025726f11b57a19a9c24 commit

Occasionally, DMA transaction completes _after_ DMA engine is stopped.
Verify if the transaction has not finished before forcing the engine to
stop and push the data

Signed-off-by: Muhammad Hamza Farooq <mfarooq@visteon.com>
Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
---
 drivers/tty/serial/sh-sci.c |   16 ++++++++++++++++
 1 files changed, 16 insertions(+), 0 deletions(-)

diff --git a/drivers/tty/serial/sh-sci.c b/drivers/tty/serial/sh-sci.c
index 4c63716..a2ae843 100644
--- a/drivers/tty/serial/sh-sci.c
+++ b/drivers/tty/serial/sh-sci.c
@@ -1340,6 +1340,7 @@ static void work_fn_tx(struct work_struct *work)
 static void rx_timer_fn(unsigned long arg)
 {
 	struct sci_port *s = (struct sci_port *)arg;
+	struct dma_chan *chan = s->chan_rx;
 	struct uart_port *port = &s->port;
 	struct dma_tx_state state;
 	enum dma_status status;
@@ -1368,6 +1369,21 @@ static void rx_timer_fn(unsigned long arg)
 		return;
 	}
 
+	dmaengine_pause(chan);
+
+	/*
+	 * sometimes DMA transfer doesn't stop even if it is stopped and
+	 * data keeps on coming until transaction is complete so check
+	 * for DMA_COMPLETE again
+	 * Let packet complete handler take care of the packet
+	 */
+	status = dmaengine_tx_status(s->chan_rx, s->active_rx, &state);
+	if (status == DMA_COMPLETE) {
+		spin_unlock_irqrestore(&port->lock, flags);
+		dev_dbg(port->dev, "Transaction complete after DMA engine was stopped");
+		return;
+	}
+
 	/* Handle incomplete DMA receive */
 	dmaengine_terminate_all(s->chan_rx);
 	read = sg_dma_len(&s->sg_rx[active]) - state.residue;
-- 
1.7.5.4

