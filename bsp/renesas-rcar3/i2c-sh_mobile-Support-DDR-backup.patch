From 1191e8fd744599633e82b91478c8059d79577834 Mon Sep 17 00:00:00 2001
From: Khiem Nguyen <khiem.nguyen.xt@rvc.renesas.com>
Date: Fri, 26 Feb 2016 22:21:11 +0700
Subject: [PATCH 1642/2066] i2c: sh_mobile: Support DDR backup

Signed-off-by: Hien Dang <hien.dang.eb@rvc.renesas.com>
Signed-off-by: Takeshi Kihara <takeshi.kihara.df@renesas.com>
[zou:Original patch taken from
git://git.kernel.org/pub/scm/linux/kernel/git/horms/renesas-bsp.git
 v4.9/rcar-3.5.1]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 drivers/i2c/busses/i2c-sh_mobile.c |   49 ++++++++++++++++++++++++++++++++++++
 1 files changed, 49 insertions(+), 0 deletions(-)

diff --git a/drivers/i2c/busses/i2c-sh_mobile.c b/drivers/i2c/busses/i2c-sh_mobile.c
index 6b12da3..abf059d 100644
--- a/drivers/i2c/busses/i2c-sh_mobile.c
+++ b/drivers/i2c/busses/i2c-sh_mobile.c
@@ -34,6 +34,7 @@
 #include <linux/platform_device.h>
 #include <linux/pm_runtime.h>
 #include <linux/slab.h>
+#include <linux/soc/renesas/s2ram_ddr_backup.h>
 
 /* Transmit operation:                                                      */
 /*                                                                          */
@@ -153,6 +154,24 @@ struct sh_mobile_dt_config {
 	void (*setup)(struct sh_mobile_i2c_data *pd);
 };
 
+#ifdef CONFIG_RCAR_DDR_BACKUP
+static struct hw_register i2c_dvfs_ip_regs[] = {
+	{"ICDR",   0x00, 8, 0},
+	{"ICCR",   0x04, 8, 0},
+	{"ICIC",   0x0C, 8, 0},
+	{"ICCL",   0x10, 8, 0},
+	{"ICCH",   0x14, 8, 0},
+	{"ICTC",   0x28, 8, 0},
+	{"ICVCON", 0x6C, 8, 0},
+};
+
+static struct rcar_ip i2c_dvfs_ip = {
+	.ip_name = "I2C_DVFS",
+	.reg_count = ARRAY_SIZE(i2c_dvfs_ip_regs),
+	.ip_reg = i2c_dvfs_ip_regs,
+};
+#endif /* CONFIG_RCAR_DDR_BACKUP */
+
 #define IIC_FLAG_HAS_ICIC67	(1 << 0)
 
 #define STANDARD_MODE		100000
@@ -1014,7 +1033,37 @@ static int sh_mobile_i2c_runtime_nop(struct device *dev)
 	return 0;
 }
 
+#ifdef CONFIG_PM_SLEEP
+static int sh_mobile_i2c_suspend(struct device *dev)
+{
+	int ret = 0;
+#ifdef CONFIG_RCAR_DDR_BACKUP
+	struct sh_mobile_i2c_data *i2c_data = dev_get_drvdata(dev);
+
+	if (!i2c_dvfs_ip.virt_addr)
+		i2c_dvfs_ip.virt_addr = i2c_data->reg;
+	ret = handle_registers(&i2c_dvfs_ip, DO_BACKUP);
+#endif /* CONFIG_RCAR_DDR_BACKUP  */
+	return ret;
+}
+
+static int sh_mobile_i2c_resume(struct device *dev)
+{
+	int ret = 0;
+#ifdef CONFIG_RCAR_DDR_BACKUP
+	ret = handle_registers(&i2c_dvfs_ip, DO_RESTORE);
+#endif /* CONFIG_RCAR_DDR_BACKUP  */
+	return ret;
+}
+
+#else
+#define sh_mobile_i2c_suspend	NULL
+#define sh_mobile_i2c_resume	NULL
+#endif /* CONFIG_PM_SLEEP */
+
 static const struct dev_pm_ops sh_mobile_i2c_dev_pm_ops = {
+	.suspend = sh_mobile_i2c_suspend,
+	.resume = sh_mobile_i2c_resume,
 	.runtime_suspend = sh_mobile_i2c_runtime_nop,
 	.runtime_resume = sh_mobile_i2c_runtime_nop,
 };
-- 
1.7.5.4

