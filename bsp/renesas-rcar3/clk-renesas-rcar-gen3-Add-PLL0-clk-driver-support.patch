From 7fdeb4fa6e07757890611d9c9ef244f720f37a05 Mon Sep 17 00:00:00 2001
From: Dien Pham <dien.pham.ry@renesas.com>
Date: Fri, 16 Dec 2016 11:04:31 +0700
Subject: [PATCH 1257/2066] clk: renesas: rcar-gen3: Add PLL0 clk driver
 support

With parent clock is 33.33MHz,
PLL0 driver supports to change frequency in range:
Min: 1.5 GHz
Max: 1.7 GHz(H3), 1.8 GHz(M3)

Signed-off-by: Dien Pham <dien.pham.ry@renesas.com>
[zou:Original patch taken from
git://git.kernel.org/pub/scm/linux/kernel/git/horms/renesas-bsp.git
 v4.9/rcar-3.5.1]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 drivers/clk/renesas/rcar-gen3-cpg.c |  192 +++++++++++++++++++++++++++++++----
 1 files changed, 173 insertions(+), 19 deletions(-)

diff --git a/drivers/clk/renesas/rcar-gen3-cpg.c b/drivers/clk/renesas/rcar-gen3-cpg.c
index 47d037c..9a27a41 100644
--- a/drivers/clk/renesas/rcar-gen3-cpg.c
+++ b/drivers/clk/renesas/rcar-gen3-cpg.c
@@ -45,9 +45,134 @@ static const struct soc_device_attribute r8a7796es10[] = {
 #define CPG_PLL2CR		0x002c
 #define CPG_PLL4CR		0x01f4
 
-/** Modify for Z-clock
- * -----------------------------------------------------------------------------
- * Z Clock & Z2 Clock
+/* Implementation for customized clocks (Z-clk, Z2-clk, PLL0-clk) for CPUFreq */
+#define CPG_PLLECR     0x00D0
+#define CPG_PLLECR_PLL0ST (1 << 8)
+
+
+/* Define for PLL0 clk driver */
+#define CPG_PLL0CR_STC_MASK             0x7f000000
+#define CPG_PLL0CR_STC_SHIFT            24
+
+#ifdef CONFIG_RCAR_Z_CLK_MAX_THRESHOLD
+#define Z_CLK_MAX_THRESHOLD     CONFIG_RCAR_Z_CLK_MAX_THRESHOLD
+#else
+#define Z_CLK_MAX_THRESHOLD             1500000000
+#endif
+
+struct cpg_pll0_clk {
+	struct clk_hw hw;
+	void __iomem *reg;
+	void __iomem *pllecr_reg;
+};
+
+#define to_pll0_clk(_hw)   container_of(_hw, struct cpg_pll0_clk, hw)
+
+static int cpg_pll0_clk_set_rate(struct clk_hw *hw, unsigned long rate,
+				unsigned long prate)
+{
+	struct cpg_pll0_clk *pll0_clk = to_pll0_clk(hw);
+	unsigned int stc_val;
+	u32 val;
+	int i;
+
+	stc_val = DIV_ROUND_CLOSEST(rate, prate);
+	stc_val = clamp(stc_val, 90U, 120U);/*Lowest value is 1.5G (stc == 90)*/
+	pr_debug("%s(): prate: %lu, rate: %lu, pll0-mult: %d\n",
+		__func__, prate, rate, stc_val);
+
+	stc_val -= 1;
+	val = clk_readl(pll0_clk->reg);
+	val &= ~CPG_PLL0CR_STC_MASK;
+	val |= stc_val << CPG_PLL0CR_STC_SHIFT;
+	clk_writel(val, pll0_clk->reg);
+
+	i = 0;
+	while (!(clk_readl(pll0_clk->pllecr_reg) & CPG_PLLECR_PLL0ST)) {
+		cpu_relax();
+		i++;
+	}
+
+	if (i > 1000)
+		pr_warn("%s(): PLL0: long settled time: %d\n", __func__, i);
+
+	return 0;
+}
+
+static long cpg_pll0_clk_round_rate(struct clk_hw *hw, unsigned long rate,
+				unsigned long *parent_rate)
+{
+	unsigned long prate = *parent_rate;
+	unsigned int mult;
+
+	if (rate < Z_CLK_MAX_THRESHOLD)
+		rate = Z_CLK_MAX_THRESHOLD; /* Set lowest value: 1.5GHz */
+
+	mult = DIV_ROUND_CLOSEST(rate, prate);
+	mult = clamp(mult, 90U, 120U); /* 1.5G => (stc == 90)*/
+
+	rate = prate * mult;
+
+	/* Round to closest value at 100MHz unit */
+	rate = 100000000 * DIV_ROUND_CLOSEST(rate, 100000000);
+	pr_debug("%s(): output rate: %lu, parent_rate: %lu, pll0-mult: %d\n",
+		__func__, rate, prate, mult);
+	return rate;
+}
+
+static unsigned long cpg_pll0_clk_recalc_rate(struct clk_hw *hw,
+					unsigned long parent_rate)
+{
+	struct cpg_pll0_clk *pll0_clk = to_pll0_clk(hw);
+	unsigned int val;
+	unsigned long rate;
+
+	val = (clk_readl(pll0_clk->reg) & CPG_PLL0CR_STC_MASK)
+		>> CPG_PLL0CR_STC_SHIFT;
+
+	rate = (u64)parent_rate * (val + 1);
+
+	/* Round to closest value at 100MHz unit */
+	rate = 100000000 * DIV_ROUND_CLOSEST(rate, 100000000);
+	return rate;
+}
+
+static const struct clk_ops cpg_pll0_clk_ops = {
+	.recalc_rate = cpg_pll0_clk_recalc_rate,
+	.round_rate = cpg_pll0_clk_round_rate,
+	.set_rate = cpg_pll0_clk_set_rate,
+};
+
+static struct clk * __init cpg_pll0_clk_register(const char *name,
+				const char *parent_name,
+				void __iomem *cpg_base)
+{
+	struct clk_init_data init;
+	struct cpg_pll0_clk *pll0_clk;
+	struct clk *clk;
+
+	pll0_clk = kzalloc(sizeof(*pll0_clk), GFP_KERNEL);
+	if (!pll0_clk)
+		return ERR_PTR(-ENOMEM);
+
+	init.name = name;
+	init.ops = &cpg_pll0_clk_ops;
+	init.flags = 0;
+	init.parent_names = &parent_name;
+	init.num_parents = 1;
+
+	pll0_clk->reg = cpg_base + CPG_PLL0CR;
+	pll0_clk->pllecr_reg = cpg_base + CPG_PLLECR;
+	pll0_clk->hw.init = &init;
+
+	clk = clk_register(NULL, &pll0_clk->hw);
+	if (IS_ERR(clk))
+		kfree(pll0_clk);
+
+	return clk;
+}
+
+/* Modify for Z-clock and Z2-clock
  *
  * Traits of this clock:
  * prepare - clk_prepare only ensures that parents are prepared
@@ -115,10 +240,37 @@ static long cpg_z_clk_round_rate(struct clk_hw *hw, unsigned long rate,
 	if (!prate)
 		prate = 1;
 
+	if (rate <= Z_CLK_MAX_THRESHOLD) { /* Focus on changing z-clock */
+		prate = Z_CLK_MAX_THRESHOLD; /* Set parent to: 1.5GHz */
+		mult = div_u64((u64)rate * 32 + prate/2, prate);
+	} else {
+		/* Focus on changing parent. Fix z-clock divider is 32/32 */
+		mult = 32;
+	}
+
+	mult = clamp(mult, 1U, 32U);
+
+	/* Re-calculate the parent_rate to propagate new rate for it */
+	prate = div_u64((u64)rate * 32 + mult/2, mult);
+	prate = 100000000 * DIV_ROUND_CLOSEST(prate, 100000000);
+	rate = 100000000 * DIV_ROUND_CLOSEST(prate / 32 * mult, 100000000);
+	pr_debug("%s():z-clk mult:%d, re-calculated prate:%lu, return: %lu\n",
+		__func__, mult, prate, rate);
+	*parent_rate = prate;
+
+	return rate;
+}
+
+static long cpg_z2_clk_round_rate(struct clk_hw *hw, unsigned long rate,
+				unsigned long *parent_rate)
+{
+	unsigned long prate  = *parent_rate;
+	unsigned int mult;
+
 	mult = div_u64((u64)rate * 32 + prate/2, prate);
 	mult = clamp(mult, 1U, 32U);
 
-	return *parent_rate / 32 * mult;
+	return prate / 32 * mult;
 }
 
 static int cpg_z_clk_set_rate(struct clk_hw *hw, unsigned long rate,
@@ -129,9 +281,16 @@ static int cpg_z_clk_set_rate(struct clk_hw *hw, unsigned long rate,
 	u32 val, kick;
 	unsigned int i;
 
-	mult = div_u64((u64)rate * 32 + parent_rate/2, parent_rate);
+	if (rate <= Z_CLK_MAX_THRESHOLD) { /* Focus on changing z-clock */
+		parent_rate = Z_CLK_MAX_THRESHOLD; /* Set parent to: 1.5GHz */
+		mult = div_u64((u64)rate * 32 + parent_rate/2, parent_rate);
+	} else {
+		mult = 32;
+	}
 	mult = clamp(mult, 1U, 32U);
 
+	pr_debug("%s(): rate: %lu, set prate to: %lu, z-clk mult: %d\n",
+		__func__, rate, parent_rate, mult);
 	if (clk_readl(zclk->kick_reg) & CPG_FRQCRB_KICK)
 		return -EBUSY;
 
@@ -221,7 +380,7 @@ static const struct clk_ops cpg_z_clk_ops = {
 
 static const struct clk_ops cpg_z2_clk_ops = {
 	.recalc_rate = cpg_z2_clk_recalc_rate,
-	.round_rate = cpg_z_clk_round_rate,
+	.round_rate = cpg_z2_clk_round_rate,
 	.set_rate = cpg_z2_clk_set_rate,
 };
 
@@ -239,7 +398,7 @@ static struct clk * __init cpg_z_clk_register(const char *name,
 
 	init.name = name;
 	init.ops = &cpg_z_clk_ops;
-	init.flags = 0;
+	init.flags = CLK_SET_RATE_PARENT;
 	init.parent_names = &parent_name;
 	init.num_parents = 1;
 
@@ -282,7 +441,7 @@ static struct clk * __init cpg_z2_clk_register(const char *name,
 
 	return clk;
 }
-/** End of modifying for Z-clock */
+/** End of modifying for Z-clock, Z2-clock and PLL0-clock */
 
 /*
  * SDn Clock
@@ -525,18 +684,13 @@ struct clk * __init rcar_gen3_cpg_clk_register(struct device *dev,
 
 	case CLK_TYPE_GEN3_PLL0:
 		/*
-		 * PLL0 is a configurable multiplier clock. Register it as a
-		 * fixed factor clock for now as there's no generic multiplier
-		 * clock implementation and we currently have no need to change
-		 * the multiplier value.
+		 * The PLL0 is implemented as customized clock,
+		 * it changes the multiplier when cpufreq changes between
+		 * normal and override mode.
 		 */
-		value = readl(base + CPG_PLL0CR);
-		mult = ((value >> 24) & 0x7f) + 1;
-		/* Start clock issue W/A (for H3 WS1.0) */
-		if (soc_device_match(r8a7795es10))
-			mult *= 2; /* PLL0 output multiplied by 2 */
-		/* End clock issue W/A */
-		break;
+
+		return cpg_pll0_clk_register(core->name,
+				__clk_get_name(parent), base);
 
 	case CLK_TYPE_GEN3_PLL1:
 		mult = cpg_pll_config->pll1_mult;
-- 
1.7.5.4

