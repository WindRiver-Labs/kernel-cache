From 9b67bd7d5f4d5d51364712427c0bffc16e3bf1a5 Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Mon, 7 May 2012 15:47:35 +0800
Subject: [PATCH 06/11] lsi/clock: add clock api

Extracted from lsi.patch in lsi_acp_linux_3.8.1.28 tarball.

Add the support to get the ppc or peripheral clock for acp
boards.

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/lsi/acp/Makefile |    1 +
 drivers/lsi/acp/clocks.c |  254 ++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 255 insertions(+), 0 deletions(-)
 create mode 100644 drivers/lsi/acp/clocks.c

diff --git a/drivers/lsi/acp/Makefile b/drivers/lsi/acp/Makefile
index 7ecee93..3488353 100644
--- a/drivers/lsi/acp/Makefile
+++ b/drivers/lsi/acp/Makefile
@@ -1,2 +1,3 @@
 # Makefile for LSI drivers
 obj-$(CONFIG_ACP)			+= ncr.o
+obj-$(CONFIG_ACP)			+= clocks.o
diff --git a/drivers/lsi/acp/clocks.c b/drivers/lsi/acp/clocks.c
new file mode 100644
index 0000000..b6cc27c
--- /dev/null
+++ b/drivers/lsi/acp/clocks.c
@@ -0,0 +1,254 @@
+/*
+ *  Copyright (C) 2009 LSI Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <asm/dcr-native.h>
+
+#define CLK_REF0 125000000
+
+extern int is_asic(void);
+
+/*
+  ===============================================================================
+  ===============================================================================
+  Private Interface
+  ===============================================================================
+  ===============================================================================
+*/
+
+static unsigned char ps[] = {1, 3, 2, 4};
+
+static unsigned char idiv[] = {
+	1, 16, 17, 30, 13, 18, 7, 31, 14, 11, 19, 21, 27, 8, 23, 32,
+	15, 29, 12, 6, 10, 20, 26, 22, 28, 5, 9, 25, 4, 24, 3, 2};
+
+static unsigned char odiv[] = {
+	1, 2, 28, 27, 22, 21, 30, 29, 24, 23, 12, 11, 16, 15, 32, 31,
+	26, 25, 20, 19, 10, 9, 14, 13, 18, 17, 8, 7, 6, 5, 4, 3};
+
+static unsigned char mult[] = {
+	1, 123, 117, 251, 245, 69, 111, 125, 119, 95, 105, 197, 239,
+	163, 63, 253, 247, 187, 57, 223, 233, 207, 157, 71, 113, 15,
+	89, 37, 191, 19, 99, 127, 121, 109, 93, 61, 185, 155, 13, 97,
+	107, 11, 9, 81, 31, 49, 83, 199, 241, 33, 181, 143, 217, 173,
+	51, 165, 65, 85, 151, 147, 227, 41, 201, 255, 249, 243, 195,
+	237, 221, 231, 35, 189, 59, 183, 79, 29, 141, 215, 145, 225,
+	235, 219, 27, 139, 137, 135, 175, 209, 159, 53, 45, 177, 211,
+	23, 167, 73, 115, 67, 103, 161, 55, 205, 87, 17, 91, 153, 7,
+	47, 179, 171, 149, 39, 193, 229, 77, 213, 25, 133, 43, 21,
+	101, 203, 5, 169, 75, 131, 3, 129, 1, 250, 244, 124, 118, 196,
+	238, 252, 246, 222, 232, 70, 112, 36, 190, 126, 120, 60, 184,
+	96, 106, 80, 30, 198, 240, 142, 216, 164, 64, 146, 226, 254,
+	248, 236, 220, 188, 58, 28, 140, 224, 234, 138, 136, 208, 158,
+	176, 210, 72, 114, 160, 54, 16, 90, 46, 178, 38, 192, 212, 24,
+	20, 100, 168, 74, 128, 122, 116, 68, 110, 94, 104, 162, 62,
+	186, 56, 206, 156, 14, 88, 18, 98, 108, 92, 154, 12, 10, 8,
+	48, 82, 32, 180, 172, 50, 84, 150, 40, 200, 242, 194, 230, 34,
+	182, 78, 214, 144, 218, 26, 134, 174, 52, 44, 22, 166, 66,
+	102, 204, 86, 152, 6, 170, 148, 228, 76, 132, 42, 202, 4, 130,
+	2
+};
+
+#define PREDIV(value)       (idiv[(((value) & 0xfc000000) >> 26)])
+#define MULTINT(value)      (((value) & 0x00000ffe) >> 1)
+#define MULTINT_PRE(value)  (ps[((MULTINT((value)) & 0x300) >> 8)])
+#define MULTINT_MAIN(value) (mult[(MULTINT((value)) & 0xff)])
+#define RANGEA(value)       (((value) & 0x03f80000) >> 19)
+#define RANGEA_PRE(value)   (ps[((RANGEA((value)) & 0x60) >> 5)])
+#define RANGEA_MAIN(value)  (odiv[(RANGEA((value)) & 0x1f)])
+#define RANGEB(value)       (((value) & 0x0007f000) >> 12)
+#define RANGEB_PRE(value)   (ps[((RANGEB((value)) & 0x60) >> 5)])
+#define RANGEB_MAIN(value)  (odiv[(RANGEB((value)) & 0x1f)])
+
+/*
+  ------------------------------------------------------------------------------
+  get_ppc_pll
+
+  Assumes the the PPC PLL is locked...
+*/
+
+static int
+get_ppc_pll(unsigned long *dco, unsigned long *pllouta, unsigned long *plloutb)
+{
+	unsigned long ctrl;
+
+	ctrl = mfdcr(0xd02);
+
+	*dco = (CLK_REF0 / 1000 / PREDIV(ctrl));
+	*dco *= (MULTINT_PRE(ctrl) * MULTINT_MAIN(ctrl));
+	*pllouta = *dco / (RANGEA_PRE(ctrl) * RANGEA_MAIN(ctrl));
+	*plloutb = *dco / (RANGEB_PRE(ctrl) * RANGEB_MAIN(ctrl));
+
+#if 0
+	printf("0x%x %d 0x%x (%d %d) 0x%x (%d %d) 0x%x (%d %d)\n",
+	       ctrl, PREDIV(ctrl),
+	       MULTINT(ctrl), MULTINT_PRE(ctrl), MULTINT_MAIN(ctrl),
+	       RANGEA(ctrl), RANGEA_PRE(ctrl), RANGEA_MAIN(ctrl),
+	       RANGEB(ctrl), RANGEB_PRE(ctrl), RANGEB_MAIN(ctrl));
+#endif
+
+	return 0;
+}
+
+/*
+  -------------------------------------------------------------------------------
+  acp_clock_get_asic
+*/
+
+static int
+acp_clock_get_asic(int clock, unsigned long *frequency)
+{
+	unsigned long mcgc;
+	unsigned long mcgs;
+	unsigned long dco = 0;
+	unsigned long pllouta;
+	unsigned long plloutb;
+
+	*frequency = 0ULL;
+
+	mcgc = mfdcr(0xd00);
+	mcgs = mfdcr(0xd01);
+
+	switch (clock) {
+	case 0:			/* PPC */
+		if (0 == (mcgc & 0xc0000000)) {
+			/* ppc_clk is clk_ref0 */
+			*frequency = CLK_REF0 / 1000;
+		} else if (0 == get_ppc_pll(&dco, &pllouta, &plloutb)) {
+			if (1 == ((mcgc & 0xc0000000) >> 30)) {
+				*frequency = pllouta;
+			} else {
+				*frequency = pllouta / 2;
+			}
+		} else {
+			return -1;
+		}
+		break;
+	case 1:			/* Peripheral */
+		if (0 == (mcgc & 0x08000000)) {
+			/* clk_per is clk_ref0 */
+			*frequency = CLK_REF0 / 1000;
+ 		} else {
+			/* clk_per is clk_pllb_ppc */
+			if (0 == (mcgs & 0x80000000) ||
+			    (0 == dco &&
+			     0 != get_ppc_pll(&dco, &pllouta, &plloutb))) {
+				return -1;
+			}
+
+			*frequency = plloutb;
+		}
+		break;
+	default:
+		return -1;
+		break;
+	}
+
+	return 0;
+}
+
+/*
+  -------------------------------------------------------------------------------
+  acp_glock_get_emulation
+*/
+
+static int
+acp_clock_get_emulation(int clock, unsigned long *frequency)
+{
+	*frequency = 0ULL;
+
+	/*
+	  Clocks are only available on the ASIC.
+	*/
+	switch (clock) {
+	case 0:			/* PPC */
+		*frequency = 12500;
+		break;
+	case 1:			/* Peripheral */
+		*frequency = 6500;
+		break;
+	default:
+		return -1;
+		break;
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_ACPISS
+/*
+  -------------------------------------------------------------------------------
+  acp_glock_get_iss
+*/
+
+static int
+acp_clock_get_iss(int clock, unsigned long *frequency)
+{
+	*frequency = 0ULL;
+
+	/*
+	  Clocks are only available on the ASIC.
+	*/
+	switch (clock) {
+	case 0:			/* PPC */
+		*frequency = 12500;
+		break;
+	case 1:			/* Peripheral */
+		*frequency = 6500;
+		break;
+	default:
+		return -1;
+		break;
+	}
+
+	return 0;
+}
+#endif
+
+/*
+  ===============================================================================
+  ===============================================================================
+  Public Interface
+  ===============================================================================
+  ===============================================================================
+*/
+
+/*
+  -------------------------------------------------------------------------------
+  acp_clock_get
+*/
+
+int
+acp_clock_get(int clock, unsigned long *frequency)
+{
+#ifdef CONFIG_ACPISS
+	return acp_clock_get_iss(clock, frequency);
+#else
+	if (0 == is_asic()) {
+		return acp_clock_get_emulation(clock, frequency);
+	} else {
+		return acp_clock_get_asic(clock, frequency);
+	}
+
+	return -1;
+#endif
+}
-- 
1.7.0.4

