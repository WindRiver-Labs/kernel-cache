From 36423583eab40bfc8852f749173f309ea1e25973 Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Thu, 31 Jan 2013 16:21:19 +0800
Subject: [PATCH 13/16] LSI:ACP34xx:Move clock driver to arch/powerpc/sysdev

Reposition acp34xx's clock driver to arch/powerpc/sysdev:
drivers/lsi/acp/clocks.c -> arch/powerpc/sysdev/lsi_acpclock.c

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 arch/powerpc/include/asm/lsi/acp_clock.h |    7 +
 arch/powerpc/sysdev/Makefile             |    1 +
 arch/powerpc/sysdev/lsi_acpclock.c       |  233 ++++++++++++++++++++++++++++++
 drivers/lsi/acp/Makefile                 |    1 -
 drivers/lsi/acp/clocks.c                 |  233 ------------------------------
 drivers/lsi/acp/serial.c                 |    3 +-
 drivers/lsi/acp/wrappers.c               |    1 -
 7 files changed, 242 insertions(+), 237 deletions(-)
 create mode 100644 arch/powerpc/include/asm/lsi/acp_clock.h
 create mode 100644 arch/powerpc/sysdev/lsi_acpclock.c
 delete mode 100644 drivers/lsi/acp/clocks.c

diff --git a/arch/powerpc/include/asm/lsi/acp_clock.h b/arch/powerpc/include/asm/lsi/acp_clock.h
new file mode 100644
index 0000000..29bcc97
--- /dev/null
+++ b/arch/powerpc/include/asm/lsi/acp_clock.h
@@ -0,0 +1,7 @@
+#ifndef __DRIVERS_LSI_CLOCK_H
+#define __DRIVERS_LSI_CLOCK_H
+
+int
+acp_clock_get(int clock, unsigned long *frequency);
+
+#endif
diff --git a/arch/powerpc/sysdev/Makefile b/arch/powerpc/sysdev/Makefile
index bdfe5d3..5829e2f 100644
--- a/arch/powerpc/sysdev/Makefile
+++ b/arch/powerpc/sysdev/Makefile
@@ -71,3 +71,4 @@ obj-$(CONFIG_PPC_XICS)		+= xics/
 obj-$(CONFIG_GE_FPGA)		+= ge/
 
 obj-$(CONFIG_ACP)			+= lsi_acp_ncr.o
+obj-$(CONFIG_ACP)			+= lsi_acpclock.o
\ No newline at end of file
diff --git a/arch/powerpc/sysdev/lsi_acpclock.c b/arch/powerpc/sysdev/lsi_acpclock.c
new file mode 100644
index 0000000..0f9a1d6
--- /dev/null
+++ b/arch/powerpc/sysdev/lsi_acpclock.c
@@ -0,0 +1,233 @@
+/*
+ *  Copyright (C) 2009 LSI Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <asm/dcr-native.h>
+
+#define CLK_REF0 125000000
+
+#include <asm/lsi/acp_ncr.h>
+
+/*
+  Private Interface
+*/
+
+static unsigned char ps[] = { 1, 3, 2, 4 };
+
+static unsigned char idiv[] = {
+	1, 16, 17, 30, 13, 18, 7, 31, 14, 11, 19, 21, 27, 8, 23, 32,
+	15, 29, 12, 6, 10, 20, 26, 22, 28, 5, 9, 25, 4, 24, 3, 2
+};
+
+static unsigned char odiv[] = {
+	1, 2, 28, 27, 22, 21, 30, 29, 24, 23, 12, 11, 16, 15, 32, 31,
+	26, 25, 20, 19, 10, 9, 14, 13, 18, 17, 8, 7, 6, 5, 4, 3
+};
+
+static unsigned char mult[] = {
+	1, 123, 117, 251, 245, 69, 111, 125, 119, 95, 105, 197, 239,
+	163, 63, 253, 247, 187, 57, 223, 233, 207, 157, 71, 113, 15,
+	89, 37, 191, 19, 99, 127, 121, 109, 93, 61, 185, 155, 13, 97,
+	107, 11, 9, 81, 31, 49, 83, 199, 241, 33, 181, 143, 217, 173,
+	51, 165, 65, 85, 151, 147, 227, 41, 201, 255, 249, 243, 195,
+	237, 221, 231, 35, 189, 59, 183, 79, 29, 141, 215, 145, 225,
+	235, 219, 27, 139, 137, 135, 175, 209, 159, 53, 45, 177, 211,
+	23, 167, 73, 115, 67, 103, 161, 55, 205, 87, 17, 91, 153, 7,
+	47, 179, 171, 149, 39, 193, 229, 77, 213, 25, 133, 43, 21,
+	101, 203, 5, 169, 75, 131, 3, 129, 1, 250, 244, 124, 118, 196,
+	238, 252, 246, 222, 232, 70, 112, 36, 190, 126, 120, 60, 184,
+	96, 106, 80, 30, 198, 240, 142, 216, 164, 64, 146, 226, 254,
+	248, 236, 220, 188, 58, 28, 140, 224, 234, 138, 136, 208, 158,
+	176, 210, 72, 114, 160, 54, 16, 90, 46, 178, 38, 192, 212, 24,
+	20, 100, 168, 74, 128, 122, 116, 68, 110, 94, 104, 162, 62,
+	186, 56, 206, 156, 14, 88, 18, 98, 108, 92, 154, 12, 10, 8,
+	48, 82, 32, 180, 172, 50, 84, 150, 40, 200, 242, 194, 230, 34,
+	182, 78, 214, 144, 218, 26, 134, 174, 52, 44, 22, 166, 66,
+	102, 204, 86, 152, 6, 170, 148, 228, 76, 132, 42, 202, 4, 130,
+	2
+};
+
+#define PREDIV(value)       (idiv[(((value) & 0xfc000000) >> 26)])
+#define MULTINT(value)      (((value) & 0x00000ffe) >> 1)
+#define MULTINT_PRE(value)  (ps[((MULTINT((value)) & 0x300) >> 8)])
+#define MULTINT_MAIN(value) (mult[(MULTINT((value)) & 0xff)])
+#define RANGEA(value)       (((value) & 0x03f80000) >> 19)
+#define RANGEA_PRE(value)   (ps[((RANGEA((value)) & 0x60) >> 5)])
+#define RANGEA_MAIN(value)  (odiv[(RANGEA((value)) & 0x1f)])
+#define RANGEB(value)       (((value) & 0x0007f000) >> 12)
+#define RANGEB_PRE(value)   (ps[((RANGEB((value)) & 0x60) >> 5)])
+#define RANGEB_MAIN(value)  (odiv[(RANGEB((value)) & 0x1f)])
+
+/*
+  get_ppc_pll
+
+  Assumes the the PPC PLL is locked...
+*/
+
+static int
+get_ppc_pll(unsigned long *dco, unsigned long *pllouta, unsigned long *plloutb)
+{
+	unsigned long ctrl;
+
+	ctrl = mfdcr(0xd02);
+
+	*dco = (CLK_REF0 / 1000 / PREDIV(ctrl));
+	*dco *= (MULTINT_PRE(ctrl) * MULTINT_MAIN(ctrl));
+	*pllouta = *dco / (RANGEA_PRE(ctrl) * RANGEA_MAIN(ctrl));
+	*plloutb = *dco / (RANGEB_PRE(ctrl) * RANGEB_MAIN(ctrl));
+
+	return 0;
+}
+
+/*
+  acp_clock_get_asic
+*/
+
+static int
+acp_clock_get_asic(int clock, unsigned long *frequency)
+{
+	unsigned long mcgc;
+	unsigned long mcgs;
+	unsigned long dco = 0;
+	unsigned long pllouta;
+	unsigned long plloutb;
+
+	*frequency = 0ULL;
+
+	mcgc = mfdcr(0xd00);
+	mcgs = mfdcr(0xd01);
+
+	switch (clock) {
+	case 0:		/* PPC */
+		if (0 == (mcgc & 0xc0000000)) {
+			/* ppc_clk is clk_ref0 */
+			*frequency = CLK_REF0 / 1000;
+		} else if (0 == get_ppc_pll(&dco, &pllouta, &plloutb)) {
+			if (1 == ((mcgc & 0xc0000000) >> 30))
+				*frequency = pllouta;
+			else
+				*frequency = pllouta / 2;
+		} else {
+			return -1;
+		}
+		break;
+	case 1:		/* Peripheral */
+		if (0 == (mcgc & 0x08000000)) {
+			/* clk_per is clk_ref0 */
+			*frequency = CLK_REF0 / 1000;
+		} else {
+			/* clk_per is clk_pllb_ppc */
+			if (0 == (mcgs & 0x80000000) ||
+			    (0 == dco &&
+			     0 != get_ppc_pll(&dco, &pllouta, &plloutb))) {
+				return -1;
+			}
+
+			*frequency = plloutb;
+		}
+		break;
+	default:
+		return -1;
+		break;
+	}
+
+	return 0;
+}
+
+/*
+  acp_glock_get_emulation
+*/
+
+static int
+acp_clock_get_emulation(int clock, unsigned long *frequency)
+{
+	*frequency = 0ULL;
+
+	/*
+	   Clocks are only available on the ASIC.
+	 */
+	switch (clock) {
+	case 0:		/* PPC */
+		*frequency = 12500;
+		break;
+	case 1:		/* Peripheral */
+		*frequency = 6500;
+		break;
+	default:
+		return -1;
+		break;
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_ACPISS
+/*
+  acp_glock_get_iss
+*/
+
+static int
+acp_clock_get_iss(int clock, unsigned long *frequency)
+{
+	*frequency = 0ULL;
+
+	/*
+	   Clocks are only available on the ASIC.
+	 */
+	switch (clock) {
+	case 0:		/* PPC */
+		*frequency = 12500;
+		break;
+	case 1:		/* Peripheral */
+		*frequency = 6500;
+		break;
+	default:
+		return -1;
+		break;
+	}
+
+	return 0;
+}
+#endif
+
+/*
+  Public Interface
+*/
+
+/*
+  acp_clock_get
+*/
+
+int
+acp_clock_get(int clock, unsigned long *frequency)
+{
+#ifdef CONFIG_ACPISS
+	return acp_clock_get_iss(clock, frequency);
+#else
+	if (0 == is_asic())
+		return acp_clock_get_emulation(clock, frequency);
+	else
+		return acp_clock_get_asic(clock, frequency);
+
+	return -1;
+#endif
+}
diff --git a/drivers/lsi/acp/Makefile b/drivers/lsi/acp/Makefile
index 63aaf9d..c538840 100644
--- a/drivers/lsi/acp/Makefile
+++ b/drivers/lsi/acp/Makefile
@@ -1,5 +1,4 @@
 # Makefile for LSI drivers
-obj-$(CONFIG_ACP)			+= clocks.o
 obj-$(CONFIG_LSI_NAND)			+= lsi_nand.o
 obj-$(CONFIG_LSI_UBOOTENV)		+= ubootenv.o
 obj-$(CONFIG_SERIAL_ACP)		+= serial.o
diff --git a/drivers/lsi/acp/clocks.c b/drivers/lsi/acp/clocks.c
deleted file mode 100644
index 0f9a1d6..0000000
--- a/drivers/lsi/acp/clocks.c
+++ /dev/null
@@ -1,233 +0,0 @@
-/*
- *  Copyright (C) 2009 LSI Corporation
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <linux/module.h>
-#include <asm/dcr-native.h>
-
-#define CLK_REF0 125000000
-
-#include <asm/lsi/acp_ncr.h>
-
-/*
-  Private Interface
-*/
-
-static unsigned char ps[] = { 1, 3, 2, 4 };
-
-static unsigned char idiv[] = {
-	1, 16, 17, 30, 13, 18, 7, 31, 14, 11, 19, 21, 27, 8, 23, 32,
-	15, 29, 12, 6, 10, 20, 26, 22, 28, 5, 9, 25, 4, 24, 3, 2
-};
-
-static unsigned char odiv[] = {
-	1, 2, 28, 27, 22, 21, 30, 29, 24, 23, 12, 11, 16, 15, 32, 31,
-	26, 25, 20, 19, 10, 9, 14, 13, 18, 17, 8, 7, 6, 5, 4, 3
-};
-
-static unsigned char mult[] = {
-	1, 123, 117, 251, 245, 69, 111, 125, 119, 95, 105, 197, 239,
-	163, 63, 253, 247, 187, 57, 223, 233, 207, 157, 71, 113, 15,
-	89, 37, 191, 19, 99, 127, 121, 109, 93, 61, 185, 155, 13, 97,
-	107, 11, 9, 81, 31, 49, 83, 199, 241, 33, 181, 143, 217, 173,
-	51, 165, 65, 85, 151, 147, 227, 41, 201, 255, 249, 243, 195,
-	237, 221, 231, 35, 189, 59, 183, 79, 29, 141, 215, 145, 225,
-	235, 219, 27, 139, 137, 135, 175, 209, 159, 53, 45, 177, 211,
-	23, 167, 73, 115, 67, 103, 161, 55, 205, 87, 17, 91, 153, 7,
-	47, 179, 171, 149, 39, 193, 229, 77, 213, 25, 133, 43, 21,
-	101, 203, 5, 169, 75, 131, 3, 129, 1, 250, 244, 124, 118, 196,
-	238, 252, 246, 222, 232, 70, 112, 36, 190, 126, 120, 60, 184,
-	96, 106, 80, 30, 198, 240, 142, 216, 164, 64, 146, 226, 254,
-	248, 236, 220, 188, 58, 28, 140, 224, 234, 138, 136, 208, 158,
-	176, 210, 72, 114, 160, 54, 16, 90, 46, 178, 38, 192, 212, 24,
-	20, 100, 168, 74, 128, 122, 116, 68, 110, 94, 104, 162, 62,
-	186, 56, 206, 156, 14, 88, 18, 98, 108, 92, 154, 12, 10, 8,
-	48, 82, 32, 180, 172, 50, 84, 150, 40, 200, 242, 194, 230, 34,
-	182, 78, 214, 144, 218, 26, 134, 174, 52, 44, 22, 166, 66,
-	102, 204, 86, 152, 6, 170, 148, 228, 76, 132, 42, 202, 4, 130,
-	2
-};
-
-#define PREDIV(value)       (idiv[(((value) & 0xfc000000) >> 26)])
-#define MULTINT(value)      (((value) & 0x00000ffe) >> 1)
-#define MULTINT_PRE(value)  (ps[((MULTINT((value)) & 0x300) >> 8)])
-#define MULTINT_MAIN(value) (mult[(MULTINT((value)) & 0xff)])
-#define RANGEA(value)       (((value) & 0x03f80000) >> 19)
-#define RANGEA_PRE(value)   (ps[((RANGEA((value)) & 0x60) >> 5)])
-#define RANGEA_MAIN(value)  (odiv[(RANGEA((value)) & 0x1f)])
-#define RANGEB(value)       (((value) & 0x0007f000) >> 12)
-#define RANGEB_PRE(value)   (ps[((RANGEB((value)) & 0x60) >> 5)])
-#define RANGEB_MAIN(value)  (odiv[(RANGEB((value)) & 0x1f)])
-
-/*
-  get_ppc_pll
-
-  Assumes the the PPC PLL is locked...
-*/
-
-static int
-get_ppc_pll(unsigned long *dco, unsigned long *pllouta, unsigned long *plloutb)
-{
-	unsigned long ctrl;
-
-	ctrl = mfdcr(0xd02);
-
-	*dco = (CLK_REF0 / 1000 / PREDIV(ctrl));
-	*dco *= (MULTINT_PRE(ctrl) * MULTINT_MAIN(ctrl));
-	*pllouta = *dco / (RANGEA_PRE(ctrl) * RANGEA_MAIN(ctrl));
-	*plloutb = *dco / (RANGEB_PRE(ctrl) * RANGEB_MAIN(ctrl));
-
-	return 0;
-}
-
-/*
-  acp_clock_get_asic
-*/
-
-static int
-acp_clock_get_asic(int clock, unsigned long *frequency)
-{
-	unsigned long mcgc;
-	unsigned long mcgs;
-	unsigned long dco = 0;
-	unsigned long pllouta;
-	unsigned long plloutb;
-
-	*frequency = 0ULL;
-
-	mcgc = mfdcr(0xd00);
-	mcgs = mfdcr(0xd01);
-
-	switch (clock) {
-	case 0:		/* PPC */
-		if (0 == (mcgc & 0xc0000000)) {
-			/* ppc_clk is clk_ref0 */
-			*frequency = CLK_REF0 / 1000;
-		} else if (0 == get_ppc_pll(&dco, &pllouta, &plloutb)) {
-			if (1 == ((mcgc & 0xc0000000) >> 30))
-				*frequency = pllouta;
-			else
-				*frequency = pllouta / 2;
-		} else {
-			return -1;
-		}
-		break;
-	case 1:		/* Peripheral */
-		if (0 == (mcgc & 0x08000000)) {
-			/* clk_per is clk_ref0 */
-			*frequency = CLK_REF0 / 1000;
-		} else {
-			/* clk_per is clk_pllb_ppc */
-			if (0 == (mcgs & 0x80000000) ||
-			    (0 == dco &&
-			     0 != get_ppc_pll(&dco, &pllouta, &plloutb))) {
-				return -1;
-			}
-
-			*frequency = plloutb;
-		}
-		break;
-	default:
-		return -1;
-		break;
-	}
-
-	return 0;
-}
-
-/*
-  acp_glock_get_emulation
-*/
-
-static int
-acp_clock_get_emulation(int clock, unsigned long *frequency)
-{
-	*frequency = 0ULL;
-
-	/*
-	   Clocks are only available on the ASIC.
-	 */
-	switch (clock) {
-	case 0:		/* PPC */
-		*frequency = 12500;
-		break;
-	case 1:		/* Peripheral */
-		*frequency = 6500;
-		break;
-	default:
-		return -1;
-		break;
-	}
-
-	return 0;
-}
-
-#ifdef CONFIG_ACPISS
-/*
-  acp_glock_get_iss
-*/
-
-static int
-acp_clock_get_iss(int clock, unsigned long *frequency)
-{
-	*frequency = 0ULL;
-
-	/*
-	   Clocks are only available on the ASIC.
-	 */
-	switch (clock) {
-	case 0:		/* PPC */
-		*frequency = 12500;
-		break;
-	case 1:		/* Peripheral */
-		*frequency = 6500;
-		break;
-	default:
-		return -1;
-		break;
-	}
-
-	return 0;
-}
-#endif
-
-/*
-  Public Interface
-*/
-
-/*
-  acp_clock_get
-*/
-
-int
-acp_clock_get(int clock, unsigned long *frequency)
-{
-#ifdef CONFIG_ACPISS
-	return acp_clock_get_iss(clock, frequency);
-#else
-	if (0 == is_asic())
-		return acp_clock_get_emulation(clock, frequency);
-	else
-		return acp_clock_get_asic(clock, frequency);
-
-	return -1;
-#endif
-}
diff --git a/drivers/lsi/acp/serial.c b/drivers/lsi/acp/serial.c
index 6c18efb..af2765c 100644
--- a/drivers/lsi/acp/serial.c
+++ b/drivers/lsi/acp/serial.c
@@ -53,8 +53,7 @@
 #include <linux/io.h>
 
 #include <asm/lsi/acp_ncr.h>
-
-extern int acp_clock_get(int, unsigned long *);
+#include <asm/lsi/acp_clock.h>
 
 #define SZ_4K (4*1024)
 #define UART_NR			2
diff --git a/drivers/lsi/acp/wrappers.c b/drivers/lsi/acp/wrappers.c
index e144f8e..328c1fe 100644
--- a/drivers/lsi/acp/wrappers.c
+++ b/drivers/lsi/acp/wrappers.c
@@ -24,7 +24,6 @@
 #include <linux/io.h>
 
 #include <asm/lsi/acp_ncr.h>
-extern int acp_clock_get(int, unsigned long *);
 
 /*
   ==============================================================================
-- 
1.7.9.7

