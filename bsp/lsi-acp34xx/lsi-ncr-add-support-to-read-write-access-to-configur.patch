From 76af1b9df84707d1483593a45147217c1db1a88b Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Mon, 7 May 2012 15:51:24 +0800
Subject: [PATCH 05/11] lsi/ncr: add support to read/write access to configuration ring resources

Extracted from lsi.patch in lsi_acp_linux_3.8.1.28 tarball.

The Nuevo CPU Adapter (NCA) is the hardware engine that connects the
powerpc complex with the ACP3400 data patch accellerator engines.
This driver provides the CPU with read/write access to configuration
ring resources via NCA configuration commands.

[Kevin: Get the nca register virtual address by using ioremap instead
of using a fixed virtual address bolted in tlb entry.]

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/Makefile         |    1 +
 drivers/lsi/Makefile     |    1 +
 drivers/lsi/acp/Makefile |    2 +
 drivers/lsi/acp/ncr.c    |  290 ++++++++++++++++++++++++++++++++++++++++++++++
 drivers/lsi/acp/ncr.h    |   40 +++++++
 5 files changed, 334 insertions(+), 0 deletions(-)
 create mode 100644 drivers/lsi/Makefile
 create mode 100644 drivers/lsi/acp/Makefile
 create mode 100644 drivers/lsi/acp/ncr.c
 create mode 100644 drivers/lsi/acp/ncr.h

diff --git a/drivers/Makefile b/drivers/Makefile
index 95952c8..c980e8e 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -134,3 +134,4 @@ obj-$(CONFIG_VIRT_DRIVERS)	+= virt/
 obj-$(CONFIG_HYPERV)		+= hv/
 
 obj-$(CONFIG_PM_DEVFREQ)	+= devfreq/
+obj-$(CONFIG_ACP)		+= lsi/
diff --git a/drivers/lsi/Makefile b/drivers/lsi/Makefile
new file mode 100644
index 0000000..36b59f4
--- /dev/null
+++ b/drivers/lsi/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_ACP)	+= acp/
diff --git a/drivers/lsi/acp/Makefile b/drivers/lsi/acp/Makefile
new file mode 100644
index 0000000..7ecee93
--- /dev/null
+++ b/drivers/lsi/acp/Makefile
@@ -0,0 +1,2 @@
+# Makefile for LSI drivers
+obj-$(CONFIG_ACP)			+= ncr.o
diff --git a/drivers/lsi/acp/ncr.c b/drivers/lsi/acp/ncr.c
new file mode 100644
index 0000000..ae48106
--- /dev/null
+++ b/drivers/lsi/acp/ncr.c
@@ -0,0 +1,290 @@
+/*
+ *  Copyright (C) 2009 LSI Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <asm/io.h>
+#include <linux/module.h>
+
+#include "ncr.h"
+
+static void *nca_reg;
+
+#define NCA  nca_reg
+
+typedef union {
+	unsigned long raw;
+	struct {
+		unsigned long start_done:1;
+		unsigned long unused:6;
+		unsigned long local_bit:1;
+		unsigned long status:2;
+		unsigned long byte_swap_enable:1;
+		unsigned long cfg_cmpl_int_enable:1;
+		unsigned long cmd_type:4;
+		unsigned long dbs:16;
+	} __attribute__ ((packed)) bits;
+} __attribute__ ((packed)) command_data_register_0_t;
+
+typedef union {
+	unsigned long raw;
+	struct {
+		unsigned long target_address:32;
+	} __attribute__ ((packed)) bits;
+} __attribute__ ((packed)) command_data_register_1_t;
+
+typedef union {
+	unsigned long raw;
+	struct {
+		unsigned long unused:16;
+		unsigned long target_node_id:8;
+		unsigned long target_id_address_upper:8;
+	} __attribute__ ((packed)) bits;
+} __attribute__ ((packed)) command_data_register_2_t;
+
+/*
+  ----------------------------------------------------------------------
+  ncr_register_read
+*/
+
+static __inline__ unsigned long
+ncr_register_read(unsigned *address)
+{
+	unsigned long value;
+
+	value = in_be32(address);
+
+	return value;
+}
+
+/*
+  ----------------------------------------------------------------------
+  ncr_register_write
+*/
+
+static __inline__ void
+ncr_register_write(const unsigned value, unsigned *address)
+{
+	out_be32(address, value);
+}
+
+/*
+  ======================================================================
+  ======================================================================
+  Public Interface
+  ======================================================================
+  ======================================================================
+*/
+
+/*
+  ----------------------------------------------------------------------
+  ncr_read
+*/
+
+int
+ncr_read(unsigned long region, unsigned long address, int number,
+	 void *buffer)
+{
+	command_data_register_0_t cdr0;
+	command_data_register_1_t cdr1;
+	command_data_register_2_t cdr2;
+
+	/*
+	  Set up the read command.
+	*/
+
+	cdr2.raw = 0;
+	cdr2.bits.target_node_id = NCP_NODE_ID(region);
+	cdr2.bits.target_id_address_upper = NCP_TARGET_ID(region);
+	ncr_register_write(cdr2.raw, (unsigned *) (NCA + 0xf8));
+
+	cdr1.raw = 0;
+	cdr1.bits.target_address = (address >> 2);
+	ncr_register_write(cdr1.raw, (unsigned *) (NCA + 0xf4));
+
+	cdr0.raw = 0;
+	cdr0.bits.start_done = 1;
+
+	if (0xff == cdr2.bits.target_id_address_upper)
+		cdr0.bits.local_bit = 1;
+
+	cdr0.bits.cmd_type = 4;
+	/* TODO: Verify number... */
+	cdr0.bits.dbs = (number - 1);
+	ncr_register_write(cdr0.raw, (unsigned *) (NCA + 0xf0));
+	mb();
+
+	/*
+	  Wait for completion.
+	*/
+
+	/* TODO: Handle failure cases. */
+#if 0
+	while (0x80000000 ==
+	       (ncr_register_read((unsigned *) (NCA + 0xf0)) & 0x80000000))
+		;
+#else
+	{
+		volatile unsigned long value;
+
+		do {
+			value = ncr_register_read((unsigned *) (NCA + 0xf0));
+		} while (0x80000000 == (value & 0x80000000));
+	}
+#endif
+
+	/*
+	  Copy data words to the buffer.
+	*/
+
+	address = (unsigned long)(NCA + 0x1000);
+	while (4 <= number) {
+		*((unsigned long *) buffer) =
+			ncr_register_read((unsigned *) address);
+		address += 4;
+		number -= 4;
+	}
+
+	if (0 < number) {
+		unsigned long temp =
+			ncr_register_read((unsigned *) address);
+		memcpy((void *) buffer, &temp, number);
+	}
+
+	return 0;
+}
+
+/*
+  ----------------------------------------------------------------------
+  ncr_write
+*/
+
+int
+ncr_write(unsigned long region, unsigned long address, int number,
+	  void *buffer)
+{
+	command_data_register_0_t cdr0;
+	command_data_register_1_t cdr1;
+	command_data_register_2_t cdr2;
+	unsigned long data_word_base;
+	int dbs = (number - 1);
+
+	/*
+	  Set up the write.
+	*/
+
+	cdr2.raw = 0;
+	cdr2.bits.target_node_id = NCP_NODE_ID(region);
+	cdr2.bits.target_id_address_upper = NCP_TARGET_ID(region);
+	ncr_register_write(cdr2.raw, (unsigned *) (NCA + 0xf8));
+
+	cdr1.raw = 0;
+	cdr1.bits.target_address = (address >> 2);
+	ncr_register_write(cdr1.raw, (unsigned *) (NCA + 0xf4));
+
+	/*
+	  Copy from buffer to the data words.
+	*/
+
+	data_word_base = (unsigned long)(NCA + 0x1000);
+
+	while (4 <= number) {
+		ncr_register_write(*((unsigned long *) buffer),
+				   (unsigned *) data_word_base);
+		data_word_base += 4;
+		buffer += 4;
+		number -= 4;
+	}
+
+	if (0 < number) {
+		unsigned long temp = 0;
+
+		memcpy((void *) &temp, (void *) buffer, number);
+		ncr_register_write(temp, (unsigned *) data_word_base);
+		data_word_base += number;
+		buffer += number;
+		number = 0;
+	}
+
+	cdr0.raw = 0;
+	cdr0.bits.start_done = 1;
+
+	if (0xff == cdr2.bits.target_id_address_upper) {
+		cdr0.bits.local_bit = 1;
+	}
+
+	cdr0.bits.cmd_type = 5;
+	/* TODO: Verify number... */
+	cdr0.bits.dbs = dbs;
+	ncr_register_write(cdr0.raw, (unsigned *) (NCA + 0xf0));
+	mb();
+
+	/*
+	  Wait for completion.
+	*/
+
+	/* TODO: Handle failure cases. */
+	while (0x80000000 ==
+	       (ncr_register_read((unsigned *) (NCA + 0xf0)) & 0x80000000))
+		;
+
+	return 0;
+}
+
+/*
+  ----------------------------------------------------------------------
+  ncr_init
+*/
+
+int
+ncr_init( void )
+{
+    /* We need this to be a module so that the functions can be exported
+     * as module symbols.
+     */
+	nca_reg = ioremap(0x2000520000ull, 0x2000);
+	if (!nca_reg) {
+		pr_err("Can't iomap for nca registers\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+module_init( ncr_init );
+
+/*
+  ----------------------------------------------------------------------
+  ncr_exit
+*/
+
+void __exit
+ncr_exit( void )
+{
+	iounmap(nca_reg);
+}
+
+module_exit( ncr_exit );
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Register Ring access for LSI's ACP board");
+
+EXPORT_SYMBOL(ncr_read);
+EXPORT_SYMBOL(ncr_write);
diff --git a/drivers/lsi/acp/ncr.h b/drivers/lsi/acp/ncr.h
new file mode 100644
index 0000000..f102df5
--- /dev/null
+++ b/drivers/lsi/acp/ncr.h
@@ -0,0 +1,40 @@
+/*
+ * drivers/lsi/common/version.h
+ *
+ * Copyright (C) 2010 LSI
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307	 USA
+ */
+
+#ifndef __DRIVERS_LSI_ACP_NCR_H
+#define __DRIVERS_LSI_ACP_NCR_H
+
+#ifndef NCP_REGION_ID
+#define NCP_REGION_ID(node, target) \
+(unsigned long) ((((node) & 0xffff) << 16) | ((target) & 0xffff))
+#endif
+
+#ifndef NCP_NODE_ID
+#define NCP_NODE_ID(region) (((region) >> 16) & 0xffff)
+#endif
+
+#ifndef NCP_TARGET_ID
+#define NCP_TARGET_ID(region) ((region) & 0xffff)
+#endif
+
+int ncr_read(unsigned long, unsigned long, int, void *);
+int ncr_write(unsigned long, unsigned long, int, void *);
+
+#endif /*  __DRIVERS_LSI_ACP_NCR_H */
-- 
1.7.0.4

