From fba77bca53adf0f5322d73b204be3eeb3f1079db Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Thu, 31 Jan 2013 15:09:20 +0800
Subject: [PATCH 03/16] LSI:ACP34xx:Cleanup serial driver

Cleanup acp34xx's serial driver with following modification:

1.Remove unnecessary debug macros.
2.Fix code indent issues.
3.Remove dead code.

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/lsi/acp/serial.c |  148 +++++++++-------------------------------------
 1 file changed, 28 insertions(+), 120 deletions(-)

diff --git a/drivers/lsi/acp/serial.c b/drivers/lsi/acp/serial.c
index bd67d30..1864ef0 100644
--- a/drivers/lsi/acp/serial.c
+++ b/drivers/lsi/acp/serial.c
@@ -50,7 +50,7 @@
 #include <linux/amba/serial.h>
 #include <linux/irq.h>
 #include <linux/of.h>
-#include <asm/io.h>
+#include <linux/io.h>
 
 #include "ncr.h"
 
@@ -66,14 +66,6 @@ extern int acp_clock_get(int, unsigned long *);
 (UART011_DR_OE|UART011_DR_BE|UART011_DR_PE|UART011_DR_FE)
 #define UART_DUMMY_DR_RX	(1 << 16)
 
-#undef DEBUG_EXPORT_SYMBOLS
-#define DEBUG_EXPORT_SYMBOLS
-#ifdef DEBUG_EXPORT_SYMBOLS
-#define STATIC
-#else
-#define STATIC static
-#endif
-
 #define MAX_BAUD_RATE 115200
 
 static int dt_baud_rate;
@@ -127,7 +119,7 @@ struct uart_acp_port {
   get_clock_stuff
 */
 
-STATIC int
+static int
 get_clock_stuff(struct uart_acp_port *port, int baud_rate)
 {
 	unsigned long per_clock;
@@ -190,17 +182,6 @@ get_clock_stuff(struct uart_acp_port *port, int baud_rate)
 	port->ibrd = (unsigned char) ibrd;
 	port->fbrd = (unsigned char) fbrd;
 
-#if 0
-	printk("\n\n == == DEBUG == ==\n"
-	       "port->ibrd=%lu ibrd=%lu\n"
-	       "port->fbrd=%lu fbrd=%lu\n"
-	       "port->divisor=%lu divisor=%lu load=%lu\n"
-	       "== == == == == ==\n",
-	       port->ibrd, ibrd,
-	       port->fbrd, fbrd,
-	       port->divisor, divisor, in_le32(port->timer_base + TIMER_LOAD));
-#endif
-
 	if (port->divisor != in_le32(port->timer_base + TIMER_LOAD)) {
 		while (0 ==
 		       (in_le32((const volatile unsigned *)
@@ -239,7 +220,7 @@ get_clock_stuff(struct uart_acp_port *port, int baud_rate)
   This was added to allow an easy debugging breakpoint.
 */
 
-STATIC void
+static void
 acp_serial_wac(u32 *address, int character, u32 line)
 {
 	out_le32(address, character);
@@ -252,12 +233,12 @@ acp_serial_wac(u32 *address, int character, u32 line)
   acp_serial_tx_empty
 */
 
-STATIC unsigned int
+static unsigned int
 acp_serial_tx_empty(struct uart_port *port)
 {
-	struct uart_acp_port * uap = (struct uart_acp_port *) port;
+	struct uart_acp_port *uap = (struct uart_acp_port *) port;
 	unsigned int status =
-		in_le32((u32 *) (uap->port.membase + UART01x_FR));
+		in_le32((u32 *)(uap->port.membase + UART01x_FR));
 	return status &
 		(UART01x_FR_BUSY | UART01x_FR_TXFF) ? 0 : TIOCSER_TEMT;
 }
@@ -267,7 +248,7 @@ acp_serial_tx_empty(struct uart_port *port)
   acp_serial_stop_tx
 */
 
-STATIC void
+static void
 acp_serial_stop_tx(struct uart_port *port)
 {
 	struct uart_acp_port *uap = (struct uart_acp_port *)port;
@@ -282,7 +263,7 @@ acp_serial_stop_tx(struct uart_port *port)
   acp_serial_start_tx
 */
 
-STATIC void
+static void
 acp_serial_start_tx(struct uart_port *port)
 {
 	struct uart_acp_port *uap = (struct uart_acp_port *)port;
@@ -317,13 +298,12 @@ void acp_serial_enable_ms(struct uart_port *port)
   acp_serial_rx_chars
 */
 
-STATIC void
+static void
 acp_serial_rx_chars(struct uart_acp_port *uap)
 {
 	struct tty_struct *tty = uap->port.state->port.tty;
 	unsigned int status, ch, flag, max_count = 256;
 
-	/*status = readw(uap->port.membase + UART01x_FR);*/
 	status = in_le32((u32 *)(uap->port.membase + UART01x_FR));
 	while ((status & UART01x_FR_RXFE) == 0 && max_count--) {
 		ch = in_le32((u32 *)(uap->port.membase + UART01x_DR)) |
@@ -363,7 +343,7 @@ acp_serial_rx_chars(struct uart_acp_port *uap)
 
 		uart_insert_char(&uap->port, ch, UART011_DR_OE, ch, flag);
 
-	ignore_char:
+ignore_char:
 		status = in_le32((u32 *)(uap->port.membase + UART01x_FR));
 	}
 	spin_unlock(&uap->port.lock);
@@ -376,18 +356,13 @@ acp_serial_rx_chars(struct uart_acp_port *uap)
   acp_serial_tx_chars
 */
 
-STATIC void
+static void
 acp_serial_tx_chars(struct uart_acp_port *uap)
 {
 	struct circ_buf *xmit = &uap->port.state->xmit;
 	int count;
 
 	if (uap->port.x_char) {
-		/*writew(uap->port.x_char, uap->port.membase + UART01x_DR);*/
-#if 0
-		out_le32((u32 *)(uap->port.membase + UART01x_DR),
-			 uap->port.x_char);
-#endif
 		acp_serial_wac((u32 *)(uap->port.membase + UART01x_DR),
 				uap->port.x_char, __LINE__);
 		uap->port.icount.tx++;
@@ -401,10 +376,6 @@ acp_serial_tx_chars(struct uart_acp_port *uap)
 
 	count = uap->port.fifosize >> 1;
 	do {
-#if 0
-		out_le32((u32 *)(uap->port.membase + UART01x_DR),
-			 xmit->buf[xmit->tail]);
-#endif
 		acp_serial_wac((u32 *) (uap->port.membase + UART01x_DR),
 				xmit->buf[xmit->tail], __LINE__);
 		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
@@ -450,7 +421,7 @@ void acp_serial_modem_status(struct uart_acp_port *uap)
   acp_serial_isr
 */
 
-STATIC irqreturn_t
+static irqreturn_t
 acp_serial_isr(int irq, void *dev_id)
 {
 	struct uart_acp_port *uap = dev_id;
@@ -459,19 +430,12 @@ acp_serial_isr(int irq, void *dev_id)
 
 	spin_lock(&uap->port.lock);
 
-	/*status = readw(uap->port.membase + UART011_MIS);*/
 	status = in_le32((u32 *)(uap->port.membase + UART011_MIS));
 	if (status) {
 		do {
-#if 0
-			writew(status & ~(UART011_TXIS|UART011_RTIS|
-					  UART011_RXIS),
-			       uap->port.membase + UART011_ICR);
-#else
 			out_le32((u32 *)(uap->port.membase + UART011_ICR),
 				 (status &
 				  ~(UART011_TXIS|UART011_RTIS|UART011_RXIS)));
-#endif
 
 			if (status & (UART011_RTIS|UART011_RXIS))
 				acp_serial_rx_chars(uap);
@@ -484,9 +448,9 @@ acp_serial_isr(int irq, void *dev_id)
 			if (pass_counter-- == 0)
 				break;
 
-			/*status = readw(uap->port.membase + UART011_MIS);*/
 			status =
-				in_le32((u32 *)(uap->port.membase + UART011_MIS));
+				in_le32((u32 *)(uap->port.membase +
+					UART011_MIS));
 		} while (status != 0);
 		handled = 1;
 	}
@@ -500,7 +464,6 @@ unsigned int acp_serial_get_mctrl(struct uart_port *port)
 {
 	struct uart_acp_port *uap = (struct uart_acp_port *)port;
 	unsigned int result = 0;
-	/*unsigned int status = readw(uap->port.membase + UART01x_FR);*/
 	unsigned int status = in_le32((u32 *)(uap->port.membase + UART01x_FR));
 
 #define TIOCMBIT(uartbit, tiocmbit) do { \
@@ -520,7 +483,6 @@ void acp_serial_set_mctrl(struct uart_port *port, unsigned int mctrl)
 	struct uart_acp_port *uap = (struct uart_acp_port *)port;
 	unsigned int cr;
 
-	/*cr = readw(uap->port.membase + UART011_CR);*/
 	cr = in_le32((u32 *)(uap->port.membase + UART011_CR));
 
 #define TIOCMBIT(tiocmbit, uartbit) do { \
@@ -538,7 +500,6 @@ void acp_serial_set_mctrl(struct uart_port *port, unsigned int mctrl)
 
 #undef TIOCMBIT
 
-	/*writew(cr, uap->port.membase + UART011_CR);*/
 	out_le32((u32 *)(uap->port.membase + UART011_CR), cr);
 }
 
@@ -549,13 +510,11 @@ void acp_serial_break_ctl(struct uart_port *port, int break_state)
 	unsigned int lcr_h;
 
 	spin_lock_irqsave(&uap->port.lock, flags);
-	/*lcr_h = readw(uap->port.membase + UART011_LCRH);*/
 	lcr_h = in_le32((u32 *)(uap->port.membase + UART011_LCRH));
 	if (break_state == -1)
 		lcr_h |= UART01x_LCRH_BRK;
 	else
 		lcr_h &= ~UART01x_LCRH_BRK;
-	/*writew(lcr_h, uap->port.membase + UART011_LCRH);*/
 	out_le32((u32 *)(uap->port.membase + UART011_LCRH), lcr_h);
 	spin_unlock_irqrestore(&uap->port.lock, flags);
 }
@@ -567,10 +526,10 @@ void acp_serial_break_ctl(struct uart_port *port, int break_state)
   acp_serial_poll_get_char
 */
 
-STATIC int
+static int
 acp_serial_poll_get_char(struct uart_port *port)
 {
-	struct uart_acp_port * uap = (struct uart_acp_port *) port;
+	struct uart_acp_port *uap = (struct uart_acp_port *) port;
 	unsigned int status;
 
 	do {
@@ -586,7 +545,7 @@ acp_serial_poll_get_char(struct uart_port *port)
   acp_serial_poll_put_char
 */
 
-STATIC void
+static void
 acp_serial_poll_put_char(struct uart_port *port, unsigned char ch)
 {
 	struct uart_acp_port *uap = (struct uart_acp_port *)port;
@@ -601,7 +560,6 @@ acp_serial_poll_put_char(struct uart_port *port, unsigned char ch)
 
 	return;
 }
-
 #endif /* CONFIG_CONSOLE_POLL */
 
 /*
@@ -609,7 +567,7 @@ acp_serial_poll_put_char(struct uart_port *port, unsigned char ch)
   acp_serial_startup
 */
 
-STATIC int
+static int
 acp_serial_startup(struct uart_port *port)
 {
 	struct uart_acp_port *uap = (struct uart_acp_port *)port;
@@ -620,7 +578,7 @@ acp_serial_startup(struct uart_port *port)
 	 * Set up the interrupt.
 	 */
 
-        uap->port.irq = irq_create_mapping( NULL, uap->hwirq );
+	uap->port.irq = irq_create_mapping(NULL, uap->hwirq);
 
 	if (NO_IRQ == uap->port.irq) {
 		printk(KERN_ERR "irq_create_mapping() failed!\n");
@@ -662,27 +620,21 @@ acp_serial_startup(struct uart_port *port)
 		barrier();
 
 	cr = UART01x_CR_UARTEN | UART011_CR_RXE | UART011_CR_TXE;
-	/*writew(cr, uap->port.membase + UART011_CR);*/
 	out_le32((u32 *)(uap->port.membase + UART011_CR), cr);
 
 	/*
 	 * initialise the old status of the modem signals
 	 */
-#if 0
-	uap->old_status =
-		readw(uap->port.membase + UART01x_FR) & UART01x_FR_MODEM_ANY;
-#else
+
 	uap->old_status =
 		in_le32((u32 *)(uap->port.membase + UART01x_FR)) &
 		UART01x_FR_MODEM_ANY;
-#endif
 
 	/*
 	 * Finally, enable interrupts
 	 */
 	spin_lock_irq(&uap->port.lock);
 	uap->interrupt_mask = UART011_RXIM | UART011_RTIM;
-	/*writew(uap->interrupt_mask, uap->port.membase + UART011_IMSC);*/
 	out_le32((u32 *)(uap->port.membase + UART011_IMSC),
 		 uap->interrupt_mask);
 	spin_unlock_irq(&uap->port.lock);
@@ -700,7 +652,7 @@ acp_serial_startup(struct uart_port *port)
   acp_serial_shutdown
 */
 
-STATIC void
+static void
 acp_serial_shutdown(struct uart_port *port)
 {
 	struct uart_acp_port *uap = (struct uart_acp_port *)port;
@@ -740,7 +692,7 @@ acp_serial_shutdown(struct uart_port *port)
   acp_serial_set_termios
 */
 
-STATIC void
+static void
 acp_serial_set_termios(struct uart_port *port, struct ktermios *termios,
 			struct ktermios *old)
 {
@@ -917,7 +869,7 @@ static struct uart_acp_port *acp_ports[2];
   acp_serial_console_putchar
 */
 
-STATIC void
+static void
 acp_serial_console_putchar(struct uart_port *port, int ch)
 {
 	struct uart_acp_port *uap = (struct uart_acp_port *)port;
@@ -927,7 +879,6 @@ acp_serial_console_putchar(struct uart_port *port, int ch)
 		barrier();
 	}
 
-	/*out_le32((u32 *)(uap->port.membase + UART01x_DR), ch);*/
 	acp_serial_wac((u32 *) (uap->port.membase + UART01x_DR), ch,
 			__LINE__);
 }
@@ -943,11 +894,9 @@ acp_console_write(struct console *co, const char *s, unsigned int count)
 	/*
 	 *	First save the CR then disable the interrupts
 	 */
-	/*old_cr = readw(uap->port.membase + UART011_CR);*/
 	old_cr = in_le32((u32 *)(uap->port.membase + UART011_CR));
 	new_cr = old_cr & ~UART011_CR_CTSEN;
 	new_cr |= UART01x_CR_UARTEN | UART011_CR_TXE;
-	/*writew(new_cr, uap->port.membase + UART011_CR);*/
 	out_le32((u32 *)(uap->port.membase + UART011_CR), new_cr);
 
 	uart_console_write(&uap->port, s, count, acp_serial_console_putchar);
@@ -957,11 +906,9 @@ acp_console_write(struct console *co, const char *s, unsigned int count)
 	 *	and restore the TCR
 	 */
 	do {
-		/*status = readw(uap->port.membase + UART01x_FR);*/
 		status =
 			in_le32((u32 *)(u32 *)(uap->port.membase + UART01x_FR));
 	} while (status & UART01x_FR_BUSY);
-	/*writew(old_cr, uap->port.membase + UART011_CR);*/
 	out_le32((u32 *)(uap->port.membase + UART011_CR), old_cr);
 
 	/*clk_disable(uap->clk);*/
@@ -1070,7 +1017,7 @@ static struct uart_driver acp_serial_driver = {
   acp_serial_add_ports
 */
 
-STATIC int
+static int
 acp_serial_add_ports(struct uart_driver *driver)
 {
 	struct uart_acp_port *uap;
@@ -1082,9 +1029,8 @@ acp_serial_add_ports(struct uart_driver *driver)
 	const int *enabled = NULL;
 
 	for (i = 0; i < ARRAY_SIZE(acp_ports); ++i) {
-		if (acp_ports[i] == NULL) {
+		if (acp_ports[i] == NULL)
 			break;
-		}
 	}
 
 	if (i == ARRAY_SIZE(acp_ports)) {
@@ -1104,9 +1050,8 @@ acp_serial_add_ports(struct uart_driver *driver)
 	while (np && !of_device_is_compatible(np, "acp-uart0"))
 		np = of_find_node_by_type(np, "serial");
 
-	if (np) {
+	if (np)
 		enabled = of_get_property(np, "enabled", NULL);
-	}
 
 	if (!enabled) {
 		/*
@@ -1130,9 +1075,8 @@ acp_serial_add_ports(struct uart_driver *driver)
 			while (np && !of_device_is_compatible(np, "acp-uart1"))
 				np = of_find_node_by_type(np, "serial");
 
-			if (np) {
+			if (np)
 				enabled = of_get_property(np, "enabled", NULL);
-			}
 		}
 
 		if (np && (0 != *enabled)) {
@@ -1223,7 +1167,7 @@ acp_serial_add_ports(struct uart_driver *driver)
   acp_serial_delete_ports
 */
 
-STATIC int
+static int
 acp_serial_delete_ports(struct uart_driver *driver)
 {
 	int i;
@@ -1243,40 +1187,6 @@ acp_serial_delete_ports(struct uart_driver *driver)
 /*
   ======================================================================
   ======================================================================
-  For debugging, export symbols...
-  ======================================================================
-  ======================================================================
-*/
-
-#ifdef DEBUG_EXPORT_SYMBOLS
-
-EXPORT_SYMBOL(acp_serial_isr);
-EXPORT_SYMBOL(acp_serial_set_termios);
-EXPORT_SYMBOL(acp_serial_shutdown);
-EXPORT_SYMBOL(get_clock_stuff);
-EXPORT_SYMBOL(acp_serial_startup);
-EXPORT_SYMBOL(acp_serial_tx_empty);
-EXPORT_SYMBOL(acp_serial_tx_chars);
-EXPORT_SYMBOL(acp_serial_add_ports);
-EXPORT_SYMBOL(acp_serial_delete_ports);
-EXPORT_SYMBOL(acp_serial_wac);
-EXPORT_SYMBOL(acp_serial_start_tx);
-EXPORT_SYMBOL(acp_serial_stop_tx);
-
-#ifdef CONFIG_SERIAL_ACP_CONSOLE
-EXPORT_SYMBOL(acp_serial_console_putchar);
-#endif
-
-#ifdef CONFIG_CONSOLE_POLL
-EXPORT_SYMBOL(acp_serial_poll_put_char);
-EXPORT_SYMBOL(acp_serial_poll_get_char);
-#endif
-
-#endif
-
-/*
-  ======================================================================
-  ======================================================================
   Linux module stuff.
   ======================================================================
   ======================================================================
@@ -1319,7 +1229,6 @@ acp_serial_init(void)
  out:
 	return ret;
 }
-
 module_init(acp_serial_init);
 
 /*
@@ -1333,7 +1242,6 @@ acp_serial_exit(void)
 	acp_serial_delete_ports(&acp_serial_driver);
 	uart_unregister_driver(&acp_serial_driver);
 }
-
 module_exit(acp_serial_exit);
 
 MODULE_AUTHOR("LSI Corporation");
-- 
1.7.9.7

