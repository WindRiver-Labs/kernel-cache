From 7afd698c768a04978575dc5b03d01e060535c694 Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Mon, 16 Jul 2012 14:00:50 +0800
Subject: [PATCH 1/2] LSI:ACP34xx:Allow NAND & Ubootenv to compile as modules

The nand & ubootenv driver on acp34xx platform depends on MTD.
Since the MTD subsystem could compile as kernel modules, the patch
allows lsi's nand & ubootenv driver to compile as kernel modules.

1.Update dependence of LSI's nand & ubootenv driver.
2.Change the module name of nand driver to lsi_nand.
3.Update lsi's NIC driver & version driver, force them using default
value when ubootenv driver not present.

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/lsi/Kconfig       |    6 +++---
 drivers/lsi/acp/Makefile  |    3 ++-
 drivers/lsi/acp/net.c     |   30 ++++++++++++++++++++++--------
 drivers/lsi/acp/version.c |    5 +++++
 4 files changed, 32 insertions(+), 12 deletions(-)

diff --git a/drivers/lsi/Kconfig b/drivers/lsi/Kconfig
index c93e192..f3dd3ae 100644
--- a/drivers/lsi/Kconfig
+++ b/drivers/lsi/Kconfig
@@ -1,14 +1,14 @@
 menu "LSI Drivers (APP3, APP3K, and ACP)"
 
 config LSI_NAND
-	bool "NAND Driver for LSI's APP and ACP"
+	tristate "NAND Driver for LSI's APP and ACP"
 	depends on ACP
-	select MTD_NAND
+	depends on MTD_NAND
 	help
 		Add NAND support to LSI's APP/ACP boards.
 
 config LSI_UBOOTENV
-	bool "U-Boot Environment Access for LSI's APP and ACP"
+	tristate "U-Boot Environment Access for LSI's APP and ACP"
 	depends on ( ACP && LSI_NAND && CRC32 )
 	help
 		Add U-Boot environment access on LSI's APP/ACP boards.
diff --git a/drivers/lsi/acp/Makefile b/drivers/lsi/acp/Makefile
index b874787..9f11564 100644
--- a/drivers/lsi/acp/Makefile
+++ b/drivers/lsi/acp/Makefile
@@ -1,9 +1,10 @@
 # Makefile for LSI drivers
 obj-$(CONFIG_ACP)			+= ncr.o
 obj-$(CONFIG_ACP)			+= clocks.o
-obj-$(CONFIG_LSI_NAND)			+= nand.o
+obj-$(CONFIG_LSI_NAND)			+= lsi_nand.o
 obj-$(CONFIG_LSI_UBOOTENV)		+= ubootenv.o
 obj-$(CONFIG_ACP)			+= version.o
 obj-$(CONFIG_SERIAL_ACP)		+= serial.o
 obj-$(CONFIG_ACP)			+= wrappers.o
 obj-$(CONFIG_LSI_NET)			+= net.o
+lsi_nand-objs := nand.o
diff --git a/drivers/lsi/acp/net.c b/drivers/lsi/acp/net.c
index 836a21d..8de649f 100644
--- a/drivers/lsi/acp/net.c
+++ b/drivers/lsi/acp/net.c
@@ -2021,7 +2021,7 @@ static int phy_enable_( int phy ) {
     char mdio_clock_speed_string_ [ 256 ];
     unsigned long mdio_clock_speed_;
     unsigned long mdio_divisor_;
-
+#ifdef CONFIG_LSI_UBOOTENV
     if( 0 != ubootenv_get( "mdio_clock", mdio_clock_speed_string_ ) ) {
 
       mdio_clock_speed_ = 1250000;
@@ -2031,6 +2031,9 @@ static int phy_enable_( int phy ) {
       mdio_clock_speed_ = simple_strtoul(  mdio_clock_speed_string_, NULL, 0 );
 
     }
+#else
+	mdio_clock_speed_ = 1250000;
+#endif
 
 #ifdef CONFIG_ARCH_APP3K
     mdio_divisor_ =
@@ -2052,7 +2055,7 @@ static int phy_enable_( int phy ) {
   {
 
     char phy_address_string_ [ 256 ];
-
+#ifdef CONFIG_LSI_UBOOTENV
     if( 0 != ubootenv_get( "phy_address", phy_address_string_ ) ) {
 
       phy_address_ = phy_scan_( );
@@ -2062,7 +2065,9 @@ static int phy_enable_( int phy ) {
       phy_address_ = simple_strtoul( phy_address_string_, NULL, 0 );
 
     }
-
+#else
+	phy_address_ = phy_scan_();
+#endif
     if( 31 < phy_address_ || 0 > phy_address_ ) {
 
       ERROR_PRINT( "Unable to get valid PHY address!\n" );
@@ -2141,9 +2146,9 @@ static int phy_enable_( int phy ) {
       0x61 - 10 half/full
       0x41 - 10 half
     */
-
+#ifdef CONFIG_LSI_UBOOTENV
     if( 0 != ubootenv_get( "ad_value", ad_value_string_ ) ) {
-
+#endif
       if( ( is_asic ) &&
           ( 0 == ( APP3XX_REVISION_REGISTER & 0x1f ) ) ) {
 
@@ -2158,12 +2163,13 @@ static int phy_enable_( int phy ) {
       }
 
       WARN_PRINT( "ad_value not set, using 0x%x\n", ad_value_ );
-
+#ifdef CONFIG_LSI_UBOOTENV
     } else {
 
       ad_value_ = simple_strtoul( ad_value_string_, NULL, 0 );
 
     }
+#endif
 
     if( 0 != phy_write_( phy_address_, PHY_AUTONEG_ADVERTISE_,
                          ad_value_ ) ) {
@@ -2915,13 +2921,16 @@ int appnic_open( struct net_device * device ) {
 #ifndef PHYLESS
 
 #ifndef CONFIG_ACP
-
+#ifdef CONFIG_LSI_UBOOTENV
     if( ( 0 != ubootenv_get( "phy_mode", phy_string_ ) ) ||
         ( 0 == strncmp( phy_string_, "poll", strlen( "poll" ) ) ) ) {
 
       use_interrupts_ = 0;
 
     }
+#else
+	use_interrupts_ = 0;
+#endif
 
     PHY_DEBUG_PRINT( "use_interrupts_=%d\n", use_interrupts_ );
 
@@ -4445,7 +4454,7 @@ lsinet_init(void)
 
 	} else {
 		unsigned char ethaddr_string[20];
-
+#ifdef CONFIG_LSI_UBOOTENV
 		if (0 != ubootenv_get("ethaddr", ethaddr_string)) {
 			ERROR_PRINT("Could not read ethernet address!\n");
 			return -EBUSY;
@@ -4477,6 +4486,11 @@ lsinet_init(void)
 		dma_base = (unsigned long)ioremap(0x002000482000ULL, 0x1000);
 		appnic_device->dma_base = dma_base;
 		appnic_device->interrupt = 33;
+#else
+		/* Neither dtb info nor ubootenv driver found.*/
+		ERROR_PRINT("Could not read ethernet address!\n");
+		return -EBUSY;
+#endif
 	}
 
  device_tree_succeeded:
diff --git a/drivers/lsi/acp/version.c b/drivers/lsi/acp/version.c
index 6c193c7..9306b07 100644
--- a/drivers/lsi/acp/version.c
+++ b/drivers/lsi/acp/version.c
@@ -252,6 +252,7 @@ info_create_string(char *buffer)
 	sprintf(uboot_version2, "Unknown");
 	sprintf(uboot_version3, "Unknown");
 #else
+#ifdef CONFIG_LSI_UBOOTENV
 	if (0 != ubootenv_get("version2", uboot_version2)) {
 		sprintf(uboot_version2, "Unknown");
 	}
@@ -259,6 +260,10 @@ info_create_string(char *buffer)
 	if (0 != ubootenv_get("version3", uboot_version3)) {
 		sprintf(uboot_version3, "Unknown");
 	}
+#else
+	sprintf(uboot_version2, "Unknown");
+	sprintf(uboot_version3, "Unknown");
+#endif
 #endif
 
 	length = sprintf(buffer,
-- 
1.7.9.7

