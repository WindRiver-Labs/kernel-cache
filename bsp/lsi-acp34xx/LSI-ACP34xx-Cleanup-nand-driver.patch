From 5b3060cbe3df0701b2fd701c4077318b5b04caf1 Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Thu, 31 Jan 2013 15:22:19 +0800
Subject: [PATCH 06/16] LSI:ACP34xx:Cleanup nand driver

Cleanup apc34xx's nand driver with following modification:
1.Remove unnecessary debug macros.
2.Fix code indent issues.
3.Remove dead code.

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/lsi/acp/nand.c |  868 +++++++++++++++++++++++-------------------------
 1 file changed, 417 insertions(+), 451 deletions(-)

diff --git a/drivers/lsi/acp/nand.c b/drivers/lsi/acp/nand.c
index 97f5cc3..93f221c 100644
--- a/drivers/lsi/acp/nand.c
+++ b/drivers/lsi/acp/nand.c
@@ -31,26 +31,26 @@
 #include <linux/mtd/nand.h>
 #include <linux/mtd/partitions.h>
 #include <linux/of.h>
-#include <asm/io.h>
-#include <asm/delay.h>
+#include <linux/io.h>
+#include <linux/delay.h>
 #include <asm/cacheflush.h>
 
 /*
-  ======================================================================
-  ======================================================================
+  =========================================================
+  =========================================================
   Private
-  ======================================================================
-  ======================================================================
+  =========================================================
+  =========================================================
 */
 
 #include <asm/lsi/debug.h>
 
-/* -- LOGIO --------------------------------------------------------- */
+/* -- LOGIO -- */
 
 #undef LOGIO
 #define LOGIO
 #ifdef LOGIO
-int enable_logio = 0;
+int enable_logio;
 static inline unsigned long _READL(const char *, int, void *);
 static inline unsigned long
 _READL(const char *file, int line, void *address)
@@ -65,6 +65,7 @@ _READL(const char *file, int line, void *address)
 
 	return value;
 }
+
 #define READL(address) _READL(__FILE__, __LINE__, (address))
 static inline void _WRITEL(const char *, int, unsigned long, void *);
 static inline void
@@ -73,16 +74,17 @@ _WRITEL(const char *file, int line, unsigned long value, void *address)
 	writel(value, (volatile void __iomem *)address);
 
 	if (0 != enable_logio)
-		printk( "%s:%d - Wrote 0x%08lx to 0x%08lx\n",
-			file, line, value, (unsigned long)address);
+		printk("%s:%d - Wrote 0x%08lx to 0x%08lx\n",
+		       file, line, value, (unsigned long)address);
 
 	return;
 }
+
 #define WRITEL(value, address) _WRITEL(__FILE__, __LINE__, (value), (address))
-#else  /* LOGIO */
+#else				/* LOGIO */
 #define READL(address) readl((address))
 #define WRITEL(value, address) writel((value), (address))
-#endif /* LOGIO */
+#endif				/* LOGIO */
 
 /*
   ----------------------------------------------------------------------
@@ -366,9 +368,10 @@ static void *gpreg_base;
 
 static struct mtd_info lsi_nand_mtd = { 0 };
 static struct nand_chip lsi_nand_chip = { 0 };
+
 static struct lsi_nand_private {
-	int	cur;	/* -1 means there is no meaningful data in buffer*/
-	uint8_t	buf[MAX_READ_BUF];
+	int cur;		/* -1 means there is no meaningful data in buffer */
+	uint8_t buf[MAX_READ_BUF];
 } lsi_nand_private;
 
 #define NAND_CMD_START_ECC_READ	  0x23
@@ -393,7 +396,7 @@ typedef union {
 		unsigned long trp:8;
 		unsigned long th:8;
 #endif
-	} __attribute__ ((packed)) bits;
+	} __packed bits;
 } nand_timing_control_register_0_t;
 
 typedef union {
@@ -411,26 +414,26 @@ typedef union {
 		unsigned long trr:8;
 		unsigned long twb:8;
 #endif
-	} __attribute__ ((packed)) bits;
-} __attribute__ ((packed)) nand_timing_control_register_1_t;
+	} __packed bits;
+} __packed nand_timing_control_register_1_t;
 
 typedef union {
 	unsigned long raw;
 
 	struct {
 #ifdef CONFIG_ACP
-		unsigned long      : 8;
-		unsigned long trhw : 8;
-		unsigned long twhr : 8;
-		unsigned long tccs : 8;
+		unsigned long:8;
+		unsigned long trhw:8;
+		unsigned long twhr:8;
+		unsigned long tccs:8;
 #else
-		unsigned long tccs : 8;
-		unsigned long twhr : 8;
-		unsigned long trhw : 8;
-		unsigned long      : 8;
+		unsigned long tccs:8;
+		unsigned long twhr:8;
+		unsigned long trhw:8;
+		unsigned long:8;
 #endif
-	} __attribute__ ( ( packed ) ) bits;
-} __attribute__ ( ( packed ) ) nand_timing_control_register_2_t;
+	} __packed bits;
+} __packed nand_timing_control_register_2_t;
 
 typedef enum {
 	LSI_NAND_NONE, LSI_NAND_EP501, LSI_NAND_EP501G1, LSI_NAND_EP501G3
@@ -439,15 +442,15 @@ typedef enum {
 static lsi_nand_type_t lsi_nand_type;
 
 typedef struct page_wise_ecc_status_st {
-	unsigned err_bit :  3;
-	unsigned column  :  9;
-	unsigned status  :  2;
-	unsigned rsvd    : 18;
+	unsigned err_bit:3;
+	unsigned column:9;
+	unsigned status:2;
+	unsigned rsvd:18;
 } page_wise_ecc_status_t;
 
 /*
-  ===============================================================================
-  ===============================================================================
+  =====================================================================
+  =====================================================================
   Concerning ECC
 
   The EP501 only supports 1 bit ECC mode.  The EP501G1 supports both 1
@@ -476,86 +479,59 @@ typedef struct page_wise_ecc_status_st {
 
   This driver has been tested with 2K and 4K page sizes using 1 bit
   and 4 bit ECC.
-  ===============================================================================
-  ===============================================================================
+  ==================================================================
+  ==================================================================
 */
 
-static uint8_t scan_ff_pattern[] = {0xff, 0xff};
+static uint8_t scan_ff_pattern[] = { 0xff, 0xff };
 
 static struct nand_ecclayout lsi_2k_1bit_ecclayout = {
 	.eccbytes = 12,
-	.eccpos = {	       
-		52, 53, 54, 55, 56, 57, 
-		58, 59, 60, 61, 62, 63},
-	.oobfree = {{2, 50}}
+	.eccpos = {
+		   52, 53, 54, 55, 56, 57,
+		   58, 59, 60, 61, 62, 63},
+	.oobfree = { {2, 50} }
 };
 
 static struct nand_ecclayout lsi_2k_4bit_ecclayout = {
 	.eccbytes = 32,
 	.eccpos = {
-		32, 33, 34, 35, 36, 37, 38, 39,
-		40, 41, 42, 43, 44, 45, 46, 47,
-		48, 49, 50, 51, 52, 53, 54, 55,
-		56, 57, 58, 59, 60, 61, 62, 63},
+		   32, 33, 34, 35, 36, 37, 38, 39,
+		   40, 41, 42, 43, 44, 45, 46, 47,
+		   48, 49, 50, 51, 52, 53, 54, 55,
+		   56, 57, 58, 59, 60, 61, 62, 63},
 	.oobfree = { {2, 30} }
 };
 
 static struct nand_bbt_descr lsi_2k_4bit_bbt_descr = {
-	.options = NAND_BBT_SCANEMPTY |	NAND_BBT_SCANALLPAGES | \
-	NAND_BBT_SCAN2NDPAGE,
-        .offs = 5,
-        .len = 1,
-        .pattern = scan_ff_pattern
+	.options = NAND_BBT_SCANEMPTY | NAND_BBT_SCANALLPAGES |
+	    NAND_BBT_SCAN2NDPAGE,
+	.offs = 5,
+	.len = 1,
+	.pattern = scan_ff_pattern
 };
 
-
 static struct nand_ecclayout lsi_4k_4bit_ecclayout = {
 	.eccbytes = 64,
 	.eccpos = {
-		64,  65,  66,  67,  68,  69,  70,  71,
-		72,  73,  74,  75,  76,  77,  78,  79,
-		80,  81,  82,  83,  84,  85,  86,  87,
-		88,  89,  90,  91,  92,  93,  94,  95,
-		96,  97,  98,  99, 100, 101, 102, 103,
-		104, 105, 106, 107, 108, 109, 110, 111,
-		112, 113, 114, 115, 116, 117, 118, 119,
-		120, 121, 122, 123, 124, 125, 126, 127
-	},
-	.oobfree = {{2, 62}}
+		   64, 65, 66, 67, 68, 69, 70, 71,
+		   72, 73, 74, 75, 76, 77, 78, 79,
+		   80, 81, 82, 83, 84, 85, 86, 87,
+		   88, 89, 90, 91, 92, 93, 94, 95,
+		   96, 97, 98, 99, 100, 101, 102, 103,
+		   104, 105, 106, 107, 108, 109, 110, 111,
+		   112, 113, 114, 115, 116, 117, 118, 119,
+		   120, 121, 122, 123, 124, 125, 126, 127},
+	.oobfree = { {2, 62} }
 };
 
 static struct nand_bbt_descr lsi_4k_4bit_bbt_descr = {
 	.options = NAND_BBT_SCANEMPTY | NAND_BBT_SCANALLPAGES,
-        .offs = 0,
-        .len = 2,
-        .pattern = scan_ff_pattern
+	.offs = 0,
+	.len = 2,
+	.pattern = scan_ff_pattern
 };
 
-#if 0
-static struct nand_ecclayout lsi_8k_4bit_ecclayout = {
-	.eccbytes = 128,
-	.eccpos = {
-		128, 129, 130, 131, 132, 133, 134, 135,
-		136, 137, 138, 139, 140, 141, 142, 143,
-		144, 145, 146, 147, 148, 149, 150, 151,
-		152, 153, 154, 155, 156, 157, 158, 159,
-		160, 161, 162, 163, 164, 165, 166, 167,
-		168, 169, 170, 171, 172, 173, 174, 175,
-		176, 177, 178, 179, 180, 181, 182, 183,
-		184, 185, 186, 187, 188, 189, 190, 191,
-		192, 193, 194, 195, 196, 197, 198, 199,
-		200, 201, 202, 203, 204, 205, 206, 207,
-		208, 209, 210, 211, 212, 213, 214, 215,
-		216, 217, 218, 219, 220, 221, 222, 223,
-		224, 225, 226, 227, 228, 229, 230, 231,
-		232, 233, 234, 235, 236, 237, 238, 239,
-		240, 241, 242, 243, 244, 245, 246, 247,
-		248, 249, 250, 251, 252, 253, 254, 255
-	},
-	.oobfree = {{2, 126}}
-};
-#endif
-
 typedef struct {
 	unsigned long long corrected_ecc_errors;
 	unsigned long long uncorrectable_ecc_errors;
@@ -564,7 +540,7 @@ typedef struct {
 static lsi_nand_statistics_t lsi_nand_statistics;
 
 /*
-  -------------------------------------------------------------------------------
+  -------------------------------------------------------------------
   lsi_nand_read_proc
 */
 
@@ -578,17 +554,16 @@ lsi_nand_read_proc(char *page,
 	loff_t ofs;
 
 	length = sprintf(page,
-			 "LSI NAND Driver Statistics\n" \
-			 "  ECC, Corrected   : %llu\n" \
+			 "LSI NAND Driver Statistics\n"
+			 "  ECC, Corrected   : %llu\n"
 			 "  ECC, Uncorrected : %llu\n\n",
 			 lsi_nand_statistics.corrected_ecc_errors,
 			 lsi_nand_statistics.uncorrectable_ecc_errors);
 
 	length += sprintf((page + length),
-			  "LSI NAND Driver Info\n" \
-			  "writesize=0x%x eraseisze=0x%x\n" \
-			  "Bad Blocks: ",
-			  mtd->writesize, mtd->erasesize);
+			  "LSI NAND Driver Info\n"
+			  "writesize=0x%x eraseisze=0x%x\n"
+			  "Bad Blocks: ", mtd->writesize, mtd->erasesize);
 
 	for (ofs = 0; ofs < mtd->size; ofs += mtd->erasesize) {
 		int isbad = 0;
@@ -608,7 +583,6 @@ lsi_nand_read_proc(char *page,
 }
 
 /*
-  -------------------------------------------------------------------------------
   lsi_nand_hwcontrol
 */
 
@@ -617,15 +591,14 @@ lsi_nand_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl)
 {
 	struct nand_chip *chip = mtd->priv;
 
-	if (cmd != NAND_CMD_NONE) {
-		WRITEL (cmd, (chip->IO_ADDR_W + NAND_CMD_REG));
-	}
+	if (cmd != NAND_CMD_NONE)
+		WRITEL(cmd, (chip->IO_ADDR_W + NAND_CMD_REG));
 
 	return;
 }
 
 /*
-  ------------------------------------------------------------------------------
+  --------------------------------------------------------------------
   lsi_nand_device_ready
 
   The READ/BUSY# input from the NAND device(s) (ORed if there are more
@@ -683,8 +656,7 @@ lsi_nand_command(struct mtd_info *mtd, unsigned int command,
 	    command != NAND_CMD_READID &&
 	    command != NAND_CMD_RESET &&
 	    command != NAND_CMD_START_ECC_READ &&
-	    command != NAND_CMD_PAGEPROG &&
-	    command != NAND_CMD_ERASE2) {
+	    command != NAND_CMD_PAGEPROG && command != NAND_CMD_ERASE2) {
 		printk(KERN_ERR
 		       "lsi_nand_command(): WARN: Unhandled command 0x%x "
 		       "issued for page=0x%x, column=0x%x.\n",
@@ -694,8 +666,7 @@ lsi_nand_command(struct mtd_info *mtd, unsigned int command,
 
 	priv->cur = -1;
 	/* Command latch cycle */
-	chip->cmd_ctrl(mtd, command,
-		       NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);
+	chip->cmd_ctrl(mtd, command, NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);
 
 	if (column != -1 || page_addr != -1) {
 		unsigned long index = 0;
@@ -703,9 +674,9 @@ lsi_nand_command(struct mtd_info *mtd, unsigned int command,
 
 		/* column number */
 		/*
-		  Since the ACP uses 8 bit device access, only that
-		  mode is supported.
-		*/
+		   Since the ACP uses 8 bit device access, only that
+		   mode is supported.
+		 */
 
 		if (LSI_NAND_EP501 == lsi_nand_type) {
 			/* column number */
@@ -741,11 +712,13 @@ lsi_nand_command(struct mtd_info *mtd, unsigned int command,
 					break;
 				case 2048:
 					index |= (page_addr & 0xfffff) << 12;
-					extended_index |= (page_addr & 0xfff00000);
+					extended_index |=
+					    (page_addr & 0xfff00000);
 					break;
 				case 4096:
 					index |= (page_addr & 0x7ffff) << 13;
-					extended_index |= (page_addr & 0xfff80000);
+					extended_index |=
+					    (page_addr & 0xfff80000);
 					break;
 				default:
 					break;
@@ -799,20 +772,20 @@ lsi_nand_command(struct mtd_info *mtd, unsigned int command,
  *
  * Default read function for 8bit buswith
  */
-static void lsi_nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
+static void
+lsi_nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
 {
 	int i = 0;
-	struct nand_chip * chip = (struct nand_chip *) mtd->priv;
-	uint32_t * p = (uint32_t *)buf;
+	struct nand_chip *chip = (struct nand_chip *) mtd->priv;
+	uint32_t *p = (uint32_t *)buf;
 
 #if defined(LOGIO)
 	if (0 != enable_logio)
 		printk("Reading NAND Buffer (len=%d)...\n", len);
 #endif
 
-	for (i = 0; i < (len >> 2); i++) {
+	for (i = 0; i < (len >> 2); i++)
 		p[i] = readl(chip->IO_ADDR_R);
-	}
 
 	return;
 }
@@ -837,9 +810,8 @@ lsi_nand_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
 		printk("Writing NAND Buffer (len=%d)...\n", len);
 #endif
 
-	for (i = 0; i < (len >> 2); i++) {
+	for (i = 0; i < (len >> 2); i++)
 		writel(p[i], chip->IO_ADDR_W);
-	}
 
 	return;
 }
@@ -852,7 +824,8 @@ lsi_nand_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
  *
  * Default verify function for 8bit buswith
  */
-static int lsi_nand_verify_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
+static int
+lsi_nand_verify_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
 {
 	int i;
 	struct nand_chip *chip = mtd->priv;
@@ -860,15 +833,15 @@ static int lsi_nand_verify_buf(struct mtd_info *mtd, const uint8_t *buf, int len
 
 	for (i = 0; i < (len >> 2); i++) {
 		udelay(chip->chip_delay);
-		if (p[i] != readl((uint32_t *)chip->IO_ADDR_R)) {
+		if (p[i] != readl((uint32_t *) chip->IO_ADDR_R))
 			return -EFAULT;
-		}
 	}
 
 	return 0;
 }
 
-static int lsi_nand_read_status(struct mtd_info *mtd)
+static int
+lsi_nand_read_status(struct mtd_info *mtd)
 {
 	struct nand_chip *chip = mtd->priv;
 
@@ -877,7 +850,6 @@ static int lsi_nand_read_status(struct mtd_info *mtd)
 	return READL(chip->IO_ADDR_R + NAND_STATUS1_REG) & 0xff;
 }
 
-
 /**
  * lsi_nand_wait - [DEFAULT]  wait until the command is done
  * @mtd:	MTD device structure
@@ -887,27 +859,16 @@ static int lsi_nand_read_status(struct mtd_info *mtd)
  * Erase can take up to 400ms and program up to 20ms according to
  * general NAND and SmartMedia specs
  */
-static int lsi_nand_wait(struct mtd_info *mtd, struct nand_chip *chip)
+static int
+lsi_nand_wait(struct mtd_info *mtd, struct nand_chip *chip)
 {
 	unsigned long status = 0;
 	loff_t offset = 0;
 
 	/*
-	  When reading or writing, wait for the
-	  controller's PECC_BUSY signal to clear.
-	*/
-#if 0
-	if (FL_READING == chip->state || FL_WRITING == chip->state) {
-		for (;;) {
-			status = READL((void *)LSI_NAND_PECC_BUSY_REGISTER);
-
-			if (0 == (status & LSI_NAND_PECC_BUSY_MASK))
-				break;
-
-			udelay(chip->chip_delay);
-		}
-	}
-#else
+	   When reading or writing, wait for the
+	   controller's PECC_BUSY signal to clear.
+	 */
 	for (;;) {
 		status = READL((void *)LSI_NAND_PECC_BUSY_REGISTER);
 
@@ -916,13 +877,12 @@ static int lsi_nand_wait(struct mtd_info *mtd, struct nand_chip *chip)
 
 		udelay(chip->chip_delay);
 	}
-#endif
 
 	/*
-	  In all cases, wait for the NAND device to be "ready".
+	   In all cases, wait for the NAND device to be "ready".
 
-	  N.B. The FL_READING case is handled in lsi_nand_command().
-	*/
+	   N.B. The FL_READING case is handled in lsi_nand_command().
+	 */
 
 	if (FL_WRITING == chip->state || FL_ERASING == chip->state) {
 		for (;;) {
@@ -934,8 +894,8 @@ static int lsi_nand_wait(struct mtd_info *mtd, struct nand_chip *chip)
 	}
 
 	/*
-	  Then get the status.
-	*/
+	   Then get the status.
+	 */
 
 	for (;;) {
 		status = lsi_nand_read_status(mtd);
@@ -980,11 +940,10 @@ lsi_nand_ecc_calculate(struct mtd_info *mtd, const uint8_t *dat,
 	struct nand_chip *chip = mtd->priv;
 
 	/* start ECC calculation */
-	if (chip->state == FL_READING) {
+	if (chip->state == FL_READING)
 		chip->cmdfunc(mtd, NAND_CMD_START_ECC_READ, -1, -1);
-	} else if (chip->state == FL_WRITING) {
+	else if (chip->state == FL_WRITING)
 		chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
-	}
 
 	/* wait for PECC_BUSY to go down */
 	return chip->waitfunc(mtd, chip);
@@ -1014,7 +973,7 @@ report_ecc_errors_ep501(struct mtd_info *mtd, struct nand_chip *chip,
 	int rc = 0;
 	unsigned long ecc_status;
 	page_wise_ecc_status_t *ecc_status_reg =
-		(page_wise_ecc_status_t *)&ecc_status;
+	    (page_wise_ecc_status_t *)&ecc_status;
 	int column;
 	int i;
 
@@ -1029,7 +988,8 @@ report_ecc_errors_ep501(struct mtd_info *mtd, struct nand_chip *chip,
 			       page, column, ecc_status_reg->err_bit);
 
 			if (column < mtd->writesize) {
-				buffer[column] ^= (1 << ecc_status_reg->err_bit);
+				buffer[column] ^=
+				    (1 << ecc_status_reg->err_bit);
 				++mtd->ecc_stats.corrected;
 			} else {
 				printk(KERN_ERR
@@ -1039,14 +999,9 @@ report_ecc_errors_ep501(struct mtd_info *mtd, struct nand_chip *chip,
 				       column, mtd->writesize);
 				rc = -1;
 			}
-		} else if((ecc_status & 0x3000) == 2) {
+		} else if ((ecc_status & 0x3000) == 2) {
 			++lsi_nand_statistics.uncorrectable_ecc_errors;
-#if 0
-			printk(KERN_ERR
-			       "Uncorrectable ECC Error: "
-			       "Page=0x%x Column=0x%x\n",
-			       page, column);
-#endif
+
 			rc = -1;
 		}
 	}
@@ -2693,8 +2648,8 @@ fix_section(unsigned long offset, void *data, int *syndromes_in)
 	block_length = 8191;
 
 	/*
-	  If there are no errors, just return.
-	*/
+	   If there are no errors, just return.
+	 */
 
 	j = 0;
 
@@ -2709,23 +2664,23 @@ fix_section(unsigned long offset, void *data, int *syndromes_in)
 		return 0;
 
 	/*
-	  Decode.
-	*/
+	   Decode.
+	 */
 
-	memcpy((void *)syndromes, (void *)syndromes_in, sizeof(int) * 9);
+	memcpy((void *) syndromes, (void *) syndromes_in, sizeof(int) * 9);
 	d_flg = 0;
 
-	// initialise table entries
+	/* initialise table entries */
 	for (i = 0; i < 8; i++)
-	  syndromes[i] = i_to_a[syndromes[i]];
+		syndromes[i] = i_to_a[syndromes[i]];
 
 	Matrix_c[0] = 0;
 	Matrix_c[1] = syndromes[0];
 	err_loc_ply[0][0] = 1;
 	err_loc_ply[1][0] = 1;
 	for (i = 1; i < 8; i++) {
-	  err_loc_ply[0][i] = 0;
-	  err_loc_ply[1][i] = 0;
+		err_loc_ply[0][i] = 0;
+		err_loc_ply[1][i] = 0;
 	}
 	Matrix_a[0] = 0;
 	Matrix_a[1] = 0;
@@ -2734,135 +2689,145 @@ fix_section(unsigned long offset, void *data, int *syndromes_in)
 	alpha = -1;
 
 	do {
-	  // skip even loops
-	  alpha += 2;
-	  if (Matrix_c[alpha] != -1) {
-	    temp_index = alpha - 2;
-	    if (temp_index<0) temp_index=0;
-	    while ((Matrix_c[temp_index] == -1) && (temp_index > 0))
-	      temp_index=temp_index-2;
-	    if (temp_index < 0) temp_index = 0;
-
-	    if (temp_index > 0) {
-	      j = temp_index;
-	      do {
-		j=j-2;
-		if (j < 0) j = 0;
-		if ((Matrix_c[j] != -1) && (Matrix_b[temp_index] < Matrix_b[j]))
-		  temp_index = j;
-	      } while (j > 0);
-	    }
-
-	    if (Matrix_a[alpha] > Matrix_a[temp_index] + alpha - temp_index)
-	      Matrix_a[alpha + 2] = Matrix_a[alpha];
-	    else
-	      Matrix_a[alpha + 2] = Matrix_a[temp_index] + alpha - temp_index;
-
-	    for (i = 0; i < 8; ++i) {
-		    err_loc_ply[alpha + 2][i] = 0;
-	    }
-
-	    for (i = 0; i <= Matrix_a[temp_index]; i++) {
-	      if (err_loc_ply[temp_index][i] != 0)
-		    err_loc_ply[alpha + 2][i + alpha - temp_index] =
-			    a_to_i[(Matrix_c[alpha] + block_length -
-				    Matrix_c[temp_index] +
-				    i_to_a[err_loc_ply[temp_index][i]]) %
-				   block_length];
-	    }
-
-	    for (i = 0; i <= Matrix_a[alpha]; i++) {
-		    err_loc_ply[alpha + 2][i] ^= err_loc_ply[alpha][i];
-	    }
-	  } else {
-		  Matrix_a[alpha + 2] = Matrix_a[alpha];
-
-		  for (i = 0; i <= Matrix_a[alpha]; i++) {
-			  err_loc_ply[alpha + 2][i] = err_loc_ply[alpha][i];
-		  }
-	  }
-
-	  Matrix_b[alpha + 2] = alpha+1 - Matrix_a[alpha + 2];
-
-	  // Form (alpha+2)th discrepancy.
-	  if (alpha < 8) {
-		  if (syndromes[alpha + 1] != -1) {
-			  Matrix_c[alpha + 2] = a_to_i[syndromes[alpha + 1]];
-		  } else {
-			  Matrix_c[alpha + 2] = 0;
-		  }
-
-		  for (i = 1; i <= Matrix_a[alpha + 2]; i++) {
-			  if ((syndromes[alpha + 1 - i] != -1) && (err_loc_ply[alpha + 2][i] != 0))
-				  Matrix_c[alpha + 2] ^= a_to_i[(syndromes[alpha + 1 - i] + i_to_a[err_loc_ply[alpha + 2][i]]) % block_length];
-		  }
-		  Matrix_c[alpha + 2] = i_to_a[Matrix_c[alpha + 2]];
-	  }
+		/* skip even loops */
+		alpha += 2;
+		if (Matrix_c[alpha] != -1) {
+			temp_index = alpha - 2;
+			if (temp_index < 0)
+				temp_index = 0;
+			while ((Matrix_c[temp_index] == -1) && (temp_index > 0))
+				temp_index = temp_index - 2;
+			if (temp_index < 0)
+				temp_index = 0;
+
+			if (temp_index > 0) {
+				j = temp_index;
+				do {
+					j = j - 2;
+					if (j < 0)
+						j = 0;
+					if ((Matrix_c[j] != -1)
+					    && (Matrix_b[temp_index] <
+						Matrix_b[j]))
+						temp_index = j;
+				} while (j > 0);
+			}
+
+			if (Matrix_a[alpha] >
+			    Matrix_a[temp_index] + alpha - temp_index)
+				Matrix_a[alpha + 2] = Matrix_a[alpha];
+			else
+				Matrix_a[alpha + 2] =
+				    Matrix_a[temp_index] + alpha - temp_index;
+
+			for (i = 0; i < 8; ++i)
+				err_loc_ply[alpha + 2][i] = 0;
+
+			for (i = 0; i <= Matrix_a[temp_index]; i++) {
+				if (err_loc_ply[temp_index][i] != 0)
+					err_loc_ply[alpha + 2][i + alpha -
+							       temp_index] =
+					    a_to_i[(Matrix_c[alpha] +
+						    block_length -
+						    Matrix_c[temp_index] +
+						    i_to_a[err_loc_ply
+							   [temp_index][i]]) %
+						   block_length];
+			}
+
+			for (i = 0; i <= Matrix_a[alpha]; i++) {
+				err_loc_ply[alpha + 2][i] ^=
+				    err_loc_ply[alpha][i];
+			}
+		} else {
+			Matrix_a[alpha + 2] = Matrix_a[alpha];
+
+			for (i = 0; i <= Matrix_a[alpha]; i++) {
+				err_loc_ply[alpha + 2][i] =
+				    err_loc_ply[alpha][i];
+			}
+		}
+
+		Matrix_b[alpha + 2] = alpha + 1 - Matrix_a[alpha + 2];
+
+		/* Form (alpha+2)th discrepancy.*/
+		if (alpha < 8) {
+			if (syndromes[alpha + 1] != -1) {
+				Matrix_c[alpha + 2] =
+				    a_to_i[syndromes[alpha + 1]];
+			} else {
+				Matrix_c[alpha + 2] = 0;
+			}
+
+			for (i = 1; i <= Matrix_a[alpha + 2]; i++) {
+				if ((syndromes[alpha + 1 - i] != -1)
+				    && (err_loc_ply[alpha + 2][i] != 0))
+					Matrix_c[alpha + 2] ^=
+					    a_to_i[(syndromes[alpha + 1 - i] +
+						    i_to_a[err_loc_ply
+							   [alpha +
+							    2][i]]) %
+						   block_length];
+			}
+			Matrix_c[alpha + 2] = i_to_a[Matrix_c[alpha + 2]];
+		}
 	} while ((alpha < 7) && (Matrix_a[alpha + 2] <= 4));
 
-	alpha=alpha+2;
+	alpha = alpha + 2;
 	Matrix_a[7] = Matrix_a[alpha];
 	if (Matrix_a[7] <= 4) {
 
-	  for (i = 1; i <= Matrix_a[7]; i++) {
-	    Element[i] = i_to_a[err_loc_ply[alpha][i]];
-	  }
-
-	  err_count = 0 ;
-	  for (i = 1; i <= block_length; i++) {
-	    elp_sum = 1 ;
-	    for (j = 1; j <= Matrix_a[7]; j++)
-	      if (Element[j] != -1) {
-		Element[j] = (Element[j] + j) % block_length ;
-		elp_sum ^= a_to_i[Element[j]] ;
-	      }
-
-	    if (!elp_sum) {
-	      err_location[err_count] = block_length - i ;
-	      err_count++ ;
-	    }
-	  }
-
-	  if (err_count == Matrix_a[7])
-	    d_flg = 1 ;
+		for (i = 1; i <= Matrix_a[7]; i++)
+			Element[i] = i_to_a[err_loc_ply[alpha][i]];
+
+		err_count = 0;
+		for (i = 1; i <= block_length; i++) {
+			elp_sum = 1;
+			for (j = 1; j <= Matrix_a[7]; j++)
+				if (Element[j] != -1) {
+					Element[j] =
+					    (Element[j] + j) % block_length;
+					elp_sum ^= a_to_i[Element[j]];
+				}
+
+			if (!elp_sum) {
+				err_location[err_count] = block_length - i;
+				err_count++;
+			}
+		}
+
+		if (err_count == Matrix_a[7])
+			d_flg = 1;
 	}
 
 	if (d_flg == 0) {
 		return -1;
-	}
-	else {
-                uncorrected_count = err_count;
+	} else {
+		uncorrected_count = err_count;
 
-		for (i=0; i<err_count; i++)
-		{
+		for (i = 0; i < err_count; i++) {
 			if (err_location[i] >= 52)
 				data_location = err_location[i] - 52;
 			else
 				data_location = err_location[i] + data_length;
 
-			if (data_location <= 4095)
-			{
+			if (data_location <= 4095) {
 				rev_location = 4095 - data_location;
-				result_bit = rev_location%8;
-				result_byte = (rev_location - result_bit)/8;
+				result_bit = rev_location % 8;
+				result_byte = (rev_location - result_bit) / 8;
 				++lsi_nand_statistics.corrected_ecc_errors;
 				--uncorrected_count;
-#if 0
-				printk(KERN_NOTICE
-				       "Corrected ECC Error: "
-				       "offset 0x%lx byte 0x%x bit %d\n",
-				       offset, result_byte, result_bit);
-#endif
+
 				result_byte =
-					(result_byte & 0xfffffffc) |
-					((result_byte & 0x3) ^ 0x3);
-				*((unsigned char *)(data +
-						    result_byte)) ^=
-					(1 << result_bit);
+				    (result_byte & 0xfffffffc) |
+				    ((result_byte & 0x3) ^ 0x3);
+				*((unsigned char *) (data +
+						     result_byte)) ^=
+				    (1 << result_bit);
 			} else {
 				rev_location = 4147 - data_location;
-				result_bit = rev_location%8;
-				result_byte = (rev_location - result_bit)/8;
+				result_bit = rev_location % 8;
+				result_byte = (rev_location - result_bit) / 8;
 				printk(KERN_ERR
 				       "BCH byte = %d, bit = %d\n",
 				       result_byte, result_bit);
@@ -2967,37 +2932,38 @@ report_ecc_errors_ep501g3(struct mtd_info *mtd, struct nand_chip *chip,
 	}
 
 	/* Ignore fully erased blocks. */
-      if(mtd->oobsize != 224){	
-	  	data = chip->oob_poi;
+	if (mtd->oobsize != 224) {
+		data = chip->oob_poi;
 		data += mtd->oobsize;
 		data -= chip->ecc.layout->eccbytes;
 
-	      for (i = 0; i < (mtd->oobsize - chip->ecc.layout->eccbytes); ++i) {
-		    if (0xff != *data++) {
-			    is_blank = 0;
-			    break;
-		    }
-	      }
-      	}else{   
-	         data = chip->oob_poi;
-	         for (i = 0; i < chip->ecc.total; ++i) {
-			  if (0xff != *data++) {
-				  is_blank = 0;
-				  break;
-			  }
-		   }
-
-		   if(is_blank == 0){
-		   	is_blank = 1;
-		       data = buffer;	
-		       for (i = 0; i < mtd->writesize; ++i) {
-		   	    if (0xff != *data++) {	
+		for (i = 0; i < (mtd->oobsize - chip->ecc.layout->eccbytes);
+		     ++i) {
+			if (0xff != *data++) {
+				is_blank = 0;
+				break;
+			}
+		}
+	} else {
+		data = chip->oob_poi;
+		for (i = 0; i < chip->ecc.total; ++i) {
+			if (0xff != *data++) {
 				is_blank = 0;
 				break;
-			    }
-		       }
-		   }  	    			   
-      	}
+			}
+		}
+
+		if (is_blank == 0) {
+			is_blank = 1;
+			data = buffer;
+			for (i = 0; i < mtd->writesize; ++i) {
+				if (0xff != *data++) {
+					is_blank = 0;
+					break;
+				}
+			}
+		}
+	}
 
 	if (0 != is_blank)
 		goto report_ecc_errors_ep501g3_end;
@@ -3012,46 +2978,26 @@ report_ecc_errors_ep501g3(struct mtd_info *mtd, struct nand_chip *chip,
 		for (syndrome = 0; syndrome < ((mtd->writesize / 512) * 2);
 		     syndrome += 2, address += 4) {
 			value = READL(chip->IO_ADDR_R + address);
-			syndromes[section][syndrome] =
-				(value & 0x1fff);
+			syndromes[section][syndrome] = (value & 0x1fff);
 			syndromes[section][syndrome + 1] =
-				((value & 0x1fff0000) >> 16);
+			    ((value & 0x1fff0000) >> 16);
 		}
 	}
 
 	/* Debug output (BCH status register and syndromes). */
-#if 0
-	printk("BCH Status Register: 0x%02lx\n", bch_status);
-
-	for (section = 0; section < 8; ++section) {
-		printk("Syndromes, Section %d: ", section);
-
-		for (syndrome = 0; syndrome < 8; ++syndrome) {
-			printk("0x%04lx ", syndromes[section][syndrome]);
-		}
-
-		printk("\n");
-	}
-#endif
 
 	for (i = 0; i < 4; ++i) {
 		if ((1 << i) == (bch_status & (1 << i))) {
 			rc = fix_section(((page * mtd->writesize) + (512 * i)),
-					 (void *)(buffer + (512 * i)),
-					 (int *)&syndromes[i]);
+					 (void *) (buffer + (512 * i)),
+					 (int *) &syndromes[i]);
 
-			if (-1 == rc) {
+			if (-1 == rc)
 				++lsi_nand_statistics.uncorrectable_ecc_errors;
-#if 0
-				printk(KERN_ERR
-				       "Uncorrectable ECC Error: Page %d\n",
-				       page);
-#endif
-			}
 		}
 	}
 
- report_ecc_errors_ep501g3_end:
+report_ecc_errors_ep501g3_end:
 
 	return rc;
 }
@@ -3085,7 +3031,6 @@ report_ecc_errors(struct mtd_info *mtd, struct nand_chip *chip,
 	return rc;
 }
 
-
 /**
  * nand_read_page_hwecc - hardware ecc based page read function
  * @mtd:	mtd info structure
@@ -3100,10 +3045,10 @@ lsi_nand_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
 			 uint8_t *buf, int page)
 {
 	int rc;
-	/*int page = 0;*/
+	/*int page = 0; */
 
 	/* Read the current page number and save it. */
-	/*page = READL(chip->IO_ADDR_R + NAND_INDEX_REG) >> 12;*/
+	/*page = READL(chip->IO_ADDR_R + NAND_INDEX_REG) >> 12; */
 
 	/* read the page */
 	chip->read_buf(mtd, buf, mtd->writesize);
@@ -3133,7 +3078,7 @@ lsi_nand_write_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
 			  const uint8_t *buf)
 {
 	int ecctotal = chip->ecc.total;
-	
+
 	/* write the page data */
 	chip->write_buf(mtd, buf, mtd->writesize);
 
@@ -3188,20 +3133,17 @@ lsi_nand_write_page(struct mtd_info *mtd, struct nand_chip *chip,
 
 		return -EIO;
 	}
-
 #ifdef CONFIG_MTD_NAND_VERIFY_WRITE
 	/* Send command to read back the data */
 	chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
 
-	if (chip->verify_buf(mtd, buf, mtd->writesize)) {
+	if (chip->verify_buf(mtd, buf, mtd->writesize))
 		return -EIO;
-	}
 #endif
 
 	return 0;
 }
 
-
 /**
  * lsi_nand_read_oob_std - [REPLACABLE] the most common OOB data read function
  * @mtd:	mtd info structure
@@ -3288,17 +3230,16 @@ lsi_nand_set_config(struct mtd_info *mtd, struct nand_chip *chip)
 
 	if (LSI_NAND_EP501 == lsi_nand_type) {
 		/* The EP501 only supports 512 and 2k page sizes. */
-		if (512 != mtd->writesize &&
-		    2048 != mtd->writesize)
+		if (512 != mtd->writesize && 2048 != mtd->writesize)
 			return -1;
 
 		while (64 < mbits) {
-			++config; /* 0b000=64Mbit, 0b001=128Mbit, etc. */
+			++config;	/* 0b000=64Mbit, 0b001=128Mbit, etc. */
 			mbits >>= 1;
 		}
 
 		if (512 < mtd->writesize)
-			config |= 0x100; /* large block */
+			config |= 0x100;	/* large block */
 
 		config |= 0x200;	/* not write protected */
 		chip->ecc.layout = &lsi_2k_1bit_ecclayout;
@@ -3307,35 +3248,64 @@ lsi_nand_set_config(struct mtd_info *mtd, struct nand_chip *chip)
 	} else if (LSI_NAND_EP501G1 == lsi_nand_type) {
 		/* The EP501G1 only supports 512, 2k, and 4k page sizes, */
 		if (512 != mtd->writesize &&
-		    2048 != mtd->writesize &&
-		    4096 != mtd->writesize)
+		    2048 != mtd->writesize && 4096 != mtd->writesize)
 			return -1;
 
 		/* and device sizes as follows. */
 		if (512 == mtd->writesize) {
 			switch (mbits) {
-			case 64:                 break;
-			case 128:   config |= 1; break;
-			case 256:   config |= 2; break;
-			case 512:   config |= 3; break;
-			case 1024:  config |= 4; break;
-			case 2048:  config |= 5; break;
-			case 4096:  config |= 6; break;
-			case 8192:  config |= 7; break;
+			case 64:
+				break;
+			case 128:
+				config |= 1;
+				break;
+			case 256:
+				config |= 2;
+				break;
+			case 512:
+				config |= 3;
+				break;
+			case 1024:
+				config |= 4;
+				break;
+			case 2048:
+				config |= 5;
+				break;
+			case 4096:
+				config |= 6;
+				break;
+			case 8192:
+				config |= 7;
+				break;
 			default:
 				return -1;
 				break;
 			}
 		} else {
 			switch (mbits) {
-			case 512:   config |= 3; break;
-			case 1024:  config |= 4; break;
-			case 2048:  config |= 5; break;
-			case 4096:  config |= 6; break;
-			case 8192:  config |= 7; break;
-			case 16384:              break;
-			case 32768: config |= 1; break;
-			case 65536: config |= 2; break;
+			case 512:
+				config |= 3;
+				break;
+			case 1024:
+				config |= 4;
+				break;
+			case 2048:
+				config |= 5;
+				break;
+			case 4096:
+				config |= 6;
+				break;
+			case 8192:
+				config |= 7;
+				break;
+			case 16384:
+				break;
+			case 32768:
+				config |= 1;
+				break;
+			case 65536:
+				config |= 2;
+				break;
 			default:
 				return -1;
 				break;
@@ -3360,40 +3330,55 @@ lsi_nand_set_config(struct mtd_info *mtd, struct nand_chip *chip)
 			break;
 		}
 
-		config |= 1 << 10; /* not write protected */
+		config |= 1 << 10;	/* not write protected */
 
-		config |= 1 << 11; /* 4 bit ECC */
+		config |= 1 << 11;	/* 4 bit ECC */
 
 		if (512 < mtd->writesize)
-			config |= 1 << 12; /* 3 cycle row address */
+			config |= 1 << 12;	/* 3 cycle row address */
 
 		chip->ecc.size = mtd->writesize;
 
 		if (mtd->oobsize == 224) {
-			chip->ecc.bytes = 64;		
-		      chip->ecc.total =  chip->ecc.layout->eccbytes;
-	       } else {
-	       	chip->ecc.bytes = chip->ecc.layout->eccbytes;
-			chip->ecc.total =  mtd->oobsize - chip->ecc.layout->eccbytes;
-		}		
+			chip->ecc.bytes = 64;
+			chip->ecc.total = chip->ecc.layout->eccbytes;
+		} else {
+			chip->ecc.bytes = chip->ecc.layout->eccbytes;
+			chip->ecc.total =
+			    mtd->oobsize - chip->ecc.layout->eccbytes;
+		}
 
 	} else if (LSI_NAND_EP501G3 == lsi_nand_type) {
 		/* The EP501G3 only supports 2k, 4k, and 8k page sizes, */
 		if (2048 != mtd->writesize &&
-		    4096 != mtd->writesize &&
-		    8192 != mtd->writesize)
+		    4096 != mtd->writesize && 8192 != mtd->writesize)
 			return -1;
 
 		/* and device sizes as follows. */
 		switch (mbits) {
-		case 512:   config |= 3; break;
-		case 1024:  config |= 4; break;
-		case 2048:  config |= 5; break;
-		case 4096:  config |= 6; break;
-		case 8192:  config |= 7; break;
-		case 16384:              break;
-		case 32768: config |= 1; break;
-		case 65536: config |= 2; break;
+		case 512:
+			config |= 3;
+			break;
+		case 1024:
+			config |= 4;
+			break;
+		case 2048:
+			config |= 5;
+			break;
+		case 4096:
+			config |= 6;
+			break;
+		case 8192:
+			config |= 7;
+			break;
+		case 16384:
+			break;
+		case 32768:
+			config |= 1;
+			break;
+		case 65536:
+			config |= 2;
+			break;
 		default:
 			printk("Invalid Device Size: 0x%lx\n", mbits);
 			return -1;
@@ -3411,27 +3396,21 @@ lsi_nand_set_config(struct mtd_info *mtd, struct nand_chip *chip)
 			chip->ecc.layout = &lsi_4k_4bit_ecclayout;
 			chip->badblock_pattern = &lsi_4k_4bit_bbt_descr;
 			break;
-#if 0
-		case 8192:
-			config |= 0x3 << 8;
-			chip->ecc.layout = &lsi_8k_4bit_ecclayout;
-			break;
-#endif
 		default:
 			return -1;
 			break;
 		}
 
-		config |= 1 << 10; /* not write protected */
-		config |= 1 << 13; /* 3 cycle row address */
+		config |= 1 << 10;	/* not write protected */
+		config |= 1 << 13;	/* 3 cycle row address */
 
 		/*
-		  2K/4bit  - 32 bytes (8192)
-		  2K/8bit  - 64 bytes (16384)
-		  2K/12bit - 80 bytes (24576)
-		  ...
-		  8K/12bit - 320 bytes (98304)
-		*/
+		   2K/4bit  - 32 bytes (8192)
+		   2K/8bit  - 64 bytes (16384)
+		   2K/12bit - 80 bytes (24576)
+		   ...
+		   8K/12bit - 320 bytes (98304)
+		 */
 
 		if (mtd->oobsize < chip->ecc.layout->eccbytes) {
 			printk(KERN_ERR
@@ -3440,40 +3419,31 @@ lsi_nand_set_config(struct mtd_info *mtd, struct nand_chip *chip)
 			return -1;
 		}
 
-		config |= 1 << 11; /* 4 bit ECC */
+		config |= 1 << 11;	/* 4 bit ECC */
 		mtd->oobavail = mtd->oobsize - chip->ecc.layout->eccbytes;
 		mtd->oobavail -= (mtd->oobavail % 4);
-		if(mtd->oobsize != 224)
- 			config |= (chip->ecc.layout->eccbytes / 4) << 16;
+		if (mtd->oobsize != 224)
+			config |= (chip->ecc.layout->eccbytes / 4) << 16;
 		else
-			config |= ( (mtd->oobsize - chip->ecc.layout->eccbytes) / 4) << 16;
+			config |=
+			    ((mtd->oobsize -
+			      chip->ecc.layout->eccbytes) / 4) << 16;
 		chip->ecc.size = mtd->writesize;
 
 		chip->ecc.bytes = chip->ecc.layout->eccbytes;
-             chip->ecc.total = mtd->oobsize - chip->ecc.bytes;
-#if 0
-		if( mtd->oobsize != 224){
-		       chip->ecc.bytes = chip->ecc.layout->eccbytes;
-		       chip->ecc.total = mtd->oobsize - chip->ecc.bytes;
-		}
-		else{
-			chip->ecc.bytes = 64;
-			chip->ecc.total = chip->ecc.layout->eccbytes;
-		}	 
-#endif 
-		
+		chip->ecc.total = mtd->oobsize - chip->ecc.bytes;
 	} else {
 		return -1;
 	}
 
-	DEBUG_PRINT("write/erase/oob=0x%x/0x%x/0x%x config=0x%lx\n",
-	       mtd->writesize, mtd->erasesize, mtd->oobsize, config); /* ZZZ */
+	DEBUG_PRINT("write/erase/oob=0x%x/0x%x/0x%x config=0x%lx\n", mtd->writesize, mtd->erasesize, mtd->oobsize, config);	/* ZZZ */
 	WRITEL(config, chip->IO_ADDR_W + EP501_NAND_CONFIG_REG);
 
 	return 0;
 }
 
-static uint8_t lsi_nand_read_byte(struct mtd_info *mtd)
+static uint8_t
+lsi_nand_read_byte(struct mtd_info *mtd)
 {
 	struct lsi_nand_private *priv = &lsi_nand_private;
 	struct nand_chip *chip = mtd->priv;
@@ -3487,8 +3457,7 @@ static uint8_t lsi_nand_read_byte(struct mtd_info *mtd)
 
 static int lsi_nand_errstat
 	(struct mtd_info *mtd, struct nand_chip *chip,
-	int state, int status, int page)
-{
+	int state, int status, int page) {
 	/* if erase failed for a block, mark it as bad block */
 	if ((FL_ERASING == chip->state) && (status & NAND_STATUS_FAIL))
 		mtd_block_markbad(mtd, page << chip->page_shift);
@@ -3496,8 +3465,8 @@ static int lsi_nand_errstat
 	return status;
 }
 
-static int lsi_nand_init_size(struct mtd_info *mtd, struct nand_chip *chip,
-			u8 *id_data)
+static int
+lsi_nand_init_size(struct mtd_info *mtd, struct nand_chip *chip, u8 *id_data)
 {
 	int busw, extid;
 
@@ -3506,24 +3475,23 @@ static int lsi_nand_init_size(struct mtd_info *mtd, struct nand_chip *chip,
 	/* The 4th id byte is the important one */
 	extid = readb(chip->IO_ADDR_R + NAND_ID6_REG);
 
-	/* Add workaournd for Micron MT29Fxxxxxx NAND flash*/
+	/* Add workaournd for Micron MT29Fxxxxxx NAND flash */
 	if (id_data[0] == NAND_MFR_MICRON && id_data[1] == 0x48) {
 		/* Calc pagesize */
 		mtd->writesize = 1024 << (extid & 0x03);
 		extid >>= 2;
 		/*Calc oobsize */
-		mtd->oobsize = ((extid & 0x03) == 0x03) ? 218: 224;
+		mtd->oobsize = ((extid & 0x03) == 0x03) ? 218 : 224;
 		extid >>= 3;
 		/* Calc blocksize. Blocksize is multiples of 256KiB */
 		mtd->erasesize = (256 * 1024) << (extid & 0x03);
 		busw = 0;
-	  } else {
+	} else {
 		/* Calc pagesize */
 		mtd->writesize = 1024 << (extid & 0x03);
 		extid >>= 2;
 		/* Calc oobsize */
-		mtd->oobsize = (8 << (extid & 0x01)) *
-			(mtd->writesize >> 9);
+		mtd->oobsize = (8 << (extid & 0x01)) * (mtd->writesize >> 9);
 		extid >>= 2;
 		/* Calc blocksize. Blocksize is multiples of 64KiB */
 		mtd->erasesize = (64 * 1024) << (extid & 0x03);
@@ -3549,7 +3517,7 @@ lsi_nand_init(void)
 	struct device_node *np = NULL;
 	struct mtd_part_parser_data ppdata;
 	static const char *part_probe_types[]
-		= { "cmdlinepart", "ofpart", NULL };
+	= { "cmdlinepart", "ofpart", NULL };
 
 	memset(&ppdata, 0, sizeof(ppdata));
 
@@ -3587,7 +3555,7 @@ lsi_nand_init(void)
 			       nand_address, nand_length,
 			       gpreg_address, gpreg_length);
 			nand_base = (unsigned long)
-				ioremap(nand_address, nand_length);
+			    ioremap(nand_address, nand_length);
 			gpreg_base = ioremap(gpreg_address, gpreg_length);
 		} else {
 			return -1;
@@ -3596,37 +3564,36 @@ lsi_nand_init(void)
 		ppdata.of_node = np;
 	} else {
 		printk("ACP NAND: Using Static Addresses.\n");
-		nand_base = (unsigned long)ioremap(0x002000440000ULL, 0x20000);
+		nand_base = (unsigned long) ioremap(0x002000440000ULL, 0x20000);
 		gpreg_base = ioremap(0x00200040c000ULL, 0x1000);
 	}
 
 	/*
-	  Determine the version of the controller.
+	   Determine the version of the controller.
 
-	  As there is not version register, see if bits 5:3 of the
-	  configuration register are writable.  There are in the EP501
-	  case and aren't in the EP501G1 case.
-	*/
+	   As there is not version register, see if bits 5:3 of the
+	   configuration register are writable.  There are in the EP501
+	   case and aren't in the EP501G1 case.
+	 */
 
 	{
 		unsigned long cr;
 		unsigned long cr_save;
-		
-		cr = cr_save = READL((void *)(nand_base + NAND_CONFIG_REG));
+
+		cr = cr_save = READL((void *) (nand_base + NAND_CONFIG_REG));
 		cr = 0x2038;
-		WRITEL(cr, (void *)(nand_base + EP501_NAND_CONFIG_REG));
-		cr = READL((void *)nand_base + EP501_NAND_CONFIG_REG);
-		WRITEL(cr_save, (void *)(nand_base + EP501_NAND_CONFIG_REG));
+		WRITEL(cr, (void *) (nand_base + EP501_NAND_CONFIG_REG));
+		cr = READL((void *) nand_base + EP501_NAND_CONFIG_REG);
+		WRITEL(cr_save, (void *) (nand_base + EP501_NAND_CONFIG_REG));
 
-		if (0 == (cr & 0x2038)) {
+		if (0 == (cr & 0x2038))
 			lsi_nand_type = LSI_NAND_EP501G1;
-		} else if (0x38 == (cr & 0x2038)) {
+		else if (0x38 == (cr & 0x2038))
 			lsi_nand_type = LSI_NAND_EP501;
-		} else if (0x2000 == (cr & 0x2038)) {
+		else if (0x2000 == (cr & 0x2038))
 			lsi_nand_type = LSI_NAND_EP501G3;
-		} else {
+		else
 			lsi_nand_type = LSI_NAND_NONE;
-		}
 	}
 
 	switch (lsi_nand_type) {
@@ -3695,16 +3662,16 @@ lsi_nand_init(void)
 	WRITEL(0x0, lsi_nand_chip.IO_ADDR_W + NAND_INTR_EN_REG);
 
 	/*
-	  ======================================================================
-	  Timing Control
+	   =======================================================
+	   Timing Control
 
-	  This may need to be changed, based on the devices used.  Each field is
-	  described below.
-	*/
+	   This may need to be changed, based on the devices used.
+	   Each field is described below.
+	 */
 
 	/*
-	  TCR0 - NAND Timing Control Register 0
-	*/
+	   TCR0 - NAND Timing Control Register 0
+	 */
 
 	{
 		nand_timing_control_register_0_t tcr0;
@@ -3721,13 +3688,12 @@ lsi_nand_init(void)
 		/* TS [7:0] - Setup Time for CLE, CE & ALE */
 		tcr0.bits.ts = 0x05;
 
-		WRITEL(tcr0.raw,
-		       (lsi_nand_chip.IO_ADDR_W + NAND_TIMING1_REG));
+		WRITEL(tcr0.raw, (lsi_nand_chip.IO_ADDR_W + NAND_TIMING1_REG));
 	}
 
 	/*
-	  TCR1 - NAND Timing Control Register 1
-	*/
+	   TCR1 - NAND Timing Control Register 1
+	 */
 
 	{
 		nand_timing_control_register_1_t tcr1;
@@ -3744,13 +3710,12 @@ lsi_nand_init(void)
 		/* TWH [7:0] - Write Pulse High Time */
 		tcr1.bits.twh = 0x03;
 
-		WRITEL(tcr1.raw,
-		       (lsi_nand_chip.IO_ADDR_W + NAND_TIMING2_REG));
+		WRITEL(tcr1.raw, (lsi_nand_chip.IO_ADDR_W + NAND_TIMING2_REG));
 	}
 
 	/*
-	  TCR2 - NAND Timing Control Register 2 (EP501G3 Only)
-	*/
+	   TCR2 - NAND Timing Control Register 2 (EP501G3 Only)
+	 */
 
 	{
 		nand_timing_control_register_2_t tcr2;
@@ -3771,15 +3736,16 @@ lsi_nand_init(void)
 
 	/* Register the partitions */
 	mtd_device_parse_register(&lsi_nand_mtd, part_probe_types, &ppdata,
-					NULL, 0);
+				  NULL, 0);
 
 	/* Clear the statistics. */
-	memset((void *)&lsi_nand_statistics, 0, sizeof(lsi_nand_statistics_t));
+	memset((void *) &lsi_nand_statistics, 0,
+	       sizeof(lsi_nand_statistics_t));
 
 	/* Create /proc entry. */
 	create_proc_read_entry("driver/lsinand",
 			       0, NULL, lsi_nand_read_proc,
-			       (void *)&lsi_nand_mtd);
+			       (void *) &lsi_nand_mtd);
 
 	/* Return happy */
 	return 0;
-- 
1.7.9.7

