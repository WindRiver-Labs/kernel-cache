From 5b0fc8d2c40b28642bcb0a632beb377ce2f5db50 Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Thu, 31 Jan 2013 16:10:54 +0800
Subject: [PATCH 12/16] LSI:ACP34xx:Move ncr driver to arch/powerpc/sysdev

Move acp34xx's ncr driver to arch/powerpc/sysdev:
drivers/lsi/acp/ncr.h -> arch/powerpc/include/asm/lsi/acp_ncr.h
drivers/lsi/acp/ncr.c -> arch/powerpc/sysdev/lsi_acp_ncr.c

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 arch/powerpc/include/asm/lsi/acp_ncr.h |   42 +++++
 arch/powerpc/sysdev/Makefile           |    2 +
 arch/powerpc/sysdev/lsi_acp_ncr.c      |  299 ++++++++++++++++++++++++++++++++
 arch/powerpc/sysdev/ppc4xx_pci.c       |    2 +-
 drivers/lsi/acp/Makefile               |    1 -
 drivers/lsi/acp/clocks.c               |    2 +-
 drivers/lsi/acp/ncr.c                  |  299 --------------------------------
 drivers/lsi/acp/ncr.h                  |   42 -----
 drivers/lsi/acp/net.c                  |    2 +-
 drivers/lsi/acp/serial.c               |    2 +-
 drivers/lsi/acp/wrappers.c             |    2 +-
 11 files changed, 348 insertions(+), 347 deletions(-)
 create mode 100644 arch/powerpc/include/asm/lsi/acp_ncr.h
 create mode 100644 arch/powerpc/sysdev/lsi_acp_ncr.c
 delete mode 100644 drivers/lsi/acp/ncr.c
 delete mode 100644 drivers/lsi/acp/ncr.h

diff --git a/arch/powerpc/include/asm/lsi/acp_ncr.h b/arch/powerpc/include/asm/lsi/acp_ncr.h
new file mode 100644
index 0000000..a7399e7
--- /dev/null
+++ b/arch/powerpc/include/asm/lsi/acp_ncr.h
@@ -0,0 +1,42 @@
+/*
+ * asm/lsi/acp_ncr.h
+ *
+ * Copyright (C) 2010 LSI
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307	 USA
+ */
+
+#ifndef __DRIVERS_LSI_ACP_NCR_H
+#define __DRIVERS_LSI_ACP_NCR_H
+
+#ifndef NCP_REGION_ID
+#define NCP_REGION_ID(node, target) \
+(unsigned long)((((node) & 0xffff) << 16) | ((target) & 0xffff))
+#endif
+
+#ifndef NCP_NODE_ID
+#define NCP_NODE_ID(region) (((region) >> 16) & 0xffff)
+#endif
+
+#ifndef NCP_TARGET_ID
+#define NCP_TARGET_ID(region) ((region) & 0xffff)
+#endif
+
+int ncr_read(unsigned long, unsigned long, int, void *);
+int ncr_write(unsigned long, unsigned long, int, void *);
+
+int is_asic(void);
+
+#endif /*  __DRIVERS_LSI_ACP_NCR_H */
diff --git a/arch/powerpc/sysdev/Makefile b/arch/powerpc/sysdev/Makefile
index 1bd7ecb..bdfe5d3 100644
--- a/arch/powerpc/sysdev/Makefile
+++ b/arch/powerpc/sysdev/Makefile
@@ -69,3 +69,5 @@ subdir-ccflags-$(CONFIG_PPC_WERROR) := -Werror
 obj-$(CONFIG_PPC_XICS)		+= xics/
 
 obj-$(CONFIG_GE_FPGA)		+= ge/
+
+obj-$(CONFIG_ACP)			+= lsi_acp_ncr.o
diff --git a/arch/powerpc/sysdev/lsi_acp_ncr.c b/arch/powerpc/sysdev/lsi_acp_ncr.c
new file mode 100644
index 0000000..c835695
--- /dev/null
+++ b/arch/powerpc/sysdev/lsi_acp_ncr.c
@@ -0,0 +1,299 @@
+/*
+ *  Copyright (C) 2009 LSI Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/io.h>
+#include <linux/module.h>
+
+#include <asm/lsi/acp_ncr.h>
+
+static void *nca_reg;
+
+#define NCA  nca_reg
+
+typedef union {
+	unsigned long raw;
+	struct {
+		unsigned long start_done:1;
+		unsigned long unused:6;
+		unsigned long local_bit:1;
+		unsigned long status:2;
+		unsigned long byte_swap_enable:1;
+		unsigned long cfg_cmpl_int_enable:1;
+		unsigned long cmd_type:4;
+		unsigned long dbs:16;
+	} __packed bits;
+} __packed command_data_register_0_t;
+
+typedef union {
+	unsigned long raw;
+	struct {
+		unsigned long target_address:32;
+	} __packed bits;
+} __packed command_data_register_1_t;
+
+typedef union {
+	unsigned long raw;
+	struct {
+		unsigned long unused:16;
+		unsigned long target_node_id:8;
+		unsigned long target_id_address_upper:8;
+	} __packed bits;
+} __packed command_data_register_2_t;
+
+/*
+  ----------------------------------------------------------------------
+  ncr_register_read
+*/
+
+static inline unsigned long
+ncr_register_read(unsigned *address)
+{
+	unsigned long value;
+
+	value = in_be32(address);
+
+	return value;
+}
+
+/*
+  ----------------------------------------------------------------------
+  ncr_register_write
+*/
+
+static inline void
+ncr_register_write(const unsigned value, unsigned *address)
+{
+	out_be32(address, value);
+}
+
+/*
+  ======================================================================
+  ======================================================================
+  Public Interface
+  ======================================================================
+  ======================================================================
+*/
+
+/*
+  ----------------------------------------------------------------------
+  ncr_read
+*/
+
+int
+ncr_read(unsigned long region, unsigned long address, int number, void *buffer)
+{
+	command_data_register_0_t cdr0;
+	command_data_register_1_t cdr1;
+	command_data_register_2_t cdr2;
+
+	/*
+	  Set up the read command.
+	*/
+
+	cdr2.raw = 0;
+	cdr2.bits.target_node_id = NCP_NODE_ID(region);
+	cdr2.bits.target_id_address_upper = NCP_TARGET_ID(region);
+	ncr_register_write(cdr2.raw, (unsigned *) (NCA + 0xf8));
+
+	cdr1.raw = 0;
+	cdr1.bits.target_address = (address >> 2);
+	ncr_register_write(cdr1.raw, (unsigned *) (NCA + 0xf4));
+
+	cdr0.raw = 0;
+	cdr0.bits.start_done = 1;
+
+	if (0xff == cdr2.bits.target_id_address_upper)
+		cdr0.bits.local_bit = 1;
+
+	cdr0.bits.cmd_type = 4;
+	/* TODO: Verify number... */
+	cdr0.bits.dbs = (number - 1);
+	ncr_register_write(cdr0.raw, (unsigned *) (NCA + 0xf0));
+	mb();
+
+	/*
+	  Wait for completion.
+	*/
+
+	/* TODO: Handle failure cases. */
+	{
+		volatile unsigned long value;
+
+		do {
+			value = ncr_register_read((unsigned *) (NCA + 0xf0));
+		} while (0x80000000 == (value & 0x80000000));
+	}
+
+	/*
+	  Copy data words to the buffer.
+	*/
+
+	address = (unsigned long)(NCA + 0x1000);
+	while (4 <= number) {
+		*((unsigned long *) buffer) =
+			ncr_register_read((unsigned *) address);
+		address += 4;
+		number -= 4;
+	}
+
+	if (0 < number) {
+		unsigned long temp = ncr_register_read((unsigned *) address);
+		memcpy((void *) buffer, &temp, number);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(ncr_read);
+/*
+  ------------------------------------------------------------------------------
+  is_asic
+*/
+
+int
+is_asic(void)
+{
+#ifdef CONFIG_ACPISS
+	return 0;
+#else
+	unsigned long nca_config;
+
+	if (0 == ncr_read(NCP_REGION_ID(0x16, 0xff), 0x10, 4, &nca_config))
+		return (0 == (nca_config & 0x80000000));
+
+	return -1;
+#endif
+}
+EXPORT_SYMBOL(is_asic);
+
+/*
+  ----------------------------------------------------------------------
+  ncr_write
+*/
+
+int
+ncr_write(unsigned long region, unsigned long address, int number, void *buffer)
+{
+	command_data_register_0_t cdr0;
+	command_data_register_1_t cdr1;
+	command_data_register_2_t cdr2;
+	unsigned long data_word_base;
+	int dbs = (number - 1);
+
+	/*
+	  Set up the write.
+	*/
+
+	cdr2.raw = 0;
+	cdr2.bits.target_node_id = NCP_NODE_ID(region);
+	cdr2.bits.target_id_address_upper = NCP_TARGET_ID(region);
+	ncr_register_write(cdr2.raw, (unsigned *) (NCA + 0xf8));
+
+	cdr1.raw = 0;
+	cdr1.bits.target_address = (address >> 2);
+	ncr_register_write(cdr1.raw, (unsigned *) (NCA + 0xf4));
+
+	/*
+	  Copy from buffer to the data words.
+	*/
+
+	data_word_base = (unsigned long)(NCA + 0x1000);
+
+	while (4 <= number) {
+		ncr_register_write(*((unsigned long *) buffer),
+				   (unsigned *) data_word_base);
+		data_word_base += 4;
+		buffer += 4;
+		number -= 4;
+	}
+
+	if (0 < number) {
+		unsigned long temp = 0;
+
+		memcpy((void *) &temp, (void *) buffer, number);
+		ncr_register_write(temp, (unsigned *) data_word_base);
+		data_word_base += number;
+		buffer += number;
+		number = 0;
+	}
+
+	cdr0.raw = 0;
+	cdr0.bits.start_done = 1;
+
+	if (0xff == cdr2.bits.target_id_address_upper)
+		cdr0.bits.local_bit = 1;
+
+	cdr0.bits.cmd_type = 5;
+	/* TODO: Verify number... */
+	cdr0.bits.dbs = dbs;
+	ncr_register_write(cdr0.raw, (unsigned *) (NCA + 0xf0));
+	mb();
+
+	/*
+	  Wait for completion.
+	*/
+
+	/* TODO: Handle failure cases. */
+	while (0x80000000 ==
+		(ncr_register_read((unsigned *) (NCA + 0xf0)) & 0x80000000))
+		;
+
+	return 0;
+}
+EXPORT_SYMBOL(ncr_write);
+
+/*
+  ----------------------------------------------------------------------
+  ncr_init
+*/
+
+int
+ncr_init(void)
+{
+	/* We need this to be a module so that the functions can be exported
+	 * as module symbols.
+	 */
+	nca_reg = ioremap(0x2000520000ull, 0x2000);
+	if (!nca_reg) {
+		pr_err("Can't iomap for nca registers\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+postcore_initcall(ncr_init);
+
+/*
+  ----------------------------------------------------------------------
+  ncr_exit
+*/
+
+void __exit
+ncr_exit(void)
+{
+	iounmap(nca_reg);
+}
+
+module_exit(ncr_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Register Ring access for LSI's ACP board");
diff --git a/arch/powerpc/sysdev/ppc4xx_pci.c b/arch/powerpc/sysdev/ppc4xx_pci.c
index a401ec5..e8e75c1 100644
--- a/arch/powerpc/sysdev/ppc4xx_pci.c
+++ b/arch/powerpc/sysdev/ppc4xx_pci.c
@@ -36,7 +36,7 @@
 #include "ppc4xx_pci.h"
 #ifdef CONFIG_ACP
 #include <linux/interrupt.h>
-#include "../../../drivers/lsi/acp/ncr.h"
+#include <asm/lsi/acp_ncr.h>
 static int acp_plx;
 #endif
 
diff --git a/drivers/lsi/acp/Makefile b/drivers/lsi/acp/Makefile
index 176c138..63aaf9d 100644
--- a/drivers/lsi/acp/Makefile
+++ b/drivers/lsi/acp/Makefile
@@ -1,5 +1,4 @@
 # Makefile for LSI drivers
-obj-$(CONFIG_ACP)			+= ncr.o
 obj-$(CONFIG_ACP)			+= clocks.o
 obj-$(CONFIG_LSI_NAND)			+= lsi_nand.o
 obj-$(CONFIG_LSI_UBOOTENV)		+= ubootenv.o
diff --git a/drivers/lsi/acp/clocks.c b/drivers/lsi/acp/clocks.c
index bf9fda0..0f9a1d6 100644
--- a/drivers/lsi/acp/clocks.c
+++ b/drivers/lsi/acp/clocks.c
@@ -25,7 +25,7 @@
 
 #define CLK_REF0 125000000
 
-#include "ncr.h"
+#include <asm/lsi/acp_ncr.h>
 
 /*
   Private Interface
diff --git a/drivers/lsi/acp/ncr.c b/drivers/lsi/acp/ncr.c
deleted file mode 100644
index b65e670..0000000
--- a/drivers/lsi/acp/ncr.c
+++ /dev/null
@@ -1,299 +0,0 @@
-/*
- *  Copyright (C) 2009 LSI Corporation
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <linux/io.h>
-#include <linux/module.h>
-
-#include "ncr.h"
-
-static void *nca_reg;
-
-#define NCA  nca_reg
-
-typedef union {
-	unsigned long raw;
-	struct {
-		unsigned long start_done:1;
-		unsigned long unused:6;
-		unsigned long local_bit:1;
-		unsigned long status:2;
-		unsigned long byte_swap_enable:1;
-		unsigned long cfg_cmpl_int_enable:1;
-		unsigned long cmd_type:4;
-		unsigned long dbs:16;
-	} __packed bits;
-} __packed command_data_register_0_t;
-
-typedef union {
-	unsigned long raw;
-	struct {
-		unsigned long target_address:32;
-	} __packed bits;
-} __packed command_data_register_1_t;
-
-typedef union {
-	unsigned long raw;
-	struct {
-		unsigned long unused:16;
-		unsigned long target_node_id:8;
-		unsigned long target_id_address_upper:8;
-	} __packed bits;
-} __packed command_data_register_2_t;
-
-/*
-  ----------------------------------------------------------------------
-  ncr_register_read
-*/
-
-static inline unsigned long
-ncr_register_read(unsigned *address)
-{
-	unsigned long value;
-
-	value = in_be32(address);
-
-	return value;
-}
-
-/*
-  ----------------------------------------------------------------------
-  ncr_register_write
-*/
-
-static inline void
-ncr_register_write(const unsigned value, unsigned *address)
-{
-	out_be32(address, value);
-}
-
-/*
-  ======================================================================
-  ======================================================================
-  Public Interface
-  ======================================================================
-  ======================================================================
-*/
-
-/*
-  ----------------------------------------------------------------------
-  ncr_read
-*/
-
-int
-ncr_read(unsigned long region, unsigned long address, int number, void *buffer)
-{
-	command_data_register_0_t cdr0;
-	command_data_register_1_t cdr1;
-	command_data_register_2_t cdr2;
-
-	/*
-	  Set up the read command.
-	*/
-
-	cdr2.raw = 0;
-	cdr2.bits.target_node_id = NCP_NODE_ID(region);
-	cdr2.bits.target_id_address_upper = NCP_TARGET_ID(region);
-	ncr_register_write(cdr2.raw, (unsigned *) (NCA + 0xf8));
-
-	cdr1.raw = 0;
-	cdr1.bits.target_address = (address >> 2);
-	ncr_register_write(cdr1.raw, (unsigned *) (NCA + 0xf4));
-
-	cdr0.raw = 0;
-	cdr0.bits.start_done = 1;
-
-	if (0xff == cdr2.bits.target_id_address_upper)
-		cdr0.bits.local_bit = 1;
-
-	cdr0.bits.cmd_type = 4;
-	/* TODO: Verify number... */
-	cdr0.bits.dbs = (number - 1);
-	ncr_register_write(cdr0.raw, (unsigned *) (NCA + 0xf0));
-	mb();
-
-	/*
-	  Wait for completion.
-	*/
-
-	/* TODO: Handle failure cases. */
-	{
-		volatile unsigned long value;
-
-		do {
-			value = ncr_register_read((unsigned *) (NCA + 0xf0));
-		} while (0x80000000 == (value & 0x80000000));
-	}
-
-	/*
-	  Copy data words to the buffer.
-	*/
-
-	address = (unsigned long)(NCA + 0x1000);
-	while (4 <= number) {
-		*((unsigned long *) buffer) =
-			ncr_register_read((unsigned *) address);
-		address += 4;
-		number -= 4;
-	}
-
-	if (0 < number) {
-		unsigned long temp = ncr_register_read((unsigned *) address);
-		memcpy((void *) buffer, &temp, number);
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL(ncr_read);
-/*
-  ------------------------------------------------------------------------------
-  is_asic
-*/
-
-int
-is_asic(void)
-{
-#ifdef CONFIG_ACPISS
-	return 0;
-#else
-	unsigned long nca_config;
-
-	if (0 == ncr_read(NCP_REGION_ID(0x16, 0xff), 0x10, 4, &nca_config))
-		return (0 == (nca_config & 0x80000000));
-
-	return -1;
-#endif
-}
-EXPORT_SYMBOL(is_asic);
-
-/*
-  ----------------------------------------------------------------------
-  ncr_write
-*/
-
-int
-ncr_write(unsigned long region, unsigned long address, int number, void *buffer)
-{
-	command_data_register_0_t cdr0;
-	command_data_register_1_t cdr1;
-	command_data_register_2_t cdr2;
-	unsigned long data_word_base;
-	int dbs = (number - 1);
-
-	/*
-	  Set up the write.
-	*/
-
-	cdr2.raw = 0;
-	cdr2.bits.target_node_id = NCP_NODE_ID(region);
-	cdr2.bits.target_id_address_upper = NCP_TARGET_ID(region);
-	ncr_register_write(cdr2.raw, (unsigned *) (NCA + 0xf8));
-
-	cdr1.raw = 0;
-	cdr1.bits.target_address = (address >> 2);
-	ncr_register_write(cdr1.raw, (unsigned *) (NCA + 0xf4));
-
-	/*
-	  Copy from buffer to the data words.
-	*/
-
-	data_word_base = (unsigned long)(NCA + 0x1000);
-
-	while (4 <= number) {
-		ncr_register_write(*((unsigned long *) buffer),
-				   (unsigned *) data_word_base);
-		data_word_base += 4;
-		buffer += 4;
-		number -= 4;
-	}
-
-	if (0 < number) {
-		unsigned long temp = 0;
-
-		memcpy((void *) &temp, (void *) buffer, number);
-		ncr_register_write(temp, (unsigned *) data_word_base);
-		data_word_base += number;
-		buffer += number;
-		number = 0;
-	}
-
-	cdr0.raw = 0;
-	cdr0.bits.start_done = 1;
-
-	if (0xff == cdr2.bits.target_id_address_upper)
-		cdr0.bits.local_bit = 1;
-
-	cdr0.bits.cmd_type = 5;
-	/* TODO: Verify number... */
-	cdr0.bits.dbs = dbs;
-	ncr_register_write(cdr0.raw, (unsigned *) (NCA + 0xf0));
-	mb();
-
-	/*
-	  Wait for completion.
-	*/
-
-	/* TODO: Handle failure cases. */
-	while (0x80000000 ==
-		(ncr_register_read((unsigned *) (NCA + 0xf0)) & 0x80000000))
-		;
-
-	return 0;
-}
-EXPORT_SYMBOL(ncr_write);
-
-/*
-  ----------------------------------------------------------------------
-  ncr_init
-*/
-
-int
-ncr_init(void)
-{
-	/* We need this to be a module so that the functions can be exported
-	 * as module symbols.
-	 */
-	nca_reg = ioremap(0x2000520000ull, 0x2000);
-	if (!nca_reg) {
-		pr_err("Can't iomap for nca registers\n");
-		return -1;
-	}
-
-	return 0;
-}
-
-postcore_initcall(ncr_init);
-
-/*
-  ----------------------------------------------------------------------
-  ncr_exit
-*/
-
-void __exit
-ncr_exit(void)
-{
-	iounmap(nca_reg);
-}
-
-module_exit(ncr_exit);
-
-MODULE_LICENSE("GPL");
-MODULE_DESCRIPTION("Register Ring access for LSI's ACP board");
diff --git a/drivers/lsi/acp/ncr.h b/drivers/lsi/acp/ncr.h
deleted file mode 100644
index fe468f9..0000000
--- a/drivers/lsi/acp/ncr.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * drivers/lsi/common/ncr.h
- *
- * Copyright (C) 2010 LSI
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307	 USA
- */
-
-#ifndef __DRIVERS_LSI_ACP_NCR_H
-#define __DRIVERS_LSI_ACP_NCR_H
-
-#ifndef NCP_REGION_ID
-#define NCP_REGION_ID(node, target) \
-(unsigned long)((((node) & 0xffff) << 16) | ((target) & 0xffff))
-#endif
-
-#ifndef NCP_NODE_ID
-#define NCP_NODE_ID(region) (((region) >> 16) & 0xffff)
-#endif
-
-#ifndef NCP_TARGET_ID
-#define NCP_TARGET_ID(region) ((region) & 0xffff)
-#endif
-
-int ncr_read(unsigned long, unsigned long, int, void *);
-int ncr_write(unsigned long, unsigned long, int, void *);
-
-int is_asic(void);
-
-#endif /*  __DRIVERS_LSI_ACP_NCR_H */
diff --git a/drivers/lsi/acp/net.c b/drivers/lsi/acp/net.c
index 05fe597..31e9da8 100644
--- a/drivers/lsi/acp/net.c
+++ b/drivers/lsi/acp/net.c
@@ -43,7 +43,7 @@
 #include <linux/io.h>
 #include <asm/dma.h>
 
-#include "ncr.h"
+#include <asm/lsi/acp_ncr.h>
 
 extern int acp_mdio_read(unsigned long, unsigned long, unsigned short *);
 extern int acp_mdio_write(unsigned long, unsigned long, unsigned short);
diff --git a/drivers/lsi/acp/serial.c b/drivers/lsi/acp/serial.c
index 1864ef0..6c18efb 100644
--- a/drivers/lsi/acp/serial.c
+++ b/drivers/lsi/acp/serial.c
@@ -52,7 +52,7 @@
 #include <linux/of.h>
 #include <linux/io.h>
 
-#include "ncr.h"
+#include <asm/lsi/acp_ncr.h>
 
 extern int acp_clock_get(int, unsigned long *);
 
diff --git a/drivers/lsi/acp/wrappers.c b/drivers/lsi/acp/wrappers.c
index 04bb3c0..e144f8e 100644
--- a/drivers/lsi/acp/wrappers.c
+++ b/drivers/lsi/acp/wrappers.c
@@ -23,7 +23,7 @@
 #include <asm/irq.h>
 #include <linux/io.h>
 
-#include "ncr.h"
+#include <asm/lsi/acp_ncr.h>
 extern int acp_clock_get(int, unsigned long *);
 
 /*
-- 
1.7.9.7

