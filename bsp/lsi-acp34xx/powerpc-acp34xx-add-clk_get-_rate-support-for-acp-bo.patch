From fc5e944d857259f85b2cb36e920321491a15c45f Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Tue, 5 Jun 2012 14:43:30 +0800
Subject: [PATCH 2/9] powerpc/acp34xx: add clk_get/_rate support for acp board

Some drivers used by acp34xx depend on the clk_get/_rate methods
to get the device frequency. So implement these methods by checking
the "clock-frequency" property in the device node.

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 arch/powerpc/platforms/44x/acpclock.c |   69 ++++++++++++++++++++++++++++++++-
 1 file changed, 67 insertions(+), 2 deletions(-)

diff --git a/arch/powerpc/platforms/44x/acpclock.c b/arch/powerpc/platforms/44x/acpclock.c
index 8ea00c5..dcb97a4 100644
--- a/arch/powerpc/platforms/44x/acpclock.c
+++ b/arch/powerpc/platforms/44x/acpclock.c
@@ -15,15 +15,67 @@
 #include <linux/clk.h>
 #include <linux/io.h>
 #include <linux/export.h>
+#include <linux/list.h>
+#include <linux/mutex.h>
+#include <linux/kref.h>
+#include <linux/slab.h>
+#include <linux/of.h>
 #include <asm/clk_interface.h>
 
+struct clk {
+	struct list_head node;
+	struct device *dev;
+	struct kref kref;
+};
+
+static LIST_HEAD(clocks);
+static DEFINE_MUTEX(clocks_mutex);
+
 struct clk *acp_clk_get(struct device *dev, const char *id)
 {
-	return NULL;
+	struct clk *clk;
+
+	if (!dev)
+		return NULL;
+
+	mutex_lock(&clocks_mutex);
+	list_for_each_entry(clk, &clocks, node) {
+		if (clk->dev == dev) {
+			kref_get(&clk->kref);
+			mutex_unlock(&clocks_mutex);
+			return clk;
+		}
+	}
+
+	clk = kzalloc(sizeof(*clk), GFP_KERNEL);
+	if (!clk) {
+		dev_err(dev, "Create clock error\n");
+		return ERR_PTR(-ENOMEM);
+	}
+
+	INIT_LIST_HEAD(&clk->node);
+	kref_init(&clk->kref);
+	clk->dev = dev;
+	list_add(&clk->node, &clocks);
+	mutex_unlock(&clocks_mutex);
+
+	return clk;
+}
+
+static void acp_clk_release(struct kref *kref)
+{
+	struct clk *clk = container_of(kref, struct clk, kref);
+
+	mutex_lock(&clocks_mutex);
+	list_del(&clk->node);
+	mutex_lock(&clocks_mutex);
+
+	kfree(clk);
 }
 
 void acp_clk_put(struct clk *clk)
 {
+	kref_put(&clk->kref, acp_clk_release);
 	return;
 }
 
@@ -39,7 +91,20 @@ void acp_clk_disable(struct clk *clk)
 
 unsigned long acp_clk_get_rate(struct clk *clk)
 {
-	return 0;
+	struct device_node *np = clk->dev->of_node;
+	const int *prop;
+	int len;
+
+	if (!np)
+		return 0;
+
+	prop = of_get_property(np, "clock-frequency", &len);
+	if (!prop || len != sizeof(*prop)) {
+		dev_err(clk->dev, "Get the clock frequency error\n");
+		return -1;
+	}
+
+	return *prop;
 }
 
 long acp_clk_round_rate(struct clk *clk, unsigned long rate)
-- 
1.7.9.7

