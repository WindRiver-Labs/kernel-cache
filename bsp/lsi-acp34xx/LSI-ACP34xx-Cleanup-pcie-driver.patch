From 6bedd15242f7173746a802921eedd299462fc37d Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Thu, 31 Jan 2013 10:17:48 +0800
Subject: [PATCH 10/16] LSI:ACP34xx:Cleanup pcie driver

Cleanup acp34xx's pcie driver with following modification:
1.Fix trailing space error.
2.Fix code indent issues.
3.Remove dead code.

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 arch/powerpc/sysdev/ppc4xx_pci.c |  169 ++++++++++++++++----------------------
 1 file changed, 69 insertions(+), 100 deletions(-)

diff --git a/arch/powerpc/sysdev/ppc4xx_pci.c b/arch/powerpc/sysdev/ppc4xx_pci.c
index 278144e..a401ec5 100644
--- a/arch/powerpc/sysdev/ppc4xx_pci.c
+++ b/arch/powerpc/sysdev/ppc4xx_pci.c
@@ -107,7 +107,7 @@ fixup_acp_pci_bridge(struct pci_dev *dev)
 		return ;
 
 	/*
-	 * Set the class appropriately for a bridge device 
+	 * Set the class appropriately for a bridge device
 	 */
 	printk(KERN_INFO "PCI: Setting PCI Class to PCI_CLASS_BRIDGE_HOST for %04x:%04x\n", dev->vendor, dev->device);
 
@@ -115,7 +115,7 @@ fixup_acp_pci_bridge(struct pci_dev *dev)
 	dev->class = PCI_CLASS_BRIDGE_HOST << 8;
 
 	/*
-	 * Make the bridge transparent 
+	 * Make the bridge transparent
 	 */
 	dev->transparent = 1;
 
@@ -1678,15 +1678,15 @@ static void __iomem *ppc4xx_pciex_get_config_base(struct ppc4xx_pciex_port *port
 #ifndef CONFIG_ACP
 	return (void __iomem *)port->hose->cfg_data +
 		((relbus  << 20) | (devfn << 12));
-#else 
-    
+#else
+
     {
         unsigned mpage;
         u32 addr;
         int dev, fn;
         int cfg_type;
 
-        /* 
+        /*
          * Set MPAGE0 to map config access for this BDF
          */
 
@@ -1702,7 +1702,7 @@ static void __iomem *ppc4xx_pciex_get_config_base(struct ppc4xx_pciex_port *port
         if (fn) {
             return NULL;
         }
-#else 
+#else
         /* v2 only supports fn0-3 and bus0-63 */
         if (port->acpChipType == 1) {
             if ((fn > 3) || (bus->number > 63)) {
@@ -1718,8 +1718,8 @@ static void __iomem *ppc4xx_pciex_get_config_base(struct ppc4xx_pciex_port *port
         }
 
         /* build the mpage register */
-        mpage = (bus->number << 11) | 
-                (dev << 6) | 
+        mpage = (bus->number << 11) |
+                (dev << 6) |
 		(cfg_type << 5 );
 
 	mpage |= 0x10;   /* enable MPAGE for configuration access */
@@ -1736,8 +1736,7 @@ static void __iomem *ppc4xx_pciex_get_config_base(struct ppc4xx_pciex_port *port
 
 
         if (mpage != last_mpage) {
-	  /* printk("%02x:%02x:%02x setting mpage = 0x%08x\n", bus->number, dev, fn, mpage); */
-            addr = ((u32) port->hose->cfg_addr) + ACPX1_PCIE_MPAGE_LOWER(7); 
+            addr = ((u32) port->hose->cfg_addr) + ACPX1_PCIE_MPAGE_LOWER(7);
             out_le32((u32 *) addr, mpage);
             last_mpage = mpage;
         }
@@ -1884,9 +1883,9 @@ ppc4xx_pciex_acp_read_config(struct pci_bus *bus, unsigned int devfn,
 	mtmsr( mfmsr() & ~(MSR_ME));
 	__asm__ __volatile__("msync");
 
-	/* 
+	/*
 	 * addressing is different for local config access vs.
-	 * access through the mapped config space. 
+	 * access through the mapped config space.
 	 */
 	if (bus->number == port->hose->first_busno) {
 		int wo = offset & 0xfffffffc;
@@ -1894,34 +1893,34 @@ ppc4xx_pciex_acp_read_config(struct pci_bus *bus, unsigned int devfn,
 
 	} else {
 
-		/* 
-		 * mapped config space only supports 32-bit access 
+		/*
+		 * mapped config space only supports 32-bit access
 		 *
 		 *  AXI address [3:0] is not used at all.
 		 *  AXI address[9:4] becomes register number.
 		 *  AXI address[13:10] becomes Ext. register number
-		 *  AXI address[17:14] becomes 1st DWBE for configuration read only. 
+		 *  AXI address[17:14] becomes 1st DWBE for configuration read only.
 		 *  AXI address[29:27] is used to select one of 8 Mpage registers.
 		 */
 
 		bus_addr = (u32) addr + (offset << 2);
-        
+
 		switch (len) {
 		case 1:
-			bus_addr |=  ((1 << bo) ) << 14; 
+			bus_addr |=  ((1 << bo) ) << 14;
 			break;
 		case 2:
-			bus_addr |=  ((3 << bo) ) << 14; 
+			bus_addr |=  ((3 << bo) ) << 14;
 			break;
 		default:
-			bus_addr |=  ( 0xf ) << 14; 
+			bus_addr |=  ( 0xf ) << 14;
 			break;
 		}
 
 	}
 
-	/* 
-	 * do the read 
+	/*
+	 * do the read
 	 */
 
 	val32 = in_le32((u32 *)bus_addr);
@@ -1947,13 +1946,13 @@ ppc4xx_pciex_acp_read_config(struct pci_bus *bus, unsigned int devfn,
 
 #ifdef PRINT_CONFIG_ACCESSES
 		printk("acp_read_config : %3d [%3d..%3d] fn=0x%04x"
-		       " o=0x%04x l=%d a=0x%08x machine check!! 0x%08x\n", 
+		       " o=0x%04x l=%d a=0x%08x machine check!! 0x%08x\n",
 		       bus->number, hose->first_busno, hose->last_busno,
 		       devfn, offset, len, bus_addr, mcsr);
 #endif
 		pr_debug("acp_read_config : bus=%3d [%3d..%3d] devfn=0x%04x"
 			 " offset=0x%04x len=%d, addr=0x%08x machine check!! "
-			 "0x%08x\n", 
+			 "0x%08x\n",
 			 bus->number, hose->first_busno, hose->last_busno,
 			 devfn, offset, len, bus_addr, mcsr);
 		*val = 0;
@@ -1997,14 +1996,14 @@ static int ppc4xx_pciex_acp_write_config(struct pci_bus *bus, unsigned int devfn
 		return PCIBIOS_DEVICE_NOT_FOUND;
     }
 
-    /* 
+    /*
      * addressing is different for local config access vs.
      * access through the mapped config space. We need to
      * translate the offset for mapped config access
      */
 	if (bus->number == port->hose->first_busno) {
-        /* the local ACP RC only supports 32-bit dword config access, 
-         * so if this is a byte or 16-bit word access we need to 
+        /* the local ACP RC only supports 32-bit dword config access,
+         * so if this is a byte or 16-bit word access we need to
          * perform a read-modify write
          */
         if (len == 4) {
@@ -2026,8 +2025,8 @@ static int ppc4xx_pciex_acp_write_config(struct pci_bus *bus, unsigned int devfn
             len = 4;
         }
 
-    } else { 
-        bus_addr = (u32) addr + (offset << 2) + (offset & 0x3); 
+    } else {
+        bus_addr = (u32) addr + (offset << 2) + (offset & 0x3);
     }
 
 #ifdef PRINT_CONFIG_ACCESSES
@@ -2152,11 +2151,11 @@ static int __init ppc4xx_setup_one_pciex_POM(struct ppc4xx_pciex_port	*port,
         u32 mpage_lower;
 
         printk(KERN_INFO "setting outbound window %d with "
-           "plb_add=0x%012llx, pci_addr=0x%012llx, size=0x%012llx\n", 
+           "plb_add=0x%012llx, pci_addr=0x%012llx, size=0x%012llx\n",
            index, plb_addr, pci_addr, size);
 
-        /* 
-         * MPAGE7 is dedicated to config access, so we only 
+        /*
+         * MPAGE7 is dedicated to config access, so we only
          *  have 7 128MB pages available for memory i/o.
          *  Calculate how many pages we need
          */
@@ -2349,7 +2348,7 @@ ppc4xx_configure_acp_pciex_PIMs(struct ppc4xx_pciex_port *port,
 
 		if (0 != ncr_read(NCP_REGION_ID(0xa, 0x10), 0x2c, 4, &value))
 			printk(KERN_WARNING "** Unable to get ACP type!\n");
-		
+
 		/*
 		 * For ACP we need to set the dema_offset to the size of
 		 * inbound window.
@@ -2366,8 +2365,8 @@ ppc4xx_configure_acp_pciex_PIMs(struct ppc4xx_pciex_port *port,
 			out_le32(mbase + 0x11f4, 0xf0000000UL);
 		}
 
-		/* 
-		 * set up the TPAGE registers 
+		/*
+		 * set up the TPAGE registers
 		 *
 		 * We set the MSB of each TPAGE to select 128-bit AXI access.
 		 * For the address field we simply program an incrementing value
@@ -2383,28 +2382,24 @@ ppc4xx_configure_acp_pciex_PIMs(struct ppc4xx_pciex_port *port,
 		} else {
 			out_le32(tpage_base, 0x0);    /* tpage 0  point to 0x0, not used */
 			tpage_base +=4;
-			out_le32(tpage_base, 0x0);    /* tpage 1  point to 0x0, not used */	
+			out_le32(tpage_base, 0x0);    /* tpage 1  point to 0x0, not used */
 			tpage_base +=4;
-			out_le32(tpage_base, 0x0);    /* tpage 2  point to 0x0, not used */	
+			out_le32(tpage_base, 0x0);    /* tpage 2  point to 0x0, not used */
 			tpage_base +=4;
-			out_le32(tpage_base, 0x0);    /* tpage 3  point to 0x0, not used */	
+			out_le32(tpage_base, 0x0);    /* tpage 3  point to 0x0, not used */
 			tpage_base +=4;
 			out_le32(tpage_base, 0x0);    /* tpage 4  point to 0x0, not used */
 			tpage_base +=4;
-			out_le32(tpage_base, 0x0);    /* tpage 5  point to 0x0, not used */	 
-			tpage_base +=4;	
-			out_le32(tpage_base, 0x0);    /* tpage 6  point to 0x0 for dynamic mapping */	
-			tpage_base +=4;		 
-			out_le32(tpage_base, 0x80001000);    /* tpage 7  point to 0x20,0000,0000 tpage size = 256MB */	       
+			out_le32(tpage_base, 0x0);    /* tpage 5  point to 0x0, not used */
+			tpage_base +=4;
+			out_le32(tpage_base, 0x0);    /* tpage 6  point to 0x0 for dynamic mapping */
+			tpage_base +=4;
+			out_le32(tpage_base, 0x80001000);
+				/* tpage 7  point to 0x20,0000,0000 tpage size = 256MB */
 		}
 	}
 
 	/* Enable I/O, Mem, and Busmaster cycles */
-#if 0
-	out_le16(mbase + PCI_COMMAND,
-		 in_le16(mbase + PCI_COMMAND) |
-		 PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);
-#endif
 }
 
 #endif
@@ -2588,16 +2583,7 @@ acp_pcie_isr(int irq, void *arg)
 
     /* read the PEI interrupt status register */
     intr_status = in_le32(mbase + 0x10c0);
-#if 0
-    {
-	    u32 intr_enb;
-	    intr_enb = in_le32(mbase + 0x10c4);
-	    printk("PCIE%d mbase %p intr_status/enb = 0x%08x 0x%08x\n",
-		   hose->indirect_type, mbase, intr_status, intr_enb);
-    }
-#else
     in_le32(mbase + 0x10c4);
-#endif
 
     /* check if this is a PCIe message from an external device */
     if (intr_status & 0x00000010) {
@@ -2616,7 +2602,7 @@ acp_pcie_isr(int irq, void *arg)
             fn  = (msg_fifo_info >>  8 ) & 0x07;
             msg_type = msg_fifo_info & 0xff;
 
-            /* print out the BDF and message type. 
+            /* print out the BDF and message type.
              * We ignore the common message types.
              */
             switch (msg_type) {
@@ -2684,8 +2670,8 @@ acp_pcie_isr(int irq, void *arg)
                 out_le32(mbase + 0x10c4, int_enb);
             }
 
-            /* 
-             * dump all the potentially interesting PEI registers 
+            /*
+             * dump all the potentially interesting PEI registers
              */
             for (offset = 0x114c; offset <= 0x1180; offset += 4) {
                 printk("  0x%04x : 0x%08x\n", offset, in_le32(mbase + offset));
@@ -2695,10 +2681,10 @@ acp_pcie_isr(int irq, void *arg)
 
      /*
       *  We clear all the interrupts in the PEI status, even though
-      *  interrupts from external devices have not yet been handled. 
+      *  interrupts from external devices have not yet been handled.
       *  That should be okay, since the PCI IRQ in the MPIC won't be
-      *  re-enabled until all external handlers have been called. 
-      */ 
+      *  re-enabled until all external handlers have been called.
+      */
     out_le32(mbase + 0x10c0, intr_status);
 
     return (externalPciIntr ? IRQ_NONE : IRQ_HANDLED);
@@ -2763,7 +2749,7 @@ static void __init ppc4xx_acp_pciex_port_setup_hose(struct ppc4xx_pciex_port *po
 		hose->cfg_data = cfg_data;
 	}
 
-	/* 
+	/*
 	 * The internal config space has already been mapped, so
 	 * just re-use that virtual address.
 	 */
@@ -2791,12 +2777,12 @@ static void __init ppc4xx_acp_pciex_port_setup_hose(struct ppc4xx_pciex_port *po
 
     pci_status = in_le32(mbase + 0x1004);
     link_state = (pci_status & 0x3f00) >> 8;
-    printk("PCIE%d status = 0x%08x : PCI link state = 0x%x\n", 
+    printk("PCIE%d status = 0x%08x : PCI link state = 0x%x\n",
                         port->index, pci_status, link_state);
 
     /* make sure the ACP device is configured as PCI Root Complex */
     if ((pci_status & 0x18) != 0x18) {
-        printk("ACP device is not PCI Root Complex! status = 0x%08x\n", 
+        printk("ACP device is not PCI Root Complex! status = 0x%08x\n",
                 pci_status);
         goto fail;
     }
@@ -2826,7 +2812,7 @@ static void __init ppc4xx_acp_pciex_port_setup_hose(struct ppc4xx_pciex_port *po
         goto fail;
     }
     port->acpChipType = (version & 0x1f);
-    printk(KERN_INFO "Using PEI register set for ACP chipType %d\n", 
+    printk(KERN_INFO "Using PEI register set for ACP chipType %d\n",
             port->acpChipType);
 
 	/*
@@ -2851,57 +2837,40 @@ static void __init ppc4xx_acp_pciex_port_setup_hose(struct ppc4xx_pciex_port *po
 	ppc4xx_configure_acp_pciex_PIMs(port, hose, mbase, &dma_window);
 
     /*
-     * hook up an interrupt handler 
+     * hook up an interrupt handler
      */
-#if 0
-    mappedIrq = irq_create_mapping(NULL, 29); 
-    if (mappedIrq == NO_IRQ) {
-        printk(KERN_ERR "irq_create_mapping failed!!!\n");
-        goto fail;
-    }
-
-    err = set_irq_type(mappedIrq, IRQ_TYPE_LEVEL_HIGH); 
-    if (err) {
-        printk(KERN_ERR "set_irq_type failed!!!!\n");
-        goto fail;
-    }
-#endif
     printk("PCIE%d mapping interrupt\n", port->index);
     mappedIrq = irq_of_parse_and_map(port->node, 0);
 
-    err = request_irq(mappedIrq, acp_pcie_isr, IRQF_SHARED, "acp_pcie", hose); 
+    err = request_irq(mappedIrq, acp_pcie_isr,
+		IRQF_SHARED, "acp_pcie", hose);
     if (err) {
-        printk(KERN_ERR "request_irq failed!!!!\n");
-        goto fail;
-    }
+		printk(KERN_ERR "request_irq failed!!!!\n");
+		goto fail;
+	}
 
     /* unmask PEI interrupts */
-#if 0
-    out_le32(mbase + 0x10c4, 0xffffffff);
-#else
     /* for now ignore retry requests, and INT assert/deassert */
     out_le32(mbase + 0x10c4, 0xf3fffffd);
-#endif
 
-    if (port->acpChipType == 1) {
-        /* 
-         * for v2 we need to set the 'axi_interface_rdy' bit
-         * this bit didn't exist in X1V1, and means something 
-         * else for X2...
-         */
-        pci_config = in_le32(mbase + 0x1000);
-        pci_config |= 0x00040000;
-        out_le32(mbase + 0x1000, pci_config);
-    }
+	if (port->acpChipType == 1) {
+		/*
+		 * for v2 we need to set the 'axi_interface_rdy' bit
+		 * this bit didn't exist in X1V1, and means something
+		 * else for X2...
+		 */
+		pci_config = in_le32(mbase + 0x1000);
+		pci_config |= 0x00040000;
+		out_le32(mbase + 0x1000, pci_config);
+	}
 
 	if (!port->endpoint) {
 		printk(KERN_INFO "PCIE%d: successfully set as root-complex\n",
 		       port->index);
-	} else {
 	}
 
 	return;
- fail:
+fail:
 	if (hose)
 		pcibios_free_controller(hose);
 	if (cfg_data)
-- 
1.7.9.7

