From 0952248b20da64c6c537a206bb54404e36eb765e Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Mon, 7 May 2012 16:06:06 +0800
Subject: [PATCH 11/11] lsi/net: add femac support

Extracted from lsi.patch in lsi_acp_linux_3.8.1.28 tarball.

Add the 10/100 Fast Ethernet MAC (FEMAC) support on the ACP
board.

[Kevin: The main modifications include:
* Adapt to the changes of API in new kernel.
* Remove sbb_desecure_range since we don't support sbb on
  acp34xx.]

Signed-off-by Kevin Hao <kexin.hao@windriver.com>
---
 drivers/lsi/Kconfig        |   34 +
 drivers/lsi/acp/Makefile   |    2 +
 drivers/lsi/acp/net.c      | 4538 ++++++++++++++++++++++++++++++++++++++++++++
 drivers/lsi/acp/wrappers.c |  243 +++
 4 files changed, 4817 insertions(+), 0 deletions(-)
 create mode 100644 drivers/lsi/acp/net.c
 create mode 100644 drivers/lsi/acp/wrappers.c

diff --git a/drivers/lsi/Kconfig b/drivers/lsi/Kconfig
index d71178a..c93e192 100644
--- a/drivers/lsi/Kconfig
+++ b/drivers/lsi/Kconfig
@@ -62,4 +62,38 @@ config SERIAL_ACP_CONSOLE_POLL
 		This is only intended to be used for debugging.
 
 		If unsure, say N.
+
+config LSI_NET
+	bool "Network interface for LSI's APP and ACP"
+	help
+	  Network interface driver for LSI's APP and ACP series boards.
+
+config LSI_NET_NUM_RX_DESC
+	int "NIC driver: Number of receive descriptors"
+	depends on LSI_NET
+	default "4"
+	help
+          The number of receive descriptors to allocate.
+
+config LSI_NET_RX_BUF_SZ
+    int "NIC driver: Size of the receive buffer"
+    depends on LSI_NET
+    default "32768"
+    help
+        The size of the receive buffer.
+
+config LSI_NET_NUM_TX_DESC
+    int "NIC driver: Number of transmit descriptors"
+    depends on LSI_NET
+    default "4"
+    help
+        The number of transmit descriptors to allocate.
+
+config LSI_NET_TX_BUF_SZ
+    int "NIC driver: Size of the transmit buffer"
+    depends on LSI_NET
+    default "32768"
+    help
+        The size of the transmit buffer.
+
 endmenu
diff --git a/drivers/lsi/acp/Makefile b/drivers/lsi/acp/Makefile
index 347441e..b874787 100644
--- a/drivers/lsi/acp/Makefile
+++ b/drivers/lsi/acp/Makefile
@@ -5,3 +5,5 @@ obj-$(CONFIG_LSI_NAND)			+= nand.o
 obj-$(CONFIG_LSI_UBOOTENV)		+= ubootenv.o
 obj-$(CONFIG_ACP)			+= version.o
 obj-$(CONFIG_SERIAL_ACP)		+= serial.o
+obj-$(CONFIG_ACP)			+= wrappers.o
+obj-$(CONFIG_LSI_NET)			+= net.o
diff --git a/drivers/lsi/acp/net.c b/drivers/lsi/acp/net.c
new file mode 100644
index 0000000..836a21d
--- /dev/null
+++ b/drivers/lsi/acp/net.c
@@ -0,0 +1,4538 @@
+/*
+ * drivers/lsi/acp/net.c
+ *
+ * Copyright (C) 2009 LSI
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+#include <linux/in.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/bitops.h>
+#include <linux/proc_fs.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/skbuff.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/of.h>
+
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/dma.h>
+
+#include "../common/version.h"
+
+extern int acp_mdio_read(unsigned long, unsigned long, unsigned short *);
+extern int acp_mdio_write(unsigned long, unsigned long, unsigned short);
+
+/* Base Addresses of the RX, TX, and DMA Registers. */
+static unsigned long rx_base;
+static unsigned long tx_base;
+static unsigned long dma_base;
+
+/*
+  ===============================================================================
+  Debug counts (readable from the external host).
+  ===============================================================================
+*/
+
+#undef LSINET_COUNTS
+#define LSINET_COUNTS
+
+#ifdef LSINET_COUNTS
+
+unsigned long lsinet_counts [ ] = {
+	0, 0, 0, 0,		/* ISR */
+	0, 0, 0, 0, 0, 0,	/* HST */
+	0, 0, 0, 0, 0, 0, 0,	/* RX */
+	0, 0, 0, 0		/* POL */
+};
+
+EXPORT_SYMBOL( lsinet_counts );
+
+#define LSINET_COUNTS_INC( index ) { ++ lsinet_counts [ ( index ) ]; }
+
+#else  /* LSINET_DEBUG_COUNTS */
+
+#define LSINET_COUNTS_INC( index )
+
+#endif /* LSINET_DEBUG_COUNTS */
+
+#define LSINET_COUNTS_ISR_START  0
+#define LSINET_COUNTS_ISR_TX     1
+#define LSINET_COUNTS_ISR_RX     2
+#define LSINET_COUNTS_ISR_DONE   3
+#define LSINET_COUNTS_HST_START  4
+#define LSINET_COUNTS_HST_RCLM   5
+#define LSINET_COUNTS_HST_SNDG   6
+#define LSINET_COUNTS_HST_SNT    7
+#define LSINET_COUNTS_HST_OOD    8
+#define LSINET_COUNTS_HST_DONE   9
+#define LSINET_COUNTS_RX_START  10
+#define LSINET_COUNTS_RX_PKT    11
+#define LSINET_COUNTS_RX_ERR    12
+#define LSINET_COUNTS_RX_GOOD   13
+#define LSINET_COUNTS_RX_SENT   14
+#define LSINET_COUNTS_RX_DRPD   15
+#define LSINET_COUNTS_RX_DONE   16
+#define LSINET_COUNTS_POL_START 17
+#define LSINET_COUNTS_POL_PKT   18
+#define LSINET_COUNTS_POL_RNBL  19
+#define LSINET_COUNTS_POL_DONE  20
+
+/*
+  ======================================================================
+  ======================================================================
+  ======================================================================
+  Profile/Trace/Debug/Warn/Error Macros
+  ======================================================================
+  ======================================================================
+  ======================================================================
+*/
+
+/* -- Profile ------------------------------------------------------- */
+
+/*#define __APPNIC_C_PROFILE__*/
+#ifdef __APPNIC_C_PROFILE__
+#include <asm/arch/timers.h>
+unsigned long time_in_rx_max_ = 0;
+unsigned long time_in_rx_min_ = 0xffffffff;
+unsigned long long total_rx_time_ = 0;
+unsigned long max_rx_packets_handled_ = 0;
+unsigned long total_rx_packets_handled_ = 0;
+unsigned long total_rx_interrupts_ = 0;
+unsigned long rx_packet_size_max_ = 0;
+unsigned long rx_packet_size_min_ = 0xffffffff;
+unsigned long total_rx_bytes_ = 0;
+unsigned long time_in_tx_max_ = 0;
+unsigned long time_in_tx_min_ = 0xffffffff;
+unsigned long long total_tx_time_ = 0;
+unsigned long total_tx_packets_ = 1;
+unsigned long jiffies_changed_ = 0;
+unsigned long total_polls_ = 0;
+
+unsigned long recv_t1_min_ = 0xffffffff;
+unsigned long recv_t2_min_ = 0xffffffff;
+unsigned long recv_t3_min_ = 0xffffffff;
+unsigned long recv_t1_max_ = 0;
+unsigned long recv_t2_max_ = 0;
+unsigned long recv_t3_max_ = 0;
+unsigned long long recv_t1_tot_ = 0;
+unsigned long long recv_t2_tot_ = 0;
+unsigned long long recv_t3_tot_ = 0;
+unsigned long total_rx_packets_sent_up_ = 1;
+
+
+#define app3xx_profile_time_calc(_beg_t_, _end_t_, _min_t_, _max_t_, _tot_t_) \
+    do {                                                                 \
+        unsigned long _this_t_;                                          \
+        if( _end_t_ > _beg_t_ ) {                                        \
+            _this_t_ = _end_t_ - _beg_t_;                                \
+        } else {                                                         \
+             _this_t_ = _end_t_ + ( 0xffffffff - _beg_t_ ) + 1;          \
+        }                                                                \
+        _tot_t_ += _this_t_;                                             \
+        if( _this_t_ > _max_t_ ) { _max_t_ = _this_t_; }                  \
+        if( _this_t_ < _min_t_ ) { _min_t_ = _this_t_; }                  \
+    } while (0) ;
+
+#define profile_time_fmt(t,d)  ((1000*t)/d)
+#define profile_avg_fmt(t,c,d) ((1000*(t/c))/d)
+#endif /* __APPNIC_C_PROFILE__ */
+
+/* -- TRACE --------------------------------------------------------- */
+
+#undef TRACE
+/*#define TRACE*/
+#define TRACE_PRINTK
+#ifdef TRACE
+#ifdef TRACE_PRINTK
+#define TRACE_BEGINNING( ) \
+printk( "nic:%d:%s:Beginning\n", smp_processor_id( ), __FUNCTION__ )
+#define TRACE_ENDING( ) \
+printk( "nic:%d:%s:Ending\n", smp_processor_id( ), __FUNCTION__ )
+#else
+#define TRACE_BEGINNING( ) TRACER_POST( "Beginning" );
+#define TRACE_ENDING( ) TRACER_POST( "Ending" );
+#endif
+#else
+#define TRACE_BEGINNING( format, args... )
+#define TRACE_ENDING( format, args... )
+#endif
+
+/* -- DEBUG --------------------------------------------------------- */
+
+#undef DEBUG
+/*#define DEBUG*/
+#if defined( DEBUG )
+#define DEBUG_PRINT( format, args... ) do { \
+printk( "appnic:%d - DEBUG - ", __LINE__ ); \
+printk( format, ##args ); \
+} while( 0 );
+#else
+#define DEBUG_PRINT( format, args... )
+#endif
+
+#undef PHY_DEBUG
+/*#define PHY_DEBUG*/
+#if defined( PHY_DEBUG )
+#define PHY_DEBUG_PRINT( format, args... ) do { \
+printk( "net:%d - PHY_DEBUG - ", __LINE__ ); \
+printk( format, ##args ); \
+} while( 0 );
+#else
+#define PHY_DEBUG_PRINT( format, args... )
+#endif
+
+/* -- WARN ----------------------------------------------------------- */
+
+#undef WARN
+#define WARN
+#if defined( WARN )
+#define WARN_PRINT( format, args... ) do { \
+printk( "appnic:%d - WARN - ", __LINE__ ); \
+printk( format, ##args ); \
+} while( 0 );
+#else
+#define WARN_PRINT( format, args... )
+#endif
+
+/* -- ERROR --------------------------------------------------------- */
+
+#define ERROR_PRINT( format, args... ) do { \
+printk( "%s:%s:%d - ERROR - ", __FILE__, __FUNCTION__, __LINE__ ); \
+printk( format, ##args ); \
+} while( 0 );
+
+/*
+  ======================================================================
+  ======================================================================
+  Optimizations
+  ======================================================================
+  ======================================================================
+*/
+
+#define DISABLE_TX_INTERRUPTS
+/*#define PRELOAD_RX_BUFFERS*/
+
+#undef DMA_CACHABLE
+/*#define DMA_CACHABLE*/
+
+/*
+  ===============================================================================
+  NAPI Support (new and newer)...
+  ===============================================================================
+*/
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,20)
+
+#define LSINET_NAPI
+#define LSINET_NAPI_WEIGHT 64
+
+#endif
+
+/*
+  ======================================================================
+  ======================================================================
+  ======================================================================
+  Access and Access Logging
+  ======================================================================
+  ======================================================================
+  ======================================================================
+*/
+
+/*#define LOG_MAC_ACCESS*/
+/*#define LOG_PHY_ACCESS*/
+
+/*
+  ======================================================================
+  ======================================================================
+  ======================================================================
+  PHY
+  ======================================================================
+  ======================================================================
+  ======================================================================
+*/
+
+#undef PHYLESS
+/*#define PHYLESS*/
+
+#ifndef PHYLESS
+
+/* -- control -- */
+
+#define PHY_CONTROL 0x00
+
+typedef union {
+  unsigned short raw;
+
+  struct {
+#if 1
+    unsigned short soft_reset      : 1;
+    unsigned short loop_back       : 1;
+    unsigned short force100        : 1; /* speedBit0 */
+    unsigned short autoneg_enable  : 1;
+    unsigned short power_down      : 1;
+    unsigned short isolate         : 1;
+    unsigned short restart_autoneg : 1;
+    unsigned short full_duplex     : 1; /* duplex */
+    unsigned short collision_test  : 1;
+    unsigned short unused          : 7;
+#else  /* __BIG_ENDIAN */
+    unsigned short                 : 7;
+    unsigned short collision_test  : 1;
+    unsigned short full_duplex     : 1; /* duplex */
+    unsigned short restart_autoneg : 1;
+    unsigned short isolate         : 1;
+    unsigned short power_down      : 1;
+    unsigned short autoneg_enable  : 1;
+    unsigned short force100        : 1; /* speedBit0 */
+    unsigned short loop_back       : 1;
+    unsigned short soft_reset      : 1;
+#endif /* __BIG_ENDIAN */
+  } __attribute__ ( ( packed ) ) bits;
+} __attribute__ ( ( packed ) ) phy_control_t;
+
+/* -- status -- */
+
+#define PHY_STATUS 0x01
+
+typedef union {
+  unsigned short raw;
+
+  struct {
+#if 1
+    unsigned short t4_capable        : 1;
+    unsigned short tx_fdx_capable    : 1;
+    unsigned short tx_capable        : 1;
+    unsigned short bt_fdx_capable    : 1;
+    unsigned short tenbt_capable     : 1;
+    unsigned short unused            : 4;
+    unsigned short mf_pream_suppress : 1;
+    unsigned short autoneg_comp      : 1; /* autoNegDone */
+    unsigned short remote_fault      : 1; /* remoutFault */
+    unsigned short autoneg_capable   : 1;
+    unsigned short link_status       : 1; /* linkStatus */
+    unsigned short jabber_detect     : 1;
+    unsigned short extd_reg_capable  : 1;
+#else
+    unsigned short extd_reg_capable  : 1;
+    unsigned short jabber_detect     : 1;
+    unsigned short link_status       : 1; /* linkStatus */
+    unsigned short autoneg_capable   : 1;
+    unsigned short remote_fault      : 1; /* remoutFault */
+    unsigned short autoneg_comp      : 1; /* autoNegDone */
+    unsigned short mf_pream_suppress : 1;
+    unsigned short                   : 4;
+    unsigned short tenbt_capable     : 1;
+    unsigned short bt_fdx_capable    : 1;
+    unsigned short tx_capable        : 1;
+    unsigned short tx_fdx_capable    : 1;
+    unsigned short t4_capable        : 1;
+#endif /* __BIG_ENDIAN */
+  } __attribute__ ( ( packed ) ) bits;
+} __attribute__ ( ( packed ) ) phy_status_t;
+
+/* -- id_high -- */
+
+#define PHY_ID_HIGH 0x02
+
+typedef union {
+  unsigned short raw;
+
+  struct {
+    unsigned short id : 16;
+  } __attribute__ ( ( packed ) ) bits;
+} __attribute__ ( ( packed ) ) phy_id_high_t;
+
+/* -- id_low -- */
+
+#define PHY_ID_LOW  0x03
+
+typedef union {
+  unsigned short raw;
+
+  struct {
+#if 1
+    unsigned short id       : 6;
+    unsigned short model    : 6;
+    unsigned short revision : 4;
+#else  /* __BIG_ENDIAN */
+    unsigned short revision : 4;
+    unsigned short model    : 6;
+    unsigned short id       : 6;
+#endif /* __BIG_ENDIAN */
+  } __attribute__ ( ( packed ) ) bits;
+} __attribute__ ( ( packed ) ) phy_id_low_t;
+
+/* -- autoneg_advertise  -- */
+
+#define PHY_AUTONEG_ADVERTISE 0x04
+
+/* -- link_partner_ability -- */
+
+#define PHY_LINK_PARTNER_ABILITY 0x05
+
+/* -- -- */
+
+#define MICREL_PHY_AUXILIARY_CONTROL_STATUS 0x1f
+
+typedef union {
+	unsigned short raw;
+
+	struct {
+		unsigned short                    : 3;
+		unsigned short energy             : 1;
+		unsigned short force_link         : 1;
+		unsigned short power_saving       : 1;
+		unsigned short interrupt_level    : 1;
+		unsigned short jabber_enable      : 1;
+		unsigned short autoneg_indication : 1;
+		unsigned short enable_pause       : 1;
+		unsigned short isolate            : 1;
+		unsigned short op_mode_indication : 3;
+		unsigned short                    : 2;
+  } bits;
+} micrel_phy_auxiliary_control_status_t;
+
+/*
+  Auto-negotiation Advertisement Values.
+*/
+
+#define PHY_AUTONEG_ADVERTISE_100FULL 0x101
+#define PHY_AUTONEG_ADVERTISE_100     0x081
+#define PHY_AUTONEG_ADVERTISE_10FULL  0x041
+#define PHY_AUTONEG_ADVERTISE_10      0x021
+
+#define PHY_ADDRESS_ 0x1e
+static int phy_address_ = PHY_ADDRESS_;
+
+#define UNKNOWN_PHY_ 0x0
+#define BCM5221_PHY_ 0x1
+#define MICREL_PHY_  0x2
+
+#ifndef CONFIG_ACP
+static int phy_type_ = UNKNOWN_PHY_;
+static int phy_link_( int );
+static int phy_scan_( void );
+static int phy_reset_( int );
+#endif
+
+static int phy_read_( int, int, unsigned short * );
+static int phy_write_( int, int, unsigned short );
+static int phy_speed_( int );
+static int phy_duplex_( int );
+static int phy_renegotiate_( int );
+static int phy_enable_( int );
+
+#endif /* PHYLESS */
+
+/*
+  ======================================================================
+  ======================================================================
+  ======================================================================
+
+  NIC Interface
+
+  ======================================================================
+  ======================================================================
+  ======================================================================
+*/
+
+static int enable_( struct net_device * );
+
+/*
+  ======================================================================
+  ======================================================================
+  ======================================================================
+
+  Device Data Structures
+
+  ======================================================================
+  ======================================================================
+  ======================================================================
+*/
+
+typedef struct {
+
+#ifdef CONFIG_ACP
+
+  /* Word 0 */
+  unsigned long                         : 24;
+  /* big endian to little endian */
+  unsigned long byte_swapping_on        : 1;
+  unsigned long error                   : 1;
+  unsigned long interrupt_on_completion : 1;
+  unsigned long end_of_packet           : 1;
+  unsigned long start_of_packet         : 1;
+  unsigned long write                   : 1;
+  /* 00=Fill|01=Block|10=Scatter */
+  unsigned long transfer_type           : 2;
+
+  /* Word 1 */
+  unsigned long pdu_length           : 16;
+  unsigned long data_transfer_length : 16;
+
+  /* Word 2 */
+  unsigned long target_memory_address;
+
+  /* Word 3 */
+  unsigned long host_data_memory_pointer;
+
+#else
+
+  /* Word 0 */
+  /* 00=Fill|01=Block|10=Scatter */
+  unsigned long transfer_type           : 2;
+  unsigned long write                   : 1;
+  unsigned long start_of_packet         : 1;
+  unsigned long end_of_packet           : 1;
+  unsigned long interrupt_on_completion : 1;
+  unsigned long error                   : 1;
+  /* big endian to little endian */
+  unsigned long byte_swapping_on        : 1;
+  unsigned long                         : 24;
+
+  /* Word 1 */
+  unsigned long data_transfer_length : 16;
+  unsigned long pdu_length           : 16;
+
+  /* Word 2 */
+  unsigned long target_memory_address;
+
+  /* Word 3 */
+  unsigned long host_data_memory_pointer;
+
+#endif
+
+} __attribute__ ( ( packed ) ) appnic_dma_descriptor_t;
+
+typedef union {
+
+  unsigned long raw;
+
+  struct {
+#ifdef CONFIG_ACP
+    unsigned long                : 11;
+    unsigned long generation_bit : 1;
+    unsigned long offset         : 20;
+#else
+    unsigned long offset         : 20;
+    unsigned long generation_bit : 1;
+    unsigned long                : 11;
+#endif
+  } __attribute__ ( ( packed ) ) bits;
+
+} __attribute__ ( ( packed ) ) appnic_queue_pointer_t;
+
+/*
+  ===============================================================================
+  The Device Struction
+  ===============================================================================
+*/
+
+typedef struct {
+
+	/* net_device */
+	struct net_device * device;
+
+	/* Addresses, Interrupt, and PHY stuff. */
+	unsigned long rx_base;
+	unsigned long tx_base;
+	unsigned long dma_base;
+	unsigned long interrupt;
+	unsigned long mdio_clock;
+	unsigned long phy_address;
+	unsigned long ad_value;
+	unsigned char mac_addr[6];
+
+#ifdef LSINET_NAPI
+	/* napi */
+	struct napi_struct napi;
+#endif /* LSINET_ENABLE_NAPI */
+
+	/* statistics */
+	struct net_device_stats stats;
+
+	/*
+	  DMA-able memory.
+	*/
+
+	/* */
+	int dma_alloc_size;
+	void * dma_alloc;
+	dma_addr_t dma_alloc_dma;
+	int dma_alloc_offset;
+
+	/* tail pointers */
+	volatile appnic_queue_pointer_t * rx_tail;
+	dma_addr_t rx_tail_dma;
+	volatile appnic_queue_pointer_t * tx_tail;
+	dma_addr_t tx_tail_dma;
+
+	/* descriptors */
+	appnic_dma_descriptor_t * rx_desc;
+	dma_addr_t rx_desc_dma;
+	unsigned rx_num_desc;
+	appnic_dma_descriptor_t * tx_desc;
+	dma_addr_t tx_desc_dma;
+	unsigned tx_num_desc;
+
+	/* buffers */
+	unsigned rx_buf_sz;
+	unsigned rx_buf_per_desc;
+	void * rx_buf;
+	dma_addr_t rx_buf_dma;
+	unsigned tx_buf_sz;
+	unsigned tx_buf_per_desc;
+	void * tx_buf;
+	dma_addr_t tx_buf_dma;
+
+	/*
+	  The local pointers
+	*/
+
+	appnic_queue_pointer_t rx_tail_copy;
+	appnic_queue_pointer_t rx_head;
+
+	appnic_queue_pointer_t tx_tail_copy;
+	appnic_queue_pointer_t tx_head;
+
+	/*
+	  Polling Mode?
+	*/
+
+	int polling;
+
+	/*
+	  Spin Lock
+	*/
+
+	spinlock_t lock;
+	spinlock_t extra_lock;
+
+	/*
+	 * TEMP: semaphores for locking Tx/Rx operations
+	 */
+
+	struct mutex tx_sem;
+	struct mutex rx_sem;
+	struct mutex poll_sem;
+
+} appnic_device_t;
+
+#define DESCRIPTOR_GRANULARITY 64
+#define BUFFER_ALIGNMENT 64
+
+#define ALIGN64B( address ) \
+( ( ( ( unsigned long ) ( address ) + ( 64UL - 1UL ) ) & ~ ( 64UL - 1UL ) ) )
+
+#define ALIGN64B_OFFSET( address ) \
+( ALIGN64B( address ) - ( unsigned long ) ( address ) )
+
+#define APPNIC_NAME "appnic"
+
+/*
+  Overview
+  --------
+
+  Register offset decoding is as follows:
+
+  Bit(s) Description
+
+  16:15  define the Channel.  There is only one; therefore, 00.
+  14:12  define the MAC within the channel.  Only one so 000.
+  11:10  define the register "space" as follows:
+  00 = fast ethernet MAC
+  10 = global
+  11 = interrupt
+  9: 2  register
+  1: 0  always 00, 32 bit registers only.
+
+  Receive registers start at the base address.  Transmit registers start
+  at 0x20000 above the base address.  DMA start at a completely different
+  base address (in this case 0x8000000 above the base).
+
+*/
+
+/*
+  ======================================================================
+  ======================================================================
+  ======================================================================
+
+  Registers.
+
+  ======================================================================
+  ======================================================================
+  ======================================================================
+*/
+
+/* SMII Status ------------------------------------------------------ */
+
+#define APPNIC_RX_SMII_STATUS        ( rx_base + 0x10 )
+#define APPNIC_RX_SMII_STATUS_SPEED  0x01
+#define APPNIC_RX_SMII_STATUS_DUPLEX 0x02
+#define APPNIC_RX_SMII_STATUS_LINK   0x04
+#define APPNIC_RX_SMII_STATUS_JABBER 0x08
+#define APPNIC_RX_SMII_STATUS_FCD    0x10 /* False Carrier Detect */
+
+#define SMII_SPEED_100( smii_status_ ) \
+( 0 != ( smii_status_ & APPNIC_RX_SMII_STATUS_SPEED ) )
+#define SMII_DUPLEX( smii_status_ ) \
+( 0 != ( smii_status_ & APPNIC_RX_SMII_STATUS_DUPLEX ) )
+#define SMII_LINK( smii_status_ ) \
+( 0 != ( smii_status_ & APPNIC_RX_SMII_STATUS_LINK ) )
+#define SMII_JABBER( smii_status_ ) \
+( 0 != ( smii_status_ & APPNIC_RX_SMII_STATUS_JABBER ) )
+
+/* Receive Configuration -------------------------------------------- */
+
+#define APPNIC_RX_CONF          ( rx_base + 0x004c )
+#define APPNIC_RX_CONF_ENABLE   0x0001
+/* Pass Any Packet */
+#define APPNIC_RX_CONF_PAP      0x0002
+#define APPNIC_RX_CONF_JUMBO9K  0x0008
+#define APPNIC_RX_CONF_STRIPCRC 0x0010
+/* Accept All MAC Types */
+#define APPNIC_RX_CONF_AMT      0x0020
+/* Accept Flow Control */
+#define APPNIC_RX_CONF_AFC      0x0040
+/* Enable VLAN */
+#define APPNIC_RX_CONF_VLAN     0x0200
+/* RX MAC Speed, 1=100MBS */
+#define APPNIC_RX_CONF_SPEED    0x0800
+/* 1=Duplex Mode */
+#define APPNIC_RX_CONF_DUPLEX   0x1000
+/* 1=Enable */
+#define APPNIC_RX_CONF_LINK     0x2000
+/* Determines the action taken when the FE MAC
+   receives an FC packet in FD mode.*/
+#define APPNIC_RX_CONF_RXFCE    0x4000
+/* Controls the insertion of FC packets
+   by the MAC transmitter. */
+#define APPNIC_RX_CONF_TXFCE    0x8000
+
+/* Receive Stat Overflow -------------------------------------------- */
+
+#define APPNIC_RX_STAT_OVERFLOW ( rx_base + 0x278 )
+
+/* Receive Stat Undersize ------------------------------------------- */
+
+#define APPNIC_RX_STAT_UNDERSIZE ( rx_base + 0x280 )
+
+/* Receive Stat Oversize -------------------------------------------- */
+
+#define APPNIC_RX_STAT_OVERSIZE ( rx_base + 0x2b8 )
+
+/* Receive Stat Multicast ------------------------------------------- */
+
+#define APPNIC_RX_STAT_MULTICAST ( rx_base + 0x2d0 )
+
+/* Receive Stat Packet OK ------------------------------------------- */
+
+#define APPNIC_RX_STAT_PACKET_OK ( rx_base + 0x2c0 )
+
+/* Receive Stat CRC Error ------------------------------------------- */
+
+#define APPNIC_RX_STAT_CRC_ERROR ( rx_base + 0x2c8 )
+
+/* Receive Stat Align Error ----------------------------------------- */
+
+#define APPNIC_RX_STAT_ALIGN_ERROR ( rx_base + 0x2e8 )
+
+/* Receive Ethernet Mode -------------------------------------------- */
+
+#define APPNIC_RX_MODE ( rx_base + 0x0800 )
+#define APPNIC_RX_MODE_ETHERNET_MODE_ENABLE 0x00001
+
+/* Receive Soft Reset ----------------------------------------------- */
+
+#define APPNIC_RX_SOFT_RESET ( rx_base + 0x0808 )
+#define APPNIC_RX_SOFT_RESET_MAC_0 0x00001
+
+/* Receive Internal Interrupt Control ------------------------------- */
+
+#define APPNIC_RX_INTERNAL_INTERRUPT_CONTROL ( rx_base + 0xc00 )
+#define APPNIC_RX_INTERNAL_INTERRUPT_CONTROL_MAC_0 0x1
+
+/* Receive External Interrupt Control ------------------------------- */
+
+#define APPNIC_RX_EXTERNAL_INTERRUPT_CONTROL ( rx_base + 0xc04 )
+#define APPNIC_RX_EXTERNAL_INTERRUPT_CONTROL_MAC_0_HIGH_LOW 0x10
+#define APPNIC_RX_EXTERNAL_INTERRUPT_CONTROL_MAC_0 0x1
+
+/* Receive Interrupt Status ----------------------------------------- */
+
+#define APPNIC_RX_INTERRUPT_STATUS ( rx_base + 0xc20 )
+#define APPNIC_RX_INTERRUPT_EXTERNAL_STATUS_MAC_0 0x10
+#define APPNIC_RX_INTERRUPT_INTERNAL_STATUS_MAC_0 0x1
+
+/* Transmit Watermark ----------------------------------------------- */
+
+#define APPNIC_TX_WATERMARK (tx_base + 0x18 )
+#define APPNIC_TX_WATERMARK_TXCONFIG_DTPA_ASSERT 0x8000
+#define APPNIC_TX_WATERMARK_TXCONFIG_DTPA_DISABLE 0x4000
+#define APPNIC_TX_WATERMARK_TXCONFIG_DTPA_WATER_MARK_HIGH 0x3f00
+#define APPNIC_TX_WATERMARK_TXCONFIG_DTPA_WATER_MARK_LOW 0x3f
+
+/* Swap Source Address Registers ------------------------------------ */
+
+#define APPNIC_SWAP_SOURCE_ADDRESS_2 ( tx_base + 0x20 )
+#define APPNIC_SWAP_SOURCE_ADDRESS_1 ( tx_base + 0x24 )
+#define APPNIC_SWAP_SOURCE_ADDRESS_0 ( tx_base + 0x28 )
+
+/* Transmit Extended Configuration ---------------------------------- */
+
+#define APPNIC_TX_EXTENDED_CONF ( tx_base + 0x30 )
+#define APPNIC_TX_EXTENDED_CONF_TRANSMIT_COLLISION_WATERMARK_LEVEL 0xf000
+#define APPNIC_TX_EXTENDED_CONF_EXCESSIVE_DEFFERED_PACKET_DROP 0x200
+#define APPNIC_TX_EXTENDED_CONF_JUMBO9K 0x100
+#define APPNIC_TX_EXTENDED_CONF_LATE_COLLISION_WINDOW_COUNT 0xff
+
+/* Transmit Half Duplex Configuration ------------------------------- */
+
+#define APPNIC_TX_HALF_DUPLEX_CONF ( tx_base + 0x34 )
+#define APPNIC_TX_HALF_DUPLEX_CONF_RANDOM_SEED_VALUE 0xff
+
+/* Transmit Configuration ------------------------------------------- */
+
+#define APPNIC_TX_CONF ( tx_base + 0x0050 )
+#define APPNIC_TX_CONF_ENABLE_SWAP_SA 0x8000
+#define APPNIC_TX_CONF_LINK           0x2000
+#define APPNIC_TX_CONF_DUPLEX         0x1000
+#define APPNIC_TX_CONF_SPEED          0x0800
+#define APPNIC_TX_CONF_XBK_RST_RX_NTX 0x0600
+#define APPNIC_TX_CONF_IFG            0x01f0
+#define APPNIC_TX_CONF_APP_CRC_ENABLE 0x0004
+#define APPNIC_TX_CONF_PAD_ENABLE     0x0002
+#define APPNIC_TX_CONF_ENABLE         0x0001
+
+#define TX_CONF_SET_IFG( tx_configuration_, ifg_ ) do { \
+( tx_configuration_ ) &= ~ APPNIC_TX_CONF_IFG; \
+( tx_configuration_ ) |= ( ( ifg_ & 0x1f ) << 4 ); \
+} while( 0 );
+
+/* Transmit Time Value Configuration -------------------------------- */
+
+#define APPNIC_TX_TIME_VALUE_CONF ( tx_base + 0x5c )
+#define APPNIC_TX_TIME_VALUE_CONF_PAUSE_VALUE 0xffff
+
+/* Transmit Stat Underrun ------------------------------------------- */
+
+#define APPNIC_TX_STAT_UNDERRUN ( tx_base + 0x300 )
+
+/* Transmit Stat Packet OK ------------------------------------------ */
+
+#define APPNIC_TX_STAT_PACKET_OK ( tx_base + 0x318 )
+
+/* Transmit Stat Undersize ------------------------------------------ */
+
+#define APPNIC_TX_STAT_UNDERSIZE ( tx_base + 0x350 )
+
+/* Transmit Status Late Collision ----------------------------------- */
+
+#define APPNIC_TX_STATUS_LATE_COLLISION ( tx_base + 0x368 )
+
+/* Transmit Status Excessive Collision ------------------------------ */
+
+#define APPNIC_TX_STATUS_EXCESSIVE_COLLISION ( tx_base + 0x370 )
+
+/* Transmit Stat Collision Above Watermark -------------------------- */
+
+#define APPNIC_TX_STAT_COLLISION_ABOVE_WATERMARK ( tx_base + 0x380 )
+
+/* Transmit Mode ---------------------------------------------------- */
+
+#define APPNIC_TX_MODE ( tx_base + 0x800 )
+#define APPNIC_TX_MODE_ETHERNET_MODE_ENABLE 0x1
+
+/* Transmit Soft Reset ---------------------------------------------- */
+
+#define APPNIC_TX_SOFT_RESET ( tx_base + 0x808 )
+#define APPNIC_TX_SOFT_RESET_MAC_0 0x1
+
+/* Transmit Interrupt Control --------------------------------------- */
+
+#define APPNIC_TX_INTERRUPT_CONTROL ( tx_base + 0xc00 )
+#define APPNIC_TX_INTERRUPT_CONTROL_MAC_0 0x1
+
+/* Transmit Interrupt Status ---------------------------------------- */
+
+#define APPNIC_TX_INTERRUPT_STATUS ( tx_base + 0xc20 )
+#define APPNIC_TX_INTERRUPT_STATUS_MAC_0 0x1
+
+/* */
+
+#define APPNIC_DMA_PCI_CONTROL ( dma_base + 0x00 )
+
+/* */
+
+#define APPNIC_DMA_CONTROL ( dma_base + 0x08 )
+
+/* DMA Interrupt Status --------------------------------------------- */
+
+#define APPNIC_DMA_INTERRUPT_STATUS ( dma_base + 0x18 )
+#define APPNIC_DMA_INTERRUPT_STATUS_RX 0x2
+#define APPNIC_DMA_INTERRUPT_STATUS_TX 0x1
+
+#define RX_INTERRUPT( dma_interrupt_status_ ) \
+( 0 != ( dma_interrupt_status_ & APPNIC_DMA_INTERRUPT_STATUS_RX ) )
+#define TX_INTERRUPT( dma_interrupt_status_ ) \
+( 0 != ( dma_interrupt_status_ & APPNIC_DMA_INTERRUPT_STATUS_TX ) )
+
+/* DMA Interrupt Enable --------------------------------------------- */
+
+#define APPNIC_DMA_INTERRUPT_ENABLE ( dma_base + 0x1c )
+#define APPNIC_DMA_INTERRUPT_ENABLE_RECEIVE 0x2
+#define APPNIC_DMA_INTERRUPT_ENABLE_TRANSMIT 0x1
+
+/* DMA Receive Queue Base Address ----------------------------------- */
+
+#define APPNIC_DMA_RX_QUEUE_BASE_ADDRESS ( dma_base + 0x30 )
+
+/* DMA Receive Queue Size ------------------------------------------- */
+
+#define APPNIC_DMA_RX_QUEUE_SIZE ( dma_base + 0x34 )
+
+/* DMA Transmit Queue Base Address ---------------------------------- */
+
+#define APPNIC_DMA_TX_QUEUE_BASE_ADDRESS ( dma_base + 0x38 )
+
+/* DMA Transmit Queue Size ------------------------------------------ */
+
+#define APPNIC_DMA_TX_QUEUE_SIZE ( dma_base + 0x3c )
+
+/* DMA Recevie Tail Pointer Address --------------------------------- */
+
+#define APPNIC_DMA_RX_TAIL_POINTER_ADDRESS ( dma_base + 0x48 )
+
+/* DMA Transmit Tail Pointer Address -------------------------------- */
+
+#define APPNIC_DMA_TX_TAIL_POINTER_ADDRESS ( dma_base + 0x4c )
+
+/* DMA Receive Head Pointer ----------------------------------------- */
+
+#define APPNIC_DMA_RX_HEAD_POINTER ( dma_base + 0x50 )
+#define APPNIC_DMA_RX_HEAD_POINTER_GB      0x100000
+#define APPNIC_DMA_RX_HEAD_POINTER_POINTER 0x0fffff
+
+/* DMA Receive Tail Pointer Local Copy ------------------------------ */
+
+#define APPNIC_DMA_RX_TAIL_POINTER_LOCAL_COPY ( dma_base + 0x54 )
+#define APPNIC_DMA_RX_TAIL_POINTER_LOCAL_COPY_GB      0x100000
+#define APPNIC_DMA_RX_TAIL_POINTER_LOCAL_COPY_POINTER 0x0fffff
+
+/* DMA Transmit Head Pointer ---------------------------------------- */
+
+#define APPNIC_DMA_TX_HEAD_POINTER ( dma_base + 0x58 )
+#define APPNIC_DMA_TX_HEAD_POINTER_GB      0x100000
+#define APPNIC_DMA_TX_HEAD_POINTER_POINTER 0x0fffff
+
+/* DMA Transmit Tail Pointer Local Copy ----------------------------- */
+
+#define APPNIC_DMA_TX_TAIL_POINTER_LOCAL_COPY ( dma_base + 0x5c )
+#define APPNIC_DMA_TX_TAIL_POINTER_LOCAL_COPY_GB      0x100000
+#define APPNIC_DMA_TX_TAIL_POINTER_LOCAL_COPY_POINTER 0x0fffff
+
+/*
+  ======================================================================
+  ======================================================================
+  ======================================================================
+
+  Access
+
+  N.B. On the APP, DMA transfers from the NIC MUST USE THE MEMORY
+  ALIAS AT 0x60000000!
+
+  ======================================================================
+  ======================================================================
+  ======================================================================
+*/
+
+#ifdef CONFIG_ACP
+
+#define readio( address ) in_le32( ( u32 * ) ( address ) )
+
+#define writeio( value, address ) out_le32( ( u32 * ) ( address ), ( value ) );
+
+static inline void
+readdescriptor( unsigned long address, appnic_dma_descriptor_t * descriptor )
+{
+  unsigned long * from = ( unsigned long * ) address;
+  unsigned long * to = ( unsigned long * ) descriptor;
+  * to ++ = swab32( * from ++ );
+  * to ++ = swab32( * from ++ );
+  * to ++ = swab32( * from ++ );
+  * to ++ = swab32( * from ++ );
+  return;
+}
+
+static inline void
+writedescriptor( unsigned long address,
+                 const appnic_dma_descriptor_t * descriptor )
+{
+  unsigned long * to = ( unsigned long * ) address;
+  unsigned long * from = ( unsigned long * ) descriptor;
+  * to ++ = swab32( * from ++ );
+  * to ++ = swab32( * from ++ );
+  * to ++ = swab32( * from ++ );
+  * to ++ = swab32( * from ++ );
+  return;
+}
+
+static inline appnic_queue_pointer_t
+swab_queue_pointer( const appnic_queue_pointer_t * old_queue )
+{
+  appnic_queue_pointer_t new_queue;
+  new_queue.raw = swab32( old_queue->raw );
+  return new_queue;
+}
+
+#define SWAB_QUEUE_POINTER( pointer ) \
+swab_queue_pointer( ( const appnic_queue_pointer_t * ) ( pointer ) )
+
+#else
+
+#define readio( address ) readl( ( address ) )
+
+#define writeio( value, address ) writel( ( value ), ( address ) )
+
+static inline void
+readdescriptor( unsigned long address, appnic_dma_descriptor_t * descriptor )
+{
+  memcpy( descriptor, ( void * ) address, sizeof( appnic_dma_descriptor_t ) );
+  return;
+}
+
+static inline void
+writedescriptor( unsigned long address,
+                 const appnic_dma_descriptor_t * descriptor )
+{
+  memcpy( ( void * ) address, descriptor, sizeof( appnic_dma_descriptor_t ) );
+  return;
+}
+
+static inline unsigned long
+swab_queue_pointer( unsigned long old_queue )
+{
+  return old_queue;
+}
+
+#endif
+
+#ifdef LOG_MAC_ACCESS
+
+static unsigned long read_mac_( unsigned int address ) {
+
+  unsigned long value_ = readio( address );
+
+  switch( address & 0xfffff000 ) {
+
+  case rx_base:
+    printk( "-MAC-   RX + 0x%04x => 0x%08lx\n", ( address & 0x1fff ), value_ );
+    break;
+
+  case tx_base:
+    printk( "-MAC-   TX + 0x%04x => 0x%08lx\n", ( address & 0x1fff ), value_ );
+    break;
+
+  case dma_base:
+    printk( "-MAC-  DMA + 0x%04x => 0x%08lx\n", ( address & 0x1fff ), value_ );
+    break;
+
+  default:
+    ERROR_PRINT( "ARGHHHHH!!!\n" );
+    break;
+
+  }
+
+  return value_;
+
+}
+
+static void write_mac_( unsigned long value, unsigned int address ) {
+
+  switch( address & 0xfffff000 ) {
+
+  case rx_base:
+    printk( "-MAC-   RX + 0x%04x <= 0x%08lx\n", ( address & 0x1fff ), value );
+    break;
+
+  case tx_base:
+    printk( "-MAC-   TX + 0x%04x <= 0x%08lx\n", ( address & 0x1fff ), value );
+    break;
+
+  case dma_base:
+    printk( "-MAC-  DMA + 0x%04x <= 0x%08lx\n", ( address & 0x1fff ), value );
+    break;
+
+  default:
+    ERROR_PRINT( "ARGHHHHH!!!\n" );
+    break;
+
+  }
+
+  writeio( value, address );
+  return;
+
+}
+
+#else  /* ! LOG_MAC_ACCESS */
+
+#define read_mac_( address ) readio( ( address ) )
+#define write_mac_( value, address ) writeio( ( value ), ( address ) )
+
+#endif
+
+#ifndef PHYLESS
+#ifdef LOG_PHY_ACCESS
+
+static unsigned long read_phy_( unsigned int address ) {
+
+  unsigned long value_ = readl( address );
+  printk( "-PHY- HOST + 0x%04x => 0x%08lx\n", ( address & 0xff ), value_ );
+  return value_;
+
+}
+
+static void write_phy_( unsigned long value, unsigned int address ) {
+
+  printk( "-PHY- HOST + 0x%04x <= 0x%08lx\n", ( address & 0xff ), value );
+  writel( value, address );
+  return;
+
+}
+
+#else  /* ! LOG_PHY_ACCESS */
+
+#define read_phy_( address ) readl( ( address ) )
+#define write_phy_( value, address ) writel( value, address )
+
+#endif
+#endif /* PHYLESS */
+
+/*
+  ======================================================================
+  ======================================================================
+  ======================================================================
+
+  Module Information
+
+  ======================================================================
+  ======================================================================
+  ======================================================================
+*/
+
+MODULE_AUTHOR( "John Jacques" );
+MODULE_DESCRIPTION( "Agere APP3xx ethernet driver" );
+MODULE_LICENSE( "GPL" );
+
+/*
+  ----- Note On Buffer Space -----
+
+  Minimum number of descriptors is 64 for the receiver and 64 for the
+  transmitter; therefore, 2048 bytes (16 bytes each).
+  This driver uses the following parameters,
+  all of which may be set on the command line if this drivers is used
+  as a module.
+
+  - rx_num_desc : Number of receive descriptors.  This  must be a multiple of
+  64.
+  - tx_num_desc : Number of transmit descriptors.  This must be a multiple of
+  64.
+
+  The scheme used will be as follows:
+
+  - num_[rt]x_desc will be adjusted to be a multiple of 64 (if necessary).
+  - An skb (with the data area 64 byte aligned) will be allocated for each rx
+  descriptor.
+*/
+
+/*
+  Receiver
+*/
+
+int rx_num_desc = ( CONFIG_LSI_NET_NUM_RX_DESC * DESCRIPTOR_GRANULARITY );
+module_param( rx_num_desc, int, 0 );
+MODULE_PARM_DESC( rx_num_desc, "appnic : Number of receive descriptors" );
+
+int rx_buf_sz = CONFIG_LSI_NET_RX_BUF_SZ;
+module_param( rx_buf_sz, int, 0 );
+MODULE_PARM_DESC( rx_buf_sz, "appnic : Receive buffer size" );
+
+/*
+  Transmitter
+*/
+
+int tx_num_desc = ( CONFIG_LSI_NET_NUM_TX_DESC * DESCRIPTOR_GRANULARITY );
+module_param( tx_num_desc, int, 0 );
+MODULE_PARM_DESC( tx_num_desc, "appnic : Number of receive descriptors" );
+
+int tx_buf_sz = CONFIG_LSI_NET_TX_BUF_SZ;
+module_param( tx_buf_sz, int, 0 );
+MODULE_PARM_DESC( tx_buf_sz, "Appnic : Receive buffer size" );
+
+/*
+  Timeout, if a transmit takes longer than this
+  value in jiffies it has timed out.
+*/
+
+#define DEFAULT_TX_TIMEOUT 10
+
+int tx_timeout = DEFAULT_TX_TIMEOUT;
+module_param( tx_timeout, int, 0 );
+MODULE_PARM_DESC( tx_timeout, "appnic : Transmit timeout (in jiffies)" );
+
+/*
+  Only 1 device is possible...
+*/
+
+struct net_device *this_net_device;
+
+static unsigned long dropped_by_stack_ = 0;
+static unsigned long out_of_tx_descriptors_ = 0;
+static unsigned long transmit_interrupts_ = 0;
+#ifdef LSINET_NAPI
+static unsigned long receive_interrupts_ = 0;
+#endif
+
+#define APPNIC_TIMER_PERIOD 5
+#ifndef PHYLESS
+static void appnic_timer_handler_( unsigned long );
+static struct timer_list appnic_timer_;
+#endif /* PHYLESS */
+
+/*
+  ======================================================================
+  ======================================================================
+  ======================================================================
+
+  Locking...
+
+  ======================================================================
+  ======================================================================
+  ======================================================================        
+*/
+
+#ifdef CONFIG_SMP
+/*
+ * On SMP we have the following problem:
+ *
+ *      A = smc_hard_start_xmit()
+ *      B = smc_interrupt()
+ *
+ * A and B can never be executed simultaneously.  However, at least on UP,
+ * it is possible (and even desirable) for C to interrupt execution of
+ * A or B in order to have better RX reliability and avoid overruns.
+ * C, just like A and B, must have exclusive access to the chip and
+ * each of them must lock against any other concurrent access.
+ * Unfortunately this is not possible to have C suspend execution of A or
+ * B taking place on another CPU. On UP this is no an issue since A and B
+ * are run from softirq context and C from hard IRQ context, and there is
+ * no other CPU where concurrent access can happen.
+ * If ever there is a way to force at least B and C to always be executed
+ * on the same CPU then we could use read/write locks to protect against
+ * any other concurrent access and C would always interrupt B. But life
+ * isn't that easy in a SMP world...
+ */
+
+#define appnic_special_trylock(lock)            \
+  ({                                            \
+        int __ret;                              \
+        local_irq_disable();                    \
+        __ret = spin_trylock(lock);             \
+        if (!__ret)                             \
+        local_irq_enable();                     \
+        __ret;                                  \
+  })
+#define appnic_special_lock(lock)               spin_lock_irq(lock)
+#define appnic_special_unlock(lock)             spin_unlock_irq(lock)
+#else
+#define appnic_special_trylock(lock)            (1)
+#define appnic_special_lock(lock)               do { } while (0)
+#define appnic_special_unlock(lock)             do { } while (0)
+#endif
+
+/*
+  ======================================================================
+  ======================================================================
+  ======================================================================
+
+  Utility Functions
+
+  ======================================================================
+  ======================================================================
+  ======================================================================        
+*/
+
+/*
+  ----------------------------------------------------------------------
+  clear_statistics_
+*/
+
+static void clear_statistics_( appnic_device_t * device ) {
+
+  int waste_;
+
+  /*
+    Clear memory.
+  */
+
+  memset( ( void * ) & ( device->stats ), 0,
+          sizeof( struct net_device_stats ) );
+
+  /*
+    Clear counters.
+  */
+
+  waste_ = read_mac_( APPNIC_RX_STAT_PACKET_OK ); /* rx_packets */
+  waste_ = read_mac_( APPNIC_TX_STAT_PACKET_OK ); /* tx_packets */
+  /* rx_bytes kept by driver. */
+  /* tx_bytes kept by driver. */
+  /* rx_errors will be the sum of the rx errors available. */
+  /* tx_errors will be the sum of the tx errors available. */
+  /* rx_dropped (unable to allocate skb) will be maintained by the driver */
+  /* tx_dropped (unable to allocate skb) will be maintained by the driver */
+  /* multicast */
+  waste_ = read_mac_( APPNIC_RX_STAT_MULTICAST );
+  /* collisions will be the sum of the three following. */
+  waste_ = read_mac_( APPNIC_TX_STATUS_LATE_COLLISION );
+  waste_ = read_mac_( APPNIC_TX_STATUS_EXCESSIVE_COLLISION );
+  waste_ = read_mac_( APPNIC_TX_STAT_COLLISION_ABOVE_WATERMARK );
+  /* rx_length_errors will be the sum of the two following. */
+  waste_ = read_mac_( APPNIC_RX_STAT_UNDERSIZE );
+  waste_ = read_mac_( APPNIC_RX_STAT_OVERSIZE );
+  /* rx_over_errors (out of descriptors?) maintained by the driver. */
+  /* rx_crc_errors */
+  waste_ = read_mac_( APPNIC_RX_STAT_CRC_ERROR );
+  /* rx_frame_errors */
+  waste_ = read_mac_( APPNIC_RX_STAT_ALIGN_ERROR );
+  /* rx_fifo_errors */
+  waste_ = read_mac_( APPNIC_RX_STAT_OVERFLOW );
+  /* rx_missed will not be maintained. */
+  /* tx_aborted_errors will be maintained by the driver. */
+  /* tx_carrier_errors will not be maintained. */
+  /* tx_fifo_errors */
+  waste_ = read_mac_( APPNIC_TX_STAT_UNDERRUN );
+  /* tx_heartbeat_errors */
+  /* tx_window_errors */
+
+  /* rx_compressed will not be maintained. */
+  /* tx_compressed will not be maintained. */
+
+  /*
+    That's all.
+  */
+
+  return;
+
+}
+
+/*
+  ----------------------------------------------------------------------
+  get_hw_statistics_
+
+  -- NOTES --
+
+  1) The hardware clears the statistics registers after a read.
+*/
+
+static void get_hw_statistics_( appnic_device_t * device ) {
+
+  /* tx_packets */
+  device->stats.tx_packets += read_mac_( APPNIC_TX_STAT_PACKET_OK );
+  /* multicast */
+  device->stats.multicast += read_mac_( APPNIC_RX_STAT_MULTICAST );
+  /* collision */
+  device->stats.collisions += read_mac_( APPNIC_TX_STATUS_LATE_COLLISION );
+  device->stats.collisions +=
+    read_mac_( APPNIC_TX_STATUS_EXCESSIVE_COLLISION );
+  device->stats.collisions +=
+    read_mac_( APPNIC_TX_STAT_COLLISION_ABOVE_WATERMARK );
+  /* rx_length_errors */
+  device->stats.rx_length_errors += read_mac_( APPNIC_RX_STAT_UNDERSIZE );
+  device->stats.rx_length_errors += read_mac_( APPNIC_RX_STAT_OVERSIZE );
+  /* tx_fifo_errors */
+  device->stats.tx_fifo_errors += read_mac_( APPNIC_TX_STAT_UNDERRUN );
+
+  /*
+    Lock this section out so the statistics maintained by the driver
+    don't get clobbered.
+  */
+
+  {
+
+    unsigned long flags_;
+
+    spin_lock_irqsave( & device->lock, flags_ );
+
+    device->stats.rx_errors +=
+      ( device->stats.rx_length_errors +
+        device->stats.rx_crc_errors +
+        device->stats.rx_frame_errors +
+        device->stats.rx_fifo_errors +
+        device->stats.rx_dropped +
+        device->stats.rx_over_errors );
+    device->stats.rx_dropped = 0;
+    device->stats.rx_over_errors = 0;
+
+    device->stats.tx_errors +=
+      ( device->stats.tx_fifo_errors +
+        device->stats.tx_aborted_errors );
+    device->stats.tx_aborted_errors = 0;
+
+    spin_unlock_irqrestore( & device->lock, flags_ );
+
+  }
+
+  /*
+    That's all.
+  */
+
+  return;
+
+}
+
+/*
+  ----------------------------------------------------------------------
+  queue_initialized_
+
+  Returns the number of descriptors that are ready to receive packets
+  or are waiting to transmit packets.  (from tail to head).
+*/
+
+static int queue_initialized_( appnic_queue_pointer_t head,
+                               appnic_queue_pointer_t tail,
+                               int size ) {
+  int initialized;
+
+  /* Calculate the number of descriptors currently initialized. */
+
+  if( head.bits.generation_bit == tail.bits.generation_bit ) {
+
+    /* same generation */
+    initialized = ( head.bits.offset - tail.bits.offset );
+
+  } else {
+
+    /* different generation */
+    initialized = head.bits.offset +
+      ( size * sizeof( appnic_dma_descriptor_t ) - tail.bits.offset );
+
+  }
+
+  /* number of descriptors is offset / sizeof( a descriptor ) */
+  initialized /= sizeof( appnic_dma_descriptor_t );
+
+  return initialized;
+}
+
+/*
+  ----------------------------------------------------------------------
+  queue_uninitialzed_
+
+  Returns the number of unused/uninitialized descriptors.  (from head to tail).
+*/
+
+static int queue_uninitialized_( appnic_queue_pointer_t head,
+                                 appnic_queue_pointer_t tail,
+                                 int size ) {
+
+  int allocated_;
+
+  /* calculate the number of descriptors currently unused/uninitialized */
+
+  if( head.bits.generation_bit == tail.bits.generation_bit ) {
+
+    /* same generation. */
+    allocated_ =
+      ( ( size * sizeof( appnic_dma_descriptor_t ) ) - head.bits.offset ) +
+      tail.bits.offset;
+
+  } else {
+
+    /* different generation. */
+    allocated_ = tail.bits.offset - head.bits.offset;
+
+  }
+
+  /* number of descriptors is offset / sizeof( a descriptor ). */
+  allocated_ /= sizeof( appnic_dma_descriptor_t );
+
+  /* that's all */
+  return allocated_;
+
+}
+
+/*
+  ----------------------------------------------------------------------
+  queue_increment_
+*/
+
+static void queue_increment_( appnic_queue_pointer_t * queue,
+                              int number_of_descriptors ) {
+
+  queue->bits.offset += sizeof( appnic_dma_descriptor_t );
+
+  if( ( number_of_descriptors * sizeof( appnic_dma_descriptor_t ) ) ==
+      queue->bits.offset ) {
+
+    queue->bits.offset = 0;
+    queue->bits.generation_bit = ( 0 == queue->bits.generation_bit ) ? 1 : 0;
+
+  }
+
+  return;
+
+}
+
+/*
+  ----------------------------------------------------------------------
+  queue_decrement_
+*/
+
+static void queue_decrement_( appnic_queue_pointer_t * queue,
+                              int number_of_descriptors ) {
+
+  if( 0 == queue->bits.offset ) {
+
+    queue->bits.offset =
+      ( ( number_of_descriptors - 1 ) * sizeof( appnic_dma_descriptor_t ) );
+    queue->bits.generation_bit = ( 0 == queue->bits.generation_bit ) ? 1 : 0;
+
+  } else {
+
+    queue->bits.offset -= sizeof( appnic_dma_descriptor_t );
+
+  }
+
+  return;
+
+}
+
+/*
+  ----------------------------------------------------------------------
+  dump_packet_
+*/
+
+#if 0
+static void dump_packet_( const char * title, const void * data, int length ) {
+
+  int data_index_ = 0;
+
+  printk( "\n--appnic--dump_packet_( %s, 0x%p, %d)\n", title, data, length );
+
+  while( data_index_ < ( length / 2 ) ) {
+
+    int output_index_;
+    unsigned short * data_ =
+      & ( ( ( unsigned short * ) data ) [ data_index_ ] );
+
+    for( output_index_ = 0;
+         ( output_index_ < 8 ) &&
+           ( ( output_index_ + data_index_ ) < length );
+         ++ output_index_, ++ data_index_ ) {
+
+      printk( "%04x ",
+              htons( ( ( unsigned short * ) data_ ) [ output_index_ ] ) );
+
+    }
+
+    printk( "\n" );
+
+  }
+
+}
+#endif
+
+/*
+  ----------------------------------------------------------------------
+  dump_descriptor_
+*/
+
+#if 0
+static void dump_descriptor_( const char * title,
+                              appnic_dma_descriptor_t * descriptor ) {
+
+  printk( "--appnic--dump_descriptor_( %s, 0x%p)\n", title, descriptor );
+  printk( "        byte_swapping_on=%d\n" \
+          " interrupt_on_completion=%d\n" \
+          "           end_of_packet=%d\n" \
+          "         start_of_packet=%d\n" \
+          "                   write=%d\n" \
+          "           transfer_type=0x%x\n" \
+          "              pdu_length=0x%x\n" \
+          "    data_transfer_length=0x%x\n" \
+          "   target_memory_address=0x%x\n" \
+          "host_data_memory_pointer=0x%x\n",
+          ( unsigned int ) ( descriptor->byte_swapping_on ),
+          ( unsigned int ) ( descriptor->interrupt_on_completion ),
+          ( unsigned int ) ( descriptor->end_of_packet ),
+          ( unsigned int ) ( descriptor->start_of_packet ),
+          ( unsigned int ) ( descriptor->write ),
+          ( unsigned int ) ( descriptor->transfer_type ),
+          ( unsigned int ) ( descriptor->pdu_length ),
+          ( unsigned int ) ( descriptor->data_transfer_length ),
+          ( unsigned int ) ( descriptor->target_memory_address ),
+          ( unsigned int ) ( descriptor->host_data_memory_pointer ) );
+
+}
+#endif
+
+/*
+  ----------------------------------------------------------------------
+  appnic_timer_handler_
+*/
+
+#ifndef PHYLESS
+
+static void appnic_timer_handler_( unsigned long __opaque ) {
+
+  struct net_device * device_ = ( struct net_device * ) __opaque;
+
+  PHY_DEBUG_PRINT( "Handling Timer Expiration.\n" );
+  enable_( device_ );
+  appnic_timer_.expires = jiffies + ( APPNIC_TIMER_PERIOD * HZ );
+  add_timer( & appnic_timer_ );
+
+}
+
+#endif
+
+/*
+  ----------------------------------------------------------------------
+  enable_
+
+  -- NOTES --
+
+  1) Does not change the default values in the extended and
+  half-duplex configuration registers.
+*/
+
+static int enable_( struct net_device * device ) {
+
+#ifndef PHYLESS
+
+  int return_code_ = 1;
+  int carrier_state_ = 0;
+  unsigned long rx_configuration_;
+  unsigned long tx_configuration_ = 0;
+  phy_status_t phy_status_;
+
+  rx_configuration_ = 
+    ( APPNIC_RX_CONF_STRIPCRC |
+      APPNIC_RX_CONF_RXFCE |
+      APPNIC_RX_CONF_TXFCE );
+  tx_configuration_ =
+    ( APPNIC_TX_CONF_ENABLE_SWAP_SA |
+      APPNIC_TX_CONF_APP_CRC_ENABLE |
+      APPNIC_TX_CONF_PAD_ENABLE );
+  TX_CONF_SET_IFG( tx_configuration_, 0xf );
+
+  DEBUG_PRINT( "Enabling the interface.\n" );
+
+  /*
+    Setup the receive and transmit configuration registers (using smii
+    status to set speed/duplex and check the link status).
+  */
+
+  if( ( 0 == phy_read_( phy_address_, PHY_STATUS, & phy_status_.raw ) ) &&
+      ( 0 == phy_read_( phy_address_, PHY_STATUS, & phy_status_.raw ) ) ) {
+
+    PHY_DEBUG_PRINT( "phy_status_.raw=0x%x\n", phy_status_.raw );
+
+    if( 1 == phy_status_.bits.autoneg_comp ) {
+
+      if( 1 == phy_status_.bits.link_status ) {
+
+        if( 1 == phy_speed_( phy_address_ ) ) {
+
+          rx_configuration_ |= APPNIC_RX_CONF_SPEED;
+          tx_configuration_ |= APPNIC_TX_CONF_SPEED;
+
+        }
+
+        if( 1 == phy_duplex_( phy_address_ ) ) {
+
+          rx_configuration_ |= APPNIC_RX_CONF_DUPLEX;
+          tx_configuration_ |= APPNIC_TX_CONF_DUPLEX;
+
+        }
+
+        rx_configuration_ |=
+          ( APPNIC_RX_CONF_ENABLE | APPNIC_RX_CONF_LINK );
+        tx_configuration_ |=
+          ( APPNIC_TX_CONF_LINK | APPNIC_TX_CONF_ENABLE );
+        return_code_ = 0;
+        carrier_state_ = 1;
+
+      } else {
+
+        netif_carrier_off( device );
+
+      }
+
+    } else {
+
+      netif_carrier_off( device );
+
+    }
+
+  } else {
+
+    ERROR_PRINT( "phy_read_( ) failed!\n" );
+
+  }
+
+#else  /* PHYLESS */
+
+  int return_code_ = 1;
+  int carrier_state_ = 0;
+  unsigned long rx_configuration_;
+  unsigned long tx_configuration_ = 0;
+
+  rx_configuration_ = APPNIC_RX_CONF_STRIPCRC;
+  tx_configuration_ =
+    ( APPNIC_TX_CONF_ENABLE_SWAP_SA |
+      APPNIC_TX_CONF_APP_CRC_ENABLE |
+      APPNIC_TX_CONF_PAD_ENABLE );
+  TX_CONF_SET_IFG( tx_configuration_, 0xf );
+
+  /*
+    100/Full
+  */
+#if 0
+  rx_configuration_ |=
+    ( APPNIC_RX_CONF_ENABLE | APPNIC_RX_CONF_LINK |
+      APPNIC_RX_CONF_DUPLEX | APPNIC_RX_CONF_SPEED );
+  tx_configuration_ |=
+    ( APPNIC_TX_CONF_ENABLE | APPNIC_TX_CONF_LINK |
+      APPNIC_TX_CONF_DUPLEX | APPNIC_TX_CONF_SPEED );
+#endif
+
+  /*
+    100/Half
+  */
+#if 1
+  rx_configuration_ |=
+    ( APPNIC_RX_CONF_ENABLE | APPNIC_RX_CONF_LINK |
+      APPNIC_RX_CONF_SPEED );
+  tx_configuration_ |=
+    ( APPNIC_TX_CONF_ENABLE | APPNIC_TX_CONF_LINK |
+      APPNIC_TX_CONF_SPEED );
+#endif
+
+  /*
+    10/Full
+  */
+#if 0
+  rx_configuration_ |=
+    ( APPNIC_RX_CONF_ENABLE | APPNIC_RX_CONF_LINK |
+      APPNIC_RX_CONF_DUPLEX );
+  tx_configuration_ |=
+    ( APPNIC_TX_CONF_ENABLE | APPNIC_TX_CONF_LINK |
+      APPNIC_TX_CONF_DUPLEX );
+#endif
+
+  /*
+    10/Half
+  */
+#if 0
+  rx_configuration_ |=
+    ( APPNIC_RX_CONF_ENABLE | APPNIC_RX_CONF_LINK );
+  tx_configuration_ |=
+    ( APPNIC_TX_CONF_ENABLE | APPNIC_TX_CONF_LINK );
+#endif
+
+  return_code_ = 0;
+  carrier_state_ = 1;
+
+#endif /* PHYLESS */
+
+  if( rx_configuration_ != read_mac_( APPNIC_RX_CONF ) ) {
+
+    write_mac_( rx_configuration_, APPNIC_RX_CONF );
+
+  }
+
+  if( tx_configuration_ != read_mac_( APPNIC_TX_CONF ) ) {
+
+    write_mac_( tx_configuration_, APPNIC_TX_CONF );
+
+  }
+
+  if( 0 != carrier_state_ ) {
+
+    netif_carrier_on( device );
+
+  } else {
+
+    netif_carrier_off( device );
+
+  }
+
+  return return_code_;
+
+}
+
+/*
+  ----------------------------------------------------------------------
+  disable_
+*/
+
+static void disable_( void ) {
+
+  unsigned long tx_configuration_;
+  unsigned long rx_configuration_;
+
+  DEBUG_PRINT( "Disabling the interface.\n" );
+
+  rx_configuration_ = read_mac_( APPNIC_RX_CONF );
+  rx_configuration_ &= ~ APPNIC_RX_CONF_ENABLE;
+  write_mac_( rx_configuration_, APPNIC_RX_CONF );
+
+  tx_configuration_ = read_mac_( APPNIC_TX_CONF );
+  tx_configuration_ &= ~ APPNIC_TX_CONF_ENABLE;
+  write_mac_( tx_configuration_, APPNIC_TX_CONF );
+
+  /* that's all. */
+  return;
+
+}
+
+void disable_nic_( void ) {
+
+  disable_( );
+
+}
+
+/*
+  ======================================================================
+  ======================================================================
+  ======================================================================
+  PHY interface (BCM5221)
+  ======================================================================
+  ======================================================================
+  ======================================================================
+*/
+
+#ifndef PHYLESS
+
+/*
+  ----------------------------------------------------------------------
+  phy_read_
+
+  Returns -1 if unsuccessful, the (short) value otherwise.
+*/
+
+static int
+phy_read_( int phy, int reg, unsigned short * value )
+{
+	return acp_mdio_read(phy, reg, value);
+}
+
+/*
+  ----------------------------------------------------------------------
+  phy_write_
+*/
+
+static int
+phy_write_( int phy, int reg, unsigned short value )
+{
+	return acp_mdio_write(phy, reg, value);
+}
+
+#ifndef CONFIG_ACP
+/*
+  ----------------------------------------------------------------------
+  phy_link_
+
+  Returns the link status (1=link up, 0=link down) or an error (-1).
+*/
+
+static int
+phy_link_( int phy )
+{
+	phy_status_t status;
+
+	phy_read_( phy, PHY_STATUS, & status.raw );
+	phy_read_( phy, PHY_STATUS, & status.raw );
+
+	return status.bits.link_status;
+}
+#endif
+
+/*
+  ----------------------------------------------------------------------
+  phy_speed_
+
+  Returns the speed (1=100, 0=10) or an error (-1).
+*/
+
+static int
+phy_speed_( int phy )
+{
+	micrel_phy_auxiliary_control_status_t aux;
+
+	phy_read_( phy, MICREL_PHY_AUXILIARY_CONTROL_STATUS, & aux.raw );
+	switch( ( aux.bits.op_mode_indication & 3 ) ) {
+	case 2: return 1; break;
+	case 1:	return 0; break;
+	default: break;
+	}
+
+	return -1;
+}
+
+/*
+  ----------------------------------------------------------------------
+  phy_duplex_
+
+  Returns duplex status (1=full duplex, 0=half duplex) or an error (-1).
+*/
+
+static int
+phy_duplex_( int phy )
+{
+	micrel_phy_auxiliary_control_status_t aux;
+
+	phy_read_( phy, MICREL_PHY_AUXILIARY_CONTROL_STATUS, & aux.raw );
+
+	return ( ( aux.bits.op_mode_indication >> 2 ) & 0x1 );
+}
+
+#ifndef CONFIG_ACP
+/*
+  ----------------------------------------------------------------------
+  phy_reset_
+*/
+
+static int
+phy_reset_( int phy )
+{
+	phy_control_t control;
+	int retries = 10;
+
+	phy_read_( phy, PHY_CONTROL, & control.raw );
+	control.bits.soft_reset = 1;
+	phy_write_( phy, PHY_CONTROL, control.raw );
+
+	do {
+	        phy_read_( phy, PHY_CONTROL, & control.raw );
+		-- retries;
+	} while( ( 0 < retries ) && ( 0 != control.bits.soft_reset ) );
+
+	if( 0 != control.bits.soft_reset ) {
+		printk( "phy_reset( %d ) failed.\n", phy );
+		return -1;
+	}
+
+	return 0;
+}
+#endif
+
+/*
+  ----------------------------------------------------------------------
+  phy_renegotiate_
+*/
+
+static int
+phy_renegotiate_( int phy )
+{
+	phy_control_t control;
+	phy_status_t status;
+	int autoneg_retries = 4;
+	int autoneg_complete_retries = 8;
+
+	printk( "Initiating Auto Negotiation" );
+	phy_write_( phy, PHY_AUTONEG_ADVERTISE, 0x61 );
+
+	do {
+		phy_read_( phy, PHY_CONTROL, & control.raw );
+		control.bits.restart_autoneg = 1;
+		phy_write_( phy, PHY_CONTROL, control.raw );
+
+		do {
+			udelay( 500000 );
+			phy_read_( phy, PHY_STATUS, & status.raw );
+		} while( ( 0 < -- autoneg_complete_retries ) &&
+			 ( 0 == status.bits.autoneg_comp ) );
+
+		if( 0 != status.bits.autoneg_comp ) {
+			break;
+		}
+
+		printk( "." );
+	} while( 0 < -- autoneg_retries );
+
+	printk( "\n" );
+
+	if( 0 == status.bits.autoneg_comp ) {
+		printk( "Auto Negotiation Failed\n" );
+		return -1;
+	}
+
+	printk( "Auto Negotiation Succeeded\n" );
+	return 0;
+}
+
+/*
+  ----------------------------------------------------------------------
+  phy_enable_
+*/
+
+extern int ubootenv_get( const char *, char * );
+
+static int phy_enable_( int phy ) {
+
+#ifdef CONFIG_ACP
+  phy_address_ = 0x1e;
+  phy_renegotiate_( phy_address_ );
+#else
+  /*
+    Set up the MDIO clock.
+  */
+
+  {
+
+    char mdio_clock_speed_string_ [ 256 ];
+    unsigned long mdio_clock_speed_;
+    unsigned long mdio_divisor_;
+
+    if( 0 != ubootenv_get( "mdio_clock", mdio_clock_speed_string_ ) ) {
+
+      mdio_clock_speed_ = 1250000;
+
+    } else {
+
+      mdio_clock_speed_ = simple_strtoul(  mdio_clock_speed_string_, NULL, 0 );
+
+    }
+
+#ifdef CONFIG_ARCH_APP3K
+    mdio_divisor_ =
+      ( ( get_core_speed( ) / 2 ) / mdio_clock_speed_ );
+#else
+    mdio_divisor_ = ( get_core_speed( ) / mdio_clock_speed_ );
+#endif
+
+    printk( "Setting the MDIO clock to %lu Hz (divisor=%lu)\n",
+            mdio_clock_speed_, mdio_divisor_ );
+    writel( mdio_divisor_, MDIO_CLK_ );
+
+  }
+
+  /*
+    Get the PHY address.
+  */
+
+  {
+
+    char phy_address_string_ [ 256 ];
+
+    if( 0 != ubootenv_get( "phy_address", phy_address_string_ ) ) {
+
+      phy_address_ = phy_scan_( );
+
+    } else {
+
+      phy_address_ = simple_strtoul( phy_address_string_, NULL, 0 );
+
+    }
+
+    if( 31 < phy_address_ || 0 > phy_address_ ) {
+
+      ERROR_PRINT( "Unable to get valid PHY address!\n" );
+      return -EBUSY;
+
+    }
+
+  }
+
+  /*
+    Get PHY type.
+  */
+
+  {
+
+    phy_id_high_t phy_id_high_;
+    phy_id_low_t phy_id_low_;
+
+    if( 0 != phy_read_( phy_address_, PHY_ID_HIGH_, & phy_id_high_.raw ) ) {
+
+      TRACE_ENDING( );
+      return -1;
+
+    }
+
+    if( 0 != phy_read_( phy_address_, PHY_ID_LOW_, & phy_id_low_.raw ) ) {
+
+      TRACE_ENDING( );
+      return -1;
+
+    }
+
+    if( ( PHY_ID_HIGH_ID == phy_id_high_.bits.id ) &&
+        ( BC_PHY_ID_LOW_ID_ == phy_id_low_.bits.id ) &&
+        ( BC_PHY_ID_LOW_MODEL_ == phy_id_low_.bits.model ) ) {
+
+      phy_type_ = BCM5221_PHY_;
+      printk( "Broadcomm 5221 PHY at 0x%x\n", phy_address_ );
+
+    } else if( ( M_PHY_ID_HIGH_ID_ == phy_id_high_.bits.id ) &&
+               ( M_PHY_ID_LOW_ID_ == phy_id_low_.bits.id ) ) {
+
+      phy_type_ = MICREL_PHY_;
+      printk( "Micrel PHY at 0x%x, Model 0x%x\n",
+              phy_address_, phy_id_low_.bits.model );
+
+    } else {
+
+      phy_type_ = UNKNOWN_PHY_;
+      printk( "Unknown PHY at 0x%x.  0x%x 0x%x 0x%x\n",
+              phy_address_, phy_id_high_.bits.id, phy_id_low_.bits.id,
+              phy_id_low_.bits.model );
+
+    }
+
+  }
+
+  if( -1 != phy_address_ ) {
+
+    int link_status_retries_ = 10;
+    phy_status_t phy_status_;
+    char ad_value_string_ [ 40 ];
+    unsigned short ad_value_;
+
+    DEBUG_PRINT( "Initializing PHY at 0x%x\n", phy_address_ );
+
+    if( 0 != phy_reset_( phy_address_ ) ) {
+
+      return -1;
+
+    }
+
+    /*
+      0x1e1 - 10/100 half/full
+      0xe1 - 100 half, 10 half/full
+      0x61 - 10 half/full
+      0x41 - 10 half
+    */
+
+    if( 0 != ubootenv_get( "ad_value", ad_value_string_ ) ) {
+
+      if( ( is_asic ) &&
+          ( 0 == ( APP3XX_REVISION_REGISTER & 0x1f ) ) ) {
+
+        /* 10M does not work on ASIC v1.0 */
+        ad_value_ = 0x0181;
+
+      } else {
+
+        /* For FGPA loads and any ASIC after v1.0, default to 10 full/half */
+        ad_value_ = 0x061;
+
+      }
+
+      WARN_PRINT( "ad_value not set, using 0x%x\n", ad_value_ );
+
+    } else {
+
+      ad_value_ = simple_strtoul( ad_value_string_, NULL, 0 );
+
+    }
+
+    if( 0 != phy_write_( phy_address_, PHY_AUTONEG_ADVERTISE_,
+                         ad_value_ ) ) {
+
+      TRACE_ENDING( );
+      return -1;
+
+    }
+
+    if( 0 != phy_renegotiate_( phy_address_ ) ) {
+
+      WARN_PRINT( "PHY: Auto Negotiation Failed.\n" );
+
+    }
+
+    do {
+
+      if( 0 != phy_read_( phy_address_, PHY_STATUS, & phy_status_.raw ) ) {
+
+        return -1;
+
+      }
+
+      mdelay( 10 );
+      -- link_status_retries_;
+
+    } while( ( 0 == phy_status_.bits.link_status ) &&
+             ( 0 < link_status_retries_ ) );
+
+    if( 0 == phy_status_.bits.link_status ) {
+
+      WARN_PRINT( "PHY: link down\n" );
+
+    } else {
+
+      printk( "PHY: link=%s speed=%d Mbs duplex=%s\n",
+              ( 1 == phy_link_( phy_address_ ) ) ? "up" : "down",
+              ( 1 == phy_speed_( phy_address_ ) ) ? 100 : 10,
+              ( 1 == phy_duplex_( phy_address_ ) ) ? "full" : "half" );
+
+    }
+
+  }
+
+#endif
+
+  /*
+    That's all
+  */
+
+  return 0;
+
+}
+
+#endif /* PHYLESS */
+
+/*
+  ======================================================================
+  ======================================================================
+  ======================================================================
+
+  Linux Network Driver Interface
+
+  ======================================================================
+  ======================================================================
+  ======================================================================        
+*/
+
+/*
+  ----------------------------------------------------------------------
+  handle_transmit_interrupt_
+*/
+
+static void handle_transmit_interrupt_( struct net_device * device ) {
+
+  appnic_device_t * dev_ = netdev_priv( device );
+
+  TRACE_BEGINNING( );
+  DEBUG_PRINT( "tail=0x%lx tail_copy=0x%lx head=0x%lx\n",
+               dev_->tx_tail->raw, dev_->tx_tail_copy.raw,
+               dev_->tx_head.raw );
+
+  /*
+    The hardware's tail pointer should be one descriptor (or more)
+    ahead of software's copy.
+  */
+
+  while( 0 < queue_initialized_( SWAB_QUEUE_POINTER( dev_->tx_tail ),
+                                 dev_->tx_tail_copy, dev_->tx_num_desc ) ) {
+    queue_increment_( & dev_->tx_tail_copy, dev_->tx_num_desc );
+  }
+
+  DEBUG_PRINT( "tail=0x%lx tail_copy=0x%lx head=0x%lx\n",
+               dev_->tx_tail->raw, dev_->tx_tail_copy.raw,
+               dev_->tx_head.raw );
+  TRACE_ENDING( );
+
+  return;
+
+}
+
+/*
+  ----------------------------------------------------------------------
+  lsinet_rx_packet
+*/
+
+static void
+lsinet_rx_packet( struct net_device * device )
+{
+  appnic_device_t * adapter = netdev_priv( device );
+  appnic_dma_descriptor_t descriptor;
+  struct sk_buff * sk_buff_;
+
+#ifdef __APPNIC_C_PROFILE__
+  unsigned long ts0_ = 0;
+  unsigned long ts1_ = 0;
+  unsigned long ts2_ = 0;
+  unsigned long ts3_ = 0;
+  int sent_up = 0;
+  ts0_ = ( 0xffffffff - readl( ( TIMER7_BASE + TIMER_n_VALUE ) ) );
+#endif /* __APPNIC_C_PROFILE__ */
+
+  /* TEMP HACK: 
+   * should use down_interruptible
+   */
+  spin_lock( & adapter->extra_lock );
+  TRACE_BEGINNING( );
+  DEBUG_PRINT( "head=0x%lx tail=0x%lx tail_copy=0x%lx\n",
+               adapter->rx_head.raw, adapter->rx_tail->raw,
+               adapter->rx_tail_copy.raw );
+  readdescriptor( ( ( unsigned long ) adapter->rx_desc +
+		    adapter->rx_tail_copy.bits.offset ), & descriptor );
+
+  if( ( struct sk_buff * ) 0 != ( sk_buff_ = dev_alloc_skb( 1600 ) ) ) {
+    unsigned bytes_copied_ = 0;
+    unsigned error_ = 0;
+    int return_code_;
+    unsigned long ok_, overflow_, crc_, align_;
+
+#ifdef __APPNIC_C_PROFILE__
+    ts1_ = ( 0xffffffff - readl( ( TIMER7_BASE + TIMER_n_VALUE ) ) );
+#endif /* __APPNIC_C_PROFILE__ */
+
+    ok_ = read_mac_( APPNIC_RX_STAT_PACKET_OK );
+    overflow_ = read_mac_( APPNIC_RX_STAT_OVERFLOW );
+    crc_ = read_mac_( APPNIC_RX_STAT_CRC_ERROR );
+    align_ = read_mac_( APPNIC_RX_STAT_ALIGN_ERROR );
+
+    /*
+      Copy the received packet into the skb.
+    */
+
+    while( 0 < queue_initialized_( SWAB_QUEUE_POINTER( adapter->rx_tail ),
+                                   adapter->rx_tail_copy, adapter->rx_num_desc ) ) {
+      /*TRACER_POST( "tail_copy=0x%x", adapter->rx_tail_copy.raw );*/
+#ifdef PRELOAD_RX_BUFFERS
+      {
+        unsigned char * buffer_;
+        buffer_ = skb_put( sk_buff_, descriptor.pdu_length );
+        memcmp( buffer_, buffer_, descriptor.pdu_length );
+        memcpy( ( void * ) buffer_,
+                ( void * ) ( descriptor.host_data_memory_pointer +
+                             adapter->dma_alloc_offset ),
+                descriptor.pdu_length );
+      }
+#else  /* PRELOAD_RX_BUFFERS */
+      memcpy( ( void * ) skb_put( sk_buff_, descriptor.pdu_length ),
+              ( void * ) ( descriptor.host_data_memory_pointer +
+                           adapter->dma_alloc_offset ),
+              descriptor.pdu_length );
+#endif /* PRELOAD_RX_BUFFERS */
+      bytes_copied_ += descriptor.pdu_length;
+      descriptor.data_transfer_length = adapter->rx_buf_per_desc;
+      writedescriptor( ( ( unsigned long ) adapter->rx_desc +
+			 adapter->rx_tail_copy.bits.offset ), & descriptor );
+      if( 0 != descriptor.error ) { error_ = 1; }
+      queue_increment_( & adapter->rx_tail_copy, adapter->rx_num_desc );
+      if( 0 != descriptor.end_of_packet ) { break; }
+      readdescriptor( ( ( unsigned long ) adapter->rx_desc +
+			adapter->rx_tail_copy.bits.offset ), & descriptor );
+    }
+
+    if( 0 == descriptor.end_of_packet ) {
+
+      ERROR_PRINT( "No end of packet! %lu/%lu/%lu/%lu\n",
+                   ok_, overflow_, crc_, align_ );
+      BUG( );
+      dev_kfree_skb( sk_buff_ );
+
+    } else {
+
+      if( 0 == error_ ) {
+
+        struct ethhdr * ethhdr_ = ( struct ethhdr * ) sk_buff_->data;
+        unsigned char broadcast_ [ ] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
+        unsigned char multicast_ [ ] = { 0x01, 0x00 };
+
+	LSINET_COUNTS_INC( LSINET_COUNTS_RX_GOOD );
+
+        if( ( 0 == memcmp( ( const void * ) & ( ethhdr_->h_dest [ 0 ] ),
+                           ( const void * ) & ( device->dev_addr [ 0 ] ),
+                           sizeof( ethhdr_->h_dest ) ) ) ||
+            ( 0 == memcmp( ( const void * ) & ( ethhdr_->h_dest [ 0 ] ),
+                           ( const void * ) & ( broadcast_ [ 0 ] ),
+                           sizeof( ethhdr_->h_dest ) ) ) ||
+            ( 0 == memcmp( ( const void * ) & (ethhdr_->h_dest [ 0 ] ),
+                           ( const void * ) & ( multicast_ [ 0 ] ),
+                           sizeof( multicast_ ) ) ) ) {
+
+#ifdef __APPNIC_C_PROFILE__
+          if( bytes_copied_ > rx_packet_size_max_ ) {
+            rx_packet_size_max_ = bytes_copied_;
+          } else if( bytes_copied_ < rx_packet_size_min_ ) {
+            rx_packet_size_min_ = bytes_copied_;
+          }
+          total_rx_bytes_ += bytes_copied_;
+
+          total_rx_packets_sent_up_++;
+          sent_up = 1;
+
+          ts2_ = ( 0xffffffff - readl( ( TIMER7_BASE + TIMER_n_VALUE ) ) );
+#endif /* __APPNIC_C_PROFILE__ */
+
+          adapter->stats.rx_bytes += bytes_copied_;
+          ++ adapter->stats.rx_packets;
+          sk_buff_->dev = device;
+          sk_buff_->protocol = eth_type_trans( sk_buff_, device );
+#ifdef LSINET_NAPI
+	  LSINET_COUNTS_INC( LSINET_COUNTS_RX_SENT );
+          return_code_ = netif_receive_skb( sk_buff_ );
+#else
+	  LSINET_COUNTS_INC( LSINET_COUNTS_RX_SENT );
+          return_code_ = netif_rx( sk_buff_ );
+#endif
+
+          if( NET_RX_DROP == return_code_ ) {
+
+            ++ dropped_by_stack_;
+	    LSINET_COUNTS_INC( LSINET_COUNTS_RX_DRPD );
+#if 0
+            ERROR_PRINT( "Packet dropped by stack: 0x%x!\n", return_code_ );
+	    {
+	      unsigned long * packet = ( unsigned long * ) sk_buff_->data;
+	      int data_index_ = 0;
+	      static int bug = 10;
+
+	      printk( "\n---------- Dropped Packet\n" );
+	      printk( "Head:0x%lx Tail:0x%lx Tail Copy:0x%x\n",
+		      adapter->rx_head.raw, adapter->rx_tail->raw,
+		      read_mac_( APPNIC_DMA_RX_TAIL_POINTER_LOCAL_COPY ) );
+	      printk( "Address:0x%lx Length:0x%x\n",
+		      ( unsigned long ) packet, bytes_copied_ );
+
+	      while( data_index_ < ( bytes_copied_ / 2 ) ) {
+
+		int output_index_;
+		unsigned short * data_ =
+		  & ( ( ( unsigned short * ) packet ) [ data_index_ ] );
+
+		for( output_index_ = 0;
+		     ( output_index_ < 8 ) && ( data_index_ < bytes_copied_ );
+		     ++ output_index_, ++ data_index_ ) {
+
+		  printk( "%04x ", htons( data_ [ output_index_ ] ) );
+
+		}
+
+		printk( "\n" );
+
+	      }
+
+	      if( 0 == -- bug ) BUG( );
+
+	    }
+#endif
+	  }
+
+	} else {
+
+          dev_kfree_skb( sk_buff_ );
+
+        }
+
+      } else {
+
+	LSINET_COUNTS_INC( LSINET_COUNTS_RX_ERR );
+
+        dev_kfree_skb( sk_buff_ );
+
+        if( 0 != overflow_ ) {
+
+          ++ adapter->stats.rx_fifo_errors;
+
+        } else if( 0 != crc_ ) {
+
+          ++ adapter->stats.rx_crc_errors;
+
+        } else if( 0 != align_ ) {
+
+          ++ adapter->stats.rx_frame_errors;
+
+        }
+
+      }
+
+    }
+
+  } else {
+
+    ERROR_PRINT( "dev_alloc_skb( ) failed!  Dropping packet.\n" );
+
+  }
+
+  DEBUG_PRINT( "head=0x%lx tail=0x%lx tail_copy=0x%lx\n",
+               adapter->rx_head.raw, adapter->rx_tail->raw,
+               adapter->rx_tail_copy.raw );
+  TRACE_ENDING( );
+
+#ifdef __APPNIC_C_PROFILE__
+
+  app3xx_profile_time_calc(ts0_, ts1_, 
+                           recv_t1_min_, recv_t1_max_, recv_t1_tot_);
+  /*
+   * only calculate stats for packets that were sent up to the stack
+   */
+  if (sent_up) {
+    ts3_ = ( 0xffffffff - readl( ( TIMER7_BASE + TIMER_n_VALUE ) ) );
+
+    app3xx_profile_time_calc(ts1_, ts2_, 
+                             recv_t2_min_, recv_t2_max_, recv_t2_tot_);
+    app3xx_profile_time_calc(ts2_, ts3_, 
+                             recv_t3_min_, recv_t3_max_, recv_t3_tot_);
+  }
+
+#endif /* __APPNIC_C_PROFILE__ */
+
+  /* TEMP */
+  spin_unlock( & adapter->extra_lock );
+  /* that's all */
+  return;
+
+}
+
+/*
+  ===============================================================================
+  lsinet_rx_packets
+*/
+
+static int
+lsinet_rx_packets( struct net_device * device, int max )
+{
+	appnic_device_t * adapter = netdev_priv( device );
+	appnic_queue_pointer_t queue;
+	int updated_head_pointer = 0;
+	int packets = 0;
+
+	queue.raw = adapter->rx_tail_copy.raw;
+
+	/* Receive Packets */
+
+	while( 0 < queue_initialized_( SWAB_QUEUE_POINTER( adapter->rx_tail ),
+				       queue, adapter->rx_num_desc ) ) {
+		appnic_dma_descriptor_t descriptor;
+
+		readdescriptor( ( ( unsigned long ) adapter->rx_desc +
+				  queue.bits.offset ),
+				& descriptor );
+
+		if( 0 != descriptor.end_of_packet ) {
+#ifdef __APPNIC_C_PROFILE__
+			++ packets_handled_;
+#endif /* __APPNIC_C_PROFILE__ */
+			LSINET_COUNTS_INC( LSINET_COUNTS_RX_PKT );
+			lsinet_rx_packet( device );
+			++ packets;
+			queue.raw = adapter->rx_tail_copy.raw;
+
+			if( -1 != max ) {
+				if( packets == max ) {
+					break;
+				}
+			}
+		} else {
+			queue_increment_( & queue, adapter->rx_num_desc );
+		}
+	}
+
+	/* Update the Head Pointer */
+
+	while( 1 < queue_uninitialized_( adapter->rx_head, adapter->rx_tail_copy,
+					 adapter->rx_num_desc ) ) {
+
+		appnic_dma_descriptor_t descriptor;
+
+		readdescriptor( ( ( unsigned long ) adapter->rx_desc +
+				  adapter->rx_head.bits.offset ), & descriptor );
+		descriptor.data_transfer_length = adapter->rx_buf_per_desc;
+		descriptor.write = 1;
+		descriptor.pdu_length = 0;
+		descriptor.start_of_packet = 0;
+		descriptor.end_of_packet = 0;
+		descriptor.interrupt_on_completion = 1;
+		writedescriptor( ( ( unsigned long ) adapter->rx_desc +
+				   adapter->rx_head.bits.offset ),
+				 & descriptor );
+		queue_increment_( & adapter->rx_head, adapter->rx_num_desc );
+		updated_head_pointer = 1;
+	}
+
+	if( 0 != updated_head_pointer ) {
+		write_mac_( adapter->rx_head.raw, APPNIC_DMA_RX_HEAD_POINTER );
+	}
+
+	return packets;
+}
+
+#ifdef LSINET_NAPI
+
+/*
+  ===============================================================================
+  lsinet_poll
+*/
+
+static int
+lsinet_poll( struct napi_struct * napi, int budget )
+{
+  appnic_device_t * adapter = container_of( napi, appnic_device_t, napi );
+  struct net_device * device = adapter->device;
+  appnic_queue_pointer_t queue_;
+
+  int cur_budget = budget;
+  int done;
+  unsigned long dma_interrupt_status_;
+#ifdef __APPNIC_C_PROFILE__
+  unsigned long packets_handled_ = 0;
+  unsigned long beginning_;
+  unsigned long end_;
+
+  beginning_ = ( 0xffffffff - readl( ( TIMER7_BASE + TIMER_n_VALUE ) ) );
+#endif /* __APPNIC_C_PROFILE__ */
+
+  LSINET_COUNTS_INC( LSINET_COUNTS_POL_START );
+  /* TEMP DEBUG: should be interruptible */
+  /*down( & adapter->poll_sem);*/
+
+  TRACE_BEGINNING( );
+  DEBUG_PRINT( "head=0x%x tail=0x%x tail_copy=0x%x\n",
+               adapter->rx_head.raw, adapter->rx_tail->raw,
+               adapter->rx_tail_copy.raw );
+  queue_.raw = adapter->rx_tail_copy.raw;
+
+#if 0
+  if (cur_budget > device->quota) {
+    cur_budget = device->quota;
+  }
+#endif
+
+  done = 1;
+
+  do {
+
+	  /* Acknowledge the RX interrupt. */
+	  write_mac_( ~APPNIC_DMA_INTERRUPT_ENABLE_RECEIVE , 
+		      APPNIC_DMA_INTERRUPT_STATUS );
+
+	  if( 0 == ( cur_budget -= lsinet_rx_packets( device, cur_budget ) ) ) {
+		  break;
+	  }
+
+	  dma_interrupt_status_ = read_mac_( APPNIC_DMA_INTERRUPT_STATUS );
+
+  } while ( (RX_INTERRUPT (dma_interrupt_status_)) && cur_budget );
+
+
+#if 0
+  device->quota -= packets_handled_;
+#endif
+
+  if (done) {
+    LSINET_COUNTS_INC( LSINET_COUNTS_POL_RNBL );
+    napi_complete( napi );
+    /* re-enable receive interrupts */
+    write_mac_( ( APPNIC_DMA_INTERRUPT_ENABLE_RECEIVE |
+                  APPNIC_DMA_INTERRUPT_ENABLE_TRANSMIT ),
+                APPNIC_DMA_INTERRUPT_ENABLE );
+  } 
+
+  DEBUG_PRINT( "head=0x%x tail=0x%x tail_copy=0x%x\n",
+               adapter->rx_head.raw, adapter->rx_tail->raw,
+               adapter->rx_tail_copy.raw );
+  TRACE_ENDING( );
+
+#ifdef __APPNIC_C_PROFILE__
+  end_ = ( 0xffffffff - readl( ( TIMER7_BASE + TIMER_n_VALUE ) ) );
+  app3xx_profile_time_calc(beginning_, end_, 
+                           time_in_rx_min_, time_in_rx_max_, total_rx_time_);
+
+
+  total_rx_packets_handled_ += packets_handled_;
+  if( packets_handled_ > max_rx_packets_handled_ ) {
+    max_rx_packets_handled_ = packets_handled_;
+  }
+  ++ total_polls_;
+#endif /* __APPNIC_C_PROFILE__ */
+
+  /* TEMP */
+  /*up( & adapter->poll_sem);*/
+  LSINET_COUNTS_INC( LSINET_COUNTS_POL_DONE );
+  return (done ? 0 : 1);
+
+}
+
+#else /* Not using NAPI, define the Rx interrupt handler instead */
+
+/*
+  ----------------------------------------------------------------------
+  handle_receive_interrupt_
+*/
+
+static void handle_receive_interrupt_(  struct net_device * device ) {
+
+  appnic_device_t * dev_ = netdev_priv( device );
+  appnic_queue_pointer_t queue_;
+
+#ifdef __APPNIC_C_PROFILE__
+  unsigned long beginning_;
+  unsigned long end_;
+  unsigned long packets_handled_ = 0;
+
+  beginning_ = ( 0xffffffff - readl( ( TIMER7_BASE + TIMER_n_VALUE ) ) );
+#endif /* __APPNIC_C_PROFILE__ */
+
+  LSINET_COUNTS_INC( LSINET_COUNTS_RX_START );
+  TRACE_BEGINNING( );
+  DEBUG_PRINT( "head=0x%lx tail=0x%lx tail_copy=0x%lx\n",
+               dev_->rx_head.raw, dev_->rx_tail->raw,
+               dev_->rx_tail_copy.raw );
+  queue_.raw = dev_->rx_tail_copy.raw;
+  lsinet_rx_packets( device, -1 );
+  DEBUG_PRINT( "head=0x%lx tail=0x%lx tail_copy=0x%lx\n",
+               dev_->rx_head.raw, dev_->rx_tail->raw,
+               dev_->rx_tail_copy.raw );
+  TRACE_ENDING( );
+  LSINET_COUNTS_INC( LSINET_COUNTS_RX_DONE );
+#ifdef __APPNIC_C_PROFILE__
+  end_ = ( 0xffffffff - readl( ( TIMER7_BASE + TIMER_n_VALUE ) ) );
+  app3xx_profile_time_calc(beginning_, end_, 
+                           time_in_rx_min_, time_in_rx_max_, total_rx_time_);
+
+
+  total_rx_packets_handled_ += packets_handled_;
+  if( packets_handled_ > max_rx_packets_handled_ ) {
+    max_rx_packets_handled_ = packets_handled_;
+  }
+  ++ total_rx_interrupts_;
+#endif /* __APPNIC_C_PROFILE__ */
+
+  return;
+
+}
+#endif /* else not NAPI */
+
+/*
+  ----------------------------------------------------------------------
+  appnic_isr_
+*/
+
+static irqreturn_t appnic_isr_( int irq, void * device_id ) {
+
+  struct net_device * device_ = ( struct net_device * ) device_id;
+  appnic_device_t * dev_ = netdev_priv( device_ );
+  unsigned long dma_interrupt_status_;
+  unsigned long flags;
+
+#ifdef __APPNIC_C_PROFILE__
+  unsigned beginning_jiffies_ = jiffies;
+#endif /* __APPNIC_C_PROFILE__ */
+
+  TRACE_BEGINNING( );
+  LSINET_COUNTS_INC( LSINET_COUNTS_ISR_START );
+
+  /* acquire the lock */
+  spin_lock_irqsave( & dev_->lock, flags );
+
+#if ! defined( PHYLESS ) && ! defined( CONFIG_ACP )
+  if( INT_MAC_RX == irq ) {
+
+    PHY_DEBUG_PRINT( "Handling PHY interrupt.\n" );
+
+    if( BCM5221_PHY_ == phy_type_ ) {
+
+      bc_phy_interrupt_t bc_phy_interrupt_;
+
+      ( void ) phy_read_( phy_address_,
+                          BC_PHY_INTERRUPT_, & bc_phy_interrupt_.raw );
+      bc_phy_interrupt_.raw = 0;
+      bc_phy_interrupt_.bits.enable = 1;
+      ( void ) phy_write_( phy_address_,
+                           BC_PHY_INTERRUPT_, bc_phy_interrupt_.raw );
+
+    } else if( MICREL_PHY_ == phy_type_ ) {
+
+      m_phy_interrupt_t m_phy_interrupt_;
+
+      ( void ) phy_read_( phy_address_,
+                          M_PHY_INTERRUPT_, & m_phy_interrupt_.raw );
+      ( void ) phy_write_( phy_address_,
+                           M_PHY_INTERRUPT_, m_phy_interrupt_.raw );
+
+    }
+
+    write_mac_( 0, APPNIC_RX_INTERRUPT_STATUS );
+    enable_( device_ );
+
+  } else {
+#endif /* PHYLESS */
+    /* get the status */
+    dma_interrupt_status_ = read_mac_( APPNIC_DMA_INTERRUPT_STATUS );
+#ifdef LSINET_NAPI
+    /* NAPI - don't ack RX interrupt */
+    write_mac_( APPNIC_DMA_INTERRUPT_ENABLE_RECEIVE, APPNIC_DMA_INTERRUPT_STATUS );
+#else
+    write_mac_( 0, APPNIC_DMA_INTERRUPT_STATUS );
+#endif
+
+    /*TRACER_POST( "dma_interrupt_status_=0x%x", dma_interrupt_status_ );*/
+
+    /* handle interrupts */
+
+    if( TX_INTERRUPT( dma_interrupt_status_ ) ) {
+      LSINET_COUNTS_INC( LSINET_COUNTS_ISR_TX );
+      /* transmition complete */
+      ++ transmit_interrupts_;
+      handle_transmit_interrupt_( device_ );
+    }
+
+    if( RX_INTERRUPT( dma_interrupt_status_ ) ) {
+      LSINET_COUNTS_INC( LSINET_COUNTS_ISR_RX );
+#ifdef LSINET_NAPI
+      ++ receive_interrupts_;
+      if (napi_schedule_prep(&dev_->napi)) {
+        /* disable RX interrupts and tell the system we've got work */
+        write_mac_( APPNIC_DMA_INTERRUPT_ENABLE_TRANSMIT , 
+                    APPNIC_DMA_INTERRUPT_ENABLE );
+        __napi_schedule(&dev_->napi);
+      } else {
+        ERROR_PRINT( "NAPI bug! interrupt while in poll\n");
+        write_mac_( APPNIC_DMA_INTERRUPT_ENABLE_TRANSMIT , 
+                    APPNIC_DMA_INTERRUPT_ENABLE );
+      }
+#else
+      /* receive complete */
+      handle_receive_interrupt_( device_ );
+#endif
+    }
+#if ! defined( PHYLESS ) && ! defined( CONFIG_ACP )
+  }
+#endif /* PHYLESS */
+
+  /* release the lock */
+  spin_unlock_irqrestore( & dev_->lock, flags );
+
+  LSINET_COUNTS_INC( LSINET_COUNTS_ISR_DONE );
+  TRACE_ENDING( );
+
+#ifdef __APPNIC_C_PROFILE__
+  if( jiffies != beginning_jiffies_ ) {
+    ++ jiffies_changed_;
+  }
+#endif /* __APPNIC_C_PROFILE__ */
+
+  return IRQ_HANDLED;
+
+}
+
+/*
+  ----------------------------------------------------------------------
+  appnic_open
+
+  Opens the interface.  The interface is opened whenever ifconfig
+  activates it.  The open method should register any system resource
+  it needs (I/O ports, IRQ, DMA, etc.) turn on the hardware, and
+  increment the module usage count.
+*/
+
+int appnic_open( struct net_device * device ) {
+
+  int return_code_ = 0;
+#if defined( CONFIG_ARCH_APP3 )
+  unsigned long gpio_mux_ = readl( APP3XX_HB_CONF_BASE + 0x18 );
+#elif defined( CONFIG_ARCH_APP3K )
+  /*unsigned long gpio_mux_ = readl( APP_AEI_BASE + 0x18 );*/
+#endif
+
+  /* enable the receiver and transmitter */
+  if( 0 != enable_( device ) ) {
+
+    ERROR_PRINT( "Unable to enable the interface.\n" );
+    disable_( );
+    return -EBUSY;
+
+  }
+
+#ifdef LSINET_NAPI
+  {
+    appnic_device_t * adapter = netdev_priv( device );
+    napi_enable( & adapter->napi );
+  }
+#endif /* LSINET_NAPI */
+
+  /* install the interrupt handlers */
+  if( 0 != ( return_code_ = request_irq( device->irq, appnic_isr_, IRQF_DISABLED,
+                                         APPNIC_NAME, device ) ) ) {
+
+    ERROR_PRINT( "request_irq( ) failed, returned 0x%x/%d\n",
+                 return_code_, return_code_ );
+    return return_code_;
+
+  }
+
+  /* enable interrupts */
+  write_mac_( ( APPNIC_DMA_INTERRUPT_ENABLE_RECEIVE |
+                APPNIC_DMA_INTERRUPT_ENABLE_TRANSMIT ),
+              APPNIC_DMA_INTERRUPT_ENABLE );
+
+  {
+
+#ifndef PHYLESS
+#ifndef CONFIG_ACP
+    char phy_string_ [ 256 ];
+    int use_interrupts_ = 1;
+#endif
+    appnic_device_t * dev_ = netdev_priv( device );
+#endif
+
+#ifdef CONFIG_ARCH_APP3
+
+    PHY_DEBUG_PRINT( "phy_type_=0x%x gpio_mux_=0x%x\n", phy_type_, gpio_mux_ );
+
+    if( ( BCM5221_PHY_ != phy_type_ ) ||
+        ( 0x04000000 != ( gpio_mux_ & 0x04000000 ) ) ) {
+
+      use_interrupts_ = 0;
+
+    }
+
+#endif
+
+#ifndef PHYLESS
+
+#ifndef CONFIG_ACP
+
+    if( ( 0 != ubootenv_get( "phy_mode", phy_string_ ) ) ||
+        ( 0 == strncmp( phy_string_, "poll", strlen( "poll" ) ) ) ) {
+
+      use_interrupts_ = 0;
+
+    }
+
+    PHY_DEBUG_PRINT( "use_interrupts_=%d\n", use_interrupts_ );
+
+    if( 1 == use_interrupts_ ) {
+
+      if( BCM5221_PHY_ == phy_type_ ) {
+
+        bc_phy_interrupt_t bc_phy_interrupt_;
+
+        bc_phy_interrupt_.raw = 0;
+        bc_phy_interrupt_.bits.enable = 1;
+
+        if( 0 != phy_write_( phy_address_, BC_PHY_INTERRUPT_,
+                             bc_phy_interrupt_.raw ) ) {
+
+          return -EBUSY;
+
+        }
+
+        if( 0 != phy_read_( phy_address_, BC_PHY_INTERRUPT_,
+                            & bc_phy_interrupt_.raw ) ) {
+
+          return -EBUSY;
+
+        }
+
+      } else if( MICREL_PHY_ == phy_type_ ) {
+
+        m_phy_interrupt_t m_phy_interrupt_;
+
+        m_phy_interrupt_.raw = 0;
+        m_phy_interrupt_.bits.enable_link_up = 1;
+
+        if( 0 != phy_write_( phy_address_, M_PHY_INTERRUPT_,
+                             m_phy_interrupt_.raw ) ) {
+
+          return -EBUSY;
+
+        }
+
+      }
+
+      if( 0 != ( return_code_ =
+                 request_irq( INT_MAC_RX, appnic_isr_, 0,
+                              APPNIC_NAME "(phy)", device ) ) ) {
+
+        ERROR_PRINT( "request_irq( ) failed, returned 0x%x/%d\n",
+                     return_code_, return_code_ );
+        return return_code_;
+
+      }
+
+      write_mac_( ( APPNIC_RX_EXTERNAL_INTERRUPT_CONTROL_MAC_0 ),
+                  APPNIC_RX_EXTERNAL_INTERRUPT_CONTROL );
+      dev_->polling = 0;
+
+    } else {
+
+#endif
+
+#ifndef CONFIG_ACP
+      WARN_PRINT( "PHY is in polling mode.\n" );
+#endif
+      init_timer( & appnic_timer_ );
+      appnic_timer_.expires = jiffies + ( APPNIC_TIMER_PERIOD * HZ );
+      appnic_timer_.data = ( unsigned long ) device;
+      appnic_timer_.function = appnic_timer_handler_;
+      add_timer( & appnic_timer_ );
+      dev_->polling = 1;
+
+#ifndef CONFIG_ACP
+
+    }
+
+#endif
+
+#endif /* PHYLESS */
+
+  }
+
+  /* let the OS know we are ready to send packets */
+  netif_start_queue( device );
+
+  /* that's all */
+  return 0;
+
+}
+
+/*
+  ----------------------------------------------------------------------
+  appnic_stop
+
+  Stops the interface.  The interface is stopped when it is broughht
+  down; operations performed at open time should be reversed.
+*/
+
+int appnic_stop( struct net_device * device ) {
+
+  int return_code_ = 0;
+
+  DEBUG_PRINT( "Stopping the interface.\n" );
+
+  /*
+    Indicate to the OS that no more packets should be sent.
+  */
+
+  netif_stop_queue( device );
+
+  /*
+    Stop the receiver and transmitter.
+  */
+
+  disable_( );
+
+  /* Disable NAPI. */
+#ifdef LSINET_NAPI
+  {
+    appnic_device_t * adapter = netdev_priv( device );
+    napi_disable( & adapter->napi );
+  }
+#endif
+
+  /*
+    Free the interrupts.
+  */
+
+  free_irq( device->irq, device );
+
+#ifndef PHYLESS
+
+  {
+#ifndef CONFIG_ACP
+    appnic_device_t * dev_ = netdev_priv( device );
+    if( 0 != dev_->polling ) { del_timer( & appnic_timer_ ); }
+    else { free_irq( INT_MAC_RX, device ); }
+#else
+    del_timer( & appnic_timer_ );
+#endif
+  }
+
+#endif /* PHYLESS */
+
+  /*
+    That's all.
+  */
+
+  return return_code_;
+
+}
+
+/*
+  ----------------------------------------------------------------------
+  appnic_hard_start_xmit
+
+  The method initiates the transmission of a packet.  The full packet
+  (protocol headers and all) is contained in a socket buffer (sk_buff)
+  structure.
+
+  ----- NOTES -----
+
+  1) This will not get called again by the kernel until it returns.
+*/
+
+int
+appnic_hard_start_xmit( struct sk_buff * skb,
+			struct net_device * device )
+{
+  appnic_device_t * adapter = netdev_priv( device );
+  int length_;
+  int buf_per_desc_;
+
+#ifdef __APPNIC_C_PROFILE__
+  unsigned long beginning_;
+  unsigned long end_;
+  unsigned long this_time_;
+
+  beginning_ = ( 0xffffffff - readl( ( TIMER7_BASE + TIMER_n_VALUE ) ) );
+  ++ total_tx_packets_;
+#endif /* __APPNIC_C_PROFILE__ */
+
+  LSINET_COUNTS_INC( LSINET_COUNTS_HST_START );
+  appnic_special_lock( & adapter->lock );
+  length_ = skb->len < ETH_ZLEN ? ETH_ZLEN : skb->len;
+  buf_per_desc_ = adapter->tx_buf_sz / adapter->tx_num_desc;
+
+  /*
+    If enough transmit descriptors are available, copy and transmit.
+  */
+
+  DEBUG_PRINT( "length_=%d buf_per_desc_=%d tx_tail=0x%x\n",
+	       length_, buf_per_desc_, swab32( adapter->tx_tail->raw ) );
+
+#if 0
+  if( ( ( length_ / buf_per_desc_ ) + 1 ) >=
+      queue_uninitialized_( adapter->tx_head, SWAB_QUEUE_POINTER( adapter->tx_tail ),
+                            adapter->tx_num_desc ) ) {
+    LSINET_COUNTS_INC( LSINET_COUNTS_HST_RCLM );
+    handle_transmit_interrupt_( device );
+  }
+#else
+  while( ( ( length_ / buf_per_desc_ ) + 1 ) >=
+	 queue_uninitialized_( adapter->tx_head,
+			       SWAB_QUEUE_POINTER( adapter->tx_tail ),
+			       adapter->tx_num_desc ) ) {
+    udelay( 1000 );
+    LSINET_COUNTS_INC( LSINET_COUNTS_HST_RCLM );
+    handle_transmit_interrupt_( device );
+  }
+#endif
+
+  if( ( ( length_ / buf_per_desc_ ) + 1 ) <
+      queue_uninitialized_( adapter->tx_head, SWAB_QUEUE_POINTER( adapter->tx_tail ),
+                            adapter->tx_num_desc ) ) {
+    int bytes_copied_ = 0;
+    appnic_dma_descriptor_t descriptor;
+
+    LSINET_COUNTS_INC( LSINET_COUNTS_HST_SNDG );
+    readdescriptor( ( ( unsigned long ) adapter->tx_desc +
+		      adapter->tx_head.bits.offset ), & descriptor );
+    descriptor.start_of_packet = 1;
+
+    while( bytes_copied_ < length_ ) {
+      descriptor.write = 1;
+      descriptor.pdu_length = length_;
+
+      if( ( length_ - bytes_copied_ ) > buf_per_desc_ ) {
+        memcpy( ( void * ) ( descriptor.host_data_memory_pointer +
+                             adapter->dma_alloc_offset ),
+                ( void * ) ( ( unsigned long ) skb->data + bytes_copied_ ),
+                buf_per_desc_ );
+        descriptor.data_transfer_length = buf_per_desc_;
+        descriptor.end_of_packet = 0;
+        descriptor.interrupt_on_completion = 0;
+        bytes_copied_ += buf_per_desc_;
+      } else {
+        memcpy( ( void * ) ( descriptor.host_data_memory_pointer +
+                             adapter->dma_alloc_offset ),
+                ( void * ) ( ( unsigned long ) skb->data + bytes_copied_ ),
+                ( length_ - bytes_copied_ ) );
+        descriptor.data_transfer_length = ( length_ - bytes_copied_ );
+        descriptor.end_of_packet = 1;
+#ifdef DISABLE_TX_INTERRUPTS
+        descriptor.interrupt_on_completion = 0;
+#else  /* DISABLE_TX_INTERRUPTS */
+        descriptor.interrupt_on_completion = 1;
+#endif /* DISABLE_TX_INTERRUPTS */
+        bytes_copied_ = length_;
+      }
+
+      adapter->stats.tx_bytes += bytes_copied_;
+      writedescriptor( ( ( unsigned long ) adapter->tx_desc +
+		      adapter->tx_head.bits.offset ), & descriptor );
+      queue_increment_( & adapter->tx_head, adapter->tx_num_desc );
+      readdescriptor( ( ( unsigned long ) adapter->tx_desc +
+			adapter->tx_head.bits.offset ), & descriptor );
+      descriptor.start_of_packet = 0;
+    }
+
+    write_mac_( adapter->tx_head.raw, APPNIC_DMA_TX_HEAD_POINTER );
+    device->trans_start = jiffies;
+    LSINET_COUNTS_INC( LSINET_COUNTS_HST_SNT );
+  } else {
+    ++ out_of_tx_descriptors_;
+    LSINET_COUNTS_INC( LSINET_COUNTS_HST_OOD );
+    ERROR_PRINT( "No transmit descriptors available!\n" );
+  }
+
+  /* free the socket buffer */
+  dev_kfree_skb( skb );
+  appnic_special_unlock( & adapter->lock );
+
+#ifdef __APPNIC_C_PROFILE__
+  end_ = ( 0xffffffff - readl( ( TIMER7_BASE + TIMER_n_VALUE ) ) );
+  if( end_ > beginning_ ) {
+    this_time_ = end_ - beginning_;
+  } else {
+    this_time_ = end_ + ( 0xffffffff - beginning_ ) + 1;
+  }
+  total_tx_time_ += this_time_;
+  if( this_time_ > time_in_tx_max_ ) { time_in_tx_max_ = this_time_; }
+  if( this_time_ < time_in_tx_min_ ) { time_in_tx_min_ = this_time_; }
+#endif /* __APPNIC_C_PROFILE__ */
+
+  LSINET_COUNTS_INC( LSINET_COUNTS_HST_DONE );
+  return 0;
+
+}
+
+/*
+  ----------------------------------------------------------------------
+  appnic_tx_timeout
+
+  This method is called when a packet transmission fails to complete
+  within a resonable period, on the assumption that an interrupt has
+  been missed or the interface has locked up.  It should handle the
+  problem and resume packet transmission.
+*/
+
+void appnic_tx_timeout( struct net_device * device ) {
+
+  appnic_device_t * adapter = netdev_priv( device );
+
+  WARN_PRINT( "Transmission timed out!\n" );
+
+  if( 0 == queue_initialized_( SWAB_QUEUE_POINTER( adapter->tx_tail ),
+                               adapter->tx_tail_copy, adapter->tx_num_desc ) ) {
+    /*
+      If tx_tail is still the same as tx_tail_copy
+      then restart the transmission.
+    */
+
+    write_mac_( adapter->tx_head.raw, APPNIC_DMA_TX_HEAD_POINTER );
+  } else {
+    /* If tx_tail has moved on, just increment tx_tail_copy. */
+    appnic_dma_descriptor_t descriptor;
+
+    readdescriptor( ( ( unsigned long ) adapter->tx_desc +
+		      adapter->tx_tail_copy.bits.offset ), & descriptor );
+    adapter->stats.tx_bytes += descriptor.pdu_length;
+    kfree( ( void * ) descriptor.host_data_memory_pointer );
+    queue_increment_( & adapter->tx_tail_copy, adapter->tx_num_desc );
+  }
+
+  return;
+
+}
+
+/*
+  ----------------------------------------------------------------------
+  appnic_net_device_stats
+
+  Whenever an application needs to get statistics for the interface,
+  this method is called.  This happens, for example, when ifconfig or
+  nstat -i is run.
+*/
+
+struct net_device_stats *
+appnic_get_stats( struct net_device * device )
+{
+
+  appnic_device_t * device_ = netdev_priv( device );
+
+  /*
+    Update the statistics structure.
+  */
+
+  get_hw_statistics_( device_ );
+
+  /*
+    That's all.
+  */
+
+  return & device_->stats;
+
+}
+
+/*
+  ----------------------------------------------------------------------
+  appnic_do_ioctl
+*/
+
+#if 0
+
+static int
+appnic_do_ioctl( struct net_device * device, struct ifreq * request,
+                 int command )
+{
+
+  int return_code_ = 0;
+#ifndef PHYLESS
+  u16 * data_ = ( u16 * ) & ( request->ifr_data );
+#endif
+
+  switch( command ) {
+    /* Get the speed. */
+  case 0x8946:
+    break;
+#ifndef PHYLESS
+    /* Get the PHY (defined in 2.5.x kernels) */
+  case 0x89f0:
+    data_ [ 0 ] = phy_address_;
+    break;
+    /* Read PHY (defined in 2.5.x kernels) */
+  case 0x89f1:
+    if( 0 != phy_read_( data_ [ 0 ], data_ [ 1 ],
+                        & ( data_ [ 3 ] ) ) ) {
+      return_code_ = -EIO;
+    }
+    break;
+    /* Write PHY (defined in 2.5.x kernels) */
+  case 0x89f2:
+    if( 0 != phy_write_( data_ [ 0 ], data_ [ 1 ], data_ [ 2 ] ) ) {
+      return_code_ = -EIO;
+    }
+    break;
+#endif
+  default:
+    ERROR_PRINT( "Unknown Command: 0x%x\n", command );
+    break;
+  }
+
+  return return_code_;
+
+}
+
+#endif
+
+/*
+  ----------------------------------------------------------------------
+  appnic_set_mac_address
+*/
+
+static int
+appnic_set_mac_address(struct net_device *device, void *data) {
+	struct sockaddr *address_ = data;
+	unsigned long swap_source_address_;
+
+	if (netif_running(device))
+		return -EBUSY;
+
+	DEBUG_PRINT("Setting MAC to %02x:%02x:%02x:%02x:%02x:%02x\n",
+		    address_->sa_data [0], address_->sa_data [1],
+		    address_->sa_data [2], address_->sa_data [3],
+		    address_->sa_data [4], address_->sa_data [5]);
+	memcpy(device->dev_addr, address_->sa_data, 6);
+	memcpy(device->perm_addr, address_->sa_data, 6);
+
+	swap_source_address_ =
+		((address_->sa_data[4]) << 8) | address_->sa_data[5];
+	write_mac_(swap_source_address_, APPNIC_SWAP_SOURCE_ADDRESS_2);
+	swap_source_address_ =
+		((address_->sa_data[2]) << 8) | address_->sa_data[3];
+	write_mac_(swap_source_address_, APPNIC_SWAP_SOURCE_ADDRESS_1);
+	swap_source_address_ =
+		((address_->sa_data[0]) << 8) | address_->sa_data[1];
+	write_mac_(swap_source_address_, APPNIC_SWAP_SOURCE_ADDRESS_0);
+	memcpy(device->dev_addr, address_->sa_data, device->addr_len);
+
+	return 0;
+}
+
+/*
+  ======================================================================
+  ======================================================================
+  ======================================================================
+
+  ETHTOOL Operations
+
+  ======================================================================
+  ======================================================================
+  ======================================================================
+*/
+
+/*
+  ----------------------------------------------------------------------
+  appnic_get_settings
+*/
+
+static int
+appnic_get_settings( struct net_device * device, struct ethtool_cmd * command )
+{
+  appnic_device_t * appnic_device_ = netdev_priv( device );
+
+  memset( command, 0, sizeof( struct ethtool_cmd ) );
+
+  /* What the hardware supports. */
+  command->supported =
+    ( SUPPORTED_10baseT_Half |
+      SUPPORTED_10baseT_Full |
+      SUPPORTED_100baseT_Half |
+      SUPPORTED_100baseT_Full );
+
+  /* Acquire the device lock. */
+  appnic_special_lock( & appnic_device_->lock );
+
+#ifndef PHYLESS
+
+  /* What is currently advertised. */
+
+  {
+
+    unsigned short ad_value_;
+
+    if( 0 != phy_read_( phy_address_, PHY_AUTONEG_ADVERTISE, & ad_value_ ) ) {
+
+      ERROR_PRINT( "PHY read failed!" );
+      appnic_special_unlock( & appnic_device_->lock );
+      return -EIO;
+
+    }
+
+    switch( ad_value_ ) {
+
+    case 0x1e1:
+      command->advertising =
+        ( ADVERTISED_100baseT_Full | ADVERTISED_100baseT_Half |
+          ADVERTISED_10baseT_Full | ADVERTISED_10baseT_Half );
+      break;
+
+    case 0xe1:
+      command->advertising =
+        ( ADVERTISED_100baseT_Half |
+          ADVERTISED_10baseT_Full | ADVERTISED_10baseT_Half );
+      break;
+
+    case 0x61:
+      command->advertising =
+        ( ADVERTISED_10baseT_Full | ADVERTISED_10baseT_Half );
+      break;
+
+    case 0x41:
+      command->advertising =
+        ( ADVERTISED_10baseT_Half );
+      break;
+
+    default:
+      break;
+
+    }
+
+  }
+
+  /* The current speed. */
+
+  {
+
+    int speed_;
+
+    if( -1 == ( speed_ = phy_speed_( phy_address_ ) ) ) {
+
+      ERROR_PRINT( "PHY read failed!" );
+      appnic_special_unlock( & appnic_device_->lock );
+      return -EIO;
+
+    }
+
+    if( 1 == speed_ ) {
+
+      command->speed = SPEED_100;
+
+    } else {
+
+      command->speed = SPEED_10;
+
+    }
+
+  }
+
+  /* Is the current link duplex? */
+
+  {
+
+    int duplex_;
+
+    if( -1 == ( duplex_ = phy_duplex_( phy_address_ ) ) ) {
+
+      ERROR_PRINT( "PHY read failed!" );
+      appnic_special_unlock( & appnic_device_->lock );
+      return -EIO;
+
+    }
+
+    if( 1 == duplex_ ) {
+
+      command->duplex = DUPLEX_FULL;
+
+    } else {
+
+      command->duplex = DUPLEX_HALF;
+
+    }
+
+  }
+
+#endif /* PHYLESS */
+
+  /* Is autoneg enabled? */
+  command->autoneg = AUTONEG_ENABLE;
+
+  /* Unlock and return success. */
+  appnic_special_unlock( & appnic_device_->lock );
+
+  return 0;
+
+}
+
+/*
+  Fill in the struture...
+*/
+
+static const struct ethtool_ops appnic_ethtool_ops = {
+  .get_settings = appnic_get_settings
+};
+  
+
+/*
+  ======================================================================
+  ======================================================================
+  ======================================================================
+
+  Linux Module Interface.
+
+  ======================================================================
+  ======================================================================
+  ======================================================================
+*/
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 29)
+static const struct net_device_ops appnic_netdev_ops = {
+       .ndo_open = appnic_open,
+       .ndo_stop = appnic_stop,
+       .ndo_get_stats = appnic_get_stats,
+       .ndo_set_mac_address = appnic_set_mac_address,
+       .ndo_start_xmit = appnic_hard_start_xmit,
+};
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 29) */
+
+/*
+  ----------------------------------------------------------------------
+  appnic_init
+*/
+
+int
+appnic_init( struct net_device * device )
+{
+
+  appnic_device_t * adapter = netdev_priv( device );
+
+  TRACE_BEGINNING( );
+
+  /*
+    Reset the MAC
+  */
+
+  write_mac_( 0x80000000, APPNIC_DMA_PCI_CONTROL );
+
+  /*
+    -- WORKAROUND -- WORKAROUND -- WORKAROUND -- WORKAROUND -- WORKAROUND --
+    This is the software work around for defect 15129.  Use 64 byte
+    buffers for receive descriptors for all dma.
+    -- WORKAROUND -- WORKAROUND -- WORKAROUND -- WORKAROUND -- WORKAROUND --
+  */
+#ifndef CONFIG_ACP
+  if( 1 >= ( APP3XX_REVISION_REGISTER & 0x1f ) ) {
+
+    printk( "++ Using work around for defect 15129\n" );
+    rx_num_desc = ( 8 * DESCRIPTOR_GRANULARITY );
+    rx_buf_sz = 32768;
+
+  }
+#endif
+
+  /*
+    Allocate memory and initialize the descriptors
+  */
+
+  {
+
+    void * dma_offset_;
+
+    /*
+      fixup num_[rt]x_desc
+    */
+
+    if( 0 != ( rx_num_desc % DESCRIPTOR_GRANULARITY ) ) {
+
+      WARN_PRINT( "rx_num_desc was not a multiple of %d.\n",
+                  DESCRIPTOR_GRANULARITY );
+      rx_num_desc +=
+        DESCRIPTOR_GRANULARITY - ( rx_num_desc % DESCRIPTOR_GRANULARITY );
+
+    }
+
+    adapter->rx_num_desc = rx_num_desc;
+
+    if( 0 != ( tx_num_desc % DESCRIPTOR_GRANULARITY ) ) {
+
+      WARN_PRINT( "tx_num_desc was not a multiple of %d.\n",
+                  DESCRIPTOR_GRANULARITY );
+      tx_num_desc +=
+        DESCRIPTOR_GRANULARITY - ( tx_num_desc % DESCRIPTOR_GRANULARITY );
+
+    }
+
+    adapter->tx_num_desc = tx_num_desc;
+
+    DEBUG_PRINT( "rx_num_desc=%d tx_num_desc=%d\n", rx_num_desc, tx_num_desc );
+
+    /*
+      Fix up [rt]x_buf_sz.  Must be some multiple of 64 bytes per descriptor.
+    */
+
+    if( 0 != ( rx_buf_sz % ( BUFFER_ALIGNMENT *
+                             rx_num_desc ) ) ) {
+
+      WARN_PRINT( "rx_buf_sz was not a multiple of %d.\n",
+                  ( BUFFER_ALIGNMENT * rx_num_desc ) );
+      rx_buf_sz +=
+        ( BUFFER_ALIGNMENT * rx_num_desc ) -
+        ( rx_buf_sz % ( BUFFER_ALIGNMENT *
+                        rx_num_desc ) );
+
+    }
+
+    adapter->rx_buf_sz = rx_buf_sz;
+
+    if( 0 != ( tx_buf_sz % ( BUFFER_ALIGNMENT *
+                             tx_num_desc ) ) ) {
+
+      WARN_PRINT( "tx_buf_sz was not a multiple of %d.\n",
+                  ( BUFFER_ALIGNMENT * tx_num_desc ) );
+      tx_buf_sz +=
+        ( BUFFER_ALIGNMENT * tx_num_desc ) -
+        ( tx_buf_sz % ( BUFFER_ALIGNMENT *
+                        tx_num_desc ) );
+
+    }
+
+    adapter->tx_buf_sz = tx_buf_sz;
+
+    DEBUG_PRINT( "rx_buf_sz=%d tx_buf_sz=%d\n",
+                 rx_buf_sz, tx_buf_sz );
+
+    /*
+      Allocate dma-able memory
+    */
+
+    adapter->dma_alloc_size =
+      /* The tail pointers (rx and tx) */
+      ( sizeof( appnic_queue_pointer_t ) * 2 ) +
+      /* The RX descriptor ring (and padding to allow
+         64 byte alignment) */
+      ( sizeof( appnic_dma_descriptor_t ) *
+        adapter->rx_num_desc ) +
+      ( DESCRIPTOR_GRANULARITY ) +
+      /* The TX descriptor ring (and padding...) */
+      ( sizeof( appnic_dma_descriptor_t ) *
+        adapter->tx_num_desc ) +
+      ( DESCRIPTOR_GRANULARITY ) +
+      /* The RX buffer (and padding...) */
+      ( adapter->rx_buf_sz ) + ( BUFFER_ALIGNMENT ) +
+      /* The TX buffer (and padding...) */
+      ( adapter->tx_buf_sz ) + ( BUFFER_ALIGNMENT );
+
+#ifdef DMA_CACHABLE
+
+    if( ( void * ) 0 ==
+	( adapter->dma_alloc = ( void * )
+	  kmalloc( adapter->dma_alloc_size, GFP_KERNEL ) ) ) {
+
+      ERROR_PRINT( "Could not allocate %d bytes of "
+                   "DMA-able memory!\n",
+                   adapter->dma_alloc_size );
+      kfree( adapter );
+      TRACE_ENDING( );
+      return -ENOMEM;
+
+    }
+
+    adapter->dma_alloc_dma = virt_to_phys( adapter->dma_alloc );
+
+#else
+
+    /* This needs to be set to something sane for dma_alloc_coherent() */
+    device->dev.archdata.dma_ops = &dma_direct_ops;
+
+    if( ( void * ) 0 ==
+        ( adapter->dma_alloc = ( void * )
+          dma_alloc_coherent( &device->dev, adapter->dma_alloc_size,
+                              & adapter->dma_alloc_dma,
+                              GFP_KERNEL ) ) ) {
+
+      ERROR_PRINT( "Could not allocate %d bytes of "
+                   "DMA-able memory!\n",
+                   adapter->dma_alloc_size );
+      kfree( adapter );
+      TRACE_ENDING( );
+      return -ENOMEM;
+
+    }
+
+#endif
+
+    adapter->dma_alloc_offset =
+      ( int ) adapter->dma_alloc - ( int ) adapter->dma_alloc_dma;
+    dma_offset_ = adapter->dma_alloc;
+    DEBUG_PRINT( "Allocated %d bytes at 0x%08lx(0x%08lx), "
+                 "offset=0x%x.\n",
+                 adapter->dma_alloc_size,
+                 ( unsigned long ) adapter->dma_alloc,
+                 ( unsigned long ) adapter->dma_alloc_dma,
+                 adapter->dma_alloc_offset );
+    printk( "Allocated %d bytes at 0x%08lx(0x%08lx), "
+	    "offset=0x%x.\n",
+	    adapter->dma_alloc_size,
+	    ( unsigned long ) adapter->dma_alloc,
+	    ( unsigned long ) adapter->dma_alloc_dma,
+	    adapter->dma_alloc_offset );
+
+    /*
+      Initialize the tail pointers
+    */
+
+    adapter->rx_tail = ( appnic_queue_pointer_t * ) dma_offset_;
+    adapter->rx_tail_dma =
+	    ( int ) adapter->rx_tail - ( int ) adapter->dma_alloc_offset;
+    dma_offset_ += sizeof( appnic_queue_pointer_t );
+    memset( ( void * ) adapter->rx_tail, 0,
+            sizeof( appnic_queue_pointer_t ) );
+    DEBUG_PRINT( "rx_tail=0x%08lx\n",
+                 ( unsigned long ) adapter->rx_tail );
+
+    adapter->tx_tail = ( appnic_queue_pointer_t * ) dma_offset_;
+    adapter->tx_tail_dma =
+	    ( int ) adapter->tx_tail - ( int ) adapter->dma_alloc_offset;
+    dma_offset_ += sizeof( appnic_queue_pointer_t );
+    memset( ( void * ) adapter->tx_tail, 0,
+            sizeof( appnic_queue_pointer_t ) );
+    DEBUG_PRINT( "tx_tail=0x%08lx\n",
+                 ( unsigned long ) adapter->tx_tail );
+
+    /*
+      Initialize the descriptor pointers
+    */
+
+    DEBUG_PRINT( "rx_tail=0x%08lx\n",
+                 ( unsigned long ) adapter->rx_tail );
+    adapter->rx_desc = ( appnic_dma_descriptor_t * )
+      ALIGN64B( dma_offset_ );
+    DEBUG_PRINT( "rx_desc=0x%08lx\n",
+                 ( unsigned long ) adapter->rx_desc );
+    adapter->rx_desc_dma =
+	    ( int ) adapter->rx_desc - ( int ) adapter->dma_alloc_offset;
+    dma_offset_ += ( sizeof( appnic_dma_descriptor_t ) *
+                     adapter->rx_num_desc ) +
+      ( DESCRIPTOR_GRANULARITY );
+    memset( ( void * ) adapter->rx_desc, 0,
+            ( sizeof( appnic_dma_descriptor_t ) *
+              adapter->rx_num_desc ) );
+
+    DEBUG_PRINT( "rx_tail=0x%08lx\n",
+                 ( unsigned long ) adapter->rx_tail );
+    adapter->tx_desc = ( appnic_dma_descriptor_t * )
+      ALIGN64B( dma_offset_ );
+    DEBUG_PRINT( "tx_desc=0x%08lx\n",
+                 ( unsigned long ) adapter->tx_desc );
+    adapter->tx_desc_dma =
+	    ( int ) adapter->tx_desc - ( int ) adapter->dma_alloc_offset;
+    dma_offset_ += ( sizeof( appnic_dma_descriptor_t ) *
+                     adapter->tx_num_desc ) +
+      ( DESCRIPTOR_GRANULARITY );
+    memset( ( void * ) adapter->tx_desc, 0,
+            ( sizeof( appnic_dma_descriptor_t ) *
+              adapter->tx_num_desc ) );
+
+    /*
+      Initialize the buffer pointers
+    */
+
+    DEBUG_PRINT( "rx_tail=0x%08lx\n",
+                 ( unsigned long ) adapter->rx_tail );
+    DEBUG_PRINT( "Initializing the RX buffer pointers, dma_offset=0x%lx/0x%lx\n",
+		 ( unsigned long ) dma_offset_,
+		 ( unsigned long ) ALIGN64B( dma_offset_ ) );
+    adapter->rx_buf = ( void * ) ALIGN64B( dma_offset_ );
+    adapter->rx_buf_dma =
+	    ( int ) adapter->rx_buf - ( int ) adapter->dma_alloc_offset;
+    adapter->rx_buf_per_desc = adapter->rx_buf_sz / adapter->rx_num_desc;
+
+    dma_offset_ += ( adapter->rx_buf_sz ) + ( BUFFER_ALIGNMENT );
+
+    DEBUG_PRINT( "rx_tail=0x%08lx\n",
+                 ( unsigned long ) adapter->rx_tail );
+    DEBUG_PRINT( "Initializing the TX buffer pointers, dma_offset=0x%lx/0x%lx\n",
+		 ( unsigned long ) dma_offset_,
+		 ( unsigned long ) ALIGN64B( dma_offset_ ) );
+    adapter->tx_buf = ( void * ) ALIGN64B( dma_offset_ );
+    adapter->tx_buf_dma =
+	    ( int ) adapter->tx_buf - ( int ) adapter->dma_alloc_offset;
+    adapter->tx_buf_per_desc = adapter->tx_buf_sz / adapter->tx_num_desc;
+    dma_offset_ += ( adapter->tx_buf_sz ) + ( BUFFER_ALIGNMENT );
+
+    /*
+      Initialize the descriptors
+    */
+
+    DEBUG_PRINT( "rx_tail=0x%08lx\n",
+                 ( unsigned long ) adapter->rx_tail );
+    {
+
+      int index_;
+      unsigned long buf_ =
+        ( unsigned long ) adapter->rx_buf_dma;
+      appnic_dma_descriptor_t descriptor;
+
+      DEBUG_PRINT( "Initializing the RX descriptors at 0x%lx\n", buf_ );
+
+      for( index_ = 0; index_ < adapter->rx_num_desc; ++ index_ ) {
+	memset( ( void * ) & descriptor, 0, sizeof( appnic_dma_descriptor_t ) );
+        descriptor.write = 1;
+        descriptor.interrupt_on_completion = 1;
+        descriptor.host_data_memory_pointer = buf_;
+        descriptor.data_transfer_length = adapter->rx_buf_per_desc;
+	writedescriptor( ( ( unsigned long ) adapter->rx_desc +
+			   ( index_ * sizeof( appnic_dma_descriptor_t ) ) ),
+			 & descriptor );
+        buf_ += adapter->rx_buf_per_desc;
+      }
+
+      buf_ = ( unsigned long ) adapter->tx_buf_dma;
+      DEBUG_PRINT( "Initializing the RX descriptors at 0x%lx\n", buf_ );
+
+      for( index_ = 0;
+           index_ < adapter->tx_num_desc; ++ index_ ) {
+	memset( ( void * ) & descriptor, 0, sizeof( appnic_dma_descriptor_t ) );
+        descriptor.write = 1;
+        descriptor.interrupt_on_completion = 1;
+        descriptor.host_data_memory_pointer = buf_;
+	writedescriptor( ( ( unsigned long ) adapter->tx_desc +
+			   ( index_ * sizeof( appnic_dma_descriptor_t ) ) ),
+			 & descriptor );
+        buf_ += adapter->tx_buf_per_desc;
+      }
+    }
+
+    DEBUG_PRINT( "rx_tail=0x%08lx\n",
+                 ( unsigned long ) adapter->rx_tail );
+    DEBUG_PRINT( "Initializing spin locks and semaphores.\n" );
+
+    /*
+      Initialize the spin lock.
+    */
+
+    spin_lock_init( & adapter->lock );
+    spin_lock_init( & adapter->extra_lock );
+
+    /*
+     * TEMP: Initialize the semaphores 
+     */
+    mutex_init( & adapter->rx_sem);
+    mutex_init( & adapter->tx_sem);
+    mutex_init( & adapter->poll_sem);
+
+  }
+
+  /*
+    Take MAC out of reset
+  */
+
+  DEBUG_PRINT( "rx_tail=0x%08lx\n",
+	       ( unsigned long ) adapter->rx_tail );
+  DEBUG_PRINT( "Enabling the MAC" );
+  write_mac_( 0x0, APPNIC_RX_SOFT_RESET );
+  write_mac_( 0x1, APPNIC_RX_MODE );
+  write_mac_( 0x0, APPNIC_TX_SOFT_RESET );
+  write_mac_( 0x1, APPNIC_TX_MODE );
+  if( is_asic( ) ) {
+    write_mac_( 0x300a, APPNIC_TX_WATERMARK );
+  } else {
+    write_mac_( 0xc00096, APPNIC_TX_WATERMARK );
+  }
+  write_mac_( 0x1, APPNIC_TX_HALF_DUPLEX_CONF );
+  write_mac_( 0xffff, APPNIC_TX_TIME_VALUE_CONF );
+  write_mac_( 0x1, APPNIC_TX_INTERRUPT_CONTROL );
+  write_mac_( 0x5275, APPNIC_TX_EXTENDED_CONF );
+  write_mac_( 0x1, APPNIC_RX_INTERNAL_INTERRUPT_CONTROL );
+  write_mac_( 0x1, APPNIC_RX_EXTERNAL_INTERRUPT_CONTROL );
+  write_mac_( 0x40010000, APPNIC_DMA_PCI_CONTROL );
+  write_mac_( 0x30000, APPNIC_DMA_CONTROL );
+  writeio( 0x280044, dma_base + 0x60 );
+  writeio( 0xc0, dma_base + 0x64 );
+
+  /*
+    Set the MAC address.
+  */
+
+  {
+	  struct sockaddr address;
+
+	  memcpy(&(address.sa_data[0]), device->dev_addr, 6);
+	  appnic_set_mac_address(device, &address);
+  }
+
+  /*
+    Initialize the queue pointers.
+  */
+
+  DEBUG_PRINT( "rx_tail=0x%08lx\n",
+	       ( unsigned long ) adapter->rx_tail );
+  {
+
+    /*
+      Receiver
+    */
+
+    memset( ( void * ) & adapter->rx_tail_copy,
+            0, sizeof( appnic_queue_pointer_t ) );
+    memset( ( void * ) & adapter->rx_head,
+            0, sizeof( appnic_queue_pointer_t ) );
+
+    write_mac_( adapter->rx_desc_dma,
+                APPNIC_DMA_RX_QUEUE_BASE_ADDRESS );
+    write_mac_( ( adapter->rx_num_desc *
+                  sizeof( appnic_dma_descriptor_t ) ) / 1024,
+                APPNIC_DMA_RX_QUEUE_SIZE );
+    /* indicate that all of the receive descriptors are ready */
+    adapter->rx_head.bits.offset =
+      ( adapter->rx_num_desc - 1 ) *
+      sizeof( appnic_dma_descriptor_t );
+    write_mac_( adapter->rx_tail_dma,
+                APPNIC_DMA_RX_TAIL_POINTER_ADDRESS );
+
+    /*
+      N.B.
+
+      The boot loader may have used the NIC.  If so, the
+      tail pointer must be read and the head pointer (and
+      local copy of the tail) based on it.
+    */
+
+    DEBUG_PRINT( "Initializing the RX tail: adapter=0x%lx\n",
+		 ( unsigned long ) adapter );
+    DEBUG_PRINT( "Initializing the RX tail: adapter->rx_tail=0x%lx\n",
+		 ( unsigned long ) adapter->rx_tail );
+    DEBUG_PRINT( "Initializing the RX tail: adapter->rx_tail->raw=0x%lx\n",
+		 ( unsigned long ) adapter->rx_tail->raw );
+    adapter->rx_tail->raw =
+      read_mac_( APPNIC_DMA_RX_TAIL_POINTER_LOCAL_COPY );
+    adapter->rx_tail_copy.raw = adapter->rx_tail->raw;
+    adapter->rx_head.raw = adapter->rx_tail->raw;
+    queue_decrement_( & adapter->rx_head, adapter->rx_num_desc );
+    adapter->rx_head.bits.generation_bit =
+      ( 0 == adapter->rx_head.bits.generation_bit ) ? 1 : 0;
+    write_mac_( adapter->rx_head.raw, APPNIC_DMA_RX_HEAD_POINTER );
+
+    /*
+      Transmitter
+    */
+
+    memset( ( void * ) & adapter->tx_tail_copy,
+            0, sizeof( appnic_queue_pointer_t ) );
+    memset( ( void * ) & adapter->tx_head,
+            0, sizeof( appnic_queue_pointer_t ) );
+
+    write_mac_( adapter->tx_desc_dma,
+                APPNIC_DMA_TX_QUEUE_BASE_ADDRESS );
+    write_mac_( ( adapter->tx_num_desc *
+                  sizeof( appnic_dma_descriptor_t ) ) / 1024,
+                APPNIC_DMA_TX_QUEUE_SIZE );
+    DEBUG_PRINT( "Writing 0x%lx to APPNIC_DMA_TX_TAIL_POINTER_ADDRESS\n",
+                 ( unsigned long ) adapter->tx_tail_dma );
+    write_mac_( adapter->tx_tail_dma,
+                APPNIC_DMA_TX_TAIL_POINTER_ADDRESS );
+
+    /*
+      N.B.
+
+      The boot loader may have used the NIC.  If so, the
+      tail pointer must be read and the head pointer (and
+      local copy of the tail) based on it.
+    */
+    
+    DEBUG_PRINT( "Initializing the TX tail pointer at 0x%lx/0x%lx.\n",
+		 ( unsigned long ) adapter->tx_tail,
+		 ( unsigned long ) adapter->tx_tail->raw );
+    adapter->tx_tail->raw =
+      read_mac_( APPNIC_DMA_TX_TAIL_POINTER_LOCAL_COPY );
+    adapter->tx_tail_copy.raw = adapter->tx_tail->raw;
+    adapter->tx_head.raw = adapter->tx_tail->raw;
+    write_mac_( adapter->tx_head.raw, APPNIC_DMA_TX_HEAD_POINTER );
+
+  }
+
+  /* clear statistics */
+
+  {
+
+    appnic_device_t * device_ = netdev_priv( device );
+    clear_statistics_( device_ );
+
+  }
+
+  /* initialize the PHY */
+
+#ifndef PHYLESS
+
+  if( 0 != phy_enable_( phy_address_ ) ) {
+
+    WARN_PRINT( "Failed to initialize the PHY!\n" );
+
+  }
+
+#endif /* PHYLESS */
+
+  /* fill in the net_device structure */
+
+  DEBUG_PRINT( "Filling in the device structure.\n" );
+  ether_setup( device );
+
+#ifdef CONFIG_ACP
+  if( NO_IRQ ==
+      ( device->irq = irq_create_mapping( NULL, adapter->interrupt ) ) ) {
+	  ERROR_PRINT( "irq_create_mapping( ) failed\n" );
+	  return -EBUSY;
+  }
+
+  if( 0 != irq_set_irq_type( device->irq, IRQ_TYPE_LEVEL_HIGH ) ) {
+    ERROR_PRINT( "irq_set_irq_type( ) failed\n" );
+    return -EBUSY;
+  }
+#else
+  device->irq             = INT_MAC_DMA;
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
+  device->open            = appnic_open;
+  device->stop            = appnic_stop;
+  device->hard_start_xmit = appnic_hard_start_xmit;
+  device->tx_timeout      = appnic_tx_timeout;
+  device->get_stats       = appnic_get_stats;
+  device->do_ioctl        = appnic_do_ioctl;
+  device->watchdog_timeo  = tx_timeout;
+  device->set_mac_address = appnic_set_mac_address;
+#else
+  device->netdev_ops = & appnic_netdev_ops;
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29) */
+  SET_ETHTOOL_OPS( device, & appnic_ethtool_ops );
+#ifdef LSINET_NAPI
+  memset( ( void * ) & adapter->napi, 0, sizeof( struct napi_struct ) );
+  netif_napi_add( device, & adapter->napi, lsinet_poll, LSINET_NAPI_WEIGHT );
+  adapter->device = device;
+  printk( "%s:%d - lsinet_poll=0x%lx\n",
+	  __FILE__, __LINE__, ( unsigned long ) lsinet_poll );
+#endif
+
+  /* that's all */
+  TRACE_ENDING( );
+  return 0;
+
+}
+
+/*
+  ----------------------------------------------------------------------
+  appnic_read_proc_
+*/
+
+static int
+appnic_read_proc_( char * page, char * * start, off_t offset,
+                   int count, int * eof, void * data )
+{
+
+  int length_;
+
+#ifdef __APPNIC_C_PROFILE__
+
+  struct net_device *net_device_ = this_net_device;
+  appnic_device_t * appnic_device_ =
+    ( appnic_device_t * ) net_device_->priv;
+  unsigned long divisor_;
+  unsigned long tx_tpa_real_;
+  unsigned long tx_tpa_virt_;
+
+  divisor_ = get_core_speed( ) / 1000000;
+
+#if 1
+
+  if(  appnic_device_->tx_tail_dma !=
+       read_mac_( APPNIC_DMA_TX_TAIL_POINTER_ADDRESS ) ) {
+
+    ERROR_PRINT( "Real Address Doesn't Match Configuration! " \
+                 "0x%x 0x%x\n",
+                 appnic_device_->tx_tail_dma,
+                 read_mac_( APPNIC_DMA_TX_TAIL_POINTER_ADDRESS ) );
+
+  }
+
+  tx_tpa_real_ = appnic_device_->tx_tail_dma;
+  tx_tpa_virt_ = appnic_device_->tx_tail->raw;
+
+  length_ = sprintf( page,
+                     " GKM TEMP DEBUG Build 5\n" \
+                     " RX: head=0x%lx tail=0x%lx tail_copy=0x%lx\n" \
+                     " TX: head=0x%lx tail=0x%lx tail_copy=0x%lx\n" \
+                     "DMA: IE=0x%x IS=0x%x\n" \
+                     "VIC: status=0x%x raw=0x%x enable=0x%x\n" \
+                     " TX: tpa_config=0x%x tpa_real_=0x%lx " \
+                     "*tpa_virt_=0x%x\n",
+                     appnic_device_->rx_head.raw,
+                     appnic_device_->rx_tail->raw,
+                     appnic_device_->rx_tail_copy.raw,
+                     appnic_device_->tx_head.raw,
+                     appnic_device_->tx_tail->raw,
+                     appnic_device_->tx_tail_copy.raw,
+                     read_mac_( APPNIC_DMA_INTERRUPT_ENABLE ),
+                     read_mac_( APPNIC_DMA_INTERRUPT_STATUS ),
+                     readl( ( APP3XX_VIC_BASE + VICIRQSTATUS ) ),
+                     readl( ( APP3XX_VIC_BASE + VICRAWINTR ) ),
+                     readl( ( APP3XX_VIC_BASE + VICINTENABLE ) ),
+                     read_mac_( APPNIC_DMA_TX_TAIL_POINTER_ADDRESS ),
+                     tx_tpa_real_,
+                     * ( ( unsigned int * ) tx_tpa_virt_ ) );
+                     
+
+#else
+
+  length_ = sprintf( page,
+
+#ifdef LSINET_NAPI
+
+                     "-- appnic.c\n" \
+                     "-- rx_num_desc = %d\n" \
+                     "-- rx_buf_sz = %d\n" \
+                     "-- rx_buf_per_desc = %d\n" \
+                     "-- tx_num_desc = %d\n" \
+                     "-- tx_buf_sz = %d\n" \
+                     "-- tx_buf_per_desc = %d\n" \
+                     "-- dropped_by_stack_ = %lu\n" \
+                     "-- transmit_interrupts_ = %lu\n" \
+                     "-- receive_interrupts_ = %lu\n" \
+                     "-- total_polls_ = %lu\n" \
+                     "-- jiffies_changed_ = %lu\n" \
+                     "-- out_of_tx_descriptors_ = %lu\n" \
+                     "-- divisor_ = %lu\n" \
+                     "-- RX(ns): min=%lu max=%lu avg/pkt=%llu "
+                     "avg/poll=%llu\n" \
+                     "-- Max RX Packets Handled/poll: %lu\n" \
+                     "-- RX Size: min=%lu max=%lu total=%lu "
+                     "average=%lu\n" \
+                     "-- TX(ns): min=%lu max=%lu avg/pkt=%llu\n" \
+                     "-- total_tx_packets_: %lu\n" \
+                     "-- recv t1: min=%lu max=%lu, avg=%llu\n" \
+                     "-- recv t2: min=%lu max=%lu, avg=%llu\n" \
+                     "-- recv t3: min=%lu max=%lu, avg=%llu\n",
+
+#else
+
+                     "-- appnic.c\n" \
+                     "-- rx_num_desc = %d\n" \
+                     "-- rx_buf_sz = %d\n" \
+                     "-- rx_buf_per_desc = %d\n" \
+                     "-- tx_num_desc = %d\n" \
+                     "-- tx_buf_sz = %d\n" \
+                     "-- tx_buf_per_desc = %d\n" \
+                     "-- dropped_by_stack_ = %lu\n" \
+                     "-- transmit_interrupts_ = %lu\n" \
+                     "-- total_rx_interrupts_ = %lu\n" \
+                     "-- jiffies_changed_ = %lu\n" \
+                     "-- out_of_tx_descriptors_ = %lu\n" \
+                     "-- divisor_ = %lu\n" \
+                     "-- RX(ns): min=%lu max=%lu avg/pkt=%llu "
+                     "avg/irq=%llu\n" \
+                     "-- Max RX Packets Handled/Interrupt: %lu\n" \
+                     "-- RX Size: min=%lu max=%lu total=%lu "
+                     "average=%lu\n" \
+                     "-- TX(ns): min=%lu max=%lu avg/pkt=%llu\n" \
+                     "-- total_tx_packets_: %lu\n" \
+                     "-- recv t1: min=%lu max=%lu, avg=%llu\n" \
+                     "-- recv t2: min=%lu max=%lu, avg=%llu\n" \
+                     "-- recv t3: min=%lu max=%lu, avg=%llu\n",
+
+#endif
+
+                     appnic_device_->rx_num_desc,
+                     appnic_device_->rx_buf_sz,
+                     appnic_device_->rx_buf_per_desc,
+                     appnic_device_->tx_num_desc,
+                     appnic_device_->tx_buf_sz,
+                     appnic_device_->tx_buf_per_desc,
+                     dropped_by_stack_,
+                     transmit_interrupts_,
+
+#ifdef LSINET_NAPI
+
+                     receive_interrupts_,
+                     total_polls_,
+
+#else
+
+                     total_rx_interrupts_,
+
+#endif
+
+                     jiffies_changed_,
+                     out_of_tx_descriptors_,
+                     divisor_,
+                     profile_time_fmt(time_in_rx_min_,divisor_),
+                     profile_time_fmt(time_in_rx_max_,divisor_),
+                     total_rx_packets_handled_ ?
+                     (profile_avg_fmt(total_rx_time_,
+                                      total_rx_packets_handled_,
+                                      divisor_)) : 0,
+
+#ifdef LSINET_NAPI
+
+                     total_polls_ ?
+                     (profile_avg_fmt(total_rx_time_,
+                                      total_polls_,
+                                      divisor_)) : 0,
+
+#else
+
+                     total_rx_interrupts_ ?
+                     (profile_avg_fmt(total_rx_time_,
+                                      total_rx_interrupts_,
+                                      divisor_)) : 0,
+
+#endif
+
+                     max_rx_packets_handled_,
+                     rx_packet_size_min_, rx_packet_size_max_,
+                     total_rx_bytes_,
+                     total_rx_packets_handled_ ?
+                     ( total_rx_bytes_ / total_rx_packets_handled_ ) :
+                     0,
+                     profile_time_fmt(time_in_tx_min_,divisor_),
+                     profile_time_fmt(time_in_tx_max_,divisor_),
+                     total_tx_packets_ ?
+                     (profile_avg_fmt(total_tx_time_,
+                                      total_tx_packets_,
+                                      divisor_)) : 0,
+                     total_tx_packets_,
+                     profile_time_fmt(recv_t1_min_,divisor_),
+                     profile_time_fmt(recv_t1_max_,divisor_),
+                     total_rx_packets_handled_ ?
+                     ( total_rx_packets_sent_up_ ?
+                       (profile_avg_fmt(recv_t1_tot_,
+                                        total_rx_packets_handled_,
+                                        divisor_)) : 0 ) : 0,
+                     profile_time_fmt(recv_t2_min_,divisor_),
+                     profile_time_fmt(recv_t2_max_,divisor_),
+                     total_rx_packets_sent_up_ ?
+                     (profile_avg_fmt(recv_t2_tot_,
+                                      total_rx_packets_sent_up_,
+                                      divisor_)) : 0,
+                     profile_time_fmt(recv_t3_min_,divisor_),
+                     profile_time_fmt(recv_t3_max_,divisor_),
+                     total_rx_packets_sent_up_ ? 
+                     (profile_avg_fmt(recv_t3_tot_,
+                                      total_rx_packets_sent_up_,
+                                      divisor_)) : 0);
+
+#endif
+
+  time_in_rx_max_ = 0;
+  time_in_rx_min_ = 0xffffffff;
+  rx_packet_size_max_ = 0;
+  rx_packet_size_min_ = 0xffffffff;
+  total_rx_bytes_ = 0;
+  total_rx_packets_handled_ = 1;
+  total_rx_time_ = 0;
+  max_rx_packets_handled_ = 0;
+  total_rx_interrupts_ = 0;
+
+#ifdef LSINET_NAPI
+
+  receive_interrupts_ = 0;
+  total_polls_ = 0;
+
+#endif
+
+  time_in_tx_max_ = 0;
+  time_in_tx_min_ = 0xffffffff;
+  total_tx_time_ = 0;
+  total_tx_packets_ = 1;
+  jiffies_changed_ = 0;
+  recv_t1_min_ = 0xffffffff;
+  recv_t2_min_ = 0xffffffff;
+  recv_t3_min_ = 0xffffffff;
+  recv_t1_max_ = 0;
+  recv_t2_max_ = 0;
+  recv_t3_max_ = 0;
+  recv_t1_tot_ = 0;
+  recv_t2_tot_ = 0;
+  recv_t3_tot_ = 0;
+  total_rx_packets_sent_up_ = 1;
+
+#else
+
+  length_ = sprintf( page, "-- appnic.c -- Profiling is disabled\n" );
+
+#endif
+
+  /* that's all */
+  return length_;
+
+}
+
+/*
+  ----------------------------------------------------------------------
+  lsinet_init
+*/
+
+int
+lsinet_init(void)
+{
+	int rc = 0;
+	struct net_device *device;
+	struct device_node *np = NULL;
+	const u32 *field;
+	appnic_device_t *appnic_device;
+
+	TRACE_BEGINNING();
+
+	/* Allocate space for the device. */
+	if ((struct net_device *)0 ==
+	    (device = alloc_etherdev(sizeof(appnic_device_t)))) {
+		ERROR_PRINT( "Couldn't allocate net device." );
+		rc = -ENOMEM;
+		goto out;
+	}
+
+	this_net_device = device; /* For /proc/reads. */
+	appnic_device = (appnic_device_t *)netdev_priv(device);
+
+	/*
+	  Get the physical addresses, interrupt number, etc. from the
+	  device tree.  If no entry exists (older boot loader...) just
+	  use the pre-devicetree method.
+	*/
+
+	np = of_find_node_by_type(np, "network");
+
+	while (np && !of_device_is_compatible(np, "acp-femac"))
+		np = of_find_node_by_type(np, "network");
+
+	if (np) {
+		u64 value64;
+		u32 value32;
+		int length;
+
+		field = of_get_property(np, "enabled", NULL);
+
+		if (!field || (field && (0 == *field))) {
+			ERROR_PRINT("Not Enabled\n");
+			rc = -EINVAL;
+			goto out;
+		}
+
+		field = of_get_property(np, "reg", NULL);
+
+		if (!field) {
+			ERROR_PRINT("Couldn't get \"reg\" property.\n");
+			rc = -EINVAL;
+			goto out;
+		}
+
+		value64 = of_translate_address(np, field);
+		value32 = field[1];
+		field += 2;
+		rx_base = (unsigned long)ioremap(value64, value32);
+		appnic_device->rx_base = rx_base;
+		value64 = of_translate_address(np, field);
+		value32 = field[1];
+		field += 2;
+		tx_base = (unsigned long)ioremap(value64, value32);
+		appnic_device->tx_base = tx_base;
+		value64 = of_translate_address(np, field);
+		value32 = field[1];
+		field += 2;
+		dma_base = (unsigned long)ioremap(value64, value32);
+		appnic_device->dma_base = dma_base;
+
+		field = of_get_property(np, "interrupts", NULL);
+
+		if (field)
+			appnic_device->interrupt = field[0];
+		else
+			goto device_tree_failed;
+
+		field = of_get_property(np, "mdio-clock", NULL);
+
+		if (!field) {
+			goto device_tree_failed;
+		} else {
+			appnic_device->mdio_clock = field[0];
+		}
+
+		field = of_get_property(np, "phy-address", NULL);
+
+		if (!field) {
+			goto device_tree_failed;
+		} else {
+			appnic_device->phy_address = field[0];
+		}
+
+		field = of_get_property(np, "ad-value", NULL);
+
+		if (!field) {
+			goto device_tree_failed;
+		} else {
+			appnic_device->ad_value = field[0];
+		}
+
+		field = of_get_property(np, "mac-address", &length);
+
+		if (!field || 6 != length) {
+			goto device_tree_failed;
+		} else {
+			int i;
+			u8 *value;
+
+			value = (u8 *)field;
+
+			for (i = 0; i < 6; ++i) {
+				/*printk("value[%d] = 0x%2x\n", i, value[i]);*/
+				appnic_device->mac_addr[i] = value[i];
+			}
+		}
+
+		memcpy(device->dev_addr, &appnic_device->mac_addr[0], 6);
+		memcpy(device->perm_addr, &appnic_device->mac_addr[0], 6);
+
+		goto device_tree_succeeded;
+
+	device_tree_failed:
+		ERROR_PRINT("Reading Device Tree Failed\n");
+		iounmap((void *)rx_base);
+		iounmap((void *)tx_base);
+		iounmap((void *)dma_base);
+		rc = -EINVAL;
+		goto out;
+
+	} else {
+		unsigned char ethaddr_string[20];
+
+		if (0 != ubootenv_get("ethaddr", ethaddr_string)) {
+			ERROR_PRINT("Could not read ethernet address!\n");
+			return -EBUSY;
+		} else {
+			char *string;
+			int i = 0;
+			u8 mac_address[6];
+
+			string = ethaddr_string;
+
+			while ((0 != string) && (6 > i)) {
+				char *value;
+
+				value = strsep(&string, ":");
+				mac_address[i++] =
+					simple_strtoul(value, NULL, 16);
+			}
+
+			memcpy(device->dev_addr, mac_address, 6);
+			memcpy(device->perm_addr, mac_address, 6);
+			device->addr_len = 6;
+		}
+
+		printk("LSI FEMAC: Using Static Addresses and Interrupts.\n");
+		rx_base = (unsigned long)ioremap(0x002000480000ULL, 0x1000);
+		appnic_device->rx_base = rx_base;
+		tx_base = (unsigned long)ioremap(0x002000481000ULL, 0x1000);
+		appnic_device->tx_base = tx_base;
+		dma_base = (unsigned long)ioremap(0x002000482000ULL, 0x1000);
+		appnic_device->dma_base = dma_base;
+		appnic_device->interrupt = 33;
+	}
+
+ device_tree_succeeded:
+
+#ifdef __APPNIC_C_PROFILE__
+	writel( 0xffffffff, ( TIMER7_BASE + TIMER_n_LOAD ) );
+	writel( 0xffffffff, ( TIMER7_BASE + TIMER_n_VALUE ) );
+	writel( ( TIMER_n_CONTROL_ENABLE |
+		  TIMER_n_CONTROL_MODE |
+		  TIMER_n_CONTROL_SIZE ),
+		( TIMER7_BASE + TIMER_n_CONTROL ) );
+#endif /* __APPNIC_C_PROFILE__ */
+
+	/* Initialize the device. */
+
+	if( 0 != ( rc = appnic_init( device ) ) ) {
+		ERROR_PRINT( "appnic_init( ) failed: %d\n", rc );
+		rc = -ENODEV;
+		goto out;
+	}
+
+	strcpy(this_net_device->name, "eth%d");
+
+	/* Register the device. */
+
+	if (0 != (rc = register_netdev(this_net_device))) {
+		ERROR_PRINT("register_netdev() failed: %d\n", rc);
+		rc = -ENODEV;
+		goto out;
+	}
+
+	/* Create the /proc entry. */
+	create_proc_read_entry( "driver/appnic", 0, NULL,
+				appnic_read_proc_, NULL );
+
+ out:
+	TRACE_ENDING( );
+	return rc;
+}
+
+module_init(lsinet_init);
+
+/*
+  ----------------------------------------------------------------------
+  lsinet_exit
+*/
+
+void __exit
+lsinet_exit(void)
+{
+	TRACE_BEGINNING();
+	remove_proc_entry("driver/appnic", NULL);
+	unregister_netdev(this_net_device);
+	TRACE_ENDING();
+
+	return;
+}
+
+module_exit(lsinet_exit);
diff --git a/drivers/lsi/acp/wrappers.c b/drivers/lsi/acp/wrappers.c
new file mode 100644
index 0000000..fbb2f19
--- /dev/null
+++ b/drivers/lsi/acp/wrappers.c
@@ -0,0 +1,243 @@
+/*
+ * drivers/lsi/acp/wrappers.c
+ *
+ * Copyright (C) 2010 LSI
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307	 USA
+ */
+
+#include <linux/module.h>
+#include <linux/of.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+
+extern int is_asic(void);
+extern int acp_clock_get(int, unsigned long *);
+
+/*
+  ==============================================================================
+  ==============================================================================
+  MDIO Access
+  ==============================================================================
+  ==============================================================================
+*/
+
+#ifndef CONFIG_ACPISS
+
+#undef BZ33327_WA
+#define BZ33327_WA
+
+static unsigned long mdio_base;
+static DEFINE_SPINLOCK(mdio_lock);
+
+#define MDIO_CONTROL_RD_DATA ((void *)(mdio_base + 0x0))
+#define MDIO_STATUS_RD_DATA  ((void *)(mdio_base + 0x4))
+#define MDIO_CLK_OFFSET      ((void *)(mdio_base + 0x8))
+#define MDIO_CLK_PERIOD      ((void *)(mdio_base + 0xc))
+
+/*
+  ------------------------------------------------------------------------------
+  acp_mdio_read
+*/
+
+int
+acp_mdio_read(unsigned long address, unsigned long offset, unsigned short *value)
+{
+	unsigned long command = 0;
+	unsigned long status;
+	unsigned long flags;
+
+	spin_lock_irqsave(&mdio_lock, flags);
+#if defined(BZ33327_WA)
+	/* Set the mdio_busy (status) bit. */
+	status = in_le32(MDIO_STATUS_RD_DATA);
+	status |= 0x40000000;
+	out_le32(MDIO_STATUS_RD_DATA, status);
+#endif /* BZ33327_WA */
+
+	/* Write the command.*/
+	command |= 0x10000000;	/* op_code: read */
+	command |= (address & 0x1f) << 16; /* port_addr (target device) */
+	command |= (offset & 0x1f) << 21; /* device_addr (target register) */
+	out_le32(MDIO_CONTROL_RD_DATA, command);
+
+#if defined(BZ33327_WA)
+	/* Wait for the mdio_busy (status) bit to clear. */
+	do {
+		status = in_le32(MDIO_STATUS_RD_DATA);
+	} while (0 != (status & 0x40000000));
+
+	/* Wait for the mdio_busy (control) bit to clear. */
+	do {
+		command = in_le32(MDIO_CONTROL_RD_DATA);
+	} while(0 != (command & 0x80000000));
+
+	*value = (unsigned short)(command & 0xffff);
+#endif /* BZ33327_WA */
+	spin_unlock_irqrestore(&mdio_lock, flags);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(acp_mdio_read);
+
+/*
+  ------------------------------------------------------------------------------
+  acp_mdio_write
+*/
+
+int
+acp_mdio_write(unsigned long address, unsigned long offset, unsigned short value)
+{
+	unsigned long command = 0;
+	unsigned long status;
+	unsigned long flags;
+
+	spin_lock_irqsave(&mdio_lock, flags);
+
+	/* Wait for mdio_busy (control) to be clear. */
+	do {
+		command = in_le32(MDIO_CONTROL_RD_DATA);
+	} while (0 != (command & 0x80000000));
+
+#if defined(BZ33327_WA)
+	/* Set the mdio_busy (status) bit. */
+	status = in_le32(MDIO_STATUS_RD_DATA);
+	status |= 0x40000000;
+	out_le32(MDIO_STATUS_RD_DATA, status);
+#endif /* BZ33327_WA */
+
+	/* Write the command. */
+	command = 0x08000000;	/* op_code: write */
+	command |= (address & 0x1f) << 16; /* port_addr (target device) */
+	command |= (offset & 0x1f) << 21; /* device_addr (target register) */
+	command |= (value & 0xffff); /* value */
+	out_le32(MDIO_CONTROL_RD_DATA, command);
+
+#if defined(BZ33327_WA)
+	/* Wait for the mdio_busy (status) bit to clear. */
+	do {
+		status = in_le32(MDIO_STATUS_RD_DATA);
+	} while (0 != (status & 0x40000000));
+#endif /* BZ33327_WA */
+
+	/* Wait for the mdio_busy (control) bit to clear. */
+	do {
+		command = in_le32(MDIO_CONTROL_RD_DATA);
+	} while (0 != (command & 0x80000000));
+
+	spin_unlock_irqrestore(&mdio_lock, flags);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(acp_mdio_write);
+
+/*
+  ------------------------------------------------------------------------------
+  acp_mdio_initialize
+*/
+
+static int
+acp_mdio_initialize(void)
+{
+	if (is_asic()) {
+		out_le32(MDIO_CLK_OFFSET, 0x10);
+		out_le32(MDIO_CLK_PERIOD, 0x2c);
+	} else {
+		out_le32(MDIO_CLK_OFFSET, 0x05);
+		out_le32(MDIO_CLK_PERIOD, 0x0c);
+	}
+
+	return 0;
+}
+
+#endif /* CONFIG_ACPISS */
+
+/*
+  ==============================================================================
+  ==============================================================================
+  Interrupts
+  ==============================================================================
+  ==============================================================================
+*/
+
+/*
+  ------------------------------------------------------------------------------
+  acp_wrappers_init
+*/
+
+int __init
+acp_wrappers_init(void)
+{
+	int rc = -1;
+	struct device_node *np = NULL;
+	const u32 *field;
+	u64 mdio_phys_address;
+	u32 mdio_size;
+
+	printk(KERN_INFO "Initializing ACP Wrappers.\n");
+
+#ifndef CONFIG_ACPISS
+	np = of_find_node_by_type(np, "network");
+
+	while (np && !of_device_is_compatible(np, "acp-femac"))
+		np = of_find_node_by_type(np, "network");
+
+	if (np) {
+		field = of_get_property(np, "enabled", NULL);
+
+		if (!field || (field && (0 == *field))) {
+			printk(KERN_WARNING
+			       "Networking is Not Enabled.\n");
+			goto acp_wrappers_init_done;
+		}
+
+		field = of_get_property(np, "mdio-reg", NULL);
+
+		if (!field) {
+			printk(KERN_ERR
+			       "Couldn't get \"mdio-reg\" property.\n");
+		} else {
+			mdio_phys_address = of_translate_address(np, field);
+			mdio_size = field[1];
+			rc = 0;
+		}
+	}
+
+	if (0 != rc) {
+		mdio_phys_address = 0x002000409000ULL;
+		mdio_size = 0x1000;
+		printk(KERN_WARNING
+		       "** MDIO Address Not Specified in Device Tree.\n");
+	}
+
+	mdio_base = (unsigned long)ioremap(mdio_phys_address, mdio_size);
+	rc = acp_mdio_initialize();
+#endif
+
+	if (0 != rc)
+		printk(KERN_ERR "MDIO Initiailzation Failed!\n");
+
+ acp_wrappers_init_done:
+
+	return 0;
+}
+
+module_init(acp_wrappers_init);
+
+MODULE_AUTHOR("LSI Corporation");
+MODULE_DESCRIPTION("Timing Test");
+MODULE_LICENSE("GPL");
-- 
1.7.0.4

