From 1cbb87743302835a181059bd7de0b1e06ed0c976 Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Thu, 31 Jan 2013 16:38:16 +0800
Subject: [PATCH 16/16] LSI:ACP34xx:Move nic driver to drivers/net/ethernet

Reposition acp34xx's ethernet driver:

drivers/lsi/acp/wrappers.c -> drivers/net/ethernet/lsi_acp_mdio.c
drivers/lsi/acp/net.c -> drivers/net/ethernet/lsi_acp_net.c

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/Kconfig                     |    2 -
 drivers/Makefile                    |    1 -
 drivers/lsi/Kconfig                 |   36 -
 drivers/lsi/Makefile                |    1 -
 drivers/lsi/acp/Makefile            |    4 -
 drivers/lsi/acp/net.c               | 4222 -----------------------------------
 drivers/lsi/acp/wrappers.c          |  238 --
 drivers/net/ethernet/Kconfig        |   33 +
 drivers/net/ethernet/Makefile       |    3 +
 drivers/net/ethernet/lsi_acp_mdio.c |  238 ++
 drivers/net/ethernet/lsi_acp_net.c  | 4222 +++++++++++++++++++++++++++++++++++
 11 files changed, 4496 insertions(+), 4504 deletions(-)
 delete mode 100644 drivers/lsi/Kconfig
 delete mode 100644 drivers/lsi/Makefile
 delete mode 100644 drivers/lsi/acp/Makefile
 delete mode 100644 drivers/lsi/acp/net.c
 delete mode 100644 drivers/lsi/acp/wrappers.c
 create mode 100644 drivers/net/ethernet/lsi_acp_mdio.c
 create mode 100644 drivers/net/ethernet/lsi_acp_net.c

diff --git a/drivers/Kconfig b/drivers/Kconfig
index 181c75e..c057878 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -142,6 +142,4 @@ source "drivers/devfreq/Kconfig"
 
 source "drivers/mxc/Kconfig"
 
-source "drivers/lsi/Kconfig"
-
 endmenu
diff --git a/drivers/Makefile b/drivers/Makefile
index 0597b53..1acbcea 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -134,5 +134,4 @@ obj-$(CONFIG_VIRT_DRIVERS)	+= virt/
 obj-$(CONFIG_HYPERV)		+= hv/
 
 obj-$(CONFIG_PM_DEVFREQ)	+= devfreq/
-obj-$(CONFIG_ACP)		+= lsi/
 obj-$(CONFIG_ARCH_MXC)          += mxc/
diff --git a/drivers/lsi/Kconfig b/drivers/lsi/Kconfig
deleted file mode 100644
index 3a864a1..0000000
--- a/drivers/lsi/Kconfig
+++ /dev/null
@@ -1,36 +0,0 @@
-menu "LSI Drivers (APP3, APP3K, and ACP)"
-
-config LSI_NET
-	bool "Network interface for LSI's APP and ACP"
-	help
-	  Network interface driver for LSI's APP and ACP series boards.
-
-config LSI_NET_NUM_RX_DESC
-	int "NIC driver: Number of receive descriptors"
-	depends on LSI_NET
-	default "4"
-	help
-          The number of receive descriptors to allocate.
-
-config LSI_NET_RX_BUF_SZ
-    int "NIC driver: Size of the receive buffer"
-    depends on LSI_NET
-    default "32768"
-    help
-        The size of the receive buffer.
-
-config LSI_NET_NUM_TX_DESC
-    int "NIC driver: Number of transmit descriptors"
-    depends on LSI_NET
-    default "4"
-    help
-        The number of transmit descriptors to allocate.
-
-config LSI_NET_TX_BUF_SZ
-    int "NIC driver: Size of the transmit buffer"
-    depends on LSI_NET
-    default "32768"
-    help
-        The size of the transmit buffer.
-
-endmenu
diff --git a/drivers/lsi/Makefile b/drivers/lsi/Makefile
deleted file mode 100644
index 36b59f4..0000000
--- a/drivers/lsi/Makefile
+++ /dev/null
@@ -1 +0,0 @@
-obj-$(CONFIG_ACP)	+= acp/
diff --git a/drivers/lsi/acp/Makefile b/drivers/lsi/acp/Makefile
deleted file mode 100644
index 2076832..0000000
--- a/drivers/lsi/acp/Makefile
+++ /dev/null
@@ -1,4 +0,0 @@
-# Makefile for LSI drivers
-obj-$(CONFIG_ACP)			+= wrappers.o
-obj-$(CONFIG_LSI_NET)			+= net.o
-lsi_nand-objs := nand.o
diff --git a/drivers/lsi/acp/net.c b/drivers/lsi/acp/net.c
deleted file mode 100644
index 31e9da8..0000000
--- a/drivers/lsi/acp/net.c
+++ /dev/null
@@ -1,4222 +0,0 @@
-/*
- * drivers/lsi/acp/net.c
- *
- * Copyright (C) 2009 LSI
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/version.h>
-#include <linux/string.h>
-#include <linux/interrupt.h>
-#include <linux/errno.h>
-#include <linux/in.h>
-#include <linux/slab.h>
-#include <linux/ioport.h>
-#include <linux/spinlock.h>
-#include <linux/delay.h>
-#include <linux/bitops.h>
-#include <linux/proc_fs.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/ethtool.h>
-#include <linux/skbuff.h>
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <linux/of.h>
-
-#include <linux/uaccess.h>
-#include <linux/io.h>
-#include <asm/dma.h>
-
-#include <asm/lsi/acp_ncr.h>
-
-extern int acp_mdio_read(unsigned long, unsigned long, unsigned short *);
-extern int acp_mdio_write(unsigned long, unsigned long, unsigned short);
-
-/* Base Addresses of the RX, TX, and DMA Registers. */
-static unsigned long rx_base;
-static unsigned long tx_base;
-static unsigned long dma_base;
-
-/*
-  =================================================
-  Debug counts (readable from the external host).
-  =================================================
-*/
-
-#undef LSINET_COUNTS
-#define LSINET_COUNTS
-
-#ifdef LSINET_COUNTS
-
-unsigned long lsinet_counts[] = {
-	0, 0, 0, 0,		/* ISR */
-	0, 0, 0, 0, 0, 0,	/* HST */
-	0, 0, 0, 0, 0, 0, 0,	/* RX */
-	0, 0, 0, 0		/* POL */
-};
-EXPORT_SYMBOL(lsinet_counts);
-
-#define LSINET_COUNTS_INC(index) { ++lsinet_counts[(index)]; }
-
-#else				/* LSINET_DEBUG_COUNTS */
-
-#define LSINET_COUNTS_INC(index)
-
-#endif				/* LSINET_DEBUG_COUNTS */
-
-#define LSINET_COUNTS_ISR_START  0
-#define LSINET_COUNTS_ISR_TX     1
-#define LSINET_COUNTS_ISR_RX     2
-#define LSINET_COUNTS_ISR_DONE   3
-#define LSINET_COUNTS_HST_START  4
-#define LSINET_COUNTS_HST_RCLM   5
-#define LSINET_COUNTS_HST_SNDG   6
-#define LSINET_COUNTS_HST_SNT    7
-#define LSINET_COUNTS_HST_OOD    8
-#define LSINET_COUNTS_HST_DONE   9
-#define LSINET_COUNTS_RX_START  10
-#define LSINET_COUNTS_RX_PKT    11
-#define LSINET_COUNTS_RX_ERR    12
-#define LSINET_COUNTS_RX_GOOD   13
-#define LSINET_COUNTS_RX_SENT   14
-#define LSINET_COUNTS_RX_DRPD   15
-#define LSINET_COUNTS_RX_DONE   16
-#define LSINET_COUNTS_POL_START 17
-#define LSINET_COUNTS_POL_PKT   18
-#define LSINET_COUNTS_POL_RNBL  19
-#define LSINET_COUNTS_POL_DONE  20
-
-/*
-  =======================================
-  Profile/Trace/Debug/Warn/Error Macros
-  =======================================
-*/
-
-/* -- Profile --- */
-
-/*#define __APPNIC_C_PROFILE__*/
-#ifdef __APPNIC_C_PROFILE__
-#include <asm/arch/timers.h>
-unsigned long time_in_rx_max_;
-unsigned long time_in_rx_min_ = 0xffffffff;
-unsigned long long total_rx_time_;
-unsigned long max_rx_packets_handled_;
-unsigned long total_rx_packets_handled_;
-unsigned long total_rx_interrupts_;
-unsigned long rx_packet_size_max_;
-unsigned long rx_packet_size_min_ = 0xffffffff;
-unsigned long total_rx_bytes_;
-unsigned long time_in_tx_max_;
-unsigned long time_in_tx_min_ = 0xffffffff;
-unsigned long long total_tx_time_;
-unsigned long total_tx_packets_ = 1;
-unsigned long jiffies_changed_;
-unsigned long total_polls_;
-
-unsigned long recv_t1_min_ = 0xffffffff;
-unsigned long recv_t2_min_ = 0xffffffff;
-unsigned long recv_t3_min_ = 0xffffffff;
-unsigned long recv_t1_max_;
-unsigned long recv_t2_max_;
-unsigned long recv_t3_max_;
-unsigned long long recv_t1_tot_;
-unsigned long long recv_t2_tot_;
-unsigned long long recv_t3_tot_;
-unsigned long total_rx_packets_sent_up_ = 1;
-
-#define app3xx_profile_time_calc(_beg_t_, _end_t_, _min_t_, _max_t_, _tot_t_) \
-do {	\
-	unsigned long _this_t_;	\
-	if (_end_t_ > _beg_t_)	\
-		_this_t_ = _end_t_ - _beg_t_;	\
-	else	\
-		_this_t_ = _end_t_ + (0xffffffff - _beg_t_) + 1;	\
-		_tot_t_ += _this_t_;	\
-	if (_this_t_ > _max_t_)	\
-		_max_t_ = _this_t_;	\
-	if (_this_t_ < _min_t_)	\
-		_min_t_ = _this_t_;	\
-} while (0)
-
-#define profile_time_fmt(t, d)  ((1000 * t) / d)
-#define profile_avg_fmt(t, c, d) ((1000 * (t / c)) / d)
-#endif				/* __APPNIC_C_PROFILE__ */
-
-#include <asm/lsi/debug.h>
-
-/*
-  ======================================================================
-  ======================================================================
-  Optimizations
-  ======================================================================
-  ======================================================================
-*/
-
-#define DISABLE_TX_INTERRUPTS
-/*#define PRELOAD_RX_BUFFERS*/
-
-#undef DMA_CACHABLE
-/*#define DMA_CACHABLE*/
-
-/*
-  ===================================
-  NAPI Support (new and newer)...
-  ===================================
-*/
-
-#define LSINET_NAPI
-#define LSINET_NAPI_WEIGHT 64
-
-/*
-  ===================================
-  Access and Access Logging
-  ===================================
-*/
-
-/*#define LOG_MAC_ACCESS*/
-/*#define LOG_PHY_ACCESS*/
-
-/*
-  ====================================
-  PHY
-  ====================================
-*/
-
-#undef PHYLESS
-/*#define PHYLESS*/
-
-#ifndef PHYLESS
-
-/* -- control -- */
-
-#define PHY_CONTROL 0x00
-
-typedef union {
-	unsigned short raw;
-
-	struct {
-#if 1
-		unsigned short soft_reset:1;
-		unsigned short loop_back:1;
-		unsigned short force100:1;	/* speedBit0 */
-		unsigned short autoneg_enable:1;
-		unsigned short power_down:1;
-		unsigned short isolate:1;
-		unsigned short restart_autoneg:1;
-		unsigned short full_duplex:1;	/* duplex */
-		unsigned short collision_test:1;
-		unsigned short unused:7;
-#else				/* __BIG_ENDIAN */
-		unsigned short:7;
-		unsigned short collision_test:1;
-		unsigned short full_duplex:1;	/* duplex */
-		unsigned short restart_autoneg:1;
-		unsigned short isolate:1;
-		unsigned short power_down:1;
-		unsigned short autoneg_enable:1;
-		unsigned short force100:1;	/* speedBit0 */
-		unsigned short loop_back:1;
-		unsigned short soft_reset:1;
-#endif				/* __BIG_ENDIAN */
-	} __packed bits;
-} __packed phy_control_t;
-
-/* -- status -- */
-
-#define PHY_STATUS 0x01
-
-typedef union {
-	unsigned short raw;
-
-	struct {
-#if 1
-		unsigned short t4_capable:1;
-		unsigned short tx_fdx_capable:1;
-		unsigned short tx_capable:1;
-		unsigned short bt_fdx_capable:1;
-		unsigned short tenbt_capable:1;
-		unsigned short unused:4;
-		unsigned short mf_pream_suppress:1;
-		unsigned short autoneg_comp:1;	/* autoNegDone */
-		unsigned short remote_fault:1;	/* remoutFault */
-		unsigned short autoneg_capable:1;
-		unsigned short link_status:1;	/* linkStatus */
-		unsigned short jabber_detect:1;
-		unsigned short extd_reg_capable:1;
-#else
-		unsigned short extd_reg_capable:1;
-		unsigned short jabber_detect:1;
-		unsigned short link_status:1;	/* linkStatus */
-		unsigned short autoneg_capable:1;
-		unsigned short remote_fault:1;	/* remoutFault */
-		unsigned short autoneg_comp:1;	/* autoNegDone */
-		unsigned short mf_pream_suppress:1;
-		unsigned short:4;
-		unsigned short tenbt_capable:1;
-		unsigned short bt_fdx_capable:1;
-		unsigned short tx_capable:1;
-		unsigned short tx_fdx_capable:1;
-		unsigned short t4_capable:1;
-#endif				/* __BIG_ENDIAN */
-	} __packed bits;
-} __packed phy_status_t;
-
-/* -- id_high -- */
-
-#define PHY_ID_HIGH 0x02
-
-typedef union {
-	unsigned short raw;
-
-	struct {
-		unsigned short id:16;
-	} __packed bits;
-} __packed phy_id_high_t;
-
-/* -- id_low -- */
-
-#define PHY_ID_LOW  0x03
-
-typedef union {
-	unsigned short raw;
-
-	struct {
-#if 1
-		unsigned short id:6;
-		unsigned short model:6;
-		unsigned short revision:4;
-#else				/* __BIG_ENDIAN */
-		unsigned short revision:4;
-		unsigned short model:6;
-		unsigned short id:6;
-#endif				/* __BIG_ENDIAN */
-	} __packed bits;
-} __packed phy_id_low_t;
-
-/* -- autoneg_advertise  -- */
-
-#define PHY_AUTONEG_ADVERTISE 0x04
-
-/* -- link_partner_ability -- */
-
-#define PHY_LINK_PARTNER_ABILITY 0x05
-
-/* -- -- */
-
-#define MICREL_PHY_AUXILIARY_CONTROL_STATUS 0x1f
-
-typedef union {
-	unsigned short raw;
-
-	struct {
-		unsigned short:3;
-		unsigned short energy:1;
-		unsigned short force_link:1;
-		unsigned short power_saving:1;
-		unsigned short interrupt_level:1;
-		unsigned short jabber_enable:1;
-		unsigned short autoneg_indication:1;
-		unsigned short enable_pause:1;
-		unsigned short isolate:1;
-		unsigned short op_mode_indication:3;
-		unsigned short:2;
-	} bits;
-} micrel_phy_auxiliary_control_status_t;
-
-/*
-  Auto-negotiation Advertisement Values.
-*/
-
-#define PHY_AUTONEG_ADVERTISE_100FULL 0x101
-#define PHY_AUTONEG_ADVERTISE_100     0x081
-#define PHY_AUTONEG_ADVERTISE_10FULL  0x041
-#define PHY_AUTONEG_ADVERTISE_10      0x021
-
-#define PHY_ADDRESS_ 0x1e
-static int phy_address_ = PHY_ADDRESS_;
-
-#define UNKNOWN_PHY_ 0x0
-#define BCM5221_PHY_ 0x1
-#define MICREL_PHY_  0x2
-
-#ifndef CONFIG_ACP
-static int phy_type_ = UNKNOWN_PHY_;
-static int phy_link_(int);
-static int phy_scan_(void);
-static int phy_reset_(int);
-#endif
-
-static int phy_read_(int, int, unsigned short *);
-static int phy_write_(int, int, unsigned short);
-static int phy_speed_(int);
-static int phy_duplex_(int);
-static int phy_renegotiate_(int);
-static int phy_enable_(int);
-
-#endif				/* PHYLESS */
-
-/*
-  ======================================================================
-  ======================================================================
-  ======================================================================
-
-  NIC Interface
-
-  ======================================================================
-  ======================================================================
-  ======================================================================
-*/
-
-static int enable_(struct net_device *);
-
-/*
-  ======================================================================
-  ======================================================================
-  ======================================================================
-
-  Device Data Structures
-
-  ======================================================================
-  ======================================================================
-  ======================================================================
-*/
-
-typedef struct {
-
-#ifdef CONFIG_ACP
-
-	/* Word 0 */
-	unsigned long:24;
-	/* big endian to little endian */
-	unsigned long byte_swapping_on:1;
-	unsigned long error:1;
-	unsigned long interrupt_on_completion:1;
-	unsigned long end_of_packet:1;
-	unsigned long start_of_packet:1;
-	unsigned long write:1;
-	/* 00=Fill|01=Block|10=Scatter */
-	unsigned long transfer_type:2;
-
-	/* Word 1 */
-	unsigned long pdu_length:16;
-	unsigned long data_transfer_length:16;
-
-	/* Word 2 */
-	unsigned long target_memory_address;
-
-	/* Word 3 */
-	unsigned long host_data_memory_pointer;
-
-#else
-
-	/* Word 0 */
-	/* 00=Fill|01=Block|10=Scatter */
-	unsigned long transfer_type:2;
-	unsigned long write:1;
-	unsigned long start_of_packet:1;
-	unsigned long end_of_packet:1;
-	unsigned long interrupt_on_completion:1;
-	unsigned long error:1;
-	/* big endian to little endian */
-	unsigned long byte_swapping_on:1;
-	unsigned long:24;
-
-	/* Word 1 */
-	unsigned long data_transfer_length:16;
-	unsigned long pdu_length:16;
-
-	/* Word 2 */
-	unsigned long target_memory_address;
-
-	/* Word 3 */
-	unsigned long host_data_memory_pointer;
-
-#endif
-
-} __packed appnic_dma_descriptor_t;
-
-typedef union {
-
-	unsigned long raw;
-
-	struct {
-#ifdef CONFIG_ACP
-		unsigned long:11;
-		unsigned long generation_bit:1;
-		unsigned long offset:20;
-#else
-		unsigned long offset:20;
-		unsigned long generation_bit:1;
-		unsigned long:11;
-#endif
-	} __packed bits;
-
-} __packed appnic_queue_pointer_t;
-
-/*
-  ============================================
-  The Device Struction
-  ============================================
-*/
-
-typedef struct {
-
-	/* net_device */
-	struct net_device *device;
-
-	/* Addresses, Interrupt, and PHY stuff. */
-	unsigned long rx_base;
-	unsigned long tx_base;
-	unsigned long dma_base;
-	unsigned long interrupt;
-	unsigned long mdio_clock;
-	unsigned long phy_address;
-	unsigned long ad_value;
-	unsigned char mac_addr[6];
-
-#ifdef LSINET_NAPI
-	/* napi */
-	struct napi_struct napi;
-#endif				/* LSINET_ENABLE_NAPI */
-
-	/* statistics */
-	struct net_device_stats stats;
-
-	/*
-	   DMA-able memory.
-	 */
-
-	/* */
-	int dma_alloc_size;
-	void *dma_alloc;
-	dma_addr_t dma_alloc_dma;
-	int dma_alloc_offset;
-
-	/* tail pointers */
-	volatile appnic_queue_pointer_t *rx_tail;
-	dma_addr_t rx_tail_dma;
-	volatile appnic_queue_pointer_t *tx_tail;
-	dma_addr_t tx_tail_dma;
-
-	/* descriptors */
-	appnic_dma_descriptor_t *rx_desc;
-	dma_addr_t rx_desc_dma;
-	unsigned rx_num_desc;
-	appnic_dma_descriptor_t *tx_desc;
-	dma_addr_t tx_desc_dma;
-	unsigned tx_num_desc;
-
-	/* buffers */
-	unsigned rx_buf_sz;
-	unsigned rx_buf_per_desc;
-	void *rx_buf;
-	dma_addr_t rx_buf_dma;
-	unsigned tx_buf_sz;
-	unsigned tx_buf_per_desc;
-	void *tx_buf;
-	dma_addr_t tx_buf_dma;
-
-	/*
-	   The local pointers
-	 */
-
-	appnic_queue_pointer_t rx_tail_copy;
-	appnic_queue_pointer_t rx_head;
-
-	appnic_queue_pointer_t tx_tail_copy;
-	appnic_queue_pointer_t tx_head;
-
-	/*
-	   Polling Mode?
-	 */
-
-	int polling;
-
-	/*
-	   Spin Lock
-	 */
-
-	spinlock_t lock;
-	spinlock_t extra_lock;
-
-	/*
-	 * TEMP: semaphores for locking Tx/Rx operations
-	 */
-
-	struct mutex tx_sem;
-	struct mutex rx_sem;
-	struct mutex poll_sem;
-
-} appnic_device_t;
-
-#define DESCRIPTOR_GRANULARITY 64
-#define BUFFER_ALIGNMENT 64
-
-#define ALIGN64B(address) \
-((((unsigned long)(address) + (64UL - 1UL)) & ~(64UL - 1UL)))
-
-#define ALIGN64B_OFFSET(address) \
-(ALIGN64B(address) - (unsigned long)(address))
-
-#define APPNIC_NAME "appnic"
-
-/*
-  Overview
-  --------
-
-  Register offset decoding is as follows:
-
-  Bit(s) Description
-
-  16:15  define the Channel.  There is only one; therefore, 00.
-  14:12  define the MAC within the channel.  Only one so 000.
-  11:10  define the register "space" as follows:
-  00 = fast ethernet MAC
-  10 = global
-  11 = interrupt
-  9: 2  register
-  1: 0  always 00, 32 bit registers only.
-
-  Receive registers start at the base address.  Transmit registers start
-  at 0x20000 above the base address.  DMA start at a completely different
-  base address (in this case 0x8000000 above the base).
-
-*/
-
-/*
-  ======================================================================
-  ======================================================================
-  ======================================================================
-
-  Registers.
-
-  ======================================================================
-  ======================================================================
-  ======================================================================
-*/
-
-/* SMII Status ------------------------------------------------------ */
-
-#define APPNIC_RX_SMII_STATUS        (rx_base + 0x10)
-#define APPNIC_RX_SMII_STATUS_SPEED  0x01
-#define APPNIC_RX_SMII_STATUS_DUPLEX 0x02
-#define APPNIC_RX_SMII_STATUS_LINK   0x04
-#define APPNIC_RX_SMII_STATUS_JABBER 0x08
-#define APPNIC_RX_SMII_STATUS_FCD    0x10	/* False Carrier Detect */
-
-#define SMII_SPEED_100(smii_status_) \
-(0 != (smii_status_ & APPNIC_RX_SMII_STATUS_SPEED))
-#define SMII_DUPLEX(smii_status_) \
-(0 != (smii_status_ & APPNIC_RX_SMII_STATUS_DUPLEX))
-#define SMII_LINK(smii_status_) \
-(0 != (smii_status_ & APPNIC_RX_SMII_STATUS_LINK))
-#define SMII_JABBER(smii_status_) \
-(0 != (smii_status_ & APPNIC_RX_SMII_STATUS_JABBER))
-
-/* Receive Configuration -------------------------------------------- */
-
-#define APPNIC_RX_CONF          (rx_base + 0x004c)
-#define APPNIC_RX_CONF_ENABLE   0x0001
-/* Pass Any Packet */
-#define APPNIC_RX_CONF_PAP      0x0002
-#define APPNIC_RX_CONF_JUMBO9K  0x0008
-#define APPNIC_RX_CONF_STRIPCRC 0x0010
-/* Accept All MAC Types */
-#define APPNIC_RX_CONF_AMT      0x0020
-/* Accept Flow Control */
-#define APPNIC_RX_CONF_AFC      0x0040
-/* Enable VLAN */
-#define APPNIC_RX_CONF_VLAN     0x0200
-/* RX MAC Speed, 1=100MBS */
-#define APPNIC_RX_CONF_SPEED    0x0800
-/* 1=Duplex Mode */
-#define APPNIC_RX_CONF_DUPLEX   0x1000
-/* 1=Enable */
-#define APPNIC_RX_CONF_LINK     0x2000
-/* Determines the action taken when the FE MAC
-   receives an FC packet in FD mode.*/
-#define APPNIC_RX_CONF_RXFCE    0x4000
-/* Controls the insertion of FC packets
-   by the MAC transmitter. */
-#define APPNIC_RX_CONF_TXFCE    0x8000
-
-/* Receive Stat Overflow -------------------------------------------- */
-
-#define APPNIC_RX_STAT_OVERFLOW (rx_base + 0x278)
-
-/* Receive Stat Undersize ------------------------------------------- */
-
-#define APPNIC_RX_STAT_UNDERSIZE (rx_base + 0x280)
-
-/* Receive Stat Oversize -------------------------------------------- */
-
-#define APPNIC_RX_STAT_OVERSIZE (rx_base + 0x2b8)
-
-/* Receive Stat Multicast ------------------------------------------- */
-
-#define APPNIC_RX_STAT_MULTICAST (rx_base + 0x2d0)
-
-/* Receive Stat Packet OK ------------------------------------------- */
-
-#define APPNIC_RX_STAT_PACKET_OK (rx_base + 0x2c0)
-
-/* Receive Stat CRC Error ------------------------------------------- */
-
-#define APPNIC_RX_STAT_CRC_ERROR (rx_base + 0x2c8)
-
-/* Receive Stat Align Error ----------------------------------------- */
-
-#define APPNIC_RX_STAT_ALIGN_ERROR (rx_base + 0x2e8)
-
-/* Receive Ethernet Mode -------------------------------------------- */
-
-#define APPNIC_RX_MODE (rx_base + 0x0800)
-#define APPNIC_RX_MODE_ETHERNET_MODE_ENABLE 0x00001
-
-/* Receive Soft Reset ----------------------------------------------- */
-
-#define APPNIC_RX_SOFT_RESET (rx_base + 0x0808)
-#define APPNIC_RX_SOFT_RESET_MAC_0 0x00001
-
-/* Receive Internal Interrupt Control ------------------------------- */
-
-#define APPNIC_RX_INTERNAL_INTERRUPT_CONTROL (rx_base + 0xc00)
-#define APPNIC_RX_INTERNAL_INTERRUPT_CONTROL_MAC_0 0x1
-
-/* Receive External Interrupt Control ------------------------------- */
-
-#define APPNIC_RX_EXTERNAL_INTERRUPT_CONTROL (rx_base + 0xc04)
-#define APPNIC_RX_EXTERNAL_INTERRUPT_CONTROL_MAC_0_HIGH_LOW 0x10
-#define APPNIC_RX_EXTERNAL_INTERRUPT_CONTROL_MAC_0 0x1
-
-/* Receive Interrupt Status ----------------------------------------- */
-
-#define APPNIC_RX_INTERRUPT_STATUS (rx_base + 0xc20)
-#define APPNIC_RX_INTERRUPT_EXTERNAL_STATUS_MAC_0 0x10
-#define APPNIC_RX_INTERRUPT_INTERNAL_STATUS_MAC_0 0x1
-
-/* Transmit Watermark ----------------------------------------------- */
-
-#define APPNIC_TX_WATERMARK (tx_base + 0x18)
-#define APPNIC_TX_WATERMARK_TXCONFIG_DTPA_ASSERT 0x8000
-#define APPNIC_TX_WATERMARK_TXCONFIG_DTPA_DISABLE 0x4000
-#define APPNIC_TX_WATERMARK_TXCONFIG_DTPA_WATER_MARK_HIGH 0x3f00
-#define APPNIC_TX_WATERMARK_TXCONFIG_DTPA_WATER_MARK_LOW 0x3f
-
-/* Swap Source Address Registers ------------------------------------ */
-
-#define APPNIC_SWAP_SOURCE_ADDRESS_2 (tx_base + 0x20)
-#define APPNIC_SWAP_SOURCE_ADDRESS_1 (tx_base + 0x24)
-#define APPNIC_SWAP_SOURCE_ADDRESS_0 (tx_base + 0x28)
-
-/* Transmit Extended Configuration ---------------------------------- */
-
-#define APPNIC_TX_EXTENDED_CONF (tx_base + 0x30)
-#define APPNIC_TX_EXTENDED_CONF_TRANSMIT_COLLISION_WATERMARK_LEVEL 0xf000
-#define APPNIC_TX_EXTENDED_CONF_EXCESSIVE_DEFFERED_PACKET_DROP 0x200
-#define APPNIC_TX_EXTENDED_CONF_JUMBO9K 0x100
-#define APPNIC_TX_EXTENDED_CONF_LATE_COLLISION_WINDOW_COUNT 0xff
-
-/* Transmit Half Duplex Configuration ------------------------------- */
-
-#define APPNIC_TX_HALF_DUPLEX_CONF (tx_base + 0x34)
-#define APPNIC_TX_HALF_DUPLEX_CONF_RANDOM_SEED_VALUE 0xff
-
-/* Transmit Configuration ------------------------------------------- */
-
-#define APPNIC_TX_CONF (tx_base + 0x0050)
-#define APPNIC_TX_CONF_ENABLE_SWAP_SA 0x8000
-#define APPNIC_TX_CONF_LINK           0x2000
-#define APPNIC_TX_CONF_DUPLEX         0x1000
-#define APPNIC_TX_CONF_SPEED          0x0800
-#define APPNIC_TX_CONF_XBK_RST_RX_NTX 0x0600
-#define APPNIC_TX_CONF_IFG            0x01f0
-#define APPNIC_TX_CONF_APP_CRC_ENABLE 0x0004
-#define APPNIC_TX_CONF_PAD_ENABLE     0x0002
-#define APPNIC_TX_CONF_ENABLE         0x0001
-
-#define TX_CONF_SET_IFG(tx_configuration_, ifg_) do {\
-(tx_configuration_) &= ~APPNIC_TX_CONF_IFG; \
-(tx_configuration_) |= ((ifg_ & 0x1f) << 4); \
-} while (0);
-
-/* Transmit Time Value Configuration -------------------------------- */
-
-#define APPNIC_TX_TIME_VALUE_CONF (tx_base + 0x5c)
-#define APPNIC_TX_TIME_VALUE_CONF_PAUSE_VALUE 0xffff
-
-/* Transmit Stat Underrun ------------------------------------------- */
-
-#define APPNIC_TX_STAT_UNDERRUN (tx_base + 0x300)
-
-/* Transmit Stat Packet OK ------------------------------------------ */
-
-#define APPNIC_TX_STAT_PACKET_OK (tx_base + 0x318)
-
-/* Transmit Stat Undersize ------------------------------------------ */
-
-#define APPNIC_TX_STAT_UNDERSIZE (tx_base + 0x350)
-
-/* Transmit Status Late Collision ----------------------------------- */
-
-#define APPNIC_TX_STATUS_LATE_COLLISION (tx_base + 0x368)
-
-/* Transmit Status Excessive Collision ------------------------------ */
-
-#define APPNIC_TX_STATUS_EXCESSIVE_COLLISION (tx_base + 0x370)
-
-/* Transmit Stat Collision Above Watermark -------------------------- */
-
-#define APPNIC_TX_STAT_COLLISION_ABOVE_WATERMARK (tx_base + 0x380)
-
-/* Transmit Mode ---------------------------------------------------- */
-
-#define APPNIC_TX_MODE (tx_base + 0x800)
-#define APPNIC_TX_MODE_ETHERNET_MODE_ENABLE 0x1
-
-/* Transmit Soft Reset ---------------------------------------------- */
-
-#define APPNIC_TX_SOFT_RESET (tx_base + 0x808)
-#define APPNIC_TX_SOFT_RESET_MAC_0 0x1
-
-/* Transmit Interrupt Control --------------------------------------- */
-
-#define APPNIC_TX_INTERRUPT_CONTROL (tx_base + 0xc00)
-#define APPNIC_TX_INTERRUPT_CONTROL_MAC_0 0x1
-
-/* Transmit Interrupt Status ---------------------------------------- */
-
-#define APPNIC_TX_INTERRUPT_STATUS (tx_base + 0xc20)
-#define APPNIC_TX_INTERRUPT_STATUS_MAC_0 0x1
-
-/* */
-
-#define APPNIC_DMA_PCI_CONTROL (dma_base + 0x00)
-
-/* */
-
-#define APPNIC_DMA_CONTROL (dma_base + 0x08)
-
-/* DMA Interrupt Status --------------------------------------------- */
-
-#define APPNIC_DMA_INTERRUPT_STATUS (dma_base + 0x18)
-#define APPNIC_DMA_INTERRUPT_STATUS_RX 0x2
-#define APPNIC_DMA_INTERRUPT_STATUS_TX 0x1
-
-#define RX_INTERRUPT(dma_interrupt_status_) \
-(0 != (dma_interrupt_status_ & APPNIC_DMA_INTERRUPT_STATUS_RX))
-#define TX_INTERRUPT(dma_interrupt_status_) \
-(0 != (dma_interrupt_status_ & APPNIC_DMA_INTERRUPT_STATUS_TX))
-
-/* DMA Interrupt Enable --------------------------------------------- */
-
-#define APPNIC_DMA_INTERRUPT_ENABLE (dma_base + 0x1c)
-#define APPNIC_DMA_INTERRUPT_ENABLE_RECEIVE 0x2
-#define APPNIC_DMA_INTERRUPT_ENABLE_TRANSMIT 0x1
-
-/* DMA Receive Queue Base Address ----------------------------------- */
-
-#define APPNIC_DMA_RX_QUEUE_BASE_ADDRESS (dma_base + 0x30)
-
-/* DMA Receive Queue Size ------------------------------------------- */
-
-#define APPNIC_DMA_RX_QUEUE_SIZE (dma_base + 0x34)
-
-/* DMA Transmit Queue Base Address ---------------------------------- */
-
-#define APPNIC_DMA_TX_QUEUE_BASE_ADDRESS (dma_base + 0x38)
-
-/* DMA Transmit Queue Size ------------------------------------------ */
-
-#define APPNIC_DMA_TX_QUEUE_SIZE (dma_base + 0x3c)
-
-/* DMA Recevie Tail Pointer Address --------------------------------- */
-
-#define APPNIC_DMA_RX_TAIL_POINTER_ADDRESS (dma_base + 0x48)
-
-/* DMA Transmit Tail Pointer Address -------------------------------- */
-
-#define APPNIC_DMA_TX_TAIL_POINTER_ADDRESS (dma_base + 0x4c)
-
-/* DMA Receive Head Pointer ----------------------------------------- */
-
-#define APPNIC_DMA_RX_HEAD_POINTER (dma_base + 0x50)
-#define APPNIC_DMA_RX_HEAD_POINTER_GB      0x100000
-#define APPNIC_DMA_RX_HEAD_POINTER_POINTER 0x0fffff
-
-/* DMA Receive Tail Pointer Local Copy ------------------------------ */
-
-#define APPNIC_DMA_RX_TAIL_POINTER_LOCAL_COPY (dma_base + 0x54)
-#define APPNIC_DMA_RX_TAIL_POINTER_LOCAL_COPY_GB      0x100000
-#define APPNIC_DMA_RX_TAIL_POINTER_LOCAL_COPY_POINTER 0x0fffff
-
-/* DMA Transmit Head Pointer ---------------------------------------- */
-
-#define APPNIC_DMA_TX_HEAD_POINTER (dma_base + 0x58)
-#define APPNIC_DMA_TX_HEAD_POINTER_GB      0x100000
-#define APPNIC_DMA_TX_HEAD_POINTER_POINTER 0x0fffff
-
-/* DMA Transmit Tail Pointer Local Copy ----------------------------- */
-
-#define APPNIC_DMA_TX_TAIL_POINTER_LOCAL_COPY (dma_base + 0x5c)
-#define APPNIC_DMA_TX_TAIL_POINTER_LOCAL_COPY_GB      0x100000
-#define APPNIC_DMA_TX_TAIL_POINTER_LOCAL_COPY_POINTER 0x0fffff
-
-/*
-  ======================================================================
-  ======================================================================
-  ======================================================================
-
-  Access
-
-  N.B. On the APP, DMA transfers from the NIC MUST USE THE MEMORY
-  ALIAS AT 0x60000000!
-
-  ======================================================================
-  ======================================================================
-  ======================================================================
-*/
-
-#ifdef CONFIG_ACP
-
-#define readio(address) in_le32((u32 *)(address))
-
-#define writeio(value, address) out_le32((u32 *)(address), (value))
-
-static inline void
-readdescriptor(unsigned long address, appnic_dma_descriptor_t *descriptor)
-{
-	unsigned long *from = (unsigned long *) address;
-	unsigned long *to = (unsigned long *) descriptor;
-	*to++ = swab32(*from++);
-	*to++ = swab32(*from++);
-	*to++ = swab32(*from++);
-	*to++ = swab32(*from++);
-	return;
-}
-
-static inline void
-writedescriptor(unsigned long address,
-		const appnic_dma_descriptor_t *descriptor)
-{
-	unsigned long *to = (unsigned long *) address;
-	unsigned long *from = (unsigned long *) descriptor;
-	*to++ = swab32(*from++);
-	*to++ = swab32(*from++);
-	*to++ = swab32(*from++);
-	*to++ = swab32(*from++);
-	return;
-}
-
-static inline appnic_queue_pointer_t
-swab_queue_pointer(const appnic_queue_pointer_t *old_queue)
-{
-	appnic_queue_pointer_t new_queue;
-	new_queue.raw = swab32(old_queue->raw);
-	return new_queue;
-}
-
-#define SWAB_QUEUE_POINTER(pointer) \
-swab_queue_pointer((const appnic_queue_pointer_t *)(pointer))
-
-#else
-
-#define readio(address) readl((address))
-
-#define writeio(value, address) writel((value), (address))
-
-static inline void
-readdescriptor(unsigned long address, appnic_dma_descriptor_t *descriptor)
-{
-	memcpy(descriptor, (void *) address, sizeof(appnic_dma_descriptor_t));
-	return;
-}
-
-static inline void
-writedescriptor(unsigned long address,
-		const appnic_dma_descriptor_t *descriptor)
-{
-	memcpy((void *) address, descriptor, sizeof(appnic_dma_descriptor_t));
-	return;
-}
-
-static inline unsigned long
-swab_queue_pointer(unsigned long old_queue)
-{
-	return old_queue;
-}
-
-#endif
-
-#ifdef LOG_MAC_ACCESS
-
-static unsigned long
-read_mac_(unsigned int address)
-{
-
-	unsigned long value_ = readio(address);
-
-	switch (address & 0xfffff000) {
-
-	case rx_base:
-		printk("-MAC-   RX + 0x%04x => 0x%08lx\n", (address & 0x1fff),
-		       value_);
-		break;
-
-	case tx_base:
-		printk("-MAC-   TX + 0x%04x => 0x%08lx\n", (address & 0x1fff),
-		       value_);
-		break;
-
-	case dma_base:
-		printk("-MAC-  DMA + 0x%04x => 0x%08lx\n", (address & 0x1fff),
-		       value_);
-		break;
-
-	default:
-		ERROR_PRINT("ARGHHHHH!!!\n");
-		break;
-
-	}
-
-	return value_;
-
-}
-
-static void
-write_mac_(unsigned long value, unsigned int address)
-{
-
-	switch (address & 0xfffff000) {
-
-	case rx_base:
-		printk("-MAC-   RX + 0x%04x <= 0x%08lx\n", (address & 0x1fff),
-		       value);
-		break;
-
-	case tx_base:
-		printk("-MAC-   TX + 0x%04x <= 0x%08lx\n", (address & 0x1fff),
-		       value);
-		break;
-
-	case dma_base:
-		printk("-MAC-  DMA + 0x%04x <= 0x%08lx\n", (address & 0x1fff),
-		       value);
-		break;
-
-	default:
-		ERROR_PRINT("ARGHHHHH!!!\n");
-		break;
-
-	}
-
-	writeio(value, address);
-	return;
-
-}
-
-#else				/* ! LOG_MAC_ACCESS */
-
-#define read_mac_(address) readio((address))
-#define write_mac_(value, address) writeio((value), (address))
-
-#endif
-
-#ifndef PHYLESS
-#ifdef LOG_PHY_ACCESS
-
-static unsigned long
-read_phy_(unsigned int address)
-{
-
-	unsigned long value_ = readl(address);
-	printk("-PHY- HOST + 0x%04x => 0x%08lx\n", (address & 0xff), value_);
-	return value_;
-
-}
-
-static void
-write_phy_(unsigned long value, unsigned int address)
-{
-
-	printk("-PHY- HOST + 0x%04x <= 0x%08lx\n", (address & 0xff), value);
-	writel(value, address);
-	return;
-
-}
-
-#else				/* ! LOG_PHY_ACCESS */
-
-#define read_phy_(address) readl((address))
-#define write_phy_(value, address) writel(value, address)
-
-#endif
-#endif				/* PHYLESS */
-
-/*
-  ======================================================================
-  ======================================================================
-  ======================================================================
-
-  Module Information
-
-  ======================================================================
-  ======================================================================
-  ======================================================================
-*/
-
-MODULE_AUTHOR("John Jacques");
-MODULE_DESCRIPTION("Agere APP3xx ethernet driver");
-MODULE_LICENSE("GPL");
-
-/*
-  ----- Note On Buffer Space -----
-
-  Minimum number of descriptors is 64 for the receiver and 64 for the
-  transmitter; therefore, 2048 bytes (16 bytes each).
-  This driver uses the following parameters,
-  all of which may be set on the command line if this drivers is used
-  as a module.
-
-  - rx_num_desc : Number of receive descriptors.  This  must be a multiple of
-  64.
-  - tx_num_desc : Number of transmit descriptors.  This must be a multiple of
-  64.
-
-  The scheme used will be as follows:
-
-  - num_[rt]x_desc will be adjusted to be a multiple of 64 (if necessary).
-  - An skb (with the data area 64 byte aligned) will be allocated for each rx
-  descriptor.
-*/
-
-/*
-  Receiver
-*/
-
-int rx_num_desc = (CONFIG_LSI_NET_NUM_RX_DESC * DESCRIPTOR_GRANULARITY);
-module_param(rx_num_desc, int, 0);
-MODULE_PARM_DESC(rx_num_desc, "appnic : Number of receive descriptors");
-
-int rx_buf_sz = CONFIG_LSI_NET_RX_BUF_SZ;
-module_param(rx_buf_sz, int, 0);
-MODULE_PARM_DESC(rx_buf_sz, "appnic : Receive buffer size");
-
-/*
-  Transmitter
-*/
-
-int tx_num_desc = (CONFIG_LSI_NET_NUM_TX_DESC * DESCRIPTOR_GRANULARITY);
-module_param(tx_num_desc, int, 0);
-MODULE_PARM_DESC(tx_num_desc, "appnic : Number of receive descriptors");
-
-int tx_buf_sz = CONFIG_LSI_NET_TX_BUF_SZ;
-module_param(tx_buf_sz, int, 0);
-MODULE_PARM_DESC(tx_buf_sz, "Appnic : Receive buffer size");
-
-/*
-  Timeout, if a transmit takes longer than this
-  value in jiffies it has timed out.
-*/
-
-#define DEFAULT_TX_TIMEOUT 10
-
-int tx_timeout = DEFAULT_TX_TIMEOUT;
-module_param(tx_timeout, int, 0);
-MODULE_PARM_DESC(tx_timeout, "appnic : Transmit timeout (in jiffies)");
-
-/*
-  Only 1 device is possible...
-*/
-
-struct net_device *this_net_device;
-
-static unsigned long dropped_by_stack_;
-static unsigned long out_of_tx_descriptors_;
-static unsigned long transmit_interrupts_;
-#ifdef LSINET_NAPI
-static unsigned long receive_interrupts_;
-#endif
-
-#define APPNIC_TIMER_PERIOD 5
-#ifndef PHYLESS
-static void appnic_timer_handler_(unsigned long);
-static struct timer_list appnic_timer_;
-#endif				/* PHYLESS */
-
-/*
-  ======================================================================
-  ======================================================================
-  ======================================================================
-
-  Locking...
-
-  ======================================================================
-  ======================================================================
-  ======================================================================
-*/
-
-#ifdef CONFIG_SMP
-/*
- * On SMP we have the following problem:
- *
- *      A = smc_hard_start_xmit()
- *      B = smc_interrupt()
- *
- * A and B can never be executed simultaneously.  However, at least on UP,
- * it is possible (and even desirable) for C to interrupt execution of
- * A or B in order to have better RX reliability and avoid overruns.
- * C, just like A and B, must have exclusive access to the chip and
- * each of them must lock against any other concurrent access.
- * Unfortunately this is not possible to have C suspend execution of A or
- * B taking place on another CPU. On UP this is no an issue since A and B
- * are run from softirq context and C from hard IRQ context, and there is
- * no other CPU where concurrent access can happen.
- * If ever there is a way to force at least B and C to always be executed
- * on the same CPU then we could use read/write locks to protect against
- * any other concurrent access and C would always interrupt B. But life
- * isn't that easy in a SMP world...
- */
-
-#define appnic_special_trylock(lock)	\
-	({									\
-		int __ret;						\
-		unsigned long flags;			\
-		local_irq_save(flags);			\
-		__ret = spin_trylock(lock);		\
-		if (!__ret)						\
-			local_irq_restore(flags);	\
-		__ret;							\
-	})
-#define appnic_special_lock(lock, flags)	spin_lock_irqsave(lock, flags)
-#define appnic_special_unlock(lock, flags)	spin_unlock_irqrestore(lock, flags)
-#else
-#define appnic_special_trylock(lock)            (1)
-#define appnic_special_lock(lock, flags)	do {} while (0)
-#define appnic_special_unlock(lock, flags)	do {} while (0)
-#endif
-
-/*
-  ======================================================================
-  ======================================================================
-  ======================================================================
-
-  Utility Functions
-
-  ======================================================================
-  ======================================================================
-  ======================================================================
-*/
-
-/*
-  ----------------------------------------------------------------------
-  clear_statistics_
-*/
-
-static void
-clear_statistics_(appnic_device_t *device)
-{
-
-	int waste_;
-
-	/*
-	   Clear memory.
-	 */
-
-	memset((void *) &(device->stats), 0, sizeof(struct net_device_stats));
-
-	/*
-	   Clear counters.
-	 */
-
-	waste_ = read_mac_(APPNIC_RX_STAT_PACKET_OK);	/* rx_packets */
-	waste_ = read_mac_(APPNIC_TX_STAT_PACKET_OK);	/* tx_packets */
-	/* rx_bytes kept by driver. */
-	/* tx_bytes kept by driver. */
-	/* rx_errors will be the sum of the rx errors available. */
-	/* tx_errors will be the sum of the tx errors available. */
-	/* rx_dropped (unable to allocate skb) will be maintained by the driver */
-	/* tx_dropped (unable to allocate skb) will be maintained by the driver */
-	/* multicast */
-	waste_ = read_mac_(APPNIC_RX_STAT_MULTICAST);
-	/* collisions will be the sum of the three following. */
-	waste_ = read_mac_(APPNIC_TX_STATUS_LATE_COLLISION);
-	waste_ = read_mac_(APPNIC_TX_STATUS_EXCESSIVE_COLLISION);
-	waste_ = read_mac_(APPNIC_TX_STAT_COLLISION_ABOVE_WATERMARK);
-	/* rx_length_errors will be the sum of the two following. */
-	waste_ = read_mac_(APPNIC_RX_STAT_UNDERSIZE);
-	waste_ = read_mac_(APPNIC_RX_STAT_OVERSIZE);
-	/* rx_over_errors (out of descriptors?) maintained by the driver. */
-	/* rx_crc_errors */
-	waste_ = read_mac_(APPNIC_RX_STAT_CRC_ERROR);
-	/* rx_frame_errors */
-	waste_ = read_mac_(APPNIC_RX_STAT_ALIGN_ERROR);
-	/* rx_fifo_errors */
-	waste_ = read_mac_(APPNIC_RX_STAT_OVERFLOW);
-	/* rx_missed will not be maintained. */
-	/* tx_aborted_errors will be maintained by the driver. */
-	/* tx_carrier_errors will not be maintained. */
-	/* tx_fifo_errors */
-	waste_ = read_mac_(APPNIC_TX_STAT_UNDERRUN);
-	/* tx_heartbeat_errors */
-	/* tx_window_errors */
-
-	/* rx_compressed will not be maintained. */
-	/* tx_compressed will not be maintained. */
-
-	/*
-	   That's all.
-	 */
-
-	return;
-
-}
-
-/*
-  ----------------------------------------------------------------------
-  get_hw_statistics_
-
-  -- NOTES --
-
-  1) The hardware clears the statistics registers after a read.
-*/
-
-static void
-get_hw_statistics_(appnic_device_t *device)
-{
-
-	/* tx_packets */
-	device->stats.tx_packets += read_mac_(APPNIC_TX_STAT_PACKET_OK);
-	/* multicast */
-	device->stats.multicast += read_mac_(APPNIC_RX_STAT_MULTICAST);
-	/* collision */
-	device->stats.collisions += read_mac_(APPNIC_TX_STATUS_LATE_COLLISION);
-	device->stats.collisions +=
-	    read_mac_(APPNIC_TX_STATUS_EXCESSIVE_COLLISION);
-	device->stats.collisions +=
-	    read_mac_(APPNIC_TX_STAT_COLLISION_ABOVE_WATERMARK);
-	/* rx_length_errors */
-	device->stats.rx_length_errors += read_mac_(APPNIC_RX_STAT_UNDERSIZE);
-	device->stats.rx_length_errors += read_mac_(APPNIC_RX_STAT_OVERSIZE);
-	/* tx_fifo_errors */
-	device->stats.tx_fifo_errors += read_mac_(APPNIC_TX_STAT_UNDERRUN);
-
-	/*
-	   Lock this section out so the statistics maintained by the driver
-	   don't get clobbered.
-	 */
-
-	{
-
-		unsigned long flags_;
-
-		spin_lock_irqsave(&device->lock, flags_);
-
-		device->stats.rx_errors +=
-		    (device->stats.rx_length_errors +
-		     device->stats.rx_crc_errors +
-		     device->stats.rx_frame_errors +
-		     device->stats.rx_fifo_errors +
-		     device->stats.rx_dropped + device->stats.rx_over_errors);
-		device->stats.rx_dropped = 0;
-		device->stats.rx_over_errors = 0;
-
-		device->stats.tx_errors +=
-		    (device->stats.tx_fifo_errors +
-		     device->stats.tx_aborted_errors);
-		device->stats.tx_aborted_errors = 0;
-
-		spin_unlock_irqrestore(&device->lock, flags_);
-
-	}
-
-	/*
-	   That's all.
-	 */
-
-	return;
-
-}
-
-/*
-  ----------------------------------------------------------------------
-  queue_initialized_
-
-  Returns the number of descriptors that are ready to receive packets
-  or are waiting to transmit packets.  (from tail to head).
-*/
-
-static int
-queue_initialized_(appnic_queue_pointer_t head,
-		   appnic_queue_pointer_t tail, int size)
-{
-	int initialized;
-
-	/* Calculate the number of descriptors currently initialized. */
-
-	if (head.bits.generation_bit == tail.bits.generation_bit) {
-
-		/* same generation */
-		initialized = (head.bits.offset - tail.bits.offset);
-
-	} else {
-
-		/* different generation */
-		initialized = head.bits.offset +
-		    (size * sizeof(appnic_dma_descriptor_t) -
-		     tail.bits.offset);
-
-	}
-
-	/* number of descriptors is offset / sizeof( a descriptor ) */
-	initialized /= sizeof(appnic_dma_descriptor_t);
-
-	return initialized;
-}
-
-/*
-  ----------------------------------------------------------------------
-  queue_uninitialzed_
-
-  Returns the number of unused/uninitialized descriptors.  (from head to tail).
-*/
-
-static int
-queue_uninitialized_(appnic_queue_pointer_t head,
-		     appnic_queue_pointer_t tail, int size)
-{
-
-	int allocated_;
-
-	/* calculate the number of descriptors currently unused/uninitialized */
-
-	if (head.bits.generation_bit == tail.bits.generation_bit) {
-
-		/* same generation. */
-		allocated_ =
-		    ((size * sizeof(appnic_dma_descriptor_t)) -
-		     head.bits.offset) + tail.bits.offset;
-
-	} else {
-
-		/* different generation. */
-		allocated_ = tail.bits.offset - head.bits.offset;
-
-	}
-
-	/* number of descriptors is offset / sizeof( a descriptor ). */
-	allocated_ /= sizeof(appnic_dma_descriptor_t);
-
-	/* that's all */
-	return allocated_;
-
-}
-
-/*
-  ----------------------------------------------------------------------
-  queue_increment_
-*/
-
-static void
-queue_increment_(appnic_queue_pointer_t *queue, int number_of_descriptors)
-{
-
-	queue->bits.offset += sizeof(appnic_dma_descriptor_t);
-
-	if ((number_of_descriptors * sizeof(appnic_dma_descriptor_t)) ==
-	    queue->bits.offset) {
-
-		queue->bits.offset = 0;
-		queue->bits.generation_bit =
-		    (0 == queue->bits.generation_bit) ? 1 : 0;
-
-	}
-
-	return;
-
-}
-
-/*
-  ----------------------------------------------------------------------
-  queue_decrement_
-*/
-
-static void
-queue_decrement_(appnic_queue_pointer_t *queue, int number_of_descriptors)
-{
-
-	if (0 == queue->bits.offset) {
-
-		queue->bits.offset =
-		    ((number_of_descriptors -
-		      1) * sizeof(appnic_dma_descriptor_t));
-		queue->bits.generation_bit =
-		    (0 == queue->bits.generation_bit) ? 1 : 0;
-
-	} else {
-
-		queue->bits.offset -= sizeof(appnic_dma_descriptor_t);
-
-	}
-
-	return;
-
-}
-
-/*
-  ----------------------------------------------------------------------
-  appnic_timer_handler_
-*/
-
-#ifndef PHYLESS
-
-static void
-appnic_timer_handler_(unsigned long __opaque)
-{
-
-	struct net_device *device_ = (struct net_device *) __opaque;
-
-	PHY_DEBUG_PRINT("Handling Timer Expiration.\n");
-	enable_(device_);
-	appnic_timer_.expires = jiffies + (APPNIC_TIMER_PERIOD * HZ);
-	add_timer(&appnic_timer_);
-
-}
-
-#endif
-
-/*
-  ----------------------------------------------------------------------
-  enable_
-
-  -- NOTES --
-
-  1) Does not change the default values in the extended and
-  half-duplex configuration registers.
-*/
-
-static int
-enable_(struct net_device *device)
-{
-
-#ifndef PHYLESS
-
-	int return_code_ = 1;
-	int carrier_state_ = 0;
-	unsigned long rx_configuration_;
-	unsigned long tx_configuration_ = 0;
-	phy_status_t phy_status_;
-
-	rx_configuration_ =
-	    (APPNIC_RX_CONF_STRIPCRC |
-	     APPNIC_RX_CONF_RXFCE | APPNIC_RX_CONF_TXFCE);
-	tx_configuration_ =
-	    (APPNIC_TX_CONF_ENABLE_SWAP_SA |
-	     APPNIC_TX_CONF_APP_CRC_ENABLE | APPNIC_TX_CONF_PAD_ENABLE);
-	TX_CONF_SET_IFG(tx_configuration_, 0xf);
-
-	DEBUG_PRINT("Enabling the interface.\n");
-
-	/*
-	   Setup the receive and transmit configuration registers (using smii
-	   status to set speed/duplex and check the link status).
-	 */
-
-	if ((0 == phy_read_(phy_address_, PHY_STATUS, &phy_status_.raw)) &&
-	    (0 == phy_read_(phy_address_, PHY_STATUS, &phy_status_.raw))) {
-
-		PHY_DEBUG_PRINT("phy_status_.raw=0x%x\n", phy_status_.raw);
-
-		if (1 == phy_status_.bits.autoneg_comp) {
-
-			if (1 == phy_status_.bits.link_status) {
-
-				if (1 == phy_speed_(phy_address_)) {
-
-					rx_configuration_ |=
-					    APPNIC_RX_CONF_SPEED;
-					tx_configuration_ |=
-					    APPNIC_TX_CONF_SPEED;
-
-				}
-
-				if (1 == phy_duplex_(phy_address_)) {
-
-					rx_configuration_ |=
-					    APPNIC_RX_CONF_DUPLEX;
-					tx_configuration_ |=
-					    APPNIC_TX_CONF_DUPLEX;
-
-				}
-
-				rx_configuration_ |=
-				    (APPNIC_RX_CONF_ENABLE |
-				     APPNIC_RX_CONF_LINK);
-				tx_configuration_ |=
-				    (APPNIC_TX_CONF_LINK |
-				     APPNIC_TX_CONF_ENABLE);
-				return_code_ = 0;
-				carrier_state_ = 1;
-
-			} else {
-
-				netif_carrier_off(device);
-
-			}
-
-		} else {
-
-			netif_carrier_off(device);
-
-		}
-
-	} else {
-
-		ERROR_PRINT("phy_read_( ) failed!\n");
-
-	}
-
-#else				/* PHYLESS */
-
-	int return_code_ = 1;
-	int carrier_state_ = 0;
-	unsigned long rx_configuration_;
-	unsigned long tx_configuration_ = 0;
-
-	rx_configuration_ = APPNIC_RX_CONF_STRIPCRC;
-	tx_configuration_ =
-	    (APPNIC_TX_CONF_ENABLE_SWAP_SA |
-	     APPNIC_TX_CONF_APP_CRC_ENABLE | APPNIC_TX_CONF_PAD_ENABLE);
-	TX_CONF_SET_IFG(tx_configuration_, 0xf);
-
-	/*
-	   100/Half
-	 */
-	rx_configuration_ |=
-	    (APPNIC_RX_CONF_ENABLE | APPNIC_RX_CONF_LINK |
-	     APPNIC_RX_CONF_SPEED);
-	tx_configuration_ |=
-	    (APPNIC_TX_CONF_ENABLE | APPNIC_TX_CONF_LINK |
-	     APPNIC_TX_CONF_SPEED);
-
-	return_code_ = 0;
-	carrier_state_ = 1;
-
-#endif				/* PHYLESS */
-
-	if (rx_configuration_ != read_mac_(APPNIC_RX_CONF))
-		write_mac_(rx_configuration_, APPNIC_RX_CONF);
-
-	if (tx_configuration_ != read_mac_(APPNIC_TX_CONF))
-		write_mac_(tx_configuration_, APPNIC_TX_CONF);
-
-	if (0 != carrier_state_)
-		netif_carrier_on(device);
-	else
-		netif_carrier_off(device);
-
-	return return_code_;
-
-}
-
-/*
-  ----------------------------------------------------------------------
-  disable_
-*/
-
-static void
-disable_(void)
-{
-
-	unsigned long tx_configuration_;
-	unsigned long rx_configuration_;
-
-	DEBUG_PRINT("Disabling the interface.\n");
-
-	rx_configuration_ = read_mac_(APPNIC_RX_CONF);
-	rx_configuration_ &= ~APPNIC_RX_CONF_ENABLE;
-	write_mac_(rx_configuration_, APPNIC_RX_CONF);
-
-	tx_configuration_ = read_mac_(APPNIC_TX_CONF);
-	tx_configuration_ &= ~APPNIC_TX_CONF_ENABLE;
-	write_mac_(tx_configuration_, APPNIC_TX_CONF);
-
-	/* that's all. */
-	return;
-
-}
-
-void
-disable_nic_(void)
-{
-
-	disable_();
-
-}
-
-/*
-  ======================================================================
-  ======================================================================
-  ======================================================================
-  PHY interface (BCM5221)
-  ======================================================================
-  ======================================================================
-  ======================================================================
-*/
-
-#ifndef PHYLESS
-
-/*
-  ----------------------------------------------------------------------
-  phy_read_
-
-  Returns -1 if unsuccessful, the (short) value otherwise.
-*/
-
-static int
-phy_read_(int phy, int reg, unsigned short *value)
-{
-	return acp_mdio_read(phy, reg, value);
-}
-
-/*
-  ----------------------------------------------------------------------
-  phy_write_
-*/
-
-static int
-phy_write_(int phy, int reg, unsigned short value)
-{
-	return acp_mdio_write(phy, reg, value);
-}
-
-#ifndef CONFIG_ACP
-/*
-  ----------------------------------------------------------------------
-  phy_link_
-
-  Returns the link status (1=link up, 0=link down) or an error (-1).
-*/
-
-static int
-phy_link_(int phy)
-{
-	phy_status_t status;
-
-	phy_read_(phy, PHY_STATUS, &status.raw);
-	phy_read_(phy, PHY_STATUS, &status.raw);
-
-	return status.bits.link_status;
-}
-#endif
-
-/*
-  ----------------------------------------------------------------------
-  phy_speed_
-
-  Returns the speed (1=100, 0=10) or an error (-1).
-*/
-
-static int
-phy_speed_(int phy)
-{
-	micrel_phy_auxiliary_control_status_t aux;
-
-	phy_read_(phy, MICREL_PHY_AUXILIARY_CONTROL_STATUS, &aux.raw);
-	switch ((aux.bits.op_mode_indication & 3)) {
-	case 2:
-		return 1;
-		break;
-	case 1:
-		return 0;
-		break;
-	default:
-		break;
-	}
-
-	return -1;
-}
-
-/*
-  ----------------------------------------------------------------------
-  phy_duplex_
-
-  Returns duplex status (1=full duplex, 0=half duplex) or an error (-1).
-*/
-
-static int
-phy_duplex_(int phy)
-{
-	micrel_phy_auxiliary_control_status_t aux;
-
-	phy_read_(phy, MICREL_PHY_AUXILIARY_CONTROL_STATUS, &aux.raw);
-
-	return (aux.bits.op_mode_indication >> 2) & 0x1;
-}
-
-#ifndef CONFIG_ACP
-/*
-  ----------------------------------------------------------------------
-  phy_reset_
-*/
-
-static int
-phy_reset_(int phy)
-{
-	phy_control_t control;
-	int retries = 10;
-
-	phy_read_(phy, PHY_CONTROL, &control.raw);
-	control.bits.soft_reset = 1;
-	phy_write_(phy, PHY_CONTROL, control.raw);
-
-	do {
-		phy_read_(phy, PHY_CONTROL, &control.raw);
-		--retries;
-	} while ((0 < retries) && (0 != control.bits.soft_reset));
-
-	if (0 != control.bits.soft_reset) {
-		printk("phy_reset( %d ) failed.\n", phy);
-		return -1;
-	}
-
-	return 0;
-}
-#endif
-
-/*
-  ----------------------------------------------------------------------
-  phy_renegotiate_
-*/
-
-static int
-phy_renegotiate_(int phy)
-{
-	phy_control_t control;
-	phy_status_t status;
-	int autoneg_retries = 4;
-	int autoneg_complete_retries = 8;
-
-	printk("Initiating Auto Negotiation");
-
-	do {
-		phy_read_(phy, PHY_CONTROL, &control.raw);
-		control.bits.restart_autoneg = 1;
-		phy_write_(phy, PHY_CONTROL, control.raw);
-
-		do {
-			udelay(500000);
-			phy_read_(phy, PHY_STATUS, &status.raw);
-		} while ((0 < --autoneg_complete_retries) &&
-			 (0 == status.bits.autoneg_comp));
-
-		if (0 != status.bits.autoneg_comp)
-			break;
-
-		printk(".");
-	} while (0 < --autoneg_retries);
-
-	printk("\n");
-
-	if (0 == status.bits.autoneg_comp) {
-		printk("Auto Negotiation Failed\n");
-		return -1;
-	}
-
-	printk("Auto Negotiation Succeeded\n");
-	return 0;
-}
-
-/*
-  ----------------------------------------------------------------------
-  phy_enable_
-*/
-
-extern int ubootenv_get(const char *, char *);
-
-static int
-phy_enable_(int phy)
-{
-
-#ifdef CONFIG_ACP
-	unsigned short ad_value;
-	phy_address_ = 0x1e;
-
-	ad_value = PHY_AUTONEG_ADVERTISE_100FULL |
-	    PHY_AUTONEG_ADVERTISE_100 |
-	    PHY_AUTONEG_ADVERTISE_10FULL | PHY_AUTONEG_ADVERTISE_10;
-
-	if (0 != phy_write_(phy_address_, PHY_AUTONEG_ADVERTISE, ad_value))
-		return -1;
-
-	phy_renegotiate_(phy_address_);
-#else
-	/*
-	   Set up the MDIO clock.
-	 */
-
-	{
-
-		char mdio_clock_speed_string_[256];
-		unsigned long mdio_clock_speed_;
-		unsigned long mdio_divisor_;
-#ifdef CONFIG_LSI_UBOOTENV
-		if (0 != ubootenv_get("mdio_clock", mdio_clock_speed_string_)) {
-
-			mdio_clock_speed_ = 1250000;
-
-		} else {
-
-			mdio_clock_speed_ =
-			    simple_strtoul(mdio_clock_speed_string_, NULL, 0);
-
-		}
-#else
-		mdio_clock_speed_ = 1250000;
-#endif
-
-#ifdef CONFIG_ARCH_APP3K
-		mdio_divisor_ = ((get_core_speed() / 2) / mdio_clock_speed_);
-#else
-		mdio_divisor_ = (get_core_speed() / mdio_clock_speed_);
-#endif
-
-		printk("Setting the MDIO clock to %lu Hz (divisor=%lu)\n",
-		       mdio_clock_speed_, mdio_divisor_);
-		writel(mdio_divisor_, MDIO_CLK_);
-
-	}
-
-	/*
-	   Get the PHY address.
-	 */
-
-	{
-
-		char phy_address_string_[256];
-#ifdef CONFIG_LSI_UBOOTENV
-		if (0 != ubootenv_get("phy_address", phy_address_string_)) {
-
-			phy_address_ = phy_scan_();
-
-		} else {
-
-			phy_address_ =
-			    simple_strtoul(phy_address_string_, NULL, 0);
-
-		}
-#else
-		phy_address_ = phy_scan_();
-#endif
-		if (31 < phy_address_ || 0 > phy_address_) {
-
-			ERROR_PRINT("Unable to get valid PHY address!\n");
-			return -EBUSY;
-
-		}
-
-	}
-
-	/*
-	   Get PHY type.
-	 */
-
-	{
-
-		phy_id_high_t phy_id_high_;
-		phy_id_low_t phy_id_low_;
-
-		if (0 !=
-		    phy_read_(phy_address_, PHY_ID_HIGH_, &phy_id_high_.raw)) {
-
-			TRACE_ENDING();
-			return -1;
-
-		}
-
-		if (0 != phy_read_(phy_address_, PHY_ID_LOW_, &phy_id_low_.raw)) {
-
-			TRACE_ENDING();
-			return -1;
-
-		}
-
-		if ((PHY_ID_HIGH_ID == phy_id_high_.bits.id) &&
-		    (BC_PHY_ID_LOW_ID_ == phy_id_low_.bits.id) &&
-		    (BC_PHY_ID_LOW_MODEL_ == phy_id_low_.bits.model)) {
-
-			phy_type_ = BCM5221_PHY_;
-			printk("Broadcomm 5221 PHY at 0x%x\n", phy_address_);
-
-		} else if ((M_PHY_ID_HIGH_ID_ == phy_id_high_.bits.id) &&
-			   (M_PHY_ID_LOW_ID_ == phy_id_low_.bits.id)) {
-
-			phy_type_ = MICREL_PHY_;
-			printk("Micrel PHY at 0x%x, Model 0x%x\n",
-			       phy_address_, phy_id_low_.bits.model);
-
-		} else {
-
-			phy_type_ = UNKNOWN_PHY_;
-			printk("Unknown PHY at 0x%x.  0x%x 0x%x 0x%x\n",
-			       phy_address_, phy_id_high_.bits.id,
-			       phy_id_low_.bits.id, phy_id_low_.bits.model);
-
-		}
-
-	}
-
-	if (-1 != phy_address_) {
-
-		int link_status_retries_ = 10;
-		phy_status_t phy_status_;
-		char ad_value_string_[40];
-		unsigned short ad_value_;
-
-		DEBUG_PRINT("Initializing PHY at 0x%x\n", phy_address_);
-
-		if (0 != phy_reset_(phy_address_))
-			return -1;
-
-		/*
-		   0x1e1 - 10/100 half/full
-		   0xe1 - 100 half, 10 half/full
-		   0x61 - 10 half/full
-		   0x41 - 10 half
-		 */
-#ifdef CONFIG_LSI_UBOOTENV
-		if (0 != ubootenv_get("ad_value", ad_value_string_)) {
-#endif
-			if ((is_asic) &&
-			    (0 == (APP3XX_REVISION_REGISTER & 0x1f))) {
-
-				/* 10M does not work on ASIC v1.0 */
-				ad_value_ = 0x0181;
-
-			} else {
-
-				/* For FGPA loads and any ASIC after v1.0, default to 10 full/half */
-				ad_value_ = 0x061;
-
-			}
-
-			WARN_PRINT("ad_value not set, using 0x%x\n", ad_value_);
-#ifdef CONFIG_LSI_UBOOTENV
-		} else {
-
-			ad_value_ = simple_strtoul(ad_value_string_, NULL, 0);
-
-		}
-#endif
-
-		if (0 != phy_write_(phy_address_, PHY_AUTONEG_ADVERTISE_,
-				    ad_value_)) {
-
-			TRACE_ENDING();
-			return -1;
-
-		}
-
-		if (0 != phy_renegotiate_(phy_address_))
-			WARN_PRINT("PHY: Auto Negotiation Failed.\n");
-
-		do {
-			if (0 !=
-			    phy_read_(phy_address_, PHY_STATUS,
-				      &phy_status_.raw)) {
-
-				return -1;
-
-			}
-
-			mdelay(10);
-			--link_status_retries_;
-
-		} while ((0 == phy_status_.bits.link_status) &&
-			 (0 < link_status_retries_));
-
-		if (0 == phy_status_.bits.link_status) {
-
-			WARN_PRINT("PHY: link down\n");
-
-		} else {
-
-			printk("PHY: link=%s speed=%d Mbs duplex=%s\n",
-			       (1 == phy_link_(phy_address_)) ? "up" : "down",
-			       (1 == phy_speed_(phy_address_)) ? 100 : 10,
-			       (1 ==
-				phy_duplex_(phy_address_)) ? "full" : "half");
-
-		}
-
-	}
-#endif
-
-	/*
-	   That's all
-	 */
-
-	return 0;
-
-}
-
-#endif				/* PHYLESS */
-
-/*
-  ======================================================================
-  ======================================================================
-  ======================================================================
-
-  Linux Network Driver Interface
-
-  ======================================================================
-  ======================================================================
-  ======================================================================
-*/
-
-/*
-  ----------------------------------------------------------------------
-  handle_transmit_interrupt_
-*/
-
-static void
-handle_transmit_interrupt_(struct net_device *device)
-{
-
-	appnic_device_t *dev_ = netdev_priv(device);
-
-	TRACE_BEGINNING();
-	DEBUG_PRINT("tail=0x%lx tail_copy=0x%lx head=0x%lx\n",
-		    dev_->tx_tail->raw, dev_->tx_tail_copy.raw,
-		    dev_->tx_head.raw);
-
-	/*
-	   The hardware's tail pointer should be one descriptor (or more)
-	   ahead of software's copy.
-	 */
-
-	while (0 < queue_initialized_(SWAB_QUEUE_POINTER(dev_->tx_tail),
-				      dev_->tx_tail_copy, dev_->tx_num_desc)) {
-		queue_increment_(&dev_->tx_tail_copy, dev_->tx_num_desc);
-	}
-
-	DEBUG_PRINT("tail=0x%lx tail_copy=0x%lx head=0x%lx\n",
-		    dev_->tx_tail->raw, dev_->tx_tail_copy.raw,
-		    dev_->tx_head.raw);
-	TRACE_ENDING();
-
-	return;
-
-}
-
-/*
-  ----------------------------------------------------------------------
-  lsinet_rx_packet
-*/
-
-static void
-lsinet_rx_packet(struct net_device *device)
-{
-	appnic_device_t *adapter = netdev_priv(device);
-	appnic_dma_descriptor_t descriptor;
-	struct sk_buff *sk_buff_;
-
-#ifdef __APPNIC_C_PROFILE__
-	unsigned long ts0_ = 0;
-	unsigned long ts1_ = 0;
-	unsigned long ts2_ = 0;
-	unsigned long ts3_ = 0;
-	int sent_up = 0;
-	ts0_ = (0xffffffff - readl((TIMER7_BASE + TIMER_n_VALUE)));
-#endif				/* __APPNIC_C_PROFILE__ */
-
-	/* TEMP HACK:
-	 * should use down_interruptible
-	 */
-	spin_lock(&adapter->extra_lock);
-	TRACE_BEGINNING();
-	DEBUG_PRINT("head=0x%lx tail=0x%lx tail_copy=0x%lx\n",
-		    adapter->rx_head.raw, adapter->rx_tail->raw,
-		    adapter->rx_tail_copy.raw);
-	readdescriptor(((unsigned long) adapter->rx_desc +
-			adapter->rx_tail_copy.bits.offset), &descriptor);
-
-	sk_buff_ = dev_alloc_skb(1600);
-	if ((struct sk_buff *) 0 != sk_buff_) {
-		unsigned bytes_copied_ = 0;
-		unsigned error_ = 0;
-		int return_code_;
-		unsigned long ok_, overflow_, crc_, align_;
-
-#ifdef __APPNIC_C_PROFILE__
-		ts1_ = (0xffffffff - readl((TIMER7_BASE + TIMER_n_VALUE)));
-#endif				/* __APPNIC_C_PROFILE__ */
-
-		ok_ = read_mac_(APPNIC_RX_STAT_PACKET_OK);
-		overflow_ = read_mac_(APPNIC_RX_STAT_OVERFLOW);
-		crc_ = read_mac_(APPNIC_RX_STAT_CRC_ERROR);
-		align_ = read_mac_(APPNIC_RX_STAT_ALIGN_ERROR);
-
-		/*
-		   Copy the received packet into the skb.
-		 */
-
-		while (0 <
-		       queue_initialized_(SWAB_QUEUE_POINTER(adapter->rx_tail),
-					  adapter->rx_tail_copy,
-					  adapter->rx_num_desc)) {
-			/*TRACER_POST( "tail_copy=0x%x", adapter->rx_tail_copy.raw ); */
-#ifdef PRELOAD_RX_BUFFERS
-			{
-				unsigned char *buffer_;
-				buffer_ =
-				    skb_put(sk_buff_, descriptor.pdu_length);
-				memcmp(buffer_, buffer_, descriptor.pdu_length);
-				memcpy((void *) buffer_,
-				       (void *) (descriptor.
-						 host_data_memory_pointer +
-						 adapter->dma_alloc_offset),
-				       descriptor.pdu_length);
-			}
-#else				/* PRELOAD_RX_BUFFERS */
-			memcpy((void *)
-			       skb_put(sk_buff_, descriptor.pdu_length),
-			       (void *) (descriptor.host_data_memory_pointer +
-					 adapter->dma_alloc_offset),
-			       descriptor.pdu_length);
-#endif				/* PRELOAD_RX_BUFFERS */
-			bytes_copied_ += descriptor.pdu_length;
-			descriptor.data_transfer_length =
-			    adapter->rx_buf_per_desc;
-			writedescriptor(((unsigned long) adapter->rx_desc +
-					 adapter->rx_tail_copy.bits.offset),
-					&descriptor);
-			if (0 != descriptor.error)
-				error_ = 1;
-
-			queue_increment_(&adapter->rx_tail_copy,
-					 adapter->rx_num_desc);
-			if (0 != descriptor.end_of_packet)
-				break;
-
-			readdescriptor(((unsigned long) adapter->rx_desc +
-					adapter->rx_tail_copy.bits.offset),
-				       &descriptor);
-		}
-
-		if (0 == descriptor.end_of_packet) {
-
-			ERROR_PRINT("No end of packet! %lu/%lu/%lu/%lu\n",
-				    ok_, overflow_, crc_, align_);
-			BUG();
-			dev_kfree_skb(sk_buff_);
-
-		} else {
-
-			if (0 == error_) {
-
-				struct ethhdr *ethhdr_ =
-				    (struct ethhdr *) sk_buff_->data;
-				unsigned char broadcast_[] = {
-					0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
-				unsigned char multicast_[] = {0x01, 0x00};
-
-				LSINET_COUNTS_INC(LSINET_COUNTS_RX_GOOD);
-
-				if ((0 ==
-				     memcmp((const void *)
-					    &(ethhdr_->h_dest[0]),
-					    (const void *) &(device->
-							     dev_addr[0]),
-					    sizeof(ethhdr_->h_dest)))
-				    || (0 ==
-					memcmp((const void *)
-					       &(ethhdr_->h_dest[0]),
-					       (const void *) &(broadcast_[0]),
-					       sizeof(ethhdr_->h_dest)))
-				    || (0 ==
-					memcmp((const void *)
-					       &(ethhdr_->h_dest[0]),
-					       (const void *) &(multicast_[0]),
-					       sizeof(multicast_)))) {
-
-#ifdef __APPNIC_C_PROFILE__
-					if (bytes_copied_ > rx_packet_size_max_) {
-						rx_packet_size_max_ =
-						    bytes_copied_;
-					} else if (bytes_copied_ <
-						   rx_packet_size_min_) {
-						rx_packet_size_min_ =
-						    bytes_copied_;
-					}
-					total_rx_bytes_ += bytes_copied_;
-
-					total_rx_packets_sent_up_++;
-					sent_up = 1;
-
-					ts2_ =
-					    (0xffffffff -
-					     readl((TIMER7_BASE +
-						    TIMER_n_VALUE)));
-#endif				/* __APPNIC_C_PROFILE__ */
-
-					adapter->stats.rx_bytes +=
-					    bytes_copied_;
-					++adapter->stats.rx_packets;
-					sk_buff_->dev = device;
-					sk_buff_->protocol =
-					    eth_type_trans(sk_buff_, device);
-#ifdef LSINET_NAPI
-					LSINET_COUNTS_INC
-					    (LSINET_COUNTS_RX_SENT);
-					return_code_ =
-					    netif_receive_skb(sk_buff_);
-#else
-					LSINET_COUNTS_INC
-					    (LSINET_COUNTS_RX_SENT);
-					return_code_ = netif_rx(sk_buff_);
-#endif
-
-					if (NET_RX_DROP == return_code_) {
-
-						++dropped_by_stack_;
-						LSINET_COUNTS_INC
-						    (LSINET_COUNTS_RX_DRPD);
-					}
-
-				} else {
-
-					dev_kfree_skb(sk_buff_);
-
-				}
-
-			} else {
-
-				LSINET_COUNTS_INC(LSINET_COUNTS_RX_ERR);
-
-				dev_kfree_skb(sk_buff_);
-
-				if (0 != overflow_)
-					++adapter->stats.rx_fifo_errors;
-				else if (0 != crc_)
-					++adapter->stats.rx_crc_errors;
-				else if (0 != align_)
-					++adapter->stats.rx_frame_errors;
-			}
-
-		}
-
-	} else {
-
-		ERROR_PRINT("dev_alloc_skb( ) failed!  Dropping packet.\n");
-
-	}
-
-	DEBUG_PRINT("head=0x%lx tail=0x%lx tail_copy=0x%lx\n",
-		    adapter->rx_head.raw, adapter->rx_tail->raw,
-		    adapter->rx_tail_copy.raw);
-	TRACE_ENDING();
-
-#ifdef __APPNIC_C_PROFILE__
-
-	app3xx_profile_time_calc(ts0_, ts1_,
-				 recv_t1_min_, recv_t1_max_, recv_t1_tot_);
-	/*
-	 * only calculate stats for packets that were sent up to the stack
-	 */
-	if (sent_up) {
-		ts3_ = (0xffffffff - readl((TIMER7_BASE + TIMER_n_VALUE)));
-
-		app3xx_profile_time_calc(ts1_, ts2_,
-					 recv_t2_min_, recv_t2_max_,
-					 recv_t2_tot_);
-		app3xx_profile_time_calc(ts2_, ts3_, recv_t3_min_, recv_t3_max_,
-					 recv_t3_tot_);
-	}
-#endif				/* __APPNIC_C_PROFILE__ */
-
-	/* TEMP */
-	spin_unlock(&adapter->extra_lock);
-	/* that's all */
-	return;
-
-}
-
-/*
-  ============================================
-  lsinet_rx_packets
-*/
-
-static int
-lsinet_rx_packets(struct net_device *device, int max)
-{
-	appnic_device_t *adapter = netdev_priv(device);
-	appnic_queue_pointer_t queue;
-	int updated_head_pointer = 0;
-	int packets = 0;
-
-	queue.raw = adapter->rx_tail_copy.raw;
-
-	/* Receive Packets */
-
-	while (0 < queue_initialized_(SWAB_QUEUE_POINTER(adapter->rx_tail),
-				      queue, adapter->rx_num_desc)) {
-		appnic_dma_descriptor_t descriptor;
-
-		readdescriptor(((unsigned long) adapter->rx_desc +
-				queue.bits.offset), &descriptor);
-
-		if (0 != descriptor.end_of_packet) {
-#ifdef __APPNIC_C_PROFILE__
-			++packets_handled_;
-#endif				/* __APPNIC_C_PROFILE__ */
-			LSINET_COUNTS_INC(LSINET_COUNTS_RX_PKT);
-			lsinet_rx_packet(device);
-			++packets;
-			queue.raw = adapter->rx_tail_copy.raw;
-
-			if (-1 != max) {
-				if (packets == max)
-					break;
-			}
-		} else {
-			queue_increment_(&queue, adapter->rx_num_desc);
-		}
-	}
-
-	/* Update the Head Pointer */
-
-	while (1 < queue_uninitialized_(adapter->rx_head, adapter->rx_tail_copy,
-					adapter->rx_num_desc)) {
-
-		appnic_dma_descriptor_t descriptor;
-
-		readdescriptor(((unsigned long) adapter->rx_desc +
-				adapter->rx_head.bits.offset), &descriptor);
-		descriptor.data_transfer_length = adapter->rx_buf_per_desc;
-		descriptor.write = 1;
-		descriptor.pdu_length = 0;
-		descriptor.start_of_packet = 0;
-		descriptor.end_of_packet = 0;
-		descriptor.interrupt_on_completion = 1;
-		writedescriptor(((unsigned long) adapter->rx_desc +
-				 adapter->rx_head.bits.offset), &descriptor);
-		queue_increment_(&adapter->rx_head, adapter->rx_num_desc);
-		updated_head_pointer = 1;
-	}
-
-	if (0 != updated_head_pointer)
-		write_mac_(adapter->rx_head.raw, APPNIC_DMA_RX_HEAD_POINTER);
-
-	return packets;
-}
-
-#ifdef LSINET_NAPI
-
-/*
-  ============================================
-  lsinet_poll
-*/
-
-static int
-lsinet_poll(struct napi_struct *napi, int budget)
-{
-	appnic_device_t *adapter = container_of(napi, appnic_device_t, napi);
-	struct net_device *device = adapter->device;
-	appnic_queue_pointer_t queue_;
-
-	int cur_budget = budget;
-	int done;
-	unsigned long dma_interrupt_status_;
-#ifdef __APPNIC_C_PROFILE__
-	unsigned long packets_handled_ = 0;
-	unsigned long beginning_;
-	unsigned long end_;
-
-	beginning_ = (0xffffffff - readl((TIMER7_BASE + TIMER_n_VALUE)));
-#endif				/* __APPNIC_C_PROFILE__ */
-
-	LSINET_COUNTS_INC(LSINET_COUNTS_POL_START);
-	/* TEMP DEBUG: should be interruptible */
-	/*down( & adapter->poll_sem); */
-
-	TRACE_BEGINNING();
-	DEBUG_PRINT("head=0x%x tail=0x%x tail_copy=0x%x\n",
-		    adapter->rx_head.raw, adapter->rx_tail->raw,
-		    adapter->rx_tail_copy.raw);
-	queue_.raw = adapter->rx_tail_copy.raw;
-
-	done = 1;
-
-	do {
-
-		/* Acknowledge the RX interrupt. */
-		write_mac_(~APPNIC_DMA_INTERRUPT_ENABLE_RECEIVE,
-			   APPNIC_DMA_INTERRUPT_STATUS);
-
-		cur_budget -= lsinet_rx_packets(device, cur_budget);
-		if (0 == cur_budget)
-			break;
-
-		dma_interrupt_status_ = read_mac_(APPNIC_DMA_INTERRUPT_STATUS);
-
-	} while ((RX_INTERRUPT(dma_interrupt_status_)) && cur_budget);
-
-	if (done) {
-		LSINET_COUNTS_INC(LSINET_COUNTS_POL_RNBL);
-		napi_complete(napi);
-		/* re-enable receive interrupts */
-		write_mac_((APPNIC_DMA_INTERRUPT_ENABLE_RECEIVE |
-			    APPNIC_DMA_INTERRUPT_ENABLE_TRANSMIT),
-			   APPNIC_DMA_INTERRUPT_ENABLE);
-	}
-
-	DEBUG_PRINT("head=0x%x tail=0x%x tail_copy=0x%x\n",
-		    adapter->rx_head.raw, adapter->rx_tail->raw,
-		    adapter->rx_tail_copy.raw);
-	TRACE_ENDING();
-
-#ifdef __APPNIC_C_PROFILE__
-	end_ = (0xffffffff - readl((TIMER7_BASE + TIMER_n_VALUE)));
-	app3xx_profile_time_calc(beginning_, end_,
-				 time_in_rx_min_, time_in_rx_max_,
-				 total_rx_time_);
-
-	total_rx_packets_handled_ += packets_handled_;
-	if (packets_handled_ > max_rx_packets_handled_)
-		max_rx_packets_handled_ = packets_handled_;
-
-	++total_polls_;
-#endif				/* __APPNIC_C_PROFILE__ */
-
-	/* TEMP */
-	/*up( & adapter->poll_sem); */
-	LSINET_COUNTS_INC(LSINET_COUNTS_POL_DONE);
-	return done ? 0 : 1;
-
-}
-
-#else				/* Not using NAPI, define the Rx interrupt handler instead */
-
-/*
-  ----------------------------------------------------------------------
-  handle_receive_interrupt_
-*/
-
-static void
-handle_receive_interrupt_(struct net_device *device)
-{
-
-	appnic_device_t *dev_ = netdev_priv(device);
-	appnic_queue_pointer_t queue_;
-
-#ifdef __APPNIC_C_PROFILE__
-	unsigned long beginning_;
-	unsigned long end_;
-	unsigned long packets_handled_ = 0;
-
-	beginning_ = (0xffffffff - readl((TIMER7_BASE + TIMER_n_VALUE)));
-#endif				/* __APPNIC_C_PROFILE__ */
-
-	LSINET_COUNTS_INC(LSINET_COUNTS_RX_START);
-	TRACE_BEGINNING();
-	DEBUG_PRINT("head=0x%lx tail=0x%lx tail_copy=0x%lx\n",
-		    dev_->rx_head.raw, dev_->rx_tail->raw,
-		    dev_->rx_tail_copy.raw);
-	queue_.raw = dev_->rx_tail_copy.raw;
-	lsinet_rx_packets(device, -1);
-	DEBUG_PRINT("head=0x%lx tail=0x%lx tail_copy=0x%lx\n",
-		    dev_->rx_head.raw, dev_->rx_tail->raw,
-		    dev_->rx_tail_copy.raw);
-	TRACE_ENDING();
-	LSINET_COUNTS_INC(LSINET_COUNTS_RX_DONE);
-#ifdef __APPNIC_C_PROFILE__
-	end_ = (0xffffffff - readl((TIMER7_BASE + TIMER_n_VALUE)));
-	app3xx_profile_time_calc(beginning_, end_,
-				 time_in_rx_min_, time_in_rx_max_,
-				 total_rx_time_);
-
-	total_rx_packets_handled_ += packets_handled_;
-	if (packets_handled_ > max_rx_packets_handled_)
-		max_rx_packets_handled_ = packets_handled_;
-	++total_rx_interrupts_;
-#endif				/* __APPNIC_C_PROFILE__ */
-
-	return;
-
-}
-#endif				/* else not NAPI */
-
-/*
-  ----------------------------------------------------------------------
-  appnic_isr_
-*/
-
-static irqreturn_t
-appnic_isr_(int irq, void *device_id)
-{
-
-	struct net_device *device_ = (struct net_device *) device_id;
-	appnic_device_t *dev_ = netdev_priv(device_);
-	unsigned long dma_interrupt_status_;
-	unsigned long flags;
-
-#ifdef __APPNIC_C_PROFILE__
-	unsigned beginning_jiffies_ = jiffies;
-#endif				/* __APPNIC_C_PROFILE__ */
-
-	TRACE_BEGINNING();
-	LSINET_COUNTS_INC(LSINET_COUNTS_ISR_START);
-
-	/* acquire the lock */
-	spin_lock_irqsave(&dev_->lock, flags);
-
-#if !defined(PHYLESS) && !defined(CONFIG_ACP)
-	if (INT_MAC_RX == irq) {
-
-		PHY_DEBUG_PRINT("Handling PHY interrupt.\n");
-
-		if (BCM5221_PHY_ == phy_type_) {
-
-			bc_phy_interrupt_t bc_phy_interrupt_;
-
-			(void) phy_read_(phy_address_,
-					 BC_PHY_INTERRUPT_,
-					 &bc_phy_interrupt_.raw);
-			bc_phy_interrupt_.raw = 0;
-			bc_phy_interrupt_.bits.enable = 1;
-			(void) phy_write_(phy_address_,
-					  BC_PHY_INTERRUPT_,
-					  bc_phy_interrupt_.raw);
-
-		} else if (MICREL_PHY_ == phy_type_) {
-
-			m_phy_interrupt_t m_phy_interrupt_;
-
-			(void) phy_read_(phy_address_,
-					 M_PHY_INTERRUPT_,
-					 &m_phy_interrupt_.raw);
-			(void) phy_write_(phy_address_, M_PHY_INTERRUPT_,
-					  m_phy_interrupt_.raw);
-
-		}
-
-		write_mac_(0, APPNIC_RX_INTERRUPT_STATUS);
-		enable_(device_);
-
-	} else {
-#endif				/* PHYLESS */
-		/* get the status */
-		dma_interrupt_status_ = read_mac_(APPNIC_DMA_INTERRUPT_STATUS);
-#ifdef LSINET_NAPI
-		/* NAPI - don't ack RX interrupt */
-		write_mac_(APPNIC_DMA_INTERRUPT_ENABLE_RECEIVE,
-			   APPNIC_DMA_INTERRUPT_STATUS);
-#else
-		write_mac_(0, APPNIC_DMA_INTERRUPT_STATUS);
-#endif
-
-		/*TRACER_POST( "dma_interrupt_status_=0x%x", dma_interrupt_status_ ); */
-
-		/* handle interrupts */
-
-		if (TX_INTERRUPT(dma_interrupt_status_)) {
-			LSINET_COUNTS_INC(LSINET_COUNTS_ISR_TX);
-			/* transmition complete */
-			++transmit_interrupts_;
-			handle_transmit_interrupt_(device_);
-		}
-
-		if (RX_INTERRUPT(dma_interrupt_status_)) {
-			LSINET_COUNTS_INC(LSINET_COUNTS_ISR_RX);
-#ifdef LSINET_NAPI
-			++receive_interrupts_;
-			if (napi_schedule_prep(&dev_->napi)) {
-				/* disable RX interrupts and tell the system we've got work */
-				write_mac_(APPNIC_DMA_INTERRUPT_ENABLE_TRANSMIT,
-					   APPNIC_DMA_INTERRUPT_ENABLE);
-				__napi_schedule(&dev_->napi);
-			} else {
-				write_mac_(APPNIC_DMA_INTERRUPT_ENABLE_TRANSMIT,
-					   APPNIC_DMA_INTERRUPT_ENABLE);
-			}
-#else
-			/* receive complete */
-			handle_receive_interrupt_(device_);
-#endif
-		}
-#if !defined(PHYLESS) && !defined(CONFIG_ACP)
-	}
-#endif				/* PHYLESS */
-
-	/* release the lock */
-	spin_unlock_irqrestore(&dev_->lock, flags);
-
-	LSINET_COUNTS_INC(LSINET_COUNTS_ISR_DONE);
-	TRACE_ENDING();
-
-#ifdef __APPNIC_C_PROFILE__
-	if (jiffies != beginning_jiffies_)
-		++jiffies_changed_;
-#endif				/* __APPNIC_C_PROFILE__ */
-
-	return IRQ_HANDLED;
-
-}
-
-#ifdef CONFIG_NET_POLL_CONTROLLER
-/*
- * Polling receive - used by netconsole and other diagnostic tools
- * to allow network i/o with interrupts disabled.
- */
-static void
-appnic_poll_controller(struct net_device *dev)
-{
-	disable_irq(dev->irq);
-	appnic_isr_(dev->irq, dev);
-	enable_irq(dev->irq);
-}
-
-#endif
-/*
-  ----------------------------------------------------------------------
-  appnic_open
-
-  Opens the interface.  The interface is opened whenever ifconfig
-  activates it.  The open method should register any system resource
-  it needs (I/O ports, IRQ, DMA, etc.) turn on the hardware, and
-  increment the module usage count.
-*/
-
-int
-appnic_open(struct net_device *device)
-{
-
-	int return_code_ = 0;
-#if defined(CONFIG_ARCH_APP3)
-	unsigned long gpio_mux_ = readl(APP3XX_HB_CONF_BASE + 0x18);
-#elif defined(CONFIG_ARCH_APP3K)
-	/*unsigned long gpio_mux_ = readl( APP_AEI_BASE + 0x18 ); */
-#endif
-
-	/* enable the receiver and transmitter */
-	if (0 != enable_(device)) {
-
-		ERROR_PRINT("Unable to enable the interface.\n");
-		disable_();
-		return -EBUSY;
-
-	}
-#ifdef LSINET_NAPI
-	{
-		appnic_device_t *adapter = netdev_priv(device);
-		napi_enable(&adapter->napi);
-	}
-#endif				/* LSINET_NAPI */
-
-	/* install the interrupt handlers */
-	return_code_ =
-	     request_irq(device->irq, appnic_isr_, IRQF_DISABLED, APPNIC_NAME,
-		 device);
-	if (0 != return_code_) {
-
-		ERROR_PRINT("request_irq( ) failed, returned 0x%x/%d\n",
-			    return_code_, return_code_);
-		return return_code_;
-
-	}
-
-	/* enable interrupts */
-	write_mac_((APPNIC_DMA_INTERRUPT_ENABLE_RECEIVE |
-		    APPNIC_DMA_INTERRUPT_ENABLE_TRANSMIT),
-		   APPNIC_DMA_INTERRUPT_ENABLE);
-
-	{
-
-#ifndef PHYLESS
-#ifndef CONFIG_ACP
-		char phy_string_[256];
-		int use_interrupts_ = 1;
-#endif
-		appnic_device_t *dev_ = netdev_priv(device);
-#endif
-
-#ifdef CONFIG_ARCH_APP3
-
-		PHY_DEBUG_PRINT("phy_type_=0x%x gpio_mux_=0x%x\n", phy_type_,
-				gpio_mux_);
-
-		if ((BCM5221_PHY_ != phy_type_) ||
-		    (0x04000000 != (gpio_mux_ & 0x04000000))) {
-
-			use_interrupts_ = 0;
-
-		}
-#endif
-
-#ifndef PHYLESS
-
-#ifndef CONFIG_ACP
-#ifdef CONFIG_LSI_UBOOTENV
-		if ((0 != ubootenv_get("phy_mode", phy_string_)) ||
-		    (0 == strncmp(phy_string_, "poll", strlen("poll")))) {
-
-			use_interrupts_ = 0;
-
-		}
-#else
-		use_interrupts_ = 0;
-#endif
-
-		PHY_DEBUG_PRINT("use_interrupts_=%d\n", use_interrupts_);
-
-		if (1 == use_interrupts_) {
-
-			if (BCM5221_PHY_ == phy_type_) {
-
-				bc_phy_interrupt_t bc_phy_interrupt_;
-
-				bc_phy_interrupt_.raw = 0;
-				bc_phy_interrupt_.bits.enable = 1;
-
-				if (0 !=
-				    phy_write_(phy_address_, BC_PHY_INTERRUPT_,
-					       bc_phy_interrupt_.raw)) {
-
-					return -EBUSY;
-
-				}
-
-				if (0 !=
-				    phy_read_(phy_address_, BC_PHY_INTERRUPT_,
-					      &bc_phy_interrupt_.raw)) {
-
-					return -EBUSY;
-
-				}
-
-			} else if (MICREL_PHY_ == phy_type_) {
-
-				m_phy_interrupt_t m_phy_interrupt_;
-
-				m_phy_interrupt_.raw = 0;
-				m_phy_interrupt_.bits.enable_link_up = 1;
-
-				if (0 !=
-				    phy_write_(phy_address_, M_PHY_INTERRUPT_,
-					       m_phy_interrupt_.raw)) {
-
-					return -EBUSY;
-
-				}
-
-			}
-
-			return_code_ =
-				  request_irq(INT_MAC_RX, appnic_isr_, 0,
-					      APPNIC_NAME "(phy)", device);
-			if (0 != return_code_) {
-
-				ERROR_PRINT
-				    ("request_irq( ) failed, returned 0x%x/%d\n",
-				     return_code_, return_code_);
-				return return_code_;
-
-			}
-
-			write_mac_((APPNIC_RX_EXTERNAL_INTERRUPT_CONTROL_MAC_0),
-				   APPNIC_RX_EXTERNAL_INTERRUPT_CONTROL);
-			dev_->polling = 0;
-
-		} else {
-
-#endif
-
-#ifndef CONFIG_ACP
-			WARN_PRINT("PHY is in polling mode.\n");
-#endif
-			init_timer(&appnic_timer_);
-			appnic_timer_.expires =
-			    jiffies + (APPNIC_TIMER_PERIOD * HZ);
-			appnic_timer_.data = (unsigned long) device;
-			appnic_timer_.function = appnic_timer_handler_;
-			add_timer(&appnic_timer_);
-			dev_->polling = 1;
-
-#ifndef CONFIG_ACP
-
-		}
-
-#endif
-
-#endif				/* PHYLESS */
-
-	}
-
-	/* let the OS know we are ready to send packets */
-	netif_start_queue(device);
-
-	/* that's all */
-	return 0;
-
-}
-
-/*
-  ----------------------------------------------------------------------
-  appnic_stop
-
-  Stops the interface.  The interface is stopped when it is broughht
-  down; operations performed at open time should be reversed.
-*/
-
-int
-appnic_stop(struct net_device *device)
-{
-
-	int return_code_ = 0;
-
-	DEBUG_PRINT("Stopping the interface.\n");
-
-	/*
-	   Indicate to the OS that no more packets should be sent.
-	 */
-
-	netif_stop_queue(device);
-
-	/*
-	   Stop the receiver and transmitter.
-	 */
-
-	disable_();
-
-	/* Disable NAPI. */
-#ifdef LSINET_NAPI
-	{
-		appnic_device_t *adapter = netdev_priv(device);
-		napi_disable(&adapter->napi);
-	}
-#endif
-
-	/*
-	   Free the interrupts.
-	 */
-
-	free_irq(device->irq, device);
-
-#ifndef PHYLESS
-
-	{
-#ifndef CONFIG_ACP
-		appnic_device_t *dev_ = netdev_priv(device);
-		if (0 != dev_->polling)
-			del_timer(&appnic_timer_);
-		else
-			free_irq(INT_MAC_RX, device);
-
-#else
-		del_timer(&appnic_timer_);
-#endif
-	}
-
-#endif				/* PHYLESS */
-
-	/*
-	   That's all.
-	 */
-
-	return return_code_;
-
-}
-
-/*
-  ----------------------------------------------------------------------
-  appnic_hard_start_xmit
-
-  The method initiates the transmission of a packet.  The full packet
-  (protocol headers and all) is contained in a socket buffer (sk_buff)
-  structure.
-
-  ----- NOTES -----
-
-  1) This will not get called again by the kernel until it returns.
-*/
-
-int
-appnic_hard_start_xmit(struct sk_buff *skb, struct net_device *device)
-{
-	appnic_device_t *adapter = netdev_priv(device);
-	int length_;
-	int buf_per_desc_;
-	unsigned long flags;
-
-#ifdef __APPNIC_C_PROFILE__
-	unsigned long beginning_;
-	unsigned long end_;
-	unsigned long this_time_;
-
-	beginning_ = (0xffffffff - readl((TIMER7_BASE + TIMER_n_VALUE)));
-	++total_tx_packets_;
-#endif				/* __APPNIC_C_PROFILE__ */
-
-	LSINET_COUNTS_INC(LSINET_COUNTS_HST_START);
-	appnic_special_lock(&adapter->lock, flags);
-	length_ = skb->len < ETH_ZLEN ? ETH_ZLEN : skb->len;
-	buf_per_desc_ = adapter->tx_buf_sz / adapter->tx_num_desc;
-
-	/*
-	   If enough transmit descriptors are available, copy and transmit.
-	 */
-
-	DEBUG_PRINT("length_=%d buf_per_desc_=%d tx_tail=0x%x\n",
-		    length_, buf_per_desc_, swab32(adapter->tx_tail->raw));
-
-	while (((length_ / buf_per_desc_) + 1) >=
-	       queue_uninitialized_(adapter->tx_head,
-				    SWAB_QUEUE_POINTER(adapter->tx_tail),
-				    adapter->tx_num_desc)) {
-		udelay(1000);
-		LSINET_COUNTS_INC(LSINET_COUNTS_HST_RCLM);
-		handle_transmit_interrupt_(device);
-	}
-
-	if (((length_ / buf_per_desc_) + 1) <
-	    queue_uninitialized_(adapter->tx_head,
-				 SWAB_QUEUE_POINTER(adapter->tx_tail),
-				 adapter->tx_num_desc)) {
-		int bytes_copied_ = 0;
-		appnic_dma_descriptor_t descriptor;
-
-		LSINET_COUNTS_INC(LSINET_COUNTS_HST_SNDG);
-		readdescriptor(((unsigned long) adapter->tx_desc +
-				adapter->tx_head.bits.offset), &descriptor);
-		descriptor.start_of_packet = 1;
-
-		while (bytes_copied_ < length_) {
-			descriptor.write = 1;
-			descriptor.pdu_length = length_;
-
-			if ((length_ - bytes_copied_) > buf_per_desc_) {
-				memcpy((void *) (descriptor.
-						 host_data_memory_pointer +
-						 adapter->dma_alloc_offset),
-				       (void *) ((unsigned long) skb->data +
-						 bytes_copied_), buf_per_desc_);
-				descriptor.data_transfer_length = buf_per_desc_;
-				descriptor.end_of_packet = 0;
-				descriptor.interrupt_on_completion = 0;
-				bytes_copied_ += buf_per_desc_;
-			} else {
-				memcpy((void *) (descriptor.
-						 host_data_memory_pointer +
-						 adapter->dma_alloc_offset),
-				       (void *) ((unsigned long) skb->data +
-						 bytes_copied_),
-				       (length_ - bytes_copied_));
-				descriptor.data_transfer_length =
-				    (length_ - bytes_copied_);
-				descriptor.end_of_packet = 1;
-#ifdef DISABLE_TX_INTERRUPTS
-				descriptor.interrupt_on_completion = 0;
-#else				/* DISABLE_TX_INTERRUPTS */
-				descriptor.interrupt_on_completion = 1;
-#endif				/* DISABLE_TX_INTERRUPTS */
-				bytes_copied_ = length_;
-			}
-
-			adapter->stats.tx_bytes += bytes_copied_;
-			writedescriptor(((unsigned long) adapter->tx_desc +
-					 adapter->tx_head.bits.offset),
-					&descriptor);
-			queue_increment_(&adapter->tx_head,
-					 adapter->tx_num_desc);
-			readdescriptor(((unsigned long) adapter->tx_desc +
-					adapter->tx_head.bits.offset),
-				       &descriptor);
-			descriptor.start_of_packet = 0;
-		}
-
-		write_mac_(adapter->tx_head.raw, APPNIC_DMA_TX_HEAD_POINTER);
-		device->trans_start = jiffies;
-		LSINET_COUNTS_INC(LSINET_COUNTS_HST_SNT);
-	} else {
-		++out_of_tx_descriptors_;
-		LSINET_COUNTS_INC(LSINET_COUNTS_HST_OOD);
-		ERROR_PRINT("No transmit descriptors available!\n");
-	}
-
-	appnic_special_unlock(&adapter->lock, flags);
-	/* free the socket buffer */
-	dev_kfree_skb(skb);
-
-#ifdef __APPNIC_C_PROFILE__
-	end_ = (0xffffffff - readl((TIMER7_BASE + TIMER_n_VALUE)));
-	if (end_ > beginning_)
-		this_time_ = end_ - beginning_;
-	else
-		this_time_ = end_ + (0xffffffff - beginning_) + 1;
-
-	total_tx_time_ += this_time_;
-	if (this_time_ > time_in_tx_max_)
-		time_in_tx_max_ = this_time_;
-
-	if (this_time_ < time_in_tx_min_)
-		time_in_tx_min_ = this_time_;
-
-#endif				/* __APPNIC_C_PROFILE__ */
-
-	LSINET_COUNTS_INC(LSINET_COUNTS_HST_DONE);
-	return 0;
-
-}
-
-/*
-  ----------------------------------------------------------------------
-  appnic_tx_timeout
-
-  This method is called when a packet transmission fails to complete
-  within a resonable period, on the assumption that an interrupt has
-  been missed or the interface has locked up.  It should handle the
-  problem and resume packet transmission.
-*/
-
-void
-appnic_tx_timeout(struct net_device *device)
-{
-
-	appnic_device_t *adapter = netdev_priv(device);
-
-	WARN_PRINT("Transmission timed out!\n");
-
-	if (0 == queue_initialized_(SWAB_QUEUE_POINTER(adapter->tx_tail),
-				    adapter->tx_tail_copy,
-				    adapter->tx_num_desc)) {
-		/*
-		   If tx_tail is still the same as tx_tail_copy
-		   then restart the transmission.
-		 */
-
-		write_mac_(adapter->tx_head.raw, APPNIC_DMA_TX_HEAD_POINTER);
-	} else {
-		/* If tx_tail has moved on, just increment tx_tail_copy. */
-		appnic_dma_descriptor_t descriptor;
-
-		readdescriptor(((unsigned long) adapter->tx_desc +
-				adapter->tx_tail_copy.bits.offset),
-			       &descriptor);
-		adapter->stats.tx_bytes += descriptor.pdu_length;
-		kfree((void *) descriptor.host_data_memory_pointer);
-		queue_increment_(&adapter->tx_tail_copy, adapter->tx_num_desc);
-	}
-
-	return;
-
-}
-
-/*
-  ----------------------------------------------------------------------
-  appnic_net_device_stats
-
-  Whenever an application needs to get statistics for the interface,
-  this method is called.  This happens, for example, when ifconfig or
-  nstat -i is run.
-*/
-
-struct net_device_stats *
-appnic_get_stats(struct net_device *device)
-{
-
-	appnic_device_t *device_ = netdev_priv(device);
-
-	/*
-	   Update the statistics structure.
-	 */
-
-	get_hw_statistics_(device_);
-
-	/*
-	   That's all.
-	 */
-
-	return &device_->stats;
-
-}
-
-/*
-  ----------------------------------------------------------------------
-  appnic_set_mac_address
-*/
-
-static int
-appnic_set_mac_address(struct net_device *device, void *data)
-{
-	struct sockaddr *address_ = data;
-	unsigned long swap_source_address_;
-
-	if (netif_running(device))
-		return -EBUSY;
-
-	DEBUG_PRINT("Setting MAC to %02x:%02x:%02x:%02x:%02x:%02x\n",
-		    address_->sa_data[0], address_->sa_data[1],
-		    address_->sa_data[2], address_->sa_data[3],
-		    address_->sa_data[4], address_->sa_data[5]);
-	memcpy(device->dev_addr, address_->sa_data, 6);
-	memcpy(device->perm_addr, address_->sa_data, 6);
-
-	swap_source_address_ =
-	    ((address_->sa_data[4]) << 8) | address_->sa_data[5];
-	write_mac_(swap_source_address_, APPNIC_SWAP_SOURCE_ADDRESS_2);
-	swap_source_address_ =
-	    ((address_->sa_data[2]) << 8) | address_->sa_data[3];
-	write_mac_(swap_source_address_, APPNIC_SWAP_SOURCE_ADDRESS_1);
-	swap_source_address_ =
-	    ((address_->sa_data[0]) << 8) | address_->sa_data[1];
-	write_mac_(swap_source_address_, APPNIC_SWAP_SOURCE_ADDRESS_0);
-	memcpy(device->dev_addr, address_->sa_data, device->addr_len);
-
-	return 0;
-}
-
-/*
-  ======================================================================
-  ======================================================================
-  ======================================================================
-
-  ETHTOOL Operations
-
-  ======================================================================
-  ======================================================================
-  ======================================================================
-*/
-
-/*
-  ----------------------------------------------------------------------
-  appnic_get_settings
-*/
-
-static int
-appnic_get_settings(struct net_device *device, struct ethtool_cmd *command)
-{
-	unsigned long flags;
-	appnic_device_t *appnic_device_ = netdev_priv(device);
-
-	memset(command, 0, sizeof(struct ethtool_cmd));
-
-	/* What the hardware supports. */
-	command->supported =
-	    (SUPPORTED_10baseT_Half |
-	     SUPPORTED_10baseT_Full |
-	     SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full);
-
-	/* Acquire the device lock. */
-	appnic_special_lock(&appnic_device_->lock, flags);
-
-#ifndef PHYLESS
-
-	/* What is currently advertised. */
-
-	{
-
-		unsigned short ad_value_;
-
-		if (0 !=
-		    phy_read_(phy_address_, PHY_AUTONEG_ADVERTISE,
-			      &ad_value_)) {
-
-			ERROR_PRINT("PHY read failed!");
-			appnic_special_unlock(&appnic_device_->lock, flags);
-			return -EIO;
-
-		}
-
-		switch (ad_value_) {
-
-		case 0x1e1:
-			command->advertising =
-			    (ADVERTISED_100baseT_Full | ADVERTISED_100baseT_Half
-			     | ADVERTISED_10baseT_Full |
-			     ADVERTISED_10baseT_Half);
-			break;
-
-		case 0xe1:
-			command->advertising =
-			    (ADVERTISED_100baseT_Half |
-			     ADVERTISED_10baseT_Full | ADVERTISED_10baseT_Half);
-			break;
-
-		case 0x61:
-			command->advertising =
-			    (ADVERTISED_10baseT_Full | ADVERTISED_10baseT_Half);
-			break;
-
-		case 0x41:
-			command->advertising = (ADVERTISED_10baseT_Half);
-			break;
-
-		default:
-			break;
-
-		}
-
-	}
-
-	/* The current speed. */
-
-	{
-
-		int speed_;
-
-		speed_ = phy_speed_(phy_address_);
-		if (-1 == speed_) {
-
-			ERROR_PRINT("PHY read failed!");
-			appnic_special_unlock(&appnic_device_->lock, flags);
-			return -EIO;
-
-		}
-
-		if (1 == speed_)
-			command->speed = SPEED_100;
-		else
-			command->speed = SPEED_10;
-
-	}
-
-	/* Is the current link duplex? */
-
-	{
-
-		int duplex_;
-
-		duplex_ = phy_duplex_(phy_address_);
-		if (-1 == duplex_) {
-
-			ERROR_PRINT("PHY read failed!");
-			appnic_special_unlock(&appnic_device_->lock, flags);
-			return -EIO;
-
-		}
-
-		if (1 == duplex_)
-			command->duplex = DUPLEX_FULL;
-		else
-			command->duplex = DUPLEX_HALF;
-
-	}
-
-#endif				/* PHYLESS */
-
-	/* Is autoneg enabled? */
-	command->autoneg = AUTONEG_ENABLE;
-
-	/* Unlock and return success. */
-	appnic_special_unlock(&appnic_device_->lock, flags);
-
-	return 0;
-
-}
-
-/*
-  Fill in the struture...
-*/
-
-static const struct ethtool_ops appnic_ethtool_ops = {
-	.get_settings = appnic_get_settings
-};
-
-/*
-  ======================================================================
-  ======================================================================
-  ======================================================================
-
-  Linux Module Interface.
-
-  ======================================================================
-  ======================================================================
-  ======================================================================
-*/
-
-static const struct net_device_ops appnic_netdev_ops = {
-	.ndo_open = appnic_open,
-	.ndo_stop = appnic_stop,
-	.ndo_get_stats = appnic_get_stats,
-	.ndo_set_mac_address = appnic_set_mac_address,
-	.ndo_start_xmit = appnic_hard_start_xmit,
-#ifdef CONFIG_NET_POLL_CONTROLLER
-	.ndo_poll_controller = appnic_poll_controller,
-#endif
-};
-
-/*
-  ----------------------------------------------------------------------
-  appnic_init
-*/
-
-int
-appnic_init(struct net_device *device)
-{
-
-	appnic_device_t *adapter = netdev_priv(device);
-
-	TRACE_BEGINNING();
-
-	/*
-	   Reset the MAC
-	 */
-
-	write_mac_(0x80000000, APPNIC_DMA_PCI_CONTROL);
-
-	/*
-	   -- WORKAROUND -- WORKAROUND -- WORKAROUND -- WORKAROUND -- WORKAROUND --
-	   This is the software work around for defect 15129.  Use 64 byte
-	   buffers for receive descriptors for all dma.
-	   -- WORKAROUND -- WORKAROUND -- WORKAROUND -- WORKAROUND -- WORKAROUND --
-	 */
-#ifndef CONFIG_ACP
-	if (1 >= (APP3XX_REVISION_REGISTER & 0x1f)) {
-
-		printk("++ Using work around for defect 15129\n");
-		rx_num_desc = (8 * DESCRIPTOR_GRANULARITY);
-		rx_buf_sz = 32768;
-
-	}
-#endif
-
-	/*
-	   Allocate memory and initialize the descriptors
-	 */
-
-	{
-
-		void *dma_offset_;
-
-		/*
-		   fixup num_[rt]x_desc
-		 */
-
-		if (0 != (rx_num_desc % DESCRIPTOR_GRANULARITY)) {
-
-			WARN_PRINT("rx_num_desc was not a multiple of %d.\n",
-				   DESCRIPTOR_GRANULARITY);
-			rx_num_desc +=
-			    DESCRIPTOR_GRANULARITY -
-			    (rx_num_desc % DESCRIPTOR_GRANULARITY);
-
-		}
-
-		adapter->rx_num_desc = rx_num_desc;
-
-		if (0 != (tx_num_desc % DESCRIPTOR_GRANULARITY)) {
-
-			WARN_PRINT("tx_num_desc was not a multiple of %d.\n",
-				   DESCRIPTOR_GRANULARITY);
-			tx_num_desc +=
-			    DESCRIPTOR_GRANULARITY -
-			    (tx_num_desc % DESCRIPTOR_GRANULARITY);
-
-		}
-
-		adapter->tx_num_desc = tx_num_desc;
-
-		DEBUG_PRINT("rx_num_desc=%d tx_num_desc=%d\n", rx_num_desc,
-			    tx_num_desc);
-
-		/*
-		   Fix up [rt]x_buf_sz.  Must be some multiple of 64 bytes per descriptor.
-		 */
-
-		if (0 != (rx_buf_sz % (BUFFER_ALIGNMENT * rx_num_desc))) {
-
-			WARN_PRINT("rx_buf_sz was not a multiple of %d.\n",
-				   (BUFFER_ALIGNMENT * rx_num_desc));
-			rx_buf_sz +=
-			    (BUFFER_ALIGNMENT * rx_num_desc) -
-			    (rx_buf_sz % (BUFFER_ALIGNMENT * rx_num_desc));
-
-		}
-
-		adapter->rx_buf_sz = rx_buf_sz;
-
-		if (0 != (tx_buf_sz % (BUFFER_ALIGNMENT * tx_num_desc))) {
-
-			WARN_PRINT("tx_buf_sz was not a multiple of %d.\n",
-				   (BUFFER_ALIGNMENT * tx_num_desc));
-			tx_buf_sz +=
-			    (BUFFER_ALIGNMENT * tx_num_desc) -
-			    (tx_buf_sz % (BUFFER_ALIGNMENT * tx_num_desc));
-
-		}
-
-		adapter->tx_buf_sz = tx_buf_sz;
-
-		DEBUG_PRINT("rx_buf_sz=%d tx_buf_sz=%d\n",
-			    rx_buf_sz, tx_buf_sz);
-
-		/*
-		   Allocate dma-able memory
-		 */
-
-		adapter->dma_alloc_size =
-		    /* The tail pointers (rx and tx) */
-		    (sizeof(appnic_queue_pointer_t) * 2) +
-		    /* The RX descriptor ring (and padding to allow
-		       64 byte alignment) */
-		    (sizeof(appnic_dma_descriptor_t) *
-		     adapter->rx_num_desc) + (DESCRIPTOR_GRANULARITY) +
-		    /* The TX descriptor ring (and padding...) */
-		    (sizeof(appnic_dma_descriptor_t) *
-		     adapter->tx_num_desc) + (DESCRIPTOR_GRANULARITY) +
-		    /* The RX buffer (and padding...) */
-		    (adapter->rx_buf_sz) + (BUFFER_ALIGNMENT) +
-		    /* The TX buffer (and padding...) */
-		    (adapter->tx_buf_sz) + (BUFFER_ALIGNMENT);
-
-#ifdef DMA_CACHABLE
-		adapter->dma_alloc = (void *)
-				   kmalloc(adapter->dma_alloc_size,
-					   GFP_KERNEL);
-		if ((void *) 0 == adapter->dma_alloc) {
-
-			ERROR_PRINT("Could not allocate %d bytes of "
-				    "DMA-able memory!\n",
-				    adapter->dma_alloc_size);
-			kfree(adapter);
-			TRACE_ENDING();
-			return -ENOMEM;
-
-		}
-
-		adapter->dma_alloc_dma = virt_to_phys(adapter->dma_alloc);
-
-#else
-
-		/* This needs to be set to something sane for dma_alloc_coherent() */
-		device->dev.archdata.dma_ops = &dma_direct_ops;
-
-		adapter->dma_alloc = (void *)
-				   dma_alloc_coherent(&device->dev,
-						      adapter->dma_alloc_size,
-						      &adapter->dma_alloc_dma,
-						      GFP_KERNEL);
-		if ((void *) 0 == adapter->dma_alloc) {
-
-			ERROR_PRINT("Could not allocate %d bytes of "
-				    "DMA-able memory!\n",
-				    adapter->dma_alloc_size);
-			kfree(adapter);
-			TRACE_ENDING();
-			return -ENOMEM;
-
-		}
-#endif
-
-		adapter->dma_alloc_offset =
-		    (int) adapter->dma_alloc - (int) adapter->dma_alloc_dma;
-		dma_offset_ = adapter->dma_alloc;
-		DEBUG_PRINT("Allocated %d bytes at 0x%08lx(0x%08lx), "
-			    "offset=0x%x.\n",
-			    adapter->dma_alloc_size,
-			    (unsigned long) adapter->dma_alloc,
-			    (unsigned long) adapter->dma_alloc_dma,
-			    adapter->dma_alloc_offset);
-		printk("Allocated %d bytes at 0x%08lx(0x%08lx), "
-		       "offset=0x%x.\n",
-		       adapter->dma_alloc_size,
-		       (unsigned long) adapter->dma_alloc,
-		       (unsigned long) adapter->dma_alloc_dma,
-		       adapter->dma_alloc_offset);
-
-		/*
-		   Initialize the tail pointers
-		 */
-
-		adapter->rx_tail = (appnic_queue_pointer_t *) dma_offset_;
-		adapter->rx_tail_dma =
-		    (int) adapter->rx_tail - (int) adapter->dma_alloc_offset;
-		dma_offset_ += sizeof(appnic_queue_pointer_t);
-		memset((void *) adapter->rx_tail, 0,
-		       sizeof(appnic_queue_pointer_t));
-		DEBUG_PRINT("rx_tail=0x%08lx\n",
-			    (unsigned long) adapter->rx_tail);
-
-		adapter->tx_tail = (appnic_queue_pointer_t *) dma_offset_;
-		adapter->tx_tail_dma =
-		    (int) adapter->tx_tail - (int) adapter->dma_alloc_offset;
-		dma_offset_ += sizeof(appnic_queue_pointer_t);
-		memset((void *) adapter->tx_tail, 0,
-		       sizeof(appnic_queue_pointer_t));
-		DEBUG_PRINT("tx_tail=0x%08lx\n",
-			    (unsigned long) adapter->tx_tail);
-
-		/*
-		   Initialize the descriptor pointers
-		 */
-
-		DEBUG_PRINT("rx_tail=0x%08lx\n",
-			    (unsigned long) adapter->rx_tail);
-		adapter->rx_desc = (appnic_dma_descriptor_t *)
-		    ALIGN64B(dma_offset_);
-		DEBUG_PRINT("rx_desc=0x%08lx\n",
-			    (unsigned long) adapter->rx_desc);
-		adapter->rx_desc_dma =
-		    (int) adapter->rx_desc - (int) adapter->dma_alloc_offset;
-		dma_offset_ += (sizeof(appnic_dma_descriptor_t) *
-				adapter->rx_num_desc) +
-		    (DESCRIPTOR_GRANULARITY);
-		memset((void *) adapter->rx_desc, 0,
-		       (sizeof(appnic_dma_descriptor_t) *
-			adapter->rx_num_desc));
-
-		DEBUG_PRINT("rx_tail=0x%08lx\n",
-			    (unsigned long) adapter->rx_tail);
-		adapter->tx_desc = (appnic_dma_descriptor_t *)
-		    ALIGN64B(dma_offset_);
-		DEBUG_PRINT("tx_desc=0x%08lx\n",
-			    (unsigned long) adapter->tx_desc);
-		adapter->tx_desc_dma =
-		    (int) adapter->tx_desc - (int) adapter->dma_alloc_offset;
-		dma_offset_ += (sizeof(appnic_dma_descriptor_t) *
-				adapter->tx_num_desc) +
-		    (DESCRIPTOR_GRANULARITY);
-		memset((void *) adapter->tx_desc, 0,
-		       (sizeof(appnic_dma_descriptor_t) *
-			adapter->tx_num_desc));
-
-		/*
-		   Initialize the buffer pointers
-		 */
-
-		DEBUG_PRINT("rx_tail=0x%08lx\n",
-			    (unsigned long) adapter->rx_tail);
-		DEBUG_PRINT
-		    ("Initializing the RX buffer pointers, dma_offset=0x%lx/0x%lx\n",
-		     (unsigned long) dma_offset_,
-		     (unsigned long) ALIGN64B(dma_offset_));
-		adapter->rx_buf = (void *) ALIGN64B(dma_offset_);
-		adapter->rx_buf_dma =
-		    (int) adapter->rx_buf - (int) adapter->dma_alloc_offset;
-		adapter->rx_buf_per_desc =
-		    adapter->rx_buf_sz / adapter->rx_num_desc;
-
-		dma_offset_ += (adapter->rx_buf_sz) + (BUFFER_ALIGNMENT);
-
-		DEBUG_PRINT("rx_tail=0x%08lx\n",
-			    (unsigned long) adapter->rx_tail);
-		DEBUG_PRINT
-		    ("Initializing the TX buffer pointers, dma_offset=0x%lx/0x%lx\n",
-		     (unsigned long) dma_offset_,
-		     (unsigned long) ALIGN64B(dma_offset_));
-		adapter->tx_buf = (void *) ALIGN64B(dma_offset_);
-		adapter->tx_buf_dma =
-		    (int) adapter->tx_buf - (int) adapter->dma_alloc_offset;
-		adapter->tx_buf_per_desc =
-		    adapter->tx_buf_sz / adapter->tx_num_desc;
-		dma_offset_ += (adapter->tx_buf_sz) + (BUFFER_ALIGNMENT);
-
-		/*
-		   Initialize the descriptors
-		 */
-
-		DEBUG_PRINT("rx_tail=0x%08lx\n",
-			    (unsigned long) adapter->rx_tail);
-		{
-
-			int index_;
-			unsigned long buf_ =
-			    (unsigned long) adapter->rx_buf_dma;
-			appnic_dma_descriptor_t descriptor;
-
-			DEBUG_PRINT
-			    ("Initializing the RX descriptors at 0x%lx\n",
-			     buf_);
-
-			for (index_ = 0; index_ < adapter->rx_num_desc;
-			     ++index_) {
-				memset((void *) &descriptor, 0,
-				       sizeof(appnic_dma_descriptor_t));
-				descriptor.write = 1;
-				descriptor.interrupt_on_completion = 1;
-				descriptor.host_data_memory_pointer = buf_;
-				descriptor.data_transfer_length =
-				    adapter->rx_buf_per_desc;
-				writedescriptor(((unsigned long) adapter->
-						 rx_desc +
-						 (index_ *
-						  sizeof
-						  (appnic_dma_descriptor_t))),
-						&descriptor);
-				buf_ += adapter->rx_buf_per_desc;
-			}
-
-			buf_ = (unsigned long) adapter->tx_buf_dma;
-			DEBUG_PRINT
-			    ("Initializing the RX descriptors at 0x%lx\n",
-			     buf_);
-
-			for (index_ = 0;
-			     index_ < adapter->tx_num_desc; ++index_) {
-				memset((void *) &descriptor, 0,
-				       sizeof(appnic_dma_descriptor_t));
-				descriptor.write = 1;
-				descriptor.interrupt_on_completion = 1;
-				descriptor.host_data_memory_pointer = buf_;
-				writedescriptor(((unsigned long) adapter->
-						 tx_desc +
-						 (index_ *
-						  sizeof
-						  (appnic_dma_descriptor_t))),
-						&descriptor);
-				buf_ += adapter->tx_buf_per_desc;
-			}
-		}
-
-		DEBUG_PRINT("rx_tail=0x%08lx\n",
-			    (unsigned long) adapter->rx_tail);
-		DEBUG_PRINT("Initializing spin locks and semaphores.\n");
-
-		/*
-		   Initialize the spin lock.
-		 */
-
-		spin_lock_init(&adapter->lock);
-		spin_lock_init(&adapter->extra_lock);
-
-		/*
-		 * TEMP: Initialize the semaphores
-		 */
-		mutex_init(&adapter->rx_sem);
-		mutex_init(&adapter->tx_sem);
-		mutex_init(&adapter->poll_sem);
-
-	}
-
-	/*
-	   Take MAC out of reset
-	 */
-
-	DEBUG_PRINT("rx_tail=0x%08lx\n", (unsigned long) adapter->rx_tail);
-	DEBUG_PRINT("Enabling the MAC");
-	write_mac_(0x0, APPNIC_RX_SOFT_RESET);
-	write_mac_(0x1, APPNIC_RX_MODE);
-	write_mac_(0x0, APPNIC_TX_SOFT_RESET);
-	write_mac_(0x1, APPNIC_TX_MODE);
-
-	if (is_asic())
-		write_mac_(0x300a, APPNIC_TX_WATERMARK);
-	else
-		write_mac_(0xc00096, APPNIC_TX_WATERMARK);
-
-	write_mac_(0x1, APPNIC_TX_HALF_DUPLEX_CONF);
-	write_mac_(0xffff, APPNIC_TX_TIME_VALUE_CONF);
-	write_mac_(0x1, APPNIC_TX_INTERRUPT_CONTROL);
-	write_mac_(0x5275, APPNIC_TX_EXTENDED_CONF);
-	write_mac_(0x1, APPNIC_RX_INTERNAL_INTERRUPT_CONTROL);
-	write_mac_(0x1, APPNIC_RX_EXTERNAL_INTERRUPT_CONTROL);
-	write_mac_(0x40010000, APPNIC_DMA_PCI_CONTROL);
-	write_mac_(0x30000, APPNIC_DMA_CONTROL);
-	writeio(0x280044, dma_base + 0x60);
-	writeio(0xc0, dma_base + 0x64);
-
-	/*
-	   Set the MAC address.
-	 */
-
-	{
-		struct sockaddr address;
-
-		memcpy(&(address.sa_data[0]), device->dev_addr, 6);
-		appnic_set_mac_address(device, &address);
-	}
-
-	/*
-	   Initialize the queue pointers.
-	 */
-
-	DEBUG_PRINT("rx_tail=0x%08lx\n", (unsigned long) adapter->rx_tail);
-	{
-
-		/*
-		   Receiver
-		 */
-
-		memset((void *) &adapter->rx_tail_copy,
-		       0, sizeof(appnic_queue_pointer_t));
-		memset((void *) &adapter->rx_head,
-		       0, sizeof(appnic_queue_pointer_t));
-
-		write_mac_(adapter->rx_desc_dma,
-			   APPNIC_DMA_RX_QUEUE_BASE_ADDRESS);
-		write_mac_((adapter->rx_num_desc *
-			    sizeof(appnic_dma_descriptor_t)) / 1024,
-			   APPNIC_DMA_RX_QUEUE_SIZE);
-		/* indicate that all of the receive descriptors are ready */
-		adapter->rx_head.bits.offset =
-		    (adapter->rx_num_desc - 1) *
-		    sizeof(appnic_dma_descriptor_t);
-		write_mac_(adapter->rx_tail_dma,
-			   APPNIC_DMA_RX_TAIL_POINTER_ADDRESS);
-
-		/*
-		   N.B.
-
-		   The boot loader may have used the NIC.  If so, the
-		   tail pointer must be read and the head pointer (and
-		   local copy of the tail) based on it.
-		 */
-
-		DEBUG_PRINT("Initializing the RX tail: adapter=0x%lx\n",
-			    (unsigned long) adapter);
-		DEBUG_PRINT
-		    ("Initializing the RX tail: adapter->rx_tail=0x%lx\n",
-		     (unsigned long) adapter->rx_tail);
-		DEBUG_PRINT
-		    ("Initializing the RX tail: adapter->rx_tail->raw=0x%lx\n",
-		     (unsigned long) adapter->rx_tail->raw);
-		adapter->rx_tail->raw =
-		    read_mac_(APPNIC_DMA_RX_TAIL_POINTER_LOCAL_COPY);
-		adapter->rx_tail_copy.raw = adapter->rx_tail->raw;
-		adapter->rx_head.raw = adapter->rx_tail->raw;
-		queue_decrement_(&adapter->rx_head, adapter->rx_num_desc);
-		adapter->rx_head.bits.generation_bit =
-		    (0 == adapter->rx_head.bits.generation_bit) ? 1 : 0;
-		write_mac_(adapter->rx_head.raw, APPNIC_DMA_RX_HEAD_POINTER);
-
-		/*
-		   Transmitter
-		 */
-
-		memset((void *) &adapter->tx_tail_copy,
-		       0, sizeof(appnic_queue_pointer_t));
-		memset((void *) &adapter->tx_head,
-		       0, sizeof(appnic_queue_pointer_t));
-
-		write_mac_(adapter->tx_desc_dma,
-			   APPNIC_DMA_TX_QUEUE_BASE_ADDRESS);
-		write_mac_((adapter->tx_num_desc *
-			    sizeof(appnic_dma_descriptor_t)) / 1024,
-			   APPNIC_DMA_TX_QUEUE_SIZE);
-		DEBUG_PRINT
-		    ("Writing 0x%lx to APPNIC_DMA_TX_TAIL_POINTER_ADDRESS\n",
-		     (unsigned long) adapter->tx_tail_dma);
-		write_mac_(adapter->tx_tail_dma,
-			   APPNIC_DMA_TX_TAIL_POINTER_ADDRESS);
-
-		/*
-		   N.B.
-
-		   The boot loader may have used the NIC.  If so, the
-		   tail pointer must be read and the head pointer (and
-		   local copy of the tail) based on it.
-		 */
-
-		DEBUG_PRINT
-		    ("Initializing the TX tail pointer at 0x%lx/0x%lx.\n",
-		     (unsigned long) adapter->tx_tail,
-		     (unsigned long) adapter->tx_tail->raw);
-		adapter->tx_tail->raw =
-		    read_mac_(APPNIC_DMA_TX_TAIL_POINTER_LOCAL_COPY);
-		adapter->tx_tail_copy.raw = adapter->tx_tail->raw;
-		adapter->tx_head.raw = adapter->tx_tail->raw;
-		write_mac_(adapter->tx_head.raw, APPNIC_DMA_TX_HEAD_POINTER);
-
-	}
-
-	/* clear statistics */
-
-	{
-
-		appnic_device_t *device_ = netdev_priv(device);
-		clear_statistics_(device_);
-
-	}
-
-	/* initialize the PHY */
-
-#ifndef PHYLESS
-
-	if (0 != phy_enable_(phy_address_))
-		WARN_PRINT("Failed to initialize the PHY!\n");
-#endif				/* PHYLESS */
-
-	/* fill in the net_device structure */
-
-	DEBUG_PRINT("Filling in the device structure.\n");
-	ether_setup(device);
-
-#ifdef CONFIG_ACP
-	device->irq = irq_create_mapping(NULL, adapter->interrupt);
-	if (NO_IRQ == device->irq) {
-		ERROR_PRINT("irq_create_mapping( ) failed\n");
-		return -EBUSY;
-	}
-
-	if (0 != irq_set_irq_type(device->irq, IRQ_TYPE_LEVEL_HIGH)) {
-		ERROR_PRINT("irq_set_irq_type( ) failed\n");
-		return -EBUSY;
-	}
-#else
-	device->irq = INT_MAC_DMA;
-#endif
-
-	device->netdev_ops = &appnic_netdev_ops;
-
-	SET_ETHTOOL_OPS(device, &appnic_ethtool_ops);
-#ifdef LSINET_NAPI
-	memset((void *) &adapter->napi, 0, sizeof(struct napi_struct));
-	netif_napi_add(device, &adapter->napi, lsinet_poll, LSINET_NAPI_WEIGHT);
-	adapter->device = device;
-	DEBUG_PRINT("lsinet_poll=0x%lx\n", (unsigned long) lsinet_poll);
-#endif
-
-	/* that's all */
-	TRACE_ENDING();
-	return 0;
-
-}
-
-/*
-  ----------------------------------------------------------------------
-  appnic_read_proc_
-*/
-
-static int
-appnic_read_proc_(char *page, char **start, off_t offset,
-		  int count, int *eof, void *data)
-{
-
-	int length_;
-
-#ifdef __APPNIC_C_PROFILE__
-
-	struct net_device *net_device_ = this_net_device;
-	appnic_device_t *appnic_device_ = (appnic_device_t *) net_device_->priv;
-	unsigned long divisor_;
-	unsigned long tx_tpa_real_;
-	unsigned long tx_tpa_virt_;
-
-	divisor_ = get_core_speed() / 1000000;
-
-	if (appnic_device_->tx_tail_dma !=
-	    read_mac_(APPNIC_DMA_TX_TAIL_POINTER_ADDRESS)) {
-
-		ERROR_PRINT(
-			"Real Address Doesn't Match Configuration! 0x%x 0x%x\n",
-			appnic_device_->tx_tail_dma,
-			read_mac_(APPNIC_DMA_TX_TAIL_POINTER_ADDRESS));
-
-	}
-
-	tx_tpa_real_ = appnic_device_->tx_tail_dma;
-	tx_tpa_virt_ = appnic_device_->tx_tail->raw;
-
-	length_ = sprintf(page,
-			  " GKM TEMP DEBUG Build 5\n"
-			  " RX: head=0x%lx tail=0x%lx tail_copy=0x%lx\n"
-			  " TX: head=0x%lx tail=0x%lx tail_copy=0x%lx\n"
-			  "DMA: IE=0x%x IS=0x%x\n"
-			  "VIC: status=0x%x raw=0x%x enable=0x%x\n"
-			  " TX: tpa_config=0x%x tpa_real_=0x%lx "
-			  "*tpa_virt_=0x%x\n",
-			  appnic_device_->rx_head.raw,
-			  appnic_device_->rx_tail->raw,
-			  appnic_device_->rx_tail_copy.raw,
-			  appnic_device_->tx_head.raw,
-			  appnic_device_->tx_tail->raw,
-			  appnic_device_->tx_tail_copy.raw,
-			  read_mac_(APPNIC_DMA_INTERRUPT_ENABLE),
-			  read_mac_(APPNIC_DMA_INTERRUPT_STATUS),
-			  readl((APP3XX_VIC_BASE + VICIRQSTATUS)),
-			  readl((APP3XX_VIC_BASE + VICRAWINTR)),
-			  readl((APP3XX_VIC_BASE + VICINTENABLE)),
-			  read_mac_(APPNIC_DMA_TX_TAIL_POINTER_ADDRESS),
-			  tx_tpa_real_, *((unsigned int *) tx_tpa_virt_));
-
-	time_in_rx_max_ = 0;
-	time_in_rx_min_ = 0xffffffff;
-	rx_packet_size_max_ = 0;
-	rx_packet_size_min_ = 0xffffffff;
-	total_rx_bytes_ = 0;
-	total_rx_packets_handled_ = 1;
-	total_rx_time_ = 0;
-	max_rx_packets_handled_ = 0;
-	total_rx_interrupts_ = 0;
-
-#ifdef LSINET_NAPI
-
-	receive_interrupts_ = 0;
-	total_polls_ = 0;
-
-#endif
-
-	time_in_tx_max_ = 0;
-	time_in_tx_min_ = 0xffffffff;
-	total_tx_time_ = 0;
-	total_tx_packets_ = 1;
-	jiffies_changed_ = 0;
-	recv_t1_min_ = 0xffffffff;
-	recv_t2_min_ = 0xffffffff;
-	recv_t3_min_ = 0xffffffff;
-	recv_t1_max_ = 0;
-	recv_t2_max_ = 0;
-	recv_t3_max_ = 0;
-	recv_t1_tot_ = 0;
-	recv_t2_tot_ = 0;
-	recv_t3_tot_ = 0;
-	total_rx_packets_sent_up_ = 1;
-
-#else
-
-	length_ = sprintf(page, "-- appnic.c -- Profiling is disabled\n");
-
-#endif
-
-	/* that's all */
-	return length_;
-
-}
-
-/*
-  ----------------------------------------------------------------------
-  lsinet_init
-*/
-
-int
-lsinet_init(void)
-{
-	int rc = 0;
-	struct net_device *device;
-	struct device_node *np = NULL;
-	const u32 *field;
-	appnic_device_t *appnic_device;
-
-	TRACE_BEGINNING();
-
-	/* Allocate space for the device. */
-	device = alloc_etherdev(sizeof(appnic_device_t));
-	if ((struct net_device *) 0 == device) {
-		ERROR_PRINT("Couldn't allocate net device.");
-		rc = -ENOMEM;
-		goto out;
-	}
-
-	this_net_device = device;	/* For /proc/reads. */
-	appnic_device = (appnic_device_t *) netdev_priv(device);
-
-	/*
-	   Get the physical addresses, interrupt number, etc. from the
-	   device tree.  If no entry exists (older boot loader...) just
-	   use the pre-devicetree method.
-	 */
-
-	np = of_find_node_by_type(np, "network");
-
-	while (np && !of_device_is_compatible(np, "acp-femac"))
-		np = of_find_node_by_type(np, "network");
-
-	if (np) {
-		u64 value64;
-		u32 value32;
-		int length;
-
-		field = of_get_property(np, "enabled", NULL);
-
-		if (!field || (field && (0 == *field))) {
-			ERROR_PRINT("Not Enabled\n");
-			rc = -EINVAL;
-			goto out;
-		}
-
-		field = of_get_property(np, "reg", NULL);
-
-		if (!field) {
-			ERROR_PRINT("Couldn't get \"reg\" property.\n");
-			rc = -EINVAL;
-			goto out;
-		}
-
-		value64 = of_translate_address(np, field);
-		value32 = field[1];
-		field += 2;
-		rx_base = (unsigned long) ioremap(value64, value32);
-		appnic_device->rx_base = rx_base;
-		value64 = of_translate_address(np, field);
-		value32 = field[1];
-		field += 2;
-		tx_base = (unsigned long) ioremap(value64, value32);
-		appnic_device->tx_base = tx_base;
-		value64 = of_translate_address(np, field);
-		value32 = field[1];
-		field += 2;
-		dma_base = (unsigned long) ioremap(value64, value32);
-		appnic_device->dma_base = dma_base;
-
-		field = of_get_property(np, "interrupts", NULL);
-
-		if (field)
-			appnic_device->interrupt = field[0];
-		else
-			goto device_tree_failed;
-
-		field = of_get_property(np, "mdio-clock", NULL);
-
-		if (!field)
-			goto device_tree_failed;
-		else
-			appnic_device->mdio_clock = field[0];
-
-		field = of_get_property(np, "phy-address", NULL);
-
-		if (!field)
-			goto device_tree_failed;
-		else
-			appnic_device->phy_address = field[0];
-
-		field = of_get_property(np, "ad-value", NULL);
-
-		if (!field)
-			goto device_tree_failed;
-		else
-			appnic_device->ad_value = field[0];
-
-		field = of_get_property(np, "mac-address", &length);
-
-		if (!field || 6 != length) {
-			goto device_tree_failed;
-		} else {
-			int i;
-			u8 *value;
-
-			value = (u8 *) field;
-
-			for (i = 0; i < 6; ++i) {
-				/*printk("value[%d] = 0x%2x\n", i, value[i]); */
-				appnic_device->mac_addr[i] = value[i];
-			}
-		}
-
-		memcpy(device->dev_addr, &appnic_device->mac_addr[0], 6);
-		memcpy(device->perm_addr, &appnic_device->mac_addr[0], 6);
-
-		goto device_tree_succeeded;
-
-device_tree_failed:
-		ERROR_PRINT("Reading Device Tree Failed\n");
-		iounmap((void *) rx_base);
-		iounmap((void *) tx_base);
-		iounmap((void *) dma_base);
-		rc = -EINVAL;
-		goto out;
-
-	} else {
-		unsigned char ethaddr_string[20];
-#ifdef CONFIG_LSI_UBOOTENV
-		if (0 != ubootenv_get("ethaddr", ethaddr_string)) {
-			ERROR_PRINT("Could not read ethernet address!\n");
-			return -EBUSY;
-		} else {
-			char *string;
-			int i = 0;
-			u8 mac_address[6];
-
-			string = ethaddr_string;
-
-			while ((0 != string) && (6 > i)) {
-				char *value;
-
-				value = strsep(&string, ":");
-				mac_address[i++] =
-				    simple_strtoul(value, NULL, 16);
-			}
-
-			memcpy(device->dev_addr, mac_address, 6);
-			memcpy(device->perm_addr, mac_address, 6);
-			device->addr_len = 6;
-		}
-
-		printk("LSI FEMAC: Using Static Addresses and Interrupts.\n");
-		rx_base = (unsigned long) ioremap(0x002000480000ULL, 0x1000);
-		appnic_device->rx_base = rx_base;
-		tx_base = (unsigned long) ioremap(0x002000481000ULL, 0x1000);
-		appnic_device->tx_base = tx_base;
-		dma_base = (unsigned long) ioremap(0x002000482000ULL, 0x1000);
-		appnic_device->dma_base = dma_base;
-		appnic_device->interrupt = 33;
-#else
-		/* Neither dtb info nor ubootenv driver found. */
-		ERROR_PRINT("Could not read ethernet address!\n");
-		return -EBUSY;
-#endif
-	}
-
-device_tree_succeeded:
-
-#ifdef __APPNIC_C_PROFILE__
-	writel(0xffffffff, (TIMER7_BASE + TIMER_n_LOAD));
-	writel(0xffffffff, (TIMER7_BASE + TIMER_n_VALUE));
-	writel((TIMER_n_CONTROL_ENABLE |
-		TIMER_n_CONTROL_MODE |
-		TIMER_n_CONTROL_SIZE), (TIMER7_BASE + TIMER_n_CONTROL));
-#endif				/* __APPNIC_C_PROFILE__ */
-
-	/* Initialize the device. */
-	rc = appnic_init(device);
-	if (0 != rc) {
-		ERROR_PRINT("appnic_init( ) failed: %d\n", rc);
-		rc = -ENODEV;
-		goto out;
-	}
-
-	strcpy(this_net_device->name, "eth%d");
-
-	/* Register the device. */
-
-	rc = register_netdev(this_net_device);
-	if (0 != rc) {
-		ERROR_PRINT("register_netdev() failed: %d\n", rc);
-		rc = -ENODEV;
-		goto out;
-	}
-
-	/* Create the /proc entry. */
-	create_proc_read_entry("driver/appnic", 0, NULL,
-			       appnic_read_proc_, NULL);
-
-out:
-	TRACE_ENDING();
-	return rc;
-}
-
-module_init(lsinet_init);
-
-/*
-  ----------------------------------------------------------------------
-  lsinet_exit
-*/
-
-void __exit
-lsinet_exit(void)
-{
-	TRACE_BEGINNING();
-	remove_proc_entry("driver/appnic", NULL);
-	unregister_netdev(this_net_device);
-	TRACE_ENDING();
-
-	return;
-}
-
-module_exit(lsinet_exit);
diff --git a/drivers/lsi/acp/wrappers.c b/drivers/lsi/acp/wrappers.c
deleted file mode 100644
index 328c1fe..0000000
--- a/drivers/lsi/acp/wrappers.c
+++ /dev/null
@@ -1,238 +0,0 @@
-/*
- * drivers/lsi/acp/wrappers.c
- *
- * Copyright (C) 2010 LSI
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307	 USA
- */
-
-#include <linux/module.h>
-#include <linux/of.h>
-#include <asm/irq.h>
-#include <linux/io.h>
-
-#include <asm/lsi/acp_ncr.h>
-
-/*
-  ==============================================================================
-  ==============================================================================
-  MDIO Access
-  ==============================================================================
-  ==============================================================================
-*/
-
-#ifndef CONFIG_ACPISS
-
-#define BZ33327_WA
-
-static unsigned long mdio_base;
-static DEFINE_SPINLOCK(mdio_lock);
-
-#define MDIO_CONTROL_RD_DATA ((void *)(mdio_base + 0x0))
-#define MDIO_STATUS_RD_DATA  ((void *)(mdio_base + 0x4))
-#define MDIO_CLK_OFFSET      ((void *)(mdio_base + 0x8))
-#define MDIO_CLK_PERIOD      ((void *)(mdio_base + 0xc))
-
-/*
-  ------------------------------------------------------------------------------
-  acp_mdio_read
-*/
-
-int
-acp_mdio_read(unsigned long address, unsigned long offset,
-	      unsigned short *value)
-{
-	unsigned long command = 0;
-	unsigned long status;
-	unsigned long flags;
-
-	spin_lock_irqsave(&mdio_lock, flags);
-#if defined(BZ33327_WA)
-	/* Set the mdio_busy (status) bit. */
-	status = in_le32(MDIO_STATUS_RD_DATA);
-	status |= 0x40000000;
-	out_le32(MDIO_STATUS_RD_DATA, status);
-#endif				/* BZ33327_WA */
-
-	/* Write the command. */
-	command |= 0x10000000;	/* op_code: read */
-	command |= (address & 0x1f) << 16;	/* port_addr (target device) */
-	command |= (offset & 0x1f) << 21;/* device_addr (target register) */
-	out_le32(MDIO_CONTROL_RD_DATA, command);
-
-#if defined(BZ33327_WA)
-	/* Wait for the mdio_busy (status) bit to clear. */
-	do {
-		status = in_le32(MDIO_STATUS_RD_DATA);
-	} while (0 != (status & 0x40000000));
-
-	/* Wait for the mdio_busy (control) bit to clear. */
-	do {
-		command = in_le32(MDIO_CONTROL_RD_DATA);
-	} while (0 != (command & 0x80000000));
-
-	*value = (unsigned short)(command & 0xffff);
-#endif				/* BZ33327_WA */
-	spin_unlock_irqrestore(&mdio_lock, flags);
-
-	return 0;
-}
-EXPORT_SYMBOL(acp_mdio_read);
-
-/*
-  ------------------------------------------------------------------------------
-  acp_mdio_write
-*/
-
-int
-acp_mdio_write(unsigned long address, unsigned long offset,
-	       unsigned short value)
-{
-	unsigned long command = 0;
-	unsigned long status;
-	unsigned long flags;
-
-	spin_lock_irqsave(&mdio_lock, flags);
-
-	/* Wait for mdio_busy (control) to be clear. */
-	do {
-		command = in_le32(MDIO_CONTROL_RD_DATA);
-	} while (0 != (command & 0x80000000));
-
-#if defined(BZ33327_WA)
-	/* Set the mdio_busy (status) bit. */
-	status = in_le32(MDIO_STATUS_RD_DATA);
-	status |= 0x40000000;
-	out_le32(MDIO_STATUS_RD_DATA, status);
-#endif				/* BZ33327_WA */
-
-	/* Write the command. */
-	command = 0x08000000;	/* op_code: write */
-	command |= (address & 0x1f) << 16;	/* port_addr (target device) */
-	command |= (offset & 0x1f) << 21;/* device_addr (target register) */
-	command |= (value & 0xffff);	/* value */
-	out_le32(MDIO_CONTROL_RD_DATA, command);
-
-#if defined(BZ33327_WA)
-	/* Wait for the mdio_busy (status) bit to clear. */
-	do {
-		status = in_le32(MDIO_STATUS_RD_DATA);
-	} while (0 != (status & 0x40000000));
-#endif				/* BZ33327_WA */
-
-	/* Wait for the mdio_busy (control) bit to clear. */
-	do {
-		command = in_le32(MDIO_CONTROL_RD_DATA);
-	} while (0 != (command & 0x80000000));
-
-	spin_unlock_irqrestore(&mdio_lock, flags);
-
-	return 0;
-}
-EXPORT_SYMBOL(acp_mdio_write);
-
-/*
-  ------------------------------------------------------------------------------
-  acp_mdio_initialize
-*/
-
-static int
-acp_mdio_initialize(void)
-{
-	if (is_asic()) {
-		out_le32(MDIO_CLK_OFFSET, 0x10);
-		out_le32(MDIO_CLK_PERIOD, 0x2c);
-	} else {
-		out_le32(MDIO_CLK_OFFSET, 0x05);
-		out_le32(MDIO_CLK_PERIOD, 0x0c);
-	}
-
-	return 0;
-}
-
-#endif				/* CONFIG_ACPISS */
-
-/*
-  ==============================================================================
-  ==============================================================================
-  Interrupts
-  ==============================================================================
-  ==============================================================================
-*/
-
-/*
-  ------------------------------------------------------------------------------
-  acp_wrappers_init
-*/
-
-int __init
-acp_wrappers_init(void)
-{
-	int rc = -1;
-	struct device_node *np = NULL;
-	const u32 *field;
-	u64 mdio_phys_address;
-	u32 mdio_size;
-
-	printk(KERN_INFO "Initializing ACP Wrappers.\n");
-
-#ifndef CONFIG_ACPISS
-	np = of_find_node_by_type(np, "network");
-
-	while (np && !of_device_is_compatible(np, "acp-femac"))
-		np = of_find_node_by_type(np, "network");
-
-	if (np) {
-		field = of_get_property(np, "enabled", NULL);
-
-		if (!field || (field && (0 == *field))) {
-			printk(KERN_WARNING "Networking is Not Enabled.\n");
-			goto acp_wrappers_init_done;
-		}
-
-		field = of_get_property(np, "mdio-reg", NULL);
-
-		if (!field) {
-			printk(KERN_ERR
-			       "Couldn't get \"mdio-reg\" property.\n");
-		} else {
-			mdio_phys_address = of_translate_address(np, field);
-			mdio_size = field[1];
-			rc = 0;
-		}
-	}
-
-	if (0 != rc) {
-		mdio_phys_address = 0x002000409000ULL;
-		mdio_size = 0x1000;
-		printk(KERN_WARNING
-		       "** MDIO Address Not Specified in Device Tree.\n");
-	}
-
-	mdio_base = (unsigned long)ioremap(mdio_phys_address, mdio_size);
-	rc = acp_mdio_initialize();
-#endif
-
-	if (0 != rc)
-		printk(KERN_ERR "MDIO Initiailzation Failed!\n");
-
-acp_wrappers_init_done:
-	return 0;
-}
-module_init(acp_wrappers_init);
-
-MODULE_AUTHOR("LSI Corporation");
-MODULE_DESCRIPTION("Timing Test");
-MODULE_LICENSE("GPL");
diff --git a/drivers/net/ethernet/Kconfig b/drivers/net/ethernet/Kconfig
index c63a64c..c45914d 100644
--- a/drivers/net/ethernet/Kconfig
+++ b/drivers/net/ethernet/Kconfig
@@ -177,4 +177,37 @@ source "drivers/net/ethernet/via/Kconfig"
 source "drivers/net/ethernet/xilinx/Kconfig"
 source "drivers/net/ethernet/xircom/Kconfig"
 
+config LSI_NET
+	bool "Network interface for LSI's APP and ACP"
+	help
+	  Network interface driver for LSI's APP and ACP series boards.
+
+config LSI_NET_NUM_RX_DESC
+	int "NIC driver: Number of receive descriptors"
+	depends on LSI_NET
+	default "4"
+	help
+          The number of receive descriptors to allocate.
+
+config LSI_NET_RX_BUF_SZ
+    int "NIC driver: Size of the receive buffer"
+    depends on LSI_NET
+    default "32768"
+    help
+        The size of the receive buffer.
+
+config LSI_NET_NUM_TX_DESC
+    int "NIC driver: Number of transmit descriptors"
+    depends on LSI_NET
+    default "4"
+    help
+        The number of transmit descriptors to allocate.
+
+config LSI_NET_TX_BUF_SZ
+    int "NIC driver: Size of the transmit buffer"
+    depends on LSI_NET
+    default "32768"
+    help
+        The size of the transmit buffer.
+
 endif # ETHERNET
diff --git a/drivers/net/ethernet/Makefile b/drivers/net/ethernet/Makefile
index ae0e21c..4c18003 100644
--- a/drivers/net/ethernet/Makefile
+++ b/drivers/net/ethernet/Makefile
@@ -76,3 +76,6 @@ obj-$(CONFIG_NET_VENDOR_TUNDRA) += tundra/
 obj-$(CONFIG_NET_VENDOR_VIA) += via/
 obj-$(CONFIG_NET_VENDOR_XILINX) += xilinx/
 obj-$(CONFIG_NET_VENDOR_XIRCOM) += xircom/
+
+obj-$(CONFIG_LSI_NET) += lsi_acp_mdio.o
+obj-$(CONFIG_LSI_NET) += lsi_acp_net.o
\ No newline at end of file
diff --git a/drivers/net/ethernet/lsi_acp_mdio.c b/drivers/net/ethernet/lsi_acp_mdio.c
new file mode 100644
index 0000000..328c1fe
--- /dev/null
+++ b/drivers/net/ethernet/lsi_acp_mdio.c
@@ -0,0 +1,238 @@
+/*
+ * drivers/lsi/acp/wrappers.c
+ *
+ * Copyright (C) 2010 LSI
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307	 USA
+ */
+
+#include <linux/module.h>
+#include <linux/of.h>
+#include <asm/irq.h>
+#include <linux/io.h>
+
+#include <asm/lsi/acp_ncr.h>
+
+/*
+  ==============================================================================
+  ==============================================================================
+  MDIO Access
+  ==============================================================================
+  ==============================================================================
+*/
+
+#ifndef CONFIG_ACPISS
+
+#define BZ33327_WA
+
+static unsigned long mdio_base;
+static DEFINE_SPINLOCK(mdio_lock);
+
+#define MDIO_CONTROL_RD_DATA ((void *)(mdio_base + 0x0))
+#define MDIO_STATUS_RD_DATA  ((void *)(mdio_base + 0x4))
+#define MDIO_CLK_OFFSET      ((void *)(mdio_base + 0x8))
+#define MDIO_CLK_PERIOD      ((void *)(mdio_base + 0xc))
+
+/*
+  ------------------------------------------------------------------------------
+  acp_mdio_read
+*/
+
+int
+acp_mdio_read(unsigned long address, unsigned long offset,
+	      unsigned short *value)
+{
+	unsigned long command = 0;
+	unsigned long status;
+	unsigned long flags;
+
+	spin_lock_irqsave(&mdio_lock, flags);
+#if defined(BZ33327_WA)
+	/* Set the mdio_busy (status) bit. */
+	status = in_le32(MDIO_STATUS_RD_DATA);
+	status |= 0x40000000;
+	out_le32(MDIO_STATUS_RD_DATA, status);
+#endif				/* BZ33327_WA */
+
+	/* Write the command. */
+	command |= 0x10000000;	/* op_code: read */
+	command |= (address & 0x1f) << 16;	/* port_addr (target device) */
+	command |= (offset & 0x1f) << 21;/* device_addr (target register) */
+	out_le32(MDIO_CONTROL_RD_DATA, command);
+
+#if defined(BZ33327_WA)
+	/* Wait for the mdio_busy (status) bit to clear. */
+	do {
+		status = in_le32(MDIO_STATUS_RD_DATA);
+	} while (0 != (status & 0x40000000));
+
+	/* Wait for the mdio_busy (control) bit to clear. */
+	do {
+		command = in_le32(MDIO_CONTROL_RD_DATA);
+	} while (0 != (command & 0x80000000));
+
+	*value = (unsigned short)(command & 0xffff);
+#endif				/* BZ33327_WA */
+	spin_unlock_irqrestore(&mdio_lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(acp_mdio_read);
+
+/*
+  ------------------------------------------------------------------------------
+  acp_mdio_write
+*/
+
+int
+acp_mdio_write(unsigned long address, unsigned long offset,
+	       unsigned short value)
+{
+	unsigned long command = 0;
+	unsigned long status;
+	unsigned long flags;
+
+	spin_lock_irqsave(&mdio_lock, flags);
+
+	/* Wait for mdio_busy (control) to be clear. */
+	do {
+		command = in_le32(MDIO_CONTROL_RD_DATA);
+	} while (0 != (command & 0x80000000));
+
+#if defined(BZ33327_WA)
+	/* Set the mdio_busy (status) bit. */
+	status = in_le32(MDIO_STATUS_RD_DATA);
+	status |= 0x40000000;
+	out_le32(MDIO_STATUS_RD_DATA, status);
+#endif				/* BZ33327_WA */
+
+	/* Write the command. */
+	command = 0x08000000;	/* op_code: write */
+	command |= (address & 0x1f) << 16;	/* port_addr (target device) */
+	command |= (offset & 0x1f) << 21;/* device_addr (target register) */
+	command |= (value & 0xffff);	/* value */
+	out_le32(MDIO_CONTROL_RD_DATA, command);
+
+#if defined(BZ33327_WA)
+	/* Wait for the mdio_busy (status) bit to clear. */
+	do {
+		status = in_le32(MDIO_STATUS_RD_DATA);
+	} while (0 != (status & 0x40000000));
+#endif				/* BZ33327_WA */
+
+	/* Wait for the mdio_busy (control) bit to clear. */
+	do {
+		command = in_le32(MDIO_CONTROL_RD_DATA);
+	} while (0 != (command & 0x80000000));
+
+	spin_unlock_irqrestore(&mdio_lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(acp_mdio_write);
+
+/*
+  ------------------------------------------------------------------------------
+  acp_mdio_initialize
+*/
+
+static int
+acp_mdio_initialize(void)
+{
+	if (is_asic()) {
+		out_le32(MDIO_CLK_OFFSET, 0x10);
+		out_le32(MDIO_CLK_PERIOD, 0x2c);
+	} else {
+		out_le32(MDIO_CLK_OFFSET, 0x05);
+		out_le32(MDIO_CLK_PERIOD, 0x0c);
+	}
+
+	return 0;
+}
+
+#endif				/* CONFIG_ACPISS */
+
+/*
+  ==============================================================================
+  ==============================================================================
+  Interrupts
+  ==============================================================================
+  ==============================================================================
+*/
+
+/*
+  ------------------------------------------------------------------------------
+  acp_wrappers_init
+*/
+
+int __init
+acp_wrappers_init(void)
+{
+	int rc = -1;
+	struct device_node *np = NULL;
+	const u32 *field;
+	u64 mdio_phys_address;
+	u32 mdio_size;
+
+	printk(KERN_INFO "Initializing ACP Wrappers.\n");
+
+#ifndef CONFIG_ACPISS
+	np = of_find_node_by_type(np, "network");
+
+	while (np && !of_device_is_compatible(np, "acp-femac"))
+		np = of_find_node_by_type(np, "network");
+
+	if (np) {
+		field = of_get_property(np, "enabled", NULL);
+
+		if (!field || (field && (0 == *field))) {
+			printk(KERN_WARNING "Networking is Not Enabled.\n");
+			goto acp_wrappers_init_done;
+		}
+
+		field = of_get_property(np, "mdio-reg", NULL);
+
+		if (!field) {
+			printk(KERN_ERR
+			       "Couldn't get \"mdio-reg\" property.\n");
+		} else {
+			mdio_phys_address = of_translate_address(np, field);
+			mdio_size = field[1];
+			rc = 0;
+		}
+	}
+
+	if (0 != rc) {
+		mdio_phys_address = 0x002000409000ULL;
+		mdio_size = 0x1000;
+		printk(KERN_WARNING
+		       "** MDIO Address Not Specified in Device Tree.\n");
+	}
+
+	mdio_base = (unsigned long)ioremap(mdio_phys_address, mdio_size);
+	rc = acp_mdio_initialize();
+#endif
+
+	if (0 != rc)
+		printk(KERN_ERR "MDIO Initiailzation Failed!\n");
+
+acp_wrappers_init_done:
+	return 0;
+}
+module_init(acp_wrappers_init);
+
+MODULE_AUTHOR("LSI Corporation");
+MODULE_DESCRIPTION("Timing Test");
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/ethernet/lsi_acp_net.c b/drivers/net/ethernet/lsi_acp_net.c
new file mode 100644
index 0000000..31e9da8
--- /dev/null
+++ b/drivers/net/ethernet/lsi_acp_net.c
@@ -0,0 +1,4222 @@
+/*
+ * drivers/lsi/acp/net.c
+ *
+ * Copyright (C) 2009 LSI
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+#include <linux/in.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/bitops.h>
+#include <linux/proc_fs.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/skbuff.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/of.h>
+
+#include <linux/uaccess.h>
+#include <linux/io.h>
+#include <asm/dma.h>
+
+#include <asm/lsi/acp_ncr.h>
+
+extern int acp_mdio_read(unsigned long, unsigned long, unsigned short *);
+extern int acp_mdio_write(unsigned long, unsigned long, unsigned short);
+
+/* Base Addresses of the RX, TX, and DMA Registers. */
+static unsigned long rx_base;
+static unsigned long tx_base;
+static unsigned long dma_base;
+
+/*
+  =================================================
+  Debug counts (readable from the external host).
+  =================================================
+*/
+
+#undef LSINET_COUNTS
+#define LSINET_COUNTS
+
+#ifdef LSINET_COUNTS
+
+unsigned long lsinet_counts[] = {
+	0, 0, 0, 0,		/* ISR */
+	0, 0, 0, 0, 0, 0,	/* HST */
+	0, 0, 0, 0, 0, 0, 0,	/* RX */
+	0, 0, 0, 0		/* POL */
+};
+EXPORT_SYMBOL(lsinet_counts);
+
+#define LSINET_COUNTS_INC(index) { ++lsinet_counts[(index)]; }
+
+#else				/* LSINET_DEBUG_COUNTS */
+
+#define LSINET_COUNTS_INC(index)
+
+#endif				/* LSINET_DEBUG_COUNTS */
+
+#define LSINET_COUNTS_ISR_START  0
+#define LSINET_COUNTS_ISR_TX     1
+#define LSINET_COUNTS_ISR_RX     2
+#define LSINET_COUNTS_ISR_DONE   3
+#define LSINET_COUNTS_HST_START  4
+#define LSINET_COUNTS_HST_RCLM   5
+#define LSINET_COUNTS_HST_SNDG   6
+#define LSINET_COUNTS_HST_SNT    7
+#define LSINET_COUNTS_HST_OOD    8
+#define LSINET_COUNTS_HST_DONE   9
+#define LSINET_COUNTS_RX_START  10
+#define LSINET_COUNTS_RX_PKT    11
+#define LSINET_COUNTS_RX_ERR    12
+#define LSINET_COUNTS_RX_GOOD   13
+#define LSINET_COUNTS_RX_SENT   14
+#define LSINET_COUNTS_RX_DRPD   15
+#define LSINET_COUNTS_RX_DONE   16
+#define LSINET_COUNTS_POL_START 17
+#define LSINET_COUNTS_POL_PKT   18
+#define LSINET_COUNTS_POL_RNBL  19
+#define LSINET_COUNTS_POL_DONE  20
+
+/*
+  =======================================
+  Profile/Trace/Debug/Warn/Error Macros
+  =======================================
+*/
+
+/* -- Profile --- */
+
+/*#define __APPNIC_C_PROFILE__*/
+#ifdef __APPNIC_C_PROFILE__
+#include <asm/arch/timers.h>
+unsigned long time_in_rx_max_;
+unsigned long time_in_rx_min_ = 0xffffffff;
+unsigned long long total_rx_time_;
+unsigned long max_rx_packets_handled_;
+unsigned long total_rx_packets_handled_;
+unsigned long total_rx_interrupts_;
+unsigned long rx_packet_size_max_;
+unsigned long rx_packet_size_min_ = 0xffffffff;
+unsigned long total_rx_bytes_;
+unsigned long time_in_tx_max_;
+unsigned long time_in_tx_min_ = 0xffffffff;
+unsigned long long total_tx_time_;
+unsigned long total_tx_packets_ = 1;
+unsigned long jiffies_changed_;
+unsigned long total_polls_;
+
+unsigned long recv_t1_min_ = 0xffffffff;
+unsigned long recv_t2_min_ = 0xffffffff;
+unsigned long recv_t3_min_ = 0xffffffff;
+unsigned long recv_t1_max_;
+unsigned long recv_t2_max_;
+unsigned long recv_t3_max_;
+unsigned long long recv_t1_tot_;
+unsigned long long recv_t2_tot_;
+unsigned long long recv_t3_tot_;
+unsigned long total_rx_packets_sent_up_ = 1;
+
+#define app3xx_profile_time_calc(_beg_t_, _end_t_, _min_t_, _max_t_, _tot_t_) \
+do {	\
+	unsigned long _this_t_;	\
+	if (_end_t_ > _beg_t_)	\
+		_this_t_ = _end_t_ - _beg_t_;	\
+	else	\
+		_this_t_ = _end_t_ + (0xffffffff - _beg_t_) + 1;	\
+		_tot_t_ += _this_t_;	\
+	if (_this_t_ > _max_t_)	\
+		_max_t_ = _this_t_;	\
+	if (_this_t_ < _min_t_)	\
+		_min_t_ = _this_t_;	\
+} while (0)
+
+#define profile_time_fmt(t, d)  ((1000 * t) / d)
+#define profile_avg_fmt(t, c, d) ((1000 * (t / c)) / d)
+#endif				/* __APPNIC_C_PROFILE__ */
+
+#include <asm/lsi/debug.h>
+
+/*
+  ======================================================================
+  ======================================================================
+  Optimizations
+  ======================================================================
+  ======================================================================
+*/
+
+#define DISABLE_TX_INTERRUPTS
+/*#define PRELOAD_RX_BUFFERS*/
+
+#undef DMA_CACHABLE
+/*#define DMA_CACHABLE*/
+
+/*
+  ===================================
+  NAPI Support (new and newer)...
+  ===================================
+*/
+
+#define LSINET_NAPI
+#define LSINET_NAPI_WEIGHT 64
+
+/*
+  ===================================
+  Access and Access Logging
+  ===================================
+*/
+
+/*#define LOG_MAC_ACCESS*/
+/*#define LOG_PHY_ACCESS*/
+
+/*
+  ====================================
+  PHY
+  ====================================
+*/
+
+#undef PHYLESS
+/*#define PHYLESS*/
+
+#ifndef PHYLESS
+
+/* -- control -- */
+
+#define PHY_CONTROL 0x00
+
+typedef union {
+	unsigned short raw;
+
+	struct {
+#if 1
+		unsigned short soft_reset:1;
+		unsigned short loop_back:1;
+		unsigned short force100:1;	/* speedBit0 */
+		unsigned short autoneg_enable:1;
+		unsigned short power_down:1;
+		unsigned short isolate:1;
+		unsigned short restart_autoneg:1;
+		unsigned short full_duplex:1;	/* duplex */
+		unsigned short collision_test:1;
+		unsigned short unused:7;
+#else				/* __BIG_ENDIAN */
+		unsigned short:7;
+		unsigned short collision_test:1;
+		unsigned short full_duplex:1;	/* duplex */
+		unsigned short restart_autoneg:1;
+		unsigned short isolate:1;
+		unsigned short power_down:1;
+		unsigned short autoneg_enable:1;
+		unsigned short force100:1;	/* speedBit0 */
+		unsigned short loop_back:1;
+		unsigned short soft_reset:1;
+#endif				/* __BIG_ENDIAN */
+	} __packed bits;
+} __packed phy_control_t;
+
+/* -- status -- */
+
+#define PHY_STATUS 0x01
+
+typedef union {
+	unsigned short raw;
+
+	struct {
+#if 1
+		unsigned short t4_capable:1;
+		unsigned short tx_fdx_capable:1;
+		unsigned short tx_capable:1;
+		unsigned short bt_fdx_capable:1;
+		unsigned short tenbt_capable:1;
+		unsigned short unused:4;
+		unsigned short mf_pream_suppress:1;
+		unsigned short autoneg_comp:1;	/* autoNegDone */
+		unsigned short remote_fault:1;	/* remoutFault */
+		unsigned short autoneg_capable:1;
+		unsigned short link_status:1;	/* linkStatus */
+		unsigned short jabber_detect:1;
+		unsigned short extd_reg_capable:1;
+#else
+		unsigned short extd_reg_capable:1;
+		unsigned short jabber_detect:1;
+		unsigned short link_status:1;	/* linkStatus */
+		unsigned short autoneg_capable:1;
+		unsigned short remote_fault:1;	/* remoutFault */
+		unsigned short autoneg_comp:1;	/* autoNegDone */
+		unsigned short mf_pream_suppress:1;
+		unsigned short:4;
+		unsigned short tenbt_capable:1;
+		unsigned short bt_fdx_capable:1;
+		unsigned short tx_capable:1;
+		unsigned short tx_fdx_capable:1;
+		unsigned short t4_capable:1;
+#endif				/* __BIG_ENDIAN */
+	} __packed bits;
+} __packed phy_status_t;
+
+/* -- id_high -- */
+
+#define PHY_ID_HIGH 0x02
+
+typedef union {
+	unsigned short raw;
+
+	struct {
+		unsigned short id:16;
+	} __packed bits;
+} __packed phy_id_high_t;
+
+/* -- id_low -- */
+
+#define PHY_ID_LOW  0x03
+
+typedef union {
+	unsigned short raw;
+
+	struct {
+#if 1
+		unsigned short id:6;
+		unsigned short model:6;
+		unsigned short revision:4;
+#else				/* __BIG_ENDIAN */
+		unsigned short revision:4;
+		unsigned short model:6;
+		unsigned short id:6;
+#endif				/* __BIG_ENDIAN */
+	} __packed bits;
+} __packed phy_id_low_t;
+
+/* -- autoneg_advertise  -- */
+
+#define PHY_AUTONEG_ADVERTISE 0x04
+
+/* -- link_partner_ability -- */
+
+#define PHY_LINK_PARTNER_ABILITY 0x05
+
+/* -- -- */
+
+#define MICREL_PHY_AUXILIARY_CONTROL_STATUS 0x1f
+
+typedef union {
+	unsigned short raw;
+
+	struct {
+		unsigned short:3;
+		unsigned short energy:1;
+		unsigned short force_link:1;
+		unsigned short power_saving:1;
+		unsigned short interrupt_level:1;
+		unsigned short jabber_enable:1;
+		unsigned short autoneg_indication:1;
+		unsigned short enable_pause:1;
+		unsigned short isolate:1;
+		unsigned short op_mode_indication:3;
+		unsigned short:2;
+	} bits;
+} micrel_phy_auxiliary_control_status_t;
+
+/*
+  Auto-negotiation Advertisement Values.
+*/
+
+#define PHY_AUTONEG_ADVERTISE_100FULL 0x101
+#define PHY_AUTONEG_ADVERTISE_100     0x081
+#define PHY_AUTONEG_ADVERTISE_10FULL  0x041
+#define PHY_AUTONEG_ADVERTISE_10      0x021
+
+#define PHY_ADDRESS_ 0x1e
+static int phy_address_ = PHY_ADDRESS_;
+
+#define UNKNOWN_PHY_ 0x0
+#define BCM5221_PHY_ 0x1
+#define MICREL_PHY_  0x2
+
+#ifndef CONFIG_ACP
+static int phy_type_ = UNKNOWN_PHY_;
+static int phy_link_(int);
+static int phy_scan_(void);
+static int phy_reset_(int);
+#endif
+
+static int phy_read_(int, int, unsigned short *);
+static int phy_write_(int, int, unsigned short);
+static int phy_speed_(int);
+static int phy_duplex_(int);
+static int phy_renegotiate_(int);
+static int phy_enable_(int);
+
+#endif				/* PHYLESS */
+
+/*
+  ======================================================================
+  ======================================================================
+  ======================================================================
+
+  NIC Interface
+
+  ======================================================================
+  ======================================================================
+  ======================================================================
+*/
+
+static int enable_(struct net_device *);
+
+/*
+  ======================================================================
+  ======================================================================
+  ======================================================================
+
+  Device Data Structures
+
+  ======================================================================
+  ======================================================================
+  ======================================================================
+*/
+
+typedef struct {
+
+#ifdef CONFIG_ACP
+
+	/* Word 0 */
+	unsigned long:24;
+	/* big endian to little endian */
+	unsigned long byte_swapping_on:1;
+	unsigned long error:1;
+	unsigned long interrupt_on_completion:1;
+	unsigned long end_of_packet:1;
+	unsigned long start_of_packet:1;
+	unsigned long write:1;
+	/* 00=Fill|01=Block|10=Scatter */
+	unsigned long transfer_type:2;
+
+	/* Word 1 */
+	unsigned long pdu_length:16;
+	unsigned long data_transfer_length:16;
+
+	/* Word 2 */
+	unsigned long target_memory_address;
+
+	/* Word 3 */
+	unsigned long host_data_memory_pointer;
+
+#else
+
+	/* Word 0 */
+	/* 00=Fill|01=Block|10=Scatter */
+	unsigned long transfer_type:2;
+	unsigned long write:1;
+	unsigned long start_of_packet:1;
+	unsigned long end_of_packet:1;
+	unsigned long interrupt_on_completion:1;
+	unsigned long error:1;
+	/* big endian to little endian */
+	unsigned long byte_swapping_on:1;
+	unsigned long:24;
+
+	/* Word 1 */
+	unsigned long data_transfer_length:16;
+	unsigned long pdu_length:16;
+
+	/* Word 2 */
+	unsigned long target_memory_address;
+
+	/* Word 3 */
+	unsigned long host_data_memory_pointer;
+
+#endif
+
+} __packed appnic_dma_descriptor_t;
+
+typedef union {
+
+	unsigned long raw;
+
+	struct {
+#ifdef CONFIG_ACP
+		unsigned long:11;
+		unsigned long generation_bit:1;
+		unsigned long offset:20;
+#else
+		unsigned long offset:20;
+		unsigned long generation_bit:1;
+		unsigned long:11;
+#endif
+	} __packed bits;
+
+} __packed appnic_queue_pointer_t;
+
+/*
+  ============================================
+  The Device Struction
+  ============================================
+*/
+
+typedef struct {
+
+	/* net_device */
+	struct net_device *device;
+
+	/* Addresses, Interrupt, and PHY stuff. */
+	unsigned long rx_base;
+	unsigned long tx_base;
+	unsigned long dma_base;
+	unsigned long interrupt;
+	unsigned long mdio_clock;
+	unsigned long phy_address;
+	unsigned long ad_value;
+	unsigned char mac_addr[6];
+
+#ifdef LSINET_NAPI
+	/* napi */
+	struct napi_struct napi;
+#endif				/* LSINET_ENABLE_NAPI */
+
+	/* statistics */
+	struct net_device_stats stats;
+
+	/*
+	   DMA-able memory.
+	 */
+
+	/* */
+	int dma_alloc_size;
+	void *dma_alloc;
+	dma_addr_t dma_alloc_dma;
+	int dma_alloc_offset;
+
+	/* tail pointers */
+	volatile appnic_queue_pointer_t *rx_tail;
+	dma_addr_t rx_tail_dma;
+	volatile appnic_queue_pointer_t *tx_tail;
+	dma_addr_t tx_tail_dma;
+
+	/* descriptors */
+	appnic_dma_descriptor_t *rx_desc;
+	dma_addr_t rx_desc_dma;
+	unsigned rx_num_desc;
+	appnic_dma_descriptor_t *tx_desc;
+	dma_addr_t tx_desc_dma;
+	unsigned tx_num_desc;
+
+	/* buffers */
+	unsigned rx_buf_sz;
+	unsigned rx_buf_per_desc;
+	void *rx_buf;
+	dma_addr_t rx_buf_dma;
+	unsigned tx_buf_sz;
+	unsigned tx_buf_per_desc;
+	void *tx_buf;
+	dma_addr_t tx_buf_dma;
+
+	/*
+	   The local pointers
+	 */
+
+	appnic_queue_pointer_t rx_tail_copy;
+	appnic_queue_pointer_t rx_head;
+
+	appnic_queue_pointer_t tx_tail_copy;
+	appnic_queue_pointer_t tx_head;
+
+	/*
+	   Polling Mode?
+	 */
+
+	int polling;
+
+	/*
+	   Spin Lock
+	 */
+
+	spinlock_t lock;
+	spinlock_t extra_lock;
+
+	/*
+	 * TEMP: semaphores for locking Tx/Rx operations
+	 */
+
+	struct mutex tx_sem;
+	struct mutex rx_sem;
+	struct mutex poll_sem;
+
+} appnic_device_t;
+
+#define DESCRIPTOR_GRANULARITY 64
+#define BUFFER_ALIGNMENT 64
+
+#define ALIGN64B(address) \
+((((unsigned long)(address) + (64UL - 1UL)) & ~(64UL - 1UL)))
+
+#define ALIGN64B_OFFSET(address) \
+(ALIGN64B(address) - (unsigned long)(address))
+
+#define APPNIC_NAME "appnic"
+
+/*
+  Overview
+  --------
+
+  Register offset decoding is as follows:
+
+  Bit(s) Description
+
+  16:15  define the Channel.  There is only one; therefore, 00.
+  14:12  define the MAC within the channel.  Only one so 000.
+  11:10  define the register "space" as follows:
+  00 = fast ethernet MAC
+  10 = global
+  11 = interrupt
+  9: 2  register
+  1: 0  always 00, 32 bit registers only.
+
+  Receive registers start at the base address.  Transmit registers start
+  at 0x20000 above the base address.  DMA start at a completely different
+  base address (in this case 0x8000000 above the base).
+
+*/
+
+/*
+  ======================================================================
+  ======================================================================
+  ======================================================================
+
+  Registers.
+
+  ======================================================================
+  ======================================================================
+  ======================================================================
+*/
+
+/* SMII Status ------------------------------------------------------ */
+
+#define APPNIC_RX_SMII_STATUS        (rx_base + 0x10)
+#define APPNIC_RX_SMII_STATUS_SPEED  0x01
+#define APPNIC_RX_SMII_STATUS_DUPLEX 0x02
+#define APPNIC_RX_SMII_STATUS_LINK   0x04
+#define APPNIC_RX_SMII_STATUS_JABBER 0x08
+#define APPNIC_RX_SMII_STATUS_FCD    0x10	/* False Carrier Detect */
+
+#define SMII_SPEED_100(smii_status_) \
+(0 != (smii_status_ & APPNIC_RX_SMII_STATUS_SPEED))
+#define SMII_DUPLEX(smii_status_) \
+(0 != (smii_status_ & APPNIC_RX_SMII_STATUS_DUPLEX))
+#define SMII_LINK(smii_status_) \
+(0 != (smii_status_ & APPNIC_RX_SMII_STATUS_LINK))
+#define SMII_JABBER(smii_status_) \
+(0 != (smii_status_ & APPNIC_RX_SMII_STATUS_JABBER))
+
+/* Receive Configuration -------------------------------------------- */
+
+#define APPNIC_RX_CONF          (rx_base + 0x004c)
+#define APPNIC_RX_CONF_ENABLE   0x0001
+/* Pass Any Packet */
+#define APPNIC_RX_CONF_PAP      0x0002
+#define APPNIC_RX_CONF_JUMBO9K  0x0008
+#define APPNIC_RX_CONF_STRIPCRC 0x0010
+/* Accept All MAC Types */
+#define APPNIC_RX_CONF_AMT      0x0020
+/* Accept Flow Control */
+#define APPNIC_RX_CONF_AFC      0x0040
+/* Enable VLAN */
+#define APPNIC_RX_CONF_VLAN     0x0200
+/* RX MAC Speed, 1=100MBS */
+#define APPNIC_RX_CONF_SPEED    0x0800
+/* 1=Duplex Mode */
+#define APPNIC_RX_CONF_DUPLEX   0x1000
+/* 1=Enable */
+#define APPNIC_RX_CONF_LINK     0x2000
+/* Determines the action taken when the FE MAC
+   receives an FC packet in FD mode.*/
+#define APPNIC_RX_CONF_RXFCE    0x4000
+/* Controls the insertion of FC packets
+   by the MAC transmitter. */
+#define APPNIC_RX_CONF_TXFCE    0x8000
+
+/* Receive Stat Overflow -------------------------------------------- */
+
+#define APPNIC_RX_STAT_OVERFLOW (rx_base + 0x278)
+
+/* Receive Stat Undersize ------------------------------------------- */
+
+#define APPNIC_RX_STAT_UNDERSIZE (rx_base + 0x280)
+
+/* Receive Stat Oversize -------------------------------------------- */
+
+#define APPNIC_RX_STAT_OVERSIZE (rx_base + 0x2b8)
+
+/* Receive Stat Multicast ------------------------------------------- */
+
+#define APPNIC_RX_STAT_MULTICAST (rx_base + 0x2d0)
+
+/* Receive Stat Packet OK ------------------------------------------- */
+
+#define APPNIC_RX_STAT_PACKET_OK (rx_base + 0x2c0)
+
+/* Receive Stat CRC Error ------------------------------------------- */
+
+#define APPNIC_RX_STAT_CRC_ERROR (rx_base + 0x2c8)
+
+/* Receive Stat Align Error ----------------------------------------- */
+
+#define APPNIC_RX_STAT_ALIGN_ERROR (rx_base + 0x2e8)
+
+/* Receive Ethernet Mode -------------------------------------------- */
+
+#define APPNIC_RX_MODE (rx_base + 0x0800)
+#define APPNIC_RX_MODE_ETHERNET_MODE_ENABLE 0x00001
+
+/* Receive Soft Reset ----------------------------------------------- */
+
+#define APPNIC_RX_SOFT_RESET (rx_base + 0x0808)
+#define APPNIC_RX_SOFT_RESET_MAC_0 0x00001
+
+/* Receive Internal Interrupt Control ------------------------------- */
+
+#define APPNIC_RX_INTERNAL_INTERRUPT_CONTROL (rx_base + 0xc00)
+#define APPNIC_RX_INTERNAL_INTERRUPT_CONTROL_MAC_0 0x1
+
+/* Receive External Interrupt Control ------------------------------- */
+
+#define APPNIC_RX_EXTERNAL_INTERRUPT_CONTROL (rx_base + 0xc04)
+#define APPNIC_RX_EXTERNAL_INTERRUPT_CONTROL_MAC_0_HIGH_LOW 0x10
+#define APPNIC_RX_EXTERNAL_INTERRUPT_CONTROL_MAC_0 0x1
+
+/* Receive Interrupt Status ----------------------------------------- */
+
+#define APPNIC_RX_INTERRUPT_STATUS (rx_base + 0xc20)
+#define APPNIC_RX_INTERRUPT_EXTERNAL_STATUS_MAC_0 0x10
+#define APPNIC_RX_INTERRUPT_INTERNAL_STATUS_MAC_0 0x1
+
+/* Transmit Watermark ----------------------------------------------- */
+
+#define APPNIC_TX_WATERMARK (tx_base + 0x18)
+#define APPNIC_TX_WATERMARK_TXCONFIG_DTPA_ASSERT 0x8000
+#define APPNIC_TX_WATERMARK_TXCONFIG_DTPA_DISABLE 0x4000
+#define APPNIC_TX_WATERMARK_TXCONFIG_DTPA_WATER_MARK_HIGH 0x3f00
+#define APPNIC_TX_WATERMARK_TXCONFIG_DTPA_WATER_MARK_LOW 0x3f
+
+/* Swap Source Address Registers ------------------------------------ */
+
+#define APPNIC_SWAP_SOURCE_ADDRESS_2 (tx_base + 0x20)
+#define APPNIC_SWAP_SOURCE_ADDRESS_1 (tx_base + 0x24)
+#define APPNIC_SWAP_SOURCE_ADDRESS_0 (tx_base + 0x28)
+
+/* Transmit Extended Configuration ---------------------------------- */
+
+#define APPNIC_TX_EXTENDED_CONF (tx_base + 0x30)
+#define APPNIC_TX_EXTENDED_CONF_TRANSMIT_COLLISION_WATERMARK_LEVEL 0xf000
+#define APPNIC_TX_EXTENDED_CONF_EXCESSIVE_DEFFERED_PACKET_DROP 0x200
+#define APPNIC_TX_EXTENDED_CONF_JUMBO9K 0x100
+#define APPNIC_TX_EXTENDED_CONF_LATE_COLLISION_WINDOW_COUNT 0xff
+
+/* Transmit Half Duplex Configuration ------------------------------- */
+
+#define APPNIC_TX_HALF_DUPLEX_CONF (tx_base + 0x34)
+#define APPNIC_TX_HALF_DUPLEX_CONF_RANDOM_SEED_VALUE 0xff
+
+/* Transmit Configuration ------------------------------------------- */
+
+#define APPNIC_TX_CONF (tx_base + 0x0050)
+#define APPNIC_TX_CONF_ENABLE_SWAP_SA 0x8000
+#define APPNIC_TX_CONF_LINK           0x2000
+#define APPNIC_TX_CONF_DUPLEX         0x1000
+#define APPNIC_TX_CONF_SPEED          0x0800
+#define APPNIC_TX_CONF_XBK_RST_RX_NTX 0x0600
+#define APPNIC_TX_CONF_IFG            0x01f0
+#define APPNIC_TX_CONF_APP_CRC_ENABLE 0x0004
+#define APPNIC_TX_CONF_PAD_ENABLE     0x0002
+#define APPNIC_TX_CONF_ENABLE         0x0001
+
+#define TX_CONF_SET_IFG(tx_configuration_, ifg_) do {\
+(tx_configuration_) &= ~APPNIC_TX_CONF_IFG; \
+(tx_configuration_) |= ((ifg_ & 0x1f) << 4); \
+} while (0);
+
+/* Transmit Time Value Configuration -------------------------------- */
+
+#define APPNIC_TX_TIME_VALUE_CONF (tx_base + 0x5c)
+#define APPNIC_TX_TIME_VALUE_CONF_PAUSE_VALUE 0xffff
+
+/* Transmit Stat Underrun ------------------------------------------- */
+
+#define APPNIC_TX_STAT_UNDERRUN (tx_base + 0x300)
+
+/* Transmit Stat Packet OK ------------------------------------------ */
+
+#define APPNIC_TX_STAT_PACKET_OK (tx_base + 0x318)
+
+/* Transmit Stat Undersize ------------------------------------------ */
+
+#define APPNIC_TX_STAT_UNDERSIZE (tx_base + 0x350)
+
+/* Transmit Status Late Collision ----------------------------------- */
+
+#define APPNIC_TX_STATUS_LATE_COLLISION (tx_base + 0x368)
+
+/* Transmit Status Excessive Collision ------------------------------ */
+
+#define APPNIC_TX_STATUS_EXCESSIVE_COLLISION (tx_base + 0x370)
+
+/* Transmit Stat Collision Above Watermark -------------------------- */
+
+#define APPNIC_TX_STAT_COLLISION_ABOVE_WATERMARK (tx_base + 0x380)
+
+/* Transmit Mode ---------------------------------------------------- */
+
+#define APPNIC_TX_MODE (tx_base + 0x800)
+#define APPNIC_TX_MODE_ETHERNET_MODE_ENABLE 0x1
+
+/* Transmit Soft Reset ---------------------------------------------- */
+
+#define APPNIC_TX_SOFT_RESET (tx_base + 0x808)
+#define APPNIC_TX_SOFT_RESET_MAC_0 0x1
+
+/* Transmit Interrupt Control --------------------------------------- */
+
+#define APPNIC_TX_INTERRUPT_CONTROL (tx_base + 0xc00)
+#define APPNIC_TX_INTERRUPT_CONTROL_MAC_0 0x1
+
+/* Transmit Interrupt Status ---------------------------------------- */
+
+#define APPNIC_TX_INTERRUPT_STATUS (tx_base + 0xc20)
+#define APPNIC_TX_INTERRUPT_STATUS_MAC_0 0x1
+
+/* */
+
+#define APPNIC_DMA_PCI_CONTROL (dma_base + 0x00)
+
+/* */
+
+#define APPNIC_DMA_CONTROL (dma_base + 0x08)
+
+/* DMA Interrupt Status --------------------------------------------- */
+
+#define APPNIC_DMA_INTERRUPT_STATUS (dma_base + 0x18)
+#define APPNIC_DMA_INTERRUPT_STATUS_RX 0x2
+#define APPNIC_DMA_INTERRUPT_STATUS_TX 0x1
+
+#define RX_INTERRUPT(dma_interrupt_status_) \
+(0 != (dma_interrupt_status_ & APPNIC_DMA_INTERRUPT_STATUS_RX))
+#define TX_INTERRUPT(dma_interrupt_status_) \
+(0 != (dma_interrupt_status_ & APPNIC_DMA_INTERRUPT_STATUS_TX))
+
+/* DMA Interrupt Enable --------------------------------------------- */
+
+#define APPNIC_DMA_INTERRUPT_ENABLE (dma_base + 0x1c)
+#define APPNIC_DMA_INTERRUPT_ENABLE_RECEIVE 0x2
+#define APPNIC_DMA_INTERRUPT_ENABLE_TRANSMIT 0x1
+
+/* DMA Receive Queue Base Address ----------------------------------- */
+
+#define APPNIC_DMA_RX_QUEUE_BASE_ADDRESS (dma_base + 0x30)
+
+/* DMA Receive Queue Size ------------------------------------------- */
+
+#define APPNIC_DMA_RX_QUEUE_SIZE (dma_base + 0x34)
+
+/* DMA Transmit Queue Base Address ---------------------------------- */
+
+#define APPNIC_DMA_TX_QUEUE_BASE_ADDRESS (dma_base + 0x38)
+
+/* DMA Transmit Queue Size ------------------------------------------ */
+
+#define APPNIC_DMA_TX_QUEUE_SIZE (dma_base + 0x3c)
+
+/* DMA Recevie Tail Pointer Address --------------------------------- */
+
+#define APPNIC_DMA_RX_TAIL_POINTER_ADDRESS (dma_base + 0x48)
+
+/* DMA Transmit Tail Pointer Address -------------------------------- */
+
+#define APPNIC_DMA_TX_TAIL_POINTER_ADDRESS (dma_base + 0x4c)
+
+/* DMA Receive Head Pointer ----------------------------------------- */
+
+#define APPNIC_DMA_RX_HEAD_POINTER (dma_base + 0x50)
+#define APPNIC_DMA_RX_HEAD_POINTER_GB      0x100000
+#define APPNIC_DMA_RX_HEAD_POINTER_POINTER 0x0fffff
+
+/* DMA Receive Tail Pointer Local Copy ------------------------------ */
+
+#define APPNIC_DMA_RX_TAIL_POINTER_LOCAL_COPY (dma_base + 0x54)
+#define APPNIC_DMA_RX_TAIL_POINTER_LOCAL_COPY_GB      0x100000
+#define APPNIC_DMA_RX_TAIL_POINTER_LOCAL_COPY_POINTER 0x0fffff
+
+/* DMA Transmit Head Pointer ---------------------------------------- */
+
+#define APPNIC_DMA_TX_HEAD_POINTER (dma_base + 0x58)
+#define APPNIC_DMA_TX_HEAD_POINTER_GB      0x100000
+#define APPNIC_DMA_TX_HEAD_POINTER_POINTER 0x0fffff
+
+/* DMA Transmit Tail Pointer Local Copy ----------------------------- */
+
+#define APPNIC_DMA_TX_TAIL_POINTER_LOCAL_COPY (dma_base + 0x5c)
+#define APPNIC_DMA_TX_TAIL_POINTER_LOCAL_COPY_GB      0x100000
+#define APPNIC_DMA_TX_TAIL_POINTER_LOCAL_COPY_POINTER 0x0fffff
+
+/*
+  ======================================================================
+  ======================================================================
+  ======================================================================
+
+  Access
+
+  N.B. On the APP, DMA transfers from the NIC MUST USE THE MEMORY
+  ALIAS AT 0x60000000!
+
+  ======================================================================
+  ======================================================================
+  ======================================================================
+*/
+
+#ifdef CONFIG_ACP
+
+#define readio(address) in_le32((u32 *)(address))
+
+#define writeio(value, address) out_le32((u32 *)(address), (value))
+
+static inline void
+readdescriptor(unsigned long address, appnic_dma_descriptor_t *descriptor)
+{
+	unsigned long *from = (unsigned long *) address;
+	unsigned long *to = (unsigned long *) descriptor;
+	*to++ = swab32(*from++);
+	*to++ = swab32(*from++);
+	*to++ = swab32(*from++);
+	*to++ = swab32(*from++);
+	return;
+}
+
+static inline void
+writedescriptor(unsigned long address,
+		const appnic_dma_descriptor_t *descriptor)
+{
+	unsigned long *to = (unsigned long *) address;
+	unsigned long *from = (unsigned long *) descriptor;
+	*to++ = swab32(*from++);
+	*to++ = swab32(*from++);
+	*to++ = swab32(*from++);
+	*to++ = swab32(*from++);
+	return;
+}
+
+static inline appnic_queue_pointer_t
+swab_queue_pointer(const appnic_queue_pointer_t *old_queue)
+{
+	appnic_queue_pointer_t new_queue;
+	new_queue.raw = swab32(old_queue->raw);
+	return new_queue;
+}
+
+#define SWAB_QUEUE_POINTER(pointer) \
+swab_queue_pointer((const appnic_queue_pointer_t *)(pointer))
+
+#else
+
+#define readio(address) readl((address))
+
+#define writeio(value, address) writel((value), (address))
+
+static inline void
+readdescriptor(unsigned long address, appnic_dma_descriptor_t *descriptor)
+{
+	memcpy(descriptor, (void *) address, sizeof(appnic_dma_descriptor_t));
+	return;
+}
+
+static inline void
+writedescriptor(unsigned long address,
+		const appnic_dma_descriptor_t *descriptor)
+{
+	memcpy((void *) address, descriptor, sizeof(appnic_dma_descriptor_t));
+	return;
+}
+
+static inline unsigned long
+swab_queue_pointer(unsigned long old_queue)
+{
+	return old_queue;
+}
+
+#endif
+
+#ifdef LOG_MAC_ACCESS
+
+static unsigned long
+read_mac_(unsigned int address)
+{
+
+	unsigned long value_ = readio(address);
+
+	switch (address & 0xfffff000) {
+
+	case rx_base:
+		printk("-MAC-   RX + 0x%04x => 0x%08lx\n", (address & 0x1fff),
+		       value_);
+		break;
+
+	case tx_base:
+		printk("-MAC-   TX + 0x%04x => 0x%08lx\n", (address & 0x1fff),
+		       value_);
+		break;
+
+	case dma_base:
+		printk("-MAC-  DMA + 0x%04x => 0x%08lx\n", (address & 0x1fff),
+		       value_);
+		break;
+
+	default:
+		ERROR_PRINT("ARGHHHHH!!!\n");
+		break;
+
+	}
+
+	return value_;
+
+}
+
+static void
+write_mac_(unsigned long value, unsigned int address)
+{
+
+	switch (address & 0xfffff000) {
+
+	case rx_base:
+		printk("-MAC-   RX + 0x%04x <= 0x%08lx\n", (address & 0x1fff),
+		       value);
+		break;
+
+	case tx_base:
+		printk("-MAC-   TX + 0x%04x <= 0x%08lx\n", (address & 0x1fff),
+		       value);
+		break;
+
+	case dma_base:
+		printk("-MAC-  DMA + 0x%04x <= 0x%08lx\n", (address & 0x1fff),
+		       value);
+		break;
+
+	default:
+		ERROR_PRINT("ARGHHHHH!!!\n");
+		break;
+
+	}
+
+	writeio(value, address);
+	return;
+
+}
+
+#else				/* ! LOG_MAC_ACCESS */
+
+#define read_mac_(address) readio((address))
+#define write_mac_(value, address) writeio((value), (address))
+
+#endif
+
+#ifndef PHYLESS
+#ifdef LOG_PHY_ACCESS
+
+static unsigned long
+read_phy_(unsigned int address)
+{
+
+	unsigned long value_ = readl(address);
+	printk("-PHY- HOST + 0x%04x => 0x%08lx\n", (address & 0xff), value_);
+	return value_;
+
+}
+
+static void
+write_phy_(unsigned long value, unsigned int address)
+{
+
+	printk("-PHY- HOST + 0x%04x <= 0x%08lx\n", (address & 0xff), value);
+	writel(value, address);
+	return;
+
+}
+
+#else				/* ! LOG_PHY_ACCESS */
+
+#define read_phy_(address) readl((address))
+#define write_phy_(value, address) writel(value, address)
+
+#endif
+#endif				/* PHYLESS */
+
+/*
+  ======================================================================
+  ======================================================================
+  ======================================================================
+
+  Module Information
+
+  ======================================================================
+  ======================================================================
+  ======================================================================
+*/
+
+MODULE_AUTHOR("John Jacques");
+MODULE_DESCRIPTION("Agere APP3xx ethernet driver");
+MODULE_LICENSE("GPL");
+
+/*
+  ----- Note On Buffer Space -----
+
+  Minimum number of descriptors is 64 for the receiver and 64 for the
+  transmitter; therefore, 2048 bytes (16 bytes each).
+  This driver uses the following parameters,
+  all of which may be set on the command line if this drivers is used
+  as a module.
+
+  - rx_num_desc : Number of receive descriptors.  This  must be a multiple of
+  64.
+  - tx_num_desc : Number of transmit descriptors.  This must be a multiple of
+  64.
+
+  The scheme used will be as follows:
+
+  - num_[rt]x_desc will be adjusted to be a multiple of 64 (if necessary).
+  - An skb (with the data area 64 byte aligned) will be allocated for each rx
+  descriptor.
+*/
+
+/*
+  Receiver
+*/
+
+int rx_num_desc = (CONFIG_LSI_NET_NUM_RX_DESC * DESCRIPTOR_GRANULARITY);
+module_param(rx_num_desc, int, 0);
+MODULE_PARM_DESC(rx_num_desc, "appnic : Number of receive descriptors");
+
+int rx_buf_sz = CONFIG_LSI_NET_RX_BUF_SZ;
+module_param(rx_buf_sz, int, 0);
+MODULE_PARM_DESC(rx_buf_sz, "appnic : Receive buffer size");
+
+/*
+  Transmitter
+*/
+
+int tx_num_desc = (CONFIG_LSI_NET_NUM_TX_DESC * DESCRIPTOR_GRANULARITY);
+module_param(tx_num_desc, int, 0);
+MODULE_PARM_DESC(tx_num_desc, "appnic : Number of receive descriptors");
+
+int tx_buf_sz = CONFIG_LSI_NET_TX_BUF_SZ;
+module_param(tx_buf_sz, int, 0);
+MODULE_PARM_DESC(tx_buf_sz, "Appnic : Receive buffer size");
+
+/*
+  Timeout, if a transmit takes longer than this
+  value in jiffies it has timed out.
+*/
+
+#define DEFAULT_TX_TIMEOUT 10
+
+int tx_timeout = DEFAULT_TX_TIMEOUT;
+module_param(tx_timeout, int, 0);
+MODULE_PARM_DESC(tx_timeout, "appnic : Transmit timeout (in jiffies)");
+
+/*
+  Only 1 device is possible...
+*/
+
+struct net_device *this_net_device;
+
+static unsigned long dropped_by_stack_;
+static unsigned long out_of_tx_descriptors_;
+static unsigned long transmit_interrupts_;
+#ifdef LSINET_NAPI
+static unsigned long receive_interrupts_;
+#endif
+
+#define APPNIC_TIMER_PERIOD 5
+#ifndef PHYLESS
+static void appnic_timer_handler_(unsigned long);
+static struct timer_list appnic_timer_;
+#endif				/* PHYLESS */
+
+/*
+  ======================================================================
+  ======================================================================
+  ======================================================================
+
+  Locking...
+
+  ======================================================================
+  ======================================================================
+  ======================================================================
+*/
+
+#ifdef CONFIG_SMP
+/*
+ * On SMP we have the following problem:
+ *
+ *      A = smc_hard_start_xmit()
+ *      B = smc_interrupt()
+ *
+ * A and B can never be executed simultaneously.  However, at least on UP,
+ * it is possible (and even desirable) for C to interrupt execution of
+ * A or B in order to have better RX reliability and avoid overruns.
+ * C, just like A and B, must have exclusive access to the chip and
+ * each of them must lock against any other concurrent access.
+ * Unfortunately this is not possible to have C suspend execution of A or
+ * B taking place on another CPU. On UP this is no an issue since A and B
+ * are run from softirq context and C from hard IRQ context, and there is
+ * no other CPU where concurrent access can happen.
+ * If ever there is a way to force at least B and C to always be executed
+ * on the same CPU then we could use read/write locks to protect against
+ * any other concurrent access and C would always interrupt B. But life
+ * isn't that easy in a SMP world...
+ */
+
+#define appnic_special_trylock(lock)	\
+	({									\
+		int __ret;						\
+		unsigned long flags;			\
+		local_irq_save(flags);			\
+		__ret = spin_trylock(lock);		\
+		if (!__ret)						\
+			local_irq_restore(flags);	\
+		__ret;							\
+	})
+#define appnic_special_lock(lock, flags)	spin_lock_irqsave(lock, flags)
+#define appnic_special_unlock(lock, flags)	spin_unlock_irqrestore(lock, flags)
+#else
+#define appnic_special_trylock(lock)            (1)
+#define appnic_special_lock(lock, flags)	do {} while (0)
+#define appnic_special_unlock(lock, flags)	do {} while (0)
+#endif
+
+/*
+  ======================================================================
+  ======================================================================
+  ======================================================================
+
+  Utility Functions
+
+  ======================================================================
+  ======================================================================
+  ======================================================================
+*/
+
+/*
+  ----------------------------------------------------------------------
+  clear_statistics_
+*/
+
+static void
+clear_statistics_(appnic_device_t *device)
+{
+
+	int waste_;
+
+	/*
+	   Clear memory.
+	 */
+
+	memset((void *) &(device->stats), 0, sizeof(struct net_device_stats));
+
+	/*
+	   Clear counters.
+	 */
+
+	waste_ = read_mac_(APPNIC_RX_STAT_PACKET_OK);	/* rx_packets */
+	waste_ = read_mac_(APPNIC_TX_STAT_PACKET_OK);	/* tx_packets */
+	/* rx_bytes kept by driver. */
+	/* tx_bytes kept by driver. */
+	/* rx_errors will be the sum of the rx errors available. */
+	/* tx_errors will be the sum of the tx errors available. */
+	/* rx_dropped (unable to allocate skb) will be maintained by the driver */
+	/* tx_dropped (unable to allocate skb) will be maintained by the driver */
+	/* multicast */
+	waste_ = read_mac_(APPNIC_RX_STAT_MULTICAST);
+	/* collisions will be the sum of the three following. */
+	waste_ = read_mac_(APPNIC_TX_STATUS_LATE_COLLISION);
+	waste_ = read_mac_(APPNIC_TX_STATUS_EXCESSIVE_COLLISION);
+	waste_ = read_mac_(APPNIC_TX_STAT_COLLISION_ABOVE_WATERMARK);
+	/* rx_length_errors will be the sum of the two following. */
+	waste_ = read_mac_(APPNIC_RX_STAT_UNDERSIZE);
+	waste_ = read_mac_(APPNIC_RX_STAT_OVERSIZE);
+	/* rx_over_errors (out of descriptors?) maintained by the driver. */
+	/* rx_crc_errors */
+	waste_ = read_mac_(APPNIC_RX_STAT_CRC_ERROR);
+	/* rx_frame_errors */
+	waste_ = read_mac_(APPNIC_RX_STAT_ALIGN_ERROR);
+	/* rx_fifo_errors */
+	waste_ = read_mac_(APPNIC_RX_STAT_OVERFLOW);
+	/* rx_missed will not be maintained. */
+	/* tx_aborted_errors will be maintained by the driver. */
+	/* tx_carrier_errors will not be maintained. */
+	/* tx_fifo_errors */
+	waste_ = read_mac_(APPNIC_TX_STAT_UNDERRUN);
+	/* tx_heartbeat_errors */
+	/* tx_window_errors */
+
+	/* rx_compressed will not be maintained. */
+	/* tx_compressed will not be maintained. */
+
+	/*
+	   That's all.
+	 */
+
+	return;
+
+}
+
+/*
+  ----------------------------------------------------------------------
+  get_hw_statistics_
+
+  -- NOTES --
+
+  1) The hardware clears the statistics registers after a read.
+*/
+
+static void
+get_hw_statistics_(appnic_device_t *device)
+{
+
+	/* tx_packets */
+	device->stats.tx_packets += read_mac_(APPNIC_TX_STAT_PACKET_OK);
+	/* multicast */
+	device->stats.multicast += read_mac_(APPNIC_RX_STAT_MULTICAST);
+	/* collision */
+	device->stats.collisions += read_mac_(APPNIC_TX_STATUS_LATE_COLLISION);
+	device->stats.collisions +=
+	    read_mac_(APPNIC_TX_STATUS_EXCESSIVE_COLLISION);
+	device->stats.collisions +=
+	    read_mac_(APPNIC_TX_STAT_COLLISION_ABOVE_WATERMARK);
+	/* rx_length_errors */
+	device->stats.rx_length_errors += read_mac_(APPNIC_RX_STAT_UNDERSIZE);
+	device->stats.rx_length_errors += read_mac_(APPNIC_RX_STAT_OVERSIZE);
+	/* tx_fifo_errors */
+	device->stats.tx_fifo_errors += read_mac_(APPNIC_TX_STAT_UNDERRUN);
+
+	/*
+	   Lock this section out so the statistics maintained by the driver
+	   don't get clobbered.
+	 */
+
+	{
+
+		unsigned long flags_;
+
+		spin_lock_irqsave(&device->lock, flags_);
+
+		device->stats.rx_errors +=
+		    (device->stats.rx_length_errors +
+		     device->stats.rx_crc_errors +
+		     device->stats.rx_frame_errors +
+		     device->stats.rx_fifo_errors +
+		     device->stats.rx_dropped + device->stats.rx_over_errors);
+		device->stats.rx_dropped = 0;
+		device->stats.rx_over_errors = 0;
+
+		device->stats.tx_errors +=
+		    (device->stats.tx_fifo_errors +
+		     device->stats.tx_aborted_errors);
+		device->stats.tx_aborted_errors = 0;
+
+		spin_unlock_irqrestore(&device->lock, flags_);
+
+	}
+
+	/*
+	   That's all.
+	 */
+
+	return;
+
+}
+
+/*
+  ----------------------------------------------------------------------
+  queue_initialized_
+
+  Returns the number of descriptors that are ready to receive packets
+  or are waiting to transmit packets.  (from tail to head).
+*/
+
+static int
+queue_initialized_(appnic_queue_pointer_t head,
+		   appnic_queue_pointer_t tail, int size)
+{
+	int initialized;
+
+	/* Calculate the number of descriptors currently initialized. */
+
+	if (head.bits.generation_bit == tail.bits.generation_bit) {
+
+		/* same generation */
+		initialized = (head.bits.offset - tail.bits.offset);
+
+	} else {
+
+		/* different generation */
+		initialized = head.bits.offset +
+		    (size * sizeof(appnic_dma_descriptor_t) -
+		     tail.bits.offset);
+
+	}
+
+	/* number of descriptors is offset / sizeof( a descriptor ) */
+	initialized /= sizeof(appnic_dma_descriptor_t);
+
+	return initialized;
+}
+
+/*
+  ----------------------------------------------------------------------
+  queue_uninitialzed_
+
+  Returns the number of unused/uninitialized descriptors.  (from head to tail).
+*/
+
+static int
+queue_uninitialized_(appnic_queue_pointer_t head,
+		     appnic_queue_pointer_t tail, int size)
+{
+
+	int allocated_;
+
+	/* calculate the number of descriptors currently unused/uninitialized */
+
+	if (head.bits.generation_bit == tail.bits.generation_bit) {
+
+		/* same generation. */
+		allocated_ =
+		    ((size * sizeof(appnic_dma_descriptor_t)) -
+		     head.bits.offset) + tail.bits.offset;
+
+	} else {
+
+		/* different generation. */
+		allocated_ = tail.bits.offset - head.bits.offset;
+
+	}
+
+	/* number of descriptors is offset / sizeof( a descriptor ). */
+	allocated_ /= sizeof(appnic_dma_descriptor_t);
+
+	/* that's all */
+	return allocated_;
+
+}
+
+/*
+  ----------------------------------------------------------------------
+  queue_increment_
+*/
+
+static void
+queue_increment_(appnic_queue_pointer_t *queue, int number_of_descriptors)
+{
+
+	queue->bits.offset += sizeof(appnic_dma_descriptor_t);
+
+	if ((number_of_descriptors * sizeof(appnic_dma_descriptor_t)) ==
+	    queue->bits.offset) {
+
+		queue->bits.offset = 0;
+		queue->bits.generation_bit =
+		    (0 == queue->bits.generation_bit) ? 1 : 0;
+
+	}
+
+	return;
+
+}
+
+/*
+  ----------------------------------------------------------------------
+  queue_decrement_
+*/
+
+static void
+queue_decrement_(appnic_queue_pointer_t *queue, int number_of_descriptors)
+{
+
+	if (0 == queue->bits.offset) {
+
+		queue->bits.offset =
+		    ((number_of_descriptors -
+		      1) * sizeof(appnic_dma_descriptor_t));
+		queue->bits.generation_bit =
+		    (0 == queue->bits.generation_bit) ? 1 : 0;
+
+	} else {
+
+		queue->bits.offset -= sizeof(appnic_dma_descriptor_t);
+
+	}
+
+	return;
+
+}
+
+/*
+  ----------------------------------------------------------------------
+  appnic_timer_handler_
+*/
+
+#ifndef PHYLESS
+
+static void
+appnic_timer_handler_(unsigned long __opaque)
+{
+
+	struct net_device *device_ = (struct net_device *) __opaque;
+
+	PHY_DEBUG_PRINT("Handling Timer Expiration.\n");
+	enable_(device_);
+	appnic_timer_.expires = jiffies + (APPNIC_TIMER_PERIOD * HZ);
+	add_timer(&appnic_timer_);
+
+}
+
+#endif
+
+/*
+  ----------------------------------------------------------------------
+  enable_
+
+  -- NOTES --
+
+  1) Does not change the default values in the extended and
+  half-duplex configuration registers.
+*/
+
+static int
+enable_(struct net_device *device)
+{
+
+#ifndef PHYLESS
+
+	int return_code_ = 1;
+	int carrier_state_ = 0;
+	unsigned long rx_configuration_;
+	unsigned long tx_configuration_ = 0;
+	phy_status_t phy_status_;
+
+	rx_configuration_ =
+	    (APPNIC_RX_CONF_STRIPCRC |
+	     APPNIC_RX_CONF_RXFCE | APPNIC_RX_CONF_TXFCE);
+	tx_configuration_ =
+	    (APPNIC_TX_CONF_ENABLE_SWAP_SA |
+	     APPNIC_TX_CONF_APP_CRC_ENABLE | APPNIC_TX_CONF_PAD_ENABLE);
+	TX_CONF_SET_IFG(tx_configuration_, 0xf);
+
+	DEBUG_PRINT("Enabling the interface.\n");
+
+	/*
+	   Setup the receive and transmit configuration registers (using smii
+	   status to set speed/duplex and check the link status).
+	 */
+
+	if ((0 == phy_read_(phy_address_, PHY_STATUS, &phy_status_.raw)) &&
+	    (0 == phy_read_(phy_address_, PHY_STATUS, &phy_status_.raw))) {
+
+		PHY_DEBUG_PRINT("phy_status_.raw=0x%x\n", phy_status_.raw);
+
+		if (1 == phy_status_.bits.autoneg_comp) {
+
+			if (1 == phy_status_.bits.link_status) {
+
+				if (1 == phy_speed_(phy_address_)) {
+
+					rx_configuration_ |=
+					    APPNIC_RX_CONF_SPEED;
+					tx_configuration_ |=
+					    APPNIC_TX_CONF_SPEED;
+
+				}
+
+				if (1 == phy_duplex_(phy_address_)) {
+
+					rx_configuration_ |=
+					    APPNIC_RX_CONF_DUPLEX;
+					tx_configuration_ |=
+					    APPNIC_TX_CONF_DUPLEX;
+
+				}
+
+				rx_configuration_ |=
+				    (APPNIC_RX_CONF_ENABLE |
+				     APPNIC_RX_CONF_LINK);
+				tx_configuration_ |=
+				    (APPNIC_TX_CONF_LINK |
+				     APPNIC_TX_CONF_ENABLE);
+				return_code_ = 0;
+				carrier_state_ = 1;
+
+			} else {
+
+				netif_carrier_off(device);
+
+			}
+
+		} else {
+
+			netif_carrier_off(device);
+
+		}
+
+	} else {
+
+		ERROR_PRINT("phy_read_( ) failed!\n");
+
+	}
+
+#else				/* PHYLESS */
+
+	int return_code_ = 1;
+	int carrier_state_ = 0;
+	unsigned long rx_configuration_;
+	unsigned long tx_configuration_ = 0;
+
+	rx_configuration_ = APPNIC_RX_CONF_STRIPCRC;
+	tx_configuration_ =
+	    (APPNIC_TX_CONF_ENABLE_SWAP_SA |
+	     APPNIC_TX_CONF_APP_CRC_ENABLE | APPNIC_TX_CONF_PAD_ENABLE);
+	TX_CONF_SET_IFG(tx_configuration_, 0xf);
+
+	/*
+	   100/Half
+	 */
+	rx_configuration_ |=
+	    (APPNIC_RX_CONF_ENABLE | APPNIC_RX_CONF_LINK |
+	     APPNIC_RX_CONF_SPEED);
+	tx_configuration_ |=
+	    (APPNIC_TX_CONF_ENABLE | APPNIC_TX_CONF_LINK |
+	     APPNIC_TX_CONF_SPEED);
+
+	return_code_ = 0;
+	carrier_state_ = 1;
+
+#endif				/* PHYLESS */
+
+	if (rx_configuration_ != read_mac_(APPNIC_RX_CONF))
+		write_mac_(rx_configuration_, APPNIC_RX_CONF);
+
+	if (tx_configuration_ != read_mac_(APPNIC_TX_CONF))
+		write_mac_(tx_configuration_, APPNIC_TX_CONF);
+
+	if (0 != carrier_state_)
+		netif_carrier_on(device);
+	else
+		netif_carrier_off(device);
+
+	return return_code_;
+
+}
+
+/*
+  ----------------------------------------------------------------------
+  disable_
+*/
+
+static void
+disable_(void)
+{
+
+	unsigned long tx_configuration_;
+	unsigned long rx_configuration_;
+
+	DEBUG_PRINT("Disabling the interface.\n");
+
+	rx_configuration_ = read_mac_(APPNIC_RX_CONF);
+	rx_configuration_ &= ~APPNIC_RX_CONF_ENABLE;
+	write_mac_(rx_configuration_, APPNIC_RX_CONF);
+
+	tx_configuration_ = read_mac_(APPNIC_TX_CONF);
+	tx_configuration_ &= ~APPNIC_TX_CONF_ENABLE;
+	write_mac_(tx_configuration_, APPNIC_TX_CONF);
+
+	/* that's all. */
+	return;
+
+}
+
+void
+disable_nic_(void)
+{
+
+	disable_();
+
+}
+
+/*
+  ======================================================================
+  ======================================================================
+  ======================================================================
+  PHY interface (BCM5221)
+  ======================================================================
+  ======================================================================
+  ======================================================================
+*/
+
+#ifndef PHYLESS
+
+/*
+  ----------------------------------------------------------------------
+  phy_read_
+
+  Returns -1 if unsuccessful, the (short) value otherwise.
+*/
+
+static int
+phy_read_(int phy, int reg, unsigned short *value)
+{
+	return acp_mdio_read(phy, reg, value);
+}
+
+/*
+  ----------------------------------------------------------------------
+  phy_write_
+*/
+
+static int
+phy_write_(int phy, int reg, unsigned short value)
+{
+	return acp_mdio_write(phy, reg, value);
+}
+
+#ifndef CONFIG_ACP
+/*
+  ----------------------------------------------------------------------
+  phy_link_
+
+  Returns the link status (1=link up, 0=link down) or an error (-1).
+*/
+
+static int
+phy_link_(int phy)
+{
+	phy_status_t status;
+
+	phy_read_(phy, PHY_STATUS, &status.raw);
+	phy_read_(phy, PHY_STATUS, &status.raw);
+
+	return status.bits.link_status;
+}
+#endif
+
+/*
+  ----------------------------------------------------------------------
+  phy_speed_
+
+  Returns the speed (1=100, 0=10) or an error (-1).
+*/
+
+static int
+phy_speed_(int phy)
+{
+	micrel_phy_auxiliary_control_status_t aux;
+
+	phy_read_(phy, MICREL_PHY_AUXILIARY_CONTROL_STATUS, &aux.raw);
+	switch ((aux.bits.op_mode_indication & 3)) {
+	case 2:
+		return 1;
+		break;
+	case 1:
+		return 0;
+		break;
+	default:
+		break;
+	}
+
+	return -1;
+}
+
+/*
+  ----------------------------------------------------------------------
+  phy_duplex_
+
+  Returns duplex status (1=full duplex, 0=half duplex) or an error (-1).
+*/
+
+static int
+phy_duplex_(int phy)
+{
+	micrel_phy_auxiliary_control_status_t aux;
+
+	phy_read_(phy, MICREL_PHY_AUXILIARY_CONTROL_STATUS, &aux.raw);
+
+	return (aux.bits.op_mode_indication >> 2) & 0x1;
+}
+
+#ifndef CONFIG_ACP
+/*
+  ----------------------------------------------------------------------
+  phy_reset_
+*/
+
+static int
+phy_reset_(int phy)
+{
+	phy_control_t control;
+	int retries = 10;
+
+	phy_read_(phy, PHY_CONTROL, &control.raw);
+	control.bits.soft_reset = 1;
+	phy_write_(phy, PHY_CONTROL, control.raw);
+
+	do {
+		phy_read_(phy, PHY_CONTROL, &control.raw);
+		--retries;
+	} while ((0 < retries) && (0 != control.bits.soft_reset));
+
+	if (0 != control.bits.soft_reset) {
+		printk("phy_reset( %d ) failed.\n", phy);
+		return -1;
+	}
+
+	return 0;
+}
+#endif
+
+/*
+  ----------------------------------------------------------------------
+  phy_renegotiate_
+*/
+
+static int
+phy_renegotiate_(int phy)
+{
+	phy_control_t control;
+	phy_status_t status;
+	int autoneg_retries = 4;
+	int autoneg_complete_retries = 8;
+
+	printk("Initiating Auto Negotiation");
+
+	do {
+		phy_read_(phy, PHY_CONTROL, &control.raw);
+		control.bits.restart_autoneg = 1;
+		phy_write_(phy, PHY_CONTROL, control.raw);
+
+		do {
+			udelay(500000);
+			phy_read_(phy, PHY_STATUS, &status.raw);
+		} while ((0 < --autoneg_complete_retries) &&
+			 (0 == status.bits.autoneg_comp));
+
+		if (0 != status.bits.autoneg_comp)
+			break;
+
+		printk(".");
+	} while (0 < --autoneg_retries);
+
+	printk("\n");
+
+	if (0 == status.bits.autoneg_comp) {
+		printk("Auto Negotiation Failed\n");
+		return -1;
+	}
+
+	printk("Auto Negotiation Succeeded\n");
+	return 0;
+}
+
+/*
+  ----------------------------------------------------------------------
+  phy_enable_
+*/
+
+extern int ubootenv_get(const char *, char *);
+
+static int
+phy_enable_(int phy)
+{
+
+#ifdef CONFIG_ACP
+	unsigned short ad_value;
+	phy_address_ = 0x1e;
+
+	ad_value = PHY_AUTONEG_ADVERTISE_100FULL |
+	    PHY_AUTONEG_ADVERTISE_100 |
+	    PHY_AUTONEG_ADVERTISE_10FULL | PHY_AUTONEG_ADVERTISE_10;
+
+	if (0 != phy_write_(phy_address_, PHY_AUTONEG_ADVERTISE, ad_value))
+		return -1;
+
+	phy_renegotiate_(phy_address_);
+#else
+	/*
+	   Set up the MDIO clock.
+	 */
+
+	{
+
+		char mdio_clock_speed_string_[256];
+		unsigned long mdio_clock_speed_;
+		unsigned long mdio_divisor_;
+#ifdef CONFIG_LSI_UBOOTENV
+		if (0 != ubootenv_get("mdio_clock", mdio_clock_speed_string_)) {
+
+			mdio_clock_speed_ = 1250000;
+
+		} else {
+
+			mdio_clock_speed_ =
+			    simple_strtoul(mdio_clock_speed_string_, NULL, 0);
+
+		}
+#else
+		mdio_clock_speed_ = 1250000;
+#endif
+
+#ifdef CONFIG_ARCH_APP3K
+		mdio_divisor_ = ((get_core_speed() / 2) / mdio_clock_speed_);
+#else
+		mdio_divisor_ = (get_core_speed() / mdio_clock_speed_);
+#endif
+
+		printk("Setting the MDIO clock to %lu Hz (divisor=%lu)\n",
+		       mdio_clock_speed_, mdio_divisor_);
+		writel(mdio_divisor_, MDIO_CLK_);
+
+	}
+
+	/*
+	   Get the PHY address.
+	 */
+
+	{
+
+		char phy_address_string_[256];
+#ifdef CONFIG_LSI_UBOOTENV
+		if (0 != ubootenv_get("phy_address", phy_address_string_)) {
+
+			phy_address_ = phy_scan_();
+
+		} else {
+
+			phy_address_ =
+			    simple_strtoul(phy_address_string_, NULL, 0);
+
+		}
+#else
+		phy_address_ = phy_scan_();
+#endif
+		if (31 < phy_address_ || 0 > phy_address_) {
+
+			ERROR_PRINT("Unable to get valid PHY address!\n");
+			return -EBUSY;
+
+		}
+
+	}
+
+	/*
+	   Get PHY type.
+	 */
+
+	{
+
+		phy_id_high_t phy_id_high_;
+		phy_id_low_t phy_id_low_;
+
+		if (0 !=
+		    phy_read_(phy_address_, PHY_ID_HIGH_, &phy_id_high_.raw)) {
+
+			TRACE_ENDING();
+			return -1;
+
+		}
+
+		if (0 != phy_read_(phy_address_, PHY_ID_LOW_, &phy_id_low_.raw)) {
+
+			TRACE_ENDING();
+			return -1;
+
+		}
+
+		if ((PHY_ID_HIGH_ID == phy_id_high_.bits.id) &&
+		    (BC_PHY_ID_LOW_ID_ == phy_id_low_.bits.id) &&
+		    (BC_PHY_ID_LOW_MODEL_ == phy_id_low_.bits.model)) {
+
+			phy_type_ = BCM5221_PHY_;
+			printk("Broadcomm 5221 PHY at 0x%x\n", phy_address_);
+
+		} else if ((M_PHY_ID_HIGH_ID_ == phy_id_high_.bits.id) &&
+			   (M_PHY_ID_LOW_ID_ == phy_id_low_.bits.id)) {
+
+			phy_type_ = MICREL_PHY_;
+			printk("Micrel PHY at 0x%x, Model 0x%x\n",
+			       phy_address_, phy_id_low_.bits.model);
+
+		} else {
+
+			phy_type_ = UNKNOWN_PHY_;
+			printk("Unknown PHY at 0x%x.  0x%x 0x%x 0x%x\n",
+			       phy_address_, phy_id_high_.bits.id,
+			       phy_id_low_.bits.id, phy_id_low_.bits.model);
+
+		}
+
+	}
+
+	if (-1 != phy_address_) {
+
+		int link_status_retries_ = 10;
+		phy_status_t phy_status_;
+		char ad_value_string_[40];
+		unsigned short ad_value_;
+
+		DEBUG_PRINT("Initializing PHY at 0x%x\n", phy_address_);
+
+		if (0 != phy_reset_(phy_address_))
+			return -1;
+
+		/*
+		   0x1e1 - 10/100 half/full
+		   0xe1 - 100 half, 10 half/full
+		   0x61 - 10 half/full
+		   0x41 - 10 half
+		 */
+#ifdef CONFIG_LSI_UBOOTENV
+		if (0 != ubootenv_get("ad_value", ad_value_string_)) {
+#endif
+			if ((is_asic) &&
+			    (0 == (APP3XX_REVISION_REGISTER & 0x1f))) {
+
+				/* 10M does not work on ASIC v1.0 */
+				ad_value_ = 0x0181;
+
+			} else {
+
+				/* For FGPA loads and any ASIC after v1.0, default to 10 full/half */
+				ad_value_ = 0x061;
+
+			}
+
+			WARN_PRINT("ad_value not set, using 0x%x\n", ad_value_);
+#ifdef CONFIG_LSI_UBOOTENV
+		} else {
+
+			ad_value_ = simple_strtoul(ad_value_string_, NULL, 0);
+
+		}
+#endif
+
+		if (0 != phy_write_(phy_address_, PHY_AUTONEG_ADVERTISE_,
+				    ad_value_)) {
+
+			TRACE_ENDING();
+			return -1;
+
+		}
+
+		if (0 != phy_renegotiate_(phy_address_))
+			WARN_PRINT("PHY: Auto Negotiation Failed.\n");
+
+		do {
+			if (0 !=
+			    phy_read_(phy_address_, PHY_STATUS,
+				      &phy_status_.raw)) {
+
+				return -1;
+
+			}
+
+			mdelay(10);
+			--link_status_retries_;
+
+		} while ((0 == phy_status_.bits.link_status) &&
+			 (0 < link_status_retries_));
+
+		if (0 == phy_status_.bits.link_status) {
+
+			WARN_PRINT("PHY: link down\n");
+
+		} else {
+
+			printk("PHY: link=%s speed=%d Mbs duplex=%s\n",
+			       (1 == phy_link_(phy_address_)) ? "up" : "down",
+			       (1 == phy_speed_(phy_address_)) ? 100 : 10,
+			       (1 ==
+				phy_duplex_(phy_address_)) ? "full" : "half");
+
+		}
+
+	}
+#endif
+
+	/*
+	   That's all
+	 */
+
+	return 0;
+
+}
+
+#endif				/* PHYLESS */
+
+/*
+  ======================================================================
+  ======================================================================
+  ======================================================================
+
+  Linux Network Driver Interface
+
+  ======================================================================
+  ======================================================================
+  ======================================================================
+*/
+
+/*
+  ----------------------------------------------------------------------
+  handle_transmit_interrupt_
+*/
+
+static void
+handle_transmit_interrupt_(struct net_device *device)
+{
+
+	appnic_device_t *dev_ = netdev_priv(device);
+
+	TRACE_BEGINNING();
+	DEBUG_PRINT("tail=0x%lx tail_copy=0x%lx head=0x%lx\n",
+		    dev_->tx_tail->raw, dev_->tx_tail_copy.raw,
+		    dev_->tx_head.raw);
+
+	/*
+	   The hardware's tail pointer should be one descriptor (or more)
+	   ahead of software's copy.
+	 */
+
+	while (0 < queue_initialized_(SWAB_QUEUE_POINTER(dev_->tx_tail),
+				      dev_->tx_tail_copy, dev_->tx_num_desc)) {
+		queue_increment_(&dev_->tx_tail_copy, dev_->tx_num_desc);
+	}
+
+	DEBUG_PRINT("tail=0x%lx tail_copy=0x%lx head=0x%lx\n",
+		    dev_->tx_tail->raw, dev_->tx_tail_copy.raw,
+		    dev_->tx_head.raw);
+	TRACE_ENDING();
+
+	return;
+
+}
+
+/*
+  ----------------------------------------------------------------------
+  lsinet_rx_packet
+*/
+
+static void
+lsinet_rx_packet(struct net_device *device)
+{
+	appnic_device_t *adapter = netdev_priv(device);
+	appnic_dma_descriptor_t descriptor;
+	struct sk_buff *sk_buff_;
+
+#ifdef __APPNIC_C_PROFILE__
+	unsigned long ts0_ = 0;
+	unsigned long ts1_ = 0;
+	unsigned long ts2_ = 0;
+	unsigned long ts3_ = 0;
+	int sent_up = 0;
+	ts0_ = (0xffffffff - readl((TIMER7_BASE + TIMER_n_VALUE)));
+#endif				/* __APPNIC_C_PROFILE__ */
+
+	/* TEMP HACK:
+	 * should use down_interruptible
+	 */
+	spin_lock(&adapter->extra_lock);
+	TRACE_BEGINNING();
+	DEBUG_PRINT("head=0x%lx tail=0x%lx tail_copy=0x%lx\n",
+		    adapter->rx_head.raw, adapter->rx_tail->raw,
+		    adapter->rx_tail_copy.raw);
+	readdescriptor(((unsigned long) adapter->rx_desc +
+			adapter->rx_tail_copy.bits.offset), &descriptor);
+
+	sk_buff_ = dev_alloc_skb(1600);
+	if ((struct sk_buff *) 0 != sk_buff_) {
+		unsigned bytes_copied_ = 0;
+		unsigned error_ = 0;
+		int return_code_;
+		unsigned long ok_, overflow_, crc_, align_;
+
+#ifdef __APPNIC_C_PROFILE__
+		ts1_ = (0xffffffff - readl((TIMER7_BASE + TIMER_n_VALUE)));
+#endif				/* __APPNIC_C_PROFILE__ */
+
+		ok_ = read_mac_(APPNIC_RX_STAT_PACKET_OK);
+		overflow_ = read_mac_(APPNIC_RX_STAT_OVERFLOW);
+		crc_ = read_mac_(APPNIC_RX_STAT_CRC_ERROR);
+		align_ = read_mac_(APPNIC_RX_STAT_ALIGN_ERROR);
+
+		/*
+		   Copy the received packet into the skb.
+		 */
+
+		while (0 <
+		       queue_initialized_(SWAB_QUEUE_POINTER(adapter->rx_tail),
+					  adapter->rx_tail_copy,
+					  adapter->rx_num_desc)) {
+			/*TRACER_POST( "tail_copy=0x%x", adapter->rx_tail_copy.raw ); */
+#ifdef PRELOAD_RX_BUFFERS
+			{
+				unsigned char *buffer_;
+				buffer_ =
+				    skb_put(sk_buff_, descriptor.pdu_length);
+				memcmp(buffer_, buffer_, descriptor.pdu_length);
+				memcpy((void *) buffer_,
+				       (void *) (descriptor.
+						 host_data_memory_pointer +
+						 adapter->dma_alloc_offset),
+				       descriptor.pdu_length);
+			}
+#else				/* PRELOAD_RX_BUFFERS */
+			memcpy((void *)
+			       skb_put(sk_buff_, descriptor.pdu_length),
+			       (void *) (descriptor.host_data_memory_pointer +
+					 adapter->dma_alloc_offset),
+			       descriptor.pdu_length);
+#endif				/* PRELOAD_RX_BUFFERS */
+			bytes_copied_ += descriptor.pdu_length;
+			descriptor.data_transfer_length =
+			    adapter->rx_buf_per_desc;
+			writedescriptor(((unsigned long) adapter->rx_desc +
+					 adapter->rx_tail_copy.bits.offset),
+					&descriptor);
+			if (0 != descriptor.error)
+				error_ = 1;
+
+			queue_increment_(&adapter->rx_tail_copy,
+					 adapter->rx_num_desc);
+			if (0 != descriptor.end_of_packet)
+				break;
+
+			readdescriptor(((unsigned long) adapter->rx_desc +
+					adapter->rx_tail_copy.bits.offset),
+				       &descriptor);
+		}
+
+		if (0 == descriptor.end_of_packet) {
+
+			ERROR_PRINT("No end of packet! %lu/%lu/%lu/%lu\n",
+				    ok_, overflow_, crc_, align_);
+			BUG();
+			dev_kfree_skb(sk_buff_);
+
+		} else {
+
+			if (0 == error_) {
+
+				struct ethhdr *ethhdr_ =
+				    (struct ethhdr *) sk_buff_->data;
+				unsigned char broadcast_[] = {
+					0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+				unsigned char multicast_[] = {0x01, 0x00};
+
+				LSINET_COUNTS_INC(LSINET_COUNTS_RX_GOOD);
+
+				if ((0 ==
+				     memcmp((const void *)
+					    &(ethhdr_->h_dest[0]),
+					    (const void *) &(device->
+							     dev_addr[0]),
+					    sizeof(ethhdr_->h_dest)))
+				    || (0 ==
+					memcmp((const void *)
+					       &(ethhdr_->h_dest[0]),
+					       (const void *) &(broadcast_[0]),
+					       sizeof(ethhdr_->h_dest)))
+				    || (0 ==
+					memcmp((const void *)
+					       &(ethhdr_->h_dest[0]),
+					       (const void *) &(multicast_[0]),
+					       sizeof(multicast_)))) {
+
+#ifdef __APPNIC_C_PROFILE__
+					if (bytes_copied_ > rx_packet_size_max_) {
+						rx_packet_size_max_ =
+						    bytes_copied_;
+					} else if (bytes_copied_ <
+						   rx_packet_size_min_) {
+						rx_packet_size_min_ =
+						    bytes_copied_;
+					}
+					total_rx_bytes_ += bytes_copied_;
+
+					total_rx_packets_sent_up_++;
+					sent_up = 1;
+
+					ts2_ =
+					    (0xffffffff -
+					     readl((TIMER7_BASE +
+						    TIMER_n_VALUE)));
+#endif				/* __APPNIC_C_PROFILE__ */
+
+					adapter->stats.rx_bytes +=
+					    bytes_copied_;
+					++adapter->stats.rx_packets;
+					sk_buff_->dev = device;
+					sk_buff_->protocol =
+					    eth_type_trans(sk_buff_, device);
+#ifdef LSINET_NAPI
+					LSINET_COUNTS_INC
+					    (LSINET_COUNTS_RX_SENT);
+					return_code_ =
+					    netif_receive_skb(sk_buff_);
+#else
+					LSINET_COUNTS_INC
+					    (LSINET_COUNTS_RX_SENT);
+					return_code_ = netif_rx(sk_buff_);
+#endif
+
+					if (NET_RX_DROP == return_code_) {
+
+						++dropped_by_stack_;
+						LSINET_COUNTS_INC
+						    (LSINET_COUNTS_RX_DRPD);
+					}
+
+				} else {
+
+					dev_kfree_skb(sk_buff_);
+
+				}
+
+			} else {
+
+				LSINET_COUNTS_INC(LSINET_COUNTS_RX_ERR);
+
+				dev_kfree_skb(sk_buff_);
+
+				if (0 != overflow_)
+					++adapter->stats.rx_fifo_errors;
+				else if (0 != crc_)
+					++adapter->stats.rx_crc_errors;
+				else if (0 != align_)
+					++adapter->stats.rx_frame_errors;
+			}
+
+		}
+
+	} else {
+
+		ERROR_PRINT("dev_alloc_skb( ) failed!  Dropping packet.\n");
+
+	}
+
+	DEBUG_PRINT("head=0x%lx tail=0x%lx tail_copy=0x%lx\n",
+		    adapter->rx_head.raw, adapter->rx_tail->raw,
+		    adapter->rx_tail_copy.raw);
+	TRACE_ENDING();
+
+#ifdef __APPNIC_C_PROFILE__
+
+	app3xx_profile_time_calc(ts0_, ts1_,
+				 recv_t1_min_, recv_t1_max_, recv_t1_tot_);
+	/*
+	 * only calculate stats for packets that were sent up to the stack
+	 */
+	if (sent_up) {
+		ts3_ = (0xffffffff - readl((TIMER7_BASE + TIMER_n_VALUE)));
+
+		app3xx_profile_time_calc(ts1_, ts2_,
+					 recv_t2_min_, recv_t2_max_,
+					 recv_t2_tot_);
+		app3xx_profile_time_calc(ts2_, ts3_, recv_t3_min_, recv_t3_max_,
+					 recv_t3_tot_);
+	}
+#endif				/* __APPNIC_C_PROFILE__ */
+
+	/* TEMP */
+	spin_unlock(&adapter->extra_lock);
+	/* that's all */
+	return;
+
+}
+
+/*
+  ============================================
+  lsinet_rx_packets
+*/
+
+static int
+lsinet_rx_packets(struct net_device *device, int max)
+{
+	appnic_device_t *adapter = netdev_priv(device);
+	appnic_queue_pointer_t queue;
+	int updated_head_pointer = 0;
+	int packets = 0;
+
+	queue.raw = adapter->rx_tail_copy.raw;
+
+	/* Receive Packets */
+
+	while (0 < queue_initialized_(SWAB_QUEUE_POINTER(adapter->rx_tail),
+				      queue, adapter->rx_num_desc)) {
+		appnic_dma_descriptor_t descriptor;
+
+		readdescriptor(((unsigned long) adapter->rx_desc +
+				queue.bits.offset), &descriptor);
+
+		if (0 != descriptor.end_of_packet) {
+#ifdef __APPNIC_C_PROFILE__
+			++packets_handled_;
+#endif				/* __APPNIC_C_PROFILE__ */
+			LSINET_COUNTS_INC(LSINET_COUNTS_RX_PKT);
+			lsinet_rx_packet(device);
+			++packets;
+			queue.raw = adapter->rx_tail_copy.raw;
+
+			if (-1 != max) {
+				if (packets == max)
+					break;
+			}
+		} else {
+			queue_increment_(&queue, adapter->rx_num_desc);
+		}
+	}
+
+	/* Update the Head Pointer */
+
+	while (1 < queue_uninitialized_(adapter->rx_head, adapter->rx_tail_copy,
+					adapter->rx_num_desc)) {
+
+		appnic_dma_descriptor_t descriptor;
+
+		readdescriptor(((unsigned long) adapter->rx_desc +
+				adapter->rx_head.bits.offset), &descriptor);
+		descriptor.data_transfer_length = adapter->rx_buf_per_desc;
+		descriptor.write = 1;
+		descriptor.pdu_length = 0;
+		descriptor.start_of_packet = 0;
+		descriptor.end_of_packet = 0;
+		descriptor.interrupt_on_completion = 1;
+		writedescriptor(((unsigned long) adapter->rx_desc +
+				 adapter->rx_head.bits.offset), &descriptor);
+		queue_increment_(&adapter->rx_head, adapter->rx_num_desc);
+		updated_head_pointer = 1;
+	}
+
+	if (0 != updated_head_pointer)
+		write_mac_(adapter->rx_head.raw, APPNIC_DMA_RX_HEAD_POINTER);
+
+	return packets;
+}
+
+#ifdef LSINET_NAPI
+
+/*
+  ============================================
+  lsinet_poll
+*/
+
+static int
+lsinet_poll(struct napi_struct *napi, int budget)
+{
+	appnic_device_t *adapter = container_of(napi, appnic_device_t, napi);
+	struct net_device *device = adapter->device;
+	appnic_queue_pointer_t queue_;
+
+	int cur_budget = budget;
+	int done;
+	unsigned long dma_interrupt_status_;
+#ifdef __APPNIC_C_PROFILE__
+	unsigned long packets_handled_ = 0;
+	unsigned long beginning_;
+	unsigned long end_;
+
+	beginning_ = (0xffffffff - readl((TIMER7_BASE + TIMER_n_VALUE)));
+#endif				/* __APPNIC_C_PROFILE__ */
+
+	LSINET_COUNTS_INC(LSINET_COUNTS_POL_START);
+	/* TEMP DEBUG: should be interruptible */
+	/*down( & adapter->poll_sem); */
+
+	TRACE_BEGINNING();
+	DEBUG_PRINT("head=0x%x tail=0x%x tail_copy=0x%x\n",
+		    adapter->rx_head.raw, adapter->rx_tail->raw,
+		    adapter->rx_tail_copy.raw);
+	queue_.raw = adapter->rx_tail_copy.raw;
+
+	done = 1;
+
+	do {
+
+		/* Acknowledge the RX interrupt. */
+		write_mac_(~APPNIC_DMA_INTERRUPT_ENABLE_RECEIVE,
+			   APPNIC_DMA_INTERRUPT_STATUS);
+
+		cur_budget -= lsinet_rx_packets(device, cur_budget);
+		if (0 == cur_budget)
+			break;
+
+		dma_interrupt_status_ = read_mac_(APPNIC_DMA_INTERRUPT_STATUS);
+
+	} while ((RX_INTERRUPT(dma_interrupt_status_)) && cur_budget);
+
+	if (done) {
+		LSINET_COUNTS_INC(LSINET_COUNTS_POL_RNBL);
+		napi_complete(napi);
+		/* re-enable receive interrupts */
+		write_mac_((APPNIC_DMA_INTERRUPT_ENABLE_RECEIVE |
+			    APPNIC_DMA_INTERRUPT_ENABLE_TRANSMIT),
+			   APPNIC_DMA_INTERRUPT_ENABLE);
+	}
+
+	DEBUG_PRINT("head=0x%x tail=0x%x tail_copy=0x%x\n",
+		    adapter->rx_head.raw, adapter->rx_tail->raw,
+		    adapter->rx_tail_copy.raw);
+	TRACE_ENDING();
+
+#ifdef __APPNIC_C_PROFILE__
+	end_ = (0xffffffff - readl((TIMER7_BASE + TIMER_n_VALUE)));
+	app3xx_profile_time_calc(beginning_, end_,
+				 time_in_rx_min_, time_in_rx_max_,
+				 total_rx_time_);
+
+	total_rx_packets_handled_ += packets_handled_;
+	if (packets_handled_ > max_rx_packets_handled_)
+		max_rx_packets_handled_ = packets_handled_;
+
+	++total_polls_;
+#endif				/* __APPNIC_C_PROFILE__ */
+
+	/* TEMP */
+	/*up( & adapter->poll_sem); */
+	LSINET_COUNTS_INC(LSINET_COUNTS_POL_DONE);
+	return done ? 0 : 1;
+
+}
+
+#else				/* Not using NAPI, define the Rx interrupt handler instead */
+
+/*
+  ----------------------------------------------------------------------
+  handle_receive_interrupt_
+*/
+
+static void
+handle_receive_interrupt_(struct net_device *device)
+{
+
+	appnic_device_t *dev_ = netdev_priv(device);
+	appnic_queue_pointer_t queue_;
+
+#ifdef __APPNIC_C_PROFILE__
+	unsigned long beginning_;
+	unsigned long end_;
+	unsigned long packets_handled_ = 0;
+
+	beginning_ = (0xffffffff - readl((TIMER7_BASE + TIMER_n_VALUE)));
+#endif				/* __APPNIC_C_PROFILE__ */
+
+	LSINET_COUNTS_INC(LSINET_COUNTS_RX_START);
+	TRACE_BEGINNING();
+	DEBUG_PRINT("head=0x%lx tail=0x%lx tail_copy=0x%lx\n",
+		    dev_->rx_head.raw, dev_->rx_tail->raw,
+		    dev_->rx_tail_copy.raw);
+	queue_.raw = dev_->rx_tail_copy.raw;
+	lsinet_rx_packets(device, -1);
+	DEBUG_PRINT("head=0x%lx tail=0x%lx tail_copy=0x%lx\n",
+		    dev_->rx_head.raw, dev_->rx_tail->raw,
+		    dev_->rx_tail_copy.raw);
+	TRACE_ENDING();
+	LSINET_COUNTS_INC(LSINET_COUNTS_RX_DONE);
+#ifdef __APPNIC_C_PROFILE__
+	end_ = (0xffffffff - readl((TIMER7_BASE + TIMER_n_VALUE)));
+	app3xx_profile_time_calc(beginning_, end_,
+				 time_in_rx_min_, time_in_rx_max_,
+				 total_rx_time_);
+
+	total_rx_packets_handled_ += packets_handled_;
+	if (packets_handled_ > max_rx_packets_handled_)
+		max_rx_packets_handled_ = packets_handled_;
+	++total_rx_interrupts_;
+#endif				/* __APPNIC_C_PROFILE__ */
+
+	return;
+
+}
+#endif				/* else not NAPI */
+
+/*
+  ----------------------------------------------------------------------
+  appnic_isr_
+*/
+
+static irqreturn_t
+appnic_isr_(int irq, void *device_id)
+{
+
+	struct net_device *device_ = (struct net_device *) device_id;
+	appnic_device_t *dev_ = netdev_priv(device_);
+	unsigned long dma_interrupt_status_;
+	unsigned long flags;
+
+#ifdef __APPNIC_C_PROFILE__
+	unsigned beginning_jiffies_ = jiffies;
+#endif				/* __APPNIC_C_PROFILE__ */
+
+	TRACE_BEGINNING();
+	LSINET_COUNTS_INC(LSINET_COUNTS_ISR_START);
+
+	/* acquire the lock */
+	spin_lock_irqsave(&dev_->lock, flags);
+
+#if !defined(PHYLESS) && !defined(CONFIG_ACP)
+	if (INT_MAC_RX == irq) {
+
+		PHY_DEBUG_PRINT("Handling PHY interrupt.\n");
+
+		if (BCM5221_PHY_ == phy_type_) {
+
+			bc_phy_interrupt_t bc_phy_interrupt_;
+
+			(void) phy_read_(phy_address_,
+					 BC_PHY_INTERRUPT_,
+					 &bc_phy_interrupt_.raw);
+			bc_phy_interrupt_.raw = 0;
+			bc_phy_interrupt_.bits.enable = 1;
+			(void) phy_write_(phy_address_,
+					  BC_PHY_INTERRUPT_,
+					  bc_phy_interrupt_.raw);
+
+		} else if (MICREL_PHY_ == phy_type_) {
+
+			m_phy_interrupt_t m_phy_interrupt_;
+
+			(void) phy_read_(phy_address_,
+					 M_PHY_INTERRUPT_,
+					 &m_phy_interrupt_.raw);
+			(void) phy_write_(phy_address_, M_PHY_INTERRUPT_,
+					  m_phy_interrupt_.raw);
+
+		}
+
+		write_mac_(0, APPNIC_RX_INTERRUPT_STATUS);
+		enable_(device_);
+
+	} else {
+#endif				/* PHYLESS */
+		/* get the status */
+		dma_interrupt_status_ = read_mac_(APPNIC_DMA_INTERRUPT_STATUS);
+#ifdef LSINET_NAPI
+		/* NAPI - don't ack RX interrupt */
+		write_mac_(APPNIC_DMA_INTERRUPT_ENABLE_RECEIVE,
+			   APPNIC_DMA_INTERRUPT_STATUS);
+#else
+		write_mac_(0, APPNIC_DMA_INTERRUPT_STATUS);
+#endif
+
+		/*TRACER_POST( "dma_interrupt_status_=0x%x", dma_interrupt_status_ ); */
+
+		/* handle interrupts */
+
+		if (TX_INTERRUPT(dma_interrupt_status_)) {
+			LSINET_COUNTS_INC(LSINET_COUNTS_ISR_TX);
+			/* transmition complete */
+			++transmit_interrupts_;
+			handle_transmit_interrupt_(device_);
+		}
+
+		if (RX_INTERRUPT(dma_interrupt_status_)) {
+			LSINET_COUNTS_INC(LSINET_COUNTS_ISR_RX);
+#ifdef LSINET_NAPI
+			++receive_interrupts_;
+			if (napi_schedule_prep(&dev_->napi)) {
+				/* disable RX interrupts and tell the system we've got work */
+				write_mac_(APPNIC_DMA_INTERRUPT_ENABLE_TRANSMIT,
+					   APPNIC_DMA_INTERRUPT_ENABLE);
+				__napi_schedule(&dev_->napi);
+			} else {
+				write_mac_(APPNIC_DMA_INTERRUPT_ENABLE_TRANSMIT,
+					   APPNIC_DMA_INTERRUPT_ENABLE);
+			}
+#else
+			/* receive complete */
+			handle_receive_interrupt_(device_);
+#endif
+		}
+#if !defined(PHYLESS) && !defined(CONFIG_ACP)
+	}
+#endif				/* PHYLESS */
+
+	/* release the lock */
+	spin_unlock_irqrestore(&dev_->lock, flags);
+
+	LSINET_COUNTS_INC(LSINET_COUNTS_ISR_DONE);
+	TRACE_ENDING();
+
+#ifdef __APPNIC_C_PROFILE__
+	if (jiffies != beginning_jiffies_)
+		++jiffies_changed_;
+#endif				/* __APPNIC_C_PROFILE__ */
+
+	return IRQ_HANDLED;
+
+}
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+/*
+ * Polling receive - used by netconsole and other diagnostic tools
+ * to allow network i/o with interrupts disabled.
+ */
+static void
+appnic_poll_controller(struct net_device *dev)
+{
+	disable_irq(dev->irq);
+	appnic_isr_(dev->irq, dev);
+	enable_irq(dev->irq);
+}
+
+#endif
+/*
+  ----------------------------------------------------------------------
+  appnic_open
+
+  Opens the interface.  The interface is opened whenever ifconfig
+  activates it.  The open method should register any system resource
+  it needs (I/O ports, IRQ, DMA, etc.) turn on the hardware, and
+  increment the module usage count.
+*/
+
+int
+appnic_open(struct net_device *device)
+{
+
+	int return_code_ = 0;
+#if defined(CONFIG_ARCH_APP3)
+	unsigned long gpio_mux_ = readl(APP3XX_HB_CONF_BASE + 0x18);
+#elif defined(CONFIG_ARCH_APP3K)
+	/*unsigned long gpio_mux_ = readl( APP_AEI_BASE + 0x18 ); */
+#endif
+
+	/* enable the receiver and transmitter */
+	if (0 != enable_(device)) {
+
+		ERROR_PRINT("Unable to enable the interface.\n");
+		disable_();
+		return -EBUSY;
+
+	}
+#ifdef LSINET_NAPI
+	{
+		appnic_device_t *adapter = netdev_priv(device);
+		napi_enable(&adapter->napi);
+	}
+#endif				/* LSINET_NAPI */
+
+	/* install the interrupt handlers */
+	return_code_ =
+	     request_irq(device->irq, appnic_isr_, IRQF_DISABLED, APPNIC_NAME,
+		 device);
+	if (0 != return_code_) {
+
+		ERROR_PRINT("request_irq( ) failed, returned 0x%x/%d\n",
+			    return_code_, return_code_);
+		return return_code_;
+
+	}
+
+	/* enable interrupts */
+	write_mac_((APPNIC_DMA_INTERRUPT_ENABLE_RECEIVE |
+		    APPNIC_DMA_INTERRUPT_ENABLE_TRANSMIT),
+		   APPNIC_DMA_INTERRUPT_ENABLE);
+
+	{
+
+#ifndef PHYLESS
+#ifndef CONFIG_ACP
+		char phy_string_[256];
+		int use_interrupts_ = 1;
+#endif
+		appnic_device_t *dev_ = netdev_priv(device);
+#endif
+
+#ifdef CONFIG_ARCH_APP3
+
+		PHY_DEBUG_PRINT("phy_type_=0x%x gpio_mux_=0x%x\n", phy_type_,
+				gpio_mux_);
+
+		if ((BCM5221_PHY_ != phy_type_) ||
+		    (0x04000000 != (gpio_mux_ & 0x04000000))) {
+
+			use_interrupts_ = 0;
+
+		}
+#endif
+
+#ifndef PHYLESS
+
+#ifndef CONFIG_ACP
+#ifdef CONFIG_LSI_UBOOTENV
+		if ((0 != ubootenv_get("phy_mode", phy_string_)) ||
+		    (0 == strncmp(phy_string_, "poll", strlen("poll")))) {
+
+			use_interrupts_ = 0;
+
+		}
+#else
+		use_interrupts_ = 0;
+#endif
+
+		PHY_DEBUG_PRINT("use_interrupts_=%d\n", use_interrupts_);
+
+		if (1 == use_interrupts_) {
+
+			if (BCM5221_PHY_ == phy_type_) {
+
+				bc_phy_interrupt_t bc_phy_interrupt_;
+
+				bc_phy_interrupt_.raw = 0;
+				bc_phy_interrupt_.bits.enable = 1;
+
+				if (0 !=
+				    phy_write_(phy_address_, BC_PHY_INTERRUPT_,
+					       bc_phy_interrupt_.raw)) {
+
+					return -EBUSY;
+
+				}
+
+				if (0 !=
+				    phy_read_(phy_address_, BC_PHY_INTERRUPT_,
+					      &bc_phy_interrupt_.raw)) {
+
+					return -EBUSY;
+
+				}
+
+			} else if (MICREL_PHY_ == phy_type_) {
+
+				m_phy_interrupt_t m_phy_interrupt_;
+
+				m_phy_interrupt_.raw = 0;
+				m_phy_interrupt_.bits.enable_link_up = 1;
+
+				if (0 !=
+				    phy_write_(phy_address_, M_PHY_INTERRUPT_,
+					       m_phy_interrupt_.raw)) {
+
+					return -EBUSY;
+
+				}
+
+			}
+
+			return_code_ =
+				  request_irq(INT_MAC_RX, appnic_isr_, 0,
+					      APPNIC_NAME "(phy)", device);
+			if (0 != return_code_) {
+
+				ERROR_PRINT
+				    ("request_irq( ) failed, returned 0x%x/%d\n",
+				     return_code_, return_code_);
+				return return_code_;
+
+			}
+
+			write_mac_((APPNIC_RX_EXTERNAL_INTERRUPT_CONTROL_MAC_0),
+				   APPNIC_RX_EXTERNAL_INTERRUPT_CONTROL);
+			dev_->polling = 0;
+
+		} else {
+
+#endif
+
+#ifndef CONFIG_ACP
+			WARN_PRINT("PHY is in polling mode.\n");
+#endif
+			init_timer(&appnic_timer_);
+			appnic_timer_.expires =
+			    jiffies + (APPNIC_TIMER_PERIOD * HZ);
+			appnic_timer_.data = (unsigned long) device;
+			appnic_timer_.function = appnic_timer_handler_;
+			add_timer(&appnic_timer_);
+			dev_->polling = 1;
+
+#ifndef CONFIG_ACP
+
+		}
+
+#endif
+
+#endif				/* PHYLESS */
+
+	}
+
+	/* let the OS know we are ready to send packets */
+	netif_start_queue(device);
+
+	/* that's all */
+	return 0;
+
+}
+
+/*
+  ----------------------------------------------------------------------
+  appnic_stop
+
+  Stops the interface.  The interface is stopped when it is broughht
+  down; operations performed at open time should be reversed.
+*/
+
+int
+appnic_stop(struct net_device *device)
+{
+
+	int return_code_ = 0;
+
+	DEBUG_PRINT("Stopping the interface.\n");
+
+	/*
+	   Indicate to the OS that no more packets should be sent.
+	 */
+
+	netif_stop_queue(device);
+
+	/*
+	   Stop the receiver and transmitter.
+	 */
+
+	disable_();
+
+	/* Disable NAPI. */
+#ifdef LSINET_NAPI
+	{
+		appnic_device_t *adapter = netdev_priv(device);
+		napi_disable(&adapter->napi);
+	}
+#endif
+
+	/*
+	   Free the interrupts.
+	 */
+
+	free_irq(device->irq, device);
+
+#ifndef PHYLESS
+
+	{
+#ifndef CONFIG_ACP
+		appnic_device_t *dev_ = netdev_priv(device);
+		if (0 != dev_->polling)
+			del_timer(&appnic_timer_);
+		else
+			free_irq(INT_MAC_RX, device);
+
+#else
+		del_timer(&appnic_timer_);
+#endif
+	}
+
+#endif				/* PHYLESS */
+
+	/*
+	   That's all.
+	 */
+
+	return return_code_;
+
+}
+
+/*
+  ----------------------------------------------------------------------
+  appnic_hard_start_xmit
+
+  The method initiates the transmission of a packet.  The full packet
+  (protocol headers and all) is contained in a socket buffer (sk_buff)
+  structure.
+
+  ----- NOTES -----
+
+  1) This will not get called again by the kernel until it returns.
+*/
+
+int
+appnic_hard_start_xmit(struct sk_buff *skb, struct net_device *device)
+{
+	appnic_device_t *adapter = netdev_priv(device);
+	int length_;
+	int buf_per_desc_;
+	unsigned long flags;
+
+#ifdef __APPNIC_C_PROFILE__
+	unsigned long beginning_;
+	unsigned long end_;
+	unsigned long this_time_;
+
+	beginning_ = (0xffffffff - readl((TIMER7_BASE + TIMER_n_VALUE)));
+	++total_tx_packets_;
+#endif				/* __APPNIC_C_PROFILE__ */
+
+	LSINET_COUNTS_INC(LSINET_COUNTS_HST_START);
+	appnic_special_lock(&adapter->lock, flags);
+	length_ = skb->len < ETH_ZLEN ? ETH_ZLEN : skb->len;
+	buf_per_desc_ = adapter->tx_buf_sz / adapter->tx_num_desc;
+
+	/*
+	   If enough transmit descriptors are available, copy and transmit.
+	 */
+
+	DEBUG_PRINT("length_=%d buf_per_desc_=%d tx_tail=0x%x\n",
+		    length_, buf_per_desc_, swab32(adapter->tx_tail->raw));
+
+	while (((length_ / buf_per_desc_) + 1) >=
+	       queue_uninitialized_(adapter->tx_head,
+				    SWAB_QUEUE_POINTER(adapter->tx_tail),
+				    adapter->tx_num_desc)) {
+		udelay(1000);
+		LSINET_COUNTS_INC(LSINET_COUNTS_HST_RCLM);
+		handle_transmit_interrupt_(device);
+	}
+
+	if (((length_ / buf_per_desc_) + 1) <
+	    queue_uninitialized_(adapter->tx_head,
+				 SWAB_QUEUE_POINTER(adapter->tx_tail),
+				 adapter->tx_num_desc)) {
+		int bytes_copied_ = 0;
+		appnic_dma_descriptor_t descriptor;
+
+		LSINET_COUNTS_INC(LSINET_COUNTS_HST_SNDG);
+		readdescriptor(((unsigned long) adapter->tx_desc +
+				adapter->tx_head.bits.offset), &descriptor);
+		descriptor.start_of_packet = 1;
+
+		while (bytes_copied_ < length_) {
+			descriptor.write = 1;
+			descriptor.pdu_length = length_;
+
+			if ((length_ - bytes_copied_) > buf_per_desc_) {
+				memcpy((void *) (descriptor.
+						 host_data_memory_pointer +
+						 adapter->dma_alloc_offset),
+				       (void *) ((unsigned long) skb->data +
+						 bytes_copied_), buf_per_desc_);
+				descriptor.data_transfer_length = buf_per_desc_;
+				descriptor.end_of_packet = 0;
+				descriptor.interrupt_on_completion = 0;
+				bytes_copied_ += buf_per_desc_;
+			} else {
+				memcpy((void *) (descriptor.
+						 host_data_memory_pointer +
+						 adapter->dma_alloc_offset),
+				       (void *) ((unsigned long) skb->data +
+						 bytes_copied_),
+				       (length_ - bytes_copied_));
+				descriptor.data_transfer_length =
+				    (length_ - bytes_copied_);
+				descriptor.end_of_packet = 1;
+#ifdef DISABLE_TX_INTERRUPTS
+				descriptor.interrupt_on_completion = 0;
+#else				/* DISABLE_TX_INTERRUPTS */
+				descriptor.interrupt_on_completion = 1;
+#endif				/* DISABLE_TX_INTERRUPTS */
+				bytes_copied_ = length_;
+			}
+
+			adapter->stats.tx_bytes += bytes_copied_;
+			writedescriptor(((unsigned long) adapter->tx_desc +
+					 adapter->tx_head.bits.offset),
+					&descriptor);
+			queue_increment_(&adapter->tx_head,
+					 adapter->tx_num_desc);
+			readdescriptor(((unsigned long) adapter->tx_desc +
+					adapter->tx_head.bits.offset),
+				       &descriptor);
+			descriptor.start_of_packet = 0;
+		}
+
+		write_mac_(adapter->tx_head.raw, APPNIC_DMA_TX_HEAD_POINTER);
+		device->trans_start = jiffies;
+		LSINET_COUNTS_INC(LSINET_COUNTS_HST_SNT);
+	} else {
+		++out_of_tx_descriptors_;
+		LSINET_COUNTS_INC(LSINET_COUNTS_HST_OOD);
+		ERROR_PRINT("No transmit descriptors available!\n");
+	}
+
+	appnic_special_unlock(&adapter->lock, flags);
+	/* free the socket buffer */
+	dev_kfree_skb(skb);
+
+#ifdef __APPNIC_C_PROFILE__
+	end_ = (0xffffffff - readl((TIMER7_BASE + TIMER_n_VALUE)));
+	if (end_ > beginning_)
+		this_time_ = end_ - beginning_;
+	else
+		this_time_ = end_ + (0xffffffff - beginning_) + 1;
+
+	total_tx_time_ += this_time_;
+	if (this_time_ > time_in_tx_max_)
+		time_in_tx_max_ = this_time_;
+
+	if (this_time_ < time_in_tx_min_)
+		time_in_tx_min_ = this_time_;
+
+#endif				/* __APPNIC_C_PROFILE__ */
+
+	LSINET_COUNTS_INC(LSINET_COUNTS_HST_DONE);
+	return 0;
+
+}
+
+/*
+  ----------------------------------------------------------------------
+  appnic_tx_timeout
+
+  This method is called when a packet transmission fails to complete
+  within a resonable period, on the assumption that an interrupt has
+  been missed or the interface has locked up.  It should handle the
+  problem and resume packet transmission.
+*/
+
+void
+appnic_tx_timeout(struct net_device *device)
+{
+
+	appnic_device_t *adapter = netdev_priv(device);
+
+	WARN_PRINT("Transmission timed out!\n");
+
+	if (0 == queue_initialized_(SWAB_QUEUE_POINTER(adapter->tx_tail),
+				    adapter->tx_tail_copy,
+				    adapter->tx_num_desc)) {
+		/*
+		   If tx_tail is still the same as tx_tail_copy
+		   then restart the transmission.
+		 */
+
+		write_mac_(adapter->tx_head.raw, APPNIC_DMA_TX_HEAD_POINTER);
+	} else {
+		/* If tx_tail has moved on, just increment tx_tail_copy. */
+		appnic_dma_descriptor_t descriptor;
+
+		readdescriptor(((unsigned long) adapter->tx_desc +
+				adapter->tx_tail_copy.bits.offset),
+			       &descriptor);
+		adapter->stats.tx_bytes += descriptor.pdu_length;
+		kfree((void *) descriptor.host_data_memory_pointer);
+		queue_increment_(&adapter->tx_tail_copy, adapter->tx_num_desc);
+	}
+
+	return;
+
+}
+
+/*
+  ----------------------------------------------------------------------
+  appnic_net_device_stats
+
+  Whenever an application needs to get statistics for the interface,
+  this method is called.  This happens, for example, when ifconfig or
+  nstat -i is run.
+*/
+
+struct net_device_stats *
+appnic_get_stats(struct net_device *device)
+{
+
+	appnic_device_t *device_ = netdev_priv(device);
+
+	/*
+	   Update the statistics structure.
+	 */
+
+	get_hw_statistics_(device_);
+
+	/*
+	   That's all.
+	 */
+
+	return &device_->stats;
+
+}
+
+/*
+  ----------------------------------------------------------------------
+  appnic_set_mac_address
+*/
+
+static int
+appnic_set_mac_address(struct net_device *device, void *data)
+{
+	struct sockaddr *address_ = data;
+	unsigned long swap_source_address_;
+
+	if (netif_running(device))
+		return -EBUSY;
+
+	DEBUG_PRINT("Setting MAC to %02x:%02x:%02x:%02x:%02x:%02x\n",
+		    address_->sa_data[0], address_->sa_data[1],
+		    address_->sa_data[2], address_->sa_data[3],
+		    address_->sa_data[4], address_->sa_data[5]);
+	memcpy(device->dev_addr, address_->sa_data, 6);
+	memcpy(device->perm_addr, address_->sa_data, 6);
+
+	swap_source_address_ =
+	    ((address_->sa_data[4]) << 8) | address_->sa_data[5];
+	write_mac_(swap_source_address_, APPNIC_SWAP_SOURCE_ADDRESS_2);
+	swap_source_address_ =
+	    ((address_->sa_data[2]) << 8) | address_->sa_data[3];
+	write_mac_(swap_source_address_, APPNIC_SWAP_SOURCE_ADDRESS_1);
+	swap_source_address_ =
+	    ((address_->sa_data[0]) << 8) | address_->sa_data[1];
+	write_mac_(swap_source_address_, APPNIC_SWAP_SOURCE_ADDRESS_0);
+	memcpy(device->dev_addr, address_->sa_data, device->addr_len);
+
+	return 0;
+}
+
+/*
+  ======================================================================
+  ======================================================================
+  ======================================================================
+
+  ETHTOOL Operations
+
+  ======================================================================
+  ======================================================================
+  ======================================================================
+*/
+
+/*
+  ----------------------------------------------------------------------
+  appnic_get_settings
+*/
+
+static int
+appnic_get_settings(struct net_device *device, struct ethtool_cmd *command)
+{
+	unsigned long flags;
+	appnic_device_t *appnic_device_ = netdev_priv(device);
+
+	memset(command, 0, sizeof(struct ethtool_cmd));
+
+	/* What the hardware supports. */
+	command->supported =
+	    (SUPPORTED_10baseT_Half |
+	     SUPPORTED_10baseT_Full |
+	     SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full);
+
+	/* Acquire the device lock. */
+	appnic_special_lock(&appnic_device_->lock, flags);
+
+#ifndef PHYLESS
+
+	/* What is currently advertised. */
+
+	{
+
+		unsigned short ad_value_;
+
+		if (0 !=
+		    phy_read_(phy_address_, PHY_AUTONEG_ADVERTISE,
+			      &ad_value_)) {
+
+			ERROR_PRINT("PHY read failed!");
+			appnic_special_unlock(&appnic_device_->lock, flags);
+			return -EIO;
+
+		}
+
+		switch (ad_value_) {
+
+		case 0x1e1:
+			command->advertising =
+			    (ADVERTISED_100baseT_Full | ADVERTISED_100baseT_Half
+			     | ADVERTISED_10baseT_Full |
+			     ADVERTISED_10baseT_Half);
+			break;
+
+		case 0xe1:
+			command->advertising =
+			    (ADVERTISED_100baseT_Half |
+			     ADVERTISED_10baseT_Full | ADVERTISED_10baseT_Half);
+			break;
+
+		case 0x61:
+			command->advertising =
+			    (ADVERTISED_10baseT_Full | ADVERTISED_10baseT_Half);
+			break;
+
+		case 0x41:
+			command->advertising = (ADVERTISED_10baseT_Half);
+			break;
+
+		default:
+			break;
+
+		}
+
+	}
+
+	/* The current speed. */
+
+	{
+
+		int speed_;
+
+		speed_ = phy_speed_(phy_address_);
+		if (-1 == speed_) {
+
+			ERROR_PRINT("PHY read failed!");
+			appnic_special_unlock(&appnic_device_->lock, flags);
+			return -EIO;
+
+		}
+
+		if (1 == speed_)
+			command->speed = SPEED_100;
+		else
+			command->speed = SPEED_10;
+
+	}
+
+	/* Is the current link duplex? */
+
+	{
+
+		int duplex_;
+
+		duplex_ = phy_duplex_(phy_address_);
+		if (-1 == duplex_) {
+
+			ERROR_PRINT("PHY read failed!");
+			appnic_special_unlock(&appnic_device_->lock, flags);
+			return -EIO;
+
+		}
+
+		if (1 == duplex_)
+			command->duplex = DUPLEX_FULL;
+		else
+			command->duplex = DUPLEX_HALF;
+
+	}
+
+#endif				/* PHYLESS */
+
+	/* Is autoneg enabled? */
+	command->autoneg = AUTONEG_ENABLE;
+
+	/* Unlock and return success. */
+	appnic_special_unlock(&appnic_device_->lock, flags);
+
+	return 0;
+
+}
+
+/*
+  Fill in the struture...
+*/
+
+static const struct ethtool_ops appnic_ethtool_ops = {
+	.get_settings = appnic_get_settings
+};
+
+/*
+  ======================================================================
+  ======================================================================
+  ======================================================================
+
+  Linux Module Interface.
+
+  ======================================================================
+  ======================================================================
+  ======================================================================
+*/
+
+static const struct net_device_ops appnic_netdev_ops = {
+	.ndo_open = appnic_open,
+	.ndo_stop = appnic_stop,
+	.ndo_get_stats = appnic_get_stats,
+	.ndo_set_mac_address = appnic_set_mac_address,
+	.ndo_start_xmit = appnic_hard_start_xmit,
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	.ndo_poll_controller = appnic_poll_controller,
+#endif
+};
+
+/*
+  ----------------------------------------------------------------------
+  appnic_init
+*/
+
+int
+appnic_init(struct net_device *device)
+{
+
+	appnic_device_t *adapter = netdev_priv(device);
+
+	TRACE_BEGINNING();
+
+	/*
+	   Reset the MAC
+	 */
+
+	write_mac_(0x80000000, APPNIC_DMA_PCI_CONTROL);
+
+	/*
+	   -- WORKAROUND -- WORKAROUND -- WORKAROUND -- WORKAROUND -- WORKAROUND --
+	   This is the software work around for defect 15129.  Use 64 byte
+	   buffers for receive descriptors for all dma.
+	   -- WORKAROUND -- WORKAROUND -- WORKAROUND -- WORKAROUND -- WORKAROUND --
+	 */
+#ifndef CONFIG_ACP
+	if (1 >= (APP3XX_REVISION_REGISTER & 0x1f)) {
+
+		printk("++ Using work around for defect 15129\n");
+		rx_num_desc = (8 * DESCRIPTOR_GRANULARITY);
+		rx_buf_sz = 32768;
+
+	}
+#endif
+
+	/*
+	   Allocate memory and initialize the descriptors
+	 */
+
+	{
+
+		void *dma_offset_;
+
+		/*
+		   fixup num_[rt]x_desc
+		 */
+
+		if (0 != (rx_num_desc % DESCRIPTOR_GRANULARITY)) {
+
+			WARN_PRINT("rx_num_desc was not a multiple of %d.\n",
+				   DESCRIPTOR_GRANULARITY);
+			rx_num_desc +=
+			    DESCRIPTOR_GRANULARITY -
+			    (rx_num_desc % DESCRIPTOR_GRANULARITY);
+
+		}
+
+		adapter->rx_num_desc = rx_num_desc;
+
+		if (0 != (tx_num_desc % DESCRIPTOR_GRANULARITY)) {
+
+			WARN_PRINT("tx_num_desc was not a multiple of %d.\n",
+				   DESCRIPTOR_GRANULARITY);
+			tx_num_desc +=
+			    DESCRIPTOR_GRANULARITY -
+			    (tx_num_desc % DESCRIPTOR_GRANULARITY);
+
+		}
+
+		adapter->tx_num_desc = tx_num_desc;
+
+		DEBUG_PRINT("rx_num_desc=%d tx_num_desc=%d\n", rx_num_desc,
+			    tx_num_desc);
+
+		/*
+		   Fix up [rt]x_buf_sz.  Must be some multiple of 64 bytes per descriptor.
+		 */
+
+		if (0 != (rx_buf_sz % (BUFFER_ALIGNMENT * rx_num_desc))) {
+
+			WARN_PRINT("rx_buf_sz was not a multiple of %d.\n",
+				   (BUFFER_ALIGNMENT * rx_num_desc));
+			rx_buf_sz +=
+			    (BUFFER_ALIGNMENT * rx_num_desc) -
+			    (rx_buf_sz % (BUFFER_ALIGNMENT * rx_num_desc));
+
+		}
+
+		adapter->rx_buf_sz = rx_buf_sz;
+
+		if (0 != (tx_buf_sz % (BUFFER_ALIGNMENT * tx_num_desc))) {
+
+			WARN_PRINT("tx_buf_sz was not a multiple of %d.\n",
+				   (BUFFER_ALIGNMENT * tx_num_desc));
+			tx_buf_sz +=
+			    (BUFFER_ALIGNMENT * tx_num_desc) -
+			    (tx_buf_sz % (BUFFER_ALIGNMENT * tx_num_desc));
+
+		}
+
+		adapter->tx_buf_sz = tx_buf_sz;
+
+		DEBUG_PRINT("rx_buf_sz=%d tx_buf_sz=%d\n",
+			    rx_buf_sz, tx_buf_sz);
+
+		/*
+		   Allocate dma-able memory
+		 */
+
+		adapter->dma_alloc_size =
+		    /* The tail pointers (rx and tx) */
+		    (sizeof(appnic_queue_pointer_t) * 2) +
+		    /* The RX descriptor ring (and padding to allow
+		       64 byte alignment) */
+		    (sizeof(appnic_dma_descriptor_t) *
+		     adapter->rx_num_desc) + (DESCRIPTOR_GRANULARITY) +
+		    /* The TX descriptor ring (and padding...) */
+		    (sizeof(appnic_dma_descriptor_t) *
+		     adapter->tx_num_desc) + (DESCRIPTOR_GRANULARITY) +
+		    /* The RX buffer (and padding...) */
+		    (adapter->rx_buf_sz) + (BUFFER_ALIGNMENT) +
+		    /* The TX buffer (and padding...) */
+		    (adapter->tx_buf_sz) + (BUFFER_ALIGNMENT);
+
+#ifdef DMA_CACHABLE
+		adapter->dma_alloc = (void *)
+				   kmalloc(adapter->dma_alloc_size,
+					   GFP_KERNEL);
+		if ((void *) 0 == adapter->dma_alloc) {
+
+			ERROR_PRINT("Could not allocate %d bytes of "
+				    "DMA-able memory!\n",
+				    adapter->dma_alloc_size);
+			kfree(adapter);
+			TRACE_ENDING();
+			return -ENOMEM;
+
+		}
+
+		adapter->dma_alloc_dma = virt_to_phys(adapter->dma_alloc);
+
+#else
+
+		/* This needs to be set to something sane for dma_alloc_coherent() */
+		device->dev.archdata.dma_ops = &dma_direct_ops;
+
+		adapter->dma_alloc = (void *)
+				   dma_alloc_coherent(&device->dev,
+						      adapter->dma_alloc_size,
+						      &adapter->dma_alloc_dma,
+						      GFP_KERNEL);
+		if ((void *) 0 == adapter->dma_alloc) {
+
+			ERROR_PRINT("Could not allocate %d bytes of "
+				    "DMA-able memory!\n",
+				    adapter->dma_alloc_size);
+			kfree(adapter);
+			TRACE_ENDING();
+			return -ENOMEM;
+
+		}
+#endif
+
+		adapter->dma_alloc_offset =
+		    (int) adapter->dma_alloc - (int) adapter->dma_alloc_dma;
+		dma_offset_ = adapter->dma_alloc;
+		DEBUG_PRINT("Allocated %d bytes at 0x%08lx(0x%08lx), "
+			    "offset=0x%x.\n",
+			    adapter->dma_alloc_size,
+			    (unsigned long) adapter->dma_alloc,
+			    (unsigned long) adapter->dma_alloc_dma,
+			    adapter->dma_alloc_offset);
+		printk("Allocated %d bytes at 0x%08lx(0x%08lx), "
+		       "offset=0x%x.\n",
+		       adapter->dma_alloc_size,
+		       (unsigned long) adapter->dma_alloc,
+		       (unsigned long) adapter->dma_alloc_dma,
+		       adapter->dma_alloc_offset);
+
+		/*
+		   Initialize the tail pointers
+		 */
+
+		adapter->rx_tail = (appnic_queue_pointer_t *) dma_offset_;
+		adapter->rx_tail_dma =
+		    (int) adapter->rx_tail - (int) adapter->dma_alloc_offset;
+		dma_offset_ += sizeof(appnic_queue_pointer_t);
+		memset((void *) adapter->rx_tail, 0,
+		       sizeof(appnic_queue_pointer_t));
+		DEBUG_PRINT("rx_tail=0x%08lx\n",
+			    (unsigned long) adapter->rx_tail);
+
+		adapter->tx_tail = (appnic_queue_pointer_t *) dma_offset_;
+		adapter->tx_tail_dma =
+		    (int) adapter->tx_tail - (int) adapter->dma_alloc_offset;
+		dma_offset_ += sizeof(appnic_queue_pointer_t);
+		memset((void *) adapter->tx_tail, 0,
+		       sizeof(appnic_queue_pointer_t));
+		DEBUG_PRINT("tx_tail=0x%08lx\n",
+			    (unsigned long) adapter->tx_tail);
+
+		/*
+		   Initialize the descriptor pointers
+		 */
+
+		DEBUG_PRINT("rx_tail=0x%08lx\n",
+			    (unsigned long) adapter->rx_tail);
+		adapter->rx_desc = (appnic_dma_descriptor_t *)
+		    ALIGN64B(dma_offset_);
+		DEBUG_PRINT("rx_desc=0x%08lx\n",
+			    (unsigned long) adapter->rx_desc);
+		adapter->rx_desc_dma =
+		    (int) adapter->rx_desc - (int) adapter->dma_alloc_offset;
+		dma_offset_ += (sizeof(appnic_dma_descriptor_t) *
+				adapter->rx_num_desc) +
+		    (DESCRIPTOR_GRANULARITY);
+		memset((void *) adapter->rx_desc, 0,
+		       (sizeof(appnic_dma_descriptor_t) *
+			adapter->rx_num_desc));
+
+		DEBUG_PRINT("rx_tail=0x%08lx\n",
+			    (unsigned long) adapter->rx_tail);
+		adapter->tx_desc = (appnic_dma_descriptor_t *)
+		    ALIGN64B(dma_offset_);
+		DEBUG_PRINT("tx_desc=0x%08lx\n",
+			    (unsigned long) adapter->tx_desc);
+		adapter->tx_desc_dma =
+		    (int) adapter->tx_desc - (int) adapter->dma_alloc_offset;
+		dma_offset_ += (sizeof(appnic_dma_descriptor_t) *
+				adapter->tx_num_desc) +
+		    (DESCRIPTOR_GRANULARITY);
+		memset((void *) adapter->tx_desc, 0,
+		       (sizeof(appnic_dma_descriptor_t) *
+			adapter->tx_num_desc));
+
+		/*
+		   Initialize the buffer pointers
+		 */
+
+		DEBUG_PRINT("rx_tail=0x%08lx\n",
+			    (unsigned long) adapter->rx_tail);
+		DEBUG_PRINT
+		    ("Initializing the RX buffer pointers, dma_offset=0x%lx/0x%lx\n",
+		     (unsigned long) dma_offset_,
+		     (unsigned long) ALIGN64B(dma_offset_));
+		adapter->rx_buf = (void *) ALIGN64B(dma_offset_);
+		adapter->rx_buf_dma =
+		    (int) adapter->rx_buf - (int) adapter->dma_alloc_offset;
+		adapter->rx_buf_per_desc =
+		    adapter->rx_buf_sz / adapter->rx_num_desc;
+
+		dma_offset_ += (adapter->rx_buf_sz) + (BUFFER_ALIGNMENT);
+
+		DEBUG_PRINT("rx_tail=0x%08lx\n",
+			    (unsigned long) adapter->rx_tail);
+		DEBUG_PRINT
+		    ("Initializing the TX buffer pointers, dma_offset=0x%lx/0x%lx\n",
+		     (unsigned long) dma_offset_,
+		     (unsigned long) ALIGN64B(dma_offset_));
+		adapter->tx_buf = (void *) ALIGN64B(dma_offset_);
+		adapter->tx_buf_dma =
+		    (int) adapter->tx_buf - (int) adapter->dma_alloc_offset;
+		adapter->tx_buf_per_desc =
+		    adapter->tx_buf_sz / adapter->tx_num_desc;
+		dma_offset_ += (adapter->tx_buf_sz) + (BUFFER_ALIGNMENT);
+
+		/*
+		   Initialize the descriptors
+		 */
+
+		DEBUG_PRINT("rx_tail=0x%08lx\n",
+			    (unsigned long) adapter->rx_tail);
+		{
+
+			int index_;
+			unsigned long buf_ =
+			    (unsigned long) adapter->rx_buf_dma;
+			appnic_dma_descriptor_t descriptor;
+
+			DEBUG_PRINT
+			    ("Initializing the RX descriptors at 0x%lx\n",
+			     buf_);
+
+			for (index_ = 0; index_ < adapter->rx_num_desc;
+			     ++index_) {
+				memset((void *) &descriptor, 0,
+				       sizeof(appnic_dma_descriptor_t));
+				descriptor.write = 1;
+				descriptor.interrupt_on_completion = 1;
+				descriptor.host_data_memory_pointer = buf_;
+				descriptor.data_transfer_length =
+				    adapter->rx_buf_per_desc;
+				writedescriptor(((unsigned long) adapter->
+						 rx_desc +
+						 (index_ *
+						  sizeof
+						  (appnic_dma_descriptor_t))),
+						&descriptor);
+				buf_ += adapter->rx_buf_per_desc;
+			}
+
+			buf_ = (unsigned long) adapter->tx_buf_dma;
+			DEBUG_PRINT
+			    ("Initializing the RX descriptors at 0x%lx\n",
+			     buf_);
+
+			for (index_ = 0;
+			     index_ < adapter->tx_num_desc; ++index_) {
+				memset((void *) &descriptor, 0,
+				       sizeof(appnic_dma_descriptor_t));
+				descriptor.write = 1;
+				descriptor.interrupt_on_completion = 1;
+				descriptor.host_data_memory_pointer = buf_;
+				writedescriptor(((unsigned long) adapter->
+						 tx_desc +
+						 (index_ *
+						  sizeof
+						  (appnic_dma_descriptor_t))),
+						&descriptor);
+				buf_ += adapter->tx_buf_per_desc;
+			}
+		}
+
+		DEBUG_PRINT("rx_tail=0x%08lx\n",
+			    (unsigned long) adapter->rx_tail);
+		DEBUG_PRINT("Initializing spin locks and semaphores.\n");
+
+		/*
+		   Initialize the spin lock.
+		 */
+
+		spin_lock_init(&adapter->lock);
+		spin_lock_init(&adapter->extra_lock);
+
+		/*
+		 * TEMP: Initialize the semaphores
+		 */
+		mutex_init(&adapter->rx_sem);
+		mutex_init(&adapter->tx_sem);
+		mutex_init(&adapter->poll_sem);
+
+	}
+
+	/*
+	   Take MAC out of reset
+	 */
+
+	DEBUG_PRINT("rx_tail=0x%08lx\n", (unsigned long) adapter->rx_tail);
+	DEBUG_PRINT("Enabling the MAC");
+	write_mac_(0x0, APPNIC_RX_SOFT_RESET);
+	write_mac_(0x1, APPNIC_RX_MODE);
+	write_mac_(0x0, APPNIC_TX_SOFT_RESET);
+	write_mac_(0x1, APPNIC_TX_MODE);
+
+	if (is_asic())
+		write_mac_(0x300a, APPNIC_TX_WATERMARK);
+	else
+		write_mac_(0xc00096, APPNIC_TX_WATERMARK);
+
+	write_mac_(0x1, APPNIC_TX_HALF_DUPLEX_CONF);
+	write_mac_(0xffff, APPNIC_TX_TIME_VALUE_CONF);
+	write_mac_(0x1, APPNIC_TX_INTERRUPT_CONTROL);
+	write_mac_(0x5275, APPNIC_TX_EXTENDED_CONF);
+	write_mac_(0x1, APPNIC_RX_INTERNAL_INTERRUPT_CONTROL);
+	write_mac_(0x1, APPNIC_RX_EXTERNAL_INTERRUPT_CONTROL);
+	write_mac_(0x40010000, APPNIC_DMA_PCI_CONTROL);
+	write_mac_(0x30000, APPNIC_DMA_CONTROL);
+	writeio(0x280044, dma_base + 0x60);
+	writeio(0xc0, dma_base + 0x64);
+
+	/*
+	   Set the MAC address.
+	 */
+
+	{
+		struct sockaddr address;
+
+		memcpy(&(address.sa_data[0]), device->dev_addr, 6);
+		appnic_set_mac_address(device, &address);
+	}
+
+	/*
+	   Initialize the queue pointers.
+	 */
+
+	DEBUG_PRINT("rx_tail=0x%08lx\n", (unsigned long) adapter->rx_tail);
+	{
+
+		/*
+		   Receiver
+		 */
+
+		memset((void *) &adapter->rx_tail_copy,
+		       0, sizeof(appnic_queue_pointer_t));
+		memset((void *) &adapter->rx_head,
+		       0, sizeof(appnic_queue_pointer_t));
+
+		write_mac_(adapter->rx_desc_dma,
+			   APPNIC_DMA_RX_QUEUE_BASE_ADDRESS);
+		write_mac_((adapter->rx_num_desc *
+			    sizeof(appnic_dma_descriptor_t)) / 1024,
+			   APPNIC_DMA_RX_QUEUE_SIZE);
+		/* indicate that all of the receive descriptors are ready */
+		adapter->rx_head.bits.offset =
+		    (adapter->rx_num_desc - 1) *
+		    sizeof(appnic_dma_descriptor_t);
+		write_mac_(adapter->rx_tail_dma,
+			   APPNIC_DMA_RX_TAIL_POINTER_ADDRESS);
+
+		/*
+		   N.B.
+
+		   The boot loader may have used the NIC.  If so, the
+		   tail pointer must be read and the head pointer (and
+		   local copy of the tail) based on it.
+		 */
+
+		DEBUG_PRINT("Initializing the RX tail: adapter=0x%lx\n",
+			    (unsigned long) adapter);
+		DEBUG_PRINT
+		    ("Initializing the RX tail: adapter->rx_tail=0x%lx\n",
+		     (unsigned long) adapter->rx_tail);
+		DEBUG_PRINT
+		    ("Initializing the RX tail: adapter->rx_tail->raw=0x%lx\n",
+		     (unsigned long) adapter->rx_tail->raw);
+		adapter->rx_tail->raw =
+		    read_mac_(APPNIC_DMA_RX_TAIL_POINTER_LOCAL_COPY);
+		adapter->rx_tail_copy.raw = adapter->rx_tail->raw;
+		adapter->rx_head.raw = adapter->rx_tail->raw;
+		queue_decrement_(&adapter->rx_head, adapter->rx_num_desc);
+		adapter->rx_head.bits.generation_bit =
+		    (0 == adapter->rx_head.bits.generation_bit) ? 1 : 0;
+		write_mac_(adapter->rx_head.raw, APPNIC_DMA_RX_HEAD_POINTER);
+
+		/*
+		   Transmitter
+		 */
+
+		memset((void *) &adapter->tx_tail_copy,
+		       0, sizeof(appnic_queue_pointer_t));
+		memset((void *) &adapter->tx_head,
+		       0, sizeof(appnic_queue_pointer_t));
+
+		write_mac_(adapter->tx_desc_dma,
+			   APPNIC_DMA_TX_QUEUE_BASE_ADDRESS);
+		write_mac_((adapter->tx_num_desc *
+			    sizeof(appnic_dma_descriptor_t)) / 1024,
+			   APPNIC_DMA_TX_QUEUE_SIZE);
+		DEBUG_PRINT
+		    ("Writing 0x%lx to APPNIC_DMA_TX_TAIL_POINTER_ADDRESS\n",
+		     (unsigned long) adapter->tx_tail_dma);
+		write_mac_(adapter->tx_tail_dma,
+			   APPNIC_DMA_TX_TAIL_POINTER_ADDRESS);
+
+		/*
+		   N.B.
+
+		   The boot loader may have used the NIC.  If so, the
+		   tail pointer must be read and the head pointer (and
+		   local copy of the tail) based on it.
+		 */
+
+		DEBUG_PRINT
+		    ("Initializing the TX tail pointer at 0x%lx/0x%lx.\n",
+		     (unsigned long) adapter->tx_tail,
+		     (unsigned long) adapter->tx_tail->raw);
+		adapter->tx_tail->raw =
+		    read_mac_(APPNIC_DMA_TX_TAIL_POINTER_LOCAL_COPY);
+		adapter->tx_tail_copy.raw = adapter->tx_tail->raw;
+		adapter->tx_head.raw = adapter->tx_tail->raw;
+		write_mac_(adapter->tx_head.raw, APPNIC_DMA_TX_HEAD_POINTER);
+
+	}
+
+	/* clear statistics */
+
+	{
+
+		appnic_device_t *device_ = netdev_priv(device);
+		clear_statistics_(device_);
+
+	}
+
+	/* initialize the PHY */
+
+#ifndef PHYLESS
+
+	if (0 != phy_enable_(phy_address_))
+		WARN_PRINT("Failed to initialize the PHY!\n");
+#endif				/* PHYLESS */
+
+	/* fill in the net_device structure */
+
+	DEBUG_PRINT("Filling in the device structure.\n");
+	ether_setup(device);
+
+#ifdef CONFIG_ACP
+	device->irq = irq_create_mapping(NULL, adapter->interrupt);
+	if (NO_IRQ == device->irq) {
+		ERROR_PRINT("irq_create_mapping( ) failed\n");
+		return -EBUSY;
+	}
+
+	if (0 != irq_set_irq_type(device->irq, IRQ_TYPE_LEVEL_HIGH)) {
+		ERROR_PRINT("irq_set_irq_type( ) failed\n");
+		return -EBUSY;
+	}
+#else
+	device->irq = INT_MAC_DMA;
+#endif
+
+	device->netdev_ops = &appnic_netdev_ops;
+
+	SET_ETHTOOL_OPS(device, &appnic_ethtool_ops);
+#ifdef LSINET_NAPI
+	memset((void *) &adapter->napi, 0, sizeof(struct napi_struct));
+	netif_napi_add(device, &adapter->napi, lsinet_poll, LSINET_NAPI_WEIGHT);
+	adapter->device = device;
+	DEBUG_PRINT("lsinet_poll=0x%lx\n", (unsigned long) lsinet_poll);
+#endif
+
+	/* that's all */
+	TRACE_ENDING();
+	return 0;
+
+}
+
+/*
+  ----------------------------------------------------------------------
+  appnic_read_proc_
+*/
+
+static int
+appnic_read_proc_(char *page, char **start, off_t offset,
+		  int count, int *eof, void *data)
+{
+
+	int length_;
+
+#ifdef __APPNIC_C_PROFILE__
+
+	struct net_device *net_device_ = this_net_device;
+	appnic_device_t *appnic_device_ = (appnic_device_t *) net_device_->priv;
+	unsigned long divisor_;
+	unsigned long tx_tpa_real_;
+	unsigned long tx_tpa_virt_;
+
+	divisor_ = get_core_speed() / 1000000;
+
+	if (appnic_device_->tx_tail_dma !=
+	    read_mac_(APPNIC_DMA_TX_TAIL_POINTER_ADDRESS)) {
+
+		ERROR_PRINT(
+			"Real Address Doesn't Match Configuration! 0x%x 0x%x\n",
+			appnic_device_->tx_tail_dma,
+			read_mac_(APPNIC_DMA_TX_TAIL_POINTER_ADDRESS));
+
+	}
+
+	tx_tpa_real_ = appnic_device_->tx_tail_dma;
+	tx_tpa_virt_ = appnic_device_->tx_tail->raw;
+
+	length_ = sprintf(page,
+			  " GKM TEMP DEBUG Build 5\n"
+			  " RX: head=0x%lx tail=0x%lx tail_copy=0x%lx\n"
+			  " TX: head=0x%lx tail=0x%lx tail_copy=0x%lx\n"
+			  "DMA: IE=0x%x IS=0x%x\n"
+			  "VIC: status=0x%x raw=0x%x enable=0x%x\n"
+			  " TX: tpa_config=0x%x tpa_real_=0x%lx "
+			  "*tpa_virt_=0x%x\n",
+			  appnic_device_->rx_head.raw,
+			  appnic_device_->rx_tail->raw,
+			  appnic_device_->rx_tail_copy.raw,
+			  appnic_device_->tx_head.raw,
+			  appnic_device_->tx_tail->raw,
+			  appnic_device_->tx_tail_copy.raw,
+			  read_mac_(APPNIC_DMA_INTERRUPT_ENABLE),
+			  read_mac_(APPNIC_DMA_INTERRUPT_STATUS),
+			  readl((APP3XX_VIC_BASE + VICIRQSTATUS)),
+			  readl((APP3XX_VIC_BASE + VICRAWINTR)),
+			  readl((APP3XX_VIC_BASE + VICINTENABLE)),
+			  read_mac_(APPNIC_DMA_TX_TAIL_POINTER_ADDRESS),
+			  tx_tpa_real_, *((unsigned int *) tx_tpa_virt_));
+
+	time_in_rx_max_ = 0;
+	time_in_rx_min_ = 0xffffffff;
+	rx_packet_size_max_ = 0;
+	rx_packet_size_min_ = 0xffffffff;
+	total_rx_bytes_ = 0;
+	total_rx_packets_handled_ = 1;
+	total_rx_time_ = 0;
+	max_rx_packets_handled_ = 0;
+	total_rx_interrupts_ = 0;
+
+#ifdef LSINET_NAPI
+
+	receive_interrupts_ = 0;
+	total_polls_ = 0;
+
+#endif
+
+	time_in_tx_max_ = 0;
+	time_in_tx_min_ = 0xffffffff;
+	total_tx_time_ = 0;
+	total_tx_packets_ = 1;
+	jiffies_changed_ = 0;
+	recv_t1_min_ = 0xffffffff;
+	recv_t2_min_ = 0xffffffff;
+	recv_t3_min_ = 0xffffffff;
+	recv_t1_max_ = 0;
+	recv_t2_max_ = 0;
+	recv_t3_max_ = 0;
+	recv_t1_tot_ = 0;
+	recv_t2_tot_ = 0;
+	recv_t3_tot_ = 0;
+	total_rx_packets_sent_up_ = 1;
+
+#else
+
+	length_ = sprintf(page, "-- appnic.c -- Profiling is disabled\n");
+
+#endif
+
+	/* that's all */
+	return length_;
+
+}
+
+/*
+  ----------------------------------------------------------------------
+  lsinet_init
+*/
+
+int
+lsinet_init(void)
+{
+	int rc = 0;
+	struct net_device *device;
+	struct device_node *np = NULL;
+	const u32 *field;
+	appnic_device_t *appnic_device;
+
+	TRACE_BEGINNING();
+
+	/* Allocate space for the device. */
+	device = alloc_etherdev(sizeof(appnic_device_t));
+	if ((struct net_device *) 0 == device) {
+		ERROR_PRINT("Couldn't allocate net device.");
+		rc = -ENOMEM;
+		goto out;
+	}
+
+	this_net_device = device;	/* For /proc/reads. */
+	appnic_device = (appnic_device_t *) netdev_priv(device);
+
+	/*
+	   Get the physical addresses, interrupt number, etc. from the
+	   device tree.  If no entry exists (older boot loader...) just
+	   use the pre-devicetree method.
+	 */
+
+	np = of_find_node_by_type(np, "network");
+
+	while (np && !of_device_is_compatible(np, "acp-femac"))
+		np = of_find_node_by_type(np, "network");
+
+	if (np) {
+		u64 value64;
+		u32 value32;
+		int length;
+
+		field = of_get_property(np, "enabled", NULL);
+
+		if (!field || (field && (0 == *field))) {
+			ERROR_PRINT("Not Enabled\n");
+			rc = -EINVAL;
+			goto out;
+		}
+
+		field = of_get_property(np, "reg", NULL);
+
+		if (!field) {
+			ERROR_PRINT("Couldn't get \"reg\" property.\n");
+			rc = -EINVAL;
+			goto out;
+		}
+
+		value64 = of_translate_address(np, field);
+		value32 = field[1];
+		field += 2;
+		rx_base = (unsigned long) ioremap(value64, value32);
+		appnic_device->rx_base = rx_base;
+		value64 = of_translate_address(np, field);
+		value32 = field[1];
+		field += 2;
+		tx_base = (unsigned long) ioremap(value64, value32);
+		appnic_device->tx_base = tx_base;
+		value64 = of_translate_address(np, field);
+		value32 = field[1];
+		field += 2;
+		dma_base = (unsigned long) ioremap(value64, value32);
+		appnic_device->dma_base = dma_base;
+
+		field = of_get_property(np, "interrupts", NULL);
+
+		if (field)
+			appnic_device->interrupt = field[0];
+		else
+			goto device_tree_failed;
+
+		field = of_get_property(np, "mdio-clock", NULL);
+
+		if (!field)
+			goto device_tree_failed;
+		else
+			appnic_device->mdio_clock = field[0];
+
+		field = of_get_property(np, "phy-address", NULL);
+
+		if (!field)
+			goto device_tree_failed;
+		else
+			appnic_device->phy_address = field[0];
+
+		field = of_get_property(np, "ad-value", NULL);
+
+		if (!field)
+			goto device_tree_failed;
+		else
+			appnic_device->ad_value = field[0];
+
+		field = of_get_property(np, "mac-address", &length);
+
+		if (!field || 6 != length) {
+			goto device_tree_failed;
+		} else {
+			int i;
+			u8 *value;
+
+			value = (u8 *) field;
+
+			for (i = 0; i < 6; ++i) {
+				/*printk("value[%d] = 0x%2x\n", i, value[i]); */
+				appnic_device->mac_addr[i] = value[i];
+			}
+		}
+
+		memcpy(device->dev_addr, &appnic_device->mac_addr[0], 6);
+		memcpy(device->perm_addr, &appnic_device->mac_addr[0], 6);
+
+		goto device_tree_succeeded;
+
+device_tree_failed:
+		ERROR_PRINT("Reading Device Tree Failed\n");
+		iounmap((void *) rx_base);
+		iounmap((void *) tx_base);
+		iounmap((void *) dma_base);
+		rc = -EINVAL;
+		goto out;
+
+	} else {
+		unsigned char ethaddr_string[20];
+#ifdef CONFIG_LSI_UBOOTENV
+		if (0 != ubootenv_get("ethaddr", ethaddr_string)) {
+			ERROR_PRINT("Could not read ethernet address!\n");
+			return -EBUSY;
+		} else {
+			char *string;
+			int i = 0;
+			u8 mac_address[6];
+
+			string = ethaddr_string;
+
+			while ((0 != string) && (6 > i)) {
+				char *value;
+
+				value = strsep(&string, ":");
+				mac_address[i++] =
+				    simple_strtoul(value, NULL, 16);
+			}
+
+			memcpy(device->dev_addr, mac_address, 6);
+			memcpy(device->perm_addr, mac_address, 6);
+			device->addr_len = 6;
+		}
+
+		printk("LSI FEMAC: Using Static Addresses and Interrupts.\n");
+		rx_base = (unsigned long) ioremap(0x002000480000ULL, 0x1000);
+		appnic_device->rx_base = rx_base;
+		tx_base = (unsigned long) ioremap(0x002000481000ULL, 0x1000);
+		appnic_device->tx_base = tx_base;
+		dma_base = (unsigned long) ioremap(0x002000482000ULL, 0x1000);
+		appnic_device->dma_base = dma_base;
+		appnic_device->interrupt = 33;
+#else
+		/* Neither dtb info nor ubootenv driver found. */
+		ERROR_PRINT("Could not read ethernet address!\n");
+		return -EBUSY;
+#endif
+	}
+
+device_tree_succeeded:
+
+#ifdef __APPNIC_C_PROFILE__
+	writel(0xffffffff, (TIMER7_BASE + TIMER_n_LOAD));
+	writel(0xffffffff, (TIMER7_BASE + TIMER_n_VALUE));
+	writel((TIMER_n_CONTROL_ENABLE |
+		TIMER_n_CONTROL_MODE |
+		TIMER_n_CONTROL_SIZE), (TIMER7_BASE + TIMER_n_CONTROL));
+#endif				/* __APPNIC_C_PROFILE__ */
+
+	/* Initialize the device. */
+	rc = appnic_init(device);
+	if (0 != rc) {
+		ERROR_PRINT("appnic_init( ) failed: %d\n", rc);
+		rc = -ENODEV;
+		goto out;
+	}
+
+	strcpy(this_net_device->name, "eth%d");
+
+	/* Register the device. */
+
+	rc = register_netdev(this_net_device);
+	if (0 != rc) {
+		ERROR_PRINT("register_netdev() failed: %d\n", rc);
+		rc = -ENODEV;
+		goto out;
+	}
+
+	/* Create the /proc entry. */
+	create_proc_read_entry("driver/appnic", 0, NULL,
+			       appnic_read_proc_, NULL);
+
+out:
+	TRACE_ENDING();
+	return rc;
+}
+
+module_init(lsinet_init);
+
+/*
+  ----------------------------------------------------------------------
+  lsinet_exit
+*/
+
+void __exit
+lsinet_exit(void)
+{
+	TRACE_BEGINNING();
+	remove_proc_entry("driver/appnic", NULL);
+	unregister_netdev(this_net_device);
+	TRACE_ENDING();
+
+	return;
+}
+
+module_exit(lsinet_exit);
-- 
1.7.9.7

