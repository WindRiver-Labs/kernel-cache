From e93c716277539b4d008ca6125a93c34b751e2e07 Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Thu, 31 Jan 2013 15:10:21 +0800
Subject: [PATCH 04/16] LSI:ACP34xx:Cleanup ncr driver

Cleanup acp34xx's ncr driver with following modification:
1.Remove unnecessary debug macros.
2.Fix code indent issues.
3.Remove dead code.

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/lsi/acp/ncr.c |   58 ++++++++++++++++++++-----------------------------
 drivers/lsi/acp/ncr.h |    2 +-
 2 files changed, 25 insertions(+), 35 deletions(-)

diff --git a/drivers/lsi/acp/ncr.c b/drivers/lsi/acp/ncr.c
index 9203f55..b65e670 100644
--- a/drivers/lsi/acp/ncr.c
+++ b/drivers/lsi/acp/ncr.c
@@ -20,7 +20,7 @@
  * MA 02111-1307 USA
  */
 
-#include <asm/io.h>
+#include <linux/io.h>
 #include <linux/module.h>
 
 #include "ncr.h"
@@ -40,15 +40,15 @@ typedef union {
 		unsigned long cfg_cmpl_int_enable:1;
 		unsigned long cmd_type:4;
 		unsigned long dbs:16;
-	} __attribute__ ((packed)) bits;
-} __attribute__ ((packed)) command_data_register_0_t;
+	} __packed bits;
+} __packed command_data_register_0_t;
 
 typedef union {
 	unsigned long raw;
 	struct {
 		unsigned long target_address:32;
-	} __attribute__ ((packed)) bits;
-} __attribute__ ((packed)) command_data_register_1_t;
+	} __packed bits;
+} __packed command_data_register_1_t;
 
 typedef union {
 	unsigned long raw;
@@ -56,15 +56,15 @@ typedef union {
 		unsigned long unused:16;
 		unsigned long target_node_id:8;
 		unsigned long target_id_address_upper:8;
-	} __attribute__ ((packed)) bits;
-} __attribute__ ((packed)) command_data_register_2_t;
+	} __packed bits;
+} __packed command_data_register_2_t;
 
 /*
   ----------------------------------------------------------------------
   ncr_register_read
 */
 
-static __inline__ unsigned long
+static inline unsigned long
 ncr_register_read(unsigned *address)
 {
 	unsigned long value;
@@ -79,7 +79,7 @@ ncr_register_read(unsigned *address)
   ncr_register_write
 */
 
-static __inline__ void
+static inline void
 ncr_register_write(const unsigned value, unsigned *address)
 {
 	out_be32(address, value);
@@ -99,8 +99,7 @@ ncr_register_write(const unsigned value, unsigned *address)
 */
 
 int
-ncr_read(unsigned long region, unsigned long address, int number,
-	 void *buffer)
+ncr_read(unsigned long region, unsigned long address, int number, void *buffer)
 {
 	command_data_register_0_t cdr0;
 	command_data_register_1_t cdr1;
@@ -136,11 +135,6 @@ ncr_read(unsigned long region, unsigned long address, int number,
 	*/
 
 	/* TODO: Handle failure cases. */
-#if 0
-	while (0x80000000 ==
-	       (ncr_register_read((unsigned *) (NCA + 0xf0)) & 0x80000000))
-		;
-#else
 	{
 		volatile unsigned long value;
 
@@ -148,7 +142,6 @@ ncr_read(unsigned long region, unsigned long address, int number,
 			value = ncr_register_read((unsigned *) (NCA + 0xf0));
 		} while (0x80000000 == (value & 0x80000000));
 	}
-#endif
 
 	/*
 	  Copy data words to the buffer.
@@ -163,8 +156,7 @@ ncr_read(unsigned long region, unsigned long address, int number,
 	}
 
 	if (0 < number) {
-		unsigned long temp =
-			ncr_register_read((unsigned *) address);
+		unsigned long temp = ncr_register_read((unsigned *) address);
 		memcpy((void *) buffer, &temp, number);
 	}
 
@@ -176,16 +168,16 @@ EXPORT_SYMBOL(ncr_read);
   is_asic
 */
 
-int is_asic(void)
+int
+is_asic(void)
 {
 #ifdef CONFIG_ACPISS
 	return 0;
 #else
 	unsigned long nca_config;
 
-	if (0 == ncr_read(NCP_REGION_ID(0x16, 0xff), 0x10, 4, &nca_config)) {
+	if (0 == ncr_read(NCP_REGION_ID(0x16, 0xff), 0x10, 4, &nca_config))
 		return (0 == (nca_config & 0x80000000));
-	}
 
 	return -1;
 #endif
@@ -198,8 +190,7 @@ EXPORT_SYMBOL(is_asic);
 */
 
 int
-ncr_write(unsigned long region, unsigned long address, int number,
-	  void *buffer)
+ncr_write(unsigned long region, unsigned long address, int number, void *buffer)
 {
 	command_data_register_0_t cdr0;
 	command_data_register_1_t cdr1;
@@ -247,9 +238,8 @@ ncr_write(unsigned long region, unsigned long address, int number,
 	cdr0.raw = 0;
 	cdr0.bits.start_done = 1;
 
-	if (0xff == cdr2.bits.target_id_address_upper) {
+	if (0xff == cdr2.bits.target_id_address_upper)
 		cdr0.bits.local_bit = 1;
-	}
 
 	cdr0.bits.cmd_type = 5;
 	/* TODO: Verify number... */
@@ -263,7 +253,7 @@ ncr_write(unsigned long region, unsigned long address, int number,
 
 	/* TODO: Handle failure cases. */
 	while (0x80000000 ==
-	       (ncr_register_read((unsigned *) (NCA + 0xf0)) & 0x80000000))
+		(ncr_register_read((unsigned *) (NCA + 0xf0)) & 0x80000000))
 		;
 
 	return 0;
@@ -276,11 +266,11 @@ EXPORT_SYMBOL(ncr_write);
 */
 
 int
-ncr_init( void )
+ncr_init(void)
 {
-    /* We need this to be a module so that the functions can be exported
-     * as module symbols.
-     */
+	/* We need this to be a module so that the functions can be exported
+	 * as module symbols.
+	 */
 	nca_reg = ioremap(0x2000520000ull, 0x2000);
 	if (!nca_reg) {
 		pr_err("Can't iomap for nca registers\n");
@@ -290,7 +280,7 @@ ncr_init( void )
 	return 0;
 }
 
-postcore_initcall(ncr_init );
+postcore_initcall(ncr_init);
 
 /*
   ----------------------------------------------------------------------
@@ -298,12 +288,12 @@ postcore_initcall(ncr_init );
 */
 
 void __exit
-ncr_exit( void )
+ncr_exit(void)
 {
 	iounmap(nca_reg);
 }
 
-module_exit( ncr_exit );
+module_exit(ncr_exit);
 
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Register Ring access for LSI's ACP board");
diff --git a/drivers/lsi/acp/ncr.h b/drivers/lsi/acp/ncr.h
index 291c07f..fe468f9 100644
--- a/drivers/lsi/acp/ncr.h
+++ b/drivers/lsi/acp/ncr.h
@@ -23,7 +23,7 @@
 
 #ifndef NCP_REGION_ID
 #define NCP_REGION_ID(node, target) \
-(unsigned long) ((((node) & 0xffff) << 16) | ((target) & 0xffff))
+(unsigned long)((((node) & 0xffff) << 16) | ((target) & 0xffff))
 #endif
 
 #ifndef NCP_NODE_ID
-- 
1.7.9.7

