From df8ef7058f38c8367643411da5090c79518692a0 Mon Sep 17 00:00:00 2001
From: Guoqing Jiang <Guoqing.Jiang@windriver.com>
Date: Thu, 5 Sep 2013 10:32:43 +0800
Subject: [PATCH 11/20] dma: add ability to request channel by name

Comm 32fdd0a3324588ba9a78d6e037dd079bef4111c6 from arago tree
git://arago-project.org/git/projects/linux-keystone.git releases/03.00.00.11/master

This patch adds a new dma_request_channel_by_name() interface that allows
drivers to use a simpler name match model.  This rides alongside the current
filter function model.

Signed-off-by: Cyril Chemparathy <cyril@ti.com>
Signed-off-by: Guoqing Jiang <Guoqing.Jiang@windriver.com>
---
 drivers/dma/dmaengine.c   | 12 ++++++++++--
 include/linux/dmaengine.h | 10 ++++++++--
 2 files changed, 18 insertions(+), 4 deletions(-)

diff --git a/drivers/dma/dmaengine.c b/drivers/dma/dmaengine.c
index 93f7992..6f67968 100644
--- a/drivers/dma/dmaengine.c
+++ b/drivers/dma/dmaengine.c
@@ -468,6 +468,7 @@ static void dma_channel_rebalance(void)
 
 static struct dma_chan *private_candidate(const dma_cap_mask_t *mask,
 					  struct dma_device *dev,
+					  const char *name,
 					  dma_filter_fn fn, void *fn_param)
 {
 	struct dma_chan *chan;
@@ -492,6 +493,13 @@ static struct dma_chan *private_candidate(const dma_cap_mask_t *mask,
 				 __func__, dma_chan_name(chan));
 			continue;
 		}
+		if (name) {
+			if (!chan->name || strcmp(name, chan->name)) {
+				pr_debug("%s: %s name mismatch\n",
+					__func__, dma_chan_name(chan));
+				continue;
+			}
+		}
 		if (fn && !fn(chan, fn_param)) {
 			pr_debug("%s: %s filter said false\n",
 				 __func__, dma_chan_name(chan));
@@ -510,7 +518,7 @@ static struct dma_chan *private_candidate(const dma_cap_mask_t *mask,
  * @fn_param: opaque parameter to pass to dma_filter_fn
  */
 struct dma_chan *__dma_request_channel(const dma_cap_mask_t *mask,
-				       dma_filter_fn fn, void *fn_param)
+			const char *name, dma_filter_fn fn, void *fn_param)
 {
 	struct dma_device *device, *_d;
 	struct dma_chan *chan = NULL;
@@ -519,7 +527,7 @@ struct dma_chan *__dma_request_channel(const dma_cap_mask_t *mask,
 	/* Find a channel */
 	mutex_lock(&dma_list_mutex);
 	list_for_each_entry_safe(device, _d, &dma_device_list, global_node) {
-		chan = private_candidate(mask, device, fn, fn_param);
+		chan = private_candidate(mask, device, name, fn, fn_param);
 		if (chan) {
 			/* Found a suitable channel, try to grab, prep, and
 			 * return it.  We first set DMA_PRIVATE to disable
diff --git a/include/linux/dmaengine.h b/include/linux/dmaengine.h
index 96d3e4a..6b257a3 100644
--- a/include/linux/dmaengine.h
+++ b/include/linux/dmaengine.h
@@ -269,6 +269,7 @@ struct dma_chan_percpu {
  * @private: private data for certain client-channel associations
  */
 struct dma_chan {
+	const char *name;
 	struct dma_device *device;
 	dma_cookie_t cookie;
 	dma_cookie_t completed_cookie;
@@ -968,6 +969,7 @@ enum dma_status dma_sync_wait(struct dma_chan *chan, dma_cookie_t cookie);
 enum dma_status dma_wait_for_async_tx(struct dma_async_tx_descriptor *tx);
 void dma_issue_pending_all(void);
 struct dma_chan *__dma_request_channel(const dma_cap_mask_t *mask,
+					const char *name,
 					dma_filter_fn fn, void *fn_param);
 struct dma_chan *dma_request_slave_channel(struct device *dev, const char *name);
 void dma_release_channel(struct dma_chan *chan);
@@ -980,6 +982,7 @@ static inline void dma_issue_pending_all(void)
 {
 }
 static inline struct dma_chan *__dma_request_channel(const dma_cap_mask_t *mask,
+					      const char *name,
 					      dma_filter_fn fn, void *fn_param)
 {
 	return NULL;
@@ -1001,7 +1004,10 @@ void dma_async_device_unregister(struct dma_device *device);
 void dma_run_dependencies(struct dma_async_tx_descriptor *tx);
 struct dma_chan *dma_find_channel(enum dma_transaction_type tx_type);
 struct dma_chan *net_dma_find_channel(void);
-#define dma_request_channel(mask, x, y) __dma_request_channel(&(mask), x, y)
+#define dma_request_channel(mask, x, y)				\
+	__dma_request_channel(&(mask), NULL, x, y)
+#define dma_request_channel_by_name(mask, name)			\
+	__dma_request_channel(&(mask), name, NULL, NULL)
 #define dma_request_slave_channel_compat(mask, x, y, dev, name) \
 	__dma_request_slave_channel_compat(&(mask), x, y, dev, name)
 
@@ -1016,7 +1022,7 @@ static inline struct dma_chan
 	if (chan)
 		return chan;
 
-	return __dma_request_channel(mask, fn, fn_param);
+	return __dma_request_channel(mask, name, fn, fn_param);
 }
 
 /* --- Helper iov-locking functions --- */
-- 
1.8.4.93.g57e4c17

