From c3da8fcd4e968eb0d2ab7258357998c3c58eff7d Mon Sep 17 00:00:00 2001
From: Guoqing Jiang <Guoqing.Jiang@windriver.com>
Date: Thu, 18 Jul 2013 09:25:15 +0800
Subject: [PATCH 45/61] dma: add ability to request channel by name

Comm 32fdd0a3324588ba9a78d6e037dd079bef4111c6 from arago tree
git://arago-project.org/git/projects/linux-keystone.git releases/03.00.00.11/master

This patch adds a new dma_request_channel_by_name() interface that allows
drivers to use a simpler name match model.  This rides alongside the current
filter function model.

Signed-off-by: Cyril Chemparathy <cyril@ti.com>
Signed-off-by: Guoqing Jiang <Guoqing.Jiang@windriver.com>
---
 drivers/dma/dmaengine.c   |   17 +++++++++++++----
 include/linux/dmaengine.h |   14 ++++++++++----
 2 files changed, 23 insertions(+), 8 deletions(-)

diff --git a/drivers/dma/dmaengine.c b/drivers/dma/dmaengine.c
index 6c87d67..1bb5e6b 100644
--- a/drivers/dma/dmaengine.c
+++ b/drivers/dma/dmaengine.c
@@ -457,8 +457,9 @@ static void dma_channel_rebalance(void)
 		}
 }
 
-static struct dma_chan *private_candidate(dma_cap_mask_t *mask, struct dma_device *dev,
-					  dma_filter_fn fn, void *fn_param)
+static struct dma_chan *
+private_candidate(dma_cap_mask_t *mask, struct dma_device *dev,
+		  const char *name, dma_filter_fn fn, void *fn_param)
 {
 	struct dma_chan *chan;
 
@@ -482,6 +483,13 @@ static struct dma_chan *private_candidate(dma_cap_mask_t *mask, struct dma_devic
 				 __func__, dma_chan_name(chan));
 			continue;
 		}
+		if (name) {
+			if (!chan->name || strcmp(name, chan->name)) {
+				pr_debug("%s: %s name mismatch\n",
+					 __func__, dma_chan_name(chan));
+				continue;
+			}
+		}
 		if (fn && !fn(chan, fn_param)) {
 			pr_debug("%s: %s filter said false\n",
 				 __func__, dma_chan_name(chan));
@@ -499,7 +507,8 @@ static struct dma_chan *private_candidate(dma_cap_mask_t *mask, struct dma_devic
  * @fn: optional callback to disposition available channels
  * @fn_param: opaque parameter to pass to dma_filter_fn
  */
-struct dma_chan *__dma_request_channel(dma_cap_mask_t *mask, dma_filter_fn fn, void *fn_param)
+struct dma_chan *__dma_request_channel(dma_cap_mask_t *mask, const char *name,
+				       dma_filter_fn fn, void *fn_param)
 {
 	struct dma_device *device, *_d;
 	struct dma_chan *chan = NULL;
@@ -508,7 +517,7 @@ struct dma_chan *__dma_request_channel(dma_cap_mask_t *mask, dma_filter_fn fn, v
 	/* Find a channel */
 	mutex_lock(&dma_list_mutex);
 	list_for_each_entry_safe(device, _d, &dma_device_list, global_node) {
-		chan = private_candidate(mask, device, fn, fn_param);
+		chan = private_candidate(mask, device, name, fn, fn_param);
 		if (chan) {
 			/* Found a suitable channel, try to grab, prep, and
 			 * return it.  We first set DMA_PRIVATE to disable
diff --git a/include/linux/dmaengine.h b/include/linux/dmaengine.h
index d1d6ef2..2282f4e 100644
--- a/include/linux/dmaengine.h
+++ b/include/linux/dmaengine.h
@@ -269,6 +269,7 @@ struct dma_chan_percpu {
  * @private: private data for certain client-channel associations
  */
 struct dma_chan {
+	const char *name;
 	struct dma_device *device;
 	dma_cookie_t cookie;
 	dma_cookie_t completed_cookie;
@@ -960,7 +961,8 @@ enum dma_status dma_sync_wait(struct dma_chan *chan, dma_cookie_t cookie);
 #ifdef CONFIG_DMA_ENGINE
 enum dma_status dma_wait_for_async_tx(struct dma_async_tx_descriptor *tx);
 void dma_issue_pending_all(void);
-struct dma_chan *__dma_request_channel(dma_cap_mask_t *mask, dma_filter_fn fn, void *fn_param);
+struct dma_chan *__dma_request_channel(dma_cap_mask_t *mask, const char *name,
+				       dma_filter_fn fn, void *fn_param);
 void dma_release_channel(struct dma_chan *chan);
 #else
 static inline enum dma_status dma_wait_for_async_tx(struct dma_async_tx_descriptor *tx)
@@ -970,8 +972,9 @@ static inline enum dma_status dma_wait_for_async_tx(struct dma_async_tx_descript
 static inline void dma_issue_pending_all(void)
 {
 }
-static inline struct dma_chan *__dma_request_channel(dma_cap_mask_t *mask,
-					      dma_filter_fn fn, void *fn_param)
+static inline struct dma_chan *
+__dma_request_channel(dma_cap_mask_t *mask, const char *name, dma_filter_fn fn,
+		      void *fn_param)
 {
 	return NULL;
 }
@@ -987,7 +990,10 @@ void dma_async_device_unregister(struct dma_device *device);
 void dma_run_dependencies(struct dma_async_tx_descriptor *tx);
 struct dma_chan *dma_find_channel(enum dma_transaction_type tx_type);
 struct dma_chan *net_dma_find_channel(void);
-#define dma_request_channel(mask, x, y) __dma_request_channel(&(mask), x, y)
+#define dma_request_channel(mask, x, y)			\
+	__dma_request_channel(&(mask), NULL, x, y)
+#define dma_request_channel_by_name(mask, name)			\
+	__dma_request_channel(&(mask), name, NULL, NULL)
 
 /* --- Helper iov-locking functions --- */
 
-- 
1.7.5.4

