From fff438069d37c68cb6fc1490269dbcce89abe121 Mon Sep 17 00:00:00 2001
From: Guoqing Jiang <Guoqing.Jiang@windriver.com>
Date: Tue, 23 Jul 2013 17:40:49 +0800
Subject: [PATCH 52/61] net: keystone: add ethernet support for keystone
 platform

Keystone introduced a new ethernet subsystem for keystone platform since it owns
a different IP which doesn't used for other TI chips, and this IP is named as
network coprocessor (NETCP).

NETCP is a hardware accelerator that processes data packets with a main focus on
processing Ethernet packets. NETCP has two gigabit Ethernet (GbE) modules to send
and receive packets from an IEEE 802.3 compliant network. The NETCP also includes
a packet accelerator (PA) to perform packet classification operations such as header
matching, and packet modification operations such as checksum generation. The NETCP
also provides a security accelerator (SA) to encrypt and decrypt data packets.
The NETCP can receive packets from the Ethernet modules, or packets can be delivered
to the NETCP through packet DMA from the DSP or another supported peripheral.

Refer to the following commits from arago tree
git://arago-project.org/git/projects/linux-keystone.git releases/03.00.00.11/master

b843ecb net: keystone: xge: add sysfs entry to support resetting cpsw stats
7904c7d net: keystone: cpsw: add sysfs entry to support resetting cpsw stats
e93d908 net: keystone: xge: change XGMII link type defines to avoid conflict with SGMII
354a923 net: keystone: xge: add support of ethtool get and set settings
4b9b287 net: keystone: xge: add sysfs entries to support cpsw configuration from user space
a26e635 net: keystone: corrected port tx pri map field shift in sysfs entry
cd7184a net: keystone: add ethtool get and set settings
918f583 net: keystone: add sysfs entries to support cpsw configuration from user space
579aff4 net: keystone: add support of sysfs ale table store and additional ale control show/store
27b4381 net: keystone: disable VLAN-awareness in the 1G and 10G switches
a1e61ed net: keystone: add multi interface support for qos module
2b364d7 net: keystone: update pa timestamp handling
4a655b7 net: keystone: update 10g switch ioctl handling
336cbd7 net: keystone: update 1g switch ioctl handling
a124d93 net: keystone: update ioctl handling in net core engine
fffbb3c [tmp] net: keystone: patch to remove serdes initialization
fbd4f1c net: keystone: enable mac-phy mode with no mdio
973849b net: keystone: xge: add 10ge kernel config
254b028 net: keystone: xge: add macro to facilitate checking xgmii link type
71e66d1 net: keystone: xge: correct statistics name string
4887f41 net: keystone: xge: remove PCS-R configurations
916a046 net: keystone: Enhancement to PA timestamping support
352ea02 net: keystone: xge: add support 10GE subsystem
59ebc45 net: davinci_mdio: use of_mdiobus_register api
d54b832 net: davinci_mdio - fix to work with run time pm
e2c5cc9 net: keystone: xge: include 10GE support in the keystone build
950ee7a net: keystone: xge: add support of 10GE switch subsystem
fa28779 net: keystone: xge: add support 10GE PCS-R and serdes config
bf215fa net: keystone: add support keystone xge mdio
f474a42 net: keystone: xge: add XGMII link type defines
a116784 net: keystone: add support of streaming interface configuration.
7998aef net: keystone: add function to find netcp's registered module instance.
db1f6fe net: keystone: fix dma addressing in scatter list
9b5e17c net: keystone: use of_phy_connect api in ethss
95c495d net: keystone: add keystone 2 serdes init
09f24e7 net: keystone: support 4 ports in streaming switch
28bcaf5 net: keystone: forward ip traffic in promisc mode
fc84960 net: keystone: don't add entries during host initialization
bfb949c net: keystone: force delete interface specific address on ifconfig down
e7b185d net: keystone: use of_get_child_by_name()
afd5f37 net: keystone: stop using obsolete kmap_skb_frag()
0100b0f net: keystone: Add support for IPSec NAT-T in net SA module
9e5ea98 net: keystone: changes in pa to get promiscuous mode working
e5a06df net: keystone: changes needed to add promiscuous support
c4a8d9b net: keystone: changes to add promiscuous support in keystone-net-core
940aa77 net: keystone: disable advertisement of sctp checksum offload
bcb51b0 net: keystone: add support for multiple interface support in PA module
82be1a4 net: keystone: add multi interface support for the switch
be4a7f3 net: keystone: add multi interface support for net core
d0cbdcd net: keystone: add an sgmii api to get per port link state
efb6950 net: keystone: add multi interface support for sa module
6ed59f1 net: keystone: add multi interface support for qos module
f7753bb net: keystone: Fix bug in TCP/UDP Software checksum offload
b30ff17 net: keystone: ethss: use snprintf to prevent possible buffer overflow
5bdf792 net: keystone: ethss: use strncpy to prevent possible buffer overflow
48c4fbf net: keystone: Create a kmem_cache for RX netcp_packet structures
7ab70d7 net: keystone: Fix potential NULL pointer dereference
c3bfce3 net: keystone: Fix ndo_do_ioctl method return status
8286429 net: keystone: Fix checksum offload for VLANs
7766636 net: keystone: Enhance support of mqprio qdisc
f80193c net: keystone: Turn on checksum offload features by default
884257b net: keystone: Improve TX flow control handling
0c1391a net: keystone: Collect TX-related functions together
dd9ef57 net: keystone: Use common methods to open/close txpipes
c8777d8 net: keystone: Use common methods to open/close txpipes
25bd57b net: keystone: Use common methods to open/close txpipes
fdef116 net: keystone: Use common methods to open/close txpipes
b8e479a net: keystone: Add common methods for opening/closing txpipes
aae02b0 net: keystone: use of_get_child_by_name()
c916e7f net: keystone: enable copy of rx short frames
c4a2b83 net: keystone: update clock handling for ethernet subsystem
a802f7d net: keystone: modify clock handling for packet accelerator
7af5c38 net: keystone: enable networking for keystone devices
34d29ef net: keystone: update driver to use kmap/kunmap atomic
18cbd57 net: keystone: Fetch bits 47-32 of RX timestamp from its new location
fa97fb8 net: keystone: Fix (again!) race condition in packet submission
40dc120 net: keystone: support distinct destination for IPSec packets
cbd4255 net: keystone: fix race submitting PA config commands
f823a46 net: keystone: add netcp_setup_tc() to support mqprio qdisc
fc5977f net: keystone: Fix possible failure to poll for TX completions
93eb7a2 net: keystone: Fill in dma_queue in tx_pipe
33fc47c net: keystone: Add software checksum/crc "offload" support
ba4f54a net: keystone: Add NETCP QoS plug-in module
11c5df9 net: keystone: Multi-queue network interface support
5cab93a net: keystone: Implement Checksum Offload in PA
748d392 net: keystone: NETCP Plug-in module support
73e2b57 net:keystone: add security accelerator module
44b82c9 net:keystone: add packet accelerator driver
f26e4d9 net:keystone: add ethernet subsystem driver
bb87363 net:keystone: add sgmii driver
e9bf08b net:keystone: add net core driver

Signed-off-by: Guoqing Jiang <Guoqing.Jiang@windriver.com>
---
 .../devicetree/bindings/net/keystone-net.txt       |   43 +
 drivers/net/ethernet/ti/Kconfig                    |   74 +-
 drivers/net/ethernet/ti/Makefile                   |   14 +-
 drivers/net/ethernet/ti/cpmac.c                    |   14 +-
 drivers/net/ethernet/ti/cpsw.c                     |  719 +++++-
 drivers/net/ethernet/ti/cpsw_ale.c                 |  898 +++++++-
 drivers/net/ethernet/ti/cpsw_ale.h                 |   58 +-
 drivers/net/ethernet/ti/cpts.c                     |  424 ++++
 drivers/net/ethernet/ti/cpts.h                     |  145 ++
 drivers/net/ethernet/ti/davinci_cpdma.c            |   17 +-
 drivers/net/ethernet/ti/davinci_emac.c             |  221 ++-
 drivers/net/ethernet/ti/davinci_mdio.c             |   87 +-
 drivers/net/ethernet/ti/keystone_ethss.c           | 2377 ++++++++++++++++++
 drivers/net/ethernet/ti/keystone_net.h             |  224 ++
 drivers/net/ethernet/ti/keystone_net_core.c        | 2056 ++++++++++++++++
 drivers/net/ethernet/ti/keystone_net_sa.c          |  253 ++
 drivers/net/ethernet/ti/keystone_pa.c              | 2473 +++++++++++++++++++
 drivers/net/ethernet/ti/keystone_pa.h              |  741 ++++++
 drivers/net/ethernet/ti/keystone_pasahost.h        |  390 +++
 drivers/net/ethernet/ti/keystone_qos.c             |  300 +++
 drivers/net/ethernet/ti/keystone_sgmii.c           |  307 +++
 drivers/net/ethernet/ti/keystone_xgemdio.c         |  525 ++++
 drivers/net/ethernet/ti/keystone_xgepcsr.c         |  268 +++
 drivers/net/ethernet/ti/keystone_xgess.c           | 2524 ++++++++++++++++++++
 drivers/net/ethernet/ti/tlan.c                     |   13 +-
 25 files changed, 14908 insertions(+), 257 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/net/keystone-net.txt
 create mode 100644 drivers/net/ethernet/ti/cpts.c
 create mode 100644 drivers/net/ethernet/ti/cpts.h
 create mode 100644 drivers/net/ethernet/ti/keystone_ethss.c
 create mode 100644 drivers/net/ethernet/ti/keystone_net.h
 create mode 100644 drivers/net/ethernet/ti/keystone_net_core.c
 create mode 100644 drivers/net/ethernet/ti/keystone_net_sa.c
 create mode 100644 drivers/net/ethernet/ti/keystone_pa.c
 create mode 100644 drivers/net/ethernet/ti/keystone_pa.h
 create mode 100644 drivers/net/ethernet/ti/keystone_pasahost.h
 create mode 100644 drivers/net/ethernet/ti/keystone_qos.c
 create mode 100644 drivers/net/ethernet/ti/keystone_sgmii.c
 create mode 100644 drivers/net/ethernet/ti/keystone_xgemdio.c
 create mode 100644 drivers/net/ethernet/ti/keystone_xgepcsr.c
 create mode 100644 drivers/net/ethernet/ti/keystone_xgess.c

diff --git a/Documentation/devicetree/bindings/net/keystone-net.txt b/Documentation/devicetree/bindings/net/keystone-net.txt
new file mode 100644
index 0000000..b64f74d
--- /dev/null
+++ b/Documentation/devicetree/bindings/net/keystone-net.txt
@@ -0,0 +1,43 @@
+This document describes the device tree bindings associated with the
+keystone network driver support.
+
+reg:		the register start address and the size that will be
+		used by the driver. The second index is for the efuse
+		mac address
+tx-channel:	the packet dma channel name associated with tx
+tx-queue-depth: the number of descriptors to be used
+rx-channel:	the packet dma channel name associated with rx
+rx-queue-depth: there can be at present a maximum of 4 queues per packet
+		dma channel. We can specify the number of descriptors for
+		each queue
+rx-buffer-size: For each receive queue, we can specify a buffer size.
+efuse-mac:	If this is 1, then the mac address is obtained from the
+		device efuse mac address register
+local-mac-address:the driver is designed to use the of_get_mac_address api
+		  only if efuse-mac is 0. When efuse-mac is 0, the mac address
+		  is obtained from local-mac-address.
+
+The keystone network device can open other modules such as cpsw or pa.
+
+Below we provide an example.
+
+netcp: netcp@2090000 {
+			reg = <0x2090000 0xf00
+				0x2620110 0x8>;
+			compatible = "ti,keystone-netcp";
+
+			tx-channel = "nettx";
+			tx-queue-depth = <128>;
+
+			rx-channel = "netrx";
+			rx-queue-depth = < 128 128 0 0>;
+			rx-buffer-size = <1500 4096 0 0>;
+
+			efuse-mac = <1>;
+			local-mac-address = [00 18 31 7e 3e 6e];
+
+			pa: pa@2000000 {
+				label = "keystone-pa";
+			};
+		};
+
diff --git a/drivers/net/ethernet/ti/Kconfig b/drivers/net/ethernet/ti/Kconfig
index b42252c..1f2c351 100644
--- a/drivers/net/ethernet/ti/Kconfig
+++ b/drivers/net/ethernet/ti/Kconfig
@@ -5,7 +5,7 @@
 config NET_VENDOR_TI
 	bool "Texas Instruments (TI) devices"
 	default y
-	depends on PCI || EISA || AR7 || (ARM && (ARCH_DAVINCI || ARCH_OMAP3))
+	depends on PCI || EISA || AR7 || (ARM && (ARCH_DAVINCI || ARCH_OMAP3 || SOC_AM33XX || ARCH_KEYSTONE))
 	---help---
 	  If you have a network (Ethernet) card belonging to this class, say Y
 	  and read the Ethernet-HOWTO, available from
@@ -32,7 +32,7 @@ config TI_DAVINCI_EMAC
 
 config TI_DAVINCI_MDIO
 	tristate "TI DaVinci MDIO Support"
-	depends on ARM && ( ARCH_DAVINCI || ARCH_OMAP3 )
+	depends on ARM && ( ARCH_DAVINCI || ARCH_OMAP3 || SOC_AM33XX || ARCH_KEYSTONE )
 	select PHYLIB
 	---help---
 	  This driver supports TI's DaVinci MDIO module.
@@ -42,7 +42,7 @@ config TI_DAVINCI_MDIO
 
 config TI_DAVINCI_CPDMA
 	tristate "TI DaVinci CPDMA Support"
-	depends on ARM && ( ARCH_DAVINCI || ARCH_OMAP3 )
+	depends on ARM && ( ARCH_DAVINCI || ARCH_OMAP3 || SOC_AM33XX )
 	---help---
 	  This driver supports TI's DaVinci CPDMA dma engine.
 
@@ -51,7 +51,7 @@ config TI_DAVINCI_CPDMA
 
 config TI_CPSW
 	tristate "TI CPSW Switch Support"
-	depends on ARM && (ARCH_DAVINCI || SOC_OMAPAM33XX)
+	depends on ARM && (ARCH_DAVINCI || SOC_AM33XX)
 	select TI_DAVINCI_CPDMA
 	select TI_DAVINCI_MDIO
 	---help---
@@ -60,6 +60,53 @@ config TI_CPSW
 	  To compile this driver as a module, choose M here: the module
 	  will be called cpsw.
 
+config TI_CPTS
+	boolean "TI Common Platform Time Sync (CPTS) Support"
+	depends on TI_CPSW
+	select PTP_1588_CLOCK
+	---help---
+	  This driver supports the Common Platform Time Sync unit of
+	  the CPSW Ethernet Switch. The unit can time stamp PTP UDP/IPv4
+	  and Layer 2 packets, and the driver offers a PTP Hardware Clock.
+
+config TI_KEYSTONE_NET
+	tristate "TI Keystone Ethernet Support"
+	depends on TI_KEYSTONE
+	default y if TI_KEYSTONE
+	---help---
+	  This driver supports TI's Keystone Ethernet.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called keystone_net.
+
+config TI_KEYSTONE_PA
+	tristate "TI Keystone Packet Accelerator Support"
+	depends on TI_KEYSTONE
+	default y if TI_KEYSTONE
+	---help---
+	  This driver supports TI's Keystone Packet Accelerator.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called keystone_pa.
+
+config TI_KEYSTONE_QOS
+	tristate "TI Keystone Quality of Service Support"
+	depends on TI_KEYSTONE
+	default y if TI_KEYSTONE
+	---help---
+	  This driver supports TI's Keystone Quality of Service support.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called keystone_qos.
+
+config TI_KEYSTONE_NET_SA
+	tristate "TI Keystone inflow Security Accelerator mode Support"
+	depends on TI_KEYSTONE
+	default y if TI_KEYSTONE
+	---help---
+	  This driver supports TI's Keystone inflow Security Accelerator
+          mode.
+
 config TLAN
 	tristate "TI ThunderLAN support"
 	depends on (PCI || EISA)
@@ -85,4 +132,23 @@ config CPMAC
 	---help---
 	  TI AR7 CPMAC Ethernet support
 
+config TI_KEYSTONE_XGE
+	tristate "TI Keystone 10Gig Ethernet Support"
+	depends on TI_KEYSTONE && TI_KEYSTONE_NET
+	---help---
+	  This driver supports TI's Keystone 10Gig Ethernet.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called keystone_xge.
+
+config TI_KEYSTONE_XGE_MDIO
+	tristate "TI Keystone 10GE MDIO Support"
+	depends on ARM && ARCH_KEYSTONE
+	select PHYLIB
+	---help---
+	  This driver supports TI's Keystone 10GE MDIO module.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called keystone_xgemdio.  This is recommended.
+
 endif # NET_VENDOR_TI
diff --git a/drivers/net/ethernet/ti/Makefile b/drivers/net/ethernet/ti/Makefile
index 91bd8bb..de33d9f 100644
--- a/drivers/net/ethernet/ti/Makefile
+++ b/drivers/net/ethernet/ti/Makefile
@@ -8,4 +8,16 @@ obj-$(CONFIG_TI_DAVINCI_EMAC) += davinci_emac.o
 obj-$(CONFIG_TI_DAVINCI_MDIO) += davinci_mdio.o
 obj-$(CONFIG_TI_DAVINCI_CPDMA) += davinci_cpdma.o
 obj-$(CONFIG_TI_CPSW) += ti_cpsw.o
-ti_cpsw-y := cpsw_ale.o cpsw.o
+ti_cpsw-y := cpsw_ale.o cpsw.o cpts.o
+obj-$(CONFIG_TI_KEYSTONE_NET) += keystone_net.o
+obj-$(CONFIG_TI_KEYSTONE_PA) += keystone_pa.o
+obj-$(CONFIG_TI_KEYSTONE_QOS) += keystone_qos.o
+obj-$(CONFIG_TI_KEYSTONE_NET_SA) += keystone_net_sa.o
+keystone_net-y += cpsw_ale.o		\
+		  keystone_ethss.o	\
+		  keystone_sgmii.o	\
+		  keystone_net_core.o
+obj-$(CONFIG_TI_KEYSTONE_XGE) += keystone_xge.o
+obj-$(CONFIG_TI_KEYSTONE_XGE_MDIO) += keystone_xgemdio.o
+keystone_xge-y += keystone_xgess.o	\
+		  keystone_xgepcsr.o
diff --git a/drivers/net/ethernet/ti/cpmac.c b/drivers/net/ethernet/ti/cpmac.c
index 860c252..c8130fc 100644
--- a/drivers/net/ethernet/ti/cpmac.c
+++ b/drivers/net/ethernet/ti/cpmac.c
@@ -920,7 +920,7 @@ static const struct ethtool_ops cpmac_ethtool_ops = {
 	.set_ringparam = cpmac_set_ringparam,
 };
 
-static void cpmac_adjust_link(struct net_device *dev)
+static void cpmac_adjust_link(struct net_device *dev, void *context)
 {
 	struct cpmac_priv *priv = netdev_priv(dev);
 	int new_state = 0;
@@ -1110,7 +1110,7 @@ static const struct net_device_ops cpmac_netdev_ops = {
 
 static int external_switch;
 
-static int __devinit cpmac_probe(struct platform_device *pdev)
+static int cpmac_probe(struct platform_device *pdev)
 {
 	int rc, phy_id;
 	char mdio_bus_id[MII_BUS_ID_SIZE];
@@ -1174,7 +1174,7 @@ static int __devinit cpmac_probe(struct platform_device *pdev)
 						mdio_bus_id, phy_id);
 
 	priv->phy = phy_connect(dev, priv->phy_name, cpmac_adjust_link, 0,
-						PHY_INTERFACE_MODE_MII);
+				PHY_INTERFACE_MODE_MII, NULL);
 
 	if (IS_ERR(priv->phy)) {
 		if (netif_msg_drv(priv))
@@ -1204,7 +1204,7 @@ fail:
 	return rc;
 }
 
-static int __devexit cpmac_remove(struct platform_device *pdev)
+static int cpmac_remove(struct platform_device *pdev)
 {
 	struct net_device *dev = platform_get_drvdata(pdev);
 	unregister_netdev(dev);
@@ -1216,10 +1216,10 @@ static struct platform_driver cpmac_driver = {
 	.driver.name = "cpmac",
 	.driver.owner = THIS_MODULE,
 	.probe = cpmac_probe,
-	.remove = __devexit_p(cpmac_remove),
+	.remove = cpmac_remove,
 };
 
-int __devinit cpmac_init(void)
+int cpmac_init(void)
 {
 	u32 mask;
 	int i, res;
@@ -1290,7 +1290,7 @@ fail_alloc:
 	return res;
 }
 
-void __devexit cpmac_exit(void)
+void cpmac_exit(void)
 {
 	platform_driver_unregister(&cpmac_driver);
 	mdiobus_unregister(cpmac_mii);
diff --git a/drivers/net/ethernet/ti/cpsw.c b/drivers/net/ethernet/ti/cpsw.c
index 310e353..a159ae0 100644
--- a/drivers/net/ethernet/ti/cpsw.c
+++ b/drivers/net/ethernet/ti/cpsw.c
@@ -24,15 +24,23 @@
 #include <linux/if_ether.h>
 #include <linux/etherdevice.h>
 #include <linux/netdevice.h>
+#include <linux/net_tstamp.h>
 #include <linux/phy.h>
 #include <linux/workqueue.h>
 #include <linux/delay.h>
+#include <linux/pm_runtime.h>
+#include <linux/of.h>
+#include <linux/of_net.h>
+#include <linux/of_device.h>
 
 #include <linux/platform_data/cpsw.h>
 
 #include "cpsw_ale.h"
+#include "cpts.h"
 #include "davinci_cpdma.h"
 
+#define CPSW_NON_VLAN_ADDR	-1
+
 #define CPSW_DEBUG	(NETIF_MSG_HW		| NETIF_MSG_WOL		| \
 			 NETIF_MSG_DRV		| NETIF_MSG_LINK	| \
 			 NETIF_MSG_IFUP		| NETIF_MSG_INTR	| \
@@ -66,10 +74,37 @@ do {								\
 		dev_notice(priv->dev, format, ## __VA_ARGS__);	\
 } while (0)
 
+#define ALE_ALL_PORTS		0x7
+
 #define CPSW_MAJOR_VERSION(reg)		(reg >> 8 & 0x7)
 #define CPSW_MINOR_VERSION(reg)		(reg & 0xff)
 #define CPSW_RTL_VERSION(reg)		((reg >> 11) & 0x1f)
 
+#define CPSW_VERSION_1		0x19010a
+#define CPSW_VERSION_2		0x19010c
+
+#define HOST_PORT_NUM		0
+#define SLIVER_SIZE		0x40
+
+#define CPSW1_HOST_PORT_OFFSET	0x028
+#define CPSW1_SLAVE_OFFSET	0x050
+#define CPSW1_SLAVE_SIZE	0x040
+#define CPSW1_CPDMA_OFFSET	0x100
+#define CPSW1_STATERAM_OFFSET	0x200
+#define CPSW1_CPTS_OFFSET	0x500
+#define CPSW1_ALE_OFFSET	0x600
+#define CPSW1_SLIVER_OFFSET	0x700
+
+#define CPSW2_HOST_PORT_OFFSET	0x108
+#define CPSW2_SLAVE_OFFSET	0x200
+#define CPSW2_SLAVE_SIZE	0x100
+#define CPSW2_CPDMA_OFFSET	0x800
+#define CPSW2_STATERAM_OFFSET	0xa00
+#define CPSW2_CPTS_OFFSET	0xc00
+#define CPSW2_ALE_OFFSET	0xd00
+#define CPSW2_SLIVER_OFFSET	0xd80
+#define CPSW2_BD_OFFSET		0x2000
+
 #define CPDMA_RXTHRESH		0x0c0
 #define CPDMA_RXFREE		0x0e0
 #define CPDMA_TXHDP		0x00
@@ -77,21 +112,6 @@ do {								\
 #define CPDMA_TXCP		0x40
 #define CPDMA_RXCP		0x60
 
-#define cpsw_dma_regs(base, offset)		\
-	(void __iomem *)((base) + (offset))
-#define cpsw_dma_rxthresh(base, offset)		\
-	(void __iomem *)((base) + (offset) + CPDMA_RXTHRESH)
-#define cpsw_dma_rxfree(base, offset)		\
-	(void __iomem *)((base) + (offset) + CPDMA_RXFREE)
-#define cpsw_dma_txhdp(base, offset)		\
-	(void __iomem *)((base) + (offset) + CPDMA_TXHDP)
-#define cpsw_dma_rxhdp(base, offset)		\
-	(void __iomem *)((base) + (offset) + CPDMA_RXHDP)
-#define cpsw_dma_txcp(base, offset)		\
-	(void __iomem *)((base) + (offset) + CPDMA_TXCP)
-#define cpsw_dma_rxcp(base, offset)		\
-	(void __iomem *)((base) + (offset) + CPDMA_RXCP)
-
 #define CPSW_POLL_WEIGHT	64
 #define CPSW_MIN_PACKET_SIZE	60
 #define CPSW_MAX_PACKET_SIZE	(1500 + 14 + 4 + 4)
@@ -125,7 +145,7 @@ static int rx_packet_max = CPSW_MAX_PACKET_SIZE;
 module_param(rx_packet_max, int, 0);
 MODULE_PARM_DESC(rx_packet_max, "maximum receive packet size (bytes)");
 
-struct cpsw_ss_regs {
+struct cpsw_wr_regs {
 	u32	id_ver;
 	u32	soft_reset;
 	u32	control;
@@ -136,26 +156,98 @@ struct cpsw_ss_regs {
 	u32	misc_en;
 };
 
-struct cpsw_regs {
+struct cpsw_ss_regs {
 	u32	id_ver;
 	u32	control;
 	u32	soft_reset;
 	u32	stat_port_en;
 	u32	ptype;
+	u32	soft_idle;
+	u32	thru_rate;
+	u32	gap_thresh;
+	u32	tx_start_wds;
+	u32	flow_control;
+	u32	vlan_ltype;
+	u32	ts_ltype;
+	u32	dlr_ltype;
 };
 
-struct cpsw_slave_regs {
-	u32	max_blks;
-	u32	blk_cnt;
-	u32	flow_thresh;
-	u32	port_vlan;
-	u32	tx_pri_map;
-	u32	ts_ctl;
-	u32	ts_seq_ltype;
-	u32	ts_vlan;
-	u32	sa_lo;
-	u32	sa_hi;
-};
+/* CPSW_PORT_V1 */
+#define CPSW1_MAX_BLKS      0x00 /* Maximum FIFO Blocks */
+#define CPSW1_BLK_CNT       0x04 /* FIFO Block Usage Count (Read Only) */
+#define CPSW1_TX_IN_CTL     0x08 /* Transmit FIFO Control */
+#define CPSW1_PORT_VLAN     0x0c /* VLAN Register */
+#define CPSW1_TX_PRI_MAP    0x10 /* Tx Header Priority to Switch Pri Mapping */
+#define CPSW1_TS_CTL        0x14 /* Time Sync Control */
+#define CPSW1_TS_SEQ_LTYPE  0x18 /* Time Sync Sequence ID Offset and Msg Type */
+#define CPSW1_TS_VLAN       0x1c /* Time Sync VLAN1 and VLAN2 */
+
+/* CPSW_PORT_V2 */
+#define CPSW2_CONTROL       0x00 /* Control Register */
+#define CPSW2_MAX_BLKS      0x08 /* Maximum FIFO Blocks */
+#define CPSW2_BLK_CNT       0x0c /* FIFO Block Usage Count (Read Only) */
+#define CPSW2_TX_IN_CTL     0x10 /* Transmit FIFO Control */
+#define CPSW2_PORT_VLAN     0x14 /* VLAN Register */
+#define CPSW2_TX_PRI_MAP    0x18 /* Tx Header Priority to Switch Pri Mapping */
+#define CPSW2_TS_SEQ_MTYPE  0x1c /* Time Sync Sequence ID Offset and Msg Type */
+
+/* CPSW_PORT_V1 and V2 */
+#define SA_LO               0x20 /* CPGMAC_SL Source Address Low */
+#define SA_HI               0x24 /* CPGMAC_SL Source Address High */
+#define SEND_PERCENT        0x28 /* Transmit Queue Send Percentages */
+
+/* CPSW_PORT_V2 only */
+#define RX_DSCP_PRI_MAP0    0x30 /* Rx DSCP Priority to Rx Packet Mapping */
+#define RX_DSCP_PRI_MAP1    0x34 /* Rx DSCP Priority to Rx Packet Mapping */
+#define RX_DSCP_PRI_MAP2    0x38 /* Rx DSCP Priority to Rx Packet Mapping */
+#define RX_DSCP_PRI_MAP3    0x3c /* Rx DSCP Priority to Rx Packet Mapping */
+#define RX_DSCP_PRI_MAP4    0x40 /* Rx DSCP Priority to Rx Packet Mapping */
+#define RX_DSCP_PRI_MAP5    0x44 /* Rx DSCP Priority to Rx Packet Mapping */
+#define RX_DSCP_PRI_MAP6    0x48 /* Rx DSCP Priority to Rx Packet Mapping */
+#define RX_DSCP_PRI_MAP7    0x4c /* Rx DSCP Priority to Rx Packet Mapping */
+
+/* Bit definitions for the CPSW2_CONTROL register */
+#define PASS_PRI_TAGGED     (1<<24) /* Pass Priority Tagged */
+#define VLAN_LTYPE2_EN      (1<<21) /* VLAN LTYPE 2 enable */
+#define VLAN_LTYPE1_EN      (1<<20) /* VLAN LTYPE 1 enable */
+#define DSCP_PRI_EN         (1<<16) /* DSCP Priority Enable */
+#define TS_320              (1<<14) /* Time Sync Dest Port 320 enable */
+#define TS_319              (1<<13) /* Time Sync Dest Port 319 enable */
+#define TS_132              (1<<12) /* Time Sync Dest IP Addr 132 enable */
+#define TS_131              (1<<11) /* Time Sync Dest IP Addr 131 enable */
+#define TS_130              (1<<10) /* Time Sync Dest IP Addr 130 enable */
+#define TS_129              (1<<9)  /* Time Sync Dest IP Addr 129 enable */
+#define TS_BIT8             (1<<8)  /* ts_ttl_nonzero? */
+#define TS_ANNEX_D_EN       (1<<4)  /* Time Sync Annex D enable */
+#define TS_LTYPE2_EN        (1<<3)  /* Time Sync LTYPE 2 enable */
+#define TS_LTYPE1_EN        (1<<2)  /* Time Sync LTYPE 1 enable */
+#define TS_TX_EN            (1<<1)  /* Time Sync Transmit Enable */
+#define TS_RX_EN            (1<<0)  /* Time Sync Receive Enable */
+
+#define CTRL_TS_BITS \
+	(TS_320 | TS_319 | TS_132 | TS_131 | TS_130 | TS_129 | TS_BIT8 | \
+	 TS_ANNEX_D_EN | TS_LTYPE1_EN)
+
+#define CTRL_ALL_TS_MASK (CTRL_TS_BITS | TS_TX_EN | TS_RX_EN)
+#define CTRL_TX_TS_BITS  (CTRL_TS_BITS | TS_TX_EN)
+#define CTRL_RX_TS_BITS  (CTRL_TS_BITS | TS_RX_EN)
+
+/* Bit definitions for the CPSW2_TS_SEQ_MTYPE register */
+#define TS_SEQ_ID_OFFSET_SHIFT   (16)    /* Time Sync Sequence ID Offset */
+#define TS_SEQ_ID_OFFSET_MASK    (0x3f)
+#define TS_MSG_TYPE_EN_SHIFT     (0)     /* Time Sync Message Type Enable */
+#define TS_MSG_TYPE_EN_MASK      (0xffff)
+
+/* The PTP event messages - Sync, Delay_Req, Pdelay_Req, and Pdelay_Resp. */
+#define EVENT_MSG_BITS ((1<<0) | (1<<1) | (1<<2) | (1<<3))
+
+/* Bit definitions for the CPSW1_TS_CTL register */
+#define CPSW_V1_TS_RX_EN		BIT(0)
+#define CPSW_V1_TS_TX_EN		BIT(4)
+#define CPSW_V1_MSG_TYPE_OFS		16
+
+/* Bit definitions for the CPSW1_TS_SEQ_LTYPE register */
+#define CPSW_V1_SEQ_ID_OFS_SHIFT	16
 
 struct cpsw_host_regs {
 	u32	max_blks;
@@ -181,7 +273,7 @@ struct cpsw_sliver_regs {
 };
 
 struct cpsw_slave {
-	struct cpsw_slave_regs __iomem	*regs;
+	void __iomem			*regs;
 	struct cpsw_sliver_regs __iomem	*sliver;
 	int				slave_num;
 	u32				mac_control;
@@ -189,19 +281,30 @@ struct cpsw_slave {
 	struct phy_device		*phy;
 };
 
+static inline u32 slave_read(struct cpsw_slave *slave, u32 offset)
+{
+	return __raw_readl(slave->regs + offset);
+}
+
+static inline void slave_write(struct cpsw_slave *slave, u32 val, u32 offset)
+{
+	__raw_writel(val, slave->regs + offset);
+}
+
 struct cpsw_priv {
 	spinlock_t			lock;
 	struct platform_device		*pdev;
 	struct net_device		*ndev;
 	struct resource			*cpsw_res;
-	struct resource			*cpsw_ss_res;
+	struct resource			*cpsw_wr_res;
 	struct napi_struct		napi;
 	struct device			*dev;
 	struct cpsw_platform_data	data;
-	struct cpsw_regs __iomem	*regs;
-	struct cpsw_ss_regs __iomem	*ss_regs;
+	struct cpsw_ss_regs __iomem	*regs;
+	struct cpsw_wr_regs __iomem	*wr_regs;
 	struct cpsw_host_regs __iomem	*host_port_regs;
 	u32				msg_enable;
+	u32				version;
 	struct net_device_stats		stats;
 	int				rx_packet_max;
 	int				host_port;
@@ -214,6 +317,7 @@ struct cpsw_priv {
 	/* snapshot of IRQ numbers */
 	u32 irqs_table[4];
 	u32 num_irqs;
+	struct cpts cpts;
 };
 
 #define napi_to_priv(napi)	container_of(napi, struct cpsw_priv, napi)
@@ -224,10 +328,34 @@ struct cpsw_priv {
 			(func)((priv)->slaves + idx, ##arg);	\
 	} while (0)
 
+static void cpsw_ndo_set_rx_mode(struct net_device *ndev)
+{
+	struct cpsw_priv *priv = netdev_priv(ndev);
+
+	if (ndev->flags & IFF_PROMISC) {
+		/* Enable promiscuous mode */
+		dev_err(priv->dev, "Ignoring Promiscuous mode\n");
+		return;
+	}
+
+	/* Clear all mcast from ALE */
+	cpsw_ale_flush_multicast(priv->ale, ALE_ALL_PORTS << priv->host_port);
+
+	if (!netdev_mc_empty(ndev)) {
+		struct netdev_hw_addr *ha;
+
+		/* program multicast address list into ALE register */
+		netdev_for_each_mc_addr(ha, ndev) {
+			cpsw_ale_add_mcast(priv->ale, (u8 *)ha->addr,
+				ALE_ALL_PORTS << priv->host_port, 0, 0);
+		}
+	}
+}
+
 static void cpsw_intr_enable(struct cpsw_priv *priv)
 {
-	__raw_writel(0xFF, &priv->ss_regs->tx_en);
-	__raw_writel(0xFF, &priv->ss_regs->rx_en);
+	__raw_writel(0xFF, &priv->wr_regs->tx_en);
+	__raw_writel(0xFF, &priv->wr_regs->rx_en);
 
 	cpdma_ctlr_int_ctrl(priv->dma, true);
 	return;
@@ -235,8 +363,8 @@ static void cpsw_intr_enable(struct cpsw_priv *priv)
 
 static void cpsw_intr_disable(struct cpsw_priv *priv)
 {
-	__raw_writel(0, &priv->ss_regs->tx_en);
-	__raw_writel(0, &priv->ss_regs->rx_en);
+	__raw_writel(0, &priv->wr_regs->tx_en);
+	__raw_writel(0, &priv->wr_regs->rx_en);
 
 	cpdma_ctlr_int_ctrl(priv->dma, false);
 	return;
@@ -249,7 +377,8 @@ void cpsw_tx_handler(void *token, int len, int status)
 	struct cpsw_priv	*priv = netdev_priv(ndev);
 
 	if (unlikely(netif_queue_stopped(ndev)))
-		netif_wake_queue(ndev);
+		netif_start_queue(ndev);
+	cpts_tx_timestamp(&priv->cpts, skb);
 	priv->stats.tx_packets++;
 	priv->stats.tx_bytes += len;
 	dev_kfree_skb_any(skb);
@@ -270,6 +399,7 @@ void cpsw_rx_handler(void *token, int len, int status)
 	}
 	if (likely(status >= 0)) {
 		skb_put(skb, len);
+		cpts_rx_timestamp(&priv->cpts, skb);
 		skb->protocol = eth_type_trans(skb, ndev);
 		netif_receive_skb(skb);
 		priv->stats.rx_bytes += len;
@@ -355,8 +485,8 @@ static inline void soft_reset(const char *module, void __iomem *reg)
 static void cpsw_set_slave_mac(struct cpsw_slave *slave,
 			       struct cpsw_priv *priv)
 {
-	__raw_writel(mac_hi(priv->mac_addr), &slave->regs->sa_hi);
-	__raw_writel(mac_lo(priv->mac_addr), &slave->regs->sa_lo);
+	slave_write(slave, mac_hi(priv->mac_addr), SA_HI);
+	slave_write(slave, mac_lo(priv->mac_addr), SA_LO);
 }
 
 static void _cpsw_adjust_link(struct cpsw_slave *slave,
@@ -382,6 +512,11 @@ static void _cpsw_adjust_link(struct cpsw_slave *slave,
 			mac_control |= BIT(7);	/* GIGABITEN	*/
 		if (phy->duplex)
 			mac_control |= BIT(0);	/* FULLDUPLEXEN	*/
+
+		/* set speed_in input in case RMII mode is used in 100Mbps */
+		if (phy->speed == 100)
+			mac_control |= BIT(15);
+
 		*link = true;
 	} else {
 		mac_control = 0;
@@ -398,7 +533,7 @@ static void _cpsw_adjust_link(struct cpsw_slave *slave,
 	slave->mac_control = mac_control;
 }
 
-static void cpsw_adjust_link(struct net_device *ndev)
+static void cpsw_adjust_link(struct net_device *ndev, void *context)
 {
 	struct cpsw_priv	*priv = netdev_priv(ndev);
 	bool			link = false;
@@ -437,7 +572,15 @@ static void cpsw_slave_open(struct cpsw_slave *slave, struct cpsw_priv *priv)
 
 	/* setup priority mapping */
 	__raw_writel(RX_PRIORITY_MAPPING, &slave->sliver->rx_pri_map);
-	__raw_writel(TX_PRIORITY_MAPPING, &slave->regs->tx_pri_map);
+
+	switch (priv->version) {
+	case CPSW_VERSION_1:
+		slave_write(slave, TX_PRIORITY_MAPPING, CPSW1_TX_PRI_MAP);
+		break;
+	case CPSW_VERSION_2:
+		slave_write(slave, TX_PRIORITY_MAPPING, CPSW2_TX_PRI_MAP);
+		break;
+	}
 
 	/* setup max packet size, and mac address */
 	__raw_writel(priv->rx_packet_max, &slave->sliver->rx_maxlen);
@@ -448,10 +591,12 @@ static void cpsw_slave_open(struct cpsw_slave *slave, struct cpsw_priv *priv)
 	slave_port = cpsw_get_slave_port(priv, slave->slave_num);
 
 	cpsw_ale_add_mcast(priv->ale, priv->ndev->broadcast,
-			   1 << slave_port, 0, ALE_MCAST_FWD_2);
+			   1 << slave_port, 0,
+			   ALE_MCAST_FWD_2, CPSW_NON_VLAN_ADDR);
 
 	slave->phy = phy_connect(priv->ndev, slave->data->phy_id,
-				 &cpsw_adjust_link, 0, slave->data->phy_if);
+				 &cpsw_adjust_link, 0,
+				 slave->data->phy_if, NULL);
 	if (IS_ERR(slave->phy)) {
 		dev_err(priv->dev, "phy %s not found on slave %d\n",
 			slave->data->phy_id, slave->slave_num);
@@ -480,9 +625,11 @@ static void cpsw_init_host_port(struct cpsw_priv *priv)
 	cpsw_ale_control_set(priv->ale, priv->host_port,
 			     ALE_PORT_STATE, ALE_PORT_STATE_FORWARD);
 
-	cpsw_ale_add_ucast(priv->ale, priv->mac_addr, priv->host_port, 0);
+	cpsw_ale_add_ucast(priv->ale, priv->mac_addr, priv->host_port,
+			   0, CPSW_NON_VLAN_ADDR);
 	cpsw_ale_add_mcast(priv->ale, priv->ndev->broadcast,
-			   1 << priv->host_port, 0, ALE_MCAST_FWD_2);
+			   1 << priv->host_port, 0,
+			   ALE_MCAST_FWD_2, CPSW_NON_VLAN_ADDR);
 }
 
 static int cpsw_ndo_open(struct net_device *ndev)
@@ -494,13 +641,9 @@ static int cpsw_ndo_open(struct net_device *ndev)
 	cpsw_intr_disable(priv);
 	netif_carrier_off(ndev);
 
-	ret = clk_enable(priv->clk);
-	if (ret < 0) {
-		dev_err(priv->dev, "unable to turn on device clock\n");
-		return ret;
-	}
+	pm_runtime_get_sync(&priv->pdev->dev);
 
-	reg = __raw_readl(&priv->regs->id_ver);
+	reg = priv->version;
 
 	dev_info(priv->dev, "initializing cpsw version %d.%d (%d)\n",
 		 CPSW_MAJOR_VERSION(reg), CPSW_MINOR_VERSION(reg),
@@ -561,15 +704,15 @@ static int cpsw_ndo_stop(struct net_device *ndev)
 	struct cpsw_priv *priv = netdev_priv(ndev);
 
 	cpsw_info(priv, ifdown, "shutting down cpsw device\n");
-	cpsw_intr_disable(priv);
-	cpdma_ctlr_int_ctrl(priv->dma, false);
-	cpdma_ctlr_stop(priv->dma);
 	netif_stop_queue(priv->ndev);
 	napi_disable(&priv->napi);
 	netif_carrier_off(priv->ndev);
+	cpsw_intr_disable(priv);
+	cpdma_ctlr_int_ctrl(priv->dma, false);
+	cpdma_ctlr_stop(priv->dma);
 	cpsw_ale_stop(priv->ale);
 	for_each_slave(priv, cpsw_slave_stop, priv);
-	clk_disable(priv->clk);
+	pm_runtime_put_sync(&priv->pdev->dev);
 	return 0;
 }
 
@@ -587,6 +730,11 @@ static netdev_tx_t cpsw_ndo_start_xmit(struct sk_buff *skb,
 		return NETDEV_TX_OK;
 	}
 
+	if (skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP && priv->cpts.tx_enable)
+		skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
+
+	skb_tx_timestamp(skb);
+
 	ret = cpdma_chan_submit(priv->txch, skb, skb->data,
 				skb->len, GFP_KERNEL);
 	if (unlikely(ret != 0)) {
@@ -624,6 +772,129 @@ static void cpsw_ndo_change_rx_flags(struct net_device *ndev, int flags)
 		dev_err(&ndev->dev, "multicast traffic cannot be filtered!\n");
 }
 
+#ifdef CONFIG_TI_CPTS
+
+static void cpsw_hwtstamp_v1(struct cpsw_priv *priv)
+{
+	struct cpsw_slave *slave = &priv->slaves[priv->data.cpts_active_slave];
+	u32 ts_en, seq_id;
+
+	if (!priv->cpts.tx_enable && !priv->cpts.rx_enable) {
+		slave_write(slave, 0, CPSW1_TS_CTL);
+		return;
+	}
+
+	seq_id = (30 << CPSW_V1_SEQ_ID_OFS_SHIFT) | ETH_P_1588;
+	ts_en = EVENT_MSG_BITS << CPSW_V1_MSG_TYPE_OFS;
+
+	if (priv->cpts.tx_enable)
+		ts_en |= CPSW_V1_TS_TX_EN;
+
+	if (priv->cpts.rx_enable)
+		ts_en |= CPSW_V1_TS_RX_EN;
+
+	slave_write(slave, ts_en, CPSW1_TS_CTL);
+	slave_write(slave, seq_id, CPSW1_TS_SEQ_LTYPE);
+}
+
+static void cpsw_hwtstamp_v2(struct cpsw_priv *priv)
+{
+	struct cpsw_slave *slave = &priv->slaves[priv->data.cpts_active_slave];
+	u32 ctrl, mtype;
+
+	ctrl = slave_read(slave, CPSW2_CONTROL);
+	ctrl &= ~CTRL_ALL_TS_MASK;
+
+	if (priv->cpts.tx_enable)
+		ctrl |= CTRL_TX_TS_BITS;
+
+	if (priv->cpts.rx_enable)
+		ctrl |= CTRL_RX_TS_BITS;
+
+	mtype = (30 << TS_SEQ_ID_OFFSET_SHIFT) | EVENT_MSG_BITS;
+
+	slave_write(slave, mtype, CPSW2_TS_SEQ_MTYPE);
+	slave_write(slave, ctrl, CPSW2_CONTROL);
+	__raw_writel(ETH_P_1588, &priv->regs->ts_ltype);
+}
+
+static int cpsw_hwtstamp_ioctl(struct net_device *dev, struct ifreq *ifr)
+{
+	struct cpsw_priv *priv = netdev_priv(dev);
+	struct cpts *cpts = &priv->cpts;
+	struct hwtstamp_config cfg;
+
+	if (copy_from_user(&cfg, ifr->ifr_data, sizeof(cfg)))
+		return -EFAULT;
+
+	/* reserved for future extensions */
+	if (cfg.flags)
+		return -EINVAL;
+
+	switch (cfg.tx_type) {
+	case HWTSTAMP_TX_OFF:
+		cpts->tx_enable = 0;
+		break;
+	case HWTSTAMP_TX_ON:
+		cpts->tx_enable = 1;
+		break;
+	default:
+		return -ERANGE;
+	}
+
+	switch (cfg.rx_filter) {
+	case HWTSTAMP_FILTER_NONE:
+		cpts->rx_enable = 0;
+		break;
+	case HWTSTAMP_FILTER_ALL:
+	case HWTSTAMP_FILTER_PTP_V1_L4_EVENT:
+	case HWTSTAMP_FILTER_PTP_V1_L4_SYNC:
+	case HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:
+		return -ERANGE;
+	case HWTSTAMP_FILTER_PTP_V2_L4_EVENT:
+	case HWTSTAMP_FILTER_PTP_V2_L4_SYNC:
+	case HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:
+	case HWTSTAMP_FILTER_PTP_V2_L2_EVENT:
+	case HWTSTAMP_FILTER_PTP_V2_L2_SYNC:
+	case HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:
+	case HWTSTAMP_FILTER_PTP_V2_EVENT:
+	case HWTSTAMP_FILTER_PTP_V2_SYNC:
+	case HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:
+		cpts->rx_enable = 1;
+		cfg.rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;
+		break;
+	default:
+		return -ERANGE;
+	}
+
+	switch (priv->version) {
+	case CPSW_VERSION_1:
+		cpsw_hwtstamp_v1(priv);
+		break;
+	case CPSW_VERSION_2:
+		cpsw_hwtstamp_v2(priv);
+		break;
+	default:
+		return -ENOTSUPP;
+	}
+
+	return copy_to_user(ifr->ifr_data, &cfg, sizeof(cfg)) ? -EFAULT : 0;
+}
+
+#endif /*CONFIG_TI_CPTS*/
+
+static int cpsw_ndo_ioctl(struct net_device *dev, struct ifreq *req, int cmd)
+{
+	if (!netif_running(dev))
+		return -EINVAL;
+
+#ifdef CONFIG_TI_CPTS
+	if (cmd == SIOCSHWTSTAMP)
+		return cpsw_hwtstamp_ioctl(dev, req);
+#endif
+	return -ENOTSUPP;
+}
+
 static void cpsw_ndo_tx_timeout(struct net_device *ndev)
 {
 	struct cpsw_priv *priv = netdev_priv(ndev);
@@ -664,10 +935,12 @@ static const struct net_device_ops cpsw_netdev_ops = {
 	.ndo_stop		= cpsw_ndo_stop,
 	.ndo_start_xmit		= cpsw_ndo_start_xmit,
 	.ndo_change_rx_flags	= cpsw_ndo_change_rx_flags,
+	.ndo_do_ioctl		= cpsw_ndo_ioctl,
 	.ndo_validate_addr	= eth_validate_addr,
 	.ndo_change_mtu		= eth_change_mtu,
 	.ndo_tx_timeout		= cpsw_ndo_tx_timeout,
 	.ndo_get_stats		= cpsw_ndo_get_stats,
+	.ndo_set_rx_mode	= cpsw_ndo_set_rx_mode,
 #ifdef CONFIG_NET_POLL_CONTROLLER
 	.ndo_poll_controller	= cpsw_ndo_poll_controller,
 #endif
@@ -694,40 +967,193 @@ static void cpsw_set_msglevel(struct net_device *ndev, u32 value)
 	priv->msg_enable = value;
 }
 
+static int cpsw_get_ts_info(struct net_device *ndev,
+			    struct ethtool_ts_info *info)
+{
+#ifdef CONFIG_TI_CPTS
+	struct cpsw_priv *priv = netdev_priv(ndev);
+
+	info->so_timestamping =
+		SOF_TIMESTAMPING_TX_HARDWARE |
+		SOF_TIMESTAMPING_TX_SOFTWARE |
+		SOF_TIMESTAMPING_RX_HARDWARE |
+		SOF_TIMESTAMPING_RX_SOFTWARE |
+		SOF_TIMESTAMPING_SOFTWARE |
+		SOF_TIMESTAMPING_RAW_HARDWARE;
+	info->phc_index = priv->cpts.phc_index;
+	info->tx_types =
+		(1 << HWTSTAMP_TX_OFF) |
+		(1 << HWTSTAMP_TX_ON);
+	info->rx_filters =
+		(1 << HWTSTAMP_FILTER_NONE) |
+		(1 << HWTSTAMP_FILTER_PTP_V2_EVENT);
+#else
+	info->so_timestamping =
+		SOF_TIMESTAMPING_TX_SOFTWARE |
+		SOF_TIMESTAMPING_RX_SOFTWARE |
+		SOF_TIMESTAMPING_SOFTWARE;
+	info->phc_index = -1;
+	info->tx_types = 0;
+	info->rx_filters = 0;
+#endif
+	return 0;
+}
+
 static const struct ethtool_ops cpsw_ethtool_ops = {
 	.get_drvinfo	= cpsw_get_drvinfo,
 	.get_msglevel	= cpsw_get_msglevel,
 	.set_msglevel	= cpsw_set_msglevel,
 	.get_link	= ethtool_op_get_link,
+	.get_ts_info	= cpsw_get_ts_info,
 };
 
-static void cpsw_slave_init(struct cpsw_slave *slave, struct cpsw_priv *priv)
+static void cpsw_slave_init(struct cpsw_slave *slave, struct cpsw_priv *priv,
+			    u32 slave_reg_ofs, u32 sliver_reg_ofs)
 {
 	void __iomem		*regs = priv->regs;
 	int			slave_num = slave->slave_num;
 	struct cpsw_slave_data	*data = priv->data.slave_data + slave_num;
 
 	slave->data	= data;
-	slave->regs	= regs + data->slave_reg_ofs;
-	slave->sliver	= regs + data->sliver_reg_ofs;
+	slave->regs	= regs + slave_reg_ofs;
+	slave->sliver	= regs + sliver_reg_ofs;
+}
+
+static int cpsw_probe_dt(struct cpsw_platform_data *data,
+			 struct platform_device *pdev)
+{
+	struct device_node *node = pdev->dev.of_node;
+	struct device_node *slave_node;
+	int i = 0, ret;
+	u32 prop;
+
+	if (!node)
+		return -EINVAL;
+
+	if (of_property_read_u32(node, "slaves", &prop)) {
+		pr_err("Missing slaves property in the DT.\n");
+		return -EINVAL;
+	}
+	data->slaves = prop;
+
+	if (of_property_read_u32(node, "cpts_active_slave", &prop)) {
+		pr_err("Missing cpts_active_slave property in the DT.\n");
+		ret = -EINVAL;
+		goto error_ret;
+	}
+	data->cpts_active_slave = prop;
+
+	if (of_property_read_u32(node, "cpts_clock_mult", &prop)) {
+		pr_err("Missing cpts_clock_mult property in the DT.\n");
+		ret = -EINVAL;
+		goto error_ret;
+	}
+	data->cpts_clock_mult = prop;
+
+	if (of_property_read_u32(node, "cpts_clock_shift", &prop)) {
+		pr_err("Missing cpts_clock_shift property in the DT.\n");
+		ret = -EINVAL;
+		goto error_ret;
+	}
+	data->cpts_clock_shift = prop;
+
+	data->slave_data = kzalloc(sizeof(struct cpsw_slave_data) *
+				   data->slaves, GFP_KERNEL);
+	if (!data->slave_data) {
+		pr_err("Could not allocate slave memory.\n");
+		return -EINVAL;
+	}
+
+	if (of_property_read_u32(node, "cpdma_channels", &prop)) {
+		pr_err("Missing cpdma_channels property in the DT.\n");
+		ret = -EINVAL;
+		goto error_ret;
+	}
+	data->channels = prop;
+
+	if (of_property_read_u32(node, "ale_entries", &prop)) {
+		pr_err("Missing ale_entries property in the DT.\n");
+		ret = -EINVAL;
+		goto error_ret;
+	}
+	data->ale_entries = prop;
+
+	if (of_property_read_u32(node, "bd_ram_size", &prop)) {
+		pr_err("Missing bd_ram_size property in the DT.\n");
+		ret = -EINVAL;
+		goto error_ret;
+	}
+	data->bd_ram_size = prop;
+
+	if (of_property_read_u32(node, "rx_descs", &prop)) {
+		pr_err("Missing rx_descs property in the DT.\n");
+		ret = -EINVAL;
+		goto error_ret;
+	}
+	data->rx_descs = prop;
+
+	if (of_property_read_u32(node, "mac_control", &prop)) {
+		pr_err("Missing mac_control property in the DT.\n");
+		ret = -EINVAL;
+		goto error_ret;
+	}
+	data->mac_control = prop;
+
+	/*
+	 * Populate all the child nodes here...
+	 */
+	ret = of_platform_populate(node, NULL, NULL, &pdev->dev);
+	/* We do not want to force this, as in some cases may not have child */
+	if (ret)
+		pr_warn("Doesn't have any child node\n");
+
+	for_each_node_by_name(slave_node, "slave") {
+		struct cpsw_slave_data *slave_data = data->slave_data + i;
+		const void *mac_addr = NULL;
+		u32 phyid;
+		int lenp;
+		const __be32 *parp;
+		struct device_node *mdio_node;
+		struct platform_device *mdio;
+
+		parp = of_get_property(slave_node, "phy_id", &lenp);
+		if ((parp == NULL) && (lenp != (sizeof(void *) * 2))) {
+			pr_err("Missing slave[%d] phy_id property\n", i);
+			ret = -EINVAL;
+			goto error_ret;
+		}
+		mdio_node = of_find_node_by_phandle(be32_to_cpup(parp));
+		phyid = be32_to_cpup(parp+1);
+		mdio = of_find_device_by_node(mdio_node);
+		snprintf(slave_data->phy_id, sizeof(slave_data->phy_id),
+			 PHY_ID_FMT, mdio->name, phyid);
+
+		mac_addr = of_get_mac_address(slave_node);
+		if (mac_addr)
+			memcpy(slave_data->mac_addr, mac_addr, ETH_ALEN);
+
+		i++;
+	}
+
+	return 0;
+
+error_ret:
+	kfree(data->slave_data);
+	return ret;
 }
 
-static int __devinit cpsw_probe(struct platform_device *pdev)
+static int cpsw_probe(struct platform_device *pdev)
 {
 	struct cpsw_platform_data	*data = pdev->dev.platform_data;
 	struct net_device		*ndev;
 	struct cpsw_priv		*priv;
 	struct cpdma_params		dma_params;
 	struct cpsw_ale_params		ale_params;
-	void __iomem			*regs;
+	void __iomem			*ss_regs, *wr_regs;
 	struct resource			*res;
+	u32 slave_offset, sliver_offset, slave_size;
 	int ret = 0, i, k = 0;
 
-	if (!data) {
-		pr_err("platform data missing\n");
-		return -ENODEV;
-	}
-
 	ndev = alloc_etherdev(sizeof(struct cpsw_priv));
 	if (!ndev) {
 		pr_err("error allocating net_device\n");
@@ -737,18 +1163,29 @@ static int __devinit cpsw_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, ndev);
 	priv = netdev_priv(ndev);
 	spin_lock_init(&priv->lock);
-	priv->data = *data;
 	priv->pdev = pdev;
 	priv->ndev = ndev;
 	priv->dev  = &ndev->dev;
 	priv->msg_enable = netif_msg_init(debug_level, CPSW_DEBUG);
 	priv->rx_packet_max = max(rx_packet_max, 128);
 
+	/*
+	 * This may be required here for child devices.
+	 */
+	pm_runtime_enable(&pdev->dev);
+
+	if (cpsw_probe_dt(&priv->data, pdev)) {
+		pr_err("cpsw: platform data missing\n");
+		ret = -ENODEV;
+		goto clean_ndev_ret;
+	}
+	data = &priv->data;
+
 	if (is_valid_ether_addr(data->slave_data[0].mac_addr)) {
 		memcpy(priv->mac_addr, data->slave_data[0].mac_addr, ETH_ALEN);
 		pr_info("Detected MACID = %pM", priv->mac_addr);
 	} else {
-		random_ether_addr(priv->mac_addr);
+		eth_random_addr(priv->mac_addr);
 		pr_info("Random MACID = %pM", priv->mac_addr);
 	}
 
@@ -763,10 +1200,11 @@ static int __devinit cpsw_probe(struct platform_device *pdev)
 	for (i = 0; i < data->slaves; i++)
 		priv->slaves[i].slave_num = i;
 
-	priv->clk = clk_get(&pdev->dev, NULL);
+	priv->clk = clk_get(&pdev->dev, "fck");
 	if (IS_ERR(priv->clk)) {
-		dev_err(priv->dev, "failed to get device clock)\n");
-		ret = -EBUSY;
+		dev_err(&pdev->dev, "fck is not found\n");
+		ret = -ENODEV;
+		goto clean_slave_ret;
 	}
 
 	priv->cpsw_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
@@ -775,63 +1213,86 @@ static int __devinit cpsw_probe(struct platform_device *pdev)
 		ret = -ENOENT;
 		goto clean_clk_ret;
 	}
-
 	if (!request_mem_region(priv->cpsw_res->start,
 				resource_size(priv->cpsw_res), ndev->name)) {
 		dev_err(priv->dev, "failed request i/o region\n");
 		ret = -ENXIO;
 		goto clean_clk_ret;
 	}
-
-	regs = ioremap(priv->cpsw_res->start, resource_size(priv->cpsw_res));
-	if (!regs) {
+	ss_regs = ioremap(priv->cpsw_res->start, resource_size(priv->cpsw_res));
+	if (!ss_regs) {
 		dev_err(priv->dev, "unable to map i/o region\n");
 		goto clean_cpsw_iores_ret;
 	}
-	priv->regs = regs;
-	priv->host_port = data->host_port_num;
-	priv->host_port_regs = regs + data->host_port_reg_ofs;
+	priv->regs = ss_regs;
+	priv->version = __raw_readl(&priv->regs->id_ver);
+	priv->host_port = HOST_PORT_NUM;
 
-	priv->cpsw_ss_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
-	if (!priv->cpsw_ss_res) {
+	priv->cpsw_wr_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (!priv->cpsw_wr_res) {
 		dev_err(priv->dev, "error getting i/o resource\n");
 		ret = -ENOENT;
-		goto clean_clk_ret;
+		goto clean_iomap_ret;
 	}
-
-	if (!request_mem_region(priv->cpsw_ss_res->start,
-			resource_size(priv->cpsw_ss_res), ndev->name)) {
+	if (!request_mem_region(priv->cpsw_wr_res->start,
+			resource_size(priv->cpsw_wr_res), ndev->name)) {
 		dev_err(priv->dev, "failed request i/o region\n");
 		ret = -ENXIO;
-		goto clean_clk_ret;
+		goto clean_iomap_ret;
 	}
-
-	regs = ioremap(priv->cpsw_ss_res->start,
-				resource_size(priv->cpsw_ss_res));
-	if (!regs) {
+	wr_regs = ioremap(priv->cpsw_wr_res->start,
+				resource_size(priv->cpsw_wr_res));
+	if (!wr_regs) {
 		dev_err(priv->dev, "unable to map i/o region\n");
-		goto clean_cpsw_ss_iores_ret;
+		goto clean_cpsw_wr_iores_ret;
 	}
-	priv->ss_regs = regs;
-
-	for_each_slave(priv, cpsw_slave_init, priv);
+	priv->wr_regs = wr_regs;
 
 	memset(&dma_params, 0, sizeof(dma_params));
+	memset(&ale_params, 0, sizeof(ale_params));
+
+	switch (priv->version) {
+	case CPSW_VERSION_1:
+		priv->host_port_regs = ss_regs + CPSW1_HOST_PORT_OFFSET;
+		priv->cpts.reg       = ss_regs + CPSW1_CPTS_OFFSET;
+		dma_params.dmaregs   = ss_regs + CPSW1_CPDMA_OFFSET;
+		dma_params.txhdp     = ss_regs + CPSW1_STATERAM_OFFSET;
+		ale_params.ale_regs  = ss_regs + CPSW1_ALE_OFFSET;
+		slave_offset         = CPSW1_SLAVE_OFFSET;
+		slave_size           = CPSW1_SLAVE_SIZE;
+		sliver_offset        = CPSW1_SLIVER_OFFSET;
+		dma_params.desc_mem_phys = 0;
+		break;
+	case CPSW_VERSION_2:
+		priv->host_port_regs = ss_regs + CPSW2_HOST_PORT_OFFSET;
+		priv->cpts.reg       = ss_regs + CPSW2_CPTS_OFFSET;
+		dma_params.dmaregs   = ss_regs + CPSW2_CPDMA_OFFSET;
+		dma_params.txhdp     = ss_regs + CPSW2_STATERAM_OFFSET;
+		ale_params.ale_regs  = ss_regs + CPSW2_ALE_OFFSET;
+		slave_offset         = CPSW2_SLAVE_OFFSET;
+		slave_size           = CPSW2_SLAVE_SIZE;
+		sliver_offset        = CPSW2_SLIVER_OFFSET;
+		dma_params.desc_mem_phys =
+			(u32 __force) priv->cpsw_res->start + CPSW2_BD_OFFSET;
+		break;
+	default:
+		dev_err(priv->dev, "unknown version 0x%08x\n", priv->version);
+		ret = -ENODEV;
+		goto clean_cpsw_wr_iores_ret;
+	}
+	for (i = 0; i < priv->data.slaves; i++) {
+		struct cpsw_slave *slave = &priv->slaves[i];
+		cpsw_slave_init(slave, priv, slave_offset, sliver_offset);
+		slave_offset  += slave_size;
+		sliver_offset += SLIVER_SIZE;
+	}
+
 	dma_params.dev		= &pdev->dev;
-	dma_params.dmaregs	= cpsw_dma_regs((u32)priv->regs,
-						data->cpdma_reg_ofs);
-	dma_params.rxthresh	= cpsw_dma_rxthresh((u32)priv->regs,
-						    data->cpdma_reg_ofs);
-	dma_params.rxfree	= cpsw_dma_rxfree((u32)priv->regs,
-						  data->cpdma_reg_ofs);
-	dma_params.txhdp	= cpsw_dma_txhdp((u32)priv->regs,
-						 data->cpdma_sram_ofs);
-	dma_params.rxhdp	= cpsw_dma_rxhdp((u32)priv->regs,
-						 data->cpdma_sram_ofs);
-	dma_params.txcp		= cpsw_dma_txcp((u32)priv->regs,
-						data->cpdma_sram_ofs);
-	dma_params.rxcp		= cpsw_dma_rxcp((u32)priv->regs,
-						data->cpdma_sram_ofs);
+	dma_params.rxthresh	= dma_params.dmaregs + CPDMA_RXTHRESH;
+	dma_params.rxfree	= dma_params.dmaregs + CPDMA_RXFREE;
+	dma_params.rxhdp	= dma_params.txhdp + CPDMA_RXHDP;
+	dma_params.txcp		= dma_params.txhdp + CPDMA_TXCP;
+	dma_params.rxcp		= dma_params.txhdp + CPDMA_RXCP;
 
 	dma_params.num_chan		= data->channels;
 	dma_params.has_soft_reset	= true;
@@ -839,16 +1300,13 @@ static int __devinit cpsw_probe(struct platform_device *pdev)
 	dma_params.desc_mem_size	= data->bd_ram_size;
 	dma_params.desc_align		= 16;
 	dma_params.has_ext_regs		= true;
-	dma_params.desc_mem_phys        = data->no_bd_ram ? 0 :
-			(u32 __force)priv->cpsw_res->start + data->bd_ram_ofs;
-	dma_params.desc_hw_addr         = data->hw_ram_addr ?
-			data->hw_ram_addr : dma_params.desc_mem_phys ;
+	dma_params.desc_hw_addr         = dma_params.desc_mem_phys;
 
 	priv->dma = cpdma_ctlr_create(&dma_params);
 	if (!priv->dma) {
 		dev_err(priv->dev, "error initializing dma\n");
 		ret = -ENOMEM;
-		goto clean_iomap_ret;
+		goto clean_wr_iomap_ret;
 	}
 
 	priv->txch = cpdma_chan_create(priv->dma, tx_chan_num(0),
@@ -862,10 +1320,7 @@ static int __devinit cpsw_probe(struct platform_device *pdev)
 		goto clean_dma_ret;
 	}
 
-	memset(&ale_params, 0, sizeof(ale_params));
 	ale_params.dev			= &ndev->dev;
-	ale_params.ale_regs		= (void *)((u32)priv->regs) +
-						((u32)data->ale_reg_ofs);
 	ale_params.ale_ageout		= ale_ageout;
 	ale_params.ale_entries		= data->ale_entries;
 	ale_params.ale_ports		= data->slaves;
@@ -912,6 +1367,10 @@ static int __devinit cpsw_probe(struct platform_device *pdev)
 		goto clean_irq_ret;
 	}
 
+	if (cpts_register(&pdev->dev, &priv->cpts,
+			  data->cpts_clock_mult, data->cpts_clock_shift))
+		dev_err(priv->dev, "error registering cpts device\n");
+
 	cpsw_notice(priv, probe, "initialized device (regs %x, irq %d)\n",
 		  priv->cpsw_res->start, ndev->irq);
 
@@ -925,23 +1384,27 @@ clean_dma_ret:
 	cpdma_chan_destroy(priv->txch);
 	cpdma_chan_destroy(priv->rxch);
 	cpdma_ctlr_destroy(priv->dma);
+clean_wr_iomap_ret:
+	iounmap(priv->wr_regs);
+clean_cpsw_wr_iores_ret:
+	release_mem_region(priv->cpsw_wr_res->start,
+			   resource_size(priv->cpsw_wr_res));
 clean_iomap_ret:
 	iounmap(priv->regs);
-clean_cpsw_ss_iores_ret:
-	release_mem_region(priv->cpsw_ss_res->start,
-			   resource_size(priv->cpsw_ss_res));
 clean_cpsw_iores_ret:
 	release_mem_region(priv->cpsw_res->start,
 			   resource_size(priv->cpsw_res));
 clean_clk_ret:
 	clk_put(priv->clk);
+clean_slave_ret:
+	pm_runtime_disable(&pdev->dev);
 	kfree(priv->slaves);
 clean_ndev_ret:
 	free_netdev(ndev);
 	return ret;
 }
 
-static int __devexit cpsw_remove(struct platform_device *pdev)
+static int cpsw_remove(struct platform_device *pdev)
 {
 	struct net_device *ndev = platform_get_drvdata(pdev);
 	struct cpsw_priv *priv = netdev_priv(ndev);
@@ -949,6 +1412,7 @@ static int __devexit cpsw_remove(struct platform_device *pdev)
 	pr_info("removing device");
 	platform_set_drvdata(pdev, NULL);
 
+	cpts_unregister(&priv->cpts);
 	free_irq(ndev->irq, priv);
 	cpsw_ale_destroy(priv->ale);
 	cpdma_chan_destroy(priv->txch);
@@ -957,8 +1421,10 @@ static int __devexit cpsw_remove(struct platform_device *pdev)
 	iounmap(priv->regs);
 	release_mem_region(priv->cpsw_res->start,
 			   resource_size(priv->cpsw_res));
-	release_mem_region(priv->cpsw_ss_res->start,
-			   resource_size(priv->cpsw_ss_res));
+	iounmap(priv->wr_regs);
+	release_mem_region(priv->cpsw_wr_res->start,
+			   resource_size(priv->cpsw_wr_res));
+	pm_runtime_disable(&pdev->dev);
 	clk_put(priv->clk);
 	kfree(priv->slaves);
 	free_netdev(ndev);
@@ -973,6 +1439,8 @@ static int cpsw_suspend(struct device *dev)
 
 	if (netif_running(ndev))
 		cpsw_ndo_stop(ndev);
+	pm_runtime_put_sync(&pdev->dev);
+
 	return 0;
 }
 
@@ -981,6 +1449,7 @@ static int cpsw_resume(struct device *dev)
 	struct platform_device	*pdev = to_platform_device(dev);
 	struct net_device	*ndev = platform_get_drvdata(pdev);
 
+	pm_runtime_get_sync(&pdev->dev);
 	if (netif_running(ndev))
 		cpsw_ndo_open(ndev);
 	return 0;
@@ -991,14 +1460,20 @@ static const struct dev_pm_ops cpsw_pm_ops = {
 	.resume		= cpsw_resume,
 };
 
+static const struct of_device_id cpsw_of_mtable[] = {
+	{ .compatible = "ti,cpsw", },
+	{ /* sentinel */ },
+};
+
 static struct platform_driver cpsw_driver = {
 	.driver = {
 		.name	 = "cpsw",
 		.owner	 = THIS_MODULE,
 		.pm	 = &cpsw_pm_ops,
+		.of_match_table = of_match_ptr(cpsw_of_mtable),
 	},
 	.probe = cpsw_probe,
-	.remove = __devexit_p(cpsw_remove),
+	.remove = cpsw_remove,
 };
 
 static int __init cpsw_init(void)
diff --git a/drivers/net/ethernet/ti/cpsw_ale.c b/drivers/net/ethernet/ti/cpsw_ale.c
index ca0d48a..6e325a7 100644
--- a/drivers/net/ethernet/ti/cpsw_ale.c
+++ b/drivers/net/ethernet/ti/cpsw_ale.c
@@ -20,12 +20,16 @@
 #include <linux/io.h>
 #include <linux/stat.h>
 #include <linux/sysfs.h>
+#include <linux/etherdevice.h>
 
 #include "cpsw_ale.h"
 
 #define BITMASK(bits)		(BIT(bits) - 1)
+#define ADDR_FMT_STR		"%02x:%02x:%02x:%02x:%02x:%02x"
+#define ADDR_FMT_ARGS(addr)	(addr)[0], (addr)[1], (addr)[2], \
+				(addr)[3], (addr)[4], (addr)[5]
 #define ALE_ENTRY_BITS		68
-#define ALE_ENTRY_WORDS	DIV_ROUND_UP(ALE_ENTRY_BITS, 32)
+#define ALE_ENTRY_WORDS		DIV_ROUND_UP(ALE_ENTRY_BITS, 32)
 
 #define ALE_VERSION_MAJOR(rev)	((rev >> 8) & 0xff)
 #define ALE_VERSION_MINOR(rev)	(rev & 0xff)
@@ -51,6 +55,9 @@
 #define ALE_UCAST_OUI			2
 #define ALE_UCAST_TOUCHED		3
 
+#define ALE_TBL_ENTRY_SHOW_LEN		160
+#define ALE_RAW_TBL_ENTRY_SHOW_LEN	32
+
 static inline int cpsw_ale_get_field(u32 *ale_entry, u32 start, u32 bits)
 {
 	int idx;
@@ -147,10 +154,29 @@ static int cpsw_ale_write(struct cpsw_ale *ale, int idx, u32 *ale_entry)
 	return idx;
 }
 
-static int cpsw_ale_match_addr(struct cpsw_ale *ale, u8 *addr)
+static int cpsw_ale_match_vlan(struct cpsw_ale *ale, int vid)
+{
+	u32 ale_entry[ALE_ENTRY_WORDS];
+	int type, idx;
+
+	for (idx = 0; idx < ale->params.ale_entries; idx++) {
+		cpsw_ale_read(ale, idx, ale_entry);
+		type = cpsw_ale_get_entry_type(ale_entry);
+		if (type != ALE_TYPE_VLAN && type != ALE_TYPE_VLAN_ADDR)
+			continue;
+
+		if (vid == cpsw_ale_get_vlan_id(ale_entry))
+			return idx;
+	}
+
+	return -ENOENT;
+}
+
+static int cpsw_ale_match_addr(struct cpsw_ale *ale, u8 *addr, int vid)
 {
 	u32 ale_entry[ALE_ENTRY_WORDS];
 	int type, idx;
+	int match_type = ALE_TYPE_VLAN_ADDR;
 
 	for (idx = 0; idx < ale->params.ale_entries; idx++) {
 		u8 entry_addr[6];
@@ -159,8 +185,14 @@ static int cpsw_ale_match_addr(struct cpsw_ale *ale, u8 *addr)
 		type = cpsw_ale_get_entry_type(ale_entry);
 		if (type != ALE_TYPE_ADDR && type != ALE_TYPE_VLAN_ADDR)
 			continue;
+
+		if (vid < 0)
+			match_type = ALE_TYPE_ADDR;
+
 		cpsw_ale_get_addr(ale_entry, entry_addr);
-		if (memcmp(entry_addr, addr, 6) == 0)
+		if ((memcmp(entry_addr, addr, 6) == 0) &&
+		    (vid < 0 || vid == cpsw_ale_get_vlan_id(ale_entry)) &&
+		    (match_type == type))
 			return idx;
 	}
 	return -ENOENT;
@@ -211,10 +243,34 @@ static void cpsw_ale_flush_mcast(struct cpsw_ale *ale, u32 *ale_entry,
 	mask &= ~port_mask;
 
 	/* free if only remaining port is host port */
-	if (mask == BIT(ale->params.ale_ports))
-		cpsw_ale_set_entry_type(ale_entry, ALE_TYPE_FREE);
-	else
+	if (mask)
 		cpsw_ale_set_port_mask(ale_entry, mask);
+	else
+		cpsw_ale_set_entry_type(ale_entry, ALE_TYPE_FREE);
+}
+
+int cpsw_ale_flush_multicast(struct cpsw_ale *ale, int port_mask)
+{
+	u32 ale_entry[ALE_ENTRY_WORDS];
+	int ret, idx;
+
+	for (idx = 0; idx < ale->params.ale_entries; idx++) {
+		cpsw_ale_read(ale, idx, ale_entry);
+		ret = cpsw_ale_get_entry_type(ale_entry);
+		if (ret != ALE_TYPE_ADDR && ret != ALE_TYPE_VLAN_ADDR)
+			continue;
+
+		if (cpsw_ale_get_mcast(ale_entry)) {
+			u8 addr[6];
+
+			cpsw_ale_get_addr(ale_entry, addr);
+			if (!is_broadcast_ether_addr(addr))
+				cpsw_ale_flush_mcast(ale, ale_entry, port_mask);
+		}
+
+		cpsw_ale_write(ale, idx, ale_entry);
+	}
+	return 0;
 }
 
 static void cpsw_ale_flush_ucast(struct cpsw_ale *ale, u32 *ale_entry,
@@ -249,19 +305,172 @@ int cpsw_ale_flush(struct cpsw_ale *ale, int port_mask)
 	return 0;
 }
 
-int cpsw_ale_add_ucast(struct cpsw_ale *ale, u8 *addr, int port, int flags)
+static int cpsw_ale_dump_mcast(u32 *ale_entry, char *buf, int len)
+{
+	int outlen = 0;
+	static const char * const str_mcast_state[] = {"f", "blf", "lf", "f"};
+	int mcast_state = cpsw_ale_get_mcast_state(ale_entry);
+	int port_mask   = cpsw_ale_get_port_mask(ale_entry);
+	int super       = cpsw_ale_get_super(ale_entry);
+
+	outlen += snprintf(buf + outlen, len - outlen,
+			   "mcstate: %s(%d), ", str_mcast_state[mcast_state],
+			   mcast_state);
+	outlen += snprintf(buf + outlen, len - outlen,
+			   "port mask: %x, %ssuper\n", port_mask,
+			   super ? "" : "no ");
+	return outlen;
+}
+
+static int cpsw_ale_dump_ucast(u32 *ale_entry, char *buf, int len)
+{
+	int outlen = 0;
+	static const char * const str_ucast_type[] = {"persistant", "untouched",
+							"oui", "touched"};
+	int ucast_type  = cpsw_ale_get_ucast_type(ale_entry);
+	int port_num    = cpsw_ale_get_port_num(ale_entry);
+	int secure      = cpsw_ale_get_secure(ale_entry);
+	int blocked     = cpsw_ale_get_blocked(ale_entry);
+
+	outlen += snprintf(buf + outlen, len - outlen,
+			   "uctype: %s(%d)", str_ucast_type[ucast_type],
+			   ucast_type);
+	if (ucast_type == ALE_UCAST_OUI)
+		outlen += snprintf(buf + outlen, len - outlen, "\n");
+	else
+		outlen += snprintf(buf + outlen, len - outlen,
+				", port: %d%s%s\n", port_num,
+				secure ? ", Secure" : "",
+				blocked ? ", Blocked" : "");
+	return outlen;
+}
+
+static int cpsw_ale_dump_vlan(u32 *ale_entry, char *buf, int len)
+{
+	int outlen = 0;
+	int force_utag_egress	= cpsw_ale_get_vlan_untag_force(ale_entry);
+	int reg_mc_fld		= cpsw_ale_get_vlan_reg_mcast(ale_entry);
+	int unreg_mc_fld	= cpsw_ale_get_vlan_unreg_mcast(ale_entry);
+	int mem_list		= cpsw_ale_get_vlan_member_list(ale_entry);
+
+	outlen += snprintf(buf + outlen, len - outlen,
+			   "force_untag_egress: %02x, ", force_utag_egress);
+	outlen += snprintf(buf + outlen, len - outlen,
+			   "reg_fld: %02x, ", reg_mc_fld);
+	outlen += snprintf(buf + outlen, len - outlen,
+			   "unreg_fld: %02x, ", unreg_mc_fld);
+	outlen += snprintf(buf + outlen, len - outlen,
+			   "mem_list: %02x\n", mem_list);
+	return outlen;
+}
+
+static int cpsw_ale_dump_entry(int idx, u32 *ale_entry, char *buf, int len)
+{
+	int type, outlen = 0;
+	u8 addr[6];
+	static const char * const str_type[] = {"free", "addr",
+						"vlan", "vlan+addr"};
+
+	type = cpsw_ale_get_entry_type(ale_entry);
+	if (type == ALE_TYPE_FREE)
+		return outlen;
+
+	if (len < ALE_TBL_ENTRY_SHOW_LEN)
+		return outlen;
+
+	if (idx >= 0) {
+		outlen += snprintf(buf + outlen, len - outlen,
+				   "index %d, ", idx);
+	}
+
+	outlen += snprintf(buf + outlen, len - outlen, "raw: %08x %08x %08x, ",
+			   ale_entry[0], ale_entry[1], ale_entry[2]);
+
+	outlen += snprintf(buf + outlen, len - outlen,
+			   "type: %s(%d), ", str_type[type], type);
+
+	if (type != ALE_TYPE_VLAN) {
+		cpsw_ale_get_addr(ale_entry, addr);
+		outlen += snprintf(buf + outlen, len - outlen,
+			   "addr: " ADDR_FMT_STR ", ", ADDR_FMT_ARGS(addr));
+	}
+
+	if (type == ALE_TYPE_VLAN || type == ALE_TYPE_VLAN_ADDR) {
+		outlen += snprintf(buf + outlen, len - outlen, "vlan: %d, ",
+				   cpsw_ale_get_vlan_id(ale_entry));
+	}
+
+	if (type == ALE_TYPE_VLAN)
+		outlen += cpsw_ale_dump_vlan(ale_entry,
+				buf + outlen, len - outlen);
+	else
+		outlen += cpsw_ale_get_mcast(ale_entry) ?
+		  cpsw_ale_dump_mcast(ale_entry, buf + outlen, len - outlen) :
+		  cpsw_ale_dump_ucast(ale_entry, buf + outlen, len - outlen);
+
+	return outlen;
+}
+
+int cpsw_ale_add_vlan(struct cpsw_ale *ale, int vid, int member_list,
+		      int reg_mcast, int unreg_mcast, int force_untag_egress)
 {
 	u32 ale_entry[ALE_ENTRY_WORDS] = {0, 0, 0};
 	int idx;
 
-	cpsw_ale_set_entry_type(ale_entry, ALE_TYPE_ADDR);
+	cpsw_ale_set_entry_type(ale_entry, ALE_TYPE_VLAN);
+	cpsw_ale_set_vlan_id(ale_entry, vid);
+	cpsw_ale_set_vlan_untag_force(ale_entry, force_untag_egress);
+	cpsw_ale_set_vlan_reg_mcast(ale_entry, reg_mcast);
+	cpsw_ale_set_vlan_unreg_mcast(ale_entry, unreg_mcast);
+	cpsw_ale_set_vlan_member_list(ale_entry, member_list);
+
+	idx = cpsw_ale_match_vlan(ale, vid);
+	if (idx < 0)
+		idx = cpsw_ale_match_free(ale);
+	if (idx < 0)
+		idx = cpsw_ale_find_ageable(ale);
+	if (idx < 0)
+		return -ENOMEM;
+
+	cpsw_ale_write(ale, idx, ale_entry);
+
+	return 0;
+}
+
+int cpsw_ale_del_vlan(struct cpsw_ale *ale, int vid)
+{
+	u32 ale_entry[ALE_ENTRY_WORDS] = {0, 0, 0};
+	int idx;
+
+	idx = cpsw_ale_match_vlan(ale, vid);
+	if (idx < 0)
+		return -ENOENT;
+
+	cpsw_ale_set_entry_type(ale_entry, ALE_TYPE_FREE);
+	cpsw_ale_write(ale, idx, ale_entry);
+
+	return 0;
+}
+
+int cpsw_ale_add_ucast(struct cpsw_ale *ale, u8 *addr, int port,
+		       int flags, int vid)
+{
+	u32 ale_entry[ALE_ENTRY_WORDS] = {0, 0, 0};
+	int idx;
+
+	if (vid >= 0) {
+		cpsw_ale_set_entry_type(ale_entry, ALE_TYPE_VLAN_ADDR);
+		cpsw_ale_set_vlan_id(ale_entry, vid);
+	} else
+		cpsw_ale_set_entry_type(ale_entry, ALE_TYPE_ADDR);
+
 	cpsw_ale_set_addr(ale_entry, addr);
 	cpsw_ale_set_ucast_type(ale_entry, ALE_UCAST_PERSISTANT);
 	cpsw_ale_set_secure(ale_entry, (flags & ALE_SECURE) ? 1 : 0);
 	cpsw_ale_set_blocked(ale_entry, (flags & ALE_BLOCKED) ? 1 : 0);
 	cpsw_ale_set_port_num(ale_entry, port);
 
-	idx = cpsw_ale_match_addr(ale, addr);
+	idx = cpsw_ale_match_addr(ale, addr, vid);
 	if (idx < 0)
 		idx = cpsw_ale_match_free(ale);
 	if (idx < 0)
@@ -273,12 +482,12 @@ int cpsw_ale_add_ucast(struct cpsw_ale *ale, u8 *addr, int port, int flags)
 	return 0;
 }
 
-int cpsw_ale_del_ucast(struct cpsw_ale *ale, u8 *addr, int port)
+int cpsw_ale_del_ucast(struct cpsw_ale *ale, u8 *addr, int port, int vid)
 {
 	u32 ale_entry[ALE_ENTRY_WORDS] = {0, 0, 0};
 	int idx;
 
-	idx = cpsw_ale_match_addr(ale, addr);
+	idx = cpsw_ale_match_addr(ale, addr, vid);
 	if (idx < 0)
 		return -ENOENT;
 
@@ -288,16 +497,21 @@ int cpsw_ale_del_ucast(struct cpsw_ale *ale, u8 *addr, int port)
 }
 
 int cpsw_ale_add_mcast(struct cpsw_ale *ale, u8 *addr, int port_mask,
-			int super, int mcast_state)
+			int super, int mcast_state, int vid)
 {
 	u32 ale_entry[ALE_ENTRY_WORDS] = {0, 0, 0};
 	int idx, mask;
 
-	idx = cpsw_ale_match_addr(ale, addr);
+	idx = cpsw_ale_match_addr(ale, addr, vid);
 	if (idx >= 0)
 		cpsw_ale_read(ale, idx, ale_entry);
 
-	cpsw_ale_set_entry_type(ale_entry, ALE_TYPE_ADDR);
+	if (vid >= 0) {
+		cpsw_ale_set_entry_type(ale_entry, ALE_TYPE_VLAN_ADDR);
+		cpsw_ale_set_vlan_id(ale_entry, vid);
+	} else
+		cpsw_ale_set_entry_type(ale_entry, ALE_TYPE_ADDR);
+
 	cpsw_ale_set_addr(ale_entry, addr);
 	cpsw_ale_set_super(ale_entry, super);
 	cpsw_ale_set_mcast_state(ale_entry, mcast_state);
@@ -317,12 +531,12 @@ int cpsw_ale_add_mcast(struct cpsw_ale *ale, u8 *addr, int port_mask,
 	return 0;
 }
 
-int cpsw_ale_del_mcast(struct cpsw_ale *ale, u8 *addr, int port_mask)
+int cpsw_ale_del_mcast(struct cpsw_ale *ale, u8 *addr, int port_mask, int vid)
 {
 	u32 ale_entry[ALE_ENTRY_WORDS] = {0, 0, 0};
 	int idx;
 
-	idx = cpsw_ale_match_addr(ale, addr);
+	idx = cpsw_ale_match_addr(ale, addr, vid);
 	if (idx < 0)
 		return -EINVAL;
 
@@ -345,6 +559,14 @@ struct ale_control_info {
 };
 
 static const struct ale_control_info ale_controls[ALE_NUM_CONTROLS] = {
+	[ALE_VERSION]		= {
+		.name		= "version",
+		.offset		= ALE_IDVER,
+		.port_offset	= 0,
+		.shift		= 0,
+		.port_shift	= 0,
+		.bits		= 32,
+	},
 	[ALE_ENABLE]		= {
 		.name		= "enable",
 		.offset		= ALE_CONTROL,
@@ -369,6 +591,14 @@ static const struct ale_control_info ale_controls[ALE_NUM_CONTROLS] = {
 		.port_shift	= 0,
 		.bits		= 1,
 	},
+	[ALE_UNI_FLOOD]		= {
+		.name		= "p0_uni_flood_en",
+		.offset		= ALE_CONTROL,
+		.port_offset	= 0,
+		.shift		= 8,
+		.port_shift	= 0,
+		.bits		= 1,
+	},
 	[ALE_VLAN_NOLEARN]	= {
 		.name		= "vlan_nolearn",
 		.offset		= ALE_CONTROL,
@@ -506,7 +736,7 @@ static const struct ale_control_info ale_controls[ALE_NUM_CONTROLS] = {
 		.bits		= 6,
 	},
 	[ALE_PORT_UNTAGGED_EGRESS] = {
-		.name		= "untagged_egress",
+		.name		= "unknown_force_untag_egress",
 		.offset		= ALE_UNKNOWNVLAN,
 		.port_offset	= 0,
 		.shift		= 24,
@@ -569,6 +799,622 @@ int cpsw_ale_control_get(struct cpsw_ale *ale, int port, int control)
 	return tmp & BITMASK(info->bits);
 }
 
+static ssize_t cpsw_ale_control_show(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	int i, port, len = 0;
+	const struct ale_control_info *info;
+	struct cpsw_ale *ale = control_attr_to_ale(attr);
+	u32 reg;
+
+	for (i = 0, info = ale_controls; i < ALE_NUM_CONTROLS; i++, info++) {
+		if (i == ALE_VERSION) {
+			reg = cpsw_ale_control_get(ale, 0, i);
+			len += snprintf(buf + len, SZ_4K - len,
+					"%s=(ALE_ID=0x%04x) Rev %d.%d\n",
+					info->name,
+					(reg & 0xffff0000) >> 16,
+					ALE_VERSION_MAJOR(reg),
+					ALE_VERSION_MINOR(reg));
+			continue;
+		}
+
+		/* global controls */
+		if (info->port_shift == 0 &&  info->port_offset == 0) {
+			len += snprintf(buf + len, SZ_4K - len,
+					"%s=%d\n", info->name,
+					cpsw_ale_control_get(ale, 0, i));
+			continue;
+		}
+
+		/* port specific controls */
+		for (port = 0; port < ale->params.ale_ports; port++) {
+			len += snprintf(buf + len, SZ_4K - len,
+					"%s.%d=%d\n", info->name, port,
+					cpsw_ale_control_get(ale, port, i));
+		}
+	}
+
+	return len;
+}
+
+static ssize_t cpsw_ale_control_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	char ctrl_str[33], tmp_str[9];
+	int port = 0, value, len, ret, control;
+	unsigned long end;
+	struct cpsw_ale *ale = control_attr_to_ale(attr);
+
+	len = strcspn(buf, ".=");
+	if (len >= 32)
+		return -ENOMEM;
+
+	strncpy(ctrl_str, buf, len);
+	ctrl_str[len] = '\0';
+	buf += len;
+
+	if (*buf == '.') {
+		++buf;
+		len = strcspn(buf, "=");
+		if (len >= 8)
+			return -ENOMEM;
+		strncpy(tmp_str, buf, len);
+		tmp_str[len] = '\0';
+		if (kstrtoul(tmp_str, 0, &end))
+			return -EINVAL;
+		port = (int)end;
+		buf += len;
+	}
+
+	if (*buf != '=')
+		return -EINVAL;
+
+	if (kstrtoul(buf + 1, 0, &end))
+		return -EINVAL;
+
+	value = (int)end;
+
+	for (control = 0; control < ALE_NUM_CONTROLS; control++)
+		if (strcmp(ctrl_str, ale_controls[control].name) == 0)
+			break;
+
+	if (control >= ALE_NUM_CONTROLS)
+		return -ENOENT;
+
+	dev_dbg(ale->params.dev, "processing command %s.%d=%d\n",
+		ale_controls[control].name, port, value);
+
+	ret = cpsw_ale_control_set(ale, port, control, value);
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+DEVICE_ATTR(ale_control, S_IRUGO | S_IWUSR,
+	cpsw_ale_control_show, cpsw_ale_control_store);
+
+static ssize_t cpsw_ale_table_show(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	int len = SZ_4K, outlen = 0, idx, start;
+	u32 ale_entry[ALE_ENTRY_WORDS];
+	struct cpsw_ale *ale = table_attr_to_ale(attr);
+	int not_shown = 0, total_outlen = 0, type, shown = 0;
+
+	start = ale->show_next;
+
+	for (idx = start; (idx < ale->params.ale_entries) &&
+			(len > total_outlen); idx++) {
+		cpsw_ale_read(ale, idx, ale_entry);
+		outlen = cpsw_ale_dump_entry(idx, ale_entry,
+				buf + total_outlen, len - total_outlen);
+		if (outlen == 0) {
+			type = cpsw_ale_get_entry_type(ale_entry);
+			if (type != ALE_TYPE_FREE) {
+				++not_shown;
+				break;
+			}
+		} else {
+			total_outlen += outlen;
+			++shown;
+		}
+	}
+
+	/* update next show index */
+	if (idx >= ale->params.ale_entries)
+		ale->show_next = 0;
+	else
+		ale->show_next = idx;
+
+	if (len > total_outlen + 32)
+		total_outlen += snprintf(buf + total_outlen, len - total_outlen,
+				"[%d..%d]: %d entries%s\n", start, idx - 1,
+				shown, not_shown ? ", +" : "");
+
+	return total_outlen;
+}
+
+struct ale_table_param {
+	const char *name;
+	union	{
+		int	val;
+		u8	addr[6];
+	};
+};
+
+struct ale_table_cmd {
+	const char *name;
+	int (*process)(struct cpsw_ale *ale,
+		const u8 *params_str, size_t str_len);
+};
+
+static struct ale_table_param vlan_params[] = {
+	[ALE_VP_VID]		= { .name = "vid", },
+	[ALE_VP_FORCE_UT_EGR]	= { .name = "force_untag_egress", },
+	[ALE_VP_REG_FLD]	= { .name = "reg_fld_mask", },
+	[ALE_VP_UNREG_FLD]	= { .name = "unreg_fld_mask", },
+	[ALE_VP_M_LIST]		= { .name = "mem_list", },
+};
+
+static struct ale_table_param vlan_ucast_params[] = {
+	[ALE_UP_PORT]		= { .name = "port", },
+	[ALE_UP_BLOCK]		= { .name = "block", },
+	[ALE_UP_SECURE]		= { .name = "secure", },
+	[ALE_UP_AGEABLE]	= { .name = "ageable", },
+	[ALE_UP_ADDR]		= { .name = "addr", },
+	[ALE_UP_VID]		= { .name = "vid", },
+};
+
+static struct ale_table_param vlan_mcast_params[] = {
+	[ALE_MP_PORT_MASK]	= { .name = "port_mask", },
+	[ALE_MP_SUPER]		= { .name = "supervisory", },
+	[ALE_MP_FW_ST]		= { .name = "mc_fw_st", },
+	[ALE_MP_ADDR]		= { .name = "addr", },
+	[ALE_MP_VID]		= { .name = "vid", },
+};
+
+static struct ale_table_param oui_params[] = {
+	{ .name	= "addr", },
+};
+
+void cpsw_ale_table_store_init_params(
+	struct ale_table_param *params, int param_num)
+{
+	int i;
+
+	for (i = 0; i < param_num; i++)
+		memset(params[i].addr, 0, 6);
+}
+
+int cpsw_ale_table_store_get_params(struct cpsw_ale *ale,
+	struct ale_table_param *params, int param_num,
+	const u8 *params_str, size_t str_len)
+{
+	char param_name[33], val_str[33];
+	size_t tmp_len = str_len;
+	unsigned int iaddr[6];
+	unsigned long end;
+	int len, i, n, addr_len;
+
+	while (tmp_len > 0) {
+		len = strcspn(params_str, "=");
+		if (len >= 32)
+			return -ENOMEM;
+
+		strncpy(param_name, params_str, len);
+		param_name[len] = '\0';
+		params_str += len;
+		tmp_len -= len;
+
+		if (*params_str != '=')
+			return -EINVAL;
+
+		++params_str;
+		--tmp_len;
+
+		len = strcspn(params_str, ".");
+		if (len >= 32)
+			return -ENOMEM;
+
+		strncpy(val_str, params_str, len);
+		val_str[len] = '\0';
+		params_str += len;
+		tmp_len -= len;
+
+		if (*params_str == '.') {
+			++params_str;
+			--tmp_len;
+		}
+
+		for (n = 0; n < param_num; n++) {
+			if (strcmp(param_name, params[n].name) != 0)
+				continue;
+
+			if (strcmp(param_name, "addr") == 0) {
+				addr_len = sscanf(val_str,
+					"%02x:%02x:%02x:%02x:%02x:%02x",
+					&iaddr[0], &iaddr[1], &iaddr[2],
+					&iaddr[3], &iaddr[4], &iaddr[5]);
+				if (addr_len != 6 && addr_len != 3)
+					return -EINVAL;
+
+				for (i = 0; i < addr_len; i++)
+					params[n].addr[i] = iaddr[i];
+
+				break;
+			}
+
+			if (kstrtoul(val_str, 0, &end))
+				return -EINVAL;
+
+			params[n].val = (int)end;
+			break;
+		}
+
+		if (n >= param_num)
+			return -EINVAL;
+	}
+
+	return str_len;
+}
+
+int cpsw_ale_table_store_vlan(struct cpsw_ale *ale,
+			const u8 *params_str, size_t str_len)
+{
+	int ret;
+
+	cpsw_ale_table_store_init_params(vlan_params, ALE_VP_NUM);
+	vlan_params[ALE_VP_VID].val = -1;
+
+	ret = cpsw_ale_table_store_get_params(ale,
+		vlan_params, ALE_VP_NUM, params_str, str_len);
+
+	if (ret < 0)
+		return ret;
+
+	ret = cpsw_ale_add_vlan(ale,
+		vlan_params[ALE_VP_VID].val,
+		vlan_params[ALE_VP_M_LIST].val,
+		vlan_params[ALE_VP_REG_FLD].val,
+		vlan_params[ALE_VP_UNREG_FLD].val,
+		vlan_params[ALE_VP_FORCE_UT_EGR].val);
+
+	if (ret < 0)
+		return ret;
+	else
+		return str_len;
+}
+
+int cpsw_ale_table_store_vlan_ucast(struct cpsw_ale *ale,
+		const u8 *params_str, size_t str_len, int has_vid)
+{
+	int ret, flags = 0;
+
+	cpsw_ale_table_store_init_params(vlan_ucast_params, ALE_UP_NUM);
+	vlan_ucast_params[ALE_UP_VID].val = -1;
+
+	ret = cpsw_ale_table_store_get_params(ale,
+		vlan_ucast_params, ALE_UP_NUM,
+		params_str, str_len);
+
+	if (ret < 0)
+		return ret;
+
+	if (!has_vid && vlan_ucast_params[ALE_UP_VID].val >= 0)
+		return -EINVAL;
+
+	if (vlan_ucast_params[ALE_UP_BLOCK].val)
+		flags |= ALE_BLOCKED;
+
+	if (vlan_ucast_params[ALE_UP_SECURE].val)
+		flags |= ALE_SECURE;
+
+	cpsw_ale_add_ucast(ale,
+		vlan_ucast_params[ALE_UP_ADDR].addr,
+		vlan_ucast_params[ALE_UP_PORT].val,
+		flags,
+		vlan_ucast_params[ALE_UP_VID].val);
+
+	return str_len;
+}
+
+int cpsw_ale_table_store_u_proc(struct cpsw_ale *ale,
+		const u8 *params_str, size_t str_len)
+{
+	return  cpsw_ale_table_store_vlan_ucast(ale, params_str, str_len, 0);
+}
+
+int cpsw_ale_table_store_vu_proc(struct cpsw_ale *ale,
+		const u8 *params_str, size_t str_len)
+{
+	return  cpsw_ale_table_store_vlan_ucast(ale, params_str, str_len, 1);
+}
+
+int cpsw_ale_table_store_vlan_mcast(struct cpsw_ale *ale,
+		const u8 *params_str, size_t str_len, int has_vid)
+{
+	int ret;
+
+	cpsw_ale_table_store_init_params(vlan_mcast_params, ALE_MP_NUM);
+	vlan_mcast_params[ALE_MP_VID].val = -1;
+
+	ret = cpsw_ale_table_store_get_params(ale,
+		vlan_mcast_params, ALE_MP_NUM,
+		params_str, str_len);
+
+	if (ret < 0)
+		return ret;
+
+	if (!has_vid && vlan_mcast_params[ALE_MP_VID].val >= 0)
+		return -EINVAL;
+
+	cpsw_ale_add_mcast(ale,
+		vlan_mcast_params[ALE_MP_ADDR].addr,
+		vlan_mcast_params[ALE_MP_PORT_MASK].val,
+		vlan_mcast_params[ALE_MP_SUPER].val,
+		vlan_mcast_params[ALE_MP_FW_ST].val,
+		vlan_mcast_params[ALE_MP_VID].val);
+
+	return str_len;
+}
+
+int cpsw_ale_table_store_m_proc(struct cpsw_ale *ale,
+			const u8 *params_str, size_t str_len)
+{
+	return  cpsw_ale_table_store_vlan_mcast(ale, params_str, str_len, 0);
+}
+
+int cpsw_ale_table_store_vm_proc(struct cpsw_ale *ale,
+			const u8 *params_str, size_t str_len)
+{
+	return  cpsw_ale_table_store_vlan_mcast(ale, params_str, str_len, 1);
+}
+
+int cpsw_ale_add_oui(struct cpsw_ale *ale, u8 *addr)
+{
+	u32 ale_entry[ALE_ENTRY_WORDS] = {0, 0, 0};
+	int idx;
+
+	cpsw_ale_set_entry_type(ale_entry, ALE_TYPE_ADDR);
+
+	cpsw_ale_set_addr(ale_entry, addr);
+	cpsw_ale_set_ucast_type(ale_entry, ALE_UCAST_OUI);
+
+	idx = cpsw_ale_match_addr(ale, addr, -1);
+	if (idx < 0)
+		idx = cpsw_ale_match_free(ale);
+	if (idx < 0)
+		idx = cpsw_ale_find_ageable(ale);
+	if (idx < 0)
+		return -ENOMEM;
+
+	cpsw_ale_write(ale, idx, ale_entry);
+	return 0;
+}
+
+int cpsw_ale_table_store_oui(struct cpsw_ale *ale,
+			const u8 *params_str, size_t str_len)
+{
+	int ret;
+
+	cpsw_ale_table_store_init_params(oui_params, 1);
+
+	ret = cpsw_ale_table_store_get_params(ale,
+		oui_params, 1, params_str, str_len);
+
+	if (ret < 0)
+		return ret;
+
+	/* Clear out the don't cares */
+	oui_params[0].addr[3] = 0;
+	oui_params[0].addr[4] = 0;
+	oui_params[0].addr[5] = 0;
+
+	cpsw_ale_add_oui(ale, oui_params[0].addr);
+
+	return str_len;
+}
+
+int cpsw_ale_table_store_del(struct cpsw_ale *ale, int idx)
+{
+	u32 ale_entry[ALE_ENTRY_WORDS];
+	int type;
+
+	dev_dbg(ale->params.dev, "deleting entry[%d] ...\n", idx);
+
+	if (idx >= ale->params.ale_entries)
+		return -EINVAL;
+
+	cpsw_ale_read(ale, idx, ale_entry);
+
+	type = cpsw_ale_get_entry_type(ale_entry);
+	if (type == ALE_TYPE_FREE)
+		return -EINVAL;
+
+	cpsw_ale_set_entry_type(ale_entry, ALE_TYPE_FREE);
+	cpsw_ale_write(ale, idx, ale_entry);
+	return 0;
+}
+
+static struct ale_table_cmd ale_table_cmds[] = {
+	{
+		.name		= "v",
+		.process	= cpsw_ale_table_store_vlan,
+	},
+	{
+		.name		= "m",
+		.process	= cpsw_ale_table_store_m_proc,
+	},
+	{
+		.name		= "vm",
+		.process	= cpsw_ale_table_store_vm_proc,
+	},
+	{
+		.name		= "u",
+		.process	= cpsw_ale_table_store_u_proc,
+	},
+	{
+		.name		= "vu",
+		.process	= cpsw_ale_table_store_vu_proc,
+	},
+	{
+		.name		= "o",
+		.process	= cpsw_ale_table_store_oui,
+	},
+};
+
+static ssize_t cpsw_ale_table_store_proc(struct cpsw_ale *ale,
+				const char *buf, size_t count)
+{
+	char ctrl_str[33];
+	unsigned long end;
+	int len, i, tmp_count = count, ret = -EINVAL;
+
+	len = strcspn(buf, ".:");
+	if (len >= 5)
+		return -ENOMEM;
+
+	strncpy(ctrl_str, buf, len);
+	ctrl_str[len] = '\0';
+
+	/* skip to param beginning */
+	buf += len;
+	tmp_count -= len;
+
+	if (*buf == ':') {
+		/* delete cmd */
+		if (kstrtoul(ctrl_str, 0, &end))
+			return -EINVAL;
+		ret = cpsw_ale_table_store_del(ale, end);
+		if (ret != 0)
+			return ret;
+		else
+			return count;
+	}
+
+	if (len >= 3)
+		return -ENOMEM;
+
+	if (*buf != '.')
+		return -EINVAL;
+
+	++buf;
+	--tmp_count;
+
+	for (i = 0; i < ARRAY_SIZE(ale_table_cmds); i++) {
+		if (strcmp(ale_table_cmds[i].name, ctrl_str) == 0) {
+			ret = ale_table_cmds[i].process(ale, buf, tmp_count);
+			break;
+		}
+	}
+
+	if (ret < 0)
+		return ret;
+	else
+		return count;
+}
+
+static ssize_t cpsw_ale_table_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	struct cpsw_ale *ale = table_attr_to_ale(attr);
+
+	return cpsw_ale_table_store_proc(ale, buf, count);
+}
+DEVICE_ATTR(ale_table, S_IRUGO | S_IWUSR,
+	cpsw_ale_table_show, cpsw_ale_table_store);
+
+static int cpsw_ale_dump_entry_raw(int idx, u32 *ale_entry, char *buf, int len)
+{
+	int type, outlen = 0;
+
+	type = cpsw_ale_get_entry_type(ale_entry);
+	if (type == ALE_TYPE_FREE)
+		return outlen;
+
+	if (len < ALE_RAW_TBL_ENTRY_SHOW_LEN)
+		return outlen;
+
+	if (idx >= 0)
+		outlen += snprintf(buf + outlen, len - outlen,
+				   "%d: ", idx);
+
+	outlen += snprintf(buf + outlen, len - outlen, "%02x %08x %08x\n",
+			   ale_entry[0], ale_entry[1], ale_entry[2]);
+
+	return outlen;
+}
+
+static ssize_t cpsw_ale_table_raw_show(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	struct cpsw_ale *ale = table_raw_attr_to_ale(attr);
+	int not_shown = 0, total_outlen = 0, shown = 0;
+	int outlen = 0, idx, start, type;
+	u32 ale_entry[ALE_ENTRY_WORDS];
+
+	start = ale->raw_show_next;
+
+	for (idx = start; (idx < ale->params.ale_entries) &&
+				(PAGE_SIZE > total_outlen); idx++) {
+		cpsw_ale_read(ale, idx, ale_entry);
+		outlen = cpsw_ale_dump_entry_raw(idx, ale_entry,
+					buf + total_outlen,
+					PAGE_SIZE - total_outlen);
+		if (outlen == 0) {
+			type = cpsw_ale_get_entry_type(ale_entry);
+			if (type != ALE_TYPE_FREE) {
+				++not_shown;
+				break;
+			}
+		} else {
+			total_outlen += outlen;
+			++shown;
+		}
+	}
+
+	/* update next show index */
+	if (idx >= ale->params.ale_entries)
+		ale->raw_show_next = 0;
+	else
+		ale->raw_show_next = idx;
+
+	if (PAGE_SIZE > total_outlen + 32)
+		total_outlen += snprintf(buf + total_outlen,
+			PAGE_SIZE - total_outlen,
+			"[%d..%d]: %d entries%s\n",
+			start, idx - 1, shown, not_shown ? ", +" : "");
+
+	return total_outlen;
+}
+
+static ssize_t cpsw_ale_table_raw_store(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	struct cpsw_ale *ale = table_raw_attr_to_ale(attr);
+	unsigned long end;
+
+	if (kstrtoul(buf, 0, &end) == 0) {
+		/* set start-show-index command */
+		ale->raw_show_next = (int)end;
+		if (ale->raw_show_next >= ale->params.ale_entries)
+			ale->raw_show_next = 0;
+		return count;
+	}
+
+	/* add or delete command */
+	return cpsw_ale_table_store_proc(ale, buf, count);
+}
+DEVICE_ATTR(ale_table_raw, S_IRUGO | S_IWUSR,
+	cpsw_ale_table_raw_show, cpsw_ale_table_raw_store);
+
 static void cpsw_ale_timer(unsigned long arg)
 {
 	struct cpsw_ale *ale = (struct cpsw_ale *)arg;
@@ -595,13 +1441,26 @@ int cpsw_ale_set_ageout(struct cpsw_ale *ale, int ageout)
 void cpsw_ale_start(struct cpsw_ale *ale)
 {
 	u32 rev;
+	int ret;
 
 	rev = __raw_readl(ale->params.ale_regs + ALE_IDVER);
-	dev_dbg(ale->params.dev, "initialized cpsw ale revision %d.%d\n",
+	dev_info(ale->params.dev, "initialized cpsw ale revision %d.%d\n",
 		ALE_VERSION_MAJOR(rev), ALE_VERSION_MINOR(rev));
 	cpsw_ale_control_set(ale, 0, ALE_ENABLE, 1);
 	cpsw_ale_control_set(ale, 0, ALE_CLEAR, 1);
 
+	ale->ale_control_attr = dev_attr_ale_control;
+	ret = device_create_file(ale->params.dev, &ale->ale_control_attr);
+	WARN_ON(ret < 0);
+
+	ale->ale_table_attr = dev_attr_ale_table;
+	ret = device_create_file(ale->params.dev, &ale->ale_table_attr);
+	WARN_ON(ret < 0);
+
+	ale->ale_table_raw_attr = dev_attr_ale_table_raw;
+	ret = device_create_file(ale->params.dev, &ale->ale_table_raw_attr);
+	WARN_ON(ret < 0);
+
 	init_timer(&ale->timer);
 	ale->timer.data	    = (unsigned long)ale;
 	ale->timer.function = cpsw_ale_timer;
@@ -614,6 +1473,9 @@ void cpsw_ale_start(struct cpsw_ale *ale)
 void cpsw_ale_stop(struct cpsw_ale *ale)
 {
 	del_timer_sync(&ale->timer);
+	device_remove_file(ale->params.dev, &ale->ale_table_attr);
+	device_remove_file(ale->params.dev, &ale->ale_control_attr);
+	device_remove_file(ale->params.dev, &ale->ale_table_raw_attr);
 }
 
 struct cpsw_ale *cpsw_ale_create(struct cpsw_ale_params *params)
diff --git a/drivers/net/ethernet/ti/cpsw_ale.h b/drivers/net/ethernet/ti/cpsw_ale.h
index a95b37b..ed33762 100644
--- a/drivers/net/ethernet/ti/cpsw_ale.h
+++ b/drivers/net/ethernet/ti/cpsw_ale.h
@@ -27,13 +27,26 @@ struct cpsw_ale {
 	struct cpsw_ale_params	params;
 	struct timer_list	timer;
 	unsigned long		ageout;
+	struct device_attribute ale_control_attr;
+#define control_attr_to_ale(attr)	\
+	container_of(attr, struct cpsw_ale, ale_control_attr)
+	struct device_attribute ale_table_attr;
+#define table_attr_to_ale(attr)		\
+	container_of(attr, struct cpsw_ale, ale_table_attr)
+	struct device_attribute ale_table_raw_attr;
+#define table_raw_attr_to_ale(attr)		\
+	container_of(attr, struct cpsw_ale, ale_table_raw_attr)
+	int show_next;
+	int raw_show_next;
 };
 
 enum cpsw_ale_control {
 	/* global */
+	ALE_VERSION,
 	ALE_ENABLE,
 	ALE_CLEAR,
 	ALE_AGEOUT,
+	ALE_UNI_FLOOD,
 	ALE_VLAN_NOLEARN,
 	ALE_NO_PORT_VLAN,
 	ALE_OUI_DENY,
@@ -80,14 +93,51 @@ void cpsw_ale_stop(struct cpsw_ale *ale);
 
 int cpsw_ale_set_ageout(struct cpsw_ale *ale, int ageout);
 int cpsw_ale_flush(struct cpsw_ale *ale, int port_mask);
-int cpsw_ale_add_ucast(struct cpsw_ale *ale, u8 *addr, int port, int flags);
-int cpsw_ale_del_ucast(struct cpsw_ale *ale, u8 *addr, int port);
+int cpsw_ale_flush_multicast(struct cpsw_ale *ale, int port_mask);
+int cpsw_ale_add_ucast(struct cpsw_ale *ale, u8 *addr, int port,
+		       int flags, int vid);
+int cpsw_ale_del_ucast(struct cpsw_ale *ale, u8 *addr, int port, int vid);
 int cpsw_ale_add_mcast(struct cpsw_ale *ale, u8 *addr, int port_mask,
-			int super, int mcast_state);
-int cpsw_ale_del_mcast(struct cpsw_ale *ale, u8 *addr, int port_mask);
+			int super, int mcast_state, int vid);
+int cpsw_ale_del_mcast(struct cpsw_ale *ale, u8 *addr, int port_mask, int vid);
+
+int cpsw_ale_add_vlan(struct cpsw_ale *ale, int vid, int member_list,
+		      int reg_mcast, int unreg_mcast, int force_untag_egress);
+int cpsw_ale_del_vlan(struct cpsw_ale *ale, int vid);
 
 int cpsw_ale_control_get(struct cpsw_ale *ale, int port, int control);
 int cpsw_ale_control_set(struct cpsw_ale *ale, int port,
 			 int control, int value);
 
+/* ALE Table store VLAN command param indices */
+enum {
+	ALE_VP_VID,
+	ALE_VP_FORCE_UT_EGR,
+	ALE_VP_REG_FLD,
+	ALE_VP_UNREG_FLD,
+	ALE_VP_M_LIST,
+	ALE_VP_NUM,
+};
+
+/* ALE Table store UCAST command param indices */
+enum {
+	ALE_UP_PORT,
+	ALE_UP_BLOCK,
+	ALE_UP_SECURE,
+	ALE_UP_AGEABLE,
+	ALE_UP_ADDR,
+	ALE_UP_VID,
+	ALE_UP_NUM,
+};
+
+/* ALE Table store MCAST command param indices */
+enum {
+	ALE_MP_PORT_MASK,
+	ALE_MP_SUPER,
+	ALE_MP_FW_ST,
+	ALE_MP_ADDR,
+	ALE_MP_VID,
+	ALE_MP_NUM
+};
+
 #endif
diff --git a/drivers/net/ethernet/ti/cpts.c b/drivers/net/ethernet/ti/cpts.c
new file mode 100644
index 0000000..463597f
--- /dev/null
+++ b/drivers/net/ethernet/ti/cpts.c
@@ -0,0 +1,424 @@
+/*
+ * TI Common Platform Time Sync
+ *
+ * Copyright (C) 2012 Richard Cochran <richardcochran@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <linux/err.h>
+#include <linux/if.h>
+#include <linux/hrtimer.h>
+#include <linux/module.h>
+#include <linux/net_tstamp.h>
+#include <linux/ptp_classify.h>
+#include <linux/time.h>
+#include <linux/uaccess.h>
+#include <linux/workqueue.h>
+
+#include "cpts.h"
+
+#ifdef CONFIG_TI_CPTS
+
+static struct sock_filter ptp_filter[] = {
+	PTP_FILTER
+};
+
+#define cpts_read32(c, r)	__raw_readl(&c->reg->r)
+#define cpts_write32(c, v, r)	__raw_writel(v, &c->reg->r)
+
+static int event_expired(struct cpts_event *event)
+{
+	return time_after(jiffies, event->tmo);
+}
+
+static int event_type(struct cpts_event *event)
+{
+	return (event->high >> EVENT_TYPE_SHIFT) & EVENT_TYPE_MASK;
+}
+
+static int cpts_fifo_pop(struct cpts *cpts, u32 *high, u32 *low)
+{
+	u32 r = cpts_read32(cpts, intstat_raw);
+
+	if (r & TS_PEND_RAW) {
+		*high = cpts_read32(cpts, event_high);
+		*low  = cpts_read32(cpts, event_low);
+		cpts_write32(cpts, EVENT_POP, event_pop);
+		return 0;
+	}
+	return -1;
+}
+
+/*
+ * Returns zero if matching event type was found.
+ */
+static int cpts_fifo_read(struct cpts *cpts, int match)
+{
+	int i, type = -1;
+	u32 hi, lo;
+	struct cpts_event *event;
+
+	for (i = 0; i < CPTS_FIFO_DEPTH; i++) {
+		if (cpts_fifo_pop(cpts, &hi, &lo))
+			break;
+		if (list_empty(&cpts->pool)) {
+			pr_err("cpts: event pool is empty\n");
+			return -1;
+		}
+		event = list_first_entry(&cpts->pool, struct cpts_event, list);
+		event->tmo = jiffies + 2;
+		event->high = hi;
+		event->low = lo;
+		type = event_type(event);
+		switch (type) {
+		case CPTS_EV_PUSH:
+		case CPTS_EV_RX:
+		case CPTS_EV_TX:
+			list_del_init(&event->list);
+			list_add_tail(&event->list, &cpts->events);
+			break;
+		case CPTS_EV_ROLL:
+		case CPTS_EV_HALF:
+		case CPTS_EV_HW:
+			break;
+		default:
+			pr_err("cpts: unkown event type\n");
+			break;
+		}
+		if (type == match)
+			break;
+	}
+	return type == match ? 0 : -1;
+}
+
+static cycle_t cpts_systim_read(const struct cyclecounter *cc)
+{
+	u64 val = 0;
+	struct cpts_event *event;
+	struct list_head *this, *next;
+	struct cpts *cpts = container_of(cc, struct cpts, cc);
+
+	cpts_write32(cpts, TS_PUSH, ts_push);
+	if (cpts_fifo_read(cpts, CPTS_EV_PUSH))
+		pr_err("cpts: unable to obtain a time stamp\n");
+
+	list_for_each_safe(this, next, &cpts->events) {
+		event = list_entry(this, struct cpts_event, list);
+		if (event_type(event) == CPTS_EV_PUSH) {
+			list_del_init(&event->list);
+			list_add(&event->list, &cpts->pool);
+			val = event->low;
+			break;
+		}
+	}
+
+	return val;
+}
+
+/* PTP clock operations */
+
+static int cpts_ptp_adjfreq(struct ptp_clock_info *ptp, s32 ppb)
+{
+	u64 adj;
+	u32 diff, mult;
+	int neg_adj = 0;
+	unsigned long flags;
+	struct cpts *cpts = container_of(ptp, struct cpts, info);
+
+	if (ppb < 0) {
+		neg_adj = 1;
+		ppb = -ppb;
+	}
+	mult = cpts->cc_mult;
+	adj = mult;
+	adj *= ppb;
+	diff = div_u64(adj, 1000000000ULL);
+
+	spin_lock_irqsave(&cpts->lock, flags);
+
+	timecounter_read(&cpts->tc);
+
+	cpts->cc.mult = neg_adj ? mult - diff : mult + diff;
+
+	spin_unlock_irqrestore(&cpts->lock, flags);
+
+	return 0;
+}
+
+static int cpts_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)
+{
+	s64 now;
+	unsigned long flags;
+	struct cpts *cpts = container_of(ptp, struct cpts, info);
+
+	spin_lock_irqsave(&cpts->lock, flags);
+	now = timecounter_read(&cpts->tc);
+	now += delta;
+	timecounter_init(&cpts->tc, &cpts->cc, now);
+	spin_unlock_irqrestore(&cpts->lock, flags);
+
+	return 0;
+}
+
+static int cpts_ptp_gettime(struct ptp_clock_info *ptp, struct timespec *ts)
+{
+	u64 ns;
+	u32 remainder;
+	unsigned long flags;
+	struct cpts *cpts = container_of(ptp, struct cpts, info);
+
+	spin_lock_irqsave(&cpts->lock, flags);
+	ns = timecounter_read(&cpts->tc);
+	spin_unlock_irqrestore(&cpts->lock, flags);
+
+	ts->tv_sec = div_u64_rem(ns, 1000000000, &remainder);
+	ts->tv_nsec = remainder;
+
+	return 0;
+}
+
+static int cpts_ptp_settime(struct ptp_clock_info *ptp,
+			    const struct timespec *ts)
+{
+	u64 ns;
+	unsigned long flags;
+	struct cpts *cpts = container_of(ptp, struct cpts, info);
+
+	ns = ts->tv_sec * 1000000000ULL;
+	ns += ts->tv_nsec;
+
+	spin_lock_irqsave(&cpts->lock, flags);
+	timecounter_init(&cpts->tc, &cpts->cc, ns);
+	spin_unlock_irqrestore(&cpts->lock, flags);
+
+	return 0;
+}
+
+static int cpts_ptp_enable(struct ptp_clock_info *ptp,
+			   struct ptp_clock_request *rq, int on)
+{
+	return -EOPNOTSUPP;
+}
+
+static struct ptp_clock_info cpts_info = {
+	.owner		= THIS_MODULE,
+	.name		= "CTPS timer",
+	.max_adj	= 1000000,
+	.n_ext_ts	= 0,
+	.pps		= 0,
+	.adjfreq	= cpts_ptp_adjfreq,
+	.adjtime	= cpts_ptp_adjtime,
+	.gettime	= cpts_ptp_gettime,
+	.settime	= cpts_ptp_settime,
+	.enable		= cpts_ptp_enable,
+};
+
+static void cpts_overflow_check(struct work_struct *work)
+{
+	struct timespec ts;
+	struct cpts *cpts = container_of(work, struct cpts, overflow_work.work);
+
+	cpts_write32(cpts, CPTS_EN, control);
+	cpts_write32(cpts, TS_PEND_EN, int_enable);
+	cpts_ptp_gettime(&cpts->info, &ts);
+	pr_debug("cpts overflow check at %ld.%09lu\n", ts.tv_sec, ts.tv_nsec);
+	schedule_delayed_work(&cpts->overflow_work, CPTS_OVERFLOW_PERIOD);
+}
+
+#define CPTS_REF_CLOCK_NAME "cpsw_cpts_rft_clk"
+
+static void cpts_clk_init(struct cpts *cpts)
+{
+	cpts->refclk = clk_get(NULL, CPTS_REF_CLOCK_NAME);
+	if (IS_ERR(cpts->refclk)) {
+		pr_err("Failed to clk_get %s\n", CPTS_REF_CLOCK_NAME);
+		cpts->refclk = NULL;
+		return;
+	}
+	clk_prepare_enable(cpts->refclk);
+}
+
+static void cpts_clk_release(struct cpts *cpts)
+{
+	clk_disable(cpts->refclk);
+	clk_put(cpts->refclk);
+}
+
+static int cpts_match(struct sk_buff *skb, unsigned int ptp_class,
+		      u16 ts_seqid, u8 ts_msgtype)
+{
+	u16 *seqid;
+	unsigned int offset;
+	u8 *msgtype, *data = skb->data;
+
+	switch (ptp_class) {
+	case PTP_CLASS_V1_IPV4:
+	case PTP_CLASS_V2_IPV4:
+		offset = ETH_HLEN + IPV4_HLEN(data) + UDP_HLEN;
+		break;
+	case PTP_CLASS_V1_IPV6:
+	case PTP_CLASS_V2_IPV6:
+		offset = OFF_PTP6;
+		break;
+	case PTP_CLASS_V2_L2:
+		offset = ETH_HLEN;
+		break;
+	case PTP_CLASS_V2_VLAN:
+		offset = ETH_HLEN + VLAN_HLEN;
+		break;
+	default:
+		return 0;
+	}
+
+	if (skb->len + ETH_HLEN < offset + OFF_PTP_SEQUENCE_ID + sizeof(*seqid))
+		return 0;
+
+	if (unlikely(ptp_class & PTP_CLASS_V1))
+		msgtype = data + offset + OFF_PTP_CONTROL;
+	else
+		msgtype = data + offset;
+
+	seqid = (u16 *)(data + offset + OFF_PTP_SEQUENCE_ID);
+
+	return (ts_msgtype == (*msgtype & 0xf) && ts_seqid == ntohs(*seqid));
+}
+
+static u64 cpts_find_ts(struct cpts *cpts, struct sk_buff *skb, int ev_type)
+{
+	u64 ns = 0;
+	struct cpts_event *event;
+	struct list_head *this, *next;
+	unsigned int class = sk_run_filter(skb, ptp_filter);
+	unsigned long flags;
+	u16 seqid;
+	u8 mtype;
+
+	if (class == PTP_CLASS_NONE)
+		return 0;
+
+	spin_lock_irqsave(&cpts->lock, flags);
+	cpts_fifo_read(cpts, CPTS_EV_PUSH);
+	list_for_each_safe(this, next, &cpts->events) {
+		event = list_entry(this, struct cpts_event, list);
+		if (event_expired(event)) {
+			list_del_init(&event->list);
+			list_add(&event->list, &cpts->pool);
+			continue;
+		}
+		mtype = (event->high >> MESSAGE_TYPE_SHIFT) & MESSAGE_TYPE_MASK;
+		seqid = (event->high >> SEQUENCE_ID_SHIFT) & SEQUENCE_ID_MASK;
+		if (ev_type == event_type(event) &&
+		    cpts_match(skb, class, seqid, mtype)) {
+			ns = timecounter_cyc2time(&cpts->tc, event->low);
+			list_del_init(&event->list);
+			list_add(&event->list, &cpts->pool);
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&cpts->lock, flags);
+
+	return ns;
+}
+
+void cpts_rx_timestamp(struct cpts *cpts, struct sk_buff *skb)
+{
+	u64 ns;
+	struct skb_shared_hwtstamps *ssh;
+
+	if (!cpts->rx_enable)
+		return;
+	ns = cpts_find_ts(cpts, skb, CPTS_EV_RX);
+	if (!ns)
+		return;
+	ssh = skb_hwtstamps(skb);
+	memset(ssh, 0, sizeof(*ssh));
+	ssh->hwtstamp = ns_to_ktime(ns);
+}
+
+void cpts_tx_timestamp(struct cpts *cpts, struct sk_buff *skb)
+{
+	u64 ns;
+	struct skb_shared_hwtstamps ssh;
+
+	if (!(skb_shinfo(skb)->tx_flags & SKBTX_IN_PROGRESS))
+		return;
+	ns = cpts_find_ts(cpts, skb, CPTS_EV_TX);
+	if (!ns)
+		return;
+	memset(&ssh, 0, sizeof(ssh));
+	ssh.hwtstamp = ns_to_ktime(ns);
+	skb_tstamp_tx(skb, &ssh);
+}
+
+#endif /*CONFIG_TI_CPTS*/
+
+int cpts_register(struct device *dev, struct cpts *cpts,
+		  u32 mult, u32 shift)
+{
+#ifdef CONFIG_TI_CPTS
+	int err, i;
+	unsigned long flags;
+
+	if (ptp_filter_init(ptp_filter, ARRAY_SIZE(ptp_filter))) {
+		pr_err("cpts: bad ptp filter\n");
+		return -EINVAL;
+	}
+	cpts->info = cpts_info;
+	cpts->clock = ptp_clock_register(&cpts->info, dev);
+	if (IS_ERR(cpts->clock)) {
+		err = PTR_ERR(cpts->clock);
+		cpts->clock = NULL;
+		return err;
+	}
+	spin_lock_init(&cpts->lock);
+
+	cpts->cc.read = cpts_systim_read;
+	cpts->cc.mask = CLOCKSOURCE_MASK(32);
+	cpts->cc_mult = mult;
+	cpts->cc.mult = mult;
+	cpts->cc.shift = shift;
+
+	INIT_LIST_HEAD(&cpts->events);
+	INIT_LIST_HEAD(&cpts->pool);
+	for (i = 0; i < CPTS_MAX_EVENTS; i++)
+		list_add(&cpts->pool_data[i].list, &cpts->pool);
+
+	cpts_clk_init(cpts);
+	cpts_write32(cpts, CPTS_EN, control);
+	cpts_write32(cpts, TS_PEND_EN, int_enable);
+
+	spin_lock_irqsave(&cpts->lock, flags);
+	timecounter_init(&cpts->tc, &cpts->cc, ktime_to_ns(ktime_get_real()));
+	spin_unlock_irqrestore(&cpts->lock, flags);
+
+	INIT_DELAYED_WORK(&cpts->overflow_work, cpts_overflow_check);
+	schedule_delayed_work(&cpts->overflow_work, CPTS_OVERFLOW_PERIOD);
+
+	cpts->phc_index = ptp_clock_index(cpts->clock);
+#endif
+	return 0;
+}
+
+void cpts_unregister(struct cpts *cpts)
+{
+#ifdef CONFIG_TI_CPTS
+	if (cpts->clock) {
+		ptp_clock_unregister(cpts->clock);
+		cancel_delayed_work_sync(&cpts->overflow_work);
+	}
+	if (cpts->refclk)
+		cpts_clk_release(cpts);
+#endif
+}
diff --git a/drivers/net/ethernet/ti/cpts.h b/drivers/net/ethernet/ti/cpts.h
new file mode 100644
index 0000000..fe993cd
--- /dev/null
+++ b/drivers/net/ethernet/ti/cpts.h
@@ -0,0 +1,145 @@
+/*
+ * TI Common Platform Time Sync
+ *
+ * Copyright (C) 2012 Richard Cochran <richardcochran@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef _TI_CPTS_H_
+#define _TI_CPTS_H_
+
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/clocksource.h>
+#include <linux/device.h>
+#include <linux/list.h>
+#include <linux/ptp_clock_kernel.h>
+#include <linux/skbuff.h>
+
+struct cpsw_cpts {
+	u32 idver;                /* Identification and version */
+	u32 control;              /* Time sync control */
+	u32 res1;
+	u32 ts_push;              /* Time stamp event push */
+	u32 ts_load_val;          /* Time stamp load value */
+	u32 ts_load_en;           /* Time stamp load enable */
+	u32 res2[2];
+	u32 intstat_raw;          /* Time sync interrupt status raw */
+	u32 intstat_masked;       /* Time sync interrupt status masked */
+	u32 int_enable;           /* Time sync interrupt enable */
+	u32 res3;
+	u32 event_pop;            /* Event interrupt pop */
+	u32 event_low;            /* 32 Bit Event Time Stamp */
+	u32 event_high;           /* Event Type Fields */
+};
+
+/* Bit definitions for the IDVER register */
+#define TX_IDENT_SHIFT       (16)    /* TX Identification Value */
+#define TX_IDENT_MASK        (0xffff)
+#define RTL_VER_SHIFT        (11)    /* RTL Version Value */
+#define RTL_VER_MASK         (0x1f)
+#define MAJOR_VER_SHIFT      (8)     /* Major Version Value */
+#define MAJOR_VER_MASK       (0x7)
+#define MINOR_VER_SHIFT      (0)     /* Minor Version Value */
+#define MINOR_VER_MASK       (0xff)
+
+/* Bit definitions for the CONTROL register */
+#define HW4_TS_PUSH_EN       (1<<11) /* Hardware push 4 enable */
+#define HW3_TS_PUSH_EN       (1<<10) /* Hardware push 3 enable */
+#define HW2_TS_PUSH_EN       (1<<9)  /* Hardware push 2 enable */
+#define HW1_TS_PUSH_EN       (1<<8)  /* Hardware push 1 enable */
+#define INT_TEST             (1<<1)  /* Interrupt Test */
+#define CPTS_EN              (1<<0)  /* Time Sync Enable */
+
+/*
+ * Definitions for the single bit resisters:
+ * TS_PUSH TS_LOAD_EN  INTSTAT_RAW INTSTAT_MASKED INT_ENABLE EVENT_POP
+ */
+#define TS_PUSH             (1<<0)  /* Time stamp event push */
+#define TS_LOAD_EN          (1<<0)  /* Time Stamp Load */
+#define TS_PEND_RAW         (1<<0)  /* int read (before enable) */
+#define TS_PEND             (1<<0)  /* masked interrupt read (after enable) */
+#define TS_PEND_EN          (1<<0)  /* masked interrupt enable */
+#define EVENT_POP           (1<<0)  /* writing discards one event */
+
+/* Bit definitions for the EVENT_HIGH register */
+#define PORT_NUMBER_SHIFT    (24)    /* Indicates Ethernet port or HW pin */
+#define PORT_NUMBER_MASK     (0x1f)
+#define EVENT_TYPE_SHIFT     (20)    /* Time sync event type */
+#define EVENT_TYPE_MASK      (0xf)
+#define MESSAGE_TYPE_SHIFT   (16)    /* PTP message type */
+#define MESSAGE_TYPE_MASK    (0xf)
+#define SEQUENCE_ID_SHIFT    (0)     /* PTP message sequence ID */
+#define SEQUENCE_ID_MASK     (0xffff)
+
+enum {
+	CPTS_EV_PUSH, /* Time Stamp Push Event */
+	CPTS_EV_ROLL, /* Time Stamp Rollover Event */
+	CPTS_EV_HALF, /* Time Stamp Half Rollover Event */
+	CPTS_EV_HW,   /* Hardware Time Stamp Push Event */
+	CPTS_EV_RX,   /* Ethernet Receive Event */
+	CPTS_EV_TX,   /* Ethernet Transmit Event */
+};
+
+/* This covers any input clock up to about 500 MHz. */
+#define CPTS_OVERFLOW_PERIOD (HZ * 8)
+
+#define CPTS_FIFO_DEPTH 16
+#define CPTS_MAX_EVENTS 32
+
+struct cpts_event {
+	struct list_head list;
+	unsigned long tmo;
+	u32 high;
+	u32 low;
+};
+
+struct cpts {
+	struct cpsw_cpts __iomem *reg;
+	int tx_enable;
+	int rx_enable;
+#ifdef CONFIG_TI_CPTS
+	struct ptp_clock_info info;
+	struct ptp_clock *clock;
+	spinlock_t lock; /* protects time registers */
+	u32 cc_mult; /* for the nominal frequency */
+	struct cyclecounter cc;
+	struct timecounter tc;
+	struct delayed_work overflow_work;
+	int phc_index;
+	struct clk *refclk;
+	struct list_head events;
+	struct list_head pool;
+	struct cpts_event pool_data[CPTS_MAX_EVENTS];
+#endif
+};
+
+#ifdef CONFIG_TI_CPTS
+extern void cpts_rx_timestamp(struct cpts *cpts, struct sk_buff *skb);
+extern void cpts_tx_timestamp(struct cpts *cpts, struct sk_buff *skb);
+#else
+static inline void cpts_rx_timestamp(struct cpts *cpts, struct sk_buff *skb)
+{
+}
+static inline void cpts_tx_timestamp(struct cpts *cpts, struct sk_buff *skb)
+{
+}
+#endif
+
+extern int cpts_register(struct device *dev, struct cpts *cpts,
+			 u32 mult, u32 shift);
+extern void cpts_unregister(struct cpts *cpts);
+
+#endif
diff --git a/drivers/net/ethernet/ti/davinci_cpdma.c b/drivers/net/ethernet/ti/davinci_cpdma.c
index 06f2b49..4995673 100644
--- a/drivers/net/ethernet/ti/davinci_cpdma.c
+++ b/drivers/net/ethernet/ti/davinci_cpdma.c
@@ -15,6 +15,7 @@
 #include <linux/kernel.h>
 #include <linux/spinlock.h>
 #include <linux/device.h>
+#include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/err.h>
 #include <linux/dma-mapping.h>
@@ -92,7 +93,7 @@ enum cpdma_state {
 	CPDMA_STATE_TEARDOWN,
 };
 
-const char *cpdma_state_str[] = { "idle", "active", "teardown" };
+static const char *cpdma_state_str[] = { "idle", "active", "teardown" };
 
 struct cpdma_ctlr {
 	enum cpdma_state	state;
@@ -276,6 +277,7 @@ struct cpdma_ctlr *cpdma_ctlr_create(struct cpdma_params *params)
 		ctlr->num_chan = CPDMA_MAX_CHANNELS;
 	return ctlr;
 }
+EXPORT_SYMBOL_GPL(cpdma_ctlr_create);
 
 int cpdma_ctlr_start(struct cpdma_ctlr *ctlr)
 {
@@ -321,6 +323,7 @@ int cpdma_ctlr_start(struct cpdma_ctlr *ctlr)
 	spin_unlock_irqrestore(&ctlr->lock, flags);
 	return 0;
 }
+EXPORT_SYMBOL_GPL(cpdma_ctlr_start);
 
 int cpdma_ctlr_stop(struct cpdma_ctlr *ctlr)
 {
@@ -351,6 +354,7 @@ int cpdma_ctlr_stop(struct cpdma_ctlr *ctlr)
 	spin_unlock_irqrestore(&ctlr->lock, flags);
 	return 0;
 }
+EXPORT_SYMBOL_GPL(cpdma_ctlr_stop);
 
 int cpdma_ctlr_dump(struct cpdma_ctlr *ctlr)
 {
@@ -421,6 +425,7 @@ int cpdma_ctlr_dump(struct cpdma_ctlr *ctlr)
 	spin_unlock_irqrestore(&ctlr->lock, flags);
 	return 0;
 }
+EXPORT_SYMBOL_GPL(cpdma_ctlr_dump);
 
 int cpdma_ctlr_destroy(struct cpdma_ctlr *ctlr)
 {
@@ -444,6 +449,7 @@ int cpdma_ctlr_destroy(struct cpdma_ctlr *ctlr)
 	kfree(ctlr);
 	return ret;
 }
+EXPORT_SYMBOL_GPL(cpdma_ctlr_destroy);
 
 int cpdma_ctlr_int_ctrl(struct cpdma_ctlr *ctlr, bool enable)
 {
@@ -528,14 +534,16 @@ err_chan_busy:
 err_chan_alloc:
 	return ERR_PTR(ret);
 }
+EXPORT_SYMBOL_GPL(cpdma_chan_create);
 
 int cpdma_chan_destroy(struct cpdma_chan *chan)
 {
-	struct cpdma_ctlr *ctlr = chan->ctlr;
+	struct cpdma_ctlr *ctlr;
 	unsigned long flags;
 
 	if (!chan)
 		return -EINVAL;
+	ctlr = chan->ctlr;
 
 	spin_lock_irqsave(&ctlr->lock, flags);
 	if (chan->state != CPDMA_STATE_IDLE)
@@ -545,6 +553,7 @@ int cpdma_chan_destroy(struct cpdma_chan *chan)
 	kfree(chan);
 	return 0;
 }
+EXPORT_SYMBOL_GPL(cpdma_chan_destroy);
 
 int cpdma_chan_get_stats(struct cpdma_chan *chan,
 			 struct cpdma_chan_stats *stats)
@@ -693,6 +702,7 @@ unlock_ret:
 	spin_unlock_irqrestore(&chan->lock, flags);
 	return ret;
 }
+EXPORT_SYMBOL_GPL(cpdma_chan_submit);
 
 static void __cpdma_chan_free(struct cpdma_chan *chan,
 			      struct cpdma_desc __iomem *desc,
@@ -776,6 +786,7 @@ int cpdma_chan_process(struct cpdma_chan *chan, int quota)
 	}
 	return used;
 }
+EXPORT_SYMBOL_GPL(cpdma_chan_process);
 
 int cpdma_chan_start(struct cpdma_chan *chan)
 {
@@ -803,6 +814,7 @@ int cpdma_chan_start(struct cpdma_chan *chan)
 	spin_unlock_irqrestore(&chan->lock, flags);
 	return 0;
 }
+EXPORT_SYMBOL_GPL(cpdma_chan_start);
 
 int cpdma_chan_stop(struct cpdma_chan *chan)
 {
@@ -864,6 +876,7 @@ int cpdma_chan_stop(struct cpdma_chan *chan)
 	spin_unlock_irqrestore(&chan->lock, flags);
 	return 0;
 }
+EXPORT_SYMBOL_GPL(cpdma_chan_stop);
 
 int cpdma_chan_int_ctrl(struct cpdma_chan *chan, bool enable)
 {
diff --git a/drivers/net/ethernet/ti/davinci_emac.c b/drivers/net/ethernet/ti/davinci_emac.c
index 43fada5..7c75b16 100644
--- a/drivers/net/ethernet/ti/davinci_emac.c
+++ b/drivers/net/ethernet/ti/davinci_emac.c
@@ -57,7 +57,12 @@
 #include <linux/bitops.h>
 #include <linux/io.h>
 #include <linux/uaccess.h>
+#include <linux/pm_runtime.h>
 #include <linux/davinci_emac.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_net.h>
 
 #include <asm/irq.h>
 #include <asm/page.h>
@@ -339,6 +344,9 @@ struct emac_priv {
 	u32 rx_addr_type;
 	atomic_t cur_tx;
 	const char *phy_id;
+#ifdef CONFIG_OF
+	struct device_node *phy_node;
+#endif
 	struct phy_device *phydev;
 	spinlock_t lock;
 	/*platform specific members*/
@@ -346,10 +354,6 @@ struct emac_priv {
 	void (*int_disable) (void);
 };
 
-/* clock frequency for EMAC */
-static struct clk *emac_clk;
-static unsigned long emac_bus_frequency;
-
 /* EMAC TX Host Error description strings */
 static char *emac_txhost_errcodes[16] = {
 	"No error", "SOP error", "Ownership bit not set in SOP buffer",
@@ -375,7 +379,7 @@ static char *emac_rxhost_errcodes[16] = {
 #define emac_ctrl_write(reg, val) iowrite32(val, (priv->ctrl_base + (reg)))
 
 /**
- * emac_dump_regs: Dump important EMAC registers to debug terminal
+ * emac_dump_regs - Dump important EMAC registers to debug terminal
  * @priv: The DaVinci EMAC private adapter structure
  *
  * Executes ethtool set cmd & sets phy mode
@@ -466,7 +470,7 @@ static void emac_dump_regs(struct emac_priv *priv)
 }
 
 /**
- * emac_get_drvinfo: Get EMAC driver information
+ * emac_get_drvinfo - Get EMAC driver information
  * @ndev: The DaVinci EMAC network adapter
  * @info: ethtool info structure containing name and version
  *
@@ -481,7 +485,7 @@ static void emac_get_drvinfo(struct net_device *ndev,
 }
 
 /**
- * emac_get_settings: Get EMAC settings
+ * emac_get_settings - Get EMAC settings
  * @ndev: The DaVinci EMAC network adapter
  * @ecmd: ethtool command
  *
@@ -500,7 +504,7 @@ static int emac_get_settings(struct net_device *ndev,
 }
 
 /**
- * emac_set_settings: Set EMAC settings
+ * emac_set_settings - Set EMAC settings
  * @ndev: The DaVinci EMAC network adapter
  * @ecmd: ethtool command
  *
@@ -518,7 +522,7 @@ static int emac_set_settings(struct net_device *ndev, struct ethtool_cmd *ecmd)
 }
 
 /**
- * emac_get_coalesce : Get interrupt coalesce settings for this device
+ * emac_get_coalesce - Get interrupt coalesce settings for this device
  * @ndev : The DaVinci EMAC network adapter
  * @coal : ethtool coalesce settings structure
  *
@@ -536,7 +540,7 @@ static int emac_get_coalesce(struct net_device *ndev,
 }
 
 /**
- * emac_set_coalesce : Set interrupt coalesce settings for this device
+ * emac_set_coalesce - Set interrupt coalesce settings for this device
  * @ndev : The DaVinci EMAC network adapter
  * @coal : ethtool coalesce settings structure
  *
@@ -614,11 +618,9 @@ static int emac_set_coalesce(struct net_device *ndev,
 }
 
 
-/**
- * ethtool_ops: DaVinci EMAC Ethtool structure
+/* ethtool_ops: DaVinci EMAC Ethtool structure
  *
  * Ethtool support for EMAC adapter
- *
  */
 static const struct ethtool_ops ethtool_ops = {
 	.get_drvinfo = emac_get_drvinfo,
@@ -627,10 +629,11 @@ static const struct ethtool_ops ethtool_ops = {
 	.get_link = ethtool_op_get_link,
 	.get_coalesce = emac_get_coalesce,
 	.set_coalesce =  emac_set_coalesce,
+	.get_ts_info = ethtool_op_get_ts_info,
 };
 
 /**
- * emac_update_phystatus: Update Phy status
+ * emac_update_phystatus - Update Phy status
  * @priv: The DaVinci EMAC private adapter structure
  *
  * Updates phy status and takes action for network queue if required
@@ -696,7 +699,7 @@ static void emac_update_phystatus(struct emac_priv *priv)
 }
 
 /**
- * hash_get: Calculate hash value from mac address
+ * hash_get - Calculate hash value from mac address
  * @addr: mac address to delete from hash table
  *
  * Calculates hash value from mac address
@@ -722,9 +725,9 @@ static u32 hash_get(u8 *addr)
 }
 
 /**
- * hash_add: Hash function to add mac addr from hash table
+ * hash_add - Hash function to add mac addr from hash table
  * @priv: The DaVinci EMAC private adapter structure
- * mac_addr: mac address to delete from hash table
+ * @mac_addr: mac address to delete from hash table
  *
  * Adds mac address to the internal hash table
  *
@@ -764,9 +767,9 @@ static int hash_add(struct emac_priv *priv, u8 *mac_addr)
 }
 
 /**
- * hash_del: Hash function to delete mac addr from hash table
+ * hash_del - Hash function to delete mac addr from hash table
  * @priv: The DaVinci EMAC private adapter structure
- * mac_addr: mac address to delete from hash table
+ * @mac_addr: mac address to delete from hash table
  *
  * Removes mac address from the internal hash table
  *
@@ -806,7 +809,7 @@ static int hash_del(struct emac_priv *priv, u8 *mac_addr)
 #define EMAC_ALL_MULTI_CLR	3
 
 /**
- * emac_add_mcast: Set multicast address in the EMAC adapter (Internal)
+ * emac_add_mcast - Set multicast address in the EMAC adapter (Internal)
  * @priv: The DaVinci EMAC private adapter structure
  * @action: multicast operation to perform
  * mac_addr: mac address to set
@@ -854,7 +857,7 @@ static void emac_add_mcast(struct emac_priv *priv, u32 action, u8 *mac_addr)
 }
 
 /**
- * emac_dev_mcast_set: Set multicast address in the EMAC adapter
+ * emac_dev_mcast_set - Set multicast address in the EMAC adapter
  * @ndev: The DaVinci EMAC network adapter
  *
  * Set multicast addresses in EMAC adapter
@@ -900,7 +903,7 @@ static void emac_dev_mcast_set(struct net_device *ndev)
  *************************************************************************/
 
 /**
- * emac_int_disable: Disable EMAC module interrupt (from adapter)
+ * emac_int_disable - Disable EMAC module interrupt (from adapter)
  * @priv: The DaVinci EMAC private adapter structure
  *
  * Disable EMAC interrupt on the adapter
@@ -930,7 +933,7 @@ static void emac_int_disable(struct emac_priv *priv)
 }
 
 /**
- * emac_int_enable: Enable EMAC module interrupt (from adapter)
+ * emac_int_enable - Enable EMAC module interrupt (from adapter)
  * @priv: The DaVinci EMAC private adapter structure
  *
  * Enable EMAC interrupt on the adapter
@@ -966,7 +969,7 @@ static void emac_int_enable(struct emac_priv *priv)
 }
 
 /**
- * emac_irq: EMAC interrupt handler
+ * emac_irq - EMAC interrupt handler
  * @irq: interrupt number
  * @dev_id: EMAC network adapter data structure ptr
  *
@@ -1052,14 +1055,14 @@ static void emac_tx_handler(void *token, int len, int status)
 	atomic_dec(&priv->cur_tx);
 
 	if (unlikely(netif_queue_stopped(ndev)))
-		netif_wake_queue(ndev);
+		netif_start_queue(ndev);
 	ndev->stats.tx_packets++;
 	ndev->stats.tx_bytes += len;
 	dev_kfree_skb_any(skb);
 }
 
 /**
- * emac_dev_xmit: EMAC Transmit function
+ * emac_dev_xmit - EMAC Transmit function
  * @skb: SKB pointer
  * @ndev: The DaVinci EMAC network adapter
  *
@@ -1110,7 +1113,7 @@ fail_tx:
 }
 
 /**
- * emac_dev_tx_timeout: EMAC Transmit timeout function
+ * emac_dev_tx_timeout - EMAC Transmit timeout function
  * @ndev: The DaVinci EMAC network adapter
  *
  * Called when system detects that a skb timeout period has expired
@@ -1137,7 +1140,7 @@ static void emac_dev_tx_timeout(struct net_device *ndev)
 }
 
 /**
- * emac_set_type0addr: Set EMAC Type0 mac address
+ * emac_set_type0addr - Set EMAC Type0 mac address
  * @priv: The DaVinci EMAC private adapter structure
  * @ch: RX channel number
  * @mac_addr: MAC address to set in device
@@ -1164,7 +1167,7 @@ static void emac_set_type0addr(struct emac_priv *priv, u32 ch, char *mac_addr)
 }
 
 /**
- * emac_set_type1addr: Set EMAC Type1 mac address
+ * emac_set_type1addr - Set EMAC Type1 mac address
  * @priv: The DaVinci EMAC private adapter structure
  * @ch: RX channel number
  * @mac_addr: MAC address to set in device
@@ -1186,7 +1189,7 @@ static void emac_set_type1addr(struct emac_priv *priv, u32 ch, char *mac_addr)
 }
 
 /**
- * emac_set_type2addr: Set EMAC Type2 mac address
+ * emac_set_type2addr - Set EMAC Type2 mac address
  * @priv: The DaVinci EMAC private adapter structure
  * @ch: RX channel number
  * @mac_addr: MAC address to set in device
@@ -1212,7 +1215,7 @@ static void emac_set_type2addr(struct emac_priv *priv, u32 ch,
 }
 
 /**
- * emac_setmac: Set mac address in the adapter (internal function)
+ * emac_setmac - Set mac address in the adapter (internal function)
  * @priv: The DaVinci EMAC private adapter structure
  * @ch: RX channel number
  * @mac_addr: MAC address to set in device
@@ -1241,7 +1244,7 @@ static void emac_setmac(struct emac_priv *priv, u32 ch, char *mac_addr)
 }
 
 /**
- * emac_dev_setmac_addr: Set mac address in the adapter
+ * emac_dev_setmac_addr - Set mac address in the adapter
  * @ndev: The DaVinci EMAC network adapter
  * @addr: MAC address to set in device
  *
@@ -1276,7 +1279,7 @@ static int emac_dev_setmac_addr(struct net_device *ndev, void *addr)
 }
 
 /**
- * emac_hw_enable: Enable EMAC hardware for packet transmission/reception
+ * emac_hw_enable - Enable EMAC hardware for packet transmission/reception
  * @priv: The DaVinci EMAC private adapter structure
  *
  * Enables EMAC hardware for packet processing - enables PHY, enables RX
@@ -1346,7 +1349,7 @@ static int emac_hw_enable(struct emac_priv *priv)
 }
 
 /**
- * emac_poll: EMAC NAPI Poll function
+ * emac_poll - EMAC NAPI Poll function
  * @ndev: The DaVinci EMAC network adapter
  * @budget: Number of receive packets to process (as told by NAPI layer)
  *
@@ -1429,7 +1432,7 @@ static int emac_poll(struct napi_struct *napi, int budget)
 
 #ifdef CONFIG_NET_POLL_CONTROLLER
 /**
- * emac_poll_controller: EMAC Poll controller function
+ * emac_poll_controller - EMAC Poll controller function
  * @ndev: The DaVinci EMAC network adapter
  *
  * Polled functionality used by netconsole and others in non interrupt mode
@@ -1445,7 +1448,7 @@ void emac_poll_controller(struct net_device *ndev)
 }
 #endif
 
-static void emac_adjust_link(struct net_device *ndev)
+static void emac_adjust_link(struct net_device *ndev, void *context)
 {
 	struct emac_priv *priv = netdev_priv(ndev);
 	struct phy_device *phydev = priv->phydev;
@@ -1488,7 +1491,7 @@ static void emac_adjust_link(struct net_device *ndev)
  *************************************************************************/
 
 /**
- * emac_devioctl: EMAC adapter ioctl
+ * emac_devioctl - EMAC adapter ioctl
  * @ndev: The DaVinci EMAC network adapter
  * @ifrq: request parameter
  * @cmd: command parameter
@@ -1515,7 +1518,7 @@ static int match_first_device(struct device *dev, void *data)
 }
 
 /**
- * emac_dev_open: EMAC device open
+ * emac_dev_open - EMAC device open
  * @ndev: The DaVinci EMAC network adapter
  *
  * Called when system wants to start the interface. We init TX/RX channels
@@ -1534,6 +1537,8 @@ static int emac_dev_open(struct net_device *ndev)
 	int k = 0;
 	struct emac_priv *priv = netdev_priv(ndev);
 
+	pm_runtime_get(&priv->pdev->dev);
+
 	netif_carrier_off(ndev);
 	for (cnt = 0; cnt < ETH_ALEN; cnt++)
 		ndev->dev_addr[cnt] = priv->mac_addr[cnt];
@@ -1596,14 +1601,14 @@ static int emac_dev_open(struct net_device *ndev)
 	if (priv->phy_id && *priv->phy_id) {
 		priv->phydev = phy_connect(ndev, priv->phy_id,
 					   &emac_adjust_link, 0,
-					   PHY_INTERFACE_MODE_MII);
+					   PHY_INTERFACE_MODE_MII, NULL);
 
 		if (IS_ERR(priv->phydev)) {
 			dev_err(emac_dev, "could not connect to phy %s\n",
 				priv->phy_id);
 			ret = PTR_ERR(priv->phydev);
 			priv->phydev = NULL;
-			return ret;
+			goto err;
 		}
 
 		priv->link = 0;
@@ -1644,11 +1649,15 @@ rollback:
 		res = platform_get_resource(priv->pdev, IORESOURCE_IRQ, k-1);
 		m = res->end;
 	}
-	return -EBUSY;
+
+	ret = -EBUSY;
+err:
+	pm_runtime_put(&priv->pdev->dev);
+	return ret;
 }
 
 /**
- * emac_dev_stop: EMAC device stop
+ * emac_dev_stop - EMAC device stop
  * @ndev: The DaVinci EMAC network adapter
  *
  * Called when system wants to stop or down the interface. We stop the network
@@ -1686,11 +1695,12 @@ static int emac_dev_stop(struct net_device *ndev)
 	if (netif_msg_drv(priv))
 		dev_notice(emac_dev, "DaVinci EMAC: %s stopped\n", ndev->name);
 
+	pm_runtime_put(&priv->pdev->dev);
 	return 0;
 }
 
 /**
- * emac_dev_getnetstats: EMAC get statistics function
+ * emac_dev_getnetstats - EMAC get statistics function
  * @ndev: The DaVinci EMAC network adapter
  *
  * Called when system wants to get statistics from the device.
@@ -1761,15 +1771,86 @@ static const struct net_device_ops emac_netdev_ops = {
 #endif
 };
 
+#ifdef CONFIG_OF
+static struct emac_platform_data
+	*davinci_emac_of_get_pdata(struct platform_device *pdev,
+	struct emac_priv *priv)
+{
+	struct device_node *np;
+	struct emac_platform_data *pdata = NULL;
+	const u8 *mac_addr;
+	u32 data;
+	int ret;
+
+	pdata = pdev->dev.platform_data;
+	if (!pdata) {
+		pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
+		if (!pdata)
+			goto nodata;
+	}
+
+	np = pdev->dev.of_node;
+	if (!np)
+		goto nodata;
+	else
+		pdata->version = EMAC_VERSION_2;
+
+	if (!is_valid_ether_addr(pdata->mac_addr)) {
+		mac_addr = of_get_mac_address(np);
+		if (mac_addr)
+			memcpy(pdata->mac_addr, mac_addr, ETH_ALEN);
+	}
+
+	ret = of_property_read_u32(np, "ti,davinci-ctrl-reg-offset", &data);
+	if (!ret)
+		pdata->ctrl_reg_offset = data;
+
+	ret = of_property_read_u32(np, "ti,davinci-ctrl-mod-reg-offset",
+		&data);
+	if (!ret)
+		pdata->ctrl_mod_reg_offset = data;
+
+	ret = of_property_read_u32(np, "ti,davinci-ctrl-ram-offset", &data);
+	if (!ret)
+		pdata->ctrl_ram_offset = data;
+
+	ret = of_property_read_u32(np, "ti,davinci-ctrl-ram-size", &data);
+	if (!ret)
+		pdata->ctrl_ram_size = data;
+
+	ret = of_property_read_u32(np, "ti,davinci-rmii-en", &data);
+	if (!ret)
+		pdata->rmii_en = data;
+
+	ret = of_property_read_u32(np, "ti,davinci-no-bd-ram", &data);
+	if (!ret)
+		pdata->no_bd_ram = data;
+
+	priv->phy_node = of_parse_phandle(np, "phy-handle", 0);
+	if (!priv->phy_node)
+		pdata->phy_id = "";
+
+	pdev->dev.platform_data = pdata;
+nodata:
+	return  pdata;
+}
+#else
+static struct emac_platform_data
+	*davinci_emac_of_get_pdata(struct platform_device *pdev,
+	struct emac_priv *priv)
+{
+	return  pdev->dev.platform_data;
+}
+#endif
 /**
- * davinci_emac_probe: EMAC device probe
+ * davinci_emac_probe - EMAC device probe
  * @pdev: The DaVinci EMAC device that we are removing
  *
  * Called when probing for emac devicesr. We get details of instances and
  * resource information from platform init and register a network device
  * and allocate resources necessary for driver to perform
  */
-static int __devinit davinci_emac_probe(struct platform_device *pdev)
+static int davinci_emac_probe(struct platform_device *pdev)
 {
 	int rc = 0;
 	struct resource *res;
@@ -1779,6 +1860,9 @@ static int __devinit davinci_emac_probe(struct platform_device *pdev)
 	struct emac_platform_data *pdata;
 	struct device *emac_dev;
 	struct cpdma_params dma_params;
+	struct clk *emac_clk;
+	unsigned long emac_bus_frequency;
+
 
 	/* obtain emac clock from kernel */
 	emac_clk = clk_get(&pdev->dev, NULL);
@@ -1787,12 +1871,14 @@ static int __devinit davinci_emac_probe(struct platform_device *pdev)
 		return -EBUSY;
 	}
 	emac_bus_frequency = clk_get_rate(emac_clk);
+	clk_put(emac_clk);
+
 	/* TODO: Probe PHY here if possible */
 
 	ndev = alloc_etherdev(sizeof(struct emac_priv));
 	if (!ndev) {
 		rc = -ENOMEM;
-		goto free_clk;
+		goto no_ndev;
 	}
 
 	platform_set_drvdata(pdev, ndev);
@@ -1803,7 +1889,7 @@ static int __devinit davinci_emac_probe(struct platform_device *pdev)
 
 	spin_lock_init(&priv->lock);
 
-	pdata = pdev->dev.platform_data;
+	pdata = davinci_emac_of_get_pdata(pdev, priv);
 	if (!pdata) {
 		dev_err(&pdev->dev, "no platform data\n");
 		rc = -ENODEV;
@@ -1908,15 +1994,13 @@ static int __devinit davinci_emac_probe(struct platform_device *pdev)
 	SET_ETHTOOL_OPS(ndev, &ethtool_ops);
 	netif_napi_add(ndev, &priv->napi, emac_poll, EMAC_POLL_WEIGHT);
 
-	clk_enable(emac_clk);
-
 	/* register the network device */
 	SET_NETDEV_DEV(ndev, &pdev->dev);
 	rc = register_netdev(ndev);
 	if (rc) {
 		dev_err(&pdev->dev, "error in register_netdev\n");
 		rc = -ENODEV;
-		goto netdev_reg_err;
+		goto no_irq_res;
 	}
 
 
@@ -1925,10 +2009,12 @@ static int __devinit davinci_emac_probe(struct platform_device *pdev)
 			   "(regs: %p, irq: %d)\n",
 			   (void *)priv->emac_base_phys, ndev->irq);
 	}
+
+	pm_runtime_enable(&pdev->dev);
+	pm_runtime_resume(&pdev->dev);
+
 	return 0;
 
-netdev_reg_err:
-	clk_disable(emac_clk);
 no_irq_res:
 	if (priv->txchan)
 		cpdma_chan_destroy(priv->txchan);
@@ -1942,19 +2028,18 @@ no_dma:
 
 probe_quit:
 	free_netdev(ndev);
-free_clk:
-	clk_put(emac_clk);
+no_ndev:
 	return rc;
 }
 
 /**
- * davinci_emac_remove: EMAC device remove
+ * davinci_emac_remove - EMAC device remove
  * @pdev: The DaVinci EMAC device that we are removing
  *
  * Called when removing the device driver. We disable clock usage and release
  * the resources taken up by the driver and unregister network device
  */
-static int __devexit davinci_emac_remove(struct platform_device *pdev)
+static int davinci_emac_remove(struct platform_device *pdev)
 {
 	struct resource *res;
 	struct net_device *ndev = platform_get_drvdata(pdev);
@@ -1977,9 +2062,6 @@ static int __devexit davinci_emac_remove(struct platform_device *pdev)
 	iounmap(priv->remap_addr);
 	free_netdev(ndev);
 
-	clk_disable(emac_clk);
-	clk_put(emac_clk);
-
 	return 0;
 }
 
@@ -1991,8 +2073,6 @@ static int davinci_emac_suspend(struct device *dev)
 	if (netif_running(ndev))
 		emac_dev_stop(ndev);
 
-	clk_disable(emac_clk);
-
 	return 0;
 }
 
@@ -2001,8 +2081,6 @@ static int davinci_emac_resume(struct device *dev)
 	struct platform_device *pdev = to_platform_device(dev);
 	struct net_device *ndev = platform_get_drvdata(pdev);
 
-	clk_enable(emac_clk);
-
 	if (netif_running(ndev))
 		emac_dev_open(ndev);
 
@@ -2014,21 +2092,26 @@ static const struct dev_pm_ops davinci_emac_pm_ops = {
 	.resume		= davinci_emac_resume,
 };
 
-/**
- * davinci_emac_driver: EMAC platform driver structure
- */
+static const struct of_device_id davinci_emac_of_match[] = {
+	{.compatible = "ti,davinci-dm6467-emac", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, davinci_emac_of_match);
+
+/* davinci_emac_driver: EMAC platform driver structure */
 static struct platform_driver davinci_emac_driver = {
 	.driver = {
 		.name	 = "davinci_emac",
 		.owner	 = THIS_MODULE,
 		.pm	 = &davinci_emac_pm_ops,
+		.of_match_table = of_match_ptr(davinci_emac_of_match),
 	},
 	.probe = davinci_emac_probe,
-	.remove = __devexit_p(davinci_emac_remove),
+	.remove = davinci_emac_remove,
 };
 
 /**
- * davinci_emac_init: EMAC driver module init
+ * davinci_emac_init - EMAC driver module init
  *
  * Called when initializing the driver. We register the driver with
  * the platform.
@@ -2040,7 +2123,7 @@ static int __init davinci_emac_init(void)
 late_initcall(davinci_emac_init);
 
 /**
- * davinci_emac_exit: EMAC driver module exit
+ * davinci_emac_exit - EMAC driver module exit
  *
  * Called when exiting the driver completely. We unregister the driver with
  * the platform and exit
diff --git a/drivers/net/ethernet/ti/davinci_mdio.c b/drivers/net/ethernet/ti/davinci_mdio.c
index e4e4708..44ab57a0d 100644
--- a/drivers/net/ethernet/ti/davinci_mdio.c
+++ b/drivers/net/ethernet/ti/davinci_mdio.c
@@ -34,7 +34,11 @@
 #include <linux/clk.h>
 #include <linux/err.h>
 #include <linux/io.h>
+#include <linux/pm_runtime.h>
 #include <linux/davinci_emac.h>
+#include <linux/of.h>
+#include <linux/of_mdio.h>
+#include <linux/of_device.h>
 
 /*
  * This timeout definition is a worst-case ultra defensive measure against
@@ -140,6 +144,10 @@ static int davinci_mdio_reset(struct mii_bus *bus)
 	dev_info(data->dev, "davinci mdio revision %d.%d\n",
 		 (ver >> 8) & 0xff, ver & 0xff);
 
+	/* OF explicitly registers phy devices without a bus scan */
+	if (data->dev->of_node)
+		return 0;
+
 	/* get phy mask from the alive register */
 	phy_mask = __raw_readl(&data->regs->alive);
 	if (phy_mask) {
@@ -288,9 +296,29 @@ static int davinci_mdio_write(struct mii_bus *bus, int phy_id,
 	return 0;
 }
 
-static int __devinit davinci_mdio_probe(struct platform_device *pdev)
+static int davinci_mdio_probe_dt(struct mdio_platform_data *data,
+			 struct platform_device *pdev)
+{
+	struct device_node *node = pdev->dev.of_node;
+	u32 prop;
+
+	if (!node)
+		return -EINVAL;
+
+	if (of_property_read_u32(node, "bus_freq", &prop)) {
+		pr_err("Missing bus_freq property in the DT.\n");
+		return -EINVAL;
+	}
+	data->bus_freq = prop;
+
+	return 0;
+}
+
+
+static int davinci_mdio_probe(struct platform_device *pdev)
 {
 	struct mdio_platform_data *pdata = pdev->dev.platform_data;
+	struct device_node *node = pdev->dev.of_node;
 	struct device *dev = &pdev->dev;
 	struct davinci_mdio_data *data;
 	struct resource *res;
@@ -303,8 +331,6 @@ static int __devinit davinci_mdio_probe(struct platform_device *pdev)
 		return -ENOMEM;
 	}
 
-	data->pdata = pdata ? (*pdata) : default_pdata;
-
 	data->bus = mdiobus_alloc();
 	if (!data->bus) {
 		dev_err(dev, "failed to alloc mii bus\n");
@@ -312,16 +338,26 @@ static int __devinit davinci_mdio_probe(struct platform_device *pdev)
 		goto bail_out;
 	}
 
+	if (dev->of_node) {
+		if (davinci_mdio_probe_dt(&data->pdata, pdev))
+			data->pdata = default_pdata;
+		snprintf(data->bus->id, MII_BUS_ID_SIZE, "%s", pdev->name);
+	} else {
+		data->pdata = pdata ? (*pdata) : default_pdata;
+		snprintf(data->bus->id, MII_BUS_ID_SIZE, "%s-%x",
+			 pdev->name, pdev->id);
+	}
+
 	data->bus->name		= dev_name(dev);
 	data->bus->read		= davinci_mdio_read,
 	data->bus->write	= davinci_mdio_write,
 	data->bus->reset	= davinci_mdio_reset,
 	data->bus->parent	= dev;
 	data->bus->priv		= data;
-	snprintf(data->bus->id, MII_BUS_ID_SIZE, "%s-%x",
-		pdev->name, pdev->id);
+	data->dev = dev;
 
-	data->clk = clk_get(dev, NULL);
+	pm_runtime_enable(&pdev->dev);
+	data->clk = clk_get(&pdev->dev, "fck");
 	if (IS_ERR(data->clk)) {
 		dev_err(dev, "failed to get device clock\n");
 		ret = PTR_ERR(data->clk);
@@ -329,10 +365,9 @@ static int __devinit davinci_mdio_probe(struct platform_device *pdev)
 		goto bail_out;
 	}
 
-	clk_enable(data->clk);
-
+	clk_prepare(data->clk);
+	pm_runtime_get_sync(&pdev->dev);
 	dev_set_drvdata(dev, data);
-	data->dev = dev;
 	spin_lock_init(&data->lock);
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
@@ -358,7 +393,7 @@ static int __devinit davinci_mdio_probe(struct platform_device *pdev)
 	}
 
 	/* register the mii bus */
-	ret = mdiobus_register(data->bus);
+	ret = of_mdiobus_register(data->bus, node);
 	if (ret)
 		goto bail_out;
 
@@ -378,28 +413,30 @@ bail_out:
 	if (data->bus)
 		mdiobus_free(data->bus);
 
-	if (data->clk) {
-		clk_disable(data->clk);
+	if (data->clk)
 		clk_put(data->clk);
-	}
+	pm_runtime_put_sync(&pdev->dev);
+	pm_runtime_disable(&pdev->dev);
 
 	kfree(data);
 
 	return ret;
 }
 
-static int __devexit davinci_mdio_remove(struct platform_device *pdev)
+static int davinci_mdio_remove(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct davinci_mdio_data *data = dev_get_drvdata(dev);
 
-	if (data->bus)
+	if (data->bus) {
+		mdiobus_unregister(data->bus);
 		mdiobus_free(data->bus);
+	}
 
-	if (data->clk) {
-		clk_disable(data->clk);
+	if (data->clk)
 		clk_put(data->clk);
-	}
+	pm_runtime_put_sync(&pdev->dev);
+	pm_runtime_disable(&pdev->dev);
 
 	dev_set_drvdata(dev, NULL);
 
@@ -421,8 +458,7 @@ static int davinci_mdio_suspend(struct device *dev)
 	__raw_writel(ctrl, &data->regs->control);
 	wait_for_idle(data);
 
-	if (data->clk)
-		clk_disable(data->clk);
+	pm_runtime_put_sync(data->dev);
 
 	data->suspended = true;
 	spin_unlock(&data->lock);
@@ -436,8 +472,7 @@ static int davinci_mdio_resume(struct device *dev)
 	u32 ctrl;
 
 	spin_lock(&data->lock);
-	if (data->clk)
-		clk_enable(data->clk);
+	pm_runtime_get_sync(data->dev);
 
 	/* restart the scan state machine */
 	ctrl = __raw_readl(&data->regs->control);
@@ -455,14 +490,20 @@ static const struct dev_pm_ops davinci_mdio_pm_ops = {
 	.resume		= davinci_mdio_resume,
 };
 
+static const struct of_device_id davinci_mdio_of_mtable[] = {
+	{ .compatible = "ti,davinci_mdio", },
+	{ /* sentinel */ },
+};
+
 static struct platform_driver davinci_mdio_driver = {
 	.driver = {
 		.name	 = "davinci_mdio",
 		.owner	 = THIS_MODULE,
 		.pm	 = &davinci_mdio_pm_ops,
+		.of_match_table = of_match_ptr(davinci_mdio_of_mtable),
 	},
 	.probe = davinci_mdio_probe,
-	.remove = __devexit_p(davinci_mdio_remove),
+	.remove = davinci_mdio_remove,
 };
 
 static int __init davinci_mdio_init(void)
diff --git a/drivers/net/ethernet/ti/keystone_ethss.c b/drivers/net/ethernet/ti/keystone_ethss.c
new file mode 100644
index 0000000..299db15
--- /dev/null
+++ b/drivers/net/ethernet/ti/keystone_ethss.c
@@ -0,0 +1,2377 @@
+/*
+ * Copyright (C) 2012 Texas Instruments Incorporated
+ * Authors: Sandeep Paulraj <s-paulraj@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/clk.h>
+#include <linux/phy.h>
+#include <linux/timer.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/uaccess.h>
+#include <linux/if_vlan.h>
+#include <linux/of_mdio.h>
+#include <linux/ethtool.h>
+#include <linux/if_ether.h>
+#include <linux/net_tstamp.h>
+#include <linux/netdevice.h>
+#include <linux/interrupt.h>
+#include <linux/dmaengine.h>
+#include <linux/dma-mapping.h>
+#include <linux/scatterlist.h>
+#include <linux/etherdevice.h>
+#include <linux/platform_device.h>
+
+#include "cpsw_ale.h"
+#include "keystone_net.h"
+
+#define NETCP_DRIVER_NAME	"TI KeyStone Ethernet Driver"
+#define NETCP_DRIVER_VERSION	"v1.2.2"
+
+#define CPSW_SGMII_IDENT(reg)		((reg >> 16) & 0xffff)
+#define CPSW_MAJOR_VERSION(reg)		(reg >> 8 & 0x7)
+#define CPSW_MINOR_VERSION(reg)		(reg & 0xff)
+#define CPSW_RTL_VERSION(reg)		((reg >> 11) & 0x1f)
+
+#define TCI6614_SS_BASE				0x02090000
+#define DEVICE_N_GMACSL_PORTS			2
+#define DEVICE_EMACSL_RESET_POLL_COUNT		100
+
+#define	CPSW_TIMER_INTERVAL			(HZ / 10)
+
+/* Soft reset register values */
+#define SOFT_RESET_MASK				BIT(0)
+#define SOFT_RESET				BIT(0)
+
+#define MACSL_RX_ENABLE_CSF			BIT(23)
+#define MACSL_RX_ENABLE_EXT_CTL			BIT(18)
+#define MACSL_ENABLE				BIT(5)
+#define GMACSL_RET_WARN_RESET_INCOMPLETE	-2
+
+#define CPSW_NUM_PORTS		                3
+#define CPSW_CTL_P0_ENABLE			BIT(2)
+#define CPSW_CTL_VLAN_AWARE			BIT(1)
+#define CPSW_REG_VAL_STAT_ENABLE_ALL		0xf
+
+#define CPSW_MASK_ALL_PORTS			7
+#define CPSW_MASK_PHYS_PORTS			6
+#define CPSW_MASK_NO_PORTS			0
+#define CPSW_NON_VLAN_ADDR			-1
+
+#define CPSW_STATSA_MODULE			0
+#define CPSW_STATSB_MODULE			1
+
+#define MAX_SIZE_STREAM_BUFFER		        9504
+
+struct cpsw_slave {
+	struct cpsw_slave_regs __iomem	*regs;
+	struct cpsw_sliver_regs __iomem	*sliver;
+	int				 slave_num;
+	int				 port_num;
+	u32				 mac_control;
+	struct phy_device		*phy;
+	const char			*phy_id;
+	struct cpsw_ale			*ale;
+	u32				 link_interface;
+	u8				 phy_port_t;
+};
+
+struct cpsw_ss_regs {
+	u32	id_ver;
+	u32	soft_reset;
+	u32	control;
+	u32	int_control;
+	u32	rx_thresh_en;
+	u32	rx_en;
+	u32	tx_en;
+	u32	misc_en;
+	u32	mem_allign1[8];
+	u32	rx_thresh_stat;
+	u32	rx_stat;
+	u32	tx_stat;
+	u32	misc_stat;
+	u32	mem_allign2[8];
+	u32	rx_imax;
+	u32	tx_imax;
+};
+
+struct cpsw_regs {
+	u32	id_ver;
+	u32	control;
+	u32	soft_reset;
+	u32	stat_port_en;
+	u32	ptype;
+	u32	soft_idle;
+	u32	thru_rate;
+	u32	gap_thresh;
+	u32	tx_start_wds;
+	u32	flow_control;
+};
+
+struct cpsw_slave_regs {
+	u32	max_blks;
+	u32	blk_cnt;
+	u32	port_vlan;
+	u32	tx_pri_map;
+	u32	sa_lo;
+	u32	sa_hi;
+	u32	ts_ctl;
+	u32	ts_seq_ltype;
+	u32	ts_vlan;
+};
+
+struct cpsw_host_regs {
+	u32	src_id;
+	u32	port_vlan;
+	u32	rx_pri_map;
+	u32	rx_maxlen;
+};
+
+struct cpsw_sliver_regs {
+	u32	id_ver;
+	u32	mac_control;
+	u32	mac_status;
+	u32	soft_reset;
+	u32	rx_maxlen;
+	u32	__reserved_0;
+	u32	rx_pause;
+	u32	tx_pause;
+	u32	__reserved_1;
+	u32	rx_pri_map;
+	u32	rsvd[6];
+};
+
+struct cpsw_hw_stats {
+	u32	rx_good_frames;
+	u32	rx_broadcast_frames;
+	u32	rx_multicast_frames;
+	u32	rx_pause_frames;
+	u32	rx_crc_errors;
+	u32	rx_align_code_errors;
+	u32	rx_oversized_frames;
+	u32	rx_jabber_frames;
+	u32	rx_undersized_frames;
+	u32	rx_fragments;
+	u32	__pad_0[2];
+	u32	rx_bytes;
+	u32	tx_good_frames;
+	u32	tx_broadcast_frames;
+	u32	tx_multicast_frames;
+	u32	tx_pause_frames;
+	u32	tx_deferred_frames;
+	u32	tx_collision_frames;
+	u32	tx_single_coll_frames;
+	u32	tx_mult_coll_frames;
+	u32	tx_excessive_collisions;
+	u32	tx_late_collisions;
+	u32	tx_underrun;
+	u32	tx_carrier_sense_errors;
+	u32	tx_bytes;
+	u32	tx_64byte_frames;
+	u32	tx_65_to_127byte_frames;
+	u32	tx_128_to_255byte_frames;
+	u32	tx_256_to_511byte_frames;
+	u32	tx_512_to_1023byte_frames;
+	u32	tx_1024byte_frames;
+	u32	net_bytes;
+	u32	rx_sof_overruns;
+	u32	rx_mof_overruns;
+	u32	rx_dma_overruns;
+};
+
+struct cpsw_ale_regs {
+	u32	ale_idver;
+	u32	rsvd0;
+	u32	ale_control;
+	u32	rsvd1;
+	u32	ale_prescale;
+	u32	rsvd2;
+	u32	ale_unknown_vlan;
+	u32	rsvd3;
+	u32	ale_tblctl;
+	u32	rsvd4[4];
+	u32	ale_tblw2;
+	u32	ale_tblw1;
+	u32	ale_tblw0;
+	u32	ale_portctl[6];
+};
+
+struct cpsw_priv {
+	struct device			*dev;
+	struct clk			*cpgmac;
+	struct netcp_device		*netcp_device;
+	u32				 num_slaves;
+	u32				 ale_ageout;
+	u32				 ale_entries;
+	u32				 ale_ports;
+	u32				 sgmii_module_ofs;
+	u32				 switch_module_ofs;
+	u32				 host_port_reg_ofs;
+	u32				 slave_reg_ofs;
+	u32				 sliver_reg_ofs;
+	u32				 hw_stats_reg_ofs;
+	u32				 ale_reg_ofs;
+
+	int				 host_port;
+	u32				 rx_packet_max;
+
+	struct cpsw_regs __iomem	*regs;
+	struct cpsw_ss_regs __iomem	*ss_regs;
+	struct cpsw_hw_stats __iomem	*hw_stats_regs[2];
+	struct cpsw_host_regs __iomem	*host_port_regs;
+	struct cpsw_ale_regs __iomem	*ale_reg;
+
+	void __iomem			*sgmii_port_regs;
+
+	struct cpsw_ale			*ale;
+	u32				 ale_refcnt;
+
+	u32				 link[5];
+	struct device_node		*phy_node[4];
+
+	u32				 intf_tx_queues;
+
+	u32				 multi_if;
+	u32				 slaves_per_interface;
+	u32				 num_interfaces;
+	struct device_node		*interfaces;
+	struct list_head		 cpsw_intf_head;
+
+	u64				 hw_stats[72];
+	int				 init_serdes_at_probe;
+	struct kobject			kobj;
+	struct kobject			tx_pri_kobj;
+	struct kobject			pvlan_kobj;
+	struct kobject			stats_kobj;
+	struct mutex			hw_stats_lock;
+};
+
+struct cpsw_intf {
+	struct net_device	*ndev;
+	struct device		*dev;
+	struct cpsw_priv	*cpsw_priv;
+	struct device_node	*phy_node;
+	u32			 num_slaves;
+	u32			 slave_port;
+	struct cpsw_slave	*slaves;
+	u32			 intf_tx_queues;
+	const char		*tx_chan_name;
+	u32			 tx_queue_depth;
+	struct netcp_tx_pipe	 tx_pipe;
+	u32			 multi_if;
+	struct list_head	 cpsw_intf_list;
+	struct timer_list	 timer;
+	u32			 sgmii_link;
+	unsigned long		 active_vlans[BITS_TO_LONGS(VLAN_N_VID)];
+};
+
+static struct cpsw_priv *priv;		/* FIXME: REMOVE THIS!! */
+
+/*
+ * Statistic management
+ */
+struct netcp_ethtool_stat {
+	char desc[ETH_GSTRING_LEN];
+	int type;
+	u32 size;
+	int offset;
+};
+
+#define for_each_slave(priv, func, arg...)				\
+	do {								\
+		int idx, port;						\
+		port = (priv)->slave_port;				\
+		if ((priv)->multi_if)					\
+			(func)((priv)->slaves, ##arg);			\
+		else							\
+			for (idx = 0; idx < (priv)->num_slaves; idx++)	\
+				(func)((priv)->slaves + idx, ##arg);	\
+	} while (0)
+
+#define FIELDINFO(_struct, field)       FIELD_SIZEOF(_struct, field),	\
+		                                offsetof(_struct, field)
+#define CPSW_STATSA_INFO(field) 	"CPSW_A:"#field, CPSW_STATSA_MODULE,\
+					FIELDINFO(struct cpsw_hw_stats,\
+						field)
+#define CPSW_STATSB_INFO(field) 	"CPSW_B:"#field, CPSW_STATSB_MODULE,\
+					FIELDINFO(struct cpsw_hw_stats,\
+						field)
+
+static const struct netcp_ethtool_stat et_stats[] = {
+	/* CPSW module A */
+	{CPSW_STATSA_INFO(rx_good_frames)},
+	{CPSW_STATSA_INFO(rx_broadcast_frames)},
+	{CPSW_STATSA_INFO(rx_multicast_frames)},
+	{CPSW_STATSA_INFO(rx_pause_frames)},
+	{CPSW_STATSA_INFO(rx_crc_errors)},
+	{CPSW_STATSA_INFO(rx_align_code_errors)},
+	{CPSW_STATSA_INFO(rx_oversized_frames)},
+	{CPSW_STATSA_INFO(rx_jabber_frames)},
+	{CPSW_STATSA_INFO(rx_undersized_frames)},
+	{CPSW_STATSA_INFO(rx_fragments)},
+	{CPSW_STATSA_INFO(rx_bytes)},
+	{CPSW_STATSA_INFO(tx_good_frames)},
+	{CPSW_STATSA_INFO(tx_broadcast_frames)},
+	{CPSW_STATSA_INFO(tx_multicast_frames)},
+	{CPSW_STATSA_INFO(tx_pause_frames)},
+	{CPSW_STATSA_INFO(tx_deferred_frames)},
+	{CPSW_STATSA_INFO(tx_collision_frames)},
+	{CPSW_STATSA_INFO(tx_single_coll_frames)},
+	{CPSW_STATSA_INFO(tx_mult_coll_frames)},
+	{CPSW_STATSA_INFO(tx_excessive_collisions)},
+	{CPSW_STATSA_INFO(tx_late_collisions)},
+	{CPSW_STATSA_INFO(tx_underrun)},
+	{CPSW_STATSA_INFO(tx_carrier_sense_errors)},
+	{CPSW_STATSA_INFO(tx_bytes)},
+	{CPSW_STATSA_INFO(tx_64byte_frames)},
+	{CPSW_STATSA_INFO(tx_65_to_127byte_frames)},
+	{CPSW_STATSA_INFO(tx_128_to_255byte_frames)},
+	{CPSW_STATSA_INFO(tx_256_to_511byte_frames)},
+	{CPSW_STATSA_INFO(tx_512_to_1023byte_frames)},
+	{CPSW_STATSA_INFO(tx_1024byte_frames)},
+	{CPSW_STATSA_INFO(net_bytes)},
+	{CPSW_STATSA_INFO(rx_sof_overruns)},
+	{CPSW_STATSA_INFO(rx_mof_overruns)},
+	{CPSW_STATSA_INFO(rx_dma_overruns)},
+	/* CPSW module B */
+	{CPSW_STATSB_INFO(rx_good_frames)},
+	{CPSW_STATSB_INFO(rx_broadcast_frames)},
+	{CPSW_STATSB_INFO(rx_multicast_frames)},
+	{CPSW_STATSB_INFO(rx_pause_frames)},
+	{CPSW_STATSB_INFO(rx_crc_errors)},
+	{CPSW_STATSB_INFO(rx_align_code_errors)},
+	{CPSW_STATSB_INFO(rx_oversized_frames)},
+	{CPSW_STATSB_INFO(rx_jabber_frames)},
+	{CPSW_STATSB_INFO(rx_undersized_frames)},
+	{CPSW_STATSB_INFO(rx_fragments)},
+	{CPSW_STATSB_INFO(rx_bytes)},
+	{CPSW_STATSB_INFO(tx_good_frames)},
+	{CPSW_STATSB_INFO(tx_broadcast_frames)},
+	{CPSW_STATSB_INFO(tx_multicast_frames)},
+	{CPSW_STATSB_INFO(tx_pause_frames)},
+	{CPSW_STATSB_INFO(tx_deferred_frames)},
+	{CPSW_STATSB_INFO(tx_collision_frames)},
+	{CPSW_STATSB_INFO(tx_single_coll_frames)},
+	{CPSW_STATSB_INFO(tx_mult_coll_frames)},
+	{CPSW_STATSB_INFO(tx_excessive_collisions)},
+	{CPSW_STATSB_INFO(tx_late_collisions)},
+	{CPSW_STATSB_INFO(tx_underrun)},
+	{CPSW_STATSB_INFO(tx_carrier_sense_errors)},
+	{CPSW_STATSB_INFO(tx_bytes)},
+	{CPSW_STATSB_INFO(tx_64byte_frames)},
+	{CPSW_STATSB_INFO(tx_65_to_127byte_frames)},
+	{CPSW_STATSB_INFO(tx_128_to_255byte_frames)},
+	{CPSW_STATSB_INFO(tx_256_to_511byte_frames)},
+	{CPSW_STATSB_INFO(tx_512_to_1023byte_frames)},
+	{CPSW_STATSB_INFO(tx_1024byte_frames)},
+	{CPSW_STATSB_INFO(net_bytes)},
+	{CPSW_STATSB_INFO(rx_sof_overruns)},
+	{CPSW_STATSB_INFO(rx_mof_overruns)},
+	{CPSW_STATSB_INFO(rx_dma_overruns)},
+};
+
+#define ETHTOOL_STATS_NUM ARRAY_SIZE(et_stats)
+
+struct cpsw_attribute {
+	struct attribute attr;
+	ssize_t (*show)(struct cpsw_priv *cpsw_dev,
+		struct cpsw_attribute *attr, char *buf);
+	ssize_t	(*store)(struct cpsw_priv *cpsw_dev,
+		struct cpsw_attribute *attr, const char *, size_t);
+	const struct cpsw_mod_info *info;
+	ssize_t info_size;
+	void *context;
+};
+#define to_cpsw_attr(_attr) container_of(_attr, struct cpsw_attribute, attr)
+
+#define to_cpsw_dev(obj) container_of(obj, struct cpsw_priv, kobj)
+#define tx_pri_to_cpsw_dev(obj) container_of(obj, struct cpsw_priv, tx_pri_kobj)
+#define pvlan_to_cpsw_dev(obj) container_of(obj, struct cpsw_priv, pvlan_kobj)
+#define stats_to_cpsw_dev(obj) container_of(obj, struct cpsw_priv, stats_kobj)
+
+#define BITS(x)			(BIT(x) - 1)
+#define BITMASK(n, s)		(BITS(n) << (s))
+#define cpsw_mod_info_field_val(r, i) \
+	((r & BITMASK(i->bits, i->shift)) >> i->shift)
+
+#define for_each_intf(i, priv) \
+	list_for_each_entry((i), &(priv)->cpsw_intf_head, cpsw_intf_list)
+
+#define __CPSW_ATTR_FULL(_name, _mode, _show, _store, _info,	\
+				_info_size, _ctxt)		\
+	{ \
+		.attr = {.name = __stringify(_name), .mode = _mode },	\
+		.show	= _show,		\
+		.store	= _store,		\
+		.info	= _info,		\
+		.info_size = _info_size,	\
+		.context = (_ctxt),		\
+	}
+
+#define __CPSW_ATTR(_name, _mode, _show, _store, _info) \
+		__CPSW_ATTR_FULL(_name, _mode, _show, _store, _info, \
+					(ARRAY_SIZE(_info)), NULL)
+
+#define __CPSW_CTXT_ATTR(_name, _mode, _show, _store, _info, _ctxt) \
+		__CPSW_ATTR_FULL(_name, _mode, _show, _store, _info, \
+					(ARRAY_SIZE(_info)), _ctxt)
+
+struct cpsw_mod_info {
+	const char	*name;
+	int		shift;
+	int		bits;
+};
+
+struct cpsw_parse_result {
+	int control;
+	int port;
+	u32 value;
+};
+
+static ssize_t cpsw_attr_info_show(const struct cpsw_mod_info *info,
+				int info_size, u32 reg, char *buf)
+{
+	int i, len = 0;
+
+	for (i = 0; i < info_size; i++, info++) {
+		len += snprintf(buf + len, PAGE_SIZE - len,
+			"%s=%d\n", info->name,
+			(int)cpsw_mod_info_field_val(reg, info));
+	}
+
+	return len;
+}
+
+static ssize_t cpsw_attr_parse_set_command(struct cpsw_priv *cpsw_dev,
+			      struct cpsw_attribute *attr,
+			      const char *buf, size_t count,
+				struct cpsw_parse_result *res)
+{
+	char ctrl_str[33], tmp_str[9];
+	int port = -1, value, len, control;
+	unsigned long end;
+	const struct cpsw_mod_info *info = attr->info;
+
+	len = strcspn(buf, ".=");
+	if (len >= 32)
+		return -ENOMEM;
+
+	strncpy(ctrl_str, buf, len);
+	ctrl_str[len] = '\0';
+	buf += len;
+
+	if (*buf == '.') {
+		++buf;
+		len = strcspn(buf, "=");
+		if (len >= 8)
+			return -ENOMEM;
+		strncpy(tmp_str, buf, len);
+		tmp_str[len] = '\0';
+		if (kstrtoul(tmp_str, 0, &end))
+			return -EINVAL;
+		port = (int)end;
+		buf += len;
+	}
+
+	if (*buf != '=')
+		return -EINVAL;
+
+	if (kstrtoul(buf + 1, 0, &end))
+		return -EINVAL;
+
+	value = (int)end;
+
+	for (control = 0; control < attr->info_size; control++)
+		if (strcmp(ctrl_str, info[control].name) == 0)
+			break;
+
+	if (control >= attr->info_size)
+		return -ENOENT;
+
+	res->control = control;
+	res->port = port;
+	res->value = value;
+
+	dev_info(cpsw_dev->dev, "parsed command %s.%d=%d\n",
+		attr->info[control].name, port, value);
+
+	return 0;
+}
+
+static inline void cpsw_info_set_reg_field(void __iomem *r,
+		const struct cpsw_mod_info *info, int val)
+{
+	u32 rv;
+
+	rv = __raw_readl(r);
+	rv = ((rv & ~BITMASK(info->bits, info->shift)) | (val << info->shift));
+	__raw_writel(rv, r);
+}
+
+static ssize_t cpsw_version_show(struct cpsw_priv *cpsw_dev,
+		     struct cpsw_attribute *attr,
+		     char *buf)
+{
+	u32 reg;
+
+	reg = __raw_readl(&cpsw_dev->regs->id_ver);
+
+	return snprintf(buf, PAGE_SIZE,
+		"cpsw version %d.%d (%d) SGMII identification value 0x%x\n",
+		 CPSW_MAJOR_VERSION(reg), CPSW_MINOR_VERSION(reg),
+		 CPSW_RTL_VERSION(reg), CPSW_SGMII_IDENT(reg));
+}
+
+static struct cpsw_attribute cpsw_version_attribute =
+	__ATTR(version, S_IRUGO, cpsw_version_show, NULL);
+
+static const struct cpsw_mod_info cpsw_controls[] = {
+	{
+		.name		= "fifo_loopback",
+		.shift		= 0,
+		.bits		= 1,
+	},
+	{
+		.name		= "vlan_aware",
+		.shift		= 1,
+		.bits		= 1,
+	},
+	{
+		.name		= "p0_enable",
+		.shift		= 2,
+		.bits		= 1,
+	},
+	{
+		.name		= "p0_pass_pri_tagged",
+		.shift		= 3,
+		.bits		= 1,
+	},
+	{
+		.name		= "p1_pass_pri_tagged",
+		.shift		= 4,
+		.bits		= 1,
+	},
+	{
+		.name		= "p2_pass_pri_tagged",
+		.shift		= 5,
+		.bits		= 1,
+	},
+};
+
+static ssize_t cpsw_control_show(struct cpsw_priv *cpsw_dev,
+		     struct cpsw_attribute *attr,
+		     char *buf)
+{
+	u32 reg;
+
+	reg = __raw_readl(&cpsw_dev->regs->control);
+	return cpsw_attr_info_show(attr->info, attr->info_size, reg, buf);
+}
+
+static ssize_t cpsw_control_store(struct cpsw_priv *cpsw_dev,
+			      struct cpsw_attribute *attr,
+			      const char *buf, size_t count)
+{
+	const struct cpsw_mod_info *i;
+	struct cpsw_parse_result res;
+	void __iomem *r = NULL;
+	int ret;
+
+
+	ret = cpsw_attr_parse_set_command(cpsw_dev, attr, buf, count, &res);
+	if (ret)
+		return ret;
+
+	i = &(attr->info[res.control]);
+	r = &cpsw_dev->regs->control;
+
+	cpsw_info_set_reg_field(r, i, res.value);
+	return count;
+}
+
+static struct cpsw_attribute cpsw_control_attribute =
+	__CPSW_ATTR(control, S_IRUGO | S_IWUSR,
+		cpsw_control_show, cpsw_control_store, cpsw_controls);
+
+static const struct cpsw_mod_info cpsw_ptypes[] = {
+	{
+		.name		= "escalate_pri_load_val",
+		.shift		= 0,
+		.bits		= 5,
+	},
+	{
+		.name		= "port0_pri_type_escalate",
+		.shift		= 8,
+		.bits		= 1,
+	},
+	{
+		.name		= "port1_pri_type_escalate",
+		.shift		= 9,
+		.bits		= 1,
+	},
+	{
+		.name		= "port2_pri_type_escalate",
+		.shift		= 10,
+		.bits		= 1,
+	},
+};
+
+static ssize_t cpsw_pri_type_show(struct cpsw_priv *cpsw_dev,
+		     struct cpsw_attribute *attr,
+		     char *buf)
+{
+	u32 reg;
+
+	reg = __raw_readl(&cpsw_dev->regs->ptype);
+
+	return cpsw_attr_info_show(attr->info, attr->info_size, reg, buf);
+}
+
+static ssize_t cpsw_pri_type_store(struct cpsw_priv *cpsw_dev,
+			      struct cpsw_attribute *attr,
+			      const char *buf, size_t count)
+{
+	const struct cpsw_mod_info *i;
+	struct cpsw_parse_result res;
+	void __iomem *r = NULL;
+	int ret;
+
+
+	ret = cpsw_attr_parse_set_command(cpsw_dev, attr, buf, count, &res);
+	if (ret)
+		return ret;
+
+	i = &(attr->info[res.control]);
+	r = &cpsw_dev->regs->ptype;
+
+	cpsw_info_set_reg_field(r, i, res.value);
+	return count;
+}
+
+static struct cpsw_attribute cpsw_pri_type_attribute =
+	__CPSW_ATTR(priority_type, S_IRUGO | S_IWUSR,
+			cpsw_pri_type_show,
+			cpsw_pri_type_store,
+			cpsw_ptypes);
+
+static const struct cpsw_mod_info cpsw_flow_controls[] = {
+	{
+		.name		= "port0_flow_control_en",
+		.shift		= 0,
+		.bits		= 1,
+	},
+	{
+		.name		= "port1_flow_control_en",
+		.shift		= 1,
+		.bits		= 1,
+	},
+	{
+		.name		= "port2_flow_control_en",
+		.shift		= 2,
+		.bits		= 1,
+	},
+};
+
+static ssize_t cpsw_flow_control_show(struct cpsw_priv *cpsw_dev,
+		     struct cpsw_attribute *attr, char *buf)
+{
+	u32 reg;
+
+	reg = __raw_readl(&cpsw_dev->regs->flow_control);
+
+	return cpsw_attr_info_show(attr->info, attr->info_size, reg, buf);
+}
+
+static ssize_t cpsw_flow_control_store(struct cpsw_priv *cpsw_dev,
+			      struct cpsw_attribute *attr,
+			      const char *buf, size_t count)
+{
+	const struct cpsw_mod_info *i;
+	struct cpsw_parse_result res;
+	void __iomem *r = NULL;
+	int ret;
+
+
+	ret = cpsw_attr_parse_set_command(cpsw_dev, attr, buf, count, &res);
+	if (ret)
+		return ret;
+
+	i = &(attr->info[res.control]);
+	r = &cpsw_dev->regs->flow_control;
+
+	cpsw_info_set_reg_field(r, i, res.value);
+	return count;
+}
+
+static struct cpsw_attribute cpsw_flow_control_attribute =
+	__CPSW_ATTR(flow_control, S_IRUGO | S_IWUSR,
+		cpsw_flow_control_show,
+		cpsw_flow_control_store,
+		cpsw_flow_controls);
+
+static const struct cpsw_mod_info cpsw_port_tx_pri_maps[] = {
+	{
+		.name		= "port_tx_pri_0",
+		.shift		= 0,
+		.bits		= 3,
+	},
+	{
+		.name		= "port_tx_pri_1",
+		.shift		= 4,
+		.bits		= 3,
+	},
+	{
+		.name		= "port_tx_pri_2",
+		.shift		= 8,
+		.bits		= 3,
+	},
+	{
+		.name		= "port_tx_pri_3",
+		.shift		= 12,
+		.bits		= 3,
+	},
+	{
+		.name		= "port_tx_pri_4",
+		.shift		= 16,
+		.bits		= 3,
+	},
+	{
+		.name		= "port_tx_pri_5",
+		.shift		= 20,
+		.bits		= 3,
+	},
+	{
+		.name		= "port_tx_pri_6",
+		.shift		= 24,
+		.bits		= 3,
+	},
+	{
+		.name		= "port_tx_pri_7",
+		.shift		= 28,
+		.bits		= 3,
+	},
+};
+
+static ssize_t cpsw_port_tx_pri_map_show(struct cpsw_priv *cpsw_dev,
+		     struct cpsw_attribute *attr,
+		     char *buf)
+{
+	int idx, len = 0, total_len = 0, port;
+	struct cpsw_intf *cpsw_intf;
+	struct cpsw_slave *slave;
+	u32 reg;
+
+	port = (int)(attr->context);
+
+	for_each_intf(cpsw_intf, cpsw_dev) {
+		if (cpsw_intf->multi_if) {
+			slave = cpsw_intf->slaves;
+			if (slave->port_num != port)
+				continue;
+			reg = __raw_readl(&slave->regs->tx_pri_map);
+			len = cpsw_attr_info_show(attr->info, attr->info_size,
+						reg, buf+total_len);
+			total_len += len;
+		} else {
+			for (idx = 0; idx < cpsw_intf->num_slaves; idx++) {
+				slave = cpsw_intf->slaves + idx;
+				if (slave->port_num != port)
+					continue;
+				reg = __raw_readl(&slave->regs->tx_pri_map);
+				len = cpsw_attr_info_show(attr->info,
+					attr->info_size, reg, buf+total_len);
+				total_len += len;
+			}
+		}
+	}
+	return total_len;
+}
+
+static ssize_t cpsw_port_tx_pri_map_store(struct cpsw_priv *cpsw_dev,
+			      struct cpsw_attribute *attr,
+			      const char *buf, size_t count)
+{
+	const struct cpsw_mod_info *i;
+	struct cpsw_parse_result res;
+	struct cpsw_intf *cpsw_intf;
+	struct cpsw_slave *slave;
+	void __iomem *r = NULL;
+	int ret, idx, port;
+
+	port = (int)(attr->context);
+
+	ret = cpsw_attr_parse_set_command(cpsw_dev, attr, buf, count, &res);
+	if (ret)
+		return ret;
+
+	i = &(attr->info[res.control]);
+
+	/* Slave port */
+	for_each_intf(cpsw_intf, cpsw_dev) {
+		if (cpsw_intf->multi_if) {
+			slave = cpsw_intf->slaves;
+			if (slave->port_num == port) {
+				r = &slave->regs->tx_pri_map;
+				goto set;
+			}
+		} else
+			for (idx = 0; idx < cpsw_intf->num_slaves; idx++) {
+				slave = cpsw_intf->slaves + idx;
+				if (slave->port_num == port) {
+					r = &slave->regs->tx_pri_map;
+					goto set;
+				}
+			}
+	}
+
+	if (!r)
+		return  -ENOENT;
+
+set:
+	cpsw_info_set_reg_field(r, i, res.value);
+	return count;
+}
+
+static struct cpsw_attribute cpsw_tx_pri_1_attribute =
+	__CPSW_CTXT_ATTR(1, S_IRUGO | S_IWUSR,
+			cpsw_port_tx_pri_map_show,
+			cpsw_port_tx_pri_map_store,
+			cpsw_port_tx_pri_maps, (void *)1);
+
+static struct cpsw_attribute cpsw_tx_pri_2_attribute =
+	__CPSW_CTXT_ATTR(2, S_IRUGO | S_IWUSR,
+			cpsw_port_tx_pri_map_show,
+			cpsw_port_tx_pri_map_store,
+			cpsw_port_tx_pri_maps, (void *)2);
+
+static struct cpsw_attribute cpsw_tx_pri_3_attribute =
+	__CPSW_CTXT_ATTR(3, S_IRUGO | S_IWUSR,
+			cpsw_port_tx_pri_map_show,
+			cpsw_port_tx_pri_map_store,
+			cpsw_port_tx_pri_maps, (void *)3);
+
+static struct cpsw_attribute cpsw_tx_pri_4_attribute =
+	__CPSW_CTXT_ATTR(4, S_IRUGO | S_IWUSR,
+			cpsw_port_tx_pri_map_show,
+			cpsw_port_tx_pri_map_store,
+			cpsw_port_tx_pri_maps, (void *)4);
+
+static struct attribute *cpsw_tx_pri_default_attrs[] = {
+	&cpsw_tx_pri_1_attribute.attr,
+	&cpsw_tx_pri_2_attribute.attr,
+	&cpsw_tx_pri_3_attribute.attr,
+	&cpsw_tx_pri_4_attribute.attr,
+	NULL
+};
+
+static ssize_t cpsw_tx_pri_attr_show(struct kobject *kobj,
+			struct attribute *attr, char *buf)
+{
+	struct cpsw_attribute *attribute = to_cpsw_attr(attr);
+	struct cpsw_priv *cpsw_dev = tx_pri_to_cpsw_dev(kobj);
+
+	if (!attribute->show)
+		return -EIO;
+
+	return attribute->show(cpsw_dev, attribute, buf);
+}
+
+static ssize_t cpsw_tx_pri_attr_store(struct kobject *kobj,
+			struct attribute *attr, const char *buf, size_t count)
+{
+	struct cpsw_attribute *attribute = to_cpsw_attr(attr);
+	struct cpsw_priv *cpsw_dev = tx_pri_to_cpsw_dev(kobj);
+
+	if (!attribute->store)
+		return -EIO;
+
+	return attribute->store(cpsw_dev, attribute, buf, count);
+}
+
+static const struct sysfs_ops cpsw_tx_pri_sysfs_ops = {
+	.show = cpsw_tx_pri_attr_show,
+	.store = cpsw_tx_pri_attr_store,
+};
+
+static struct kobj_type cpsw_tx_pri_ktype = {
+	.sysfs_ops = &cpsw_tx_pri_sysfs_ops,
+	.default_attrs = cpsw_tx_pri_default_attrs,
+};
+
+static const struct cpsw_mod_info cpsw_port_vlans[] = {
+	{
+		.name		= "port_vlan_id",
+		.shift		= 0,
+		.bits		= 12,
+	},
+	{
+		.name		= "port_cfi",
+		.shift		= 12,
+		.bits		= 1,
+	},
+	{
+		.name		= "port_vlan_pri",
+		.shift		= 13,
+		.bits		= 3,
+	},
+};
+
+static ssize_t cpsw_port_vlan_show(struct cpsw_priv *cpsw_dev,
+		     struct cpsw_attribute *attr,
+		     char *buf)
+{
+	int idx, len = 0, total_len = 0, port;
+	struct cpsw_intf *cpsw_intf;
+	struct cpsw_slave *slave;
+	u32 reg;
+
+	port = (int)(attr->context);
+
+	if (port == cpsw_dev->host_port) {
+		/* Host port */
+		reg = __raw_readl(&cpsw_dev->host_port_regs->port_vlan);
+		len = cpsw_attr_info_show(attr->info, attr->info_size,
+					reg, buf);
+		return len;
+	}
+
+	/* Slave ports */
+	for_each_intf(cpsw_intf, cpsw_dev) {
+		if (cpsw_intf->multi_if) {
+			slave = cpsw_intf->slaves;
+			if (slave->port_num != port)
+				continue;
+			reg = __raw_readl(&slave->regs->port_vlan);
+			len = cpsw_attr_info_show(attr->info, attr->info_size,
+					reg, buf+total_len);
+			total_len += len;
+		} else {
+			for (idx = 0; idx < cpsw_intf->num_slaves; idx++) {
+				slave = cpsw_intf->slaves + idx;
+				if (slave->port_num != port)
+					continue;
+				reg = __raw_readl(&slave->regs->port_vlan);
+				len = cpsw_attr_info_show(attr->info,
+					attr->info_size, reg, buf+total_len);
+				total_len += len;
+			}
+		}
+	}
+	return total_len;
+}
+
+static ssize_t cpsw_port_vlan_store(struct cpsw_priv *cpsw_dev,
+			      struct cpsw_attribute *attr,
+			      const char *buf, size_t count)
+{
+	const struct cpsw_mod_info *i;
+	struct cpsw_parse_result res;
+	struct cpsw_intf *cpsw_intf;
+	struct cpsw_slave *slave;
+	void __iomem *r = NULL;
+	int ret, idx, port;
+
+	port = (int)(attr->context);
+
+	ret = cpsw_attr_parse_set_command(cpsw_dev, attr, buf, count, &res);
+	if (ret)
+		return ret;
+
+	i = &(attr->info[res.control]);
+
+	/* Host port */
+	if (port == cpsw_dev->host_port) {
+		r = &cpsw_dev->host_port_regs->port_vlan;
+		goto set;
+	}
+
+	/* Slave port */
+	for_each_intf(cpsw_intf, cpsw_dev) {
+		if (cpsw_intf->multi_if) {
+			slave = cpsw_intf->slaves;
+			if (slave->port_num == port) {
+				r = &slave->regs->port_vlan;
+				goto set;
+			}
+		} else
+			for (idx = 0; idx < cpsw_intf->num_slaves; idx++) {
+				slave = cpsw_intf->slaves + idx;
+				if (slave->port_num == port) {
+					r = &slave->regs->port_vlan;
+					goto set;
+				}
+			}
+	}
+
+	if (!r)
+		return  -ENOENT;
+
+set:
+	cpsw_info_set_reg_field(r, i, res.value);
+	return count;
+}
+
+static struct cpsw_attribute cpsw_pvlan_0_attribute =
+	__CPSW_CTXT_ATTR(0, S_IRUGO | S_IWUSR,
+			cpsw_port_vlan_show,
+			cpsw_port_vlan_store,
+			cpsw_port_vlans, (void *)0);
+
+static struct cpsw_attribute cpsw_pvlan_1_attribute =
+	__CPSW_CTXT_ATTR(1, S_IRUGO | S_IWUSR,
+			cpsw_port_vlan_show,
+			cpsw_port_vlan_store,
+			cpsw_port_vlans, (void *)1);
+
+static struct cpsw_attribute cpsw_pvlan_2_attribute =
+	__CPSW_CTXT_ATTR(2, S_IRUGO | S_IWUSR,
+			cpsw_port_vlan_show,
+			cpsw_port_vlan_store,
+			cpsw_port_vlans, (void *)2);
+
+static struct cpsw_attribute cpsw_pvlan_3_attribute =
+	__CPSW_CTXT_ATTR(3, S_IRUGO | S_IWUSR,
+			cpsw_port_vlan_show,
+			cpsw_port_vlan_store,
+			cpsw_port_vlans, (void *)3);
+
+static struct cpsw_attribute cpsw_pvlan_4_attribute =
+	__CPSW_CTXT_ATTR(4, S_IRUGO | S_IWUSR,
+			cpsw_port_vlan_show,
+			cpsw_port_vlan_store,
+			cpsw_port_vlans, (void *)4);
+
+static struct attribute *cpsw_pvlan_default_attrs[] = {
+	&cpsw_pvlan_0_attribute.attr,
+	&cpsw_pvlan_1_attribute.attr,
+	&cpsw_pvlan_2_attribute.attr,
+	&cpsw_pvlan_3_attribute.attr,
+	&cpsw_pvlan_4_attribute.attr,
+	NULL
+};
+
+static ssize_t cpsw_pvlan_attr_show(struct kobject *kobj,
+			struct attribute *attr, char *buf)
+{
+	struct cpsw_attribute *attribute = to_cpsw_attr(attr);
+	struct cpsw_priv *cpsw_dev = pvlan_to_cpsw_dev(kobj);
+
+	if (!attribute->show)
+		return -EIO;
+
+	return attribute->show(cpsw_dev, attribute, buf);
+}
+
+static ssize_t cpsw_pvlan_attr_store(struct kobject *kobj,
+			struct attribute *attr, const char *buf, size_t count)
+{
+	struct cpsw_attribute *attribute = to_cpsw_attr(attr);
+	struct cpsw_priv *cpsw_dev = pvlan_to_cpsw_dev(kobj);
+
+	if (!attribute->store)
+		return -EIO;
+
+	return attribute->store(cpsw_dev, attribute, buf, count);
+}
+
+static const struct sysfs_ops cpsw_pvlan_sysfs_ops = {
+	.show = cpsw_pvlan_attr_show,
+	.store = cpsw_pvlan_attr_store,
+};
+
+static struct kobj_type cpsw_pvlan_ktype = {
+	.sysfs_ops = &cpsw_pvlan_sysfs_ops,
+	.default_attrs = cpsw_pvlan_default_attrs,
+};
+
+static void cpsw_reset_mod_stats(struct cpsw_priv *cpsw_dev, int stat_mod)
+{
+	struct cpsw_hw_stats __iomem *cpsw_statsa = cpsw_dev->hw_stats_regs[0];
+	struct cpsw_hw_stats __iomem *cpsw_statsb = cpsw_dev->hw_stats_regs[1];
+	void *p = NULL;
+	int i;
+
+	if (stat_mod == CPSW_STATSA_MODULE)
+		p = cpsw_statsa;
+	else
+		p = cpsw_statsb;
+
+	for (i = 0; i < ETHTOOL_STATS_NUM; i++) {
+		if (et_stats[i].type == stat_mod) {
+			cpsw_dev->hw_stats[i] = 0;
+			p = (u8 *)p + et_stats[i].offset;
+			*(u32 *)p = 0xffffffff;
+		}
+	}
+	return;
+}
+
+static ssize_t cpsw_stats_mod_store(struct cpsw_priv *cpsw_dev,
+			      struct cpsw_attribute *attr,
+			      const char *buf, size_t count)
+{
+	unsigned long end;
+	int stat_mod;
+
+	if (kstrtoul(buf, 0, &end) != 0 || (end != 0))
+		return -EINVAL;
+
+	stat_mod = (int)(attr->context);
+	mutex_lock(&cpsw_dev->hw_stats_lock);
+	cpsw_reset_mod_stats(cpsw_dev, stat_mod);
+	mutex_unlock(&cpsw_dev->hw_stats_lock);
+	return count;
+}
+
+static struct cpsw_attribute cpsw_stats_a_attribute =
+	__CPSW_ATTR_FULL(A, S_IWUSR, NULL, cpsw_stats_mod_store,
+			NULL, 0, (void *)CPSW_STATSA_MODULE);
+
+static struct cpsw_attribute cpsw_stats_b_attribute =
+	__CPSW_ATTR_FULL(B, S_IWUSR, NULL, cpsw_stats_mod_store,
+			NULL, 0, (void *)CPSW_STATSB_MODULE);
+
+static struct attribute *cpsw_stats_default_attrs[] = {
+	&cpsw_stats_a_attribute.attr,
+	&cpsw_stats_b_attribute.attr,
+	NULL
+};
+
+static ssize_t cpsw_stats_attr_store(struct kobject *kobj,
+			struct attribute *attr, const char *buf, size_t count)
+{
+	struct cpsw_attribute *attribute = to_cpsw_attr(attr);
+	struct cpsw_priv *cpsw_dev = stats_to_cpsw_dev(kobj);
+
+	if (!attribute->store)
+		return -EIO;
+
+	return attribute->store(cpsw_dev, attribute, buf, count);
+}
+
+static const struct sysfs_ops cpsw_stats_sysfs_ops = {
+	.store = cpsw_stats_attr_store,
+};
+
+static struct kobj_type cpsw_stats_ktype = {
+	.sysfs_ops = &cpsw_stats_sysfs_ops,
+	.default_attrs = cpsw_stats_default_attrs,
+};
+
+static struct attribute *cpsw_default_attrs[] = {
+	&cpsw_version_attribute.attr,
+	&cpsw_control_attribute.attr,
+	&cpsw_pri_type_attribute.attr,
+	&cpsw_flow_control_attribute.attr,
+	NULL
+};
+
+static ssize_t cpsw_attr_show(struct kobject *kobj, struct attribute *attr,
+				  char *buf)
+{
+	struct cpsw_attribute *attribute = to_cpsw_attr(attr);
+	struct cpsw_priv *cpsw_dev = to_cpsw_dev(kobj);
+
+	if (!attribute->show)
+		return -EIO;
+
+	return attribute->show(cpsw_dev, attribute, buf);
+}
+
+static ssize_t cpsw_attr_store(struct kobject *kobj, struct attribute *attr,
+				   const char *buf, size_t count)
+{
+	struct cpsw_attribute *attribute = to_cpsw_attr(attr);
+	struct cpsw_priv *cpsw_dev = to_cpsw_dev(kobj);
+
+	if (!attribute->store)
+		return -EIO;
+
+	return attribute->store(cpsw_dev, attribute, buf, count);
+}
+
+static const struct sysfs_ops cpsw_sysfs_ops = {
+	.show = cpsw_attr_show,
+	.store = cpsw_attr_store,
+};
+
+static struct kobj_type cpsw_ktype = {
+	.sysfs_ops = &cpsw_sysfs_ops,
+	.default_attrs = cpsw_default_attrs,
+};
+
+static void keystone_get_drvinfo(struct net_device *ndev,
+			     struct ethtool_drvinfo *info)
+{
+	strncpy(info->driver, NETCP_DRIVER_NAME, sizeof(info->driver));
+	strncpy(info->version, NETCP_DRIVER_VERSION, sizeof(info->version));
+}
+
+static u32 keystone_get_msglevel(struct net_device *ndev)
+{
+	struct netcp_priv *netcp = netdev_priv(ndev);
+	return netcp->msg_enable;
+}
+
+static void keystone_set_msglevel(struct net_device *ndev, u32 value)
+{
+	struct netcp_priv *netcp = netdev_priv(ndev);
+	netcp->msg_enable = value;
+}
+
+static void keystone_get_stat_strings(struct net_device *ndev,
+				   uint32_t stringset, uint8_t *data)
+{
+	int i;
+
+	switch (stringset) {
+	case ETH_SS_STATS:
+		for (i = 0; i < ETHTOOL_STATS_NUM; i++) {
+			memcpy(data, et_stats[i].desc, ETH_GSTRING_LEN);
+			data += ETH_GSTRING_LEN;
+		}
+		break;
+	case ETH_SS_TEST:
+		break;
+	}
+}
+
+static int keystone_get_sset_count(struct net_device *ndev, int stringset)
+{
+	switch (stringset) {
+	case ETH_SS_TEST:
+		return 0;
+	case ETH_SS_STATS:
+		return ETHTOOL_STATS_NUM;
+	default:
+		return -EINVAL;
+	}
+}
+
+static void cpsw_update_stats(struct cpsw_priv *cpsw_dev, uint64_t *data)
+{
+	struct cpsw_hw_stats __iomem *cpsw_statsa = cpsw_dev->hw_stats_regs[0];
+	struct cpsw_hw_stats __iomem *cpsw_statsb = cpsw_dev->hw_stats_regs[1];
+	void *p = NULL;
+	u32 tmp = 0;
+	int i;
+
+	for (i = 0; i < ETHTOOL_STATS_NUM; i++) {
+		switch (et_stats[i].type) {
+		case CPSW_STATSA_MODULE:
+			p = cpsw_statsa;
+			break;
+		case CPSW_STATSB_MODULE:
+			p  = cpsw_statsb;
+			break;
+		}
+
+		p = (u8 *)p + et_stats[i].offset;
+		tmp = *(u32 *)p;
+		cpsw_dev->hw_stats[i] = cpsw_dev->hw_stats[i] + tmp;
+		if (data)
+			data[i] = cpsw_dev->hw_stats[i];
+		*(u32 *)p = tmp;
+	}
+
+	return;
+}
+
+static void keystone_get_ethtool_stats(struct net_device *ndev,
+				       struct ethtool_stats *stats,
+				       uint64_t *data)
+{
+	mutex_lock(&priv->hw_stats_lock);
+	cpsw_update_stats(priv, data);
+	mutex_unlock(&priv->hw_stats_lock);
+
+	return;
+}
+
+static int keystone_get_settings(struct net_device *ndev,
+			      struct ethtool_cmd *cmd)
+{
+	struct phy_device *phy = ndev->phydev;
+	struct cpsw_slave *slave;
+	int ret;
+
+	if (!phy)
+		return -EINVAL;
+
+	slave = (struct cpsw_slave *)phy->context;
+	if (!slave)
+		return -EINVAL;
+
+	ret = phy_ethtool_gset(phy, cmd);
+	if (!ret)
+		cmd->port = slave->phy_port_t;
+
+	return ret;
+}
+
+static int keystone_set_settings(struct net_device *ndev,
+				struct ethtool_cmd *cmd)
+{
+	struct phy_device *phy = ndev->phydev;
+	struct cpsw_slave *slave;
+	u32 features = cmd->advertising & cmd->supported;
+
+	if (!phy)
+		return -EINVAL;
+
+	slave = (struct cpsw_slave *)phy->context;
+	if (!slave)
+		return -EINVAL;
+
+	if (cmd->port != slave->phy_port_t) {
+		if ((cmd->port == PORT_TP) && !(features & ADVERTISED_TP))
+			return -EINVAL;
+
+		if ((cmd->port == PORT_AUI) && !(features & ADVERTISED_AUI))
+			return -EINVAL;
+
+		if ((cmd->port == PORT_BNC) && !(features & ADVERTISED_BNC))
+			return -EINVAL;
+
+		if ((cmd->port == PORT_MII) && !(features & ADVERTISED_MII))
+			return -EINVAL;
+
+		if ((cmd->port == PORT_FIBRE) && !(features & ADVERTISED_FIBRE))
+			return -EINVAL;
+	}
+
+	slave->phy_port_t = cmd->port;
+
+	return phy_ethtool_sset(phy, cmd);
+}
+
+static const struct ethtool_ops keystone_ethtool_ops = {
+	.get_drvinfo		= keystone_get_drvinfo,
+	.get_link		= ethtool_op_get_link,
+	.get_msglevel		= keystone_get_msglevel,
+	.set_msglevel		= keystone_set_msglevel,
+	.get_strings		= keystone_get_stat_strings,
+	.get_sset_count		= keystone_get_sset_count,
+	.get_ethtool_stats	= keystone_get_ethtool_stats,
+	.get_settings		= keystone_get_settings,
+	.set_settings		= keystone_set_settings,
+};
+
+#define mac_hi(mac)	(((mac)[0] << 0) | ((mac)[1] << 8) |	\
+			 ((mac)[2] << 16) | ((mac)[3] << 24))
+#define mac_lo(mac)	(((mac)[4] << 0) | ((mac)[5] << 8))
+
+static void cpsw_set_slave_mac(struct cpsw_slave *slave,
+			       struct cpsw_intf *cpsw_intf)
+{
+	struct net_device *ndev = cpsw_intf->ndev;
+
+	__raw_writel(mac_hi(ndev->dev_addr), &slave->regs->sa_hi);
+	__raw_writel(mac_lo(ndev->dev_addr), &slave->regs->sa_lo);
+}
+
+static inline int cpsw_get_slave_port(struct cpsw_priv *priv, u32 slave_num)
+{
+	if (priv->host_port == 0)
+		return slave_num + 1;
+	else
+		return slave_num;
+}
+
+static void _cpsw_adjust_link(struct cpsw_slave *slave, bool *link)
+{
+	struct phy_device *phy = slave->phy;
+	u32 mac_control = 0;
+	u32 slave_port;
+
+	if (!phy)
+		return;
+
+	slave_port = slave->port_num;
+
+	if (phy->link) {
+		mac_control = slave->mac_control;
+		mac_control |= MACSL_ENABLE | MACSL_RX_ENABLE_EXT_CTL |
+				MACSL_RX_ENABLE_CSF;
+		/* enable forwarding */
+		cpsw_ale_control_set(slave->ale, slave_port,
+				     ALE_PORT_STATE, ALE_PORT_STATE_FORWARD);
+
+		if (phy->duplex)
+			mac_control |= BIT(0);	/* FULLDUPLEXEN	*/
+		else
+			mac_control &= ~0x1;
+
+		*link = true;
+	} else {
+		mac_control = 0;
+		/* disable forwarding */
+		cpsw_ale_control_set(slave->ale, slave_port,
+				     ALE_PORT_STATE, ALE_PORT_STATE_DISABLE);
+	}
+
+	if (mac_control != slave->mac_control) {
+		phy_print_status(phy);
+		__raw_writel(mac_control, &slave->sliver->mac_control);
+	}
+
+	slave->mac_control = mac_control;
+}
+
+static void cpsw_adjust_link(struct net_device *n_dev, void *context)
+{
+	struct cpsw_slave *slave = (struct cpsw_slave *)context;
+	struct netcp_priv *netcp = netdev_priv(n_dev);
+	bool link = false;
+
+	_cpsw_adjust_link(slave, &link);
+
+	if (link)
+		netcp->link_state |= BIT(slave->slave_num);
+	else
+		netcp->link_state &= ~BIT(slave->slave_num);
+}
+
+/*
+ * Reset the the mac sliver
+ * Soft reset is set and polled until clear, or until a timeout occurs
+ */
+static int cpsw_port_reset(struct cpsw_slave *slave)
+{
+	u32 i, v;
+
+	/* Set the soft reset bit */
+	__raw_writel(SOFT_RESET,
+		     &slave->sliver->soft_reset);
+
+	/* Wait for the bit to clear */
+	for (i = 0; i < DEVICE_EMACSL_RESET_POLL_COUNT; i++) {
+		v = __raw_readl(&slave->sliver->soft_reset);
+		if ((v & SOFT_RESET_MASK) !=
+		    SOFT_RESET)
+			return 0;
+	}
+
+	/* Timeout on the reset */
+	return GMACSL_RET_WARN_RESET_INCOMPLETE;
+}
+
+/*
+ * Configure the mac sliver
+ */
+static void cpsw_port_config(struct cpsw_slave *slave, int max_rx_len)
+{
+	if (max_rx_len > MAX_SIZE_STREAM_BUFFER)
+		max_rx_len = MAX_SIZE_STREAM_BUFFER;
+
+	__raw_writel(max_rx_len, &slave->sliver->rx_maxlen);
+	
+	__raw_writel(MACSL_ENABLE | MACSL_RX_ENABLE_EXT_CTL |
+		     MACSL_RX_ENABLE_CSF, &slave->sliver->mac_control);
+}
+
+static void cpsw_slave_stop(struct cpsw_slave *slave, struct cpsw_priv *priv)
+{
+	cpsw_port_reset(slave);
+
+	if (!slave->phy)
+		return;
+
+	phy_stop(slave->phy);
+	phy_disconnect(slave->phy);
+	slave->phy = NULL;
+}
+
+static void cpsw_slave_link(struct cpsw_slave *slave,
+			    struct cpsw_intf *cpsw_intf)
+{
+	struct netcp_priv *netcp = netdev_priv(cpsw_intf->ndev);
+
+	if (slave->link_interface == SGMII_LINK_MAC_PHY) {
+		if (netcp->link_state)
+			cpsw_intf->sgmii_link |= BIT(slave->slave_num);
+		else
+			cpsw_intf->sgmii_link &= ~BIT(slave->slave_num);
+	}
+}
+
+static void cpsw_slave_open(struct cpsw_slave *slave,
+			    struct cpsw_intf *cpsw_intf)
+{
+	struct cpsw_priv *priv = cpsw_intf->cpsw_priv;
+	char name[32];		/* FIXME: Unused variable */
+	u32 slave_port;
+
+	snprintf(name, sizeof(name), "slave-%d", slave->slave_num);
+
+	keystone_sgmii_reset(priv->sgmii_port_regs, slave->slave_num);
+
+	keystone_sgmii_config(priv->sgmii_port_regs, slave->slave_num,
+				slave->link_interface);
+
+	cpsw_port_reset(slave);
+
+	cpsw_port_config(slave, priv->rx_packet_max);
+
+	cpsw_set_slave_mac(slave, cpsw_intf);
+
+	slave->mac_control = MACSL_ENABLE | MACSL_RX_ENABLE_EXT_CTL |
+				MACSL_RX_ENABLE_CSF;
+
+	slave_port = cpsw_get_slave_port(priv, slave->slave_num);
+
+	slave->port_num = slave_port;
+	slave->ale = priv->ale;
+
+	/* enable forwarding */
+	cpsw_ale_control_set(priv->ale, slave_port,
+			     ALE_PORT_STATE, ALE_PORT_STATE_FORWARD);
+
+	cpsw_ale_add_mcast(priv->ale, cpsw_intf->ndev->broadcast,
+			   1 << slave_port, 0, ALE_MCAST_FWD_2,
+			   CPSW_NON_VLAN_ADDR);
+
+	if (slave->link_interface == SGMII_LINK_MAC_PHY) {
+		slave->phy = of_phy_connect(cpsw_intf->ndev,
+					    cpsw_intf->phy_node,
+					    &cpsw_adjust_link, 0,
+					    PHY_INTERFACE_MODE_SGMII,
+					    slave);
+		if (IS_ERR_OR_NULL(slave->phy)) {
+			dev_err(priv->dev, "phy not found on slave %d\n",
+				slave->slave_num);
+			slave->phy = NULL;
+		} else {
+			dev_info(priv->dev, "phy found: id is: 0x%s\n",
+				 dev_name(&slave->phy->dev));
+			cpsw_intf->ndev->phydev = slave->phy;
+			slave->phy_port_t = PORT_MII;
+			phy_start(slave->phy);
+		}
+	}
+}
+
+static void cpsw_init_host_port(struct cpsw_priv *priv,
+				struct cpsw_intf *cpsw_intf)
+{
+	/* Max length register */
+	__raw_writel(MAX_SIZE_STREAM_BUFFER,
+		     &priv->host_port_regs->rx_maxlen);
+
+	if (priv->ale_refcnt == 1)
+		cpsw_ale_start(priv->ale);
+
+	if (priv->multi_if)
+		cpsw_ale_control_set(priv->ale, 0, ALE_BYPASS, 1);
+
+	cpsw_ale_control_set(priv->ale, 0, ALE_NO_PORT_VLAN, 1);
+
+	cpsw_ale_control_set(priv->ale, priv->host_port,
+			     ALE_PORT_STATE, ALE_PORT_STATE_FORWARD);
+
+	cpsw_ale_control_set(priv->ale, 0,
+			     ALE_PORT_UNKNOWN_VLAN_MEMBER,
+			     CPSW_MASK_ALL_PORTS);
+
+	cpsw_ale_control_set(priv->ale, 0,
+			     ALE_PORT_UNKNOWN_MCAST_FLOOD,
+			     CPSW_MASK_PHYS_PORTS);
+
+	cpsw_ale_control_set(priv->ale, 0,
+			     ALE_PORT_UNKNOWN_REG_MCAST_FLOOD,
+			     CPSW_MASK_ALL_PORTS);
+
+	cpsw_ale_control_set(priv->ale, 0,
+			     ALE_PORT_UNTAGGED_EGRESS,
+			     CPSW_MASK_ALL_PORTS);
+}
+
+static void cpsw_slave_init(struct cpsw_slave *slave, struct cpsw_priv *priv)
+{
+	void __iomem		*regs = priv->ss_regs;
+	int			slave_num = slave->slave_num;
+
+	slave->regs	= regs + priv->slave_reg_ofs + (0x30 * slave_num);
+	slave->sliver	= regs + priv->sliver_reg_ofs + (0x40 * slave_num);
+}
+
+static void cpsw_add_mcast_addr(struct cpsw_intf *cpsw_intf, u8 *addr)
+{
+	struct cpsw_priv *cpsw_dev = cpsw_intf->cpsw_priv;
+	u16 vlan_id;
+
+	cpsw_ale_add_mcast(cpsw_dev->ale, addr, CPSW_MASK_ALL_PORTS, 0,
+			   ALE_MCAST_FWD_2, -1);
+	for_each_set_bit(vlan_id, cpsw_intf->active_vlans, VLAN_N_VID) {
+		cpsw_ale_add_mcast(cpsw_dev->ale, addr, CPSW_MASK_ALL_PORTS, 0,
+				   ALE_MCAST_FWD_2, vlan_id);
+	}
+}
+
+static void cpsw_add_ucast_addr(struct cpsw_intf *cpsw_intf, u8 *addr)
+{
+	struct cpsw_priv *cpsw_dev = cpsw_intf->cpsw_priv;
+	u16 vlan_id;
+
+	cpsw_ale_add_ucast(cpsw_dev->ale, addr, cpsw_dev->host_port, 0, -1);
+
+	for_each_set_bit(vlan_id, cpsw_intf->active_vlans, VLAN_N_VID)
+		cpsw_ale_add_ucast(cpsw_dev->ale, addr, cpsw_dev->host_port, 0,
+				   vlan_id);
+}
+
+static void cpsw_del_mcast_addr(struct cpsw_intf *cpsw_intf, u8 *addr)
+{
+	struct cpsw_priv *cpsw_dev = cpsw_intf->cpsw_priv;
+	u16 vlan_id;
+
+	cpsw_ale_del_mcast(cpsw_dev->ale, addr, CPSW_MASK_ALL_PORTS, -1);
+
+	for_each_set_bit(vlan_id, cpsw_intf->active_vlans, VLAN_N_VID) {
+		cpsw_ale_del_mcast(cpsw_dev->ale, addr, CPSW_MASK_ALL_PORTS,
+				   vlan_id);
+	}
+}
+
+static void cpsw_del_ucast_addr(struct cpsw_intf *cpsw_intf, u8 *addr)
+{
+	struct cpsw_priv *cpsw_dev = cpsw_intf->cpsw_priv;
+	u16 vlan_id;
+
+	cpsw_ale_del_ucast(cpsw_dev->ale, addr, cpsw_dev->host_port, -1);
+
+	for_each_set_bit(vlan_id, cpsw_intf->active_vlans, VLAN_N_VID) {
+		cpsw_ale_del_ucast(cpsw_dev->ale, addr, cpsw_dev->host_port,
+				   vlan_id);
+	}
+}
+
+int cpsw_add_addr(void *intf_priv, struct netcp_addr *naddr)
+{
+	struct cpsw_intf *cpsw_intf = intf_priv;
+	struct cpsw_priv *cpsw_dev = cpsw_intf->cpsw_priv;
+
+	dev_dbg(cpsw_dev->dev, "ethss adding address %pM, type %d\n",
+		naddr->addr, naddr->type);
+
+	switch (naddr->type) {
+	case ADDR_MCAST:
+	case ADDR_BCAST:
+		cpsw_add_mcast_addr(cpsw_intf, naddr->addr);
+		break;
+	case ADDR_UCAST:
+	case ADDR_DEV:
+		cpsw_add_ucast_addr(cpsw_intf, naddr->addr);
+		break;
+	case ADDR_ANY:
+		/* nothing to do for promiscuous */
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+int cpsw_del_addr(void *intf_priv, struct netcp_addr *naddr)
+{
+	struct cpsw_intf *cpsw_intf = intf_priv;
+	struct cpsw_priv *cpsw_dev = cpsw_intf->cpsw_priv;
+
+	dev_dbg(cpsw_dev->dev, "ethss deleting address %pM, type %d\n",
+		naddr->addr, naddr->type);
+
+	switch (naddr->type) {
+	case ADDR_MCAST:
+	case ADDR_BCAST:
+		cpsw_del_mcast_addr(cpsw_intf, naddr->addr);
+		break;
+	case ADDR_UCAST:
+	case ADDR_DEV:
+		cpsw_del_ucast_addr(cpsw_intf, naddr->addr);
+		break;
+	case ADDR_ANY:
+		/* nothing to do for promiscuous */
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+int cpsw_add_vid(void *intf_priv, int vid)
+{
+	struct cpsw_intf *cpsw_intf = intf_priv;
+	struct cpsw_priv *cpsw_dev = cpsw_intf->cpsw_priv;
+
+	set_bit(vid, cpsw_intf->active_vlans);
+
+	cpsw_ale_add_vlan(cpsw_dev->ale, vid, CPSW_MASK_ALL_PORTS,
+			  CPSW_MASK_ALL_PORTS, CPSW_MASK_PHYS_PORTS,
+			  CPSW_MASK_NO_PORTS);
+
+	return 0;
+}
+
+int cpsw_del_vid(void *intf_priv, int vid)
+{
+	struct cpsw_intf *cpsw_intf = intf_priv;
+	struct cpsw_priv *cpsw_dev = cpsw_intf->cpsw_priv;
+
+	cpsw_ale_del_vlan(cpsw_dev->ale, vid);
+
+	clear_bit(vid, cpsw_intf->active_vlans);
+
+	return 0;
+}
+
+int cpsw_ioctl(void *intf_priv, struct ifreq *req, int cmd)
+{
+	struct cpsw_intf *cpsw_intf = intf_priv;
+	struct cpsw_slave *slave = cpsw_intf->slaves;
+	struct phy_device *phy = slave->phy;
+	int ret;
+
+	if (!phy)
+		return -EOPNOTSUPP;
+
+	ret = phy_mii_ioctl(phy, req, cmd);
+	if ((cmd == SIOCSHWTSTAMP) && (ret == -ERANGE))
+		ret = -EOPNOTSUPP;
+
+	return ret;
+}
+
+static void cpsw_timer(unsigned long arg)
+{
+	struct cpsw_intf *cpsw_intf = (struct cpsw_intf *)arg;
+	struct cpsw_priv *cpsw_dev = cpsw_intf->cpsw_priv;
+	
+	if (cpsw_dev->multi_if)
+		cpsw_intf->sgmii_link =
+			keystone_sgmii_get_port_link(cpsw_dev->sgmii_port_regs,
+						     cpsw_intf->slave_port);
+	else
+		cpsw_intf->sgmii_link =
+			keystone_sgmii_link_status(cpsw_dev->sgmii_port_regs,
+						   cpsw_intf->num_slaves);
+
+	for_each_slave(cpsw_intf, cpsw_slave_link, cpsw_intf);
+
+	/* FIXME: Don't aggregate link statuses in multi-interface case */
+	if (cpsw_intf->sgmii_link) {
+		/* link ON */
+		if (!netif_carrier_ok(cpsw_intf->ndev))
+			netif_carrier_on(cpsw_intf->ndev);
+		/*
+		 * reactivate the transmit queue if
+		 * it is stopped
+		 */
+		if (netif_running(cpsw_intf->ndev) &&
+		    netif_queue_stopped(cpsw_intf->ndev))
+			netif_wake_queue(cpsw_intf->ndev);
+	} else {
+		/* link OFF */
+		if (netif_carrier_ok(cpsw_intf->ndev))
+			netif_carrier_off(cpsw_intf->ndev);
+		if (!netif_queue_stopped(cpsw_intf->ndev))
+			netif_stop_queue(cpsw_intf->ndev);
+	}
+
+	mutex_lock(&cpsw_dev->hw_stats_lock);
+	cpsw_update_stats(cpsw_dev, NULL);
+	mutex_unlock(&cpsw_dev->hw_stats_lock);
+
+	cpsw_intf->timer.expires = jiffies + (HZ/10);
+	add_timer(&cpsw_intf->timer);
+
+	return;
+}
+
+static int cpsw_tx_hook(int order, void *data, struct netcp_packet *p_info)
+{
+	struct cpsw_intf *cpsw_intf = data;
+
+	p_info->tx_pipe = &cpsw_intf->tx_pipe;
+	return 0;
+}
+
+#define	CPSW_TXHOOK_ORDER	0
+
+static int cpsw_open(void *intf_priv, struct net_device *ndev)
+{
+	struct cpsw_intf *cpsw_intf = intf_priv;
+	struct cpsw_priv *cpsw_dev = cpsw_intf->cpsw_priv;
+	struct netcp_priv *netcp = netdev_priv(ndev);
+	struct cpsw_ale_params ale_params;
+	int ret = 0;
+	u32 reg;
+
+	cpsw_dev->cpgmac = clk_get(cpsw_dev->dev, "clk_cpgmac");
+	if (IS_ERR(cpsw_dev->cpgmac)) {
+		ret = PTR_ERR(cpsw_dev->cpgmac);
+		cpsw_dev->cpgmac = NULL;
+		dev_err(cpsw_dev->dev, "unable to get Keystone CPGMAC"
+			" clock: %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(cpsw_dev->cpgmac);
+	if (ret)
+		goto clk_fail;
+
+	reg = __raw_readl(&cpsw_dev->regs->id_ver);
+
+	dev_info(cpsw_dev->dev, "initializing cpsw version %d.%d (%d) "
+		 "SGMII identification value 0x%x\n",
+		 CPSW_MAJOR_VERSION(reg), CPSW_MINOR_VERSION(reg),
+		 CPSW_RTL_VERSION(reg), CPSW_SGMII_IDENT(reg));
+
+	ret = netcp_txpipe_open(&cpsw_intf->tx_pipe);
+	if (ret)
+		goto txpipe_fail;
+
+	dev_dbg(cpsw_dev->dev, "opened TX channel %s: %p with psflags %d\n",
+		cpsw_intf->tx_pipe.dma_chan_name,
+		cpsw_intf->tx_pipe.dma_channel,
+		cpsw_intf->tx_pipe.dma_psflags);
+
+	cpsw_dev->ale_refcnt++;
+	if (cpsw_dev->ale_refcnt == 1) {
+		memset(&ale_params, 0, sizeof(ale_params));
+
+		ale_params.dev			= cpsw_dev->dev;
+		ale_params.ale_regs		= (void *)((u32)priv->ale_reg);
+		ale_params.ale_ageout		= cpsw_dev->ale_ageout;
+		ale_params.ale_entries		= cpsw_dev->ale_entries;
+		ale_params.ale_ports		= cpsw_dev->ale_ports;
+
+		cpsw_dev->ale = cpsw_ale_create(&ale_params);
+		if (!cpsw_dev->ale) {
+			dev_err(cpsw_dev->dev, "error initializing ale engine\n");
+			ret = -ENODEV;
+			goto ale_fail;
+		} else
+			dev_info(cpsw_dev->dev, "Created a cpsw ale engine\n");
+	}
+
+	for_each_slave(cpsw_intf, cpsw_slave_init, cpsw_dev);
+
+	for_each_slave(cpsw_intf, cpsw_slave_stop, cpsw_dev);
+
+	/* Serdes init */
+	if (cpsw_dev->init_serdes_at_probe == 0) {
+		serdes_init();
+	}
+
+	/* initialize host and slave ports */
+	cpsw_init_host_port(cpsw_dev, cpsw_intf);
+
+	/* disable priority elevation and enable statistics on all ports */
+	__raw_writel(0, &cpsw_dev->regs->ptype);
+
+	/* Control register */
+	__raw_writel(CPSW_CTL_P0_ENABLE, &cpsw_dev->regs->control);
+
+	/* All statistics enabled by default */
+	__raw_writel(CPSW_REG_VAL_STAT_ENABLE_ALL,
+		     &cpsw_dev->regs->stat_port_en);
+
+	for_each_slave(cpsw_intf, cpsw_slave_open, cpsw_intf);
+
+	init_timer(&cpsw_intf->timer);
+	cpsw_intf->timer.data		= (unsigned long)cpsw_intf;
+	cpsw_intf->timer.function	= cpsw_timer;
+	cpsw_intf->timer.expires	= jiffies + CPSW_TIMER_INTERVAL;
+	add_timer(&cpsw_intf->timer);
+	dev_dbg(cpsw_dev->dev, "%s(): cpsw_timer = %p\n", __func__, cpsw_timer);
+
+	netcp_register_txhook(netcp, CPSW_TXHOOK_ORDER,
+			      cpsw_tx_hook, cpsw_intf);
+
+	/* Configure the streaming switch */
+#define	PSTREAM_ROUTE_DMA	6
+	netcp_set_streaming_switch(cpsw_dev->netcp_device, netcp->cpsw_port,
+				   PSTREAM_ROUTE_DMA);
+
+	return 0;
+
+ale_fail:
+	netcp_txpipe_close(&cpsw_intf->tx_pipe);
+txpipe_fail:
+	clk_disable_unprepare(cpsw_dev->cpgmac);
+clk_fail:
+	clk_put(cpsw_dev->cpgmac);
+	cpsw_dev->cpgmac = NULL;
+	return ret;
+}
+
+static int cpsw_close(void *intf_priv, struct net_device *ndev)
+{
+	struct cpsw_intf *cpsw_intf = intf_priv;
+	struct cpsw_priv *cpsw_dev = cpsw_intf->cpsw_priv;
+	struct netcp_priv *netcp = netdev_priv(ndev);
+
+	del_timer_sync(&cpsw_intf->timer);
+
+	cpsw_dev->ale_refcnt--;
+	if (!cpsw_dev->ale_refcnt)
+		cpsw_ale_stop(cpsw_dev->ale);
+	
+	for_each_slave(cpsw_intf, cpsw_slave_stop, cpsw_dev);
+
+	if (!cpsw_dev->ale_refcnt)
+		cpsw_ale_destroy(cpsw_dev->ale);
+
+	netcp_unregister_txhook(netcp, CPSW_TXHOOK_ORDER, cpsw_tx_hook,
+				cpsw_intf);
+	netcp_txpipe_close(&cpsw_intf->tx_pipe);
+
+	clk_disable_unprepare(cpsw_dev->cpgmac);
+	clk_put(cpsw_dev->cpgmac);
+
+	return 0;
+}
+
+static int cpsw_remove(struct netcp_device *netcp_device, void *inst_priv)
+{
+	struct cpsw_priv *cpsw_dev = inst_priv;
+	struct cpsw_intf *cpsw_intf, *tmp;
+
+	of_node_put(cpsw_dev->interfaces);
+
+	list_for_each_entry_safe(cpsw_intf, tmp, &cpsw_dev->cpsw_intf_head,
+				 cpsw_intf_list) {
+		netcp_delete_interface(netcp_device, cpsw_intf->ndev);
+	}
+	BUG_ON(!list_empty(&cpsw_dev->cpsw_intf_head));
+
+	iounmap(cpsw_dev->ss_regs);
+	memset(cpsw_dev, 0x00, sizeof(*cpsw_dev));	/* FIXME: Poison */
+	kfree(cpsw_dev);
+	return 0;
+}
+
+static int init_slave(struct cpsw_priv *cpsw_dev,
+		      struct device_node *node, int slave_num)
+{
+	int ret = 0;
+
+	ret = of_property_read_u32(node, "link-interface",
+				   &cpsw_dev->link[slave_num]);
+	if (ret < 0) {
+		dev_err(cpsw_dev->dev,
+			"missing link-interface value"
+			"defaulting to mac-phy link\n");
+		cpsw_dev->link[slave_num] = 1;
+	}
+
+	cpsw_dev->phy_node[slave_num] = of_parse_phandle(node, "phy-handle", 0);
+
+	return 0;
+}
+
+static int cpsw_create_sysfs_entries(struct cpsw_priv *cpsw_dev)
+{
+	struct device *dev = cpsw_dev->dev;
+	int ret;
+
+	ret = kobject_init_and_add(&cpsw_dev->kobj, &cpsw_ktype,
+		kobject_get(&dev->kobj), "cpsw");
+
+	if (ret) {
+		dev_err(dev, "failed to create cpsw sysfs entry\n");
+		kobject_put(&cpsw_dev->kobj);
+		kobject_put(&dev->kobj);
+		return ret;
+	}
+
+	ret = kobject_init_and_add(&cpsw_dev->tx_pri_kobj,
+		&cpsw_tx_pri_ktype,
+		kobject_get(&cpsw_dev->kobj), "port_tx_pri_map");
+
+	if (ret) {
+		dev_err(dev, "failed to create sysfs port_tx_pri_map entry\n");
+		kobject_put(&cpsw_dev->tx_pri_kobj);
+		kobject_put(&cpsw_dev->kobj);
+		return ret;
+	}
+
+	ret = kobject_init_and_add(&cpsw_dev->pvlan_kobj,
+		&cpsw_pvlan_ktype,
+		kobject_get(&cpsw_dev->kobj), "port_vlan");
+
+	if (ret) {
+		dev_err(dev, "failed to create sysfs port_vlan entry\n");
+		kobject_put(&cpsw_dev->pvlan_kobj);
+		kobject_put(&cpsw_dev->kobj);
+		return ret;
+	}
+
+	ret = kobject_init_and_add(&cpsw_dev->stats_kobj,
+		&cpsw_stats_ktype,
+		kobject_get(&cpsw_dev->kobj), "stats");
+
+	if (ret) {
+		dev_err(dev, "failed to create sysfs stats entry\n");
+		kobject_put(&cpsw_dev->stats_kobj);
+		kobject_put(&cpsw_dev->kobj);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int cpsw_probe(struct netcp_device *netcp_device,
+			struct device *dev,
+			struct device_node *node,
+			void **inst_priv)
+{
+	struct cpsw_priv *cpsw_dev;
+	struct device_node *slaves, *slave, *interfaces;
+	void __iomem *regs;
+	struct net_device *ndev;
+	int slave_num = 0;
+	int i, ret = 0;
+
+	cpsw_dev = devm_kzalloc(dev, sizeof(struct cpsw_priv), GFP_KERNEL);
+	if (!cpsw_dev) {
+		dev_err(dev, "cpsw_dev memory allocation failed\n");
+		return -ENOMEM;
+	}
+	*inst_priv = cpsw_dev;
+	dev_dbg(dev, "%s(): cpsw_priv = %p\n", __func__, cpsw_dev);
+
+	if (!node) {
+		dev_err(dev, "device tree info unavailable\n");
+		ret = -ENODEV;
+		goto exit;
+	}
+
+	cpsw_dev->dev = dev;
+	cpsw_dev->netcp_device = netcp_device;
+	
+	priv = cpsw_dev;	/* FIXME: Remove this!! */
+
+	regs = ioremap(TCI6614_SS_BASE, 0xf00);
+	BUG_ON(!regs);
+
+	ret = of_property_read_u32(node, "serdes_at_probe", &cpsw_dev->init_serdes_at_probe);
+	if (ret < 0) {
+		dev_err(dev, "missing serdes_at_probe parameter, err %d\n", ret);
+		cpsw_dev->init_serdes_at_probe = 0;
+	}
+	dev_dbg(dev, "serdes_at_probe %u\n", cpsw_dev->init_serdes_at_probe);
+#if 0
+	if (cpsw_dev->init_serdes_at_probe == 1) {
+		serdes_init_6638_156p25Mhz();
+	}
+#endif
+	ret = of_property_read_u32(node, "sgmii_module_ofs",
+				   &cpsw_dev->sgmii_module_ofs);
+	if (ret < 0)
+		dev_err(dev, "missing sgmii module offset, err %d\n", ret);
+	
+	ret = of_property_read_u32(node, "switch_module_ofs",
+				   &cpsw_dev->switch_module_ofs);
+	if (ret < 0)
+		dev_err(dev, "missing switch module offset, err %d\n", ret);
+
+	ret = of_property_read_u32(node, "host_port_reg_ofs",
+				   &cpsw_dev->host_port_reg_ofs);
+	if (ret < 0)
+		dev_err(dev, "missing host port reg offset, err %d\n", ret);
+
+	ret = of_property_read_u32(node, "slave_reg_ofs",
+				   &cpsw_dev->slave_reg_ofs);
+	if (ret < 0)
+		dev_err(dev, "missing slave reg offset, err %d\n", ret);
+
+	ret = of_property_read_u32(node, "sliver_reg_ofs",
+				   &cpsw_dev->sliver_reg_ofs);
+	if (ret < 0)
+		dev_err(dev, "missing sliver reg offset, err %d\n", ret);
+
+	ret = of_property_read_u32(node, "hw_stats_reg_ofs",
+				   &cpsw_dev->hw_stats_reg_ofs);
+	if (ret < 0)
+		dev_err(dev, "missing hw stats reg offset, err %d\n", ret);
+
+	ret = of_property_read_u32(node, "ale_reg_ofs",
+				   &cpsw_dev->ale_reg_ofs);
+	if (ret < 0)
+		dev_err(dev, "missing ale reg offset, err %d\n", ret);
+
+
+	ret = of_property_read_u32(node, "num_slaves", &cpsw_dev->num_slaves);
+	if (ret < 0) {
+		dev_err(dev, "missing num_slaves parameter, err %d\n", ret);
+		cpsw_dev->num_slaves = 2;
+	}
+
+	ret = of_property_read_u32(node, "ale_ageout", &cpsw_dev->ale_ageout);
+	if (ret < 0) {
+		dev_err(dev, "missing ale_ageout parameter, err %d\n", ret);
+		cpsw_dev->ale_ageout = 10;
+	}
+
+	ret = of_property_read_u32(node, "ale_entries", &cpsw_dev->ale_entries);
+	if (ret < 0) {
+		dev_err(dev, "missing ale_entries parameter, err %d\n", ret);
+		cpsw_dev->ale_entries = 1024;
+	}
+
+	ret = of_property_read_u32(node, "ale_ports", &cpsw_dev->ale_ports);
+	if (ret < 0) {
+		dev_err(dev, "missing ale_ports parameter, err %d\n", ret);
+		cpsw_dev->ale_ports = 2;
+	}
+
+	ret = of_property_read_u32(node, "intf_tx_queues", &cpsw_dev->intf_tx_queues);
+	if (ret < 0) {
+		dev_err(dev, "missing intf_tx_queues parameter, err %d\n", ret);
+		cpsw_dev->intf_tx_queues = 1;
+	}
+
+	if (of_find_property(node, "multi-interface", NULL))
+		cpsw_dev->multi_if = 1;
+
+	ret = of_property_read_u32(node, "num-interfaces",
+				   &cpsw_dev->num_interfaces);
+	if (ret < 0) {
+		dev_err(dev, "missing num-interfaces parameter\n");
+		cpsw_dev->num_interfaces = 1;
+	}
+
+	ret = of_property_read_u32(node, "slaves-per-interface",
+				   &cpsw_dev->slaves_per_interface);
+	if (ret < 0) {
+		dev_err(dev, "missing slaves-per_interface parameter\n");
+		cpsw_dev->slaves_per_interface = 2;
+	}
+
+	/* FIXME: TCI6614_SS_BASE needs to come from the device tree */
+	regs = ioremap(TCI6614_SS_BASE, 0xf00);
+	BUG_ON(!regs);
+
+	cpsw_dev->ss_regs = regs;
+	cpsw_dev->sgmii_port_regs	= regs + cpsw_dev->sgmii_module_ofs;
+	cpsw_dev->regs = regs + cpsw_dev->switch_module_ofs;
+	cpsw_dev->host_port_regs = regs + cpsw_dev->host_port_reg_ofs;
+	cpsw_dev->hw_stats_regs[0] = regs + cpsw_dev->hw_stats_reg_ofs;
+	cpsw_dev->hw_stats_regs[1] = regs + cpsw_dev->hw_stats_reg_ofs + 0x100;
+	cpsw_dev->ale_reg	  = regs + cpsw_dev->ale_reg_ofs;
+
+	cpsw_dev->host_port = 0;
+	cpsw_dev->rx_packet_max = 9500;
+
+	dev_dbg(dev, "num_slaves = %d\n", cpsw_dev->num_slaves);
+	dev_dbg(dev, "ale_ageout = %d\n", cpsw_dev->ale_ageout);
+	dev_dbg(dev, "ale_entries = %d\n", cpsw_dev->ale_entries);
+	dev_dbg(dev, "ale_ports = %d\n", cpsw_dev->ale_ports);
+
+	slaves = of_get_child_by_name(node, "slaves");
+	if (!slaves) {
+		dev_err(dev, "could not find slaves\n");
+		ret = -ENODEV;
+		goto exit;
+	}
+
+	for_each_child_of_node(slaves, slave) {
+			init_slave(cpsw_dev, slave, slave_num);
+			slave_num++;
+	}
+
+	of_node_put(slaves);
+
+	interfaces = of_get_child_by_name(node, "interfaces");
+	if (!interfaces)
+		dev_err(dev, "could not find interfaces\n");
+
+	cpsw_dev->interfaces = interfaces;
+
+	/* Create the interface */
+	INIT_LIST_HEAD(&cpsw_dev->cpsw_intf_head);
+	if (cpsw_dev->multi_if)
+		for (i = 0; i < cpsw_dev->num_interfaces; i++)
+			netcp_create_interface(netcp_device, &ndev,
+					       NULL, cpsw_dev->intf_tx_queues,
+					       1, (i + 1));
+	else
+		netcp_create_interface(netcp_device, &ndev,
+					       NULL, cpsw_dev->intf_tx_queues,
+					       1, 0);
+	/* init the hw stats lock */
+	mutex_init(&cpsw_dev->hw_stats_lock);
+
+	ret = cpsw_create_sysfs_entries(cpsw_dev);
+	if (ret)
+		goto exit;
+
+	return 0;
+
+exit:
+	if (cpsw_dev->ss_regs)
+		iounmap(cpsw_dev->ss_regs);
+	*inst_priv = NULL;
+	kfree(cpsw_dev);
+	return ret;
+}
+
+static int cpsw_attach(void *inst_priv, struct net_device *ndev,
+		       void **intf_priv)
+{
+	struct cpsw_priv *cpsw_dev = inst_priv;
+	struct cpsw_intf *cpsw_intf;
+	struct netcp_priv *netcp = netdev_priv(ndev);
+	struct device_node *interface;
+	int i = 0, ret = 0;
+	char node_name[24];
+
+	cpsw_intf = devm_kzalloc(cpsw_dev->dev,
+				 sizeof(struct cpsw_intf), GFP_KERNEL);
+	if (!cpsw_intf) {
+		dev_err(cpsw_dev->dev, "cpsw interface memory "
+			"allocation failed\n");
+		return -ENOMEM;
+	}
+	cpsw_intf->ndev = ndev;
+	cpsw_intf->dev = cpsw_dev->dev;
+	cpsw_intf->cpsw_priv = cpsw_dev;
+	cpsw_intf->multi_if = cpsw_dev->multi_if;
+
+	if (cpsw_dev->multi_if)
+		snprintf(node_name, sizeof(node_name), "interface-%d",
+			 netcp->cpsw_port - 1);
+	else
+		snprintf(node_name, sizeof(node_name), "interface-%d",
+			 0);
+
+	interface = of_get_child_by_name(cpsw_dev->interfaces, node_name);
+	if (!interface) {
+		dev_err(cpsw_dev->dev, "interface data not available\n");
+		devm_kfree(cpsw_dev->dev, cpsw_intf);
+		return -ENODEV;
+	}
+	ret = of_property_read_u32(interface, "slave_port",
+				   &cpsw_intf->slave_port);
+	if (ret < 0) {
+		dev_err(cpsw_dev->dev, "missing slave_port paramater\n");
+		return -EINVAL;
+	}
+
+	ret = of_property_read_string(interface, "tx-channel",
+				      &cpsw_intf->tx_chan_name);
+	if (ret < 0) {
+		dev_err(cpsw_dev->dev, "missing tx-channel "
+			"parameter, err %d\n", ret);
+		cpsw_intf->tx_chan_name = "nettx";
+	}
+	dev_info(cpsw_dev->dev, "dma_chan_name %s\n", cpsw_intf->tx_chan_name);
+
+	ret = of_property_read_u32(interface, "tx_queue_depth",
+				   &cpsw_intf->tx_queue_depth);
+	if (ret < 0) {
+		dev_err(cpsw_dev->dev, "missing tx_queue_depth "
+			"parameter, err %d\n", ret);
+		cpsw_intf->tx_queue_depth = 32;
+	}
+	dev_dbg(cpsw_dev->dev, "tx_queue_depth %u\n",
+		cpsw_intf->tx_queue_depth);
+
+	of_node_put(interface);
+
+	cpsw_intf->num_slaves = cpsw_dev->slaves_per_interface;
+
+	cpsw_intf->slaves = devm_kzalloc(cpsw_dev->dev,
+					 sizeof(struct cpsw_slave) *
+					 cpsw_intf->num_slaves, GFP_KERNEL);
+
+	if (!cpsw_intf->slaves) {
+		dev_err(cpsw_dev->dev, "cpsw interface slave memory "
+			"allocation failed\n");
+		devm_kfree(cpsw_dev->dev, cpsw_intf);
+		return -ENOMEM;
+	}
+
+	if (cpsw_dev->multi_if) {
+		cpsw_intf->slaves[i].slave_num = cpsw_intf->slave_port;
+		cpsw_intf->slaves[i].link_interface =
+			cpsw_dev->link[cpsw_intf->slave_port];
+		cpsw_intf->phy_node = cpsw_dev->phy_node[cpsw_intf->slave_port];
+	} else {
+		for (i = 0; i < cpsw_intf->num_slaves; i++) {
+			cpsw_intf->slaves[i].slave_num = i;
+			cpsw_intf->slaves[i].link_interface = cpsw_dev->link[i];
+		}
+	}
+
+	netcp_txpipe_init(&cpsw_intf->tx_pipe, netdev_priv(ndev),
+			  cpsw_intf->tx_chan_name, cpsw_intf->tx_queue_depth);
+
+	cpsw_intf->tx_pipe.dma_psflags	= netcp->cpsw_port;
+
+	SET_ETHTOOL_OPS(ndev, &keystone_ethtool_ops);
+
+	list_add(&cpsw_intf->cpsw_intf_list, &cpsw_dev->cpsw_intf_head);
+
+	*intf_priv = cpsw_intf;
+	return 0;
+}
+
+static int cpsw_release(void *intf_priv)
+{
+	struct cpsw_intf *cpsw_intf = intf_priv;
+
+	SET_ETHTOOL_OPS(cpsw_intf->ndev, NULL);
+
+	list_del(&cpsw_intf->cpsw_intf_list);
+
+	devm_kfree(cpsw_intf->dev, cpsw_intf->slaves);
+	devm_kfree(cpsw_intf->dev, cpsw_intf);
+
+	return 0;
+}
+
+
+static struct netcp_module cpsw_module = {
+	.name		= "keystone-cpsw",
+	.owner		= THIS_MODULE,
+	.probe		= cpsw_probe,
+	.open		= cpsw_open,
+	.close		= cpsw_close,
+	.remove		= cpsw_remove,
+	.attach		= cpsw_attach,
+	.release	= cpsw_release,
+	.add_addr	= cpsw_add_addr,
+	.del_addr	= cpsw_del_addr,
+	.add_vid	= cpsw_add_vid,
+	.del_vid	= cpsw_del_vid,
+	.ioctl		= cpsw_ioctl,
+};
+
+int __init keystone_cpsw_init(void)
+{
+	return netcp_register_module(&cpsw_module);
+}
+//module_init(keystone_cpsw_init);
+
+void __exit keystone_cpsw_exit(void)
+{
+	netcp_unregister_module(&cpsw_module);
+}
+//module_exit(keystone_cpsw_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Sandeep Paulraj <s-paulraj@ti.com>");
+MODULE_DESCRIPTION("CPSW driver for Keystone devices");
diff --git a/drivers/net/ethernet/ti/keystone_net.h b/drivers/net/ethernet/ti/keystone_net.h
new file mode 100644
index 0000000..f369b24
--- /dev/null
+++ b/drivers/net/ethernet/ti/keystone_net.h
@@ -0,0 +1,224 @@
+/*
+ * Copyright (C) 2012 Texas Instruments
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef __KEYSTONE_NECTP_H__
+#define __KEYSTONE_NECTP_H__
+
+#include <linux/skbuff.h>
+#include <linux/if_vlan.h>
+#include <linux/ethtool.h>
+#include <linux/if_ether.h>
+#include <linux/netdevice.h>
+#include <linux/keystone-dma.h>
+#include <linux/interrupt.h>
+
+/* Maximum Ethernet frame size supported by Keystone switch */
+#define NETCP_MAX_FRAME_SIZE	9504
+#define NETCP_MAX_MCAST_ADDR	16
+
+#define SGMII_LINK_MAC_MAC_AUTONEG	0
+#define SGMII_LINK_MAC_PHY		1
+#define SGMII_LINK_MAC_MAC_FORCED	2
+#define SGMII_LINK_MAC_FIBER		3
+#define SGMII_LINK_MAC_PHY_NO_MDIO	4
+#define XGMII_LINK_MAC_PHY		10
+#define XGMII_LINK_MAC_MAC_FORCED	11
+
+int serdes_init(void);
+void serdes_init_6638_156p25Mhz(void);
+int keystone_sgmii_reset(void __iomem *sgmii_ofs, int port);
+int keystone_sgmii_link_status(void __iomem *sgmii_ofs, int ports);
+int keystone_sgmii_get_port_link(void __iomem *sgmii_ofs, int port);
+int keystone_sgmii_config(void __iomem *sgmii_ofs,
+			  int port, u32 interface);
+
+struct netcp_device;
+
+enum netcp_rx_state {
+	RX_STATE_INTERRUPT,
+	RX_STATE_SCHEDULED,
+	RX_STATE_POLL,
+	RX_STATE_TEARDOWN,
+	RX_STATE_INVALID,
+};
+
+enum netcp_tx_state {
+	TX_STATE_INVALID,
+	TX_STATE_INTERRUPT,
+	TX_STATE_SCHEDULED,
+	TX_STATE_POLL,
+};
+
+struct netcp_tx_pipe {
+	struct netcp_priv		*netcp_priv;
+	struct dma_chan			*dma_channel;
+	const char			*dma_chan_name;
+	u8				 dma_psflags;
+	u8				 filler1;
+	u16				 dma_queue;
+	unsigned int			 dma_queue_depth;
+	unsigned int			 dma_poll_threshold;
+	unsigned int			 dma_pause_threshold;
+	unsigned int			 dma_resume_threshold;
+	atomic_t			 dma_poll_count;
+	struct tasklet_struct		 dma_poll_tasklet;
+	enum netcp_tx_state		 dma_poll_state;
+};
+
+#define ADDR_NEW	BIT(0)
+#define ADDR_VALID	BIT(1)
+
+enum netcp_addr_type {
+	ADDR_ANY,
+	ADDR_DEV,
+	ADDR_UCAST,
+	ADDR_MCAST,
+	ADDR_BCAST
+};
+
+struct netcp_addr {
+	struct netcp_priv	*netcp;
+	unsigned char		 addr[MAX_ADDR_LEN];
+	enum netcp_addr_type	 type;
+	unsigned int		 flags;
+	struct list_head	 node;
+};
+
+struct netcp_priv {
+	spinlock_t			 lock;
+	struct netcp_device		*netcp_device;
+	struct platform_device		*pdev;
+	struct net_device		*ndev;
+	struct napi_struct		 napi;
+	struct device			*dev;
+	int				 cpsw_port;
+	u32				 msg_enable;
+	struct net_device_stats		 stats;
+	int				 rx_packet_max;
+
+	struct dma_chan			*rx_channel;
+	const char			*rx_chan_name;
+
+	u32				 link_state;
+
+	enum netcp_rx_state		 rx_state;
+	struct list_head		 module_head;
+	struct list_head		 interface_list;
+	struct list_head		 txhook_list_head;
+	struct list_head		 rxhook_list_head;
+	struct list_head		 addr_list;
+
+	/* PktDMA configuration data */
+	u32				 rx_queue_depths[KEYSTONE_QUEUES_PER_CHAN];
+	u32				 rx_buffer_sizes[KEYSTONE_QUEUES_PER_CHAN];
+};
+
+#define NETCP_SGLIST_SIZE	(MAX_SKB_FRAGS + 2)
+#define	NETCP_PSDATA_LEN	16
+struct netcp_packet {
+	struct scatterlist		 sg[NETCP_SGLIST_SIZE];
+	int				 sg_ents;
+	struct sk_buff			*skb;
+	u32				 epib[4];
+	u32				 psdata[NETCP_PSDATA_LEN];
+	unsigned int			 psdata_len;
+	struct netcp_priv		*netcp;
+	dma_cookie_t			 cookie;
+	struct netcp_tx_pipe		*tx_pipe;
+};
+
+static inline int netcp_prepend_psdata(struct netcp_packet *p_info, u32 *data, unsigned len)
+{
+	if ((len + p_info->psdata_len) > NETCP_PSDATA_LEN)
+		return -ENOBUFS;
+	p_info->psdata_len += len;
+
+	memcpy(&p_info->psdata[NETCP_PSDATA_LEN - p_info->psdata_len],
+			data, len * sizeof(u32));
+	return 0;
+}
+
+struct netcp_module {
+	const char		*name;
+	struct module		*owner;
+	struct list_head	 module_list;
+	struct list_head	 interface_list;
+
+	/* probe/remove: called once per NETCP instance */
+	int			(*probe)(struct netcp_device *netcp_device,
+					 struct device *device,
+					 struct device_node *node,
+					 void **inst_priv);
+	int			(*remove)(struct netcp_device *netcp_device,
+					  void *inst_priv);
+
+	/* attach/release: called once per network interface */
+	int			(*attach)(void *inst_priv, struct net_device *ndev,
+					  void **intf_priv);
+	int			(*release)(void *intf_priv);
+
+	int			(*open)(void *intf_priv, struct net_device *ndev);
+	int			(*close)(void *intf_priv, struct net_device *ndev);
+	int			(*add_addr)(void *intf_priv,
+					    struct netcp_addr *naddr);
+	int			(*del_addr)(void *intf_priv,
+					    struct netcp_addr *naddr);
+	int			(*add_vid)(void *intf_priv, int vid);
+	int			(*del_vid)(void *intf_priv, int vid);
+	int			(*ioctl)(void *intf_priv, struct ifreq *req,
+					 int cmd);
+};
+
+int netcp_register_module(struct netcp_module *module);
+void netcp_unregister_module(struct netcp_module *module);
+
+u32 netcp_get_streaming_switch(struct netcp_device *netcp_device, int port);
+u32 netcp_set_streaming_switch(struct netcp_device *netcp_device,
+				int port, u32 new_value);
+
+int netcp_create_interface(struct netcp_device *netcp_device,
+			   struct net_device **ndev_p,
+			   const char *ifname_proto,
+			   int tx_queues, int rx_queues,
+			   int cpsw_port);
+void netcp_delete_interface(struct netcp_device *netcp_device,
+			    struct net_device *ndev);
+
+int netcp_txpipe_init(struct netcp_tx_pipe *tx_pipe,
+		struct netcp_priv *netcp_priv,
+		const char *chan_name,
+		int queue_depth);
+int netcp_txpipe_open(struct netcp_tx_pipe *tx_pipe);
+int netcp_txpipe_close(struct netcp_tx_pipe *tx_pipe);
+
+struct dma_chan *netcp_get_rx_chan(struct netcp_priv *priv);
+struct dma_chan *netcp_get_tx_chan(struct netcp_priv *priv);
+
+u32 *netcp_push_psdata(struct netcp_packet *p_info, unsigned words);
+int netcp_align_psdata(struct netcp_packet *p_info, unsigned word_align);
+
+typedef int netcp_hook_rtn(int order, void *data, struct netcp_packet *packet);
+
+int netcp_register_txhook(struct netcp_priv *netcp_priv, int order,
+		netcp_hook_rtn *hook_rtn, void *hook_data);
+int netcp_unregister_txhook(struct netcp_priv *netcp_priv, int order,
+		netcp_hook_rtn *hook_rtn, void *hook_data);
+int netcp_register_rxhook(struct netcp_priv *netcp_priv, int order,
+		netcp_hook_rtn *hook_rtn, void *hook_data);
+int netcp_unregister_rxhook(struct netcp_priv *netcp_priv, int order,
+		netcp_hook_rtn *hook_rtn, void *hook_data);
+
+void *netcp_device_find_module(struct netcp_device *netcp_device,
+		const char *name);
+void xge_serdes_init_156p25Mhz(void);
+int keystone_pcsr_config(void __iomem *pcsr_ofs, int port, u32 interface);
+#endif
diff --git a/drivers/net/ethernet/ti/keystone_net_core.c b/drivers/net/ethernet/ti/keystone_net_core.c
new file mode 100644
index 0000000..9c982bb
--- /dev/null
+++ b/drivers/net/ethernet/ti/keystone_net_core.c
@@ -0,0 +1,2056 @@
+/*
+ * Copyright (C) 2012 Texas Instruments Incorporated
+ * Authors: Cyril Chemparathy <cyril@ti.com>
+ *	    Sandeep Paulraj <s-paulraj@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/clk.h>
+#include <linux/phy.h>
+#include <linux/timer.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/uaccess.h>
+#include <linux/if_vlan.h>
+#include <linux/ethtool.h>
+#include <linux/if_ether.h>
+#include <linux/netdevice.h>
+#include <linux/interrupt.h>
+#include <linux/dmaengine.h>
+#include <linux/net_tstamp.h>
+#include <linux/of_net.h>
+#include <linux/of_address.h>
+#include <linux/dma-mapping.h>
+#include <linux/scatterlist.h>
+#include <linux/etherdevice.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/keystone-dma.h>
+
+#include "keystone_net.h"
+
+/* Read the e-fuse value as 32 bit values to be endian independent */
+static inline int emac_arch_get_mac_addr(char *x,
+					 void __iomem *efuse_mac)
+{
+	unsigned int addr0, addr1;
+
+	addr1 = __raw_readl(efuse_mac + 4);
+	addr0 = __raw_readl(efuse_mac);
+
+	x[0] = (addr1 & 0x0000ff00) >> 8;
+	x[1] = addr1 & 0x000000ff;
+	x[2] = (addr0 & 0xff000000) >> 24;
+	x[3] = (addr0 & 0x00ff0000) >> 16;
+	x[4] = (addr0 & 0x0000ff00) >> 8;
+	x[5] = addr0 & 0x000000ff;
+
+	return 0;
+}
+
+static unsigned int sg_count(struct scatterlist *sg, unsigned int max_ents)
+{
+	unsigned int count;
+
+	for (count = 0; sg && (count < max_ents); count++, sg = sg_next(sg))
+		;
+
+	return count;
+}
+
+static const char *netcp_node_name(struct device_node *node)
+{
+	const char *name;
+
+	if (of_property_read_string(node, "label", &name) < 0)
+		name = node->name;
+	if (!name)
+		name = "unknown";
+	return name;
+}
+
+
+/*
+ *  Module management structures
+ */
+struct netcp_device {
+	struct list_head	 device_list;
+	struct list_head	 interface_head;
+	struct list_head	 modpriv_head;
+	struct platform_device	*platform_device;
+	void __iomem		*streaming_switch;
+};
+
+struct netcp_inst_modpriv {
+	struct netcp_device	*netcp_device;
+	struct netcp_module	*netcp_module;
+	struct list_head	 inst_list;
+	void			*module_priv;
+};
+
+struct netcp_intf_modpriv {
+	struct netcp_priv	*netcp_priv;
+	struct netcp_module	*netcp_module;
+	struct list_head	 intf_list;
+	void			*module_priv;
+};
+
+static LIST_HEAD(netcp_devices);
+static LIST_HEAD(netcp_modules);
+static DEFINE_MUTEX(netcp_modules_lock);
+
+static struct kmem_cache *netcp_pinfo_cache;
+
+/*
+ *  Module management routines
+ */
+#define for_each_netcp_module(module)			\
+	list_for_each_entry(module, &netcp_modules, module_list)
+
+#define for_each_netcp_device_module(netcp_device, inst_modpriv) \
+	list_for_each_entry(inst_modpriv, \
+		&((netcp_device)->modpriv_head), inst_list)
+
+int netcp_register_module(struct netcp_module *module)
+{
+	struct netcp_module *tmp;
+	struct netcp_device *netcp_device;
+	int ret;
+
+	BUG_ON(!module->name);
+	BUG_ON(!module->probe);
+
+	mutex_lock(&netcp_modules_lock);
+
+	ret = -EEXIST;
+	for_each_netcp_module(tmp) {
+		if (!strcasecmp(tmp->name, module->name))
+			goto done;
+	}
+
+	list_add_tail(&module->module_list, &netcp_modules);
+
+	list_for_each_entry(netcp_device, &netcp_devices, device_list) {
+		struct platform_device *pdev = netcp_device->platform_device;
+		struct device_node *node = pdev->dev.of_node;
+		struct device_node *child;
+		struct netcp_inst_modpriv *inst_modpriv;
+		struct netcp_priv *netcp_priv;
+
+		/* Find this module in the sub-tree for this device */
+		for_each_child_of_node(node, child) {
+			const char *name = netcp_node_name(child);
+			if (!strcasecmp(module->name, name))
+				break;
+		}
+
+		/* If module not used for this device, skip it */
+		if (child == NULL)
+			continue;
+
+		inst_modpriv = kzalloc(sizeof(*inst_modpriv), GFP_KERNEL);
+		if (!inst_modpriv) {
+			dev_err(&pdev->dev, "Failed to allocate instance for for %s\n", pdev->name);
+			continue;	/* FIXME: Fail instead? */
+		}
+		inst_modpriv->netcp_device = netcp_device;
+		inst_modpriv->netcp_module = module;
+		list_add_tail(&inst_modpriv->inst_list, &netcp_device->modpriv_head);
+
+		dev_dbg(&pdev->dev, "%s(): probing module \"%s\"\n", __func__, module->name);
+
+		ret = module->probe(netcp_device, &pdev->dev, child, &inst_modpriv->module_priv);
+		if (ret) {
+			dev_warn(&pdev->dev, "Probe of module %s failed with %d\n",
+					module->name, ret);
+			list_del(&inst_modpriv->inst_list);
+			kfree(inst_modpriv);
+			continue;
+		}
+
+		/* Attach module to interfaces */
+		list_for_each_entry(netcp_priv, &netcp_device->interface_head, interface_list) {
+			struct netcp_intf_modpriv *intf_modpriv;
+			int found = 0;
+
+			list_for_each_entry(intf_modpriv, &netcp_priv->module_head, intf_list) {
+				if (intf_modpriv->netcp_module == module) {
+					found = 1;
+					break;
+				}
+			}
+
+			if (!found) {
+				intf_modpriv = kzalloc(sizeof(*intf_modpriv), GFP_KERNEL);
+				if (!intf_modpriv) {
+					dev_err(&pdev->dev, "Error allocating intf_modpriv for %s\n",
+							module->name);
+					continue;
+				}
+
+				intf_modpriv->netcp_priv = netcp_priv;
+				intf_modpriv->netcp_module = module;
+				list_add_tail(&intf_modpriv->intf_list, &netcp_priv->module_head);
+
+				dev_dbg(&pdev->dev, "Attaching module \"%s\"\n", module->name);
+				ret = module->attach(inst_modpriv->module_priv, netcp_priv->ndev, &intf_modpriv->module_priv);
+				if (ret) {
+					dev_info(&pdev->dev, "Attach of module %s declined with %d\n",
+							module->name, ret);
+					list_del(&intf_modpriv->intf_list);
+					kfree(intf_modpriv);
+					continue;
+				}
+
+			}
+		}
+	}
+
+	ret = 0;
+
+done:
+	mutex_unlock(&netcp_modules_lock);
+	return ret;
+}
+EXPORT_SYMBOL(netcp_register_module);
+
+static struct netcp_module *__netcp_find_module(const char *name)
+{
+	struct netcp_module *tmp;
+
+	for_each_netcp_module(tmp) {
+		if (!strcasecmp(tmp->name, name))
+			return tmp;
+	}
+	return NULL;
+}
+
+static struct netcp_module *netcp_find_module(const char *name)
+{
+	struct netcp_module *module;
+
+	mutex_lock(&netcp_modules_lock);
+	module = __netcp_find_module(name);
+	mutex_unlock(&netcp_modules_lock);
+	return module;
+}
+
+static void *__netcp_device_find_module(struct netcp_device *netcp_device,
+					 const char *name)
+{
+	struct netcp_inst_modpriv *tmp;
+
+	for_each_netcp_device_module(netcp_device, tmp) {
+		if (!strcasecmp(tmp->netcp_module->name, name))
+			return tmp->module_priv;
+	}
+	return NULL;
+}
+
+void *netcp_device_find_module(struct netcp_device *netcp_device,
+		const char *name)
+{
+	void *module;
+
+	mutex_lock(&netcp_modules_lock);
+	module = __netcp_device_find_module(netcp_device, name);
+	mutex_unlock(&netcp_modules_lock);
+	return module;
+}
+EXPORT_SYMBOL(netcp_device_find_module);
+
+void netcp_unregister_module(struct netcp_module *module)
+{
+	struct netcp_device *netcp_device;
+	struct netcp_module *module_tmp;
+
+	mutex_lock(&netcp_modules_lock);
+
+	list_for_each_entry(netcp_device, &netcp_devices, device_list) {
+		struct netcp_priv *netcp_priv, *netcp_tmp;
+		struct netcp_inst_modpriv *inst_modpriv, *inst_tmp;
+
+		/* Release the module from each interface */
+		list_for_each_entry_safe(netcp_priv, netcp_tmp, 
+				&netcp_device->interface_head, interface_list) {
+			struct netcp_intf_modpriv *intf_modpriv, *intf_tmp;
+
+			list_for_each_entry_safe(intf_modpriv, intf_tmp,
+					&netcp_priv->module_head, intf_list) {
+				if (intf_modpriv->netcp_module == module) {
+					module->release(intf_modpriv->module_priv);
+					list_del(&intf_modpriv->intf_list);
+					kfree(intf_modpriv);
+					break;
+				}
+			}
+		}
+
+		/* Remove the module from each instance */
+		list_for_each_entry_safe(inst_modpriv, inst_tmp,
+				&netcp_device->modpriv_head, inst_list) {
+			if (inst_modpriv->netcp_module == module) {
+				module->remove(netcp_device, inst_modpriv->module_priv);
+				list_del(&inst_modpriv->inst_list);
+				kfree(inst_modpriv);
+				break;
+			}
+		}
+	}
+
+	/* Remove the module from the module list */
+	for_each_netcp_module(module_tmp) {
+		if (module == module_tmp) {
+			list_del(&module->module_list);
+			break;
+		}
+	}
+
+	mutex_unlock(&netcp_modules_lock);
+}
+EXPORT_SYMBOL(netcp_unregister_module);
+
+
+/*
+ *  Module TX and RX Hook management
+ */
+struct netcp_hook_list {
+	struct list_head	 list;
+	netcp_hook_rtn		*hook_rtn;
+	void			*hook_data;
+	int			 order;
+};
+
+
+int netcp_register_txhook(struct netcp_priv *netcp_priv, int order,
+		netcp_hook_rtn *hook_rtn, void *hook_data)
+{
+	struct netcp_hook_list	*entry;
+	struct netcp_hook_list	*next;
+
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	if (!entry)
+		return -ENOMEM;
+
+	entry->hook_rtn  = hook_rtn;
+	entry->hook_data = hook_data;
+	entry->order     = order;
+
+	list_for_each_entry(next, &netcp_priv->txhook_list_head, list) {
+		if (next->order > order)
+			break;
+	}
+	__list_add(&entry->list, next->list.prev, &next->list);
+
+	return 0;
+}
+EXPORT_SYMBOL(netcp_register_txhook);
+
+int netcp_unregister_txhook(struct netcp_priv *netcp_priv, int order,
+		netcp_hook_rtn *hook_rtn, void *hook_data)
+{
+	struct netcp_hook_list	*next;
+
+	list_for_each_entry(next, &netcp_priv->txhook_list_head, list) {
+		if ((next->order     == order) &&
+		    (next->hook_rtn  == hook_rtn) &&
+		    (next->hook_data == hook_data)) {
+			list_del(&next->list);
+			kfree(next);
+			return 0;
+		}
+	}
+
+	return -ENOENT;
+}
+EXPORT_SYMBOL(netcp_unregister_txhook);
+
+int netcp_register_rxhook(struct netcp_priv *netcp_priv, int order,
+		netcp_hook_rtn *hook_rtn, void *hook_data)
+{
+	struct netcp_hook_list	*entry;
+	struct netcp_hook_list	*next;
+
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	if (!entry)
+		return -ENOMEM;
+
+	entry->hook_rtn  = hook_rtn;
+	entry->hook_data = hook_data;
+	entry->order     = order;
+
+	list_for_each_entry(next, &netcp_priv->rxhook_list_head, list) {
+		if (next->order > order)
+			break;
+	}
+	__list_add(&entry->list, next->list.prev, &next->list);
+
+	return 0;
+}
+EXPORT_SYMBOL(netcp_register_rxhook);
+
+int netcp_unregister_rxhook(struct netcp_priv *netcp_priv, int order,
+		netcp_hook_rtn *hook_rtn, void *hook_data)
+{
+	struct netcp_hook_list	*next;
+
+	list_for_each_entry(next, &netcp_priv->rxhook_list_head, list) {
+		if ((next->order     == order) &&
+		    (next->hook_rtn  == hook_rtn) &&
+		    (next->hook_data == hook_data)) {
+			list_del(&next->list);
+			kfree(next);
+			return 0;
+		}
+	}
+
+	return -ENOENT;
+}
+EXPORT_SYMBOL(netcp_unregister_rxhook);
+
+u32 *netcp_push_psdata(struct netcp_packet *p_info, unsigned bytes)
+{
+	u32		*buf;
+	unsigned	 words;
+
+	if ((bytes & 0x03) != 0)
+		return NULL;
+	words = bytes >> 2;
+
+	if ((p_info->psdata_len + words) > NETCP_PSDATA_LEN)
+		return NULL;
+
+	p_info->psdata_len += words;
+	buf = &p_info->psdata[NETCP_PSDATA_LEN - p_info->psdata_len];
+
+	memset(buf, 0, bytes);
+
+	return buf;
+}
+EXPORT_SYMBOL(netcp_push_psdata);
+
+int netcp_align_psdata(struct netcp_packet *p_info, unsigned byte_align)
+{
+	int	padding;
+
+	switch (byte_align) {
+	case 0:
+		padding = -EINVAL;
+		break;
+	case 1:
+		padding = 0;
+		break;
+	default:
+		padding = (p_info->psdata_len << 2) % byte_align;
+		break;
+	}
+
+	return padding;
+}
+EXPORT_SYMBOL(netcp_align_psdata);
+
+#define NETCP_DEBUG (NETIF_MSG_HW	| NETIF_MSG_WOL		|	\
+		    NETIF_MSG_DRV	| NETIF_MSG_LINK	|	\
+		    NETIF_MSG_IFUP	| NETIF_MSG_INTR	|	\
+		    NETIF_MSG_PROBE	| NETIF_MSG_TIMER	|	\
+		    NETIF_MSG_IFDOWN	| NETIF_MSG_RX_ERR	|	\
+		    NETIF_MSG_TX_ERR	| NETIF_MSG_TX_DONE	|	\
+		    NETIF_MSG_PKTDATA	| NETIF_MSG_TX_QUEUED	|	\
+		    NETIF_MSG_RX_STATUS)
+
+#define NETCP_NAPI_WEIGHT	128
+#define NETCP_TX_TIMEOUT	40
+#define NETCP_MIN_PACKET_SIZE	64
+#define NETCP_MAX_PACKET_SIZE	(VLAN_ETH_FRAME_LEN + ETH_FCS_LEN)
+
+static int netcp_rx_packet_max = NETCP_MAX_PACKET_SIZE;
+static int netcp_debug_level;
+
+#define for_each_module(netcp, intf_modpriv)			\
+	list_for_each_entry(intf_modpriv, &netcp->module_head, intf_list)
+
+static const char *netcp_rx_state_str(struct netcp_priv *netcp)
+{
+	static const char * const state_str[] = {
+		[RX_STATE_POLL]		= "poll",
+		[RX_STATE_SCHEDULED]	= "scheduled",
+		[RX_STATE_TEARDOWN]	= "teardown",
+		[RX_STATE_INTERRUPT]	= "interrupt",
+		[RX_STATE_INVALID]	= "invalid",
+	};
+
+	if (netcp->rx_state < 0 || netcp->rx_state >= ARRAY_SIZE(state_str))
+		return state_str[RX_STATE_INVALID];
+	else
+		return state_str[netcp->rx_state];
+}
+
+static inline void netcp_set_rx_state(struct netcp_priv *netcp,
+				     enum netcp_rx_state state)
+{
+	netcp->rx_state = state;
+	cpu_relax();
+}
+
+static inline bool netcp_is_alive(struct netcp_priv *netcp)
+{
+	return (netcp->rx_state == RX_STATE_POLL ||
+		netcp->rx_state == RX_STATE_INTERRUPT);
+}
+
+static void netcp_dump_packet(struct netcp_packet *p_info, const char *cause)
+{
+	struct netcp_priv *netcp = p_info->netcp;
+	struct sk_buff *skb = p_info->skb;
+	unsigned char *head, *tail;
+
+	head = skb->data;
+	tail = skb_tail_pointer(skb) - 16;
+
+	dev_dbg(netcp->dev, "packet %p %s, size %d (%d): "
+		"%02x%02x%02x%02x%02x%02x%02x%02x"
+		"%02x%02x%02x%02x%02x%02x%02x%02x"
+		"%02x%02x%02x%02x%02x%02x%02x%02x"
+		"%02x%02x%02x%02x%02x%02x%02x%02x\n",
+		p_info, cause, skb->len, p_info->sg[2].length,
+		head[0x00], head[0x01], head[0x02], head[0x03],
+		head[0x04], head[0x05], head[0x06], head[0x07],
+		head[0x08], head[0x09], head[0x0a], head[0x0b],
+		head[0x0c], head[0x0d], head[0x0e], head[0x0f],
+		tail[0x00], tail[0x01], tail[0x02], tail[0x03],
+		tail[0x04], tail[0x05], tail[0x06], tail[0x07],
+		tail[0x08], tail[0x09], tail[0x0a], tail[0x0b],
+		tail[0x0c], tail[0x0d], tail[0x0e], tail[0x0f]);
+}
+
+static void netcp_rx_complete(void *data)
+{
+	struct netcp_packet *p_info = data;
+	struct netcp_priv *netcp = p_info->netcp;
+	struct sk_buff *skb = p_info->skb;
+	struct scatterlist *sg;
+	enum dma_status status;
+	unsigned int frags;
+	struct netcp_hook_list *rx_hook;
+
+	status = dma_async_is_tx_complete(netcp->rx_channel,
+					  p_info->cookie, NULL, NULL);
+	WARN_ON(status != DMA_SUCCESS && status != DMA_ERROR);
+	WARN_ON(netcp->rx_state != RX_STATE_INTERRUPT	&&
+		netcp->rx_state != RX_STATE_POLL	&&
+		netcp->rx_state != RX_STATE_TEARDOWN);
+
+	/* sg[2] describes the buffer already attached to the sk_buff. */
+	skb_put(skb, sg_dma_len(&p_info->sg[2]));
+
+	/* Fill in the page fragment list from sg[3] and later */
+	for (frags = 0, sg = sg_next(&p_info->sg[2]);
+			frags < NETCP_SGLIST_SIZE-3 && sg;
+			++frags, sg = sg_next(sg)) {
+		skb_add_rx_frag(skb, frags, sg_page(sg), sg->offset,
+				sg_dma_len(sg), sg_dma_len(sg));
+	}
+
+	dma_unmap_sg(netcp->dev, &p_info->sg[2], frags+1, DMA_FROM_DEVICE);
+
+	if (unlikely(netcp->rx_state == RX_STATE_TEARDOWN)) {
+		dev_dbg(netcp->dev,
+			"receive: reclaimed packet %p, status %d, state %s\n",
+			p_info, status, netcp_rx_state_str(netcp));
+		dev_kfree_skb_any(skb);
+		kmem_cache_free(netcp_pinfo_cache, p_info);
+		netcp->ndev->stats.rx_dropped++;
+		return;
+	}
+
+	if (unlikely(status != DMA_SUCCESS)) {
+		dev_warn(netcp->dev,
+			 "receive: reclaimed packet %p, status %d, state %s\n",
+			 p_info, status, netcp_rx_state_str(netcp));
+		dev_kfree_skb_any(skb);
+		kmem_cache_free(netcp_pinfo_cache, p_info);
+		netcp->ndev->stats.rx_errors++;
+		return;
+	}
+
+	if (unlikely(!skb->len)) {
+		dev_warn(netcp->dev, "receive: zero length packet\n");
+		dev_kfree_skb_any(skb);
+		kmem_cache_free(netcp_pinfo_cache, p_info);
+		netcp->ndev->stats.rx_errors++;
+		return;
+	}
+
+	BUG_ON(netcp->rx_state != RX_STATE_POLL);
+
+
+	netcp->ndev->last_rx = jiffies;
+
+#ifdef DEBUG
+	netcp_dump_packet(p_info, "rx");
+#endif
+
+	/* Call each of the RX hooks */
+	list_for_each_entry(rx_hook, &netcp->rxhook_list_head, list) {
+		int ret;
+		ret = rx_hook->hook_rtn(rx_hook->order, rx_hook->hook_data, p_info);
+		if (ret) {
+			dev_err(netcp->dev, "RX hook %d failed: %d\n", rx_hook->order, ret);
+			dev_kfree_skb_any(skb);
+			kmem_cache_free(netcp_pinfo_cache, p_info);
+			return;
+		}
+	}
+
+	netcp->ndev->stats.rx_packets++;
+	netcp->ndev->stats.rx_bytes += skb->len;
+
+	p_info->skb = NULL;
+	kmem_cache_free(netcp_pinfo_cache, p_info);
+
+	/* push skb up the stack */
+	skb->protocol = eth_type_trans(skb, netcp->ndev);
+	netif_receive_skb(skb);
+}
+
+/* Release a free receive buffer */
+static void netcp_rxpool_free(void *arg, unsigned q_num, unsigned bufsize,
+		struct dma_async_tx_descriptor *desc)
+{
+	struct netcp_priv *netcp = arg;
+
+	if (q_num == 0) {
+		struct netcp_packet *p_info = desc->callback_param;
+		struct sk_buff *skb = p_info->skb;
+
+		dma_unmap_sg(netcp->dev, &p_info->sg[2], 1, DMA_FROM_DEVICE);
+		dev_kfree_skb_any(skb);
+		kmem_cache_free(netcp_pinfo_cache, p_info);
+	} else {
+		void *bufptr = desc->callback_param;
+		struct scatterlist sg[1];
+
+		sg_init_table(sg, 1);
+		sg_set_buf(&sg[0], bufptr, PAGE_SIZE);
+		sg_dma_address(&sg[0]) = virt_to_dma(netcp->dev, bufptr);
+		dma_unmap_sg(netcp->dev, sg, 1, DMA_FROM_DEVICE);
+		free_page((unsigned long)bufptr);
+	}
+}
+
+static void netcp_rx_complete2nd(void *data)
+{
+	WARN(1, "Attempt to complete secondary receive buffer!\n");
+}
+
+/* Allocate a free receive buffer */
+static struct dma_async_tx_descriptor *netcp_rxpool_alloc(void *arg,
+		unsigned q_num, unsigned bufsize)
+{
+	struct netcp_priv *netcp = arg;
+	struct dma_async_tx_descriptor *desc;
+	struct dma_device *device;
+	u32 err = 0;
+
+	device = netcp->rx_channel->device;
+
+	if (q_num == 0) {
+		struct netcp_packet *p_info;
+		struct sk_buff *skb;
+
+		/* Allocate a primary receive queue entry */
+		p_info = kmem_cache_alloc(netcp_pinfo_cache, GFP_ATOMIC);
+		if (!p_info) {
+			dev_err(netcp->dev, "packet alloc failed\n");
+			return NULL;
+		}
+		p_info->netcp = netcp;
+
+		skb = netdev_alloc_skb(netcp->ndev, bufsize);
+		if (!skb) {
+			dev_err(netcp->dev, "skb alloc failed\n");
+			kmem_cache_free(netcp_pinfo_cache, p_info);
+			return NULL;
+		}
+		skb->dev = netcp->ndev;
+		p_info->skb = skb;
+
+		sg_init_table(p_info->sg, NETCP_SGLIST_SIZE);
+		sg_set_buf(&p_info->sg[0], p_info->epib, sizeof(p_info->epib));
+		sg_set_buf(&p_info->sg[1], p_info->psdata, sizeof(p_info->psdata));
+		sg_set_buf(&p_info->sg[2], skb_tail_pointer(skb), skb_tailroom(skb));
+
+		p_info->sg_ents = 2 + dma_map_sg(netcp->dev, &p_info->sg[2],
+						 1, DMA_FROM_DEVICE);
+		if (p_info->sg_ents != 3) {
+			dev_err(netcp->dev, "dma map failed\n");
+			dev_kfree_skb_any(skb);
+			kmem_cache_free(netcp_pinfo_cache, p_info);
+			return NULL;
+		}
+
+		desc = dmaengine_prep_slave_sg(netcp->rx_channel, p_info->sg,
+					       3, DMA_DEV_TO_MEM,
+					       DMA_HAS_EPIB | DMA_HAS_PSINFO);
+		if (IS_ERR_OR_NULL(desc)) {
+			dma_unmap_sg(netcp->dev, &p_info->sg[2], 1, DMA_FROM_DEVICE);
+			dev_kfree_skb_any(skb);
+			kmem_cache_free(netcp_pinfo_cache, p_info);
+			err = PTR_ERR(desc);
+			if (err != -ENOMEM) {
+				dev_err(netcp->dev,
+					"dma prep failed, error %d\n", err);
+			}
+			return NULL;
+		}
+
+		desc->callback_param = p_info;
+		desc->callback = netcp_rx_complete;
+		p_info->cookie = desc->cookie;
+
+	} else {
+
+		/* Allocate a secondary receive queue entry */
+		struct scatterlist sg[1];
+		void *bufptr;
+
+		bufptr = (void *)__get_free_page(GFP_ATOMIC);
+		if (!bufptr) {
+			dev_warn(netcp->dev, "page alloc failed for pool %d\n", q_num);
+			return NULL;
+		}
+
+		sg_init_table(sg, 1);
+		sg_set_buf(&sg[0], bufptr, PAGE_SIZE);
+
+		err = dma_map_sg(netcp->dev, sg, 1, DMA_FROM_DEVICE);
+		if (err != 1) {
+			dev_warn(netcp->dev, "map error for pool %d\n", q_num);
+			free_page((unsigned long)bufptr);
+			return NULL;
+		}
+
+		desc = dmaengine_prep_slave_sg(netcp->rx_channel, sg, 1,
+					       DMA_DEV_TO_MEM,
+					       q_num << DMA_QNUM_SHIFT);
+		if (IS_ERR_OR_NULL(desc)) {
+			dma_unmap_sg(netcp->dev, sg, 1, DMA_FROM_DEVICE);
+			free_page((unsigned long)bufptr);
+
+			err = PTR_ERR(desc);
+			if (err != -ENOMEM) {
+				dev_err(netcp->dev,
+					"dma prep failed, error %d\n", err);
+			}
+			return NULL;
+		}
+
+		desc->callback_param = bufptr;
+		desc->callback = netcp_rx_complete2nd;
+	}
+
+	return desc;
+}
+
+/* NAPI poll */
+static int netcp_poll(struct napi_struct *napi, int budget)
+{
+	struct netcp_priv *netcp = container_of(napi, struct netcp_priv, napi);
+	unsigned long flags;
+	unsigned packets;
+
+	spin_lock_irqsave(&netcp->lock, flags);
+
+	BUG_ON(netcp->rx_state != RX_STATE_SCHEDULED);
+	netcp_set_rx_state(netcp, RX_STATE_POLL);
+
+	spin_unlock_irqrestore(&netcp->lock, flags);
+
+	packets = dma_poll(netcp->rx_channel, budget);
+
+	if (packets < budget) {
+		netcp_set_rx_state(netcp, RX_STATE_INTERRUPT);
+		napi_complete(&netcp->napi);
+		dmaengine_resume(netcp->rx_channel);
+	} else {
+		netcp_set_rx_state(netcp, RX_STATE_SCHEDULED);
+	}
+
+	dma_rxfree_refill(netcp->rx_channel);
+
+	return packets;
+}
+
+static const char *netcp_tx_state_str(enum netcp_tx_state tx_state)
+{
+	static const char * const state_str[] = {
+		[TX_STATE_INTERRUPT]	= "interrupt",
+		[TX_STATE_POLL]		= "poll",
+		[TX_STATE_SCHEDULED]	= "scheduled",
+		[TX_STATE_INVALID]	= "invalid",
+	};
+
+	if (tx_state < 0 || tx_state >= ARRAY_SIZE(state_str))
+		return state_str[TX_STATE_INVALID];
+	else
+		return state_str[tx_state];
+}
+
+static inline void netcp_set_txpipe_state(struct netcp_tx_pipe *tx_pipe,
+					  enum netcp_tx_state new_state)
+{
+	dev_dbg(tx_pipe->netcp_priv->dev, "txpipe %s: %s -> %s\n",
+		tx_pipe->dma_chan_name,
+		netcp_tx_state_str(tx_pipe->dma_poll_state),
+		netcp_tx_state_str(new_state));
+
+	tx_pipe->dma_poll_state = new_state;
+	cpu_relax();
+}
+
+static void netcp_tx_complete(void *data)
+{
+	struct netcp_packet *p_info = data;
+	struct netcp_priv *netcp = p_info->netcp;
+	struct netcp_tx_pipe *tx_pipe = p_info->tx_pipe;
+	struct sk_buff *skb = p_info->skb;
+	enum dma_status status;
+	unsigned int sg_ents;
+	int poll_count;
+
+	if (unlikely(p_info->cookie <= 0))
+		WARN(1, "invalid dma cookie == %d", p_info->cookie);
+	else {
+		status = dma_async_is_tx_complete(p_info->tx_pipe->dma_channel,
+						  p_info->cookie, NULL, NULL);
+		WARN((status != DMA_SUCCESS && status != DMA_ERROR),
+				"invalid dma status %d", status);
+		if (status != DMA_SUCCESS)
+			netcp->ndev->stats.tx_errors++;
+	}
+
+	sg_ents = sg_count(&p_info->sg[2], p_info->sg_ents);
+	dma_unmap_sg(netcp->dev, &p_info->sg[2], sg_ents, DMA_TO_DEVICE);
+
+	netcp_dump_packet(p_info, "txc");
+
+	poll_count = atomic_add_return(sg_ents, &tx_pipe->dma_poll_count);
+	if ((poll_count >= tx_pipe->dma_resume_threshold) &&
+	    netif_subqueue_stopped(netcp->ndev, skb)) {
+		u16 subqueue = skb_get_queue_mapping(skb);
+		dev_dbg(netcp->dev, "waking subqueue %hu\n", subqueue);
+		netif_wake_subqueue(netcp->ndev, subqueue);
+	}
+
+	dev_kfree_skb_any(skb);
+	kfree(p_info);
+}
+
+static void netcp_tx_tasklet(unsigned long data)
+{
+	struct netcp_tx_pipe *tx_pipe = (void *)data;
+	int poll_count, packets;
+
+	if (unlikely(tx_pipe->dma_poll_state != TX_STATE_SCHEDULED)) {
+		WARN(1, "spurious tasklet activation, txpipe %s state %d",
+			tx_pipe->dma_chan_name, tx_pipe->dma_poll_state);
+		return;
+	}
+
+	packets = dma_poll(tx_pipe->dma_channel, -1);
+
+	poll_count = atomic_read(&tx_pipe->dma_poll_count);
+	if (poll_count >= tx_pipe->dma_resume_threshold)
+		netcp_set_txpipe_state(tx_pipe, TX_STATE_POLL);
+	else {
+		netcp_set_txpipe_state(tx_pipe, TX_STATE_INTERRUPT);
+		dmaengine_resume(tx_pipe->dma_channel);
+	}
+
+	dev_dbg(tx_pipe->netcp_priv->dev,
+		"txpipe %s poll count %d, packets %d\n",
+		tx_pipe->dma_chan_name, poll_count, packets);
+}
+
+static void netcp_tx_notify(struct dma_chan *chan, void *arg)
+{
+	struct netcp_tx_pipe *tx_pipe = arg;
+
+	BUG_ON(tx_pipe->dma_poll_state != TX_STATE_INTERRUPT);
+	dmaengine_pause(tx_pipe->dma_channel);
+	netcp_set_txpipe_state(tx_pipe, TX_STATE_SCHEDULED);
+	tasklet_schedule(&tx_pipe->dma_poll_tasklet);
+}
+
+/* Push an outcoming packet */
+static int netcp_ndo_start_xmit(struct sk_buff *skb, struct net_device *ndev)
+{
+	struct netcp_priv *netcp = netdev_priv(ndev);
+	struct dma_async_tx_descriptor *desc;
+	struct netcp_tx_pipe *tx_pipe = NULL;
+	struct netcp_hook_list *tx_hook;
+	struct netcp_packet *p_info;
+	int subqueue = skb_get_queue_mapping(skb);
+	int real_sg_ents = 0;
+	int poll_count;
+	int ret = 0;
+
+	ndev->stats.tx_packets++;
+	ndev->stats.tx_bytes += skb->len;
+
+	p_info = kmalloc(sizeof(*p_info), GFP_ATOMIC);
+	if (!p_info) {
+		ndev->stats.tx_dropped++;
+		dev_kfree_skb_any(skb);
+		dev_warn(netcp->dev, "failed to alloc packet info\n");
+		return -ENOMEM;
+	}
+
+	p_info->netcp = netcp;
+	p_info->skb = skb;
+	p_info->tx_pipe = NULL;
+	p_info->psdata_len = 0;
+	memset(p_info->epib, 0, sizeof(p_info->epib));
+
+	/* Find out where to inject the packet for transmission */
+	list_for_each_entry(tx_hook, &netcp->txhook_list_head, list) {
+		ret = tx_hook->hook_rtn(tx_hook->order, tx_hook->hook_data,
+					p_info);
+		if (ret) {
+			dev_err(netcp->dev, "TX hook %d "
+				"rejected the packet: %d\n",
+				tx_hook->order, ret);
+			dev_kfree_skb_any(skb);
+			kfree(p_info);
+			return ret;
+		}
+	}
+
+	/* Make sure some TX hook claimed the packet */
+	tx_pipe = p_info->tx_pipe;
+	if (tx_pipe == NULL) {
+		dev_err(netcp->dev, "No TX hook claimed the packet!\n");
+		dev_kfree_skb_any(skb);
+		kfree(p_info);
+		return -ENXIO;
+	}
+
+	if (unlikely(skb->len < NETCP_MIN_PACKET_SIZE)) {
+		ret = skb_padto(skb, NETCP_MIN_PACKET_SIZE);
+		if (ret < 0) {
+			dev_warn(netcp->dev, "padding failed (%d), "
+				 "packet dropped\n", ret);
+			kfree(p_info);
+			return ret;
+		}
+		skb->len = NETCP_MIN_PACKET_SIZE;
+	}
+
+	netcp_dump_packet(p_info, "txs");
+
+	skb_tx_timestamp(skb);
+
+	sg_init_table(p_info->sg, NETCP_SGLIST_SIZE);
+	sg_set_buf(&p_info->sg[0], p_info->epib, sizeof(p_info->epib));
+	sg_set_buf(&p_info->sg[1], &p_info->psdata[NETCP_PSDATA_LEN - p_info->psdata_len],
+			p_info->psdata_len * sizeof(u32));
+
+	/* Map all the packet fragments	into the scatterlist */
+	real_sg_ents = skb_to_sgvec(skb, &p_info->sg[2], 0, skb->len);
+	p_info->sg_ents = 2 + dma_map_sg(netcp->dev, &p_info->sg[2],
+					 real_sg_ents, DMA_TO_DEVICE);
+	if (p_info->sg_ents != (real_sg_ents + 2)) {
+		ndev->stats.tx_dropped++;
+		dev_kfree_skb_any(skb);
+		kfree(p_info);
+		real_sg_ents = 0;
+		dev_warn(netcp->dev, "failed to map transmit packet\n");
+		ret = -ENXIO;
+		goto out;
+	}
+
+	desc = dmaengine_prep_slave_sg(tx_pipe->dma_channel, p_info->sg,
+				       p_info->sg_ents, DMA_MEM_TO_DEV,
+				       (DMA_HAS_EPIB | DMA_HAS_PSINFO |
+					tx_pipe->dma_psflags));
+
+	if (IS_ERR_OR_NULL(desc)) {
+		ndev->stats.tx_dropped++;
+		dma_unmap_sg(netcp->dev, &p_info->sg[2], real_sg_ents,
+			     DMA_TO_DEVICE);
+		dev_kfree_skb_any(skb);
+		kfree(p_info);
+		real_sg_ents = 0;
+		dev_dbg(netcp->dev, "failed to prep slave dma\n");
+		ret = -ENOBUFS;
+		goto out;
+	}
+
+	desc->callback_param = p_info;
+	desc->callback = netcp_tx_complete;
+	p_info->cookie = dmaengine_submit(desc);
+
+	ndev->trans_start = jiffies;
+
+	ret = NETDEV_TX_OK;
+
+out:
+	poll_count = atomic_sub_return(real_sg_ents, &tx_pipe->dma_poll_count);
+	if ((poll_count < tx_pipe->dma_poll_threshold) || (ret < 0)) {
+		dev_dbg(netcp->dev, "polling %s, poll count %d\n",
+			tx_pipe->dma_chan_name, poll_count);
+
+		tasklet_disable(&tx_pipe->dma_poll_tasklet);
+		if (unlikely(tx_pipe->dma_poll_state == TX_STATE_INTERRUPT)) {
+			dmaengine_pause(tx_pipe->dma_channel);
+			netcp_set_txpipe_state(tx_pipe, TX_STATE_POLL);
+		}
+		dma_poll(tx_pipe->dma_channel, -1);
+		tasklet_enable(&tx_pipe->dma_poll_tasklet);
+	}
+
+	if (atomic_read(&tx_pipe->dma_poll_count) < tx_pipe->dma_pause_threshold) {
+		dev_dbg(netcp->dev, "pausing subqueue %d, %s poll count %d\n",
+			subqueue, tx_pipe->dma_chan_name, poll_count);
+		netif_stop_subqueue(ndev, subqueue);
+		if (likely(tx_pipe->dma_poll_state == TX_STATE_POLL)) {
+			netcp_set_txpipe_state(tx_pipe, TX_STATE_INTERRUPT);
+			dmaengine_resume(tx_pipe->dma_channel);
+		}
+	}
+
+	return ret;
+}
+
+
+int netcp_txpipe_close(struct netcp_tx_pipe *tx_pipe)
+{
+	if (tx_pipe->dma_channel) {
+		tasklet_disable(&tx_pipe->dma_poll_tasklet);
+		dmaengine_pause(tx_pipe->dma_channel);
+		dma_poll(tx_pipe->dma_channel, -1);
+		dma_release_channel(tx_pipe->dma_channel);
+		tx_pipe->dma_channel = NULL;
+		netcp_set_txpipe_state(tx_pipe, TX_STATE_INVALID);
+
+		dev_dbg(tx_pipe->netcp_priv->dev, "closed tx pipe %s\n",
+			tx_pipe->dma_chan_name);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(netcp_txpipe_close);
+
+int netcp_txpipe_open(struct netcp_tx_pipe *tx_pipe)
+{
+	struct dma_keystone_info config;
+	dma_cap_mask_t mask;
+	int ret;
+
+	dma_cap_zero(mask);
+	dma_cap_set(DMA_SLAVE, mask);
+
+	tx_pipe->dma_channel = dma_request_channel_by_name(mask, tx_pipe->dma_chan_name);
+	if (IS_ERR_OR_NULL(tx_pipe->dma_channel)) {
+		dev_err(tx_pipe->netcp_priv->dev,
+			"Could not get DMA channel \"%s\"\n",
+			tx_pipe->dma_chan_name);
+		tx_pipe->dma_channel = NULL;
+		return -ENODEV;
+	}
+
+	memset(&config, 0, sizeof(config));
+	config.direction = DMA_MEM_TO_DEV;
+	config.tx_queue_depth = tx_pipe->dma_queue_depth;
+	ret = dma_keystone_config(tx_pipe->dma_channel, &config);
+	if (ret) {
+		dev_err(tx_pipe->netcp_priv->dev,
+			"Could not configure DMA channel \"%s\": %d\n",
+			tx_pipe->dma_chan_name, ret);
+		dma_release_channel(tx_pipe->dma_channel);
+		tx_pipe->dma_channel = NULL;
+		return ret;
+	}
+
+	dma_set_notify(tx_pipe->dma_channel, netcp_tx_notify, tx_pipe);
+	dmaengine_pause(tx_pipe->dma_channel);
+	netcp_set_txpipe_state(tx_pipe, TX_STATE_POLL);
+
+	tx_pipe->dma_queue = dma_get_tx_queue(tx_pipe->dma_channel);
+	atomic_set(&tx_pipe->dma_poll_count, tx_pipe->dma_queue_depth);
+	tasklet_enable(&tx_pipe->dma_poll_tasklet);
+
+
+	dev_dbg(tx_pipe->netcp_priv->dev, "opened tx pipe %s\n",
+		tx_pipe->dma_chan_name);
+	return 0;
+}
+EXPORT_SYMBOL(netcp_txpipe_open);
+
+int netcp_txpipe_init(struct netcp_tx_pipe *tx_pipe,
+		struct netcp_priv *netcp_priv,
+		const char *chan_name,
+		int queue_depth)
+{
+	memset(tx_pipe, 0, sizeof(*tx_pipe));
+
+	tx_pipe->netcp_priv = netcp_priv;
+	tx_pipe->dma_chan_name = chan_name;
+	tx_pipe->dma_queue_depth = queue_depth;
+
+	tx_pipe->dma_poll_threshold = queue_depth / 2;
+	tx_pipe->dma_pause_threshold = (MAX_SKB_FRAGS < (queue_depth / 4)) ?
+					MAX_SKB_FRAGS : (queue_depth / 4);
+	tx_pipe->dma_resume_threshold = tx_pipe->dma_pause_threshold;
+
+	tasklet_init(&tx_pipe->dma_poll_tasklet, netcp_tx_tasklet, (unsigned long)tx_pipe);
+	tasklet_disable_nosync(&tx_pipe->dma_poll_tasklet);
+	netcp_set_txpipe_state(tx_pipe, TX_STATE_INVALID);
+
+	dev_dbg(tx_pipe->netcp_priv->dev, "initialized tx pipe %s, %d/%d/%d\n",
+		tx_pipe->dma_chan_name, tx_pipe->dma_poll_threshold,
+		tx_pipe->dma_pause_threshold, tx_pipe->dma_resume_threshold);
+	return 0;
+}
+EXPORT_SYMBOL(netcp_txpipe_init);
+
+static struct netcp_addr *
+netcp_addr_find(struct netcp_priv *netcp, const u8 *addr,
+	       enum netcp_addr_type type)
+{
+	struct netcp_addr *naddr;
+
+	list_for_each_entry(naddr, &netcp->addr_list, node) {
+		if (naddr->type != type)
+			continue;
+		if (addr && memcmp(addr, naddr->addr, ETH_ALEN))
+			continue;
+		return naddr;
+	}
+
+	return NULL;
+}
+
+static struct netcp_addr *
+netcp_addr_add(struct netcp_priv *netcp, const u8 *addr,
+	       enum netcp_addr_type type)
+{
+	struct netcp_addr *naddr;
+
+	naddr = kmalloc(sizeof(struct netcp_addr), GFP_KERNEL);
+	if (!naddr)
+		return NULL;
+
+	naddr->type = type;
+	naddr->flags = 0;
+	naddr->netcp = netcp;
+	if (addr)
+		memcpy(naddr->addr, addr, ETH_ALEN);
+	else
+		memset(naddr->addr, 0, ETH_ALEN);
+	list_add_tail(&naddr->node, &netcp->addr_list);
+
+	return naddr;
+}
+
+static void netcp_addr_del(struct netcp_addr *naddr)
+{
+	list_del(&naddr->node);
+	kfree(naddr);
+}
+
+static void netcp_addr_clear_mark(struct netcp_priv *netcp)
+{
+	struct netcp_addr *naddr;
+
+	list_for_each_entry(naddr, &netcp->addr_list, node)
+		naddr->flags = 0;
+}
+
+static void netcp_addr_add_mark(struct netcp_priv *netcp, const u8 *addr,
+				enum netcp_addr_type type)
+{
+	struct netcp_addr *naddr;
+
+	naddr = netcp_addr_find(netcp, addr, type);
+	if (naddr) {
+		naddr->flags |= ADDR_VALID;
+		return;
+	}
+
+	naddr = netcp_addr_add(netcp, addr, type);
+	if (!WARN_ON(!naddr))
+		naddr->flags |= ADDR_NEW;
+}
+
+static void netcp_addr_sweep_del(struct netcp_priv *netcp)
+{
+	struct netcp_addr *naddr, *tmp;
+	struct netcp_intf_modpriv *priv;
+	struct netcp_module *module;
+	int error;
+
+	list_for_each_entry_safe(naddr, tmp, &netcp->addr_list, node) {
+		if (naddr->flags & (ADDR_VALID | ADDR_NEW))
+			continue;
+		dev_dbg(netcp->dev, "deleting address %pM, type %x\n",
+			naddr->addr, naddr->type);
+		for_each_module(netcp, priv) {
+			module = priv->netcp_module;
+			if (!module->del_addr)
+				continue;
+			error = module->del_addr(priv->module_priv,
+						 naddr);
+			WARN_ON(error);
+		}
+		netcp_addr_del(naddr);
+	}
+}
+
+static void netcp_addr_sweep_add(struct netcp_priv *netcp)
+{
+	struct netcp_addr *naddr, *tmp;
+	struct netcp_intf_modpriv *priv;
+	struct netcp_module *module;
+	int error;
+
+	list_for_each_entry_safe(naddr, tmp, &netcp->addr_list, node) {
+		if (!(naddr->flags & ADDR_NEW))
+			continue;
+		dev_dbg(netcp->dev, "adding address %pM, type %x\n",
+			naddr->addr, naddr->type);
+		for_each_module(netcp, priv) {
+			module = priv->netcp_module;
+			if (!module->add_addr)
+				continue;
+			error = module->add_addr(priv->module_priv, naddr);
+			WARN_ON(error);
+		}
+	}
+}
+
+static void netcp_set_rx_mode(struct net_device *ndev)
+{
+	struct netcp_priv *netcp = netdev_priv(ndev);
+	struct netdev_hw_addr *ndev_addr;
+	bool promisc;
+
+	promisc = (ndev->flags & IFF_PROMISC ||
+		   ndev->flags & IFF_ALLMULTI ||
+		   netdev_mc_count(ndev) > NETCP_MAX_MCAST_ADDR);
+
+	spin_lock(&netcp->lock);
+
+	/* first clear all marks */
+	netcp_addr_clear_mark(netcp);
+
+	/* next add new entries, mark existing ones */
+	netcp_addr_add_mark(netcp, ndev->broadcast, ADDR_BCAST);
+	for_each_dev_addr(ndev, ndev_addr)
+		netcp_addr_add_mark(netcp, ndev_addr->addr, ADDR_DEV);
+	netdev_for_each_uc_addr(ndev_addr, ndev)
+		netcp_addr_add_mark(netcp, ndev_addr->addr, ADDR_UCAST);
+	netdev_for_each_mc_addr(ndev_addr, ndev)
+		netcp_addr_add_mark(netcp, ndev_addr->addr, ADDR_MCAST);
+
+	if (promisc)
+		netcp_addr_add_mark(netcp, NULL, ADDR_ANY);
+
+	/* finally sweep and callout into modules */
+	netcp_addr_sweep_del(netcp);
+	netcp_addr_sweep_add(netcp);
+
+	spin_unlock(&netcp->lock);
+}
+
+struct dma_chan *netcp_get_rx_chan(struct netcp_priv *netcp)
+{
+	return netcp->rx_channel;
+}
+EXPORT_SYMBOL(netcp_get_rx_chan);
+
+static void netcp_rx_notify(struct dma_chan *chan, void *arg)
+{
+	struct netcp_priv *netcp = arg;
+
+	BUG_ON(netcp->rx_state != RX_STATE_INTERRUPT);
+	dmaengine_pause(netcp->rx_channel);
+	netcp_set_rx_state(netcp, RX_STATE_SCHEDULED);
+	napi_schedule(&netcp->napi);
+}
+
+/* Open the device */
+static int netcp_ndo_open(struct net_device *ndev)
+{
+	struct netcp_priv *netcp = netdev_priv(ndev);
+	struct netcp_intf_modpriv *intf_modpriv;
+	struct netcp_module *module;
+	struct dma_keystone_info config;
+	dma_cap_mask_t mask;
+	int err = -ENODEV;
+	const char *name;
+	int i;
+
+	netif_carrier_off(ndev);
+
+	BUG_ON(netcp->rx_state != RX_STATE_INVALID);
+
+	dma_cap_zero(mask);
+	dma_cap_set(DMA_SLAVE, mask);
+
+	name = netcp->rx_chan_name;
+	netcp->rx_channel = dma_request_channel_by_name(mask, name);
+	if (IS_ERR_OR_NULL(netcp->rx_channel))
+		goto fail;
+
+	memset(&config, 0, sizeof(config));
+	config.direction		= DMA_DEV_TO_MEM;
+	config.scatterlist_size		= NETCP_SGLIST_SIZE;
+	config.rxpool_allocator		= netcp_rxpool_alloc;
+	config.rxpool_destructor	= netcp_rxpool_free;
+	config.rxpool_param		= netcp;
+	config.rxpool_thresh_enable	= DMA_THRESH_NONE;
+
+	for (i = 0; i < KEYSTONE_QUEUES_PER_CHAN &&
+		    netcp->rx_queue_depths[i] &&
+		    netcp->rx_buffer_sizes[i]; ++i) {
+		config.rxpools[i].pool_depth  = netcp->rx_queue_depths[i];
+		config.rxpools[i].buffer_size = netcp->rx_buffer_sizes[i];
+		dev_dbg(netcp->dev, "rx_pool[%d] depth %d, size %d\n", i,
+				config.rxpools[i].pool_depth,
+				config.rxpools[i].buffer_size);
+	}
+	config.rxpool_count = i;
+
+	err = dma_keystone_config(netcp->rx_channel, &config);
+	if (err) {
+		dev_err(netcp->dev, "%d error configuring RX channel\n",
+				err);
+		goto fail;
+	}
+
+	dma_set_notify(netcp->rx_channel, netcp_rx_notify, netcp);
+
+	dev_dbg(netcp->dev, "opened RX channel: %p\n", netcp->rx_channel);
+
+	netcp_set_rx_state(netcp, RX_STATE_INTERRUPT);
+
+	for_each_module(netcp, intf_modpriv) {
+		module = intf_modpriv->netcp_module;
+		if (module->open != NULL) {
+			err = module->open(intf_modpriv->module_priv, ndev);
+			if (err != 0) {
+				dev_err(netcp->dev, "Open failed\n");
+				goto fail;
+			}
+		}
+	}
+
+	dma_rxfree_refill(netcp->rx_channel);
+	napi_enable(&netcp->napi);
+	netif_tx_wake_all_queues(ndev);
+
+	dev_info(netcp->dev, "netcp device %s opened\n", ndev->name);
+
+	return 0;
+fail:
+	if (netcp->rx_channel) {
+		dma_release_channel(netcp->rx_channel);
+		netcp->rx_channel = NULL;
+	}
+	return err;
+}
+
+/* Close the device */
+static int netcp_ndo_stop(struct net_device *ndev)
+{
+	struct netcp_priv *netcp = netdev_priv(ndev);
+	struct netcp_intf_modpriv *intf_modpriv;
+	struct netcp_module *module;
+	unsigned long flags;
+	int err = 0;
+
+	spin_lock_irqsave(&netcp->lock, flags);
+
+	netif_tx_stop_all_queues(ndev);
+	netif_carrier_off(ndev);
+
+	BUG_ON(!netcp_is_alive(netcp));
+
+	netcp_set_rx_state(netcp, RX_STATE_TEARDOWN);
+
+	dmaengine_pause(netcp->rx_channel);
+
+	spin_unlock_irqrestore(&netcp->lock, flags);
+
+	napi_disable(&netcp->napi);
+
+	if (netcp->rx_channel) {
+		dma_release_channel(netcp->rx_channel);
+		netcp->rx_channel = NULL;
+	}
+
+	netcp_set_rx_state(netcp, RX_STATE_INVALID);
+
+	netcp_addr_clear_mark(netcp);
+	netcp_addr_sweep_del(netcp);
+
+	for_each_module(netcp, intf_modpriv) {
+		module = intf_modpriv->netcp_module;
+		if (module->close != NULL) {
+			err = module->close(intf_modpriv->module_priv, ndev);
+			if (err != 0) {
+				dev_err(netcp->dev, "Close failed\n");
+				goto out;
+			}
+		}
+	}
+out:
+	dev_dbg(netcp->dev, "netcp device %s stopped\n", ndev->name);
+
+	return 0;
+}
+
+static int netcp_ndo_ioctl(struct net_device *ndev,
+			   struct ifreq *req, int cmd)
+{
+	struct netcp_priv *netcp = netdev_priv(ndev);
+	struct netcp_intf_modpriv *intf_modpriv;
+	struct netcp_module *module;
+	int ret = -1, err = -EOPNOTSUPP;
+
+	if (!netif_running(ndev))
+		return -EINVAL;
+
+	for_each_module(netcp, intf_modpriv) {
+		module = intf_modpriv->netcp_module;
+		if (!module->ioctl)
+			continue;
+
+		err = module->ioctl(intf_modpriv->module_priv, req, cmd);
+		if ((err < 0) && (err != -EOPNOTSUPP))
+			return err;
+		if (err == 0)
+			ret = err;
+	}
+
+	return (ret == 0) ? 0 : err;
+}
+
+static int netcp_ndo_change_mtu(struct net_device *ndev, int new_mtu)
+{
+	struct netcp_priv *netcp = netdev_priv(ndev);
+	int old_max_frame = ndev->mtu + ETH_HLEN + ETH_FCS_LEN;
+	int max_frame = new_mtu + ETH_HLEN + ETH_FCS_LEN;
+	unsigned long flags;
+	int ret = 0;
+
+	spin_lock_irqsave(&netcp->lock, flags);
+
+	netif_tx_stop_all_queues(ndev);
+	netif_carrier_off(ndev);
+
+	BUG_ON(!netcp_is_alive(netcp));
+
+	netcp_set_rx_state(netcp, RX_STATE_TEARDOWN);
+
+	dmaengine_pause(netcp->rx_channel);
+
+	spin_unlock_irqrestore(&netcp->lock, flags);
+
+	napi_disable(&netcp->napi);
+
+	netcp_set_rx_state(netcp, RX_STATE_INVALID);
+
+	/* MTU < 68 is an error for IPv4 traffic, just don't allow it */
+	if ((new_mtu < 68) ||
+	    (max_frame > NETCP_MAX_FRAME_SIZE)) {
+		dev_err(netcp->dev, "Invalid mtu size = %d\n", new_mtu);
+		ret = -EINVAL;
+		goto out_change_mtu;
+	}
+
+	if (old_max_frame == max_frame) {
+		ret = 0;
+		goto out_change_mtu;
+	}
+
+	netcp->rx_packet_max = max_frame;
+
+	ndev->mtu = new_mtu;
+
+out_change_mtu:
+	netcp_set_rx_state(netcp, RX_STATE_INTERRUPT);
+
+	dmaengine_resume(netcp->rx_channel);
+
+	napi_enable(&netcp->napi);
+
+	netif_tx_start_all_queues(ndev);
+	netif_carrier_on(ndev);
+
+	return ret;
+}
+
+static void netcp_ndo_tx_timeout(struct net_device *ndev)
+{
+	struct netcp_priv *netcp = netdev_priv(ndev);
+
+	dev_err(netcp->dev, "transmit timed out\n");
+	/* FIXME: Need to unstall the DMAs */
+	netif_tx_wake_all_queues(ndev);
+}
+
+static int netcp_rx_add_vid(struct net_device *ndev, u16 vid)
+{
+	struct netcp_priv *netcp = netdev_priv(ndev);
+	struct netcp_intf_modpriv *intf_modpriv;
+	struct netcp_module *module;
+	unsigned long flags;
+	int err = 0;
+
+	dev_info(netcp->dev, "adding rx vlan id: %d\n", vid);
+
+	spin_lock_irqsave(&netcp->lock, flags);
+
+	for_each_module(netcp, intf_modpriv) {
+		module = intf_modpriv->netcp_module;
+		if ((module->add_vid != NULL) && (vid != 0)) {
+			err = module->add_vid(intf_modpriv->module_priv, vid);
+			if (err != 0) {
+				dev_err(netcp->dev, "Could not add "
+					"vlan id = %d\n", vid);
+				return -ENODEV;
+			}
+		}
+	}
+
+	spin_unlock_irqrestore(&netcp->lock, flags);
+
+	return 0;
+}
+
+static int netcp_rx_kill_vid(struct net_device *ndev, u16 vid)
+{
+	struct netcp_priv *netcp = netdev_priv(ndev);
+	struct netcp_intf_modpriv *intf_modpriv;
+	struct netcp_module *module;
+	int err = 0;
+
+	dev_info(netcp->dev, "removing rx vlan id: %d\n", vid);
+
+	for_each_module(netcp, intf_modpriv) {
+		module = intf_modpriv->netcp_module;
+		if (module->del_vid != NULL) {
+			err = module->del_vid(intf_modpriv->module_priv, vid);
+			if (err != 0) {
+				dev_err(netcp->dev, "Could not delete "
+					"vlan id = %d\n", vid);
+				return -ENODEV;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static u16 netcp_select_queue(struct net_device *dev, struct sk_buff *skb)
+{
+	return 0;
+}
+
+static int netcp_setup_tc(struct net_device *dev, u8 num_tc)
+{
+	int i;
+
+	/* setup tc must be called under rtnl lock */
+	ASSERT_RTNL();
+
+	/* Sanity-check the number of traffic classes requested */
+	if ((dev->real_num_tx_queues <= 1) || (dev->real_num_tx_queues < num_tc))
+		return -EINVAL;
+
+	/* Configure traffic class to queue mappings */
+	if (num_tc) {
+		netdev_set_num_tc(dev, num_tc);
+		for (i = 0; i < num_tc; i++)
+			netdev_set_tc_queue(dev, i, 1, i);
+	} else {
+		netdev_reset_tc(dev);
+	}
+
+	return 0;
+}
+
+u32 netcp_get_streaming_switch(struct netcp_device *netcp_device, int port)
+{
+	u32	reg;
+
+	reg = __raw_readl(netcp_device->streaming_switch);
+	return (port == 0) ? reg : (reg >> ((port - 1) * 8)) & 0xff;
+}
+EXPORT_SYMBOL(netcp_get_streaming_switch);
+
+u32 netcp_set_streaming_switch(struct netcp_device *netcp_device,
+				int port, u32 new_value)
+{
+	u32	reg;
+	u32	old_value;
+
+	reg = __raw_readl(netcp_device->streaming_switch);
+
+	if (port == 0) {
+		old_value = reg;
+		reg = (new_value << 24) | (new_value << 16) |
+			(new_value << 8) | new_value;
+	} else {
+		int shift = (port - 1) * 8;
+		old_value = (reg >> shift) & 0xff;
+		reg &= ~(0xff << shift);
+		reg |= (new_value & 0xff) << shift;
+	}
+
+	__raw_writel(reg, netcp_device->streaming_switch);
+	return old_value;
+}
+EXPORT_SYMBOL(netcp_set_streaming_switch);
+
+
+static const struct net_device_ops netcp_netdev_ops = {
+	.ndo_open		= netcp_ndo_open,
+	.ndo_stop		= netcp_ndo_stop,
+	.ndo_start_xmit		= netcp_ndo_start_xmit,
+	.ndo_set_rx_mode	= netcp_set_rx_mode,
+	.ndo_do_ioctl           = netcp_ndo_ioctl,
+	.ndo_change_mtu		= netcp_ndo_change_mtu,
+	.ndo_set_mac_address	= eth_mac_addr,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_vlan_rx_add_vid	= netcp_rx_add_vid,
+	.ndo_vlan_rx_kill_vid	= netcp_rx_kill_vid,
+	.ndo_tx_timeout		= netcp_ndo_tx_timeout,
+	.ndo_select_queue	= netcp_select_queue,
+	.ndo_setup_tc		= netcp_setup_tc,
+};
+
+int netcp_create_interface(struct netcp_device *netcp_device,
+			   struct net_device **ndev_p,
+			   const char *ifname_proto,
+			   int tx_queues, int rx_queues, int cpsw_port)
+{
+	struct platform_device *pdev = netcp_device->platform_device;
+	struct device_node *node = pdev->dev.of_node;
+	struct device_node *node_ifgroup;
+	struct device_node *node_interface;
+	struct netcp_inst_modpriv *inst_modpriv;
+	struct netcp_priv *netcp;
+	struct net_device *ndev;
+	resource_size_t size;
+	struct resource res;
+	void __iomem *efuse = NULL;
+	u32 efuse_mac = 0;
+	const void *mac_addr;
+	u8 efuse_mac_addr[6];
+	int ret = 0;
+
+	ndev = alloc_netdev_mqs(sizeof(struct netcp_priv),
+			(ifname_proto ? ifname_proto : "eth%d"),
+			ether_setup, tx_queues, rx_queues);
+	*ndev_p = ndev;
+	if (!ndev) {
+		dev_err(&pdev->dev, "Error allocating net_device\n");
+		ret = -ENOMEM;
+		goto probe_quit;
+	}
+	dev_dbg(&pdev->dev, "%s(): ndev = %p\n", __func__, ndev);
+	ndev->features |= NETIF_F_SG;
+	ndev->features |= NETIF_F_FRAGLIST;
+
+	ndev->features |= NETIF_F_HW_VLAN_FILTER;
+	ndev->hw_features = ndev->features;
+
+	ndev->vlan_features |= NETIF_F_TSO |
+				NETIF_F_TSO6 |
+				NETIF_F_IP_CSUM |
+				NETIF_F_IPV6_CSUM |
+				NETIF_F_SG|
+				NETIF_F_FRAGLIST;
+
+	netcp = netdev_priv(ndev);
+	spin_lock_init(&netcp->lock);
+	INIT_LIST_HEAD(&netcp->module_head);
+	INIT_LIST_HEAD(&netcp->txhook_list_head);
+	INIT_LIST_HEAD(&netcp->rxhook_list_head);
+	INIT_LIST_HEAD(&netcp->addr_list);
+	netcp->netcp_device = netcp_device;
+	netcp->pdev = netcp_device->platform_device;
+	netcp->ndev = ndev;
+	netcp->dev  = &ndev->dev;
+	netcp->cpsw_port = cpsw_port;
+	netcp->msg_enable = netif_msg_init(netcp_debug_level, NETCP_DEBUG);
+	netcp->rx_packet_max = netcp_rx_packet_max;
+	netcp_set_rx_state(netcp, RX_STATE_INVALID);
+
+	node_ifgroup = of_get_child_by_name(node, "interfaces");
+	if (!node_ifgroup) {
+		dev_info(&pdev->dev, "could not find group \"interfaces\", "
+				     "defaulting to parent\n");
+		node_interface = node;
+	} else {
+		char node_name[24];
+		snprintf(node_name, sizeof(node_name), "interface-%d",
+			 (cpsw_port == 0) ? 0 : (cpsw_port - 1));
+		node_interface = of_get_child_by_name(node_ifgroup, node_name);
+		if (!node_interface) {
+			dev_err(&pdev->dev, "could not find %s\n", node_name);
+			of_node_put(node_ifgroup);
+			ret = -ENODEV;
+			goto probe_quit;
+		}
+		dev_dbg(&pdev->dev, "Using node \"%s\"\n", node_name);
+	}
+
+	ret = of_property_read_u32(node_interface, "efuse-mac", &efuse_mac);
+	if (efuse_mac) {
+		if (of_address_to_resource(node, 1, &res)) {
+			dev_err(&pdev->dev, "could not find resource\n");
+			ret = -ENODEV;
+			goto probe_quit;
+		}
+		size = resource_size(&res);
+
+		if (!devm_request_mem_region(&pdev->dev, res.start, size,
+					     dev_name(&pdev->dev))) {
+			dev_err(&pdev->dev, "could not reserve resource\n");
+			ret = -ENOMEM;
+			goto probe_quit;
+		}
+
+		efuse = devm_ioremap_nocache(&pdev->dev, res.start, size);
+		if (!efuse) {
+			dev_err(&pdev->dev, "could not map resource\n");
+			devm_release_mem_region(&pdev->dev, res.start, size);
+			ret = -ENOMEM;
+			goto probe_quit;
+		}
+
+		emac_arch_get_mac_addr(efuse_mac_addr, efuse);
+		if (is_valid_ether_addr(efuse_mac_addr))
+			memcpy(ndev->dev_addr, efuse_mac_addr, ETH_ALEN);
+		else
+			random_ether_addr(ndev->dev_addr);
+
+		devm_iounmap(&pdev->dev, efuse);
+		devm_release_mem_region(&pdev->dev, res.start, size);
+	} else {
+		mac_addr = of_get_mac_address(node_interface);
+		if (mac_addr)
+			memcpy(ndev->dev_addr, mac_addr, ETH_ALEN);
+		else
+			random_ether_addr(ndev->dev_addr);
+	}
+
+	ret = of_property_read_string(node_interface, "rx-channel",
+				      &netcp->rx_chan_name);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "missing \"rx-channel\" parameter\n");
+		netcp->rx_chan_name = "netrx";
+	}
+
+	ret = of_property_read_u32_array(node_interface, "rx-queue-depth",
+			netcp->rx_queue_depths, KEYSTONE_QUEUES_PER_CHAN);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "missing \"rx-queue-depth\" parameter\n");
+		netcp->rx_queue_depths[0] = 128;
+	}
+
+	ret = of_property_read_u32_array(node_interface, "rx-buffer-size",
+			netcp->rx_buffer_sizes, KEYSTONE_QUEUES_PER_CHAN);
+	if (ret) {
+		dev_err(&pdev->dev, "missing \"rx-buffer-size\" parameter\n");
+		netcp->rx_buffer_sizes[0] = 1500;
+	}
+
+	if (node_ifgroup) {
+		of_node_put(node_interface);
+		of_node_put(node_ifgroup);
+		node_interface = NULL;
+		node_ifgroup = NULL;
+	}
+
+	/* NAPI register */
+	netif_napi_add(ndev, &netcp->napi, netcp_poll, NETCP_NAPI_WEIGHT);
+
+	/* Register the network device */
+	ndev->dev_id		= 0;
+	ndev->watchdog_timeo	= NETCP_TX_TIMEOUT;
+	ndev->netdev_ops	= &netcp_netdev_ops;
+
+	SET_NETDEV_DEV(ndev, &pdev->dev);
+
+	ret = register_netdev(ndev);
+	if (ret) {
+		dev_err(netcp->dev, "Error registering net device\n");
+		ret = -ENODEV;
+		goto clean_ndev_ret;
+	}
+	dev_info(&pdev->dev, "Created interface \"%s\"\n", ndev->name);
+	list_add_tail(&netcp->interface_list, &netcp_device->interface_head);
+
+	/* Notify each registered module of the new interface */
+	list_for_each_entry(inst_modpriv, &netcp_device->modpriv_head, inst_list) {
+		struct netcp_module *module = inst_modpriv->netcp_module;
+		struct netcp_intf_modpriv *intf_modpriv;
+
+		intf_modpriv = kzalloc(sizeof(*intf_modpriv), GFP_KERNEL);
+		if (!intf_modpriv) {
+			dev_err(&pdev->dev, "Error allocating intf_modpriv for %s\n",
+					module->name);
+			continue;
+		}
+
+		intf_modpriv->netcp_priv = netcp;
+		intf_modpriv->netcp_module = module;
+		list_add_tail(&intf_modpriv->intf_list, &netcp->module_head);
+
+		dev_dbg(&pdev->dev, "Attaching module \"%s\"\n", module->name);
+		ret = module->attach(inst_modpriv->module_priv, ndev, &intf_modpriv->module_priv);
+		if (ret) {
+			dev_info(&pdev->dev, "Attach of module %s declined with %d\n",
+					module->name, ret);
+			list_del(&intf_modpriv->intf_list);
+			kfree(intf_modpriv);
+			continue;
+		}
+	}
+
+	return 0;
+
+clean_ndev_ret:
+	free_netdev(ndev);
+probe_quit:
+	*ndev_p = NULL;
+	return ret;
+}
+EXPORT_SYMBOL(netcp_create_interface);
+
+void netcp_delete_interface(struct netcp_device *netcp_device,
+			    struct net_device *ndev)
+{
+	struct netcp_intf_modpriv *intf_modpriv, *tmp;
+	struct netcp_priv *netcp = netdev_priv(ndev);
+	struct netcp_module *module;
+
+	dev_info(&netcp_device->platform_device->dev,
+			"Removing interface \"%s\"\n", ndev->name);
+
+	/* Notify each of the modules that the interface is going away */
+	list_for_each_entry_safe(intf_modpriv, tmp, &netcp->module_head, intf_list) {
+		module = intf_modpriv->netcp_module;
+		dev_dbg(&netcp_device->platform_device->dev,
+				"Releasing module \"%s\"\n", module->name);
+		if (module->release)
+			module->release(intf_modpriv->module_priv);
+		list_del(&intf_modpriv->intf_list);
+		kfree(intf_modpriv);
+	}
+	WARN(!list_empty(&netcp->module_head),
+			"%s interface module list is not empty!\n", ndev->name);
+
+	list_del(&netcp->interface_list);
+
+	unregister_netdev(ndev);
+	netif_napi_del(&netcp->napi);
+	free_netdev(ndev);
+}
+EXPORT_SYMBOL(netcp_delete_interface);
+
+
+static int netcp_probe(struct platform_device *pdev)
+{
+	struct device_node *node = pdev->dev.of_node;
+	struct device_node *child;
+	struct netcp_device *netcp_device;
+	struct netcp_module *module;
+	struct netcp_inst_modpriv *inst_modpriv;
+	const char *name;
+	u32 temp[4];
+	int ret;
+
+	if (!node) {
+		dev_err(&pdev->dev, "could not find device info\n");
+		return -EINVAL;
+	}
+
+	/* Allocate a new NETCP device instance */
+	netcp_device = kzalloc(sizeof(*netcp_device), GFP_KERNEL);
+	if (!netcp_device) {
+		dev_err(&pdev->dev, "failure allocating NETCP device\n");
+		return -ENOMEM;
+	}
+	dev_dbg(&pdev->dev, "%s(): netcp_device = %p\n", __func__, netcp_device);
+
+	/* Initialize the NETCP device instance */
+	INIT_LIST_HEAD(&netcp_device->interface_head);
+	INIT_LIST_HEAD(&netcp_device->modpriv_head);
+	netcp_device->platform_device = pdev;
+	platform_set_drvdata(pdev, netcp_device);
+
+	/* Map the Streaming Switch */
+	if (of_property_read_u32_array(node, "streaming-regs",
+					(u32 *)&(temp[0]), 2)) {
+		dev_err(&pdev->dev, "No streaming regs defined\n");
+	} else {
+		netcp_device->streaming_switch =
+			devm_ioremap_nocache(&pdev->dev, temp[0], temp[1]);
+		if (!netcp_device->streaming_switch) {
+			dev_err(&pdev->dev, "can't map streaming switch\n");
+			ret = -ENOMEM;
+			goto probe_quit;
+		}
+	}
+
+	/* Add the device instance to the list */
+	list_add_tail(&netcp_device->device_list, &netcp_devices);
+
+	/* Probe any modules already registered */
+	for_each_child_of_node(node, child) {
+		name = netcp_node_name(child);
+		module = netcp_find_module(name);
+		if (!module)
+			continue;
+
+		inst_modpriv = kzalloc(sizeof(*inst_modpriv), GFP_KERNEL);
+		if (!inst_modpriv) {
+			dev_err(&pdev->dev, "Failed to allocate instance for for %s\n", name);
+			continue;	/* FIXME: Fail instead? */
+		}
+		inst_modpriv->netcp_device = netcp_device;
+		inst_modpriv->netcp_module = module;
+		list_add_tail(&inst_modpriv->inst_list, &netcp_device->modpriv_head);
+
+		dev_dbg(&pdev->dev, "%s(): probing module \"%s\"\n", __func__, name);
+		ret = module->probe(netcp_device, &pdev->dev, child, &inst_modpriv->module_priv);
+		if (ret) {
+			dev_warn(&pdev->dev, "Probe of module %s failed with %d\n", name, ret);
+			list_del(&inst_modpriv->inst_list);
+			kfree(inst_modpriv);
+			continue;
+		}
+	}
+
+	return 0;
+
+probe_quit:
+	platform_set_drvdata(pdev, NULL);
+	kfree(netcp_device);
+	return ret;
+}
+
+static int netcp_remove(struct platform_device *pdev)
+{
+	struct netcp_device *netcp_device = platform_get_drvdata(pdev);
+	struct netcp_inst_modpriv *inst_modpriv, *tmp;
+	struct netcp_module *module;
+
+	list_for_each_entry_safe(inst_modpriv, tmp, &netcp_device->modpriv_head, inst_list) {
+		module = inst_modpriv->netcp_module;
+		dev_dbg(&pdev->dev, "Removing module \"%s\"\n", module->name);
+		module->remove(netcp_device, inst_modpriv->module_priv);
+		list_del(&inst_modpriv->inst_list);
+		kfree(inst_modpriv);
+	}
+	WARN(!list_empty(&netcp_device->interface_head),
+			"%s interface list not empty!\n", pdev->name);
+
+	/* Unmap the Streaming Switch */
+	if (netcp_device->streaming_switch)
+		devm_iounmap(&pdev->dev, netcp_device->streaming_switch);
+
+	platform_set_drvdata(pdev, NULL);
+	kfree(netcp_device);
+	return 0;
+}
+
+static struct of_device_id of_match[] = {
+	{ .compatible = "ti,keystone-netcp", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, of_match);
+
+static struct platform_driver netcp_driver = {
+	.driver = {
+		.name		= "keystone-netcp",
+		.owner		= THIS_MODULE,
+		.of_match_table	= of_match,
+	},
+	.probe = netcp_probe,
+	.remove = netcp_remove,
+};
+
+extern int  keystone_cpsw_init(void);
+extern void keystone_cpsw_exit(void);
+#ifdef CONFIG_TI_KEYSTONE_XGE
+extern int  keystone_cpswx_init(void);
+extern void keystone_cpswx_exit(void);
+#endif
+
+static int __init netcp_init(void)
+{
+	int err;
+
+	/* Create a cache for these commonly-used structures */
+	netcp_pinfo_cache = kmem_cache_create("netcp_pinfo_cache",
+			sizeof(struct netcp_packet), sizeof(void *),
+			0, NULL);
+	if (!netcp_pinfo_cache)
+		return -ENOMEM;
+
+	err = platform_driver_register(&netcp_driver);
+	if (err)
+		goto netcp_fail;
+
+	err = keystone_cpsw_init();
+	if (err)
+		goto cpsw_fail;
+
+#ifdef CONFIG_TI_KEYSTONE_XGE
+	err = keystone_cpswx_init();
+	if (err)
+		goto cpsw_fail;
+#endif
+
+	return 0;
+
+cpsw_fail:
+	platform_driver_unregister(&netcp_driver);
+netcp_fail:
+	kmem_cache_destroy(netcp_pinfo_cache);
+	netcp_pinfo_cache = NULL;
+	return err;
+}
+module_init(netcp_init);
+
+static void __exit netcp_exit(void)
+{
+	keystone_cpsw_exit();
+#ifdef CONFIG_TI_KEYSTONE_XGE
+	keystone_cpswx_exit();
+#endif
+	platform_driver_unregister(&netcp_driver);
+	kmem_cache_destroy(netcp_pinfo_cache);
+	netcp_pinfo_cache = NULL;
+}
+module_exit(netcp_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("TI Keystone Ethernet driver");
diff --git a/drivers/net/ethernet/ti/keystone_net_sa.c b/drivers/net/ethernet/ti/keystone_net_sa.c
new file mode 100644
index 0000000..6722947
--- /dev/null
+++ b/drivers/net/ethernet/ti/keystone_net_sa.c
@@ -0,0 +1,253 @@
+/*
+ * Copyright (C) 2012 Texas Instruments Incorporated
+ * Authors: Sandeep Nair <sandeep_n@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/interrupt.h>
+#include <linux/byteorder/generic.h>
+#include <linux/platform_device.h>
+#include <linux/keystone-dma.h>
+#include <linux/errqueue.h>
+
+#include "keystone_net.h"
+#include "keystone_pasahost.h"
+
+struct sa_device {
+	struct netcp_device		*netcp_device;
+	struct net_device		*net_device;		/* FIXME */
+	struct device			*dev;
+	const char			*tx_chan_name;
+	u32				 tx_queue_depth;
+	struct netcp_tx_pipe		 tx_pipe;
+	struct device_node		*node;
+	u32				 multi_if;
+};
+
+struct ipsecmgr_mod_sa_ctx_info {
+	u32 word0;
+	u32 word1;
+	u16 flow_id;
+};
+
+/**
+ * Used to update the destination information within swInfo[2]
+ */
+
+#define SA_SWINFO_UPDATE_DEST_INFO(info, queueID, flowID) \
+{ \
+	(info[0]) |= 0x40000000L; \
+	(info[2]) = ((queueID)) | (((flowID) & 0xFF) << 16) | \
+	((info[2]) & 0xFF000000L); \
+}
+
+#define	SA_TXHOOK_ORDER	30
+
+static int sa_tx_hook(int order, void *data, struct netcp_packet *p_info)
+{
+	struct sa_device *sa_dev = data;
+	u16 offset, len, ihl;
+	u32 *psdata, *swinfo;
+	const struct iphdr *iph;
+	struct ipsecmgr_mod_sa_ctx_info *ctx_info =
+			(struct ipsecmgr_mod_sa_ctx_info *)p_info->skb->sp;
+
+	if (!ctx_info)
+		return 0;
+
+	iph = ip_hdr(p_info->skb);
+
+	if (iph->version != IPVERSION)
+		return 0;
+
+	ihl = iph->ihl * 4;
+
+	if (iph->protocol == IPPROTO_UDP) {
+		/* UDP encapsulation for IPSec NAT-T */
+		offset = (ulong)(skb_network_header(p_info->skb) -
+			p_info->skb->data) + ihl + sizeof(struct udphdr);
+		len = ntohs(iph->tot_len) - ihl - sizeof(struct udphdr);
+	} else if (iph->protocol == IPPROTO_ESP) {
+		offset = (ulong)(skb_network_header(p_info->skb) -
+			p_info->skb->data) + ihl;
+		len = ntohs(iph->tot_len) - ihl;
+	} else {
+	    return 0;
+	}
+
+	psdata = netcp_push_psdata(p_info, (2 * sizeof(u32)));
+	if (!psdata)
+		return -ENOMEM;
+
+	psdata[0] = PASAHO_SINFO_FORMAT_CMD(offset, len);
+	psdata[1] = 0;
+	swinfo = &p_info->epib[1];
+	swinfo[0] = ctx_info->word0;
+	swinfo[1] = ctx_info->word1;
+	SA_SWINFO_UPDATE_DEST_INFO(swinfo, p_info->tx_pipe->dma_queue,
+			ctx_info->flow_id);
+
+	p_info->tx_pipe = &sa_dev->tx_pipe;
+	kfree(ctx_info);
+	p_info->skb->sp = NULL;
+	return 0;
+}
+
+static int sa_close(void *intf_priv, struct net_device *ndev)
+{
+	struct sa_device *sa_dev = intf_priv;
+	struct netcp_priv *netcp_priv = netdev_priv(ndev);
+
+	netcp_unregister_txhook(netcp_priv, SA_TXHOOK_ORDER, sa_tx_hook, sa_dev);
+
+	netcp_txpipe_close(&sa_dev->tx_pipe);
+
+	return 0;
+}
+
+static int sa_open(void *intf_priv, struct net_device *ndev)
+{
+	struct sa_device *sa_dev = intf_priv;
+	struct netcp_priv *netcp_priv = netdev_priv(ndev);
+	int ret;
+
+	/* Open the SA IPSec data transmit channel */
+	ret = netcp_txpipe_open(&sa_dev->tx_pipe);
+	if (ret)
+		goto fail;
+
+	netcp_register_txhook(netcp_priv, SA_TXHOOK_ORDER, sa_tx_hook, sa_dev);
+	return 0;
+
+fail:
+	sa_close(intf_priv, ndev);
+	return ret;
+}
+
+static int sa_attach(void *inst_priv, struct net_device *ndev, void **intf_priv)
+{
+	struct netcp_priv *netcp = netdev_priv(ndev);
+	struct sa_device *sa_dev = inst_priv;
+	char node_name[24];
+
+	snprintf(node_name, sizeof(node_name), "interface-%d",
+		 (sa_dev->multi_if) ? (netcp->cpsw_port - 1) : 0);
+
+	if (of_find_property(sa_dev->node, node_name, NULL)) {
+		sa_dev->net_device = ndev;
+		*intf_priv = sa_dev;
+
+		netcp_txpipe_init(&sa_dev->tx_pipe, netdev_priv(ndev),
+				  sa_dev->tx_chan_name, sa_dev->tx_queue_depth);
+
+		sa_dev->tx_pipe.dma_psflags = netcp->cpsw_port;
+
+		return 0;
+	} else
+		return -ENODEV;
+}
+
+static int sa_release(void *intf_priv)
+{
+	struct sa_device *sa_dev = intf_priv;
+
+	printk("%s() called for interface %s\n", __func__, sa_dev->net_device->name);
+	sa_dev->net_device = NULL;
+	return 0;
+}
+
+static int sa_remove(struct netcp_device *netcp_device, void *inst_priv)
+{
+	struct sa_device *sa_dev = inst_priv;
+	kfree(sa_dev);
+	return 0;
+}
+
+static int sa_probe(struct netcp_device *netcp_device,
+		    struct device *dev,
+		    struct device_node *node,
+		    void **inst_priv)
+{
+	struct sa_device *sa_dev;
+	int ret = 0;
+
+	if (!node) {
+		dev_err(dev, "device tree info unavailable\n");
+		return -ENODEV;
+	}
+
+	sa_dev = devm_kzalloc(dev, sizeof(struct sa_device), GFP_KERNEL);
+	if (!sa_dev) {
+		dev_err(dev, "memory allocation failed\n");
+		return -ENOMEM;
+	}
+	*inst_priv = sa_dev;
+	sa_dev->dev = dev;
+
+	sa_dev->node = node;
+
+	if (of_find_property(node, "multi-interface", NULL))
+		sa_dev->multi_if = 1;
+
+	ret = of_property_read_string(node, "tx-channel", &sa_dev->tx_chan_name);
+	if (ret < 0) {
+		dev_err(dev, "missing \"tx-channel\" parameter, err %d\n", ret);
+		sa_dev->tx_chan_name = "satx";
+	}
+	dev_dbg(dev, "tx-channel \"%s\"\n", sa_dev->tx_chan_name);
+
+	ret = of_property_read_u32(node, "tx_queue_depth",
+				   &sa_dev->tx_queue_depth);
+	if (ret < 0) {
+		dev_err(dev, "missing tx_queue_depth parameter, err %d\n", ret);
+		sa_dev->tx_queue_depth = 32;
+	}
+	dev_dbg(dev, "tx_queue_depth %u\n", sa_dev->tx_queue_depth);
+
+	return 0;
+}
+
+static struct netcp_module sa_module = {
+	.name		= "keystone-sa",
+	.owner		= THIS_MODULE,
+	.probe		= sa_probe,
+	.open		= sa_open,
+	.close		= sa_close,
+	.remove		= sa_remove,
+	.attach		= sa_attach,
+	.release	= sa_release,
+};
+
+static int __init keystone_sa_init(void)
+{
+	return netcp_register_module(&sa_module);
+}
+module_init(keystone_sa_init);
+
+static void __exit keystone_sa_exit(void)
+{
+	netcp_unregister_module(&sa_module);
+}
+module_exit(keystone_sa_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Sandeep Nair <sandeep_n@ti.com>");
+MODULE_DESCRIPTION("IPSec driver for Keystone devices");
+
diff --git a/drivers/net/ethernet/ti/keystone_pa.c b/drivers/net/ethernet/ti/keystone_pa.c
new file mode 100644
index 0000000..4fc4e75
--- /dev/null
+++ b/drivers/net/ethernet/ti/keystone_pa.c
@@ -0,0 +1,2473 @@
+/*
+ * Copyright (C) 2012 Texas Instruments Incorporated
+ * Authors: Sandeep Paulraj <s-paulraj@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/firmware.h>
+#include <linux/spinlock.h>
+#include <linux/highmem.h>
+#include <linux/interrupt.h>
+#include <linux/dmaengine.h>
+#include <linux/net_tstamp.h>
+#include <linux/dma-mapping.h>
+#include <linux/scatterlist.h>
+#include <linux/byteorder/generic.h>
+#include <linux/platform_device.h>
+#include <linux/keystone-dma.h>
+#include <linux/phy.h>
+#include <linux/errqueue.h>
+#include <linux/ptp_classify.h>
+#include <net/sctp/checksum.h>
+#include <linux/clocksource.h>
+
+#include "keystone_net.h"
+#include "keystone_pa.h"
+#include "keystone_pasahost.h"
+
+#define DEVICE_PA_PDSP02_FIRMWARE "keystone/pa_pdsp02_classify1.fw"
+#define DEVICE_PA_PDSP3_FIRMWARE "keystone/pa_pdsp3_classify2.fw"
+#define DEVICE_PA_PDSP45_FIRMWARE "keystone/pa_pdsp45_pam.fw"
+
+#define	PA_NETIF_FEATURES	(NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM)
+
+#define PSTREAM_ROUTE_PDSP0	0
+
+#define PA_PDSP_ALREADY_ACTIVE	0
+#define PA_PDSP_RESET_RELEASED	1
+#define PA_PDSP_NO_RESTART	2
+#define PA_MAX_PDSP_ENABLE_LOOP_COUNT	100000
+
+#define PA_INVALID_PORT			0xff
+
+#define PA_STATE_RESET			0  /* Sub-system state reset */
+#define PA_STATE_ENABLE			1  /* Sub-system state enable  */
+#define PA_STATE_QUERY			2  /* Query the Sub-system state */
+#define PA_STATE_INCONSISTENT		3  /* Sub-system is partially enabled */
+#define PA_STATE_INVALID_REQUEST	4  /* Invalid state command to the Sub-system */
+#define PA_STATE_ENABLE_FAILED		5  /*  The Sub-system did not respond after restart */
+
+/* System Timestamp */
+#define PAFRM_SRAM_SIZE			0x2000
+#define PAFRM_SYS_TIMESTAMP_ADDR	0x6460
+
+/* PDSP Versions */
+#define PAFRM_PDSP_VERSION_BASE		0x7F04
+
+#define DEVICE_PA_BASE				0x02000000
+#define DEVICE_PA_REGION_SIZE			0x48000
+#define DEVICE_PA_NUM_PDSPS			6
+
+#define PA_MEM_PDSP_IRAM(pdsp)			((pdsp) * 0x8000)
+#define PA_MEM_PDSP_SRAM(num)			((num) * 0x2000)
+#define PA_REG_PKTID_SOFT_RESET	                0x00404
+#define PA_REG_LUT2_SOFT_RESET	                0x00504
+#define PA_REG_STATS_SOFT_RESET	                0x06004
+
+#define PA_PDSP_CONST_REG_INDEX_C25_C24     0
+#define PA_PDSP_CONST_REG_INDEX_C27_C26     1
+#define PA_PDSP_CONST_REG_INDEX_C29_C28     2
+#define PA_PDSP_CONST_REG_INDEX_C31_C30     3
+
+/* The pdsp control register */
+#define PA_REG_VAL_PDSP_CTL_DISABLE_PDSP	1
+#define PA_REG_VAL_PDSP_CTL_RESET_PDSP	        0
+#define PA_REG_VAL_PDSP_CTL_STATE               (1 << 15)
+#define PA_REG_VAL_PDSP_CTL_ENABLE              (1 << 1)
+#define PA_REG_VAL_PDSP_CTL_SOFT_RESET          (1 << 0)
+#define PA_REG_VAL_PDSP_CTL_ENABLE_PDSP(pcval)	(((pcval) << 16)	\
+						 | PA_REG_VAL_PDSP_CTL_ENABLE \
+						 | PA_REG_VAL_PDSP_CTL_SOFT_RESET)
+
+/* Number of mailbox slots for each PDPS */
+#define PA_NUM_MAILBOX_SLOTS	4
+#define TEST_SWINFO0_TIMESTAMP	0x12340002
+
+#define PACKET_DROP	0
+#define PACKET_PARSE	1
+#define PACKET_HST	2
+
+#define NT 32
+
+#define PA_SGLIST_SIZE	3
+
+static struct sock_filter ptp_filter[] = {
+	PTP_FILTER
+};
+
+static bool need_timestamp(const struct sk_buff *skb)
+{
+	unsigned type = PTP_CLASS_NONE;
+
+	if (likely(skb->dev &&
+		   skb->dev->phydev &&
+		   skb->dev->phydev->drv &&
+		   skb->dev->phydev->drv->txtstamp))
+		type = sk_run_filter(skb, ptp_filter);
+
+	/* if timestamping is handled at the phy, we don't timestamp */
+	switch (type) {
+	case PTP_CLASS_V1_IPV4:
+	case PTP_CLASS_V1_IPV6:
+	case PTP_CLASS_V2_IPV4:
+	case PTP_CLASS_V2_IPV6:
+	case PTP_CLASS_V2_L2:
+	case PTP_CLASS_V2_VLAN:
+		return false;
+	}
+
+	return true;
+}
+
+const u32 pap_pdsp_const_reg_map[6][4] =
+{
+	/* PDSP0: C24-C31 */
+	{
+		0x0000007F,		/* C25-C24 */
+		0x0000006E,		/* C27-C26 */
+		0x00000000,		/* C29-C28 */
+		0x00000000		/* C31-C30 */
+	},
+	/* PDSP1: C24-C31 */
+	{
+		0x0001007F,		/* C25-C24 */
+		0x00480040,		/* C27-C26 */
+		0x00000000,		/* C29-C28 */
+		0x00000000		/* C31-C30 */
+	},
+	/* PDSP2: C24-C31 */
+	{
+		0x0002007F,		/* C25-C24 */
+		0x00490044,		/* C27-C26 */
+		0x00000000,		/* C29-C28 */
+		0x00000000		/* C31-C30 */
+	},
+	/* PDSP3: C24-C31 */
+	{
+		0x0003007F,		/* C25-C24 */
+		0x0000006E,		/* C27-C26 */
+		0x00000000,		/* C29-C28 */
+		0x00000000		/* C31-C30 */
+	},
+	/* PDSP4: C24-C31 */
+	{
+		0x0070007F,		/* C25-C24 */
+		0x00000000,		/* C27-C26 */
+		0x04080404,		/* C29-C28 */
+		0x00000000		/* C31-C30 */
+	},
+	/* PDSP5: C24-C31 */
+	{
+		0x0071007F,		/* C25-C24 */
+		0x00000000,		/* C27-C26 */
+		0x04080404,		/* C29-C28 */
+		0x00000000		/* C31-C30 */
+	}
+};
+
+struct pa_mailbox_regs {
+	u32 pdsp_mailbox_slot0;
+	u32 pdsp_mailbox_slot1;
+	u32 pdsp_mailbox_slot2;
+	u32 pdsp_mailbox_slot3;
+};
+
+struct pa_packet_id_alloc_regs {
+	u32 revision;
+	u32 soft_reset;
+	u32 range_limit;
+	u32 idvalue;
+};
+
+struct pa_lut2_control_regs {
+	u32 revision;
+	u32 soft_reset;
+	u32 rsvd[6];
+	u32 add_data0;
+	u32 add_data1;
+	u32 add_data2;
+	u32 add_data3;
+	u32 add_del_key;
+	u32 add_del_control;
+};
+
+struct pa_pdsp_control_regs {
+	u32 control;
+	u32 status;
+	u32 wakeup_enable;
+	u32 cycle_count;
+	u32 stall_count;
+	u32 rsvd[3];
+	u32 const_tbl_blk_index0;
+	u32 const_tbl_blk_index1;
+	u32 const_tbl_prog_pointer0;
+	u32 const_tbl_prog_pointer1;
+	u32 rsvd1[52];
+};
+
+struct pa_pdsp_timer_regs {
+	u32 timer_control;
+	u32 timer_load;
+	u32 timer_value;
+	u32 timer_interrupt;
+	u32 rsvd[60];
+};
+
+struct pa_statistics_regs {
+	u32 revision;
+	u32 soft_reset;
+	u32 incr_flags;
+	u32 stats_capture;
+	u32 rsvd[4];
+	u32 stats_red[32];
+};
+
+#define	CSUM_OFFLOAD_NONE	0
+#define	CSUM_OFFLOAD_HARD	1
+#define	CSUM_OFFLOAD_SOFT	2
+
+#define	PA_TXHOOK_ORDER	10
+#define	PA_RXHOOK_ORDER	10
+
+static DEFINE_MUTEX(pa_modules_lock);
+
+struct pa_lut_entry {
+	int			index;
+	bool			valid, in_use;
+	struct netcp_addr	*naddr;
+};
+
+struct pa_timestamp_info {
+	u32	mult;
+	u32	shift;
+	u64	system_offset;
+};
+
+struct pa_intf {
+	struct pa_device		*pa_device;
+	struct net_device		*net_device;
+	struct netcp_tx_pipe		 tx_pipe;
+	unsigned			 data_flow_num;
+	unsigned			 data_queue_num;
+	u32				 saved_ss_state;
+	char				 tx_chan_name[24];
+
+	bool				 tx_timestamp_enable;
+	bool				 rx_timestamp_enable;
+};
+
+struct pa_device {
+	struct netcp_device		*netcp_device;
+	struct device			*dev;
+	struct clk			*clk;
+	struct dma_chan			*pdsp0_tx_channel;
+	struct dma_chan			*rx_channel;
+	const char			*rx_chan_name;
+	unsigned			 cmd_flow_num;
+	unsigned			 cmd_queue_num;
+
+	struct pa_timestamp_info	timestamp_info;
+
+	struct pa_mailbox_regs __iomem		*reg_mailbox;
+	struct pa_packet_id_alloc_regs __iomem	*reg_packet_id;
+	struct pa_lut2_control_regs __iomem	*reg_lut2;
+	struct pa_pdsp_control_regs __iomem	*reg_control;
+	struct pa_pdsp_timer_regs   __iomem	*reg_timer;
+	struct pa_statistics_regs   __iomem	*reg_stats;
+	void __iomem				*pa_sram;
+	void __iomem				*pa_iram;
+
+
+	u8				*mc_list;
+	u8				 addr_count;
+	struct tasklet_struct		 task;
+	spinlock_t			 lock;
+
+	u32				 tx_cmd_queue_depth;
+	u32				 tx_data_queue_depth;
+	u32				 rx_pool_depth;
+	u32				 rx_buffer_size;
+	u32				 csum_offload;
+	u32				 txhook_order;
+	u32				 txhook_softcsum;
+	u32				 rxhook_order;
+	u32				 multi_if;
+	u32				 inuse_if_count;
+	u32				 lut_inuse_count;
+	struct pa_lut_entry		 *lut;
+	u32				 lut_size;
+
+	u32				 ts_not_req;
+};
+
+#define pa_from_module(data)	container_of(data, struct pa_device, module)
+#define pa_to_module(pa)	(&(pa)->module)
+
+struct pa_packet {
+	struct scatterlist		 sg[PA_SGLIST_SIZE];
+	int				 sg_ents;
+	struct pa_device		*priv;
+	struct dma_chan			*chan;
+	struct dma_async_tx_descriptor	*desc;
+	dma_cookie_t			 cookie;
+	u32				 epib[4];
+	u32				 psdata[6];
+	struct completion		 complete;
+	void				*data;
+};
+
+static void pdsp_fw_put(u32 *dest, const u32 *src, u32 wc)
+{
+	int i;
+
+	for (i = 0; i < wc; i++)
+		*dest++ = be32_to_cpu(*src++);
+}
+
+static inline void swizFwd (struct pa_frm_forward *fwd)
+{
+	fwd->flow_id = fwd->flow_id;
+	fwd->queue   = cpu_to_be16(fwd->queue);
+
+	if (fwd->forward_type == PAFRM_FORWARD_TYPE_HOST) {
+		fwd->u.host.context      = cpu_to_be32(fwd->u.host.context);
+		fwd->u.host.multi_route  = fwd->u.host.multi_route;
+		fwd->u.host.multi_idx    = fwd->u.host.multi_idx;
+		fwd->u.host.pa_pdsp_router = fwd->u.host.pa_pdsp_router;
+	} else if (fwd->forward_type == PAFRM_FORWARD_TYPE_SA) {
+		fwd->u.sa.sw_info_0 = cpu_to_be32(fwd->u.sa.sw_info_0);
+		fwd->u.sa.sw_info_1 = cpu_to_be32(fwd->u.sa.sw_info_1);
+	} else if (fwd->forward_type == PAFRM_FORWARD_TYPE_SRIO) {
+		fwd->u.srio.ps_info0 = cpu_to_be32(fwd->u.srio.ps_info0);
+		fwd->u.srio.ps_info1 = cpu_to_be32(fwd->u.srio.ps_info1);
+		fwd->u.srio.pkt_type = fwd->u.srio.pkt_type;
+	} else if (fwd->forward_type == PAFRM_FORWARD_TYPE_ETH) {
+		fwd->u.eth.ps_flags	= fwd->u.eth.ps_flags;
+	} else if (fwd->forward_type == PAFRM_FORWARD_TYPE_PA) {
+		fwd->u.pa.pa_dest	= fwd->u.pa.pa_dest;
+		fwd->u.pa.custom_type	= fwd->u.pa.custom_type;
+		fwd->u.pa.custom_idx	= fwd->u.pa.custom_idx;
+	}
+
+	fwd->forward_type = fwd->forward_type;
+}
+
+static inline void swizFcmd (struct pa_frm_command *fcmd)
+{
+	fcmd->command_result =  cpu_to_be32(fcmd->command_result);
+	fcmd->command	     =  fcmd->command;
+	fcmd->magic          =  fcmd->magic;
+	fcmd->com_id         =  cpu_to_be16(fcmd->com_id);
+	fcmd->ret_context    =  cpu_to_be32(fcmd->ret_context);
+	fcmd->reply_queue    =  cpu_to_be16(fcmd->reply_queue);
+	fcmd->reply_dest     =  fcmd->reply_dest;
+	fcmd->flow_id        =  fcmd->flow_id;
+}
+
+static inline void swizAl1 (struct pa_frm_cmd_add_lut1 *al1)
+{
+	al1->index         =  al1->index;
+	al1->type          =  al1->type;
+	al1->cust_index    =  al1->cust_index;
+
+	if (al1->type == PAFRM_COM_ADD_LUT1_STANDARD) {
+		al1->u.eth_ip.etype = cpu_to_be16(al1->u.eth_ip.etype);
+		al1->u.eth_ip.vlan  = cpu_to_be16(al1->u.eth_ip.vlan);
+		al1->u.eth_ip.spi   = cpu_to_be32(al1->u.eth_ip.spi);
+		al1->u.eth_ip.flow  = cpu_to_be32(al1->u.eth_ip.flow);
+
+		if (al1->u.eth_ip.key & PAFRM_LUT1_KEY_MPLS)
+			al1->u.eth_ip.pm.mpls     =  cpu_to_be32(al1->u.eth_ip.pm.mpls);
+		else {
+			al1->u.eth_ip.pm.ports[0] =  cpu_to_be16(al1->u.eth_ip.pm.ports[0]);
+			al1->u.eth_ip.pm.ports[1] =  cpu_to_be16(al1->u.eth_ip.pm.ports[1]);
+		}
+
+		al1->u.eth_ip.proto_next  =  al1->u.eth_ip.proto_next;
+		al1->u.eth_ip.tos_tclass  =  al1->u.eth_ip.tos_tclass;
+		al1->u.eth_ip.inport      =  al1->u.eth_ip.inport;
+		al1->u.eth_ip.key         =  al1->u.eth_ip.key;
+		al1->u.eth_ip.match_flags =  cpu_to_be16(al1->u.eth_ip.match_flags);
+	} else if (al1->type == PAFRM_COM_ADD_LUT1_SRIO) {
+		al1->u.srio.src_id	= cpu_to_be16(al1->u.srio.src_id);
+		al1->u.srio.dest_id	= cpu_to_be16(al1->u.srio.dest_id);
+		al1->u.srio.etype	= cpu_to_be16(al1->u.srio.etype);
+		al1->u.srio.vlan	= cpu_to_be16(al1->u.srio.vlan);
+		al1->u.srio.pri         = al1->u.srio.pri;
+		al1->u.srio.type_param1 = cpu_to_be16(al1->u.srio.type_param1);
+		al1->u.srio.type_param2 = al1->u.srio.type_param2;
+		al1->u.srio.key         = al1->u.srio.key;
+		al1->u.srio.match_flags = cpu_to_be16(al1->u.srio.match_flags);
+		al1->u.srio.next_hdr    = al1->u.srio.next_hdr;
+		al1->u.srio.next_hdr_offset = cpu_to_be16(al1->u.srio.next_hdr_offset);
+	} else {
+		al1->u.custom.etype		=  cpu_to_be16(al1->u.custom.etype);
+		al1->u.custom.vlan		=  cpu_to_be16(al1->u.custom.vlan);
+		al1->u.custom.key		=  al1->u.custom.key;
+		al1->u.custom.match_flags	=  cpu_to_be16(al1->u.custom.match_flags);
+	}
+
+	swizFwd(&(al1->match));
+	swizFwd(&(al1->next_fail));
+}
+
+static int pa_conv_routing_info(struct	pa_frm_forward *fwd_info,
+			 struct	pa_route_info *route_info,
+			 int cmd_dest, u16 fail_route)
+{
+	u8 *pcmd = NULL;
+	fwd_info->flow_id = route_info->flow_id;
+	fwd_info->queue   = route_info->queue;
+
+	if (route_info->dest == PA_DEST_HOST) {
+		fwd_info->forward_type   = PAFRM_FORWARD_TYPE_HOST;
+		fwd_info->u.host.context = route_info->sw_info_0;
+
+		if (route_info->m_route_index >= 0) {
+			if (route_info->m_route_index >= PA_MAX_MULTI_ROUTE_SETS) {
+				return (PA_ERR_CONFIG);
+			}
+
+			fwd_info->u.host.multi_route	= 1;
+			fwd_info->u.host.multi_idx	= route_info->m_route_index;
+			fwd_info->u.host.pa_pdsp_router	= PAFRM_DEST_PA_M_0;
+		}
+		pcmd = fwd_info->u.host.cmd;
+	} else if (route_info->dest == PA_DEST_DISCARD)	{
+		fwd_info->forward_type = PAFRM_FORWARD_TYPE_DISCARD;
+	} else if (route_info->dest == PA_DEST_EMAC) {
+		fwd_info->forward_type = PAFRM_FORWARD_TYPE_ETH;
+		fwd_info->u.eth.ps_flags = (route_info->pkt_type_emac_ctrl &
+					    PA_EMAC_CTRL_CRC_DISABLE)?
+			PAFRM_ETH_PS_FLAGS_DISABLE_CRC:0;
+		fwd_info->u.eth.ps_flags |= ((route_info->pkt_type_emac_ctrl &
+					      PA_EMAC_CTRL_PORT_MASK) <<
+					     PAFRM_ETH_PS_FLAGS_PORT_SHIFT);
+	} else if (fail_route) {
+		return (PA_ERR_CONFIG);
+
+	} else if (((route_info->dest == PA_DEST_CONTINUE_PARSE_LUT1) &&
+		    (route_info->custom_type != PA_CUSTOM_TYPE_LUT2)) ||
+		   ((route_info->dest == PA_DEST_CONTINUE_PARSE_LUT2) &&
+		    (route_info->custom_type != PA_CUSTOM_TYPE_LUT1))) {
+
+		/* Custom Error check */
+		if (((route_info->custom_type == PA_CUSTOM_TYPE_LUT1) &&
+		     (route_info->custom_index >= PA_MAX_CUSTOM_TYPES_LUT1)) ||
+		    ((route_info->custom_type == PA_CUSTOM_TYPE_LUT2) &&
+		     (route_info->custom_index >= PA_MAX_CUSTOM_TYPES_LUT2)))
+			return(PA_ERR_CONFIG);
+
+		fwd_info->forward_type = PAFRM_FORWARD_TYPE_PA;
+		fwd_info->u.pa.custom_type = (u8)route_info->custom_type;
+		fwd_info->u.pa.custom_idx  = route_info->custom_index;
+
+		if (route_info->dest == PA_DEST_CONTINUE_PARSE_LUT2) {
+			fwd_info->u.pa.pa_dest = PAFRM_DEST_PA_C2;
+		} else {
+			/*
+			 * cmd_dest is provided by calling function
+			 * There is no need to check error case
+			 */
+			fwd_info->u.pa.pa_dest = (cmd_dest == PA_CMD_TX_DEST_0)?
+				PAFRM_DEST_PA_C1_1:PAFRM_DEST_PA_C1_2;
+		}
+	} else if (route_info->dest == PA_DEST_SASS) {
+		fwd_info->forward_type   = PAFRM_FORWARD_TYPE_SA;
+		fwd_info->u.sa.sw_info_0 = route_info->sw_info_0;
+		fwd_info->u.sa.sw_info_1 = route_info->sw_info_1;
+		pcmd = fwd_info->u.sa.cmd;
+	} else if (route_info->dest == PA_DEST_SRIO) {
+		fwd_info->forward_type		= PAFRM_FORWARD_TYPE_SRIO;
+		fwd_info->u.srio.ps_info0	= route_info->sw_info_0;
+		fwd_info->u.srio.ps_info1	= route_info->sw_info_1;
+		fwd_info->u.srio.pkt_type	= route_info->pkt_type_emac_ctrl;
+	} else {
+		return (PA_ERR_CONFIG);
+	}
+
+	if (pcmd && route_info->pcmd) {
+		struct pa_cmd_info *pacmd = route_info->pcmd;
+		struct pa_patch_info *patch_info;
+		struct pa_cmd_set *cmd_set;
+
+		switch (pacmd->cmd) {
+		case PA_CMD_PATCH_DATA:
+			patch_info = &pacmd->params.patch;
+			if ((patch_info->n_patch_bytes > 2) ||
+			    (patch_info->overwrite) ||
+			    (patch_info->patch_data == NULL))
+				return (PA_ERR_CONFIG);
+
+			pcmd[0] = PAFRM_RX_CMD_CMDSET;
+			pcmd[1] = patch_info->n_patch_bytes;
+			pcmd[2] = patch_info->patch_data[0];
+			pcmd[3] = patch_info->patch_data[1];
+			break;
+
+		case PA_CMD_CMDSET:
+			cmd_set = &pacmd->params.cmd_set;
+			if(cmd_set->index >= PA_MAX_CMD_SETS)
+				return (PA_ERR_CONFIG);
+
+			pcmd[0] = PAFRM_RX_CMD_CMDSET;
+			pcmd[1] = (u8)cmd_set->index;
+			break;
+		default:
+			return(PA_ERR_CONFIG);
+		}
+	}
+	return (PA_OK);
+}
+
+static int keystone_pa_reset(struct pa_device *pa_dev)
+{
+	struct pa_packet_id_alloc_regs __iomem	*packet_id_regs = pa_dev->reg_packet_id;
+	struct pa_lut2_control_regs __iomem	*lut2_regs = pa_dev->reg_lut2;
+	struct pa_statistics_regs   __iomem	*stats_regs = pa_dev->reg_stats;
+	u32 i;
+
+	/* Reset and disable all PDSPs */
+	for (i = 0; i < DEVICE_PA_NUM_PDSPS; i++) {
+		struct pa_pdsp_control_regs __iomem *ctrl_reg = &pa_dev->reg_control[i];
+		__raw_writel(PA_REG_VAL_PDSP_CTL_RESET_PDSP,
+			     &ctrl_reg->control);
+
+		while((__raw_readl(&ctrl_reg->control)
+		       & PA_REG_VAL_PDSP_CTL_STATE));
+	}
+
+	/* Reset packet Id */
+	__raw_writel(1, &packet_id_regs->soft_reset);
+
+	/* Reset LUT2 */
+	__raw_writel(1, &lut2_regs->soft_reset);
+
+	/* Reset statistic */
+	__raw_writel(1, &stats_regs->soft_reset);
+
+	/* Reset timers */
+	for (i = 0; i < DEVICE_PA_NUM_PDSPS; i++) {
+		struct pa_pdsp_timer_regs __iomem *timer_reg = &pa_dev->reg_timer[i];
+		__raw_writel(0, &timer_reg->timer_control);
+	}
+
+	return 0;
+}
+
+/*
+ *  Convert a raw PA timer count to nanoseconds
+ */
+static inline u64 tstamp_raw_to_ns(struct pa_device *pa_dev, u64 raw)
+{
+	return (raw * pa_dev->timestamp_info.mult)
+		>> pa_dev->timestamp_info.shift;
+}
+
+static u64 pa_to_sys_time(struct pa_device *pa_dev, u64 pa_ticks)
+{
+	s64 temp;
+	u64 result;
+
+	/* we need to compute difference from wallclock
+	*  to time from boot dynamically since
+	*  it will change whenever absolute time is adjusted by
+	*  protocols above (ntp, ptpv2)
+	*/
+
+	temp = ktime_to_ns(ktime_get_monotonic_offset());
+	result = (u64)((s64)pa_dev->timestamp_info.system_offset - temp +
+			(s64)tstamp_raw_to_ns(pa_dev, pa_ticks));
+
+	return result;
+}
+
+static inline u64 tstamp_get_raw(struct pa_device *pa_dev)
+{
+	struct pa_pdsp_timer_regs __iomem *timer_reg = &pa_dev->reg_timer[0];
+	u32 low, high, high2;
+	u64 raw;
+	int count;
+
+	count = 0;
+	do {
+		high  = __raw_readl(pa_dev->pa_sram + 0x6460);
+		low   = __raw_readl(&timer_reg->timer_value);
+		high2 = __raw_readl(pa_dev->pa_sram + 0x6460);
+	} while((high != high2) && (++count < 32));
+
+	raw = (((u64)high) << 16) | (u64)(0x0000ffff - (low & 0x0000ffff));
+
+	return raw;
+}
+
+/*
+ * calibrate the PA timer to the system time
+ * ktime_get gives montonic time 
+ * ktime_to_ns converts ktime to ns
+ * this needs to be called before doing conversions
+ */
+static void pa_calibrate_with_system_timer(struct pa_device *pa_dev)
+{
+	ktime_t ktime1, ktime2;
+	u64 pa_ticks;
+	u64 pa_ns;
+	u64 sys_ns1, sys_ns2;
+
+	/* Get the two values with minimum delay between */
+	ktime1 = ktime_get();
+	pa_ticks = tstamp_get_raw(pa_dev);
+	ktime2 = ktime_get();
+
+	/* Convert both values to nanoseconds */
+	sys_ns1 = ktime_to_ns(ktime1);
+	pa_ns   = tstamp_raw_to_ns(pa_dev, pa_ticks);
+	sys_ns2 = ktime_to_ns(ktime2);
+
+	/* compute offset */
+	pa_dev->timestamp_info.system_offset = sys_ns1 +
+		((sys_ns2 - sys_ns1) / 2) - pa_ns;
+}
+
+static void pa_get_version(struct pa_device *pa_dev)
+{
+	u32 version;
+
+	version = __raw_readl(pa_dev->pa_sram + PAFRM_PDSP_VERSION_BASE);
+
+	dev_info(pa_dev->dev, "Using Packet Accelerator Firmware version "
+				"0x%08x\n", version);
+}
+
+static int pa_pdsp_run(struct pa_device *pa_dev, int pdsp)
+{
+	struct pa_pdsp_control_regs __iomem *ctrl_reg = &pa_dev->reg_control[pdsp];
+	struct pa_mailbox_regs __iomem *mailbox_reg = &pa_dev->reg_mailbox[pdsp];
+	u32 i, v;
+
+	/* Check for enabled PDSP */
+	v = __raw_readl(&ctrl_reg->control);
+	if ((v & PA_REG_VAL_PDSP_CTL_ENABLE) ==
+	    PA_REG_VAL_PDSP_CTL_ENABLE) {
+		/* Already enabled */
+		return (PA_PDSP_ALREADY_ACTIVE);
+	}
+
+	/* Clear the mailbox */
+	__raw_writel(0, &mailbox_reg->pdsp_mailbox_slot0);
+
+	/* Set PDSP PC to 0, enable the PDSP */
+	__raw_writel(PA_REG_VAL_PDSP_CTL_ENABLE |
+		     PA_REG_VAL_PDSP_CTL_SOFT_RESET,
+		     &ctrl_reg->control);
+
+	/* Wait for the mailbox to become non-zero */
+	for (i = 0; i < PA_MAX_PDSP_ENABLE_LOOP_COUNT; i++)
+		v = __raw_readl(&mailbox_reg->pdsp_mailbox_slot0);
+		if (v != 0)
+			return (PA_PDSP_RESET_RELEASED);
+
+	return (PA_PDSP_NO_RESTART);
+}
+
+static int keystone_pa_reset_control(struct pa_device *pa_dev, int new_state)
+{
+	struct pa_mailbox_regs __iomem *mailbox_reg = &pa_dev->reg_mailbox[0];
+	int do_global_reset = 1;
+	int i, res;
+	int ret;
+
+	if (new_state == PA_STATE_ENABLE) {
+		ret = PA_STATE_ENABLE;
+
+		/*
+		 * Do nothing if a pdsp is already out of reset.
+		 * If any PDSPs are out of reset
+		 * a global init is not performed
+		 */
+		for (i = 0; i < 6; i++) {
+			res = pa_pdsp_run(pa_dev, i);
+
+			if (res == PA_PDSP_ALREADY_ACTIVE)
+				do_global_reset = 0;
+
+			if (res == PA_PDSP_NO_RESTART) {
+				ret = PA_STATE_ENABLE_FAILED;
+				do_global_reset = 0;
+			}
+		}
+
+		/* If global reset is required any PDSP can do it */
+		if (do_global_reset) {
+			__raw_writel(1, &mailbox_reg->pdsp_mailbox_slot1);
+			__raw_writel(0, &mailbox_reg->pdsp_mailbox_slot0);
+
+			while (__raw_readl(&mailbox_reg->pdsp_mailbox_slot1) != 0);
+
+			for (i = 1; i < 6; i++) {
+				struct pa_mailbox_regs __iomem *mbox_reg =
+					&pa_dev->reg_mailbox[i];
+				__raw_writel(0,
+					     &mbox_reg->pdsp_mailbox_slot0);
+			}
+		} else {
+			for (i = 0; i < 6; i++) {
+				struct pa_mailbox_regs __iomem *mbox_reg =
+					&pa_dev->reg_mailbox[i];
+				__raw_writel(0,
+					     &mbox_reg->pdsp_mailbox_slot0);
+			}
+
+		}
+
+		return (ret);
+	}
+
+	return (PA_STATE_INVALID_REQUEST);
+}
+
+static int keystone_pa_set_firmware(struct pa_device *pa_dev,
+			     int pdsp, const unsigned int *buffer, int len)
+{
+	struct pa_pdsp_control_regs __iomem *ctrl_reg = &pa_dev->reg_control[pdsp];
+
+	if ((pdsp < 0) || (pdsp >= DEVICE_PA_NUM_PDSPS))
+		return -EINVAL;
+
+	pdsp_fw_put((u32 *)(pa_dev->pa_iram + PA_MEM_PDSP_IRAM(pdsp)), buffer,
+		    len >> 2);
+
+	__raw_writel(pap_pdsp_const_reg_map[pdsp][PA_PDSP_CONST_REG_INDEX_C25_C24],
+		     &ctrl_reg->const_tbl_blk_index0);
+
+	__raw_writel(pap_pdsp_const_reg_map[pdsp][PA_PDSP_CONST_REG_INDEX_C27_C26],
+		     &ctrl_reg->const_tbl_blk_index1);
+
+	__raw_writel(pap_pdsp_const_reg_map[pdsp][PA_PDSP_CONST_REG_INDEX_C29_C28],
+		     &ctrl_reg->const_tbl_prog_pointer0);
+
+	__raw_writel(pap_pdsp_const_reg_map[pdsp][PA_PDSP_CONST_REG_INDEX_C31_C30],
+		     &ctrl_reg->const_tbl_prog_pointer1);
+
+	return 0;
+}
+
+static struct pa_packet *pa_alloc_packet(struct pa_device *pa_dev,
+					 unsigned cmd_size,
+					 struct dma_chan *dma_chan)
+{
+	struct pa_packet *p_info;
+
+	p_info = kzalloc(sizeof(*p_info) + cmd_size, GFP_KERNEL);
+	if (!p_info)
+		return NULL;
+
+	p_info->priv = pa_dev;
+	p_info->data = p_info + 1;
+	p_info->chan = dma_chan;
+
+	sg_init_table(p_info->sg, PA_SGLIST_SIZE);
+	sg_set_buf(&p_info->sg[0], p_info->epib, sizeof(p_info->epib));
+	sg_set_buf(&p_info->sg[1], p_info->psdata, sizeof(p_info->psdata));
+	sg_set_buf(&p_info->sg[2], p_info->data, cmd_size);
+
+	return p_info;
+}
+
+static void pa_tx_dma_callback(void *data)
+{
+	struct pa_packet *p_info = data;
+	struct pa_device *pa_dev = p_info->priv;
+	enum dma_status status;
+	unsigned long irqsave;
+	dma_cookie_t cookie;
+
+	spin_lock_irqsave(&pa_dev->lock, irqsave);
+	cookie = p_info->cookie;
+	spin_unlock_irqrestore(&pa_dev->lock, irqsave);
+
+	if (unlikely(cookie <= 0))
+		WARN(1, "invalid dma cookie == %d", cookie);
+	else {
+		status = dma_async_is_tx_complete(p_info->chan,
+						  cookie, NULL, NULL);
+		WARN((status != DMA_SUCCESS),
+				"dma completion failure, status == %d", status);
+	}
+
+	dma_unmap_sg(pa_dev->dev, &p_info->sg[2], 1, DMA_TO_DEVICE);
+
+	p_info->desc = NULL;
+
+	kfree(p_info);
+}
+
+static int pa_submit_tx_packet(struct pa_packet *p_info)
+{
+	unsigned flags = DMA_HAS_EPIB | DMA_HAS_PSINFO;
+	struct pa_device *pa_dev = p_info->priv;
+	unsigned long irqsave;
+	int ret;
+
+	ret = dma_map_sg(pa_dev->dev, &p_info->sg[2], 1, DMA_TO_DEVICE);
+	if (ret < 0)
+		return ret;
+
+	p_info->desc = dmaengine_prep_slave_sg(p_info->chan, p_info->sg, 3,
+					       DMA_TO_DEVICE, flags);
+	if (IS_ERR_OR_NULL(p_info->desc)) {
+		dma_unmap_sg(pa_dev->dev, &p_info->sg[2], 1, DMA_TO_DEVICE);
+		return PTR_ERR(p_info->desc);
+	}
+
+	p_info->desc->callback = pa_tx_dma_callback;
+	p_info->desc->callback_param = p_info;
+
+	spin_lock_irqsave(&pa_dev->lock, irqsave);
+	p_info->cookie = dmaengine_submit(p_info->desc);
+	spin_unlock_irqrestore(&pa_dev->lock, irqsave);
+
+	return dma_submit_error(p_info->cookie) ? p_info->cookie : 0;
+}
+
+#define	PA_CONTEXT_MASK		0xffff0000
+#define	PA_CONTEXT_CONFIG	0xdead0000
+#define	PA_CONTEXT_TSTAMP	0xbeef0000
+
+#define	TSTAMP_TIMEOUT	(HZ * 5)	/* 5 seconds (arbitrary) */
+
+struct tstamp_pending {
+	struct list_head	 list;
+	u32			 context;
+	struct sock		*sock;
+	struct sk_buff		*skb;
+	struct pa_device	*pa_dev;
+	struct timer_list	 timeout;
+};
+
+static spinlock_t		 tstamp_lock;
+static atomic_t			 tstamp_sequence = ATOMIC_INIT(0);
+static struct list_head		 tstamp_pending = LIST_HEAD_INIT(tstamp_pending);
+
+static struct tstamp_pending *tstamp_remove_pending(u32 context)
+{
+	struct tstamp_pending	*pend;
+
+	spin_lock(&tstamp_lock);
+	list_for_each_entry(pend, &tstamp_pending, list) {
+		if (pend->context == context) {
+			del_timer(&pend->timeout);
+			list_del(&pend->list);
+			spin_unlock(&tstamp_lock);
+			return pend;
+		}
+	}
+	spin_unlock(&tstamp_lock);
+
+	return NULL;
+}
+
+static void tstamp_complete(u32, struct pa_packet *);
+
+static void tstamp_purge_pending(struct pa_device *pa_dev)
+{
+	struct tstamp_pending	*pend;
+	int			 found;
+
+	/* This is ugly and inefficient, but very rarely executed */
+	do {
+		found = 0;
+
+		spin_lock(&tstamp_lock);
+		list_for_each_entry(pend, &tstamp_pending, list) {
+			if (pend->pa_dev == pa_dev) {
+				found = 1;
+				break;
+			}
+		}
+		spin_unlock(&tstamp_lock);
+
+		if (found)
+			tstamp_complete(pend->context, NULL);
+	} while(found);
+}
+
+static void tstamp_timeout(unsigned long context)
+{
+	tstamp_complete((u32)context, NULL);
+}
+
+static int tstamp_add_pending(struct tstamp_pending *pend)
+{
+	init_timer(&pend->timeout);
+	pend->timeout.expires = jiffies + TSTAMP_TIMEOUT;
+	pend->timeout.function = tstamp_timeout;
+	pend->timeout.data = (unsigned long)pend->context;
+
+	spin_lock(&tstamp_lock);
+	add_timer(&pend->timeout);
+	list_add_tail(&pend->list, &tstamp_pending);
+	spin_unlock(&tstamp_lock);
+
+	return 0;
+}
+
+static void tstamp_complete(u32 context, struct pa_packet *p_info)
+{
+	struct tstamp_pending	*pend;
+	struct sock_exterr_skb 	*serr;
+	struct sk_buff 		*skb;
+	struct skb_shared_hwtstamps *sh_hw_tstamps;
+	u64			 tx_timestamp;
+	u64			 sys_time;
+	int			 err;
+
+	pend = tstamp_remove_pending(context);
+	if (!pend)
+		return;
+
+
+	skb = pend->skb;
+	if (!p_info) {
+		dev_warn(pend->pa_dev->dev, "Timestamp completion timeout\n");
+		kfree_skb(skb);
+	} else {
+		tx_timestamp = p_info->epib[0];
+		tx_timestamp |= ((u64)(p_info->epib[2] & 0x0000ffff)) << 32;
+
+		sys_time = pa_to_sys_time(pend->pa_dev, tx_timestamp);
+
+		sh_hw_tstamps = skb_hwtstamps(skb);
+		memset(sh_hw_tstamps, 0, sizeof(*sh_hw_tstamps));
+		sh_hw_tstamps->hwtstamp =
+			ns_to_ktime(tstamp_raw_to_ns(pend->pa_dev,
+							tx_timestamp));
+		sh_hw_tstamps->syststamp = ns_to_ktime(sys_time);
+
+		serr = SKB_EXT_ERR(skb);
+		memset(serr, 0, sizeof(*serr));
+		serr->ee.ee_errno = ENOMSG;
+		serr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;
+
+		err = sock_queue_err_skb(pend->sock, skb);
+		if (err)
+			kfree_skb(skb);
+	}
+
+	kfree(pend);
+}
+
+static void pa_rx_complete(void *param)
+{
+	struct pa_packet *p_info = param;
+	struct pa_device *pa_dev = p_info->priv;
+	struct pa_frm_command *fcmd;
+
+	dma_unmap_sg(pa_dev->dev, &p_info->sg[2], 1, DMA_FROM_DEVICE);
+
+	switch (p_info->epib[1] & PA_CONTEXT_MASK) {
+	case PA_CONTEXT_CONFIG:
+		fcmd = p_info->data;
+		swizFcmd(fcmd);
+
+		if (fcmd->command_result != PAFRM_COMMAND_RESULT_SUCCESS) {
+			dev_dbg(pa_dev->dev, "Command Result = 0x%x\n", fcmd->command_result);
+			dev_dbg(pa_dev->dev, "Command = 0x%x\n", fcmd->command);
+			dev_dbg(pa_dev->dev, "Magic = 0x%x\n", fcmd->magic);
+			dev_dbg(pa_dev->dev, "Com ID = 0x%x\n", fcmd->com_id);
+			dev_dbg(pa_dev->dev, "ret Context = 0x%x\n", fcmd->ret_context);
+			dev_dbg(pa_dev->dev, "Flow ID = 0x%x\n", fcmd->flow_id);
+			dev_dbg(pa_dev->dev, "reply Queue = 0x%x\n", fcmd->reply_queue);
+			dev_dbg(pa_dev->dev, "reply dest = 0x%x\n", fcmd->reply_dest);
+		}
+		dev_dbg(pa_dev->dev, "command response complete\n");
+		break;
+
+	case PA_CONTEXT_TSTAMP:
+		tstamp_complete(p_info->epib[1], p_info);
+		break;
+
+	default:
+		dev_warn(pa_dev->dev, "bad response context, got 0x%08x\n", p_info->epib[1]);
+		break;
+	}
+
+	p_info->desc = NULL;
+	kfree(p_info);
+}
+
+/* Release a free receive buffer */
+static void pa_rxpool_free(void *arg, unsigned q_num, unsigned bufsize,
+		struct dma_async_tx_descriptor *desc)
+{
+	struct pa_device *pa_dev = arg;
+	struct pa_packet *p_info = desc->callback_param;
+
+	dma_unmap_sg(pa_dev->dev, &p_info->sg[2], 1, DMA_FROM_DEVICE);
+
+	p_info->desc = NULL;
+
+	kfree(p_info);
+}
+
+static void pa_chan_work_handler(unsigned long data)
+{
+	struct pa_device *pa_dev = (struct pa_device *)data;
+
+	dma_poll(pa_dev->rx_channel, -1);
+
+	dma_rxfree_refill(pa_dev->rx_channel);
+
+	dmaengine_resume(pa_dev->rx_channel);
+}
+
+static void pa_chan_notify(struct dma_chan *dma_chan, void *arg)
+{
+	struct pa_device *pa_dev = arg;
+
+	dmaengine_pause(pa_dev->rx_channel);
+
+	tasklet_schedule(&pa_dev->task);
+
+	return;
+}
+
+/* Allocate a free receive buffer */
+static struct dma_async_tx_descriptor *pa_rxpool_alloc(void *arg,
+		unsigned q_num, unsigned bufsize)
+{
+	struct pa_device *pa_dev = arg;
+	struct dma_async_tx_descriptor *desc;
+	struct dma_device *device;
+	u32 err = 0;
+
+	struct pa_packet *rx;
+
+	rx = pa_alloc_packet(pa_dev, bufsize, pa_dev->rx_channel);
+	if (!rx) {
+		dev_err(pa_dev->dev, "could not allocate cmd rx packet\n");
+		kfree(rx);
+		return NULL;
+	}
+
+	rx->sg_ents = 2 + dma_map_sg(pa_dev->dev, &rx->sg[2],
+				1, DMA_FROM_DEVICE);
+	if (rx->sg_ents != 3) {
+		dev_err(pa_dev->dev, "dma map failed\n");
+
+		kfree(rx);
+		return NULL;
+	}
+
+	device = rx->chan->device;
+
+	desc = dmaengine_prep_slave_sg(rx->chan, rx->sg, 3, DMA_DEV_TO_MEM,
+				       DMA_HAS_EPIB | DMA_HAS_PSINFO);
+
+	if (IS_ERR_OR_NULL(desc)) {
+		dma_unmap_sg(pa_dev->dev, &rx->sg[2], 1, DMA_FROM_DEVICE);
+		kfree(rx);
+		err = PTR_ERR(desc);
+		if (err != -ENOMEM) {
+			dev_err(pa_dev->dev,
+				"dma prep failed, error %d\n", err);
+		}
+
+		return NULL;
+	}
+
+	desc->callback_param = rx;
+	desc->callback = pa_rx_complete;
+	rx->cookie = desc->cookie;
+
+	return desc;
+}
+
+static int keystone_pa_add_mac(struct pa_intf *pa_intf, int index,
+			       const u8 *smac, const u8 *dmac, int rule,
+			       unsigned etype, int port)
+{
+	struct pa_route_info route_info, fail_info;
+	struct pa_frm_command *fcmd;
+	struct pa_frm_cmd_add_lut1 *al1;
+	struct pa_packet *tx;
+	struct pa_device *priv = pa_intf->pa_device;
+	u32 context = PA_CONTEXT_CONFIG;
+	int size, ret;
+
+	dev_dbg(priv->dev, "add mac, index %d, smac %pM, dmac %pM, rule %d, type %x, port %d\n",
+		index, smac, dmac, rule, etype, port);
+
+	memset(&fail_info, 0, sizeof(fail_info));
+
+	memset(&route_info, 0, sizeof(route_info));
+
+	if (rule == PACKET_HST) {
+		route_info.dest			= PA_DEST_HOST;
+		route_info.flow_id		= pa_intf->data_flow_num;
+		route_info.queue		= pa_intf->data_queue_num;
+		route_info.m_route_index	= -1;
+		fail_info.dest			= PA_DEST_HOST;
+		fail_info.flow_id		= pa_intf->data_flow_num;
+		fail_info.queue			= pa_intf->data_queue_num;
+		fail_info.m_route_index		= -1;
+	} else if (rule == PACKET_PARSE) {
+		route_info.dest			= PA_DEST_CONTINUE_PARSE_LUT1;
+		route_info.m_route_index	= -1;
+		fail_info.dest			= PA_DEST_HOST;
+		fail_info.flow_id		= pa_intf->data_flow_num;
+		fail_info.queue			= pa_intf->data_queue_num;
+		fail_info.m_route_index		= -1;
+	} else if (rule == PACKET_DROP) {
+		route_info.dest			= PA_DEST_DISCARD;
+		route_info.m_route_index	= -1;
+		fail_info.dest			= PA_DEST_DISCARD;
+		fail_info.m_route_index		= -1;
+	}
+
+	size = (sizeof(struct pa_frm_command) +
+		sizeof(struct pa_frm_cmd_add_lut1) + 4);
+	tx = pa_alloc_packet(priv, size, priv->pdsp0_tx_channel);
+	if (!tx) {
+		dev_err(priv->dev, "could not allocate cmd tx packet\n");
+		return -ENOMEM;
+	}
+
+	fcmd = tx->data;
+	al1 = (struct pa_frm_cmd_add_lut1 *) &(fcmd->cmd);
+
+	fcmd->command_result	= 0;
+	fcmd->command		= PAFRM_CONFIG_COMMAND_ADDREP_LUT1;
+	fcmd->magic		= PAFRM_CONFIG_COMMAND_SEC_BYTE;
+	fcmd->com_id		= PA_COMID_L2;
+	fcmd->ret_context	= context;
+	fcmd->flow_id		= priv->cmd_flow_num;
+	fcmd->reply_queue	= priv->cmd_queue_num;
+	fcmd->reply_dest	= PAFRM_DEST_PKTDMA;
+
+	al1->index		= index;
+	al1->type		= PAFRM_COM_ADD_LUT1_STANDARD;
+
+	if (etype) {
+		al1->u.eth_ip.etype	= etype;
+		al1->u.eth_ip.match_flags |= PAFRM_LUT1_MATCH_ETYPE;
+	}
+
+	al1->u.eth_ip.vlan	= 0;
+	al1->u.eth_ip.pm.mpls	= 0;
+	if (port) {
+		al1->u.eth_ip.inport    = port;
+		al1->u.eth_ip.match_flags |= PAFRM_LUT1_MATCH_PORT;
+	}
+
+	if (dmac) {
+		al1->u.eth_ip.dmac[0] = dmac[0];
+		al1->u.eth_ip.dmac[1] = dmac[1];
+		al1->u.eth_ip.dmac[2] = dmac[2];
+		al1->u.eth_ip.dmac[3] = dmac[3];
+		al1->u.eth_ip.dmac[4] = dmac[4];
+		al1->u.eth_ip.dmac[5] = dmac[5];
+		al1->u.eth_ip.match_flags |= PAFRM_LUT1_MATCH_DMAC;
+	}
+	if (smac) {
+		al1->u.eth_ip.smac[0] = smac[0];
+		al1->u.eth_ip.smac[1] = smac[1];
+		al1->u.eth_ip.smac[2] = smac[2];
+		al1->u.eth_ip.smac[3] = smac[3];
+		al1->u.eth_ip.smac[4] = smac[4];
+		al1->u.eth_ip.smac[5] = smac[5];
+		al1->u.eth_ip.match_flags |= PAFRM_LUT1_MATCH_SMAC;
+	}
+
+	al1->u.eth_ip.key |= PAFRM_LUT1_KEY_MAC;
+	al1->u.eth_ip.match_flags |= PAFRM_LUT1_CUSTOM_MATCH_KEY;
+
+	ret = pa_conv_routing_info(&al1->match, &route_info, 0, 0);
+	if (ret != 0)
+		dev_err(priv->dev, "route info config failed\n");
+
+	ret = pa_conv_routing_info(&al1->next_fail, &fail_info, 0, 1);
+	if (ret != 0)
+		dev_err(priv->dev, "fail info config failed\n");
+
+	swizFcmd(fcmd);
+	swizAl1((struct pa_frm_cmd_add_lut1 *)&(fcmd->cmd));
+
+	tx->psdata[0] = ((u32)(4 << 5) << 24);
+
+	tx->epib[1] = 0x11112222;
+	tx->epib[2] = 0x33334444;
+	tx->epib[3] = 0;
+
+	pa_submit_tx_packet(tx);
+	dev_dbg(priv->dev, "waiting for command transmit complete\n");
+
+	return 0;
+}
+
+static void pa_init_crc_table4(u32 polynomial, u32 *crc_table4)
+{
+	int i, bit;
+
+	/* 16 values representing all possible 4-bit values */
+	for(i = 0; i < PARAM_CRC_TABLE_SIZE; i++) {
+		crc_table4[i] = i << 28;
+		for (bit = 0; bit < 4; bit++) {
+			/* If shifting out a zero, then just shift */
+			if (!(crc_table4[i] & 0x80000000))
+				crc_table4[i] = (crc_table4[i] << 1);
+			/* Else add in the polynomial as well */
+			else
+				crc_table4[i] = (crc_table4[i] << 1) ^ polynomial;
+		}
+		crc_table4[i] = cpu_to_be32(crc_table4[i]);
+	}
+}
+
+#define	CRC32C_POLYNOMIAL	0x1EDC6F41
+#define	SCTP_CRC_INITVAL	0xFFFFFFFF
+static int pa_config_crc_engine(struct pa_device *priv)
+{
+	struct pa_frm_command *fcmd;
+	struct pa_frm_config_crc *ccrc;
+	struct pa_packet *tx;
+	int size;
+
+	/* Verify that there is enough room to create the command */
+	size = sizeof(*fcmd) + sizeof(*ccrc) - sizeof(u32);
+	tx = pa_alloc_packet(priv, size, priv->pdsp0_tx_channel);
+	if (!tx) {
+		dev_err(priv->dev, "could not allocate cmd tx packet\n");
+		return -ENOMEM;
+	}
+
+	/* Create the command */
+	fcmd = tx->data;
+	fcmd->command_result	= 0;
+	fcmd->command		= PAFRM_CONFIG_COMMAND_CRC_ENGINE;
+	fcmd->magic		= PAFRM_CONFIG_COMMAND_SEC_BYTE;
+	fcmd->com_id		= 0;
+	fcmd->ret_context	= PA_CONTEXT_CONFIG;
+	fcmd->flow_id		= priv->cmd_flow_num;
+	fcmd->reply_queue	= priv->cmd_queue_num;
+	fcmd->reply_dest	= PAFRM_DEST_PKTDMA;
+	swizFcmd(fcmd);
+
+	ccrc = (struct pa_frm_config_crc *)&(fcmd->cmd);
+	ccrc->ctrl_bitmap  = PARAM_CRC_SIZE_32;
+	ccrc->ctrl_bitmap |= PARAM_CRC_CTRL_RIGHT_SHIFT;
+	ccrc->ctrl_bitmap |= PARAM_CRC_CTRL_INV_RESULT;
+	ccrc->init_val = cpu_to_be32(SCTP_CRC_INITVAL);
+
+	/* Magic polynomial value is CRC32c defined by RFC4960 */
+	pa_init_crc_table4(CRC32C_POLYNOMIAL, ccrc->crc_tbl);
+
+	tx->psdata[0] = ((u32)(4 << 5) << 24);
+
+	tx->epib[1] = 0x11112222;
+	tx->epib[2] = 0x33334444;
+	tx->epib[3] = 0;
+
+	pa_submit_tx_packet(tx);
+	dev_dbg(priv->dev, "waiting for command transmit complete\n");
+
+	return 0;
+}
+
+
+static int pa_fmtcmd_tx_csum(struct netcp_packet *p_info)
+{
+	struct sk_buff *skb = p_info->skb;
+	struct pasaho_com_chk_crc *ptx;
+	int start, len;
+	int size;
+
+	size = sizeof(*ptx);
+	ptx = (struct pasaho_com_chk_crc *)netcp_push_psdata(p_info, size);
+
+	start = skb_checksum_start_offset(skb);
+	len = skb->len - start;
+	if (len & 0x01) {
+		int err = skb_pad(skb, 1);
+		if (err < 0) {
+			if (unlikely(net_ratelimit())) {
+				dev_warn(p_info->netcp->dev,
+					"padding failed (%d), packet discarded\n",
+					err);
+			}
+			p_info->skb = NULL;
+			return err;
+		}
+		dev_dbg(p_info->netcp->dev, "padded packet to even length");
+		++len;
+	}
+
+	PASAHO_SET_CMDID(ptx, PASAHO_PAMOD_CMPT_CHKSUM);
+	PASAHO_CHKCRC_SET_START(ptx, start);
+	PASAHO_CHKCRC_SET_LEN(ptx, len);
+	PASAHO_CHKCRC_SET_RESULT_OFF(ptx, skb->csum_offset);
+	PASAHO_CHKCRC_SET_INITVAL(ptx, 0);
+	PASAHO_CHKCRC_SET_NEG0(ptx, 0);
+
+	return size;
+}
+
+static int pa_fmtcmd_tx_crc32c(struct netcp_packet *p_info)
+{
+	struct sk_buff *skb = p_info->skb;
+	struct pasaho_com_chk_crc *ptx;
+	int start, len;
+	int size;
+
+	size = sizeof(*ptx);
+	ptx = (struct pasaho_com_chk_crc *)netcp_push_psdata(p_info, size);
+
+	start = skb_checksum_start_offset(skb);
+	len = skb->len - start;
+
+	PASAHO_SET_CMDID             (ptx, PASAHO_PAMOD_CMPT_CRC);
+	PASAHO_CHKCRC_SET_START      (ptx, start);
+	PASAHO_CHKCRC_SET_LEN        (ptx, len);
+	PASAHO_CHKCRC_SET_CTRL       (ptx, PAFRM_CRC_FLAG_CRC_OFFSET_VALID);
+	PASAHO_CHKCRC_SET_RESULT_OFF (ptx, skb->csum_offset);
+
+	return size;
+}
+
+static int pa_fmtcmd_next_route(struct netcp_packet *p_info, const struct pa_cmd_next_route *route)
+{
+	struct pasaho_next_route	*nr;
+	int	size;
+	u16	pdest;
+
+	/* Make sure the destination is valid */
+	switch (route->dest) {
+	case PA_DEST_HOST:
+		pdest = PAFRM_DEST_PKTDMA;
+		break;
+	case PA_DEST_EMAC:
+		pdest = PAFRM_DEST_ETH;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	size = route->pkt_type_emac_ctrl ? sizeof(*nr) : (sizeof(*nr) - sizeof(nr->word1));
+	nr = (struct pasaho_next_route *)netcp_push_psdata(p_info, size);
+	if (!nr)
+		return -ENOMEM;
+
+	if (route->pkt_type_emac_ctrl) {
+		u8 ps_flags;
+		PASAHO_SET_E(nr, 1);
+
+		ps_flags = (route->pkt_type_emac_ctrl & PA_EMAC_CTRL_CRC_DISABLE) ?
+				PAFRM_ETH_PS_FLAGS_DISABLE_CRC : 0;
+
+		ps_flags |= ((route->pkt_type_emac_ctrl & PA_EMAC_CTRL_PORT_MASK) <<
+				PAFRM_ETH_PS_FLAGS_PORT_SHIFT);
+
+		PASAHO_SET_PKTTYPE(nr, ps_flags);
+	}
+
+	PASAHO_SET_CMDID(nr, PASAHO_PAMOD_NROUTE);
+	PASAHO_SET_DEST(nr, pdest);
+	PASAHO_SET_FLOW(nr, route->flow_id);
+	PASAHO_SET_QUEUE (nr, route->queue);
+
+	if (route->ctrl_bit_field & PA_NEXT_ROUTE_PROC_NEXT_CMD)
+		PASAHO_SET_N  (nr, 1);
+
+	nr->sw_info0 = route->sw_info_0;
+	nr->sw_info1 = route->sw_info_1;
+
+	return size;
+}
+
+static int pa_fmtcmd_tx_timestamp(struct netcp_packet *p_info, const struct pa_cmd_tx_timestamp *tx_ts)
+{
+	struct pasaho_report_timestamp	*rt_info;
+	int				 size;
+
+	size = sizeof(*rt_info);
+	rt_info = (struct pasaho_report_timestamp *)netcp_push_psdata(p_info, size);
+	if (!rt_info)
+		return -ENOMEM;
+
+	PASAHO_SET_CMDID(rt_info, PASAHO_PAMOD_REPORT_TIMESTAMP);
+	PASAHO_SET_REPORT_FLOW(rt_info, (u8)tx_ts->flow_id);
+	PASAHO_SET_REPORT_QUEUE(rt_info, tx_ts->dest_queue);
+	rt_info->sw_info0 = tx_ts->sw_info0;
+
+	return size;
+}
+
+static int pa_fmtcmd_align(struct netcp_packet *p_info, const unsigned bytes)
+{
+	struct pasaho_cmd_info	*paCmdInfo;
+	int i;
+
+	if ((bytes & 0x03) != 0)
+		return -EINVAL;
+
+	paCmdInfo = (struct pasaho_cmd_info *)netcp_push_psdata(p_info, bytes);
+
+	for (i = bytes/sizeof(u32); i > 0; --i ) {
+		PASAHO_SET_CMDID(paCmdInfo, PASAHO_PAMOD_DUMMY);
+		++paCmdInfo;
+	}
+
+	return bytes;
+}
+
+static inline int extract_l4_proto(struct netcp_packet *p_info)
+{
+	struct sk_buff *skb = p_info->skb;
+	int l4_proto = 0;
+	__be16 l3_proto;
+
+	l3_proto = skb->protocol;
+	if (l3_proto == __constant_htons(ETH_P_8021Q)) {
+		/* Can't use vlan_eth_hdr() here, skb->mac_header isn't valid */
+		struct vlan_ethhdr *vhdr = (struct vlan_ethhdr *)skb->data;
+		l3_proto = vhdr->h_vlan_encapsulated_proto;
+	}
+
+	switch (l3_proto) {
+	case __constant_htons(ETH_P_IP):
+		l4_proto = ip_hdr(skb)->protocol;
+		break;
+	case __constant_htons(ETH_P_IPV6):
+		l4_proto = ipv6_hdr(skb)->nexthdr;
+		break;
+	default:
+		if (unlikely(net_ratelimit())) {
+			dev_warn(p_info->netcp->dev,
+				 "partial checksum but L3 proto = 0x%04hx!\n",
+				 ntohs(l3_proto));
+		}
+	}
+
+	return l4_proto;
+}
+
+static int pa_tx_hook(int order, void *data, struct netcp_packet *p_info)
+{
+	struct pa_intf *pa_intf = data;
+	struct pa_device *pa_dev = pa_intf->pa_device;
+	struct netcp_priv *netcp_priv = netdev_priv(pa_intf->net_device);
+	struct sk_buff *skb = p_info->skb;
+	struct sock *sk = skb->sk;
+	struct pa_cmd_tx_timestamp tx_ts;
+	int size, total = 0;
+	struct pa_cmd_next_route route_cmd;
+	struct tstamp_pending *pend;
+
+	/* Generate the route_cmd */
+	memset(&route_cmd, 0, sizeof(route_cmd));
+	route_cmd.dest = PA_DEST_EMAC;
+	if (pa_dev->multi_if)
+		route_cmd.pkt_type_emac_ctrl = netcp_priv->cpsw_port;
+
+	/* Generate the next route command */
+	size = pa_fmtcmd_next_route(p_info, &route_cmd);
+	if (unlikely(size < 0))
+		return size;
+	total += size;
+
+	/* If TX Timestamp required, request it */
+	if (unlikely((skb_shinfo(p_info->skb)->tx_flags & SKBTX_HW_TSTAMP) &&
+		     p_info->skb->sk && pa_intf->tx_timestamp_enable &&
+		     need_timestamp(p_info->skb))) {
+		pend = kzalloc(sizeof(*pend), GFP_ATOMIC);
+		if (pend) {
+			if (!atomic_inc_not_zero(&sk->sk_refcnt))
+				return -ENODEV;
+			pend->skb = skb_clone(p_info->skb, GFP_ATOMIC);
+			if (!pend->skb) {
+				sock_put(sk);
+				kfree(pend);
+				return -ENOMEM;
+			} else {
+				pend->sock = p_info->skb->sk;
+				pend->pa_dev = pa_dev;
+				pend->context =  PA_CONTEXT_TSTAMP |
+					(~PA_CONTEXT_MASK &
+					 atomic_inc_return(&tstamp_sequence));
+				tstamp_add_pending(pend);
+
+				memset(&tx_ts, 0, sizeof(tx_ts));
+				tx_ts.dest_queue = pa_dev->cmd_queue_num;
+				tx_ts.flow_id    = pa_dev->cmd_flow_num;
+				tx_ts.sw_info0   = pend->context;
+
+				size = pa_fmtcmd_tx_timestamp(p_info,
+							      &tx_ts);
+				if (unlikely(size < 0))
+					return size;
+				total += size;
+			}
+		}
+	}
+
+	/* If checksum offload required, request it */
+	if ((skb->ip_summed == CHECKSUM_PARTIAL) &&
+	    (pa_dev->csum_offload == CSUM_OFFLOAD_HARD)) {
+		int l4_proto;
+
+		l4_proto = extract_l4_proto(p_info);
+		switch (l4_proto) {
+		case IPPROTO_TCP:
+		case IPPROTO_UDP:
+			size = pa_fmtcmd_tx_csum(p_info);
+			break;
+		case IPPROTO_SCTP:
+			size = pa_fmtcmd_tx_crc32c(p_info);
+			break;
+		default:
+			if (unlikely(net_ratelimit())) {
+				dev_warn(p_info->netcp->dev,
+					 "partial checksum but L4 proto = %d!\n",
+					 l4_proto);
+			}
+			size = 0;
+			break;
+		}
+
+		if (unlikely(size < 0))
+			return size;
+		total += size;
+	}
+
+	/* The next hook may require the command stack to be 8-byte aligned */
+	size = netcp_align_psdata(p_info, 8);
+	if (unlikely(size < 0))
+		return size;
+	if (size > 0) {
+		size = pa_fmtcmd_align(p_info, size);
+		if (unlikely(size < 0))
+			return size;
+		total += size;
+	}
+
+	p_info->tx_pipe = &pa_intf->tx_pipe;
+	return 0;
+}
+
+
+/* This code adapted from net/core/skbuff.c:skb_checksum() */
+static __wsum skb_sctp_csum(struct sk_buff *skb, int offset,
+			  int len, __wsum csum)
+{
+	int start = skb_headlen(skb);
+	int i, copy = start - offset;
+	struct sk_buff *frag_iter;
+
+	/* Checksum header. */
+	if (copy > 0) {
+		if (copy > len)
+			copy = len;
+		csum = sctp_update_cksum(skb->data + offset, copy, csum);
+		if ((len -= copy) == 0)
+			return csum;
+		offset += copy;
+	}
+
+	for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
+		int end;
+		skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
+
+		WARN_ON(start > offset + len);
+
+		end = start + skb_frag_size(frag);
+		if ((copy = end - offset) > 0) {
+			u8 *vaddr;
+			skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
+
+			if (copy > len)
+				copy = len;
+			vaddr = kmap_atomic(skb_frag_page(frag));
+			csum = sctp_update_cksum(vaddr + frag->page_offset +
+					 offset - start, copy, csum);
+			kunmap_atomic(vaddr);
+			if (!(len -= copy))
+				return csum;
+			offset += copy;
+		}
+		start = end;
+	}
+
+	skb_walk_frags(skb, frag_iter) {
+		int end;
+
+		WARN_ON(start > offset + len);
+
+		end = start + frag_iter->len;
+		if ((copy = end - offset) > 0) {
+			if (copy > len)
+				copy = len;
+			csum = skb_sctp_csum(frag_iter,
+						offset - start, copy, csum);
+			if ((len -= copy) == 0)
+				return csum;
+			offset += copy;
+		}
+		start = end;
+	}
+	BUG_ON(len);
+
+	return csum;
+}
+
+static void skb_warn_bad_offload(const struct sk_buff *skb)
+{
+	static const netdev_features_t null_features = 0;
+	struct net_device *dev = skb->dev;
+	const char *driver = "";
+
+	if (dev && dev->dev.parent)
+		driver = dev_driver_string(dev->dev.parent);
+
+	WARN(1, "%s: caps=(%pNF, %pNF) len=%d data_len=%d gso_size=%d "
+	     "gso_type=%d ip_summed=%d\n",
+	     driver, dev ? &dev->features : &null_features,
+	     skb->sk ? &skb->sk->sk_route_caps : &null_features,
+	     skb->len, skb->data_len, skb_shinfo(skb)->gso_size,
+	     skb_shinfo(skb)->gso_type, skb->ip_summed);
+}
+
+/* This code adapted from net/core/dev.c:skb_checksum_help() */
+static int skb_sctp_csum_help(struct sk_buff *skb)
+{
+	__wsum csum;
+	int ret = 0, offset;
+
+	if (skb->ip_summed == CHECKSUM_COMPLETE)
+		goto out_set_summed;
+
+	if (unlikely(skb_shinfo(skb)->gso_size)) {
+		skb_warn_bad_offload(skb);
+		return -EINVAL;
+	}
+
+	offset = skb_checksum_start_offset(skb);
+	BUG_ON(offset >= skb_headlen(skb));
+	csum = skb_sctp_csum(skb, offset, skb->len - offset, ~0);
+
+	offset += skb->csum_offset;
+	BUG_ON(offset + sizeof(__le32) > skb_headlen(skb));
+
+	if (skb_cloned(skb) &&
+	    !skb_clone_writable(skb, offset + sizeof(__le32))) {
+		ret = pskb_expand_head(skb, 0, 0, GFP_ATOMIC);
+		if (ret)
+			goto out;
+	}
+
+	*(__le32 *)(skb->data + offset) = sctp_end_cksum(csum);
+out_set_summed:
+	skb->ip_summed = CHECKSUM_NONE;
+out:
+	return ret;
+}
+
+static int pa_txhook_softcsum(int order, void *data, struct netcp_packet *p_info)
+{
+	struct pa_intf *pa_intf = data;
+	struct pa_device *pa_dev = pa_intf->pa_device;
+	struct sk_buff *skb = p_info->skb;
+	int l4_proto;
+	int ret = 0;
+
+	if ((skb->ip_summed != CHECKSUM_PARTIAL) ||
+	    (pa_dev->csum_offload != CSUM_OFFLOAD_SOFT))
+		return 0;
+
+	l4_proto = extract_l4_proto(p_info);
+	if (unlikely(!l4_proto))
+		return 0;
+
+	switch (l4_proto) {
+	case IPPROTO_TCP:
+	case IPPROTO_UDP:
+		ret = skb_checksum_help(skb);
+		break;
+	case IPPROTO_SCTP:
+		ret = skb_sctp_csum_help(skb);
+		break;
+	default:
+		if (unlikely(net_ratelimit())) {
+			dev_warn(p_info->netcp->dev,
+				 "partial checksum but L4 proto = %d!\n",
+				 l4_proto);
+		}
+		return 0;
+	}
+
+	return ret;
+}
+
+
+static int pa_rx_timestamp(int order, void *data, struct netcp_packet *p_info)
+{
+	struct pa_intf *pa_intf = data;
+	struct pa_device *pa_dev = pa_intf->pa_device;
+	struct sk_buff *skb = p_info->skb;
+	struct skb_shared_hwtstamps *sh_hw_tstamps;
+	u64 rx_timestamp;
+	u64 sys_time;
+
+	if (!pa_intf->rx_timestamp_enable)
+		return 0;
+
+	rx_timestamp = p_info->epib[0];
+	rx_timestamp |= ((u64)(p_info->psdata[5] & 0x0000ffff)) << 32;
+
+	sys_time = pa_to_sys_time(pa_dev, rx_timestamp);
+
+	sh_hw_tstamps = skb_hwtstamps(skb);
+	memset(sh_hw_tstamps, 0, sizeof(*sh_hw_tstamps));
+	sh_hw_tstamps->hwtstamp = ns_to_ktime(tstamp_raw_to_ns(pa_dev,
+							rx_timestamp));
+	sh_hw_tstamps->syststamp = ns_to_ktime(sys_time);
+
+	return 0;
+}
+
+static int pa_close(void *intf_priv, struct net_device *ndev)
+{
+	struct pa_intf *pa_intf = intf_priv;
+	struct pa_device *pa_dev = pa_intf->pa_device;
+	struct netcp_priv *netcp_priv = netdev_priv(ndev);
+
+	netcp_unregister_txhook(netcp_priv, pa_dev->txhook_order,
+				pa_tx_hook, intf_priv);
+	if (pa_dev->csum_offload == CSUM_OFFLOAD_SOFT)
+		netcp_unregister_txhook(netcp_priv, pa_dev->txhook_softcsum,
+					pa_txhook_softcsum, intf_priv);
+	netcp_unregister_rxhook(netcp_priv, pa_dev->rxhook_order,
+				pa_rx_timestamp, intf_priv);
+
+	netcp_txpipe_close(&pa_intf->tx_pipe);
+
+	/* De-Configure the streaming switch */
+	netcp_set_streaming_switch(pa_dev->netcp_device,
+				   netcp_priv->cpsw_port,
+				   pa_intf->saved_ss_state);
+
+
+	mutex_lock(&pa_modules_lock);
+	if (!--pa_dev->inuse_if_count) {
+		/* Do pa disable related stuff only if this is the last
+		 * interface to go down
+		 */
+		tasklet_disable(&pa_dev->task);
+
+		tstamp_purge_pending(pa_dev);
+
+		if (pa_dev->pdsp0_tx_channel) {
+			dmaengine_pause(pa_dev->pdsp0_tx_channel);
+			dma_release_channel(pa_dev->pdsp0_tx_channel);
+			pa_dev->pdsp0_tx_channel = NULL;
+		}
+		if (pa_dev->rx_channel) {
+			dmaengine_pause(pa_dev->rx_channel);
+			dma_release_channel(pa_dev->rx_channel);
+			pa_dev->rx_channel = NULL;
+		}
+
+		if (pa_dev->clk) {
+			clk_disable_unprepare(pa_dev->clk);
+			clk_put(pa_dev->clk);
+		}
+		pa_dev->clk = NULL;
+	}
+
+	mutex_unlock(&pa_modules_lock);
+	return 0;
+}
+
+static int pa_open(void *intf_priv, struct net_device *ndev)
+{
+	struct pa_intf *pa_intf = intf_priv;
+	struct pa_device *pa_dev = pa_intf->pa_device;
+	struct netcp_priv *netcp_priv = netdev_priv(ndev);
+	struct dma_keystone_info config;
+	struct pa_pdsp_timer_regs __iomem *timer_reg = &pa_dev->reg_timer[0];
+	const struct firmware *fw;
+	struct dma_chan *chan;
+	dma_cap_mask_t mask;
+	int i, ret, err;
+	unsigned long pa_rate;
+	u64 max_sec;
+
+	/* The first time an open is being called */
+	mutex_lock(&pa_modules_lock);
+
+	dev_dbg(pa_dev->dev, "pa_open() called for port: %d\n",
+		 netcp_priv->cpsw_port);
+
+	if (++pa_dev->inuse_if_count == 1) {
+
+		/* Do pa enable, load firmware only for the first interface
+		 * that comes up
+		 */
+		dev_dbg(pa_dev->dev, "pa_open() called for first time"
+			" initializing per dev stuff\n");
+
+		pa_dev->clk = clk_get(pa_dev->dev, "clk_pa");
+		if (IS_ERR_OR_NULL(pa_dev->clk)) {
+			dev_warn(pa_dev->dev, "unable to get Packet Accelerator clock\n");
+			pa_dev->clk = NULL;
+		}
+
+		if (pa_dev->clk)
+			clk_prepare_enable(pa_dev->clk);
+
+		keystone_pa_reset(pa_dev);
+
+		for (i = 0; i <= 5; i++) {
+			if (i <= 2)
+				ret = request_firmware(&fw,
+					       DEVICE_PA_PDSP02_FIRMWARE,
+					       pa_dev->dev);
+			else if (i == 3)
+				ret = request_firmware(&fw,
+					       DEVICE_PA_PDSP3_FIRMWARE,
+					       pa_dev->dev);
+			else if (i > 3)
+				ret = request_firmware(&fw,
+						DEVICE_PA_PDSP45_FIRMWARE,
+						pa_dev->dev);
+			if (ret != 0) {
+				dev_err(pa_dev->dev, "cant find fw for pdsp %d",
+					i);
+				ret = -ENODEV;
+				goto fail;
+			}
+
+			/* Download the firmware to the PDSP */
+			keystone_pa_set_firmware(pa_dev, i,
+					(const unsigned int *) fw->data,
+					fw->size);
+
+			release_firmware(fw);
+		}
+
+		ret = keystone_pa_reset_control(pa_dev, PA_STATE_ENABLE);
+		if (ret != 1) {
+			dev_err(pa_dev->dev, "enable failed, ret = %d\n", ret);
+			ret = -ENODEV;
+			goto fail;
+		}
+
+		pa_get_version(pa_dev);
+
+		/* Start PDSP timer at a prescaler of divide by 2 */
+		__raw_writel(0xffff, &timer_reg->timer_load);
+		__raw_writel((PA_SS_TIMER_CNTRL_REG_GO |
+			      PA_SS_TIMER_CNTRL_REG_MODE |
+			      PA_SS_TIMER_CNTRL_REG_PSE |
+			      (0 << PA_SS_TIMER_CNTRL_REG_PRESCALE_SHIFT)),
+			      &timer_reg->timer_control);
+
+		/* calculate the multiplier/shift to
+		 * convert PA counter ticks to ns. */
+		pa_rate = clk_get_rate(pa_dev->clk) / 2;
+
+		max_sec = ((1ULL << 48) - 1) + (pa_rate - 1);
+		do_div(max_sec, pa_rate);
+
+		clocks_calc_mult_shift(&pa_dev->timestamp_info.mult,
+				&pa_dev->timestamp_info.shift, pa_rate,
+				NSEC_PER_SEC, max_sec);
+
+		dev_info(pa_dev->dev, "pa_clk_rate(%lu HZ),mult(%u),shift(%u)\n",
+				pa_rate, pa_dev->timestamp_info.mult,
+				pa_dev->timestamp_info.shift);
+
+		pa_dev->timestamp_info.system_offset = 0;
+
+		pa_calibrate_with_system_timer(pa_dev);
+
+		dma_cap_zero(mask);
+		dma_cap_set(DMA_SLAVE, mask);
+
+		/* Open the PA Command transmit channel */
+		pa_dev->pdsp0_tx_channel = dma_request_channel_by_name(mask,
+								"patx-pdsp0");
+		if (IS_ERR_OR_NULL(pa_dev->pdsp0_tx_channel)) {
+			dev_err(pa_dev->dev, "Couldnt get PATX cmd channel\n");
+			pa_dev->pdsp0_tx_channel = NULL;
+			ret = -ENODEV;
+			goto fail;
+		}
+
+		memset(&config, 0, sizeof(config));
+		config.direction	= DMA_MEM_TO_DEV;
+		config.tx_queue_depth	= pa_dev->tx_cmd_queue_depth;
+
+		err = dma_keystone_config(pa_dev->pdsp0_tx_channel, &config);
+		if (err)
+			goto fail;
+
+		/* Open the PA common response channel */
+		pa_dev->rx_channel = dma_request_channel_by_name(mask, "parx");
+		if (IS_ERR_OR_NULL(pa_dev->rx_channel)) {
+			dev_err(pa_dev->dev, "Could not get PA RX channel\n");
+			pa_dev->rx_channel = NULL;
+			ret = -ENODEV;
+			goto fail;
+		}
+
+		memset(&config, 0, sizeof(config));
+
+		config.direction		= DMA_DEV_TO_MEM;
+		config.scatterlist_size		= PA_SGLIST_SIZE;
+		config.rxpool_allocator		= pa_rxpool_alloc;
+		config.rxpool_destructor	= pa_rxpool_free;
+		config.rxpool_param		= pa_dev;
+		config.rxpool_count		= 1;
+		config.rxpool_thresh_enable	= DMA_THRESH_NONE;
+		config.rxpools[0].pool_depth	= pa_dev->rx_pool_depth;
+		config.rxpools[0].buffer_size	= pa_dev->rx_buffer_size;
+
+		err = dma_keystone_config(pa_dev->rx_channel, &config);
+		if (err)
+			goto fail;
+
+		tasklet_init(&pa_dev->task, pa_chan_work_handler,
+			     (unsigned long) pa_dev);
+
+		dma_set_notify(pa_dev->rx_channel, pa_chan_notify, pa_dev);
+
+		pa_dev->cmd_flow_num = dma_get_rx_flow(pa_dev->rx_channel);
+		pa_dev->cmd_queue_num = dma_get_rx_queue(pa_dev->rx_channel);
+
+		dev_dbg(pa_dev->dev, "command receive flow %d, queue %d\n",
+			pa_dev->cmd_flow_num, pa_dev->cmd_queue_num);
+
+		pa_dev->addr_count = 0;
+
+		dma_rxfree_refill(pa_dev->rx_channel);
+
+		ret = pa_config_crc_engine(pa_dev);
+		if (ret < 0)
+			goto fail;
+
+		/* make lut entries invalid */
+		for (i = 0; i < pa_dev->lut_size; i++) {
+			if (!pa_dev->lut[i].valid)
+				continue;
+			keystone_pa_add_mac(pa_intf, i, NULL, NULL, PACKET_DROP,
+					    0, PA_INVALID_PORT);
+		}
+	}
+	mutex_unlock(&pa_modules_lock);
+
+	pa_intf->saved_ss_state = netcp_get_streaming_switch(
+						     pa_dev->netcp_device,
+						     netcp_priv->cpsw_port);
+	dev_dbg(pa_dev->dev, "saved_ss_state for port %d is %d\n",
+		 netcp_priv->cpsw_port, pa_intf->saved_ss_state);
+
+	chan = netcp_get_rx_chan(netcp_priv);
+	pa_intf->data_flow_num = dma_get_rx_flow(chan);
+	pa_intf->data_queue_num = dma_get_rx_queue(chan);
+
+	dev_dbg(pa_dev->dev, "configuring data receive flow %d, queue %d\n",
+		 pa_intf->data_flow_num, pa_intf->data_queue_num);
+
+	/* Configure the streaming switch */
+	netcp_set_streaming_switch(pa_dev->netcp_device, netcp_priv->cpsw_port,
+				   PSTREAM_ROUTE_PDSP0);
+
+	/* Open the PA Data transmit channel */
+	ret = netcp_txpipe_open(&pa_intf->tx_pipe);
+	if (ret)
+		goto fail;
+
+	netcp_register_txhook(netcp_priv, pa_dev->txhook_order,
+			      pa_tx_hook, intf_priv);
+	if (pa_dev->csum_offload == CSUM_OFFLOAD_SOFT)
+		netcp_register_txhook(netcp_priv, pa_dev->txhook_softcsum,
+				      pa_txhook_softcsum, intf_priv);
+	netcp_register_rxhook(netcp_priv, pa_dev->rxhook_order,
+			      pa_rx_timestamp, intf_priv);
+
+	return 0;
+
+fail:
+	mutex_unlock(&pa_modules_lock);
+	pa_close(intf_priv, ndev);
+	return ret;
+}
+
+static struct pa_lut_entry *pa_lut_alloc(struct pa_device *pa_dev,
+					 bool backwards)
+{
+	struct pa_lut_entry *entry;
+	int i;
+
+	if (!backwards) {
+		for (i = 0; i < pa_dev->lut_size; i++) {
+			entry = pa_dev->lut + i;
+			if (!entry->valid || entry->in_use)
+				continue;
+			entry->in_use = true;
+			return entry;
+		}
+	} else {
+		for (i = pa_dev->lut_size - 1; i >= 0; i--) {
+			entry = pa_dev->lut + i;
+			if (!entry->valid || entry->in_use)
+				continue;
+			entry->in_use = true;
+			return entry;
+		}
+	}
+	return NULL;
+}
+
+static inline int pa_lut_entry_count(enum netcp_addr_type type)
+{
+	return (type == ADDR_DEV || type == ADDR_UCAST || type == ADDR_ANY) ? 3 : 1;
+}
+
+int pa_add_addr(void *intf_priv, struct netcp_addr *naddr)
+{
+	struct pa_intf *pa_intf = intf_priv;
+	struct pa_device *pa_dev = pa_intf->pa_device;
+	struct netcp_priv *netcp_priv = netdev_priv(pa_intf->net_device);
+	int count = pa_lut_entry_count(naddr->type);
+	struct pa_lut_entry *entries[count];
+	int port = netcp_priv->cpsw_port;
+	int idx, error;
+	const u8 *addr;
+
+	for (idx = 0; idx < count; idx++) {
+		entries[idx] = pa_lut_alloc(pa_dev, naddr->type == ADDR_ANY);
+		entries[idx]->naddr = naddr;
+		if (!entries[idx])
+			goto fail_alloc;
+	}
+
+	addr = (naddr->type == ADDR_ANY) ? NULL : naddr->addr;
+	idx = 0;
+
+	if (naddr->type == ADDR_ANY) {
+		error = keystone_pa_add_mac(pa_intf, entries[idx++]->index,
+					    NULL, addr, PACKET_HST, 0, port);
+		if (error)
+			return error;
+	}
+
+	if (count > 1) {
+		error = keystone_pa_add_mac(pa_intf, entries[idx++]->index,
+					    NULL, addr, PACKET_PARSE,
+					    0x0800, port);
+		if (error)
+			return error;
+
+		error = keystone_pa_add_mac(pa_intf, entries[idx++]->index,
+					    NULL, addr, PACKET_PARSE,
+					    0x86dd, port);
+		if (error)
+			return error;
+	}
+
+	if (naddr->type != ADDR_ANY) {
+		error = keystone_pa_add_mac(pa_intf, entries[idx++]->index,
+					    NULL, addr, PACKET_HST, 0, port);
+		if (error)
+			return error;
+	}
+
+	return error;
+
+fail_alloc:
+	for (idx--; idx >= 0; idx--)
+		entries[idx]->in_use = false;
+	return -ENOMEM;
+}
+
+static int pa_del_addr(void *intf_priv, struct netcp_addr *naddr)
+{
+	struct pa_intf *pa_intf = intf_priv;
+	struct pa_device *pa_dev = pa_intf->pa_device;
+	struct pa_lut_entry *entry;
+	int idx;
+
+	for (idx = 0; idx < pa_dev->lut_size; idx++) {
+		entry = pa_dev->lut + idx;
+		if (!entry->valid || !entry->in_use || entry->naddr != naddr)
+			continue;
+		keystone_pa_add_mac(pa_intf, entry->index, NULL, NULL,
+				    PACKET_DROP, 0, PA_INVALID_PORT);
+		entry->in_use = false;
+	}
+
+	return 0;
+}
+
+static int pa_hwtstamp_ioctl(struct pa_intf *pa_intf,
+			     struct ifreq *ifr, int cmd)
+{
+	struct hwtstamp_config cfg;
+
+	if (copy_from_user(&cfg, ifr->ifr_data, sizeof(cfg)))
+		return -EFAULT;
+
+	if (cfg.flags)
+		return -EINVAL;
+
+	switch (cfg.tx_type) {
+	case HWTSTAMP_TX_OFF:
+		pa_intf->tx_timestamp_enable = false;
+		break;
+	case HWTSTAMP_TX_ON:
+		pa_intf->tx_timestamp_enable = true;
+		break;
+	default:
+		return -ERANGE;
+	}
+
+	switch (cfg.rx_filter) {
+	case HWTSTAMP_FILTER_NONE:
+		pa_intf->rx_timestamp_enable = false;
+		break;
+	default:
+		pa_intf->rx_timestamp_enable = true;
+		break;
+	}
+
+	return copy_to_user(ifr->ifr_data, &cfg, sizeof(cfg)) ? -EFAULT : 0;
+}
+
+int pa_ioctl(void *intf_priv, struct ifreq *req, int cmd)
+{
+	struct pa_intf *pa_intf = intf_priv;
+
+	if (cmd == SIOCSHWTSTAMP)
+		return pa_hwtstamp_ioctl(pa_intf, req, cmd);
+
+	return -EOPNOTSUPP;
+}
+
+static int pa_attach(void *inst_priv, struct net_device *ndev, void **intf_priv)
+{
+	struct pa_device *pa_dev = inst_priv;
+	struct netcp_priv *netcp_priv = netdev_priv(ndev);
+	struct pa_intf *pa_intf;
+	int chan_id = 0;
+
+	if (netcp_priv->cpsw_port)
+		pa_dev->multi_if = 1;
+
+	dev_dbg(pa_dev->dev, "pa_attach, port %d\n", netcp_priv->cpsw_port);
+	pa_intf = devm_kzalloc(pa_dev->dev, sizeof(struct pa_intf), GFP_KERNEL);
+	if (!pa_intf) {
+		dev_err(pa_dev->dev, "memory allocation failed\n");
+		return -ENOMEM;
+	}
+
+	pa_intf->net_device = ndev;
+	pa_intf->pa_device = pa_dev;
+	*intf_priv = pa_intf;
+
+	/* Use pdsp5 with 0 as base */
+	if (netcp_priv->cpsw_port)
+		chan_id = netcp_priv->cpsw_port - 1;
+
+	snprintf(pa_intf->tx_chan_name, sizeof(pa_intf->tx_chan_name),
+		 "patx-pdsp5-%d", chan_id);
+	netcp_txpipe_init(&pa_intf->tx_pipe, netdev_priv(ndev),
+			  pa_intf->tx_chan_name, pa_dev->tx_data_queue_depth);
+
+	if (pa_dev->csum_offload) {
+		rtnl_lock();
+		ndev->features		|= PA_NETIF_FEATURES;
+		ndev->hw_features	|= PA_NETIF_FEATURES;
+		ndev->wanted_features	|= PA_NETIF_FEATURES;
+		netdev_update_features(ndev);
+		rtnl_unlock();
+	}
+	return 0;
+}
+
+static int pa_release(void *intf_priv)
+{
+	struct pa_intf *pa_intf = intf_priv;
+	struct pa_device *pa_dev = pa_intf->pa_device;
+	struct net_device *ndev = pa_intf->net_device;
+
+	mutex_lock(&pa_modules_lock);
+	if ((!--pa_dev->inuse_if_count) && (pa_dev->csum_offload)) {
+		rtnl_lock();
+		ndev->features		&= ~PA_NETIF_FEATURES;
+		ndev->hw_features	&= ~PA_NETIF_FEATURES;
+		ndev->wanted_features	&= ~PA_NETIF_FEATURES;
+		netdev_update_features(ndev);
+		rtnl_unlock();
+	}
+	mutex_unlock(&pa_modules_lock);
+
+	devm_kfree(pa_dev->dev, pa_intf);
+	return 0;
+}
+
+
+
+#define pa_cond_unmap(field)					\
+	do {							\
+		if (pa_dev->field)				\
+			devm_iounmap(dev, pa_dev->field);	\
+	} while(0)
+
+static int pa_remove(struct netcp_device *netcp_device, void *inst_priv)
+{
+	struct pa_device *pa_dev = inst_priv;
+	struct device *dev = pa_dev->dev;
+
+	pa_cond_unmap(reg_mailbox);
+	pa_cond_unmap(reg_packet_id);
+	pa_cond_unmap(reg_lut2);
+	pa_cond_unmap(reg_control);
+	pa_cond_unmap(reg_timer);
+	pa_cond_unmap(reg_stats);
+	pa_cond_unmap(pa_iram);
+	pa_cond_unmap(pa_sram);
+
+	kfree(pa_dev);
+
+	return 0;
+}
+
+static int pa_probe(struct netcp_device *netcp_device,
+		    struct device *dev,
+		    struct device_node *node,
+		    void **inst_priv)
+{
+	struct pa_device *pa_dev;
+	int ret, len = 0, start, end, i, j;
+	int table_size, num_ranges;
+	u32 *prange;
+
+	if (!node) {
+		dev_err(dev, "device tree info unavailable\n");
+		return -ENODEV;
+	}
+
+	pa_dev = devm_kzalloc(dev, sizeof(struct pa_device), GFP_KERNEL);
+	if (!pa_dev) {
+		dev_err(dev, "memory allocation failed\n");
+		return -ENOMEM;
+	}
+	*inst_priv = pa_dev;
+
+	pa_dev->netcp_device = netcp_device;
+	pa_dev->dev = dev;
+
+	ret = of_property_read_u32(node, "tx_cmd_queue_depth",
+				   &pa_dev->tx_cmd_queue_depth);
+	if (ret < 0) {
+		dev_err(dev, "missing tx_cmd_queue_depth parameter, err %d\n",
+			ret);
+		pa_dev->tx_cmd_queue_depth = 32;
+	}
+	dev_dbg(dev, "tx_cmd_queue_depth %u\n", pa_dev->tx_cmd_queue_depth);
+
+	ret = of_property_read_u32(node, "tx_data_queue_depth",
+				   &pa_dev->tx_data_queue_depth);
+	if (ret < 0) {
+		dev_err(dev, "missing tx_data_queue_depth parameter, err %d\n",
+			ret);
+		pa_dev->tx_data_queue_depth = 32;
+	}
+	dev_dbg(dev, "tx_data_queue_depth %u\n", pa_dev->tx_data_queue_depth);
+
+	ret = of_property_read_u32(node, "rx_pool_depth",
+				   &pa_dev->rx_pool_depth);
+	if (ret < 0) {
+		dev_err(dev, "missing rx_pool_depth parameter, err %d\n",
+			ret);
+		pa_dev->rx_pool_depth = 32;
+	}
+	dev_dbg(dev, "rx_pool_depth %u\n", pa_dev->rx_pool_depth);
+
+	ret = of_property_read_u32(node, "rx_buffer_size",
+				   &pa_dev->rx_buffer_size);
+	if (ret < 0) {
+		dev_err(dev, "missing rx_buffer_size parameter, err %d\n",
+			ret);
+		pa_dev->rx_buffer_size = 128;
+	}
+	dev_dbg(dev, "rx_buffer_size %u\n", pa_dev->rx_buffer_size);
+
+	pa_dev->reg_mailbox	= devm_ioremap(dev, 0x2000000, 0x60);
+	pa_dev->reg_packet_id	= devm_ioremap(dev, 0x2000400, 0x10);
+	pa_dev->reg_lut2	= devm_ioremap(dev, 0x2000500, 0x40);
+	pa_dev->reg_control	= devm_ioremap(dev, 0x2001000, 0x600);
+	pa_dev->reg_timer	= devm_ioremap(dev, 0x2003000, 0x600);
+	pa_dev->reg_stats	= devm_ioremap(dev, 0x2006000, 0x100);
+	pa_dev->pa_iram		= devm_ioremap(dev, 0x2010000, 0x30000);
+	pa_dev->pa_sram		= devm_ioremap(dev, 0x2040000, 0x8000);
+
+	if (!pa_dev->reg_mailbox || !pa_dev->reg_packet_id ||
+	    !pa_dev->reg_lut2 || !pa_dev->reg_control ||
+	    !pa_dev->reg_timer || !pa_dev->reg_stats ||
+	    !pa_dev->pa_sram || !pa_dev->pa_iram) {
+		dev_err(dev, "failed to set up register areas\n");
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	ret = of_property_read_u32(node, "checksum-offload",
+				   &pa_dev->csum_offload);
+	if (ret < 0) {
+		dev_warn(dev, "missing checksum-offload parameter, err %d\n",
+			ret);
+		pa_dev->csum_offload = CSUM_OFFLOAD_NONE;
+	}
+	if (pa_dev->csum_offload > CSUM_OFFLOAD_SOFT) {
+		dev_err(dev, "invalid checksum-offload parameter %d, err %d\n",
+			ret, pa_dev->csum_offload);
+		pa_dev->csum_offload = CSUM_OFFLOAD_NONE;
+	}
+	dev_dbg(dev, "checksum-offload %u\n", pa_dev->csum_offload);
+
+	ret = of_property_read_u32(node, "txhook-order",
+				   &pa_dev->txhook_order);
+	if (ret < 0) {
+		dev_err(dev, "missing txhook-order parameter, err %d\n",
+			ret);
+		pa_dev->txhook_order = PA_TXHOOK_ORDER;
+	}
+	dev_dbg(dev, "txhook-order %u\n", pa_dev->txhook_order);
+
+	if (pa_dev->csum_offload == CSUM_OFFLOAD_SOFT) {
+		ret = of_property_read_u32(node, "txhook-softcsum",
+					   &pa_dev->txhook_softcsum);
+		if (ret < 0) {
+			dev_err(dev, "missing txhook-softcsum parameter, err %d\n",
+				ret);
+			pa_dev->csum_offload = CSUM_OFFLOAD_NONE;
+			pa_dev->txhook_order = ~0;
+		}
+		dev_dbg(dev, "txhook-softcsum %u\n", pa_dev->txhook_softcsum);
+	}
+
+	ret = of_property_read_u32(node, "rxhook-order",
+				   &pa_dev->rxhook_order);
+	if (ret < 0) {
+		dev_err(dev, "missing rxhook-order parameter, err %d\n",
+			ret);
+		pa_dev->rxhook_order = PA_RXHOOK_ORDER;
+	}
+	dev_dbg(dev, "rxhook-order %u\n", pa_dev->rxhook_order);
+
+	if (!of_get_property(node, "lut-ranges", &len)) {
+		dev_err(dev, "No lut-entry array in dt bindings for PA\n");
+		return -ENODEV;
+	}
+
+	prange = devm_kzalloc(dev, len, GFP_KERNEL);
+	if (!prange) {
+		dev_err(dev, "memory allocation failed at PA lut entry range\n");
+		return -ENOMEM;
+	}
+	len = len / sizeof(u32);
+	if ((len % 2) != 0) {
+		dev_err(dev, "invalid address map in dt binding\n");
+		return -EINVAL;
+	}
+	num_ranges = len / 2;
+	if (of_property_read_u32_array(node, "lut-ranges", prange, len)) {
+		dev_err(dev, "No range-map array  in dt bindings\n");
+		return -ENODEV;
+	}
+
+	table_size = prange[2 * num_ranges - 1] + 1;
+	dev_dbg(dev, "lut size = %d\n", table_size);
+
+	/* Initialize a table for storing entry listings locally */
+	len = table_size * sizeof(struct pa_lut_entry);
+	pa_dev->lut  = devm_kzalloc(dev, len, GFP_KERNEL);
+	if (!pa_dev->lut) {
+		dev_err(dev, "devm_kzalloc mapping failed\n");
+		return -ENOMEM;
+	}
+	pa_dev->lut_size = table_size;
+	dev_dbg(dev, "lut size = %d\n", table_size);
+
+	for (i = 0; i < num_ranges; i++) {
+		start = prange[i * 2];
+		end   = prange[i * 2 + 1];
+		for (j = start; j <= end; j++) {
+			pa_dev->lut[j].valid = true;
+			pa_dev->lut[j].index = j;
+			dev_dbg(dev, "setting entry %d to valid\n", j);
+		}
+	}
+
+	devm_kfree(pa_dev->dev, prange);
+
+	spin_lock_init(&pa_dev->lock);
+	spin_lock_init(&tstamp_lock);
+
+	return 0;
+
+exit:
+	pa_remove(netcp_device, pa_dev);
+	*inst_priv = NULL;
+	return ret;
+}
+
+
+static struct netcp_module pa_module = {
+	.name		= "keystone-pa",
+	.owner		= THIS_MODULE,
+	.probe		= pa_probe,
+	.open		= pa_open,
+	.close		= pa_close,
+	.remove		= pa_remove,
+	.attach		= pa_attach,
+	.release	= pa_release,
+	.add_addr	= pa_add_addr,
+	.del_addr	= pa_del_addr,
+	.ioctl		= pa_ioctl,
+};
+
+static int __init keystone_pa_init(void)
+{
+	return netcp_register_module(&pa_module);
+}
+module_init(keystone_pa_init);
+
+static void __exit keystone_pa_exit(void)
+{
+	netcp_unregister_module(&pa_module);
+}
+module_exit(keystone_pa_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Sandeep Paulraj <s-paulraj@ti.com>");
+MODULE_DESCRIPTION("Packet Accelerator driver for Keystone devices");
diff --git a/drivers/net/ethernet/ti/keystone_pa.h b/drivers/net/ethernet/ti/keystone_pa.h
new file mode 100644
index 0000000..a7d61cf
--- /dev/null
+++ b/drivers/net/ethernet/ti/keystone_pa.h
@@ -0,0 +1,741 @@
+/*
+ * Copyright (C) 2012 Texas Instruments Incorporated
+ * Author: Sandeep Paulraj <s-paulraj@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef KEYSTONE_PA_H
+#define KEYSTONE_PA_H
+
+#ifdef __KERNEL__
+
+
+struct pa_pdsp_config {
+
+	u32 pdsp[6];
+
+	char *pdsp_fw[6];
+};
+
+#define PAFRM_MAX_CMD_SET_SIZE		124
+
+#define	PA_DEST_DISCARD  3  /**< Packet is discarded */
+
+/** 
+ *  @def  PA_DEST_CONTINUE_PARSE_LUT1
+ *        packet remains in PA sub-system for more parsing and LUT1 classification
+ */
+#define PA_DEST_CONTINUE_PARSE_LUT1  4 /**< Packet remains in PA sub-system for more parsing and LUT1 classification */
+
+/** 
+ *  @def  PA_DEST_CONTINUE_PARSE_LUT2
+ *        packet remains in PA sub-system for more parsing and LUT2 classification. 
+ */
+#define PA_DEST_CONTINUE_PARSE_LUT2  5  /**< Packet remains in PA sub-system for more parsing and LUT2 classification */
+
+/**
+ *  @def  PA_DEST_HOST
+ *        host thread 
+ */
+#define PA_DEST_HOST   6   /**< Packet is routed to host */
+
+/** 
+ *  @def  PA_DEST_EMAC
+ *        ethernet mac port (of the switch)
+ */
+#define PA_DEST_EMAC   7   /**< Packet is routed to  EMAC */
+
+/** 
+ *  @def  PA_DEST_SASS
+ *        security accelerator destination 
+ */
+#define PA_DEST_SASS   8   /**< Packet is routed to SA */
+
+#define PA_DEST_SRIO   9
+
+#define PA_NO_MULTI_ROUTE		-1
+#define PA_MAX_MULTI_ROUTE_SETS		32
+#define PA_MAX_MULTI_ROUTE_ENTRIES	8
+#define PA_MULTI_ROUTE_DESCRIPTOR_ONLY	0x01
+
+#define PA_EMAC_CTRL_PORT_MASK		0x0F 
+#define PA_EMAC_CTRL_CRC_DISABLE	0x80 
+#define PA_CUSTOM_TYPE_NONE		0   
+#define PA_CUSTOM_TYPE_LUT1		1   
+#define PA_CUSTOM_TYPE_LUT2		2   
+#define PA_MAX_CUSTOM_TYPES_LUT1	4
+#define PA_MAX_CUSTOM_TYPES_LUT2	4
+
+#define PA_CMD_TX_DEST_0	0  /* Packet is sent to PDSP0 */
+#define PA_CMD_TX_DEST_1	1  /* Packet is sent to PDSP1 */
+#define PA_CMD_TX_DEST_2	2  /* Packet is sent to PDSP2 */
+#define PA_CMD_TX_DEST_3	3  /* Packet is sent to PDSP3 */
+#define PA_CMD_TX_DEST_4	4  /* Packet is sent to PDSP4 */
+#define PA_CMD_TX_DEST_5	5  /* Packet is sent to PDSP5 */
+
+#define PA_CMD_NONE			0   
+#define PA_CMD_NEXT_ROUTE		1   
+#define PA_CMD_CRC_OP			2   
+#define PA_CMD_COPY_DATA_TO_PSINFO	3
+#define PA_CMD_PATCH_DATA		4  
+#define PA_CMD_TX_CHECKSUM		5 
+#define PA_CMD_MULTI_ROUTE		6  
+#define PA_CMD_REPORT_TX_TIMESTAMP	7 
+#define PA_CMD_REMOVE_HEADER		8 
+#define PA_CMD_REMOVE_TAIL		9 
+#define PA_CMD_CMDSET			10   
+#define PA_CMD_SA_PAYLOAD		11
+#define PA_CMD_IP_FRAGMENT		12
+#define PA_CMD_USR_STATS		13
+#define PA_CMD_CMDSET_AND_USR_STATS	14
+
+struct pa_frm_forward_host {
+
+	u32	context;	/* Context returned as swInfo0 for matched packet */
+	u8	multi_route;	/* True if multiple destination enabled */
+	u8	multi_idx;	/* Index of the multiple destination set */
+	u8	pa_pdsp_router; /* PA PDSP number used as multi-route router */
+	u8	rsvd2;
+	u8	cmd[4];		/* optional simple command: 0 means no command */
+}; /* 12 bytes */
+
+/*
+ * Routing information used to forward packets to the SA (via PKTDMA) 
+ */
+struct pa_frm_forward_sa {
+
+	u32	sw_info_0;	/* Packet descriptor swInfo0 required by SA operation */
+	u32	sw_info_1;	/* Packet descriptor swInfo1 required by SA operation */
+	u8	cmd[4];		/* optional simple command: 0 means no command */
+};
+
+/*
+ * Routing information used to forward packets to the SRIO (via PKTDMA) 
+ */
+struct pa_frm_forward_srio {
+
+	u32  ps_info0;		/* 8-byte protocol-specific information required by SRIO  */
+	u32  ps_info1;		/* routing */
+	u8   pkt_type;		/* Packet type specified for SRIO operation */
+	u8   rsv4[3];
+};
+
+/*
+ * Routing information used to forward packets to the Ethernet port 
+ */
+struct pa_frm_forward_eth {
+	u8	ps_flags;  /* use the bit 7:4 bit 7: Disable CRC, bit 6:4 port number (0/1/2) bit 3:0 errflags = 0*/
+	u8	rsvd1;
+	u16	rsvd2;
+	u32	rsvd3;
+	u32	rsvd4;
+};
+
+#define PAFRM_ETH_PS_FLAGS_DISABLE_CRC          0x80
+#define PAFRM_ETH_PS_FLAGS_PORT_MASK            0x70
+#define PAFRM_ETH_PS_FLAGS_PORT_SHIFT              4
+
+
+/* Routing information used to forward packets within PA */
+struct pa_frm_forward_pa {
+
+	u8	pa_dest;      /* PDSP destination */
+	u8	custom_type;  /* None, LUT1, LUT2 */
+	u8	custom_idx;   /* Index of the custom type if LUT1 or LUT2 custom */
+	u8	rsvd2;
+	u32	rsvd3;
+	u32	rsvd4;
+};
+
+#define PAFRM_CUSTOM_TYPE_NONE PA_CUSTOM_TYPE_NONE    /* 0 */
+#define PAFRM_CUSTOM_TYPE_LUT1 PA_CUSTOM_TYPE_LUT1    /* 1 */
+#define PAFRM_CUSTOM_TYPE_LUT2 PA_CUSTOM_TYPE_LUT2    /* 2 */
+
+/*
+ * Routing information used to forward packets fromm PA sub-system to various destinations
+ */
+struct pa_frm_forward  {
+
+	u8 forward_type;	/* Forwarding type as defined below */
+	u8 flow_id;		/* PKTDMA flow Id, valid if forwarding via PKTDMA */
+	u16 queue;		/* Destination queue number, valid if forwarding via PKTDMA */
+  
+	union {
+		struct pa_frm_forward_host	host;    /* Host specific routing information */
+		struct pa_frm_forward_sa	sa;      /* SA specific routing information */
+		struct pa_frm_forward_srio	srio;    /* SRIO specific routing information */
+		struct pa_frm_forward_eth	eth;     /* Ethernet specific routing information */
+		struct pa_frm_forward_pa	pa;      /* PA internal routing information */
+	} u;
+};
+
+enum {
+	PAFRM_FORWARD_TYPE_HOST = 0,	/* use PAFRM_DEST_CDMA */
+	PAFRM_FORWARD_TYPE_SA,		/* use PAFRM_DEST_CDMA */
+	PAFRM_FORWARD_TYPE_PA,		/* use pa.paDest */
+	PAFRM_FORWARD_TYPE_ETH,		/* use PAFRM_DEST_ETH */
+	PAFRM_FORWARD_TYPE_SRIO,	/* use PAFRM_DEST_CDMA */
+	PAFRM_FORWARD_TYPE_DISCARD
+};
+
+/* Custom match flag bits */
+#define	PAFRM_LUT1_CUSTOM_MATCH_ETYPE	(1 << 2)
+#define	PAFRM_LUT1_CUSTOM_MATCH_VLAN	(1 << 3)
+#define	PAFRM_LUT1_CUSTOM_MATCH_MATCH	(3 << 4)  /* Ipv6 source and dest entries */
+#define	PAFRM_LUT1_CUSTOM_MATCH_KEY	(1 << 13)
+#define	PAFRM_LUT1_CUSTOM_MATCH_VALID	(1 << 15)
+
+/* Key values. The PDSP will set these bits as it parses the SRIO header */
+#define PAFRM_LUT1_CUSTOM_KEY_CUSTOM		PAFRM_LUT1_KEY_CUSTOM
+#define PAFRM_LUT1_CUSTOM_KEY_INDEX(index)	((index) << 0)  /* Vaild if custom type is set */
+
+/* Add entry to LUT1 */
+/* if PA_LUT1_INDEX_LAST_FREE is used then when the command returns, the value of index
+ * will be replaced with the actual index used */
+#define PAFRM_HW_LUT1_ENTRIES		64
+#define PAFRM_LUT1_INDEX_LAST_FREE	PAFRM_HW_LUT1_ENTRIES
+
+/* Standard match flag bits */
+#define PAFRM_LUT1_MATCH_DMAC		(1 << 0)
+#define PAFRM_LUT1_MATCH_SMAC		(1 << 1)
+#define PAFRM_LUT1_MATCH_ETYPE		(1 << 2)
+#define PAFRM_LUT1_MATCH_VLAN		(1 << 3)
+#define PAFRM_LUT1_MATCH_SIP		(1 << 4)
+#define PAFRM_LUT1_MATCH_DIP		(1 << 5)
+#define PAFRM_LUT1_MATCH_SPI_GRE_SCTP	(1 << 6)
+#define PAFRM_LUT1_MATCH_FLOW		(1 << 7)
+#define PAFRM_LUT1_MATCH_SPORT		(1 << 8)
+#define PAFRM_LUT1_MATCH_DPORT		(1 << 9)
+#define PAFRM_LUT1_MATCH_PROTO		(1 << 10)
+#define PAFRM_LUT1_MATCH_TOS		(1 << 11)
+#define PAFRM_LUT1_MATCH_PORT		(1 << 12)
+#define PAFRM_LUT1_MATCH_KEY		(1 << 13)
+#define PAFRM_LUT1_MATCH_VALID		(1 << 15)
+
+#define PAFRM_LUT1_MATCH_MPLS		(PAFRM_LUT1_MATCH_SPORT | PAFRM_LUT1_MATCH_DPORT)
+
+/* Key values. The PDSP will set these bits as it parses the headers. */
+/* LUT1_1 and LUT1_2 (L3): The following bit fields are used */
+#define PAFRM_LUT1_KEY_SPI	(1 << 0)
+#define PAFRM_LUT1_KEY_GRE	(1 << 1)
+#define PAFRM_LUT1_KEY_MPLS	(1 << 2)
+#define PAFRM_LUT1_KEY_IPV4	(1 << 3)
+#define PAFRM_LUT1_KEY_IPV6	(1 << 4)
+#define PAFRM_LUT1_KEY_SCTP	(1 << 5)
+
+/* LUT1: Custom  (L3) */
+#define PAFRM_LUT1_KEY_CUSTOM	(1 << 7)     
+
+/* LUT1_0: MAC and SRIO (L0-l2): The following bit fields are used */
+#define PAFRM_LUT1_KEY_SRIO	(1 << 7)
+
+#define PAFRM_LUT1_KEY_MAC    (1 << 0)
+
+struct pa_frm_com_l1_standard {
+
+	/* LUT1 view 1 */
+	u8	dmac[6];	/* Destination mac */
+	u8	smac[6];	/* Source mac */
+	u16	etype;		/* Ethernrt type, the field is also used for the previous match PDSP number */
+	u16	vlan;		/* VLAN tag, the field is also used for the previous match LUT1 index */
+  
+	/* LUT1 view 2 */
+	u8	src_ip[16];	/* Source IP address */
+	u8	dst_ip[16];	/* Destination IP address */
+  
+	/* LUT1 view 3 */
+	u32	spi;		/* ESP or AH header Security Parameters Index */
+				/* The field is also used for GRE protocol or SCTP destination port */
+	u32	flow;		/* IPv6 flow label in 20 lsbs */
+  
+	union {
+		u16	ports[2];   /* UDP/TCP Source port (0), destination port (1) */
+		u32	mpls;       /* mpls label in 20 Lsbs */
+	} pm;
+  
+	u8	proto_next;	/* Ipv4 Protocol fields, IPv6 next */
+	u8	tos_tclass;	/* Ipv4 TOS, Ipv6 traffic class */
+	u8	inport;		/* reserved field: not used */
+	u8	key;		/* IP: Distinguishs spi/gre and mpls and ports
+					* LUT1_0: MAC/SRIO, 
+					* LUT1_1/LUT1_2: custom or standard 
+					*/
+	/* end LUT1 view 3 */
+  
+	/* Lookup cares/don't cares */
+	u16	match_flags;	/* lookup matching valid flags as defined below */
+	u16	rsvd;		/* reserved for alignment */
+};
+
+struct pa_frm_com_l1_srio {
+
+	/* LUT1 view 1 */
+	u8	rsvd1[4];	/* unused field: All zero's */
+	u16	src_id;	/* Source ID */
+	u16	dest_id;	/* Destination ID */
+	u8	rsvd2[4];	/* unused field: All zero's */
+	u16	etype;	/* upper link (previous match PDSP number) */
+	u16	vlan;	/* upper link (previous match LUT1 index) */
+  
+	/* LUT1 view 2 */
+	u8	rsvd3[16];		/* unused field: All zero's */
+	u8	rsvd4[14];		/* unused field: All zero's */
+	u16	type_param1;	/* stream ID or mailbox */
+  
+	/* LUT1 view 3 */
+	u32	spi;	/* unused field: All zero's */
+	u32	flow;	/* unused field: All zero's */
+  
+	u16	next_hdr_offset;	/* unused field: All zero's */
+	u8	next_hdr;		/* place holder for nextHdr and nextOffset */
+	u8	rsvd5;			/* unused field: All zero's */
+	u8	pri;			/* 3-bit Priority */
+	u8	type_param2;		/* cos or letter */
+	u8	inport;			/* unused field: All zero's */
+	u8	key;			/* IP: Distinguishs spi/gre and mpls and ports
+					 * LUT1_0: MAC/SRIO, 
+					 * LUT1_1/LUT1_2: custom or standard 
+					 */
+	/* end LUT1 view 3 */
+	/* Lookup cares/don't cares */
+	u16	match_flags;		/* lookup matching valid flags as defined below */
+	u16	rsvd;			/* reserved for alignment */
+};
+
+struct pa_frm_com_l1_custom{
+
+	/* LUT1 view 1 */
+	u8	dmac[6];	/* unused field: All zero's */
+	u8	smac[6];	/* unused field: All zero's */
+	u16	etype;		/* upper link (previous match PDSP number) */
+	u16	vlan;		/* upper link (previous match LUT1 index) */
+  
+	/* LUT1 view 2 */
+	u8	match_values[32];	/* 32 bytes to match   */
+  
+	/* LUT1 view 3 - offset from start */
+	u32	rsvd0;		/* unused field: All zero's */
+	u32	rsvd1;		/* unused field: All zero's */
+	u32	rsvd2;		/* unused field: All zero's */
+  
+	u8	rsvd3;		/* unused field: All zero's */
+	u8	rsvd4;		/* unused field: All zero's */
+	u8	inport;		/* unused field: All zero's */
+	u8	key;		/* IP: Distinguishs spi/gre and mpls and ports
+				 * LUT1_0: MAC/SRIO, 
+				 * LUT1_1/LUT1_2: custom or standard 
+				 */
+  
+	/* Lookup cares/dont cares */
+	u16	match_flags;	/* lookup matching valid flags as defined below */
+	u16	rsvd5;		/* reserved for alignment */ 
+};
+
+enum {
+	PAFRM_CONFIG_COMMAND_RSVD	= 0,
+	PAFRM_CONFIG_COMMAND_ADDREP_LUT1,
+	PAFRM_CONFIG_COMMAND_DEL_LUT1,
+	PAFRM_CONFIG_COMMAND_ADDREP_LUT2,
+	PAFRM_CONFIG_COMMAND_DEL_LUT2,
+	PAFRM_CONFIG_COMMAND_CONFIG_PA,
+	PAFRM_CONFIG_COMMAND_REQ_STATS,
+	PAFRM_CONFIG_COMMAND_REQ_VERSION,
+	PAFRM_CONFIG_COMMAND_MULTI_ROUTE,
+	PAFRM_CONFIG_COMMAND_CRC_ENGINE,
+	PAFRM_CONFIG_COMMAND_CMD_SET
+};
+
+/* Command magic value */
+#define PAFRM_CONFIG_COMMAND_SEC_BYTE  0xce
+
+/* Command return values */
+enum {
+
+	PAFRM_COMMAND_RESULT_SUCCESS = 0,              /* Must be 0 */
+	PAFRM_COMMAND_RESULT_NO_COMMAND_MAGIC,         /* Command magic value not found */
+  
+	PAFRM_COMMAND_RESULT_INVALID_CMD,              /* Invalid command identifier */
+  
+	/* Add entry to LUT1 fails */
+	PAFRM_COMMAND_RESULT_LUT1_TYPE_INVALID,        /* Invalid type, custom or standard IP/ethernet */
+	PAFRM_COMMAND_RESULT_LUT1_INDEX_INVALID,       /* Invalid LUT1 index (0-63) or no free indices available */
+	PAFRM_COMMAND_RESULT_LUT1_MATCH_DEST_INVALID,  /* Sent a match packet to q0 on c1 or c2 - this is illegal. */
+	PAFRM_COMMAND_RESULT_LUT1_NMATCH_INVALID,      /* Previous match forward info was somewhere in chunk domain */
+	PAFRM_COMMAND_RESULT_LUT1_INVALID_KEYS,        /* Invalid combination found in the key value */
+  
+	/* Lut 2 entry warnings since the lut can be configured without pdsp */
+	PAFRM_COMMAND_RESULT_WARN_OVER_MAX_ENTRIES,
+	PAFRM_COMMAND_RESULT_WARN_NEGATIVE_ENTRY_COUNT,
+  
+	/* Lut 2 entry failures */
+	PAFRM_COMMAND_RESULT_LUT2_ADD_BUSY,            /* LUT2 had a lookup and pending config */
+  
+	/* Not enough room in stats request packet for the reply */
+	PAFRM_COMMAND_RESULT_WARN_STATS_REPLY_SIZE,
+  
+	/* Command sent to PDSP which couldn't handle it */
+	PAFRM_COMMAND_RESULT_INVALID_DESTINATION,
+  
+	/* Add/Delete/Read entries to multi route table */
+	PAFRM_COMMAND_RESULT_MULTI_ROUTE_NO_FREE_ENTRIES,    /* Asked to use a free entry, but none found */
+	PAFRM_COMMAND_RESULT_MULTI_ROUTE_INVALID_IDX,        /* Illegal index value used */
+	PAFRM_COMMAND_RESULT_MULTI_ROUTE_INVALID_MODE,       /* Illegal multi route mode used */
+  
+	/* Packet size didn't match command */
+	PAFRM_COMMAND_RESULT_INVALID_PKT_SIZE,
+  
+	/* Coustom and Command set index */
+	PAFRM_COMMAND_RESULT_INVALID_C1_CUSTOM_IDX,          /* Illegal Custom LUT1 index value used */
+	PAFRM_COMMAND_RESULT_INVALID_C2_CUSTOM_IDX,          /* Illegal Custom LUT2 index value used */
+	PAFRM_COMMAND_RESULT_INVALID_CMDSET_IDX              /* Illegal Custom Command Set index value used */
+};
+
+#define PA_SS_TIMER_CNTRL_REG_GO		0x00000001u
+#define PA_SS_TIMER_CNTRL_REG_MODE		0x00000002u
+#define PA_SS_TIMER_CNTRL_REG_PSE		0x00008000u
+#define PA_SS_TIMER_CNTRL_REG_PRESCALE_SHIFT	0x00000002u
+
+/* Destination (route) values */
+#define PAFRM_DEST_PDSP0	0
+#define PAFRM_DEST_PDSP1	1
+#define PAFRM_DEST_PDSP2	2
+#define PAFRM_DEST_PDSP3	3
+#define PAFRM_DEST_PDSP4	4
+#define PAFRM_DEST_PDSP5	5
+#define PAFRM_DEST_PKTDMA	6   
+#define PAFRM_DEST_ETH		7
+
+#define PAFRM_DEST_DISCARD	10
+
+/* Assigning names based on PDSP functions */
+#define PAFRM_DEST_PA_C1_0	PAFRM_DEST_PDSP0
+#define PAFRM_DEST_PA_C1_1	PAFRM_DEST_PDSP1
+#define PAFRM_DEST_PA_C1_2	PAFRM_DEST_PDSP2 
+#define PAFRM_DEST_PA_C2	PAFRM_DEST_PDSP3
+#define PAFRM_DEST_PA_M_0	PAFRM_DEST_PDSP4
+#define PAFRM_DEST_PA_M_1	PAFRM_DEST_PDSP5
+
+/* The default queue for packets that arrive at the PA and don't match in
+ * classify1 (right at init time) */
+#define PAFRM_DEFAULT_INIT_Q	0x100
+
+/* Ethertypes recognized by the firmware. */
+#define PAFRM_ETHERTYPE_IP		0x0800
+#define PAFRM_ETHERTYPE_IPV6		0x86dd
+#define PAFRM_ETHERTYPE_VLAN		0x8100
+#define PAFRM_ETHERTYPE_SPVLAN		0x88a8
+#define PAFRM_ETHERTYPE_MPLS		0x8847
+#define PAFRM_ETHERTYPE_MPLS_MULTI	0x8848
+
+/* Next header type values  */
+#define PAFRM_HDR_MAC			0
+#define PAFRM_HDR_VLAN			1
+#define PAFRM_HDR_MPLS			2
+#define PAFRM_HDR_IPv4			3
+#define PAFRM_HDR_IPv6			4
+#define PAFRM_HDR_IPv6_EXT_HOP		5
+#define PAFRM_HDR_IPv6_EXT_ROUTE	6
+#define PAFRM_HDR_IPv6_EXT_FRAG		7
+#define PAFRM_HDR_IPv6_EXT_DEST		8
+#define PAFRM_HDR_GRE			9
+#define PAFRM_HDR_ESP			10
+#define PAFRM_HDR_ESP_DECODED		11
+#define PAFRM_HDR_AUTH			12
+#define PAFRM_HDR_CUSTOM_C1		13
+#define PAFRM_HDR_FORCE_LOOKUP		14   /* A contrived header type used with custom SRIO to force
+                                           a parse after looking at only the RIO L0-L2 */
+#define PAFRM_HDR_SCTP			15
+#define PAFRM_HDR_UNKNOWN		16
+#define PAFRM_HDR_UDP			17
+#define PAFRM_HDR_UDP_LITE		18
+#define PAFRM_HDR_TCP			19
+#define PAFRM_HDR_GTPU			20
+#define PAFRM_HDR_ESP_DECODED_C2	21
+#define PAFRM_HDR_CUSTOM_C2		22
+
+/* Command related definitions */
+#define PAFRM_CRC_FLAG_CRC_OFFSET_VALID		0x01
+#define PAFRM_CRC_FLAG_CRC_OFFSET_FROM_DESC	0x02
+#define PAFRM_CHKSUM_FALG_NEGATIVE		0x01
+
+#define PA_NEXT_ROUTE_PARAM_PRESENT		0x0001
+#define PA_NEXT_ROUTE_PROC_NEXT_CMD		0x0002
+#define PA_NEXT_ROUTE_PROC_MULTI_ROUTE		0x0004
+
+/* PAFRM receive commands related definitions */
+
+/* 
+ * There are the following two groups of PAFRM receive commands:
+ * PAFRM short commands which can be used as part of the routing info 
+ * PAFRM commands which can be used within a command set
+ */
+ 
+#define PAFRM_RX_CMD_NONE		0           /* Dummy command */
+
+/* short commands */
+#define PAFRM_RX_CMD_CMDSET		1           /* Execute a command set */
+#define PAFRM_RX_CMD_INSERT		2           /* Insert up to two types at the current location */
+
+/* command set commands */
+#define PAFRM_RX_CMD_NEXT_ROUTE		3           /* Specify the next route */
+#define PAFRM_RX_CMD_CRC_OP		4           /* CRC generation or verification */
+#define PAFRM_RX_CMD_COPY_DATA		5           /* Copy data to the PS Info section */
+#define PAFRM_RX_CMD_PATCH_DATA		6           /* Insert or pacth packet data at the specific location */
+#define PAFRM_RX_CMD_REMOVE_HDR		7           /* Remove the parsed packet header */
+#define PAFRM_RX_CMD_REMOVE_TAIL	8           /* Remove the parsed packet tail */
+#define PAFRM_RX_CMD_MULTI_ROUTE	9           /* Duplicate packet to multiple destinations */
+
+/*
+ * PASS command ID formatting
+ * Bit 15 is used to distinguish the L2 table from
+ * the L3 table in the command comId field
+ */
+#define PA_COMID_L2		(0 << 15)
+#define PA_COMID_L3		(1 << 15)
+#define PA_COMID_L_MASK		(1 << 15)
+#define PA_COMID_IDX_MASK	(~(1 << 15))
+
+/* define LUT1 entry types */
+#define PAFRM_COM_ADD_LUT1_STANDARD	0	/* MAC/IP */
+#define PAFRM_COM_ADD_LUT1_SRIO		1	/* SRIO */
+#define PAFRM_COM_ADD_LUT1_CUSTOM	2   /* Custom LUT1 */
+
+struct pa_frm_cmd_add_lut1 {
+
+	u8	index;		/* LUT1 index. */
+	u8	type;		/* Custom or standard */
+	u8	rsvd;		/* reserved for alignment */
+	u8	cust_index;     /* Vaild only if type is custom */
+	
+	union {
+		struct	pa_frm_com_l1_standard	eth_ip;   /* matching information for MAC/IP entry */
+		struct	pa_frm_com_l1_srio	srio;
+		struct	pa_frm_com_l1_custom	custom;
+	} u;
+
+	struct	pa_frm_forward match;	/* Routing information when a match is found */
+  
+	/*
+	 * Routing information when subsequent match fails - a fragmented
+	 * packet orinner route
+	 */
+	struct	pa_frm_forward next_fail;
+};
+
+/* CRC Engine Configuration */
+#define PARAM_CRC_TABLE_SIZE    16
+
+struct pa_frm_config_crc {
+	u8	ctrl_bitmap;			/* Control bit maps as defined below */
+#define PARAM_CRC_SIZE_8         0
+#define PARAM_CRC_SIZE_16        1
+#define PARAM_CRC_SIZE_24        2
+#define PARAM_CRC_SIZE_32        3
+
+#define PARAM_CRC_CTRL_CRC_SIZE_MASK    0x3
+#define PARAM_CRC_CTRL_LEFT_SHIFT       0x0
+#define PARAM_CRC_CTRL_RIGHT_SHIFT      0x4
+#define PARAM_CRC_CTRL_INV_RESULT       0x8
+
+	u8	rsvd1;				/* reserved for alignment */
+	u16	rsvd2;				/* reserved for alignment */
+	u32	init_val;			/* Initial value to use in the CRC calcualtion */
+	u32	crc_tbl[PARAM_CRC_TABLE_SIZE];	/* CRC table */
+};
+
+/* Commands to PA */
+struct pa_frm_command {
+
+	u32	command_result; /* Returned to the host, ignored on entry to the PASS */
+	u8	command;	/* Command value */
+	u8	magic;		/* Magic value */
+	u16	com_id;		/* Used by the host to identify command results */
+	u32	ret_context;	/* Returned in swInfo to identify packet as a command */
+	u16	reply_queue;	/* Specifies the queue number for the message reply. 0xffff to toss the reply */
+	u8	reply_dest;	/* Reply destination (host0, host1, discard are the only valid values) */
+	u8	flow_id;	/* Flow ID used to assign packet at reply */
+	u32	cmd;		/* First word of the command */
+};
+
+struct pa_cmd_next_route {
+	u16	ctrl_bit_field;		/* Routing control information as defined at @ref routeCtrlInfo */	
+	int	dest;			/* Packet destination as defined at @ref pktDest */
+	u8	pkt_type_emac_ctrl;	/*  For destination SRIO, specify the 5-bit packet type toward SRIO 
+                                     For destination EMAC, specify the EMAC control @ref emcOutputCtrlBits to the network */
+	u8	flow_id;	/* For host, SA or SRIO destinations, specifies return free descriptor setup */
+	u16	queue;		/*For host, SA or SRIO destinations, specifies the dest queue */
+	u32	sw_info_0;	/* Placed in SwInfo0 for packets to host or SA */
+	u32	sw_info_1;         /* Placed in SwInfo1 for packets to the SA */
+	u16	multi_route_index; /* Multi-route index. It is valid in the from-network direction only */
+};
+
+struct pa_cmd_crcOp {
+	u16	ctrl_bit_field;    /* CRC operation control information as defined at @ref crcOpCtrlInfo */
+	u16	start_offset;     /* Byte location, from SOP/Protocol Header, where the CRC computation begins 
+                                    if frame type is not specified
+                                    Byte location, from SOP/Protocol header, where the specific frame header begins
+                                    if frame type is specified
+                                    In to-network direction: offset from SOP
+                                    In from-network direction: offset from the current parsed header 
+                                    */
+	u16	len;             /* Number of bytes covered by the CRC computation 
+                                    valid only if pa_CRC_OP_PAYLOAD_LENGTH_IN_HEADER is clear */
+	u16	len_offset;       /* Payload length field offset in the custom header */
+	u16	len_mask;         /* Payload length field mask */
+	u16	len_adjust;       /* Payload length adjustment: valid only if PA_CRC_OP_PAYLOAD_LENGTH_IN_HEADER is set */
+	u16	crc_offset;       /* Offset from SOP/Protocol Header to the CRC field 
+                                    In to-network direction: offset from SOP
+                                    In from-network direction: offset from the current parsed header */
+	u16	frame_yype;       /* Frame type @ref crcFrameTypes, vaild if
+			    PA_CRC_OP_CRC_FRAME_TYPE is set */
+};
+
+/**
+ *  @ingroup palld_api_structures
+ *  @brief  Transmit checksum configuration
+ *
+ *  @details  paTxChksum_t is used in the call to @ref Pa_formatTxRoute or @ref Pa_formatTxCmd to create a tx 
+ *            command header that instructs the packet accelerator sub-system to generate ones' complement
+ *             checksums into network packets. The checksums are typically used for TCP and UDP payload checksums as
+ *            well as IPv4 header checksums. In the case of TCP and UDP payload checksums the psuedo header
+ *            checksum must be pre-calculated and provided, the sub-system does not calculate it.
+ */
+struct pa_tx_chksum {
+	u16	start_offset;   /* Byte location, from SOP, where the checksum calculation begins */
+	u16	length_bytes;   /* Number of bytes covered by the checksum. Must be even */
+	u16	result_offset;  /* Byte offset, from startOffset, to place the resulting checksum */
+	u16	initial_sum;    /* Initial value of the checksum */
+	u16	negative_0;     /* If TRUE, a computed value of 0 is written as -0 */
+};
+
+struct pa_cmd_copy {
+	u16	ctrl_bitfield;    /* Copy operation control information as defined at @ref copyCtrlInfo */
+	u16	src_offset;       /* Offset from the start of current protocol header for the data copy to begin */
+	u16	dest_offset;      /* Offset from the top of the PSInfo for the data to be copied to */
+	u16	num_bytes;        /* Number of bytes to be copied */   
+};
+
+struct pa_patch_info{
+	unsigned int	n_patch_bytes;              /**<  The number of bytes to be patched */
+	unsigned int	total_patch_size;           /**<  The number of patch bytes in the patch command, must be >= to nPatchBytes and a multiple of 4 bytes */
+	unsigned int	offset;                   /**<  Offset from the start of the packet for the patch to begin in the to-network direction 
+                                                 Offset from the start of the current header for the patch to begin in the from-network direction */
+	u16		overwrite;                /**<  If TRUE the patch data replaces existing packet data. If false the data is added */
+	u8		*patch_data;                /**<  Pointer to the patch data */
+};
+
+
+/**
+ *  @ingroup palld_api_structures
+ *  @brief  paPayloadInfo_t defines the packet payload information in the short format.
+ *          It is required by the Security Accelerator sub-system (SASS)
+ *
+ *  @details paPayloadInfo_t defines the packet parsing information in terms of
+ *           payload offset and payload length as described below
+ *  @li      SRTP:      offset to the RTP header; RTP payload length including ICV
+ *  @li      IPSEC AH:  offset to the Outer IP; IP payload length
+ *  @li      IPSEC ESP: offset to the ESP header; ESP papload length including ICV
+ */
+
+struct pa_payload_info  {
+	u16	offset;	/* The offset to where the SA packet parsing starts */
+	u16	len;	/* The total length of the protocal payload to be processed by SA */
+};
+
+struct pa_cmd_multi_route {
+	u16	index;        /*  Multi-route set Index */
+};
+
+/**
+ *   @def  PA_MAX_CMD_SETS
+ *         The maximum number of command sets supported
+ */
+#define PA_MAX_CMD_SETS     8
+
+#define PA_OK					0
+#define PA_ERR_CONFIG				-10
+#define PA_INSUFFICIENT_CMD_BUFFER_SIZE		-11
+#define PA_INVALID_CMD_REPLY_DEST		-12
+
+/**
+ *  @ingroup palld_api_structures
+ *  @brief  Command Set Command
+ *
+ *  @details paCmdSet_t is used to specify the desired PA command set. The command set command 
+ *           instructs the PASS to execute a list of commands after a LUT1 or LUT2 match occurs. 
+ *           It is one of the command which can be embedded within the @ref paRouteInfo_t. 
+ */
+struct pa_cmd_set {
+	u16	index;        /*Command Set Index */
+};
+
+struct pa_cmd_tx_timestamp {
+	u16	dest_queue;	/* Host queue for the tx timestamp reporting packet */
+	u16	flow_id;	/* CPPI flow */
+	u32	sw_info0;	/* 32 bit value returned in the descriptor */
+};
+
+struct pa_cmd_ip_frag {
+	u16	ip_offset;	/* Offset to the IP header. */
+	u16	mtu_size;	/* Size of the maximum transmission unit (>= 68) */
+};
+
+struct pa_cmd_usr_stats {
+	u16	index;		/* User-defined statistics index */
+};
+
+struct pa_cmd_set_usr_stats {
+	u16	set_index;	/* Commad Set Index */
+	u16	stats_index;    /* User-defined statistics index */
+};
+
+struct pa_cmd_info {
+	u16	cmd;			/*Specify the PA command code as defined at @ref paCmdCode */
+	union {
+		struct pa_cmd_next_route route;	/* Specify nextRoute command specific parameters */
+		struct pa_tx_chksum	chksum;	/* Specify Tx Checksum command specific parameters */
+		struct pa_cmd_crcOp     crcOp;    /* Specify CRC operation command specific parameters */
+		struct pa_cmd_copy	copy;     /* Specify Copy command specific parameters */
+		struct pa_patch_info	patch;    /* Specify Patch command specific parameters */
+		struct pa_payload_info	payload;  /* Specify the payload information required by SA */
+		struct pa_cmd_set	cmd_set;   /* Specify Command Set command specific parameters */
+		struct pa_cmd_multi_route m_route;   /* Specify Multi-route command specific parameters */
+		struct pa_cmd_tx_timestamp tx_ts;     /*Specify Report Tx Timestamp command specific parameters */
+		struct pa_cmd_ip_frag	ip_frag;   /* Specify IP fragmentation command specific parameters */
+		struct pa_cmd_usr_stats usr_stats; /* Specify User-defined Statistics command specific parameters */
+		struct pa_cmd_set_usr_stats cmd_set_usr_stats;  
+	} params;
+};
+
+struct pa_route_info {
+	int	dest;
+	u8	flow_id;
+	u16	queue;
+	int	m_route_index;
+	u32	sw_info_0;
+	u32	sw_info_1;
+	int	custom_type;
+	u8	custom_index;                                    
+	u8	pkt_type_emac_ctrl;
+	struct pa_cmd_info *pcmd;
+};
+
+struct pa_cmd_reply {
+	int	dest;		/* Packet destination, must be pa_DEST_HOST or PA_DEST_DISCARD, see @ref pktDest */
+	u32	reply_id;	/*  Value placed in swinfo0 in reply packet */
+	u16	queue;		/*  Destination queue for destination PA_DEST_HOST */
+	u8	flow_id;	/*  Flow ID used on command reply from PASS */
+};
+
+#endif /* __KERNEL__ */
+
+#endif /* KEYSTONE_PA_H */
+
diff --git a/drivers/net/ethernet/ti/keystone_pasahost.h b/drivers/net/ethernet/ti/keystone_pasahost.h
new file mode 100644
index 0000000..33e21f8
--- /dev/null
+++ b/drivers/net/ethernet/ti/keystone_pasahost.h
@@ -0,0 +1,390 @@
+/*
+ * Copyright (C) 2012 Texas Instruments Incorporated
+ * Author: Sandeep Paulraj <s-paulraj@ti.com> 
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef KEYSTONE_PASAHOST_H
+#define KEYSTONE_PASAHOST_H
+
+#ifdef __KERNEL__
+
+#define	PASAHO_CONFIGURE		4
+#define PASAHO_PARX_PARSECMD		0
+#define PASAHO_PARX_MULTI_ROUTE		5
+#define PASAHO_PAMOD_CMPT_CHKSUM	0
+#define PASAHO_PAMOD_CMPT_CRC		1
+#define PASAHO_PAMOD_PATCH		2
+#define PASAHO_PAMOD_NROUTE		3
+#define PASAHO_PAMOD_MULTI_ROUTE	5
+#define PASAHO_PAMOD_REPORT_TIMESTAMP	6   
+#define PASAHO_PAMOD_GROUP_7		7   
+#define PASAHO_PAMOD_DUMMY		PASAHO_PAMOD_GROUP_7
+#define PASAHO_PAMOD_IP_FRAGMENT	PASAHO_PAMOD_GROUP_7
+#define PASAHO_SA_LONG_INFO		0
+#define PASAHO_SA_SHORT_INFO		1
+#define PASAHO_SA_AIR_INFO		2
+
+#define PASAHO_READ_BITFIELD(a,b,c)	(((a)>>(b)) & ((1UL<<(c))-1))
+
+#define PASAHO_SET_BITFIELD(a,x,b,c)	(a) &= ~(((1UL<<(c))-1)<<(b)), \
+					(a) |= (((x) & ((1UL<<(c))-1))<<(b))
+
+#define PASAHO_SET_CMDID(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 29,3)
+
+#define PASAHO_PACFG_CMD	(((u32)PASAHO_CONFIGURE << 5) << 24)
+
+enum pasaho_header_type {
+	PASAHO_HDR_MAC        = 0,        /* MAC */
+	PASAHO_HDR_VLAN,                  /* VLAN */
+	PASAHO_HDR_MPLS,                  /* MPLS */
+	PASAHO_HDR_IPv4,                  /* IPv4 */
+	PASAHO_HDR_IPv6,                  /* IPv6 */
+	PASAHO_HDR_IPv6_EXT_HOP,          /* IPv6 hop by hop extenstion header */
+	PASAHO_HDR_IPv6_EXT_ROUTE,        /* IPv6 routing extenstion header */
+	PASAHO_HDR_IPv6_EXT_FRAG,         /* IPv6 fragmentation extention header */
+	PASAHO_HDR_IPv6_EXT_DEST,         /* IPv6 destination options header */
+	PASAHO_HDR_GRE,                   /* Generic Routing Encapsulation header */
+	PASAHO_HDR_ESP,                   /* Encapsulating Security Payload header */
+	PASAHO_HDR_ESP_DECODED,           /* Decoded Encapsulating Security Payload header */
+	PASAHO_HDR_AUTH,                  /* Authentication header */
+	PASAHO_HDR_CUSTOM_C1,             /* Custom classify 1 header */
+	PASAHO_HDR_FORCE_LOOKUP,          /* A contrived header type used with custom SRIO to force
+                                        a parse after looking at only the SRIO L0-L2 */
+	PASAHO_HDR_UNKNOWN,               /* Next header type is unknown */
+	PASAHO_HDR_UDP,                   /* User Datagram Protocol header */
+	PASAHO_HDR_UDP_LITE,              /* Lightweight User Datagram Protocol header */
+	PASAHO_HDR_TCP,                   /* Transmission Control Protocol header */
+	PASAHO_HDR_CUSTOM_C2              /* Custom classify 2 header */
+};
+
+/**
+ *  @defgroup pasahoSubCmdCode PASS Sub-Command Code
+ *  @ingroup pasaho_if_constants
+ *  @{
+ *
+ *  @name PASS Sub-Command Code
+ *  Definition of the 5-bit sub-command codes which is used to specify the group 7 commands. 
+ */ 
+
+enum pasaho_sub_cmd_code {
+	PASAHO_SUB_CMD_DUMMY	= 0,	/* Dummy */
+	PASAHO_SUB_CMD_IP_FRAG		/* IPv4 fragmentation */
+};
+
+/**
+ *  @ingroup pasaho_if_structures
+ *  @brief  pasahoCmdInfo_t defines the general short command information
+ *
+ */
+struct pasaho_cmd_info {
+	u32	word0;		/* Control block word 0 */
+};
+
+/**
+ *  @ingroup pasaho_if_structures
+ *  @brief  pasahoLongInfo_t defines the packet parsing information in the long format. 
+ *          The information is structured as an array of 32 bit values. These values
+ *          are broken down through macros. This allows the representation to be
+ *          endian independent to the hardware which operates only on 32 bit values.
+ *
+ *  @details  
+ */
+struct pasaho_long_info {
+	u32   word0;	/* Control block word 0 */
+	u32   word1;	/* Control block word 1 */
+	u32   word2;	/* Control block word 2 */
+	u32   word3;	/* Control block word 3 */
+	u32   word4;	/* Control block word 4 */
+};
+
+/** 
+ *  @defgroup PASAHO_long_info_command_macros  PASAHO Long Info Command Macros
+ *  @ingroup pasaho_if_macros
+ *  @{
+ *  @name PASAHO Long Info Command Macros
+ *  Macros used by the PASAHO Long Info Command
+ */
+
+/* Extract the command ID defined at */
+#define PASAHO_LINFO_READ_CMDID(x)		PASAHO_READ_BITFIELD((x)->word0,29,3)
+
+/* Extract the block length */
+#define PASAHO_LINFO_READ_RECLEN(x)		PASAHO_READ_BITFIELD((x)->word0,24,5)
+
+/* Extract the next parse start offset */
+#define PASAHO_LINFO_READ_START_OFFSET(x)	PASAHO_READ_BITFIELD((x)->word0,0,16)
+
+/* Extract the end of packet parse offset */
+#define PASAHO_LINFO_READ_END_OFFSET(x)		PASAHO_READ_BITFIELD((x)->word1,16,16)
+
+/* Extract the error index */
+#define PASAHO_LINFO_READ_EIDX(x)		PASAHO_READ_BITFIELD((x)->word1,11,5)
+
+/* Extract the previous match flag */
+#define PASAHO_LINFO_READ_PMATCH(x)		PASAHO_READ_BITFIELD((x)->word1,10,1)
+
+/* Extract the custom classify flag */
+#define PASAHO_LINFO_READ_C2C(x)		PASAHO_READ_BITFIELD((x)->word1,9,1)
+
+/* Extract the first parse module ID */
+#define PASAHO_LINFO_READ_L1_PDSP_ID(x)		PASAHO_READ_BITFIELD((x)->word1,6,3)
+
+/* Extract the first parse module match index */
+#define PASAHO_LINFO_READ_L1_IDX(x)		PASAHO_READ_BITFIELD((x)->word1,0,6)
+
+/* Extract the offset to the level 3 header */
+#define PASAHO_LINFO_READ_L3_OFFSET(x)		PASAHO_READ_BITFIELD((x)->word2,24,8)
+
+/* Extract the offset to the level 4 header */
+#define PASAHO_LINFO_READ_L4_OFFSET(x)		PASAHO_READ_BITFIELD((x)->word2,16,8)
+
+/* Extract the offset to the level 5 header */
+#define PASAHO_LINFO_READ_L5_OFFSET(x)		PASAHO_READ_BITFIELD((x)->word2,8,8)
+
+/* Extract the offset to the security header */
+#define PASAHO_LINFO_READ_ESP_AH_OFFSET(x)	PASAHO_READ_BITFIELD((x)->word2,0,8)
+
+/* Extract the bitmask of parsed header types */
+#define PASAHO_LINFO_READ_HDR_BITMASK(x)	PASAHO_READ_BITFIELD((x)->word3,21,11)
+
+/* Extract the next header to parse type */
+#define PASAHO_LINFO_READ_NXT_HDR_TYPE(x)	PASAHO_READ_BITFIELD((x)->word3,16,5)
+
+/* Extract the number of VLAN tags found */
+#define PASAHO_LINFO_READ_VLAN_COUNT(x)		PASAHO_READ_BITFIELD((x)->word3,12,4)
+
+/* Extract the number of IP headers found */
+#define PASAHO_LINFO_READ_IP_COUNT(x)		PASAHO_READ_BITFIELD((x)->word3,8,4)
+
+/* Extract the number of GRE headers found */
+#define PASAHO_LINFO_READ_GRE_COUNT(x)		PASAHO_READ_BITFIELD((x)->word3,4,4)
+
+/* Extract the fragmentation found flag */
+#define PASAHO_LINFO_READ_FLAG_FRAG(x)		PASAHO_READ_BITFIELD((x)->word3,3,1)
+
+/* Extract the incomplete IP route flag */
+#define PASAHO_LINFO_READ_FLAG_ROUTE(x)		PASAHO_READ_BITFIELD((x)->word3,2,1)
+
+/* Extract the (1-based) input EMAC port number */
+/*  0: Indicates that the packet does not enter PASS through CPSW */
+#define PASAHO_LINFO_READ_INPORT(x)		PASAHO_READ_BITFIELD((x)->word3,0,3)
+
+/* Extract the last pseudo-header checksum computed */
+#define PASAHO_LINFO_READ_PSEUDO_CHKSM(x)	PASAHO_READ_BITFIELD((x)->word4,16,16)
+
+#define PASAHO_LINFO_READ_TSTAMP_MSB(x)		PASAHO_READ_BITFIELD((x)->word4,0,16)
+
+/* Extract the IP Reassembly Traffic Flow Index */
+#define PASAHO_LINFO_READ_TFINDEX(x)		PASAHO_READ_BITFIELD((x)->word4,24,8)
+
+/* Extract the IP Reassembly Fragment count */
+#define PASAHO_LINFO_READ_FRANCNT(x)		PASAHO_READ_BITFIELD((x)->word4,16,8)
+
+/* Set the IP Reassembly Traffic Flow Index */
+#define PASAHO_LINFO_SET_TFINDEX(x, v)		PASAHO_SET_BITFIELD((x)->word4,(v),24,8)
+
+/* Set the IP Reassembly Fragment count */
+#define PASAHO_LINFO_SET_FRANCNT(x, v)		PASAHO_SET_BITFIELD((x)->word4,(v),16,8)
+
+/* Indicate whether it is an IPSEC packet */
+#define PASAHO_LINFO_IS_IPSEC(x)		PASAHO_READ_BITFIELD((x)->word3,25,2)
+
+/* Indicate whether it is an IPSEC ESP packet */
+#define PASAHO_LINFO_IS_IPSEC_ESP(x)		PASAHO_READ_BITFIELD((x)->word3,26,1)
+
+/* Indicate whether it is an IPSEC AH packet */
+#define PASAHO_LINFO_IS_IPSEC_AH(x)		PASAHO_READ_BITFIELD((x)->word3,25,1)
+
+/* Clear IPSEC indication bits */
+#define PASAHO_LINFO_CLR_IPSEC(x)		PASAHO_SET_BITFIELD((x)->word3,0,25,2)
+
+/* Clear IPSEC ESP indication bit */
+#define PASAHO_LINFO_CLR_IPSEC_ESP(x)		PASAHO_SET_BITFIELD((x)->word3,0,26,1)
+
+/* Clear IPSEC AH indication bit */
+#define PASAHO_LINFO_CLR_IPSEC_AH(x)		PASAHO_SET_BITFIELD((x)->word3,0,25,1)
+
+/* Clear the fragmentation found flag */
+#define PASAHO_LINFO_CLR_FLAG_FRAG(x)		PASAHO_SET_BITFIELD((x)->word3,0,3,1)
+
+/* Update the next parse start offset */
+#define PASAHO_LINFO_SET_START_OFFSET(x, v)	PASAHO_SET_BITFIELD((x)->word0,(v),0,16)
+
+/* Update the end of packet parse offset */
+#define PASAHO_LINFO_SET_END_OFFSET(x, v)	PASAHO_SET_BITFIELD((x)->word1,(v),16,16)
+
+
+/*
+ * Set the null packet flag which indicates that the packet should be dropped.
+ * This flag should be set for the null packet to be delivered to PASS when
+ * the reassembly timeout occurs
+ */
+#define PASAHO_LINFO_SET_NULL_PKT_IND(x, v)	PASAHO_SET_BITFIELD((x)->word0,(v),21,1)
+
+/*
+ * PA_INV_TF_INDEX
+ * PASS-asssited IP reassembly traffic flow index to indicate
+ * that no traffic flow is available
+ */
+#define PA_INV_TF_INDEX		0xFF
+
+struct pasaho_short_info {
+	u32	word0;
+	u32	word1;
+};
+
+/* Extract the command ID defined at */
+#define PASAHO_SINFO_READ_CMDID(x)		PASAHO_READ_BITFIELD((x)->word0,29,3)
+
+/* Extract the offset to the packet payload */
+#define PASAHO_SINFO_RESD_PAYLOAD_OFFSET(x)	PASAHO_READ_BITFIELD((x)->word0,16,8)
+
+/* Extract the byte length of the payload */
+#define PASAHO_SINFO_READ_PAYLOAD_LENGTH(x)	PASAHO_READ_BITFIELD((x)->word0,0,16)
+
+/* Set the offset to the payload */
+#define PASAHO_SINFO_SET_PAYLOAD_OFFSET(x, v)	PASAHO_SET_BITFIELD((x)->word0, (v), 16, 8)
+
+/* Set the payload length */
+#define PASAHO_SINFO_SET_PAYLOAD_LENGTH(x, v)	PASAHO_SET_BITFIELD((x)->word0, (v), 0,  16)
+
+/* Format the entire short info command */
+#define PASAHO_SINFO_FORMAT_CMD(offset, len)	(((offset) << 16) | (len) | (PASAHO_SA_SHORT_INFO << 29))
+
+#define PASAHO_HDR_BITMASK_MAC		(1 << 0)	/* MAC present */
+#define PASAHO_HDR_BITMASK_VLAN		(1 << 1)	/* VLAN present */
+#define PASAHO_HDR_BITMASK_MPLS		(1 << 2)	/* MPLS present */
+#define PASAHO_HDR_BITMASK_IP		(1 << 3)	/* IP present */
+#define PASAHO_HDR_BITMASK_ESP		(1 << 4)	/* IPSEC/ESP present */
+#define PASAHO_HDR_BITMASK_AH		(1 << 5)	/* IPSEC/AH present */
+#define PASAHO_HDR_BITMASK_UDP		(1 << 6)	/* UDP present */
+#define PASAHO_HDR_BITMASK_UDPLITE	(1 << 7)	/* UDPLITE present */
+#define PASAHO_HDR_BITMASK_TCP		(1 << 8)	/* TCP present */
+#define PASAHO_HDR_BITMASK_GRE		(1 << 9)	/* GRE present */
+#define PASAHO_HDR_BITMASK_CUSTOM	(1 << 10)	/* Custom header */
+
+struct pasaho_next_route {
+	u32  word0;          
+	u32  sw_info0;        
+	u32  sw_info1;        
+	u32  word1;          
+};
+
+/*
+ * Sets the N bit which indicates the next command
+ * should be executed prior to the route command
+ */
+#define PASAHO_SET_N(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 28, 1)
+
+/*
+ * Sets the E bit which indicates the extened
+ * parameters (packet type) are present for SRIO
+ */
+#define PASAHO_SET_E(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 27, 1)
+
+/*
+ * Sets the destination of the route defined */
+#define PASAHO_SET_DEST(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 24, 3)
+
+/* Specifies the flow to use for packets sent to the host */
+#define PASAHO_SET_FLOW(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 16, 8)
+
+/* Specifies the queue to use for packets send to the host */
+#define PASAHO_SET_QUEUE(x,v)   PASAHO_SET_BITFIELD((x)->word0, (v), 0,  16)
+
+/* Specifies the packet type to use for packets send to the SRIO */
+#define PASAHO_SET_PKTTYPE(x,v) PASAHO_SET_BITFIELD((x)->word1, (v), 24, 8)
+
+struct pasaho_com_chk_crc {
+	u32	word0;		/* PASAHO_chksum_command_macros */
+	u32	word1;		/* PASAHO_chksum_command_macros */
+	u32	word2;		/* PASAHO_chksum_command_macros */
+};
+
+/*
+ * Sets the negative 0 flag - if set a
+ * checksum computed as 0 will be sent as 0xffff
+ */
+#define PASAHO_CHKCRC_SET_NEG0(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 23, 1)
+
+/* Sets the optional flags of the CRC/Checksum command */
+#define PASAHO_CHKCRC_SET_CTRL(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 16, 8)
+
+/* Sets the start offset of the checksum/crc */
+#define PASAHO_CHKCRC_SET_START(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 0,  16)
+
+/* Sets the length of the checksum/crc */
+#define PASAHO_CHKCRC_SET_LEN(x,v)	PASAHO_SET_BITFIELD((x)->word1, (v), 16, 16)
+
+/* Sets the offset to where to paste the checksum/crc into the packet */
+#define PASAHO_CHKCRC_SET_RESULT_OFF(x,v)	PASAHO_SET_BITFIELD((x)->word1, (v), 0,  16)
+
+/* Sets the initial value of the checksum/crc */
+#define PASAHO_CHKCRC_SET_INITVAL(x,v)	PASAHO_SET_BITFIELD((x)->word2, (v), 16, 16)
+
+#define PASAHO_BPATCH_MAX_PATCH_WORDS	4
+
+struct pasaho_com_blind_patch {
+	u32	word0;
+	u32	patch[PASAHO_BPATCH_MAX_PATCH_WORDS];
+};
+
+
+#define PASAHO_BPATCH_SET_PATCH_NBYTES(x,v)	PASAHO_SET_BITFIELD((x)->word0, v, 24,  5)
+
+/* Sets the number of bytes to patch */
+#define PASAHO_BPATCH_SET_PATCH_CMDSIZE(x,v)	PASAHO_SET_BITFIELD((x)->word0, v, 20, 4)
+
+/* Sets the size of the command in 32 bit word units */                        
+#define PASAHO_BPATCH_SET_OVERWRITE(x,v)	PASAHO_SET_BITFIELD((x)->word0, v, 19, 1)
+
+/*
+ * Sets the overwrite flag. If set the patch will
+ * overwrite existing packet data, otherwise data is inserted
+ */                         
+#define PASAHO_BPATCH_SET_OFFSET(x,v)		PASAHO_SET_BITFIELD((x)->word0, v, 0,  16)
+
+/* Sets the offset to the start of the patch */
+#define PASAHO_BPATCH_SET_PATCH_BYTE(x, byteNum, byte)  (x)->patch[(byteNum) >> 2] = \
+		PASAHO_SET_BITFIELD((x)->patch[(byteNum) >> 2], byte, ((3 - (byteNum & 0x3)) << 3), 8)
+
+
+struct pasaho_report_timestamp {
+	u32	word0;
+	u32	sw_info0;
+};
+
+/* Specifies the flow to use for report packets sent to the host */
+
+#define PASAHO_SET_REPORT_FLOW(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 16, 8)
+
+/* Specifies the queue to use for report packets send to the host */
+#define PASAHO_SET_REPORT_QUEUE(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 0,  16)
+
+struct pasaho_ip_frag {
+	u32	word0;
+};
+
+/* Set sub-command code to indicate IP Fragmentation command */
+#define PASAHO_SET_SUB_CODE_IP_FRAG(x) PASAHO_SET_BITFIELD((x)->word0, PASAHO_SUB_CMD_IP_FRAG, 24, 5)
+
+/* Specifies the sub-command code */
+#define PASAHO_SET_SUB_CODE(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 24, 5)
+
+/* Specifies the offset to the IP header to be fragmented */
+#define PASAHO_SET_IP_OFFSET(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 16, 8)
+
+/* Specifies the MTU size */
+#define PASAHO_SET_MTU_SIZE(x,v)	PASAHO_SET_BITFIELD((x)->word0, (v), 0,  16)
+
+#endif /* __KERNEL__ */
+#endif /* KEYSTONE_PASAHOST_H */
diff --git a/drivers/net/ethernet/ti/keystone_qos.c b/drivers/net/ethernet/ti/keystone_qos.c
new file mode 100644
index 0000000..4cfcc4b
--- /dev/null
+++ b/drivers/net/ethernet/ti/keystone_qos.c
@@ -0,0 +1,300 @@
+/*
+ * Copyright (C) 2012 Texas Instruments Incorporated
+ * Authors: Reece Pollack <reece@theptrgroup.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/firmware.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/dmaengine.h>
+#include <linux/dma-mapping.h>
+#include <linux/scatterlist.h>
+#include <linux/byteorder/generic.h>
+#include <linux/platform_device.h>
+#include <linux/keystone-dma.h>
+#include <linux/errqueue.h>
+
+#include "keystone_net.h"
+
+#define	QOS_TXHOOK_ORDER	20
+
+#define	MAX_CHANNELS	8
+
+struct qos_channel {
+	const char		*tx_chan_name;
+	u32			 tx_queue_depth;
+	struct netcp_tx_pipe	 tx_pipe;
+};
+
+struct qos_device {
+	struct netcp_device		*netcp_device;
+	struct device			*dev;
+	struct device_node		*node;
+	u32				 multi_if;
+};
+
+struct qos_intf {
+	struct net_device		*ndev;
+	struct device			*dev;
+	int				 num_channels;
+	struct qos_channel		 channels[MAX_CHANNELS];
+};
+
+static int qos_tx_hook(int order, void *data, struct netcp_packet *p_info)
+{
+	struct qos_intf *qos_intf = data;
+	struct sk_buff *skb = p_info->skb;
+
+	dev_dbg(qos_intf->dev,
+		"priority: %u, queue_mapping: %04x\n",
+		skb->priority, skb_get_queue_mapping(skb));
+
+	if (skb->queue_mapping < qos_intf->num_channels)
+		p_info->tx_pipe =
+			&qos_intf->channels[skb->queue_mapping].tx_pipe;
+	else {
+		dev_warn(qos_intf->dev,
+			"queue mapping (%d) >= num chans (%d) QoS bypassed\n",
+			 skb_get_queue_mapping(skb), qos_intf->num_channels);
+	}
+
+	return 0;
+}
+
+
+static int qos_close(void *intf_priv, struct net_device *ndev)
+{
+	struct qos_intf *qos_intf = intf_priv;
+	struct netcp_priv *netcp_priv = netdev_priv(ndev);
+	int i;
+
+	netcp_unregister_txhook(netcp_priv, QOS_TXHOOK_ORDER, qos_tx_hook,
+				qos_intf);
+
+	for (i = 0; i < qos_intf->num_channels; ++i) {
+		struct qos_channel *qchan = &qos_intf->channels[i];
+
+		netcp_txpipe_close(&qchan->tx_pipe);
+	}
+
+	return 0;
+}
+
+static int qos_open(void *intf_priv, struct net_device *ndev)
+{
+	struct qos_intf *qos_intf = intf_priv;
+	struct netcp_priv *netcp_priv = netdev_priv(ndev);
+	int ret;
+	int i;
+
+	/* Open the QoS input queues */
+	for (i = 0; i < qos_intf->num_channels; ++i) {
+		struct qos_channel *qchan = &qos_intf->channels[i];
+
+		ret = netcp_txpipe_open(&qchan->tx_pipe);
+		if (ret)
+			goto fail;
+	}
+
+	netcp_register_txhook(netcp_priv, QOS_TXHOOK_ORDER, qos_tx_hook,
+			      intf_priv);
+
+	return 0;
+
+fail:
+	qos_close(intf_priv, ndev);
+	return ret;
+}
+
+static int init_channel(struct qos_intf *qos_intf,
+			int index,
+			struct device_node *node)
+{
+	struct qos_channel *qchan = &qos_intf->channels[index];
+	int ret;
+
+	ret = of_property_read_string(node, "tx-channel", &qchan->tx_chan_name);
+	if (ret < 0) {
+		dev_err(qos_intf->dev,
+			"missing tx-channel parameter, err %d\n", ret);
+		qchan->tx_chan_name = "qos";
+	}
+	dev_dbg(qos_intf->dev, "tx-channel \"%s\"\n", qchan->tx_chan_name);
+
+	ret = of_property_read_u32(node, "tx_queue_depth",
+				   &qchan->tx_queue_depth);
+	if (ret < 0) {
+		dev_err(qos_intf->dev,
+			"missing tx_queue_depth parameter, err %d\n", ret);
+		qchan->tx_queue_depth = 16;
+	}
+	dev_dbg(qos_intf->dev, "tx_queue_depth %u\n", qchan->tx_queue_depth);
+
+	return 0;
+}
+
+static int qos_attach(void *inst_priv, struct net_device *ndev,
+		      void **intf_priv)
+{
+	struct netcp_priv *netcp = netdev_priv(ndev);
+	struct qos_device *qos_dev = inst_priv;
+	struct qos_intf *qos_intf;
+	struct device_node *interface, *channel;
+	char node_name[24];
+	int i, ret;
+
+	qos_intf = devm_kzalloc(qos_dev->dev,
+				 sizeof(struct qos_intf), GFP_KERNEL);
+	if (!qos_intf) {
+		dev_err(qos_dev->dev,
+			"qos interface memory allocation failed\n");
+		return -ENOMEM;
+	}
+
+	qos_intf->ndev = ndev;
+	qos_intf->dev = qos_dev->dev;
+
+	snprintf(node_name, sizeof(node_name), "interface-%d",
+		 (qos_dev->multi_if) ? (netcp->cpsw_port - 1) : 0);
+
+	*intf_priv = qos_intf;
+
+	interface = of_get_child_by_name(qos_dev->node, node_name);
+	if (!interface) {
+		dev_err(qos_intf->dev,
+			"could not find interface %d node in device tree\n",
+			(netcp->cpsw_port - 1));
+		ret = -ENODEV;
+		goto exit;
+	}
+
+	qos_intf->num_channels = 0;
+	for_each_child_of_node(interface, channel) {
+		if (qos_intf->num_channels >= MAX_CHANNELS) {
+			dev_err(qos_intf->dev,
+				"too many QoS input channels defined\n");
+			break;
+		}
+		init_channel(qos_intf, qos_intf->num_channels, channel);
+		++qos_intf->num_channels;
+	}
+
+	of_node_put(interface);
+
+	/* Initialize the QoS input queues */
+	for (i = 0; i < qos_intf->num_channels; ++i) {
+		struct qos_channel *qchan = &qos_intf->channels[i];
+
+		netcp_txpipe_init(&qchan->tx_pipe, netdev_priv(ndev),
+				  qchan->tx_chan_name,
+				  qchan->tx_queue_depth);
+
+		qchan->tx_pipe.dma_psflags = netcp->cpsw_port;
+	}
+
+	return 0;
+exit:
+	devm_kfree(qos_dev->dev, qos_intf);
+	return ret;
+}
+
+static int qos_release(void *intf_priv)
+{
+	struct qos_intf *qos_intf = intf_priv;
+
+	kfree(qos_intf);
+
+	return 0;
+}
+
+static int qos_remove(struct netcp_device *netcp_device, void *inst_priv)
+{
+	struct qos_device *qos_dev = inst_priv;
+
+	kfree(qos_dev);
+
+	return 0;
+}
+
+static int qos_probe(struct netcp_device *netcp_device,
+		    struct device *dev,
+		    struct device_node *node,
+		    void **inst_priv)
+{
+	struct qos_device *qos_dev;
+	int ret = 0;
+	
+	qos_dev = devm_kzalloc(dev, sizeof(struct qos_device), GFP_KERNEL);
+	if (!qos_dev) {
+		dev_err(dev, "memory allocation failed\n");
+		return -ENOMEM;
+	}
+	*inst_priv = qos_dev;
+
+	if (!node) {
+		dev_err(dev, "device tree info unavailable\n");
+		ret = -ENODEV;
+		goto exit;
+	}
+
+	qos_dev->netcp_device = netcp_device;
+	qos_dev->dev = dev;
+	qos_dev->node = node;
+
+	if (of_find_property(node, "multi-interface", NULL))
+		qos_dev->multi_if = 1;
+
+	return 0;
+
+exit:
+	qos_remove(netcp_device, qos_dev);
+	*inst_priv = NULL;
+	return ret;
+}
+
+
+static struct netcp_module qos_module = {
+	.name		= "keystone-qos",
+	.owner		= THIS_MODULE,
+	.probe		= qos_probe,
+	.open		= qos_open,
+	.close		= qos_close,
+	.remove		= qos_remove,
+	.attach		= qos_attach,
+	.release	= qos_release,
+};
+
+static int __init keystone_qos_init(void)
+{
+	return netcp_register_module(&qos_module);
+}
+module_init(keystone_qos_init);
+
+static void __exit keystone_qos_exit(void)
+{
+	netcp_unregister_module(&qos_module);
+}
+module_exit(keystone_qos_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Reece Pollack <reece@theptrgroup.com");
+MODULE_DESCRIPTION("Quality of Service driver for Keystone devices");
diff --git a/drivers/net/ethernet/ti/keystone_sgmii.c b/drivers/net/ethernet/ti/keystone_sgmii.c
new file mode 100644
index 0000000..02030bc
--- /dev/null
+++ b/drivers/net/ethernet/ti/keystone_sgmii.c
@@ -0,0 +1,307 @@
+/*
+ * Copyright (C) 2012 Texas Instruments Incorporated
+ * Authors: Sandeep Paulraj <s-paulraj@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/io.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+
+#include "keystone_net.h"
+
+#define SGMII_REG_BASE                  0x02090100
+#define SGMII_SERDES_BASE		0x02620340
+#define SGMII_SERDES_CFGPLL		0x0
+#define SGMII_SERDES_CFGRX0		0x4
+#define SGMII_SERDES_CFGTX0		0x8
+#define SGMII_SERDES_CFGRX1		0xC
+#define SGMII_SERDES_CFGTX1		0x10
+#define SGMII_SERDES_SIZE		0x14
+
+#define SGMII_SRESET_RESET		0x1
+#define SGMII_SRESET_RTRESET		0x2
+#define SGMII_CTL_AUTONEG		0x01
+#define SGMII_CTL_LOOPBACK		0x10
+#define SGMII_CTL_MASTER		0x20
+#define SGMII_REG_STATUS_LOCK		BIT(4)
+#define	SGMII_REG_STATUS_LINK		BIT(0)
+#define SGMII_REG_STATUS_AUTONEG	BIT(2)
+#define SGMII_REG_CONTROL_AUTONEG	BIT(0)
+
+#define SGMII_OFFSET(x)	((x <= 1)? (x * 0x100): ((x * 0x100) + 0x100))
+/*
+ * SGMII registers
+ */
+#define SGMII_IDVER_REG(x)    (SGMII_OFFSET(x) + 0x000)
+#define SGMII_SRESET_REG(x)   (SGMII_OFFSET(x) + 0x004)
+#define SGMII_CTL_REG(x)      (SGMII_OFFSET(x) + 0x010)
+#define SGMII_STATUS_REG(x)   (SGMII_OFFSET(x) + 0x014)
+#define SGMII_MRADV_REG(x)    (SGMII_OFFSET(x) + 0x018)
+#define SGMII_LPADV_REG(x)    (SGMII_OFFSET(x) + 0x020)
+#define SGMII_TXCFG_REG(x)    (SGMII_OFFSET(x) + 0x030)
+#define SGMII_RXCFG_REG(x)    (SGMII_OFFSET(x) + 0x034)
+#define SGMII_AUXCFG_REG(x)   (SGMII_OFFSET(x) + 0x038)
+
+struct sgmii_config {
+	u32	interface;
+	u32	mr_adv_ability;
+	u32	control;
+};
+
+static inline void sgmii_write_reg(void __iomem *base, int reg, u32 val)
+{
+	__raw_writel(val, base + reg);
+}
+
+static inline u32 sgmii_read_reg(void __iomem *base, int reg)
+{
+	return __raw_readl(base + reg);
+}
+
+static inline void sgmii_write_reg_bit(void __iomem *base, int reg, u32 val)
+{
+	__raw_writel((__raw_readl(base + reg) | val),
+			base + reg);
+}
+
+int serdes_init(void)
+{
+	void __iomem *sgmii_serdes;
+
+	sgmii_serdes = ioremap(SGMII_SERDES_BASE, SGMII_SERDES_SIZE);
+
+	sgmii_write_reg(sgmii_serdes, SGMII_SERDES_CFGPLL, 0x00000041);
+	
+	udelay(2000);
+
+	sgmii_write_reg(sgmii_serdes, SGMII_SERDES_CFGRX0, 0x00700621);
+	sgmii_write_reg(sgmii_serdes, SGMII_SERDES_CFGRX1, 0x00700621);
+
+	sgmii_write_reg(sgmii_serdes, SGMII_SERDES_CFGTX0, 0x000108a1);
+	sgmii_write_reg(sgmii_serdes, SGMII_SERDES_CFGTX1, 0x000108a1);
+
+	udelay(2000);
+
+	iounmap(sgmii_serdes);
+
+	return 0;
+}	
+
+int keystone_sgmii_reset(void __iomem *sgmii_ofs, int port)
+{
+	/* Soft reset */
+	sgmii_write_reg_bit(sgmii_ofs, SGMII_SRESET_REG(port), 0x1);
+	while(sgmii_read_reg(sgmii_ofs, SGMII_SRESET_REG(port)) != 0x0);
+
+	return 0;
+}
+
+int keystone_sgmii_link_status(void __iomem *sgmii_ofs, int ports)
+{
+	u32 status = 0, link = 0;
+	u32 i;
+
+	for (i = 0; i < ports; i++) {
+		status = sgmii_read_reg(sgmii_ofs, SGMII_STATUS_REG(i));
+		if ((status & SGMII_REG_STATUS_LINK) != 0)
+			link |= BIT(i);
+		else
+			link &= ~BIT(i);
+	}
+
+	return link;
+}
+
+int keystone_sgmii_get_port_link(void __iomem *sgmii_ofs, int port)
+{
+	u32 status = 0, link = 0;
+
+	status = sgmii_read_reg(sgmii_ofs, SGMII_STATUS_REG(port));
+	if ((status & SGMII_REG_STATUS_LINK) != 0)
+		link |= BIT(port);
+	else
+		link &= ~BIT(port);
+
+	return link;
+}
+
+
+int keystone_sgmii_config(void __iomem *sgmii_ofs,
+			  int port, u32 interface)
+{
+	unsigned int i, status, mask;
+	struct sgmii_config *config;
+
+	config = kzalloc(sizeof(*config), GFP_KERNEL);
+	if (!config)
+		return -ENOMEM;
+
+	switch (interface) {
+	case SGMII_LINK_MAC_MAC_AUTONEG:
+		config->mr_adv_ability	= 0x9801;
+		config->control		= 0x21;
+
+		break;
+	case SGMII_LINK_MAC_PHY:
+	case SGMII_LINK_MAC_PHY_NO_MDIO:
+		config->mr_adv_ability	= 1;
+		config->control		= 1;
+
+		break;
+	case SGMII_LINK_MAC_MAC_FORCED:
+		config->mr_adv_ability	= 0x9801;
+		config->control		= 0x20;
+
+		break;
+	case SGMII_LINK_MAC_FIBER:
+		config->mr_adv_ability	= 0x20;
+		config->control		= 0x1;
+
+		break;
+	}
+
+	sgmii_write_reg(sgmii_ofs, SGMII_CTL_REG(port), 0);
+
+	/*
+	 * Wait for the SerDes pll to lock,
+	 * but don't trap if lock is never read
+	 */
+	for (i = 0; i < 1000; i++)  {
+		udelay(2000);
+		status = sgmii_read_reg(sgmii_ofs, SGMII_STATUS_REG(port));
+		if ((status & SGMII_REG_STATUS_LOCK) != 0)
+			break;
+	}
+
+	sgmii_write_reg(sgmii_ofs,
+			SGMII_MRADV_REG(port), config->mr_adv_ability);
+	sgmii_write_reg(sgmii_ofs,
+			SGMII_CTL_REG(port), config->control);
+
+
+	mask = SGMII_REG_STATUS_LINK;
+
+	if (config->control & SGMII_REG_CONTROL_AUTONEG)
+		mask |= SGMII_REG_STATUS_AUTONEG;
+
+	for (i = 0; i < 1000; i++)  {
+		status = sgmii_read_reg(sgmii_ofs, SGMII_STATUS_REG(port));
+		if ((status & mask) == mask)
+			break;
+	}
+
+	kfree(config);
+	return 0;
+}
+
+#define reg_rmw(addr, value, mask) \
+	__raw_writel(((__raw_readl(addr) & (~(mask))) | (value) ), (addr) )
+
+void serdes_init_6638_156p25Mhz()
+{
+	void __iomem *regs;
+	unsigned int cnt;
+
+	regs = ioremap(0x0232a000, 0x2000);
+
+	reg_rmw(regs + 0x000, 0x00800000, 0xffff0000);
+	reg_rmw(regs + 0x014, 0x00008282, 0x0000ffff);
+	reg_rmw(regs + 0x060, 0x00142438, 0x00ffffff);
+	reg_rmw(regs + 0x064, 0x00c3c700, 0x00ffff00);
+	reg_rmw(regs + 0x078, 0x0000c000, 0x0000ff00);
+	reg_rmw(regs + 0x204, 0x38000080, 0xff0000ff);
+	reg_rmw(regs + 0x208, 0x00000000, 0x000000ff);
+	reg_rmw(regs + 0x20c, 0x02000000, 0xff000000);
+	reg_rmw(regs + 0x210, 0x1b000000, 0xff000000);
+	reg_rmw(regs + 0x214, 0x00006fb8, 0x0000ffff);
+	reg_rmw(regs + 0x218, 0x758000e4, 0xffff00ff);
+	reg_rmw(regs + 0x2ac, 0x00004400, 0x0000ff00);
+	reg_rmw(regs + 0x22c, 0x00100800, 0x00ffff00);
+	reg_rmw(regs + 0x280, 0x00820082, 0x00ff00ff);
+	reg_rmw(regs + 0x284, 0x1D0F0385, 0xFFFFFFFF);
+	reg_rmw(regs + 0x404, 0x38000080, 0xff0000ff);
+	reg_rmw(regs + 0x408, 0x00000000, 0x000000ff);
+	reg_rmw(regs + 0x40c, 0x02000000, 0xff000000);
+	reg_rmw(regs + 0x410, 0x1b000000, 0xff000000);
+	reg_rmw(regs + 0x414, 0x00006FB8, 0x0000FFFF);
+	reg_rmw(regs + 0x418, 0x758000E4, 0xFFFF00FF);
+	reg_rmw(regs + 0x4AC, 0x00004400, 0x0000FF00);
+	reg_rmw(regs + 0x42C, 0x00100800, 0x00FFFF00);
+	reg_rmw(regs + 0x480, 0x00820082, 0x00FF00FF);
+	reg_rmw(regs + 0x484, 0x1D0F0385, 0xFFFFFFFF);
+	reg_rmw(regs + 0x604, 0x38000080, 0xFF0000FF);
+	reg_rmw(regs + 0x608, 0x00000000, 0x000000FF);
+	reg_rmw(regs + 0x60C, 0x02000000, 0xFF000000);
+	reg_rmw(regs + 0x610, 0x1B000000, 0xFF000000);
+	reg_rmw(regs + 0x614, 0x00006FB8, 0x0000FFFF);
+	reg_rmw(regs + 0x618, 0x758000E4, 0xFFFF00FF);
+	reg_rmw(regs + 0x6AC, 0x00004400, 0x0000FF00);
+	reg_rmw(regs + 0x62C, 0x00100800, 0x00FFFF00);
+	reg_rmw(regs + 0x680, 0x00820082, 0x00FF00FF);
+	reg_rmw(regs + 0x684, 0x1D0F0385, 0xFFFFFFFF);
+	reg_rmw(regs + 0x804, 0x38000080, 0xFF0000FF);
+	reg_rmw(regs + 0x808, 0x00000000, 0x000000FF);
+	reg_rmw(regs + 0x80C, 0x02000000, 0xFF000000);
+	reg_rmw(regs + 0x810, 0x1B000000, 0xFF000000);
+	reg_rmw(regs + 0x814, 0x00006FB8, 0x0000FFFF);
+	reg_rmw(regs + 0x818, 0x758000E4, 0xFFFF00FF);
+	reg_rmw(regs + 0x8AC, 0x00004400, 0x0000FF00);
+	reg_rmw(regs + 0x82C, 0x00100800, 0x00FFFF00);
+	reg_rmw(regs + 0x880, 0x00820082, 0x00FF00FF);
+	reg_rmw(regs + 0x884, 0x1D0F0385, 0xFFFFFFFF);
+	reg_rmw(regs + 0xa00, 0x00000800, 0x0000FF00);
+	reg_rmw(regs + 0xa08, 0x38A20000, 0xFFFF0000);
+	reg_rmw(regs + 0xa30, 0x008A8A00, 0x00FFFF00);
+	reg_rmw(regs + 0xa84, 0x00000600, 0x0000FF00);
+	reg_rmw(regs + 0xa94, 0x10000000, 0xFF000000);
+	reg_rmw(regs + 0xaa0, 0x81000000, 0xFF000000);
+	reg_rmw(regs + 0xabc, 0xFF000000, 0xFF000000);
+	reg_rmw(regs + 0xac0, 0x0000008B, 0x000000FF);
+	reg_rmw(regs + 0xb08, 0x583F0000, 0xFFFF0000);
+	reg_rmw(regs + 0xb0c, 0x0000004e, 0x000000FF);
+	reg_rmw(regs + 0x000, 0x00000003, 0x000000FF);
+	reg_rmw(regs + 0xa00, 0x0000005F, 0x000000FF);
+
+	/* Enable TX and RX via the LANExCTL_STS 0x0000 + x*4 */
+	__raw_writel(0xF800F8C0, regs + 0x1fe0);
+	__raw_writel(0xF800F8C0, regs + 0x1fe4);
+	__raw_writel(0xF800F8C0, regs + 0x1fe8);
+	__raw_writel(0xF800F8C0, regs + 0x1fec);
+
+	/*Enable pll via the pll_ctrl 0x0014*/
+	__raw_writel(0xe0000000, regs + 0x1ff4);
+
+	iounmap(regs);
+	regs = ioremap(0x02090000, 0x1000);
+
+	/*Waiting for SGMII Serdes PLL lock.*/
+	for (cnt = 10000;
+	     cnt > 0 && ((__raw_readl(regs + 0x114) & 0x10) == 0);
+	     cnt--);
+
+	for (cnt = 10000;
+	     cnt > 0 && ((__raw_readl(regs + 0x214) & 0x10) == 0);
+	     cnt--);
+
+	for (cnt = 10000;
+	     cnt > 0 && ((__raw_readl(regs + 0x414) & 0x10) == 0);
+	     cnt--);
+
+	for (cnt = 10000;
+	     cnt > 0 && ((__raw_readl(regs + 0x514) & 0x10) == 0);
+	     cnt--);
+
+	iounmap(regs);
+	udelay(200);
+}
diff --git a/drivers/net/ethernet/ti/keystone_xgemdio.c b/drivers/net/ethernet/ti/keystone_xgemdio.c
new file mode 100644
index 0000000..6ef634e
--- /dev/null
+++ b/drivers/net/ethernet/ti/keystone_xgemdio.c
@@ -0,0 +1,525 @@
+/*
+ * Keystone MDIO Module driver
+ *
+ * Copyright (C) 2013 Texas Instruments.
+ *
+ * Shamelessly cloned from davinci_mdio.c, original copyrights follow:
+ *
+ * Copyright (C) 2009 Texas Instruments.
+ *
+ * ---------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ---------------------------------------------------------------------------
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/phy.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/pm_runtime.h>
+#include <linux/davinci_emac.h>
+#include <linux/of.h>
+#include <linux/of_mdio.h>
+#include <linux/of_device.h>
+#include "keystone_net.h"
+
+/*
+ * This timeout definition is a worst-case ultra defensive measure against
+ * unexpected controller lock ups.  Ideally, we should never ever hit this
+ * scenario in practice.
+ */
+#define MDIO_TIMEOUT		100 /* msecs */
+
+#define PHY_REG_MASK		0x1f
+#define PHY_ID_MASK		0x1f
+
+#define DEF_OUT_FREQ		2200000		/* 2.2 MHz */
+
+struct keystone_mdiox_regs {
+	u32	version;
+	u32	control;
+#define CONTROL_IDLE		BIT(31)
+#define CONTROL_ENABLE		BIT(30)
+#define CONTROL_MAX_DIV		(0xffff)
+
+	u32	alive;
+	u32	link;
+	u32	linkintraw;
+	u32	linkintmasked;
+	u32	__reserved_0[2];
+	u32	userintraw;
+	u32	userintmasked;
+	u32	userintmaskset;
+	u32	userintmaskclr;
+	u32	__reserved_1[20];
+
+	struct {
+		u32	access;
+#define USERACCESS_GO		BIT(31)
+#define USERACCESS_WRITE	BIT(30)
+#define USERACCESS_ACK		BIT(29)
+#define USERACCESS_READ		(0)
+#define USERACCESS_DATA		(0xffff)
+
+		u32	physel;
+	}	user[0];
+};
+
+struct mdio_platform_data k_default_pdata = {
+	.bus_freq = DEF_OUT_FREQ,
+};
+
+struct keystone_mdiox_data {
+	struct mdio_platform_data pdata;
+	struct keystone_mdiox_regs __iomem *regs;
+	spinlock_t	lock;
+	struct clk	*clk;
+	struct device	*dev;
+	struct mii_bus	*bus;
+	bool		suspended;
+	unsigned long	access_time; /* jiffies */
+};
+
+static void __keystone_mdiox_reset(struct keystone_mdiox_data *data)
+{
+	u32 mdio_in, div, mdio_out_khz, access_time;
+
+	mdio_in = clk_get_rate(data->clk);
+	div = (mdio_in / data->pdata.bus_freq) - 1;
+	if (div > CONTROL_MAX_DIV)
+		div = CONTROL_MAX_DIV;
+
+	/* set enable and clock divider */
+	__raw_writel(div | CONTROL_ENABLE, &data->regs->control);
+
+	/*
+	 * One mdio transaction consists of:
+	 *	32 bits of preamble
+	 *	32 bits of transferred data
+	 *	24 bits of bus yield (not needed unless shared?)
+	 */
+	mdio_out_khz = mdio_in / (1000 * (div + 1));
+	access_time  = (88 * 1000) / mdio_out_khz;
+
+	/*
+	 * In the worst case, we could be kicking off a user-access immediately
+	 * after the mdio bus scan state-machine triggered its own read.  If
+	 * so, our request could get deferred by one access cycle.  We
+	 * defensively allow for 4 access cycles.
+	 */
+	data->access_time = usecs_to_jiffies(access_time * 4);
+	if (!data->access_time)
+		data->access_time = 1;
+}
+
+static int keystone_mdiox_reset(struct mii_bus *bus)
+{
+	struct keystone_mdiox_data *data = bus->priv;
+	u32 phy_mask, ver;
+
+	__keystone_mdiox_reset(data);
+
+	/* wait for scan logic to settle */
+	msleep(PHY_MAX_ADDR * data->access_time);
+
+	/* dump hardware version info */
+	ver = __raw_readl(&data->regs->version);
+	dev_info(data->dev, "keystone mdio revision %d.%d\n",
+		 (ver >> 8) & 0xff, ver & 0xff);
+
+	/* OF explicitly registers phy devices without a bus scan */
+	if (data->dev->of_node)
+		return 0;
+
+	/* get phy mask from the alive register */
+	phy_mask = __raw_readl(&data->regs->alive);
+	if (phy_mask) {
+		/* restrict mdio bus to live phys only */
+		dev_info(data->dev, "detected phy mask %x\n", ~phy_mask);
+		phy_mask = ~phy_mask;
+	} else {
+		/* desperately scan all phys */
+		dev_warn(data->dev, "no live phy, scanning all\n");
+		phy_mask = 0;
+	}
+	data->bus->phy_mask = phy_mask;
+
+	return 0;
+}
+
+/* wait until hardware is ready for another user access */
+static inline int wait_for_user_access(struct keystone_mdiox_data *data)
+{
+	struct keystone_mdiox_regs __iomem *regs = data->regs;
+	unsigned long timeout = jiffies + msecs_to_jiffies(MDIO_TIMEOUT);
+	u32 reg;
+
+	while (time_after(timeout, jiffies)) {
+		reg = __raw_readl(&regs->user[0].access);
+		if ((reg & USERACCESS_GO) == 0)
+			return 0;
+
+		reg = __raw_readl(&regs->control);
+		if ((reg & CONTROL_IDLE) == 0)
+			continue;
+
+		/*
+		 * An emac soft_reset may have clobbered the mdio controller's
+		 * state machine.  We need to reset and retry the current
+		 * operation
+		 */
+		dev_warn(data->dev, "resetting idled controller\n");
+		__keystone_mdiox_reset(data);
+		return -EAGAIN;
+	}
+
+	reg = __raw_readl(&regs->user[0].access);
+	if ((reg & USERACCESS_GO) == 0)
+		return 0;
+
+	dev_err(data->dev, "timed out waiting for user access\n");
+	return -ETIMEDOUT;
+}
+
+/* wait until hardware state machine is idle */
+static inline int wait_for_idle(struct keystone_mdiox_data *data)
+{
+	struct keystone_mdiox_regs __iomem *regs = data->regs;
+	unsigned long timeout = jiffies + msecs_to_jiffies(MDIO_TIMEOUT);
+
+	while (time_after(timeout, jiffies)) {
+		if (__raw_readl(&regs->control) & CONTROL_IDLE)
+			return 0;
+	}
+	dev_err(data->dev, "timed out waiting for idle\n");
+	return -ETIMEDOUT;
+}
+
+static int keystone_mdiox_read(struct mii_bus *bus, int phy_id, int phy_reg)
+{
+	struct keystone_mdiox_data *data = bus->priv;
+	u32 reg;
+	int ret;
+
+	if (phy_reg & ~PHY_REG_MASK || phy_id & ~PHY_ID_MASK)
+		return -EINVAL;
+
+	spin_lock(&data->lock);
+
+	if (data->suspended) {
+		spin_unlock(&data->lock);
+		return -ENODEV;
+	}
+
+	reg = (USERACCESS_GO | USERACCESS_READ | (phy_reg << 21) |
+	       (phy_id << 16));
+
+	while (1) {
+		ret = wait_for_user_access(data);
+		if (ret == -EAGAIN)
+			continue;
+		if (ret < 0)
+			break;
+
+		__raw_writel(reg, &data->regs->user[0].access);
+
+		ret = wait_for_user_access(data);
+		if (ret == -EAGAIN)
+			continue;
+		if (ret < 0)
+			break;
+
+		reg = __raw_readl(&data->regs->user[0].access);
+		ret = (reg & USERACCESS_ACK) ? (reg & USERACCESS_DATA) : -EIO;
+		break;
+	}
+
+	spin_unlock(&data->lock);
+
+	return ret;
+}
+
+static int keystone_mdiox_write(struct mii_bus *bus, int phy_id,
+			      int phy_reg, u16 phy_data)
+{
+	struct keystone_mdiox_data *data = bus->priv;
+	u32 reg;
+	int ret;
+
+	if (phy_reg & ~PHY_REG_MASK || phy_id & ~PHY_ID_MASK)
+		return -EINVAL;
+
+	spin_lock(&data->lock);
+
+	if (data->suspended) {
+		spin_unlock(&data->lock);
+		return -ENODEV;
+	}
+
+	reg = (USERACCESS_GO | USERACCESS_WRITE | (phy_reg << 21) |
+		   (phy_id << 16) | (phy_data & USERACCESS_DATA));
+
+	while (1) {
+		ret = wait_for_user_access(data);
+		if (ret == -EAGAIN)
+			continue;
+		if (ret < 0)
+			break;
+
+		__raw_writel(reg, &data->regs->user[0].access);
+
+		ret = wait_for_user_access(data);
+		if (ret == -EAGAIN)
+			continue;
+		break;
+	}
+
+	spin_unlock(&data->lock);
+
+	return 0;
+}
+
+static int keystone_mdiox_probe_dt(struct mdio_platform_data *data,
+			 struct platform_device *pdev)
+{
+	struct device_node *node = pdev->dev.of_node;
+	u32 prop;
+
+	if (!node)
+		return -EINVAL;
+
+	if (of_property_read_u32(node, "bus_freq", &prop)) {
+		pr_err("Missing bus_freq property in the DT.\n");
+		return -EINVAL;
+	}
+	data->bus_freq = prop;
+
+	return 0;
+}
+
+
+static int keystone_mdiox_probe(struct platform_device *pdev)
+{
+	struct mdio_platform_data *pdata = pdev->dev.platform_data;
+	struct device_node *node = pdev->dev.of_node;
+	struct device *dev = &pdev->dev;
+	struct keystone_mdiox_data *data;
+	struct resource *res;
+	struct phy_device *phy;
+	int ret, addr;
+
+	data = kzalloc(sizeof(*data), GFP_KERNEL);
+	if (!data) {
+		dev_err(dev, "failed to alloc device data\n");
+		return -ENOMEM;
+	}
+
+	data->bus = mdiobus_alloc();
+	if (!data->bus) {
+		dev_err(dev, "failed to alloc mii bus\n");
+		ret = -ENOMEM;
+		goto bail_out;
+	}
+
+	if (dev->of_node) {
+		if (keystone_mdiox_probe_dt(&data->pdata, pdev))
+			data->pdata = k_default_pdata;
+		snprintf(data->bus->id, MII_BUS_ID_SIZE, "%s", pdev->name);
+	} else {
+		data->pdata = pdata ? (*pdata) : k_default_pdata;
+		snprintf(data->bus->id, MII_BUS_ID_SIZE, "%s-%x",
+			 pdev->name, pdev->id);
+	}
+
+	data->bus->name		= dev_name(dev);
+	data->bus->read		= keystone_mdiox_read,
+	data->bus->write	= keystone_mdiox_write,
+	data->bus->reset	= keystone_mdiox_reset,
+	data->bus->parent	= dev;
+	data->bus->priv		= data;
+	data->dev = dev;
+
+	pm_runtime_enable(&pdev->dev);
+	data->clk = clk_get(&pdev->dev, "fck");
+	if (IS_ERR(data->clk)) {
+		dev_err(dev, "failed to get device clock\n");
+		ret = PTR_ERR(data->clk);
+		data->clk = NULL;
+		goto bail_out;
+	}
+
+	clk_prepare(data->clk);
+	pm_runtime_get_sync(&pdev->dev);
+	dev_set_drvdata(dev, data);
+	spin_lock_init(&data->lock);
+
+	xge_serdes_init_156p25Mhz();
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(dev, "could not find register map resource\n");
+		ret = -ENOENT;
+		goto bail_out;
+	}
+
+	res = devm_request_mem_region(dev, res->start, resource_size(res),
+					    dev_name(dev));
+	if (!res) {
+		dev_err(dev, "could not allocate register map resource\n");
+		ret = -ENXIO;
+		goto bail_out;
+	}
+
+	data->regs = devm_ioremap_nocache(dev, res->start, resource_size(res));
+	if (!data->regs) {
+		dev_err(dev, "could not map mdio registers\n");
+		ret = -ENOMEM;
+		goto bail_out;
+	}
+
+	/* register the mii bus */
+	ret = of_mdiobus_register(data->bus, node);
+	if (ret)
+		goto bail_out;
+
+	/* scan and dump the bus */
+	for (addr = 0; addr < PHY_MAX_ADDR; addr++) {
+		phy = data->bus->phy_map[addr];
+		if (phy) {
+			dev_info(dev, "phy[%d]: device %s, driver %s\n",
+				 phy->addr, dev_name(&phy->dev),
+				 phy->drv ? phy->drv->name : "unknown");
+		}
+	}
+	return 0;
+
+bail_out:
+	if (data->bus)
+		mdiobus_free(data->bus);
+
+	if (data->clk)
+		clk_put(data->clk);
+	pm_runtime_put_sync(&pdev->dev);
+	pm_runtime_disable(&pdev->dev);
+
+	kfree(data);
+
+	return ret;
+
+}
+
+static int keystone_mdiox_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct keystone_mdiox_data *data = dev_get_drvdata(dev);
+
+	if (data->bus) {
+		mdiobus_unregister(data->bus);
+		mdiobus_free(data->bus);
+	}
+
+	if (data->clk)
+		clk_put(data->clk);
+	pm_runtime_put_sync(&pdev->dev);
+	pm_runtime_disable(&pdev->dev);
+
+	dev_set_drvdata(dev, NULL);
+
+	kfree(data);
+
+	return 0;
+}
+
+static int keystone_mdiox_suspend(struct device *dev)
+{
+	struct keystone_mdiox_data *data = dev_get_drvdata(dev);
+	u32 ctrl;
+
+	spin_lock(&data->lock);
+
+	/* shutdown the scan state machine */
+	ctrl = __raw_readl(&data->regs->control);
+	ctrl &= ~CONTROL_ENABLE;
+	__raw_writel(ctrl, &data->regs->control);
+	wait_for_idle(data);
+
+	pm_runtime_put_sync(data->dev);
+
+	data->suspended = true;
+	spin_unlock(&data->lock);
+
+	return 0;
+}
+
+static int keystone_mdiox_resume(struct device *dev)
+{
+	struct keystone_mdiox_data *data = dev_get_drvdata(dev);
+	u32 ctrl;
+
+	spin_lock(&data->lock);
+	pm_runtime_put_sync(data->dev);
+
+	/* restart the scan state machine */
+	ctrl = __raw_readl(&data->regs->control);
+	ctrl |= CONTROL_ENABLE;
+	__raw_writel(ctrl, &data->regs->control);
+
+	data->suspended = false;
+	spin_unlock(&data->lock);
+
+	return 0;
+}
+
+static const struct dev_pm_ops keystone_mdiox_pm_ops = {
+	.suspend	= keystone_mdiox_suspend,
+	.resume		= keystone_mdiox_resume,
+};
+
+static const struct of_device_id keystone_mdiox_of_mtable[] = {
+	{ .compatible = "ti,keystone_mdiox", },
+	{ /* sentinel */ },
+};
+
+static struct platform_driver keystone_mdiox_driver = {
+	.driver = {
+		.name	 = "keystone_mdiox",
+		.owner	 = THIS_MODULE,
+		.pm	 = &keystone_mdiox_pm_ops,
+		.of_match_table = of_match_ptr(keystone_mdiox_of_mtable),
+	},
+	.probe = keystone_mdiox_probe,
+	.remove = keystone_mdiox_remove,
+};
+
+static int __init keystone_mdiox_init(void)
+{
+	return platform_driver_register(&keystone_mdiox_driver);
+}
+device_initcall(keystone_mdiox_init);
+
+static void __exit keystone_mdiox_exit(void)
+{
+	platform_driver_unregister(&keystone_mdiox_driver);
+}
+module_exit(keystone_mdiox_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Keystone XGE MDIO driver");
diff --git a/drivers/net/ethernet/ti/keystone_xgepcsr.c b/drivers/net/ethernet/ti/keystone_xgepcsr.c
new file mode 100644
index 0000000..37b074c
--- /dev/null
+++ b/drivers/net/ethernet/ti/keystone_xgepcsr.c
@@ -0,0 +1,268 @@
+/*
+ * Copyright (C) 2012 Texas Instruments Incorporated
+ * Author: WingMan Kwok <w-kwok2@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/io.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+
+#include "keystone_net.h"
+
+#define XGE_SERDES_BASE		0x0231E000
+#define XGE_SERDES_SIZE		0x2000
+
+#define XGE_SGMII_1_STATUS	0x02f00114
+#define XGE_SGMII_2_STATUS	0x02f00214
+
+#define PCSR_OFFSET(x)	((x == 0) ? (0x600) : (0x680))
+
+/*
+ * PCS-R registers
+ */
+#define PCSR_TX_CTL(x)		(PCSR_OFFSET(x) + 0x00)
+#define PCSR_TX_STATUS(x)	(PCSR_OFFSET(x) + 0x04)
+#define PCSR_RX_CTL(x)		(PCSR_OFFSET(x) + 0x08)
+#define PCSR_RX_STATUS(x)	(PCSR_OFFSET(x) + 0x0C)
+
+#define PCSR_SEED_A_LO(x)	(PCSR_OFFSET(x) + 0x10)
+#define PCSR_SEED_A_HI(x)	(PCSR_OFFSET(x) + 0x14)
+#define PCSR_SEED_B_LO(x)	(PCSR_OFFSET(x) + 0x18)
+#define PCSR_SEED_B_HI(x)	(PCSR_OFFSET(x) + 0x1C)
+
+#define PCSR_FEC(x)		(PCSR_OFFSET(x) + 0x20)
+#define PCSR_CTL(x)		(PCSR_OFFSET(x) + 0x24)
+#define PCSR_RX_FEC_CNT(x)	(PCSR_OFFSET(x) + 0x28)
+#define PCSR_RX_ERR_FIFO(x)	(PCSR_OFFSET(x) + 0x2C)
+
+#define PCSR_SIGNAL_OK_EN	BIT(1)
+
+#define reg_rmw(addr, value, mask) \
+	__raw_writel(((__raw_readl(addr) & (~(mask))) | (value)), (addr))
+
+struct serdes_cfg {
+	u32 ofs;
+	u32 val;
+	u32 mask;
+};
+
+struct serdes_cfg cfg_cmu0_1g_slow[] = {
+	{0x0000, 0x00800002, 0x00ff00ff},
+	{0x0014, 0x00003838, 0x0000ffff},
+	{0x0060, 0x1c44e438, 0xffffffff},
+	{0x0064, 0x00c18400, 0x00ffffff},
+	{0x0068, 0x17078200, 0xffffff00},
+	{0x006c, 0x00000014, 0x000000ff},
+	{0x0078, 0x0000c000, 0x0000ff00},
+	{0x0000, 0x00000003, 0x000000ff}
+};
+
+struct serdes_cfg cfg_cmu1_10g_slow[] = {
+	{0x0c00, 0x00030002, 0x00ff00ff},
+	{0x0c14, 0x00005252, 0x0000ffff},
+	{0x0c28, 0x80000000, 0xff000000},
+	{0x0c2c, 0x000000f6, 0x000000ff},
+	{0x0c3c, 0x04000405, 0xff00ffff},
+	{0x0c40, 0xc0800000, 0xffff0000},
+	{0x0c44, 0x5a202062, 0xffffffff},
+	{0x0c48, 0x40040424, 0xffffffff},
+	{0x0c4c, 0x00004002, 0x0000ffff},
+	{0x0c50, 0x19001c00, 0xff00ff00},
+	{0x0c54, 0x00002100, 0x0000ff00},
+	{0x0c58, 0x00000060, 0x000000ff},
+	{0x0c60, 0x80131e7c, 0xffffffff},
+	{0x0c64, 0x00008b02, 0x0000ffff},
+	{0x0c68, 0x17078200, 0xffffff00},
+	{0x0c6c, 0x0000001a, 0x000000ff},
+	{0x0c74, 0x00000400, 0x0000ff00},
+	{0x0c78, 0x0000c000, 0x0000ff00},
+	{0x0c00, 0x00000003, 0x000000ff}
+};
+
+struct serdes_cfg cfg_lane1_10g_slow[] = {
+	{0x0204, 0x00000080, 0x000000ff},
+	{0x0208, 0x0000920d, 0x0000ffff},
+	{0x0204, 0xfc000000, 0xff000000},
+	{0x0208, 0x00009104, 0x0000ffff},
+	{0x0210, 0x1a000000, 0xff000000},
+	/* 58 Lane address 0x14 pma_ln_ctrl[32] should be set to 1.
+	   This is dlpf_div2_ena bit and controls the clock speed for
+	   updating the DLPF integral path in the CDR.
+	*/
+	{0x0214, 0x0000b65c, 0x00ffffff},
+	{0x0218, 0x75800084, 0xffff00ff},
+	{0x022c, 0x00300000, 0x00ff0000},
+	{0x0230, 0x00003800, 0x0000ff00},
+	{0x024c, 0x008f0000, 0x00ff0000},
+	{0x0250, 0x30000000, 0xff000000},
+	{0x0260, 0x00000002, 0x000000ff},
+	{0x0264, 0x00000057, 0x000000ff},
+	{0x0268, 0x00575700, 0x00ffff00},
+	{0x0278, 0xff000000, 0xff000000},
+	{0x0280, 0x00500050, 0x00ff00ff},
+	{0x0284, 0x00001f15, 0x0000ffff},
+	{0x028c, 0x00006f00, 0x0000ff00},
+	{0x0294, 0x00000000, 0xffffff00},
+	{0x0298, 0x00002640, 0xff00ffff},
+	{0x029c, 0x00000003, 0x000000ff},
+	{0x02a4, 0x00000f13, 0x0000ffff},
+	{0x02a8, 0x0001b600, 0x00ffff00},
+	/* CJT, sb=0x30, disable aneg */
+	{0x0380, 0x00000020, 0x000000ff},
+	/* CJT, sb=0x02, disable training */
+	{0x03c0, 0x00000000, 0x0000ff00},
+	{0x03cc, 0x00000018, 0x000000ff},
+	{0x03cc, 0x00000000, 0x000000ff},
+};
+
+struct serdes_cfg cfg_lane2_10g_slow[] = {
+	{0x0404, 0x00000080, 0x000000ff},
+	{0x0408, 0x0000920d, 0x0000ffff},
+	{0x0404, 0xfc000000, 0xff000000},
+	{0x0408, 0x00009104, 0x0000ffff},
+	{0x0410, 0x1a000000, 0xff000000},
+	/* 58 Lane address 0x14 pma_ln_ctrl[32] should be set to 1.
+	   This is dlpf_div2_ena bit and controls the clock speed
+	   for updating the DLPF integral path in the CDR.
+	*/
+	{0x0414, 0x0000b6b5c, 0x00ffffff},
+	{0x0418, 0x75800084, 0xffff00ff},
+	{0x042c, 0x00300000, 0x00ff0000},
+	{0x0430, 0x00003800, 0x0000ff00},
+	{0x044c, 0x008f0000, 0x00ff0000},
+	{0x0450, 0x30000000, 0xff000000},
+	{0x0460, 0x00000002, 0x000000ff},
+	{0x0464, 0x00000057, 0x000000ff},
+	{0x0468, 0x00575700, 0x00ffff00},
+	{0x0478, 0xff000000, 0xff000000},
+	{0x0480, 0x00500050, 0x00ff00ff},
+	{0x0484, 0x00001f15, 0x0000ffff},
+	{0x048c, 0x00006f00, 0x0000ff00},
+	{0x0494, 0x00000000, 0xffffff00},
+	{0x0498, 0x00002640, 0xff00ffff},
+	{0x049c, 0x00000003, 0x000000ff},
+	{0x04a4, 0x00000f13, 0x0000ffff},
+	{0x04a8, 0x0001b600, 0x00ffff00},
+	/* CJT, sb=0x30, disable aneg */
+	{0x0580, 0x00000020, 0x000000ff},
+	/* CJT, sb=0x30, disable training */
+	{0x05c0, 0x00000000, 0x0000ff00},
+	{0x05cc, 0x00000018, 0x000000ff},
+	{0x05cc, 0x00000000, 0x000000ff}
+};
+
+struct serdes_cfg cfg_comlane_10g_slow[] = {
+	{0x0a00, 0x00000800, 0x0000ff00},
+	{0x0a84, 0x00000000, 0x000000ff},
+	{0x0a8c, 0x00130000, 0x00ff0000},
+	{0x0a90, 0x77a00000, 0xffff0000},
+	{0x0a94, 0x00007777, 0x0000ffff},
+	{0x0b08, 0x000f0000, 0xffff0000},
+	{0x0b0c, 0x000f0000, 0x00ffffff},
+	{0x0b10, 0xbe000000, 0xff000000},
+	{0x0b14, 0x000000ff, 0x000000ff},
+	{0x0b18, 0x00000014, 0x000000ff},
+	{0x0b5c, 0x981b0000, 0xffff0000},
+	{0x0b64, 0x00001100, 0x0000ff00},
+	{0x0b78, 0x00000c00, 0x0000ff00},
+	{0x0abc, 0xff000000, 0xff000000},
+	{0x0ac0, 0x0000008b, 0x000000ff},
+};
+
+void xge_serdes_10gbps_setup_phy_b(void)
+{
+	void __iomem *regs, *sgmii_1_status, *sgmii_2_status;
+	u32 i, val;
+
+	regs = ioremap(XGE_SERDES_BASE, XGE_SERDES_SIZE);
+	sgmii_1_status = ioremap(XGE_SGMII_1_STATUS, 4);
+	sgmii_2_status = ioremap(XGE_SGMII_2_STATUS, 4);
+
+	/* preamble */
+	__raw_writel(37500, regs + 0x1ffc);
+
+	/* cmu0_1g_slow */
+	for (i = 0; i < ARRAY_SIZE(cfg_cmu0_1g_slow); i++) {
+		reg_rmw(regs + cfg_cmu0_1g_slow[i].ofs,
+			cfg_cmu0_1g_slow[i].val,
+			cfg_cmu0_1g_slow[i].mask);
+	}
+
+	/* cmu1_10g_slow */
+	for (i = 0; i < ARRAY_SIZE(cfg_cmu1_10g_slow); i++) {
+		reg_rmw(regs + cfg_cmu1_10g_slow[i].ofs,
+			cfg_cmu1_10g_slow[i].val,
+			cfg_cmu1_10g_slow[i].mask);
+	}
+
+	/* lane1_10g_slow */
+	for (i = 0; i < ARRAY_SIZE(cfg_lane1_10g_slow); i++) {
+		reg_rmw(regs + cfg_lane1_10g_slow[i].ofs,
+			cfg_lane1_10g_slow[i].val,
+			cfg_lane1_10g_slow[i].mask);
+	}
+
+	/* lane2_10g_slow */
+	for (i = 0; i < ARRAY_SIZE(cfg_lane2_10g_slow); i++) {
+		reg_rmw(regs + cfg_lane2_10g_slow[i].ofs,
+			cfg_lane2_10g_slow[i].val,
+			cfg_lane2_10g_slow[i].mask);
+	}
+
+	/* comlane_10g_slow */
+	for (i = 0; i < ARRAY_SIZE(cfg_comlane_10g_slow); i++) {
+		reg_rmw(regs + cfg_comlane_10g_slow[i].ofs,
+			cfg_comlane_10g_slow[i].val,
+			cfg_comlane_10g_slow[i].mask);
+	}
+
+	/* reset_clr */
+	reg_rmw(regs + 0x0a00, 0x0000005f, 0x000000ff);
+
+	/*Enable pll via the pll_ctrl 0x0014*/
+	__raw_writel(0xee000000, regs + 0x1ff4);
+
+	/* Enable TX and RX via the LANExCTL_STS 0x0000 + x*4 */
+	/* Full Rate mode, 16b width */
+	__raw_writel(0xe0e9e038, regs + 0x1fe0);
+	__raw_writel(0xe0e9e038, regs + 0x1fe4);
+	udelay(200);
+
+	/* Wait for SGMII Serdes PLL lock */
+	do {
+		val = __raw_readl(sgmii_1_status);
+	} while ((val & 0x10) != 0x10);
+
+	do {
+		/* sgmii_2 status */
+	} while ((val & 0x10) != 0x10);
+
+	iounmap(regs);
+}
+
+static int keystone_xge_serdes_configured;  /* FIXME */
+
+void xge_serdes_init_156p25Mhz(void)
+{
+	/* Serdes should only be configured once */
+	if (keystone_xge_serdes_configured)
+		return;
+
+	xge_serdes_10gbps_setup_phy_b();
+	keystone_xge_serdes_configured = 1;
+}
+
+int keystone_pcsr_config(void __iomem *pcsr_ofs, int port, u32 interface)
+{
+	return 0;
+}
diff --git a/drivers/net/ethernet/ti/keystone_xgess.c b/drivers/net/ethernet/ti/keystone_xgess.c
new file mode 100644
index 0000000..47173de
--- /dev/null
+++ b/drivers/net/ethernet/ti/keystone_xgess.c
@@ -0,0 +1,2524 @@
+/*
+ * Copyright (C) 2012 Texas Instruments Incorporated
+ * Authors: Sandeep Paulraj <s-paulraj@ti.com>
+ * Authors: WingMan Kwok <w-kwok2@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/clk.h>
+#include <linux/phy.h>
+#include <linux/timer.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/uaccess.h>
+#include <linux/if_vlan.h>
+#include <linux/of_mdio.h>
+#include <linux/ethtool.h>
+#include <linux/if_ether.h>
+#include <linux/net_tstamp.h>
+#include <linux/netdevice.h>
+#include <linux/interrupt.h>
+#include <linux/dmaengine.h>
+#include <linux/dma-mapping.h>
+#include <linux/scatterlist.h>
+#include <linux/etherdevice.h>
+#include <linux/platform_device.h>
+
+#include "cpsw_ale.h"
+#include "keystone_net.h"
+
+#define CPSW_MODULE_NAME	"keystone-cpswx"
+#define NETCP_DRIVER_NAME	"TI KeyStone XGE Driver"
+#define NETCP_DRIVER_VERSION	"v0.0.0"
+
+#define CPSW_IDENT(reg)			((reg >> 16) & 0xffff)
+#define CPSW_MAJOR_VERSION(reg)		(reg >> 8 & 0x7)
+#define CPSW_MINOR_VERSION(reg)		(reg & 0xff)
+#define CPSW_RTL_VERSION(reg)		((reg >> 11) & 0x1f)
+
+#define DEVICE_N_GMACSL_PORTS			2
+#define DEVICE_EMACSL_RESET_POLL_COUNT		100
+
+#define	CPSW_TIMER_INTERVAL			(HZ / 10)
+
+/* Soft reset register values */
+#define SOFT_RESET_MASK				BIT(0)
+#define SOFT_RESET				BIT(0)
+
+#define MACSL_RX_ENABLE_CSF			BIT(23)
+#define MACSL_RX_ENABLE_EXT_CTL			BIT(18)
+#define MACSL_XGMII_ENABLE			BIT(13)
+#define MACSL_XGIG_MODE				BIT(8)
+#define MACSL_GMII_ENABLE			BIT(5)
+#define GMACSL_RET_WARN_RESET_INCOMPLETE	-2
+
+#define SLAVE_LINK_IS_XGMII(s) \
+	((s)->link_interface >= XGMII_LINK_MAC_PHY)
+
+#define MACSL_SIG_ENABLE(s) \
+		(SLAVE_LINK_IS_XGMII((s)) ?   \
+		(MACSL_XGMII_ENABLE | MACSL_XGIG_MODE) : \
+		MACSL_GMII_ENABLE)
+
+#define CPSW_NUM_PORTS		                3
+#define CPSW_CTL_P0_ENABLE			BIT(2)
+#define CPSW_CTL_VLAN_AWARE			BIT(1)
+#define CPSW_REG_VAL_STAT_ENABLE_ALL		0xf
+
+#define CPSW_MASK_ALL_PORTS			7
+#define CPSW_MASK_PHYS_PORTS			6
+#define CPSW_MASK_NO_PORTS			0
+#define CPSW_NON_VLAN_ADDR			-1
+
+#define CPSW_STATS0_MODULE			0
+#define CPSW_STATS1_MODULE			1
+#define CPSW_STATS2_MODULE			2
+
+#define MAX_SIZE_STREAM_BUFFER		        9504
+
+struct cpswx_slave {
+	struct cpswx_slave_regs __iomem		*regs;
+	struct cpswx_sliver_regs __iomem	*sliver;
+	int				 slave_num;
+	int				 port_num;
+	u32				 mac_control;
+	struct phy_device		*phy;
+	const char			*phy_id;
+	struct cpsw_ale			*ale;
+	u32				 link_interface;
+	u8				 phy_port_t;
+};
+
+/* 0x0000 */
+struct cpswx_ss_regs {
+	u32	id_ver;
+	u32	synce_count;
+	u32	synce_mux;
+	u32	control;
+};
+
+/* 0x1000 */
+struct cpswx_regs {
+	u32	id_ver;
+	u32	control;
+	u32	emcontrol;
+	u32	stat_port_en;
+	u32	ptype;
+	u32	soft_idle;
+	u32	thru_rate;
+	u32	gap_thresh;
+	u32	tx_start_wds;
+	u32	flow_control;
+	u32	cppi_thresh;
+};
+
+/* 0x1064, 0x1094 */
+struct cpswx_slave_regs {
+	u32	blk_cnt;
+	u32	port_vlan;
+	u32	tx_pri_map;
+	u32	sa_lo;
+	u32	sa_hi;
+	u32	ts_ctl;
+	u32	ts_seq_ltype;
+	u32	ts_vlan;
+	u32	ts_ctl_ltype2;
+	u32	ts_ctl2;
+	u32	control;
+};
+
+/* 0x1034 */
+struct cpswx_host_regs {
+	u32	blk_cnt;
+	u32	port_vlan;
+	u32	tx_pri_map;
+	u32	src_id;
+	u32	rx_pri_map;
+	u32	rx_maxlen;
+};
+
+/* 0x1400, 0x1440 */
+struct cpswx_sliver_regs {
+	u32	id_ver;
+	u32	mac_control;
+	u32	mac_status;
+	u32	soft_reset;
+	u32	rx_maxlen;
+	u32	__reserved_0;
+	u32	rx_pause;
+	u32	tx_pause;
+	u32	em_control;
+	u32	__reserved_1;
+	u32	tx_gap;
+	u32	rsvd[4];
+};
+
+struct cpswx_host_hw_stats {
+	u32	rx_good_frames;
+	u32	rx_broadcast_frames;
+	u32	rx_multicast_frames;
+	u32	__rsvd_0[3];
+	u32	rx_oversized_frames;
+	u32	__rsvd_1;
+	u32	rx_undersized_frames;
+	u32	__rsvd_2;
+	u32	overrun_type4;
+	u32	overrun_type5;
+	u32	rx_bytes;
+	u32	tx_good_frames;
+	u32	tx_broadcast_frames;
+	u32	tx_multicast_frames;
+	u32	__rsvd_3[9];
+	u32	tx_bytes;
+	u32	tx_64byte_frames;
+	u32	tx_65_to_127byte_frames;
+	u32	tx_128_to_255byte_frames;
+	u32	tx_256_to_511byte_frames;
+	u32	tx_512_to_1023byte_frames;
+	u32	tx_1024byte_frames;
+	u32	net_bytes;
+	u32	rx_sof_overruns;
+	u32	rx_mof_overruns;
+	u32	rx_dma_overruns;
+};
+
+/* 0x1900, 0x1a00 */
+struct cpswx_hw_stats {
+	u32	rx_good_frames;
+	u32	rx_broadcast_frames;
+	u32	rx_multicast_frames;
+	u32	rx_pause_frames;
+	u32	rx_crc_errors;
+	u32	rx_align_code_errors;
+	u32	rx_oversized_frames;
+	u32	rx_jabber_frames;
+	u32	rx_undersized_frames;
+	u32	rx_fragments;
+	u32	overrun_type4;
+	u32	overrun_type5;
+	u32	rx_bytes;
+	u32	tx_good_frames;
+	u32	tx_broadcast_frames;
+	u32	tx_multicast_frames;
+	u32	tx_pause_frames;
+	u32	tx_deferred_frames;
+	u32	tx_collision_frames;
+	u32	tx_single_coll_frames;
+	u32	tx_mult_coll_frames;
+	u32	tx_excessive_collisions;
+	u32	tx_late_collisions;
+	u32	tx_underrun;
+	u32	tx_carrier_sense_errors;
+	u32	tx_bytes;
+	u32	tx_64byte_frames;
+	u32	tx_65_to_127byte_frames;
+	u32	tx_128_to_255byte_frames;
+	u32	tx_256_to_511byte_frames;
+	u32	tx_512_to_1023byte_frames;
+	u32	tx_1024byte_frames;
+	u32	net_bytes;
+	u32	rx_sof_overruns;
+	u32	rx_mof_overruns;
+	u32	rx_dma_overruns;
+};
+
+/* 0x1700 */
+struct cpswx_ale_regs {
+	u32	ale_idver;
+	u32	__rsvd0;
+	u32	ale_control;
+	u32	__rsvd1;
+	u32	ale_prescale;
+	u32	ale_aging_timer;  /* +++FIXME: no description found in manual */
+	u32	ale_unknown_vlan;
+	u32	__rsvd3;
+	u32	ale_tblctl;
+	u32	__rsvd4[4];
+	u32	ale_tblw2;
+	u32	ale_tblw1;
+	u32	ale_tblw0;
+	u32	ale_portctl[3];
+};
+
+struct cpswx_priv {
+	struct device			*dev;
+	struct clk			*clk;
+	struct netcp_device		*netcp_device;
+	u32				 num_slaves;
+	u32				 ale_ageout;
+	u32				 ale_entries;
+	u32				 ale_ports;
+	u32				 sgmii_module_ofs;
+	u32				 pcsr_module_ofs;
+	u32				 switch_module_ofs;
+	u32				 host_port_reg_ofs;
+	u32				 slave_reg_ofs;
+	u32				 sliver_reg_ofs;
+	u32				 hw_stats_reg_ofs;
+	u32				 ale_reg_ofs;
+
+	int				 host_port;
+	u32				 rx_packet_max;
+
+	struct cpswx_regs __iomem		*regs;
+	struct cpswx_ss_regs __iomem		*ss_regs;
+	struct cpswx_host_hw_stats __iomem	*host_hw_stats_regs;
+	struct cpswx_hw_stats __iomem		*hw_stats_regs[2];
+	struct cpswx_host_regs __iomem		*host_port_regs;
+	struct cpswx_ale_regs __iomem		*ale_reg;
+
+	void __iomem				*sgmii_port_regs;
+	void __iomem				*pcsr_port_regs;
+
+	struct cpsw_ale				*ale;
+	u32				 ale_refcnt;
+
+	u32				 link[5];
+	struct device_node		*phy_node[4];
+
+	u32				 intf_tx_queues;
+
+	u32				 multi_if;
+	u32				 slaves_per_interface;
+	u32				 num_interfaces;
+	struct device_node		*interfaces;
+	struct list_head		 cpsw_intf_head;
+
+	u64				 hw_stats[96];
+	int				 init_serdes_at_probe;
+	struct kobject			kobj;
+	struct kobject			tx_pri_kobj;
+	struct kobject			pvlan_kobj;
+	struct kobject			stats_kobj;
+	struct mutex			hw_stats_lock;
+};
+
+struct cpswx_intf {
+	struct net_device	*ndev;
+	struct device		*dev;
+	struct cpswx_priv	*cpsw_priv;
+	struct device_node	*phy_node;
+	u32			 num_slaves;
+	u32			 slave_port;
+	struct cpswx_slave	*slaves;
+	u32			 intf_tx_queues;
+	const char		*tx_chan_name;
+	u32			 tx_queue_depth;
+	struct netcp_tx_pipe	 tx_pipe;
+	u32			 multi_if;
+	struct list_head	 cpsw_intf_list;
+	struct timer_list	 timer;
+	u32			 sgmii_link;
+	unsigned long		 active_vlans[BITS_TO_LONGS(VLAN_N_VID)];
+};
+
+/*
+ * Statistic management
+ */
+struct netcp_ethtool_stat {
+	char desc[ETH_GSTRING_LEN];
+	int type;
+	u32 size;
+	int offset;
+};
+
+/* +++FIXME: do we need the port?? */
+#define for_each_slave(priv, func, arg...)				\
+	do {								\
+		int idx, port;						\
+		port = (priv)->slave_port;				\
+		if ((priv)->multi_if)					\
+			(func)((priv)->slaves, ##arg);			\
+		else							\
+			for (idx = 0; idx < (priv)->num_slaves; idx++)	\
+				(func)((priv)->slaves + idx, ##arg);	\
+	} while (0)
+
+#define FIELDINFO(_struct, field) FIELD_SIZEOF(_struct, field), \
+					offsetof(_struct, field)
+
+#define CPSW_STATS0_INFO(field)	"CPSW_0:"#field, CPSW_STATS0_MODULE, \
+				FIELDINFO(struct cpswx_host_hw_stats, field)
+
+#define CPSW_STATSA_INFO(field)	"CPSW_1:"#field, CPSW_STATS1_MODULE, \
+				FIELDINFO(struct cpswx_hw_stats, field)
+#define CPSW_STATSB_INFO(field)	"CPSW_2:"#field, CPSW_STATS2_MODULE, \
+				FIELDINFO(struct cpswx_hw_stats, field)
+
+static const struct netcp_ethtool_stat et_stats[] = {
+	/* CPSW module 0 */
+	{CPSW_STATS0_INFO(rx_good_frames)},
+	{CPSW_STATS0_INFO(rx_broadcast_frames)},
+	{CPSW_STATS0_INFO(rx_multicast_frames)},
+	{CPSW_STATS0_INFO(rx_oversized_frames)},
+	{CPSW_STATS0_INFO(rx_undersized_frames)},
+	{CPSW_STATS0_INFO(overrun_type4)},
+	{CPSW_STATS0_INFO(overrun_type5)},
+	{CPSW_STATS0_INFO(rx_bytes)},
+	{CPSW_STATS0_INFO(tx_good_frames)},
+	{CPSW_STATS0_INFO(tx_broadcast_frames)},
+	{CPSW_STATS0_INFO(tx_multicast_frames)},
+	{CPSW_STATS0_INFO(tx_bytes)},
+	{CPSW_STATS0_INFO(tx_64byte_frames)},
+	{CPSW_STATS0_INFO(tx_65_to_127byte_frames)},
+	{CPSW_STATS0_INFO(tx_128_to_255byte_frames)},
+	{CPSW_STATS0_INFO(tx_256_to_511byte_frames)},
+	{CPSW_STATS0_INFO(tx_512_to_1023byte_frames)},
+	{CPSW_STATS0_INFO(tx_1024byte_frames)},
+	{CPSW_STATS0_INFO(net_bytes)},
+	{CPSW_STATS0_INFO(rx_sof_overruns)},
+	{CPSW_STATS0_INFO(rx_mof_overruns)},
+	{CPSW_STATS0_INFO(rx_dma_overruns)},
+	/* CPSW module 1 */
+	{CPSW_STATSA_INFO(rx_good_frames)},
+	{CPSW_STATSA_INFO(rx_broadcast_frames)},
+	{CPSW_STATSA_INFO(rx_multicast_frames)},
+	{CPSW_STATSA_INFO(rx_pause_frames)},
+	{CPSW_STATSA_INFO(rx_crc_errors)},
+	{CPSW_STATSA_INFO(rx_align_code_errors)},
+	{CPSW_STATSA_INFO(rx_oversized_frames)},
+	{CPSW_STATSA_INFO(rx_jabber_frames)},
+	{CPSW_STATSA_INFO(rx_undersized_frames)},
+	{CPSW_STATSA_INFO(rx_fragments)},
+	{CPSW_STATSA_INFO(overrun_type4)},
+	{CPSW_STATSA_INFO(overrun_type5)},
+	{CPSW_STATSA_INFO(rx_bytes)},
+	{CPSW_STATSA_INFO(tx_good_frames)},
+	{CPSW_STATSA_INFO(tx_broadcast_frames)},
+	{CPSW_STATSA_INFO(tx_multicast_frames)},
+	{CPSW_STATSA_INFO(tx_pause_frames)},
+	{CPSW_STATSA_INFO(tx_deferred_frames)},
+	{CPSW_STATSA_INFO(tx_collision_frames)},
+	{CPSW_STATSA_INFO(tx_single_coll_frames)},
+	{CPSW_STATSA_INFO(tx_mult_coll_frames)},
+	{CPSW_STATSA_INFO(tx_excessive_collisions)},
+	{CPSW_STATSA_INFO(tx_late_collisions)},
+	{CPSW_STATSA_INFO(tx_underrun)},
+	{CPSW_STATSA_INFO(tx_carrier_sense_errors)},
+	{CPSW_STATSA_INFO(tx_bytes)},
+	{CPSW_STATSA_INFO(tx_64byte_frames)},
+	{CPSW_STATSA_INFO(tx_65_to_127byte_frames)},
+	{CPSW_STATSA_INFO(tx_128_to_255byte_frames)},
+	{CPSW_STATSA_INFO(tx_256_to_511byte_frames)},
+	{CPSW_STATSA_INFO(tx_512_to_1023byte_frames)},
+	{CPSW_STATSA_INFO(tx_1024byte_frames)},
+	{CPSW_STATSA_INFO(net_bytes)},
+	{CPSW_STATSA_INFO(rx_sof_overruns)},
+	{CPSW_STATSA_INFO(rx_mof_overruns)},
+	{CPSW_STATSA_INFO(rx_dma_overruns)},
+	/* CPSW module 2 */
+	{CPSW_STATSB_INFO(rx_good_frames)},
+	{CPSW_STATSB_INFO(rx_broadcast_frames)},
+	{CPSW_STATSB_INFO(rx_multicast_frames)},
+	{CPSW_STATSB_INFO(rx_pause_frames)},
+	{CPSW_STATSB_INFO(rx_crc_errors)},
+	{CPSW_STATSB_INFO(rx_align_code_errors)},
+	{CPSW_STATSB_INFO(rx_oversized_frames)},
+	{CPSW_STATSB_INFO(rx_jabber_frames)},
+	{CPSW_STATSB_INFO(rx_undersized_frames)},
+	{CPSW_STATSB_INFO(rx_fragments)},
+	{CPSW_STATSB_INFO(overrun_type4)},
+	{CPSW_STATSB_INFO(overrun_type5)},
+	{CPSW_STATSB_INFO(rx_bytes)},
+	{CPSW_STATSB_INFO(tx_good_frames)},
+	{CPSW_STATSB_INFO(tx_broadcast_frames)},
+	{CPSW_STATSB_INFO(tx_multicast_frames)},
+	{CPSW_STATSB_INFO(tx_pause_frames)},
+	{CPSW_STATSB_INFO(tx_deferred_frames)},
+	{CPSW_STATSB_INFO(tx_collision_frames)},
+	{CPSW_STATSB_INFO(tx_single_coll_frames)},
+	{CPSW_STATSB_INFO(tx_mult_coll_frames)},
+	{CPSW_STATSB_INFO(tx_excessive_collisions)},
+	{CPSW_STATSB_INFO(tx_late_collisions)},
+	{CPSW_STATSB_INFO(tx_underrun)},
+	{CPSW_STATSB_INFO(tx_carrier_sense_errors)},
+	{CPSW_STATSB_INFO(tx_bytes)},
+	{CPSW_STATSB_INFO(tx_64byte_frames)},
+	{CPSW_STATSB_INFO(tx_65_to_127byte_frames)},
+	{CPSW_STATSB_INFO(tx_128_to_255byte_frames)},
+	{CPSW_STATSB_INFO(tx_256_to_511byte_frames)},
+	{CPSW_STATSB_INFO(tx_512_to_1023byte_frames)},
+	{CPSW_STATSB_INFO(tx_1024byte_frames)},
+	{CPSW_STATSB_INFO(net_bytes)},
+	{CPSW_STATSB_INFO(rx_sof_overruns)},
+	{CPSW_STATSB_INFO(rx_mof_overruns)},
+	{CPSW_STATSB_INFO(rx_dma_overruns)},
+};
+
+#define ETHTOOL_STATS_NUM ARRAY_SIZE(et_stats)
+
+struct cpswx_attribute {
+	struct attribute attr;
+	ssize_t (*show)(struct cpswx_priv *cpsw_dev,
+		struct cpswx_attribute *attr, char *buf);
+	ssize_t	(*store)(struct cpswx_priv *cpsw_dev,
+		struct cpswx_attribute *attr, const char *, size_t);
+	const struct cpswx_mod_info *info;
+	ssize_t info_size;
+	void *context;
+};
+#define to_cpswx_attr(_attr) container_of(_attr, struct cpswx_attribute, attr)
+
+#define to_cpswx_dev(obj) container_of(obj, struct cpswx_priv, kobj)
+
+#define tx_pri_to_cpswx_dev(obj) \
+	container_of(obj, struct cpswx_priv, tx_pri_kobj)
+
+#define pvlan_to_cpswx_dev(obj) \
+	container_of(obj, struct cpswx_priv, pvlan_kobj)
+
+#define stats_to_cpswx_dev(obj) \
+	container_of(obj, struct cpswx_priv, stats_kobj)
+
+#define BITS(x)			(BIT(x) - 1)
+#define BITMASK(n, s)		(BITS(n) << (s))
+#define cpsw_mod_info_field_val(r, i) \
+	((r & BITMASK(i->bits, i->shift)) >> i->shift)
+
+#define for_each_intf(i, priv) \
+	list_for_each_entry((i), &(priv)->cpsw_intf_head, cpsw_intf_list)
+
+#define __CPSW_ATTR_FULL(_name, _mode, _show, _store, _info,	\
+				_info_size, _ctxt)		\
+	{ \
+		.attr = {.name = __stringify(_name), .mode = _mode },	\
+		.show	= _show,		\
+		.store	= _store,		\
+		.info	= _info,		\
+		.info_size = _info_size,	\
+		.context = (_ctxt),		\
+	}
+
+#define __CPSW_ATTR(_name, _mode, _show, _store, _info) \
+		__CPSW_ATTR_FULL(_name, _mode, _show, _store, _info, \
+					(ARRAY_SIZE(_info)), NULL)
+
+#define __CPSW_CTXT_ATTR(_name, _mode, _show, _store, _info, _ctxt) \
+		__CPSW_ATTR_FULL(_name, _mode, _show, _store, _info, \
+					(ARRAY_SIZE(_info)), _ctxt)
+
+struct cpswx_mod_info {
+	const char	*name;
+	int		shift;
+	int		bits;
+};
+
+struct cpswx_parse_result {
+	int control;
+	int port;
+	u32 value;
+};
+
+static ssize_t cpsw_attr_info_show(const struct cpswx_mod_info *info,
+				int info_size, u32 reg, char *buf)
+{
+	int i, len = 0;
+
+	for (i = 0; i < info_size; i++, info++) {
+		len += snprintf(buf + len, PAGE_SIZE - len,
+			"%s=%d\n", info->name,
+			(int)cpsw_mod_info_field_val(reg, info));
+	}
+
+	return len;
+}
+
+static ssize_t cpsw_attr_parse_set_command(struct cpswx_priv *cpsw_dev,
+			      struct cpswx_attribute *attr,
+			      const char *buf, size_t count,
+				struct cpswx_parse_result *res)
+{
+	char ctrl_str[33], tmp_str[9];
+	int port = -1, value, len, control;
+	unsigned long end;
+	const struct cpswx_mod_info *info = attr->info;
+
+	len = strcspn(buf, ".=");
+	if (len >= 32)
+		return -ENOMEM;
+
+	strncpy(ctrl_str, buf, len);
+	ctrl_str[len] = '\0';
+	buf += len;
+
+	if (*buf == '.') {
+		++buf;
+		len = strcspn(buf, "=");
+		if (len >= 8)
+			return -ENOMEM;
+		strncpy(tmp_str, buf, len);
+		tmp_str[len] = '\0';
+		if (kstrtoul(tmp_str, 0, &end))
+			return -EINVAL;
+		port = (int)end;
+		buf += len;
+	}
+
+	if (*buf != '=')
+		return -EINVAL;
+
+	if (kstrtoul(buf + 1, 0, &end))
+		return -EINVAL;
+
+	value = (int)end;
+
+	for (control = 0; control < attr->info_size; control++)
+		if (strcmp(ctrl_str, info[control].name) == 0)
+			break;
+
+	if (control >= attr->info_size)
+		return -ENOENT;
+
+	res->control = control;
+	res->port = port;
+	res->value = value;
+
+	dev_info(cpsw_dev->dev, "parsed command %s.%d=%d\n",
+		attr->info[control].name, port, value);
+
+	return 0;
+}
+
+static inline void cpsw_info_set_reg_field(void __iomem *r,
+		const struct cpswx_mod_info *info, int val)
+{
+	u32 rv;
+
+	rv = __raw_readl(r);
+	rv = ((rv & ~BITMASK(info->bits, info->shift)) | (val << info->shift));
+	__raw_writel(rv, r);
+}
+
+static ssize_t cpsw_version_show(struct cpswx_priv *cpsw_dev,
+		     struct cpswx_attribute *attr,
+		     char *buf)
+{
+	u32 reg;
+
+	reg = __raw_readl(&cpsw_dev->regs->id_ver);
+
+	return snprintf(buf, PAGE_SIZE,
+		"cpsw version %d.%d (%d) SGMII identification value 0x%x\n",
+		 CPSW_MAJOR_VERSION(reg), CPSW_MINOR_VERSION(reg),
+		 CPSW_RTL_VERSION(reg), CPSW_IDENT(reg));
+}
+
+static struct cpswx_attribute cpsw_version_attribute =
+	__ATTR(version, S_IRUGO, cpsw_version_show, NULL);
+
+static const struct cpswx_mod_info cpsw_controls[] = {
+	{
+		.name		= "fifo_loopback",
+		.shift		= 0,
+		.bits		= 1,
+	},
+	{
+		.name		= "vlan_aware",
+		.shift		= 1,
+		.bits		= 1,
+	},
+	{
+		.name		= "p0_enable",
+		.shift		= 2,
+		.bits		= 1,
+	},
+	{
+		.name		= "p0_pass_pri_tagged",
+		.shift		= 3,
+		.bits		= 1,
+	},
+	{
+		.name		= "p1_pass_pri_tagged",
+		.shift		= 4,
+		.bits		= 1,
+	},
+	{
+		.name		= "p2_pass_pri_tagged",
+		.shift		= 5,
+		.bits		= 1,
+	},
+	{
+		.name		= "p0_tx_crc_type",
+		.shift		= 12,
+		.bits		= 1,
+	},
+};
+
+static ssize_t cpsw_control_show(struct cpswx_priv *cpsw_dev,
+		     struct cpswx_attribute *attr,
+		     char *buf)
+{
+	u32 reg;
+
+	reg = __raw_readl(&cpsw_dev->regs->control);
+	return cpsw_attr_info_show(attr->info, attr->info_size, reg, buf);
+}
+
+static ssize_t cpsw_control_store(struct cpswx_priv *cpsw_dev,
+			      struct cpswx_attribute *attr,
+			      const char *buf, size_t count)
+{
+	const struct cpswx_mod_info *i;
+	struct cpswx_parse_result res;
+	void __iomem *r = NULL;
+	int ret;
+
+
+	ret = cpsw_attr_parse_set_command(cpsw_dev, attr, buf, count, &res);
+	if (ret)
+		return ret;
+
+	i = &(attr->info[res.control]);
+	r = &cpsw_dev->regs->control;
+
+	cpsw_info_set_reg_field(r, i, res.value);
+	return count;
+}
+
+static struct cpswx_attribute cpsw_control_attribute =
+	__CPSW_ATTR(control, S_IRUGO | S_IWUSR,
+		cpsw_control_show, cpsw_control_store, cpsw_controls);
+
+static const struct cpswx_mod_info cpsw_ptypes[] = {
+	{
+		.name		= "escalate_pri_load_val",
+		.shift		= 0,
+		.bits		= 5,
+	},
+	{
+		.name		= "port0_pri_type_escalate",
+		.shift		= 8,
+		.bits		= 1,
+	},
+	{
+		.name		= "port1_pri_type_escalate",
+		.shift		= 9,
+		.bits		= 1,
+	},
+	{
+		.name		= "port2_pri_type_escalate",
+		.shift		= 10,
+		.bits		= 1,
+	},
+};
+
+static ssize_t cpsw_pri_type_show(struct cpswx_priv *cpsw_dev,
+		     struct cpswx_attribute *attr,
+		     char *buf)
+{
+	u32 reg;
+
+	reg = __raw_readl(&cpsw_dev->regs->ptype);
+
+	return cpsw_attr_info_show(attr->info, attr->info_size, reg, buf);
+}
+
+static ssize_t cpsw_pri_type_store(struct cpswx_priv *cpsw_dev,
+			      struct cpswx_attribute *attr,
+			      const char *buf, size_t count)
+{
+	const struct cpswx_mod_info *i;
+	struct cpswx_parse_result res;
+	void __iomem *r = NULL;
+	int ret;
+
+
+	ret = cpsw_attr_parse_set_command(cpsw_dev, attr, buf, count, &res);
+	if (ret)
+		return ret;
+
+	i = &(attr->info[res.control]);
+	r = &cpsw_dev->regs->ptype;
+
+	cpsw_info_set_reg_field(r, i, res.value);
+	return count;
+}
+
+static struct cpswx_attribute cpsw_pri_type_attribute =
+	__CPSW_ATTR(priority_type, S_IRUGO | S_IWUSR,
+			cpsw_pri_type_show,
+			cpsw_pri_type_store,
+			cpsw_ptypes);
+
+static const struct cpswx_mod_info cpsw_flow_controls[] = {
+	{
+		.name		= "port0_flow_control_en",
+		.shift		= 0,
+		.bits		= 1,
+	},
+	{
+		.name		= "port1_flow_control_en",
+		.shift		= 1,
+		.bits		= 1,
+	},
+	{
+		.name		= "port2_flow_control_en",
+		.shift		= 2,
+		.bits		= 1,
+	},
+};
+
+static ssize_t cpsw_flow_control_show(struct cpswx_priv *cpsw_dev,
+		     struct cpswx_attribute *attr, char *buf)
+{
+	u32 reg;
+
+	reg = __raw_readl(&cpsw_dev->regs->flow_control);
+
+	return cpsw_attr_info_show(attr->info, attr->info_size, reg, buf);
+}
+
+static ssize_t cpsw_flow_control_store(struct cpswx_priv *cpsw_dev,
+			      struct cpswx_attribute *attr,
+			      const char *buf, size_t count)
+{
+	const struct cpswx_mod_info *i;
+	struct cpswx_parse_result res;
+	void __iomem *r = NULL;
+	int ret;
+
+
+	ret = cpsw_attr_parse_set_command(cpsw_dev, attr, buf, count, &res);
+	if (ret)
+		return ret;
+
+	i = &(attr->info[res.control]);
+	r = &cpsw_dev->regs->flow_control;
+
+	cpsw_info_set_reg_field(r, i, res.value);
+	return count;
+}
+
+static struct cpswx_attribute cpsw_flow_control_attribute =
+	__CPSW_ATTR(flow_control, S_IRUGO | S_IWUSR,
+		cpsw_flow_control_show,
+		cpsw_flow_control_store,
+		cpsw_flow_controls);
+
+static const struct cpswx_mod_info cpsw_port_tx_pri_maps[] = {
+	{
+		.name		= "port_tx_pri_0",
+		.shift		= 0,
+		.bits		= 3,
+	},
+	{
+		.name		= "port_tx_pri_1",
+		.shift		= 4,
+		.bits		= 3,
+	},
+	{
+		.name		= "port_tx_pri_2",
+		.shift		= 8,
+		.bits		= 3,
+	},
+	{
+		.name		= "port_tx_pri_3",
+		.shift		= 12,
+		.bits		= 3,
+	},
+	{
+		.name		= "port_tx_pri_4",
+		.shift		= 16,
+		.bits		= 3,
+	},
+	{
+		.name		= "port_tx_pri_5",
+		.shift		= 20,
+		.bits		= 3,
+	},
+	{
+		.name		= "port_tx_pri_6",
+		.shift		= 24,
+		.bits		= 3,
+	},
+	{
+		.name		= "port_tx_pri_7",
+		.shift		= 28,
+		.bits		= 3,
+	},
+};
+
+static ssize_t cpsw_port_tx_pri_map_show(struct cpswx_priv *cpsw_dev,
+		     struct cpswx_attribute *attr,
+		     char *buf)
+{
+	int idx, len = 0, total_len = 0, port;
+	struct cpswx_intf *cpsw_intf;
+	struct cpswx_slave *slave;
+	u32 reg;
+
+	port = (int)(attr->context);
+
+	for_each_intf(cpsw_intf, cpsw_dev) {
+		if (cpsw_intf->multi_if) {
+			slave = cpsw_intf->slaves;
+			if (slave->port_num != port)
+				continue;
+			reg = __raw_readl(&slave->regs->tx_pri_map);
+			len = cpsw_attr_info_show(attr->info, attr->info_size,
+						reg, buf+total_len);
+			total_len += len;
+		} else {
+			for (idx = 0; idx < cpsw_intf->num_slaves; idx++) {
+				slave = cpsw_intf->slaves + idx;
+				if (slave->port_num != port)
+					continue;
+				reg = __raw_readl(&slave->regs->tx_pri_map);
+				len = cpsw_attr_info_show(attr->info,
+					attr->info_size, reg, buf+total_len);
+				total_len += len;
+			}
+		}
+	}
+	return total_len;
+}
+
+static ssize_t cpsw_port_tx_pri_map_store(struct cpswx_priv *cpsw_dev,
+			      struct cpswx_attribute *attr,
+			      const char *buf, size_t count)
+{
+	const struct cpswx_mod_info *i;
+	struct cpswx_parse_result res;
+	struct cpswx_intf *cpsw_intf;
+	struct cpswx_slave *slave;
+	void __iomem *r = NULL;
+	int ret, idx, port;
+
+	port = (int)(attr->context);
+
+	ret = cpsw_attr_parse_set_command(cpsw_dev, attr, buf, count, &res);
+	if (ret)
+		return ret;
+
+	i = &(attr->info[res.control]);
+
+	/* Slave port */
+	for_each_intf(cpsw_intf, cpsw_dev) {
+		if (cpsw_intf->multi_if) {
+			slave = cpsw_intf->slaves;
+			if (slave->port_num == port) {
+				r = &slave->regs->tx_pri_map;
+				goto set;
+			}
+		} else
+			for (idx = 0; idx < cpsw_intf->num_slaves; idx++) {
+				slave = cpsw_intf->slaves + idx;
+				if (slave->port_num == port) {
+					r = &slave->regs->tx_pri_map;
+					goto set;
+				}
+			}
+	}
+
+	if (!r)
+		return  -ENOENT;
+
+set:
+	cpsw_info_set_reg_field(r, i, res.value);
+	return count;
+}
+
+static struct cpswx_attribute cpsw_tx_pri_1_attribute =
+	__CPSW_CTXT_ATTR(1, S_IRUGO | S_IWUSR,
+			cpsw_port_tx_pri_map_show,
+			cpsw_port_tx_pri_map_store,
+			cpsw_port_tx_pri_maps, (void *)1);
+
+static struct cpswx_attribute cpsw_tx_pri_2_attribute =
+	__CPSW_CTXT_ATTR(2, S_IRUGO | S_IWUSR,
+			cpsw_port_tx_pri_map_show,
+			cpsw_port_tx_pri_map_store,
+			cpsw_port_tx_pri_maps, (void *)2);
+
+static struct attribute *cpsw_tx_pri_default_attrs[] = {
+	&cpsw_tx_pri_1_attribute.attr,
+	&cpsw_tx_pri_2_attribute.attr,
+	NULL
+};
+
+static ssize_t cpsw_tx_pri_attr_show(struct kobject *kobj,
+			struct attribute *attr, char *buf)
+{
+	struct cpswx_attribute *attribute = to_cpswx_attr(attr);
+	struct cpswx_priv *cpsw_dev = tx_pri_to_cpswx_dev(kobj);
+
+	if (!attribute->show)
+		return -EIO;
+
+	return attribute->show(cpsw_dev, attribute, buf);
+}
+
+static ssize_t cpsw_tx_pri_attr_store(struct kobject *kobj,
+			struct attribute *attr, const char *buf, size_t count)
+{
+	struct cpswx_attribute *attribute = to_cpswx_attr(attr);
+	struct cpswx_priv *cpsw_dev = tx_pri_to_cpswx_dev(kobj);
+
+	if (!attribute->store)
+		return -EIO;
+
+	return attribute->store(cpsw_dev, attribute, buf, count);
+}
+
+static const struct sysfs_ops cpsw_tx_pri_sysfs_ops = {
+	.show = cpsw_tx_pri_attr_show,
+	.store = cpsw_tx_pri_attr_store,
+};
+
+static struct kobj_type cpsw_tx_pri_ktype = {
+	.sysfs_ops = &cpsw_tx_pri_sysfs_ops,
+	.default_attrs = cpsw_tx_pri_default_attrs,
+};
+
+static const struct cpswx_mod_info cpsw_port_vlans[] = {
+	{
+		.name		= "port_vlan_id",
+		.shift		= 0,
+		.bits		= 12,
+	},
+	{
+		.name		= "port_cfi",
+		.shift		= 12,
+		.bits		= 1,
+	},
+	{
+		.name		= "port_vlan_pri",
+		.shift		= 13,
+		.bits		= 3,
+	},
+};
+
+static ssize_t cpsw_port_vlan_show(struct cpswx_priv *cpsw_dev,
+		     struct cpswx_attribute *attr,
+		     char *buf)
+{
+	int idx, len = 0, total_len = 0, port;
+	struct cpswx_intf *cpsw_intf;
+	struct cpswx_slave *slave;
+	u32 reg;
+
+	port = (int)(attr->context);
+
+	if (port == cpsw_dev->host_port) {
+		/* Host port */
+		reg = __raw_readl(&cpsw_dev->host_port_regs->port_vlan);
+		len = cpsw_attr_info_show(attr->info, attr->info_size,
+					reg, buf);
+		return len;
+	}
+
+	/* Slave ports */
+	for_each_intf(cpsw_intf, cpsw_dev) {
+		if (cpsw_intf->multi_if) {
+			slave = cpsw_intf->slaves;
+			if (slave->port_num != port)
+				continue;
+			reg = __raw_readl(&slave->regs->port_vlan);
+			len = cpsw_attr_info_show(attr->info, attr->info_size,
+					reg, buf+total_len);
+			total_len += len;
+		} else {
+			for (idx = 0; idx < cpsw_intf->num_slaves; idx++) {
+				slave = cpsw_intf->slaves + idx;
+				if (slave->port_num != port)
+					continue;
+				reg = __raw_readl(&slave->regs->port_vlan);
+				len = cpsw_attr_info_show(attr->info,
+					attr->info_size, reg, buf+total_len);
+				total_len += len;
+			}
+		}
+	}
+	return total_len;
+}
+
+static ssize_t cpsw_port_vlan_store(struct cpswx_priv *cpsw_dev,
+			      struct cpswx_attribute *attr,
+			      const char *buf, size_t count)
+{
+	const struct cpswx_mod_info *i;
+	struct cpswx_parse_result res;
+	struct cpswx_intf *cpsw_intf;
+	struct cpswx_slave *slave;
+	void __iomem *r = NULL;
+	int ret, idx, port;
+
+	port = (int)(attr->context);
+
+	ret = cpsw_attr_parse_set_command(cpsw_dev, attr, buf, count, &res);
+	if (ret)
+		return ret;
+
+	i = &(attr->info[res.control]);
+
+	/* Host port */
+	if (port == cpsw_dev->host_port) {
+		r = &cpsw_dev->host_port_regs->port_vlan;
+		goto set;
+	}
+
+	/* Slave port */
+	for_each_intf(cpsw_intf, cpsw_dev) {
+		if (cpsw_intf->multi_if) {
+			slave = cpsw_intf->slaves;
+			if (slave->port_num == port) {
+				r = &slave->regs->port_vlan;
+				goto set;
+			}
+		} else
+			for (idx = 0; idx < cpsw_intf->num_slaves; idx++) {
+				slave = cpsw_intf->slaves + idx;
+				if (slave->port_num == port) {
+					r = &slave->regs->port_vlan;
+					goto set;
+				}
+			}
+	}
+
+	if (!r)
+		return  -ENOENT;
+
+set:
+	cpsw_info_set_reg_field(r, i, res.value);
+	return count;
+}
+
+static struct cpswx_attribute cpsw_pvlan_0_attribute =
+	__CPSW_CTXT_ATTR(0, S_IRUGO | S_IWUSR,
+			cpsw_port_vlan_show,
+			cpsw_port_vlan_store,
+			cpsw_port_vlans, (void *)0);
+
+static struct cpswx_attribute cpsw_pvlan_1_attribute =
+	__CPSW_CTXT_ATTR(1, S_IRUGO | S_IWUSR,
+			cpsw_port_vlan_show,
+			cpsw_port_vlan_store,
+			cpsw_port_vlans, (void *)1);
+
+static struct cpswx_attribute cpsw_pvlan_2_attribute =
+	__CPSW_CTXT_ATTR(2, S_IRUGO | S_IWUSR,
+			cpsw_port_vlan_show,
+			cpsw_port_vlan_store,
+			cpsw_port_vlans, (void *)2);
+
+static struct attribute *cpsw_pvlan_default_attrs[] = {
+	&cpsw_pvlan_0_attribute.attr,
+	&cpsw_pvlan_1_attribute.attr,
+	&cpsw_pvlan_2_attribute.attr,
+	NULL
+};
+
+static ssize_t cpsw_pvlan_attr_show(struct kobject *kobj,
+			struct attribute *attr, char *buf)
+{
+	struct cpswx_attribute *attribute = to_cpswx_attr(attr);
+	struct cpswx_priv *cpsw_dev = pvlan_to_cpswx_dev(kobj);
+
+	if (!attribute->show)
+		return -EIO;
+
+	return attribute->show(cpsw_dev, attribute, buf);
+}
+
+static ssize_t cpsw_pvlan_attr_store(struct kobject *kobj,
+			struct attribute *attr, const char *buf, size_t count)
+{
+	struct cpswx_attribute *attribute = to_cpswx_attr(attr);
+	struct cpswx_priv *cpsw_dev = pvlan_to_cpswx_dev(kobj);
+
+	if (!attribute->store)
+		return -EIO;
+
+	return attribute->store(cpsw_dev, attribute, buf, count);
+}
+
+static const struct sysfs_ops cpsw_pvlan_sysfs_ops = {
+	.show = cpsw_pvlan_attr_show,
+	.store = cpsw_pvlan_attr_store,
+};
+
+static struct kobj_type cpsw_pvlan_ktype = {
+	.sysfs_ops = &cpsw_pvlan_sysfs_ops,
+	.default_attrs = cpsw_pvlan_default_attrs,
+};
+
+static void cpsw_reset_mod_stats(struct cpswx_priv *cpsw_dev, int stat_mod)
+{
+	struct cpswx_host_hw_stats __iomem *cpsw_stats0;
+	struct cpswx_hw_stats __iomem *cpsw_statsa;
+	struct cpswx_hw_stats __iomem *cpsw_statsb;
+	void *p = NULL;
+	int i;
+
+	cpsw_stats0 = cpsw_dev->host_hw_stats_regs;
+	cpsw_statsa = cpsw_dev->hw_stats_regs[0];
+	cpsw_statsb = cpsw_dev->hw_stats_regs[1];
+
+	switch (stat_mod) {
+	case CPSW_STATS0_MODULE:
+		p = cpsw_stats0;
+		break;
+	case CPSW_STATS1_MODULE:
+		p = cpsw_statsa;
+		break;
+	case CPSW_STATS2_MODULE:
+		p  = cpsw_statsb;
+		break;
+	}
+
+	for (i = 0; i < ETHTOOL_STATS_NUM; i++) {
+		if (et_stats[i].type == stat_mod) {
+			cpsw_dev->hw_stats[i] = 0;
+			p = (u8 *)p + et_stats[i].offset;
+			*(u32 *)p = 0xffffffff;
+		}
+	}
+	return;
+}
+
+static ssize_t cpsw_stats_mod_store(struct cpswx_priv *cpsw_dev,
+			      struct cpswx_attribute *attr,
+			      const char *buf, size_t count)
+{
+	unsigned long end;
+	int stat_mod;
+
+	if (kstrtoul(buf, 0, &end) != 0 || (end != 0))
+		return -EINVAL;
+
+	stat_mod = (int)(attr->context);
+	mutex_lock(&cpsw_dev->hw_stats_lock);
+	cpsw_reset_mod_stats(cpsw_dev, stat_mod);
+	mutex_unlock(&cpsw_dev->hw_stats_lock);
+	return count;
+}
+
+static struct cpswx_attribute cpsw_stats_0_attribute =
+	__CPSW_ATTR_FULL(0, S_IWUSR, NULL, cpsw_stats_mod_store,
+			NULL, 0, (void *)CPSW_STATS0_MODULE);
+
+static struct cpswx_attribute cpsw_stats_1_attribute =
+	__CPSW_ATTR_FULL(1, S_IWUSR, NULL, cpsw_stats_mod_store,
+			NULL, 0, (void *)CPSW_STATS1_MODULE);
+
+static struct cpswx_attribute cpsw_stats_2_attribute =
+	__CPSW_ATTR_FULL(2, S_IWUSR, NULL, cpsw_stats_mod_store,
+			NULL, 0, (void *)CPSW_STATS2_MODULE);
+
+static struct attribute *cpsw_stats_default_attrs[] = {
+	&cpsw_stats_0_attribute.attr,
+	&cpsw_stats_1_attribute.attr,
+	&cpsw_stats_2_attribute.attr,
+	NULL
+};
+
+static ssize_t cpsw_stats_attr_store(struct kobject *kobj,
+			struct attribute *attr, const char *buf, size_t count)
+{
+	struct cpswx_attribute *attribute = to_cpswx_attr(attr);
+	struct cpswx_priv *cpsw_dev = stats_to_cpswx_dev(kobj);
+
+	if (!attribute->store)
+		return -EIO;
+
+	return attribute->store(cpsw_dev, attribute, buf, count);
+}
+
+static const struct sysfs_ops cpsw_stats_sysfs_ops = {
+	.store = cpsw_stats_attr_store,
+};
+
+static struct kobj_type cpsw_stats_ktype = {
+	.sysfs_ops = &cpsw_stats_sysfs_ops,
+	.default_attrs = cpsw_stats_default_attrs,
+};
+static struct attribute *cpsw_default_attrs[] = {
+	&cpsw_version_attribute.attr,
+	&cpsw_control_attribute.attr,
+	&cpsw_pri_type_attribute.attr,
+	&cpsw_flow_control_attribute.attr,
+	NULL
+};
+
+static ssize_t cpsw_attr_show(struct kobject *kobj, struct attribute *attr,
+				  char *buf)
+{
+	struct cpswx_attribute *attribute = to_cpswx_attr(attr);
+	struct cpswx_priv *cpsw_dev = to_cpswx_dev(kobj);
+
+	if (!attribute->show)
+		return -EIO;
+
+	return attribute->show(cpsw_dev, attribute, buf);
+}
+
+static ssize_t cpsw_attr_store(struct kobject *kobj, struct attribute *attr,
+				   const char *buf, size_t count)
+{
+	struct cpswx_attribute *attribute = to_cpswx_attr(attr);
+	struct cpswx_priv *cpsw_dev = to_cpswx_dev(kobj);
+
+	if (!attribute->store)
+		return -EIO;
+
+	return attribute->store(cpsw_dev, attribute, buf, count);
+}
+
+static const struct sysfs_ops cpsw_sysfs_ops = {
+	.show = cpsw_attr_show,
+	.store = cpsw_attr_store,
+};
+
+static struct kobj_type cpsw_ktype = {
+	.sysfs_ops = &cpsw_sysfs_ops,
+	.default_attrs = cpsw_default_attrs,
+};
+
+static void keystone_get_drvinfo(struct net_device *ndev,
+			     struct ethtool_drvinfo *info)
+{
+	strncpy(info->driver, NETCP_DRIVER_NAME, sizeof(info->driver));
+	strncpy(info->version, NETCP_DRIVER_VERSION, sizeof(info->version));
+}
+
+static u32 keystone_get_msglevel(struct net_device *ndev)
+{
+	struct netcp_priv *netcp = netdev_priv(ndev);
+	return netcp->msg_enable;
+}
+
+static void keystone_set_msglevel(struct net_device *ndev, u32 value)
+{
+	struct netcp_priv *netcp = netdev_priv(ndev);
+	netcp->msg_enable = value;
+}
+
+static void keystone_get_stat_strings(struct net_device *ndev,
+				   uint32_t stringset, uint8_t *data)
+{
+	int i;
+
+	switch (stringset) {
+	case ETH_SS_STATS:
+		for (i = 0; i < ETHTOOL_STATS_NUM; i++) {
+			memcpy(data, et_stats[i].desc, ETH_GSTRING_LEN);
+			data += ETH_GSTRING_LEN;
+		}
+		break;
+	case ETH_SS_TEST:
+		break;
+	}
+}
+
+static int keystone_get_sset_count(struct net_device *ndev, int stringset)
+{
+	switch (stringset) {
+	case ETH_SS_TEST:
+		return 0;
+	case ETH_SS_STATS:
+		return ETHTOOL_STATS_NUM;
+	default:
+		return -EINVAL;
+	}
+}
+
+static void cpswx_update_stats(struct cpswx_priv *cpsw_dev, uint64_t *data)
+{
+	struct cpswx_host_hw_stats __iomem *cpsw_stats0;
+	struct cpswx_hw_stats __iomem *cpsw_statsa;
+	struct cpswx_hw_stats __iomem *cpsw_statsb;
+	void *p = NULL;
+	u32 tmp = 0;
+	int i;
+
+	cpsw_stats0 = cpsw_dev->host_hw_stats_regs;
+	cpsw_statsa = cpsw_dev->hw_stats_regs[0];
+	cpsw_statsb = cpsw_dev->hw_stats_regs[1];
+
+	for (i = 0; i < ETHTOOL_STATS_NUM; i++) {
+		switch (et_stats[i].type) {
+		case CPSW_STATS0_MODULE:
+			p = cpsw_stats0;
+			break;
+		case CPSW_STATS1_MODULE:
+			p = cpsw_statsa;
+			break;
+		case CPSW_STATS2_MODULE:
+			p  = cpsw_statsb;
+			break;
+		}
+
+		p = (u8 *)p + et_stats[i].offset;
+		tmp = *(u32 *)p;
+		cpsw_dev->hw_stats[i] = cpsw_dev->hw_stats[i] + tmp;
+		if (data)
+			data[i] = cpsw_dev->hw_stats[i];
+		*(u32 *)p = tmp;
+	}
+
+	return;
+}
+
+static void keystone_get_ethtool_stats(struct net_device *ndev,
+				       struct ethtool_stats *stats,
+				       uint64_t *data)
+{
+	struct netcp_priv *netcp = netdev_priv(ndev);
+	struct netcp_device *netcp_device = netcp->netcp_device;
+	struct cpswx_priv *priv;
+
+	/* find the instance of the module registered to the netcp_device */
+	priv = (struct cpswx_priv *)netcp_device_find_module(netcp_device,
+							CPSW_MODULE_NAME);
+	if (priv) {
+		mutex_lock(&priv->hw_stats_lock);
+		cpswx_update_stats(priv, data);
+		mutex_unlock(&priv->hw_stats_lock);
+	}
+
+	return;
+}
+
+static int keystone_get_settings(struct net_device *ndev,
+			      struct ethtool_cmd *cmd)
+{
+	struct phy_device *phy = ndev->phydev;
+	struct cpswx_slave *slave;
+	int ret;
+
+	if (!phy)
+		return -EINVAL;
+
+	slave = (struct cpswx_slave *)phy->context;
+	if (!slave)
+		return -EINVAL;
+
+	ret = phy_ethtool_gset(phy, cmd);
+	if (!ret)
+		cmd->port = slave->phy_port_t;
+
+	return ret;
+}
+
+static int keystone_set_settings(struct net_device *ndev,
+				struct ethtool_cmd *cmd)
+{
+	struct phy_device *phy = ndev->phydev;
+	struct cpswx_slave *slave;
+	u32 features = cmd->advertising & cmd->supported;
+
+	if (!phy)
+		return -EINVAL;
+
+	slave = (struct cpswx_slave *)phy->context;
+	if (!slave)
+		return -EINVAL;
+
+	if (cmd->port != slave->phy_port_t) {
+		if ((cmd->port == PORT_TP) && !(features & ADVERTISED_TP))
+			return -EINVAL;
+
+		if ((cmd->port == PORT_AUI) && !(features & ADVERTISED_AUI))
+			return -EINVAL;
+
+		if ((cmd->port == PORT_BNC) && !(features & ADVERTISED_BNC))
+			return -EINVAL;
+
+		if ((cmd->port == PORT_MII) && !(features & ADVERTISED_MII))
+			return -EINVAL;
+
+		if ((cmd->port == PORT_FIBRE) && !(features & ADVERTISED_FIBRE))
+			return -EINVAL;
+	}
+
+	slave->phy_port_t = cmd->port;
+
+	return phy_ethtool_sset(phy, cmd);
+}
+
+static const struct ethtool_ops keystone_ethtool_ops = {
+	.get_drvinfo		= keystone_get_drvinfo,
+	.get_link		= ethtool_op_get_link,
+	.get_msglevel		= keystone_get_msglevel,
+	.set_msglevel		= keystone_set_msglevel,
+	.get_strings		= keystone_get_stat_strings,
+	.get_sset_count		= keystone_get_sset_count,
+	.get_ethtool_stats	= keystone_get_ethtool_stats,
+	.get_settings		= keystone_get_settings,
+	.set_settings		= keystone_set_settings,
+};
+
+#define mac_hi(mac)	(((mac)[0] << 0) | ((mac)[1] << 8) |	\
+			 ((mac)[2] << 16) | ((mac)[3] << 24))
+#define mac_lo(mac)	(((mac)[4] << 0) | ((mac)[5] << 8))
+
+static void cpsw_set_slave_mac(struct cpswx_slave *slave,
+			       struct cpswx_intf *cpsw_intf)
+{
+	struct net_device *ndev = cpsw_intf->ndev;
+
+	__raw_writel(mac_hi(ndev->dev_addr), &slave->regs->sa_hi);
+	__raw_writel(mac_lo(ndev->dev_addr), &slave->regs->sa_lo);
+}
+
+static inline int cpsw_get_slave_port(struct cpswx_priv *priv, u32 slave_num)
+{
+	if (priv->host_port == 0)
+		return slave_num + 1;
+	else
+		return slave_num;
+}
+
+static void _cpsw_adjust_link(struct cpswx_slave *slave, bool *link)
+{
+	struct phy_device *phy = slave->phy;
+	u32 mac_control = 0;
+	u32 slave_port;
+
+	if (!phy)
+		return;
+
+	slave_port = slave->port_num;
+
+	if (phy->link) {
+		mac_control = slave->mac_control;
+		mac_control |= MACSL_SIG_ENABLE(slave) |
+				MACSL_RX_ENABLE_EXT_CTL |
+				MACSL_RX_ENABLE_CSF;
+		/* enable forwarding */
+		cpsw_ale_control_set(slave->ale, slave_port,
+				     ALE_PORT_STATE, ALE_PORT_STATE_FORWARD);
+
+		if (phy->duplex)
+			mac_control |= BIT(0);	/* FULLDUPLEXEN	*/
+		else
+			mac_control &= ~0x1;
+
+		*link = true;
+	} else {
+		mac_control = 0;
+		/* disable forwarding */
+		cpsw_ale_control_set(slave->ale, slave_port,
+				     ALE_PORT_STATE, ALE_PORT_STATE_DISABLE);
+	}
+
+	if (mac_control != slave->mac_control) {
+		phy_print_status(phy);
+		__raw_writel(mac_control, &slave->sliver->mac_control);
+	}
+
+	slave->mac_control = mac_control;
+}
+
+static void cpsw_adjust_link(struct net_device *n_dev, void *context)
+{
+	struct cpswx_slave *slave = (struct cpswx_slave *)context;
+	struct netcp_priv *netcp = netdev_priv(n_dev);
+	bool link = false;
+
+	_cpsw_adjust_link(slave, &link);
+
+	if (link)
+		netcp->link_state |= BIT(slave->slave_num);
+	else
+		netcp->link_state &= ~BIT(slave->slave_num);
+}
+
+/*
+ * Reset the the mac sliver
+ * Soft reset is set and polled until clear, or until a timeout occurs
+ */
+static int cpsw_port_reset(struct cpswx_slave *slave)
+{
+	u32 i, v;
+
+	/* Set the soft reset bit */
+	__raw_writel(SOFT_RESET,
+		     &slave->sliver->soft_reset);
+
+	/* Wait for the bit to clear */
+	for (i = 0; i < DEVICE_EMACSL_RESET_POLL_COUNT; i++) {
+		v = __raw_readl(&slave->sliver->soft_reset);
+		if ((v & SOFT_RESET_MASK) !=
+		    SOFT_RESET)
+			return 0;
+	}
+
+	/* Timeout on the reset */
+	return GMACSL_RET_WARN_RESET_INCOMPLETE;
+}
+
+/*
+ * Configure the mac sliver
+ */
+static void cpsw_port_config(struct cpswx_slave *slave, int max_rx_len)
+{
+	u32 mac_control;
+
+	if (max_rx_len > MAX_SIZE_STREAM_BUFFER)
+		max_rx_len = MAX_SIZE_STREAM_BUFFER;
+
+	__raw_writel(max_rx_len, &slave->sliver->rx_maxlen);
+
+	mac_control = (MACSL_SIG_ENABLE(slave) |
+			MACSL_RX_ENABLE_EXT_CTL |
+			MACSL_RX_ENABLE_CSF);
+	__raw_writel(mac_control, &slave->sliver->mac_control);
+}
+
+static void cpsw_slave_stop(struct cpswx_slave *slave, struct cpswx_priv *priv)
+{
+	cpsw_port_reset(slave);
+
+	if (!slave->phy)
+		return;
+
+	phy_stop(slave->phy);
+	phy_disconnect(slave->phy);
+	slave->phy = NULL;
+}
+
+static void cpsw_slave_link(struct cpswx_slave *slave,
+			    struct cpswx_intf *cpsw_intf)
+{
+	struct netcp_priv *netcp = netdev_priv(cpsw_intf->ndev);
+
+	if ((slave->link_interface == SGMII_LINK_MAC_PHY) ||
+		(slave->link_interface == XGMII_LINK_MAC_PHY)) {
+		if (netcp->link_state)
+			cpsw_intf->sgmii_link |= BIT(slave->slave_num);
+		else
+			cpsw_intf->sgmii_link &= ~BIT(slave->slave_num);
+	} else if (slave->link_interface == XGMII_LINK_MAC_MAC_FORCED)
+		cpsw_intf->sgmii_link |= BIT(slave->slave_num);
+}
+
+static void cpsw_slave_open(struct cpswx_slave *slave,
+			    struct cpswx_intf *cpsw_intf)
+{
+	struct cpswx_priv *priv = cpsw_intf->cpsw_priv;
+	char name[32];		/* FIXME: Unused variable */
+	u32 slave_port;
+	int has_phy = 0;
+	phy_interface_t phy_mode;
+
+	snprintf(name, sizeof(name), "slave-%d", slave->slave_num);
+
+	if (!SLAVE_LINK_IS_XGMII(slave)) {
+		keystone_sgmii_reset(priv->sgmii_port_regs, slave->slave_num);
+
+		keystone_sgmii_config(priv->sgmii_port_regs, slave->slave_num,
+				slave->link_interface);
+	} else
+		keystone_pcsr_config(priv->pcsr_port_regs, slave->slave_num,
+				slave->link_interface);
+
+	cpsw_port_reset(slave);
+
+	cpsw_port_config(slave, priv->rx_packet_max);
+
+	cpsw_set_slave_mac(slave, cpsw_intf);
+
+	slave->mac_control = MACSL_SIG_ENABLE(slave) | MACSL_RX_ENABLE_EXT_CTL |
+				MACSL_RX_ENABLE_CSF;
+
+	slave_port = cpsw_get_slave_port(priv, slave->slave_num);
+
+	slave->port_num = slave_port;
+	slave->ale = priv->ale;
+
+	/* enable forwarding */
+	cpsw_ale_control_set(priv->ale, slave_port,
+			     ALE_PORT_STATE, ALE_PORT_STATE_FORWARD);
+
+	cpsw_ale_add_mcast(priv->ale, cpsw_intf->ndev->broadcast,
+			   1 << slave_port, 0, ALE_MCAST_FWD_2,
+			   CPSW_NON_VLAN_ADDR);
+
+	if (slave->link_interface == SGMII_LINK_MAC_PHY) {
+		has_phy = 1;
+		phy_mode = PHY_INTERFACE_MODE_SGMII;
+		slave->phy_port_t = PORT_MII;
+	} else if (slave->link_interface == XGMII_LINK_MAC_PHY) {
+		has_phy = 1;
+		/* +++FIXME: PHY_INTERFACE_MODE_XGMII ?? */
+		phy_mode = PHY_INTERFACE_MODE_NA;
+		slave->phy_port_t = PORT_FIBRE;
+	}
+
+	if (has_phy) {
+		slave->phy = of_phy_connect(cpsw_intf->ndev,
+					    cpsw_intf->phy_node,
+					    &cpsw_adjust_link, 0,
+					    phy_mode,
+					    slave);
+		if (IS_ERR_OR_NULL(slave->phy)) {
+			dev_err(priv->dev, "phy not found on slave %d\n",
+				slave->slave_num);
+			slave->phy = NULL;
+		} else {
+			dev_info(priv->dev, "phy found: id is: 0x%s\n",
+				 dev_name(&slave->phy->dev));
+			cpsw_intf->ndev->phydev = slave->phy;
+			phy_start(slave->phy);
+		}
+	}
+}
+
+static void cpsw_init_host_port(struct cpswx_priv *priv,
+				struct cpswx_intf *cpsw_intf)
+{
+	/* Max length register */
+	__raw_writel(MAX_SIZE_STREAM_BUFFER,
+		     &priv->host_port_regs->rx_maxlen);
+
+	if (priv->ale_refcnt == 1)
+		cpsw_ale_start(priv->ale);
+
+	if (priv->multi_if)
+		cpsw_ale_control_set(priv->ale, 0, ALE_BYPASS, 1);
+
+	cpsw_ale_control_set(priv->ale, 0, ALE_NO_PORT_VLAN, 1);
+
+	cpsw_ale_control_set(priv->ale, priv->host_port,
+			     ALE_PORT_STATE, ALE_PORT_STATE_FORWARD);
+
+	cpsw_ale_control_set(priv->ale, 0,
+			     ALE_PORT_UNKNOWN_VLAN_MEMBER,
+			     CPSW_MASK_ALL_PORTS);
+
+	cpsw_ale_control_set(priv->ale, 0,
+			     ALE_PORT_UNKNOWN_MCAST_FLOOD,
+			     CPSW_MASK_PHYS_PORTS);
+
+	cpsw_ale_control_set(priv->ale, 0,
+			     ALE_PORT_UNKNOWN_REG_MCAST_FLOOD,
+			     CPSW_MASK_ALL_PORTS);
+
+	cpsw_ale_control_set(priv->ale, 0,
+			     ALE_PORT_UNTAGGED_EGRESS,
+			     CPSW_MASK_ALL_PORTS);
+}
+
+static void cpsw_slave_init(struct cpswx_slave *slave, struct cpswx_priv *priv)
+{
+	void __iomem		*regs = priv->ss_regs;
+	int			slave_num = slave->slave_num;
+
+	slave->regs	= regs + priv->slave_reg_ofs + (0x30 * slave_num);
+	slave->sliver	= regs + priv->sliver_reg_ofs + (0x40 * slave_num);
+}
+
+static void cpsw_add_mcast_addr(struct cpswx_intf *cpsw_intf, u8 *addr)
+{
+	struct cpswx_priv *cpsw_dev = cpsw_intf->cpsw_priv;
+	u16 vlan_id;
+
+	cpsw_ale_add_mcast(cpsw_dev->ale, addr, CPSW_MASK_ALL_PORTS, 0,
+			   ALE_MCAST_FWD_2, -1);
+	for_each_set_bit(vlan_id, cpsw_intf->active_vlans, VLAN_N_VID) {
+		cpsw_ale_add_mcast(cpsw_dev->ale, addr, CPSW_MASK_ALL_PORTS, 0,
+				   ALE_MCAST_FWD_2, vlan_id);
+	}
+}
+
+static void cpsw_add_ucast_addr(struct cpswx_intf *cpsw_intf, u8 *addr)
+{
+	struct cpswx_priv *cpsw_dev = cpsw_intf->cpsw_priv;
+	u16 vlan_id;
+
+	cpsw_ale_add_ucast(cpsw_dev->ale, addr, cpsw_dev->host_port, 0, -1);
+
+	for_each_set_bit(vlan_id, cpsw_intf->active_vlans, VLAN_N_VID)
+		cpsw_ale_add_ucast(cpsw_dev->ale, addr, cpsw_dev->host_port, 0,
+				   vlan_id);
+}
+
+static void cpsw_del_mcast_addr(struct cpswx_intf *cpsw_intf, u8 *addr)
+{
+	struct cpswx_priv *cpsw_dev = cpsw_intf->cpsw_priv;
+	u16 vlan_id;
+
+	cpsw_ale_del_mcast(cpsw_dev->ale, addr, CPSW_MASK_ALL_PORTS, -1);
+
+	for_each_set_bit(vlan_id, cpsw_intf->active_vlans, VLAN_N_VID) {
+		cpsw_ale_del_mcast(cpsw_dev->ale, addr, CPSW_MASK_ALL_PORTS,
+				   vlan_id);
+	}
+}
+
+static void cpsw_del_ucast_addr(struct cpswx_intf *cpsw_intf, u8 *addr)
+{
+	struct cpswx_priv *cpsw_dev = cpsw_intf->cpsw_priv;
+	u16 vlan_id;
+
+	cpsw_ale_del_ucast(cpsw_dev->ale, addr, cpsw_dev->host_port, -1);
+
+	for_each_set_bit(vlan_id, cpsw_intf->active_vlans, VLAN_N_VID) {
+		cpsw_ale_del_ucast(cpsw_dev->ale, addr, cpsw_dev->host_port,
+				   vlan_id);
+	}
+}
+
+static int cpswx_add_addr(void *intf_priv, struct netcp_addr *naddr)
+{
+	struct cpswx_intf *cpsw_intf = intf_priv;
+	struct cpswx_priv *cpsw_dev = cpsw_intf->cpsw_priv;
+
+	dev_dbg(cpsw_dev->dev, "xgess adding address %pM, type %d\n",
+		naddr->addr, naddr->type);
+
+	switch (naddr->type) {
+	case ADDR_MCAST:
+	case ADDR_BCAST:
+		cpsw_add_mcast_addr(cpsw_intf, naddr->addr);
+		break;
+	case ADDR_UCAST:
+	case ADDR_DEV:
+		cpsw_add_ucast_addr(cpsw_intf, naddr->addr);
+		break;
+	case ADDR_ANY:
+		/* nothing to do for promiscuous */
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int cpswx_del_addr(void *intf_priv, struct netcp_addr *naddr)
+{
+	struct cpswx_intf *cpsw_intf = intf_priv;
+	struct cpswx_priv *cpsw_dev = cpsw_intf->cpsw_priv;
+
+	dev_dbg(cpsw_dev->dev, "xgess deleting address %pM, type %d\n",
+		naddr->addr, naddr->type);
+
+	switch (naddr->type) {
+	case ADDR_MCAST:
+	case ADDR_BCAST:
+		cpsw_del_mcast_addr(cpsw_intf, naddr->addr);
+		break;
+	case ADDR_UCAST:
+	case ADDR_DEV:
+		cpsw_del_ucast_addr(cpsw_intf, naddr->addr);
+		break;
+	case ADDR_ANY:
+		/* nothing to do for promiscuous */
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int cpswx_add_vid(void *intf_priv, int vid)
+{
+	struct cpswx_intf *cpsw_intf = intf_priv;
+	struct cpswx_priv *cpsw_dev = cpsw_intf->cpsw_priv;
+
+	set_bit(vid, cpsw_intf->active_vlans);
+
+	cpsw_ale_add_vlan(cpsw_dev->ale, vid, CPSW_MASK_ALL_PORTS,
+			  CPSW_MASK_ALL_PORTS, CPSW_MASK_PHYS_PORTS,
+			  CPSW_MASK_NO_PORTS);
+
+	return 0;
+}
+
+static int cpswx_del_vid(void *intf_priv, int vid)
+{
+	struct cpswx_intf *cpsw_intf = intf_priv;
+	struct cpswx_priv *cpsw_dev = cpsw_intf->cpsw_priv;
+
+	cpsw_ale_del_vlan(cpsw_dev->ale, vid);
+
+	clear_bit(vid, cpsw_intf->active_vlans);
+
+	return 0;
+}
+
+static int cpswx_ioctl(void *intf_priv, struct ifreq *req, int cmd)
+{
+	struct cpswx_intf *cpsw_intf = intf_priv;
+	struct cpswx_slave *slave = cpsw_intf->slaves;
+	struct phy_device *phy = slave->phy;
+	int ret;
+
+	if (!phy)
+		return -EOPNOTSUPP;
+
+	ret = phy_mii_ioctl(phy, req, cmd);
+	if ((cmd == SIOCSHWTSTAMP) && (ret == -ERANGE))
+		ret = -EOPNOTSUPP;
+
+	return ret;
+}
+
+static void cpswx_timer(unsigned long arg)
+{
+	struct cpswx_intf *cpsw_intf = (struct cpswx_intf *)arg;
+	struct cpswx_priv *cpsw_dev = cpsw_intf->cpsw_priv;
+
+	/*
+	 * if the slave's link_interface is not XGMII, sgmii_link bit
+	 * will not be set
+	 */
+	if (cpsw_dev->multi_if)
+		cpsw_intf->sgmii_link =
+			keystone_sgmii_get_port_link(cpsw_dev->sgmii_port_regs,
+						     cpsw_intf->slave_port);
+	else
+		cpsw_intf->sgmii_link =
+			keystone_sgmii_link_status(cpsw_dev->sgmii_port_regs,
+						   cpsw_intf->num_slaves);
+
+	for_each_slave(cpsw_intf, cpsw_slave_link, cpsw_intf);
+
+	/* FIXME: Don't aggregate link statuses in multi-interface case */
+	if (cpsw_intf->sgmii_link) {
+		/* link ON */
+		if (!netif_carrier_ok(cpsw_intf->ndev))
+			netif_carrier_on(cpsw_intf->ndev);
+		/*
+		 * reactivate the transmit queue if
+		 * it is stopped
+		 */
+		if (netif_running(cpsw_intf->ndev) &&
+		    netif_queue_stopped(cpsw_intf->ndev))
+			netif_wake_queue(cpsw_intf->ndev);
+	} else {
+		/* link OFF */
+		if (netif_carrier_ok(cpsw_intf->ndev))
+			netif_carrier_off(cpsw_intf->ndev);
+		if (!netif_queue_stopped(cpsw_intf->ndev))
+			netif_stop_queue(cpsw_intf->ndev);
+	}
+
+	mutex_lock(&cpsw_dev->hw_stats_lock);
+	cpswx_update_stats(cpsw_dev, NULL);
+	mutex_unlock(&cpsw_dev->hw_stats_lock);
+
+	cpsw_intf->timer.expires = jiffies + (HZ/10);
+	add_timer(&cpsw_intf->timer);
+
+	return;
+}
+
+static int cpsw_tx_hook(int order, void *data, struct netcp_packet *p_info)
+{
+	struct cpswx_intf *cpsw_intf = data;
+
+	p_info->tx_pipe = &cpsw_intf->tx_pipe;
+	return 0;
+}
+
+#define	CPSW_TXHOOK_ORDER	0
+
+static int cpswx_open(void *intf_mod_priv, struct net_device *ndev)
+{
+	struct cpswx_intf *cpsw_intf = intf_mod_priv;
+	struct cpswx_priv *cpsw_dev = cpsw_intf->cpsw_priv;
+	struct netcp_priv *netcp = netdev_priv(ndev);
+	struct cpsw_ale_params ale_params;
+	u32 xgmii_mode = 0;
+	int ret = 0;
+	u32 reg, i;
+
+	cpsw_dev->clk = clk_get(cpsw_dev->dev, "clk_xge");
+	if (IS_ERR(cpsw_dev->clk)) {
+		ret = PTR_ERR(cpsw_dev->clk);
+		cpsw_dev->clk = NULL;
+		dev_err(cpsw_dev->dev,
+			"unable to get Keystone XGE clock: %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(cpsw_dev->clk);
+	if (ret)
+		goto clk_fail;
+
+	reg = __raw_readl(&cpsw_dev->regs->id_ver);
+
+	dev_info(cpsw_dev->dev,
+	 "initialize cpsw version %d.%d (%d) CPSW identification value 0x%x\n",
+	 CPSW_MAJOR_VERSION(reg), CPSW_MINOR_VERSION(reg),
+	 CPSW_RTL_VERSION(reg), CPSW_IDENT(reg));
+
+	ret = netcp_txpipe_open(&cpsw_intf->tx_pipe);
+	if (ret)
+		goto txpipe_fail;
+
+	dev_dbg(cpsw_dev->dev, "opened TX channel %s: %p with psflags %d\n",
+		cpsw_intf->tx_pipe.dma_chan_name,
+		cpsw_intf->tx_pipe.dma_channel,
+		cpsw_intf->tx_pipe.dma_psflags);
+
+	cpsw_dev->ale_refcnt++;
+	if (cpsw_dev->ale_refcnt == 1) {
+		memset(&ale_params, 0, sizeof(ale_params));
+
+		ale_params.dev		= cpsw_dev->dev;
+		ale_params.ale_regs	= (void *)((u32)cpsw_dev->ale_reg);
+		ale_params.ale_ageout	= cpsw_dev->ale_ageout;
+		ale_params.ale_entries	= cpsw_dev->ale_entries;
+		ale_params.ale_ports	= cpsw_dev->ale_ports;
+
+		cpsw_dev->ale = cpsw_ale_create(&ale_params);
+		if (!cpsw_dev->ale) {
+			dev_err(cpsw_dev->dev, "error initializing ale engine\n");
+			ret = -ENODEV;
+			goto ale_fail;
+		} else
+			dev_info(cpsw_dev->dev, "Created a cpsw ale engine\n");
+	}
+
+	for_each_slave(cpsw_intf, cpsw_slave_init, cpsw_dev);
+
+	for_each_slave(cpsw_intf, cpsw_slave_stop, cpsw_dev);
+
+	/* Enable correct MII mode at SS level */
+	for (i = 0; i < cpsw_dev->num_slaves; i++)
+		if (cpsw_dev->link[i] >= XGMII_LINK_MAC_PHY)
+			xgmii_mode |= (1 << i);
+	__raw_writel(xgmii_mode, &cpsw_dev->ss_regs->control);
+
+	/* initialize host and slave ports */
+	cpsw_init_host_port(cpsw_dev, cpsw_intf);
+
+	/* disable priority elevation and enable statistics on all ports */
+	__raw_writel(0, &cpsw_dev->regs->ptype);
+
+	/* Control register */
+	__raw_writel(CPSW_CTL_P0_ENABLE, &cpsw_dev->regs->control);
+
+	/* All statistics enabled by default */
+	__raw_writel(CPSW_REG_VAL_STAT_ENABLE_ALL,
+		     &cpsw_dev->regs->stat_port_en);
+
+	for_each_slave(cpsw_intf, cpsw_slave_open, cpsw_intf);
+
+	init_timer(&cpsw_intf->timer);
+	cpsw_intf->timer.data		= (unsigned long)cpsw_intf;
+	cpsw_intf->timer.function	= cpswx_timer;
+	cpsw_intf->timer.expires	= jiffies + CPSW_TIMER_INTERVAL;
+	add_timer(&cpsw_intf->timer);
+	dev_dbg(cpsw_dev->dev,
+		"%s(): cpswx_timer = %p\n", __func__, cpswx_timer);
+
+	netcp_register_txhook(netcp, CPSW_TXHOOK_ORDER,
+			      cpsw_tx_hook, cpsw_intf);
+
+#if 0
+	/* Configure the streaming switch */
+#define	PSTREAM_ROUTE_DMA	6
+	netcp_set_streaming_switch(cpsw_dev->netcp_device, netcp->cpsw_port,
+				   PSTREAM_ROUTE_DMA);
+#endif
+
+	return 0;
+
+ale_fail:
+	netcp_txpipe_close(&cpsw_intf->tx_pipe);
+txpipe_fail:
+	clk_disable_unprepare(cpsw_dev->clk);
+clk_fail:
+	clk_put(cpsw_dev->clk);
+	cpsw_dev->clk = NULL;
+	return ret;
+}
+
+static int cpswx_close(void *intf_modpriv, struct net_device *ndev)
+{
+	struct cpswx_intf *cpsw_intf = intf_modpriv;
+	struct cpswx_priv *cpsw_dev = cpsw_intf->cpsw_priv;
+	struct netcp_priv *netcp = netdev_priv(ndev);
+
+	del_timer_sync(&cpsw_intf->timer);
+
+	cpsw_dev->ale_refcnt--;
+	if (!cpsw_dev->ale_refcnt)
+		cpsw_ale_stop(cpsw_dev->ale);
+
+	for_each_slave(cpsw_intf, cpsw_slave_stop, cpsw_dev);
+
+	if (!cpsw_dev->ale_refcnt)
+		cpsw_ale_destroy(cpsw_dev->ale);
+
+	netcp_unregister_txhook(netcp, CPSW_TXHOOK_ORDER, cpsw_tx_hook,
+				cpsw_intf);
+	netcp_txpipe_close(&cpsw_intf->tx_pipe);
+
+	clk_disable_unprepare(cpsw_dev->clk);
+	clk_put(cpsw_dev->clk);
+
+	return 0;
+}
+
+static int cpswx_remove(struct netcp_device *netcp_device, void *inst_priv)
+{
+	struct cpswx_priv *cpsw_dev = inst_priv;
+	struct cpswx_intf *cpsw_intf, *tmp;
+
+	of_node_put(cpsw_dev->interfaces);
+
+	list_for_each_entry_safe(cpsw_intf, tmp, &cpsw_dev->cpsw_intf_head,
+				 cpsw_intf_list) {
+		netcp_delete_interface(netcp_device, cpsw_intf->ndev);
+	}
+	BUG_ON(!list_empty(&cpsw_dev->cpsw_intf_head));
+
+	iounmap(cpsw_dev->ss_regs);
+	memset(cpsw_dev, 0x00, sizeof(*cpsw_dev));	/* FIXME: Poison */
+	kfree(cpsw_dev);
+	return 0;
+}
+
+static int init_slave(struct cpswx_priv *cpsw_dev,
+		      struct device_node *node, int slave_num)
+{
+	int ret = 0;
+
+	ret = of_property_read_u32(node, "link-interface",
+				   &cpsw_dev->link[slave_num]);
+	if (ret < 0) {
+		dev_err(cpsw_dev->dev,
+			"missing link-interface value"
+			"defaulting to mac-phy link\n");
+		cpsw_dev->link[slave_num] = XGMII_LINK_MAC_PHY;
+	}
+
+	cpsw_dev->phy_node[slave_num] = of_parse_phandle(node, "phy-handle", 0);
+
+	return 0;
+}
+
+static int cpsw_create_sysfs_entries(struct cpswx_priv *cpsw_dev)
+{
+	struct device *dev = cpsw_dev->dev;
+	int ret;
+
+	ret = kobject_init_and_add(&cpsw_dev->kobj, &cpsw_ktype,
+		kobject_get(&dev->kobj), "cpsw");
+
+	if (ret) {
+		dev_err(dev, "failed to create cpsw sysfs entry\n");
+		kobject_put(&cpsw_dev->kobj);
+		kobject_put(&dev->kobj);
+		return ret;
+	}
+
+	ret = kobject_init_and_add(&cpsw_dev->tx_pri_kobj,
+		&cpsw_tx_pri_ktype,
+		kobject_get(&cpsw_dev->kobj), "port_tx_pri_map");
+
+	if (ret) {
+		dev_err(dev, "failed to create sysfs port_tx_pri_map entry\n");
+		kobject_put(&cpsw_dev->tx_pri_kobj);
+		kobject_put(&cpsw_dev->kobj);
+		return ret;
+	}
+
+	ret = kobject_init_and_add(&cpsw_dev->pvlan_kobj,
+		&cpsw_pvlan_ktype,
+		kobject_get(&cpsw_dev->kobj), "port_vlan");
+
+	if (ret) {
+		dev_err(dev, "failed to create sysfs port_vlan entry\n");
+		kobject_put(&cpsw_dev->pvlan_kobj);
+		kobject_put(&cpsw_dev->kobj);
+		return ret;
+	}
+
+	ret = kobject_init_and_add(&cpsw_dev->stats_kobj,
+		&cpsw_stats_ktype,
+		kobject_get(&cpsw_dev->kobj), "stats");
+
+	if (ret) {
+		dev_err(dev, "failed to create sysfs stats entry\n");
+		kobject_put(&cpsw_dev->stats_kobj);
+		kobject_put(&cpsw_dev->kobj);
+		return ret;
+	}
+
+	return 0;
+}
+
+
+static int cpswx_probe(struct netcp_device *netcp_device,
+			struct device *dev,
+			struct device_node *node,
+			void **inst_priv)
+{
+	struct cpswx_priv *cpsw_dev;
+	struct device_node *slaves, *slave, *interfaces;
+	void __iomem *regs = NULL;
+	struct net_device *ndev;
+	int slave_num = 0;
+	int i, ret = 0;
+	u32 temp[4];
+
+	cpsw_dev = devm_kzalloc(dev, sizeof(struct cpswx_priv), GFP_KERNEL);
+	if (!cpsw_dev) {
+		dev_err(dev, "cpsw_dev memory allocation failed\n");
+		return -ENOMEM;
+	}
+	*inst_priv = cpsw_dev;
+	dev_dbg(dev, "%s(): cpsw_priv = %p\n", __func__, cpsw_dev);
+
+	if (!node) {
+		dev_err(dev, "device tree info unavailable\n");
+		ret = -ENODEV;
+		goto exit;
+	}
+
+	cpsw_dev->dev = dev;
+	cpsw_dev->netcp_device = netcp_device;
+
+	ret = of_property_read_u32(node, "serdes_at_probe",
+				   &cpsw_dev->init_serdes_at_probe);
+	if (ret < 0) {
+		dev_err(dev,
+			"missing serdes_at_probe parameter, err %d\n", ret);
+		cpsw_dev->init_serdes_at_probe = 0;
+	}
+	dev_dbg(dev, "serdes_at_probe %u\n", cpsw_dev->init_serdes_at_probe);
+
+	ret = of_property_read_u32(node, "sgmii_module_ofs",
+				   &cpsw_dev->sgmii_module_ofs);
+	if (ret < 0)
+		dev_err(dev, "missing sgmii module offset, err %d\n", ret);
+
+	ret = of_property_read_u32(node, "pcsr_module_ofs",
+				   &cpsw_dev->pcsr_module_ofs);
+	if (ret < 0)
+		dev_err(dev, "missing pcsr module offset, err %d\n", ret);
+
+	ret = of_property_read_u32(node, "switch_module_ofs",
+				   &cpsw_dev->switch_module_ofs);
+	if (ret < 0)
+		dev_err(dev, "missing switch module offset, err %d\n", ret);
+
+	ret = of_property_read_u32(node, "host_port_reg_ofs",
+				   &cpsw_dev->host_port_reg_ofs);
+	if (ret < 0)
+		dev_err(dev, "missing host port reg offset, err %d\n", ret);
+
+	ret = of_property_read_u32(node, "slave_reg_ofs",
+				   &cpsw_dev->slave_reg_ofs);
+	if (ret < 0)
+		dev_err(dev, "missing slave reg offset, err %d\n", ret);
+
+	ret = of_property_read_u32(node, "sliver_reg_ofs",
+				   &cpsw_dev->sliver_reg_ofs);
+	if (ret < 0)
+		dev_err(dev, "missing sliver reg offset, err %d\n", ret);
+
+	ret = of_property_read_u32(node, "hw_stats_reg_ofs",
+				   &cpsw_dev->hw_stats_reg_ofs);
+	if (ret < 0)
+		dev_err(dev, "missing hw stats reg offset, err %d\n", ret);
+
+	ret = of_property_read_u32(node, "ale_reg_ofs",
+				   &cpsw_dev->ale_reg_ofs);
+	if (ret < 0)
+		dev_err(dev, "missing ale reg offset, err %d\n", ret);
+
+
+	ret = of_property_read_u32(node, "num_slaves", &cpsw_dev->num_slaves);
+	if (ret < 0) {
+		dev_err(dev, "missing num_slaves parameter, err %d\n", ret);
+		cpsw_dev->num_slaves = 2;
+	}
+
+	ret = of_property_read_u32(node, "ale_ageout", &cpsw_dev->ale_ageout);
+	if (ret < 0) {
+		dev_err(dev, "missing ale_ageout parameter, err %d\n", ret);
+		cpsw_dev->ale_ageout = 10;
+	}
+
+	ret = of_property_read_u32(node, "ale_entries", &cpsw_dev->ale_entries);
+	if (ret < 0) {
+		dev_err(dev, "missing ale_entries parameter, err %d\n", ret);
+		cpsw_dev->ale_entries = 1024;
+	}
+
+	ret = of_property_read_u32(node, "ale_ports", &cpsw_dev->ale_ports);
+	if (ret < 0) {
+		dev_err(dev, "missing ale_ports parameter, err %d\n", ret);
+		cpsw_dev->ale_ports = 2;
+	}
+
+	ret = of_property_read_u32(node,
+				   "intf_tx_queues", &cpsw_dev->intf_tx_queues);
+	if (ret < 0) {
+		dev_err(dev, "missing intf_tx_queues parameter, err %d\n", ret);
+		cpsw_dev->intf_tx_queues = 1;
+	}
+
+	if (of_find_property(node, "multi-interface", NULL))
+		cpsw_dev->multi_if = 1;
+
+	ret = of_property_read_u32(node, "num-interfaces",
+				   &cpsw_dev->num_interfaces);
+	if (ret < 0) {
+		dev_err(dev, "missing num-interfaces parameter\n");
+		cpsw_dev->num_interfaces = 1;
+	}
+
+	ret = of_property_read_u32(node, "slaves-per-interface",
+				   &cpsw_dev->slaves_per_interface);
+	if (ret < 0) {
+		dev_err(dev, "missing slaves-per_interface parameter\n");
+		cpsw_dev->slaves_per_interface = 2;
+	}
+
+	/* Sub-sys regs base */
+	if (of_property_read_u32_array(node, "reg", (u32 *)&(temp[0]), 2))
+		dev_err(dev, "No reg defined\n");
+	else
+		regs = ioremap(temp[0], temp[1]);
+	BUG_ON(!regs);
+
+	cpsw_dev->ss_regs = regs;
+	cpsw_dev->sgmii_port_regs	= regs + cpsw_dev->sgmii_module_ofs;
+	cpsw_dev->pcsr_port_regs	= regs + cpsw_dev->pcsr_module_ofs;
+	cpsw_dev->regs			= regs + cpsw_dev->switch_module_ofs;
+	cpsw_dev->host_port_regs	= regs + cpsw_dev->host_port_reg_ofs;
+	cpsw_dev->host_hw_stats_regs	= regs + cpsw_dev->hw_stats_reg_ofs;
+	cpsw_dev->hw_stats_regs[0] = regs + cpsw_dev->hw_stats_reg_ofs + 0x100;
+	cpsw_dev->hw_stats_regs[1] = regs + cpsw_dev->hw_stats_reg_ofs + 0x200;
+	cpsw_dev->ale_reg		= regs + cpsw_dev->ale_reg_ofs;
+
+	ret = of_property_read_u32(node, "host_port", &cpsw_dev->host_port);
+	if (ret < 0) {
+		dev_err(dev, "missing host_port parameter\n");
+		cpsw_dev->host_port = 0;
+	}
+	cpsw_dev->rx_packet_max = 9500;
+
+	dev_dbg(dev, "num_slaves = %d\n", cpsw_dev->num_slaves);
+	dev_dbg(dev, "ale_ageout = %d\n", cpsw_dev->ale_ageout);
+	dev_dbg(dev, "ale_entries = %d\n", cpsw_dev->ale_entries);
+	dev_dbg(dev, "ale_ports = %d\n", cpsw_dev->ale_ports);
+
+	slaves = of_get_child_by_name(node, "slaves");
+	if (!slaves) {
+		dev_err(dev, "could not find slaves\n");
+		ret = -ENODEV;
+		goto exit;
+	}
+
+	for_each_child_of_node(slaves, slave) {
+		init_slave(cpsw_dev, slave, slave_num);
+		slave_num++;
+	}
+
+	of_node_put(slaves);
+
+	interfaces = of_get_child_by_name(node, "interfaces");
+	if (!interfaces)
+		dev_err(dev, "could not find interfaces\n");
+
+	cpsw_dev->interfaces = interfaces;
+
+	if (cpsw_dev->init_serdes_at_probe == 1) {
+		cpsw_dev->clk = clk_get(cpsw_dev->dev, "clk_xge");
+		if (IS_ERR(cpsw_dev->clk)) {
+			ret = PTR_ERR(cpsw_dev->clk);
+			cpsw_dev->clk = NULL;
+			dev_err(cpsw_dev->dev,
+				"unable to get Keystone XGE clock: %d\n", ret);
+			return ret;
+		}
+
+		ret = clk_prepare_enable(cpsw_dev->clk);
+		if (ret)
+			goto exit;
+
+		xge_serdes_init_156p25Mhz();
+	}
+
+	/* Create the interface */
+	INIT_LIST_HEAD(&cpsw_dev->cpsw_intf_head);
+	if (cpsw_dev->multi_if)
+		for (i = 0; i < cpsw_dev->num_interfaces; i++)
+			netcp_create_interface(netcp_device, &ndev,
+					       NULL, cpsw_dev->intf_tx_queues,
+					       1, (i + 1));
+	else
+		netcp_create_interface(netcp_device, &ndev,
+					       NULL, cpsw_dev->intf_tx_queues,
+					       1, 0);
+
+	/* init the hw stats lock */
+	mutex_init(&cpsw_dev->hw_stats_lock);
+
+	ret = cpsw_create_sysfs_entries(cpsw_dev);
+	if (ret)
+		goto exit;
+
+	return 0;
+
+exit:
+	if (cpsw_dev->ss_regs)
+		iounmap(cpsw_dev->ss_regs);
+	*inst_priv = NULL;
+	kfree(cpsw_dev);
+	return ret;
+}
+
+static int cpswx_attach(void *inst_priv, struct net_device *ndev,
+		       void **intf_priv)
+{
+	struct cpswx_priv *cpsw_dev = inst_priv;
+	struct cpswx_intf *cpsw_intf;
+	struct netcp_priv *netcp = netdev_priv(ndev);
+	struct device_node *interface;
+	int i = 0, ret = 0;
+	char node_name[24];
+
+	cpsw_intf = devm_kzalloc(cpsw_dev->dev,
+				 sizeof(struct cpswx_intf), GFP_KERNEL);
+	if (!cpsw_intf) {
+		dev_err(cpsw_dev->dev,
+			"cpswx interface memory allocation failed\n");
+		return -ENOMEM;
+	}
+	cpsw_intf->ndev = ndev;
+	cpsw_intf->dev = cpsw_dev->dev;
+	cpsw_intf->cpsw_priv = cpsw_dev;
+	cpsw_intf->multi_if = cpsw_dev->multi_if;
+
+	if (cpsw_dev->multi_if)
+		snprintf(node_name, sizeof(node_name), "interface-%d",
+			 netcp->cpsw_port - 1);
+	else
+		snprintf(node_name, sizeof(node_name), "interface-%d",
+			 0);
+
+	interface = of_get_child_by_name(cpsw_dev->interfaces, node_name);
+	if (!interface) {
+		dev_err(cpsw_dev->dev, "interface data not available\n");
+		devm_kfree(cpsw_dev->dev, cpsw_intf);
+		return -ENODEV;
+	}
+	ret = of_property_read_u32(interface, "slave_port",
+				   &cpsw_intf->slave_port);
+	if (ret < 0) {
+		dev_err(cpsw_dev->dev, "missing slave_port paramater\n");
+		return -EINVAL;
+	}
+
+	ret = of_property_read_string(interface, "tx-channel",
+				      &cpsw_intf->tx_chan_name);
+	if (ret < 0) {
+		dev_err(cpsw_dev->dev,
+			"missing tx-channel parameter, err %d\n", ret);
+		cpsw_intf->tx_chan_name = "nettx";
+	}
+	dev_info(cpsw_dev->dev, "dma_chan_name %s\n", cpsw_intf->tx_chan_name);
+
+	ret = of_property_read_u32(interface, "tx_queue_depth",
+				   &cpsw_intf->tx_queue_depth);
+	if (ret < 0) {
+		dev_err(cpsw_dev->dev,
+			"missing tx_queue_depth parameter, err %d\n", ret);
+		cpsw_intf->tx_queue_depth = 32;
+	}
+	dev_dbg(cpsw_dev->dev, "tx_queue_depth %u\n",
+		cpsw_intf->tx_queue_depth);
+
+	of_node_put(interface);
+
+	cpsw_intf->num_slaves = cpsw_dev->slaves_per_interface;
+
+	cpsw_intf->slaves = devm_kzalloc(cpsw_dev->dev,
+					 sizeof(struct cpswx_slave) *
+					 cpsw_intf->num_slaves, GFP_KERNEL);
+
+	if (!cpsw_intf->slaves) {
+		dev_err(cpsw_dev->dev,
+			"cpsw interface slave memory allocation failed\n");
+		devm_kfree(cpsw_dev->dev, cpsw_intf);
+		return -ENOMEM;
+	}
+
+	if (cpsw_dev->multi_if) {
+		cpsw_intf->slaves[i].slave_num = cpsw_intf->slave_port;
+		cpsw_intf->slaves[i].link_interface =
+			cpsw_dev->link[cpsw_intf->slave_port];
+		cpsw_intf->phy_node = cpsw_dev->phy_node[cpsw_intf->slave_port];
+	} else {
+		for (i = 0; i < cpsw_intf->num_slaves; i++) {
+			cpsw_intf->slaves[i].slave_num = i;
+			cpsw_intf->slaves[i].link_interface = cpsw_dev->link[i];
+		}
+	}
+
+	netcp_txpipe_init(&cpsw_intf->tx_pipe, netdev_priv(ndev),
+			  cpsw_intf->tx_chan_name, cpsw_intf->tx_queue_depth);
+
+	cpsw_intf->tx_pipe.dma_psflags	= netcp->cpsw_port;
+
+	SET_ETHTOOL_OPS(ndev, &keystone_ethtool_ops);
+
+	list_add(&cpsw_intf->cpsw_intf_list, &cpsw_dev->cpsw_intf_head);
+
+	*intf_priv = cpsw_intf;
+	return 0;
+}
+
+static int cpswx_release(void *intf_modpriv)
+{
+	struct cpswx_intf *cpsw_intf = intf_modpriv;
+
+	SET_ETHTOOL_OPS(cpsw_intf->ndev, NULL);
+
+	list_del(&cpsw_intf->cpsw_intf_list);
+
+	devm_kfree(cpsw_intf->dev, cpsw_intf->slaves);
+	devm_kfree(cpsw_intf->dev, cpsw_intf);
+
+	return 0;
+}
+
+
+static struct netcp_module cpsw_module = {
+	.name		= CPSW_MODULE_NAME,
+	.owner		= THIS_MODULE,
+	.probe		= cpswx_probe,
+	.open		= cpswx_open,
+	.close		= cpswx_close,
+	.remove		= cpswx_remove,
+	.attach		= cpswx_attach,
+	.release	= cpswx_release,
+	.add_addr	= cpswx_add_addr,
+	.del_addr	= cpswx_del_addr,
+	.add_vid	= cpswx_add_vid,
+	.del_vid	= cpswx_del_vid,
+	.ioctl		= cpswx_ioctl,
+};
+
+int __init keystone_cpswx_init(void)
+{
+	return netcp_register_module(&cpsw_module);
+}
+
+void __exit keystone_cpswx_exit(void)
+{
+	netcp_unregister_module(&cpsw_module);
+}
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Sandeep Paulraj <s-paulraj@ti.com>");
+MODULE_DESCRIPTION("CPSW driver for Keystone 10GE devices");
diff --git a/drivers/net/ethernet/ti/tlan.c b/drivers/net/ethernet/ti/tlan.c
index efd3669..2272538 100644
--- a/drivers/net/ethernet/ti/tlan.c
+++ b/drivers/net/ethernet/ti/tlan.c
@@ -300,7 +300,7 @@ these functions are more or less common to all linux network drivers.
  **************************************************************/
 
 
-static void __devexit tlan_remove_one(struct pci_dev *pdev)
+static void tlan_remove_one(struct pci_dev *pdev)
 {
 	struct net_device *dev = pci_get_drvdata(pdev);
 	struct tlan_priv	*priv = netdev_priv(dev);
@@ -392,7 +392,7 @@ static struct pci_driver tlan_driver = {
 	.name		= "tlan",
 	.id_table	= tlan_pci_tbl,
 	.probe		= tlan_init_one,
-	.remove		= __devexit_p(tlan_remove_one),
+	.remove		= tlan_remove_one,
 	.suspend	= tlan_suspend,
 	.resume		= tlan_resume,
 };
@@ -434,7 +434,7 @@ err_out_pci_free:
 }
 
 
-static int __devinit tlan_init_one(struct pci_dev *pdev,
+static int tlan_init_one(struct pci_dev *pdev,
 				   const struct pci_device_id *ent)
 {
 	return tlan_probe1(pdev, -1, -1, 0, ent);
@@ -460,9 +460,8 @@ static int __devinit tlan_init_one(struct pci_dev *pdev,
 *
 **************************************************************/
 
-static int __devinit tlan_probe1(struct pci_dev *pdev,
-				 long ioaddr, int irq, int rev,
-				 const struct pci_device_id *ent)
+static int tlan_probe1(struct pci_dev *pdev, long ioaddr, int irq, int rev,
+		       const struct pci_device_id *ent)
 {
 
 	struct net_device  *dev;
@@ -2545,7 +2544,7 @@ static void tlan_phy_reset(struct net_device *dev)
 
 	phy = priv->phy[priv->phy_num];
 
-	TLAN_DBG(TLAN_DEBUG_GNRL, "%s: Reseting PHY.\n", dev->name);
+	TLAN_DBG(TLAN_DEBUG_GNRL, "%s: Resetting PHY.\n", dev->name);
 	tlan_mii_sync(dev->base_addr);
 	value = MII_GC_LOOPBK | MII_GC_RESET;
 	tlan_mii_write_reg(dev, phy, MII_GEN_CTL, value);
-- 
1.7.5.4

