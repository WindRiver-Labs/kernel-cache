From 82f11f0e7fa86b8a22313541cdb246f5b7bed87a Mon Sep 17 00:00:00 2001
From: Guoqing Jiang <Guoqing.Jiang@windriver.com>
Date: Thu, 18 Jul 2013 10:51:03 +0800
Subject: [PATCH 13/20] phylib: add context argument to adjust link callback

Commit 2a9bfae68c18f7628d7b1ac8919dc999e05cecbd from arago tree
git://arago-project.org/git/projects/linux-keystone.git releases/03.00.00.11/master

This patch introduces a context argument for the adjust link callback.  This
context information is set at phy_connect() (and its variants), and is passed
back into the adjust_link callbacks on link state change events.

Such context information is necessary when a network device has multiple
underlying ports.  Specifically, this comes into play when the netdev is
really one of the ports going into an on-chip switch of some sort.

Signed-off-by: Sandeep Paulraj <s-paulraj@ti.com>
Signed-off-by: Guoqing Jiang <Guoqing.Jiang@windriver.com>
---
 drivers/net/phy/phy.c        | 20 ++++++++++----------
 drivers/net/phy/phy_device.c | 22 ++++++++++++++--------
 include/linux/phy.h          | 17 ++++++++++-------
 3 files changed, 34 insertions(+), 25 deletions(-)

diff --git a/drivers/net/phy/phy.c b/drivers/net/phy/phy.c
index 38f0b31..1ba32bd 100644
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@ -435,7 +435,7 @@ static void phy_change(struct work_struct *work);
  *   function.
  */
 void phy_start_machine(struct phy_device *phydev,
-		void (*handler)(struct net_device *))
+		       void (*handler)(struct net_device *, void *context))
 {
 	phydev->adjust_state = handler;
 
@@ -749,7 +749,7 @@ void phy_state_machine(struct work_struct *work)
 	mutex_lock(&phydev->lock);
 
 	if (phydev->adjust_state)
-		phydev->adjust_state(phydev->attached_dev);
+		phydev->adjust_state(phydev->attached_dev, phydev->context);
 
 	switch(phydev->state) {
 		case PHY_DOWN:
@@ -774,7 +774,7 @@ void phy_state_machine(struct work_struct *work)
 			if (!phydev->link) {
 				phydev->state = PHY_NOLINK;
 				netif_carrier_off(phydev->attached_dev);
-				phydev->adjust_link(phydev->attached_dev);
+				phydev->adjust_link(phydev->attached_dev, phydev->context);
 				break;
 			}
 
@@ -788,7 +788,7 @@ void phy_state_machine(struct work_struct *work)
 			if (err > 0) {
 				phydev->state = PHY_RUNNING;
 				netif_carrier_on(phydev->attached_dev);
-				phydev->adjust_link(phydev->attached_dev);
+				phydev->adjust_link(phydev->attached_dev, phydev->context);
 
 			} else if (0 == phydev->link_timeout--) {
 				needs_aneg = 1;
@@ -807,7 +807,7 @@ void phy_state_machine(struct work_struct *work)
 			if (phydev->link) {
 				phydev->state = PHY_RUNNING;
 				netif_carrier_on(phydev->attached_dev);
-				phydev->adjust_link(phydev->attached_dev);
+				phydev->adjust_link(phydev->attached_dev, phydev->context);
 			}
 			break;
 		case PHY_FORCING:
@@ -824,7 +824,7 @@ void phy_state_machine(struct work_struct *work)
 					needs_aneg = 1;
 			}
 
-			phydev->adjust_link(phydev->attached_dev);
+			phydev->adjust_link(phydev->attached_dev, phydev->context);
 			break;
 		case PHY_RUNNING:
 			/* Only register a CHANGE if we are
@@ -846,7 +846,7 @@ void phy_state_machine(struct work_struct *work)
 				netif_carrier_off(phydev->attached_dev);
 			}
 
-			phydev->adjust_link(phydev->attached_dev);
+			phydev->adjust_link(phydev->attached_dev, phydev->context);
 
 			if (PHY_POLL != phydev->irq)
 				err = phy_config_interrupt(phydev,
@@ -856,7 +856,7 @@ void phy_state_machine(struct work_struct *work)
 			if (phydev->link) {
 				phydev->link = 0;
 				netif_carrier_off(phydev->attached_dev);
-				phydev->adjust_link(phydev->attached_dev);
+				phydev->adjust_link(phydev->attached_dev, phydev->context);
 			}
 			break;
 		case PHY_RESUMING:
@@ -890,7 +890,7 @@ void phy_state_machine(struct work_struct *work)
 						netif_carrier_on(phydev->attached_dev);
 					} else
 						phydev->state = PHY_NOLINK;
-					phydev->adjust_link(phydev->attached_dev);
+					phydev->adjust_link(phydev->attached_dev, phydev->context);
 				} else {
 					phydev->state = PHY_AN;
 					phydev->link_timeout = PHY_AN_TIMEOUT;
@@ -905,7 +905,7 @@ void phy_state_machine(struct work_struct *work)
 					netif_carrier_on(phydev->attached_dev);
 				} else
 					phydev->state = PHY_NOLINK;
-				phydev->adjust_link(phydev->attached_dev);
+				phydev->adjust_link(phydev->attached_dev, phydev->context);
 			}
 			break;
 	}
diff --git a/drivers/net/phy/phy_device.c b/drivers/net/phy/phy_device.c
index 3657b4a..8dc9d57 100644
--- a/drivers/net/phy/phy_device.c
+++ b/drivers/net/phy/phy_device.c
@@ -399,6 +399,7 @@ EXPORT_SYMBOL(phy_find_first);
  * phy_prepare_link - prepares the PHY layer to monitor link status
  * @phydev: target phy_device struct
  * @handler: callback function for link status change notifications
+ * @context: context information for callback handler
  *
  * Description: Tells the PHY infrastructure to handle the
  *   gory details on monitoring link status (whether through
@@ -408,9 +409,11 @@ EXPORT_SYMBOL(phy_find_first);
  *   this function.
  */
 static void phy_prepare_link(struct phy_device *phydev,
-		void (*handler)(struct net_device *))
+		void (*handler)(struct net_device *, void *context),
+		void *context)
 {
 	phydev->adjust_link = handler;
+	phydev->context = context;
 }
 
 /**
@@ -418,19 +421,21 @@ static void phy_prepare_link(struct phy_device *phydev,
  * @dev: the network device to connect
  * @phydev: the pointer to the phy device
  * @handler: callback function for state change notifications
+ * @flags: PHY device's dev_flags
  * @interface: PHY device's interface
+ * @context: context information for callback handler
  */
 int phy_connect_direct(struct net_device *dev, struct phy_device *phydev,
-		       void (*handler)(struct net_device *),
-		       phy_interface_t interface)
+		       void (*handler)(struct net_device *, void *context),
+		       u32 flags, phy_interface_t interface, void *context)
 {
 	int rc;
 
-	rc = phy_attach_direct(dev, phydev, phydev->dev_flags, interface);
+	rc = phy_attach_direct(dev, phydev, flags, interface);
 	if (rc)
 		return rc;
 
-	phy_prepare_link(phydev, handler);
+	phy_prepare_link(phydev, handler, context);
 	phy_start_machine(phydev, NULL);
 	if (phydev->irq > 0)
 		phy_start_interrupts(phydev);
@@ -445,6 +450,7 @@ EXPORT_SYMBOL(phy_connect_direct);
  * @bus_id: the id string of the PHY device to connect
  * @handler: callback function for state change notifications
  * @interface: PHY device's interface
+ * @context: context information for callback handler
  *
  * Description: Convenience function for connecting ethernet
  *   devices to PHY devices.  The default behavior is for
@@ -455,8 +461,8 @@ EXPORT_SYMBOL(phy_connect_direct);
  *   the desired functionality.
  */
 struct phy_device * phy_connect(struct net_device *dev, const char *bus_id,
-		void (*handler)(struct net_device *),
-		phy_interface_t interface)
+		void (*handler)(struct net_device *, void *context),
+		u32 flags, phy_interface_t interface, void *context)
 {
 	struct phy_device *phydev;
 	struct device *d;
@@ -471,7 +477,7 @@ struct phy_device * phy_connect(struct net_device *dev, const char *bus_id,
 	}
 	phydev = to_phy_device(d);
 
-	rc = phy_connect_direct(dev, phydev, handler, interface);
+	rc = phy_connect_direct(dev, phydev, handler, flags, interface, context);
 	if (rc)
 		return ERR_PTR(rc);
 
diff --git a/include/linux/phy.h b/include/linux/phy.h
index 9e11039..be4ecd0 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -274,6 +274,7 @@ struct phy_c45_device_ids {
  * changes in the link state.
  * adjust_state: Callback for the enet driver to respond to
  * changes in the state machine.
+ * context: Context information for adjust_link and adjust_state callbacks
  *
  * speed, duplex, pause, supported, advertising, and
  * autoneg are used like in mii_if_info
@@ -351,9 +352,11 @@ struct phy_device {
 
 	struct net_device *attached_dev;
 
-	void (*adjust_link)(struct net_device *dev);
+	void (*adjust_link)(struct net_device *dev, void *context);
 
-	void (*adjust_state)(struct net_device *dev);
+	void (*adjust_state)(struct net_device *dev, void *context);
+
+	void *context;
 };
 #define to_phy_device(d) container_of(d, struct phy_device, dev)
 
@@ -517,11 +520,11 @@ struct phy_device * phy_attach(struct net_device *dev,
 		const char *bus_id, phy_interface_t interface);
 struct phy_device *phy_find_first(struct mii_bus *bus);
 int phy_connect_direct(struct net_device *dev, struct phy_device *phydev,
-		void (*handler)(struct net_device *),
-		phy_interface_t interface);
+		void (*handler)(struct net_device *, void *context),
+		u32 flags, phy_interface_t interface, void *context);
 struct phy_device * phy_connect(struct net_device *dev, const char *bus_id,
-		void (*handler)(struct net_device *),
-		phy_interface_t interface);
+		void (*handler)(struct net_device *, void *context),
+		u32 flags, phy_interface_t interface, void *context);
 void phy_disconnect(struct phy_device *phydev);
 void phy_detach(struct phy_device *phydev);
 void phy_start(struct phy_device *phydev);
@@ -546,7 +549,7 @@ int phy_driver_register(struct phy_driver *new_driver);
 int phy_drivers_register(struct phy_driver *new_driver, int n);
 void phy_state_machine(struct work_struct *work);
 void phy_start_machine(struct phy_device *phydev,
-		void (*handler)(struct net_device *));
+		       void (*handler)(struct net_device *, void *context));
 void phy_stop_machine(struct phy_device *phydev);
 int phy_ethtool_sset(struct phy_device *phydev, struct ethtool_cmd *cmd);
 int phy_ethtool_gset(struct phy_device *phydev, struct ethtool_cmd *cmd);
-- 
1.8.4.93.g57e4c17

