From 4a456313f8c2fd071e9fba5a770c412f0ff086ae Mon Sep 17 00:00:00 2001
From: Guoqing Jiang <Guoqing.Jiang@windriver.com>
Date: Thu, 5 Sep 2013 11:12:29 +0800
Subject: [PATCH 17/20] i2c: davinci: add i2c support for keystone platform

Update davinci i2c code to make it works on keystone platform.

Refer to the following commits from arago tree
git://arago-project.org/git/projects/linux-keystone.git releases/03.00.00.11/master

e8becca i2c: davinci: remove useless machine include
12250d8 Merge branch 'i2c-embedded/for-next' of git://git.pengutronix.de/git/wsa/linux
9e5ead8 i2c: davinci: enable davinci i2c on keystone platforms
2bdbfa9 i2c: davinci: preparation for switch to common clock framework
ec2a083 ARM: davinci: move platform_data definitions
5c3d8a4 i2c: davinci: add OF support

Signed-off-by: Guoqing Jiang <Guoqing.Jiang@windriver.com>
---
 drivers/i2c/busses/Kconfig       |  2 +-
 drivers/i2c/busses/i2c-davinci.c | 74 +++++++++++++++++++++++++++-------------
 2 files changed, 52 insertions(+), 24 deletions(-)

diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index 4faf02b..bba660e 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -384,7 +384,7 @@ config I2C_CPM
 
 config I2C_DAVINCI
 	tristate "DaVinci I2C driver"
-	depends on ARCH_DAVINCI
+	depends on ARCH_DAVINCI || ARCH_KEYSTONE
 	help
 	  Support for TI DaVinci I2C controller driver.
 
diff --git a/drivers/i2c/busses/i2c-davinci.c b/drivers/i2c/busses/i2c-davinci.c
index cf20e06..8a81b3d 100644
--- a/drivers/i2c/busses/i2c-davinci.c
+++ b/drivers/i2c/busses/i2c-davinci.c
@@ -41,7 +41,6 @@
 #include <linux/of_i2c.h>
 #include <linux/of_device.h>
 
-#include <mach/hardware.h>
 #include <linux/platform_data/i2c-davinci.h>
 
 /* ----- global defines ----------------------------------------------- */
@@ -137,7 +136,7 @@ static inline u16 davinci_i2c_read_reg(struct davinci_i2c_dev *i2c_dev, int reg)
 }
 
 /* Generate a pulse on the i2c clock pin. */
-static void davinci_i2c_clock_pulse(unsigned int scl_pin)
+static void generic_i2c_clock_pulse(unsigned int scl_pin)
 {
 	u16 i;
 
@@ -166,7 +165,7 @@ static void davinci_i2c_recover_bus(struct davinci_i2c_dev *dev)
 	flag |=  DAVINCI_I2C_MDR_NACK;
 	/* write the data into mode register */
 	davinci_i2c_write_reg(dev, DAVINCI_I2C_MDR_REG, flag);
-	davinci_i2c_clock_pulse(pdata->scl_pin);
+	generic_i2c_clock_pulse(pdata->scl_pin);
 	/* Send STOP */
 	flag = davinci_i2c_read_reg(dev, DAVINCI_I2C_MDR_REG);
 	flag |= DAVINCI_I2C_MDR_STP;
@@ -643,7 +642,7 @@ static int davinci_i2c_probe(struct platform_device *pdev)
 {
 	struct davinci_i2c_dev *dev;
 	struct i2c_adapter *adap;
-	struct resource *mem, *irq;
+	struct resource *mem, *irq, *ioarea;
 	int r;
 
 	/* NOTE: driver uses the static register mapping */
@@ -659,18 +658,24 @@ static int davinci_i2c_probe(struct platform_device *pdev)
 		return -ENODEV;
 	}
 
-	dev = devm_kzalloc(&pdev->dev, sizeof(struct davinci_i2c_dev),
-			GFP_KERNEL);
+	ioarea = request_mem_region(mem->start, resource_size(mem),
+				    pdev->name);
+	if (!ioarea) {
+		dev_err(&pdev->dev, "I2C region already claimed\n");
+		return -EBUSY;
+	}
+
+	dev = kzalloc(sizeof(struct davinci_i2c_dev), GFP_KERNEL);
 	if (!dev) {
-		dev_err(&pdev->dev, "Memory allocation failed\n");
-		return -ENOMEM;
+		r = -ENOMEM;
+		goto err_release_region;
 	}
 
 	init_completion(&dev->cmd_complete);
 #ifdef CONFIG_CPU_FREQ
 	init_completion(&dev->xfr_complete);
 #endif
-	dev->dev = &pdev->dev;
+	dev->dev = get_device(&pdev->dev);
 	dev->irq = irq->start;
 	dev->pdata = dev->dev->platform_data;
 	platform_set_drvdata(pdev, dev);
@@ -680,9 +685,10 @@ static int davinci_i2c_probe(struct platform_device *pdev)
 
 		dev->pdata = devm_kzalloc(&pdev->dev,
 			sizeof(struct davinci_i2c_platform_data), GFP_KERNEL);
-		if (!dev->pdata)
-			return -ENOMEM;
-
+		if (!dev->pdata) {
+			r = -ENOMEM;
+			goto err_free_mem;
+		}
 		memcpy(dev->pdata, &davinci_i2c_platform_data_default,
 			sizeof(struct davinci_i2c_platform_data));
 		if (!of_property_read_u32(pdev->dev.of_node, "clock-frequency",
@@ -692,21 +698,22 @@ static int davinci_i2c_probe(struct platform_device *pdev)
 		dev->pdata = &davinci_i2c_platform_data_default;
 	}
 
-	dev->clk = devm_clk_get(&pdev->dev, NULL);
-	if (IS_ERR(dev->clk))
-		return -ENODEV;
+	dev->clk = clk_get(&pdev->dev, NULL);
+	if (IS_ERR(dev->clk)) {
+		r = -ENODEV;
+		goto err_free_mem;
+	}
 	clk_prepare_enable(dev->clk);
 
-	dev->base = devm_ioremap_resource(&pdev->dev, mem);
-	if (IS_ERR(dev->base)) {
-		r = PTR_ERR(dev->base);
-		goto err_unuse_clocks;
+	dev->base = ioremap(mem->start, resource_size(mem));
+	if (!dev->base) {
+		r = -EBUSY;
+		goto err_mem_ioremap;
 	}
 
 	i2c_davinci_init(dev);
 
-	r = devm_request_irq(&pdev->dev, dev->irq, i2c_davinci_isr, 0,
-			pdev->name, dev);
+	r = request_irq(dev->irq, i2c_davinci_isr, 0, pdev->name, dev);
 	if (r) {
 		dev_err(&pdev->dev, "failure requesting irq %i\n", dev->irq);
 		goto err_unuse_clocks;
@@ -715,7 +722,7 @@ static int davinci_i2c_probe(struct platform_device *pdev)
 	r = i2c_davinci_cpufreq_register(dev);
 	if (r) {
 		dev_err(&pdev->dev, "failed to register cpufreq\n");
-		goto err_unuse_clocks;
+		goto err_free_irq;
 	}
 
 	adap = &dev->adapter;
@@ -732,31 +739,52 @@ static int davinci_i2c_probe(struct platform_device *pdev)
 	r = i2c_add_numbered_adapter(adap);
 	if (r) {
 		dev_err(&pdev->dev, "failure adding adapter\n");
-		goto err_unuse_clocks;
+		goto err_free_irq;
 	}
 	of_i2c_register_devices(adap);
 
 	return 0;
 
+err_free_irq:
+	free_irq(dev->irq, dev);
 err_unuse_clocks:
+	iounmap(dev->base);
+err_mem_ioremap:
 	clk_disable_unprepare(dev->clk);
+	clk_put(dev->clk);
 	dev->clk = NULL;
+err_free_mem:
+	platform_set_drvdata(pdev, NULL);
+	put_device(&pdev->dev);
+	kfree(dev);
+err_release_region:
+	release_mem_region(mem->start, resource_size(mem));
+
 	return r;
 }
 
 static int davinci_i2c_remove(struct platform_device *pdev)
 {
 	struct davinci_i2c_dev *dev = platform_get_drvdata(pdev);
+	struct resource *mem;
 
 	i2c_davinci_cpufreq_deregister(dev);
 
+	platform_set_drvdata(pdev, NULL);
 	i2c_del_adapter(&dev->adapter);
+	put_device(&pdev->dev);
 
 	clk_disable_unprepare(dev->clk);
+	clk_put(dev->clk);
 	dev->clk = NULL;
 
 	davinci_i2c_write_reg(dev, DAVINCI_I2C_MDR_REG, 0);
+	free_irq(dev->irq, dev);
+	iounmap(dev->base);
+	kfree(dev);
 
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(mem->start, resource_size(mem));
 	return 0;
 }
 
-- 
1.8.4.93.g57e4c17

