From 3dedc2b65428122bd402f5c99d81eaee28751961 Mon Sep 17 00:00:00 2001
From: Guoqing Jiang <Guoqing.Jiang@windriver.com>
Date: Thu, 18 Jul 2013 14:22:10 +0800
Subject: [PATCH 58/61] clk: add common clock support for davinci and keystone

Introduce davinci clock driver and keystone clock driver for Keystone platform,

Refer to the following commits from arago tree
git://arago-project.org/git/projects/linux-keystone.git releases/03.00.00.11/master

36335df clk: davinci: add local reset when disabling clock psc module
4747bbb clk: davinci - add support for lreset control
823fb27 clk: davinci - initialize strings fetched from device-tree
f291b21 clk: davinci - add clock driver init through DT
7e80527 clk: davinci - add support for DT in psc clk driver
c4aab03 clk: davinci - add build infrastructure
a07d18d clk: davinci - common clk driver initialization
9bf0b13 clk: davinci - add PSC clock driver
933f3c2 clk: davinci - add Main PLL clock driver
b5e8843 clk: keystone: enhancement to support ARMPLL, DDRPLL and PAPLL
d1b213f clk: keystone - add support for DT in keystone PLL driver
1cd75a9 clk: keystone - add Main PLL clock driver

Signed-off-by: Guoqing Jiang <Guoqing.Jiang@windriver.com>
---
 drivers/clk/Kconfig                            |    2 +
 drivers/clk/Makefile                           |    3 +
 drivers/clk/davinci/Kconfig                    |   42 +++
 drivers/clk/davinci/Makefile                   |    3 +
 drivers/clk/davinci/clk-davinci-pll.c          |  128 ++++++++
 drivers/clk/davinci/clk-davinci-psc.c          |  324 +++++++++++++++++++
 drivers/clk/davinci/davinci-clock.c            |  407 ++++++++++++++++++++++++
 drivers/clk/keystone/Kconfig                   |    6 +
 drivers/clk/keystone/Makefile                  |    1 +
 drivers/clk/keystone/clk-keystone-pll.c        |  170 ++++++++++
 include/linux/platform_data/clk-davinci-pll.h  |   54 ++++
 include/linux/platform_data/clk-davinci-psc.h  |   58 ++++
 include/linux/platform_data/clk-keystone-pll.h |   55 ++++
 include/linux/platform_data/davinci-clock.h    |  149 +++++++++
 14 files changed, 1402 insertions(+), 0 deletions(-)
 create mode 100644 drivers/clk/davinci/Kconfig
 create mode 100644 drivers/clk/davinci/Makefile
 create mode 100644 drivers/clk/davinci/clk-davinci-pll.c
 create mode 100644 drivers/clk/davinci/clk-davinci-psc.c
 create mode 100644 drivers/clk/davinci/davinci-clock.c
 create mode 100644 drivers/clk/keystone/Kconfig
 create mode 100644 drivers/clk/keystone/Makefile
 create mode 100644 drivers/clk/keystone/clk-keystone-pll.c
 create mode 100644 include/linux/platform_data/clk-davinci-pll.h
 create mode 100644 include/linux/platform_data/clk-davinci-psc.h
 create mode 100644 include/linux/platform_data/clk-keystone-pll.h
 create mode 100644 include/linux/platform_data/davinci-clock.h

diff --git a/drivers/clk/Kconfig b/drivers/clk/Kconfig
index 4864407..fb0c683 100644
--- a/drivers/clk/Kconfig
+++ b/drivers/clk/Kconfig
@@ -34,4 +34,6 @@ config COMMON_CLK_DEBUG
 	  clk_flags, clk_prepare_count, clk_enable_count &
 	  clk_notifier_count.
 
+source "drivers/clk/davinci/Kconfig"
+source "drivers/clk/keystone/Kconfig"
 endmenu
diff --git a/drivers/clk/Makefile b/drivers/clk/Makefile
index 24aa714..16c21e5 100644
--- a/drivers/clk/Makefile
+++ b/drivers/clk/Makefile
@@ -2,3 +2,6 @@
 obj-$(CONFIG_CLKDEV_LOOKUP)	+= clkdev.o
 obj-$(CONFIG_COMMON_CLK)	+= clk.o clk-fixed-rate.o clk-gate.o \
 				   clk-mux.o clk-divider.o clk-fixed-factor.o
+
+obj-$(CONFIG_DAVINCI_CLKS)      += davinci/
+obj-$(CONFIG_CLK_KEYSTONE_PLL)  += keystone/
diff --git a/drivers/clk/davinci/Kconfig b/drivers/clk/davinci/Kconfig
new file mode 100644
index 0000000..2202c25
--- /dev/null
+++ b/drivers/clk/davinci/Kconfig
@@ -0,0 +1,42 @@
+menu "TI DaVinci Clock Drivers"
+	depends on COMMON_CLK
+
+config  CLK_DAVINCI_PSC
+	bool "TI DaVici PSC Clock driver"
+	default n
+	---help---
+	  Selects clock driver for DaVinci PSC clocks. This clock
+	  hardware is found on TI DaVinci SoCs and other SoCs that
+	  uses this hardware IP. This hardware has a local power
+	  sleep control module that gate the clock to the IP.
+
+config  CLK_DAVINCI_PLL
+	bool "DaVici Main PLL clock"
+	---help---
+	  Selects clock driver for DaVinci Main PLL. This clock
+	  hardware is found on TI DaVinci SoCs. This typically has
+	  a multiplier, a pre divider and post driver. Some of the
+	  SoCs has the the dividers fixed, and others have it
+	  programmable
+
+config DAVINCI_CLKS
+	bool "TI DaVinci common clocks"
+	default n
+	select CLK_DAVINCI_PSC
+	select DAVINCI_CLKINIT
+	---help---
+	  Selects common clock drivers for DaVinci. These clocks
+	  are re-used across many TI SoCs that are based on DaVinci and
+	  Keystone (c6x) families. This config option is used to select
+	  the common clock driver for DaVinci based SoCs. SoCs specific
+	  Kconfig option needs to select the driver for clocks specific
+	  to the SoC.
+
+config	DAVINCI_CLKINIT
+	bool "TI DaVici Clock initialization"
+	default n
+	---help---
+	  Selects clock driver initialization for DaVinci and Keystone
+	  architectures.
+endmenu
+
diff --git a/drivers/clk/davinci/Makefile b/drivers/clk/davinci/Makefile
new file mode 100644
index 0000000..420e9c3
--- /dev/null
+++ b/drivers/clk/davinci/Makefile
@@ -0,0 +1,3 @@
+obj-$(CONFIG_CLK_DAVINCI_PLL)	+= clk-davinci-pll.o
+obj-$(CONFIG_CLK_DAVINCI_PSC)	+= clk-davinci-psc.o
+obj-$(CONFIG_DAVINCI_CLKINIT)	+= davinci-clock.o
diff --git a/drivers/clk/davinci/clk-davinci-pll.c b/drivers/clk/davinci/clk-davinci-pll.c
new file mode 100644
index 0000000..13e1690
--- /dev/null
+++ b/drivers/clk/davinci/clk-davinci-pll.c
@@ -0,0 +1,128 @@
+/*
+ * PLL clk driver DaVinci devices
+ *
+ * Copyright (C) 2006-2012 Texas Instruments.
+ * Copyright (C) 2008-2009 Deep Root Systems, LLC
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * TODO - Add set_parent_rate()
+ */
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/platform_data/clk-davinci-pll.h>
+
+#include <mach/cputype.h>
+
+#define PLLM		0x110
+#define PLLM_PLLM_MASK  0xff
+#define PREDIV          0x114
+#define POSTDIV         0x128
+#define PLLDIV_EN       BIT(15)
+
+/**
+ * struct clk_davinci_pll - DaVinci Main pll clock
+ * @hw: clk_hw for the pll
+ * @pll_data: PLL driver specific data
+ */
+struct clk_davinci_pll {
+	struct clk_hw hw;
+	struct clk_davinci_pll_data *pll_data;
+};
+
+#define to_clk_pll(_hw) container_of(_hw, struct clk_davinci_pll, hw)
+
+static unsigned long clk_pllclk_recalc(struct clk_hw *hw,
+					unsigned long parent_rate)
+{
+	struct clk_davinci_pll *pll = to_clk_pll(hw);
+	struct clk_davinci_pll_data *pll_data = pll->pll_data;
+	u32 mult = 1, prediv = 1, postdiv = 1;
+	unsigned long rate = parent_rate;
+
+	/* If there is a device specific recalc defined invoke it. Otherwise
+	 * fallback to default one
+	 */
+	mult = __raw_readl(pll_data->pllm);
+	if (pll_data->pllm_multiplier)
+		mult =  pll_data->pllm_multiplier *
+				(mult & pll_data->pllm_mask);
+	else
+		mult = (mult & pll_data->pllm_mask) + 1;
+
+	if (pll_data->flags & CLK_DAVINCI_PLL_HAS_PREDIV) {
+		/* pre-divider is fixed, take prediv value from pll_data  */
+		if (pll_data->fixed_prediv)
+			prediv = pll_data->fixed_prediv;
+		else {
+			prediv = __raw_readl(pll_data->prediv);
+			if (prediv & PLLDIV_EN)
+				prediv = (prediv & pll_data->prediv_mask) + 1;
+			else
+				prediv = 1;
+		}
+	}
+
+	if (pll_data->flags & CLK_DAVINCI_PLL_HAS_POSTDIV) {
+		postdiv = __raw_readl(pll_data->postdiv);
+		if (postdiv & PLLDIV_EN)
+			postdiv = (postdiv & pll_data->postdiv_mask) + 1;
+		else
+			postdiv = 1;
+	}
+
+	rate /= prediv;
+	rate *= mult;
+	rate /= postdiv;
+
+	pr_debug("PLL%d: input = %lu MHz [ ",
+		 pll_data->num, parent_rate / 1000000);
+	if (prediv > 1)
+		pr_debug("/ %d ", prediv);
+	if (mult > 1)
+		pr_debug("* %d ", mult);
+	if (postdiv > 1)
+		pr_debug("/ %d ", postdiv);
+	pr_debug("] --> %lu MHz output.\n", rate / 1000000);
+	return rate;
+}
+
+static const struct clk_ops clk_pll_ops = {
+	.recalc_rate = clk_pllclk_recalc,
+};
+
+struct clk *clk_register_davinci_pll(struct device *dev, const char *name,
+			const char *parent_name,
+			struct clk_davinci_pll_data *pll_data)
+{
+	struct clk_init_data init;
+	struct clk_davinci_pll *pll;
+	struct clk *clk;
+
+	if (!pll_data)
+		return ERR_PTR(-ENODEV);
+
+	pll = kzalloc(sizeof(*pll), GFP_KERNEL);
+	if (!pll)
+		return ERR_PTR(-ENOMEM);
+	init.name = name;
+	init.ops = &clk_pll_ops;
+	init.flags = pll_data->flags;
+	init.parent_names = (parent_name ? &parent_name : NULL);
+	init.num_parents = (parent_name ? 1 : 0);
+
+	pll->pll_data	= pll_data;
+	pll->hw.init = &init;
+
+	clk = clk_register(NULL, &pll->hw);
+	if (IS_ERR(clk))
+		kfree(pll);
+
+	return clk;
+}
diff --git a/drivers/clk/davinci/clk-davinci-psc.c b/drivers/clk/davinci/clk-davinci-psc.c
new file mode 100644
index 0000000..464d6ea
--- /dev/null
+++ b/drivers/clk/davinci/clk-davinci-psc.c
@@ -0,0 +1,324 @@
+/*
+ * PSC clk driver for DaVinci devices
+ *
+ * Copyright (C) 2006-2012 Texas Instruments.
+ * Copyright (C) 2008-2009 Deep Root Systems, LLC
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/platform_data/clk-davinci-psc.h>
+#include <linux/of_address.h>
+#include <linux/of.h>
+#include <linux/module.h>
+
+/* PSC register offsets */
+#define EPCPR		0x070
+#define PTCMD		0x120
+#define PTSTAT		0x128
+#define PDSTAT		0x200
+#define PDCTL		0x300
+#define MDSTAT		0x800
+#define MDCTL		0xA00
+
+/* PSC module states */
+#define PSC_STATE_SWRSTDISABLE	0
+#define PSC_STATE_SYNCRST	1
+#define PSC_STATE_DISABLE	2
+#define PSC_STATE_ENABLE	3
+
+#define MDSTAT_STATE_MASK	0x3f
+#define PDSTAT_STATE_MASK	0x1f
+#define MDCTL_FORCE		BIT(31)
+#define MDCTL_LRESET		BIT(8)
+#define PDCTL_NEXT		BIT(0)
+#define PDCTL_EPCGOOD		BIT(8)
+
+/* PSC flags */
+#define PSC_SWRSTDISABLE	BIT(0) /* Disable state is SwRstDisable */
+#define PSC_FORCE		BIT(1) /* Force module state transtition */
+#define PSC_HAS_EXT_POWER_CNTL	BIT(2) /* PSC has external power control
+					* available (for DM6446 SoC) */
+#define PSC_LRESET		BIT(3) /* Keep module in local reset */
+#define STATE_TRANS_MAX_COUNT	0xffff /* Maximum timeout to bail out state
+					* transition for module */
+/**
+ * struct clk_psc - DaVinci PSC clock
+ * @hw: clk_hw for the psc
+ * @psc_data: PSC driver specific data
+ * @lock: Spinlock used by the driver
+ */
+struct clk_psc {
+	struct clk_hw hw;
+	struct clk_davinci_psc_data *psc_data;
+	spinlock_t *lock;
+};
+
+#define to_clk_psc(_hw) container_of(_hw, struct clk_psc, hw)
+
+/* Enable or disable a PSC domain */
+static void clk_psc_config(void __iomem *base, unsigned int domain,
+		unsigned int id, bool enable, u32 flags)
+{
+	u32 epcpr, ptcmd, ptstat, pdstat, pdctl, mdstat, mdctl;
+	u32 next_state = PSC_STATE_ENABLE;
+	void __iomem *psc_base = base;
+	u32 count = STATE_TRANS_MAX_COUNT;
+	int err = 0;
+
+	if (!enable) {
+		if (flags & PSC_SWRSTDISABLE)
+			next_state = PSC_STATE_SWRSTDISABLE;
+		else
+			next_state = PSC_STATE_DISABLE;
+	}
+
+	mdctl = __raw_readl(psc_base + MDCTL + 4 * id);
+	mdctl &= ~MDSTAT_STATE_MASK;
+	mdctl |= next_state;
+	if (flags & PSC_FORCE)
+		mdctl |= MDCTL_FORCE;
+
+	if (flags & PSC_LRESET)
+		mdctl &= ~MDCTL_LRESET;
+
+	/* For disable, we always put the module in local reset */
+	if (!enable)
+		mdctl &= ~MDCTL_LRESET;
+
+	__raw_writel(mdctl, psc_base + MDCTL + 4 * id);
+
+	pdstat = __raw_readl(psc_base + PDSTAT + 4 * domain);
+	if ((pdstat & PDSTAT_STATE_MASK) == 0) {
+		pdctl = __raw_readl(psc_base + PDCTL + 4 * domain);
+		pdctl |= PDCTL_NEXT;
+		__raw_writel(pdctl, psc_base + PDCTL + 4 * domain);
+
+		ptcmd = 1 << domain;
+		__raw_writel(ptcmd, psc_base + PTCMD);
+
+		if (flags & PSC_HAS_EXT_POWER_CNTL) {
+			do {
+				epcpr = __raw_readl(psc_base + EPCPR);
+			} while ((((epcpr >> domain) & 1) == 0));
+		}
+
+		pdctl = __raw_readl(psc_base + PDCTL + 4 * domain);
+		pdctl |= 0x100;
+		__raw_writel(pdctl, psc_base + PDCTL + 4 * domain);
+
+		pdctl = __raw_readl(psc_base + PDCTL + 4 * domain);
+		pdctl |= PDCTL_EPCGOOD;
+		__raw_writel(pdctl, psc_base + PDCTL + 4 * domain);
+	} else {
+		ptcmd = 1 << domain;
+		__raw_writel(ptcmd, psc_base + PTCMD);
+	}
+
+	do {
+		ptstat = __raw_readl(psc_base + PTSTAT);
+	} while (!(((ptstat >> domain) & 1) == 0) && (count--));
+
+	if (!count)
+		goto err;
+
+	count = STATE_TRANS_MAX_COUNT;
+	do {
+		mdstat = __raw_readl(psc_base + MDSTAT + 4 * id);
+	} while (!((mdstat & MDSTAT_STATE_MASK) == next_state) && (count--));
+err:
+	return;
+}
+
+static int clk_psc_is_enabled(struct clk_hw *hw)
+{
+	struct clk_psc *psc = to_clk_psc(hw);
+	struct clk_davinci_psc_data *psc_data = psc->psc_data;
+	u32 mdstat;
+
+	mdstat = __raw_readl(psc_data->base + MDSTAT + 4 * psc_data->lpsc);
+	/* if clocked, state can be "Enable" or "SyncReset" */
+	return (mdstat & BIT(12)) ? 1 : 0;
+}
+
+static int clk_psc_enable(struct clk_hw *hw)
+{
+	struct clk_psc *psc = to_clk_psc(hw);
+	struct clk_davinci_psc_data *psc_data = psc->psc_data;
+	unsigned long flags = 0;
+
+	if (psc->lock)
+		spin_lock_irqsave(psc->lock, flags);
+
+	clk_psc_config(psc_data->base, psc_data->domain, psc_data->lpsc,
+			1, psc_data->psc_flags);
+
+	if (psc->lock)
+		spin_unlock_irqrestore(psc->lock, flags);
+
+	return 0;
+}
+
+static void clk_psc_disable(struct clk_hw *hw)
+{
+	struct clk_psc *psc = to_clk_psc(hw);
+	struct clk_davinci_psc_data *psc_data = psc->psc_data;
+	unsigned long flags = 0;
+
+	if (psc->lock)
+		spin_lock_irqsave(psc->lock, flags);
+
+	clk_psc_config(psc_data->base, psc_data->domain, psc_data->lpsc,
+			0, psc_data->psc_flags);
+
+	if (psc->lock)
+		spin_unlock_irqrestore(psc->lock, flags);
+}
+
+static const struct clk_ops clk_psc_ops = {
+	.enable = clk_psc_enable,
+	.disable = clk_psc_disable,
+	.is_enabled = clk_psc_is_enabled,
+};
+
+/**
+ * clk_register_davinci_psc - register davinci psc clock
+ * @dev: device that is registering this clock
+ * @name: name of this clock
+ * @parent_name: name of clock's parent
+ * @psc_data: platform data to configure this clock
+ * @lock: spinlock used by this clock
+ */
+struct clk *clk_register_davinci_psc(struct device *dev, const char *name,
+			const char *parent_name,
+			struct clk_davinci_psc_data *psc_data,
+			spinlock_t *lock)
+{
+	struct clk_init_data init;
+	struct clk_psc *psc;
+	struct clk *clk;
+
+	psc = kzalloc(sizeof(*psc), GFP_KERNEL);
+	if (!psc)
+		return ERR_PTR(-ENOMEM);
+
+	init.name = name;
+	init.ops = &clk_psc_ops;
+	init.flags = psc_data->flags;
+	init.parent_names = (parent_name ? &parent_name : NULL);
+	init.num_parents = (parent_name ? 1 : 0);
+
+	psc->psc_data = psc_data;
+	psc->lock = lock;
+	psc->hw.init = &init;
+
+	clk = clk_register(NULL, &psc->hw);
+	if (IS_ERR(clk))
+		kfree(psc);
+
+	return clk;
+}
+EXPORT_SYMBOL_GPL(clk_register_davinci_psc);
+
+#ifdef CONFIG_OF
+#define NUM_GPSC	2
+struct reg_psc {
+	u32 phy_base;
+	u32 size;
+	void __iomem *io_base;
+};
+
+static struct reg_psc psc_addr[NUM_GPSC];
+
+/**
+ * of_davinci_psc_clk_init - initialize davinci psc clock through DT
+ * @node: device tree node for this clock
+ * @lock: spinlock used by this clock
+ */
+void __init of_davinci_psc_clk_init(struct device_node *node, spinlock_t *lock)
+{
+	const char *parent_name, *status = NULL, *base_flags = NULL;
+	struct clk_davinci_psc_data *data;
+	const char *clk_name = node->name;
+	u32 gpsc = 0, lpsc = 0, pd = 0;
+	struct resource res;
+	struct clk *clk;
+	int rc;
+
+	data = kzalloc(sizeof(*data), GFP_KERNEL);
+	WARN_ON(!data);
+
+	if (of_address_to_resource(node, 0, &res)) {
+		pr_err("psc_clk_init - no reg property defined\n");
+		goto out;
+	}
+
+	of_property_read_u32(node, "gpsc", &gpsc);
+	of_property_read_u32(node, "lpsc", &lpsc);
+	of_property_read_u32(node, "pd", &pd);
+
+	if (gpsc >= NUM_GPSC) {
+		pr_err("psc_clk_init - no reg property defined\n");
+		goto out;
+	}
+
+	of_property_read_string(node,
+			"clock-output-names", &clk_name);
+	parent_name = of_clk_get_parent_name(node, 0);
+	WARN_ON(!parent_name);
+
+	/* Expected that same phy_base is used for all psc clocks of
+	 * a give gpsc. So ioremap is done only once.
+	 */
+	if (psc_addr[gpsc].phy_base) {
+		if (psc_addr[gpsc].phy_base != res.start) {
+			pr_err("Different psc base for same GPSC\n");
+			goto out;
+		}
+	} else {
+		psc_addr[gpsc].phy_base = res.start;
+		psc_addr[gpsc].io_base =
+			ioremap(res.start, resource_size(&res));
+	}
+
+	WARN_ON(!psc_addr[gpsc].io_base);
+	data->base = psc_addr[gpsc].io_base;
+	data->lpsc = lpsc;
+	data->gpsc = gpsc;
+	data->domain = pd;
+
+	of_property_read_string_index(node, "base-flags", 0, &base_flags);
+	if (base_flags && !strcmp(base_flags, "ignore-unused"))
+		data->flags = CLK_IGNORE_UNUSED;
+
+	if (of_property_read_bool(node, "ti,psc-lreset"))
+		data->psc_flags |= PSC_LRESET;
+	if (of_property_read_bool(node, "ti,psc-force"))
+		data->psc_flags |= PSC_FORCE;
+
+	clk = clk_register_davinci_psc(NULL, clk_name, parent_name,
+				data, lock);
+
+	if (clk) {
+		of_clk_add_provider(node, of_clk_src_simple_get, clk);
+
+		rc = of_property_read_string(node, "status", &status);
+		if (status && !strcmp(status, "enabled"))
+			clk_prepare_enable(clk);
+		return;
+	}
+	pr_err("psc_clk_init - error registering psc clk %s\n", node->name);
+out:
+	kfree(data);
+	return;
+}
+EXPORT_SYMBOL_GPL(of_davinci_psc_clk_init);
+#endif
diff --git a/drivers/clk/davinci/davinci-clock.c b/drivers/clk/davinci/davinci-clock.c
new file mode 100644
index 0000000..3ac6306
--- /dev/null
+++ b/drivers/clk/davinci/davinci-clock.c
@@ -0,0 +1,407 @@
+/*
+ * Clock initialization code for DaVinci devices
+ *
+ * Copyright (C) 2006-2012 Texas Instruments.
+ * Copyright (C) 2008-2009 Deep Root Systems, LLC
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+#include <linux/init.h>
+#include <linux/clk-provider.h>
+#include <linux/clkdev.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/of_address.h>
+#include <linux/platform_data/clk-davinci-pll.h>
+#include <linux/platform_data/clk-keystone-pll.h>
+#include <linux/platform_data/clk-davinci-psc.h>
+#include <linux/platform_data/davinci-clock.h>
+#include <linux/of.h>
+
+static DEFINE_SPINLOCK(_lock);
+
+#ifndef CONFIG_OF
+struct clk *davinci_lookup_clk(struct davinci_clk_lookup *clocks,
+				const char *con_id)
+{
+	struct davinci_clk_lookup *c;
+
+	for (c = clocks; c->_clk; c++) {
+		if (c->con_id && !strcmp(c->con_id, con_id))
+			return c->clk;
+	}
+	return NULL;
+}
+
+#ifdef	CONFIG_CLK_DAVINCI_PLL
+static void register_davinci_pll_clk(struct davinci_clk_lookup *c,
+			struct clk_davinci_pll_data *pll_data)
+{
+
+	WARN_ON(!pll_data->phy_pllm);
+	pll_data->pllm = ioremap(pll_data->phy_pllm, 4);
+	WARN_ON(!pll_data->pllm);
+	if (pll_data->phy_prediv) {
+		pll_data->prediv = ioremap(pll_data->phy_prediv, 4);
+		WARN_ON(!pll_data->prediv);
+	}
+	if (pll_data->phy_postdiv) {
+		pll_data->postdiv = ioremap(pll_data->phy_postdiv, 4);
+		WARN_ON(!pll_data->postdiv);
+	}
+	c->clk = clk_register_davinci_pll(NULL,
+			c->_clk->name, c->_clk->parent->name,
+			pll_data);
+}
+#else
+static void register_davinci_pll_clk(struct davinci_clk_lookup *c,
+			struct clk_davinci_pll_data *pll_data)
+{
+	return;
+}
+#endif
+
+#ifdef	CONFIG_CLK_KEYSTONE_PLL
+static void register_keystone_pll_clk(struct davinci_clk_lookup *c,
+			struct clk_keystone_pll_data *pll_data)
+{
+	WARN_ON(!pll_data->phy_pllm);
+	pll_data->pllm = ioremap(pll_data->phy_pllm, 4);
+	WARN_ON(!pll_data->pllm);
+	WARN_ON(!pll_data->phy_main_pll_ctl0);
+	pll_data->main_pll_ctl0 =
+		ioremap(pll_data->phy_main_pll_ctl0, 4);
+	WARN_ON(!pll_data->main_pll_ctl0);
+	c->clk = clk_register_keystone_pll(NULL,
+			c->_clk->name, c->_clk->parent->name,
+			 pll_data);
+}
+#else
+static void register_keystone_pll_clk(struct davinci_clk_lookup *c,
+			struct clk_keystone_pll_data *pll_data)
+{
+	return;
+}
+#endif
+
+int __init davinci_common_clk_init(struct davinci_clk_lookup *clocks,
+				struct davinci_dev_lookup *dev_clk_lookups,
+				u8 num_gpscs, u32 *psc_bases)
+{
+	void __iomem **base = NULL, *reg;
+	struct davinci_clk_lookup *c;
+	struct davinci_clk *_clk;
+	unsigned long rate;
+	int i, skip;
+
+	WARN_ON(!num_gpscs);
+	WARN_ON(psc_bases == NULL);
+
+	base = kzalloc(sizeof(void __iomem *) * num_gpscs, GFP_KERNEL);
+	WARN_ON(!base);
+	for (i = 0; i < num_gpscs; i++) {
+		base[i] = ioremap(psc_bases[i], SZ_4K);
+		WARN_ON(!base[i]);
+	}
+
+	for (c = clocks; c->_clk; c++) {
+		skip = 0;
+		_clk = c->_clk;
+
+		WARN_ON(!_clk->clk_data.data);
+		switch (_clk->type) {
+		case DAVINCI_FIXED_RATE_CLK:
+		{
+			struct clk_fixed_rate_data *data = _clk->clk_data.fixed_rate;
+
+			if (data->recalc)
+				rate = data->recalc(0);
+			else
+				rate = data->rate;
+
+			c->clk = clk_register_fixed_rate(NULL, _clk->name,
+					NULL, data->flags, rate);
+			break;
+		}
+		case KEYSTONE_MAIN_PLL_CLK:
+		{
+			struct clk_keystone_pll_data *data =
+					_clk->clk_data.keystone_pll;
+
+			register_keystone_pll_clk(c, data);
+			break;
+		}
+		case DAVINCI_MAIN_PLL_CLK:
+		{
+			struct clk_davinci_pll_data *data =
+					_clk->clk_data.davinci_pll;
+
+			register_davinci_pll_clk(c, data);
+			break;
+		}
+		case DAVINCI_PRG_DIV_CLK:
+		{
+			struct clk_divider_data *data = _clk->clk_data.pll_div;
+
+			/* This is a PLL derived clock with divider specified by
+			 * div_reg in pll_div_data.
+			 */
+			reg = ioremap(data->div_reg, 4);
+			WARN_ON(!reg);
+			c->clk = clk_register_divider(NULL, _clk->name,
+					_clk->parent->name, data->flags,
+					reg, data->shift, data->width,
+					data->divider_flags, &_lock);
+			break;
+		}
+		case DAVINCI_PSC_CLK:
+		{
+			struct clk_davinci_psc_data *data = _clk->clk_data.psc;
+
+			WARN_ON(!base);
+			WARN_ON(data->gpsc >= num_gpscs);
+			data->base = base[data->gpsc];
+			c->clk = clk_register_davinci_psc(NULL, _clk->name,
+					_clk->parent->name, data, &_lock);
+			break;
+		}
+		case DAVINCI_MUX_CLK:
+		{
+			struct clk_mux_data *data = _clk->clk_data.mux;
+
+			WARN_ON(!data->phys_base);
+			reg = ioremap(data->phys_base, 4);
+			WARN_ON(!reg);
+			c->clk = clk_register_mux(NULL, _clk->name,
+					data->parents, data->num_parents,
+					data->flags, reg, data->shift,
+					data->width, data->mux_flags, &_lock);
+			break;
+		}
+		case DAVINCI_FIXED_FACTOR_CLK:
+		{
+			struct clk_fixed_factor_data *data
+						 = _clk->clk_data.fixed_factor;
+
+			WARN_ON(!data->mult);
+			WARN_ON(!data->div);
+			c->clk = clk_register_fixed_factor(NULL, _clk->name,
+					_clk->parent->name, data->flags,
+					data->mult, data->div);
+			break;
+		}
+		default:
+			skip = 1;
+			pr_warn("Unknown clock - %s\n", _clk->name);
+		}
+
+		if (!skip) {
+			WARN_ON(!c->clk);
+			if (clk_register_clkdev(c->clk,
+					c->con_id, c->dev_id) < 0) {
+				pr_err("Error in registering clkdev, %s\n",
+					_clk->name);
+			}
+			/* Enable ALWAYS_ENABLED clocks */
+			if (_clk->flags & ALWAYS_ENABLED)
+				clk_prepare_enable(c->clk);
+		}
+	}
+
+	if (dev_clk_lookups) {
+		struct davinci_dev_lookup *c;
+		struct clk *clk;
+
+		for (c = dev_clk_lookups; c->con_id; c++) {
+			/* register the clock lookup table */
+			clk = davinci_lookup_clk(clocks, c->con_id);
+			WARN_ON(!clk);
+
+			for (i = 0; i < c->num_devs; i++) {
+				if (clk_register_clkdev(clk,
+					c->lookups[i].con_id,
+					c->lookups[i].dev_id) < 0) {
+					pr_err("Error in registering clkdev" \
+						" for dev_id %s\n",
+						c->lookups[i].dev_id);
+				}
+			}
+		}
+	}
+	return 0;
+}
+#else
+
+static void __init pll_div_clk_init(struct device_node *node)
+{
+	const char *parent_name;
+	void __iomem *reg;
+	u32 shift, width;
+	struct clk *clk;
+
+	reg = of_iomap(node, 0);
+	WARN_ON(!reg);
+
+	parent_name = of_clk_get_parent_name(node, 0);
+	WARN_ON(!parent_name);
+
+	if (of_property_read_u32(node, "shift", &shift)) {
+		pr_err("pll_div_clk_init - no shift value defined\n");
+		return;
+	}
+
+	if (of_property_read_u32(node, "width", &width)) {
+		pr_err("pll_div_clk_init - no width value defined\n");
+		return;
+	}
+
+	clk = clk_register_divider(NULL, node->name, parent_name, 0, reg, shift,
+				 width, 0, &_lock);
+
+	if (clk)
+		of_clk_add_provider(node, of_clk_src_simple_get, clk);
+	else
+		pr_err("pll_div_clk_init - error in registering mux clk %s\n",
+			node->name);
+}
+
+/* These will go away once there is support in clk-mux for DT */
+static void __init of_fixed_factor_clk_setup(struct device_node *node)
+{
+	const char *parent_name;
+	struct clk *clk;
+	u32 mult, div;
+
+	parent_name = of_clk_get_parent_name(node, 0);
+	WARN_ON(!parent_name);
+
+	if (of_property_read_u32(node, "mult", &mult)) {
+		pr_err("of_fixed_factor_clk_setup - no mult value defined\n");
+		return;
+	}
+
+	if (of_property_read_u32(node, "div", &div)) {
+		pr_err("of_fixed_factor_clk_setup - no div value defined\n");
+		return;
+	}
+
+	WARN_ON(!mult);
+	WARN_ON(!div);
+	clk = clk_register_fixed_factor(NULL, node->name, parent_name, 0,
+					mult, div);
+	if (clk)
+		of_clk_add_provider(node, of_clk_src_simple_get, clk);
+	else
+		pr_err("error registering fixed factor clk %s\n", node->name);
+}
+
+/* These will go away once there is support in clk-mux for DT */
+static void __init main_pll_mux_clk_init(struct device_node *node)
+{
+	const char *parents[2];
+	void __iomem *reg;
+	u32 shift, width;
+	struct clk *clk;
+
+	reg = of_iomap(node, 0);
+	WARN_ON(!reg);
+
+	parents[0] = of_clk_get_parent_name(node, 0);
+	WARN_ON(!parents[0]);
+	parents[1] = of_clk_get_parent_name(node, 1);
+	WARN_ON(!parents[1]);
+
+	if (of_property_read_u32(node, "shift", &shift)) {
+		pr_err("main_pll_mux_clk_init - no shift value defined\n");
+		return;
+	}
+
+	if (of_property_read_u32(node, "width", &width)) {
+		pr_err("main_pll_mux_clk_init - no width value defined\n");
+		return;
+	}
+
+	clk = clk_register_mux(NULL, node->name, (const char **)&parents,
+				ARRAY_SIZE(parents) , 0, reg, shift, width,
+				0, &_lock);
+
+	if (clk)
+		of_clk_add_provider(node, of_clk_src_simple_get, clk);
+	else
+		pr_err("main_pll_mux_clk_init - error registe mux clk %s\n",
+			 node->name);
+}
+
+static void __init of_davinci_psc_clk_setup(struct device_node *node)
+{
+	of_davinci_psc_clk_init(node, &_lock);
+}
+
+static const __initconst struct of_device_id clk_match[] = {
+	{ .compatible = "fixed-clock", .data = of_fixed_clk_setup, },
+	{ .compatible = "fixed-clock-factor", .data =
+					 of_fixed_factor_clk_setup, },
+	{ .compatible = "keystone,main-pll-clk", .data =
+					of_keystone_pll_clk_init, },
+	{ .compatible = "davinci,main-pll-mux-clk", .data =
+						main_pll_mux_clk_init, },
+	{ .compatible = "davinci,pll-divider-clk", .data = pll_div_clk_init, },
+	{ .compatible = "davinci,psc-clk", .data = of_davinci_psc_clk_setup, },
+	{}
+};
+
+static const __initconst struct of_device_id clk_psc_match[] = {
+	{ .compatible = "davinci,psc-clk", .data = of_davinci_psc_clk_setup, },
+	{}
+};
+
+void __init davinci_of_clk_init()
+{
+	/* initialize clk providers from device tree */
+	of_clk_init(clk_match);
+}
+
+void __init davinci_add_clkdev(struct davinci_clk_lookup *clocks)
+{
+	struct device_node *np;
+
+	/*
+	 * When drivers use device nodes for provider clock info, this will
+	 * become obsolete. Until then we need a way to register clk devices.
+	 * for dt incompatible device drivers.
+	 */
+	if (clocks == NULL)
+		return;
+
+	for_each_matching_node(np, clk_psc_match) {
+		struct davinci_clk_lookup *c;
+		struct davinci_clk *_clk;
+		const char *clk_name;
+		struct clk *clk;
+
+		clk_name = np->name;
+		of_property_read_string(np,
+			"clock-output-names", &clk_name);
+		/* get clk through provider */
+		clk = of_clk_get(np, 0);
+		if (clk) {
+			for (c = clocks; c->_clk; c++) {
+				_clk = c->_clk;
+				if (!strcmp(_clk->name, clk_name) &&
+					(clk_register_clkdev(clk, c->con_id,
+						 c->dev_id) < 0)) {
+					pr_err("Error register clkdev,%s\n",
+						clk_name);
+					break;
+				}
+			}
+		} else {
+			pr_err("Error getting clk provider info, %s\n",
+				clk_name);
+		}
+	}
+}
+#endif
diff --git a/drivers/clk/keystone/Kconfig b/drivers/clk/keystone/Kconfig
new file mode 100644
index 0000000..c0ea97a
--- /dev/null
+++ b/drivers/clk/keystone/Kconfig
@@ -0,0 +1,6 @@
+config  CLK_KEYSTONE_PLL
+	bool "Keystone Main PLL clock"
+	---help---
+	  Selects the clock driver for Keystone Main PLL. This clock
+	  hardware is found on TI c6x based SoCs
+
diff --git a/drivers/clk/keystone/Makefile b/drivers/clk/keystone/Makefile
new file mode 100644
index 0000000..6ae8ae9
--- /dev/null
+++ b/drivers/clk/keystone/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_CLK_KEYSTONE_PLL)	+= clk-keystone-pll.o
diff --git a/drivers/clk/keystone/clk-keystone-pll.c b/drivers/clk/keystone/clk-keystone-pll.c
new file mode 100644
index 0000000..7cad58b
--- /dev/null
+++ b/drivers/clk/keystone/clk-keystone-pll.c
@@ -0,0 +1,170 @@
+/*
+ * Main PLL clk driver for Keystone devices
+ *
+ * Copyright (C) 2012 Texas Instruments.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/of_address.h>
+#include <linux/of.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/platform_data/clk-keystone-pll.h>
+
+/**
+ * struct clk_pll - DaVinci Main pll clock
+ * @hw: clk_hw for the pll
+ * @pll_data: PLL driver specific data
+ */
+struct clk_pll {
+	struct clk_hw hw;
+	struct clk_keystone_pll_data *pll_data;
+};
+
+#define to_clk_pll(_hw) container_of(_hw, struct clk_pll, hw)
+
+static unsigned long clk_pllclk_recalc(struct clk_hw *hw,
+					unsigned long parent_rate)
+{
+	struct clk_pll *pll = to_clk_pll(hw);
+	struct clk_keystone_pll_data *pll_data = pll->pll_data;
+	unsigned long rate = parent_rate;
+	u32  mult = 0, prediv, postdiv, val;
+
+	/*
+	 * get bits 0-5 of multiplier from pllctrl PLLM register
+	 * if has_pllctrl is non zero */
+	if (pll_data->has_pllctrl) {
+		val = __raw_readl(pll_data->pllm);
+		mult = (val & pll_data->pllm_lower_mask);
+	}
+
+	/* bit6-12 of PLLM is in Main PLL control register */
+	val = __raw_readl(pll_data->pll_ctl0);
+	mult |= ((val & pll_data->pllm_upper_mask)
+			>> pll_data->pllm_upper_shift);
+	prediv = (val & pll_data->plld_mask);
+	postdiv = pll_data->fixed_postdiv;
+
+	rate /= (prediv + 1);
+	rate = (rate * (mult + 1));
+	rate /= postdiv;
+
+	if (pll_data->has_pllctrl) {
+		pr_notice("main_pll_clk rate is %ld, postdiv = %d, mult = %d," \
+				"prediv = %d\n", rate, postdiv, mult, prediv);
+	} else {
+		pr_notice("pll_clk parent_rate(%ld Hz), rate(%ld Hz)," \
+				"postdiv = %d, mult = %d, prediv = %d\n",
+				parent_rate, rate, postdiv, mult, prediv);
+	}
+	return rate;
+}
+
+static const struct clk_ops clk_pll_ops = {
+	.recalc_rate = clk_pllclk_recalc,
+};
+
+struct clk *clk_register_keystone_pll(struct device *dev, const char *name,
+			const char *parent_name,
+			struct clk_keystone_pll_data *pll_data)
+{
+	struct clk_init_data init;
+	struct clk_pll *pll;
+	struct clk *clk;
+
+	if (!pll_data)
+		return ERR_PTR(-ENODEV);
+
+	pll = kzalloc(sizeof(*pll), GFP_KERNEL);
+	if (!pll)
+		return ERR_PTR(-ENOMEM);
+
+	init.name = name;
+	init.ops = &clk_pll_ops;
+	init.flags = 0;
+	init.parent_names = (parent_name ? &parent_name : NULL);
+	init.num_parents = (parent_name ? 1 : 0);
+
+	pll->pll_data	= pll_data;
+	pll->hw.init = &init;
+
+	clk = clk_register(NULL, &pll->hw);
+	if (IS_ERR(clk))
+		goto out;
+
+	return clk;
+out:
+	kfree(pll);
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(clk_register_keystone_pll);
+
+#ifdef CONFIG_OF
+void __init of_keystone_pll_clk_init(struct device_node *node)
+{
+	struct clk_keystone_pll_data *pll_data;
+	const char *parent_name;
+	struct clk *clk;
+	int temp;
+
+	pll_data = kzalloc(sizeof(*pll_data), GFP_KERNEL);
+	WARN_ON(!pll_data);
+
+	parent_name = of_clk_get_parent_name(node, 0);
+
+	if (of_find_property(node, "pll_has_pllctrl", &temp)) {
+		/* PLL is controlled by the pllctrl */
+		pll_data->has_pllctrl = 1;
+		pll_data->pllm = of_iomap(node, 0);
+		WARN_ON(!pll_data->pllm);
+
+		pll_data->pll_ctl0 = of_iomap(node, 1);
+		WARN_ON(!pll_data->pll_ctl0);
+
+		if (of_property_read_u32(node, "pllm_lower_mask",
+			&pll_data->pllm_lower_mask))
+			goto out;
+
+	} else {
+		/* PLL is controlled by the ctrl register */
+		pll_data->has_pllctrl = 0;
+		pll_data->pll_ctl0 = of_iomap(node, 0);
+	}
+
+	if (of_property_read_u32(node, "pllm_upper_mask",
+			&pll_data->pllm_upper_mask))
+		goto out;
+
+	if (of_property_read_u32(node, "pllm_upper_shift",
+			&pll_data->pllm_upper_shift))
+		goto out;
+
+	if (of_property_read_u32(node, "plld_mask", &pll_data->plld_mask))
+		goto out;
+
+	if (of_property_read_u32(node, "fixed_postdiv",
+					&pll_data->fixed_postdiv))
+		goto out;
+
+	clk = clk_register_keystone_pll(NULL, node->name, parent_name,
+					 pll_data);
+	if (clk) {
+		of_clk_add_provider(node, of_clk_src_simple_get, clk);
+		return;
+	}
+out:
+	pr_err("of_keystone_pll_clk_init - error initializing clk %s\n",
+		 node->name);
+	kfree(pll_data);
+}
+EXPORT_SYMBOL_GPL(of_keystone_pll_clk_init);
+#endif
diff --git a/include/linux/platform_data/clk-davinci-pll.h b/include/linux/platform_data/clk-davinci-pll.h
new file mode 100644
index 0000000..4c2920b
--- /dev/null
+++ b/include/linux/platform_data/clk-davinci-pll.h
@@ -0,0 +1,54 @@
+/*
+ * TI DaVinci clk-pll driver platform data definitions
+ *
+ * Copyright (C) 2006-2012 Texas Instruments.
+ * Copyright (C) 2008-2009 Deep Root Systems, LLC
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef __CLK_DAVINCI_PLL_H
+#define __CLK_DAVINCI_PLL_H
+
+/* PLL flags */
+#define CLK_DAVINCI_PLL_HAS_PREDIV			BIT(0)
+#define CLK_DAVINCI_PLL_HAS_POSTDIV			BIT(1)
+
+struct clk_davinci_pll_data {
+	/* physical addresses set by platform code */
+	u32 phy_pllm;
+	/* if PLL has a prediv register this should be non zero */
+	u32 phy_prediv;
+	/* if PLL has a postdiv register this should be non zero */
+	u32 phy_postdiv;
+	/* mapped addresses. should be initialized by  */
+	void __iomem *pllm;
+	void __iomem *prediv;
+	void __iomem *postdiv;
+	u32 pllm_mask;
+	u32 prediv_mask;
+	u32 postdiv_mask;
+	u32 num;
+	/* framework flags */
+	u32 flags;
+	/* pll flags */
+	u32 pll_flags;
+       /* use this value for prediv */
+	u32 fixed_prediv;
+	/* multiply PLLM by this factor. By default most SOC set this to zero
+	 * that translates to a multiplier of 1 and incrementer of 1.
+	 * To override default, set this factor
+	 */
+	u32 pllm_multiplier;
+};
+
+extern struct clk *clk_register_davinci_pll(struct device *dev,
+			const char *name, const char *parent_name,
+			struct clk_davinci_pll_data *pll_data);
+#endif /* CLK_DAVINCI_PLL_H */
diff --git a/include/linux/platform_data/clk-davinci-psc.h b/include/linux/platform_data/clk-davinci-psc.h
new file mode 100644
index 0000000..1b17993
--- /dev/null
+++ b/include/linux/platform_data/clk-davinci-psc.h
@@ -0,0 +1,58 @@
+/*
+ *  DaVinci Power & Sleep Controller (PSC) clk driver platform data
+ *
+ *  Copyright (C) 2006-2012 Texas Instruments.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+#ifndef __CLK_DAVINCI_PSC_H
+#define __CLK_DAVINCI_PSC_H
+
+/* PSC flags */
+/* Disable state is SwRstDisable */
+#define CLK_DAVINCI_PSC_SWRSTDISABLE	BIT(0)
+/* Force module state transtition */
+#define CLK_DAVINCI_PSC_FORCE		BIT(1)
+/* PSC has external power control available (for DM6446 SoC) */
+#define CLK_DAVINCI_PSC_HAS_EXT_POWER_CNTL	BIT(2)
+struct clk_davinci_psc_data {
+	/* base address of the PSC */
+	void __iomem *base;
+	/* framework flags */
+	u32	flags;
+	/* psc specific flags */
+	u32	psc_flags;
+	u8	lpsc;
+	u8	gpsc;
+	u8	domain;
+};
+
+extern struct clk *clk_register_davinci_psc(struct device *dev,
+			const char *name, const char *parent_name,
+			struct clk_davinci_psc_data *psc_data,
+			spinlock_t *lock);
+
+#ifdef CONFIG_OF
+extern void __init of_davinci_psc_clk_init(struct device_node *node,
+			 spinlock_t *lock);
+#endif
+#endif /* __CLK_DAVINCI_PSC_H */
diff --git a/include/linux/platform_data/clk-keystone-pll.h b/include/linux/platform_data/clk-keystone-pll.h
new file mode 100644
index 0000000..4fe750a
--- /dev/null
+++ b/include/linux/platform_data/clk-keystone-pll.h
@@ -0,0 +1,55 @@
+/*
+ * TI Keyston clk-pll driver platform data definitions
+ *
+ * Copyright (C) 2012 Texas Instruments.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef __CLK_KEYSTONE_PLL_H
+#define __CLK_KEYSTONE_PLL_H
+
+struct clk_keystone_pll_data {
+	/*
+	 * Has pllctrl. If set to non zero, lower 6 bits of multiplier is in
+	 * pllm register of pll controller, else it is in the pll_ctrl0
+	 * (bit 11-6)
+	 */
+	unsigned char has_pllctrl;
+	/*
+	 * physical address of PLLM in pll controller. Used when has_pllctrl is
+	 * non zero
+	 */
+	u32 phy_pllm;
+	/*
+	 * Physical address of PLL ctrl0. This could be that of Main PLL or Any
+	 * other PLLs in the device such as ARM PLL, DDR PLL or PA PLL available
+	 * on keystone2. These PLLs are controlled by this register. Main PLL is
+	 * controlled by a PLL controller.
+	 */
+	u32 phy_pll_ctl0;
+	/* mapped addresses of the above registers. */
+	void __iomem *pllm;
+	void __iomem *pll_ctl0;
+	u32 pllm_lower_mask;
+	u32 pllm_upper_mask;
+	u32 pllm_upper_shift;
+	u32 plld_mask;
+	/* use this value for postdiv */
+	u32 fixed_postdiv;
+};
+
+extern struct clk *clk_register_keystone_pll(struct device *dev,
+			const char *name, const char *parent_name,
+			struct clk_keystone_pll_data *pll_data);
+
+#ifdef CONFIG_OF
+extern void __init of_keystone_pll_clk_init(struct device_node *node);
+#endif
+#endif /* CLK_KEYSTONE_PLL_H */
diff --git a/include/linux/platform_data/davinci-clock.h b/include/linux/platform_data/davinci-clock.h
new file mode 100644
index 0000000..e940853
--- /dev/null
+++ b/include/linux/platform_data/davinci-clock.h
@@ -0,0 +1,149 @@
+/*
+ * TI DaVinci Clock definitions -  Contains Macros and Types used for
+ * defining various clocks on a DaVinci SoC
+ *
+ * Copyright (C) 2012 Texas Instruments
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef __DAVINCI_CLOCK_H
+#define __DAVINCI_CLOCK_H
+
+#include <linux/types.h>
+
+struct clk;
+
+#define CLK(dev, con, ck)	\
+	{			\
+		.dev_id = dev,	\
+		.con_id = con,	\
+		._clk = ck,	\
+	}			\
+
+/* general flags: */
+#define ALWAYS_ENABLED		BIT(0)
+
+/* configuration data for clk mux */
+struct clk_mux_data {
+	u32			flags;
+	u8			mux_flags;
+	u8			shift;
+	u8			width;
+	u8			num_parents;
+	const char		**parents;
+	u32			phys_base;
+};
+
+/* configuration data for PLL divider clock */
+struct clk_divider_data {
+	u32			flags;
+	u8			divider_flags;
+	u32                     div_reg;
+	/* H/W supported max rate */
+	unsigned long		maxrate;
+	/* Width and shift for divider clock register mask */
+	u8			shift;
+	u8			width;
+};
+
+/* configuration data for fixed factor clocks. Some clocks in DaVinci are just
+ * duplicate clock pins that can be represented by this using a factor of 1
+ * for multiplier and divider
+ */
+struct clk_fixed_factor_data {
+	u32			flags;
+	u32			mult;
+	u32			div;
+};
+
+/* configuration data for fixed ref clock */
+struct clk_fixed_rate_data {
+	u32			flags;
+	unsigned long		rate;
+	/* where a register has input clock rate settings this function
+	 * is used to read that value from SoC specific code
+	 */
+	unsigned long		(*recalc)(unsigned long parent_rate);
+};
+
+/* forward declaration for other clock drivers */
+struct clk_davinci_pll_data;
+struct clk_keystone_pll_data;
+struct clk_psc_data;
+
+enum davinci_clk_type {
+	DAVINCI_MAIN_PLL_CLK,
+	KEYSTONE_MAIN_PLL_CLK,
+	DAVINCI_FIXED_RATE_CLK,
+	/* Use programmable divider */
+	DAVINCI_PRG_DIV_CLK,
+	/* Use fixed divider and multiplier */
+	DAVINCI_FIXED_FACTOR_CLK,
+	DAVINCI_PSC_CLK,
+	DAVINCI_MUX_CLK,
+};
+
+/* struct for defining DaVinci clocks for a SoC. Only one of the data ptr
+ * to be valid (non NULL). davinci_clk_init() in drivers/clk/davinci/clock.c
+ * check these ptr values to determine what clock register function to call
+ * to register a particular clock.
+ */
+struct davinci_clk {
+	const char			*name;
+	/* General flag for all drivers */
+	u32				flags;
+	struct davinci_clk		*parent;
+	enum davinci_clk_type		type;
+	/* one of these will be present in each SoC */
+	union {
+		/* root ref clock data */
+		struct clk_fixed_rate_data	*fixed_rate;
+		struct clk_davinci_pll_data	*davinci_pll;
+		struct clk_keystone_pll_data	*keystone_pll;
+		struct clk_divider_data		*pll_div;
+		struct clk_davinci_psc_data	*psc;
+		struct clk_mux_data		*mux;
+		struct clk_fixed_factor_data	*fixed_factor;
+		void				*data;
+	} clk_data;
+};
+
+/* struct for the DaVinci clock tables. */
+struct davinci_clk_lookup {
+	const char		*dev_id;
+	const char		*con_id;
+	struct davinci_clk      *_clk;
+	/* This saves the opaque clk ptr returned by clk_register() and is
+	 * saved to use later to register clkdevs for a specific clk node.
+	 */
+	struct clk		*clk;
+};
+
+/* struct for the DaVinci clkdev lookups. When several drivers uses the same
+ * clock, this structure is used to define a dev look up table that maps
+ * clkdevs to a clks node.
+ */
+struct davinci_dev_lookup {
+	const char		*con_id;
+	unsigned short		num_devs;
+	struct clk_lookup	*lookups;
+};
+
+/* clock init function for a DaVinci SoC (defined in drivers/clk/clock.c).
+ * This can also be used on other TI SoCs that has similar clock hardware.
+ */
+extern int davinci_common_clk_init(struct davinci_clk_lookup *clocks,
+				struct davinci_dev_lookup *dev_lookups,
+				u8 num_gpscs, u32 *psc_bases);
+#ifdef CONFIG_OF
+extern void davinci_add_clkdev(struct davinci_clk_lookup *clocks);
+extern void davinci_of_clk_init(void);
+#endif
+#endif
-- 
1.7.5.4

