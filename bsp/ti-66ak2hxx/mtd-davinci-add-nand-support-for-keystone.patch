From dc8cee6b49c819a7f312ff6d95c12f969b8dc119 Mon Sep 17 00:00:00 2001
From: Guoqing Jiang <Guoqing.Jiang@windriver.com>
Date: Thu, 5 Sep 2013 11:11:25 +0800
Subject: [PATCH 16/20] mtd: davinci: add nand support for keystone

Update davinci nand code to make it works on keystone platform.

Refer to the following commits from arago tree
git://arago-project.org/git/projects/linux-keystone.git releases/03.00.00.11/master

7be11e1 mtd: davinci-nand: add dts property for NAND_NO_SUBPAGE_WRITE option
0893a72 nand: davinci: add support for 4K page size nand devices
d249bef mtd: davinci - remove DaVinci architecture depedency
f694dec memory: davinci - add aemif controller platform driver
ec2a083 ARM: davinci: move platform_data definitions

Signed-off-by: Guoqing Jiang <Guoqing.Jiang@windriver.com>
---
 drivers/mtd/nand/Kconfig                        |   2 +-
 drivers/mtd/nand/davinci_nand.c                 | 109 +++++++++++++++++-------
 include/linux/platform_data/mtd-davinci-aemif.h |  28 ++++--
 include/linux/platform_data/mtd-davinci.h       |   3 -
 4 files changed, 101 insertions(+), 41 deletions(-)

diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
index 50543f1..8692441 100644
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -499,7 +499,7 @@ config MTD_NAND_SH_FLCTL
 
 config MTD_NAND_DAVINCI
         tristate "Support NAND on DaVinci SoC"
-        depends on ARCH_DAVINCI
+	select TI_DAVINCI_AEMIF
         help
 	  Enable the driver for NAND flash chips on Texas Instruments
 	  DaVinci processors.
diff --git a/drivers/mtd/nand/davinci_nand.c b/drivers/mtd/nand/davinci_nand.c
index c3e15a5..05d0d78 100644
--- a/drivers/mtd/nand/davinci_nand.c
+++ b/drivers/mtd/nand/davinci_nand.c
@@ -34,7 +34,6 @@
 #include <linux/mtd/partitions.h>
 #include <linux/slab.h>
 #include <linux/of_device.h>
-#include <linux/of.h>
 
 #include <linux/platform_data/mtd-davinci.h>
 #include <linux/platform_data/mtd-davinci-aemif.h>
@@ -74,7 +73,7 @@ struct davinci_nand_info {
 
 	uint32_t		core_chipsel;
 
-	struct davinci_aemif_timing	*timing;
+	struct davinci_aemif_cs_data	*cs_data;
 };
 
 static DEFINE_SPINLOCK(davinci_nand_lock);
@@ -520,6 +519,31 @@ static struct nand_ecclayout hwecc4_2048 __initconst = {
 	},
 };
 
+/* An ECC layout for using 4-bit ECC with large-page (4096bytes) flash,
+ * storing ten ECC bytes plus the manufacturer's bad block marker byte,
+ * and not overlapping the default BBT markers.
+ */
+static struct nand_ecclayout hwecc4_4096 __initconst = {
+          .eccbytes = 80,
+          .eccpos = {
+                  /* at the end of spare sector */
+                  48, 49, 50, 51, 52, 53, 54, 55, 56, 57,
+                  58, 59, 60, 61, 62, 63, 64, 65, 66, 67,
+                  68, 69, 70, 71, 72, 73, 74, 75, 76, 77,
+                  78, 79, 80, 81, 82, 83, 84, 85, 86, 87,
+                  88, 89, 90, 91, 92, 93, 94, 95, 96, 97,
+                  98, 99, 100, 101, 102, 103, 104, 105, 106, 107,
+                  108, 109, 110, 111, 112, 113, 114, 115, 116, 117,
+                  118, 119, 120, 121, 122, 123, 124, 125, 126, 127,
+                  },
+          .oobfree = {
+                  /* 2 bytes at offset 0 hold manufacturer badblock markers */
+                  {.offset = 2, .length = 46, },
+                  /* 5 bytes at offset 8 hold BBT markers */
+                  /* 8 bytes at offset 16 hold JFFS2 clean markers */
+         },
+};
+
 #if defined(CONFIG_OF)
 static const struct of_device_id davinci_nand_of_match[] = {
 	{.compatible = "ti,davinci-nand", },
@@ -573,11 +597,15 @@ static struct davinci_nand_pdata
 		if (of_find_property(pdev->dev.of_node,
 			"ti,davinci-nand-use-bbt", &len))
 			pdata->bbt_options = NAND_BBT_USE_FLASH;
+		if (of_find_property(pdev->dev.of_node,
+			"ti,davinci-no-subpage-write", &len))
+			pdata->options |= NAND_NO_SUBPAGE_WRITE;
 	}
 
 	return pdev->dev.platform_data;
 }
 #else
+#define davinci_nand_of_match NULL
 static struct davinci_nand_pdata
 	*nand_davinci_get_pdata(struct platform_device *pdev)
 {
@@ -606,7 +634,7 @@ static int __init nand_davinci_probe(struct platform_device *pdev)
 	if (pdev->id < 0 || pdev->id > 3)
 		return -ENODEV;
 
-	info = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);
+	info = kzalloc(sizeof(*info), GFP_KERNEL);
 	if (!info) {
 		dev_err(&pdev->dev, "unable to allocate memory\n");
 		ret = -ENOMEM;
@@ -623,11 +651,11 @@ static int __init nand_davinci_probe(struct platform_device *pdev)
 		goto err_nomem;
 	}
 
-	vaddr = devm_request_and_ioremap(&pdev->dev, res1);
-	base = devm_request_and_ioremap(&pdev->dev, res2);
+	vaddr = ioremap(res1->start, resource_size(res1));
+	base = ioremap(res2->start, resource_size(res2));
 	if (!vaddr || !base) {
 		dev_err(&pdev->dev, "ioremap failed\n");
-		ret = -EADDRNOTAVAIL;
+		ret = -EINVAL;
 		goto err_ioremap;
 	}
 
@@ -652,7 +680,6 @@ static int __init nand_davinci_probe(struct platform_device *pdev)
 	info->chip.options	= pdata->options;
 	info->chip.bbt_td	= pdata->bbt_td;
 	info->chip.bbt_md	= pdata->bbt_md;
-	info->timing		= pdata->timing;
 
 	info->ioaddr		= (uint32_t __force) vaddr;
 
@@ -717,7 +744,7 @@ static int __init nand_davinci_probe(struct platform_device *pdev)
 	}
 	info->chip.ecc.mode = ecc_mode;
 
-	info->clk = devm_clk_get(&pdev->dev, "aemif");
+	info->clk = clk_get(&pdev->dev, "aemif");
 	if (IS_ERR(info->clk)) {
 		ret = PTR_ERR(info->clk);
 		dev_dbg(&pdev->dev, "unable to get AEMIF clock, err %d\n", ret);
@@ -731,26 +758,21 @@ static int __init nand_davinci_probe(struct platform_device *pdev)
 		goto err_clk_enable;
 	}
 
-	/*
-	 * Setup Async configuration register in case we did not boot from
-	 * NAND and so bootloader did not bother to set it up.
-	 */
-	val = davinci_nand_readl(info, A1CR_OFFSET + info->core_chipsel * 4);
-
-	/* Extended Wait is not valid and Select Strobe mode is not used */
-	val &= ~(ACR_ASIZE_MASK | ACR_EW_MASK | ACR_SS_MASK);
-	if (info->chip.options & NAND_BUSWIDTH_16)
-		val |= 0x1;
+	if (info->chip.options & NAND_BUSWIDTH_16) {
+		info->cs_data =
+			davinci_aemif_get_abus_params(info->core_chipsel);
+		if (info->cs_data == NULL)
+			goto err_bus_config;
 
-	davinci_nand_writel(info, A1CR_OFFSET + info->core_chipsel * 4, val);
+		/* asize = 1 for 16bit bus */
+		info->cs_data->asize = 1;
+		ret = davinci_aemif_set_abus_params(info->core_chipsel,
+						info->cs_data);
 
-	ret = 0;
-	if (info->timing)
-		ret = davinci_aemif_setup_timing(info->timing, info->base,
-							info->core_chipsel);
-	if (ret < 0) {
-		dev_dbg(&pdev->dev, "NAND timing values setup fail\n");
-		goto err_timing;
+		if (ret < 0) {
+			dev_dbg(&pdev->dev, "NAND timing values setup fail\n");
+			goto err_bus_config;
+		}
 	}
 
 	spin_lock_irq(&davinci_nand_lock);
@@ -798,6 +820,11 @@ static int __init nand_davinci_probe(struct platform_device *pdev)
 			info->chip.ecc.mode = NAND_ECC_HW_OOB_FIRST;
 			goto syndrome_done;
 		}
+		if (chunks == 8) {
+			info->ecclayout = hwecc4_4096;
+			info->chip.ecc.mode = NAND_ECC_HW_OOB_FIRST;
+			goto syndrome_done;
+		}
 
 		/* 4KiB page chips are not yet supported. The eccpos from
 		 * nand_ecclayout cannot hold 80 bytes and change to eccpos[]
@@ -841,10 +868,12 @@ syndrome_done:
 	return 0;
 
 err_scan:
-err_timing:
+err_bus_config:
 	clk_disable_unprepare(info->clk);
 
 err_clk_enable:
+	clk_put(info->clk);
+
 	spin_lock_irq(&davinci_nand_lock);
 	if (ecc_mode == NAND_ECC_HW_SYNDROME)
 		ecc4_busy = false;
@@ -853,7 +882,13 @@ err_clk_enable:
 err_ecc:
 err_clk:
 err_ioremap:
+	if (base)
+		iounmap(base);
+	if (vaddr)
+		iounmap(vaddr);
+
 err_nomem:
+	kfree(info);
 	return ret;
 }
 
@@ -866,9 +901,15 @@ static int __exit nand_davinci_remove(struct platform_device *pdev)
 		ecc4_busy = false;
 	spin_unlock_irq(&davinci_nand_lock);
 
+	iounmap(info->base);
+	iounmap(info->vaddr);
+
 	nand_release(&info->mtd);
 
 	clk_disable_unprepare(info->clk);
+	clk_put(info->clk);
+
+	kfree(info);
 
 	return 0;
 }
@@ -878,12 +919,22 @@ static struct platform_driver nand_davinci_driver = {
 	.driver		= {
 		.name	= "davinci_nand",
 		.owner	= THIS_MODULE,
-		.of_match_table = of_match_ptr(davinci_nand_of_match),
+		.of_match_table = davinci_nand_of_match,
 	},
 };
 MODULE_ALIAS("platform:davinci_nand");
 
-module_platform_driver_probe(nand_davinci_driver, nand_davinci_probe);
+static int __init nand_davinci_init(void)
+{
+	return platform_driver_probe(&nand_davinci_driver, nand_davinci_probe);
+}
+module_init(nand_davinci_init);
+
+static void __exit nand_davinci_exit(void)
+{
+	platform_driver_unregister(&nand_davinci_driver);
+}
+module_exit(nand_davinci_exit);
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Texas Instruments");
diff --git a/include/linux/platform_data/mtd-davinci-aemif.h b/include/linux/platform_data/mtd-davinci-aemif.h
index 05b2934..b107a78 100644
--- a/include/linux/platform_data/mtd-davinci-aemif.h
+++ b/include/linux/platform_data/mtd-davinci-aemif.h
@@ -17,20 +17,32 @@
 #define ACR_ASIZE_MASK		0x3
 #define ACR_EW_MASK		BIT(30)
 #define ACR_SS_MASK		BIT(31)
+#define ASIZE_16BIT		1
 
-/* All timings in nanoseconds */
-struct davinci_aemif_timing {
+struct davinci_aemif_cs_data {
+	u8	cs;
+	u16	wstrobe;
+	u16	rstrobe;
 	u8	wsetup;
-	u8	wstrobe;
 	u8	whold;
-
 	u8	rsetup;
-	u8	rstrobe;
 	u8	rhold;
-
 	u8	ta;
+	u8	enable_ss;
+	u8	enable_ew;
+	u8	asize;
+};
+
+struct davinci_aemif_pdata {
+	u8	num_cs;
+	struct davinci_aemif_cs_data cs_data[4];
 };
 
-int davinci_aemif_setup_timing(struct davinci_aemif_timing *t,
-					void __iomem *base, unsigned cs);
+/* API to Get current Asynchrnous emif bus parameters */
+struct davinci_aemif_cs_data *davinci_aemif_get_abus_params(unsigned int cs);
+
+/* API to Set current Asynchrnous emif bus parameters */
+int davinci_aemif_set_abus_params(unsigned int cs,
+			struct davinci_aemif_cs_data *data);
+
 #endif
diff --git a/include/linux/platform_data/mtd-davinci.h b/include/linux/platform_data/mtd-davinci.h
index 1cf555a..df1fc66 100644
--- a/include/linux/platform_data/mtd-davinci.h
+++ b/include/linux/platform_data/mtd-davinci.h
@@ -82,9 +82,6 @@ struct davinci_nand_pdata {		/* platform_data */
 	/* Main and mirror bbt descriptor overrides */
 	struct nand_bbt_descr	*bbt_td;
 	struct nand_bbt_descr	*bbt_md;
-
-	/* Access timings */
-	struct davinci_aemif_timing	*timing;
 };
 
 #endif	/* __ARCH_ARM_DAVINCI_NAND_H */
-- 
1.8.4.93.g57e4c17

