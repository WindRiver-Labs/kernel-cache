From cd0c5d4eae4de1b47f2162922fc5a4c4515dfce1 Mon Sep 17 00:00:00 2001
From: TonyLiu <Bo.Liu@windriver.com>
Date: Mon, 27 Oct 2008 17:56:57 +0800
Subject: [PATCH] imx31lite_drivers_smc911x

MX31lite ethernet smc911x driver.

Signed-off-by: Tonyliu <Bo.Liu@windriver.com>
---
 drivers/net/Kconfig   |    3 +-
 drivers/net/smc911x.c |  112 +++++++++++++++++++++++++++++++++++++++++++++++-
 drivers/net/smc911x.h |   22 ++++++++++
 3 files changed, 133 insertions(+), 4 deletions(-)

diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index cd5867f..3d0e548 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -960,7 +960,8 @@ config SMC911X
 	tristate "SMSC LAN911[5678] support"
 	select CRC32
 	select MII
-	depends on ARCH_PXA || SUPERH || SH_MAGIC_PANEL_R2 || ARCH_OMAP24XX || ARCH_OMAP34XX
+	depends on ARCH_PXA || SUPERH || SH_MAGIC_PANEL_R2 || ARCH_OMAP24XX || ARCH_OMAP34XX \
+							|| MACH_MX31LITE
 	help
 	  This is a driver for SMSC's LAN911x series of Ethernet chipsets
 	  including the new LAN9115, LAN9116, LAN9117, and LAN9118.
diff --git a/drivers/net/smc911x.c b/drivers/net/smc911x.c
index c587162..379955c 100644
--- a/drivers/net/smc911x.c
+++ b/drivers/net/smc911x.c
@@ -241,7 +241,11 @@ static void smc911x_reset(struct net_device *dev)
 	/* Reset the FIFO level and flow control settings */
 	SMC_SET_HW_CFG(lp, (lp->tx_fifo_kb & 0xF) << 16);
 //TODO: Figure out what appropriate pause time is
+#ifdef CONFIG_MACH_MX31LITE
+	SMC_SET_FLOW(lp, FLOW_FCPT_ALT_ | FLOW_FCEN_);
+#else
 	SMC_SET_FLOW(lp, FLOW_FCPT_ | FLOW_FCEN_);
+#endif
 	SMC_SET_AFC_CFG(lp, lp->afc_cfg);
 
 
@@ -820,6 +824,7 @@ static int smc911x_phy_reset(struct net_device *dev, int phy)
 	return reg & PMT_CTRL_PHY_RST_;
 }
 
+#ifndef CONFIG_MACH_MX31LITE
 /*
  * smc911x_phy_powerdown - powerdown phy
  * @dev: net device
@@ -837,6 +842,7 @@ static void smc911x_phy_powerdown(struct net_device *dev, int phy)
 	bmcr |= BMCR_PDOWN;
 	SMC_SET_PHY_BMCR(lp, phy, bmcr);
 }
+#endif
 
 /*
  * smc911x_phy_check_media - check the media status and adjust BMCR
@@ -1018,7 +1024,13 @@ static irqreturn_t smc911x_interrupt(int irq, void *dev_id)
 	spin_lock_irqsave(&lp->lock, flags);
 
 	/* Spurious interrupt check */
+#ifdef CONFIG_MACH_MX31LITE
+	if (!lp->waking_up &&
+			(SMC_GET_IRQ_CFG(lp) &
+			 (INT_CFG_IRQ_INT_ | INT_CFG_IRQ_EN_)) !=
+#else
 	if ((SMC_GET_IRQ_CFG(lp) & (INT_CFG_IRQ_INT_ | INT_CFG_IRQ_EN_)) !=
+#endif
 		(INT_CFG_IRQ_INT_ | INT_CFG_IRQ_EN_)) {
 		spin_unlock_irqrestore(&lp->lock, flags);
 		return IRQ_NONE;
@@ -1040,6 +1052,13 @@ static irqreturn_t smc911x_interrupt(int irq, void *dev_id)
 		status &= mask;
 		if (!status)
 			break;
+#ifdef CONFIG_MACH_MX31LITE
+		if (status & INT_STS_PME_INT_) {
+			SMC_ACK_INT(lp, INT_STS_PME_INT_);
+			mask &= ~INT_STS_PME_INT_;
+			lp->waking_up = 0;
+		}
+#endif
 
 		/* Handle SW interrupt condition */
 		if (status & INT_STS_SW_INT_) {
@@ -1423,10 +1442,10 @@ smc911x_open(struct net_device *dev)
 		PRINTK("%s: no valid ethernet hw addr\n", __FUNCTION__);
 		return -EINVAL;
 	}
-
+#ifndef CONFIG_MACH_MX31LITE
 	/* reset the hardware */
 	smc911x_reset(dev);
-
+#endif
 	/* Configure the PHY, initialize the link state */
 	smc911x_phy_configure(&lp->phy_configure);
 
@@ -1462,7 +1481,9 @@ static int smc911x_close(struct net_device *dev)
 		 * smc911x_phy_configure are pending.
 		 */
 		cancel_work_sync(&lp->phy_configure);
+#ifndef CONFIG_MACH_MX31LITE
 		smc911x_phy_powerdown(dev, lp->mii.phy_id);
+#endif
 	}
 
 	if (lp->pending_tx_skb) {
@@ -1715,6 +1736,23 @@ static int smc911x_ethtool_geteeprom_len(struct net_device *dev)
 	 return SMC911X_EEPROM_LEN;
 }
 
+#ifdef CONFIG_MACH_MX31LITE
+static void smc911x_ethtool_getwol(struct net_device *dev,
+		struct ethtool_wolinfo *wol)
+{
+	wol->wolopts = WAKE_PHY | WAKE_UCAST | WAKE_MAGIC;
+}
+static int smc911x_ethtool_setwol(struct net_device *dev,
+		struct ethtool_wolinfo *wol)
+{
+		struct smc911x_local *lp = netdev_priv(dev);
+		if ((wol->wolopts & ~(WAKE_PHY | WAKE_UCAST | WAKE_MAGIC)) != 0)
+			return -EOPNOTSUPP;
+		lp->wolopts = wol->wolopts;
+		return 0;
+}
+#endif
+
 static const struct ethtool_ops smc911x_ethtool_ops = {
 	.get_settings	 = smc911x_ethtool_getsettings,
 	.set_settings	 = smc911x_ethtool_setsettings,
@@ -1728,6 +1766,10 @@ static const struct ethtool_ops smc911x_ethtool_ops = {
 	.get_eeprom_len = smc911x_ethtool_geteeprom_len,
 	.get_eeprom = smc911x_ethtool_geteeprom,
 	.set_eeprom = smc911x_ethtool_seteeprom,
+#ifdef CONFIG_MACH_MX31LITE
+	.get_wol = smc911x_ethtool_getwol,
+	.set_wol = smc911x_ethtool_setwol,
+#endif
 };
 
 /*
@@ -2159,16 +2201,68 @@ static int smc911x_drv_suspend(struct platform_device *dev, pm_message_t state)
 	struct net_device *ndev = platform_get_drvdata(dev);
 	struct smc911x_local *lp = netdev_priv(ndev);
 
+#ifdef CONFIG_MACH_MX31LITE
+	int phyaddr = lp->mii.phy_id;
+	int sts = 0;
+#endif
+
 	DBG(SMC_DEBUG_FUNC, "--> %s\n", __FUNCTION__);
 	if (ndev) {
 		if (netif_running(ndev)) {
+#ifdef CONFIG_MACH_MX31LITE
+			netif_stop_queue(ndev);
+#endif
 			netif_device_detach(ndev);
+#ifndef CONFIG_MACH_MX31LITE
 			smc911x_shutdown(ndev);
+#else
+			SMC_SET_INT_EN(lp, 0);
+#endif
 #if POWER_DOWN
+#ifndef CONFIG_MACH_MX31LITE
 			/* Set D2 - Energy detect only setting */
 			SMC_SET_PMT_CTRL(lp, 2<<12);
+#else /*CONFIG_MACH_MX31LITE*/
+            lp->waking_up = 1;
+			if (lp->wolopts) {
+				SMC_SET_INT_EN(lp, INT_EN_PME_INT_EN_);
+				if (lp->wolopts & WAKE_MAGIC) {
+					/* Set D1 */
+					SMC_SET_WUCSR(lp, WUCSR_MPEN_);
+					SMC_SET_PMT_CTRL(lp,
+							PMT_CTRL_PM_MODE_D1_ |
+							PMT_CTRL_WOL_EN_ |
+							PMT_CTRL_PME_EN_);
+				}
+				if (lp->wolopts & WAKE_UCAST) {
+					/* Set D1 */
+					SMC_SET_WUCSR(lp, WUCSR_GUE_);
+					SMC_SET_PMT_CTRL(lp,
+							PMT_CTRL_PM_MODE_D1_ |
+							PMT_CTRL_WOL_EN_ |
+							PMT_CTRL_PME_EN_);
+				}
+				if (lp->wolopts & WAKE_PHY) {
+					/* Set D2 */
+					SMC_SET_INT_EN(lp, INT_EN_PME_INT_EN_);
+					SMC_SET_PMT_CTRL(lp,
+							PMT_CTRL_PM_MODE_D2_ |
+							PMT_CTRL_ED_EN_);
+					SMC_GET_PHY_CTRL_STS(lp, phyaddr, sts);
+					sts |= MODE_CTRL_STS_EDPWRDOWN_;
+					SMC_SET_PHY_CTRL_STS(lp, phyaddr, sts);
+				}
+			} else {
+				/* Set D2, energy detect only */
+				smc911x_shutdown(ndev);
+				SMC_SET_INT_EN(lp, INT_EN_PME_INT_EN_);
+				SMC_SET_PMT_CTRL(lp, PMT_CTRL_PM_MODE_D2_ |
+						PMT_CTRL_ED_EN_);
+			}
+#endif /* CONFIG_MACH_MX31LITE */
 #endif
 		}
+
 	}
 	return 0;
 }
@@ -2180,13 +2274,25 @@ static int smc911x_drv_resume(struct platform_device *dev)
 	DBG(SMC_DEBUG_FUNC, "--> %s\n", __FUNCTION__);
 	if (ndev) {
 		struct smc911x_local *lp = netdev_priv(ndev);
-
+#ifdef CONFIG_MACH_MX31LITE
+		lp->waking_up = 0;
+#endif
 		if (netif_running(ndev)) {
+#ifndef CONFIG_MACH_MX31LITE
+			smc911x_reset(ndev);
+			smc911x_enable(ndev);
+#endif
 			smc911x_reset(ndev);
 			smc911x_enable(ndev);
 			if (lp->phy_type != 0)
 				smc911x_phy_configure(&lp->phy_configure);
+#ifdef CONFIG_MACH_MX31LITE
+			smc911x_enable(ndev);
+			netif_device_attach(ndev);
+			netif_start_queue(ndev);
+#else
 			netif_device_attach(ndev);
+#endif
 		}
 	}
 	return 0;
diff --git a/drivers/net/smc911x.h b/drivers/net/smc911x.h
index b4d69c7..fdf03d4 100644
--- a/drivers/net/smc911x.h
+++ b/drivers/net/smc911x.h
@@ -52,6 +52,10 @@
   #define SMC_USE_32BIT		1
   #define SMC_IRQ_SENSE		IRQF_TRIGGER_LOW
   #define SMC_MEM_RESERVED	1
+#elif defined (CONFIG_MACH_MX31LITE)
+  #define SMC_USE_16BIT     0
+  #define SMC_USE_32BIT     1
+  #define SMC_IRQ_SENSE		IRQF_TRIGGER_LOW
 #else
 /*
  * Default configuration
@@ -110,6 +114,13 @@ struct smc911x_local {
 #ifdef SMC_DYNAMIC_BUS_CONFIG
 	struct smc911x_platdata cfg;
 #endif
+
+#ifdef CONFIG_MACH_MX31LITE
+	/* expect wake-on-lan interrupt */
+	int waking_up;
+	/* wake-on-lan options */
+	int wolopts;
+#endif
 };
 
 /*
@@ -479,6 +490,12 @@ smc_pxa_dma_outsl(struct smc911x_local *lp, u_long physaddr,
 
 #define PMT_CTRL		(0x84)
 #define	PMT_CTRL_PM_MODE_		(0x00003000)  /* Self Clearing */
+
+#ifdef CONFIG_MACH_MX31LITE
+#define		PMT_CTRL_PM_MODE_D2_		(0x00002000)
+#define		PMT_CTRL_PM_MODE_D1_		(0x00001000)
+#endif
+
 #define	PMT_CTRL_PHY_RST_		(0x00000400)  /* Self Clearing */
 #define	PMT_CTRL_WOL_EN_		(0x00000200)  /* R/W */
 #define	PMT_CTRL_ED_EN_			(0x00000100)  /* R/W */
@@ -605,6 +622,11 @@ smc_pxa_dma_outsl(struct smc911x_local *lp, u_long physaddr,
 
 #define FLOW			(0x08)	  /* R/W */
 #define FLOW_FCPT_			(0xFFFF0000)
+
+#ifdef CONFIG_MACH_MX31LITE
+#define FLOW_FCPT_ALT_		(0x000F0000)
+#endif
+
 #define FLOW_FCPASS_			(0x00000004)
 #define FLOW_FCEN_			(0x00000002)
 #define FLOW_FCBSY_			(0x00000001)
-- 
1.5.5.1

