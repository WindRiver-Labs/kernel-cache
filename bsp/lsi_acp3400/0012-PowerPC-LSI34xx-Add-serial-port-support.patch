From 66b5119538ec31ba43cb977c0b77551533c343e2 Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Wed, 27 Apr 2011 11:13:41 +0800
Subject: [PATCH 12/27] PowerPC:LSI34xx:Add serial port support

LSI ACP34xx boards implement 2 pl011 serial ports. This patch update
pl011 driver to support the device on LSI ACP34xx board, including
IO routines and timer facility.

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/serial/amba-pl011.c |   71 +++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 71 insertions(+), 0 deletions(-)

diff --git a/drivers/serial/amba-pl011.c b/drivers/serial/amba-pl011.c
index f6ae388..e39b1ff 100644
--- a/drivers/serial/amba-pl011.c
+++ b/drivers/serial/amba-pl011.c
@@ -59,6 +59,11 @@
 #include <asm/sizes.h>
 #endif
 
+#ifdef CONFIG_ACPX1
+#define writew(b, addr) writel(b, addr)
+#define readw(addr) readl(addr)
+#endif
+
 #define UART_NR			14
 
 #define SERIAL_AMBA_MAJOR	204
@@ -85,6 +90,13 @@ struct uart_amba_port {
 #endif
 };
 
+struct pl011_platform_data {
+#ifdef CONFIG_ACPX1
+	u32 clkfreq;
+#endif
+};
+
+
 /* There is by now at least one vendor with differing details, so handle it */
 struct vendor_data {
 	unsigned int		ifls;
@@ -388,7 +400,11 @@ static int pl011_startup(struct uart_port *port)
 	if (retval)
 		goto out;
 
+#ifndef CONFIG_ACPX1
 	uap->port.uartclk = clk_get_rate(uap->clk);
+#else
+	/*The clock frequency on ACP34xx already load at probe routine*/
+#endif
 
 	/*
 	 * Allocate the IRQ
@@ -482,11 +498,47 @@ pl011_set_termios(struct uart_port *port, struct ktermios *termios,
 	unsigned long flags;
 	unsigned int baud, quot;
 
+#ifdef CONFIG_ACPX1
+	unsigned short ibrd, fbrd;
+#endif
 	/*
 	 * Ask the core to calculate the divisor for us.
 	 */
 	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16);
+#ifndef CONFIG_ACPX1
 	quot = port->uartclk * 4 / baud;
+#else
+	/*
+	 * The following forumla is from the ARM document (ARM DDI 0183E).
+	 *
+	 * Baud Rate Divisor = (Uart Clock / (16 * Baud Rate))
+	 *
+	 * Baud Rate Divisor is then split into integral and fractional
+	 * parts.  The IBRD value is simply the itegral part.  The FBRD is
+	 * calculated as follows.
+	 *
+	 * FBRD = fractional part of the Baud Rate Divisor * 64 + 0.5
+	 *
+	 * The fractional part of the Baud Rate Divisor can be represented as
+	 * follows.
+	 *
+	 * (Uart Clock % (16 * baud_rate)) / (16 * baud_rate)
+	 *
+	 * As long as the division isn't done till the end.  So, the above *
+	 * 64 + 0.5 is the FBRD.	 Also note that x/y + 1/2 = (2x+y)/2y.
+	 * This leads to
+	 *
+	 * ((Uart Clock % (16 * baud_rate)) * 64 * 2 + (16 * baud_rate))
+	 * ---------------------------------------------------------------------
+	 * 2 * (16 * baud_rate)
+	 */
+	ibrd = (port->uartclk >> 4) / baud ;
+	fbrd = (port->uartclk >> 4) % baud ;
+	fbrd *= 128;
+	fbrd += (16 * baud);
+	fbrd /= (2 * (16 * baud));
+	quot = (ibrd << 6)|(fbrd & 0x3f);
+#endif
 
 	switch (termios->c_cflag & CSIZE) {
 	case CS5:
@@ -754,7 +806,11 @@ static int __init pl011_console_setup(struct console *co, char *options)
 	if (!uap)
 		return -ENODEV;
 
+#ifndef CONFIG_ACPX1
 	uap->port.uartclk = clk_get_rate(uap->clk);
+#else
+	/*The clock frequency on ACP34xx already load at probe routine*/
+#endif
 
 	if (options)
 		uart_parse_options(options, &baud, &parity, &bits, &flow);
@@ -800,6 +856,7 @@ static int pl011_probe(
 	struct uart_amba_port *uap;
 	void __iomem *base;
 	int i, ret;
+	struct pl011_platform_data *pl011_data = dev->platform_data;
 
 	for (i = 0; i < ARRAY_SIZE(amba_ports); i++)
 		if (amba_ports[i] == NULL)
@@ -827,6 +884,9 @@ static int pl011_probe(
 		ret = PTR_ERR(uap->clk);
 		goto unmap;
 	}
+#ifdef CONFIG_ACPX1
+	uap->port.uartclk = pl011_data->clkfreq;
+#endif
 
 	uap->ifls = vendor->ifls;
 	uap->port.dev = dev;
@@ -958,6 +1018,17 @@ static int pl011_of_probe(struct of_device *dev,
 	int ret;
 	struct resource res;
 	int irq;
+#ifdef CONFIG_ACPX1
+	u32 *pfreq;
+	struct pl011_platform_data pl011_data;
+	pfreq = (u32 *)of_get_property(dev->node, "clock-frequency", NULL);
+	if (!pfreq)
+		return -ENODEV;
+	pl011_data.clkfreq = *pfreq;
+	dev->dev.platform_data = &pl011_data;
+#else
+	dev->dev.platform_data = NULL;
+#endif
 
 	ret = of_address_to_resource(dev->node, 0, &res);
 	if (ret)
-- 
1.7.0.5

