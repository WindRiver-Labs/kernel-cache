From 29bae0ca1afb1cfc992fb14fa35cf7398f7e4206 Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Wed, 13 Apr 2011 12:14:32 +0800
Subject: [PATCH 16/27] PowePC:ACP34xx:add ci13612 usb host driver

The patch adds ci13612 usb host driver.

Based on the vendor drop lsi-patch-2.8.1.7 (06/08).

Signed-off-by: Fei Wu <fei.wu@windriver.com>

Move device specific routine to echi-PPC-of driver. The code added
in this patch will take effect when found usb controller compatible
to "ci13612-ehci".

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/usb/host/ehci-ci13612.h |   51 ++++++++++++++++++++++
 drivers/usb/host/ehci-ppc-of.c  |   91 ++++++++++++++++++++++++++++++++++++++-
 2 files changed, 141 insertions(+), 1 deletions(-)
 create mode 100644 drivers/usb/host/ehci-ci13612.h

diff --git a/drivers/usb/host/ehci-ci13612.h b/drivers/usb/host/ehci-ci13612.h
new file mode 100644
index 0000000..f2c5eaa
--- /dev/null
+++ b/drivers/usb/host/ehci-ci13612.h
@@ -0,0 +1,51 @@
+/*
+ * System definitions
+ */
+/*
+ * Host interface registers
+ */
+
+/* define CI13612 USB registers here */
+#define CI13612_USB_BASE	((unsigned) hcd->regs)
+
+#define USB_ID			(CI13612_USB_BASE + 0x0000)
+#define USB_HWGENERAL		(CI13612_USB_BASE + 0x0004)
+#define USB_HWHOST		(CI13612_USB_BASE + 0x0008)
+#define USB_HWDEVICE		(CI13612_USB_BASE + 0x000C)
+#define USB_HWTXBUF		(CI13612_USB_BASE + 0x0010)
+#define USB_HWRXBUF		(CI13612_USB_BASE + 0x0014)
+#define USB_GPTIMER0LD		(CI13612_USB_BASE + 0x0080)
+#define USB_GPTIMER0CTRL	(CI13612_USB_BASE + 0x0084)
+#define USB_GPTIMER1LD		(CI13612_USB_BASE + 0x0088)
+#define USB_GPTIMER1CTRL	(CI13612_USB_BASE + 0x008c)
+#define USB_SBUSCFG		(CI13612_USB_BASE + 0x0090)
+
+#define USB_CAPLENGTH		(CI13612_USB_BASE + 0x0100) /* 8 bit */
+#define USB_HCIVERSION		(CI13612_USB_BASE + 0x0102) /* 16 bit */
+#define USB_HCSPARAMS		(CI13612_USB_BASE + 0x0104)
+#define USB_HCCPARAMS		(CI13612_USB_BASE + 0x0108)
+#define USB_DCIVERSION		(CI13612_USB_BASE + 0x0120) /* 16 bit */
+#define USB_DCCPARAMS		(CI13612_USB_BASE + 0x0124)
+#define USB_USBCMD		(CI13612_USB_BASE + 0x0140)
+#define USB_USBSTS		(CI13612_USB_BASE + 0x0144)
+#define USB_USBINTR		(CI13612_USB_BASE + 0x0148)
+#define USB_FRINDEX		(CI13612_USB_BASE + 0x014C)
+#define USB_DEVICEADDR		(CI13612_USB_BASE + 0x0154)
+#define USB_ENDPOINTLISTADDR	(CI13612_USB_BASE + 0x0158)
+#define USB_TTCTRL		(CI13612_USB_BASE + 0x015C)
+#define USB_BURSTSIZE		(CI13612_USB_BASE + 0x0160)
+#define USB_TXFILLTUNING	(CI13612_USB_BASE + 0x0164)
+#define USB_ICUSB		(CI13612_USB_BASE + 0x016C)
+#define USB_ULPI_VIEWPORT	(CI13612_USB_BASE + 0x0170)
+#define USB_ENDPTNAK		(CI13612_USB_BASE + 0x0178)
+#define USB_ENDPTNAKEN		(CI13612_USB_BASE + 0x017C)
+#define USB_CONFIGFLAG		(CI13612_USB_BASE + 0x0180)
+#define USB_PORTSC		(CI13612_USB_BASE + 0x0184)
+#define USB_OTGSC		(CI13612_USB_BASE + 0x01A4)
+#define USB_USBMODE		(CI13612_USB_BASE + 0x01A8)
+#define USB_ENDPTSETUPSTAT	(CI13612_USB_BASE + 0x01AC)
+#define USB_ENDPTPRIME		(CI13612_USB_BASE + 0x01B0)
+#define USB_ENDPTFLUSH		(CI13612_USB_BASE + 0x01B4)
+#define USB_ENDPTSTAT		(CI13612_USB_BASE + 0x01B8)
+#define USB_ENDPTCOMPLETE	(CI13612_USB_BASE + 0x01BC)
+#define USB_ENDPTCTRL(n)	(CI13612_USB_BASE + 0x01C0 + (4 * (n)))
diff --git a/drivers/usb/host/ehci-ppc-of.c b/drivers/usb/host/ehci-ppc-of.c
index 5c2fbd1..b934230 100644
--- a/drivers/usb/host/ehci-ppc-of.c
+++ b/drivers/usb/host/ehci-ppc-of.c
@@ -17,6 +17,89 @@
 #include <linux/of.h>
 #include <linux/of_platform.h>
 
+#include "ehci-ci13612.h"
+
+static void ci13612_usb_setup(struct usb_hcd *hcd)
+{
+	int USB_TXFIFOTHRES, VUSB_HS_TX_BURST;
+
+	VUSB_HS_TX_BURST = inl(USB_HWTXBUF) & 0x0f;
+	USB_TXFIFOTHRES = (inl(USB_TXFILLTUNING) & 0x3f0000) >> 16;
+
+	printk(KERN_INFO "ehci-ci13612 (ci13612_usb_setup): "
+			 "VUSB_HS_TX_BURST = 0x%x, USB_TXFIFOTHRES = 0x%x\n",
+			 VUSB_HS_TX_BURST, USB_TXFIFOTHRES);
+
+	return;
+}
+
+/* called after powerup, by probe or system-pm "wakeup" */
+static int ehci_ci13612_reinit(struct ehci_hcd *ehci)
+{
+	ci13612_usb_setup(ehci_to_hcd(ehci));
+	ehci_port_power(ehci, 0);
+
+	return 0;
+}
+
+static int ci13612_ehci_init(struct usb_hcd *hcd)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	int retval = 0;
+	int len;
+
+	/* EHCI registers start at offset 0x100 */
+	ehci->caps = hcd->regs + 0x100;
+	ehci->regs = hcd->regs + 0x100
+		+ HC_LENGTH(ehci_readl(ehci, &ehci->caps->hc_capbase));
+	len = HC_LENGTH(ehci_readl(ehci, &ehci->caps->hc_capbase));
+
+	/* configure other settings */
+	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
+	hcd->has_tt = 1;
+
+	ehci->sbrn = 0x20;
+
+	/* reset and halt controller */
+	ehci_reset(ehci);
+
+	/* data structure init */
+	retval = ehci_init(hcd);
+	if (retval)
+		return retval;
+	hcd->self.sg_tablesize = 0;
+
+	retval = ehci_ci13612_reinit(ehci);
+
+	return retval;
+}
+
+static int ci13612_ehci_run(struct usb_hcd *hcd)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	u32 port_status;
+	unsigned burst_size;
+	int retval;
+
+	port_status = ehci_readl(ehci, &ehci->regs->port_status[0]);
+	printk(KERN_INFO "ehci_run: port_status = 0x%x\n", port_status);
+	if (port_status & 0x100) {
+		printk(KERN_ERR "USB port is in reset status, not able to "
+				"change host controller status to run\n");
+		return -EFAULT;
+	}
+
+	retval = ehci_run(hcd);
+	if (retval)
+		return retval;
+
+	burst_size = ehci_readl(ehci, &ehci->regs->reserved[1]);
+	burst_size = (burst_size & 0xffff00ff) | 0x4000;	/* TXPBURST */
+	ehci_writel(ehci, burst_size, &ehci->regs->reserved[1]);
+
+	return 0;
+}
+
 /* called during probe() after chip reset completes */
 static int ehci_ppc_of_setup(struct usb_hcd *hcd)
 {
@@ -36,7 +119,7 @@ static int ehci_ppc_of_setup(struct usb_hcd *hcd)
 }
 
 
-static const struct hc_driver ehci_ppc_of_hc_driver = {
+static struct hc_driver ehci_ppc_of_hc_driver = {
 	.description		= hcd_name,
 	.product_desc		= "OF EHCI",
 	.hcd_priv_size		= sizeof(struct ehci_hcd),
@@ -126,6 +209,12 @@ ehci_hcd_ppc_of_probe(struct of_device *op, const struct of_device_id *match)
 	if (rv)
 		return rv;
 
+	np = of_find_compatible_node(NULL, NULL, "ci13612-ehci");
+	if (np != NULL) {
+		ehci_ppc_of_hc_driver.reset = ci13612_ehci_init;
+		ehci_ppc_of_hc_driver.start = ci13612_ehci_run;
+	}
+
 	hcd = usb_create_hcd(&ehci_ppc_of_hc_driver, &op->dev, "PPC-OF USB");
 	if (!hcd)
 		return -ENOMEM;
-- 
1.7.0.5

