From aacbbfa113af2f743f7f7ad2c4bf75b6a25b2df4 Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Mon, 18 Apr 2011 13:24:09 +0800
Subject: [PATCH 26/27] PowerPc/47x: Adding PCI-E support for LSI ACP34xx based SOC.

Add support for PCI-e on the LSI ACP34xx boards.

Extract from vendor drop patch lsi-patch 3.8.1.12.

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 arch/powerpc/kernel/pci-common.c   |   13 +
 arch/powerpc/platforms/44x/Kconfig |    1 +
 arch/powerpc/sysdev/ppc4xx_pci.c   |  802 ++++++++++++++++++++++++++++++++++++
 drivers/pci/probe.c                |    8 +
 4 files changed, 824 insertions(+), 0 deletions(-)

diff --git a/arch/powerpc/kernel/pci-common.c b/arch/powerpc/kernel/pci-common.c
index d4b8d86..364f408 100644
--- a/arch/powerpc/kernel/pci-common.c
+++ b/arch/powerpc/kernel/pci-common.c
@@ -1114,7 +1114,20 @@ void __devinit pcibios_setup_bus_devices(struct pci_bus *bus)
 
 		/* Hook up default DMA ops */
 		sd->dma_ops = pci_dma_ops;
+#ifndef CONFIG_ACPX1
 		set_dma_offset(&dev->dev, PCI_DRAM_OFFSET);
+#else
+		{
+			/*
+			 * For ACP we need to set dma_data to the size of the
+			 * inbound window, which we have stuffed into
+			 * isa_mem_size
+			 */
+			struct pci_controller *hose = pci_bus_to_host(bus);
+			set_dma_offset(&dev->dev,
+				(dma_addr_t)hose->isa_mem_size);
+		}
+#endif
 
 		/* Additional platform DMA/iommu setup */
 		if (ppc_md.pci_dma_dev_setup)
diff --git a/arch/powerpc/platforms/44x/Kconfig b/arch/powerpc/platforms/44x/Kconfig
index b668010..021b713 100644
--- a/arch/powerpc/platforms/44x/Kconfig
+++ b/arch/powerpc/platforms/44x/Kconfig
@@ -172,6 +172,7 @@ config ACPX1
 	depends on ACP
 	default n
 	select PPC_CLOCK
+	select PPC4xx_PCI_EXPRESS
 	help
 	  This option enables support for the ACP on the X1 platform.
 
diff --git a/arch/powerpc/sysdev/ppc4xx_pci.c b/arch/powerpc/sysdev/ppc4xx_pci.c
index 106d767..25bc3b0 100644
--- a/arch/powerpc/sysdev/ppc4xx_pci.c
+++ b/arch/powerpc/sysdev/ppc4xx_pci.c
@@ -14,6 +14,7 @@
  * Copyright (c) 2005 Cisco Systems.  All rights reserved.
  * Roland Dreier <rolandd@cisco.com>
  *
+ * These patches add ACP3400 support signed-off-by: john.jacques@lsi.com
  */
 
 #undef DEBUG
@@ -26,6 +27,13 @@
 #include <linux/delay.h>
 #include <linux/slab.h>
 
+#ifdef CONFIG_ACPX1
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+
+#include <asm/ncr.h>
+#endif
+
 #include <asm/io.h>
 #include <asm/pci-bridge.h>
 #include <asm/machdep.h>
@@ -36,6 +44,9 @@
 #include "ppc4xx_pci.h"
 
 static int dma_offset_set;
+#ifdef CONFIG_ACPX1
+static u32 last_mpage;
+#endif
 
 #define U64_TO_U32_LOW(val)	((u32)((val) & 0x00000000ffffffffULL))
 #define U64_TO_U32_HIGH(val)	((u32)((val) >> 32))
@@ -45,6 +56,11 @@ static int dma_offset_set;
 #define RES_TO_U32_HIGH(val)	\
 	((sizeof(resource_size_t) > sizeof(u32)) ? U64_TO_U32_HIGH(val) : (0))
 
+#ifdef CONFIG_ACPX1
+#define ACPX1_PCIE_MPAGE_UPPER(n) (0x1010 + (n * 8))
+#define ACPX1_PCIE_MPAGE_LOWER(n) (0x1014 + (n * 8))
+#endif
+
 static inline int ppc440spe_revA(void)
 {
 	/* Catch both 440SPe variants, with and without RAID6 support */
@@ -89,6 +105,28 @@ static void fixup_ppc4xx_pci_bridge(struct pci_dev *dev)
 }
 DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID, fixup_ppc4xx_pci_bridge);
 
+#ifdef CONFIG_ACPX1
+static void __init fixup_acp_pci_bridge(struct pci_dev *dev)
+{
+	/* if we aren't a PCIe don't bother */
+	if (!pci_find_capability(dev, PCI_CAP_ID_EXP))
+		return ;
+
+	/*
+	 * Set the class appropriately for a bridge device
+	 */
+	dev->class = PCI_CLASS_BRIDGE_HOST << 8;
+
+	/*
+	 * Make the bridge transparent
+	 */
+	dev->transparent = 1;
+
+	return ;
+}
+DECLARE_PCI_FIXUP_HEADER(0x1000, PCI_ANY_ID, fixup_acp_pci_bridge);
+#endif
+
 static int __init ppc4xx_parse_dma_ranges(struct pci_controller *hose,
 					  void __iomem *reg,
 					  struct resource *res)
@@ -640,6 +678,9 @@ struct ppc4xx_pciex_port
 	struct resource		cfg_space;
 	struct resource		utl_regs;
 	void __iomem		*utl_base;
+#ifdef CONFIG_ACPX1
+	int	acpChipType;
+#endif
 };
 
 static struct ppc4xx_pciex_port *ppc4xx_pciex_ports;
@@ -865,6 +906,32 @@ static struct ppc4xx_pciex_hwops ppc440speB_pcie_hwops __initdata =
 	.setup_utl	= ppc440speB_pciex_init_utl,
 };
 
+#ifdef CONFIG_ACP
+static int __init
+acp_pciex_core_init(struct device_node *np)
+{
+	return 3;
+}
+
+static int
+acp_pciex_port_init_hw(struct ppc4xx_pciex_port *port)
+{
+	return 0;
+}
+
+static int
+acp_pciex_setup_utl(struct ppc4xx_pciex_port *port)
+{
+	return 0;
+}
+
+static struct ppc4xx_pciex_hwops acp_pcie_hwops __initdata = {
+	.core_init      = acp_pciex_core_init,
+	.port_init_hw   = acp_pciex_port_init_hw,
+	.setup_utl      = acp_pciex_setup_utl
+};
+
+#endif
 static int __init ppc460ex_pciex_core_init(struct device_node *np)
 {
 	/* Nothing to do, return 2 ports */
@@ -1080,6 +1147,11 @@ static int __init ppc4xx_pciex_check_core_init(struct device_node *np)
 	if (core_init++)
 		return 0;
 
+#ifdef CONFIG_ACPX1
+	if (of_device_is_compatible(np, "lsi,plb-pciex"))
+		ppc4xx_pciex_hwops = &acp_pcie_hwops;
+#endif
+
 #ifdef CONFIG_44x
 	if (of_device_is_compatible(np, "ibm,plb-pciex-440spe")) {
 		if (ppc440spe_revA())
@@ -1270,9 +1342,11 @@ static int ppc4xx_pciex_validate_bdf(struct ppc4xx_pciex_port *port,
 	    PCI_SLOT(devfn) != 0)
 		return PCIBIOS_DEVICE_NOT_FOUND;
 
+#ifndef CONFIG_ACPX1
 	/* Check if we have a link */
 	if ((bus->number != port->hose->first_busno) && !port->link)
 		return PCIBIOS_DEVICE_NOT_FOUND;
+#endif
 
 	return 0;
 }
@@ -1290,10 +1364,63 @@ static void __iomem *ppc4xx_pciex_get_config_base(struct ppc4xx_pciex_port *port
 		return (void __iomem *)port->hose->cfg_addr;
 
 	relbus = bus->number - (port->hose->first_busno + 1);
+
+#ifndef CONFIG_ACPX1
 	return (void __iomem *)port->hose->cfg_data +
 		((relbus  << 20) | (devfn << 12));
+#else
+	{
+		unsigned mpage;
+		u32 addr;
+		int dev, fn;
+		int cfg_type;
+
+		/*
+		 * Set MPAGE0 to map config access for this BDF
+		 */
+
+		dev = ((devfn & 0xf8) >> 3);
+		fn  = devfn & 0x7;
+
+		if (dev > 31)
+			return NULL;
+
+		/* v2 only supports fn0-3 and bus0-63 */
+		if (port->acpChipType == 1) {
+			if ((fn > 3) || (bus->number > 63))
+				return NULL;
+		}
+
+		if (relbus && (bus->number != bus->primary))
+			cfg_type = 1;
+		else
+			cfg_type = 0;
+
+		/* build the mpage register */
+		mpage = (bus->number << 11) |
+			(dev << 6) |
+			(cfg_type << 5) |
+			0x11;   /* enable MPAGE for configuration access */
+
+		/* the function number moved for X2 */
+		if (port->acpChipType < 2)
+			mpage |= (fn << 17);
+		else
+			mpage |= (fn << 19);
+
+		if (mpage != last_mpage) {
+			addr = ((u32) port->hose->cfg_addr)
+				+ ACPX1_PCIE_MPAGE_LOWER(7);
+			out_le32((u32 *) addr, mpage);
+			last_mpage = mpage;
+		}
+
+		return (void __iomem *)port->hose->cfg_data;
+	}
+#endif
 }
 
+#ifndef CONFIG_ACPX1
 static int ppc4xx_pciex_read_config(struct pci_bus *bus, unsigned int devfn,
 				    int offset, int len, u32 *val)
 {
@@ -1395,10 +1522,204 @@ static int ppc4xx_pciex_write_config(struct pci_bus *bus, unsigned int devfn,
 	return PCIBIOS_SUCCESSFUL;
 }
 
+#else
+static int
+ppc4xx_pciex_acp_read_config(struct pci_bus *bus, unsigned int devfn,
+			     int offset, int len, u32 *val)
+{
+	struct pci_controller *hose = (struct pci_controller *) bus->sysdata;
+	struct ppc4xx_pciex_port *port =
+		&ppc4xx_pciex_ports[hose->indirect_type];
+	void __iomem *addr;
+	u32 bus_addr;
+	u32 val32;
+	u32 mcsr;
+	int bo = offset & 0x3;
+	int rc = PCIBIOS_SUCCESSFUL;
+
+	BUG_ON(hose != port->hose);
+
+	if (ppc4xx_pciex_validate_bdf(port, bus, devfn) != 0)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	addr = ppc4xx_pciex_get_config_base(port, bus, devfn);
+
+	if (!addr) {
+		*val = 0;
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	}
+
+	/*
+	 * Reading from configuration space of non-existing device can
+	 * generate transaction errors. For the read duration we suppress
+	 * assertion of machine check exceptions to avoid those.
+	 */
+	mtmsr(mfmsr() & ~(MSR_ME));
+	__asm__ __volatile__("msync");
+
+	/*
+	 * addressing is different for local config access vs.
+	 * access through the mapped config space.
+	 */
+	if (bus->number == port->hose->first_busno) {
+		int wo = offset & 0xfffffffc;
+		bus_addr = (u32) addr + wo;
+
+	} else {
+
+	/*
+	 * mapped config space only supports 32-bit access
+	 *
+	 *  AXI address [3:0] is not used at all.
+	 *  AXI address[9:4] becomes register number.
+	 *  AXI address[13:10] becomes Ext. register number
+	 *  AXI address[17:14] becomes 1st DWBE for configuration read only.
+	 *  AXI address[29:27] is used to select one of 8 Mpage registers.
+	 */
+
+		bus_addr = (u32) addr + (offset << 2);
+
+		switch (len) {
+		case 1:
+			bus_addr |=  ((1 << bo)) << 14;
+			break;
+		case 2:
+			bus_addr |=  ((3 << bo)) << 14;
+			break;
+		default:
+			bus_addr |=  (0xf) << 14;
+			break;
+		}
+	}
+
+	/*
+	 * do the read
+	 */
+
+	val32 = in_le32((u32 *)bus_addr);
+
+	switch (len) {
+	case 1:
+		*val = (val32 >> (bo * 8)) & 0xff;
+		break;
+	case 2:
+		*val = (val32 >> (bo * 8)) & 0xffff;
+		break;
+	default:
+		*val = val32;
+		break;
+	}
+
+	__asm__ __volatile__("msync");
+
+	mcsr = mfspr(SPRN_MCSR);
+	if (mcsr != 0) {
+		mtspr(SPRN_MCSR, 0);
+		__asm__ __volatile__("msync");
+
+		pr_debug("acp_read_config  : bus=%3d [%3d..%3d] devfn=0x%04x"
+			 " offset=0x%04x len=%d, addr=0x%08x machine check!! "
+			 "0x%08x\n",
+			 bus->number, hose->first_busno, hose->last_busno,
+			 devfn, offset, len, bus_addr, mcsr);
+		*val = 0;
+		rc =  PCIBIOS_DEVICE_NOT_FOUND;
+	} else {
+		pr_debug("acp_read_config  : bus=%3d [%3d..%3d] devfn=0x%04x"
+			 " offset=0x%04x len=%d, addr=0x%08x val=0x%08x\n",
+			 bus->number, hose->first_busno, hose->last_busno,
+			 devfn, offset, len, bus_addr, *val);
+	}
+
+	/* re-enable machine checks */
+	mtmsr(mfmsr() | (MSR_ME));
+	__asm__ __volatile__("msync");
+
+	return rc;
+}
+
+static int ppc4xx_pciex_acp_write_config(struct pci_bus *bus,
+	unsigned int devfn,
+	int offset, int len, u32 val)
+{
+	struct pci_controller *hose = (struct pci_controller *) bus->sysdata;
+	struct ppc4xx_pciex_port *port =
+		&ppc4xx_pciex_ports[hose->indirect_type];
+	void __iomem *addr;
+	u32 bus_addr;
+	u32 val32;
+
+	if (ppc4xx_pciex_validate_bdf(port, bus, devfn) != 0)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	addr = ppc4xx_pciex_get_config_base(port, bus, devfn);
+
+    if (!addr)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	/*
+	 * addressing is different for local config access vs.
+	 * access through the mapped config space. We need to
+	 * translate the offset for mapped config access
+	 */
+	if (bus->number == port->hose->first_busno) {
+		/* the local ACP RC only supports 32-bit dword config access,
+		 * so if this is a byte or 16-bit word access we need to
+		 * perform a read-modify write
+		 */
+		if (len == 4) {
+			bus_addr = (u32) addr + offset;
+		} else {
+			int bs = ((offset & 0x3) * 8);
+
+			bus_addr = (u32) addr + (offset & 0xfffffffc);
+			val32 = in_le32((u32 *)bus_addr);
+
+
+			if (len == 2)
+				val32 = (val32 & ~(0xffff << bs)) |
+					((val & 0xffff) << bs);
+			else
+				val32 = (val32 & ~(0xff << bs)) |
+					((val & 0xff) << bs);
+
+			val = val32;
+			len = 4;
+		}
+	} else {
+		bus_addr = (u32) addr + (offset << 2) + (offset & 0x3);
+	}
+
+	pr_debug("acp_write_config : bus=%3d [%3d..%3d] devfn=0x%04x"
+		 " offset=0x%04x len=%d, addr=0x%08x val=0x%08x\n",
+		 bus->number, hose->first_busno, hose->last_busno,
+		 devfn, offset, len, bus_addr, val);
+
+	switch (len) {
+	case 1:
+		out_8((u8 *)(bus_addr), val);
+		break;
+	case 2:
+		out_le16((u16 *)(bus_addr), val);
+		break;
+	default:
+		out_le32((u32 *)(bus_addr), val);
+		break;
+	}
+
+	return PCIBIOS_SUCCESSFUL;
+}
+#endif
+
 static struct pci_ops ppc4xx_pciex_pci_ops =
 {
+#ifndef CONFIG_ACPX1
 	.read  = ppc4xx_pciex_read_config,
 	.write = ppc4xx_pciex_write_config,
+#else
+	.read  = ppc4xx_pciex_acp_read_config,
+	.write = ppc4xx_pciex_acp_write_config,
+#endif
 };
 
 static int __init ppc4xx_setup_one_pciex_POM(struct ppc4xx_pciex_port	*port,
@@ -1428,6 +1749,7 @@ static int __init ppc4xx_setup_one_pciex_POM(struct ppc4xx_pciex_port	*port,
 	pcial = RES_TO_U32_LOW(pci_addr);
 	sa = (0xffffffffu << ilog2(size)) | 0x1;
 
+#ifndef CONFIG_ACPX1
 	/* Program register values */
 	switch (index) {
 	case 0:
@@ -1459,6 +1781,38 @@ static int __init ppc4xx_setup_one_pciex_POM(struct ppc4xx_pciex_port	*port,
 		break;
 	}
 
+#else
+	{
+	/* ACP X1 setup MPAGE registers */
+
+		int i, num_pages;
+		u32 mpage_lower;
+
+		printk(KERN_INFO "setting outbound window %d with "
+		   "plb_add=0x%012llx, pci_addr=0x%012llx, size=0x%012llx\n",
+		   index, plb_addr, pci_addr, size);
+
+		/*
+		 * MPAGE7 is dedicated to config access, so we only
+		 *  have 7 128MB pages available for memory i/o.
+		 *  Calculate how many pages we need
+		 */
+		if (size > (7 * 0x08000000)) {
+			printk(KERN_WARNING "%s: Resource size 0x%012llx out of range\n",
+				   hose->dn->full_name, size);
+			return -1;
+		}
+
+		num_pages = ((size - 1) >> 27) + 1;
+		for (i = 0; i < num_pages; i++) {
+			mpage_lower = (pcial & 0xf8000000) | 1;
+			out_le32(mbase + ACPX1_PCIE_MPAGE_UPPER(i), pciah);
+			out_le32(mbase + ACPX1_PCIE_MPAGE_LOWER(i),
+				mpage_lower);
+			pcial += 0x08000000;
+		}
+	}
+#endif
 	return 0;
 }
 
@@ -1582,6 +1936,71 @@ static void __init ppc4xx_configure_pciex_PIMs(struct ppc4xx_pciex_port *port,
 		 PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);
 }
 
+#ifdef CONFIG_ACPX1
+static void __init
+ppc4xx_configure_acp_pciex_PIMs(struct ppc4xx_pciex_port *port,
+		struct pci_controller *hose,
+		void __iomem *mbase,
+		struct resource *res)
+{
+	resource_size_t size = res->end - res->start + 1;
+	u64 sa;
+	int i;
+	void __iomem *tpage_base = mbase + 0x1050;
+
+	if (port->endpoint) {
+		resource_size_t ep_addr = 0;
+		resource_size_t ep_size = 32 << 20;
+
+		/* Currently we map a fixed 64MByte window to PLB address
+		 * 0 (SDRAM). This should probably be configurable via a dts
+		 * property.
+		 */
+
+		/* Calculate window size */
+		sa = (0xffffffffffffffffull << ilog2(ep_size));;
+
+		out_le32(mbase + PCI_BASE_ADDRESS_0, RES_TO_U32_LOW(ep_addr));
+		out_le32(mbase + PCI_BASE_ADDRESS_1, RES_TO_U32_HIGH(ep_addr));
+	} else {
+		/* Calculate window size */
+		sa = (0xffffffffffffffffull << ilog2(size));;
+		if (res->flags & IORESOURCE_PREFETCH)
+			sa |= 0x8;
+
+		printk(KERN_INFO "configure inbound mapping from 0x%012llx-0x%012llx (0x%08llx bytes)\n",
+				res->start, res->end, size);
+
+		/* HACK!!
+		 * Since PCI legacy support is disabled in our config, we reuse
+		 * the isa_mem_size field to save size of our inbound window.
+		 * We use this elsewhere to set up the dma_base
+		 */
+		hose->isa_mem_size = size;
+
+		out_le32(mbase + PCI_BASE_ADDRESS_0, RES_TO_U32_LOW(size));
+		out_le32(mbase + PCI_BASE_ADDRESS_1, RES_TO_U32_HIGH(size));
+
+		/*
+		 * set up the TPAGE registers
+		 *
+		 * We set the MSB of each TPAGE to select 128-bit AXI access.
+		 * For the address field we simply program an incrementing value
+		 * to map consecutive pages
+		 */
+		for (i = 0; i < 8; i++) {
+			out_le32(tpage_base, (0x80000000 + i));
+			tpage_base += 4;
+		}
+	}
+
+	/* Enable I/O, Mem, and Busmaster cycles */
+	out_le16(mbase + PCI_COMMAND,
+		 in_le16(mbase + PCI_COMMAND) |
+		 PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);
+}
+#endif
+
 static void __init ppc4xx_pciex_port_setup_hose(struct ppc4xx_pciex_port *port)
 {
 	struct resource dma_window;
@@ -1741,6 +2160,384 @@ static void __init ppc4xx_pciex_port_setup_hose(struct ppc4xx_pciex_port *port)
 		iounmap(mbase);
 }
 
+#ifdef CONFIG_ACPX1
+
+static irqreturn_t
+acp_pcie_isr(int irq, void *arg)
+{
+	struct pci_controller *hose = (struct pci_controller *) arg;
+	void __iomem *mbase = (void __iomem *)hose->cfg_addr;
+
+	u32 intr_status;
+	u32 intr_enb;
+	u32 msg_fifo_stat;
+	u32 msg_fifo_info;
+	u8  externalPciIntr = 0;
+
+	/* read the PEI interrupt status register */
+	intr_status = in_le32(mbase + 0x10c0);
+	intr_enb = in_le32(mbase + 0x10c4);
+
+	/* check if this is a PCIe message from an external device */
+	if (intr_status & 0x00000010) {
+		externalPciIntr = 1;
+
+		msg_fifo_stat = in_le32(mbase + 0x10b4);
+
+		if (msg_fifo_stat & 0x01) {
+			printk(KERN_ERR "ACP_PCIE_ISR got message_arrived interrupt, but fifo is empty!!\n");
+		} else {
+			u8 bus, dev, fn;
+			u8 msg_type;
+			msg_fifo_info = in_le32(mbase + 0x10b0);
+
+			bus = (msg_fifo_info >> 16) & 0xff;
+			dev = (msg_fifo_info >> 11) & 0x1f;
+			fn  = (msg_fifo_info >>  8) & 0x07;
+			msg_type = msg_fifo_info & 0xff;
+		}
+	} else {
+		/* ignore the common interrupts,
+		 * still need to figure out what they all mean
+		 */
+		if (intr_status & 0xf3ffffab) {
+			u32 t2a_err_stat;
+			u32 t2a_other_err_stat;
+			u32 int_enb;
+			u32 linkStatus;
+
+			linkStatus = in_le32(mbase + 0x117c);
+			printk(KERN_ERR "link_status (0x117c) = 0x%08x\n",
+				linkStatus);
+
+			if (intr_status & 0x00020000) {
+				t2a_err_stat = in_le32(mbase + 0x1170);
+				printk(KERN_ERR "t2a_fn_indp_err_stat"
+					" = 0x%08x\n",
+					t2a_err_stat);
+				int_enb = in_le32(mbase + 0x10c4);
+				int_enb &= 0xfffdffff;
+				out_le32(mbase + 0x10c4, int_enb);
+			}
+
+			if (intr_status & 0x00040000) {
+				t2a_other_err_stat = in_le32(mbase + 0x1174);
+				printk(KERN_ERR "t2a_fn_indp_other_err_stat"
+					" = 0x%08x\n",
+					t2a_other_err_stat);
+				int_enb = in_le32(mbase + 0x10c4);
+				int_enb &= 0xfffbffff;
+				out_le32(mbase + 0x10c4, int_enb);
+			}
+
+			if (intr_status & 0x00000800) {
+				printk(KERN_INFO "pci_config = 0x%08x\n",
+					in_le32(mbase + 0x1000));
+				printk(KERN_INFO "pci_status = 0x%08x\n",
+					in_le32(mbase + 0x1004));
+
+				int_enb = in_le32(mbase + 0x10c4);
+				int_enb &= 0xfffff7ff;
+				out_le32(mbase + 0x10c4, int_enb);
+			}
+		}
+	}
+
+	 /*
+	  *  We clear all the interrupts in the PEI status, even though
+	  *  interrupts from external devices have not yet been handled.
+	  *  That should be okay, since the PCI IRQ in the MPIC won't be
+	  *  re-enabled until all external handlers have been called.
+	  */
+	out_le32(mbase + 0x10c0, intr_status);
+
+	return externalPciIntr ? IRQ_NONE : IRQ_HANDLED;
+}
+
+static void __init
+ppc4xx_acp_pciex_port_setup_hose(struct ppc4xx_pciex_port *port)
+{
+	struct resource dma_window;
+	struct pci_controller *hose = NULL;
+	const int *bus_range;
+	int primary = 0, busses;
+	void __iomem *mbase = NULL, *cfg_data = NULL;
+	int mappedIrq;
+	int err;
+	u32 pci_status;
+	u32 link_state;
+	u32 pci_config;
+	u32 version;
+
+	/* Check if primary bridge */
+	if (of_get_property(port->node, "primary", NULL))
+		primary = 1;
+
+	/* Get bus range if any */
+	bus_range = of_get_property(port->node, "bus-range", NULL);
+
+	/* Allocate the host controller data structure */
+	hose = pcibios_alloc_controller(port->node);
+	if (!hose)
+		goto fail;
+
+	/* We stick the port number in "indirect_type" so the config space
+	 * ops can retrieve the port data structure easily
+	 */
+	hose->indirect_type = port->index;
+
+	/* Get bus range */
+	hose->first_busno = bus_range ? bus_range[0] : 0x0;
+	hose->last_busno = bus_range ? bus_range[1] : 0xff;
+
+	/* Because of how big mapping the config space is (1M per bus), we
+	 * limit how many busses we support. In the long run, we could replace
+	 * that with something akin to kmap_atomic instead. We set aside 1 bus
+	 * for the host itself too.
+	 */
+	busses = hose->last_busno - hose->first_busno; /* This is off by 1 */
+	if (busses > MAX_PCIE_BUS_MAPPED) {
+		busses = MAX_PCIE_BUS_MAPPED;
+		hose->last_busno = hose->first_busno + busses;
+	}
+
+	if (!port->endpoint) {
+		/*
+		 * map the bottom page of PCIe memory for config space access
+		 */
+		cfg_data = ioremap(port->cfg_space.start, 0x100000);
+		if (cfg_data == NULL) {
+			printk(KERN_ERR "%s: Can't map external config space !",
+			   port->node->full_name);
+			goto fail;
+		}
+		hose->cfg_data = cfg_data;
+	}
+
+	/*
+	 * The internal config space has already been mapped, so
+	 * just re-use that virtual address.
+	 */
+	hose->cfg_addr = port->utl_base;
+
+	pr_debug("PCIE %s, bus %d..%d\n", port->node->full_name,
+		 hose->first_busno, hose->last_busno);
+	pr_debug("	 config space mapped at: root @0x%p, other @0x%p\n",
+		 hose->cfg_addr, hose->cfg_data);
+
+	/* Setup config space */
+	hose->ops = &ppc4xx_pciex_pci_ops;
+	port->hose = hose;
+	mbase = (void __iomem *)hose->cfg_addr;
+
+	if (port->endpoint) {
+		/* if we're an endpoint don't do anything else */
+		printk(KERN_INFO "PCIE%d: successfully set as endpoint\n",
+			port->index);
+		return;
+	}
+
+	/* setting up as root complex */
+	pci_config = in_le32(mbase + 0x1000);
+	printk(KERN_INFO "PEI config = 0x%08x\n", pci_config);
+
+	pci_status = in_le32(mbase + 0x1004);
+	link_state = (pci_status & 0x3f00) >> 8;
+	printk(KERN_INFO "PEI status = 0x%08x :"
+		" PCI link state = 0x%x\n",
+		pci_status, link_state);
+
+	/* make sure the ACP device is configured as PCI Root Complex */
+	if ((pci_status & 0x18) != 0x18) {
+		printk(KERN_ERR "ACP device is not PCI Root Complex!"
+			" status = 0x%08x\n",
+			pci_status);
+		goto fail;
+	}
+
+	/* make sure the link is up */
+	if (link_state != 0xb) {
+		/* reset */
+		printk("PCI link in bad state - resetting\n");
+		pci_config |= 1;
+		out_le32(mbase + 1000, pci_config);
+		msleep(1);
+
+		pci_status = in_le32(mbase + 0x1004);
+		link_state = (pci_status & 0x3f00) >> 8;
+
+		printk(KERN_ERR "PCI link state now = 0x%x\n",
+			link_state);
+
+		if (link_state != 0xb) {
+			printk(KERN_ERR "PCI link still in bad state"
+				" - giving up!\n");
+			goto fail;
+		}
+	}
+
+	/* get the device version */
+	if (0 != ncr_read(NCP_REGION_ID(0xa, 0x10), 0x2c, 4, &version)) {
+		printk(KERN_ERR "Unable to detect ACP revision!\n");
+		goto fail;
+	}
+
+	port->acpChipType = (version & 0x1f);
+	printk(KERN_INFO "Using PEI register set for ACP chipType %d\n",
+		port->acpChipType);
+
+	/*
+	 * Set bus numbers on our root port
+	 */
+	out_8(mbase + PCI_PRIMARY_BUS, hose->first_busno);
+	out_8(mbase + PCI_SECONDARY_BUS, hose->first_busno + 1);
+	out_8(mbase + PCI_SUBORDINATE_BUS, hose->last_busno);
+
+
+	/* Parse outbound mapping resources */
+	pci_process_bridge_OF_ranges(hose, port->node, primary);
+
+	/* Parse inbound mapping resources */
+	if (ppc4xx_parse_dma_ranges(hose, mbase, &dma_window) != 0)
+		goto fail;
+
+	/* Configure outbound ranges POMs */
+	ppc4xx_configure_pciex_POMs(port, hose, mbase);
+
+	/* Configure inbound ranges PIMs */
+	ppc4xx_configure_acp_pciex_PIMs(port, hose, mbase, &dma_window);
+
+	/* TEMP??
+	 * hook up an interrupt handler
+	 */
+	mappedIrq = irq_create_mapping(NULL, 29);
+	if (mappedIrq == NO_IRQ) {
+		printk(KERN_ERR "irq_create_mapping failed!!!\n");
+		goto fail;
+	}
+
+	err = set_irq_type(mappedIrq, IRQ_TYPE_LEVEL_HIGH);
+	if (err) {
+		printk(KERN_ERR "set_irq_type failed!!!!\n");
+		goto fail;
+	}
+
+	err = request_irq(mappedIrq, acp_pcie_isr,
+		IRQF_SHARED, "acp_pcie", hose);
+	if (err) {
+		printk(KERN_ERR "request_irq failed!!!!\n");
+		goto fail;
+	}
+
+	/* for now ignore retry requests */
+	out_le32(mbase + 0x10c4, 0xfffffffd);
+
+	/* for v2 we need to set the 'axi_interface_rdy' bit */
+	pci_config = in_le32(mbase + 0x1000);
+	pci_config |= 0x00040000;
+	out_le32(mbase + 0x1000, pci_config);
+
+
+	if (!port->endpoint)
+		printk(KERN_INFO "PCIE%d: successfully set as root-complex\n",
+		       port->index);
+
+	if (!port->endpoint)
+		printk(KERN_INFO "PCIE%d: successfully set as root-complex\n",
+			   port->index);
+	else
+		printk(KERN_INFO "PCIE%d: successfully set as endpoint\n",
+			   port->index);
+
+	return;
+ fail:
+	if (hose)
+		pcibios_free_controller(hose);
+	if (cfg_data)
+		iounmap(cfg_data);
+}
+
+static void __init ppc4xx_probe_acp_pciex_bridge(struct device_node *np)
+{
+	struct ppc4xx_pciex_port *port;
+	const u32 *pval;
+	int portno;
+	const char *val;
+
+	last_mpage = 0;
+	/* First, proceed to core initialization as we assume there's
+	 * only one PCIe core in the system
+	 */
+	if (ppc4xx_pciex_check_core_init(np))
+		return;
+
+	/* Get the port number from the device-tree */
+	pval = of_get_property(np, "port", NULL);
+	if (pval == NULL) {
+		printk(KERN_ERR "PCIE: Can't find port number for %s\n",
+		       np->full_name);
+		return;
+	}
+	portno = *pval;
+	if (portno >= ppc4xx_pciex_port_count) {
+		printk(KERN_ERR "PCIE: port number out of range for %s\n",
+		       np->full_name);
+		return;
+	}
+	port = &ppc4xx_pciex_ports[portno];
+	port->index = portno;
+
+	/*
+	 * Check if device is enabled
+	 */
+	if (!of_device_is_available(np)) {
+		printk(KERN_INFO "PCIE%d: Port disabled via device-tree\n",
+			port->index);
+		return;
+	}
+
+	port->node = of_node_get(np);
+
+	/* Check if device_type property is set to "pci" or "pci-endpoint".
+	 * Resulting from this setup this PCIe port will be configured
+	 * as root-complex or as endpoint.
+	 */
+	val = of_get_property(port->node, "device_type", NULL);
+	if (!strcmp(val, "pci-endpoint")) {
+		port->endpoint = 1;
+	} else if (!strcmp(val, "pci")) {
+		port->endpoint = 0;
+	} else {
+		printk(KERN_ERR "PCIE%d: missing or incorrect device_type for %s\n",
+		       portno, np->full_name);
+		return;
+	}
+
+	/* Fetch config space registers address */
+	if (of_address_to_resource(np, 0, &port->cfg_space)) {
+		printk(KERN_ERR "%s: Can't get PCI-E config space !",
+		       np->full_name);
+		return;
+	}
+
+	/* Fetch host bridge internal registers address */
+	if (of_address_to_resource(np, 1, &port->utl_regs)) {
+		printk(KERN_ERR "%s: Can't get UTL register base !",
+		       np->full_name);
+		return;
+	}
+
+	port->utl_base = (void __iomem *)
+		((u32)(port->utl_regs.start - 0x2000400000ULL) + 0xf0000000);
+
+	printk(KERN_INFO "%s PEI config base = 0x%012llx (0x%08x virtual)\n",
+		np->full_name, port->utl_regs.start, (u32) port->utl_base);
+
+	/* Setup the linux hose data structure */
+	ppc4xx_acp_pciex_port_setup_hose(port);
+}
+#endif /* CONFIG_ACP */
+
 static void __init ppc4xx_probe_pciex_bridge(struct device_node *np)
 {
 	struct ppc4xx_pciex_port *port;
@@ -1843,6 +2640,11 @@ static int __init ppc4xx_pci_find_bridges(void)
 
 	ppc_pci_flags |= PPC_PCI_ENABLE_PROC_DOMAINS | PPC_PCI_COMPAT_DOMAIN_0;
 
+#ifdef CONFIG_ACPX1
+	for_each_compatible_node(np, NULL, "lsi,plb-pciex")
+		ppc4xx_probe_acp_pciex_bridge(np);
+#endif
+
 #ifdef CONFIG_PPC4xx_PCI_EXPRESS
 	for_each_compatible_node(np, NULL, "ibm,plb-pciex")
 		ppc4xx_probe_pciex_bridge(np);
diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index c82548a..2f45536 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -1,5 +1,7 @@
 /*
  * probe.c - PCI detection and setup code
+ *
+ * These patches add ACP3400 support signed-off-by: john.jacques@lsi.com
  */
 
 #include <linux/kernel.h>
@@ -1011,8 +1013,14 @@ int pci_setup_device(struct pci_dev *dev)
 		break;
 
 	case PCI_HEADER_TYPE_BRIDGE:		    /* bridge header */
+#if defined(CONFIG_ACPX1)
+		if ((class != PCI_CLASS_BRIDGE_PCI) &&
+			(class != PCI_CLASS_NETWORK_OTHER))
+			goto bad;
+#else
 		if (class != PCI_CLASS_BRIDGE_PCI)
 			goto bad;
+#endif
 		/* The PCI-to-PCI bridge spec requires that subtractive
 		   decoding (i.e. transparent) bridge must have programming
 		   interface code of 0x01. */ 
-- 
1.7.0.5

