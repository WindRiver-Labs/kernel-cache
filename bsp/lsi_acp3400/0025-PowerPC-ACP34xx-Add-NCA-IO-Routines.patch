From 160568ddd22543cc1218444d9577a68107536116 Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Mon, 18 Apr 2011 13:13:24 +0800
Subject: [PATCH 25/27] PowerPC:ACP34xx:Add NCA IO Routines

The Nuevo CPU Adapter (NCA) on ACP34xx is the hardware engine that
connects the PowerPC CPU complex with the ACP3400 data path
accelerator engines.

The NCA's physical address starts from 0x2000520000, ACP platform
create a UTLB entry map NCA's address to 0xf0120000 at kernel startup.

This patch provide IO routines to access NCA reigisters.

Extract from vendor drop patch lsi-patch 3.8.1.12.

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 arch/powerpc/include/asm/ncr.h      |   32 +++++
 arch/powerpc/platforms/44x/Makefile |    2 +-
 arch/powerpc/platforms/44x/ncr.c    |  237 +++++++++++++++++++++++++++++++++++
 3 files changed, 270 insertions(+), 1 deletions(-)
 create mode 100644 arch/powerpc/include/asm/ncr.h
 create mode 100644 arch/powerpc/platforms/44x/ncr.c

diff --git a/arch/powerpc/include/asm/ncr.h b/arch/powerpc/include/asm/ncr.h
new file mode 100644
index 0000000..05d0094
--- /dev/null
+++ b/arch/powerpc/include/asm/ncr.h
@@ -0,0 +1,32 @@
+/*
+ * drivers/lsi/common/version.h
+ *
+ * Copyright (C) 2010 LSI
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307	 USA
+ */
+
+#ifndef __DRIVERS_LSI_ACP_NCR_H
+#define __DRIVERS_LSI_ACP_NCR_H
+
+#define NCP_REGION_ID(node, target) \
+(unsigned long) ((((node) & 0xffff) << 16) | ((target) & 0xffff))
+#define NCP_NODE_ID(region) (((region) >> 16) & 0xffff)
+#define NCP_TARGET_ID(region) ((region) & 0xffff)
+
+int ncr_read(unsigned long, unsigned long, int, void *);
+int ncr_write(unsigned long, unsigned long, int, void *);
+
+#endif /*  __DRIVERS_LSI_ACP_NCR_H */
diff --git a/arch/powerpc/platforms/44x/Makefile b/arch/powerpc/platforms/44x/Makefile
index 6fcbf22..04e65c1 100644
--- a/arch/powerpc/platforms/44x/Makefile
+++ b/arch/powerpc/platforms/44x/Makefile
@@ -5,5 +5,5 @@ obj-$(CONFIG_SAM440EP) 	+= sam440ep.o
 obj-$(CONFIG_WARP)	+= warp.o
 obj-$(CONFIG_XILINX_VIRTEX_5_FXT) += virtex.o
 obj-$(CONFIG_XILINX_ML510) += virtex_ml510.o
-obj-$(CONFIG_ACPX1)	+= acpx1.o acpclock.o
+obj-$(CONFIG_ACPX1)	+= acpx1.o acpclock.o ncr.o
 obj-$(CONFIG_LSI_UBOOTENV) += ubootenv.o
diff --git a/arch/powerpc/platforms/44x/ncr.c b/arch/powerpc/platforms/44x/ncr.c
new file mode 100644
index 0000000..300f961
--- /dev/null
+++ b/arch/powerpc/platforms/44x/ncr.c
@@ -0,0 +1,237 @@
+/*
+ *  Copyright (C) 2009 LSI Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/io.h>
+
+#include <asm/ncr.h>
+
+#define NCA 0xf0120000
+
+union command_data_register_0_t{
+	unsigned long raw;
+	struct {
+		unsigned long start_done:1;
+		unsigned long unused:6;
+		unsigned long local_bit:1;
+		unsigned long status:2;
+		unsigned long byte_swap_enable:1;
+		unsigned long cfg_cmpl_int_enable:1;
+		unsigned long cmd_type:4;
+		unsigned long dbs:16;
+	} __attribute__ ((packed)) bits;
+} __attribute__ ((packed));
+
+union command_data_register_1_t {
+	unsigned long raw;
+	struct {
+		unsigned long target_address:32;
+	} __attribute__ ((packed)) bits;
+} __attribute__ ((packed));
+
+union command_data_register_2_t{
+	unsigned long raw;
+	struct {
+		unsigned long unused:16;
+		unsigned long target_node_id:8;
+		unsigned long target_id_address_upper:8;
+	} __attribute__ ((packed)) bits;
+} __attribute__ ((packed));
+
+/*
+  ----------------------------------------------------------------------
+  ncr_register_read
+*/
+
+static inline unsigned long
+ncr_register_read(unsigned *address)
+{
+	unsigned long value;
+
+	value = in_be32((unsigned long) address);
+
+	return value;
+}
+
+/*
+  ----------------------------------------------------------------------
+  ncr_register_write
+*/
+
+static inline void
+ncr_register_write(const unsigned value, unsigned *address)
+{
+	out_be32(address, value);
+}
+
+/*
+  ======================================================================
+  ======================================================================
+  Public Interface
+  ======================================================================
+  ======================================================================
+*/
+
+/*
+  ----------------------------------------------------------------------
+  ncr_read
+*/
+
+int
+ncr_read(unsigned long region, unsigned long address, int number,
+	 void *buffer)
+{
+	union command_data_register_0_t cdr0;
+	union command_data_register_1_t cdr1;
+	union command_data_register_2_t cdr2;
+
+	/*
+	  Set up the read command.
+	*/
+
+	cdr2.raw = 0;
+	cdr2.bits.target_node_id = NCP_NODE_ID(region);
+	cdr2.bits.target_id_address_upper = NCP_TARGET_ID(region);
+	ncr_register_write(cdr2.raw, (unsigned *) (NCA + 0xf8));
+
+	cdr1.raw = 0;
+	cdr1.bits.target_address = (address >> 2);
+	ncr_register_write(cdr1.raw, (unsigned *) (NCA + 0xf4));
+
+	cdr0.raw = 0;
+	cdr0.bits.start_done = 1;
+
+	if (0xff == cdr2.bits.target_id_address_upper)
+		cdr0.bits.local_bit = 1;
+
+	cdr0.bits.cmd_type = 4;
+	/* TODO: Verify number... */
+	cdr0.bits.dbs = (number - 1);
+	ncr_register_write(cdr0.raw, (unsigned *) (NCA + 0xf0));
+	mb();
+
+	/*
+	  Wait for completion.
+	*/
+	{
+		volatile unsigned long value;
+
+		do {
+			value = ncr_register_read((unsigned *) (NCA + 0xf0));
+		} while (0x80000000 == (value & 0x80000000));
+	}
+
+	/*
+	  Copy data words to the buffer.
+	*/
+
+	address = (NCA + 0x1000);
+	while (4 <= number) {
+		*((unsigned long *) buffer) =
+			ncr_register_read((unsigned *) address);
+		address += 4;
+		number -= 4;
+	}
+
+	if (0 < number) {
+		unsigned long temp =
+			ncr_register_read((unsigned *) address);
+		memcpy((void *) buffer, &temp, number);
+	}
+
+	return 0;
+}
+
+/*
+  ----------------------------------------------------------------------
+  ncr_write
+*/
+
+int
+ncr_write(unsigned long region, unsigned long address, int number,
+	  void *buffer)
+{
+	union command_data_register_0_t cdr0;
+	union command_data_register_1_t cdr1;
+	union command_data_register_2_t cdr2;
+	unsigned long data_word_base;
+	int dbs = (number - 1);
+
+	/*
+	  Set up the write.
+	*/
+
+	cdr2.raw = 0;
+	cdr2.bits.target_node_id = NCP_NODE_ID(region);
+	cdr2.bits.target_id_address_upper = NCP_TARGET_ID(region);
+	ncr_register_write(cdr2.raw, (unsigned *) (NCA + 0xf8));
+
+	cdr1.raw = 0;
+	cdr1.bits.target_address = (address >> 2);
+	ncr_register_write(cdr1.raw, (unsigned *) (NCA + 0xf4));
+
+	/*
+	  Copy from buffer to the data words.
+	*/
+
+	data_word_base = (NCA + 0x1000);
+
+	while (4 <= number) {
+		ncr_register_write(*((unsigned long *) buffer),
+				   (unsigned *) data_word_base);
+		data_word_base += 4;
+		buffer += 4;
+		number -= 4;
+	}
+
+	if (0 < number) {
+		unsigned long temp = 0;
+
+		memcpy((void *) &temp, (void *) buffer, number);
+		ncr_register_write(temp, (unsigned *) data_word_base);
+		data_word_base += number;
+		buffer += number;
+		number = 0;
+	}
+
+	cdr0.raw = 0;
+	cdr0.bits.start_done = 1;
+
+	if (0xff == cdr2.bits.target_id_address_upper)
+		cdr0.bits.local_bit = 1;
+
+	cdr0.bits.cmd_type = 5;
+	/* TODO: Verify number... */
+	cdr0.bits.dbs = dbs;
+	ncr_register_write(cdr0.raw, (unsigned *) (NCA + 0xf0));
+	mb();
+
+	/*
+	  Wait for completion.
+	*/
+
+	/* TODO: Handle failure cases. */
+	while (0x80000000 ==
+	       (ncr_register_read((unsigned *) (NCA + 0xf0)) & 0x80000000))
+		;
+
+	return 0;
+}
-- 
1.7.0.5

