From 7f51d2e80ae97935fe72b330fbdb4234841f01bc Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Mon, 18 Apr 2011 13:05:14 +0800
Subject: [PATCH 13/27] PowerPC:ACP34xx:Add nand driver

This patch add support for ep501 NAND flash controller, which implement
on ACP34xx board.

Update vender drop code to support OF-platform style driver register
interface.

Fixed context to apply to Wind River kernel tree.

Extract from vendor drop patch lsi-patch 3.8.1.12.

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/mtd/nand/Kconfig     |    6 +
 drivers/mtd/nand/Makefile    |    1 +
 drivers/mtd/nand/ep501.c     | 1318 ++++++++++++++++++++++++++++++++++++++++++
 drivers/mtd/nand/ep501.h     |  196 +++++++
 drivers/mtd/nand/nand_base.c |   38 ++-
 5 files changed, 1558 insertions(+), 1 deletions(-)
 create mode 100644 drivers/mtd/nand/ep501.c
 create mode 100644 drivers/mtd/nand/ep501.h

diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
index 3aa5142..cf497d9 100644
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -496,4 +496,10 @@ config MTD_NAND_FSMC
 	  Enables support for NAND Flash chips on the ST Microelectronics
 	  Flexible Static Memory Controller (FSMC)
 
+config MTD_NAND_LSI
+	bool "NAND Driver for LSI's APP and ACP"
+	depends on ACPX1
+	help
+		Add NAND support to LSI's APP34xx boards.
+
 endif # MTD_NAND
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index 8abc265..d74d575 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -43,5 +43,6 @@ obj-$(CONFIG_MTD_NAND_TXX9NDFMC)	+= txx9ndfmc.o
 obj-$(CONFIG_MTD_NAND_W90P910)		+= w90p910_nand.o
 obj-$(CONFIG_MTD_NAND_NOMADIK)		+= nomadik_nand.o
 obj-$(CONFIG_MTD_NAND_BCM_UMI)		+= bcm_umi_nand.o nand_bcm_umi.o
+obj-$(CONFIG_MTD_NAND_LSI)			+= ep501.o
 
 nand-objs := nand_base.o nand_bbt.o
diff --git a/drivers/mtd/nand/ep501.c b/drivers/mtd/nand/ep501.c
new file mode 100644
index 0000000..87bbc64
--- /dev/null
+++ b/drivers/mtd/nand/ep501.c
@@ -0,0 +1,1318 @@
+/*
+ * drivers/mtd/nand/ep501.c
+ *
+ * NAND Controller Driver for LSI's ACP
+ *
+ * Copyright (C) 2009 LSI Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307	 USA
+ *
+ */
+
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/of_platform.h>
+#include <linux/of.h>
+#include <asm/cacheflush.h>
+
+#include "ep501.h"
+
+
+/*
+  ==============================================================================
+  ==============================================================================
+  Some Oddities...
+
+  -1-
+  Reading EP501 registers while the device is calculating ECC will
+  hang the AHB.	 As the only way to know that an ECC calculation is in
+  progress is to read the "extra bits" added to the interrupt status
+  register, this can cause problems.  To get around this, the
+  PECC_BUSY signal from the controller is also available in a general
+  purpose system register.  0x149.0.0xc/0x0020_0040_0000_c00c, bit 24.
+  So, before reading the interrupt status register (or any other
+  register for that matter) make sure the bit mentioned above is
+  clear.  See BZ21212.
+
+  -2-
+  Extra bits have been added to the interrupt status register.	See
+  BZ21196.  From that defect...
+
+  == Bit 0
+  This bit is set when un-correctable ECC is detected. This bit can be
+  cleared by writing "0" to this register. Writing "1" has no
+  effect. An interrupt is generated if this bit and the enable bit
+  (bit 0) in the Interrupt Enable Register are "1". This bit is not
+  set if ECC is disabled.
+
+  == Bit 1
+  This bit is set when correctable ECC is detected. This bit can be
+  cleared by writing "0" to this register. Writing "1" has no
+  effect. An interrupt is generated if this bit and the enable bit
+  (bit 1) in the Interrupt Enable Register are "1". This bit is not
+  set if ECC is disabled.
+
+  == Bit 2
+  This bit is set when a rising edge is detected on the non gated
+  READY/BUSY# input from the NAND Flash. This bit can be cleared by
+  writing a "0" to this register. Writing a "1" has no effect. An
+  interrupt is generated if this bit and the enable bit (bit 2) in the
+  Interrupt Enable Register are "1".
+
+  == Bit 3
+  This bit is set when a falling edge is detected on the non gated
+  READY/BUSY# input from the NAND Flash. This bit can be cleared by
+  writing a "0" to this register. Writing a "1" has no effect. An
+  interrupt is generated if this bit and the enable bit (bit 3) in the
+  Interrupt Enable Register are "1".
+
+  == Bit 4
+  This bit is set when a falling edge is detected on the PECC_BUSY
+  signal which indicates when the NAND controller has taken control of
+  the NAND Flash for ECC byte access. This bit can be cleared by
+  writing a "0" to this register. Writing a "1" has no effect. An
+  interrupt is generated if this bit and the enable bit (bit 4) in the
+  Interrupt Enable Register are "1".
+
+  == Bit 5
+  This bit is read only and is the synchronized level on the non gated
+  READY/BUSY# input from the NAND Flash. This bit can be used to poll
+  the status of this signal and is not used to generate an interrupt.
+
+  == Bit 6
+  This bit is read only and indicates the level on the PECC_BUSY
+  signal which indicates when the NAND controller has taken control of
+  the NAND Flash for ECC byte access. This bit can be used to poll the
+  level of this signal and is not used to generate an interrupt.
+
+  ==============================================================================
+  ==============================================================================
+*/
+
+#define LSI_NAND_BASE	      0xf0040000
+#define LSI_NAND_PECC_BUSY_REGISTER 0xf000c00c
+
+#define LSI_NAND_PECC_BUSY_MASK	    (1 << 28)
+
+/*
+  ----------------------------------------------------------------------
+  MTD structures
+*/
+#define NAND_CMD_START_ECC_READ	  0x23
+
+#define NAND_CMD_CE_OFF_501	  0xEE
+#define NAND_CMD_CE_OFF_501G1	  0xEE
+#define NAND_CMD_CE_OFF_501G3	  0xFE
+
+union nand_timing_control_register_0_t {
+	unsigned long raw;
+
+	struct {
+#ifdef __BIG_ENDIAN
+		unsigned long th:8;
+		unsigned long trp:8;
+		unsigned long twp:8;
+		unsigned long ts:8;
+#else
+		unsigned long ts:8;
+		unsigned long twp:8;
+		unsigned long trp:8;
+		unsigned long th:8;
+#endif
+	} __attribute__ ((packed)) bits;
+} __attribute__ ((packed));
+
+union nand_timing_control_register_1_t{
+	unsigned long raw;
+
+	struct {
+#ifdef __BIG_ENDIAN
+		unsigned long twb:8;
+		unsigned long trr:8;
+		unsigned long trh:8;
+		unsigned long twh:8;
+#else
+		unsigned long twh:8;
+		unsigned long trh:8;
+		unsigned long trr:8;
+		unsigned long twb:8;
+#endif
+	} __attribute__ ((packed)) bits;
+} __attribute__ ((packed));
+
+union nand_timing_control_register_2_t{
+	unsigned long raw;
+
+	struct {
+#ifdef __BIG_ENDIAN
+		unsigned long:8;
+		unsigned long trhw:8;
+		unsigned long twhr:8;
+		unsigned long tccs:8;
+#else
+		unsigned long tccs:8;
+		unsigned long twhr:8;
+		unsigned long trhw:8;
+		unsigned long:8;
+#endif
+	} __attribute__ ((packed)) bits;
+} __attribute__ ((packed));
+
+enum lsi_nand_type_t{
+	LSI_NAND_NONE, LSI_NAND_EP501, LSI_NAND_EP501G1, LSI_NAND_EP501G3
+} ;
+
+struct lsi_nand_chip {
+	struct mtd_info nand_mtd;
+	struct nand_chip nand_chip;
+	enum lsi_nand_type_t nand_type;
+	int nand_cmd_ce_off;
+
+	struct device *dev;
+	u8 __iomem *vbase;
+};
+
+/*
+  ======================================================================
+  ======================================================================
+  Concerning ECC
+
+  The EP501 only supports 1 bit ECC mode.  The EP501G1 supports both 1
+  bit and 4 bit modes.  The EP501G3 supports 4 bit, 8 bit, and 12 bit.
+  The NAND part normally used on ACP boards has 2K pages (supported by
+  all three controllers) with 64 bytes of OOB.  For a 2K page, 1 bit
+  ECC uses 12 bytes, 4 bit ECC uses 32 bytes, 8 bit ECC uses 64 bytes
+  and 12 bit ECC uses 80 bytes.  In order to to keep the bad block
+  markers (first two bytes) and leave some OOB available for file
+  systems etc., this driver only supports 1 bit ECC or 4 bit ECC.
+
+  For now, the EP501 version will use 1 bit ECC (only option), the
+  EP501G1 version will use 4 bit (for compabitility with the EP501G3)
+  and teh EP501G3 versions will use 4 bit (due to the amount of OOB
+  required and for compatibility with the EP501G1).
+
+  EP501
+
+  The driver has not been tested with small page (512 byte) devices.
+  The only usable option is 2K.  So, the OOB should be 64 bytes.  The
+  first 2 bytes are reserved for marking bad blocks.  The last 12
+  bytes are reserved for ECC.  All other bytes are free.  See
+  lsi_ep501_2k_ecclayout below.
+
+  EP501G1
+
+  This driver has been tested with 2K and 4K page sizes using 1 bit
+  and 4 bit ECC.
+  ======================================================================
+  ======================================================================
+*/
+
+static struct nand_ecclayout lsi_2k_1bit_ecclayout = {
+	.eccbytes = 12,
+	.eccpos = {
+		52, 53, 54, 55, 56, 57,
+		58, 59, 60, 61, 62, 63},
+	.oobfree = { {2, 50} }
+};
+
+static struct nand_ecclayout lsi_4k_1bit_ecclayout = {
+	.eccbytes = 24,
+	.eccpos = {
+		52, 53, 54, 55, 56, 57,
+		58, 59, 60, 61, 62, 63},
+	.oobfree = { {2, 50} }
+};
+
+static struct nand_ecclayout lsi_2k_4bit_ecclayout = {
+	.eccbytes = 32,
+	.eccpos = {
+		32, 33, 34, 35, 36, 37, 38, 39,
+		40, 41, 42, 43, 44, 45, 46, 47,
+		48, 49, 50, 51, 52, 53, 54, 55,
+		56, 57, 58, 59, 60, 61, 62, 63},
+	.oobfree = { {2, 30} }
+};
+
+static struct nand_ecclayout lsi_4k_4bit_ecclayout = {
+	.eccbytes = 64,
+	.eccpos = {
+		64,  65,  66,  67,  68,  69,  70,  71,
+		72,  73,  74,  75,  76,  77,  78,  79,
+		80,  81,  82,  83,  84,  85,  86,  87,
+		88,  89,  90,  91,  92,  93,  94,  95,
+		96,  97,  98,  99, 100, 101, 102, 103,
+		104, 105, 106, 107, 108, 109, 110, 111,
+		112, 113, 114, 115, 116, 117, 118, 119,
+		120, 121, 122, 123, 124, 125, 126, 127
+	},
+	.oobfree = { {2, 62} }
+};
+
+/*
+  lsi_nand_hwcontrol
+*/
+
+static void
+lsi_nand_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl)
+{
+	struct nand_chip *chip = mtd->priv;
+
+	if (cmd != NAND_CMD_NONE)
+		writel(cmd, (chip->IO_ADDR_W + NAND_CMD_REG));
+
+	return;
+}
+
+/* lsi_nand_device_ready
+
+  The READ/BUSY# input from the NAND device(s) (ORed if there are more
+  than one) is availble as an extra bit in the interrupt status
+  register.  Note that this register shouldn't be read unless the
+  controller is not in the middle of calculating ECC (see "Some
+  Oddities..." above).
+*/
+
+static int
+lsi_nand_device_ready(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+	unsigned long interrupt_status;
+
+	/* Get the status. */
+	interrupt_status = readl(chip->IO_ADDR_R + NAND_INTR_STATUS_REG);
+
+	return interrupt_status & NAND_STATUS_TRUE_READY;
+}
+
+/**
+ * lsi_nand_command - [DEFAULT] Send command to NAND large page device
+ * @mtd:	MTD device structure
+ * @command:	the command to be sent
+ * @column:	the column address for this command, -1 if none
+ * @page_addr:	the page address for this command, -1 if none
+ *
+ * Send command to NAND device. This is the version for the new large page
+ * devices We dont have the separate regions as we have in the small page
+ * devices.  We must emulate NAND_CMD_READOOB to keep the code compatible.
+ */
+static void
+lsi_nand_command(struct mtd_info *mtd, unsigned int command,
+		 int column, int page_addr)
+{
+	register struct nand_chip *chip = mtd->priv;
+	struct lsi_nand_chip *priv = (struct lsi_nand_chip *) chip->priv;
+	unsigned int status = 0;
+
+	command &= 0xff;
+
+	/* Emulate NAND_CMD_READOOB */
+	if (command == NAND_CMD_READOOB) {
+		column += mtd->writesize;
+		command = NAND_CMD_READ0;
+	}
+
+	/* return if unhandled command is issued */
+	if (command != NAND_CMD_READ0 &&
+	    command != NAND_CMD_SEQIN && command != NAND_CMD_ERASE1 &&
+	    command != NAND_CMD_STATUS && command != NAND_CMD_READID &&
+	    command != NAND_CMD_RESET &&
+	    command != NAND_CMD_START_ECC_READ &&
+	    command != NAND_CMD_PAGEPROG &&
+	    command != NAND_CMD_ERASE2) {
+		printk(KERN_ERR
+		       "lsi_nand_command(): WARN: Unhandled command 0x%x "
+		       "issued for page=0x%x, column=0x%x.\n",
+		       command, page_addr, column);
+		return;
+	}
+
+	/* Command latch cycle */
+	chip->cmd_ctrl(mtd, command,
+		       NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);
+
+	if (column != -1 || page_addr != -1) {
+		unsigned long index = 0;
+		unsigned long extended_index = 0;
+
+		/* column number */
+		/*
+		  Since the ACP uses 8 bit device access, only that
+		  mode is supported.
+		*/
+
+		if (LSI_NAND_EP501 == priv->nand_type) {
+			/* column number */
+			if (column != -1)
+				index = column & 0xfff;
+
+			/* page and block number */
+			if (page_addr != -1)
+				index += ((page_addr & 0x7ffff) << 12);
+		} else {
+			/* column number */
+			if (-1 != column) {
+				switch (mtd->writesize) {
+				case 512:
+					index |= (column & 0x1ff);
+					break;
+				case 2048:
+					index |= (column & 0xfff);
+					break;
+				case 4096:
+					index |= (column & 0x1fff);
+					break;
+				default:
+					break;
+				}
+			}
+
+			/* page_addr and block number */
+			if (-1 != page_addr) {
+				switch (mtd->writesize) {
+				case 512:
+					index |= (page_addr & 0x7fffff) << 9;
+					break;
+				case 2048:
+					index |= (page_addr & 0xfffff) << 12;
+					extended_index |=
+						(page_addr & 0xfff00000);
+					break;
+				case 4096:
+					index |= (page_addr & 0x7ffff) << 13;
+					extended_index |=
+						(page_addr & 0xfff80000);
+					break;
+				default:
+					break;
+				}
+			}
+		}
+
+		/* write index reg */
+		writel(index, chip->IO_ADDR_W + NAND_INDEX_REG);
+
+		/* write ext index reg */
+		writel(extended_index, chip->IO_ADDR_W + NAND_EXT_INDEX_REG);
+
+		mb();
+	}
+
+	/* for read command, send 0xe0 so data is populated */
+	if (command == NAND_CMD_READ0) {
+		chip->cmd_ctrl(mtd, NAND_CMD_RNDOUTSTART,
+			       NAND_NCE | NAND_CLE | NAND_CTRL_CHANGE);
+		/* wait until CHIP_BUSY goes low */
+		do {
+			udelay(chip->chip_delay);
+			status = chip->dev_ready(mtd);
+		} while (!status);
+	} else if (command == NAND_CMD_STATUS) {
+		udelay(chip->chip_delay);
+	}
+
+	return;
+}
+
+/**
+ * lsi_nand_read_buf - [DEFAULT] read chip data into buffer
+ * @mtd:	MTD device structure
+ * @buf:	buffer to store date
+ * @len:	number of bytes to read
+ *
+ * Default read function for 8bit buswith
+ */
+static void lsi_nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
+{
+	int i = 0;
+	struct nand_chip * chip = (struct nand_chip *) mtd->priv;
+	uint32_t * p = (uint32_t *)buf;
+
+	for (i = 0; i < (len >> 2); i++)
+		p[i] = readl(chip->IO_ADDR_R);
+
+	return;
+}
+
+/**
+ * lsi_nand_write_buf - [DEFAULT] write buffer to chip
+ * @mtd:	MTD device structure
+ * @buf:	data buffer
+ * @len:	number of bytes to write
+ *
+ * Default write function for 8bit buswith
+ */
+static void
+lsi_nand_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
+{
+	int i = 0;
+	struct nand_chip *chip = mtd->priv;
+	uint32_t *p = (uint32_t *)buf;
+
+	for (i = 0; i < (len >> 2); i++)
+		writel(p[i], chip->IO_ADDR_W);
+
+	return;
+}
+
+/**
+ * lsi_nand_verify_buf - [DEFAULT] Verify chip data against buffer
+ * @mtd:	MTD device structure
+ * @buf:	buffer containing the data to compare
+ * @len:	number of bytes to compare
+ *
+ * Default verify function for 8bit buswith
+ */
+static int
+lsi_nand_verify_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
+{
+	int i;
+	struct nand_chip *chip = mtd->priv;
+	uint32_t *p = (uint32_t *)buf;
+
+	for (i = 0; i < (len >> 2); i++) {
+		udelay(chip->chip_delay);
+		if (p[i] != readl((uint32_t *)chip->IO_ADDR_R))
+			return -EFAULT;
+	}
+
+	return 0;
+}
+
+static int lsi_nand_read_status(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+
+	chip->cmd_ctrl(mtd, NAND_CMD_STATUS, 0);
+
+	return readl(chip->IO_ADDR_R + NAND_STATUS1_REG) & 0xff;
+}
+
+
+/**
+ * lsi_nand_wait - [DEFAULT]  wait until the command is done
+ * @mtd:	MTD device structure
+ * @chip:	NAND chip structure
+ *
+ * Wait for command done. This applies to erase and program only
+ * Erase can take up to 400ms and program up to 20ms according to
+ * general NAND and SmartMedia specs
+ */
+static int lsi_nand_wait(struct mtd_info *mtd, struct nand_chip *chip)
+{
+	volatile unsigned long status = 0;
+	loff_t offset = 0;
+
+	/*
+	  When reading or writing, wait for the
+	  controller's PECC_BUSY signal to clear.
+	*/
+
+	if (FL_READING == chip->state ||
+	    FL_WRITING == chip->state) {
+		do {
+			status = readl((void *)LSI_NAND_PECC_BUSY_REGISTER);
+		} while (0 != (status & LSI_NAND_PECC_BUSY_MASK));
+	}
+
+	/*
+	  In all cases, wait for the NAND device to be "ready".
+	*/
+
+	if (FL_READING == chip->state ||
+	    FL_WRITING == chip->state ||
+	    FL_ERASING == chip->state) {
+		while (!chip->dev_ready(mtd))
+			;
+	} else {
+		printk(KERN_ERR
+		       "NAND wait called in unknown state %d\n", chip->state);
+		return NAND_STATUS_FAIL;
+	}
+
+	/*
+	  Then get the status...
+	*/
+
+	do {
+		status = lsi_nand_read_status(mtd);
+	} while (0 == (status & NAND_STATUS_READY));
+
+	status = lsi_nand_read_status(mtd);
+
+	if (status & NAND_STATUS_FAIL) {
+		offset = (readl(chip->IO_ADDR_R +
+				NAND_INDEX_REG) >> 12) << 11;
+		printk(KERN_ERR
+		       "lsi_nand_wait(): Action %d failed for "
+		       "Offset: 0x%llx, status 0x%lx\n\n",
+		       chip->state, offset, status);
+	}
+
+	return status;
+}
+
+/*
+  lsi_nand_ecc_hwctl
+*/
+
+void
+lsi_nand_ecc_hwctl(struct mtd_info *mtd, int mode)
+{
+	/* nothing to do to enable ECC */
+	return;
+}
+
+/* lsi_nand_ecc_calculate  */
+
+int
+lsi_nand_ecc_calculate(struct mtd_info *mtd, const uint8_t *dat,
+		       uint8_t *ecc_code)
+{
+	struct nand_chip *chip = mtd->priv;
+
+	/* start ECC calculation */
+	if (chip->state == FL_READING)
+		chip->cmdfunc(mtd, NAND_CMD_START_ECC_READ, -1, -1);
+	else if (chip->state == FL_WRITING)
+		chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
+
+	/* wait for PECC_BUSY to go down */
+	return chip->waitfunc(mtd, chip);
+}
+
+/* lsi_nand_ecc_correct  */
+
+int
+lsi_nand_ecc_correct(struct mtd_info *mtd, uint8_t *dat, uint8_t *read_ecc,
+		     uint8_t *calc_ecc)
+{
+	/* nothing to do to correct ECC */
+	return 0;
+}
+
+/* report_ecc_errors_ep501 */
+
+static void
+report_ecc_errors_ep501(struct mtd_info *mtd, struct nand_chip *chip)
+{
+	unsigned long ecc_status;
+	int i;
+
+	for (i = 0; i < (mtd->writesize >> 9); i++) {
+		ecc_status = readl(chip->IO_ADDR_R + EP501_NAND_PECC_REG);
+		if ((ecc_status & 0x3000) == 1)
+			printk(KERN_ERR
+			       "Single ECC Error: 0x%lx\n", ecc_status);
+		else if ((ecc_status & 0x3000) == 2)
+			printk(KERN_ERR
+			       "Uncorrectable ECC Error: 0x%lx\n", ecc_status);
+	}
+
+	return;
+}
+
+/* report_ecc_errors_ep501g1 */
+
+static void
+report_ecc_errors_ep501g1(struct mtd_info *mtd, struct nand_chip *chip)
+{
+	unsigned long ecc_status;
+	int i;
+
+	for (i = 0; i < (mtd->writesize / 1024); ++i) {
+		ecc_status = readl(chip->IO_ADDR_R +
+				   EP501G1_NAND_1BIT_ECC0_STATUS + (i * 4));
+
+		switch (ecc_status & (3 << 12)) {
+		case 01:
+			printk(KERN_ERR
+			       "Correctable ECC Error: %d:0x%lx\n",
+			       i, ecc_status);
+		case 02:
+			printk(KERN_ERR
+			       "Uncorrectable ECC Error: %d:0x%lx\n",
+			       i, ecc_status);
+		}
+	}
+
+	return;
+}
+
+/**
+ * nand_read_page_hwecc - hardware ecc based page read function
+ * @mtd:	mtd info structure
+ * @chip:	nand chip info structure
+ * @buf:	buffer to store read data
+ *
+ * Not for syndrome calculating ecc controllers which need a special oob layout
+ */
+
+static int
+lsi_nand_read_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
+			 uint8_t *buf, int page)
+{
+	struct lsi_nand_chip *priv = (struct lsi_nand_chip *)chip->priv;
+	/* read the page */
+	chip->read_buf(mtd, buf, mtd->writesize);
+
+	/* read oob data */
+	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	/* start ECC calculations */
+	chip->ecc.calculate(mtd, NULL, NULL);
+
+	/* Read the ECC Status and see if there were any errors */
+	if (LSI_NAND_EP501 == priv->nand_type)
+		report_ecc_errors_ep501(mtd, chip);
+	else
+		report_ecc_errors_ep501g1(mtd, chip);
+
+	/* cmd to controller to turn off CE */
+	chip->cmd_ctrl(mtd, priv->nand_cmd_ce_off, 0);
+	return 0;
+}
+
+/**
+ * lsi_nand_write_page_hwecc - hardware ecc based page write function
+ * @mtd:	mtd info structure
+ * @chip:	nand chip info structure
+ * @buf:	data buffer
+ */
+static void
+lsi_nand_write_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
+			  const uint8_t *buf)
+{
+	/* write the page data */
+	chip->write_buf(mtd, buf, mtd->writesize);
+
+	/*
+	 * Write the oob data. Last 12 bytes are used by HW ECC.
+	 * Do not touch them.
+	 */
+	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize - chip->ecc.bytes);
+	return;
+}
+
+/**
+ * lsi_nand_write_page - [REPLACEABLE] write one page
+ * @mtd:	MTD device structure
+ * @chip:	NAND chip descriptor
+ * @buf:	the data to write
+ * @page:	page number to write
+ * @cached:	cached programming
+ * @raw:	use _raw version of write_page
+ */
+
+static int
+lsi_nand_write_page(struct mtd_info *mtd, struct nand_chip *chip,
+		    const uint8_t *buf, int page, int cached, int raw)
+{
+	int status;
+	struct lsi_nand_chip *priv = (struct lsi_nand_chip *)chip->priv;
+
+	chip->cmdfunc(mtd, NAND_CMD_SEQIN, 0x00, page);
+
+	if (unlikely(raw))
+		chip->ecc.write_page_raw(mtd, chip, buf);
+	else
+		chip->ecc.write_page(mtd, chip, buf);
+
+	/* calculate ECC */
+	status = chip->ecc.calculate(mtd, NULL, NULL);
+
+	/* cmd to controller to turn off CE */
+	chip->cmd_ctrl(mtd, priv->nand_cmd_ce_off, 0);
+
+	/*
+	 * See if operation failed and additional status checks are
+	 * available
+	 */
+	if (status & NAND_STATUS_FAIL) {
+		printk(KERN_ERR "ERROR: Page write failed for page 0x%x\n",
+		       page);
+
+		if (chip->errstat)
+			status = chip->errstat(mtd, chip, FL_WRITING, status,
+					       page);
+
+		return -EIO;
+	}
+
+#ifdef CONFIG_MTD_NAND_VERIFY_WRITE
+	/* Send command to read back the data */
+	chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
+
+	if (chip->verify_buf(mtd, buf, mtd->writesize))
+		return -EIO;
+#endif
+
+	return 0;
+}
+
+
+/**
+ * lsi_nand_read_oob_std - [REPLACABLE] the most common OOB data read function
+ * @mtd:	mtd info structure
+ * @chip:	nand chip info structure
+ * @page:	page number to read
+ * @sndcmd:	flag whether to issue read command or not
+ */
+
+static int
+lsi_nand_read_oob(struct mtd_info *mtd, struct nand_chip *chip,
+		  int page, int sndcmd)
+{
+	struct lsi_nand_chip *priv = (struct lsi_nand_chip *)chip->priv;
+	/* send command to read oob */
+	chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
+
+	/* read oob data */
+	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	/* start ECC calculations */
+	chip->ecc.calculate(mtd, NULL, NULL);
+
+	/* Read the ECC Status and see if there were any errors */
+	if (LSI_NAND_EP501 == priv->nand_type)
+		report_ecc_errors_ep501(mtd, chip);
+	else
+		report_ecc_errors_ep501g1(mtd, chip);
+
+	/* cmd to controller to turn off CE */
+	chip->cmd_ctrl(mtd, priv->nand_cmd_ce_off, 0);
+	return sndcmd;
+}
+
+/**
+ * lsi_nand_write_oob_std - [REPLACABLE] the most common OOB data write
+ *			      function
+ * @mtd:	mtd info structure
+ * @chip:	nand chip info structure
+ * @page:	page number to write
+ */
+
+static int
+lsi_nand_write_oob(struct mtd_info *mtd, struct nand_chip *chip, int page)
+{
+	struct lsi_nand_chip *priv = (struct lsi_nand_chip *)chip->priv;
+	/* start OOB write */
+	chip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);
+
+	/*
+	 * Write the oob data. Last 12 bytes are used by HW ECC.
+	 * Do not touch them.
+	 */
+	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize - chip->ecc.bytes);
+
+	/* calculate ECC */
+	chip->ecc.calculate(mtd, NULL, NULL);
+
+	/* cmd to controller to turn off CE */
+	chip->cmd_ctrl(mtd, priv->nand_cmd_ce_off, 0);
+
+	return (chip->dev_ready(mtd) & NAND_STATUS_FAIL) ? -EIO : 0;
+}
+
+/* Linux Module Stuff */
+
+/* lsi_nand_set_config */
+
+int
+lsi_nand_set_config(struct mtd_info *mtd, struct nand_chip *chip)
+{
+	unsigned long config = 0;
+	unsigned long mbits;
+
+	struct lsi_nand_chip *priv = (struct lsi_nand_chip *)chip->priv;
+
+	mbits = ((chip->chipsize >> 20) * 8);
+
+	if (LSI_NAND_EP501 == priv->nand_type) {
+		/* The EP501 only supports 512 and 2k page sizes. */
+		if (512 != mtd->writesize &&
+		    2048 != mtd->writesize)
+			return -1;
+
+		while (64 < mbits) {
+			++config; /* 0b000=64Mbit, 0b001=128Mbit, etc. */
+			mbits >>= 1;
+		}
+
+		if (512 < mtd->writesize)
+			config |= 0x100; /* large block */
+
+		config |= 0x200;	/* not write protected */
+		chip->ecc.layout = &lsi_2k_1bit_ecclayout;
+		chip->ecc.size = mtd->writesize;
+		chip->ecc.bytes = chip->ecc.layout->eccbytes;
+	} else if (LSI_NAND_EP501G1 == priv->nand_type) {
+		/* The EP501G1 only supports 512, 2k, and 4k page sizes, */
+		if (512 != mtd->writesize &&
+		    2048 != mtd->writesize &&
+		    4096 != mtd->writesize)
+			return -1;
+
+		/* and device sizes as follows. */
+		if (512 == mtd->writesize) {
+			switch (mbits) {
+			case 64:
+				break;
+			case 128:
+				config |= 1;
+				break;
+			case 256:
+				config |= 2;
+				break;
+			case 512:
+				config |= 3;
+				break;
+			case 1024:
+				config |= 4;
+				break;
+			case 2048:
+				config |= 5;
+				break;
+			case 4096:
+				config |= 6;
+				break;
+			case 8192:
+				config |= 7;
+				break;
+			default:
+				return -1;
+				break;
+			}
+		} else {
+			switch (mbits) {
+			case 512:
+				config |= 3;
+				break;
+			case 1024:
+				config |= 4;
+				break;
+			case 2048:
+				config |= 5;
+				break;
+			case 4096:
+				config |= 6;
+				break;
+			case 8192:
+				config |= 7;
+				break;
+			case 16384:
+				break;
+			case 32768:
+				config |= 1;
+				break;
+			case 65536:
+				config |= 2;
+				break;
+			default:
+				return -1;
+				break;
+			}
+		}
+
+		switch (mtd->writesize) {
+		case 512:
+			break;
+		case 2048:
+			config |= 0x1 << 8;
+			chip->ecc.layout = &lsi_2k_4bit_ecclayout;
+			break;
+		case 4096:
+			config |= 0x2 << 8;
+			chip->ecc.layout = &lsi_4k_4bit_ecclayout;
+			break;
+		default:
+			return -1;
+			break;
+		}
+
+		config |= 1 << 10; /* not write protected */
+
+		config |= 1 << 11; /* 4 bit ECC */
+
+		if (512 < mtd->writesize)
+			config |= 1 << 12; /* 3 cycle row address */
+
+		chip->ecc.size = mtd->writesize;
+		chip->ecc.bytes = chip->ecc.layout->eccbytes;
+	} else if (LSI_NAND_EP501G3 == priv->nand_type) {
+		/* The EP501G3 only supports 2k, 4k, and 8k page sizes, */
+		if (2048 != mtd->writesize &&
+		    4096 != mtd->writesize &&
+		    8192 != mtd->writesize)
+			return -1;
+
+		/* and device sizes as follows. */
+		switch (mbits) {
+		case 512:
+			config |= 3;
+			break;
+		case 1024:
+			config |= 4;
+			break;
+		case 2048:
+			config |= 5;
+			break;
+		case 4096:
+			config |= 6;
+			break;
+		case 8192:
+			config |= 7;
+			break;
+		case 16384:
+			break;
+		case 32768:
+			config |= 1;
+			break;
+		case 65536:
+			config |= 2;
+			break;
+		default:
+			printk(KERN_ERR "Invalid Device Size: 0x%lx\n", mbits);
+			return -1;
+			break;
+		}
+
+		switch (mtd->writesize) {
+		case 2048:
+			config |= 0x1 << 8;
+			chip->ecc.layout = &lsi_2k_4bit_ecclayout;
+			break;
+		case 4096:
+			config |= 0x2 << 8;
+			chip->ecc.layout = &lsi_4k_4bit_ecclayout;
+			break;
+		default:
+			return -1;
+			break;
+		}
+
+		config |= 1 << 10; /* not write protected */
+		config |= 1 << 13; /* 3 cycle row address */
+
+		/*
+		  2K/4bit  - 32 bytes (8192)
+		  2K/8bit  - 64 bytes (16384)
+		  2K/12bit - 80 bytes (24576)
+		  ...
+		  8K/12bit - 320 bytes (98304)
+		*/
+
+		if (mtd->oobsize < chip->ecc.layout->eccbytes) {
+			printk(KERN_ERR
+				"ECC requires %d bytes,"
+				"only %d are available.\n",
+				chip->ecc.layout->eccbytes, mtd->oobsize);
+			return -1;
+		}
+
+		config |= 1 << 11; /* 4 bit ECC */
+		mtd->oobavail = mtd->oobsize - chip->ecc.layout->eccbytes;
+		mtd->oobavail -= (mtd->oobavail % 4);
+		config |= (chip->ecc.layout->eccbytes / 4) << 16;
+		chip->ecc.size = mtd->writesize;
+		chip->ecc.bytes = chip->ecc.layout->eccbytes;
+	} else {
+		return -1;
+	}
+
+	writel(config, chip->IO_ADDR_W + EP501_NAND_CONFIG_REG);
+	return 0;
+}
+
+
+static int lsi_nand_check_type(struct lsi_nand_chip *chip)
+{
+/*
+  Determine the version of the controller.
+
+  As there is not version register, see if bits 5:3 of the
+  configuration register are writable.  There are in the EP501
+  case and aren't in the EP501G1 case.
+*/
+	unsigned long cr;
+	unsigned long cr_save;
+
+	cr = cr_save = readl((void *)(chip->vbase + NAND_CONFIG_REG));
+	cr = 0x2038;
+	writel(cr, (void *)(chip->vbase + EP501_NAND_CONFIG_REG));
+	cr = readl((void *)chip->vbase + EP501_NAND_CONFIG_REG);
+	writel(cr_save,
+		(void *)(chip->vbase + EP501_NAND_CONFIG_REG));
+
+	if (0 == (cr & 0x2038))
+		chip->nand_type = LSI_NAND_EP501G1;
+	else if (0x38 == (cr & 0x2038))
+		chip->nand_type = LSI_NAND_EP501;
+	else if (0x2000 == (cr & 0x2038))
+		chip->nand_type = LSI_NAND_EP501G3;
+	else
+		chip->nand_type = LSI_NAND_NONE;
+
+	switch (chip->nand_type) {
+	case LSI_NAND_EP501:
+		printk(KERN_INFO "EP501 NAND Controller.\n");
+		chip->nand_cmd_ce_off = NAND_CMD_CE_OFF_501;
+		break;
+	case LSI_NAND_EP501G1:
+		printk(KERN_INFO "EP501G1 NAND Controller.\n");
+		chip->nand_cmd_ce_off = NAND_CMD_CE_OFF_501G1;
+		break;
+	case LSI_NAND_EP501G3:
+		printk(KERN_INFO "EP501G3 NAND Controller.\n");
+		chip->nand_cmd_ce_off = NAND_CMD_CE_OFF_501G3;
+		break;
+	default:
+		printk(KERN_ERR "Unknown NAND Controller!\n");
+		return -1;
+	}
+	return 0;
+}
+/*  lsi_nand_init */
+
+static int __init
+lsi_acp_nand_probe(struct of_device *ofdev,
+			const struct of_device_id *match)
+{
+
+#ifdef CONFIG_MTD_PARTITIONS
+	struct mtd_partition *parts;
+	const char *probes[] = { "cmdlinepart", "RedBoot", NULL };
+#endif
+	struct lsi_nand_chip *priv;
+	int rc;
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		rc = -ENOMEM;
+		goto out;
+	}
+
+	priv->vbase = of_iomap(ofdev->node, 0);
+	if (!priv->vbase) {
+		rc = -ENOMEM;
+		goto err_iomap;
+	}
+
+	if (lsi_nand_check_type(priv) < 0) {
+		rc = -ENODEV;
+		goto err_device;
+	}
+
+	/* Initialize structures */
+	/* Link the private data with the MTD structure */
+	priv->dev = &ofdev->dev;
+	priv->nand_mtd.priv = &priv->nand_chip;
+	priv->nand_chip.priv = priv;
+	priv->nand_mtd.owner = THIS_MODULE;
+	priv->nand_mtd.name = "acp-nand";
+
+	/* init chip callbacks */
+	priv->nand_chip.IO_ADDR_R = (void *) priv->vbase;
+	priv->nand_chip.IO_ADDR_W = (void *) priv->vbase;
+	priv->nand_chip.write_buf = lsi_nand_write_buf;
+	priv->nand_chip.read_buf = lsi_nand_read_buf;
+	priv->nand_chip.verify_buf = lsi_nand_verify_buf;
+	priv->nand_chip.write_page = lsi_nand_write_page;
+	priv->nand_chip.cmd_ctrl = lsi_nand_hwcontrol;
+	priv->nand_chip.dev_ready = lsi_nand_device_ready;
+	priv->nand_chip.cmdfunc = lsi_nand_command;
+	priv->nand_chip.waitfunc = lsi_nand_wait;
+	priv->nand_chip.chip_delay = 10;
+	priv->nand_chip.options = NAND_USE_FLASH_BBT;
+
+	/* initialize ECC */
+	priv->nand_chip.ecc.mode = NAND_ECC_HW;
+	priv->nand_chip.ecc.steps = 1;
+	priv->nand_chip.ecc.total = 12;
+	priv->nand_chip.ecc.hwctl = lsi_nand_ecc_hwctl;
+	priv->nand_chip.ecc.calculate = lsi_nand_ecc_calculate;
+	priv->nand_chip.ecc.correct = lsi_nand_ecc_correct;
+	priv->nand_chip.ecc.read_page = lsi_nand_read_page_hwecc;
+	priv->nand_chip.ecc.write_page = lsi_nand_write_page_hwecc;
+	priv->nand_chip.ecc.read_page_raw = lsi_nand_read_page_hwecc;
+	priv->nand_chip.ecc.write_page_raw = lsi_nand_write_page_hwecc;
+	priv->nand_chip.ecc.read_oob = lsi_nand_read_oob;
+	priv->nand_chip.ecc.write_oob = lsi_nand_write_oob;
+
+	printk(KERN_ERR "Enabling NAND ECC...\n");
+	/* clear any existing ECC status */
+	writel(0x0, priv->vbase + NAND_INTR_STATUS_REG);
+	/* enable ECC */
+	writel(0x0, priv->vbase + NAND_INTR_EN_REG);
+
+	/*
+	  ======================================================================
+	  Timing Control
+
+	  This may need to be changed, based on the devices used.  Each field is
+	  described below.
+	*/
+
+	/*
+	  TCR0 - NAND Timing Control Register 0
+	*/
+
+	{
+		union nand_timing_control_register_0_t tcr0;
+
+		/* TH [31:24] - CLE, CE & ALE hold Time */
+		tcr0.bits.th = 0x08;
+
+		/* TRP [23:16] - Read Pulse Width */
+		tcr0.bits.trp = 0x0c;
+
+		/* TWP [15:8] - Write Pulse Width */
+		tcr0.bits.twp = 0x0c;
+
+		/* TS [7:0] - Setup Time for CLE, CE & ALE */
+		tcr0.bits.ts = 0x05;
+
+		writel(tcr0.raw,
+		       (priv->vbase + NAND_TIMING1_REG));
+	}
+
+	/*
+	  TCR1 - NAND Timing Control Register 1
+	*/
+
+	{
+		union nand_timing_control_register_1_t tcr1;
+
+		/* TWB [31:24] - WE Rising Edge to RY/BY Falling Edge */
+		tcr1.bits.twb = 0x1e;
+
+		/* TRR [23:16] - RY/BY Rising Edge To Read Falling Edge */
+		tcr1.bits.trr = 0x07;
+
+		/* TRH [15:8] - Read Pulse High Time */
+		tcr1.bits.trh = 0x03;
+
+		/* TWH [7:0] - Write Pulse High Time */
+		tcr1.bits.twh = 0x03;
+
+		writel(tcr1.raw,
+		       (priv->vbase + NAND_TIMING2_REG));
+	}
+
+	/*
+	  TCR2 - NAND Timing Control Register 2 (EP501G3 Only)
+	*/
+
+	{
+		union nand_timing_control_register_2_t tcr2;
+
+		tcr2.bits.tccs = 0x10;
+		tcr2.bits.twhr = 0x10;
+		tcr2.bits.trhw = 0x14;
+		writel(tcr2.raw,
+		       (priv->vbase + EP501G3_NAND_TIMING2_REG));
+	}
+
+	printk(KERN_ERR "Searching for NAND flash...\n");
+	/* Scan to find existence of the device */
+	if (nand_scan(&priv->nand_mtd, 1)) {
+		printk(KERN_ERR "nand_scan failure...\n");
+		rc = -ENXIO;
+		goto err_device;
+	}
+
+	/* Register the partitions */
+#ifdef CONFIG_MTD_PARTITIONS
+#ifdef CONFIG_MTD_OF_PARTS
+	/* Since uboot from lsi auto add mtd parts to command line,
+	 * driver should check partition from device tree first first.
+	 */
+	rc = of_mtd_parse_partitions(priv->dev, ofdev->node, &parts);
+	if (rc < 0)
+		goto err_device;
+	if (rc == 0) {
+#endif
+		rc = parse_mtd_partitions(&priv->nand_mtd, probes, &parts, 0);
+		if (rc < 0)
+			goto err_device;
+#ifdef CONFIG_MTD_OF_PARTS
+	}
+#endif
+	if (rc > 0)
+		add_mtd_partitions(&priv->nand_mtd, parts, rc);
+	else
+#endif
+		add_mtd_device(&priv->nand_mtd);
+
+	dev_set_drvdata(&ofdev->dev, priv);
+	return 0;
+
+err_device:
+	iounmap(priv->vbase);
+err_iomap:
+	kfree(priv);
+out:
+	return rc;
+}
+
+/* lsi_nand_exit */
+
+static void __exit
+lsi_acp_nand_remove(struct of_device *ofdev)
+{
+	struct lsi_nand_chip *priv = dev_get_drvdata(&ofdev->dev);
+	/* Release resources, unregister device */
+	iounmap(priv->vbase);
+	nand_release(&priv->nand_mtd);
+	kfree(priv);
+}
+
+static const struct of_device_id lsi_acp_nand_match[] = {
+	{
+		.compatible = "ep501-nand",
+	},
+	{ /* end of list */ }
+};
+
+static struct of_platform_driver lsi_acp_nand_driver = {
+	.name = "lsi,acp-nand",
+	.match_table = lsi_acp_nand_match,
+	.probe = lsi_acp_nand_probe,
+	.remove = __exit_p(lsi_acp_nand_remove),
+};
+
+static int __init lsi_nand_init(void)
+{
+	return of_register_platform_driver(&lsi_acp_nand_driver);
+}
+
+static void __exit lsi_nand_exit(void)
+{
+	of_unregister_platform_driver(&lsi_acp_nand_driver);
+}
+
+module_init(lsi_nand_init);
+module_exit(lsi_nand_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jay Jayatheerthan <jay.jayatheerthan@lsi.com>");
+MODULE_DESCRIPTION("MTD map driver for LSI's ACP board");
diff --git a/drivers/mtd/nand/ep501.h b/drivers/mtd/nand/ep501.h
new file mode 100644
index 0000000..1d65dfa
--- /dev/null
+++ b/drivers/mtd/nand/ep501.h
@@ -0,0 +1,196 @@
+#ifndef __EP501_HEAD__
+#define __EP501_HEAD__
+
+#define NAND_DATA_REG	      0x00000000
+#define NAND_CMD_REG	      0x00008000
+#define NAND_INDEX_REG	      0x00008004
+#define NAND_STATUS1_REG      0x00008008
+#define NAND_STATUS2_REG      0x0000800C
+#define NAND_ID0_REG	      0x00008010
+#define NAND_ID1_REG	      0x00008014
+#define NAND_ID2_REG	      0x00008018
+#define NAND_ID3_REG	      0x0000801C
+#define NAND_ID4_REG	      0x00008020
+#define NAND_ID5_REG	      0x00008024
+#define NAND_ID6_REG	      0x00008028
+#define NAND_ID7_REG	      0x0000802C
+#define NAND_INTR_EN_REG      0x00008030
+#define NAND_INTR_STATUS_REG  0x00008034
+#define NAND_INTR_REG	      0x00008038
+#define NAND_ECC_ADDR_LOG_REG 0x0000803C
+#define NAND_ECC_VAL_REG      0x00008040
+#define NAND_ECC_INJECT_REG   0x00008044
+#define NAND_EXT_INDEX_REG    0x00008048
+#define NAND_TIMING1_REG      0x0000804C
+#define NAND_TIMING2_REG      0x00008050
+#define NAND_CONFIG_REG	      0x00008054
+#define NAND_PECC_REG	      0x00008058
+
+#define EP501_NAND_DATA_REG         0x0000
+#define EP501_NAND_CMD_REG          0x8000
+#define EP501_NAND_INDEX_REG        0x8004
+#define EP501_NAND_STATUS0_REG      0x8008
+#define EP501_NAND_STATUS1_REG      0x800C
+#define EP501_NAND_ID0_REG          0x8010
+#define EP501_NAND_ID1_REG          0x8014
+#define EP501_NAND_ID2_REG          0x8018
+#define EP501_NAND_ID3_REG          0x801C
+#define EP501_NAND_ID4_REG          0x8020
+#define EP501_NAND_ID5_REG          0x8024
+#define EP501_NAND_ID6_REG          0x8028
+#define EP501_NAND_ID7_REG          0x802C
+#define EP501_NAND_INTR_EN_REG      0x8030
+#define EP501_NAND_INTR_STATUS_REG  0x8034
+#define EP501_NAND_INTR_REG         0x8038
+#define EP501_NAND_ECC_ADDR_LOG_REG 0x803C
+#define EP501_NAND_ECC_VAL_REG      0x8040
+#define EP501_NAND_ECC_INJECT_REG   0x8044
+#define EP501_NAND_EXT_INDEX_REG    0x8048
+#define EP501_NAND_TIMING0_REG      0x804C
+#define EP501_NAND_TIMING1_REG      0x8050
+#define EP501_NAND_CONFIG_REG       0x8054
+#define EP501_NAND_PECC_REG         0x8058
+
+#define EP501G1_NAND_DATA_REG         0x0000
+#define EP501G1_NAND_CMD_REG          0x8000
+#define EP501G1_NAND_INDEX_REG        0x8004
+#define EP501G1_NAND_STATUS0_REG      0x8008
+#define EP501G1_NAND_ID0_REG          0x8010
+#define EP501G1_NAND_ID2_REG          0x8018
+#define EP501G1_NAND_ID4_REG          0x8020
+#define EP501G1_NAND_ID6_REG          0x8028
+#define EP501G1_NAND_INTR_EN_REG      0x8030
+#define EP501G1_NAND_INTR_STATUS_REG  0x8034
+#define EP501G1_NAND_INTR_REG         0x8038
+#define EP501G1_NAND_EXT_INDEX_REG    0x8048
+#define EP501G1_NAND_TIMING0_REG      0x804C
+#define EP501G1_NAND_TIMING1_REG      0x8050
+#define EP501G1_NAND_CONFIG_REG       0x8054
+#define EP501G1_NAND_1BIT_ECC0_STATUS 0x8058
+#define EP501G1_NAND_1BIT_ECC1_STATUS 0x805c
+#define EP501G1_NAND_1BIT_ECC2_STATUS 0x8060
+#define EP501G1_NAND_1BIT_ECC3_STATUS 0x8064
+#define EP501G1_NAND_1BIT_ECC4_STATUS 0x8068
+#define EP501G1_NAND_1BIT_ECC5_STATUS 0x806c
+#define EP501G1_NAND_1BIT_ECC6_STATUS 0x8070
+#define EP501G1_NAND_1BIT_ECC7_STATUS 0x8074
+#define EP501G1_NAND_BCH_STATUS       0x807c
+#define EP501G1_NAND_SYN_R12_S0       0x8080
+#define EP501G1_NAND_SYN_R34_S0       0x8084
+#define EP501G1_NAND_SYN_R56_S0       0x8088
+#define EP501G1_NAND_SYN_R78_S0       0x808c
+#define EP501G1_NAND_SYN_R12_S1       0x8090
+#define EP501G1_NAND_SYN_R34_S1       0x8094
+#define EP501G1_NAND_SYN_R56_S1       0x8098
+#define EP501G1_NAND_SYN_R78_S1       0x809c
+#define EP501G1_NAND_SYN_R12_S2       0x80a0
+#define EP501G1_NAND_SYN_R34_S2       0x80a4
+#define EP501G1_NAND_SYN_R56_S2       0x80a8
+#define EP501G1_NAND_SYN_R78_S2       0x80ac
+#define EP501G1_NAND_SYN_R12_S3       0x80b0
+#define EP501G1_NAND_SYN_R34_S3       0x80b4
+#define EP501G1_NAND_SYN_R56_S3       0x80b8
+#define EP501G1_NAND_SYN_R78_S3       0x80bc
+#define EP501G1_NAND_SYN_R12_S4       0x80c0
+#define EP501G1_NAND_SYN_R34_S4       0x80c4
+#define EP501G1_NAND_SYN_R56_S4       0x80c8
+#define EP501G1_NAND_SYN_R78_S4       0x80cc
+#define EP501G1_NAND_SYN_R12_S5       0x80d0
+#define EP501G1_NAND_SYN_R34_S5       0x80d4
+#define EP501G1_NAND_SYN_R56_S5       0x80d8
+#define EP501G1_NAND_SYN_R78_S5       0x80dc
+#define EP501G1_NAND_SYN_R12_S6       0x80e0
+#define EP501G1_NAND_SYN_R34_S6       0x80e4
+#define EP501G1_NAND_SYN_R56_S6       0x80e8
+#define EP501G1_NAND_SYN_R78_S6       0x80ec
+#define EP501G1_NAND_SYN_R12_S7       0x80f0
+#define EP501G1_NAND_SYN_R34_S7       0x80f4
+#define EP501G1_NAND_SYN_R56_S7       0x80f8
+#define EP501G1_NAND_SYN_R78_S7       0x80fc
+
+#define EP501G3_NAND_DATA_REG         0x0000
+#define EP501G3_NAND_CMD_REG          0x8000
+#define EP501G3_NAND_INDEX_REG        0x8004
+#define EP501G3_NAND_STATUS0_REG      0x8008
+#define EP501G3_NAND_ID0_REG          0x8010
+#define EP501G3_NAND_ID2_REG          0x8018
+#define EP501G3_NAND_ID4_REG          0x8020
+#define EP501G3_NAND_ID6_REG          0x8028
+#define EP501G3_NAND_INTR_EN_REG      0x8030
+#define EP501G3_NAND_INTR_STATUS_REG  0x8034
+#define EP501G3_NAND_INTR_REG         0x8038
+#define EP501G3_NAND_EXT_INDEX_REG    0x8048
+#define EP501G3_NAND_TIMING0_REG      0x804C
+#define EP501G3_NAND_TIMING1_REG      0x8050
+#define EP501G3_NAND_CONFIG_REG       0x8054
+#define EP501G3_NAND_TIMING2_REG      0x805c
+#define EP501G3_NAND_BCH_STATUS       0x807c
+#define EP501G3_NAND_SYN_R12_S0       0x8080
+#define EP501G3_NAND_SYN_R34_S0       0x8084
+#define EP501G3_NAND_SYN_R56_S0       0x8088
+#define EP501G3_NAND_SYN_R78_S0       0x808c
+#define EP501G3_NAND_SYN_R12_S1       0x8090
+#define EP501G3_NAND_SYN_R34_S1       0x8094
+#define EP501G3_NAND_SYN_R56_S1       0x8098
+#define EP501G3_NAND_SYN_R78_S1       0x809c
+#define EP501G3_NAND_SYN_R12_S2       0x80a0
+#define EP501G3_NAND_SYN_R34_S2       0x80a4
+#define EP501G3_NAND_SYN_R56_S2       0x80a8
+#define EP501G3_NAND_SYN_R78_S2       0x80ac
+#define EP501G3_NAND_SYN_R12_S3       0x80b0
+#define EP501G3_NAND_SYN_R34_S3       0x80b4
+#define EP501G3_NAND_SYN_R56_S3       0x80b8
+#define EP501G3_NAND_SYN_R78_S3       0x80bc
+#define EP501G3_NAND_SYN_R12_S4       0x80c0
+#define EP501G3_NAND_SYN_R34_S4       0x80c4
+#define EP501G3_NAND_SYN_R56_S4       0x80c8
+#define EP501G3_NAND_SYN_R78_S4       0x80cc
+#define EP501G3_NAND_SYN_R12_S5       0x80d0
+#define EP501G3_NAND_SYN_R34_S5       0x80d4
+#define EP501G3_NAND_SYN_R56_S5       0x80d8
+#define EP501G3_NAND_SYN_R78_S5       0x80dc
+#define EP501G3_NAND_SYN_R12_S6       0x80e0
+#define EP501G3_NAND_SYN_R34_S6       0x80e4
+#define EP501G3_NAND_SYN_R56_S6       0x80e8
+#define EP501G3_NAND_SYN_R78_S6       0x80ec
+#define EP501G3_NAND_SYN_R12_S7       0x80f0
+#define EP501G3_NAND_SYN_R34_S7       0x80f4
+#define EP501G3_NAND_SYN_R56_S7       0x80f8
+#define EP501G3_NAND_SYN_R78_S7       0x80fc
+#define EP501G3_NAND_SYN_R12_S8       0x8100
+#define EP501G3_NAND_SYN_R34_S8       0x8104
+#define EP501G3_NAND_SYN_R56_S8       0x8108
+#define EP501G3_NAND_SYN_R78_S8       0x810c
+#define EP501G3_NAND_SYN_R12_S9       0x8110
+#define EP501G3_NAND_SYN_R34_S9       0x8114
+#define EP501G3_NAND_SYN_R56_S9       0x8118
+#define EP501G3_NAND_SYN_R78_S9       0x811c
+#define EP501G3_NAND_SYN_R12_S10      0x8120
+#define EP501G3_NAND_SYN_R34_S10      0x8124
+#define EP501G3_NAND_SYN_R56_S10      0x8128
+#define EP501G3_NAND_SYN_R78_S10      0x812c
+#define EP501G3_NAND_SYN_R12_S11      0x8130
+#define EP501G3_NAND_SYN_R34_S11      0x8134
+#define EP501G3_NAND_SYN_R56_S11      0x8138
+#define EP501G3_NAND_SYN_R78_S11      0x813c
+#define EP501G3_NAND_SYN_R12_S12      0x8140
+#define EP501G3_NAND_SYN_R34_S12      0x8144
+#define EP501G3_NAND_SYN_R56_S12      0x8148
+#define EP501G3_NAND_SYN_R78_S12      0x814c
+#define EP501G3_NAND_SYN_R12_S13      0x8150
+#define EP501G3_NAND_SYN_R34_S13      0x8154
+#define EP501G3_NAND_SYN_R56_S13      0x8158
+#define EP501G3_NAND_SYN_R78_S13      0x815c
+#define EP501G3_NAND_SYN_R12_S14      0x8160
+#define EP501G3_NAND_SYN_R34_S14      0x8164
+#define EP501G3_NAND_SYN_R56_S14      0x8168
+#define EP501G3_NAND_SYN_R78_S14      0x816c
+#define EP501G3_NAND_SYN_R12_S15      0x8170
+#define EP501G3_NAND_SYN_R34_S15      0x8174
+#define EP501G3_NAND_SYN_R56_S15      0x8178
+#define EP501G3_NAND_SYN_R78_S15      0x817c
+
+int
+lsi_nand_set_config(struct mtd_info *mtd, struct nand_chip *chip);
+
+#endif
diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c
index 8f2958f..4f4b531 100644
--- a/drivers/mtd/nand/nand_base.c
+++ b/drivers/mtd/nand/nand_base.c
@@ -52,6 +52,10 @@
 #include <linux/mtd/partitions.h>
 #endif
 
+#ifdef CONFIG_MTD_NAND_LSI
+#include "ep501.h"
+#endif /* CONFIG_LSI_NAND */
+
 /* Define default oob placement schemes for large and small page devices */
 static struct nand_ecclayout nand_oob_8 = {
 	.eccbytes = 3,
@@ -403,7 +407,12 @@ static int nand_check_wp(struct mtd_info *mtd)
 	struct nand_chip *chip = mtd->priv;
 	/* Check the WP bit */
 	chip->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);
+#ifdef CONFIG_MTD_NAND_LSI
+	return (readl(chip->IO_ADDR_R +
+		NAND_STATUS1_REG) & NAND_STATUS_WP) ? 0 : 1;
+#else
 	return (chip->read_byte(mtd) & NAND_STATUS_WP) ? 0 : 1;
+#endif
 }
 
 /**
@@ -2430,6 +2439,12 @@ int nand_erase_nand(struct mtd_info *mtd, struct erase_info *instr,
 	/* Deselect and wake up anyone waiting on the device */
 	nand_release_device(mtd);
 
+#ifdef CONFIG_MTD_NAND_LSI
+	/* if erase failed for a block, mark it as bad block */
+	if (status & NAND_STATUS_FAIL)
+		mtd->block_markbad(mtd, page << chip->page_shift);
+#endif /* CONFIG_MTD_NAND_LSI */
+
 	/* Do call back function */
 	if (!ret)
 		mtd_erase_callback(instr);
@@ -2601,8 +2616,13 @@ static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
 	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
 
 	/* Read manufacturer and device IDs */
+#ifdef CONFIG_MTD_NAND_LSI
+	*maf_id = readb(chip->IO_ADDR_R + NAND_ID0_REG);
+	dev_id = readb(chip->IO_ADDR_R + NAND_ID2_REG);
+#else  /* CONFIG_MTD_NAND_LSI */
 	*maf_id = chip->read_byte(mtd);
 	dev_id = chip->read_byte(mtd);
+#endif /* CONFIG_MTD_NAND_LSI */
 
 	/* Try again to make sure, as some systems the bus-hold or other
 	 * interface concerns can cause random data which looks like a
@@ -2613,9 +2633,13 @@ static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
 	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
 
 	/* Read manufacturer and device IDs */
-
+#ifdef CONFIG_MTD_NAND_LSI
+	tmp_manf = readb(chip->IO_ADDR_R + NAND_ID0_REG);
+	tmp_id = readb(chip->IO_ADDR_R + NAND_ID2_REG);
+#else  /* CONFIG_MTD_NAND_LSI */
 	tmp_manf = chip->read_byte(mtd);
 	tmp_id = chip->read_byte(mtd);
+#endif /* CONFIG_MTD_NAND_LSI */
 
 	if (tmp_manf != *maf_id || tmp_id != dev_id) {
 		printk(KERN_INFO "%s: second ID read did not match "
@@ -2643,10 +2667,17 @@ static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
 	/* Newer devices have all the information in additional id bytes */
 	if (!type->pagesize) {
 		int extid;
+#ifdef CONFIG_MTD_NAND_LSI
+		/* The 3rd id byte holds MLC / multichip data */
+		chip->cellinfo = readb(chip->IO_ADDR_R + NAND_ID4_REG);
+		/* The 4th id byte is the important one */
+		extid = readb(chip->IO_ADDR_R + NAND_ID6_REG);
+#else  /* CONFIG_MTD_NAND_LSI */
 		/* The 3rd id byte holds MLC / multichip data */
 		chip->cellinfo = chip->read_byte(mtd);
 		/* The 4th id byte is the important one */
 		extid = chip->read_byte(mtd);
+#endif /* CONFIG_MTD_NAND_LSI */
 		/* Calc pagesize */
 		mtd->writesize = 1024 << (extid & 0x3);
 		extid >>= 2;
@@ -2669,6 +2700,11 @@ static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
 		busw = type->options & NAND_BUSWIDTH_16;
 	}
 
+#ifdef CONFIG_MTD_NAND_LSI
+	/* Set the EP501/EP501G1 config register. */
+	lsi_nand_set_config(mtd, chip);
+#endif /* CONFIG_MTD_NAND_LSI */
+
 	/* Try to identify manufacturer */
 	for (maf_idx = 0; nand_manuf_ids[maf_idx].id != 0x0; maf_idx++) {
 		if (nand_manuf_ids[maf_idx].id == *maf_id)
-- 
1.7.0.5

