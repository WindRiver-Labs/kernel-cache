From d6672dca1bbcf9d8f98cc235b04c8ba1f769df80 Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Wed, 13 Apr 2011 12:16:34 +0800
Subject: [PATCH 17/27] PowerPC:ACP34xx:Add app350 i2c controller driver

I2C driver for the controller on ACP platform.
The EEPROM attached on the bus can be accessed.

Signed-off-by: Fei Wu <fei.wu@windriver.com>

Update driver register interface to support ppc of-platform style
driver register interface.

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/i2c/busses/Kconfig   |    6 +
 drivers/i2c/busses/Makefile  |    1 +
 drivers/i2c/busses/i2c-acp.c |  355 ++++++++++++++++++++++++++++++++++++++++++
 drivers/i2c/busses/i2c-acp.h |  146 +++++++++++++++++
 4 files changed, 508 insertions(+), 0 deletions(-)
 create mode 100644 drivers/i2c/busses/i2c-acp.c
 create mode 100644 drivers/i2c/busses/i2c-acp.h

diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index 9c6170c..9864d1a 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -673,6 +673,12 @@ config I2C_TINY_USB
 
 comment "Other I2C/SMBus bus drivers"
 
+config I2C_ACP
+	tristate "ACP I2C bus support"
+	default y
+	help
+	  Say yes if you want to support the I2C bus on ACP platforms.
+
 config I2C_ACORN
 	tristate "Acorn IOC/IOMD I2C bus support"
 	depends on ARCH_ACORN
diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
index 097236f..a774cb3 100644
--- a/drivers/i2c/busses/Makefile
+++ b/drivers/i2c/busses/Makefile
@@ -28,6 +28,7 @@ obj-$(CONFIG_I2C_HYDRA)		+= i2c-hydra.o
 obj-$(CONFIG_I2C_POWERMAC)	+= i2c-powermac.o
 
 # Embebbed system I2C/SMBus host controller drivers
+obj-$(CONFIG_I2C_ACP)		+= i2c-acp.o
 obj-$(CONFIG_I2C_AT91)		+= i2c-at91.o
 obj-$(CONFIG_I2C_AU1550)	+= i2c-au1550.o
 obj-$(CONFIG_I2C_BLACKFIN_TWI)	+= i2c-bfin-twi.o
diff --git a/drivers/i2c/busses/i2c-acp.c b/drivers/i2c/busses/i2c-acp.c
new file mode 100644
index 0000000..e0f06bf
--- /dev/null
+++ b/drivers/i2c/busses/i2c-acp.c
@@ -0,0 +1,355 @@
+/*
+ * Copyright (C) 2010 Wind River Systems
+ *
+ * I2C master mode controller driver, used in LSI ACP34xx board.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+
+#include <linux/of_platform.h>
+#include <linux/of.h>
+#include <linux/of_i2c.h>
+
+#include "i2c-acp.h"
+
+struct acp_i2c {
+	struct device		*dev;
+	struct i2c_adapter	adap;
+	void __iomem *base;
+	void __iomem *timer_base;
+};
+
+static int acp_i2c_xfer_one_read(struct acp_i2c *i2c, struct i2c_msg *msg)
+{
+	struct xfer_config xfer_config = {0};
+	struct recv_config recv_config = {0};
+	struct recv_status recv_status = {0};
+	struct clk_config clk_config = {0};
+	struct hold_setup_clk start_condition = {0};
+	struct hold_setup_clk stop_condition = {0};
+	struct hold_setup_clk data_condition = {0};
+	unsigned *v;
+
+	uint32_t data[2] = {0};
+	uint8_t *cp = (uint8_t *)data;
+	int timeout = 2;
+	int i;
+
+	BUG_ON(msg->len > 8);
+
+	v = (unsigned *)&clk_config;
+	clk_config.pclk_low = CFG_CLK_CONFIG_SCL_LOW_RD;
+	clk_config.pclk_high = CFG_CLK_CONFIG_SCL_HIGH;
+	writel(*v, i2c->base + CLK_CONFIG);
+	dev_dbg(i2c->dev, "read clk config: %x\n", *v);
+
+	v = (unsigned *)&start_condition;
+	start_condition.pclk_setup = CFG_START_SETUP_PERIOD;
+	start_condition.pclk_hold = CFG_START_HOLD_PERIOD;
+	writel(*v, i2c->base + START_SETUP_HOLD_CONFIG);
+	dev_dbg(i2c->dev, "start cfg: %x\n", *v);
+
+	v = (unsigned *)&stop_condition;
+	stop_condition.pclk_setup = CFG_STOP_SETUP_PERIOD;
+	stop_condition.pclk_hold = CFG_STOP_HOLD_PERIOD;
+	writel(*v, i2c->base + STOP_SETUP_HOLD_CONFIG);
+	dev_dbg(i2c->dev, "stop cfg: %x\n", *v);
+
+	v = (unsigned *)&data_condition;
+	data_condition.pclk_setup = CFG_DATA_SETUP_PERIOD;
+	data_condition.pclk_hold = CFG_DATA_HOLD_PERIOD;
+	writel(*v, i2c->base + DATA_SETUP_HOLD_CONFIG);
+	dev_dbg(i2c->dev, "data cfg: %x\n", *v);
+
+	writel(msg->addr, i2c->base + SLAVE_ADDRESS);
+
+	writel(0x0, i2c->base + INTR_ENABLE);
+
+	v = (unsigned *)&recv_config;
+	recv_config.ready = 1;
+	recv_config.nbytes = msg->len;
+	writel(*v, i2c->base + RECV_CONFIG);
+	dev_dbg(i2c->dev, "recv cfg: %x\n", *v);
+
+	v = (unsigned *)&xfer_config;
+	xfer_config.ready = 1;
+	xfer_config.nbytes = 0;
+	xfer_config.master_mode_active = 1;
+	xfer_config.command = 1;
+	writel(*v, i2c->base + XFER_CONFIG);
+	dev_dbg(i2c->dev, "xfer cfg: %x\n", *v);
+
+	do {
+		v = (unsigned *)&recv_status;
+		*v = readl(i2c->base + RECV_STATUS);
+		dev_dbg(i2c->dev, "recv status: %x\n", *v);
+		if (recv_status.error) {
+			dev_warn(i2c->dev, "acp i2c read error\n");
+			return -EIO;
+		} else if (recv_status.done)
+			break;
+
+		udelay(200);
+	} while (--timeout);
+
+	if (timeout <= 0) {
+		dev_warn(i2c->dev, "acp i2c read timeout\n");
+		return -EIO;
+	}
+
+	data[0] = __raw_readl(i2c->base + RECV_DATA0);
+	data[1] = __raw_readl(i2c->base + RECV_DATA1);
+
+	dev_dbg(i2c->dev, "nbytes done: %d\n", recv_status.nbytes_done);
+	for (i = 0; i < recv_status.nbytes_done; i++)
+		msg->buf[recv_status.nbytes_done - i - 1] = cp[i];
+
+	return 0;
+}
+
+static int acp_i2c_xfer_one_write(struct acp_i2c *i2c, struct i2c_msg *msg)
+{
+	struct xfer_config xfer_config = {0};
+	struct xfer_status xfer_status = {0};
+	struct clk_config clk_config = {0};
+	struct hold_setup_clk start_condition = {0};
+	struct hold_setup_clk stop_condition = {0};
+	struct hold_setup_clk data_condition = {0};
+	unsigned *v;
+
+	uint32_t buf[2] = {0};
+	uint8_t *cp = (uint8_t *)buf;
+	int timeout = 2;
+	int i;
+
+	BUG_ON(msg->len > 8);
+
+	for (i = 0; i < msg->len; i++)
+		cp[msg->len - i - 1] = msg->buf[i];
+
+	v = (unsigned *)&clk_config;
+	clk_config.pclk_low = CFG_CLK_CONFIG_SCL_LOW;
+	clk_config.pclk_high = CFG_CLK_CONFIG_SCL_HIGH;
+	writel(*v, i2c->base + CLK_CONFIG);
+	dev_dbg(i2c->dev, "write clk config: %x\n", *v);
+
+	v = (unsigned *)&start_condition;
+	start_condition.pclk_setup = CFG_START_SETUP_PERIOD;
+	start_condition.pclk_hold = CFG_START_HOLD_PERIOD;
+	writel(*v, i2c->base + START_SETUP_HOLD_CONFIG);
+	dev_dbg(i2c->dev, "start cfg: %x\n", *v);
+
+	v = (unsigned *)&stop_condition;
+	stop_condition.pclk_setup = CFG_STOP_SETUP_PERIOD;
+	stop_condition.pclk_hold = CFG_STOP_HOLD_PERIOD;
+	writel(*v, i2c->base + STOP_SETUP_HOLD_CONFIG);
+	dev_dbg(i2c->dev, "stop cfg: %x\n", *v);
+
+	v = (unsigned *)&data_condition;
+	data_condition.pclk_setup = CFG_DATA_SETUP_PERIOD;
+	data_condition.pclk_hold = CFG_DATA_HOLD_PERIOD;
+	writel(*v, i2c->base + DATA_SETUP_HOLD_CONFIG);
+	dev_dbg(i2c->dev, "data cfg: %x\n", *v);
+
+	writel(msg->addr, i2c->base + SLAVE_ADDRESS);
+
+	__raw_writel(buf[0], i2c->base + XFER_DATA0);
+	__raw_writel(buf[1], i2c->base + XFER_DATA1);
+
+	writel(0x0, i2c->base + INTR_ENABLE);
+
+	v = (unsigned *)&xfer_config;
+	xfer_config.ready = 1;
+	xfer_config.nbytes = msg->len;
+	xfer_config.master_mode_active = 1;
+	writel(*v, i2c->base + XFER_CONFIG);
+	dev_dbg(i2c->dev, "xfer cfg: %x\n", *v);
+
+	do {
+		v = (unsigned *)&xfer_status;
+		*v = readl(i2c->base + XFER_STATUS);
+		dev_dbg(i2c->dev, "xfer status: %x\n", *v);
+		if (xfer_status.error) {
+			dev_warn(i2c->dev, "acp i2c write error\n");
+			return -EIO;
+		} else if (xfer_status.done)
+			break;
+
+		udelay(200);
+	} while (--timeout);
+
+	if (timeout <= 0) {
+		dev_warn(i2c->dev, "acp i2c write timeout\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int acp_i2c_xfer_one(struct acp_i2c *i2c, struct i2c_msg *msg)
+{
+	struct xfer_config xfer_config = {0};
+	unsigned *v;
+	int ret;
+
+	v = (unsigned *)&xfer_config;
+	xfer_config.zero_all = 1;
+	xfer_config.master_mode_active = 1;
+	writel(*v, i2c->base + XFER_CONFIG);
+
+	if (msg->flags & I2C_M_RD)
+		ret = acp_i2c_xfer_one_read(i2c, msg);
+	else
+		ret = acp_i2c_xfer_one_write(i2c, msg);
+
+	return ret;
+}
+
+static int acp_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
+{
+	struct acp_i2c *i2c = (struct acp_i2c *)adap->algo_data;
+	int ret = 0;
+	int i;
+
+	for (i = 0; i < num; i++) {
+		ret = acp_i2c_xfer_one(i2c, &msgs[i]);
+		if (ret != 0)
+			break;
+	}
+
+	if (ret == 0)
+		ret = num;
+
+	return ret;
+}
+
+static u32 acp_i2c_func(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_QUICK |
+		I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA;
+}
+
+static const struct i2c_algorithm acp_i2c_algorithm = {
+	.master_xfer		= acp_i2c_xfer,
+	.functionality		= acp_i2c_func,
+};
+
+static int acp_i2c_probe(struct of_device *dev,
+	const struct of_device_id *match)
+{
+	struct acp_i2c *i2c;
+	int ret;
+
+	i2c = kzalloc(sizeof(struct acp_i2c), GFP_KERNEL);
+	if (!i2c) {
+		dev_err(&dev->dev, "no memory for state\n");
+		return -ENOMEM;
+	}
+
+	strlcpy(i2c->adap.name, "acp-i2c", sizeof(i2c->adap.name));
+	i2c->adap.owner   = THIS_MODULE;
+	i2c->adap.algo    = &acp_i2c_algorithm;
+	i2c->adap.retries = 2;
+	i2c->adap.class   = I2C_CLASS_HWMON | I2C_CLASS_SPD;
+
+	i2c->dev = &dev->dev;
+
+	i2c->adap.algo_data = i2c;
+	i2c->adap.dev.parent = &dev->dev;
+	i2c->adap.nr = 0;
+
+	ret = i2c_add_numbered_adapter(&i2c->adap);
+	if (ret < 0) {
+		dev_err(&dev->dev, "failed to add bus to i2c core\n");
+		goto err;
+	}
+
+	i2c->base = of_iomap(dev->node, 0);
+	if (!i2c->base) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	i2c->timer_base = of_iomap(dev->node, 1);
+	if (!i2c->timer_base) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	/* enable the i2c clock */
+	writel(0x0, i2c->timer_base + I2C_TIMER_CONTROL);
+	writel(0x10, i2c->timer_base + I2C_TIMER_LOAD);
+	writel(0xc0, i2c->timer_base + I2C_TIMER_CONTROL);
+
+	dev_set_drvdata(&dev->dev, i2c);
+
+	dev_info(&dev->dev, "%s: ACP I2C adapter\n", dev_name(&i2c->adap.dev));
+
+	of_register_i2c_devices(&i2c->adap, dev->node);
+
+	return 0;
+err:
+	kfree(i2c);
+	return ret;
+}
+
+static int acp_i2c_remove(struct of_device *dev)
+{
+	struct acp_i2c *i2c = dev_get_drvdata(&dev->dev);
+
+	/* disable the i2c clock */
+	writel(0x0, i2c->timer_base + I2C_TIMER_CONTROL);
+
+	i2c_del_adapter(&i2c->adap);
+	kfree(i2c);
+
+	return 0;
+}
+
+static struct of_device_id acp_i2c_match[] = {
+	{
+		.compatible = "acp-i2c",
+	},
+	{ /* end of list */ },
+};
+
+static struct of_platform_driver acp_i2c_driver = {
+	.name = "acp-i2c",
+	.match_table = acp_i2c_match,
+	.probe		= acp_i2c_probe,
+	.remove		= acp_i2c_remove,
+};
+
+static int __init i2c_acp_init(void)
+{
+	int ret = 0;
+
+	ret = of_register_platform_driver(&acp_i2c_driver);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static void __exit i2c_acp_exit(void)
+{
+	of_unregister_platform_driver(&acp_i2c_driver);
+}
+
+module_init(i2c_acp_init);
+module_exit(i2c_acp_exit);
+
+MODULE_DESCRIPTION("ACP I2C Bus driver");
+MODULE_AUTHOR("Wu Fei <fei.wu@windriver.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/i2c/busses/i2c-acp.h b/drivers/i2c/busses/i2c-acp.h
new file mode 100644
index 0000000..654b217
--- /dev/null
+++ b/drivers/i2c/busses/i2c-acp.h
@@ -0,0 +1,146 @@
+/*
+ * Copyright (C) 2010 Wind River Systems
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#define XFER_CONFIG			(0x0)
+#define RECV_CONFIG			(0x4)
+#define XFER_STATUS			(0x8)
+#define RECV_STATUS			(0xc)
+#define INTR_ENABLE			(0x10)
+#define INTR_CLEAR			(0X14)
+#define INTR_STATUS			(0x18)
+#define CLK_CONFIG			(0x1c)
+#define START_SETUP_HOLD_CONFIG		(0x20)
+#define STOP_SETUP_HOLD_CONFIG		(0x24)
+#define DATA_SETUP_HOLD_CONFIG		(0x28)
+#define BYPASS_MODE			(0x2c)
+#define SLAVE_ADDRESS			(0x30)
+#define XFER_DATA0			(0x34)
+#define XFER_DATA1			(0x38)
+#define RECV_DATA0			(0x3c)
+#define RECV_DATA1			(0x40)
+
+#define I2C_TIMER_LOAD			(0x0)
+#define I2C_TIMER_CONTROL		(0x8)
+
+#define CFG_CLK_CONFIG_SCL_LOW		(10 * 40)   /* Yx 1.2 us / 30 ns  */
+#define CFG_CLK_CONFIG_SCL_LOW_RD	(256)       /* Yx 0.75 us / 30 ns */
+#define CFG_CLK_CONFIG_SCL_HIGH		(10 * 20)   /* Yx 0.6 us / 30 ns  */
+#define CFG_START_SETUP_PERIOD		20          /* 0.6 us / 30 ns     */
+#define CFG_START_HOLD_PERIOD		20          /* 0.6 us / 30 ns     */
+#define CFG_STOP_SETUP_PERIOD		20          /* 0.6 us / 30 ns     */
+#define CFG_STOP_HOLD_PERIOD		0           /* 0.0 us / 30 ns     */
+#define CFG_DATA_SETUP_PERIOD		2           /* 60 ns / 30 ns      */
+#define CFG_DATA_HOLD_PERIOD		0           /* 0.0 us / 30 ns     */
+
+
+struct xfer_config {
+#ifdef __BIG_ENDIAN
+	unsigned reserved2:21;
+	unsigned zero_all:1;
+	unsigned command:1;
+	unsigned master_mode_active:1;
+	unsigned ten_bit_addr:1;
+	unsigned reserved1:1;
+	unsigned endianness:1;
+	unsigned nbytes:4;
+	unsigned ready:1;
+#else
+	unsigned ready:1;
+	unsigned nbytes:4;
+	unsigned endianness:1;
+	unsigned reserved1:1;
+	unsigned ten_bit_addr:1;
+	unsigned master_mode_active:1;
+	unsigned command:1;
+	unsigned zero_all:1;
+	unsigned reserved2:21;
+#endif
+};
+
+struct recv_config {
+#ifdef __BIG_ENDIAN
+	unsigned reserved:26;
+	unsigned endianness:1;
+	unsigned nbytes:4;
+	unsigned ready:1;
+#else
+	unsigned ready:1;
+	unsigned nbytes:4;
+	unsigned endianness:1;
+	unsigned reserved:26;
+#endif
+};
+
+struct xfer_status {
+#ifdef __BIG_ENDIAN
+	unsigned reserved:30;
+	unsigned error:1;
+	unsigned done:1;
+#else
+	unsigned done:1;
+	unsigned error:1;
+	unsigned reserved:30;
+#endif
+};
+
+struct recv_status {
+#ifdef __BIG_ENDIAN
+	unsigned reserved:26;
+	unsigned nbytes_done:4;
+	unsigned error:1;
+	unsigned done:1;
+#else
+	unsigned done:1;
+	unsigned error:1;
+	unsigned nbytes_done:4;
+	unsigned reserved:26;
+#endif
+};
+
+struct intr_enable {
+#ifdef __BIG_ENDIAN
+	unsigned reserved:28;
+	unsigned recv_error:1;
+	unsigned recv_done:1;
+	unsigned xfer_error:1;
+	unsigned xfer_done:1;
+#else
+	unsigned xfer_done:1;
+	unsigned xfer_error:1;
+	unsigned recv_done:1;
+	unsigned recv_error:1;
+	unsigned reserved:28;
+#endif
+};
+
+struct clk_config {
+#ifdef __BIG_ENDIAN
+	unsigned reserved2:6;
+	unsigned pclk_high:10;
+	unsigned reserved1:6;
+	unsigned pclk_low:10;
+#else
+	unsigned pclk_low:10;
+	unsigned reserved1:6;
+	unsigned pclk_high:10;
+	unsigned reserved2:6;
+#endif
+};
+
+struct hold_setup_clk {
+#ifdef __BIG_ENDIAN
+	unsigned reserved2:6;
+	unsigned pclk_hold:10;
+	unsigned reserved1:6;
+	unsigned pclk_setup:10;
+#else
+	unsigned pclk_setup:10;
+	unsigned reserved1:6;
+	unsigned pclk_hold:10;
+	unsigned reserved2:6;
+#endif
+};
-- 
1.7.0.5

