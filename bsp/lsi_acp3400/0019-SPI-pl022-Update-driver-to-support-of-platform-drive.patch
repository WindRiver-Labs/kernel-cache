From 9411fa9d80a92ce43c7366485d970bc3204b0bb2 Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Mon, 18 Apr 2011 10:31:29 +0800
Subject: [PATCH 19/27] SPI:pl022:Update driver to support of-platform drivers

Since the PPC LSI ACP34xx board implements pl022 spi controller,
Update driver register interface to support ppc of-platform style
driver register interface.

The patch abstract the common code of probe, remove & PM routines
between ARM_AMBA style driver and of-platform driver, then fork
a new drivers for ppc of-platform.

The OF style driver extract device information from device-tree, including
"cell-index", "num-ss-bits", "enalbe-dma" , io address & irq.

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/spi/Kconfig      |    2 +-
 drivers/spi/amba-pl022.c |  252 ++++++++++++++++++++++++++++++++++++++--------
 2 files changed, 209 insertions(+), 45 deletions(-)

diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 9526eca..a459c0b 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -206,7 +206,7 @@ config SPI_ORION
 
 config SPI_PL022
 	tristate "ARM AMBA PL022 SSP controller (EXPERIMENTAL)"
-	depends on ARM_AMBA && EXPERIMENTAL
+	depends on (ARM_AMBA || ACPX1)&& EXPERIMENTAL
 	default y if MACH_U300
 	default y if ARCH_REALVIEW
 	default y if INTEGRATOR_IMPD1
diff --git a/drivers/spi/amba-pl022.c b/drivers/spi/amba-pl022.c
index e9aeee1..19b2868 100644
--- a/drivers/spi/amba-pl022.c
+++ b/drivers/spi/amba-pl022.c
@@ -41,7 +41,12 @@
 #include <linux/delay.h>
 #include <linux/clk.h>
 #include <linux/err.h>
+#ifdef CONFIG_ARM_AMBA
 #include <linux/amba/bus.h>
+#else
+#include <linux/of_platform.h>
+#include <linux/of.h>
+#endif
 #include <linux/amba/pl022.h>
 #include <linux/io.h>
 #include <linux/slab.h>
@@ -339,7 +344,11 @@ struct vendor_data {
  * @writingtype: the type or write currently going on
  */
 struct pl022 {
+#ifdef CONFIG_ARM_AMBA
 	struct amba_device		*adev;
+#else
+	struct of_device		*adev;
+#endif
 	struct vendor_data		*vendor;
 	resource_size_t			phybase;
 	void __iomem			*virtbase;
@@ -1623,19 +1632,19 @@ static void pl022_cleanup(struct spi_device *spi)
 }
 
 
-static int __init
-pl022_probe(struct amba_device *adev, struct amba_id *id)
+static int __init pl022_probe(
+	struct device *dev,
+	struct vendor_data *vendor,
+	struct resource *res,
+	int irq, struct pl022 **retpl022)
 {
-	struct device *dev = &adev->dev;
-	struct pl022_ssp_controller *platform_info = adev->dev.platform_data;
+	struct pl022_ssp_controller *platform_info = dev->platform_data;
 	struct spi_master *master;
 	struct pl022 *pl022 = NULL;	/*Data for this driver */
 	int status = 0;
 
-	dev_info(&adev->dev,
-		 "ARM PL022 driver, device ID: 0x%08x\n", adev->periphid);
 	if (platform_info == NULL) {
-		dev_err(&adev->dev, "probe - no platform data supplied\n");
+		dev_err(dev, "probe - no platform data supplied\n");
 		status = -ENODEV;
 		goto err_no_pdata;
 	}
@@ -1643,7 +1652,7 @@ pl022_probe(struct amba_device *adev, struct amba_id *id)
 	/* Allocate master with space for data */
 	master = spi_alloc_master(dev, sizeof(struct pl022));
 	if (master == NULL) {
-		dev_err(&adev->dev, "probe - cannot alloc SPI master\n");
+		dev_err(dev, "probe - cannot alloc SPI master\n");
 		status = -ENOMEM;
 		goto err_no_master;
 	}
@@ -1651,8 +1660,7 @@ pl022_probe(struct amba_device *adev, struct amba_id *id)
 	pl022 = spi_master_get_devdata(master);
 	pl022->master = master;
 	pl022->master_info = platform_info;
-	pl022->adev = adev;
-	pl022->vendor = id->data;
+	pl022->vendor = vendor;
 
 	/*
 	 * Bus Number Which has been Assigned to this SSP controller
@@ -1664,24 +1672,24 @@ pl022_probe(struct amba_device *adev, struct amba_id *id)
 	master->setup = pl022_setup;
 	master->transfer = pl022_transfer;
 
-	dev_dbg(&adev->dev, "BUSNO: %d\n", master->bus_num);
+	dev_dbg(dev, "BUSNO: %d\n", master->bus_num);
 
-	status = amba_request_regions(adev, NULL);
-	if (status)
+	if (!request_mem_region(res->start, resource_size(res),
+			dev->driver->name))
 		goto err_no_ioregion;
 
-	pl022->virtbase = ioremap(adev->res.start, resource_size(&adev->res));
+	pl022->virtbase = ioremap(res->start, resource_size(res));
 	if (pl022->virtbase == NULL) {
 		status = -ENOMEM;
 		goto err_no_ioremap;
 	}
 	printk(KERN_INFO "pl022: mapped registers from 0x%08x to %p\n",
-	       adev->res.start, pl022->virtbase);
+	       res->start, pl022->virtbase);
 
-	pl022->clk = clk_get(&adev->dev, NULL);
+	pl022->clk = clk_get(dev, NULL);
 	if (IS_ERR(pl022->clk)) {
 		status = PTR_ERR(pl022->clk);
-		dev_err(&adev->dev, "could not retrieve SSP/SPI bus clock\n");
+		dev_err(dev, "could not retrieve SSP/SPI bus clock\n");
 		goto err_no_clk;
 	}
 
@@ -1692,45 +1700,47 @@ pl022_probe(struct amba_device *adev, struct amba_id *id)
 	load_ssp_default_config(pl022);
 	clk_disable(pl022->clk);
 
-	status = request_irq(adev->irq[0], pl022_interrupt_handler, 0, "pl022",
+	status = request_irq(irq, pl022_interrupt_handler, 0, "pl022",
 			     pl022);
 	if (status < 0) {
-		dev_err(&adev->dev, "probe - cannot get IRQ (%d)\n", status);
+		dev_err(dev, "probe - cannot get IRQ (%d)\n", status);
 		goto err_no_irq;
 	}
 	/* Initialize and start queue */
 	status = init_queue(pl022);
 	if (status != 0) {
-		dev_err(&adev->dev, "probe - problem initializing queue\n");
+		dev_err(dev, "probe - problem initializing queue\n");
 		goto err_init_queue;
 	}
 	status = start_queue(pl022);
 	if (status != 0) {
-		dev_err(&adev->dev, "probe - problem starting queue\n");
+		dev_err(dev, "probe - problem starting queue\n");
 		goto err_start_queue;
 	}
 	/* Register with the SPI framework */
-	amba_set_drvdata(adev, pl022);
+	dev_set_drvdata(dev, pl022);
 	status = spi_register_master(master);
 	if (status != 0) {
-		dev_err(&adev->dev,
+		dev_err(dev,
 			"probe - problem registering spi master\n");
 		goto err_spi_register;
 	}
 	dev_dbg(dev, "probe succeded\n");
+	if (retpl022)
+		*retpl022 = pl022;
 	return 0;
 
  err_spi_register:
  err_start_queue:
  err_init_queue:
 	destroy_queue(pl022);
-	free_irq(adev->irq[0], pl022);
+	free_irq(irq, pl022);
  err_no_irq:
 	clk_put(pl022->clk);
  err_no_clk:
 	iounmap(pl022->virtbase);
  err_no_ioremap:
-	amba_release_regions(adev);
+	release_mem_region(res->start, resource_size(res));
  err_no_ioregion:
 	spi_master_put(master);
  err_no_master:
@@ -1739,9 +1749,9 @@ pl022_probe(struct amba_device *adev, struct amba_id *id)
 }
 
 static int __exit
-pl022_remove(struct amba_device *adev)
+pl022_remove(struct device *dev, struct resource *res, int irq)
 {
-	struct pl022 *pl022 = amba_get_drvdata(adev);
+	struct pl022 *pl022 = dev_get_drvdata(dev);
 	int status = 0;
 	if (!pl022)
 		return 0;
@@ -1749,54 +1759,54 @@ pl022_remove(struct amba_device *adev)
 	/* Remove the queue */
 	status = destroy_queue(pl022);
 	if (status != 0) {
-		dev_err(&adev->dev,
+		dev_err(dev,
 			"queue remove failed (%d)\n", status);
 		return status;
 	}
 	load_ssp_default_config(pl022);
-	free_irq(adev->irq[0], pl022);
+	free_irq(irq, pl022);
 	clk_disable(pl022->clk);
 	clk_put(pl022->clk);
 	iounmap(pl022->virtbase);
-	amba_release_regions(adev);
+	release_mem_region(res->start, resource_size(res));
 	tasklet_disable(&pl022->pump_transfers);
 	spi_unregister_master(pl022->master);
 	spi_master_put(pl022->master);
-	amba_set_drvdata(adev, NULL);
-	dev_dbg(&adev->dev, "remove succeded\n");
+	dev_set_drvdata(dev, NULL);
+	dev_dbg(dev, "remove succeded\n");
 	return 0;
 }
 
 #ifdef CONFIG_PM
-static int pl022_suspend(struct amba_device *adev, pm_message_t state)
+static int pl022_suspend(struct device *dev, pm_message_t state)
 {
-	struct pl022 *pl022 = amba_get_drvdata(adev);
+	struct pl022 *pl022 = dev_get_drvdata(dev);
 	int status = 0;
 
 	status = stop_queue(pl022);
 	if (status) {
-		dev_warn(&adev->dev, "suspend cannot stop queue\n");
+		dev_warn(dev, "suspend cannot stop queue\n");
 		return status;
 	}
 
 	clk_enable(pl022->clk);
 	load_ssp_default_config(pl022);
 	clk_disable(pl022->clk);
-	dev_dbg(&adev->dev, "suspended\n");
+	dev_dbg(dev, "suspended\n");
 	return 0;
 }
 
-static int pl022_resume(struct amba_device *adev)
+static int pl022_resume(struct device *dev)
 {
-	struct pl022 *pl022 = amba_get_drvdata(adev);
+	struct pl022 *pl022 = dev_get_drvdata(dev);
 	int status = 0;
 
 	/* Start the queue running */
 	status = start_queue(pl022);
 	if (status)
-		dev_err(&adev->dev, "problem starting queue (%d)\n", status);
+		dev_err(dev, "problem starting queue (%d)\n", status);
 	else
-		dev_dbg(&adev->dev, "resumed\n");
+		dev_dbg(dev, "resumed\n");
 
 	return status;
 }
@@ -1818,6 +1828,45 @@ static struct vendor_data vendor_st = {
 	.unidir = false,
 };
 
+#ifdef CONFIG_ARM_AMBA
+
+static int __init
+pl022_amba_probe(struct amba_device *adev, struct amba_id *id)
+{
+	struct pl022 *pl022 = NULL;
+	int ret;
+	dev_info(&adev->dev,
+		 "ARM PL022 driver, device ID: 0x%08x\n", adev->periphid);
+	ret = pl022_probe(&adev->dev, id->data,
+		&adev->res, adev->irq[0], &pl022);
+
+	if (ret < 0)
+		return ret;
+	pl022->adev = adev;
+	return 0;
+}
+
+static int __exit
+pl022_amba_remove(struct amba_device *adev)
+{
+	return  pl022_remove(&adev->dev, &adev->res, adev->irq[0]);
+}
+
+#ifdef CONFIG_PM
+static int pl022_amba_suspend(struct amba_device *adev, pm_message_t state)
+{
+	return pl022_suspend(&adev->dev, state);
+}
+
+static int pl022_amba_resume(struct amba_device *adev)
+{
+	return pl022_resume(&adev->dev);
+}
+#else
+#define pl022_amba_suspend NULL
+#define pl022_amba_resume NULL
+#endif
+
 static struct amba_id pl022_ids[] = {
 	{
 		/*
@@ -1845,23 +1894,138 @@ static struct amba_driver pl022_driver = {
 		.name	= "ssp-pl022",
 	},
 	.id_table	= pl022_ids,
-	.probe		= pl022_probe,
-	.remove		= __exit_p(pl022_remove),
-	.suspend        = pl022_suspend,
-	.resume         = pl022_resume,
+	.probe		= pl022_amba_probe,
+	.remove		= __exit_p(pl022_amba_remove),
+	.suspend        = pl022_amba_suspend,
+	.resume         = pl022_amba_resume,
 };
+#else
+static int __init
+pl022_of_probe(struct of_device *ofdev, const struct of_device_id *id)
+{
+	struct pl022_ssp_controller *platform_info;
+	int ret = -ENODEV;
+	struct resource r_mem;
+	int irq;
+
+	struct pl022 *pl022 = NULL;
+	const u32 *prop;
+	int len;
+
+	platform_info = kmalloc(sizeof(struct pl022_ssp_controller),
+		GFP_KERNEL);
+	if (!platform_info)
+		return -ENOMEM;
+
+	prop = of_get_property(ofdev->node, "cell-index", &len);
+	if (!prop || len < sizeof(*prop)) {
+		dev_warn(&ofdev->dev, "no 'cell-index' property\n");
+		goto err_data;
+	}
+	platform_info->bus_id = *prop;
+	/* number of slave select bits is required */
+	prop = of_get_property(ofdev->node, "num-ss-bits", &len);
+	if (!prop || len < sizeof(*prop)) {
+		dev_warn(&ofdev->dev, "no 'num-ss-bits' property\n");
+		goto err_data;
+	}
+	platform_info->num_chipselect = *prop;
+	/* number of slave select bits is required */
+	prop = of_get_property(ofdev->node, "enalbe-dma", &len);
+	if (!prop || len < sizeof(*prop))
+		platform_info->enable_dma = 0;
+	platform_info->enable_dma = *prop;
+
+	ofdev->dev.platform_data = platform_info;
+
+	ret = of_address_to_resource(ofdev->node, 0, &r_mem);
+	if (ret) {
+		dev_warn(&ofdev->dev, "invalid address\n");
+		goto err_data;
+	}
+
+	irq = of_irq_to_resource(ofdev->node, 0, NULL);
+
+	ret = pl022_probe(&ofdev->dev, id->data, &r_mem, irq, &pl022);
+
+	if (ret < 0)
+		goto err_data;
+
+	pl022->adev = ofdev;
+	return 0;
+err_data:
+	kfree(platform_info);
+	return ret;
+}
+
+static int __exit
+pl022_of_remove(struct of_device *ofdev)
+{
+	struct resource r_mem;
+	int irq;
+	int ret;
+	of_address_to_resource(ofdev->node, 0, &r_mem);
 
+	irq = of_irq_to_resource(ofdev->node, 0, NULL);
+
+	ret = pl022_remove(&ofdev->dev, &r_mem, irq);
+	if (ret)
+		return ret;
+	kfree(ofdev->dev.platform_data);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int pl022_of_suspend(struct of_device *ofdev, pm_message_t state)
+{
+	return pl022_suspend(&ofdev->dev, state);
+}
+
+static int pl022_of_resume(struct of_device *ofdev)
+{
+	return pl022_resume(&ofdev->dev);
+}
+#else
+#define pl022_of_suspend NULL
+#define pl022_of_resume NULL
+#endif
+
+static struct of_device_id pl022_match[] = {
+	{
+		.compatible = "amba_pl022",
+		.data = (void *)&vendor_arm,
+	},
+	{ /* end of list */ },
+};
+
+static struct of_platform_driver pl022_driver = {
+	.name = "ssp-pl022",
+	.probe = pl022_of_probe,
+	.remove = __exit_p(pl022_of_remove),
+	.suspend = pl022_of_suspend,
+	.resume = pl022_of_resume,
+	.match_table = pl022_match,
+};
+#endif
 
 static int __init pl022_init(void)
 {
+#ifdef CONFIG_ARM_AMBA
 	return amba_driver_register(&pl022_driver);
+#else
+	return of_register_platform_driver(&pl022_driver);
+#endif
 }
 
 module_init(pl022_init);
 
 static void __exit pl022_exit(void)
 {
+#ifdef CONFIG_ARM_AMBA
 	amba_driver_unregister(&pl022_driver);
+#else
+	of_unregister_platform_driver(&pl022_driver);
+#endif
 }
 
 module_exit(pl022_exit);
-- 
1.7.0.5

