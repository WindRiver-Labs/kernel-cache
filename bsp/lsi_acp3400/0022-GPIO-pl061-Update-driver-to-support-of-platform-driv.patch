From 4d920824ebc766396e550979a33b59e759a14848 Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Mon, 18 Apr 2011 11:21:43 +0800
Subject: [PATCH 22/27] GPIO:pl061:Update driver to support of-platform drivers

Since the PPC LSI ACP34xx board implements 2 pl061 gpio controller,
Update driver register interface to support ppc of-platform style
driver register interface.

The patch abstract the common code of probe routine between
ARM_AMBA style driver and of-platform driver, then fork a new drivers
for ppc of-platform.

The OF style driver extract device information from device-tree, including
gpio base, io address & irq.

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/gpio/Kconfig |    2 +-
 drivers/gpio/pl061.c |   94 +++++++++++++++++++++++++++++++++++++++++++------
 2 files changed, 83 insertions(+), 13 deletions(-)

diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index fee678f..b1455dd 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -78,7 +78,7 @@ config GPIO_IT8761E
 
 config GPIO_PL061
 	bool "PrimeCell PL061 GPIO support"
-	depends on ARM_AMBA
+	depends on ARM_AMBA || ACPX1
 	help
 	  Say yes here to support the PrimeCell PL061 GPIO device
 
diff --git a/drivers/gpio/pl061.c b/drivers/gpio/pl061.c
index 105701a..ec928b4 100644
--- a/drivers/gpio/pl061.c
+++ b/drivers/gpio/pl061.c
@@ -22,7 +22,12 @@
 #include <linux/workqueue.h>
 #include <linux/gpio.h>
 #include <linux/device.h>
+#ifdef CONFIG_ARM_AMBA
 #include <linux/amba/bus.h>
+#else
+#include <linux/of_platform.h>
+#include <linux/of.h>
+#endif
 #include <linux/amba/pl061.h>
 #include <linux/slab.h>
 
@@ -232,15 +237,16 @@ static void pl061_irq_handler(unsigned irq, struct irq_desc *desc)
 	desc->chip->unmask(irq);
 }
 
-static int __init pl061_probe(struct amba_device *dev, struct amba_id *id)
+static int __init pl061_probe(struct device *dev,
+	struct resource *res, int irq, struct pl061_gpio **retchip)
 {
 	struct pl061_platform_data *pdata;
 	struct pl061_gpio *chip;
 	struct list_head *chip_list;
-	int ret, irq, i;
+	int ret, i;
 	static DECLARE_BITMAP(init_irq, NR_IRQS);
 
-	pdata = dev->dev.platform_data;
+	pdata = dev->platform_data;
 	if (pdata == NULL)
 		return -ENODEV;
 
@@ -248,13 +254,13 @@ static int __init pl061_probe(struct amba_device *dev, struct amba_id *id)
 	if (chip == NULL)
 		return -ENOMEM;
 
-	if (!request_mem_region(dev->res.start,
-				resource_size(&dev->res), "pl061")) {
+	if (!request_mem_region(res->start,
+				resource_size(res), "pl061")) {
 		ret = -EBUSY;
 		goto free_mem;
 	}
 
-	chip->base = ioremap(dev->res.start, resource_size(&dev->res));
+	chip->base = ioremap(res->start, resource_size(res));
 	if (chip->base == NULL) {
 		ret = -ENOMEM;
 		goto release_region;
@@ -271,8 +277,8 @@ static int __init pl061_probe(struct amba_device *dev, struct amba_id *id)
 	chip->gc.to_irq = pl061_to_irq;
 	chip->gc.base = pdata->gpio_base;
 	chip->gc.ngpio = PL061_GPIO_NR;
-	chip->gc.label = dev_name(&dev->dev);
-	chip->gc.dev = &dev->dev;
+	chip->gc.label = dev_name(dev);
+	chip->gc.dev = dev;
 	chip->gc.owner = THIS_MODULE;
 
 	chip->irq_base = pdata->irq_base;
@@ -281,6 +287,9 @@ static int __init pl061_probe(struct amba_device *dev, struct amba_id *id)
 	if (ret)
 		goto iounmap;
 
+	if (retchip)
+		*retchip = chip;
+
 	/*
 	 * irq_chip support
 	 */
@@ -289,7 +298,6 @@ static int __init pl061_probe(struct amba_device *dev, struct amba_id *id)
 		return 0;
 
 	writeb(0, chip->base + GPIOIE); /* disable irqs */
-	irq = dev->irq[0];
 	if (irq < 0) {
 		ret = -ENODEV;
 		goto iounmap;
@@ -317,7 +325,9 @@ static int __init pl061_probe(struct amba_device *dev, struct amba_id *id)
 
 		set_irq_chip(i+chip->irq_base, &pl061_irqchip);
 		set_irq_handler(i+chip->irq_base, handle_simple_irq);
+#ifdef CONFIG_ARM_AMBA
 		set_irq_flags(i+chip->irq_base, IRQF_VALID);
+#endif
 		set_irq_chip_data(i+chip->irq_base, chip);
 	}
 
@@ -326,13 +336,20 @@ static int __init pl061_probe(struct amba_device *dev, struct amba_id *id)
 iounmap:
 	iounmap(chip->base);
 release_region:
-	release_mem_region(dev->res.start, resource_size(&dev->res));
+	release_mem_region(res->start, resource_size(res));
 free_mem:
 	kfree(chip);
-
+	if (retchip)
+		*retchip = NULL;
 	return ret;
 }
 
+#ifdef CONFIG_ARM_AMBA
+static int __init pl061_amba_probe(struct amba_device *dev, struct amba_id *id)
+{
+	return pl061_probe(&dev->dev, &dev->res, dev->irq[0], NULL);
+}
+
 static struct amba_id pl061_ids[] __initdata = {
 	{
 		.id	= 0x00041061,
@@ -346,12 +363,65 @@ static struct amba_driver pl061_gpio_driver = {
 		.name	= "pl061_gpio",
 	},
 	.id_table	= pl061_ids,
-	.probe		= pl061_probe,
+	.probe		= pl061_amba_probe,
+};
+#else
+static int __init pl061_of_probe(struct of_device *ofdev,
+	const struct of_device_id *id)
+{
+	struct resource r_mem;
+	struct pl061_platform_data pl061_data = {0};
+	int irq;
+	const u32 *prop;
+	int len;
+	struct pl061_gpio *chip = NULL;
+	int ret;
+
+	if (of_address_to_resource(ofdev->node, 0, &r_mem))
+		return -ENODEV;
+
+	pl061_data.gpio_base = 0;
+	prop = of_get_property(ofdev->node, "cell-index", &len);
+	if (!prop || len < sizeof(*prop))
+		dev_warn(&ofdev->dev, "no 'cell-index' property\n");
+	else
+		pl061_data.gpio_base = *prop;
+
+	irq = of_irq_to_resource(ofdev->node, 0, NULL);
+	pl061_data.irq_base = irq;
+	if (irq == NO_IRQ)
+		pl061_data.irq_base = (unsigned) -1;
+
+	ofdev->dev.platform_data = &pl061_data;
+
+	ret = pl061_probe(&ofdev->dev, &r_mem, irq, &chip);
+
+	if (ret < 0)
+		return ret;
+	return 0;
+}
+
+static struct of_device_id pl061_match[] = {
+	{
+		.compatible = "amba_pl061",
+	},
+	{ /* end of list */ },
+};
+
+static struct of_platform_driver pl061_gpio_driver = {
+	.name = "gpio-pl061",
+	.probe = pl061_of_probe,
+	.match_table = pl061_match,
 };
+#endif
 
 static int __init pl061_gpio_init(void)
 {
+#ifdef CONFIG_ARM_AMBA
 	return amba_driver_register(&pl061_gpio_driver);
+#else
+	return of_register_platform_driver(&pl061_gpio_driver);
+#endif
 }
 subsys_initcall(pl061_gpio_init);
 
-- 
1.7.0.5

