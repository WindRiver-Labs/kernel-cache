From 859a2010f538d6b0c5af0de4f474b22bd741965e Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Mon, 18 Apr 2011 10:42:11 +0800
Subject: [PATCH 20/27] PowerPC:LSI34xx:Add SPI bus support

LSI ACP34xx boards implement pl022 spi bus controller. This patch
update pl022 driver to support the device on LSI ACP34xx board,
including IO routines and timer facility.

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/spi/amba-pl022.c |   37 ++++++++++++++++++++++++++++++++++++-
 1 files changed, 36 insertions(+), 1 deletions(-)

diff --git a/drivers/spi/amba-pl022.c b/drivers/spi/amba-pl022.c
index 19b2868..ae0115c 100644
--- a/drivers/spi/amba-pl022.c
+++ b/drivers/spi/amba-pl022.c
@@ -51,6 +51,11 @@
 #include <linux/io.h>
 #include <linux/slab.h>
 
+#ifdef CONFIG_ACPX1
+#define writew(b, addr) writel(b, addr)
+#define readw(addr) readl(addr)
+#endif
+
 /*
  * This macro is used to define some register default values.
  * reg is masked with mask, the OR:ed with an (again masked)
@@ -353,6 +358,9 @@ struct pl022 {
 	resource_size_t			phybase;
 	void __iomem			*virtbase;
 	struct clk			*clk;
+#ifdef CONFIG_ACPX1
+	u32 clkfreq;
+#endif
 	struct spi_master		*master;
 	struct pl022_ssp_controller	*master_info;
 	/* Driver message queue */
@@ -649,6 +657,11 @@ static void readwriter(struct pl022 *pl022)
 		}
 		pl022->tx += (pl022->cur_chip->n_bytes);
 		pl022->exp_fifo_level++;
+#ifdef CONFIG_ACPX1
+		/*Some datas will go into receive FIFO when transmiting*/
+		while (!(readw(SSP_SR(pl022->virtbase)) & SSP_SR_MASK_RNE))
+			;
+#endif
 		/*
 		 * This inner reader takes care of things appearing in the RX
 		 * FIFO as we're transmitting. This will happen a lot since the
@@ -1348,8 +1361,11 @@ static int calculate_effective_freq(struct pl022 *pl022,
 	u32 rate;
 	u32 max_tclk;
 	u32 min_tclk;
-
+#ifndef CONFIG_ACPX1
 	rate = clk_get_rate(pl022->clk);
+#else
+	rate = pl022->clkfreq;
+#endif
 	/* cpsdvscr = 2 & scr 0 */
 	max_tclk = (rate / (CPSDVR_MIN * (1 + SCR_MIN)));
 	/* cpsdvsr = 254 & scr = 255 */
@@ -1843,6 +1859,9 @@ pl022_amba_probe(struct amba_device *adev, struct amba_id *id)
 	if (ret < 0)
 		return ret;
 	pl022->adev = adev;
+#ifdef CONFIG_ACPX1
+	pl022->clkfreq = clkfreq;
+#endif
 	return 0;
 }
 
@@ -1912,6 +1931,10 @@ pl022_of_probe(struct of_device *ofdev, const struct of_device_id *id)
 	const u32 *prop;
 	int len;
 
+#ifdef CONFIG_ACPX1
+	u32 clkfreq;
+#endif
+
 	platform_info = kmalloc(sizeof(struct pl022_ssp_controller),
 		GFP_KERNEL);
 	if (!platform_info)
@@ -1936,6 +1959,15 @@ pl022_of_probe(struct of_device *ofdev, const struct of_device_id *id)
 		platform_info->enable_dma = 0;
 	platform_info->enable_dma = *prop;
 
+#ifdef CONFIG_ACPX1
+	prop = of_get_property(ofdev->node, "clock-frequency", &len);
+	if (!prop || len < sizeof(*prop)) {
+		dev_warn(&ofdev->dev, "no 'clock-frequency' property\n");
+		goto err_data;
+	}
+	clkfreq = *prop;
+#endif
+
 	ofdev->dev.platform_data = platform_info;
 
 	ret = of_address_to_resource(ofdev->node, 0, &r_mem);
@@ -1952,6 +1984,9 @@ pl022_of_probe(struct of_device *ofdev, const struct of_device_id *id)
 		goto err_data;
 
 	pl022->adev = ofdev;
+#ifdef CONFIG_ACPX1
+	pl022->clkfreq = clkfreq;
+#endif
 	return 0;
 err_data:
 	kfree(platform_info);
-- 
1.7.0.5

