From ac3f3478a5dd2eb63cbfa2f5b07d81137e49bd4d Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Tue, 26 Apr 2011 14:50:22 +0800
Subject: [PATCH 27/27] PowerPC:ACP34xx:Update NAND driver to support nandsim driver

The NAND flash controller implements addition registers for chip
identify and status command. The vendor drop driver for ACP34xx board
modified nand_base.c, adding ACP specific code to chip identify & erase
routine.

Though the code is braced by CONFIG_MTD_NAND_LSI marco, it will cause
problem while there is other NAND flash driver in system, such as
nand flash simulator driver.

This patch move the ACP specific code in nand_base.c into ep501.c, so
that the driver won't break the compatibility of nand sub system.

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/mtd/nand/ep501.c     |   69 +++++++++++++++++++++++++++++++++++++++++-
 drivers/mtd/nand/ep501.h     |    3 --
 drivers/mtd/nand/nand_base.c |   38 +----------------------
 3 files changed, 69 insertions(+), 41 deletions(-)

diff --git a/drivers/mtd/nand/ep501.c b/drivers/mtd/nand/ep501.c
index ac2e6ab..735b392 100644
--- a/drivers/mtd/nand/ep501.c
+++ b/drivers/mtd/nand/ep501.c
@@ -194,6 +194,14 @@ struct lsi_nand_chip {
 
 	struct device *dev;
 	u8 __iomem *vbase;
+
+#define LSI_CMD_STAGE_COMMON	(0)
+#define LSI_CMD_STAGE_ID0		(1)
+#define LSI_CMD_STAGE_ID1		(2)
+#define LSI_CMD_STAGE_ID2		(3)
+#define LSI_CMD_STAGE_ID3		(4)
+#define LSI_CMD_STAGE_STATUS	(10)
+	int stage;
 };
 
 /*
@@ -434,6 +442,13 @@ lsi_nand_command(struct mtd_info *mtd, unsigned int command,
 		udelay(chip->chip_delay);
 	}
 
+	if (command == NAND_CMD_READID)
+		priv->stage = LSI_CMD_STAGE_ID0;
+	else if (command == NAND_CMD_STATUS)
+		priv->stage = LSI_CMD_STAGE_STATUS;
+	else
+		priv->stage = LSI_CMD_STAGE_COMMON;
+
 	return;
 }
 
@@ -841,7 +856,7 @@ lsi_nand_write_oob(struct mtd_info *mtd, struct nand_chip *chip, int page)
 
 /* lsi_nand_set_config */
 
-int
+static int
 lsi_nand_set_config(struct mtd_info *mtd, struct nand_chip *chip)
 {
 	unsigned long config = 0;
@@ -1047,6 +1062,55 @@ lsi_nand_set_config(struct mtd_info *mtd, struct nand_chip *chip)
 	return 0;
 }
 
+static uint8_t lsi_nand_read_byte(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct lsi_nand_chip *priv = (struct lsi_nand_chip *) chip->priv;
+	int extid;
+	switch (priv->stage) {
+	case LSI_CMD_STAGE_ID0:
+		priv->stage = LSI_CMD_STAGE_ID1;
+		return readb(chip->IO_ADDR_R + NAND_ID0_REG);
+	case LSI_CMD_STAGE_ID1:
+		priv->stage = LSI_CMD_STAGE_ID2;
+		return readb(chip->IO_ADDR_R + NAND_ID2_REG);
+	case LSI_CMD_STAGE_ID2:
+		priv->stage = LSI_CMD_STAGE_ID3;
+		return readb(chip->IO_ADDR_R + NAND_ID4_REG);
+	case LSI_CMD_STAGE_ID3:
+		priv->stage = LSI_CMD_STAGE_COMMON;
+
+		/*Fill MTD's page size info for lsi_nand_set_config*/
+		extid = readb(chip->IO_ADDR_R + NAND_ID6_REG);
+		/* Calc pagesize */
+		mtd->writesize = 1024 << (extid & 0x3);
+		extid >>= 2;
+		/* Calc oobsize */
+		mtd->oobsize = (8 << (extid & 0x01)) * (mtd->writesize >> 9);
+		extid >>= 2;
+		/* Calc blocksize. Blocksize is multiples of 64KiB */
+		mtd->erasesize = (64 * 1024) << (extid & 0x03);
+		lsi_nand_set_config(mtd, chip);
+
+		return readb(chip->IO_ADDR_R + NAND_ID6_REG);;
+	case LSI_CMD_STAGE_STATUS:
+		priv->stage = LSI_CMD_STAGE_COMMON;
+		return readb(chip->IO_ADDR_R + NAND_STATUS1_REG);
+	default:
+		return readb(chip->IO_ADDR_R);
+	}
+}
+
+static int lsi_nand_errstat
+	(struct mtd_info *mtd, struct nand_chip *chip,
+	int state, int status, int page)
+{
+	/* if erase failed for a block, mark it as bad block */
+	if ((FL_ERASING == chip->state) && (status & NAND_STATUS_FAIL))
+		mtd->block_markbad(mtd, page << chip->page_shift);
+
+	return status;
+}
 
 static int lsi_nand_check_type(struct lsi_nand_chip *chip)
 {
@@ -1148,6 +1212,9 @@ lsi_acp_nand_probe(struct of_device *ofdev,
 	priv->nand_chip.chip_delay = 10;
 	priv->nand_chip.options = NAND_USE_FLASH_BBT;
 
+	priv->nand_chip.read_byte = lsi_nand_read_byte;
+	priv->nand_chip.errstat = lsi_nand_errstat;
+
 	/* initialize ECC */
 	priv->nand_chip.ecc.mode = NAND_ECC_HW;
 	priv->nand_chip.ecc.steps = 1;
diff --git a/drivers/mtd/nand/ep501.h b/drivers/mtd/nand/ep501.h
index 1d65dfa..a95f463 100644
--- a/drivers/mtd/nand/ep501.h
+++ b/drivers/mtd/nand/ep501.h
@@ -190,7 +190,4 @@
 #define EP501G3_NAND_SYN_R56_S15      0x8178
 #define EP501G3_NAND_SYN_R78_S15      0x817c
 
-int
-lsi_nand_set_config(struct mtd_info *mtd, struct nand_chip *chip);
-
 #endif
diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c
index 4f4b531..8f2958f 100644
--- a/drivers/mtd/nand/nand_base.c
+++ b/drivers/mtd/nand/nand_base.c
@@ -52,10 +52,6 @@
 #include <linux/mtd/partitions.h>
 #endif
 
-#ifdef CONFIG_MTD_NAND_LSI
-#include "ep501.h"
-#endif /* CONFIG_LSI_NAND */
-
 /* Define default oob placement schemes for large and small page devices */
 static struct nand_ecclayout nand_oob_8 = {
 	.eccbytes = 3,
@@ -407,12 +403,7 @@ static int nand_check_wp(struct mtd_info *mtd)
 	struct nand_chip *chip = mtd->priv;
 	/* Check the WP bit */
 	chip->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);
-#ifdef CONFIG_MTD_NAND_LSI
-	return (readl(chip->IO_ADDR_R +
-		NAND_STATUS1_REG) & NAND_STATUS_WP) ? 0 : 1;
-#else
 	return (chip->read_byte(mtd) & NAND_STATUS_WP) ? 0 : 1;
-#endif
 }
 
 /**
@@ -2439,12 +2430,6 @@ int nand_erase_nand(struct mtd_info *mtd, struct erase_info *instr,
 	/* Deselect and wake up anyone waiting on the device */
 	nand_release_device(mtd);
 
-#ifdef CONFIG_MTD_NAND_LSI
-	/* if erase failed for a block, mark it as bad block */
-	if (status & NAND_STATUS_FAIL)
-		mtd->block_markbad(mtd, page << chip->page_shift);
-#endif /* CONFIG_MTD_NAND_LSI */
-
 	/* Do call back function */
 	if (!ret)
 		mtd_erase_callback(instr);
@@ -2616,13 +2601,8 @@ static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
 	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
 
 	/* Read manufacturer and device IDs */
-#ifdef CONFIG_MTD_NAND_LSI
-	*maf_id = readb(chip->IO_ADDR_R + NAND_ID0_REG);
-	dev_id = readb(chip->IO_ADDR_R + NAND_ID2_REG);
-#else  /* CONFIG_MTD_NAND_LSI */
 	*maf_id = chip->read_byte(mtd);
 	dev_id = chip->read_byte(mtd);
-#endif /* CONFIG_MTD_NAND_LSI */
 
 	/* Try again to make sure, as some systems the bus-hold or other
 	 * interface concerns can cause random data which looks like a
@@ -2633,13 +2613,9 @@ static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
 	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
 
 	/* Read manufacturer and device IDs */
-#ifdef CONFIG_MTD_NAND_LSI
-	tmp_manf = readb(chip->IO_ADDR_R + NAND_ID0_REG);
-	tmp_id = readb(chip->IO_ADDR_R + NAND_ID2_REG);
-#else  /* CONFIG_MTD_NAND_LSI */
+
 	tmp_manf = chip->read_byte(mtd);
 	tmp_id = chip->read_byte(mtd);
-#endif /* CONFIG_MTD_NAND_LSI */
 
 	if (tmp_manf != *maf_id || tmp_id != dev_id) {
 		printk(KERN_INFO "%s: second ID read did not match "
@@ -2667,17 +2643,10 @@ static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
 	/* Newer devices have all the information in additional id bytes */
 	if (!type->pagesize) {
 		int extid;
-#ifdef CONFIG_MTD_NAND_LSI
-		/* The 3rd id byte holds MLC / multichip data */
-		chip->cellinfo = readb(chip->IO_ADDR_R + NAND_ID4_REG);
-		/* The 4th id byte is the important one */
-		extid = readb(chip->IO_ADDR_R + NAND_ID6_REG);
-#else  /* CONFIG_MTD_NAND_LSI */
 		/* The 3rd id byte holds MLC / multichip data */
 		chip->cellinfo = chip->read_byte(mtd);
 		/* The 4th id byte is the important one */
 		extid = chip->read_byte(mtd);
-#endif /* CONFIG_MTD_NAND_LSI */
 		/* Calc pagesize */
 		mtd->writesize = 1024 << (extid & 0x3);
 		extid >>= 2;
@@ -2700,11 +2669,6 @@ static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
 		busw = type->options & NAND_BUSWIDTH_16;
 	}
 
-#ifdef CONFIG_MTD_NAND_LSI
-	/* Set the EP501/EP501G1 config register. */
-	lsi_nand_set_config(mtd, chip);
-#endif /* CONFIG_MTD_NAND_LSI */
-
 	/* Try to identify manufacturer */
 	for (maf_idx = 0; nand_manuf_ids[maf_idx].id != 0x0; maf_idx++) {
 		if (nand_manuf_ids[maf_idx].id == *maf_id)
-- 
1.7.0.5

