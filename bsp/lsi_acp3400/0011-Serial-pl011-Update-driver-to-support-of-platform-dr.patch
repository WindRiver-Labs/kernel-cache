From ae058f07ab7a433be341f30b63583f33e466899d Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Mon, 18 Apr 2011 09:42:06 +0800
Subject: [PATCH 11/27] Serial:pl011:Update driver to support of-platform drivers

Since the PPC LSI ACP34xx board implements pl011 serial driver,
Update driver register interface to support ppc of-platform style
driver register interface.

The patch abstract the common code of probe, remove & PM routines
between ARM_AMBA style driver and of-platform driver, then fork
a new drivers for ppc of-platform.

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/serial/Kconfig      |    2 +-
 drivers/serial/amba-pl011.c |  166 +++++++++++++++++++++++++++++++++++++-----
 2 files changed, 147 insertions(+), 21 deletions(-)

diff --git a/drivers/serial/Kconfig b/drivers/serial/Kconfig
index 6e704f4..9490310 100644
--- a/drivers/serial/Kconfig
+++ b/drivers/serial/Kconfig
@@ -327,7 +327,7 @@ config SERIAL_AMBA_PL010_CONSOLE
 
 config SERIAL_AMBA_PL011
 	tristate "ARM AMBA PL011 serial port support"
-	depends on ARM_AMBA
+	depends on ARM_AMBA || ACPX1
 	select SERIAL_CORE
 	help
 	  This selects the ARM(R) AMBA(R) PrimeCell PL011 UART.  If you have
diff --git a/drivers/serial/amba-pl011.c b/drivers/serial/amba-pl011.c
index 6df825c..f6ae388 100644
--- a/drivers/serial/amba-pl011.c
+++ b/drivers/serial/amba-pl011.c
@@ -44,13 +44,20 @@
 #include <linux/tty_flip.h>
 #include <linux/serial_core.h>
 #include <linux/serial.h>
+#ifdef CONFIG_ARM_AMBA
 #include <linux/amba/bus.h>
+#else
+#include <linux/of_platform.h>
+#include <linux/of.h>
+#endif
 #include <linux/amba/serial.h>
 #include <linux/clk.h>
 #include <linux/slab.h>
 
 #include <asm/io.h>
+#ifdef CONFIG_ARM_AMBA
 #include <asm/sizes.h>
+#endif
 
 #define UART_NR			14
 
@@ -73,6 +80,9 @@ struct uart_amba_port {
 	unsigned int		old_status;
 	unsigned int		ifls;	/* vendor-specific */
 	bool			autorts;
+#ifndef CONFIG_ARM_AMBA
+	struct resource res;
+#endif
 };
 
 /* There is by now at least one vendor with differing details, so handle it */
@@ -580,7 +590,12 @@ static const char *pl011_type(struct uart_port *port)
  */
 static void pl010_release_port(struct uart_port *port)
 {
+#ifdef CONFIG_ARM_AMBA
 	release_mem_region(port->mapbase, SZ_4K);
+#else
+	struct uart_amba_port *uap = (struct uart_amba_port *)port;
+	release_mem_region(port->mapbase, resource_size(&uap->res));
+#endif
 }
 
 /*
@@ -588,8 +603,15 @@ static void pl010_release_port(struct uart_port *port)
  */
 static int pl010_request_port(struct uart_port *port)
 {
+#ifdef CONFIG_ARM_AMBA
 	return request_mem_region(port->mapbase, SZ_4K, "uart-pl011")
 			!= NULL ? 0 : -EBUSY;
+#else
+	struct uart_amba_port *uap = (struct uart_amba_port *)port;
+	return request_mem_region(port->mapbase,
+			resource_size(&uap->res), "uart-pl011")
+			!= NULL ? 0 : -EBUSY;
+#endif
 }
 
 /*
@@ -768,10 +790,14 @@ static struct uart_driver amba_reg = {
 	.cons			= AMBA_CONSOLE,
 };
 
-static int pl011_probe(struct amba_device *dev, struct amba_id *id)
+static int pl011_probe(
+	struct device *dev,
+	struct vendor_data *vendor,
+	struct resource *res,
+	int irq,
+	struct uart_amba_port **retuap)
 {
 	struct uart_amba_port *uap;
-	struct vendor_data *vendor = id->data;
 	void __iomem *base;
 	int i, ret;
 
@@ -790,24 +816,24 @@ static int pl011_probe(struct amba_device *dev, struct amba_id *id)
 		goto out;
 	}
 
-	base = ioremap(dev->res.start, resource_size(&dev->res));
+	base = ioremap(res->start, resource_size(res));
 	if (!base) {
 		ret = -ENOMEM;
 		goto free;
 	}
 
-	uap->clk = clk_get(&dev->dev, NULL);
+	uap->clk = clk_get(dev, NULL);
 	if (IS_ERR(uap->clk)) {
 		ret = PTR_ERR(uap->clk);
 		goto unmap;
 	}
 
 	uap->ifls = vendor->ifls;
-	uap->port.dev = &dev->dev;
-	uap->port.mapbase = dev->res.start;
+	uap->port.dev = dev;
+	uap->port.mapbase = res->start;
 	uap->port.membase = base;
 	uap->port.iotype = UPIO_MEM;
-	uap->port.irq = dev->irq[0];
+	uap->port.irq = irq;
 	uap->port.fifosize = vendor->fifosize;
 	uap->port.ops = &amba_pl011_pops;
 	uap->port.flags = UPF_BOOT_AUTOCONF;
@@ -815,10 +841,10 @@ static int pl011_probe(struct amba_device *dev, struct amba_id *id)
 
 	amba_ports[i] = uap;
 
-	amba_set_drvdata(dev, uap);
+	dev_set_drvdata(dev, uap);
 	ret = uart_add_one_port(&amba_reg, &uap->port);
 	if (ret) {
-		amba_set_drvdata(dev, NULL);
+		dev_set_drvdata(dev, NULL);
 		amba_ports[i] = NULL;
 		clk_put(uap->clk);
  unmap:
@@ -827,15 +853,19 @@ static int pl011_probe(struct amba_device *dev, struct amba_id *id)
 		kfree(uap);
 	}
  out:
+	if (ret == 0)
+		if (retuap)
+			*retuap = uap;
+
 	return ret;
 }
 
-static int pl011_remove(struct amba_device *dev)
+static int pl011_remove(struct device *dev)
 {
-	struct uart_amba_port *uap = amba_get_drvdata(dev);
+	struct uart_amba_port *uap = dev_get_drvdata(dev);
 	int i;
 
-	amba_set_drvdata(dev, NULL);
+	dev_set_drvdata(dev, NULL);
 
 	uart_remove_one_port(&amba_reg, &uap->port);
 
@@ -850,9 +880,9 @@ static int pl011_remove(struct amba_device *dev)
 }
 
 #ifdef CONFIG_PM
-static int pl011_suspend(struct amba_device *dev, pm_message_t state)
+static int pl011_suspend(struct device *dev, pm_message_t state)
 {
-	struct uart_amba_port *uap = amba_get_drvdata(dev);
+	struct uart_amba_port *uap = dev_get_drvdata(dev);
 
 	if (!uap)
 		return -EINVAL;
@@ -860,9 +890,9 @@ static int pl011_suspend(struct amba_device *dev, pm_message_t state)
 	return uart_suspend_port(&amba_reg, &uap->port);
 }
 
-static int pl011_resume(struct amba_device *dev)
+static int pl011_resume(struct device *dev)
 {
-	struct uart_amba_port *uap = amba_get_drvdata(dev);
+	struct uart_amba_port *uap = dev_get_drvdata(dev);
 
 	if (!uap)
 		return -EINVAL;
@@ -871,6 +901,29 @@ static int pl011_resume(struct amba_device *dev)
 }
 #endif
 
+#ifdef CONFIG_ARM_AMBA
+
+static int pl011_amba_probe(struct amba_device *dev, struct amba_id *id)
+{
+	return pl011_probe(&dev->dev, id->data, &dev->res, dev->irq[0], NULL);
+}
+
+static int pl011_amba_remove(struct amba_device *dev)
+{
+	return pl011_remove(&dev->dev);
+}
+
+#ifdef CONFIG_PM
+static int pl011_amba_suspend(struct amba_device *dev, pm_message_t state)
+{
+	return pl011_suspend(&dev->dev, state);
+}
+
+static int pl011_amba_resume(struct amba_device *dev)
+{
+	return pl011_resume(&dev->dev);
+}
+#endif
 static struct amba_id pl011_ids[] __initdata = {
 	{
 		.id	= 0x00041011,
@@ -890,13 +943,78 @@ static struct amba_driver pl011_driver = {
 		.name	= "uart-pl011",
 	},
 	.id_table	= pl011_ids,
-	.probe		= pl011_probe,
-	.remove		= pl011_remove,
+	.probe		= pl011_amba_probe,
+	.remove		= pl011_amba_remove,
+#ifdef CONFIG_PM
+	.suspend	= pl011_amba_suspend,
+	.resume		= pl011_amba_resume,
+#endif
+};
+#else
+static int pl011_of_probe(struct of_device *dev,
+	const struct of_device_id *id)
+{
+	struct uart_amba_port *uap = NULL;
+	int ret;
+	struct resource res;
+	int irq;
+
+	ret = of_address_to_resource(dev->node, 0, &res);
+	if (ret)
+		return -ENOMEM;
+
+	irq = of_irq_to_resource(dev->node, 0, NULL);
+	if (NO_IRQ == irq)
+		return -ENODEV;
+
+	ret = pl011_probe(&dev->dev, id->data, &res, irq, &uap);
+	if (ret < 0)
+		return ret;
+	memcpy(&uap->res, &res, sizeof(struct resource));
+	return 0;
+}
+
+static int pl011_of_remove(struct of_device *dev)
+{
+	return pl011_remove(&dev->dev);
+}
+
+#ifdef CONFIG_PM
+static int pl011_of_suspend(struct of_device *dev, pm_message_t state)
+{
+	return pl011_suspend(&dev->dev, state);
+}
+
+static int pl011_of_resume(struct of_device *dev)
+{
+	return pl011_resume(&dev->dev);
+}
+#endif
+static struct of_device_id pl011_match[] = {
+	{
+		.type = "serial",
+		.compatible = "acp-uart0",
+		.data = (void *)&vendor_arm,
+	},
+	{
+		.type = "serial",
+		.compatible = "acp-uart1",
+		.data = (void *)&vendor_arm,
+	},
+	{ /* end of list */ },
+};
+
+static struct of_platform_driver pl011_driver = {
+	.name = "uart-pl011",
+	.probe		= pl011_of_probe,
+	.remove		= pl011_of_remove,
 #ifdef CONFIG_PM
-	.suspend	= pl011_suspend,
-	.resume		= pl011_resume,
+	.suspend	= pl011_of_suspend,
+	.resume		= pl011_of_resume,
 #endif
+	.match_table = pl011_match,
 };
+#endif
 
 static int __init pl011_init(void)
 {
@@ -905,7 +1023,11 @@ static int __init pl011_init(void)
 
 	ret = uart_register_driver(&amba_reg);
 	if (ret == 0) {
+#ifdef CONFIG_ARM_AMBA
 		ret = amba_driver_register(&pl011_driver);
+#else
+		ret = of_register_platform_driver(&pl011_driver);
+#endif
 		if (ret)
 			uart_unregister_driver(&amba_reg);
 	}
@@ -914,7 +1036,11 @@ static int __init pl011_init(void)
 
 static void __exit pl011_exit(void)
 {
+#ifdef CONFIG_ARM_AMBA
 	amba_driver_unregister(&pl011_driver);
+#else
+	of_unregister_platform_driver(&pl011_driver);
+#endif
 	uart_unregister_driver(&amba_reg);
 }
 
-- 
1.7.0.5

