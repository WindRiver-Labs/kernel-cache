From 32976d837012c35809b8ce7638a848756e6b6cc9 Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Thu, 14 Apr 2011 18:00:51 +0800
Subject: [PATCH 15/27] PowerPC:ACP34xx:Add NIC Driver

The patch add driver for LSI ACP34xx NIC.

Update vender drop code to support OF-platform style driver register
interface.

Fixed context to apply to Wind River kernel tree.

Extract from vendor drop patch lsi-patch 3.8.1.12.

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/net/Kconfig  |   35 +
 drivers/net/Makefile |    2 +
 drivers/net/acpnic.c | 2819 ++++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 2856 insertions(+), 0 deletions(-)
 create mode 100644 drivers/net/acpnic.c

diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index fbb3570..9e28e0c 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -234,6 +234,41 @@ config MACB
 	  To compile this driver as a module, choose M here: the module
 	  will be called macb.
 
+config LSI_NET
+	tristate "Network interface for LSI's APP and ACP"
+	depends on ACP
+	default y
+	help
+	  Network interface driver for LSI's APP and ACP series boards.
+
+config LSI_NET_NUM_RX_DESC
+	int "NIC driver: Number of receive descriptors"
+	depends on LSI_NET
+	default "4"
+	help
+          The number of receive descriptors to allocate.
+
+config LSI_NET_RX_BUF_SZ
+	int "NIC driver: Size of the receive buffer"
+	depends on LSI_NET
+	default "32768"
+	help
+	  The size of the receive buffer.
+
+config LSI_NET_NUM_TX_DESC
+	int "NIC driver: Number of transmit descriptors"
+	depends on LSI_NET
+	default "4"
+	help
+	  The number of transmit descriptors to allocate.
+
+config LSI_NET_TX_BUF_SZ
+	int "NIC driver: Size of the transmit buffer"
+	depends on LSI_NET
+	default "32768"
+	help
+	  The size of the transmit buffer.
+
 source "drivers/net/arm/Kconfig"
 
 config AX88796
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index 96df0ab..0c019a5 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -303,3 +303,5 @@ obj-$(CONFIG_WIMAX) += wimax/
 
 obj-$(CONFIG_OCTEON_MGMT_ETHERNET) += octeon/
 obj-$(CONFIG_PCH_GBE) += pch_gbe/
+
+obj-$(CONFIG_LSI_NET)		+= acpnic.o
diff --git a/drivers/net/acpnic.c b/drivers/net/acpnic.c
new file mode 100644
index 0000000..371803f
--- /dev/null
+++ b/drivers/net/acpnic.c
@@ -0,0 +1,2819 @@
+/*
+ * drivers/net/acpnic.c
+ *
+ * Copyright (C) 2009 LSI
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307	 USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+#include <linux/in.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/spinlock.h>
+#include <linux/delay.h>
+#include <linux/bitops.h>
+#include <linux/proc_fs.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/skbuff.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
+#include <linux/of_platform.h>
+#include <linux/of.h>
+
+#include <asm/dma.h>
+
+#ifdef CONFIG_LSI_UBOOTENV
+#include <asm/ubootenv.h>
+#endif
+
+/* DEBUG */
+#if defined(DEBUG)
+#define DEBUG_PRINT(format, args...) do { \
+printk(KERN_INFO "appnic:%d - DEBUG - ", __LINE__); \
+printk(format, ##args); \
+} while (0);
+#else
+#define DEBUG_PRINT(format, args...)
+#endif
+
+#if defined(PHY_DEBUG)
+#define PHY_DEBUG_PRINT(format, args...) do { \
+printk(KERN_INFO "net:%d - PHY_DEBUG - ", __LINE__); \
+printk(format, ##args); \
+} while (0);
+#else
+#define PHY_DEBUG_PRINT(format, args...)
+#endif
+
+/*  WARN  */
+#if defined(WARN)
+#define WARN_PRINT(format, args...) do { \
+printk(KERN_WARNING "appnic:%d - WARN - ", __LINE__); \
+printk(format, ##args); \
+} while (0);
+#else
+#define WARN_PRINT(format, args...)
+#endif
+
+/* ERROR */
+#define ERROR_PRINT(format, args...) do { \
+printk(KERN_ERR "%s:%s:%d - ERROR - ", __FILE__, __func__, __LINE__); \
+printk(format, ##args); \
+} while (0);
+
+/*
+  Optimizations
+*/
+
+#define DISABLE_TX_INTERRUPTS
+
+/*
+  NAPI Support (new and newer)...
+*/
+
+#define LSINET_NAPI
+#define LSINET_NAPI_WEIGHT 64
+
+/* PHY */
+
+/* -- control -- */
+
+#define PHY_CONTROL 0x00
+
+union phy_control_t{
+	unsigned short raw;
+
+	struct {
+#ifdef __BIG_ENDIAN
+		unsigned short soft_reset:1;
+		unsigned short loop_back:1;
+		unsigned short force100:1; /* speedBit0 */
+		unsigned short autoneg_enable:1;
+		unsigned short power_down:1;
+		unsigned short isolate:1;
+		unsigned short restart_autoneg:1;
+		unsigned short full_duplex:1; /* duplex */
+		unsigned short collision_test:1;
+		unsigned short unused:7;
+#else
+		unsigned short unused:7;
+		unsigned short collision_test:1;
+		unsigned short full_duplex:1; /* duplex */
+		unsigned short restart_autoneg:1;
+		unsigned short isolate:1;
+		unsigned short power_down:1;
+		unsigned short autoneg_enable:1;
+		unsigned short force100:1; /* speedBit0 */
+		unsigned short loop_back:1;
+		unsigned short soft_reset:1;
+#endif
+	} __attribute__ ((packed)) bits;
+} __attribute__ ((packed));
+
+/* -- status -- */
+
+#define PHY_STATUS 0x01
+
+union phy_status_t{
+	unsigned short raw;
+
+	struct {
+#ifdef __BIG_ENDIAN
+		unsigned short t4_capable:1;
+		unsigned short tx_fdx_capable:1;
+		unsigned short tx_capable:1;
+		unsigned short bt_fdx_capable:1;
+		unsigned short tenbt_capable:1;
+		unsigned short unused:4;
+		unsigned short mf_pream_suppress:1;
+		unsigned short autoneg_comp:1; /* autoNegDone */
+		unsigned short remote_fault:1; /* remoutFault */
+		unsigned short autoneg_capable:1;
+		unsigned short link_status:1; /* linkStatus */
+		unsigned short jabber_detect:1;
+		unsigned short extd_reg_capable:1;
+#else
+		unsigned short extd_reg_capable:1;
+		unsigned short jabber_detect:1;
+		unsigned short link_status:1; /* linkStatus */
+		unsigned short autoneg_capable:1;
+		unsigned short remote_fault:1; /* remoutFault */
+		unsigned short autoneg_comp:1; /* autoNegDone */
+		unsigned short mf_pream_suppress:1;
+		unsigned short:4;
+		unsigned short tenbt_capable:1;
+		unsigned short bt_fdx_capable:1;
+		unsigned short tx_capable:1;
+		unsigned short tx_fdx_capable:1;
+		unsigned short t4_capable:1;
+#endif
+	} __attribute__ ((packed)) bits;
+} __attribute__ ((packed));
+
+/* -- id_high -- */
+
+#define PHY_ID_HIGH 0x02
+
+union phy_id_high_t {
+	unsigned short raw;
+	struct {
+		unsigned short id:16;
+	} __attribute__ ((packed)) bits;
+} __attribute__ ((packed));
+
+#define BC_PHY_ID_HIGH_ID	0x40
+#define M_PHY_ID_HIGH_ID	0x22
+
+/* -- id_low -- */
+
+#define PHY_ID_LOW  0x03
+
+union phy_id_low_t {
+	unsigned short raw;
+	struct {
+#ifdef __BIG_ENDIAN
+		unsigned short id:6;
+		unsigned short model:6;
+		unsigned short revision:4;
+#else
+		unsigned short revision:4;
+		unsigned short model:6;
+		unsigned short id:6;
+#endif
+	} __attribute__ ((packed)) bits;
+} __attribute__ ((packed));
+
+#define BC_PHY_ID_LOW_ID		0x18
+#define BC_PHY_ID_LOW_MODEL		0x1e
+#define M_PHY_ID_LOW_ID			0x05
+#define M_PHY_ID_LOW_MODEL		0x20
+
+/* -- autoneg_advertise	 -- */
+
+#define PHY_AUTONEG_ADVERTISE 0x04
+
+/* -- link_partner_ability -- */
+
+#define PHY_LINK_PARTNER_ABILITY 0x05
+
+/* -- -- */
+
+#define MICREL_PHY_AUXILIARY_CONTROL_STATUS 0x1f
+
+union micrel_phy_auxiliary_control_status_t{
+	unsigned short raw;
+	struct {
+#ifdef __BIG_ENDIAN
+		unsigned short unused1:3;
+		unsigned short energy:1;
+		unsigned short force_link:1;
+		unsigned short power_saving:1;
+		unsigned short interrupt_level:1;
+		unsigned short jabber_enable:1;
+		unsigned short autoneg_indication:1;
+		unsigned short enable_pause:1;
+		unsigned short isolate:1;
+		unsigned short op_mode_indication:3;
+		unsigned short unused2:2;
+#else
+		unsigned short unused2:2;  /*bit 0-1*/
+		unsigned short op_mode_indication:3;   /*bit 2-4*/
+		unsigned short isolate:1;   /*bit 5*/
+		unsigned short enable_pause:1;   /*bit 6*/
+		unsigned short autoneg_indication:1;   /*bit 7*/
+		unsigned short jabber_enable:1;   /*bit 8*/
+		unsigned short interrupt_level:1;   /*bit 9*/
+		unsigned short power_saving:1;   /*bit 10*/
+		unsigned short force_link:1;   /*bit 11*/
+		unsigned short energy:1;   /*bit 12*/
+		unsigned short unused1:3;   /*bit 13-15*/
+#endif
+	} __attribute__ ((packed)) bits;
+} __attribute__ ((packed));
+
+/*
+  Auto-negotiation Advertisement Values.
+*/
+
+#define PHY_AUTONEG_ADVERTISE_100FULL 0x101
+#define PHY_AUTONEG_ADVERTISE_100     0x081
+#define PHY_AUTONEG_ADVERTISE_10FULL  0x041
+#define PHY_AUTONEG_ADVERTISE_10      0x021
+
+
+#define UNKNOWN_PHY_ 0x0
+#define BCM5221_PHY_ 0x1
+#define MICREL_PHY_  0x2
+
+/*  NIC Interface */
+
+static int enable_(struct net_device *);
+
+/*
+  Device Data Structures
+*/
+
+struct appnic_dma_descriptor_t{
+
+#ifdef __BIG_ENDIAN
+	/* Word 0 */
+	unsigned long unused:24;
+	/* big endian to little endian */
+	unsigned long byte_swapping_on:1;
+	unsigned long error:1;
+	unsigned long interrupt_on_completion:1;
+	unsigned long end_of_packet:1;
+	unsigned long start_of_packet:1;
+	unsigned long write:1;
+	/* 00=Fill|01=Block|10=Scatter */
+	unsigned long transfer_type:2;
+
+	/* Word 1 */
+	unsigned long pdu_length:16;
+	unsigned long data_transfer_length:16;
+
+	/* Word 2 */
+	unsigned long target_memory_address;
+
+	/* Word 3 */
+	unsigned long host_data_memory_pointer;
+#else
+	/* Word 0 */
+	/* 00=Fill|01=Block|10=Scatter */
+	unsigned long transfer_type:2;
+	unsigned long write:1;
+	unsigned long start_of_packet:1;
+	unsigned long end_of_packet:1;
+	unsigned long interrupt_on_completion:1;
+	unsigned long error:1;
+	/* big endian to little endian */
+	unsigned long byte_swapping_on:1;
+	unsigned long unused:24;
+
+	/* Word 1 */
+	unsigned long data_transfer_length:16;
+	unsigned long pdu_length:16;
+
+	/* Word 2 */
+	unsigned long target_memory_address;
+
+	/* Word 3 */
+	unsigned long host_data_memory_pointer;
+#endif
+} __attribute__ ((packed)) ;
+
+union appnic_queue_pointer_t{
+	unsigned long raw;
+	struct {
+#ifdef __BIG_ENDIAN
+		unsigned long unused:11;
+		unsigned long generation_bit:1;
+		unsigned long offset:20;
+#else
+		unsigned long offset:20;
+		unsigned long generation_bit:1;
+		unsigned long unused:11;
+#endif
+	} __attribute__ ((packed)) bits;
+} __attribute__ ((packed));
+
+/*
+  The Device Struction
+*/
+
+struct appnic_device_t{
+	/* net_device */
+	struct net_device *device;
+
+#ifdef LSINET_NAPI
+	/* napi */
+	struct napi_struct napi;
+#endif /* LSINET_ENABLE_NAPI */
+
+	/* statistics */
+	struct net_device_stats stats;
+
+	/* DMA-able memory.*/
+	int dma_alloc_size;
+	void *dma_alloc;
+	dma_addr_t dma_alloc_dma;
+	int dma_alloc_offset;
+
+	/* tail pointers */
+	volatile union appnic_queue_pointer_t *rx_tail;
+	dma_addr_t rx_tail_dma;
+	volatile union appnic_queue_pointer_t *tx_tail;
+	dma_addr_t tx_tail_dma;
+
+	/* descriptors */
+	struct appnic_dma_descriptor_t *rx_desc;
+	dma_addr_t rx_desc_dma;
+	unsigned rx_num_desc;
+	struct appnic_dma_descriptor_t *tx_desc;
+	dma_addr_t tx_desc_dma;
+	unsigned tx_num_desc;
+
+	/* buffers */
+	unsigned rx_buf_sz;
+	unsigned rx_buf_per_desc;
+	void *rx_buf;
+	dma_addr_t rx_buf_dma;
+	unsigned tx_buf_sz;
+	unsigned tx_buf_per_desc;
+	void *tx_buf;
+	dma_addr_t tx_buf_dma;
+
+	/* The local pointers */
+
+	union appnic_queue_pointer_t rx_tail_copy;
+	union appnic_queue_pointer_t rx_head;
+
+	union appnic_queue_pointer_t tx_tail_copy;
+	union appnic_queue_pointer_t tx_head;
+
+	/* Spin Lock */
+	spinlock_t lock;
+	spinlock_t extra_lock;
+
+	/* PHY Polling Timer*/
+	struct timer_list appnic_timer_;
+	int phy_address_;
+	int phy_type_;
+	spinlock_t mdio_lock;
+
+	/* Device Variables */
+	unsigned int irq;
+	void __iomem *reg;
+	void __iomem *mdioreg;
+};
+
+#define DESCRIPTOR_GRANULARITY 64
+#define BUFFER_ALIGNMENT 64
+
+#define ALIGN64B(address) \
+((((unsigned long) (address) + (64UL - 1UL)) & ~(64UL - 1UL)))
+
+#define ALIGN64B_OFFSET(address) \
+(ALIGN64B(address) - (unsigned long) (address))
+
+const char APPNIC_DEFAULT_MAC[] = {
+	0x00, 0x02, 0x2d, 0x84, 0x11, 0xa2
+};
+
+/*
+  Overview
+  --------
+
+  Register offset decoding is as follows:
+
+  Bit(s) Description
+
+  16:15	 define the Channel.  There is only one; therefore, 00.
+  14:12	 define the MAC within the channel.  Only one so 000.
+  11:10	 define the register "space" as follows:
+  00 = fast ethernet MAC
+  10 = global
+  11 = interrupt
+  9: 2	register
+  1: 0	always 00, 32 bit registers only.
+
+  Receive registers start at the base address.	Transmit registers start
+  at 0x20000 above the base address.  DMA start at a completely different
+  base address (in this case 0x8000000 above the base).
+
+*/
+
+/*
+  Registers.
+*/
+
+/* SMII Status  */
+#define APPNIC_RX_SMII_STATUS(adapter)	     (adapter->reg + 0x10)
+#define APPNIC_RX_SMII_STATUS_SPEED  0x01
+#define APPNIC_RX_SMII_STATUS_DUPLEX 0x02
+#define APPNIC_RX_SMII_STATUS_LINK   0x04
+#define APPNIC_RX_SMII_STATUS_JABBER 0x08
+#define APPNIC_RX_SMII_STATUS_FCD    0x10 /* False Carrier Detect */
+
+#define SMII_SPEED_100(smii_status_) \
+(0 != (smii_status_ & APPNIC_RX_SMII_STATUS_SPEED))
+#define SMII_DUPLEX(smii_status_) \
+(0 != (smii_status_ & APPNIC_RX_SMII_STATUS_DUPLEX))
+#define SMII_LINK(smii_status_) \
+(0 != (smii_status_ & APPNIC_RX_SMII_STATUS_LINK))
+#define SMII_JABBER(smii_status_) \
+(0 != (smii_status_ & APPNIC_RX_SMII_STATUS_JABBER))
+
+/* Receive Configuration  */
+
+#define APPNIC_RX_CONF(adapter)	     (adapter->reg + 0x004c)
+#define APPNIC_RX_CONF_ENABLE	0x0001
+/* Pass Any Packet */
+#define APPNIC_RX_CONF_PAP	0x0002
+#define APPNIC_RX_CONF_JUMBO9K	0x0008
+#define APPNIC_RX_CONF_STRIPCRC 0x0010
+/* Accept All MAC Types */
+#define APPNIC_RX_CONF_AMT	0x0020
+/* Accept Flow Control */
+#define APPNIC_RX_CONF_AFC	0x0040
+/* Enable VLAN */
+#define APPNIC_RX_CONF_VLAN	0x0200
+/* RX MAC Speed, 1=100MBS */
+#define APPNIC_RX_CONF_SPEED	0x0800
+/* 1=Duplex Mode */
+#define APPNIC_RX_CONF_DUPLEX	0x1000
+/* 1=Enable */
+#define APPNIC_RX_CONF_LINK	0x2000
+/* Determines the action taken when the FE MAC
+   receives an FC packet in FD mode.*/
+#define APPNIC_RX_CONF_RXFCE	0x4000
+/* Controls the insertion of FC packets
+   by the MAC transmitter. */
+#define APPNIC_RX_CONF_TXFCE	0x8000
+
+/* Receive Stat Overflow  */
+
+#define APPNIC_RX_STAT_OVERFLOW(adapter)	     (adapter->reg + 0x278)
+
+/* Receive Stat Undersize  */
+
+#define APPNIC_RX_STAT_UNDERSIZE(adapter)	     (adapter->reg + 0x280)
+
+/* Receive Stat Oversize  */
+
+#define APPNIC_RX_STAT_OVERSIZE(adapter)	     (adapter->reg + 0x2b8)
+
+/* Receive Stat Multicast  */
+
+#define APPNIC_RX_STAT_MULTICAST(adapter)	     (adapter->reg + 0x2d0)
+
+/* Receive Stat Packet OK  */
+
+#define APPNIC_RX_STAT_PACKET_OK(adapter)	     (adapter->reg + 0x2c0)
+
+/* Receive Stat CRC Error  */
+
+#define APPNIC_RX_STAT_CRC_ERROR(adapter)	     (adapter->reg + 0x2c8)
+
+/* Receive Stat Align Error  */
+
+#define APPNIC_RX_STAT_ALIGN_ERROR(adapter)	     (adapter->reg + 0x2e8)
+
+/* Receive Ethernet Mode  */
+
+#define APPNIC_RX_MODE(adapter)	     (adapter->reg + 0x0800)
+#define APPNIC_RX_MODE_ETHERNET_MODE_ENABLE 0x00001
+
+/* Receive Soft Reset  */
+
+#define APPNIC_RX_SOFT_RESET(adapter)	     (adapter->reg + 0x0808)
+#define APPNIC_RX_SOFT_RESET_MAC_0 0x00001
+
+/* Receive Internal Interrupt Control */
+
+#define APPNIC_RX_INTERNAL_INTERRUPT_CONTROL(adapter) (adapter->reg + 0xc00)
+#define APPNIC_RX_INTERNAL_INTERRUPT_CONTROL_MAC_0 0x1
+
+/* Receive External Interrupt Control  */
+
+#define APPNIC_RX_EXTERNAL_INTERRUPT_CONTROL(adapter) (adapter->reg + 0xc04)
+#define APPNIC_RX_EXTERNAL_INTERRUPT_CONTROL_MAC_0_HIGH_LOW 0x10
+#define APPNIC_RX_EXTERNAL_INTERRUPT_CONTROL_MAC_0 0x1
+
+/* Receive Interrupt Status ----------------------------------------- */
+
+#define APPNIC_RX_INTERRUPT_STATUS(adapter) (adapter->reg + 0xc20)
+#define APPNIC_RX_INTERRUPT_EXTERNAL_STATUS_MAC_0 0x10
+#define APPNIC_RX_INTERRUPT_INTERNAL_STATUS_MAC_0 0x1
+
+/* Transmit Watermark ----------------------------------------------- */
+
+#define APPNIC_TX_WATERMARK(adapter) (adapter->reg + 0x1018)
+#define APPNIC_TX_WATERMARK_TXCONFIG_DTPA_ASSERT 0x8000
+#define APPNIC_TX_WATERMARK_TXCONFIG_DTPA_DISABLE 0x4000
+#define APPNIC_TX_WATERMARK_TXCONFIG_DTPA_WATER_MARK_HIGH 0x3f00
+#define APPNIC_TX_WATERMARK_TXCONFIG_DTPA_WATER_MARK_LOW 0x3f
+
+/* Swap Source Address Registers ------------------------------------ */
+
+#define APPNIC_SWAP_SOURCE_ADDRESS_2(adapter) (adapter->reg + 0x1020)
+#define APPNIC_SWAP_SOURCE_ADDRESS_1(adapter) (adapter->reg + 0x1024)
+#define APPNIC_SWAP_SOURCE_ADDRESS_0(adapter) (adapter->reg + 0x1028)
+
+/* Transmit Extended Configuration ---------------------------------- */
+
+#define APPNIC_TX_EXTENDED_CONF(adapter) (adapter->reg + 0x1030)
+#define APPNIC_TX_EXTENDED_CONF_TRANSMIT_COLLISION_WATERMARK_LEVEL 0xf000
+#define APPNIC_TX_EXTENDED_CONF_EXCESSIVE_DEFFERED_PACKET_DROP 0x200
+#define APPNIC_TX_EXTENDED_CONF_JUMBO9K 0x100
+#define APPNIC_TX_EXTENDED_CONF_LATE_COLLISION_WINDOW_COUNT 0xff
+
+/* Transmit Half Duplex Configuration ------------------------------- */
+
+#define APPNIC_TX_HALF_DUPLEX_CONF(adapter) (adapter->reg + 0x1034)
+#define APPNIC_TX_HALF_DUPLEX_CONF_RANDOM_SEED_VALUE 0xff
+
+/* Transmit Configuration ------------------------------------------- */
+
+#define APPNIC_TX_CONF(adapter) (adapter->reg + 0x1050)
+#define APPNIC_TX_CONF_ENABLE_SWAP_SA 0x8000
+#define APPNIC_TX_CONF_LINK	      0x2000
+#define APPNIC_TX_CONF_DUPLEX	      0x1000
+#define APPNIC_TX_CONF_SPEED	      0x0800
+#define APPNIC_TX_CONF_XBK_RST_RX_NTX 0x0600
+#define APPNIC_TX_CONF_IFG	      0x01f0
+#define APPNIC_TX_CONF_APP_CRC_ENABLE 0x0004
+#define APPNIC_TX_CONF_PAD_ENABLE     0x0002
+#define APPNIC_TX_CONF_ENABLE	      0x0001
+
+#define TX_CONF_SET_IFG(tx_configuration_, ifg_) do { \
+(tx_configuration_) &= ~APPNIC_TX_CONF_IFG; \
+(tx_configuration_) |= ((ifg_ & 0x1f) << 4); \
+} while (0);
+
+/* Transmit Time Value Configuration   */
+
+#define APPNIC_TX_TIME_VALUE_CONF(adapter) (adapter->reg + 0x105c)
+#define APPNIC_TX_TIME_VALUE_CONF_PAUSE_VALUE 0xffff
+
+/* Transmit Stat Underrun   */
+
+#define APPNIC_TX_STAT_UNDERRUN(adapter) (adapter->reg + 0x1300)
+
+/* Transmit Stat Packet OK   */
+
+#define APPNIC_TX_STAT_PACKET_OK(adapter) (adapter->reg + 0x1318)
+
+/* Transmit Stat Undersize  */
+
+#define APPNIC_TX_STAT_UNDERSIZE(adapter) (adapter->reg + 0x1350)
+
+/* Transmit Status Late Collision  */
+
+#define APPNIC_TX_STATUS_LATE_COLLISION(adapter) (adapter->reg + 0x1368)
+
+/* Transmit Status Excessive Collision  */
+
+#define APPNIC_TX_STATUS_EXCESSIVE_COLLISION(adapter) (adapter->reg + 0x1370)
+
+/* Transmit Stat Collision Above Watermark  */
+
+#define APPNIC_TX_STAT_COLLISION_ABOVE_WATERMARK(adapter) \
+	(adapter->reg + 0x1380)
+
+/* Transmit Mode   */
+
+#define APPNIC_TX_MODE(adapter) (adapter->reg + 0x1800)
+#define APPNIC_TX_MODE_ETHERNET_MODE_ENABLE 0x1
+
+/* Transmit Soft Reset   */
+
+#define APPNIC_TX_SOFT_RESET(adapter) (adapter->reg + 0x1808)
+#define APPNIC_TX_SOFT_RESET_MAC_0 0x1
+
+/* Transmit Interrupt Control   */
+
+#define APPNIC_TX_INTERRUPT_CONTROL(adapter) (adapter->reg + 0x1c00)
+#define APPNIC_TX_INTERRUPT_CONTROL_MAC_0 0x1
+
+/* Transmit Interrupt Status   */
+
+#define APPNIC_TX_INTERRUPT_STATUS(adapter) (adapter->reg + 0x1c20)
+#define APPNIC_TX_INTERRUPT_STATUS_MAC_0 0x1
+
+/* */
+
+#define APPNIC_DMA_PCI_CONTROL(adapter) (adapter->reg + 0x2000)
+
+/* */
+
+#define APPNIC_DMA_CONTROL(adapter) (adapter->reg + 0x2008)
+
+/* DMA Interrupt Status  */
+
+#define APPNIC_DMA_INTERRUPT_STATUS(adapter) (adapter->reg + 0x2018)
+#define APPNIC_DMA_INTERRUPT_STATUS_RX 0x2
+#define APPNIC_DMA_INTERRUPT_STATUS_TX 0x1
+
+#define RX_INTERRUPT(dma_interrupt_status_) \
+(0 != (dma_interrupt_status_ & APPNIC_DMA_INTERRUPT_STATUS_RX))
+#define TX_INTERRUPT(dma_interrupt_status_) \
+(0 != (dma_interrupt_status_ & APPNIC_DMA_INTERRUPT_STATUS_TX))
+
+/* DMA Interrupt Enable   */
+
+#define APPNIC_DMA_INTERRUPT_ENABLE(adapter) (adapter->reg + 0x201c)
+#define APPNIC_DMA_INTERRUPT_ENABLE_RECEIVE 0x2
+#define APPNIC_DMA_INTERRUPT_ENABLE_TRANSMIT 0x1
+
+/* DMA Receive Queue Base Address  */
+
+#define APPNIC_DMA_RX_QUEUE_BASE_ADDRESS(adapter) (adapter->reg + 0x2030)
+
+/* DMA Receive Queue Size  */
+
+#define APPNIC_DMA_RX_QUEUE_SIZE(adapter) (adapter->reg + 0x2034)
+
+/* DMA Transmit Queue Base Address  */
+
+#define APPNIC_DMA_TX_QUEUE_BASE_ADDRESS(adapter) (adapter->reg + 0x2038)
+
+/* DMA Transmit Queue Size  */
+
+#define APPNIC_DMA_TX_QUEUE_SIZE(adapter) (adapter->reg + 0x203c)
+
+/* DMA Recevie Tail Pointer Address */
+
+#define APPNIC_DMA_RX_TAIL_POINTER_ADDRESS(adapter) (adapter->reg + 0x2048)
+
+/* DMA Transmit Tail Pointer Address */
+
+#define APPNIC_DMA_TX_TAIL_POINTER_ADDRESS(adapter) (adapter->reg + 0x204c)
+
+/* DMA Receive Head Pointer  */
+
+#define APPNIC_DMA_RX_HEAD_POINTER(adapter) (adapter->reg + 0x2050)
+#define APPNIC_DMA_RX_HEAD_POINTER_GB	   0x100000
+#define APPNIC_DMA_RX_HEAD_POINTER_POINTER 0x0fffff
+
+/* DMA Receive Tail Pointer Local Copy  */
+
+#define APPNIC_DMA_RX_TAIL_POINTER_LOCAL_COPY(adapter) \
+	(adapter->reg + 0x2054)
+#define APPNIC_DMA_RX_TAIL_POINTER_LOCAL_COPY_GB      0x100000
+#define APPNIC_DMA_RX_TAIL_POINTER_LOCAL_COPY_POINTER 0x0fffff
+
+/* DMA Transmit Head Pointer  */
+
+#define APPNIC_DMA_TX_HEAD_POINTER(adapter) (adapter->reg + 0x2058)
+#define APPNIC_DMA_TX_HEAD_POINTER_GB	   0x100000
+#define APPNIC_DMA_TX_HEAD_POINTER_POINTER 0x0fffff
+
+/* DMA Transmit Tail Pointer Local Copy  */
+
+#define APPNIC_DMA_TX_TAIL_POINTER_LOCAL_COPY(adapter) (adapter->reg + 0x205c)
+#define APPNIC_DMA_TX_TAIL_POINTER_LOCAL_COPY_GB      0x100000
+#define APPNIC_DMA_TX_TAIL_POINTER_LOCAL_COPY_POINTER 0x0fffff
+
+#define APPNIC_DMA_DTPA_LOW(adapter) (adapter->reg + 0x2060)
+#define APPNIC_DMA_DTPA_HIGH(adapter) (adapter->reg + 0x2064)
+
+
+/* MDIO registers */
+#define MDIO_CONTROL_RD_DATA(adapter) (adapter->mdioreg + 0x00)
+#define MDIO_STATUS_RD_DATA(adapter) (adapter->mdioreg + 0x04)
+#define MDIO_CLK_OFFSET(adapter) (adapter->mdioreg + 0x08)
+#define MDIO_CLK_PERIOD(adapter) (adapter->mdioreg + 0x0c)
+
+
+/* Access */
+
+#define readio(address) in_le32((u32 *) (address))
+
+#define writeio(value, address) out_le32((u32 *) (address), (value))
+
+static inline void
+readdescriptor(unsigned long address,
+	struct appnic_dma_descriptor_t *descriptor)
+{
+	unsigned long *from = (unsigned long *) address;
+	unsigned long *to = (unsigned long *) descriptor;
+	*to++ = swab32(*from++);
+	*to++ = swab32(*from++);
+	*to++ = swab32(*from++);
+	*to++ = swab32(*from++);
+	return;
+}
+
+static inline void
+writedescriptor(unsigned long address,
+	const struct appnic_dma_descriptor_t *descriptor)
+{
+	unsigned long *to = (unsigned long *) address;
+	unsigned long *from = (unsigned long *) descriptor;
+	*to++ = swab32(*from++);
+	*to++ = swab32(*from++);
+	*to++ = swab32(*from++);
+	*to++ = swab32(*from++);
+	return;
+}
+
+static inline union appnic_queue_pointer_t
+swab_queue_pointer(const union appnic_queue_pointer_t *old_queue)
+{
+	union appnic_queue_pointer_t new_queue;
+	new_queue.raw = swab32(old_queue->raw);
+	return new_queue;
+}
+
+#define SWAB_QUEUE_POINTER(pointer) \
+swab_queue_pointer((const union appnic_queue_pointer_t *) (pointer))
+
+#define read_mac_(address) readio((address))
+#define write_mac_(value, address) writeio((value), (address))
+
+/*
+  Module Information
+*/
+
+MODULE_AUTHOR("John Jacques");
+MODULE_DESCRIPTION("Agere APP3xx ethernet driver");
+MODULE_LICENSE("GPL");
+
+/*
+  ----- Note On Buffer Space -----
+
+  Minimum number of descriptors is 64 for the receiver and 64 for the
+  transmitter; therefore, 2048 bytes (16 bytes each).
+  This driver uses the following parameters,
+  all of which may be set on the command line if this drivers is used
+  as a module.
+
+  - rx_num_desc : Number of receive descriptors.  This	must be a multiple of
+  64.
+  - tx_num_desc : Number of transmit descriptors.  This must be a multiple of
+  64.
+
+  The scheme used will be as follows:
+
+  - num_[rt]x_desc will be adjusted to be a multiple of 64 (if necessary).
+  - An skb (with the data area 64 byte aligned) will be allocated for each rx
+  descriptor.
+*/
+
+/*
+  Receiver
+*/
+
+int rx_num_desc = (CONFIG_LSI_NET_NUM_RX_DESC * DESCRIPTOR_GRANULARITY);
+module_param(rx_num_desc, int, 0);
+MODULE_PARM_DESC(rx_num_desc, "appnic : Number of receive descriptors");
+
+int rx_buf_sz = CONFIG_LSI_NET_RX_BUF_SZ;
+module_param(rx_buf_sz, int, 0);
+MODULE_PARM_DESC(rx_buf_sz, "appnic : Receive buffer size");
+
+/*
+  Transmitter
+*/
+
+int tx_num_desc = (CONFIG_LSI_NET_NUM_TX_DESC * DESCRIPTOR_GRANULARITY);
+module_param(tx_num_desc, int, 0);
+MODULE_PARM_DESC(tx_num_desc, "appnic : Number of receive descriptors");
+
+int tx_buf_sz = CONFIG_LSI_NET_TX_BUF_SZ;
+module_param(tx_buf_sz, int, 0);
+MODULE_PARM_DESC(tx_buf_sz, "Appnic : Receive buffer size");
+
+/*
+  Timeout, if a transmit takes longer than this
+  value in jiffies it has timed out.
+*/
+
+#define DEFAULT_TX_TIMEOUT 10
+
+int tx_timeout = DEFAULT_TX_TIMEOUT;
+module_param(tx_timeout, int, 0);
+MODULE_PARM_DESC(tx_timeout, "appnic : Transmit timeout (in jiffies)");
+
+static unsigned long dropped_by_stack_;
+static unsigned long out_of_tx_descriptors_;
+static unsigned long transmit_interrupts_;
+#ifdef LSINET_NAPI
+static unsigned long receive_interrupts_;
+#endif
+
+#define APPNIC_TIMER_PERIOD 5
+static void appnic_timer_handler_(unsigned long);
+
+/*
+  Locking...
+*/
+
+#ifdef CONFIG_SMP
+/*
+ * On SMP we have the following problem:
+ *
+ *	A = smc_hard_start_xmit()
+ *	B = smc_interrupt()
+ *
+ * A and B can never be executed simultaneously.  However, at least on UP,
+ * it is possible (and even desirable) for C to interrupt execution of
+ * A or B in order to have better RX reliability and avoid overruns.
+ * C, just like A and B, must have exclusive access to the chip and
+ * each of them must lock against any other concurrent access.
+ * Unfortunately this is not possible to have C suspend execution of A or
+ * B taking place on another CPU. On UP this is no an issue since A and B
+ * are run from softirq context and C from hard IRQ context, and there is
+ * no other CPU where concurrent access can happen.
+ * If ever there is a way to force at least B and C to always be executed
+ * on the same CPU then we could use read/write locks to protect against
+ * any other concurrent access and C would always interrupt B. But life
+ * isn't that easy in a SMP world...
+ */
+
+#define appnic_special_trylock(lock, flags)		\
+  ({						\
+	int __ret;				\
+	local_irq_save(flags);	\
+	__ret = spin_trylock(lock);		\
+	if (0 != __ret)				\
+		local_irq_restore(flags);	\
+	__ret;					\
+  })
+#define appnic_special_lock(lock, flags)   spin_lock_irqsave(lock, flags)
+#define appnic_special_unlock(lock, flags) spin_unlock_irqrestore(lock, flags)
+#else
+#define appnic_special_trylock(lock, flags)		(1)
+#define appnic_special_lock(lock, flags)		do { } while (0)
+#define appnic_special_unlock(lock, flags)		do { } while (0)
+#endif
+
+/*
+  Utility Functions
+*/
+
+/*
+  clear_statistics_
+*/
+
+static void
+clear_statistics_(struct appnic_device_t *adapter) {
+	int waste_;
+
+	/* Clear memory.*/
+
+	memset((void *) &(adapter->stats), 0,
+		sizeof(struct net_device_stats));
+
+	/* Clear counters.*/
+
+	waste_ = read_mac_(APPNIC_RX_STAT_PACKET_OK(adapter)); /* rx_packets */
+	waste_ = read_mac_(APPNIC_TX_STAT_PACKET_OK(adapter)); /* tx_packets */
+	/* rx_bytes kept by driver. */
+	/* tx_bytes kept by driver. */
+	/* rx_errors will be the sum of the rx errors available. */
+	/* tx_errors will be the sum of the tx errors available. */
+	/* rx_dropped (unable to allocate skb)
+	 * will be maintained by the driver */
+	/* tx_dropped (unable to allocate skb)
+	 * will be maintained by the driver */
+	/* multicast */
+	waste_ = read_mac_(APPNIC_RX_STAT_MULTICAST(adapter));
+	/* collisions will be the sum of the three following. */
+	waste_ = read_mac_(APPNIC_TX_STATUS_LATE_COLLISION(adapter));
+	waste_ = read_mac_(APPNIC_TX_STATUS_EXCESSIVE_COLLISION(adapter));
+	waste_ = read_mac_(APPNIC_TX_STAT_COLLISION_ABOVE_WATERMARK(adapter));
+	/* rx_length_errors will be the sum of the two following. */
+	waste_ = read_mac_(APPNIC_RX_STAT_UNDERSIZE(adapter));
+	waste_ = read_mac_(APPNIC_RX_STAT_OVERSIZE(adapter));
+	/* rx_over_errors (out of descriptors?) maintained by the driver. */
+	/* rx_crc_errors */
+	waste_ = read_mac_(APPNIC_RX_STAT_CRC_ERROR(adapter));
+	/* rx_frame_errors */
+	waste_ = read_mac_(APPNIC_RX_STAT_ALIGN_ERROR(adapter));
+	/* rx_fifo_errors */
+	waste_ = read_mac_(APPNIC_RX_STAT_OVERFLOW(adapter));
+	/* rx_missed will not be maintained. */
+	/* tx_aborted_errors will be maintained by the driver. */
+	/* tx_carrier_errors will not be maintained. */
+	/* tx_fifo_errors */
+	waste_ = read_mac_(APPNIC_TX_STAT_UNDERRUN(adapter));
+	/* tx_heartbeat_errors */
+	/* tx_window_errors */
+
+	/* rx_compressed will not be maintained. */
+	/* tx_compressed will not be maintained. */
+
+	return;
+}
+
+/*
+  get_hw_statistics_
+  -- NOTES --
+  1) The hardware clears the statistics registers after a read.
+*/
+
+static void
+get_hw_statistics_(struct appnic_device_t *adapter)
+{
+	unsigned long flags_;
+
+	/* tx_packets */
+	adapter->stats.tx_packets +=
+		read_mac_(APPNIC_TX_STAT_PACKET_OK(adapter));
+	/* multicast */
+	adapter->stats.multicast +=
+		read_mac_(APPNIC_RX_STAT_MULTICAST(adapter));
+	/* collision */
+	adapter->stats.collisions +=
+		read_mac_(APPNIC_TX_STATUS_LATE_COLLISION(adapter));
+	adapter->stats.collisions +=
+		read_mac_(APPNIC_TX_STATUS_EXCESSIVE_COLLISION(adapter));
+	adapter->stats.collisions +=
+		read_mac_(APPNIC_TX_STAT_COLLISION_ABOVE_WATERMARK(adapter));
+	/* rx_length_errors */
+	adapter->stats.rx_length_errors +=
+		read_mac_(APPNIC_RX_STAT_UNDERSIZE(adapter));
+	adapter->stats.rx_length_errors +=
+		read_mac_(APPNIC_RX_STAT_OVERSIZE(adapter));
+	/* tx_fifo_errors */
+	adapter->stats.tx_fifo_errors +=
+		read_mac_(APPNIC_TX_STAT_UNDERRUN(adapter));
+
+	/*
+	  Lock this section out so the statistics maintained by the driver
+	  don't get clobbered.
+	*/
+	spin_lock_irqsave(&adapter->lock, flags_);
+
+	adapter->stats.rx_errors +=
+		(adapter->stats.rx_length_errors +
+		  adapter->stats.rx_crc_errors +
+		  adapter->stats.rx_frame_errors +
+		  adapter->stats.rx_fifo_errors +
+		  adapter->stats.rx_dropped +
+		  adapter->stats.rx_over_errors);
+	adapter->stats.rx_dropped = 0;
+	adapter->stats.rx_over_errors = 0;
+
+	adapter->stats.tx_errors +=
+		(adapter->stats.tx_fifo_errors +
+		  adapter->stats.tx_aborted_errors);
+	adapter->stats.tx_aborted_errors = 0;
+
+	spin_unlock_irqrestore(&adapter->lock, flags_);
+
+	return;
+}
+
+/*
+  queue_initialized_
+
+  Returns the number of descriptors that are ready to receive packets
+  or are waiting to transmit packets.  (from tail to head).
+*/
+
+static int queue_initialized_(union appnic_queue_pointer_t head,
+		union appnic_queue_pointer_t tail,
+		int size) {
+	int initialized;
+
+	/* Calculate the number of descriptors currently initialized. */
+
+	if (head.bits.generation_bit == tail.bits.generation_bit) {
+
+		/* same generation */
+		initialized = (head.bits.offset - tail.bits.offset);
+
+	} else {
+
+		/* different generation */
+		initialized = head.bits.offset +
+			(size * sizeof(struct appnic_dma_descriptor_t)
+			- tail.bits.offset);
+
+	}
+
+	/* number of descriptors is offset / sizeof(a descriptor) */
+	initialized /= sizeof(struct appnic_dma_descriptor_t);
+
+	return initialized;
+}
+
+/*
+ queue_uninitialzed_
+
+  Returns the number of unused/uninitialized descriptors.  (from head to tail).
+*/
+
+static int queue_uninitialized_(union appnic_queue_pointer_t head,
+		union appnic_queue_pointer_t tail,
+		int size) {
+
+	int allocated_;
+
+	/* calculate the number of descriptors currently unused/uninitialized */
+
+	if (head.bits.generation_bit == tail.bits.generation_bit) {
+
+		/* same generation. */
+		allocated_ =
+			((size * sizeof(struct appnic_dma_descriptor_t))
+			- head.bits.offset)	+ tail.bits.offset;
+
+	} else
+		/* different generation. */
+		allocated_ = tail.bits.offset - head.bits.offset;
+
+	/* number of descriptors is offset / sizeof(a descriptor). */
+	allocated_ /= sizeof(struct appnic_dma_descriptor_t);
+
+	/* that's all */
+	return allocated_;
+
+}
+
+/*
+  queue_increment_
+*/
+
+static void queue_increment_(union appnic_queue_pointer_t *queue,
+			      int number_of_descriptors) {
+
+	queue->bits.offset += sizeof(struct appnic_dma_descriptor_t);
+
+	if ((number_of_descriptors * sizeof(struct appnic_dma_descriptor_t)) ==
+	    queue->bits.offset) {
+
+		queue->bits.offset = 0;
+		queue->bits.generation_bit =
+			(0 == queue->bits.generation_bit) ? 1 : 0;
+
+	}
+
+	return;
+}
+
+/*
+  queue_decrement_
+*/
+
+static void queue_decrement_(union appnic_queue_pointer_t *queue,
+			      int number_of_descriptors) {
+
+	if (0 == queue->bits.offset) {
+
+		queue->bits.offset =
+			((number_of_descriptors - 1) *
+			sizeof(struct appnic_dma_descriptor_t));
+		queue->bits.generation_bit =
+			(0 == queue->bits.generation_bit) ? 1 : 0;
+
+	} else
+		queue->bits.offset -= sizeof(struct appnic_dma_descriptor_t);
+
+	return;
+}
+
+/* appnic_timer_handler_ */
+static void
+appnic_timer_handler_(unsigned long __opaque)
+{
+	struct net_device *device_ = (struct net_device *) __opaque;
+	struct appnic_device_t *adapter = netdev_priv(device_);
+
+	enable_(device_);
+	adapter->appnic_timer_.expires =
+		jiffies + (APPNIC_TIMER_PERIOD * HZ);
+	add_timer(&adapter->appnic_timer_);
+}
+
+/*
+  PHY interface (BCM5221)
+*/
+
+
+/*
+  phy_read_
+  Returns -1 if unsuccessful, the (short) value otherwise.
+*/
+
+static int
+phy_read_(struct appnic_device_t *adapter, int reg, unsigned short *value)
+{
+	unsigned long command = 0;
+	unsigned long status;
+	unsigned long flags;
+
+	spin_lock_irqsave(&adapter->mdio_lock, flags);
+	/* Set the mdio_busy (status) bit. */
+	status = readio(MDIO_STATUS_RD_DATA(adapter));
+	status |= 0x40000000;
+	writeio(status, MDIO_STATUS_RD_DATA(adapter));
+
+	command |= 0x10000000;	/* read */
+	command |= (adapter->phy_address_ & 0x1f) << 16; /* device address */
+	command |= (reg & 0x1f) << 21; /* register */
+	PHY_DEBUG_PRINT("phy:0x%x reg:0x%x command:0x%lx\n",
+			 adapter->phy_address_, reg, command);
+	writeio(command, MDIO_CONTROL_RD_DATA(adapter));
+
+	/* Wait for the mdio_busy (status) bit to clear. */
+	do {
+		status = readio(MDIO_STATUS_RD_DATA(adapter));
+	} while (0 != (status & 0x40000000));
+
+	/* Wait for the mdio_busy (control) bit to clear. */
+	do {
+		command = readio(MDIO_CONTROL_RD_DATA(adapter));
+	} while (0 != (command & 0x80000000));
+
+	*value = (unsigned short)(command & 0xffff);
+	spin_unlock_irqrestore(&adapter->mdio_lock, flags);
+	return 0;
+}
+
+/*  phy_write_ */
+
+static int
+phy_write_(struct appnic_device_t *adapter, int reg, unsigned short value)
+{
+	unsigned long command = 0;
+	unsigned long status;
+	unsigned long flags;
+
+	spin_lock_irqsave(&adapter->mdio_lock, flags);
+	/* Wait for mdio_busy (control) to be clear. */
+	do {
+		command = readio(MDIO_CONTROL_RD_DATA(adapter));
+	} while (0 != (command & 0x80000000));
+
+	/* Set the mdio_busy (status) bit. */
+	status = readio(MDIO_STATUS_RD_DATA(adapter));
+	status |= 0x40000000;
+	writeio(status, MDIO_STATUS_RD_DATA(adapter));
+
+	command |= 0x08000000; /* write */
+	command |= (adapter->phy_address_ & 0x1f) << 16; /* device address */
+	command |= (reg & 0x1f) << 21; /* register */
+	command |= value;
+	PHY_DEBUG_PRINT("phy:0x%x reg:0x%x command:0x%lx\n",
+			 adapter->phy_address_, reg, command);
+	writeio(command, MDIO_CONTROL_RD_DATA(adapter));
+
+	/* Wait for the mdio_busy (status) bit to clear. */
+	do {
+		status = readio(MDIO_STATUS_RD_DATA(adapter));
+	} while (0 != (status & 0x40000000));
+
+	/* Wait for the mdio_busy (control) bit to clear. */
+	do {
+		command = readio(MDIO_CONTROL_RD_DATA(adapter));
+	} while (0 != (command & 0x80000000));
+
+	spin_unlock_irqrestore(&adapter->mdio_lock, flags);
+	return 0;
+}
+
+/*
+  phy_link_
+  Returns the link status (1=link up, 0=link down) or an error (-1).
+*/
+
+static int
+phy_link_(struct appnic_device_t *adapter)
+{
+	union phy_status_t status;
+
+	phy_read_(adapter, PHY_STATUS, &status.raw);
+	phy_read_(adapter, PHY_STATUS, &status.raw);
+
+	return status.bits.link_status;
+}
+
+/*
+  phy_speed_
+  Returns the speed (1=100, 0=10) or an error (-1).
+*/
+
+static int
+phy_speed_(struct appnic_device_t *adapter)
+{
+	union micrel_phy_auxiliary_control_status_t aux;
+
+	phy_read_(adapter, MICREL_PHY_AUXILIARY_CONTROL_STATUS, &aux.raw);
+	switch ((aux.bits.op_mode_indication & 3)) {
+	case 2: return 1; break;
+	case 1:	return 0; break;
+	default:
+		break;
+	}
+
+	return -1;
+}
+
+/*
+  phy_duplex_
+  Returns duplex status (1=full duplex, 0=half duplex) or an error (-1).
+*/
+
+static int
+phy_duplex_(struct appnic_device_t *adapter)
+{
+	union micrel_phy_auxiliary_control_status_t aux;
+
+	phy_read_(adapter, MICREL_PHY_AUXILIARY_CONTROL_STATUS, &aux.raw);
+
+	return (aux.bits.op_mode_indication >> 2) & 0x1;
+}
+
+/*
+  phy_scan_
+*/
+static int phy_scan_(struct appnic_device_t *adapter)
+{
+	int phy = -1;
+	int index;
+	union phy_id_high_t phy_id_high;
+	union phy_id_low_t phy_id_low;
+
+	for (index = 31; index > -1; --index) {
+		adapter->phy_address_ = index;
+
+		if (0 != phy_read_(adapter, PHY_ID_HIGH, &phy_id_high.raw))
+			continue;
+
+		if (0 != phy_read_(adapter, PHY_ID_LOW, &phy_id_low.raw))
+			continue;
+
+		if ((BC_PHY_ID_HIGH_ID == phy_id_high.bits.id) &&
+			(BC_PHY_ID_LOW_ID == phy_id_low.bits.id) &&
+			(BC_PHY_ID_LOW_MODEL == phy_id_low.bits.model)) {
+			phy = index;
+			PHY_DEBUG_PRINT("Found a Broadcom PHY at 0x%x,"
+					"revision %d.\n",
+					(phy << 4), phy_id_low.bits.revision);
+			break;
+		} else if ((M_PHY_ID_HIGH_ID == phy_id_high.bits.id) &&
+				(M_PHY_ID_LOW_ID == phy_id_low.bits.id)) {
+			phy = index;
+			PHY_DEBUG_PRINT("Found a Micrel PHY at 0x%x,"
+					"model 0x%x revision %d.\n",
+					(phy << 4), phy_id_low.bits.model,
+					phy_id_low.bits.revision);
+			break;
+		} else {
+			adapter->phy_type_ = UNKNOWN_PHY_;
+			PHY_DEBUG_PRINT("Unknown PHY at 0x%x."
+					" 0x%x 0x%x 0x%x\n",
+					(phy << 4), phy_id_high.bits.id,
+					phy_id_low.bits.id,
+					phy_id_low.bits.model);
+		}
+	}
+	adapter->phy_address_ = phy;
+	return phy;
+}
+
+/*
+  phy_reset_
+*/
+static int
+phy_reset_(struct appnic_device_t *adapter)
+{
+	union phy_control_t control;
+	int retries = 10;
+
+	phy_read_(adapter, PHY_CONTROL, &control.raw);
+	control.bits.soft_reset = 1;
+	phy_write_(adapter, PHY_CONTROL, control.raw);
+
+	do {
+		phy_read_(adapter, PHY_CONTROL, &control.raw);
+		--retries;
+	} while ((0 < retries) && (0 != control.bits.soft_reset));
+
+	if (0 != control.bits.soft_reset) {
+		printk(KERN_INFO "phy_reset(%d) failed.\n",
+			adapter->phy_address_);
+		return -1;
+	}
+
+	return 0;
+}
+
+/*
+  phy_renegotiate_
+*/
+static int
+phy_renegotiate_(struct appnic_device_t *adapter)
+{
+	union phy_control_t control;
+	union phy_status_t status;
+	int autoneg_retries = 4;
+	int autoneg_complete_retries = 8;
+
+	phy_write_(adapter, PHY_AUTONEG_ADVERTISE, 0x61);
+
+	do {
+		phy_read_(adapter, PHY_CONTROL, &control.raw);
+		control.bits.restart_autoneg = 1;
+		phy_write_(adapter, PHY_CONTROL, control.raw);
+
+		do {
+			udelay(500000);
+			phy_read_(adapter, PHY_STATUS, &status.raw);
+		} while ((0 < --autoneg_complete_retries) &&
+			 (0 == status.bits.autoneg_comp));
+
+		if (0 != status.bits.autoneg_comp)
+			break;
+
+	} while (0 < --autoneg_retries);
+
+	if (0 == status.bits.autoneg_comp) {
+		WARN_PRINT("Auto Negotiation Failed\n");
+		return -1;
+	}
+
+	DEBUG_PRINT("Auto Negotiation Succeeded\n");
+	return 0;
+}
+
+/*
+  phy_enable_
+*/
+static int phy_enable_(struct appnic_device_t *adapter)
+{
+	unsigned short ad_value_;
+	union phy_status_t phy_status;
+	int link_status_retries = 10;
+
+	writeio(0x10, MDIO_CLK_OFFSET(adapter));
+	writeio(0x2c, MDIO_CLK_PERIOD(adapter));
+
+	phy_scan_(adapter);
+	if (31 < adapter->phy_address_ || 0 > adapter->phy_address_) {
+		ERROR_PRINT("Unable to get valid PHY address!\n");
+		return -ENODEV;
+	}
+
+	if (0 != phy_reset_(adapter))
+		return -EBUSY;
+
+	ad_value_ = PHY_AUTONEG_ADVERTISE_100FULL |
+			PHY_AUTONEG_ADVERTISE_100 |
+			PHY_AUTONEG_ADVERTISE_10FULL |
+			PHY_AUTONEG_ADVERTISE_10;
+
+	if (0 != phy_write_(adapter, PHY_AUTONEG_ADVERTISE,
+			     ad_value_))
+		return -1;
+
+	phy_renegotiate_(adapter);
+
+	do {
+		if (0 != phy_read_(adapter, PHY_STATUS,
+					&phy_status.raw))
+				return -EIO;
+
+		mdelay(10);
+		--link_status_retries;
+
+	} while ((0 == phy_status.bits.link_status) &&
+			(0 < link_status_retries));
+
+	if (0 != phy_status.bits.link_status)
+		printk(KERN_INFO "PHY: link=%s speed=%d Mbs duplex=%s\n",
+			(1 == phy_link_(adapter)) ? "up" : "down",
+			(1 == phy_speed_(adapter)) ? 100 : 10,
+			(1 == phy_duplex_(adapter)) ? "full" : "half");
+
+	return 0;
+}
+
+/*
+  enable_
+  -- NOTES --
+
+  1) Does not change the default values in the extended and
+  half-duplex configuration registers.
+*/
+
+static int
+enable_(struct net_device *device)
+{
+	struct appnic_device_t *adapter = netdev_priv(device);
+	int return_code_ = 1;
+	int carrier_state_ = 0;
+	unsigned long rx_configuration_;
+	unsigned long tx_configuration_ = 0;
+	union phy_status_t phy_status_;
+
+	rx_configuration_ =
+		(APPNIC_RX_CONF_STRIPCRC |
+		  APPNIC_RX_CONF_RXFCE |
+		  APPNIC_RX_CONF_TXFCE);
+	tx_configuration_ =
+		(APPNIC_TX_CONF_ENABLE_SWAP_SA |
+		  APPNIC_TX_CONF_APP_CRC_ENABLE |
+		  APPNIC_TX_CONF_PAD_ENABLE);
+	TX_CONF_SET_IFG(tx_configuration_, 0xf);
+
+	DEBUG_PRINT("Enabling the interface.\n");
+
+	/*
+	  Setup the receive and transmit configuration registers (using smii
+	  status to set speed/duplex and check the link status).
+	*/
+
+	if ((0 == phy_read_(adapter, PHY_STATUS, &phy_status_.raw)) &&
+	    (0 == phy_read_(adapter, PHY_STATUS, &phy_status_.raw))) {
+
+		PHY_DEBUG_PRINT("phy_status_.raw=0x%x\n", phy_status_.raw);
+
+		if (1 == phy_status_.bits.autoneg_comp) {
+
+			if (1 == phy_status_.bits.link_status) {
+
+				if (1 == phy_speed_(adapter)) {
+					rx_configuration_ |=
+						APPNIC_RX_CONF_SPEED;
+					tx_configuration_ |=
+						APPNIC_TX_CONF_SPEED;
+				}
+
+				if (1 == phy_duplex_(adapter)) {
+					rx_configuration_ |=
+						APPNIC_RX_CONF_DUPLEX;
+					tx_configuration_ |=
+						APPNIC_TX_CONF_DUPLEX;
+				}
+
+				rx_configuration_ |=
+					(APPNIC_RX_CONF_ENABLE |
+					APPNIC_RX_CONF_LINK);
+				tx_configuration_ |=
+					(APPNIC_TX_CONF_LINK |
+					APPNIC_TX_CONF_ENABLE);
+				return_code_ = 0;
+				carrier_state_ = 1;
+
+			} else
+				netif_carrier_off(device);
+
+		} else
+			netif_carrier_off(device);
+
+	} else
+		ERROR_PRINT("phy_read_() failed!\n");
+
+	if (rx_configuration_ != read_mac_(APPNIC_RX_CONF(adapter)))
+		write_mac_(rx_configuration_, APPNIC_RX_CONF(adapter));
+
+	if (tx_configuration_ != read_mac_(APPNIC_TX_CONF(adapter)))
+		write_mac_(tx_configuration_, APPNIC_TX_CONF(adapter));
+
+	if (0 != carrier_state_)
+		netif_carrier_on(device);
+	else
+		netif_carrier_off(device);
+
+	return return_code_;
+}
+
+/*  disable_ */
+
+static void
+disable_(struct net_device *device)
+{
+	struct appnic_device_t *adapter = netdev_priv(device);
+	unsigned long tx_configuration_;
+	unsigned long rx_configuration_;
+
+	DEBUG_PRINT("Disabling the interface.\n");
+
+	rx_configuration_ = read_mac_(APPNIC_RX_CONF(adapter));
+	rx_configuration_ &= ~APPNIC_RX_CONF_ENABLE;
+	write_mac_(rx_configuration_, APPNIC_RX_CONF(adapter));
+
+	tx_configuration_ = read_mac_(APPNIC_TX_CONF(adapter));
+	tx_configuration_ &= ~APPNIC_TX_CONF_ENABLE;
+	write_mac_(tx_configuration_, APPNIC_TX_CONF(adapter));
+
+	return;
+}
+
+/*
+  Linux Network Driver Interface
+*/
+
+/* handle_transmit_interrupt_ */
+static void
+handle_transmit_interrupt_(struct net_device *device)
+{
+	struct appnic_device_t *dev_ = netdev_priv(device);
+
+	DEBUG_PRINT("tail=0x%lx tail_copy=0x%lx head=0x%lx\n",
+		     dev_->tx_tail->raw, dev_->tx_tail_copy.raw,
+		     dev_->tx_head.raw);
+
+	/*
+	  The hardware's tail pointer should be one descriptor (or more)
+	  ahead of software's copy.
+	*/
+
+	while (0 < queue_initialized_(SWAB_QUEUE_POINTER(dev_->tx_tail),
+				       dev_->tx_tail_copy, dev_->tx_num_desc)) {
+		queue_increment_(&dev_->tx_tail_copy, dev_->tx_num_desc);
+	}
+
+	DEBUG_PRINT("tail=0x%lx tail_copy=0x%lx head=0x%lx\n",
+		     dev_->tx_tail->raw, dev_->tx_tail_copy.raw,
+		     dev_->tx_head.raw);
+
+	return;
+}
+
+static DECLARE_MUTEX(rpm);
+
+/*
+  lsinet_rx_packet
+*/
+
+static void
+lsinet_rx(
+	struct net_device *device,
+	struct sk_buff *sk_buff_,
+	unsigned bytes_copied_)
+{
+	struct appnic_device_t *adapter = netdev_priv(device);
+	struct ethhdr *ethhdr_ = (struct ethhdr *) sk_buff_->data;
+	unsigned char broadcast_[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
+	unsigned char multicast_[] = { 0x01, 0x00 };
+	int return_code_;
+
+	if ((0 == memcmp((const void *) &(ethhdr_->h_dest[0]),
+			   (const void *) &(device->dev_addr[0]),
+			   sizeof(ethhdr_->h_dest))) ||
+		(0 == memcmp((const void *) &(ethhdr_->h_dest[0]),
+			   (const void *) &(broadcast_[0]),
+			   sizeof(ethhdr_->h_dest))) ||
+		(0 == memcmp((const void *) &(ethhdr_->h_dest[0]),
+			   (const void *) &(multicast_[0]),
+			   sizeof(multicast_)))) {
+
+		adapter->stats.rx_bytes += bytes_copied_;
+		++adapter->stats.rx_packets;
+		sk_buff_->dev = device;
+		sk_buff_->protocol = eth_type_trans(sk_buff_, device);
+	#ifdef LSINET_NAPI
+		return_code_ =  netif_receive_skb(sk_buff_);
+	#else
+		return_code_ = netif_rx(sk_buff_);
+	#endif
+
+		if (NET_RX_DROP == return_code_)
+			++dropped_by_stack_;
+	} else
+		dev_kfree_skb(sk_buff_);
+}
+
+static void
+lsinet_rx_skb(
+	struct net_device *device,
+	struct sk_buff *sk_buff_,
+	struct appnic_dma_descriptor_t *pdescriptor)
+{
+	struct appnic_device_t *adapter = netdev_priv(device);
+	unsigned bytes_copied_ = 0;
+	unsigned error_ = 0;
+	unsigned long ok_, overflow_, crc_, align_;
+
+	ok_ = read_mac_(APPNIC_RX_STAT_PACKET_OK(adapter));
+	overflow_ = read_mac_(APPNIC_RX_STAT_OVERFLOW(adapter));
+	crc_ = read_mac_(APPNIC_RX_STAT_CRC_ERROR(adapter));
+	align_ = read_mac_(APPNIC_RX_STAT_ALIGN_ERROR(adapter));
+
+	/* Copy the received packet into the skb.*/
+	while (0 < queue_initialized_(
+			SWAB_QUEUE_POINTER(adapter->rx_tail),
+			adapter->rx_tail_copy, adapter->rx_num_desc)) {
+		memcpy((void *) skb_put(sk_buff_, pdescriptor->pdu_length),
+			(void *)(pdescriptor->host_data_memory_pointer +
+					 adapter->dma_alloc_offset),
+			pdescriptor->pdu_length);
+
+		bytes_copied_ += pdescriptor->pdu_length;
+		pdescriptor->data_transfer_length = adapter->rx_buf_per_desc;
+		writedescriptor(((unsigned long) adapter->rx_desc +
+			adapter->rx_tail_copy.bits.offset),	pdescriptor);
+		if (0 != pdescriptor->error)
+			error_ = 1;
+
+		queue_increment_(&adapter->rx_tail_copy, adapter->rx_num_desc);
+		if (0 != pdescriptor->end_of_packet)
+			break;
+
+		readdescriptor(((unsigned long) adapter->rx_desc +
+			  adapter->rx_tail_copy.bits.offset), pdescriptor);
+	}
+
+	if (0 == pdescriptor->end_of_packet) {
+		ERROR_PRINT("No end of packet! %lu/%lu/%lu/%lu\n",
+				 ok_, overflow_, crc_, align_);
+		BUG();
+		dev_kfree_skb(sk_buff_);
+	} else {
+		if (0 == error_) {
+			lsinet_rx(device, sk_buff_, bytes_copied_);
+		} else {
+			dev_kfree_skb(sk_buff_);
+
+			if (0 != overflow_)
+				++adapter->stats.rx_fifo_errors;
+			else if (0 != crc_)
+				++adapter->stats.rx_crc_errors;
+			else if (0 != align_)
+				++adapter->stats.rx_frame_errors;
+		}
+	}
+}
+
+static void
+lsinet_rx_packet(struct net_device *device)
+{
+	struct appnic_device_t *adapter = netdev_priv(device);
+	struct appnic_dma_descriptor_t descriptor;
+	struct sk_buff *sk_buff_;
+
+	spin_lock(&adapter->extra_lock);
+	DEBUG_PRINT("head=0x%lx tail=0x%lx tail_copy=0x%lx\n",
+		     adapter->rx_head.raw, adapter->rx_tail->raw,
+		     adapter->rx_tail_copy.raw);
+	readdescriptor(((unsigned long) adapter->rx_desc +
+			adapter->rx_tail_copy.bits.offset), &descriptor);
+
+	sk_buff_ = dev_alloc_skb(1600);
+	if ((struct sk_buff *) 0 != sk_buff_)
+		lsinet_rx_skb(device, sk_buff_, &descriptor);
+	else
+		ERROR_PRINT("dev_alloc_skb() failed!	Dropping packet.\n");
+
+	DEBUG_PRINT("head=0x%lx tail=0x%lx tail_copy=0x%lx\n",
+		     adapter->rx_head.raw, adapter->rx_tail->raw,
+		     adapter->rx_tail_copy.raw);
+
+	spin_unlock(&adapter->extra_lock);
+
+	return;
+}
+
+/*
+  lsinet_rx_packets
+*/
+
+static int
+lsinet_rx_packets(struct net_device *device, int max)
+{
+	struct appnic_device_t *adapter = netdev_priv(device);
+	union appnic_queue_pointer_t queue;
+	int updated_head_pointer = 0;
+	int packets = 0;
+
+	queue.raw = adapter->rx_tail_copy.raw;
+
+	/* Receive Packets */
+
+	while (0 < queue_initialized_(SWAB_QUEUE_POINTER(adapter->rx_tail),
+				       queue, adapter->rx_num_desc)) {
+		struct appnic_dma_descriptor_t descriptor;
+
+		readdescriptor(((unsigned long) adapter->rx_desc +
+				  queue.bits.offset),
+				&descriptor);
+
+		if (0 != descriptor.end_of_packet) {
+			lsinet_rx_packet(device);
+			++packets;
+			queue.raw = adapter->rx_tail_copy.raw;
+
+			if (-1 != max)
+				if (packets == max)
+					break;
+
+		} else {
+			queue_increment_(&queue, adapter->rx_num_desc);
+		}
+	}
+
+	/* Update the Head Pointer */
+
+	while (1 < queue_uninitialized_(adapter->rx_head, adapter->rx_tail_copy,
+					 adapter->rx_num_desc)) {
+
+		struct appnic_dma_descriptor_t descriptor;
+
+		readdescriptor(((unsigned long) adapter->rx_desc +
+				  adapter->rx_head.bits.offset), &descriptor);
+		descriptor.data_transfer_length = adapter->rx_buf_per_desc;
+		descriptor.write = 1;
+		descriptor.pdu_length = 0;
+		descriptor.start_of_packet = 0;
+		descriptor.end_of_packet = 0;
+		descriptor.interrupt_on_completion = 1;
+		writedescriptor(((unsigned long) adapter->rx_desc +
+				   adapter->rx_head.bits.offset),
+				 &descriptor);
+		queue_increment_(&adapter->rx_head, adapter->rx_num_desc);
+		updated_head_pointer = 1;
+	}
+
+	if (0 != updated_head_pointer)
+		write_mac_(adapter->rx_head.raw,
+			APPNIC_DMA_RX_HEAD_POINTER(adapter));
+
+	return packets;
+}
+
+#ifdef LSINET_NAPI
+
+/* lsinet_poll */
+
+static int
+lsinet_poll(struct napi_struct *napi, int budget)
+{
+	struct appnic_device_t *adapter =
+		container_of(napi, struct appnic_device_t, napi);
+	struct net_device *device = adapter->device;
+	union appnic_queue_pointer_t queue_;
+
+	int cur_budget = budget;
+	int done;
+	unsigned long dma_interrupt_status_;
+
+	DEBUG_PRINT("head=0x%x tail=0x%x tail_copy=0x%x\n",
+		     adapter->rx_head.raw, adapter->rx_tail->raw,
+		     adapter->rx_tail_copy.raw);
+	queue_.raw = adapter->rx_tail_copy.raw;
+
+	done = 1;
+
+	do {
+		/* Acknowledge the RX interrupt. */
+		write_mac_(~APPNIC_DMA_INTERRUPT_ENABLE_RECEIVE,
+			   APPNIC_DMA_INTERRUPT_STATUS(adapter));
+
+		cur_budget -= lsinet_rx_packets(device, cur_budget);
+		if (0 == cur_budget)
+			break;
+
+		dma_interrupt_status_ =
+			read_mac_(APPNIC_DMA_INTERRUPT_STATUS(adapter));
+
+	} while ((RX_INTERRUPT(dma_interrupt_status_)) && cur_budget);
+
+	if (done) {
+		napi_complete(napi);
+		/* re-enable receive interrupts */
+		write_mac_((APPNIC_DMA_INTERRUPT_ENABLE_RECEIVE |
+			      APPNIC_DMA_INTERRUPT_ENABLE_TRANSMIT),
+			    APPNIC_DMA_INTERRUPT_ENABLE(adapter));
+	}
+
+	DEBUG_PRINT("head=0x%x tail=0x%x tail_copy=0x%x\n",
+		     adapter->rx_head.raw, adapter->rx_tail->raw,
+		     adapter->rx_tail_copy.raw);
+
+	return done ? 0 : 1;
+}
+
+#else /* Not using NAPI, define the Rx interrupt handler instead */
+
+/* handle_receive_interrupt_ */
+
+static void
+handle_receive_interrupt_(struct net_device *device)
+{
+	struct appnic_device_t *dev_ = netdev_priv(device);
+	union appnic_queue_pointer_t queue_;
+
+	DEBUG_PRINT("head=0x%lx tail=0x%lx tail_copy=0x%lx\n",
+		     dev_->rx_head.raw, dev_->rx_tail->raw,
+		     dev_->rx_tail_copy.raw);
+	queue_.raw = dev_->rx_tail_copy.raw;
+	lsinet_rx_packets(device, -1);
+	DEBUG_PRINT("head=0x%lx tail=0x%lx tail_copy=0x%lx\n",
+		     dev_->rx_head.raw, dev_->rx_tail->raw,
+		     dev_->rx_tail_copy.raw);
+	return;
+}
+#endif /* else not NAPI */
+
+/* appnic_isr_ */
+
+static irqreturn_t
+appnic_isr_(int irq, void *device_id)
+{
+	struct net_device *device_ = (struct net_device *) device_id;
+	struct appnic_device_t *adapter = netdev_priv(device_);
+	unsigned long dma_interrupt_status_;
+	unsigned long flags;
+
+	/* acquire the lock */
+	spin_lock_irqsave(&adapter->lock, flags);
+
+	/* get the status */
+	dma_interrupt_status_ = read_mac_(APPNIC_DMA_INTERRUPT_STATUS(adapter));
+#ifdef LSINET_NAPI
+	/* NAPI - don't ack RX interrupt */
+	write_mac_(APPNIC_DMA_INTERRUPT_ENABLE_RECEIVE,
+		APPNIC_DMA_INTERRUPT_STATUS(adapter));
+#else
+	write_mac_(0, APPNIC_DMA_INTERRUPT_STATUS(adapter));
+#endif
+
+	/* handle interrupts */
+
+	if (TX_INTERRUPT(dma_interrupt_status_)) {
+		/* transmition complete */
+		++transmit_interrupts_;
+		handle_transmit_interrupt_(device_);
+	}
+
+	if (RX_INTERRUPT(dma_interrupt_status_)) {
+		++receive_interrupts_;
+#ifdef LSINET_NAPI
+		if (napi_schedule_prep(&adapter->napi)) {
+			write_mac_(APPNIC_DMA_INTERRUPT_ENABLE_TRANSMIT,
+					APPNIC_DMA_INTERRUPT_ENABLE(adapter));
+			__napi_schedule(&adapter->napi);
+		} else {
+			write_mac_(APPNIC_DMA_INTERRUPT_ENABLE_TRANSMIT,
+					APPNIC_DMA_INTERRUPT_ENABLE(adapter));
+		}
+#else
+		/* receive complete */
+		handle_receive_interrupt_(device_);
+#endif
+	}
+
+	/* release the lock */
+	spin_unlock_irqrestore(&adapter->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+/*
+ * Polling receive - used by netconsole and other diagnostic tools
+ * to allow network i/o with interrupts disabled.
+ */
+static void appnic_poll_controller(struct net_device *dev)
+{
+	disable_irq(dev->irq);
+	appnic_isr_(dev->irq, dev);
+	enable_irq(dev->irq);
+}
+#endif
+
+/*
+  appnic_open
+
+  Opens the interface.	The interface is opened whenever ifconfig
+  activates it.	 The open method should register any system resource
+  it needs (I/O ports, IRQ, DMA, etc.) turn on the hardware, and
+  increment the module usage count.
+*/
+
+int
+appnic_open(struct net_device *device)
+{
+	int return_code_ = 0;
+	struct appnic_device_t *adapter = netdev_priv(device);
+
+	/* enable the receiver and transmitter */
+	if (0 != enable_(device)) {
+		ERROR_PRINT("Unable to enable the interface.\n");
+		disable_(device);
+		return -EBUSY;
+	}
+
+#ifdef LSINET_NAPI
+	napi_enable(&adapter->napi);
+#endif /* LSINET_NAPI */
+
+	/* install the interrupt handlers */
+	return_code_ = request_irq(adapter->irq, appnic_isr_, IRQF_DISABLED,
+				   device->name, device);
+	if (0 != return_code_) {
+		ERROR_PRINT("request_irq() failed, returned 0x%x/%d\n",
+			     return_code_, return_code_);
+		return return_code_;
+	}
+
+	/* enable interrupts */
+	write_mac_((APPNIC_DMA_INTERRUPT_ENABLE_RECEIVE |
+		      APPNIC_DMA_INTERRUPT_ENABLE_TRANSMIT),
+		    APPNIC_DMA_INTERRUPT_ENABLE(adapter));
+
+	/* Enable phy polling timer */
+	init_timer(&adapter->appnic_timer_);
+	adapter->appnic_timer_.expires =
+		jiffies + (APPNIC_TIMER_PERIOD * HZ);
+	adapter->appnic_timer_.data = (unsigned long) device;
+	adapter->appnic_timer_.function = appnic_timer_handler_;
+	add_timer(&adapter->appnic_timer_);
+
+	/* let the OS know we are ready to send packets */
+	netif_start_queue(device);
+
+	return 0;
+}
+
+/*
+  appnic_stop
+
+  Stops the interface.	The interface is stopped when it is broughht
+  down; operations performed at open time should be reversed.
+*/
+
+int
+appnic_stop(struct net_device *device)
+{
+	int return_code_ = 0;
+	struct appnic_device_t *adapter = netdev_priv(device);
+
+	DEBUG_PRINT("Stopping the interface.\n");
+	/*Indicate to the OS that no more packets should be sent.*/
+
+	netif_stop_queue(device);
+
+	/*Stop the receiver and transmitter.*/
+	disable_(device);
+
+#ifdef LSINET_NAPI
+	/* Disable NAPI. */
+	napi_disable(&adapter->napi);
+#endif
+
+	/* Free the interrupts.	*/
+	free_irq(device->irq, device);
+
+	/* Stop phy polling timer. */
+	del_timer(&adapter->appnic_timer_);
+
+	return return_code_;
+}
+
+/*
+  appnic_hard_start_xmit
+
+  The method initiates the transmission of a packet.  The full packet
+  (protocol headers and all) is contained in a socket buffer (sk_buff)
+  structure.
+
+  ----- NOTES -----
+
+  1) This will not get called again by the kernel until it returns.
+*/
+
+int
+appnic_hard_start_xmit(struct sk_buff *skb,
+			struct net_device *device)
+{
+	struct appnic_device_t *adapter = netdev_priv(device);
+	int length_;
+	int buf_per_desc_;
+	unsigned long flags;
+
+	appnic_special_lock(&adapter->lock, flags);
+	length_ = skb->len < ETH_ZLEN ? ETH_ZLEN : skb->len;
+	buf_per_desc_ = adapter->tx_buf_sz / adapter->tx_num_desc;
+
+	/*
+	  If enough transmit descriptors are available, copy and transmit.
+	*/
+
+	DEBUG_PRINT("length_=%d buf_per_desc_=%d tx_tail=0x%x\n",
+		     length_, buf_per_desc_, swab32(adapter->tx_tail->raw));
+
+	while (((length_ / buf_per_desc_) + 1) >=
+	       queue_uninitialized_(adapter->tx_head,
+				     SWAB_QUEUE_POINTER(adapter->tx_tail),
+				     adapter->tx_num_desc)) {
+		udelay(1000);
+		handle_transmit_interrupt_(device);
+	}
+
+	if (((length_ / buf_per_desc_) + 1) <
+	    queue_uninitialized_(
+			adapter->tx_head,
+			SWAB_QUEUE_POINTER(adapter->tx_tail),
+			adapter->tx_num_desc)) {
+		int bytes_copied_ = 0;
+		struct appnic_dma_descriptor_t descriptor;
+
+		readdescriptor(((unsigned long) adapter->tx_desc +
+				  adapter->tx_head.bits.offset), &descriptor);
+		descriptor.start_of_packet = 1;
+
+		while (bytes_copied_ < length_) {
+			descriptor.write = 1;
+			descriptor.pdu_length = length_;
+
+			if ((length_ - bytes_copied_) > buf_per_desc_) {
+				memcpy(
+					(void *)
+					(descriptor.host_data_memory_pointer
+						+ adapter->dma_alloc_offset),
+					(void *)((unsigned long) skb->data +
+						bytes_copied_),
+					buf_per_desc_);
+				descriptor.data_transfer_length = buf_per_desc_;
+				descriptor.end_of_packet = 0;
+				descriptor.interrupt_on_completion = 0;
+				bytes_copied_ += buf_per_desc_;
+			} else {
+				memcpy(
+					(void *)
+					(descriptor.host_data_memory_pointer
+						+ adapter->dma_alloc_offset),
+					(void *)((unsigned long) skb->data +
+						bytes_copied_),
+					(length_ - bytes_copied_));
+				descriptor.data_transfer_length =
+					(length_ - bytes_copied_);
+				descriptor.end_of_packet = 1;
+#ifdef DISABLE_TX_INTERRUPTS
+				descriptor.interrupt_on_completion = 0;
+#else  /* DISABLE_TX_INTERRUPTS */
+				descriptor.interrupt_on_completion = 1;
+#endif /* DISABLE_TX_INTERRUPTS */
+				bytes_copied_ = length_;
+			}
+
+			adapter->stats.tx_bytes += bytes_copied_;
+			writedescriptor(
+				((unsigned long) adapter->tx_desc +
+					adapter->tx_head.bits.offset),
+				&descriptor);
+			queue_increment_(&adapter->tx_head,
+				adapter->tx_num_desc);
+			readdescriptor(
+				((unsigned long) adapter->tx_desc +
+					adapter->tx_head.bits.offset),
+				&descriptor);
+			descriptor.start_of_packet = 0;
+		}
+
+		write_mac_(adapter->tx_head.raw,
+			APPNIC_DMA_TX_HEAD_POINTER(adapter));
+		device->trans_start = jiffies;
+	} else {
+		++out_of_tx_descriptors_;
+		ERROR_PRINT("No transmit descriptors available!\n");
+	}
+
+	/* free the socket buffer */
+	dev_kfree_skb(skb);
+	appnic_special_unlock(&adapter->lock, flags);
+
+	return 0;
+}
+
+/*
+  appnic_tx_timeout
+
+  This method is called when a packet transmission fails to complete
+  within a resonable period, on the assumption that an interrupt has
+  been missed or the interface has locked up.  It should handle the
+  problem and resume packet transmission.
+*/
+
+void
+appnic_tx_timeout(struct net_device *device)
+{
+	struct appnic_device_t *adapter = netdev_priv(device);
+
+	WARN_PRINT("Transmission timed out!\n");
+
+	if (0 == queue_initialized_(
+		SWAB_QUEUE_POINTER(adapter->tx_tail),
+		adapter->tx_tail_copy,
+		adapter->tx_num_desc)) {
+		/*
+		  If tx_tail is still the same as tx_tail_copy
+		  then restart the transmission.
+		*/
+
+		write_mac_(adapter->tx_head.raw,
+			APPNIC_DMA_TX_HEAD_POINTER(adapter));
+	} else {
+		/* If tx_tail has moved on, just increment tx_tail_copy. */
+		struct appnic_dma_descriptor_t descriptor;
+
+		readdescriptor(
+			((unsigned long) adapter->tx_desc +
+			adapter->tx_tail_copy.bits.offset),
+			&descriptor);
+		adapter->stats.tx_bytes += descriptor.pdu_length;
+		kfree((void *) descriptor.host_data_memory_pointer);
+		queue_increment_(&adapter->tx_tail_copy, adapter->tx_num_desc);
+	}
+
+	return;
+
+}
+
+/*
+  appnic_net_device_stats
+
+  Whenever an application needs to get statistics for the interface,
+  this method is called.  This happens, for example, when ifconfig or
+  nstat -i is run.
+*/
+
+struct net_device_stats *
+appnic_get_stats(struct net_device *device)
+{
+	struct appnic_device_t *device_ = netdev_priv(device);
+
+	/*
+	  Update the statistics structure.
+	*/
+
+	get_hw_statistics_(device_);
+
+	return &device_->stats;
+}
+
+/*
+  appnic_set_mac_address
+*/
+
+static int
+appnic_set_mac_address(struct net_device *device, void *data) {
+
+	struct sockaddr *address_ = data;
+	unsigned long swap_source_address_;
+	struct appnic_device_t *adapter = netdev_priv(device);
+
+	if (netif_running(device))
+		return -EBUSY;
+
+	device->addr_len = 6;
+
+	DEBUG_PRINT("Setting MAC to %02x:%02x:%02x:%02x:%02x:%02x\n",
+		     address_->sa_data[0], address_->sa_data[1],
+		     address_->sa_data[2], address_->sa_data[3],
+		     address_->sa_data[4], address_->sa_data[5]);
+
+	memcpy(device->dev_addr, address_->sa_data, 6);
+	memcpy(device->perm_addr, address_->sa_data, 6);
+
+	swap_source_address_ =
+		((address_->sa_data[4]) << 8) | address_->sa_data[5];
+	write_mac_(swap_source_address_, APPNIC_SWAP_SOURCE_ADDRESS_2(adapter));
+	swap_source_address_ =
+		((address_->sa_data[2]) << 8) | address_->sa_data[3];
+	write_mac_(swap_source_address_, APPNIC_SWAP_SOURCE_ADDRESS_1(adapter));
+	swap_source_address_ =
+		((address_->sa_data[0]) << 8) | address_->sa_data[1];
+	write_mac_(swap_source_address_, APPNIC_SWAP_SOURCE_ADDRESS_0(adapter));
+	memcpy(device->dev_addr, address_->sa_data, device->addr_len);
+
+	return 0;
+}
+
+/*
+  ETHTOOL Operations
+*/
+
+/* appnic_get_settings */
+
+static int
+appnic_get_settings(struct net_device *device, struct ethtool_cmd *command)
+{
+	unsigned long flags;
+	struct appnic_device_t *adapter = netdev_priv(device);
+
+	memset(command, 0, sizeof(struct ethtool_cmd));
+
+	/* What the hardware supports. */
+	command->supported =
+		(SUPPORTED_10baseT_Half |
+		  SUPPORTED_10baseT_Full |
+		  SUPPORTED_100baseT_Half |
+		  SUPPORTED_100baseT_Full);
+
+	/* Acquire the device lock. */
+	appnic_special_lock(&adapter->lock, flags);
+
+	/* What is currently advertised. */
+	{
+		unsigned short ad_value_;
+
+		if (0 != phy_read_(adapter,
+			PHY_AUTONEG_ADVERTISE, &ad_value_)) {
+			ERROR_PRINT("PHY read failed!");
+			appnic_special_unlock(&adapter->lock, flags);
+			return -EIO;
+		}
+
+		switch (ad_value_) {
+		case 0x1e1:
+			command->advertising =
+				(ADVERTISED_100baseT_Full |
+				ADVERTISED_100baseT_Half |
+				ADVERTISED_10baseT_Full |
+				ADVERTISED_10baseT_Half);
+			break;
+
+		case 0xe1:
+			command->advertising =
+				(ADVERTISED_100baseT_Half |
+				ADVERTISED_10baseT_Full |
+				ADVERTISED_10baseT_Half);
+			break;
+
+		case 0x61:
+			command->advertising =
+				(ADVERTISED_10baseT_Full |
+				ADVERTISED_10baseT_Half);
+			break;
+
+		case 0x41:
+			command->advertising =
+				(ADVERTISED_10baseT_Half);
+			break;
+
+		default:
+			break;
+
+		}
+	}
+	/* The current speed. */
+
+	{
+		int speed_;
+
+		speed_ = phy_speed_(adapter);
+		if (-1 == speed_) {
+			ERROR_PRINT("PHY read failed!");
+			appnic_special_unlock(&adapter->lock, flags);
+			return -EIO;
+		}
+
+		if (1 == speed_)
+			command->speed = SPEED_100;
+		else
+			command->speed = SPEED_10;
+	}
+
+	/* Is the current link duplex? */
+	{
+		int duplex_;
+		duplex_ = phy_duplex_(adapter);
+		if (-1 == duplex_) {
+			ERROR_PRINT("PHY read failed!");
+			appnic_special_unlock(&adapter->lock, flags);
+			return -EIO;
+		}
+		if (1 == duplex_)
+			command->duplex = DUPLEX_FULL;
+		else
+			command->duplex = DUPLEX_HALF;
+	}
+
+	command->autoneg = AUTONEG_ENABLE;
+
+	/* Unlock and return success. */
+	appnic_special_unlock(&adapter->lock, flags);
+
+	return 0;
+}
+
+static const struct ethtool_ops appnic_ethtool_ops = {
+	.get_settings = appnic_get_settings
+};
+
+/*
+  Linux Module Interface.
+*/
+
+static const struct net_device_ops appnic_netdev_ops = {
+	.ndo_open = appnic_open,
+	.ndo_stop = appnic_stop,
+	.ndo_get_stats = appnic_get_stats,
+	.ndo_set_mac_address = appnic_set_mac_address,
+	.ndo_start_xmit = appnic_hard_start_xmit,
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	.ndo_poll_controller	= appnic_poll_controller,
+#endif
+};
+
+static int
+appnic_macaddr_init(struct net_device *device)
+{
+	struct sockaddr address_;
+#ifdef CONFIG_LSI_UBOOTENV
+	unsigned char ethaddr_string_[40];
+#endif
+
+#ifdef CONFIG_LSI_UBOOTENV
+	if (0 != ubootenv_get("ethaddr", ethaddr_string_)) {
+		WARN_PRINT("Could not read ethernet address!\n");
+#endif
+		memcpy(address_.sa_data, APPNIC_DEFAULT_MAC, 6);
+
+#ifdef CONFIG_LSI_UBOOTENV
+	} else {
+		char *string_;
+		int index_ = 0;
+
+		string_ = ethaddr_string_;
+		while ((0 != string_) && (6 > index_)) {
+			char *value_;
+			value_ = strsep(&string_, ":");
+			address_.sa_data[index_++] =
+				simple_strtoul(value_, NULL, 16);
+		}
+	}
+#endif
+
+	return appnic_set_mac_address(device, &address_);
+}
+
+static void
+appnic_descriptor_init(struct appnic_device_t *adapter)
+{
+	int index_;
+	unsigned long buf_;
+	struct appnic_dma_descriptor_t descriptor;
+
+	buf_ = (unsigned long) adapter->rx_buf_dma;
+	for (index_ = 0; index_ < adapter->rx_num_desc; ++index_) {
+		memset((void *) &descriptor, 0,
+			sizeof(struct appnic_dma_descriptor_t));
+		descriptor.write = 1;
+		descriptor.interrupt_on_completion = 1;
+		descriptor.host_data_memory_pointer = buf_;
+		descriptor.data_transfer_length = adapter->rx_buf_per_desc;
+		writedescriptor(
+			((unsigned long) adapter->rx_desc +
+			(index_ * sizeof(struct appnic_dma_descriptor_t))),
+			&descriptor);
+		buf_ += adapter->rx_buf_per_desc;
+	}
+
+	buf_ = (unsigned long) adapter->tx_buf_dma;
+	for (index_ = 0; index_ < adapter->tx_num_desc; ++index_) {
+		memset((void *) &descriptor, 0,
+			sizeof(struct appnic_dma_descriptor_t));
+		descriptor.write = 1;
+		descriptor.interrupt_on_completion = 1;
+		descriptor.host_data_memory_pointer = buf_;
+		writedescriptor(
+			((unsigned long) adapter->tx_desc +
+			(index_ * sizeof(struct appnic_dma_descriptor_t))),
+			&descriptor);
+		buf_ += adapter->tx_buf_per_desc;
+	}
+}
+
+static int
+appnic_mem_init(struct net_device *device)
+{
+/* Allocate memory and initialize the descriptors*/
+	struct appnic_device_t *adapter = netdev_priv(device);
+	void *dma_offset_;
+
+	/*  fixup num_[rt]x_desc*/
+	if (0 != (rx_num_desc % DESCRIPTOR_GRANULARITY)) {
+		WARN_PRINT("rx_num_desc was not a multiple of %d.\n",
+				DESCRIPTOR_GRANULARITY);
+		rx_num_desc += DESCRIPTOR_GRANULARITY -
+			(rx_num_desc % DESCRIPTOR_GRANULARITY);
+	}
+	adapter->rx_num_desc = rx_num_desc;
+
+	if (0 != (tx_num_desc % DESCRIPTOR_GRANULARITY)) {
+		WARN_PRINT("tx_num_desc was not a multiple of %d.\n",
+				DESCRIPTOR_GRANULARITY);
+		tx_num_desc += DESCRIPTOR_GRANULARITY -
+			(tx_num_desc % DESCRIPTOR_GRANULARITY);
+	}
+	adapter->tx_num_desc = tx_num_desc;
+
+	DEBUG_PRINT("rx_num_desc=%d tx_num_desc=%d\n",
+		rx_num_desc, tx_num_desc);
+
+	/*Fix up[rt]x_buf_sz.Must be some multiple of 64 bytes per descriptor.*/
+
+	if (0 != (rx_buf_sz % (BUFFER_ALIGNMENT * rx_num_desc))) {
+		WARN_PRINT("rx_buf_sz was not a multiple of %d.\n",
+				(BUFFER_ALIGNMENT * rx_num_desc));
+		rx_buf_sz += (BUFFER_ALIGNMENT * rx_num_desc) -
+			(rx_buf_sz % (BUFFER_ALIGNMENT * rx_num_desc));
+	}
+	adapter->rx_buf_sz = rx_buf_sz;
+
+	if (0 != (tx_buf_sz % (BUFFER_ALIGNMENT * tx_num_desc))) {
+		WARN_PRINT("tx_buf_sz was not a multiple of %d.\n",
+				(BUFFER_ALIGNMENT * tx_num_desc));
+		tx_buf_sz +=
+			(BUFFER_ALIGNMENT * tx_num_desc) -
+			(tx_buf_sz % (BUFFER_ALIGNMENT * tx_num_desc));
+	}
+	adapter->tx_buf_sz = tx_buf_sz;
+	DEBUG_PRINT("rx_buf_sz=%d tx_buf_sz=%d\n", rx_buf_sz, tx_buf_sz);
+
+	/*  Allocate dma-able memory*/
+	adapter->dma_alloc_size =
+		/* The tail pointers (rx and tx) */
+		(sizeof(union appnic_queue_pointer_t) * 2) +
+		/* The RX descriptor ring (and padding to allow
+		   64 byte alignment) */
+		(sizeof(struct appnic_dma_descriptor_t) *
+		  adapter->rx_num_desc) +
+		(DESCRIPTOR_GRANULARITY) +
+		/* The TX descriptor ring (and padding...) */
+		(sizeof(struct appnic_dma_descriptor_t) *
+		  adapter->tx_num_desc) +
+		(DESCRIPTOR_GRANULARITY) +
+		/* The RX buffer (and padding...) */
+		(adapter->rx_buf_sz) + (BUFFER_ALIGNMENT) +
+		/* The TX buffer (and padding...) */
+		(adapter->tx_buf_sz) + (BUFFER_ALIGNMENT);
+
+	device->dev.archdata.dma_ops = &dma_direct_ops;
+	adapter->dma_alloc = (void *)
+		dma_alloc_coherent(&device->dev, adapter->dma_alloc_size,
+				   &adapter->dma_alloc_dma,
+				   GFP_KERNEL);
+	if ((void *) 0 == adapter->dma_alloc) {
+		ERROR_PRINT("Could not allocate %d bytes of DMA-able memory!\n",
+				 adapter->dma_alloc_size);
+		return -ENOMEM;
+	}
+
+	adapter->dma_alloc_offset =
+		(int) adapter->dma_alloc - (int) adapter->dma_alloc_dma;
+	dma_offset_ = adapter->dma_alloc;
+	DEBUG_PRINT("Allocated %d bytes at 0x%08lx(0x%08lx), "
+			 "offset=0x%x.\n",
+			 adapter->dma_alloc_size,
+			 (unsigned long) adapter->dma_alloc,
+			 (unsigned long) adapter->dma_alloc_dma,
+			 adapter->dma_alloc_offset);
+
+	/* Initialize the tail pointers */
+	adapter->rx_tail = (union appnic_queue_pointer_t *) dma_offset_;
+	adapter->rx_tail_dma =
+		(int) adapter->rx_tail - (int) adapter->dma_alloc_offset;
+	dma_offset_ += sizeof(union appnic_queue_pointer_t);
+	memset((void *) adapter->rx_tail, 0,
+		sizeof(union appnic_queue_pointer_t));
+	DEBUG_PRINT("rx_tail=0x%08lx\n", (unsigned long) adapter->rx_tail);
+
+	adapter->tx_tail = (union appnic_queue_pointer_t *) dma_offset_;
+	adapter->tx_tail_dma =
+		(int) adapter->tx_tail - (int) adapter->dma_alloc_offset;
+	dma_offset_ += sizeof(union appnic_queue_pointer_t);
+	memset((void *) adapter->tx_tail, 0,
+		sizeof(union appnic_queue_pointer_t));
+	DEBUG_PRINT("tx_tail=0x%08lx\n", (unsigned long) adapter->tx_tail);
+
+	/* Initialize the descriptor pointers*/
+
+	adapter->rx_desc =
+		(struct appnic_dma_descriptor_t *)ALIGN64B(dma_offset_);
+	DEBUG_PRINT("rx_desc=0x%08lx\n", (unsigned long) adapter->rx_desc);
+
+	adapter->rx_desc_dma =
+		(int) adapter->rx_desc - (int) adapter->dma_alloc_offset;
+	dma_offset_ +=
+		(sizeof(struct appnic_dma_descriptor_t) *
+		adapter->rx_num_desc) +	(DESCRIPTOR_GRANULARITY);
+	memset((void *) adapter->rx_desc, 0,
+		(sizeof(struct appnic_dma_descriptor_t) *
+		adapter->rx_num_desc));
+
+	adapter->tx_desc =
+		(struct appnic_dma_descriptor_t *)ALIGN64B(dma_offset_);
+	DEBUG_PRINT("tx_desc=0x%08lx\n", (unsigned long) adapter->tx_desc);
+
+	adapter->tx_desc_dma =
+		(int) adapter->tx_desc - (int) adapter->dma_alloc_offset;
+	dma_offset_ +=
+		(sizeof(struct appnic_dma_descriptor_t) *
+		adapter->tx_num_desc) + (DESCRIPTOR_GRANULARITY);
+	memset((void *) adapter->tx_desc, 0,
+		(sizeof(struct appnic_dma_descriptor_t) *
+		adapter->tx_num_desc));
+
+	/* Initialize the buffer pointers */
+	DEBUG_PRINT("Initializing the RX buffer pointers,"
+		"dma_offset=0x%lx/0x%lx\n",
+		(unsigned long) dma_offset_,
+		(unsigned long) ALIGN64B(dma_offset_));
+	adapter->rx_buf = (void *) ALIGN64B(dma_offset_);
+	adapter->rx_buf_dma =
+		(int) adapter->rx_buf - (int) adapter->dma_alloc_offset;
+	adapter->rx_buf_per_desc = adapter->rx_buf_sz / adapter->rx_num_desc;
+
+	dma_offset_ += (adapter->rx_buf_sz) + (BUFFER_ALIGNMENT);
+
+	DEBUG_PRINT("Initializing the TX buffer pointers,"
+		"dma_offset=0x%lx/0x%lx\n",
+		 (unsigned long) dma_offset_,
+		 (unsigned long) ALIGN64B(dma_offset_));
+	adapter->tx_buf = (void *) ALIGN64B(dma_offset_);
+	adapter->tx_buf_dma =
+		(int) adapter->tx_buf - (int) adapter->dma_alloc_offset;
+	adapter->tx_buf_per_desc = adapter->tx_buf_sz / adapter->tx_num_desc;
+	dma_offset_ += (adapter->tx_buf_sz) + (BUFFER_ALIGNMENT);
+
+	appnic_descriptor_init(adapter);
+
+	return 0;
+}
+
+/*
+  appnic_init
+*/
+static int appnic_init(struct net_device *device)
+{
+	struct appnic_device_t *adapter = netdev_priv(device);
+	int rc = 0;
+
+	/* Reset the MAC*/
+	write_mac_(0x80000000, APPNIC_DMA_PCI_CONTROL(adapter));
+
+	rc = appnic_mem_init(device);
+	if (rc < 0)
+		return rc;
+
+	/*  Initialize the spin lock.	*/
+	spin_lock_init(&adapter->lock);
+	spin_lock_init(&adapter->extra_lock);
+	spin_lock_init(&adapter->mdio_lock);
+
+	/* Take MAC out of reset */
+	DEBUG_PRINT("Enabling the MAC");
+	write_mac_(0x0, APPNIC_RX_SOFT_RESET(adapter));
+	write_mac_(0x1, APPNIC_RX_MODE(adapter));
+	write_mac_(0x0, APPNIC_TX_SOFT_RESET(adapter));
+	write_mac_(0x1, APPNIC_TX_MODE(adapter));
+	write_mac_(0x300a, APPNIC_TX_WATERMARK(adapter));
+	write_mac_(0x1, APPNIC_TX_HALF_DUPLEX_CONF(adapter));
+	write_mac_(0xffff, APPNIC_TX_TIME_VALUE_CONF(adapter));
+	write_mac_(0x1, APPNIC_TX_INTERRUPT_CONTROL(adapter));
+	write_mac_(0x5275, APPNIC_TX_EXTENDED_CONF(adapter));
+	write_mac_(0x1, APPNIC_RX_INTERNAL_INTERRUPT_CONTROL(adapter));
+	write_mac_(0x1, APPNIC_RX_EXTERNAL_INTERRUPT_CONTROL(adapter));
+	write_mac_(0x40010000, APPNIC_DMA_PCI_CONTROL(adapter));
+	write_mac_(0x30000, APPNIC_DMA_CONTROL(adapter));
+	writeio(0x280044, APPNIC_DMA_DTPA_LOW(adapter));
+	writeio(0xc0, APPNIC_DMA_DTPA_HIGH(adapter));
+
+	/* Set the MAC address */
+	rc = appnic_macaddr_init(device);
+	if (rc < 0)
+		return rc;
+
+	/*  Receiver	*/
+	memset((void *) &adapter->rx_tail_copy,
+		0, sizeof(union appnic_queue_pointer_t));
+	memset((void *) &adapter->rx_head,
+		0, sizeof(union appnic_queue_pointer_t));
+
+	write_mac_(adapter->rx_desc_dma,
+			APPNIC_DMA_RX_QUEUE_BASE_ADDRESS(adapter));
+	write_mac_((adapter->rx_num_desc *
+			  sizeof(struct appnic_dma_descriptor_t)) / 1024,
+			APPNIC_DMA_RX_QUEUE_SIZE(adapter));
+	/* indicate that all of the receive descriptors are ready */
+	adapter->rx_head.bits.offset =
+		(adapter->rx_num_desc - 1) *
+		sizeof(struct appnic_dma_descriptor_t);
+	write_mac_(adapter->rx_tail_dma,
+			APPNIC_DMA_RX_TAIL_POINTER_ADDRESS(adapter));
+
+	DEBUG_PRINT("Initializing the RX tail: "
+		"adapter=0x%lx\n", (unsigned long) adapter);
+	DEBUG_PRINT("Initializing the RX tail: "
+		"adapter->rx_tail=0x%lx\n", (unsigned long) adapter->rx_tail);
+	DEBUG_PRINT("Initializing the RX tail: "
+		"adapter->rx_tail->raw=0x%lx\n",
+		(unsigned long) adapter->rx_tail->raw);
+	adapter->rx_tail->raw =
+		read_mac_(APPNIC_DMA_RX_TAIL_POINTER_LOCAL_COPY(adapter));
+	adapter->rx_tail_copy.raw = adapter->rx_tail->raw;
+	adapter->rx_head.raw = adapter->rx_tail->raw;
+	queue_decrement_(&adapter->rx_head, adapter->rx_num_desc);
+	adapter->rx_head.bits.generation_bit =
+		(0 == adapter->rx_head.bits.generation_bit) ? 1 : 0;
+	write_mac_(adapter->rx_head.raw, APPNIC_DMA_RX_HEAD_POINTER(adapter));
+
+	/*  Transmitter	*/
+	memset((void *) &adapter->tx_tail_copy,
+		0, sizeof(union appnic_queue_pointer_t));
+	memset((void *) &adapter->tx_head,
+		0, sizeof(union appnic_queue_pointer_t));
+
+	write_mac_(adapter->tx_desc_dma,
+		APPNIC_DMA_TX_QUEUE_BASE_ADDRESS(adapter));
+	write_mac_(
+		(adapter->tx_num_desc * sizeof(struct appnic_dma_descriptor_t))
+		/ 1024,
+		APPNIC_DMA_TX_QUEUE_SIZE(adapter));
+	DEBUG_PRINT("Writing 0x%lx to APPNIC_DMA_TX_TAIL_POINTER_ADDRESS\n",
+		(unsigned long) adapter->tx_tail_dma);
+	write_mac_(adapter->tx_tail_dma,
+			APPNIC_DMA_TX_TAIL_POINTER_ADDRESS(adapter));
+	DEBUG_PRINT("Initializing the TX tail pointer at 0x%lx/0x%lx.\n",
+			 (unsigned long) adapter->tx_tail,
+			 (unsigned long) adapter->tx_tail->raw);
+	adapter->tx_tail->raw =
+		read_mac_(APPNIC_DMA_TX_TAIL_POINTER_LOCAL_COPY(adapter));
+	adapter->tx_tail_copy.raw = adapter->tx_tail->raw;
+	adapter->tx_head.raw = adapter->tx_tail->raw;
+	write_mac_(adapter->tx_head.raw, APPNIC_DMA_TX_HEAD_POINTER(adapter));
+
+	/* clear statistics */
+	clear_statistics_(adapter);
+
+	/* initialize the PHY */
+	if (0 != phy_enable_(adapter))
+		WARN_PRINT("Failed to initialize the PHY!\n");
+
+	/* fill in the net_device structure */
+	DEBUG_PRINT("Filling in the device structure.\n");
+	ether_setup(device);
+
+	device->netdev_ops = &appnic_netdev_ops;
+	SET_ETHTOOL_OPS(device, &appnic_ethtool_ops);
+
+#ifdef LSINET_NAPI
+	memset((void *) &adapter->napi, 0, sizeof(struct napi_struct));
+	netif_napi_add(device, &adapter->napi, lsinet_poll, LSINET_NAPI_WEIGHT);
+	adapter->device = device;
+#endif
+
+	return 0;
+}
+
+/*  lsinet_init */
+
+static int __init appnic_probe(struct of_device *ofdev,
+	const struct of_device_id *match)
+{
+	int rc = 0;
+	struct net_device *device;
+	struct appnic_device_t *adapter;
+
+	/* Allocate space for the device. */
+	device = alloc_etherdev(sizeof(struct appnic_device_t));
+
+	if ((struct net_device *)0 == device) {
+		ERROR_PRINT("Couldn't allocate net device.");
+		rc = -ENOMEM;
+		goto out;
+	}
+	/* Get device resource from of node. */
+	adapter = netdev_priv(device);
+	adapter->irq = of_irq_to_resource(ofdev->node, 0, NULL);
+	if (adapter->irq == NO_IRQ) {
+		ERROR_PRINT("failed to get irq resource\n");
+		rc = -ENODEV;
+		goto err_free_dev;
+	}
+
+	adapter->reg = of_iomap(ofdev->node, 0);
+	if (!adapter->reg) {
+		ERROR_PRINT("IO remap io space failed.\n");
+		rc = -ENOMEM;
+		goto err_free_dev;
+	}
+
+	adapter->mdioreg = of_iomap(ofdev->node, 1);
+	if (!adapter->mdioreg) {
+		ERROR_PRINT("IO remap mdio space failed.\n");
+		rc = -ENOMEM;
+		goto err_unmap;
+	}
+
+	/* Initialize the device. */
+	rc = appnic_init(device);
+	if (0 != rc) {
+		ERROR_PRINT("appnic_init() failed: %d\n", rc);
+		rc = -ENODEV;
+		goto err_unmap_mdio;
+	}
+
+	strcpy(device->name, "eth%d");
+
+	/* Register the device. */
+	rc = register_netdev(device);
+	if (0 != rc) {
+		ERROR_PRINT("register_netdev() failed: %d\n", rc);
+		rc = -ENODEV;
+		goto err_unmap_mdio;
+	}
+	dev_set_drvdata(&ofdev->dev, device);
+	return 0;
+
+err_unmap_mdio:
+	iounmap(adapter->mdioreg);
+err_unmap:
+	iounmap(adapter->reg);
+err_free_dev:
+	free_netdev(device);
+out:
+	return rc;
+}
+
+/* lsinet_cleanup */
+void __exit appnic_remove(struct of_device *ofdev)
+{
+	struct net_device *device = dev_get_drvdata(&ofdev->dev);
+	struct appnic_device_t *adapter = netdev_priv(device);
+
+	iounmap(adapter->reg);
+	iounmap(adapter->mdioreg);
+
+	unregister_netdev(device);
+	return;
+}
+
+static struct of_device_id acpnic_match[] = {
+	{
+		.compatible = "lsi-acpnic",
+	},
+	{ /* end of list */ },
+};
+
+static struct of_platform_driver appnic_drv = {
+	.name = "appnic",
+	.probe		= appnic_probe,
+	.remove		= __exit_p(appnic_remove),
+	.match_table = acpnic_match,
+};
+
+static int __init lsinet_init(void)
+{
+	return of_register_platform_driver(&appnic_drv);
+}
+
+static void __exit lsinet_exit(void)
+{
+	of_unregister_platform_driver(&appnic_drv);
+}
+
+module_init(lsinet_init);
+module_exit(lsinet_exit);
-- 
1.7.0.5

