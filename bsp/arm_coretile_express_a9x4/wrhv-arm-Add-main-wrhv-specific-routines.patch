From 629dc90ff7983a92fc456a296c26f8f80c0f6c5a Mon Sep 17 00:00:00 2001
From: Jim Somerville <Jim.Somerville@windriver.com>
Date: Wed, 3 Aug 2011 13:37:32 -0400
Subject: [PATCH 08/10] wrhv: arm:  Add main wrhv specific routines

Contains the paravirt non-native implementations.

Signed-off-by: Jim Somerville <Jim.Somerville@windriver.com>
---
 arch/arm/include/asm/wrhv.h  |   31 ++++
 arch/arm/kernel/vbi/Makefile |    2 +-
 arch/arm/kernel/vbi/util.c   |   67 +++++++++
 arch/arm/kernel/vbi/wrhv.c   |  318 ++++++++++++++++++++++++++++++++++++++++++
 4 files changed, 417 insertions(+), 1 deletions(-)
 create mode 100644 arch/arm/include/asm/wrhv.h
 create mode 100644 arch/arm/kernel/vbi/util.c
 create mode 100644 arch/arm/kernel/vbi/wrhv.c

diff --git a/arch/arm/include/asm/wrhv.h b/arch/arm/include/asm/wrhv.h
new file mode 100644
index 0000000..f3a1e1b
--- /dev/null
+++ b/arch/arm/include/asm/wrhv.h
@@ -0,0 +1,31 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by the
+ *  Free Software Foundation; either version 2, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  Copyright (C) 2011 Wind River Systems, Inc.
+ */
+
+#ifndef __ARM_ASM_WRHV_H
+#define __ARM_ASM_WRHV_H
+
+#ifdef CONFIG_WRHV
+
+#ifndef __ASSEMBLY__
+
+#include <vbi/vmmu.h>
+
+extern void wrhv_time_init(void);
+extern VMMU_CONFIG vmmu_cfg;
+extern void wrhv_init_irq(void);
+extern void *wrhv_machine_init_irq;
+
+#endif /* __ASSEMBLY__ */
+#endif /* CONFIG_WRHV */
+#endif /* __ARM_ASM_WRHV_H */
diff --git a/arch/arm/kernel/vbi/Makefile b/arch/arm/kernel/vbi/Makefile
index 6639318..ab54d86 100644
--- a/arch/arm/kernel/vbi/Makefile
+++ b/arch/arm/kernel/vbi/Makefile
@@ -2,4 +2,4 @@
 # Makefile for the vbi arm.
 #
 
-obj-y		:= syscalls.o wrhv.o show.o
+obj-y		:= syscalls.o wrhv.o show.o util.o
diff --git a/arch/arm/kernel/vbi/util.c b/arch/arm/kernel/vbi/util.c
new file mode 100644
index 0000000..c44f5f7
--- /dev/null
+++ b/arch/arm/kernel/vbi/util.c
@@ -0,0 +1,67 @@
+/*
+ * util.c - utilities routines for guest OS para-virtualization
+ *
+ * Copyright (c) 2011 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ */
+
+#include <asm/page.h>
+#include <linux/module.h>
+#include <vbi/interface.h>
+#include <vbi/vmmu.h>
+#include <vbi/syscall.h>
+#include <vbi/vbi.h>
+
+extern struct vb_config *wr_config;
+extern struct vb_status *wr_status;
+extern struct vb_control *wr_control;
+
+VMMU_CONFIG vmmu_cfg;
+
+/*
+ * vb_memsize_get should not be called before wr_config is initialized
+ */
+unsigned int vb_memsize_get(void)
+{
+	if (wr_config == (struct vb_config *)(-1))
+		return 0;
+	return VBI_MEM_SIZE_GET();
+}
+
+unsigned int vb_context_get(void)
+{
+	if (wr_config == (struct vb_config *)(-1))
+		return 0xbadc0de0;
+	return VBI_CONTEXT_ID_GET();
+}
+
+void vb__flush_dcache_icache(void *start)
+{
+	vbi_flush_icache(start, PAGE_SIZE);
+	vbi_flush_dcache(start, PAGE_SIZE);
+}
+
+void vb_flush_dcache_range(unsigned long start, unsigned long stop)
+{
+	vbi_flush_dcache((void *) start, (stop - start + 1));
+}
+
+void vb__flush_icache_range(unsigned long start, unsigned long stop)
+{
+	vbi_update_text_cache((void *) start, (stop - start + 1));
+}
+
+void vb__flush_dcache_icache_phys(unsigned long physaddr)
+{
+	vbi_flush_icache((void *) physaddr, PAGE_SIZE);
+	vbi_flush_dcache((void *) physaddr, PAGE_SIZE);
+}
diff --git a/arch/arm/kernel/vbi/wrhv.c b/arch/arm/kernel/vbi/wrhv.c
new file mode 100644
index 0000000..570a122
--- /dev/null
+++ b/arch/arm/kernel/vbi/wrhv.c
@@ -0,0 +1,318 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by the
+ *  Free Software Foundation; either version 2, or (at your option) any
+ *  later version.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  Copyright (C) 2011 Wind River Systems, Inc.
+ */
+
+#include <linux/module.h>
+#include <linux/irq.h>
+#include <linux/wrhv.h>
+#include <linux/interrupt.h>
+#include <linux/ptrace.h>
+#include <linux/delay.h>
+#include <linux/mm.h>
+#include <linux/stddef.h>
+#include <linux/clockchips.h>
+
+#include <asm/setup.h>
+#include <asm/irq.h>
+#include <asm/paravirt.h>
+
+#include <trace/irq.h>
+
+#include <vbi/vbi.h>
+#include <vbi/interface.h>
+
+#define WRHV_BOOTARG_BUF_SIZE	256
+
+DEFINE_PER_CPU(struct clock_event_device, wrhv_clock_events);
+
+/* wr_config is set super early to a pointer passed from the hv */
+struct vb_config *wr_config = (void *)(-1); /* keep it out of the bss */
+EXPORT_SYMBOL(wr_config);
+
+/* control and status pointers are set from info in the config region */
+struct vb_control *wr_control;
+struct vb_status *wr_status;
+extern struct vb_status *LCstatptr;
+
+static char *direct_interrupts_list;
+static int __init wrhv_check_direct_interrupts(char *str)
+{
+	direct_interrupts_list = str;
+	return 0;
+}
+
+early_param("direct_interrupts", wrhv_check_direct_interrupts);
+
+int wrhv_find_direct_interrupt(int intr_candidate)
+{
+	char	direct_interrupts[WRHV_BOOTARG_BUF_SIZE];
+	char	*current_tok;
+	char	*position;
+	int	intr_num;
+
+	if (direct_interrupts_list == NULL)
+		return -ENOENT;
+
+	strncpy(direct_interrupts, direct_interrupts_list,
+		WRHV_BOOTARG_BUF_SIZE-1);
+	direct_interrupts[WRHV_BOOTARG_BUF_SIZE-1] = '\0'; /* be safe */
+	position = direct_interrupts;
+	/* crack by ',' first */
+	while ((current_tok = strsep(&position, ","))) {
+		if (sscanf(current_tok, "%d", &intr_num) != 1)
+			return -EINVAL; /* broken list */
+
+			if (intr_num == intr_candidate) {
+				/* We have a match! */
+				return 0;
+			}
+	}
+	/* Didn't find it */
+	return -ENOENT;
+}
+
+unsigned long __init wrhv_find_end_of_memory(void)
+{
+	return wr_config->phys_mem_size;
+}
+
+static void wrhv_do_restart(void *data)
+{
+	int ret;
+	int cpu = smp_processor_id();
+
+	if (!cpu) {
+		printk(KERN_INFO "WRHV: rebooting\n");
+
+		ret = vbi_vb_reset(VBI_BOARD_ID_GET(), VBI_VB_CORES_ALL,
+				VBI_VBMGMT_RESET_AND_START_CORE0 |
+				VBI_VBMGMT_RESET_DOWNLOAD
+				);
+
+		if (ret)
+			printk(KERN_ERR "WRHV: reboot failed. ret = %d\n", ret);
+	}
+}
+
+void wrhv_restart(char str, const char *cmd)
+{
+	int cpu = smp_processor_id();
+
+	if (!cpu)
+		wrhv_do_restart(NULL);
+	else
+		smp_call_function(wrhv_do_restart, NULL, 1);
+
+	while (1);
+}
+
+static struct irqaction wrhv_timer_irq = {
+	.handler = wrhv_timer_interrupt,
+	.flags = IRQF_DISABLED | IRQF_NOBALANCING,
+	.name = "timer",
+};
+
+#ifdef CONFIG_SPARSE_IRQ
+#define WRHV_NR_IRQS	NR_IRQS_LEGACY
+#else
+#define WRHV_NR_IRQS	NR_IRQS
+#endif
+
+void (*wrhv_machine_init_irq)(void) __initdata = NULL;
+
+void __init wrhv_init_irq(void)
+{
+	int i;
+	struct irq_desc *desc;
+
+#ifdef CONFIG_SMP
+	/* By default all the irqs will be routed to core0 */
+	cpumask_copy(irq_default_affinity, cpumask_of(0));
+#endif
+
+	wrhv_irq_chip.typename = "WRHV-PIC";
+	for (i = 0; i < WRHV_NR_IRQS; i++) {
+		desc = irq_to_desc_alloc_node(i, 0);
+		desc->status = IRQ_DISABLED | IRQ_LEVEL;
+		desc->action = NULL;
+		desc->depth = 1;
+		set_irq_chip_and_handler(i, &wrhv_irq_chip, handle_fasteoi_irq);
+	}
+
+	/* Do any hardware specific init to support direct irqs */
+	if (wrhv_machine_init_irq)
+		wrhv_machine_init_irq();
+}
+
+void wrhv_do_IRQ(struct pt_regs *regs)
+{
+	struct pt_regs *old_regs = set_irq_regs(regs);
+	unsigned int irq;
+	int handled_at_least_one = 0;
+
+	trace_irq_entry(0, regs, NULL);
+
+	irq_enter();
+
+	/* To be implemented if there is a simple way...
+	check_stack_overflow();
+	*/
+
+check_again:
+	irq = vbi_get_pending_vioapic_irq();
+
+	if (irq != 0xffff) {
+		generic_handle_irq(irq);
+		handled_at_least_one = 1;
+		goto check_again;
+	} else if (!handled_at_least_one)
+		printk(KERN_WARNING "WRHV: Spurious interrupt!\n");
+
+	irq_exit();
+	set_irq_regs(old_regs);
+
+	trace_irq_exit(IRQ_HANDLED);
+}
+
+static void wrhv_set_mode(enum clock_event_mode mode,
+				 struct clock_event_device *dev)
+{
+	return;
+}
+
+static int wrhv_set_next_event(unsigned long evt,
+				      struct clock_event_device *dev)
+{
+	return 0;
+}
+
+static struct clock_event_device wrhv_clockevent = {
+	.name		= "wrhv",
+	.features	= CLOCK_EVT_FEAT_PERIODIC,
+	.set_mode	= wrhv_set_mode,
+	.set_next_event = wrhv_set_next_event,
+	.max_delta_ns	= 0xffffffff,
+	.min_delta_ns	= 10000,
+	.shift		= 32,   /* nanoseconds to cycles divisor 2^ */
+	.mult		= 1,     /* To be filled in */
+	.irq		= 0,
+	.rating		= 1,
+};
+
+void __init wrhv_time_init(void)
+{
+	struct clock_event_device *evt;
+
+	evt = &per_cpu(wrhv_clock_events, 0);
+	memcpy(evt, &wrhv_clockevent, sizeof(*evt));
+	evt->cpumask = cpumask_of(0);
+
+	clockevents_register_device(evt);
+	setup_irq(0, &wrhv_timer_irq);
+}
+
+pgd_t *wrhv_cpu_get_pgd(void)
+{
+	return current->active_mm->pgd;
+}
+
+void wrhv_do_idle(void)
+{
+	vbi_idle(1);
+}
+
+extern int __init arm_add_memory(unsigned long start, unsigned long size);
+
+void __init wrhv_MMU_init(void)
+{
+
+	__u32 start;
+	__u32 size;
+
+	start = 0x00000000ul;
+	size = wrhv_find_end_of_memory();
+
+	printk(KERN_DEBUG "Total %dK memory added\n", size / 1024);
+
+	arm_add_memory(start, size);
+
+}
+
+void wrhv_set_pte_ext(pte_t *ptep, pte_t pte, unsigned int ext)
+{
+	native_cpu_set_pte_ext(ptep, pte, ext);
+
+	/* We really want to just flush the modified entry for obvious
+	 * efficiency reasons.  But hypervisor issues right now mean that
+	 * we must flush them all.  The third parameter, length, being set
+	 * to -1 will flush them all.  We will leave the second parameter set
+	 * to what we really just want to flush even though it's ignored.
+	 */
+	vbi_flush_tlb(0, (void *)(pte & (-PAGE_SIZE)), -1);
+}
+
+void wrhv_do_switch_mm(unsigned long pgd_phys, struct mm_struct *mm)
+{
+	wr_control->vb_control_regs.vmmu_handle = mm->context.vmmu_handle;
+	wr_control->vb_control_regs.asid = 0;
+	vbi_load_ctx();
+	/* Flush everything for now, until we support asids.
+	 */
+	vbi_flush_tlb(0, 0, -1);
+}
+
+void wrhv_calculate_clock_freq(void)
+{
+	u64 lpj;
+	/* Hypervisor doesn't fill in the stamp freq field yet
+	unsigned long cpu_khz = wrhv_calculate_cpu_khz();
+	*/
+	unsigned long cpu_khz = 400 * 1000; /* 400 MHz default */
+
+	lpj = ((u64)cpu_khz * 1000);
+	do_div(lpj, HZ);
+	lpj_fine = lpj;
+
+	printk(KERN_INFO "Detected %lu.%03lu MHz processor.\n", cpu_khz / 1000,
+		cpu_khz % 1000);
+}
+
+void wrhv_init(void)
+{
+	/* wr_config was already set, super early */
+	vbi_init(wr_config);
+
+	wr_control = wr_config->vb_control;
+	wr_status = LCstatptr = wr_config->vb_status;
+
+
+	pv_info.name = "wrhv";
+	pv_info.paravirt_enabled = 1;
+
+	pv_irq_ops.do_IRQ = wrhv_do_IRQ;
+
+	pv_cpu_ops.do_idle = wrhv_do_idle;
+
+	pv_mmu_ops.MMU_init = wrhv_MMU_init;
+	pv_mmu_ops.do_switch_mm = wrhv_do_switch_mm;
+	pv_mmu_ops.set_pte_ext = wrhv_set_pte_ext;
+	pv_mmu_ops.cpu_get_pgd = wrhv_cpu_get_pgd;
+
+	snprintf(boot_command_line, COMMAND_LINE_SIZE,
+		"retain_initrd %s",
+	wr_config->bootLine);
+
+	wrhv_calculate_clock_freq();
+
+	arm_pm_restart = wrhv_restart;
+}
-- 
1.7.0.4

