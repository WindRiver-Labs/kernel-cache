From b4af9fd46f910d4531854bb5bbd8064d35840363 Mon Sep 17 00:00:00 2001
From: Charlie Paul <cpaul.windriver@gmail.com>
Date: Tue, 1 Sep 2015 21:20:53 -0700
Subject: [PATCH 41/59] arm/mach-axxia: Updated to support linux 4.1

git://git.yoctoproject.org/linux-yocto-4.1 standard/axxia/base
	commit c4f960e6bcbb7180ab260ad62d8cf7791ea3deda

Signed-off-by: Charlie Paul <cpaul.windriver@gmail.com>
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 arch/arm/mach-axxia/pci.c    |   58 +++++++++++++++++++++++++++++------------
 arch/arm/mach-axxia/timers.c |    2 +-
 2 files changed, 42 insertions(+), 18 deletions(-)

diff --git a/arch/arm/mach-axxia/pci.c b/arch/arm/mach-axxia/pci.c
index bec29e1..55ab9eca 100644
--- a/arch/arm/mach-axxia/pci.c
+++ b/arch/arm/mach-axxia/pci.c
@@ -113,6 +113,9 @@ static const struct resource pcie_outbound_default[] = {
 		.flags = IORESOURCE_MEM
 	}
 };
+struct axxia_private_data {
+	int port;
+};
 
 struct axxia_pciex_port {
 	char                name[16];
@@ -167,6 +170,13 @@ DECLARE_PCI_FIXUP_HEADER(0x1000, 0x5101, fixup_axxia_pci_bridge);
 DECLARE_PCI_FIXUP_HEADER(0x1000, 0x5108, fixup_axxia_pci_bridge);
 DECLARE_PCI_FIXUP_HEADER(0x1000, 0x5120, fixup_axxia_pci_bridge);
 
+static struct axxia_private_data *sysdata_to_axxiapci(void *sysdata)
+{
+	struct pci_sys_data *root = sysdata;
+
+	return root->private_data;
+}
+
 /* Convert to Bus# to PCIe port# */
 static struct axxia_pciex_port *bus_to_port(struct pci_bus *bus)
 {
@@ -604,7 +614,9 @@ pcie_msi_irq_handler(unsigned int irq, struct irq_desc *desc)
 /* PCIe setup function */
 static int axxia_pcie_setup(int portno, struct pci_sys_data *sys)
 {
-	struct axxia_pciex_port *port = &axxia_pciex_ports[sys->domain];
+
+	struct axxia_private_data *private_data = sysdata_to_axxiapci(sys);
+	struct axxia_pciex_port *port = &axxia_pciex_ports[private_data->port];
 	u32 pci_config, pci_status, link_state;
 	int i, num_pages, err, ret;
 	u32 outbound_size;
@@ -618,7 +630,7 @@ static int axxia_pcie_setup(int portno, struct pci_sys_data *sys)
 			     resource_size(&port->utl_regs));
 	if (!port->regs) {
 		pr_err("PCIE%d: Failed to map control registers\n",
-			sys->domain);
+				private_data->port);
 		goto fail;
 	}
 
@@ -626,7 +638,7 @@ static int axxia_pcie_setup(int portno, struct pci_sys_data *sys)
 	port->cfg_data = ioremap(port->cfg_space.start,
 				 resource_size(&port->cfg_space));
 	if (!port->cfg_data) {
-		pr_err("PCIE%d: Failed to map config space\n", sys->domain);
+		pr_err("PCIE%d: Failed to map config space\n", private_data->port);
 		goto fail;
 	}
 
@@ -635,13 +647,13 @@ static int axxia_pcie_setup(int portno, struct pci_sys_data *sys)
 
 	/* add IO_RESOURCE for legacy support expected by bios32 driver
 	 * not used by AXM55xx */
-	sys->io_res.start = (sys->domain * 0x100);
+	sys->io_res.start = (private_data->port * 0x100);
 	sys->io_res.end =  sys->io_res.start + 0xff;
 	sys->io_res.flags = IORESOURCE_IO;
 	sys->io_res.name = sys->io_res_name;
-	sprintf(sys->io_res_name, "PCI%d I/O", sys->domain);
+	sprintf(sys->io_res_name, "PCI%d I/O", private_data->port);
 	pr_info("PCIE%d: ioport start =  %#llx (PCI) -> %#llx\n",
-		sys->domain, sys->io_res.start, sys->io_res.end);
+			private_data->port, sys->io_res.start, sys->io_res.end);
 
 	ret = request_resource(&ioport_resource, &sys->io_res);
 	if (ret) {
@@ -657,7 +669,7 @@ static int axxia_pcie_setup(int portno, struct pci_sys_data *sys)
 			  "pcie", port);
 	if (err) {
 		pr_err("PCIE%d: Failed to request IRQ#%d (%d)\n",
-		       sys->domain, port->irq[0], err);
+				private_data->port, port->irq[0], err);
 		release_resource(&sys->io_res);
 		goto fail;
 	}
@@ -673,25 +685,25 @@ static int axxia_pcie_setup(int portno, struct pci_sys_data *sys)
 	if ((pci_status & 0x18) != 0x18) {
 		/* Endpoint */
 		pr_err("PCIE%d: Device is not Root Complex\n", port->index);
-		if (sys->domain == 0) {
+		if (private_data->port == 0) {
 			/* PEI0 */
 			port->irq[1] = irq_of_parse_and_map(port->node, 1);
 			err = request_irq(port->irq[1], pcie_doorbell_isr,
 			IRQF_SHARED, "pcie_db", port);
 			if (err) {
 				pr_err("PCIE%d: Failed to request IRQ#%d (%d)\n",
-					sys->domain, port->irq[0], err);
+						private_data->port, port->irq[0], err);
 				release_resource(&sys->io_res);
 				goto fail;
 			}
-		} else if (sys->domain == 1) {
+		} else if (private_data->port == 1) {
 			/* PEI1 */
 			port->irq[1] = irq_of_parse_and_map(port->node, 1);
 			err = request_irq(port->irq[1], pcie_doorbell_isr,
 			IRQF_SHARED, "pcie_db", port);
 			if (err) {
 				pr_err("PCIE%d: Failed to request IRQ#%d (%d)\n",
-					sys->domain, port->irq[0], err);
+						private_data->port, port->irq[0], err);
 				release_resource(&sys->io_res);
 				goto fail;
 			}
@@ -853,8 +865,10 @@ axxia_pcie_scan_bus(int nr, struct pci_sys_data *sys)
 static int
 axxia_pcie_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
 {
-	struct pci_sys_data *sys = dev->sysdata;
-	struct axxia_pciex_port *port = &axxia_pciex_ports[sys->domain];
+	//struct pci_sys_data *sys = dev->sysdata;
+	struct pci_bus	*bus = dev->bus;
+	struct axxia_pciex_port *port = bus_to_port(bus);
+	//struct axxia_pciex_port *port = &axxia_pciex_ports[sys->domain];
 
 	return port->irq[0];
 }
@@ -868,21 +882,28 @@ static struct irq_chip axxia_msi_chip = {
 	.irq_unmask  = unmask_msi_irq,
 };
 
+static struct axxia_private_data axxia_pd[] =  {
+	[0] = {
+		.port = 0,
+	},
+	[1] = {
+		.port = 1,
+	}
+};
+
 /* Port definition struct */
 static struct hw_pci axxia_pcie_hw[] = {
 	[0] = {
 		.nr_controllers = 1,
-		.domain = 0,
 		.setup = axxia_pcie_setup,
 		.scan = axxia_pcie_scan_bus,
-		.map_irq = axxia_pcie_map_irq
+		.map_irq = axxia_pcie_map_irq,
 	},
 	[1] = {
 		.nr_controllers = 1,
-		.domain = 1,
 		.setup = axxia_pcie_setup,
 		.scan = axxia_pcie_scan_bus,
-		.map_irq = axxia_pcie_map_irq
+		.map_irq = axxia_pcie_map_irq,
 	}
 };
 
@@ -1100,6 +1121,7 @@ axxia_pcie_init(void)
 {
 	struct device_node *np;
 	int num_ports = 0;
+	void *private_data;
 
 	/* allocate memory */
 	axxia_pciex_ports = kzalloc(PCIE_MAX_PORTS *
@@ -1118,6 +1140,8 @@ axxia_pcie_init(void)
 		}
 
 		axxia_probe_pciex_bridge(np);
+		axxia_pcie_hw[num_ports].private_data = &private_data;
+		private_data = &axxia_pd[num_ports];
 		pci_common_init(&axxia_pcie_hw[num_ports]);
 		if (++num_ports == PCIE_MAX_PORTS)
 			break;
diff --git a/arch/arm/mach-axxia/timers.c b/arch/arm/mach-axxia/timers.c
index 7d6e564..45079e2 100644
--- a/arch/arm/mach-axxia/timers.c
+++ b/arch/arm/mach-axxia/timers.c
@@ -215,7 +215,7 @@ axxia_timer_clockevents_init(void __iomem *base,
 	evt->reload             = DIV_ROUND_CLOSEST(rate, HZ);
 
 	evt->irqaction.name     = name;
-	evt->irqaction.flags    = IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL;
+	evt->irqaction.flags    = IRQF_TIMER | IRQF_IRQPOLL;
 	evt->irqaction.handler	= axxia_timer_handler;
 	evt->irqaction.dev_id	= evt;
 
-- 
1.7.5.4

