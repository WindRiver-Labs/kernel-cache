From bc2431f9b2fe901553481089d9436d62e38a1090 Mon Sep 17 00:00:00 2001
From: SangeethaRao <sangeetha.rao@intel.com>
Date: Wed, 9 Sep 2015 17:58:19 -0500
Subject: [PATCH 49/59] drivers/pci/host: Enabled X7 PCIe driver support

git://git.yoctoproject.org/linux-yocto-4.1 standard/axxia/base
	commit b6f97661d2154af4bb67f5264445ecd6bdf72ca2

Signed-off-by: SangeethaRao <sangeetha.rao@intel.com>
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 arch/arm/boot/dts/axm5504-sim-virtio.dts |    8 +
 arch/arm/boot/dts/axm5516-sim-virtio.dts |    7 +
 arch/arm/mach-axxia/Makefile             |    1 -
 arch/arm/mach-axxia/axxia.c              |    2 -
 arch/arm/mach-axxia/pci.c                | 1149 ------------------------------
 drivers/pci/host/Kconfig                 |    9 +
 drivers/pci/host/Makefile                |    3 +-
 7 files changed, 26 insertions(+), 1153 deletions(-)
 delete mode 100644 arch/arm/mach-axxia/pci.c

diff --git a/arch/arm/boot/dts/axm5504-sim-virtio.dts b/arch/arm/boot/dts/axm5504-sim-virtio.dts
index 68560e5..8ed571a 100644
--- a/arch/arm/boot/dts/axm5504-sim-virtio.dts
+++ b/arch/arm/boot/dts/axm5504-sim-virtio.dts
@@ -69,6 +69,14 @@
 	};
 };
 
+&pcie0 {
+	status = "okay";
+};
+
+&pcie1 {
+	status = "okay";
+};
+
 &mtc {
 	status = "okay";
 };
diff --git a/arch/arm/boot/dts/axm5516-sim-virtio.dts b/arch/arm/boot/dts/axm5516-sim-virtio.dts
index 3533467..4d6de47 100644
--- a/arch/arm/boot/dts/axm5516-sim-virtio.dts
+++ b/arch/arm/boot/dts/axm5516-sim-virtio.dts
@@ -68,6 +68,13 @@
 		};
 	};
 };
+&pcie0 {
+	status = "okay";
+};
+
+&pcie1 {
+	status = "okay";
+};
 
 &mtc {
 	status = "okay";
diff --git a/arch/arm/mach-axxia/Makefile b/arch/arm/mach-axxia/Makefile
index 73392a4..2ecc468 100644
--- a/arch/arm/mach-axxia/Makefile
+++ b/arch/arm/mach-axxia/Makefile
@@ -7,7 +7,6 @@ obj-y					+= io.o
 obj-y					+= ssp-gpio.o
 #obj-y					+= ncr.o
 obj-y					+= timers.o
-obj-y					+= pci.o
 obj-y					+= ddr_retention.o ddr_shutdown.o
 obj-$(CONFIG_SMP)			+= platsmp.o headsmp.o
 obj-$(CONFIG_ARCH_AXXIA_GIC)		+= axxia-gic.o
diff --git a/arch/arm/mach-axxia/axxia.c b/arch/arm/mach-axxia/axxia.c
index a54eecd..cb2652e 100644
--- a/arch/arm/mach-axxia/axxia.c
+++ b/arch/arm/mach-axxia/axxia.c
@@ -221,8 +221,6 @@ void __init axxia_dt_init(void)
 	ncr_init();
 	axxia_ddr_retention_init();
 
-	axxia_pcie_init();
-
 #ifdef CONFIG_AXXIA_RIO
 	axxia_rapidio_init();
 #endif
diff --git a/arch/arm/mach-axxia/pci.c b/arch/arm/mach-axxia/pci.c
deleted file mode 100644
index 55ab9eca..0000000
--- a/arch/arm/mach-axxia/pci.c
+++ /dev/null
@@ -1,1149 +0,0 @@
-/*
- * arch/arm/mach-axxia/pci.c
- *
- * PCIe support for AXM55xx.
- *
- * Copyright (C) 2013 LSI
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-#include <linux/kernel.h>
-#include <linux/pci.h>
-#include <linux/init.h>
-#include <linux/of.h>
-#include <linux/of_address.h>
-#include <linux/delay.h>
-#include <linux/slab.h>
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <linux/of_irq.h>
-#include <linux/interrupt.h>
-#include <linux/io.h>
-#include <linux/msi.h>
-#include <linux/kernel_stat.h>
-#include <asm/sizes.h>
-#include <asm/mach/pci.h>
-#include <asm/irq.h>
-#include <asm/mach/irq.h>
-#include <asm-generic/errno-base.h>
-#include <mach/pci.h>
-
-
-#define PCIE_CONFIG              (0x1000)
-#define PCIE_STATUS              (0x1004)
-#define PCIE_CORE_DEBUG          (0x1008)
-#define PCIE_LOOPBACK_FAIL       (0x100C)
-#define PCIE_MPAGE_U(n)          (0x1010 + (n * 8)) /* n = 0..7 */
-#define PCIE_MPAGE_L(n)          (0x1014 + (n * 8)) /* n = 0..7 */
-#define PCIE_TPAGE_BAR0(n)       (0x1050 + (n * 4)) /* n = 0..7 */
-#define     PCIE_TPAGE_32        (0<<31) /* AXI 32-bit access */
-#define     PCIE_TPAGE_128       (1<<31) /* AXI 128-bit access */
-#define PCIE_TPAGE_BAR1(n)       (0x1070 + (n * 4)) /* n = 0..7 */
-#define PCIE_TPAGE_BAR2(n)       (0x1090 + (n * 4)) /* n = 0..7 */
-#define PCIE_MSG_IN_FIFO         (0x10B0)
-#define PCIE_MSG_IN_FIFO_STATUS  (0x10B4)
-#define PCIE_MSG_OUT             (0x10B8)
-#define PCIE_TRN_ORDER_STATUS    (0x10BC)
-#define PCIE_INT0_STATUS         (0x10C0)
-#define PCIE_INT0_ENABLE         (0x10C4)
-#define PCIE_INT0_FORCE          (0x10C8)
-#define    INT0_MSI              0x80000000U
-#define    INT0_INT_ASSERTED     0x08000000U
-#define    INT0_INT_DEASSERTED   0x04000000U
-#define    INT0_ERROR            0x73FFFFABU
-#define PCIE_PHY_STATUS0         (0x10CC)
-#define PCIE_PHY_STATUS1         (0x10D0)
-#define PCIE_PHY_CONTROL0        (0x10D4)
-#define PCIE_PHY_CONTROL1        (0x10D8)
-#define PCIE_PHY_CONTROL2        (0x10DC)
-#define PCIE_RESERVED_E0         (0x10E0)
-#define PCIE_RESERVED_E4         (0x10E4)
-#define PCIE_RESERVED_E8         (0x10E8)
-#define PCIE_AXI_MASTER_WR       (0x10EC)
-#define PCIE_LINK_STATUS         (0x117C)
-#define PCIE_EP_BAR2_CFG         (0x1184)
-#define PCIE_AXI_MSI_ADDR        (0x1190)
-#define PCIE_INT1_STATUS         (0x11C4)
-#define PCIE_INT1_ENABLE         (0x11C8)
-#define PCIE_INT1_FORCE          (0x11CC)
-#define INT1_DOORBELL            0x00000001U
-#define PCIE_RC_BAR0_SIZE        (0x11F4)
-#define PCIE_MSI0_STATUS         (0x1230)
-#define PCIE_MSI0_ENABLE         (0x1234)
-#define PCIE_MSI0_FORCE          (0x1238)
-#define PCIE_MSI1_STATUS(_grp)   (0x123C+(_grp)*12)
-#define PCIE_MSI1_ENABLE(_grp)   (0x1240+(_grp)*12)
-#define PCIE_MSI1_FORCE(_grp)    (0x1244+(_grp)*12)
-
-/* Every MPAGE register maps 128MB in the AXI memory range */
-#define MPAGE_SIZE               (128U<<20)
-
-/* We have 7 MPAGE registers available for outbound window (one reserved for
- * mapping PCI configuration space).
- */
-#define MAX_OUTBOUND_SIZE	 (7 * MPAGE_SIZE)
-
-/* Number of IRQs allocated to MSI */
-#define NUM_MSI_IRQ (NR_IRQS - AXXIA_MSI_FIRST)
-
-/* Bitmap for allocated MSIs */
-static DECLARE_BITMAP(msi_irq_in_use, NUM_MSI_IRQ);
-
-static const struct resource pcie_outbound_default[] = {
-	[0] = {
-		.start = 0,
-		.end   = 0,
-		.flags = IORESOURCE_MEM
-	},
-	[1] = {
-		.start = 0,
-		.end   = 0,
-		.flags = IORESOURCE_MEM
-	}
-};
-struct axxia_private_data {
-	int port;
-};
-
-struct axxia_pciex_port {
-	char                name[16];
-	unsigned int	    index;
-	u8                  root_bus_nr;
-	bool                link_up;
-	int                 irq[18]; /* 1 legacy, 1 Doorbell (EP), 16 MSI */
-	void __iomem	    *regs;
-	void __iomem	    *cfg_data;
-	u32                 last_mpage;
-	int                 endpoint;
-	struct device_node  *node;
-	struct resource	    utl_regs;
-	struct resource	    cfg_space;
-	/* Outbound PCI base address */
-	u64                 pci_addr;
-	/* Outbound range in (physical) CPU addresses */
-	struct resource	    outbound;
-	/* Inbound PCI base address */
-	u64                 pci_bar;
-	/* Inbound range in (physical) CPU addresses */
-	struct resource	    inbound;
-	/* Virtual and physical (CPU space) address for MSI table */
-	void                *msi_virt;
-	dma_addr_t          msi_phys;
-	/* PCI memory space address for MSI table */
-	u32                 msi_pci_addr;
-};
-
-#define PCIE_MAX_PORTS 2
-static struct axxia_pciex_port *axxia_pciex_ports;
-
-static void pcie_msi_dispatch(u32 group, struct axxia_pciex_port *port);
-
-static void
-fixup_axxia_pci_bridge(struct pci_dev *dev)
-{
-	/* if we aren't a PCIe don't bother */
-	if (!pci_find_capability(dev, PCI_CAP_ID_EXP))
-		return;
-
-	/* Set the class appropriately for a bridge device */
-	dev_info(&dev->dev,
-		 "Fixup PCI Class to PCI_CLASS_BRIDGE_HOST for %04x:%04x\n",
-		 dev->vendor, dev->device);
-	dev->class = PCI_CLASS_BRIDGE_HOST << 8;
-	/* Make the bridge transparent */
-	dev->transparent = 1;
-}
-
-DECLARE_PCI_FIXUP_HEADER(0x1000, 0x5101, fixup_axxia_pci_bridge);
-DECLARE_PCI_FIXUP_HEADER(0x1000, 0x5108, fixup_axxia_pci_bridge);
-DECLARE_PCI_FIXUP_HEADER(0x1000, 0x5120, fixup_axxia_pci_bridge);
-
-static struct axxia_private_data *sysdata_to_axxiapci(void *sysdata)
-{
-	struct pci_sys_data *root = sysdata;
-
-	return root->private_data;
-}
-
-/* Convert to Bus# to PCIe port# */
-static struct axxia_pciex_port *bus_to_port(struct pci_bus *bus)
-{
-	return axxia_pciex_ports + pci_domain_nr(bus);
-}
-
-/*
- * Validate the Bus#/Device#/Function#
- */
-static int
-axxia_pciex_validate_bdf(struct pci_bus *bus, unsigned int devfn)
-{
-	struct axxia_pciex_port *port;
-
-	port = bus_to_port(bus);
-
-	/* Endpoint can not generate upstream(remote) config cycles */
-	if (port->endpoint)
-		return PCIBIOS_DEVICE_NOT_FOUND;
-
-	if (((!((PCI_FUNC(devfn) == 0) && (PCI_SLOT(devfn) == 0)))
-		&& (bus->number == port->root_bus_nr))
-		|| (!(PCI_SLOT(devfn) == 0)
-		&& (bus->number == port->root_bus_nr+1))) {
-		return PCIBIOS_DEVICE_NOT_FOUND;
-	}
-	return 0;
-}
-
-/*
- * Return the configuration access base address
- */
-static void __iomem *
-axxia_pciex_get_config_base(struct axxia_pciex_port *port,
-			    struct pci_bus *bus,
-			    unsigned int devfn)
-{
-	int relbus, dev, fn;
-	unsigned mpage;
-
-	if (bus->number == port->root_bus_nr)
-		return port->regs;
-
-	relbus = bus->number - (port->root_bus_nr + 1);
-	dev    = PCI_SLOT(devfn);
-	fn     = PCI_FUNC(devfn);
-
-	if (dev > 31)
-		return NULL;
-
-	/* Build the mpage register (MPAGE[4]=1 for cfg access) */
-	mpage = (fn << 19) | (bus->number << 11) | (dev << 6) | (1<<4);
-
-	/* Primary bus */
-	if (relbus && (bus->number != port->root_bus_nr))
-		mpage |= 1<<5;
-
-	if (mpage != port->last_mpage) {
-		writel(0,     port->regs + PCIE_MPAGE_U(7));
-		writel(mpage, port->regs + PCIE_MPAGE_L(7));
-		port->last_mpage = mpage;
-	}
-
-	return port->cfg_data;
-}
-
-/*
- * Read PCI config space
- */
-static int
-arm_pciex_axxia_read_config(struct pci_bus *bus,
-			    unsigned int devfn,
-			    int offset,
-			    int len,
-			    u32 *val)
-{
-	struct axxia_pciex_port *port = bus_to_port(bus);
-	void __iomem *addr;
-	u32 bus_addr;
-	u32 val32;
-	int bo = offset & 0x3;
-	int rc = PCIBIOS_SUCCESSFUL;
-	u32 bus_addr1;
-
-	if (axxia_pciex_validate_bdf(bus, devfn) != 0)
-		return PCIBIOS_DEVICE_NOT_FOUND;
-
-	addr = axxia_pciex_get_config_base(port, bus, devfn);
-
-	if (!addr) {
-		*val = 0;
-		return PCIBIOS_DEVICE_NOT_FOUND;
-	}
-
-	/*
-	 * addressing is different for local config access vs.
-	 * access through the mapped config space.
-	 */
-	if (bus->number == 0) {
-		int wo = offset & 0xfffffffc;
-
-		bus_addr = (u32)addr + wo;
-		bus_addr1 = bus_addr;
-	} else {
-		/*
-		 * mapped config space only supports 32-bit access
-		 *
-		 *  AXI address [3:0] is not used at all.
-		 *  AXI address[9:4] becomes register number.
-		 *  AXI address[13:10] becomes Ext. register number
-		 *  AXI address[17:14] becomes 1st DWBE for configuration
-		 *  read only.
-		 *  AXI address[29:27] is used to select one of 8 Mpage
-		 *  registers.
-		 */
-		bus_addr = (u32) addr + (offset << 2);
-		bus_addr1 = bus_addr;
-
-		switch (len) {
-		case 1:
-			bus_addr |=  ((1 << bo)) << 14;
-			break;
-		case 2:
-			bus_addr |=  ((3 << bo)) << 14;
-			break;
-		default:
-			bus_addr |=  (0xf) << 14;
-			break;
-		}
-	}
-	/*
-	 * do the read
-	 */
-	val32 = readl((u32 __iomem *)bus_addr);
-
-	switch (len) {
-	case 1:
-		*val = (val32 >> (bo * 8)) & 0xff;
-		break;
-	case 2:
-		*val = (val32 >> (bo * 8)) & 0xffff;
-		break;
-	default:
-		*val = val32;
-		break;
-	}
-
-#ifdef PRINT_CONFIG_ACCESSES
-	pr_info("acp_read_config for PCIE%d: %3d  fn=0x%04x o=0x%04x l=%d a=0x%08x v=0x%08x, dev=%d\n",
-			port->index, bus->number, devfn, offset, len,
-			bus_addr, *val, PCI_SLOT(devfn));
-#endif
-	return rc;
-}
-
-/*
- * Write PCI config space.
- */
-static int
-arm_pciex_axxia_write_config(struct pci_bus *bus,
-			     unsigned int devfn,
-			     int offset,
-			     int len,
-			     u32 val)
-{
-	struct axxia_pciex_port *port = bus_to_port(bus);
-	void __iomem *addr;
-	u32 bus_addr;
-	u32 val32;
-
-	if (axxia_pciex_validate_bdf(bus, devfn) != 0)
-		return PCIBIOS_DEVICE_NOT_FOUND;
-
-	addr = axxia_pciex_get_config_base(port, bus, devfn);
-
-	if (!addr)
-		return PCIBIOS_DEVICE_NOT_FOUND;
-
-	/*
-	 * addressing is different for local config access vs.
-	 * access through the mapped config space. We need to
-	 * translate the offset for mapped config access
-	 */
-	if (bus->number == 0) {
-		/* the local ACP RC only supports 32-bit dword config access,
-		 * so if this is a byte or 16-bit word access we need to
-		 * perform a read-modify write
-		 */
-		if (len == 4) {
-			bus_addr = (u32) addr + offset;
-		} else {
-			int bs = ((offset & 0x3) * 8);
-
-			bus_addr = (u32) addr + (offset & 0xfffffffc);
-			val32 = readl((u32 __iomem *)bus_addr);
-
-			if (len == 2) {
-				val32 = (val32 & ~(0xffff << bs))
-					| ((val & 0xffff) << bs);
-			} else {
-				val32 = (val32 & ~(0xff << bs))
-					| ((val & 0xff) << bs);
-			}
-
-			val = val32;
-			len = 4;
-		}
-	} else {
-		bus_addr = (u32) addr + (offset << 2) + (offset & 0x3);
-	}
-
-#ifdef PRINT_CONFIG_ACCESSES
-	pr_info("acp_write_config: bus=%3d devfn=0x%04x offset=0x%04x len=%d addr=0x%08x val=0x%08x\n",
-		bus->number, devfn, offset, len, bus_addr, val);
-#endif
-
-	switch (len) {
-	case 1:
-		writeb(val, (u8 __iomem *)(bus_addr));
-		break;
-	case 2:
-		writew(val, (u16 __iomem *)(bus_addr));
-		break;
-	default:
-		writel(val, (u32 __iomem *)(bus_addr));
-		break;
-	}
-	return PCIBIOS_SUCCESSFUL;
-}
-
-static struct pci_ops axxia_pciex_pci_ops = {
-	.read  = arm_pciex_axxia_read_config,
-	.write = arm_pciex_axxia_write_config,
-};
-
-/*
- * pcie_doorbell_isr
- *
- * This ISR is for doorbell interrupts for
- * Endpoint mode which has a dedicated IRQ line
- * This support expects kernel module to handle the doorbell
- * interrupt
- */
-static irqreturn_t
-pcie_doorbell_isr(int irq, void *arg)
-{
-	struct axxia_pciex_port *port  = arg;
-	void __iomem            *mbase = port->regs;
-	u32                     intr1_status;
-
-	intr1_status = readl(mbase + PCIE_INT1_STATUS);
-
-	if (intr1_status & INT1_DOORBELL) {
-		/* EP doorbell interrupt. This support expects kernel module
-		 * to handle this doorbell interrupt
-		 */
-		/* Clear it */
-		writel(INT1_DOORBELL, mbase + PCIE_INT1_STATUS);
-	}
-	return IRQ_NONE;
-}
-
-
-/*
- * pcie_legacy_isr
- *
- * The interrupt line for this handler is shared between the PCIE controller
- * itself (for status and error interrupts) and devices using legacy PCI
- * interupt signalling. Statis and error interrupts are serviced here and this
- * handler will return IRQ_HANDLED. If the reasont is the assertion of a device
- * legacy interrupt, this handler returns IRQ_NONE the next action on this line
- * will be called (the PCI EP interrupt service routine).
- */
-static irqreturn_t
-pcie_legacy_isr(int irq, void *arg)
-{
-	struct axxia_pciex_port *port  = arg;
-	void __iomem            *mbase = port->regs;
-	u32                      intr_status, intr1_status;
-	irqreturn_t              retval = IRQ_HANDLED;
-
-	/* read the PEI interrupt status register */
-	intr_status = readl(mbase + PCIE_INT0_STATUS);
-	intr1_status = readl(mbase + PCIE_INT1_STATUS);
-
-	/* check if this is a PCIe message not from an external device */
-	if (intr_status & INT0_ERROR) {
-			u32 offset;
-
-			pr_info("PCIE%d: Error interrupt %#x\n",
-				port->index, intr_status);
-
-			pr_info("PCIE%d: link status = %#x\n",
-				port->index, readl(mbase + PCIE_LINK_STATUS));
-
-			if (intr_status & 0x00020000) {
-				pr_info("PCIE%d: t2a_fn_indp_err_stat = %#x\n",
-					port->index, readl(mbase+0x1170));
-			}
-
-			if (intr_status & 0x00040000) {
-				pr_info("PCIE%d: t2a_fn_indp_other_err_stat = %#x\n",
-					port->index, readl(mbase+0x1174));
-			}
-
-			if (intr_status & 0x00000800) {
-				pr_info("PCIE%d: config=%#x status=%#x\n",
-					port->index,
-					readl(mbase + PCIE_CONFIG),
-					readl(mbase + PCIE_STATUS));
-			}
-
-			/*
-			 * Dump all the potentially interesting PEI registers
-			 */
-			for (offset = 0x114c; offset <= 0x1180; offset += 4) {
-				pr_err("  [0x%04x] = 0x%08x\n",
-				       offset, readl(mbase + offset));
-			}
-	} else if (intr_status & INT0_INT_ASSERTED) {
-		/* Empty the message FIFO */
-		while ((readl(port->regs + PCIE_MSG_IN_FIFO_STATUS) & 1) == 0)
-			(void) readl(port->regs + PCIE_MSG_IN_FIFO);
-		/* Next handler in chain will service this interrupt */
-		retval = IRQ_NONE;
-	} else if (intr_status & INT0_MSI) {
-		u32 msi_status = readl(port->regs + PCIE_MSI0_STATUS);
-
-		if (msi_status == 0) {
-			retval = IRQ_NONE;
-		} else {
-			u32 group = ffs(msi_status) - 1;
-
-			pcie_msi_dispatch(group, port);
-		}
-	}
-
-	if (intr1_status & INT1_DOORBELL) {
-		/* RC doorbell interrupt. This support expects kernel module
-		 * to handle this doorbell interrupt
-		 */
-		/* Clear it */
-		writel(INT1_DOORBELL, mbase + PCIE_INT1_STATUS);
-		return IRQ_NONE;
-	}
-
-	/*
-	 *  We clear all the interrupts in the PEI status, even though
-	 *  interrupts from external devices have not yet been handled.
-	 *  That should be okay, since the PCI IRQ in the GIC won't be
-	 *  re-enabled until all external handlers have been called.
-	 */
-	writel(intr_status, mbase + PCIE_INT0_STATUS);
-	return retval;
-}
-
-/*
- * MSI handler
- *
- * This is the handler for PCIE MSI service. It will decode the signalled MSI
- * using the following hierarchy of status bits. This handler is installed as a
- * chained handler for each of the 16 interrupt lines on the top-level
- * interrupt controller. When a pending MSI is found, this handler forwards the
- * interrupt service to the corresponding MSI IRQs (numbered from
- * AXXIA_MSI_FIRST..NR_IRQS).
- *
- *                                             PCIE_MSI1_STATUS(group)
- *
- *                 PCIE_MSI0_STATUS                  +----------+
- *                                                   | MSI      |
- *   +----------+    +----------+                    | 0..15    |
- *   | ARM GIC  |    | GROUP    |        /-----------+          |
- *   |          +----+ 0..15    +-------/            |          |
- *   |          |    |          |                    |          |
- *   |          +----+          +-------\            +----------+
- *   |          |    |          |        \
- *   |          +----+          |         \          +----------+
- *   |          |    |          |          \         | MSI      |
- *   |          +----+          |           \        | 16..31   |
- *   |          |    |          |            \-------+          |
- *   |          +----+          |                    |          |
- *   |          |    |          |                    |          |
- *   |          |    |          |                    +----------+
- *   |          | .  |          |
- *   |          | .  |          |                    ...
- *   |          | .  |          |
- *   |          |    |          |                    +----------+
- *   |          |    |          |                    | MSI      |
- *   |          +----+          +--------------------+ 240..255 |
- *   |          |    |          |                    |          |
- *   +----------+    +----------+                    |          |
- *                                                   |          |
- *                                                   +----------+
- */
-static void
-pcie_msi_dispatch(u32 group, struct axxia_pciex_port *port)
-{
-	u32 status;
-
-	/* Check next level interrupt status */
-	status = readl(port->regs + PCIE_MSI1_STATUS(group)) & 0xffff;
-	while (status) {
-		u32 line = ffs(status) - 1;
-
-		status &= ~(1 << line);
-		/* Clear interrupt on sub-level */
-		writel((1 << line), port->regs + PCIE_MSI1_STATUS(group));
-		generic_handle_irq(AXXIA_MSI_FIRST + (group * 16) + line);
-	}
-
-	/* Clear interrupt on top-level*/
-	writel(1 << group, port->regs + PCIE_MSI0_STATUS);
-}
-
-static void
-pcie_msi_irq_handler(unsigned int irq, struct irq_desc *desc)
-{
-	struct axxia_pciex_port *port = &axxia_pciex_ports[0];
-	u32 group = irq - port->irq[1];
-	u32 status;
-
-	/* Check if interrupt is pending */
-	status = readl(port->regs + PCIE_MSI0_STATUS);
-	if (status & (1 << group)) {
-		kstat_incr_irq_this_cpu(irq);
-		/* Handle the PCIe interrupt */
-		pcie_msi_dispatch(group, port);
-	} else {
-		handle_bad_irq(irq, desc);
-	}
-	/* Signal end-of-interrupt */
-	irq_desc_get_chip(desc)->irq_eoi(&desc->irq_data);
-}
-
-/* PCIe setup function */
-static int axxia_pcie_setup(int portno, struct pci_sys_data *sys)
-{
-
-	struct axxia_private_data *private_data = sysdata_to_axxiapci(sys);
-	struct axxia_pciex_port *port = &axxia_pciex_ports[private_data->port];
-	u32 pci_config, pci_status, link_state;
-	int i, num_pages, err, ret;
-	u32 outbound_size;
-	u32 inbound_size;
-	u64 dest;
-
-	port->root_bus_nr = sys->busnr;
-
-	/* Map PCIe bridge control registers */
-	port->regs = ioremap(port->utl_regs.start,
-			     resource_size(&port->utl_regs));
-	if (!port->regs) {
-		pr_err("PCIE%d: Failed to map control registers\n",
-				private_data->port);
-		goto fail;
-	}
-
-	/* Map range for access to PCI configuration space */
-	port->cfg_data = ioremap(port->cfg_space.start,
-				 resource_size(&port->cfg_space));
-	if (!port->cfg_data) {
-		pr_err("PCIE%d: Failed to map config space\n", private_data->port);
-		goto fail;
-	}
-
-	pci_add_resource_offset(&sys->resources, &port->outbound,
-				port->outbound.start - port->pci_addr);
-
-	/* add IO_RESOURCE for legacy support expected by bios32 driver
-	 * not used by AXM55xx */
-	sys->io_res.start = (private_data->port * 0x100);
-	sys->io_res.end =  sys->io_res.start + 0xff;
-	sys->io_res.flags = IORESOURCE_IO;
-	sys->io_res.name = sys->io_res_name;
-	sprintf(sys->io_res_name, "PCI%d I/O", private_data->port);
-	pr_info("PCIE%d: ioport start =  %#llx (PCI) -> %#llx\n",
-			private_data->port, sys->io_res.start, sys->io_res.end);
-
-	ret = request_resource(&ioport_resource, &sys->io_res);
-	if (ret) {
-		pr_err("PCI: unable to allocate I/O port region (%d)\n", ret);
-		goto fail;
-	}
-	pci_add_resource_offset(&sys->resources, &sys->io_res,
-		sys->io_offset);
-
-	/* Status/error interrupt */
-	port->irq[0] = irq_of_parse_and_map(port->node, 0);
-	err = request_irq(port->irq[0], pcie_legacy_isr, IRQF_SHARED,
-			  "pcie", port);
-	if (err) {
-		pr_err("PCIE%d: Failed to request IRQ#%d (%d)\n",
-				private_data->port, port->irq[0], err);
-		release_resource(&sys->io_res);
-		goto fail;
-	}
-
-	/* Setup as root complex */
-	pci_config = readl(port->regs + PCIE_CONFIG);
-	pci_status = readl(port->regs + PCIE_STATUS);
-	link_state = (pci_status >> 8) & 0x3f;
-	pr_info("PCIE%d: status=0x%08x, link state=%#x\n",
-		port->index, pci_status, link_state);
-
-	/* make sure the ACP device is configured as PCI Root Complex */
-	if ((pci_status & 0x18) != 0x18) {
-		/* Endpoint */
-		pr_err("PCIE%d: Device is not Root Complex\n", port->index);
-		if (private_data->port == 0) {
-			/* PEI0 */
-			port->irq[1] = irq_of_parse_and_map(port->node, 1);
-			err = request_irq(port->irq[1], pcie_doorbell_isr,
-			IRQF_SHARED, "pcie_db", port);
-			if (err) {
-				pr_err("PCIE%d: Failed to request IRQ#%d (%d)\n",
-						private_data->port, port->irq[0], err);
-				release_resource(&sys->io_res);
-				goto fail;
-			}
-		} else if (private_data->port == 1) {
-			/* PEI1 */
-			port->irq[1] = irq_of_parse_and_map(port->node, 1);
-			err = request_irq(port->irq[1], pcie_doorbell_isr,
-			IRQF_SHARED, "pcie_db", port);
-			if (err) {
-				pr_err("PCIE%d: Failed to request IRQ#%d (%d)\n",
-						private_data->port, port->irq[0], err);
-				release_resource(&sys->io_res);
-				goto fail;
-			}
-		}
-		/* Enable doorbell interrupts */
-		writel(INT1_DOORBELL,
-			port->regs + PCIE_INT1_ENABLE);
-		release_resource(&sys->io_res);
-		return 0;
-	}
-
-	/* Make sure the link is up */
-	if (link_state != 0xb) {
-		/* Reset */
-		pr_warn("PCIE%d: Link in bad state - resetting\n", port->index);
-		pci_config |= 1;
-		writel(pci_config, port->regs + PCIE_CONFIG);
-		msleep(1000);
-		pci_status = readl(port->regs + PCIE_STATUS);
-		link_state = (pci_status & 0x3f00) >> 8;
-		pr_warn("PCIE%d: (after reset) link state=%#x\n",
-			port->index, link_state);
-		if (link_state != 0xb) {
-			pr_warn("PCIE%d: Link in bad state - giving up!\n",
-				port->index);
-			release_resource(&sys->io_res);
-			goto fail;
-		}
-	}
-
-	/* MSI interrupts */
-	for (i = 2; i <= 17; i++) {
-		port->irq[i] = irq_of_parse_and_map(port->node, i);
-		if (!port->irq[i])
-			break;
-		irq_set_chained_handler(port->irq[i], pcie_msi_irq_handler);
-	}
-	/*
-	 * Setup outbound PCI Memory Window
-	 */
-
-	outbound_size = resource_size(&port->outbound);
-	num_pages = (outbound_size + MPAGE_SIZE - 1) / MPAGE_SIZE;
-	dest = port->pci_addr;
-	for (i = 0; i < num_pages; i++) {
-		u32 mpage_u = dest >> 32;
-		u32 mpage_l = (u32)dest & ~(MPAGE_SIZE-1);
-
-		writel(mpage_u, port->regs + PCIE_MPAGE_U(i));
-		writel(mpage_l, port->regs + PCIE_MPAGE_L(i));
-		pr_debug("PCIE%d: MPAGE(%d) = %08x %08x\n",
-			 port->index, i, mpage_u, mpage_l);
-		dest += MPAGE_SIZE;
-	}
-
-	/*
-	 * Setup inbound PCI window
-	 */
-
-	/* Configure the inbound window size */
-	inbound_size = (u32) resource_size(&port->inbound);
-	writel(~(inbound_size-1), port->regs + PCIE_RC_BAR0_SIZE);
-
-	/* Verify BAR0 size */
-	{
-		u32 bar0_size;
-
-		writel(~0, port->regs + PCI_BASE_ADDRESS_0);
-		bar0_size = readl(port->regs + PCI_BASE_ADDRESS_0);
-		if ((bar0_size & ~0xf) != ~(inbound_size-1))
-			pr_err("PCIE%d: Config BAR0 failed\n", port->index);
-	}
-
-	/* Set the BASE0 address to start of PCIe base */
-	writel(port->pci_bar, port->regs + PCI_BASE_ADDRESS_0);
-
-	/* Set the BASE1 address to 0x0 */
-	writel(0x0, port->regs + PCI_BASE_ADDRESS_1);
-
-
-	/* Setup TPAGE registers for inbound mapping
-	 *
-	 * We set the MSB of each TPAGE to select 128-bit AXI access. For the
-	 * address field we simply program an incrementing value to map
-	 * consecutive pages
-	 */
-	for (i = 0; i < 8; i++)
-		writel(PCIE_TPAGE_128 | i, port->regs + PCIE_TPAGE_BAR0(i));
-
-
-	/* Enable all legacy/status/error interrupts */
-	writel(INT0_MSI | INT0_INT_ASSERTED | INT0_ERROR,
-	       port->regs + PCIE_INT0_ENABLE);
-
-	/* Enable doorbell interrupts */
-	writel(INT1_DOORBELL,
-	       port->regs + PCIE_INT1_ENABLE);
-
-	/* Enable all MSI interrupt groups */
-	writel(0xFFFF, port->regs + PCIE_MSI0_ENABLE);
-	/* Enable all lines in all subgroups */
-	for (i = 0; i < 16; i++)
-		writel(0xFFFF, port->regs + PCIE_MSI1_ENABLE(i));
-
-	return 1;
-fail:
-	if (port->cfg_data)
-		iounmap(port->cfg_data);
-	if (port->regs)
-		iounmap(port->regs);
-	return 0;
-}
-
-/*
- * Allocate MSI page. A MSI is generated when EP writes to this PCI address.
- * The region must be 1Kb to manage 256 MSIs.
- */
-static void *
-pcie_alloc_msi_table(struct pci_dev *pdev, struct axxia_pciex_port *port)
-{
-	u32 msi_lower;
-	void *msi_virt;
-
-	if (dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(64)) != 0 &&
-	    dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32)) != 0) {
-		dev_err(&pdev->dev, "No memory for MSI table\n");
-		return NULL;
-	}
-
-	msi_virt = dma_alloc_coherent(&pdev->dev, 1024,
-				      &port->msi_phys,
-				      GFP_KERNEL);
-	if (msi_virt) {
-		msi_lower = (u32)port->msi_phys;
-		/* Please note we have 1:1 mapping for inbound */
-		port->msi_pci_addr = port->inbound.start + msi_lower;
-		writel(msi_lower>>10, port->regs + PCIE_AXI_MSI_ADDR);
-	}
-
-	return msi_virt;
-}
-
-
-/*
- * Scan PCIe bus
- */
-static struct pci_bus *
-axxia_pcie_scan_bus(int nr, struct pci_sys_data *sys)
-{
-	if (WARN_ON(nr >= PCIE_MAX_PORTS))
-		return NULL;
-
-	return pci_scan_root_bus(NULL, sys->busnr, &axxia_pciex_pci_ops,
-				 sys, &sys->resources);
-}
-
-
-
-static int
-axxia_pcie_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
-{
-	//struct pci_sys_data *sys = dev->sysdata;
-	struct pci_bus	*bus = dev->bus;
-	struct axxia_pciex_port *port = bus_to_port(bus);
-	//struct axxia_pciex_port *port = &axxia_pciex_ports[sys->domain];
-
-	return port->irq[0];
-}
-
-/* IRQ chip ops for MSI IRQs */
-static struct irq_chip axxia_msi_chip = {
-	.name = "PCI-MSI",
-	.irq_enable  = unmask_msi_irq,
-	.irq_disable = mask_msi_irq,
-	.irq_mask    = mask_msi_irq,
-	.irq_unmask  = unmask_msi_irq,
-};
-
-static struct axxia_private_data axxia_pd[] =  {
-	[0] = {
-		.port = 0,
-	},
-	[1] = {
-		.port = 1,
-	}
-};
-
-/* Port definition struct */
-static struct hw_pci axxia_pcie_hw[] = {
-	[0] = {
-		.nr_controllers = 1,
-		.setup = axxia_pcie_setup,
-		.scan = axxia_pcie_scan_bus,
-		.map_irq = axxia_pcie_map_irq,
-	},
-	[1] = {
-		.nr_controllers = 1,
-		.setup = axxia_pcie_setup,
-		.scan = axxia_pcie_scan_bus,
-		.map_irq = axxia_pcie_map_irq,
-	}
-};
-
-static void
-axxia_probe_pciex_bridge(struct device_node *np)
-{
-	struct axxia_pciex_port *port;
-	u32 portno;
-	const char *val;
-	const u32 *field;
-	int rlen;
-	int pna = of_n_addr_cells(np); /* address-size of parent */
-	u32 pci_space;
-	u64 pci_addr;
-	u64 cpu_addr;
-	u64 size;
-
-	/* Check if device is enabled */
-	if (!of_device_is_available(np))
-		return;
-
-	/* Get the port number from the device-tree */
-	if (of_property_read_u32(np, "port", &portno) != 0) {
-		pr_err("%s: No 'port' property\n", np->full_name);
-		return;
-	}
-
-	if (portno >= PCIE_MAX_PORTS) {
-		pr_err("%s: Port %d out of range\n", np->full_name, portno);
-		return;
-	}
-
-	port = &axxia_pciex_ports[portno];
-	port->index = portno;
-	snprintf(port->name, sizeof(port->name) - 1, "PCIE%d", portno);
-	port->node = of_node_get(np);
-
-	/* Check if device_type property is set to "pci" or "pci-endpoint".
-	 * Resulting from this setup this PCIe port will be configured
-	 * as root-complex or as endpoint.
-	 */
-	val = of_get_property(port->node, "device_type", NULL);
-	port->endpoint = val && strcmp(val, "pci-endpoint") == 0;
-
-	/* Fetch address range for PCIE config space */
-	if (of_address_to_resource(np, 0, &port->cfg_space)) {
-		pr_err("PCIE%d: No resource for PCIe config space\n", portno);
-		return;
-	}
-
-	/* Fetch address range for host bridge internal registers */
-	if (of_address_to_resource(np, 1, &port->utl_regs)) {
-		pr_err("PCIE%d: No resource for PCIe registers\n", portno);
-		return;
-	}
-
-	if (request_resource(&iomem_resource, &port->utl_regs))
-		return;
-
-	/*
-	 * Outbound PCI memory window
-	 */
-
-	/* Defaults */
-	port->outbound = pcie_outbound_default[portno];
-	port->outbound.name = port->name;
-
-	field = of_get_property(np, "ranges", &rlen);
-	if (field) {
-		pci_space = of_read_number(field + 0, 1);
-		switch ((pci_space >> 24) & 3) {
-		case 0:
-			pr_err("PCIE%d: Invalid 'ranges'\n", portno);
-			break;
-		case 1: /* PCI IO Space */
-			pr_err("PCIE%d: PCI IO not supported\n", portno);
-			break;
-		case 2: /* PCI MEM 32-bit */
-		case 3: /* PCI MEM 64-bit */
-			cpu_addr  = of_read_number(field + 3, 2);
-			size      = of_read_number(field + 5, 2);
-			port->outbound.start = cpu_addr;
-			port->outbound.end   = cpu_addr + size - 1;
-			port->pci_addr = of_read_number(field + 1, 2);
-			break;
-		}
-	}
-
-	if (resource_size(&port->outbound) > MAX_OUTBOUND_SIZE) {
-		pr_err("PCIE%d: Outbound window too large (using max %#x)\n",
-		       portno, MAX_OUTBOUND_SIZE);
-		port->outbound.end = (port->outbound.start +
-				      MAX_OUTBOUND_SIZE - 1);
-	}
-
-	if (request_resource(&iomem_resource, &port->outbound)) {
-		pr_err("PCIE%d: Memory resource request failed\n", portno);
-		return;
-	}
-
-	if (request_resource(&iomem_resource, &port->cfg_space)) {
-		pr_err("PCIE%d: Config space request failed\n", portno);
-		return;
-	}
-
-	pr_info("PCIE%d: Outbound %#llx..%#llx (CPU) -> %#llx (PCI)\n",
-		portno,
-		port->outbound.start, port->outbound.end,
-		port->pci_addr);
-
-	/*
-	 * Inbound PCI memory window
-	 */
-
-	/* Default 4GB */
-	port->inbound.name  = "PCIE DMA";
-	port->inbound.start = 0x00000000;
-	port->inbound.end   = 0xffffffff;
-	port->inbound.flags = IORESOURCE_MEM | IORESOURCE_PREFETCH;
-
-	/* Get dma-ranges property */
-	field = of_get_property(np, "dma-ranges", &rlen);
-	if (!field) {
-		pr_info("PCIE%d: No 'dma-ranges' property, using defaults\n",
-			portno);
-	} else {
-		BUILD_BUG_ON(sizeof(resource_size_t) != sizeof(u64));
-
-		/* Limited to one inbound window for now... */
-		pci_space = of_read_number(field + 0, 1);
-		pci_addr  = of_read_number(field + 1, 2);
-		cpu_addr  = of_read_number(field + 3, pna);
-		size      = of_read_number(field + pna + 3, 2);
-
-		port->inbound.start = cpu_addr;
-		port->inbound.end   = cpu_addr + size - 1;
-		port->pci_bar       = pci_addr;
-	}
-
-	pr_info("PCIE%d: Inbound %#llx (PCI) -> %#llx..%#llx (CPU)\n",
-		portno,
-		port->pci_bar,
-		port->inbound.start, port->inbound.end);
-}
-
-/*
- * Allocate a MSI interrupt number and IRQ (the IRQ is a constant offset from
- * the MSI index). The kernel IRQs for MSI are in a range above hardware IRQs.
- *
- * First call also allocates the 1Kb MSI table and configures the controller.
- */
-int
-arch_setup_msi_irq(struct pci_dev *pdev, struct msi_desc *desc)
-{
-	struct axxia_pciex_port *port = bus_to_port(pdev->bus);
-	struct msi_msg msg;
-	int pos, irq;
-
-	/* Allocate MSI table on demand when first device needs it */
-	if (!port->msi_virt)
-		port->msi_virt = pcie_alloc_msi_table(pdev, port);
-
-	if (!port->msi_virt)
-		return -ENOMEM;
-
-	/* Find available MSI */
-again:
-	pos = find_first_zero_bit(msi_irq_in_use, NUM_MSI_IRQ);
-	/* Offset to get the IRQ */
-	irq = AXXIA_MSI_FIRST + pos;
-	if (irq >= NR_IRQS)
-		return -ENOSYS;
-	if (test_and_set_bit(pos, msi_irq_in_use))
-		goto again;
-
-	/* Initialize IRQ descriptor */
-	irq_init_desc(irq);
-	if (irq_set_msi_desc(irq, desc) != 0) {
-		dev_err(&pdev->dev, "Bad IRQ descriptor for IRQ%d\n", irq);
-		clear_bit(pos, msi_irq_in_use);
-		return -EINVAL;
-	}
-	/* Use a simple handle for our "SW" MSI IRQs */
-	irq_set_chip_and_handler(irq, &axxia_msi_chip, handle_simple_irq);
-	set_irq_flags(irq, IRQF_VALID);
-
-	/* Configure PCI device with its MSI address */
-	msg.address_hi = 0x0;
-	msg.address_lo = port->msi_pci_addr + 4*pos;
-	msg.data       = irq;
-	write_msi_msg(irq, &msg);
-
-	return 0;
-}
-
-/*
- * Called by the generic MSI layer to free MSI IRQ.
- */
-void
-arch_teardown_msi_irq(unsigned int irq)
-{
-	int pos = irq - AXXIA_MSI_FIRST;
-
-	if (0 <= pos && pos < NR_IRQS) {
-		clear_bit(pos, msi_irq_in_use);
-		irq_init_desc(irq);
-	}
-}
-
-/**
- * Initialize PCIe controller(s) found in the device tree.
- */
-void __init
-axxia_pcie_init(void)
-{
-	struct device_node *np;
-	int num_ports = 0;
-	void *private_data;
-
-	/* allocate memory */
-	axxia_pciex_ports = kzalloc(PCIE_MAX_PORTS *
-				    sizeof(struct axxia_pciex_port),
-				    GFP_KERNEL);
-	if (!axxia_pciex_ports) {
-		pr_err("PCIE: No memory\n");
-		return;
-	}
-
-
-	for_each_compatible_node(np, NULL, "lsi,plb-pciex") {
-		if (!of_device_is_available(np)) {
-			num_ports++;
-			continue;
-		}
-
-		axxia_probe_pciex_bridge(np);
-		axxia_pcie_hw[num_ports].private_data = &private_data;
-		private_data = &axxia_pd[num_ports];
-		pci_common_init(&axxia_pcie_hw[num_ports]);
-		if (++num_ports == PCIE_MAX_PORTS)
-			break;
-	}
-}
diff --git a/drivers/pci/host/Kconfig b/drivers/pci/host/Kconfig
index 9703240..ded9c47 100644
--- a/drivers/pci/host/Kconfig
+++ b/drivers/pci/host/Kconfig
@@ -9,6 +9,15 @@ config PCI_AXXIA
 	 Enables support for the Axxia PCIe controller. There are three PEI
 	 controllers on X9. Only RootComplex mode is supported.
 
+config PCI_AXXIA_DW
+	bool "AXXIA PCIe controller"
+	depends on ARCH_AXXIA && ARM64
+	default ARCH_AXXIA
+	help
+	 Enables support for the Axxia PCIe DesignWare controller.
+	 There are three PEI controllers on X9. Only RootComplex
+	 mode is supported.
+
 config PCI_DRA7XX
 	bool "TI DRA7xx PCIe controller"
 	select PCIE_DW
diff --git a/drivers/pci/host/Makefile b/drivers/pci/host/Makefile
index 4066b7b..f52dcf7 100644
--- a/drivers/pci/host/Makefile
+++ b/drivers/pci/host/Makefile
@@ -11,7 +11,8 @@ obj-$(CONFIG_PCIE_SPEAR13XX) += pcie-spear13xx.o
 obj-$(CONFIG_PCI_KEYSTONE) += pci-keystone-dw.o pci-keystone.o
 obj-$(CONFIG_PCIE_XILINX) += pcie-xilinx.o
 obj-$(CONFIG_PCI_XGENE) += pci-xgene.o
-obj-$(CONFIG_PCI_AXXIA) += pcie-axxia.o
+obj-$(CONFIG_PCI_AXXIA) += axxia_pci.o
+obj-$(CONFIG_PCI_AXXIA_DW) += pcie-axxia.o
 obj-$(CONFIG_PCI_LAYERSCAPE) += pci-layerscape.o
 obj-$(CONFIG_PCI_VERSATILE) += pci-versatile.o
 obj-$(CONFIG_PCIE_IPROC) += pcie-iproc.o
-- 
1.7.5.4

