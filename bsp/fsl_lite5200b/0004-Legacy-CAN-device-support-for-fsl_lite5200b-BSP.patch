From 238ced7768f9c6ec18ecb8212df5034f64edada4 Mon Sep 17 00:00:00 2001
From: Liang Li <Liang.Li@windriver.com>
Date: Wed, 3 Dec 2008 17:49:07 +0800
Subject: [PATCH] Legacy CAN device support for fsl_lite5200b BSP

The patch is upreved from wrlinux2.0,only two minor modifications plus
to the original patch:

-Adjust match_id table according to dts setting
-Modify deprecated function call class_device_xxx to device_xxx
-Code cleaning,include remove tail blanks and redundant blank lines

Signed-off-by: Zumeng Chen <Zumeng.Chen@windriver.com>
Signed-off-by: Liang Li <Liang.Li@windriver.com>
---
 drivers/Kconfig              |    2 +
 drivers/Makefile             |    1 +
 drivers/can/Kconfig          |   44 +++
 drivers/can/Makefile         |   16 +
 drivers/can/can-base.c       |  182 ++++++++++
 drivers/can/can-base.h       |   60 ++++
 drivers/can/can-dev.c        |  293 ++++++++++++++++
 drivers/can/can-fifo.c       |  161 +++++++++
 drivers/can/can-fifo.h       |   58 ++++
 drivers/can/can-mpc52xx-of.c |  776 ++++++++++++++++++++++++++++++++++++++++++
 drivers/can/can-mpc52xx-of.h |  240 +++++++++++++
 include/linux/major.h        |    1 +
 12 files changed, 1834 insertions(+), 0 deletions(-)
 create mode 100644 drivers/can/Kconfig
 create mode 100644 drivers/can/Makefile
 create mode 100644 drivers/can/can-base.c
 create mode 100644 drivers/can/can-base.h
 create mode 100644 drivers/can/can-dev.c
 create mode 100644 drivers/can/can-fifo.c
 create mode 100644 drivers/can/can-fifo.h
 create mode 100644 drivers/can/can-mpc52xx-of.c
 create mode 100644 drivers/can/can-mpc52xx-of.h

diff --git a/drivers/Kconfig b/drivers/Kconfig
index 59f33fa..67c4029 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -92,6 +92,8 @@ source "drivers/edac/Kconfig"
 
 source "drivers/rtc/Kconfig"
 
+source "drivers/can/Kconfig"
+
 source "drivers/dma/Kconfig"
 
 source "drivers/dca/Kconfig"
diff --git a/drivers/Makefile b/drivers/Makefile
index 39cfe40..0fec76f 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -70,6 +70,7 @@ obj-$(CONFIG_GAMEPORT)		+= input/gameport/
 obj-$(CONFIG_INPUT)		+= input/
 obj-$(CONFIG_I2O)		+= message/
 obj-$(CONFIG_RTC_LIB)		+= rtc/
+obj-$(CONFIG_CAN_DEV)		+= can/
 obj-$(CONFIG_W1)		+= w1/
 obj-$(CONFIG_POWER_SUPPLY)	+= power/
 obj-$(CONFIG_HWMON)		+= hwmon/
diff --git a/drivers/can/Kconfig b/drivers/can/Kconfig
new file mode 100644
index 0000000..6391363
--- /dev/null
+++ b/drivers/can/Kconfig
@@ -0,0 +1,44 @@
+#
+# CAN class/drivers configuration
+#
+
+menu "Controller Area Network"
+
+config CAN_DEV
+	tristate "CAN device class"
+	depends on EXPERIMENTAL
+	default n
+	help
+	  Generic CAN class support. If you say yes here, you will
+	  be allowed to plug one or more CANs to your system. You will
+	  probably want to use your CANs using the /dev interfaces,
+	  which "udev" sets up as /dev/can0 through /dev/canN.
+
+	  This driver can also be built as a module. If so, the module
+	  will be called can_class.
+
+config CAN_PHYS_ENDPOINT_NUM
+	int "CAN endpoint number of all kinds of controllers"
+	depends on CAN_DEV
+	default "2"
+	help
+	  This is the total number of the can endpoint in your platform.
+	  Including all kinds of CAN controllers routed to misc interfaces.
+
+config CAN_DEBUG
+	bool "CAN debug support"
+	depends on CAN_DEV
+	help
+	  Say yes here to enable debugging support in the CAN framework
+	  and individual CAN drivers.
+
+comment "CAN drivers"
+	depends on CAN_DEV
+
+config CAN_DRV_MPC_52xx
+	tristate "MSCAN built in lite5200b"
+	depends on CAN_DEV && (PPC_MPC52xx)
+	help
+	  This driver can also be built as a module. If so, the module
+	  will be called can.
+endmenu
diff --git a/drivers/can/Makefile b/drivers/can/Makefile
new file mode 100644
index 0000000..c44a57f
--- /dev/null
+++ b/drivers/can/Makefile
@@ -0,0 +1,16 @@
+#
+# Makefile for CAN driver.
+#
+
+# Core
+#
+obj-$(CONFIG_CAN_DEV)	+= can-core.o
+
+can-core-y := can-base.o can-fifo.o can-dev.o
+
+# CAN controller drivers
+obj-$(CONFIG_CAN_DRV_MPC_52xx) += can-mpc52xx-of.o
+
+ifeq ($(CONFIG_CAN_DEBUG),y)
+EXTRA_CFLAGS += -DDEBUG
+endif
diff --git a/drivers/can/can-base.c b/drivers/can/can-base.c
new file mode 100644
index 0000000..b1823c3
--- /dev/null
+++ b/drivers/can/can-base.c
@@ -0,0 +1,182 @@
+/*
+ * Controller Aera Network(CAN) driver for Linux 2.6
+ *
+ * Re-written by Zumeng.Chen <zumeng.chen@windriver.com>
+ * Based on peak-linux-driver.3.17.tar.gz.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/fs.h>
+#include <linux/major.h>
+#include <linux/device.h>
+#include <asm/atomic.h>
+#include <linux/types.h>
+
+#include "can-base.h"
+
+/* ------------------------------------------------------------*/
+#define FIFOSIZE 200
+/* Used for minor number allocation */
+static struct can_endpoint_t *can_endpoint[CAN_MAX_ENDPOINTS];
+struct class *can_dev_class;
+
+struct can_endpoint_t *can_endpoint_get_by_minor(unsigned index)
+{
+	if (index < 0 || index >= CAN_MAX_ENDPOINTS)
+		return NULL;
+
+	return can_endpoint[index];
+}
+
+struct can_endpoint_t *can_endpoint_init(int factorTx2Rx)
+{
+	struct can_endpoint_t *endpoint = (struct can_endpoint_t *)
+		kmalloc(sizeof(struct can_endpoint_t), GFP_KERNEL);
+
+	memset((void *)endpoint, 0x0, sizeof(struct can_endpoint_t));
+
+	if (can_fifo_init(&endpoint->txfifo, FIFOSIZE))
+		goto free_exit;
+
+	printk(KERN_INFO "CAN FIFO: %dBytes for Tx\n",
+			FIFOSIZE * (sizeof(struct can_frame)));
+
+	if (!(can_fifo_init(&endpoint->rxfifo, FIFOSIZE*factorTx2Rx)))
+		goto normal_exit;
+
+	printk(KERN_ERR "CAN: %s out of memory\n", __func__);
+	kfree((const void *) endpoint->rxfifo.data);
+free_exit:
+	kfree((const void *) endpoint);
+normal_exit:
+	return endpoint;
+}
+EXPORT_SYMBOL(can_endpoint_init);
+
+void can_endpoint_free(struct can_endpoint_t *endpoint)
+{
+	kfree((const void *) endpoint->txfifo.data);
+	kfree((const void *) endpoint->rxfifo.data);
+	kfree((const void *) endpoint);
+	return ;
+}
+EXPORT_SYMBOL(can_endpoint_free);
+
+/* read a frame from buffer-FIFO */
+can_frame_t *can_endpoint_readframe(struct can_endpoint_t *endpoint,
+		int uid, int  *retval)
+{
+	can_frame_t  *frame = NULL;
+
+	can_fifo_lock(&endpoint->rxfifo);
+	frame = can_fifo_pop(&endpoint->rxfifo, uid, retval);
+	can_fifo_unlock(&endpoint->rxfifo);
+	/*Try to release lock asap. */
+
+	return frame;
+}
+
+/* Try to write a CAN frame from buffer-FIFO to Hard-Tx */
+void  can_endpoint_writeframe(struct can_endpoint_t *endpoint)
+{
+	int sending = 0;
+
+	can_fifo_lock(&endpoint->txfifo);
+	sending = atomic_sub_and_test(1, &endpoint->send_ready_flag);
+	can_fifo_unlock(&endpoint->txfifo);
+
+	if (sending)
+		endpoint->initiate2write(endpoint);
+
+	return;
+}
+
+/* Try to get free frame from buffer-FIFO */
+can_frame_t *can_endpoint_getframe(struct can_endpoint_t *endpoint,
+		int *retval)
+{
+	can_frame_t *frame = NULL;
+
+	can_fifo_lock(&endpoint->txfifo);
+	frame = can_fifo_get(&endpoint->txfifo, retval);
+	can_fifo_unlock(&endpoint->txfifo);
+
+	return frame;
+}
+
+int can_endpoint_adduser(struct can_endpoint_t *endpoint)
+{
+	int uid;
+
+	can_fifo_lock(&endpoint->rxfifo);
+	uid = can_fifo_adduser(&endpoint->rxfifo);
+	can_fifo_unlock(&endpoint->rxfifo);
+
+	return uid;
+}
+
+int can_endpoint_deluser(struct can_endpoint_t *endpoint, int uid)
+{
+	int retval = 0;
+
+	can_fifo_lock(&endpoint->rxfifo);
+	retval = can_fifo_deluser(&endpoint->rxfifo, uid);
+	can_fifo_unlock(&endpoint->rxfifo);
+
+	return retval;
+}
+
+/*  This function will be called by chip-specific implementations;
+ *  return minor number  */
+int can_endpoint_register(struct can_endpoint_t *endpoint)
+{
+	int retval, i, minor = -1;
+
+	/* Allocate a minor number */
+	for (i = 0; i < CAN_MAX_ENDPOINTS; i++) {
+		if (can_endpoint[i] == NULL) {
+			minor = i;
+			break;
+		}
+	}
+
+	if (minor == -1) {
+		printk(KERN_ERR "CAN: Ran out of minor numbers!\n");
+		return -EFAULT;
+	}
+
+	can_endpoint[minor] = endpoint;
+	endpoint->minor = minor;
+	endpoint->txfifo.end[0] = endpoint->txfifo.start;
+
+	init_waitqueue_head(&endpoint->write_queue);
+	init_waitqueue_head(&endpoint->read_queue);
+
+	snprintf(endpoint->name, 7, "can%i", minor);
+	retval = minor;
+
+	printk(KERN_INFO "CAN: Registering CAN endpoint %s\n", endpoint->name);
+
+	/* To create a class device */
+	device_create(can_dev_class, NULL, MKDEV(CAN_MAJOR, minor),
+			NULL, endpoint->name);
+
+	return minor;
+}
+EXPORT_SYMBOL(can_endpoint_register);
+
+/* Unregister a endpoint (device specific module unloaded or USB hotplug) */
+void can_endpoint_unregister(struct can_endpoint_t *endpoint)
+{
+	device_destroy(can_dev_class, MKDEV(CAN_MAJOR, endpoint->minor));
+
+	can_endpoint[endpoint->minor] = NULL;
+	can_endpoint_free(endpoint);
+}
+EXPORT_SYMBOL(can_endpoint_unregister);
+
diff --git a/drivers/can/can-base.h b/drivers/can/can-base.h
new file mode 100644
index 0000000..53711ff
--- /dev/null
+++ b/drivers/can/can-base.h
@@ -0,0 +1,60 @@
+/*
+ * Controller Aera Network(CAN) driver for Linux 2.6
+ *
+ * Re-written by Zumeng.Chen <zumeng.chen@windriver.com>
+ * Based on peak-linux-driver.3.17.tar.gz.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef _LINUX_CAN_H
+#define _LINUX_CAN_H
+
+#include "can-fifo.h"
+
+#define CAN_MAX_ENDPOINTS	CONFIG_CAN_PHYS_ENDPOINT_NUM
+
+#define CAN_SETBAUDRATE				0x01
+#define CAN_IOCHIPRESET				0x02
+#define CAN_MODE					0x03
+
+struct can_endpoint_t {
+	int minor;	/* Minor number of can device */
+	atomic_t send_ready_flag;
+	char name[8];	/* Device name */
+	void *chip;	/* Point to specific chip  */
+	can_fifo_t rxfifo;	/* Rx FIFO */
+	can_fifo_t txfifo;	/* Tx FIFO */
+	wait_queue_head_t read_queue;
+	wait_queue_head_t write_queue;
+	void (*set_bitrate)(struct can_endpoint_t *endpoint, int bitrate);
+	void (*chip_reset)(struct can_endpoint_t *endpoint);
+	void (*set_mode)(struct can_endpoint_t *endpoint, int mode);
+	int (*initiate2write)(struct can_endpoint_t *endpoint);
+};
+
+
+struct can_dev_client {
+	int uid;
+	u32 magic_num;
+	int reserved;
+	struct can_endpoint_t *endpoint;
+};
+
+extern struct class *can_dev_class;
+extern can_frame_t *can_fifo_get(can_fifo_t *fifo, int *retval);
+can_frame_t *can_endpoint_getframe(struct can_endpoint_t *endpoint,
+		int *retval);
+extern int can_endpoint_adduser(struct can_endpoint_t *endpoint);
+extern int can_endpoint_deluser(struct can_endpoint_t *endpoint, int uid);
+extern void can_endpoint_writeframe(struct can_endpoint_t *endpoint) ;
+extern can_frame_t *can_endpoint_readframe(struct can_endpoint_t *endpoint,
+		int uid, int  *retval);
+extern struct can_endpoint_t *can_endpoint_init(int factorTx2Rx);
+extern struct can_endpoint_t *can_endpoint_get_by_minor(unsigned index);
+extern void can_endpoint_free(struct can_endpoint_t *endpoint);
+extern int can_endpoint_register(struct can_endpoint_t *endpoint) ;
+extern void can_endpoint_unregister(struct can_endpoint_t *endpoint) ;
+#endif /* _LINUX_CAN_H */
diff --git a/drivers/can/can-dev.c b/drivers/can/can-dev.c
new file mode 100644
index 0000000..0122900
--- /dev/null
+++ b/drivers/can/can-dev.c
@@ -0,0 +1,293 @@
+/*
+ * Controller Aera Network(CAN) driver for Linux 2.6
+ *
+ * Re-written by Zumeng.Chen <zumeng.chen@windriver.com>
+ * Based on peak-linux-driver.3.17.tar.gz.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/fs.h>
+#include <linux/major.h>
+#include <linux/device.h>
+#include <asm/atomic.h>
+#include <linux/types.h>
+#include <linux/uaccess.h>
+
+#include "can-base.h"
+
+/* --------------CAN File operation functions start --------------------*/
+/* File operation function for CAN endpoint */
+/* CAN Open function . */
+static int can_endpoint_open(struct inode *inode, struct file *file)
+{
+	struct can_endpoint_t *endpoint;
+	int uid = -1, deviceId = iminor(inode);
+	struct can_dev_client *can_client =
+		kmalloc(sizeof(struct can_dev_client), GFP_KERNEL);
+
+	endpoint = (struct can_endpoint_t *)can_endpoint_get_by_minor(deviceId);
+
+	if (endpoint == NULL || can_client == NULL)
+		return -ENODEV;
+
+	if ((endpoint->rxfifo.user_counter) == (u32)CAN_MAX_USER_BIT)
+		return -EBUSY;
+
+	can_client->endpoint = endpoint;
+
+	uid = can_endpoint_adduser(endpoint);
+
+	if (uid < 0)
+		return uid;
+
+	can_client->uid = uid;
+	can_client->magic_num = ((uid) ^ (unsigned int)endpoint);
+
+	printk(KERN_INFO "CAN: Opening endpoint %s (uid %i)\n",
+			endpoint->name, uid);
+
+	file->private_data = (void *) can_client;
+
+	return 0;
+}
+
+/* CAN release function */
+static int can_endpoint_release(struct inode *inode, struct file *file)
+{
+	struct can_dev_client *can_client =
+		(struct can_dev_client *)file->private_data;
+	struct can_endpoint_t *endpoint = can_client->endpoint;
+	int uid = can_client->uid;
+	int retval = -1;
+
+	if (can_client->magic_num != ((uid) ^ (unsigned int)endpoint))
+		printk(KERN_ERR"CAN can_client has been overrun by unknown \
+				reason.\n ");
+
+	printk(KERN_INFO "CAN: /dev/can%i closed\n", can_client->uid);
+
+	retval = can_endpoint_deluser(endpoint, can_client->uid);
+
+	kfree((const void *)can_client);
+	if (retval != 0) {
+		printk(KERN_ERR "CAN: wicked error in %s\n", __func__);
+		retval = -EFAULT;
+	}
+
+	return retval;
+}
+
+/* CAN read function*/
+static ssize_t can_endpoint_read(struct file *file, char *buf,
+		size_t count, loff_t *ppos)
+{
+	struct can_dev_client *can_client =
+		(struct can_dev_client *)file->private_data;
+	struct can_endpoint_t *endpoint = can_client->endpoint;
+	can_frame_t *frame = NULL;
+	int uid = can_client->uid;
+	int retval = -1;
+	size_t index = 0;
+
+	if (can_client->magic_num != ((uid) ^ (unsigned int)endpoint)) {
+		printk(KERN_ERR"CAN can_client has been overrun by unknown \
+				reason.\n ");
+		return -EFAULT;
+	}
+
+	while (count - index >= sizeof(struct can_frame)) {
+
+		frame = can_endpoint_readframe(endpoint, can_client->uid,
+				&retval);
+
+		if (retval == 0) {
+			retval = copy_to_user(buf, frame,
+					sizeof(struct can_frame));
+			if (retval)
+				return -EFAULT;
+			index += sizeof(struct can_frame);
+			buf += sizeof(struct can_frame);
+			continue;
+		}
+
+		if (retval == -ENODATA) {
+			if (file->f_flags & O_NONBLOCK) {
+				if (index == 0)
+					return -EAGAIN;
+				else
+					return index;
+			} else {
+				interruptible_sleep_on(&endpoint->read_queue);
+				if (signal_pending(current)) {
+					if (index == 0)
+						return -EINTR;
+					return index;
+				}
+			}
+		} else {
+			printk(KERN_ERR "%s: Unknow error when read from fifo \
+					retval = %d \n", __func__, retval);
+			return retval;
+		}
+	}
+
+	return index;
+}
+
+/*CAN  write function */
+static ssize_t can_endpoint_write(struct file *file, const char *buf,
+		size_t count, loff_t *ppos)
+{
+	struct can_dev_client *can_client =
+		(struct can_dev_client *)file->private_data;
+	struct can_endpoint_t *endpoint = can_client->endpoint;
+	int uid = can_client->uid;
+	int retval = -1;
+	size_t index = 0;
+
+	if (can_client->magic_num != ((uid) ^ (unsigned int)endpoint)) {
+		printk(KERN_ERR"CAN can_client has been overrun by unknown \
+				reason.\n ");
+		return -EFAULT;
+	}
+
+	while (count - index >= sizeof(struct can_frame)) {
+		can_frame_t *frame = NULL;
+
+		frame = can_endpoint_getframe(endpoint, &retval);
+
+		if (retval == 0) {
+			if (copy_from_user(frame, (can_frame_t *) &buf[index],
+						sizeof(struct can_frame)))
+				return -EFAULT;
+
+			can_endpoint_writeframe(endpoint);
+			index += sizeof(struct can_frame);
+			continue;
+		}
+
+		if (retval == -EBUSY) {
+			if (file->f_flags & O_NONBLOCK) {
+				if (index == 0)
+					return -EAGAIN;
+				else
+					return index;
+			}
+			interruptible_sleep_on(&endpoint->write_queue);
+			if (signal_pending(current)) {
+				if (index == 0)
+					return -EINTR;
+				return index;
+			}
+		} else if (retval < 0) {
+			printk(KERN_ERR "%s: Unknow error when write to fifo \
+					retval = %d \n", __func__, retval);
+			return retval;
+		}
+	}
+
+	return index;
+}
+
+/* CAN IOCTL function*/
+static int can_endpoint_ioctl(struct inode *inode, struct file *file,
+		unsigned int cmd, unsigned long arg)
+{
+	struct can_dev_client *can_client =
+		(struct can_dev_client *)file->private_data;
+	struct can_endpoint_t *endpoint = can_client->endpoint;
+	int uid = can_client->uid;
+	int retval = 0;
+
+	if (can_client->magic_num != ((uid) ^ (unsigned int)endpoint)) {
+		printk(KERN_ERR"CAN can_client has been overrun by unknown \
+				reason.\n ");
+		return -EFAULT;
+	}
+
+	can_fifo_lock(&endpoint->rxfifo);
+	can_fifo_lock(&endpoint->txfifo);
+	switch (cmd) {
+	case CAN_SETBAUDRATE:
+		endpoint->set_bitrate(endpoint, arg);
+		break;
+	case CAN_IOCHIPRESET:
+		if (endpoint->chip_reset != NULL)
+			endpoint->chip_reset(endpoint);
+		else
+			retval = -EPERM;
+		break;
+	case CAN_MODE:
+		if (endpoint->set_mode != NULL)
+			endpoint->set_mode(endpoint, arg);
+		else
+			retval = -EPERM;
+		break;
+	default:
+		retval = -EINVAL;
+	}
+
+	can_fifo_unlock(&endpoint->txfifo);
+	can_fifo_unlock(&endpoint->rxfifo);
+
+	if (retval == -EINVAL)
+		printk(KERN_WARNING "CAN device: Invalid ioctl request.\n");
+
+	return retval;
+}
+
+static struct file_operations can_endpoint_fops = {
+	.owner   = THIS_MODULE,
+	.open    = can_endpoint_open,
+	.release = can_endpoint_release,
+	.write   = can_endpoint_write,
+	.read    = can_endpoint_read,
+	.ioctl   = can_endpoint_ioctl
+};
+/* --------------CAN File operation functions end --------------------*/
+
+
+/* -----------module function start ------------------------------- */
+
+static int __init can_dev_init(void)
+{
+	int err = 0;
+
+	can_dev_class = class_create(THIS_MODULE, "can-dev");
+	if (IS_ERR(can_dev_class)) {
+		err = PTR_ERR(can_dev_class);
+		goto err_exit;
+	}
+
+	/* Register can device operation to VFS*/
+	if (register_chrdev(CAN_MAJOR, "can-dev", &can_endpoint_fops)) {
+		printk(KERN_ERR "Register the CAN major number failed !\n");
+		err = -EFAULT;
+		goto err_destroy_class;
+	}
+
+	printk(KERN_INFO "CAN device class register Version 0.1\n");
+	return 0;
+
+err_destroy_class:
+	class_destroy(can_dev_class);
+err_exit:
+	return err;
+}
+
+static void __exit can_dev_cleanup(void)
+{
+	unregister_chrdev(CAN_MAJOR, "can-dev");
+	class_destroy(can_dev_class);
+}
+
+module_init(can_dev_init);
+module_exit(can_dev_cleanup);
+/* -----------module function end ------------------------------- */
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("MPC52xx CAN Device class support");
diff --git a/drivers/can/can-fifo.c b/drivers/can/can-fifo.c
new file mode 100644
index 0000000..fd2d931
--- /dev/null
+++ b/drivers/can/can-fifo.c
@@ -0,0 +1,161 @@
+/*
+ * Controller Aera Network(CAN) driver for Linux 2.6
+ *
+ * Re-written by Zumeng.Chen <zumeng.chen@windriver.com>
+ * Based on peak-linux-driver.3.17.tar.gz.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/fs.h>
+#include <linux/major.h>
+#include <linux/device.h>
+#include <asm/atomic.h>
+#include <linux/types.h>
+
+#include "can-fifo.h"
+
+/*
+ * It is somewhat confusion, current definition is if only there is a valid
+ * reader, this function return 0; otherwise a negative return value:
+ * This function will be called only if read interrupter happen.
+ */
+static int can_fifo_full_check(can_fifo_t *fifo)
+{
+	int i, retval = 0;
+#ifdef CONFIG_CAN_DEBUG
+	int overrun_bit = fifo->rd_overrun_bit;
+#endif
+
+	for (i = 0; i < CAN_MAX_USER; i++) {
+		if (fifo->end[i] != -1) {
+			if ((fifo->end[i] == fifo->start + 1) ||
+				(fifo->end[i] == 0 &&
+				 fifo->start == fifo->size - 1))
+					fifo->rd_overrun_bit |= (1<<i);
+		}
+	}
+
+#ifdef CONFIG_CAN_DEBUG
+	if (overrun_bit != fifo->rd_overrun_bit)
+		printk(KERN_WARNING "CAN Rx FIFO is full bit = 0x%x\n",
+				fifo->rd_overrun_bit);
+#endif
+	if (fifo->rd_overrun_bit == fifo->user_counter) {
+		printk(KERN_WARNING "CAN Rx FIFO is full bit = 0x%x\n",
+				fifo->rd_overrun_bit);
+		retval =  -ENOSPC;
+	}
+	return retval;
+}
+
+static int  can_fifo_empty(can_fifo_t *fifo, int id)
+{
+	if (fifo->end[id] == -1) {
+		printk(KERN_ERR "%s: Wicked Error Client number %d \n",
+				__func__, id);
+		return -EINVAL;
+	}
+	return (fifo->start == fifo->end[id]) ? (-ENODATA) : 0;
+}
+
+/* FIFO initialization, and end[i] = -1 means that this slot is idle. */
+int can_fifo_init(can_fifo_t *fifo, int size)
+{
+	int i;
+
+	fifo->data = (can_frame_t *)
+		kmalloc(size * sizeof(struct can_frame), GFP_KERNEL);
+
+	if (!fifo->data)
+		return -ENOMEM;
+
+	fifo->size = size;
+	fifo->start = 0;
+	for (i = 0; i < CAN_MAX_USER; i++)
+		fifo->end[i] = -1;
+
+	spin_lock_init(&fifo->lock);
+
+	return 0;
+}
+
+int can_fifo_adduser(can_fifo_t *fifo)
+{
+	int i;
+	for (i = 0; i < CAN_MAX_USER; i++) {
+		if (fifo->end[i] == -1) {
+			fifo->end[i] = fifo->start;
+			fifo->user_counter |= (1<<i);
+			return i;
+		}
+	}
+	return -EBUSY;
+}
+
+int can_fifo_deluser(can_fifo_t *fifo, int id)
+{
+	fifo->end[id] = -1;
+	fifo->user_counter &= ~(1<<id);
+	fifo->rd_overrun_bit &= ~(1<<id);
+	return 0;
+}
+
+/* Push a CAN frame into FIFO */
+int can_fifo_push(can_fifo_t *fifo, can_frame_t *frame)
+{
+	int retval = 0;
+
+	retval = can_fifo_full_check(fifo);
+
+	memcpy(&fifo->data[fifo->start], frame, sizeof(struct can_frame));
+
+	if (++fifo->start == fifo->size)
+		fifo->start = 0;
+	return retval;
+}
+EXPORT_SYMBOL(can_fifo_push);
+
+/* ------------------------------------------------------------------------ */
+/* POP a CAN frame from FIFO */
+can_frame_t *can_fifo_pop(can_fifo_t *fifo, int id, int  *retval)
+{
+	int val = can_fifo_empty(fifo, id);
+	can_frame_t *frame = NULL;
+
+	*retval =  val;
+
+	if (val == 0) {
+		frame = &fifo->data[fifo->end[id]];
+
+		/*There is a implicit expression, and wrap around*/
+		if (++fifo->end[id] ==  fifo->size)
+			fifo->end[id] = 0;
+	}
+
+	return frame;
+}
+EXPORT_SYMBOL(can_fifo_pop);
+
+/* get a CAN free frame pointer from FIFO */
+can_frame_t *can_fifo_get(can_fifo_t *fifo, int *retval)
+{
+	can_frame_t *frame = NULL;
+
+	if ((fifo->end[0] == fifo->start + 1) ||
+			(fifo->end[0] == 0 && fifo->start == fifo->size - 1))
+		*retval =  -EBUSY;
+	else
+		*retval =  0;
+
+	frame = &(fifo->data[fifo->start]);
+	if (++fifo->start == fifo->size)
+		fifo->start = 0;
+	return frame;
+}
+
+
diff --git a/drivers/can/can-fifo.h b/drivers/can/can-fifo.h
new file mode 100644
index 0000000..75c6310
--- /dev/null
+++ b/drivers/can/can-fifo.h
@@ -0,0 +1,58 @@
+/*
+ * Controller Aera Network(CAN) driver for Linux 2.6
+ *
+ * Re-written by Zumeng.Chen <zumeng.chen@windriver.com>
+ * Based on peak-linux-driver.3.17.tar.gz.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef _LINUX_CANFIFO_H
+#define _LINUX_CANFIFO_H
+#include <linux/spinlock.h>
+
+/* Maximum number of connected clients */
+#define CAN_MAX_USER		8
+#define CAN_MAX_USER_BIT	((1<<CAN_MAX_USER) - 1)
+
+typedef struct can_frame {
+	u32 id;    	 /* CAN ID */
+	u8 efi;		/* Extended format identifier  bit */
+	u8 data_len;
+	u8 rtr;     	/* Remote transmission request bit */
+	u8 data[8]; 	/* Message */
+	struct timeval tv; /* Timestamp for frame package */
+} can_frame_t;
+
+/* CAN FIFO structure */
+typedef struct can_fifo {
+	spinlock_t lock;
+	unsigned long flags;	/* Backup for interrupt status */
+	/*read overrun status bit, so CAN_MAX_ENDPOINTS should be
+	 *less than 32-bit*/
+	int rd_overrun_bit;
+	u32 user_counter;	/*can endpoint user counter */
+	int size;
+	int start;			/* Start offset */
+	int end[CAN_MAX_USER];	/* End offset */
+	can_frame_t *data;	/* Buffer loop-pool */
+} can_fifo_t;
+
+static inline void can_fifo_lock(can_fifo_t *fifo)
+{
+	spin_lock_irqsave(&fifo->lock, fifo->flags);
+}
+
+static inline void can_fifo_unlock(can_fifo_t *fifo)
+{
+	spin_unlock_irqrestore(&fifo->lock, fifo->flags);
+}
+
+extern int can_fifo_init(can_fifo_t *fifo, int size);
+extern int can_fifo_adduser(can_fifo_t *fifo);
+extern int can_fifo_deluser(can_fifo_t *fifo, int id);
+extern int can_fifo_push(can_fifo_t *fifo, can_frame_t *frame);
+extern can_frame_t *can_fifo_pop(can_fifo_t *fifo, int id, int  *retval);
+#endif /* _LINUX_CANFIFO_H*/
diff --git a/drivers/can/can-mpc52xx-of.c b/drivers/can/can-mpc52xx-of.c
new file mode 100644
index 0000000..5b8750c
--- /dev/null
+++ b/drivers/can/can-mpc52xx-of.c
@@ -0,0 +1,776 @@
+/*
+ * Can of_devices probe and chip function
+ *
+ * Re-written by Zumeng.Chen <zumeng.chen@windriver.com>
+ * Based on peak-linux-driver.3.17.tar.gz.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/io.h>
+#include <asm/prom.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+
+#include "can-base.h"
+#include "can-mpc52xx-of.h"
+
+
+
+/* -------------------chip function  start----------------------------------*/
+/*
+ * Register a mpc52xx chip with the chip layer.
+ * And there may be ugly deadloop here, it should be fixed at somepoint
+ */
+static int mscan_init(struct can_mpc52xx_chip_t  *chip)
+{
+	struct mpc52xx_mscan *regs = chip->regs;
+
+#ifdef CONFIG_CAN_DEBUG
+	printk(KERN_INFO"MSCAN: Initializing CAN chip bitrate=0x%x:\n",
+		chip->wBTR0BTR1);
+#endif
+
+	/* Enable MSCAN module. */
+	regs->canctl1 |= MPC52xx_MSCAN_CANE;
+	udelay(100);
+
+	/* Switch to sleep mode */
+	regs->canctl0 |= MPC52xx_MSCAN_SLPRQ;
+	while (!(regs->canctl1 & MPC52xx_MSCAN_SLPAK))
+		;
+
+	/* Switch to initialization mode. */
+	regs->canctl0 |= MPC52xx_MSCAN_INITRQ;
+	while (!(regs->canctl1 & MPC52xx_MSCAN_INITAK))
+		;
+
+	/* Set listen-only mode if needed. */
+	if (chip->ucListenOnly)
+		regs->canctl1 |= MPC52xx_MSCAN_LISTEN;
+	else
+		regs->canctl1 &= ~MPC52xx_MSCAN_LISTEN;
+
+	/* Set endpoint timings.	 */
+	regs->canbtr0 = (chip->wBTR0BTR1 >> 8);
+	regs->canbtr1 = (u8)chip->wBTR0BTR1;
+
+	/*Set internal timer */
+	regs->canctl0 |= MPC52xx_MSCAN_TIME;
+
+	/*IP endpoint as clock source. It looks this bit is not used
+	 * in lite5200b*/
+	regs->canctl1 &= (~MPC52xx_MSCAN_CLKSRC);
+
+	if (chip->loopbackmode)
+		regs->canctl1 |= MPC52xx_MSCAN_LOOPB;
+	else
+		regs->canctl1 &= ~MPC52xx_MSCAN_LOOPB;
+
+	/* Configure MSCAN to accept all incoming messages. */
+	regs->canidar0 = regs->canidar1 = 0x00;
+	regs->canidar2 = regs->canidar3 = 0x00;
+	regs->canidmr0 = regs->canidmr1 = 0xFF;
+	regs->canidmr2 = regs->canidmr3 = 0xFF;
+	regs->canidar4 = regs->canidar5 = 0x00;
+	regs->canidar6 = regs->canidar7 = 0x00;
+	regs->canidmr4 = regs->canidmr5 = 0xFF;
+	regs->canidmr6 = regs->canidmr7 = 0xFF;
+	regs->canidac &= ~(MPC52xx_MSCAN_IDAM0 | MPC52xx_MSCAN_IDAM1);
+
+	/* Switch back to normal mode.	 */
+	regs->canctl0 &= ~MPC52xx_MSCAN_INITRQ;
+	regs->canctl0 &= ~MPC52xx_MSCAN_SLPRQ;
+	while ((regs->canctl1 & MPC52xx_MSCAN_INITAK) ||
+	      (regs->canctl1 & MPC52xx_MSCAN_SLPAK))
+		;
+
+	/* Enable receive interrupts.	 */
+	regs->canrier |= MPC52xx_MSCAN_OVRIE | MPC52xx_MSCAN_RXFIE;
+
+#ifdef CONFIG_CAN_DEBUG
+	printk(KERN_INFO "MSCAN: bitrate= 0x%x %x ctl1=0x%x\n",
+		regs->canbtr0, regs->canbtr1, regs->canctl1);
+#endif
+	return 0;
+}
+
+
+
+/* Read CAN data from the controller. Called from the interrupt handler on
+  * receive interrupt. */
+static int mscan_read(struct can_mpc52xx_chip_t *chip, can_frame_t *frame)
+{
+	struct mpc52xx_mscan *regs = chip->regs;
+	volatile ID        local;
+	u8                 ucLen;
+	int                i;
+	int                result  = 0;
+
+#ifdef CONFIG_CAN_DEBUG
+	printk(KERN_INFO"%s: mscan_read() \n", DEVICE_NAME);
+#endif
+	frame->rtr = 0;
+
+	/* Filter out extended messages in non extended mode. */
+	if (!chip->bExtended && (regs->canrxfg.idr[1] & BUFFER_EXTENDED)) {
+#ifdef CONFIG_CAN_DEBUG
+		printk(KERN_INFO"%s %d Extended format error\n",
+				__func__, __LINE__);
+#endif
+		result = -ENOSPC;
+		goto Done;
+	} else {
+		if (regs->canrxfg.idr[1] & BUFFER_EXTENDED) {
+			/* Extended ID. */
+			frame->efi = MSGTYPE_EXTENDED;
+
+			local.ucID[0] = regs->canrxfg.idr[0];
+			local.ucID[1] = regs->canrxfg.idr[1];
+			local.ucID[2] = regs->canrxfg.idr[4];
+			local.ucID[3] = regs->canrxfg.idr[5];
+
+			/* Shift data in 'local' * to remove the SRR and
+			 * IDE bits. */
+			local.dwID = (local.dwID & 0xFFE00000) |
+				((local.dwID & 0x0007FFFF) << 2);
+			local.dwID >>= 3;
+			frame->id = local.dwID;
+
+			if (regs->canrxfg.idr[5] & BUFFER_EXT_RTR)
+				frame->rtr = MSGTYPE_RTR;
+		} else {
+			/* Standart ID. */
+			frame->efi  = MSGTYPE_STANDARD;
+
+			local.ucID[0] = regs->canrxfg.idr[0];
+			local.ucID[1] = regs->canrxfg.idr[1];
+
+			local.dwID >>= 21;
+			frame->id = local.dwID;
+
+			if (regs->canrxfg.idr[1] & BUFFER_STD_RTR)
+				frame->rtr = MSGTYPE_RTR;
+		}
+
+		do_gettimeofday(&frame->tv);
+		/* Get data length.	 */
+		ucLen = regs->canrxfg.dlr & 0x0F;
+		frame->data_len = ucLen;
+
+		/* Read data.	 */
+		for (i = 0; i < ucLen; i++)
+			frame->data[i] = regs->canrxfg.dsr[i + (i / 2) * 2];
+
+	}
+
+	result = 0;
+Done:
+	return result;
+}
+
+/* sent a CAN frame to a free slot */
+static void mscan_write(struct can_mpc52xx_chip_t *chip, int bufslot,
+		can_frame_t *frame)
+{
+	struct mpc52xx_mscan *regs = chip->regs;
+	volatile ID local;
+	int i ;
+
+	regs->cantier &= ~(1 << bufslot);
+	regs->cantbsel = 1 << bufslot;
+
+	local.dwID = frame->id;
+
+	if (frame->efi & MSGTYPE_EXTENDED) {
+		local.dwID <<= 3;
+		regs->cantxfg.idr[0]  = local.ucID[0];
+
+		/* Write bits [20..18] of the ID. */
+		regs->cantxfg.idr[1]  = local.ucID[1];
+
+		/* set SRR and IDE bits	 */
+		regs->cantxfg.idr[1] |= 0x18;
+
+		/* Write [17..15] bits of the ID. */
+		local.dwID >>= 2;
+		regs->cantxfg.idr[1] &= ~0x07;
+		regs->cantxfg.idr[1] |= (local.ucID[1] & 0x07);
+
+		/* Now write the rest of the ID. */
+		regs->cantxfg.idr[4]  = local.ucID[2];
+		regs->cantxfg.idr[5]  = local.ucID[3];
+
+		if (frame->rtr & MSGTYPE_RTR)
+			regs->cantxfg.idr[5] |= 0x1;
+		else
+			regs->cantxfg.idr[5] &= ~0x1;
+
+	} else {
+		local.dwID   <<= 21;
+		regs->cantxfg.idr[0]  = local.ucID[0];
+		regs->cantxfg.idr[1]  = local.ucID[1];
+
+		/* Clear IDE.	 */
+		regs->cantxfg.idr[1] &= ~0x8;
+
+		if (frame->rtr & MSGTYPE_RTR)
+			regs->cantxfg.idr[1] |= 0x10;
+		else
+			regs->cantxfg.idr[1] &= ~0x10;
+
+	}
+
+	for (i = 0; i < frame->data_len; i++)
+		regs->cantxfg.dsr[i + (i / 2) * 2] = frame->data[i];
+
+	regs->cantxfg.dlr = frame->data_len;
+
+	regs->cantxfg.tbpr = 0;	/* all messages have the same prio */
+
+	/* Trigger transmission. */
+	regs->cantflg = (1 << bufslot);
+
+	/* Enable interrupt.*/
+	regs->cantier |= (1 << bufslot);
+	wmb();
+
+#ifdef CONFIG_CAN_DEBUG
+	printk(KERN_ERR "%s: mscan_write() OVER! \n", DEVICE_NAME);
+#endif
+	return;
+}
+
+/* This function calculates BTR0 BTR1 values for a given bitrate.
+ * Heavily based on mscan_bitrate(), which in turn is based
+ * on work by Arnaud Westenberg.
+ *
+ * Set communication parameters.
+ * baud rate in Hz
+ * input clock frequency of MSCAN in Hz
+ * sjw synchronization jump width (0-3) prescaled clock cycles
+ * sampl_pt sample point in % (0-100) sets (TSEG1+2)/(TSEG1+TSEG2+3)
+ * ratio
+ */
+static u16 mscan_bitrate(u32 rate)
+{
+	int best_error = 1000000000;
+	int error;
+	int best_tseg = 0, best_brp = 0, best_rate = 0, brp = 0;
+	int tseg = 0, tseg1 = 0, tseg2 = 0;
+
+	/* Board info structure is not available to modules. */
+	int clock = 66000000;
+	u16 wBTR0BTR1;
+	int sjw = 0;
+	int sampl_pt = 90;
+	int flags = 0;
+
+	/* some heuristic specials */
+	if (rate > ((1000000 + 500000) / 2))
+		sampl_pt = 75;
+
+	if (rate < ((12500 + 10000) / 2))
+		sampl_pt = 75;
+
+	if (rate < ((100000 + 125000) / 2))
+		sjw = 1;
+
+	/* tseg even = round down, odd = round up */
+	for (tseg = (0 + 0 + 2) * 2;
+	     tseg <= (MAX_TSEG2 + MAX_TSEG1 + 2) * 2 + 1;
+	     tseg++) {
+		brp = clock / ((1 + tseg / 2) * rate) + tseg % 2;
+		if ((brp == 0) || (brp > 64))
+			continue;
+
+		error = rate - clock / (brp * (1 + tseg / 2));
+		if (error < 0)
+			error = -error;
+
+		if (error <= best_error) {
+			best_error = error;
+			best_tseg = tseg/2;
+			best_brp = brp-1;
+			best_rate = clock/(brp*(1+tseg/2));
+		}
+	}
+
+	if (best_error && (rate / best_error < 10)) {
+		printk(KERN_ERR "%s: bitrate %d is not possible with %d Hz \
+				clock\n", DEVICE_NAME, rate, clock);
+		return 0;
+	}
+
+	tseg2 = best_tseg - (sampl_pt * (best_tseg + 1)) / 100;
+
+	if (tseg2 < 0)
+		tseg2 = 0;
+
+	if (tseg2 > MAX_TSEG2)
+		tseg2 = MAX_TSEG2;
+
+	tseg1 = best_tseg - tseg2 - 2;
+
+	if (tseg1 > MAX_TSEG1) {
+		tseg1 = MAX_TSEG1;
+		tseg2 = best_tseg - tseg1 - 2;
+	}
+
+/*
+ * MSCAN has the sjw bits encoded not in the lexicographical
+ * order, unlike the sja1000. We have to asjust for that here.
+ */
+	if (sjw && sjw < 3)
+		sjw ^= 3;/* 01 ==> 10  * 10 ==> 01	 */
+
+	wBTR0BTR1 = ((sjw << 6 | best_brp) << 8) |
+		(((flags & BTR1_SAM) != 0) << 7 | tseg2 << 4 | tseg1);
+
+#ifdef CONFIG_CAN_DEBUG
+	printk(KERN_INFO"bitrate %d : 0x%x\n", rate, wBTR0BTR1);
+#endif
+
+	return wBTR0BTR1;
+}
+
+
+/* Register a mpc52xx chip with the chip layer */
+static int mscan_set_mode(struct can_mpc52xx_chip_t *chip, int mode)
+{
+	struct mpc52xx_mscan *regs = chip->regs;
+	u8 canrier = regs->canrier;
+	u8 cantier = regs->cantier;
+
+#ifdef CONFIG_CAN_DEBUG
+	printk(KERN_INFO "MSCAN: mscan_set_mode start ...\n");
+#endif
+
+	regs->canrier = 0;
+	regs->cantier = 0;
+
+	/* Switch to sleep mode */
+	regs->canctl0 |= MPC52xx_MSCAN_SLPRQ;
+	while (!(regs->canctl1 & MPC52xx_MSCAN_SLPAK))
+		;
+
+	/* Switch to initialization mode. */
+	regs->canctl0 |= MPC52xx_MSCAN_INITRQ;
+	while (!(regs->canctl1 & MPC52xx_MSCAN_INITAK))
+		;
+
+	switch (mode) {
+	case MPC52xx_MSCAN_LISTEN:
+		cantier = 0;
+		regs->canctl1 |= MPC52xx_MSCAN_LISTEN;/* Set listen-only mode */
+		break;
+	case MPC52xx_MSCAN_LOOPB:
+		regs->canctl1 |= MPC52xx_MSCAN_LOOPB;
+		break;
+	case MPC52xx_MSCAN_NORMAL:
+		regs->canctl1 &= ~MPC52xx_MSCAN_LISTEN;
+		regs->canctl1 &= ~MPC52xx_MSCAN_LOOPB;
+		break;
+	case MPC52xx_MSCAN_BITRATE:
+		regs->canbtr0 = (chip->wBTR0BTR1 >> 8);
+		regs->canbtr1 = (u8)chip->wBTR0BTR1;
+		break;
+	default:
+		printk(KERN_ERR "MSCAN: mscan_set_mode Unknown mode = 0x%x.\n",
+				mode);
+	}
+
+	/* Switch back to normal mode.	 */
+	regs->canctl0 &= ~MPC52xx_MSCAN_INITRQ;
+	regs->canctl0 &= ~MPC52xx_MSCAN_SLPRQ;
+	while ((regs->canctl1 & MPC52xx_MSCAN_INITAK) ||
+	      (regs->canctl1 & MPC52xx_MSCAN_SLPAK))
+		;
+
+	/* Enable receive interrupts.	 */
+	regs->canrier = canrier;
+	regs->cantier = cantier;
+
+#ifdef CONFIG_CAN_DEBUG
+	printk(KERN_INFO "MSCAN: mscan_set_mode end.\n");
+#endif
+
+	return 0;
+}
+
+/* -------------------chip function  end-----------------------------------*/
+
+
+/* -------------------endpoint function start ---------------------------- */
+static int can_mpc52xx_initiate_read(struct can_endpoint_t *endpoint)
+{
+	struct can_mpc52xx_chip_t *chip =
+		(struct can_mpc52xx_chip_t *) endpoint->chip;
+	can_frame_t frame;
+
+	if (endpoint->rxfifo.user_counter == 0) {
+		/*Though there is no carer, so this frame should be throwed
+		 * away */
+#ifdef CONFIG_CAN_DEBUG
+		printk(KERN_WARNING "CAN: /dev/can%d no reader attached.\n",
+				endpoint->minor);
+#endif
+		return -EAGAIN;
+	}
+
+	mscan_read(chip, &frame);
+
+	/* forward from frame to fifo.*/
+	return can_fifo_push(&endpoint->rxfifo, &frame);
+}
+
+/* Initiate a CAN endpoint write operation */
+static int can_mpc52xx_initiate2write(struct can_endpoint_t *endpoint)
+{
+	struct can_mpc52xx_chip_t *chip =
+		(struct can_mpc52xx_chip_t *) endpoint->chip;
+	struct mpc52xx_mscan *regs  = chip->regs;
+	can_frame_t *frame = NULL;
+	int   buf, used = 0;
+	int retval = 0;
+
+	can_fifo_lock(&endpoint->txfifo);
+	/* Try to find an empty buffer and send a frame  */
+	for (buf = 0; buf < 3; buf++) {
+		if (!(regs->cantflg & (1 << buf)))
+				continue;/* Buffer is busy. */
+
+		frame = can_fifo_pop(&endpoint->txfifo, 0, &retval);
+
+		if (retval == 0) {
+			mscan_write(endpoint->chip, buf, frame);
+			used |= (1 << buf);
+		} else {
+#ifdef CONFIG_CAN_DEBUG
+			printk(KERN_INFO"No frame ready to be sent\n");
+#endif
+			break; /* There buffer is empty do nothing */
+		}
+	}
+
+	can_fifo_unlock(&endpoint->txfifo);
+#ifdef CONFIG_CAN_DEBUG
+	printk(KERN_INFO"%s used = 0x%x t\n", __func__, used);
+#endif
+	return used;
+}
+
+/* Set the endpoint timing register */
+static void can_mpc52xx_set_bitrate(struct can_endpoint_t *endpoint,
+		int bitrate)
+{
+	struct can_mpc52xx_chip_t *chip =
+		(struct can_mpc52xx_chip_t *) endpoint->chip;
+	u16 btr0btr1 = 0;
+
+	btr0btr1 = mscan_bitrate(bitrate);
+
+	chip->wBTR0BTR1 = btr0btr1;
+	mscan_set_mode(chip, MPC52xx_MSCAN_BITRATE);
+
+	printk(KERN_INFO "MPC52xx: Setting bitrate %d btr0btr1=%x to can%d\n",
+			bitrate, btr0btr1, endpoint->minor);
+
+	return;
+}
+
+/* set the chip to mode */
+static void can_mpc52xx_set_mode(struct can_endpoint_t *endpoint, int mode)
+{
+	struct can_mpc52xx_chip_t  *chip = endpoint->chip;
+
+	switch (mode) 	{
+	case MPC52xx_MSCAN_LISTEN:
+		chip->loopbackmode = 0;
+		chip->ucListenOnly = 1;
+		break;
+	case MPC52xx_MSCAN_LOOPB:
+		chip->loopbackmode = 1;
+		chip->ucListenOnly = 0;
+		break;
+	case MPC52xx_MSCAN_NORMAL:
+	default:
+		chip->loopbackmode = 0;
+		chip->ucListenOnly = 0;
+	}
+
+	mscan_set_mode(chip, mode);
+
+	printk(KERN_INFO "MPC52xx: set_mode %s to CAN%d \n",
+		(mode == MPC52xx_MSCAN_LOOPB ? "LOOPBACK" :
+		(mode == MPC52xx_MSCAN_LISTEN ? "ListenOnly" :
+		(mode == MPC52xx_MSCAN_NORMAL ? "Normal" : "Unkown"))),
+		endpoint->minor);
+
+	return;
+}
+
+/*chip resest function */
+static void can_mpc52xx_reset(struct can_endpoint_t *endpoint)
+{
+	struct can_mpc52xx_chip_t  *chip = endpoint->chip;
+	struct mpc52xx_mscan *regs = chip->regs;
+
+#ifdef CONFIG_CAN_DEBUG
+	printk(KERN_INFO "MSCAN: can_mpc52xx_reset start ...\n");
+#endif
+
+	regs->canrier = 0;
+	regs->cantier = 0;
+	chip->loopbackmode = 0;
+	chip->ucListenOnly = 0;
+	mscan_init(chip);
+
+#ifdef CONFIG_CAN_DEBUG
+	printk(KERN_INFO "MSCAN: can_mpc52xx_reset end.\n");
+#endif
+	return;
+}
+
+/*  Register a mpc52xx chip and provide an interface to the can-base layer */
+static int can_mpc52xx_register(struct can_mpc52xx_chip_t *chip)
+{
+	int retval = 0;
+	struct can_endpoint_t *endpoint = chip->endpoint;
+
+	retval = can_endpoint_register(endpoint);
+
+	if (retval < 0) {
+		printk(KERN_ERR "CAN: wicked error from out of device endpoint");
+		return retval;
+	}
+
+	endpoint->chip = chip;
+	endpoint->initiate2write = can_mpc52xx_initiate2write;
+	endpoint->set_bitrate = can_mpc52xx_set_bitrate;
+	endpoint->chip_reset = can_mpc52xx_reset;
+	endpoint->set_mode = can_mpc52xx_set_mode;
+
+	return retval;
+}
+/* -------------------endpoint function end ---------------------------------*/
+
+
+/* -------------------OF function start -------------------------------------*/
+/*This function may be re-entry, so don't use static melta. */
+static irqreturn_t can_mpc52xx_interrupter(int irq, void *dev_id,
+		struct pt_regs *pt_regs)
+{
+	struct can_mpc52xx_chip_t  *chip =
+		(struct can_mpc52xx_chip_t *)dev_id;
+	struct can_endpoint_t *endpoint = chip->endpoint;
+	struct mpc52xx_mscan *regs  = chip->regs;
+	unsigned long flags;
+	int  err;
+	int  wr_wakeup   = 0;
+	int  rd_wakeup   = 0;
+	u8  t_status, r_status, used = 0;
+
+	spin_lock_irqsave(&chip->lock, flags);
+	t_status = regs->cantflg;
+	r_status = regs->canrflg;
+
+#ifdef CONFIG_CAN_DEBUG
+	printk(KERN_ERR "%s: can_mpc52xx_interrupter() r = 0x%x t = 0x%x\n",
+			DEVICE_NAME, r_status, t_status);
+#endif
+	if (r_status & MPC52xx_MSCAN_RXF) {
+		/* Handle receiption. */
+		err = can_mpc52xx_initiate_read(endpoint);
+		if (err) {
+			chip->error_counter++;
+			chip->error_status |= CAN_ERR_QOVERRUN;
+		}
+		rd_wakeup = 1;
+	}
+
+	if (t_status & MPC52xx_MSCAN_TXE) {
+		/* reading doc to be sure that it is needed */
+		regs->cantier &= ~(MPC52xx_MSCAN_TXIE & t_status);
+		used = can_mpc52xx_initiate2write(endpoint);
+		wr_wakeup = 1;
+		/* Signal to:  there is already idle sent slot.	*/
+		if ((t_status & MPC52xx_MSCAN_TXE) & (~(used)))
+			atomic_set(&endpoint->send_ready_flag, 1);
+
+	}
+
+	if (r_status & MPC52xx_MSCAN_OVRIF) {
+		/* Handle data overrun.	 */
+		chip->error_status |= CAN_ERR_QOVERRUN;
+		rd_wakeup = 1;
+		chip->error_counter++;
+	}
+
+	if (wr_wakeup)
+		wake_up_interruptible(&endpoint->write_queue);
+
+	if (rd_wakeup)
+		wake_up_interruptible(&endpoint->read_queue);
+
+	/* Ack receive interrupter */
+	regs->canrflg = r_status;
+	spin_unlock_irqrestore(&chip->lock, flags);
+	return IRQ_HANDLED;
+}
+
+static int __devinit can_mpc52xx_probe(struct of_device *of_dev,
+		const struct of_device_id *match)
+{
+	struct resource res;
+	struct device_node *dp = of_dev->node;
+	struct can_mpc52xx_chip_t *chip = NULL;
+	void __iomem *base = NULL;
+	int irq, err = -1, minor;
+
+	if (of_address_to_resource(dp, 0, &res)) {
+		dev_err(&of_dev->dev, "Can't get the can mapping!\n");
+		err = -EINVAL;
+		goto err_out;
+	}
+
+#ifdef CONFIG_CAN_DEBUG
+	printk(KERN_INFO"mpc52xx can device: %.8llx at %.8llx\n",
+			(unsigned long long)res.end - res.start + 1,
+			(unsigned long long)res.start);
+#endif
+
+	irq = irq_of_parse_and_map(dp, 0);
+
+	if (irq < 0) {
+		err = -ENXIO;
+		goto err_out;
+	}
+
+	base = ioremap((phys_addr_t)res.start, (res.end - res.start + 1));
+
+	if (!base) {
+		printk(KERN_ERR "CAN-mpc52xx - failed to map controller\n");
+		err = -ENXIO;
+		goto err_out;
+	}
+
+	chip = (struct can_mpc52xx_chip_t *)
+		kmalloc(sizeof(struct can_mpc52xx_chip_t), GFP_KERNEL);
+
+	if (chip == NULL) {
+		err = -ENOMEM;
+		goto ioerr_out;
+	}
+
+	chip->irq = irq;
+	chip->regs = (struct mpc52xx_mscan *)base;
+	chip->bitrate = 1000000;
+	chip->wBTR0BTR1 = mscan_bitrate(chip->bitrate);
+	chip->error_status   = 0;
+	chip->bExtended    = 1;
+	chip->ucListenOnly = 0;
+	chip->loopbackmode = 0;
+	spin_lock_init(&chip->lock);
+	dev_set_drvdata(&of_dev->dev, chip);
+
+	/* Try to get can endpoint pointer, here 2 is a speed ratio of Tx/Rx*/
+	chip->endpoint = can_endpoint_init(2);
+	if (chip->endpoint == NULL) {
+		err = -ENOMEM;
+		goto free_chip_out ;
+	}
+
+	minor = can_mpc52xx_register(chip);
+	if (minor < 0) {
+		can_endpoint_free(chip->endpoint);
+		goto free_chip_out;
+	}
+
+	err = request_irq(irq, (irq_handler_t)can_mpc52xx_interrupter,
+			IRQF_SHARED, "can-mpc52xx", chip);
+	if (err < 0) {
+			printk(KERN_ERR "can-mpc52xx - failed to attach\
+					interrupt\n");
+			err = -ENXIO;
+			goto free_chip_out;
+	}
+
+	mscan_init(chip);
+	/* There is no ongoing send */
+	atomic_set(&chip->endpoint->send_ready_flag , 1);
+
+	printk(KERN_INFO "CAN:Irq %d BaudR %d %s %s on /dev/can%d.\n",
+		irq, chip->bitrate, (chip->bExtended == 1) ? "Ext." : "Std.",
+			(chip->loopbackmode == 1) ? "LB" : "Normal", minor);
+	return 0;
+
+free_chip_out:
+	kfree(chip);
+ioerr_out:
+	iounmap(base);
+err_out:
+	return err;
+}
+
+static int can_mpc52xx_remove(struct of_device *of_dev)
+{
+	struct can_mpc52xx_chip_t *chip =
+		(struct can_mpc52xx_chip_t *)dev_get_drvdata(&of_dev->dev);
+
+	can_endpoint_unregister(chip->endpoint);
+	dev_set_drvdata(&of_dev->dev, NULL);
+	if (chip->irq != 0)
+		free_irq(chip->irq, chip);
+
+	iounmap(chip->regs);
+	kfree(chip);
+
+	return 0;
+}
+
+
+static struct of_device_id can_mpc52xx_match[] = {
+	{
+		.compatible	= "fsl,mpc5200b-mscan"
+	},
+	{ },
+};
+
+MODULE_DEVICE_TABLE(of, can_mpc52xx_match);
+
+static struct of_platform_driver can_mpc52xx_driver = {
+	.name		= "mpc52xx-mscan",
+	.match_table	= can_mpc52xx_match,
+	.probe		= can_mpc52xx_probe,
+	.remove		= can_mpc52xx_remove,
+};
+
+static int __init mpc52xx_can_init_module(void)
+{
+	return of_register_platform_driver(&can_mpc52xx_driver);
+}
+
+static void __exit mpc52xx_can_cleanup_module(void)
+{
+	of_unregister_platform_driver(&can_mpc52xx_driver);
+}
+
+/* -------------------OF function end -------------------------------- */
+
+module_init(mpc52xx_can_init_module);
+module_exit(mpc52xx_can_cleanup_module);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("MPC52xx can driver for OF");
diff --git a/drivers/can/can-mpc52xx-of.h b/drivers/can/can-mpc52xx-of.h
new file mode 100644
index 0000000..d077f72
--- /dev/null
+++ b/drivers/can/can-mpc52xx-of.h
@@ -0,0 +1,240 @@
+/*
+ * MSCAN defines
+ * from mpc52xx.h
+ *
+ *  Maintainer : Sylvain Munaut <tnt@246tNt.com>
+ *
+ *  Copyright (C) 2004 Sylvain Munaut <tnt@246tNt.com>
+ *  Copyright (C) 2003 MontaVista, Software, Inc.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#ifndef __MPC52xx_MSCAN_H__
+#define __MPC52xx_MSCAN_H__
+
+#define DEVICE_NAME "mpc52xx-mscan"
+
+/* MSCAN control register 0 (CANCTL0) bits */
+#define MPC52xx_MSCAN_RXFRM	0x80
+#define MPC52xx_MSCAN_RXACT	0x40
+#define MPC52xx_MSCAN_CSWAI	0x20
+#define MPC52xx_MSCAN_SYNCH	0x10
+#define MPC52xx_MSCAN_TIME	0x08
+#define MPC52xx_MSCAN_WUPE	0x04
+#define MPC52xx_MSCAN_SLPRQ	0x02
+#define MPC52xx_MSCAN_INITRQ	0x01
+
+/* MSCAN control register 1 (CANCTL1) bits */
+#define MPC52xx_MSCAN_CANE	0x80
+#define MPC52xx_MSCAN_CLKSRC	0x40
+#define MPC52xx_MSCAN_LOOPB	0x20
+#define MPC52xx_MSCAN_LISTEN	0x10
+#define MPC52xx_MSCAN_WUPM	0x04
+#define MPC52xx_MSCAN_SLPAK	0x02
+#define MPC52xx_MSCAN_INITAK	0x01
+
+/* MSCAN receiver flag register (CANRFLG) bits */
+#define MPC52xx_MSCAN_WUPIF	0x80
+#define MPC52xx_MSCAN_CSCIF	0x40
+#define MPC52xx_MSCAN_RSTAT1	0x20
+#define MPC52xx_MSCAN_RSTAT0	0x10
+#define MPC52xx_MSCAN_TSTAT1	0x08
+#define MPC52xx_MSCAN_TSTAT0	0x04
+#define MPC52xx_MSCAN_OVRIF	0x02
+#define MPC52xx_MSCAN_RXF		0x01
+
+/* MSCAN receiver interrupt enable register (CANRIER) bits */
+#define MPC52xx_MSCAN_WUPIE	0x80
+#define MPC52xx_MSCAN_CSCIE	0x40
+#define MPC52xx_MSCAN_RSTATE1	0x20
+#define MPC52xx_MSCAN_RSTATE0	0x10
+#define MPC52xx_MSCAN_TSTATE1	0x08
+#define MPC52xx_MSCAN_TSTATE0	0x04
+#define MPC52xx_MSCAN_OVRIE	0x02
+#define MPC52xx_MSCAN_RXFIE	0x01
+
+/* MSCAN transmitter flag register (CANTFLG) bits */
+#define MPC52xx_MSCAN_TXE2	0x04
+#define MPC52xx_MSCAN_TXE1	0x02
+#define MPC52xx_MSCAN_TXE0	0x01
+#define MPC52xx_MSCAN_TXE	(MPC52xx_MSCAN_TXE2 | MPC52xx_MSCAN_TXE1 | \
+				 MPC52xx_MSCAN_TXE0)
+
+/* MSCAN transmitter interrupt enable register (CANTIER) bits */
+#define MPC52xx_MSCAN_TXIE2	0x04
+#define MPC52xx_MSCAN_TXIE1	0x02
+#define MPC52xx_MSCAN_TXIE0	0x01
+#define MPC52xx_MSCAN_TXIE	(MPC52xx_MSCAN_TXIE2 | MPC52xx_MSCAN_TXIE1 | \
+				 MPC52xx_MSCAN_TXIE0)
+
+/* MSCAN transmitter message abort request (CANTARQ) bits */
+#define MPC52xx_MSCAN_ABTRQ2	0x04
+#define MPC52xx_MSCAN_ABTRQ1	0x02
+#define MPC52xx_MSCAN_ABTRQ0	0x01
+
+/* MSCAN transmitter message abort ack (CANTAAK) bits */
+#define MPC52xx_MSCAN_ABTAK2	0x04
+#define MPC52xx_MSCAN_ABTAK1	0x02
+#define MPC52xx_MSCAN_ABTAK0	0x01
+
+/* MSCAN transmit buffer selection (CANTBSEL) bits */
+#define MPC52xx_MSCAN_TX2	0x04
+#define MPC52xx_MSCAN_TX1	0x02
+#define MPC52xx_MSCAN_TX0	0x01
+
+/* MSCAN ID acceptance control register (CANIDAC) bits */
+#define MPC52xx_MSCAN_IDAM1	0x20
+#define MPC52xx_MSCAN_IDAM0	0x10
+#define MPC52xx_MSCAN_IDHIT2	0x04
+#define MPC52xx_MSCAN_IDHIT1	0x02
+#define MPC52xx_MSCAN_IDHIT0	0x01
+
+#define MPC52xx_MSCAN_NORMAL	0x00
+#define MPC52xx_MSCAN_BITRATE	0x01
+
+struct mscan_buffer {
+	volatile u8  idr[0x8];		/* 0x00 */
+	volatile u8  dsr[0x10];		/* 0x08 */
+	volatile u8  dlr;		/* 0x18 */
+	/* This register is not applicable for receive buffers */
+	volatile u8  tbpr;		/* 0x19 */
+	volatile u16 rsrv1;		/* 0x1A */
+	volatile u8  tsrh;		/* 0x1C */
+	volatile u8  tsrl;		/* 0x1D */
+	volatile u16 rsrv2;		/* 0x1E */
+};
+
+struct mpc52xx_mscan {
+	volatile u8  canctl0;		/* MSCAN + 0x00 */
+	volatile u8  canctl1;		/* MSCAN + 0x01 */
+	volatile u16 rsrv1;		/* MSCAN + 0x02 */
+	volatile u8  canbtr0;		/* MSCAN + 0x04 */
+	volatile u8  canbtr1;		/* MSCAN + 0x05 */
+	volatile u16 rsrv2;		/* MSCAN + 0x06 */
+	volatile u8  canrflg;		/* MSCAN + 0x08 */
+	volatile u8  canrier;		/* MSCAN + 0x09 */
+	volatile u16 rsrv3;		/* MSCAN + 0x0A */
+	volatile u8  cantflg;		/* MSCAN + 0x0C */
+	volatile u8  cantier;		/* MSCAN + 0x0D */
+	volatile u16 rsrv4;		/* MSCAN + 0x0E */
+	volatile u8  cantarq;		/* MSCAN + 0x10 */
+	volatile u8  cantaak;		/* MSCAN + 0x11 */
+	volatile u16 rsrv5;		/* MSCAN + 0x12 */
+	volatile u8  cantbsel;		/* MSCAN + 0x14 */
+	volatile u8  canidac;		/* MSCAN + 0x15 */
+	volatile u16 rsrv6[3];		/* MSCAN + 0x16 */
+	volatile u8  canrxerr;		/* MSCAN + 0x1C */
+	volatile u8  cantxerr;		/* MSCAN + 0x1D */
+	volatile u16 rsrv7;		/* MSCAN + 0x1E */
+	volatile u8  canidar0;		/* MSCAN + 0x20 */
+	volatile u8  canidar1;		/* MSCAN + 0x21 */
+	volatile u16 rsrv8;		/* MSCAN + 0x22 */
+	volatile u8  canidar2;		/* MSCAN + 0x24 */
+	volatile u8  canidar3;		/* MSCAN + 0x25 */
+	volatile u16 rsrv9;		/* MSCAN + 0x26 */
+	volatile u8  canidmr0;		/* MSCAN + 0x28 */
+	volatile u8  canidmr1;		/* MSCAN + 0x29 */
+	volatile u16 rsrv10;		/* MSCAN + 0x2A */
+	volatile u8  canidmr2;		/* MSCAN + 0x2C */
+	volatile u8  canidmr3;		/* MSCAN + 0x2D */
+	volatile u16 rsrv11;		/* MSCAN + 0x2E */
+	volatile u8  canidar4;		/* MSCAN + 0x30 */
+	volatile u8  canidar5;		/* MSCAN + 0x31 */
+	volatile u16 rsrv12;		/* MSCAN + 0x32 */
+	volatile u8  canidar6;		/* MSCAN + 0x34 */
+	volatile u8  canidar7;		/* MSCAN + 0x35 */
+	volatile u16 rsrv13;		/* MSCAN + 0x36 */
+	volatile u8  canidmr4;		/* MSCAN + 0x38 */
+	volatile u8  canidmr5;		/* MSCAN + 0x39 */
+	volatile u16 rsrv14;		/* MSCAN + 0x3A */
+	volatile u8  canidmr6;		/* MSCAN + 0x3C */
+	volatile u8  canidmr7;		/* MSCAN + 0x3D */
+	volatile u16 rsrv15;		/* MSCAN + 0x3E */
+
+	/* Foreground receive buffer */
+	struct mscan_buffer canrxfg;	/* MSCAN + 0x40 */
+	/* Foreground transmit buffer */
+	struct mscan_buffer cantxfg;	/* MSCAN + 0x60 */
+};
+
+/* -------data structure definition start-----------*/
+
+/* Available device types */
+enum device_type_t {
+	DT_SINGLE,           /* Single-endpoint device */
+	/* Single-endpoint device, without external clock source */
+	DT_SINGLE_NOEXTCLK,
+	DT_MASTER,           /* Dual-endpoint: master device */
+	DT_SLAVE             /* Dual-endpoint: slave device */
+};
+
+typedef union {
+	u8  ucID[4];
+	u32 dwID;
+} ID;
+
+/* Fundamental mpc52xx chip operations */
+struct can_mpc52xx_chip_t {
+	/* Pointer to the chip's CAN endpoint */
+	struct can_endpoint_t *endpoint;
+	/* Pointer to the chip's hw device */
+	struct mpc52xx_mscan *regs;
+	/* Device type */
+	enum device_type_t type;
+	int irq;
+
+	spinlock_t lock;		/* No recursive interrupts */
+	int bitrate;
+	u32 error_counter;		/* counts all fatal errors*/
+	u32	reserved0;
+	u32 reserved1;
+	u16 error_status;		/* status of CAN chip*/
+	u16 wBTR0BTR1;		/*  Bitrate BTR0 and BTR1*/
+	/* the persistent storage for 11 or 29 bit identifier*/
+	u8  ucCANMsgType;
+	u8  ucListenOnly;	/* the persistent storage for listen-only mode*/
+	u8  loopbackmode;	 /* loopback mode  */
+	u8  bExtended;		/* if 0, no extended frames are accepted*/
+};
+
+/* -------data structure definition start-----------*/
+
+/*  static declaration start */
+
+/* Max. number of messages during an interrupt */
+#define CAN_MPC52xx_MAX_MESSAGES		8
+
+/* Max. number of interrupts to process before leaving the handler */
+#define CAN_MPC52xx_MAX_INTERRUPTS	8
+#define MAX_TSEG1	15
+#define MAX_TSEG2	7
+#define BTR1_SAM	(1 << 1)
+
+/* Message type access macros. */
+#define BUFFER_STD_RTR		0x10
+#define BUFFER_EXT_RTR		0x01
+#define BUFFER_EXTENDED		0x08
+
+#define CAN_BAUD_1M	0x025e	/*    1 MBit/s        */
+#define CAN_BAUD_500K	0x054f	 /*   500 kBit/s    */
+#define CAN_BAUD_250K	0x0a6f	/*   250 kBit/s    */
+#define CAN_BAUD_125K	0x156f 	/*   125 kBit/s    */
+#define CAN_BAUD_100K	0x9d4f	 /*   100 kBit/s    */
+#define CAN_BAUD_50K	0xb66f	/*   50 kBit/s      */
+#define CAN_BAUD_20K	0x0000	/*   not supported*/
+#define CAN_BAUD_10K	0x0000	/*   not supported*/
+#define CAN_BAUD_5K	0x0000	/*   not supported*/
+
+/* MSGTYPE bits of element MSGTYPE in structure TPCANMsg*/
+#define MSGTYPE_STATUS		0x80	/* used to mark pending status */
+#define MSGTYPE_EXTENDED	0x03	/* declares a extended frame */
+#define MSGTYPE_RTR			0x01	/* marks a remote frame*/
+#define MSGTYPE_STANDARD	0x00	/* marks a standard frame*/
+
+/* error codes */
+#define CAN_ERR_QOVERRUN	0x0040	/*  receive queue overrun*/
+
+#endif /* __MPC52xx_MSCAN_H__ */
diff --git a/include/linux/major.h b/include/linux/major.h
index 53d5faf..1437765 100644
--- a/include/linux/major.h
+++ b/include/linux/major.h
@@ -170,4 +170,5 @@
 
 #define VIOTAPE_MAJOR		230
 
+#define CAN_MAJOR		231
 #endif
-- 
1.6.0.2.GIT

