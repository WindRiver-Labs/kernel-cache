From b6c55534eb464e44aba36947f728f5fe895fc58c Mon Sep 17 00:00:00 2001
From: Stanley.Miao <stanley.miao@windriver.com>
Date: Thu, 18 Mar 2010 14:17:53 +0800
Subject: [PATCH 1/9] Davinci EMAC: Add the manipulation of EMAC functional clock

Original codes from TI Linux Platform Support Package
AM35x-OMAP35x-PSP-SDK-03.00.00.04.tgz which is at http://software-dl.ti.com/
dsps/dsps_public_sw/psp/omap3_00/03_00_00_04/index_FDS.html

Add the manipulation of EMAC functional clock "fck", in davinci emac driver.

Signed-off-by: Stanley.Miao <stanley.miao@windriver.com>
---
 drivers/net/davinci_emac.c |   18 +++++++++++++++++-
 1 files changed, 17 insertions(+), 1 deletions(-)

diff --git a/drivers/net/davinci_emac.c b/drivers/net/davinci_emac.c
index 2b8edd2..1a0e87c 100644
--- a/drivers/net/davinci_emac.c
+++ b/drivers/net/davinci_emac.c
@@ -491,6 +491,7 @@ struct emac_priv {
 
 /* clock frequency for EMAC */
 static struct clk *emac_clk;
+static struct clk *emac_phy_clk;
 static unsigned long emac_bus_frequency;
 static unsigned long mdio_max_freq;
 
@@ -2638,17 +2639,25 @@ static int __devinit davinci_emac_probe(struct platform_device *pdev)
 	struct device *emac_dev;
 
 	/* obtain emac clock from kernel */
-	emac_clk = clk_get(&pdev->dev, NULL);
+	emac_clk = clk_get(&pdev->dev, "ick");
 	if (IS_ERR(emac_clk)) {
 		printk(KERN_ERR "DaVinci EMAC: Failed to get EMAC clock\n");
 		return -EBUSY;
 	}
+	/* obtain emac functional clock from kernel */
+	emac_phy_clk = clk_get(&pdev->dev, "fck");
+	if (IS_ERR(emac_phy_clk)) {
+		printk(KERN_ERR "DaVinci EMAC: Failed to get EMAC Functional clock\n");
+		clk_put(emac_clk);
+		return -EBUSY;
+	}
 	emac_bus_frequency = clk_get_rate(emac_clk);
 	/* TODO: Probe PHY here if possible */
 
 	ndev = alloc_etherdev(sizeof(struct emac_priv));
 	if (!ndev) {
 		printk(KERN_ERR "DaVinci EMAC: Error allocating net_device\n");
+		clk_put(emac_phy_clk);
 		clk_put(emac_clk);
 		return -ENOMEM;
 	}
@@ -2734,6 +2743,7 @@ static int __devinit davinci_emac_probe(struct platform_device *pdev)
 	netif_napi_add(ndev, &priv->napi, emac_poll, EMAC_POLL_WEIGHT);
 
 	clk_enable(emac_clk);
+	clk_enable(emac_phy_clk);
 
 	/* register the network device */
 	SET_NETDEV_DEV(ndev, &pdev->dev);
@@ -2783,6 +2793,7 @@ mdiobus_quit:
 
 netdev_reg_err:
 mdio_alloc_err:
+	clk_disable(emac_phy_clk);
 	clk_disable(emac_clk);
 no_irq_res:
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
@@ -2791,6 +2802,7 @@ no_irq_res:
 
 probe_quit:
 	clk_put(emac_clk);
+	clk_put(emac_phy_clk);
 	free_netdev(ndev);
 	return rc;
 }
@@ -2821,7 +2833,9 @@ static int __devexit davinci_emac_remove(struct platform_device *pdev)
 	free_netdev(ndev);
 	iounmap(priv->remap_addr);
 
+	clk_disable(emac_phy_clk);
 	clk_disable(emac_clk);
+	clk_put(emac_phy_clk);
 	clk_put(emac_clk);
 
 	return 0;
@@ -2835,6 +2849,7 @@ static int davinci_emac_suspend(struct device *dev)
 	if (netif_running(ndev))
 		emac_dev_stop(ndev);
 
+	clk_disable(emac_phy_clk);
 	clk_disable(emac_clk);
 
 	return 0;
@@ -2846,6 +2861,7 @@ static int davinci_emac_resume(struct device *dev)
 	struct net_device *ndev = platform_get_drvdata(pdev);
 
 	clk_enable(emac_clk);
+	clk_enable(emac_phy_clk);
 
 	if (netif_running(ndev))
 		emac_dev_open(ndev);
-- 
1.6.5.2

