From 0274023587945ddbbfc2b907ea456d91c62ee71c Mon Sep 17 00:00:00 2001
From: John Jacques <john.jacques@lsi.com>
Date: Wed, 2 Oct 2013 19:20:34 -0500
Subject: [PATCH 52/75] drivers/misc: Add a parameter to the smmon module,
 log.

By default it is on (1). To turn off logging, add lsi-smmon.log=0
to bootargs or "cat 0 > /sys/module/lsi_smmon/parameters/log".

Signed-off-by: John Jacques <john.jacques@lsi.com>
---
 drivers/misc/lsi-smmon.c |   48 ++++++++++++++++++++++++++++++++++-----------
 1 files changed, 36 insertions(+), 12 deletions(-)

diff --git a/drivers/misc/lsi-smmon.c b/drivers/misc/lsi-smmon.c
index 6b57ca9..5e859db 100644
--- a/drivers/misc/lsi-smmon.c
+++ b/drivers/misc/lsi-smmon.c
@@ -11,6 +11,8 @@
 
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/spinlock.h>
 #include <linux/proc_fs.h>
@@ -21,6 +23,10 @@
 #error "Only AXM55xx is Supported At Present!"
 #endif
 
+static int log=1;
+module_param(log, int, 0755);
+MODULE_PARM_DESC(log, "Log each error on the console.");
+
 /*
   AXM55xx Interrupt Status Bits
 
@@ -116,7 +122,8 @@ static irqreturn_t smmon_isr(int interrupt, void *device)
 	spin_lock(&counts_lock);
 
 	if (0 != (0x00000002 & status) || 0 != (0x00000004 & status))
-		printk(KERN_CRIT "smmon(%d): Illegal Access!\n", sm);
+		printk(KERN_ERR
+		       "smmon(%d): Illegal Access!\n", sm);
 
 	if (0 != (0x00000002 & status))
 		++counts.illegal_access[sm];
@@ -124,8 +131,11 @@ static irqreturn_t smmon_isr(int interrupt, void *device)
 	if (0 != (0x00000004 & status))
 		++counts.multiple_illegal_access[sm];
 
-	if (0 != (0x00000008 & status) || 0 != (0x00000010 & status))
-		printk(KERN_NOTICE "smmon(%d): Correctable ECC Error!\n", sm);
+	if ((0 != (0x00000008 & status) ||
+	     0 != (0x00000010 & status)) &&
+	    0 != log)
+		printk(KERN_NOTICE
+		       "smmon(%d): Correctable ECC Error!\n", sm);
 
 	if (0 != (0x00000008 & status))
 		++counts.correctable_ecc[sm];
@@ -133,8 +143,11 @@ static irqreturn_t smmon_isr(int interrupt, void *device)
 	if (0 != (0x00000010 & status))
 		++counts.multiple_correctable_ecc[sm];
 
-	if (0 != (0x00000020 & status) || 0 != (0x00000040 & status))
-		printk(KERN_CRIT "smmon(%d): Uncorrectable ECC Error!\n", sm);
+	if ((0 != (0x00000020 & status) ||
+	     0 != (0x00000040 & status)) &&
+	    0 != log)
+		printk(KERN_CRIT
+		       "smmon(%d): Uncorrectable ECC Error!\n", sm);
 
 	if (0 != (0x00000020 & status))
 		++counts.uncorrectable_ecc[sm];
@@ -144,17 +157,26 @@ static irqreturn_t smmon_isr(int interrupt, void *device)
 
 	if (0 != (0x00000080 & status)) {
 		++counts.port_error[sm];
-		printk(KERN_CRIT "smmon(%d): Port Error!\n", sm);
+
+		if (0 != log)
+			printk(KERN_CRIT
+			       "smmon(%d): Port Error!\n", sm);
 	}
 
 	if (0 != (0x00000800 & status)) {
 		++counts.wrap_error[sm];
-		printk(KERN_CRIT "smmon(%d): Wrap Error!\n", sm);
+
+		if (0 != log)
+			printk(KERN_CRIT
+			       "smmon(%d): Wrap Error!\n", sm);
 	}
 
 	if (0 != (0x00080000 & status)) {
 		++counts.parity_error[sm];
-		printk(KERN_CRIT "smmon(%d): Parity Error!\n", sm);
+
+		if (0 != log)
+			printk(KERN_CRIT
+			       "smmon(%d): Parity Error!\n", sm);
 	}
 
 	spin_unlock(&counts_lock);
@@ -179,6 +201,7 @@ smmon_read_proc(char *page, char **start, off_t offset, int count,
 	spin_lock_irqsave(&counts_lock, flags);
 
 	length = sprintf(page,
+			 "------------ Counts for SM0/SM1 ----------\n"
 			 "                   Illegal Access: %lu/%lu\n"
 			 "        Multiple Illegal Accesses: %lu/%lu\n"
 			 "            Correctable ECC Error: %lu/%lu\n"
@@ -230,12 +253,13 @@ static int __init smmon_init(void)
 {
 	int rc;
 
+	printk("smmon: log=%d\n", log);
 	create_proc_read_entry("smmon", 0, NULL, smmon_read_proc, NULL);
-
 	memset(&counts, 0, sizeof(struct smmon_counts));
-
-	rc = request_irq(32 + 161, smmon_isr, IRQF_ONESHOT, "smmon_0", NULL);
-	rc |= request_irq(32 + 160, smmon_isr, IRQF_ONESHOT, "smmon_1", NULL);
+	rc = request_irq(32 + 161, smmon_isr, IRQF_ONESHOT,
+			"smmon_0", NULL);
+	rc |= request_irq(32 + 160, smmon_isr, IRQF_ONESHOT,
+			"smmon_1", NULL);
 
 	if (0 != rc) {
 		printk(KERN_ERR "smmon: Couldn't connect interrupt handler!\n");
-- 
1.7.5.4

