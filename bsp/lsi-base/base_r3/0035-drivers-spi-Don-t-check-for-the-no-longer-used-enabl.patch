From 7de88a254fed2e51587c24fddac3a8bc9457bedf Mon Sep 17 00:00:00 2001
From: John Jacques <john.jacques@lsi.com>
Date: Fri, 13 Sep 2013 14:05:27 -0500
Subject: [PATCH 35/75] drivers/spi: Don't check for the, no longer used,
 enabled property.

Signed-off-by: John Jacques <john.jacques@lsi.com>
---
 drivers/spi/spi-pl022.c |   34 +++++++++++++++++++---------------
 1 files changed, 19 insertions(+), 15 deletions(-)

diff --git a/drivers/spi/spi-pl022.c b/drivers/spi/spi-pl022.c
index 1e98900..d2d0fce 100644
--- a/drivers/spi/spi-pl022.c
+++ b/drivers/spi/spi-pl022.c
@@ -58,7 +58,7 @@
  * val shifted sb steps to the left.
  */
 #define SSP_WRITE_BITS(reg, val, mask, sb) \
- ((reg) = (((reg) & ~(mask)) | (((val)<<(sb)) & (mask))))
+	((reg) = (((reg) & ~(mask)) | (((val)<<(sb)) & (mask))))
 
 /*
  * This macro is also used to define some default values.
@@ -66,7 +66,7 @@
  * the result with mask.
  */
 #define GEN_MASK_BITS(val, mask, sb) \
- (((val)<<(sb)) & (mask))
+	(((val)<<(sb)) & (mask))
 
 #define DRIVE_TX		0
 #define DO_NOT_DRIVE_TX		1
@@ -564,7 +564,8 @@ static void restore_state(struct pl022 *pl022)
 /* ST versions have slightly different bit layout */
 #define DEFAULT_SSP_REG_CR0_ST ( \
 	GEN_MASK_BITS(SSP_DATA_BITS_12, SSP_CR0_MASK_DSS_ST, 0)	| \
-	GEN_MASK_BITS(SSP_MICROWIRE_CHANNEL_FULL_DUPLEX, SSP_CR0_MASK_HALFDUP_ST, 5) | \
+	GEN_MASK_BITS(SSP_MICROWIRE_CHANNEL_FULL_DUPLEX, \
+		SSP_CR0_MASK_HALFDUP_ST, 5) | \
 	GEN_MASK_BITS(SSP_CLK_POL_IDLE_LOW, SSP_CR0_MASK_SPO, 6) | \
 	GEN_MASK_BITS(SSP_CLK_SECOND_EDGE, SSP_CR0_MASK_SPH, 7) | \
 	GEN_MASK_BITS(SSP_DEFAULT_CLKRATE, SSP_CR0_MASK_SCR, 8) | \
@@ -594,7 +595,8 @@ static void restore_state(struct pl022 *pl022)
 	GEN_MASK_BITS(SSP_TX_MSB, SSP_CR1_MASK_TENDN_ST, 5) | \
 	GEN_MASK_BITS(SSP_MWIRE_WAIT_ZERO, SSP_CR1_MASK_MWAIT_ST, 6) |\
 	GEN_MASK_BITS(SSP_RX_1_OR_MORE_ELEM, SSP_CR1_MASK_RXIFLSEL_ST, 7) | \
-	GEN_MASK_BITS(SSP_TX_1_OR_MORE_EMPTY_LOC, SSP_CR1_MASK_TXIFLSEL_ST, 10) \
+	GEN_MASK_BITS(SSP_TX_1_OR_MORE_EMPTY_LOC, \
+		SSP_CR1_MASK_TXIFLSEL_ST, 10) \
 )
 
 /*
@@ -608,8 +610,10 @@ static void restore_state(struct pl022 *pl022)
 	GEN_MASK_BITS(SSP_RX_MSB, SSP_CR1_MASK_RENDN_ST, 4) | \
 	GEN_MASK_BITS(SSP_TX_MSB, SSP_CR1_MASK_TENDN_ST, 5) | \
 	GEN_MASK_BITS(SSP_RX_1_OR_MORE_ELEM, SSP_CR1_MASK_RXIFLSEL_ST, 7) | \
-	GEN_MASK_BITS(SSP_TX_1_OR_MORE_EMPTY_LOC, SSP_CR1_MASK_TXIFLSEL_ST, 10) | \
-	GEN_MASK_BITS(SSP_FEEDBACK_CLK_DELAY_NONE, SSP_CR1_MASK_FBCLKDEL_ST, 13) \
+	GEN_MASK_BITS(SSP_TX_1_OR_MORE_EMPTY_LOC, \
+		SSP_CR1_MASK_TXIFLSEL_ST, 10) | \
+	GEN_MASK_BITS(SSP_FEEDBACK_CLK_DELAY_NONE, \
+		SSP_CR1_MASK_FBCLKDEL_ST, 13) \
 )
 
 #define DEFAULT_SSP_REG_CPSR ( \
@@ -1260,9 +1264,8 @@ static irqreturn_t pl022_interrupt_handler(int irq, void *dev_id)
 		       SSP_IMSC(pl022->virtbase));
 		writew(CLEAR_ALL_INTERRUPTS, SSP_ICR(pl022->virtbase));
 		if (unlikely(pl022->rx > pl022->rx_end)) {
-			dev_warn(&pl022->dev->dev, "read %u surplus "
-				 "bytes (did you request an odd "
-				 "number of bytes on a 16bit bus?)\n",
+			dev_warn(&pl022->dev->dev,
+			"read %u surplus bytes (did you request an odd number of bytes on a 16bit bus?)\n",
 				 (u32) (pl022->rx - pl022->rx_end));
 		}
 		/* Update total bytes transferred */
@@ -1380,7 +1383,8 @@ static void pump_transfers(unsigned long data)
 
 err_config_dma:
 	/* enable all interrupts except RX */
-	writew(ENABLE_ALL_INTERRUPTS & ~SSP_IMSC_MASK_RXIM, SSP_IMSC(pl022->virtbase));
+	writew(ENABLE_ALL_INTERRUPTS & ~SSP_IMSC_MASK_RXIM,
+		SSP_IMSC(pl022->virtbase));
 }
 
 static void do_interrupt_dma_transfer(struct pl022 *pl022)
@@ -1658,11 +1662,10 @@ static int verify_controller_parameters(struct pl022 *pl022,
 				return -EINVAL;
 			}
 		} else {
-			if (chip_info->duplex != SSP_MICROWIRE_CHANNEL_FULL_DUPLEX)
+			if (chip_info->duplex !=
+			   SSP_MICROWIRE_CHANNEL_FULL_DUPLEX)
 				dev_err(&pl022->dev->dev,
-					"Microwire half duplex mode requested,"
-					" but this is only available in the"
-					" ST version of PL022\n");
+					"Microwire half duplex mode requested, but this is only available in the ST version of PL022\n");
 			return -EINVAL;
 		}
 	}
@@ -1736,7 +1739,7 @@ static int calculate_effective_freq(struct pl022 *pl022, int freq, struct
 		scr = SCR_MIN;
 	}
 
-	WARN(!best_freq, "pl022: Matching cpsdvsr and scr not found for %d Hz rate \n",
+	WARN(!best_freq, "pl022: Matching cpsdvsr and scr not found for %d Hz rate\n",
 			freq);
 
 	clk_freq->cpsdvsr = (u8) (best_cpsdvsr & 0xFF);
@@ -2617,6 +2620,7 @@ static struct platform_driver pl022_driver = {
 #endif
 static int __init pl022_init(void)
 {
+	printk(KERN_INFO "--> %s:%d -\n", __FILE__, __LINE__);
 #ifdef CONFIG_ARM_AMBA
 	return amba_driver_register(&pl022_driver);
 #else
-- 
1.7.5.4

