From bef76eb70e42ef2c0dbc686dfaf6742a474562e1 Mon Sep 17 00:00:00 2001
From: John Jacques <john.jacques@lsi.com>
Date: Fri, 23 Aug 2013 21:33:38 -0500
Subject: [PATCH 18/75] drivers/tty: Handle the baud rate correctly, and use
 the PLLs provided by U-Boot to set up the clocks.

Signed-off-by: John Jacques <john.jacques@lsi.com>
---
 arch/arm/boot/dts/axm55xx.dts   |   17 ++++++++++
 arch/arm/mach-axxia/clock.c     |   68 +++++++++++++++++++++++++++-----------
 drivers/tty/serial/amba-pl011.c |   38 +++++++++++----------
 3 files changed, 85 insertions(+), 38 deletions(-)

diff --git a/arch/arm/boot/dts/axm55xx.dts b/arch/arm/boot/dts/axm55xx.dts
index 0286752..6f4d1a5 100644
--- a/arch/arm/boot/dts/axm55xx.dts
+++ b/arch/arm/boot/dts/axm55xx.dts
@@ -152,6 +152,23 @@
 		};
 	};
 
+	clocks {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu {
+                        frequency = <0>; /* Filled in by the boot loader. */
+		};
+
+		peripheral {
+			frequency = <0>; /* Filled in by the boot loader. */
+		};
+
+		emmc {
+                        frequency = <0>; /* Filled in by the boot loader. */
+		};
+	};
+
 	memory@00000000 {
 		device_type = "memory";
 		reg = <0 0x00000000 0 0x10000000>;
diff --git a/arch/arm/mach-axxia/clock.c b/arch/arm/mach-axxia/clock.c
index 27ace6f..4ad8cb9 100644
--- a/arch/arm/mach-axxia/clock.c
+++ b/arch/arm/mach-axxia/clock.c
@@ -13,6 +13,9 @@
 #include <linux/clk.h>
 #include <linux/clkdev.h>
 #include <linux/clk-provider.h>
+#include <linux/of_fdt.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
 
 #define AXXIA_CPU_CLOCK 1400000000
 #define AXXIA_SYS_CLOCK  450000000
@@ -81,6 +84,11 @@ axxia_init_clocks(void)
 
 #else
 
+static struct of_device_id cpu_pll[] __initconst = {
+	{ .name = "/clocks/cpu", },
+	{},
+};
+
 /*
   -------------------------------------------------------------------------------
   axxia_init_clocks
@@ -93,27 +101,29 @@ axxia_init_clocks(void)
 {
 	struct clk *clk;
 	int i;
+	struct device_node *np;
+	u32 frequency;
 
-	/* APB clock dummy */
-	clk = clk_register_fixed_rate(NULL, "apb_pclk", NULL,
-				      CLK_IS_ROOT, AXXIA_SYS_CLOCK/2);
-	clk_register_clkdev(clk, "apb_pclk", NULL);
+	np = of_find_node_by_path("/clocks/cpu");
+
+	if (np) {
+		if (of_property_read_u32(np, "frequency", &frequency))
+			printk(KERN_ERR "%d - Error!", __LINE__);
+	}
 
-	/* CPU core clock (1400MHz) from CPU_PLL */
 	clk = clk_register_fixed_rate(NULL, "clk_cpu", NULL,
-				      CLK_IS_ROOT, AXXIA_CPU_CLOCK);
+				      CLK_IS_ROOT, frequency);
 
-	/* APB and System AXI clock from CPU_PLL */
-	clk = clk_register_fixed_rate(NULL, "clk_pclk", NULL,
-				      CLK_IS_ROOT, AXXIA_CPU_CLOCK/9);
+	np = of_find_node_by_path("/clocks/peripheral");
 
-	/* DDR3 (interface 1) clock from SMEM1_PLL */
-	clk = clk_register_fixed_rate(NULL, "clk_smem1_2x", NULL,
-				      CLK_IS_ROOT, AXXIA_DDR_CLOCK);
+	if (np) {
+		if (of_property_read_u32(np, "frequency", &frequency))
+			printk(KERN_ERR "%d - Error!", __LINE__);
+	}
 
-	/* AXIS slow peripheral clock from SMEM1_PLL. */
 	clk = clk_register_fixed_rate(NULL, "clk_per", NULL,
-				      CLK_IS_ROOT, 2000000);
+				      CLK_IS_ROOT, frequency);
+
 	/* PL011 UART0 */
 	clk_register_clkdev(clk, NULL, "2010080000.uart");
 	/* PL011 UART1 */
@@ -124,20 +134,38 @@ axxia_init_clocks(void)
 	clk_register_clkdev(clk, NULL, "2010083000.uart");
 	/* PL022 SSP */
 	clk_register_clkdev(clk, NULL, "ssp");
-
-	/* Timers 1MHz clock */
-	clk = clk_register_fixed_rate(NULL, "clk_1mhz", NULL,
-				      CLK_IS_ROOT, 1000000);
 	/* SP804 timers */
 	clk_register_clkdev(clk, NULL, "sp804");
 	for (i = 0; i < 8; i++)
 		clk_register_clkdev(clk, NULL, "axxia-timer%d", i);
 
-	/* Dummy MMC clk */
+	np = of_find_node_by_path("/clocks/emmc");
+
+	if (np) {
+		if (of_property_read_u32(np, "frequency", &frequency))
+			printk(KERN_ERR "%d - Error!", __LINE__);
+	}
+
 	clk = clk_register_fixed_rate(NULL, "clk_mmci", NULL,
-				      CLK_IS_ROOT, 25000000);
+				      CLK_IS_ROOT, frequency);
+
 	/* PL180 MMCI */
 	clk_register_clkdev(clk, NULL, "mmci");
+
+	/* APB clock dummy */
+	clk = clk_register_fixed_rate(NULL, "apb_pclk", NULL,
+				      CLK_IS_ROOT, AXXIA_SYS_CLOCK/2);
+	clk_register_clkdev(clk, "apb_pclk", NULL);
+
+	/* APB and System AXI clock from CPU_PLL */
+	clk = clk_register_fixed_rate(NULL, "clk_pclk", NULL,
+				      CLK_IS_ROOT, AXXIA_CPU_CLOCK/9);
+
+	/* DDR3 (interface 1) clock from SMEM1_PLL */
+	clk = clk_register_fixed_rate(NULL, "clk_smem1_2x", NULL,
+				      CLK_IS_ROOT, AXXIA_DDR_CLOCK);
+
+	return;
 }
 
 #endif
diff --git a/drivers/tty/serial/amba-pl011.c b/drivers/tty/serial/amba-pl011.c
index 3cd5b63..038ec43 100644
--- a/drivers/tty/serial/amba-pl011.c
+++ b/drivers/tty/serial/amba-pl011.c
@@ -64,7 +64,8 @@
 
 #define AMBA_ISR_PASS_LIMIT	256
 
-#define UART_DR_ERROR		(UART011_DR_OE|UART011_DR_BE|UART011_DR_PE|UART011_DR_FE)
+#define UART_DR_ERROR		(UART011_DR_OE|UART011_DR_BE| \
+				UART011_DR_PE|UART011_DR_FE)
 #define UART_DUMMY_DR_RX	(1 << 16)
 
 
@@ -754,8 +755,9 @@ static void pl011_dma_rx_chars(struct uart_amba_port *uap,
 	 */
 	if (dma_count == pending && readfifo) {
 		/* Clear any error flags */
-		writew(UART011_OEIS | UART011_BEIS | UART011_PEIS | UART011_FEIS,
-		       uap->port.membase + UART011_ICR);
+		writew(UART011_OEIS | UART011_BEIS |
+			UART011_PEIS | UART011_FEIS,
+			uap->port.membase + UART011_ICR);
 
 		/*
 		 * If we read all the DMA'd characters, and we had an
@@ -820,8 +822,8 @@ static void pl011_dma_rx_irq(struct uart_amba_port *uap)
 	/* Switch buffer & re-trigger DMA job */
 	dmarx->use_buf_b = !dmarx->use_buf_b;
 	if (pl011_dma_rx_trigger_dma(uap)) {
-		dev_dbg(uap->port.dev, "could not retrigger RX DMA job "
-			"fall back to interrupt mode\n");
+		dev_dbg(uap->port.dev,
+			"could not retrigger RX DMA job fall back to interrupt mode\n");
 		uap->im |= UART011_RXIM;
 		writew(uap->im, uap->port.membase + UART011_IMSC);
 	}
@@ -868,8 +870,8 @@ static void pl011_dma_rx_callback(void *data)
 	 * get some IRQ immediately from RX.
 	 */
 	if (ret) {
-		dev_dbg(uap->port.dev, "could not retrigger RX DMA job "
-			"fall back to interrupt mode\n");
+		dev_dbg(uap->port.dev,
+			"could not retrigger RX DMA job fall back to interrupt mode\n");
 		uap->im |= UART011_RXIM;
 		writew(uap->im, uap->port.membase + UART011_IMSC);
 	}
@@ -947,8 +949,8 @@ skip_rx:
 
 	if (uap->using_rx_dma) {
 		if (pl011_dma_rx_trigger_dma(uap))
-			dev_dbg(uap->port.dev, "could not trigger initial "
-				"RX DMA job, fall back to interrupt mode\n");
+			dev_dbg(uap->port.dev,
+				"could not trigger initial RX DMA job, fall back to interrupt mode\n");
 	}
 }
 
@@ -1172,8 +1174,8 @@ static void pl011_rx_chars(struct uart_amba_port *uap)
 	 */
 	if (pl011_dma_rx_available(uap)) {
 		if (pl011_dma_rx_trigger_dma(uap)) {
-			dev_dbg(uap->port.dev, "could not trigger RX DMA job "
-				"fall back to interrupt mode again\n");
+			dev_dbg(uap->port.dev,
+				"could not trigger RX DMA job fall back to interrupt mode again\n");
 			uap->im |= UART011_RXIM;
 		} else
 			uap->im &= ~UART011_RXIM;
@@ -1484,11 +1486,11 @@ int pl011_startup(struct uart_port *port)
 static void pl011_shutdown_channel(struct uart_amba_port *uap,
 					unsigned int lcrh)
 {
-      unsigned long val;
+	unsigned long val;
 
-      val = readw(uap->port.membase + lcrh);
-      val &= ~(UART01x_LCRH_BRK | UART01x_LCRH_FEN);
-      writew(val, uap->port.membase + lcrh);
+	val = readw(uap->port.membase + lcrh);
+	val &= ~(UART01x_LCRH_BRK | UART01x_LCRH_FEN);
+	writew(val, uap->port.membase + lcrh);
 }
 
 static void pl011_shutdown(struct uart_port *port)
@@ -1583,7 +1585,7 @@ pl011_set_termios(struct uart_port *port, struct ktermios *termios,
 	case CS7:
 		lcr_h = UART01x_LCRH_WLEN_7;
 		break;
-	default: // CS8
+	default: /* CS8 */
 		lcr_h = UART01x_LCRH_WLEN_8;
 		break;
 	}
@@ -1670,8 +1672,8 @@ pl011_set_termios(struct uart_port *port, struct ktermios *termios,
 			quot -= 2;
 	}
 	/* Set baud rate */
-	writew(0x3, port->membase + UART011_FBRD);
-	writew(0x364, port->membase + UART011_IBRD);
+	writew(quot & 0x3f, port->membase + UART011_FBRD);
+	writew(quot >> 6, port->membase + UART011_IBRD);
 
 	/*
 	 * ----------v----------v----------v----------v-----
-- 
1.7.5.4

