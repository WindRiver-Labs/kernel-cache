From 907b050553bbca86d832e193e58ff0680024e9ff Mon Sep 17 00:00:00 2001
From: John Jacques <john.jacques@lsi.com>
Date: Wed, 3 Jul 2013 18:55:19 -0500
Subject: [PATCH 73/75] arm-powerpc-drivers: Rearrange the location of the
 wrapper functions

In previos commit, the config ring access code has been moved into
drivers/misc, The mdio wrapper has been move into drivers/net/ethernet/lsi.

This patch updates reference for ncr.h for ppc system device driver and
removes the duplicate code in arch/powerpc.

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 arch/powerpc/include/asm/lsi/acp_ncr.h |   45 ----
 arch/powerpc/sysdev/Makefile           |    2 +-
 arch/powerpc/sysdev/lsi_acp_ncr.c      |  375 --------------------------------
 arch/powerpc/sysdev/lsi_acp_wrappers.c |  288 +++++--------------------
 arch/powerpc/sysdev/ppc4xx_pci.c       |    2 +-
 5 files changed, 56 insertions(+), 656 deletions(-)
 delete mode 100644 arch/powerpc/include/asm/lsi/acp_ncr.h
 delete mode 100644 arch/powerpc/sysdev/lsi_acp_ncr.c

diff --git a/arch/powerpc/include/asm/lsi/acp_ncr.h b/arch/powerpc/include/asm/lsi/acp_ncr.h
deleted file mode 100644
index 1a08f07..0000000
--- a/arch/powerpc/include/asm/lsi/acp_ncr.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * asm/lsi/acp_ncr.h
- *
- * Copyright (C) 2010 LSI
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307	 USA
- */
-
-#ifndef __DRIVERS_LSI_ACP_NCR_H
-#define __DRIVERS_LSI_ACP_NCR_H
-
-#ifndef NCP_REGION_ID
-#define NCP_REGION_ID(node, target) \
-(unsigned long)((((node) & 0xffff) << 16) | ((target) & 0xffff))
-#endif
-
-#ifndef NCP_NODE_ID
-#define NCP_NODE_ID(region) (((region) >> 16) & 0xffff)
-#endif
-
-#ifndef NCP_TARGET_ID
-#define NCP_TARGET_ID(region) ((region) & 0xffff)
-#endif
-
-int ncr_read(unsigned long, unsigned long, int, void *);
-int ncr_write(unsigned long, unsigned long, int, void *);
-
-int is_asic(void);
-
-extern int acp_mdio_read(unsigned long, unsigned long, unsigned short *);
-extern int acp_mdio_write(unsigned long, unsigned long, unsigned short);
-
-#endif /*  __DRIVERS_LSI_ACP_NCR_H */
diff --git a/arch/powerpc/sysdev/Makefile b/arch/powerpc/sysdev/Makefile
index 230bb72..792e851 100644
--- a/arch/powerpc/sysdev/Makefile
+++ b/arch/powerpc/sysdev/Makefile
@@ -70,4 +70,4 @@ obj-$(CONFIG_PPC_XICS)		+= xics/
 
 obj-$(CONFIG_GE_FPGA)		+= ge/
 
-obj-$(CONFIG_ACP)		+= lsi_acp_ncr.o lsi_acp_wrappers.o
+obj-$(CONFIG_ACP)		+= lsi_acp_wrappers.o
diff --git a/arch/powerpc/sysdev/lsi_acp_ncr.c b/arch/powerpc/sysdev/lsi_acp_ncr.c
deleted file mode 100644
index 9802110..0000000
--- a/arch/powerpc/sysdev/lsi_acp_ncr.c
+++ /dev/null
@@ -1,375 +0,0 @@
-/*
- *  Copyright (C) 2009 LSI Corporation
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <linux/io.h>
-#include <linux/module.h>
-
-#include <include/asm/lsi/acp_ncr.h>
-
-static void __iomem *nca_address;
-
-#define WFC_TIMEOUT (400000)
-
-#define LOCK_DOMAIN 0
-
-union command_data_register_0 {
-	unsigned long raw;
-	struct {
-		unsigned long start_done:1;
-		unsigned long unused:6;
-		unsigned long local_bit:1;
-		unsigned long status:2;
-		unsigned long byte_swap_enable:1;
-		unsigned long cfg_cmpl_int_enable:1;
-		unsigned long cmd_type:4;
-		unsigned long dbs:16;
-	} __packed bits;
-} __packed;
-
-union command_data_register_1 {
-	unsigned long raw;
-	struct {
-		unsigned long target_address:32;
-	} __packed bits;
-} __packed;
-
-union command_data_register_2 {
-	unsigned long raw;
-	struct {
-		unsigned long unused:16;
-		unsigned long target_node_id:8;
-		unsigned long target_id_address_upper:8;
-	} __packed bits;
-} __packed;
-
-/*
-  ----------------------------------------------------------------------
-  ncr_register_read
-*/
-
-static inline unsigned long
-ncr_register_read(unsigned *address)
-{
-	unsigned long value;
-
-	value = in_be32(address);
-
-	return value;
-}
-
-/*
-  ----------------------------------------------------------------------
-  ncr_register_write
-*/
-
-static inline void
-ncr_register_write(const unsigned value, unsigned *address)
-{
-	out_be32(address, value);
-}
-
-/*
-  ------------------------------------------------------------------------------
-  ncr_lock
-*/
-
-static int
-ncr_lock(int domain)
-{
-	unsigned long offset;
-	unsigned long value;
-	int loops = 10000;
-
-	offset = (0xff80 + (domain * 4));
-
-	do {
-		value = ncr_register_read((unsigned *)(nca_address + offset));
-	} while ((0 != value) && (0 < --loops));
-
-	if (0 == loops)
-		return -1;
-
-	return 0;
-}
-
-/*
-  ------------------------------------------------------------------------------
-  ncr_unlock
-*/
-
-static void
-ncr_unlock(int domain)
-{
-	unsigned long offset;
-
-	offset = (0xff80 + (domain * 4));
-	ncr_register_write(0, (unsigned *)(nca_address + offset));
-
-	return;
-}
-
-/*
-  ======================================================================
-  ======================================================================
-  Public Interface
-  ======================================================================
-  ======================================================================
-*/
-
-/*
-  ----------------------------------------------------------------------
-  ncr_read
-*/
-
-int
-ncr_read(unsigned long region, unsigned long address, int number, void *buffer)
-{
-	union command_data_register_0 cdr0;
-	union command_data_register_1 cdr1;
-	union command_data_register_2 cdr2;
-	int wfc_timeout = WFC_TIMEOUT;
-
-	if (NULL == nca_address)
-		nca_address = ioremap(0x002000520000ULL, 0x20000);
-
-	if (0 != ncr_lock(LOCK_DOMAIN))
-		return -1;
-
-	/*
-	  Set up the read command.
-	*/
-
-	cdr2.raw = 0;
-	cdr2.bits.target_node_id = NCP_NODE_ID(region);
-	cdr2.bits.target_id_address_upper = NCP_TARGET_ID(region);
-	ncr_register_write(cdr2.raw, (unsigned *) (nca_address + 0xf8));
-
-	cdr1.raw = 0;
-	cdr1.bits.target_address = (address >> 2);
-	ncr_register_write(cdr1.raw, (unsigned *) (nca_address + 0xf4));
-
-	cdr0.raw = 0;
-	cdr0.bits.start_done = 1;
-
-	if (0xff == cdr2.bits.target_id_address_upper)
-		cdr0.bits.local_bit = 1;
-
-	cdr0.bits.cmd_type = 4;
-	/* TODO: Verify number... */
-	cdr0.bits.dbs = (number - 1);
-	ncr_register_write(cdr0.raw, (unsigned *) (nca_address + 0xf0));
-	mb();
-
-	/*
-	  Wait for completion.
-	*/
-
-	do {
-		--wfc_timeout;
-	} while ((0x80000000UL ==
-		  ncr_register_read((unsigned *)(nca_address + 0xf0))) &&
-		 0 < wfc_timeout);
-
-	if (0 == wfc_timeout) {
-		ncr_unlock(LOCK_DOMAIN);
-		return -1;
-	}
-
-	/*
-	  Copy data words to the buffer.
-	*/
-
-	address = (unsigned long)(nca_address + 0x1000);
-	while (4 <= number) {
-		*((unsigned long *) buffer) =
-			ncr_register_read((unsigned *) address);
-		address += 4;
-		number -= 4;
-	}
-
-	if (0 < number) {
-		unsigned long temp = ncr_register_read((unsigned *) address);
-		memcpy((void *) buffer, &temp, number);
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL(ncr_read);
-/*
-  ------------------------------------------------------------------------------
-  is_asic
-*/
-
-int
-is_asic(void)
-{
-#ifdef CONFIG_ACPISS
-	return 0;
-#else
-	unsigned long nca_config;
-
-	if (0 == ncr_read(NCP_REGION_ID(0x16, 0xff), 0x10, 4, &nca_config))
-		return (0 == (nca_config & 0x80000000));
-
-	return -1;
-#endif
-}
-EXPORT_SYMBOL(is_asic);
-
-/*
-  ----------------------------------------------------------------------
-  ncr_write
-*/
-
-int
-ncr_write(unsigned long region, unsigned long address, int number, void *buffer)
-{
-	union command_data_register_0 cdr0;
-	union command_data_register_1 cdr1;
-	union command_data_register_2 cdr2;
-	unsigned long data_word_base;
-	int dbs = (number - 1);
-	int wfc_timeout = WFC_TIMEOUT;
-
-	if (NULL == nca_address)
-		nca_address = ioremap(0x002000520000ULL, 0x20000);
-
-	if (0 != ncr_lock(LOCK_DOMAIN))
-		return -1;
-
-	/*
-	  Set up the write.
-	*/
-
-	cdr2.raw = 0;
-	cdr2.bits.target_node_id = NCP_NODE_ID(region);
-	cdr2.bits.target_id_address_upper = NCP_TARGET_ID(region);
-	ncr_register_write(cdr2.raw, (unsigned *) (nca_address + 0xf8));
-
-	cdr1.raw = 0;
-	cdr1.bits.target_address = (address >> 2);
-	ncr_register_write(cdr1.raw, (unsigned *) (nca_address + 0xf4));
-
-	/*
-	  Copy from buffer to the data words.
-	*/
-
-	data_word_base = (unsigned long)(nca_address + 0x1000);
-
-	while (4 <= number) {
-		ncr_register_write(*((unsigned long *) buffer),
-				   (unsigned *) data_word_base);
-		data_word_base += 4;
-		buffer += 4;
-		number -= 4;
-	}
-
-	if (0 < number) {
-		unsigned long temp = 0;
-
-		memcpy((void *) &temp, (void *) buffer, number);
-		ncr_register_write(temp, (unsigned *) data_word_base);
-		data_word_base += number;
-		buffer += number;
-		number = 0;
-	}
-
-	cdr0.raw = 0;
-	cdr0.bits.start_done = 1;
-
-	if (0xff == cdr2.bits.target_id_address_upper)
-		cdr0.bits.local_bit = 1;
-
-	cdr0.bits.cmd_type = 5;
-	/* TODO: Verify number... */
-	cdr0.bits.dbs = dbs;
-	ncr_register_write(cdr0.raw, (unsigned *) (nca_address + 0xf0));
-	mb();
-
-	/*
-	  Wait for completion.
-	*/
-
-	do {
-		--wfc_timeout;
-	} while ((0x80000000UL ==
-		  ncr_register_read((unsigned *)(nca_address + 0xf0))) &&
-		 0 < wfc_timeout);
-
-	if (0 == wfc_timeout) {
-		ncr_unlock(LOCK_DOMAIN);
-		return -1;
-	}
-
-	/*
-	  Check status.
-	*/
-
-	if (0x3 !=
-	    ((ncr_register_read((unsigned *) (nca_address + 0xf0)) &
-		0x00c00000) >> 22)) {
-		unsigned long status;
-
-		status = ncr_register_read((unsigned *)(nca_address + 0xe4));
-		ncr_unlock(LOCK_DOMAIN);
-
-		return status;
-	}
-
-	ncr_unlock(LOCK_DOMAIN);
-
-	return 0;
-}
-EXPORT_SYMBOL(ncr_write);
-
-/*
-  ----------------------------------------------------------------------
-  ncr_init
-*/
-
-int
-ncr_init(void)
-{
-	/* We need this to be a module so that the functions can be exported
-	 * as module symbols.
-	 */
-	return 0;
-}
-
-postcore_initcall(ncr_init);
-
-/*
-  ----------------------------------------------------------------------
-  ncr_exit
-*/
-
-void __exit
-ncr_exit(void)
-{
-	/* Unmap the NCA. */
-	iounmap(nca_address);
-}
-
-module_exit(ncr_exit);
-
-MODULE_LICENSE("GPL");
-MODULE_DESCRIPTION("Register Ring access for LSI's ACP board");
diff --git a/arch/powerpc/sysdev/lsi_acp_wrappers.c b/arch/powerpc/sysdev/lsi_acp_wrappers.c
index 6d96e84..724c96c 100644
--- a/arch/powerpc/sysdev/lsi_acp_wrappers.c
+++ b/arch/powerpc/sysdev/lsi_acp_wrappers.c
@@ -19,142 +19,65 @@
  */
 
 #include <linux/module.h>
-#include <linux/spinlock.h>
-#include <linux/sched.h>
-#include <linux/of.h>
-#include <linux/io.h>
 #include <asm/irq.h>
-#include <asm/lsi/acp_ncr.h>
-
-MODULE_AUTHOR("LSI Corporation");
-MODULE_DESCRIPTION("ACP Wrappers");
-MODULE_LICENSE("GPL");
+#include <linux/io.h>
+#include <linux/irqdomain.h>
+#include <linux/skbuff.h>
+#include <linux/platform_device.h>
 
 /*
-  ============================================================================
-  ============================================================================
-  MDIO Access
-  ============================================================================
-  ============================================================================
+  ==============================================================================
+  ==============================================================================
+  Platform Device Registration
+  ==============================================================================
+  ==============================================================================
 */
 
-
-static unsigned long mdio_base;
-static DEFINE_SPINLOCK(mdio_lock);
-
-#define MDIO_CONTROL_RD_DATA ((void *)(mdio_base + 0x0))
-#define MDIO_STATUS_RD_DATA  ((void *)(mdio_base + 0x4))
-#define MDIO_CLK_OFFSET      ((void *)(mdio_base + 0x8))
-#define MDIO_CLK_PERIOD      ((void *)(mdio_base + 0xc))
-
 /*
- * -------------------------------------------------------------------------
- * acp_mdio_read
- */
+  ------------------------------------------------------------------------------
+  acp_platform_device_register
+*/
 
-int acp_mdio_read(unsigned long address, unsigned long offset,
-		  unsigned short *value)
+int
+acp_platform_device_register(struct platform_device *pdev)
 {
-	unsigned long command = 0;
-	unsigned long status;
-	unsigned long flags;
-
-	spin_lock_irqsave(&mdio_lock, flags);
-
-	/* Set the mdio_busy (status) bit. */
-	status = in_le32(MDIO_STATUS_RD_DATA);
-	status |= 0x40000000;
-	out_le32(MDIO_STATUS_RD_DATA, status);
-
-	/* Write the command.*/
-	command |= 0x10000000;	/* op_code: read */
-	command |= (address & 0x1f) << 16; /* port_addr (target device) */
-	command |= (offset & 0x1f) << 21; /* device_addr (target register) */
-	out_le32(MDIO_CONTROL_RD_DATA, command);
-
-	/* Wait for the mdio_busy (status) bit to clear. */
-	do {
-		status = in_le32(MDIO_STATUS_RD_DATA);
-	} while (0 != (status & 0x40000000));
-
-	/* Wait for the mdio_busy (control) bit to clear. */
-	do {
-		command = in_le32(MDIO_CONTROL_RD_DATA);
-	} while (0 != (command & 0x80000000));
-
-	*value = (unsigned short)(command & 0xffff);
-
-	spin_unlock_irqrestore(&mdio_lock, flags);
-
-	return 0;
+	return platform_device_register(pdev);
 }
-EXPORT_SYMBOL(acp_mdio_read);
+EXPORT_SYMBOL(acp_platform_device_register);
 
 /*
- * -------------------------------------------------------------------------
- * acp_mdio_write
- */
+  ------------------------------------------------------------------------------
+  acp_platform_device_unregister
+*/
 
-int acp_mdio_write(unsigned long address, unsigned long offset,
-		   unsigned short value)
+void
+acp_platform_device_unregister(struct platform_device *pdev)
 {
-	unsigned long command = 0;
-	unsigned long status;
-	unsigned long flags;
-
-	spin_lock_irqsave(&mdio_lock, flags);
+	platform_device_unregister(pdev);
 
-	/* Wait for mdio_busy (control) to be clear. */
-	do {
-		command = in_le32(MDIO_CONTROL_RD_DATA);
-	} while (0 != (command & 0x80000000));
-
-	/* Set the mdio_busy (status) bit. */
-	status = in_le32(MDIO_STATUS_RD_DATA);
-	status |= 0x40000000;
-	out_le32(MDIO_STATUS_RD_DATA, status);
-
-	/* Write the command. */
-	command = 0x08000000;	/* op_code: write */
-	command |= (address & 0x1f) << 16; /* port_addr (target device) */
-	command |= (offset & 0x1f) << 21; /* device_addr (target register) */
-	command |= (value & 0xffff); /* value */
-	out_le32(MDIO_CONTROL_RD_DATA, command);
-
-	/* Wait for the mdio_busy (status) bit to clear. */
-	do {
-		status = in_le32(MDIO_STATUS_RD_DATA);
-	} while (0 != (status & 0x40000000));
-
-	/* Wait for the mdio_busy (control) bit to clear. */
-	do {
-		command = in_le32(MDIO_CONTROL_RD_DATA);
-	} while (0 != (command & 0x80000000));
-
-	spin_unlock_irqrestore(&mdio_lock, flags);
-
-	return 0;
+	return;
 }
-EXPORT_SYMBOL(acp_mdio_write);
+EXPORT_SYMBOL(acp_platform_device_unregister);
 
 /*
- * -------------------------------------------------------------------------
- * acp_mdio_initialize
- */
+  ============================================================================
+  ============================================================================
+  SKB
+  ============================================================================
+  ============================================================================
+*/
 
-static int acp_mdio_initialize(void)
-{
-	if (is_asic()) {
-		out_le32(MDIO_CLK_OFFSET, 0x10);
-		out_le32(MDIO_CLK_PERIOD, 0x2c);
-	} else {
-		out_le32(MDIO_CLK_OFFSET, 0x05);
-		out_le32(MDIO_CLK_PERIOD, 0x0c);
-	}
+/*
+  ----------------------------------------------------------------------------
+  acp_skb_tstamp_tx
+*/
 
-	return 0;
+void
+acp_skb_tstamp_tx(struct sk_buff *orig_skb,
+		  struct skb_shared_hwtstamps *hwtstamps) {
+	skb_tstamp_tx(orig_skb, hwtstamps);
 }
-
+EXPORT_SYMBOL(acp_skb_tstamp_tx);
 
 /*
   ============================================================================
@@ -182,131 +105,28 @@ unsigned int acp_irq_create_mapping(struct irq_domain *host,
 EXPORT_SYMBOL(acp_irq_create_mapping);
 
 /*
-  ============================================================================
-  ============================================================================
-  Spin Locks
-  ============================================================================
-  ============================================================================
+  ==============================================================================
+  ==============================================================================
+  Linux Stuff
+  ==============================================================================
+  ==============================================================================
 */
 
 /*
- * -------------------------------------------------------------------------
- * acp_spin_lock_init
- */
-
-void acp_spin_lock_init(spinlock_t *lock)
-{
-	spin_lock_init(lock);
-}
-EXPORT_SYMBOL(acp_spin_lock_init);
-
-/*
- * -------------------------------------------------------------------------
- * acp_spin_lock
- */
-
-void acp_spin_lock(spinlock_t *lock)
-{
-	spin_lock(lock);
-}
-EXPORT_SYMBOL(acp_spin_lock);
-
-/*
- * -------------------------------------------------------------------------
- * acp_spin_unlock
- */
-
-void acp_spin_unlock(spinlock_t *lock)
-{
-	spin_unlock(lock);
-}
-EXPORT_SYMBOL(acp_spin_unlock);
-
-/*
- * -------------------------------------------------------------------------
- * acp_spin_lock_bh
- */
-
-void acp_spin_lock_bh(spinlock_t *lock)
-{
-	spin_lock_bh(lock);
-}
-EXPORT_SYMBOL(acp_spin_lock_bh);
-
-/*
- * -------------------------------------------------------------------------
- * acp_spin_unlock_bh
- */
-
-void acp_spin_unlock_bh(spinlock_t *lock)
-{
-	spin_unlock_bh(lock);
-}
-EXPORT_SYMBOL(acp_spin_unlock_bh);
-
-/*
- * -------------------------------------------------------------------------
- * acp_spin_lock_irqsave
- */
-
-void acp_spin_lock_irqsave(spinlock_t *lock, unsigned long flags)
-{
-	spin_lock_irqsave(lock, flags);
-}
-EXPORT_SYMBOL(acp_spin_lock_irqsave);
-
-/*
- * -------------------------------------------------------------------------
- * acp_spin_unlock_irqrestore
- */
-
-void acp_spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
-{
-	spin_unlock_irqrestore(lock, flags);
-}
-EXPORT_SYMBOL(acp_spin_unlock_irqrestore);
-
-/*
- * -------------------------------------------------------------------------
- * acp_wrappers_init
- */
+  ------------------------------------------------------------------------------
+  acp_wrappers_init
+*/
 
-static int __init acp_wrappers_init(void)
+int __init
+acp_wrappers_init(void)
 {
-	int rc = -1;
-	struct device_node *np = NULL;
-	const u32 *field;
-	u64 mdio_phys_address;
-	u32 mdio_size;
-
-	pr_info("Initializing ACP Wrappers.\n");
-
-	np = of_find_compatible_node(np, "network", "acp-femac");
-	if (np) {
-		field = of_get_property(np, "mdio-reg", NULL);
-
-		if (!field) {
-			pr_err("Couldn't get \"mdio-reg\" property.\n");
-		} else {
-			mdio_phys_address = of_translate_address(np, field);
-			mdio_size = field[1];
-			rc = 0;
-		}
-	}
-
-	if (0 != rc) {
-		mdio_phys_address = 0x002000409000ULL;
-		mdio_size = 0x1000;
-		pr_warn("** MDIO Address Not Specified in Device Tree.\n");
-	}
-
-	mdio_base = (unsigned long)ioremap(mdio_phys_address, mdio_size);
-	rc = acp_mdio_initialize();
-
-	if (0 != rc)
-		pr_err("MDIO Initiailzation Failed!\n");
+	printk(KERN_INFO "Initializing Axxia Wrappers.\n");
 
 	return 0;
 }
 
 module_init(acp_wrappers_init);
+
+MODULE_AUTHOR("LSI Corporation");
+MODULE_DESCRIPTION("Timing Test");
+MODULE_LICENSE("GPL");
diff --git a/arch/powerpc/sysdev/ppc4xx_pci.c b/arch/powerpc/sysdev/ppc4xx_pci.c
index 43e6ce3..f2f4ac1 100644
--- a/arch/powerpc/sysdev/ppc4xx_pci.c
+++ b/arch/powerpc/sysdev/ppc4xx_pci.c
@@ -36,7 +36,7 @@
 #include "ppc4xx_pci.h"
 #ifdef CONFIG_ACP
 #include <linux/interrupt.h>
-#include <asm/lsi/acp_ncr.h>
+#include "../../../drivers/misc/lsi-ncr.h"
 static int acp_plx;
 #endif
 
-- 
1.7.5.4

