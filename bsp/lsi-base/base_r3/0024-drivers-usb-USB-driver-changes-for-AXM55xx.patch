From ed11219c7ec22d00f53fb86322b58b1a386b9daf Mon Sep 17 00:00:00 2001
From: SangeethaRao <sangeetha.rao@lsi.com>
Date: Thu, 5 Sep 2013 12:59:35 -0500
Subject: [PATCH 24/75] drivers/usb: USB driver changes for AXM55xx
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

CONFIG_LSI_USB_SW_WORKAROUND Kconfig definition since AXM55xx doesnâ€™t
need EHCI controller workarounds that were required in older devices.

Signed-off-by: SangeethaRao <sangeetha.rao@lsi.com>
---
 arch/arm/boot/dts/axm55xx.dts   |    9 ++++++
 drivers/usb/host/ehci-ci13612.c |   58 +++++++++++++++++++++++++++++++++++---
 2 files changed, 62 insertions(+), 5 deletions(-)

diff --git a/arch/arm/boot/dts/axm55xx.dts b/arch/arm/boot/dts/axm55xx.dts
index d6c776f..cbffa89 100644
--- a/arch/arm/boot/dts/axm55xx.dts
+++ b/arch/arm/boot/dts/axm55xx.dts
@@ -246,6 +246,15 @@
 		mac-address = [00 00 00 00 00 00];
 	};
 
+	USB0: usb@004a4000 {
+		device_type = "usb";
+		compatible = "lsi,acp-usb";
+		enabled = <0>;
+		reg = <0x20 0x10140000 0x0 0020000>,
+		      <0x20 0x10094000 0x0 0002000>;
+		interrupts = <0 55 4>;
+	};
+
         amba {
 		compatible = "arm,amba-bus";
 		#address-cells = <2>;
diff --git a/drivers/usb/host/ehci-ci13612.c b/drivers/usb/host/ehci-ci13612.c
index e7e54cd..4f9e4b1 100644
--- a/drivers/usb/host/ehci-ci13612.c
+++ b/drivers/usb/host/ehci-ci13612.c
@@ -24,9 +24,15 @@
 #include <linux/platform_device.h>
 #include <linux/irq.h>
 #include <linux/of_platform.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
 #include "ehci-ci13612.h"
 
 
+#ifdef CONFIG_LSI_USB_SW_WORKAROUND
 static void ci13612_usb_setup(struct usb_hcd *hcd)
 {
 	int USB_TXFIFOTHRES, VUSB_HS_TX_BURST;
@@ -59,6 +65,7 @@ static void ci13612_usb_setup(struct usb_hcd *hcd)
 
 	return;
 }
+#endif
 
 /* called after powerup, by probe or system-pm "wakeup" */
 static int ehci_ci13612_reinit(struct ehci_hcd *ehci)
@@ -66,9 +73,9 @@ static int ehci_ci13612_reinit(struct ehci_hcd *ehci)
 #ifdef CONFIG_LSI_USB_SW_WORKAROUND
 	/* S/W workarounds are not needed in AXM55xx */
 	ci13612_usb_setup(ehci_to_hcd(ehci));
-#endif
-	ehci_port_power(ehci, 0);
 
+	ehci_port_power(ehci, 0);
+#endif
 	return 0;
 }
 
@@ -79,7 +86,6 @@ static int ci13612_ehci_init(struct usb_hcd *hcd)
 	int retval = 0;
 	int len;
 
-
 	/* EHCI registers start at offset 0x100 */
 	ehci->caps = hcd->regs + 0x100;
 	ehci->regs = hcd->regs + 0x100
@@ -109,11 +115,13 @@ static int ci13612_ehci_init(struct usb_hcd *hcd)
 static int ehci_run_fix(struct usb_hcd *hcd)
 {
 	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+#ifdef CONFIG_LSI_USB_SW_WORKAROUND
 	u32 port_status;
+#endif
 	unsigned burst_size;
 	int retval;
-#ifdef CONFIG_LSI_USB_SW_WORKAROUND
 
+#ifdef CONFIG_LSI_USB_SW_WORKAROUND
 	/* Fix a HW erratum during the USB reset process. */
 	port_status = ehci_readl(ehci, &ehci->regs->port_status[0]);
 	printk(KERN_INFO "ehci_run: port_status = 0x%x\n", port_status);
@@ -131,6 +139,25 @@ static int ehci_run_fix(struct usb_hcd *hcd)
 	burst_size = (burst_size & 0xffff00ff) | 0x4000;	/* TXPBURST */
 	ehci_writel(ehci, burst_size, &ehci->regs->reserved[1]);
 
+#else
+#if 1
+    /* Fix for HW errata 9000373951: You can adjust the burst size and fill the
+     * level to minimize under-run possibilities. In the failing case, the
+     * transfer size was 96 bytes, the burst size was 16, and the fill
+     * threshold level was set to 2. Because of this, the Host core issued
+     * the Out token when it requested the second burst of data. If the
+     * burst size had been changed to 8, and the fill level set to 3,
+     * then the core would have pre-fetched the 96 bytes before issuing
+     * the OUT token.
+     */
+	burst_size = ehci_readl(ehci, &ehci->regs->reserved[1]);
+	burst_size = (burst_size & 0xffff00ff) | 0x4000;	/* TXPBURST */
+	ehci_writel(ehci, burst_size, &ehci->regs->reserved[1]);
+
+	retval = ehci_run(hcd);
+	if (retval)
+		return retval;
+#endif
 #endif
 
 	return 0;
@@ -170,6 +197,7 @@ static int ci13612_ehci_probe(struct platform_device *pdev)
 	struct device_node *np = pdev->dev.of_node;
 	struct resource *res;
 
+#ifdef CONFIG_LSI_USB_SW_WORKAROUND
 	if (!of_device_is_available(np))
 		return -ENODEV;
 
@@ -185,12 +213,29 @@ static int ci13612_ehci_probe(struct platform_device *pdev)
 		goto fail_create_hcd;
 	}
 
+	if (0 != irq_set_irq_type(87, IRQ_TYPE_LEVEL_HIGH)) {
+		dev_dbg(&pdev->dev, "set_irq_type() failed\n");
+		retval = -EBUSY;
+		goto fail_create_hcd;
+	}
+#else
+
+	irq = irq_of_parse_and_map(np, 0);
+	if (NO_IRQ == irq) {
+		dev_dbg(&pdev->dev, "error getting irq number\n");
+		retval = -EBUSY;
+		goto fail_create_hcd;
+	}
+
 	if (0 != irq_set_irq_type(irq, IRQ_TYPE_LEVEL_HIGH)) {
 		dev_dbg(&pdev->dev, "set_irq_type() failed\n");
 		retval = -EBUSY;
 		goto fail_create_hcd;
 	}
 
+#endif
+
+
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
 		dev_err(&pdev->dev, "Error: resource addr %s setup!\n",
@@ -224,7 +269,10 @@ static int ci13612_ehci_probe(struct platform_device *pdev)
 	} else {
 		/* Setup GPREG for USB to enable the 6-bit address line */
 		writel(0x0, gpreg_base + 0x8);
-
+#ifndef CONFIG_LSI_USB_SW_WORKAROUND
+		/* setup hprot for uncached USB mode */
+		writel(0x0, gpreg_base + 0x74);
+#endif
 		iounmap(gpreg_base);
 	}
 
-- 
1.7.5.4

