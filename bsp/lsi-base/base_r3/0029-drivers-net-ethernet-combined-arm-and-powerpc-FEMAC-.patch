From daba5c7ea23478f21712a7e863de4043cd8402cc Mon Sep 17 00:00:00 2001
From: David Mercado <david.mercado@windriver.com>
Date: Wed, 11 Sep 2013 11:48:55 -0400
Subject: [PATCH 29/75] drivers/net/ethernet: combined arm and powerpc FEMAC
 ethernet driver

Finalized changes and integration test with amarillo board.

Signed-off-by: David Mercado <david.mercado@windriver.com>
---
 drivers/net/ethernet/lsi/lsi_acp_net.c |   71 ++++++++++++++++++-------------
 drivers/net/ethernet/lsi/lsi_acp_net.h |    6 +-
 2 files changed, 44 insertions(+), 33 deletions(-)

diff --git a/drivers/net/ethernet/lsi/lsi_acp_net.c b/drivers/net/ethernet/lsi/lsi_acp_net.c
index ef1d78f..c91722c 100644
--- a/drivers/net/ethernet/lsi/lsi_acp_net.c
+++ b/drivers/net/ethernet/lsi/lsi_acp_net.c
@@ -27,15 +27,33 @@
  *
  *    ethaddr - MAC address of interface, in xx:xx:xx:xx:xx:xx format
  *
- *    ad_value - PHY advertise value. Can be set to one of these or multiple
- *               can be OR'ed together. If not set, the driver defaults to
- *               the OR'ed quantity of all four (0x1e1).
+ *    phy-addr - Specific address of PHY (0 - 0x20). If not specified,
+ *               the driver will scan the bus and will attach to the first
+ *               PHY it finds.
+ *
+ *    ad-value - PHY advertise value. Can be set to one of these or they
+ *               be OR'ed together. If not set, the driver sets the
+ *               advertised value equal to what the driver supports.
  *
  *               0x101 - 100/Full
  *               0x81  - 100/Half
  *               0x41  - 10/Full
  *               0x21  - 10/Half
  *
+ * 3) This driver allows the option to disable auto negotiation and manually
+ *    specify the speed and duplex setting, with the use of the device tree
+ *    variable "phy-link". Legal values for this variable are:
+ *
+ *    "auto"  - auto negotiation enabled
+ *    "100MF" - auto negotation disabled, set to 100MB Full Duplex
+ *    "10MH"  - auto negotation disabled, set to 100MB Half Duplex
+ *    "10MF"  - auto negotation disabled, set to 10MB Full Duplex
+ *    "10MH"  - auto negotation disabled, set to 10MB Half Duplex
+ *
+ *    NOTE: If the phy-link variable is not present in the device tree, or
+ *    if an invalid value is used, the driver defaults to auto negotiation
+ *    mode.
+ *
  */
 
 #include <linux/module.h>
@@ -72,8 +90,8 @@
 #include <asm/lsi/acp_ncr.h>
 #include "lsi_acp_net.h"
 
+/* Define to disable full duplex mode on Amarillo boards */
 #undef AMARILLO_WA
-/*#define AMARILLO_WA*/
 
 #define LSI_DRV_NAME           "acp-femac"
 #define LSI_MDIO_NAME          "acp-femac-mdio"
@@ -152,11 +170,12 @@ static void appnic_handle_link_change(struct net_device *dev)
 	if (phydev->link) {
 		if ((pdata->speed != phydev->speed) ||
 		    (pdata->duplex != phydev->duplex)) {
-
+#ifndef AMARILLO_WA
 			if (phydev->duplex) {
 				rx_configuration |= APPNIC_RX_CONF_DUPLEX;
 				tx_configuration |= APPNIC_TX_CONF_DUPLEX;
 			}
+#endif
 			if (phydev->speed == SPEED_100) {
 				rx_configuration |= APPNIC_RX_CONF_SPEED;
 				tx_configuration |= APPNIC_TX_CONF_SPEED;
@@ -181,11 +200,6 @@ static void appnic_handle_link_change(struct net_device *dev)
 		status_change = 1;
 	}
 
-#ifdef AMARILLO_WA
-	rx_configuration &= ~0x1000;
-	tx_configuration &= ~0x1000;
-#endif
-
 	if (status_change) {
 		if (phydev->link) {
 			netif_carrier_on(dev);
@@ -236,10 +250,11 @@ static int appnic_mii_probe(struct net_device *dev)
 skip_first:
 
 	/*
-	 * For the Axxia AXM, allow the option to disable auto
-	 * negotiation and manually specify the speed and duplex
-	 * setting with the use of a environment setting.
+	 * Allow the option to disable auto negotiation and manually specify
+	 * the link speed and duplex setting with the use of a environment
+	 * setting.
 	 */
+
 	if (0 == pdata->phy_link_auto) {
 		phydev->autoneg = AUTONEG_DISABLE;
 		phydev->speed =
@@ -279,14 +294,16 @@ skip_first:
 		rc = acp_mdio_write(phydev->addr, PHY_BCM_TEST_REG, val);
 	}
 #endif
-
 	netdev_info(dev,
 		    "attached PHY driver [%s] (mii_bus:phy_addr=%s, irq=%d)\n",
 		    phydev->drv->name, dev_name(&phydev->dev), phydev->irq);
 
 	/* Mask with MAC supported features */
 	phydev->supported &= PHY_BASIC_FEATURES;
-	phydev->advertising = mii_adv_to_ethtool_adv_t(pdata->ad_value);
+	if (pdata->ad_value)
+		phydev->advertising = mii_adv_to_ethtool_adv_t(pdata->ad_value);
+	else
+		phydev->advertising = phydev->supported;
 
 	pdata->link = 0;
 	pdata->speed = 0;
@@ -1119,7 +1136,6 @@ static int appnic_hard_start_xmit(struct sk_buff *skb,
 	length = skb->len < ETH_ZLEN ? ETH_ZLEN : skb->len;
 	buf_per_desc = pdata->tx_buf_sz / pdata->tx_num_desc;
 
-	/* dump_registers(dev); */
 	/*
 	 * If enough transmit descriptors are available, copy and transmit.
 	 */
@@ -1430,10 +1446,10 @@ int appnic_init(struct net_device *dev)
 				   &pdata->dma_alloc_dma,
 				   GFP_KERNEL);
 #else
-	device->dev.archdata.dma_ops = &dma_direct_ops;
+	dev->dev.archdata.dma_ops = &dma_direct_ops;
 
 	pdata->dma_alloc = (void *)
-		dma_alloc_coherent(&device->dev,
+		dma_alloc_coherent(&dev->dev,
 				   pdata->dma_alloc_size,
 				   &pdata->dma_alloc_dma,
 				   GFP_KERNEL);
@@ -1760,13 +1776,12 @@ static int __devinit appnic_probe_config_dt(struct net_device *dev,
 {
 	struct appnic_device *pdata = netdev_priv(dev);
 	const u32 *field;
+	const char *macspeed;
+	int length;
 #ifndef CONFIG_ARM
 	u64 value64;
 	u32 value32;
-#else
-	const char *macspeed;
 #endif
-	int length;
 
 	if (!np)
 		return -ENODEV;
@@ -1844,7 +1859,6 @@ static int __devinit appnic_probe_config_dt(struct net_device *dev,
 		pdata->ad_value = field[0];
 #endif
 
-#ifdef CONFIG_ARM
 	macspeed = of_get_property(np, "phy-link", NULL);
 
 	if (macspeed) {
@@ -1866,12 +1880,15 @@ static int __devinit appnic_probe_config_dt(struct net_device *dev,
 			pdata->phy_link_auto = 0;
 			pdata->phy_link_speed = 0;
 			pdata->phy_link_duplex = 0;
+		} else {
+			pr_err("Invalid phy-link value \"%s\" in DTS. Defaulting to \"auto\".\n",
+			       macspeed);
+			pdata->phy_link_auto = 1;
 		}
 	} else {
 		/* Auto is the default. */
 		pdata->phy_link_auto = 1;
 	}
-#endif
 
 	field = of_get_property(np, "mac-address", &length);
 	if (!field || 6 != length) {
@@ -1991,7 +2008,7 @@ static int __devinit appnic_drv_probe(struct platform_device *pdev)
 			dma_base = ioremap(0x002000482000ULL, 0x1000);
 			pdata->dma_base =
 			 (unsigned long)ioremap(0x002000482000ULL, 0x1000);
-			pdata->interrupt = 33;
+			pdata->dma_interrupt = 33;
 		}
 #else
 		/* Neither dtb info nor ubootenv driver found. */
@@ -2020,12 +2037,6 @@ static int __devinit appnic_drv_probe(struct platform_device *pdev)
 	}
 
 #endif
-	/* ad_value should never be 0. */
-	if (pdata->ad_value == 0) {
-		pdata->ad_value = 0x1e1;
-		pr_err("%s: Set ad_value to default of 0x%lx\n",
-		       LSI_DRV_NAME, pdata->ad_value);
-	}
 
 	/* Initialize the device. */
 	rc = appnic_init(dev);
diff --git a/drivers/net/ethernet/lsi/lsi_acp_net.h b/drivers/net/ethernet/lsi/lsi_acp_net.h
index 9289073..7b6f2b3 100644
--- a/drivers/net/ethernet/lsi/lsi_acp_net.h
+++ b/drivers/net/ethernet/lsi/lsi_acp_net.h
@@ -86,7 +86,7 @@ struct appnic_dma_descriptor {
 	unsigned long host_data_memory_pointer;
 #endif
 
-} __attribute__ ((packed));
+} __packed;
 
 union appnic_queue_pointer {
 
@@ -102,9 +102,9 @@ union appnic_queue_pointer {
 		unsigned long generation_bit:1;
 		unsigned long offset:20;
 #endif
-	} __attribute__ ((packed)) bits;
+	} __packed bits;
 
-} __attribute__ ((packed));
+} __packed;
 
 /*
   =============================================================================
-- 
1.7.5.4

