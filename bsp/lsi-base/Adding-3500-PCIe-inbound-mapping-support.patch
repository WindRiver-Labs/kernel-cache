From e3390f79d15b354f4f5a64e66501bccd8b0f0047 Mon Sep 17 00:00:00 2001
From: SangeethaRao <sangeetha.rao@lsi.com>
Date: Thu, 5 Jun 2014 12:09:09 -0500
Subject: [PATCH 1/2] Adding 3500 PCIe inbound mapping support

the patch come from:
https://github.com/lsigithub/lsi_axxia_yocto/commit/6a88323699d6d33ed91dee229d70ac5d78113b1e

Signed-off-by: SangeethaRao <sangeetha.rao@lsi.com>
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 arch/powerpc/sysdev/ppc4xx_pci.c |   40 +++++++++++++++++++++++++++++++++----
 1 files changed, 35 insertions(+), 5 deletions(-)

diff --git a/arch/powerpc/sysdev/ppc4xx_pci.c b/arch/powerpc/sysdev/ppc4xx_pci.c
index 09befb2..a7df612 100644
--- a/arch/powerpc/sysdev/ppc4xx_pci.c
+++ b/arch/powerpc/sysdev/ppc4xx_pci.c
@@ -2365,15 +2365,45 @@ ppc4xx_configure_acp_pciex_PIMs(struct ppc4xx_pciex_port *port,
 		  dma_base.
 		*/
 
-		pci_dram_offset = size;
-		hose->dma_window_base_cur = size;
-
-		out_le32(mbase + PCI_BASE_ADDRESS_0, RES_TO_U32_LOW(size));
-		out_le32(mbase + PCI_BASE_ADDRESS_1, RES_TO_U32_HIGH(size));
+		if (0x10 == port->acpChipType) {
+			/* For 3500, set base address to pci base */
+			pci_dram_offset = res->start;
+			hose->dma_window_base_cur = res->start;
+		} else {
+			pci_dram_offset = size;
+			hose->dma_window_base_cur = size;
+		}
 
 		if (5 == port->acpChipType) {
 			printk(KERN_WARNING "Setting SIZE for 2500\n");
 			out_le32(mbase + 0x11f4, 0xf0000000UL);
+			out_le32(mbase + PCI_BASE_ADDRESS_0,
+				RES_TO_U32_LOW(size));
+			out_le32(mbase + PCI_BASE_ADDRESS_1,
+				RES_TO_U32_HIGH(size));
+		} else if (0x10 == port->acpChipType) {
+			printk(KERN_WARNING "Setting SIZE for 3500\n");
+			out_le32(mbase + 0x11f4, size);
+			/* Verify BAR0 size */
+			{
+				u32 bar0_size;
+				out_le32(mbase + PCI_BASE_ADDRESS_0, ~0);
+				out_le32(mbase + PCI_BASE_ADDRESS_1, ~0);
+				bar0_size = in_le32(mbase + PCI_BASE_ADDRESS_0);
+				if ((bar0_size & ~0xf) != size)
+					pr_err("PCIE%d: Config BAR0 failed\n",
+						port->index);
+				bar0_size = in_le32(mbase + PCI_BASE_ADDRESS_1);
+			}
+			/* Set the BASE0 address to start of PCIe base */
+			out_le32(mbase + PCI_BASE_ADDRESS_0, res->start);
+			/* Set the BASE1 address to 0x0 */
+			out_le32(mbase + PCI_BASE_ADDRESS_1, 0x0);
+		} else {
+			out_le32(mbase + PCI_BASE_ADDRESS_0,
+				RES_TO_U32_LOW(size));
+			out_le32(mbase + PCI_BASE_ADDRESS_1,
+				RES_TO_U32_HIGH(size));
 		}
 
 		/*
-- 
1.7.5.4

