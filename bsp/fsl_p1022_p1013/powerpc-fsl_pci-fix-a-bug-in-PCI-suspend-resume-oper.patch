From 1d7cdbca7db1708f734b956c69f38fd8820869af Mon Sep 17 00:00:00 2001
From: Shan Hai <shan.hai@windriver.com>
Date: Mon, 22 Jul 2013 09:55:36 +0800
Subject: [PATCH] powerpc/fsl_pci: fix a bug in PCI suspend/resume operations

Save/restore register contexts according to the available pcie controller
which is described in the DTB on suspend/resume operations, otherwise certain
PCIe-to-USB device could not be awoken after resuming from suspention.

Signed-off-by: Shan Hai <shan.hai@windriver.com>
---
 arch/powerpc/sysdev/fsl_pci.c |   30 ++++++++++++++++++------------
 1 files changed, 18 insertions(+), 12 deletions(-)

diff --git a/arch/powerpc/sysdev/fsl_pci.c b/arch/powerpc/sysdev/fsl_pci.c
index ae19eea..e9e1aef 100644
--- a/arch/powerpc/sysdev/fsl_pci.c
+++ b/arch/powerpc/sysdev/fsl_pci.c
@@ -681,8 +681,11 @@ struct fsl_pcie_ctrl {
 /* save pci registers */
 static int fsl_pci_suspend(struct of_device *ofdev, pm_message_t state)
 {
+	int i, j, win_idx = 3;
 	struct fsl_pcie_ctrl *ctrl = dev_get_drvdata(&ofdev->dev);
-	int i;
+
+	if (of_device_is_compatible(ofdev->node, "fsl,qoriq-pcie-v2.2"))
+		win_idx = 2;
 
 	for (i = 0; i < 5; i++) {
 		ctrl->pow_save[i].potar = ctrl->regs->pow[i].potar;
@@ -691,11 +694,11 @@ static int fsl_pci_suspend(struct of_device *ofdev, pm_message_t state)
 		ctrl->pow_save[i].powar = ctrl->regs->pow[i].powar;
 	}
 
-	for (i = 0; i < 3; i++) {
-		ctrl->piw_save[i].pitar = ctrl->regs->piw[i].pitar;
-		ctrl->piw_save[i].piwbar = ctrl->regs->piw[i].piwbar;
-		ctrl->piw_save[i].piwbear = ctrl->regs->piw[i].piwbear;
-		ctrl->piw_save[i].piwar = ctrl->regs->piw[i].piwar;
+	for (i = 2, j = win_idx; i >= 0 ; i--, j--) {
+		ctrl->piw_save[i].pitar = ctrl->regs->piw[j].pitar;
+		ctrl->piw_save[i].piwbar = ctrl->regs->piw[j].piwbar;
+		ctrl->piw_save[i].piwbear = ctrl->regs->piw[j].piwbear;
+		ctrl->piw_save[i].piwar = ctrl->regs->piw[j].piwar;
 	}
 
 	return 0;
@@ -704,8 +707,11 @@ static int fsl_pci_suspend(struct of_device *ofdev, pm_message_t state)
 /* restore pci registers */
 static int fsl_pci_resume(struct of_device *ofdev)
 {
+	int i, j, win_idx = 3;
 	struct fsl_pcie_ctrl *ctrl = dev_get_drvdata(&ofdev->dev);
-	int i;
+
+	if (of_device_is_compatible(ofdev->node, "fsl,qoriq-pcie-v2.2"))
+		win_idx = 2;
 
 	for (i = 0; i < 5; i++) {
 		ctrl->regs->pow[i].potar = ctrl->pow_save[i].potar;
@@ -714,11 +720,11 @@ static int fsl_pci_resume(struct of_device *ofdev)
 		ctrl->regs->pow[i].powar = ctrl->pow_save[i].powar;
 	}
 
-	for (i = 0; i < 3; i++) {
-		ctrl->regs->piw[i].pitar = ctrl->piw_save[i].pitar;
-		ctrl->regs->piw[i].piwbar = ctrl->piw_save[i].piwbar;
-		ctrl->regs->piw[i].piwbear = ctrl->piw_save[i].piwbear;
-		ctrl->regs->piw[i].piwar = ctrl->piw_save[i].piwar;
+	for (i = 2, j = win_idx; i >= 0; i--, j--) {
+		ctrl->regs->piw[j].pitar = ctrl->piw_save[i].pitar;
+		ctrl->regs->piw[j].piwbar = ctrl->piw_save[i].piwbar;
+		ctrl->regs->piw[j].piwbear = ctrl->piw_save[i].piwbear;
+		ctrl->regs->piw[j].piwar = ctrl->piw_save[i].piwar;
 	}
 
 	return 0;
-- 
1.7.0

