From 102525ad7e6141002b3ee34141a281be88c7cc1e Mon Sep 17 00:00:00 2001
From: Yang Shi <yang.shi@windriver.com>
Date: Tue, 21 Sep 2010 12:49:48 +0800
Subject: [PATCH] preempt_rt: gianfar: Replace tx/rx locks to raw spin locks

During suspend/resume operation, sleepable spinlocks introduce
call trace:

BUG: sleeping function called from invalid context at
/home/ljiang0/work/fsl_p1022_prt_cgl/build/linux/kernel/rtmutex.c:707
pcnt: 0 0 in_atomic(): 0, irqs_disabled(): 1, pid: 693, name: bash
Call Trace:
[ee149cc0] [c000842c] show_stack+0x44/0x160 (unreliable)
[ee149cf0] [c003c85c] __might_sleep+0xe4/0x108
[ee149d00] [c04785ec] rt_spin_lock+0x38/0xb4
[ee149d10] [c02fe49c] lock_tx_qs+0x38/0x58
[ee149d30] [c02fed6c] gfar_suspend+0xa4/0x184
[ee149d50] [c03a6788] of_platform_pm_suspend+0x38/0x84
[ee149d60] [c02b7ce4] pm_op+0x90/0x140
[ee149d90] [c02b83c4] __device_suspend+0x104/0x18c
[ee149dc0] [c02b8a44] dpm_suspend_start+0x290/0x44c
[ee149e30] [c0090808] suspend_devices_and_enter+0x98/0x20c
[ee149e60] [c0090a60] enter_state+0xe4/0xf4
[ee149e80] [c008ffe4] state_store+0x9c/0x108
[ee149ea0] [c0247c2c] kobj_attr_store+0x24/0x3c
[ee149eb0] [c017809c] sysfs_write_file+0xe4/0x1dc
[ee149ee0] [c0118c34] vfs_write+0xb4/0x188
[ee149f00] [c0118e7c] sys_write+0x50/0x10c
[ee149f40] [c0011cec] ret_from_syscall+0x0/0x4

So, replace sleepable tx/rx spin locks to raw spin locks.

Signed-off-by: Yang Shi <yang.shi@windriver.com>
---
 drivers/net/gianfar.c |   20 ++++++++++----------
 drivers/net/gianfar.h |    4 ++--
 2 files changed, 12 insertions(+), 12 deletions(-)

diff --git a/drivers/net/gianfar.c b/drivers/net/gianfar.c
index 7b64136..82df3f9 100644
--- a/drivers/net/gianfar.c
+++ b/drivers/net/gianfar.c
@@ -472,7 +472,7 @@ void lock_rx_qs(struct gfar_private *priv)
 	int i = 0x0;
 
 	for (i = 0; i < priv->num_rx_queues; i++)
-		spin_lock(&priv->rx_queue[i]->rxlock);
+		raw_spin_lock(&priv->rx_queue[i]->rxlock);
 }
 
 void lock_tx_qs(struct gfar_private *priv)
@@ -480,7 +480,7 @@ void lock_tx_qs(struct gfar_private *priv)
 	int i = 0x0;
 
 	for (i = 0; i < priv->num_tx_queues; i++)
-		spin_lock(&priv->tx_queue[i]->txlock);
+		raw_spin_lock(&priv->tx_queue[i]->txlock);
 }
 
 void unlock_rx_qs(struct gfar_private *priv)
@@ -488,7 +488,7 @@ void unlock_rx_qs(struct gfar_private *priv)
 	int i = 0x0;
 
 	for (i = 0; i < priv->num_rx_queues; i++)
-		spin_unlock(&priv->rx_queue[i]->rxlock);
+		raw_spin_unlock(&priv->rx_queue[i]->rxlock);
 }
 
 void unlock_tx_qs(struct gfar_private *priv)
@@ -496,7 +496,7 @@ void unlock_tx_qs(struct gfar_private *priv)
 	int i = 0x0;
 
 	for (i = 0; i < priv->num_tx_queues; i++)
-		spin_unlock(&priv->tx_queue[i]->txlock);
+		raw_spin_unlock(&priv->tx_queue[i]->txlock);
 }
 
 /* Returns 1 if incoming frames use an FCB */
@@ -682,7 +682,7 @@ static int gfar_of_init(struct of_device *ofdev, struct net_device **pdev)
 		priv->tx_queue[i]->tx_skbuff = NULL;
 		priv->tx_queue[i]->qindex = i;
 		priv->tx_queue[i]->dev = dev;
-		spin_lock_init(&(priv->tx_queue[i]->txlock));
+		raw_spin_lock_init(&(priv->tx_queue[i]->txlock));
 	}
 
 	for (i = 0; i < priv->num_rx_queues; i++) {
@@ -695,7 +695,7 @@ static int gfar_of_init(struct of_device *ofdev, struct net_device **pdev)
 		priv->rx_queue[i]->rx_skbuff = NULL;
 		priv->rx_queue[i]->qindex = i;
 		priv->rx_queue[i]->dev = dev;
-		spin_lock_init(&(priv->rx_queue[i]->rxlock));
+		raw_spin_lock_init(&(priv->rx_queue[i]->rxlock));
 	}
 
 
@@ -2114,7 +2114,7 @@ static int gfar_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	 * also must grab the lock before setting ready bit for the first
 	 * to be transmitted BD.
 	 */
-	spin_lock_irqsave(&tx_queue->txlock, flags);
+	raw_spin_lock_irqsave(&tx_queue->txlock, flags);
 
 	/*
 	 * The powerpc-specific eieio() is used, as wmb() has too strong
@@ -2156,7 +2156,7 @@ static int gfar_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	gfar_write(&regs->tstat, TSTAT_CLEAR_THALT >> tx_queue->qindex);
 
 	/* Unlock priv */
-	spin_unlock_irqrestore(&tx_queue->txlock, flags);
+	raw_spin_unlock_irqrestore(&tx_queue->txlock, flags);
 
 	return NETDEV_TX_OK;
 }
@@ -2393,9 +2393,9 @@ static int gfar_clean_tx_ring(struct gfar_priv_tx_q *tx_queue)
 			TX_RING_MOD_MASK(tx_ring_size);
 
 		howmany++;
-		spin_lock_irqsave(&tx_queue->txlock, flags);
+		raw_spin_lock_irqsave(&tx_queue->txlock, flags);
 		tx_queue->num_txbdfree += frags + 1;
-		spin_unlock_irqrestore(&tx_queue->txlock, flags);
+		raw_spin_unlock_irqrestore(&tx_queue->txlock, flags);
 	}
 
 	/* If we freed a buffer, we can restart transmission, if necessary */
diff --git a/drivers/net/gianfar.h b/drivers/net/gianfar.h
index 9c23f12..d1f4a14 100644
--- a/drivers/net/gianfar.h
+++ b/drivers/net/gianfar.h
@@ -925,7 +925,7 @@ enum {
  *	@txtime: coalescing value if based on time
  */
 struct gfar_priv_tx_q {
-	spinlock_t txlock __attribute__ ((aligned (SMP_CACHE_BYTES)));
+	raw_spinlock_t txlock __attribute__ ((aligned (SMP_CACHE_BYTES)));
 	struct sk_buff ** tx_skbuff;
 	/* Buffer descriptor pointers */
 	dma_addr_t tx_bd_dma_base;
@@ -970,7 +970,7 @@ struct rx_q_stats {
  */
 
 struct gfar_priv_rx_q {
-	spinlock_t rxlock __attribute__ ((aligned (SMP_CACHE_BYTES)));
+	raw_spinlock_t rxlock __attribute__ ((aligned (SMP_CACHE_BYTES)));
 	struct	sk_buff ** rx_skbuff;
 	dma_addr_t rx_bd_dma_base;
 	struct	rxbd8 *rx_bd_base;
-- 
1.6.5.2

