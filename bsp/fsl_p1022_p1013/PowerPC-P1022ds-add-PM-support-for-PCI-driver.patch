From 58636012f270df6b8289037c7f4444bf394ec94f Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Wed, 1 Dec 2010 14:10:47 +0800
Subject: [PATCH 2/6] PowerPC:P1022ds add PM support for PCI driver.

Add PM support for PCI driver of P1022ds. The driver would probe
successfully when there are nodes compatible with "fsl,p1022-pcie".

The driver would save PCIe register when suspend, and restore PCIe
registers when resume from sleep.

The patch has been validated with PM feature using NFS rootfs via
e1000e PCIe NIC on P1022ds platform.

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 arch/powerpc/platforms/85xx/p1022_ds.c |    1 +
 arch/powerpc/sysdev/fsl_pci.c          |  133 ++++++++++++++++++++++++++++++++
 2 files changed, 134 insertions(+), 0 deletions(-)

diff --git a/arch/powerpc/platforms/85xx/p1022_ds.c b/arch/powerpc/platforms/85xx/p1022_ds.c
index a931ef4..198a0e8 100644
--- a/arch/powerpc/platforms/85xx/p1022_ds.c
+++ b/arch/powerpc/platforms/85xx/p1022_ds.c
@@ -302,6 +302,7 @@ static struct of_device_id __initdata p1022_ds_ids[] = {
 	{ .compatible = "soc", },
 	{ .compatible = "simple-bus", },
 	{ .compatible = "gianfar", },
+	{ .compatible = "fsl,p1022-pcie", },
 	{},
 };
 
diff --git a/arch/powerpc/sysdev/fsl_pci.c b/arch/powerpc/sysdev/fsl_pci.c
index 91d0d76..395e205 100644
--- a/arch/powerpc/sysdev/fsl_pci.c
+++ b/arch/powerpc/sysdev/fsl_pci.c
@@ -26,6 +26,8 @@
 #include <linux/lmb.h>
 #include <linux/log2.h>
 #include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/of_platform.h>
 
 #include <asm/io.h>
 #include <asm/prom.h>
@@ -702,3 +704,134 @@ err0:
 	return ret;
 }
 #endif /* CONFIG_PPC_83xx */
+
+struct fsl_pcie_ctrl {
+	struct ccsr_pci __iomem *regs;
+#ifdef CONFIG_SUSPEND
+	struct pci_outbound_window_regs pow_save[5];
+	struct pci_inbound_window_regs piw_save[3];
+#endif
+};
+
+#ifdef CONFIG_SUSPEND
+/* save pci registers */
+static int fsl_pci_suspend(struct of_device *ofdev, pm_message_t state)
+{
+	struct fsl_pcie_ctrl *ctrl = dev_get_drvdata(&ofdev->dev);
+	int i;
+
+	for (i = 0; i < 5; i++) {
+		ctrl->pow_save[i].potar = ctrl->regs->pow[i].potar;
+		ctrl->pow_save[i].potear = ctrl->regs->pow[i].potear;
+		ctrl->pow_save[i].powbar = ctrl->regs->pow[i].powbar;
+		ctrl->pow_save[i].powar = ctrl->regs->pow[i].powar;
+	}
+
+	for (i = 0; i < 3; i++) {
+		ctrl->piw_save[i].pitar = ctrl->regs->piw[i].pitar;
+		ctrl->piw_save[i].piwbar = ctrl->regs->piw[i].piwbar;
+		ctrl->piw_save[i].piwbear = ctrl->regs->piw[i].piwbear;
+		ctrl->piw_save[i].piwar = ctrl->regs->piw[i].piwar;
+	}
+
+	return 0;
+}
+
+/* restore pci registers */
+static int fsl_pci_resume(struct of_device *ofdev)
+{
+	struct fsl_pcie_ctrl *ctrl = dev_get_drvdata(&ofdev->dev);
+	int i;
+
+	for (i = 0; i < 5; i++) {
+		ctrl->regs->pow[i].potar = ctrl->pow_save[i].potar;
+		ctrl->regs->pow[i].potear = ctrl->pow_save[i].potear;
+		ctrl->regs->pow[i].powbar = ctrl->pow_save[i].powbar;
+		ctrl->regs->pow[i].powar = ctrl->pow_save[i].powar;
+	}
+
+	for (i = 0; i < 3; i++) {
+		ctrl->regs->piw[i].pitar = ctrl->piw_save[i].pitar;
+		ctrl->regs->piw[i].piwbar = ctrl->piw_save[i].piwbar;
+		ctrl->regs->piw[i].piwbear = ctrl->piw_save[i].piwbear;
+		ctrl->regs->piw[i].piwar = ctrl->piw_save[i].piwar;
+	}
+
+	return 0;
+}
+#endif
+
+static int __devinit fsl_pci_probe(struct of_device *ofdev,
+				const struct of_device_id *match)
+{
+	int ret;
+	struct fsl_pcie_ctrl *ctrl;
+
+	ctrl = kzalloc(sizeof(struct fsl_pcie_ctrl) , GFP_KERNEL);
+
+	if (ctrl == NULL)
+		return -ENOMEM;
+
+	dev_set_drvdata(&ofdev->dev, ctrl);
+
+	ctrl->regs = of_iomap(ofdev->node, 0);
+	if (ctrl->regs == NULL) {
+		dev_err(&ofdev->dev, "failed to get memory region\n");
+		ret = -ENODEV;
+		goto err;
+	}
+
+	return 0;
+err:
+	if (ctrl->regs)
+		iounmap(ctrl->regs);
+
+	kfree(ctrl);
+	return ret;
+}
+
+static int __exit fsl_pci_remove(struct of_device *ofdev)
+{
+	struct fsl_pcie_ctrl *ctrl = dev_get_drvdata(&ofdev->dev);
+	if (ctrl->regs)
+		iounmap(ctrl->regs);
+
+	dev_set_drvdata(&ofdev->dev, NULL);
+	kfree(ctrl);
+	return 0;
+}
+
+static const struct of_device_id fsl_pci_match[] = {
+	{
+		.compatible = "fsl,p1022-pcie",
+	},
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, fsl_pci_match);
+
+static struct of_platform_driver fsl_pci_driver = {
+	.name	= "fsl-pci",
+	.match_table = fsl_pci_match,
+	.probe = fsl_pci_probe,
+	.remove = __exit_p(fsl_pci_remove),
+#ifdef CONFIG_SUSPEND
+	.suspend     = fsl_pci_suspend,
+	.resume      = fsl_pci_resume,
+#endif
+};
+
+static int __init fsl_pci_init(void)
+{
+	return of_register_platform_driver(&fsl_pci_driver);
+}
+
+static void __exit fsl_pci_exit(void)
+{
+	of_unregister_platform_driver(&fsl_pci_driver);
+}
+module_init(fsl_pci_init);
+module_exit(fsl_pci_exit);
+
+MODULE_DESCRIPTION("Freescale PCI Driver");
+MODULE_LICENSE("GPL");
-- 
1.6.5.2

