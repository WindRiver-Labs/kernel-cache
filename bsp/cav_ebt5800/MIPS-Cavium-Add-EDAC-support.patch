From b913c61122d7d9e0da1f1a2eb734c2325d201b8a Mon Sep 17 00:00:00 2001
From: Ralf Baechle <ralf.baechle@windriver.com>
Date: Tue, 14 Jul 2009 21:40:57 +0100
Subject: [PATCH] MIPS: Cavium: Add EDAC support.

Drivers for EDAC on Cavium.  Supported subsystems are:

 o CPU primary caches.  These are parity protected only, so only error
   reporting.
 o Second level cache - ECC protected, provides SECDED.
 o Memory: ECC / SECDEC if used with suitable DRAM modules.  The driver will
   will only initialize if ECC is enabled on a system so is safe to run on
   non-ECC memory.
 o PCI: Parity error reporting

Since it is very hard to test this sort of code the implementation is very
conservative and uses polling where possible.  Thus also review often,
review hard.  I had somebody from Cavium review this code and they were
happy with it.

The changes to drivers/edac/edac_core.[ch] are backporting a simple EDAC
API from later upstream kernels.  drivers/edac/Makefile has some CFLAGS_*
weirdness.  Both changes can be dropped without replacement when we
eventually upgrade to a later kernel.

Signed-off-by: Ralf Baechle <ralf.baechle@windriver.com>
---
 arch/mips/Kconfig               |    4 +
 arch/mips/cavium-octeon/pci.c   |    5 +
 arch/mips/cavium-octeon/setup.c |   29 +++++++
 arch/mips/mm/c-octeon.c         |   43 +++++-----
 drivers/edac/Kconfig            |   30 +++++++-
 drivers/edac/Makefile           |    8 ++
 drivers/edac/edac_core.h        |    1 +
 drivers/edac/edac_device.c      |   14 +++
 drivers/edac/octeon_edac-l2c.c  |  137 ++++++++++++++++++++++++++++++++
 drivers/edac/octeon_edac-lmc.c  |  166 +++++++++++++++++++++++++++++++++++++++
 drivers/edac/octeon_edac-lmc.h  |   78 ++++++++++++++++++
 drivers/edac/octeon_edac-pc.c   |  150 +++++++++++++++++++++++++++++++++++
 drivers/edac/octeon_edac-pci.c  |  153 ++++++++++++++++++++++++++++++++++++
 13 files changed, 796 insertions(+), 22 deletions(-)
 create mode 100644 drivers/edac/octeon_edac-l2c.c
 create mode 100644 drivers/edac/octeon_edac-lmc.c
 create mode 100644 drivers/edac/octeon_edac-lmc.h
 create mode 100644 drivers/edac/octeon_edac-pc.c
 create mode 100644 drivers/edac/octeon_edac-pci.c

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index abb2e26..3b8c5c1 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -621,6 +621,7 @@ config CAVIUM_OCTEON_REFERENCE_BOARD
 	select 64BIT_PHYS_ADDR
 	select SYS_SUPPORTS_64BIT_KERNEL
 	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_SUPPORTS_EDAC
 	select SYS_SUPPORTS_HIGHMEM
 	select SYS_SUPPORTS_HOTPLUG_CPU
 	select SYS_R4K_CVET_HWTIMER 
@@ -872,6 +873,9 @@ config SYS_SUPPORTS_APM_EMULATION
 config SYS_SUPPORTS_BIG_ENDIAN
 	bool
 
+config SYS_SUPPORTS_EDAC
+	bool
+
 config SYS_SUPPORTS_LITTLE_ENDIAN
 	bool
 
diff --git a/arch/mips/cavium-octeon/pci.c b/arch/mips/cavium-octeon/pci.c
index 200e72f..a8d25f5 100644
--- a/arch/mips/cavium-octeon/pci.c
+++ b/arch/mips/cavium-octeon/pci.c
@@ -11,6 +11,7 @@
 #include <linux/interrupt.h>
 #include <linux/time.h>
 #include <linux/delay.h>
+#include <linux/platform_device.h>
 #include "hal.h"
 #include "pci-common.h"
 
@@ -506,6 +507,10 @@ static int __init octeon_pci_setup(void)
 	/* Clear any errors that might be pending from before the bus was setup
 	   properly */
 	cvmx_write_csr(CVMX_NPI_PCI_INT_SUM2, -1);
+
+	if (IS_ERR(platform_device_register_simple("co_pci_edac", 0, NULL, 0)))
+		pr_err("Registation of co_pci_edac failed!\n");
+
 	return 0;
 }
 
diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index 20b9887..c34fa1a 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -5,8 +5,11 @@
  *
  * Copyright (C) 2004-2007 Cavium Networks
  * Copyright (C) 2008 Wind River Systems
+ * Copyright (C) 2009 Wind River Systems
+ *   written by Ralf Baechle
  */
 #include <linux/init.h>
+#include <linux/kernel.h>
 #include <linux/delay.h>
 #include <linux/irq.h>
 #include <linux/interrupt.h>
@@ -505,3 +508,29 @@ void prom_free_prom_memory(void)
 	   CONFIG_CAVIUM_RESERVE32_USE_WIRED_TLB option is set */
 	octeon_hal_setup_reserved32();
 }
+
+static char *edac_device_names[] = {
+	"co_l2c_edac",
+	"co_lmc_edac",
+	"co_pc_edac",
+};
+
+static int __init edac_devinit(void)
+{
+	struct platform_device *dev;
+	int i, err = 0;
+	char *name;
+
+	for (i = 0; i < ARRAY_SIZE(edac_device_names); i++) {
+		name = edac_device_names[i];
+		dev = platform_device_register_simple(name, -1, NULL, 0);
+		if (IS_ERR(dev)) {
+			pr_err("Registation of %s failed!\n", name);
+		err = PTR_ERR(dev);
+		}
+	}
+
+	return err;
+}
+
+device_initcall(edac_devinit);
diff --git a/arch/mips/mm/c-octeon.c b/arch/mips/mm/c-octeon.c
index 35a781b..05a74a6 100644
--- a/arch/mips/mm/c-octeon.c
+++ b/arch/mips/mm/c-octeon.c
@@ -26,6 +26,7 @@
 #include "../cavium-octeon/hal.h"
 
 unsigned long long cache_err_dcache[NR_CPUS];
+EXPORT_SYMBOL_GPL(cache_err_dcache);
 
 extern struct plat_smp_ops *mp_ops;	/* private */
 
@@ -260,42 +261,42 @@ void __devinit octeon_cache_init(void)
  * Handle a cache error exception
  */
 
-static void  cache_parity_error_octeon(int non_recoverable)
+static RAW_NOTIFIER_HEAD(co_cache_error_chain);
+
+int register_co_cache_error_notifier(struct notifier_block *nb)
 {
-	unsigned long coreid = cvmx_get_core_num();
-	uint64_t icache_err = read_c0_cacheerr();
-
-	pr_err("Cache error exception:\n");
-	pr_err("cp0_errorepc == %lx\n", read_c0_errorepc());
-	if (icache_err & 1) {
-		pr_err("CacheErr (Icache) == %llx\n", (unsigned long long)icache_err);
-		write_c0_cacheerr(0);
-	}
-	if (cache_err_dcache[coreid] & 1) {
-		pr_err("CacheErr (Dcache) == %llx\n", (unsigned long long)cache_err_dcache[coreid]);
-		cache_err_dcache[coreid] = 0;
-	}
+	return raw_notifier_chain_register(&co_cache_error_chain, nb);
+}
+EXPORT_SYMBOL_GPL(register_co_cache_error_notifier);
 
+int unregister_co_cache_error_notifier(struct notifier_block *nb)
+{
+	return raw_notifier_chain_unregister(&co_cache_error_chain, nb);
+}
+EXPORT_SYMBOL_GPL(unregister_co_cache_error_notifier);
 
-	if (non_recoverable)
-		panic("Can't handle cache error: nested exception");
+static inline int co_cache_error_call_notifiers(unsigned long val)
+{
+	return raw_notifier_call_chain(&co_cache_error_chain, val, NULL);
 }
 
 /**
  * Called when the the exception is not recoverable
+ *
+ * The issue not that the cache error exception itself was non-recoverable
+ * but that due to nesting of exception may have lost some state so can't
+ * continue.
  */
-
 asmlinkage void cache_parity_error_octeon_recoverable(void)
 {
-	cache_parity_error_octeon(0);
+	co_cache_error_call_notifiers(0);
 }
 
 /**
  * Called when the the exception is recoverable
  */
-
 asmlinkage void cache_parity_error_octeon_non_recoverable(void)
 {
-	cache_parity_error_octeon(1);
+	co_cache_error_call_notifiers(1);
+	panic("Can't handle cache error: nested exception");
 }
-
diff --git a/drivers/edac/Kconfig b/drivers/edac/Kconfig
index 5a11e3c..33a51fc 100644
--- a/drivers/edac/Kconfig
+++ b/drivers/edac/Kconfig
@@ -8,7 +8,7 @@ menuconfig EDAC
 	bool "EDAC - error detection and reporting (EXPERIMENTAL)"
 	depends on HAS_IOMEM
 	depends on EXPERIMENTAL
-	depends on X86 || PPC
+	depends on X86 || PPC || SYS_SUPPORTS_EDAC
 	help
 	  EDAC is designed to report errors in the core system.
 	  These are low-level errors that are reported in the CPU or
@@ -160,4 +160,32 @@ config EDAC_CELL
 	  Cell Broadband Engine internal memory controller
 	  on platform without a hypervisor
 
+config EDAC_OCTEON_PC
+	tristate "Cavium Octeon Primary Caches"
+	depends on EDAC_MM_EDAC && CPU_CAVIUM_OCTEON
+	help
+	  Support for error detection and correction on the primary caches of
+	  the cnMIPS cores of Cavium Octeon family SOCs.
+
+config EDAC_OCTEON_L2C
+	tristate "Cavium Octeon Secondary Caches (L2C)"
+	depends on EDAC_MM_EDAC && CPU_CAVIUM_OCTEON
+	help
+	  Support for error detection and correction on the
+	  Cavium Octeon family of SOCs.
+
+config EDAC_OCTEON_LMC
+	tristate "Cavium Octeon DRAM Memory Controller (LMC)"
+	depends on EDAC_MM_EDAC && CPU_CAVIUM_OCTEON
+	help
+	  Support for error detection and correction on the
+	  Cavium Octeon family of SOCs.
+
+config EDAC_OCTEON_PCI
+	tristate "Cavium Octeon PCI Controller"
+	depends on EDAC_MM_EDAC && PCI && CPU_CAVIUM_OCTEON
+	help
+	  Support for error detection and correction on the
+	  Cavium Octeon family of SOCs.
+
 endif # EDAC
diff --git a/drivers/edac/Makefile b/drivers/edac/Makefile
index e5e9104..18e4880 100644
--- a/drivers/edac/Makefile
+++ b/drivers/edac/Makefile
@@ -32,4 +32,12 @@ obj-$(CONFIG_EDAC_PASEMI)		+= pasemi_edac.o
 obj-$(CONFIG_EDAC_MPC85XX)		+= mpc85xx_edac.o
 obj-$(CONFIG_EDAC_MV64X60)		+= mv64x60_edac.o
 obj-$(CONFIG_EDAC_CELL)			+= cell_edac.o
+obj-$(CONFIG_EDAC_OCTEON_PC)		+= octeon_edac-pc.o
+CFLAGS_octeon_edac-pc.o = -Iarch/mips/cavium-octeon
+obj-$(CONFIG_EDAC_OCTEON_L2C)		+= octeon_edac-l2c.o
+CFLAGS_octeon_edac-l2c.o = -Iarch/mips/cavium-octeon
+obj-$(CONFIG_EDAC_OCTEON_LMC)		+= octeon_edac-lmc.o
+CFLAGS_octeon_edac-lmc.o = -Iarch/mips/cavium-octeon
+obj-$(CONFIG_EDAC_OCTEON_PCI)		+= octeon_edac-pci.o
+CFLAGS_octeon_edac-pci.o = -Iarch/mips/cavium-octeon -Iarch/mips/cavium-octeon/executive
 
diff --git a/drivers/edac/edac_core.h b/drivers/edac/edac_core.h
index 4b55ec6..88eacff 100644
--- a/drivers/edac/edac_core.h
+++ b/drivers/edac/edac_core.h
@@ -819,6 +819,7 @@ extern void edac_device_handle_ue(struct edac_device_ctl_info *edac_dev,
 				int inst_nr, int block_nr, const char *msg);
 extern void edac_device_handle_ce(struct edac_device_ctl_info *edac_dev,
 				int inst_nr, int block_nr, const char *msg);
+extern int edac_device_alloc_index(void);
 
 /*
  * edac_pci APIs
diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c
index 5fcd3d8..a746012 100644
--- a/drivers/edac/edac_device.c
+++ b/drivers/edac/edac_device.c
@@ -484,6 +484,20 @@ void edac_device_reset_delay_period(struct edac_device_ctl_info *edac_dev,
 	mutex_unlock(&device_ctls_mutex);
 }
 
+/*
+ * edac_device_alloc_index: Allocate a unique device index number
+ *
+ * Return:
+ *      allocated index number
+ */
+int edac_device_alloc_index(void)
+{
+	static atomic_t device_indexes = ATOMIC_INIT(0);
+
+	return atomic_inc_return(&device_indexes) - 1;
+}
+EXPORT_SYMBOL_GPL(edac_device_alloc_index);
+
 /**
  * edac_device_add_device: Insert the 'edac_dev' structure into the
  * edac_device global list and create sysfs entries associated with
diff --git a/drivers/edac/octeon_edac-l2c.c b/drivers/edac/octeon_edac-l2c.c
new file mode 100644
index 0000000..740b4e7
--- /dev/null
+++ b/drivers/edac/octeon_edac-l2c.c
@@ -0,0 +1,137 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2009 Wind River Systems,
+ *   written by Ralf Baechle <ralf.baechle@windriver.com>
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/edac.h>
+
+#include <executive/cvmx.h>
+
+#include "edac_core.h"
+#include "edac_module.h"
+
+#define EDAC_MOD_STR "octeon-l2c"
+
+struct co_l2c_priv {
+	struct timer_list poll_timer;
+};
+
+static void co_l2c_poll(unsigned long data)
+{
+	struct edac_device_ctl_info *l2c = (struct edac_device_ctl_info *) data;
+	struct co_l2c_priv *pp = l2c->pvt_info;
+	cvmx_l2t_err_t l2t_err;
+
+	l2t_err.u64 = cvmx_read_csr(CVMX_L2T_ERR);
+	if (l2t_err.s.sec_err) {
+		edac_device_handle_ce(l2c, 0, 0,
+				      "Single bit error (corrected)");
+		l2t_err.s.sec_err = 1;		/* Reset */
+		cvmx_write_csr(CVMX_L2T_ERR, l2t_err.u64);
+	}
+	if (l2t_err.s.ded_err) {
+		edac_device_handle_ue(l2c, 0, 0,
+				      "Double bit error (corrected)");
+		l2t_err.s.ded_err = 1;		/* Reset */
+		cvmx_write_csr(CVMX_L2T_ERR, l2t_err.u64);
+	}
+
+	mod_timer(&pp->poll_timer, jiffies + HZ);	/* Done, re-arm also */
+}
+
+static int __devinit co_l2c_probe(struct platform_device *pdev)
+{
+	struct edac_device_ctl_info *l2c;
+	struct co_l2c_priv *pp;
+	cvmx_l2t_err_t l2t_err;
+	int res = 0;
+
+	l2c = edac_device_alloc_ctl_info(sizeof(*pp), "l2c", 1, NULL, 0, 0,
+					 NULL, 0, edac_device_alloc_index());
+	if (!l2c)
+		return -ENOMEM;
+
+	l2c->dev = &pdev->dev;
+	platform_set_drvdata(pdev, l2c);
+	l2c->dev_name = dev_name(&pdev->dev);
+
+	l2c->mod_name = "octeon-l2c";
+	l2c->ctl_name = "octeon_l2c_err";
+
+	if (edac_device_add_device(l2c) > 0) {
+		pr_err("%s: edac_device_add_device() failed\n", __func__);
+		goto err;
+	}
+
+	pp = l2c->pvt_info;
+
+	l2t_err.u64 = cvmx_read_csr(CVMX_L2T_ERR);
+	l2t_err.s.sec_intena = 0;	/* We poll */
+	l2t_err.s.ded_intena = 0;
+	l2t_err.s.sec_err = 1;		/* Clear, just in case */
+	l2t_err.s.ded_err = 1;
+	cvmx_write_csr(CVMX_L2T_ERR, l2t_err.u64);
+
+	init_timer(&pp->poll_timer);
+	pp->poll_timer.data       = (unsigned long) l2c;
+	pp->poll_timer.function   = co_l2c_poll;
+	pp->poll_timer.expires    = jiffies + HZ;
+	add_timer(&pp->poll_timer);
+
+	return 0;
+
+err:
+	edac_device_free_ctl_info(l2c);
+
+	return res;
+}
+
+static int co_l2c_remove(struct platform_device *pdev)
+{
+	struct edac_device_ctl_info *l2c = platform_get_drvdata(pdev);
+	struct co_l2c_priv *pp = l2c->pvt_info;
+
+	del_timer_sync(&pp->poll_timer);
+	edac_device_del_device(&pdev->dev);
+	edac_device_free_ctl_info(l2c);
+
+	return 0;
+}
+
+static struct platform_driver co_l2c_driver = {
+	.probe = co_l2c_probe,
+	.remove = co_l2c_remove,
+	.driver = {
+		   .name = "co_l2c_edac",
+	}
+};
+
+static int __init co_edac_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&co_l2c_driver);
+	if (ret)
+		pr_warning(EDAC_MOD_STR " EDAC failed to register\n");
+
+	return ret;
+}
+
+static void __exit co_edac_exit(void)
+{
+	platform_driver_unregister(&co_l2c_driver);
+}
+
+module_init(co_edac_init);
+module_exit(co_edac_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Ralf Baechle <ralf.baechle@windriver.com>");
diff --git a/drivers/edac/octeon_edac-lmc.c b/drivers/edac/octeon_edac-lmc.c
new file mode 100644
index 0000000..5c413a5
--- /dev/null
+++ b/drivers/edac/octeon_edac-lmc.c
@@ -0,0 +1,166 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2009 Wind River Systems,
+ *   written by Ralf Baechle <ralf.baechle@windriver.com>
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/edac.h>
+
+#include <executive/cvmx.h>
+
+#include "edac_core.h"
+#include "edac_module.h"
+#include "octeon_edac-lmc.h"
+
+#define EDAC_MOD_STR "octeon"
+
+struct co_lmc_priv {
+	struct timer_list poll_timer;
+};
+
+static struct mem_ctl_info *mc_cavium;
+static void *lmc_base;
+
+static void co_lmc_poll(unsigned long data)
+{
+	union lmc_mem_cfg0 cfg0;
+	struct mem_ctl_info *mci = (struct mem_ctl_info *) data;
+	struct co_lmc_priv *mp = mci->pvt_info;
+	union lmc_fadr fadr;
+	char msg[64];
+
+	fadr.u64 = readq(lmc_base + LMC_FADR);
+	cfg0.u64 = readq(lmc_base + LMC_MEM_CFG0);
+	snprintf(msg, sizeof(msg), "DIMM %d rank %d bank %d row %d col %d",
+		fadr.fdimm, fadr.fbunk, fadr.fbank, fadr.frow, fadr.fcol);
+
+	if (cfg0.sec_err) {
+		edac_mc_handle_ce_no_info(mci, msg);
+		cfg0.intr_sec_ena = -1;		/* Done, re-arm */
+	}
+
+	if (cfg0.ded_err) {
+		edac_mc_handle_ue_no_info(mci, msg);
+		cfg0.intr_ded_ena = -1;		/* Done, re-arm */
+	}
+
+	writeq(cfg0.u64, lmc_base + LMC_MEM_CFG0);
+
+	mod_timer(&mp->poll_timer, jiffies + HZ);	/* Done, re-arm also */
+}
+
+static int __devinit co_lmc_probe(struct platform_device *pdev)
+{
+	struct mem_ctl_info *mci;
+	union lmc_mem_cfg0 cfg0;
+	struct co_lmc_priv *mp;
+	int res = 0;
+
+	mci = edac_mc_alloc(sizeof(*mp), 0, 0, 0);
+	if (!mci)
+		return -ENOMEM;
+
+	mci->dev = &pdev->dev;
+	platform_set_drvdata(pdev, mci);
+	mci->dev_name = dev_name(&pdev->dev);
+
+	mci->mod_name = "octeon-lmc";
+	mci->ctl_name = "co_lmc_err";
+
+	if (edac_mc_add_mc(mci) > 0) {
+		pr_err("%s: edac_mc_add_mc() failed\n", __func__);
+		goto err;
+	}
+
+	mp = mci->pvt_info;
+
+	cfg0.u64 = readq(lmc_base + LMC_MEM_CFG0);	/* We poll */
+	cfg0.intr_ded_ena = 0;
+	cfg0.intr_sec_ena = 0;
+	writeq(cfg0.u64, lmc_base + LMC_MEM_CFG0);
+
+	init_timer(&mp->poll_timer);
+	mp->poll_timer.data       = (unsigned long) mci;
+	mp->poll_timer.function   = co_lmc_poll;
+	mp->poll_timer.expires    = jiffies + HZ;
+	add_timer(&mp->poll_timer);
+
+	mc_cavium = mci;
+
+	return 0;
+
+err:
+	edac_mc_free(mci);
+
+	return res;
+}
+
+static int co_lmc_remove(struct platform_device *pdev)
+{
+	struct mem_ctl_info *mci = platform_get_drvdata(pdev);
+	struct co_lmc_priv *mp = mci->pvt_info;
+
+	del_timer_sync(&mp->poll_timer);
+	mc_cavium = NULL;
+	edac_mc_del_mc(&pdev->dev);
+	edac_mc_free(mci);
+
+	return 0;
+}
+
+static struct platform_driver co_lmc_driver = {
+	.probe = co_lmc_probe,
+	.remove = co_lmc_remove,
+	.driver = {
+		   .name = "co_lmc_edac",
+	}
+};
+
+static int __init co_edac_init(void)
+{
+	union lmc_mem_cfg0 cfg0;
+	int ret;
+
+	lmc_base = ioremap_nocache(LMC_BASE, LMC_SIZE);
+	if (!lmc_base)
+		return -ENOMEM;
+
+	cfg0.u64 = readq(lmc_base + LMC_MEM_CFG0);
+	if (!cfg0.ecc_ena) {
+		pr_info(EDAC_MOD_STR " LMC EDAC: ECC disabled, good bye\n");
+		ret = -ENODEV;
+		goto out;
+	}
+
+	ret = platform_driver_register(&co_lmc_driver);
+	if (ret) {
+		pr_warning(EDAC_MOD_STR " LMC EDAC failed to register\n");
+		goto out;
+	}
+
+	return ret;
+
+out:
+	iounmap(lmc_base);
+
+	return ret;
+}
+
+static void __exit co_edac_exit(void)
+{
+	platform_driver_unregister(&co_lmc_driver);
+	iounmap(lmc_base);
+}
+
+module_init(co_edac_init);
+module_exit(co_edac_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Ralf Baechle <ralf.baechle@windriver.com>");
diff --git a/drivers/edac/octeon_edac-lmc.h b/drivers/edac/octeon_edac-lmc.h
new file mode 100644
index 0000000..246dc52
--- /dev/null
+++ b/drivers/edac/octeon_edac-lmc.h
@@ -0,0 +1,78 @@
+/*
+ * LMC Registers, see chapter 2.5
+ *
+ * These are RSL Type registers and are accessed indirectly across the
+ * I/O bus, so accesses are slowish.  Not that it matters.  Any size load is
+ * ok but stores must be 64-bit.
+ */
+#define LMC_BASE		0x0001180088000000
+#define LMC_SIZE		0xb8
+
+#define LMC_MEM_CFG0		0x0000000000000000
+#define LMC_MEM_CFG1		0x0000000000000008
+#define LMC_CTL			0x0000000000000010
+#define LMC_DDR2_CTL		0x0000000000000018
+#define LMC_FADR		0x0000000000000020
+#define   LMC_FADR_FDIMM
+#define   LMC_FADR_FBUNK
+#define   LMC_FADR_FBANK
+#define   LMC_FADR_FROW
+#define   LMC_FADR_FCOL
+#define LMC_COMP_CTL		0x0000000000000028
+#define LMC_WODT_CTL		0x0000000000000030
+#define LMC_ECC_SYND		0x0000000000000038
+#define LMC_IFB_CNT_LO		0x0000000000000048
+#define LMC_IFB_CNT_HI		0x0000000000000050
+#define LMC_OPS_CNT_LO		0x0000000000000058
+#define LMC_OPS_CNT_HI		0x0000000000000060
+#define LMC_DCLK_CNT_LO		0x0000000000000068
+#define LMC_DCLK_CNT_HI		0x0000000000000070
+#define LMC_DELAY_CFG		0x0000000000000088
+#define LMC_CTL1		0x0000000000000090
+#define LMC_DUAL_MEM_CONFIG	0x0000000000000098
+#define LMC_RODT_COMP_CTL	0x00000000000000A0
+#define LMC_PLL_CTL		0x00000000000000A8
+#define LMC_PLL_STATUS		0x00000000000000B0
+
+union lmc_mem_cfg0 {
+	uint64_t u64;
+	struct {
+		uint64_t reserved_32_63:32;
+		uint64_t reset:1;
+		uint64_t silo_qc:1;
+		uint64_t bunk_ena:1;
+		uint64_t ded_err:4;
+		uint64_t sec_err:4;
+		uint64_t intr_ded_ena:1;
+		uint64_t intr_sec_ena:1;
+		uint64_t reserved_15_18:4;
+		uint64_t ref_int:5;
+		uint64_t pbank_lsb:4;
+		uint64_t row_lsb:3;
+		uint64_t ecc_ena:1;
+		uint64_t init_start:1;
+	};
+};
+
+union lmc_fadr {
+	uint64_t u64;
+	struct {
+		uint64_t reserved_32_63:32;
+		uint64_t fdimm:2;
+		uint64_t fbunk:1;
+		uint64_t fbank:3;
+		uint64_t frow:14;
+		uint64_t fcol:12;
+	};
+};
+
+union lmc_ecc_synd {
+	uint64_t u64;
+	struct {
+		uint64_t reserved_32_63:32;
+		uint64_t mrdsyn3:8;
+		uint64_t mrdsyn2:8;
+		uint64_t mrdsyn1:8;
+		uint64_t mrdsyn0:8;
+	};
+};
diff --git a/drivers/edac/octeon_edac-pc.c b/drivers/edac/octeon_edac-pc.c
new file mode 100644
index 0000000..273ef32
--- /dev/null
+++ b/drivers/edac/octeon_edac-pc.c
@@ -0,0 +1,150 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2009 Wind River Systems,
+ *   written by Ralf Baechle <ralf.baechle@windriver.com>
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/edac.h>
+
+#include "edac_core.h"
+#include "edac_module.h"
+
+#include <executive/cvmx.h>
+
+#define EDAC_MOD_STR "octeon"
+
+extern int register_co_cache_error_notifier(struct notifier_block *nb);
+extern int unregister_co_cache_error_notifier(struct notifier_block *nb);
+
+extern unsigned long long cache_err_dcache[NR_CPUS];
+
+static struct edac_device_ctl_info *ed_cavium;
+
+/*
+ * EDAC CPU cache error callback
+ *
+ */
+
+static int  co_cache_error_event(struct notifier_block *this,
+	unsigned long event, void *ptr)
+{
+	unsigned int core = cvmx_get_core_num();
+	unsigned int cpu = smp_processor_id();
+	uint64_t icache_err = read_c0_cacheerr();
+	struct edac_device_ctl_info *ed = ed_cavium;
+
+	edac_device_printk(ed, KERN_ERR,
+			   "Cache error exception on core %d / processor %d:\n",
+			   core, cpu);
+	edac_device_printk(ed, KERN_ERR,
+			   "cp0_errorepc == %lx\n", read_c0_errorepc());
+	if (icache_err & 1) {
+		edac_device_printk(ed, KERN_ERR, "CacheErr (Icache) == %llx\n",
+				   (unsigned long long)icache_err);
+		write_c0_cacheerr(0);
+		edac_device_handle_ce(ed, 0, 0, ed->ctl_name);
+	}
+	if (cache_err_dcache[core] & 1) {
+		edac_device_printk(ed, KERN_ERR, "CacheErr (Dcache) == %llx\n",
+				   (unsigned long long)cache_err_dcache[core]);
+		cache_err_dcache[core] = 0;
+		edac_device_handle_ue(ed, 0, 0, ed->ctl_name);
+	}
+
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block co_cache_error_notifier = {
+	.notifier_call = co_cache_error_event,
+};
+
+static int __devinit co_cache_error_probe(struct platform_device *pdev)
+{
+	struct edac_device_ctl_info *ed;
+	int res = 0;
+
+	ed = edac_device_alloc_ctl_info(0, "cpu", 1, NULL, 0, 0, NULL, 0,
+					edac_device_alloc_index());
+
+	ed->dev = &pdev->dev;
+	platform_set_drvdata(pdev, ed);
+	ed->dev_name = dev_name(&pdev->dev);
+
+	ed->mod_name = "octeon-cpu";
+	ed->ctl_name = "co_cpu_err";
+
+	if (edac_device_add_device(ed) > 0) {
+		pr_err("%s: edac_device_add_device() failed\n", __func__);
+		goto err;
+	}
+
+	register_co_cache_error_notifier(&co_cache_error_notifier);
+	ed_cavium = ed;
+
+	return 0;
+
+err:
+	edac_device_free_ctl_info(ed);
+
+	return res;
+}
+
+static int co_cache_error_remove(struct platform_device *pdev)
+{
+	struct edac_device_ctl_info *ed = platform_get_drvdata(pdev);
+
+	unregister_co_cache_error_notifier(&co_cache_error_notifier);
+	ed_cavium = NULL;
+	edac_device_del_device(&pdev->dev);
+	edac_device_free_ctl_info(ed);
+
+	return 0;
+}
+
+static struct platform_driver co_cache_error_driver = {
+	.probe = co_cache_error_probe,
+	.remove = co_cache_error_remove,
+	.driver = {
+		   .name = "co_pc_edac",
+	}
+};
+
+static int __init co_edac_init(void)
+{
+	int ret;
+
+	/* make sure error reporting method is sane */
+	switch (edac_op_state) {
+	case EDAC_OPSTATE_INT:
+		break;
+	default:
+		edac_op_state = EDAC_OPSTATE_INT;
+		break;
+	}
+	ret = platform_driver_register(&co_cache_error_driver);
+	if (ret)
+		pr_warning(EDAC_MOD_STR "CPU err failed to register\n");
+
+	return ret;
+}
+
+static void __exit co_edac_exit(void)
+{
+	platform_driver_unregister(&co_cache_error_driver);
+}
+
+module_init(co_edac_init);
+module_exit(co_edac_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Ralf Baechle <ralf.baechle@windriver.com>");
+module_param(edac_op_state, int, 0444);
+MODULE_PARM_DESC(edac_op_state,
+		 "EDAC Error Reporting state: 2=Interrupt");
diff --git a/drivers/edac/octeon_edac-pci.c b/drivers/edac/octeon_edac-pci.c
new file mode 100644
index 0000000..0433218
--- /dev/null
+++ b/drivers/edac/octeon_edac-pci.c
@@ -0,0 +1,153 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2009 Wind River Systems,
+ *   written by Ralf Baechle <ralf.baechle@windriver.com>
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/edac.h>
+
+#include <executive/cvmx.h>
+
+#include <asm/mach-cavium-octeon/octeon-hal-read-write.h>
+
+#include "edac_core.h"
+#include "edac_module.h"
+
+#define EDAC_MOD_STR "octeon"
+
+struct co_pci_priv {
+	struct timer_list poll_timer;
+};
+
+static void co_pci_poll(unsigned long data)
+{
+	struct edac_pci_ctl_info *pci = (struct edac_pci_ctl_info *) data;
+	struct co_pci_priv *pp = pci->pvt_info;
+	cvmx_pci_cfg01_t cfg01;
+
+	cfg01.u32 = octeon_npi_read32(CVMX_NPI_PCI_CFG01);
+	if (cfg01.s.dpe) {		/* Detected parity error */
+		edac_pci_handle_pe(pci, pci->ctl_name);
+		cfg01.s.dpe = 1;		/* Reset  */
+		octeon_npi_write32(CVMX_NPI_PCI_CFG01, cfg01.u32);
+	}
+	if (cfg01.s.sse) {
+		edac_pci_handle_npe(pci, "Signaled System Error");
+		cfg01.s.sse = 1;		/* Reset */
+		octeon_npi_write32(CVMX_NPI_PCI_CFG01, cfg01.u32);
+	}
+	if (cfg01.s.rma) {
+		edac_pci_handle_npe(pci, "Received Master Abort");
+		cfg01.s.rma = 1;		/* Reset */
+		octeon_npi_write32(CVMX_NPI_PCI_CFG01, cfg01.u32);
+	}
+	if (cfg01.s.rta) {
+		edac_pci_handle_npe(pci, "Received Target Abort");
+		cfg01.s.rta = 1;		/* Reset */
+		octeon_npi_write32(CVMX_NPI_PCI_CFG01, cfg01.u32);
+	}
+	if (cfg01.s.sta) {
+		edac_pci_handle_npe(pci, "Signaled Target Abort");
+		cfg01.s.sta = 1;		/* Reset */
+		octeon_npi_write32(CVMX_NPI_PCI_CFG01, cfg01.u32);
+	}
+	if (cfg01.s.mdpe) {
+		edac_pci_handle_npe(pci, "Master Data Parity Error");
+		cfg01.s.mdpe = 1;		/* Reset */
+		octeon_npi_write32(CVMX_NPI_PCI_CFG01, cfg01.u32);
+	}
+	if (cfg01.s.mdpe) {
+		edac_pci_handle_npe(pci, "Master Data Parity Error");
+		cfg01.s.mdpe = 1;		/* Reset */
+		octeon_npi_write32(CVMX_NPI_PCI_CFG01, cfg01.u32);
+	}
+
+	mod_timer(&pp->poll_timer, jiffies + HZ);	/* Done, re-arm also */
+}
+
+static int __devinit co_pci_probe(struct platform_device *pdev)
+{
+	struct edac_pci_ctl_info *pci;
+	struct co_pci_priv *pp;
+	int res = 0;
+
+	pci = edac_pci_alloc_ctl_info(sizeof(*pp), "octeon_pci_err");
+	if (!pci)
+		return -ENOMEM;
+
+	pci->dev = &pdev->dev;
+	platform_set_drvdata(pdev, pci);
+	pci->dev_name = dev_name(&pdev->dev);
+
+	pci->mod_name = "octeon-pci";
+	pci->ctl_name = "octeon_pci_err";
+
+	if (edac_pci_add_device(pci, 0) > 0) {
+		pr_err("%s: edac_pci_add_device() failed\n", __func__);
+		goto err;
+	}
+
+	pp = pci->pvt_info;
+
+	init_timer(&pp->poll_timer);
+	pp->poll_timer.data       = (unsigned long) pci;
+	pp->poll_timer.function   = co_pci_poll;
+	pp->poll_timer.expires    = jiffies + HZ;
+	add_timer(&pp->poll_timer);
+
+	return 0;
+
+err:
+	edac_pci_free_ctl_info(pci);
+
+	return res;
+}
+
+static int co_pci_remove(struct platform_device *pdev)
+{
+	struct edac_pci_ctl_info *pci = platform_get_drvdata(pdev);
+	struct co_pci_priv *pp = pci->pvt_info;
+
+	del_timer_sync(&pp->poll_timer);
+	edac_pci_del_device(&pdev->dev);
+	edac_pci_free_ctl_info(pci);
+
+	return 0;
+}
+
+static struct platform_driver co_pci_driver = {
+	.probe = co_pci_probe,
+	.remove = co_pci_remove,
+	.driver = {
+		   .name = "co_pci_edac",
+	}
+};
+
+static int __init co_edac_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&co_pci_driver);
+	if (ret)
+		pr_warning(EDAC_MOD_STR " PCI EDAC failed to register\n");
+
+	return ret;
+}
+
+static void __exit co_edac_exit(void)
+{
+	platform_driver_unregister(&co_pci_driver);
+}
+
+module_init(co_edac_init);
+module_exit(co_edac_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Ralf Baechle <ralf.baechle@windriver.com>");
-- 
1.6.3.1

