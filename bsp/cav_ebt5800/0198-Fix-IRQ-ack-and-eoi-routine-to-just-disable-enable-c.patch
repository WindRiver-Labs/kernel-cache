From 6d74533948678567b01f61fdc673793346820cd1 Mon Sep 17 00:00:00 2001
From: Yang Shi <yang.shi@windriver.com>
Date: Thu, 8 Jan 2009 10:13:10 +0800
Subject: [PATCH] Fix IRQ ack and eoi routine to just disable/enable current IRQ

On Cavium board, CIU0 is connected to IP2. And, the orignal
    design of IRQ ack and eoi just disable/enable Status[IM2]
    bit. So when CPU running an ISR, other interrupts, including
    IPI, will be disabled.

    And, when host GDB connecting to target serial port, the code
    path on all cores is as follows:

        Master core                             Other cores

    serial8250_interrupt(aquired lock)  serial8250_interrupt(spin)
                |
                V
        KGDB BP breakpoint
                |
                V
        kgdb_roundup_cpus(send IPI)

    Other cores will spin in serial8250_interrupt and disable
    Status[IM2]. This causes other cores can't response IPI
    sent by master core to feed watchdog, then softlockup occurs
    on other cores.

    So, we need fix IRQ ack and eoi routine to just disable/enable
    the current IRQ.

Signed-off-by: Yang Shi <yang.shi@windriver.com>
---
 arch/mips/kernel/irq-octeon.c |   38 +++++++++++++++++++++++++++-----------
 1 files changed, 27 insertions(+), 11 deletions(-)

diff --git a/arch/mips/kernel/irq-octeon.c b/arch/mips/kernel/irq-octeon.c
index 738f3c6..0ac7e03 100644
--- a/arch/mips/kernel/irq-octeon.c
+++ b/arch/mips/kernel/irq-octeon.c
@@ -81,21 +81,37 @@ struct irq_chip octeon_irq_chip_core = {
 
 static void octeon_irq_ciu0_ack(unsigned int irq)
 {
-	/* In order to avoid any locking accessing the CIU, we acknowledge CIU
-	   interrupts by disabling all of them. This way we can use a per core
-	   register and avoid any out of core locking requirements. This has
-	   the side affect that CIU interrupts can't be processed recursively */
-	/* We don't need to disable IRQs to make these atomic since they are
-	   already disabled earlier in the low level interrupt code */
-	clear_c0_status(0x100 << 2);
+	/* Disable the current IRQ line to ack interrupt */
+	int bit = irq - OCTEON_IRQ_WORKQ0;	/* Bit 0-63 of EN0 */
+	unsigned long flags;
+	uint64_t en0;
+	int coreid = cvmx_get_core_num();
+	local_irq_save(flags);
+	en0 = cvmx_read_csr(CVMX_CIU_INTX_EN0(coreid * 2));
+	en0 &= ~(1ull << bit);
+	cvmx_write_csr(CVMX_CIU_INTX_EN0(coreid * 2), en0);
+	cvmx_read_csr(CVMX_CIU_INTX_EN0(coreid * 2));
+	local_irq_restore(flags);
 }
 
 static void octeon_irq_ciu0_eoi(unsigned int irq)
 {
-	/* Enable all CIU interrupts again */
-	/* We don't need to disable IRQs to make these atomic since they are
-	   already disabled earlier in the low level interrupt code */
-	set_c0_status(0x100 << 2);
+	/* Enable the current IRQ line to end of interrupt */
+	int coreid = cvmx_get_core_num();
+	unsigned long flags;
+	uint64_t en0;
+	int bit = irq - OCTEON_IRQ_WORKQ0;	/* Bit 0-63 of EN0 */
+
+	/* A read lock is used here to make sure only one core is ever updating
+	   the CIU enable bits at a time. During an enable the cores don't
+	   interfere with each other. During a disable the write lock stops any
+	   enables that might cause a problem */
+	read_lock_irqsave(&octeon_irq_ciu0_rwlock, flags);
+	en0 = cvmx_read_csr(CVMX_CIU_INTX_EN0(coreid * 2));
+	en0 |= 1ull << bit;
+	cvmx_write_csr(CVMX_CIU_INTX_EN0(coreid * 2), en0);
+	cvmx_read_csr(CVMX_CIU_INTX_EN0(coreid * 2));
+	read_unlock_irqrestore(&octeon_irq_ciu0_rwlock, flags);
 }
 
 static void octeon_irq_ciu0_enable(unsigned int irq)
-- 
1.6.0.3

