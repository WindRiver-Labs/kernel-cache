From 313f85deff1da81f6b486743ee7d718e1c100cad Mon Sep 17 00:00:00 2001
From: auto commit <unknown@unknown>
Date: Fri, 24 Oct 2008 12:23:14 -0700
Subject: [PATCH] Cavium Timer synchronization.

MIPS cp0 timer syncronization over multiple cores using Octeon on-chip
performance counter as a common clock base.
Included fix to sync-r4k.c to provide an alternative method.

Signed-off-by: Vlad Malov <Vlad.Malov@caviumnetworks.com>
Signed-off-by: Tomaso Paoletti <tpaoletti@caviumnetworks.com>
---
 arch/mips/Kconfig                     |    2 +
 arch/mips/cavium-octeon/Kconfig       |    6 ++
 arch/mips/cavium-octeon/Makefile      |    1 +
 arch/mips/cavium-octeon/smp.c         |   11 +++-
 arch/mips/cavium-octeon/sync-octeon.c |   87 +++++++++++++++++++++++++++++++++
 arch/mips/kernel/sync-r4k.c           |   10 ++--
 6 files changed, 109 insertions(+), 8 deletions(-)
 create mode 100644 arch/mips/cavium-octeon/sync-octeon.c

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 5ad2703..8a3730e 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -609,6 +609,7 @@ config CAVIUM_OCTEON_SIMULATOR
 	select SYS_SUPPORTS_HIGHMEM
 	select SYS_SUPPORTS_KGDB
 	select CPU_CAVIUM_OCTEON
+	select CAVIUM_OCTEON_SYNC
 	help
 	  The Octeon simulator is software performance model of the Cavium
 	  Octeon Processor. It supports simulating Octeon processors on x86
@@ -629,6 +630,7 @@ config CAVIUM_OCTEON_REFERENCE_BOARD
 	select ISA
 	select GENERIC_ISA_DMA
 	select ARCH_MAY_HAVE_PC_FDC
+	select CAVIUM_OCTEON_SYNC
 	help
 	  This option supports all of the Octeon reference boards from Cavium
 	  Networks. It builds a kernel that dynamically determines the Octeon
diff --git a/arch/mips/cavium-octeon/Kconfig b/arch/mips/cavium-octeon/Kconfig
index 53bf4b6..a6997a7 100644
--- a/arch/mips/cavium-octeon/Kconfig
+++ b/arch/mips/cavium-octeon/Kconfig
@@ -272,3 +272,9 @@ config CAVIUM_OCTEON_IPFWD_OFFLOAD
 	default "n"
 	help
 	  This enables Cavium Octeon ip-offload module.
+
+config CAVIUM_OCTEON_SYNC
+	bool "Enable Cavium multi-core clock synchronization"
+	default "n"
+	help
+	   This enables Cavium multi-core clock synchronisation using perf counters.
diff --git a/arch/mips/cavium-octeon/Makefile b/arch/mips/cavium-octeon/Makefile
index c250a87..d56f97e 100644
--- a/arch/mips/cavium-octeon/Makefile
+++ b/arch/mips/cavium-octeon/Makefile
@@ -28,6 +28,7 @@ obj-$(CONFIG_CAVIUM_OCTEON_WATCHDOG)  += watchdog.o watchdog_nmi.o
 obj-$(CONFIG_CAVIUM_OCTEON_TRA)       += octeon-tra.o
 obj-$(CONFIG_CAVIUM_OCTEON_MGMT_PORT_ETHERNET) += ethernet-mgmt-port.o
 obj-$(CONFIG_CAVIUM_OCTEON_POW_ONLY_ETHERNET) += ethernet-pow.o
+obj-$(CONFIG_CAVIUM_OCTEON_SYNC)       += sync-octeon.o
 
 clean:
 	rm -f *.o
diff --git a/arch/mips/cavium-octeon/smp.c b/arch/mips/cavium-octeon/smp.c
index 836a20f..8bc4c05 100644
--- a/arch/mips/cavium-octeon/smp.c
+++ b/arch/mips/cavium-octeon/smp.c
@@ -19,12 +19,14 @@
 
 extern void octeon_user_io_init(void);
 
+extern void  oct_synchronise_count_master(void);
+extern void  oct_synchronise_count_slave(void);
+
 volatile unsigned long octeon_processor_boot = 0xff;
 volatile unsigned long octeon_processor_cycle;
 volatile unsigned long octeon_processor_sp;
 volatile unsigned long octeon_processor_gp;
 
-
 static irqreturn_t mailbox_interrupt(int irq, void *dev_id)
 {
 	const int coreid = cvmx_get_core_num();
@@ -97,6 +99,9 @@ static void octeon_smp_setup(void)
 			cpus++;
 		}
 	}
+#ifdef CONFIG_CAVIUM_OCTEON_SYNC
+	oct_synchronise_count_master();
+#endif
 }
 
 
@@ -196,7 +201,9 @@ static void octeon_smp_finish(void)
 #ifdef CONFIG_CAVIUM_OCTEON_USER_MEM
 	octeon_user_io_init();
 #endif
-
+#ifdef CONFIG_CAVIUM_OCTEON_SYNC
+	oct_synchronise_count_slave();
+#endif
 	/* to generate the first CPU timer interrupt */
 	write_c0_compare(read_c0_count() + mips_hpt_frequency / HZ);
 }
diff --git a/arch/mips/cavium-octeon/sync-octeon.c b/arch/mips/cavium-octeon/sync-octeon.c
new file mode 100644
index 0000000..ddda782
--- /dev/null
+++ b/arch/mips/cavium-octeon/sync-octeon.c
@@ -0,0 +1,87 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2004-2008 Cavium Networks
+ */
+#include <linux/sched.h>
+
+#include "hal.h"
+
+
+/*
+  Sync mips clock on different cores
+*/
+
+/* no atomic sync needed, really. Call master sync before SMP launched. */
+static atomic_t __initdata octeon_time_sync_flag = ATOMIC_INIT(0);
+
+/* Master sets up external reference clock. Use PFC0 for that.
+   If you do Octeon performance monitoring
+   at boot time - this code will break it. */
+void __init oct_synchronise_count_master(void)
+{
+	cvmx_l2c_pfctl_t pfctl;
+	cvmx_l2c_pfcx_t pfc0;
+	int count = 2;
+	unsigned long flags;
+
+	pfctl.u64 = 0;
+	pfctl.s.cnt0sel = 0; 	/* configure to L2 cache clock counting */
+	pfctl.s.cnt0ena = 1;
+	pfctl.s.cnt0rdclr = 1; 	/* enable clear on read */
+
+	local_irq_save(flags);
+
+	cvmx_write_csr(CVMX_L2C_PFCTL, pfctl.u64);
+
+	/* loop 2 times to run from cache */
+	while (count--)	{
+		/* we reset PFC to zero by reading to have instruction count
+		from PFC0 set to c0 write as close as possible to same in
+		slave function. You can look at disassembly of your generated
+		code and adjust c0 written number accordingly to get the clock
+		difference between cores down to 0 */
+		pfc0.u64 = cvmx_read_csr(CVMX_L2C_PFC0);
+		write_c0_count(0);
+	}
+
+	pfctl.s.cnt0rdclr = 0;   /* disable clear on read */
+	cvmx_write_csr(CVMX_L2C_PFCTL, pfctl.u64);
+
+	/* notify slaves it is time to sync */
+	atomic_set(&octeon_time_sync_flag, 1);
+	smp_wmb();
+	local_irq_restore(flags);
+}
+
+/* each slave core sets its clock to external reference */
+void __init oct_synchronise_count_slave(void)
+{
+	cvmx_l2c_pfcx_t pfc0;
+	int count = 2;
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	/* wait for master to signal */
+	while (!atomic_read(&octeon_time_sync_flag))
+		mb();
+
+	/* loop 2 times to run from cache */
+	while (count--)  {
+		pfc0.u64 = cvmx_read_csr(CVMX_L2C_PFC0);
+		write_c0_count(pfc0.s.pfcnt0);
+	}
+	local_irq_restore(flags);
+}
+
+
+
+
+
+
+
+
+
diff --git a/arch/mips/kernel/sync-r4k.c b/arch/mips/kernel/sync-r4k.c
index 9021108..79d2436 100644
--- a/arch/mips/kernel/sync-r4k.c
+++ b/arch/mips/kernel/sync-r4k.c
@@ -13,11 +13,11 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/irqflags.h>
-#include <linux/r4k-timer.h>
+#include <linux/cpumask.h>
 
+#include <asm/r4k-timer.h>
 #include <asm/atomic.h>
 #include <asm/barrier.h>
-#include <asm/cpumask.h>
 #include <asm/mipsregs.h>
 
 static atomic_t __initdata count_start_flag = ATOMIC_INIT(0);
@@ -26,6 +26,8 @@ static atomic_t __initdata count_count_stop = ATOMIC_INIT(0);
 
 #define COUNTON	100
 #define NR_LOOPS 5
+/* XXX Hack. Fix this when the rest of the timer sync code is submitted */
+unsigned int expirelo = 1;
 
 void __init synchronise_count_master(void)
 {
@@ -44,7 +46,6 @@ void __init synchronise_count_master(void)
 
 	pr_info("Checking COUNT synchronization across %u CPUs: ",
 		num_online_cpus());
-
 	local_irq_save(flags);
 
 	/*
@@ -103,7 +104,6 @@ void __init synchronise_count_master(void)
 	 * count registers were almost certainly out of sync
 	 * so no point in alarming people
 	 */
-	printk("done.\n");
 }
 
 void __init synchronise_count_slave(void)
@@ -155,5 +155,3 @@ void __init synchronise_count_slave(void)
 
 	local_irq_restore(flags);
 }
-#undef NR_LOOPS
-#endif
-- 
1.5.5.1

