From 873e0a1fa2853a1e6a2dcbd494b620078f7e52e1 Mon Sep 17 00:00:00 2001
From: David Daney <ddaney@caviumnetworks.com>
Date: Tue, 27 Jan 2009 14:31:07 -0800
Subject: [PATCH] clock synchronization

The counter synchronization code was using the L2C performance
counters.  These are not simulated by the OCTEON simulator, resulting
in unsynchronized clocks.  This caused an endless loop in the tick
interrupt handler.

Since the cmvcount register is already synchronized by the SMP
initialization code, the easiest solution is to create a clocksource
driver that uses cvmcount and use it instead of the csrc-r4k driver.
Once we do that, we can get rid of all of the
CONFIG_CAVIUM_OCTEON_SYNC code.

Signed-off-by: David Daney <ddaney@caviumnetworks.com>
Signed-off-by: Phil Staub <Phil.Staub@windriver.com>
---
 arch/mips/Kconfig                     |    4 --
 arch/mips/cavium-octeon/Kconfig       |    6 --
 arch/mips/cavium-octeon/Makefile      |    3 +-
 arch/mips/cavium-octeon/setup.c       |   10 ----
 arch/mips/cavium-octeon/smp.c         |    6 --
 arch/mips/cavium-octeon/sync-octeon.c |   85 +++++++--------------------------
 include/asm-mips/mipsregs.h           |    4 ++
 7 files changed, 23 insertions(+), 95 deletions(-)

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index d2882c5..48c7b95 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -603,14 +603,12 @@ config WR_PPMC
 config CAVIUM_OCTEON_SIMULATOR
 	bool "Support for the Cavium Networks Octeon Simulator"
 	select CEVT_R4K
-	select CSRC_R4K
 	select 64BIT_PHYS_ADDR
 	select SYS_SUPPORTS_64BIT_KERNEL
 	select SYS_SUPPORTS_BIG_ENDIAN
 	select SYS_SUPPORTS_HIGHMEM
 	select SYS_SUPPORTS_KGDB
 	select CPU_CAVIUM_OCTEON
-	select CAVIUM_OCTEON_SYNC
 	help
 	  The Octeon simulator is software performance model of the Cavium
 	  Octeon Processor. It supports simulating Octeon processors on x86
@@ -619,7 +617,6 @@ config CAVIUM_OCTEON_SIMULATOR
 config CAVIUM_OCTEON_REFERENCE_BOARD
 	bool "Support for the Cavium Networks Octeon reference board"
 	select CEVT_R4K
-	select CSRC_R4K
 	select 64BIT_PHYS_ADDR
 	select SYS_SUPPORTS_64BIT_KERNEL
 	select SYS_SUPPORTS_BIG_ENDIAN
@@ -632,7 +629,6 @@ config CAVIUM_OCTEON_REFERENCE_BOARD
 	select ISA
 	select GENERIC_ISA_DMA
 	select ARCH_MAY_HAVE_PC_FDC
-	select CAVIUM_OCTEON_SYNC
 	help
 	  This option supports all of the Octeon reference boards from Cavium
 	  Networks. It builds a kernel that dynamically determines the Octeon
diff --git a/arch/mips/cavium-octeon/Kconfig b/arch/mips/cavium-octeon/Kconfig
index 5f2c116..bcda070 100644
--- a/arch/mips/cavium-octeon/Kconfig
+++ b/arch/mips/cavium-octeon/Kconfig
@@ -290,12 +290,6 @@ config CAVIUM_OCTEON_IPFWD_OFFLOAD
 	help
 	  This enables Cavium Octeon ip-offload module.
 
-config CAVIUM_OCTEON_SYNC
-	bool "Enable Cavium multi-core clock synchronization"
-	default "n"
-	help
-	   This enables Cavium multi-core clock synchronisation using perf counters.
-
 config BUILD_ID_DISABLE
 	bool "Disable the build-id feature of the linker"
 	default "y"
diff --git a/arch/mips/cavium-octeon/Makefile b/arch/mips/cavium-octeon/Makefile
index 9c93406..a237f62 100644
--- a/arch/mips/cavium-octeon/Makefile
+++ b/arch/mips/cavium-octeon/Makefile
@@ -20,7 +20,7 @@ EXTRA_CFLAGS += ${CAVIUM_INCLUDES}
 
 
 obj-y := setup.o serial.o irq.o hal.o perf_counters.o octeon_info.o
-obj-y += dma-octeon.o userio.o
+obj-y += dma-octeon.o userio.o sync-octeon.o
 obj-y += octeon-memcpy.o
 obj-y += console.o
 
@@ -34,7 +34,6 @@ obj-$(CONFIG_CAVIUM_OCTEON_WATCHDOG)  += watchdog.o watchdog_nmi.o
 obj-$(CONFIG_CAVIUM_OCTEON_TRA)       += octeon-tra.o
 obj-$(CONFIG_CAVIUM_OCTEON_MGMT_PORT_ETHERNET) += ethernet-mgmt-port.o
 obj-$(CONFIG_CAVIUM_OCTEON_POW_ONLY_ETHERNET) += ethernet-pow.o
-obj-$(CONFIG_CAVIUM_OCTEON_SYNC)      += sync-octeon.o
 obj-$(CONFIG_I2C_OCTEON_TWSI)         += i2c-octeon_twsi.o
 obj-$(CONFIG_I2C_OCTEON_TWSI_RAW)     += i2c-octeon_twsi_raw.o
 
diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index 23abf6a..759a74a 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -111,16 +111,6 @@ static void octeon_halt(void)
 
 
 /**
- * Platform time init specifics.
- * @return
- */
-void __init plat_time_init(void)
-{
-	/* Nothing special here, but we are required to have one */
-}
-
-
-/**
  * Handle all the error condition interrupts that might occur.
  *
  * @param cpl
diff --git a/arch/mips/cavium-octeon/smp.c b/arch/mips/cavium-octeon/smp.c
index f2e0854..268a46d 100644
--- a/arch/mips/cavium-octeon/smp.c
+++ b/arch/mips/cavium-octeon/smp.c
@@ -99,9 +99,6 @@ static void __cpuinit octeon_smp_setup(void)
 			cpus++;
 		}
 	}
-#ifdef CONFIG_CAVIUM_OCTEON_SYNC
-	oct_synchronise_count_master();
-#endif
 }
 
 
@@ -201,9 +198,6 @@ static void __cpuinit octeon_smp_finish(void)
 #ifdef CONFIG_CAVIUM_OCTEON_USER_MEM
 	octeon_user_io_init();
 #endif
-#ifdef CONFIG_CAVIUM_OCTEON_SYNC
-	oct_synchronise_count_slave();
-#endif
 	/* to generate the first CPU timer interrupt */
 	write_c0_compare(read_c0_count() + mips_hpt_frequency / HZ);
 }
diff --git a/arch/mips/cavium-octeon/sync-octeon.c b/arch/mips/cavium-octeon/sync-octeon.c
index 452422c..3842157 100644
--- a/arch/mips/cavium-octeon/sync-octeon.c
+++ b/arch/mips/cavium-octeon/sync-octeon.c
@@ -3,78 +3,31 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 2004-2008 Cavium Networks
+ * Copyright (C) 2007 by Ralf Baechle
+ * Copyright (C) 2004-2009 Cavium Networks
  */
-#include <linux/sched.h>
+#include <linux/clocksource.h>
+#include <linux/init.h>
 
-#include "hal.h"
+#include <asm/time.h>
 
-
-/*
-  Sync mips clock on different cores
-*/
-
-/* no atomic sync needed, really. Call master sync before SMP launched. */
-static atomic_t __cpuinitdata octeon_time_sync_flag = ATOMIC_INIT(0);
-
-/* Master sets up external reference clock. Use PFC0 for that.
-   If you do Octeon performance monitoring
-   at boot time - this code will break it. */
-void __cpuinit oct_synchronise_count_master(void)
+static cycle_t octeon_cvmcount_read(void)
 {
-	cvmx_l2c_pfctl_t pfctl;
-	cvmx_l2c_pfcx_t pfc0;
-	int count = 2;
-	unsigned long flags;
-
-	pfctl.u64 = 0;
-	pfctl.s.cnt0sel = 0; 	/* configure to L2 cache clock counting */
-	pfctl.s.cnt0ena = 1;
-	pfctl.s.cnt0rdclr = 1; 	/* enable clear on read */
-
-	local_irq_save(flags);
-
-	cvmx_write_csr(CVMX_L2C_PFCTL, pfctl.u64);
-
-	/* loop 2 times to run from cache */
-	while (count--)	{
-		/* we reset PFC to zero by reading to have instruction count
-		from PFC0 set to c0 write as close as possible to same in
-		slave function. You can look at disassembly of your generated
-		code and adjust c0 written number accordingly to get the clock
-		difference between cores down to 0 */
-		pfc0.u64 = cvmx_read_csr(CVMX_L2C_PFC0);
-		write_c0_count(0);
-	}
-
-	pfctl.s.cnt0rdclr = 0;   /* disable clear on read */
-	cvmx_write_csr(CVMX_L2C_PFCTL, pfctl.u64);
-
-	/* notify slaves it is time to sync */
-	atomic_set(&octeon_time_sync_flag, 1);
-	smp_wmb();
-	local_irq_restore(flags);
+	return read_c0_cvmcount();
 }
 
-/* each slave core sets its clock to external reference */
-void __cpuinit oct_synchronise_count_slave(void)
-{
-	cvmx_l2c_pfcx_t pfc0;
-	int count = 2;
-	unsigned long flags;
-
-	local_irq_save(flags);
+static struct clocksource clocksource_mips = {
+	.name		= "OCTEON_CVMCOUNT",
+	.read		= octeon_cvmcount_read,
+	.mask		= CLOCKSOURCE_MASK(64),
+	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
+};
 
-	/* wait for master to signal */
-	while (!atomic_read(&octeon_time_sync_flag))
-		mb();
-
-	/* loop 2 times to run from cache */
-	while (count--)  {
-		pfc0.u64 = cvmx_read_csr(CVMX_L2C_PFC0);
-		write_c0_count(pfc0.s.pfcnt0);
-	}
-	local_irq_restore(flags);
+void __init plat_time_init(void)
+{
+	clocksource_mips.rating = 300;
+	clocksource_set_clock(&clocksource_mips, mips_hpt_frequency);
+	clocksource_register(&clocksource_mips);
 }
 
 
@@ -83,5 +36,3 @@ void __cpuinit oct_synchronise_count_slave(void)
 
 
 
-
-
diff --git a/include/asm-mips/mipsregs.h b/include/asm-mips/mipsregs.h
index 5d93d8c..6f4d1a5 100644
--- a/include/asm-mips/mipsregs.h
+++ b/include/asm-mips/mipsregs.h
@@ -1066,6 +1066,10 @@ do {									\
 #define read_c0_ebase()		__read_32bit_c0_register($15, 1)
 #define write_c0_ebase(val)	__write_32bit_c0_register($15, 1, val)
 
+/* Cavium OCTEON (cnMIPS) */
+#define read_c0_cvmcount()	__read_ulong_c0_register($9, 6)
+#define write_c0_cvmcount(val)	__write_ulong_c0_register($9, 6, val)
+
 /*
  * Macros to access the floating point coprocessor control registers
  */
-- 
1.6.0.3

