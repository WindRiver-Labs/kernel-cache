From c3cb5f4103520d3dfa8b1f40bc347d510fe49238 Mon Sep 17 00:00:00 2001
From: David Daney <ddaney@caviumnetworks.com>
Date: Tue, 27 Jan 2009 14:31:00 -0800
Subject: [PATCH] CF: multiple thread fixes

Requests were being handled on multiple threads causing concurrent
access to the CF and corrupting request queue state.

This patch runs the requests on a single threaded workqueue to avoid
the problem.

Signed-off-by: David Daney <ddaney@caviumnetworks.com>
Signed-off-by: Phil Staub <Phil.Staub@windriver.com>
---
 arch/mips/cavium-octeon/ebt3000_cf.c |   16 +++++++++++-----
 1 files changed, 11 insertions(+), 5 deletions(-)

diff --git a/arch/mips/cavium-octeon/ebt3000_cf.c b/arch/mips/cavium-octeon/ebt3000_cf.c
index cf28556..e20dd94 100644
--- a/arch/mips/cavium-octeon/ebt3000_cf.c
+++ b/arch/mips/cavium-octeon/ebt3000_cf.c
@@ -25,6 +25,7 @@
 #include <linux/hdreg.h>
 #include <linux/ide.h>
 #include <linux/delay.h>
+#include <linux/workqueue.h>
 
 #include "cvmx-app-init.h"
 #include "cvmx-sysinfo.h"
@@ -60,6 +61,7 @@ struct cf_device {
 	struct hd_geometry geo;
 	spinlock_t lock;
 	struct request_queue *queue;
+	struct workqueue_struct *workqueue;
 	struct work_struct cf_work;
 	int is16bit;
 	int is_true_ide;	/* is16bit must also be set */
@@ -737,7 +739,7 @@ static void ebt3000_cf_request(struct request_queue *q)
 	struct request *req = elv_next_request(q);
 	if (req) {
 		struct cf_device *cf = req->rq_disk->private_data;
-		schedule_work(&cf->cf_work);
+		queue_work(cf->workqueue, &cf->cf_work);
 	}
 }
 
@@ -796,6 +798,7 @@ static void ebt3000_cf_work(struct work_struct *work)
 			end_request(req, 0);
 		} else {
 			int count;
+			int error;
 			/* Give away the lock while we're doing the
 			   slow IOs */
 			spin_unlock_irqrestore(&cf->lock, flags);
@@ -804,10 +807,8 @@ static void ebt3000_cf_work(struct work_struct *work)
 					req->buffer, rq_data_dir(req));
 			/* We need the lock again to signal completion */
 			spin_lock_irqsave(&cf->lock, flags);
-			if (count == req->current_nr_sectors)
-				end_request(req, 1);
-			else
-				end_request(req, -EIO);
+			error = (count == req->current_nr_sectors) ? 0 : -EIO;
+			__blk_end_request(req, error, count * KERNEL_SECTOR_SIZE);
 		}
 	}
 	spin_unlock_irqrestore(&cf->lock, flags);
@@ -866,6 +867,11 @@ static int __init ebt3000_cf_init(void)
 		cf->is_true_ide = 1;
 
 	spin_lock_init(&cf->lock);
+	cf->workqueue = create_singlethread_workqueue(DEVICE_NAME "-worker");
+	if (cf->workqueue == NULL) {
+		pr_err(DEVICE_NAME ": unable to create workqueue\n");
+		goto out;
+	}
 	INIT_WORK(&cf->cf_work, ebt3000_cf_work);
 
 	/* Get a request queue. */
-- 
1.6.0.3

