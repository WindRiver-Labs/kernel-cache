From 180c7ae5bab3e3255c17445b4f6fbee8303f4e16 Mon Sep 17 00:00:00 2001
From: auto commit <unknown@unknown>
Date: Fri, 24 Oct 2008 12:23:18 -0700
Subject: [PATCH] cavium: tweak c0 handling for simulator compatibility

The simulator makes some assumptions that certain hardware bits will
always be zero -- however in practice this doesn't turn out to be,
esp. if there is an overflow condition.

Signed-off-by: Tomaso Paoletti <tpaoletti@caviumnetworks.com>
Signed-off-by: Paul Gortmaker <Paul.Gortmaker@windriver.com>
---
 include/asm-mips/mipsregs.h |    7 +++++++
 1 files changed, 7 insertions(+), 0 deletions(-)

diff --git a/include/asm-mips/mipsregs.h b/include/asm-mips/mipsregs.h
index 86a2b20..5d93d8c 100644
--- a/include/asm-mips/mipsregs.h
+++ b/include/asm-mips/mipsregs.h
@@ -862,7 +862,14 @@ do {									\
 #define write_c0_count3(val)	__write_32bit_c0_register($9, 7, val)
 
 #define read_c0_entryhi()	__read_ulong_c0_register($10, 0)
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+/* The Cavium Octeon simulator validates that unused hardware bits are zero.
+    The kernel by default allows the ASID to overflow the actual hardware
+    space. Most mips hardware doesn't care, but the simulator does. */
+#define write_c0_entryhi(val)	__write_ulong_c0_register($10, 0, (val) & ~0x1f00ul)
+#else
 #define write_c0_entryhi(val)	__write_ulong_c0_register($10, 0, val)
+#endif
 
 #define read_c0_compare()	__read_32bit_c0_register($11, 0)
 #define write_c0_compare(val)	__write_32bit_c0_register($11, 0, val)
-- 
1.5.5.1

