From 4ed1f0bc5cfd08b6d78532dd613a970686cd8c80 Mon Sep 17 00:00:00 2001
From: auto commit <unknown@unknown>
Date: Fri, 24 Oct 2008 12:23:20 -0700
Subject: [PATCH] plement the ability to use a non hard IRQ to break into KGDB

from a port that is registered in the rs232 core.

Signed-off-by: Jason Wessel <jason.wessel@windriver.com>
Signed-off-by: Yang Shi <yang.shi@windriver.com>
---
 drivers/serial/8250.c       |   49 ++++++++++++++++++++++++++++++++++++++++--
 drivers/serial/8250_kgdb.c  |   24 +++++++++++++++++++++
 include/linux/serial_8250.h |    3 ++
 lib/Kconfig.kgdb            |    9 ++++++++
 4 files changed, 82 insertions(+), 3 deletions(-)

diff --git a/drivers/serial/8250.c b/drivers/serial/8250.c
index 727623f..776102b 100644
--- a/drivers/serial/8250.c
+++ b/drivers/serial/8250.c
@@ -144,6 +144,9 @@ struct uart_8250_port {
 	 */
 	void			(*pm)(struct uart_port *port,
 				      unsigned int state, unsigned int old);
+#ifdef CONFIG_KGDB_SHARE_DEBUG_IRQ
+	void  (*debug_irq)(void);
+#endif
 };
 
 struct irq_info {
@@ -1384,9 +1387,15 @@ ignore_char:
 
 static void transmit_chars(struct uart_8250_port *up)
 {
-	struct circ_buf *xmit = &up->port.info->xmit;
+	struct circ_buf *xmit;
 	int count;
 
+#ifdef CONFIG_KGDB_SHARE_DEBUG_IRQ
+	if (up->debug_irq)
+		return;
+#endif
+
+	xmit = &up->port.info->xmit;
 	if (up->port.x_char) {
 		serial_outp(up, UART_TX, up->port.x_char);
 		up->port.icount.tx++;
@@ -1458,8 +1467,22 @@ serial8250_handle_port(struct uart_8250_port *up)
 
 	DEBUG_INTR("status = %x...", status);
 
-	if (status & (UART_LSR_DR | UART_LSR_BI))
+	if (status & (UART_LSR_DR | UART_LSR_BI)) {
+		#ifdef CONFIG_KGDB_SHARE_DEBUG_IRQ
+			if (up->debug_irq) {
+				up->debug_irq();
+				spin_unlock(&up->port.lock);
+				return;
+			}
+		#endif
 		receive_chars(up, &status);
+	}
+#ifdef CONFIG_KGDB_SHARE_DEBUG_IRQ
+	if (up->debug_irq) {
+		spin_unlock(&up->port.lock);
+		return;
+	}
+#endif
 	check_modem_status(up);
 	if (status & UART_LSR_THRE)
 		transmit_chars(up);
@@ -2981,7 +3004,6 @@ int serial8250_register_port(struct uart_port *port)
 		uart->port.private_data = port->private_data;
 		if (port->dev)
 			uart->port.dev = port->dev;
-
 		ret = uart_add_one_port(&serial8250_reg, &uart->port);
 		if (ret == 0)
 			ret = uart->port.line;
@@ -2992,6 +3014,26 @@ int serial8250_register_port(struct uart_port *port)
 }
 EXPORT_SYMBOL(serial8250_register_port);
 
+#ifdef CONFIG_KGDB_SHARE_DEBUG_IRQ
+void *serial8250_register_debugirq(struct uart_port *port, void *ptr)
+{
+	struct uart_8250_port *uart = 0;
+
+	if (port->uartclk == 0)
+		return 0;
+
+	mutex_lock(&serial_mutex);
+
+	uart = serial8250_find_match_or_unused(port);
+	if (uart) {
+		uart->debug_irq = ptr;
+	}
+	mutex_unlock(&serial_mutex);
+	return uart;
+}
+EXPORT_SYMBOL(serial8250_register_debugirq);
+#endif
+
 /**
  *	serial8250_unregister_port - remove a 16x50 serial port at runtime
  *	@line: serial line number
@@ -3042,6 +3084,7 @@ int serial8250_get_port_def(struct uart_port *port, int line)
 	port->flags    = port8250->flags;
 	port->mapbase  = port8250->mapbase;
 	port->dev      = port8250->dev;
+	port->ops      = port8250->ops;	
 	return 0;
 }
 EXPORT_SYMBOL_GPL(serial8250_get_port_def);
diff --git a/drivers/serial/8250_kgdb.c b/drivers/serial/8250_kgdb.c
index d2d6553..5219748 100644
--- a/drivers/serial/8250_kgdb.c
+++ b/drivers/serial/8250_kgdb.c
@@ -242,6 +242,12 @@ static int kgdb8250_uart_init(void)
 	return 0;
 }
 
+#ifdef CONFIG_KGDB_SHARE_DEBUG_IRQ
+static void debug_irq(void)
+{
+	kgdb8250_interrupt(0, 0);
+}
+#endif
 /*
  * Syntax for this cmdline option is:
  *   <io|mmio|mbase>,<address>[/<regshift>],<baud rate>,<irq> or
@@ -400,6 +406,15 @@ static int kgdb8250_late_init(void)
 	if (hijacked_line >= 0)
 		serial8250_unregister_port(hijacked_line);
 
+#ifdef CONFIG_KGDB_SHARE_DEBUG_IRQ
+ 	{
+ 		void *up;
+ 		up = serial8250_register_debugirq(&kgdb8250_port, debug_irq);
+ 		if (up)
+ 			kgdb8250_port.ops->startup(up);
+ 	}
+#endif
+ 
 	/* Now reinit the port as the above has disabled things. */
 	kgdb8250_uart_init();
 
@@ -478,9 +493,18 @@ static void kgdb8250_cleanup(void)
 			       8 << kgdb8250_port.regshift);
 	}
 
+#ifdef CONFIG_KGDB_SHARE_DEBUG_IRQ
+ 	{
+ 		void *up;
+ 		up = serial8250_register_debugirq(&kgdb8250_port, 0);
+ 		if (up)
+ 			kgdb8250_port.ops->shutdown(up);
+ 	}
+#else
 	/* Give the port back to the 8250 driver. */
 	if (hijacked_line >= 0)
 		serial8250_register_port(&kgdb8250_port);
+#endif
 }
 
 static int kgdb8250_set_config(const char *kmessage, struct kernel_param *kp)
diff --git a/include/linux/serial_8250.h b/include/linux/serial_8250.h
index 7b1d82f..74a73dc 100644
--- a/include/linux/serial_8250.h
+++ b/include/linux/serial_8250.h
@@ -68,5 +68,8 @@ extern int serial8250_find_port(struct uart_port *p);
 extern int serial8250_find_port_for_earlycon(void);
 extern int setup_early_serial8250_console(char *cmdline);
 int serial8250_get_port_def(struct uart_port *port, int line);
+#ifdef CONFIG_KGDB_SHARE_DEBUG_IRQ
+void *serial8250_register_debugirq(struct uart_port *port, void *ptr);
+#endif
 
 #endif
diff --git a/lib/Kconfig.kgdb b/lib/Kconfig.kgdb
index 44044b7..01275a2 100644
--- a/lib/Kconfig.kgdb
+++ b/lib/Kconfig.kgdb
@@ -55,6 +55,15 @@ config KGDB_8250
 	  attached via this driver,  the configured serial port cannot be
 	  used by the standard 8250 driver or serial earlyprintk/earlycon.
 
+config KGDB_SHARE_DEBUG_IRQ
+ 	bool "Share RS232 debug IRQ"
+ 	depends on CPU_CAVIUM_OCTEON && KGDB_8250
+ 	default n
+ 	help
+ 	  This option is hardware specific and available only when
+ 	  a board has non dedicated irq's for kgdb and uses timers
+ 	  to service the RS232 chips.
+
 config KGDBOE
 	tristate "KGDB: On ethernet"
 	depends on KGDB
-- 
1.5.5.1

