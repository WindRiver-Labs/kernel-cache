From 31adca50ade0cb266fcaa3f9e78317e444df1ec3 Mon Sep 17 00:00:00 2001
From: auto commit <unknown@unknown>
Date: Fri, 24 Oct 2008 12:23:01 -0700
Subject: [PATCH] cavium: 8250 serial driver changes

Cavium UART implementation won't work with the standard 8250 driver
as-is.  Make some adjustments and add a delay.

Signed-off-by: Tomaso Paoletti <tpaoletti@caviumnetworks.com>
Signed-off-by: Paul Gortmaker <Paul.Gortmaker@windriver.com>
---
 drivers/serial/8250.c       |   46 ++++++++++++++++++++++++++++++++++++++++++-
 drivers/serial/8250_early.c |    8 +++++++
 2 files changed, 53 insertions(+), 1 deletions(-)

diff --git a/drivers/serial/8250.c b/drivers/serial/8250.c
index 1b351a3..727623f 100644
--- a/drivers/serial/8250.c
+++ b/drivers/serial/8250.c
@@ -41,7 +41,9 @@
 
 #include <asm/io.h>
 #include <asm/irq.h>
-
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+#include <asm/delay.h>
+#endif
 #include "8250.h"
 
 /*
@@ -360,7 +362,11 @@ static unsigned int serial_in(struct uart_8250_port *up, int offset)
 
 	case UPIO_MEM:
 	case UPIO_DWAPB:
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+		return __raw_readq(up->port.membase + offset);
+#else
 		return readb(up->port.membase + offset);
+#endif
 
 	case UPIO_RM9000:
 	case UPIO_MEM32:
@@ -397,7 +403,13 @@ serial_out(struct uart_8250_port *up, int offset, int value)
 		break;
 
 	case UPIO_MEM:
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+		if (offset == (UART_LCR<<up->port.regshift))
+			value &= 0x9f;
+		 __raw_writeq((unsigned char)value, up->port.membase + offset);
+#else
 		writeb(value, up->port.membase + offset);
+#endif
 		break;
 
 	case UPIO_RM9000:
@@ -838,7 +850,9 @@ static int broken_efr(struct uart_8250_port *up)
 static void autoconfig_16550a(struct uart_8250_port *up)
 {
 	unsigned char status1, status2;
+#ifndef CONFIG_CPU_CAVIUM_OCTEON
 	unsigned int iersave;
+#endif
 
 	up->port.type = PORT_16550A;
 	up->capabilities |= UART_CAP_FIFO;
@@ -886,7 +900,9 @@ static void autoconfig_16550a(struct uart_8250_port *up)
 
 	if (!((status2 ^ status1) & UART_MCR_LOOP)) {
 		serial_outp(up, UART_LCR, 0);
+#ifndef CONFIG_CPU_CAVIUM_OCTEON
 		serial_outp(up, UART_MCR, status1 ^ UART_MCR_LOOP);
+#endif
 		serial_outp(up, UART_LCR, 0xE0);
 		status2 = serial_in(up, 0x02); /* EXCR1 */
 		serial_outp(up, UART_LCR, 0);
@@ -940,6 +956,7 @@ static void autoconfig_16550a(struct uart_8250_port *up)
 		return;
 	}
 
+#if !defined(CONFIG_TAIGA) && !defined (CONFIG_CPU_CAVIUM_OCTEON)
 	/*
 	 * Try writing and reading the UART_IER_UUE bit (b6).
 	 * If it works, this is probably one of the Xscale platform's
@@ -974,6 +991,7 @@ static void autoconfig_16550a(struct uart_8250_port *up)
 		DEBUG_AUTOCONF("Couldn't force IER_UUE to 0 ");
 	}
 	serial_outp(up, UART_IER, iersave);
+#endif /* CAVIUM */
 }
 
 /*
@@ -1135,6 +1153,10 @@ static void autoconfig(struct uart_8250_port *up, unsigned int probeflags)
 	up->port.fifosize = uart_config[up->port.type].fifo_size;
 	up->capabilities = uart_config[up->port.type].flags;
 	up->tx_loadsz = uart_config[up->port.type].tx_loadsz;
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+	up->port.fifosize = 64;
+	up->tx_loadsz = 64;
+#endif
 
 	if (up->port.type == PORT_UNKNOWN)
 		goto out;
@@ -1477,6 +1499,14 @@ static irqreturn_t serial8250_interrupt(int irq, void *dev_id)
 		up = list_entry(l, struct uart_8250_port, list);
 
 		iir = serial_in(up, UART_IIR);
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+#define UART_USR        0x27    /* UART Status Register */
+		if ((iir & 0xf) == 7) /* Busy interrupt */
+		{
+			serial_in(up, UART_USR);
+			iir = serial_in(up, UART_IIR);
+		}
+#endif
 		if (!(iir & UART_IIR_NO_INT)) {
 			serial8250_handle_port(up);
 
@@ -1598,7 +1628,11 @@ static void serial8250_timeout(unsigned long data)
 	struct uart_8250_port *up = (struct uart_8250_port *)data;
 	unsigned int iir;
 
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+	iir = 0;
+#else
 	iir = serial_in(up, UART_IIR);
+#endif
 	if (!(iir & UART_IIR_NO_INT))
 		serial8250_handle_port(up);
 	mod_timer(&up->timer, jiffies + poll_timeout(up->port.timeout));
@@ -1935,7 +1969,11 @@ static int serial8250_startup(struct uart_port *port)
 	 */
 	if (!is_real_interrupt(up->port.irq)) {
 		up->timer.data = (unsigned long)up;
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+		add_timer_on(&up->timer, 0);
+#else
 		mod_timer(&up->timer, jiffies + poll_timeout(up->port.timeout));
+#endif
 	} else {
 		retval = serial_link_irq_chain(up);
 		if (retval)
@@ -2183,6 +2221,12 @@ serial8250_set_termios(struct uart_port *port, struct ktermios *termios,
 			up->port.ignore_status_mask |= UART_LSR_OE;
 	}
 
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+{
+	udelay(500);
+}
+#endif
+
 	/*
 	 * ignore all characters if CREAD is not set
 	 */
diff --git a/drivers/serial/8250_early.c b/drivers/serial/8250_early.c
index f279745..df6bd00 100644
--- a/drivers/serial/8250_early.c
+++ b/drivers/serial/8250_early.c
@@ -49,7 +49,11 @@ static struct early_serial8250_device early_device;
 static unsigned int __init serial_in(struct uart_port *port, int offset)
 {
 	if (port->iotype == UPIO_MEM)
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+		return __raw_readq(port->membase + offset);
+#else
 		return readb(port->membase + offset);
+#endif
 	else
 		return inb(port->iobase + offset);
 }
@@ -57,7 +61,11 @@ static unsigned int __init serial_in(struct uart_port *port, int offset)
 static void __init serial_out(struct uart_port *port, int offset, int value)
 {
 	if (port->iotype == UPIO_MEM)
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+		__raw_writeq((unsigned char)value, port->membase + offset);
+#else
 		writeb(value, port->membase + offset);
+#endif
 	else
 		outb(value, port->iobase + offset);
 }
-- 
1.5.5.1

