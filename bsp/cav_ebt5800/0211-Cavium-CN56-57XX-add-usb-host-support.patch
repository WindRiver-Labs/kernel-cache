From 8ebf15a7555cec6a578d502416777a717ee1113d Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Mon, 16 Mar 2009 10:44:48 +0800
Subject: [PATCH] Cavium CN56/57XX: add usb host support

The cn56/57xx support USB host mode, so we introduce this support
by modifying imported usb driver and other related files.

Signed-off-by: David Daney <ddaney@caviumnetworks.com>
Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 arch/mips/cavium-octeon/Kconfig                    |    9 +++++
 arch/mips/cavium-octeon/Makefile                   |    1 +
 arch/mips/cavium-octeon/gpl-executive/Makefile     |    3 ++
 .../gpl-executive/cvmx-linux-kernel-exports.c      |   27 ++++++++++++++++
 arch/mips/cavium-octeon/hal.c                      |   19 ------------
 arch/mips/cavium-octeon/hal.h                      |    1 -
 arch/mips/cavium-octeon/octeon-usb-host.c          |   32 ++++++++++++++++----
 7 files changed, 66 insertions(+), 26 deletions(-)

diff --git a/arch/mips/cavium-octeon/Kconfig b/arch/mips/cavium-octeon/Kconfig
index f652005..5c5be0d 100644
--- a/arch/mips/cavium-octeon/Kconfig
+++ b/arch/mips/cavium-octeon/Kconfig
@@ -268,6 +268,15 @@ config CAVIUM_OCTEON_TRA
 	  octeon-tra.c for information on customizing this driver to find
 	  specific problems.
 
+config CAVIUM_OCTEON_USB
+	tristate "Octeon usb host driver"
+	depends on USB && CPU_CAVIUM_OCTEON
+	default n
+	help
+	  This option enables an alternative driver for the Octeon USB as a
+	  host controller. It currently does not support the CN31XX and CN3020
+	  chips. All other Octeon based chips with USB are supported.
+
 config CAVIUM_OCTEON_IPSEC
    bool "Enable enhancements to the IPSec stack to allow procotol offload."
    depends on CAVIUM_OCTEON_SPECIFIC_OPTIONS
diff --git a/arch/mips/cavium-octeon/Makefile b/arch/mips/cavium-octeon/Makefile
index a237f62..cc1371f 100644
--- a/arch/mips/cavium-octeon/Makefile
+++ b/arch/mips/cavium-octeon/Makefile
@@ -36,6 +36,7 @@ obj-$(CONFIG_CAVIUM_OCTEON_MGMT_PORT_ETHERNET) += ethernet-mgmt-port.o
 obj-$(CONFIG_CAVIUM_OCTEON_POW_ONLY_ETHERNET) += ethernet-pow.o
 obj-$(CONFIG_I2C_OCTEON_TWSI)         += i2c-octeon_twsi.o
 obj-$(CONFIG_I2C_OCTEON_TWSI_RAW)     += i2c-octeon_twsi_raw.o
+obj-$(CONFIG_CAVIUM_OCTEON_USB)       += octeon-usb-host.o
 
 clean:
 	rm -f *.o
diff --git a/arch/mips/cavium-octeon/gpl-executive/Makefile b/arch/mips/cavium-octeon/gpl-executive/Makefile
index 420b0b4..2241119 100644
--- a/arch/mips/cavium-octeon/gpl-executive/Makefile
+++ b/arch/mips/cavium-octeon/gpl-executive/Makefile
@@ -26,6 +26,8 @@ EXTRA_CFLAGS += -I $(obj)/config -I $(source)/config
 
 executive-files := cvmx-bootmem.o
 executive-files += cvmx-cmd-queue.o
+executive-files += cvmx-csr-db.o
+executive-files += cvmx-csr-db-support.o
 executive-files += cvmx-dma-engine.o
 executive-files += cvmx-fpa.o
 executive-files += cvmx-helper.o
@@ -53,6 +55,7 @@ executive-files += cvmx-tra.o
 executive-files += cvmx-twsi.o
 executive-files += cvmx-warn.o
 executive-files += cvmx-compactflash.o
+executive-files += cvmx-usb.o
 executive-files += octeon-model.o
 executive-files += octeon-pci-console.o
 
diff --git a/arch/mips/cavium-octeon/gpl-executive/cvmx-linux-kernel-exports.c b/arch/mips/cavium-octeon/gpl-executive/cvmx-linux-kernel-exports.c
index 66eb88a..a8cade5 100644
--- a/arch/mips/cavium-octeon/gpl-executive/cvmx-linux-kernel-exports.c
+++ b/arch/mips/cavium-octeon/gpl-executive/cvmx-linux-kernel-exports.c
@@ -19,6 +19,8 @@
 #include "cvmx-sysinfo.h"
 #include "cvmx-tra.h"
 #include "cvmx-warn.h"
+#include "cvmx-csr-db.h"
+#include "cvmx-usb.h"
 
 extern CVMX_SHARED __cvmx_cmd_queue_all_state_t *__cvmx_cmd_queue_state_ptr;
 
@@ -33,6 +35,10 @@ EXPORT_SYMBOL(cvmx_bootmem_free_named);
 EXPORT_SYMBOL(cvmx_bootmem_find_named_block);
 EXPORT_SYMBOL(cvmx_bootmem_available_mem);
 
+/* Exports for cvmx-csr-db-support.c */
+EXPORT_SYMBOL(cvmx_db_get_chipindex);
+EXPORT_SYMBOL(cvmx_csr_db_decode);
+
 /* Exports for cvmx-cmd-queue.c */
 EXPORT_SYMBOL(cvmx_cmd_queue_initialize);
 EXPORT_SYMBOL(cvmx_cmd_queue_shutdown);
@@ -53,6 +59,7 @@ EXPORT_SYMBOL(cvmx_helper_link_set);
 
 /* Exports for cvmx-helper-board.c */
 EXPORT_SYMBOL(cvmx_helper_board_get_mii_address);
+EXPORT_SYMBOL(__cvmx_helper_board_usb_get_clock_type);
 
 /* Exports for cvmx-helper-util.c */
 EXPORT_SYMBOL(cvmx_helper_interface_mode_to_string);
@@ -98,6 +105,26 @@ EXPORT_SYMBOL(cvmx_tra_read);
 EXPORT_SYMBOL(cvmx_tra_decode_text);
 EXPORT_SYMBOL(cvmx_tra_display);
 
+/* Exports for cvmx-usb.c */
+EXPORT_SYMBOL(cvmx_usb_get_num_ports);
+EXPORT_SYMBOL(cvmx_usb_initialize);
+EXPORT_SYMBOL(cvmx_usb_shutdown);
+EXPORT_SYMBOL(cvmx_usb_enable);
+EXPORT_SYMBOL(cvmx_usb_disable);
+EXPORT_SYMBOL(cvmx_usb_get_status);
+EXPORT_SYMBOL(cvmx_usb_set_status);
+EXPORT_SYMBOL(cvmx_usb_open_pipe);
+EXPORT_SYMBOL(cvmx_usb_submit_bulk);
+EXPORT_SYMBOL(cvmx_usb_submit_interrupt);
+EXPORT_SYMBOL(cvmx_usb_submit_control);
+EXPORT_SYMBOL(cvmx_usb_submit_isochronous);
+EXPORT_SYMBOL(cvmx_usb_cancel);
+EXPORT_SYMBOL(cvmx_usb_cancel_all);
+EXPORT_SYMBOL(cvmx_usb_close_pipe);
+EXPORT_SYMBOL(cvmx_usb_register_callback);
+EXPORT_SYMBOL(cvmx_usb_get_frame_number);
+EXPORT_SYMBOL(cvmx_usb_poll);
+
 /* Exports for cvmx-warn.c */
 EXPORT_SYMBOL(cvmx_warn);
 
diff --git a/arch/mips/cavium-octeon/hal.c b/arch/mips/cavium-octeon/hal.c
index 10c0412..a2e7e9c 100644
--- a/arch/mips/cavium-octeon/hal.c
+++ b/arch/mips/cavium-octeon/hal.c
@@ -124,25 +124,6 @@ int octeon_is_pci_host(void)
 
 
 /**
- * This function returns if the USB clock uses 12/24/48MHz 3.3V
- * reference clock at the USB_REF_CLK pin. Result is non zero
- * if it does, If it uses 12MHz crystal as clock source at USB_XO
- * and USB_XI, then the return value is zero. This function will
- * need update for new boards.
- *
- * @return True is USB is using a reference clock
- */
-int octeon_usb_is_ref_clk(void)
-{
-	switch (octeon_bootinfo->board_type) {
-	case CVMX_BOARD_TYPE_BBGW_REF:
-		return 0;
-	}
-	return 1;
-}
-
-
-/**
  * Get the clock rate of Octeon
  *
  * @return Clock rate in HZ
diff --git a/arch/mips/cavium-octeon/hal.h b/arch/mips/cavium-octeon/hal.h
index 85021d9..9fe7902 100644
--- a/arch/mips/cavium-octeon/hal.h
+++ b/arch/mips/cavium-octeon/hal.h
@@ -40,7 +40,6 @@ extern void octeon_bootmem_unlock(void);
 
 extern int octeon_is_simulation(void);
 extern int octeon_is_pci_host(void);
-extern int octeon_usb_is_ref_clk(void);
 extern uint64_t octeon_get_clock_rate(void);
 extern const char *octeon_board_type_string(void);
 extern const char *octeon_get_pci_interrupts(void);
diff --git a/arch/mips/cavium-octeon/octeon-usb-host.c b/arch/mips/cavium-octeon/octeon-usb-host.c
index cad703e..2c625ec 100644
--- a/arch/mips/cavium-octeon/octeon-usb-host.c
+++ b/arch/mips/cavium-octeon/octeon-usb-host.c
@@ -161,12 +161,22 @@ static void octeon_usb_urb_complete_callback(cvmx_usb_state_t *usb,
 	case CVMX_USB_COMPLETE_CANCEL:
 		urb->status = -EPIPE;
 		break;
+	case CVMX_USB_COMPLETE_STALL:
+		DEBUG_ERROR("%s: status=stall pipe=%d submit=%d size=%d\n",
+			    __func__, pipe_handle, submit_handle,
+			    bytes_transferred);
+		urb->status = -EPIPE;
+		break;
+        case CVMX_USB_COMPLETE_BABBLEERR:
+		DEBUG_ERROR("%s: status=babble pipe=%d submit=%d size=%d\n",
+			    __func__, pipe_handle, submit_handle,
+			    bytes_transferred);
+		urb->status = -EOVERFLOW;
+		break;
 	case CVMX_USB_COMPLETE_SHORT:
 	case CVMX_USB_COMPLETE_ERROR:
-	case CVMX_USB_COMPLETE_STALL:
 	case CVMX_USB_COMPLETE_XACTERR:
 	case CVMX_USB_COMPLETE_DATATGLERR:
-	case CVMX_USB_COMPLETE_BABBLEERR:
 	case CVMX_USB_COMPLETE_FRAMEERR:
 		DEBUG_ERROR("%s: status=%d pipe=%d submit=%d size=%d\n",
 			    __func__, status, pipe_handle, submit_handle,
@@ -175,12 +185,11 @@ static void octeon_usb_urb_complete_callback(cvmx_usb_state_t *usb,
 		break;
 	}
 	spin_unlock(&priv->lock);
-	usb_hcd_giveback_urb(hcd, urb);
+	usb_hcd_giveback_urb(hcd, urb, urb->status);
 	spin_lock(&priv->lock);
 }
 
 static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
-				  struct usb_host_endpoint *ep,
 				  struct urb *urb, gfp_t mem_flags)
 {
 	struct octeon_usb_priv_t *priv =
@@ -189,6 +198,7 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 	int pipe_handle;
 	unsigned long flags;
 	cvmx_usb_iso_packet_t *iso_packet;
+	struct usb_host_endpoint *ep = urb->ep;
 
 	DEBUG_CALL("OcteonUSB: %s called\n", __func__);
 	spin_lock_irqsave(&priv->lock, flags);
@@ -358,7 +368,8 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 	return 0;
 }
 
-static int octeon_usb_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
+static int octeon_usb_urb_dequeue(struct usb_hcd *hcd, struct urb *urb,
+				  int status)
 {
 	struct octeon_usb_priv_t *priv =
 	    (struct octeon_usb_priv_t *) hcd->hcd_priv;
@@ -367,6 +378,7 @@ static int octeon_usb_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
 	int pipe_handle;
 	int submit_handle;
 	unsigned long flags;
+	int rc;
 
 	DEBUG_CALL("OcteonUSB: %s called\n", __func__);
 
@@ -381,6 +393,13 @@ static int octeon_usb_urb_dequeue(struct usb_hcd *hcd, struct urb *urb)
 	pipe_handle = 0xffff & (long)ep->hcpriv;
 	submit_handle = (long)urb->hcpriv;
 	spin_lock_irqsave(&priv->lock, flags);
+
+	rc = usb_hcd_check_unlink_urb(hcd, urb, status);
+	if (rc) {
+		spin_unlock_irqrestore(&priv->lock, flags);
+		return rc;
+	}
+
 	if (cvmx_usb_cancel(&priv->usb, pipe_handle, submit_handle)) {
 		spin_unlock_irqrestore(&priv->lock, flags);
 		DEBUG_ERROR("OcteonUSB: Canceling URB failed\n");
@@ -684,8 +703,9 @@ static int octeon_usb_driver_probe(struct device *dev)
 	}
 
 	/* This delay is needed for CN3010, but I don't know why... */
-	udelay(10000);
+	mdelay(10);
 
+	spin_lock_init(&priv->lock);
 	spin_lock_irqsave(&priv->lock, flags);
 	cvmx_usb_poll(&priv->usb);
 	spin_unlock_irqrestore(&priv->lock, flags);
-- 
1.6.0.4

