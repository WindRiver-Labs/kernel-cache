From 9a662d9ed0773d3c2ed3fd594759247622964f94 Mon Sep 17 00:00:00 2001
From: auto commit <unknown@unknown>
Date: Fri, 24 Oct 2008 12:23:10 -0700
Subject: [PATCH] auto_msg: importing 1000-1.8.0-cleanup-ethernet-pow.patch

This is an automatic import of patch 1000-1.8.0-cleanup-ethernet-pow.patch, no headers were
detected and a default message was constructed
---
 arch/mips/cavium-octeon/ethernet-pow.c |   88 ++++++++++++++++++-------------
 1 files changed, 51 insertions(+), 37 deletions(-)

diff --git a/arch/mips/cavium-octeon/ethernet-pow.c b/arch/mips/cavium-octeon/ethernet-pow.c
index c9bfb80..3b750e2 100644
--- a/arch/mips/cavium-octeon/ethernet-pow.c
+++ b/arch/mips/cavium-octeon/ethernet-pow.c
@@ -21,7 +21,9 @@
 #define IP_PROTOCOL_TCP 6	/* IP header protocol for TCP */
 #define IP_PROTOCOL_UDP 0x11	/* IP header protocol for UDP */
 
-#define DEBUGPRINT(format, ...) do{if (printk_ratelimit()) printk(format, ##__VA_ARGS__);} while (0)
+#define DEBUGPRINT(format, ...) do { if (printk_ratelimit()) 		\
+					printk(format, ##__VA_ARGS__);	\
+				} while (0)
 
 /* These are the Octeon CSR IO addresses we are going to need */
 #define OCTEON_POW_WQ_INT_THRX(offset)  (0x8001670000000080ull+((offset)*8))
@@ -42,7 +44,7 @@ MODULE_PARM_DESC(receive_group,
 		 "\t\tthe system. If you don't specify a value, the core ID will\n"
 		 "\t\tbe used.");
 
-int broadcast_groups = 0;
+int broadcast_groups;
 module_param(broadcast_groups, int, 0644);
 MODULE_PARM_DESC(broadcast_groups,
 		 " Bitmask of groups to send broadcasts to. This MUST be specified.\n"
@@ -133,9 +135,9 @@ typedef struct {
 } octeon_wqe_t;
 
 static int fpa_wqe_pool = 1;	/* HW FPA pool to use for work queue entries */
-static int fpa_packet_pool = 0;	/* HW FPA pool to use for packet buffers */
+static int fpa_packet_pool;	/* HW FPA pool to use for packet buffers */
 static int fpa_packet_pool_size = 2048;	/* Size of the packet buffers */
-static struct net_device *global_device = NULL;
+static struct net_device *global_device;
 
 
 /**
@@ -197,7 +199,7 @@ static inline void fpa_free(void *ptr, int pool, int num_cache_lines)
  * @param qos      Input queue to add to.
  * @param grp      group value for the work queue entry.
  */
-static inline void pow_work_submit(octeon_wqe_t * wqp, uint32_t tag,
+static inline void pow_work_submit(octeon_wqe_t *wqp, uint32_t tag,
 				   uint64_t tag_type, uint64_t qos,
 				   uint64_t grp)
 {
@@ -236,7 +238,7 @@ static inline octeon_wqe_t *pow_work_request_sync(int wait)
  *               Work queue entry to free
  * @return Zero on success, Negative on failure.
  */
-static int free_work(octeon_wqe_t * work)
+static int free_work(octeon_wqe_t *work)
 {
 	int segments = work->word2.s.bufs;
 	octeon_buf_ptr_t segment_ptr = work->packet_ptr;
@@ -342,45 +344,55 @@ static int packet_transmit(struct sk_buff *skb, struct net_device *dev)
 
 		if (skb->protocol == htons(ETH_P_IP)) {
 			work->word2.s.ip_offset = 14;
-			// work->word2.s.vlan_valid = 0; /* FIXME */
-			// work->word2.s.vlan_cfi = 0; /* FIXME */
-			// work->word2.s.vlan_id = 0; /* FIXME */
-			// work->word2.s.dec_ipcomp = 0; /* FIXME */
+			#if 0
+			work->word2.s.vlan_valid = 0;	/* FIXME */
+			work->word2.s.vlan_cfi = 0;	/* FIXME */
+			work->word2.s.vlan_id = 0;	/* FIXME */
+			work->word2.s.dec_ipcomp = 0;	/* FIXME */
+			#endif
 			work->word2.s.tcp_or_udp =
 				(ip_hdr(skb)->protocol == IP_PROTOCOL_TCP) ||
 				(ip_hdr(skb)->protocol == IP_PROTOCOL_UDP);
-			// work->word2.s.dec_ipsec = 0; /* FIXME */
-			// work->word2.s.is_v6 = 0; /* We only support IPv4
-			// right now */
-			// work->word2.s.software = 0; /* Hardware would set to
-			// zero */
-			// work->word2.s.L4_error = 0; /* No error, packet is
-			// internal */
+			#if 0
+			work->word2.s.dec_ipsec = 0; /* FIXME */
+			work->word2.s.is_v6 = 0; /* We only support IPv4
+						    right now */
+			work->word2.s.software = 0; /* Hardware would set to
+						       zero */
+			work->word2.s.L4_error = 0; /* No error, packet is
+						       internal */
+			#endif
 			work->word2.s.is_frag = !((ip_hdr(skb)->frag_off == 0)
 						  || (ip_hdr(skb)->frag_off ==
 						      1 << 14));
-			// work->word2.s.IP_exc = 0; /* Assume Linux is sending
-			// a good packet */
+			#if 0
+			work->word2.s.IP_exc = 0; /* Assume Linux is sending
+						     a good packet */
+			#endif
 			work->word2.s.is_bcast =
 				(skb->pkt_type == PACKET_BROADCAST);
 			work->word2.s.is_mcast =
 				(skb->pkt_type == PACKET_MULTICAST);
-			// work->word2.s.not_IP = 0; /* This is an IP packet */
-			// work->word2.s.rcv_error = 0; /* No error, packet is
-			// internal */
-			// work->word2.s.err_code = 0; /* No error, packet is
-			// internal */
+			#if 0
+			work->word2.s.not_IP = 0; /* This is an IP packet */
+			work->word2.s.rcv_error = 0; /* No error, packet is
+							internal */
+			work->word2.s.err_code = 0;  /* No error, packet is
+							internal */
+			#endif
 
 			/* When copying the data, include 4 bytes of the
 			   ethernet header to align the same way hardware does */
 			memcpy(work->packet_data, skb->data + 10,
 			       sizeof(work->packet_data));
 		} else {
-			// work->word2.snoip.vlan_valid = 0; /* FIXME */
-			// work->word2.snoip.vlan_cfi = 0; /* FIXME */
-			// work->word2.snoip.vlan_id = 0; /* FIXME */
-			// work->word2.snoip.software = 0; /* Hardware would
-			// set to zero */
+			#if 0
+			work->word2.snoip.vlan_valid = 0; /* FIXME */
+			work->word2.snoip.vlan_cfi = 0;   /* FIXME */
+			work->word2.snoip.vlan_id = 0;    /* FIXME */
+			work->word2.snoip.software = 0;   /* Hardware would
+							     set to zero */
+			#endif
 			work->word2.snoip.is_rarp =
 				skb->protocol == htons(ETH_P_RARP);
 			work->word2.snoip.is_arp =
@@ -390,10 +402,12 @@ static int packet_transmit(struct sk_buff *skb, struct net_device *dev)
 			work->word2.snoip.is_mcast =
 				(skb->pkt_type == PACKET_MULTICAST);
 			work->word2.snoip.not_IP = 1;	/* IP was done up above */
-			// work->word2.snoip.rcv_error = 0; /* No error, packet
-			// is internal */
-			// work->word2.snoip.err_code = 0; /* No error, packet
-			// is internal */
+			#if 0
+			work->word2.snoip.rcv_error = 0; /* No error, packet
+							    is internal */
+			work->word2.snoip.err_code = 0;  /* No error, packet
+							    is internal */
+			#endif
 			memcpy(work->packet_data, skb->data,
 			       sizeof(work->packet_data));
 		}
@@ -410,7 +424,7 @@ static int packet_transmit(struct sk_buff *skb, struct net_device *dev)
 	dev_kfree_skb(skb);
 	return 0;
 
-      fail:
+fail:
 	if (work)
 		fpa_free(work, fpa_wqe_pool, 0);
 	if (packet_buffer)
@@ -440,7 +454,7 @@ static irqreturn_t do_interrupt(int cpl, void *dev_id)
 	struct sk_buff *skb;
 
 	/* Make sure any userspace operations are complete */
-	asm volatile ("synciobdma":::"memory");
+	asm volatile ("synciobdma" : : : "memory");
 
 	/* Acknowledge the interrupt */
 	cvmx_write_csr(OCTEON_POW_WQ_INT, 0x10001 << receive_group);
@@ -676,9 +690,9 @@ static int __init ethernet_pow_init(void)
 
 	/* Spin waiting for another core to setup all the hardware */
 	printk("Waiting for another core to setup the IPD hardware...");
-	while ((cvmx_read_csr(OCTEON_IPD_CTL_STATUS) & 1) == 0) {
+	while ((cvmx_read_csr(OCTEON_IPD_CTL_STATUS) & 1) == 0)
 		mdelay(100);
-	}
+
 	printk("Done\n");
 
 	/* Read the configured size of the FPA packet buffers. This way we
-- 
1.5.5.1

