From 78ec0bf167b3d292723570db896686cf100efeb0 Mon Sep 17 00:00:00 2001
From: Guijin Gao <guijin.gao@windriver.com>
Date: Tue, 18 Nov 2008 16:59:56 +0800
Subject: [PATCH] conditionally skip cop2 register save to avoid kthread stack corruption

Code in "resume" can corrupt the stack of kernel thread. It assumes
there is a frame of "pt_regs" at the bottom of the kernel stack. But
if it's in a kernel thread, there is no such a frame at the bottom
of the stack and the instructions that update stored cp0_status
corrupt the stack.

Then following instructions in "resume" corrupt the stack of kernel
thread:

=======================================================
       /* Disable COP2 in the stored process state */
       li      t1, ST0_CU2
       xor     t0, t1
       LONG_S  t0, ST_OFF(t2)
=======================================================

The fix is to judge whether it's in kernel thread by value of
"addr_limit" in "struct thread_info". If value of "addr_limit"
is equal to "KERNEL_DS", it's in a kernel thread and we don't
save cop2 registers.

Signed-off-by: Guijin Gao <guijin.gao@windriver.com>
---
 arch/mips/kernel/octeon_switch.S |    5 +++++
 1 files changed, 5 insertions(+), 0 deletions(-)

diff --git a/arch/mips/kernel/octeon_switch.S b/arch/mips/kernel/octeon_switch.S
index a3fe6ca..f3ac934 100644
--- a/arch/mips/kernel/octeon_switch.S
+++ b/arch/mips/kernel/octeon_switch.S
@@ -46,6 +46,11 @@
 
 	/* check if we need to save COP2 registers */
 	PTR_L	t2, TASK_THREAD_INFO(a0)
+	/* if we are a kernel thread, TI_ADDR_LIMIT is
+	   KERNEL_DS  ((mm_segment_t) { 0UL }) and we can't
+	   be using COP2, so jump around the save */
+	LONG_L  t0, TI_ADDR_LIMIT(t2)
+	beqz    t0, 1f
 	LONG_L	t0, ST_OFF(t2)
 	bbit0	t0, 30, 1f
 
-- 
1.6.0.3

