From 59ec6819bdcf1185a4cb1fff14dd35e5d14aea08 Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Mon, 16 Mar 2009 10:47:55 +0800
Subject: [PATCH] Cavium CN56/57XX: Ethernet management port support

The Cavium ethernet management port can drop all of the
packets with error log:
ERROR: cvmx_mgmt_port_receive: Receive error code 0. Packet dropped
ERROR: cvmx_mgmt_port_receive: Receive error code 0. Packet dropped
ERROR: cvmx_mgmt_port_receive: Receive error code 0. Packet dropped

To fix this, we backport management port related Simple Exec files
from Cavium SDK 1.8.1-294

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
---
 arch/mips/cavium-octeon/executive/cvmx-mgmt-port.c |  207 +++++++++++++-------
 arch/mips/cavium-octeon/executive/cvmx-mgmt-port.h |   12 ++
 2 files changed, 152 insertions(+), 67 deletions(-)

diff --git a/arch/mips/cavium-octeon/executive/cvmx-mgmt-port.c b/arch/mips/cavium-octeon/executive/cvmx-mgmt-port.c
index c0f687e..9cb9ed9 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-mgmt-port.c
+++ b/arch/mips/cavium-octeon/executive/cvmx-mgmt-port.c
@@ -58,10 +58,11 @@
 #include "cvmx-mgmt-port.h"
 #include "cvmx-sysinfo.h"
 
-#define CVMX_MGMT_PORT_NUM_PORTS        2	/* Right now we only have one mgmt port */
-#define CVMX_MGMT_PORT_NUM_TX_BUFFERS   128	/* Number of TX ring buffer entries and buffers */
+#define CVMX_MGMT_PORT_NUM_PORTS        2	/* Max mgmt ports. Current eval board only implements one */
+#define CVMX_MGMT_PORT_NUM_TX_BUFFERS   16	/* Number of TX ring buffer entries and buffers */
 #define CVMX_MGMT_PORT_NUM_RX_BUFFERS   128	/* Number of RX ring buffer entries and buffers */
-#define CVMX_MGMT_PORT_BUFFER_SIZE      1536	/* Size of each TX/RX buffer */
+#define CVMX_MGMT_PORT_TX_BUFFER_SIZE   12288   /* Size of each TX/RX buffer */
+#define CVMX_MGMT_PORT_RX_BUFFER_SIZE   1536    /* Size of each TX/RX buffer */
 
 /**
  * Format of the TX/RX ring buffer entries
@@ -88,9 +89,9 @@ typedef struct {
 	cvmx_mgmt_port_ring_entry_t tx_ring[CVMX_MGMT_PORT_NUM_TX_BUFFERS];
 	cvmx_mgmt_port_ring_entry_t rx_ring[CVMX_MGMT_PORT_NUM_RX_BUFFERS];
 	char tx_buffers[CVMX_MGMT_PORT_NUM_TX_BUFFERS]
-	    [CVMX_MGMT_PORT_BUFFER_SIZE];
+	    [CVMX_MGMT_PORT_TX_BUFFER_SIZE];
 	char rx_buffers[CVMX_MGMT_PORT_NUM_RX_BUFFERS]
-	    [CVMX_MGMT_PORT_BUFFER_SIZE];
+	    [CVMX_MGMT_PORT_RX_BUFFER_SIZE];
 } cvmx_mgmt_port_state_t;
 
 /**
@@ -124,6 +125,8 @@ int __cvmx_mgmt_port_num_ports(void)
 cvmx_mgmt_port_result_t cvmx_mgmt_port_initialize(int port)
 {
 	char *alloc_name = "cvmx_mgmt_port";
+	cvmx_mixx_oring1_t oring1;
+	cvmx_mixx_ctl_t mix_ctl;
 
 	if ((port < 0) || (port >= __cvmx_mgmt_port_num_ports()))
 		return CVMX_MGMT_PORT_INVALID_PARAM;
@@ -150,6 +153,27 @@ cvmx_mgmt_port_result_t cvmx_mgmt_port_initialize(int port)
 		}
 	}
 
+	/* Reset the MIX block if the previous user had a different TX ring size */
+	mix_ctl.u64 = cvmx_read_csr(CVMX_MIXX_CTL(port));
+	if (!mix_ctl.s.reset)
+	{
+		oring1.u64 = cvmx_read_csr(CVMX_MIXX_ORING1(port));
+		if (oring1.s.osize != CVMX_MGMT_PORT_NUM_TX_BUFFERS)
+		{
+			mix_ctl.u64 = cvmx_read_csr(CVMX_MIXX_CTL(port));
+			mix_ctl.s.en = 0;
+			cvmx_write_csr(CVMX_MIXX_CTL(port), mix_ctl.u64);
+			do
+			{
+				mix_ctl.u64 = cvmx_read_csr(CVMX_MIXX_CTL(port));
+			} while (mix_ctl.s.busy);
+			mix_ctl.s.reset = 1;
+			cvmx_write_csr(CVMX_MIXX_CTL(port), mix_ctl.u64);
+			cvmx_read_csr(CVMX_MIXX_CTL(port));
+			memset(cvmx_mgmt_port_state_ptr + port, 0, sizeof(cvmx_mgmt_port_state_t));
+		}
+	}
+
 	if (cvmx_mgmt_port_state_ptr[port].tx_ring[0].u64 == 0) {
 		cvmx_mgmt_port_state_t *state = cvmx_mgmt_port_state_ptr + port;
 		int i;
@@ -192,7 +216,7 @@ cvmx_mgmt_port_result_t cvmx_mgmt_port_initialize(int port)
 
 		/* Setup the TX ring */
 		for (i = 0; i < CVMX_MGMT_PORT_NUM_TX_BUFFERS; i++) {
-			state->tx_ring[i].s.len = CVMX_MGMT_PORT_BUFFER_SIZE;
+			state->tx_ring[i].s.len = CVMX_MGMT_PORT_TX_BUFFER_SIZE;
 			state->tx_ring[i].s.addr =
 			    cvmx_ptr_to_phys(state->tx_buffers[i]);
 		}
@@ -206,7 +230,8 @@ cvmx_mgmt_port_result_t cvmx_mgmt_port_initialize(int port)
 
 		/* Setup the RX ring */
 		for (i = 0; i < CVMX_MGMT_PORT_NUM_RX_BUFFERS; i++) {
-			state->rx_ring[i].s.len = CVMX_MGMT_PORT_BUFFER_SIZE;
+			/* This size is -8 due to an errata for CN56XX pass 1 */
+			state->rx_ring[i].s.len = CVMX_MGMT_PORT_RX_BUFFER_SIZE - 8;
 			state->rx_ring[i].s.addr =
 			    cvmx_ptr_to_phys(state->rx_buffers[i]);
 		}
@@ -226,6 +251,9 @@ cvmx_mgmt_port_result_t cvmx_mgmt_port_initialize(int port)
 		/* Set the MAC address filtering up */
 		cvmx_mgmt_port_set_mac(port, state->mac);
 
+		/* Set the default max size to an MTU of 1500 with L2 and VLAN */
+		cvmx_mgmt_port_set_max_packet_size(port, 1518);
+
 		/* Enable the port HW. Packets are not allowed until cvmx_mgmt_port_enable() is called */
 		mix_ctl.u64 = 0;
 		mix_ctl.s.crc_strip = 1;	/* Strip the ending CRC */
@@ -234,8 +262,8 @@ cvmx_mgmt_port_result_t cvmx_mgmt_port_initialize(int port)
 		mix_ctl.s.mrq_hwm = 1;	/* MII CB-request FIFO programmable high watermark */
 		cvmx_write_csr(CVMX_MIXX_CTL(port), mix_ctl.u64);
 
-		if (OCTEON_IS_MODEL(OCTEON_CN56XX_PASS1)
-		    || OCTEON_IS_MODEL(OCTEON_CN52XX_PASS1)) {
+		if (OCTEON_IS_MODEL(OCTEON_CN56XX_PASS1 | 0x08000000)
+		    || OCTEON_IS_MODEL(OCTEON_CN52XX_PASS1 | 0x08000000)) {
 			/* Force compensation values, as they are not determined properly by HW */
 			cvmx_agl_gmx_drv_ctl_t drv_ctl;
 
@@ -310,12 +338,6 @@ cvmx_mgmt_port_result_t cvmx_mgmt_port_enable(int port)
 	rxx_frm_ctl.s.pre_chk = 1;	/* This port is configured to send PREAMBLE+SFD to begin every frame.  GMX checks that the PREAMBLE is sent correctly */
 	cvmx_write_csr(CVMX_AGL_GMX_RXX_FRM_CTL(port), rxx_frm_ctl.u64);
 
-	/* Don't allow packets that span buffers */
-	cvmx_write_csr(CVMX_AGL_GMX_RXX_FRM_MAX(port),
-		       CVMX_MGMT_PORT_BUFFER_SIZE);
-	cvmx_write_csr(CVMX_AGL_GMX_RXX_JABBER(port),
-		       CVMX_MGMT_PORT_BUFFER_SIZE);
-
 	/* Enable the AGL block */
 	agl_gmx_inf_mode.u64 = 0;
 	agl_gmx_inf_mode.s.en = 1;
@@ -383,7 +405,7 @@ cvmx_mgmt_port_result_t cvmx_mgmt_port_send(int port, int packet_len,
 		return CVMX_MGMT_PORT_INVALID_PARAM;
 
 	/* Max sure the packet size is valid */
-	if ((packet_len < 1) || (packet_len > CVMX_MGMT_PORT_BUFFER_SIZE))
+	if ((packet_len < 1) || (packet_len > CVMX_MGMT_PORT_TX_BUFFER_SIZE))
 		return CVMX_MGMT_PORT_INVALID_PARAM;
 
 	if (buffer == NULL)
@@ -454,65 +476,91 @@ int cvmx_mgmt_port_receive(int port, int buffer_len, void *buffer)
 
 	/* Find out how many RX packets are pending */
 	mix_ircnt.u64 = cvmx_read_csr(CVMX_MIXX_IRCNT(port));
-	if (mix_ircnt.s.ircnt) {
-		/* Based on the completion code figure out what happened */
-		switch (state->rx_ring[state->rx_read_index].s.code) {
-		case 15:	/* Done - Everything is good */
-			if (buffer_len >=
-			    state->rx_ring[state->rx_read_index].s.len) {
-				/* Some packets seem to be copied at offset 8 in the buffer.  Here we check to see if the first 8 bytes
-				 ** are zero, and if so, skip those bytes.  We clear these bytes so that this check is valid the next time
-				 ** around. */
-				if (*
-				    ((uint64_t *) (state->
-						   rx_buffers[state->
-							      rx_read_index])))
-					memcpy(buffer,
-					       state->rx_buffers[state->
-								 rx_read_index],
-					       state->rx_ring[state->
-							      rx_read_index].s.
-					       len);
-				else
-					memcpy(buffer,
-					       state->rx_buffers[state->
-								 rx_read_index]
-					       + 8,
-					       state->rx_ring[state->
-							      rx_read_index].s.
-					       len);
-
-				memset(state->rx_buffers[state->rx_read_index],
-				       0, 8);
-				result =
-				    state->rx_ring[state->rx_read_index].s.len;
-			} else {
-				/* Not enough room for the packet */
-				cvmx_dprintf
-				    ("ERROR: cvmx_mgmt_port_receive: Packet (%d) larger than supplied buffer (%d)\n",
-				     state->rx_ring[state->rx_read_index].s.len,
-				     buffer_len);
-				result = CVMX_MGMT_PORT_NO_MEMORY;
-			}
-			break;
-		default:
-			cvmx_dprintf
-			    ("ERROR: cvmx_mgmt_port_receive: Receive error code %d. Packet dropped\n",
-			     state->rx_ring[state->rx_read_index].s.code);
-			result = -state->rx_ring[state->rx_read_index].s.code;
-			break;
-		}
+    if (mix_ircnt.s.ircnt)
+    {
+        void *source = state->rx_buffers[state->rx_read_index];
+        uint64_t *zero_check = source;
+        /* CN56XX pass 1 has an errata where packets might start 8 bytes
+            into the buffer instead of at their correct lcoation. If the
+            first 8 bytes is zero we assume this has happened */
+        if (OCTEON_IS_MODEL(OCTEON_CN56XX_PASS1 | 0x08000000) && (*zero_check == 0))
+            source += 8;
+        /* Start off with zero bytes received */
+        result = 0;
+        /* While the completion code signals more data, copy the buffers
+            into the user's data */
+        while (state->rx_ring[state->rx_read_index].s.code == 16)
+        {
+            /* Only copy what will fit in the user's buffer */
+            int length = state->rx_ring[state->rx_read_index].s.len;
+            if (length > buffer_len)
+                length = buffer_len;
+            memcpy(buffer, source, length);
+            /* Reduce the size of the buffer to the remaining space. If we run
+                out we will signal an error when the code 15 buffer doesn't fit */
+            buffer += length;
+            buffer_len -= length;
+            result += length;
+            /* Update this buffer for reuse in future receives. This size is
+                -8 due to an errata for CN56XX pass 1 */
+            state->rx_ring[state->rx_read_index].s.code = 0;
+            state->rx_ring[state->rx_read_index].s.len = CVMX_MGMT_PORT_RX_BUFFER_SIZE - 8;
+            state->rx_read_index = (state->rx_read_index + 1) % CVMX_MGMT_PORT_NUM_RX_BUFFERS;
+            /* Zero the beginning of the buffer for use by the errata check */
+            *zero_check = 0;
+            CVMX_SYNCWS;
+            /* Increment the number of RX buffers */
+            cvmx_write_csr(CVMX_MIXX_IRING2(port), 1);
+            source = state->rx_buffers[state->rx_read_index];
+            zero_check = source;
+        }
+
+        /* Check for the final good completion code */
+        if (state->rx_ring[state->rx_read_index].s.code == 15)
+        {
+            if (buffer_len >= state->rx_ring[state->rx_read_index].s.len)
+            {
+                int length = state->rx_ring[state->rx_read_index].s.len;
+                memcpy(buffer, source, length);
+                result += length;
+            }
+            else
+            {
+                /* Not enough room for the packet */
+                cvmx_dprintf("ERROR: cvmx_mgmt_port_receive: Packet (%d) larger than supplied buffer (%d)\n", state->rx_ring[state->rx_read_index].s.len, buffer_len);
+                result = CVMX_MGMT_PORT_NO_MEMORY;
+            }
+        }
+        else
+        {
+            cvmx_agl_gmx_prtx_cfg_t agl_gmx_prtx;
+            cvmx_dprintf("ERROR: cvmx_mgmt_port_receive: Receive error code %d. Packet dropped(Len %d), \n",
+                         state->rx_ring[state->rx_read_index].s.code, state->rx_ring[state->rx_read_index].s.len + result);
+            result = -state->rx_ring[state->rx_read_index].s.code;
+
+
+            /* Check to see if we need to change the duplex. */
+            agl_gmx_prtx.u64 = cvmx_read_csr(CVMX_AGL_GMX_PRTX_CFG(port));
+            if (cvmx_mgmt_port_get_link(port) < 0)
+                agl_gmx_prtx.s.duplex = 0;
+            else
+                agl_gmx_prtx.s.duplex = 1;
+            cvmx_write_csr(CVMX_AGL_GMX_PRTX_CFG(port), agl_gmx_prtx.u64);
+        }
+
 		/* Clean out the ring buffer entry */
 		state->rx_ring[state->rx_read_index].s.code = 0;
 		state->rx_ring[state->rx_read_index].s.len =
-		    CVMX_MGMT_PORT_BUFFER_SIZE;
+		     CVMX_MGMT_PORT_RX_BUFFER_SIZE - 8;
 		state->rx_read_index =
 		    (state->rx_read_index + 1) % CVMX_MGMT_PORT_NUM_RX_BUFFERS;
-		/* Decrement the pending RX count */
+		/* Zero the beginning of the buffer for use by the errata check */
+		*zero_check = 0;
 		CVMX_SYNCWS;
-		cvmx_write_csr(CVMX_MIXX_IRCNT(port), 1);
 		/* Increment the number of RX buffers */
 		cvmx_write_csr(CVMX_MIXX_IRING2(port), 1);
+		/* Decrement the pending RX count */
+		cvmx_write_csr(CVMX_MIXX_IRCNT(port), 1);
 	} else {
 		/* No packets available */
 		result = 0;
@@ -674,3 +722,28 @@ void cvmx_mgmt_port_set_multicast_list(int port, int flags)
 
 	cvmx_spinlock_unlock(&state->lock);
 }
+
+/**
+ * Set the maximum packet allowed in. Size is specified
+ * including L2 but without FCS. A normal MTU would corespond
+ * to 1514 assuming the standard 14 byte L2 header.
+ *
+ * @param port   Management port
+ * @param size_without_fcs
+ *               Size in bytes without FCS
+ */
+void cvmx_mgmt_port_set_max_packet_size(int port, int size_without_fcs)
+{
+	cvmx_mgmt_port_state_t *state;
+
+	if ((port < 0) || (port >= __cvmx_mgmt_port_num_ports()))
+		return;
+
+	state = cvmx_mgmt_port_state_ptr + port;
+
+	cvmx_spinlock_lock(&state->lock);
+	cvmx_write_csr(CVMX_AGL_GMX_RXX_FRM_MAX(port), size_without_fcs);
+	cvmx_write_csr(CVMX_AGL_GMX_RXX_JABBER(port), (size_without_fcs+7) & 0xfff8);
+	cvmx_spinlock_unlock(&state->lock);
+}
+
diff --git a/arch/mips/cavium-octeon/executive/cvmx-mgmt-port.h b/arch/mips/cavium-octeon/executive/cvmx-mgmt-port.h
index e4406c8..c69a14e 100644
--- a/arch/mips/cavium-octeon/executive/cvmx-mgmt-port.h
+++ b/arch/mips/cavium-octeon/executive/cvmx-mgmt-port.h
@@ -173,4 +173,16 @@ extern uint64_t cvmx_mgmt_port_get_mac(int port);
  * @return
  */
 extern void cvmx_mgmt_port_set_multicast_list(int port, int flags);
+
+/**
+ * Set the maximum packet allowed in. Size is specified
+ * including L2 but without FCS. A normal MTU would corespond
+ * to 1514 assuming the standard 14 byte L2 header.
+ *
+ * @param port   Management port
+ * @param size_without_crc
+ *               Size in bytes without FCS
+ */
+extern void cvmx_mgmt_port_set_max_packet_size(int port, int size_without_fcs);
+
 #endif /* __CVMX_MGMT_PORT_H__ */
-- 
1.6.0.4

