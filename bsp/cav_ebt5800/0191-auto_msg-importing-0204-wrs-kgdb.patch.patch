From 30e565d539d90dedac96b25e8609cadb79a64969 Mon Sep 17 00:00:00 2001
From: auto commit <unknown@unknown>
Date: Fri, 24 Oct 2008 12:23:19 -0700
Subject: [PATCH] auto_msg: importing 0204-wrs-kgdb.patch

This is an automatic import of patch 0204-wrs-kgdb.patch, no headers were
detected and a default message was constructed
---
 arch/mips/cavium-octeon/serial.c |   57 +++++++++++++++++++++++--------------
 arch/mips/cavium-octeon/setup.c  |   22 +++++++++-----
 drivers/serial/8250_kgdb.c       |   21 ++++++++++++++
 3 files changed, 70 insertions(+), 30 deletions(-)

diff --git a/arch/mips/cavium-octeon/serial.c b/arch/mips/cavium-octeon/serial.c
index 5671d9e..044337c 100644
--- a/arch/mips/cavium-octeon/serial.c
+++ b/arch/mips/cavium-octeon/serial.c
@@ -12,14 +12,23 @@
 #include <linux/serial_8250.h>
 #include "hal.h"
 
+#if defined(CONFIG_CAVIUM_GDB)
+static int cavium_gdb_active = 0;
+
+static int __init opt_cavium_gdb(void)
+{
+	cavium_gdb_active = 1;
+	return 0;
+}
+
+early_param("cavium_gdb", opt_cavium_gdb);
+
 #ifdef CONFIG_GDB_CONSOLE
 #define DEBUG_UART 0
 #else
 #define DEBUG_UART 1
 #endif
 
-#ifdef CONFIG_KGDB
-
 extern void breakpoint(void);
 
 char getDebugChar(void)
@@ -52,21 +61,11 @@ void putDebugChar(char ch)
 	cvmx_write_csr(CVMX_MIO_UARTX_THR(DEBUG_UART), ch);
 }
 
-#endif
-
-#if defined(CONFIG_KGDB) || defined(CONFIG_CAVIUM_GDB)
-
 static irqreturn_t interruptDebugChar(int cpl, void *dev_id)
 {
 	unsigned long lsrval;
 	lsrval = cvmx_read_csr(CVMX_MIO_UARTX_LSR(1));
 	if (lsrval & 1) {
-#ifdef CONFIG_KGDB
-		struct pt_regs *regs = get_irq_regs();
-
-		putDebugChar(getDebugChar());
-		set_async_breakpoint(&regs->cp0_epc);
-#else
 		unsigned long tmp;
 		/* Pulse MCD0 signal on Ctrl-C to stop all the cores. Also set
 		   the MCD0 to be not masked by this core so we know the signal
@@ -76,7 +75,6 @@ static irqreturn_t interruptDebugChar(int cpl, void *dev_id)
 			      "ori   %0, %0, 0x10\n"
 			      "dmtc0 %0, $22\n" : "=r" (tmp));
 		octeon_write_lcd("");
-#endif
 		return IRQ_HANDLED;
 	}
 	return IRQ_NONE;
@@ -108,9 +106,18 @@ static int octeon_serial_init(void)
 	*/
 #endif
 
-#if defined(CONFIG_KGDB) || defined(CONFIG_CAVIUM_GDB)
-	/* As a special case disable uart1 if KGDB is in use */
-	enable_uart1 = 0;
+	/* The second port isn't enabled by default because a simple
+	   exec application might be running on another core. Linux control
+	   of the second uart breaks the simple exec debugger interface
+	   through the second uart. */
+
+#if defined(CONFIG_CAVIUM_GDB)
+	/* As a special case forcibly disable uart1 if cavium gdb is in use */
+
+	/* cavium_gdb_active is true if 'cavium_gdb' was detected on
+	   kernel command line */
+	if (cavium_gdb_active)
+		enable_uart1 = 0;
 #endif
 
 	/* Right now CN52XX is the only chip with a third uart */
@@ -153,13 +160,19 @@ static int octeon_serial_init(void)
 		octeon_port.irq = OCTEON_IRQ_UART2;
 		serial8250_register_port(&octeon_port);
 	}
-#if defined(CONFIG_KGDB) || defined(CONFIG_CAVIUM_GDB)
-	request_irq(OCTEON_IRQ_UART0 + DEBUG_UART, interruptDebugChar,
-		    IRQF_SHARED, "KGDB", interruptDebugChar);
 
-	/* Enable uart1 interrupts for debugger Control-C processing */
-	cvmx_write_csr(CVMX_MIO_UARTX_IER(DEBUG_UART),
-		       cvmx_read_csr(CVMX_MIO_UARTX_IER(DEBUG_UART)) | 1);
+#if defined(CONFIG_CAVIUM_GDB)
+
+	/* cavium_gdb_active is true if 'cavium_gdb' was detected on
+	   kernel command line */
+	if (cavium_gdb_active) {
+		request_irq(OCTEON_IRQ_UART0 + DEBUG_UART, interruptDebugChar,
+			IRQF_SHARED, "GDB", interruptDebugChar);
+		
+		/* Enable uart1 interrupts for debugger Control-C processing */
+		cvmx_write_csr(CVMX_MIO_UARTX_IER(DEBUG_UART),
+			cvmx_read_csr(CVMX_MIO_UARTX_IER(DEBUG_UART)) | 1);
+	}
 #endif
 	return 0;
 }
diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index 6d27bfa..23abf6a 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -277,17 +277,23 @@ void __init prom_init(void)
 							   interrupt */
 		octeon_port.irq = 42 + octeon_uart;
 	early_serial_setup(&octeon_port);
+/* 
+ *  If KGDB is enabled we need second UART 
+ *  to be functional as early as possible
+ */
+#ifdef CONFIG_KGDB 
+	octeon_uart = !octeon_uart;
+	octeon_port.mapbase = 0x0001180000000800ull + (1024 * octeon_uart);
+	octeon_port.membase = cvmx_phys_to_ptr(octeon_port.mapbase);
+	octeon_port.line = octeon_uart;
+	early_serial_setup(&octeon_port);
+#ifdef CONFIG_KGDB_8250_NOMODULE
+	kgdb8250_add_port(octeon_uart, &octeon_port);
+#endif
+#endif 
 
 	octeon_user_io_init();
 	register_smp_ops(&octeon_smp_ops);
-
-#ifdef CONFIG_KGDB
-	{
-		const char *s = "\r\nConnect GDB to this port\r\n";
-		while (*s)
-			putDebugChar(*s++);
-	}
-#endif
 }
 
 
diff --git a/drivers/serial/8250_kgdb.c b/drivers/serial/8250_kgdb.c
index 84d8d33..d2d6553 100644
--- a/drivers/serial/8250_kgdb.c
+++ b/drivers/serial/8250_kgdb.c
@@ -71,9 +71,29 @@ int __weak kgdb8250_early_debug_ready(void)
 }
 #endif
 
+#ifdef CONFIG_CPU_CAVIUM_OCTEON
+static inline void octeon_write_csr(uint64_t csr_addr, uint64_t val)
+{
+	*(volatile uint64_t *)csr_addr = val;
+}
+
+static inline uint64_t octeon_read_csr(uint64_t csr_addr)
+{
+	return *(volatile uint64_t *)csr_addr;
+}
 
 static inline unsigned int kgdb8250_ioread(u8 mask)
 {
+	return octeon_read_csr(kgdb8250_addr + (mask << kgdb8250_port.regshift));
+}
+
+static inline void kgdb8250_iowrite(u8 val, u8 mask)
+{
+	octeon_write_csr(kgdb8250_addr + (mask << kgdb8250_port.regshift) , val);
+}
+#else
+static inline unsigned int kgdb8250_ioread(u8 mask)
+{
 	return ioread8(kgdb8250_addr + (mask << kgdb8250_port.regshift));
 }
 
@@ -81,6 +101,7 @@ static inline void kgdb8250_iowrite(u8 val, u8 mask)
 {
 	iowrite8(val, kgdb8250_addr + (mask << kgdb8250_port.regshift));
 }
+#endif
 
 /*
  * Wait until the interface can accept a char, then write it.
-- 
1.6.0.3

