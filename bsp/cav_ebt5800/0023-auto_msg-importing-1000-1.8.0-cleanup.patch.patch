From f7d355a63ee64d73ba229fbfa2ebb7c7d2906bd2 Mon Sep 17 00:00:00 2001
From: auto commit <unknown@unknown>
Date: Fri, 24 Oct 2008 12:22:38 -0700
Subject: [PATCH] auto_msg: importing 1000-1.8.0-cleanup.patch

This is an automatic import of patch 1000-1.8.0-cleanup.patch, no headers were
detected and a default message was constructed
---
 arch/mips/cavium-octeon/dma-octeon.c               |   35 ++--
 arch/mips/cavium-octeon/hal.c                      |   44 ++--
 arch/mips/cavium-octeon/hal.h                      |   42 ++--
 arch/mips/cavium-octeon/i8259.c                    |   96 ++++----
 arch/mips/cavium-octeon/irq.c                      |   14 +-
 arch/mips/cavium-octeon/octeon_info.c              |    9 +-
 arch/mips/cavium-octeon/perf_counters.c            |   42 ++--
 arch/mips/cavium-octeon/serial.c                   |    9 +-
 arch/mips/cavium-octeon/setup.c                    |   30 ++-
 arch/mips/cavium-octeon/smp.c                      |   17 +-
 arch/mips/cavium-octeon/userio.c                   |    8 +-
 arch/mips/mm/c-octeon.c                            |  232 ++++++++++----------
 arch/mips/mm/pg-octeon.c                           |  176 ++++++++--------
 .../mach-cavium-octeon/cpu-feature-overrides.h     |    6 +-
 .../mach-cavium-octeon/kernel-entry-init.h         |    8 +-
 15 files changed, 388 insertions(+), 380 deletions(-)

diff --git a/arch/mips/cavium-octeon/dma-octeon.c b/arch/mips/cavium-octeon/dma-octeon.c
index 27fefc3..eec62d7 100644
--- a/arch/mips/cavium-octeon/dma-octeon.c
+++ b/arch/mips/cavium-octeon/dma-octeon.c
@@ -19,35 +19,34 @@
 #include <linux/platform_device.h>
 #include <linux/scatterlist.h>
 
-#include <asm/cache.h>
-#include <asm/io.h>
-#include <asm/ip32/crime.h>
+#include <linux/cache.h>
+#include <linux/io.h>
 
 #include "hal.h"
 #include "pci-common.h"
 
 #define BAR2_PCI_ADDRESS 0x8000000000ul
 
-typedef struct {
+struct bar1_index_state {
 	int16_t ref_count;	/* Number of PCI mappings using this index */
 	int16_t address_bits;	/* Upper bits of physical address. This is
 				   shifted 22 bits */
-} bar1_index_state_t;
+};
 
 #ifdef CONFIG_PCI
-static spinlock_t bar1_lock = SPIN_LOCK_UNLOCKED;
-static bar1_index_state_t bar1_state[32] = { {0, 0}, };
+static DEFINE_SPINLOCK(bar1_lock);
+static struct bar1_index_state bar1_state[32] = { {0, 0}, };
 #endif
 
 void *dma_alloc_noncoherent(struct device *dev, size_t size,
-			    dma_addr_t * dma_handle, unsigned int __nocast gfp)
+			    dma_addr_t *dma_handle, unsigned int __nocast gfp)
 	__attribute__ ((alias("dma_alloc_coherent")));
 
 EXPORT_SYMBOL(dma_alloc_noncoherent);
 
 
 void *dma_alloc_coherent(struct device *dev, size_t size,
-			 dma_addr_t * dma_handle, unsigned int __nocast gfp)
+			 dma_addr_t *dma_handle, unsigned int __nocast gfp)
 {
 	void *ret;
 	/* Ignore region specifiers. The Octeon Bar1 register can be used to
@@ -131,16 +130,16 @@ dma_addr_t dma_map_single(struct device *dev, void *ptr, size_t size,
 			panic("dma_map_single: Attempt to map illegal memory address 0x%lx\n", physical);
 		else if (physical >= 0x420000000ull)
 			panic("dma_map_single: Attempt to map illegal memory address 0x%lx\n", physical);
-                else if ((physical + size >= (4ull<<30) - (OCTEON_PCI_BAR1_HOLE_SIZE<<20)) &&
-                         physical < (4ull<<30))
-                    printk("dma_map_single: Warning: Maping memory address that might conflict with devices 0x%lx-0x%lx\n", physical, physical+size-1);
+		else if ((physical + size >= (4ull<<30) - (OCTEON_PCI_BAR1_HOLE_SIZE<<20)) &&
+			 physical < (4ull<<30))
+			printk("dma_map_single: Warning: Maping memory address that might conflict with devices 0x%lx-0x%lx\n", physical, physical+size-1);
 		/* The 2nd 256MB is mapped at 256<<20 instead of 0x410000000 */
 		if ((physical >= 0x410000000ull) && physical < 0x420000000ull)
 			result = physical - 0x400000000ull;
 		else
 			result = physical;
-                if (((result+size-1) & dma_mask) != result+size-1)
-                    panic("dma_map_single: Attempt to map address 0x%lx-0x%lx, which can't be accessed according to the dma mask 0x%lx\n", physical, physical+size-1, dma_mask);
+		if (((result+size-1) & dma_mask) != result+size-1)
+			panic("dma_map_single: Attempt to map address 0x%lx-0x%lx, which can't be accessed according to the dma mask 0x%lx\n", physical, physical+size-1, dma_mask);
 		goto done;
 
 	case OCTEON_DMA_BAR_TYPE_BIG:
@@ -270,7 +269,7 @@ dma_addr_t dma_map_single(struct device *dev, void *ptr, size_t size,
       done_unlock:
 	spin_unlock_irqrestore(&bar1_lock, flags);
       done:
-	// printk("dma_map_single 0x%lx->0x%lx\n", physical, result);
+	/* printk("dma_map_single 0x%lx->0x%lx\n", physical, result); */
 	return result;
 #endif
 }
@@ -352,7 +351,7 @@ void dma_unmap_single(struct device *dev, dma_addr_t dma_addr, size_t size,
 		      (int) index);
 	spin_unlock_irqrestore(&bar1_lock, flags);
       done:
-	// printk("dma_unmap_single 0x%lx\n", dma_addr);
+	/* printk("dma_unmap_single 0x%lx\n", dma_addr); */
 	return;
 #endif
 }
@@ -375,7 +374,7 @@ int dma_map_sg(struct device *dev, struct scatterlist *sg, int nents,
 EXPORT_SYMBOL(dma_map_sg);
 
 
-dma_addr_t dma_map_page(struct device * dev, struct page * page,
+dma_addr_t dma_map_page(struct device *dev, struct page *page,
 			unsigned long offset, size_t size,
 			enum dma_data_direction direction)
 {
@@ -464,7 +463,7 @@ EXPORT_SYMBOL(dma_sync_sg_for_device);
 
 int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
 {
-	return (dma_addr == -1);
+	return dma_addr == -1;
 }
 
 EXPORT_SYMBOL(dma_mapping_error);
diff --git a/arch/mips/cavium-octeon/hal.c b/arch/mips/cavium-octeon/hal.c
index 1d0080f..a87dcca 100644
--- a/arch/mips/cavium-octeon/hal.c
+++ b/arch/mips/cavium-octeon/hal.c
@@ -23,6 +23,13 @@
 #include "cvmx-l2c.h"
 #include "cvmx-spinlock.h"
 
+extern void add_wired_entry(unsigned long entrylo0,
+			    unsigned long entrylo1,
+			    unsigned long entryhi,
+			    unsigned long pagemask);
+extern asmlinkage void handle_int(void);
+extern asmlinkage void plat_irq_dispatch(void);
+
 /* Set to non-zero, so it is not in .bss section and is not zeroed */
 volatile octeon_boot_descriptor_t *octeon_boot_desc_ptr = (void *) 0xEADBEEFULL;
 cvmx_bootinfo_t *octeon_bootinfo;
@@ -31,7 +38,7 @@ cvmx_bootinfo_t *octeon_bootinfo;
 spinlock_t octeon_led_lock;
 
 #if CONFIG_CAVIUM_RESERVE32
-uint64_t octeon_reserve32_memory = 0;
+uint64_t octeon_reserve32_memory;
 #endif
 
 
@@ -90,13 +97,13 @@ void octeon_check_cpu_bist(void)
 
 
 /**
- * Return non zero of we are currently running in the Octeon simulator
+ * Return non zero if we are currently running in the Octeon simulator
  *
  * @return
  */
 int octeon_is_simulation(void)
 {
-	return (octeon_bootinfo->board_type == CVMX_BOARD_TYPE_SIM);
+	return octeon_bootinfo->board_type == CVMX_BOARD_TYPE_SIM;
 }
 
 
@@ -109,8 +116,7 @@ int octeon_is_simulation(void)
 int octeon_is_pci_host(void)
 {
 #ifdef CONFIG_PCI
-	return (octeon_bootinfo->
-		config_flags & CVMX_BOOTINFO_CFG_FLAG_PCI_HOST);
+	return octeon_bootinfo->config_flags & CVMX_BOOTINFO_CFG_FLAG_PCI_HOST;
 #else
 	return 0;
 #endif
@@ -192,10 +198,9 @@ const char *octeon_get_pci_interrupts(void)
 	   MB = (D + I) MOD 4 MB = System board Interrupt (IRQW = 0, IRQX = 1,
 	   IRQY = 2, and IRQZ = 3) D = Device Number I = Interrupt Number
 	   (INTA# = 0, INTB# = 1, INTC# = 2, and INTD# = 3) */
-	switch (octeon_bootinfo->board_type) {	/* Device ID
-		   1111111111222222222233 *//* 01234567890123456789012345678901 */
-		// case CVMX_BOARD_TYPE_NAO38: return
-		// "AAAAAADBAAAAAAAAAAAAAAAAAAAAAAAA";
+	switch (octeon_bootinfo->board_type) {
+	/* Device ID              1111111111222222222233 */
+	/*              01234567890123456789012345678901 */
 	case CVMX_BOARD_TYPE_NAO38:
 		return "AAAAADABAAAAAAAAAAAAAAAAAAAAAAAA";	/* This is
 								   really the
@@ -208,8 +213,8 @@ const char *octeon_get_pci_interrupts(void)
 	case CVMX_BOARD_TYPE_CN3010_EVB_HS5:
 	case CVMX_BOARD_TYPE_CN3005_EVB_HS5:
 		return "AAABAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
-        case CVMX_BOARD_TYPE_BBGW_REF:
-            return "AABCD";
+	case CVMX_BOARD_TYPE_BBGW_REF:
+		return "AABCD";
 	default:
 		return "";
 	}
@@ -357,8 +362,6 @@ void octeon_hal_init(void)
 	if (cvmx_read_csr(CVMX_L2D_FUS3) & (3ull << 34)) {
 		printk("Skipping L2 locking due to reduced L2 cache size\n");
 	} else {
-		extern asmlinkage void handle_int(void);
-		extern asmlinkage void plat_irq_dispatch(void);
 		uint32_t ebase = read_c0_ebase() & 0x3ffff000;
 #ifdef CONFIG_CAVIUM_OCTEON_LOCK_L2_TLB
 		cvmx_l2c_lock_mem_region(ebase, 0x100);	/* TLB refill */
@@ -422,18 +425,16 @@ static void octeon_hal_setup_per_cpu_reserved32(void *unused)
 	   userspace applications. We need to put a wired TLB entry in for each
 	   512MB of reserve32 memory. We only handle double 256MB pages here,
 	   so reserve32 must be multiple of 512MB */
-	extern void add_wired_entry(unsigned long entrylo0,
-				    unsigned long entrylo1,
-				    unsigned long entryhi,
-				    unsigned long pagemask);
 	uint32_t size = CONFIG_CAVIUM_RESERVE32;
 	uint32_t entrylo0 =
 		0x7 | ((octeon_reserve32_memory & ((1ul << 40) - 1)) >> 6);
 	uint32_t entrylo1 = entrylo0 + (256 << 14);
 	uint32_t entryhi = (0x80000000UL - (CONFIG_CAVIUM_RESERVE32 << 20));
 	while (size >= 512) {
-		// printk("CPU%d: Adding double wired TLB entry for 0x%lx\n",
-		// smp_processor_id(), entryhi);
+		/*
+		printk("CPU%d: Adding double wired TLB entry for 0x%lx\n",
+		       smp_processor_id(), entryhi);
+		*/
 		add_wired_entry(entrylo0, entrylo1, entryhi, PM_256M);
 		entrylo0 += 512 << 14;
 		entrylo1 += 512 << 14;
@@ -497,8 +498,7 @@ unsigned long octeon_crypto_enable(struct octeon_cop2_state *state)
 	local_irq_save(flags);
 	status = read_c0_status();
 	write_c0_status(status | ST0_CU2);
-	if (KSTK_STATUS(current) & ST0_CU2)
-	{
+	if (KSTK_STATUS(current) & ST0_CU2) {
 		octeon_cop2_save(&(current->thread.cp2));
 		KSTK_STATUS(current) &= ~ST0_CU2;
 		status &= ~ST0_CU2;
@@ -527,7 +527,7 @@ void octeon_crypto_disable(struct octeon_cop2_state *state, unsigned long crypto
 	if (crypto_flags & ST0_CU2)
 		octeon_cop2_restore(state);
 	else
-                write_c0_status(read_c0_status() & ~ST0_CU2);
+		write_c0_status(read_c0_status() & ~ST0_CU2);
 	local_irq_restore(flags);
 }
 EXPORT_SYMBOL(octeon_crypto_disable);
diff --git a/arch/mips/cavium-octeon/hal.h b/arch/mips/cavium-octeon/hal.h
index 5b04d94..85021d9 100644
--- a/arch/mips/cavium-octeon/hal.h
+++ b/arch/mips/cavium-octeon/hal.h
@@ -63,42 +63,42 @@ typedef union {
 		uint64_t wbfbist:1;	    /**< RO 1 = BIST fail, 0 = BIST pass */
 		uint64_t reserved:22;	    /**< Reserved */
 		uint64_t dismarkwblongto:1; /**< R/W If set, marked write-buffer entries time out the same as
-                                                as other entries; if clear, marked write-buffer entries use the
-                                                maximum timeout. */
+						as other entries; if clear, marked write-buffer entries use the
+						maximum timeout. */
 		uint64_t dismrgclrwbto:1;   /**< R/W If set, a merged store does not clear the write-buffer entry
-                                                timeout state. */
+						timeout state. */
 		uint64_t iobdmascrmsb:2;    /**< R/W Two bits that are the MSBs of the resultant CVMSEG LM word
-                                                location for an IOBDMA. The other 8 bits come from the SCRADDR
-                                                field of the IOBDMA. */
+						location for an IOBDMA. The other 8 bits come from the SCRADDR
+						field of the IOBDMA. */
 		uint64_t syncwsmarked:1;    /**< R/W If set, SYNCWS and SYNCS only order marked stores; if clear,
-                                                SYNCWS and SYNCS only order unmarked stores. SYNCWSMARKED has no
-                                                effect when DISSYNCWS is set. */
+						SYNCWS and SYNCS only order unmarked stores. SYNCWSMARKED has no
+						effect when DISSYNCWS is set. */
 		uint64_t dissyncws:1;	    /**< R/W If set, SYNCWS acts as SYNCW and SYNCS acts as SYNC. */
 		uint64_t diswbfst:1;	    /**< R/W If set, no stall happens on write buffer full. */
 		uint64_t xkmemenas:1;	    /**< R/W If set (and SX set), supervisor-level loads/stores can use
-                                                XKPHYS addresses with VA<48>==0 */
+						XKPHYS addresses with VA<48>==0 */
 		uint64_t xkmemenau:1;	    /**< R/W If set (and UX set), user-level loads/stores can use XKPHYS
-                                                addresses with VA<48>==0 */
+						addresses with VA<48>==0 */
 		uint64_t xkioenas:1;	    /**< R/W If set (and SX set), supervisor-level loads/stores can use
-                                                XKPHYS addresses with VA<48>==1 */
+						XKPHYS addresses with VA<48>==1 */
 		uint64_t xkioenau:1;	    /**< R/W If set (and UX set), user-level loads/stores can use XKPHYS
-                                                addresses with VA<48>==1 */
+						addresses with VA<48>==1 */
 		uint64_t allsyncw:1;	    /**< R/W If set, all stores act as SYNCW (NOMERGE must be set when
-                                                this is set) RW, reset to 0. */
+						this is set) RW, reset to 0. */
 		uint64_t nomerge:1;	    /**< R/W If set, no stores merge, and all stores reach the coherent
-                                                bus in order. */
+						bus in order. */
 		uint64_t didtto:2;	    /**< R/W Selects the bit in the counter used for DID time-outs
-                                                0 = 231, 1 = 230, 2 = 229, 3 = 214. Actual time-out is between
-                                                1� and 2� this interval. For example, with DIDTTO=3, expiration
-                                                interval is between 16K and 32K. */
+						0 = 231, 1 = 230, 2 = 229, 3 = 214. Actual time-out is between
+						1� and 2� this interval. For example, with DIDTTO=3, expiration
+						interval is between 16K and 32K. */
 		uint64_t csrckalwys:1;	    /**< R/W If set, the (mem) CSR clock never turns off. */
 		uint64_t mclkalwys:1;	    /**< R/W If set, mclk never turns off. */
 		uint64_t wbfltime:3;	    /**< R/W Selects the bit in the counter used for write buffer flush
-                                                time-outs (WBFLT+11) is the bit position in an internal counter
-                                                used to determine expiration. The write buffer expires between
-                                                1� and 2� this interval. For example, with WBFLT = 0, a write
-                                                buffer expires between 2K and 4K cycles after the write buffer
-                                                entry is allocated. */
+						time-outs (WBFLT+11) is the bit position in an internal counter
+						used to determine expiration. The write buffer expires between
+						1� and 2� this interval. For example, with WBFLT = 0, a write
+						buffer expires between 2K and 4K cycles after the write buffer
+						entry is allocated. */
 		uint64_t istrnol2:1;	    /**< R/W If set, do not put Istream in the L2 cache. */
 		uint64_t wbthresh:4;	    /**< R/W The write buffer threshold. */
 		uint64_t reserved2:2;	    /**< Reserved */
diff --git a/arch/mips/cavium-octeon/i8259.c b/arch/mips/cavium-octeon/i8259.c
index 842147f..8723975 100644
--- a/arch/mips/cavium-octeon/i8259.c
+++ b/arch/mips/cavium-octeon/i8259.c
@@ -16,13 +16,14 @@
 /* Initialization Command Word 1 (ICW1 address 0x20 or 0xa0) */
 /* 7:5 Interrupt Vector Addresses for MCS-80/85 Mode. */
 #define ICW1_ADDRESS    0x20
-#define ICW1            0x10	// 4 Must be set to 1 for ICW1
-#define ICW1_LEVEL_TRIG (1<<3)	// 3 1 Level Triggered Interrupts, 0 Edge
-				// Triggered Interrupts
-#define ICW1_INTERVAL4  (1<<2)	// 2 1 Call Address Interval of 4, 0 Call
-				// Address Interval of 8
-#define ICW1_SINGLE_PIC (1<<1)	// 1 1 Single PIC, 0 Cascaded PICs
-#define ICW1_NEED_ICW4  (1<<0)	// 0 1 Will be Sending ICW4, 0 Don't need ICW4
+#define ICW1            0x10	/* 4 Must be set to 1 for ICW1 */
+#define ICW1_LEVEL_TRIG (1<<3)	/* 3 1 Level Triggered Interrupts, 0 Edge
+				   Triggered Interrupts */
+#define ICW1_INTERVAL4  (1<<2)	/* 2 1 Call Address Interval of 4, 0 Call
+				   Address Interval of 8 */
+#define ICW1_SINGLE_PIC (1<<1)	/* 1 1 Single PIC, 0 Cascaded PICs */
+#define ICW1_NEED_ICW4  (1<<0)	/* 0 1 Will be Sending ICW4,
+				   0 Don't need ICW4 */
 
 /* Initialization Command Word 2 (ICW2 address 0x21 or 0xa1) */
 #define ICW2_ADDRESS    0x21
@@ -37,12 +38,12 @@
 /* Initialization Command Word 4 (ICW4 address 0x21 or 0xa1) */
 /* Bits 7-5 are reserved */
 #define ICW4_ADDRESS        0x21
-#define ICW4_FULLY_NESTED   (1<<4)	// 4 1 Special Fully Nested Mode, 0 Not
-					// Special Fully Nested Mode
-#define ICW4_BUFFERED       (3<<2)	// 3 1 Buffered Mode, 0 Unbuffered
-#define ICW4_MASTER         (2<<2)	// 2 1 Master, 0 Slave
-#define ICW4_AUTO_EOI       (1<<1)	// 1 1 Auto EOI, 0 Normal EOI
-#define ICW4_8086           (1<<0)	// 0 1 8086/8080 Mode, 0 MCS-80/85
+#define ICW4_FULLY_NESTED   (1<<4)	/* 4 1 Special Fully Nested Mode, 0 Not
+					   Special Fully Nested Mode */
+#define ICW4_BUFFERED       (3<<2)	/* 3 1 Buffered Mode, 0 Unbuffered */
+#define ICW4_MASTER         (2<<2)	/* 2 1 Master, 0 Slave */
+#define ICW4_AUTO_EOI       (1<<1)	/* 1 1 Auto EOI, 0 Normal EOI */
+#define ICW4_8086           (1<<0)	/* 0 1 8086/8080 Mode, 0 MCS-80/85 */
 
 /* Operation Control Word 1 (OCW1 address 0x21 or 0xa1) This is a bitmask for
    each interrupt */
@@ -50,34 +51,35 @@
 
 /* Operation Control Word 2 (OCW2 address 0x20 or 0xa0) */
 #define OCW2_ADDRESS    0x20
-#define OCW2            0x00	// Bits 4:3 must be zero
-#define OCW2_ROTATE_AUTO_EOI_CLEAR  (0<<5)	// 7:5 000 Rotate in Auto EOI
-						// Mode (Clear)
-#define OCW2_NON_SPECIFIC_EOI       (1<<5)	// 001 Non Specific EOI
-#define OCW2_NOP                    (2<<5)	// 010 NOP
-#define OCW2_SPECIFIC_EOI           (3<<5)	// 011 Specific EOI
-#define OCW2_ROTATE_AUTO_EOI_SET    (4<<5)	// 100 Rotate in Auto EOI Mode
-						// (Set)
-#define OCW2_ROTATE_NON_SPECIFIC_EOI (5<<5)	// 101 Rotate on Non-Specific
-						// EOI
-#define OCW2_SET_PRIORITY           (6<<5)	// 110 Set Priority Command
-						// (Use Bits 2:0)
-#define OCW2_ROTATE_SPECIFIC_EOI    (7<<5)	// 111 Rotate on Specific EOI
-						// (Use Bits 2:0)
+#define OCW2            0x00	/* Bits 4:3 must be zero */
+#define OCW2_ROTATE_AUTO_EOI_CLEAR  (0<<5)	/* 7:5 000 Rotate in Auto EOI
+						   Mode (Clear) */
+#define OCW2_NON_SPECIFIC_EOI       (1<<5)	/* 001 Non Specific EOI */
+#define OCW2_NOP                    (2<<5)	/* 010 NOP */
+#define OCW2_SPECIFIC_EOI           (3<<5)	/* 011 Specific EOI */
+#define OCW2_ROTATE_AUTO_EOI_SET    (4<<5)	/* 100 Rotate in Auto EOI Mode
+						   (Set) */
+#define OCW2_ROTATE_NON_SPECIFIC_EOI (5<<5)	/* 101 Rotate on Non-Specific
+						   EOI */
+#define OCW2_SET_PRIORITY           (6<<5)	/* 110 Set Priority Command
+						   (Use Bits 2:0) */
+#define OCW2_ROTATE_SPECIFIC_EOI    (7<<5)	/* 111 Rotate on Specific EOI
+						   (Use Bits 2:0) */
 
 /* Operation Control Word 3 (OCW3 address 0x20 or 0xa0) */
 /* Bit 7 Must be set to 0 */
 #define OCW3_ADDRESS    0x20
-#define OCW3            0x08	// 4:3 Must be set to 01
-#define OCW3_RESET_SPECIAL_MASK (2<<5)	// 6:5 00 Reserved, 01 Reserved, 10
-					// Reset Special Mask
-#define OCW3_SET_SPECIAL_MASK   (3<<5)	// 11 Set Special Mask
-#define OCW3_POLL               (1<<2)	// 2 1 Poll Command, 0 No Poll Command
-#define OCW3_READ_IRR           (2<<0)	// 1:0 00 Reserved, 01 Reserved, 10
-					// Next Read Returns Interrupt Request
-					// Register
-#define OCW3_READ_ISR           (3<<0)	// 11 Next Read Returns In-Service
-					// Register
+#define OCW3            0x08	/* 4:3 Must be set to 01 */
+#define OCW3_RESET_SPECIAL_MASK (2<<5)	/* 6:5 00 Reserved, 01 Reserved, 10
+					   Reset Special Mask */
+#define OCW3_SET_SPECIAL_MASK   (3<<5)	/* 11 Set Special Mask */
+#define OCW3_POLL               (1<<2)	/* 2 1 Poll Command,
+					   0 No Poll Command */
+#define OCW3_READ_IRR           (2<<0)	/* 1:0 00 Reserved, 01 Reserved, 10
+					   Next Read Returns Interrupt Request
+					   Register */
+#define OCW3_READ_ISR           (3<<0)	/* 11 Next Read Returns In-Service
+					   Register */
 
 
 static irqreturn_t octeon_i8259_interrupt(int cpl, void *dev_id)
@@ -95,9 +97,9 @@ static irqreturn_t octeon_i8259_interrupt(int cpl, void *dev_id)
 			if (slave_isr & 0x80) {	/* Top bit is set if the slave
 						   requested the interrupt */
 				int irq = (slave_isr & 7) + OCTEON_IRQ_I8259S0;
-
-				// printk("8259: Interrupt %d from slave\n",
-				// irq);
+				/*
+				printk("8259: Interrupt %d from slave\n", irq);
+				*/
 				if (irq_desc[irq].action)
 					do_IRQ(irq);
 
@@ -108,7 +110,9 @@ static irqreturn_t octeon_i8259_interrupt(int cpl, void *dev_id)
 				printk("8259: Spurious interrupt from master for slave\n");
 		} else {
 			int irq = (master_isr & 7) + OCTEON_IRQ_I8259M0;
-			// printk("8259: Interrupt %d from master\n", irq);
+			/*
+			printk("8259: Interrupt %d from master\n", irq);
+			*/
 			if (irq_desc[irq].action)
 				do_IRQ(irq);
 		}
@@ -125,8 +129,6 @@ static irqreturn_t octeon_i8259_interrupt(int cpl, void *dev_id)
 
 void octeon_i8259_setup(int irq_line)
 {
-	int r;
-
 	/* Setup the Master 8259 */
 	outb(ICW1 | ICW1_NEED_ICW4, ICW1_ADDRESS);	/* Begin the init
 							   sequence */
@@ -158,13 +160,13 @@ void octeon_i8259_setup(int irq_line)
 		printk("8259: Setting GPIO %d for the interrupt\n",
 		       irq_line - 24);
 		cvmx_write_csr(CVMX_GPIO_BIT_CFGX(irq_line - 24), 0x114);
-		if (request_irq(irq_line, octeon_i8259_interrupt, IRQF_SHARED, "8259",
-			    octeon_i8259_interrupt)) {
+		if (request_irq(irq_line, octeon_i8259_interrupt, IRQF_SHARED,
+				"8259", octeon_i8259_interrupt)) {
 		}
 	} else if ((irq_line >= 44) && (irq_line <= 47)) {
 		printk("8259: Using PCI INT-%c\n", irq_line - 44 + 'A');
-		if (request_irq(irq_line, octeon_i8259_interrupt, IRQF_SHARED, "8259",
-			    octeon_i8259_interrupt)) {
+		if (request_irq(irq_line, octeon_i8259_interrupt, IRQF_SHARED,
+				"8259", octeon_i8259_interrupt)) {
 		}
 	} else {
 		panic("8259: Don't know how to setup the interrupt IRQ %d\n",
diff --git a/arch/mips/cavium-octeon/irq.c b/arch/mips/cavium-octeon/irq.c
index 7b71b51..0e1f5e1 100644
--- a/arch/mips/cavium-octeon/irq.c
+++ b/arch/mips/cavium-octeon/irq.c
@@ -30,9 +30,10 @@ asmlinkage void plat_irq_dispatch(void)
 
 		if (unlikely(cop0_cause & STATUSF_IP2)) {
 			asm volatile ("ld	%[sum], 0(%[sum_address])\n"
-				      "ld	%[en], 0(%[en_address])\n":
-				      [sum] "=r"(ciu_sum),[en] "=r"(ciu_en)
-				      :[sum_address] "r"(ciu_sum0_address),
+				      "ld	%[en], 0(%[en_address])\n" :
+				      [sum] "=r"(ciu_sum),
+				      [en] "=r"(ciu_en) :
+				      [sum_address] "r"(ciu_sum0_address),
 				      [en_address] "r"(ciu_en0_address));
 			ciu_sum &= ciu_en;
 			if (likely(ciu_sum))
@@ -41,9 +42,10 @@ asmlinkage void plat_irq_dispatch(void)
 				spurious_interrupt();
 		} else if (unlikely(cop0_cause & STATUSF_IP3)) {
 			asm volatile ("ld	%[sum], 0(%[sum_address])\n"
-				      "ld	%[en], 0(%[en_address])\n":
-				      [sum] "=r"(ciu_sum),[en] "=r"(ciu_en)
-				      :[sum_address] "r"(ciu_sum1_address),
+				      "ld	%[en], 0(%[en_address])\n" :
+				      [sum] "=r"(ciu_sum),
+				      [en] "=r"(ciu_en) :
+				      [sum_address] "r"(ciu_sum1_address),
 				      [en_address] "r"(ciu_en1_address));
 			ciu_sum &= ciu_en;
 			if (likely(ciu_sum))
diff --git a/arch/mips/cavium-octeon/octeon_info.c b/arch/mips/cavium-octeon/octeon_info.c
index 301e1a0..80e24dc 100644
--- a/arch/mips/cavium-octeon/octeon_info.c
+++ b/arch/mips/cavium-octeon/octeon_info.c
@@ -15,6 +15,11 @@
 #include "hal.h"
 #include "cvmx-app-init.h"
 
+extern cvmx_bootinfo_t *octeon_bootinfo;
+#if defined(CONFIG_CAVIUM_RESERVE32) && CONFIG_CAVIUM_RESERVE32
+extern uint64_t octeon_reserve32_memory;
+#endif
+
 /**
  * User is reading /proc/octeon_info
  *
@@ -24,10 +29,6 @@
  */
 static int octeon_info_show(struct seq_file *m, void *v)
 {
-	extern cvmx_bootinfo_t *octeon_bootinfo;
-#if defined(CONFIG_CAVIUM_RESERVE32) && CONFIG_CAVIUM_RESERVE32
-	extern uint64_t octeon_reserve32_memory;
-#endif
 
 	seq_printf(m, "processor_id:        0x%x\n", read_c0_prid());
 	seq_printf(m, "boot_flags:          0x%x\n", octeon_bootinfo->flags);
diff --git a/arch/mips/cavium-octeon/perf_counters.c b/arch/mips/cavium-octeon/perf_counters.c
index 01229a2..1273544 100644
--- a/arch/mips/cavium-octeon/perf_counters.c
+++ b/arch/mips/cavium-octeon/perf_counters.c
@@ -12,14 +12,14 @@
 #include <linux/fs.h>
 #include <linux/seq_file.h>
 #include <linux/proc_fs.h>
-#include <asm/ioctl.h>
+#include <linux/ioctl.h>
 #include <asm/mach-cavium-octeon/perf_counters.h>
 #include "hal.h"
 
 /**
  * The types of counters supported per cpu
  */
-typedef enum {
+enum proc_perf_core {
 	PROC_PERF_CORE_NONE = 0,	/* Turn off the performance counter */
 	PROC_PERF_CORE_CLK = 1,	/* Conditionally clocked cycles (as opposed to
 				   count/cvm_count which count even with no
@@ -117,12 +117,12 @@ typedef enum {
 					   accurate counts) */
 	PROC_PERF_CORE_SYNCW = 58,	/* Number of SYNCWs */
 	PROC_PERF_CORE_MAX
-} proc_perf_core_t;
+};
 
 /**
  * The types of counters supported for L2
  */
-typedef enum {
+enum proc_perf_l2 {
 	PROC_PERF_L2_CYCLES,	/* Cycles */
 	PROC_PERF_L2_IMISS,	/* L2 Instruction Miss */
 	PROC_PERF_L2_IHIT,	/* L2 Instruction Hit */
@@ -183,7 +183,7 @@ typedef enum {
 	PROC_PERF_L2_DT_RD_ALLOC,	/* DT RD-ALLOC */
 	PROC_PERF_L2_DT_WR_INVA,	/* DT WR-INVA */
 	PROC_PERF_L2_MAX
-} proc_perf_l2_t;
+};
 
 /**
  * IO addresses for L2 registers
@@ -201,42 +201,42 @@ typedef enum {
 /**
  * Bit description of the core counters control register
  */
-typedef union {
+union proc_perf_core_control {
 	uint32_t u32;
 	struct {
 		uint32_t M:1;
 		uint32_t W:1;
 		uint32_t reserved:19;
-		proc_perf_core_t event:6;
+		enum proc_perf_core event:6;
 		uint32_t IE:1;
 		uint32_t U:1;
 		uint32_t S:1;
 		uint32_t K:1;
 		uint32_t EX:1;
 	} s;
-} proc_perf_core_control_t;
+};
 
 /**
  * Bit description of the L2 counters control register
  */
-typedef union {
+union proc_perf_l2_control {
 	uint64_t u64;
 	struct {
 		uint64_t reserved:32;
 		uint64_t cnt3ena:1;
 		uint64_t cnt3clr:1;
-		proc_perf_l2_t cnt3sel:6;
+		enum proc_perf_l2 cnt3sel:6;
 		uint64_t cnt2ena:1;
 		uint64_t cnt2clr:1;
-		proc_perf_l2_t cnt2sel:6;
+		enum proc_perf_l2 cnt2sel:6;
 		uint64_t cnt1ena:1;
 		uint64_t cnt1clr:1;
-		proc_perf_l2_t cnt1sel:6;
+		enum proc_perf_l2 cnt1sel:6;
 		uint64_t cnt0ena:1;
 		uint64_t cnt0clr:1;
-		proc_perf_l2_t cnt0sel:6;
+		enum proc_perf_l2 cnt0sel:6;
 	} s;
-} proc_perf_l2_control_t;
+};
 
 /**
  * Module parameters used to control the counters. Can be
@@ -265,7 +265,7 @@ static const char *proc_perf_label[PROC_PERF_CORE_MAX];
 static const char *proc_perf_l2label[PROC_PERF_L2_MAX];
 static uint64_t proc_perf_dram_clocks;
 static uint64_t proc_perf_dram_operations;
-static int proc_perf_in_use = 0;
+static int proc_perf_in_use;
 
 
 /**
@@ -275,7 +275,7 @@ static int proc_perf_in_use = 0;
  */
 static void proc_perf_setup_counters(void *arg)
 {
-	proc_perf_core_control_t control;
+	union proc_perf_core_control control;
 	uint64_t cvmctl;
 
 	if (proc_perf_in_use) {
@@ -338,7 +338,7 @@ static inline void clean_string(char *str, int len)
 static void proc_perf_setup(void)
 {
 	int i;
-	proc_perf_l2_control_t l2control;
+	union proc_perf_l2_control l2control;
 
 	proc_perf_counter_control[0] = 0;
 	proc_perf_counter_control[1] = 0;
@@ -431,8 +431,8 @@ static int proc_perf_show(struct seq_file *m, void *v)
 	int i;
 	uint64_t dram_clocks;
 	uint64_t dram_operations;
-	proc_perf_core_control_t control0;
-	proc_perf_core_control_t control1;
+	union proc_perf_core_control control0;
+	union proc_perf_core_control control1;
 
 	proc_perf_update();
 
@@ -533,7 +533,9 @@ static int proc_perf_open(struct inode *inode, struct file *file)
 static int proc_perf_ioctl(struct inode *inode, struct file *file,
 			   unsigned int cmd, unsigned long arg)
 {
-	// printk("proc_perf_ioctl(cmd=0x%x(%u), arg=0x%lx)\n", cmd, cmd, arg);
+	/*
+	printk("proc_perf_ioctl(cmd=0x%x(%u), arg=0x%lx)\n", cmd, cmd, arg);
+	*/
 	switch (cmd) {
 	case PROC_PERF_IOCTL_SETUP_COUNTER0:
 		if ((arg <= PROC_PERF_CORE_MAX) && proc_perf_label[arg]) {
diff --git a/arch/mips/cavium-octeon/serial.c b/arch/mips/cavium-octeon/serial.c
index 16a7a1f..fce02d5 100644
--- a/arch/mips/cavium-octeon/serial.c
+++ b/arch/mips/cavium-octeon/serial.c
@@ -47,8 +47,7 @@ void putDebugChar(char ch)
 	/* Spin until there is room */
 	do {
 		lsrval = cvmx_read_csr(CVMX_MIO_UARTX_LSR(DEBUG_UART));
-	}
-	while ((lsrval & 0x20) == 0);
+	} while ((lsrval & 0x20) == 0);
 
 	/* Write the byte */
 	cvmx_write_csr(CVMX_MIO_UARTX_THR(DEBUG_UART), ch);
@@ -76,7 +75,7 @@ static irqreturn_t interruptDebugChar(int cpl, void *dev_id)
 		octeon_write_lcd("brk");
 		asm volatile ("dmfc0 %0, $22\n"
 			      "ori   %0, %0, 0x10\n"
-			      "dmtc0 %0, $22\n":"=r" (tmp));
+			      "dmtc0 %0, $22\n" : "=r" (tmp));
 		octeon_write_lcd("");
 #endif
 		return IRQ_HANDLED;
@@ -105,7 +104,9 @@ static int octeon_serial_init(void)
 	enable_uart1 = (octeon_get_boot_uart() == 1);
 	/* Uncomment the following line if you'd like uart1 to be enable as
 	   well as uart 0 when the bootloader tells us to use uart0 */
-	// enable_uart1 = 1;
+	/*
+	enable_uart1 = 1;
+	*/
 #endif
 
 #if defined(CONFIG_KGDB) || defined(CONFIG_CAVIUM_GDB)
diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index 5d6cef9..52c6edd 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -16,7 +16,7 @@
 #include <linux/console.h>
 #include <linux/serial.h>
 #include <linux/tty.h>
-#include <asm/time.h>
+#include <linux/time.h>
 #include <linux/serial_core.h>
 #include <linux/serial_8250.h>
 #include <linux/string.h>
@@ -26,7 +26,7 @@
 #include <asm/time.h>
 #include <asm/processor.h>
 #include <asm/smp-ops.h>
-#include <asm/reboot.h>
+#include <linux/reboot.h>
 #include <asm/system.h>
 #include <asm/irq_cpu.h>
 #include <asm/mipsregs.h>
@@ -36,15 +36,29 @@
 #include "cvmx-l2c.h"
 #include "cvmx-bootmem.h"
 
+extern void cvmx_interrupt_rsl_decode(void);
+extern int __cvmx_interrupt_ecc_report_single_bit_errors;
+extern void cvmx_interrupt_rsl_enable(void);
+
 extern struct plat_smp_ops octeon_smp_ops;
 extern void octeon_user_io_init(void);
 extern void pci_console_init(const char *arg);
+
+extern void putDebugChar(char ch);
+
 #ifdef CONFIG_CAVIUM_OCTEON_BOOTBUS_COMPACT_FLASH
 extern void ebt3000_cf_enable_dma(void);
 #endif
+
+#if CONFIG_CAVIUM_RESERVE32
+extern uint64_t octeon_reserve32_memory;
+#endif
+extern asmlinkage void kernel_entry(void);
+
 static unsigned long long MAX_MEMORY = 512ull << 20;
 
 
+
 /**
  * Reboot Octeon
  *
@@ -115,7 +129,6 @@ void __init plat_time_init(void)
  */
 static irqreturn_t octeon_rlm_interrupt(int cpl, void *dev_id)
 {
-	extern void cvmx_interrupt_rsl_decode(void);
 	cvmx_interrupt_rsl_decode();
 	return IRQ_HANDLED;
 }
@@ -176,7 +189,7 @@ void __init prom_init(void)
 
 	/* BIST should always be enabled when doing a soft reset. L2 Cache
 	   locking for instance is not cleared unless BIST is enabled.
-	   Unfortunately due to a chip errata G-200 for Cn38XX and CN31XX, BIST 
+	   Unfortunately due to a chip errata G-200 for Cn38XX and CN31XX, BIST
 	   msut be disabled on these parts */
 	if (OCTEON_IS_MODEL(OCTEON_CN38XX_PASS2) ||
 	    OCTEON_IS_MODEL(OCTEON_CN31XX))
@@ -199,7 +212,6 @@ void __init prom_init(void)
 			if (MAX_MEMORY == 0)
 				MAX_MEMORY = 32ull << 30;
 		} else if (strcmp(arg, "ecc_verbose") == 0) {
-			extern int __cvmx_interrupt_ecc_report_single_bit_errors;
 			__cvmx_interrupt_ecc_report_single_bit_errors = 1;
 			printk("Reporting of single bit ECC errors is turned on\n");
 		} else if (strlen(arcs_cmdline) + strlen(arg) + 1 <
@@ -270,7 +282,6 @@ void __init prom_init(void)
 
 #ifdef CONFIG_KGDB
 	{
-		extern void putDebugChar(char ch);
 		const char *s = "\r\nConnect GDB to this port\r\n";
 		while (*s)
 			putDebugChar(*s++);
@@ -282,10 +293,6 @@ void __init prom_init(void)
 
 void __init plat_mem_setup(void)
 {
-#if CONFIG_CAVIUM_RESERVE32
-	extern uint64_t octeon_reserve32_memory;
-#endif
-	extern asmlinkage void kernel_entry(void);
 	uint64_t mem_alloc_size;
 	uint64_t total;
 
@@ -347,12 +354,11 @@ void __init plat_mem_setup(void)
 
 void prom_free_prom_memory(void)
 {
-	extern void cvmx_interrupt_rsl_enable(void);
 	cvmx_interrupt_rsl_enable();
 
 	/* Add an interrupt handler for general failures. */
 	if (request_irq(OCTEON_IRQ_RML, octeon_rlm_interrupt, IRQF_SHARED, "RML/RSL",
-		    octeon_rlm_interrupt)) {
+			octeon_rlm_interrupt)) {
 	}
 
 	/* This call is here so that it is performed after any TLB
diff --git a/arch/mips/cavium-octeon/smp.c b/arch/mips/cavium-octeon/smp.c
index 18b7004..b7b0eb4 100644
--- a/arch/mips/cavium-octeon/smp.c
+++ b/arch/mips/cavium-octeon/smp.c
@@ -12,7 +12,7 @@
 #include <linux/sched.h>
 #include <linux/module.h>
 #include <asm/mmu_context.h>
-#include <asm/time.h>
+#include <linux/time.h>
 #include <asm/system.h>
 
 #include "hal.h"
@@ -57,8 +57,10 @@ static irqreturn_t mailbox_interrupt(int irq, void *dev_id)
 static void octeon_send_ipi_single(int cpu, unsigned int action)
 {
 	int coreid = cpu_logical_map(cpu);
-	// printk("SMP: Mailbox send cpu=%d, coreid=%d, action=%u\n", cpu,
-	// coreid, action);
+	/*
+	printk("SMP: Mailbox send cpu=%d, coreid=%d, action=%u\n", cpu,
+	       coreid, action);
+	*/
 	cvmx_write_csr(CVMX_CIU_MBOX_SETX(coreid), action);
 }
 
@@ -142,8 +144,9 @@ static void octeon_init_secondary(void)
 
 	octeon_check_cpu_bist();
 
-	// printk("SMP: CPU%d (CoreId %lu) started\n", cpu, coreid);
-
+	/*
+	printk("SMP: CPU%d (CoreId %lu) started\n", cpu, coreid);
+	*/
 	/* Enable Mailbox interrupts to this core. These are the only
 	   interrupts allowed on line 3 */
 	cvmx_write_csr(CVMX_CIU_MBOX_CLRX(coreid), 0xffffffff);
@@ -187,7 +190,7 @@ static void octeon_smp_finish(void)
 	   to be not masked by this core so we know the signal is received by
 	   someone */
 	asm volatile ("dmfc0 %0, $22\n"
-		      "ori   %0, %0, 0x9100\n" "dmtc0 %0, $22\n":"=r" (tmp));
+		      "ori   %0, %0, 0x9100\n" "dmtc0 %0, $22\n" : "=r" (tmp));
 #endif
 
 #ifdef CONFIG_CAVIUM_OCTEON_USER_MEM
@@ -210,7 +213,7 @@ static void octeon_cpus_done(void)
 	   to be not masked by this core so we know the signal is received by
 	   someone */
 	asm volatile ("dmfc0 %0, $22\n"
-		      "ori   %0, %0, 0x9100\n" "dmtc0 %0, $22\n":"=r" (tmp));
+		      "ori   %0, %0, 0x9100\n" "dmtc0 %0, $22\n" : "=r" (tmp));
 #endif
 }
 
diff --git a/arch/mips/cavium-octeon/userio.c b/arch/mips/cavium-octeon/userio.c
index 4bd58e1..6e0ece7 100644
--- a/arch/mips/cavium-octeon/userio.c
+++ b/arch/mips/cavium-octeon/userio.c
@@ -15,14 +15,12 @@
 #include <linux/console.h>
 #include <linux/serial.h>
 #include <linux/tty.h>
-#include <asm/time.h>
+#include <linux/time.h>
 #include <linux/serial_core.h>
+#include <linux/reboot.h>
+#include <linux/io.h>
 
-#include <asm/reboot.h>
-#include <asm/io.h>
-#include <asm/time.h>
 #include <asm/processor.h>
-#include <asm/reboot.h>
 #include <asm/system.h>
 #include <asm/irq_cpu.h>
 #include <asm/mipsregs.h>
diff --git a/arch/mips/mm/c-octeon.c b/arch/mips/mm/c-octeon.c
index 5da2586..80c121e 100644
--- a/arch/mips/mm/c-octeon.c
+++ b/arch/mips/mm/c-octeon.c
@@ -10,13 +10,13 @@
 #include <linux/sched.h>
 #include <linux/mm.h>
 #include <linux/bitops.h>
+#include <linux/cpu.h>
+#include <linux/io.h>
 
 #include <asm/bcache.h>
 #include <asm/bootinfo.h>
 #include <asm/cacheops.h>
-#include <asm/cpu.h>
 #include <asm/cpu-features.h>
-#include <asm/io.h>
 #include <asm/page.h>
 #include <asm/pgtable.h>
 #include <asm/r4kcache.h>
@@ -51,38 +51,36 @@ static void octeon_flush_data_cache_page(unsigned long addr)
 static void octeon_flush_icache_all_cores(struct vm_area_struct *vma)
 {
 #ifdef CONFIG_SMP
-    int i;
-    int cpu;
+	int i;
+	int cpu;
 #endif
-    preempt_disable();
+	
+	preempt_disable();
 #ifdef CONFIG_SMP
-    cpu = smp_processor_id();
+	cpu = smp_processor_id();
 #endif
-    mb();
+	mb();
 
-    /* If we have a vma structure, we only need to worry about cores it
-        has been used on */
-    if (vma)
-    {
+	/* If we have a vma structure, we only need to worry about cores it
+	   has been used on */
+	if (vma) {
 #ifdef CONFIG_SMP
-        for (i = 0; i < NR_CPUS; i++)
-            if (cpu_isset(i, vma->vm_mm->cpu_vm_mask) && i != cpu)
-                mp_ops->send_ipi_single(i, SMP_ICACHE_FLUSH);
+		for (i = 0; i < NR_CPUS; i++)
+			if (cpu_isset(i, vma->vm_mm->cpu_vm_mask) && i != cpu)
+				mp_ops->send_ipi_single(i, SMP_ICACHE_FLUSH);
 #endif
-        asm volatile ("synci 0($0)\n");
-    }
-    else
-    {
-        /* No extra info available. Flush the icache on all cores that
-            are online */
+		asm volatile ("synci 0($0)\n");
+	} else {
+		/* No extra info available. Flush the icache on all cores that
+		   are online */
 #ifdef CONFIG_SMP
-        for (i = 0; i < NR_CPUS; i++)
-            if (cpu_online(i) && i != cpu)
-                mp_ops->send_ipi_single(i, SMP_ICACHE_FLUSH);
+		for (i = 0; i < NR_CPUS; i++)
+			if (cpu_online(i) && i != cpu)
+				mp_ops->send_ipi_single(i, SMP_ICACHE_FLUSH);
 #endif
-        asm volatile ("synci 0($0)\n");
-    }
-    preempt_enable();
+		asm volatile ("synci 0($0)\n");
+	}
+	preempt_enable();
 }
 
 
@@ -103,8 +101,8 @@ static void octeon_flush_icache_all(void)
  */
 static void octeon_flush_cache_mm(struct mm_struct *mm)
 {
-    /* According to the R4K version of this file, CPUs without
-        dcache aliases don't need to do anything here */
+	/* According to the R4K version of this file, CPUs without
+	   dcache aliases don't need to do anything here */
 }
 
 
@@ -128,9 +126,9 @@ static void octeon_flush_icache_range(unsigned long start, unsigned long end)
  */
 static void octeon_flush_cache_sigtramp(unsigned long addr)
 {
-    /* Only flush trampolines on the current core */
-    mb();
-    asm volatile ("synci 0(%0)\n":: "r" (addr));
+	/* Only flush trampolines on the current core */
+	mb();
+	asm volatile ("synci 0(%0)\n" : : "r" (addr));
 }
 
 
@@ -143,8 +141,8 @@ static void octeon_flush_cache_sigtramp(unsigned long addr)
  */
 static void octeon_flush_cache_range(struct vm_area_struct *vma, unsigned long start, unsigned long end)
 {
-    if (vma->vm_flags & (VM_EXEC|VM_EXECUTABLE))
-        octeon_flush_icache_all_cores(vma);
+	if (vma->vm_flags & (VM_EXEC|VM_EXECUTABLE))
+		octeon_flush_icache_all_cores(vma);
 }
 
 
@@ -157,8 +155,8 @@ static void octeon_flush_cache_range(struct vm_area_struct *vma, unsigned long s
  */
 static void octeon_flush_cache_page(struct vm_area_struct *vma, unsigned long page, unsigned long pfn)
 {
-    if (vma->vm_flags & (VM_EXEC|VM_EXECUTABLE))
-        octeon_flush_icache_all_cores(vma);
+	if (vma->vm_flags & (VM_EXEC|VM_EXECUTABLE))
+		octeon_flush_icache_all_cores(vma);
 }
 
 
@@ -169,54 +167,52 @@ static void octeon_flush_cache_page(struct vm_area_struct *vma, unsigned long pa
  */
 static void __init probe_octeon(void)
 {
-    unsigned long icache_size;
-    unsigned long dcache_size;
-    unsigned int config1;
-    struct cpuinfo_mips *c = &current_cpu_data;
-
-    switch (c->cputype)
-    {
-        case CPU_CAVIUM_OCTEON:
-            config1 = read_c0_config1();
-            c->icache.linesz = 2 << ((config1 >> 19) & 7);
-            c->icache.sets = 64 << ((config1 >> 22) & 7);
-            c->icache.ways = 1 + ((config1 >> 16) & 7);
-            c->icache.flags |= MIPS_CACHE_VTAG;
-            icache_size = c->icache.sets * c->icache.ways * c->icache.linesz;
-            c->icache.waybit = ffs(icache_size / c->icache.ways) - 1;
-            c->dcache.linesz = 128;
-            if (OCTEON_IS_MODEL(OCTEON_CN3XXX))
-                c->dcache.sets = 1; /* CN3XXX has one Dcache set */
-            else
-                c->dcache.sets = 2; /* CN5XXX has two Dcache sets */
-            c->dcache.ways = 64;
-            dcache_size = c->dcache.sets * c->dcache.ways * c->dcache.linesz;
-            c->dcache.waybit = ffs(dcache_size / c->dcache.ways) - 1;
-            c->options |= MIPS_CPU_PREFETCH;
-            break;
-
-        default:
-            panic("Unsupported Cavium Networks CPU type\n");
-            break;
-    }
-
-    /* compute a couple of other cache variables */
-    c->icache.waysize = icache_size / c->icache.ways;
-    c->dcache.waysize = dcache_size / c->dcache.ways;
-
-    c->icache.sets = icache_size / (c->icache.linesz * c->icache.ways);
-    c->dcache.sets = dcache_size / (c->dcache.linesz * c->dcache.ways);
-
-    if (smp_processor_id() == 0)
-    {
-        printk("Primary instruction cache %ldkB, %s, %d way, %d sets, linesize %d bytes.\n",
-               icache_size >> 10,
-               cpu_has_vtag_icache ? "virtually tagged" : "physically tagged",
-               c->icache.ways, c->icache.sets, c->icache.linesz);
-
-        printk("Primary data cache %ldkB, %d-way, %d sets, linesize %d bytes.\n",
-               dcache_size >> 10, c->dcache.ways, c->dcache.sets, c->dcache.linesz);
-    }
+	unsigned long icache_size;
+	unsigned long dcache_size;
+	unsigned int config1;
+	struct cpuinfo_mips *c = &current_cpu_data;
+
+	switch (c->cputype) {
+	case CPU_CAVIUM_OCTEON:
+		config1 = read_c0_config1();
+		c->icache.linesz = 2 << ((config1 >> 19) & 7);
+		c->icache.sets = 64 << ((config1 >> 22) & 7);
+		c->icache.ways = 1 + ((config1 >> 16) & 7);
+		c->icache.flags |= MIPS_CACHE_VTAG;
+		icache_size = c->icache.sets * c->icache.ways * c->icache.linesz;
+		c->icache.waybit = ffs(icache_size / c->icache.ways) - 1;
+		c->dcache.linesz = 128;
+		if (OCTEON_IS_MODEL(OCTEON_CN3XXX))
+			c->dcache.sets = 1; /* CN3XXX has one Dcache set */
+		else
+			c->dcache.sets = 2; /* CN5XXX has two Dcache sets */
+		c->dcache.ways = 64;
+		dcache_size = c->dcache.sets * c->dcache.ways * c->dcache.linesz;
+		c->dcache.waybit = ffs(dcache_size / c->dcache.ways) - 1;
+		c->options |= MIPS_CPU_PREFETCH;
+		break;
+
+	default:
+		panic("Unsupported Cavium Networks CPU type\n");
+		break;
+	}
+
+	/* compute a couple of other cache variables */
+	c->icache.waysize = icache_size / c->icache.ways;
+	c->dcache.waysize = dcache_size / c->dcache.ways;
+
+	c->icache.sets = icache_size / (c->icache.linesz * c->icache.ways);
+	c->dcache.sets = dcache_size / (c->dcache.linesz * c->dcache.ways);
+
+	if (smp_processor_id() == 0) {
+		printk("Primary instruction cache %ldkB, %s, %d way, %d sets, linesize %d bytes.\n",
+		icache_size >> 10,
+		cpu_has_vtag_icache ? "virtually tagged" : "physically tagged",
+		c->icache.ways, c->icache.sets, c->icache.linesz);
+
+		printk("Primary data cache %ldkB, %d-way, %d sets, linesize %d bytes.\n",
+		dcache_size >> 10, c->dcache.ways, c->dcache.sets, c->dcache.linesz);
+	}
 }
 
 
@@ -227,25 +223,25 @@ static void __init probe_octeon(void)
  */
 void __init octeon_cache_init(void)
 {
-    extern unsigned long ebase;
-    extern char except_vec2_octeon;
+	extern unsigned long ebase;
+	extern char except_vec2_octeon;
 
-    memcpy((void *)(ebase + 0x100), &except_vec2_octeon, 0x80);
-    octeon_flush_cache_sigtramp(ebase + 0x100);
+	memcpy((void *)(ebase + 0x100), &except_vec2_octeon, 0x80);
+	octeon_flush_cache_sigtramp(ebase + 0x100);
 
-    probe_octeon();
+	probe_octeon();
 
-    shm_align_mask = PAGE_SIZE - 1;
+	shm_align_mask = PAGE_SIZE - 1;
 
-    flush_cache_all         = octeon_flush_icache_all;
-    __flush_cache_all       = octeon_flush_icache_all;
-    flush_cache_mm          = octeon_flush_cache_mm;
-    flush_cache_page        = octeon_flush_cache_page;
-    flush_cache_range       = octeon_flush_cache_range;
-    flush_cache_sigtramp    = octeon_flush_cache_sigtramp;
-    flush_icache_all        = octeon_flush_icache_all;
-    flush_data_cache_page   = octeon_flush_data_cache_page;
-    flush_icache_range      = octeon_flush_icache_range;
+	flush_cache_all         = octeon_flush_icache_all;
+	__flush_cache_all       = octeon_flush_icache_all;
+	flush_cache_mm          = octeon_flush_cache_mm;
+	flush_cache_page        = octeon_flush_cache_page;
+	flush_cache_range       = octeon_flush_cache_range;
+	flush_cache_sigtramp    = octeon_flush_cache_sigtramp;
+	flush_icache_all        = octeon_flush_icache_all;
+	flush_data_cache_page   = octeon_flush_data_cache_page;
+	flush_icache_range      = octeon_flush_icache_range;
 }
 
 /**
@@ -254,25 +250,23 @@ void __init octeon_cache_init(void)
 
 static void  cache_parity_error_octeon(int non_recoverable)
 {
-    unsigned long coreid = cvmx_get_core_num();
-    uint64_t icache_err = read_c0_cacheerr();
-
-    printk("Cache error exception:\n");
-    printk("cp0_errorepc == %lx\n", read_c0_errorepc());
-    if (icache_err & 1)
-    {
-        printk("CacheErr (Icache) == %llx\n", (unsigned long long)icache_err);
-        write_c0_cacheerr(0);
-    }
-    if (cache_err_dcache[coreid] & 1)
-    {
-        printk("CacheErr (Dcache) == %llx\n", (unsigned long long)cache_err_dcache[coreid]);
-        cache_err_dcache[coreid] = 0;
-    }
-
-
-    if (non_recoverable)
-        panic("Can't handle cache error: nested exception");
+	unsigned long coreid = cvmx_get_core_num();
+	uint64_t icache_err = read_c0_cacheerr();
+
+	printk("Cache error exception:\n");
+	printk("cp0_errorepc == %lx\n", read_c0_errorepc());
+	if (icache_err & 1) {
+		printk("CacheErr (Icache) == %llx\n", (unsigned long long)icache_err);
+		write_c0_cacheerr(0);
+	}
+	if (cache_err_dcache[coreid] & 1) {
+		printk("CacheErr (Dcache) == %llx\n", (unsigned long long)cache_err_dcache[coreid]);
+		cache_err_dcache[coreid] = 0;
+	}
+
+
+	if (non_recoverable)
+		panic("Can't handle cache error: nested exception");
 }
 
 /**
@@ -281,7 +275,7 @@ static void  cache_parity_error_octeon(int non_recoverable)
 
 asmlinkage void cache_parity_error_octeon_recoverable(void)
 {
-    cache_parity_error_octeon(0);
+	cache_parity_error_octeon(0);
 }
 
 /**
@@ -290,6 +284,6 @@ asmlinkage void cache_parity_error_octeon_recoverable(void)
 
 asmlinkage void cache_parity_error_octeon_non_recoverable(void)
 {
-    cache_parity_error_octeon(1);
+	cache_parity_error_octeon(1);
 }
 
diff --git a/arch/mips/mm/pg-octeon.c b/arch/mips/mm/pg-octeon.c
index ce3f4cb..b457955 100644
--- a/arch/mips/mm/pg-octeon.c
+++ b/arch/mips/mm/pg-octeon.c
@@ -12,37 +12,37 @@ void clear_page(void *page)
 {
 	void *end = page + PAGE_SIZE;
 
-    asm volatile (
-        "   .set	push		\n"
-        "   .set	mips64		\n"
-        "   .set	noreorder	\n"
-        "1: sd      $0, 0(%0)   \n" /* Write zeros to the cache line */
-        "   sd      $0, 8(%0)   \n"
-        "   sd      $0, 16(%0)  \n"
-        "   sd      $0, 24(%0)  \n"
-        "   sd      $0, 32(%0)  \n"
-        "   sd      $0, 40(%0)  \n"
-        "   sd      $0, 48(%0)  \n"
-        "   sd      $0, 56(%0)  \n"
-        "   sd      $0, 64(%0)  \n"
-        "   sd      $0, 72(%0)  \n"
-        "   sd      $0, 80(%0)  \n"
-        "   sd      $0, 88(%0)  \n"
-        "   sd      $0, 96(%0)  \n"
-        "   sd      $0, 104(%0) \n"
+	asm volatile (
+		"   .set	push		\n"
+		"   .set	mips64		\n"
+		"   .set	noreorder	\n"
+		"1: sd      $0, 0(%0)   \n" /* Write zeros to the cache line */
+		"   sd      $0, 8(%0)   \n"
+		"   sd      $0, 16(%0)  \n"
+		"   sd      $0, 24(%0)  \n"
+		"   sd      $0, 32(%0)  \n"
+		"   sd      $0, 40(%0)  \n"
+		"   sd      $0, 48(%0)  \n"
+		"   sd      $0, 56(%0)  \n"
+		"   sd      $0, 64(%0)  \n"
+		"   sd      $0, 72(%0)  \n"
+		"   sd      $0, 80(%0)  \n"
+		"   sd      $0, 88(%0)  \n"
+		"   sd      $0, 96(%0)  \n"
+		"   sd      $0, 104(%0) \n"
 #ifdef CONFIG_64BIT
-        "   daddu   %0, 128     \n" /* Increment to the next address. Will be dual issued */
+		"   daddu   %0, 128     \n" /* Increment to the next address. Will be dual issued */
 #else
-        "   addu    %0, 128     \n"
+		"   addu    %0, 128     \n"
 #endif
-        "   sd      $0, -16(%0) \n"
-        "   blt     %0, %1, 1b  \n" /* Loop until we've completed the page */
-        "    sd     $0, -8(%0)  \n"
-        "   .set	pop		\n"
-        : "+r" (page)
-        : "r" (end)
-        : "memory"
-    );
+		"   sd      $0, -16(%0) \n"
+		"   blt     %0, %1, 1b  \n" /* Loop until we've completed the page */
+		"    sd     $0, -8(%0)  \n"
+		"   .set	pop		\n"
+		: "+r" (page)
+		: "r" (end)
+		: "memory"
+	);
 }
 
 
@@ -53,66 +53,66 @@ void copy_page(void *to, void *from)
 #else
 	void *end = to + PAGE_SIZE;
 
-    /* Warning: Bad thing can happen if you prefetch an address that doesn't
-        exist in memory. With Octeon, this can happen at 256MB, 0x420000000,
-        and the top of memory. To avoid this, we stop prefetching during the
-        last two iterations of this loop */
-    asm volatile (
-        "   .set	push		\n"
-        "   .set	mips64		\n"
-        "   .set	noreorder	\n"
-        "   pref    0,  0(%1)   \n" /* Prefetch the first cache line of "from" */
-        "   pref    0,  128(%1) \n" /* Prefetch the next "from" cache line for the next iteration */
-        "1: pref    0,  256(%1) \n" /* Prefetch for two loops ahead */
-        "2:                     \n" /* This is the entry point for the last two loops to skip the prefetch */
-        "   ld      $12, 0(%1)  \n" /* Copy 32 bytes at a time */
-        "   ld      $13, 8(%1)  \n"
-        "   ld      $14, 16(%1) \n"
-        "   ld      $15, 24(%1) \n"
-        "   daddu   %1, 32      \n" /* Dual issued */
-        "   sd      $12, 0(%0)  \n"
-        "   sd      $13, 8(%0)  \n"
-        "   sd      $14, 16(%0) \n"
-        "   sd      $15, 24(%0) \n"
-        "   daddu   %0, 32      \n" /* Dual issued */
-        "   ld      $12, 0(%1)  \n" /* Copy 32 bytes at a time */
-        "   ld      $13, 8(%1)  \n"
-        "   ld      $14, 16(%1) \n"
-        "   ld      $15, 24(%1) \n"
-        "   daddu   %1, 32      \n" /* Dual issued */
-        "   sd      $12, 0(%0)  \n"
-        "   sd      $13, 8(%0)  \n"
-        "   sd      $14, 16(%0) \n"
-        "   sd      $15, 24(%0) \n"
-        "   daddu   %0, 32      \n" /* Dual issued */
-        "   ld      $12, 0(%1)  \n" /* Copy 32 bytes at a time */
-        "   ld      $13, 8(%1)  \n"
-        "   ld      $14, 16(%1) \n"
-        "   ld      $15, 24(%1) \n"
-        "   daddu   %1, 32      \n" /* Dual issued */
-        "   sd      $12, 0(%0)  \n"
-        "   sd      $13, 8(%0)  \n"
-        "   sd      $14, 16(%0) \n"
-        "   sd      $15, 24(%0) \n"
-        "   daddu   %0, 32      \n" /* Dual issued */
-        "   ld      $12, 0(%1)  \n" /* Copy 32 bytes at a time */
-        "   ld      $13, 8(%1)  \n"
-        "   ld      $14, 16(%1) \n"
-        "   ld      $15, 24(%1) \n"
-        "   daddu   %1, 32      \n" /* Dual issued */
-        "   sd      $12, 0(%0)  \n"
-        "   sd      $13, 8(%0)  \n"
-        "   daddu   %0, 32      \n" /* Dual issued */
-        "   sd      $14, -16(%0)\n"
-        "   blt     %0, %3, 1b  \n" /* Loop until we've gotten to the last 256 bytes */
-        "    sd     $15, -8(%0) \n"
-        "   blt     %0, %2, 2b  \n" /* Loop until we've completed the last 256 bytes, skip the prefetch */
-        "    nop                \n"
-        "   .set	pop		\n"
-        : "+r" (to), "+r" (from)
-        : "r" (end), "r" (end-256)
-        : "$12", "$13", "$14", "$15", "memory"
-    );
+	/* Warning: Bad thing can happen if you prefetch an address that doesn't
+	   exist in memory. With Octeon, this can happen at 256MB, 0x420000000,
+	   and the top of memory. To avoid this, we stop prefetching during the
+	   last two iterations of this loop */
+	asm volatile (
+		"   .set	push		\n"
+		"   .set	mips64		\n"
+		"   .set	noreorder	\n"
+		"   pref    0,  0(%1)   \n" /* Prefetch the first cache line of "from" */
+		"   pref    0,  128(%1) \n" /* Prefetch the next "from" cache line for the next iteration */
+		"1: pref    0,  256(%1) \n" /* Prefetch for two loops ahead */
+		"2:                     \n" /* This is the entry point for the last two loops to skip the prefetch */
+		"   ld      $12, 0(%1)  \n" /* Copy 32 bytes at a time */
+		"   ld      $13, 8(%1)  \n"
+		"   ld      $14, 16(%1) \n"
+		"   ld      $15, 24(%1) \n"
+		"   daddu   %1, 32      \n" /* Dual issued */
+		"   sd      $12, 0(%0)  \n"
+		"   sd      $13, 8(%0)  \n"
+		"   sd      $14, 16(%0) \n"
+		"   sd      $15, 24(%0) \n"
+		"   daddu   %0, 32      \n" /* Dual issued */
+		"   ld      $12, 0(%1)  \n" /* Copy 32 bytes at a time */
+		"   ld      $13, 8(%1)  \n"
+		"   ld      $14, 16(%1) \n"
+		"   ld      $15, 24(%1) \n"
+		"   daddu   %1, 32      \n" /* Dual issued */
+		"   sd      $12, 0(%0)  \n"
+		"   sd      $13, 8(%0)  \n"
+		"   sd      $14, 16(%0) \n"
+		"   sd      $15, 24(%0) \n"
+		"   daddu   %0, 32      \n" /* Dual issued */
+		"   ld      $12, 0(%1)  \n" /* Copy 32 bytes at a time */
+		"   ld      $13, 8(%1)  \n"
+		"   ld      $14, 16(%1) \n"
+		"   ld      $15, 24(%1) \n"
+		"   daddu   %1, 32      \n" /* Dual issued */
+		"   sd      $12, 0(%0)  \n"
+		"   sd      $13, 8(%0)  \n"
+		"   sd      $14, 16(%0) \n"
+		"   sd      $15, 24(%0) \n"
+		"   daddu   %0, 32      \n" /* Dual issued */
+		"   ld      $12, 0(%1)  \n" /* Copy 32 bytes at a time */
+		"   ld      $13, 8(%1)  \n"
+		"   ld      $14, 16(%1) \n"
+		"   ld      $15, 24(%1) \n"
+		"   daddu   %1, 32      \n" /* Dual issued */
+		"   sd      $12, 0(%0)  \n"
+		"   sd      $13, 8(%0)  \n"
+		"   daddu   %0, 32      \n" /* Dual issued */
+		"   sd      $14, -16(%0)\n"
+		"   blt     %0, %3, 1b  \n" /* Loop until we've gotten to the last 256 bytes */
+		"    sd     $15, -8(%0) \n"
+		"   blt     %0, %2, 2b  \n" /* Loop until we've completed the last 256 bytes, skip the prefetch */
+		"    nop                \n"
+		"   .set	pop		\n"
+		: "+r" (to), "+r" (from)
+		: "r" (end), "r" (end-256)
+		: "$12", "$13", "$14", "$15", "memory"
+	);
 #endif
 }
 
diff --git a/include/asm-mips/mach-cavium-octeon/cpu-feature-overrides.h b/include/asm-mips/mach-cavium-octeon/cpu-feature-overrides.h
index 6c5cb4b..227f148 100644
--- a/include/asm-mips/mach-cavium-octeon/cpu-feature-overrides.h
+++ b/include/asm-mips/mach-cavium-octeon/cpu-feature-overrides.h
@@ -44,7 +44,7 @@ static inline int read_current_timer(unsigned long *result)
 #ifndef CONFIG_64BIT
 		      "sll %0, 0\n"
 #endif
-		      :"=r" (*result));
+		      : "=r" (*result));
 	return 0;
 }
 
@@ -52,8 +52,8 @@ static inline int octeon_has_saa(void)
 {
 #ifdef CONFIG_CPU_CAVIUM_OCTEON
 	int id;
-	asm volatile ("mfc0 %0, $15,0":"=r" (id));
-	return (id >= 0x000d0300);
+	asm volatile ("mfc0 %0, $15,0" : "=r" (id));
+	return id >= 0x000d0300;
 #else
 	return 0;
 #endif
diff --git a/include/asm-mips/mach-cavium-octeon/kernel-entry-init.h b/include/asm-mips/mach-cavium-octeon/kernel-entry-init.h
index 16a8a2a..77193b5 100644
--- a/include/asm-mips/mach-cavium-octeon/kernel-entry-init.h
+++ b/include/asm-mips/mach-cavium-octeon/kernel-entry-init.h
@@ -3,10 +3,10 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 2005 Cavium Networks, Inc
+ * Copyright (C) 2005-2008 Cavium Networks, Inc
  */
-#ifndef __ASM_MACH_GENERIC_KERNEL_ENTRY_H
-#define __ASM_MACH_GENERIC_KERNEL_ENTRY_H
+#ifndef __ASM_MACH_CAVIUM_OCTEON_KERNEL_ENTRY_H
+#define __ASM_MACH_CAVIUM_OCTEON_KERNEL_ENTRY_H
 
 
 #define CP0_CYCLE_COUNTER $9,6
@@ -113,4 +113,4 @@ octeon_main_processor:
     .endm
 
 
-#endif /* __ASM_MACH_GENERIC_KERNEL_ENTRY_H */
+#endif /* __ASM_MACH_CAVIUM_OCTEON_KERNEL_ENTRY_H */
-- 
1.6.0.3

