From f4aa966239c493dbe38be7ad6b05c42efa8014df Mon Sep 17 00:00:00 2001
From: auto commit <unknown@unknown>
Date: Fri, 24 Oct 2008 12:23:04 -0700
Subject: [PATCH] auto_msg: importing 0001-cavium-cf-improvements.patch

This is an automatic import of patch 0001-cavium-cf-improvements.patch, no headers were
detected and a default message was constructed
---
 arch/mips/cavium-octeon/ebt3000_cf.c |   68 +++++++++++++++++-----------------
 1 files changed, 34 insertions(+), 34 deletions(-)

diff --git a/arch/mips/cavium-octeon/ebt3000_cf.c b/arch/mips/cavium-octeon/ebt3000_cf.c
index 9f1e9e3..c32d34b 100644
--- a/arch/mips/cavium-octeon/ebt3000_cf.c
+++ b/arch/mips/cavium-octeon/ebt3000_cf.c
@@ -144,11 +144,11 @@ static inline int ata_wait_idle(struct cf_device *cf)
 
 	if (unlikely(status & 0x80)) {
 		if (cf->gd)
-			printk("%s: Timeout\n", cf->gd->disk_name);
+			pr_warning("%s: Timeout\n", cf->gd->disk_name);
 		return -1;
 	} else if (unlikely(status & 1)) {
 		if (cf->gd)
-			printk("%s: Error\n", cf->gd->disk_name);
+			pr_err("%s: Error\n", cf->gd->disk_name);
 		return -1;
 	} else
 		return 0;
@@ -197,7 +197,7 @@ static inline int ata_wait_drq_ready(struct cf_device *cf)
 
 	if (unlikely((status & 0x08) == 0)) {
 		if (cf->gd)
-			printk("%s: Timeout\n", cf->gd->disk_name);
+			pr_warning("%s: Timeout\n", cf->gd->disk_name);
 		return -1;
 	} else
 		return 0;
@@ -359,7 +359,7 @@ static int ata_read_dma(struct cf_device *cf, unsigned long lba_start,
 
 #if 1
 	if (num_sectors > 8)
-		printk("ATA_READ_DMA: start: %ld, count: %ld, buffer: %p\n", lba_start, num_sectors, buffer);
+		pr_debug("ATA_READ_DMA: start: %ld, count: %ld, buffer: %p\n", lba_start, num_sectors, buffer);
 #endif
 
 	/* octeon_led_set(0, 31); */
@@ -368,7 +368,7 @@ static int ata_read_dma(struct cf_device *cf, unsigned long lba_start,
 
 		/* Wait for read to complete (BSY clear) */
 		if (ata_wait_idle(cf)) {
-			printk("CF not idle....\n");
+			pr_warning("CF not idle....\n");
 			goto done;
 		}
 
@@ -395,7 +395,7 @@ static int ata_read_dma(struct cf_device *cf, unsigned long lba_start,
 
 		/* Send CF read DMA command */
 		if (ata_command(cf, sectors_to_read & 0xff, lba_start, ATA_CMD_RD_DMA, 0)) {
-			printk("ATA command failed\n");
+			pr_err("ATA command failed\n");
 			goto done;
 		}
 
@@ -405,7 +405,7 @@ static int ata_read_dma(struct cf_device *cf, unsigned long lba_start,
 		while (--to && !dma_done[cf->dma_channel])
 			yield();
 		if (!dma_done[cf->dma_channel]) {
-			printk("ERROR: timeout waiting for DMA completion\n");
+			pr_err("Timeout waiting for DMA completion\n");
 			goto done;
 		}
 #else
@@ -416,7 +416,7 @@ static int ata_read_dma(struct cf_device *cf, unsigned long lba_start,
 			yield();
 		}
 		if (dma_cfg.s.en) {
-			printk("ERROR: timeout waiting for DMA completion\n");
+			pr_err("Timeout waiting for DMA completion\n");
 			goto done;
 		}
 #endif
@@ -431,7 +431,7 @@ done:
 	cvmx_write_csr(CVMX_MIO_BOOT_DMA_CFGX(cf->dma_channel), 0ull);
 
 	if (ata_wait_idle(cf)) {
-		printk("CF not idle....\n");
+		pr_warning("CF not idle....\n");
 	}
 	if (cf->dma_mode < 4)
 		udelay(10); /* 10 works on sandisk @ 700 Mhz */
@@ -458,7 +458,7 @@ static int ata_write_dma(struct cf_device *cf, unsigned long lba_start,
 	int to = 1000000;
 
 #if 0
-	printk("ATA_WRITE_DMA: start: %d, count: %d, buffer: %p\n", lba_start, num_sectors, buffer);
+	pr_debug("ATA_WRITE_DMA: start: %d, count: %d, buffer: %p\n", lba_start, num_sectors, buffer);
 #endif
 	/* Make sure data to be written is in L2 before DMA engine reads it */
 	CVMX_SYNCW;
@@ -469,7 +469,7 @@ static int ata_write_dma(struct cf_device *cf, unsigned long lba_start,
 
 		/* Wait for read to complete (BSY clear) */
 		if (ata_wait_idle(cf)) {
-			printk("CF not idle....\n");
+			pr_warning("CF not idle....\n");
 			goto done;
 		}
 
@@ -497,7 +497,7 @@ static int ata_write_dma(struct cf_device *cf, unsigned long lba_start,
 
 		/* Send CF read DMA command */
 		if (ata_command(cf, sectors_to_write & 0xff, lba_start, ATA_CMD_WR_DMA, 0)) {
-			printk("ATA command failed\n");
+			pr_err("ATA command failed\n");
 			goto done;
 		}
 
@@ -506,7 +506,7 @@ static int ata_write_dma(struct cf_device *cf, unsigned long lba_start,
 		while (--to && !dma_done[cf->dma_channel])
 			yield();
 		if (!dma_done[cf->dma_channel]) {
-			printk("ERROR: timeout waiting for DMA completion\n");
+			pr_err("Timeout waiting for DMA completion\n");
 			goto done;
 		}
 #else
@@ -517,7 +517,7 @@ static int ata_write_dma(struct cf_device *cf, unsigned long lba_start,
 			yield();
 		}
 		if (dma_cfg.s.en) {
-			printk("ERROR: timeout waiting for DMA completion\n");
+			pr_err("Timeout waiting for DMA completion\n");
 			goto done;
 		}
 #endif
@@ -533,7 +533,7 @@ done:
 	/* octeon_led_clear(0, 31); */
 
 	if (ata_wait_idle(cf)) {
-		printk("CF not idle....\n");
+		pr_warning("CF not idle....\n");
 	}
 	return sectors_written;
 }
@@ -623,7 +623,7 @@ static int ebt3000cf_identify(struct cf_device *cf)
 	if (result == 0) {
 		/* Sandisk 1G reports the wrong sector size */
 		drive_info.sector_bytes = 512;
-		printk("%s: %s Serial %s (%u sectors, %u bytes/sector)\n",
+		pr_info("%s: %s Serial %s (%u sectors, %u bytes/sector)\n",
 		       (cf->gd) ? cf->gd->disk_name : DEVICE_NAME,
 		       drive_info.model, drive_info.serial_no,
 		       drive_info.lba_capacity, (int) drive_info.sector_bytes);
@@ -647,7 +647,7 @@ static int ebt3000cf_identify(struct cf_device *cf)
 			cf->dma_channel = 0;  /* CF slot on ebh5200, ebh5600 wired to channel 0 */
 			cf->use_dma = 1;
 
-			printk("%s: using MWDMA mode %d, dma channel %d\n",
+			pr_info("%s: using MWDMA mode %d, dma channel %d\n",
 			       (cf->gd) ? cf->gd->disk_name : DEVICE_NAME,
 			       cf->dma_mode, cf->dma_channel);
 			cvmx_write_csr(CVMX_MIO_BOOT_DMA_TIMX(cf->dma_channel), dma_tim);
@@ -655,14 +655,14 @@ static int ebt3000cf_identify(struct cf_device *cf)
 			/* Select the DMA mode that we want to use (this does not seem to be needed
 			** or help) */
 			if (ata_command(cf, (0x4 << 3) | cf->dma_mode, 0, WIN_SETFEATURES, 0x3)) {
-				printk("ERROR setting DMA mode\n");
+				pr_err("ERROR setting DMA mode\n");
 			}
 
 			/* Get the drive info again to verify setting of DMA mode */
 
 			result = ata_identify(cf, &drive_info);
 			if (0 && result == 0) {
-				printk("%s: MWDMA after set: 0x%x, w163: 0x%x\n",
+				pr_info("%s: MWDMA after set: 0x%x, w163: 0x%x\n",
 				       (cf->gd) ? cf->gd->disk_name : DEVICE_NAME,
 				       drive_info.dma_mword, drive_info.words161_175[2]);
 			}
@@ -677,12 +677,12 @@ static int ebt3000cf_identify(struct cf_device *cf)
 				dma_int_en.u64 = cvmx_read_csr(CVMX_MIO_BOOT_DMA_INT_ENX(cf->dma_channel));
 				dma_int_en.s.done = 1;
 				cvmx_write_csr(CVMX_MIO_BOOT_DMA_INT_ENX(cf->dma_channel), dma_int_en.u64);
-				printk("%s: using IRQ DMA completion notification\n",
+				pr_info("%s: using IRQ DMA completion notification\n",
 				       (cf->gd) ? cf->gd->disk_name : DEVICE_NAME);
 			}
 #endif
 		} else
-			printk("%s: MWDMA not supported.\n", (cf->gd) ? cf->gd->disk_name : DEVICE_NAME);
+			pr_warning("%s: MWDMA not supported.\n", (cf->gd) ? cf->gd->disk_name : DEVICE_NAME);
 	}
 
 	return result;
@@ -704,7 +704,7 @@ static int ebt3000_cf_transfer(struct cf_device *cf, unsigned long lba_sector,
 			       int write)
 {
 	if ((lba_sector + num_sectors) > cf->num_sectors) {
-		printk("%s: Attempt to access beyond end of device (%ld > %ld)\n", cf->gd->disk_name, lba_sector + num_sectors - 1, cf->num_sectors - 1);
+		pr_err("%s: Attempt to access beyond end of device (%ld > %ld)\n", cf->gd->disk_name, lba_sector + num_sectors - 1, cf->num_sectors - 1);
 		num_sectors = cf->num_sectors - lba_sector;
 		if (num_sectors <= 0)
 			return 0;
@@ -791,8 +791,8 @@ static void ebt3000_cf_work(struct work_struct *work)
 	/* Loop through all the pending requests */
 	while ((req = elv_next_request(cf->queue)) != NULL) {
 		if (!blk_fs_request(req)) {
-			printk("%s: Skip non-CMD request\n",
-			       req->rq_disk->disk_name);
+			pr_warning("%s: Skip non-CMD request\n",
+				   req->rq_disk->disk_name);
 			end_request(req, 0);
 		} else {
 			int count;
@@ -834,7 +834,7 @@ static int __init ebt3000_cf_init(void)
 	int major_num;
 	int region;
 
-	printk(KERN_NOTICE DEVICE_NAME
+	pr_notice(DEVICE_NAME
 	       ": Octeon bootbus compact flash driver version %s\n", VERSION);
 
 	memset(cf, 0, sizeof(*cf));
@@ -851,8 +851,8 @@ static int __init ebt3000_cf_init(void)
 				cvmx_phys_to_ptr(octeon_bootinfo->
 						 compact_flash_common_base_addr);
 		else {
-			printk(KERN_NOTICE DEVICE_NAME
-			       ": Compact flash interface not present.\n");
+			pr_notice(DEVICE_NAME
+			          ": Compact flash interface not present.\n");
 			goto out;
 		}
 	} else
@@ -869,7 +869,7 @@ static int __init ebt3000_cf_init(void)
 	/* Get a request queue. */
 	cf->queue = blk_init_queue(ebt3000_cf_request, &cf->lock);
 	if (cf->queue == NULL) {
-		printk(DEVICE_NAME
+		pr_err(DEVICE_NAME
 		       ": unable to allocate block request queue\n");
 		goto out;
 	}
@@ -885,14 +885,14 @@ static int __init ebt3000_cf_init(void)
 	/* Get registered. */
 	major_num = register_blkdev(0, DEVICE_NAME);
 	if (major_num <= 0) {
-		printk(DEVICE_NAME ": unable to get major number\n");
+		pr_err(DEVICE_NAME ": unable to get major number\n");
 		goto out;
 	}
 
 	/* And the gendisk structure. */
 	cf->gd = alloc_disk(64);
 	if (cf->gd == NULL) {
-		printk(DEVICE_NAME ": unable to allocate disk\n");
+		pr_err(DEVICE_NAME ": unable to allocate disk\n");
 		goto out_unregister;
 	}
 
@@ -903,10 +903,10 @@ static int __init ebt3000_cf_init(void)
 		if (cfg.s.base ==
 		    octeon_bootinfo->compact_flash_common_base_addr >> 16) {
 			cf->is16bit = cfg.s.width;
-			printk(KERN_NOTICE DEVICE_NAME
-			       ": Compact flash found in bootbus region %d (%d bit%s).\n",
-			       region, (cf->is16bit) ? 16 : 8,
-			       (cf->is_true_ide) ? ", ide" : "");
+			pr_notice(DEVICE_NAME
+				  ": Compact flash found in bootbus region %d (%d bit%s).\n",
+				  region, (cf->is16bit) ? 16 : 8,
+				  (cf->is_true_ide) ? ", ide" : "");
 			break;
 		}
 	}
-- 
1.5.5.1

