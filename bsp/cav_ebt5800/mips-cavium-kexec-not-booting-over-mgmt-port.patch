From 35d791c5d6b86eb04ced14adc555182c45f1dc45 Mon Sep 17 00:00:00 2001
From: Greg Moffatt <greg.moffatt@windriver.com>
Date: Tue, 11 Aug 2009 14:29:16 -0400
Subject: [PATCH 2/2] mips/cavium: kexec not booting over mgmt port

For cavium targets where the management port is used for booting
kexec fails to mount the rootfs.  The management ports require
some special handling and notification to correctly re-initialize
after a kexec.  When the original kernel is shutting down,
some actions are required on the USB and mgmt ports to ensure
that they can be successfully re-initialized by the new kernel.

Signed-off-by: Greg Moffatt <greg.moffatt@windriver.com>
---
 arch/mips/cavium-octeon/hal.c |   56 +++++++++++++++++++++++++++++++++++++++++
 1 files changed, 56 insertions(+), 0 deletions(-)

diff --git a/arch/mips/cavium-octeon/hal.c b/arch/mips/cavium-octeon/hal.c
index e6895c0..f9a5bce 100644
--- a/arch/mips/cavium-octeon/hal.c
+++ b/arch/mips/cavium-octeon/hal.c
@@ -768,6 +768,13 @@ static void octeon_kexec_shutdown_other_cpus(void *ignore)
 }
 #endif /* CONFIG_SMP */
 
+/* externs for USB shutdown */
+#define MAX_USB_PORTS   10
+extern struct platform_device *pdev_glob[MAX_USB_PORTS];
+extern void platform_device_unregister(struct platform_device *pdev);
+
+extern int cvmx_mgmt_port_shutdown(int port);
+
 void octeon_kexec_shutdown(void)
 {
 #ifdef CONFIG_SMP
@@ -789,6 +796,55 @@ void octeon_kexec_shutdown(void)
 		mdelay(1);
 	}
 #endif /* CONFIG_SMP */
+
+	/* shutdown all USB ports */
+	int i=0;
+	for(i=0; i < MAX_USB_PORTS; i++) {
+		if(pdev_glob[i]) {
+			platform_device_unregister(pdev_glob[i]);
+			pdev_glob[i] = NULL;
+		}
+	}
+
+	/* shutdown all mgmt ports */
+	int port;
+	int num_ports;
+	struct net_device dev;
+	struct net_device *mgmt_port;
+	struct net        *net;
+
+	if(OCTEON_IS_MODEL(OCTEON_CN52XX))
+		num_ports = 2;
+	else if(OCTEON_IS_MODEL(OCTEON_CN56XX))
+		num_ports = 1;
+	else
+		num_ports = 0;
+
+	for(port=0; port < num_ports; port++)
+	{
+		memset(&dev, 0, sizeof(dev));
+		net = dev_net(&dev);
+		if(!net)
+			continue;
+
+		mgmt_port = dev_get_by_name(net, (port==0 ? "mgmt0" : "mgmt1"));
+		if(!mgmt_port)
+			continue;
+
+		cvmx_write_csr(CVMX_MIXX_IRHWM(port), 0);
+		cvmx_write_csr(CVMX_MIXX_INTENA(port), 0);
+		cvmx_mgmt_port_shutdown(port);
+		free_irq(mgmt_port->irq, mgmt_port);
+
+		/* flag the new kernel to query for the mgmt port mac address */
+		uint64_t *prev_mac_ptr = cvmx_bootmem_alloc_named(sizeof(uint64_t), 64, "kexec_previous_mac");
+		if(!prev_mac_ptr) {
+			uint64_t *prev_mac_ptr_phys = 
+				cvmx_bootmem_find_named_block("kexec_previous_mac");
+			if(prev_mac_ptr_phys)
+				prev_mac_ptr = cvmx_phys_to_ptr(prev_mac_ptr_phys);
+		}
+	}
 }
 
 void octeon_crash_shutdown(struct pt_regs *regs)
-- 
1.6.3.3

