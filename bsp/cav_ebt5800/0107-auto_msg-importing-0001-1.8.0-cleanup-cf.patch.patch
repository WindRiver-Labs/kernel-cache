From 48b1fb1643a493131ccb6f89a7bce84ce5b5e0ee Mon Sep 17 00:00:00 2001
From: auto commit <unknown@unknown>
Date: Fri, 24 Oct 2008 12:23:04 -0700
Subject: [PATCH] auto_msg: importing 0001-1.8.0-cleanup-cf.patch

This is an automatic import of patch 0001-1.8.0-cleanup-cf.patch, no headers were
detected and a default message was constructed
---
 arch/mips/cavium-octeon/ebt3000_cf.c |  352 ++++++++++++++++------------------
 1 files changed, 169 insertions(+), 183 deletions(-)

diff --git a/arch/mips/cavium-octeon/ebt3000_cf.c b/arch/mips/cavium-octeon/ebt3000_cf.c
index fc14567..ee51095 100644
--- a/arch/mips/cavium-octeon/ebt3000_cf.c
+++ b/arch/mips/cavium-octeon/ebt3000_cf.c
@@ -24,7 +24,7 @@
 #include <linux/blkdev.h>
 #include <linux/hdreg.h>
 #include <linux/ide.h>
-#include <asm/delay.h>
+#include <linux/delay.h>
 
 #include "cvmx-app-init.h"
 #include "cvmx-sysinfo.h"
@@ -33,7 +33,7 @@
 
 
 #ifndef MAX
-#define	MAX(a,b) (((a)>(b))?(a):(b))
+#define	MAX(a, b) (((a) > (b)) ? (a) : (b))
 #endif
 
 #define VERSION "1.1"
@@ -48,11 +48,11 @@ MODULE_LICENSE("GPL");
 
 /* Timing multiple used for configuring the boot bus DMA engine */
 #define CF_DMA_TIMING_MULT	4
+
 /*
  * The internal representation of our device.
  */
-
-typedef struct {
+struct cf_device {
 	void *base_ptr;
 	unsigned long num_sectors;
 	unsigned long sector_size;
@@ -63,14 +63,14 @@ typedef struct {
 	struct work_struct cf_work;
 	int is16bit;
 	int is_true_ide;	/* is16bit must also be set */
-        int use_dma;      
+	int use_dma;
 	int dma_channel;
 	int dma_mode;		/* CF mwdma mode */
-} cf_device_t;
+};
 
-static cf_device_t STATIC_DEVICE;
+static struct cf_device STATIC_DEVICE;
 
-static int use_cf_dma = 0;
+static int use_cf_dma;
 
 /**
  * Called to enable the use of DMA based on kernel command line.
@@ -84,22 +84,23 @@ void ebt3000_cf_enable_dma(void)
 #ifdef USE_CF_DMA_IRQ
 /* Used for for demonstrating DMA completion IRQ */
 static volatile int dma_done[3] = {0};
+
 static irqreturn_t interruptDma0Done(int cpl, void *dev_id)
 {
-    cvmx_mio_boot_dma_intx_t dma_int;
-    cf_device_t * cf = dev_id;
-    /* Check to see if DMA channel 0 is done */
-    dma_int.u64 = cvmx_read_csr(CVMX_MIO_BOOT_DMA_INTX(cf->dma_channel));
-    if (dma_int.s.done)
-    {
-        dma_done[cf->dma_channel] = 1;
-        cvmx_write_csr(CVMX_MIO_BOOT_DMA_INTX(cf->dma_channel), dma_int.u64);
-        CVMX_SYNCW;
-        return IRQ_HANDLED;
-    }
-    return IRQ_NONE;
+	cvmx_mio_boot_dma_intx_t dma_int;
+	struct cf_device *cf = dev_id;
+	/* Check to see if DMA channel 0 is done */
+	dma_int.u64 = cvmx_read_csr(CVMX_MIO_BOOT_DMA_INTX(cf->dma_channel));
+	if (dma_int.s.done) {
+		dma_done[cf->dma_channel] = 1;
+		cvmx_write_csr(CVMX_MIO_BOOT_DMA_INTX(cf->dma_channel), dma_int.u64);
+		CVMX_SYNCW;
+		return IRQ_HANDLED;
+	}
+	return IRQ_NONE;
 }
 #endif
+
 /**
  * Check if the Compact flash is idle and doesn't have any
  * errors.
@@ -107,12 +108,12 @@ static irqreturn_t interruptDma0Done(int cpl, void *dev_id)
  * @param cf     Device to check
  * @return Zero on success
  */
-static inline int ata_wait_idle(cf_device_t * cf)
+static inline int ata_wait_idle(struct cf_device *cf)
 {
 	unsigned char status;
 	unsigned long timeout = jiffies + HZ;
 
-	// octeon_led_set(0, 30);
+	/* octeon_led_set(0, 30); */
 
 	if (cf->is_true_ide) {
 		status = __raw_readw(cf->base_ptr + 14) & 0xff;
@@ -139,7 +140,7 @@ static inline int ata_wait_idle(cf_device_t * cf)
 			status = __raw_readb(cf->base_ptr + 7);
 		}
 	}
-	// octeon_led_clear(0, 30);
+	/* octeon_led_clear(0, 30); */
 
 	if (unlikely(status & 0x80)) {
 		if (cf->gd)
@@ -160,12 +161,12 @@ static inline int ata_wait_idle(cf_device_t * cf)
  * @param cf     Device to check
  * @return Zero on success
  */
-static inline int ata_wait_drq_ready(cf_device_t * cf)
+static inline int ata_wait_drq_ready(struct cf_device *cf)
 {
 	unsigned char status;
 	unsigned long timeout = jiffies + HZ;
 
-	// octeon_led_set(0, 30);
+	/* octeon_led_set(0, 30); */
 	if (cf->is_true_ide) {
 		status = __raw_readw(cf->base_ptr + 14) & 0xff;
 		while ((status & 0x08) == 0) {
@@ -191,7 +192,7 @@ static inline int ata_wait_drq_ready(cf_device_t * cf)
 			status = __raw_readb(cf->base_ptr + 7);
 		}
 	}
-	// octeon_led_clear(0, 30);
+	/* octeon_led_clear(0, 30); */
 
 
 	if (unlikely((status & 0x08) == 0)) {
@@ -214,7 +215,7 @@ static inline int ata_wait_drq_ready(cf_device_t * cf)
  * 		   in true IDE mode
  * @return Zero on success
  */
-static int ata_command(cf_device_t * cf, int sectors, unsigned long lba,
+static int ata_command(struct cf_device *cf, int sectors, unsigned long lba,
 		       int command, int features)
 {
 	/* Wait to not be busy before we start */
@@ -223,7 +224,7 @@ static int ata_command(cf_device_t * cf, int sectors, unsigned long lba,
 
 	if (cf->is_true_ide) {
 		if (features)  /* Feature 0 is not valid */
- 			__raw_writew(features & 0xff, cf->base_ptr + 2);
+			__raw_writew(features & 0xff, cf->base_ptr + 2);
 		__raw_writew(sectors, cf->base_ptr + 4);
 		__raw_writew(lba & 0xff, cf->base_ptr + 6);
 		__raw_writew((lba >> 8) & 0xff, cf->base_ptr + 8);
@@ -255,7 +256,7 @@ static int ata_command(cf_device_t * cf, int sectors, unsigned long lba,
  * @param drive_info IDE drive information
  * @return Zero on success
  */
-static int ata_identify(cf_device_t * cf, struct hd_driveid *drive_info)
+static int ata_identify(struct cf_device *cf, struct hd_driveid *drive_info)
 {
 	if (ata_command(cf, 0, 0, WIN_IDENTIFY, 0))
 		return -1;
@@ -292,12 +293,12 @@ static int ata_identify(cf_device_t * cf, struct hd_driveid *drive_info)
  * @param buffer    Buffer to put the results in
  * @return Number of sectors read
  */
-static int ata_read(cf_device_t * cf, unsigned long lba_start,
+static int ata_read(struct cf_device *cf, unsigned long lba_start,
 		    unsigned long num_sectors, char *buffer)
 {
 	int sectors_read = 0;
 
-	// octeon_led_set(0, 31);
+	/* octeon_led_set(0, 31); */
 	while (sectors_read < num_sectors) {
 		int count;
 		int sectors_to_read = num_sectors;
@@ -331,8 +332,8 @@ static int ata_read(cf_device_t * cf, unsigned long lba_start,
 			sectors_read++;
 		}
 	}
-      done:
-	// octeon_led_clear(0, 31);
+done:
+	/* octeon_led_clear(0, 31); */
 
 	return sectors_read;
 }
@@ -349,97 +350,91 @@ static int ata_read(cf_device_t * cf, unsigned long lba_start,
  * @return Number of sectors read
  */
 #define ATA_CMD_RD_DMA	0xC8	/* Read DMA (with retries)	*/
-static int ata_read_dma(cf_device_t * cf, unsigned long lba_start,
+static int ata_read_dma(struct cf_device *cf, unsigned long lba_start,
 		    unsigned long num_sectors, char *buffer)
 {
 	int sectors_read = 0;
-        cvmx_mio_boot_dma_cfgx_t dma_cfg;
-        int to = 1000000;
+	cvmx_mio_boot_dma_cfgx_t dma_cfg;
+	int to = 1000000;
 
 #if 1
-        if (num_sectors > 8)
-            printk("ATA_READ_DMA: start: %ld, count: %ld, buffer: %p\n", lba_start, num_sectors, buffer);
+	if (num_sectors > 8)
+		printk("ATA_READ_DMA: start: %ld, count: %ld, buffer: %p\n", lba_start, num_sectors, buffer);
 #endif
 
-	// octeon_led_set(0, 31);
+	/* octeon_led_set(0, 31); */
 	while (sectors_read < num_sectors) {
 		int sectors_to_read = num_sectors - sectors_read;
 
-                /* Wait for read to complete (BSY clear) */
-                if (ata_wait_idle(cf))
-                {
+		/* Wait for read to complete (BSY clear) */
+		if (ata_wait_idle(cf)) {
 			printk("CF not idle....\n");
 			goto done;
-                }
+		}
 
 		if (cf->dma_mode < 4)
-			udelay(10); // 10 OK,   5 bad
-				// 1, 0 OK with lexar
+			udelay(10); /* 10 OK,   5 bad
+				       1, 0 OK with lexar */
 
 		if (sectors_to_read > 256)
 			sectors_to_read = 256;
 
 
 #ifdef USE_CF_DMA_IRQ
-                dma_done[cf->dma_channel] = 0;
-                CVMX_SYNCW;
+		dma_done[cf->dma_channel] = 0;
+		CVMX_SYNCW;
 #endif
-                /* Setup DMA engine */
-                dma_cfg.u64 = 0;
-                dma_cfg.s.en = 1;
-                dma_cfg.s.swap8 = 1;
-                dma_cfg.s.adr = cvmx_ptr_to_phys(buffer);
-                dma_cfg.s.size = sectors_to_read * (512/2) - 1;
-                cvmx_write_csr(CVMX_MIO_BOOT_DMA_CFGX(cf->dma_channel), dma_cfg.u64);
-                CVMX_SYNCW;
-
-                /* Send CF read DMA command */
-                if (ata_command(cf, sectors_to_read & 0xff, lba_start, ATA_CMD_RD_DMA, 0))
-                {
+		/* Setup DMA engine */
+		dma_cfg.u64 = 0;
+		dma_cfg.s.en = 1;
+		dma_cfg.s.swap8 = 1;
+		dma_cfg.s.adr = cvmx_ptr_to_phys(buffer);
+		dma_cfg.s.size = sectors_to_read * (512/2) - 1;
+		cvmx_write_csr(CVMX_MIO_BOOT_DMA_CFGX(cf->dma_channel), dma_cfg.u64);
+		CVMX_SYNCW;
+
+		/* Send CF read DMA command */
+		if (ata_command(cf, sectors_to_read & 0xff, lba_start, ATA_CMD_RD_DMA, 0)) {
 			printk("ATA command failed\n");
 			goto done;
-                }
-    
-    
-                /* Poll for DMA completion */
+		}
+
+
+		/* Poll for DMA completion */
 #ifdef USE_CF_DMA_IRQ
-                while (--to && !dma_done[cf->dma_channel])
+		while (--to && !dma_done[cf->dma_channel])
 			yield();
-                if (!dma_done[cf->dma_channel])
-                {
+		if (!dma_done[cf->dma_channel]) {
 			printk("ERROR: timeout waiting for DMA completion\n");
 			goto done;
-                }
+		}
 #else
-                while (--to)
-                {
+		while (--to) {
 			dma_cfg.u64 = cvmx_read_csr(CVMX_MIO_BOOT_DMA_CFGX(cf->dma_channel));
 			if (!dma_cfg.s.en)
 				break;
 			yield();
-                }
-                if (dma_cfg.s.en)
-                {
+		}
+		if (dma_cfg.s.en) {
 			printk("ERROR: timeout waiting for DMA completion\n");
 			goto done;
-                }
+		}
 #endif
-                sectors_read += sectors_to_read;
-                buffer += sectors_to_read * 512;
+		sectors_read += sectors_to_read;
+		buffer += sectors_to_read * 512;
 		lba_start += sectors_to_read;
 
 
 	}
-      done:
-	// octeon_led_clear(0, 31);
+done:
+	/* octeon_led_clear(0, 31); */
 	cvmx_write_csr(CVMX_MIO_BOOT_DMA_CFGX(cf->dma_channel), 0ull);
 
-        if (ata_wait_idle(cf))
-        {
+	if (ata_wait_idle(cf)) {
 		printk("CF not idle....\n");
-        }
-        if (cf->dma_mode < 4)
-            udelay(10); // 10 works on sandisk @ 700 Mhz
+	}
+	if (cf->dma_mode < 4)
+		udelay(10); /* 10 works on sandisk @ 700 Mhz */
 	return sectors_read;
 }
 
@@ -455,98 +450,91 @@ static int ata_read_dma(cf_device_t * cf, unsigned long lba_start,
  * @return Number of sectors written
  */
 #define ATA_CMD_WR_DMA	0xCA	/* Write DMA (with retries)	*/
-static int ata_write_dma(cf_device_t * cf, unsigned long lba_start,
+static int ata_write_dma(struct cf_device *cf, unsigned long lba_start,
 		    unsigned long num_sectors, char *buffer)
 {
 	int sectors_written = 0;
-        cvmx_mio_boot_dma_cfgx_t dma_cfg;
-        int to = 1000000;
+	cvmx_mio_boot_dma_cfgx_t dma_cfg;
+	int to = 1000000;
 
 #if 0
-        printk("ATA_WRITE_DMA: start: %d, count: %d, buffer: %p\n", lba_start, num_sectors, buffer);
+	printk("ATA_WRITE_DMA: start: %d, count: %d, buffer: %p\n", lba_start, num_sectors, buffer);
 #endif
-        /* Make sure data to be written is in L2 before DMA engine reads it */
-        CVMX_SYNCW;
+	/* Make sure data to be written is in L2 before DMA engine reads it */
+	CVMX_SYNCW;
 
-	// octeon_led_set(0, 31);
+	/* octeon_led_set(0, 31); */
 	while (sectors_written < num_sectors) {
 		int sectors_to_write = num_sectors - sectors_written;
 
-                /* Wait for read to complete (BSY clear) */
-                if (ata_wait_idle(cf))
-                {
-                    printk("CF not idle....\n");
-                    goto done;
-                }
+		/* Wait for read to complete (BSY clear) */
+		if (ata_wait_idle(cf)) {
+			printk("CF not idle....\n");
+			goto done;
+		}
 
 		if (cf->dma_mode < 4)
-			udelay(10); // 10 OK, 5 bad with sandisk
-				   // 1 OK with lexar 
+			udelay(10); /* 10 OK, 5 bad with sandisk
+					1 OK with lexar */
 
 		if (sectors_to_write > 256)
 			sectors_to_write = 256;
 
 
 #ifdef USE_CF_DMA_IRQ
-                dma_done[cf->dma_channel] = 0;
-                CVMX_SYNCW;
+		dma_done[cf->dma_channel] = 0;
+		CVMX_SYNCW;
 #endif
-                /* Setup DMA engine */
-                dma_cfg.u64 = 0;
-                dma_cfg.s.en = 1;
-                dma_cfg.s.rw = 1;
-                dma_cfg.s.swap8 = 1;
-                dma_cfg.s.adr = cvmx_ptr_to_phys(buffer);
-                dma_cfg.s.size = sectors_to_write * (512/2) - 1;
-                cvmx_write_csr(CVMX_MIO_BOOT_DMA_CFGX(cf->dma_channel), dma_cfg.u64);
-                CVMX_SYNCW;
-
-                /* Send CF read DMA command */
-                if (ata_command(cf, sectors_to_write & 0xff, lba_start, ATA_CMD_WR_DMA, 0))
-                {
-                    printk("ATA command failed\n");
-                    goto done;
-                }
-    
-    
-                /* Poll for DMA completion */
+		/* Setup DMA engine */
+		dma_cfg.u64 = 0;
+		dma_cfg.s.en = 1;
+		dma_cfg.s.rw = 1;
+		dma_cfg.s.swap8 = 1;
+		dma_cfg.s.adr = cvmx_ptr_to_phys(buffer);
+		dma_cfg.s.size = sectors_to_write * (512/2) - 1;
+		cvmx_write_csr(CVMX_MIO_BOOT_DMA_CFGX(cf->dma_channel), dma_cfg.u64);
+		CVMX_SYNCW;
+
+		/* Send CF read DMA command */
+		if (ata_command(cf, sectors_to_write & 0xff, lba_start, ATA_CMD_WR_DMA, 0)) {
+			printk("ATA command failed\n");
+			goto done;
+		}
+
+		/* Poll for DMA completion */
 #ifdef USE_CF_DMA_IRQ
-                while (--to && !dma_done[cf->dma_channel])
+		while (--to && !dma_done[cf->dma_channel])
 			yield();
-                if (!dma_done[cf->dma_channel])
-                {
+		if (!dma_done[cf->dma_channel]) {
 			printk("ERROR: timeout waiting for DMA completion\n");
 			goto done;
-                }
+		}
 #else
-                while (--to)
-                {
+		while (--to) {
 			dma_cfg.u64 = cvmx_read_csr(CVMX_MIO_BOOT_DMA_CFGX(cf->dma_channel));
 			if (!dma_cfg.s.en)
 				break;
 			yield();
-                }
-                if (dma_cfg.s.en)
-                {
+		}
+		if (dma_cfg.s.en) {
 			printk("ERROR: timeout waiting for DMA completion\n");
 			goto done;
-                }
+		}
 #endif
-                sectors_written += sectors_to_write;
-                buffer += sectors_to_write * 512;
+		sectors_written += sectors_to_write;
+		buffer += sectors_to_write * 512;
 		lba_start += sectors_to_write;
 
 
 	}
-      done:
+done:
 
 	cvmx_write_csr(CVMX_MIO_BOOT_DMA_CFGX(cf->dma_channel), 0ull);
-	// octeon_led_clear(0, 31);
+	/* octeon_led_clear(0, 31); */
 
-        if (ata_wait_idle(cf))
-        {
+	if (ata_wait_idle(cf)) {
 		printk("CF not idle....\n");
-        }
+	}
 	return sectors_written;
 }
 /**
@@ -559,12 +547,12 @@ static int ata_write_dma(cf_device_t * cf, unsigned long lba_start,
  * @param buffer    Data buffer to write
  * @return Number of sectors written
  */
-static int ata_write(cf_device_t * cf, unsigned long lba_start,
+static int ata_write(struct cf_device *cf, unsigned long lba_start,
 		     unsigned long num_sectors, const char *buffer)
 {
 	int sectors_written = 0;
 
-	// octeon_led_set(1, 31);
+	/* octeon_led_set(1, 31); */
 	while (sectors_written < num_sectors) {
 		int count;
 		int sectors_to_write = num_sectors;
@@ -609,8 +597,8 @@ static int ata_write(cf_device_t * cf, unsigned long lba_start,
 			sectors_written++;
 		}
 	}
-      done:
-	// octeon_led_clear(1, 31);
+done:
+	/* octeon_led_clear(1, 31); */
 
 	return sectors_written;
 }
@@ -624,7 +612,7 @@ static int ata_write(cf_device_t * cf, unsigned long lba_start,
  * @return Zero on success. Failure will result in a device of zero
  *         size and a -1 return code.
  */
-static int ebt3000cf_identify(cf_device_t * cf)
+static int ebt3000cf_identify(struct cf_device *cf)
 {
 	struct hd_driveid drive_info;
 	int result;
@@ -650,56 +638,52 @@ static int ebt3000cf_identify(cf_device_t * cf)
 		cf->sector_size = KERNEL_SECTOR_SIZE;
 	}
 
-        if (use_cf_dma && cf->is_true_ide)
-        {
+	if (use_cf_dma && cf->is_true_ide) {
+
 		uint64_t dma_tim = cvmx_compactflash_generate_dma_tim(CF_DMA_TIMING_MULT,
 							      (void *)&drive_info,
 							      &(cf->dma_mode));
-		if (dma_tim)
-		{
+		if (dma_tim) {
 			cf->dma_channel = 0;  /* CF slot on ebh5200, ebh5600 wired to channel 0 */
-			cf->use_dma = 1; 
+			cf->use_dma = 1;
 
 			printk("%s: using MWDMA mode %d, dma channel %d\n",
 			       (cf->gd) ? cf->gd->disk_name : DEVICE_NAME,
 			       cf->dma_mode, cf->dma_channel);
-			cvmx_write_csr(CVMX_MIO_BOOT_DMA_TIMX(cf->dma_channel), dma_tim); 
+			cvmx_write_csr(CVMX_MIO_BOOT_DMA_TIMX(cf->dma_channel), dma_tim);
 
 			/* Select the DMA mode that we want to use (this does not seem to be needed
-                        ** or help) */
-			if (ata_command(cf, (0x4 << 3) | cf->dma_mode, 0, WIN_SETFEATURES, 0x3))
-			{
+			** or help) */
+			if (ata_command(cf, (0x4 << 3) | cf->dma_mode, 0, WIN_SETFEATURES, 0x3)) {
 				printk("ERROR setting DMA mode\n");
 			}
 
 			/* Get the drive info again to verify setting of DMA mode */
 
 			result = ata_identify(cf, &drive_info);
-			if (0 && result == 0)
-			{
-				printk("%s: MWDMA after set: 0x%x, w163: 0x%x\n", 
+			if (0 && result == 0) {
+				printk("%s: MWDMA after set: 0x%x, w163: 0x%x\n",
 				       (cf->gd) ? cf->gd->disk_name : DEVICE_NAME,
 				       drive_info.dma_mword, drive_info.words161_175[2]);
 			}
 #ifdef USE_CF_DMA_IRQ
-                        {
-                                /* Request the interrupt */
-                                cvmx_mio_boot_dma_int_enx_t dma_int_en;
-                                request_irq(OCTEON_IRQ_BOOTDMA, interruptDma0Done,
-                                            SA_SHIRQ, "MIO_DMA", cf);
+			{
+				/* Request the interrupt */
+				cvmx_mio_boot_dma_int_enx_t dma_int_en;
+				request_irq(OCTEON_IRQ_BOOTDMA, interruptDma0Done,
+					    SA_SHIRQ, "MIO_DMA", cf);
     
-                                /* Enable interrupts for DMA completion */
-                                dma_int_en.u64 = cvmx_read_csr(CVMX_MIO_BOOT_DMA_INT_ENX(cf->dma_channel));
-                                dma_int_en.s.done = 1;
-                                cvmx_write_csr(CVMX_MIO_BOOT_DMA_INT_ENX(cf->dma_channel), dma_int_en.u64);
-                                printk("%s: using IRQ DMA completion notification\n",
-                                       (cf->gd) ? cf->gd->disk_name : DEVICE_NAME);
-                        }
+				/* Enable interrupts for DMA completion */
+				dma_int_en.u64 = cvmx_read_csr(CVMX_MIO_BOOT_DMA_INT_ENX(cf->dma_channel));
+				dma_int_en.s.done = 1;
+				cvmx_write_csr(CVMX_MIO_BOOT_DMA_INT_ENX(cf->dma_channel), dma_int_en.u64);
+				printk("%s: using IRQ DMA completion notification\n",
+				       (cf->gd) ? cf->gd->disk_name : DEVICE_NAME);
+			}
 #endif
-		}
-                else
-                    printk("%s: MWDMA not supported.\n", (cf->gd) ? cf->gd->disk_name : DEVICE_NAME);
-        }
+		} else
+			printk("%s: MWDMA not supported.\n", (cf->gd) ? cf->gd->disk_name : DEVICE_NAME);
+	}
 
 	return result;
 }
@@ -715,7 +699,7 @@ static int ebt3000cf_identify(cf_device_t * cf)
  * @param buffer     Data buffer
  * @param write      Is the a write. Default to a read
  */
-static int ebt3000_cf_transfer(cf_device_t * cf, unsigned long lba_sector,
+static int ebt3000_cf_transfer(struct cf_device *cf, unsigned long lba_sector,
 			       unsigned long num_sectors, char *buffer,
 			       int write)
 {
@@ -744,7 +728,7 @@ static int ebt3000_cf_transfer(cf_device_t * cf, unsigned long lba_sector,
  *
  * @param q      queue of requests
  */
-static void ebt3000_cf_request(struct request_queue * q)
+static void ebt3000_cf_request(struct request_queue *q)
 {
 	/* For some unknown reason, sometimes the kernel calls us with
 	   interrupts disabled. Since the CF is very slow, we just use the
@@ -752,7 +736,7 @@ static void ebt3000_cf_request(struct request_queue * q)
 	   periods of time */
 	struct request *req = elv_next_request(q);
 	if (req) {
-		cf_device_t *cf = req->rq_disk->private_data;
+		struct cf_device *cf = req->rq_disk->private_data;
 		schedule_work(&cf->cf_work);
 	}
 }
@@ -772,7 +756,7 @@ int ebt3000_cf_ioctl(struct inode *inode, struct file *filp,
 {
 	struct block_device *bdev = inode->i_bdev;
 	struct gendisk *disk = bdev->bd_disk;
-	cf_device_t *cf = disk->private_data;
+	struct cf_device *cf = disk->private_data;
 	struct hd_geometry geo;
 	switch (cmd) {
 	case HDIO_GETGEO:
@@ -797,7 +781,7 @@ int ebt3000_cf_ioctl(struct inode *inode, struct file *filp,
  */
 static void ebt3000_cf_work(struct work_struct *work)
 {
-	cf_device_t *cf = container_of(work, cf_device_t, cf_work);
+	struct cf_device *cf = container_of(work, struct cf_device, cf_work);
 	struct request *req = NULL;
 	unsigned long flags;
 
@@ -814,10 +798,12 @@ static void ebt3000_cf_work(struct work_struct *work)
 			int count;
 			/* Give away the lock while we're doing the
 			   slow IOs */
+			spin_unlock_irqrestore(&cf->lock, flags);
 			count = ebt3000_cf_transfer(cf, req->sector,
-					req-> current_nr_sectors,
+					req->current_nr_sectors,
 					req->buffer, rq_data_dir(req));
 			/* We need the lock again to signal completion */
+			spin_lock_irqsave(&cf->lock, flags);
 			if (count == req->current_nr_sectors)
 				end_request(req, 1);
 			else
@@ -846,7 +832,7 @@ static struct block_device_operations ebt3000_cf_ops = {
 static int __init ebt3000_cf_init(void)
 {
 	extern cvmx_bootinfo_t *octeon_bootinfo;
-	cf_device_t *cf = &STATIC_DEVICE;
+	struct cf_device *cf = &STATIC_DEVICE;
 	int major_num;
 	int region;
 
@@ -891,12 +877,12 @@ static int __init ebt3000_cf_init(void)
 	}
 	blk_queue_hardsect_size(cf->queue, KERNEL_SECTOR_SIZE);
 
-        /* None of the following seem to make the request sizes larger
-        ** than 8 blocks (8*512 bytes = 4K = page size) */
-        blk_queue_max_sectors(cf->queue, 256);
-        blk_queue_max_segment_size(cf->queue, 128*1024);
-        blk_queue_max_phys_segments(cf->queue, 32);
-        blk_queue_max_hw_segments(cf->queue, 32);
+	/* None of the following seem to make the request sizes larger
+	** than 8 blocks (8*512 bytes = 4K = page size) */
+	blk_queue_max_sectors(cf->queue, 256);
+	blk_queue_max_segment_size(cf->queue, 128*1024);
+	blk_queue_max_phys_segments(cf->queue, 32);
+	blk_queue_max_hw_segments(cf->queue, 32);
 
 	/* Get registered. */
 	major_num = register_blkdev(0, DEVICE_NAME);
@@ -946,9 +932,9 @@ static int __init ebt3000_cf_init(void)
 
 	return 0;
 
-      out_unregister:
+out_unregister:
 	unregister_blkdev(major_num, DEVICE_NAME);
-      out:
+out:
 	return -ENOMEM;
 }
 
-- 
1.6.0.3

