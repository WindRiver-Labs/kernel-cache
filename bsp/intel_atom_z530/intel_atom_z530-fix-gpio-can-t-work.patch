From 730b0c1dedc0b10d7a9e28ffe3b6859a55f5284e Mon Sep 17 00:00:00 2001
From: Yang Wei <Wei.Yang@windriver.com>
Date: Mon, 7 May 2012 13:46:25 +0800
Subject: [PATCH] intel_atom_z530: fix gpio can't work.

Echoing "0" or "1" into /sys/class/gpio/gpioX/value cannot alter
the output of GPIO pins. The patch fixes the issue.

Signed-off-by: Wei Yang <wei.yang@windriver.com>
Integrated-by: jiaxi liu <jiaxi.liu@windriver.com>

Signed-off-by: jiaxi liu <jiaxi.liu@windriver.com>
---
 drivers/gpio/nano8044_gpio.c |  153 +++++++++++++++++++++++++-----------------
 1 files changed, 92 insertions(+), 61 deletions(-)

diff --git a/drivers/gpio/nano8044_gpio.c b/drivers/gpio/nano8044_gpio.c
index cad7027..53183a1 100644
--- a/drivers/gpio/nano8044_gpio.c
+++ b/drivers/gpio/nano8044_gpio.c
@@ -25,47 +25,68 @@
  * Windriver Corporation
  */
 
-
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/pci.h>
+#include <linux/ioport.h>
 #include <linux/gpio.h>
 
 #define DRVNAME "8044_gpio"
+/*
+ *  CR means CONFIGURATION REGISTER here,
+ *  LD means Logical Device here.
+ */
+/*
+ * IO PORT 2E is H/W strapped and named as EFIR (Extended Function Index
+ * Register, for identifying CR index number
+ */
+#define IO_EFIR (0x2E)		/* I/O configuration mode address */
+/*
+ * IO port 0x2F is H/W strapped and named as EFDR (Extend Function Data
+ * Register, for accessing desired CR.
+ */
+#define IO_EFDR (0x2F)		/* I/O port's configuration address */
+/*
+ * CR00-2F: Gobal Control Register. (ALL logical devices share these CRs
+ */
 
-/* CR means CONFIGURATION REGISTER here, */
-#define CR_2E (0x2E)	/* I/O configuration mode address */
-#define CR_4E (0x4E)	/* I/O port's configuration address */
-#define CR_2A (0x2A)	/* I2C Pin Select address */
-#define CR_2C (0x2C)	/* Multi-function Pin Select address */
-#define CR_30 (0x30)	/* Enable logical device active address */
-#define CR_F0 (0xF0)	/* GPI or GPO select address */
-#define CR_F1 (0xF1)	/* Output High or Low select address */
-
-static inline void
-superio_outb(int ioreg, int reg, int val)
+#define CR_07 (0x07)		/* Logical Device selection */
+#define CR_2A (0x2A)		/* I2C Pin Select address */
+#define CR_2C (0x2C)		/* Multi-function Pin Select address */
+/*
+ * The ninth Logical Device of Super IO
+ */
+#define LD_09 (0x09)           /* The LD provide GPIO functionality */
+/* The configuration registers of the ninth logical device */
+#define CR_30 (0x30)		/* Enable logical device active address */
+#define CR_E7 (0xE7)		/* Status Register */
+#define CR_F0 (0xF0)		/* GPI or GPO select address */
+#define CR_F1 (0xF1)		/* Output High or Low select address */
+#define CR_F2 (0xF2)		/* Inversion Register */
+#define CR_FE (0xFE)		/* Input detected type Register */
+
+static inline void superio_outb(int ioreg, int reg, int val)
 {
-    outb(reg, ioreg);
-    outb(val, ioreg + 1);
+	outb(reg, ioreg);
+	outb(val, ioreg + 1);
 }
 
-static inline u8
-superio_inb(int ioreg, int reg)
+static inline u8 superio_inb(int ioreg, int reg)
 {
-    outb(reg, ioreg);
-    return inb(ioreg + 1);
+	outb(reg, ioreg);
+	return inb(ioreg + 1);
 }
 
 static inline void superio_enter(int ioreg)
 {
-    outb(0x87, ioreg);
-    outb(0x87, ioreg);
+	outb(0x87, ioreg);
+	outb(0x87, ioreg);
 }
 
 static inline void superio_exit(int ioreg)
 {
-    outb(0x02, ioreg);
-    outb(0x02, ioreg + 1);
+	outb(0x02, ioreg);
+	outb(0x02, ioreg + 1);
 }
 
 static DEFINE_MUTEX(w83627_gpio_lock);
@@ -76,7 +97,7 @@ static void nano8044_free(struct gpio_chip *chip, unsigned offset)
 }
 
 static int nano8044_gpio_direction_input(struct gpio_chip *chip,
-					unsigned offset)
+					 unsigned offset)
 {
 	return 0;
 }
@@ -85,49 +106,60 @@ static int nano8044_gpio_get(struct gpio_chip *chip, unsigned offset)
 {
 	u8 tmp;
 	mutex_lock(&w83627_gpio_lock);
-	
+
+	superio_enter(IO_EFIR);
+	superio_outb(IO_EFIR, 0x07, 0x09);
 	/* Get the status of active GPI port, and shift it to bit 0, clear other bits */
-	tmp = superio_inb(CR_2E, CR_F1);
-	tmp >>= ((offset % 2) * 4 + (offset / 2));
+	tmp = superio_inb(IO_EFIR, CR_F1);
+	tmp >>= offset;
 	tmp &= 0x01;
 
+	superio_exit(IO_EFIR);
 	mutex_unlock(&w83627_gpio_lock);
 	return tmp;
 }
 
 static int nano8044_gpio_direction_output(struct gpio_chip *chip,
-					unsigned offset, int value)
+					  unsigned offset, int value)
 {
 	int res = 0;
 	u8 tmp;
 	mutex_lock(&w83627_gpio_lock);
-	if ((offset % 2 ) != 0) {
-		printk(KERN_INFO"NANO-8044: Only *ODD* pins can be GPO.\n");
-		printk(KERN_INFO"NANO-8044: offset value is  %d.\n", offset);
-		printk(KERN_INFO"NANO-8044: The first GPIO pin is '1'.\n");
+	superio_enter(IO_EFIR);
+	superio_outb(IO_EFIR, 0x07, 0x09);
+	if (offset > 3) {
+		printk(KERN_INFO "NANO-8044: Only *ODD* pins can be GPO.\n");
+		printk(KERN_INFO "NANO-8044: offset value is  %d.\n", offset);
+		printk(KERN_INFO "NANO-8044: The first GPIO pin is '1'.\n");
 		res = -1;
 	} else {
-		tmp = superio_inb(CR_2E, CR_F0);
-		tmp &= ~(1 << (offset / 2));
-		superio_outb(CR_2E, CR_F0, tmp);
+		tmp = superio_inb(IO_EFIR, CR_F0);
+		tmp &= ~(1 << offset);
+		superio_outb(IO_EFIR, CR_F0, tmp);
 	}
+	superio_exit(IO_EFIR);
 	mutex_unlock(&w83627_gpio_lock);
 	return res;
 }
 
 static void nano8044_gpio_set(struct gpio_chip *chip, unsigned offset,
-				int value)
+			      int value)
 {
 	u8 tmp;
 	mutex_lock(&w83627_gpio_lock);
+	superio_enter(IO_EFIR);
 
-	tmp = superio_inb(CR_2E, CR_F1);
+	superio_outb(IO_EFIR, 0x07, 0x09);
+	tmp = superio_inb(IO_EFIR, CR_F1);
 	/* Write the get value to the GPO */
 	if (0 == value)
-		tmp &= ~(1 << (offset / 2));   /* Low Bit */
+		tmp &= ~(1 << offset);	/* Low Bit */
 	else
-		tmp |= 1 << (offset / 2);		/* High Bit */
-	superio_outb(CR_2E, CR_F1, tmp);
+		tmp |= 1 << offset;	/* High Bit */
+	superio_outb(IO_EFIR, CR_F1, tmp);
+	tmp = superio_inb(IO_EFIR, CR_F1);
+	printk(KERN_DEBUG "CR_F1 is %d offset is %d\n", tmp, offset);
+	superio_exit(IO_EFIR);
 
 	mutex_unlock(&w83627_gpio_lock);
 }
@@ -138,17 +170,17 @@ static int nano8044_request(struct gpio_chip *chip, unsigned offset)
 }
 
 static struct gpio_chip w83627dhg_gpio_chip = {
-	.label              = DRVNAME,
-	.owner              = THIS_MODULE,
-	.request            = nano8044_request,
-	.free               = nano8044_free,
-	.direction_input    = nano8044_gpio_direction_input,
-	.get                = nano8044_gpio_get,
-	.direction_output   = nano8044_gpio_direction_output,
-	.set                = nano8044_gpio_set,
-	.base               = 0,
-	.ngpio              = 8,
-	.can_sleep          = 0,
+	.label = DRVNAME,
+	.owner = THIS_MODULE,
+	.request = nano8044_request,
+	.free = nano8044_free,
+	.direction_input = nano8044_gpio_direction_input,
+	.get = nano8044_gpio_get,
+	.direction_output = nano8044_gpio_direction_output,
+	.set = nano8044_gpio_set,
+	.base = 0,
+	.ngpio = 8,
+	.can_sleep = 0,
 };
 
 static void detect_chip(u8 ioaddr)
@@ -161,24 +193,24 @@ static void detect_chip(u8 ioaddr)
 	superio_outb(ioaddr, CR_2A, tmp);
 
 	tmp = superio_inb(ioaddr, CR_2C);
-	tmp &= 0x1F;
+	tmp &= ~0xE0;
 	superio_outb(ioaddr, CR_2C, tmp);
 
-	superio_outb(ioaddr, 0x07, 0x09);
-
+	superio_outb(ioaddr, CR_07, LD_09);
 	tmp = superio_inb(ioaddr, CR_30);
 	tmp |= 0x02;
 	superio_outb(ioaddr, CR_30, tmp);
 
-	superio_outb(ioaddr, 0xFE, 0x77);
-	superio_outb(ioaddr, 0xF2, 0x00);
+	superio_outb(ioaddr, CR_E7, 0x00);
+	superio_outb(ioaddr, CR_FE, 0x77);
+	superio_outb(ioaddr, CR_F2, 0x00);
 
-	/*'1' for input, '0' for output*/
+	/*'1' for input, '0' for output */
 	superio_outb(ioaddr, CR_F0, 0xF0);
 
 	superio_outb(ioaddr, CR_F1, 0x0A);
 
-	tmp = superio_inb(ioaddr, CR_F1);
+	superio_exit(IO_EFIR);
 
 }
 
@@ -186,13 +218,13 @@ static int __init nano8044_gpio_init(void)
 {
 	int err;
 
-	detect_chip(CR_2E);
+	detect_chip(IO_EFIR);
 
 	err = gpiochip_add(&w83627dhg_gpio_chip);
 	if (err < 0)
 		return err;
 
-	printk(KERN_INFO"8044_gpio_init Done.\n");
+	printk(KERN_INFO "8044_gpio_init Done.\n");
 	return 0;
 }
 
@@ -201,8 +233,7 @@ static void __exit nano8044_gpio_exit(void)
 	int err;
 	err = gpiochip_remove(&w83627dhg_gpio_chip);
 
-	superio_exit(CR_2E);
-	printk(KERN_INFO"8044_gpio_exit(%d)\n", err);
+	printk(KERN_INFO "8044_gpio_exit(%d)\n", err);
 }
 
 module_init(nano8044_gpio_init);
-- 
1.7.0

