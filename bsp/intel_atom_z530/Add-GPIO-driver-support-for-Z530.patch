From 21b5ec690669c313a502faee5aaa183bf7abf8ce Mon Sep 17 00:00:00 2001
From: Wang Yucheng <yucheng.wang@windriver.com>
Date: Mon, 23 Nov 2009 14:03:09 +0800
Subject: [PATCH] Add GPIO driver support for Z530

intel_atom_z530: add gpio driver

Signed-off-by: Wang Yucheng <yucheng.wang@windriver.com>
---
 drivers/gpio/Kconfig         |    6 +
 drivers/gpio/Makefile        |    1 +
 drivers/gpio/nano8044_gpio.c |  213 ++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 220 insertions(+), 0 deletions(-)
 create mode 100644 drivers/gpio/nano8044_gpio.c

diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index b4990e2..99ad59e 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -315,4 +315,10 @@ config GPIO_CNS3XXX
 	help
 	  Say yes here to support GPIO device for Cavium's CNS3xxx SoCs.
 
+config NANO_8044_GPIO
+	tristate "GPIO Support for NANO 8044 ITX board"
+	depends on X86 && PCI
+	---help---
+	  The driver provides a GPIO interface to supporting input and outputs.
+
 endif
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index 0530ba5..3997cbb 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -22,6 +22,7 @@ obj-$(CONFIG_GPIO_UCB1400)	+= ucb1400_gpio.o
 obj-$(CONFIG_GPIO_XILINX)	+= xilinx_gpio.o
 obj-$(CONFIG_GPIO_CS5535)	+= cs5535-gpio.o
 obj-$(CONFIG_GPIO_BT8XX)	+= bt8xxgpio.o
+obj-$(CONFIG_NANO_8044_GPIO)+= nano8044_gpio.o
 obj-$(CONFIG_GPIO_IT8761E)	+= it8761e_gpio.o
 obj-$(CONFIG_GPIO_VR41XX)	+= vr41xx_giu.o
 obj-$(CONFIG_GPIO_WM831X)	+= wm831x-gpio.o
diff --git a/drivers/gpio/nano8044_gpio.c b/drivers/gpio/nano8044_gpio.c
new file mode 100644
index 0000000..cad7027
--- /dev/null
+++ b/drivers/gpio/nano8044_gpio.c
@@ -0,0 +1,213 @@
+/*
+ * Author:      Liang Li <Liang.Li@windriver.com>
+ *
+ * Abstract:    This module supports PortWell NANO8044 ITX board, w83726DHG
+ *            All of the driver functions are provided in this file.
+ *
+ * Copyright(c) 2009 Windriver Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * Contact Information:
+ * Windriver Corporation
+ */
+
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/gpio.h>
+
+#define DRVNAME "8044_gpio"
+
+/* CR means CONFIGURATION REGISTER here, */
+#define CR_2E (0x2E)	/* I/O configuration mode address */
+#define CR_4E (0x4E)	/* I/O port's configuration address */
+#define CR_2A (0x2A)	/* I2C Pin Select address */
+#define CR_2C (0x2C)	/* Multi-function Pin Select address */
+#define CR_30 (0x30)	/* Enable logical device active address */
+#define CR_F0 (0xF0)	/* GPI or GPO select address */
+#define CR_F1 (0xF1)	/* Output High or Low select address */
+
+static inline void
+superio_outb(int ioreg, int reg, int val)
+{
+    outb(reg, ioreg);
+    outb(val, ioreg + 1);
+}
+
+static inline u8
+superio_inb(int ioreg, int reg)
+{
+    outb(reg, ioreg);
+    return inb(ioreg + 1);
+}
+
+static inline void superio_enter(int ioreg)
+{
+    outb(0x87, ioreg);
+    outb(0x87, ioreg);
+}
+
+static inline void superio_exit(int ioreg)
+{
+    outb(0x02, ioreg);
+    outb(0x02, ioreg + 1);
+}
+
+static DEFINE_MUTEX(w83627_gpio_lock);
+
+static void nano8044_free(struct gpio_chip *chip, unsigned offset)
+{
+	return;
+}
+
+static int nano8044_gpio_direction_input(struct gpio_chip *chip,
+					unsigned offset)
+{
+	return 0;
+}
+
+static int nano8044_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	u8 tmp;
+	mutex_lock(&w83627_gpio_lock);
+	
+	/* Get the status of active GPI port, and shift it to bit 0, clear other bits */
+	tmp = superio_inb(CR_2E, CR_F1);
+	tmp >>= ((offset % 2) * 4 + (offset / 2));
+	tmp &= 0x01;
+
+	mutex_unlock(&w83627_gpio_lock);
+	return tmp;
+}
+
+static int nano8044_gpio_direction_output(struct gpio_chip *chip,
+					unsigned offset, int value)
+{
+	int res = 0;
+	u8 tmp;
+	mutex_lock(&w83627_gpio_lock);
+	if ((offset % 2 ) != 0) {
+		printk(KERN_INFO"NANO-8044: Only *ODD* pins can be GPO.\n");
+		printk(KERN_INFO"NANO-8044: offset value is  %d.\n", offset);
+		printk(KERN_INFO"NANO-8044: The first GPIO pin is '1'.\n");
+		res = -1;
+	} else {
+		tmp = superio_inb(CR_2E, CR_F0);
+		tmp &= ~(1 << (offset / 2));
+		superio_outb(CR_2E, CR_F0, tmp);
+	}
+	mutex_unlock(&w83627_gpio_lock);
+	return res;
+}
+
+static void nano8044_gpio_set(struct gpio_chip *chip, unsigned offset,
+				int value)
+{
+	u8 tmp;
+	mutex_lock(&w83627_gpio_lock);
+
+	tmp = superio_inb(CR_2E, CR_F1);
+	/* Write the get value to the GPO */
+	if (0 == value)
+		tmp &= ~(1 << (offset / 2));   /* Low Bit */
+	else
+		tmp |= 1 << (offset / 2);		/* High Bit */
+	superio_outb(CR_2E, CR_F1, tmp);
+
+	mutex_unlock(&w83627_gpio_lock);
+}
+
+static int nano8044_request(struct gpio_chip *chip, unsigned offset)
+{
+	return 0;
+}
+
+static struct gpio_chip w83627dhg_gpio_chip = {
+	.label              = DRVNAME,
+	.owner              = THIS_MODULE,
+	.request            = nano8044_request,
+	.free               = nano8044_free,
+	.direction_input    = nano8044_gpio_direction_input,
+	.get                = nano8044_gpio_get,
+	.direction_output   = nano8044_gpio_direction_output,
+	.set                = nano8044_gpio_set,
+	.base               = 0,
+	.ngpio              = 8,
+	.can_sleep          = 0,
+};
+
+static void detect_chip(u8 ioaddr)
+{
+	u8 tmp;
+	superio_enter(ioaddr);
+
+	tmp = superio_inb(ioaddr, CR_2A);
+	tmp &= 0xFD;
+	superio_outb(ioaddr, CR_2A, tmp);
+
+	tmp = superio_inb(ioaddr, CR_2C);
+	tmp &= 0x1F;
+	superio_outb(ioaddr, CR_2C, tmp);
+
+	superio_outb(ioaddr, 0x07, 0x09);
+
+	tmp = superio_inb(ioaddr, CR_30);
+	tmp |= 0x02;
+	superio_outb(ioaddr, CR_30, tmp);
+
+	superio_outb(ioaddr, 0xFE, 0x77);
+	superio_outb(ioaddr, 0xF2, 0x00);
+
+	/*'1' for input, '0' for output*/
+	superio_outb(ioaddr, CR_F0, 0xF0);
+
+	superio_outb(ioaddr, CR_F1, 0x0A);
+
+	tmp = superio_inb(ioaddr, CR_F1);
+
+}
+
+static int __init nano8044_gpio_init(void)
+{
+	int err;
+
+	detect_chip(CR_2E);
+
+	err = gpiochip_add(&w83627dhg_gpio_chip);
+	if (err < 0)
+		return err;
+
+	printk(KERN_INFO"8044_gpio_init Done.\n");
+	return 0;
+}
+
+static void __exit nano8044_gpio_exit(void)
+{
+	int err;
+	err = gpiochip_remove(&w83627dhg_gpio_chip);
+
+	superio_exit(CR_2E);
+	printk(KERN_INFO"8044_gpio_exit(%d)\n", err);
+}
+
+module_init(nano8044_gpio_init);
+module_exit(nano8044_gpio_exit);
+
+MODULE_AUTHOR("Liang Li");
+MODULE_DESCRIPTION("Portwell 8044 ITX board GPIO DRIVER");
+MODULE_LICENSE("GPL");
-- 
1.7.0.4

