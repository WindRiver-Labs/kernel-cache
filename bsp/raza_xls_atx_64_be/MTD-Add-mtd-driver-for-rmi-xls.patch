From c42c3960cd17ef664a281525cd330ed00f9c9f4e Mon Sep 17 00:00:00 2001
From: Liu Changhui <changhui.liu@windriver.com>
Date: Fri, 29 Jan 2010 13:28:06 +0800
Subject: [PATCH] MTD: Add mtd driver for rmi xls

Add mtd driver for rmi xls.

source: from RMI SDK1.7

Signed-off-by: shuo.kang <shuo.kang@windriver.com>
---
 drivers/mtd/maps/Kconfig     |    6 +
 drivers/mtd/maps/Makefile    |    1 +
 drivers/mtd/maps/xlr-flash.c |  129 +++++++++++++++++++
 drivers/mtd/nand/Kconfig     |    4 +
 drivers/mtd/nand/Makefile    |    1 +
 drivers/mtd/nand/nand_base.c |   22 ++++
 drivers/mtd/nand/xls_nand.c  |  281 ++++++++++++++++++++++++++++++++++++++++++
 drivers/mtd/nand/xls_nand.h  |   70 +++++++++++
 include/linux/mtd/map.h      |   37 ++++++
 9 files changed, 551 insertions(+), 0 deletions(-)
 create mode 100644 drivers/mtd/maps/xlr-flash.c
 create mode 100644 drivers/mtd/nand/xls_nand.c
 create mode 100644 drivers/mtd/nand/xls_nand.h

diff --git a/drivers/mtd/maps/Kconfig b/drivers/mtd/maps/Kconfig
index 5c79fc2..e0d8eaa 100644
--- a/drivers/mtd/maps/Kconfig
+++ b/drivers/mtd/maps/Kconfig
@@ -257,6 +257,12 @@ config MTD_ALCHEMY
 	help
 	  Flash memory access on AMD Alchemy Pb/Db/RDK Reference Boards
 
+config MTD_SPS
+	tristate "SPS Flash MTD support"
+	depends on RMI_PHOENIX 
+	help
+	  Flash memory access on SPS Reference Boards
+
 config MTD_DILNETPC
 	tristate "CFI Flash device mapped on DIL/Net PC"
 	depends on X86 && MTD_CONCAT && MTD_PARTITIONS && MTD_CFI_INTELEXT
diff --git a/drivers/mtd/maps/Makefile b/drivers/mtd/maps/Makefile
index 9e17291..5300b47 100644
--- a/drivers/mtd/maps/Makefile
+++ b/drivers/mtd/maps/Makefile
@@ -65,4 +65,5 @@ obj-$(CONFIG_MTD_PLATRAM)	+= plat-ram.o
 obj-$(CONFIG_MTD_OMAP_NOR)	+= omap_nor.o
 obj-$(CONFIG_MTD_INTEL_VR_NOR)	+= intel_vr_nor.o
 obj-$(CONFIG_MTD_BFIN_ASYNC)	+= bfin-async-flash.o
+obj-$(CONFIG_MTD_SPS)      += xlr-flash.o
 obj-$(CONFIG_MTD_ATMEL49XX_FLASH)   += atmel49xx_flash.o atmel49xx_uflash.o
diff --git a/drivers/mtd/maps/xlr-flash.c b/drivers/mtd/maps/xlr-flash.c
new file mode 100644
index 0000000..f7e2550
--- /dev/null
+++ b/drivers/mtd/maps/xlr-flash.c
@@ -0,0 +1,129 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+/*
+ * Flash memory access on XLR evaluation boards
+ *
+ * (C) 2008, 2009  RMI Corp <sandip@rmicorp.com>
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/io.h>
+#include <asm/rmi/sim.h>
+
+#ifdef 	DEBUG_RW
+#define	DBG(x...)	printk(x)
+#else
+#define	DBG(x...)
+#endif
+
+#define BOARD_MAP_NAME "SPS Flash"
+#define BOARD_FLASH_SIZE 0x01000000 /* 16MB */
+#define BOARD_FLASH_BASE 0x1c000000 
+#define BOARD_FLASH_WIDTH 2 /* 16-bits */
+
+static struct map_info sps_map = {
+	.name =	BOARD_MAP_NAME,
+};
+
+static struct mtd_partition sps_partitions[] = {
+        {
+                .name = "User FS",
+                .offset = 0x800000, // Upto 8 MB is used by bootloader.
+		.size = MTDPART_SIZ_FULL ,
+        }
+};
+
+static struct mtd_info *mymtd;
+
+int __init sps_mtd_init(void)
+{
+	struct mtd_partition *parts;
+	int nb_parts = 0;
+	unsigned long window_addr;
+	unsigned long window_size;
+
+	if (xlr_board_atx_viii()){
+		return -ENODEV;
+	}
+	/* Default flash buswidth */
+	sps_map.bankwidth = BOARD_FLASH_WIDTH;
+
+	window_addr = BOARD_FLASH_BASE;
+	window_size = BOARD_FLASH_SIZE;
+
+	/*
+	 * Static partition definition selection
+	 */
+	parts = sps_partitions;
+	nb_parts = ARRAY_SIZE(sps_partitions);
+	sps_map.size = window_size;
+
+	/*
+	 * Now let's probe for the actual flash.  Do it here since
+	 * specific machine settings might have been set above.
+	 */
+	printk(KERN_NOTICE BOARD_MAP_NAME ": probing %d-bit flash bus\n",
+			sps_map.bankwidth*8);
+	sps_map.virt = ioremap(window_addr, window_size);
+	mymtd = do_map_probe("cfi_probe", &sps_map);
+	if (!mymtd) {
+		iounmap(sps_map.virt);
+		return -ENXIO;
+	}
+	mymtd->owner = THIS_MODULE;
+
+	add_mtd_partitions(mymtd, parts, nb_parts);
+	return 0;
+}
+
+static void __exit sps_mtd_cleanup(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+		iounmap(sps_map.virt);
+	}
+}
+
+module_init(sps_mtd_init);
+module_exit(sps_mtd_cleanup);
+
+MODULE_AUTHOR("Sandip Matte, RMI Corporation");
+MODULE_DESCRIPTION(BOARD_MAP_NAME " MTD driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
index 236fb65..e8f60a3 100644
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -425,4 +425,8 @@ config MTD_NAND_FSL_UPM
 	  Enables support for NAND Flash chips wired onto Freescale PowerPC
 	  processor localbus with User-Programmable Machine support.
 
+config MTD_NAND_XLS
+        tristate "Support for NAND Flash on XLS"
+        depends on MTD_NAND && RMI_PHOENIX
+
 endif # MTD_NAND
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index ba42584..4e12fb6 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -37,5 +37,6 @@ obj-$(CONFIG_MTD_NAND_PASEMI)		+= pasemi_nand.o
 obj-$(CONFIG_MTD_NAND_ORION)		+= orion_nand.o
 obj-$(CONFIG_MTD_NAND_FSL_ELBC)		+= fsl_elbc_nand.o
 obj-$(CONFIG_MTD_NAND_FSL_UPM)		+= fsl_upm.o
+obj-$(CONFIG_MTD_NAND_XLS)		+= xls_nand.o
 
 nand-objs := nand_base.o nand_bbt.o
diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c
index d1129ba..d4f9d99 100644
--- a/drivers/mtd/nand/nand_base.c
+++ b/drivers/mtd/nand/nand_base.c
@@ -82,6 +82,8 @@ static struct nand_ecclayout nand_oob_64 = {
 		 .length = 38}}
 };
 
+static int nand_manufacturer;
+
 static int nand_get_device(struct nand_chip *chip, struct mtd_info *mtd,
 			   int new_state);
 
@@ -507,6 +509,11 @@ static void nand_command(struct mtd_info *mtd, unsigned int command,
 	case NAND_CMD_STATUS:
 		return;
 
+	/* In case of micron nand, we need to return */
+	case NAND_CMD_READID:
+		udelay(chip->chip_delay);
+		return;
+
 	case NAND_CMD_RESET:
 		if (chip->dev_ready)
 			break;
@@ -551,6 +558,7 @@ static void nand_command_lp(struct mtd_info *mtd, unsigned int command,
 			    int column, int page_addr)
 {
 	register struct nand_chip *chip = mtd->priv;
+	int micron_chip = 0;
 
 	/* Emulate NAND_CMD_READOOB */
 	if (command == NAND_CMD_READOOB) {
@@ -586,6 +594,14 @@ static void nand_command_lp(struct mtd_info *mtd, unsigned int command,
 	}
 	chip->cmd_ctrl(mtd, NAND_CMD_NONE, NAND_NCE | NAND_CTRL_CHANGE);
 
+	if ((mtd->name) && (nand_manufacturer == NAND_MFR_MICRON))
+		micron_chip = 1;
+
+	if (micron_chip) {
+		if (command == NAND_CMD_READID)
+			return;
+	}
+
 	/*
 	 * program and erase have their own busy handlers
 	 * status, sequential in, and deplete1 need no delay
@@ -655,6 +671,10 @@ static void nand_command_lp(struct mtd_info *mtd, unsigned int command,
 	ndelay(100);
 
 	nand_wait_ready(mtd);
+	if ((micron_chip) && (command == NAND_CMD_READ0)) {
+		chip->cmd_ctrl(mtd, NAND_CMD_READ0,
+			       NAND_CLE | NAND_CTRL_CHANGE);
+	}
 }
 
 /**
@@ -2452,6 +2472,8 @@ static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
 	       " 0x%02x, Chip ID: 0x%02x (%s %s)\n", *maf_id, dev_id,
 	       nand_manuf_ids[maf_idx].name, type->name);
 
+	nand_manufacturer =  *maf_id;
+
 	return type;
 }
 
diff --git a/drivers/mtd/nand/xls_nand.c b/drivers/mtd/nand/xls_nand.c
new file mode 100644
index 0000000..45f1826
--- /dev/null
+++ b/drivers/mtd/nand/xls_nand.c
@@ -0,0 +1,281 @@
+/*
+ * drivers/mtd/nand/xls_nand.c
+ *
+ *  Copyright (C) 2007 Raza microelectronics Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/genhd.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/nand_ecc.h>
+#include <linux/mtd/partitions.h>
+#include <linux/interrupt.h>
+#include <asm/io.h>
+#include <asm/rmi/sim.h>
+
+#include "xls_nand.h"
+
+static u8 hwctl;
+static void __iomem *xls_io_base;
+static int xls_nand_phys_base = 0xBD800000;
+
+/* register offset */
+#define FLASHIO	 	0xBD800000		/* Flash I/O */
+
+/*
+ * MTD structure for xls
+ */
+static struct mtd_info *xls_mtd= NULL;
+
+/*
+ * Define partitions for flash device
+ */
+#define DEFAULT_NUM_PARTITIONS 2
+
+#define CLE_REG (0xbef19240 + (long)(((struct nand_chip *)(mtd->priv))->priv) * 4)
+#define ALE_REG (0xbef19280 + (long)(((struct nand_chip *)(mtd->priv))->priv) * 4)
+#define RW_OFFSET  0xbd800000 
+
+#define WRITE_NAND_CLE(command)(nand_write_cmd((long)(int)CLE_REG, command))
+#define WRITE_NAND_ALE(address)(nand_write_addr((long)(int)ALE_REG, address))
+#define WRITE_NAND_ARRAY(data,n) (nand_write_multi((long)(int)RW_OFFSET, data, n))
+#define READ_NAND_BYTE(data)(nand_read_byte((long)(int)RW_OFFSET, &(data)))
+#define READ_NAND_ARRAY(data,n) (nand_read_multi((long)(int)RW_OFFSET, data, n))
+
+
+static int nr_partitions;
+static struct mtd_partition xls_nand_default_partition_info[] = {
+	{
+	.name = "Root Filesystem",
+	.offset = 64 * 64 * 2048, /* 54M@8M */
+	.size = 432 * 64 * 2048,
+	},
+	{
+	.name = "Home Filesystem",
+	.offset = MTDPART_OFS_APPEND , /* Rest@62M */
+	.size = MTDPART_SIZ_FULL ,
+	},
+};
+
+/*
+ *	hardware specific access to control-lines
+ *	In case of xls, we remember the access, and accordingly do read/write of
+ *	ale/cle or IO.
+ */
+static void xls_nand_hwcontrol(struct mtd_info *mtd, int cmd,
+				   unsigned int ctrl)
+{
+	unsigned char bits = ctrl & 0x07;
+
+		if (bits & NAND_CLE)
+			WRITE_NAND_CLE(cmd);
+		else if (bits & NAND_ALE)
+			WRITE_NAND_ALE(cmd);
+}
+
+#define STATUS_BIT_0 0x01
+#define STATUS_BIT_6 0x40
+#define MAX_READ_STATUS_COUNT 100000
+#define NAND_CMD_READ_STATUS 0x70
+
+int nand_read_status(struct mtd_info *mtd)
+{
+	int status_count;
+	unsigned char status;
+
+	WRITE_NAND_CLE(NAND_CMD_READ_STATUS);		
+	status_count = 0;
+
+	while(status_count < MAX_READ_STATUS_COUNT)
+	{
+		/* Read status byte */
+		READ_NAND_BYTE(status);
+		/* Check status */
+		if((status& STATUS_BIT_6) == STATUS_BIT_6)  /* if 1, device is ready */
+		{
+			if((status& STATUS_BIT_0) == 0)	/* if 0, the last operation was succesful */
+				return 1;
+			else
+				return 0;
+		}			
+		status_count++;
+	}
+
+	return 0;
+}
+
+static unsigned char xls_nand_read_byte(struct mtd_info *mtd)
+{
+	unsigned char x;
+	READ_NAND_BYTE(x);
+	return x;
+}
+
+static void xls_nand_write_buf(struct mtd_info *mtd, const unsigned char *buf, int len)
+{
+	int i;
+    unsigned char *tmp = (unsigned char *)buf;
+
+	for (i = 0; i < len; i++) {
+		WRITE_NAND_ARRAY((void *)&tmp[i],1);
+	}
+}
+
+static void xls_nand_read_buf(struct mtd_info *mtd, unsigned char *buf, int len)
+{
+	READ_NAND_ARRAY(buf,len);
+}
+
+static int xls_nand_verify_buf(struct mtd_info *mtd, const unsigned char *buf, int len)
+{
+	int i;
+	unsigned char temp_byte;
+
+	for (i = 0; i < len; i++) {
+		READ_NAND_BYTE(temp_byte);
+		if (buf[i] != temp_byte)
+			return i;
+	}
+
+	return 0;
+}
+
+static int xls_nand_dev_ready(struct mtd_info *mtd)
+{
+	return nand_read_status(mtd);
+}
+
+#ifdef CONFIG_MTD_PARTITIONS
+const char *part_probes[] = { "cmdlinepart", NULL };
+#endif
+
+/*
+ * Main initialization routine
+ */
+int __init
+xls_nand_init(void)
+{
+	struct nand_chip *this;
+	struct mtd_partition* xls_partition_info;
+	int err = 0;
+	uint32_t nand_gpio_check;
+	uint32_t read_cs_base;
+	int nand_chip_select;
+	
+	hwctl = 0;
+
+	if (!is_xls())
+		return -ENODEV;
+
+
+	/* nand is present */
+	nand_gpio_check = *(uint32_t *)((long)(int)(0xbef00000 + 0x18000 + 84));
+	if ((nand_gpio_check >> 16) & 0x1)
+		nand_chip_select = 0;
+	else
+		nand_chip_select = 2;
+	
+	read_cs_base = *(uint32_t *)((long)(int)(0xbef19000 + nand_chip_select * 4));
+
+	read_cs_base = read_cs_base & 0xffff;
+
+	if (read_cs_base  != 384) { /* This checks if flash bar is mapped at
+				       0xbd800000 */
+		printk ("Burn bootloader version > 1.4.2 to use nand flash\n");
+		return -ENODEV;
+	}
+	/* Allocate memory for MTD device structure and private data */
+	xls_mtd = kmalloc(sizeof(struct mtd_info) + sizeof(struct nand_chip),
+				GFP_KERNEL);
+	if (!xls_mtd) {
+		printk ("Unable to allocate xls NAND MTD device structure.\n");
+		return -ENOMEM;
+	}
+
+	/* map physical adress */
+	xls_io_base = ioremap((long)xls_nand_phys_base, 0x1000);
+	if(!xls_io_base){
+		printk("ioremap to access XLS NAND chip failed\n");
+		kfree(xls_mtd);
+		return -EIO;
+	}
+
+	/* Get pointer to private data */
+	this = (struct nand_chip *) (&xls_mtd[1]);
+
+	/* Initialize structures */
+	memset((char *) xls_mtd, 0, sizeof(struct mtd_info));
+	memset((char *) this, 0, sizeof(struct nand_chip));
+
+	/* Link the private data with the MTD structure */
+	xls_mtd->priv = this;
+
+	/* Set address of NAND IO lines */
+	this->IO_ADDR_R = (char *)(long)(int)FLASHIO;
+	this->IO_ADDR_W = (char *)(long)(int)FLASHIO;
+	/* Set address of hardware control function */
+	this->cmd_ctrl = xls_nand_hwcontrol;
+	this->dev_ready = xls_nand_dev_ready;
+	this->read_byte  = xls_nand_read_byte;
+	this->write_buf  = xls_nand_write_buf;
+	this->read_buf   = xls_nand_read_buf;
+	this->verify_buf = xls_nand_verify_buf;
+	
+	/* 15 us command delay time */
+	this->chip_delay = 15;
+	this->ecc.mode = NAND_ECC_SOFT;
+	this->priv = (void *)(unsigned long)nand_chip_select;
+
+	/* Scan to find existence of the device */
+	err=nand_scan(xls_mtd,1);
+	if (err) {
+		iounmap(xls_io_base);
+		kfree(xls_mtd);
+		return err;
+	}
+
+	xls_mtd->name = "xls-nand";
+	/* Register the partitions */
+#ifdef CONFIG_MTD_PARTITIONS
+	nr_partitions = parse_mtd_partitions(xls_mtd, part_probes,
+						&xls_partition_info, 0);
+#endif 
+
+	if (nr_partitions <= 0) {
+		nr_partitions = DEFAULT_NUM_PARTITIONS;
+		xls_partition_info = xls_nand_default_partition_info;
+	}
+
+	add_mtd_partitions(xls_mtd, xls_partition_info, nr_partitions);
+
+	return 0;
+}
+module_init(xls_nand_init);
+
+#ifdef MODULE
+static void __exit xls_nand_cleanup(void)
+{
+	struct nand_chip *this = (struct nand_chip *) &xls_mtd[1];
+
+	/* Release resources, unregister device */
+	nand_release(xls_mtd);
+
+	iounmap(xls_io_base);
+
+	/* Free the MTD device structure */
+	kfree(xls_mtd);
+}
+module_exit(xls_nand_cleanup);
+#endif
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Raza Micronelectronics <sandip@razamicro.com>");
+MODULE_DESCRIPTION("Device specific logic for NAND flash on XLS Series");
diff --git a/drivers/mtd/nand/xls_nand.h b/drivers/mtd/nand/xls_nand.h
new file mode 100644
index 0000000..bc60a20
--- /dev/null
+++ b/drivers/mtd/nand/xls_nand.h
@@ -0,0 +1,70 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+#ifndef __XLS_NAND_H__
+#define __XLS_NAND_H__
+
+static void nand_write_cmd(unsigned long offset, unsigned char cmd)
+{
+	*(volatile uint32_t *)offset = (uint32_t)cmd;
+}
+
+static void nand_write_addr(unsigned long offset, unsigned char addr)
+{
+	*(volatile uint32_t *)offset = (uint32_t)addr;
+}
+
+static void nand_read_multi(unsigned long offset, void *buf, unsigned short len)
+{
+	int i;
+	volatile unsigned char *tbuf = (volatile unsigned char *)buf;
+
+	for (i = 0; i < len; i++) {
+		*tbuf = *(volatile unsigned char *)offset;
+		tbuf++;
+	}
+}
+
+static void nand_read_byte(unsigned long offset, void *buf)
+{
+	*(volatile unsigned char *) buf = *(volatile unsigned char *)offset;
+}
+
+static void nand_write_multi(unsigned long offset, void *buf, unsigned short len)
+{
+	int i;
+	volatile unsigned char *tbuf = (volatile char *)buf;
+
+	for (i = 0; i < len; i++) {
+		*(volatile unsigned char *)offset = *(volatile unsigned char *)tbuf;
+		tbuf++;
+	}
+}
+
+#endif /* __XLS_NAND_H__ */
diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h
index aa30244..dde5509 100644
--- a/include/linux/mtd/map.h
+++ b/include/linux/mtd/map.h
@@ -13,6 +13,9 @@
 #include <asm/unaligned.h>
 #include <asm/system.h>
 #include <asm/io.h>
+#ifdef CONFIG_RMI_PHOENIX
+#include <asm/rmi/iomap.h>
+#endif
 
 #ifdef CONFIG_MTD_MAP_BANK_WIDTH_1
 #define map_bankwidth(map) 1
@@ -372,6 +375,12 @@ static inline map_word map_word_ff(struct map_info *map)
 static inline map_word inline_map_read(struct map_info *map, unsigned long ofs)
 {
 	map_word r;
+#ifdef CONFIG_RMI_PHOENIX
+	unsigned int flags=0;
+	
+	flags = rmi_br_read_lock();
+
+#endif
 
 	if (map_bankwidth_is_1(map))
 		r.x[0] = __raw_readb(map->virt + ofs);
@@ -386,11 +395,20 @@ static inline map_word inline_map_read(struct map_info *map, unsigned long ofs)
 	else if (map_bankwidth_is_large(map))
 		memcpy_fromio(r.x, map->virt+ofs, map->bankwidth);
 
+#ifdef CONFIG_RMI_PHOENIX
+	rmi_br_read_unlock(flags);
+#endif
 	return r;
 }
 
 static inline void inline_map_write(struct map_info *map, const map_word datum, unsigned long ofs)
 {
+#ifdef CONFIG_RMI_PHOENIX
+	unsigned int flags=0;
+	
+	flags = rmi_br_write_lock();
+
+#endif
 	if (map_bankwidth_is_1(map))
 		__raw_writeb(datum.x[0], map->virt + ofs);
 	else if (map_bankwidth_is_2(map))
@@ -404,19 +422,38 @@ static inline void inline_map_write(struct map_info *map, const map_word datum,
 	else if (map_bankwidth_is_large(map))
 		memcpy_toio(map->virt+ofs, datum.x, map->bankwidth);
 	mb();
+#ifdef CONFIG_RMI_PHOENIX
+	rmi_br_write_unlock(flags);
+#endif
 }
 
 static inline void inline_map_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
 {
+#ifdef CONFIG_RMI_PHOENIX
+	unsigned int flags=0;
+	
+	flags = rmi_br_write_lock();
+#endif
 	if (map->cached)
 		memcpy(to, (char *)map->cached + from, len);
 	else
 		memcpy_fromio(to, map->virt + from, len);
+#ifdef CONFIG_RMI_PHOENIX
+	rmi_br_write_unlock(flags);
+#endif
 }
 
 static inline void inline_map_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
 {
+#ifdef CONFIG_RMI_PHOENIX
+	unsigned int flags=0;
+	
+	flags = rmi_br_write_lock();
+#endif
 	memcpy_toio(map->virt + to, from, len);
+#ifdef CONFIG_RMI_PHOENIX
+	rmi_br_write_unlock(flags);
+#endif
 }
 
 #ifdef CONFIG_MTD_COMPLEX_MAPPINGS
-- 
1.6.0.4

