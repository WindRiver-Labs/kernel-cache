From db0127c16bd824241ae7dd8591ad586cd9fdce68 Mon Sep 17 00:00:00 2001
From: Liu Changhui <changhui.liu@windriver.com>
Date: Fri, 29 Jan 2010 13:28:00 +0800
Subject: [PATCH] Platform: Add header files for rmi xls

Add header files for rmi xls.

source: from RMI SDK1.7

Signed-off-by: shuo.kang <shuo.kang@windriver.com>
---
 include/asm-mips/addrspace.h                |    4 +
 include/asm-mips/asmmacro.h                 |   25 ++
 include/asm-mips/atomic.h                   |   24 ++
 include/asm-mips/elf.h                      |    1 +
 include/asm-mips/hazards.h                  |    2 +
 include/asm-mips/mach-rmi/war.h             |   25 ++
 include/asm-mips/mipsregs.h                 |   14 +
 include/asm-mips/mman.h                     |    5 +
 include/asm-mips/mmu_context.h              |   15 +-
 include/asm-mips/msi.h                      |   28 ++
 include/asm-mips/offset.h                   |  208 ++++++++++++
 include/asm-mips/rmi/64bit.h                |   84 +++++
 include/asm-mips/rmi/atx_cpld.h             |   64 ++++
 include/asm-mips/rmi/debug.h                |  117 +++++++
 include/asm-mips/rmi/devices.h              |   46 +++
 include/asm-mips/rmi/gpio.h                 |   77 +++++
 include/asm-mips/rmi/interrupt.h            |   55 ++++
 include/asm-mips/rmi/io.h                   |   53 +++
 include/asm-mips/rmi/iomap.h                |  275 ++++++++++++++++
 include/asm-mips/rmi/memory-exclusion.h     |   38 +++
 include/asm-mips/rmi/mips-exts.h            |  461 +++++++++++++++++++++++++++
 include/asm-mips/rmi/msidef.h               |   73 +++++
 include/asm-mips/rmi/perf_ctr.h             |   72 +++++
 include/asm-mips/rmi/phnx_loader.h          |  175 ++++++++++
 include/asm-mips/rmi/phnx_user_mac.h        |   61 ++++
 include/asm-mips/rmi/phoenix_flash_pcmcia.h |  116 +++++++
 include/asm-mips/rmi/phoenix_ide.h          |   62 ++++
 include/asm-mips/rmi/proc.h                 |   51 +++
 include/asm-mips/rmi/rmi_pcix_gen_dev.h     |  124 +++++++
 include/asm-mips/rmi/rmi_rw_lock.h          |  221 +++++++++++++
 include/asm-mips/rmi/rmi_srio.h             |  343 ++++++++++++++++++++
 include/asm-mips/rmi/sim.h                  |  443 +++++++++++++++++++++++++
 include/asm-mips/rmi/utils.h                |   88 +++++
 include/asm-mips/rmi/xlr_pcix_boot.h        |   42 +++
 include/asm-mips/serial.h                   |   21 ++
 include/linux/libata.h                      |    2 +-
 include/linux/mm.h                          |    5 +
 include/linux/skbuff.h                      |   16 +
 include/linux/syscalls.h                    |   11 +
 include/user/rmi/phnx_loader.h              |  153 +++++++++
 40 files changed, 3697 insertions(+), 3 deletions(-)
 create mode 100644 include/asm-mips/mach-rmi/war.h
 create mode 100644 include/asm-mips/msi.h
 create mode 100644 include/asm-mips/offset.h
 create mode 100644 include/asm-mips/rmi/64bit.h
 create mode 100644 include/asm-mips/rmi/atx_cpld.h
 create mode 100644 include/asm-mips/rmi/debug.h
 create mode 100644 include/asm-mips/rmi/devices.h
 create mode 100644 include/asm-mips/rmi/gpio.h
 create mode 100644 include/asm-mips/rmi/interrupt.h
 create mode 100644 include/asm-mips/rmi/io.h
 create mode 100644 include/asm-mips/rmi/iomap.h
 create mode 100644 include/asm-mips/rmi/memory-exclusion.h
 create mode 100644 include/asm-mips/rmi/mips-exts.h
 create mode 100644 include/asm-mips/rmi/msidef.h
 create mode 100644 include/asm-mips/rmi/perf_ctr.h
 create mode 100644 include/asm-mips/rmi/phnx_loader.h
 create mode 100644 include/asm-mips/rmi/phnx_user_mac.h
 create mode 100644 include/asm-mips/rmi/phoenix_flash_pcmcia.h
 create mode 100644 include/asm-mips/rmi/phoenix_ide.h
 create mode 100644 include/asm-mips/rmi/proc.h
 create mode 100644 include/asm-mips/rmi/rmi_pcix_gen_dev.h
 create mode 100644 include/asm-mips/rmi/rmi_rw_lock.h
 create mode 100644 include/asm-mips/rmi/rmi_srio.h
 create mode 100644 include/asm-mips/rmi/sim.h
 create mode 100644 include/asm-mips/rmi/utils.h
 create mode 100644 include/asm-mips/rmi/xlr_pcix_boot.h
 create mode 100644 include/user/rmi/phnx_loader.h

diff --git a/include/asm-mips/addrspace.h b/include/asm-mips/addrspace.h
index 569f80a..9b5e0a7 100644
--- a/include/asm-mips/addrspace.h
+++ b/include/asm-mips/addrspace.h
@@ -134,7 +134,11 @@
  * the region, 3 bits for the CCA mode.  This leaves 59 bits of which the
  * R8000 implements most with its 48-bit physical address space.
  */
+#ifdef CONFIG_CPU_PHOENIX
+#define TO_PHYS_MASK	_CONST64_(0x000000ffffffffff)	/* 2^^40 - 1 */
+#else
 #define TO_PHYS_MASK	_CONST64_(0x07ffffffffffffff)	/* 2^^59 - 1 */
+#endif
 
 #ifndef CONFIG_CPU_R8000
 
diff --git a/include/asm-mips/asmmacro.h b/include/asm-mips/asmmacro.h
index 7a88175..3d0d24c 100644
--- a/include/asm-mips/asmmacro.h
+++ b/include/asm-mips/asmmacro.h
@@ -20,6 +20,27 @@
 #include <asm/mipsmtregs.h>
 #endif
 
+#ifdef CONFIG_PREEMPT
+
+.macro __preempt_disable
+lw  t0, TI_PRE_COUNT($28);
+addiu t0, 1;
+sw t0, TI_PRE_COUNT($28);
+.endm
+
+.macro __preempt_enable
+lw  t0, TI_PRE_COUNT($28)
+subu t0, 1
+sw t0, TI_PRE_COUNT($28)
+.endm
+
+#else
+
+#define __preempt_disable
+#define __preempt_enable
+
+#endif
+
 #ifdef CONFIG_MIPS_MT_SMTC
 	.macro	local_irq_enable reg=t0
 	mfc0	\reg, CP0_TCSTATUS
@@ -37,17 +58,21 @@
 	.endm
 #else
 	.macro	local_irq_enable reg=t0
+	__preempt_disable
 	mfc0	\reg, CP0_STATUS
 	ori	\reg, \reg, 1
 	mtc0	\reg, CP0_STATUS
+	__preempt_enable
 	irq_enable_hazard
 	.endm
 
 	.macro	local_irq_disable reg=t0
+	__preempt_disable
 	mfc0	\reg, CP0_STATUS
 	ori	\reg, \reg, 1
 	xori	\reg, \reg, 1
 	mtc0	\reg, CP0_STATUS
+	__preempt_enable
 	irq_disable_hazard
 	.endm
 #endif /* CONFIG_MIPS_MT_SMTC */
diff --git a/include/asm-mips/atomic.h b/include/asm-mips/atomic.h
index 1232be3..75a3aad 100644
--- a/include/asm-mips/atomic.h
+++ b/include/asm-mips/atomic.h
@@ -20,6 +20,10 @@
 #include <asm/war.h>
 #include <asm/system.h>
 
+#ifdef CONFIG_RMI_PHOENIX
+#include <asm/rmi/mips-exts.h>
+#endif
+
 typedef struct { volatile int counter; } atomic_t;
 
 #define ATOMIC_INIT(i)    { (i) }
@@ -50,6 +54,9 @@ typedef struct { volatile int counter; } atomic_t;
  */
 static __inline__ void atomic_add(int i, atomic_t * v)
 {
+#ifdef CONFIG_RMI_PHOENIX
+	ldadd_w_no_read(i, &v->counter);
+#else
 	if (cpu_has_llsc && R10000_LLSC_WAR) {
 		unsigned long temp;
 
@@ -84,6 +91,7 @@ static __inline__ void atomic_add(int i, atomic_t * v)
 		v->counter += i;
 		raw_local_irq_restore(flags);
 	}
+#endif
 }
 
 /*
@@ -95,6 +103,9 @@ static __inline__ void atomic_add(int i, atomic_t * v)
  */
 static __inline__ void atomic_sub(int i, atomic_t * v)
 {
+#ifdef CONFIG_RMI_PHOENIX
+	ldadd_w_no_read(-i,&v->counter);
+#else
 	if (cpu_has_llsc && R10000_LLSC_WAR) {
 		unsigned long temp;
 
@@ -129,6 +140,7 @@ static __inline__ void atomic_sub(int i, atomic_t * v)
 		v->counter -= i;
 		raw_local_irq_restore(flags);
 	}
+#endif
 }
 
 /*
@@ -140,6 +152,12 @@ static __inline__ int atomic_add_return(int i, atomic_t * v)
 
 	smp_llsc_mb();
 
+#ifdef CONFIG_RMI_PHOENIX
+	result = ldadd_w(i, &v->counter);
+	result += i;
+#else
+
+
 	if (cpu_has_llsc && R10000_LLSC_WAR) {
 		unsigned long temp;
 
@@ -181,6 +199,7 @@ static __inline__ int atomic_add_return(int i, atomic_t * v)
 		raw_local_irq_restore(flags);
 	}
 
+#endif
 	smp_llsc_mb();
 
 	return result;
@@ -191,6 +210,10 @@ static __inline__ int atomic_sub_return(int i, atomic_t * v)
 	unsigned long result;
 
 	smp_llsc_mb();
+#ifdef CONFIG_RMI_PHOENIX
+	result = ldadd_w(-i, &v->counter);
+	result -= i;
+#else
 
 	if (cpu_has_llsc && R10000_LLSC_WAR) {
 		unsigned long temp;
@@ -233,6 +256,7 @@ static __inline__ int atomic_sub_return(int i, atomic_t * v)
 		raw_local_irq_restore(flags);
 	}
 
+#endif
 	smp_llsc_mb();
 
 	return result;
diff --git a/include/asm-mips/elf.h b/include/asm-mips/elf.h
index d66afa2..434f82f 100644
--- a/include/asm-mips/elf.h
+++ b/include/asm-mips/elf.h
@@ -316,6 +316,7 @@ do {									\
 
 struct pt_regs;
 struct task_struct;
+struct pt_regs;
 
 extern void elf_dump_regs(elf_greg_t *, struct pt_regs *regs);
 extern int dump_task_regs(struct task_struct *, elf_gregset_t *);
diff --git a/include/asm-mips/hazards.h b/include/asm-mips/hazards.h
index 2de638f..9e67f07 100644
--- a/include/asm-mips/hazards.h
+++ b/include/asm-mips/hazards.h
@@ -232,6 +232,8 @@ ASMMACRO(irq_disable_hazard,
 ASMMACRO(back_to_back_c0_hazard,
 	 _ssnop; _ssnop; _ssnop;
 	)
+ASMMACRO(tlbw_eret_hazard,
+	)
 #define instruction_hazard() do { } while (0)
 
 #endif
diff --git a/include/asm-mips/mach-rmi/war.h b/include/asm-mips/mach-rmi/war.h
new file mode 100644
index 0000000..bc959e6
--- /dev/null
+++ b/include/asm-mips/mach-rmi/war.h
@@ -0,0 +1,25 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2002, 2004, 2007 by Ralf Baechle <ralf@linux-mips.org>
+ */
+#ifndef __ASM_MIPS_MACH_RMI_WAR_H
+#define __ASM_MIPS_MACH_RMI_WAR_H
+
+#define R4600_V1_INDEX_ICACHEOP_WAR	0
+#define R4600_V1_HIT_CACHEOP_WAR	0
+#define R4600_V2_HIT_CACHEOP_WAR	0
+#define R5432_CP0_INTERRUPT_WAR		0
+#define BCM1250_M3_WAR			0
+#define SIBYTE_1956_WAR			0
+#define MIPS4K_ICACHE_REFILL_WAR	0
+#define MIPS_CACHE_SYNC_WAR		0
+#define TX49XX_ICACHE_INDEX_INV_WAR	0
+#define RM9000_CDEX_SMP_WAR		0
+#define ICACHE_REFILLS_WORKAROUND_WAR	0
+#define R10000_LLSC_WAR			0
+#define MIPS34K_MISSED_ITLB_WAR		0
+#define RMI_XLS_WAR  1
+#endif /* __ASM_MIPS_MACH_RMI_WAR_H */
diff --git a/include/asm-mips/mipsregs.h b/include/asm-mips/mipsregs.h
index 3d956ee..6aa3079 100644
--- a/include/asm-mips/mipsregs.h
+++ b/include/asm-mips/mipsregs.h
@@ -17,6 +17,8 @@
 #include <asm/hazards.h>
 #include <asm/war.h>
 
+#include <asm/rmi/mips-exts.h>
+
 /*
  * The following macros are especially useful for __asm__
  * inline assembler.
@@ -808,7 +810,19 @@ do {									\
 #define write_c0_count3(val)	__write_32bit_c0_register($9, 7, val)
 
 #define read_c0_entryhi()	__read_ulong_c0_register($10, 0)
+#if defined(CONFIG_PHOENIX_GLOBAL_TLB_SPLIT_ASID)
+extern unsigned int rmi_shtlb;
+#define write_c0_entryhi(val)	\
+	if(rmi_shtlb) \
+		__write_ulong_c0_register($10, 0, (((val) & ~0xc0)|(phoenix_thr_id()<<6))); \
+	else \
+		__write_ulong_c0_register($10, 0, val);
+		
+#elif defined(CONFIG_PHOENIX_GLOBAL_TLB_GLOBAL_ASID)
+#define write_c0_entryhi(val)	__write_ulong_c0_register($10, 0, (((val) & ~0xc0)|(phoenix_thr_id()<<6)))
+#else
 #define write_c0_entryhi(val)	__write_ulong_c0_register($10, 0, val)
+#endif
 
 #define read_c0_compare()	__read_32bit_c0_register($11, 0)
 #define write_c0_compare(val)	__write_32bit_c0_register($11, 0, val)
diff --git a/include/asm-mips/mman.h b/include/asm-mips/mman.h
index e4d6f1f..f393ade 100644
--- a/include/asm-mips/mman.h
+++ b/include/asm-mips/mman.h
@@ -74,4 +74,9 @@
 /* compatibility flags */
 #define MAP_FILE	0
 
+#if defined(CONFIG_RMI_PHOENIX) && defined(CONFIG_64BIT)
+#define arch_mmap_check(addr,len,flags)	mips_mmap_check(addr,len,flags)
+int mips_mmap_check(unsigned long addr, unsigned long len,
+		unsigned long flags);
+#endif
 #endif /* _ASM_MMAN_H */
diff --git a/include/asm-mips/mmu_context.h b/include/asm-mips/mmu_context.h
index 0c4f245..343ce88 100644
--- a/include/asm-mips/mmu_context.h
+++ b/include/asm-mips/mmu_context.h
@@ -22,6 +22,11 @@
 #endif /* SMTC */
 #include <asm-generic/mm_hooks.h>
 
+#ifdef CONFIG_RMI_PHOENIX
+#include <asm/rmi/mips-exts.h>
+#include <asm/rmi/debug.h>
+#endif
+
 /*
  * For the fast tlb miss handlers, we keep a per cpu array of pointers
  * to the current pgd for each processor. Also, the proc. id is stuffed
@@ -68,8 +73,14 @@ extern unsigned long smtc_asid_mask;
 /* End SMTC/34K debug hack */
 #else /* FIXME: not correct for R6000 */
 
-#define ASID_INC	0x1
-#define ASID_MASK	0xff
+#ifdef CONFIG_PHOENIX_GLOBAL_TLB_SPLIT_ASID
+#define ASID_INC    0x1
+extern unsigned long rmi_asid_mask;
+#define ASID_MASK   rmi_asid_mask
+#else
+#define ASID_INC    0x1
+#define ASID_MASK   0xff
+#endif
 
 #endif
 
diff --git a/include/asm-mips/msi.h b/include/asm-mips/msi.h
new file mode 100644
index 0000000..a955c58
--- /dev/null
+++ b/include/asm-mips/msi.h
@@ -0,0 +1,28 @@
+/************************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc.(RMI).
+
+  This is a derived work from software originally provided by the external
+  entity identified below. The licensing terms and warranties specified in
+  the header of the original work apply to this derived work.
+
+  Contribution by RMI: Defines for MSI support for RMI Eval Board
+
+  *****************************#RMI_1#************************************/
+
+/*
+ * Copyright (C) 2003-2004 Intel
+ * Copyright (C) Tom Long Nguyen (tom.l.nguyen@intel.com)
+ */
+
+#ifndef ASM_MSI_H
+#define ASM_MSI_H
+
+#define NR_VECTORS              128
+#define NR_IRQ_VECTORS          NR_IRQS
+#define FIRST_DEVICE_VECTOR     0x00
+
+#define LAST_DEVICE_VECTOR		232
+#define MSI_TARGET_CPU_SHIFT	12
+
+#endif /* ASM_MSI_H */
diff --git a/include/asm-mips/offset.h b/include/asm-mips/offset.h
new file mode 100644
index 0000000..dadcba5
--- /dev/null
+++ b/include/asm-mips/offset.h
@@ -0,0 +1,208 @@
+#ifndef _ASM_OFFSET_H
+#define _ASM_OFFSET_H
+/*
+ * DO NOT MODIFY.
+ *
+ * This file was generated by arch/mips/Makefile
+ *
+ */
+
+/* MIPS pt_regs offsets. */
+#define PT_R0     24
+#define PT_R1     28
+#define PT_R2     32
+#define PT_R3     36
+#define PT_R4     40
+#define PT_R5     44
+#define PT_R6     48
+#define PT_R7     52
+#define PT_R8     56
+#define PT_R9     60
+#define PT_R10    64
+#define PT_R11    68
+#define PT_R12    72
+#define PT_R13    76
+#define PT_R14    80
+#define PT_R15    84
+#define PT_R16    88
+#define PT_R17    92
+#define PT_R18    96
+#define PT_R19    100
+#define PT_R20    104
+#define PT_R21    108
+#define PT_R22    112
+#define PT_R23    116
+#define PT_R24    120
+#define PT_R25    124
+#define PT_R26    128
+#define PT_R27    132
+#define PT_R28    136
+#define PT_R29    140
+#define PT_R30    144
+#define PT_R31    148
+#define PT_LO     156
+#define PT_HI     160
+#define PT_EPC    172
+#define PT_BVADDR 164
+#define PT_STATUS 152
+#define PT_CAUSE  168
+#define PT_SIZE   176
+
+/* MIPS task_struct offsets. */
+#define TASK_STATE         0
+#define TASK_THREAD_INFO   4
+#define TASK_FLAGS         12
+#define TASK_MM            108
+#define TASK_PID           140
+#define TASK_STRUCT_SIZE   1152
+
+/* MIPS thread_info offsets. */
+#define TI_TASK            0
+#define TI_EXEC_DOMAIN     4
+#define TI_FLAGS           8
+#define TI_CPU             16
+#define TI_PRE_COUNT       20
+#define TI_ADDR_LIMIT      24
+#define TI_RESTART_BLOCK   28
+#define TI_TP_VALUE        12
+#define _THREAD_SIZE_ORDER 0x1
+#define _THREAD_SIZE       0x2000
+#define _THREAD_MASK       0x1fff
+
+/* MIPS specific thread_struct offsets. */
+#define THREAD_REG16   656
+#define THREAD_REG17   660
+#define THREAD_REG18   664
+#define THREAD_REG19   668
+#define THREAD_REG20   672
+#define THREAD_REG21   676
+#define THREAD_REG22   680
+#define THREAD_REG23   684
+#define THREAD_REG29   688
+#define THREAD_REG30   692
+#define THREAD_REG31   696
+#define THREAD_STATUS  700
+#define THREAD_FPU     704
+#define THREAD_BVADDR  968
+#define THREAD_BUADDR  972
+#define THREAD_ECODE   976
+#define THREAD_TRAPNO  980
+#define THREAD_MFLAGS  984
+#define THREAD_TRAMP   988
+#define THREAD_OLDCTX  992
+
+#define THREAD_FPR0    704
+#define THREAD_FPR1    712
+#define THREAD_FPR2    720
+#define THREAD_FPR3    728
+#define THREAD_FPR4    736
+#define THREAD_FPR5    744
+#define THREAD_FPR6    752
+#define THREAD_FPR7    760
+#define THREAD_FPR8    768
+#define THREAD_FPR9    776
+#define THREAD_FPR10   784
+#define THREAD_FPR11   792
+#define THREAD_FPR12   800
+#define THREAD_FPR13   808
+#define THREAD_FPR14   816
+#define THREAD_FPR15   824
+#define THREAD_FPR16   832
+#define THREAD_FPR17   840
+#define THREAD_FPR18   848
+#define THREAD_FPR19   856
+#define THREAD_FPR20   864
+#define THREAD_FPR21   872
+#define THREAD_FPR22   880
+#define THREAD_FPR23   888
+#define THREAD_FPR24   896
+#define THREAD_FPR25   904
+#define THREAD_FPR26   912
+#define THREAD_FPR27   920
+#define THREAD_FPR28   928
+#define THREAD_FPR29   936
+#define THREAD_FPR30   944
+#define THREAD_FPR31   952
+#define THREAD_FCR31   960
+
+/* Size of struct page  */
+#define STRUCT_PAGE_SIZE   40
+
+/* Linux mm_struct offsets. */
+#define MM_USERS      20
+#define MM_PGD        16
+#define MM_CONTEXT    288
+
+#define _PAGE_SIZE     0x1000
+#define _PAGE_SHIFT    0xc
+
+#define _PGD_T_SIZE    0x4
+#define _PMD_T_SIZE    0x4
+#define _PTE_T_SIZE    0x8
+
+#define _PGD_T_LOG2    0x2
+#define _PMD_T_LOG2    0x2
+#define _PTE_T_LOG2    0x3
+
+#define _PMD_SHIFT     0x15
+#define _PGDIR_SHIFT   0x15
+
+#define _PGD_ORDER     0x1
+#define _PMD_ORDER     0x0
+#define _PTE_ORDER     0x0
+
+#define _PTRS_PER_PGD  0x800
+#define _PTRS_PER_PMD  0x1
+#define _PTRS_PER_PTE  0x200
+
+/* Linux sigcontext offsets. */
+#define SC_REGS       16
+#define SC_FPREGS     272
+#define SC_MDHI       552
+#define SC_MDLO       560
+#define SC_PC         8
+#define SC_STATUS     4
+#define SC_FPC_CSR    532
+#define SC_FPC_EIR    536
+#define SC_CAUSE      568
+#define SC_BADVADDR   572
+
+/* Linux signal numbers. */
+#define _SIGHUP     0x1
+#define _SIGINT     0x2
+#define _SIGQUIT    0x3
+#define _SIGILL     0x4
+#define _SIGTRAP    0x5
+#define _SIGIOT     0x6
+#define _SIGABRT    0x6
+#define _SIGEMT     0x7
+#define _SIGFPE     0x8
+#define _SIGKILL    0x9
+#define _SIGBUS     0xa
+#define _SIGSEGV    0xb
+#define _SIGSYS     0xc
+#define _SIGPIPE    0xd
+#define _SIGALRM    0xe
+#define _SIGTERM    0xf
+#define _SIGUSR1    0x10
+#define _SIGUSR2    0x11
+#define _SIGCHLD    0x12
+#define _SIGPWR     0x13
+#define _SIGWINCH   0x14
+#define _SIGURG     0x15
+#define _SIGIO      0x16
+#define _SIGSTOP    0x17
+#define _SIGTSTP    0x18
+#define _SIGCONT    0x19
+#define _SIGTTIN    0x1a
+#define _SIGTTOU    0x1b
+#define _SIGVTALRM  0x1c
+#define _SIGPROF    0x1d
+#define _SIGXCPU    0x1e
+#define _SIGXFSZ    0x1f
+
+/* Linux irq_cpustat_t offsets. */
+#define IC_SOFTIRQ_PENDING 0
+#define IC_IRQ_CPUSTAT_T   32
+
+#endif /* _ASM_OFFSET_H */
diff --git a/include/asm-mips/rmi/64bit.h b/include/asm-mips/rmi/64bit.h
new file mode 100644
index 0000000..b6b6c72
--- /dev/null
+++ b/include/asm-mips/rmi/64bit.h
@@ -0,0 +1,84 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_64BIT_H
+#define _ASM_RMI_64BIT_H
+
+#include <linux/types.h>
+#include <asm/system.h>
+
+/* Implement 64bit read and write operations */
+
+static inline void out64(u64 val, unsigned long addr)
+{
+	u32 low, high, tmp;
+	unsigned long flags=0;
+
+	high = val >> 32;
+	low = val & 0xffffffff;
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+			".set push\t\t\t# out64n"
+			".set noreorder\n"
+			".set noat\n"
+			".set mips4\n"
+			"   dsll32 %0, %2, 0   \n"
+			"   dsll32 $1, %1, 0   \n"
+			"   dsrl32 %0, %0, 0   \n"
+			"   or     $1, $1, %0  \n"
+			"   sd $1, (%3)\n"
+			".set pop\n"
+			: "=&r" (tmp)
+			: "r" (high), "r" (low), "r" (addr));
+	local_irq_restore(flags);
+}
+
+static inline u64 in64(unsigned long addr)
+{
+	unsigned long flags;
+	u32 low, high;
+
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+			".set push\t\t\t# in64\n"
+			".set noreorder\n"
+			".set noat     \n"
+			".set mips4    \n"
+			"  ld     %1, (%2)\n"
+			"  dsra32 %0, %1, 0\n"
+			"  sll    %1, %1, 0\n"
+			".set pop\n"
+			: "=r" (high), "=r" (low)
+			: "r" (addr));
+	local_irq_restore(flags);
+
+	return (((u64)high) << 32) | low;
+}
+#endif 
diff --git a/include/asm-mips/rmi/atx_cpld.h b/include/asm-mips/rmi/atx_cpld.h
new file mode 100644
index 0000000..e9361f4
--- /dev/null
+++ b/include/asm-mips/rmi/atx_cpld.h
@@ -0,0 +1,64 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_ATX_CPLD_H
+#define _ASM_RMI_ATX_CPLD_H
+
+/*
+	 * bit_0 : xgs0 phy reset
+	 * bit_1 : xgs1 phy reset
+	 * bit_2 : HT reset
+	 * bit_3 : RTC reset
+	 * bit_4 : gmac phy soft reset
+	 * bit_5 : gmac phy hard reset
+	 * bit_6 : board reset
+	 * bit_7 : reserved
+*/
+#define ATX_CPLD_RESET_1   2
+
+/*
+ *  bit_0_2 : reserved
+ *  bit_3 : turn off xpak_0 tx
+ *  bit_4 : turn off xpak_1 tx
+ *  bit_5 : HT stop (active low)
+ *  bit_6 : flash program enable
+ *  bit_7 : compact flash io mode
+ */
+#define ATX_CPLD_MISC_CTRL 8
+
+/*
+ * bit_0 : reset tcam 
+ * bit_1 : reset xpak_0 module
+ * bit_2 : reset xpak_1 module
+ * bit_3_7 : reserved
+ */
+#define ATX_CPLD_RESET_2   9
+
+#endif /* _ASM_RMI_ATX_CPLD_H */
diff --git a/include/asm-mips/rmi/debug.h b/include/asm-mips/rmi/debug.h
new file mode 100644
index 0000000..7924f22
--- /dev/null
+++ b/include/asm-mips/rmi/debug.h
@@ -0,0 +1,117 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_DEBUG_H
+#define _ASM_RMI_DEBUG_H
+
+/*Enable below macro to enable net stats. */
+//#define CONFIG_RMI_STATS
+extern void prom_printf(char *fmt, ...);
+#include <linux/threads.h>
+#include <asm/atomic.h>
+
+enum {
+  //cacheline 0
+  MSGRNG_INT,
+  MSGRNG_PIC_INT,
+  MSGRNG_MSG,
+  MSGRNG_EXIT_STATUS,
+  MSGRNG_MSG_CYCLES,
+  //cacheline 1
+  NETIF_TX = 8,
+  NETIF_RX,
+  NETIF_TX_COMPLETE,
+  NETIF_TX_COMPLETE_TX,
+  NETIF_RX_CYCLES,
+  NETIF_TX_COMPLETE_CYCLES,
+  NETIF_TX_CYCLES,
+  NETIF_TIMER_START_Q,
+  //NETIF_REG_FRIN,
+  //NETIF_INT_REG,
+  //cacheline 2
+  REPLENISH_ENTER = 16,
+  REPLENISH_ENTER_COUNT,
+  REPLENISH_CPU,
+  REPLENISH_FRIN,
+  REPLENISH_CYCLES,
+  NETIF_STACK_TX,
+  NETIF_START_Q,
+  NETIF_STOP_Q,
+  //cacheline 3
+  USER_MAC_START = 24,
+  USER_MAC_INT   = 24,
+  USER_MAC_TX_COMPLETE,
+  USER_MAC_RX,
+  USER_MAC_POLL,
+  USER_MAC_TX,
+  USER_MAC_TX_FAIL,
+  USER_MAC_TX_COUNT,
+  USER_MAC_FRIN,
+  //cacheline 4
+  USER_MAC_TX_FAIL_GMAC_CREDITS = 32,
+  USER_MAC_DO_PAGE_FAULT,
+  USER_MAC_UPDATE_TLB,
+  USER_MAC_UPDATE_TLB_PFN0,
+  USER_MAC_UPDATE_TLB_PFN1,
+  
+  PHNX_MAX_COUNTERS = 40
+};
+extern atomic_t phnx_counters[NR_CPUS][PHNX_MAX_COUNTERS];
+extern __u32 msgrng_msg_cycles;
+
+#ifdef CONFIG_RMI_STATS 
+#define phnx_inc_counter(x) atomic_inc(&phnx_counters[0][(x)])
+#define phnx_dec_counter(x) atomic_dec(&phnx_counters[0][(x)])
+#define phnx_set_counter(x, value) atomic_set(&phnx_counters[0][(x)], (value))
+#define phnx_get_counter(x) atomic_read(&phnx_counters[0][(x)])
+#else
+#define phnx_inc_counter(x) //atomic_inc(&phnx_counters[0][(x)])
+#define phnx_dec_counter(x) //atomic_dec(&phnx_counters[0][(x)])
+#define phnx_set_counter(x, value) //atomic_set(&phnx_counters[0][(x)], (value))
+#define phnx_get_counter(x) //atomic_read(&phnx_counters[0][(x)])
+#endif
+#if 0
+#define dbg_msg(fmt, args...) printk("[%s@%d|%s]: cpu_%d: " fmt, \
+                               __FILE__, __LINE__, __FUNCTION__,  smp_processor_id(), ##args)
+
+#define dbg_panic(fmt, args...) panic("[%s@%d|:%s]: cpu_%d: " fmt, \
+                               __FILE__, __LINE__, __FUNCTION__, smp_processor_id(), ##args)
+
+#define prom_dbg_msg(fmt, args...) prom_printf("[%s@%d|%s]: cpu_%d: " fmt, \
+                               __FILE__, __LINE__, __FUNCTION__,  smp_processor_id(), ##args)
+#else
+#define dbg_msg(fmt, args...)
+
+#define dbg_panic(fmt, args...) panic(fmt, ##args)
+
+#define prom_dbg_msg(fmt, args...) printk(fmt, ##args)
+#endif
+
+#endif
diff --git a/include/asm-mips/rmi/devices.h b/include/asm-mips/rmi/devices.h
new file mode 100644
index 0000000..329dba6
--- /dev/null
+++ b/include/asm-mips/rmi/devices.h
@@ -0,0 +1,46 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_DEVICES_H
+#define _ASM_RMI_DEVICES_H
+
+#define XLR_VIRT_UART_MAJOR       239
+#define XLR_TB_MAJOR              240
+#define XLR_USER_MAC_MAJOR        241
+#define XLR_CRYPTO_MAJOR          242
+
+#define BTLBDEV_MAJOR             243
+
+#define XLR_MSGRING_SHM_MAJOR     244
+#define XLR_APP_LOADER_MAJOR      245
+#define XLR_CONSOLE_OVER_PCI_MAJOR	  246
+#define XLR_DEBUGGER_MAJOR              247
+
+#endif
diff --git a/include/asm-mips/rmi/gpio.h b/include/asm-mips/rmi/gpio.h
new file mode 100644
index 0000000..27169af
--- /dev/null
+++ b/include/asm-mips/rmi/gpio.h
@@ -0,0 +1,77 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_GPIO_H
+#define _ASM_RMI_GPIO_H
+
+#include <asm/rmi/iomap.h>
+
+#define PHOENIX_GPIO_INT_EN_REG 0
+#define PHOENIX_GPIO_INPUT_INVERSION_REG 1
+#define PHOENIX_GPIO_IO_DIR_REG 2
+#define PHOENIX_GPIO_IO_DATA_WR_REG 3
+#define PHOENIX_GPIO_IO_DATA_RD_REG 4
+
+#define PHOENIX_GPIO_SWRESET_REG 8
+
+#define PHOENIX_GPIO_DRAM1_CNTRL_REG 9
+#define PHOENIX_GPIO_DRAM1_RATIO_REG 10
+#define PHOENIX_GPIO_DRAM1_RESET_REG 11
+#define PHOENIX_GPIO_DRAM1_STATUS_REG 12
+
+#define PHOENIX_GPIO_DRAM2_CNTRL_REG 13
+#define PHOENIX_GPIO_DRAM2_RATIO_REG 14
+#define PHOENIX_GPIO_DRAM2_RESET_REG 15
+#define PHOENIX_GPIO_DRAM2_STATUS_REG 16
+
+#define PHOENIX_GPIO_PWRON_RESET_CFG_REG 21
+
+#define PHOENIX_GPIO_BIST_ALL_GO_STATUS_REG 24
+#define PHOENIX_GPIO_BIST_CPU_GO_STATUS_REG 25
+#define PHOENIX_GPIO_BIST_DEV_GO_STATUS_REG 26
+
+#define PHOENIX_GPIO_FUSE_BANK_REG 35
+
+#define PHOENIX_GPIO_CPU_RESET_REG 40
+
+#define PHOENIX_GPIO_RNG_REG 43
+
+#define PHOENIX_PWRON_RESET_PCMCIA_BOOT 17
+
+#define PHOENIX_GPIO_LED_BITMAP 0x1700000
+#define PHOENIX_GPIO_LED_0_SHIFT 20
+#define PHOENIX_GPIO_LED_1_SHIFT 24
+
+#define PHOENIX_GPIO_LED_OUTPUT_CODE_RESET 0x01
+#define PHOENIX_GPIO_LED_OUTPUT_CODE_HARD_RESET 0x02
+#define PHOENIX_GPIO_LED_OUTPUT_CODE_SOFT_RESET 0x03
+#define PHOENIX_GPIO_LED_OUTPUT_CODE_MAIN 0x04
+
+#endif
diff --git a/include/asm-mips/rmi/interrupt.h b/include/asm-mips/rmi/interrupt.h
new file mode 100644
index 0000000..5e44062
--- /dev/null
+++ b/include/asm-mips/rmi/interrupt.h
@@ -0,0 +1,55 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_INTERRUPT_H
+#define _ASM_RMI_INTERRUPT_H
+
+#include <asm/rmi/pic.h>
+
+/* Defines for the IRQ numbers */
+
+#define IRQ_DUMMY_UART           2
+#define IRQ_IPI_SMP_FUNCTION     3
+#define IRQ_IPI_SMP_RESCHEDULE   4
+#define IRQ_REMOTE_DEBUG         5
+#define IRQ_MSGRING              6
+#define IRQ_TIMER                7
+#define IRQ_IPI_SMP_KGDB   		50
+#define IRQ_IPI_OPROFILE        51
+
+#define IRQ_IPI_CRF_MGMT_IPI	45 /* */
+#define IRQ_IPI_CRF_EVENTQ_IPI 46 
+
+
+#define SMP_CALL_KGDB_HOOK 	8
+#define SMP_OPROFILE_IPI        16
+
+
+#endif
diff --git a/include/asm-mips/rmi/io.h b/include/asm-mips/rmi/io.h
new file mode 100644
index 0000000..989b110
--- /dev/null
+++ b/include/asm-mips/rmi/io.h
@@ -0,0 +1,53 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_IO_H
+#define _ASM_RMI_IO_H
+
+extern void __iomem *pci_iomap(struct pci_dev *dev, int bar, unsigned long max);
+extern void pci_iounmap(struct pci_dev *dev, void __iomem *);
+
+#define __raw_writeb(v,a)       (*(volatile unsigned char  *)(a) = (v))
+#define __raw_writew(v,a)       (*(volatile unsigned short *)(a) = (v))
+#define __raw_writel(v,a)       (*(volatile unsigned int   *)(a) = (v))
+
+#define __raw_readb(a)          (*(volatile unsigned char  *)(a))
+#define __raw_readw(a)          (*(volatile unsigned short *)(a))
+#define __raw_readl(a)          (*(volatile unsigned int   *)(a))
+
+#define ioread8(p)  ({ unsigned int __v = __raw_readb(p); __v; })
+#define ioread16(p) ({ unsigned int __v = le16_to_cpu(__raw_readw(p)); __v; })
+#define ioread32(p) ({ unsigned int __v = le32_to_cpu(__raw_readl(p)); __v; })
+
+#define iowrite8(v,p)   __raw_writeb(v, p)
+#define iowrite16(v,p)  __raw_writew(cpu_to_le16(v), p)
+#define iowrite32(v,p)  __raw_writel(cpu_to_le32(v), p)
+
+#endif
diff --git a/include/asm-mips/rmi/iomap.h b/include/asm-mips/rmi/iomap.h
new file mode 100644
index 0000000..2c07002
--- /dev/null
+++ b/include/asm-mips/rmi/iomap.h
@@ -0,0 +1,275 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RFI_IO_H
+#define _ASM_RFI_IO_H
+
+#define DEFAULT_PHOENIX_IO_BASE 0xffffffffbef00000ULL
+#define PHOENIX_IO_SIZE                   0x1000
+
+#define PHOENIX_IO_BRIDGE_OFFSET          0x00000
+
+#define PHOENIX_IO_DDR2_CHN0_OFFSET       0x01000
+#define PHOENIX_IO_DDR2_CHN1_OFFSET       0x02000
+#define PHOENIX_IO_DDR2_CHN2_OFFSET       0x03000
+#define PHOENIX_IO_DDR2_CHN3_OFFSET       0x04000
+
+#define PHOENIX_IO_RLD2_CHN0_OFFSET       0x05000
+#define PHOENIX_IO_RLD2_CHN1_OFFSET       0x06000
+
+#define PHOENIX_IO_SRAM_OFFSET            0x07000
+
+#define PHOENIX_IO_PIC_OFFSET             0x08000
+#define PHOENIX_IO_PCIX_OFFSET            0x09000
+#define PHOENIX_IO_HT_OFFSET              0x0A000
+
+#define PHOENIX_IO_SECURITY_OFFSET        0x0B000
+
+#define PHOENIX_IO_GMAC_0_OFFSET          0x0C000
+#define PHOENIX_IO_GMAC_1_OFFSET          0x0D000
+#define PHOENIX_IO_GMAC_2_OFFSET          0x0E000
+#define PHOENIX_IO_GMAC_3_OFFSET          0x0F000
+
+#ifdef XLS
+#define PHOENIX_IO_GMAC_4_OFFSET          0x20000
+#define PHOENIX_IO_GMAC_5_OFFSET          0x21000
+#define PHOENIX_IO_GMAC_6_OFFSET          0x22000
+#define PHOENIX_IO_GMAC_7_OFFSET          0x23000
+
+#define PHOENIX_IO_PCIE_0_OFFSET          0x1E000
+#define PHOENIX_IO_PCIE_1_OFFSET          0x1F000
+#define PHOENIX_IO_SRIO_0_OFFSET          0x1E000
+#define PHOENIX_IO_SRIO_1_OFFSET          0x1F000
+
+#define PHOENIX_IO_USB_0_OFFSET           0x24000
+#define PHOENIX_IO_USB_1_OFFSET           0x25000
+
+#define PHOENIX_IO_COMP_OFFSET            0x1D000
+
+#endif /* CLS */
+
+#define PHOENIX_IO_SPI4_0_OFFSET          0x10000
+#define PHOENIX_IO_XGMAC_0_OFFSET         0x11000
+#define PHOENIX_IO_SPI4_1_OFFSET          0x12000
+#define PHOENIX_IO_XGMAC_1_OFFSET         0x13000
+
+#define PHOENIX_IO_UART_0_OFFSET          0x14000
+#define PHOENIX_IO_UART_1_OFFSET          0x15000
+
+#define PHOENIX_IO_I2C_0_OFFSET           0x16000
+#define PHOENIX_IO_I2C_1_OFFSET           0x17000
+
+#define PHOENIX_IO_GPIO_OFFSET            0x18000
+
+#define PHOENIX_IO_FLASH_OFFSET           0x19000
+
+#define PHOENIX_IO_TB_OFFSET           	  0x1C000
+
+#define PHOENIX_CPLD_OFFSET               0xffffffffbd840000ULL
+
+/* Base Address (Virtual) of the PCI Config address space
+ * For now, choose 256M phys in kseg1 = 0xA0000000 + (1<<28)
+ * Config space spans 256 (num of buses) * 256 (num functions) * 256 bytes
+ * ie 1<<24 = 16M
+ */ 
+#define DEFAULT_PCI_CONFIG_BASE         0x18000000
+#define DEFAULT_HT_TYPE0_CFG_BASE       0x16000000
+#define DEFAULT_HT_TYPE1_CFG_BASE       0x17000000
+
+#ifndef __ASSEMBLY__
+
+#include <linux/types.h>
+#include <asm/byteorder.h>
+
+typedef volatile __u32 phoenix_reg_t;
+extern unsigned long phoenix_io_base;
+
+#define phoenix_io_mmio(offset) ((phoenix_reg_t *)(phoenix_io_base+(offset)))
+
+#ifdef RMI_BRIDGE_WKAROUND
+#include "rmi_rw_lock.h"
+extern rmi_rwlock_t *rmi_bridge_lock;
+extern int rmi_enable_br_wrkaround;
+
+static inline void rmi_preempt_enable(void)
+{
+    uint32_t status=0;
+    __asm__ volatile(
+#ifdef CONFIG_64BIT
+            "lw %0, 36($28)\n"
+#else
+            "lw %0, 20($28)\n"
+#endif
+            "addiu %0, %0, -1 \n"
+#ifdef CONFIG_64BIT
+            "sw %0, 36($28) \n"
+#else
+            "sw %0, 20($28) \n"
+#endif
+            :"=r"(status)
+            );    
+}
+
+static inline void rmi_preempt_disable(void)
+{
+    uint32_t status=0;
+    __asm__ volatile(
+#ifdef CONFIG_64BIT
+            "lw %0, 36($28)\n"
+#else
+            "lw %0, 20($28)\n"
+#endif
+            "addiu %0, %0, 1 \n"
+#ifdef CONFIG_64BIT
+            "sw %0, 36($28) \n"
+#else
+            "sw %0, 20($28) \n"
+#endif
+            :"=r"(status)
+            );    
+}
+
+static inline uint32_t rmi_br_read_lock(void)
+{
+    uint32_t ret = 0;
+	if(rmi_enable_br_wrkaround){
+         rmi_preempt_disable();
+		 ret = rmi_read_lock_irq_save(rmi_bridge_lock);
+         rmi_preempt_enable();
+    }
+	return ret;
+}
+static inline void rmi_br_read_unlock(unsigned int flags)
+{
+	if(rmi_enable_br_wrkaround){
+        rmi_preempt_disable();
+		rmi_read_unlock_irq_restore(rmi_bridge_lock, flags);
+        rmi_preempt_enable();
+    }
+}
+
+static inline uint32_t rmi_br_write_lock(void)
+{
+    uint32_t ret = 0;
+	if(rmi_enable_br_wrkaround){
+        rmi_preempt_disable();
+		ret = rmi_write_lock_irq_save(rmi_bridge_lock);
+        rmi_preempt_enable();
+    }
+	return ret;
+}
+
+static inline void rmi_br_write_unlock(unsigned int flags)
+{
+	if(rmi_enable_br_wrkaround){
+        rmi_preempt_disable();
+		rmi_write_unlock_irq_restore(rmi_bridge_lock, flags);
+        rmi_preempt_enable();
+    }
+}
+
+static inline uint32_t rmi_read_reg_locked(phoenix_reg_t *base, 
+		unsigned int offset) 	
+{
+	unsigned int flags, val;
+
+	flags = rmi_br_read_lock();
+	val = (be32_to_cpu((base)[(offset)])); 
+	rmi_br_read_unlock(flags);
+
+	return val;
+}
+static inline uint32_t rmi_read_reg_le_locked(phoenix_reg_t *base, 
+		unsigned int offset) 	
+{
+	unsigned int flags, val;
+	flags = rmi_br_read_lock();
+	val = (le32_to_cpu((base)[(offset)])); 
+	rmi_br_read_unlock(flags);
+
+	return val;
+}
+static inline void rmi_write_reg_locked(phoenix_reg_t *base, 
+		 unsigned int offset,  unsigned int value)
+{
+	unsigned int flags;
+	flags = rmi_br_write_lock();
+	((base)[(offset)] = cpu_to_be32((value)));
+	rmi_br_write_unlock(flags);
+}
+
+static inline void rmi_write_reg_le_locked(phoenix_reg_t *base, 
+		 unsigned int offset,  unsigned int value)
+{
+	unsigned int flags;
+	flags = rmi_br_write_lock();
+	((base)[(offset)] = cpu_to_le32((value)));
+	rmi_br_write_unlock(flags);
+}
+
+#define phoenix_read_reg(base, offset) rmi_read_reg_locked(base, offset)
+#define phoenix_write_reg(base, offset, value) \
+	rmi_write_reg_locked(base, offset, value)
+
+#define phoenix_read_reg_le32(base, offset) \
+	rmi_read_reg_le_locked(base, offset)
+#define phoenix_write_reg_le32(base, offset, value) \
+	rmi_write_reg_le_locked(base, offset, value)
+#else
+static inline uint32_t rmi_br_read_lock(void) 
+{
+	return 0;
+}
+
+static inline void rmi_br_read_unlock(unsigned int flags)
+{
+}
+
+static inline uint32_t rmi_br_write_lock(void)
+{
+	return 0;
+}
+
+static inline void rmi_br_write_unlock(unsigned int flags)
+{
+}
+#define phoenix_read_reg(base, offset) (be32_to_cpu((base)[(offset)]))
+#define phoenix_write_reg(base, offset, value) ((base)[(offset)] = cpu_to_be32((value)))
+
+#define phoenix_read_reg_le32(base, offset) (le32_to_cpu((base)[(offset)]))
+#define phoenix_write_reg_le32(base, offset, value) \
+	((base)[(offset)] = cpu_to_le32((value)))
+
+#endif
+extern void on_chip_init(void);
+
+#endif
+
+#endif
diff --git a/include/asm-mips/rmi/memory-exclusion.h b/include/asm-mips/rmi/memory-exclusion.h
new file mode 100644
index 0000000..2a21502
--- /dev/null
+++ b/include/asm-mips/rmi/memory-exclusion.h
@@ -0,0 +1,38 @@
+/***********************************************************************
+Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#RMI_2#**********************************/
+
+#ifndef PHNX_MEMORY_EXCLUSION
+#define PHNX_MEMORY_EXCLUSION
+
+#define PHNX_RMIOS_TCPIP_START  (8<<20)
+#define PHNX_RMIOS_TCPIP_END    (96<<20)
+
+#define PHNX_RMIOS_IPSEC_START  (1<<20)
+#define PHNX_RMIOS_IPSEC_END    (51<<20)
+
+#define PHNX_RMIOS_LIB_START    (16<<20)
+#define PHNX_RMIOS_LIB_END	(51<<20)
+
+#endif
diff --git a/include/asm-mips/rmi/mips-exts.h b/include/asm-mips/rmi/mips-exts.h
new file mode 100644
index 0000000..9b11db3
--- /dev/null
+++ b/include/asm-mips/rmi/mips-exts.h
@@ -0,0 +1,461 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_MIPS_EXTS_H
+#define _ASM_RMI_MIPS_EXTS_H
+
+#define PHOENIX_OSS_SEL_TLB_STATS 0
+#define PHOENIX_OSS_SEL_UNUSED 1
+#define PHOENIX_OSS_SEL_PAGEMASK 2
+#define PHOENIX_OSS_SEL_VADDR 3
+#define PHOENIX_OSS_SEL_PFN0 4
+#define PHOENIX_OSS_SEL_PFN1 5
+#define PHOENIX_OSS_SEL_K0 6
+#define PHOENIX_OSS_SEL_K1 7
+
+#define OS_SCRATCH_REG0	22, 0
+#define OS_SCRATCH_REG1	22, 1
+#define OS_SCRATCH_REG2	22, 2
+#define OS_SCRATCH_REG3	22, 3
+#define OS_SCRATCH_REG4	22, 4
+#define OS_SCRATCH_REG5	22, 5
+#define OS_SCRATCH_REG6	22, 6
+#define OS_SCRATCH_REG7	22, 7
+
+#define OS_KGDB_SCRATCH_REG6	$22, 6
+#define OS_KGDB_SCRATCH_REG7	$22, 7
+
+#ifndef __ASSEMBLY__
+
+#include <linux/types.h>
+#include <asm/rmi/interrupt.h>
+
+/* Scratch registers used */
+#define RMI_TLB_STATS_SCRATCH_REG_SEL  2
+#define RMI_HTLB_PMASK_SCRATCH_REG_SEL 3
+#define RMI_CRF_PERF0_SCRATCH_REG_SEL  4
+#define RMI_CRF_PERF1_SCRATCH_REG_SEL  5
+
+
+#define DMFC0_AT_EIRR 0x40214806
+#define DMFC0_AT_EIMR 0x40214807
+#define DMTC0_AT_EIRR 0x40a14806
+#define DMTC0_AT_EIMR 0x40a14807
+
+/* functions to write to and read from the extended
+ * cp0 registers.
+ * EIRR : Extended Interrupt Request Register
+ *        cp0 register 9 sel 6
+ *        bits 0...7 are same as cause register 8...15
+ * EIMR : Extended Interrupt Mask Register
+ *        cp0 register 9 sel 7
+ *        bits 0...7 are same as status register 8...15
+ */
+
+static inline __u64 read_64bit_cp0_eirr(void)
+{
+  __u32 high, low;
+
+  __asm__ __volatile__ (
+			".set push\n"
+			".set noreorder\n"
+			".set noat\n"
+			".set mips4\n"
+
+			".word 0x40214806  \n\t"
+			"nop               \n\t"
+			"dsra32 %0, $1, 0  \n\t"
+			"sll    %1, $1, 0  \n\t"
+
+			".set pop\n"
+
+			: "=r" (high), "=r" (low)
+			);
+
+  return ( ((__u64)high) << 32) | low;
+}
+
+static inline __u64 read_64bit_cp0_eimr(void)
+{
+  __u32 high, low;
+
+  __asm__ __volatile__ (
+			".set push\n"
+			".set noreorder\n"
+			".set noat\n"
+			".set mips4\n"
+
+			".word 0x40214807  \n\t"
+			"nop               \n\t"
+			"dsra32 %0, $1, 0  \n\t"
+			"sll    %1, $1, 0  \n\t"
+
+			".set pop\n"
+
+			: "=r" (high), "=r" (low)
+			);
+
+  return ( ((__u64)high) << 32) | low;
+}
+
+static inline void write_64bit_cp0_eirr(__u64 value)
+{
+  __u32 low, high;
+
+  high = value >> 32;
+  low  = value & 0xffffffff;
+
+	__asm__ __volatile__ (
+	".set push\n"
+	".set noreorder\n"
+	".set noat\n"
+	".set mips4\n\t"
+
+	"dsll32 $2, %1, 0  \n\t"
+	"dsll32 $1, %0, 0  \n\t"
+	"dsrl32 $2, $2, 0  \n\t"
+	"or     $1, $1, $2 \n\t"
+	".word  0x40a14806 \n\t"
+	"nop               \n\t"
+
+	".set pop\n"
+
+	:
+	: "r" (high), "r" (low)
+	: "$1", "$2");
+}
+
+static inline void write_64bit_cp0_eimr(__u64 value)
+{
+  __u32 low, high;
+
+  high = value >> 32;
+  low  = value & 0xffffffff;
+
+	__asm__ __volatile__ (
+	".set push\n"
+	".set noreorder\n"
+	".set noat\n"
+	".set mips4\n\t"
+
+	"dsll32 $2, %1, 0  \n\t"
+	"dsll32 $1, %0, 0  \n\t"
+	"dsrl32 $2, $2, 0  \n\t"
+	"or     $1, $1, $2 \n\t"
+	".word  0x40a14807 \n\t"
+	"nop               \n\t"
+
+	".set pop\n"
+
+	:
+	: "r" (high), "r" (low)
+	: "$1", "$2");
+}
+
+static __inline__ int ldadd_w(unsigned int value, volatile int *addr)
+{
+	unsigned long res;
+  __asm__ __volatile__(
+		       ".set push\n"
+		       ".set noreorder\n"
+		       "move $8, %2\n"
+		       "move $9, %3\n"
+		       //"ldaddw %2, %3\n"
+                       ".word 0x71280010\n"
+		       "move %0, $8\n"
+		       ".set pop\n"
+		       :"=r"(res), "+m"(*addr)
+		       : "r" (value), "r"((unsigned long)addr)
+		       : "$8", "$9"
+		       );
+  return res;
+}
+
+static __inline__ void ldadd_w_no_read(int value, volatile int *addr)
+{
+	unsigned long res;
+  __asm__ __volatile__(
+                       ".set push\n"
+                       ".set noreorder\n"
+                       "move $8, %2\n"
+                       "move $9, %3\n"
+                       //"ldaddw $8, $9\n"
+                       ".word 0x71280010\n"
+                       //"move %0, $8\n"
+                       ".set pop\n"
+                       :"=r"(res), "+m"(*addr)
+                       : "r" (value), "r"((unsigned long)addr)
+                       : "$8", "$9"
+                       );
+}
+
+static __inline__ unsigned int ldadd_wu(unsigned int value, volatile unsigned int *addr)
+{
+	unsigned long res;
+  __asm__ __volatile__(
+		       ".set push\n"
+		       ".set noreorder\n"
+		       "move $8, %2\n"
+		       "move $9, %3\n"
+		       //"ldaddwu $8, $9\n"
+                       ".word 0x71280011\n"
+		       "move %0, $8\n"
+		       ".set pop\n"
+		       :"=r"(res), "+m"(*addr)
+		       : "r"(value), "r"((unsigned long)addr)
+		       : "$8", "$9"
+		       );
+  return res;
+}
+
+static __inline__ void ldadd_wu_no_read(unsigned int value,
+					volatile unsigned int *addr)
+{
+	unsigned long res;
+  __asm__ __volatile__(
+                       ".set push\n"
+                       ".set noreorder\n"
+                       "move $8, %2\n"
+                       "move $9, %3\n"
+                       //"ldaddwu $8, $9\n"
+                       ".word 0x71280011\n"
+                       //"move %0, $8\n"
+                       ".set pop\n"
+                       :"=r"(res), "+m"(*addr)
+                       : "r"(value), "r"((unsigned long)addr)
+                       : "$8", "$9"
+                       );
+}
+
+
+
+#if 0
+#define read_64bit_cp2_register(source)                         \
+({ int __res;                                                   \
+        __asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+	".set\treorder\n\t"					\
+        "mfc2\t%0,"STR(source)"\n\t"                            \
+	".set\tpop"						\
+        : "=r" (__res));                                        \
+        __res;})
+
+#define write_64bit_cp2_register(register,value)                \
+        __asm__ __volatile__(                                   \
+        "mtc2\t%0,"STR(register)"\n\t"				\
+	"nop"							\
+        : : "r" (value));
+
+#define read_64bit_cp2_register_sel(source, sel)                \
+({ int __res;                                                   \
+        __asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+	".set\treorder\n\t"					\
+        "mfc2\t%0,"STR(source)", %1\n\t"                        \
+	".set\tpop"						\
+        : "=r" (__res) : "i" (sel) );                           \
+        __res;})
+
+#define write_64bit_cp2_register_sel(register,value,sel)        \
+        __asm__ __volatile__(                                   \
+	".set\tpush\n\t"					\
+	".set\treorder\n\t"					\
+        "mtc2\t%0,"STR(register)",%1\n\t"		        \
+	"nop\n\t"  					        \
+	".set\tpop"						\
+        : : "r" (value), "i"(sel));
+
+#endif
+
+#define phoenix_id()                                            \
+({int __id;                                                     \
+ __asm__ __volatile__ (                                         \
+		       ".set push\n"                            \
+		       ".set noreorder\n"                       \
+                       ".word 0x40088007\n"                     \
+		       "srl  $8, $8, 10\n"                      \
+		       "andi %0, $8, 0x3f\n"                    \
+		       ".set pop\n"                             \
+		       : "=r" (__id) : : "$8");                 \
+ __id;})
+
+#define phoenix_cpu_id()                                        \
+({int __id;                                                     \
+ __asm__ __volatile__ (                                         \
+		       ".set push\n"                            \
+		       ".set noreorder\n"                       \
+                       ".word 0x40088007\n"                     \
+		       "srl  $8, $8, 4\n"                       \
+		       "andi %0, $8, 0x7\n"                    \
+		       ".set pop\n"                             \
+		       : "=r" (__id) : : "$8");                 \
+ __id;})
+
+#define phoenix_thr_id()                                        \
+({int __id;                                                     \
+ __asm__ __volatile__ (                                         \
+		       ".set push\n"                            \
+		       ".set noreorder\n"                       \
+                       ".word 0x40088007\n"                     \
+		       "andi %0, $8, 0x03\n"                    \
+		       ".set pop\n"                             \
+		       : "=r" (__id) : : "$8");                 \
+ __id;})
+
+static __inline__ int hard_smp_processor_id(void)
+{
+  return (phoenix_cpu_id() << 2) + phoenix_thr_id();
+}
+
+#define phoenix_cpu_to_thrid(cpu) (phys_proc_id[(cpu)] >> 2)
+#define phoenix_cpu_to_cpuid(cpu) (phys_proc_id[(cpu)] & 0x3)
+
+#define CPU_BLOCKID_IFU      0
+#define CPU_BLOCKID_ICU      1
+#define CPU_BLOCKID_IEU      2
+#define CPU_BLOCKID_LSU      3
+#define CPU_BLOCKID_MMU      4
+#define CPU_BLOCKID_PRF      5
+
+#define LSU_CERRLOG_REGID    9
+
+static __inline__ unsigned int read_32bit_phnx_ctrl_reg(int block, int reg)
+{
+  unsigned int __res;
+
+  __asm__ __volatile__(
+		       ".set\tpush\n\t"
+		       ".set\tnoreorder\n\t"
+		       "move $9, %1\n"
+/* 		       "mfcr\t$8, $9\n\t"          */
+		       ".word 0x71280018\n"
+		       "move %0, $8\n"
+		       ".set\tpop"
+		       : "=r" (__res) : "r"((block<<8)|reg)
+		       : "$8", "$9"
+		       );
+  return __res;
+}
+
+static __inline__ void write_32bit_phnx_ctrl_reg(int block, int reg, unsigned int value)
+{
+  __asm__ __volatile__(
+		       ".set\tpush\n\t"
+		       ".set\tnoreorder\n\t"
+		       "move $8, %0\n"
+		       "move $9, %1\n"
+/* 		       "mtcr\t$8, $9\n\t"  */
+		       ".word 0x71280019\n"
+		       ".set\tpop"
+		       :
+		       : "r" (value), "r"((block<<8)|reg)
+		       : "$8", "$9"
+		       );
+}
+
+static __inline__ unsigned long long read_64bit_phnx_ctrl_reg(int block, int reg)
+{
+	unsigned int high, low;
+
+	__asm__ __volatile__(
+		".set\tmips64\n\t"
+		"move    $9, %2\n"
+		/* "mfcr    $8, $9\n" */
+		".word   0x71280018\n"
+		"dsrl32  %0, $8, 0\n\t"
+		"dsll32  $8, $8, 0\n\t"
+		"dsrl32  %1, $8, 0\n\t"
+		".set mips0"
+		: "=r" (high), "=r"(low)
+		: "r"((block<<8)|reg)
+		: "$8", "$9"
+		);
+
+	return ( (((unsigned long long)high)<<32) | low);
+}
+
+static __inline__ void write_64bit_phnx_ctrl_reg(int block, int reg,unsigned long long value)
+{
+	__u32 low, high;
+	high = value >> 32;
+	low = value & 0xffffffff;
+
+	__asm__ __volatile__(
+		".set push\n"
+		".set noreorder\n"
+		".set mips4\n\t"
+		/* Set up "rs" */
+		"move $9, %0\n"
+
+		/* Store 64 bit value in "rt" */
+		"dsll32 $10, %1, 0  \n\t"
+		"dsll32 $8, %2, 0  \n\t"
+		"dsrl32 $8, $8, 0  \n\t"
+		"or     $8, $10, $8 \n\t"
+
+		".word 0x71280019\n" /* mtcr $8, $9 */
+
+		".set pop\n"
+
+		:  /* No outputs */
+		: "r"((block<<8)|reg), "r" (high), "r" (low)
+		: "$8", "$9", "$10"
+		);
+}
+
+typedef struct { volatile int value; } phnx_atomic_t;
+
+static __inline__ int phnx_test_and_set(phnx_atomic_t *lock)
+{
+  int oldval = 0;
+
+  __asm__ __volatile__ (".set push\n"
+			".set noreorder\n"
+			"move $9, %2\n"
+			"li $8, 1\n"
+			//"swapw $8, $9\n"
+			".word 0x71280014\n"
+			"move %1, $8\n"
+			".set pop\n"
+			: "+m" (lock->value), "=r" (oldval)
+			: "r" ((unsigned long)&lock->value)
+			: "$8", "$9"
+			);
+  return (oldval == 0 ? 1/*success*/ : 0/*failure*/);
+}
+
+#define rmi_write_os_scratch_2(val)	__write_64bit_c0_register($22, 2, val)
+#define rmi_read_os_scratch_2()	__read_64bit_c0_register($22, 2)
+
+#define rmi_write_os_scratch_3(val)	__write_64bit_c0_register($22, 3, val)
+#define rmi_read_os_scratch_3()	__read_64bit_c0_register($22, 3)
+#endif
+
+#endif /* _ASM_RMI_MIPS_EXTS_H */
diff --git a/include/asm-mips/rmi/msidef.h b/include/asm-mips/rmi/msidef.h
new file mode 100644
index 0000000..a8aa92a
--- /dev/null
+++ b/include/asm-mips/rmi/msidef.h
@@ -0,0 +1,73 @@
+/***********************************************************************
+Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+reserved.
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+1. Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright
+notice, this list of conditions and the following disclaimer in
+the documentation and/or other materials provided with the
+distribution.
+THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+THE POSSIBILITY OF SUCH DAMAGE.
+*****************************#RMI_2#**********************************/
+
+#ifndef ASM_RMI_MSIDEF_H
+#define ASM_RMI_MSIDEF_H
+
+/*
+ * Constants for Intel APIC based MSI messages.
+ * Adapted for the RMI XLR using identical defines
+ */
+
+/*
+ * Shifts for MSI data
+ */
+
+#define MSI_DATA_VECTOR_SHIFT		0
+#define  MSI_DATA_VECTOR_MASK		0x000000ff
+#define	 MSI_DATA_VECTOR(v)		(((v) << MSI_DATA_VECTOR_SHIFT) & MSI_DATA_VECTOR_MASK)
+
+#define MSI_DATA_DELIVERY_MODE_SHIFT	8
+#define  MSI_DATA_DELIVERY_FIXED	(0 << MSI_DATA_DELIVERY_MODE_SHIFT)
+#define  MSI_DATA_DELIVERY_LOWPRI	(1 << MSI_DATA_DELIVERY_MODE_SHIFT)
+
+#define MSI_DATA_LEVEL_SHIFT		14
+#define	 MSI_DATA_LEVEL_DEASSERT	(0 << MSI_DATA_LEVEL_SHIFT)
+#define	 MSI_DATA_LEVEL_ASSERT		(1 << MSI_DATA_LEVEL_SHIFT)
+
+#define MSI_DATA_TRIGGER_SHIFT		15
+#define  MSI_DATA_TRIGGER_EDGE		(0 << MSI_DATA_TRIGGER_SHIFT)
+#define  MSI_DATA_TRIGGER_LEVEL		(1 << MSI_DATA_TRIGGER_SHIFT)
+
+/*
+ * Shift/mask fields for msi address
+ */
+
+#define MSI_ADDR_BASE_HI		0
+#define MSI_ADDR_BASE_LO		0xfee00000
+
+#define MSI_ADDR_DEST_MODE_SHIFT	2
+#define  MSI_ADDR_DEST_MODE_PHYSICAL	(0 << MSI_ADDR_DEST_MODE_SHIFT)
+#define	 MSI_ADDR_DEST_MODE_LOGICAL	(1 << MSI_ADDR_DEST_MODE_SHIFT)
+
+#define MSI_ADDR_REDIRECTION_SHIFT	3
+#define  MSI_ADDR_REDIRECTION_CPU	(0 << MSI_ADDR_REDIRECTION_SHIFT) /* dedicated cpu */
+#define  MSI_ADDR_REDIRECTION_LOWPRI	(1 << MSI_ADDR_REDIRECTION_SHIFT) /* lowest priority */
+
+#define MSI_ADDR_DEST_ID_SHIFT		12
+#define	 MSI_ADDR_DEST_ID_MASK		0x00ffff0
+#define  MSI_ADDR_DEST_ID(dest)		(((dest) << MSI_ADDR_DEST_ID_SHIFT) & MSI_ADDR_DEST_ID_MASK)
+
+#endif /* ASM_RMI_MSIDEF_H */
diff --git a/include/asm-mips/rmi/perf_ctr.h b/include/asm-mips/rmi/perf_ctr.h
new file mode 100644
index 0000000..0dd108f
--- /dev/null
+++ b/include/asm-mips/rmi/perf_ctr.h
@@ -0,0 +1,72 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef __ASM_RMI_PERF_CTR_H
+#define __ASM_RMI_PERF_CTR_H
+
+#include <asm/mipsregs.h>
+
+#define CP0_PERF_CTR  $25
+
+/* Subset of perf ctr events */
+
+#define PERF_CTR_INSTR_FETCHED           0
+#define PERF_CTR_ICACHE_MISSES           1
+#define PERF_CTR_SLEEP_CYCLES           12
+#define PERF_CTR_INSTR_RETIRED          17
+#define PERF_CTR_BRJMP_INSTR            20
+#define PERF_CTR_BRJMP_FLUSH            21
+#define PERF_CTR_REPLAYFLUSH            27
+#define PERF_CTR_REPLAYFLUSH_LDUSE      28
+#define PERF_CTR_L1_HIT                 38
+#define PERF_CTR_L1_REF                 39
+#define PERF_CTR_SNOOP_UPGRADE_FAIL     47
+#define PERF_CTR_SNOOP_TRANSFERS        48
+#define PERF_CTR_SNOOP_HITS             49
+#define PERF_CTR_SNOOP_OPS              50
+#define PERF_CTR_CYCLES                 63
+
+/* 2 sets of counters are supported across all threads of a core */
+#define PERF_CTR_EVENT0        0
+#define PERF_CTR_EVENT0_VALUE  1
+#define PERF_CTR_EVENT1        2
+#define PERF_CTR_EVENT1_VALUE  3
+
+#define PERF_CTR_DEFAULT 0x0f /* disable int, enable counting in all modes */
+
+#define perf_ctr_start(ctr, event, global, thr) __write_32bit_c0_register($25, ctr, ((PERF_CTR_DEFAULT)|((global)<<13)|((thr)<<11)|((event)<<5)) ) 
+
+#define perf_ctr_stop(ctr) __write_32bit_c0_register($25, ctr, 0)
+
+#define perf_ctr_reset(ctr) __write_32bit_c0_register($25, ctr, 0)
+
+#define perf_ctr_read(ctr) __read_32bit_c0_register($25, ctr)
+
+#endif /* __ASM_RMI_PERF_CTR_H */
diff --git a/include/asm-mips/rmi/phnx_loader.h b/include/asm-mips/rmi/phnx_loader.h
new file mode 100644
index 0000000..7f523f7
--- /dev/null
+++ b/include/asm-mips/rmi/phnx_loader.h
@@ -0,0 +1,175 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_PHNX_LOADER_H
+#define _ASM_RMI_PHNX_LOADER_H
+#include <linux/list.h>
+#include <asm/rmi/memory-exclusion.h>
+
+#define PHNX_LOADER_KSEG0_VIRT_START         0x60000000
+#define PHNX_LOADER_KSEG0_START         0x0c000000
+#define PHNX_LOADER_KSEG0_SIZE         0x04000000
+
+#define PHNX_LOADER_KUSEG_VIRT_START         0x20000000
+#define PHNX_LOADER_KUSEG_PHYS_START         0x20000000ULL
+#define PHNX_LOADER_KUSEG_PHYS_SIZE          0xf000000ULL /* for 512 MB boards*/
+
+/* the below macros go together */
+#define PHNX_LOADER_PHYS_SIZE          (512<<20)
+#define PHNX_LOADER_PMASK_SIZE         (PHNX_LOADER_PHYS_SIZE >> 1)
+#define PHNX_LOADER_PMASK_SIZE_256MB   0xffff
+
+#define PHNX_LOADER_IPI_VECTOR 51
+
+
+#if (_MIPS_SIM == _MIPS_SIM_ABI64)
+#define PTR2U64(x) (unsigned long)(x)
+#define U642PTR(x) (void *)((unsigned long)(x))
+#else
+// preserve sign-extension
+#define PTR2U64(x) (int)(x)
+#define U642PTR(x) (void *)((int)(x))
+#endif
+
+#define NUM_WORDS 2048
+
+#define XLR_THREAD_SIZE (NUM_WORDS * sizeof(long))
+
+#define PHNX_APP_SHMEM_MAX_SZ (512*1024*1024)
+#ifndef __ASSEMBLY__
+
+struct xlr_thread_info {
+	unsigned long stack[NUM_WORDS];
+};
+extern struct xlr_thread_info xlrthreads_info[];
+
+#endif
+
+#define PSB_MEM_MAP_MAX 32
+#define PSB_IO_MAP_MAX 32
+
+struct psb_mem_map {
+	int nr_map;
+	struct psb_mem_map_entry {
+		uint64_t addr;  /* start of memory segment */
+		uint64_t size;  /* size of memory segment */
+		uint32_t type;      /* type of memory segment */
+	} map[PSB_MEM_MAP_MAX];
+};
+
+struct psb_io_map {
+	int nr_map;
+	struct psb_io_map_entry {
+		uint64_t addr;  /* start of IO segment */
+		uint64_t size;  /* size of IO segment */
+		long type;      /* type of IO segment */
+	} map[PSB_IO_MAP_MAX];
+};
+
+struct r_exception_region {
+	    unsigned int data[1024];
+};
+
+#define PKT_DATA_LEN 1592
+#define PKT_SEC_AUTH_LEN 32
+#define PKT_SEC_CTRL_DESC_LEN 128
+#define PKT_SEC_PKT_DESC_LEN 32
+
+
+struct packet {
+	/* New cacheline */
+	uint8_t data[PKT_DATA_LEN];
+	uint32_t len;
+	uint32_t seq_num;
+	/* New cacheline */
+	uint8_t sec_ctrl_desc[PKT_SEC_CTRL_DESC_LEN];
+	/* New cacheline */
+	uint8_t sec_pkt_desc[PKT_SEC_PKT_DESC_LEN];
+	/* New cacheline */
+	uint8_t sec_auth[PKT_SEC_AUTH_LEN];
+	/* New cacheline */
+	uint16_t sec_cksum;
+	uint8_t sec_cksum_padding[30];
+	/* New cacheline */
+	uint32_t sec_error;
+	uint32_t sec_op_timestamp;
+	struct list_head sec_tx_list;
+	uint16_t sec_ctrl_desc_size;
+	uint8_t padding[14];
+	/* New cacheline */
+} __attribute__ ((aligned(32)));
+
+#define dprintk(fmt, args...) //printk(fmt, ##args)
+#define eprintk(fmt, args...) printk(fmt, ##args)
+
+#define MAX_LOADER_MEMORY_ENTRY 128
+
+#define XLR_MAX_THRDS 32
+
+#define MEM_ALLOC_REQUEST 1
+#define MEM_ALLOC_FAILED 2
+#define MEM_ALLOC_DONE 3
+#define MAX_NUM_KUSEG_BLOCKS 4
+
+struct phnx_loader_alloc_memory
+{
+	void *ptr;
+	size_t size;
+	int status;
+};
+
+struct phnx_loader_free_memory
+{
+	void *ptr;
+};
+
+struct xlr_rmios_pt_regs {
+	unsigned long long pad0[6];
+
+	unsigned long long regs[32];
+
+	unsigned long long cp0_status;
+	unsigned long long hi;
+	unsigned long long lo;
+
+	/*
+	 * saved cp0 registers
+	 */
+	unsigned long long cp0_badvaddr;
+	unsigned long long cp0_cause;
+	unsigned long long cp0_epc;
+};
+
+struct kuseg_mem_info {
+	uint64_t size;
+	uint64_t start_addr;
+};
+
+#endif
diff --git a/include/asm-mips/rmi/phnx_user_mac.h b/include/asm-mips/rmi/phnx_user_mac.h
new file mode 100644
index 0000000..57a7209
--- /dev/null
+++ b/include/asm-mips/rmi/phnx_user_mac.h
@@ -0,0 +1,61 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_PHNX_USER_MAC_H
+#define _ASM_RMI_PHNX_USER_MAC_H
+
+#define PHNX_USER_MAC_MMAP_VIRT_START 0x60000000
+#define PHNX_USER_MAC_SIZE            0x800000
+
+#ifndef __ASSEMBLY__
+#include <asm/rmi/sim.h>
+
+extern void phoenix_user_mac_update_time(void);
+
+struct xlr_user_mac_config {
+	int l4_extract;
+	int fast_syscall;
+};
+
+extern struct xlr_user_mac_config xlr_user_mac;
+
+static __inline__ int xlr_user_mac_l4_extract(void)
+{
+	return xlr_hybrid_user_mac() ? xlr_user_mac.l4_extract  : 0;
+}
+
+static __inline__ int xlr_user_mac_fast_syscall(void)
+{
+	return xlr_hybrid_user_mac() && (xlr_user_mac.fast_syscall == 1);
+}
+
+#endif
+
+#endif
diff --git a/include/asm-mips/rmi/phoenix_flash_pcmcia.h b/include/asm-mips/rmi/phoenix_flash_pcmcia.h
new file mode 100644
index 0000000..e2f9f36
--- /dev/null
+++ b/include/asm-mips/rmi/phoenix_flash_pcmcia.h
@@ -0,0 +1,116 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _FLASH_PCMCIA_H_
+#define _FLASH_PCMCIA_H_
+
+#define R_FLASH_PCMCIA_BASE_ADDR                    0x0
+#define   O_BASE_ADDR__base_addr                    0
+#define   W_BASE_ADDR__base_addr                    16
+#define R_FLASH_PCMCIA_BASE_ADDR_MASK               0x1
+#define   O_BASE_ADDR_MASK__base_amask              0
+#define   W_BASE_ADDR_MASK__base_amask              16
+#define R_FLASH_PCMCIA_DEV_PARM                     0x2
+#define   O_DEV_PARM__burst_mode_en                 0
+#define   O_DEV_PARM__burst_mode                    1
+#define   W_DEV_PARM__burst_mode                    3
+#define   O_DEV_PARM__wait_en                       4
+#define   O_DEV_PARM__wait_pol                      5
+#define   O_DEV_PARM__mx_addr                       6
+#define   O_DEV_PARM__dwidth                        7
+#define   W_DEV_PARM__dwidth                        2
+#define   O_DEV_PARM__pcmcia_en                     9
+#define   O_DEV_PARM__genif_en                      10
+#define   O_DEV_PARM__genparity_en                  11
+#define   O_DEV_PARM__genparity_type                12
+#define   O_DEV_PARM__adv_type                      13
+#define R_FLASH_TIMING_PARM_0                       0x3
+#define   O_FLASH_TIMING_PARM_0__ale_width          0
+#define   W_FLASH_TIMING_PARM_0__ale_width          3
+#define   O_FLASH_TIMING_PARM_0__ale_to_cs          3
+#define   W_FLASH_TIMING_PARM_0__ale_to_cs          3
+#define   O_FLASH_TIMING_PARM_0__cs_width           6
+#define   W_FLASH_TIMING_PARM_0__cs_width           5
+#define   O_FLASH_TIMING_PARM_0__wait_to_data       11
+#define   W_FLASH_TIMING_PARM_0__wait_to_data       5
+#define   O_FLASH_TIMING_PARM_0__cs_to_oe           16
+#define   W_FLASH_TIMING_PARM_0__cs_to_oe           3
+#define   O_FLASH_TIMING_PARM_0__cs_to_we           19
+#define   W_FLASH_TIMING_PARM_0__cs_to_we           3
+#define   O_FLASH_TIMING_PARM_0__oe_to_cs           22
+#define   W_FLASH_TIMING_PARM_0__oe_to_cs           2
+#define   O_FLASH_TIMING_PARM_0__we_to_cs           24
+#define   W_FLASH_TIMING_PARM_0__we_to_cs           4
+#define   O_FLASH_TIMING_PARM_0__cs_to_cs           28
+#define   W_FLASH_TIMING_PARM_0__cs_to_cs           4
+#define R_FLASH_TIMING_PARM_1                       0x4
+#define   O_FLASH_TIMING_PARM_1__oe_width           0
+#define   W_FLASH_TIMING_PARM_1__oe_width           6
+#define   O_FLASH_TIMING_PARM_1__we_width           6
+#define   W_FLASH_TIMING_PARM_1__we_width           6
+#define   O_FLASH_TIMING_PARM_1__wait_timeout       12
+#define   W_FLASH_TIMING_PARM_1__wait_timeout       15
+#define R_PCMCIA_CONFIG                             0x5
+#define   O_PCMCIA_CONFIG__pcmcia_en                0
+#define   O_PCMCIA_CONFIG__reg_access               1
+#define   O_PCMCIA_CONFIG__reset                    2
+#define   O_PCMCIA_CONFIG__cdmask                   4
+#define   O_PCMCIA_CONFIG__wpmask                   5
+#define   O_PCMCIA_CONFIG__rdymask                  6
+#define   O_PCMCIA_CONFIG__rybymask                 7
+#define R_PCMCIA_STATUS                             0x6
+#define   O_PCMCIA_STATUS__bvd1_sts                 0
+#define   O_PCMCIA_STATUS__bvd2_sts                 1
+#define   O_PCMCIA_STATUS__cd1_sts                  2
+#define   O_PCMCIA_STATUS__cd2_sts                  3
+#define   O_PCMCIA_STATUS__vs1_sts                  4
+#define   O_PCMCIA_STATUS__vs2_sts                  5
+#define   O_PCMCIA_STATUS__wp_sts                   6
+#define   O_PCMCIA_STATUS__rdy_sts                  7
+#define   O_PCMCIA_STATUS__ryby_sts                 8
+#define   O_PCMCIA_STATUS__cd_intr                  9
+#define   O_PCMCIA_STATUS__wp_intr                  10
+#define   O_PCMCIA_STATUS__rdy_intr                 11
+#define   O_PCMCIA_STATUS__illegal_addr_intrpt      12
+#define   O_PCMCIA_STATUS__mutl_cs_intrpt           13
+#define   O_PCMCIA_STATUS__wait_timeout_intrpt      14
+#define   O_PCMCIA_STATUS__ryby_intrpt              16
+#define   O_PCMCIA_STATUS__werr_intrpt              17
+#define   O_PCMCIA_STATUS__illegal_pcmcia_intrpt    18
+#define R_GENERIC_REGION_STATUS                     0x7
+#define   O_GENERIC_REGION_STATUS__cs_err_intrpt    0
+#define   W_GENERIC_REGION_STATUS__cs_err_intrpt    8
+#define R_GENERIC_ERROR_ADDR                        0x8
+#define   O_GENERIC_ERROR_ADDR__err_addr            0
+#define   W_GENERIC_ERROR_ADDR__err_addr            32
+
+
+#endif /* _FLASH_PCMCIA_H_ */
+
diff --git a/include/asm-mips/rmi/phoenix_ide.h b/include/asm-mips/rmi/phoenix_ide.h
new file mode 100644
index 0000000..0582057
--- /dev/null
+++ b/include/asm-mips/rmi/phoenix_ide.h
@@ -0,0 +1,62 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef __ASM_PHOENIX_H
+#define __ASM_PHOENIX_H
+
+
+#define  CONFIG_PHOENIX 1
+
+#ifdef CONFIG_PHOENIX
+#define PHOENIX_BOARD_NAME "PHOENIX -ATX1"
+#define PHOENIX_HAVE_PCMCIA 0
+#define PHOENIX_HAVE_IDE    1
+#endif
+
+
+#ifdef PHOENIX_HAVE_IDE
+#define IDE_CS          6
+#define IDE_PHYS        0x1D000000
+#define K_GPIO_GB_IDE   4
+#define K_GPIO_PC_READY 11 
+#define K_INT_GPIO_0    32 
+#define K_INT_GB_IDE    (K_INT_GPIO_0 + K_GPIO_GB_IDE)
+#endif
+
+#ifdef PHOENIX_HAVE_PCMCIA
+#define PCMCIA_CS       4
+#define PCMCIA_PHYS     0x11000000
+#define K_INT_PC_READY  (K_INT_GPIO_0 + K_GPIO_PC_READY)
+#endif
+
+
+#define IOADDR(a) (UNCAC_BASE + (a))
+
+#endif /* __ASM_PHOENIX_H */
diff --git a/include/asm-mips/rmi/proc.h b/include/asm-mips/rmi/proc.h
new file mode 100644
index 0000000..d69b18c
--- /dev/null
+++ b/include/asm-mips/rmi/proc.h
@@ -0,0 +1,51 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_PROC_H
+#define _ASM_RMI_PROC_H
+
+#include <linux/types.h>
+
+static __inline__ int proc_pos_check(off_t * begin, int *len, off_t off,
+				     int count)
+{
+	off_t pos = *begin + *len;
+
+	if (pos < off) {
+		*len = 0;
+		*begin = pos;
+	}
+	if (pos > off + count)
+		return 0;
+
+	return 1;
+}
+
+#endif
diff --git a/include/asm-mips/rmi/rmi_pcix_gen_dev.h b/include/asm-mips/rmi/rmi_pcix_gen_dev.h
new file mode 100644
index 0000000..af2ad0f
--- /dev/null
+++ b/include/asm-mips/rmi/rmi_pcix_gen_dev.h
@@ -0,0 +1,124 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef __PHNX_PCIX_DEVICE_H__
+#define __PHNX_PCIX_DEVICE_H__
+
+#include <asm/types.h>
+#include <linux/cache.h>
+
+#ifdef PHOENIX_LITTLE_ENDIAN
+#define PCIX_REG_BASE 64
+#else
+#define PCIX_REG_BASE (512 + 64)
+#endif
+
+/*Define this macro if device supports MAILBOX interrupt.*/
+//#define XLR_MAILBOX_IS_SUPPORTED 1
+
+/*Define this macro if host is MSI capable.*/
+//#define XLR_MSI_IS_SUPPORTED 1
+
+#define XLR_PCI_HOST_MODE 0x1
+#define XLR_PCI_DEV_MODE 0x2
+#define PCIX_INTRPT_CONTROL_REG ( PCIX_REG_BASE + 15)
+#define PCIX_PHOENIX_CONTROL_REG ( PCIX_REG_BASE + 14)
+#define PCIX_INTRPT_STATUS_REG ( PCIX_REG_BASE + 16)
+#define PCIX_HOST_MODE_CTRL_STATUS_REG ( PCIX_REG_BASE + 35)
+#define PCIX_DEVICE_MODE_ADDR_MAPPER ( PCIX_REG_BASE + 36)
+#define PCIX_DEVMODE_TBL_BAR0_REG                   (PCIX_REG_BASE + 44)
+#define PCIX_DEVMODE_TBL_BAR1_REG                   (PCIX_REG_BASE + 45)
+#define PCIX_DEVMODE_TBL_BAR2_REG                   (PCIX_REG_BASE + 46)
+#define PCIX_DEVMODE_TBL_BAR3_REG                   (PCIX_REG_BASE + 47)
+
+#define PHNX_MAX_IRQS_SUPPORTED 16
+
+#define phnx_host_to_pci(addr) ((uint64_t)(addr) | 0x8000000000UL)
+
+#define CACHELINE_ALIGNED_ADDR(addr) \
+			(((unsigned long)(addr)) & ~(SMP_CACHE_BYTES-1))
+
+
+int xlr_get_pci_mode(void);
+void phnx_interrupt_host(void);
+// DEVICE SIDE
+#ifdef XLR_MAILBOX_IS_SUPPORTED
+typedef int (*mailbox_handler)(void *, struct pt_regs *);
+int phnx_request_mailbox_handler(mailbox_handler, void *, int *);
+int phnx_disable_mailbox_intr(int *);
+int phnx_enable_mailbox_intr(int *);
+int phnx_free_mailbox_handler(int *);
+#endif
+
+
+/*****************************************************************************************************************/
+/**********************************SHARED    MEMORY***************************************************************/
+/*****************************************************************************************************************/
+// DURING BOOT ONLY
+
+#define PHNX_BOOT_SHARED_MEM_BASE 0x1000
+#define PHNX_BOOT_SHARED_MEM_SIZE (32 * 1024 * 1024)
+
+
+// AFTER BOOTIN WHOLE SHARED MEMORY IS CLAIMED BY THE GENERIC PCI DRIVER 
+#define PHNX_GENERIC_SHARED_MEM_BASE (20*1024*1024)
+#define PHNX_GENERIC_SHARED_MEM_SIZE (10*1024*1024)
+
+#define PHNX_PCIX_SHARED_MEM_START (0x8000000+PHNX_GENERIC_SHARED_MEM_BASE)
+#define PHNX_PCIX_SHARED_MEM_END (PHNX_PCIX_SHARED_MEM_START+PHNX_GENERIC_SHARED_MEM_SIZE)
+// All The Shared Address must be unique for each driver. Confliction of Address Space can cause unpredictable result. Shared Space Must be in sync with that of host driver.
+
+
+// SHARED SPACE BETWEEN MAC DRIVERS
+#define PHNX_MAC_SHARED_MEM_BASE PHNX_GENERIC_SHARED_MEM_BASE
+#define PHNX_MAC_SHARED_MEM_SIZE (1 * 1024 * 1024)
+
+
+// SHARED SPACE BETWEEN CONSOLE DRIVERS
+#define PHNX_CONSOLE_OVER_PCI_SHARED_MEM_BASE \
+	         (PHNX_MAC_SHARED_MEM_BASE + PHNX_MAC_SHARED_MEM_SIZE)
+#define PHNX_CONSOLE_OVER_PCI_SHARED_MEM_SIZE (9 * 1024)
+
+// SHARED space for DMA
+#define PHNX_DMA_MEM_BASE \
+			(PHNX_CONSOLE_OVER_PCI_SHARED_MEM_BASE + \
+	 		PHNX_CONSOLE_OVER_PCI_SHARED_MEM_SIZE)
+#define PHNX_DMA_MEM_SIZE 1024
+
+// SHARED SPACE BETWEEN IP OVER PCI DRIVER...
+#define PHNX_IP_OVER_PCI_MEM_BASE \
+			(PHNX_DMA_MEM_BASE + PHNX_DMA_MEM_SIZE)
+#define PHNX_IP_OVER_PCI_MEM_SIZE (8*512+8*512+1024) 
+
+// SHARED SPACE BETWEEN SECURITY DRIVER... xxxx
+//
+//
+
+#endif
diff --git a/include/asm-mips/rmi/rmi_rw_lock.h b/include/asm-mips/rmi/rmi_rw_lock.h
new file mode 100644
index 0000000..e83c18b
--- /dev/null
+++ b/include/asm-mips/rmi/rmi_rw_lock.h
@@ -0,0 +1,221 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+#ifndef __RMI_RW_LOCK_H_
+#define __RMI_RW_LOCK_H_
+
+#define RMI_MAX_CPUS 32
+typedef struct {
+	volatile unsigned int lock;
+	unsigned int read_cpus[RMI_MAX_CPUS]; /* cpus that hold rd lock */
+	int write_cpu; /* CPU that is currently holding wr lock */
+} rmi_rwlock_t;
+
+#define rmi_sync() __asm__ __volatile__("sync": : :"memory")
+__asm__ (
+		".macro\trmi_local_irq_save result\n\t"
+		".set\tpush\n\t"
+		".set\treorder\n\t"
+		".set\tnoat\n\t"
+		"mfc0\t\\result, $12\n\t"
+		"ori\t$1, \\result, 1\n\t"
+		"xori\t$1, 1\n\t"
+		".set\tnoreorder\n\t"
+		"mtc0\t$1, $12\n\t"
+		"sll\t$0, $0, 1\t\t\t# nop\n\t"
+		"sll\t$0, $0, 1\t\t\t# nop\n\t"
+		"sll\t$0, $0, 1\t\t\t# nop\n\t"
+		".set\tpop\n\t"
+		".endm");
+
+__asm__(".macro\trmi_local_irq_restore flags\n\t"
+		".set\tnoreorder\n\t"
+		".set\tnoat\n\t"
+		"mfc0\t$1, $12\n\t"
+		"andi\t\\flags, 1\n\t"
+		"ori\t$1, 1\n\t"
+		"xori\t$1, 1\n\t"
+		"or\t\\flags, $1\n\t"
+		"mtc0\t\\flags, $12\n\t"
+		"sll\t$0, $0, 1\t\t\t# nop\n\t"
+		"sll\t$0, $0, 1\t\t\t# nop\n\t"
+		"sll\t$0, $0, 1\t\t\t# nop\n\t"
+		".set\tat\n\t"
+		".set\treorder\n\t"
+		".endm");
+
+
+#define rmi_local_irq_save(x)		\
+	__asm__ __volatile__(           \
+		"rmi_local_irq_save\t%0"                                    \
+		: "=r" (x)		\
+		: /* no inputs */	\
+		: "memory")
+
+
+#define rmi_local_irq_restore(flags)		\
+	do {                           		\
+		unsigned long __tmp1;  		\
+		__asm__ __volatile__(  		\
+		"rmi_local_irq_restore\t%0"        	\
+		: "=r" (__tmp1)                 \
+		: "0" (flags)                   \
+		: "memory");                    \
+	} while(0)
+
+
+#define rmi_processor_id() 				\
+	({ int __res;                                   \
+	 __asm__ __volatile__(                          \
+		 ".set\tmips32\n\t"                     \
+		 "mfc0\t%0, $15, 1\n\t"           	\
+		 "andi\t%0, 0x1f\n\t"			\
+		 ".set\tmips0\n\t"                      \
+		 : "=r" (__res));                       \
+	 __res;                                         \
+	 })
+
+
+static inline unsigned int rmi_read_lock_irq_save(rmi_rwlock_t *rw)
+{
+	unsigned int temp;
+	unsigned int cpu;
+	unsigned int flags;
+
+	rmi_local_irq_save(flags);
+	cpu = rmi_processor_id();
+
+		__asm__ __volatile__(
+		"	.set	noreorder	\n"
+		"1:	ll	%1, %2		\n"
+		"	bltz	%1, 2f		\n"
+		"	 addu	%1, 1		\n"
+		"	sc	%1, %0		\n"
+		"	beqz	%1, 1b		\n"
+		"	 nop			\n"
+		"	.subsection 2		\n"
+		"2:	ll	%1, %2		\n"
+		"	bltz	%1, 2b		\n"
+		"	 addu	%1, 1		\n"
+		"	b	1b		\n"
+		"	 nop			\n"
+		"	.previous		\n"
+		"	.set	reorder		\n"
+		: "=m" (rw->lock), "=&r" (temp)
+		: "m" (rw->lock)
+		: "memory");
+
+		rw->read_cpus[cpu] = 1;
+		rmi_sync();
+
+		return flags;
+}
+
+static inline void rmi_read_unlock_irq_restore(rmi_rwlock_t *rw, 
+			unsigned int flags)
+{
+	unsigned int temp;
+	unsigned int cpu;
+
+	cpu = rmi_processor_id();
+
+	rmi_sync();
+	__asm__ __volatile__(
+		"       .set    noreorder       			\n"
+		"1:     ll      %1, %2                                  \n"
+		"       sub     %1, 1                                   \n"
+		"       sc      %1, %0                                  \n"
+		"       beqz    %1, 2f                                  \n"
+		"        nop                                            \n"
+		"       .subsection 2                                   \n"
+		"2:     b       1b                                      \n"
+		"        nop                                            \n"
+		"       .previous                                       \n"
+		"       .set    reorder                                 \n"
+		: "=m" (rw->lock), "=&r" (temp)
+		: "m" (rw->lock)
+		: "memory");
+	rw->read_cpus[cpu] = 0;
+	rmi_local_irq_restore(flags);
+
+}
+
+static inline unsigned int rmi_write_lock_irq_save(rmi_rwlock_t *rw)
+{
+	unsigned int temp;
+	unsigned int cpu;
+	unsigned int flags;
+
+	rmi_local_irq_save(flags);
+	cpu = rmi_processor_id();
+
+	__asm__ __volatile__(
+		"       .set    noreorder       			\n"
+		"1:     ll      %1, %2                                  \n"
+		"       bnez    %1, 2f                                  \n"
+		"        lui    %1, 0x8000                              \n"
+		"       sc      %1, %0                                  \n"
+		"       beqz    %1, 2f                                  \n"
+		"        nop                                            \n"
+		"       .subsection 2                                   \n"
+		"2:     ll      %1, %2                                  \n"
+		"       bnez    %1, 2b                                  \n"
+		"        lui    %1, 0x8000                              \n"
+		"       b       1b                                      \n"
+		"        nop                                            \n"
+		"       .previous                                       \n"
+		"       .set    reorder                                 \n"
+		: "=m" (rw->lock), "=&r" (temp)
+		: "m" (rw->lock)
+		: "memory");
+
+	rw->write_cpu = cpu;
+	rmi_sync();
+	
+	return flags;
+
+}
+
+
+static inline void rmi_write_unlock_irq_restore(rmi_rwlock_t *rw, 
+						unsigned int flags)
+{
+	rmi_sync();
+
+	__asm__ __volatile__(
+		"       sw      $0, %0                                  \n"
+		: "=m" (rw->lock)
+		: "m" (rw->lock)
+		: "memory");
+	rw->write_cpu = -1;
+	rmi_local_irq_restore(flags);
+}
+
+
+#endif
diff --git a/include/asm-mips/rmi/rmi_srio.h b/include/asm-mips/rmi/rmi_srio.h
new file mode 100644
index 0000000..35c0801
--- /dev/null
+++ b/include/asm-mips/rmi/rmi_srio.h
@@ -0,0 +1,343 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+/*
+ * XLS RapidIO definitions
+ */
+
+#ifndef __XLS_SRIO_H__
+#define __XLS_SRIO_H__
+
+#include <asm/rmi/sim.h>
+
+static inline int is_xlsb0_srio(void) 
+{
+    unsigned int gpio_srio = 0;
+    uint32_t *gpio_mmio = (uint32_t *)
+                            (DEFAULT_PHOENIX_IO_BASE + PHOENIX_IO_GPIO_OFFSET);
+
+    if (xlr_board_atx_xi() || xlr_board_atx_xii()) {
+        gpio_srio = ((phoenix_read_reg(gpio_mmio,21) >> 26) & 0x3);
+        if (gpio_srio) {
+            return 1;
+        }
+        else {
+            return 0;
+        }
+    }
+    return 0;
+}
+
+#define RIO_OPS_LOCAL_CONFIG_READ(i) \
+        static int rmi_local_config_read_##i(struct rio_mport *mport, int pindex, u32 offset,int len, \
+                    u32 *data) \
+        { \
+            return rmi_local_config_read(rio_controller[i], pindex, offset, len, data);\
+        }
+
+#define RIO_OPS_LOCAL_CONFIG_WRITE(i) \
+static int rmi_local_config_write_##i(struct rio_mport *mport, int pindex, u32 offset,int len, u32 data)\
+{ \
+  return rmi_local_config_write(rio_controller[i], pindex, offset, len, data);\
+}
+
+#define RIO_OPS_CONFIG_READ(i) \
+static int rmi_rio_config_read_##i(struct rio_mport *mport, int index, u16 destid, u8 hopcount,\
+                                     u32 offset,int len, u32 *val) \
+{ \
+    return rmi_rio_config_read(rio_controller[i], index, destid, hopcount,\
+                        offset, len, val);\
+}
+
+#define RIO_OPS_CONFIG_WRITE(i) \
+static int rmi_rio_config_write_##i(struct rio_mport *mport, int index, u16 destid, u8 hopcount, \
+                                    u32 offset,int len, u32 val)\
+{\
+    return rmi_rio_config_write(rio_controller[i], index, destid, \
+                            hopcount, offset, len, val);\
+}
+
+#define RIO_OPS_DOORBELL_SEND(i)\
+static int rmi_rio_doorbell_send_##i(struct rio_mport *mport, int index, u16 destid, u16 data)\
+{\
+    return rmi_rio_doorbell_send(rio_controller[i], index, destid, data);\
+}
+
+void rmi_rio_setup(void);
+
+#define SRIO_IRQ(irq) (PIC_SRIO_LINK0_IRQ+irq)
+#define SRIO_CFG_BIT 21
+
+#define SRIO_X1_MODE 1
+#define SRIO_X4_MODE 2
+
+#define MAX_SRIO_PORTS 4
+#define MIN_SRIO_PORTS 1
+
+#define RMI_SRIO_MEM_SIZE (16<<20)
+
+/*BE space starts @ 0x14000000*/
+#define RMI_SRIO_MEM_0 ((256<<20) + (64<<20))
+#define RMI_SRIO_MEM_1 (RMI_SRIO_MEM_0 + RMI_SRIO_MEM_SIZE) 
+#define RMI_SRIO_MEM_2 (RMI_SRIO_MEM_1 + RMI_SRIO_MEM_SIZE) 
+#define RMI_SRIO_MEM_3 (RMI_SRIO_MEM_2 + RMI_SRIO_MEM_SIZE) 
+
+#define MAX_TQ_ENTRY 256
+#define MAX_SQ_ENTRY MAX_TQ_ENTRY 
+
+#define SIZE_OF_TQ_ENTRY 24
+#define SIZE_OF_SQ_ENTRY (16<<1)
+
+#define MAX_TRANSACTION_Q   2
+#define MAX_STATUS_Q        MAX_TRANSACTION_Q 
+
+#define MAX_MAILBOX_Q       4
+#define MAX_FREEL_Q         MAX_MAILBOX_Q 
+#define MAX_MAILBOX_ENTRY   128
+#define MAX_FREEL_ENTRY     MAX_MAILBOX_ENTRY   
+#define SIZE_OF_MQ_ENTRY    (16<<1)
+#define SIZE_OF_FQ_ENTRY    (8)
+
+/***************************************/
+/**Glue logic Register Goes here**/
+/***************************************/
+#define SRIO_CTRL 0x0
+#define SRIO_PHY_CTRL0  0x1
+#define SRIO_PHY_CTRL1  0x2
+#define SRIO_PHY0_CTRL  0x3
+#define SRIO_PHY1_CTRL  0x4
+#define SRIO_PHY2_CTRL  0x5
+#define SRIO_PHY3_CTRL  0x6
+#define SRIO_COHERENT_MEM_BASE 0x8
+#define SRIO_COHERENT_MEM_LIMIT 0x9
+#define SRIO_REG_L2ALLOC_MEM_BASE 0x10
+#define SRIO_REG_L2ALLOC_MEM_LIMIT 0x11
+#define SRIO_REG_READEX_MEM_BASE 0x12
+#define SRIO_REG_READEX_MEM_LIMIT 0x13
+#define SRIO_REG_PHY_CR_CMD 0x16
+#define SRIO_REG_PHY_CR_WR_DATA 0x17
+#define SRIO_REG_PHY_CR_RESP 0x18
+#define SRIO_REG_PHY_CR_RD_DATA 0x19
+/***************************************/
+/**Glue logic Register Ends here**/
+/***************************************/
+
+/***************************************/
+/**Extended Feature Register Goes here**/
+/***************************************/
+#define P0_EAS_CSR 0x158
+
+#define P0_CTRL_CSR 0x15c
+    /*BIT Fields*/
+    #define OUTPUT_PORT_EN  22
+    #define INPUT_PORT_EN   21
+    #define MULTI_EVENT_EN  12
+
+/***************************************/
+/**Extended Feature Register Ends here**/
+/***************************************/
+
+/***************************************/
+/*Jennic Controller registers goes here*/
+/***************************************/
+
+/*Transaction Types goes here*/
+#define TYPE_MAINTAIN_READ      13
+#define TYPE_MAINTAIN_WRITE     14
+#define TYPE_MESSAGE            16
+#define TYPE_DOORBELL           17
+
+/*Transaction Types ends here*/
+
+/*Implementation defined registers starts*/
+#define MASTER_INTR_STATUS_REG 0x10000
+    #define MISR_DF     (1<<3)
+    #define MISR_MQ3    (1<<6)
+    #define MISR_SQ     (1<<9)
+    #define MISR_GEN    (1<<11)
+#define MASTER_INTR_ENABLE_REG 0x10004
+    /*BIT Fields*/
+    #define MIER_DF     3
+    #define MIER_MQ3    6
+    #define MIER_SQ     9
+    #define MIER_GEN    11
+#define GENERAL_INTR_STATUS_REG 0x10010
+    /*BIT Fields*/
+    #define GISR_PERR   (1<<2)
+    #define GISR_DEC    (1<<5)
+    #define GISR_MQWE   (1<<7)
+    #define GISR_SQWE   (1<<8)
+#define GENERAL_INTR_ENABLE_REG 0x10014
+    /*BIT Fields*/
+    #define GIER_PERR   2
+    #define GIER_DEC    5    
+    #define GIER_MQWE   7
+    #define GIER_SQWE   8
+#define DMA_ERR_CAP_HIGH    0x10030
+#define DMA_ERR_CAP_LOW     0x10034
+#define DMA_ERR_CAP_INFO    0x10038
+/*Transaction Q Registers*/
+#define TRANSACTION_QUEUE_START(n)  (0x20000+0x20*(n))
+#define TRANSACTION_QUEUE_END(n)    (0x20004+0x20*(n))
+#define TRANSACTION_QUEUE_HEAD(n)   (0x20008+0x20*(n))
+#define TRANSACTION_QUEUE_TAIL(n)   (0x2000c+0x20*(n))
+    /*BIT Fields*/
+    #define TQ_LOCK 0
+    #define TQ_FULL 1
+#define TRANSACTION_QUEUE_UPTR(n)   (0x20010+0x20*(n))
+#define TRANSACTION_QUEUE_CTRL_1    (0x20200)
+    /*BIT Fields*/
+    #define CONFIGURE_TQUEUE(n)      (16+n)
+    #define ENABLE_QUEUE            11
+#define TRANSACTION_QUEUE_CTRL_2    (0x20204)
+#define TRANSACTION_QUEUE_STAT      (0x20208)
+#define TRANSACTION_QUEUE_IER       (0x2020c)
+    /*BIT Fields*/
+    #define IN_ENABLE(n)            (16+n)
+
+/*Maintenance Transactions Fields starts*/
+/*word-0*/
+#define MAINT_DEST_ID 16
+#define MAINT_DID_SIZE 7
+/*word-1*/
+#define MAINT_TRANS_SIZE 2
+#define MAINT_TRANS_DEFAULT_BITS 0
+/*word-2*/
+/*word-3*/
+#define MAINT_HOP_COUNT     22
+#define MAINT_REG_OFFSET    0
+/*word-4*/
+/*word-5*/
+/*word-6*/
+
+/*Maintenance Transactions Fields ends*/
+
+/*Message Transactions Fields starts*/
+/*word-0*/
+#define MSG_DEST_ID 16
+#define MSG_DID_SIZE 7
+/*word-1*/
+#define MSG_TRAN_SIZE       3
+#define MSG_MAILBOX_NUMBER  24
+#define MSG_SEG_SIZE        16
+/*Message Transactions Fields ends*/
+
+/*Door bell Transactions Fields starts*/
+/*word-0*/
+#define DBELL_DEST_ID 16
+#define DBELL_DID_SIZE 7
+/*word-1*/
+#define DBELL_INFO  16
+/*Door bell Transactions Fields ends*/
+
+/*Status Q Registers Starts*/
+#define STATUS_QUEUE_START(n)   (0x20400+0x20*(n))
+#define STATUS_QUEUE_END(n)     (0x20404+0x20*(n))
+#define STATUS_QUEUE_HEAD(n)    (0x20408+0x20*(n))
+    /*Bit Fields */
+    #define  SQ_EMPTY 1
+#define STATUS_QUEUE_TAIL(n)    (0x2040c+0x20*(n))
+#define STATUS_QUEUE_UPTR(n)    (0x20410+0x20*(n))
+#define STATUS_QUEUE_CTRL       (0x20600)
+    /*BIT Fields*/
+    #define CONFIGURE_SQUEUE(n)      (16+n)
+#define STATUS_QUEUE_STAT       (0x20608)
+#define STATUS_QUEUE_IER        (0x2060c)
+    /*BIT Fields*/
+    #define NNE_INTR(n)         (n)
+/*Status Q Registers Ends*/
+
+/*Free list Q Registers Starts*/
+#define FREEL_QUEUE_START(n)       (0x20a00+0x20*(n))
+#define FREEL_QUEUE_END(n)         (0x20a04+0x20*(n))
+#define FREEL_QUEUE_HEAD(n)        (0x20a08+0x20*(n))
+#define FREEL_QUEUE_TAIL(n)        (0x20a0c+0x20*(n))
+#define FREEL_QUEUE_UPTR(n)        (0x20a10+0x20*(n))
+    /*Bit fields*/
+    #define FQ_LOCK     0
+    #define FQ_FULL     1
+#define FREEL_BUF_SIZE(n)          (0x20a14+0x20*(n))
+    /*BIT fields*/
+    #define FL_BUF_SIZE            3
+#define FREEL_CONTROL_REG          (0x20c00)
+    /*Bit fields*/
+    #define CONFIGURE_FLQUEUE(n)    (n+16)
+#define FREEL_STATUS_REG           (0x20c08)
+#define FREEL_INT_EN               (0x20c0c)
+/*Free list Q Registers Ends*/
+
+/*Mailbox Q Registers Starts*/
+#define MAILBOX_QUEUE_START(n)  (0x21000+0x20*(n))
+#define MAILBOX_QUEUE_END(n)    (0x21004+0x20*(n))
+#define MAILBOX_QUEUE_HEAD(n)  (0x21008+0x20*(n))
+    /*Bit fields*/
+    #define MQ_EMPTY    1
+#define MAILBOX_QUEUE_TAIL(n)    (0x2100c+0x20*(n))
+#define MAILBOX_QUEUE_UPTR(n)    (0x21010+0x20*(n))
+
+#define MAILBOX_CONTROL_1   0x21800
+    /*BIT Fields*/
+    #define CONFIGURE_MQUEUE(n) (n)
+#define MAILBOX_CONTROL_2   0x21804
+#define MAILBOX_CONTROL_3   0x21808
+    /*BIT Fields*/
+    #define HIGH_MAILB_NO   (6)
+
+#define MAILBOX_STATUS_1    0x21820
+#define MAILBOX_STATUS_2    0x21824
+#define MAILBOX_STATUS_3    0x21828
+#define MAILBOX_STATUS_4    0x2182c
+
+#define MAILBOX_INT_EN_1    0x21830
+#define MAILBOX_INT_EN_2    0x21834
+#define MAILBOX_INT_EN_3    0x21838
+#define MAILBOX_INT_EN_4    0x2183c
+
+/*Mailbox Q Registers Ends*/
+
+/*Door Bell Registers Starts*/
+#define DOORBELL_INFO       0x20804
+    /*Bit fields*/
+    #define DFIFO_NUM       16 
+#define DOORBELL_INTR       0x2080c
+    /*Bit fields*/
+    #define DB_NNE          0
+#define DOORBELL_READ       0x20810
+    /*Bit fields*/
+    #define DB_SRCID        16
+/*Door Bell Registers Ends*/
+
+/*Implementation defined registers ends*/
+
+
+/***************************************/
+/*Jennic Controller registers ends here*/
+/***************************************/
+
+#endif				/* __XLS_SRIO_H__ */
diff --git a/include/asm-mips/rmi/sim.h b/include/asm-mips/rmi/sim.h
new file mode 100644
index 0000000..72a7956
--- /dev/null
+++ b/include/asm-mips/rmi/sim.h
@@ -0,0 +1,443 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_SIM_H
+#define _ASM_SIM_H
+
+#include <linux/types.h>
+#include <asm/cpu.h>
+#include <asm/mipsregs.h>
+
+#define PSB_INFO_VERSION 0x0001
+
+struct psb_info {
+	uint64_t boot_level;
+	uint64_t io_base;
+	uint64_t output_device;
+	uint64_t uart_print;
+	uint64_t led_output;
+	uint64_t init;
+	uint64_t exit;
+	uint64_t warm_reset;
+	uint64_t wakeup;
+	uint64_t cpu_online_map;
+	uint64_t master_reentry_sp;
+	uint64_t master_reentry_gp;
+	uint64_t master_reentry_fn;
+	uint64_t slave_reentry_fn;
+	uint64_t magic_dword;
+	uint64_t uart_putchar;
+	uint64_t size;
+	uint64_t uart_getchar;
+	uint64_t nmi_handler;
+	uint64_t psb_version;
+	uint64_t mac_addr;
+	uint64_t cpu_frequency;
+	uint64_t board_version;
+	uint64_t malloc;
+	uint64_t free;
+	uint64_t global_shmem_addr;
+	uint64_t global_shmem_size;
+	uint64_t psb_os_cpu_map;
+	uint64_t userapp_cpu_map;
+	uint64_t wakeup_os;
+	uint64_t psb_mem_map;
+	uint64_t board_major_version;
+	uint64_t board_minor_version;
+	uint64_t board_manf_revision;
+	uint64_t board_serial_number;
+	uint64_t psb_physaddr_map;
+	uint64_t xlr_loaderip_config;
+	uint64_t bldr_envp;
+	uint64_t avail_mem_map;
+};
+
+
+enum {
+        PHOENIX_IO_SPACE = 0x10,
+        PCIX_IO_SPACE,
+        PCIX_CFG_SPACE,
+        PCIX_MEMORY_SPACE,
+        HT_IO_SPACE,
+        HT_CFG_SPACE,
+        HT_MEMORY_SPACE,
+        SRAM_SPACE,
+        FLASH_CONTROLLER_SPACE
+};
+
+extern struct psb_info *prom_info;
+
+#define MAX_ENV_BUF 0x00020000 // 128 KB = One sector of Intel flash.
+struct environment
+{
+        unsigned int crc;
+        unsigned char envbuf[MAX_ENV_BUF - 20]; // 4 bytes for CRC and 16 bytes reserved.
+        unsigned char reserved[16];
+};
+
+#define RMI_PHOENIX_BOARD_ARIZONA_I   1
+#define RMI_PHOENIX_BOARD_ARIZONA_II  2
+#define RMI_PHOENIX_BOARD_ARIZONA_III 3
+#define RMI_PHOENIX_BOARD_ARIZONA_IV  4
+#define RMI_PHOENIX_BOARD_ARIZONA_V   5
+#define RMI_PHOENIX_BOARD_ARIZONA_VI   6  /* XLS boards */
+#define RMI_PHOENIX_BOARD_ARIZONA_VII 7 /*XLS 2xx boards*/
+#define RMI_PHOENIX_BOARD_ARIZONA_VIII 8 /*XLS LTE boards*/
+#define RMI_PHOENIX_BOARD_ARIZONA_XI 11
+#define RMI_PHOENIX_BOARD_ARIZONA_XII  12
+
+struct smp_boot_info_percpu {
+  volatile unsigned long ready;
+  volatile unsigned long sp;
+  volatile unsigned long gp;
+  volatile unsigned long fn;
+};
+
+struct smp_boot_info {
+  struct smp_boot_info_percpu boot_info[32];
+  __u32 online_map;
+};
+
+extern struct smp_boot_info smp_boot;
+extern void prom_boot_cpus_secondary(void *);
+
+extern __u32 xlr_board_major_version;
+extern __u32 xlr_board_minor_version;
+
+#define XLR_REVISION_A0 0xc0000
+#define XLR_REVISION_A1 0xc0001
+#define XLR_REVISION_B0 0xc0002
+#define XLR_REVISION_B1 0xc0003
+#define XLR_REVISION_B2 0xc0004
+#define XLR_REVISION_C0 0xc0005
+#define XLR_REVISION_C1 0xc0006
+#define XLR_REVISION_C2 0xc0007
+#define XLR_REVISION_C3 0xc0008
+#define XLR_REVISION_C4 0xc0009
+
+static __inline__ unsigned int xlr_revision(void)
+{
+	return read_c0_prid() & 0xff00ff;
+}
+
+static __inline__ int xlr_revision_a0(void)
+{
+	return xlr_revision() == XLR_REVISION_A0;
+}
+
+static __inline__ int xlr_revision_b0(void)
+{
+	return xlr_revision() == XLR_REVISION_B0;
+}
+
+static __inline__ int xlr_revision_b1(void)
+{
+        return xlr_revision() == XLR_REVISION_B1;
+}
+
+static __inline__ int xlr_revision_c(void)
+{
+    uint32_t prid = read_c0_prid();
+    if(prid>=XLR_REVISION_C0 && prid<=XLR_REVISION_C4)
+        return 1;        
+    return 0; 
+}
+
+static __inline__ int xlr_board_atx_i(void)
+{
+	return xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_I;
+}
+
+static __inline__ int xlr_board_atx_ii(void)
+{
+	return xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_II;
+}
+
+static __inline__ int xlr_board_atx_ii_b(void)
+{
+	return (xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_II)
+		&& (xlr_board_minor_version == 1);
+}
+
+static __inline__ int xlr_board_atx_iii(void)
+{
+	return xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_III;
+}
+
+static __inline__ int xlr_board_atx_iv(void)
+{
+	return (xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_IV)
+		&& (xlr_board_minor_version == 0);
+}
+
+static __inline__ int xlr_board_atx_iv_b(void)
+{
+	return (xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_IV)
+		&& (xlr_board_minor_version == 1);
+}
+
+static __inline__ int xlr_board_atx_v(void)
+{
+	return xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_V;
+}
+
+static __inline__ int xlr_board_atx_iii_256(void)
+{
+	return (xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_III)
+		&& (xlr_board_minor_version == 0);
+}
+
+static __inline__ int xlr_board_atx_iii_512(void)
+{
+	return (xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_III)
+		&& (xlr_board_minor_version == 1);
+}
+
+static __inline__ int xlr_board_atx_v_512(void)
+{
+	return (xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_V)
+		&& (xlr_board_minor_version == 1);
+}
+
+static __inline__ int xlr_board_atx_vi(void)
+{
+	return (xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_VI);
+}
+
+static __inline__ int xlr_board_atx_vii(void)
+{
+	return (xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_VII);
+}
+
+static __inline__ int xlr_board_atx_viii(void)
+{
+	return (xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_VIII);
+}
+
+static __inline__ int xlr_board_atx_xi(void)
+{
+	return (xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_XI);
+}
+
+static __inline__ int xlr_board_atx_xii(void)
+{
+	return (xlr_board_major_version == RMI_PHOENIX_BOARD_ARIZONA_XII);
+}
+
+static __inline__ int xlr_board_atx_xaui_rework(void)
+{
+	if ((xlr_board_atx_xi() || xlr_board_atx_xii()) &&
+			(xlr_board_minor_version == 4))
+		return 1;
+	else
+		return 0;
+}
+
+
+#define XLR_HYBRID_NONE              0
+#define XLR_HYBRID_USER_MAC          1
+#define XLR_HYBRID_RMIOS_IPSEC       2
+#define XLR_HYBRID_RMIOS_TCPIP_STACK 3
+#define XLR_HYBRID_USER_MAC_GMAC     4
+#define XLR_HYBRID_USER_MAC_XGMAC    5
+#define XLR_HYBRID_USER_MAC_SPI4     6
+#define XLR_HYBRID_USER_MAC_GMAC_XGMAC    7
+#define XLR_HYBRID_USER_MAC_GMAC_SPI4     8
+
+extern int xlr_hybrid;
+
+static __inline__ int xlr_hybrid_user_mac(void)
+{
+	return xlr_hybrid == XLR_HYBRID_USER_MAC;
+}
+
+static __inline__ int xlr_hybrid_user_mac_xgmac(void)
+{
+	return (xlr_hybrid == XLR_HYBRID_USER_MAC_XGMAC || 
+		xlr_hybrid == XLR_HYBRID_USER_MAC_SPI4);
+}
+
+static __inline__ int xlr_hybrid_rmios_tcpip_stack(void)
+{
+        return xlr_hybrid == XLR_HYBRID_RMIOS_TCPIP_STACK;
+}
+
+static __inline__ int xlr_hybrid_rmios_ipsec(void)
+{
+	return xlr_hybrid == XLR_HYBRID_RMIOS_IPSEC;
+}
+
+static __inline__ int xlr_hybrid_none(void)
+{
+	return xlr_hybrid == XLR_HYBRID_NONE;
+}
+
+struct boot_mem_map_entry *psb_get_physaddr_base_address(unsigned long type);
+
+
+#define CHIP_PROCESSOR_ID_XLS_608   0x80
+#define CHIP_PROCESSOR_ID_XLS_408   0x88
+#define CHIP_PROCESSOR_ID_XLS_404   0x8c
+#define CHIP_PROCESSOR_ID_XLS_208   0x8e
+#define CHIP_PROCESSOR_ID_XLS_204   0x8f
+#define CHIP_PROCESSOR_ID_XLS_108   0xce
+#define CHIP_PROCESSOR_ID_XLS_104   0xcf
+
+/* Defines for XLS B0*/
+#define CHIP_PROCESSOR_ID_XLS_616_B0   0x40
+#define CHIP_PROCESSOR_ID_XLS_608_B0   0x4a
+#define CHIP_PROCESSOR_ID_XLS_416_B0   0x44
+#define CHIP_PROCESSOR_ID_XLS_412_B0   0x4c
+#define CHIP_PROCESSOR_ID_XLS_408_B0   0x4e
+#define CHIP_PROCESSOR_ID_XLS_404_B0   0x4f
+
+#define CHIP_PROCESSOR_ID_XLR_B_308   0x06
+#define CHIP_PROCESSOR_ID_XLR_B_508   0x07
+#define CHIP_PROCESSOR_ID_XLR_B_516   0x08
+#define CHIP_PROCESSOR_ID_XLR_B_532   0x09
+#define CHIP_PROCESSOR_ID_XLR_B_716   0x0a
+#define CHIP_PROCESSOR_ID_XLR_B_732   0x0b
+
+#define CHIP_PROCESSOR_ID_XLR_C_308   0x0F
+#define CHIP_PROCESSOR_ID_XLR_C_508   0x0b
+#define CHIP_PROCESSOR_ID_XLR_C_516   0x0a
+#define CHIP_PROCESSOR_ID_XLR_C_532   0x08
+#define CHIP_PROCESSOR_ID_XLR_C_716   0x02
+#define CHIP_PROCESSOR_ID_XLR_C_732   0x00
+
+/*  fill the xls chip family types 
+ */
+extern int chip_is_xls6xx;
+extern int chip_is_xls4xx;
+extern int chip_is_xls2xx;
+extern int chip_is_xls1xx;
+extern int chip_is_xls;
+extern int chip_is_xls_b0;
+extern int chip_is_xls6xx_b0;
+extern int chip_is_xls4xx_b0;
+
+static __inline__ void set_xls_chip_family_types(void)
+{
+	int processor_id = ((read_c0_prid() & 0xff00) >> 8);
+	chip_is_xls = 1;
+	switch (processor_id) {
+        case CHIP_PROCESSOR_ID_XLS_608: 
+		{
+			chip_is_xls6xx = 1;
+			break;
+		}
+        case CHIP_PROCESSOR_ID_XLS_408:
+        case CHIP_PROCESSOR_ID_XLS_404:
+		{
+			chip_is_xls4xx = 1;
+			break;
+		}
+        case CHIP_PROCESSOR_ID_XLS_208:
+        case CHIP_PROCESSOR_ID_XLS_204:
+		{
+			chip_is_xls2xx = 1;
+			break;
+		}
+        case CHIP_PROCESSOR_ID_XLS_108:
+        case CHIP_PROCESSOR_ID_XLS_104:
+		{
+			chip_is_xls1xx = 1;
+			break;
+		}
+        case CHIP_PROCESSOR_ID_XLS_616_B0:
+        case CHIP_PROCESSOR_ID_XLS_608_B0:
+		{
+			chip_is_xls_b0 = 1;
+			chip_is_xls6xx_b0 = 1;
+			break;
+		}
+        case CHIP_PROCESSOR_ID_XLS_416_B0:
+        case CHIP_PROCESSOR_ID_XLS_412_B0:
+        case CHIP_PROCESSOR_ID_XLS_408_B0:
+        case CHIP_PROCESSOR_ID_XLS_404_B0:
+		{
+			chip_is_xls_b0 = 1;
+			chip_is_xls4xx_b0 = 1;
+			break;
+		}
+        default:
+			chip_is_xls = 0;
+	}
+	return;
+}
+
+static __inline__ int is_xls(void)
+{
+	return chip_is_xls;
+}
+
+static __inline__ int is_xls2xx(void)
+{
+	return chip_is_xls2xx;
+}
+
+static __inline__ int is_xls1xx(void)
+{
+	return chip_is_xls1xx;
+}
+
+static __inline__ int is_xls4xx(void)
+{
+	return chip_is_xls4xx;
+}
+
+static __inline__ int is_xls6xx(void)
+{
+	return chip_is_xls6xx;
+}
+
+static __inline__ int is_xls_b0_4xx(void)
+{
+	return chip_is_xls4xx_b0;
+}
+
+static __inline__ int is_xls_b0_6xx(void)
+{
+	return chip_is_xls6xx_b0;
+}
+
+static __inline__ int is_xls_b0(void)
+{
+	return chip_is_xls_b0;
+}
+
+
+
+#define NR_CORES 8
+#define NR_CPUS_PER_CORE 4
+#define RMI_MAX_ARGS 64
+#define RMI_MAX_ENVS 32
+
+#endif /* _ASM_SIM_H */
diff --git a/include/asm-mips/rmi/utils.h b/include/asm-mips/rmi/utils.h
new file mode 100644
index 0000000..82e9639
--- /dev/null
+++ b/include/asm-mips/rmi/utils.h
@@ -0,0 +1,88 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifdef CONFIG_64BIT
+#define LLX_FMT "lx"
+#define LLD_FMT "ld"
+#define LLU_FMT "lu"
+#else
+#define LLX_FMT "llx"
+#define LLD_FMT "lld"
+#define LLU_FMT "llu"
+#endif
+
+#define find_32bit_1st_one_bit(source)    \
+({ unsigned int __res;                    \
+    __asm__ __volatile__(                 \
+	".set\tpush\n\t"                  \
+	".set\tnoreorder\n\t"             \
+        ".set\tmips32\n\t"                \
+	"move\t$8,%1\n\t"                 \
+	"clz\t%0,$8\n\t"                  \
+	".set\tpop"                       \
+	: "=r"(__res): "r"(source): "$8");   \
+    __res;})
+
+#define find_32bit_1st_zero_bit(source)   \
+({ unsigned int __res;                    \
+    __asm__ __volatile__(                 \
+	".set\tpush\n\t"                  \
+	".set\tnoreorder\n\t"             \
+        ".set\tmips32\n\t"                \
+	"move\t$8,%1\n\t"                 \
+	"clo\t%0,$8\n\t"                  \
+	".set\tpop"                       \
+	: "=r"(__res): "r"(source): "$8" );      \
+    __res;})
+
+#define find_64bit_1st_one_bit(source)    \
+({ unsigned int __res;                    \
+    __asm__ __volatile__(                 \
+	".set\tpush\n\t"                  \
+	".set\tnoreorder\n\t"             \
+        ".set\tmips32\n\t"                \
+	"move\t$8,%1\n\t"                 \
+	"dclz\t%0,$8\n\t"                 \
+	".set\tpop"                       \
+	: "=r"(__res): "r"(source): "$8" );      \
+    __res;})
+
+#define find_64bit_1st_zero_bit(source)    \
+({ unsigned int __res;                    \
+    __asm__ __volatile__(                 \
+	".set\tpush\n\t"                  \
+	".set\tnoreorder\n\t"             \
+        ".set\tmips32\n\t"                \
+	"move\t$8,%1\n\t"                 \
+	"dclo\t%0,$8\n\t"                 \
+	".set\tpop"                       \
+	: "=r"(__res): "r"(source): "$8" );      \
+    __res;})
+
diff --git a/include/asm-mips/rmi/xlr_pcix_boot.h b/include/asm-mips/rmi/xlr_pcix_boot.h
new file mode 100644
index 0000000..6c74826
--- /dev/null
+++ b/include/asm-mips/rmi/xlr_pcix_boot.h
@@ -0,0 +1,42 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef __PCIX_BOOT_H__
+#define __PCIX_BOOT_H__
+
+#define PCIX_BOOT_FILE_START    (2<<20)
+#define PCIX_BOOT_ARG_CNT_OFF   0x100 /* Number of args */
+#define PCIX_BOOT_ARGS_LEN_OFF  0x104 /* Total length of the args */
+#define PCIX_BOOT_ARGS_OFF      0x108 /*  args string */
+#define PCIX_BOOT_MAGIC         0xa5a5a5a5
+
+
+#endif
+
diff --git a/include/asm-mips/serial.h b/include/asm-mips/serial.h
index c07ebd8..e59b627 100644
--- a/include/asm-mips/serial.h
+++ b/include/asm-mips/serial.h
@@ -19,4 +19,25 @@
  */
 #define BASE_BAUD (1843200 / 16)
 
+#ifdef CONFIG_RMI_PHOENIX
+#define STD_COM_FLAGS (ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST)
+#include <asm/rmi/pic.h>
+#define RMI_PHOENIX_BASE_BAUD (66000000 / 16)
+#define RMI_PHOENIX_SERIAL_PORT_DEFNS                                       \
+        { .baud_base = RMI_PHOENIX_BASE_BAUD, .irq = PIC_UART_0_IRQ, 	    \
+	  .flags = STD_COM_FLAGS,\
+      .iomem_base = (u8*)(DEFAULT_PHOENIX_IO_BASE+PHOENIX_IO_UART_0_OFFSET), \
+	  .iomem_reg_shift = 2, .io_type = SERIAL_IO_MEM},	\
+        { .baud_base = RMI_PHOENIX_BASE_BAUD, .irq = PIC_UART_1_IRQ, 	     \
+	  .flags = STD_COM_FLAGS, \
+      .iomem_base = (u8*)(DEFAULT_PHOENIX_IO_BASE+PHOENIX_IO_UART_1_OFFSET), \
+	  .iomem_reg_shift = 2, .io_type = SERIAL_IO_MEM},
+#else
+#define RMI_PHOENIX_SERIAL_PORT_DEFNS
+#endif /* CONFIG_RMI_PHOENIX */
+        
+
+#define SERIAL_PORT_DFNS				\
+	RMI_PHOENIX_SERIAL_PORT_DEFNS
+
 #endif /* _ASM_SERIAL_H */
diff --git a/include/linux/libata.h b/include/linux/libata.h
index 25062ac..48f846c 100644
--- a/include/linux/libata.h
+++ b/include/linux/libata.h
@@ -54,7 +54,7 @@
  */
 #undef ATA_DEBUG		/* debugging output */
 #undef ATA_VERBOSE_DEBUG	/* yet more debugging output */
-#undef ATA_IRQ_TRAP		/* define to ack screaming irqs */
+#define ATA_IRQ_TRAP		/* define to ack screaming irqs */
 #undef ATA_NDEBUG		/* define to disable quick runtime checks */
 
 
diff --git a/include/linux/mm.h b/include/linux/mm.h
index faa899e..3d38069 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -1157,8 +1157,13 @@ extern int filemap_fault(struct vm_area_struct *, struct vm_fault *);
 int write_one_page(struct page *page, int wait);
 
 /* readahead.c */
+#ifndef CONFIG_RMI_NAS
 #define VM_MAX_READAHEAD	128	/* kbytes */
 #define VM_MIN_READAHEAD	16	/* kbytes (includes current page) */
+#else
+#define VM_MAX_READAHEAD	1024	/* kbytes */
+#define VM_MIN_READAHEAD	32	/* kbytes (includes current page) */
+#endif
 
 int do_page_cache_readahead(struct address_space *mapping, struct file *filp,
 			pgoff_t offset, unsigned long nr_to_read);
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index 2dc6958..8755064 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -360,13 +360,21 @@ extern struct sk_buff *__alloc_skb(unsigned int size,
 static inline struct sk_buff *alloc_skb(unsigned int size,
 					gfp_t priority)
 {
+#if defined(CONFIG_RMI_PHOENIX) && defined(CONFIG_64BIT)
+	return __alloc_skb(size, priority | GFP_DMA, 0, -1);
+#else
 	return __alloc_skb(size, priority, 0, -1);
+#endif
 }
 
 static inline struct sk_buff *alloc_skb_fclone(unsigned int size,
 					       gfp_t priority)
 {
+#if defined(CONFIG_RMI_PHOENIX) && defined(CONFIG_64BIT)
+	return __alloc_skb(size, priority | GFP_DMA, 1, -1);
+#else
 	return __alloc_skb(size, priority, 1, -1);
+#endif
 }
 
 extern struct sk_buff *skb_morph(struct sk_buff *dst, struct sk_buff *src);
@@ -1204,7 +1212,11 @@ static inline void __skb_queue_purge(struct sk_buff_head *list)
 static inline struct sk_buff *__dev_alloc_skb(unsigned int length,
 					      gfp_t gfp_mask)
 {
+#if defined(CONFIG_RMI_PHOENIX) && defined(CONFIG_64BIT)
+	struct sk_buff *skb = alloc_skb(length + NET_SKB_PAD, gfp_mask|GFP_DMA);
+#else
 	struct sk_buff *skb = alloc_skb(length + NET_SKB_PAD, gfp_mask);
+#endif
 	if (likely(skb))
 		skb_reserve(skb, NET_SKB_PAD);
 	return skb;
@@ -1231,7 +1243,11 @@ extern struct sk_buff *__netdev_alloc_skb(struct net_device *dev,
 static inline struct sk_buff *netdev_alloc_skb(struct net_device *dev,
 		unsigned int length)
 {
+#if defined(CONFIG_RMI_PHOENIX) && defined(CONFIG_64BIT)
+	return __netdev_alloc_skb(dev, length, GFP_ATOMIC | GFP_DMA);
+#else
 	return __netdev_alloc_skb(dev, length, GFP_ATOMIC);
+#endif
 }
 
 /**
diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h
index 8ab38e2..b2b2641 100644
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@ -461,7 +461,18 @@ asmlinkage long sys_mkdir(const char __user *pathname, int mode);
 asmlinkage long sys_chdir(const char __user *filename);
 asmlinkage long sys_fchdir(unsigned int fd);
 asmlinkage long sys_rmdir(const char __user *pathname);
+#if defined (CONFIG_64BIT) && defined (CONFIG_RMI_PHOENIX)
+#if defined (CONFIG_MIPS32_O32) || defined (CONFIG_MIPS32_N32)
+long sys_lookup_dcookie(u64 cookie64, char __user *buf, size_t len);
+#include <asm/compat.h>
+asmlinkage long compat_sys_lookup_dcookie(u32 cookie_msb, u32 cookie_lsb,
+                                      compat_uptr_t buf, compat_size_t len);
+#else
 asmlinkage long sys_lookup_dcookie(u64 cookie64, char __user *buf, size_t len);
+#endif
+#else
+asmlinkage long sys_lookup_dcookie(u64 cookie64, char __user *buf, size_t len);
+#endif
 asmlinkage long sys_quotactl(unsigned int cmd, const char __user *special,
 				qid_t id, void __user *addr);
 asmlinkage long sys_getdents(unsigned int fd,
diff --git a/include/user/rmi/phnx_loader.h b/include/user/rmi/phnx_loader.h
new file mode 100644
index 0000000..b72c590
--- /dev/null
+++ b/include/user/rmi/phnx_loader.h
@@ -0,0 +1,153 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef __USER_RMI_PHNX_LOADER_H
+#define __USER_RMI_PHNX_LOADER_H
+
+#include <asm/ioctl.h>
+#include <asm/types.h>
+
+#define XLR_MAP_SLAVE_DEVICE 0x1
+
+#define XLR_MAP_UNCACHED 0x1
+#define XLR_MAP_CACHED 0x2
+
+#define PHNX_APP_LOADER_CHRDEV_NAME "xlr_app_loader"
+
+#define PHNX_LOADER_IOC_MAGIC 'X'
+
+#define PHNX_LOADER_IOC_SHMEM_SIZE _IOR(PHNX_LOADER_IOC_MAGIC, 0, unsigned int)
+
+#define PHNX_LOADER_IOC_MMAP_SHMEM _IOR(PHNX_LOADER_IOC_MAGIC, 1, unsigned int)
+
+#define PHNX_LOADER_IOC_LIB_BKP _IOR(PHNX_LOADER_IOC_MAGIC, 2, unsigned int)
+
+#define PHNX_LOADER_IOC_MMAP_LOAD_ADDR  _IOR(PHNX_LOADER_IOC_MAGIC, 3, unsigned int)
+
+#define PHNX_LOADER_IOC_START_IPI _IOR(PHNX_LOADER_IOC_MAGIC, 4, unsigned int)
+
+#define PHNX_LOADER_IOC_STOP_IPI  _IOR(PHNX_LOADER_IOC_MAGIC, 5, unsigned int)
+
+#define PHNX_LOADER_IOC_ALLOC_PERSISTENT_MEM  _IOR(PHNX_LOADER_IOC_MAGIC, 6, unsigned int)
+
+#define PHNX_LOADER_IOC_MMAP_PERSISTENT_MEM  _IOR(PHNX_LOADER_IOC_MAGIC, 7, unsigned int)
+
+#define PHNX_LOADER_IOC_FREE_PERSISTENT_MEM  _IOR(PHNX_LOADER_IOC_MAGIC, 8, unsigned int)
+
+#define PHNX_LOADER_IOC_SHMEM_KSEG_ADDR _IOR(PHNX_LOADER_IOC_MAGIC, 10, unsigned int)
+
+#define PHNX_LOADER_IOC_LAUNCH_KSEG _IOR(PHNX_LOADER_IOC_MAGIC, 15, unsigned int)
+
+#define PHNX_LOADER_IOC_APP_SHMEM_SIZE _IOR(PHNX_LOADER_IOC_MAGIC, 25, unsigned int)
+
+#define PHNX_LOADER_IOC_APP_SHMEM_RESERVE _IOR(PHNX_LOADER_IOC_MAGIC, 35, unsigned int)
+
+#define PHNX_LOADER_IOC_MMAP_APP_SHMEM _IOR(PHNX_LOADER_IOC_MAGIC, 45, unsigned int)
+
+#define PHNX_LOADER_IOC_APP_SHMEM_PHYS _IOR(PHNX_LOADER_IOC_MAGIC, 55, unsigned int)
+
+#define PHNX_LOADER_STORE_ENV _IOR(PHNX_LOADER_IOC_MAGIC, 65, unsigned int)
+
+#define PHNX_LOADER_SEND_IPI _IOR(PHNX_LOADER_IOC_MAGIC, 75, unsigned int)
+
+#define PHNX_LOADER_IOC_STORE_APP_SHMEM_INFO _IOR(PHNX_LOADER_IOC_MAGIC, 85, unsigned int)
+
+#define PHNX_LOADER_IOC_GET_APP_SHMEM_INFO _IOR(PHNX_LOADER_IOC_MAGIC, 95, unsigned int)
+
+
+#define PHNX_MAX_VCPUS 32
+
+enum { KUSEG_MODE, KSEG0_MODE };
+typedef enum {
+	STOP_THREAD=0xbeef,
+	START_THREAD,
+	RUN_FUNCTION, /* Used by wakeup and wakeup_os call */
+
+}loader_cmd;
+typedef enum {
+	THREAD_STOPPED=0x600d,
+	THREAD_RUNNING,
+	THREAD_SCHEDULED,
+}thread_status;
+
+struct cpu_tlb_mapping {
+	int page_size;
+	int asid;
+	int coherency;
+	int attr;
+	unsigned long virt;
+	uint64_t phys;
+};
+
+#define MAX_TLB_MAPPINGS 16
+#define MAX_ARGS 16
+#define MAX_ARGV_LEN 16
+struct cpu_wakeup_info {
+	int            master_cpu;
+	int            map_count;
+	int            valid;
+	unsigned long  func;
+	unsigned long  args;
+	int            argc;
+	uint32_t       buddy_mask;
+	uint32_t       cpu_mask;
+	char          *argv[32]; /* RMIOS LIB NEEDS this to be 32 */
+	char           buf[256];/* must be > MAX_ARGS * MAX_ARGV_LEN + some buffer */
+	struct cpu_tlb_mapping map[MAX_TLB_MAPPINGS];
+};
+
+/* SHARED memory structure b/w loader app, linux and RMIOS apps */
+typedef struct phnx_loader_shared_struct {
+	unsigned long park_entry;
+	loader_cmd    cmd;
+	thread_status thr_status;
+	unsigned long entry; /* Entry point address */
+	int 	      run_mode;
+	struct cpu_wakeup_info run_info;
+	uint32_t 	app_sh_mem_sz; /* Size of the shared memory */
+	unsigned long	sp;/* Used for reentry */
+	unsigned long	gp;
+}phnx_loader_shared_struct_t;
+
+
+/* This structure is passed to all applications launched from the linux
+   loader through OS 7 scratch register
+   */
+#define PHNX_LOADER_INFO_MAGIC 0x600ddeed
+typedef struct phnx_loader_info {
+	uint32_t magic;
+	/* phnx_loader_shared_struct_t for CPU 0 will start here */
+	unsigned long sh_mem_start;
+	/* Size of the shared memory b/w linux apps and rmios apps  */
+	uint32_t app_sh_mem_size;
+	uint8_t printk_lock[16]; /* used for printk */
+}phnx_loader_info_t;
+
+#endif
-- 
1.6.0.4

