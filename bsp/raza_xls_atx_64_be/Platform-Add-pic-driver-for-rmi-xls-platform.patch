From d6d9f649bf94b13c372c769f6fb2d1043fd580d2 Mon Sep 17 00:00:00 2001
From: Liu Changhui <changhui.liu@windriver.com>
Date: Fri, 29 Jan 2010 13:27:39 +0800
Subject: [PATCH] Platform: Add pic driver for rmi xls platform

Add driver for pic of rmi xls platform. Also add all thefunctions and struct
 that needed by IRQ dispatch, including RMI irq_chip structure, interrupt
mask and ack etc.

source: from RMI SDK1.7

Signed-off-by: shuo.kang <shuo.kang@windriver.com>
---
 arch/mips/rmi/phoenix/Makefile |    4 +
 arch/mips/rmi/phoenix/irq.c    |  632 ++++++++++++++++++++++++++++++++++++++++
 include/asm-mips/rmi/pic.h     |  274 +++++++++++++++++
 3 files changed, 910 insertions(+), 0 deletions(-)
 create mode 100644 arch/mips/rmi/phoenix/Makefile
 create mode 100644 arch/mips/rmi/phoenix/irq.c
 create mode 100644 include/asm-mips/rmi/pic.h

diff --git a/arch/mips/rmi/phoenix/Makefile b/arch/mips/rmi/phoenix/Makefile
new file mode 100644
index 0000000..6556922
--- /dev/null
+++ b/arch/mips/rmi/phoenix/Makefile
@@ -0,0 +1,4 @@
+EXTRA_CFLAGS := -Werror
+obj-y := irq.o
+
+EXTRA_AFLAGS := $(CFLAGS)
diff --git a/arch/mips/rmi/phoenix/irq.c b/arch/mips/rmi/phoenix/irq.c
new file mode 100644
index 0000000..0fa03a0
--- /dev/null
+++ b/arch/mips/rmi/phoenix/irq.c
@@ -0,0 +1,632 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/linkage.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/pci.h>
+#include <linux/msi.h>
+#include <asm/errno.h>
+#include <asm/signal.h>
+#include <asm/system.h>
+#include <asm/ptrace.h>
+#include <asm/kgdb.h>
+#include <asm/mipsregs.h>
+
+#include <asm/rmi/sim.h>
+#include <asm/rmi/rmi_srio.h>
+#include <asm/rmi/msidef.h>
+#include <asm/rmi/mips-exts.h>
+#include <asm/rmi/pic.h>
+#include <asm/rmi/debug.h>
+#include <asm/thread_info.h>
+/*
+ * These are the routines that handle all the low level interrupt stuff.
+ * Actions handled here are: initialization of the interrupt map, requesting of
+ * interrupt lines by handlers, dispatching if interrupts to handlers, probing
+ * for interrupt lines.
+ */
+
+/* Externs */
+extern void phoenix_timer_interrupt(struct pt_regs *regs, int irq);
+extern void phoenix_smp_time_init(void);
+#ifdef CONFIG_PCI
+extern void *ht_config_base;
+#endif
+extern int  link0, link1;
+struct pic_tmask pic_tmask[PIC_NUM_IRTS];
+
+__u64 phnx_irq_mask;
+spinlock_t phnx_pic_lock = SPIN_LOCK_UNLOCKED;
+
+static unsigned int pic_startup(unsigned int irq)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	unsigned long flags;
+	phoenix_reg_t reg;
+	uint32_t thread_mask = (1 << cpu_logical_map(0));
+
+  /* dbg_msg("IN irq=%d\n", irq); */
+
+	if (!PIC_IRQ_IS_IRT(irq)) return EINVAL;
+
+	spin_lock_irqsave(&phnx_pic_lock, flags);
+
+	if(pic_tmask[irq - PIC_IRQ_BASE].set == 0)
+		phoenix_write_reg(mmio, PIC_IRT_0_BASE + irq - PIC_IRQ_BASE, thread_mask);
+
+	pic_tmask[irq - PIC_IRQ_BASE].valid = 1;
+	/* What happens if this irq was previously not ack'ed?
+	 * Assume, that doesn't happen?
+	 */
+	reg = phoenix_read_reg(mmio, PIC_IRT_1_BASE + irq - PIC_IRQ_BASE);
+	/* phoenix_write_reg(mmio, PIC_IRT_1_BASE + irq - PIC_IRQ_BASE, reg | (1<<31)); */
+	/* By default all the interrupts are initialized as level senstive - fix for the PCMCIA flash */
+	phoenix_write_reg(mmio, PIC_IRT_1_BASE + irq - PIC_IRQ_BASE, reg | (1<<6)|(1<<30)|(1<<31)|(irq));
+
+	spin_unlock_irqrestore(&phnx_pic_lock, flags);
+
+	return 0;
+}
+
+static void pic_unmask(unsigned int irq)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	unsigned long flags;
+	phoenix_reg_t reg;
+	uint32_t thread_mask = (1 << cpu_logical_map(0));
+
+  /* dbg_msg("IN irq=%d\n", irq); */
+
+	if (!PIC_IRQ_IS_IRT(irq)) return;
+
+	spin_lock_irqsave(&phnx_pic_lock, flags);
+
+	if(pic_tmask[irq - PIC_IRQ_BASE].set == 0)
+ 		phoenix_write_reg(mmio, PIC_IRT_0_BASE + irq - PIC_IRQ_BASE, thread_mask);
+
+	pic_tmask[irq - PIC_IRQ_BASE].valid = 1;
+	/* What happens if this irq was previously not ack'ed?
+	 * Assume, that doesn't happen?
+	 */
+	reg = phoenix_read_reg(mmio, PIC_IRT_1_BASE + irq - PIC_IRQ_BASE);
+	/* phoenix_write_reg(mmio, PIC_IRT_1_BASE + irq - PIC_IRQ_BASE, reg | (1<<31)); */
+	/* By default all the interrupts are initialized as level senstive - fix for the PCMCIA flash */
+	phoenix_write_reg(mmio, PIC_IRT_1_BASE + irq - PIC_IRQ_BASE, reg | (1<<6)|(1<<30)| (1<<31) | irq);
+
+	spin_unlock_irqrestore(&phnx_pic_lock, flags);
+
+	return;
+}
+
+static void pic_ack(unsigned int irq)
+{
+	phoenix_reg_t *mmio     = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	phoenix_reg_t *pci_mmio = phoenix_io_mmio(PHOENIX_IO_PCIX_OFFSET);
+#ifdef CONFIG_PCI
+	phoenix_reg_t *ht_mmio  = phoenix_io_mmio(PHOENIX_IO_HT_OFFSET);
+#endif
+   
+	/* XLS PCIE : the Little Endian region */
+	phoenix_reg_t *pcie_mmio_le = NULL;
+
+	unsigned long i, flags;
+	phoenix_reg_t reg;
+
+	if (is_xls()) {
+		pcie_mmio_le = phoenix_io_mmio(PHOENIX_IO_PCIE_1_OFFSET);
+	}
+
+	if (!PIC_IRQ_IS_IRT(irq)) return;
+	
+	/* Interrupt (level sensitive ) acknowledge method for the PCMCIA flash */
+
+	if (irq == PIC_PCMCIA_IRQ ){
+	
+		reg = *(unsigned char *)(unsigned long)(0xffffffffBD0001f7ULL);
+		reg = *(unsigned int *)(unsigned long)(0xffffffffBEF19180ULL);
+		for (i = 0; i < 0x100; i++);
+			*(unsigned int *)(unsigned long)(0xffffffffBEF19180ULL) = reg;
+		for (i = 0; i < 0x1000; i++);
+			reg = *(unsigned int *)(unsigned long)(0xffffffffBEF19180ULL);
+	}
+
+	/* Deal with All PCI-Interrupts.. Brigde ACK */
+	if ((irq == PIC_PCIX_IRQ) && (!is_xls()))
+		phoenix_read_reg(pci_mmio, (0x140 >> 2));
+
+#ifdef CONFIG_PCI
+	if (irq == PIC_HYPER_IRQ) {
+
+		/* HyperTransport: Clear INT Status */
+		phoenix_read_reg (ht_mmio, (0x700 >> 2));
+
+        /*
+         *  ---------------------------------------------------------
+         *  Generating EOI.
+         *  Clear Interrupts by directly writing to PLX's CFG Space.
+         *  1. setup the off value in register 0xB8
+         *     (Interrupt Discovery Configuration, bits 23-16).
+         *  2. clear the interrupt by setting the IRR bit
+         *     (bit 63) in reg 0xBC (IRDR).
+         *  ---------------------------------------------------------
+         *  If more devices are added to HT, we have to use the EOI 
+         *  broadcast.
+         *  ---------------------------------------------------------
+         *  NOTE: Send EOI for all interrupts (INT A, B, C and D).
+         *  Bridge Cards, if plugged into the slot, may re-route
+         *  interrupts. E.g: Intel Bridge 31154 eval board re-routes 
+         *  INTA of the endpoint to INTC of PLX.
+         *  ---------------------------------------------------------
+         */
+
+        /* Generate EOI for INTA */
+        *(volatile uint32_t *)(ht_config_base + 0x008b8) = 0x08c01180; 
+        *(volatile uint32_t *)(ht_config_base + 0x008bc) = 0x00000080;
+
+        /* Generate EOI for INTB */
+        *(volatile uint32_t *)(ht_config_base + 0x008b8) = 0x08c01380; 
+        *(volatile uint32_t *)(ht_config_base + 0x008bc) = 0x00000080;
+
+        /* Generate EOI for INTC */
+        *(volatile uint32_t *)(ht_config_base + 0x008b8) = 0x08c01580; 
+        *(volatile uint32_t *)(ht_config_base + 0x008bc) = 0x00000080;
+
+        /* Generate EOI for INTD */
+        *(volatile uint32_t *)(ht_config_base + 0x008b8) = 0x08c01780; 
+        *(volatile uint32_t *)(ht_config_base + 0x008bc) = 0x00000080;
+    }
+#endif
+
+    /* Ack the PCIE Block MSI Status Register(s) */
+	if(is_xls() && !is_xlsb0_srio()){
+		if (irq == PIC_PCIE_LINK0_IRQ) {
+	            /*Link0*/
+			phoenix_write_reg(pcie_mmio_le, (0x90 >> 2), 0xffffffff);
+	        }
+	        if (irq == PIC_PCIE_LINK1_IRQ ) {
+			/* Link1 */
+			phoenix_write_reg(pcie_mmio_le, (0x94 >> 2), 0xffffffff);
+	        }
+        	if ((is_xls2xx() && irq == PIC_GMAC_6_IRQ) || (is_xls_b0() && irq == PIC_PCIE_LINK2_IRQ)){
+			/* Link2 */
+			phoenix_write_reg(pcie_mmio_le, (0x190 >> 2), 0xffffffff);
+	        }
+		if ((is_xls2xx() && irq == PIC_GMAC_7_IRQ) || (is_xls_b0() && irq == PIC_PCIE_LINK3_IRQ)){
+			/* Link3 */
+			phoenix_write_reg(pcie_mmio_le, (0x194 >> 2), 0xffffffff);
+		}
+  	}
+
+	/* If edge triggered IRQ, ack it immediately, else when the device
+	 * interrupt condition is cleared, we may lose interrupts 
+	 */
+	if (PIC_IRQ_IS_EDGE_TRIGGERED(irq)) {
+		spin_lock_irqsave(&phnx_pic_lock, flags);
+		phoenix_write_reg(mmio, PIC_INT_ACK, (1 << (irq - PIC_IRQ_BASE)));
+		spin_unlock_irqrestore(&phnx_pic_lock, flags);
+	}
+}
+
+static void pic_end(unsigned int irq)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	unsigned long flags;
+
+	if (!PIC_IRQ_IS_IRT(irq)) return;
+
+	/* If level triggered, ack it after the device condition is cleared */
+	if (! PIC_IRQ_IS_EDGE_TRIGGERED(irq)) {
+
+		spin_lock_irqsave(&phnx_pic_lock, flags);    
+		phoenix_write_reg(mmio, PIC_INT_ACK, (1 << (irq - PIC_IRQ_BASE)));
+		spin_unlock_irqrestore(&phnx_pic_lock, flags);
+	}
+}
+
+static void pic_shutdown(unsigned int irq)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	unsigned long flags;
+	phoenix_reg_t reg;
+
+	if (!PIC_IRQ_IS_IRT(irq)) return;
+
+	spin_lock_irqsave(&phnx_pic_lock, flags);
+    
+  /* What happens if this irq is currently pending an ack? 
+   * Assume, that doesn't happen?
+   */
+	reg = phoenix_read_reg(mmio, PIC_IRT_1_BASE + irq - PIC_IRQ_BASE);
+	phoenix_write_reg(mmio, PIC_IRT_1_BASE + irq - PIC_IRQ_BASE, (reg & ~(1<<31)));
+    
+	spin_unlock_irqrestore(&phnx_pic_lock, flags);
+}
+
+static void pic_set_affinity(unsigned int irq, cpumask_t mask)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	unsigned long flags;
+	uint32_t physmap = 0, logmap = 0, i;
+
+	if (!PIC_IRQ_IS_IRT(irq)) return;
+
+	/* Set affinity comes with logical cpu ids, move this to physical cpu ids */
+	for(i = 0; i < NR_CPUS; i++) {
+		if((1 << i) & (uint32_t)mask.bits[0]) {
+			logmap |= (1 << i);
+			physmap |= (1 << cpu_logical_map(i));
+		}
+	}
+
+	spin_lock_irqsave(&phnx_pic_lock, flags);
+
+	phoenix_write_reg(mmio, PIC_IRT_0_BASE + irq - PIC_IRQ_BASE, physmap);
+
+	spin_unlock_irqrestore(&phnx_pic_lock, flags);
+}
+
+static struct irq_chip phnx_pic = {
+	.name         = "Phoenix-PIC",
+	.unmask	    = pic_unmask,
+	.mask		    = pic_shutdown,
+	.ack          = pic_ack,
+	.end          = pic_end,
+	.set_affinity = pic_set_affinity
+};
+
+static void rsvd_pic_handler_1_1(unsigned int irq)
+{
+	if(irq < PIC_IRQ_BASE)
+		return;
+	dbg_msg("Requesting a reserved irq (%d)??", irq);
+	return;
+}
+
+static void rsvd_pic_handler_1(unsigned int irq)
+{
+	if(irq < PIC_IRQ_BASE)
+		return;
+	dbg_msg("handler called for a reserved irq (%d)\n", irq);
+}
+
+static void rsvd_pic_handler_2(unsigned int irq, cpumask_t mask)
+{
+	if(irq < PIC_IRQ_BASE)
+		return;
+  dbg_msg("handler called for a reserved irq (%d)\n", irq);
+}
+
+struct irq_chip phnx_rsvd_pic_irq_timer = {
+	.name		=          "Count-Compare",
+	.unmask		=          rsvd_pic_handler_1_1,
+	.mask		=          rsvd_pic_handler_1,
+	.ack		=          rsvd_pic_handler_1,
+	.end		=          rsvd_pic_handler_1,
+	.set_affinity	=          rsvd_pic_handler_2
+};
+
+struct irq_chip phnx_rsvd_pic = {
+	.name		=          "Phoenix-RSVD-PIC",
+	.unmask		=          rsvd_pic_handler_1_1,
+	.mask		=          rsvd_pic_handler_1,
+	.ack		=          rsvd_pic_handler_1,
+	.end		=          rsvd_pic_handler_1,
+	.set_affinity	=          rsvd_pic_handler_2
+};
+
+static irqreturn_t phnx_rsvd_irq_handler(int irq, void *dev_id)
+{
+	if(irq == IRQ_TIMER) 
+		return IRQ_HANDLED;
+	dbg_msg("handler for reserved irq %d\n", irq);
+	return IRQ_NONE;
+}
+
+struct irqaction phnx_rsvd_action = {
+	.handler = phnx_rsvd_irq_handler,
+	.flags = 0,
+	.name = "phnx_rsvd_action", 
+	.dev_id = 0,
+	.next = 0
+};
+
+void __init init_phoenix_irqs(void)
+{
+	int i;
+
+	for (i = 0; i < NR_IRQS; i++) {
+		set_irq_chip(i, &phnx_pic);
+	}
+
+#ifdef CONFIG_REMOTE_DEBUG
+	irq_desc[IRQ_REMOTE_DEBUG].chip = &phnx_rsvd_pic;
+	irq_desc[IRQ_REMOTE_DEBUG].action = phnx_rsvd_action;
+	phnx_irq_mask |= (1ULL << IRQ_REMOTE_DEBUG);
+#endif
+
+#ifdef CONFIG_SMP
+	irq_desc[IRQ_IPI_SMP_FUNCTION].chip = &phnx_rsvd_pic;
+	irq_desc[IRQ_IPI_SMP_FUNCTION].action = &phnx_rsvd_action;
+
+	irq_desc[IRQ_IPI_SMP_RESCHEDULE].chip = &phnx_rsvd_pic;
+	irq_desc[IRQ_IPI_SMP_RESCHEDULE].action = &phnx_rsvd_action;
+
+
+
+	phnx_irq_mask |= ((1ULL<<IRQ_IPI_SMP_FUNCTION)|(1ULL<<IRQ_IPI_SMP_RESCHEDULE));
+#endif
+
+	/* msgring interrupt */
+	irq_desc[IRQ_MSGRING].chip = &phnx_rsvd_pic;
+	irq_desc[IRQ_MSGRING].action = &phnx_rsvd_action;
+	phnx_irq_mask |= (1ULL<<IRQ_MSGRING);
+
+	irq_desc[IRQ_TIMER].chip = &phnx_rsvd_pic_irq_timer;
+	irq_desc[IRQ_TIMER].action = NULL;
+	phnx_irq_mask |= (1ULL<<IRQ_TIMER);
+
+	/* The driver installs a handler so, don't reserve it */
+	phnx_irq_mask |= (1ULL<<IRQ_DUMMY_UART);
+
+	/* unmask all PIC related interrupts. If no handler is installed by the 
+	 * drivers, it'll just ack the interrupt and return 
+	 */
+	for(i=PIC_IRT_FIRST_IRQ;i<=PIC_IRT_LAST_IRQ();i++) 
+		phnx_irq_mask |= (1ULL << i);
+
+	#ifdef CONFIG_OPROFILE
+	phnx_irq_mask |= (1ULL<<IRQ_IPI_OPROFILE);
+	#endif
+  
+#ifdef CONFIG_KGDB
+	phnx_irq_mask |= (1ULL << IRQ_IPI_SMP_KGDB);
+#endif
+  
+}
+ 
+#ifdef CONFIG_KGDB
+extern irqreturn_t xlr_kgdb_ipi_handler(int irq, struct pt_regs *regs);
+#endif
+#ifdef CONFIG_OPROFILE
+extern void phoenix_oprofile_int_handler(int irq, void * dev_id,
+		        struct pt_regs *regs);
+#endif
+void do_phnx_IRQ(unsigned int irq, struct pt_regs *regs)
+{
+
+
+#ifdef CONFIG_SMP
+
+	if  (irq == IRQ_IPI_SMP_FUNCTION || irq == IRQ_IPI_SMP_RESCHEDULE) {
+		phoenix_ipi_handler(irq, regs);
+		return;
+	}
+#endif
+	if (irq == IRQ_MSGRING)
+		 phnx_msgring_int_handler(irq, regs);
+#ifdef CONFIG_KGDB
+	else if (irq == IRQ_IPI_SMP_KGDB) {
+	}
+#endif
+#ifdef CONFIG_OPROFILE
+	else if (irq == IRQ_IPI_OPROFILE) {
+		if(phoenix_thr_id() != 0)
+			phoenix_oprofile_int_handler (irq, NULL, regs);
+	}
+#endif
+	else
+		do_IRQ(irq);
+}
+
+void __cpuinit rmi_smp_irq_init(void)
+{
+	/* set interrupt mask for non-zero cpus */
+	write_64bit_cp0_eimr(phnx_irq_mask | (1<<IRQ_TIMER));
+
+}
+
+/* 
+ * MSI hook-up routines for RMI Boards;
+ * Arch-dependent implementation called
+ * from generic msi.c routines.
+ */  
+
+struct irq_chip phnx_pic_msi = {
+	.name		= "Phoenix-PIC-MSI",
+	.startup	= pic_startup,
+	.shutdown	= pic_shutdown,
+	.ack		= pic_ack,
+	.end		= pic_end,
+	.set_affinity	= pic_set_affinity
+};
+
+void destroy_irq(unsigned int irq)
+{
+    /* no-op */
+}
+
+#ifdef CONFIG_PCI_MSI_XLR
+static int get_irq_vector(struct pci_dev *dev) 
+{
+
+	int irq = 0;
+	if (is_xls() && !is_xls2xx() && !is_xls_b0()) {
+        /* Currently, PCIE bridges not supported */        
+		if (link0) {
+			if (dev->bus->number == 1)
+				irq = PIC_PCIE_LINK0_IRQ;
+			else
+				irq = PIC_PCIE_LINK1_IRQ;
+		}
+		else if (link1) {
+			if (dev->bus->number == 1)
+				irq = PIC_PCIE_LINK1_IRQ;
+		}
+	}else if(is_xls2xx() || is_xls_b0()){
+        switch(dev->bus->self->devfn){
+            case 0x0:
+                irq = PIC_PCIE_LINK0_IRQ;
+                break;
+            case 0x8:
+                irq = PIC_PCIE_LINK1_IRQ;
+                break;
+            case 0x10:
+                if(is_xls_b0())
+                    irq = PIC_PCIE_XLSB0_LINK2_IRQ;
+                else
+                    irq = PIC_PCIE_LINK2_IRQ;
+                break;
+            case 0x18:
+                if(is_xls_b0())
+                    irq = PIC_PCIE_XLSB0_LINK3_IRQ;
+                else
+                    irq = PIC_PCIE_LINK3_IRQ;
+                break;
+            default:
+                break;
+        }
+	}
+	else {
+        	irq = PIC_HYPER_IRQ;
+	}
+	return irq;
+}
+
+
+static int msi_compose_msg(struct pci_dev *pdev, unsigned int irq, 
+        struct msi_msg *msg) {
+	
+	unsigned dest;
+
+	if (irq >= 0) {
+		dest = 0x00;
+		msg->address_hi = MSI_ADDR_BASE_HI;
+		msg->address_lo = MSI_ADDR_BASE_LO  | 
+			MSI_ADDR_DEST_MODE_PHYSICAL  |
+		      MSI_ADDR_REDIRECTION_CPU  | 
+                     MSI_ADDR_DEST_ID(dest) ;
+		msg->data = MSI_DATA_TRIGGER_EDGE   |
+			        MSI_DATA_LEVEL_ASSERT   |
+			        MSI_DATA_DELIVERY_FIXED |
+			            MSI_DATA_VECTOR(irq);
+	}
+	return irq;
+}
+
+void arch_teardown_msi_irq(unsigned int irq)
+{
+	destroy_irq(irq);
+}
+
+int arch_setup_msi_irq(struct pci_dev *dev, struct msi_desc *desc)
+{
+	struct msi_msg msg;
+	int irq, ret;
+
+	irq = get_irq_vector(dev);
+	if (irq < 0)
+		return irq;
+	set_irq_msi(irq, desc);
+	ret = msi_compose_msg(dev, irq, &msg);
+	if (ret < 0) {
+		destroy_irq(irq);
+		return ret;
+	}
+	write_msi_msg(irq, &msg);
+	irq_desc[irq].chip = &phnx_pic_msi;
+	phnx_irq_mask |= (1ULL<<irq);
+	return irq;
+}
+#endif
+
+
+void __init arch_init_irq(void)
+{
+#ifdef CONFIG_KGDB
+	if (kgdb_early_setup)
+		return;
+#endif
+
+  /* TODO:
+   * Initialize the irq registers on the PIC to route
+   * interrupts to appropriate pins
+   */
+	
+	/* Initialize the irq descriptors */
+	init_phoenix_irqs();
+
+	write_64bit_cp0_eimr(phnx_irq_mask);
+}
+
+asmlinkage void plat_irq_dispatch(void)
+{
+	uint64_t eirr;
+	struct pt_regs *pt_regs = current_thread_info()->regs;
+	int i=0;
+	eirr = read_64bit_cp0_eirr() & read_64bit_cp0_eimr();
+	
+	if(!eirr)
+		return;
+
+	if(eirr & (1 << IRQ_TIMER)){
+		phoenix_timer_interrupt(pt_regs,IRQ_TIMER);	
+		return;
+	}
+	/*TODO use dcltz: optimize below code*/
+	for(i=63; i != -1; i--){
+		if(eirr & (1ULL<<i))
+			break;
+	}
+	if(i == -1){
+		printk("no interrupt !!\n");
+		return;
+	}
+	/*ack eirr*/
+	write_64bit_cp0_eirr(1ULL<<i);
+	do_phnx_IRQ(i,pt_regs);
+	return;
+}
+
+
+void pic_setup_threadmask(unsigned int irt, uint32_t mask)
+{
+
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	pic_tmask[irt].mask = mask;
+	pic_tmask[irt].set = 1;
+	pic_tmask[irt].valid = 1;
+ 	phoenix_write_reg(mmio, PIC_IRT_0_BASE + irt, mask);
+	return;
+}
diff --git a/include/asm-mips/rmi/pic.h b/include/asm-mips/rmi/pic.h
new file mode 100644
index 0000000..a476470
--- /dev/null
+++ b/include/asm-mips/rmi/pic.h
@@ -0,0 +1,274 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _ASM_RMI_PIC_H
+#define _ASM_RMI_PIC_H
+
+#include <asm/rmi/iomap.h>
+
+#define PIC_CLKS_PER_SEC 66666666ULL
+/**************************************************************/
+#define PIC_IRT_WD_INDEX     0
+#define PIC_IRT_TIMER_0_INDEX      1
+#define PIC_IRT_TIMER_1_INDEX      2
+#define PIC_IRT_TIMER_2_INDEX      3
+#define PIC_IRT_TIMER_3_INDEX      4
+#define PIC_IRT_TIMER_4_INDEX      5
+#define PIC_IRT_TIMER_5_INDEX      6
+#define PIC_IRT_TIMER_6_INDEX      7
+#define PIC_IRT_TIMER_7_INDEX      8
+#define PIC_IRT_CLOCK_INDEX        PIC_IRT_TIMER_7_INDEX
+#define PIC_IRT_UART_0_INDEX       9
+#define PIC_IRT_UART_1_INDEX       10
+#define PIC_IRT_I2C_0_INDEX       11
+#define PIC_IRT_I2C_1_INDEX       12
+#define PIC_IRT_PCMCIA_INDEX           13
+#define PIC_IRT_GPIO_INDEX             14
+#define PIC_IRT_HYPER_INDEX            15
+#define PIC_IRT_PCIX_INDEX             16
+#ifdef XLS
+#define PIC_IRT_CDE_INDEX              15
+#define PIC_IRT_BRIDGE_TB_XLS_INDEX    16
+#endif /* XLS */
+#define PIC_IRT_GMAC0_INDEX            17
+#define PIC_IRT_GMAC1_INDEX            18
+#define PIC_IRT_GMAC2_INDEX            19
+#define PIC_IRT_GMAC3_INDEX            20
+#define PIC_IRT_XGS0_INDEX             21
+#define PIC_IRT_XGS1_INDEX             22
+#define PIC_IRT_HYPER_FATAL_INDEX      23
+#define PIC_IRT_PCIX_FATAL_INDEX       24
+#define PIC_IRT_BRIDGE_AERR_INDEX      25
+#define PIC_IRT_BRIDGE_BERR_INDEX     26
+#define PIC_IRT_BRIDGE_TB_XLR_INDEX    27
+#define PIC_IRT_BRIDGE_AERR_NMI_INDEX  28
+#ifdef XLS
+#define PIC_IRT_GMAC4_INDEX            21
+#define PIC_IRT_GMAC5_INDEX            22
+#define PIC_IRT_GMAC6_INDEX            23
+#define PIC_IRT_GMAC7_INDEX            24
+#define PIC_IRT_BRIDGE_ERR_INDEX       25
+#define PIC_IRT_PCIE_LINK0_INDEX       26
+#define PIC_IRT_PCIE_LINK1_INDEX       27
+#define PIC_IRT_PCIE_LINK2_INDEX       23
+#define PIC_IRT_PCIE_LINK3_INDEX       24
+#define PIC_IRT_PCIE_XLSB0_LINK2_INDEX       28
+#define PIC_IRT_PCIE_XLSB0_LINK3_INDEX       29
+#define PIC_IRT_SRIO_LINK0_INDEX        26
+#define PIC_IRT_SRIO_LINK1_INDEX        27
+#define PIC_IRT_SRIO_LINK2_INDEX        28
+#define PIC_IRT_SRIO_LINK3_INDEX        29
+#define PIC_IRT_PCIE_INT_INDEX         28
+#define PIC_IRT_PCIE_FATAL_INDEX       29
+#define PIC_IRT_GPIO_B_INDEX           30
+#define PIC_IRT_USB_INDEX              31
+#endif /* XLS */
+#define PIC_NUM_IRTS                   32
+
+#define PIC_SYS_TIMER_MAXVAL_0_BASE 0x100
+#define PIC_SYS_TIMER_MAXVAL_1_BASE 0x110
+
+#define PIC_SYS_TIMER_0_BASE 0x120
+#define PIC_SYS_TIMER_1_BASE 0x130
+
+#define PIC_CLOCK_TIMER 7
+
+#define PIC_CTRL    0x00
+#define PIC_IPI     0x04
+#define PIC_INT_ACK 0x06
+
+#define WD_MAX_VAL_0 0x08
+#define WD_MAX_VAL_1 0x09
+#define WD_MASK_0    0x0a
+#define WD_MASK_1    0x0b
+#define WD_HEARBEAT_0 0x0c
+#define WD_HEARBEAT_1 0x0d
+
+#define PIC_IRT_0_BASE 0x40
+#define PIC_IRT_1_BASE 0x80
+
+#define PIC_IRT_0_WD     (PIC_IRT_0_BASE   + PIC_IRT_WD_INDEX)
+#define PIC_IRT_1_WD     (PIC_IRT_1_BASE   + PIC_IRT_WD_INDEX)
+#define PIC_IRT_0_TIMER_0     (PIC_IRT_0_BASE   + PIC_IRT_TIMER_0_INDEX)
+#define PIC_IRT_1_TIMER_0     (PIC_IRT_1_BASE   + PIC_IRT_TIMER_0_INDEX)
+#define PIC_IRT_0_TIMER_1     (PIC_IRT_0_BASE   + PIC_IRT_TIMER_1_INDEX)
+#define PIC_IRT_1_TIMER_1     (PIC_IRT_1_BASE   + PIC_IRT_TIMER_1_INDEX)
+#define PIC_IRT_0_TIMER_2     (PIC_IRT_0_BASE   + PIC_IRT_TIMER_2_INDEX)
+#define PIC_IRT_1_TIMER_2     (PIC_IRT_1_BASE   + PIC_IRT_TIMER_2_INDEX)
+#define PIC_IRT_0_TIMER_3     (PIC_IRT_0_BASE   + PIC_IRT_TIMER_3_INDEX)
+#define PIC_IRT_1_TIMER_3     (PIC_IRT_1_BASE   + PIC_IRT_TIMER_3_INDEX)
+#define PIC_IRT_0_TIMER_4     (PIC_IRT_0_BASE   + PIC_IRT_TIMER_4_INDEX)
+#define PIC_IRT_1_TIMER_4     (PIC_IRT_1_BASE   + PIC_IRT_TIMER_4_INDEX)
+#define PIC_IRT_0_TIMER_5     (PIC_IRT_0_BASE   + PIC_IRT_TIMER_5_INDEX)
+#define PIC_IRT_1_TIMER_5     (PIC_IRT_1_BASE   + PIC_IRT_TIMER_5_INDEX)
+#define PIC_IRT_0_TIMER_6     (PIC_IRT_0_BASE   + PIC_IRT_TIMER_6_INDEX)
+#define PIC_IRT_1_TIMER_6     (PIC_IRT_1_BASE   + PIC_IRT_TIMER_6_INDEX)
+#define PIC_IRT_0_TIMER_7     (PIC_IRT_0_BASE   + PIC_IRT_TIMER_7_INDEX)
+#define PIC_IRT_1_TIMER_7     (PIC_IRT_1_BASE   + PIC_IRT_TIMER_7_INDEX)
+#define PIC_IRT_0_CLOCK       (PIC_IRT_0_TIMER_7)
+#define PIC_IRT_1_CLOCK       (PIC_IRT_1_TIMER_7)
+#define PIC_IRT_0_UART_0 (PIC_IRT_0_BASE + PIC_IRT_UART_0_INDEX)
+#define PIC_IRT_1_UART_0 (PIC_IRT_1_BASE + PIC_IRT_UART_0_INDEX)
+#define PIC_IRT_0_UART_1 (PIC_IRT_0_BASE + PIC_IRT_UART_1_INDEX)
+#define PIC_IRT_1_UART_1 (PIC_IRT_1_BASE + PIC_IRT_UART_1_INDEX)
+#define PIC_IRT_0_I2C_0 (PIC_IRT_0_BASE + PIC_IRT_I2C_0_INDEX)
+#define PIC_IRT_1_I2C_0 (PIC_IRT_1_BASE + PIC_IRT_I2C_0_INDEX)
+#define PIC_IRT_0_I2C_1 (PIC_IRT_0_BASE + PIC_IRT_I2C_1_INDEX)
+#define PIC_IRT_1_I2C_1 (PIC_IRT_1_BASE + PIC_IRT_I2C_1_INDEX)
+
+#define PIC_TIMER_0_MAXVAL_0   (PIC_SYS_TIMER_MAXVAL_0_BASE + 0)
+#define PIC_TIMER_0_MAXVAL_1   (PIC_SYS_TIMER_MAXVAL_1_BASE + 0)
+#define PIC_TIMER_0_COUNTER_0  (PIC_SYS_TIMER_0_BASE + 0)
+#define PIC_TIMER_0_COUNTER_1  (PIC_SYS_TIMER_1_BASE + 0)
+#define PIC_TIMER_7_MAXVAL_0   (PIC_SYS_TIMER_MAXVAL_0_BASE + 7)
+#define PIC_TIMER_7_MAXVAL_1   (PIC_SYS_TIMER_MAXVAL_1_BASE + 7)
+#define PIC_TIMER_7_COUNTER_0  (PIC_SYS_TIMER_0_BASE + 7)
+#define PIC_TIMER_7_COUNTER_1  (PIC_SYS_TIMER_1_BASE + 7)
+#define PIC_TIMER_6_MAXVAL_0   (PIC_SYS_TIMER_MAXVAL_0_BASE + 6)
+#define PIC_TIMER_6_MAXVAL_1   (PIC_SYS_TIMER_MAXVAL_1_BASE + 6)
+#define PIC_TIMER_6_COUNTER_0  (PIC_SYS_TIMER_0_BASE + 6)
+#define PIC_TIMER_6_COUNTER_1  (PIC_SYS_TIMER_1_BASE + 6)
+
+#define PIC_IRQ_BASE      8
+#define PIC_IRT_FIRST_IRQ PIC_IRQ_BASE
+#define PIC_WD_IRQ      (PIC_IRQ_BASE + PIC_IRT_WD_INDEX)
+#define PIC_TIMER_0_IRQ (PIC_IRQ_BASE + PIC_IRT_TIMER_0_INDEX)
+#define PIC_TIMER_1_IRQ (PIC_IRQ_BASE + PIC_IRT_TIMER_1_INDEX)
+#define PIC_TIMER_2_IRQ (PIC_IRQ_BASE + PIC_IRT_TIMER_2_INDEX)
+#define PIC_TIMER_3_IRQ (PIC_IRQ_BASE + PIC_IRT_TIMER_3_INDEX)
+#define PIC_TIMER_4_IRQ (PIC_IRQ_BASE + PIC_IRT_TIMER_4_INDEX)
+#define PIC_TIMER_5_IRQ (PIC_IRQ_BASE + PIC_IRT_TIMER_5_INDEX)
+#define PIC_TIMER_6_IRQ (PIC_IRQ_BASE + PIC_IRT_TIMER_6_INDEX)
+#define PIC_TIMER_7_IRQ (PIC_IRQ_BASE + PIC_IRT_TIMER_7_INDEX)
+#define PIC_CLOCK_IRQ   (PIC_TIMER_7_IRQ)
+#define PIC_UART_0_IRQ  (PIC_IRQ_BASE + PIC_IRT_UART_0_INDEX)
+#define PIC_UART_1_IRQ  (PIC_IRQ_BASE + PIC_IRT_UART_1_INDEX)
+#define PIC_I2C_0_IRQ   (PIC_IRQ_BASE + PIC_IRT_I2C_0_INDEX)
+#define PIC_I2C_1_IRQ   (PIC_IRQ_BASE + PIC_IRT_I2C_1_INDEX)
+#define PIC_PCMCIA_IRQ           (PIC_IRQ_BASE + PIC_IRT_PCMCIA_INDEX)
+#define PIC_GPIO_IRQ             (PIC_IRQ_BASE + PIC_IRT_GPIO_INDEX)
+#define PIC_HYPER_IRQ            (PIC_IRQ_BASE + PIC_IRT_HYPER_INDEX)
+#define PIC_PCIX_IRQ             (PIC_IRQ_BASE + PIC_IRT_PCIX_INDEX)
+#ifdef XLS
+#define PIC_CDE_IRQ              (PIC_IRQ_BASE + PIC_IRT_CDE_INDEX)
+#define PIC_BRIDGE_TB_XLS_IRQ    (PIC_IRQ_BASE + PIC_IRT_BRIDGE_TB_XLS_INDEX)
+#endif /* XLS */
+#define PIC_GMAC_0_IRQ            (PIC_IRQ_BASE + PIC_IRT_GMAC0_INDEX)
+#define PIC_GMAC_1_IRQ            (PIC_IRQ_BASE + PIC_IRT_GMAC1_INDEX)
+#define PIC_GMAC_2_IRQ            (PIC_IRQ_BASE + PIC_IRT_GMAC2_INDEX)
+#define PIC_GMAC_3_IRQ            (PIC_IRQ_BASE + PIC_IRT_GMAC3_INDEX)
+#define PIC_XGS_0_IRQ             (PIC_IRQ_BASE + PIC_IRT_XGS0_INDEX)
+#define PIC_XGS_1_IRQ             (PIC_IRQ_BASE + PIC_IRT_XGS1_INDEX)
+#define PIC_HYPER_FATAL_IRQ      (PIC_IRQ_BASE + PIC_IRT_HYPER_FATAL_INDEX)
+#define PIC_PCIX_FATAL_IRQ       (PIC_IRQ_BASE + PIC_IRT_PCIX_FATAL_INDEX)
+#define PIC_BRIDGE_AERR_IRQ      (PIC_IRQ_BASE + PIC_IRT_BRIDGE_AERR_INDEX)
+#define PIC_BRIDGE_BERR_IRQ      (PIC_IRQ_BASE + PIC_IRT_BRIDGE_BERR_INDEX)
+#define PIC_BRIDGE_TB_XLR_IRQ    (PIC_IRQ_BASE + PIC_IRT_BRIDGE_TB_XLR_INDEX)
+#define PIC_BRIDGE_AERR_NMI_IRQ  (PIC_IRQ_BASE + PIC_IRT_BRIDGE_AERR_NMI_INDEX)
+#define PIC_IRT_LAST_XLR_IRQ     PIC_BRIDGE_AERR_NMI_IRQ
+#ifdef XLS
+#define PIC_GMAC_4_IRQ           (PIC_IRQ_BASE + PIC_IRT_GMAC4_INDEX)
+#define PIC_GMAC_5_IRQ           (PIC_IRQ_BASE + PIC_IRT_GMAC5_INDEX)
+#define PIC_GMAC_6_IRQ           (PIC_IRQ_BASE + PIC_IRT_GMAC6_INDEX)
+#define PIC_GMAC_7_IRQ           (PIC_IRQ_BASE + PIC_IRT_GMAC7_INDEX)
+#define PIC_BRIDGE_ERR_IRQ       (PIC_IRQ_BASE + PIC_IRT_BRIDGE_ERR_INDEX)
+#define PIC_PCIE_LINK0_IRQ       (PIC_IRQ_BASE + PIC_IRT_PCIE_LINK0_INDEX)
+#define PIC_PCIE_LINK1_IRQ       (PIC_IRQ_BASE + PIC_IRT_PCIE_LINK1_INDEX)
+#define PIC_PCIE_LINK2_IRQ       (PIC_IRQ_BASE + PIC_IRT_PCIE_LINK2_INDEX)
+#define PIC_PCIE_LINK3_IRQ       (PIC_IRQ_BASE + PIC_IRT_PCIE_LINK3_INDEX)
+#define PIC_PCIE_XLSB0_LINK2_IRQ (PIC_IRQ_BASE + PIC_IRT_PCIE_XLSB0_LINK2_INDEX)
+#define PIC_PCIE_XLSB0_LINK3_IRQ (PIC_IRQ_BASE + PIC_IRT_PCIE_XLSB0_LINK3_INDEX)
+#define PIC_SRIO_LINK0_IRQ       (PIC_IRQ_BASE + PIC_IRT_SRIO_LINK0_INDEX)
+#define PIC_SRIO_LINK1_IRQ       (PIC_IRQ_BASE + PIC_IRT_SRIO_LINK1_INDEX)
+#define PIC_SRIO_LINK2_IRQ       (PIC_IRQ_BASE + PIC_IRT_SRIO_LINK2_INDEX)
+#define PIC_SRIO_LINK3_IRQ       (PIC_IRQ_BASE + PIC_IRT_SRIO_LINK3_INDEX)
+#define PIC_PCIE_INT_IRQ         (PIC_IRQ_BASE + PIC_IRT_PCIE_INT__INDEX)
+#define PIC_PCIE_FATAL_IRQ       (PIC_IRQ_BASE + PIC_IRT_PCIE_FATAL_INDEX)
+#define PIC_GPIO_B_IRQ           (PIC_IRQ_BASE + PIC_IRT_GPIO_B_INDEX)
+#define PIC_USB_IRQ              (PIC_IRQ_BASE + PIC_IRT_USB_INDEX)
+#define PIC_IRT_LAST_XLS_IRQ  PIC_USB_IRQ
+#endif /* XLS */
+
+/***************************************************************/
+
+/**************************************************************/
+//#define PHOENIX_IO_PIC (phoenix_io_base + PHOENIX_IO_PIC_OFFSET)
+
+//#define PHOENIX_IO_PIC_IPI (PHOENIX_IO_PIC + (4 << 2))
+/***************************************************************/
+#ifndef __ASSEMBLY__
+static __inline__ void pic_send_ipi(__u32 ipi)
+{
+  phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+  phoenix_write_reg(mmio, PIC_IPI, ipi);
+}
+
+static __inline__ __u32 pic_read_control(void)
+{
+  phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+  return phoenix_read_reg(mmio, PIC_CTRL);
+}
+
+static __inline__ void pic_write_control(__u32 control)
+{
+  phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+  phoenix_write_reg(mmio, PIC_CTRL, control);
+}
+static __inline__ void pic_update_control(__u32 control)
+{
+  phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+  phoenix_write_reg(mmio, PIC_CTRL, (control | phoenix_read_reg(mmio, PIC_CTRL)));
+}
+
+#define PIC_IRQ_IS_EDGE_TRIGGERED(irq) ( ((irq)>=PIC_TIMER_0_IRQ) && ((irq)<=PIC_TIMER_7_IRQ) )
+
+#ifdef XLS
+#define PIC_IRQ_IS_IRT(irq) ( ((irq)>=PIC_IRT_FIRST_IRQ) && ((irq)<=(is_xls()?PIC_IRT_LAST_XLS_IRQ:PIC_IRT_LAST_XLR_IRQ)) )
+#define PIC_IRT_LAST_IRQ() (is_xls()?PIC_IRT_LAST_XLS_IRQ:PIC_IRT_LAST_XLR_IRQ)
+#define PIC_BRIDGE_TB_IRQ() (is_xls()?PIC_BRIDGE_TB_XLS_IRQ:PIC_BRIDGE_TB_XLR_IRQ)
+#else /* XLS */
+#define PIC_IRQ_IS_IRT(irq) ( ((irq)>=PIC_IRT_FIRST_IRQ) && ((irq)<=PIC_IRT_LAST_XLR_IRQ) )
+#endif /* XLS */
+
+struct pt_regs;
+extern void phoenix_ipi_handler(int irq, struct pt_regs *regs);
+extern void phnx_msgring_int_handler(unsigned int irq, struct pt_regs *regs);
+extern void pic_setup_threadmask(unsigned int irt, uint32_t threadmask);
+extern int rmik_alloc_timer(void);
+extern int rmik_get_uart_status(int);
+
+struct pic_tmask { 
+	unsigned int mask; 
+	int set; 
+	int valid;
+};
+#endif
+
+#endif
-- 
1.6.0.4

