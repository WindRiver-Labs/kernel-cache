From f70176dea0d17a899c6b42c15ef9f0cb72df3056 Mon Sep 17 00:00:00 2001
From: Liu Changhui <changhui.liu@windriver.com>
Date: Fri, 29 Jan 2010 13:28:09 +0800
Subject: [PATCH] I2C & RTC: Add i2c and rtc driver for rmi xls

Add i2c and rtc driver for rmi xls.

source: from RMI SDK1.7

Signed-off-by: shuo.kang <shuo.kang@windriver.com>
---
 drivers/i2c/algos/Kconfig         |    9 +
 drivers/i2c/algos/Makefile        |    1 +
 drivers/i2c/algos/i2c-algo-palm.c |  325 ++++++++++++++++++++++
 drivers/i2c/algos/i2c-algo-palm.h |   58 ++++
 drivers/i2c/busses/Kconfig        |   11 +
 drivers/i2c/busses/Makefile       |    1 +
 drivers/i2c/busses/i2c-bk3220.c   |  137 +++++++++
 drivers/i2c/chips/Kconfig         |   19 ++
 drivers/i2c/chips/Makefile        |    3 +
 drivers/i2c/chips/ds1374-rtc.c    |  547 +++++++++++++++++++++++++++++++++++++
 drivers/i2c/chips/max6602.c       |  326 ++++++++++++++++++++++
 drivers/i2c/chips/max6657.c       |  307 +++++++++++++++++++++
 drivers/i2c/i2c-core.c            |   19 ++-
 include/linux/i2c-algo-palm.h     |   53 ++++
 include/linux/i2c-id.h            |   55 ++++
 include/linux/i2c.h               |    3 +
 16 files changed, 1872 insertions(+), 2 deletions(-)
 create mode 100644 drivers/i2c/algos/i2c-algo-palm.c
 create mode 100644 drivers/i2c/algos/i2c-algo-palm.h
 create mode 100644 drivers/i2c/busses/i2c-bk3220.c
 create mode 100644 drivers/i2c/chips/ds1374-rtc.c
 create mode 100644 drivers/i2c/chips/max6602.c
 create mode 100644 drivers/i2c/chips/max6657.c
 create mode 100644 include/linux/i2c-algo-palm.h

diff --git a/drivers/i2c/algos/Kconfig b/drivers/i2c/algos/Kconfig
index b788579..ac4469c 100644
--- a/drivers/i2c/algos/Kconfig
+++ b/drivers/i2c/algos/Kconfig
@@ -11,6 +11,15 @@ config I2C_ALGOBIT
 config I2C_ALGOPCF
 	tristate "I2C PCF 8584 interfaces"
 
+config I2C_ALGOPALM
+        tristate "PalmChip's I2C interfaces"
+        depends on I2C
+        help
+          This allows you to use the BK3220 I2C Host Adapter on the RMI Phoenix.
+
+          This support is also available as a module.  If so, the module
+          will be called i2c-algo-palm.
+
 config I2C_ALGOPCA
 	tristate "I2C PCA 9564 interfaces"
 
diff --git a/drivers/i2c/algos/Makefile b/drivers/i2c/algos/Makefile
index cac1051..f0f7f7f 100644
--- a/drivers/i2c/algos/Makefile
+++ b/drivers/i2c/algos/Makefile
@@ -6,6 +6,7 @@ obj-$(CONFIG_I2C_ALGOBIT)	+= i2c-algo-bit.o
 obj-$(CONFIG_I2C_ALGOPCF)	+= i2c-algo-pcf.o
 obj-$(CONFIG_I2C_ALGOPCA)	+= i2c-algo-pca.o
 obj-$(CONFIG_I2C_ALGO_SGI)	+= i2c-algo-sgi.o
+obj-$(CONFIG_I2C_ALGOPALM)      += i2c-algo-palm.o
 
 ifeq ($(CONFIG_I2C_DEBUG_ALGO),y)
 EXTRA_CFLAGS += -DDEBUG
diff --git a/drivers/i2c/algos/i2c-algo-palm.c b/drivers/i2c/algos/i2c-algo-palm.c
new file mode 100644
index 0000000..089bda7
--- /dev/null
+++ b/drivers/i2c/algos/i2c-algo-palm.c
@@ -0,0 +1,325 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+/*
+ *  i2c-algo-palm.c i2c driver algorithms for the BK3220 I2C Host 
+ *  adapter on the RMI Phoenix System.
+ *  Derived from the PCA-ISA I2C-Algo/Bus files.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/spinlock.h>
+#include <linux/i2c.h>
+#include <linux/i2c-algo-palm.h>
+#include "i2c-algo-palm.h"
+
+#define DRIVER "i2c-algo-palm"
+
+#define DEB1(fmt, args...) do { if (i2c_debug>=1) printk(fmt, ## args); } while(0)
+#define DEB2(fmt, args...) do { if (i2c_debug>=2) printk(fmt, ## args); } while(0)
+#define DEB3(fmt, args...) do { if (i2c_debug>=3) printk(fmt, ## args); } while(0)
+
+static int i2c_debug=0;
+spinlock_t palm_lock;
+					
+#define palm_write(algo_data, reg, val) 	algo_data->write(reg, val)
+#define palm_read(algo_data, reg) 		algo_data->read(reg)
+
+#define palm_clock(adap) 		adap->get_clock(adap)
+#define palm_status(adap) 		palm_inw(adap, I2C_PCA_STA)
+#define palm_set_con(adap, val) 	palm_outw(adap, I2C_PCA_CON, val)
+#define palm_get_con(adap) 		palm_inw(adap, I2C_PCA_CON)
+
+/*
+ * Check if the I2C Bus is idle or busy
+ */
+static int wait_for_idle(struct i2c_algo_palm_data *algo_data)
+{
+	int timeOut=0x1000;
+	volatile __u32 regVal=0x00;
+	regVal = palm_read(algo_data, I2C_PALM_STATUS) & 0x0001;
+	while (regVal && timeOut--) {
+		regVal = palm_read(algo_data, I2C_PALM_STATUS) & 0x0001;
+	}
+	if (timeOut == 0x00)
+		return -1;	/* Timed Out */
+	else
+		return 0;
+}
+
+/*
+ * Transmit Routine
+ */
+static int palm_tx(struct i2c_algo_palm_data *algo_data,  __u16 len, 
+		__u8 *buf, __u16 addr, __u8 offset)
+{
+	volatile __u32 regVal=0x00;
+	int timeOut, ctr=0x00, numBytes=len;
+
+	for (ctr=0x00; ctr<len; ctr++) {
+		if (wait_for_idle(algo_data) < 0) {
+			printk("TimedOut on Waiting for I2C Bus Idle.\n");
+			return -EIO;
+		}
+		palm_write(algo_data, I2C_PALM_CFG, 0xF8);			
+		palm_write(algo_data, I2C_PALM_BYTECNT, 0x00);
+		palm_write(algo_data, I2C_PALM_DEVADDR, addr); //0x4c, 0x68	
+		palm_write(algo_data, I2C_PALM_ADDR, offset+numBytes-1); //offset
+		palm_write(algo_data, I2C_PALM_DATAOUT, buf[ctr]);
+		palm_write(algo_data, I2C_PALM_STARTXFR, I2C_PALM_STARTXFR_WR );
+		spin_lock_irq(&palm_lock);
+		mdelay(0x1);
+		spin_unlock_irq(&palm_lock);
+		
+		regVal = palm_read(algo_data, I2C_PALM_STATUS);
+		spin_lock_irq(&palm_lock);
+		mdelay(0x01);
+		spin_unlock_irq(&palm_lock);
+		if (regVal & 0x0008) {
+			printk("palm_tx: ACKERR. Aborting...\n");
+			return -1;
+		}
+		timeOut= 0x1000;
+		while (!(regVal & 0x0002) && timeOut) {
+			regVal = palm_read(algo_data, I2C_PALM_STATUS);
+			timeOut--;
+		}
+		if (timeOut==0x00) {
+			printk("palm_tx: [TimeOut] SDOEMPTY Not Set\n");
+			return -1;
+		}
+		timeOut=1000;
+		while ((regVal & 0x0030) && timeOut) {
+			palm_write(algo_data, I2C_PALM_STARTXFR, I2C_PALM_STARTXFR_WR);
+			regVal = palm_read(algo_data, I2C_PALM_STATUS);
+			timeOut--;
+		}
+		if (timeOut==0x00) {
+			printk("palm_rx: TimedOut on Valid STARTXFR/Arbitration\n");
+			return -1;
+		}
+		numBytes--;
+	}
+	return 0;
+}
+static int palm_addr_only(struct i2c_algo_palm_data *algo_data, __u8 *buf,
+		__u16 addr, __u8 offset)
+{
+	volatile __u32 regVal=0x00;
+
+	palm_write(algo_data, I2C_PALM_ADDR,    offset);
+	palm_write(algo_data, I2C_PALM_DEVADDR, addr);
+	palm_write(algo_data, I2C_PALM_CFG,     0xfa);
+	palm_write(algo_data, I2C_PALM_STARTXFR,0x02);
+	regVal = palm_read(algo_data, I2C_PALM_STATUS);
+	if (regVal & 0x0008) {
+		printk("palm_addr_only: ACKERR. Aborting...\n");
+		return -1;
+	}
+	return 0;
+}
+
+
+/*
+ * Receive Routine
+ * Read 'len' bytes from device @ 'addr'
+ */
+static int palm_rx(struct i2c_algo_palm_data *algo_data, __u16 len,
+		__u8 *buf, __u16 addr, __u8 offset)
+{	
+	volatile __u32 regVal=0x00, ctr=0x00;
+	int timeOut, numBytes=0x00;
+
+	palm_write(algo_data, I2C_PALM_CFG, 0xfa);
+	palm_write(algo_data, I2C_PALM_BYTECNT, len);
+	palm_write(algo_data, I2C_PALM_DEVADDR, addr); //DEVADDR=0x4c, 0x68
+	spin_lock_irq(&palm_lock);
+	mdelay(0x01);
+	spin_unlock_irq(&palm_lock);
+
+	for (numBytes=0x00; numBytes < len; numBytes++) {
+		palm_write(algo_data, I2C_PALM_ADDR,  offset+numBytes);//I2C_PALM_ADDR:offset	
+		spin_lock_irq(&palm_lock);
+		mdelay(0x01);
+		spin_unlock_irq(&palm_lock);
+		if (!ctr) {
+			/* Trigger a READ Transaction */
+			palm_write(algo_data, I2C_PALM_STARTXFR, I2C_PALM_STARTXFR_RD);
+			ctr++;
+		}
+
+		/* Error Conditions [Begin] */
+		regVal = palm_read(algo_data, I2C_PALM_STATUS);
+		spin_lock_irq(&palm_lock);
+		mdelay(0x01);
+		spin_unlock_irq(&palm_lock);
+		if (regVal & 0x0008) {
+			printk("palm_rx: ACKERR. Aborting...\n");
+			return -1;
+		}
+		timeOut = 10;
+		while ((regVal & 0x0030) && timeOut--) {
+			palm_write(algo_data, I2C_PALM_STARTXFR, I2C_PALM_STARTXFR_RD);
+			regVal = palm_read(algo_data, I2C_PALM_STATUS);
+		}
+		if (timeOut == 0x00) {
+			printk("palm_rx: TimedOut on Valid STARTXFR/Arbitration\n");
+			return -1;
+		}
+		timeOut=10;
+		/* Do we have valid data from the device yet..? */
+		regVal &= 0x0004;
+		while (!regVal && timeOut--) {
+			regVal = palm_read(algo_data, I2C_PALM_STATUS) & 0x0004;
+		}
+		if (timeOut == 0x00) {
+			printk("palm_rx: TimedOut Waiting for Valid Data\n");
+			return -1;
+		}
+		/* Error Conditions [End] */
+		/* Read the data */
+		buf[numBytes] = (__u8)palm_read(algo_data, I2C_PALM_DATAIN);
+	}
+	return 0;
+}
+
+static int palm_xfer(struct i2c_adapter *i2c_adap,
+		struct i2c_msg msgs[],
+		int num)
+{
+	struct 	i2c_algo_palm_data *algo_data = i2c_adap->algo_data;
+	struct 	i2c_msg *msg = NULL;
+	int 	curmsg;
+
+	for (curmsg = 0; curmsg < num; curmsg++) {
+
+		int addr;
+		msg = &msgs[curmsg];
+
+		addr = (0x7f & msg->addr);
+
+		/*
+		 * Check if I2C State Machine is idle
+		 * 'wait_for_idle' returns 0 => timedOut
+		 * 'BUSY' bit cleared => BUS is IDLE
+		 */
+		if (wait_for_idle(algo_data) < 0) {
+			printk("TimedOut on Waiting for I2C Bus Idle.\n");
+			return -EIO;
+		}
+		if (msg->flags & I2C_M_RD ) {
+			if (palm_addr_only(algo_data, &msg->buf[0], addr, msg->offset) == -1) {
+				printk("I2C ADDRONLY Phase Fail.\n");
+				return -EIO;
+			}
+			if (palm_rx(algo_data, msg->len, &msg->buf[0], addr, msg->offset) == -1) {
+				printk("I2C Read Fail.\n");
+				return -EIO;
+			}
+		}
+		else {
+			if (palm_tx(algo_data, msg->len, &msg->buf[0], addr, msg->offset) == -1) {
+				printk("I2C Write Fail.\n");
+				return -EIO;
+			}
+		}
+	}
+	return num;
+}
+
+static u32 palm_func(struct i2c_adapter *adap)
+{
+	/* We emulate SMBUS over I2C */
+	return I2C_FUNC_SMBUS_EMUL;
+}
+
+static int palm_init(struct i2c_algo_palm_data *algo_data)
+{
+	printk("Intializing BK-3220 I2C Host Adapter...");
+	spin_lock_init(&palm_lock);
+#if 0
+	/* RMI Phoenix has a hardcoded value for CLKDIV now... */
+	palm_write(algo_data, I2C_PALM_CLKDIV, I2C_PALM_CLKDIV_DEF);
+	/* Needed only for Multi-master environments */
+	palm_write(algo_data, I2C_PALM_HDSTATIM, I2C_PALM_HDSTATIM_DEF);
+#endif
+	printk("done.\n");
+	return 0;
+}
+
+static struct i2c_algorithm palm_algo = {
+/* 	.name		= "PalmChips I2C algorithm", */
+/* 	.id		= I2C_ALGO_PALM, */
+	.master_xfer	= palm_xfer,
+	.functionality	= palm_func,
+};
+
+/* 
+ * registering functions to load algorithms at runtime 
+ */
+int i2c_palm_add_bus(struct i2c_adapter *adap)
+{
+	struct i2c_algo_palm_data *palm_adap = adap->algo_data;
+	int rval;
+
+/* 	adap->id |= palm_algo.id; */
+	adap->algo = &palm_algo;
+
+	adap->timeout = 100;		
+	adap->retries = 3;		
+
+	rval = palm_init(palm_adap);
+
+	/* register new adapter to i2c module... */
+	if (!rval)
+		i2c_add_adapter(adap);
+
+	return rval;
+}
+
+int i2c_palm_del_bus(struct i2c_adapter *adap)
+{
+	return i2c_del_adapter(adap);
+}
+
+EXPORT_SYMBOL(i2c_palm_add_bus);
+EXPORT_SYMBOL(i2c_palm_del_bus);
+
+MODULE_AUTHOR("RMI");
+MODULE_DESCRIPTION("I2C-Bus PalmChip's Host Adapter algorithm");
+MODULE_LICENSE("GPL");
+
+module_param(i2c_debug, int, 0);
diff --git a/drivers/i2c/algos/i2c-algo-palm.h b/drivers/i2c/algos/i2c-algo-palm.h
new file mode 100644
index 0000000..6967573
--- /dev/null
+++ b/drivers/i2c/algos/i2c-algo-palm.h
@@ -0,0 +1,58 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+/*
+ *  i2c-algo-palm.c i2c driver algorithms for the BK3220 I2C Host 
+ *  adapter on the RMI Phoenix System.
+ *  Derived from the PCA-ISA I2C-Algo/Bus files.
+ */
+
+#ifndef I2C_PALM_H
+#define I2C_PALM_H 			1
+
+#define I2C_PALM_CFG			0x00 
+#define I2C_PALM_CLKDIV			0x01 
+#define I2C_PALM_DEVADDR		0x02 
+#define I2C_PALM_ADDR			0x03
+#define I2C_PALM_DATAOUT		0x04 
+#define I2C_PALM_DATAIN			0x05 
+#define I2C_PALM_STATUS			0x06
+#define I2C_PALM_STARTXFR		0x07
+#define I2C_PALM_BYTECNT		0x08
+#define I2C_PALM_HDSTATIM		0x09
+
+/* TEST Values!! Change as required */
+#define I2C_PALM_CFG_DEF		0x000000F8	/* 8-Bit Addr + POR Values */
+#define I2C_PALM_CLKDIV_DEF		0x14A //0x00000052	
+#define I2C_PALM_HDSTATIM_DEF		0x107 //0x00000000
+
+#define I2C_PALM_STARTXFR_RD		0x00000001
+#define I2C_PALM_STARTXFR_WR		0x00000000
+
+#endif /* I2C_PALM_H */
diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index eb94378..5dbc17b 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -271,6 +271,17 @@ config I2C_AT91
 	  to support combined I2C messages.  Use the i2c-gpio driver
 	  unless your system can cope with those limitations.
 
+config I2C_BK3220
+        tristate "PalmChip BK-3220"
+        depends on I2C && EXPERIMENTAL
+        select I2C_ALGOPALM
+        help
+          This supports the BK-3220 I2C adapter.  Say Y if you own
+          such an adapter.
+
+          This support is also available as a module.  If so, the module
+          will be called i2c-bk3220.
+
 config I2C_AU1550
 	tristate "Au1550/Au1200 SMBus interface"
 	depends on SOC_AU1550 || SOC_AU1200
diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
index d4dc22d..756fb67 100644
--- a/drivers/i2c/busses/Makefile
+++ b/drivers/i2c/busses/Makefile
@@ -9,6 +9,7 @@ obj-$(CONFIG_I2C_ALI15X3)	+= i2c-ali15x3.o
 obj-$(CONFIG_I2C_AMD756)	+= i2c-amd756.o
 obj-$(CONFIG_I2C_AMD756_S4882)	+= i2c-amd756-s4882.o
 obj-$(CONFIG_I2C_AMD8111)	+= i2c-amd8111.o
+obj-$(CONFIG_I2C_BK3220)   += i2c-bk3220.o
 obj-$(CONFIG_I2C_I801)		+= i2c-i801.o
 obj-$(CONFIG_I2C_ISCH)		+= i2c-isch.o
 obj-$(CONFIG_I2C_NFORCE2)	+= i2c-nforce2.o
diff --git a/drivers/i2c/busses/i2c-bk3220.c b/drivers/i2c/busses/i2c-bk3220.c
new file mode 100644
index 0000000..64fe470
--- /dev/null
+++ b/drivers/i2c/busses/i2c-bk3220.c
@@ -0,0 +1,137 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+/*
+ *  i2c-palm-bk3220.c driver for the BK-3220 Host Adapter on the
+ *  RMI Phoenix System.
+ */
+
+#include <linux/kernel.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/wait.h>
+#include <linux/i2c.h>
+#include <linux/i2c-algo-palm.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/rmi/iomap.h>
+#include <asm/rmi/sim.h>
+
+#include "../algos/i2c-algo-palm.h"
+
+#undef 	DEBUG
+
+#define ARIZONA_RTC_BUS 1
+#define PHOENIX_CPLD_PHYS_ADDR	0xbd850000
+
+static wait_queue_head_t palm_wait;
+__u32 *iobase_i2c_regs = 0;
+
+__u32 *get_i2c_base(unsigned short bus)
+{
+	phoenix_reg_t *mmio = 0;
+
+	if (bus == 0)
+		mmio = phoenix_io_mmio(PHOENIX_IO_I2C_0_OFFSET);
+	else
+		mmio = phoenix_io_mmio(PHOENIX_IO_I2C_1_OFFSET);
+
+	return (__u32 *) mmio;
+}
+
+static void palm_bk3220_write(int reg, int val)
+{
+	/* Code to access the low-level
+	 * I2C Block on the RMI Phoenix 
+	 */
+	phoenix_write_reg(iobase_i2c_regs, reg, val);
+	udelay(100);
+}
+
+static int palm_bk3220_read(int reg)
+{
+	/* Code to access the low-level
+	 * I2C Block on the RMI Phoenix 
+	 */
+	__u32 retVal = phoenix_read_reg(iobase_i2c_regs, reg);
+	return (int) retVal;
+}
+
+static struct i2c_algo_palm_data palm_bk3220_data = {
+	.write = palm_bk3220_write,
+	.read = palm_bk3220_read,
+};
+
+/* This is our i2c_adapter structure */
+static struct i2c_adapter palm_bk3220_ops = {
+	.owner = THIS_MODULE,
+	.id = I2C_HW_PALM_BK3220,
+	.algo_data = &palm_bk3220_data,
+	.name = "Palm Chip BK3220 Adapter",
+};
+
+static int __init palm_bk3220_init(void)
+{
+
+
+
+	iobase_i2c_regs = get_i2c_base(ARIZONA_RTC_BUS);
+
+	init_waitqueue_head(&palm_wait);
+
+	if (i2c_palm_add_bus(&palm_bk3220_ops) < 0) {
+		printk(KERN_ERR
+		       "i2c-palm-bk3220: Failed to add i2c bus\n");
+		goto out;
+	} else {
+		printk("i2c-palm-bk3220: Added I2C Bus.\n");
+	}
+
+	return 0;
+      out:
+	return -ENODEV;
+}
+
+static void palm_bk3220_exit(void)
+{
+	i2c_palm_del_bus(&palm_bk3220_ops);
+}
+
+MODULE_AUTHOR("RMI Inc.");
+MODULE_DESCRIPTION("BK3220 I2C Host adapter driver");
+MODULE_LICENSE("GPL");
+
+module_init(palm_bk3220_init);
+module_exit(palm_bk3220_exit);
diff --git a/drivers/i2c/chips/Kconfig b/drivers/i2c/chips/Kconfig
index d803c41..d3aed48 100644
--- a/drivers/i2c/chips/Kconfig
+++ b/drivers/i2c/chips/Kconfig
@@ -236,4 +236,23 @@ config MENELAUS
 	  and other features that are often used in portable devices like
 	  cell phones and PDAs.
 
+config DS1374_RTC
+	tristate "Dallas/Maxim DS1374 Real Time Clock"
+	depends on RMI_PHOENIX && I2C && RTC!=y && GEN_RTC!=y && EXPERIMENTAL
+	help
+	  Driver for the I2C-based DS1374 RTC Chip on the RMI Phoenix
+
+config MAX6657_TEMP
+	tristate "Maxim MAX6657 Temperature Sensors"
+	depends on RMI_PHOENIX && I2C && RTC!=y && GEN_RTC!=y && EXPERIMENTAL
+	help
+	  Driver for the I2C-based MAX6657 Temp Sensor Chip on the RMI Phoenix
+
+config MAX6602_TEMP
+	tristate "Maxim MAX6602 Temperature Sensors"
+	depends on RMI_PHOENIX && I2C && RTC!=y && GEN_RTC!=y && EXPERIMENTAL
+	help
+	  Driver for the I2C-based MAX6602 Temp Sensor Chip on the RMI LTE Board
+
+
 endmenu
diff --git a/drivers/i2c/chips/Makefile b/drivers/i2c/chips/Makefile
index 2b6287b..8ff395c 100644
--- a/drivers/i2c/chips/Makefile
+++ b/drivers/i2c/chips/Makefile
@@ -19,6 +19,9 @@ obj-$(CONFIG_PCF8575)		+= pcf8575.o
 obj-$(CONFIG_SENSORS_PCF8591)	+= pcf8591.o
 obj-$(CONFIG_ISP1301_OMAP)	+= isp1301_omap.o
 obj-$(CONFIG_TPS65010)		+= tps65010.o
+obj-$(CONFIG_MAX6657_TEMP) += max6657.o
+obj-$(CONFIG_DS1374_RTC)   += ds1374-rtc.o
+obj-$(CONFIG_MAX6602_TEMP) += max6602.o
 obj-$(CONFIG_SENSORS_TLV320AIC23) += tlv320aic23.o
 obj-$(CONFIG_GPIOEXPANDER_OMAP)	+= gpio_expander_omap.o
 obj-$(CONFIG_MENELAUS)		+= menelaus.o
diff --git a/drivers/i2c/chips/ds1374-rtc.c b/drivers/i2c/chips/ds1374-rtc.c
new file mode 100644
index 0000000..a48cec9
--- /dev/null
+++ b/drivers/i2c/chips/ds1374-rtc.c
@@ -0,0 +1,547 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+/*
+ *  linux/drivers/char/ds1374-rtc.c
+ *
+ *	based on drivers/char/x1226-rtc.c
+ *	Steve Longerbeam <stevel@mvista.com, or source@mvista.com>
+ *	2002-2003 (c) MontaVista Software, Inc.
+ *
+ * RTC Driver for the Maxim DS1374 32-bit Binary
+ * Counter WatchDog/RTC
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/rtc.h>		/* get the user-level API */
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/miscdevice.h>
+#include <linux/fcntl.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/time.h>
+
+#include <asm/rmi/sim.h>
+
+/* #define	DEBUG_DS1374 */
+
+#define EPOCH 		2000
+#define SYS_EPOCH 	1900
+
+#ifdef DEBUG_DS1374		
+#define dbg(fmt, args...) 	printk(KERN_DEBUG "%s: " fmt, __func__, ## args)
+#else
+#define dbg(fmt, args...)
+#endif
+
+#define err(format, arg...) 	printk(KERN_ERR ": " format , ## arg)
+#define info(format, arg...) 	printk(KERN_INFO ": " format , ## arg)
+
+#define DEVID_RTC    	   	0x68
+#define DS1374_RTC_BASE    	0x00
+
+#define PHOENIX_I2C_DRIVERID_DS1374   	0x00
+
+extern struct proc_dir_entry *rmi_root_proc;
+
+static struct 	i2c_driver ds1374_driver;
+static struct 	i2c_client *this_client = NULL;
+static int 	ds1374_use_count = 0;
+static int 	rtc_read_proc(char *page, char **start, off_t off, int count, 
+		int *eof, void *data);
+static void 	ds1374_BinaryToDate(unsigned long binary, struct rtc_time *datetime);
+
+
+/* This is an image of the RTC registers starting at offset 0x00 */
+struct rtc_registers {
+	unsigned char todc_byte0;     	// 0x00
+	unsigned char todc_byte1;     	// 0x01
+	unsigned char todc_byte2;    	// 0x02
+	unsigned char todc_byte3; 	// 0x03
+};
+
+/* Array representing the number of days in one non-leap year at 
+   the beginning of each month */
+
+unsigned long DaysToMonth[13] = {
+	0,31,59,90,120,151,181,212,243,273,304,334,365
+};
+
+static int
+ds1374_read(struct i2c_client *client, u16 offset, u8 * buf, int len)
+{
+	int ret;
+	struct i2c_msg todc_read[1] = {
+		{
+			client->addr,			/* 0x68 */
+			client->flags | I2C_M_RD,	/* I2C Read Command */
+			offset,
+			4,				/* Need 4 Bytes */
+			buf				/* Store the result here */
+		}
+	};
+
+	if ((ret = i2c_transfer(client->adapter, todc_read, 1)) != 1) {
+		err("i2c_transfer failed, ret=%d\n", ret);
+		ret = -ENXIO;
+	}
+	return ret;
+}
+
+static int
+ds1374_write(struct i2c_client *client, u16 offset, u8 * buf, int len)
+{
+	int ret;
+	struct i2c_msg todc_write = {
+		client->addr,			/* 0x68 */
+		client->flags,			/* I2C Write Command */
+        offset, // register offset which to write
+		4,				/* Write 4 Bytes */
+		buf				/* Data to be written */
+	};
+
+	if ((ret = i2c_transfer(client->adapter, &todc_write, 1)) != 1) {
+		err("i2c_transfer failed, ret=%d\n", ret);
+		ret = -ENXIO;
+	}
+	return ret;
+}
+
+
+/* The DS1374 gives a 32-bit up-counter counting in seconds.
+ * We rely on a Maxim Algorithm to convert this 32-bit binary
+ * to a user-friendly time/date format
+ */
+static void ds1374_BinaryToDate(unsigned long binary, struct rtc_time *datetime) {
+
+	unsigned long hour;
+	unsigned long day;
+	unsigned long minute;
+	unsigned long second;
+	unsigned long month;
+	unsigned long year;
+
+	unsigned long whole_minutes;
+	unsigned long whole_hours;
+	unsigned long whole_days;
+	unsigned long whole_days_since_1968;
+	unsigned long leap_year_periods;
+	unsigned long days_since_current_lyear;
+	unsigned long whole_years;
+	unsigned long days_since_first_of_year;
+	unsigned long days_to_month;
+	unsigned long day_of_week;
+
+	whole_minutes = binary / 60;
+	second = binary - (60 * whole_minutes);			/* leftover seconds */
+
+	whole_hours  = whole_minutes / 60;
+	minute = whole_minutes - (60 * whole_hours);		/* leftover minutes */
+
+	whole_days   = whole_hours / 24;
+	hour         = whole_hours - (24 * whole_days);		/* leftover hours */
+
+	whole_days_since_1968 = whole_days + 365 + 366;
+	leap_year_periods = whole_days_since_1968 / ((4 * 365) + 1);
+
+	days_since_current_lyear = whole_days_since_1968 % ((4 * 365) + 1);
+
+	/* if days are after a current leap year then add a leap year period */
+	if ((days_since_current_lyear >= (31 + 29))) {
+		leap_year_periods++;
+	}
+	whole_years = (whole_days_since_1968 - leap_year_periods) / 365;
+	days_since_first_of_year = whole_days_since_1968 - 
+		(whole_years * 365) - leap_year_periods;
+
+	if ((days_since_current_lyear <= 365) && (days_since_current_lyear >= 60)) {
+		days_since_first_of_year++;
+	}
+	year = whole_years + 68;
+
+	/* setup for a search for what month it is based on how many days have past
+	 * within the current year	
+	 */
+	month = 13;
+	days_to_month = 366;
+	while (days_since_first_of_year < days_to_month) {
+		month--;
+		days_to_month = DaysToMonth[month];
+		if ((month >= 2) && ((year % 4) == 0)) {
+			days_to_month++;
+		}
+	}
+	day = days_since_first_of_year - days_to_month + 1;
+
+	day_of_week = (whole_days  + 4) % 7;
+
+	datetime->tm_yday =  days_since_first_of_year;	/* days since Jan 1 - [0,365]*/
+	datetime->tm_sec  = second;			/* seconds after the minute - [0,59]*/
+	datetime->tm_min  = minute;			/* minutes after the hour - [0,59]*/
+	datetime->tm_hour = hour;			/* hours since midnight - [0,23]*/
+	datetime->tm_mday = day;			/* day of the month - [1,31]*/
+	datetime->tm_wday = day_of_week;		/* days since Sunday - [0,6]*/
+	datetime->tm_mon  = month;			/* months since January - [0,11]*/
+	datetime->tm_year = year;			/* years since 1900*/
+}
+
+/* Converting DateTime format to the 32-bit Binary */
+unsigned long ds1374_DateToBinary(struct rtc_time *datetime) {
+
+	unsigned long iday;
+	unsigned long val;
+
+	iday = (365 * (datetime->tm_year - 70)) + DaysToMonth[datetime->tm_mon] + (datetime->tm_mday - 1);
+	iday = iday + ((datetime->tm_year - 69) / 4);
+	if ((datetime->tm_mon > 1) && ((datetime->tm_year % 4) == 0)) {
+		iday++;
+	}
+	val = datetime->tm_sec + (60 * datetime->tm_min) + (3600 * (datetime->tm_hour + (24 * iday)));
+	dbg("ds1374_DateToBinary: 0x%lx [%d]\n", val, val);
+	return val;
+}
+
+static int
+ds1374_get_time(struct i2c_client *client, struct rtc_time *tm)
+{
+	struct rtc_registers rtc;
+	int ret;
+	unsigned int binary=0x00, binary1;
+	int limit=10;
+
+	if (!client) return -ENXIO;
+	
+retry:
+	/* read RTC registers */
+	if ((ret = ds1374_read(client, DS1374_RTC_BASE, (u8 *) & rtc,
+					sizeof (struct rtc_registers))) < 0) {
+		dbg("couldn't read RTC\n");
+		return ret;
+	}
+
+	dbg("IN: todc_B0=%02d, todc_B1=%02d, todc_B2=%02d, todc_B3=%02d\n",
+			rtc.todc_byte0, 
+			rtc.todc_byte1, 
+			rtc.todc_byte2, 
+			rtc.todc_byte3);
+
+	binary = 	(rtc.todc_byte0) + (rtc.todc_byte1 << 8) + 
+		  	(rtc.todc_byte2 << 16) + (rtc.todc_byte3 << 24);
+
+	if ((ret = ds1374_read(client, DS1374_RTC_BASE, (u8 *) & rtc,
+					sizeof (struct rtc_registers))) < 0) {
+		dbg("couldn't read RTC\n");
+		return ret;
+	}
+	binary1 = (rtc.todc_byte0) + (rtc.todc_byte1 << 8) +
+		(rtc.todc_byte2 << 16) + (rtc.todc_byte3 << 24);
+
+	if((binary1 != binary) && limit) {
+		limit--;
+		goto retry;
+	}
+	if(binary1 != binary)
+		printk("ds1374_read:Unable to read consistent date value\n");
+
+	ds1374_BinaryToDate(binary, tm);
+
+	dbg("Date [%02d:%02d:%04d] Time [%02d:%02d:%02d]\n",
+			tm->tm_mon+1, tm->tm_mday,  (1900+tm->tm_year),
+			tm->tm_hour, tm->tm_min, tm->tm_sec);
+	return 0;
+}
+
+static int
+ds1374_set_time(struct i2c_client *client, struct rtc_time *tm)
+{
+	struct rtc_registers rtc, rtc1;
+	unsigned int binary=0x00, binary1;
+	int limit;
+
+	if (!client) return -ENXIO;
+	
+	dbg("IN: year=%d, mon=%d, day=%d, hour=%d, min=%d, sec=%d\n",
+			tm->tm_year, tm->tm_mon, tm->tm_mday, tm->tm_hour,
+			tm->tm_min, tm->tm_sec);
+
+	binary = ds1374_DateToBinary(tm);
+
+	rtc.todc_byte0	= (unsigned char)(binary >> 24);
+	rtc.todc_byte1	= (unsigned char)(binary >> 16);
+	rtc.todc_byte2	= (unsigned char)(binary >> 8);
+	rtc.todc_byte3	= (unsigned char)(binary & 0xFF);
+
+	/* write RTC registers */
+	limit = 10;
+	do {
+		ds1374_write(client, DS1374_RTC_BASE, (u8 *)&rtc, 
+				sizeof (struct rtc_registers));
+		ds1374_read(client, DS1374_RTC_BASE, (u8 *)&rtc1, 
+				sizeof (struct rtc_registers));
+		binary1 = (rtc1.todc_byte0) + (rtc1.todc_byte1 << 8) + 
+			(rtc1.todc_byte2 << 16) + (rtc1.todc_byte3 << 24);
+	} while ((binary1 != binary) && limit--);
+
+	if(binary1 != binary)
+		printk("ds1374_set_time: cannot set date on rtc\n");
+	return 0;
+}
+
+static int
+ds1374_probe(struct i2c_adapter *adap)
+{
+	int ret;
+	struct rtc_time dummy_tm;
+	if (this_client != NULL)
+		return -EBUSY;
+
+	this_client = kmalloc(sizeof (*this_client), GFP_KERNEL);
+	if (this_client == NULL) {
+		return -ENOMEM;
+	}
+
+	memset(this_client, 0, sizeof(*this_client));
+
+	strcpy(this_client->name, "DS1374");
+/* 	this_client->id 	= ds1374_driver.id; */
+	this_client->addr 	= DEVID_RTC;
+	this_client->adapter 	= adap;
+	this_client->driver 	= &ds1374_driver;
+	this_client->flags 	= 0;
+	/*
+	 * use ds1374_get_time() to probe for a DS1374 on this bus.
+	 */
+	if ((ret = ds1374_get_time(this_client, &dummy_tm)) < 0) {
+		kfree(this_client);
+		this_client = NULL;
+		return ret;
+	}
+
+	info("Found DS1374 on %s\n", adap->name);
+
+	/* attach it. */
+	return i2c_attach_client(this_client);
+}
+
+static int
+ds1374_detach(struct i2c_client *client)
+{
+	i2c_detach_client(client);
+
+	if (this_client != NULL) {
+		kfree(this_client);
+		this_client = NULL;
+	}
+
+	return 0;
+}
+
+int
+rtc_open(struct inode *minode, struct file *mfile)
+{
+	/*if(MOD_IN_USE) */
+	if (ds1374_use_count > 0) {
+		return -EBUSY;
+	}
+	/* MOD_INC_USE_COUNT; */
+	++ds1374_use_count;
+	return 0;
+}
+
+int
+rtc_release(struct inode *minode, struct file *mfile)
+{
+/* 	MOD_DEC_USE_COUNT; */
+	--ds1374_use_count;
+	return 0;
+}
+
+static loff_t
+rtc_llseek(struct file *mfile, loff_t offset, int origint)
+{
+	return -ESPIPE;
+}
+
+static int
+ds1374_command(struct i2c_client *client, unsigned int cmd, void *arg)
+{
+	return -EINVAL;
+}
+
+static int
+rtc_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+		unsigned long arg)
+{
+	struct rtc_time rtc_tm;
+	int ret;
+
+	switch (cmd) {
+		case RTC_RD_TIME:       /* Read the time/date from RTC  */
+			memset(&rtc_tm, 0, sizeof(rtc_tm));
+			if ((ret = ds1374_get_time(this_client, &rtc_tm)) < 0)
+				return ret;
+			return copy_to_user((void *) arg, &rtc_tm, sizeof (rtc_tm)) ?
+				-EFAULT : 0;
+		case RTC_SET_TIME:      /* Set the RTC */
+			if (!capable(CAP_SYS_TIME))
+				return -EACCES;
+
+			if (copy_from_user(&rtc_tm,
+						(struct rtc_time *) arg,
+						sizeof (struct rtc_time)))
+				return -EFAULT;
+			return ds1374_set_time(this_client, &rtc_tm);
+			return 0;
+		default:
+			return -EINVAL;
+	}
+}
+
+static struct i2c_driver ds1374_driver = {
+	.id		= PHOENIX_I2C_DRIVERID_DS1374,
+	.driver = {
+		.name   = "ds1374",
+	},
+	.attach_adapter = ds1374_probe,
+	.detach_client	= ds1374_detach,
+	.command	= ds1374_command
+};
+
+static struct file_operations rtc_fops = {
+	.owner 		= THIS_MODULE,
+	.llseek 	= rtc_llseek,
+	.ioctl 		= rtc_ioctl,
+	.open 		= rtc_open,
+	.release 	= rtc_release,
+};
+
+static struct miscdevice ds1374_miscdev = {
+	RTC_MINOR,
+	"rtc",
+	&rtc_fops
+};
+
+static int __init ds1374_init(void)
+{
+	int ret;
+	extern int xlr_noi2c;
+
+	if(xlr_noi2c)
+		return 0;
+
+	printk("Registering Phoenix I2C based RTC driver...\n");
+	ret = i2c_add_driver(&ds1374_driver);
+	if (ret) {
+		printk("Unable to register phoenix RTC driver!\n");
+		return ret;		
+	}	
+
+	ret = misc_register(&ds1374_miscdev);
+	if (ret) {
+		err("Register misc driver failed, errno is %d\n", ret);
+		i2c_del_driver(&ds1374_driver);
+		return ret;
+	}
+
+	create_proc_read_entry("rtc", 0, rmi_root_proc, rtc_read_proc, NULL);
+
+	return 0;
+}
+
+static void __exit ds1374_exit(void)
+{
+	remove_proc_entry("rtc", rmi_root_proc);
+	misc_deregister(&ds1374_miscdev);
+	i2c_del_driver(&ds1374_driver);
+}
+
+
+module_init(ds1374_init);
+module_exit(ds1374_exit);
+
+/*
+ * Info exported via "/proc/driver/rtc".
+ */
+
+static int
+rtc_proc_output(char *buf)
+{
+	char *p;
+	struct rtc_time tm;
+	int ret;
+
+	if (!this_client) {
+		p = buf;
+		p += sprintf(p, "Driver Not Initialized Properly!\n");		
+		return p - buf;		
+	}
+	
+	if ((ret = ds1374_get_time(this_client, &tm)) < 0)
+		return ret;
+
+	p = buf;
+	/*
+	 * There is no way to tell if the luser has the RTC set for local
+	 * time or for Universal Standard Time (GMT). Probably local though.
+	 */
+	p += sprintf(p,
+			"rtc_time\t: %02d:%02d:%02d\n"
+			"rtc_date\t: %04d-%02d-%02d\n"
+			"rtc_epoch\t: %04d\n",
+			tm.tm_hour, tm.tm_min, tm.tm_sec,
+			tm.tm_year + SYS_EPOCH, tm.tm_mon + 1, tm.tm_mday, EPOCH);
+	return p - buf;
+}
+
+static int
+rtc_read_proc(char *page, char **start, off_t off,
+		int count, int *eof, void *data)
+{
+	int len = rtc_proc_output(page);
+	if (len <= off + count)
+		*eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len > count)
+		len = count;
+	if (len < 0)
+		len = 0;
+	return len;
+}
+
+MODULE_AUTHOR("RMI Inc.");
+MODULE_DESCRIPTION("Maxim DS1374 RTC Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/i2c/chips/max6602.c b/drivers/i2c/chips/max6602.c
new file mode 100644
index 0000000..ca30aec
--- /dev/null
+++ b/drivers/i2c/chips/max6602.c
@@ -0,0 +1,326 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+/*
+ * linux/drivers/i2c/chips/max6602.c
+ *
+ * based on drivers/char/x1226-rtc.c
+ * Steve Longerbeam <stevel@mvista.com, or source@mvista.com>
+ * 2002-2003 (c) MontaVista Software, Inc.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/miscdevice.h>
+#include <linux/fcntl.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/time.h>
+
+#include <asm/rmi/sim.h>
+
+/* #define 	DEBUG_MAX6602 */
+
+
+#ifdef DEBUG_MAX6602		
+#define dbg(fmt, args...) 	printk(KERN_DEBUG "%s: " fmt, __func__, ## args)
+#else
+#define dbg(fmt, args...)
+#endif
+
+#define err(format, arg...) 	printk(KERN_ERR ": " format , ## arg)
+#define info(format, arg...) 	printk(KERN_INFO ": " format , ## arg)
+
+#define DEVID_TEMP    	   	0x4d
+#define MAX6602_TEMP_BASE    	0x07
+#define XLS_I2C_DRIVERID_MAX6602   	0x02
+
+static struct 	i2c_driver max6602_driver;
+static struct 	i2c_client *this_client = NULL;
+static int 	max6602_use_count = 0;
+static int 	temp_read_proc(char *page, char **start, off_t off, int count, 
+		int *eof, void *data);
+extern struct proc_dir_entry *rmi_root_proc;
+
+
+static int
+max6602_read(struct i2c_client *client, u16 offset, u8 * buf, int len)
+{
+	int ret;
+	struct i2c_msg temp_read[1] = {
+		{
+			client->addr,			/* 0x4c */
+			client->flags | I2C_M_RD,	/* I2C Read Command */
+            offset,
+			len,				/* Need 4 Bytes */
+			buf				/* Store the result here */
+		}
+	};
+
+	if ((ret = i2c_transfer(client->adapter, temp_read, 1)) != 1) {
+		err("i2c_transfer failed, ret=%d\n", ret);
+		ret = -ENXIO;
+	}
+
+	return ret;
+}
+
+static int
+max6602_get_value(struct i2c_client *client, unsigned char *value, int offset)
+{
+	int ret;
+
+	if (!client) return -ENXIO;
+
+	/* read TEMP registers */
+	if ((ret = max6602_read(client, offset, value, sizeof (char))) < 0) {
+		dbg("couldn't read TEMP\n");
+		return ret;
+	}
+
+	dbg("IN: value=%0x\n", *value);
+
+	return 0;
+}
+
+
+static int max6602_probe(struct i2c_adapter *adap)
+{
+	int ret;
+	unsigned char temp;
+	if (this_client != NULL)
+		return -EBUSY;
+
+	this_client = kmalloc(sizeof (*this_client), GFP_KERNEL);
+	if (this_client == NULL) {
+		return -ENOMEM;
+	}
+
+	memset(this_client, 0, sizeof(*this_client));
+
+	strcpy(this_client->name, "MAX6602");
+/* 	this_client->id 	= max6602_driver.id; */
+	this_client->addr 	= DEVID_TEMP;
+	this_client->adapter 	= adap;
+	this_client->driver 	= &max6602_driver;
+	this_client->flags 	= 0;
+	/*
+	 * use max6602_get_value() to probe for a MAX6602 on this bus.
+	 */
+	if ((ret = max6602_get_value(this_client, &temp, MAX6602_TEMP_BASE)) < 0) {
+		kfree(this_client);
+		this_client = NULL;
+		return ret;
+	}
+
+	info("Found MAX6602 on %s\n", adap->name);
+	printk("XLS Chip temperature is %d degrees Celsius\n", temp);
+
+	/* attach it. */
+	return i2c_attach_client(this_client);
+}
+
+static int
+max6602_detach(struct i2c_client *client)
+{
+	i2c_detach_client(client);
+
+	if (this_client != NULL) {
+		kfree(this_client);
+		this_client = NULL;
+	}
+
+	return 0;
+}
+
+static int
+temp_open(struct inode *minode, struct file *mfile)
+{
+	/*if(MOD_IN_USE) */
+	if (max6602_use_count > 0) {
+		return -EBUSY;
+	}
+/* 	MOD_INC_USE_COUNT; */
+	++max6602_use_count;
+	return 0;
+}
+
+static int
+temp_release(struct inode *minode, struct file *mfile)
+{
+/* 	MOD_DEC_USE_COUNT; */
+	--max6602_use_count;
+	return 0;
+}
+
+
+static int
+max6602_command(struct i2c_client *client, unsigned int cmd, void *arg)
+{
+	return -EINVAL;
+}
+
+static int
+temp_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+		unsigned long arg)
+{
+	return -EINVAL;
+}
+
+static struct i2c_driver max6602_driver = {
+	.id		= XLS_I2C_DRIVERID_MAX6602,
+	.driver = {
+		.name   = "max6602",
+	},
+	.attach_adapter = max6602_probe,
+	.detach_client	= max6602_detach,
+	.command	= max6602_command
+};
+
+static struct file_operations temp_fops = {
+	.owner 		= THIS_MODULE,
+	.ioctl 		= temp_ioctl,
+	.open 		= temp_open,
+	.release 	= temp_release,
+};
+
+static struct miscdevice max6602_miscdev = {
+	TEMP_MINOR,
+	"max6602",
+	&temp_fops
+};
+
+static int __init max6602_init(void)
+{
+	int ret;
+	extern int xlr_noi2c;
+
+	/* LTE boards have max6602 chips - other boards have max6657 */
+	if(!xlr_board_atx_viii() || xlr_noi2c)
+		return 0;
+
+	printk("Registering XLS I2C based Temperature Sensor driver...\n");
+	ret = i2c_add_driver(&max6602_driver);
+	if (ret) {
+		printk("Unable to register XLS temperaturn sensor driver!\n");
+		return ret;		
+	}	
+
+	ret = misc_register(&max6602_miscdev);
+	if (ret) {
+		err("Register misc driver failed, errno is %d\n", ret);
+		i2c_del_driver(&max6602_driver);
+		return ret;
+	}
+
+	create_proc_read_entry("max6602", 0, rmi_root_proc, temp_read_proc, NULL);
+
+	return 0;
+}
+
+static void __exit max6602_exit(void)
+{
+	remove_proc_entry("max6602", rmi_root_proc);
+	misc_deregister(&max6602_miscdev);
+	i2c_del_driver(&max6602_driver);
+}
+
+
+module_init(max6602_init);
+module_exit(max6602_exit);
+
+/*
+ * Info exported via "/proc/driver/max6602".
+ */
+
+static int
+temp_proc_output(char *buf)
+{
+	char *p;
+	unsigned char temp, temp1, temp2, temp3, temp4;
+	int ret;
+
+	/* Local temp */
+	if ((ret = max6602_get_value(this_client, &temp, MAX6602_TEMP_BASE)) < 0)
+		return ret;
+
+	/* Remote 1 */
+	if ((ret = max6602_get_value(this_client, &temp1, 1)) < 0)
+		return ret;
+
+	/* Remote 2 */
+	if ((ret = max6602_get_value(this_client, &temp2, 2)) < 0)
+		return ret;
+
+	/* Remote 3 */
+	if ((ret = max6602_get_value(this_client, &temp3, 3)) < 0)
+		return ret;
+
+	/* Remote 4 */
+	if ((ret = max6602_get_value(this_client, &temp4, 4)) < 0)
+		return ret;
+
+	p = buf;
+	/*
+	 * There is no way to tell if the luser has the TEMP set for local
+	 * time or for Universal Standard Time (GMT). Probably local though.
+	 */
+	p += sprintf(p, "temperature: %dC %dC %dC %dC %dC\n", 
+				temp, temp1, temp2, temp3, temp4);
+	return p - buf;
+}
+
+static int
+temp_read_proc(char *page, char **start, off_t off,
+		int count, int *eof, void *data)
+{
+	int len = temp_proc_output(page);
+	if (len <= off + count)
+		*eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len > count)
+		len = count;
+	if (len < 0)
+		len = 0;
+	return len;
+}
+
+MODULE_AUTHOR("RMI");
+MODULE_DESCRIPTION("Maxim max6602 Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/i2c/chips/max6657.c b/drivers/i2c/chips/max6657.c
new file mode 100644
index 0000000..67a6db1
--- /dev/null
+++ b/drivers/i2c/chips/max6657.c
@@ -0,0 +1,307 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+/*
+ * linux/drivers/i2c/chips/max6657.c
+ *
+ * based on drivers/char/x1226-rtc.c
+ * Steve Longerbeam <stevel@mvista.com, or source@mvista.com>
+ * 2002-2003 (c) MontaVista Software, Inc.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/miscdevice.h>
+#include <linux/fcntl.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/time.h>
+
+#include <asm/rmi/sim.h>
+
+/* #define 	DEBUG_MAX6657 */
+
+
+#ifdef DEBUG_MAX6657		
+#define dbg(fmt, args...) 	printk(KERN_DEBUG "%s: " fmt, __func__, ## args)
+#else
+#define dbg(fmt, args...)
+#endif
+
+#define err(format, arg...) 	printk(KERN_ERR ": " format , ## arg)
+#define info(format, arg...) 	printk(KERN_INFO ": " format , ## arg)
+
+#define DEVID_TEMP    	   	0x4c
+#define MAX6657_TEMP_BASE    	0x00
+#define PHOENIX_I2C_DRIVERID_MAX6657   	0x01
+
+static struct 	i2c_driver max6657_driver;
+static struct 	i2c_client *this_client = NULL;
+static int 	max6657_use_count = 0;
+static int 	temp_read_proc(char *page, char **start, off_t off, int count, 
+		int *eof, void *data);
+extern struct proc_dir_entry *rmi_root_proc;
+
+static int
+max6657_read(struct i2c_client *client, u16 offset, u8 * buf, int len)
+{
+	int ret;
+	struct i2c_msg temp_read[1] = {
+		{
+			client->addr,			/* 0x4c */
+			client->flags | I2C_M_RD,	/* I2C Read Command */
+			offset,
+			len,				/* Need 4 Bytes */
+			buf				/* Store the result here */
+		}
+	};
+
+	if ((ret = i2c_transfer(client->adapter, temp_read, 1)) != 1) {
+		err("i2c_transfer failed, ret=%d\n", ret);
+		ret = -ENXIO;
+	}
+
+	return ret;
+}
+
+static int
+max6657_get_value(struct i2c_client *client, unsigned char *value, int offset)
+{
+	int ret;
+
+	if (!client) return -ENXIO;
+
+	/* read TEMP registers */
+	if ((ret = max6657_read(client, offset, value, sizeof (char))) < 0) {
+		dbg("couldn't read TEMP\n");
+		return ret;
+	}
+
+	dbg("IN: value=%0x\n", *value);
+
+	return 0;
+}
+
+
+static int max6657_probe(struct i2c_adapter *adap)
+{
+	int ret;
+	unsigned char temp;
+	if (this_client != NULL)
+		return -EBUSY;
+
+	this_client = kmalloc(sizeof (*this_client), GFP_KERNEL);
+	if (this_client == NULL) {
+		return -ENOMEM;
+	}
+
+	memset(this_client, 0, sizeof(*this_client));
+
+	strcpy(this_client->name, "MAX6657");
+/* 	this_client->id 	= max6657_driver.id; */
+	this_client->addr 	= DEVID_TEMP;
+	this_client->adapter 	= adap;
+	this_client->driver 	= &max6657_driver;
+	this_client->flags 	= 0;
+	/*
+	 * use max6657_get_value() to probe for a MAX6657 on this bus.
+	 */
+	if ((ret = max6657_get_value(this_client, &temp, MAX6657_TEMP_BASE+1)) < 0) {
+		kfree(this_client);
+		this_client = NULL;
+		return ret;
+	}
+
+	info("Found MAX6657 on %s\n", adap->name);
+	printk("Phoenix Chip temperature is %d degrees Celsius\n", temp);
+
+	/* attach it. */
+	return i2c_attach_client(this_client);
+}
+
+static int
+max6657_detach(struct i2c_client *client)
+{
+	i2c_detach_client(client);
+
+	if (this_client != NULL) {
+		kfree(this_client);
+		this_client = NULL;
+	}
+
+	return 0;
+}
+
+int
+temp_open(struct inode *minode, struct file *mfile)
+{
+	/*if(MOD_IN_USE) */
+	if (max6657_use_count > 0) {
+		return -EBUSY;
+	}
+/* 	MOD_INC_USE_COUNT; */
+	++max6657_use_count;
+	return 0;
+}
+
+int
+temp_release(struct inode *minode, struct file *mfile)
+{
+/* 	MOD_DEC_USE_COUNT; */
+	--max6657_use_count;
+	return 0;
+}
+
+
+static int
+max6657_command(struct i2c_client *client, unsigned int cmd, void *arg)
+{
+	return -EINVAL;
+}
+
+static int
+temp_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+		unsigned long arg)
+{
+	return -EINVAL;
+}
+
+static struct i2c_driver max6657_driver = {
+	.id		= PHOENIX_I2C_DRIVERID_MAX6657,
+	.driver = {
+		.name   = "max6657",
+	},
+	.attach_adapter = max6657_probe,
+	.detach_client	= max6657_detach,
+	.command	= max6657_command
+};
+
+static struct file_operations temp_fops = {
+	.owner 		= THIS_MODULE,
+	.ioctl 		= temp_ioctl,
+	.open 		= temp_open,
+	.release 	= temp_release,
+};
+
+static struct miscdevice max6657_miscdev = {
+	TEMP_MINOR,
+	"max6657",
+	&temp_fops
+};
+
+static int __init max6657_init(void)
+{
+	int ret;
+	extern int xlr_noi2c;
+
+	/* LTE boards have max6602 chips */
+	if(xlr_board_atx_viii() || xlr_noi2c)
+		return 0;
+
+	printk("Registering Phoenix I2C based Temperature Sensor driver...\n");
+	ret = i2c_add_driver(&max6657_driver);
+	if (ret) {
+		printk("Unable to register phoenix temperaturn sensor driver!\n");
+		return ret;		
+	}	
+
+	ret = misc_register(&max6657_miscdev);
+	if (ret) {
+		err("Register misc driver failed, errno is %d\n", ret);
+		i2c_del_driver(&max6657_driver);
+		return ret;
+	}
+
+	create_proc_read_entry("max6657", 0, rmi_root_proc, temp_read_proc, NULL);
+
+	return 0;
+}
+
+static void __exit max6657_exit(void)
+{
+	remove_proc_entry("max6657", rmi_root_proc);
+	misc_deregister(&max6657_miscdev);
+	i2c_del_driver(&max6657_driver);
+}
+
+
+module_init(max6657_init);
+module_exit(max6657_exit);
+
+/*
+ * Info exported via "/proc/driver/max6657".
+ */
+
+static int
+temp_proc_output(char *buf)
+{
+	char *p;
+	unsigned char temp;
+	int ret;
+
+	if ((ret = max6657_get_value(this_client, &temp, 1)) < 0)
+		return ret;
+
+	p = buf;
+	/*
+	 * There is no way to tell if the luser has the TEMP set for local
+	 * time or for Universal Standard Time (GMT). Probably local though.
+	 */
+	p += sprintf(p, "temperature: %d C\n", temp);
+	return p - buf;
+}
+
+static int
+temp_read_proc(char *page, char **start, off_t off,
+		int count, int *eof, void *data)
+{
+	int len = temp_proc_output(page);
+	if (len <= off + count)
+		*eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len > count)
+		len = count;
+	if (len < 0)
+		len = 0;
+	return len;
+}
+
+MODULE_AUTHOR("RMI");
+MODULE_DESCRIPTION("Maxim max6657 Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/i2c/i2c-core.c b/drivers/i2c/i2c-core.c
index 6b9d632..4dcd33c 100644
--- a/drivers/i2c/i2c-core.c
+++ b/drivers/i2c/i2c-core.c
@@ -401,6 +401,15 @@ static struct class i2c_adapter_class = {
 	.dev_attrs		= i2c_adapter_attrs,
 };
 
+#ifdef CONFIG_RMI_PHOENIX
+int xlr_noi2c;
+static int __init xlr_noi2c_setup(char *str)
+{
+	xlr_noi2c = 1;
+	return 1;
+}
+__setup("xlr_noi2c", xlr_noi2c_setup);
+#endif
 static void i2c_scan_static_board_info(struct i2c_adapter *adapter)
 {
 	struct i2c_devinfo	*devinfo;
@@ -422,6 +431,12 @@ static int i2c_do_add_adapter(struct device_driver *d, void *data)
 	struct i2c_driver *driver = to_i2c_driver(d);
 	struct i2c_adapter *adap = data;
 
+#ifdef CONFIG_RMI_PHOENIX
+	if (xlr_noi2c) {
+		printk("Skipped Adding I2C Adapter..\n");
+		return -ENODEV;
+	}
+#endif
 	/* Detect supported devices on that bus, and instantiate them */
 	i2c_detect(adap, driver);
 
@@ -1783,8 +1798,8 @@ static s32 i2c_smbus_xfer_emulated(struct i2c_adapter * adapter, u16 addr,
 	unsigned char msgbuf0[I2C_SMBUS_BLOCK_MAX+3];
 	unsigned char msgbuf1[I2C_SMBUS_BLOCK_MAX+2];
 	int num = read_write == I2C_SMBUS_READ?2:1;
-	struct i2c_msg msg[2] = { { addr, flags, 1, msgbuf0 },
-	                          { addr, flags | I2C_M_RD, 0, msgbuf1 }
+	struct i2c_msg msg[2] = { { addr, flags, 1, 1, msgbuf0 },
+	                          { addr, flags | I2C_M_RD, 1, 0, msgbuf1 }
 	                        };
 	int i;
 	u8 partial_pec = 0;
diff --git a/include/linux/i2c-algo-palm.h b/include/linux/i2c-algo-palm.h
new file mode 100644
index 0000000..8c29ce4
--- /dev/null
+++ b/include/linux/i2c-algo-palm.h
@@ -0,0 +1,53 @@
+
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+/*
+ *  i2c-algo-palm.c i2c driver algorithms for the BK3220 I2C Host 
+ *  adapter on the RMI Phoenix System.
+ *  Derived from the PCA-ISA I2C-Algo/Bus files.
+ */
+
+#ifndef _LINUX_I2C_ALGO_PALM_H
+#define _LINUX_I2C_ALGO_PALM_H
+
+#define WORD	1
+
+struct i2c_algo_palm_data {
+	void (*write)(int ctl, int val);
+	int  (*read) (int ctl);
+};
+
+#define I2C_PCA_ADAP_MAX	16
+
+int i2c_palm_add_bus(struct i2c_adapter *);
+int i2c_palm_del_bus(struct i2c_adapter *);
+
+#endif /* _LINUX_I2C_ALGO_PALM_H */
diff --git a/include/linux/i2c-id.h b/include/linux/i2c-id.h
index 3ae0f76..4a6b8ba 100644
--- a/include/linux/i2c-id.h
+++ b/include/linux/i2c-id.h
@@ -1,3 +1,15 @@
+/************************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc.(RMI).
+
+  This is a derived work from software originally provided by the external
+  entity identified below. The licensing terms and warranties specified in
+  the header of the original work apply to this derived work.
+
+  Contribution by RMI: 
+
+  *****************************#RMI_1#************************************/
+
 /* ------------------------------------------------------------------------- */
 /*									     */
 /* i2c-id.h - identifier values for i2c drivers and adapters		     */
@@ -98,6 +110,46 @@
 
 /*
  * ---- Adapter types ----------------------------------------------------
+ *
+ * First, we distinguish between several algorithms to access the hardware
+ * interface types, as a PCF 8584 needs other care than a bit adapter.
+ */
+
+#define I2C_ALGO_NONE	0x000000
+#define I2C_ALGO_BIT	0x010000	/* bit style adapters		*/
+#define I2C_ALGO_PCF	0x020000	/* PCF 8584 style adapters	*/
+#define I2C_ALGO_ATI	0x030000	/* ATI video card		*/
+#define I2C_ALGO_SMBUS	0x040000
+#define I2C_ALGO_ISA 	0x050000	/* lm_sensors ISA pseudo-adapter */
+#define I2C_ALGO_SAA7146 0x060000	/* SAA 7146 video decoder bus	*/
+#define I2C_ALGO_ACB 	0x070000	/* ACCESS.bus algorithm         */
+#define I2C_ALGO_IIC    0x080000 	/* ITE IIC bus */
+#define I2C_ALGO_SAA7134 0x090000
+#define I2C_ALGO_MPC824X 0x0a0000	/* Motorola 8240 / 8245         */
+#define I2C_ALGO_IPMI 	0x0b0000	/* IPMI dummy adapter */
+#define I2C_ALGO_IPMB 	0x0c0000	/* IPMB adapter */
+#define I2C_ALGO_MPC107 0x0d0000
+#define I2C_ALGO_EC     0x100000        /* ACPI embedded controller     */
+
+#define I2C_ALGO_MPC8XX 0x110000	/* MPC8xx PowerPC I2C algorithm */
+#define I2C_ALGO_OCP    0x120000	/* IBM or otherwise On-chip I2C algorithm */
+#define I2C_ALGO_BITHS	0x130000	/* enhanced bit style adapters	*/
+#define I2C_ALGO_OCP_IOP3XX  0x140000	/* XSCALE IOP3XX On-chip I2C alg */
+
+#define I2C_ALGO_SIBYTE 0x150000	/* Broadcom SiByte SOCs		*/
+#define I2C_ALGO_SGI	0x160000        /* SGI algorithm                */
+#define I2C_ALGO_PALM	0x170000        /* PalmChip algorithm           */
+
+#define I2C_ALGO_EXP	0x800000	/* experimental			*/
+
+#define I2C_ALGO_MASK	0xff0000	/* Mask for algorithms		*/
+#define I2C_ALGO_SHIFT	0x10	/* right shift to get index values 	*/
+
+#define I2C_HW_ADAPS	0x10000		/* # adapter types		*/
+#define I2C_HW_MASK	0xffff		
+
+
+/* hw specific modules that are defined per algorithm layer
  */
 
 /* --- Bit algorithm adapters						*/
@@ -176,4 +228,7 @@
 #define I2C_HW_SAA7146		0x060000 /* SAA7146 video decoder bus */
 #define I2C_HW_SAA7134		0x090000 /* SAA7134 video decoder bus */
 
+/* --- Palm Chip adapter */
+#define I2C_HW_PALM_BK3220 	0x00
+
 #endif /* LINUX_I2C_ID_H */
diff --git a/include/linux/i2c.h b/include/linux/i2c.h
index 0611512..5839be5 100644
--- a/include/linux/i2c.h
+++ b/include/linux/i2c.h
@@ -518,6 +518,9 @@ struct i2c_msg {
 #define I2C_M_IGNORE_NAK	0x1000	/* if I2C_FUNC_PROTOCOL_MANGLING */
 #define I2C_M_NO_RD_ACK		0x0800	/* if I2C_FUNC_PROTOCOL_MANGLING */
 #define I2C_M_RECV_LEN		0x0400	/* length will be first received byte */
+#ifdef CONFIG_RMI_PHOENIX
+	__u16 offset;
+#endif
 	__u16 len;		/* msg length				*/
 	__u8 *buf;		/* pointer to msg data			*/
 };
-- 
1.6.0.4

