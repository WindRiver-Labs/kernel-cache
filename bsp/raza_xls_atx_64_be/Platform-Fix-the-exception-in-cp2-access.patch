From 8d98edab688b816e97d790d2ab13bcd8bdf415a5 Mon Sep 17 00:00:00 2001
From: Liu Changhui <changhui.liu@windriver.com>
Date: Fri, 29 Jan 2010 13:27:39 +0800
Subject: [PATCH] Platform: Fix the exception in cp2 access

Executing CP2 instructions(MSGSND, MSGLD, MSDWAIT) will cause coprocessor
unusable exception if the CU2 bit of STATUS register is zero. Add related exception
handler to allow CP2 access in user and kernel space.

source: from RMI SDK1.7

Signed-off-by: shuo.kang <shuo.kang@windriver.com>
---
 arch/mips/kernel/traps.c |   53 +++++++++++++++++++++++++++++++++++++++------
 1 files changed, 46 insertions(+), 7 deletions(-)

diff --git a/arch/mips/kernel/traps.c b/arch/mips/kernel/traps.c
index 0648874..7c763ca 100644
--- a/arch/mips/kernel/traps.c
+++ b/arch/mips/kernel/traps.c
@@ -47,6 +47,7 @@
 #include <asm/mmu_context.h>
 #include <asm/types.h>
 #include <asm/stacktrace.h>
+#include <asm/war.h>
 
 extern void check_wait(void);
 extern asmlinkage void r4k_wait(void);
@@ -84,6 +85,21 @@ void (*board_nmi_handler_setup)(void);
 void (*board_ejtag_handler_setup)(void);
 void (*board_bind_eic_interrupt)(int irq, int regset);
 
+extern unsigned long phnx_ebase;
+
+static inline int rmi_xls_war(void)
+{
+	return RMI_XLS_WAR;
+}
+
+static inline int rmi_xls_32bit(void)
+{
+#if defined(CONFIG_RMI_PHOENIX) && defined(CONFIG_32BIT)
+	return 1;
+#else
+	return 0;
+#endif
+}
 
 static void show_raw_backtrace(unsigned long reg29)
 {
@@ -912,6 +928,16 @@ asmlinkage void do_cpu(struct pt_regs *regs)
 		return;
 
 	case 2:
+		if (rmi_xls_war()) {
+			extern __u64 xlr_cp2_exceptions[];
+			preempt_disable();
+			set_c0_status(ST0_CU2);
+			KSTK_STATUS(current) |= ST0_CU2;
+			/* increment the cp2 exception stats */
+			xlr_cp2_exceptions[smp_processor_id()]++;
+			preempt_enable();
+			return;
+   	}
 	case 3:
 		break;
 	}
@@ -1447,6 +1473,13 @@ void __cpuinit per_cpu_trap_init(void)
 		secondaryTC = 1;
 #endif /* CONFIG_MIPS_MT_SMTC */
 
+	if (rmi_xls_32bit()) {
+		/* Some firmware leaves the BEV flag set, clear it. */
+		clear_c0_status(ST0_CU1|ST0_CU2|ST0_CU3|ST0_BEV|ST0_KX);
+	}else {
+		clear_c0_status(ST0_CU1|ST0_CU2|ST0_CU3|ST0_BEV);
+	}
+
 	/*
 	 * Disable coprocessors and select 32-bit or 64-bit addressing
 	 * and the 16/32 or 32/32 FPR register model.  Reset the BEV
@@ -1592,6 +1625,10 @@ void __init trap_init(void)
 	else
 		ebase = CAC_BASE;
 
+	if (rmi_xls_war()){
+		ebase = phnx_ebase;
+	}
+
 	per_cpu_trap_init();
 
 	/*
@@ -1696,13 +1733,15 @@ void __init trap_init(void)
 
 	set_except_vector(26, handle_dsp);
 
-	if (cpu_has_vce)
-		/* Special exception: R4[04]00 uses also the divec space. */
-		memcpy((void *)(CAC_BASE + 0x180), &except_vec3_r4000, 0x100);
-	else if (cpu_has_4kex)
-		memcpy((void *)(CAC_BASE + 0x180), &except_vec3_generic, 0x80);
-	else
-		memcpy((void *)(CAC_BASE + 0x080), &except_vec3_generic, 0x80);
+	if (!rmi_xls_war()) {
+		if (cpu_has_vce)
+			/* Special exception: R4[04]00 uses also the divec space. */
+			memcpy((void *)(CAC_BASE + 0x180), &except_vec3_r4000, 0x100);
+		else if (cpu_has_4kex)
+			memcpy((void *)(CAC_BASE + 0x180), &except_vec3_generic, 0x80);
+		else
+			memcpy((void *)(CAC_BASE + 0x080), &except_vec3_generic, 0x80);
+	}
 
 	signal_init();
 #ifdef CONFIG_MIPS32_COMPAT
-- 
1.6.0.4

