From 93512c21014d3c258c20b55561c36ac2c9373240 Mon Sep 17 00:00:00 2001
From: Liu Changhui <changhui.liu@windriver.com>
Date: Fri, 29 Jan 2010 13:27:43 +0800
Subject: [PATCH] Platform: Add cache error handler for rmi xls

On RMI XLS, cache error is not only caused by cache ecc/parity checking
but also come from bridge's error reporting. Something like misconfigured
 BARS or accessing to a physical address region that is not mapped to any
device in the bridge are all reported as cache errors by bridge.

source: from RMI SDK1.7

Signed-off-by: shuo.kang <shuo.kang@windriver.com>
---
 arch/mips/mm/cerr-phoenix.c |  175 +++++++++++++++++++++++++++++++++++++++++++
 arch/mips/mm/cex-gen.S      |   27 +++++++
 2 files changed, 202 insertions(+), 0 deletions(-)
 create mode 100644 arch/mips/mm/cerr-phoenix.c

diff --git a/arch/mips/mm/cerr-phoenix.c b/arch/mips/mm/cerr-phoenix.c
new file mode 100644
index 0000000..687c119
--- /dev/null
+++ b/arch/mips/mm/cerr-phoenix.c
@@ -0,0 +1,175 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#include <linux/smp.h>
+#include <asm/system.h>
+
+#include <asm/rmi/iomap.h>
+
+unsigned char xlr_cerr_stack[8192];
+
+/* generic MIPS cache error handler */
+extern void cache_parity_error(void);
+
+static __inline__ void cerr_cpu_halt(void)
+{
+	for (;;) {
+		__asm__ __volatile__(".set mips64\n"
+				     "1: wait \n" "   b 1b\n" "   nop\n");
+	}
+}
+
+#define UART_RHR 0
+#define UART_THR 0
+#define UART_IER 1
+#define UART_IIR 2
+#define UART_FCR 2
+#define UART_LCR 3
+#define UART_MCR 4
+#define UART_LSR 5
+#define UART_MSR 6
+static void xlr_cerr_outbyte(char ch)
+{
+	volatile uint32_t *mmio =
+	    phoenix_io_mmio(PHOENIX_IO_UART_0_OFFSET);
+	int lsr;
+	for (;;) {
+
+		lsr = be32_to_cpu(mmio[UART_LSR]);
+
+		/* Tx Fifo empty */
+		if (lsr & 0x20) {
+			mmio[UART_THR] = cpu_to_be32((int) ch);
+			break;
+		}
+	}
+}
+
+volatile int xlr_cerr_lock;
+static char cerr_printk_buf[1024];
+static void xlr_cerr_printk(const char *fmt, ...)
+{
+	va_list args;
+	int len;
+	int i = 0;
+
+	va_start(args, fmt);
+	len =
+	    vsnprintf(cerr_printk_buf, sizeof(cerr_printk_buf), fmt, args);
+	va_end(args);
+
+	for (i = 0; i <= len; i++) {
+		if (cerr_printk_buf[i] == 0)
+			continue;
+		if (cerr_printk_buf[i] == '\n')
+			xlr_cerr_outbyte('\r');
+		xlr_cerr_outbyte(cerr_printk_buf[i]);
+	}
+
+}
+
+
+static char *bridge_aerr_intr_devstat[] = {
+	[0] = "cpu 0",
+	[1] = "cpu 1",
+	[2] = "cpu 2",
+	[3] = "cpu 3",
+	[4] = "cpu 4",
+	[5] = "cpu 5",
+	[6] = "cpu 6",
+	[7] = "cpu 7",
+
+	[8] = "L2",
+	[9] = "XGS 0",
+	[10] = "XGS 1",
+	[11] = "GMAC",
+	[12] = "SEC",
+	[13] = "PCIX",
+	[14] = "HT",
+	[15] = "DMA",
+};
+
+/* On Phoenix, errors reported by bridge (like misconfigured BARS etc) are also
+ * reported as cache errors. Need to check if it is really a cache error or a "bus error"
+ * and take action appropriately.
+ * For now, treat it as a cache error 
+ */
+asmlinkage void phoenix_cache_error(struct pt_regs *regs)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_BRIDGE_OFFSET);
+	__u64 cerr_cpu_log = 0;
+	__u32 tmp = 0;
+	int i = 0;
+
+	/* TODO: cache error on xlr could also be because of access to a physical address region that is
+	 * not mapped to any device in the bridge
+	 * We should detect that condition by reading the bridge registers and if a process is doing
+	 * the access, the process should be SEGFAULTED. If kernel is doing it, all bets are off, so
+	 * we should dump the stack and die
+	 * For Now, just halt the cpu
+	 */
+	local_irq_disable();
+
+	/* let the first cpu in */
+	while (xlr_cerr_lock);
+	xlr_cerr_lock = 1;
+
+	xlr_cerr_printk("*********************************************\n");
+	xlr_cerr_printk("cpu_%d received a bus/cache error\n",
+			hard_smp_processor_id());
+	xlr_cerr_printk("*********************************************\n");
+
+	xlr_cerr_printk
+	    ("Bridge: Phys Addr = 0x%010llx, Device_AERR = 0x%08x\n",
+	     (((__u64) phoenix_read_reg(mmio, 39) << 5) |
+	      ((__u64) phoenix_read_reg(mmio, 40) << 37)),
+	     phoenix_read_reg(mmio, 41));
+	xlr_cerr_printk("Bridge: The devices reporting AERR are:\n");
+	tmp = phoenix_read_reg(mmio, 41);
+	for (i = 0; i < 16; i++) {
+		if (tmp & (1 << i))
+			xlr_cerr_printk("\t%s\n",
+					bridge_aerr_intr_devstat[i]);
+	}
+
+	cerr_cpu_log =
+	    read_64bit_phnx_ctrl_reg(CPU_BLOCKID_LSU, LSU_CERRLOG_REGID);
+	xlr_cerr_printk
+	    ("CPU: (XLR specific) Cache Error log = 0x%016llx, Phy Addr = 0x%010llx\n",
+	     cerr_cpu_log, ((cerr_cpu_log >> 10) & 0xffffffffffULL) << 3);
+
+	xlr_cerr_printk
+	    ("CPU: epc = 0x%lx, errorepc = 0x%lx, cacheerr = 0x%08x\n",
+	     read_c0_epc(), read_c0_errorepc(), read_c0_cacheerr());
+
+	xlr_cerr_printk("Can not handle bus/cache error - Halting cpu\n");
+
+	cerr_cpu_halt();
+}
diff --git a/arch/mips/mm/cex-gen.S b/arch/mips/mm/cex-gen.S
index e743622..91417ec 100644
--- a/arch/mips/mm/cex-gen.S
+++ b/arch/mips/mm/cex-gen.S
@@ -36,7 +36,34 @@
 	nop
 	nop
 	nop
+#ifdef CONFIG_RMI_PHOENIX
 
+	/* If some other cpu is already in the handler
+	 * just wait... */
+	PTR_LA	k0, xlr_cerr_lock
+1:	lw	k1, 0(k0)
+	bnez	k1, 1b
+	nop
+	
+	/* switch stack to a new one */
+	PTR_LA	sp, xlr_cerr_stack
+	li	k1, 8192 - 64
+	PTR_ADDU	sp, sp, k1
+	
+	/* set up first argument - pt_regs */
+	move	a0, sp
+	/* read the cache error log reg in the cpu */
+	li	k1, 0x309
+	/*mfcr	k0, k1*/
+	PTR	0x737a0018
+	move	a1, k0
+	
+    j phoenix_cache_error
+	nop
+	/* should never get here */
+
+#else
 	j	cache_parity_error
 	nop
+#endif
 	END(except_vec2_generic)
-- 
1.6.0.4

