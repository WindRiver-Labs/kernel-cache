From 9261896ee33c25af06ec883c6db15c13ae2064d0 Mon Sep 17 00:00:00 2001
From: Liu Changhui <changhui.liu@windriver.com>
Date: Fri, 29 Jan 2010 13:27:40 +0800
Subject: [PATCH] Platform: Add rmi xls timer suport

Add the driver for RMI XLS416 PIC timer support.

source: from RMI SDK1.7

Signed-off-by: shuo.kang <shuo.kang@windriver.com>
---
 arch/mips/rmi/phoenix/Makefile |    2 +-
 arch/mips/rmi/phoenix/time.c   |  235 ++++++++++++++++++++++++++++++++++++++++
 2 files changed, 236 insertions(+), 1 deletions(-)
 create mode 100644 arch/mips/rmi/phoenix/time.c

diff --git a/arch/mips/rmi/phoenix/Makefile b/arch/mips/rmi/phoenix/Makefile
index 6556922..15bc689 100644
--- a/arch/mips/rmi/phoenix/Makefile
+++ b/arch/mips/rmi/phoenix/Makefile
@@ -1,4 +1,4 @@
 EXTRA_CFLAGS := -Werror
-obj-y := irq.o
+obj-y := irq.o time.o
 
 EXTRA_AFLAGS := $(CFLAGS)
diff --git a/arch/mips/rmi/phoenix/time.c b/arch/mips/rmi/phoenix/time.c
new file mode 100644
index 0000000..b97a5b6
--- /dev/null
+++ b/arch/mips/rmi/phoenix/time.c
@@ -0,0 +1,235 @@
+/*********************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY RMI Corporation, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+
+#include <asm/irq.h>
+#include <asm/ptrace.h>
+#include <asm/addrspace.h>
+#include <asm/time.h>
+#include <asm/cpu.h>
+#include <asm/cpu-features.h>
+
+#include <linux/proc_fs.h>
+
+extern spinlock_t phnx_pic_lock;
+extern int rmik_get_free_running_timer(void);
+
+
+static unsigned long phoenix_timer_stats[NR_CPUS] ____cacheline_aligned;
+static unsigned long phoenix_timer_diff[NR_CPUS] ____cacheline_aligned;
+static unsigned long phoenix_timer_count[NR_CPUS] ____cacheline_aligned;
+static unsigned long phoenix_timer_epc[NR_CPUS] ____cacheline_aligned;
+static unsigned long phoenix_timer_cpu[NR_CPUS] ____cacheline_aligned;
+static int free_running_timer_id;
+
+#ifndef RMI_MAX_PIC_TIMERS
+#define RMI_MAX_PIC_TIMERS 8
+#endif
+
+#if defined(CONFIG_PERFCTR) && defined(CONFIG_OPROFILE)
+#error "Cannot enable both VPERF and OProfile at the same time"
+#endif
+
+#ifndef CONFIG_PHOENIX_MAC
+void phoenix_user_mac_update_time(void) { }
+void phoenix_user_mac_update_ktime(void) { }
+#else
+extern void phoenix_user_mac_update_time(void);
+extern void phoenix_user_mac_update_ktime(void);
+#endif
+ 
+extern struct irq_chip phnx_rsvd_pic;
+extern struct irqaction phnx_rsvd_action;
+
+
+void save_epc(unsigned long *epc)
+{
+	__asm__ __volatile__ (
+		      ".set push\n"
+		      ".set noreorder\n"
+		      "mfc0 %0, $14\n"
+		      ".set pop\n"
+		      : "=r" (*epc) );
+}
+#ifdef CONFIG_OPROFILE
+extern void phoenix_oprofile_int_handler(int irq, void * dev_id,
+		        struct pt_regs *regs);
+#endif
+void phoenix_timer_interrupt(struct pt_regs *regs, int irq)
+{
+	int cpu = smp_processor_id();
+#ifdef CONFIG_RMI_WATCHDOG
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+#endif
+	unsigned int    count;
+
+#ifdef CONFIG_RMI_WATCHDOG
+	/* ack the watchdog */
+	phoenix_write_reg(mmio, 0x0c, 1<<cpu_logical_map(cpu));
+#endif
+
+	if (irq != IRQ_TIMER) {
+		printk("cpu_%d: bad timer irq = %x\n", cpu, irq);
+		BUG();
+	}
+
+	count = read_c0_count();
+	{
+	        do_IRQ(irq);
+
+        	if (cpu == 0) {
+			phoenix_user_mac_update_time();
+			phoenix_user_mac_update_ktime();
+		}
+		phoenix_timer_stats[cpu]++;
+		phoenix_timer_diff[cpu]  = count - phoenix_timer_count[cpu];
+		phoenix_timer_count[cpu] = count;
+		save_epc(&phoenix_timer_epc[cpu]);
+		phoenix_timer_cpu[cpu] += irq;
+	}
+
+
+
+
+}
+
+// can't do floating in the kernel, so use 64 as an approximation 
+#define PIC_CLKS_PER_USEC 66 //(PIC_CLKS_PER_SEC / 1000000)
+#define PIC_CLKS_PER_TIMER_TICK (PIC_CLKS_PER_SEC / HZ)
+
+
+int rmi_get_free_running_timer(void)
+{
+	static int timer_id = 0;
+	if(timer_id >= RMI_MAX_PIC_TIMERS)
+		return -1;
+	return timer_id++;
+}
+
+
+/* PIC clock at 66Mhz takes more than 60 secs to come to 0 from max. So 32bit 
+   counter is sufficient
+   */
+#define PIC_FREE_RUNNING_TIMER_MAX_VAL 0xffffffff
+cycle_t xlr_hpt_read(void)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	uint32_t counter = 0;
+
+	counter = phoenix_read_reg(mmio, PIC_TIMER_0_COUNTER_0 + free_running_timer_id);
+
+	return (cycle_t)(PIC_FREE_RUNNING_TIMER_MAX_VAL - counter);
+}
+EXPORT_SYMBOL(xlr_hpt_read);
+
+int read_current_timer(unsigned long *timer_val)
+{
+	*timer_val = xlr_hpt_read();
+	return 0;
+}
+
+void phoenix_timer_setup(void)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	unsigned long flags = 0;
+	int timer_id;
+	spin_lock_irqsave(&phnx_pic_lock, flags);
+	timer_id = rmi_get_free_running_timer();
+	if(timer_id < 0) 
+		panic("Scheduler Timer allocation failed\n");
+
+	free_running_timer_id = timer_id;
+	phoenix_write_reg(mmio, PIC_TIMER_0_MAXVAL_0 + timer_id, 0xffffffff);
+	phoenix_write_reg(mmio, PIC_TIMER_0_MAXVAL_1 + timer_id, 0x0);
+	/* we Don't need interrupts */
+	pic_setup_threadmask(PIC_IRT_TIMER_0_INDEX + timer_id, 0);
+	phoenix_write_reg(mmio, PIC_IRT_1_TIMER_0 + timer_id, 
+			(1<<31)|(0<<30)|(1<<6)|(PIC_TIMER_0_IRQ + timer_id));
+	pic_update_control(1<<(8 + timer_id));
+
+	spin_unlock_irqrestore(&phnx_pic_lock, flags);
+
+	
+
+}
+
+static int rmi_timer_proc_read(char *page, char **start, off_t off, int count, int *eof,
+							  void *data) 
+{
+	int len = 0;
+
+	preempt_disable();
+	len += sprintf(page + len, "cpu = %d, eimr = 0x%016llx, status = 0x%x\n", 
+				   smp_processor_id(), 
+                   (unsigned long long)read_64bit_cp0_eimr(), read_c0_status());
+	preempt_enable();
+	*eof = 1;
+
+	return len;	
+}
+
+extern struct proc_dir_entry *rmi_root_proc;
+struct proc_dir_entry *main_entry;
+struct proc_dir_entry *sub_entry;
+
+static int init_pic_timer_procfs(void) 
+{
+	main_entry = proc_mkdir("rmi_timer", rmi_root_proc);
+	if (!main_entry) {
+		printk(KERN_ERR "unable to create /proc/rmi_timer\n");
+		return -ENOMEM;
+	}
+	
+
+	sub_entry = create_proc_entry("debug", 0644, main_entry);
+	
+	if (!sub_entry) {
+		remove_proc_entry("rmi_timer", rmi_root_proc);
+		return -ENOMEM;
+	}
+
+	sub_entry->read_proc = rmi_timer_proc_read;
+	sub_entry->owner = THIS_MODULE;
+
+	printk("created rmi_timer proc fs entry\n");
+
+	return 0;
+}
+static void exit_pic_timer_procfs(void)
+{
+	remove_proc_entry("debug", main_entry);
+	remove_proc_entry("rmi_timer", rmi_root_proc);
+}
+
+module_init(init_pic_timer_procfs);
+module_exit(exit_pic_timer_procfs);
-- 
1.6.0.4

