From 0088edbfd66dd084c660231da4a36c2b1791033a Mon Sep 17 00:00:00 2001
From: Liu Changhui <changhui.liu@windriver.com>
Date: Fri, 29 Jan 2010 13:28:05 +0800
Subject: [PATCH] CF Card: Add CF card support for rmi xls

Add CF card support for rmi xls.

source: from RMI SDK1.7

Signed-off-by: shuo.kang <shuo.kang@windriver.com>
---
 drivers/ide/Kconfig            |    5 +
 drivers/ide/ide-dma.c          |   58 ++++-
 drivers/ide/ide-iops.c         |   94 ++++++-
 drivers/ide/mips/Makefile      |    1 +
 drivers/ide/mips/phoenix_ide.c |  584 ++++++++++++++++++++++++++++++++++++++++
 5 files changed, 719 insertions(+), 23 deletions(-)
 create mode 100644 drivers/ide/mips/phoenix_ide.c

diff --git a/drivers/ide/Kconfig b/drivers/ide/Kconfig
index 052879a..7708d0a 100644
--- a/drivers/ide/Kconfig
+++ b/drivers/ide/Kconfig
@@ -783,6 +783,11 @@ config BLK_DEV_IDEDMA_PMAC
 config BLK_DEV_IDE_AU1XXX
        bool "IDE for AMD Alchemy Au1200"
        depends on SOC_AU1200
+
+config BLK_DEV_IDE_PHOENIX
+	bool "IDE for RMI XLR eval boards"
+	depends on RMI_PHOENIX 
+
 choice
        prompt "IDE Mode for AMD Alchemy Au1200"
        default CONFIG_BLK_DEV_IDE_AU1XXX_PIO_DBDMA
diff --git a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
index 3fa07c0..30c485c 100644
--- a/drivers/ide/ide-dma.c
+++ b/drivers/ide/ide-dma.c
@@ -43,6 +43,16 @@
 
 #include <asm/io.h>
 #include <asm/irq.h>
+#include <asm/war.h>
+
+static inline int rmi_xls_war(void)
+{
+	return RMI_XLS_WAR;
+}
+
+extern void rmi_ide_mm_outl (u32 value, unsigned long port);
+extern void rmi_ide_mm_outb (u8 value, unsigned long port);
+extern u8 rmi_ide_mm_inb (unsigned long port);
 
 static const struct drive_list_entry drive_whitelist [] = {
 
@@ -381,7 +391,11 @@ void ide_dma_host_set(ide_drive_t *drive, int on)
 		writeb(dma_stat,
 		       (void __iomem *)(hwif->dma_base + ATA_DMA_STATUS));
 	else
-		outb(dma_stat, hwif->dma_base + ATA_DMA_STATUS);
+		if (rmi_xls_war()) {
+		    rmi_ide_mm_outb(dma_stat, (hwif->dma_base + ATA_DMA_STATUS));
+        } else {
+		    outb(dma_stat, hwif->dma_base + ATA_DMA_STATUS);
+        }
 }
 
 EXPORT_SYMBOL_GPL(ide_dma_host_set);
@@ -473,13 +487,21 @@ int ide_dma_setup(ide_drive_t *drive)
 		writel(hwif->dmatable_dma,
 		       (void __iomem *)(hwif->dma_base + ATA_DMA_TABLE_OFS));
 	else
-		outl(hwif->dmatable_dma, hwif->dma_base + ATA_DMA_TABLE_OFS);
+		if (rmi_xls_war()) {
+		    rmi_ide_mm_outl(hwif->dmatable_dma, (hwif->dma_base + ATA_DMA_TABLE_OFS));
+		} else {
+		    outl(hwif->dmatable_dma, hwif->dma_base + ATA_DMA_TABLE_OFS);
+		}
 
 	/* specify r/w */
 	if (mmio)
 		writeb(reading, (void __iomem *)(hwif->dma_base + ATA_DMA_CMD));
 	else
-		outb(reading, hwif->dma_base + ATA_DMA_CMD);
+		if (rmi_xls_war()) {
+		    rmi_ide_mm_outb(reading, (hwif->dma_base + ATA_DMA_CMD));
+		} else {
+		    outb(reading, hwif->dma_base + ATA_DMA_CMD);
+		}
 
 	/* read DMA status for INTR & ERROR flags */
 	dma_stat = hwif->tp_ops->read_sff_dma_status(hwif);
@@ -489,7 +511,11 @@ int ide_dma_setup(ide_drive_t *drive)
 		writeb(dma_stat | 6,
 		       (void __iomem *)(hwif->dma_base + ATA_DMA_STATUS));
 	else
-		outb(dma_stat | 6, hwif->dma_base + ATA_DMA_STATUS);
+		if (rmi_xls_war()) {
+		    rmi_ide_mm_outb(dma_stat | 6,(hwif->dma_base + ATA_DMA_STATUS));
+		} else {
+		    outb(dma_stat | 6, hwif->dma_base + ATA_DMA_STATUS);
+		}
 
 	drive->waiting_for_dma = 1;
 	return 0;
@@ -520,8 +546,13 @@ void ide_dma_start(ide_drive_t *drive)
 		writeb(dma_cmd | 1,
 		       (void __iomem *)(hwif->dma_base + ATA_DMA_CMD));
 	} else {
-		dma_cmd = inb(hwif->dma_base + ATA_DMA_CMD);
-		outb(dma_cmd | 1, hwif->dma_base + ATA_DMA_CMD);
+		if (rmi_xls_war()) {
+		    dma_cmd = rmi_ide_mm_inb((hwif->dma_base + ATA_DMA_CMD));
+		    rmi_ide_mm_outb(dma_cmd | 1, (hwif->dma_base + ATA_DMA_CMD));
+		} else {
+		    dma_cmd = inb(hwif->dma_base + ATA_DMA_CMD);
+		    outb(dma_cmd | 1, hwif->dma_base + ATA_DMA_CMD);
+		}
 	}
 
 	hwif->dma = 1;
@@ -546,8 +577,13 @@ int __ide_dma_end (ide_drive_t *drive)
 		writeb(dma_cmd & ~1,
 		       (void __iomem *)(hwif->dma_base + ATA_DMA_CMD));
 	} else {
-		dma_cmd = inb(hwif->dma_base + ATA_DMA_CMD);
-		outb(dma_cmd & ~1, hwif->dma_base + ATA_DMA_CMD);
+		if (rmi_xls_war()) {
+		    dma_cmd = rmi_ide_mm_inb((hwif->dma_base + ATA_DMA_CMD));
+		    rmi_ide_mm_outb(dma_cmd & ~1, (hwif->dma_base + ATA_DMA_CMD));
+		} else {
+		    dma_cmd = inb(hwif->dma_base + ATA_DMA_CMD);
+		    outb(dma_cmd & ~1, hwif->dma_base + ATA_DMA_CMD);
+		}
 	}
 
 	/* get DMA status */
@@ -558,7 +594,11 @@ int __ide_dma_end (ide_drive_t *drive)
 		writeb(dma_stat | 6,
 		       (void __iomem *)(hwif->dma_base + ATA_DMA_STATUS));
 	else
-		outb(dma_stat | 6, hwif->dma_base + ATA_DMA_STATUS);
+		if (rmi_xls_war()) {
+		    rmi_ide_mm_outb(dma_stat | 6,(hwif->dma_base + ATA_DMA_STATUS));
+		} else {
+		    outb(dma_stat | 6, hwif->dma_base + ATA_DMA_STATUS);
+		}
 
 	/* purge DMA mappings */
 	ide_destroy_dmatable(drive);
diff --git a/drivers/ide/ide-iops.c b/drivers/ide/ide-iops.c
index 40fbf42..b37cfd6 100644
--- a/drivers/ide/ide-iops.c
+++ b/drivers/ide/ide-iops.c
@@ -27,19 +27,42 @@
 #include <asm/irq.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
+#include <asm/war.h>
+
+static inline int rmi_xls_war(void)
+{
+	return RMI_XLS_WAR;
+}
 
 /*
  *	Conventional PIO operations for ATA devices
  */
 
+#ifdef CONFIG_RMI_PHOENIX
+extern u8 rmi_ide_mm_inb (unsigned long port);              /* readb  */
+extern void rmi_ide_mm_outb (u8 value, unsigned long port); /* writeb */
+extern void rmi_ide_mm_insl(unsigned long port, void *addr, unsigned int count);
+extern void rmi_ide_mm_outsl(unsigned long port, void *addr,unsigned int count);
+extern void rmi_ide_mm_insw(unsigned long port, void *addr, u32 count);
+extern void rmi_ide_mm_outsw(unsigned long port, void *addr,unsigned int count);
+extern u16 rmi_ide_mm_inw (unsigned long port);
+extern void rmi_ide_mm_outw (u16 value, unsigned long port);
+#endif
+
 static u8 ide_inb (unsigned long port)
 {
-	return (u8) inb(port);
+	if (rmi_xls_war()) 
+		return (u8) rmi_ide_mm_inb(port);
+	else 
+		return (u8) inb(port);
 }
 
 static void ide_outb (u8 val, unsigned long port)
 {
-	outb(val, port);
+	if (rmi_xls_war())
+		rmi_ide_mm_outb(val, port);
+	else
+		outb(val, port);
 }
 
 /*
@@ -84,7 +107,10 @@ void ide_exec_command(ide_hwif_t *hwif, u8 cmd)
 	if (hwif->host_flags & IDE_HFLAG_MMIO)
 		writeb(cmd, (void __iomem *)hwif->io_ports.command_addr);
 	else
-		outb(cmd, hwif->io_ports.command_addr);
+		if (rmi_xls_war())
+			rmi_ide_mm_outb(cmd, hwif->io_ports.command_addr);
+		else
+			outb(cmd, hwif->io_ports.command_addr);
 }
 EXPORT_SYMBOL_GPL(ide_exec_command);
 
@@ -93,7 +119,10 @@ u8 ide_read_status(ide_hwif_t *hwif)
 	if (hwif->host_flags & IDE_HFLAG_MMIO)
 		return readb((void __iomem *)hwif->io_ports.status_addr);
 	else
-		return inb(hwif->io_ports.status_addr);
+		if (rmi_xls_war())
+			return rmi_ide_mm_inb(hwif->io_ports.status_addr);
+		else
+			return inb(hwif->io_ports.status_addr);
 }
 EXPORT_SYMBOL_GPL(ide_read_status);
 
@@ -102,7 +131,10 @@ u8 ide_read_altstatus(ide_hwif_t *hwif)
 	if (hwif->host_flags & IDE_HFLAG_MMIO)
 		return readb((void __iomem *)hwif->io_ports.ctl_addr);
 	else
-		return inb(hwif->io_ports.ctl_addr);
+		if (rmi_xls_war())
+			return rmi_ide_mm_inb(hwif->io_ports.ctl_addr);
+		else
+			return inb(hwif->io_ports.ctl_addr);
 }
 EXPORT_SYMBOL_GPL(ide_read_altstatus);
 
@@ -111,7 +143,10 @@ u8 ide_read_sff_dma_status(ide_hwif_t *hwif)
 	if (hwif->host_flags & IDE_HFLAG_MMIO)
 		return readb((void __iomem *)(hwif->dma_base + ATA_DMA_STATUS));
 	else
-		return inb(hwif->dma_base + ATA_DMA_STATUS);
+		if (rmi_xls_war())
+			return rmi_ide_mm_inb((hwif->dma_base + ATA_DMA_STATUS));
+		else
+			return inb(hwif->dma_base + ATA_DMA_STATUS);
 }
 EXPORT_SYMBOL_GPL(ide_read_sff_dma_status);
 
@@ -129,7 +164,10 @@ void ide_set_irq(ide_hwif_t *hwif, int on)
 	if (hwif->host_flags & IDE_HFLAG_MMIO)
 		writeb(ctl, (void __iomem *)hwif->io_ports.ctl_addr);
 	else
-		outb(ctl, hwif->io_ports.ctl_addr);
+		if (rmi_xls_war())
+		    rmi_ide_mm_outb(ctl, hwif->io_ports.ctl_addr);
+	    else
+		    outb(ctl, hwif->io_ports.ctl_addr);
 }
 EXPORT_SYMBOL_GPL(ide_set_irq);
 
@@ -156,7 +194,10 @@ void ide_tf_load(ide_drive_t *drive, ide_task_t *task)
 		if (mmio)
 			writew(data, (void __iomem *)io_ports->data_addr);
 		else
-			outw(data, io_ports->data_addr);
+			if (rmi_xls_war())
+				rmi_ide_mm_outw(data, io_ports->data_addr);
+			else
+				outw(data, io_ports->data_addr);
 	}
 
 	if (task->tf_flags & IDE_TFLAG_OUT_HOB_FEATURE)
@@ -210,7 +251,10 @@ void ide_tf_read(ide_drive_t *drive, ide_task_t *task)
 		if (mmio)
 			data = readw((void __iomem *)io_ports->data_addr);
 		else
-			data = inw(io_ports->data_addr);
+			if (rmi_xls_war())
+				data = rmi_ide_mm_inw(io_ports->data_addr);
+			else
+				data = inw(io_ports->data_addr);
 
 		tf->data = data & 0xff;
 		tf->hob_data = (data >> 8) & 0xff;
@@ -292,7 +336,10 @@ void ide_input_data(ide_drive_t *drive, struct request *rq, void *buf,
 		if (mmio)
 			__ide_mm_insl((void __iomem *)data_addr, buf, len / 4);
 		else
-			insl(data_addr, buf, len / 4);
+			if (rmi_xls_war())
+				rmi_ide_mm_insl(data_addr, buf, len / 4);
+			else
+				insl(data_addr, buf, len / 4);
 
 		if ((io_32bit & 2) && !mmio)
 			local_irq_restore(flags);
@@ -302,13 +349,21 @@ void ide_input_data(ide_drive_t *drive, struct request *rq, void *buf,
 				__ide_mm_insw((void __iomem *)data_addr,
 						(u8 *)buf + (len & ~3), 1);
 			else
-				insw(data_addr, (u8 *)buf + (len & ~3), 1);
+				if (rmi_xls_war()) {
+					rmi_ide_mm_insw(data_addr,
+						(u8 *)buf + (len & ~3), 1);
+				} else {
+					insw(data_addr, (u8 *)buf + (len & ~3), 1);
+				}
 		}
 	} else {
 		if (mmio)
 			__ide_mm_insw((void __iomem *)data_addr, buf, len / 2);
 		else
-			insw(data_addr, buf, len / 2);
+			if (rmi_xls_war())
+				rmi_ide_mm_insw(data_addr, buf, len / 2);
+		    else
+				insw(data_addr, buf, len / 2);
 	}
 }
 EXPORT_SYMBOL_GPL(ide_input_data);
@@ -338,6 +393,9 @@ void ide_output_data(ide_drive_t *drive, struct request *rq, void *buf,
 		if (mmio)
 			__ide_mm_outsl((void __iomem *)data_addr, buf, len / 4);
 		else
+			if (rmi_xls_war())
+			rmi_ide_mm_outsl(data_addr, buf, len / 4);
+		    else
 			outsl(data_addr, buf, len / 4);
 
 		if ((io_32bit & 2) && !mmio)
@@ -348,13 +406,21 @@ void ide_output_data(ide_drive_t *drive, struct request *rq, void *buf,
 				__ide_mm_outsw((void __iomem *)data_addr,
 						 (u8 *)buf + (len & ~3), 1);
 			else
-				outsw(data_addr, (u8 *)buf + (len & ~3), 1);
+				if (rmi_xls_war()) {
+					rmi_ide_mm_outsw(data_addr,
+						 (u8 *)buf + (len & ~3), 1);
+				} else {
+					outsw(data_addr, (u8 *)buf + (len & ~3), 1);
+				}
 		}
 	} else {
 		if (mmio)
 			__ide_mm_outsw((void __iomem *)data_addr, buf, len / 2);
 		else
-			outsw(data_addr, buf, len / 2);
+			if (rmi_xls_war())
+				rmi_ide_mm_outsw(data_addr, buf, len / 2);
+			else
+				outsw(data_addr, buf, len / 2);
 	}
 }
 EXPORT_SYMBOL_GPL(ide_output_data);
diff --git a/drivers/ide/mips/Makefile b/drivers/ide/mips/Makefile
index 5873fa0..9f8c814 100644
--- a/drivers/ide/mips/Makefile
+++ b/drivers/ide/mips/Makefile
@@ -1,3 +1,4 @@
+obj-$(CONFIG_BLK_DEV_IDE_PHOENIX)	+= phoenix_ide.o
 obj-$(CONFIG_BLK_DEV_IDE_AU1XXX)	+= au1xxx-ide.o
 
 EXTRA_CFLAGS    := -Idrivers/ide
diff --git a/drivers/ide/mips/phoenix_ide.c b/drivers/ide/mips/phoenix_ide.c
new file mode 100644
index 0000000..16af015
--- /dev/null
+++ b/drivers/ide/mips/phoenix_ide.c
@@ -0,0 +1,584 @@
+/************************************************************************
+
+  Copyright 2003-2006 RMI Corporation, Inc.(RMI).
+
+  This is a derived work from software originally provided by the external
+  entity identified below. The licensing terms and warranties specified in
+  the header of the original work apply to this derived work.
+
+  Contribution by RMI: Support for XLR's on-chip PCMCIA interface...
+
+  *****************************#RMI_1#************************************/
+
+/*  Derived loosely from ide-pmac.c, so:
+ *  
+ *  Copyright (C) 1998 Paul Mackerras.
+ *  Copyright (C) 1995-1998 Mark Lord
+ */
+
+/*
+ * Boards with phoenix processors so far have supported IDE devices via
+ * the Generic Bus, PCI bus, and built-in PCMCIA interface.  In all
+ * cases, byte-swapping must be avoided for these devices (whereas
+ * other PCI devices, for example, will require swapping).  Any
+ * phoenix-targetted kernel including IDE support will include this
+ * file.  Probing of a Generic Bus for an IDE device is controlled by
+ * the definitions of "PHOENIX_HAVE_IDE" and "IDE_PHYS", which are
+ * provided by <asm/rmi/phoenix_ide.h> for ATX1 boards.
+ */
+
+#include <linux/kernel.h>
+#include <linux/ide.h>
+#include <linux/platform_device.h>
+#include <asm/rmi/phoenix_ide.h>
+#include <asm/rmi/64bit.h>
+#include <asm/rmi/pic.h>
+#include <asm/rmi/iomap.h>
+#include <asm/rmi/sim.h>
+
+/* #define DEBUG_PORT  */
+
+#define GPIO_INTR_CLR_REG    0x1EF19180
+#define PCMCIA_CONFIG_REG    0x1EF19140
+
+/*
+ * Our non-swapping I/O operations.  
+ */
+static inline void phoenix_outb(u8 val, unsigned long port) 
+{
+	unsigned int flags=0;
+#ifdef DEBUG_PORT
+	printk(" %s port = %x %x \n", __FUNCTION__, (mips_io_port_base + port),val);
+#endif
+
+	flags = rmi_br_write_lock();
+	*(volatile u8 *)(mips_io_port_base + (port)) = val;
+	rmi_br_write_unlock(flags);
+}
+
+static inline void phoenix_outw(u16 val, unsigned long port) 
+{
+	unsigned int flags=0;
+#ifdef DEBUG_PORT
+	printk("%s  port = %x  %x\n",__FUNCTION__,  (mips_io_port_base + port),val);
+#endif
+	flags = rmi_br_write_lock();
+	*(volatile u16 *)(mips_io_port_base + (port)) = val;
+	rmi_br_write_unlock(flags);
+}
+
+static inline void phoenix_outl(u32 val, unsigned long port) 
+{
+	unsigned int flags=0;
+#ifdef DEBUG_PORT
+	printk("%s  port = %x %x\n",__FUNCTION__,  (mips_io_port_base + port),val);
+#endif
+	flags = rmi_br_write_lock();
+	*(volatile u32 *)(mips_io_port_base + (port)) = val;
+	rmi_br_write_unlock(flags);
+}
+
+static inline unsigned char phoenix_inb(unsigned long port)
+{
+	unsigned int flags=0;
+	unsigned char val ;
+
+	flags = rmi_br_read_lock();
+	val =  (*(volatile u8 *)(mips_io_port_base + (port)));
+	rmi_br_read_unlock(flags);
+#ifdef DEBUG_PORT
+	printk("%s  port = %x %x \n",__FUNCTION__,  (mips_io_port_base + port),val );
+#endif
+	return val;
+}
+
+static inline unsigned short phoenix_inw(unsigned long port)
+{
+	unsigned int flags=0;
+	unsigned short val ;
+	flags = rmi_br_read_lock();
+	val = (*(volatile u16 *)(mips_io_port_base + (port)));
+	rmi_br_read_unlock(flags);
+#ifdef DEBUG_PORT
+	printk("%s  port = %x %x \n",__FUNCTION__,  (mips_io_port_base + port),val );
+#endif
+	return val;
+}
+
+static inline unsigned int phoenix_inl(unsigned long port)
+{
+	unsigned int flags=0;
+	unsigned int val ;
+	flags = rmi_br_read_lock();
+	val =  (*(volatile u32 *)(mips_io_port_base + (port)));
+	rmi_br_read_unlock(flags);
+#ifdef DEBUG_PORT
+	printk("%s  port = %x %x \n",__FUNCTION__,  (mips_io_port_base + port),val );
+#endif
+	return val;
+}
+
+static inline void phoenix_outsb(unsigned long port, void *addr, unsigned int count)
+{
+	while (count--) {
+		phoenix_outb(*(u8 *)addr, port);
+		addr++;
+	}
+}
+
+static inline void phoenix_insb(unsigned long port, void *addr, unsigned int count)
+{
+	while (count--) {
+		*(u8 *)addr = phoenix_inb(port);
+		addr++;
+	}
+}
+
+static inline void phoenix_outsw(unsigned long port, void *addr, unsigned int count)
+{
+	while (count--) {
+		phoenix_outw(*(u16 *)addr, port);
+		addr += 2;
+	}
+}
+
+static inline void phoenix_insw(unsigned long port, void *addr, unsigned int count)
+{
+	while (count--) {
+		*(u16 *)addr = phoenix_inw(port);
+		addr += 2;
+	}
+}
+
+static inline void phoenix_outsl(unsigned long port, void *addr, unsigned int count)
+{
+	while (count--) {
+		phoenix_outl(*(u32 *)addr, port);
+		addr += 4;
+	}
+}
+
+static inline void phoenix_insl(unsigned long port, void *addr, unsigned int count)
+{
+	while (count--) {
+		*(u32 *)addr = phoenix_inl(port);
+		addr += 4;
+	}
+}
+
+
+/* Note:
+   Following functions are taken from drivers/ide/ide-iops.c
+   unmodified, as required for PCMCIA.
+   The original functions in drivers/ide/ide-iops.c have been modified so 
+   that PCI devices work properly
+   */
+
+/*
+ *	Conventional PIO operations for ATA devices
+ */
+static u8 ide_inb (unsigned long port)
+{
+	return (u8) inb(port);
+}
+
+static void ide_outb (u8 val, unsigned long port)
+{
+	outb(val, port);
+}
+
+/*
+ *	MMIO operations, typically used for SATA controllers
+ */
+static u8 ide_mm_inb (unsigned long port)
+{
+	return (u8) readb((void __iomem *) port);
+}
+
+static void ide_mm_outb (u8 value, unsigned long port)
+{
+	writeb(value, (void __iomem *) port);
+}
+
+static void phoenix_ide_exec_command(ide_hwif_t *hwif, u8 cmd)
+{
+	if (hwif->host_flags & IDE_HFLAG_MMIO)
+		writeb(cmd, (void __iomem *)hwif->io_ports.command_addr);
+	else
+		outb(cmd, hwif->io_ports.command_addr);
+}
+
+static u8 phoenix_ide_read_status(ide_hwif_t *hwif)
+{
+	if (hwif->host_flags & IDE_HFLAG_MMIO)
+		return readb((void __iomem *)hwif->io_ports.status_addr);
+	else
+		return inb(hwif->io_ports.status_addr);
+}
+
+static u8 phoenix_ide_read_altstatus(ide_hwif_t *hwif)
+{
+	if (hwif->host_flags & IDE_HFLAG_MMIO)
+		return readb((void __iomem *)hwif->io_ports.ctl_addr);
+	else
+		return inb(hwif->io_ports.ctl_addr);
+}
+
+static u8 phoenix_ide_read_sff_dma_status(ide_hwif_t *hwif)
+{
+	if (hwif->host_flags & IDE_HFLAG_MMIO)
+		return readb((void __iomem *)(hwif->dma_base + ATA_DMA_STATUS));
+	else
+		return inb(hwif->dma_base + ATA_DMA_STATUS);
+}
+
+static void phoenix_ide_set_irq(ide_hwif_t *hwif, int on)
+{
+	u8 ctl = ATA_DEVCTL_OBS;
+
+	if (on == 4) { /* hack for SRST */
+		ctl |= 4;
+		on &= ~4;
+	}
+
+	ctl |= on ? 0 : 2;
+
+	if (hwif->host_flags & IDE_HFLAG_MMIO)
+		writeb(ctl, (void __iomem *)hwif->io_ports.ctl_addr);
+	else
+		outb(ctl, hwif->io_ports.ctl_addr);
+}
+
+static void phoenix_ide_tf_load(ide_drive_t *drive, ide_task_t *task)
+{
+	ide_hwif_t *hwif = drive->hwif;
+	struct ide_io_ports *io_ports = &hwif->io_ports;
+	struct ide_taskfile *tf = &task->tf;
+	void (*tf_outb)(u8 addr, unsigned long port);
+	u8 mmio = (hwif->host_flags & IDE_HFLAG_MMIO) ? 1 : 0;
+	u8 HIHI = (task->tf_flags & IDE_TFLAG_LBA48) ? 0xE0 : 0xEF;
+
+	if (mmio)
+		tf_outb = ide_mm_outb;
+	else
+		tf_outb = ide_outb;
+
+	if (task->tf_flags & IDE_TFLAG_FLAGGED)
+		HIHI = 0xFF;
+
+	if (task->tf_flags & IDE_TFLAG_OUT_DATA) {
+		u16 data = (tf->hob_data << 8) | tf->data;
+
+		if (mmio)
+			writew(data, (void __iomem *)io_ports->data_addr);
+		else
+			outw(data, io_ports->data_addr);
+	}
+
+	if (task->tf_flags & IDE_TFLAG_OUT_HOB_FEATURE)
+		tf_outb(tf->hob_feature, io_ports->feature_addr);
+	if (task->tf_flags & IDE_TFLAG_OUT_HOB_NSECT)
+		tf_outb(tf->hob_nsect, io_ports->nsect_addr);
+	if (task->tf_flags & IDE_TFLAG_OUT_HOB_LBAL)
+		tf_outb(tf->hob_lbal, io_ports->lbal_addr);
+	if (task->tf_flags & IDE_TFLAG_OUT_HOB_LBAM)
+		tf_outb(tf->hob_lbam, io_ports->lbam_addr);
+	if (task->tf_flags & IDE_TFLAG_OUT_HOB_LBAH)
+		tf_outb(tf->hob_lbah, io_ports->lbah_addr);
+
+	if (task->tf_flags & IDE_TFLAG_OUT_FEATURE)
+		tf_outb(tf->feature, io_ports->feature_addr);
+	if (task->tf_flags & IDE_TFLAG_OUT_NSECT)
+		tf_outb(tf->nsect, io_ports->nsect_addr);
+	if (task->tf_flags & IDE_TFLAG_OUT_LBAL)
+		tf_outb(tf->lbal, io_ports->lbal_addr);
+	if (task->tf_flags & IDE_TFLAG_OUT_LBAM)
+		tf_outb(tf->lbam, io_ports->lbam_addr);
+	if (task->tf_flags & IDE_TFLAG_OUT_LBAH)
+		tf_outb(tf->lbah, io_ports->lbah_addr);
+
+	if (task->tf_flags & IDE_TFLAG_OUT_DEVICE)
+		tf_outb((tf->device & HIHI) | drive->select.all,
+			 io_ports->device_addr);
+}
+
+static void phoenix_ide_tf_read(ide_drive_t *drive, ide_task_t *task)
+{
+	ide_hwif_t *hwif = drive->hwif;
+	struct ide_io_ports *io_ports = &hwif->io_ports;
+	struct ide_taskfile *tf = &task->tf;
+	void (*tf_outb)(u8 addr, unsigned long port);
+	u8 (*tf_inb)(unsigned long port);
+	u8 mmio = (hwif->host_flags & IDE_HFLAG_MMIO) ? 1 : 0;
+
+	if (mmio) {
+		tf_outb = ide_mm_outb;
+		tf_inb  = ide_mm_inb;
+	} else {
+		tf_outb = ide_outb;
+		tf_inb  = ide_inb;
+	}
+
+	if (task->tf_flags & IDE_TFLAG_IN_DATA) {
+		u16 data;
+
+		if (mmio)
+			data = readw((void __iomem *)io_ports->data_addr);
+		else
+			data = inw(io_ports->data_addr);
+
+		tf->data = data & 0xff;
+		tf->hob_data = (data >> 8) & 0xff;
+	}
+
+	/* be sure we're looking at the low order bits */
+	tf_outb(ATA_DEVCTL_OBS & ~0x80, io_ports->ctl_addr);
+
+	if (task->tf_flags & IDE_TFLAG_IN_FEATURE)
+		tf->feature = tf_inb(io_ports->feature_addr);
+	if (task->tf_flags & IDE_TFLAG_IN_NSECT)
+		tf->nsect  = tf_inb(io_ports->nsect_addr);
+	if (task->tf_flags & IDE_TFLAG_IN_LBAL)
+		tf->lbal   = tf_inb(io_ports->lbal_addr);
+	if (task->tf_flags & IDE_TFLAG_IN_LBAM)
+		tf->lbam   = tf_inb(io_ports->lbam_addr);
+	if (task->tf_flags & IDE_TFLAG_IN_LBAH)
+		tf->lbah   = tf_inb(io_ports->lbah_addr);
+	if (task->tf_flags & IDE_TFLAG_IN_DEVICE)
+		tf->device = tf_inb(io_ports->device_addr);
+
+	if (task->tf_flags & IDE_TFLAG_LBA48) {
+		tf_outb(ATA_DEVCTL_OBS | 0x80, io_ports->ctl_addr);
+
+		if (task->tf_flags & IDE_TFLAG_IN_HOB_FEATURE)
+			tf->hob_feature = tf_inb(io_ports->feature_addr);
+		if (task->tf_flags & IDE_TFLAG_IN_HOB_NSECT)
+			tf->hob_nsect   = tf_inb(io_ports->nsect_addr);
+		if (task->tf_flags & IDE_TFLAG_IN_HOB_LBAL)
+			tf->hob_lbal    = tf_inb(io_ports->lbal_addr);
+		if (task->tf_flags & IDE_TFLAG_IN_HOB_LBAM)
+			tf->hob_lbam    = tf_inb(io_ports->lbam_addr);
+		if (task->tf_flags & IDE_TFLAG_IN_HOB_LBAH)
+			tf->hob_lbah    = tf_inb(io_ports->lbah_addr);
+	}
+}
+
+/*
+ * Some localbus EIDE interfaces require a special access sequence
+ * when using 32-bit I/O instructions to transfer data.  We call this
+ * the "vlb_sync" sequence, which consists of three successive reads
+ * of the sector count register location, with interrupts disabled
+ * to ensure that the reads all happen together.
+ */
+static void ata_vlb_sync(unsigned long port)
+{
+	(void)inb(port);
+	(void)inb(port);
+	(void)inb(port);
+}
+
+/*
+ * This is used for most PIO data transfers *from* the IDE interface
+ *
+ * These routines will round up any request for an odd number of bytes,
+ * so if an odd len is specified, be sure that there's at least one
+ * extra byte allocated for the buffer.
+ */
+static void phoenix_ide_input_data(ide_drive_t *drive, struct request *rq, void *buf,
+		    unsigned int len)
+{
+	ide_hwif_t *hwif = drive->hwif;
+	struct ide_io_ports *io_ports = &hwif->io_ports;
+	unsigned long data_addr = io_ports->data_addr;
+	u8 io_32bit = drive->io_32bit;
+	u8 mmio = (hwif->host_flags & IDE_HFLAG_MMIO) ? 1 : 0;
+
+	len++;
+
+	if (io_32bit) {
+		unsigned long uninitialized_var(flags);
+
+		if ((io_32bit & 2) && !mmio) {
+			local_irq_save(flags);
+			ata_vlb_sync(io_ports->nsect_addr);
+		}
+
+		if (mmio)
+			__ide_mm_insl((void __iomem *)data_addr, buf, len / 4);
+		else
+			insl(data_addr, buf, len / 4);
+
+		if ((io_32bit & 2) && !mmio)
+			local_irq_restore(flags);
+
+		if ((len & 3) >= 2) {
+			if (mmio)
+				__ide_mm_insw((void __iomem *)data_addr,
+						(u8 *)buf + (len & ~3), 1);
+			else
+				insw(data_addr, (u8 *)buf + (len & ~3), 1);
+		}
+	} else {
+		if (mmio)
+			__ide_mm_insw((void __iomem *)data_addr, buf, len / 2);
+		else
+			insw(data_addr, buf, len / 2);
+	}
+}
+
+/*
+ * This is used for most PIO data transfers *to* the IDE interface
+ */
+static void phoenix_ide_output_data(ide_drive_t *drive, struct request *rq, void *buf,
+		     unsigned int len)
+{
+	ide_hwif_t *hwif = drive->hwif;
+	struct ide_io_ports *io_ports = &hwif->io_ports;
+	unsigned long data_addr = io_ports->data_addr;
+	u8 io_32bit = drive->io_32bit;
+	u8 mmio = (hwif->host_flags & IDE_HFLAG_MMIO) ? 1 : 0;
+
+	if (io_32bit) {
+		unsigned long uninitialized_var(flags);
+
+		if ((io_32bit & 2) && !mmio) {
+			local_irq_save(flags);
+			ata_vlb_sync(io_ports->nsect_addr);
+		}
+
+		if (mmio)
+			__ide_mm_outsl((void __iomem *)data_addr, buf, len / 4);
+		else
+			outsl(data_addr, buf, len / 4);
+
+		if ((io_32bit & 2) && !mmio)
+			local_irq_restore(flags);
+
+		if ((len & 3) >= 2) {
+			if (mmio)
+				__ide_mm_outsw((void __iomem *)data_addr,
+						 (u8 *)buf + (len & ~3), 1);
+			else
+				outsw(data_addr, (u8 *)buf + (len & ~3), 1);
+		}
+	} else {
+		if (mmio)
+			__ide_mm_outsw((void __iomem *)data_addr, buf, len / 2);
+		else
+			outsw(data_addr, buf, len / 2);
+	}
+}
+
+/* Note ends:
+   Above functions are taken from drivers/ide/ide-iops.c
+   */
+
+
+
+static const struct ide_tp_ops phoenix_tp_ops = {
+	.exec_command		= phoenix_ide_exec_command,
+	.read_status		= phoenix_ide_read_status,
+	.read_altstatus		= phoenix_ide_read_altstatus,
+	.read_sff_dma_status	= phoenix_ide_read_sff_dma_status,
+
+	.set_irq		= phoenix_ide_set_irq,
+
+	.tf_load		= phoenix_ide_tf_load,
+	.tf_read		= phoenix_ide_tf_read,
+
+	.input_data		= phoenix_ide_input_data,
+	.output_data		= phoenix_ide_output_data,
+};
+
+static const struct ide_port_info phoenix_port_info = {
+	.tp_ops			= &phoenix_tp_ops,
+	.host_flags 		= IDE_HFLAG_NO_DMA,
+};
+
+#define PHOENIX_IDE_REG(pcaddr) (IOADDR(IDE_PHYS) + ((pcaddr)) - mips_io_port_base)
+
+/*
+ * phoenix_ide_probe :
+ *      - Probe the PCMCIA interface
+ *        on selected  XLR Boards.
+ */
+
+static int __devinit phoenix_ide_probe (struct device *dev)
+{
+#if defined(PHOENIX_HAVE_IDE) && defined(IDE_PHYS)
+	unsigned int i = 0;
+	int ret = 0;
+	struct ide_host *host;
+	hw_regs_t hw, *hws[] = { &hw, NULL, NULL, NULL };
+	ide_hwif_t *phoenix_ide_hwif;
+
+
+
+	if (xlr_board_atx_iii() || xlr_board_atx_v())
+	{
+		printk("** Skipping PCMCIA Interface Probe.\n");
+		goto out;
+	}
+
+	printk ("Initializing Phoenix PCMCIA IDE...\n");
+
+	memset(&hw, 0, sizeof(hw));
+	
+	/* setup ports here */
+	hw.io_ports.data_addr   = PHOENIX_IDE_REG(0x1f0);
+	hw.io_ports.error_addr  = PHOENIX_IDE_REG(0x1f1);
+	hw.io_ports.nsect_addr  = PHOENIX_IDE_REG(0x1f2);
+	hw.io_ports.lbal_addr   = PHOENIX_IDE_REG(0x1f3);
+	hw.io_ports.lbam_addr   = PHOENIX_IDE_REG(0x1f4);
+	hw.io_ports.lbah_addr   = PHOENIX_IDE_REG(0x1f5);
+	hw.io_ports.device_addr = PHOENIX_IDE_REG(0x1f6);
+	hw.io_ports.status_addr = PHOENIX_IDE_REG(0x1f7);
+	hw.io_ports.ctl_addr    = PHOENIX_IDE_REG(0x3f6);
+	hw.io_ports.irq_addr    = PHOENIX_IDE_REG(0x3f7);
+
+	hw.irq = PIC_PCMCIA_IRQ;
+	hw.dev = dev;
+	hw.ack_intr = NULL;
+
+	ret = ide_host_add(&phoenix_port_info, hws, &host);
+	if (ret)
+		goto out;
+
+	dev_set_drvdata(dev, host);
+
+	phoenix_ide_hwif = host->ports[0];
+	phoenix_ide_hwif->dma = 0;  /* 0 = NODMA */
+
+        printk("Phoenix PCMCIA configured as IDE interface = %d\n", i);
+out:
+	return ret;
+
+#endif
+}
+
+static int phoenix_ide_remove (struct device *dev)
+{
+
+	return 0;
+}
+
+static struct device_driver phoenix_ide_driver = {
+	.name           = "phoenix-pcmcia", 
+	.bus		= &platform_bus_type,
+	.probe          = phoenix_ide_probe,
+	.remove         = phoenix_ide_remove,
+};
+
+static int __init phoenix_ide_init(void)
+{
+	return driver_register(&phoenix_ide_driver);
+}
+
+static void __exit phoenix_ide_exit(void)
+{
+	driver_unregister(&phoenix_ide_driver);
+}
+
+module_init(phoenix_ide_init);
+module_exit(phoenix_ide_exit);
+MODULE_LICENSE("GPL");
-- 
1.6.0.4

