From ff26a1134969cefcfe44abfc62604e2781ed461f Mon Sep 17 00:00:00 2001
From: Liu Changhui <changhui.liu@windriver.com>
Date: Fri, 29 Jan 2010 13:28:12 +0800
Subject: [PATCH] PCI: Add some specific pci features for rmi xls

Enable Message Signaled Interrupt support for the PCI-E
 slot on the RMI XLR/XLS Boards. Also add some fixes for PCI on the
rmi xls.

source: from RMI SDK1.7

Signed-off-by: shuo.kang <shuo.kang@windriver.com>
---
 drivers/pci/Kconfig  |    9 ++++
 drivers/pci/Makefile |    1 +
 drivers/pci/pci.c    |   21 +++++++++-
 drivers/pci/pci.h    |    2 +-
 drivers/pci/probe.c  |  100 ++++++++++++++++++++++++++++++++++++++++++++++++-
 drivers/pci/proc.c   |    8 ++++
 drivers/pci/quirks.c |    3 +-
 7 files changed, 137 insertions(+), 7 deletions(-)

diff --git a/drivers/pci/Kconfig b/drivers/pci/Kconfig
index e1ca425..a7b5545 100644
--- a/drivers/pci/Kconfig
+++ b/drivers/pci/Kconfig
@@ -21,6 +21,15 @@ config PCI_MSI
 
 	   If you don't know what to do here, say N.
 
+config PCI_MSI_XLR
+	bool "Basic MSI support for the RMI XLR/XLS Platforms"
+	depends on RMI_PHOENIX && PCI && !PCI_MSI
+	help
+	  Enable Message Signaled Interrupt support for the PCI-E
+	  slot on the RMI XLR/XLS Boards.
+
+	  If you don't know what to do here, say N.
+
 config PCI_LEGACY
 	bool "Enable deprecated pci_find_* API"
 	depends on PCI
diff --git a/drivers/pci/Makefile b/drivers/pci/Makefile
index 7d63f8c..fad2dc7 100644
--- a/drivers/pci/Makefile
+++ b/drivers/pci/Makefile
@@ -19,6 +19,7 @@ endif
 
 # Build the PCI MSI interrupt support
 obj-$(CONFIG_PCI_MSI) += msi.o
+obj-$(CONFIG_PCI_MSI_XLR) += msi.o
 
 # Build the Hypertransport interrupt support
 obj-$(CONFIG_HT_IRQ) += htirq.o
diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 12eb5bb..98ba5cc 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -20,6 +20,7 @@
 #include <linux/pm_wakeup.h>
 #include <asm/dma.h>	/* isa_dma_bridge_buggy */
 #include "pci.h"
+#include <asm/rmi/sim.h>
 
 unsigned int pci_pm_d3_delay = 10;
 
@@ -1706,9 +1707,16 @@ pci_set_dma_mask(struct pci_dev *dev, u64 mask)
 {
 	if (!pci_dma_supported(dev, mask))
 		return -EIO;
-
+#ifdef CONFIG_RMI_PHOENIX
+	if(mask > DMA_32BIT_MASK)
+		return -EIO;
+	if(xlr_revision_c())
+		dev->dma_mask = mask & 0x7fffffffULL;
+	else
+		dev->dma_mask = mask;
+#else
 	dev->dma_mask = mask;
-
+#endif
 	return 0;
 }
     
@@ -1718,7 +1726,16 @@ pci_set_consistent_dma_mask(struct pci_dev *dev, u64 mask)
 	if (!pci_dma_supported(dev, mask))
 		return -EIO;
 
+#ifdef CONFIG_RMI_PHOENIX
+	if(mask > DMA_32BIT_MASK)
+		return -EIO;
+	if(xlr_revision_c())
+		dev->dev.coherent_dma_mask = mask & 0x7fffffffULL;
+	else
+		dev->dev.coherent_dma_mask = mask;
+#else
 	dev->dev.coherent_dma_mask = mask;
+#endif
 
 	return 0;
 }
diff --git a/drivers/pci/pci.h b/drivers/pci/pci.h
index 7b1efe9..59706bd 100644
--- a/drivers/pci/pci.h
+++ b/drivers/pci/pci.h
@@ -84,7 +84,7 @@ extern struct rw_semaphore pci_bus_sem;
 
 extern unsigned int pci_pm_d3_delay;
 
-#ifdef CONFIG_PCI_MSI
+#if defined(CONFIG_PCI_MSI) || defined(CONFIG_PCI_MSI_XLR)
 void pci_no_msi(void);
 extern void pci_msi_init_pci_dev(struct pci_dev *dev);
 #else
diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index eb6c8d1..a29db61 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -17,6 +17,24 @@
 #define PCI_CFG_SPACE_SIZE	256
 #define PCI_CFG_SPACE_EXP_SIZE	4096
 
+#ifdef CONFIG_RMI_PHOENIX
+/* Hack! This file includes references to XLR
+ * specific routines/defines. To be removed...
+ * -------------------------------------------
+ * The Global ht_start_busno variable (set in
+ * pci-phoenix.c) is used here, as a reference 
+ * to programming the Seconday/Subordinate bus 
+ * nrs. during bridge scans...
+ */
+extern int ht_start_busno;
+/*
+ * for the is_xls routine.
+ */
+#include <asm/rmi/sim.h>    
+extern void pcie_controller_init_done(void);
+extern int link0, link1, link2, link3;
+#endif
+
 /* Ugh.  Need to stop exporting this to modules. */
 LIST_HEAD(pci_root_buses);
 EXPORT_SYMBOL(pci_root_buses);
@@ -554,6 +572,10 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max,
 
 	pci_read_config_dword(dev, PCI_PRIMARY_BUS, &buses);
 
+#ifdef CONFIG_RMI_PHOENIX
+	buses = buses + ((ht_start_busno<<8) | (ht_start_busno<<16));
+#endif
+
 	dev_dbg(&dev->dev, "scanning behind bridge, config %06x, pass %d\n",
 		buses & 0xffffff, pass);
 
@@ -563,7 +585,11 @@ int __devinit pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max,
 	pci_write_config_word(dev, PCI_BRIDGE_CONTROL,
 			      bctl & ~PCI_BRIDGE_CTL_MASTER_ABORT);
 
+#ifdef CONFIG_RMI_PHOENIX
+	if ((buses & 0xffff00) && !is_cardbus) {
+#else
 	if ((buses & 0xffff00) && !pcibios_assign_all_busses() && !is_cardbus) {
+#endif
 		unsigned int cmax, busnr;
 		/*
 		 * Bus already configured by firmware, process it in the first
@@ -1001,7 +1027,14 @@ static struct pci_dev *pci_scan_device(struct pci_bus *bus, int devfn)
 
 	/* Assume 32-bit PCI; let 64-bit PCI cards (which are far rarer)
 	   set this higher, assuming the system even supports it.  */
+#ifdef CONFIG_RMI_PHOENIX
+	if(xlr_revision_c())
+		dev->dma_mask = DMA_31BIT_MASK;
+	else
+		dev->dma_mask = DMA_32BIT_MASK;
+#else
 	dev->dma_mask = 0xffffffff;
+#endif
 	if (pci_setup_device(dev) < 0) {
 		kfree(dev);
 		return NULL;
@@ -1020,7 +1053,14 @@ void pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
 
 	dev->dev.dma_mask = &dev->dma_mask;
 	dev->dev.dma_parms = &dev->dma_parms;
+#ifdef CONFIG_RMI_PHOENIX
+	if(xlr_revision_c())
+		dev->dev.coherent_dma_mask = DMA_31BIT_MASK;
+	else
+		dev->dev.coherent_dma_mask = DMA_32BIT_MASK;
+#else
 	dev->dev.coherent_dma_mask = 0xffffffffull;
+#endif
 
 	pci_set_dma_max_seg_size(dev, 65536);
 	pci_set_dma_seg_boundary(dev, 0xffffffff);
@@ -1109,18 +1149,72 @@ unsigned int __devinit pci_scan_child_bus(struct pci_bus *bus)
 	unsigned int devfn, pass, max = bus->secondary;
 	struct pci_dev *dev;
 
+	unsigned int devfn_start = 0x00;
+	unsigned int devfn_max   = 0x100;
+#ifdef CONFIG_RMI_PHOENIX
+	int all_absent = 0;
+    
+	if(is_xls2xx() || is_xls1xx() || is_xls_b0()){
+		if(!link0 && !link1 && !link2 && !link3)
+			all_absent = 1;
+	}    
+#endif
 	pr_debug("PCI: Scanning bus %04x:%02x\n", pci_domain_nr(bus), bus->number);
 
-	/* Go find them, Rover! */
-	for (devfn = 0; devfn < 0x100; devfn += 8)
-		pci_scan_slot(bus, devfn);
+#ifdef CONFIG_RMI_PHOENIX
+	if (is_xls() && !is_xls2xx() && !is_xls1xx() && !is_xls_b0()) {
+		if (link0 && (!link1)) {
+			if (bus->number == 0)
+				devfn_max = 0x08;
+		}
+		if ((!link0) && link1) {
+			if (bus->number == 0)
+				devfn_start = 0x08;
+		}
+	}
+#endif
 
+	/* Go find them, Rover! */
+	for (devfn = devfn_start; devfn < devfn_max; devfn += 8){
+#ifdef CONFIG_RMI_PHOENIX
+	if(bus->number==0 && (is_xls2xx() || is_xls1xx() || is_xls_b0()) && !all_absent){
+		switch(devfn){
+                case 0x0:
+               		if(!link0)
+                        	continue;
+               		break;
+                case 0x8:
+			if(!link1)
+				continue;
+			break;
+		case 0x10:
+			if(!link2)
+				continue;
+			break;
+		case 0x18:
+			if(!link3)
+				continue;
+			break;
+		default:
+			break;
+		}
+	}
+#endif
+	pci_scan_slot(bus, devfn);
+	}
 	/*
 	 * After performing arch-dependent fixup of the bus, look behind
 	 * all PCI-to-PCI bridges on this bus.
 	 */
 	pr_debug("PCI: Fixups for bus %04x:%02x\n", pci_domain_nr(bus), bus->number);
 	pcibios_fixup_bus(bus);
+
+#ifdef CONFIG_RMI_PHOENIX
+	/*link2 and link3 are always set to zero incase of xls-4xx/6xx*/
+	if ((is_xls()) && (!link0) && (!link1) && (!link2) && (!link3))
+		return max;
+#endif
+
 	for (pass=0; pass < 2; pass++)
 		list_for_each_entry(dev, &bus->devices, bus_list) {
 			if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE ||
diff --git a/drivers/pci/proc.c b/drivers/pci/proc.c
index e1098c3..97990d2 100644
--- a/drivers/pci/proc.c
+++ b/drivers/pci/proc.c
@@ -393,12 +393,20 @@ int pci_proc_attach_device(struct pci_dev *dev)
 		return -EACCES;
 
 	if (!bus->procdir) {
+#ifdef CONFIG_RMI_PHOENIX
+		/* 
+		   create /proc entries in "%02x" format at all times.
+		   Otherwise, for HT, it will be created in "%04x:%02x" format
+		   */
+		sprintf(name, "%02x", bus->number);
+#else
 		if (pci_proc_domain(bus)) {
 			sprintf(name, "%04x:%02x", pci_domain_nr(bus),
 					bus->number);
 		} else {
 			sprintf(name, "%02x", bus->number);
 		}
+#endif
 		bus->procdir = proc_mkdir(name, proc_bus_pci_dir);
 		if (!bus->procdir)
 			return -ENOMEM;
diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c
index 5625dc1..61f8674 100644
--- a/drivers/pci/quirks.c
+++ b/drivers/pci/quirks.c
@@ -1838,7 +1838,7 @@ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_BROADCOM,
 			 PCI_DEVICE_ID_NX2_5709S,
 			 quirk_brcm_570x_limit_vpd);
 
-#ifdef CONFIG_PCI_MSI
+#if defined(CONFIG_PCI_MSI) || defined(CONFIG_PCI_MSI_XLR)
 /* Some chipsets do not support MSI. We cannot easily rely on setting
  * PCI_BUS_FLAGS_NO_MSI in its bus flags because there are actually
  * some other busses controlled by the chipset even if Linux is not
@@ -1905,6 +1905,7 @@ static void __devinit quirk_msi_ht_cap(struct pci_dev *dev)
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_SERVERWORKS, PCI_DEVICE_ID_SERVERWORKS_HT2000_PCIE,
 			quirk_msi_ht_cap);
 
+
 /* The nVidia CK804 chipset may have 2 HT MSI mappings.
  * MSI are supported if the MSI capability set in any of these mappings.
  */
-- 
1.6.0.4

