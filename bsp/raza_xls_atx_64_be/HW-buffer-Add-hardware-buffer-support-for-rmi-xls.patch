From 11ee9e8a35ef08acdb1f6ef3e97ce70aa37877a7 Mon Sep 17 00:00:00 2001
From: Liu Changhui <changhui.liu@windriver.com>
Date: Fri, 29 Jan 2010 13:28:03 +0800
Subject: [PATCH] HW buffer: Add hardware buffer support for rmi xls

Experimental addition to GMAC functionality allowing "recycling" of
packet buffers by requesting HW to queue free elements upon Tx-complete
back to the Rx free list.This type of performance ehancement is important to
forwarder-like applications where fast path should stay as lean as possible.

source: from RMI SDK1.7

Signed-off-by: shuo.kang <shuo.kang@windriver.com>
---
 arch/mips/rmi/Kconfig     |   14 ++++
 drivers/net/phoenix_mac.c |  158 +++++++++++++++++++++++++++++++++++++++++++++
 include/linux/skbuff.h    |   20 ++++++
 net/core/skbuff.c         |   15 ++++
 4 files changed, 207 insertions(+), 0 deletions(-)

diff --git a/arch/mips/rmi/Kconfig b/arch/mips/rmi/Kconfig
index 068effa..1f01c2e 100644
--- a/arch/mips/rmi/Kconfig
+++ b/arch/mips/rmi/Kconfig
@@ -59,6 +59,20 @@ config PHOENIX_MSGRING_NAPI
 	  If in doubt, say N.
 
 
+config PHOENIX_HW_BUFFER_MGMT
+	bool "Enable support for network buffer recycling via hardware"
+	depends on RMI_PHOENIX
+	default y
+	help
+	  Experimental addition to GMAC functionality allowing "recycling" of 
+	  packet buffers by requesting HW to queue free elements upon Tx-complete 
+	  back to the Rx free list.
+	  This type of performance ehancement is important to forwarder-like
+	  applications where fast path should stay as lean as possible.
+
+	  If in doubt, say N.
+
+
 config RMI_PHOENIX_LOAD_ADDRESS
 	hex "RMI Linux kernel start address"
 	depends on RMI_PHOENIX
diff --git a/drivers/net/phoenix_mac.c b/drivers/net/phoenix_mac.c
index 58cf758..c1967f4 100644
--- a/drivers/net/phoenix_mac.c
+++ b/drivers/net/phoenix_mac.c
@@ -326,6 +326,9 @@ extern struct user_mac_data *user_mac;
 static int rmi_phnx_napi_setup(void);
 #endif
 
+#ifdef CONFIG_PHOENIX_HW_BUFFER_MGMT
+static int setup_auto_free(struct sk_buff *skb, int type, struct msgrng_msg *msg);
+#endif /* CONFIG_PHOENIX_HW_BUFFER_MGMT */
 
 /* global flag for automatic hardware buffer management, disabled by default */
 int rmi_auto_buffer_mgmt = 0;
@@ -702,6 +705,18 @@ static int mac_frin_send_skb(struct net_device *dev, struct sk_buff *skb)
 	unsigned long msgrng_flags = 0;
 	struct driver_data *priv;
 
+#ifdef CONFIG_PHOENIX_HW_BUFFER_MGMT
+	if (rmi_auto_buffer_mgmt) {
+		/* Put skb under automatic buffer management */
+		skb_shinfo(skb)->rmi_flags = 1;
+		skb_shinfo(skb)->rmi_owner = dev;
+		skb_shinfo(skb)->rmi_refill = mac_frin_replenish_one_msg;
+	} else {
+		skb_shinfo(skb)->rmi_flags = 0;
+		skb_shinfo(skb)->rmi_owner = NULL;
+		skb_shinfo(skb)->rmi_refill = NULL;
+	}
+#endif /* CONFIG_PHOENIX_HW_BUFFER_MGMT */
 
 	priv = netdev_priv(dev);
 
@@ -750,6 +765,97 @@ static int mac_frin_replenish_one_msg(struct net_device *dev)
 
 
 
+#ifdef CONFIG_PHOENIX_HW_BUFFER_MGMT
+/*
+ * This helper macro resets SKB data pointers for reuse
+ * as free-in buffer
+*/
+#define skb_reset_ptrs(skb) \
+do { \
+	struct skb_shared_info *shinfo; \
+	\
+	shinfo = skb_shinfo(skb); \
+	\
+	\
+	/* Now reinitialize old skb, cut & paste from dev_alloc_skb */ \
+	memset(skb, 0, offsetof(struct sk_buff, tail)); \
+	skb->data = skb->head;  \
+	skb_reset_tail_pointer(skb);\
+	\
+	atomic_set(&shinfo->dataref, 1); \
+	shinfo->nr_frags  = 0; \
+	shinfo->gso_size = 0; \
+	shinfo->gso_segs = 0; \
+	shinfo->gso_type = 0; \
+	shinfo->ip6_frag_id = 0; \
+	shinfo->frag_list = NULL; \
+} while (0)
+
+
+/*
+ * If we are in the HW buffer management case we handler frames with rx errors
+ * via this function
+*/
+static void 
+discard_rx_frame(struct net_device *dev, struct sk_buff *skb, int cpu)
+{
+	/* Reset all fields to 0, reset data pointers */
+	skb_reset_ptrs(skb);
+
+	mac_frin_send_skb(dev, skb); 
+}
+
+
+/*
+ *  Prepare SKB for automatic memory management operation (buffer recycling)
+ *
+ *  Return: 0 -- recycling is not possible
+ *          1 -- SKB set up for recycling successfully
+*/
+static int
+setup_auto_free(struct sk_buff *skb, int type, struct msgrng_msg *msg)
+{
+	struct driver_data *priv;
+	struct skb_shared_info *shinfo;
+	int fr_stid, offset;
+
+	shinfo = skb_shinfo(skb);
+	if (!shinfo->rmi_flags)
+		return 0;
+
+	if (atomic_read(&skb->users) != 1) {
+		printk(KERN_ALERT "%s: Can't recycle because of users count\n", __FUNCTION__);
+		return 0;
+	}
+
+	if (skb->cloned || atomic_read(&(skb_shinfo(skb)->dataref)) != 1) {
+		printk(KERN_EMERG "%s: Can't recycle because of cloned or dataref\n", __FUNCTION__);
+		return 0;
+	}
+
+	/* Leak no dsk entries! */
+	dst_release(skb->dst);
+
+	/* Reset all fields to 0, reset data pointers */
+	skb_reset_ptrs(skb);
+
+	offset = (((unsigned long)skb->data + SMP_CACHE_BYTES) & ~(SMP_CACHE_BYTES - 1));
+	skb_reserve(skb, (offset - (unsigned long)skb->data));
+
+	priv = netdev_priv(skb_shinfo(skb)->rmi_owner);
+	fr_stid = priv->fr_stid;
+
+	mac_put_skb_back_ptr(skb);
+
+	msg->msg1 = ( ((uint64_t) 1 << 63) |
+		      ((uint64_t) fr_stid << 54) |
+		      ((uint64_t) 0 << 40) |
+		      ((uint64_t)virt_to_phys(skb->data) & 0xffffffffffULL)
+		    );
+	return 1;
+}
+
+#endif /* CONFIG_PHOENIX_HW_BUFFER_MGMT */
 
 
 
@@ -1536,6 +1642,11 @@ static inline int mac_make_desc_b0_tx(struct msgrng_msg *msg,
 		     ((uint64_t) len << 40) | ((uint64_t) addr)
 	    );
 
+#ifdef CONFIG_PHOENIX_HW_BUFFER_MGMT
+        if (rmi_auto_buffer_mgmt && setup_auto_free(skb, priv->type, msg))
+		return tx_stid;
+	else 
+#endif /* CONFIG_PHOENIX_HW_BUFFER_MGMT */
 	{
 		msg->msg1 = (((uint64_t) 1 << 63) |
 			     ((uint64_t) fr_stid << 54) |
@@ -2349,6 +2460,24 @@ void rmi_phnx_mac_msgring_handler(int bucket, int size, int code,
 				  int stid, struct msgrng_msg *msg,
 				  void *data /* ignored */ )
 {
+#ifndef CONFIG_PHOENIX_HW_BUFFER_MGMT
+/* 
+ * Special helper macro to handle Rx errors within this interrupt handler
+ * macro is used locally in this function only
+ *
+ * NB: the alternative case when HW buffer management is on is handled by a 
+ * larger function defined above
+*/
+#define discard_rx_frame(dev, skb, cpu) \
+do { \
+	if (atomic_inc_return(&priv->frin_to_be_sent[cpu]) > \
+				MAC_FRIN_TO_BE_SENT_THRESHOLD) { \
+		tasklet_schedule(&mac_frin_replenish_task[cpu]); \
+	} \
+	dev_kfree_skb_irq(skb); \
+} while (0)
+
+#endif /* !CONFIG_PHOENIX_HW_BUFFER_MGMT */
 
 	unsigned long addr = 0;
 	__u32 length = 0;
@@ -2982,6 +3111,13 @@ static int rmi_phnx_mac_fill_rxfr(struct net_device *dev)
 
 		skb->dev = dev;
 
+#ifdef CONFIG_PHOENIX_HW_BUFFER_MGMT
+		if (rmi_auto_buffer_mgmt) {
+			skb_shinfo(skb)->rmi_flags = 1;
+			skb_shinfo(skb)->rmi_owner = dev;
+			skb_shinfo(skb)->rmi_refill = mac_frin_replenish_one_msg;
+		}
+#endif /* CONFIG_PHOENIX_HW_BUFFER_MGMT */
 
 		/* Send the free Rx desc to the MAC */
 		msgrng_access_enable(msgrng_flags);
@@ -3355,6 +3491,28 @@ xlr_mac_proc_read(char *page, char **start, off_t off,
 
 
 
+#ifdef CONFIG_PHOENIX_HW_BUFFER_MGMT
+/*
+ * Setup for XLR/XLS automatic hardware buffer management. 
+*/
+static int __init
+rmi_auto_buffer_mgmt_setup(char *str)
+{
+	if (str == NULL || !strcmp(str, "yes") || !strcmp(str, "y")) {
+		rmi_auto_buffer_mgmt = 1;
+		printk(KERN_ALERT "Enabling automatic hardware buffer management\n");
+	}
+	else if (!strcmp(str, "no") || !strcmp(str, "n")) {
+		rmi_auto_buffer_mgmt = 0;
+		printk(KERN_ALERT "Disabling automatic hardware buffer management\n");
+	}
+
+	return 0;
+}
+
+/* for compatibility we use "xlr_" prefix for the option */
+early_param("xlr_auto_buffer_mgmt", rmi_auto_buffer_mgmt_setup);
+#endif /* CONFIG_PHOENIX_HW_BUFFER_MGMT */
 
 
 
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index 8755064..d026e38 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -146,6 +146,26 @@ struct skb_shared_info {
 	unsigned short	gso_segs;
 	unsigned short  gso_type;
 	__be32          ip6_frag_id;
+#ifdef CONFIG_PHOENIX_HW_BUFFER_MGMT
+
+        /* Several fileds to track SKB's which utilize automatic buffer 
+         * management:
+         *
+         * @rmi_flags: Non-zero means that this data buffer intends to use FMN
+         * features to return data back to originating device's free pool. 
+         * If more flags added later, we will transition to bit-scale 
+         * representation for semantics of this field.
+         *
+         * @rmi_owner: pointer to the device which owns this data buffer
+         *
+         * @rmi_refill: function to create new data buffers (e.g. to replace
+         * one to be freed for some reason).
+        */
+	unsigned int      rmi_flags;
+	struct net_device *rmi_owner;
+	int               (*rmi_refill)(struct net_device *dev);
+
+#endif /* CONFIG_PHOENIX_HW_BUFFER_MGMT */
 	struct sk_buff	*frag_list;
 	skb_frag_t	frags[MAX_SKB_FRAGS];
 };
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index 3fbc8f9..07c3cfc 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -205,6 +205,11 @@ struct sk_buff *__alloc_skb(unsigned int size, gfp_t gfp_mask,
 	shinfo->gso_segs = 0;
 	shinfo->gso_type = 0;
 	shinfo->ip6_frag_id = 0;
+#ifdef CONFIG_PHOENIX_HW_BUFFER_MGMT
+	shinfo->rmi_flags = 0;
+	shinfo->rmi_owner = NULL;
+	shinfo->rmi_refill = NULL;
+#endif /* CONFIG_PHOENIX_HW_BUFFER_MGMT */
 	shinfo->frag_list = NULL;
 
 	if (fclone) {
@@ -313,6 +318,12 @@ static void skb_release_data(struct sk_buff *skb)
 		if (skb_shinfo(skb)->frag_list)
 			skb_drop_fraglist(skb);
 
+#ifdef CONFIG_PHOENIX_HW_BUFFER_MGMT
+		if (skb_shinfo(skb)->rmi_flags && skb_shinfo(skb)->rmi_refill)
+			skb_shinfo(skb)->rmi_refill(skb_shinfo(skb)->rmi_owner);
+#endif /* CONFIG_PHOENIX_HW_BUFFER_MGMT */
+
+
 		kfree(skb->head);
 	}
 }
@@ -692,6 +703,10 @@ int pskb_expand_head(struct sk_buff *skb, int nhead, int ntail,
 #endif
 	long off;
 
+#if defined (CONFIG_RMI_PHOENIX) && defined (CONFIG_64BIT)
+	gfp_mask |= GFP_DMA;
+#endif
+
 	if (skb_shared(skb))
 		BUG();
 
-- 
1.6.0.4

