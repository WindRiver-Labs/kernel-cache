From 10b1357074c00fe9b6b992f0de00ea2975a6e08e Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Tue, 3 Mar 2009 12:39:07 +0800
Subject: [PATCH] fsl_mpc8349e_mitx: Support USB Function

fsl_mpc8349e_mitx: Support USB function

Add usb device's initial function to probe associative drivers.

Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 arch/powerpc/sysdev/fsl_soc.c |   35 ++++++++-
 drivers/usb/host/ehci-fsl.c   |  162 ++++++++++++++++++++++++++++++++++++++++-
 drivers/usb/host/ehci-hub.c   |   39 ++++++++++
 drivers/usb/host/ehci.h       |    8 ++
 4 files changed, 238 insertions(+), 6 deletions(-)

diff --git a/arch/powerpc/sysdev/fsl_soc.c b/arch/powerpc/sysdev/fsl_soc.c
index dd1d7ed..b800904 100644
--- a/arch/powerpc/sysdev/fsl_soc.c
+++ b/arch/powerpc/sysdev/fsl_soc.c
@@ -479,10 +479,16 @@ static int __init fsl_usb_of_init(void)
 {
 	struct device_node *np;
 	unsigned int i = 0;
-	struct platform_device *usb_dev_mph = NULL, *usb_dev_dr_host = NULL,
-		*usb_dev_dr_client = NULL;
+	struct platform_device *usb_dev_mph = NULL;
+#if (defined(CONFIG_FSL_USB_OTG) || defined(CONFIG_FSL_USB_OTG_MODULE) || \
+	defined(CONFIG_USB_GADGET) || defined(CONFIG_USB_GADGET_MODULE))
+	struct platform_device *usb_dev_dr_host = NULL, *usb_dev_dr_client = NULL,
+		*usb_dev_dr_otg = NULL;
+#endif
 	int ret;
 
+#if !(defined(CONFIG_FSL_USB_OTG) || defined(CONFIG_FSL_USB_OTG_MODULE) || \
+	defined(CONFIG_USB_GADGET) || defined(CONFIG_USB_GADGET_MODULE))
 	for_each_compatible_node(np, NULL, "fsl-usb2-mph") {
 		struct resource r[2];
 		struct fsl_usb2_platform_data usb_data;
@@ -529,6 +535,7 @@ static int __init fsl_usb_of_init(void)
 		i++;
 	}
 
+#else
 	for_each_compatible_node(np, NULL, "fsl-usb2-dr") {
 		struct resource r[2];
 		struct fsl_usb2_platform_data usb_data;
@@ -563,6 +570,12 @@ static int __init fsl_usb_of_init(void)
 			}
 		} else if (prop && !strcmp(prop, "otg")) {
 			usb_data.operating_mode = FSL_USB2_DR_OTG;
+			usb_dev_dr_otg = platform_device_register_simple(
+					"fsl-usb2-otg", i, r, 2);
+			if (IS_ERR(usb_dev_dr_otg)) {
+				ret = PTR_ERR(usb_dev_dr_otg);
+				goto unreg_dr;
+			}
 			usb_dev_dr_host = platform_device_register_simple(
 					"fsl-ehci", i, r, 2);
 			if (IS_ERR(usb_dev_dr_host)) {
@@ -583,6 +596,18 @@ static int __init fsl_usb_of_init(void)
 		prop = of_get_property(np, "phy_type", NULL);
 		usb_data.phy_mode = determine_usb_phy(prop);
 
+		if (usb_dev_dr_otg) {
+			usb_dev_dr_otg->dev.coherent_dma_mask = 0xffffffffUL;
+			usb_dev_dr_otg->dev.dma_mask =
+			    &usb_dev_dr_otg->dev.coherent_dma_mask;
+			ret =
+			    platform_device_add_data(usb_dev_dr_otg, &usb_data,
+						     sizeof(struct
+						     fsl_usb2_platform_data));
+			if (ret)
+				goto unreg_dr;
+		}
+
 		if (usb_dev_dr_host) {
 			usb_dev_dr_host->dev.coherent_dma_mask = 0xffffffffUL;
 			usb_dev_dr_host->dev.dma_mask = &usb_dev_dr_host->
@@ -603,13 +628,19 @@ static int __init fsl_usb_of_init(void)
 		}
 		i++;
 	}
+#endif
 	return 0;
 
+#if (defined(CONFIG_FSL_USB_OTG) || defined(CONFIG_FSL_USB_OTG_MODULE) || \
+	defined(CONFIG_USB_GADGET) || defined(CONFIG_USB_GADGET_MODULE))
 unreg_dr:
 	if (usb_dev_dr_host)
 		platform_device_unregister(usb_dev_dr_host);
 	if (usb_dev_dr_client)
 		platform_device_unregister(usb_dev_dr_client);
+	if (usb_dev_dr_otg)
+		platform_device_unregister(usb_dev_dr_otg);
+#endif
 unreg_mph:
 	if (usb_dev_mph)
 		platform_device_unregister(usb_dev_mph);
diff --git a/drivers/usb/host/ehci-fsl.c b/drivers/usb/host/ehci-fsl.c
index 01c3da3..602b274 100644
--- a/drivers/usb/host/ehci-fsl.c
+++ b/drivers/usb/host/ehci-fsl.c
@@ -27,6 +27,33 @@
 /* FIXME: Power Management is un-ported so temporarily disable it */
 #undef CONFIG_PM
 
+#if defined(CONFIG_FSL_USB_OTG) || defined(CONFIG_FSL_USB_OTG_MODULE)
+/* backup of ehci registers */
+static void *usb_ehci_regs;
+static int have_hcd, hcd_add;
+struct resource *otg_get_resources(void);
+
+static void do_change_hcd(struct work_struct *work)
+{
+	struct ehci_hcd *ehci = container_of(work, struct ehci_hcd,
+			change_hcd_work);
+	struct usb_hcd *hcd = ehci_to_hcd(ehci);
+	void __iomem *non_ehci = hcd->regs;
+	struct resource *res;
+	int retval;
+
+	res = otg_get_resources();
+	if (hcd_add && !have_hcd) {
+		writel(0x00000003, non_ehci + FSL_SOC_USB_USBMODE);
+		retval = usb_add_hcd(hcd, res[1].start, IRQF_SHARED);
+		if (retval == 0)
+			have_hcd = 1;
+	} else if (!hcd_add && have_hcd) {
+		usb_remove_hcd(hcd);
+		have_hcd = 0;
+	}
+}
+#endif
 
 /* configure so an HC device and id are always provided */
 /* always called with process context; sleeping is OK */
@@ -47,8 +74,11 @@ int usb_hcd_fsl_probe(const struct hc_driver *driver,
 	struct usb_hcd *hcd;
 	struct resource *res;
 	int irq;
-	int retval;
+	int retval = 0;
 	unsigned int temp;
+#if defined(CONFIG_FSL_USB_OTG) || defined(CONFIG_FSL_USB_OTG_MODULE)
+	struct ehci_hcd *ehci;
+#endif
 
 	pr_debug("initializing FSL-SOC USB Controller\n");
 
@@ -73,6 +103,17 @@ int usb_hcd_fsl_probe(const struct hc_driver *driver,
 		return -ENODEV;
 	}
 
+#if defined(CONFIG_FSL_USB_OTG) || defined(CONFIG_FSL_USB_OTG_MODULE)
+	res = otg_get_resources();
+	if (!res) {
+		dev_err(&pdev->dev,
+			"Found HC with no IRQ. Check %s setup!\n",
+			pdev->dev.bus_id);
+		return -ENODEV;
+	}
+	irq = res[1].start;
+#else
+
 	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
 	if (!res) {
 		dev_err(&pdev->dev,
@@ -81,6 +122,7 @@ int usb_hcd_fsl_probe(const struct hc_driver *driver,
 		return -ENODEV;
 	}
 	irq = res->start;
+#endif
 
 	hcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));
 	if (!hcd) {
@@ -88,7 +130,11 @@ int usb_hcd_fsl_probe(const struct hc_driver *driver,
 		goto err1;
 	}
 
+#if defined(CONFIG_FSL_USB_OTG) || defined(CONFIG_FSL_USB_OTG_MODULE)
+	res = otg_get_resources();
+#else
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+#endif
 	if (!res) {
 		dev_err(&pdev->dev,
 			"Found HC with no register addr. Check %s setup!\n",
@@ -98,12 +144,14 @@ int usb_hcd_fsl_probe(const struct hc_driver *driver,
 	}
 	hcd->rsrc_start = res->start;
 	hcd->rsrc_len = res->end - res->start + 1;
+#if !(defined(CONFIG_FSL_USB_OTG) || defined(CONFIG_FSL_USB_OTG_MODULE))
 	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len,
 				driver->description)) {
 		dev_dbg(&pdev->dev, "controller already in use\n");
 		retval = -EBUSY;
 		goto err2;
 	}
+#endif
 	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
 
 	if (hcd->regs == NULL) {
@@ -116,6 +164,31 @@ int usb_hcd_fsl_probe(const struct hc_driver *driver,
 	temp = in_be32(hcd->regs + 0x500);
 	out_be32(hcd->regs + 0x500, temp | 0x4);
 
+#if defined(CONFIG_FSL_USB_OTG) || defined(CONFIG_FSL_USB_OTG_MODULE)
+	/* For OTG, default to suspend state on probe */
+	printk(KERN_INFO "Suspend ehci driver for OTG auto detection\n");
+	ehci = hcd_to_ehci(hcd);
+	ehci->transceiver = otg_get_transceiver();
+	INIT_WORK(&ehci->change_hcd_work, do_change_hcd);
+	if (ehci->transceiver) {
+		int status = otg_set_host(ehci->transceiver,
+				&ehci_to_hcd(ehci)->self);
+		dev_dbg(ehci->transceiver->dev,
+				"init %s transceiver, status %d\n",
+				ehci->transceiver->label, status);
+		if (status) {
+			if (ehci->transceiver)
+				put_device(ehci->transceiver->dev);
+			retval = status;
+			goto err4;
+		}
+	} else {
+		printk(KERN_INFO "can't find transceiver\n");
+		retval = -ENODEV;
+		goto err4;
+	}
+
+#else
 	/* Set to Host mode */
 	temp = in_le32(hcd->regs + 0x1a8);
 	out_le32(hcd->regs + 0x1a8, temp | 0x3);
@@ -123,6 +196,8 @@ int usb_hcd_fsl_probe(const struct hc_driver *driver,
 	retval = usb_add_hcd(hcd, irq, IRQF_DISABLED | IRQF_SHARED);
 	if (retval != 0)
 		goto err4;
+#endif
+
 	return retval;
 
       err4:
@@ -244,7 +319,9 @@ static void mpc83xx_usb_setup(struct usb_hcd *hcd)
 static int ehci_fsl_reinit(struct ehci_hcd *ehci)
 {
 	mpc83xx_usb_setup(ehci_to_hcd(ehci));
+#if !(defined(CONFIG_FSL_USB_OTG) || defined(CONFIG_FSL_USB_OTG_MODULE))
 	ehci_port_power(ehci, 0);
+#endif
 
 	return 0;
 }
@@ -266,8 +343,7 @@ static int ehci_fsl_setup(struct usb_hcd *hcd)
 	ehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);
 
 	retval = ehci_halt(ehci);
-	if (retval)
-		return retval;
+	/* It's ok that we can't halt the bus */
 
 	/* data structure init */
 	retval = ehci_init(hcd);
@@ -322,34 +398,112 @@ static const struct hc_driver ehci_fsl_hc_driver = {
 	.hub_control = ehci_hub_control,
 	.bus_suspend = ehci_bus_suspend,
 	.bus_resume = ehci_bus_resume,
+	.start_port_reset = ehci_start_port_reset,
 	.relinquish_port = ehci_relinquish_port,
 	.port_handed_over = ehci_port_handed_over,
 };
 
 static int ehci_fsl_drv_probe(struct platform_device *pdev)
 {
+	struct fsl_usb2_platform_data *pdata;
+
 	if (usb_disabled())
 		return -ENODEV;
 
+	/* Need platform data for setup */
+	pdata = (struct fsl_usb2_platform_data *)pdev->dev.platform_data;
+	if (!pdata) {
+		dev_err(&pdev->dev,
+			"No platform data for %s.\n", dev_name(&pdev->dev));
+		return -ENODEV;
+	}
+
+#if defined(CONFIG_FSL_USB_OTG) || defined(CONFIG_FSL_USB_OTG_MODULE)
 	/* FIXME we only want one one probe() not two */
 	return usb_hcd_fsl_probe(&ehci_fsl_hc_driver, pdev);
+#else
+	if ((pdata->operating_mode == FSL_USB2_MPH_HOST) ||
+		(pdata->operating_mode == FSL_USB2_DR_HOST))
+		/* FIXME we only want one one probe() not two */
+		return usb_hcd_fsl_probe(&ehci_fsl_hc_driver, pdev);
+#endif
 }
 
 static int ehci_fsl_drv_remove(struct platform_device *pdev)
 {
 	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	struct fsl_usb2_platform_data *pdata;
 
+	/* Need platform data for setup */
+	pdata = (struct fsl_usb2_platform_data *)pdev->dev.platform_data;
+	if (!pdata) {
+		dev_err(&pdev->dev,
+			"No platform data for %s.\n", dev_name(&pdev->dev));
+		return -ENODEV;
+	}
+
+#if defined(CONFIG_FSL_USB_OTG) || defined(CONFIG_FSL_USB_OTG_MODULE)
+	kfree(usb_ehci_regs);
 	/* FIXME we only want one one remove() not two */
 	usb_hcd_fsl_remove(hcd, pdev);
+#else
+	if ((pdata->operating_mode == FSL_USB2_MPH_HOST) ||
+		(pdata->operating_mode == FSL_USB2_DR_HOST))
+		/* FIXME we only want one one remove() not two */
+		usb_hcd_fsl_remove(hcd, pdev);
+#endif
+	return 0;
+}
+
+static int ehci_fsl_drv_suspend(struct platform_device *pdev,
+				pm_message_t message)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+#if defined(CONFIG_FSL_USB_OTG) || defined(CONFIG_FSL_USB_OTG_MODULE)
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+
+	/* remove hcd */
+	hcd_add = 0;
+	schedule_work(&ehci->change_hcd_work);
+
+#endif
+	hcd->state = HC_STATE_SUSPENDED;
+	pdev->dev.power.power_state = PMSG_SUSPEND;
+
+/* FIXME: USB PM not working now */
+/*	if (hcd->driver->suspend)
+		return hcd->driver->suspend(hcd,message);*/
+	return 0;
+}
+
+static int ehci_fsl_drv_resume(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+#if defined(CONFIG_FSL_USB_OTG) || defined(CONFIG_FSL_USB_OTG_MODULE)
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+
+	/* add hcd */
+	hcd_add = 1;
+	schedule_work(&ehci->change_hcd_work);
+
+#endif
+/* FIXME: USB PM not working now */
+/*	if (hcd->driver->resume)
+		return hcd->driver->resume(hcd); */
+	pdev->dev.power.power_state = PMSG_ON;
+	usb_hcd_resume_root_hub(hcd);
+
 	return 0;
 }
 
-MODULE_ALIAS("platform:fsl-ehci");
+MODULE_ALIAS("fsl-ehci");
 
 static struct platform_driver ehci_fsl_driver = {
 	.probe = ehci_fsl_drv_probe,
 	.remove = ehci_fsl_drv_remove,
 	.shutdown = usb_hcd_platform_shutdown,
+	.suspend = ehci_fsl_drv_suspend,
+	.resume = ehci_fsl_drv_resume,
 	.driver = {
 		   .name = "fsl-ehci",
 	},
diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
index 740835b..1f70048 100644
--- a/drivers/usb/host/ehci-hub.c
+++ b/drivers/usb/host/ehci-hub.c
@@ -27,6 +27,7 @@
  */
 
 /*-------------------------------------------------------------------------*/
+#include <linux/usb/otg.h>
 
 #define	PORT_WAKE_BITS	(PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E)
 
@@ -533,6 +534,36 @@ ehci_hub_descriptor (
 	desc->wHubCharacteristics = cpu_to_le16(temp);
 }
 
+#ifdef CONFIG_USB_OTG
+static int ehci_start_port_reset(struct usb_hcd *hcd, unsigned port)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+	u32 status;
+
+	if (!port)
+		return -EINVAL;
+	port--;
+
+	/* start port reset before HNP protocol time out */
+	status = readl(&ehci->regs->port_status[port]);
+	if (!(status & PORT_CONNECT))
+		return -ENODEV;
+
+	/* khubd will finish the reset later */
+	if (ehci_is_TDI(ehci))
+		writel(PORT_RESET | (status & ~(PORT_CSC | PORT_PEC
+				| PORT_OCC)), &ehci->regs->port_status[port]);
+	else
+		writel(PORT_RESET, &ehci->regs->port_status[port]);
+
+	return 0;
+}
+#else
+static int ehci_start_port_reset(struct usb_hcd *hcd, unsigned port)
+{
+}
+#endif /* CONFIG_USB_OTG */
+
 /*-------------------------------------------------------------------------*/
 
 static int ehci_hub_control (
@@ -799,6 +830,14 @@ static int ehci_hub_control (
 		case USB_PORT_FEAT_SUSPEND:
 			if (ehci->no_selective_suspend)
 				break;
+#ifdef CONFIG_USB_OTG
+			if ((hcd->self.otg_port == (wIndex + 1))
+					&& hcd->self.b_hnp_enable) {
+				otg_start_hnp(ehci->transceiver);
+				break;
+			}
+#endif
+
 			if ((temp & PORT_PE) == 0
 					|| (temp & PORT_RESET) != 0)
 				goto error;
diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h
index c165fe4..6707281 100644
--- a/drivers/usb/host/ehci.h
+++ b/drivers/usb/host/ehci.h
@@ -133,6 +133,14 @@ struct ehci_hcd {			/* one per controller */
 #	define COUNT(x) do {} while (0)
 #endif
 
+	/*
+	 * OTG controllers and transceivers need software interaction;
+	 * other external transceivers should be software-transparent
+	 */
+	struct otg_transceiver	*transceiver;
+	u32			power_budget;
+	struct work_struct change_hcd_work;
+
 	/* debug files */
 #ifdef DEBUG
 	struct dentry		*debug_dir;
-- 
1.6.0.4

