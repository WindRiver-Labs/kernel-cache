From be3fd039354a08225c3ef0fb7e6c91cfabb620a4 Mon Sep 17 00:00:00 2001
From: Wang Hui <Hui.Wang@windriver.com>
Date: Tue, 30 Oct 2012 13:33:33 +0800
Subject: [PATCH 32/50] armadaxp: udc: make USB device driver work

The original USB device driver in the linux-3.2.27-axp_a370-2012_Q4.1
is not enabled by default and follows old kernel API, to build it
correctly and make it work, we need to change to use newer kernel API
instead.

Signed-off-by: Wang Hui <Hui.Wang@windriver.com>
---
 arch/arm/mach-armadaxp/Makefile                    |    2 +
 arch/arm/mach-armadaxp/config/mvRules.mk           |    1 +
 .../arm/plat-armada/mv_drivers_lsp/mv_udc/Makefile |    4 +-
 .../mv_drivers_lsp/mv_udc/mv_udc_main.c            |   48 +++++++++++++++++++-
 4 files changed, 51 insertions(+), 4 deletions(-)

diff --git a/arch/arm/mach-armadaxp/Makefile b/arch/arm/mach-armadaxp/Makefile
index 9fb2095..667d600 100644
--- a/arch/arm/mach-armadaxp/Makefile
+++ b/arch/arm/mach-armadaxp/Makefile
@@ -126,6 +126,8 @@ endif
 
 obj-y                                  += $(LSP_PHY_DIR)/
 
+obj-$(CONFIG_USB_GADGET)                += $(LSP_UDC_DIR)/
+
 obj-$(CONFIG_MV_USE_XOR_ENGINE) 	+= $(PLAT_DRIVERS)/mv_xor/
 obj-$(CONFIG_MV_CESA) 			+= $(PLAT_DRIVERS)/mv_cesa/
 obj-$(CONFIG_MV_IPC_DRIVER)		+= $(PLAT_DRIVERS)/mv_ipc/
diff --git a/arch/arm/mach-armadaxp/config/mvRules.mk b/arch/arm/mach-armadaxp/config/mvRules.mk
index f50433f..95e9741 100644
--- a/arch/arm/mach-armadaxp/config/mvRules.mk
+++ b/arch/arm/mach-armadaxp/config/mvRules.mk
@@ -100,6 +100,7 @@ endif
 LSP_TRACE_DIR     = $(PLAT_DRIVERS)/mv_trace
 LSP_SWITCH_DIR    = $(PLAT_DRIVERS)/mv_switch
 LSP_PHY_DIR       = $(PLAT_DRIVERS)/mv_phy
+LSP_UDC_DIR       = $(PLAT_DRIVERS)/mv_udc
 
 # Environment components
 AXP_FAM_DIR	= armada_xp_family
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/Makefile b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/Makefile
index 18b966d..656187a 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/Makefile
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/Makefile
@@ -6,7 +6,7 @@ include $(srctree)/$(MACHINE)/config/mvRules.mk
 endif
 
 USB_DIR := ../mv_hal/usb/
-USB_PATH := $(srctree)/arch/arm/plat-feroceon/mv_hal/usb
+USB_PATH := $(srctree)/arch/arm/plat-armada/mv_hal/usb
 
 USB_DEV_DIR := $(USB_DIR)/device
 
@@ -17,5 +17,5 @@ OBJS        := mv_udc_main.o ../$(USB_DEV_DIR)/mvUsbDevCh9.o ../$(USB_DEV_DIR)/m
 	       ../$(USB_DEV_DIR)/mvUsbHsDevUtl.o  ../$(USB_DEV_DIR)/mvUsbHsDevMain.o ../$(USB_DEV_DIR)/mvUsbHsDevCncl.o
 
 mv_udc-objs := $(OBJS)
-obj-m := mv_udc.o
+obj-$(CONFIG_USB_GADGET) := mv_udc.o
 
diff --git a/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/mv_udc_main.c b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/mv_udc_main.c
index 7e860fc..e853367 100644
--- a/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/mv_udc_main.c
+++ b/arch/arm/plat-armada/mv_drivers_lsp/mv_udc/mv_udc_main.c
@@ -1039,7 +1039,12 @@ static int mv_usb_initialize_kobject (void)
  * disconnect is reported.  then a host may connect again, or
  * the driver might get unbound.
  */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3,0,0)
+static int mv_usb_udc_start (struct usb_gadget_driver *driver,
+		int (*bind)(struct usb_gadget *))
+#else
 int usb_gadget_register_driver (struct usb_gadget_driver *driver)
+#endif
 {
     int                 retval, dev_no;
     struct mv_usb_dev   *mv_dev = NULL;
@@ -1055,6 +1060,18 @@ int usb_gadget_register_driver (struct usb_gadget_driver *driver)
             break;
     }
 
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3,0,0)
+    if ( (driver == NULL)
+            || (driver->max_speed < USB_SPEED_FULL)
+            || !bind
+            || !driver->unbind
+            || !driver->setup)
+    {
+        mvOsPrintf("ERROR: speed=%d, setup=%p, bind=%p, unbind=%p\n",
+		   driver->max_speed, driver->setup, bind, driver->unbind);
+        return -EINVAL;
+    }
+#else
     if ( (driver == NULL)
             || (driver->speed != USB_SPEED_HIGH)
             || !driver->bind
@@ -1065,7 +1082,7 @@ int usb_gadget_register_driver (struct usb_gadget_driver *driver)
                     driver->speed, driver->bind, driver->unbind, driver->setup);
         return -EINVAL;
     }
-
+#endif
     if (!mv_dev)
     {
         mvOsPrintf("ERROR: max_dev=%d, mv_dev=%p\n", mvCtrlUsbMaxGet(), mv_dev);
@@ -1083,7 +1100,11 @@ int usb_gadget_register_driver (struct usb_gadget_driver *driver)
     /* first hook up the driver ... */
     mv_dev->driver = driver;
     mv_dev->gadget.dev.driver = &driver->driver;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3,0,0)
+    retval = bind (&mv_dev->gadget);
+#else
     retval = driver->bind (&mv_dev->gadget);
+#endif
     if (retval) {
         mvOsPrintf("bind to driver %s --> %d\n",
                 driver->driver.name, retval);
@@ -1106,9 +1127,16 @@ int usb_gadget_register_driver (struct usb_gadget_driver *driver)
     mvOsPrintf("registered Marvell USB-%d gadget driver %s\n", dev_no, driver->driver.name);
     return error;
 }
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3,0,0)
+#else
 EXPORT_SYMBOL (usb_gadget_register_driver);
+#endif
 
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3,0,0)
+static int mv_usb_udc_stop (struct usb_gadget_driver *driver)
+#else
 int usb_gadget_unregister_driver (struct usb_gadget_driver *driver)
+#endif
 {
     int                 i, dev_no;
     struct mv_usb_ep    *mv_ep;
@@ -1177,7 +1205,10 @@ int usb_gadget_unregister_driver (struct usb_gadget_driver *driver)
 
     return 0;
 }
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3,0,0)
+#else
 EXPORT_SYMBOL (usb_gadget_unregister_driver);
+#endif
 
 void    mv_usb_show(struct mv_usb_dev* mv_dev, unsigned int mode)
 {
@@ -1601,6 +1632,10 @@ static const struct usb_gadget_ops mv_usb_ops =
     .wakeup          = mv_usb_wakeup,
     .set_selfpowered = mv_usb_set_selfpowered,
     .ioctl           = NULL,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3,0,0)
+    .start	     = mv_usb_udc_start,
+    .stop	     = mv_usb_udc_stop,
+#endif
 };
 
 static void mv_usb_gadget_release (struct device *_dev)
@@ -1654,7 +1689,9 @@ static int __init mv_usb_gadget_probe(struct platform_device *pDev)
     spin_lock_init (&mv_dev->lock);
     mv_dev->dev = _dev; 
     mv_dev->gadget.ops = &mv_usb_ops;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0)
     mv_dev->gadget.is_dualspeed = 1;
+#endif
 
     /* the "gadget" abstracts/virtualizes the controller */
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25)
@@ -1826,6 +1863,10 @@ static int __init mv_usb_gadget_probe(struct platform_device *pDev)
     if( mv_usb_reinit (mv_dev) != USB_OK)
         return -EINVAL;
 
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3,0,0)
+    retval = usb_add_gadget_udc(&pDev->dev, &mv_dev->gadget);
+#endif
+
     retval = device_register (&mv_dev->gadget.dev);
 
 #ifdef MV_USB_VOLTAGE_FIX
@@ -1858,6 +1899,9 @@ static int __exit mv_usb_gadget_remove(struct platform_device *pDev)
     mvOsPrintf("mv_usb_gadget_remove: mv_dev=%p, driver=%p\n", 
                 mv_dev, mv_dev->driver);
     /* start with the driver above us */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3,0,0)
+    usb_del_gadget_udc(&mv_dev->gadget);
+#else
     if (mv_dev->driver) 
     {
         /* should have been done already by driver model core */
@@ -1866,7 +1910,7 @@ static int __exit mv_usb_gadget_remove(struct platform_device *pDev)
 
         usb_gadget_unregister_driver (mv_dev->driver);
     }
-
+#endif
     spin_lock (&mv_dev->lock);
 
     for (i=0; i<_usb_device_get_max_endpoint(mv_dev->mv_usb_handle); i++)
-- 
1.7.0

