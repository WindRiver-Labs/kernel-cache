From 2545c3978241d1e1f93f1db0bab343057930d81b Mon Sep 17 00:00:00 2001
From: Zhong Hongbo <hongbo.zhong@windriver.com>
Date: Thu, 10 Jan 2013 20:18:55 +0800
Subject: [PATCH 4/5] preempt_rt:armadaxp: change spinlock to raw_spinlock

The platform_secondary_init() is called in the irq disabled, it will
produce calltrace under RT kernel.

Signed-off-by: Zhong Hongbo <hongbo.zhong@windriver.com>
---
 arch/arm/mach-armadaxp/irq.c     |   18 +++++++++---------
 arch/arm/mach-armadaxp/platsmp.c |   10 +++++-----
 2 files changed, 14 insertions(+), 14 deletions(-)

diff --git a/arch/arm/mach-armadaxp/irq.c b/arch/arm/mach-armadaxp/irq.c
index ee2597f..09b02aa 100644
--- a/arch/arm/mach-armadaxp/irq.c
+++ b/arch/arm/mach-armadaxp/irq.c
@@ -24,7 +24,7 @@
 #include "include/mach/smp.h"
 
 unsigned int  irq_int_type[NR_IRQS];
-static DEFINE_SPINLOCK(irq_controller_lock);
+static DEFINE_RAW_SPINLOCK(irq_controller_lock);
 
 int max_per_cpu_irq = 28; // not enabled, default.
 static int __init per_cpu_irq_setup(char *__unused)
@@ -136,14 +136,14 @@ int axp_set_affinity(struct irq_data *d, const struct cpumask *mask_val,bool for
 	u32 irq=d->irq;
 	addr = (CPU_INT_SOURCE_CONTROL_REG(irq));
 
-	spin_lock(&irq_controller_lock);
+	raw_spin_lock(&irq_controller_lock);
 	cpumask_copy(d->affinity, mask_val);
 	d->node = cpumask_first(mask_val);
 	temp = MV_REG_READ(addr);
 	temp &= ~0xf;
 	temp |= *cpus_addr(*mask_val);
 	MV_REG_WRITE(addr, temp);
-	spin_unlock(&irq_controller_lock);
+	raw_spin_unlock(&irq_controller_lock);
 
 return 0;
 }
@@ -175,7 +175,7 @@ void axp_irq_mask(struct irq_data *d)
 #ifdef CONFIG_MV_AMP_ENABLE
 	 mvSemaLock(MV_SEMA_IRQ);
 #else
-	spin_lock(&irq_controller_lock);
+	raw_spin_lock(&irq_controller_lock);
 #endif
 	temp = MV_REG_READ(addr);
 	if ((irq >= IRQ_AURORA_GPIO_START) && (irq < IRQ_AURORA_MSI_START)) {
@@ -201,7 +201,7 @@ void axp_irq_mask(struct irq_data *d)
 #ifdef CONFIG_MV_AMP_ENABLE
 	mvSemaUnlock(MV_SEMA_IRQ);
 #else
-	spin_unlock(&irq_controller_lock);
+	raw_spin_unlock(&irq_controller_lock);
 #endif
 }
 
@@ -230,7 +230,7 @@ void axp_irq_unmask(struct irq_data *d)
 #ifdef CONFIG_MV_AMP_ENABLE
 	mvSemaLock(MV_SEMA_IRQ);
 #else
-	spin_lock(&irq_controller_lock);
+	raw_spin_lock(&irq_controller_lock);
 #endif
 	temp = MV_REG_READ(addr);
 
@@ -251,7 +251,7 @@ void axp_irq_unmask(struct irq_data *d)
 #ifdef CONFIG_MV_AMP_ENABLE
 	mvSemaUnlock(MV_SEMA_IRQ);
 #else
-	spin_unlock(&irq_controller_lock);
+	raw_spin_unlock(&irq_controller_lock);
 #endif
 }
 
@@ -260,9 +260,9 @@ void axp_irq_unmask(struct irq_data *d)
 int axp_set_affinity(struct irq_data *d, const struct cpumask *mask_val,bool force)
 {
 	cpumask_copy((*d).affinity, mask_val);
-	spin_lock(&irq_controller_lock);
+	raw_spin_lock(&irq_controller_lock);
 	(*d).node = cpumask_first(mask_val);
-	spin_unlock(&irq_controller_lock);
+	raw_spin_unlock(&irq_controller_lock);
 	axp_irq_unmask(d);
 	return 0;
 }
diff --git a/arch/arm/mach-armadaxp/platsmp.c b/arch/arm/mach-armadaxp/platsmp.c
index d18fdcb..0425693 100644
--- a/arch/arm/mach-armadaxp/platsmp.c
+++ b/arch/arm/mach-armadaxp/platsmp.c
@@ -80,7 +80,7 @@ void __init set_core_count(unsigned int cpu_count)
 	group_cpu_mask = ((1 << cpu_count) - 1) << (hard_smp_processor_id());
 }
 
-static DEFINE_SPINLOCK(boot_lock);
+static DEFINE_RAW_SPINLOCK(boot_lock);
 
 void __cpuinit platform_secondary_init(unsigned int cpu)
 {
@@ -111,8 +111,8 @@ void __cpuinit platform_secondary_init(unsigned int cpu)
 	/*
 	 * Synchronise with the boot thread.
 	 */
-	spin_lock(&boot_lock);
-	spin_unlock(&boot_lock);
+	raw_spin_lock(&boot_lock);
+	raw_spin_unlock(&boot_lock);
 }
 
 int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
@@ -123,7 +123,7 @@ int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
 	 * set synchronisation state between this boot processor
 	 * and the secondary one
 	 */
-	spin_lock(&boot_lock);
+	raw_spin_lock(&boot_lock);
 
 	/*
 	 * The secondary processor is waiting to be released from
@@ -153,7 +153,7 @@ int __cpuinit boot_secondary(unsigned int cpu, struct task_struct *idle)
 	 * now the secondary core is starting up let it run its
 	 * calibrations, then wait for it to finish
 	 */
-	spin_unlock(&boot_lock);
+	raw_spin_unlock(&boot_lock);
 
 	return pen_release != -1 ? -ENOSYS : 0;
 }
-- 
1.7.0

