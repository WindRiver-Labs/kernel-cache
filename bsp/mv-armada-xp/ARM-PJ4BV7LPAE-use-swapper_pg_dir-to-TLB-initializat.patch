From 45239843b6c0ae9ea108bafc180b019c12896884 Mon Sep 17 00:00:00 2001
From: Xulin Sun <xulin.sun@windriver.com>
Date: Fri, 24 Oct 2014 17:07:32 +0800
Subject: [PATCH 5/7] ARM: PJ4BV7LPAE: use swapper_pg_dir to TLB
 initialization and use phys_addr_t in switch_mm()

This patch modified V7 TLB initialization function to use swapper_pg_dir and
ARCH_PGD_SHIFT. And modifies the switch_mm() processor functions to use phys_addr_t.
On LPAE systems, we now honor the upper 32-bits of the physical address that
is being passed in, and program these into TTBR as expected.

This patch reference to the modification of the file "proc-v7-3level.S", which
comes from the upsteam commits: 4756dcbfd37819a8359d3c69a22be2ee41666d0f and
13f659b0f363114282679d06094337c5efa12fa8.

Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 arch/arm/mm/proc-sheeva_pj4bv7lpae.S |   66 ++++++++++++++++++----------------
 1 files changed, 35 insertions(+), 31 deletions(-)

diff --git a/arch/arm/mm/proc-sheeva_pj4bv7lpae.S b/arch/arm/mm/proc-sheeva_pj4bv7lpae.S
index 1d67518..234b8e3 100644
--- a/arch/arm/mm/proc-sheeva_pj4bv7lpae.S
+++ b/arch/arm/mm/proc-sheeva_pj4bv7lpae.S
@@ -50,6 +50,14 @@
 #define TTB_FLAGS_SMP	(TTB_IRGN_WBWA|TTB_S|TTB_RGN_OC_WBWA)
 #define PMD_FLAGS_SMP	(PMD_SECT_WBWA|PMD_SECT_S)
 
+#ifndef __ARMEB__
+#define rpgdl		r0
+#define rpgdh		r1
+#else
+#define rpgdl		r1
+#define rpgdh		r0
+#endif
+
 ENTRY(cpu_pj4bv7_proc_init)
 	mov	pc, lr
 ENDPROC(cpu_pj4bv7_proc_init)
@@ -140,11 +148,10 @@ ENDPROC(cpu_pj4bv7_dcache_clean_area)
  */
 ENTRY(cpu_pj4bv7_switch_mm)
 #ifdef CONFIG_MMU
-	ldr	r1, [r1, #MM_CONTEXT_ID]	@ get mm->context.id
-	mov	r2, #0
-	and	r3, r1, #0xff
-	mov	r3, r3, lsl #(48 - 32)		@ ASID
-	mcrr	p15, 0, r0, r3, c2		@ set TTB 0
+	ldr	r2, [r2, #MM_CONTEXT_ID]		@ get mm->context.id
+	and	r2, r2, #0xff				@ ASID
+	orr	rpgdh, rpgdh, r2, lsl #(48 - 32)	@ upper 32-bits of pgd
+	mcrr	p15, 0, rpgdl, rpgdh, c2		@ set TTB 0
 	isb
 #endif
 	mov	pc, lr
@@ -349,43 +356,40 @@ __v7_setup:
 	dsb
 #ifdef CONFIG_MMU
 	mcr	p15, 0, r10, c8, c7, 0		@ invalidate I + D TLBs
-	mov	r5, #TTB_EAE
+
+	ldr	r5, =swapper_pg_dir		@ swapper_pg_dir virtual address
+	mov	r5, r5, lsr #ARCH_PGD_SHIFT
+	cmp	r8, r5			@ PHYS_OFFSET > PAGE_OFFSET?
+	mrc	p15, 0, r5, c2, c0, 2		@ TTB control register
+
+	orr	r5, r5, #TTB_EAE
 	ALT_SMP(orr	r5, r5, #TTB_FLAGS_SMP)
 	ALT_SMP(orr	r5, r5, #TTB_FLAGS_SMP << 16)
 	ALT_UP(orr	r5, r5, #TTB_FLAGS_UP)
 	ALT_UP(orr	r5, r5, #TTB_FLAGS_UP << 16)
-	mrc	p15, 0, r10, c2, c0, 2
-	orr	r10, r10, r5
-#if PHYS_OFFSET <= PAGE_OFFSET
 	/*
-	 * TTBR0/TTBR1 split (PAGE_OFFSET):
-	 *   0x40000000: T0SZ = 2, T1SZ = 0 (not used)
-	 *   0x80000000: T0SZ = 0, T1SZ = 1
-	 *   0xc0000000: T0SZ = 0, T1SZ = 2
-	 *
-	 * Only use this feature if PAGE_OFFSET <=  PAGE_OFFSET, otherwise
-	 * booting secondary CPUs would end up using TTBR1 for the identity
-	 * mapping set up in TTBR0.
+	 * Only use split TTBRs if PHYS_OFFSET <= PAGE_OFFSET (cmp above),
+	 * otherwise booting secondary CPUs would end up using TTBR1 for the
+	 * identity mapping set up in TTBR0.
 	 */
-	orr	r10, r10, #(((PAGE_OFFSET >> 30) - 1) << 16)	@ TTBCR.T1SZ
-#endif
-	mcr	p15, 0, r10, c2, c0, 2		@ TTB control register
-	mov	r5, #0
-#if defined CONFIG_VMSPLIT_2G
-	/* PAGE_OFFSET == 0x80000000, T1SZ == 1 */
-	add	r6, r8, #1 << 4			@ skip two L1 entries
-#elif defined CONFIG_VMSPLIT_3G
-	/* PAGE_OFFSET == 0xc0000000, T1SZ == 2 */
-	add	r6, r8, #4096 * (1 + 3)		@ only L2 used, skip pgd+3*pmd
-#else
-	mov	r6, r8
-#endif
-	mcrr	p15, 1, r6, r5, c2		@ load TTBR1
+	orrls	r5, r5, #TTBR1_SIZE				@ TTBCR.T1SZ
+	mcr	p15, 0, r5, c2, c0, 2				@ TTBCR
+	mov	r5, r8, lsr #(32 - ARCH_PGD_SHIFT)	@ upper bits
+	mov	r8, r8, lsl #ARCH_PGD_SHIFT		@ lower bits
+	addls	r8, r8, #TTBR1_OFFSET
+	mcrr	p15, 1, r8, r10, c2			@ load TTBR1
+	mov     r5, r4, lsr #(32 - ARCH_PGD_SHIFT)	@ upper bits
+	mov	r4, r4, lsl #ARCH_PGD_SHIFT		@ lower bits
+	mcrr	p15, 0, r4, r10, c2			@ load TTBR0
+	mcrr	p15, 1, r8, r10, c2			@ load TTBR1
+	mcrr	p15, 0, r4, r10, c2			@ load TTBR0
+
 	ldr	r5, =MAIR0
 	ldr	r6, =MAIR1
 	mcr	p15, 0, r5, c10, c2, 0		@ write MAIR0
 	mcr	p15, 0, r6, c10, c2, 1		@ write MAIR1
 #endif
+	dsb
 	adr	r5, v7_crval
 	ldmia	r5, {r5, r6}
 #ifdef CONFIG_CPU_ENDIAN_BE8
-- 
1.7.5.4

